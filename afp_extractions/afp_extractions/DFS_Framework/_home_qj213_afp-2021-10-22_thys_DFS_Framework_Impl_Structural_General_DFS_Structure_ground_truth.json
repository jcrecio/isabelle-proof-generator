{"file_name": "/home/qj213/afp-2021-10-22/thys/DFS_Framework/Impl/Structural/General_DFS_Structure.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/DFS_Framework", "problem_names": ["lemmas [DFS_code_unfold] = \n  REC_annot_def (* TODO: Setup REC_annot for autoref!*)\n  GHOST_elim_Let (* TODO: Unfold in autoref. Can we (ab)use autoref_op_pat_def for that *)\n  comp_def", "lemmas pre_defs = pre_new_root_def pre_get_pending_def post_get_pending_def\n    pre_finish_def pre_cross_edge_def pre_back_edge_def pre_discover_def", "lemma gen_step_eq_assert: \"\\<lbrakk>gen_cond s; gen_rwof s\\<rbrakk>\n       \\<Longrightarrow> gen_step s = gen_step_assert s\"", "lemma gen_dfs_eq_assert: \"gen_dfs = gen_dfs_assert\"", "lemma gen_dfsT_eq_assert: \"gen_dfsT = gen_dfsT_assert\"", "lemma gen_rwof_eq_assert:\n    assumes NF: \"nofail gen_dfs\"\n    shows \"gen_rwof = gen_rwof_assert\"", "lemma gen_dfs_le_gen_dfsT: \"gen_dfs \\<le> gen_dfsT\"", "lemmas do_action_defs[DFS_code_unfold] = \n    do_action_def do_init_def do_new_root_def\n    do_finish_def do_back_edge_def do_cross_edge_def do_discover_def", "lemmas gds_simps[simp,DFS_code_unfold] \n    = gen_dfs_struct.simps[mk_record_simp, OF gds_def]", "lemmas gbs_simps[simp] = gen_basic_dfs_struct.simps[mk_record_simp, OF gbs_def]", "lemma gen_cond_simp[simp]: \"gen_dfs.gen_cond = cond\"", "lemma gen_step_simp[simp]: \"gen_dfs.gen_step = step\"", "lemma gen_init_simp[simp]: \"gen_dfs.do_init = init\"", "lemma gen_dfs_simp[simp]: \"gen_dfs.gen_dfs = it_dfs\"", "lemma gen_dfsT_simp[simp]: \"gen_dfs.gen_dfsT = it_dfsT\"", "lemma select_v0_refine[refine]:\n    assumes s_param: \"(si,s)\\<in>S\"\n    shows \"SPEC (\\<lambda>v0. v0 \\<in> V0i \\<and> \\<not> gds_is_discovered gdsi v0 si)\n           \\<le> \\<Down> V (SPEC (\\<lambda>v0. v0 \\<in> V0 \\<and> \\<not> gds_is_discovered gds v0 s))\"", "lemma gen_rwof_refine: \n    assumes NF: \"nofail (a.gen_dfs)\"\n    assumes RW: \"c.gen_rwof s\"\n    obtains s' where \"(s,s')\\<in>S\" and \"a.gen_rwof s'\"", "lemma gen_step_refine[refine]: \"(si,s)\\<in>S \\<Longrightarrow> c.gen_step si \\<le> \\<Down>S (a.gen_step_assert s)\"", "lemma gen_dfs_refine[refine]: \"c.gen_dfs \\<le> \\<Down>S a.gen_dfs\"", "lemma gen_dfsT_refine[refine]: \"c.gen_dfsT \\<le> \\<Down>S a.gen_dfsT\""], "translations": [["", "lemmas [DFS_code_unfold] = \n  REC_annot_def (* TODO: Setup REC_annot for autoref!*)\n  GHOST_elim_Let (* TODO: Unfold in autoref. Can we (ab)use autoref_op_pat_def for that *)\n  comp_def"], ["", "(* TODO: Setup transfer package to handle this ((RETURN o f) x) *)"], ["", "subsection \\<open>Generic DFS Algorithm\\<close>"], ["", "record ('v,'s) gen_dfs_struct = \n  gds_init :: \"'s nres\"\n  gds_is_break :: \"'s \\<Rightarrow> bool\"\n  gds_is_empty_stack :: \"'s \\<Rightarrow> bool\"\n  gds_new_root :: \"'v \\<Rightarrow> 's \\<Rightarrow> 's nres\"\n  gds_get_pending :: \"'s \\<Rightarrow> ('v \\<times> 'v option \\<times> 's) nres\"\n  gds_finish :: \"'v \\<Rightarrow> 's \\<Rightarrow> 's nres\"\n  gds_is_discovered :: \"'v \\<Rightarrow> 's \\<Rightarrow> bool\"\n  gds_is_finished :: \"'v \\<Rightarrow> 's \\<Rightarrow> bool\"\n  gds_back_edge :: \"'v \\<Rightarrow> 'v \\<Rightarrow> 's \\<Rightarrow> 's nres\"\n  gds_cross_edge :: \"'v \\<Rightarrow> 'v \\<Rightarrow> 's \\<Rightarrow> 's nres\"\n  gds_discover :: \"'v \\<Rightarrow> 'v \\<Rightarrow> 's \\<Rightarrow> 's nres\""], ["", "locale gen_dfs_defs =\n  fixes gds :: \"('v,'s) gen_dfs_struct\"\n  fixes V0 :: \"'v set\"\nbegin"], ["", "definition \"gen_step s \\<equiv> \n    if gds_is_empty_stack gds s then do {\n      v0 \\<leftarrow> SPEC (\\<lambda>v0. v0\\<in>V0 \\<and> \\<not>gds_is_discovered gds v0 s);\n      gds_new_root gds v0 s\n    } else  do {\n        (u,Vs,s) \\<leftarrow> gds_get_pending gds s;\n        case Vs of \n          None \\<Rightarrow> gds_finish gds u s \n        | Some v \\<Rightarrow> do {\n          if gds_is_discovered gds v s then (\n            if gds_is_finished gds v s then\n              gds_cross_edge gds u v s\n            else\n              gds_back_edge gds u v s\n          ) else \n            gds_discover gds u v s\n        }\n      }\""], ["", "definition \"gen_cond  s \n    \\<equiv> (V0 \\<subseteq> {v. gds_is_discovered gds v s} \\<longrightarrow> \\<not>gds_is_empty_stack gds s)\n      \\<and> \\<not>gds_is_break gds s\""], ["", "definition \"gen_dfs \n    \\<equiv> gds_init gds \\<bind> WHILE gen_cond gen_step\""], ["", "definition \"gen_dfsT \n    \\<equiv> gds_init gds \\<bind> WHILET gen_cond gen_step\""], ["", "abbreviation \"gen_discovered s \\<equiv> {v . gds_is_discovered gds v s}\""], ["", "abbreviation \"gen_rwof \\<equiv> rwof (gds_init gds) gen_cond gen_step\""], ["", "definition \"pre_new_root v0 s \\<equiv> \n    gen_rwof s \\<and> gds_is_empty_stack gds s \\<and> \\<not>gds_is_break gds s \n    \\<and> v0\\<in>V0 - gen_discovered s\""], ["", "definition \"pre_get_pending s \\<equiv>\n    gen_rwof s \\<and> \\<not>gds_is_empty_stack gds s \\<and> \\<not>gds_is_break gds s\""], ["", "definition \"post_get_pending u Vs s0 s \\<equiv> pre_get_pending s0 \n    \\<and> inres (gds_get_pending gds s0) (u,Vs,s)\""], ["", "definition \"pre_finish u s0 s \\<equiv> post_get_pending u None s0 s\""], ["", "definition \"pre_cross_edge u v s0 s \\<equiv> \n    post_get_pending u (Some v) s0 s \\<and> gds_is_discovered gds v s \n    \\<and> gds_is_finished gds v s\""], ["", "definition \"pre_back_edge u v s0 s \\<equiv> \n    post_get_pending u (Some v) s0 s \\<and> gds_is_discovered gds v s \n      \\<and> \\<not>gds_is_finished gds v s\""], ["", "definition \"pre_discover u v s0 s \\<equiv> \n    post_get_pending u (Some v) s0 s \\<and> \\<not>gds_is_discovered gds v s\""], ["", "lemmas pre_defs = pre_new_root_def pre_get_pending_def post_get_pending_def\n    pre_finish_def pre_cross_edge_def pre_back_edge_def pre_discover_def"], ["", "definition \"gen_step_assert s \\<equiv> \n    if gds_is_empty_stack gds s then do {\n      v0 \\<leftarrow> SPEC (\\<lambda>v0. v0\\<in>V0 \\<and> \\<not>gds_is_discovered gds v0 s);\n      ASSERT (pre_new_root v0 s);\n      gds_new_root gds v0 s\n    } else do {\n        ASSERT (pre_get_pending s);\n        let s0=GHOST s;\n        (u,Vs,s) \\<leftarrow> gds_get_pending gds s;\n        case Vs of \n          None \\<Rightarrow> do {ASSERT (pre_finish u s0 s); gds_finish gds u s}\n        | Some v \\<Rightarrow> do {\n          if gds_is_discovered gds v s then do {\n            if gds_is_finished gds v s then do {\n              ASSERT (pre_cross_edge u v s0 s);\n              gds_cross_edge gds u v s\n            } else do {\n              ASSERT (pre_back_edge u v s0 s);\n              gds_back_edge gds u v s\n            }\n          } else do {\n            ASSERT (pre_discover u v s0 s);\n            gds_discover gds u v s\n          }\n        }\n      }\""], ["", "definition \"gen_dfs_assert \n    \\<equiv> gds_init gds \\<bind> WHILE gen_cond gen_step_assert\""], ["", "definition \"gen_dfsT_assert \n    \\<equiv> gds_init gds \\<bind> WHILET gen_cond gen_step_assert\""], ["", "abbreviation \"gen_rwof_assert \\<equiv> rwof (gds_init gds) gen_cond gen_step_assert\""], ["", "lemma gen_step_eq_assert: \"\\<lbrakk>gen_cond s; gen_rwof s\\<rbrakk>\n       \\<Longrightarrow> gen_step s = gen_step_assert s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>gen_cond s; gen_rwof s\\<rbrakk>\n    \\<Longrightarrow> gen_step s = gen_step_assert s", "apply (rule antisym)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>gen_cond s; gen_rwof s\\<rbrakk>\n    \\<Longrightarrow> gen_step s \\<le> gen_step_assert s\n 2. \\<lbrakk>gen_cond s; gen_rwof s\\<rbrakk>\n    \\<Longrightarrow> gen_step_assert s \\<le> gen_step s", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>gen_cond s; gen_rwof s\\<rbrakk>\n    \\<Longrightarrow> gen_step s \\<le> gen_step_assert s", "apply (unfold gen_step_def[abs_def] gen_step_assert_def[abs_def]) []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>gen_cond s;\n     rwof (gds_init gds) gen_cond\n      (\\<lambda>s.\n          if gds_is_empty_stack gds s\n          then SPEC\n                (\\<lambda>v0.\n                    v0 \\<in> V0 \\<and>\n                    \\<not> gds_is_discovered gds v0 s) \\<bind>\n               (\\<lambda>v0. gds_new_root gds v0 s)\n          else gds_get_pending gds s \\<bind>\n               (\\<lambda>(u, Vs, s).\n                   case Vs of None \\<Rightarrow> gds_finish gds u s\n                   | Some v \\<Rightarrow>\n                       if gds_is_discovered gds v s\n                       then if gds_is_finished gds v s\n                            then gds_cross_edge gds u v s\n                            else gds_back_edge gds u v s\n                       else gds_discover gds u v s))\n      s\\<rbrakk>\n    \\<Longrightarrow> (if gds_is_empty_stack gds s\n                       then SPEC\n                             (\\<lambda>v0.\n                                 v0 \\<in> V0 \\<and>\n                                 \\<not> gds_is_discovered gds v0 s) \\<bind>\n                            (\\<lambda>v0. gds_new_root gds v0 s)\n                       else gds_get_pending gds s \\<bind>\n                            (\\<lambda>(u, Vs, s).\n                                case Vs of\n                                None \\<Rightarrow> gds_finish gds u s\n                                | Some v \\<Rightarrow>\n                                    if gds_is_discovered gds v s\n                                    then if gds_is_finished gds v s\n   then gds_cross_edge gds u v s else gds_back_edge gds u v s\n                                    else gds_discover gds u v s))\n                      \\<le> (if gds_is_empty_stack gds s\n                             then SPEC\n                                   (\\<lambda>v0.\n v0 \\<in> V0 \\<and> \\<not> gds_is_discovered gds v0 s) \\<bind>\n                                  (\\<lambda>v0.\nASSERT (pre_new_root v0 s) \\<bind> (\\<lambda>_. gds_new_root gds v0 s))\n                             else ASSERT (pre_get_pending s) \\<bind>\n                                  (\\<lambda>_.\nlet s0 = GHOST s\nin gds_get_pending gds s \\<bind>\n   (\\<lambda>(u, Vs, s).\n       case Vs of\n       None \\<Rightarrow>\n         ASSERT (pre_finish u s0 s) \\<bind> (\\<lambda>_. gds_finish gds u s)\n       | Some v \\<Rightarrow>\n           if gds_is_discovered gds v s\n           then if gds_is_finished gds v s\n                then ASSERT (pre_cross_edge u v s0 s) \\<bind>\n                     (\\<lambda>_. gds_cross_edge gds u v s)\n                else ASSERT (pre_back_edge u v s0 s) \\<bind>\n                     (\\<lambda>_. gds_back_edge gds u v s)\n           else ASSERT (pre_discover u v s0 s) \\<bind>\n                (\\<lambda>_. gds_discover gds u v s))))", "apply (unfold GHOST_elim_Let) []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>gen_cond s;\n     rwof (gds_init gds) gen_cond\n      (\\<lambda>s.\n          if gds_is_empty_stack gds s\n          then SPEC\n                (\\<lambda>v0.\n                    v0 \\<in> V0 \\<and>\n                    \\<not> gds_is_discovered gds v0 s) \\<bind>\n               (\\<lambda>v0. gds_new_root gds v0 s)\n          else gds_get_pending gds s \\<bind>\n               (\\<lambda>(u, Vs, s).\n                   case Vs of None \\<Rightarrow> gds_finish gds u s\n                   | Some v \\<Rightarrow>\n                       if gds_is_discovered gds v s\n                       then if gds_is_finished gds v s\n                            then gds_cross_edge gds u v s\n                            else gds_back_edge gds u v s\n                       else gds_discover gds u v s))\n      s\\<rbrakk>\n    \\<Longrightarrow> (if gds_is_empty_stack gds s\n                       then SPEC\n                             (\\<lambda>v0.\n                                 v0 \\<in> V0 \\<and>\n                                 \\<not> gds_is_discovered gds v0 s) \\<bind>\n                            (\\<lambda>v0. gds_new_root gds v0 s)\n                       else gds_get_pending gds s \\<bind>\n                            (\\<lambda>(u, Vs, s).\n                                case Vs of\n                                None \\<Rightarrow> gds_finish gds u s\n                                | Some v \\<Rightarrow>\n                                    if gds_is_discovered gds v s\n                                    then if gds_is_finished gds v s\n   then gds_cross_edge gds u v s else gds_back_edge gds u v s\n                                    else gds_discover gds u v s))\n                      \\<le> (if gds_is_empty_stack gds s\n                             then SPEC\n                                   (\\<lambda>v0.\n v0 \\<in> V0 \\<and> \\<not> gds_is_discovered gds v0 s) \\<bind>\n                                  (\\<lambda>v0.\nASSERT (pre_new_root v0 s) \\<bind> (\\<lambda>_. gds_new_root gds v0 s))\n                             else ASSERT (pre_get_pending s) \\<bind>\n                                  (\\<lambda>_.\ngds_get_pending gds s \\<bind>\n(\\<lambda>(u, Vs, sa).\n    case Vs of\n    None \\<Rightarrow>\n      ASSERT (pre_finish u s sa) \\<bind> (\\<lambda>_. gds_finish gds u sa)\n    | Some v \\<Rightarrow>\n        if gds_is_discovered gds v sa\n        then if gds_is_finished gds v sa\n             then ASSERT (pre_cross_edge u v s sa) \\<bind>\n                  (\\<lambda>_. gds_cross_edge gds u v sa)\n             else ASSERT (pre_back_edge u v s sa) \\<bind>\n                  (\\<lambda>_. gds_back_edge gds u v sa)\n        else ASSERT (pre_discover u v s sa) \\<bind>\n             (\\<lambda>_. gds_discover gds u v sa))))", "apply (rule refine_IdD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>gen_cond s;\n     rwof (gds_init gds) gen_cond\n      (\\<lambda>s.\n          if gds_is_empty_stack gds s\n          then SPEC\n                (\\<lambda>v0.\n                    v0 \\<in> V0 \\<and>\n                    \\<not> gds_is_discovered gds v0 s) \\<bind>\n               (\\<lambda>v0. gds_new_root gds v0 s)\n          else gds_get_pending gds s \\<bind>\n               (\\<lambda>(u, Vs, s).\n                   case Vs of None \\<Rightarrow> gds_finish gds u s\n                   | Some v \\<Rightarrow>\n                       if gds_is_discovered gds v s\n                       then if gds_is_finished gds v s\n                            then gds_cross_edge gds u v s\n                            else gds_back_edge gds u v s\n                       else gds_discover gds u v s))\n      s\\<rbrakk>\n    \\<Longrightarrow> (if gds_is_empty_stack gds s\n                       then SPEC\n                             (\\<lambda>v0.\n                                 v0 \\<in> V0 \\<and>\n                                 \\<not> gds_is_discovered gds v0 s) \\<bind>\n                            (\\<lambda>v0. gds_new_root gds v0 s)\n                       else gds_get_pending gds s \\<bind>\n                            (\\<lambda>(u, Vs, s).\n                                case Vs of\n                                None \\<Rightarrow> gds_finish gds u s\n                                | Some v \\<Rightarrow>\n                                    if gds_is_discovered gds v s\n                                    then if gds_is_finished gds v s\n   then gds_cross_edge gds u v s else gds_back_edge gds u v s\n                                    else gds_discover gds u v s))\n                      \\<le> \\<Down> Id\n                             (if gds_is_empty_stack gds s\n                              then SPEC\n                                    (\\<lambda>v0.\n  v0 \\<in> V0 \\<and> \\<not> gds_is_discovered gds v0 s) \\<bind>\n                                   (\\<lambda>v0.\n ASSERT (pre_new_root v0 s) \\<bind> (\\<lambda>_. gds_new_root gds v0 s))\n                              else ASSERT (pre_get_pending s) \\<bind>\n                                   (\\<lambda>_.\n gds_get_pending gds s \\<bind>\n (\\<lambda>(u, Vs, sa).\n     case Vs of\n     None \\<Rightarrow>\n       ASSERT (pre_finish u s sa) \\<bind> (\\<lambda>_. gds_finish gds u sa)\n     | Some v \\<Rightarrow>\n         if gds_is_discovered gds v sa\n         then if gds_is_finished gds v sa\n              then ASSERT (pre_cross_edge u v s sa) \\<bind>\n                   (\\<lambda>_. gds_cross_edge gds u v sa)\n              else ASSERT (pre_back_edge u v s sa) \\<bind>\n                   (\\<lambda>_. gds_back_edge gds u v sa)\n         else ASSERT (pre_discover u v s sa) \\<bind>\n              (\\<lambda>_. gds_discover gds u v sa))))", "apply refine_rcg"], ["proof (prove)\ngoal (9 subgoals):\n 1. \\<lbrakk>gen_cond s;\n     rwof (gds_init gds) gen_cond\n      (\\<lambda>s.\n          if gds_is_empty_stack gds s\n          then SPEC\n                (\\<lambda>v0.\n                    v0 \\<in> V0 \\<and>\n                    \\<not> gds_is_discovered gds v0 s) \\<bind>\n               (\\<lambda>v0. gds_new_root gds v0 s)\n          else gds_get_pending gds s \\<bind>\n               (\\<lambda>(u, Vs, s).\n                   case Vs of None \\<Rightarrow> gds_finish gds u s\n                   | Some v \\<Rightarrow>\n                       if gds_is_discovered gds v s\n                       then if gds_is_finished gds v s\n                            then gds_cross_edge gds u v s\n                            else gds_back_edge gds u v s\n                       else gds_discover gds u v s))\n      s\\<rbrakk>\n    \\<Longrightarrow> gds_is_empty_stack gds s = gds_is_empty_stack gds s\n 2. \\<And>v0 v0a.\n       \\<lbrakk>gen_cond s;\n        rwof (gds_init gds) gen_cond\n         (\\<lambda>s.\n             if gds_is_empty_stack gds s\n             then SPEC\n                   (\\<lambda>v0.\n                       v0 \\<in> V0 \\<and>\n                       \\<not> gds_is_discovered gds v0 s) \\<bind>\n                  (\\<lambda>v0. gds_new_root gds v0 s)\n             else gds_get_pending gds s \\<bind>\n                  (\\<lambda>(u, Vs, s).\n                      case Vs of None \\<Rightarrow> gds_finish gds u s\n                      | Some v \\<Rightarrow>\n                          if gds_is_discovered gds v s\n                          then if gds_is_finished gds v s\n                               then gds_cross_edge gds u v s\n                               else gds_back_edge gds u v s\n                          else gds_discover gds u v s))\n         s;\n        gds_is_empty_stack gds s; gds_is_empty_stack gds s;\n        (v0, v0a) \\<in> Id;\n        v0 \\<in> {v0 \\<in> V0. \\<not> gds_is_discovered gds v0 s};\n        v0a \\<in> {v0 \\<in> V0. \\<not> gds_is_discovered gds v0 s};\n        pre_new_root v0a s\\<rbrakk>\n       \\<Longrightarrow> gds_new_root gds v0 s\n                         \\<le> \\<Down> Id (gds_new_root gds v0a s)\n 3. \\<And>x x' x1 x2 x1a x2a x1b x2b x1c x2c.\n       \\<lbrakk>gen_cond s;\n        rwof (gds_init gds) gen_cond\n         (\\<lambda>s.\n             if gds_is_empty_stack gds s\n             then SPEC\n                   (\\<lambda>v0.\n                       v0 \\<in> V0 \\<and>\n                       \\<not> gds_is_discovered gds v0 s) \\<bind>\n                  (\\<lambda>v0. gds_new_root gds v0 s)\n             else gds_get_pending gds s \\<bind>\n                  (\\<lambda>(u, Vs, s).\n                      case Vs of None \\<Rightarrow> gds_finish gds u s\n                      | Some v \\<Rightarrow>\n                          if gds_is_discovered gds v s\n                          then if gds_is_finished gds v s\n                               then gds_cross_edge gds u v s\n                               else gds_back_edge gds u v s\n                          else gds_discover gds u v s))\n         s;\n        \\<not> gds_is_empty_stack gds s; \\<not> gds_is_empty_stack gds s;\n        pre_get_pending s; (x, x') \\<in> Id; x2 = (x1a, x2a); x' = (x1, x2);\n        x2b = (x1c, x2c); x = (x1b, x2b)\\<rbrakk>\n       \\<Longrightarrow> (x1c, x1a)\n                         \\<in> \\<langle>?Ra65 x x' x1 x2 x1a x2a x1b x2b x1c\n   x2c\\<rangle>option_rel\n 4. \\<And>x x' x1 x2 x1a x2a x1b x2b x1c x2c.\n       \\<lbrakk>gen_cond s;\n        rwof (gds_init gds) gen_cond\n         (\\<lambda>s.\n             if gds_is_empty_stack gds s\n             then SPEC\n                   (\\<lambda>v0.\n                       v0 \\<in> V0 \\<and>\n                       \\<not> gds_is_discovered gds v0 s) \\<bind>\n                  (\\<lambda>v0. gds_new_root gds v0 s)\n             else gds_get_pending gds s \\<bind>\n                  (\\<lambda>(u, Vs, s).\n                      case Vs of None \\<Rightarrow> gds_finish gds u s\n                      | Some v \\<Rightarrow>\n                          if gds_is_discovered gds v s\n                          then if gds_is_finished gds v s\n                               then gds_cross_edge gds u v s\n                               else gds_back_edge gds u v s\n                          else gds_discover gds u v s))\n         s;\n        \\<not> gds_is_empty_stack gds s; \\<not> gds_is_empty_stack gds s;\n        pre_get_pending s; (x, x') \\<in> Id; x2 = (x1a, x2a); x' = (x1, x2);\n        x2b = (x1c, x2c); x = (x1b, x2b); x1c = None; x1a = None;\n        pre_finish x1 s x2a\\<rbrakk>\n       \\<Longrightarrow> gds_finish gds x1b x2c\n                         \\<le> \\<Down> Id (gds_finish gds x1 x2a)\n 5. \\<And>x x' x1 x2 x1a x2a x1b x2b x1c x2c xa x'a.\n       \\<lbrakk>gen_cond s;\n        rwof (gds_init gds) gen_cond\n         (\\<lambda>s.\n             if gds_is_empty_stack gds s\n             then SPEC\n                   (\\<lambda>v0.\n                       v0 \\<in> V0 \\<and>\n                       \\<not> gds_is_discovered gds v0 s) \\<bind>\n                  (\\<lambda>v0. gds_new_root gds v0 s)\n             else gds_get_pending gds s \\<bind>\n                  (\\<lambda>(u, Vs, s).\n                      case Vs of None \\<Rightarrow> gds_finish gds u s\n                      | Some v \\<Rightarrow>\n                          if gds_is_discovered gds v s\n                          then if gds_is_finished gds v s\n                               then gds_cross_edge gds u v s\n                               else gds_back_edge gds u v s\n                          else gds_discover gds u v s))\n         s;\n        \\<not> gds_is_empty_stack gds s; \\<not> gds_is_empty_stack gds s;\n        pre_get_pending s; (x, x') \\<in> Id; x2 = (x1a, x2a); x' = (x1, x2);\n        x2b = (x1c, x2c); x = (x1b, x2b); x1c = Some xa; x1a = Some x'a;\n        (xa, x'a) \\<in> ?Ra65 x x' x1 x2 x1a x2a x1b x2b x1c x2c\\<rbrakk>\n       \\<Longrightarrow> gds_is_discovered gds xa x2c =\n                         gds_is_discovered gds x'a x2a\n 6. \\<And>x x' x1 x2 x1a x2a x1b x2b x1c x2c xa x'a.\n       \\<lbrakk>gen_cond s;\n        rwof (gds_init gds) gen_cond\n         (\\<lambda>s.\n             if gds_is_empty_stack gds s\n             then SPEC\n                   (\\<lambda>v0.\n                       v0 \\<in> V0 \\<and>\n                       \\<not> gds_is_discovered gds v0 s) \\<bind>\n                  (\\<lambda>v0. gds_new_root gds v0 s)\n             else gds_get_pending gds s \\<bind>\n                  (\\<lambda>(u, Vs, s).\n                      case Vs of None \\<Rightarrow> gds_finish gds u s\n                      | Some v \\<Rightarrow>\n                          if gds_is_discovered gds v s\n                          then if gds_is_finished gds v s\n                               then gds_cross_edge gds u v s\n                               else gds_back_edge gds u v s\n                          else gds_discover gds u v s))\n         s;\n        \\<not> gds_is_empty_stack gds s; \\<not> gds_is_empty_stack gds s;\n        pre_get_pending s; (x, x') \\<in> Id; x2 = (x1a, x2a); x' = (x1, x2);\n        x2b = (x1c, x2c); x = (x1b, x2b); x1c = Some xa; x1a = Some x'a;\n        (xa, x'a) \\<in> ?Ra65 x x' x1 x2 x1a x2a x1b x2b x1c x2c;\n        gds_is_discovered gds xa x2c; gds_is_discovered gds x'a x2a\\<rbrakk>\n       \\<Longrightarrow> gds_is_finished gds xa x2c =\n                         gds_is_finished gds x'a x2a\n 7. \\<And>x x' x1 x2 x1a x2a x1b x2b x1c x2c xa x'a.\n       \\<lbrakk>gen_cond s;\n        rwof (gds_init gds) gen_cond\n         (\\<lambda>s.\n             if gds_is_empty_stack gds s\n             then SPEC\n                   (\\<lambda>v0.\n                       v0 \\<in> V0 \\<and>\n                       \\<not> gds_is_discovered gds v0 s) \\<bind>\n                  (\\<lambda>v0. gds_new_root gds v0 s)\n             else gds_get_pending gds s \\<bind>\n                  (\\<lambda>(u, Vs, s).\n                      case Vs of None \\<Rightarrow> gds_finish gds u s\n                      | Some v \\<Rightarrow>\n                          if gds_is_discovered gds v s\n                          then if gds_is_finished gds v s\n                               then gds_cross_edge gds u v s\n                               else gds_back_edge gds u v s\n                          else gds_discover gds u v s))\n         s;\n        \\<not> gds_is_empty_stack gds s; \\<not> gds_is_empty_stack gds s;\n        pre_get_pending s; (x, x') \\<in> Id; x2 = (x1a, x2a); x' = (x1, x2);\n        x2b = (x1c, x2c); x = (x1b, x2b); x1c = Some xa; x1a = Some x'a;\n        (xa, x'a) \\<in> ?Ra65 x x' x1 x2 x1a x2a x1b x2b x1c x2c;\n        gds_is_discovered gds xa x2c; gds_is_discovered gds x'a x2a;\n        gds_is_finished gds xa x2c; gds_is_finished gds x'a x2a;\n        pre_cross_edge x1 x'a s x2a\\<rbrakk>\n       \\<Longrightarrow> gds_cross_edge gds x1b xa x2c\n                         \\<le> \\<Down> Id (gds_cross_edge gds x1 x'a x2a)\n 8. \\<And>x x' x1 x2 x1a x2a x1b x2b x1c x2c xa x'a.\n       \\<lbrakk>gen_cond s;\n        rwof (gds_init gds) gen_cond\n         (\\<lambda>s.\n             if gds_is_empty_stack gds s\n             then SPEC\n                   (\\<lambda>v0.\n                       v0 \\<in> V0 \\<and>\n                       \\<not> gds_is_discovered gds v0 s) \\<bind>\n                  (\\<lambda>v0. gds_new_root gds v0 s)\n             else gds_get_pending gds s \\<bind>\n                  (\\<lambda>(u, Vs, s).\n                      case Vs of None \\<Rightarrow> gds_finish gds u s\n                      | Some v \\<Rightarrow>\n                          if gds_is_discovered gds v s\n                          then if gds_is_finished gds v s\n                               then gds_cross_edge gds u v s\n                               else gds_back_edge gds u v s\n                          else gds_discover gds u v s))\n         s;\n        \\<not> gds_is_empty_stack gds s; \\<not> gds_is_empty_stack gds s;\n        pre_get_pending s; (x, x') \\<in> Id; x2 = (x1a, x2a); x' = (x1, x2);\n        x2b = (x1c, x2c); x = (x1b, x2b); x1c = Some xa; x1a = Some x'a;\n        (xa, x'a) \\<in> ?Ra65 x x' x1 x2 x1a x2a x1b x2b x1c x2c;\n        gds_is_discovered gds xa x2c; gds_is_discovered gds x'a x2a;\n        \\<not> gds_is_finished gds xa x2c;\n        \\<not> gds_is_finished gds x'a x2a;\n        pre_back_edge x1 x'a s x2a\\<rbrakk>\n       \\<Longrightarrow> gds_back_edge gds x1b xa x2c\n                         \\<le> \\<Down> Id (gds_back_edge gds x1 x'a x2a)\n 9. \\<And>x x' x1 x2 x1a x2a x1b x2b x1c x2c xa x'a.\n       \\<lbrakk>gen_cond s;\n        rwof (gds_init gds) gen_cond\n         (\\<lambda>s.\n             if gds_is_empty_stack gds s\n             then SPEC\n                   (\\<lambda>v0.\n                       v0 \\<in> V0 \\<and>\n                       \\<not> gds_is_discovered gds v0 s) \\<bind>\n                  (\\<lambda>v0. gds_new_root gds v0 s)\n             else gds_get_pending gds s \\<bind>\n                  (\\<lambda>(u, Vs, s).\n                      case Vs of None \\<Rightarrow> gds_finish gds u s\n                      | Some v \\<Rightarrow>\n                          if gds_is_discovered gds v s\n                          then if gds_is_finished gds v s\n                               then gds_cross_edge gds u v s\n                               else gds_back_edge gds u v s\n                          else gds_discover gds u v s))\n         s;\n        \\<not> gds_is_empty_stack gds s; \\<not> gds_is_empty_stack gds s;\n        pre_get_pending s; (x, x') \\<in> Id; x2 = (x1a, x2a); x' = (x1, x2);\n        x2b = (x1c, x2c); x = (x1b, x2b); x1c = Some xa; x1a = Some x'a;\n        (xa, x'a) \\<in> ?Ra65 x x' x1 x2 x1a x2a x1b x2b x1c x2c;\n        \\<not> gds_is_discovered gds xa x2c;\n        \\<not> gds_is_discovered gds x'a x2a;\n        pre_discover x1 x'a s x2a\\<rbrakk>\n       \\<Longrightarrow> gds_discover gds x1b xa x2c\n                         \\<le> \\<Down> Id (gds_discover gds x1 x'a x2a)", "apply refine_dref_type"], ["proof (prove)\ngoal (9 subgoals):\n 1. \\<lbrakk>gen_cond s;\n     rwof (gds_init gds) gen_cond\n      (\\<lambda>s.\n          if gds_is_empty_stack gds s\n          then SPEC\n                (\\<lambda>v0.\n                    v0 \\<in> V0 \\<and>\n                    \\<not> gds_is_discovered gds v0 s) \\<bind>\n               (\\<lambda>v0. gds_new_root gds v0 s)\n          else gds_get_pending gds s \\<bind>\n               (\\<lambda>(u, Vs, s).\n                   case Vs of None \\<Rightarrow> gds_finish gds u s\n                   | Some v \\<Rightarrow>\n                       if gds_is_discovered gds v s\n                       then if gds_is_finished gds v s\n                            then gds_cross_edge gds u v s\n                            else gds_back_edge gds u v s\n                       else gds_discover gds u v s))\n      s\\<rbrakk>\n    \\<Longrightarrow> gds_is_empty_stack gds s = gds_is_empty_stack gds s\n 2. \\<And>v0 v0a.\n       \\<lbrakk>gen_cond s;\n        rwof (gds_init gds) gen_cond\n         (\\<lambda>s.\n             if gds_is_empty_stack gds s\n             then SPEC\n                   (\\<lambda>v0.\n                       v0 \\<in> V0 \\<and>\n                       \\<not> gds_is_discovered gds v0 s) \\<bind>\n                  (\\<lambda>v0. gds_new_root gds v0 s)\n             else gds_get_pending gds s \\<bind>\n                  (\\<lambda>(u, Vs, s).\n                      case Vs of None \\<Rightarrow> gds_finish gds u s\n                      | Some v \\<Rightarrow>\n                          if gds_is_discovered gds v s\n                          then if gds_is_finished gds v s\n                               then gds_cross_edge gds u v s\n                               else gds_back_edge gds u v s\n                          else gds_discover gds u v s))\n         s;\n        gds_is_empty_stack gds s; gds_is_empty_stack gds s;\n        (v0, v0a) \\<in> Id;\n        v0 \\<in> {v0 \\<in> V0. \\<not> gds_is_discovered gds v0 s};\n        v0a \\<in> {v0 \\<in> V0. \\<not> gds_is_discovered gds v0 s};\n        pre_new_root v0a s\\<rbrakk>\n       \\<Longrightarrow> gds_new_root gds v0 s\n                         \\<le> \\<Down> Id (gds_new_root gds v0a s)\n 3. \\<And>x x' x1 x2 x1a x2a x1b x2b x1c x2c.\n       \\<lbrakk>gen_cond s;\n        rwof (gds_init gds) gen_cond\n         (\\<lambda>s.\n             if gds_is_empty_stack gds s\n             then SPEC\n                   (\\<lambda>v0.\n                       v0 \\<in> V0 \\<and>\n                       \\<not> gds_is_discovered gds v0 s) \\<bind>\n                  (\\<lambda>v0. gds_new_root gds v0 s)\n             else gds_get_pending gds s \\<bind>\n                  (\\<lambda>(u, Vs, s).\n                      case Vs of None \\<Rightarrow> gds_finish gds u s\n                      | Some v \\<Rightarrow>\n                          if gds_is_discovered gds v s\n                          then if gds_is_finished gds v s\n                               then gds_cross_edge gds u v s\n                               else gds_back_edge gds u v s\n                          else gds_discover gds u v s))\n         s;\n        \\<not> gds_is_empty_stack gds s; \\<not> gds_is_empty_stack gds s;\n        pre_get_pending s; (x, x') \\<in> Id; x2 = (x1a, x2a); x' = (x1, x2);\n        x2b = (x1c, x2c); x = (x1b, x2b)\\<rbrakk>\n       \\<Longrightarrow> (x1c, x1a) \\<in> \\<langle>Id\\<rangle>option_rel\n 4. \\<And>x x' x1 x2 x1a x2a x1b x2b x1c x2c.\n       \\<lbrakk>gen_cond s;\n        rwof (gds_init gds) gen_cond\n         (\\<lambda>s.\n             if gds_is_empty_stack gds s\n             then SPEC\n                   (\\<lambda>v0.\n                       v0 \\<in> V0 \\<and>\n                       \\<not> gds_is_discovered gds v0 s) \\<bind>\n                  (\\<lambda>v0. gds_new_root gds v0 s)\n             else gds_get_pending gds s \\<bind>\n                  (\\<lambda>(u, Vs, s).\n                      case Vs of None \\<Rightarrow> gds_finish gds u s\n                      | Some v \\<Rightarrow>\n                          if gds_is_discovered gds v s\n                          then if gds_is_finished gds v s\n                               then gds_cross_edge gds u v s\n                               else gds_back_edge gds u v s\n                          else gds_discover gds u v s))\n         s;\n        \\<not> gds_is_empty_stack gds s; \\<not> gds_is_empty_stack gds s;\n        pre_get_pending s; (x, x') \\<in> Id; x2 = (x1a, x2a); x' = (x1, x2);\n        x2b = (x1c, x2c); x = (x1b, x2b); x1c = None; x1a = None;\n        pre_finish x1 s x2a\\<rbrakk>\n       \\<Longrightarrow> gds_finish gds x1b x2c\n                         \\<le> \\<Down> Id (gds_finish gds x1 x2a)\n 5. \\<And>x x' x1 x2 x1a x2a x1b x2b x1c x2c xa x'a.\n       \\<lbrakk>gen_cond s;\n        rwof (gds_init gds) gen_cond\n         (\\<lambda>s.\n             if gds_is_empty_stack gds s\n             then SPEC\n                   (\\<lambda>v0.\n                       v0 \\<in> V0 \\<and>\n                       \\<not> gds_is_discovered gds v0 s) \\<bind>\n                  (\\<lambda>v0. gds_new_root gds v0 s)\n             else gds_get_pending gds s \\<bind>\n                  (\\<lambda>(u, Vs, s).\n                      case Vs of None \\<Rightarrow> gds_finish gds u s\n                      | Some v \\<Rightarrow>\n                          if gds_is_discovered gds v s\n                          then if gds_is_finished gds v s\n                               then gds_cross_edge gds u v s\n                               else gds_back_edge gds u v s\n                          else gds_discover gds u v s))\n         s;\n        \\<not> gds_is_empty_stack gds s; \\<not> gds_is_empty_stack gds s;\n        pre_get_pending s; (x, x') \\<in> Id; x2 = (x1a, x2a); x' = (x1, x2);\n        x2b = (x1c, x2c); x = (x1b, x2b); x1c = Some xa; x1a = Some x'a;\n        (xa, x'a) \\<in> Id\\<rbrakk>\n       \\<Longrightarrow> gds_is_discovered gds xa x2c =\n                         gds_is_discovered gds x'a x2a\n 6. \\<And>x x' x1 x2 x1a x2a x1b x2b x1c x2c xa x'a.\n       \\<lbrakk>gen_cond s;\n        rwof (gds_init gds) gen_cond\n         (\\<lambda>s.\n             if gds_is_empty_stack gds s\n             then SPEC\n                   (\\<lambda>v0.\n                       v0 \\<in> V0 \\<and>\n                       \\<not> gds_is_discovered gds v0 s) \\<bind>\n                  (\\<lambda>v0. gds_new_root gds v0 s)\n             else gds_get_pending gds s \\<bind>\n                  (\\<lambda>(u, Vs, s).\n                      case Vs of None \\<Rightarrow> gds_finish gds u s\n                      | Some v \\<Rightarrow>\n                          if gds_is_discovered gds v s\n                          then if gds_is_finished gds v s\n                               then gds_cross_edge gds u v s\n                               else gds_back_edge gds u v s\n                          else gds_discover gds u v s))\n         s;\n        \\<not> gds_is_empty_stack gds s; \\<not> gds_is_empty_stack gds s;\n        pre_get_pending s; (x, x') \\<in> Id; x2 = (x1a, x2a); x' = (x1, x2);\n        x2b = (x1c, x2c); x = (x1b, x2b); x1c = Some xa; x1a = Some x'a;\n        (xa, x'a) \\<in> Id; gds_is_discovered gds xa x2c;\n        gds_is_discovered gds x'a x2a\\<rbrakk>\n       \\<Longrightarrow> gds_is_finished gds xa x2c =\n                         gds_is_finished gds x'a x2a\n 7. \\<And>x x' x1 x2 x1a x2a x1b x2b x1c x2c xa x'a.\n       \\<lbrakk>gen_cond s;\n        rwof (gds_init gds) gen_cond\n         (\\<lambda>s.\n             if gds_is_empty_stack gds s\n             then SPEC\n                   (\\<lambda>v0.\n                       v0 \\<in> V0 \\<and>\n                       \\<not> gds_is_discovered gds v0 s) \\<bind>\n                  (\\<lambda>v0. gds_new_root gds v0 s)\n             else gds_get_pending gds s \\<bind>\n                  (\\<lambda>(u, Vs, s).\n                      case Vs of None \\<Rightarrow> gds_finish gds u s\n                      | Some v \\<Rightarrow>\n                          if gds_is_discovered gds v s\n                          then if gds_is_finished gds v s\n                               then gds_cross_edge gds u v s\n                               else gds_back_edge gds u v s\n                          else gds_discover gds u v s))\n         s;\n        \\<not> gds_is_empty_stack gds s; \\<not> gds_is_empty_stack gds s;\n        pre_get_pending s; (x, x') \\<in> Id; x2 = (x1a, x2a); x' = (x1, x2);\n        x2b = (x1c, x2c); x = (x1b, x2b); x1c = Some xa; x1a = Some x'a;\n        (xa, x'a) \\<in> Id; gds_is_discovered gds xa x2c;\n        gds_is_discovered gds x'a x2a; gds_is_finished gds xa x2c;\n        gds_is_finished gds x'a x2a; pre_cross_edge x1 x'a s x2a\\<rbrakk>\n       \\<Longrightarrow> gds_cross_edge gds x1b xa x2c\n                         \\<le> \\<Down> Id (gds_cross_edge gds x1 x'a x2a)\n 8. \\<And>x x' x1 x2 x1a x2a x1b x2b x1c x2c xa x'a.\n       \\<lbrakk>gen_cond s;\n        rwof (gds_init gds) gen_cond\n         (\\<lambda>s.\n             if gds_is_empty_stack gds s\n             then SPEC\n                   (\\<lambda>v0.\n                       v0 \\<in> V0 \\<and>\n                       \\<not> gds_is_discovered gds v0 s) \\<bind>\n                  (\\<lambda>v0. gds_new_root gds v0 s)\n             else gds_get_pending gds s \\<bind>\n                  (\\<lambda>(u, Vs, s).\n                      case Vs of None \\<Rightarrow> gds_finish gds u s\n                      | Some v \\<Rightarrow>\n                          if gds_is_discovered gds v s\n                          then if gds_is_finished gds v s\n                               then gds_cross_edge gds u v s\n                               else gds_back_edge gds u v s\n                          else gds_discover gds u v s))\n         s;\n        \\<not> gds_is_empty_stack gds s; \\<not> gds_is_empty_stack gds s;\n        pre_get_pending s; (x, x') \\<in> Id; x2 = (x1a, x2a); x' = (x1, x2);\n        x2b = (x1c, x2c); x = (x1b, x2b); x1c = Some xa; x1a = Some x'a;\n        (xa, x'a) \\<in> Id; gds_is_discovered gds xa x2c;\n        gds_is_discovered gds x'a x2a; \\<not> gds_is_finished gds xa x2c;\n        \\<not> gds_is_finished gds x'a x2a;\n        pre_back_edge x1 x'a s x2a\\<rbrakk>\n       \\<Longrightarrow> gds_back_edge gds x1b xa x2c\n                         \\<le> \\<Down> Id (gds_back_edge gds x1 x'a x2a)\n 9. \\<And>x x' x1 x2 x1a x2a x1b x2b x1c x2c xa x'a.\n       \\<lbrakk>gen_cond s;\n        rwof (gds_init gds) gen_cond\n         (\\<lambda>s.\n             if gds_is_empty_stack gds s\n             then SPEC\n                   (\\<lambda>v0.\n                       v0 \\<in> V0 \\<and>\n                       \\<not> gds_is_discovered gds v0 s) \\<bind>\n                  (\\<lambda>v0. gds_new_root gds v0 s)\n             else gds_get_pending gds s \\<bind>\n                  (\\<lambda>(u, Vs, s).\n                      case Vs of None \\<Rightarrow> gds_finish gds u s\n                      | Some v \\<Rightarrow>\n                          if gds_is_discovered gds v s\n                          then if gds_is_finished gds v s\n                               then gds_cross_edge gds u v s\n                               else gds_back_edge gds u v s\n                          else gds_discover gds u v s))\n         s;\n        \\<not> gds_is_empty_stack gds s; \\<not> gds_is_empty_stack gds s;\n        pre_get_pending s; (x, x') \\<in> Id; x2 = (x1a, x2a); x' = (x1, x2);\n        x2b = (x1c, x2c); x = (x1b, x2b); x1c = Some xa; x1a = Some x'a;\n        (xa, x'a) \\<in> Id; \\<not> gds_is_discovered gds xa x2c;\n        \\<not> gds_is_discovered gds x'a x2a;\n        pre_discover x1 x'a s x2a\\<rbrakk>\n       \\<Longrightarrow> gds_discover gds x1b xa x2c\n                         \\<le> \\<Down> Id (gds_discover gds x1 x'a x2a)", "by simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>gen_cond s; gen_rwof s\\<rbrakk>\n    \\<Longrightarrow> gen_step_assert s \\<le> gen_step s", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>gen_cond s; gen_rwof s\\<rbrakk>\n    \\<Longrightarrow> gen_step_assert s \\<le> gen_step s", "apply (simp (no_asm) only: gen_step_def[abs_def] gen_step_assert_def[abs_def]) []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>gen_cond s; gen_rwof s\\<rbrakk>\n    \\<Longrightarrow> (if gds_is_empty_stack gds s\n                       then SPEC\n                             (\\<lambda>v0.\n                                 v0 \\<in> V0 \\<and>\n                                 \\<not> gds_is_discovered gds v0 s) \\<bind>\n                            (\\<lambda>v0.\n                                ASSERT (pre_new_root v0 s) \\<bind>\n                                (\\<lambda>_. gds_new_root gds v0 s))\n                       else ASSERT (pre_get_pending s) \\<bind>\n                            (\\<lambda>_.\n                                let s0 = GHOST s\n                                in gds_get_pending gds s \\<bind>\n                                   (\\<lambda>(u, Vs, s).\n case Vs of\n None \\<Rightarrow>\n   ASSERT (pre_finish u s0 s) \\<bind> (\\<lambda>_. gds_finish gds u s)\n | Some v \\<Rightarrow>\n     if gds_is_discovered gds v s\n     then if gds_is_finished gds v s\n          then ASSERT (pre_cross_edge u v s0 s) \\<bind>\n               (\\<lambda>_. gds_cross_edge gds u v s)\n          else ASSERT (pre_back_edge u v s0 s) \\<bind>\n               (\\<lambda>_. gds_back_edge gds u v s)\n     else ASSERT (pre_discover u v s0 s) \\<bind>\n          (\\<lambda>_. gds_discover gds u v s))))\n                      \\<le> (if gds_is_empty_stack gds s\n                             then SPEC\n                                   (\\<lambda>v0.\n v0 \\<in> V0 \\<and> \\<not> gds_is_discovered gds v0 s) \\<bind>\n                                  (\\<lambda>v0. gds_new_root gds v0 s)\n                             else gds_get_pending gds s \\<bind>\n                                  (\\<lambda>(u, Vs, s).\ncase Vs of None \\<Rightarrow> gds_finish gds u s\n| Some v \\<Rightarrow>\n    if gds_is_discovered gds v s\n    then if gds_is_finished gds v s then gds_cross_edge gds u v s\n         else gds_back_edge gds u v s\n    else gds_discover gds u v s))", "apply (unfold GHOST_elim_Let) []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>gen_cond s; gen_rwof s\\<rbrakk>\n    \\<Longrightarrow> (if gds_is_empty_stack gds s\n                       then SPEC\n                             (\\<lambda>v0.\n                                 v0 \\<in> V0 \\<and>\n                                 \\<not> gds_is_discovered gds v0 s) \\<bind>\n                            (\\<lambda>v0.\n                                ASSERT (pre_new_root v0 s) \\<bind>\n                                (\\<lambda>_. gds_new_root gds v0 s))\n                       else ASSERT (pre_get_pending s) \\<bind>\n                            (\\<lambda>_.\n                                gds_get_pending gds s \\<bind>\n                                (\\<lambda>(u, Vs, sa).\n                                    case Vs of\n                                    None \\<Rightarrow>\nASSERT (pre_finish u s sa) \\<bind> (\\<lambda>_. gds_finish gds u sa)\n                                    | Some v \\<Rightarrow>\n  if gds_is_discovered gds v sa\n  then if gds_is_finished gds v sa\n       then ASSERT (pre_cross_edge u v s sa) \\<bind>\n            (\\<lambda>_. gds_cross_edge gds u v sa)\n       else ASSERT (pre_back_edge u v s sa) \\<bind>\n            (\\<lambda>_. gds_back_edge gds u v sa)\n  else ASSERT (pre_discover u v s sa) \\<bind>\n       (\\<lambda>_. gds_discover gds u v sa))))\n                      \\<le> (if gds_is_empty_stack gds s\n                             then SPEC\n                                   (\\<lambda>v0.\n v0 \\<in> V0 \\<and> \\<not> gds_is_discovered gds v0 s) \\<bind>\n                                  (\\<lambda>v0. gds_new_root gds v0 s)\n                             else gds_get_pending gds s \\<bind>\n                                  (\\<lambda>(u, Vs, s).\ncase Vs of None \\<Rightarrow> gds_finish gds u s\n| Some v \\<Rightarrow>\n    if gds_is_discovered gds v s\n    then if gds_is_finished gds v s then gds_cross_edge gds u v s\n         else gds_back_edge gds u v s\n    else gds_discover gds u v s))", "apply (rule refine_IdD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>gen_cond s; gen_rwof s\\<rbrakk>\n    \\<Longrightarrow> (if gds_is_empty_stack gds s\n                       then SPEC\n                             (\\<lambda>v0.\n                                 v0 \\<in> V0 \\<and>\n                                 \\<not> gds_is_discovered gds v0 s) \\<bind>\n                            (\\<lambda>v0.\n                                ASSERT (pre_new_root v0 s) \\<bind>\n                                (\\<lambda>_. gds_new_root gds v0 s))\n                       else ASSERT (pre_get_pending s) \\<bind>\n                            (\\<lambda>_.\n                                gds_get_pending gds s \\<bind>\n                                (\\<lambda>(u, Vs, sa).\n                                    case Vs of\n                                    None \\<Rightarrow>\nASSERT (pre_finish u s sa) \\<bind> (\\<lambda>_. gds_finish gds u sa)\n                                    | Some v \\<Rightarrow>\n  if gds_is_discovered gds v sa\n  then if gds_is_finished gds v sa\n       then ASSERT (pre_cross_edge u v s sa) \\<bind>\n            (\\<lambda>_. gds_cross_edge gds u v sa)\n       else ASSERT (pre_back_edge u v s sa) \\<bind>\n            (\\<lambda>_. gds_back_edge gds u v sa)\n  else ASSERT (pre_discover u v s sa) \\<bind>\n       (\\<lambda>_. gds_discover gds u v sa))))\n                      \\<le> \\<Down> Id\n                             (if gds_is_empty_stack gds s\n                              then SPEC\n                                    (\\<lambda>v0.\n  v0 \\<in> V0 \\<and> \\<not> gds_is_discovered gds v0 s) \\<bind>\n                                   (\\<lambda>v0. gds_new_root gds v0 s)\n                              else gds_get_pending gds s \\<bind>\n                                   (\\<lambda>(u, Vs, s).\n case Vs of None \\<Rightarrow> gds_finish gds u s\n | Some v \\<Rightarrow>\n     if gds_is_discovered gds v s\n     then if gds_is_finished gds v s then gds_cross_edge gds u v s\n          else gds_back_edge gds u v s\n     else gds_discover gds u v s))", "apply (refine_rcg bind_refine')"], ["proof (prove)\ngoal (15 subgoals):\n 1. \\<lbrakk>gen_cond s; gen_rwof s\\<rbrakk>\n    \\<Longrightarrow> gds_is_empty_stack gds s = gds_is_empty_stack gds s\n 2. \\<And>v0 v0a.\n       \\<lbrakk>gen_cond s; gen_rwof s; gds_is_empty_stack gds s;\n        gds_is_empty_stack gds s; (v0, v0a) \\<in> Id;\n        inres\n         (SPEC\n           (\\<lambda>v0.\n               v0 \\<in> V0 \\<and> \\<not> gds_is_discovered gds v0 s))\n         v0;\n        inres\n         (SPEC\n           (\\<lambda>v0.\n               v0 \\<in> V0 \\<and> \\<not> gds_is_discovered gds v0 s))\n         v0a;\n        nofail\n         (SPEC\n           (\\<lambda>v0.\n               v0 \\<in> V0 \\<and> \\<not> gds_is_discovered gds v0 s));\n        nofail\n         (SPEC\n           (\\<lambda>v0.\n               v0 \\<in> V0 \\<and>\n               \\<not> gds_is_discovered gds v0 s))\\<rbrakk>\n       \\<Longrightarrow> pre_new_root v0 s\n 3. \\<And>v0 v0a.\n       \\<lbrakk>gen_cond s; gen_rwof s; gds_is_empty_stack gds s;\n        gds_is_empty_stack gds s; (v0, v0a) \\<in> Id;\n        inres\n         (SPEC\n           (\\<lambda>v0.\n               v0 \\<in> V0 \\<and> \\<not> gds_is_discovered gds v0 s))\n         v0;\n        inres\n         (SPEC\n           (\\<lambda>v0.\n               v0 \\<in> V0 \\<and> \\<not> gds_is_discovered gds v0 s))\n         v0a;\n        nofail\n         (SPEC\n           (\\<lambda>v0.\n               v0 \\<in> V0 \\<and> \\<not> gds_is_discovered gds v0 s));\n        nofail\n         (SPEC\n           (\\<lambda>v0.\n               v0 \\<in> V0 \\<and> \\<not> gds_is_discovered gds v0 s));\n        pre_new_root v0 s\\<rbrakk>\n       \\<Longrightarrow> gds_new_root gds v0 s\n                         \\<le> \\<Down> Id (gds_new_root gds v0a s)\n 4. \\<lbrakk>gen_cond s; gen_rwof s; \\<not> gds_is_empty_stack gds s;\n     \\<not> gds_is_empty_stack gds s\\<rbrakk>\n    \\<Longrightarrow> pre_get_pending s\n 5. \\<And>x x' x1 x2 x1a x2a x1b x2b x1c x2c.\n       \\<lbrakk>gen_cond s; gen_rwof s; \\<not> gds_is_empty_stack gds s;\n        \\<not> gds_is_empty_stack gds s; pre_get_pending s;\n        (x, x') \\<in> Id; inres (gds_get_pending gds s) x;\n        inres (gds_get_pending gds s) x'; nofail (gds_get_pending gds s);\n        nofail (gds_get_pending gds s); x2 = (x1a, x2a); x' = (x1, x2);\n        x2b = (x1c, x2c); x = (x1b, x2b)\\<rbrakk>\n       \\<Longrightarrow> (x1c, x1a)\n                         \\<in> \\<langle>?Ra65 x x' x1 x2 x1a x2a x1b x2b x1c\n   x2c\\<rangle>option_rel\n 6. \\<And>x x' x1 x2 x1a x2a x1b x2b x1c x2c.\n       \\<lbrakk>gen_cond s; gen_rwof s; \\<not> gds_is_empty_stack gds s;\n        \\<not> gds_is_empty_stack gds s; pre_get_pending s;\n        (x, x') \\<in> Id; inres (gds_get_pending gds s) x;\n        inres (gds_get_pending gds s) x'; nofail (gds_get_pending gds s);\n        nofail (gds_get_pending gds s); x2 = (x1a, x2a); x' = (x1, x2);\n        x2b = (x1c, x2c); x = (x1b, x2b); x1c = None; x1a = None\\<rbrakk>\n       \\<Longrightarrow> pre_finish x1b s x2c\n 7. \\<And>x x' x1 x2 x1a x2a x1b x2b x1c x2c.\n       \\<lbrakk>gen_cond s; gen_rwof s; \\<not> gds_is_empty_stack gds s;\n        \\<not> gds_is_empty_stack gds s; pre_get_pending s;\n        (x, x') \\<in> Id; inres (gds_get_pending gds s) x;\n        inres (gds_get_pending gds s) x'; nofail (gds_get_pending gds s);\n        nofail (gds_get_pending gds s); x2 = (x1a, x2a); x' = (x1, x2);\n        x2b = (x1c, x2c); x = (x1b, x2b); x1c = None; x1a = None;\n        pre_finish x1b s x2c\\<rbrakk>\n       \\<Longrightarrow> gds_finish gds x1b x2c\n                         \\<le> \\<Down> Id (gds_finish gds x1 x2a)\n 8. \\<And>x x' x1 x2 x1a x2a x1b x2b x1c x2c xa x'a.\n       \\<lbrakk>gen_cond s; gen_rwof s; \\<not> gds_is_empty_stack gds s;\n        \\<not> gds_is_empty_stack gds s; pre_get_pending s;\n        (x, x') \\<in> Id; inres (gds_get_pending gds s) x;\n        inres (gds_get_pending gds s) x'; nofail (gds_get_pending gds s);\n        nofail (gds_get_pending gds s); x2 = (x1a, x2a); x' = (x1, x2);\n        x2b = (x1c, x2c); x = (x1b, x2b); x1c = Some xa; x1a = Some x'a;\n        (xa, x'a) \\<in> ?Ra65 x x' x1 x2 x1a x2a x1b x2b x1c x2c\\<rbrakk>\n       \\<Longrightarrow> gds_is_discovered gds xa x2c =\n                         gds_is_discovered gds x'a x2a\n 9. \\<And>x x' x1 x2 x1a x2a x1b x2b x1c x2c xa x'a.\n       \\<lbrakk>gen_cond s; gen_rwof s; \\<not> gds_is_empty_stack gds s;\n        \\<not> gds_is_empty_stack gds s; pre_get_pending s;\n        (x, x') \\<in> Id; inres (gds_get_pending gds s) x;\n        inres (gds_get_pending gds s) x'; nofail (gds_get_pending gds s);\n        nofail (gds_get_pending gds s); x2 = (x1a, x2a); x' = (x1, x2);\n        x2b = (x1c, x2c); x = (x1b, x2b); x1c = Some xa; x1a = Some x'a;\n        (xa, x'a) \\<in> ?Ra65 x x' x1 x2 x1a x2a x1b x2b x1c x2c;\n        gds_is_discovered gds xa x2c; gds_is_discovered gds x'a x2a\\<rbrakk>\n       \\<Longrightarrow> gds_is_finished gds xa x2c =\n                         gds_is_finished gds x'a x2a\n 10. \\<And>x x' x1 x2 x1a x2a x1b x2b x1c x2c xa x'a.\n        \\<lbrakk>gen_cond s; gen_rwof s; \\<not> gds_is_empty_stack gds s;\n         \\<not> gds_is_empty_stack gds s; pre_get_pending s;\n         (x, x') \\<in> Id; inres (gds_get_pending gds s) x;\n         inres (gds_get_pending gds s) x'; nofail (gds_get_pending gds s);\n         nofail (gds_get_pending gds s); x2 = (x1a, x2a); x' = (x1, x2);\n         x2b = (x1c, x2c); x = (x1b, x2b); x1c = Some xa; x1a = Some x'a;\n         (xa, x'a) \\<in> ?Ra65 x x' x1 x2 x1a x2a x1b x2b x1c x2c;\n         gds_is_discovered gds xa x2c; gds_is_discovered gds x'a x2a;\n         gds_is_finished gds xa x2c; gds_is_finished gds x'a x2a\\<rbrakk>\n        \\<Longrightarrow> pre_cross_edge x1b xa s x2c\nA total of 15 subgoals...", "apply refine_dref_type"], ["proof (prove)\ngoal (15 subgoals):\n 1. \\<lbrakk>gen_cond s; gen_rwof s\\<rbrakk>\n    \\<Longrightarrow> gds_is_empty_stack gds s = gds_is_empty_stack gds s\n 2. \\<And>v0 v0a.\n       \\<lbrakk>gen_cond s; gen_rwof s; gds_is_empty_stack gds s;\n        gds_is_empty_stack gds s; (v0, v0a) \\<in> Id;\n        inres\n         (SPEC\n           (\\<lambda>v0.\n               v0 \\<in> V0 \\<and> \\<not> gds_is_discovered gds v0 s))\n         v0;\n        inres\n         (SPEC\n           (\\<lambda>v0.\n               v0 \\<in> V0 \\<and> \\<not> gds_is_discovered gds v0 s))\n         v0a;\n        nofail\n         (SPEC\n           (\\<lambda>v0.\n               v0 \\<in> V0 \\<and> \\<not> gds_is_discovered gds v0 s));\n        nofail\n         (SPEC\n           (\\<lambda>v0.\n               v0 \\<in> V0 \\<and>\n               \\<not> gds_is_discovered gds v0 s))\\<rbrakk>\n       \\<Longrightarrow> pre_new_root v0 s\n 3. \\<And>v0 v0a.\n       \\<lbrakk>gen_cond s; gen_rwof s; gds_is_empty_stack gds s;\n        gds_is_empty_stack gds s; (v0, v0a) \\<in> Id;\n        inres\n         (SPEC\n           (\\<lambda>v0.\n               v0 \\<in> V0 \\<and> \\<not> gds_is_discovered gds v0 s))\n         v0;\n        inres\n         (SPEC\n           (\\<lambda>v0.\n               v0 \\<in> V0 \\<and> \\<not> gds_is_discovered gds v0 s))\n         v0a;\n        nofail\n         (SPEC\n           (\\<lambda>v0.\n               v0 \\<in> V0 \\<and> \\<not> gds_is_discovered gds v0 s));\n        nofail\n         (SPEC\n           (\\<lambda>v0.\n               v0 \\<in> V0 \\<and> \\<not> gds_is_discovered gds v0 s));\n        pre_new_root v0 s\\<rbrakk>\n       \\<Longrightarrow> gds_new_root gds v0 s\n                         \\<le> \\<Down> Id (gds_new_root gds v0a s)\n 4. \\<lbrakk>gen_cond s; gen_rwof s; \\<not> gds_is_empty_stack gds s;\n     \\<not> gds_is_empty_stack gds s\\<rbrakk>\n    \\<Longrightarrow> pre_get_pending s\n 5. \\<And>x x' x1 x2 x1a x2a x1b x2b x1c x2c.\n       \\<lbrakk>gen_cond s; gen_rwof s; \\<not> gds_is_empty_stack gds s;\n        \\<not> gds_is_empty_stack gds s; pre_get_pending s;\n        (x, x') \\<in> Id; inres (gds_get_pending gds s) x;\n        inres (gds_get_pending gds s) x'; nofail (gds_get_pending gds s);\n        nofail (gds_get_pending gds s); x2 = (x1a, x2a); x' = (x1, x2);\n        x2b = (x1c, x2c); x = (x1b, x2b)\\<rbrakk>\n       \\<Longrightarrow> (x1c, x1a) \\<in> \\<langle>Id\\<rangle>option_rel\n 6. \\<And>x x' x1 x2 x1a x2a x1b x2b x1c x2c.\n       \\<lbrakk>gen_cond s; gen_rwof s; \\<not> gds_is_empty_stack gds s;\n        \\<not> gds_is_empty_stack gds s; pre_get_pending s;\n        (x, x') \\<in> Id; inres (gds_get_pending gds s) x;\n        inres (gds_get_pending gds s) x'; nofail (gds_get_pending gds s);\n        nofail (gds_get_pending gds s); x2 = (x1a, x2a); x' = (x1, x2);\n        x2b = (x1c, x2c); x = (x1b, x2b); x1c = None; x1a = None\\<rbrakk>\n       \\<Longrightarrow> pre_finish x1b s x2c\n 7. \\<And>x x' x1 x2 x1a x2a x1b x2b x1c x2c.\n       \\<lbrakk>gen_cond s; gen_rwof s; \\<not> gds_is_empty_stack gds s;\n        \\<not> gds_is_empty_stack gds s; pre_get_pending s;\n        (x, x') \\<in> Id; inres (gds_get_pending gds s) x;\n        inres (gds_get_pending gds s) x'; nofail (gds_get_pending gds s);\n        nofail (gds_get_pending gds s); x2 = (x1a, x2a); x' = (x1, x2);\n        x2b = (x1c, x2c); x = (x1b, x2b); x1c = None; x1a = None;\n        pre_finish x1b s x2c\\<rbrakk>\n       \\<Longrightarrow> gds_finish gds x1b x2c\n                         \\<le> \\<Down> Id (gds_finish gds x1 x2a)\n 8. \\<And>x x' x1 x2 x1a x2a x1b x2b x1c x2c xa x'a.\n       \\<lbrakk>gen_cond s; gen_rwof s; \\<not> gds_is_empty_stack gds s;\n        \\<not> gds_is_empty_stack gds s; pre_get_pending s;\n        (x, x') \\<in> Id; inres (gds_get_pending gds s) x;\n        inres (gds_get_pending gds s) x'; nofail (gds_get_pending gds s);\n        nofail (gds_get_pending gds s); x2 = (x1a, x2a); x' = (x1, x2);\n        x2b = (x1c, x2c); x = (x1b, x2b); x1c = Some xa; x1a = Some x'a;\n        (xa, x'a) \\<in> Id\\<rbrakk>\n       \\<Longrightarrow> gds_is_discovered gds xa x2c =\n                         gds_is_discovered gds x'a x2a\n 9. \\<And>x x' x1 x2 x1a x2a x1b x2b x1c x2c xa x'a.\n       \\<lbrakk>gen_cond s; gen_rwof s; \\<not> gds_is_empty_stack gds s;\n        \\<not> gds_is_empty_stack gds s; pre_get_pending s;\n        (x, x') \\<in> Id; inres (gds_get_pending gds s) x;\n        inres (gds_get_pending gds s) x'; nofail (gds_get_pending gds s);\n        nofail (gds_get_pending gds s); x2 = (x1a, x2a); x' = (x1, x2);\n        x2b = (x1c, x2c); x = (x1b, x2b); x1c = Some xa; x1a = Some x'a;\n        (xa, x'a) \\<in> Id; gds_is_discovered gds xa x2c;\n        gds_is_discovered gds x'a x2a\\<rbrakk>\n       \\<Longrightarrow> gds_is_finished gds xa x2c =\n                         gds_is_finished gds x'a x2a\n 10. \\<And>x x' x1 x2 x1a x2a x1b x2b x1c x2c xa x'a.\n        \\<lbrakk>gen_cond s; gen_rwof s; \\<not> gds_is_empty_stack gds s;\n         \\<not> gds_is_empty_stack gds s; pre_get_pending s;\n         (x, x') \\<in> Id; inres (gds_get_pending gds s) x;\n         inres (gds_get_pending gds s) x'; nofail (gds_get_pending gds s);\n         nofail (gds_get_pending gds s); x2 = (x1a, x2a); x' = (x1, x2);\n         x2b = (x1c, x2c); x = (x1b, x2b); x1c = Some xa; x1a = Some x'a;\n         (xa, x'a) \\<in> Id; gds_is_discovered gds xa x2c;\n         gds_is_discovered gds x'a x2a; gds_is_finished gds xa x2c;\n         gds_is_finished gds x'a x2a\\<rbrakk>\n        \\<Longrightarrow> pre_cross_edge x1b xa s x2c\nA total of 15 subgoals...", "by (auto simp: pre_defs gen_cond_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma gen_dfs_eq_assert: \"gen_dfs = gen_dfs_assert\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gen_dfs = gen_dfs_assert", "unfolding gen_dfs_def gen_dfs_assert_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. gds_init gds \\<bind> WHILE gen_cond gen_step =\n    gds_init gds \\<bind> WHILE gen_cond gen_step_assert", "apply (rule antisym)"], ["proof (prove)\ngoal (2 subgoals):\n 1. gds_init gds \\<bind> WHILE gen_cond gen_step\n    \\<le> gds_init gds \\<bind> WHILE gen_cond gen_step_assert\n 2. gds_init gds \\<bind> WHILE gen_cond gen_step_assert\n    \\<le> gds_init gds \\<bind> WHILE gen_cond gen_step", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. gds_init gds \\<bind> WHILE gen_cond gen_step\n    \\<le> gds_init gds \\<bind> WHILE gen_cond gen_step_assert", "apply (unfold gen_step_def[abs_def] gen_step_assert_def[abs_def]) []"], ["proof (prove)\ngoal (1 subgoal):\n 1. gds_init gds \\<bind>\n    WHILE gen_cond\n     (\\<lambda>s.\n         if gds_is_empty_stack gds s\n         then SPEC\n               (\\<lambda>v0.\n                   v0 \\<in> V0 \\<and>\n                   \\<not> gds_is_discovered gds v0 s) \\<bind>\n              (\\<lambda>v0. gds_new_root gds v0 s)\n         else gds_get_pending gds s \\<bind>\n              (\\<lambda>(u, Vs, s).\n                  case Vs of None \\<Rightarrow> gds_finish gds u s\n                  | Some v \\<Rightarrow>\n                      if gds_is_discovered gds v s\n                      then if gds_is_finished gds v s\n                           then gds_cross_edge gds u v s\n                           else gds_back_edge gds u v s\n                      else gds_discover gds u v s))\n    \\<le> gds_init gds \\<bind>\n          WHILE gen_cond\n           (\\<lambda>s.\n               if gds_is_empty_stack gds s\n               then SPEC\n                     (\\<lambda>v0.\n                         v0 \\<in> V0 \\<and>\n                         \\<not> gds_is_discovered gds v0 s) \\<bind>\n                    (\\<lambda>v0.\n                        ASSERT (pre_new_root v0 s) \\<bind>\n                        (\\<lambda>_. gds_new_root gds v0 s))\n               else ASSERT (pre_get_pending s) \\<bind>\n                    (\\<lambda>_.\n                        let s0 = GHOST s\n                        in gds_get_pending gds s \\<bind>\n                           (\\<lambda>(u, Vs, s).\n                               case Vs of\n                               None \\<Rightarrow>\n                                 ASSERT (pre_finish u s0 s) \\<bind>\n                                 (\\<lambda>_. gds_finish gds u s)\n                               | Some v \\<Rightarrow>\n                                   if gds_is_discovered gds v s\n                                   then if gds_is_finished gds v s\n  then ASSERT (pre_cross_edge u v s0 s) \\<bind>\n       (\\<lambda>_. gds_cross_edge gds u v s)\n  else ASSERT (pre_back_edge u v s0 s) \\<bind>\n       (\\<lambda>_. gds_back_edge gds u v s)\n                                   else ASSERT\n   (pre_discover u v s0 s) \\<bind>\n  (\\<lambda>_. gds_discover gds u v s))))", "apply (unfold GHOST_elim_Let) []"], ["proof (prove)\ngoal (1 subgoal):\n 1. gds_init gds \\<bind>\n    WHILE gen_cond\n     (\\<lambda>s.\n         if gds_is_empty_stack gds s\n         then SPEC\n               (\\<lambda>v0.\n                   v0 \\<in> V0 \\<and>\n                   \\<not> gds_is_discovered gds v0 s) \\<bind>\n              (\\<lambda>v0. gds_new_root gds v0 s)\n         else gds_get_pending gds s \\<bind>\n              (\\<lambda>(u, Vs, s).\n                  case Vs of None \\<Rightarrow> gds_finish gds u s\n                  | Some v \\<Rightarrow>\n                      if gds_is_discovered gds v s\n                      then if gds_is_finished gds v s\n                           then gds_cross_edge gds u v s\n                           else gds_back_edge gds u v s\n                      else gds_discover gds u v s))\n    \\<le> gds_init gds \\<bind>\n          WHILE gen_cond\n           (\\<lambda>s.\n               if gds_is_empty_stack gds s\n               then SPEC\n                     (\\<lambda>v0.\n                         v0 \\<in> V0 \\<and>\n                         \\<not> gds_is_discovered gds v0 s) \\<bind>\n                    (\\<lambda>v0.\n                        ASSERT (pre_new_root v0 s) \\<bind>\n                        (\\<lambda>_. gds_new_root gds v0 s))\n               else ASSERT (pre_get_pending s) \\<bind>\n                    (\\<lambda>_.\n                        gds_get_pending gds s \\<bind>\n                        (\\<lambda>(u, Vs, sa).\n                            case Vs of\n                            None \\<Rightarrow>\n                              ASSERT (pre_finish u s sa) \\<bind>\n                              (\\<lambda>_. gds_finish gds u sa)\n                            | Some v \\<Rightarrow>\n                                if gds_is_discovered gds v sa\n                                then if gds_is_finished gds v sa\n                                     then ASSERT\n     (pre_cross_edge u v s sa) \\<bind>\n    (\\<lambda>_. gds_cross_edge gds u v sa)\n                                     else ASSERT\n     (pre_back_edge u v s sa) \\<bind>\n    (\\<lambda>_. gds_back_edge gds u v sa)\n                                else ASSERT (pre_discover u v s sa) \\<bind>\n                                     (\\<lambda>_.\n   gds_discover gds u v sa))))", "apply (rule refine_IdD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. gds_init gds \\<bind>\n    WHILE gen_cond\n     (\\<lambda>s.\n         if gds_is_empty_stack gds s\n         then SPEC\n               (\\<lambda>v0.\n                   v0 \\<in> V0 \\<and>\n                   \\<not> gds_is_discovered gds v0 s) \\<bind>\n              (\\<lambda>v0. gds_new_root gds v0 s)\n         else gds_get_pending gds s \\<bind>\n              (\\<lambda>(u, Vs, s).\n                  case Vs of None \\<Rightarrow> gds_finish gds u s\n                  | Some v \\<Rightarrow>\n                      if gds_is_discovered gds v s\n                      then if gds_is_finished gds v s\n                           then gds_cross_edge gds u v s\n                           else gds_back_edge gds u v s\n                      else gds_discover gds u v s))\n    \\<le> \\<Down> Id\n           (gds_init gds \\<bind>\n            WHILE gen_cond\n             (\\<lambda>s.\n                 if gds_is_empty_stack gds s\n                 then SPEC\n                       (\\<lambda>v0.\n                           v0 \\<in> V0 \\<and>\n                           \\<not> gds_is_discovered gds v0 s) \\<bind>\n                      (\\<lambda>v0.\n                          ASSERT (pre_new_root v0 s) \\<bind>\n                          (\\<lambda>_. gds_new_root gds v0 s))\n                 else ASSERT (pre_get_pending s) \\<bind>\n                      (\\<lambda>_.\n                          gds_get_pending gds s \\<bind>\n                          (\\<lambda>(u, Vs, sa).\n                              case Vs of\n                              None \\<Rightarrow>\n                                ASSERT (pre_finish u s sa) \\<bind>\n                                (\\<lambda>_. gds_finish gds u sa)\n                              | Some v \\<Rightarrow>\n                                  if gds_is_discovered gds v sa\n                                  then if gds_is_finished gds v sa\n then ASSERT (pre_cross_edge u v s sa) \\<bind>\n      (\\<lambda>_. gds_cross_edge gds u v sa)\n else ASSERT (pre_back_edge u v s sa) \\<bind>\n      (\\<lambda>_. gds_back_edge gds u v sa)\n                                  else ASSERT\n  (pre_discover u v s sa) \\<bind>\n (\\<lambda>_. gds_discover gds u v sa)))))", "by (refine_rcg, refine_dref_type, simp_all) []"], ["proof (prove)\ngoal (1 subgoal):\n 1. gds_init gds \\<bind> WHILE gen_cond gen_step_assert\n    \\<le> gds_init gds \\<bind> WHILE gen_cond gen_step", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. gds_init gds \\<bind> WHILE gen_cond gen_step_assert\n    \\<le> gds_init gds \\<bind> WHILE gen_cond gen_step", "apply (subst (2) WHILE_eq_I_rwof)"], ["proof (prove)\ngoal (1 subgoal):\n 1. gds_init gds \\<bind> WHILE gen_cond gen_step_assert\n    \\<le> gds_init gds \\<bind>\n          WHILE\\<^bsup>gen_rwof\\<^esup> gen_cond gen_step", "apply (rule refine_IdD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. gds_init gds \\<bind> WHILE gen_cond gen_step_assert\n    \\<le> \\<Down> Id\n           (gds_init gds \\<bind>\n            WHILE\\<^bsup>gen_rwof\\<^esup> gen_cond gen_step)", "apply (refine_rcg, simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x x' xa x'a.\n       \\<lbrakk>x = x'; xa = x'a; gen_cond x'a; gen_rwof x'a\\<rbrakk>\n       \\<Longrightarrow> gen_step_assert x'a \\<le> gen_step x'a", "apply (simp (no_asm) only: gen_step_def[abs_def] gen_step_assert_def[abs_def]) []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x x' xa x'a.\n       \\<lbrakk>x = x'; xa = x'a; gen_cond x'a; gen_rwof x'a\\<rbrakk>\n       \\<Longrightarrow> (if gds_is_empty_stack gds x'a\n                          then SPEC\n                                (\\<lambda>v0.\n                                    v0 \\<in> V0 \\<and>\n                                    \\<not> gds_is_discovered gds v0\n      x'a) \\<bind>\n                               (\\<lambda>v0.\n                                   ASSERT (pre_new_root v0 x'a) \\<bind>\n                                   (\\<lambda>_. gds_new_root gds v0 x'a))\n                          else ASSERT (pre_get_pending x'a) \\<bind>\n                               (\\<lambda>_.\n                                   let s0 = GHOST x'a\n                                   in gds_get_pending gds x'a \\<bind>\n(\\<lambda>(u, Vs, s).\n    case Vs of\n    None \\<Rightarrow>\n      ASSERT (pre_finish u s0 s) \\<bind> (\\<lambda>_. gds_finish gds u s)\n    | Some v \\<Rightarrow>\n        if gds_is_discovered gds v s\n        then if gds_is_finished gds v s\n             then ASSERT (pre_cross_edge u v s0 s) \\<bind>\n                  (\\<lambda>_. gds_cross_edge gds u v s)\n             else ASSERT (pre_back_edge u v s0 s) \\<bind>\n                  (\\<lambda>_. gds_back_edge gds u v s)\n        else ASSERT (pre_discover u v s0 s) \\<bind>\n             (\\<lambda>_. gds_discover gds u v s))))\n                         \\<le> (if gds_is_empty_stack gds x'a\n                                then SPEC\n(\\<lambda>v0.\n    v0 \\<in> V0 \\<and> \\<not> gds_is_discovered gds v0 x'a) \\<bind>\n                                     (\\<lambda>v0. gds_new_root gds v0 x'a)\n                                else gds_get_pending gds x'a \\<bind>\n                                     (\\<lambda>(u, Vs, s).\n   case Vs of None \\<Rightarrow> gds_finish gds u s\n   | Some v \\<Rightarrow>\n       if gds_is_discovered gds v s\n       then if gds_is_finished gds v s then gds_cross_edge gds u v s\n            else gds_back_edge gds u v s\n       else gds_discover gds u v s))", "apply (unfold GHOST_elim_Let) []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x x' xa x'a.\n       \\<lbrakk>x = x'; xa = x'a; gen_cond x'a; gen_rwof x'a\\<rbrakk>\n       \\<Longrightarrow> (if gds_is_empty_stack gds x'a\n                          then SPEC\n                                (\\<lambda>v0.\n                                    v0 \\<in> V0 \\<and>\n                                    \\<not> gds_is_discovered gds v0\n      x'a) \\<bind>\n                               (\\<lambda>v0.\n                                   ASSERT (pre_new_root v0 x'a) \\<bind>\n                                   (\\<lambda>_. gds_new_root gds v0 x'a))\n                          else ASSERT (pre_get_pending x'a) \\<bind>\n                               (\\<lambda>_.\n                                   gds_get_pending gds x'a \\<bind>\n                                   (\\<lambda>(u, Vs, s).\n case Vs of\n None \\<Rightarrow>\n   ASSERT (pre_finish u x'a s) \\<bind> (\\<lambda>_. gds_finish gds u s)\n | Some v \\<Rightarrow>\n     if gds_is_discovered gds v s\n     then if gds_is_finished gds v s\n          then ASSERT (pre_cross_edge u v x'a s) \\<bind>\n               (\\<lambda>_. gds_cross_edge gds u v s)\n          else ASSERT (pre_back_edge u v x'a s) \\<bind>\n               (\\<lambda>_. gds_back_edge gds u v s)\n     else ASSERT (pre_discover u v x'a s) \\<bind>\n          (\\<lambda>_. gds_discover gds u v s))))\n                         \\<le> (if gds_is_empty_stack gds x'a\n                                then SPEC\n(\\<lambda>v0.\n    v0 \\<in> V0 \\<and> \\<not> gds_is_discovered gds v0 x'a) \\<bind>\n                                     (\\<lambda>v0. gds_new_root gds v0 x'a)\n                                else gds_get_pending gds x'a \\<bind>\n                                     (\\<lambda>(u, Vs, s).\n   case Vs of None \\<Rightarrow> gds_finish gds u s\n   | Some v \\<Rightarrow>\n       if gds_is_discovered gds v s\n       then if gds_is_finished gds v s then gds_cross_edge gds u v s\n            else gds_back_edge gds u v s\n       else gds_discover gds u v s))", "apply (rule refine_IdD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x x' xa x'a.\n       \\<lbrakk>x = x'; xa = x'a; gen_cond x'a; gen_rwof x'a\\<rbrakk>\n       \\<Longrightarrow> (if gds_is_empty_stack gds x'a\n                          then SPEC\n                                (\\<lambda>v0.\n                                    v0 \\<in> V0 \\<and>\n                                    \\<not> gds_is_discovered gds v0\n      x'a) \\<bind>\n                               (\\<lambda>v0.\n                                   ASSERT (pre_new_root v0 x'a) \\<bind>\n                                   (\\<lambda>_. gds_new_root gds v0 x'a))\n                          else ASSERT (pre_get_pending x'a) \\<bind>\n                               (\\<lambda>_.\n                                   gds_get_pending gds x'a \\<bind>\n                                   (\\<lambda>(u, Vs, s).\n case Vs of\n None \\<Rightarrow>\n   ASSERT (pre_finish u x'a s) \\<bind> (\\<lambda>_. gds_finish gds u s)\n | Some v \\<Rightarrow>\n     if gds_is_discovered gds v s\n     then if gds_is_finished gds v s\n          then ASSERT (pre_cross_edge u v x'a s) \\<bind>\n               (\\<lambda>_. gds_cross_edge gds u v s)\n          else ASSERT (pre_back_edge u v x'a s) \\<bind>\n               (\\<lambda>_. gds_back_edge gds u v s)\n     else ASSERT (pre_discover u v x'a s) \\<bind>\n          (\\<lambda>_. gds_discover gds u v s))))\n                         \\<le> \\<Down> Id\n                                (if gds_is_empty_stack gds x'a\n                                 then SPEC\n (\\<lambda>v0.\n     v0 \\<in> V0 \\<and> \\<not> gds_is_discovered gds v0 x'a) \\<bind>\n(\\<lambda>v0. gds_new_root gds v0 x'a)\n                                 else gds_get_pending gds x'a \\<bind>\n(\\<lambda>(u, Vs, s).\n    case Vs of None \\<Rightarrow> gds_finish gds u s\n    | Some v \\<Rightarrow>\n        if gds_is_discovered gds v s\n        then if gds_is_finished gds v s then gds_cross_edge gds u v s\n             else gds_back_edge gds u v s\n        else gds_discover gds u v s))", "apply (refine_rcg bind_refine')"], ["proof (prove)\ngoal (15 subgoals):\n 1. \\<And>x x' xa x'a.\n       \\<lbrakk>x = x'; xa = x'a; gen_cond x'a; gen_rwof x'a\\<rbrakk>\n       \\<Longrightarrow> gds_is_empty_stack gds x'a =\n                         gds_is_empty_stack gds x'a\n 2. \\<And>x x' xa x'a v0 v0a.\n       \\<lbrakk>x = x'; xa = x'a; gen_cond x'a; gen_rwof x'a;\n        gds_is_empty_stack gds x'a; gds_is_empty_stack gds x'a;\n        (v0, v0a) \\<in> Id;\n        inres\n         (SPEC\n           (\\<lambda>v0.\n               v0 \\<in> V0 \\<and> \\<not> gds_is_discovered gds v0 x'a))\n         v0;\n        inres\n         (SPEC\n           (\\<lambda>v0.\n               v0 \\<in> V0 \\<and> \\<not> gds_is_discovered gds v0 x'a))\n         v0a;\n        nofail\n         (SPEC\n           (\\<lambda>v0.\n               v0 \\<in> V0 \\<and> \\<not> gds_is_discovered gds v0 x'a));\n        nofail\n         (SPEC\n           (\\<lambda>v0.\n               v0 \\<in> V0 \\<and>\n               \\<not> gds_is_discovered gds v0 x'a))\\<rbrakk>\n       \\<Longrightarrow> pre_new_root v0 x'a\n 3. \\<And>x x' xa x'a v0 v0a.\n       \\<lbrakk>x = x'; xa = x'a; gen_cond x'a; gen_rwof x'a;\n        gds_is_empty_stack gds x'a; gds_is_empty_stack gds x'a;\n        (v0, v0a) \\<in> Id;\n        inres\n         (SPEC\n           (\\<lambda>v0.\n               v0 \\<in> V0 \\<and> \\<not> gds_is_discovered gds v0 x'a))\n         v0;\n        inres\n         (SPEC\n           (\\<lambda>v0.\n               v0 \\<in> V0 \\<and> \\<not> gds_is_discovered gds v0 x'a))\n         v0a;\n        nofail\n         (SPEC\n           (\\<lambda>v0.\n               v0 \\<in> V0 \\<and> \\<not> gds_is_discovered gds v0 x'a));\n        nofail\n         (SPEC\n           (\\<lambda>v0.\n               v0 \\<in> V0 \\<and> \\<not> gds_is_discovered gds v0 x'a));\n        pre_new_root v0 x'a\\<rbrakk>\n       \\<Longrightarrow> gds_new_root gds v0 x'a\n                         \\<le> \\<Down> Id (gds_new_root gds v0a x'a)\n 4. \\<And>x x' xa x'a.\n       \\<lbrakk>x = x'; xa = x'a; gen_cond x'a; gen_rwof x'a;\n        \\<not> gds_is_empty_stack gds x'a;\n        \\<not> gds_is_empty_stack gds x'a\\<rbrakk>\n       \\<Longrightarrow> pre_get_pending x'a\n 5. \\<And>x x' xa x'a xb x'b x1 x2 x1a x2a x1b x2b x1c x2c.\n       \\<lbrakk>x = x'; xa = x'a; gen_cond x'a; gen_rwof x'a;\n        \\<not> gds_is_empty_stack gds x'a;\n        \\<not> gds_is_empty_stack gds x'a; pre_get_pending x'a;\n        (xb, x'b) \\<in> Id; inres (gds_get_pending gds x'a) xb;\n        inres (gds_get_pending gds x'a) x'b;\n        nofail (gds_get_pending gds x'a); nofail (gds_get_pending gds x'a);\n        x2 = (x1a, x2a); x'b = (x1, x2); x2b = (x1c, x2c);\n        xb = (x1b, x2b)\\<rbrakk>\n       \\<Longrightarrow> (x1c, x1a)\n                         \\<in> \\<langle>?Ra70 x x' xa x'a xb x'b x1 x2 x1a\n   x2a x1b x2b x1c x2c\\<rangle>option_rel\n 6. \\<And>x x' xa x'a xb x'b x1 x2 x1a x2a x1b x2b x1c x2c.\n       \\<lbrakk>x = x'; xa = x'a; gen_cond x'a; gen_rwof x'a;\n        \\<not> gds_is_empty_stack gds x'a;\n        \\<not> gds_is_empty_stack gds x'a; pre_get_pending x'a;\n        (xb, x'b) \\<in> Id; inres (gds_get_pending gds x'a) xb;\n        inres (gds_get_pending gds x'a) x'b;\n        nofail (gds_get_pending gds x'a); nofail (gds_get_pending gds x'a);\n        x2 = (x1a, x2a); x'b = (x1, x2); x2b = (x1c, x2c); xb = (x1b, x2b);\n        x1c = None; x1a = None\\<rbrakk>\n       \\<Longrightarrow> pre_finish x1b x'a x2c\n 7. \\<And>x x' xa x'a xb x'b x1 x2 x1a x2a x1b x2b x1c x2c.\n       \\<lbrakk>x = x'; xa = x'a; gen_cond x'a; gen_rwof x'a;\n        \\<not> gds_is_empty_stack gds x'a;\n        \\<not> gds_is_empty_stack gds x'a; pre_get_pending x'a;\n        (xb, x'b) \\<in> Id; inres (gds_get_pending gds x'a) xb;\n        inres (gds_get_pending gds x'a) x'b;\n        nofail (gds_get_pending gds x'a); nofail (gds_get_pending gds x'a);\n        x2 = (x1a, x2a); x'b = (x1, x2); x2b = (x1c, x2c); xb = (x1b, x2b);\n        x1c = None; x1a = None; pre_finish x1b x'a x2c\\<rbrakk>\n       \\<Longrightarrow> gds_finish gds x1b x2c\n                         \\<le> \\<Down> Id (gds_finish gds x1 x2a)\n 8. \\<And>x x' xa x'a xb x'b x1 x2 x1a x2a x1b x2b x1c x2c xc x'c.\n       \\<lbrakk>x = x'; xa = x'a; gen_cond x'a; gen_rwof x'a;\n        \\<not> gds_is_empty_stack gds x'a;\n        \\<not> gds_is_empty_stack gds x'a; pre_get_pending x'a;\n        (xb, x'b) \\<in> Id; inres (gds_get_pending gds x'a) xb;\n        inres (gds_get_pending gds x'a) x'b;\n        nofail (gds_get_pending gds x'a); nofail (gds_get_pending gds x'a);\n        x2 = (x1a, x2a); x'b = (x1, x2); x2b = (x1c, x2c); xb = (x1b, x2b);\n        x1c = Some xc; x1a = Some x'c;\n        (xc, x'c)\n        \\<in> ?Ra70 x x' xa x'a xb x'b x1 x2 x1a x2a x1b x2b x1c\n               x2c\\<rbrakk>\n       \\<Longrightarrow> gds_is_discovered gds xc x2c =\n                         gds_is_discovered gds x'c x2a\n 9. \\<And>x x' xa x'a xb x'b x1 x2 x1a x2a x1b x2b x1c x2c xc x'c.\n       \\<lbrakk>x = x'; xa = x'a; gen_cond x'a; gen_rwof x'a;\n        \\<not> gds_is_empty_stack gds x'a;\n        \\<not> gds_is_empty_stack gds x'a; pre_get_pending x'a;\n        (xb, x'b) \\<in> Id; inres (gds_get_pending gds x'a) xb;\n        inres (gds_get_pending gds x'a) x'b;\n        nofail (gds_get_pending gds x'a); nofail (gds_get_pending gds x'a);\n        x2 = (x1a, x2a); x'b = (x1, x2); x2b = (x1c, x2c); xb = (x1b, x2b);\n        x1c = Some xc; x1a = Some x'c;\n        (xc, x'c)\n        \\<in> ?Ra70 x x' xa x'a xb x'b x1 x2 x1a x2a x1b x2b x1c x2c;\n        gds_is_discovered gds xc x2c; gds_is_discovered gds x'c x2a\\<rbrakk>\n       \\<Longrightarrow> gds_is_finished gds xc x2c =\n                         gds_is_finished gds x'c x2a\n 10. \\<And>x x' xa x'a xb x'b x1 x2 x1a x2a x1b x2b x1c x2c xc x'c.\n        \\<lbrakk>x = x'; xa = x'a; gen_cond x'a; gen_rwof x'a;\n         \\<not> gds_is_empty_stack gds x'a;\n         \\<not> gds_is_empty_stack gds x'a; pre_get_pending x'a;\n         (xb, x'b) \\<in> Id; inres (gds_get_pending gds x'a) xb;\n         inres (gds_get_pending gds x'a) x'b;\n         nofail (gds_get_pending gds x'a); nofail (gds_get_pending gds x'a);\n         x2 = (x1a, x2a); x'b = (x1, x2); x2b = (x1c, x2c); xb = (x1b, x2b);\n         x1c = Some xc; x1a = Some x'c;\n         (xc, x'c)\n         \\<in> ?Ra70 x x' xa x'a xb x'b x1 x2 x1a x2a x1b x2b x1c x2c;\n         gds_is_discovered gds xc x2c; gds_is_discovered gds x'c x2a;\n         gds_is_finished gds xc x2c; gds_is_finished gds x'c x2a\\<rbrakk>\n        \\<Longrightarrow> pre_cross_edge x1b xc x'a x2c\nA total of 15 subgoals...", "apply refine_dref_type"], ["proof (prove)\ngoal (15 subgoals):\n 1. \\<And>x x' xa x'a.\n       \\<lbrakk>x = x'; xa = x'a; gen_cond x'a; gen_rwof x'a\\<rbrakk>\n       \\<Longrightarrow> gds_is_empty_stack gds x'a =\n                         gds_is_empty_stack gds x'a\n 2. \\<And>x x' xa x'a v0 v0a.\n       \\<lbrakk>x = x'; xa = x'a; gen_cond x'a; gen_rwof x'a;\n        gds_is_empty_stack gds x'a; gds_is_empty_stack gds x'a;\n        (v0, v0a) \\<in> Id;\n        inres\n         (SPEC\n           (\\<lambda>v0.\n               v0 \\<in> V0 \\<and> \\<not> gds_is_discovered gds v0 x'a))\n         v0;\n        inres\n         (SPEC\n           (\\<lambda>v0.\n               v0 \\<in> V0 \\<and> \\<not> gds_is_discovered gds v0 x'a))\n         v0a;\n        nofail\n         (SPEC\n           (\\<lambda>v0.\n               v0 \\<in> V0 \\<and> \\<not> gds_is_discovered gds v0 x'a));\n        nofail\n         (SPEC\n           (\\<lambda>v0.\n               v0 \\<in> V0 \\<and>\n               \\<not> gds_is_discovered gds v0 x'a))\\<rbrakk>\n       \\<Longrightarrow> pre_new_root v0 x'a\n 3. \\<And>x x' xa x'a v0 v0a.\n       \\<lbrakk>x = x'; xa = x'a; gen_cond x'a; gen_rwof x'a;\n        gds_is_empty_stack gds x'a; gds_is_empty_stack gds x'a;\n        (v0, v0a) \\<in> Id;\n        inres\n         (SPEC\n           (\\<lambda>v0.\n               v0 \\<in> V0 \\<and> \\<not> gds_is_discovered gds v0 x'a))\n         v0;\n        inres\n         (SPEC\n           (\\<lambda>v0.\n               v0 \\<in> V0 \\<and> \\<not> gds_is_discovered gds v0 x'a))\n         v0a;\n        nofail\n         (SPEC\n           (\\<lambda>v0.\n               v0 \\<in> V0 \\<and> \\<not> gds_is_discovered gds v0 x'a));\n        nofail\n         (SPEC\n           (\\<lambda>v0.\n               v0 \\<in> V0 \\<and> \\<not> gds_is_discovered gds v0 x'a));\n        pre_new_root v0 x'a\\<rbrakk>\n       \\<Longrightarrow> gds_new_root gds v0 x'a\n                         \\<le> \\<Down> Id (gds_new_root gds v0a x'a)\n 4. \\<And>x x' xa x'a.\n       \\<lbrakk>x = x'; xa = x'a; gen_cond x'a; gen_rwof x'a;\n        \\<not> gds_is_empty_stack gds x'a;\n        \\<not> gds_is_empty_stack gds x'a\\<rbrakk>\n       \\<Longrightarrow> pre_get_pending x'a\n 5. \\<And>x x' xa x'a xb x'b x1 x2 x1a x2a x1b x2b x1c x2c.\n       \\<lbrakk>x = x'; xa = x'a; gen_cond x'a; gen_rwof x'a;\n        \\<not> gds_is_empty_stack gds x'a;\n        \\<not> gds_is_empty_stack gds x'a; pre_get_pending x'a;\n        (xb, x'b) \\<in> Id; inres (gds_get_pending gds x'a) xb;\n        inres (gds_get_pending gds x'a) x'b;\n        nofail (gds_get_pending gds x'a); nofail (gds_get_pending gds x'a);\n        x2 = (x1a, x2a); x'b = (x1, x2); x2b = (x1c, x2c);\n        xb = (x1b, x2b)\\<rbrakk>\n       \\<Longrightarrow> (x1c, x1a) \\<in> \\<langle>Id\\<rangle>option_rel\n 6. \\<And>x x' xa x'a xb x'b x1 x2 x1a x2a x1b x2b x1c x2c.\n       \\<lbrakk>x = x'; xa = x'a; gen_cond x'a; gen_rwof x'a;\n        \\<not> gds_is_empty_stack gds x'a;\n        \\<not> gds_is_empty_stack gds x'a; pre_get_pending x'a;\n        (xb, x'b) \\<in> Id; inres (gds_get_pending gds x'a) xb;\n        inres (gds_get_pending gds x'a) x'b;\n        nofail (gds_get_pending gds x'a); nofail (gds_get_pending gds x'a);\n        x2 = (x1a, x2a); x'b = (x1, x2); x2b = (x1c, x2c); xb = (x1b, x2b);\n        x1c = None; x1a = None\\<rbrakk>\n       \\<Longrightarrow> pre_finish x1b x'a x2c\n 7. \\<And>x x' xa x'a xb x'b x1 x2 x1a x2a x1b x2b x1c x2c.\n       \\<lbrakk>x = x'; xa = x'a; gen_cond x'a; gen_rwof x'a;\n        \\<not> gds_is_empty_stack gds x'a;\n        \\<not> gds_is_empty_stack gds x'a; pre_get_pending x'a;\n        (xb, x'b) \\<in> Id; inres (gds_get_pending gds x'a) xb;\n        inres (gds_get_pending gds x'a) x'b;\n        nofail (gds_get_pending gds x'a); nofail (gds_get_pending gds x'a);\n        x2 = (x1a, x2a); x'b = (x1, x2); x2b = (x1c, x2c); xb = (x1b, x2b);\n        x1c = None; x1a = None; pre_finish x1b x'a x2c\\<rbrakk>\n       \\<Longrightarrow> gds_finish gds x1b x2c\n                         \\<le> \\<Down> Id (gds_finish gds x1 x2a)\n 8. \\<And>x x' xa x'a xb x'b x1 x2 x1a x2a x1b x2b x1c x2c xc x'c.\n       \\<lbrakk>x = x'; xa = x'a; gen_cond x'a; gen_rwof x'a;\n        \\<not> gds_is_empty_stack gds x'a;\n        \\<not> gds_is_empty_stack gds x'a; pre_get_pending x'a;\n        (xb, x'b) \\<in> Id; inres (gds_get_pending gds x'a) xb;\n        inres (gds_get_pending gds x'a) x'b;\n        nofail (gds_get_pending gds x'a); nofail (gds_get_pending gds x'a);\n        x2 = (x1a, x2a); x'b = (x1, x2); x2b = (x1c, x2c); xb = (x1b, x2b);\n        x1c = Some xc; x1a = Some x'c; (xc, x'c) \\<in> Id\\<rbrakk>\n       \\<Longrightarrow> gds_is_discovered gds xc x2c =\n                         gds_is_discovered gds x'c x2a\n 9. \\<And>x x' xa x'a xb x'b x1 x2 x1a x2a x1b x2b x1c x2c xc x'c.\n       \\<lbrakk>x = x'; xa = x'a; gen_cond x'a; gen_rwof x'a;\n        \\<not> gds_is_empty_stack gds x'a;\n        \\<not> gds_is_empty_stack gds x'a; pre_get_pending x'a;\n        (xb, x'b) \\<in> Id; inres (gds_get_pending gds x'a) xb;\n        inres (gds_get_pending gds x'a) x'b;\n        nofail (gds_get_pending gds x'a); nofail (gds_get_pending gds x'a);\n        x2 = (x1a, x2a); x'b = (x1, x2); x2b = (x1c, x2c); xb = (x1b, x2b);\n        x1c = Some xc; x1a = Some x'c; (xc, x'c) \\<in> Id;\n        gds_is_discovered gds xc x2c; gds_is_discovered gds x'c x2a\\<rbrakk>\n       \\<Longrightarrow> gds_is_finished gds xc x2c =\n                         gds_is_finished gds x'c x2a\n 10. \\<And>x x' xa x'a xb x'b x1 x2 x1a x2a x1b x2b x1c x2c xc x'c.\n        \\<lbrakk>x = x'; xa = x'a; gen_cond x'a; gen_rwof x'a;\n         \\<not> gds_is_empty_stack gds x'a;\n         \\<not> gds_is_empty_stack gds x'a; pre_get_pending x'a;\n         (xb, x'b) \\<in> Id; inres (gds_get_pending gds x'a) xb;\n         inres (gds_get_pending gds x'a) x'b;\n         nofail (gds_get_pending gds x'a); nofail (gds_get_pending gds x'a);\n         x2 = (x1a, x2a); x'b = (x1, x2); x2b = (x1c, x2c); xb = (x1b, x2b);\n         x1c = Some xc; x1a = Some x'c; (xc, x'c) \\<in> Id;\n         gds_is_discovered gds xc x2c; gds_is_discovered gds x'c x2a;\n         gds_is_finished gds xc x2c; gds_is_finished gds x'c x2a\\<rbrakk>\n        \\<Longrightarrow> pre_cross_edge x1b xc x'a x2c\nA total of 15 subgoals...", "by (auto simp: pre_defs gen_cond_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma gen_dfsT_eq_assert: \"gen_dfsT = gen_dfsT_assert\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gen_dfsT = gen_dfsT_assert", "unfolding gen_dfsT_def gen_dfsT_assert_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. gds_init gds \\<bind> WHILE\\<^sub>T gen_cond gen_step =\n    gds_init gds \\<bind> WHILE\\<^sub>T gen_cond gen_step_assert", "apply (rule antisym)"], ["proof (prove)\ngoal (2 subgoals):\n 1. gds_init gds \\<bind> WHILE\\<^sub>T gen_cond gen_step\n    \\<le> gds_init gds \\<bind> WHILE\\<^sub>T gen_cond gen_step_assert\n 2. gds_init gds \\<bind> WHILE\\<^sub>T gen_cond gen_step_assert\n    \\<le> gds_init gds \\<bind> WHILE\\<^sub>T gen_cond gen_step", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. gds_init gds \\<bind> WHILE\\<^sub>T gen_cond gen_step\n    \\<le> gds_init gds \\<bind> WHILE\\<^sub>T gen_cond gen_step_assert", "apply (unfold gen_step_def[abs_def] gen_step_assert_def[abs_def]) []"], ["proof (prove)\ngoal (1 subgoal):\n 1. gds_init gds \\<bind>\n    WHILE\\<^sub>T gen_cond\n     (\\<lambda>s.\n         if gds_is_empty_stack gds s\n         then SPEC\n               (\\<lambda>v0.\n                   v0 \\<in> V0 \\<and>\n                   \\<not> gds_is_discovered gds v0 s) \\<bind>\n              (\\<lambda>v0. gds_new_root gds v0 s)\n         else gds_get_pending gds s \\<bind>\n              (\\<lambda>(u, Vs, s).\n                  case Vs of None \\<Rightarrow> gds_finish gds u s\n                  | Some v \\<Rightarrow>\n                      if gds_is_discovered gds v s\n                      then if gds_is_finished gds v s\n                           then gds_cross_edge gds u v s\n                           else gds_back_edge gds u v s\n                      else gds_discover gds u v s))\n    \\<le> gds_init gds \\<bind>\n          WHILE\\<^sub>T gen_cond\n           (\\<lambda>s.\n               if gds_is_empty_stack gds s\n               then SPEC\n                     (\\<lambda>v0.\n                         v0 \\<in> V0 \\<and>\n                         \\<not> gds_is_discovered gds v0 s) \\<bind>\n                    (\\<lambda>v0.\n                        ASSERT (pre_new_root v0 s) \\<bind>\n                        (\\<lambda>_. gds_new_root gds v0 s))\n               else ASSERT (pre_get_pending s) \\<bind>\n                    (\\<lambda>_.\n                        let s0 = GHOST s\n                        in gds_get_pending gds s \\<bind>\n                           (\\<lambda>(u, Vs, s).\n                               case Vs of\n                               None \\<Rightarrow>\n                                 ASSERT (pre_finish u s0 s) \\<bind>\n                                 (\\<lambda>_. gds_finish gds u s)\n                               | Some v \\<Rightarrow>\n                                   if gds_is_discovered gds v s\n                                   then if gds_is_finished gds v s\n  then ASSERT (pre_cross_edge u v s0 s) \\<bind>\n       (\\<lambda>_. gds_cross_edge gds u v s)\n  else ASSERT (pre_back_edge u v s0 s) \\<bind>\n       (\\<lambda>_. gds_back_edge gds u v s)\n                                   else ASSERT\n   (pre_discover u v s0 s) \\<bind>\n  (\\<lambda>_. gds_discover gds u v s))))", "apply (unfold GHOST_elim_Let) []"], ["proof (prove)\ngoal (1 subgoal):\n 1. gds_init gds \\<bind>\n    WHILE\\<^sub>T gen_cond\n     (\\<lambda>s.\n         if gds_is_empty_stack gds s\n         then SPEC\n               (\\<lambda>v0.\n                   v0 \\<in> V0 \\<and>\n                   \\<not> gds_is_discovered gds v0 s) \\<bind>\n              (\\<lambda>v0. gds_new_root gds v0 s)\n         else gds_get_pending gds s \\<bind>\n              (\\<lambda>(u, Vs, s).\n                  case Vs of None \\<Rightarrow> gds_finish gds u s\n                  | Some v \\<Rightarrow>\n                      if gds_is_discovered gds v s\n                      then if gds_is_finished gds v s\n                           then gds_cross_edge gds u v s\n                           else gds_back_edge gds u v s\n                      else gds_discover gds u v s))\n    \\<le> gds_init gds \\<bind>\n          WHILE\\<^sub>T gen_cond\n           (\\<lambda>s.\n               if gds_is_empty_stack gds s\n               then SPEC\n                     (\\<lambda>v0.\n                         v0 \\<in> V0 \\<and>\n                         \\<not> gds_is_discovered gds v0 s) \\<bind>\n                    (\\<lambda>v0.\n                        ASSERT (pre_new_root v0 s) \\<bind>\n                        (\\<lambda>_. gds_new_root gds v0 s))\n               else ASSERT (pre_get_pending s) \\<bind>\n                    (\\<lambda>_.\n                        gds_get_pending gds s \\<bind>\n                        (\\<lambda>(u, Vs, sa).\n                            case Vs of\n                            None \\<Rightarrow>\n                              ASSERT (pre_finish u s sa) \\<bind>\n                              (\\<lambda>_. gds_finish gds u sa)\n                            | Some v \\<Rightarrow>\n                                if gds_is_discovered gds v sa\n                                then if gds_is_finished gds v sa\n                                     then ASSERT\n     (pre_cross_edge u v s sa) \\<bind>\n    (\\<lambda>_. gds_cross_edge gds u v sa)\n                                     else ASSERT\n     (pre_back_edge u v s sa) \\<bind>\n    (\\<lambda>_. gds_back_edge gds u v sa)\n                                else ASSERT (pre_discover u v s sa) \\<bind>\n                                     (\\<lambda>_.\n   gds_discover gds u v sa))))", "apply (rule refine_IdD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. gds_init gds \\<bind>\n    WHILE\\<^sub>T gen_cond\n     (\\<lambda>s.\n         if gds_is_empty_stack gds s\n         then SPEC\n               (\\<lambda>v0.\n                   v0 \\<in> V0 \\<and>\n                   \\<not> gds_is_discovered gds v0 s) \\<bind>\n              (\\<lambda>v0. gds_new_root gds v0 s)\n         else gds_get_pending gds s \\<bind>\n              (\\<lambda>(u, Vs, s).\n                  case Vs of None \\<Rightarrow> gds_finish gds u s\n                  | Some v \\<Rightarrow>\n                      if gds_is_discovered gds v s\n                      then if gds_is_finished gds v s\n                           then gds_cross_edge gds u v s\n                           else gds_back_edge gds u v s\n                      else gds_discover gds u v s))\n    \\<le> \\<Down> Id\n           (gds_init gds \\<bind>\n            WHILE\\<^sub>T gen_cond\n             (\\<lambda>s.\n                 if gds_is_empty_stack gds s\n                 then SPEC\n                       (\\<lambda>v0.\n                           v0 \\<in> V0 \\<and>\n                           \\<not> gds_is_discovered gds v0 s) \\<bind>\n                      (\\<lambda>v0.\n                          ASSERT (pre_new_root v0 s) \\<bind>\n                          (\\<lambda>_. gds_new_root gds v0 s))\n                 else ASSERT (pre_get_pending s) \\<bind>\n                      (\\<lambda>_.\n                          gds_get_pending gds s \\<bind>\n                          (\\<lambda>(u, Vs, sa).\n                              case Vs of\n                              None \\<Rightarrow>\n                                ASSERT (pre_finish u s sa) \\<bind>\n                                (\\<lambda>_. gds_finish gds u sa)\n                              | Some v \\<Rightarrow>\n                                  if gds_is_discovered gds v sa\n                                  then if gds_is_finished gds v sa\n then ASSERT (pre_cross_edge u v s sa) \\<bind>\n      (\\<lambda>_. gds_cross_edge gds u v sa)\n else ASSERT (pre_back_edge u v s sa) \\<bind>\n      (\\<lambda>_. gds_back_edge gds u v sa)\n                                  else ASSERT\n  (pre_discover u v s sa) \\<bind>\n (\\<lambda>_. gds_discover gds u v sa)))))", "by (refine_rcg, refine_dref_type, simp_all) []"], ["proof (prove)\ngoal (1 subgoal):\n 1. gds_init gds \\<bind> WHILE\\<^sub>T gen_cond gen_step_assert\n    \\<le> gds_init gds \\<bind> WHILE\\<^sub>T gen_cond gen_step", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. gds_init gds \\<bind> WHILE\\<^sub>T gen_cond gen_step_assert\n    \\<le> gds_init gds \\<bind> WHILE\\<^sub>T gen_cond gen_step", "apply (subst (2) WHILET_eq_I_rwof)"], ["proof (prove)\ngoal (1 subgoal):\n 1. gds_init gds \\<bind> WHILE\\<^sub>T gen_cond gen_step_assert\n    \\<le> gds_init gds \\<bind>\n          WHILE\\<^sub>T\\<^bsup>gen_rwof\\<^esup> gen_cond gen_step", "apply (rule refine_IdD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. gds_init gds \\<bind> WHILE\\<^sub>T gen_cond gen_step_assert\n    \\<le> \\<Down> Id\n           (gds_init gds \\<bind>\n            WHILE\\<^sub>T\\<^bsup>gen_rwof\\<^esup> gen_cond gen_step)", "apply (refine_rcg, simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x x' xa x'a.\n       \\<lbrakk>x = x'; xa = x'a; gen_cond x'a; gen_rwof x'a\\<rbrakk>\n       \\<Longrightarrow> gen_step_assert x'a \\<le> gen_step x'a", "apply (simp (no_asm) only: gen_step_def[abs_def] gen_step_assert_def[abs_def]) []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x x' xa x'a.\n       \\<lbrakk>x = x'; xa = x'a; gen_cond x'a; gen_rwof x'a\\<rbrakk>\n       \\<Longrightarrow> (if gds_is_empty_stack gds x'a\n                          then SPEC\n                                (\\<lambda>v0.\n                                    v0 \\<in> V0 \\<and>\n                                    \\<not> gds_is_discovered gds v0\n      x'a) \\<bind>\n                               (\\<lambda>v0.\n                                   ASSERT (pre_new_root v0 x'a) \\<bind>\n                                   (\\<lambda>_. gds_new_root gds v0 x'a))\n                          else ASSERT (pre_get_pending x'a) \\<bind>\n                               (\\<lambda>_.\n                                   let s0 = GHOST x'a\n                                   in gds_get_pending gds x'a \\<bind>\n(\\<lambda>(u, Vs, s).\n    case Vs of\n    None \\<Rightarrow>\n      ASSERT (pre_finish u s0 s) \\<bind> (\\<lambda>_. gds_finish gds u s)\n    | Some v \\<Rightarrow>\n        if gds_is_discovered gds v s\n        then if gds_is_finished gds v s\n             then ASSERT (pre_cross_edge u v s0 s) \\<bind>\n                  (\\<lambda>_. gds_cross_edge gds u v s)\n             else ASSERT (pre_back_edge u v s0 s) \\<bind>\n                  (\\<lambda>_. gds_back_edge gds u v s)\n        else ASSERT (pre_discover u v s0 s) \\<bind>\n             (\\<lambda>_. gds_discover gds u v s))))\n                         \\<le> (if gds_is_empty_stack gds x'a\n                                then SPEC\n(\\<lambda>v0.\n    v0 \\<in> V0 \\<and> \\<not> gds_is_discovered gds v0 x'a) \\<bind>\n                                     (\\<lambda>v0. gds_new_root gds v0 x'a)\n                                else gds_get_pending gds x'a \\<bind>\n                                     (\\<lambda>(u, Vs, s).\n   case Vs of None \\<Rightarrow> gds_finish gds u s\n   | Some v \\<Rightarrow>\n       if gds_is_discovered gds v s\n       then if gds_is_finished gds v s then gds_cross_edge gds u v s\n            else gds_back_edge gds u v s\n       else gds_discover gds u v s))", "apply (unfold GHOST_elim_Let) []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x x' xa x'a.\n       \\<lbrakk>x = x'; xa = x'a; gen_cond x'a; gen_rwof x'a\\<rbrakk>\n       \\<Longrightarrow> (if gds_is_empty_stack gds x'a\n                          then SPEC\n                                (\\<lambda>v0.\n                                    v0 \\<in> V0 \\<and>\n                                    \\<not> gds_is_discovered gds v0\n      x'a) \\<bind>\n                               (\\<lambda>v0.\n                                   ASSERT (pre_new_root v0 x'a) \\<bind>\n                                   (\\<lambda>_. gds_new_root gds v0 x'a))\n                          else ASSERT (pre_get_pending x'a) \\<bind>\n                               (\\<lambda>_.\n                                   gds_get_pending gds x'a \\<bind>\n                                   (\\<lambda>(u, Vs, s).\n case Vs of\n None \\<Rightarrow>\n   ASSERT (pre_finish u x'a s) \\<bind> (\\<lambda>_. gds_finish gds u s)\n | Some v \\<Rightarrow>\n     if gds_is_discovered gds v s\n     then if gds_is_finished gds v s\n          then ASSERT (pre_cross_edge u v x'a s) \\<bind>\n               (\\<lambda>_. gds_cross_edge gds u v s)\n          else ASSERT (pre_back_edge u v x'a s) \\<bind>\n               (\\<lambda>_. gds_back_edge gds u v s)\n     else ASSERT (pre_discover u v x'a s) \\<bind>\n          (\\<lambda>_. gds_discover gds u v s))))\n                         \\<le> (if gds_is_empty_stack gds x'a\n                                then SPEC\n(\\<lambda>v0.\n    v0 \\<in> V0 \\<and> \\<not> gds_is_discovered gds v0 x'a) \\<bind>\n                                     (\\<lambda>v0. gds_new_root gds v0 x'a)\n                                else gds_get_pending gds x'a \\<bind>\n                                     (\\<lambda>(u, Vs, s).\n   case Vs of None \\<Rightarrow> gds_finish gds u s\n   | Some v \\<Rightarrow>\n       if gds_is_discovered gds v s\n       then if gds_is_finished gds v s then gds_cross_edge gds u v s\n            else gds_back_edge gds u v s\n       else gds_discover gds u v s))", "apply (rule refine_IdD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x x' xa x'a.\n       \\<lbrakk>x = x'; xa = x'a; gen_cond x'a; gen_rwof x'a\\<rbrakk>\n       \\<Longrightarrow> (if gds_is_empty_stack gds x'a\n                          then SPEC\n                                (\\<lambda>v0.\n                                    v0 \\<in> V0 \\<and>\n                                    \\<not> gds_is_discovered gds v0\n      x'a) \\<bind>\n                               (\\<lambda>v0.\n                                   ASSERT (pre_new_root v0 x'a) \\<bind>\n                                   (\\<lambda>_. gds_new_root gds v0 x'a))\n                          else ASSERT (pre_get_pending x'a) \\<bind>\n                               (\\<lambda>_.\n                                   gds_get_pending gds x'a \\<bind>\n                                   (\\<lambda>(u, Vs, s).\n case Vs of\n None \\<Rightarrow>\n   ASSERT (pre_finish u x'a s) \\<bind> (\\<lambda>_. gds_finish gds u s)\n | Some v \\<Rightarrow>\n     if gds_is_discovered gds v s\n     then if gds_is_finished gds v s\n          then ASSERT (pre_cross_edge u v x'a s) \\<bind>\n               (\\<lambda>_. gds_cross_edge gds u v s)\n          else ASSERT (pre_back_edge u v x'a s) \\<bind>\n               (\\<lambda>_. gds_back_edge gds u v s)\n     else ASSERT (pre_discover u v x'a s) \\<bind>\n          (\\<lambda>_. gds_discover gds u v s))))\n                         \\<le> \\<Down> Id\n                                (if gds_is_empty_stack gds x'a\n                                 then SPEC\n (\\<lambda>v0.\n     v0 \\<in> V0 \\<and> \\<not> gds_is_discovered gds v0 x'a) \\<bind>\n(\\<lambda>v0. gds_new_root gds v0 x'a)\n                                 else gds_get_pending gds x'a \\<bind>\n(\\<lambda>(u, Vs, s).\n    case Vs of None \\<Rightarrow> gds_finish gds u s\n    | Some v \\<Rightarrow>\n        if gds_is_discovered gds v s\n        then if gds_is_finished gds v s then gds_cross_edge gds u v s\n             else gds_back_edge gds u v s\n        else gds_discover gds u v s))", "apply (refine_rcg bind_refine', refine_dref_type)"], ["proof (prove)\ngoal (15 subgoals):\n 1. \\<And>x x' xa x'a.\n       \\<lbrakk>x = x'; xa = x'a; gen_cond x'a; gen_rwof x'a\\<rbrakk>\n       \\<Longrightarrow> gds_is_empty_stack gds x'a =\n                         gds_is_empty_stack gds x'a\n 2. \\<And>x x' xa x'a v0 v0a.\n       \\<lbrakk>x = x'; xa = x'a; gen_cond x'a; gen_rwof x'a;\n        gds_is_empty_stack gds x'a; gds_is_empty_stack gds x'a;\n        (v0, v0a) \\<in> Id;\n        inres\n         (SPEC\n           (\\<lambda>v0.\n               v0 \\<in> V0 \\<and> \\<not> gds_is_discovered gds v0 x'a))\n         v0;\n        inres\n         (SPEC\n           (\\<lambda>v0.\n               v0 \\<in> V0 \\<and> \\<not> gds_is_discovered gds v0 x'a))\n         v0a;\n        nofail\n         (SPEC\n           (\\<lambda>v0.\n               v0 \\<in> V0 \\<and> \\<not> gds_is_discovered gds v0 x'a));\n        nofail\n         (SPEC\n           (\\<lambda>v0.\n               v0 \\<in> V0 \\<and>\n               \\<not> gds_is_discovered gds v0 x'a))\\<rbrakk>\n       \\<Longrightarrow> pre_new_root v0 x'a\n 3. \\<And>x x' xa x'a v0 v0a.\n       \\<lbrakk>x = x'; xa = x'a; gen_cond x'a; gen_rwof x'a;\n        gds_is_empty_stack gds x'a; gds_is_empty_stack gds x'a;\n        (v0, v0a) \\<in> Id;\n        inres\n         (SPEC\n           (\\<lambda>v0.\n               v0 \\<in> V0 \\<and> \\<not> gds_is_discovered gds v0 x'a))\n         v0;\n        inres\n         (SPEC\n           (\\<lambda>v0.\n               v0 \\<in> V0 \\<and> \\<not> gds_is_discovered gds v0 x'a))\n         v0a;\n        nofail\n         (SPEC\n           (\\<lambda>v0.\n               v0 \\<in> V0 \\<and> \\<not> gds_is_discovered gds v0 x'a));\n        nofail\n         (SPEC\n           (\\<lambda>v0.\n               v0 \\<in> V0 \\<and> \\<not> gds_is_discovered gds v0 x'a));\n        pre_new_root v0 x'a\\<rbrakk>\n       \\<Longrightarrow> gds_new_root gds v0 x'a\n                         \\<le> \\<Down> Id (gds_new_root gds v0a x'a)\n 4. \\<And>x x' xa x'a.\n       \\<lbrakk>x = x'; xa = x'a; gen_cond x'a; gen_rwof x'a;\n        \\<not> gds_is_empty_stack gds x'a;\n        \\<not> gds_is_empty_stack gds x'a\\<rbrakk>\n       \\<Longrightarrow> pre_get_pending x'a\n 5. \\<And>x x' xa x'a xb x'b x1 x2 x1a x2a x1b x2b x1c x2c.\n       \\<lbrakk>x = x'; xa = x'a; gen_cond x'a; gen_rwof x'a;\n        \\<not> gds_is_empty_stack gds x'a;\n        \\<not> gds_is_empty_stack gds x'a; pre_get_pending x'a;\n        (xb, x'b) \\<in> Id; inres (gds_get_pending gds x'a) xb;\n        inres (gds_get_pending gds x'a) x'b;\n        nofail (gds_get_pending gds x'a); nofail (gds_get_pending gds x'a);\n        x2 = (x1a, x2a); x'b = (x1, x2); x2b = (x1c, x2c);\n        xb = (x1b, x2b)\\<rbrakk>\n       \\<Longrightarrow> (x1c, x1a) \\<in> \\<langle>Id\\<rangle>option_rel\n 6. \\<And>x x' xa x'a xb x'b x1 x2 x1a x2a x1b x2b x1c x2c.\n       \\<lbrakk>x = x'; xa = x'a; gen_cond x'a; gen_rwof x'a;\n        \\<not> gds_is_empty_stack gds x'a;\n        \\<not> gds_is_empty_stack gds x'a; pre_get_pending x'a;\n        (xb, x'b) \\<in> Id; inres (gds_get_pending gds x'a) xb;\n        inres (gds_get_pending gds x'a) x'b;\n        nofail (gds_get_pending gds x'a); nofail (gds_get_pending gds x'a);\n        x2 = (x1a, x2a); x'b = (x1, x2); x2b = (x1c, x2c); xb = (x1b, x2b);\n        x1c = None; x1a = None\\<rbrakk>\n       \\<Longrightarrow> pre_finish x1b x'a x2c\n 7. \\<And>x x' xa x'a xb x'b x1 x2 x1a x2a x1b x2b x1c x2c.\n       \\<lbrakk>x = x'; xa = x'a; gen_cond x'a; gen_rwof x'a;\n        \\<not> gds_is_empty_stack gds x'a;\n        \\<not> gds_is_empty_stack gds x'a; pre_get_pending x'a;\n        (xb, x'b) \\<in> Id; inres (gds_get_pending gds x'a) xb;\n        inres (gds_get_pending gds x'a) x'b;\n        nofail (gds_get_pending gds x'a); nofail (gds_get_pending gds x'a);\n        x2 = (x1a, x2a); x'b = (x1, x2); x2b = (x1c, x2c); xb = (x1b, x2b);\n        x1c = None; x1a = None; pre_finish x1b x'a x2c\\<rbrakk>\n       \\<Longrightarrow> gds_finish gds x1b x2c\n                         \\<le> \\<Down> Id (gds_finish gds x1 x2a)\n 8. \\<And>x x' xa x'a xb x'b x1 x2 x1a x2a x1b x2b x1c x2c xc x'c.\n       \\<lbrakk>x = x'; xa = x'a; gen_cond x'a; gen_rwof x'a;\n        \\<not> gds_is_empty_stack gds x'a;\n        \\<not> gds_is_empty_stack gds x'a; pre_get_pending x'a;\n        (xb, x'b) \\<in> Id; inres (gds_get_pending gds x'a) xb;\n        inres (gds_get_pending gds x'a) x'b;\n        nofail (gds_get_pending gds x'a); nofail (gds_get_pending gds x'a);\n        x2 = (x1a, x2a); x'b = (x1, x2); x2b = (x1c, x2c); xb = (x1b, x2b);\n        x1c = Some xc; x1a = Some x'c; (xc, x'c) \\<in> Id\\<rbrakk>\n       \\<Longrightarrow> gds_is_discovered gds xc x2c =\n                         gds_is_discovered gds x'c x2a\n 9. \\<And>x x' xa x'a xb x'b x1 x2 x1a x2a x1b x2b x1c x2c xc x'c.\n       \\<lbrakk>x = x'; xa = x'a; gen_cond x'a; gen_rwof x'a;\n        \\<not> gds_is_empty_stack gds x'a;\n        \\<not> gds_is_empty_stack gds x'a; pre_get_pending x'a;\n        (xb, x'b) \\<in> Id; inres (gds_get_pending gds x'a) xb;\n        inres (gds_get_pending gds x'a) x'b;\n        nofail (gds_get_pending gds x'a); nofail (gds_get_pending gds x'a);\n        x2 = (x1a, x2a); x'b = (x1, x2); x2b = (x1c, x2c); xb = (x1b, x2b);\n        x1c = Some xc; x1a = Some x'c; (xc, x'c) \\<in> Id;\n        gds_is_discovered gds xc x2c; gds_is_discovered gds x'c x2a\\<rbrakk>\n       \\<Longrightarrow> gds_is_finished gds xc x2c =\n                         gds_is_finished gds x'c x2a\n 10. \\<And>x x' xa x'a xb x'b x1 x2 x1a x2a x1b x2b x1c x2c xc x'c.\n        \\<lbrakk>x = x'; xa = x'a; gen_cond x'a; gen_rwof x'a;\n         \\<not> gds_is_empty_stack gds x'a;\n         \\<not> gds_is_empty_stack gds x'a; pre_get_pending x'a;\n         (xb, x'b) \\<in> Id; inres (gds_get_pending gds x'a) xb;\n         inres (gds_get_pending gds x'a) x'b;\n         nofail (gds_get_pending gds x'a); nofail (gds_get_pending gds x'a);\n         x2 = (x1a, x2a); x'b = (x1, x2); x2b = (x1c, x2c); xb = (x1b, x2b);\n         x1c = Some xc; x1a = Some x'c; (xc, x'c) \\<in> Id;\n         gds_is_discovered gds xc x2c; gds_is_discovered gds x'c x2a;\n         gds_is_finished gds xc x2c; gds_is_finished gds x'c x2a\\<rbrakk>\n        \\<Longrightarrow> pre_cross_edge x1b xc x'a x2c\nA total of 15 subgoals...", "by (auto simp: pre_defs gen_cond_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma gen_rwof_eq_assert:\n    assumes NF: \"nofail gen_dfs\"\n    shows \"gen_rwof = gen_rwof_assert\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gen_rwof = gen_rwof_assert", "apply (rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. gen_rwof x = gen_rwof_assert x", "apply (rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x. gen_rwof x \\<Longrightarrow> gen_rwof_assert x\n 2. \\<And>x. gen_rwof_assert x \\<Longrightarrow> gen_rwof x", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. gen_rwof x_ \\<Longrightarrow> gen_rwof_assert x_", "apply (rule rwof_step_refine)"], ["proof (prove)\ngoal (3 subgoals):\n 1. gen_rwof x_ \\<Longrightarrow>\n    nofail (gds_init gds \\<bind> WHILE gen_cond gen_step_assert)\n 2. gen_rwof x_ \\<Longrightarrow> rwof (gds_init gds) gen_cond ?step' x_\n 3. \\<And>s.\n       \\<lbrakk>gen_rwof x_; gen_rwof_assert s; gen_cond s\\<rbrakk>\n       \\<Longrightarrow> ?step' s \\<le>\\<^sub>n gen_step_assert s", "apply (fold gen_dfs_assert_def gen_dfs_eq_assert, rule NF)"], ["proof (prove)\ngoal (2 subgoals):\n 1. gen_rwof x_ \\<Longrightarrow> rwof (gds_init gds) gen_cond ?step' x_\n 2. \\<And>s.\n       \\<lbrakk>gen_rwof x_; gen_rwof_assert s; gen_cond s\\<rbrakk>\n       \\<Longrightarrow> ?step' s \\<le>\\<^sub>n gen_step_assert s", "apply assumption"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>gen_rwof x_; gen_rwof_assert s; gen_cond s\\<rbrakk>\n       \\<Longrightarrow> gen_step s \\<le>\\<^sub>n gen_step_assert s", "apply (simp (no_asm) only: gen_step_def[abs_def] gen_step_assert_def[abs_def]) []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>gen_rwof x_; gen_rwof_assert s; gen_cond s\\<rbrakk>\n       \\<Longrightarrow> (if gds_is_empty_stack gds s\n                          then SPEC\n                                (\\<lambda>v0.\n                                    v0 \\<in> V0 \\<and>\n                                    \\<not> gds_is_discovered gds v0\n      s) \\<bind>\n                               (\\<lambda>v0. gds_new_root gds v0 s)\n                          else gds_get_pending gds s \\<bind>\n                               (\\<lambda>(u, Vs, s).\n                                   case Vs of\n                                   None \\<Rightarrow> gds_finish gds u s\n                                   | Some v \\<Rightarrow>\n if gds_is_discovered gds v s\n then if gds_is_finished gds v s then gds_cross_edge gds u v s\n      else gds_back_edge gds u v s\n else gds_discover gds u v s)) \\<le>\\<^sub>n\n                         (if gds_is_empty_stack gds s\n                          then SPEC\n                                (\\<lambda>v0.\n                                    v0 \\<in> V0 \\<and>\n                                    \\<not> gds_is_discovered gds v0\n      s) \\<bind>\n                               (\\<lambda>v0.\n                                   ASSERT (pre_new_root v0 s) \\<bind>\n                                   (\\<lambda>_. gds_new_root gds v0 s))\n                          else ASSERT (pre_get_pending s) \\<bind>\n                               (\\<lambda>_.\n                                   let s0 = GHOST s\n                                   in gds_get_pending gds s \\<bind>\n(\\<lambda>(u, Vs, s).\n    case Vs of\n    None \\<Rightarrow>\n      ASSERT (pre_finish u s0 s) \\<bind> (\\<lambda>_. gds_finish gds u s)\n    | Some v \\<Rightarrow>\n        if gds_is_discovered gds v s\n        then if gds_is_finished gds v s\n             then ASSERT (pre_cross_edge u v s0 s) \\<bind>\n                  (\\<lambda>_. gds_cross_edge gds u v s)\n             else ASSERT (pre_back_edge u v s0 s) \\<bind>\n                  (\\<lambda>_. gds_back_edge gds u v s)\n        else ASSERT (pre_discover u v s0 s) \\<bind>\n             (\\<lambda>_. gds_discover gds u v s))))", "apply (unfold GHOST_elim_Let) []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>gen_rwof x_; gen_rwof_assert s; gen_cond s\\<rbrakk>\n       \\<Longrightarrow> (if gds_is_empty_stack gds s\n                          then SPEC\n                                (\\<lambda>v0.\n                                    v0 \\<in> V0 \\<and>\n                                    \\<not> gds_is_discovered gds v0\n      s) \\<bind>\n                               (\\<lambda>v0. gds_new_root gds v0 s)\n                          else gds_get_pending gds s \\<bind>\n                               (\\<lambda>(u, Vs, s).\n                                   case Vs of\n                                   None \\<Rightarrow> gds_finish gds u s\n                                   | Some v \\<Rightarrow>\n if gds_is_discovered gds v s\n then if gds_is_finished gds v s then gds_cross_edge gds u v s\n      else gds_back_edge gds u v s\n else gds_discover gds u v s)) \\<le>\\<^sub>n\n                         (if gds_is_empty_stack gds s\n                          then SPEC\n                                (\\<lambda>v0.\n                                    v0 \\<in> V0 \\<and>\n                                    \\<not> gds_is_discovered gds v0\n      s) \\<bind>\n                               (\\<lambda>v0.\n                                   ASSERT (pre_new_root v0 s) \\<bind>\n                                   (\\<lambda>_. gds_new_root gds v0 s))\n                          else ASSERT (pre_get_pending s) \\<bind>\n                               (\\<lambda>_.\n                                   gds_get_pending gds s \\<bind>\n                                   (\\<lambda>(u, Vs, sa).\n case Vs of\n None \\<Rightarrow>\n   ASSERT (pre_finish u s sa) \\<bind> (\\<lambda>_. gds_finish gds u sa)\n | Some v \\<Rightarrow>\n     if gds_is_discovered gds v sa\n     then if gds_is_finished gds v sa\n          then ASSERT (pre_cross_edge u v s sa) \\<bind>\n               (\\<lambda>_. gds_cross_edge gds u v sa)\n          else ASSERT (pre_back_edge u v s sa) \\<bind>\n               (\\<lambda>_. gds_back_edge gds u v sa)\n     else ASSERT (pre_discover u v s sa) \\<bind>\n          (\\<lambda>_. gds_discover gds u v sa))))", "apply (rule leofI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>gen_rwof x_; gen_rwof_assert s; gen_cond s;\n        nofail\n         (if gds_is_empty_stack gds s\n          then SPEC\n                (\\<lambda>v0.\n                    v0 \\<in> V0 \\<and>\n                    \\<not> gds_is_discovered gds v0 s) \\<bind>\n               (\\<lambda>v0. gds_new_root gds v0 s)\n          else gds_get_pending gds s \\<bind>\n               (\\<lambda>(u, Vs, s).\n                   case Vs of None \\<Rightarrow> gds_finish gds u s\n                   | Some v \\<Rightarrow>\n                       if gds_is_discovered gds v s\n                       then if gds_is_finished gds v s\n                            then gds_cross_edge gds u v s\n                            else gds_back_edge gds u v s\n                       else gds_discover gds u v s))\\<rbrakk>\n       \\<Longrightarrow> (if gds_is_empty_stack gds s\n                          then SPEC\n                                (\\<lambda>v0.\n                                    v0 \\<in> V0 \\<and>\n                                    \\<not> gds_is_discovered gds v0\n      s) \\<bind>\n                               (\\<lambda>v0. gds_new_root gds v0 s)\n                          else gds_get_pending gds s \\<bind>\n                               (\\<lambda>(u, Vs, s).\n                                   case Vs of\n                                   None \\<Rightarrow> gds_finish gds u s\n                                   | Some v \\<Rightarrow>\n if gds_is_discovered gds v s\n then if gds_is_finished gds v s then gds_cross_edge gds u v s\n      else gds_back_edge gds u v s\n else gds_discover gds u v s))\n                         \\<le> (if gds_is_empty_stack gds s\n                                then SPEC\n(\\<lambda>v0. v0 \\<in> V0 \\<and> \\<not> gds_is_discovered gds v0 s) \\<bind>\n                                     (\\<lambda>v0.\n   ASSERT (pre_new_root v0 s) \\<bind> (\\<lambda>_. gds_new_root gds v0 s))\n                                else ASSERT (pre_get_pending s) \\<bind>\n                                     (\\<lambda>_.\n   gds_get_pending gds s \\<bind>\n   (\\<lambda>(u, Vs, sa).\n       case Vs of\n       None \\<Rightarrow>\n         ASSERT (pre_finish u s sa) \\<bind>\n         (\\<lambda>_. gds_finish gds u sa)\n       | Some v \\<Rightarrow>\n           if gds_is_discovered gds v sa\n           then if gds_is_finished gds v sa\n                then ASSERT (pre_cross_edge u v s sa) \\<bind>\n                     (\\<lambda>_. gds_cross_edge gds u v sa)\n                else ASSERT (pre_back_edge u v s sa) \\<bind>\n                     (\\<lambda>_. gds_back_edge gds u v sa)\n           else ASSERT (pre_discover u v s sa) \\<bind>\n                (\\<lambda>_. gds_discover gds u v sa))))", "apply (rule refine_IdD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>gen_rwof x_; gen_rwof_assert s; gen_cond s;\n        nofail\n         (if gds_is_empty_stack gds s\n          then SPEC\n                (\\<lambda>v0.\n                    v0 \\<in> V0 \\<and>\n                    \\<not> gds_is_discovered gds v0 s) \\<bind>\n               (\\<lambda>v0. gds_new_root gds v0 s)\n          else gds_get_pending gds s \\<bind>\n               (\\<lambda>(u, Vs, s).\n                   case Vs of None \\<Rightarrow> gds_finish gds u s\n                   | Some v \\<Rightarrow>\n                       if gds_is_discovered gds v s\n                       then if gds_is_finished gds v s\n                            then gds_cross_edge gds u v s\n                            else gds_back_edge gds u v s\n                       else gds_discover gds u v s))\\<rbrakk>\n       \\<Longrightarrow> (if gds_is_empty_stack gds s\n                          then SPEC\n                                (\\<lambda>v0.\n                                    v0 \\<in> V0 \\<and>\n                                    \\<not> gds_is_discovered gds v0\n      s) \\<bind>\n                               (\\<lambda>v0. gds_new_root gds v0 s)\n                          else gds_get_pending gds s \\<bind>\n                               (\\<lambda>(u, Vs, s).\n                                   case Vs of\n                                   None \\<Rightarrow> gds_finish gds u s\n                                   | Some v \\<Rightarrow>\n if gds_is_discovered gds v s\n then if gds_is_finished gds v s then gds_cross_edge gds u v s\n      else gds_back_edge gds u v s\n else gds_discover gds u v s))\n                         \\<le> \\<Down> Id\n                                (if gds_is_empty_stack gds s\n                                 then SPEC\n (\\<lambda>v0. v0 \\<in> V0 \\<and> \\<not> gds_is_discovered gds v0 s) \\<bind>\n(\\<lambda>v0.\n    ASSERT (pre_new_root v0 s) \\<bind> (\\<lambda>_. gds_new_root gds v0 s))\n                                 else ASSERT (pre_get_pending s) \\<bind>\n(\\<lambda>_.\n    gds_get_pending gds s \\<bind>\n    (\\<lambda>(u, Vs, sa).\n        case Vs of\n        None \\<Rightarrow>\n          ASSERT (pre_finish u s sa) \\<bind>\n          (\\<lambda>_. gds_finish gds u sa)\n        | Some v \\<Rightarrow>\n            if gds_is_discovered gds v sa\n            then if gds_is_finished gds v sa\n                 then ASSERT (pre_cross_edge u v s sa) \\<bind>\n                      (\\<lambda>_. gds_cross_edge gds u v sa)\n                 else ASSERT (pre_back_edge u v s sa) \\<bind>\n                      (\\<lambda>_. gds_back_edge gds u v sa)\n            else ASSERT (pre_discover u v s sa) \\<bind>\n                 (\\<lambda>_. gds_discover gds u v sa))))", "by (refine_rcg bind_refine', refine_dref_type,\n              auto simp: pre_defs gen_cond_def) []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. gen_rwof_assert x \\<Longrightarrow> gen_rwof x", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. gen_rwof_assert x_ \\<Longrightarrow> gen_rwof x_", "apply (rule rwof_step_refine)"], ["proof (prove)\ngoal (3 subgoals):\n 1. gen_rwof_assert x_ \\<Longrightarrow>\n    nofail (gds_init gds \\<bind> WHILE gen_cond gen_step)\n 2. gen_rwof_assert x_ \\<Longrightarrow>\n    rwof (gds_init gds) gen_cond ?step' x_\n 3. \\<And>s.\n       \\<lbrakk>gen_rwof_assert x_; gen_rwof s; gen_cond s\\<rbrakk>\n       \\<Longrightarrow> ?step' s \\<le>\\<^sub>n gen_step s", "apply (fold gen_dfs_def, rule NF)"], ["proof (prove)\ngoal (2 subgoals):\n 1. gen_rwof_assert x_ \\<Longrightarrow>\n    rwof (gds_init gds) gen_cond ?step' x_\n 2. \\<And>s.\n       \\<lbrakk>gen_rwof_assert x_; gen_rwof s; gen_cond s\\<rbrakk>\n       \\<Longrightarrow> ?step' s \\<le>\\<^sub>n gen_step s", "apply assumption"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>gen_rwof_assert x_; gen_rwof s; gen_cond s\\<rbrakk>\n       \\<Longrightarrow> gen_step_assert s \\<le>\\<^sub>n gen_step s", "apply (simp (no_asm) only: gen_step_def[abs_def] gen_step_assert_def[abs_def]) []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>gen_rwof_assert x_; gen_rwof s; gen_cond s\\<rbrakk>\n       \\<Longrightarrow> (if gds_is_empty_stack gds s\n                          then SPEC\n                                (\\<lambda>v0.\n                                    v0 \\<in> V0 \\<and>\n                                    \\<not> gds_is_discovered gds v0\n      s) \\<bind>\n                               (\\<lambda>v0.\n                                   ASSERT (pre_new_root v0 s) \\<bind>\n                                   (\\<lambda>_. gds_new_root gds v0 s))\n                          else ASSERT (pre_get_pending s) \\<bind>\n                               (\\<lambda>_.\n                                   let s0 = GHOST s\n                                   in gds_get_pending gds s \\<bind>\n(\\<lambda>(u, Vs, s).\n    case Vs of\n    None \\<Rightarrow>\n      ASSERT (pre_finish u s0 s) \\<bind> (\\<lambda>_. gds_finish gds u s)\n    | Some v \\<Rightarrow>\n        if gds_is_discovered gds v s\n        then if gds_is_finished gds v s\n             then ASSERT (pre_cross_edge u v s0 s) \\<bind>\n                  (\\<lambda>_. gds_cross_edge gds u v s)\n             else ASSERT (pre_back_edge u v s0 s) \\<bind>\n                  (\\<lambda>_. gds_back_edge gds u v s)\n        else ASSERT (pre_discover u v s0 s) \\<bind>\n             (\\<lambda>_. gds_discover gds u v s)))) \\<le>\\<^sub>n\n                         (if gds_is_empty_stack gds s\n                          then SPEC\n                                (\\<lambda>v0.\n                                    v0 \\<in> V0 \\<and>\n                                    \\<not> gds_is_discovered gds v0\n      s) \\<bind>\n                               (\\<lambda>v0. gds_new_root gds v0 s)\n                          else gds_get_pending gds s \\<bind>\n                               (\\<lambda>(u, Vs, s).\n                                   case Vs of\n                                   None \\<Rightarrow> gds_finish gds u s\n                                   | Some v \\<Rightarrow>\n if gds_is_discovered gds v s\n then if gds_is_finished gds v s then gds_cross_edge gds u v s\n      else gds_back_edge gds u v s\n else gds_discover gds u v s))", "apply (unfold GHOST_elim_Let) []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>gen_rwof_assert x_; gen_rwof s; gen_cond s\\<rbrakk>\n       \\<Longrightarrow> (if gds_is_empty_stack gds s\n                          then SPEC\n                                (\\<lambda>v0.\n                                    v0 \\<in> V0 \\<and>\n                                    \\<not> gds_is_discovered gds v0\n      s) \\<bind>\n                               (\\<lambda>v0.\n                                   ASSERT (pre_new_root v0 s) \\<bind>\n                                   (\\<lambda>_. gds_new_root gds v0 s))\n                          else ASSERT (pre_get_pending s) \\<bind>\n                               (\\<lambda>_.\n                                   gds_get_pending gds s \\<bind>\n                                   (\\<lambda>(u, Vs, sa).\n case Vs of\n None \\<Rightarrow>\n   ASSERT (pre_finish u s sa) \\<bind> (\\<lambda>_. gds_finish gds u sa)\n | Some v \\<Rightarrow>\n     if gds_is_discovered gds v sa\n     then if gds_is_finished gds v sa\n          then ASSERT (pre_cross_edge u v s sa) \\<bind>\n               (\\<lambda>_. gds_cross_edge gds u v sa)\n          else ASSERT (pre_back_edge u v s sa) \\<bind>\n               (\\<lambda>_. gds_back_edge gds u v sa)\n     else ASSERT (pre_discover u v s sa) \\<bind>\n          (\\<lambda>_. gds_discover gds u v sa)))) \\<le>\\<^sub>n\n                         (if gds_is_empty_stack gds s\n                          then SPEC\n                                (\\<lambda>v0.\n                                    v0 \\<in> V0 \\<and>\n                                    \\<not> gds_is_discovered gds v0\n      s) \\<bind>\n                               (\\<lambda>v0. gds_new_root gds v0 s)\n                          else gds_get_pending gds s \\<bind>\n                               (\\<lambda>(u, Vs, s).\n                                   case Vs of\n                                   None \\<Rightarrow> gds_finish gds u s\n                                   | Some v \\<Rightarrow>\n if gds_is_discovered gds v s\n then if gds_is_finished gds v s then gds_cross_edge gds u v s\n      else gds_back_edge gds u v s\n else gds_discover gds u v s))", "apply (rule leofI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>gen_rwof_assert x_; gen_rwof s; gen_cond s;\n        nofail\n         (if gds_is_empty_stack gds s\n          then SPEC\n                (\\<lambda>v0.\n                    v0 \\<in> V0 \\<and>\n                    \\<not> gds_is_discovered gds v0 s) \\<bind>\n               (\\<lambda>v0.\n                   ASSERT (pre_new_root v0 s) \\<bind>\n                   (\\<lambda>_. gds_new_root gds v0 s))\n          else ASSERT (pre_get_pending s) \\<bind>\n               (\\<lambda>_.\n                   gds_get_pending gds s \\<bind>\n                   (\\<lambda>(u, Vs, sa).\n                       case Vs of\n                       None \\<Rightarrow>\n                         ASSERT (pre_finish u s sa) \\<bind>\n                         (\\<lambda>_. gds_finish gds u sa)\n                       | Some v \\<Rightarrow>\n                           if gds_is_discovered gds v sa\n                           then if gds_is_finished gds v sa\n                                then ASSERT\n(pre_cross_edge u v s sa) \\<bind>\n                                     (\\<lambda>_. gds_cross_edge gds u v sa)\n                                else ASSERT (pre_back_edge u v s sa) \\<bind>\n                                     (\\<lambda>_. gds_back_edge gds u v sa)\n                           else ASSERT (pre_discover u v s sa) \\<bind>\n                                (\\<lambda>_.\n                                    gds_discover gds u v sa))))\\<rbrakk>\n       \\<Longrightarrow> (if gds_is_empty_stack gds s\n                          then SPEC\n                                (\\<lambda>v0.\n                                    v0 \\<in> V0 \\<and>\n                                    \\<not> gds_is_discovered gds v0\n      s) \\<bind>\n                               (\\<lambda>v0.\n                                   ASSERT (pre_new_root v0 s) \\<bind>\n                                   (\\<lambda>_. gds_new_root gds v0 s))\n                          else ASSERT (pre_get_pending s) \\<bind>\n                               (\\<lambda>_.\n                                   gds_get_pending gds s \\<bind>\n                                   (\\<lambda>(u, Vs, sa).\n case Vs of\n None \\<Rightarrow>\n   ASSERT (pre_finish u s sa) \\<bind> (\\<lambda>_. gds_finish gds u sa)\n | Some v \\<Rightarrow>\n     if gds_is_discovered gds v sa\n     then if gds_is_finished gds v sa\n          then ASSERT (pre_cross_edge u v s sa) \\<bind>\n               (\\<lambda>_. gds_cross_edge gds u v sa)\n          else ASSERT (pre_back_edge u v s sa) \\<bind>\n               (\\<lambda>_. gds_back_edge gds u v sa)\n     else ASSERT (pre_discover u v s sa) \\<bind>\n          (\\<lambda>_. gds_discover gds u v sa))))\n                         \\<le> (if gds_is_empty_stack gds s\n                                then SPEC\n(\\<lambda>v0. v0 \\<in> V0 \\<and> \\<not> gds_is_discovered gds v0 s) \\<bind>\n                                     (\\<lambda>v0. gds_new_root gds v0 s)\n                                else gds_get_pending gds s \\<bind>\n                                     (\\<lambda>(u, Vs, s).\n   case Vs of None \\<Rightarrow> gds_finish gds u s\n   | Some v \\<Rightarrow>\n       if gds_is_discovered gds v s\n       then if gds_is_finished gds v s then gds_cross_edge gds u v s\n            else gds_back_edge gds u v s\n       else gds_discover gds u v s))", "apply (rule refine_IdD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>gen_rwof_assert x_; gen_rwof s; gen_cond s;\n        nofail\n         (if gds_is_empty_stack gds s\n          then SPEC\n                (\\<lambda>v0.\n                    v0 \\<in> V0 \\<and>\n                    \\<not> gds_is_discovered gds v0 s) \\<bind>\n               (\\<lambda>v0.\n                   ASSERT (pre_new_root v0 s) \\<bind>\n                   (\\<lambda>_. gds_new_root gds v0 s))\n          else ASSERT (pre_get_pending s) \\<bind>\n               (\\<lambda>_.\n                   gds_get_pending gds s \\<bind>\n                   (\\<lambda>(u, Vs, sa).\n                       case Vs of\n                       None \\<Rightarrow>\n                         ASSERT (pre_finish u s sa) \\<bind>\n                         (\\<lambda>_. gds_finish gds u sa)\n                       | Some v \\<Rightarrow>\n                           if gds_is_discovered gds v sa\n                           then if gds_is_finished gds v sa\n                                then ASSERT\n(pre_cross_edge u v s sa) \\<bind>\n                                     (\\<lambda>_. gds_cross_edge gds u v sa)\n                                else ASSERT (pre_back_edge u v s sa) \\<bind>\n                                     (\\<lambda>_. gds_back_edge gds u v sa)\n                           else ASSERT (pre_discover u v s sa) \\<bind>\n                                (\\<lambda>_.\n                                    gds_discover gds u v sa))))\\<rbrakk>\n       \\<Longrightarrow> (if gds_is_empty_stack gds s\n                          then SPEC\n                                (\\<lambda>v0.\n                                    v0 \\<in> V0 \\<and>\n                                    \\<not> gds_is_discovered gds v0\n      s) \\<bind>\n                               (\\<lambda>v0.\n                                   ASSERT (pre_new_root v0 s) \\<bind>\n                                   (\\<lambda>_. gds_new_root gds v0 s))\n                          else ASSERT (pre_get_pending s) \\<bind>\n                               (\\<lambda>_.\n                                   gds_get_pending gds s \\<bind>\n                                   (\\<lambda>(u, Vs, sa).\n case Vs of\n None \\<Rightarrow>\n   ASSERT (pre_finish u s sa) \\<bind> (\\<lambda>_. gds_finish gds u sa)\n | Some v \\<Rightarrow>\n     if gds_is_discovered gds v sa\n     then if gds_is_finished gds v sa\n          then ASSERT (pre_cross_edge u v s sa) \\<bind>\n               (\\<lambda>_. gds_cross_edge gds u v sa)\n          else ASSERT (pre_back_edge u v s sa) \\<bind>\n               (\\<lambda>_. gds_back_edge gds u v sa)\n     else ASSERT (pre_discover u v s sa) \\<bind>\n          (\\<lambda>_. gds_discover gds u v sa))))\n                         \\<le> \\<Down> Id\n                                (if gds_is_empty_stack gds s\n                                 then SPEC\n (\\<lambda>v0. v0 \\<in> V0 \\<and> \\<not> gds_is_discovered gds v0 s) \\<bind>\n(\\<lambda>v0. gds_new_root gds v0 s)\n                                 else gds_get_pending gds s \\<bind>\n(\\<lambda>(u, Vs, s).\n    case Vs of None \\<Rightarrow> gds_finish gds u s\n    | Some v \\<Rightarrow>\n        if gds_is_discovered gds v s\n        then if gds_is_finished gds v s then gds_cross_edge gds u v s\n             else gds_back_edge gds u v s\n        else gds_discover gds u v s))", "by (refine_rcg bind_refine', refine_dref_type,\n              auto simp: pre_defs gen_cond_def) []"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma gen_dfs_le_gen_dfsT: \"gen_dfs \\<le> gen_dfsT\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gen_dfs \\<le> gen_dfsT", "unfolding gen_dfs_def gen_dfsT_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. gds_init gds \\<bind> WHILE gen_cond gen_step\n    \\<le> gds_init gds \\<bind> WHILE\\<^sub>T gen_cond gen_step", "apply (rule bind_mono)"], ["proof (prove)\ngoal (2 subgoals):\n 1. gds_init gds \\<le> gds_init gds\n 2. \\<And>x.\n       RETURN x \\<le> gds_init gds \\<Longrightarrow>\n       WHILE gen_cond gen_step x \\<le> WHILE\\<^sub>T gen_cond gen_step x", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       RETURN x \\<le> gds_init gds \\<Longrightarrow>\n       WHILE gen_cond gen_step x \\<le> WHILE\\<^sub>T gen_cond gen_step x", "unfolding WHILET_def WHILE_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       RETURN x \\<le> gds_init gds \\<Longrightarrow>\n       WHILE\\<^bsup>\\<lambda>_. True\\<^esup> gen_cond gen_step x\n       \\<le> WHILE\\<^sub>T\\<^bsup>\\<lambda>_. True\\<^esup> gen_cond gen_step\n              x", "apply (rule WHILEI_le_WHILEIT)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "locale gen_dfs = gen_dfs_defs gds V0 \n  for gds :: \"('v,'s) gen_dfs_struct\"\n  and V0 :: \"'v set\""], ["", "(* Formalize the structure of a parameterized DFS *)\n\n(* Define the operations on the basic state *)"], ["", "record ('v,'s,'es) gen_basic_dfs_struct = \n  gbs_init :: \"'es \\<Rightarrow> 's nres\"\n  gbs_is_empty_stack :: \"'s \\<Rightarrow> bool\"\n  gbs_new_root :: \"'v \\<Rightarrow> 's \\<Rightarrow> 's nres\"\n  gbs_get_pending :: \"'s \\<Rightarrow> ('v \\<times> 'v option \\<times> 's) nres\"\n  gbs_finish :: \"'v \\<Rightarrow> 's \\<Rightarrow> 's nres\"\n  gbs_is_discovered :: \"'v \\<Rightarrow> 's \\<Rightarrow> bool\"\n  gbs_is_finished :: \"'v \\<Rightarrow> 's \\<Rightarrow> bool\"\n  gbs_back_edge :: \"'v \\<Rightarrow> 'v \\<Rightarrow> 's \\<Rightarrow> 's nres\"\n  gbs_cross_edge :: \"'v \\<Rightarrow> 'v \\<Rightarrow> 's \\<Rightarrow> 's nres\"\n  gbs_discover :: \"'v \\<Rightarrow> 'v \\<Rightarrow> 's \\<Rightarrow> 's nres\""], ["", "locale gen_param_dfs_defs =\n  fixes gbs :: \"('v,'s,'es) gen_basic_dfs_struct\"\n  fixes param :: \"('v,'s,'es) gen_parameterization\"\n  fixes upd_ext :: \"('es\\<Rightarrow>'es) \\<Rightarrow> 's \\<Rightarrow> 's\"\n  fixes V0 :: \"'v set\"\nbegin"], ["", "definition \"do_action bf ef s \\<equiv> do {\n    s \\<leftarrow> bf s;\n    e \\<leftarrow> ef s;\n    RETURN (upd_ext (\\<lambda>_. e) s)\n  }\""], ["", "definition \"do_init \\<equiv> do {\n    e \\<leftarrow> on_init param;\n    gbs_init gbs e\n  }\""], ["", "definition \"do_new_root v0 \n    \\<equiv> do_action (gbs_new_root gbs v0) (on_new_root param v0)\""], ["", "definition \"do_finish u \n    \\<equiv> do_action (gbs_finish gbs u) (on_finish param u)\""], ["", "definition \"do_back_edge u v\n    \\<equiv> do_action (gbs_back_edge gbs u v) (on_back_edge param u v)\""], ["", "definition \"do_cross_edge u v\n    \\<equiv> do_action (gbs_cross_edge gbs u v) (on_cross_edge param u v)\""], ["", "definition \"do_discover u v\n    \\<equiv> do_action (gbs_discover gbs u v) (on_discover param u v)\""], ["", "lemmas do_action_defs[DFS_code_unfold] = \n    do_action_def do_init_def do_new_root_def\n    do_finish_def do_back_edge_def do_cross_edge_def do_discover_def"], ["", "definition \"gds \\<equiv> \\<lparr>\n    gds_init = do_init,\n    gds_is_break = is_break param,\n    gds_is_empty_stack = gbs_is_empty_stack gbs,\n    gds_new_root = do_new_root,\n    gds_get_pending = gbs_get_pending gbs,\n    gds_finish = do_finish,\n    gds_is_discovered = gbs_is_discovered gbs,\n    gds_is_finished = gbs_is_finished gbs,\n    gds_back_edge = do_back_edge,\n    gds_cross_edge = do_cross_edge,\n    gds_discover = do_discover\n  \\<rparr>\""], ["", "lemmas gds_simps[simp,DFS_code_unfold] \n    = gen_dfs_struct.simps[mk_record_simp, OF gds_def]"], ["", "sublocale gen_dfs_defs gds V0"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "end"], ["", "locale gen_param_dfs = gen_param_dfs_defs gbs param upd_ext V0\n  for gbs :: \"('v,'s,'es) gen_basic_dfs_struct\"\n  and param :: \"('v,'s,'es) gen_parameterization\"\n  and upd_ext :: \"('es\\<Rightarrow>'es) \\<Rightarrow> 's \\<Rightarrow> 's\"\n  and V0 :: \"'v set\""], ["", "context param_DFS_defs begin"], ["", "definition \"gbs \\<equiv> \\<lparr>\n    gbs_init = RETURN o empty_state,\n    gbs_is_empty_stack = is_empty_stack ,\n    gbs_new_root = RETURN oo new_root ,\n    gbs_get_pending = get_pending ,\n    gbs_finish = RETURN oo finish ,\n    gbs_is_discovered = is_discovered ,\n    gbs_is_finished = is_finished ,\n    gbs_back_edge = RETURN ooo back_edge ,\n    gbs_cross_edge = RETURN ooo cross_edge ,\n    gbs_discover = RETURN ooo discover\n  \\<rparr>\""], ["", "lemmas gbs_simps[simp] = gen_basic_dfs_struct.simps[mk_record_simp, OF gbs_def]"], ["", "sublocale gen_dfs: gen_param_dfs_defs gbs param state.more_update V0"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma gen_cond_simp[simp]: \"gen_dfs.gen_cond = cond\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gen_dfs.gen_cond = cond", "apply (intro ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. gen_dfs.gen_cond x = cond x", "unfolding cond_def gen_dfs.gen_cond_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       ((V0 \\<subseteq> gen_dfs.gen_discovered x \\<longrightarrow>\n         \\<not> gds_is_empty_stack gen_dfs.gds x) \\<and>\n        \\<not> gds_is_break gen_dfs.gds x) =\n       ((V0 \\<subseteq> {v. is_discovered v x} \\<longrightarrow>\n         \\<not> is_empty_stack x) \\<and>\n        \\<not> is_break param x)", "by simp"], ["", "lemma gen_step_simp[simp]: \"gen_dfs.gen_step = step\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gen_dfs.gen_step = step", "apply (intro ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. gen_dfs.gen_step x = step x", "unfolding gen_dfs.gen_step_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (if gds_is_empty_stack gen_dfs.gds x\n        then SPEC\n              (\\<lambda>v0.\n                  v0 \\<in> V0 \\<and>\n                  \\<not> gds_is_discovered gen_dfs.gds v0 x) \\<bind>\n             (\\<lambda>v0. gds_new_root gen_dfs.gds v0 x)\n        else gds_get_pending gen_dfs.gds x \\<bind>\n             (\\<lambda>(u, Vs, s).\n                 case Vs of None \\<Rightarrow> gds_finish gen_dfs.gds u s\n                 | Some v \\<Rightarrow>\n                     if gds_is_discovered gen_dfs.gds v s\n                     then if gds_is_finished gen_dfs.gds v s\n                          then gds_cross_edge gen_dfs.gds u v s\n                          else gds_back_edge gen_dfs.gds u v s\n                     else gds_discover gen_dfs.gds u v s)) =\n       step x", "apply (simp \n      cong: if_cong option.case_cong \n      add: gen_dfs.do_action_defs[abs_def])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (is_empty_stack x \\<longrightarrow>\n        SPEC\n         (\\<lambda>v0. v0 \\<in> V0 \\<and> \\<not> is_discovered v0 x) \\<bind>\n        (\\<lambda>v0.\n            on_new_root param v0 (new_root v0 x) \\<bind>\n            (\\<lambda>e.\n                RETURN (new_root v0 x\\<lparr>state.more := e\\<rparr>))) =\n        step x) \\<and>\n       (\\<not> is_empty_stack x \\<longrightarrow>\n        get_pending x \\<bind>\n        (\\<lambda>(u, Vs, s).\n            case Vs of\n            None \\<Rightarrow>\n              on_finish param u (finish u s) \\<bind>\n              (\\<lambda>e.\n                  RETURN (finish u s\\<lparr>state.more := e\\<rparr>))\n            | Some v \\<Rightarrow>\n                if is_discovered v s\n                then if is_finished v s\n                     then on_cross_edge param u v (cross_edge u v s) \\<bind>\n                          (\\<lambda>e.\n                              RETURN\n                               (cross_edge u v s\n                                \\<lparr>state.more := e\\<rparr>))\n                     else on_back_edge param u v (back_edge u v s) \\<bind>\n                          (\\<lambda>e.\n                              RETURN\n                               (back_edge u v s\n                                \\<lparr>state.more := e\\<rparr>))\n                else on_discover param u v (discover u v s) \\<bind>\n                     (\\<lambda>e.\n                         RETURN\n                          (discover u v s\n                           \\<lparr>state.more := e\\<rparr>))) =\n        step x)", "unfolding step_def[abs_def] do_defs get_new_root_def pred_defs"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (stack x = [] \\<longrightarrow>\n        SPEC\n         (\\<lambda>v0.\n             v0 \\<in> V0 \\<and> v0 \\<notin> dom (discovered x)) \\<bind>\n        (\\<lambda>v0.\n            on_new_root param v0 (new_root v0 x) \\<bind>\n            (\\<lambda>e.\n                RETURN (new_root v0 x\\<lparr>state.more := e\\<rparr>))) =\n        (if stack x = []\n         then SPEC\n               (\\<lambda>v.\n                   v \\<in> V0 \\<and> v \\<notin> dom (discovered x)) \\<bind>\n              (\\<lambda>v0.\n                  let s = new_root v0 x\n                  in on_new_root param v0 s \\<bind>\n                     (\\<lambda>e.\n                         RETURN (s\\<lparr>state.more := e\\<rparr>)))\n         else get_pending x \\<bind>\n              (\\<lambda>(u, Vs, s).\n                  case Vs of\n                  None \\<Rightarrow>\n                    let s = finish u s\n                    in on_finish param u s \\<bind>\n                       (\\<lambda>e.\n                           RETURN (s\\<lparr>state.more := e\\<rparr>))\n                  | Some v \\<Rightarrow>\n                      if v \\<in> dom (discovered s)\n                      then if v \\<in> dom (finished s)\n                           then let s = cross_edge u v s\n                                in on_cross_edge param u v s \\<bind>\n                                   (\\<lambda>e.\n RETURN (s\\<lparr>state.more := e\\<rparr>))\n                           else let s = back_edge u v s\n                                in on_back_edge param u v s \\<bind>\n                                   (\\<lambda>e.\n RETURN (s\\<lparr>state.more := e\\<rparr>))\n                      else let s = discover u v s\n                           in on_discover param u v s \\<bind>\n                              (\\<lambda>e.\n                                  RETURN\n                                   (s\\<lparr>state.more :=\n         e\\<rparr>))))) \\<and>\n       (stack x \\<noteq> [] \\<longrightarrow>\n        get_pending x \\<bind>\n        (\\<lambda>(u, Vs, s).\n            case Vs of\n            None \\<Rightarrow>\n              on_finish param u (finish u s) \\<bind>\n              (\\<lambda>e.\n                  RETURN (finish u s\\<lparr>state.more := e\\<rparr>))\n            | Some v \\<Rightarrow>\n                if v \\<in> dom (discovered s)\n                then if v \\<in> dom (finished s)\n                     then on_cross_edge param u v (cross_edge u v s) \\<bind>\n                          (\\<lambda>e.\n                              RETURN\n                               (cross_edge u v s\n                                \\<lparr>state.more := e\\<rparr>))\n                     else on_back_edge param u v (back_edge u v s) \\<bind>\n                          (\\<lambda>e.\n                              RETURN\n                               (back_edge u v s\n                                \\<lparr>state.more := e\\<rparr>))\n                else on_discover param u v (discover u v s) \\<bind>\n                     (\\<lambda>e.\n                         RETURN\n                          (discover u v s\n                           \\<lparr>state.more := e\\<rparr>))) =\n        (if stack x = []\n         then SPEC\n               (\\<lambda>v.\n                   v \\<in> V0 \\<and> v \\<notin> dom (discovered x)) \\<bind>\n              (\\<lambda>v0.\n                  let s = new_root v0 x\n                  in on_new_root param v0 s \\<bind>\n                     (\\<lambda>e.\n                         RETURN (s\\<lparr>state.more := e\\<rparr>)))\n         else get_pending x \\<bind>\n              (\\<lambda>(u, Vs, s).\n                  case Vs of\n                  None \\<Rightarrow>\n                    let s = finish u s\n                    in on_finish param u s \\<bind>\n                       (\\<lambda>e.\n                           RETURN (s\\<lparr>state.more := e\\<rparr>))\n                  | Some v \\<Rightarrow>\n                      if v \\<in> dom (discovered s)\n                      then if v \\<in> dom (finished s)\n                           then let s = cross_edge u v s\n                                in on_cross_edge param u v s \\<bind>\n                                   (\\<lambda>e.\n RETURN (s\\<lparr>state.more := e\\<rparr>))\n                           else let s = back_edge u v s\n                                in on_back_edge param u v s \\<bind>\n                                   (\\<lambda>e.\n RETURN (s\\<lparr>state.more := e\\<rparr>))\n                      else let s = discover u v s\n                           in on_discover param u v s \\<bind>\n                              (\\<lambda>e.\n                                  RETURN\n                                   (s\\<lparr>state.more := e\\<rparr>)))))", "apply (simp \n      cong: if_cong option.case_cong)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma gen_init_simp[simp]: \"gen_dfs.do_init = init\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gen_dfs.do_init = init", "unfolding init_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. gen_dfs.do_init =\n    on_init param \\<bind> (\\<lambda>e. RETURN (empty_state e))", "apply (simp add: gen_dfs.do_action_defs[abs_def])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma gen_dfs_simp[simp]: \"gen_dfs.gen_dfs = it_dfs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gen_dfs.gen_dfs = it_dfs", "unfolding it_dfs_def gen_dfs.gen_dfs_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. gds_init gen_dfs.gds \\<bind> WHILE gen_dfs.gen_cond gen_dfs.gen_step =\n    init \\<bind> WHILE cond step", "apply (simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma gen_dfsT_simp[simp]: \"gen_dfs.gen_dfsT = it_dfsT\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gen_dfs.gen_dfsT = it_dfsT", "unfolding it_dfsT_def gen_dfs.gen_dfsT_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. gds_init gen_dfs.gds \\<bind>\n    WHILE\\<^sub>T gen_dfs.gen_cond gen_dfs.gen_step =\n    init \\<bind> WHILE\\<^sub>T cond step", "apply (simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "context param_DFS begin"], ["", "sublocale gen_dfs: gen_param_dfs gbs param state.more_update V0"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "end"], ["", "subsection \\<open>Refinement Between DFS Implementations\\<close>"], ["", "(* This locale expresses refinement between two general DFS implementations *)"], ["", "locale gen_dfs_refine_defs =\n  c: gen_dfs_defs gdsi V0i + a: gen_dfs_defs gds V0 \n  for gdsi V0i gds V0"], ["", "locale gen_dfs_refine =\n  c: gen_dfs gdsi V0i + a: gen_dfs gds V0 + gen_dfs_refine_defs gdsi V0i gds V0\n  for gdsi V0i gds V0 +\n  fixes V S\n  assumes BIJV[relator_props]: \"bijective V\"\n  assumes V0_param[param]: \"(V0i,V0)\\<in>\\<langle>V\\<rangle>set_rel\"\n  assumes is_discovered_param[param]: (* TODO: Add preconditions for predicate refinement assumption *)\n    \"(gds_is_discovered gdsi,gds_is_discovered gds)\\<in>V\\<rightarrow>S\\<rightarrow>bool_rel\"\n  assumes is_finished_param[param]: \n    \"(gds_is_finished gdsi,gds_is_finished gds)\\<in>V\\<rightarrow>S\\<rightarrow>bool_rel\"\n  assumes is_empty_stack_param[param]:\n    \"(gds_is_empty_stack gdsi,gds_is_empty_stack gds)\\<in>S\\<rightarrow>bool_rel\"\n  assumes is_break_param[param]:\n    \"(gds_is_break gdsi,gds_is_break gds)\\<in>S\\<rightarrow>bool_rel\"\n  assumes init_refine[refine]: \n    \"gds_init gdsi \\<le> \\<Down> S (gds_init gds)\"\n  assumes new_root_refine[refine]: \n    \"\\<lbrakk>a.pre_new_root v0 s; (v0i,v0)\\<in>V; (si,s)\\<in>S\\<rbrakk> \n      \\<Longrightarrow> gds_new_root gdsi v0i si \\<le> \\<Down> S (gds_new_root gds v0 s)\"\n  assumes get_pending_refine[refine]:\n    \"\\<lbrakk>a.pre_get_pending s; (si,s)\\<in>S\\<rbrakk>\n      \\<Longrightarrow> gds_get_pending gdsi si \\<le> \\<Down>(V \\<times>\\<^sub>r \\<langle>V\\<rangle>option_rel \\<times>\\<^sub>r S) (gds_get_pending gds s)\"\n  assumes finish_refine[refine]: \n    \"\\<lbrakk>a.pre_finish v s0 s; (vi,v)\\<in>V; (si,s)\\<in>S\\<rbrakk> \n      \\<Longrightarrow> gds_finish gdsi vi si \\<le> \\<Down> S (gds_finish gds v s)\"\n  assumes cross_edge_refine[refine]: \n    \"\\<lbrakk>a.pre_cross_edge u v s0 s; (ui,u)\\<in>V; (vi,v)\\<in>V; (si,s)\\<in>S\\<rbrakk> \n      \\<Longrightarrow> gds_cross_edge gdsi ui vi si \\<le> \\<Down> S (gds_cross_edge gds u v s)\"\n  assumes back_edge_refine[refine]: \n    \"\\<lbrakk>a.pre_back_edge u v s0 s; (ui,u)\\<in>V; (vi,v)\\<in>V; (si,s)\\<in>S\\<rbrakk> \n      \\<Longrightarrow> gds_back_edge gdsi ui vi si \\<le> \\<Down> S (gds_back_edge gds u v s)\"\n  assumes discover_refine[refine]: \n    \"\\<lbrakk>a.pre_discover u v s0 s; (ui,u)\\<in>V; (vi,v)\\<in>V; (si,s)\\<in>S\\<rbrakk> \n      \\<Longrightarrow> gds_discover gdsi ui vi si \\<le> \\<Down> S (gds_discover gds u v s)\"\n\nbegin"], ["", "term \"gds_is_discovered gdsi\""], ["", "(*sublocale bij_rel_param!: bij_rel_param V using BIJV by unfold_locales*)"], ["", "lemma select_v0_refine[refine]:\n    assumes s_param: \"(si,s)\\<in>S\"\n    shows \"SPEC (\\<lambda>v0. v0 \\<in> V0i \\<and> \\<not> gds_is_discovered gdsi v0 si)\n           \\<le> \\<Down> V (SPEC (\\<lambda>v0. v0 \\<in> V0 \\<and> \\<not> gds_is_discovered gds v0 s))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SPEC\n     (\\<lambda>v0. v0 \\<in> V0i \\<and> \\<not> gds_is_discovered gdsi v0 si)\n    \\<le> \\<Down> V\n           (SPEC\n             (\\<lambda>v0.\n                 v0 \\<in> V0 \\<and> \\<not> gds_is_discovered gds v0 s))", "apply (rule RES_refine)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>sa.\n       sa \\<in> {v0 \\<in> V0i.\n                 \\<not> gds_is_discovered gdsi v0 si} \\<Longrightarrow>\n       \\<exists>s'\\<in>{v0 \\<in> V0. \\<not> gds_is_discovered gds v0 s}.\n          (sa, s') \\<in> V", "apply (simp add: Bex_def[symmetric], elim conjE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>sa.\n       \\<lbrakk>sa \\<in> V0i; \\<not> gds_is_discovered gdsi sa si\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'\\<in>V0.\n                            \\<not> gds_is_discovered gds s' s \\<and>\n                            (sa, s') \\<in> V", "apply (drule set_relD1[OF V0_param], elim bexE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>sa x'.\n       \\<lbrakk>\\<not> gds_is_discovered gdsi sa si; x' \\<in> V0;\n        (sa, x') \\<in> V\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'\\<in>V0.\n                            \\<not> gds_is_discovered gds s' s \\<and>\n                            (sa, s') \\<in> V", "apply (erule bexI[rotated])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>sa x'.\n       \\<lbrakk>\\<not> gds_is_discovered gdsi sa si;\n        (sa, x') \\<in> V\\<rbrakk>\n       \\<Longrightarrow> \\<not> gds_is_discovered gds x' s \\<and>\n                         (sa, x') \\<in> V", "using is_discovered_param[param_fo, OF _ s_param]"], ["proof (prove)\nusing this:\n  (?x1, ?x'1) \\<in> V \\<Longrightarrow>\n  (gds_is_discovered gdsi ?x1 si, gds_is_discovered gds ?x'1 s)\n  \\<in> bool_rel\n\ngoal (1 subgoal):\n 1. \\<And>sa x'.\n       \\<lbrakk>\\<not> gds_is_discovered gdsi sa si;\n        (sa, x') \\<in> V\\<rbrakk>\n       \\<Longrightarrow> \\<not> gds_is_discovered gds x' s \\<and>\n                         (sa, x') \\<in> V", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma gen_rwof_refine: \n    assumes NF: \"nofail (a.gen_dfs)\"\n    assumes RW: \"c.gen_rwof s\"\n    obtains s' where \"(s,s')\\<in>S\" and \"a.gen_rwof s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>s'.\n        \\<lbrakk>(s, s') \\<in> S; a.gen_rwof s'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>s'.\n        \\<lbrakk>(s, s') \\<in> S; a.gen_rwof s'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from NF"], ["proof (chain)\npicking this:\n  nofail a.gen_dfs", "have NFa: \"nofail (a.gen_dfs_assert)\""], ["proof (prove)\nusing this:\n  nofail a.gen_dfs\n\ngoal (1 subgoal):\n 1. nofail a.gen_dfs_assert", "unfolding a.gen_dfs_eq_assert"], ["proof (prove)\nusing this:\n  nofail a.gen_dfs_assert\n\ngoal (1 subgoal):\n 1. nofail a.gen_dfs_assert", "."], ["proof (state)\nthis:\n  nofail a.gen_dfs_assert\n\ngoal (1 subgoal):\n 1. (\\<And>s'.\n        \\<lbrakk>(s, s') \\<in> S; a.gen_rwof s'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"\\<exists>s'. (s, s') \\<in> S \\<and> a.gen_rwof_assert s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>s'. (s, s') \\<in> S \\<and> a.gen_rwof_assert s'", "apply (rule rwof_refine[OF RW NFa[unfolded a.gen_dfs_assert_def]])"], ["proof (prove)\ngoal (3 subgoals):\n 1. gds_init gdsi \\<le>\\<^sub>n \\<Down> S (gds_init gds)\n 2. \\<And>s s'.\n       \\<lbrakk>(s, s') \\<in> S; c.gen_rwof s; a.gen_rwof_assert s'\\<rbrakk>\n       \\<Longrightarrow> c.gen_cond s = a.gen_cond s'\n 3. \\<And>s s'.\n       \\<lbrakk>(s, s') \\<in> S; c.gen_rwof s; a.gen_rwof_assert s';\n        c.gen_cond s; a.gen_cond s'\\<rbrakk>\n       \\<Longrightarrow> c.gen_step s \\<le>\\<^sub>n\n                         \\<Down> S (a.gen_step_assert s')", "apply (rule leofI, rule init_refine)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s s'.\n       \\<lbrakk>(s, s') \\<in> S; c.gen_rwof s; a.gen_rwof_assert s'\\<rbrakk>\n       \\<Longrightarrow> c.gen_cond s = a.gen_cond s'\n 2. \\<And>s s'.\n       \\<lbrakk>(s, s') \\<in> S; c.gen_rwof s; a.gen_rwof_assert s';\n        c.gen_cond s; a.gen_cond s'\\<rbrakk>\n       \\<Longrightarrow> c.gen_step s \\<le>\\<^sub>n\n                         \\<Down> S (a.gen_step_assert s')", "(* TODO: Proof duplication between this and gen_dfs_refine.\n        Hope for better rwof/mgi-theory!\n      *)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s s'.\n       \\<lbrakk>(s, s') \\<in> S; c.gen_rwof s; a.gen_rwof_assert s'\\<rbrakk>\n       \\<Longrightarrow> c.gen_cond s = a.gen_cond s'\n 2. \\<And>s s'.\n       \\<lbrakk>(s, s') \\<in> S; c.gen_rwof s; a.gen_rwof_assert s';\n        c.gen_cond s; a.gen_cond s'\\<rbrakk>\n       \\<Longrightarrow> c.gen_step s \\<le>\\<^sub>n\n                         \\<Down> S (a.gen_step_assert s')", "unfolding c.gen_cond_def a.gen_cond_def"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s s'.\n       \\<lbrakk>(s, s') \\<in> S;\n        rwof (gds_init gdsi)\n         (\\<lambda>s.\n             (V0i \\<subseteq> c.gen_discovered s \\<longrightarrow>\n              \\<not> gds_is_empty_stack gdsi s) \\<and>\n             \\<not> gds_is_break gdsi s)\n         c.gen_step s;\n        rwof (gds_init gds)\n         (\\<lambda>s.\n             (V0 \\<subseteq> a.gen_discovered s \\<longrightarrow>\n              \\<not> gds_is_empty_stack gds s) \\<and>\n             \\<not> gds_is_break gds s)\n         a.gen_step_assert s'\\<rbrakk>\n       \\<Longrightarrow> ((V0i\n                           \\<subseteq> c.gen_discovered s \\<longrightarrow>\n                           \\<not> gds_is_empty_stack gdsi s) \\<and>\n                          \\<not> gds_is_break gdsi s) =\n                         ((V0 \\<subseteq> a.gen_discovered\n     s' \\<longrightarrow>\n                           \\<not> gds_is_empty_stack gds s') \\<and>\n                          \\<not> gds_is_break gds s')\n 2. \\<And>s s'.\n       \\<lbrakk>(s, s') \\<in> S;\n        rwof (gds_init gdsi)\n         (\\<lambda>s.\n             (V0i \\<subseteq> c.gen_discovered s \\<longrightarrow>\n              \\<not> gds_is_empty_stack gdsi s) \\<and>\n             \\<not> gds_is_break gdsi s)\n         c.gen_step s;\n        rwof (gds_init gds)\n         (\\<lambda>s.\n             (V0 \\<subseteq> a.gen_discovered s \\<longrightarrow>\n              \\<not> gds_is_empty_stack gds s) \\<and>\n             \\<not> gds_is_break gds s)\n         a.gen_step_assert s';\n        (V0i \\<subseteq> c.gen_discovered s \\<longrightarrow>\n         \\<not> gds_is_empty_stack gdsi s) \\<and>\n        \\<not> gds_is_break gdsi s;\n        (V0 \\<subseteq> a.gen_discovered s' \\<longrightarrow>\n         \\<not> gds_is_empty_stack gds s') \\<and>\n        \\<not> gds_is_break gds s'\\<rbrakk>\n       \\<Longrightarrow> c.gen_step s \\<le>\\<^sub>n\n                         \\<Down> S (a.gen_step_assert s')", "apply (rule IdD)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s s'.\n       \\<lbrakk>(s, s') \\<in> S;\n        rwof (gds_init gdsi)\n         (\\<lambda>s.\n             (V0i \\<subseteq> c.gen_discovered s \\<longrightarrow>\n              \\<not> gds_is_empty_stack gdsi s) \\<and>\n             \\<not> gds_is_break gdsi s)\n         c.gen_step s;\n        rwof (gds_init gds)\n         (\\<lambda>s.\n             (V0 \\<subseteq> a.gen_discovered s \\<longrightarrow>\n              \\<not> gds_is_empty_stack gds s) \\<and>\n             \\<not> gds_is_break gds s)\n         a.gen_step_assert s'\\<rbrakk>\n       \\<Longrightarrow> ((V0i\n                           \\<subseteq> c.gen_discovered s \\<longrightarrow>\n                           \\<not> gds_is_empty_stack gdsi s) \\<and>\n                          \\<not> gds_is_break gdsi s,\n                          (V0 \\<subseteq> a.gen_discovered\n     s' \\<longrightarrow>\n                           \\<not> gds_is_empty_stack gds s') \\<and>\n                          \\<not> gds_is_break gds s')\n                         \\<in> bool_rel\n 2. \\<And>s s'.\n       \\<lbrakk>(s, s') \\<in> S;\n        rwof (gds_init gdsi)\n         (\\<lambda>s.\n             (V0i \\<subseteq> c.gen_discovered s \\<longrightarrow>\n              \\<not> gds_is_empty_stack gdsi s) \\<and>\n             \\<not> gds_is_break gdsi s)\n         c.gen_step s;\n        rwof (gds_init gds)\n         (\\<lambda>s.\n             (V0 \\<subseteq> a.gen_discovered s \\<longrightarrow>\n              \\<not> gds_is_empty_stack gds s) \\<and>\n             \\<not> gds_is_break gds s)\n         a.gen_step_assert s';\n        (V0i \\<subseteq> c.gen_discovered s \\<longrightarrow>\n         \\<not> gds_is_empty_stack gdsi s) \\<and>\n        \\<not> gds_is_break gdsi s;\n        (V0 \\<subseteq> a.gen_discovered s' \\<longrightarrow>\n         \\<not> gds_is_empty_stack gds s') \\<and>\n        \\<not> gds_is_break gds s'\\<rbrakk>\n       \\<Longrightarrow> c.gen_step s \\<le>\\<^sub>n\n                         \\<Down> S (a.gen_step_assert s')", "apply (simp only: subset_Collect_conv)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s s'.\n       \\<lbrakk>(s, s') \\<in> S;\n        rwof (gds_init gdsi)\n         (\\<lambda>s.\n             ((\\<forall>x\\<in>V0i.\n                  gds_is_discovered gdsi x s) \\<longrightarrow>\n              \\<not> gds_is_empty_stack gdsi s) \\<and>\n             \\<not> gds_is_break gdsi s)\n         c.gen_step s;\n        rwof (gds_init gds)\n         (\\<lambda>s.\n             ((\\<forall>x\\<in>V0.\n                  gds_is_discovered gds x s) \\<longrightarrow>\n              \\<not> gds_is_empty_stack gds s) \\<and>\n             \\<not> gds_is_break gds s)\n         a.gen_step_assert s'\\<rbrakk>\n       \\<Longrightarrow> (((\\<forall>x\\<in>V0i.\n                               gds_is_discovered gdsi x s) \\<longrightarrow>\n                           \\<not> gds_is_empty_stack gdsi s) \\<and>\n                          \\<not> gds_is_break gdsi s,\n                          ((\\<forall>x\\<in>V0.\n                               gds_is_discovered gds x s') \\<longrightarrow>\n                           \\<not> gds_is_empty_stack gds s') \\<and>\n                          \\<not> gds_is_break gds s')\n                         \\<in> bool_rel\n 2. \\<And>s s'.\n       \\<lbrakk>(s, s') \\<in> S;\n        rwof (gds_init gdsi)\n         (\\<lambda>s.\n             (V0i \\<subseteq> c.gen_discovered s \\<longrightarrow>\n              \\<not> gds_is_empty_stack gdsi s) \\<and>\n             \\<not> gds_is_break gdsi s)\n         c.gen_step s;\n        rwof (gds_init gds)\n         (\\<lambda>s.\n             (V0 \\<subseteq> a.gen_discovered s \\<longrightarrow>\n              \\<not> gds_is_empty_stack gds s) \\<and>\n             \\<not> gds_is_break gds s)\n         a.gen_step_assert s';\n        (V0i \\<subseteq> c.gen_discovered s \\<longrightarrow>\n         \\<not> gds_is_empty_stack gdsi s) \\<and>\n        \\<not> gds_is_break gdsi s;\n        (V0 \\<subseteq> a.gen_discovered s' \\<longrightarrow>\n         \\<not> gds_is_empty_stack gds s') \\<and>\n        \\<not> gds_is_break gds s'\\<rbrakk>\n       \\<Longrightarrow> c.gen_step s \\<le>\\<^sub>n\n                         \\<Down> S (a.gen_step_assert s')", "apply parametricity"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s s'.\n       \\<lbrakk>(s, s') \\<in> S;\n        rwof (gds_init gdsi)\n         (\\<lambda>s.\n             (V0i \\<subseteq> c.gen_discovered s \\<longrightarrow>\n              \\<not> gds_is_empty_stack gdsi s) \\<and>\n             \\<not> gds_is_break gdsi s)\n         c.gen_step s;\n        rwof (gds_init gds)\n         (\\<lambda>s.\n             (V0 \\<subseteq> a.gen_discovered s \\<longrightarrow>\n              \\<not> gds_is_empty_stack gds s) \\<and>\n             \\<not> gds_is_break gds s)\n         a.gen_step_assert s';\n        (V0i \\<subseteq> c.gen_discovered s \\<longrightarrow>\n         \\<not> gds_is_empty_stack gdsi s) \\<and>\n        \\<not> gds_is_break gdsi s;\n        (V0 \\<subseteq> a.gen_discovered s' \\<longrightarrow>\n         \\<not> gds_is_empty_stack gds s') \\<and>\n        \\<not> gds_is_break gds s'\\<rbrakk>\n       \\<Longrightarrow> c.gen_step s \\<le>\\<^sub>n\n                         \\<Down> S (a.gen_step_assert s')", "unfolding c.gen_step_def a.gen_step_assert_def GHOST_elim_Let"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s s'.\n       \\<lbrakk>(s, s') \\<in> S;\n        rwof (gds_init gdsi)\n         (\\<lambda>s.\n             (V0i \\<subseteq> c.gen_discovered s \\<longrightarrow>\n              \\<not> gds_is_empty_stack gdsi s) \\<and>\n             \\<not> gds_is_break gdsi s)\n         (\\<lambda>s.\n             if gds_is_empty_stack gdsi s\n             then SPEC\n                   (\\<lambda>v0.\n                       v0 \\<in> V0i \\<and>\n                       \\<not> gds_is_discovered gdsi v0 s) \\<bind>\n                  (\\<lambda>v0. gds_new_root gdsi v0 s)\n             else gds_get_pending gdsi s \\<bind>\n                  (\\<lambda>(u, Vs, s).\n                      case Vs of None \\<Rightarrow> gds_finish gdsi u s\n                      | Some v \\<Rightarrow>\n                          if gds_is_discovered gdsi v s\n                          then if gds_is_finished gdsi v s\n                               then gds_cross_edge gdsi u v s\n                               else gds_back_edge gdsi u v s\n                          else gds_discover gdsi u v s))\n         s;\n        rwof (gds_init gds)\n         (\\<lambda>s.\n             (V0 \\<subseteq> a.gen_discovered s \\<longrightarrow>\n              \\<not> gds_is_empty_stack gds s) \\<and>\n             \\<not> gds_is_break gds s)\n         (\\<lambda>s.\n             if gds_is_empty_stack gds s\n             then SPEC\n                   (\\<lambda>v0.\n                       v0 \\<in> V0 \\<and>\n                       \\<not> gds_is_discovered gds v0 s) \\<bind>\n                  (\\<lambda>v0.\n                      ASSERT (a.pre_new_root v0 s) \\<bind>\n                      (\\<lambda>_. gds_new_root gds v0 s))\n             else ASSERT (a.pre_get_pending s) \\<bind>\n                  (\\<lambda>_.\n                      gds_get_pending gds s \\<bind>\n                      (\\<lambda>(u, Vs, sa).\n                          case Vs of\n                          None \\<Rightarrow>\n                            ASSERT (a.pre_finish u s sa) \\<bind>\n                            (\\<lambda>_. gds_finish gds u sa)\n                          | Some v \\<Rightarrow>\n                              if gds_is_discovered gds v sa\n                              then if gds_is_finished gds v sa\n                                   then ASSERT\n   (a.pre_cross_edge u v s sa) \\<bind>\n  (\\<lambda>_. gds_cross_edge gds u v sa)\n                                   else ASSERT\n   (a.pre_back_edge u v s sa) \\<bind>\n  (\\<lambda>_. gds_back_edge gds u v sa)\n                              else ASSERT (a.pre_discover u v s sa) \\<bind>\n                                   (\\<lambda>_. gds_discover gds u v sa))))\n         s';\n        (V0i \\<subseteq> c.gen_discovered s \\<longrightarrow>\n         \\<not> gds_is_empty_stack gdsi s) \\<and>\n        \\<not> gds_is_break gdsi s;\n        (V0 \\<subseteq> a.gen_discovered s' \\<longrightarrow>\n         \\<not> gds_is_empty_stack gds s') \\<and>\n        \\<not> gds_is_break gds s'\\<rbrakk>\n       \\<Longrightarrow> (if gds_is_empty_stack gdsi s\n                          then SPEC\n                                (\\<lambda>v0.\n                                    v0 \\<in> V0i \\<and>\n                                    \\<not> gds_is_discovered gdsi v0\n      s) \\<bind>\n                               (\\<lambda>v0. gds_new_root gdsi v0 s)\n                          else gds_get_pending gdsi s \\<bind>\n                               (\\<lambda>(u, Vs, s).\n                                   case Vs of\n                                   None \\<Rightarrow> gds_finish gdsi u s\n                                   | Some v \\<Rightarrow>\n if gds_is_discovered gdsi v s\n then if gds_is_finished gdsi v s then gds_cross_edge gdsi u v s\n      else gds_back_edge gdsi u v s\n else gds_discover gdsi u v s)) \\<le>\\<^sub>n\n                         \\<Down> S\n                          (if gds_is_empty_stack gds s'\n                           then SPEC\n                                 (\\<lambda>v0.\n                                     v0 \\<in> V0 \\<and>\n                                     \\<not> gds_is_discovered gds v0\n       s') \\<bind>\n                                (\\<lambda>v0.\n                                    ASSERT (a.pre_new_root v0 s') \\<bind>\n                                    (\\<lambda>_. gds_new_root gds v0 s'))\n                           else ASSERT (a.pre_get_pending s') \\<bind>\n                                (\\<lambda>_.\n                                    gds_get_pending gds s' \\<bind>\n                                    (\\<lambda>(u, Vs, s).\n  case Vs of\n  None \\<Rightarrow>\n    ASSERT (a.pre_finish u s' s) \\<bind> (\\<lambda>_. gds_finish gds u s)\n  | Some v \\<Rightarrow>\n      if gds_is_discovered gds v s\n      then if gds_is_finished gds v s\n           then ASSERT (a.pre_cross_edge u v s' s) \\<bind>\n                (\\<lambda>_. gds_cross_edge gds u v s)\n           else ASSERT (a.pre_back_edge u v s' s) \\<bind>\n                (\\<lambda>_. gds_back_edge gds u v s)\n      else ASSERT (a.pre_discover u v s' s) \\<bind>\n           (\\<lambda>_. gds_discover gds u v s))))", "apply (rule leofI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s s'.\n       \\<lbrakk>(s, s') \\<in> S;\n        rwof (gds_init gdsi)\n         (\\<lambda>s.\n             (V0i \\<subseteq> c.gen_discovered s \\<longrightarrow>\n              \\<not> gds_is_empty_stack gdsi s) \\<and>\n             \\<not> gds_is_break gdsi s)\n         (\\<lambda>s.\n             if gds_is_empty_stack gdsi s\n             then SPEC\n                   (\\<lambda>v0.\n                       v0 \\<in> V0i \\<and>\n                       \\<not> gds_is_discovered gdsi v0 s) \\<bind>\n                  (\\<lambda>v0. gds_new_root gdsi v0 s)\n             else gds_get_pending gdsi s \\<bind>\n                  (\\<lambda>(u, Vs, s).\n                      case Vs of None \\<Rightarrow> gds_finish gdsi u s\n                      | Some v \\<Rightarrow>\n                          if gds_is_discovered gdsi v s\n                          then if gds_is_finished gdsi v s\n                               then gds_cross_edge gdsi u v s\n                               else gds_back_edge gdsi u v s\n                          else gds_discover gdsi u v s))\n         s;\n        rwof (gds_init gds)\n         (\\<lambda>s.\n             (V0 \\<subseteq> a.gen_discovered s \\<longrightarrow>\n              \\<not> gds_is_empty_stack gds s) \\<and>\n             \\<not> gds_is_break gds s)\n         (\\<lambda>s.\n             if gds_is_empty_stack gds s\n             then SPEC\n                   (\\<lambda>v0.\n                       v0 \\<in> V0 \\<and>\n                       \\<not> gds_is_discovered gds v0 s) \\<bind>\n                  (\\<lambda>v0.\n                      ASSERT (a.pre_new_root v0 s) \\<bind>\n                      (\\<lambda>_. gds_new_root gds v0 s))\n             else ASSERT (a.pre_get_pending s) \\<bind>\n                  (\\<lambda>_.\n                      gds_get_pending gds s \\<bind>\n                      (\\<lambda>(u, Vs, sa).\n                          case Vs of\n                          None \\<Rightarrow>\n                            ASSERT (a.pre_finish u s sa) \\<bind>\n                            (\\<lambda>_. gds_finish gds u sa)\n                          | Some v \\<Rightarrow>\n                              if gds_is_discovered gds v sa\n                              then if gds_is_finished gds v sa\n                                   then ASSERT\n   (a.pre_cross_edge u v s sa) \\<bind>\n  (\\<lambda>_. gds_cross_edge gds u v sa)\n                                   else ASSERT\n   (a.pre_back_edge u v s sa) \\<bind>\n  (\\<lambda>_. gds_back_edge gds u v sa)\n                              else ASSERT (a.pre_discover u v s sa) \\<bind>\n                                   (\\<lambda>_. gds_discover gds u v sa))))\n         s';\n        (V0i \\<subseteq> c.gen_discovered s \\<longrightarrow>\n         \\<not> gds_is_empty_stack gdsi s) \\<and>\n        \\<not> gds_is_break gdsi s;\n        (V0 \\<subseteq> a.gen_discovered s' \\<longrightarrow>\n         \\<not> gds_is_empty_stack gds s') \\<and>\n        \\<not> gds_is_break gds s';\n        nofail\n         (if gds_is_empty_stack gdsi s\n          then SPEC\n                (\\<lambda>v0.\n                    v0 \\<in> V0i \\<and>\n                    \\<not> gds_is_discovered gdsi v0 s) \\<bind>\n               (\\<lambda>v0. gds_new_root gdsi v0 s)\n          else gds_get_pending gdsi s \\<bind>\n               (\\<lambda>(u, Vs, s).\n                   case Vs of None \\<Rightarrow> gds_finish gdsi u s\n                   | Some v \\<Rightarrow>\n                       if gds_is_discovered gdsi v s\n                       then if gds_is_finished gdsi v s\n                            then gds_cross_edge gdsi u v s\n                            else gds_back_edge gdsi u v s\n                       else gds_discover gdsi u v s))\\<rbrakk>\n       \\<Longrightarrow> (if gds_is_empty_stack gdsi s\n                          then SPEC\n                                (\\<lambda>v0.\n                                    v0 \\<in> V0i \\<and>\n                                    \\<not> gds_is_discovered gdsi v0\n      s) \\<bind>\n                               (\\<lambda>v0. gds_new_root gdsi v0 s)\n                          else gds_get_pending gdsi s \\<bind>\n                               (\\<lambda>(u, Vs, s).\n                                   case Vs of\n                                   None \\<Rightarrow> gds_finish gdsi u s\n                                   | Some v \\<Rightarrow>\n if gds_is_discovered gdsi v s\n then if gds_is_finished gdsi v s then gds_cross_edge gdsi u v s\n      else gds_back_edge gdsi u v s\n else gds_discover gdsi u v s))\n                         \\<le> \\<Down> S\n                                (if gds_is_empty_stack gds s'\n                                 then SPEC\n (\\<lambda>v0.\n     v0 \\<in> V0 \\<and> \\<not> gds_is_discovered gds v0 s') \\<bind>\n(\\<lambda>v0.\n    ASSERT (a.pre_new_root v0 s') \\<bind>\n    (\\<lambda>_. gds_new_root gds v0 s'))\n                                 else ASSERT (a.pre_get_pending s') \\<bind>\n(\\<lambda>_.\n    gds_get_pending gds s' \\<bind>\n    (\\<lambda>(u, Vs, s).\n        case Vs of\n        None \\<Rightarrow>\n          ASSERT (a.pre_finish u s' s) \\<bind>\n          (\\<lambda>_. gds_finish gds u s)\n        | Some v \\<Rightarrow>\n            if gds_is_discovered gds v s\n            then if gds_is_finished gds v s\n                 then ASSERT (a.pre_cross_edge u v s' s) \\<bind>\n                      (\\<lambda>_. gds_cross_edge gds u v s)\n                 else ASSERT (a.pre_back_edge u v s' s) \\<bind>\n                      (\\<lambda>_. gds_back_edge gds u v s)\n            else ASSERT (a.pre_discover u v s' s) \\<bind>\n                 (\\<lambda>_. gds_discover gds u v s))))", "apply (refine_rcg IdD)"], ["proof (prove)\ngoal (19 subgoals):\n 1. \\<And>s s'.\n       \\<lbrakk>(s, s') \\<in> S;\n        rwof (gds_init gdsi)\n         (\\<lambda>s.\n             (V0i \\<subseteq> c.gen_discovered s \\<longrightarrow>\n              \\<not> gds_is_empty_stack gdsi s) \\<and>\n             \\<not> gds_is_break gdsi s)\n         (\\<lambda>s.\n             if gds_is_empty_stack gdsi s\n             then SPEC\n                   (\\<lambda>v0.\n                       v0 \\<in> V0i \\<and>\n                       \\<not> gds_is_discovered gdsi v0 s) \\<bind>\n                  (\\<lambda>v0. gds_new_root gdsi v0 s)\n             else gds_get_pending gdsi s \\<bind>\n                  (\\<lambda>(u, Vs, s).\n                      case Vs of None \\<Rightarrow> gds_finish gdsi u s\n                      | Some v \\<Rightarrow>\n                          if gds_is_discovered gdsi v s\n                          then if gds_is_finished gdsi v s\n                               then gds_cross_edge gdsi u v s\n                               else gds_back_edge gdsi u v s\n                          else gds_discover gdsi u v s))\n         s;\n        rwof (gds_init gds)\n         (\\<lambda>s.\n             (V0 \\<subseteq> a.gen_discovered s \\<longrightarrow>\n              \\<not> gds_is_empty_stack gds s) \\<and>\n             \\<not> gds_is_break gds s)\n         (\\<lambda>s.\n             if gds_is_empty_stack gds s\n             then SPEC\n                   (\\<lambda>v0.\n                       v0 \\<in> V0 \\<and>\n                       \\<not> gds_is_discovered gds v0 s) \\<bind>\n                  (\\<lambda>v0.\n                      ASSERT (a.pre_new_root v0 s) \\<bind>\n                      (\\<lambda>_. gds_new_root gds v0 s))\n             else ASSERT (a.pre_get_pending s) \\<bind>\n                  (\\<lambda>_.\n                      gds_get_pending gds s \\<bind>\n                      (\\<lambda>(u, Vs, sa).\n                          case Vs of\n                          None \\<Rightarrow>\n                            ASSERT (a.pre_finish u s sa) \\<bind>\n                            (\\<lambda>_. gds_finish gds u sa)\n                          | Some v \\<Rightarrow>\n                              if gds_is_discovered gds v sa\n                              then if gds_is_finished gds v sa\n                                   then ASSERT\n   (a.pre_cross_edge u v s sa) \\<bind>\n  (\\<lambda>_. gds_cross_edge gds u v sa)\n                                   else ASSERT\n   (a.pre_back_edge u v s sa) \\<bind>\n  (\\<lambda>_. gds_back_edge gds u v sa)\n                              else ASSERT (a.pre_discover u v s sa) \\<bind>\n                                   (\\<lambda>_. gds_discover gds u v sa))))\n         s';\n        (V0i \\<subseteq> c.gen_discovered s \\<longrightarrow>\n         \\<not> gds_is_empty_stack gdsi s) \\<and>\n        \\<not> gds_is_break gdsi s;\n        (V0 \\<subseteq> a.gen_discovered s' \\<longrightarrow>\n         \\<not> gds_is_empty_stack gds s') \\<and>\n        \\<not> gds_is_break gds s';\n        nofail\n         (if gds_is_empty_stack gdsi s\n          then SPEC\n                (\\<lambda>v0.\n                    v0 \\<in> V0i \\<and>\n                    \\<not> gds_is_discovered gdsi v0 s) \\<bind>\n               (\\<lambda>v0. gds_new_root gdsi v0 s)\n          else gds_get_pending gdsi s \\<bind>\n               (\\<lambda>(u, Vs, s).\n                   case Vs of None \\<Rightarrow> gds_finish gdsi u s\n                   | Some v \\<Rightarrow>\n                       if gds_is_discovered gdsi v s\n                       then if gds_is_finished gdsi v s\n                            then gds_cross_edge gdsi u v s\n                            else gds_back_edge gdsi u v s\n                       else gds_discover gdsi u v s))\\<rbrakk>\n       \\<Longrightarrow> (gds_is_empty_stack gdsi s,\n                          gds_is_empty_stack gds s')\n                         \\<in> bool_rel\n 2. \\<And>s s' x x' x1 x2 x1a x2a x1b x2b x1c x2c.\n       \\<lbrakk>(s, s') \\<in> S;\n        rwof (gds_init gdsi)\n         (\\<lambda>s.\n             (V0i \\<subseteq> c.gen_discovered s \\<longrightarrow>\n              \\<not> gds_is_empty_stack gdsi s) \\<and>\n             \\<not> gds_is_break gdsi s)\n         (\\<lambda>s.\n             if gds_is_empty_stack gdsi s\n             then SPEC\n                   (\\<lambda>v0.\n                       v0 \\<in> V0i \\<and>\n                       \\<not> gds_is_discovered gdsi v0 s) \\<bind>\n                  (\\<lambda>v0. gds_new_root gdsi v0 s)\n             else gds_get_pending gdsi s \\<bind>\n                  (\\<lambda>(u, Vs, s).\n                      case Vs of None \\<Rightarrow> gds_finish gdsi u s\n                      | Some v \\<Rightarrow>\n                          if gds_is_discovered gdsi v s\n                          then if gds_is_finished gdsi v s\n                               then gds_cross_edge gdsi u v s\n                               else gds_back_edge gdsi u v s\n                          else gds_discover gdsi u v s))\n         s;\n        rwof (gds_init gds)\n         (\\<lambda>s.\n             (V0 \\<subseteq> a.gen_discovered s \\<longrightarrow>\n              \\<not> gds_is_empty_stack gds s) \\<and>\n             \\<not> gds_is_break gds s)\n         (\\<lambda>s.\n             if gds_is_empty_stack gds s\n             then SPEC\n                   (\\<lambda>v0.\n                       v0 \\<in> V0 \\<and>\n                       \\<not> gds_is_discovered gds v0 s) \\<bind>\n                  (\\<lambda>v0.\n                      ASSERT (a.pre_new_root v0 s) \\<bind>\n                      (\\<lambda>_. gds_new_root gds v0 s))\n             else ASSERT (a.pre_get_pending s) \\<bind>\n                  (\\<lambda>_.\n                      gds_get_pending gds s \\<bind>\n                      (\\<lambda>(u, Vs, sa).\n                          case Vs of\n                          None \\<Rightarrow>\n                            ASSERT (a.pre_finish u s sa) \\<bind>\n                            (\\<lambda>_. gds_finish gds u sa)\n                          | Some v \\<Rightarrow>\n                              if gds_is_discovered gds v sa\n                              then if gds_is_finished gds v sa\n                                   then ASSERT\n   (a.pre_cross_edge u v s sa) \\<bind>\n  (\\<lambda>_. gds_cross_edge gds u v sa)\n                                   else ASSERT\n   (a.pre_back_edge u v s sa) \\<bind>\n  (\\<lambda>_. gds_back_edge gds u v sa)\n                              else ASSERT (a.pre_discover u v s sa) \\<bind>\n                                   (\\<lambda>_. gds_discover gds u v sa))))\n         s';\n        (V0i \\<subseteq> c.gen_discovered s \\<longrightarrow>\n         \\<not> gds_is_empty_stack gdsi s) \\<and>\n        \\<not> gds_is_break gdsi s;\n        (V0 \\<subseteq> a.gen_discovered s' \\<longrightarrow>\n         \\<not> gds_is_empty_stack gds s') \\<and>\n        \\<not> gds_is_break gds s';\n        nofail\n         (if gds_is_empty_stack gdsi s\n          then SPEC\n                (\\<lambda>v0.\n                    v0 \\<in> V0i \\<and>\n                    \\<not> gds_is_discovered gdsi v0 s) \\<bind>\n               (\\<lambda>v0. gds_new_root gdsi v0 s)\n          else gds_get_pending gdsi s \\<bind>\n               (\\<lambda>(u, Vs, s).\n                   case Vs of None \\<Rightarrow> gds_finish gdsi u s\n                   | Some v \\<Rightarrow>\n                       if gds_is_discovered gdsi v s\n                       then if gds_is_finished gdsi v s\n                            then gds_cross_edge gdsi u v s\n                            else gds_back_edge gdsi u v s\n                       else gds_discover gdsi u v s));\n        \\<not> gds_is_empty_stack gdsi s; \\<not> gds_is_empty_stack gds s';\n        a.pre_get_pending s';\n        (x, x')\n        \\<in> V \\<times>\\<^sub>r\n              \\<langle>V\\<rangle>option_rel \\<times>\\<^sub>r S;\n        x2 = (x1a, x2a); x' = (x1, x2); x2b = (x1c, x2c);\n        x = (x1b, x2b)\\<rbrakk>\n       \\<Longrightarrow> (x1c, x1a)\n                         \\<in> \\<langle>?Ra105 s s' x x' x1 x2 x1a x2a x1b\n   x2b x1c x2c\\<rangle>option_rel\n 3. \\<And>s s' x x' x1 x2 x1a x2a x1b x2b x1c x2c.\n       \\<lbrakk>(s, s') \\<in> S;\n        rwof (gds_init gdsi)\n         (\\<lambda>s.\n             (V0i \\<subseteq> c.gen_discovered s \\<longrightarrow>\n              \\<not> gds_is_empty_stack gdsi s) \\<and>\n             \\<not> gds_is_break gdsi s)\n         (\\<lambda>s.\n             if gds_is_empty_stack gdsi s\n             then SPEC\n                   (\\<lambda>v0.\n                       v0 \\<in> V0i \\<and>\n                       \\<not> gds_is_discovered gdsi v0 s) \\<bind>\n                  (\\<lambda>v0. gds_new_root gdsi v0 s)\n             else gds_get_pending gdsi s \\<bind>\n                  (\\<lambda>(u, Vs, s).\n                      case Vs of None \\<Rightarrow> gds_finish gdsi u s\n                      | Some v \\<Rightarrow>\n                          if gds_is_discovered gdsi v s\n                          then if gds_is_finished gdsi v s\n                               then gds_cross_edge gdsi u v s\n                               else gds_back_edge gdsi u v s\n                          else gds_discover gdsi u v s))\n         s;\n        rwof (gds_init gds)\n         (\\<lambda>s.\n             (V0 \\<subseteq> a.gen_discovered s \\<longrightarrow>\n              \\<not> gds_is_empty_stack gds s) \\<and>\n             \\<not> gds_is_break gds s)\n         (\\<lambda>s.\n             if gds_is_empty_stack gds s\n             then SPEC\n                   (\\<lambda>v0.\n                       v0 \\<in> V0 \\<and>\n                       \\<not> gds_is_discovered gds v0 s) \\<bind>\n                  (\\<lambda>v0.\n                      ASSERT (a.pre_new_root v0 s) \\<bind>\n                      (\\<lambda>_. gds_new_root gds v0 s))\n             else ASSERT (a.pre_get_pending s) \\<bind>\n                  (\\<lambda>_.\n                      gds_get_pending gds s \\<bind>\n                      (\\<lambda>(u, Vs, sa).\n                          case Vs of\n                          None \\<Rightarrow>\n                            ASSERT (a.pre_finish u s sa) \\<bind>\n                            (\\<lambda>_. gds_finish gds u sa)\n                          | Some v \\<Rightarrow>\n                              if gds_is_discovered gds v sa\n                              then if gds_is_finished gds v sa\n                                   then ASSERT\n   (a.pre_cross_edge u v s sa) \\<bind>\n  (\\<lambda>_. gds_cross_edge gds u v sa)\n                                   else ASSERT\n   (a.pre_back_edge u v s sa) \\<bind>\n  (\\<lambda>_. gds_back_edge gds u v sa)\n                              else ASSERT (a.pre_discover u v s sa) \\<bind>\n                                   (\\<lambda>_. gds_discover gds u v sa))))\n         s';\n        (V0i \\<subseteq> c.gen_discovered s \\<longrightarrow>\n         \\<not> gds_is_empty_stack gdsi s) \\<and>\n        \\<not> gds_is_break gdsi s;\n        (V0 \\<subseteq> a.gen_discovered s' \\<longrightarrow>\n         \\<not> gds_is_empty_stack gds s') \\<and>\n        \\<not> gds_is_break gds s';\n        nofail\n         (if gds_is_empty_stack gdsi s\n          then SPEC\n                (\\<lambda>v0.\n                    v0 \\<in> V0i \\<and>\n                    \\<not> gds_is_discovered gdsi v0 s) \\<bind>\n               (\\<lambda>v0. gds_new_root gdsi v0 s)\n          else gds_get_pending gdsi s \\<bind>\n               (\\<lambda>(u, Vs, s).\n                   case Vs of None \\<Rightarrow> gds_finish gdsi u s\n                   | Some v \\<Rightarrow>\n                       if gds_is_discovered gdsi v s\n                       then if gds_is_finished gdsi v s\n                            then gds_cross_edge gdsi u v s\n                            else gds_back_edge gdsi u v s\n                       else gds_discover gdsi u v s));\n        \\<not> gds_is_empty_stack gdsi s; \\<not> gds_is_empty_stack gds s';\n        a.pre_get_pending s';\n        (x, x')\n        \\<in> V \\<times>\\<^sub>r\n              \\<langle>V\\<rangle>option_rel \\<times>\\<^sub>r S;\n        x2 = (x1a, x2a); x' = (x1, x2); x2b = (x1c, x2c); x = (x1b, x2b);\n        x1c = None; x1a = None; a.pre_finish x1 s' x2a\\<rbrakk>\n       \\<Longrightarrow> a.pre_finish x1\n                          (?s0.107 s s' x x' x1 x2 x1a x2a x1b x2b x1c x2c)\n                          x2a\n 4. \\<And>s s' x x' x1 x2 x1a x2a x1b x2b x1c x2c.\n       \\<lbrakk>(s, s') \\<in> S;\n        rwof (gds_init gdsi)\n         (\\<lambda>s.\n             (V0i \\<subseteq> c.gen_discovered s \\<longrightarrow>\n              \\<not> gds_is_empty_stack gdsi s) \\<and>\n             \\<not> gds_is_break gdsi s)\n         (\\<lambda>s.\n             if gds_is_empty_stack gdsi s\n             then SPEC\n                   (\\<lambda>v0.\n                       v0 \\<in> V0i \\<and>\n                       \\<not> gds_is_discovered gdsi v0 s) \\<bind>\n                  (\\<lambda>v0. gds_new_root gdsi v0 s)\n             else gds_get_pending gdsi s \\<bind>\n                  (\\<lambda>(u, Vs, s).\n                      case Vs of None \\<Rightarrow> gds_finish gdsi u s\n                      | Some v \\<Rightarrow>\n                          if gds_is_discovered gdsi v s\n                          then if gds_is_finished gdsi v s\n                               then gds_cross_edge gdsi u v s\n                               else gds_back_edge gdsi u v s\n                          else gds_discover gdsi u v s))\n         s;\n        rwof (gds_init gds)\n         (\\<lambda>s.\n             (V0 \\<subseteq> a.gen_discovered s \\<longrightarrow>\n              \\<not> gds_is_empty_stack gds s) \\<and>\n             \\<not> gds_is_break gds s)\n         (\\<lambda>s.\n             if gds_is_empty_stack gds s\n             then SPEC\n                   (\\<lambda>v0.\n                       v0 \\<in> V0 \\<and>\n                       \\<not> gds_is_discovered gds v0 s) \\<bind>\n                  (\\<lambda>v0.\n                      ASSERT (a.pre_new_root v0 s) \\<bind>\n                      (\\<lambda>_. gds_new_root gds v0 s))\n             else ASSERT (a.pre_get_pending s) \\<bind>\n                  (\\<lambda>_.\n                      gds_get_pending gds s \\<bind>\n                      (\\<lambda>(u, Vs, sa).\n                          case Vs of\n                          None \\<Rightarrow>\n                            ASSERT (a.pre_finish u s sa) \\<bind>\n                            (\\<lambda>_. gds_finish gds u sa)\n                          | Some v \\<Rightarrow>\n                              if gds_is_discovered gds v sa\n                              then if gds_is_finished gds v sa\n                                   then ASSERT\n   (a.pre_cross_edge u v s sa) \\<bind>\n  (\\<lambda>_. gds_cross_edge gds u v sa)\n                                   else ASSERT\n   (a.pre_back_edge u v s sa) \\<bind>\n  (\\<lambda>_. gds_back_edge gds u v sa)\n                              else ASSERT (a.pre_discover u v s sa) \\<bind>\n                                   (\\<lambda>_. gds_discover gds u v sa))))\n         s';\n        (V0i \\<subseteq> c.gen_discovered s \\<longrightarrow>\n         \\<not> gds_is_empty_stack gdsi s) \\<and>\n        \\<not> gds_is_break gdsi s;\n        (V0 \\<subseteq> a.gen_discovered s' \\<longrightarrow>\n         \\<not> gds_is_empty_stack gds s') \\<and>\n        \\<not> gds_is_break gds s';\n        nofail\n         (if gds_is_empty_stack gdsi s\n          then SPEC\n                (\\<lambda>v0.\n                    v0 \\<in> V0i \\<and>\n                    \\<not> gds_is_discovered gdsi v0 s) \\<bind>\n               (\\<lambda>v0. gds_new_root gdsi v0 s)\n          else gds_get_pending gdsi s \\<bind>\n               (\\<lambda>(u, Vs, s).\n                   case Vs of None \\<Rightarrow> gds_finish gdsi u s\n                   | Some v \\<Rightarrow>\n                       if gds_is_discovered gdsi v s\n                       then if gds_is_finished gdsi v s\n                            then gds_cross_edge gdsi u v s\n                            else gds_back_edge gdsi u v s\n                       else gds_discover gdsi u v s));\n        \\<not> gds_is_empty_stack gdsi s; \\<not> gds_is_empty_stack gds s';\n        a.pre_get_pending s';\n        (x, x')\n        \\<in> V \\<times>\\<^sub>r\n              \\<langle>V\\<rangle>option_rel \\<times>\\<^sub>r S;\n        x2 = (x1a, x2a); x' = (x1, x2); x2b = (x1c, x2c); x = (x1b, x2b);\n        x1c = None; x1a = None; a.pre_finish x1 s' x2a\\<rbrakk>\n       \\<Longrightarrow> (x1b, x1) \\<in> V\n 5. \\<And>s s' x x' x1 x2 x1a x2a x1b x2b x1c x2c.\n       \\<lbrakk>(s, s') \\<in> S;\n        rwof (gds_init gdsi)\n         (\\<lambda>s.\n             (V0i \\<subseteq> c.gen_discovered s \\<longrightarrow>\n              \\<not> gds_is_empty_stack gdsi s) \\<and>\n             \\<not> gds_is_break gdsi s)\n         (\\<lambda>s.\n             if gds_is_empty_stack gdsi s\n             then SPEC\n                   (\\<lambda>v0.\n                       v0 \\<in> V0i \\<and>\n                       \\<not> gds_is_discovered gdsi v0 s) \\<bind>\n                  (\\<lambda>v0. gds_new_root gdsi v0 s)\n             else gds_get_pending gdsi s \\<bind>\n                  (\\<lambda>(u, Vs, s).\n                      case Vs of None \\<Rightarrow> gds_finish gdsi u s\n                      | Some v \\<Rightarrow>\n                          if gds_is_discovered gdsi v s\n                          then if gds_is_finished gdsi v s\n                               then gds_cross_edge gdsi u v s\n                               else gds_back_edge gdsi u v s\n                          else gds_discover gdsi u v s))\n         s;\n        rwof (gds_init gds)\n         (\\<lambda>s.\n             (V0 \\<subseteq> a.gen_discovered s \\<longrightarrow>\n              \\<not> gds_is_empty_stack gds s) \\<and>\n             \\<not> gds_is_break gds s)\n         (\\<lambda>s.\n             if gds_is_empty_stack gds s\n             then SPEC\n                   (\\<lambda>v0.\n                       v0 \\<in> V0 \\<and>\n                       \\<not> gds_is_discovered gds v0 s) \\<bind>\n                  (\\<lambda>v0.\n                      ASSERT (a.pre_new_root v0 s) \\<bind>\n                      (\\<lambda>_. gds_new_root gds v0 s))\n             else ASSERT (a.pre_get_pending s) \\<bind>\n                  (\\<lambda>_.\n                      gds_get_pending gds s \\<bind>\n                      (\\<lambda>(u, Vs, sa).\n                          case Vs of\n                          None \\<Rightarrow>\n                            ASSERT (a.pre_finish u s sa) \\<bind>\n                            (\\<lambda>_. gds_finish gds u sa)\n                          | Some v \\<Rightarrow>\n                              if gds_is_discovered gds v sa\n                              then if gds_is_finished gds v sa\n                                   then ASSERT\n   (a.pre_cross_edge u v s sa) \\<bind>\n  (\\<lambda>_. gds_cross_edge gds u v sa)\n                                   else ASSERT\n   (a.pre_back_edge u v s sa) \\<bind>\n  (\\<lambda>_. gds_back_edge gds u v sa)\n                              else ASSERT (a.pre_discover u v s sa) \\<bind>\n                                   (\\<lambda>_. gds_discover gds u v sa))))\n         s';\n        (V0i \\<subseteq> c.gen_discovered s \\<longrightarrow>\n         \\<not> gds_is_empty_stack gdsi s) \\<and>\n        \\<not> gds_is_break gdsi s;\n        (V0 \\<subseteq> a.gen_discovered s' \\<longrightarrow>\n         \\<not> gds_is_empty_stack gds s') \\<and>\n        \\<not> gds_is_break gds s';\n        nofail\n         (if gds_is_empty_stack gdsi s\n          then SPEC\n                (\\<lambda>v0.\n                    v0 \\<in> V0i \\<and>\n                    \\<not> gds_is_discovered gdsi v0 s) \\<bind>\n               (\\<lambda>v0. gds_new_root gdsi v0 s)\n          else gds_get_pending gdsi s \\<bind>\n               (\\<lambda>(u, Vs, s).\n                   case Vs of None \\<Rightarrow> gds_finish gdsi u s\n                   | Some v \\<Rightarrow>\n                       if gds_is_discovered gdsi v s\n                       then if gds_is_finished gdsi v s\n                            then gds_cross_edge gdsi u v s\n                            else gds_back_edge gdsi u v s\n                       else gds_discover gdsi u v s));\n        \\<not> gds_is_empty_stack gdsi s; \\<not> gds_is_empty_stack gds s';\n        a.pre_get_pending s';\n        (x, x')\n        \\<in> V \\<times>\\<^sub>r\n              \\<langle>V\\<rangle>option_rel \\<times>\\<^sub>r S;\n        x2 = (x1a, x2a); x' = (x1, x2); x2b = (x1c, x2c); x = (x1b, x2b);\n        x1c = None; x1a = None; a.pre_finish x1 s' x2a\\<rbrakk>\n       \\<Longrightarrow> (x2c, x2a) \\<in> S\n 6. \\<And>s s' x x' x1 x2 x1a x2a x1b x2b x1c x2c xa x'a.\n       \\<lbrakk>(s, s') \\<in> S;\n        rwof (gds_init gdsi)\n         (\\<lambda>s.\n             (V0i \\<subseteq> c.gen_discovered s \\<longrightarrow>\n              \\<not> gds_is_empty_stack gdsi s) \\<and>\n             \\<not> gds_is_break gdsi s)\n         (\\<lambda>s.\n             if gds_is_empty_stack gdsi s\n             then SPEC\n                   (\\<lambda>v0.\n                       v0 \\<in> V0i \\<and>\n                       \\<not> gds_is_discovered gdsi v0 s) \\<bind>\n                  (\\<lambda>v0. gds_new_root gdsi v0 s)\n             else gds_get_pending gdsi s \\<bind>\n                  (\\<lambda>(u, Vs, s).\n                      case Vs of None \\<Rightarrow> gds_finish gdsi u s\n                      | Some v \\<Rightarrow>\n                          if gds_is_discovered gdsi v s\n                          then if gds_is_finished gdsi v s\n                               then gds_cross_edge gdsi u v s\n                               else gds_back_edge gdsi u v s\n                          else gds_discover gdsi u v s))\n         s;\n        rwof (gds_init gds)\n         (\\<lambda>s.\n             (V0 \\<subseteq> a.gen_discovered s \\<longrightarrow>\n              \\<not> gds_is_empty_stack gds s) \\<and>\n             \\<not> gds_is_break gds s)\n         (\\<lambda>s.\n             if gds_is_empty_stack gds s\n             then SPEC\n                   (\\<lambda>v0.\n                       v0 \\<in> V0 \\<and>\n                       \\<not> gds_is_discovered gds v0 s) \\<bind>\n                  (\\<lambda>v0.\n                      ASSERT (a.pre_new_root v0 s) \\<bind>\n                      (\\<lambda>_. gds_new_root gds v0 s))\n             else ASSERT (a.pre_get_pending s) \\<bind>\n                  (\\<lambda>_.\n                      gds_get_pending gds s \\<bind>\n                      (\\<lambda>(u, Vs, sa).\n                          case Vs of\n                          None \\<Rightarrow>\n                            ASSERT (a.pre_finish u s sa) \\<bind>\n                            (\\<lambda>_. gds_finish gds u sa)\n                          | Some v \\<Rightarrow>\n                              if gds_is_discovered gds v sa\n                              then if gds_is_finished gds v sa\n                                   then ASSERT\n   (a.pre_cross_edge u v s sa) \\<bind>\n  (\\<lambda>_. gds_cross_edge gds u v sa)\n                                   else ASSERT\n   (a.pre_back_edge u v s sa) \\<bind>\n  (\\<lambda>_. gds_back_edge gds u v sa)\n                              else ASSERT (a.pre_discover u v s sa) \\<bind>\n                                   (\\<lambda>_. gds_discover gds u v sa))))\n         s';\n        (V0i \\<subseteq> c.gen_discovered s \\<longrightarrow>\n         \\<not> gds_is_empty_stack gdsi s) \\<and>\n        \\<not> gds_is_break gdsi s;\n        (V0 \\<subseteq> a.gen_discovered s' \\<longrightarrow>\n         \\<not> gds_is_empty_stack gds s') \\<and>\n        \\<not> gds_is_break gds s';\n        nofail\n         (if gds_is_empty_stack gdsi s\n          then SPEC\n                (\\<lambda>v0.\n                    v0 \\<in> V0i \\<and>\n                    \\<not> gds_is_discovered gdsi v0 s) \\<bind>\n               (\\<lambda>v0. gds_new_root gdsi v0 s)\n          else gds_get_pending gdsi s \\<bind>\n               (\\<lambda>(u, Vs, s).\n                   case Vs of None \\<Rightarrow> gds_finish gdsi u s\n                   | Some v \\<Rightarrow>\n                       if gds_is_discovered gdsi v s\n                       then if gds_is_finished gdsi v s\n                            then gds_cross_edge gdsi u v s\n                            else gds_back_edge gdsi u v s\n                       else gds_discover gdsi u v s));\n        \\<not> gds_is_empty_stack gdsi s; \\<not> gds_is_empty_stack gds s';\n        a.pre_get_pending s';\n        (x, x')\n        \\<in> V \\<times>\\<^sub>r\n              \\<langle>V\\<rangle>option_rel \\<times>\\<^sub>r S;\n        x2 = (x1a, x2a); x' = (x1, x2); x2b = (x1c, x2c); x = (x1b, x2b);\n        x1c = Some xa; x1a = Some x'a;\n        (xa, x'a)\n        \\<in> ?Ra105 s s' x x' x1 x2 x1a x2a x1b x2b x1c x2c\\<rbrakk>\n       \\<Longrightarrow> (gds_is_discovered gdsi xa x2c,\n                          gds_is_discovered gds x'a x2a)\n                         \\<in> bool_rel\n 7. \\<And>s s' x x' x1 x2 x1a x2a x1b x2b x1c x2c xa x'a.\n       \\<lbrakk>(s, s') \\<in> S;\n        rwof (gds_init gdsi)\n         (\\<lambda>s.\n             (V0i \\<subseteq> c.gen_discovered s \\<longrightarrow>\n              \\<not> gds_is_empty_stack gdsi s) \\<and>\n             \\<not> gds_is_break gdsi s)\n         (\\<lambda>s.\n             if gds_is_empty_stack gdsi s\n             then SPEC\n                   (\\<lambda>v0.\n                       v0 \\<in> V0i \\<and>\n                       \\<not> gds_is_discovered gdsi v0 s) \\<bind>\n                  (\\<lambda>v0. gds_new_root gdsi v0 s)\n             else gds_get_pending gdsi s \\<bind>\n                  (\\<lambda>(u, Vs, s).\n                      case Vs of None \\<Rightarrow> gds_finish gdsi u s\n                      | Some v \\<Rightarrow>\n                          if gds_is_discovered gdsi v s\n                          then if gds_is_finished gdsi v s\n                               then gds_cross_edge gdsi u v s\n                               else gds_back_edge gdsi u v s\n                          else gds_discover gdsi u v s))\n         s;\n        rwof (gds_init gds)\n         (\\<lambda>s.\n             (V0 \\<subseteq> a.gen_discovered s \\<longrightarrow>\n              \\<not> gds_is_empty_stack gds s) \\<and>\n             \\<not> gds_is_break gds s)\n         (\\<lambda>s.\n             if gds_is_empty_stack gds s\n             then SPEC\n                   (\\<lambda>v0.\n                       v0 \\<in> V0 \\<and>\n                       \\<not> gds_is_discovered gds v0 s) \\<bind>\n                  (\\<lambda>v0.\n                      ASSERT (a.pre_new_root v0 s) \\<bind>\n                      (\\<lambda>_. gds_new_root gds v0 s))\n             else ASSERT (a.pre_get_pending s) \\<bind>\n                  (\\<lambda>_.\n                      gds_get_pending gds s \\<bind>\n                      (\\<lambda>(u, Vs, sa).\n                          case Vs of\n                          None \\<Rightarrow>\n                            ASSERT (a.pre_finish u s sa) \\<bind>\n                            (\\<lambda>_. gds_finish gds u sa)\n                          | Some v \\<Rightarrow>\n                              if gds_is_discovered gds v sa\n                              then if gds_is_finished gds v sa\n                                   then ASSERT\n   (a.pre_cross_edge u v s sa) \\<bind>\n  (\\<lambda>_. gds_cross_edge gds u v sa)\n                                   else ASSERT\n   (a.pre_back_edge u v s sa) \\<bind>\n  (\\<lambda>_. gds_back_edge gds u v sa)\n                              else ASSERT (a.pre_discover u v s sa) \\<bind>\n                                   (\\<lambda>_. gds_discover gds u v sa))))\n         s';\n        (V0i \\<subseteq> c.gen_discovered s \\<longrightarrow>\n         \\<not> gds_is_empty_stack gdsi s) \\<and>\n        \\<not> gds_is_break gdsi s;\n        (V0 \\<subseteq> a.gen_discovered s' \\<longrightarrow>\n         \\<not> gds_is_empty_stack gds s') \\<and>\n        \\<not> gds_is_break gds s';\n        nofail\n         (if gds_is_empty_stack gdsi s\n          then SPEC\n                (\\<lambda>v0.\n                    v0 \\<in> V0i \\<and>\n                    \\<not> gds_is_discovered gdsi v0 s) \\<bind>\n               (\\<lambda>v0. gds_new_root gdsi v0 s)\n          else gds_get_pending gdsi s \\<bind>\n               (\\<lambda>(u, Vs, s).\n                   case Vs of None \\<Rightarrow> gds_finish gdsi u s\n                   | Some v \\<Rightarrow>\n                       if gds_is_discovered gdsi v s\n                       then if gds_is_finished gdsi v s\n                            then gds_cross_edge gdsi u v s\n                            else gds_back_edge gdsi u v s\n                       else gds_discover gdsi u v s));\n        \\<not> gds_is_empty_stack gdsi s; \\<not> gds_is_empty_stack gds s';\n        a.pre_get_pending s';\n        (x, x')\n        \\<in> V \\<times>\\<^sub>r\n              \\<langle>V\\<rangle>option_rel \\<times>\\<^sub>r S;\n        x2 = (x1a, x2a); x' = (x1, x2); x2b = (x1c, x2c); x = (x1b, x2b);\n        x1c = Some xa; x1a = Some x'a;\n        (xa, x'a) \\<in> ?Ra105 s s' x x' x1 x2 x1a x2a x1b x2b x1c x2c;\n        gds_is_discovered gdsi xa x2c;\n        gds_is_discovered gds x'a x2a\\<rbrakk>\n       \\<Longrightarrow> (gds_is_finished gdsi xa x2c,\n                          gds_is_finished gds x'a x2a)\n                         \\<in> bool_rel\n 8. \\<And>s s' x x' x1 x2 x1a x2a x1b x2b x1c x2c xa x'a.\n       \\<lbrakk>(s, s') \\<in> S;\n        rwof (gds_init gdsi)\n         (\\<lambda>s.\n             (V0i \\<subseteq> c.gen_discovered s \\<longrightarrow>\n              \\<not> gds_is_empty_stack gdsi s) \\<and>\n             \\<not> gds_is_break gdsi s)\n         (\\<lambda>s.\n             if gds_is_empty_stack gdsi s\n             then SPEC\n                   (\\<lambda>v0.\n                       v0 \\<in> V0i \\<and>\n                       \\<not> gds_is_discovered gdsi v0 s) \\<bind>\n                  (\\<lambda>v0. gds_new_root gdsi v0 s)\n             else gds_get_pending gdsi s \\<bind>\n                  (\\<lambda>(u, Vs, s).\n                      case Vs of None \\<Rightarrow> gds_finish gdsi u s\n                      | Some v \\<Rightarrow>\n                          if gds_is_discovered gdsi v s\n                          then if gds_is_finished gdsi v s\n                               then gds_cross_edge gdsi u v s\n                               else gds_back_edge gdsi u v s\n                          else gds_discover gdsi u v s))\n         s;\n        rwof (gds_init gds)\n         (\\<lambda>s.\n             (V0 \\<subseteq> a.gen_discovered s \\<longrightarrow>\n              \\<not> gds_is_empty_stack gds s) \\<and>\n             \\<not> gds_is_break gds s)\n         (\\<lambda>s.\n             if gds_is_empty_stack gds s\n             then SPEC\n                   (\\<lambda>v0.\n                       v0 \\<in> V0 \\<and>\n                       \\<not> gds_is_discovered gds v0 s) \\<bind>\n                  (\\<lambda>v0.\n                      ASSERT (a.pre_new_root v0 s) \\<bind>\n                      (\\<lambda>_. gds_new_root gds v0 s))\n             else ASSERT (a.pre_get_pending s) \\<bind>\n                  (\\<lambda>_.\n                      gds_get_pending gds s \\<bind>\n                      (\\<lambda>(u, Vs, sa).\n                          case Vs of\n                          None \\<Rightarrow>\n                            ASSERT (a.pre_finish u s sa) \\<bind>\n                            (\\<lambda>_. gds_finish gds u sa)\n                          | Some v \\<Rightarrow>\n                              if gds_is_discovered gds v sa\n                              then if gds_is_finished gds v sa\n                                   then ASSERT\n   (a.pre_cross_edge u v s sa) \\<bind>\n  (\\<lambda>_. gds_cross_edge gds u v sa)\n                                   else ASSERT\n   (a.pre_back_edge u v s sa) \\<bind>\n  (\\<lambda>_. gds_back_edge gds u v sa)\n                              else ASSERT (a.pre_discover u v s sa) \\<bind>\n                                   (\\<lambda>_. gds_discover gds u v sa))))\n         s';\n        (V0i \\<subseteq> c.gen_discovered s \\<longrightarrow>\n         \\<not> gds_is_empty_stack gdsi s) \\<and>\n        \\<not> gds_is_break gdsi s;\n        (V0 \\<subseteq> a.gen_discovered s' \\<longrightarrow>\n         \\<not> gds_is_empty_stack gds s') \\<and>\n        \\<not> gds_is_break gds s';\n        nofail\n         (if gds_is_empty_stack gdsi s\n          then SPEC\n                (\\<lambda>v0.\n                    v0 \\<in> V0i \\<and>\n                    \\<not> gds_is_discovered gdsi v0 s) \\<bind>\n               (\\<lambda>v0. gds_new_root gdsi v0 s)\n          else gds_get_pending gdsi s \\<bind>\n               (\\<lambda>(u, Vs, s).\n                   case Vs of None \\<Rightarrow> gds_finish gdsi u s\n                   | Some v \\<Rightarrow>\n                       if gds_is_discovered gdsi v s\n                       then if gds_is_finished gdsi v s\n                            then gds_cross_edge gdsi u v s\n                            else gds_back_edge gdsi u v s\n                       else gds_discover gdsi u v s));\n        \\<not> gds_is_empty_stack gdsi s; \\<not> gds_is_empty_stack gds s';\n        a.pre_get_pending s';\n        (x, x')\n        \\<in> V \\<times>\\<^sub>r\n              \\<langle>V\\<rangle>option_rel \\<times>\\<^sub>r S;\n        x2 = (x1a, x2a); x' = (x1, x2); x2b = (x1c, x2c); x = (x1b, x2b);\n        x1c = Some xa; x1a = Some x'a;\n        (xa, x'a) \\<in> ?Ra105 s s' x x' x1 x2 x1a x2a x1b x2b x1c x2c;\n        gds_is_discovered gdsi xa x2c; gds_is_discovered gds x'a x2a;\n        gds_is_finished gdsi xa x2c; gds_is_finished gds x'a x2a;\n        a.pre_cross_edge x1 x'a s' x2a\\<rbrakk>\n       \\<Longrightarrow> a.pre_cross_edge x1 x'a\n                          (?s0.113 s s' x x' x1 x2 x1a x2a x1b x2b x1c x2c\n                            xa x'a)\n                          x2a\n 9. \\<And>s s' x x' x1 x2 x1a x2a x1b x2b x1c x2c xa x'a.\n       \\<lbrakk>(s, s') \\<in> S;\n        rwof (gds_init gdsi)\n         (\\<lambda>s.\n             (V0i \\<subseteq> c.gen_discovered s \\<longrightarrow>\n              \\<not> gds_is_empty_stack gdsi s) \\<and>\n             \\<not> gds_is_break gdsi s)\n         (\\<lambda>s.\n             if gds_is_empty_stack gdsi s\n             then SPEC\n                   (\\<lambda>v0.\n                       v0 \\<in> V0i \\<and>\n                       \\<not> gds_is_discovered gdsi v0 s) \\<bind>\n                  (\\<lambda>v0. gds_new_root gdsi v0 s)\n             else gds_get_pending gdsi s \\<bind>\n                  (\\<lambda>(u, Vs, s).\n                      case Vs of None \\<Rightarrow> gds_finish gdsi u s\n                      | Some v \\<Rightarrow>\n                          if gds_is_discovered gdsi v s\n                          then if gds_is_finished gdsi v s\n                               then gds_cross_edge gdsi u v s\n                               else gds_back_edge gdsi u v s\n                          else gds_discover gdsi u v s))\n         s;\n        rwof (gds_init gds)\n         (\\<lambda>s.\n             (V0 \\<subseteq> a.gen_discovered s \\<longrightarrow>\n              \\<not> gds_is_empty_stack gds s) \\<and>\n             \\<not> gds_is_break gds s)\n         (\\<lambda>s.\n             if gds_is_empty_stack gds s\n             then SPEC\n                   (\\<lambda>v0.\n                       v0 \\<in> V0 \\<and>\n                       \\<not> gds_is_discovered gds v0 s) \\<bind>\n                  (\\<lambda>v0.\n                      ASSERT (a.pre_new_root v0 s) \\<bind>\n                      (\\<lambda>_. gds_new_root gds v0 s))\n             else ASSERT (a.pre_get_pending s) \\<bind>\n                  (\\<lambda>_.\n                      gds_get_pending gds s \\<bind>\n                      (\\<lambda>(u, Vs, sa).\n                          case Vs of\n                          None \\<Rightarrow>\n                            ASSERT (a.pre_finish u s sa) \\<bind>\n                            (\\<lambda>_. gds_finish gds u sa)\n                          | Some v \\<Rightarrow>\n                              if gds_is_discovered gds v sa\n                              then if gds_is_finished gds v sa\n                                   then ASSERT\n   (a.pre_cross_edge u v s sa) \\<bind>\n  (\\<lambda>_. gds_cross_edge gds u v sa)\n                                   else ASSERT\n   (a.pre_back_edge u v s sa) \\<bind>\n  (\\<lambda>_. gds_back_edge gds u v sa)\n                              else ASSERT (a.pre_discover u v s sa) \\<bind>\n                                   (\\<lambda>_. gds_discover gds u v sa))))\n         s';\n        (V0i \\<subseteq> c.gen_discovered s \\<longrightarrow>\n         \\<not> gds_is_empty_stack gdsi s) \\<and>\n        \\<not> gds_is_break gdsi s;\n        (V0 \\<subseteq> a.gen_discovered s' \\<longrightarrow>\n         \\<not> gds_is_empty_stack gds s') \\<and>\n        \\<not> gds_is_break gds s';\n        nofail\n         (if gds_is_empty_stack gdsi s\n          then SPEC\n                (\\<lambda>v0.\n                    v0 \\<in> V0i \\<and>\n                    \\<not> gds_is_discovered gdsi v0 s) \\<bind>\n               (\\<lambda>v0. gds_new_root gdsi v0 s)\n          else gds_get_pending gdsi s \\<bind>\n               (\\<lambda>(u, Vs, s).\n                   case Vs of None \\<Rightarrow> gds_finish gdsi u s\n                   | Some v \\<Rightarrow>\n                       if gds_is_discovered gdsi v s\n                       then if gds_is_finished gdsi v s\n                            then gds_cross_edge gdsi u v s\n                            else gds_back_edge gdsi u v s\n                       else gds_discover gdsi u v s));\n        \\<not> gds_is_empty_stack gdsi s; \\<not> gds_is_empty_stack gds s';\n        a.pre_get_pending s';\n        (x, x')\n        \\<in> V \\<times>\\<^sub>r\n              \\<langle>V\\<rangle>option_rel \\<times>\\<^sub>r S;\n        x2 = (x1a, x2a); x' = (x1, x2); x2b = (x1c, x2c); x = (x1b, x2b);\n        x1c = Some xa; x1a = Some x'a;\n        (xa, x'a) \\<in> ?Ra105 s s' x x' x1 x2 x1a x2a x1b x2b x1c x2c;\n        gds_is_discovered gdsi xa x2c; gds_is_discovered gds x'a x2a;\n        gds_is_finished gdsi xa x2c; gds_is_finished gds x'a x2a;\n        a.pre_cross_edge x1 x'a s' x2a\\<rbrakk>\n       \\<Longrightarrow> (x1b, x1) \\<in> V\n 10. \\<And>s s' x x' x1 x2 x1a x2a x1b x2b x1c x2c xa x'a.\n        \\<lbrakk>(s, s') \\<in> S;\n         rwof (gds_init gdsi)\n          (\\<lambda>s.\n              (V0i \\<subseteq> c.gen_discovered s \\<longrightarrow>\n               \\<not> gds_is_empty_stack gdsi s) \\<and>\n              \\<not> gds_is_break gdsi s)\n          (\\<lambda>s.\n              if gds_is_empty_stack gdsi s\n              then SPEC\n                    (\\<lambda>v0.\n                        v0 \\<in> V0i \\<and>\n                        \\<not> gds_is_discovered gdsi v0 s) \\<bind>\n                   (\\<lambda>v0. gds_new_root gdsi v0 s)\n              else gds_get_pending gdsi s \\<bind>\n                   (\\<lambda>(u, Vs, s).\n                       case Vs of None \\<Rightarrow> gds_finish gdsi u s\n                       | Some v \\<Rightarrow>\n                           if gds_is_discovered gdsi v s\n                           then if gds_is_finished gdsi v s\n                                then gds_cross_edge gdsi u v s\n                                else gds_back_edge gdsi u v s\n                           else gds_discover gdsi u v s))\n          s;\n         rwof (gds_init gds)\n          (\\<lambda>s.\n              (V0 \\<subseteq> a.gen_discovered s \\<longrightarrow>\n               \\<not> gds_is_empty_stack gds s) \\<and>\n              \\<not> gds_is_break gds s)\n          (\\<lambda>s.\n              if gds_is_empty_stack gds s\n              then SPEC\n                    (\\<lambda>v0.\n                        v0 \\<in> V0 \\<and>\n                        \\<not> gds_is_discovered gds v0 s) \\<bind>\n                   (\\<lambda>v0.\n                       ASSERT (a.pre_new_root v0 s) \\<bind>\n                       (\\<lambda>_. gds_new_root gds v0 s))\n              else ASSERT (a.pre_get_pending s) \\<bind>\n                   (\\<lambda>_.\n                       gds_get_pending gds s \\<bind>\n                       (\\<lambda>(u, Vs, sa).\n                           case Vs of\n                           None \\<Rightarrow>\n                             ASSERT (a.pre_finish u s sa) \\<bind>\n                             (\\<lambda>_. gds_finish gds u sa)\n                           | Some v \\<Rightarrow>\n                               if gds_is_discovered gds v sa\n                               then if gds_is_finished gds v sa\n                                    then ASSERT\n    (a.pre_cross_edge u v s sa) \\<bind>\n   (\\<lambda>_. gds_cross_edge gds u v sa)\n                                    else ASSERT\n    (a.pre_back_edge u v s sa) \\<bind>\n   (\\<lambda>_. gds_back_edge gds u v sa)\n                               else ASSERT (a.pre_discover u v s sa) \\<bind>\n                                    (\\<lambda>_. gds_discover gds u v sa))))\n          s';\n         (V0i \\<subseteq> c.gen_discovered s \\<longrightarrow>\n          \\<not> gds_is_empty_stack gdsi s) \\<and>\n         \\<not> gds_is_break gdsi s;\n         (V0 \\<subseteq> a.gen_discovered s' \\<longrightarrow>\n          \\<not> gds_is_empty_stack gds s') \\<and>\n         \\<not> gds_is_break gds s';\n         nofail\n          (if gds_is_empty_stack gdsi s\n           then SPEC\n                 (\\<lambda>v0.\n                     v0 \\<in> V0i \\<and>\n                     \\<not> gds_is_discovered gdsi v0 s) \\<bind>\n                (\\<lambda>v0. gds_new_root gdsi v0 s)\n           else gds_get_pending gdsi s \\<bind>\n                (\\<lambda>(u, Vs, s).\n                    case Vs of None \\<Rightarrow> gds_finish gdsi u s\n                    | Some v \\<Rightarrow>\n                        if gds_is_discovered gdsi v s\n                        then if gds_is_finished gdsi v s\n                             then gds_cross_edge gdsi u v s\n                             else gds_back_edge gdsi u v s\n                        else gds_discover gdsi u v s));\n         \\<not> gds_is_empty_stack gdsi s; \\<not> gds_is_empty_stack gds s';\n         a.pre_get_pending s';\n         (x, x')\n         \\<in> V \\<times>\\<^sub>r\n               \\<langle>V\\<rangle>option_rel \\<times>\\<^sub>r S;\n         x2 = (x1a, x2a); x' = (x1, x2); x2b = (x1c, x2c); x = (x1b, x2b);\n         x1c = Some xa; x1a = Some x'a;\n         (xa, x'a) \\<in> ?Ra105 s s' x x' x1 x2 x1a x2a x1b x2b x1c x2c;\n         gds_is_discovered gdsi xa x2c; gds_is_discovered gds x'a x2a;\n         gds_is_finished gdsi xa x2c; gds_is_finished gds x'a x2a;\n         a.pre_cross_edge x1 x'a s' x2a\\<rbrakk>\n        \\<Longrightarrow> (xa, x'a) \\<in> V\nA total of 19 subgoals...", "apply simp_all"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>s s'.\n       \\<lbrakk>(s, s') \\<in> S;\n        rwof (gds_init gdsi)\n         (\\<lambda>s.\n             (V0i \\<subseteq> c.gen_discovered s \\<longrightarrow>\n              \\<not> gds_is_empty_stack gdsi s) \\<and>\n             \\<not> gds_is_break gdsi s)\n         (\\<lambda>s.\n             if gds_is_empty_stack gdsi s\n             then SPEC\n                   (\\<lambda>v0.\n                       v0 \\<in> V0i \\<and>\n                       \\<not> gds_is_discovered gdsi v0 s) \\<bind>\n                  (\\<lambda>v0. gds_new_root gdsi v0 s)\n             else gds_get_pending gdsi s \\<bind>\n                  (\\<lambda>(u, Vs, s).\n                      case Vs of None \\<Rightarrow> gds_finish gdsi u s\n                      | Some v \\<Rightarrow>\n                          if gds_is_discovered gdsi v s\n                          then if gds_is_finished gdsi v s\n                               then gds_cross_edge gdsi u v s\n                               else gds_back_edge gdsi u v s\n                          else gds_discover gdsi u v s))\n         s;\n        rwof (gds_init gds)\n         (\\<lambda>s.\n             (V0 \\<subseteq> a.gen_discovered s \\<longrightarrow>\n              \\<not> gds_is_empty_stack gds s) \\<and>\n             \\<not> gds_is_break gds s)\n         (\\<lambda>s.\n             if gds_is_empty_stack gds s\n             then SPEC\n                   (\\<lambda>v0.\n                       v0 \\<in> V0 \\<and>\n                       \\<not> gds_is_discovered gds v0 s) \\<bind>\n                  (\\<lambda>v0.\n                      ASSERT (a.pre_new_root v0 s) \\<bind>\n                      (\\<lambda>_. gds_new_root gds v0 s))\n             else ASSERT (a.pre_get_pending s) \\<bind>\n                  (\\<lambda>_.\n                      gds_get_pending gds s \\<bind>\n                      (\\<lambda>(u, Vs, sa).\n                          case Vs of\n                          None \\<Rightarrow>\n                            ASSERT (a.pre_finish u s sa) \\<bind>\n                            (\\<lambda>_. gds_finish gds u sa)\n                          | Some v \\<Rightarrow>\n                              if gds_is_discovered gds v sa\n                              then if gds_is_finished gds v sa\n                                   then ASSERT\n   (a.pre_cross_edge u v s sa) \\<bind>\n  (\\<lambda>_. gds_cross_edge gds u v sa)\n                                   else ASSERT\n   (a.pre_back_edge u v s sa) \\<bind>\n  (\\<lambda>_. gds_back_edge gds u v sa)\n                              else ASSERT (a.pre_discover u v s sa) \\<bind>\n                                   (\\<lambda>_. gds_discover gds u v sa))))\n         s';\n        (V0i \\<subseteq> c.gen_discovered s \\<longrightarrow>\n         \\<not> gds_is_empty_stack gdsi s) \\<and>\n        \\<not> gds_is_break gdsi s;\n        (V0 \\<subseteq> a.gen_discovered s' \\<longrightarrow>\n         \\<not> gds_is_empty_stack gds s') \\<and>\n        \\<not> gds_is_break gds s';\n        nofail\n         (if gds_is_empty_stack gdsi s\n          then SPEC\n                (\\<lambda>v0.\n                    v0 \\<in> V0i \\<and>\n                    \\<not> gds_is_discovered gdsi v0 s) \\<bind>\n               (\\<lambda>v0. gds_new_root gdsi v0 s)\n          else gds_get_pending gdsi s \\<bind>\n               (\\<lambda>(u, Vs, s).\n                   case Vs of None \\<Rightarrow> gds_finish gdsi u s\n                   | Some v \\<Rightarrow>\n                       if gds_is_discovered gdsi v s\n                       then if gds_is_finished gdsi v s\n                            then gds_cross_edge gdsi u v s\n                            else gds_back_edge gdsi u v s\n                       else gds_discover gdsi u v s))\\<rbrakk>\n       \\<Longrightarrow> gds_is_empty_stack gdsi s =\n                         gds_is_empty_stack gds s'\n 2. \\<And>s s' x x' x1 x2 x1a x2a x1b x2b x1c x2c.\n       \\<lbrakk>(s, s') \\<in> S;\n        rwof (gds_init gdsi)\n         (\\<lambda>s.\n             (V0i \\<subseteq> c.gen_discovered s \\<longrightarrow>\n              \\<not> gds_is_empty_stack gdsi s) \\<and>\n             \\<not> gds_is_break gdsi s)\n         (\\<lambda>s.\n             if gds_is_empty_stack gdsi s\n             then SPEC\n                   (\\<lambda>v0.\n                       v0 \\<in> V0i \\<and>\n                       \\<not> gds_is_discovered gdsi v0 s) \\<bind>\n                  (\\<lambda>v0. gds_new_root gdsi v0 s)\n             else gds_get_pending gdsi s \\<bind>\n                  (\\<lambda>(u, Vs, s).\n                      case Vs of None \\<Rightarrow> gds_finish gdsi u s\n                      | Some v \\<Rightarrow>\n                          if gds_is_discovered gdsi v s\n                          then if gds_is_finished gdsi v s\n                               then gds_cross_edge gdsi u v s\n                               else gds_back_edge gdsi u v s\n                          else gds_discover gdsi u v s))\n         s;\n        rwof (gds_init gds)\n         (\\<lambda>s.\n             (V0 \\<subseteq> a.gen_discovered s \\<longrightarrow>\n              \\<not> gds_is_empty_stack gds s) \\<and>\n             \\<not> gds_is_break gds s)\n         (\\<lambda>s.\n             if gds_is_empty_stack gds s\n             then SPEC\n                   (\\<lambda>v0.\n                       v0 \\<in> V0 \\<and>\n                       \\<not> gds_is_discovered gds v0 s) \\<bind>\n                  (\\<lambda>v0.\n                      ASSERT (a.pre_new_root v0 s) \\<bind>\n                      (\\<lambda>_. gds_new_root gds v0 s))\n             else ASSERT (a.pre_get_pending s) \\<bind>\n                  (\\<lambda>_.\n                      gds_get_pending gds s \\<bind>\n                      (\\<lambda>(u, Vs, sa).\n                          case Vs of\n                          None \\<Rightarrow>\n                            ASSERT (a.pre_finish u s sa) \\<bind>\n                            (\\<lambda>_. gds_finish gds u sa)\n                          | Some v \\<Rightarrow>\n                              if gds_is_discovered gds v sa\n                              then if gds_is_finished gds v sa\n                                   then ASSERT\n   (a.pre_cross_edge u v s sa) \\<bind>\n  (\\<lambda>_. gds_cross_edge gds u v sa)\n                                   else ASSERT\n   (a.pre_back_edge u v s sa) \\<bind>\n  (\\<lambda>_. gds_back_edge gds u v sa)\n                              else ASSERT (a.pre_discover u v s sa) \\<bind>\n                                   (\\<lambda>_. gds_discover gds u v sa))))\n         s';\n        \\<not> gds_is_break gdsi s; \\<not> gds_is_break gds s';\n        nofail\n         (gds_get_pending gdsi s \\<bind>\n          (\\<lambda>(u, Vs, s).\n              case Vs of None \\<Rightarrow> gds_finish gdsi u s\n              | Some v \\<Rightarrow>\n                  if gds_is_discovered gdsi v s\n                  then if gds_is_finished gdsi v s\n                       then gds_cross_edge gdsi u v s\n                       else gds_back_edge gdsi u v s\n                  else gds_discover gdsi u v s));\n        \\<not> gds_is_empty_stack gdsi s; \\<not> gds_is_empty_stack gds s';\n        a.pre_get_pending s';\n        (x1b, x1) \\<in> V \\<and>\n        (x1c, x1a) \\<in> \\<langle>V\\<rangle>option_rel \\<and>\n        (x2c, x2a) \\<in> S;\n        x2 = (x1a, x2a); x' = (x1, x1a, x2a); x2b = (x1c, x2c);\n        x = (x1b, x1c, x2c)\\<rbrakk>\n       \\<Longrightarrow> (x1c, x1a)\n                         \\<in> \\<langle>?Ra105 s s' (x1b, x1c, x2c)\n   (x1, x1a, x2a) x1 (x1a, x2a) x1a x2a x1b (x1c, x2c) x1c\n   x2c\\<rangle>option_rel\n 3. \\<And>s s' x x' x1 x2 x1a x2a x1b x2b x1c x2c xa x'a.\n       \\<lbrakk>(s, s') \\<in> S;\n        rwof (gds_init gdsi)\n         (\\<lambda>s.\n             (V0i \\<subseteq> c.gen_discovered s \\<longrightarrow>\n              \\<not> gds_is_empty_stack gdsi s) \\<and>\n             \\<not> gds_is_break gdsi s)\n         (\\<lambda>s.\n             if gds_is_empty_stack gdsi s\n             then SPEC\n                   (\\<lambda>v0.\n                       v0 \\<in> V0i \\<and>\n                       \\<not> gds_is_discovered gdsi v0 s) \\<bind>\n                  (\\<lambda>v0. gds_new_root gdsi v0 s)\n             else gds_get_pending gdsi s \\<bind>\n                  (\\<lambda>(u, Vs, s).\n                      case Vs of None \\<Rightarrow> gds_finish gdsi u s\n                      | Some v \\<Rightarrow>\n                          if gds_is_discovered gdsi v s\n                          then if gds_is_finished gdsi v s\n                               then gds_cross_edge gdsi u v s\n                               else gds_back_edge gdsi u v s\n                          else gds_discover gdsi u v s))\n         s;\n        rwof (gds_init gds)\n         (\\<lambda>s.\n             (V0 \\<subseteq> a.gen_discovered s \\<longrightarrow>\n              \\<not> gds_is_empty_stack gds s) \\<and>\n             \\<not> gds_is_break gds s)\n         (\\<lambda>s.\n             if gds_is_empty_stack gds s\n             then SPEC\n                   (\\<lambda>v0.\n                       v0 \\<in> V0 \\<and>\n                       \\<not> gds_is_discovered gds v0 s) \\<bind>\n                  (\\<lambda>v0.\n                      ASSERT (a.pre_new_root v0 s) \\<bind>\n                      (\\<lambda>_. gds_new_root gds v0 s))\n             else ASSERT (a.pre_get_pending s) \\<bind>\n                  (\\<lambda>_.\n                      gds_get_pending gds s \\<bind>\n                      (\\<lambda>(u, Vs, sa).\n                          case Vs of\n                          None \\<Rightarrow>\n                            ASSERT (a.pre_finish u s sa) \\<bind>\n                            (\\<lambda>_. gds_finish gds u sa)\n                          | Some v \\<Rightarrow>\n                              if gds_is_discovered gds v sa\n                              then if gds_is_finished gds v sa\n                                   then ASSERT\n   (a.pre_cross_edge u v s sa) \\<bind>\n  (\\<lambda>_. gds_cross_edge gds u v sa)\n                                   else ASSERT\n   (a.pre_back_edge u v s sa) \\<bind>\n  (\\<lambda>_. gds_back_edge gds u v sa)\n                              else ASSERT (a.pre_discover u v s sa) \\<bind>\n                                   (\\<lambda>_. gds_discover gds u v sa))))\n         s';\n        \\<not> gds_is_break gdsi s; \\<not> gds_is_break gds s';\n        nofail\n         (gds_get_pending gdsi s \\<bind>\n          (\\<lambda>(u, Vs, s).\n              case Vs of None \\<Rightarrow> gds_finish gdsi u s\n              | Some v \\<Rightarrow>\n                  if gds_is_discovered gdsi v s\n                  then if gds_is_finished gdsi v s\n                       then gds_cross_edge gdsi u v s\n                       else gds_back_edge gdsi u v s\n                  else gds_discover gdsi u v s));\n        \\<not> gds_is_empty_stack gdsi s; \\<not> gds_is_empty_stack gds s';\n        a.pre_get_pending s';\n        (x1b, x1) \\<in> V \\<and>\n        (xa, x'a) \\<in> V \\<and> (x2c, x2a) \\<in> S;\n        x2 = (Some x'a, x2a); x' = (x1, Some x'a, x2a);\n        x2b = (Some xa, x2c); x = (x1b, Some xa, x2c); x1c = Some xa;\n        x1a = Some x'a;\n        (xa, x'a)\n        \\<in> ?Ra105 s s' (x1b, Some xa, x2c) (x1, Some x'a, x2a) x1\n               (Some x'a, x2a) (Some x'a) x2a x1b (Some xa, x2c) (Some xa)\n               x2c\\<rbrakk>\n       \\<Longrightarrow> gds_is_discovered gdsi xa x2c =\n                         gds_is_discovered gds x'a x2a\n 4. \\<And>s s' x x' x1 x2 x1a x2a x1b x2b x1c x2c xa x'a.\n       \\<lbrakk>(s, s') \\<in> S;\n        rwof (gds_init gdsi)\n         (\\<lambda>s.\n             (V0i \\<subseteq> c.gen_discovered s \\<longrightarrow>\n              \\<not> gds_is_empty_stack gdsi s) \\<and>\n             \\<not> gds_is_break gdsi s)\n         (\\<lambda>s.\n             if gds_is_empty_stack gdsi s\n             then SPEC\n                   (\\<lambda>v0.\n                       v0 \\<in> V0i \\<and>\n                       \\<not> gds_is_discovered gdsi v0 s) \\<bind>\n                  (\\<lambda>v0. gds_new_root gdsi v0 s)\n             else gds_get_pending gdsi s \\<bind>\n                  (\\<lambda>(u, Vs, s).\n                      case Vs of None \\<Rightarrow> gds_finish gdsi u s\n                      | Some v \\<Rightarrow>\n                          if gds_is_discovered gdsi v s\n                          then if gds_is_finished gdsi v s\n                               then gds_cross_edge gdsi u v s\n                               else gds_back_edge gdsi u v s\n                          else gds_discover gdsi u v s))\n         s;\n        rwof (gds_init gds)\n         (\\<lambda>s.\n             (V0 \\<subseteq> a.gen_discovered s \\<longrightarrow>\n              \\<not> gds_is_empty_stack gds s) \\<and>\n             \\<not> gds_is_break gds s)\n         (\\<lambda>s.\n             if gds_is_empty_stack gds s\n             then SPEC\n                   (\\<lambda>v0.\n                       v0 \\<in> V0 \\<and>\n                       \\<not> gds_is_discovered gds v0 s) \\<bind>\n                  (\\<lambda>v0.\n                      ASSERT (a.pre_new_root v0 s) \\<bind>\n                      (\\<lambda>_. gds_new_root gds v0 s))\n             else ASSERT (a.pre_get_pending s) \\<bind>\n                  (\\<lambda>_.\n                      gds_get_pending gds s \\<bind>\n                      (\\<lambda>(u, Vs, sa).\n                          case Vs of\n                          None \\<Rightarrow>\n                            ASSERT (a.pre_finish u s sa) \\<bind>\n                            (\\<lambda>_. gds_finish gds u sa)\n                          | Some v \\<Rightarrow>\n                              if gds_is_discovered gds v sa\n                              then if gds_is_finished gds v sa\n                                   then ASSERT\n   (a.pre_cross_edge u v s sa) \\<bind>\n  (\\<lambda>_. gds_cross_edge gds u v sa)\n                                   else ASSERT\n   (a.pre_back_edge u v s sa) \\<bind>\n  (\\<lambda>_. gds_back_edge gds u v sa)\n                              else ASSERT (a.pre_discover u v s sa) \\<bind>\n                                   (\\<lambda>_. gds_discover gds u v sa))))\n         s';\n        \\<not> gds_is_break gdsi s; \\<not> gds_is_break gds s';\n        nofail\n         (gds_get_pending gdsi s \\<bind>\n          (\\<lambda>(u, Vs, s).\n              case Vs of None \\<Rightarrow> gds_finish gdsi u s\n              | Some v \\<Rightarrow>\n                  if gds_is_discovered gdsi v s\n                  then if gds_is_finished gdsi v s\n                       then gds_cross_edge gdsi u v s\n                       else gds_back_edge gdsi u v s\n                  else gds_discover gdsi u v s));\n        \\<not> gds_is_empty_stack gdsi s; \\<not> gds_is_empty_stack gds s';\n        a.pre_get_pending s';\n        (x1b, x1) \\<in> V \\<and>\n        (xa, x'a) \\<in> V \\<and> (x2c, x2a) \\<in> S;\n        x2 = (Some x'a, x2a); x' = (x1, Some x'a, x2a);\n        x2b = (Some xa, x2c); x = (x1b, Some xa, x2c); x1c = Some xa;\n        x1a = Some x'a;\n        (xa, x'a)\n        \\<in> ?Ra105 s s' (x1b, Some xa, x2c) (x1, Some x'a, x2a) x1\n               (Some x'a, x2a) (Some x'a) x2a x1b (Some xa, x2c) (Some xa)\n               x2c;\n        gds_is_discovered gdsi xa x2c;\n        gds_is_discovered gds x'a x2a\\<rbrakk>\n       \\<Longrightarrow> gds_is_finished gdsi xa x2c =\n                         gds_is_finished gds x'a x2a", "apply ((rule IdD, parametricity) | (auto) [])+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>s'. (s, s') \\<in> S \\<and> a.gen_rwof_assert s'\n\ngoal (1 subgoal):\n 1. (\\<And>s'.\n        \\<lbrakk>(s, s') \\<in> S; a.gen_rwof s'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>s'. (s, s') \\<in> S \\<and> a.gen_rwof_assert s'\n\ngoal (1 subgoal):\n 1. thesis", "unfolding a.gen_rwof_eq_assert[OF NF, symmetric]"], ["proof (prove)\nusing this:\n  \\<exists>s'. (s, s') \\<in> S \\<and> a.gen_rwof s'\n\ngoal (1 subgoal):\n 1. thesis", "by (blast intro: that)"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma gen_step_refine[refine]: \"(si,s)\\<in>S \\<Longrightarrow> c.gen_step si \\<le> \\<Down>S (a.gen_step_assert s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (si, s) \\<in> S \\<Longrightarrow>\n    c.gen_step si \\<le> \\<Down> S (a.gen_step_assert s)", "unfolding c.gen_step_def a.gen_step_assert_def GHOST_elim_Let"], ["proof (prove)\ngoal (1 subgoal):\n 1. (si, s) \\<in> S \\<Longrightarrow>\n    (if gds_is_empty_stack gdsi si\n     then SPEC\n           (\\<lambda>v0.\n               v0 \\<in> V0i \\<and>\n               \\<not> gds_is_discovered gdsi v0 si) \\<bind>\n          (\\<lambda>v0. gds_new_root gdsi v0 si)\n     else gds_get_pending gdsi si \\<bind>\n          (\\<lambda>(u, Vs, s).\n              case Vs of None \\<Rightarrow> gds_finish gdsi u s\n              | Some v \\<Rightarrow>\n                  if gds_is_discovered gdsi v s\n                  then if gds_is_finished gdsi v s\n                       then gds_cross_edge gdsi u v s\n                       else gds_back_edge gdsi u v s\n                  else gds_discover gdsi u v s))\n    \\<le> \\<Down> S\n           (if gds_is_empty_stack gds s\n            then SPEC\n                  (\\<lambda>v0.\n                      v0 \\<in> V0 \\<and>\n                      \\<not> gds_is_discovered gds v0 s) \\<bind>\n                 (\\<lambda>v0.\n                     ASSERT (a.pre_new_root v0 s) \\<bind>\n                     (\\<lambda>_. gds_new_root gds v0 s))\n            else ASSERT (a.pre_get_pending s) \\<bind>\n                 (\\<lambda>_.\n                     gds_get_pending gds s \\<bind>\n                     (\\<lambda>(u, Vs, sa).\n                         case Vs of\n                         None \\<Rightarrow>\n                           ASSERT (a.pre_finish u s sa) \\<bind>\n                           (\\<lambda>_. gds_finish gds u sa)\n                         | Some v \\<Rightarrow>\n                             if gds_is_discovered gds v sa\n                             then if gds_is_finished gds v sa\n                                  then ASSERT\n  (a.pre_cross_edge u v s sa) \\<bind>\n (\\<lambda>_. gds_cross_edge gds u v sa)\n                                  else ASSERT\n  (a.pre_back_edge u v s sa) \\<bind>\n (\\<lambda>_. gds_back_edge gds u v sa)\n                             else ASSERT (a.pre_discover u v s sa) \\<bind>\n                                  (\\<lambda>_. gds_discover gds u v sa))))", "apply (refine_rcg IdD)"], ["proof (prove)\ngoal (19 subgoals):\n 1. (si, s) \\<in> S \\<Longrightarrow>\n    (gds_is_empty_stack gdsi si, gds_is_empty_stack gds s) \\<in> bool_rel\n 2. \\<And>x x' x1 x2 x1a x2a x1b x2b x1c x2c.\n       \\<lbrakk>(si, s) \\<in> S; \\<not> gds_is_empty_stack gdsi si;\n        \\<not> gds_is_empty_stack gds s; a.pre_get_pending s;\n        (x, x')\n        \\<in> V \\<times>\\<^sub>r\n              \\<langle>V\\<rangle>option_rel \\<times>\\<^sub>r S;\n        x2 = (x1a, x2a); x' = (x1, x2); x2b = (x1c, x2c);\n        x = (x1b, x2b)\\<rbrakk>\n       \\<Longrightarrow> (x1c, x1a)\n                         \\<in> \\<langle>?Ra61 x x' x1 x2 x1a x2a x1b x2b x1c\n   x2c\\<rangle>option_rel\n 3. \\<And>x x' x1 x2 x1a x2a x1b x2b x1c x2c.\n       \\<lbrakk>(si, s) \\<in> S; \\<not> gds_is_empty_stack gdsi si;\n        \\<not> gds_is_empty_stack gds s; a.pre_get_pending s;\n        (x, x')\n        \\<in> V \\<times>\\<^sub>r\n              \\<langle>V\\<rangle>option_rel \\<times>\\<^sub>r S;\n        x2 = (x1a, x2a); x' = (x1, x2); x2b = (x1c, x2c); x = (x1b, x2b);\n        x1c = None; x1a = None; a.pre_finish x1 s x2a\\<rbrakk>\n       \\<Longrightarrow> a.pre_finish x1\n                          (?s0.63 x x' x1 x2 x1a x2a x1b x2b x1c x2c) x2a\n 4. \\<And>x x' x1 x2 x1a x2a x1b x2b x1c x2c.\n       \\<lbrakk>(si, s) \\<in> S; \\<not> gds_is_empty_stack gdsi si;\n        \\<not> gds_is_empty_stack gds s; a.pre_get_pending s;\n        (x, x')\n        \\<in> V \\<times>\\<^sub>r\n              \\<langle>V\\<rangle>option_rel \\<times>\\<^sub>r S;\n        x2 = (x1a, x2a); x' = (x1, x2); x2b = (x1c, x2c); x = (x1b, x2b);\n        x1c = None; x1a = None; a.pre_finish x1 s x2a\\<rbrakk>\n       \\<Longrightarrow> (x1b, x1) \\<in> V\n 5. \\<And>x x' x1 x2 x1a x2a x1b x2b x1c x2c.\n       \\<lbrakk>(si, s) \\<in> S; \\<not> gds_is_empty_stack gdsi si;\n        \\<not> gds_is_empty_stack gds s; a.pre_get_pending s;\n        (x, x')\n        \\<in> V \\<times>\\<^sub>r\n              \\<langle>V\\<rangle>option_rel \\<times>\\<^sub>r S;\n        x2 = (x1a, x2a); x' = (x1, x2); x2b = (x1c, x2c); x = (x1b, x2b);\n        x1c = None; x1a = None; a.pre_finish x1 s x2a\\<rbrakk>\n       \\<Longrightarrow> (x2c, x2a) \\<in> S\n 6. \\<And>x x' x1 x2 x1a x2a x1b x2b x1c x2c xa x'a.\n       \\<lbrakk>(si, s) \\<in> S; \\<not> gds_is_empty_stack gdsi si;\n        \\<not> gds_is_empty_stack gds s; a.pre_get_pending s;\n        (x, x')\n        \\<in> V \\<times>\\<^sub>r\n              \\<langle>V\\<rangle>option_rel \\<times>\\<^sub>r S;\n        x2 = (x1a, x2a); x' = (x1, x2); x2b = (x1c, x2c); x = (x1b, x2b);\n        x1c = Some xa; x1a = Some x'a;\n        (xa, x'a) \\<in> ?Ra61 x x' x1 x2 x1a x2a x1b x2b x1c x2c\\<rbrakk>\n       \\<Longrightarrow> (gds_is_discovered gdsi xa x2c,\n                          gds_is_discovered gds x'a x2a)\n                         \\<in> bool_rel\n 7. \\<And>x x' x1 x2 x1a x2a x1b x2b x1c x2c xa x'a.\n       \\<lbrakk>(si, s) \\<in> S; \\<not> gds_is_empty_stack gdsi si;\n        \\<not> gds_is_empty_stack gds s; a.pre_get_pending s;\n        (x, x')\n        \\<in> V \\<times>\\<^sub>r\n              \\<langle>V\\<rangle>option_rel \\<times>\\<^sub>r S;\n        x2 = (x1a, x2a); x' = (x1, x2); x2b = (x1c, x2c); x = (x1b, x2b);\n        x1c = Some xa; x1a = Some x'a;\n        (xa, x'a) \\<in> ?Ra61 x x' x1 x2 x1a x2a x1b x2b x1c x2c;\n        gds_is_discovered gdsi xa x2c;\n        gds_is_discovered gds x'a x2a\\<rbrakk>\n       \\<Longrightarrow> (gds_is_finished gdsi xa x2c,\n                          gds_is_finished gds x'a x2a)\n                         \\<in> bool_rel\n 8. \\<And>x x' x1 x2 x1a x2a x1b x2b x1c x2c xa x'a.\n       \\<lbrakk>(si, s) \\<in> S; \\<not> gds_is_empty_stack gdsi si;\n        \\<not> gds_is_empty_stack gds s; a.pre_get_pending s;\n        (x, x')\n        \\<in> V \\<times>\\<^sub>r\n              \\<langle>V\\<rangle>option_rel \\<times>\\<^sub>r S;\n        x2 = (x1a, x2a); x' = (x1, x2); x2b = (x1c, x2c); x = (x1b, x2b);\n        x1c = Some xa; x1a = Some x'a;\n        (xa, x'a) \\<in> ?Ra61 x x' x1 x2 x1a x2a x1b x2b x1c x2c;\n        gds_is_discovered gdsi xa x2c; gds_is_discovered gds x'a x2a;\n        gds_is_finished gdsi xa x2c; gds_is_finished gds x'a x2a;\n        a.pre_cross_edge x1 x'a s x2a\\<rbrakk>\n       \\<Longrightarrow> a.pre_cross_edge x1 x'a\n                          (?s0.69 x x' x1 x2 x1a x2a x1b x2b x1c x2c xa x'a)\n                          x2a\n 9. \\<And>x x' x1 x2 x1a x2a x1b x2b x1c x2c xa x'a.\n       \\<lbrakk>(si, s) \\<in> S; \\<not> gds_is_empty_stack gdsi si;\n        \\<not> gds_is_empty_stack gds s; a.pre_get_pending s;\n        (x, x')\n        \\<in> V \\<times>\\<^sub>r\n              \\<langle>V\\<rangle>option_rel \\<times>\\<^sub>r S;\n        x2 = (x1a, x2a); x' = (x1, x2); x2b = (x1c, x2c); x = (x1b, x2b);\n        x1c = Some xa; x1a = Some x'a;\n        (xa, x'a) \\<in> ?Ra61 x x' x1 x2 x1a x2a x1b x2b x1c x2c;\n        gds_is_discovered gdsi xa x2c; gds_is_discovered gds x'a x2a;\n        gds_is_finished gdsi xa x2c; gds_is_finished gds x'a x2a;\n        a.pre_cross_edge x1 x'a s x2a\\<rbrakk>\n       \\<Longrightarrow> (x1b, x1) \\<in> V\n 10. \\<And>x x' x1 x2 x1a x2a x1b x2b x1c x2c xa x'a.\n        \\<lbrakk>(si, s) \\<in> S; \\<not> gds_is_empty_stack gdsi si;\n         \\<not> gds_is_empty_stack gds s; a.pre_get_pending s;\n         (x, x')\n         \\<in> V \\<times>\\<^sub>r\n               \\<langle>V\\<rangle>option_rel \\<times>\\<^sub>r S;\n         x2 = (x1a, x2a); x' = (x1, x2); x2b = (x1c, x2c); x = (x1b, x2b);\n         x1c = Some xa; x1a = Some x'a;\n         (xa, x'a) \\<in> ?Ra61 x x' x1 x2 x1a x2a x1b x2b x1c x2c;\n         gds_is_discovered gdsi xa x2c; gds_is_discovered gds x'a x2a;\n         gds_is_finished gdsi xa x2c; gds_is_finished gds x'a x2a;\n         a.pre_cross_edge x1 x'a s x2a\\<rbrakk>\n        \\<Longrightarrow> (xa, x'a) \\<in> V\nA total of 19 subgoals...", "apply simp_all"], ["proof (prove)\ngoal (4 subgoals):\n 1. (si, s) \\<in> S \\<Longrightarrow>\n    gds_is_empty_stack gdsi si = gds_is_empty_stack gds s\n 2. \\<And>x x' x1 x2 x1a x2a x1b x2b x1c x2c.\n       \\<lbrakk>(si, s) \\<in> S; \\<not> gds_is_empty_stack gdsi si;\n        \\<not> gds_is_empty_stack gds s; a.pre_get_pending s;\n        (x1b, x1) \\<in> V \\<and>\n        (x1c, x1a) \\<in> \\<langle>V\\<rangle>option_rel \\<and>\n        (x2c, x2a) \\<in> S;\n        x2 = (x1a, x2a); x' = (x1, x1a, x2a); x2b = (x1c, x2c);\n        x = (x1b, x1c, x2c)\\<rbrakk>\n       \\<Longrightarrow> (x1c, x1a)\n                         \\<in> \\<langle>?Ra61 (x1b, x1c, x2c) (x1, x1a, x2a)\n   x1 (x1a, x2a) x1a x2a x1b (x1c, x2c) x1c x2c\\<rangle>option_rel\n 3. \\<And>x x' x1 x2 x1a x2a x1b x2b x1c x2c xa x'a.\n       \\<lbrakk>(si, s) \\<in> S; \\<not> gds_is_empty_stack gdsi si;\n        \\<not> gds_is_empty_stack gds s; a.pre_get_pending s;\n        (x1b, x1) \\<in> V \\<and>\n        (xa, x'a) \\<in> V \\<and> (x2c, x2a) \\<in> S;\n        x2 = (Some x'a, x2a); x' = (x1, Some x'a, x2a);\n        x2b = (Some xa, x2c); x = (x1b, Some xa, x2c); x1c = Some xa;\n        x1a = Some x'a;\n        (xa, x'a)\n        \\<in> ?Ra61 (x1b, Some xa, x2c) (x1, Some x'a, x2a) x1\n               (Some x'a, x2a) (Some x'a) x2a x1b (Some xa, x2c) (Some xa)\n               x2c\\<rbrakk>\n       \\<Longrightarrow> gds_is_discovered gdsi xa x2c =\n                         gds_is_discovered gds x'a x2a\n 4. \\<And>x x' x1 x2 x1a x2a x1b x2b x1c x2c xa x'a.\n       \\<lbrakk>(si, s) \\<in> S; \\<not> gds_is_empty_stack gdsi si;\n        \\<not> gds_is_empty_stack gds s; a.pre_get_pending s;\n        (x1b, x1) \\<in> V \\<and>\n        (xa, x'a) \\<in> V \\<and> (x2c, x2a) \\<in> S;\n        x2 = (Some x'a, x2a); x' = (x1, Some x'a, x2a);\n        x2b = (Some xa, x2c); x = (x1b, Some xa, x2c); x1c = Some xa;\n        x1a = Some x'a;\n        (xa, x'a)\n        \\<in> ?Ra61 (x1b, Some xa, x2c) (x1, Some x'a, x2a) x1\n               (Some x'a, x2a) (Some x'a) x2a x1b (Some xa, x2c) (Some xa)\n               x2c;\n        gds_is_discovered gdsi xa x2c;\n        gds_is_discovered gds x'a x2a\\<rbrakk>\n       \\<Longrightarrow> gds_is_finished gdsi xa x2c =\n                         gds_is_finished gds x'a x2a", "apply ((rule IdD, parametricity) | (auto) [])+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma gen_dfs_refine[refine]: \"c.gen_dfs \\<le> \\<Down>S a.gen_dfs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c.gen_dfs \\<le> \\<Down> S a.gen_dfs", "unfolding c.gen_dfs_def a.gen_dfs_eq_assert[unfolded a.gen_dfs_assert_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. gds_init gdsi \\<bind> WHILE c.gen_cond c.gen_step\n    \\<le> \\<Down> S\n           (gds_init gds \\<bind> WHILE a.gen_cond a.gen_step_assert)", "apply refine_rcg"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x x' xa x'a.\n       \\<lbrakk>(x, x') \\<in> S; (xa, x'a) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> c.gen_cond xa = a.gen_cond x'a", "unfolding c.gen_cond_def a.gen_cond_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x x' xa x'a.\n       \\<lbrakk>(x, x') \\<in> S; (xa, x'a) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> ((V0i\n                           \\<subseteq> c.gen_discovered xa \\<longrightarrow>\n                           \\<not> gds_is_empty_stack gdsi xa) \\<and>\n                          \\<not> gds_is_break gdsi xa) =\n                         ((V0 \\<subseteq> a.gen_discovered\n     x'a \\<longrightarrow>\n                           \\<not> gds_is_empty_stack gds x'a) \\<and>\n                          \\<not> gds_is_break gds x'a)", "apply (rule IdD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x x' xa x'a.\n       \\<lbrakk>(x, x') \\<in> S; (xa, x'a) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> ((V0i\n                           \\<subseteq> c.gen_discovered xa \\<longrightarrow>\n                           \\<not> gds_is_empty_stack gdsi xa) \\<and>\n                          \\<not> gds_is_break gdsi xa,\n                          (V0 \\<subseteq> a.gen_discovered\n     x'a \\<longrightarrow>\n                           \\<not> gds_is_empty_stack gds x'a) \\<and>\n                          \\<not> gds_is_break gds x'a)\n                         \\<in> bool_rel", "apply (simp only: subset_Collect_conv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x x' xa x'a.\n       \\<lbrakk>(x, x') \\<in> S; (xa, x'a) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> (((\\<forall>x\\<in>V0i.\n                               gds_is_discovered gdsi x\n                                xa) \\<longrightarrow>\n                           \\<not> gds_is_empty_stack gdsi xa) \\<and>\n                          \\<not> gds_is_break gdsi xa,\n                          ((\\<forall>x\\<in>V0.\n                               gds_is_discovered gds x\n                                x'a) \\<longrightarrow>\n                           \\<not> gds_is_empty_stack gds x'a) \\<and>\n                          \\<not> gds_is_break gds x'a)\n                         \\<in> bool_rel", "apply parametricity"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma gen_dfsT_refine[refine]: \"c.gen_dfsT \\<le> \\<Down>S a.gen_dfsT\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c.gen_dfsT \\<le> \\<Down> S a.gen_dfsT", "unfolding c.gen_dfsT_def a.gen_dfsT_eq_assert[unfolded a.gen_dfsT_assert_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. gds_init gdsi \\<bind> WHILE\\<^sub>T c.gen_cond c.gen_step\n    \\<le> \\<Down> S\n           (gds_init gds \\<bind> WHILE\\<^sub>T a.gen_cond a.gen_step_assert)", "apply refine_rcg"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x x' xa x'a.\n       \\<lbrakk>(x, x') \\<in> S; (xa, x'a) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> c.gen_cond xa = a.gen_cond x'a", "unfolding c.gen_cond_def a.gen_cond_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x x' xa x'a.\n       \\<lbrakk>(x, x') \\<in> S; (xa, x'a) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> ((V0i\n                           \\<subseteq> c.gen_discovered xa \\<longrightarrow>\n                           \\<not> gds_is_empty_stack gdsi xa) \\<and>\n                          \\<not> gds_is_break gdsi xa) =\n                         ((V0 \\<subseteq> a.gen_discovered\n     x'a \\<longrightarrow>\n                           \\<not> gds_is_empty_stack gds x'a) \\<and>\n                          \\<not> gds_is_break gds x'a)", "apply (rule IdD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x x' xa x'a.\n       \\<lbrakk>(x, x') \\<in> S; (xa, x'a) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> ((V0i\n                           \\<subseteq> c.gen_discovered xa \\<longrightarrow>\n                           \\<not> gds_is_empty_stack gdsi xa) \\<and>\n                          \\<not> gds_is_break gdsi xa,\n                          (V0 \\<subseteq> a.gen_discovered\n     x'a \\<longrightarrow>\n                           \\<not> gds_is_empty_stack gds x'a) \\<and>\n                          \\<not> gds_is_break gds x'a)\n                         \\<in> bool_rel", "apply (simp only: subset_Collect_conv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x x' xa x'a.\n       \\<lbrakk>(x, x') \\<in> S; (xa, x'a) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> (((\\<forall>x\\<in>V0i.\n                               gds_is_discovered gdsi x\n                                xa) \\<longrightarrow>\n                           \\<not> gds_is_empty_stack gdsi xa) \\<and>\n                          \\<not> gds_is_break gdsi xa,\n                          ((\\<forall>x\\<in>V0.\n                               gds_is_discovered gds x\n                                x'a) \\<longrightarrow>\n                           \\<not> gds_is_empty_stack gds x'a) \\<and>\n                          \\<not> gds_is_break gds x'a)\n                         \\<in> bool_rel", "apply parametricity"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "(* Locale that states refinement of basic operations, without making \n  assumptions on parameterization *)"], ["", "locale gbs_refinement =\n  c: gen_param_dfs gbsi parami upd_exti V0i +\n  a: gen_param_dfs gbs param upd_ext V0\n  for gbsi parami upd_exti V0i gbs param upd_ext V0 +\n  fixes V S ES\n  assumes BIJV: \"bijective V\"\n  assumes V0_param[param]: \"(V0i,V0)\\<in>\\<langle>V\\<rangle>set_rel\"\n\n  assumes is_discovered_param[param]: \n    \"(gbs_is_discovered gbsi,gbs_is_discovered gbs)\\<in>V\\<rightarrow>S\\<rightarrow>bool_rel\"\n\n  assumes is_finished_param[param]: \n    \"(gbs_is_finished gbsi,gbs_is_finished gbs)\\<in>V\\<rightarrow>S\\<rightarrow>bool_rel\"\n\n  assumes is_empty_stack_param[param]:\n    \"(gbs_is_empty_stack gbsi,gbs_is_empty_stack gbs)\\<in>S\\<rightarrow>bool_rel\"\n\n  assumes is_break_param[param]:\n    \"(is_break parami,is_break param)\\<in>S\\<rightarrow>bool_rel\"\n\n  assumes gbs_init_refine[refine]: \"(ei, e) \\<in> ES \\<Longrightarrow> gbs_init gbsi ei \\<le> \\<Down> S (gbs_init gbs e)\"\n\n  assumes gbs_new_root_refine[refine]:\n    \"\\<lbrakk>a.pre_new_root v0 s; (v0i, v0) \\<in> V; (si, s) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> gbs_new_root gbsi v0i si \\<le> \\<Down> S (gbs_new_root gbs v0 s)\"\n\n  assumes gbs_get_pending_refine[refine]:\n    \"\\<lbrakk>a.pre_get_pending s; (si, s) \\<in> S\\<rbrakk>\n            \\<Longrightarrow> gbs_get_pending gbsi si\n                \\<le> \\<Down> (V \\<times>\\<^sub>r \\<langle>V\\<rangle>option_rel \\<times>\\<^sub>r S) (gbs_get_pending gbs s)\"\n\n  assumes gbs_finish_refine[refine]:\n    \"\\<lbrakk>a.pre_finish v s0 s; (vi, v) \\<in> V; (si, s) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> gbs_finish gbsi vi si \\<le> \\<Down> S (gbs_finish gbs v s)\"\n\n  assumes gbs_cross_edge_refine[refine]:\n    \"\\<lbrakk>a.pre_cross_edge u v s0 s; (ui, u) \\<in> V; (vi, v) \\<in> V; (si, s) \\<in> S\\<rbrakk>\n      \\<Longrightarrow> gbs_cross_edge gbsi ui vi si \\<le> \\<Down> S (gbs_cross_edge gbs u v s)\"\n\n  assumes gbs_back_edge_refine[refine]:\n    \"\\<lbrakk>a.pre_back_edge u v s0 s; (ui, u) \\<in> V; (vi, v) \\<in> V; (si, s) \\<in> S\\<rbrakk>\n      \\<Longrightarrow> gbs_back_edge gbsi ui vi si \\<le> \\<Down> S (gbs_back_edge gbs u v s)\"\n\n  assumes gbs_discover_refine[refine]:\n    \"\\<lbrakk>a.pre_discover u v s0 s; (ui, u) \\<in> V; (vi, v) \\<in> V; (si, s) \\<in> S\\<rbrakk>\n      \\<Longrightarrow> gbs_discover gbsi ui vi si \\<le> \\<Down> S (gbs_discover gbs u v s)\""], ["", "(* Locale that states refinement of parameterization, without making\n  assumptions on basic operations *)"], ["", "locale param_refinement =\n  c: gen_param_dfs gbsi parami upd_exti V0i +\n  a: gen_param_dfs gbs param upd_ext V0\n  for gbsi parami upd_exti V0i gbs param upd_ext V0 +\n  fixes V S ES\n  assumes upd_ext_param[param]: \"(upd_exti, upd_ext)\\<in>(ES \\<rightarrow> ES) \\<rightarrow> S \\<rightarrow> S\"\n\n  assumes on_init_refine[refine]: \"on_init parami \\<le> \\<Down> ES (on_init param)\"\n\n  assumes is_break_param[param]: \n    \"(is_break parami, is_break param) \\<in> S \\<rightarrow> bool_rel\"\n\n  assumes on_new_root_refine[refine]:\n    \"\\<lbrakk>a.pre_new_root v0 s; (v0i, v0) \\<in> V; (si, s) \\<in> S;\n        (si', s') \\<in> S; nf_inres (gbs_new_root gbs v0 s) s'\\<rbrakk>\n       \\<Longrightarrow> on_new_root parami v0i si' \\<le> \\<Down> ES (on_new_root param v0 s')\"\n\n  assumes on_finish_refine[refine]:\n    \"\\<lbrakk>a.pre_finish v s0 s; (vi, v) \\<in> V; (si, s) \\<in> S; (si', s') \\<in> S;\n        nf_inres (gbs_finish gbs v s) s'\\<rbrakk>\n       \\<Longrightarrow> on_finish parami vi si' \\<le> \\<Down> ES (on_finish param v s')\"\n\n  assumes on_cross_edge_refine[refine]:\n    \"\\<lbrakk>a.pre_cross_edge u v s0 s; (ui, u) \\<in> V; (vi, v) \\<in> V; (si, s) \\<in> S;\n        (si', s') \\<in> S; nf_inres (gbs_cross_edge gbs u v s) s'\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge parami ui vi si' \\<le> \\<Down> ES (on_cross_edge param u v s')\"\n\n  assumes on_back_edge_refine[refine]:\n    \"\\<lbrakk>a.pre_back_edge u v s0 s; (ui, u) \\<in> V; (vi, v) \\<in> V; (si, s) \\<in> S;\n        (si', s') \\<in> S; nf_inres (gbs_back_edge gbs u v s) s'\\<rbrakk>\n       \\<Longrightarrow> on_back_edge parami ui vi si' \\<le> \\<Down> ES (on_back_edge param u v s')\"\n\n  assumes on_discover_refine[refine]:\n    \"\\<lbrakk>a.pre_discover u v s0 s; (ui, u) \\<in> V; (vi, v) \\<in> V; (si, s) \\<in> S;\n        (si', s') \\<in> S; nf_inres (gbs_discover gbs u v s) s'\\<rbrakk>\n       \\<Longrightarrow> on_discover parami ui vi si' \\<le> \\<Down> ES (on_discover param u v s')\""], ["", "locale gen_param_dfs_refine_defs =\n  c: gen_param_dfs_defs gbsi parami upd_exti V0i +\n  a: gen_param_dfs_defs gbs param upd_ext V0\n  for gbsi parami upd_exti V0i gbs param upd_ext V0\nbegin"], ["", "sublocale gen_dfs_refine_defs c.gds V0i a.gds V0"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "end"], ["", "locale gen_param_dfs_refine =\n  gbs_refinement where V=V and S=S and ES=ES \n+ param_refinement where V=V and S=S and ES=ES\n+ gen_param_dfs_refine_defs\n  for V :: \"('vi\\<times>'v) set\" and S:: \"('si\\<times>'s) set\" and ES :: \"('esi\\<times>'es) set\"\nbegin"], ["", "sublocale gen_dfs_refine c.gds V0i a.gds V0 V S"], ["proof (prove)\ngoal (1 subgoal):\n 1. gen_dfs_refine c.gds V0i a.gds V0 V S", "apply unfold_locales"], ["proof (prove)\ngoal (13 subgoals):\n 1. bijective V\n 2. (V0i, V0) \\<in> \\<langle>V\\<rangle>set_rel\n 3. (gds_is_discovered c.gds, gds_is_discovered a.gds)\n    \\<in> V \\<rightarrow> S \\<rightarrow> bool_rel\n 4. (gds_is_finished c.gds, gds_is_finished a.gds)\n    \\<in> V \\<rightarrow> S \\<rightarrow> bool_rel\n 5. (gds_is_empty_stack c.gds, gds_is_empty_stack a.gds)\n    \\<in> S \\<rightarrow> bool_rel\n 6. (gds_is_break c.gds, gds_is_break a.gds) \\<in> S \\<rightarrow> bool_rel\n 7. gds_init c.gds \\<le> \\<Down> S (gds_init a.gds)\n 8. \\<And>v0 s v0i si.\n       \\<lbrakk>a.pre_new_root v0 s; (v0i, v0) \\<in> V;\n        (si, s) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> gds_new_root c.gds v0i si\n                         \\<le> \\<Down> S (gds_new_root a.gds v0 s)\n 9. \\<And>s si.\n       \\<lbrakk>a.pre_get_pending s; (si, s) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> gds_get_pending c.gds si\n                         \\<le> \\<Down>\n                                (V \\<times>\\<^sub>r\n                                 \\<langle>V\\<rangle>option_rel \\<times>\\<^sub>r\n                                 S)\n                                (gds_get_pending a.gds s)\n 10. \\<And>v s0 s vi si.\n        \\<lbrakk>a.pre_finish v s0 s; (vi, v) \\<in> V;\n         (si, s) \\<in> S\\<rbrakk>\n        \\<Longrightarrow> gds_finish c.gds vi si\n                          \\<le> \\<Down> S (gds_finish a.gds v s)\nA total of 13 subgoals...", "apply (simp_all add: BIJV V0_param a.do_action_defs c.do_action_defs)"], ["proof (prove)\ngoal (11 subgoals):\n 1. (gbs_is_discovered gbsi, gbs_is_discovered gbs)\n    \\<in> V \\<rightarrow> S \\<rightarrow> bool_rel\n 2. (gbs_is_finished gbsi, gbs_is_finished gbs)\n    \\<in> V \\<rightarrow> S \\<rightarrow> bool_rel\n 3. (gbs_is_empty_stack gbsi, gbs_is_empty_stack gbs)\n    \\<in> S \\<rightarrow> bool_rel\n 4. (is_break parami, is_break param) \\<in> S \\<rightarrow> bool_rel\n 5. on_init parami \\<bind> gbs_init gbsi\n    \\<le> \\<Down> S (on_init param \\<bind> gbs_init gbs)\n 6. \\<And>v0 s v0i si.\n       \\<lbrakk>a.pre_new_root v0 s; (v0i, v0) \\<in> V;\n        (si, s) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> gbs_new_root gbsi v0i si \\<bind>\n                         (\\<lambda>s.\n                             on_new_root parami v0i s \\<bind>\n                             (\\<lambda>e.\n                                 RETURN (upd_exti (\\<lambda>_. e) s)))\n                         \\<le> \\<Down> S\n                                (gbs_new_root gbs v0 s \\<bind>\n                                 (\\<lambda>s.\n                                     on_new_root param v0 s \\<bind>\n                                     (\\<lambda>e.\n   RETURN (upd_ext (\\<lambda>_. e) s))))\n 7. \\<And>s si.\n       \\<lbrakk>a.pre_get_pending s; (si, s) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> gbs_get_pending gbsi si\n                         \\<le> \\<Down>\n                                (V \\<times>\\<^sub>r\n                                 \\<langle>V\\<rangle>option_rel \\<times>\\<^sub>r\n                                 S)\n                                (gbs_get_pending gbs s)\n 8. \\<And>v s0 s vi si.\n       \\<lbrakk>a.pre_finish v s0 s; (vi, v) \\<in> V;\n        (si, s) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> gbs_finish gbsi vi si \\<bind>\n                         (\\<lambda>s.\n                             on_finish parami vi s \\<bind>\n                             (\\<lambda>e.\n                                 RETURN (upd_exti (\\<lambda>_. e) s)))\n                         \\<le> \\<Down> S\n                                (gbs_finish gbs v s \\<bind>\n                                 (\\<lambda>s.\n                                     on_finish param v s \\<bind>\n                                     (\\<lambda>e.\n   RETURN (upd_ext (\\<lambda>_. e) s))))\n 9. \\<And>u v s0 s ui vi si.\n       \\<lbrakk>a.pre_cross_edge u v s0 s; (ui, u) \\<in> V; (vi, v) \\<in> V;\n        (si, s) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> gbs_cross_edge gbsi ui vi si \\<bind>\n                         (\\<lambda>s.\n                             on_cross_edge parami ui vi s \\<bind>\n                             (\\<lambda>e.\n                                 RETURN (upd_exti (\\<lambda>_. e) s)))\n                         \\<le> \\<Down> S\n                                (gbs_cross_edge gbs u v s \\<bind>\n                                 (\\<lambda>s.\n                                     on_cross_edge param u v s \\<bind>\n                                     (\\<lambda>e.\n   RETURN (upd_ext (\\<lambda>_. e) s))))\n 10. \\<And>u v s0 s ui vi si.\n        \\<lbrakk>a.pre_back_edge u v s0 s; (ui, u) \\<in> V; (vi, v) \\<in> V;\n         (si, s) \\<in> S\\<rbrakk>\n        \\<Longrightarrow> gbs_back_edge gbsi ui vi si \\<bind>\n                          (\\<lambda>s.\n                              on_back_edge parami ui vi s \\<bind>\n                              (\\<lambda>e.\n                                  RETURN (upd_exti (\\<lambda>_. e) s)))\n                          \\<le> \\<Down> S\n                                 (gbs_back_edge gbs u v s \\<bind>\n                                  (\\<lambda>s.\non_back_edge param u v s \\<bind>\n(\\<lambda>e. RETURN (upd_ext (\\<lambda>_. e) s))))\nA total of 11 subgoals...", "apply (parametricity+) [4]"], ["proof (prove)\ngoal (7 subgoals):\n 1. on_init parami \\<bind> gbs_init gbsi\n    \\<le> \\<Down> S (on_init param \\<bind> gbs_init gbs)\n 2. \\<And>v0 s v0i si.\n       \\<lbrakk>a.pre_new_root v0 s; (v0i, v0) \\<in> V;\n        (si, s) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> gbs_new_root gbsi v0i si \\<bind>\n                         (\\<lambda>s.\n                             on_new_root parami v0i s \\<bind>\n                             (\\<lambda>e.\n                                 RETURN (upd_exti (\\<lambda>_. e) s)))\n                         \\<le> \\<Down> S\n                                (gbs_new_root gbs v0 s \\<bind>\n                                 (\\<lambda>s.\n                                     on_new_root param v0 s \\<bind>\n                                     (\\<lambda>e.\n   RETURN (upd_ext (\\<lambda>_. e) s))))\n 3. \\<And>s si.\n       \\<lbrakk>a.pre_get_pending s; (si, s) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> gbs_get_pending gbsi si\n                         \\<le> \\<Down>\n                                (V \\<times>\\<^sub>r\n                                 \\<langle>V\\<rangle>option_rel \\<times>\\<^sub>r\n                                 S)\n                                (gbs_get_pending gbs s)\n 4. \\<And>v s0 s vi si.\n       \\<lbrakk>a.pre_finish v s0 s; (vi, v) \\<in> V;\n        (si, s) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> gbs_finish gbsi vi si \\<bind>\n                         (\\<lambda>s.\n                             on_finish parami vi s \\<bind>\n                             (\\<lambda>e.\n                                 RETURN (upd_exti (\\<lambda>_. e) s)))\n                         \\<le> \\<Down> S\n                                (gbs_finish gbs v s \\<bind>\n                                 (\\<lambda>s.\n                                     on_finish param v s \\<bind>\n                                     (\\<lambda>e.\n   RETURN (upd_ext (\\<lambda>_. e) s))))\n 5. \\<And>u v s0 s ui vi si.\n       \\<lbrakk>a.pre_cross_edge u v s0 s; (ui, u) \\<in> V; (vi, v) \\<in> V;\n        (si, s) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> gbs_cross_edge gbsi ui vi si \\<bind>\n                         (\\<lambda>s.\n                             on_cross_edge parami ui vi s \\<bind>\n                             (\\<lambda>e.\n                                 RETURN (upd_exti (\\<lambda>_. e) s)))\n                         \\<le> \\<Down> S\n                                (gbs_cross_edge gbs u v s \\<bind>\n                                 (\\<lambda>s.\n                                     on_cross_edge param u v s \\<bind>\n                                     (\\<lambda>e.\n   RETURN (upd_ext (\\<lambda>_. e) s))))\n 6. \\<And>u v s0 s ui vi si.\n       \\<lbrakk>a.pre_back_edge u v s0 s; (ui, u) \\<in> V; (vi, v) \\<in> V;\n        (si, s) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> gbs_back_edge gbsi ui vi si \\<bind>\n                         (\\<lambda>s.\n                             on_back_edge parami ui vi s \\<bind>\n                             (\\<lambda>e.\n                                 RETURN (upd_exti (\\<lambda>_. e) s)))\n                         \\<le> \\<Down> S\n                                (gbs_back_edge gbs u v s \\<bind>\n                                 (\\<lambda>s.\n                                     on_back_edge param u v s \\<bind>\n                                     (\\<lambda>e.\n   RETURN (upd_ext (\\<lambda>_. e) s))))\n 7. \\<And>u v s0 s ui vi si.\n       \\<lbrakk>a.pre_discover u v s0 s; (ui, u) \\<in> V; (vi, v) \\<in> V;\n        (si, s) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> gbs_discover gbsi ui vi si \\<bind>\n                         (\\<lambda>s.\n                             on_discover parami ui vi s \\<bind>\n                             (\\<lambda>e.\n                                 RETURN (upd_exti (\\<lambda>_. e) s)))\n                         \\<le> \\<Down> S\n                                (gbs_discover gbs u v s \\<bind>\n                                 (\\<lambda>s.\n                                     on_discover param u v s \\<bind>\n                                     (\\<lambda>e.\n   RETURN (upd_ext (\\<lambda>_. e) s))))", "apply refine_rcg"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>v0 s v0i si.\n       \\<lbrakk>a.pre_new_root v0 s; (v0i, v0) \\<in> V;\n        (si, s) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> gbs_new_root gbsi v0i si \\<bind>\n                         (\\<lambda>s.\n                             on_new_root parami v0i s \\<bind>\n                             (\\<lambda>e.\n                                 RETURN (upd_exti (\\<lambda>_. e) s)))\n                         \\<le> \\<Down> S\n                                (gbs_new_root gbs v0 s \\<bind>\n                                 (\\<lambda>s.\n                                     on_new_root param v0 s \\<bind>\n                                     (\\<lambda>e.\n   RETURN (upd_ext (\\<lambda>_. e) s))))\n 2. \\<And>s si.\n       \\<lbrakk>a.pre_get_pending s; (si, s) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> gbs_get_pending gbsi si\n                         \\<le> \\<Down>\n                                (V \\<times>\\<^sub>r\n                                 \\<langle>V\\<rangle>option_rel \\<times>\\<^sub>r\n                                 S)\n                                (gbs_get_pending gbs s)\n 3. \\<And>v s0 s vi si.\n       \\<lbrakk>a.pre_finish v s0 s; (vi, v) \\<in> V;\n        (si, s) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> gbs_finish gbsi vi si \\<bind>\n                         (\\<lambda>s.\n                             on_finish parami vi s \\<bind>\n                             (\\<lambda>e.\n                                 RETURN (upd_exti (\\<lambda>_. e) s)))\n                         \\<le> \\<Down> S\n                                (gbs_finish gbs v s \\<bind>\n                                 (\\<lambda>s.\n                                     on_finish param v s \\<bind>\n                                     (\\<lambda>e.\n   RETURN (upd_ext (\\<lambda>_. e) s))))\n 4. \\<And>u v s0 s ui vi si.\n       \\<lbrakk>a.pre_cross_edge u v s0 s; (ui, u) \\<in> V; (vi, v) \\<in> V;\n        (si, s) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> gbs_cross_edge gbsi ui vi si \\<bind>\n                         (\\<lambda>s.\n                             on_cross_edge parami ui vi s \\<bind>\n                             (\\<lambda>e.\n                                 RETURN (upd_exti (\\<lambda>_. e) s)))\n                         \\<le> \\<Down> S\n                                (gbs_cross_edge gbs u v s \\<bind>\n                                 (\\<lambda>s.\n                                     on_cross_edge param u v s \\<bind>\n                                     (\\<lambda>e.\n   RETURN (upd_ext (\\<lambda>_. e) s))))\n 5. \\<And>u v s0 s ui vi si.\n       \\<lbrakk>a.pre_back_edge u v s0 s; (ui, u) \\<in> V; (vi, v) \\<in> V;\n        (si, s) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> gbs_back_edge gbsi ui vi si \\<bind>\n                         (\\<lambda>s.\n                             on_back_edge parami ui vi s \\<bind>\n                             (\\<lambda>e.\n                                 RETURN (upd_exti (\\<lambda>_. e) s)))\n                         \\<le> \\<Down> S\n                                (gbs_back_edge gbs u v s \\<bind>\n                                 (\\<lambda>s.\n                                     on_back_edge param u v s \\<bind>\n                                     (\\<lambda>e.\n   RETURN (upd_ext (\\<lambda>_. e) s))))\n 6. \\<And>u v s0 s ui vi si.\n       \\<lbrakk>a.pre_discover u v s0 s; (ui, u) \\<in> V; (vi, v) \\<in> V;\n        (si, s) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> gbs_discover gbsi ui vi si \\<bind>\n                         (\\<lambda>s.\n                             on_discover parami ui vi s \\<bind>\n                             (\\<lambda>e.\n                                 RETURN (upd_exti (\\<lambda>_. e) s)))\n                         \\<le> \\<Down> S\n                                (gbs_discover gbs u v s \\<bind>\n                                 (\\<lambda>s.\n                                     on_discover param u v s \\<bind>\n                                     (\\<lambda>e.\n   RETURN (upd_ext (\\<lambda>_. e) s))))", "apply (refine_rcg bind_refine_abs', assumption+, parametricity) []"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>s si.\n       \\<lbrakk>a.pre_get_pending s; (si, s) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> gbs_get_pending gbsi si\n                         \\<le> \\<Down>\n                                (V \\<times>\\<^sub>r\n                                 \\<langle>V\\<rangle>option_rel \\<times>\\<^sub>r\n                                 S)\n                                (gbs_get_pending gbs s)\n 2. \\<And>v s0 s vi si.\n       \\<lbrakk>a.pre_finish v s0 s; (vi, v) \\<in> V;\n        (si, s) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> gbs_finish gbsi vi si \\<bind>\n                         (\\<lambda>s.\n                             on_finish parami vi s \\<bind>\n                             (\\<lambda>e.\n                                 RETURN (upd_exti (\\<lambda>_. e) s)))\n                         \\<le> \\<Down> S\n                                (gbs_finish gbs v s \\<bind>\n                                 (\\<lambda>s.\n                                     on_finish param v s \\<bind>\n                                     (\\<lambda>e.\n   RETURN (upd_ext (\\<lambda>_. e) s))))\n 3. \\<And>u v s0 s ui vi si.\n       \\<lbrakk>a.pre_cross_edge u v s0 s; (ui, u) \\<in> V; (vi, v) \\<in> V;\n        (si, s) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> gbs_cross_edge gbsi ui vi si \\<bind>\n                         (\\<lambda>s.\n                             on_cross_edge parami ui vi s \\<bind>\n                             (\\<lambda>e.\n                                 RETURN (upd_exti (\\<lambda>_. e) s)))\n                         \\<le> \\<Down> S\n                                (gbs_cross_edge gbs u v s \\<bind>\n                                 (\\<lambda>s.\n                                     on_cross_edge param u v s \\<bind>\n                                     (\\<lambda>e.\n   RETURN (upd_ext (\\<lambda>_. e) s))))\n 4. \\<And>u v s0 s ui vi si.\n       \\<lbrakk>a.pre_back_edge u v s0 s; (ui, u) \\<in> V; (vi, v) \\<in> V;\n        (si, s) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> gbs_back_edge gbsi ui vi si \\<bind>\n                         (\\<lambda>s.\n                             on_back_edge parami ui vi s \\<bind>\n                             (\\<lambda>e.\n                                 RETURN (upd_exti (\\<lambda>_. e) s)))\n                         \\<le> \\<Down> S\n                                (gbs_back_edge gbs u v s \\<bind>\n                                 (\\<lambda>s.\n                                     on_back_edge param u v s \\<bind>\n                                     (\\<lambda>e.\n   RETURN (upd_ext (\\<lambda>_. e) s))))\n 5. \\<And>u v s0 s ui vi si.\n       \\<lbrakk>a.pre_discover u v s0 s; (ui, u) \\<in> V; (vi, v) \\<in> V;\n        (si, s) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> gbs_discover gbsi ui vi si \\<bind>\n                         (\\<lambda>s.\n                             on_discover parami ui vi s \\<bind>\n                             (\\<lambda>e.\n                                 RETURN (upd_exti (\\<lambda>_. e) s)))\n                         \\<le> \\<Down> S\n                                (gbs_discover gbs u v s \\<bind>\n                                 (\\<lambda>s.\n                                     on_discover param u v s \\<bind>\n                                     (\\<lambda>e.\n   RETURN (upd_ext (\\<lambda>_. e) s))))", "apply refine_rcg"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>v s0 s vi si.\n       \\<lbrakk>a.pre_finish v s0 s; (vi, v) \\<in> V;\n        (si, s) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> gbs_finish gbsi vi si \\<bind>\n                         (\\<lambda>s.\n                             on_finish parami vi s \\<bind>\n                             (\\<lambda>e.\n                                 RETURN (upd_exti (\\<lambda>_. e) s)))\n                         \\<le> \\<Down> S\n                                (gbs_finish gbs v s \\<bind>\n                                 (\\<lambda>s.\n                                     on_finish param v s \\<bind>\n                                     (\\<lambda>e.\n   RETURN (upd_ext (\\<lambda>_. e) s))))\n 2. \\<And>u v s0 s ui vi si.\n       \\<lbrakk>a.pre_cross_edge u v s0 s; (ui, u) \\<in> V; (vi, v) \\<in> V;\n        (si, s) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> gbs_cross_edge gbsi ui vi si \\<bind>\n                         (\\<lambda>s.\n                             on_cross_edge parami ui vi s \\<bind>\n                             (\\<lambda>e.\n                                 RETURN (upd_exti (\\<lambda>_. e) s)))\n                         \\<le> \\<Down> S\n                                (gbs_cross_edge gbs u v s \\<bind>\n                                 (\\<lambda>s.\n                                     on_cross_edge param u v s \\<bind>\n                                     (\\<lambda>e.\n   RETURN (upd_ext (\\<lambda>_. e) s))))\n 3. \\<And>u v s0 s ui vi si.\n       \\<lbrakk>a.pre_back_edge u v s0 s; (ui, u) \\<in> V; (vi, v) \\<in> V;\n        (si, s) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> gbs_back_edge gbsi ui vi si \\<bind>\n                         (\\<lambda>s.\n                             on_back_edge parami ui vi s \\<bind>\n                             (\\<lambda>e.\n                                 RETURN (upd_exti (\\<lambda>_. e) s)))\n                         \\<le> \\<Down> S\n                                (gbs_back_edge gbs u v s \\<bind>\n                                 (\\<lambda>s.\n                                     on_back_edge param u v s \\<bind>\n                                     (\\<lambda>e.\n   RETURN (upd_ext (\\<lambda>_. e) s))))\n 4. \\<And>u v s0 s ui vi si.\n       \\<lbrakk>a.pre_discover u v s0 s; (ui, u) \\<in> V; (vi, v) \\<in> V;\n        (si, s) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> gbs_discover gbsi ui vi si \\<bind>\n                         (\\<lambda>s.\n                             on_discover parami ui vi s \\<bind>\n                             (\\<lambda>e.\n                                 RETURN (upd_exti (\\<lambda>_. e) s)))\n                         \\<le> \\<Down> S\n                                (gbs_discover gbs u v s \\<bind>\n                                 (\\<lambda>s.\n                                     on_discover param u v s \\<bind>\n                                     (\\<lambda>e.\n   RETURN (upd_ext (\\<lambda>_. e) s))))", "apply (refine_rcg bind_refine_abs', assumption+, parametricity) []"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>u v s0 s ui vi si.\n       \\<lbrakk>a.pre_cross_edge u v s0 s; (ui, u) \\<in> V; (vi, v) \\<in> V;\n        (si, s) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> gbs_cross_edge gbsi ui vi si \\<bind>\n                         (\\<lambda>s.\n                             on_cross_edge parami ui vi s \\<bind>\n                             (\\<lambda>e.\n                                 RETURN (upd_exti (\\<lambda>_. e) s)))\n                         \\<le> \\<Down> S\n                                (gbs_cross_edge gbs u v s \\<bind>\n                                 (\\<lambda>s.\n                                     on_cross_edge param u v s \\<bind>\n                                     (\\<lambda>e.\n   RETURN (upd_ext (\\<lambda>_. e) s))))\n 2. \\<And>u v s0 s ui vi si.\n       \\<lbrakk>a.pre_back_edge u v s0 s; (ui, u) \\<in> V; (vi, v) \\<in> V;\n        (si, s) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> gbs_back_edge gbsi ui vi si \\<bind>\n                         (\\<lambda>s.\n                             on_back_edge parami ui vi s \\<bind>\n                             (\\<lambda>e.\n                                 RETURN (upd_exti (\\<lambda>_. e) s)))\n                         \\<le> \\<Down> S\n                                (gbs_back_edge gbs u v s \\<bind>\n                                 (\\<lambda>s.\n                                     on_back_edge param u v s \\<bind>\n                                     (\\<lambda>e.\n   RETURN (upd_ext (\\<lambda>_. e) s))))\n 3. \\<And>u v s0 s ui vi si.\n       \\<lbrakk>a.pre_discover u v s0 s; (ui, u) \\<in> V; (vi, v) \\<in> V;\n        (si, s) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> gbs_discover gbsi ui vi si \\<bind>\n                         (\\<lambda>s.\n                             on_discover parami ui vi s \\<bind>\n                             (\\<lambda>e.\n                                 RETURN (upd_exti (\\<lambda>_. e) s)))\n                         \\<le> \\<Down> S\n                                (gbs_discover gbs u v s \\<bind>\n                                 (\\<lambda>s.\n                                     on_discover param u v s \\<bind>\n                                     (\\<lambda>e.\n   RETURN (upd_ext (\\<lambda>_. e) s))))", "apply (refine_rcg bind_refine_abs', assumption+, parametricity) []"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>u v s0 s ui vi si.\n       \\<lbrakk>a.pre_back_edge u v s0 s; (ui, u) \\<in> V; (vi, v) \\<in> V;\n        (si, s) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> gbs_back_edge gbsi ui vi si \\<bind>\n                         (\\<lambda>s.\n                             on_back_edge parami ui vi s \\<bind>\n                             (\\<lambda>e.\n                                 RETURN (upd_exti (\\<lambda>_. e) s)))\n                         \\<le> \\<Down> S\n                                (gbs_back_edge gbs u v s \\<bind>\n                                 (\\<lambda>s.\n                                     on_back_edge param u v s \\<bind>\n                                     (\\<lambda>e.\n   RETURN (upd_ext (\\<lambda>_. e) s))))\n 2. \\<And>u v s0 s ui vi si.\n       \\<lbrakk>a.pre_discover u v s0 s; (ui, u) \\<in> V; (vi, v) \\<in> V;\n        (si, s) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> gbs_discover gbsi ui vi si \\<bind>\n                         (\\<lambda>s.\n                             on_discover parami ui vi s \\<bind>\n                             (\\<lambda>e.\n                                 RETURN (upd_exti (\\<lambda>_. e) s)))\n                         \\<le> \\<Down> S\n                                (gbs_discover gbs u v s \\<bind>\n                                 (\\<lambda>s.\n                                     on_discover param u v s \\<bind>\n                                     (\\<lambda>e.\n   RETURN (upd_ext (\\<lambda>_. e) s))))", "apply (refine_rcg bind_refine_abs', assumption+, parametricity) []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>u v s0 s ui vi si.\n       \\<lbrakk>a.pre_discover u v s0 s; (ui, u) \\<in> V; (vi, v) \\<in> V;\n        (si, s) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> gbs_discover gbsi ui vi si \\<bind>\n                         (\\<lambda>s.\n                             on_discover parami ui vi s \\<bind>\n                             (\\<lambda>e.\n                                 RETURN (upd_exti (\\<lambda>_. e) s)))\n                         \\<le> \\<Down> S\n                                (gbs_discover gbs u v s \\<bind>\n                                 (\\<lambda>s.\n                                     on_discover param u v s \\<bind>\n                                     (\\<lambda>e.\n   RETURN (upd_ext (\\<lambda>_. e) s))))", "apply (refine_rcg bind_refine_abs', assumption+, parametricity) []"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "end"]]}