{"file_name": "/home/qj213/afp-2021-10-22/thys/DFS_Framework/Examples/Reachable_Nodes.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/DFS_Framework", "problem_names": ["lemma gen_obtain_finite_set:\n  assumes F: \"finite S\"\n  assumes E: \"(e,{})\\<in>\\<langle>R\\<rangle>Rs\"\n  assumes I: \"(i,insert)\\<in>R\\<rightarrow>\\<langle>R\\<rangle>Rs\\<rightarrow>\\<langle>R\\<rangle>Rs\"\n  assumes EE: \"\\<And>x. x\\<in>S \\<Longrightarrow> \\<exists>xi. (xi,x)\\<in>R\"\n  shows \"\\<exists>Si. (Si,S)\\<in>\\<langle>R\\<rangle>Rs\"", "lemma obtain_finite_ahs: \"finite S \\<Longrightarrow> \\<exists>x. (x,S)\\<in>\\<langle>Id\\<rangle>dflt_ahs_rel\"", "lemmas unit_parametrization_simp[simp, DFS_code_unfold] = \n  dflt_parametrization_simp[mk_record_simp, OF, OF unit_parametrization_def]", "lemma unit_DFSI[Pure.intro?, intro?]: \n  assumes \"fb_graph G\" \n  shows \"unit_DFS G\"", "lemma find_reachable_correct: \"find_reachable G \\<le> SPEC (\\<lambda>r. r = reachable)\"", "lemma find_reachableT_correct: \n    \"finite reachable \\<Longrightarrow> find_reachableT G \\<le> SPEC (\\<lambda>r. r = reachable)\"", "lemmas impl_refine = simple_tailrecT_refine simple_tailrec_refine simple_rec_refine", "lemma find_reachable_impl_refine: \n  \"find_reachable_impl G \\<le> \\<Down>Id (find_reachable G)\"", "lemma find_reachable_implT_refine: \n  \"find_reachable_implT G \\<le> \\<Down>Id (find_reachableT G)\"", "lemma find_reachable_rec_impl_refine: \n  \"find_reachable_rec_impl G \\<le> \\<Down>Id (find_reachable G)\"", "lemma find_reachable_code_correct:\n  assumes 1: \"fb_graph G\"\n  assumes 2: \"(Gi, G) \\<in> \\<langle>Rm, Id\\<rangle>g_impl_rel_ext\"\n  assumes 4: \"find_reachable_code Gi = dRETURN r\"\n  shows \"(r, (g_E G)\\<^sup>* `` g_V0 G)\\<in>\\<langle>Id\\<rangle>dflt_ahs_rel\"", "lemma find_reachable_codeT_correct:\n  fixes V :: \"('vi\\<times>'v) set\"\n  assumes G: \"graph G\"\n  assumes FR: \"finite ((g_E G)\\<^sup>* `` g_V0 G)\"\n  assumes BHC: \"is_bounded_hashcode V eq bhc\"\n  assumes EQ: \"(eq,(=)) \\<in> V \\<rightarrow> V \\<rightarrow> bool_rel\"\n  assumes VDS: \"is_valid_def_hm_size TYPE ('vi) sz\"\n  assumes 2: \"(Gi, G) \\<in> \\<langle>Rm, V\\<rangle>g_impl_rel_ext\"\n  shows \"(find_reachable_codeT eq bhc sz Gi, (g_E G)\\<^sup>* `` g_V0 G)\\<in>\\<langle>V\\<rangle>ahs_rel bhc\"", "lemma all_unit_refine[simp]: \n  \"((),x)\\<in>all_unit_rel\"", "lemma unit_list_rel_refine[simp]: \"((),y)\\<in>\\<langle>R\\<rangle>unit_list_rel\"", "lemmas [autoref_rel_intf] = REL_INTFI[of unit_list_rel i_list]", "lemma [autoref_rules]:\n  \"((),[])\\<in>\\<langle>R\\<rangle>unit_list_rel\"\n  \"(\\<lambda>_. (),tl)\\<in>\\<langle>R\\<rangle>unit_list_rel\\<rightarrow>\\<langle>R\\<rangle>unit_list_rel\"\n  \"(\\<lambda>_ _. (),(#))\\<in>R \\<rightarrow> \\<langle>R\\<rangle>unit_list_rel\\<rightarrow>\\<langle>R\\<rangle>unit_list_rel\"", "lemma find_reachable_rec_code_correct:\n  assumes 1: \"fb_graph G\"\n  assumes 2: \"(Gi, G) \\<in> \\<langle>Rm, Id\\<rangle>g_impl_rel_ext\"\n  assumes 4: \"find_reachable_rec_code Gi = dRETURN r\"\n  shows \"(r, (g_E G)\\<^sup>* `` g_V0 G)\\<in>\\<langle>Id\\<rangle>dflt_ahs_rel\"", "lemmas [autoref_op_pat] = op_reachable_def[symmetric]", "lemma autoref_op_reachable[autoref_rules]:\n  fixes V :: \"('vi\\<times>'v) set\"\n  assumes G: \"SIDE_PRECOND (graph G)\"\n  assumes FR: \"SIDE_PRECOND (finite ((g_E G)\\<^sup>* `` g_V0 G))\"\n  assumes BHC: \"SIDE_GEN_ALGO (is_bounded_hashcode V eq bhc)\"\n  assumes EQ: \"GEN_OP eq (=) (V \\<rightarrow> V \\<rightarrow> bool_rel)\"\n  assumes VDS: \"SIDE_GEN_ALGO (is_valid_def_hm_size TYPE ('vi) sz)\"\n  assumes 2: \"(Gi, G) \\<in> \\<langle>Rm, V\\<rangle>g_impl_rel_ext\"\n  shows \"(find_reachable_codeT eq bhc sz Gi,\n    (OP op_reachable ::: \\<langle>Rm, V\\<rangle>g_impl_rel_ext \\<rightarrow> \\<langle>V\\<rangle>ahs_rel bhc)$G)\\<in>\\<langle>V\\<rangle>ahs_rel bhc\""], "translations": [["", "lemma gen_obtain_finite_set:\n  assumes F: \"finite S\"\n  assumes E: \"(e,{})\\<in>\\<langle>R\\<rangle>Rs\"\n  assumes I: \"(i,insert)\\<in>R\\<rightarrow>\\<langle>R\\<rangle>Rs\\<rightarrow>\\<langle>R\\<rangle>Rs\"\n  assumes EE: \"\\<And>x. x\\<in>S \\<Longrightarrow> \\<exists>xi. (xi,x)\\<in>R\"\n  shows \"\\<exists>Si. (Si,S)\\<in>\\<langle>R\\<rangle>Rs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>Si. (Si, S) \\<in> \\<langle>R\\<rangle>Rs", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>Si. (Si, S) \\<in> \\<langle>R\\<rangle>Rs", "define S' where \"S' = S\""], ["proof (state)\nthis:\n  S' = S\n\ngoal (1 subgoal):\n 1. \\<exists>Si. (Si, S) \\<in> \\<langle>R\\<rangle>Rs", "have \"S\\<subseteq>S'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S \\<subseteq> S'", "by (simp add: S'_def)"], ["proof (state)\nthis:\n  S \\<subseteq> S'\n\ngoal (1 subgoal):\n 1. \\<exists>Si. (Si, S) \\<in> \\<langle>R\\<rangle>Rs", "from F this"], ["proof (chain)\npicking this:\n  finite S\n  S \\<subseteq> S'", "show \"(\\<exists>Si. (Si,S)\\<in>\\<langle>R\\<rangle>Rs)\""], ["proof (prove)\nusing this:\n  finite S\n  S \\<subseteq> S'\n\ngoal (1 subgoal):\n 1. \\<exists>Si. (Si, S) \\<in> \\<langle>R\\<rangle>Rs", "proof (induction)"], ["proof (state)\ngoal (2 subgoals):\n 1. {} \\<subseteq> S' \\<Longrightarrow>\n    \\<exists>Si. (Si, {}) \\<in> \\<langle>R\\<rangle>Rs\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        F \\<subseteq> S' \\<Longrightarrow>\n        \\<exists>Si. (Si, F) \\<in> \\<langle>R\\<rangle>Rs;\n        insert x F \\<subseteq> S'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Si.\n                            (Si, insert x F) \\<in> \\<langle>R\\<rangle>Rs", "case empty"], ["proof (state)\nthis:\n  {} \\<subseteq> S'\n\ngoal (2 subgoals):\n 1. {} \\<subseteq> S' \\<Longrightarrow>\n    \\<exists>Si. (Si, {}) \\<in> \\<langle>R\\<rangle>Rs\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        F \\<subseteq> S' \\<Longrightarrow>\n        \\<exists>Si. (Si, F) \\<in> \\<langle>R\\<rangle>Rs;\n        insert x F \\<subseteq> S'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Si.\n                            (Si, insert x F) \\<in> \\<langle>R\\<rangle>Rs", "thus ?case"], ["proof (prove)\nusing this:\n  {} \\<subseteq> S'\n\ngoal (1 subgoal):\n 1. \\<exists>Si. (Si, {}) \\<in> \\<langle>R\\<rangle>Rs", "using E"], ["proof (prove)\nusing this:\n  {} \\<subseteq> S'\n  (e, {}) \\<in> \\<langle>R\\<rangle>Rs\n\ngoal (1 subgoal):\n 1. \\<exists>Si. (Si, {}) \\<in> \\<langle>R\\<rangle>Rs", "by (blast)"], ["proof (state)\nthis:\n  \\<exists>Si. (Si, {}) \\<in> \\<langle>R\\<rangle>Rs\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        F \\<subseteq> S' \\<Longrightarrow>\n        \\<exists>Si. (Si, F) \\<in> \\<langle>R\\<rangle>Rs;\n        insert x F \\<subseteq> S'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Si.\n                            (Si, insert x F) \\<in> \\<langle>R\\<rangle>Rs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        F \\<subseteq> S' \\<Longrightarrow>\n        \\<exists>Si. (Si, F) \\<in> \\<langle>R\\<rangle>Rs;\n        insert x F \\<subseteq> S'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Si.\n                            (Si, insert x F) \\<in> \\<langle>R\\<rangle>Rs", "case (insert x S)"], ["proof (state)\nthis:\n  finite S\n  x \\<notin> S\n  S \\<subseteq> S' \\<Longrightarrow>\n  \\<exists>Si. (Si, S) \\<in> \\<langle>R\\<rangle>Rs\n  insert x S \\<subseteq> S'\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        F \\<subseteq> S' \\<Longrightarrow>\n        \\<exists>Si. (Si, F) \\<in> \\<langle>R\\<rangle>Rs;\n        insert x F \\<subseteq> S'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Si.\n                            (Si, insert x F) \\<in> \\<langle>R\\<rangle>Rs", "then"], ["proof (chain)\npicking this:\n  finite S\n  x \\<notin> S\n  S \\<subseteq> S' \\<Longrightarrow>\n  \\<exists>Si. (Si, S) \\<in> \\<langle>R\\<rangle>Rs\n  insert x S \\<subseteq> S'", "obtain xi Si where 1: \"(Si,S)\\<in>\\<langle>R\\<rangle>Rs\" and 2: \"(xi,x)\\<in>R\""], ["proof (prove)\nusing this:\n  finite S\n  x \\<notin> S\n  S \\<subseteq> S' \\<Longrightarrow>\n  \\<exists>Si. (Si, S) \\<in> \\<langle>R\\<rangle>Rs\n  insert x S \\<subseteq> S'\n\ngoal (1 subgoal):\n 1. (\\<And>Si xi.\n        \\<lbrakk>(Si, S) \\<in> \\<langle>R\\<rangle>Rs;\n         (xi, x) \\<in> R\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using EE"], ["proof (prove)\nusing this:\n  finite S\n  x \\<notin> S\n  S \\<subseteq> S' \\<Longrightarrow>\n  \\<exists>Si. (Si, S) \\<in> \\<langle>R\\<rangle>Rs\n  insert x S \\<subseteq> S'\n  ?x \\<in> S \\<Longrightarrow> \\<exists>xi. (xi, ?x) \\<in> R\n\ngoal (1 subgoal):\n 1. (\\<And>Si xi.\n        \\<lbrakk>(Si, S) \\<in> \\<langle>R\\<rangle>Rs;\n         (xi, x) \\<in> R\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding S'_def"], ["proof (prove)\nusing this:\n  finite S\n  x \\<notin> S\n  S \\<subseteq> S \\<Longrightarrow>\n  \\<exists>Si. (Si, S) \\<in> \\<langle>R\\<rangle>Rs\n  insert x S \\<subseteq> S\n  ?x \\<in> S \\<Longrightarrow> \\<exists>xi. (xi, ?x) \\<in> R\n\ngoal (1 subgoal):\n 1. (\\<And>Si xi.\n        \\<lbrakk>(Si, S) \\<in> \\<langle>R\\<rangle>Rs;\n         (xi, x) \\<in> R\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  (Si, S) \\<in> \\<langle>R\\<rangle>Rs\n  (xi, x) \\<in> R\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        F \\<subseteq> S' \\<Longrightarrow>\n        \\<exists>Si. (Si, F) \\<in> \\<langle>R\\<rangle>Rs;\n        insert x F \\<subseteq> S'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Si.\n                            (Si, insert x F) \\<in> \\<langle>R\\<rangle>Rs", "from I[THEN fun_relD, OF 2, THEN fun_relD, OF 1]"], ["proof (chain)\npicking this:\n  (i xi Si, insert x S) \\<in> \\<langle>R\\<rangle>Rs", "show ?case"], ["proof (prove)\nusing this:\n  (i xi Si, insert x S) \\<in> \\<langle>R\\<rangle>Rs\n\ngoal (1 subgoal):\n 1. \\<exists>Si. (Si, insert x S) \\<in> \\<langle>R\\<rangle>Rs", ".."], ["proof (state)\nthis:\n  \\<exists>Si. (Si, insert x S) \\<in> \\<langle>R\\<rangle>Rs\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>Si. (Si, S) \\<in> \\<langle>R\\<rangle>Rs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma obtain_finite_ahs: \"finite S \\<Longrightarrow> \\<exists>x. (x,S)\\<in>\\<langle>Id\\<rangle>dflt_ahs_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite S \\<Longrightarrow>\n    \\<exists>x.\n       (x, S) \\<in> \\<langle>Id\\<rangle>ahs_rel bounded_hashcode_nat", "apply (erule gen_obtain_finite_set)"], ["proof (prove)\ngoal (3 subgoals):\n 1. (?e, {}) \\<in> \\<langle>Id\\<rangle>ahs_rel bounded_hashcode_nat\n 2. (?i, insert)\n    \\<in> Id \\<rightarrow>\n          \\<langle>Id\\<rangle>ahs_rel bounded_hashcode_nat \\<rightarrow>\n          \\<langle>Id\\<rangle>ahs_rel bounded_hashcode_nat\n 3. \\<And>x. x \\<in> S \\<Longrightarrow> \\<exists>xi. (xi, x) \\<in> Id", "apply autoref"], ["proof (prove)\ngoal (2 subgoals):\n 1. (?i, insert)\n    \\<in> Id \\<rightarrow>\n          \\<langle>Id\\<rangle>ahs_rel bounded_hashcode_nat \\<rightarrow>\n          \\<langle>Id\\<rangle>ahs_rel bounded_hashcode_nat\n 2. \\<And>x. x \\<in> S \\<Longrightarrow> \\<exists>xi. (xi, x) \\<in> Id", "apply autoref"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> S \\<Longrightarrow> \\<exists>xi. (xi, x) \\<in> Id", "by blast"], ["", "subsection \\<open>Framework Instantiation\\<close>"], ["", "definition \"unit_parametrization \\<equiv> dflt_parametrization (\\<lambda>_. ()) (RETURN ())\""], ["", "lemmas unit_parametrization_simp[simp, DFS_code_unfold] = \n  dflt_parametrization_simp[mk_record_simp, OF, OF unit_parametrization_def]"], ["", "interpretation unit_dfs: param_DFS_defs where param=unit_parametrization for G"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "locale unit_DFS = param_DFS G unit_parametrization for G :: \"('v, 'more) graph_rec_scheme\"\nbegin"], ["", "sublocale DFS G unit_parametrization"], ["proof (prove)\ngoal (1 subgoal):\n 1. DFS G unit_parametrization", "by unfold_locales simp_all"], ["", "end"], ["", "lemma unit_DFSI[Pure.intro?, intro?]: \n  assumes \"fb_graph G\" \n  shows \"unit_DFS G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unit_DFS G", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. unit_DFS G", "interpret fb_graph G"], ["proof (prove)\ngoal (1 subgoal):\n 1. fb_graph G", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. unit_DFS G", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. unit_DFS G", "by unfold_locales"], ["proof (state)\nthis:\n  unit_DFS G\n\ngoal:\nNo subgoals!", "qed"], ["", "(* Find Reachable Nodes *)"], ["", "definition \"find_reachable G \\<equiv> do {\n  ASSERT (fb_graph G);\n  s \\<leftarrow> unit_dfs.it_dfs TYPE('a) G;\n  RETURN (dom (discovered s))\n}\""], ["", "definition \"find_reachableT G \\<equiv> do {\n  ASSERT (fb_graph G);\n  s \\<leftarrow> unit_dfs.it_dfsT TYPE('a) G;\n  RETURN (dom (discovered s))\n}\""], ["", "subsection \\<open>Correctness\\<close>"], ["", "context unit_DFS begin"], ["", "lemma find_reachable_correct: \"find_reachable G \\<le> SPEC (\\<lambda>r. r = reachable)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. find_reachable G \\<le> SPEC (\\<lambda>r. r = reachable)", "unfolding find_reachable_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ASSERT (fb_graph G) \\<bind>\n    (\\<lambda>_. it_dfs \\<bind> (\\<lambda>s. RETURN (dom (discovered s))))\n    \\<le> SPEC (\\<lambda>r. r = reachable)", "apply (refine_vcg order_trans[OF it_dfs_correct])"], ["proof (prove)\ngoal (2 subgoals):\n 1. fb_graph G\n 2. \\<And>x.\n       \\<lbrakk>fb_graph G;\n        DFS_invar G unit_parametrization x \\<and> \\<not> cond x\\<rbrakk>\n       \\<Longrightarrow> dom (discovered x) = reachable", "apply unfold_locales"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>fb_graph G;\n        DFS_invar G unit_parametrization x \\<and> \\<not> cond x\\<rbrakk>\n       \\<Longrightarrow> dom (discovered x) = reachable", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>fb_graph G; DFS_invar G unit_parametrization x;\n        \\<not> cond x\\<rbrakk>\n       \\<Longrightarrow> dom (discovered x) = reachable", "apply (drule (1) DFS_invar.nc_discovered_eq_reachable)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>fb_graph G; \\<not> cond x\\<rbrakk>\n       \\<Longrightarrow> \\<not> is_break unit_parametrization x\n 2. \\<And>x.\n       \\<lbrakk>fb_graph G; \\<not> cond x;\n        dom (discovered x) = reachable\\<rbrakk>\n       \\<Longrightarrow> dom (discovered x) = reachable", "by auto"], ["", "lemma find_reachableT_correct: \n    \"finite reachable \\<Longrightarrow> find_reachableT G \\<le> SPEC (\\<lambda>r. r = reachable)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite reachable \\<Longrightarrow>\n    find_reachableT G \\<le> SPEC (\\<lambda>r. r = reachable)", "unfolding find_reachableT_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite reachable \\<Longrightarrow>\n    ASSERT (fb_graph G) \\<bind>\n    (\\<lambda>_. it_dfsT \\<bind> (\\<lambda>s. RETURN (dom (discovered s))))\n    \\<le> SPEC (\\<lambda>r. r = reachable)", "apply (refine_vcg order_trans[OF it_dfsT_correct])"], ["proof (prove)\ngoal (2 subgoals):\n 1. finite reachable \\<Longrightarrow> fb_graph G\n 2. \\<And>x.\n       \\<lbrakk>finite reachable; fb_graph G;\n        DFS_invar G unit_parametrization x \\<and> \\<not> cond x\\<rbrakk>\n       \\<Longrightarrow> dom (discovered x) = reachable", "apply unfold_locales"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>finite reachable; fb_graph G;\n        DFS_invar G unit_parametrization x \\<and> \\<not> cond x\\<rbrakk>\n       \\<Longrightarrow> dom (discovered x) = reachable", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>finite reachable; fb_graph G;\n        DFS_invar G unit_parametrization x; \\<not> cond x\\<rbrakk>\n       \\<Longrightarrow> dom (discovered x) = reachable", "apply (drule (1) DFS_invar.nc_discovered_eq_reachable)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>finite reachable; fb_graph G; \\<not> cond x\\<rbrakk>\n       \\<Longrightarrow> \\<not> is_break unit_parametrization x\n 2. \\<And>x.\n       \\<lbrakk>finite reachable; fb_graph G; \\<not> cond x;\n        dom (discovered x) = reachable\\<rbrakk>\n       \\<Longrightarrow> dom (discovered x) = reachable", "by auto"], ["", "end"], ["", "context unit_DFS begin"], ["", "(* Derive the implementation *)"], ["", "sublocale simple_impl G unit_parametrization unit_parametrization unit_rel"], ["proof (prove)\ngoal (1 subgoal):\n 1. simple_impl G unit_parametrization unit_parametrization unit_rel", "apply unfold_locales"], ["proof (prove)\ngoal (8 subgoals):\n 1. (simple_state.more_update, state.more_update)\n    \\<in> (unit_rel \\<rightarrow> unit_rel) \\<rightarrow>\n          \\<langle>unit_rel\\<rangle>simple_state_rel \\<rightarrow>\n          \\<langle>unit_rel\\<rangle>simple_state_rel\n 2. on_init unit_parametrization\n    \\<le> \\<Down> unit_rel (on_init unit_parametrization)\n 3. (is_break unit_parametrization, is_break unit_parametrization)\n    \\<in> \\<langle>unit_rel\\<rangle>simple_state_rel \\<rightarrow> bool_rel\n 4. \\<And>v0 s v0i si si' s'.\n       \\<lbrakk>gen_dfs.pre_new_root v0 s; (v0i, v0) \\<in> Id;\n        (si, s) \\<in> \\<langle>unit_rel\\<rangle>simple_state_rel;\n        (si', s') \\<in> \\<langle>unit_rel\\<rangle>simple_state_rel;\n        nf_inres (gbs_new_root gbs v0 s) s'\\<rbrakk>\n       \\<Longrightarrow> on_new_root unit_parametrization v0i si'\n                         \\<le> \\<Down> unit_rel\n                                (on_new_root unit_parametrization v0 s')\n 5. \\<And>v s0 s vi si si' s'.\n       \\<lbrakk>gen_dfs.pre_finish v s0 s; (vi, v) \\<in> Id;\n        (si, s) \\<in> \\<langle>unit_rel\\<rangle>simple_state_rel;\n        (si', s') \\<in> \\<langle>unit_rel\\<rangle>simple_state_rel;\n        nf_inres (gbs_finish gbs v s) s'\\<rbrakk>\n       \\<Longrightarrow> on_finish unit_parametrization vi si'\n                         \\<le> \\<Down> unit_rel\n                                (on_finish unit_parametrization v s')\n 6. \\<And>u v s0 s ui vi si si' s'.\n       \\<lbrakk>gen_dfs.pre_cross_edge u v s0 s; (ui, u) \\<in> Id;\n        (vi, v) \\<in> Id;\n        (si, s) \\<in> \\<langle>unit_rel\\<rangle>simple_state_rel;\n        (si', s') \\<in> \\<langle>unit_rel\\<rangle>simple_state_rel;\n        nf_inres (gbs_cross_edge gbs u v s) s'\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge unit_parametrization ui vi si'\n                         \\<le> \\<Down> unit_rel\n                                (on_cross_edge unit_parametrization u v s')\n 7. \\<And>u v s0 s ui vi si si' s'.\n       \\<lbrakk>gen_dfs.pre_back_edge u v s0 s; (ui, u) \\<in> Id;\n        (vi, v) \\<in> Id;\n        (si, s) \\<in> \\<langle>unit_rel\\<rangle>simple_state_rel;\n        (si', s') \\<in> \\<langle>unit_rel\\<rangle>simple_state_rel;\n        nf_inres (gbs_back_edge gbs u v s) s'\\<rbrakk>\n       \\<Longrightarrow> on_back_edge unit_parametrization ui vi si'\n                         \\<le> \\<Down> unit_rel\n                                (on_back_edge unit_parametrization u v s')\n 8. \\<And>u v s0 s ui vi si si' s'.\n       \\<lbrakk>gen_dfs.pre_discover u v s0 s; (ui, u) \\<in> Id;\n        (vi, v) \\<in> Id;\n        (si, s) \\<in> \\<langle>unit_rel\\<rangle>simple_state_rel;\n        (si', s') \\<in> \\<langle>unit_rel\\<rangle>simple_state_rel;\n        nf_inres (gbs_discover gbs u v s) s'\\<rbrakk>\n       \\<Longrightarrow> on_discover unit_parametrization ui vi si'\n                         \\<le> \\<Down> unit_rel\n                                (on_discover unit_parametrization u v s')", "apply (clarsimp simp: simple_state_rel_def) []"], ["proof (prove)\ngoal (7 subgoals):\n 1. on_init unit_parametrization\n    \\<le> \\<Down> unit_rel (on_init unit_parametrization)\n 2. (is_break unit_parametrization, is_break unit_parametrization)\n    \\<in> \\<langle>unit_rel\\<rangle>simple_state_rel \\<rightarrow> bool_rel\n 3. \\<And>v0 s v0i si si' s'.\n       \\<lbrakk>gen_dfs.pre_new_root v0 s; (v0i, v0) \\<in> Id;\n        (si, s) \\<in> \\<langle>unit_rel\\<rangle>simple_state_rel;\n        (si', s') \\<in> \\<langle>unit_rel\\<rangle>simple_state_rel;\n        nf_inres (gbs_new_root gbs v0 s) s'\\<rbrakk>\n       \\<Longrightarrow> on_new_root unit_parametrization v0i si'\n                         \\<le> \\<Down> unit_rel\n                                (on_new_root unit_parametrization v0 s')\n 4. \\<And>v s0 s vi si si' s'.\n       \\<lbrakk>gen_dfs.pre_finish v s0 s; (vi, v) \\<in> Id;\n        (si, s) \\<in> \\<langle>unit_rel\\<rangle>simple_state_rel;\n        (si', s') \\<in> \\<langle>unit_rel\\<rangle>simple_state_rel;\n        nf_inres (gbs_finish gbs v s) s'\\<rbrakk>\n       \\<Longrightarrow> on_finish unit_parametrization vi si'\n                         \\<le> \\<Down> unit_rel\n                                (on_finish unit_parametrization v s')\n 5. \\<And>u v s0 s ui vi si si' s'.\n       \\<lbrakk>gen_dfs.pre_cross_edge u v s0 s; (ui, u) \\<in> Id;\n        (vi, v) \\<in> Id;\n        (si, s) \\<in> \\<langle>unit_rel\\<rangle>simple_state_rel;\n        (si', s') \\<in> \\<langle>unit_rel\\<rangle>simple_state_rel;\n        nf_inres (gbs_cross_edge gbs u v s) s'\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge unit_parametrization ui vi si'\n                         \\<le> \\<Down> unit_rel\n                                (on_cross_edge unit_parametrization u v s')\n 6. \\<And>u v s0 s ui vi si si' s'.\n       \\<lbrakk>gen_dfs.pre_back_edge u v s0 s; (ui, u) \\<in> Id;\n        (vi, v) \\<in> Id;\n        (si, s) \\<in> \\<langle>unit_rel\\<rangle>simple_state_rel;\n        (si', s') \\<in> \\<langle>unit_rel\\<rangle>simple_state_rel;\n        nf_inres (gbs_back_edge gbs u v s) s'\\<rbrakk>\n       \\<Longrightarrow> on_back_edge unit_parametrization ui vi si'\n                         \\<le> \\<Down> unit_rel\n                                (on_back_edge unit_parametrization u v s')\n 7. \\<And>u v s0 s ui vi si si' s'.\n       \\<lbrakk>gen_dfs.pre_discover u v s0 s; (ui, u) \\<in> Id;\n        (vi, v) \\<in> Id;\n        (si, s) \\<in> \\<langle>unit_rel\\<rangle>simple_state_rel;\n        (si', s') \\<in> \\<langle>unit_rel\\<rangle>simple_state_rel;\n        nf_inres (gbs_discover gbs u v s) s'\\<rbrakk>\n       \\<Longrightarrow> on_discover unit_parametrization ui vi si'\n                         \\<le> \\<Down> unit_rel\n                                (on_discover unit_parametrization u v s')", "by auto"], ["", "lemmas impl_refine = simple_tailrecT_refine simple_tailrec_refine simple_rec_refine"], ["", "end"], ["", "interpretation unit_simple_impl: \n  simple_impl_defs G unit_parametrization unit_parametrization\n  for G"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "term unit_simple_impl.tailrec_impl"], ["", "term unit_simple_impl.rec_impl"], ["", "definition [DFS_code_unfold]: \"find_reachable_impl G \\<equiv> do {\n  ASSERT (fb_graph G);\n  s \\<leftarrow> unit_simple_impl.tailrec_impl TYPE('a) G;\n  RETURN (simple_state.visited s)\n}\""], ["", "definition [DFS_code_unfold]: \"find_reachable_implT G \\<equiv> do {\n  ASSERT (fb_graph G);\n  s \\<leftarrow> unit_simple_impl.tailrec_implT TYPE('a) G;\n  RETURN (simple_state.visited s)\n}\""], ["", "definition [DFS_code_unfold]: \"find_reachable_rec_impl G \\<equiv> do {\n  ASSERT (fb_graph G);\n  s \\<leftarrow> unit_simple_impl.rec_impl TYPE('a) G;\n  RETURN (visited s)\n}\""], ["", "lemma find_reachable_impl_refine: \n  \"find_reachable_impl G \\<le> \\<Down>Id (find_reachable G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. find_reachable_impl G \\<le> \\<Down> Id (find_reachable G)", "unfolding find_reachable_impl_def find_reachable_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ASSERT (fb_graph G) \\<bind>\n    (\\<lambda>_.\n        tailrec_impl_defs.tailrec_impl G\n         (gen_param_dfs_defs.gds (pre_simple_impl.gbs G)\n           unit_parametrization simple_state.more_update) \\<bind>\n        (\\<lambda>s. RETURN (visited s)))\n    \\<le> \\<Down> Id\n           (ASSERT (fb_graph G) \\<bind>\n            (\\<lambda>_.\n                param_DFS_defs.it_dfs G unit_parametrization \\<bind>\n                (\\<lambda>s. RETURN (dom (discovered s)))))", "apply (refine_vcg unit_DFS.impl_refine)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>fb_graph G; fb_graph G\\<rbrakk> \\<Longrightarrow> unit_DFS G\n 2. \\<And>s sa.\n       \\<lbrakk>fb_graph G; fb_graph G;\n        (s, sa) \\<in> \\<langle>unit_rel\\<rangle>simple_state_rel\\<rbrakk>\n       \\<Longrightarrow> (visited s, dom (discovered sa)) \\<in> Id", "apply (simp_all add: unit_DFSI simple_state_rel_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma find_reachable_implT_refine: \n  \"find_reachable_implT G \\<le> \\<Down>Id (find_reachableT G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. find_reachable_implT G \\<le> \\<Down> Id (find_reachableT G)", "unfolding find_reachable_implT_def find_reachableT_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ASSERT (fb_graph G) \\<bind>\n    (\\<lambda>_.\n        tailrec_impl_defs.tailrec_implT G\n         (gen_param_dfs_defs.gds (pre_simple_impl.gbs G)\n           unit_parametrization simple_state.more_update) \\<bind>\n        (\\<lambda>s. RETURN (visited s)))\n    \\<le> \\<Down> Id\n           (ASSERT (fb_graph G) \\<bind>\n            (\\<lambda>_.\n                param_DFS_defs.it_dfsT G unit_parametrization \\<bind>\n                (\\<lambda>s. RETURN (dom (discovered s)))))", "apply (refine_vcg unit_DFS.impl_refine)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>fb_graph G; fb_graph G\\<rbrakk> \\<Longrightarrow> unit_DFS G\n 2. \\<And>s sa.\n       \\<lbrakk>fb_graph G; fb_graph G;\n        (s, sa) \\<in> \\<langle>unit_rel\\<rangle>simple_state_rel\\<rbrakk>\n       \\<Longrightarrow> (visited s, dom (discovered sa)) \\<in> Id", "apply (simp_all add: unit_DFSI simple_state_rel_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma find_reachable_rec_impl_refine: \n  \"find_reachable_rec_impl G \\<le> \\<Down>Id (find_reachable G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. find_reachable_rec_impl G \\<le> \\<Down> Id (find_reachable G)", "unfolding find_reachable_rec_impl_def find_reachable_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ASSERT (fb_graph G) \\<bind>\n    (\\<lambda>_.\n        rec_impl_defs.rec_impl G\n         (gen_param_dfs_defs.gds (pre_simple_impl.gbs G)\n           unit_parametrization simple_state.more_update)\n         unit_simple_impl.get_pending unit_simple_impl.get_stack\n         unit_simple_impl.choose_pending \\<bind>\n        (\\<lambda>s. RETURN (visited s)))\n    \\<le> \\<Down> Id\n           (ASSERT (fb_graph G) \\<bind>\n            (\\<lambda>_.\n                param_DFS_defs.it_dfs G unit_parametrization \\<bind>\n                (\\<lambda>s. RETURN (dom (discovered s)))))", "apply (refine_vcg unit_DFS.impl_refine)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>fb_graph G; fb_graph G\\<rbrakk> \\<Longrightarrow> unit_DFS G\n 2. \\<And>s sa.\n       \\<lbrakk>fb_graph G; fb_graph G;\n        (s, sa) \\<in> \\<langle>unit_rel\\<rangle>simple_state_rel\\<rbrakk>\n       \\<Longrightarrow> (visited s, dom (discovered sa)) \\<in> Id", "apply (simp_all add: unit_DFSI simple_state_rel_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \\<open>Synthesis of Executable Implementation\\<close>"], ["", "(* Autoref *)"], ["", "schematic_goal find_reachable_impl:\n  defines \"V \\<equiv> Id :: ('v \\<times> 'v::hashable) set\"\n  assumes [unfolded V_def,autoref_rules]: \n    \"(Gi, G) \\<in> \\<langle>Rm, V\\<rangle>g_impl_rel_ext\"\n  notes [unfolded V_def,autoref_tyrel] = \n    TYRELI[where R=\"\\<langle>V\\<rangle>dflt_ahs_rel\"]\n    TYRELI[where R=\"\\<langle>V \\<times>\\<^sub>r \\<langle>V\\<rangle>list_set_rel\\<rangle>ras_rel\"]\n  shows \"nres_of (?c::?'c dres) \\<le>\\<Down>?R (find_reachable_impl G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nres_of ?c \\<le> \\<Down> ?R (find_reachable_impl G)", "unfolding if_cancel DFS_code_unfold ssnos_unfolds"], ["proof (prove)\ngoal (1 subgoal):\n 1. nres_of ?c\n    \\<le> \\<Down> ?R\n           (ASSERT (fb_graph G) \\<bind>\n            (\\<lambda>_.\n                RETURN () \\<bind>\n                (\\<lambda>e.\n                    RETURN\n                     \\<lparr>ss_stack = [], on_stack = {}, visited = {},\n                        \\<dots> = e\\<rparr>) \\<bind>\n                FOREACH\\<^sub>C\\<^bsup>\\<lambda>it s.\n    rwof\n     (RETURN () \\<bind>\n      (\\<lambda>e.\n          RETURN\n           \\<lparr>ss_stack = [], on_stack = {}, visited = {},\n              \\<dots> = e\\<rparr>))\n     (gen_dfs_defs.gen_cond\n       (gen_param_dfs_defs.gds (pre_simple_impl.gbs G) unit_parametrization\n         simple_state.more_update)\n       (g_V0 G))\n     (gen_dfs_defs.gen_step\n       (gen_param_dfs_defs.gds (pre_simple_impl.gbs G) unit_parametrization\n         simple_state.more_update)\n       (g_V0 G))\n     s \\<and>\n    (\\<not> False \\<longrightarrow> ss_stack s = []) \\<and>\n    g_V0 G - it \\<subseteq> {v. v \\<in> visited s}\\<^esup>\n                 (g_V0 G) (\\<lambda>x. \\<not> False)\n                 (\\<lambda>v0 s.\n                     let s0 = s\n                     in if v0 \\<in> visited s then RETURN s\n                        else ASSERT (v0 \\<notin> visited s) \\<bind>\n                             (\\<lambda>_.\n                                 let s = s\n \\<lparr>ss_stack := [(v0, g_E G `` {v0})]\\<rparr>;\n                                     s =\n op_nos_on_stack_update (\\<lambda>_. {v0}) s\n                                 in Let (s\n   \\<lparr>visited := insert v0 (visited s)\\<rparr>)\n                                     RETURN) \\<bind>\n                             (\\<lambda>s.\n                                 RETURN () \\<bind>\n                                 (\\<lambda>e.\n                                     RETURN\n(s\\<lparr>simple_state.more := e\\<rparr>))) \\<bind>\n                             WHILE\\<^bsup>\\<lambda>s.\n       rwof\n        (RETURN () \\<bind>\n         (\\<lambda>e.\n             RETURN\n              \\<lparr>ss_stack = [], on_stack = {}, visited = {},\n                 \\<dots> = e\\<rparr>))\n        (gen_dfs_defs.gen_cond\n          (gen_param_dfs_defs.gds (pre_simple_impl.gbs G)\n            unit_parametrization simple_state.more_update)\n          (g_V0 G))\n        (gen_dfs_defs.gen_step\n          (gen_param_dfs_defs.gds (pre_simple_impl.gbs G)\n            unit_parametrization simple_state.more_update)\n          (g_V0 G))\n        s \\<and>\n       insert v0 {v. v \\<in> visited s0}\n       \\<subseteq> {v. v \\<in> visited s}\\<^esup>\n                              (\\<lambda>s.\n                                  \\<not> False \\<and>\n                                  ss_stack s \\<noteq> [])\n                              (\\<lambda>s.\n                                  ASSERT (ss_stack s \\<noteq> []) \\<bind>\n                                  (\\<lambda>_.\nlet (u, Vs) = hd (ss_stack s)\nin if Vs = {} then RETURN (u, None, s)\n   else SPEC (\\<lambda>v. v \\<in> Vs) \\<bind>\n        (\\<lambda>v.\n            let Vs = Vs - {v};\n                s = s\\<lparr>ss_stack := (u, Vs) # tl (ss_stack s)\\<rparr>\n            in RETURN (u, Some v, s))) \\<bind>\n                                  (\\<lambda>(u, Vs, s).\ncase Vs of\nNone \\<Rightarrow>\n  ASSERT (ss_stack s \\<noteq> [] \\<and> u \\<in> on_stack s) \\<bind>\n  (\\<lambda>_.\n      let s = s\\<lparr>ss_stack := tl (ss_stack s)\\<rparr>\n      in Let (op_nos_on_stack_update (\\<lambda>_. on_stack s - {u}) s)\n          RETURN) \\<bind>\n  (\\<lambda>s.\n      RETURN () \\<bind>\n      (\\<lambda>e. RETURN (s\\<lparr>simple_state.more := e\\<rparr>)))\n| Some v \\<Rightarrow>\n    if v \\<in> visited s\n    then RETURN s \\<bind>\n         (\\<lambda>s.\n             RETURN () \\<bind>\n             (\\<lambda>e. RETURN (s\\<lparr>simple_state.more := e\\<rparr>)))\n    else ASSERT (v \\<notin> on_stack s \\<and> v \\<notin> visited s) \\<bind>\n         (\\<lambda>_.\n             let s = s\\<lparr>ss_stack :=\n                                (v, g_E G `` {v}) # ss_stack s\\<rparr>;\n                 s = op_nos_on_stack_update\n                      (\\<lambda>_. insert v (on_stack s)) s\n             in Let (s\\<lparr>visited := insert v (visited s)\\<rparr>)\n                 RETURN) \\<bind>\n         (\\<lambda>s.\n             RETURN () \\<bind>\n             (\\<lambda>e.\n                 RETURN\n                  (s\\<lparr>simple_state.more := e\\<rparr>)))))) \\<bind>\n                (\\<lambda>s. RETURN (visited s))))", "using [[autoref_trace_failed_id, goals_limit=1]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. nres_of ?c\n    \\<le> \\<Down> ?R\n           (ASSERT (fb_graph G) \\<bind>\n            (\\<lambda>_.\n                RETURN () \\<bind>\n                (\\<lambda>e.\n                    RETURN\n                     \\<lparr>ss_stack = [], on_stack = {}, visited = {},\n                        \\<dots> = e\\<rparr>) \\<bind>\n                FOREACH\\<^sub>C\\<^bsup>\\<lambda>it s.\n    rwof\n     (RETURN () \\<bind>\n      (\\<lambda>e.\n          RETURN\n           \\<lparr>ss_stack = [], on_stack = {}, visited = {},\n              \\<dots> = e\\<rparr>))\n     (gen_dfs_defs.gen_cond\n       (gen_param_dfs_defs.gds (pre_simple_impl.gbs G) unit_parametrization\n         simple_state.more_update)\n       (g_V0 G))\n     (gen_dfs_defs.gen_step\n       (gen_param_dfs_defs.gds (pre_simple_impl.gbs G) unit_parametrization\n         simple_state.more_update)\n       (g_V0 G))\n     s \\<and>\n    (\\<not> False \\<longrightarrow> ss_stack s = []) \\<and>\n    g_V0 G - it \\<subseteq> {v. v \\<in> visited s}\\<^esup>\n                 (g_V0 G) (\\<lambda>x. \\<not> False)\n                 (\\<lambda>v0 s.\n                     let s0 = s\n                     in if v0 \\<in> visited s then RETURN s\n                        else ASSERT (v0 \\<notin> visited s) \\<bind>\n                             (\\<lambda>_.\n                                 let s = s\n \\<lparr>ss_stack := [(v0, g_E G `` {v0})]\\<rparr>;\n                                     s =\n op_nos_on_stack_update (\\<lambda>_. {v0}) s\n                                 in Let (s\n   \\<lparr>visited := insert v0 (visited s)\\<rparr>)\n                                     RETURN) \\<bind>\n                             (\\<lambda>s.\n                                 RETURN () \\<bind>\n                                 (\\<lambda>e.\n                                     RETURN\n(s\\<lparr>simple_state.more := e\\<rparr>))) \\<bind>\n                             WHILE\\<^bsup>\\<lambda>s.\n       rwof\n        (RETURN () \\<bind>\n         (\\<lambda>e.\n             RETURN\n              \\<lparr>ss_stack = [], on_stack = {}, visited = {},\n                 \\<dots> = e\\<rparr>))\n        (gen_dfs_defs.gen_cond\n          (gen_param_dfs_defs.gds (pre_simple_impl.gbs G)\n            unit_parametrization simple_state.more_update)\n          (g_V0 G))\n        (gen_dfs_defs.gen_step\n          (gen_param_dfs_defs.gds (pre_simple_impl.gbs G)\n            unit_parametrization simple_state.more_update)\n          (g_V0 G))\n        s \\<and>\n       insert v0 {v. v \\<in> visited s0}\n       \\<subseteq> {v. v \\<in> visited s}\\<^esup>\n                              (\\<lambda>s.\n                                  \\<not> False \\<and>\n                                  ss_stack s \\<noteq> [])\n                              (\\<lambda>s.\n                                  ASSERT (ss_stack s \\<noteq> []) \\<bind>\n                                  (\\<lambda>_.\nlet (u, Vs) = hd (ss_stack s)\nin if Vs = {} then RETURN (u, None, s)\n   else SPEC (\\<lambda>v. v \\<in> Vs) \\<bind>\n        (\\<lambda>v.\n            let Vs = Vs - {v};\n                s = s\\<lparr>ss_stack := (u, Vs) # tl (ss_stack s)\\<rparr>\n            in RETURN (u, Some v, s))) \\<bind>\n                                  (\\<lambda>(u, Vs, s).\ncase Vs of\nNone \\<Rightarrow>\n  ASSERT (ss_stack s \\<noteq> [] \\<and> u \\<in> on_stack s) \\<bind>\n  (\\<lambda>_.\n      let s = s\\<lparr>ss_stack := tl (ss_stack s)\\<rparr>\n      in Let (op_nos_on_stack_update (\\<lambda>_. on_stack s - {u}) s)\n          RETURN) \\<bind>\n  (\\<lambda>s.\n      RETURN () \\<bind>\n      (\\<lambda>e. RETURN (s\\<lparr>simple_state.more := e\\<rparr>)))\n| Some v \\<Rightarrow>\n    if v \\<in> visited s\n    then RETURN s \\<bind>\n         (\\<lambda>s.\n             RETURN () \\<bind>\n             (\\<lambda>e. RETURN (s\\<lparr>simple_state.more := e\\<rparr>)))\n    else ASSERT (v \\<notin> on_stack s \\<and> v \\<notin> visited s) \\<bind>\n         (\\<lambda>_.\n             let s = s\\<lparr>ss_stack :=\n                                (v, g_E G `` {v}) # ss_stack s\\<rparr>;\n                 s = op_nos_on_stack_update\n                      (\\<lambda>_. insert v (on_stack s)) s\n             in Let (s\\<lparr>visited := insert v (visited s)\\<rparr>)\n                 RETURN) \\<bind>\n         (\\<lambda>s.\n             RETURN () \\<bind>\n             (\\<lambda>e.\n                 RETURN\n                  (s\\<lparr>simple_state.more := e\\<rparr>)))))) \\<bind>\n                (\\<lambda>s. RETURN (visited s))))", "apply (autoref_monadic (trace))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "concrete_definition find_reachable_code uses find_reachable_impl"], ["", "export_code find_reachable_code checking SML"], ["", "lemma find_reachable_code_correct:\n  assumes 1: \"fb_graph G\"\n  assumes 2: \"(Gi, G) \\<in> \\<langle>Rm, Id\\<rangle>g_impl_rel_ext\"\n  assumes 4: \"find_reachable_code Gi = dRETURN r\"\n  shows \"(r, (g_E G)\\<^sup>* `` g_V0 G)\\<in>\\<langle>Id\\<rangle>dflt_ahs_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (r, (g_E G)\\<^sup>* `` g_V0 G)\n    \\<in> \\<langle>Id\\<rangle>ahs_rel bounded_hashcode_nat", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (r, (g_E G)\\<^sup>* `` g_V0 G)\n    \\<in> \\<langle>Id\\<rangle>ahs_rel bounded_hashcode_nat", "from 1"], ["proof (chain)\npicking this:\n  fb_graph G", "interpret unit_DFS"], ["proof (prove)\nusing this:\n  fb_graph G\n\ngoal (1 subgoal):\n 1. unit_DFS G", "by rule"], ["proof (state)\ngoal (1 subgoal):\n 1. (r, (g_E G)\\<^sup>* `` g_V0 G)\n    \\<in> \\<langle>Id\\<rangle>ahs_rel bounded_hashcode_nat", "note find_reachable_code.refine[OF 2]"], ["proof (state)\nthis:\n  nres_of (find_reachable_code Gi)\n  \\<le> \\<Down> (\\<langle>Id\\<rangle>ahs_rel bounded_hashcode_nat)\n         (find_reachable_impl G)\n\ngoal (1 subgoal):\n 1. (r, (g_E G)\\<^sup>* `` g_V0 G)\n    \\<in> \\<langle>Id\\<rangle>ahs_rel bounded_hashcode_nat", "also"], ["proof (state)\nthis:\n  nres_of (find_reachable_code Gi)\n  \\<le> \\<Down> (\\<langle>Id\\<rangle>ahs_rel bounded_hashcode_nat)\n         (find_reachable_impl G)\n\ngoal (1 subgoal):\n 1. (r, (g_E G)\\<^sup>* `` g_V0 G)\n    \\<in> \\<langle>Id\\<rangle>ahs_rel bounded_hashcode_nat", "note find_reachable_impl_refine"], ["proof (state)\nthis:\n  find_reachable_impl ?G \\<le> \\<Down> Id (find_reachable ?G)\n\ngoal (1 subgoal):\n 1. (r, (g_E G)\\<^sup>* `` g_V0 G)\n    \\<in> \\<langle>Id\\<rangle>ahs_rel bounded_hashcode_nat", "also"], ["proof (state)\nthis:\n  find_reachable_impl ?G \\<le> \\<Down> Id (find_reachable ?G)\n\ngoal (1 subgoal):\n 1. (r, (g_E G)\\<^sup>* `` g_V0 G)\n    \\<in> \\<langle>Id\\<rangle>ahs_rel bounded_hashcode_nat", "note find_reachable_correct"], ["proof (state)\nthis:\n  find_reachable G \\<le> SPEC (\\<lambda>r. r = (g_E G)\\<^sup>* `` g_V0 G)\n\ngoal (1 subgoal):\n 1. (r, (g_E G)\\<^sup>* `` g_V0 G)\n    \\<in> \\<langle>Id\\<rangle>ahs_rel bounded_hashcode_nat", "finally"], ["proof (chain)\npicking this:\n  nres_of (find_reachable_code Gi)\n  \\<le> \\<Down> (\\<langle>Id\\<rangle>ahs_rel bounded_hashcode_nat)\n         (SPEC (\\<lambda>r. r = (g_E G)\\<^sup>* `` g_V0 G))", "show ?thesis"], ["proof (prove)\nusing this:\n  nres_of (find_reachable_code Gi)\n  \\<le> \\<Down> (\\<langle>Id\\<rangle>ahs_rel bounded_hashcode_nat)\n         (SPEC (\\<lambda>r. r = (g_E G)\\<^sup>* `` g_V0 G))\n\ngoal (1 subgoal):\n 1. (r, (g_E G)\\<^sup>* `` g_V0 G)\n    \\<in> \\<langle>Id\\<rangle>ahs_rel bounded_hashcode_nat", "using 1 4"], ["proof (prove)\nusing this:\n  nres_of (find_reachable_code Gi)\n  \\<le> \\<Down> (\\<langle>Id\\<rangle>ahs_rel bounded_hashcode_nat)\n         (SPEC (\\<lambda>r. r = (g_E G)\\<^sup>* `` g_V0 G))\n  fb_graph G\n  find_reachable_code Gi = dRETURN r\n\ngoal (1 subgoal):\n 1. (r, (g_E G)\\<^sup>* `` g_V0 G)\n    \\<in> \\<langle>Id\\<rangle>ahs_rel bounded_hashcode_nat", "by (auto simp: RETURN_RES_refine_iff)"], ["proof (state)\nthis:\n  (r, (g_E G)\\<^sup>* `` g_V0 G)\n  \\<in> \\<langle>Id\\<rangle>ahs_rel bounded_hashcode_nat\n\ngoal:\nNo subgoals!", "qed"], ["", "schematic_goal find_reachable_implT:\n  fixes V :: \"('vi\\<times>'v) set\"\n  assumes [autoref_ga_rules]: \"is_bounded_hashcode V eq bhc\"\n  assumes [autoref_rules]: \"(eq,(=)) \\<in> V \\<rightarrow> V \\<rightarrow> bool_rel\"\n  assumes [autoref_ga_rules]: \"is_valid_def_hm_size TYPE ('vi) sz\"\n  assumes [autoref_rules]: \n    \"(Gi, G) \\<in> \\<langle>Rm, V\\<rangle>g_impl_rel_ext\"\n  notes [autoref_tyrel] = \n    TYRELI[where R=\"\\<langle>V\\<rangle>ahs_rel bhc\"]\n    TYRELI[where R=\"\\<langle>V \\<times>\\<^sub>r \\<langle>V\\<rangle>list_set_rel\\<rangle>ras_rel\"]\n  shows \"RETURN (?c::?'c) \\<le>\\<Down>?R (find_reachable_implT G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RETURN ?c \\<le> \\<Down> ?R (find_reachable_implT G)", "unfolding if_cancel DFS_code_unfold ssnos_unfolds"], ["proof (prove)\ngoal (1 subgoal):\n 1. RETURN ?c\n    \\<le> \\<Down> ?R\n           (ASSERT (fb_graph G) \\<bind>\n            (\\<lambda>_.\n                RETURN () \\<bind>\n                (\\<lambda>e.\n                    RETURN\n                     \\<lparr>ss_stack = [], on_stack = {}, visited = {},\n                        \\<dots> = e\\<rparr>) \\<bind>\n                FOREACH\\<^sub>C\\<^bsup>\\<lambda>it s.\n    rwof\n     (RETURN () \\<bind>\n      (\\<lambda>e.\n          RETURN\n           \\<lparr>ss_stack = [], on_stack = {}, visited = {},\n              \\<dots> = e\\<rparr>))\n     (gen_dfs_defs.gen_cond\n       (gen_param_dfs_defs.gds (pre_simple_impl.gbs G) unit_parametrization\n         simple_state.more_update)\n       (g_V0 G))\n     (gen_dfs_defs.gen_step\n       (gen_param_dfs_defs.gds (pre_simple_impl.gbs G) unit_parametrization\n         simple_state.more_update)\n       (g_V0 G))\n     s \\<and>\n    (\\<not> False \\<longrightarrow> ss_stack s = []) \\<and>\n    g_V0 G - it \\<subseteq> {v. v \\<in> visited s}\\<^esup>\n                 (g_V0 G) (\\<lambda>x. \\<not> False)\n                 (\\<lambda>v0 s.\n                     let s0 = s\n                     in if v0 \\<in> visited s then RETURN s\n                        else ASSERT (v0 \\<notin> visited s) \\<bind>\n                             (\\<lambda>_.\n                                 let s = s\n \\<lparr>ss_stack := [(v0, g_E G `` {v0})]\\<rparr>;\n                                     s =\n op_nos_on_stack_update (\\<lambda>_. {v0}) s\n                                 in Let (s\n   \\<lparr>visited := insert v0 (visited s)\\<rparr>)\n                                     RETURN) \\<bind>\n                             (\\<lambda>s.\n                                 RETURN () \\<bind>\n                                 (\\<lambda>e.\n                                     RETURN\n(s\\<lparr>simple_state.more := e\\<rparr>))) \\<bind>\n                             WHILE\\<^sub>T\\<^bsup>\\<lambda>s.\n               rwof\n                (RETURN () \\<bind>\n                 (\\<lambda>e.\n                     RETURN\n                      \\<lparr>ss_stack = [], on_stack = {}, visited = {},\n                         \\<dots> = e\\<rparr>))\n                (gen_dfs_defs.gen_cond\n                  (gen_param_dfs_defs.gds (pre_simple_impl.gbs G)\n                    unit_parametrization simple_state.more_update)\n                  (g_V0 G))\n                (gen_dfs_defs.gen_step\n                  (gen_param_dfs_defs.gds (pre_simple_impl.gbs G)\n                    unit_parametrization simple_state.more_update)\n                  (g_V0 G))\n                s \\<and>\n               insert v0 {v. v \\<in> visited s0}\n               \\<subseteq> {v. v \\<in> visited s}\\<^esup>\n                              (\\<lambda>s.\n                                  \\<not> False \\<and>\n                                  ss_stack s \\<noteq> [])\n                              (\\<lambda>s.\n                                  ASSERT (ss_stack s \\<noteq> []) \\<bind>\n                                  (\\<lambda>_.\nlet (u, Vs) = hd (ss_stack s)\nin if Vs = {} then RETURN (u, None, s)\n   else SPEC (\\<lambda>v. v \\<in> Vs) \\<bind>\n        (\\<lambda>v.\n            let Vs = Vs - {v};\n                s = s\\<lparr>ss_stack := (u, Vs) # tl (ss_stack s)\\<rparr>\n            in RETURN (u, Some v, s))) \\<bind>\n                                  (\\<lambda>(u, Vs, s).\ncase Vs of\nNone \\<Rightarrow>\n  ASSERT (ss_stack s \\<noteq> [] \\<and> u \\<in> on_stack s) \\<bind>\n  (\\<lambda>_.\n      let s = s\\<lparr>ss_stack := tl (ss_stack s)\\<rparr>\n      in Let (op_nos_on_stack_update (\\<lambda>_. on_stack s - {u}) s)\n          RETURN) \\<bind>\n  (\\<lambda>s.\n      RETURN () \\<bind>\n      (\\<lambda>e. RETURN (s\\<lparr>simple_state.more := e\\<rparr>)))\n| Some v \\<Rightarrow>\n    if v \\<in> visited s\n    then RETURN s \\<bind>\n         (\\<lambda>s.\n             RETURN () \\<bind>\n             (\\<lambda>e. RETURN (s\\<lparr>simple_state.more := e\\<rparr>)))\n    else ASSERT (v \\<notin> on_stack s \\<and> v \\<notin> visited s) \\<bind>\n         (\\<lambda>_.\n             let s = s\\<lparr>ss_stack :=\n                                (v, g_E G `` {v}) # ss_stack s\\<rparr>;\n                 s = op_nos_on_stack_update\n                      (\\<lambda>_. insert v (on_stack s)) s\n             in Let (s\\<lparr>visited := insert v (visited s)\\<rparr>)\n                 RETURN) \\<bind>\n         (\\<lambda>s.\n             RETURN () \\<bind>\n             (\\<lambda>e.\n                 RETURN\n                  (s\\<lparr>simple_state.more := e\\<rparr>)))))) \\<bind>\n                (\\<lambda>s. RETURN (visited s))))", "using [[autoref_trace_failed_id, goals_limit=1]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. RETURN ?c\n    \\<le> \\<Down> ?R\n           (ASSERT (fb_graph G) \\<bind>\n            (\\<lambda>_.\n                RETURN () \\<bind>\n                (\\<lambda>e.\n                    RETURN\n                     \\<lparr>ss_stack = [], on_stack = {}, visited = {},\n                        \\<dots> = e\\<rparr>) \\<bind>\n                FOREACH\\<^sub>C\\<^bsup>\\<lambda>it s.\n    rwof\n     (RETURN () \\<bind>\n      (\\<lambda>e.\n          RETURN\n           \\<lparr>ss_stack = [], on_stack = {}, visited = {},\n              \\<dots> = e\\<rparr>))\n     (gen_dfs_defs.gen_cond\n       (gen_param_dfs_defs.gds (pre_simple_impl.gbs G) unit_parametrization\n         simple_state.more_update)\n       (g_V0 G))\n     (gen_dfs_defs.gen_step\n       (gen_param_dfs_defs.gds (pre_simple_impl.gbs G) unit_parametrization\n         simple_state.more_update)\n       (g_V0 G))\n     s \\<and>\n    (\\<not> False \\<longrightarrow> ss_stack s = []) \\<and>\n    g_V0 G - it \\<subseteq> {v. v \\<in> visited s}\\<^esup>\n                 (g_V0 G) (\\<lambda>x. \\<not> False)\n                 (\\<lambda>v0 s.\n                     let s0 = s\n                     in if v0 \\<in> visited s then RETURN s\n                        else ASSERT (v0 \\<notin> visited s) \\<bind>\n                             (\\<lambda>_.\n                                 let s = s\n \\<lparr>ss_stack := [(v0, g_E G `` {v0})]\\<rparr>;\n                                     s =\n op_nos_on_stack_update (\\<lambda>_. {v0}) s\n                                 in Let (s\n   \\<lparr>visited := insert v0 (visited s)\\<rparr>)\n                                     RETURN) \\<bind>\n                             (\\<lambda>s.\n                                 RETURN () \\<bind>\n                                 (\\<lambda>e.\n                                     RETURN\n(s\\<lparr>simple_state.more := e\\<rparr>))) \\<bind>\n                             WHILE\\<^sub>T\\<^bsup>\\<lambda>s.\n               rwof\n                (RETURN () \\<bind>\n                 (\\<lambda>e.\n                     RETURN\n                      \\<lparr>ss_stack = [], on_stack = {}, visited = {},\n                         \\<dots> = e\\<rparr>))\n                (gen_dfs_defs.gen_cond\n                  (gen_param_dfs_defs.gds (pre_simple_impl.gbs G)\n                    unit_parametrization simple_state.more_update)\n                  (g_V0 G))\n                (gen_dfs_defs.gen_step\n                  (gen_param_dfs_defs.gds (pre_simple_impl.gbs G)\n                    unit_parametrization simple_state.more_update)\n                  (g_V0 G))\n                s \\<and>\n               insert v0 {v. v \\<in> visited s0}\n               \\<subseteq> {v. v \\<in> visited s}\\<^esup>\n                              (\\<lambda>s.\n                                  \\<not> False \\<and>\n                                  ss_stack s \\<noteq> [])\n                              (\\<lambda>s.\n                                  ASSERT (ss_stack s \\<noteq> []) \\<bind>\n                                  (\\<lambda>_.\nlet (u, Vs) = hd (ss_stack s)\nin if Vs = {} then RETURN (u, None, s)\n   else SPEC (\\<lambda>v. v \\<in> Vs) \\<bind>\n        (\\<lambda>v.\n            let Vs = Vs - {v};\n                s = s\\<lparr>ss_stack := (u, Vs) # tl (ss_stack s)\\<rparr>\n            in RETURN (u, Some v, s))) \\<bind>\n                                  (\\<lambda>(u, Vs, s).\ncase Vs of\nNone \\<Rightarrow>\n  ASSERT (ss_stack s \\<noteq> [] \\<and> u \\<in> on_stack s) \\<bind>\n  (\\<lambda>_.\n      let s = s\\<lparr>ss_stack := tl (ss_stack s)\\<rparr>\n      in Let (op_nos_on_stack_update (\\<lambda>_. on_stack s - {u}) s)\n          RETURN) \\<bind>\n  (\\<lambda>s.\n      RETURN () \\<bind>\n      (\\<lambda>e. RETURN (s\\<lparr>simple_state.more := e\\<rparr>)))\n| Some v \\<Rightarrow>\n    if v \\<in> visited s\n    then RETURN s \\<bind>\n         (\\<lambda>s.\n             RETURN () \\<bind>\n             (\\<lambda>e. RETURN (s\\<lparr>simple_state.more := e\\<rparr>)))\n    else ASSERT (v \\<notin> on_stack s \\<and> v \\<notin> visited s) \\<bind>\n         (\\<lambda>_.\n             let s = s\\<lparr>ss_stack :=\n                                (v, g_E G `` {v}) # ss_stack s\\<rparr>;\n                 s = op_nos_on_stack_update\n                      (\\<lambda>_. insert v (on_stack s)) s\n             in Let (s\\<lparr>visited := insert v (visited s)\\<rparr>)\n                 RETURN) \\<bind>\n         (\\<lambda>s.\n             RETURN () \\<bind>\n             (\\<lambda>e.\n                 RETURN\n                  (s\\<lparr>simple_state.more := e\\<rparr>)))))) \\<bind>\n                (\\<lambda>s. RETURN (visited s))))", "apply (autoref_monadic (plain,trace))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "concrete_definition find_reachable_codeT for eq bhc sz Gi \n  uses find_reachable_implT"], ["", "export_code find_reachable_codeT checking SML"], ["", "lemma find_reachable_codeT_correct:\n  fixes V :: \"('vi\\<times>'v) set\"\n  assumes G: \"graph G\"\n  assumes FR: \"finite ((g_E G)\\<^sup>* `` g_V0 G)\"\n  assumes BHC: \"is_bounded_hashcode V eq bhc\"\n  assumes EQ: \"(eq,(=)) \\<in> V \\<rightarrow> V \\<rightarrow> bool_rel\"\n  assumes VDS: \"is_valid_def_hm_size TYPE ('vi) sz\"\n  assumes 2: \"(Gi, G) \\<in> \\<langle>Rm, V\\<rangle>g_impl_rel_ext\"\n  shows \"(find_reachable_codeT eq bhc sz Gi, (g_E G)\\<^sup>* `` g_V0 G)\\<in>\\<langle>V\\<rangle>ahs_rel bhc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (find_reachable_codeT eq bhc sz Gi, (g_E G)\\<^sup>* `` g_V0 G)\n    \\<in> \\<langle>V\\<rangle>ahs_rel bhc", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (find_reachable_codeT eq bhc sz Gi, (g_E G)\\<^sup>* `` g_V0 G)\n    \\<in> \\<langle>V\\<rangle>ahs_rel bhc", "from G"], ["proof (chain)\npicking this:\n  graph G", "interpret graph"], ["proof (prove)\nusing this:\n  graph G\n\ngoal (1 subgoal):\n 1. graph G", "by this"], ["proof (state)\ngoal (1 subgoal):\n 1. (find_reachable_codeT eq bhc sz Gi, (g_E G)\\<^sup>* `` g_V0 G)\n    \\<in> \\<langle>V\\<rangle>ahs_rel bhc", "from FR"], ["proof (chain)\npicking this:\n  finite ((g_E G)\\<^sup>* `` g_V0 G)", "interpret fb_graph"], ["proof (prove)\nusing this:\n  finite ((g_E G)\\<^sup>* `` g_V0 G)\n\ngoal (1 subgoal):\n 1. fb_graph G", "using fb_graphI_fr"], ["proof (prove)\nusing this:\n  finite ((g_E G)\\<^sup>* `` g_V0 G)\n  finite ((g_E G)\\<^sup>* `` g_V0 G) \\<Longrightarrow> fb_graph G\n\ngoal (1 subgoal):\n 1. fb_graph G", "by simp"], ["proof (state)\ngoal (1 subgoal):\n 1. (find_reachable_codeT eq bhc sz Gi, (g_E G)\\<^sup>* `` g_V0 G)\n    \\<in> \\<langle>V\\<rangle>ahs_rel bhc", "interpret unit_DFS"], ["proof (prove)\ngoal (1 subgoal):\n 1. unit_DFS G", "by unfold_locales"], ["proof (state)\ngoal (1 subgoal):\n 1. (find_reachable_codeT eq bhc sz Gi, (g_E G)\\<^sup>* `` g_V0 G)\n    \\<in> \\<langle>V\\<rangle>ahs_rel bhc", "note find_reachable_codeT.refine[OF BHC EQ VDS 2]"], ["proof (state)\nthis:\n  RETURN (find_reachable_codeT eq bhc sz Gi)\n  \\<le> \\<Down> (\\<langle>V\\<rangle>ahs_rel bhc) (find_reachable_implT G)\n\ngoal (1 subgoal):\n 1. (find_reachable_codeT eq bhc sz Gi, (g_E G)\\<^sup>* `` g_V0 G)\n    \\<in> \\<langle>V\\<rangle>ahs_rel bhc", "also"], ["proof (state)\nthis:\n  RETURN (find_reachable_codeT eq bhc sz Gi)\n  \\<le> \\<Down> (\\<langle>V\\<rangle>ahs_rel bhc) (find_reachable_implT G)\n\ngoal (1 subgoal):\n 1. (find_reachable_codeT eq bhc sz Gi, (g_E G)\\<^sup>* `` g_V0 G)\n    \\<in> \\<langle>V\\<rangle>ahs_rel bhc", "note find_reachable_implT_refine"], ["proof (state)\nthis:\n  find_reachable_implT ?G \\<le> \\<Down> Id (find_reachableT ?G)\n\ngoal (1 subgoal):\n 1. (find_reachable_codeT eq bhc sz Gi, (g_E G)\\<^sup>* `` g_V0 G)\n    \\<in> \\<langle>V\\<rangle>ahs_rel bhc", "also"], ["proof (state)\nthis:\n  find_reachable_implT ?G \\<le> \\<Down> Id (find_reachableT ?G)\n\ngoal (1 subgoal):\n 1. (find_reachable_codeT eq bhc sz Gi, (g_E G)\\<^sup>* `` g_V0 G)\n    \\<in> \\<langle>V\\<rangle>ahs_rel bhc", "note find_reachableT_correct"], ["proof (state)\nthis:\n  finite ((g_E G)\\<^sup>* `` g_V0 G) \\<Longrightarrow>\n  find_reachableT G \\<le> SPEC (\\<lambda>r. r = (g_E G)\\<^sup>* `` g_V0 G)\n\ngoal (1 subgoal):\n 1. (find_reachable_codeT eq bhc sz Gi, (g_E G)\\<^sup>* `` g_V0 G)\n    \\<in> \\<langle>V\\<rangle>ahs_rel bhc", "finally"], ["proof (chain)\npicking this:\n  finite ((g_E G)\\<^sup>* `` g_V0 G) \\<Longrightarrow>\n  RETURN (find_reachable_codeT eq bhc sz Gi)\n  \\<le> \\<Down> (\\<langle>V\\<rangle>ahs_rel bhc)\n         (SPEC (\\<lambda>r. r = (g_E G)\\<^sup>* `` g_V0 G))", "show ?thesis"], ["proof (prove)\nusing this:\n  finite ((g_E G)\\<^sup>* `` g_V0 G) \\<Longrightarrow>\n  RETURN (find_reachable_codeT eq bhc sz Gi)\n  \\<le> \\<Down> (\\<langle>V\\<rangle>ahs_rel bhc)\n         (SPEC (\\<lambda>r. r = (g_E G)\\<^sup>* `` g_V0 G))\n\ngoal (1 subgoal):\n 1. (find_reachable_codeT eq bhc sz Gi, (g_E G)\\<^sup>* `` g_V0 G)\n    \\<in> \\<langle>V\\<rangle>ahs_rel bhc", "using FR"], ["proof (prove)\nusing this:\n  finite ((g_E G)\\<^sup>* `` g_V0 G) \\<Longrightarrow>\n  RETURN (find_reachable_codeT eq bhc sz Gi)\n  \\<le> \\<Down> (\\<langle>V\\<rangle>ahs_rel bhc)\n         (SPEC (\\<lambda>r. r = (g_E G)\\<^sup>* `` g_V0 G))\n  finite ((g_E G)\\<^sup>* `` g_V0 G)\n\ngoal (1 subgoal):\n 1. (find_reachable_codeT eq bhc sz Gi, (g_E G)\\<^sup>* `` g_V0 G)\n    \\<in> \\<langle>V\\<rangle>ahs_rel bhc", "by (auto simp: RETURN_RES_refine_iff)"], ["proof (state)\nthis:\n  (find_reachable_codeT eq bhc sz Gi, (g_E G)\\<^sup>* `` g_V0 G)\n  \\<in> \\<langle>V\\<rangle>ahs_rel bhc\n\ngoal:\nNo subgoals!", "qed"], ["", "definition all_unit_rel :: \"(unit \\<times> 'a) set\" where \"all_unit_rel \\<equiv> UNIV\""], ["", "lemma all_unit_refine[simp]: \n  \"((),x)\\<in>all_unit_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((), x) \\<in> all_unit_rel", "unfolding all_unit_rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((), x) \\<in> UNIV", "by simp"], ["", "definition unit_list_rel :: \"('c\\<times>'a) set \\<Rightarrow> (unit \\<times> 'a list) set\"\n  where [to_relAPP]: \"unit_list_rel R \\<equiv> UNIV\""], ["", "lemma unit_list_rel_refine[simp]: \"((),y)\\<in>\\<langle>R\\<rangle>unit_list_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((), y) \\<in> \\<langle>R\\<rangle>unit_list_rel", "unfolding unit_list_rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((), y) \\<in> UNIV", "by auto"], ["", "lemmas [autoref_rel_intf] = REL_INTFI[of unit_list_rel i_list]"], ["", "lemma [autoref_rules]:\n  \"((),[])\\<in>\\<langle>R\\<rangle>unit_list_rel\"\n  \"(\\<lambda>_. (),tl)\\<in>\\<langle>R\\<rangle>unit_list_rel\\<rightarrow>\\<langle>R\\<rangle>unit_list_rel\"\n  \"(\\<lambda>_ _. (),(#))\\<in>R \\<rightarrow> \\<langle>R\\<rangle>unit_list_rel\\<rightarrow>\\<langle>R\\<rangle>unit_list_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((), []) \\<in> \\<langle>R\\<rangle>unit_list_rel &&&\n    (\\<lambda>_. (), tl)\n    \\<in> \\<langle>R\\<rangle>unit_list_rel \\<rightarrow>\n          \\<langle>R\\<rangle>unit_list_rel &&&\n    (\\<lambda>_ _. (), (#))\n    \\<in> R \\<rightarrow>\n          \\<langle>R\\<rangle>unit_list_rel \\<rightarrow>\n          \\<langle>R\\<rangle>unit_list_rel", "by auto"], ["", "schematic_goal find_reachable_rec_impl:\n  defines \"V \\<equiv> Id :: ('v \\<times> 'v::hashable) set\"\n  assumes [unfolded V_def,autoref_rules]: \n    \"(Gi, G) \\<in> \\<langle>Rm, V\\<rangle>g_impl_rel_ext\"\n  notes [unfolded V_def,autoref_tyrel] = \n    TYRELI[where R=\"\\<langle>V\\<rangle>dflt_ahs_rel\"]\n  shows \"nres_of (?c::?'c dres) \\<le>\\<Down>?R (find_reachable_rec_impl G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nres_of ?c \\<le> \\<Down> ?R (find_reachable_rec_impl G)", "unfolding unit_simple_impl.ssns_unfolds \n    DFS_code_unfold if_cancel if_False option.case"], ["proof (prove)\ngoal (1 subgoal):\n 1. nres_of ?c\n    \\<le> \\<Down> ?R\n           (ASSERT (fb_graph G) \\<bind>\n            (\\<lambda>_.\n                RETURN () \\<bind>\n                (\\<lambda>e.\n                    RETURN\n                     \\<lparr>ss_stack = [], on_stack = {}, visited = {},\n                        \\<dots> = e\\<rparr>) \\<bind>\n                FOREACH\\<^sub>C\\<^bsup>\\<lambda>it s.\n    rwof\n     (RETURN () \\<bind>\n      (\\<lambda>e.\n          RETURN\n           \\<lparr>ss_stack = [], on_stack = {}, visited = {},\n              \\<dots> = e\\<rparr>))\n     (gen_dfs_defs.gen_cond\n       (gen_param_dfs_defs.gds (pre_simple_impl.gbs G) unit_parametrization\n         simple_state.more_update)\n       (g_V0 G))\n     (rec_impl_defs.gen_step' G\n       (gen_param_dfs_defs.gds (pre_simple_impl.gbs G) unit_parametrization\n         simple_state.more_update)\n       unit_simple_impl.get_pending unit_simple_impl.get_stack\n       (\\<lambda>u vo s.\n           case vo of None \\<Rightarrow> RETURN s\n           | Some v \\<Rightarrow>\n               ASSERT (ss_stack s \\<noteq> []) \\<bind>\n               (\\<lambda>_.\n                   RETURN\n                    (op_ns_stack_update\n                      (let (u, Vs) = hd (ss_stack s)\n                       in (\\<lambda>_. (u, Vs - {v}) # tl (ss_stack s)))\n                      s))))\n     s \\<and>\n    (\\<not> False \\<longrightarrow>\n     ss_stack s = [] \\<and>\n     g_V0 G - it \\<subseteq> {v. v \\<in> visited s})\\<^esup>\n                 (g_V0 G) (\\<lambda>x. \\<not> False)\n                 (\\<lambda>v0 s.\n                     if v0 \\<in> visited s then RETURN s\n                     else ASSERT (v0 \\<notin> visited s) \\<bind>\n                          (\\<lambda>_.\n                              let s = op_ns_stack_update\n (\\<lambda>_. [(v0, g_E G `` {v0})]) s;\n                                  s = op_ns_on_stack_update\n (\\<lambda>_. {v0}) s\n                              in Let (s\n\\<lparr>visited := insert v0 (visited s)\\<rparr>)\n                                  RETURN) \\<bind>\n                          (\\<lambda>s.\n                              RETURN () \\<bind>\n                              (\\<lambda>e.\n                                  RETURN\n                                   (s\\<lparr>simple_state.more :=\n         e\\<rparr>))) \\<bind>\n                          (\\<lambda>s.\n                              REC (\\<lambda>D x.\nASSERT\n (case x of\n  (u, s) \\<Rightarrow>\n    rwof\n     (RETURN () \\<bind>\n      (\\<lambda>e.\n          RETURN\n           \\<lparr>ss_stack = [], on_stack = {}, visited = {},\n              \\<dots> = e\\<rparr>))\n     (gen_dfs_defs.gen_cond\n       (gen_param_dfs_defs.gds (pre_simple_impl.gbs G) unit_parametrization\n         simple_state.more_update)\n       (g_V0 G))\n     (rec_impl_defs.gen_step' G\n       (gen_param_dfs_defs.gds (pre_simple_impl.gbs G) unit_parametrization\n         simple_state.more_update)\n       unit_simple_impl.get_pending unit_simple_impl.get_stack\n       (\\<lambda>u vo s.\n           case vo of None \\<Rightarrow> RETURN s\n           | Some v \\<Rightarrow>\n               ASSERT (ss_stack s \\<noteq> []) \\<bind>\n               (\\<lambda>_.\n                   RETURN\n                    (op_ns_stack_update\n                      (let (u, Vs) = hd (ss_stack s)\n                       in (\\<lambda>_. (u, Vs - {v}) # tl (ss_stack s)))\n                      s))))\n     s \\<and>\n    \\<not> False \\<and>\n    (\\<exists>stk. unit_simple_impl.get_stack s = u # stk) \\<and>\n    g_E G \\<inter> {u} \\<times> UNIV\n    \\<subseteq> unit_simple_impl.get_pending s) \\<bind>\n(\\<lambda>_.\n    (case x of\n     (u, s) \\<Rightarrow>\n       FOREACH\\<^sub>C\\<^bsup>\\<lambda>it s'.\n                                 rwof\n                                  (RETURN () \\<bind>\n                                   (\\<lambda>e.\n RETURN\n  \\<lparr>ss_stack = [], on_stack = {}, visited = {}, \\<dots> = e\\<rparr>))\n                                  (gen_dfs_defs.gen_cond\n                                    (gen_param_dfs_defs.gds\n(pre_simple_impl.gbs G) unit_parametrization simple_state.more_update)\n                                    (g_V0 G))\n                                  (rec_impl_defs.gen_step' G\n                                    (gen_param_dfs_defs.gds\n(pre_simple_impl.gbs G) unit_parametrization simple_state.more_update)\n                                    unit_simple_impl.get_pending\n                                    unit_simple_impl.get_stack\n                                    (\\<lambda>u vo s.\n  case vo of None \\<Rightarrow> RETURN s\n  | Some v \\<Rightarrow>\n      ASSERT (ss_stack s \\<noteq> []) \\<bind>\n      (\\<lambda>_.\n          RETURN\n           (op_ns_stack_update\n             (let (u, Vs) = hd (ss_stack s)\n              in (\\<lambda>_. (u, Vs - {v}) # tl (ss_stack s)))\n             s))))\n                                  s' \\<and>\n                                 (\\<not> False \\<longrightarrow>\n                                  unit_simple_impl.get_stack s' =\n                                  unit_simple_impl.get_stack s \\<and>\n                                  unit_simple_impl.get_pending s' =\n                                  unit_simple_impl.get_pending s -\n                                  {u} \\<times> (g_E G `` {u} - it) \\<and>\n                                  {v. v \\<in> visited s} \\<union>\n                                  (g_E G `` {u} - it)\n                                  \\<subseteq> {v.\n         v \\<in> visited s'})\\<^esup>\n        (g_E G `` {u}) (\\<lambda>s. \\<not> False)\n        (\\<lambda>v s.\n            ASSERT (ss_stack s \\<noteq> []) \\<bind>\n            (\\<lambda>_.\n                RETURN\n                 (op_ns_stack_update\n                   (let (u, Vs) = hd (ss_stack s)\n                    in (\\<lambda>_. (u, Vs - {v}) # tl (ss_stack s)))\n                   s)) \\<bind>\n            (\\<lambda>s.\n                if v \\<in> visited s\n                then RETURN s \\<bind>\n                     (\\<lambda>s.\n                         RETURN () \\<bind>\n                         (\\<lambda>e.\n                             RETURN\n                              (s\\<lparr>simple_state.more := e\\<rparr>)))\n                else ASSERT\n                      (v \\<notin> on_stack s \\<and>\n                       v \\<notin> visited s) \\<bind>\n                     (\\<lambda>_.\n                         let s = op_ns_stack_update\n                                  (\\<lambda>_.\n(v, g_E G `` {v}) # ss_stack s)\n                                  s;\n                             s = op_ns_on_stack_update\n                                  (\\<lambda>_. insert v (on_stack s)) s\n                         in Let (s\\<lparr>visited :=\n      insert v (visited s)\\<rparr>)\n                             RETURN) \\<bind>\n                     (\\<lambda>s.\n                         RETURN () \\<bind>\n                         (\\<lambda>e.\n                             RETURN\n                              (s\\<lparr>simple_state.more :=\n    e\\<rparr>))) \\<bind>\n                     (\\<lambda>s. D (v, s))))\n        s \\<bind>\n       (\\<lambda>s.\n           RETURN s \\<bind>\n           (\\<lambda>s.\n               ASSERT\n                (ss_stack s \\<noteq> [] \\<and> u \\<in> on_stack s) \\<bind>\n               (\\<lambda>_.\n                   let s = op_ns_stack_update (\\<lambda>_. tl (ss_stack s))\n                            s\n                   in Let (op_ns_on_stack_update\n                            (\\<lambda>_. on_stack s - {u}) s)\n                       RETURN) \\<bind>\n               (\\<lambda>s.\n                   RETURN () \\<bind>\n                   (\\<lambda>e.\n                       RETURN\n                        (s\\<lparr>simple_state.more := e\\<rparr>))) \\<bind>\n               RETURN))) \\<bind>\n    (\\<lambda>r.\n        ASSERT\n         ((case x of\n           (u, s) \\<Rightarrow>\n             \\<lambda>s'.\n                rwof\n                 (RETURN () \\<bind>\n                  (\\<lambda>e.\n                      RETURN\n                       \\<lparr>ss_stack = [], on_stack = {}, visited = {},\n                          \\<dots> = e\\<rparr>))\n                 (gen_dfs_defs.gen_cond\n                   (gen_param_dfs_defs.gds (pre_simple_impl.gbs G)\n                     unit_parametrization simple_state.more_update)\n                   (g_V0 G))\n                 (rec_impl_defs.gen_step' G\n                   (gen_param_dfs_defs.gds (pre_simple_impl.gbs G)\n                     unit_parametrization simple_state.more_update)\n                   unit_simple_impl.get_pending unit_simple_impl.get_stack\n                   (\\<lambda>u vo s.\n                       case vo of None \\<Rightarrow> RETURN s\n                       | Some v \\<Rightarrow>\n                           ASSERT (ss_stack s \\<noteq> []) \\<bind>\n                           (\\<lambda>_.\n                               RETURN\n                                (op_ns_stack_update\n                                  (let (u, Vs) = hd (ss_stack s)\n                                   in (\\<lambda>_.\n    (u, Vs - {v}) # tl (ss_stack s)))\n                                  s))))\n                 s' \\<and>\n                (\\<not> False \\<longrightarrow>\n                 unit_simple_impl.get_stack s' =\n                 tl (unit_simple_impl.get_stack s) \\<and>\n                 unit_simple_impl.get_pending s' =\n                 unit_simple_impl.get_pending s - {u} \\<times> UNIV \\<and>\n                 {v. v \\<in> visited s}\n                 \\<subseteq> {v. v \\<in> visited s'}))\n           r) \\<bind>\n        (\\<lambda>_. RETURN r))))\n                               (v0, s))) \\<bind>\n                (\\<lambda>s. RETURN (visited s))))", "using [[autoref_trace_failed_id, goals_limit=1]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. nres_of ?c\n    \\<le> \\<Down> ?R\n           (ASSERT (fb_graph G) \\<bind>\n            (\\<lambda>_.\n                RETURN () \\<bind>\n                (\\<lambda>e.\n                    RETURN\n                     \\<lparr>ss_stack = [], on_stack = {}, visited = {},\n                        \\<dots> = e\\<rparr>) \\<bind>\n                FOREACH\\<^sub>C\\<^bsup>\\<lambda>it s.\n    rwof\n     (RETURN () \\<bind>\n      (\\<lambda>e.\n          RETURN\n           \\<lparr>ss_stack = [], on_stack = {}, visited = {},\n              \\<dots> = e\\<rparr>))\n     (gen_dfs_defs.gen_cond\n       (gen_param_dfs_defs.gds (pre_simple_impl.gbs G) unit_parametrization\n         simple_state.more_update)\n       (g_V0 G))\n     (rec_impl_defs.gen_step' G\n       (gen_param_dfs_defs.gds (pre_simple_impl.gbs G) unit_parametrization\n         simple_state.more_update)\n       unit_simple_impl.get_pending unit_simple_impl.get_stack\n       (\\<lambda>u vo s.\n           case vo of None \\<Rightarrow> RETURN s\n           | Some v \\<Rightarrow>\n               ASSERT (ss_stack s \\<noteq> []) \\<bind>\n               (\\<lambda>_.\n                   RETURN\n                    (op_ns_stack_update\n                      (let (u, Vs) = hd (ss_stack s)\n                       in (\\<lambda>_. (u, Vs - {v}) # tl (ss_stack s)))\n                      s))))\n     s \\<and>\n    (\\<not> False \\<longrightarrow>\n     ss_stack s = [] \\<and>\n     g_V0 G - it \\<subseteq> {v. v \\<in> visited s})\\<^esup>\n                 (g_V0 G) (\\<lambda>x. \\<not> False)\n                 (\\<lambda>v0 s.\n                     if v0 \\<in> visited s then RETURN s\n                     else ASSERT (v0 \\<notin> visited s) \\<bind>\n                          (\\<lambda>_.\n                              let s = op_ns_stack_update\n (\\<lambda>_. [(v0, g_E G `` {v0})]) s;\n                                  s = op_ns_on_stack_update\n (\\<lambda>_. {v0}) s\n                              in Let (s\n\\<lparr>visited := insert v0 (visited s)\\<rparr>)\n                                  RETURN) \\<bind>\n                          (\\<lambda>s.\n                              RETURN () \\<bind>\n                              (\\<lambda>e.\n                                  RETURN\n                                   (s\\<lparr>simple_state.more :=\n         e\\<rparr>))) \\<bind>\n                          (\\<lambda>s.\n                              REC (\\<lambda>D x.\nASSERT\n (case x of\n  (u, s) \\<Rightarrow>\n    rwof\n     (RETURN () \\<bind>\n      (\\<lambda>e.\n          RETURN\n           \\<lparr>ss_stack = [], on_stack = {}, visited = {},\n              \\<dots> = e\\<rparr>))\n     (gen_dfs_defs.gen_cond\n       (gen_param_dfs_defs.gds (pre_simple_impl.gbs G) unit_parametrization\n         simple_state.more_update)\n       (g_V0 G))\n     (rec_impl_defs.gen_step' G\n       (gen_param_dfs_defs.gds (pre_simple_impl.gbs G) unit_parametrization\n         simple_state.more_update)\n       unit_simple_impl.get_pending unit_simple_impl.get_stack\n       (\\<lambda>u vo s.\n           case vo of None \\<Rightarrow> RETURN s\n           | Some v \\<Rightarrow>\n               ASSERT (ss_stack s \\<noteq> []) \\<bind>\n               (\\<lambda>_.\n                   RETURN\n                    (op_ns_stack_update\n                      (let (u, Vs) = hd (ss_stack s)\n                       in (\\<lambda>_. (u, Vs - {v}) # tl (ss_stack s)))\n                      s))))\n     s \\<and>\n    \\<not> False \\<and>\n    (\\<exists>stk. unit_simple_impl.get_stack s = u # stk) \\<and>\n    g_E G \\<inter> {u} \\<times> UNIV\n    \\<subseteq> unit_simple_impl.get_pending s) \\<bind>\n(\\<lambda>_.\n    (case x of\n     (u, s) \\<Rightarrow>\n       FOREACH\\<^sub>C\\<^bsup>\\<lambda>it s'.\n                                 rwof\n                                  (RETURN () \\<bind>\n                                   (\\<lambda>e.\n RETURN\n  \\<lparr>ss_stack = [], on_stack = {}, visited = {}, \\<dots> = e\\<rparr>))\n                                  (gen_dfs_defs.gen_cond\n                                    (gen_param_dfs_defs.gds\n(pre_simple_impl.gbs G) unit_parametrization simple_state.more_update)\n                                    (g_V0 G))\n                                  (rec_impl_defs.gen_step' G\n                                    (gen_param_dfs_defs.gds\n(pre_simple_impl.gbs G) unit_parametrization simple_state.more_update)\n                                    unit_simple_impl.get_pending\n                                    unit_simple_impl.get_stack\n                                    (\\<lambda>u vo s.\n  case vo of None \\<Rightarrow> RETURN s\n  | Some v \\<Rightarrow>\n      ASSERT (ss_stack s \\<noteq> []) \\<bind>\n      (\\<lambda>_.\n          RETURN\n           (op_ns_stack_update\n             (let (u, Vs) = hd (ss_stack s)\n              in (\\<lambda>_. (u, Vs - {v}) # tl (ss_stack s)))\n             s))))\n                                  s' \\<and>\n                                 (\\<not> False \\<longrightarrow>\n                                  unit_simple_impl.get_stack s' =\n                                  unit_simple_impl.get_stack s \\<and>\n                                  unit_simple_impl.get_pending s' =\n                                  unit_simple_impl.get_pending s -\n                                  {u} \\<times> (g_E G `` {u} - it) \\<and>\n                                  {v. v \\<in> visited s} \\<union>\n                                  (g_E G `` {u} - it)\n                                  \\<subseteq> {v.\n         v \\<in> visited s'})\\<^esup>\n        (g_E G `` {u}) (\\<lambda>s. \\<not> False)\n        (\\<lambda>v s.\n            ASSERT (ss_stack s \\<noteq> []) \\<bind>\n            (\\<lambda>_.\n                RETURN\n                 (op_ns_stack_update\n                   (let (u, Vs) = hd (ss_stack s)\n                    in (\\<lambda>_. (u, Vs - {v}) # tl (ss_stack s)))\n                   s)) \\<bind>\n            (\\<lambda>s.\n                if v \\<in> visited s\n                then RETURN s \\<bind>\n                     (\\<lambda>s.\n                         RETURN () \\<bind>\n                         (\\<lambda>e.\n                             RETURN\n                              (s\\<lparr>simple_state.more := e\\<rparr>)))\n                else ASSERT\n                      (v \\<notin> on_stack s \\<and>\n                       v \\<notin> visited s) \\<bind>\n                     (\\<lambda>_.\n                         let s = op_ns_stack_update\n                                  (\\<lambda>_.\n(v, g_E G `` {v}) # ss_stack s)\n                                  s;\n                             s = op_ns_on_stack_update\n                                  (\\<lambda>_. insert v (on_stack s)) s\n                         in Let (s\\<lparr>visited :=\n      insert v (visited s)\\<rparr>)\n                             RETURN) \\<bind>\n                     (\\<lambda>s.\n                         RETURN () \\<bind>\n                         (\\<lambda>e.\n                             RETURN\n                              (s\\<lparr>simple_state.more :=\n    e\\<rparr>))) \\<bind>\n                     (\\<lambda>s. D (v, s))))\n        s \\<bind>\n       (\\<lambda>s.\n           RETURN s \\<bind>\n           (\\<lambda>s.\n               ASSERT\n                (ss_stack s \\<noteq> [] \\<and> u \\<in> on_stack s) \\<bind>\n               (\\<lambda>_.\n                   let s = op_ns_stack_update (\\<lambda>_. tl (ss_stack s))\n                            s\n                   in Let (op_ns_on_stack_update\n                            (\\<lambda>_. on_stack s - {u}) s)\n                       RETURN) \\<bind>\n               (\\<lambda>s.\n                   RETURN () \\<bind>\n                   (\\<lambda>e.\n                       RETURN\n                        (s\\<lparr>simple_state.more := e\\<rparr>))) \\<bind>\n               RETURN))) \\<bind>\n    (\\<lambda>r.\n        ASSERT\n         ((case x of\n           (u, s) \\<Rightarrow>\n             \\<lambda>s'.\n                rwof\n                 (RETURN () \\<bind>\n                  (\\<lambda>e.\n                      RETURN\n                       \\<lparr>ss_stack = [], on_stack = {}, visited = {},\n                          \\<dots> = e\\<rparr>))\n                 (gen_dfs_defs.gen_cond\n                   (gen_param_dfs_defs.gds (pre_simple_impl.gbs G)\n                     unit_parametrization simple_state.more_update)\n                   (g_V0 G))\n                 (rec_impl_defs.gen_step' G\n                   (gen_param_dfs_defs.gds (pre_simple_impl.gbs G)\n                     unit_parametrization simple_state.more_update)\n                   unit_simple_impl.get_pending unit_simple_impl.get_stack\n                   (\\<lambda>u vo s.\n                       case vo of None \\<Rightarrow> RETURN s\n                       | Some v \\<Rightarrow>\n                           ASSERT (ss_stack s \\<noteq> []) \\<bind>\n                           (\\<lambda>_.\n                               RETURN\n                                (op_ns_stack_update\n                                  (let (u, Vs) = hd (ss_stack s)\n                                   in (\\<lambda>_.\n    (u, Vs - {v}) # tl (ss_stack s)))\n                                  s))))\n                 s' \\<and>\n                (\\<not> False \\<longrightarrow>\n                 unit_simple_impl.get_stack s' =\n                 tl (unit_simple_impl.get_stack s) \\<and>\n                 unit_simple_impl.get_pending s' =\n                 unit_simple_impl.get_pending s - {u} \\<times> UNIV \\<and>\n                 {v. v \\<in> visited s}\n                 \\<subseteq> {v. v \\<in> visited s'}))\n           r) \\<bind>\n        (\\<lambda>_. RETURN r))))\n                               (v0, s))) \\<bind>\n                (\\<lambda>s. RETURN (visited s))))", "apply (autoref_monadic (trace))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "concrete_definition find_reachable_rec_code uses find_reachable_rec_impl"], ["", "prepare_code_thms find_reachable_rec_code_def"], ["", "export_code find_reachable_rec_code checking SML"], ["", "lemma find_reachable_rec_code_correct:\n  assumes 1: \"fb_graph G\"\n  assumes 2: \"(Gi, G) \\<in> \\<langle>Rm, Id\\<rangle>g_impl_rel_ext\"\n  assumes 4: \"find_reachable_rec_code Gi = dRETURN r\"\n  shows \"(r, (g_E G)\\<^sup>* `` g_V0 G)\\<in>\\<langle>Id\\<rangle>dflt_ahs_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (r, (g_E G)\\<^sup>* `` g_V0 G)\n    \\<in> \\<langle>Id\\<rangle>ahs_rel bounded_hashcode_nat", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (r, (g_E G)\\<^sup>* `` g_V0 G)\n    \\<in> \\<langle>Id\\<rangle>ahs_rel bounded_hashcode_nat", "from 1"], ["proof (chain)\npicking this:\n  fb_graph G", "interpret unit_DFS"], ["proof (prove)\nusing this:\n  fb_graph G\n\ngoal (1 subgoal):\n 1. unit_DFS G", "by rule"], ["proof (state)\ngoal (1 subgoal):\n 1. (r, (g_E G)\\<^sup>* `` g_V0 G)\n    \\<in> \\<langle>Id\\<rangle>ahs_rel bounded_hashcode_nat", "note find_reachable_rec_code.refine[OF 2]"], ["proof (state)\nthis:\n  nres_of (find_reachable_rec_code Gi)\n  \\<le> \\<Down> (\\<langle>Id\\<rangle>ahs_rel bounded_hashcode_nat)\n         (find_reachable_rec_impl G)\n\ngoal (1 subgoal):\n 1. (r, (g_E G)\\<^sup>* `` g_V0 G)\n    \\<in> \\<langle>Id\\<rangle>ahs_rel bounded_hashcode_nat", "also"], ["proof (state)\nthis:\n  nres_of (find_reachable_rec_code Gi)\n  \\<le> \\<Down> (\\<langle>Id\\<rangle>ahs_rel bounded_hashcode_nat)\n         (find_reachable_rec_impl G)\n\ngoal (1 subgoal):\n 1. (r, (g_E G)\\<^sup>* `` g_V0 G)\n    \\<in> \\<langle>Id\\<rangle>ahs_rel bounded_hashcode_nat", "note find_reachable_rec_impl_refine"], ["proof (state)\nthis:\n  find_reachable_rec_impl ?G \\<le> \\<Down> Id (find_reachable ?G)\n\ngoal (1 subgoal):\n 1. (r, (g_E G)\\<^sup>* `` g_V0 G)\n    \\<in> \\<langle>Id\\<rangle>ahs_rel bounded_hashcode_nat", "also"], ["proof (state)\nthis:\n  find_reachable_rec_impl ?G \\<le> \\<Down> Id (find_reachable ?G)\n\ngoal (1 subgoal):\n 1. (r, (g_E G)\\<^sup>* `` g_V0 G)\n    \\<in> \\<langle>Id\\<rangle>ahs_rel bounded_hashcode_nat", "note find_reachable_correct"], ["proof (state)\nthis:\n  find_reachable G \\<le> SPEC (\\<lambda>r. r = (g_E G)\\<^sup>* `` g_V0 G)\n\ngoal (1 subgoal):\n 1. (r, (g_E G)\\<^sup>* `` g_V0 G)\n    \\<in> \\<langle>Id\\<rangle>ahs_rel bounded_hashcode_nat", "finally"], ["proof (chain)\npicking this:\n  nres_of (find_reachable_rec_code Gi)\n  \\<le> \\<Down> (\\<langle>Id\\<rangle>ahs_rel bounded_hashcode_nat)\n         (SPEC (\\<lambda>r. r = (g_E G)\\<^sup>* `` g_V0 G))", "show ?thesis"], ["proof (prove)\nusing this:\n  nres_of (find_reachable_rec_code Gi)\n  \\<le> \\<Down> (\\<langle>Id\\<rangle>ahs_rel bounded_hashcode_nat)\n         (SPEC (\\<lambda>r. r = (g_E G)\\<^sup>* `` g_V0 G))\n\ngoal (1 subgoal):\n 1. (r, (g_E G)\\<^sup>* `` g_V0 G)\n    \\<in> \\<langle>Id\\<rangle>ahs_rel bounded_hashcode_nat", "using 1 4"], ["proof (prove)\nusing this:\n  nres_of (find_reachable_rec_code Gi)\n  \\<le> \\<Down> (\\<langle>Id\\<rangle>ahs_rel bounded_hashcode_nat)\n         (SPEC (\\<lambda>r. r = (g_E G)\\<^sup>* `` g_V0 G))\n  fb_graph G\n  find_reachable_rec_code Gi = dRETURN r\n\ngoal (1 subgoal):\n 1. (r, (g_E G)\\<^sup>* `` g_V0 G)\n    \\<in> \\<langle>Id\\<rangle>ahs_rel bounded_hashcode_nat", "by (auto simp: RETURN_RES_refine_iff)"], ["proof (state)\nthis:\n  (r, (g_E G)\\<^sup>* `` g_V0 G)\n  \\<in> \\<langle>Id\\<rangle>ahs_rel bounded_hashcode_nat\n\ngoal:\nNo subgoals!", "qed"], ["", "definition [simp]: \"op_reachable G \\<equiv> (g_E G)\\<^sup>* `` g_V0 G\""], ["", "lemmas [autoref_op_pat] = op_reachable_def[symmetric]"], ["", "context begin"], ["", "interpretation autoref_syn"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma autoref_op_reachable[autoref_rules]:\n  fixes V :: \"('vi\\<times>'v) set\"\n  assumes G: \"SIDE_PRECOND (graph G)\"\n  assumes FR: \"SIDE_PRECOND (finite ((g_E G)\\<^sup>* `` g_V0 G))\"\n  assumes BHC: \"SIDE_GEN_ALGO (is_bounded_hashcode V eq bhc)\"\n  assumes EQ: \"GEN_OP eq (=) (V \\<rightarrow> V \\<rightarrow> bool_rel)\"\n  assumes VDS: \"SIDE_GEN_ALGO (is_valid_def_hm_size TYPE ('vi) sz)\"\n  assumes 2: \"(Gi, G) \\<in> \\<langle>Rm, V\\<rangle>g_impl_rel_ext\"\n  shows \"(find_reachable_codeT eq bhc sz Gi,\n    (OP op_reachable ::: \\<langle>Rm, V\\<rangle>g_impl_rel_ext \\<rightarrow> \\<langle>V\\<rangle>ahs_rel bhc)$G)\\<in>\\<langle>V\\<rangle>ahs_rel bhc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (find_reachable_codeT eq bhc sz Gi,\n     (OP op_reachable :::\n      \\<langle>Rm, V\\<rangle>g_impl_rel_ext \\<rightarrow>\n      \\<langle>V\\<rangle>ahs_rel bhc) $\n     G)\n    \\<in> \\<langle>V\\<rangle>ahs_rel bhc", "using assms"], ["proof (prove)\nusing this:\n  SIDE_PRECOND (graph G)\n  SIDE_PRECOND (finite ((g_E G)\\<^sup>* `` g_V0 G))\n  SIDE_GEN_ALGO (is_bounded_hashcode V eq bhc)\n  GEN_OP eq (=) (V \\<rightarrow> V \\<rightarrow> bool_rel)\n  SIDE_GEN_ALGO (is_valid_def_hm_size TYPE('vi) sz)\n  (Gi, G) \\<in> \\<langle>Rm, V\\<rangle>g_impl_rel_ext\n\ngoal (1 subgoal):\n 1. (find_reachable_codeT eq bhc sz Gi,\n     (OP op_reachable :::\n      \\<langle>Rm, V\\<rangle>g_impl_rel_ext \\<rightarrow>\n      \\<langle>V\\<rangle>ahs_rel bhc) $\n     G)\n    \\<in> \\<langle>V\\<rangle>ahs_rel bhc", "by (simp add: find_reachable_codeT_correct)"], ["", "end"], ["", "subsection \\<open>Conclusions\\<close>"], ["", "text \\<open>\n  We have defined an efficient DFS-based implementation for @{const op_reachable},\n  and declared it to Autoref.\n\\<close>"], ["", "end"]]}