{"file_name": "/home/qj213/afp-2021-10-22/thys/DFS_Framework/Examples/Cyc_Check.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/DFS_Framework", "problem_names": ["lemma break_more_cong: \"state.more s = state.more s' \\<Longrightarrow> break s = break s'\"", "lemma [simp]: \"s\\<lparr> state.more := \\<lparr> break = foo \\<rparr> \\<rparr> = s \\<lparr> break := foo \\<rparr>\"", "lemmas cycc_params_simp[simp] = \n  gen_parameterization.simps[mk_record_simp, OF cycc_params_def[simplified]]", "lemma cyccI: \n  assumes \"fb_graph G\" \n  shows \"cycc G\"", "lemma cyccI': \n  assumes \"graph G\" \n  and FR: \"finite (graph_defs.reachable G)\"\n  shows \"cycc G\"", "lemma cycc_invar_eq[simp]:\n  shows \"DFS_invar G cycc_params s \\<longleftrightarrow> cycc_invar G s\"", "lemma (in cycc) i_brk_eq_back: \"is_invar (\\<lambda>s. break s \\<longleftrightarrow> back_edges s \\<noteq> {})\"", "lemmas brk_eq_back = i_brk_eq_back[THEN make_invar_thm]", "lemma (in cycc) i_brk_eq_back_short_proof: \n    \"is_invar (\\<lambda>s. break s \\<longleftrightarrow> back_edges s \\<noteq> {})\"", "lemma cycc_correct_aux: \n    assumes NC: \"\\<not>cond s\"\n    shows \"break s \\<longleftrightarrow> \\<not>acyclic (E \\<inter> reachable \\<times> UNIV)\"", "lemma cycc_correct_aux_short_proof:\n    assumes NC: \"\\<not>cond s\"\n    shows \"break s \\<longleftrightarrow> \\<not>acyclic (E \\<inter> reachable \\<times> UNIV)\"", "theorem cyc_checker_correct: \"cyc_checker G \\<le> cyc_checker_spec G\"", "theorem cyc_checkerT_correct: \"cyc_checkerT G \\<le> cyc_checkerT_spec G\"", "lemmas cycc_params_impl_simp[simp,DFS_code_unfold] = \n  gen_parameterization.simps[mk_record_simp, OF cycc_params_impl_def[simplified]]", "lemma break_impl: \"(si,s)\\<in>cycc_rel \n  \\<Longrightarrow> cycc_state_impl.break si = cycc_state.break s\"", "lemmas impl_refine = simple_tailrec_refine simple_rec_refine simple_tailrecT_refine", "lemma \n    \"cycc_impl.tailrec_impl TYPE('more) G \\<le> \\<Down> cycc_rel it_dfs\"\n    \"cycc_impl.rec_impl TYPE('more) G \\<le> \\<Down> cycc_rel it_dfs\"\n    \"cycc_impl.tailrec_implT TYPE('more) G \\<le> \\<Down> cycc_rel it_dfsT\"", "lemma cyc_checker_impl_refine: \"cyc_checker_impl G \\<le> \\<Down>Id (cyc_checker G)\"", "lemma cyc_checker_rec_impl_refine: \n  \"cyc_checker_rec_impl G \\<le> \\<Down>Id (cyc_checker G)\"", "lemma cyc_checker_implT_refine: \"cyc_checker_implT G \\<le> \\<Down>Id (cyc_checkerT G)\"", "lemmas [autoref_rel_intf] = REL_INTFI[of cycc_state_erel i_cycc_state_ext]", "lemma [autoref_rules]:\n  fixes ns_rel vis_rel erel\n  defines \"R \\<equiv> \\<langle>ns_rel,vis_rel,\\<langle>erel\\<rangle>cycc_state_erel\\<rangle>ss_impl_rel\"\n  shows \n    \"(cycc_state_impl'_ext, cycc_state_impl_ext) \\<in> bool_rel \\<rightarrow> erel \\<rightarrow> \\<langle>erel\\<rangle>cycc_state_erel\"\n    \"(break_impl, cycc_state_impl.break) \\<in> R \\<rightarrow> bool_rel\"", "theorem cyc_checker_code_correct:\n  assumes 1: \"fb_graph G\"\n  assumes 2: \"(Gi, G) \\<in> \\<langle>Rm, Id\\<rangle>g_impl_rel_ext\"\n  assumes 4: \"cyc_checker_code Gi = dRETURN x\"\n  shows \"x \\<longleftrightarrow> (\\<not>acyclic (g_E G \\<inter> ((g_E G)\\<^sup>* `` g_V0 G) \\<times> UNIV))\"", "lemma cyc_checker_rec_code_correct:\n  assumes 1: \"fb_graph G\"\n  assumes 2: \"(Gi, G) \\<in> \\<langle>Rm, Id\\<rangle>g_impl_rel_ext\"\n  assumes 4: \"cyc_checker_rec_code Gi = dRETURN x\"\n  shows \"x \\<longleftrightarrow> (\\<not>acyclic (g_E G \\<inter> ((g_E G)\\<^sup>* `` g_V0 G) \\<times> UNIV))\"", "theorem cyc_checker_codeT_correct:\n  assumes 1: \"graph G\" \"finite (graph_defs.reachable G)\"\n  assumes 2: \"(Gi, G) \\<in> \\<langle>Rm, Id\\<rangle>g_impl_rel_ext\"\n  shows \"cyc_checker_codeT Gi \\<longleftrightarrow> (\\<not>acyclic (g_E G \\<inter> ((g_E G)\\<^sup>* `` g_V0 G) \\<times> UNIV))\""], "translations": [["", "lemma break_more_cong: \"state.more s = state.more s' \\<Longrightarrow> break s = break s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. state.more s = state.more s' \\<Longrightarrow> break s = break s'", "by (cases s, cases s', simp)"], ["", "lemma [simp]: \"s\\<lparr> state.more := \\<lparr> break = foo \\<rparr> \\<rparr> = s \\<lparr> break := foo \\<rparr>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s\\<lparr>state.more := \\<lparr>break = foo\\<rparr>\\<rparr> = s\n    \\<lparr>break := foo\\<rparr>", "by (cases s) simp"], ["", "text \\<open>\n  Define the parameterization. We start at a default parameterization, where\n  all operations default to skip, and just add the operations we are \n  interested in: Initially, the break flag is false, it is set if we \n  encounter a back-edge, and once set, the algorithm shall terminate immediately. \\<close>"], ["", "definition cycc_params :: \"('v,unit cycc_state_ext) parameterization\"\nwhere \"cycc_params \\<equiv> dflt_parametrization state.more \n  (RETURN \\<lparr> break = False \\<rparr>) \\<lparr>\n  on_back_edge := \\<lambda>_ _ _. RETURN \\<lparr> break = True \\<rparr>,\n  is_break := break \\<rparr>\""], ["", "lemmas cycc_params_simp[simp] = \n  gen_parameterization.simps[mk_record_simp, OF cycc_params_def[simplified]]"], ["", "interpretation cycc: param_DFS_defs where param=cycc_params for G"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "text \\<open>We now can define our cyclicity checker. \n  The partially correct version asserts a finitely branching graph:\\<close>"], ["", "definition \"cyc_checker G \\<equiv> do {\n  ASSERT (fb_graph G);\n  s \\<leftarrow> cycc.it_dfs TYPE('a) G;\n  RETURN (break s)\n}\""], ["", "text \\<open>The total correct variant asserts finitely many reachable nodes.\\<close>"], ["", "definition \"cyc_checkerT G \\<equiv> do {\n  ASSERT (graph G \\<and> finite (graph_defs.reachable G));\n  s \\<leftarrow> cycc.it_dfsT TYPE('a) G;\n  RETURN (break s)\n}\""], ["", "text \\<open>\n  Next, we define a locale for the cyclicity checker's\n  precondition and invariant, by specializing the \\<open>param_DFS\\<close> locale.\\<close>"], ["", "locale cycc = param_DFS G cycc_params for G :: \"('v, 'more) graph_rec_scheme\"\nbegin"], ["", "text \\<open>We can easily show that our parametrization does not fail, thus we also\n    get the DFS-locale, which gives us the correctness theorem for\n    the DFS-scheme \\<close>"], ["", "sublocale DFS G cycc_params"], ["proof (prove)\ngoal (1 subgoal):\n 1. DFS G cycc_params", "apply unfold_locales"], ["proof (prove)\ngoal (6 subgoals):\n 1. nofail (on_init cycc_params)\n 2. \\<And>v0 s.\n       pre_on_new_root v0 s \\<Longrightarrow>\n       nofail (on_new_root cycc_params v0 s)\n 3. \\<And>u s.\n       pre_on_finish u s \\<Longrightarrow>\n       nofail (on_finish cycc_params u s)\n 4. \\<And>u v s.\n       pre_on_cross_edge u v s \\<Longrightarrow>\n       nofail (on_cross_edge cycc_params u v s)\n 5. \\<And>u v s.\n       pre_on_back_edge u v s \\<Longrightarrow>\n       nofail (on_back_edge cycc_params u v s)\n 6. \\<And>u v s.\n       pre_on_discover u v s \\<Longrightarrow>\n       nofail (on_discover cycc_params u v s)", "apply (simp_all add: cycc_params_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "thm it_dfs_correct  \\<comment> \\<open>Partial correctness\\<close>"], ["", "thm it_dfsT_correct \\<comment> \\<open>Total correctness if set of reachable states is finite\\<close>"], ["", "end"], ["", "lemma cyccI: \n  assumes \"fb_graph G\" \n  shows \"cycc G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cycc G", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cycc G", "interpret fb_graph G"], ["proof (prove)\ngoal (1 subgoal):\n 1. fb_graph G", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. cycc G", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. cycc G", "by unfold_locales"], ["proof (state)\nthis:\n  cycc G\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cyccI': \n  assumes \"graph G\" \n  and FR: \"finite (graph_defs.reachable G)\"\n  shows \"cycc G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cycc G", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cycc G", "interpret graph G"], ["proof (prove)\ngoal (1 subgoal):\n 1. graph G", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. cycc G", "from FR"], ["proof (chain)\npicking this:\n  finite ((g_E G)\\<^sup>* `` g_V0 G)", "interpret fb_graph G"], ["proof (prove)\nusing this:\n  finite ((g_E G)\\<^sup>* `` g_V0 G)\n\ngoal (1 subgoal):\n 1. fb_graph G", "by (rule fb_graphI_fr)"], ["proof (state)\ngoal (1 subgoal):\n 1. cycc G", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. cycc G", "by unfold_locales"], ["proof (state)\nthis:\n  cycc G\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Next, we specialize the @{term DFS_invar} locale to our parameterization.\n  This locale contains all proven invariants. When proving new invariants,\n  this locale is available as assumption, thus allowing us to re-use already \n  proven invariants.\n\\<close>"], ["", "locale cycc_invar = DFS_invar where param = cycc_params + cycc"], ["", "text \\<open> The lemmas to establish invariants only provide the \\<open>DFS_invar\\<close> locale.\n  This lemma is used to convert it into the \\<open>cycc_invar\\<close> locale.\n\\<close>"], ["", "lemma cycc_invar_eq[simp]:\n  shows \"DFS_invar G cycc_params s \\<longleftrightarrow> cycc_invar G s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DFS_invar G cycc_params s = cycc_invar G s", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. DFS_invar G cycc_params s \\<Longrightarrow> cycc_invar G s\n 2. cycc_invar G s \\<Longrightarrow> DFS_invar G cycc_params s", "assume \"DFS_invar G cycc_params s\""], ["proof (state)\nthis:\n  DFS_invar G cycc_params s\n\ngoal (2 subgoals):\n 1. DFS_invar G cycc_params s \\<Longrightarrow> cycc_invar G s\n 2. cycc_invar G s \\<Longrightarrow> DFS_invar G cycc_params s", "interpret DFS_invar G cycc_params s"], ["proof (prove)\ngoal (1 subgoal):\n 1. DFS_invar G cycc_params s", "by fact"], ["proof (state)\ngoal (2 subgoals):\n 1. DFS_invar G cycc_params s \\<Longrightarrow> cycc_invar G s\n 2. cycc_invar G s \\<Longrightarrow> DFS_invar G cycc_params s", "show \"cycc_invar G s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cycc_invar G s", "by unfold_locales"], ["proof (state)\nthis:\n  cycc_invar G s\n\ngoal (1 subgoal):\n 1. cycc_invar G s \\<Longrightarrow> DFS_invar G cycc_params s", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. cycc_invar G s \\<Longrightarrow> DFS_invar G cycc_params s", "assume \"cycc_invar G s\""], ["proof (state)\nthis:\n  cycc_invar G s\n\ngoal (1 subgoal):\n 1. cycc_invar G s \\<Longrightarrow> DFS_invar G cycc_params s", "then"], ["proof (chain)\npicking this:\n  cycc_invar G s", "interpret cycc_invar G s"], ["proof (prove)\nusing this:\n  cycc_invar G s\n\ngoal (1 subgoal):\n 1. cycc_invar G s", "."], ["proof (state)\ngoal (1 subgoal):\n 1. cycc_invar G s \\<Longrightarrow> DFS_invar G cycc_params s", "show \"DFS_invar G cycc_params s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DFS_invar G cycc_params s", "by unfold_locales"], ["proof (state)\nthis:\n  DFS_invar G cycc_params s\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Correctness Proof\\<close>"], ["", "text \\<open> We now enter the \\<open>cycc_invar\\<close> locale, and show correctness of \n  our cyclicity checker.\n\\<close>"], ["", "context cycc_invar begin"], ["", "text \\<open>We show that we break if and only if there are back edges. \n    This is straightforward from our parameterization, and we can use the \n    @{thm [source] establish_invarI} rule provided by the DFS framework.\n\n    We use this example to illustrate the general proof scheme:\n    \\<close>"], ["", "lemma (in cycc) i_brk_eq_back: \"is_invar (\\<lambda>s. break s \\<longleftrightarrow> back_edges s \\<noteq> {})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_invar (\\<lambda>s. break s = (back_edges s \\<noteq> {}))", "proof (induct rule: establish_invarI)"], ["proof (state)\ngoal (6 subgoals):\n 1. on_init cycc_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         break (empty_state x) = (back_edges (empty_state x) \\<noteq> {}))\n 2. \\<And>s s' v0.\n       \\<lbrakk>DFS_invar G cycc_params s;\n        break s = (back_edges s \\<noteq> {}); cond s;\n        \\<not> is_break cycc_params s; stack s = []; v0 \\<in> V0;\n        v0 \\<notin> dom (discovered s); s' = new_root v0 s\\<rbrakk>\n       \\<Longrightarrow> on_new_root cycc_params v0 s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G cycc_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              break (s'\\<lparr>state.more := x\\<rparr>) =\n                              (back_edges\n                                (s'\\<lparr>state.more := x\\<rparr>) \\<noteq>\n                               {}))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G cycc_params s;\n        break s = (back_edges s \\<noteq> {}); cond s;\n        \\<not> is_break cycc_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish cycc_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G cycc_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              break (s'\\<lparr>state.more := x\\<rparr>) =\n                              (back_edges\n                                (s'\\<lparr>state.more := x\\<rparr>) \\<noteq>\n                               {}))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G cycc_params s;\n        break s = (back_edges s \\<noteq> {}); cond s;\n        \\<not> is_break cycc_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge cycc_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G cycc_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              break (s'\\<lparr>state.more := x\\<rparr>) =\n                              (back_edges\n                                (s'\\<lparr>state.more := x\\<rparr>) \\<noteq>\n                               {}))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G cycc_params s;\n        break s = (back_edges s \\<noteq> {}); cond s;\n        \\<not> is_break cycc_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge cycc_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G cycc_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              break (s'\\<lparr>state.more := x\\<rparr>) =\n                              (back_edges\n                                (s'\\<lparr>state.more := x\\<rparr>) \\<noteq>\n                               {}))\n 6. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G cycc_params s;\n        break s = (back_edges s \\<noteq> {}); cond s;\n        \\<not> is_break cycc_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<notin> dom (discovered s);\n        s' =\n        discover u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover cycc_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G cycc_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              break (s'\\<lparr>state.more := x\\<rparr>) =\n                              (back_edges\n                                (s'\\<lparr>state.more := x\\<rparr>) \\<noteq>\n                               {}))", "txt \\<open>The @{thm establish_invarI} rule is used with the induction method, and \n    yields cases\\<close>"], ["proof (state)\ngoal (6 subgoals):\n 1. on_init cycc_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         break (empty_state x) = (back_edges (empty_state x) \\<noteq> {}))\n 2. \\<And>s s' v0.\n       \\<lbrakk>DFS_invar G cycc_params s;\n        break s = (back_edges s \\<noteq> {}); cond s;\n        \\<not> is_break cycc_params s; stack s = []; v0 \\<in> V0;\n        v0 \\<notin> dom (discovered s); s' = new_root v0 s\\<rbrakk>\n       \\<Longrightarrow> on_new_root cycc_params v0 s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G cycc_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              break (s'\\<lparr>state.more := x\\<rparr>) =\n                              (back_edges\n                                (s'\\<lparr>state.more := x\\<rparr>) \\<noteq>\n                               {}))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G cycc_params s;\n        break s = (back_edges s \\<noteq> {}); cond s;\n        \\<not> is_break cycc_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish cycc_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G cycc_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              break (s'\\<lparr>state.more := x\\<rparr>) =\n                              (back_edges\n                                (s'\\<lparr>state.more := x\\<rparr>) \\<noteq>\n                               {}))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G cycc_params s;\n        break s = (back_edges s \\<noteq> {}); cond s;\n        \\<not> is_break cycc_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge cycc_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G cycc_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              break (s'\\<lparr>state.more := x\\<rparr>) =\n                              (back_edges\n                                (s'\\<lparr>state.more := x\\<rparr>) \\<noteq>\n                               {}))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G cycc_params s;\n        break s = (back_edges s \\<noteq> {}); cond s;\n        \\<not> is_break cycc_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge cycc_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G cycc_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              break (s'\\<lparr>state.more := x\\<rparr>) =\n                              (back_edges\n                                (s'\\<lparr>state.more := x\\<rparr>) \\<noteq>\n                               {}))\n 6. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G cycc_params s;\n        break s = (back_edges s \\<noteq> {}); cond s;\n        \\<not> is_break cycc_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<notin> dom (discovered s);\n        s' =\n        discover u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover cycc_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G cycc_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              break (s'\\<lparr>state.more := x\\<rparr>) =\n                              (back_edges\n                                (s'\\<lparr>state.more := x\\<rparr>) \\<noteq>\n                               {}))", "print_cases"], ["proof (state)\ngoal (6 subgoals):\n 1. on_init cycc_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         break (empty_state x) = (back_edges (empty_state x) \\<noteq> {}))\n 2. \\<And>s s' v0.\n       \\<lbrakk>DFS_invar G cycc_params s;\n        break s = (back_edges s \\<noteq> {}); cond s;\n        \\<not> is_break cycc_params s; stack s = []; v0 \\<in> V0;\n        v0 \\<notin> dom (discovered s); s' = new_root v0 s\\<rbrakk>\n       \\<Longrightarrow> on_new_root cycc_params v0 s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G cycc_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              break (s'\\<lparr>state.more := x\\<rparr>) =\n                              (back_edges\n                                (s'\\<lparr>state.more := x\\<rparr>) \\<noteq>\n                               {}))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G cycc_params s;\n        break s = (back_edges s \\<noteq> {}); cond s;\n        \\<not> is_break cycc_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish cycc_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G cycc_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              break (s'\\<lparr>state.more := x\\<rparr>) =\n                              (back_edges\n                                (s'\\<lparr>state.more := x\\<rparr>) \\<noteq>\n                               {}))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G cycc_params s;\n        break s = (back_edges s \\<noteq> {}); cond s;\n        \\<not> is_break cycc_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge cycc_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G cycc_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              break (s'\\<lparr>state.more := x\\<rparr>) =\n                              (back_edges\n                                (s'\\<lparr>state.more := x\\<rparr>) \\<noteq>\n                               {}))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G cycc_params s;\n        break s = (back_edges s \\<noteq> {}); cond s;\n        \\<not> is_break cycc_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge cycc_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G cycc_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              break (s'\\<lparr>state.more := x\\<rparr>) =\n                              (back_edges\n                                (s'\\<lparr>state.more := x\\<rparr>) \\<noteq>\n                               {}))\n 6. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G cycc_params s;\n        break s = (back_edges s \\<noteq> {}); cond s;\n        \\<not> is_break cycc_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<notin> dom (discovered s);\n        s' =\n        discover u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover cycc_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G cycc_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              break (s'\\<lparr>state.more := x\\<rparr>) =\n                              (back_edges\n                                (s'\\<lparr>state.more := x\\<rparr>) \\<noteq>\n                               {}))", "txt \\<open>Our parameterization has only hooked into initialization and back-edges,\n      so only these two cases are non-trivial\\<close>"], ["proof (state)\ngoal (6 subgoals):\n 1. on_init cycc_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         break (empty_state x) = (back_edges (empty_state x) \\<noteq> {}))\n 2. \\<And>s s' v0.\n       \\<lbrakk>DFS_invar G cycc_params s;\n        break s = (back_edges s \\<noteq> {}); cond s;\n        \\<not> is_break cycc_params s; stack s = []; v0 \\<in> V0;\n        v0 \\<notin> dom (discovered s); s' = new_root v0 s\\<rbrakk>\n       \\<Longrightarrow> on_new_root cycc_params v0 s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G cycc_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              break (s'\\<lparr>state.more := x\\<rparr>) =\n                              (back_edges\n                                (s'\\<lparr>state.more := x\\<rparr>) \\<noteq>\n                               {}))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G cycc_params s;\n        break s = (back_edges s \\<noteq> {}); cond s;\n        \\<not> is_break cycc_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish cycc_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G cycc_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              break (s'\\<lparr>state.more := x\\<rparr>) =\n                              (back_edges\n                                (s'\\<lparr>state.more := x\\<rparr>) \\<noteq>\n                               {}))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G cycc_params s;\n        break s = (back_edges s \\<noteq> {}); cond s;\n        \\<not> is_break cycc_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge cycc_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G cycc_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              break (s'\\<lparr>state.more := x\\<rparr>) =\n                              (back_edges\n                                (s'\\<lparr>state.more := x\\<rparr>) \\<noteq>\n                               {}))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G cycc_params s;\n        break s = (back_edges s \\<noteq> {}); cond s;\n        \\<not> is_break cycc_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge cycc_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G cycc_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              break (s'\\<lparr>state.more := x\\<rparr>) =\n                              (back_edges\n                                (s'\\<lparr>state.more := x\\<rparr>) \\<noteq>\n                               {}))\n 6. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G cycc_params s;\n        break s = (back_edges s \\<noteq> {}); cond s;\n        \\<not> is_break cycc_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<notin> dom (discovered s);\n        s' =\n        discover u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover cycc_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G cycc_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              break (s'\\<lparr>state.more := x\\<rparr>) =\n                              (back_edges\n                                (s'\\<lparr>state.more := x\\<rparr>) \\<noteq>\n                               {}))", "case init"], ["proof (state)\nthis:\n  \n\ngoal (6 subgoals):\n 1. on_init cycc_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         break (empty_state x) = (back_edges (empty_state x) \\<noteq> {}))\n 2. \\<And>s s' v0.\n       \\<lbrakk>DFS_invar G cycc_params s;\n        break s = (back_edges s \\<noteq> {}); cond s;\n        \\<not> is_break cycc_params s; stack s = []; v0 \\<in> V0;\n        v0 \\<notin> dom (discovered s); s' = new_root v0 s\\<rbrakk>\n       \\<Longrightarrow> on_new_root cycc_params v0 s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G cycc_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              break (s'\\<lparr>state.more := x\\<rparr>) =\n                              (back_edges\n                                (s'\\<lparr>state.more := x\\<rparr>) \\<noteq>\n                               {}))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G cycc_params s;\n        break s = (back_edges s \\<noteq> {}); cond s;\n        \\<not> is_break cycc_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish cycc_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G cycc_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              break (s'\\<lparr>state.more := x\\<rparr>) =\n                              (back_edges\n                                (s'\\<lparr>state.more := x\\<rparr>) \\<noteq>\n                               {}))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G cycc_params s;\n        break s = (back_edges s \\<noteq> {}); cond s;\n        \\<not> is_break cycc_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge cycc_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G cycc_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              break (s'\\<lparr>state.more := x\\<rparr>) =\n                              (back_edges\n                                (s'\\<lparr>state.more := x\\<rparr>) \\<noteq>\n                               {}))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G cycc_params s;\n        break s = (back_edges s \\<noteq> {}); cond s;\n        \\<not> is_break cycc_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge cycc_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G cycc_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              break (s'\\<lparr>state.more := x\\<rparr>) =\n                              (back_edges\n                                (s'\\<lparr>state.more := x\\<rparr>) \\<noteq>\n                               {}))\n 6. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G cycc_params s;\n        break s = (back_edges s \\<noteq> {}); cond s;\n        \\<not> is_break cycc_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<notin> dom (discovered s);\n        s' =\n        discover u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover cycc_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G cycc_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              break (s'\\<lparr>state.more := x\\<rparr>) =\n                              (back_edges\n                                (s'\\<lparr>state.more := x\\<rparr>) \\<noteq>\n                               {}))", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. on_init cycc_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         break (empty_state x) = (back_edges (empty_state x) \\<noteq> {}))", "by (simp add: empty_state_def)"], ["proof (state)\nthis:\n  on_init cycc_params \\<le>\\<^sub>n\n  SPEC\n   (\\<lambda>x.\n       break (empty_state x) = (back_edges (empty_state x) \\<noteq> {}))\n\ngoal (5 subgoals):\n 1. \\<And>s s' v0.\n       \\<lbrakk>DFS_invar G cycc_params s;\n        break s = (back_edges s \\<noteq> {}); cond s;\n        \\<not> is_break cycc_params s; stack s = []; v0 \\<in> V0;\n        v0 \\<notin> dom (discovered s); s' = new_root v0 s\\<rbrakk>\n       \\<Longrightarrow> on_new_root cycc_params v0 s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G cycc_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              break (s'\\<lparr>state.more := x\\<rparr>) =\n                              (back_edges\n                                (s'\\<lparr>state.more := x\\<rparr>) \\<noteq>\n                               {}))\n 2. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G cycc_params s;\n        break s = (back_edges s \\<noteq> {}); cond s;\n        \\<not> is_break cycc_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish cycc_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G cycc_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              break (s'\\<lparr>state.more := x\\<rparr>) =\n                              (back_edges\n                                (s'\\<lparr>state.more := x\\<rparr>) \\<noteq>\n                               {}))\n 3. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G cycc_params s;\n        break s = (back_edges s \\<noteq> {}); cond s;\n        \\<not> is_break cycc_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge cycc_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G cycc_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              break (s'\\<lparr>state.more := x\\<rparr>) =\n                              (back_edges\n                                (s'\\<lparr>state.more := x\\<rparr>) \\<noteq>\n                               {}))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G cycc_params s;\n        break s = (back_edges s \\<noteq> {}); cond s;\n        \\<not> is_break cycc_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge cycc_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G cycc_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              break (s'\\<lparr>state.more := x\\<rparr>) =\n                              (back_edges\n                                (s'\\<lparr>state.more := x\\<rparr>) \\<noteq>\n                               {}))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G cycc_params s;\n        break s = (back_edges s \\<noteq> {}); cond s;\n        \\<not> is_break cycc_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<notin> dom (discovered s);\n        s' =\n        discover u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover cycc_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G cycc_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              break (s'\\<lparr>state.more := x\\<rparr>) =\n                              (back_edges\n                                (s'\\<lparr>state.more := x\\<rparr>) \\<noteq>\n                               {}))", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>s s' v0.\n       \\<lbrakk>DFS_invar G cycc_params s;\n        break s = (back_edges s \\<noteq> {}); cond s;\n        \\<not> is_break cycc_params s; stack s = []; v0 \\<in> V0;\n        v0 \\<notin> dom (discovered s); s' = new_root v0 s\\<rbrakk>\n       \\<Longrightarrow> on_new_root cycc_params v0 s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G cycc_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              break (s'\\<lparr>state.more := x\\<rparr>) =\n                              (back_edges\n                                (s'\\<lparr>state.more := x\\<rparr>) \\<noteq>\n                               {}))\n 2. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G cycc_params s;\n        break s = (back_edges s \\<noteq> {}); cond s;\n        \\<not> is_break cycc_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish cycc_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G cycc_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              break (s'\\<lparr>state.more := x\\<rparr>) =\n                              (back_edges\n                                (s'\\<lparr>state.more := x\\<rparr>) \\<noteq>\n                               {}))\n 3. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G cycc_params s;\n        break s = (back_edges s \\<noteq> {}); cond s;\n        \\<not> is_break cycc_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge cycc_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G cycc_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              break (s'\\<lparr>state.more := x\\<rparr>) =\n                              (back_edges\n                                (s'\\<lparr>state.more := x\\<rparr>) \\<noteq>\n                               {}))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G cycc_params s;\n        break s = (back_edges s \\<noteq> {}); cond s;\n        \\<not> is_break cycc_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge cycc_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G cycc_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              break (s'\\<lparr>state.more := x\\<rparr>) =\n                              (back_edges\n                                (s'\\<lparr>state.more := x\\<rparr>) \\<noteq>\n                               {}))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G cycc_params s;\n        break s = (back_edges s \\<noteq> {}); cond s;\n        \\<not> is_break cycc_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<notin> dom (discovered s);\n        s' =\n        discover u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover cycc_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G cycc_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              break (s'\\<lparr>state.more := x\\<rparr>) =\n                              (back_edges\n                                (s'\\<lparr>state.more := x\\<rparr>) \\<noteq>\n                               {}))", "case (back_edge s s' u v)"], ["proof (state)\nthis:\n  DFS_invar G cycc_params s\n  break s = (back_edges s \\<noteq> {})\n  cond s\n  \\<not> is_break cycc_params s\n  stack s \\<noteq> []\n  (u, v) \\<in> pending s\n  u = hd (stack s)\n  v \\<in> dom (discovered s)\n  v \\<notin> dom (finished s)\n  s' = back_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n\ngoal (5 subgoals):\n 1. \\<And>s s' v0.\n       \\<lbrakk>DFS_invar G cycc_params s;\n        break s = (back_edges s \\<noteq> {}); cond s;\n        \\<not> is_break cycc_params s; stack s = []; v0 \\<in> V0;\n        v0 \\<notin> dom (discovered s); s' = new_root v0 s\\<rbrakk>\n       \\<Longrightarrow> on_new_root cycc_params v0 s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G cycc_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              break (s'\\<lparr>state.more := x\\<rparr>) =\n                              (back_edges\n                                (s'\\<lparr>state.more := x\\<rparr>) \\<noteq>\n                               {}))\n 2. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G cycc_params s;\n        break s = (back_edges s \\<noteq> {}); cond s;\n        \\<not> is_break cycc_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish cycc_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G cycc_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              break (s'\\<lparr>state.more := x\\<rparr>) =\n                              (back_edges\n                                (s'\\<lparr>state.more := x\\<rparr>) \\<noteq>\n                               {}))\n 3. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G cycc_params s;\n        break s = (back_edges s \\<noteq> {}); cond s;\n        \\<not> is_break cycc_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge cycc_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G cycc_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              break (s'\\<lparr>state.more := x\\<rparr>) =\n                              (back_edges\n                                (s'\\<lparr>state.more := x\\<rparr>) \\<noteq>\n                               {}))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G cycc_params s;\n        break s = (back_edges s \\<noteq> {}); cond s;\n        \\<not> is_break cycc_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge cycc_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G cycc_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              break (s'\\<lparr>state.more := x\\<rparr>) =\n                              (back_edges\n                                (s'\\<lparr>state.more := x\\<rparr>) \\<noteq>\n                               {}))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G cycc_params s;\n        break s = (back_edges s \\<noteq> {}); cond s;\n        \\<not> is_break cycc_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<notin> dom (discovered s);\n        s' =\n        discover u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover cycc_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G cycc_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              break (s'\\<lparr>state.more := x\\<rparr>) =\n                              (back_edges\n                                (s'\\<lparr>state.more := x\\<rparr>) \\<noteq>\n                               {}))", "txt \\<open>For proving invariant preservation, we may assume that the invariant \n      holds on the previous state. Interpreting the invariant locale makes \n      available all invariants ever proved into this locale (i.e., the invariants \n      from all loaded libraries, and the ones you proved yourself.).\n      \\<close>"], ["proof (state)\nthis:\n  DFS_invar G cycc_params s\n  break s = (back_edges s \\<noteq> {})\n  cond s\n  \\<not> is_break cycc_params s\n  stack s \\<noteq> []\n  (u, v) \\<in> pending s\n  u = hd (stack s)\n  v \\<in> dom (discovered s)\n  v \\<notin> dom (finished s)\n  s' = back_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n\ngoal (5 subgoals):\n 1. \\<And>s s' v0.\n       \\<lbrakk>DFS_invar G cycc_params s;\n        break s = (back_edges s \\<noteq> {}); cond s;\n        \\<not> is_break cycc_params s; stack s = []; v0 \\<in> V0;\n        v0 \\<notin> dom (discovered s); s' = new_root v0 s\\<rbrakk>\n       \\<Longrightarrow> on_new_root cycc_params v0 s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G cycc_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              break (s'\\<lparr>state.more := x\\<rparr>) =\n                              (back_edges\n                                (s'\\<lparr>state.more := x\\<rparr>) \\<noteq>\n                               {}))\n 2. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G cycc_params s;\n        break s = (back_edges s \\<noteq> {}); cond s;\n        \\<not> is_break cycc_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish cycc_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G cycc_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              break (s'\\<lparr>state.more := x\\<rparr>) =\n                              (back_edges\n                                (s'\\<lparr>state.more := x\\<rparr>) \\<noteq>\n                               {}))\n 3. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G cycc_params s;\n        break s = (back_edges s \\<noteq> {}); cond s;\n        \\<not> is_break cycc_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge cycc_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G cycc_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              break (s'\\<lparr>state.more := x\\<rparr>) =\n                              (back_edges\n                                (s'\\<lparr>state.more := x\\<rparr>) \\<noteq>\n                               {}))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G cycc_params s;\n        break s = (back_edges s \\<noteq> {}); cond s;\n        \\<not> is_break cycc_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge cycc_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G cycc_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              break (s'\\<lparr>state.more := x\\<rparr>) =\n                              (back_edges\n                                (s'\\<lparr>state.more := x\\<rparr>) \\<noteq>\n                               {}))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G cycc_params s;\n        break s = (back_edges s \\<noteq> {}); cond s;\n        \\<not> is_break cycc_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<notin> dom (discovered s);\n        s' =\n        discover u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover cycc_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G cycc_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              break (s'\\<lparr>state.more := x\\<rparr>) =\n                              (back_edges\n                                (s'\\<lparr>state.more := x\\<rparr>) \\<noteq>\n                               {}))", "then"], ["proof (chain)\npicking this:\n  DFS_invar G cycc_params s\n  break s = (back_edges s \\<noteq> {})\n  cond s\n  \\<not> is_break cycc_params s\n  stack s \\<noteq> []\n  (u, v) \\<in> pending s\n  u = hd (stack s)\n  v \\<in> dom (discovered s)\n  v \\<notin> dom (finished s)\n  s' = back_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)", "interpret cycc_invar G s"], ["proof (prove)\nusing this:\n  DFS_invar G cycc_params s\n  break s = (back_edges s \\<noteq> {})\n  cond s\n  \\<not> is_break cycc_params s\n  stack s \\<noteq> []\n  (u, v) \\<in> pending s\n  u = hd (stack s)\n  v \\<in> dom (discovered s)\n  v \\<notin> dom (finished s)\n  s' = back_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n\ngoal (1 subgoal):\n 1. cycc_invar G s", "by simp"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>s s' v0.\n       \\<lbrakk>DFS_invar G cycc_params s;\n        break s = (back_edges s \\<noteq> {}); cond s;\n        \\<not> is_break cycc_params s; stack s = []; v0 \\<in> V0;\n        v0 \\<notin> dom (discovered s); s' = new_root v0 s\\<rbrakk>\n       \\<Longrightarrow> on_new_root cycc_params v0 s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G cycc_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              break (s'\\<lparr>state.more := x\\<rparr>) =\n                              (back_edges\n                                (s'\\<lparr>state.more := x\\<rparr>) \\<noteq>\n                               {}))\n 2. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G cycc_params s;\n        break s = (back_edges s \\<noteq> {}); cond s;\n        \\<not> is_break cycc_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish cycc_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G cycc_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              break (s'\\<lparr>state.more := x\\<rparr>) =\n                              (back_edges\n                                (s'\\<lparr>state.more := x\\<rparr>) \\<noteq>\n                               {}))\n 3. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G cycc_params s;\n        break s = (back_edges s \\<noteq> {}); cond s;\n        \\<not> is_break cycc_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge cycc_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G cycc_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              break (s'\\<lparr>state.more := x\\<rparr>) =\n                              (back_edges\n                                (s'\\<lparr>state.more := x\\<rparr>) \\<noteq>\n                               {}))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G cycc_params s;\n        break s = (back_edges s \\<noteq> {}); cond s;\n        \\<not> is_break cycc_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge cycc_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G cycc_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              break (s'\\<lparr>state.more := x\\<rparr>) =\n                              (back_edges\n                                (s'\\<lparr>state.more := x\\<rparr>) \\<noteq>\n                               {}))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G cycc_params s;\n        break s = (back_edges s \\<noteq> {}); cond s;\n        \\<not> is_break cycc_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<notin> dom (discovered s);\n        s' =\n        discover u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover cycc_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G cycc_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              break (s'\\<lparr>state.more := x\\<rparr>) =\n                              (back_edges\n                                (s'\\<lparr>state.more := x\\<rparr>) \\<noteq>\n                               {}))", "txt \\<open>However, here we do not need them:\\<close>"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>s s' v0.\n       \\<lbrakk>DFS_invar G cycc_params s;\n        break s = (back_edges s \\<noteq> {}); cond s;\n        \\<not> is_break cycc_params s; stack s = []; v0 \\<in> V0;\n        v0 \\<notin> dom (discovered s); s' = new_root v0 s\\<rbrakk>\n       \\<Longrightarrow> on_new_root cycc_params v0 s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G cycc_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              break (s'\\<lparr>state.more := x\\<rparr>) =\n                              (back_edges\n                                (s'\\<lparr>state.more := x\\<rparr>) \\<noteq>\n                               {}))\n 2. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G cycc_params s;\n        break s = (back_edges s \\<noteq> {}); cond s;\n        \\<not> is_break cycc_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish cycc_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G cycc_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              break (s'\\<lparr>state.more := x\\<rparr>) =\n                              (back_edges\n                                (s'\\<lparr>state.more := x\\<rparr>) \\<noteq>\n                               {}))\n 3. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G cycc_params s;\n        break s = (back_edges s \\<noteq> {}); cond s;\n        \\<not> is_break cycc_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge cycc_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G cycc_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              break (s'\\<lparr>state.more := x\\<rparr>) =\n                              (back_edges\n                                (s'\\<lparr>state.more := x\\<rparr>) \\<noteq>\n                               {}))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G cycc_params s;\n        break s = (back_edges s \\<noteq> {}); cond s;\n        \\<not> is_break cycc_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge cycc_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G cycc_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              break (s'\\<lparr>state.more := x\\<rparr>) =\n                              (back_edges\n                                (s'\\<lparr>state.more := x\\<rparr>) \\<noteq>\n                               {}))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G cycc_params s;\n        break s = (back_edges s \\<noteq> {}); cond s;\n        \\<not> is_break cycc_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<notin> dom (discovered s);\n        s' =\n        discover u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover cycc_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G cycc_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              break (s'\\<lparr>state.more := x\\<rparr>) =\n                              (back_edges\n                                (s'\\<lparr>state.more := x\\<rparr>) \\<noteq>\n                               {}))", "from back_edge"], ["proof (chain)\npicking this:\n  DFS_invar G cycc_params s\n  break s = (back_edges s \\<noteq> {})\n  cond s\n  \\<not> is_break cycc_params s\n  stack s \\<noteq> []\n  (u, v) \\<in> pending s\n  u = hd (stack s)\n  v \\<in> dom (discovered s)\n  v \\<notin> dom (finished s)\n  s' = back_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)", "show ?case"], ["proof (prove)\nusing this:\n  DFS_invar G cycc_params s\n  break s = (back_edges s \\<noteq> {})\n  cond s\n  \\<not> is_break cycc_params s\n  stack s \\<noteq> []\n  (u, v) \\<in> pending s\n  u = hd (stack s)\n  v \\<in> dom (discovered s)\n  v \\<notin> dom (finished s)\n  s' = back_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n\ngoal (1 subgoal):\n 1. on_back_edge cycc_params u v s' \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         DFS_invar G cycc_params\n          (s'\\<lparr>state.more := x\\<rparr>) \\<longrightarrow>\n         break (s'\\<lparr>state.more := x\\<rparr>) =\n         (back_edges (s'\\<lparr>state.more := x\\<rparr>) \\<noteq> {}))", "by simp"], ["proof (state)\nthis:\n  on_back_edge cycc_params u v s' \\<le>\\<^sub>n\n  SPEC\n   (\\<lambda>x.\n       DFS_invar G cycc_params\n        (s'\\<lparr>state.more := x\\<rparr>) \\<longrightarrow>\n       break (s'\\<lparr>state.more := x\\<rparr>) =\n       (back_edges (s'\\<lparr>state.more := x\\<rparr>) \\<noteq> {}))\n\ngoal (4 subgoals):\n 1. \\<And>s s' v0.\n       \\<lbrakk>DFS_invar G cycc_params s;\n        break s = (back_edges s \\<noteq> {}); cond s;\n        \\<not> is_break cycc_params s; stack s = []; v0 \\<in> V0;\n        v0 \\<notin> dom (discovered s); s' = new_root v0 s\\<rbrakk>\n       \\<Longrightarrow> on_new_root cycc_params v0 s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G cycc_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              break (s'\\<lparr>state.more := x\\<rparr>) =\n                              (back_edges\n                                (s'\\<lparr>state.more := x\\<rparr>) \\<noteq>\n                               {}))\n 2. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G cycc_params s;\n        break s = (back_edges s \\<noteq> {}); cond s;\n        \\<not> is_break cycc_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish cycc_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G cycc_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              break (s'\\<lparr>state.more := x\\<rparr>) =\n                              (back_edges\n                                (s'\\<lparr>state.more := x\\<rparr>) \\<noteq>\n                               {}))\n 3. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G cycc_params s;\n        break s = (back_edges s \\<noteq> {}); cond s;\n        \\<not> is_break cycc_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge cycc_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G cycc_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              break (s'\\<lparr>state.more := x\\<rparr>) =\n                              (back_edges\n                                (s'\\<lparr>state.more := x\\<rparr>) \\<noteq>\n                               {}))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G cycc_params s;\n        break s = (back_edges s \\<noteq> {}); cond s;\n        \\<not> is_break cycc_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<notin> dom (discovered s);\n        s' =\n        discover u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover cycc_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G cycc_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              break (s'\\<lparr>state.more := x\\<rparr>) =\n                              (back_edges\n                                (s'\\<lparr>state.more := x\\<rparr>) \\<noteq>\n                               {}))", "qed (simp_all cong: break_more_cong)"], ["", "text \\<open>For technical reasons, invariants are proved in the basic locale, \n    and then transferred to the invariant locale:\\<close>"], ["", "lemmas brk_eq_back = i_brk_eq_back[THEN make_invar_thm]"], ["", "text \\<open>The above lemma is simple enough to have a short apply-style proof:\\<close>"], ["", "lemma (in cycc) i_brk_eq_back_short_proof: \n    \"is_invar (\\<lambda>s. break s \\<longleftrightarrow> back_edges s \\<noteq> {})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_invar (\\<lambda>s. break s = (back_edges s \\<noteq> {}))", "apply (induct rule: establish_invarI)"], ["proof (prove)\ngoal (6 subgoals):\n 1. on_init cycc_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         break (empty_state x) = (back_edges (empty_state x) \\<noteq> {}))\n 2. \\<And>s s' v0.\n       \\<lbrakk>DFS_invar G cycc_params s;\n        break s = (back_edges s \\<noteq> {}); cond s;\n        \\<not> is_break cycc_params s; stack s = []; v0 \\<in> V0;\n        v0 \\<notin> dom (discovered s); s' = new_root v0 s\\<rbrakk>\n       \\<Longrightarrow> on_new_root cycc_params v0 s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G cycc_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              break (s'\\<lparr>state.more := x\\<rparr>) =\n                              (back_edges\n                                (s'\\<lparr>state.more := x\\<rparr>) \\<noteq>\n                               {}))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G cycc_params s;\n        break s = (back_edges s \\<noteq> {}); cond s;\n        \\<not> is_break cycc_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish cycc_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G cycc_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              break (s'\\<lparr>state.more := x\\<rparr>) =\n                              (back_edges\n                                (s'\\<lparr>state.more := x\\<rparr>) \\<noteq>\n                               {}))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G cycc_params s;\n        break s = (back_edges s \\<noteq> {}); cond s;\n        \\<not> is_break cycc_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge cycc_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G cycc_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              break (s'\\<lparr>state.more := x\\<rparr>) =\n                              (back_edges\n                                (s'\\<lparr>state.more := x\\<rparr>) \\<noteq>\n                               {}))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G cycc_params s;\n        break s = (back_edges s \\<noteq> {}); cond s;\n        \\<not> is_break cycc_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge cycc_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G cycc_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              break (s'\\<lparr>state.more := x\\<rparr>) =\n                              (back_edges\n                                (s'\\<lparr>state.more := x\\<rparr>) \\<noteq>\n                               {}))\n 6. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G cycc_params s;\n        break s = (back_edges s \\<noteq> {}); cond s;\n        \\<not> is_break cycc_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<notin> dom (discovered s);\n        s' =\n        discover u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover cycc_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G cycc_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              break (s'\\<lparr>state.more := x\\<rparr>) =\n                              (back_edges\n                                (s'\\<lparr>state.more := x\\<rparr>) \\<noteq>\n                               {}))", "apply (simp_all add: cond_def cong: break_more_cong)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> break (empty_state \\<lparr>break = False\\<rparr>)", "apply (simp add: empty_state_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>Now, when we know that the break flag indicates back-edges,\n    we can easily prove correctness, using a lemma from the invariant \n    library:\\<close>"], ["", "thm cycle_iff_back_edges"], ["", "lemma cycc_correct_aux: \n    assumes NC: \"\\<not>cond s\"\n    shows \"break s \\<longleftrightarrow> \\<not>acyclic (E \\<inter> reachable \\<times> UNIV)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. break s = (\\<not> acyclic (E \\<inter> reachable \\<times> UNIV))", "proof (cases \"break s\", simp_all)"], ["proof (state)\ngoal (2 subgoals):\n 1. break s \\<Longrightarrow>\n    \\<not> acyclic (E \\<inter> reachable \\<times> UNIV)\n 2. \\<not> break s \\<Longrightarrow>\n    acyclic (E \\<inter> reachable \\<times> UNIV)", "assume \"break s\""], ["proof (state)\nthis:\n  break s\n\ngoal (2 subgoals):\n 1. break s \\<Longrightarrow>\n    \\<not> acyclic (E \\<inter> reachable \\<times> UNIV)\n 2. \\<not> break s \\<Longrightarrow>\n    acyclic (E \\<inter> reachable \\<times> UNIV)", "with brk_eq_back"], ["proof (chain)\npicking this:\n  break s = (back_edges s \\<noteq> {})\n  break s", "have \"back_edges s \\<noteq> {}\""], ["proof (prove)\nusing this:\n  break s = (back_edges s \\<noteq> {})\n  break s\n\ngoal (1 subgoal):\n 1. back_edges s \\<noteq> {}", "by simp"], ["proof (state)\nthis:\n  back_edges s \\<noteq> {}\n\ngoal (2 subgoals):\n 1. break s \\<Longrightarrow>\n    \\<not> acyclic (E \\<inter> reachable \\<times> UNIV)\n 2. \\<not> break s \\<Longrightarrow>\n    acyclic (E \\<inter> reachable \\<times> UNIV)", "with cycle_iff_back_edges"], ["proof (chain)\npicking this:\n  acyclic (tree_edges s \\<union> cross_edges s \\<union> back_edges s) =\n  (back_edges s = {})\n  back_edges s \\<noteq> {}", "have \"\\<not>acyclic (edges s)\""], ["proof (prove)\nusing this:\n  acyclic (tree_edges s \\<union> cross_edges s \\<union> back_edges s) =\n  (back_edges s = {})\n  back_edges s \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<not> acyclic\n            (tree_edges s \\<union> cross_edges s \\<union> back_edges s)", "by simp"], ["proof (state)\nthis:\n  \\<not> acyclic (tree_edges s \\<union> cross_edges s \\<union> back_edges s)\n\ngoal (2 subgoals):\n 1. break s \\<Longrightarrow>\n    \\<not> acyclic (E \\<inter> reachable \\<times> UNIV)\n 2. \\<not> break s \\<Longrightarrow>\n    acyclic (E \\<inter> reachable \\<times> UNIV)", "with acyclic_subset[OF _ edges_ss_reachable_edges]"], ["proof (chain)\npicking this:\n  acyclic (E \\<inter> reachable \\<times> UNIV) \\<Longrightarrow>\n  acyclic (tree_edges s \\<union> cross_edges s \\<union> back_edges s)\n  \\<not> acyclic (tree_edges s \\<union> cross_edges s \\<union> back_edges s)", "show \"\\<not>acyclic (E \\<inter> reachable \\<times> UNIV)\""], ["proof (prove)\nusing this:\n  acyclic (E \\<inter> reachable \\<times> UNIV) \\<Longrightarrow>\n  acyclic (tree_edges s \\<union> cross_edges s \\<union> back_edges s)\n  \\<not> acyclic (tree_edges s \\<union> cross_edges s \\<union> back_edges s)\n\ngoal (1 subgoal):\n 1. \\<not> acyclic (E \\<inter> reachable \\<times> UNIV)", "by blast"], ["proof (state)\nthis:\n  \\<not> acyclic (E \\<inter> reachable \\<times> UNIV)\n\ngoal (1 subgoal):\n 1. \\<not> break s \\<Longrightarrow>\n    acyclic (E \\<inter> reachable \\<times> UNIV)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> break s \\<Longrightarrow>\n    acyclic (E \\<inter> reachable \\<times> UNIV)", "assume A: \"\\<not>break s\""], ["proof (state)\nthis:\n  \\<not> break s\n\ngoal (1 subgoal):\n 1. \\<not> break s \\<Longrightarrow>\n    acyclic (E \\<inter> reachable \\<times> UNIV)", "from A brk_eq_back"], ["proof (chain)\npicking this:\n  \\<not> break s\n  break s = (back_edges s \\<noteq> {})", "have \"back_edges s = {}\""], ["proof (prove)\nusing this:\n  \\<not> break s\n  break s = (back_edges s \\<noteq> {})\n\ngoal (1 subgoal):\n 1. back_edges s = {}", "by simp"], ["proof (state)\nthis:\n  back_edges s = {}\n\ngoal (1 subgoal):\n 1. \\<not> break s \\<Longrightarrow>\n    acyclic (E \\<inter> reachable \\<times> UNIV)", "with cycle_iff_back_edges"], ["proof (chain)\npicking this:\n  acyclic (tree_edges s \\<union> cross_edges s \\<union> back_edges s) =\n  (back_edges s = {})\n  back_edges s = {}", "have \"acyclic (edges s)\""], ["proof (prove)\nusing this:\n  acyclic (tree_edges s \\<union> cross_edges s \\<union> back_edges s) =\n  (back_edges s = {})\n  back_edges s = {}\n\ngoal (1 subgoal):\n 1. acyclic (tree_edges s \\<union> cross_edges s \\<union> back_edges s)", "by simp"], ["proof (state)\nthis:\n  acyclic (tree_edges s \\<union> cross_edges s \\<union> back_edges s)\n\ngoal (1 subgoal):\n 1. \\<not> break s \\<Longrightarrow>\n    acyclic (E \\<inter> reachable \\<times> UNIV)", "also"], ["proof (state)\nthis:\n  acyclic (tree_edges s \\<union> cross_edges s \\<union> back_edges s)\n\ngoal (1 subgoal):\n 1. \\<not> break s \\<Longrightarrow>\n    acyclic (E \\<inter> reachable \\<times> UNIV)", "from A nc_edges_covered[OF NC]"], ["proof (chain)\npicking this:\n  \\<not> break s\n  \\<not> is_break cycc_params s \\<Longrightarrow>\n  E \\<inter> reachable \\<times> UNIV =\n  tree_edges s \\<union> cross_edges s \\<union> back_edges s", "have \"edges s = E \\<inter> reachable \\<times> UNIV\""], ["proof (prove)\nusing this:\n  \\<not> break s\n  \\<not> is_break cycc_params s \\<Longrightarrow>\n  E \\<inter> reachable \\<times> UNIV =\n  tree_edges s \\<union> cross_edges s \\<union> back_edges s\n\ngoal (1 subgoal):\n 1. tree_edges s \\<union> cross_edges s \\<union> back_edges s =\n    E \\<inter> reachable \\<times> UNIV", "by simp"], ["proof (state)\nthis:\n  tree_edges s \\<union> cross_edges s \\<union> back_edges s =\n  E \\<inter> reachable \\<times> UNIV\n\ngoal (1 subgoal):\n 1. \\<not> break s \\<Longrightarrow>\n    acyclic (E \\<inter> reachable \\<times> UNIV)", "finally"], ["proof (chain)\npicking this:\n  acyclic (E \\<inter> reachable \\<times> UNIV)", "show \"acyclic (E \\<inter> reachable \\<times> UNIV)\""], ["proof (prove)\nusing this:\n  acyclic (E \\<inter> reachable \\<times> UNIV)\n\ngoal (1 subgoal):\n 1. acyclic (E \\<inter> reachable \\<times> UNIV)", "."], ["proof (state)\nthis:\n  acyclic (E \\<inter> reachable \\<times> UNIV)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Again, we have a short two-line proof:\\<close>"], ["", "lemma cycc_correct_aux_short_proof:\n    assumes NC: \"\\<not>cond s\"\n    shows \"break s \\<longleftrightarrow> \\<not>acyclic (E \\<inter> reachable \\<times> UNIV)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. break s = (\\<not> acyclic (E \\<inter> reachable \\<times> UNIV))", "using nc_edges_covered[OF NC] brk_eq_back cycle_iff_back_edges"], ["proof (prove)\nusing this:\n  \\<not> is_break cycc_params s \\<Longrightarrow>\n  E \\<inter> reachable \\<times> UNIV =\n  tree_edges s \\<union> cross_edges s \\<union> back_edges s\n  break s = (back_edges s \\<noteq> {})\n  acyclic (tree_edges s \\<union> cross_edges s \\<union> back_edges s) =\n  (back_edges s = {})\n\ngoal (1 subgoal):\n 1. break s = (\\<not> acyclic (E \\<inter> reachable \\<times> UNIV))", "by (auto dest: acyclic_subset[OF _ edges_ss_reachable_edges])"], ["", "end"], ["", "text \\<open>Finally, we define a specification for cyclicity checking,\n  and prove that our cyclicity checker satisfies the specification: \\<close>"], ["", "definition \"cyc_checker_spec G \\<equiv> do {\n  ASSERT (fb_graph G);\n  SPEC (\\<lambda>r. r \\<longleftrightarrow> \\<not>acyclic (g_E G \\<inter> ((g_E G)\\<^sup>* `` g_V0 G) \\<times> UNIV))}\""], ["", "theorem cyc_checker_correct: \"cyc_checker G \\<le> cyc_checker_spec G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cyc_checker G \\<le> cyc_checker_spec G", "unfolding cyc_checker_def cyc_checker_spec_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ASSERT (fb_graph G) \\<bind>\n    (\\<lambda>_.\n        param_DFS_defs.it_dfs G cycc_params \\<bind>\n        (\\<lambda>s. RETURN (break s)))\n    \\<le> ASSERT (fb_graph G) \\<bind>\n          (\\<lambda>_.\n              SPEC\n               (\\<lambda>r.\n                   r =\n                   (\\<not> acyclic\n                            (g_E G \\<inter>\n                             (g_E G)\\<^sup>* `` g_V0 G \\<times> UNIV))))", "proof (refine_vcg le_ASSERTI order_trans[OF DFS.it_dfs_correct], clarsimp_all)"], ["proof (state)\ngoal (2 subgoals):\n 1. fb_graph G \\<Longrightarrow> DFS G cycc_params\n 2. \\<And>x.\n       \\<lbrakk>fb_graph G; cycc_invar G x;\n        \\<not> param_DFS_defs.cond G cycc_params x\\<rbrakk>\n       \\<Longrightarrow> break x =\n                         (\\<not> acyclic\n                                  (g_E G \\<inter>\n                                   (g_E G)\\<^sup>* `` g_V0 G \\<times> UNIV))", "assume \"fb_graph G\""], ["proof (state)\nthis:\n  fb_graph G\n\ngoal (2 subgoals):\n 1. fb_graph G \\<Longrightarrow> DFS G cycc_params\n 2. \\<And>x.\n       \\<lbrakk>fb_graph G; cycc_invar G x;\n        \\<not> param_DFS_defs.cond G cycc_params x\\<rbrakk>\n       \\<Longrightarrow> break x =\n                         (\\<not> acyclic\n                                  (g_E G \\<inter>\n                                   (g_E G)\\<^sup>* `` g_V0 G \\<times> UNIV))", "then"], ["proof (chain)\npicking this:\n  fb_graph G", "interpret fb_graph G"], ["proof (prove)\nusing this:\n  fb_graph G\n\ngoal (1 subgoal):\n 1. fb_graph G", "."], ["proof (state)\ngoal (2 subgoals):\n 1. fb_graph G \\<Longrightarrow> DFS G cycc_params\n 2. \\<And>x.\n       \\<lbrakk>fb_graph G; cycc_invar G x;\n        \\<not> param_DFS_defs.cond G cycc_params x\\<rbrakk>\n       \\<Longrightarrow> break x =\n                         (\\<not> acyclic\n                                  (g_E G \\<inter>\n                                   (g_E G)\\<^sup>* `` g_V0 G \\<times> UNIV))", "interpret cycc"], ["proof (prove)\ngoal (1 subgoal):\n 1. cycc G", "by unfold_locales"], ["proof (state)\ngoal (2 subgoals):\n 1. fb_graph G \\<Longrightarrow> DFS G cycc_params\n 2. \\<And>x.\n       \\<lbrakk>fb_graph G; cycc_invar G x;\n        \\<not> param_DFS_defs.cond G cycc_params x\\<rbrakk>\n       \\<Longrightarrow> break x =\n                         (\\<not> acyclic\n                                  (g_E G \\<inter>\n                                   (g_E G)\\<^sup>* `` g_V0 G \\<times> UNIV))", "show \"DFS G cycc_params\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DFS G cycc_params", "by unfold_locales"], ["proof (state)\nthis:\n  DFS G cycc_params\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>fb_graph G; cycc_invar G x;\n        \\<not> param_DFS_defs.cond G cycc_params x\\<rbrakk>\n       \\<Longrightarrow> break x =\n                         (\\<not> acyclic\n                                  (g_E G \\<inter>\n                                   (g_E G)\\<^sup>* `` g_V0 G \\<times> UNIV))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>fb_graph G; cycc_invar G x;\n        \\<not> param_DFS_defs.cond G cycc_params x\\<rbrakk>\n       \\<Longrightarrow> break x =\n                         (\\<not> acyclic\n                                  (g_E G \\<inter>\n                                   (g_E G)\\<^sup>* `` g_V0 G \\<times> UNIV))", "fix s"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>fb_graph G; cycc_invar G x;\n        \\<not> param_DFS_defs.cond G cycc_params x\\<rbrakk>\n       \\<Longrightarrow> break x =\n                         (\\<not> acyclic\n                                  (g_E G \\<inter>\n                                   (g_E G)\\<^sup>* `` g_V0 G \\<times> UNIV))", "assume \"cycc_invar G s\""], ["proof (state)\nthis:\n  cycc_invar G s\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>fb_graph G; cycc_invar G x;\n        \\<not> param_DFS_defs.cond G cycc_params x\\<rbrakk>\n       \\<Longrightarrow> break x =\n                         (\\<not> acyclic\n                                  (g_E G \\<inter>\n                                   (g_E G)\\<^sup>* `` g_V0 G \\<times> UNIV))", "then"], ["proof (chain)\npicking this:\n  cycc_invar G s", "interpret cycc_invar G s"], ["proof (prove)\nusing this:\n  cycc_invar G s\n\ngoal (1 subgoal):\n 1. cycc_invar G s", "."], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>fb_graph G; cycc_invar G x;\n        \\<not> param_DFS_defs.cond G cycc_params x\\<rbrakk>\n       \\<Longrightarrow> break x =\n                         (\\<not> acyclic\n                                  (g_E G \\<inter>\n                                   (g_E G)\\<^sup>* `` g_V0 G \\<times> UNIV))", "assume \"\\<not>cycc.cond TYPE('b) G s\""], ["proof (state)\nthis:\n  \\<not> param_DFS_defs.cond G cycc_params s\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>fb_graph G; cycc_invar G x;\n        \\<not> param_DFS_defs.cond G cycc_params x\\<rbrakk>\n       \\<Longrightarrow> break x =\n                         (\\<not> acyclic\n                                  (g_E G \\<inter>\n                                   (g_E G)\\<^sup>* `` g_V0 G \\<times> UNIV))", "thus \"break s = (\\<not> acyclic (g_E G \\<inter> cycc.reachable TYPE('b) G \\<times> UNIV))\""], ["proof (prove)\nusing this:\n  \\<not> param_DFS_defs.cond G cycc_params s\n\ngoal (1 subgoal):\n 1. break s =\n    (\\<not> acyclic\n             (g_E G \\<inter> (g_E G)\\<^sup>* `` g_V0 G \\<times> UNIV))", "by (rule cycc_correct_aux)"], ["proof (state)\nthis:\n  break s =\n  (\\<not> acyclic (g_E G \\<inter> (g_E G)\\<^sup>* `` g_V0 G \\<times> UNIV))\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>The same for the total correct variant:\\<close>"], ["", "definition \"cyc_checkerT_spec G \\<equiv> do {\n  ASSERT (graph G \\<and> finite (graph_defs.reachable G));\n  SPEC (\\<lambda>r. r \\<longleftrightarrow> \\<not>acyclic (g_E G \\<inter> ((g_E G)\\<^sup>* `` g_V0 G) \\<times> UNIV))}\""], ["", "theorem cyc_checkerT_correct: \"cyc_checkerT G \\<le> cyc_checkerT_spec G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cyc_checkerT G \\<le> cyc_checkerT_spec G", "unfolding cyc_checkerT_def cyc_checkerT_spec_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ASSERT (graph G \\<and> finite ((g_E G)\\<^sup>* `` g_V0 G)) \\<bind>\n    (\\<lambda>_.\n        param_DFS_defs.it_dfsT G cycc_params \\<bind>\n        (\\<lambda>s. RETURN (break s)))\n    \\<le> ASSERT (graph G \\<and> finite ((g_E G)\\<^sup>* `` g_V0 G)) \\<bind>\n          (\\<lambda>_.\n              SPEC\n               (\\<lambda>r.\n                   r =\n                   (\\<not> acyclic\n                            (g_E G \\<inter>\n                             (g_E G)\\<^sup>* `` g_V0 G \\<times> UNIV))))", "proof (refine_vcg le_ASSERTI order_trans[OF DFS.it_dfsT_correct], clarsimp_all)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>graph G; finite ((g_E G)\\<^sup>* `` g_V0 G)\\<rbrakk>\n    \\<Longrightarrow> DFS G cycc_params\n 2. \\<And>x.\n       \\<lbrakk>graph G; finite ((g_E G)\\<^sup>* `` g_V0 G); cycc_invar G x;\n        \\<not> param_DFS_defs.cond G cycc_params x\\<rbrakk>\n       \\<Longrightarrow> break x =\n                         (\\<not> acyclic\n                                  (g_E G \\<inter>\n                                   (g_E G)\\<^sup>* `` g_V0 G \\<times> UNIV))", "assume \"graph G\""], ["proof (state)\nthis:\n  graph G\n\ngoal (2 subgoals):\n 1. \\<lbrakk>graph G; finite ((g_E G)\\<^sup>* `` g_V0 G)\\<rbrakk>\n    \\<Longrightarrow> DFS G cycc_params\n 2. \\<And>x.\n       \\<lbrakk>graph G; finite ((g_E G)\\<^sup>* `` g_V0 G); cycc_invar G x;\n        \\<not> param_DFS_defs.cond G cycc_params x\\<rbrakk>\n       \\<Longrightarrow> break x =\n                         (\\<not> acyclic\n                                  (g_E G \\<inter>\n                                   (g_E G)\\<^sup>* `` g_V0 G \\<times> UNIV))", "then"], ["proof (chain)\npicking this:\n  graph G", "interpret graph G"], ["proof (prove)\nusing this:\n  graph G\n\ngoal (1 subgoal):\n 1. graph G", "."], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>graph G; finite ((g_E G)\\<^sup>* `` g_V0 G)\\<rbrakk>\n    \\<Longrightarrow> DFS G cycc_params\n 2. \\<And>x.\n       \\<lbrakk>graph G; finite ((g_E G)\\<^sup>* `` g_V0 G); cycc_invar G x;\n        \\<not> param_DFS_defs.cond G cycc_params x\\<rbrakk>\n       \\<Longrightarrow> break x =\n                         (\\<not> acyclic\n                                  (g_E G \\<inter>\n                                   (g_E G)\\<^sup>* `` g_V0 G \\<times> UNIV))", "assume \"finite (graph_defs.reachable G)\""], ["proof (state)\nthis:\n  finite ((g_E G)\\<^sup>* `` g_V0 G)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>graph G; finite ((g_E G)\\<^sup>* `` g_V0 G)\\<rbrakk>\n    \\<Longrightarrow> DFS G cycc_params\n 2. \\<And>x.\n       \\<lbrakk>graph G; finite ((g_E G)\\<^sup>* `` g_V0 G); cycc_invar G x;\n        \\<not> param_DFS_defs.cond G cycc_params x\\<rbrakk>\n       \\<Longrightarrow> break x =\n                         (\\<not> acyclic\n                                  (g_E G \\<inter>\n                                   (g_E G)\\<^sup>* `` g_V0 G \\<times> UNIV))", "then"], ["proof (chain)\npicking this:\n  finite ((g_E G)\\<^sup>* `` g_V0 G)", "interpret fb_graph G"], ["proof (prove)\nusing this:\n  finite ((g_E G)\\<^sup>* `` g_V0 G)\n\ngoal (1 subgoal):\n 1. fb_graph G", "by (rule fb_graphI_fr)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>graph G; finite ((g_E G)\\<^sup>* `` g_V0 G)\\<rbrakk>\n    \\<Longrightarrow> DFS G cycc_params\n 2. \\<And>x.\n       \\<lbrakk>graph G; finite ((g_E G)\\<^sup>* `` g_V0 G); cycc_invar G x;\n        \\<not> param_DFS_defs.cond G cycc_params x\\<rbrakk>\n       \\<Longrightarrow> break x =\n                         (\\<not> acyclic\n                                  (g_E G \\<inter>\n                                   (g_E G)\\<^sup>* `` g_V0 G \\<times> UNIV))", "interpret cycc"], ["proof (prove)\ngoal (1 subgoal):\n 1. cycc G", "by unfold_locales"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>graph G; finite ((g_E G)\\<^sup>* `` g_V0 G)\\<rbrakk>\n    \\<Longrightarrow> DFS G cycc_params\n 2. \\<And>x.\n       \\<lbrakk>graph G; finite ((g_E G)\\<^sup>* `` g_V0 G); cycc_invar G x;\n        \\<not> param_DFS_defs.cond G cycc_params x\\<rbrakk>\n       \\<Longrightarrow> break x =\n                         (\\<not> acyclic\n                                  (g_E G \\<inter>\n                                   (g_E G)\\<^sup>* `` g_V0 G \\<times> UNIV))", "show \"DFS G cycc_params\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DFS G cycc_params", "by unfold_locales"], ["proof (state)\nthis:\n  DFS G cycc_params\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>graph G; finite ((g_E G)\\<^sup>* `` g_V0 G); cycc_invar G x;\n        \\<not> param_DFS_defs.cond G cycc_params x\\<rbrakk>\n       \\<Longrightarrow> break x =\n                         (\\<not> acyclic\n                                  (g_E G \\<inter>\n                                   (g_E G)\\<^sup>* `` g_V0 G \\<times> UNIV))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>graph G; finite ((g_E G)\\<^sup>* `` g_V0 G); cycc_invar G x;\n        \\<not> param_DFS_defs.cond G cycc_params x\\<rbrakk>\n       \\<Longrightarrow> break x =\n                         (\\<not> acyclic\n                                  (g_E G \\<inter>\n                                   (g_E G)\\<^sup>* `` g_V0 G \\<times> UNIV))", "fix s"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>graph G; finite ((g_E G)\\<^sup>* `` g_V0 G); cycc_invar G x;\n        \\<not> param_DFS_defs.cond G cycc_params x\\<rbrakk>\n       \\<Longrightarrow> break x =\n                         (\\<not> acyclic\n                                  (g_E G \\<inter>\n                                   (g_E G)\\<^sup>* `` g_V0 G \\<times> UNIV))", "assume \"cycc_invar G s\""], ["proof (state)\nthis:\n  cycc_invar G s\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>graph G; finite ((g_E G)\\<^sup>* `` g_V0 G); cycc_invar G x;\n        \\<not> param_DFS_defs.cond G cycc_params x\\<rbrakk>\n       \\<Longrightarrow> break x =\n                         (\\<not> acyclic\n                                  (g_E G \\<inter>\n                                   (g_E G)\\<^sup>* `` g_V0 G \\<times> UNIV))", "then"], ["proof (chain)\npicking this:\n  cycc_invar G s", "interpret cycc_invar G s"], ["proof (prove)\nusing this:\n  cycc_invar G s\n\ngoal (1 subgoal):\n 1. cycc_invar G s", "."], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>graph G; finite ((g_E G)\\<^sup>* `` g_V0 G); cycc_invar G x;\n        \\<not> param_DFS_defs.cond G cycc_params x\\<rbrakk>\n       \\<Longrightarrow> break x =\n                         (\\<not> acyclic\n                                  (g_E G \\<inter>\n                                   (g_E G)\\<^sup>* `` g_V0 G \\<times> UNIV))", "assume \"\\<not>cycc.cond TYPE('b) G s\""], ["proof (state)\nthis:\n  \\<not> param_DFS_defs.cond G cycc_params s\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>graph G; finite ((g_E G)\\<^sup>* `` g_V0 G); cycc_invar G x;\n        \\<not> param_DFS_defs.cond G cycc_params x\\<rbrakk>\n       \\<Longrightarrow> break x =\n                         (\\<not> acyclic\n                                  (g_E G \\<inter>\n                                   (g_E G)\\<^sup>* `` g_V0 G \\<times> UNIV))", "thus \"break s = (\\<not> acyclic (g_E G \\<inter> cycc.reachable TYPE('b) G \\<times> UNIV))\""], ["proof (prove)\nusing this:\n  \\<not> param_DFS_defs.cond G cycc_params s\n\ngoal (1 subgoal):\n 1. break s =\n    (\\<not> acyclic\n             (g_E G \\<inter> (g_E G)\\<^sup>* `` g_V0 G \\<times> UNIV))", "by (rule cycc_correct_aux)"], ["proof (state)\nthis:\n  break s =\n  (\\<not> acyclic (g_E G \\<inter> (g_E G)\\<^sup>* `` g_V0 G \\<times> UNIV))\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Implementation\\<close>"], ["", "text \\<open>\n  The implementation has two aspects: Structural implementation and data implementation.\n  The framework provides recursive and tail-recursive implementations, as well as a variety\n  of data structures for the state.\n\n  We will choose the \\<open>simple_state\\<close> implementation, which provides \n  a stack, an on-stack and a visited set, but no timing information.\n\n  Note that it is common for state implementations to omit details from the\n  very detailed abstract state. This means, that the algorithm's operations \n  must not access these details (e.g. timing). However, the algorithm's \n  correctness proofs may still use them.\n\\<close>"], ["", "text \\<open>We extend the state template to add a break flag\\<close>"], ["", "record 'v cycc_state_impl = \"'v simple_state\" +\n  break :: bool"], ["", "text \\<open>Definition of refinement relation: The break-flag is refined by identity.\\<close>"], ["", "definition \"cycc_erel \\<equiv> { \n  (\\<lparr> cycc_state_impl.break = b \\<rparr>, \\<lparr> cycc_state.break = b\\<rparr>) | b. True }\""], ["", "abbreviation \"cycc_rel \\<equiv> \\<langle>cycc_erel\\<rangle>simple_state_rel\""], ["", "text \\<open>Implementation of the parameters\\<close>"], ["", "definition cycc_params_impl \n  :: \"('v,'v cycc_state_impl,unit cycc_state_impl_ext) gen_parameterization\"\nwhere \"cycc_params_impl \n  \\<equiv> dflt_parametrization simple_state.more (RETURN \\<lparr> break = False \\<rparr>) \\<lparr>\n  on_back_edge := \\<lambda>u v s. RETURN \\<lparr> break = True \\<rparr>,\n  is_break := break \\<rparr>\""], ["", "lemmas cycc_params_impl_simp[simp,DFS_code_unfold] = \n  gen_parameterization.simps[mk_record_simp, OF cycc_params_impl_def[simplified]]"], ["", "text \\<open>Note: In this simple case, the reformulation of the extension state and \n  parameterization is just redundant, However, in general the refinement will \n  also affect the parameterization.\\<close>"], ["", "lemma break_impl: \"(si,s)\\<in>cycc_rel \n  \\<Longrightarrow> cycc_state_impl.break si = cycc_state.break s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (si, s) \\<in> cycc_rel \\<Longrightarrow>\n    cycc_state_impl.break si = cycc_state.break s", "by (cases si, cases s, simp add: simple_state_rel_def cycc_erel_def)"], ["", "interpretation cycc_impl: simple_impl_defs G cycc_params_impl cycc_params \n  for G"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "text \\<open>The above interpretation creates an iterative and a recursive implementation \\<close>"], ["", "term cycc_impl.tailrec_impl"], ["", "term cycc_impl.rec_impl"], ["", "term cycc_impl.tailrec_implT \\<comment> \\<open>Note, for total correctness we currently only support tail-recursive implementations.\\<close>"], ["", "text \\<open>We use both to derive a tail-recursive and a recursive cyclicity checker:\\<close>"], ["", "definition [DFS_code_unfold]: \"cyc_checker_impl G \\<equiv> do {\n  ASSERT (fb_graph G);\n  s \\<leftarrow> cycc_impl.tailrec_impl TYPE('a) G;\n  RETURN (break s)\n}\""], ["", "definition [DFS_code_unfold]: \"cyc_checker_rec_impl G \\<equiv> do {\n  ASSERT (fb_graph G);\n  s \\<leftarrow> cycc_impl.rec_impl TYPE('a) G;\n  RETURN (break s)\n}\""], ["", "definition [DFS_code_unfold]: \"cyc_checker_implT G \\<equiv> do {\n  ASSERT (graph G \\<and> finite (graph_defs.reachable G));\n  s \\<leftarrow> cycc_impl.tailrec_implT TYPE('a) G;\n  RETURN (break s)\n}\""], ["", "text \\<open>To show correctness of the implementation, we integrate the\n  locale of the simple implementation into our cyclicity checker's locale:\\<close>"], ["", "context cycc begin"], ["", "sublocale simple_impl G cycc_params cycc_params_impl cycc_erel"], ["proof (prove)\ngoal (1 subgoal):\n 1. simple_impl G cycc_params cycc_params_impl cycc_erel", "apply unfold_locales"], ["proof (prove)\ngoal (8 subgoals):\n 1. (simple_state.more_update, state.more_update)\n    \\<in> (cycc_erel \\<rightarrow> cycc_erel) \\<rightarrow>\n          cycc_rel \\<rightarrow> cycc_rel\n 2. on_init cycc_params_impl \\<le> \\<Down> cycc_erel (on_init cycc_params)\n 3. (is_break cycc_params_impl, is_break cycc_params)\n    \\<in> cycc_rel \\<rightarrow> bool_rel\n 4. \\<And>v0 s v0i si si' s'.\n       \\<lbrakk>gen_dfs.pre_new_root v0 s; (v0i, v0) \\<in> Id;\n        (si, s) \\<in> cycc_rel; (si', s') \\<in> cycc_rel;\n        nf_inres (gbs_new_root gbs v0 s) s'\\<rbrakk>\n       \\<Longrightarrow> on_new_root cycc_params_impl v0i si'\n                         \\<le> \\<Down> cycc_erel\n                                (on_new_root cycc_params v0 s')\n 5. \\<And>v s0 s vi si si' s'.\n       \\<lbrakk>gen_dfs.pre_finish v s0 s; (vi, v) \\<in> Id;\n        (si, s) \\<in> cycc_rel; (si', s') \\<in> cycc_rel;\n        nf_inres (gbs_finish gbs v s) s'\\<rbrakk>\n       \\<Longrightarrow> on_finish cycc_params_impl vi si'\n                         \\<le> \\<Down> cycc_erel\n                                (on_finish cycc_params v s')\n 6. \\<And>u v s0 s ui vi si si' s'.\n       \\<lbrakk>gen_dfs.pre_cross_edge u v s0 s; (ui, u) \\<in> Id;\n        (vi, v) \\<in> Id; (si, s) \\<in> cycc_rel; (si', s') \\<in> cycc_rel;\n        nf_inres (gbs_cross_edge gbs u v s) s'\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge cycc_params_impl ui vi si'\n                         \\<le> \\<Down> cycc_erel\n                                (on_cross_edge cycc_params u v s')\n 7. \\<And>u v s0 s ui vi si si' s'.\n       \\<lbrakk>gen_dfs.pre_back_edge u v s0 s; (ui, u) \\<in> Id;\n        (vi, v) \\<in> Id; (si, s) \\<in> cycc_rel; (si', s') \\<in> cycc_rel;\n        nf_inres (gbs_back_edge gbs u v s) s'\\<rbrakk>\n       \\<Longrightarrow> on_back_edge cycc_params_impl ui vi si'\n                         \\<le> \\<Down> cycc_erel\n                                (on_back_edge cycc_params u v s')\n 8. \\<And>u v s0 s ui vi si si' s'.\n       \\<lbrakk>gen_dfs.pre_discover u v s0 s; (ui, u) \\<in> Id;\n        (vi, v) \\<in> Id; (si, s) \\<in> cycc_rel; (si', s') \\<in> cycc_rel;\n        nf_inres (gbs_discover gbs u v s) s'\\<rbrakk>\n       \\<Longrightarrow> on_discover cycc_params_impl ui vi si'\n                         \\<le> \\<Down> cycc_erel\n                                (on_discover cycc_params u v s')", "apply (intro fun_relI, clarsimp simp: simple_state_rel_def, parametricity) []"], ["proof (prove)\ngoal (7 subgoals):\n 1. on_init cycc_params_impl \\<le> \\<Down> cycc_erel (on_init cycc_params)\n 2. (is_break cycc_params_impl, is_break cycc_params)\n    \\<in> cycc_rel \\<rightarrow> bool_rel\n 3. \\<And>v0 s v0i si si' s'.\n       \\<lbrakk>gen_dfs.pre_new_root v0 s; (v0i, v0) \\<in> Id;\n        (si, s) \\<in> cycc_rel; (si', s') \\<in> cycc_rel;\n        nf_inres (gbs_new_root gbs v0 s) s'\\<rbrakk>\n       \\<Longrightarrow> on_new_root cycc_params_impl v0i si'\n                         \\<le> \\<Down> cycc_erel\n                                (on_new_root cycc_params v0 s')\n 4. \\<And>v s0 s vi si si' s'.\n       \\<lbrakk>gen_dfs.pre_finish v s0 s; (vi, v) \\<in> Id;\n        (si, s) \\<in> cycc_rel; (si', s') \\<in> cycc_rel;\n        nf_inres (gbs_finish gbs v s) s'\\<rbrakk>\n       \\<Longrightarrow> on_finish cycc_params_impl vi si'\n                         \\<le> \\<Down> cycc_erel\n                                (on_finish cycc_params v s')\n 5. \\<And>u v s0 s ui vi si si' s'.\n       \\<lbrakk>gen_dfs.pre_cross_edge u v s0 s; (ui, u) \\<in> Id;\n        (vi, v) \\<in> Id; (si, s) \\<in> cycc_rel; (si', s') \\<in> cycc_rel;\n        nf_inres (gbs_cross_edge gbs u v s) s'\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge cycc_params_impl ui vi si'\n                         \\<le> \\<Down> cycc_erel\n                                (on_cross_edge cycc_params u v s')\n 6. \\<And>u v s0 s ui vi si si' s'.\n       \\<lbrakk>gen_dfs.pre_back_edge u v s0 s; (ui, u) \\<in> Id;\n        (vi, v) \\<in> Id; (si, s) \\<in> cycc_rel; (si', s') \\<in> cycc_rel;\n        nf_inres (gbs_back_edge gbs u v s) s'\\<rbrakk>\n       \\<Longrightarrow> on_back_edge cycc_params_impl ui vi si'\n                         \\<le> \\<Down> cycc_erel\n                                (on_back_edge cycc_params u v s')\n 7. \\<And>u v s0 s ui vi si si' s'.\n       \\<lbrakk>gen_dfs.pre_discover u v s0 s; (ui, u) \\<in> Id;\n        (vi, v) \\<in> Id; (si, s) \\<in> cycc_rel; (si', s') \\<in> cycc_rel;\n        nf_inres (gbs_discover gbs u v s) s'\\<rbrakk>\n       \\<Longrightarrow> on_discover cycc_params_impl ui vi si'\n                         \\<le> \\<Down> cycc_erel\n                                (on_discover cycc_params u v s')", "apply (auto simp: cycc_erel_def break_impl simple_state_rel_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>We get that our implementation refines the abstrct DFS algorithm.\\<close>"], ["", "lemmas impl_refine = simple_tailrec_refine simple_rec_refine simple_tailrecT_refine"], ["", "text \\<open>Unfortunately, the combination of locales and abbreviations gets to its \n    limits here, so we state the above lemma a bit more readable:\\<close>"], ["", "lemma \n    \"cycc_impl.tailrec_impl TYPE('more) G \\<le> \\<Down> cycc_rel it_dfs\"\n    \"cycc_impl.rec_impl TYPE('more) G \\<le> \\<Down> cycc_rel it_dfs\"\n    \"cycc_impl.tailrec_implT TYPE('more) G \\<le> \\<Down> cycc_rel it_dfsT\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tailrec_impl_defs.tailrec_impl G\n     (gen_param_dfs_defs.gds (pre_simple_impl.gbs G) cycc_params_impl\n       simple_state.more_update)\n    \\<le> \\<Down> cycc_rel it_dfs &&&\n    rec_impl_defs.rec_impl G\n     (gen_param_dfs_defs.gds (pre_simple_impl.gbs G) cycc_params_impl\n       simple_state.more_update)\n     cycc_impl.get_pending cycc_impl.get_stack cycc_impl.choose_pending\n    \\<le> \\<Down> cycc_rel it_dfs &&&\n    tailrec_impl_defs.tailrec_implT G\n     (gen_param_dfs_defs.gds (pre_simple_impl.gbs G) cycc_params_impl\n       simple_state.more_update)\n    \\<le> \\<Down> cycc_rel it_dfsT", "using impl_refine"], ["proof (prove)\nusing this:\n  tailrec_impl_defs.tailrec_impl G\n   (gen_param_dfs_defs.gds (pre_simple_impl.gbs G) cycc_params_impl\n     simple_state.more_update)\n  \\<le> \\<Down> cycc_rel it_dfs\n  rec_impl_defs.rec_impl G\n   (gen_param_dfs_defs.gds (pre_simple_impl.gbs G) cycc_params_impl\n     simple_state.more_update)\n   cycc_impl.get_pending cycc_impl.get_stack cycc_impl.choose_pending\n  \\<le> \\<Down> cycc_rel it_dfs\n  tailrec_impl_defs.tailrec_implT G\n   (gen_param_dfs_defs.gds (pre_simple_impl.gbs G) cycc_params_impl\n     simple_state.more_update)\n  \\<le> \\<Down> cycc_rel it_dfsT\n\ngoal (1 subgoal):\n 1. tailrec_impl_defs.tailrec_impl G\n     (gen_param_dfs_defs.gds (pre_simple_impl.gbs G) cycc_params_impl\n       simple_state.more_update)\n    \\<le> \\<Down> cycc_rel it_dfs &&&\n    rec_impl_defs.rec_impl G\n     (gen_param_dfs_defs.gds (pre_simple_impl.gbs G) cycc_params_impl\n       simple_state.more_update)\n     cycc_impl.get_pending cycc_impl.get_stack cycc_impl.choose_pending\n    \\<le> \\<Down> cycc_rel it_dfs &&&\n    tailrec_impl_defs.tailrec_implT G\n     (gen_param_dfs_defs.gds (pre_simple_impl.gbs G) cycc_params_impl\n       simple_state.more_update)\n    \\<le> \\<Down> cycc_rel it_dfsT", "."], ["", "end"], ["", "text \\<open>Finally, we get correctness of our cyclicity checker implementations\\<close>"], ["", "lemma cyc_checker_impl_refine: \"cyc_checker_impl G \\<le> \\<Down>Id (cyc_checker G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cyc_checker_impl G \\<le> \\<Down> bool_rel (cyc_checker G)", "unfolding cyc_checker_impl_def cyc_checker_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ASSERT (fb_graph G) \\<bind>\n    (\\<lambda>_.\n        tailrec_impl_defs.tailrec_impl G\n         (gen_param_dfs_defs.gds (pre_simple_impl.gbs G) cycc_params_impl\n           simple_state.more_update) \\<bind>\n        (\\<lambda>s. RETURN (cycc_state_impl.break s)))\n    \\<le> \\<Down> bool_rel\n           (ASSERT (fb_graph G) \\<bind>\n            (\\<lambda>_.\n                param_DFS_defs.it_dfs G cycc_params \\<bind>\n                (\\<lambda>s. RETURN (cycc_state.break s))))", "apply (refine_vcg cycc.impl_refine)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>fb_graph G; fb_graph G\\<rbrakk> \\<Longrightarrow> cycc G\n 2. \\<And>s sa.\n       \\<lbrakk>fb_graph G; fb_graph G; (s, sa) \\<in> cycc_rel\\<rbrakk>\n       \\<Longrightarrow> (cycc_state_impl.break s, cycc_state.break sa)\n                         \\<in> bool_rel", "apply (simp_all add: break_impl cyccI)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma cyc_checker_rec_impl_refine: \n  \"cyc_checker_rec_impl G \\<le> \\<Down>Id (cyc_checker G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cyc_checker_rec_impl G \\<le> \\<Down> bool_rel (cyc_checker G)", "unfolding cyc_checker_rec_impl_def cyc_checker_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ASSERT (fb_graph G) \\<bind>\n    (\\<lambda>_.\n        rec_impl_defs.rec_impl G\n         (gen_param_dfs_defs.gds (pre_simple_impl.gbs G) cycc_params_impl\n           simple_state.more_update)\n         cycc_impl.get_pending cycc_impl.get_stack\n         cycc_impl.choose_pending \\<bind>\n        (\\<lambda>s. RETURN (cycc_state_impl.break s)))\n    \\<le> \\<Down> bool_rel\n           (ASSERT (fb_graph G) \\<bind>\n            (\\<lambda>_.\n                param_DFS_defs.it_dfs G cycc_params \\<bind>\n                (\\<lambda>s. RETURN (cycc_state.break s))))", "apply (refine_vcg cycc.impl_refine)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>fb_graph G; fb_graph G\\<rbrakk> \\<Longrightarrow> cycc G\n 2. \\<And>s sa.\n       \\<lbrakk>fb_graph G; fb_graph G; (s, sa) \\<in> cycc_rel\\<rbrakk>\n       \\<Longrightarrow> (cycc_state_impl.break s, cycc_state.break sa)\n                         \\<in> bool_rel", "apply (simp_all add: break_impl cyccI)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma cyc_checker_implT_refine: \"cyc_checker_implT G \\<le> \\<Down>Id (cyc_checkerT G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cyc_checker_implT G \\<le> \\<Down> bool_rel (cyc_checkerT G)", "unfolding cyc_checker_implT_def cyc_checkerT_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ASSERT (graph G \\<and> finite ((g_E G)\\<^sup>* `` g_V0 G)) \\<bind>\n    (\\<lambda>_.\n        tailrec_impl_defs.tailrec_implT G\n         (gen_param_dfs_defs.gds (pre_simple_impl.gbs G) cycc_params_impl\n           simple_state.more_update) \\<bind>\n        (\\<lambda>s. RETURN (cycc_state_impl.break s)))\n    \\<le> \\<Down> bool_rel\n           (ASSERT\n             (graph G \\<and> finite ((g_E G)\\<^sup>* `` g_V0 G)) \\<bind>\n            (\\<lambda>_.\n                param_DFS_defs.it_dfsT G cycc_params \\<bind>\n                (\\<lambda>s. RETURN (cycc_state.break s))))", "apply (refine_vcg cycc.impl_refine)"], ["proof (prove)\ngoal (4 subgoals):\n 1. graph G \\<and> finite ((g_E G)\\<^sup>* `` g_V0 G) \\<Longrightarrow>\n    graph G\n 2. graph G \\<and> finite ((g_E G)\\<^sup>* `` g_V0 G) \\<Longrightarrow>\n    finite ((g_E G)\\<^sup>* `` g_V0 G)\n 3. \\<lbrakk>graph G \\<and> finite ((g_E G)\\<^sup>* `` g_V0 G);\n     graph G \\<and> finite ((g_E G)\\<^sup>* `` g_V0 G)\\<rbrakk>\n    \\<Longrightarrow> cycc G\n 4. \\<And>s sa.\n       \\<lbrakk>graph G \\<and> finite ((g_E G)\\<^sup>* `` g_V0 G);\n        graph G \\<and> finite ((g_E G)\\<^sup>* `` g_V0 G);\n        (s, sa) \\<in> cycc_rel\\<rbrakk>\n       \\<Longrightarrow> (cycc_state_impl.break s, cycc_state.break sa)\n                         \\<in> bool_rel", "apply (simp_all add: break_impl cyccI')"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \\<open>Synthesizing Executable Code\\<close>"], ["", "text \\<open>\n  Our algorithm's implementation is still abstract, as it uses abstract data \n  structures like sets and relations. In a last step, we use the Autoref tool\n  to derive an implementation with efficient data structures.\n\\<close>"], ["", "text \\<open>Again, we derive our state implementation from the template provided by \n  the framework. The break-flag is implemented by a Boolean flag. \n  Note that, in general, the user-defined state extensions may be data-refined\n  in this step.\\<close>"], ["", "record ('si,'nsi,'psi)cycc_state_impl' = \"('si,'nsi)simple_state_impl\" +\n  break_impl :: bool"], ["", "text \\<open>We define the refinement relation for the state extension\\<close>"], ["", "definition [to_relAPP]: \"cycc_state_erel erel \\<equiv> {\n  (\\<lparr>break_impl = bi, \\<dots> =  mi\\<rparr>,\\<lparr>break = b, \\<dots> = m\\<rparr>) | bi mi b m.\n    (bi,b)\\<in>bool_rel \\<and> (mi,m)\\<in>erel}\""], ["", "text \\<open>And register it with the Autoref tool:\\<close>"], ["", "consts \n  i_cycc_state_ext :: \"interface \\<Rightarrow> interface\""], ["", "lemmas [autoref_rel_intf] = REL_INTFI[of cycc_state_erel i_cycc_state_ext]"], ["", "text \\<open>We show that the record operations on our extended state are parametric,\n  and declare these facts to Autoref: \\<close>"], ["", "lemma [autoref_rules]:\n  fixes ns_rel vis_rel erel\n  defines \"R \\<equiv> \\<langle>ns_rel,vis_rel,\\<langle>erel\\<rangle>cycc_state_erel\\<rangle>ss_impl_rel\"\n  shows \n    \"(cycc_state_impl'_ext, cycc_state_impl_ext) \\<in> bool_rel \\<rightarrow> erel \\<rightarrow> \\<langle>erel\\<rangle>cycc_state_erel\"\n    \"(break_impl, cycc_state_impl.break) \\<in> R \\<rightarrow> bool_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (cycc_state_impl'_ext, cycc_state_impl_ext)\n    \\<in> bool_rel \\<rightarrow>\n          erel \\<rightarrow> \\<langle>erel\\<rangle>cycc_state_erel &&&\n    (break_impl, cycc_state_impl.break) \\<in> R \\<rightarrow> bool_rel", "unfolding cycc_state_erel_def ss_impl_rel_def R_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (cycc_state_impl'_ext, cycc_state_impl_ext)\n    \\<in> bool_rel \\<rightarrow>\n          erel \\<rightarrow>\n          {(\\<lparr>break_impl = bi, \\<dots> = mi\\<rparr>,\n            \\<lparr>cycc_state_impl.break = b, \\<dots> = m\\<rparr>) |\n           bi mi b m. (bi, b) \\<in> bool_rel \\<and> (mi, m) \\<in> erel} &&&\n    (break_impl, cycc_state_impl.break)\n    \\<in> {(\\<lparr>ss_stack_impl = si, ss_on_stack_impl = osi,\n               ss_visited_impl = visi, \\<dots> = mi\\<rparr>,\n            \\<lparr>ss_stack = s, on_stack = os, visited = vis,\n               \\<dots> = m\\<rparr>) |\n           si osi visi mi s os vis m.\n           (si, s) \\<in> ns_rel \\<and>\n           (osi, os) \\<in> vis_rel \\<and>\n           (visi, vis) \\<in> vis_rel \\<and>\n           (mi, m)\n           \\<in> {(\\<lparr>break_impl = bi, \\<dots> = mi\\<rparr>,\n                   \\<lparr>cycc_state_impl.break = b, \\<dots> = m\\<rparr>) |\n                  bi mi b m.\n                  (bi, b) \\<in> bool_rel \\<and>\n                  (mi, m) \\<in> erel}} \\<rightarrow>\n          bool_rel", "by auto"], ["", "text \\<open>Finally, we can synthesize an implementation for our cyclicity checker,\n  using the standard Autoref-approach:\\<close>"], ["", "schematic_goal cyc_checker_impl:\n  defines \"V \\<equiv> Id :: ('v \\<times> 'v::hashable) set\"\n  assumes [unfolded V_def,autoref_rules]:\n    \"(Gi, G) \\<in> \\<langle>Rm, V\\<rangle>g_impl_rel_ext\"\n  notes [unfolded V_def,autoref_tyrel] = \n    TYRELI[where R=\"\\<langle>V\\<rangle>dflt_ahs_rel\"]\n    TYRELI[where R=\"\\<langle>V \\<times>\\<^sub>r \\<langle>V\\<rangle>list_set_rel\\<rangle>ras_rel\"]\n  shows \"nres_of (?c::?'c dres) \\<le>\\<Down>?R (cyc_checker_impl G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nres_of ?c \\<le> \\<Down> ?R (cyc_checker_impl G)", "unfolding DFS_code_unfold"], ["proof (prove)\ngoal (1 subgoal):\n 1. nres_of ?c\n    \\<le> \\<Down> ?R\n           (ASSERT (fb_graph G) \\<bind>\n            (\\<lambda>_.\n                RETURN \\<lparr>cycc_state_impl.break = False\\<rparr> \\<bind>\n                (\\<lambda>e.\n                    RETURN\n                     \\<lparr>ss_stack = [], on_stack = {}, visited = {},\n                        \\<dots> = e\\<rparr>) \\<bind>\n                FOREACH\\<^sub>C\\<^bsup>\\<lambda>it s.\n    rwof\n     (RETURN \\<lparr>cycc_state_impl.break = False\\<rparr> \\<bind>\n      (\\<lambda>e.\n          RETURN\n           \\<lparr>ss_stack = [], on_stack = {}, visited = {},\n              \\<dots> = e\\<rparr>))\n     (gen_dfs_defs.gen_cond\n       (gen_param_dfs_defs.gds (pre_simple_impl.gbs G) cycc_params_impl\n         simple_state.more_update)\n       (g_V0 G))\n     (gen_dfs_defs.gen_step\n       (gen_param_dfs_defs.gds (pre_simple_impl.gbs G) cycc_params_impl\n         simple_state.more_update)\n       (g_V0 G))\n     s \\<and>\n    (\\<not> cycc_state_impl.break s \\<longrightarrow>\n     ss_stack s = []) \\<and>\n    g_V0 G - it \\<subseteq> {v. v \\<in> visited s}\\<^esup>\n                 (g_V0 G) (\\<lambda>x. \\<not> cycc_state_impl.break x)\n                 (\\<lambda>v0 s.\n                     let s0 = s\n                     in if v0 \\<in> visited s then RETURN s\n                        else ASSERT (v0 \\<notin> visited s) \\<bind>\n                             (\\<lambda>_.\n                                 let s = s\n \\<lparr>ss_stack := [(v0, g_E G `` {v0})]\\<rparr>;\n                                     s = s\\<lparr>on_stack := {v0}\\<rparr>\n                                 in Let (s\n   \\<lparr>visited := insert v0 (visited s)\\<rparr>)\n                                     RETURN) \\<bind>\n                             (\\<lambda>s.\n                                 RETURN (simple_state.more s) \\<bind>\n                                 (\\<lambda>e.\n                                     RETURN\n(s\\<lparr>simple_state.more := e\\<rparr>))) \\<bind>\n                             WHILE\\<^bsup>\\<lambda>s.\n       rwof\n        (RETURN \\<lparr>cycc_state_impl.break = False\\<rparr> \\<bind>\n         (\\<lambda>e.\n             RETURN\n              \\<lparr>ss_stack = [], on_stack = {}, visited = {},\n                 \\<dots> = e\\<rparr>))\n        (gen_dfs_defs.gen_cond\n          (gen_param_dfs_defs.gds (pre_simple_impl.gbs G) cycc_params_impl\n            simple_state.more_update)\n          (g_V0 G))\n        (gen_dfs_defs.gen_step\n          (gen_param_dfs_defs.gds (pre_simple_impl.gbs G) cycc_params_impl\n            simple_state.more_update)\n          (g_V0 G))\n        s \\<and>\n       insert v0 {v. v \\<in> visited s0}\n       \\<subseteq> {v. v \\<in> visited s}\\<^esup>\n                              (\\<lambda>s.\n                                  \\<not> cycc_state_impl.break s \\<and>\n                                  ss_stack s \\<noteq> [])\n                              (\\<lambda>s.\n                                  ASSERT (ss_stack s \\<noteq> []) \\<bind>\n                                  (\\<lambda>_.\nlet (u, Vs) = hd (ss_stack s)\nin if Vs = {} then RETURN (u, None, s)\n   else SPEC (\\<lambda>v. v \\<in> Vs) \\<bind>\n        (\\<lambda>v.\n            let Vs = Vs - {v};\n                s = s\\<lparr>ss_stack := (u, Vs) # tl (ss_stack s)\\<rparr>\n            in RETURN (u, Some v, s))) \\<bind>\n                                  (\\<lambda>(u, Vs, s).\ncase Vs of\nNone \\<Rightarrow>\n  ASSERT (ss_stack s \\<noteq> [] \\<and> u \\<in> on_stack s) \\<bind>\n  (\\<lambda>_.\n      let s = s\\<lparr>ss_stack := tl (ss_stack s)\\<rparr>\n      in Let (s\\<lparr>on_stack := on_stack s - {u}\\<rparr>) RETURN) \\<bind>\n  (\\<lambda>s.\n      RETURN (simple_state.more s) \\<bind>\n      (\\<lambda>e. RETURN (s\\<lparr>simple_state.more := e\\<rparr>)))\n| Some v \\<Rightarrow>\n    if v \\<in> visited s\n    then if v \\<in> visited s - on_stack s\n         then RETURN s \\<bind>\n              (\\<lambda>s.\n                  RETURN (simple_state.more s) \\<bind>\n                  (\\<lambda>e.\n                      RETURN (s\\<lparr>simple_state.more := e\\<rparr>)))\n         else RETURN s \\<bind>\n              (\\<lambda>s.\n                  RETURN\n                   \\<lparr>cycc_state_impl.break = True\\<rparr> \\<bind>\n                  (\\<lambda>e.\n                      RETURN (s\\<lparr>simple_state.more := e\\<rparr>)))\n    else ASSERT (v \\<notin> on_stack s \\<and> v \\<notin> visited s) \\<bind>\n         (\\<lambda>_.\n             let s = s\\<lparr>ss_stack :=\n                                (v, g_E G `` {v}) # ss_stack s\\<rparr>;\n                 s = s\\<lparr>on_stack := insert v (on_stack s)\\<rparr>\n             in Let (s\\<lparr>visited := insert v (visited s)\\<rparr>)\n                 RETURN) \\<bind>\n         (\\<lambda>s.\n             RETURN (simple_state.more s) \\<bind>\n             (\\<lambda>e.\n                 RETURN\n                  (s\\<lparr>simple_state.more := e\\<rparr>)))))) \\<bind>\n                (\\<lambda>s. RETURN (cycc_state_impl.break s))))", "using [[autoref_trace_failed_id, goals_limit=1]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. nres_of ?c\n    \\<le> \\<Down> ?R\n           (ASSERT (fb_graph G) \\<bind>\n            (\\<lambda>_.\n                RETURN \\<lparr>cycc_state_impl.break = False\\<rparr> \\<bind>\n                (\\<lambda>e.\n                    RETURN\n                     \\<lparr>ss_stack = [], on_stack = {}, visited = {},\n                        \\<dots> = e\\<rparr>) \\<bind>\n                FOREACH\\<^sub>C\\<^bsup>\\<lambda>it s.\n    rwof\n     (RETURN \\<lparr>cycc_state_impl.break = False\\<rparr> \\<bind>\n      (\\<lambda>e.\n          RETURN\n           \\<lparr>ss_stack = [], on_stack = {}, visited = {},\n              \\<dots> = e\\<rparr>))\n     (gen_dfs_defs.gen_cond\n       (gen_param_dfs_defs.gds (pre_simple_impl.gbs G) cycc_params_impl\n         simple_state.more_update)\n       (g_V0 G))\n     (gen_dfs_defs.gen_step\n       (gen_param_dfs_defs.gds (pre_simple_impl.gbs G) cycc_params_impl\n         simple_state.more_update)\n       (g_V0 G))\n     s \\<and>\n    (\\<not> cycc_state_impl.break s \\<longrightarrow>\n     ss_stack s = []) \\<and>\n    g_V0 G - it \\<subseteq> {v. v \\<in> visited s}\\<^esup>\n                 (g_V0 G) (\\<lambda>x. \\<not> cycc_state_impl.break x)\n                 (\\<lambda>v0 s.\n                     let s0 = s\n                     in if v0 \\<in> visited s then RETURN s\n                        else ASSERT (v0 \\<notin> visited s) \\<bind>\n                             (\\<lambda>_.\n                                 let s = s\n \\<lparr>ss_stack := [(v0, g_E G `` {v0})]\\<rparr>;\n                                     s = s\\<lparr>on_stack := {v0}\\<rparr>\n                                 in Let (s\n   \\<lparr>visited := insert v0 (visited s)\\<rparr>)\n                                     RETURN) \\<bind>\n                             (\\<lambda>s.\n                                 RETURN (simple_state.more s) \\<bind>\n                                 (\\<lambda>e.\n                                     RETURN\n(s\\<lparr>simple_state.more := e\\<rparr>))) \\<bind>\n                             WHILE\\<^bsup>\\<lambda>s.\n       rwof\n        (RETURN \\<lparr>cycc_state_impl.break = False\\<rparr> \\<bind>\n         (\\<lambda>e.\n             RETURN\n              \\<lparr>ss_stack = [], on_stack = {}, visited = {},\n                 \\<dots> = e\\<rparr>))\n        (gen_dfs_defs.gen_cond\n          (gen_param_dfs_defs.gds (pre_simple_impl.gbs G) cycc_params_impl\n            simple_state.more_update)\n          (g_V0 G))\n        (gen_dfs_defs.gen_step\n          (gen_param_dfs_defs.gds (pre_simple_impl.gbs G) cycc_params_impl\n            simple_state.more_update)\n          (g_V0 G))\n        s \\<and>\n       insert v0 {v. v \\<in> visited s0}\n       \\<subseteq> {v. v \\<in> visited s}\\<^esup>\n                              (\\<lambda>s.\n                                  \\<not> cycc_state_impl.break s \\<and>\n                                  ss_stack s \\<noteq> [])\n                              (\\<lambda>s.\n                                  ASSERT (ss_stack s \\<noteq> []) \\<bind>\n                                  (\\<lambda>_.\nlet (u, Vs) = hd (ss_stack s)\nin if Vs = {} then RETURN (u, None, s)\n   else SPEC (\\<lambda>v. v \\<in> Vs) \\<bind>\n        (\\<lambda>v.\n            let Vs = Vs - {v};\n                s = s\\<lparr>ss_stack := (u, Vs) # tl (ss_stack s)\\<rparr>\n            in RETURN (u, Some v, s))) \\<bind>\n                                  (\\<lambda>(u, Vs, s).\ncase Vs of\nNone \\<Rightarrow>\n  ASSERT (ss_stack s \\<noteq> [] \\<and> u \\<in> on_stack s) \\<bind>\n  (\\<lambda>_.\n      let s = s\\<lparr>ss_stack := tl (ss_stack s)\\<rparr>\n      in Let (s\\<lparr>on_stack := on_stack s - {u}\\<rparr>) RETURN) \\<bind>\n  (\\<lambda>s.\n      RETURN (simple_state.more s) \\<bind>\n      (\\<lambda>e. RETURN (s\\<lparr>simple_state.more := e\\<rparr>)))\n| Some v \\<Rightarrow>\n    if v \\<in> visited s\n    then if v \\<in> visited s - on_stack s\n         then RETURN s \\<bind>\n              (\\<lambda>s.\n                  RETURN (simple_state.more s) \\<bind>\n                  (\\<lambda>e.\n                      RETURN (s\\<lparr>simple_state.more := e\\<rparr>)))\n         else RETURN s \\<bind>\n              (\\<lambda>s.\n                  RETURN\n                   \\<lparr>cycc_state_impl.break = True\\<rparr> \\<bind>\n                  (\\<lambda>e.\n                      RETURN (s\\<lparr>simple_state.more := e\\<rparr>)))\n    else ASSERT (v \\<notin> on_stack s \\<and> v \\<notin> visited s) \\<bind>\n         (\\<lambda>_.\n             let s = s\\<lparr>ss_stack :=\n                                (v, g_E G `` {v}) # ss_stack s\\<rparr>;\n                 s = s\\<lparr>on_stack := insert v (on_stack s)\\<rparr>\n             in Let (s\\<lparr>visited := insert v (visited s)\\<rparr>)\n                 RETURN) \\<bind>\n         (\\<lambda>s.\n             RETURN (simple_state.more s) \\<bind>\n             (\\<lambda>e.\n                 RETURN\n                  (s\\<lparr>simple_state.more := e\\<rparr>)))))) \\<bind>\n                (\\<lambda>s. RETURN (cycc_state_impl.break s))))", "apply (autoref_monadic (trace))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "concrete_definition cyc_checker_code uses cyc_checker_impl"], ["", "export_code cyc_checker_code checking SML"], ["", "text \\<open>Combining the refinement steps yields a correctness \n  theorem for the cyclicity checker implementation:\\<close>"], ["", "theorem cyc_checker_code_correct:\n  assumes 1: \"fb_graph G\"\n  assumes 2: \"(Gi, G) \\<in> \\<langle>Rm, Id\\<rangle>g_impl_rel_ext\"\n  assumes 4: \"cyc_checker_code Gi = dRETURN x\"\n  shows \"x \\<longleftrightarrow> (\\<not>acyclic (g_E G \\<inter> ((g_E G)\\<^sup>* `` g_V0 G) \\<times> UNIV))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x =\n    (\\<not> acyclic\n             (g_E G \\<inter> (g_E G)\\<^sup>* `` g_V0 G \\<times> UNIV))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x =\n    (\\<not> acyclic\n             (g_E G \\<inter> (g_E G)\\<^sup>* `` g_V0 G \\<times> UNIV))", "note cyc_checker_code.refine[OF 2]"], ["proof (state)\nthis:\n  nres_of (cyc_checker_code Gi) \\<le> \\<Down> bool_rel (cyc_checker_impl G)\n\ngoal (1 subgoal):\n 1. x =\n    (\\<not> acyclic\n             (g_E G \\<inter> (g_E G)\\<^sup>* `` g_V0 G \\<times> UNIV))", "also"], ["proof (state)\nthis:\n  nres_of (cyc_checker_code Gi) \\<le> \\<Down> bool_rel (cyc_checker_impl G)\n\ngoal (1 subgoal):\n 1. x =\n    (\\<not> acyclic\n             (g_E G \\<inter> (g_E G)\\<^sup>* `` g_V0 G \\<times> UNIV))", "note cyc_checker_impl_refine"], ["proof (state)\nthis:\n  cyc_checker_impl ?G \\<le> \\<Down> bool_rel (cyc_checker ?G)\n\ngoal (1 subgoal):\n 1. x =\n    (\\<not> acyclic\n             (g_E G \\<inter> (g_E G)\\<^sup>* `` g_V0 G \\<times> UNIV))", "also"], ["proof (state)\nthis:\n  cyc_checker_impl ?G \\<le> \\<Down> bool_rel (cyc_checker ?G)\n\ngoal (1 subgoal):\n 1. x =\n    (\\<not> acyclic\n             (g_E G \\<inter> (g_E G)\\<^sup>* `` g_V0 G \\<times> UNIV))", "note cyc_checker_correct"], ["proof (state)\nthis:\n  cyc_checker ?G \\<le> cyc_checker_spec ?G\n\ngoal (1 subgoal):\n 1. x =\n    (\\<not> acyclic\n             (g_E G \\<inter> (g_E G)\\<^sup>* `` g_V0 G \\<times> UNIV))", "finally"], ["proof (chain)\npicking this:\n  nres_of (cyc_checker_code Gi) \\<le> cyc_checker_spec G", "show ?thesis"], ["proof (prove)\nusing this:\n  nres_of (cyc_checker_code Gi) \\<le> cyc_checker_spec G\n\ngoal (1 subgoal):\n 1. x =\n    (\\<not> acyclic\n             (g_E G \\<inter> (g_E G)\\<^sup>* `` g_V0 G \\<times> UNIV))", "using 1 4"], ["proof (prove)\nusing this:\n  nres_of (cyc_checker_code Gi) \\<le> cyc_checker_spec G\n  fb_graph G\n  cyc_checker_code Gi = dRETURN x\n\ngoal (1 subgoal):\n 1. x =\n    (\\<not> acyclic\n             (g_E G \\<inter> (g_E G)\\<^sup>* `` g_V0 G \\<times> UNIV))", "unfolding cyc_checker_spec_def"], ["proof (prove)\nusing this:\n  nres_of (cyc_checker_code Gi)\n  \\<le> ASSERT (fb_graph G) \\<bind>\n        (\\<lambda>_.\n            SPEC\n             (\\<lambda>r.\n                 r =\n                 (\\<not> acyclic\n                          (g_E G \\<inter>\n                           (g_E G)\\<^sup>* `` g_V0 G \\<times> UNIV))))\n  fb_graph G\n  cyc_checker_code Gi = dRETURN x\n\ngoal (1 subgoal):\n 1. x =\n    (\\<not> acyclic\n             (g_E G \\<inter> (g_E G)\\<^sup>* `` g_V0 G \\<times> UNIV))", "by auto"], ["proof (state)\nthis:\n  x =\n  (\\<not> acyclic (g_E G \\<inter> (g_E G)\\<^sup>* `` g_V0 G \\<times> UNIV))\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>We can repeat the same boilerplate for the recursive version of the algorithm:\\<close>"], ["", "schematic_goal cyc_checker_rec_impl:\n  defines \"V \\<equiv> Id :: ('v \\<times> 'v::hashable) set\"\n  assumes [unfolded V_def,autoref_rules]:\n    \"(Gi, G) \\<in> \\<langle>Rm, V\\<rangle>g_impl_rel_ext\"\n  notes [unfolded V_def,autoref_tyrel] = \n    TYRELI[where R=\"\\<langle>V\\<rangle>dflt_ahs_rel\"]\n    TYRELI[where R=\"\\<langle>V \\<times>\\<^sub>r \\<langle>V\\<rangle>list_set_rel\\<rangle>ras_rel\"]\n  shows \"nres_of (?c::?'c dres) \\<le>\\<Down>?R (cyc_checker_rec_impl G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nres_of ?c \\<le> \\<Down> ?R (cyc_checker_rec_impl G)", "unfolding DFS_code_unfold"], ["proof (prove)\ngoal (1 subgoal):\n 1. nres_of ?c\n    \\<le> \\<Down> ?R\n           (ASSERT (fb_graph G) \\<bind>\n            (\\<lambda>_.\n                RETURN \\<lparr>cycc_state_impl.break = False\\<rparr> \\<bind>\n                (\\<lambda>e.\n                    RETURN\n                     \\<lparr>ss_stack = [], on_stack = {}, visited = {},\n                        \\<dots> = e\\<rparr>) \\<bind>\n                FOREACH\\<^sub>C\\<^bsup>\\<lambda>it s.\n    rwof\n     (RETURN \\<lparr>cycc_state_impl.break = False\\<rparr> \\<bind>\n      (\\<lambda>e.\n          RETURN\n           \\<lparr>ss_stack = [], on_stack = {}, visited = {},\n              \\<dots> = e\\<rparr>))\n     (gen_dfs_defs.gen_cond\n       (gen_param_dfs_defs.gds (pre_simple_impl.gbs G) cycc_params_impl\n         simple_state.more_update)\n       (g_V0 G))\n     (rec_impl_defs.gen_step' G\n       (gen_param_dfs_defs.gds (pre_simple_impl.gbs G) cycc_params_impl\n         simple_state.more_update)\n       cycc_impl.get_pending cycc_impl.get_stack\n       (\\<lambda>u vo s.\n           case vo of None \\<Rightarrow> RETURN s\n           | Some v \\<Rightarrow>\n               ASSERT (ss_stack s \\<noteq> []) \\<bind>\n               (\\<lambda>_.\n                   let (u, Vs) = hd (ss_stack s)\n                   in RETURN\n                       (s\\<lparr>ss_stack :=\n                                   (u, Vs - {v}) #\n                                   tl (ss_stack s)\\<rparr>))))\n     s \\<and>\n    (\\<not> cycc_state_impl.break s \\<longrightarrow>\n     ss_stack s = [] \\<and>\n     g_V0 G - it \\<subseteq> {v. v \\<in> visited s})\\<^esup>\n                 (g_V0 G) (\\<lambda>x. \\<not> cycc_state_impl.break x)\n                 (\\<lambda>v0 s.\n                     if v0 \\<in> visited s then RETURN s\n                     else ASSERT (v0 \\<notin> visited s) \\<bind>\n                          (\\<lambda>_.\n                              let s = s\\<lparr>ss_stack :=\n           [(v0, g_E G `` {v0})]\\<rparr>;\n                                  s = s\\<lparr>on_stack := {v0}\\<rparr>\n                              in Let (s\n\\<lparr>visited := insert v0 (visited s)\\<rparr>)\n                                  RETURN) \\<bind>\n                          (\\<lambda>s.\n                              RETURN (simple_state.more s) \\<bind>\n                              (\\<lambda>e.\n                                  RETURN\n                                   (s\\<lparr>simple_state.more :=\n         e\\<rparr>))) \\<bind>\n                          (\\<lambda>s.\n                              if cycc_state_impl.break s then RETURN s\n                              else REC (\\<lambda>D x.\n     ASSERT\n      (case x of\n       (u, s) \\<Rightarrow>\n         rwof\n          (RETURN \\<lparr>cycc_state_impl.break = False\\<rparr> \\<bind>\n           (\\<lambda>e.\n               RETURN\n                \\<lparr>ss_stack = [], on_stack = {}, visited = {},\n                   \\<dots> = e\\<rparr>))\n          (gen_dfs_defs.gen_cond\n            (gen_param_dfs_defs.gds (pre_simple_impl.gbs G) cycc_params_impl\n              simple_state.more_update)\n            (g_V0 G))\n          (rec_impl_defs.gen_step' G\n            (gen_param_dfs_defs.gds (pre_simple_impl.gbs G) cycc_params_impl\n              simple_state.more_update)\n            cycc_impl.get_pending cycc_impl.get_stack\n            (\\<lambda>u vo s.\n                case vo of None \\<Rightarrow> RETURN s\n                | Some v \\<Rightarrow>\n                    ASSERT (ss_stack s \\<noteq> []) \\<bind>\n                    (\\<lambda>_.\n                        let (u, Vs) = hd (ss_stack s)\n                        in RETURN\n                            (s\\<lparr>ss_stack :=\n  (u, Vs - {v}) # tl (ss_stack s)\\<rparr>))))\n          s \\<and>\n         \\<not> cycc_state_impl.break s \\<and>\n         (\\<exists>stk. cycc_impl.get_stack s = u # stk) \\<and>\n         g_E G \\<inter> {u} \\<times> UNIV\n         \\<subseteq> cycc_impl.get_pending s) \\<bind>\n     (\\<lambda>_.\n         (case x of\n          (u, s) \\<Rightarrow>\n            FOREACH\\<^sub>C\\<^bsup>\\<lambda>it s'.\nrwof\n (RETURN \\<lparr>cycc_state_impl.break = False\\<rparr> \\<bind>\n  (\\<lambda>e.\n      RETURN\n       \\<lparr>ss_stack = [], on_stack = {}, visited = {},\n          \\<dots> = e\\<rparr>))\n (gen_dfs_defs.gen_cond\n   (gen_param_dfs_defs.gds (pre_simple_impl.gbs G) cycc_params_impl\n     simple_state.more_update)\n   (g_V0 G))\n (rec_impl_defs.gen_step' G\n   (gen_param_dfs_defs.gds (pre_simple_impl.gbs G) cycc_params_impl\n     simple_state.more_update)\n   cycc_impl.get_pending cycc_impl.get_stack\n   (\\<lambda>u vo s.\n       case vo of None \\<Rightarrow> RETURN s\n       | Some v \\<Rightarrow>\n           ASSERT (ss_stack s \\<noteq> []) \\<bind>\n           (\\<lambda>_.\n               let (u, Vs) = hd (ss_stack s)\n               in RETURN\n                   (s\\<lparr>ss_stack :=\n                               (u, Vs - {v}) # tl (ss_stack s)\\<rparr>))))\n s' \\<and>\n(\\<not> cycc_state_impl.break s' \\<longrightarrow>\n cycc_impl.get_stack s' = cycc_impl.get_stack s \\<and>\n cycc_impl.get_pending s' =\n cycc_impl.get_pending s - {u} \\<times> (g_E G `` {u} - it) \\<and>\n {v. v \\<in> visited s} \\<union> (g_E G `` {u} - it)\n \\<subseteq> {v. v \\<in> visited s'})\\<^esup>\n             (g_E G `` {u}) (\\<lambda>s. \\<not> cycc_state_impl.break s)\n             (\\<lambda>v s.\n                 (case Some v of None \\<Rightarrow> RETURN s\n                  | Some v \\<Rightarrow>\n                      ASSERT (ss_stack s \\<noteq> []) \\<bind>\n                      (\\<lambda>_.\n                          let (u, Vs) = hd (ss_stack s)\n                          in RETURN\n                              (s\\<lparr>ss_stack :=\n    (u, Vs - {v}) # tl (ss_stack s)\\<rparr>))) \\<bind>\n                 (\\<lambda>s.\n                     if v \\<in> visited s\n                     then if v \\<in> visited s - on_stack s\n                          then RETURN s \\<bind>\n                               (\\<lambda>s.\n                                   RETURN (simple_state.more s) \\<bind>\n                                   (\\<lambda>e.\n RETURN (s\\<lparr>simple_state.more := e\\<rparr>)))\n                          else RETURN s \\<bind>\n                               (\\<lambda>s.\n                                   RETURN\n                                    \\<lparr>cycc_state_impl.break =\n        True\\<rparr> \\<bind>\n                                   (\\<lambda>e.\n RETURN (s\\<lparr>simple_state.more := e\\<rparr>)))\n                     else ASSERT\n                           (v \\<notin> on_stack s \\<and>\n                            v \\<notin> visited s) \\<bind>\n                          (\\<lambda>_.\n                              let s = s\\<lparr>ss_stack :=\n           (v, g_E G `` {v}) # ss_stack s\\<rparr>;\n                                  s = s\\<lparr>on_stack :=\n           insert v (on_stack s)\\<rparr>\n                              in Let (s\n\\<lparr>visited := insert v (visited s)\\<rparr>)\n                                  RETURN) \\<bind>\n                          (\\<lambda>s.\n                              RETURN (simple_state.more s) \\<bind>\n                              (\\<lambda>e.\n                                  RETURN\n                                   (s\\<lparr>simple_state.more :=\n         e\\<rparr>))) \\<bind>\n                          (\\<lambda>s.\n                              if cycc_state_impl.break s then RETURN s\n                              else D (v, s))))\n             s \\<bind>\n            (\\<lambda>s.\n                if cycc_state_impl.break s then RETURN s\n                else (case None of None \\<Rightarrow> RETURN s\n                      | Some v \\<Rightarrow>\n                          ASSERT (ss_stack s \\<noteq> []) \\<bind>\n                          (\\<lambda>_.\n                              let (u, Vs) = hd (ss_stack s)\n                              in RETURN\n                                  (s\\<lparr>ss_stack :=\n        (u, Vs - {v}) # tl (ss_stack s)\\<rparr>))) \\<bind>\n                     (\\<lambda>s.\n                         ASSERT\n                          (ss_stack s \\<noteq> [] \\<and>\n                           u \\<in> on_stack s) \\<bind>\n                         (\\<lambda>_.\n                             let s = s\\<lparr>ss_stack :=\n          tl (ss_stack s)\\<rparr>\n                             in Let (s\\<lparr>on_stack :=\n          on_stack s - {u}\\<rparr>)\n                                 RETURN) \\<bind>\n                         (\\<lambda>s.\n                             RETURN (simple_state.more s) \\<bind>\n                             (\\<lambda>e.\n                                 RETURN\n                                  (s\\<lparr>simple_state.more :=\n        e\\<rparr>))) \\<bind>\n                         RETURN))) \\<bind>\n         (\\<lambda>r.\n             ASSERT\n              ((case x of\n                (u, s) \\<Rightarrow>\n                  \\<lambda>s'.\n                     rwof\n                      (RETURN\n                        \\<lparr>cycc_state_impl.break =\n                                  False\\<rparr> \\<bind>\n                       (\\<lambda>e.\n                           RETURN\n                            \\<lparr>ss_stack = [], on_stack = {},\n                               visited = {}, \\<dots> = e\\<rparr>))\n                      (gen_dfs_defs.gen_cond\n                        (gen_param_dfs_defs.gds (pre_simple_impl.gbs G)\n                          cycc_params_impl simple_state.more_update)\n                        (g_V0 G))\n                      (rec_impl_defs.gen_step' G\n                        (gen_param_dfs_defs.gds (pre_simple_impl.gbs G)\n                          cycc_params_impl simple_state.more_update)\n                        cycc_impl.get_pending cycc_impl.get_stack\n                        (\\<lambda>u vo s.\n                            case vo of None \\<Rightarrow> RETURN s\n                            | Some v \\<Rightarrow>\n                                ASSERT (ss_stack s \\<noteq> []) \\<bind>\n                                (\\<lambda>_.\n                                    let (u, Vs) = hd (ss_stack s)\n                                    in RETURN\n  (s\\<lparr>ss_stack := (u, Vs - {v}) # tl (ss_stack s)\\<rparr>))))\n                      s' \\<and>\n                     (\\<not> cycc_state_impl.break s' \\<longrightarrow>\n                      cycc_impl.get_stack s' =\n                      tl (cycc_impl.get_stack s) \\<and>\n                      cycc_impl.get_pending s' =\n                      cycc_impl.get_pending s - {u} \\<times> UNIV \\<and>\n                      {v. v \\<in> visited s}\n                      \\<subseteq> {v. v \\<in> visited s'}))\n                r) \\<bind>\n             (\\<lambda>_. RETURN r))))\n                                    (v0, s))) \\<bind>\n                (\\<lambda>s. RETURN (cycc_state_impl.break s))))", "using [[autoref_trace_failed_id, goals_limit=1]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. nres_of ?c\n    \\<le> \\<Down> ?R\n           (ASSERT (fb_graph G) \\<bind>\n            (\\<lambda>_.\n                RETURN \\<lparr>cycc_state_impl.break = False\\<rparr> \\<bind>\n                (\\<lambda>e.\n                    RETURN\n                     \\<lparr>ss_stack = [], on_stack = {}, visited = {},\n                        \\<dots> = e\\<rparr>) \\<bind>\n                FOREACH\\<^sub>C\\<^bsup>\\<lambda>it s.\n    rwof\n     (RETURN \\<lparr>cycc_state_impl.break = False\\<rparr> \\<bind>\n      (\\<lambda>e.\n          RETURN\n           \\<lparr>ss_stack = [], on_stack = {}, visited = {},\n              \\<dots> = e\\<rparr>))\n     (gen_dfs_defs.gen_cond\n       (gen_param_dfs_defs.gds (pre_simple_impl.gbs G) cycc_params_impl\n         simple_state.more_update)\n       (g_V0 G))\n     (rec_impl_defs.gen_step' G\n       (gen_param_dfs_defs.gds (pre_simple_impl.gbs G) cycc_params_impl\n         simple_state.more_update)\n       cycc_impl.get_pending cycc_impl.get_stack\n       (\\<lambda>u vo s.\n           case vo of None \\<Rightarrow> RETURN s\n           | Some v \\<Rightarrow>\n               ASSERT (ss_stack s \\<noteq> []) \\<bind>\n               (\\<lambda>_.\n                   let (u, Vs) = hd (ss_stack s)\n                   in RETURN\n                       (s\\<lparr>ss_stack :=\n                                   (u, Vs - {v}) #\n                                   tl (ss_stack s)\\<rparr>))))\n     s \\<and>\n    (\\<not> cycc_state_impl.break s \\<longrightarrow>\n     ss_stack s = [] \\<and>\n     g_V0 G - it \\<subseteq> {v. v \\<in> visited s})\\<^esup>\n                 (g_V0 G) (\\<lambda>x. \\<not> cycc_state_impl.break x)\n                 (\\<lambda>v0 s.\n                     if v0 \\<in> visited s then RETURN s\n                     else ASSERT (v0 \\<notin> visited s) \\<bind>\n                          (\\<lambda>_.\n                              let s = s\\<lparr>ss_stack :=\n           [(v0, g_E G `` {v0})]\\<rparr>;\n                                  s = s\\<lparr>on_stack := {v0}\\<rparr>\n                              in Let (s\n\\<lparr>visited := insert v0 (visited s)\\<rparr>)\n                                  RETURN) \\<bind>\n                          (\\<lambda>s.\n                              RETURN (simple_state.more s) \\<bind>\n                              (\\<lambda>e.\n                                  RETURN\n                                   (s\\<lparr>simple_state.more :=\n         e\\<rparr>))) \\<bind>\n                          (\\<lambda>s.\n                              if cycc_state_impl.break s then RETURN s\n                              else REC (\\<lambda>D x.\n     ASSERT\n      (case x of\n       (u, s) \\<Rightarrow>\n         rwof\n          (RETURN \\<lparr>cycc_state_impl.break = False\\<rparr> \\<bind>\n           (\\<lambda>e.\n               RETURN\n                \\<lparr>ss_stack = [], on_stack = {}, visited = {},\n                   \\<dots> = e\\<rparr>))\n          (gen_dfs_defs.gen_cond\n            (gen_param_dfs_defs.gds (pre_simple_impl.gbs G) cycc_params_impl\n              simple_state.more_update)\n            (g_V0 G))\n          (rec_impl_defs.gen_step' G\n            (gen_param_dfs_defs.gds (pre_simple_impl.gbs G) cycc_params_impl\n              simple_state.more_update)\n            cycc_impl.get_pending cycc_impl.get_stack\n            (\\<lambda>u vo s.\n                case vo of None \\<Rightarrow> RETURN s\n                | Some v \\<Rightarrow>\n                    ASSERT (ss_stack s \\<noteq> []) \\<bind>\n                    (\\<lambda>_.\n                        let (u, Vs) = hd (ss_stack s)\n                        in RETURN\n                            (s\\<lparr>ss_stack :=\n  (u, Vs - {v}) # tl (ss_stack s)\\<rparr>))))\n          s \\<and>\n         \\<not> cycc_state_impl.break s \\<and>\n         (\\<exists>stk. cycc_impl.get_stack s = u # stk) \\<and>\n         g_E G \\<inter> {u} \\<times> UNIV\n         \\<subseteq> cycc_impl.get_pending s) \\<bind>\n     (\\<lambda>_.\n         (case x of\n          (u, s) \\<Rightarrow>\n            FOREACH\\<^sub>C\\<^bsup>\\<lambda>it s'.\nrwof\n (RETURN \\<lparr>cycc_state_impl.break = False\\<rparr> \\<bind>\n  (\\<lambda>e.\n      RETURN\n       \\<lparr>ss_stack = [], on_stack = {}, visited = {},\n          \\<dots> = e\\<rparr>))\n (gen_dfs_defs.gen_cond\n   (gen_param_dfs_defs.gds (pre_simple_impl.gbs G) cycc_params_impl\n     simple_state.more_update)\n   (g_V0 G))\n (rec_impl_defs.gen_step' G\n   (gen_param_dfs_defs.gds (pre_simple_impl.gbs G) cycc_params_impl\n     simple_state.more_update)\n   cycc_impl.get_pending cycc_impl.get_stack\n   (\\<lambda>u vo s.\n       case vo of None \\<Rightarrow> RETURN s\n       | Some v \\<Rightarrow>\n           ASSERT (ss_stack s \\<noteq> []) \\<bind>\n           (\\<lambda>_.\n               let (u, Vs) = hd (ss_stack s)\n               in RETURN\n                   (s\\<lparr>ss_stack :=\n                               (u, Vs - {v}) # tl (ss_stack s)\\<rparr>))))\n s' \\<and>\n(\\<not> cycc_state_impl.break s' \\<longrightarrow>\n cycc_impl.get_stack s' = cycc_impl.get_stack s \\<and>\n cycc_impl.get_pending s' =\n cycc_impl.get_pending s - {u} \\<times> (g_E G `` {u} - it) \\<and>\n {v. v \\<in> visited s} \\<union> (g_E G `` {u} - it)\n \\<subseteq> {v. v \\<in> visited s'})\\<^esup>\n             (g_E G `` {u}) (\\<lambda>s. \\<not> cycc_state_impl.break s)\n             (\\<lambda>v s.\n                 (case Some v of None \\<Rightarrow> RETURN s\n                  | Some v \\<Rightarrow>\n                      ASSERT (ss_stack s \\<noteq> []) \\<bind>\n                      (\\<lambda>_.\n                          let (u, Vs) = hd (ss_stack s)\n                          in RETURN\n                              (s\\<lparr>ss_stack :=\n    (u, Vs - {v}) # tl (ss_stack s)\\<rparr>))) \\<bind>\n                 (\\<lambda>s.\n                     if v \\<in> visited s\n                     then if v \\<in> visited s - on_stack s\n                          then RETURN s \\<bind>\n                               (\\<lambda>s.\n                                   RETURN (simple_state.more s) \\<bind>\n                                   (\\<lambda>e.\n RETURN (s\\<lparr>simple_state.more := e\\<rparr>)))\n                          else RETURN s \\<bind>\n                               (\\<lambda>s.\n                                   RETURN\n                                    \\<lparr>cycc_state_impl.break =\n        True\\<rparr> \\<bind>\n                                   (\\<lambda>e.\n RETURN (s\\<lparr>simple_state.more := e\\<rparr>)))\n                     else ASSERT\n                           (v \\<notin> on_stack s \\<and>\n                            v \\<notin> visited s) \\<bind>\n                          (\\<lambda>_.\n                              let s = s\\<lparr>ss_stack :=\n           (v, g_E G `` {v}) # ss_stack s\\<rparr>;\n                                  s = s\\<lparr>on_stack :=\n           insert v (on_stack s)\\<rparr>\n                              in Let (s\n\\<lparr>visited := insert v (visited s)\\<rparr>)\n                                  RETURN) \\<bind>\n                          (\\<lambda>s.\n                              RETURN (simple_state.more s) \\<bind>\n                              (\\<lambda>e.\n                                  RETURN\n                                   (s\\<lparr>simple_state.more :=\n         e\\<rparr>))) \\<bind>\n                          (\\<lambda>s.\n                              if cycc_state_impl.break s then RETURN s\n                              else D (v, s))))\n             s \\<bind>\n            (\\<lambda>s.\n                if cycc_state_impl.break s then RETURN s\n                else (case None of None \\<Rightarrow> RETURN s\n                      | Some v \\<Rightarrow>\n                          ASSERT (ss_stack s \\<noteq> []) \\<bind>\n                          (\\<lambda>_.\n                              let (u, Vs) = hd (ss_stack s)\n                              in RETURN\n                                  (s\\<lparr>ss_stack :=\n        (u, Vs - {v}) # tl (ss_stack s)\\<rparr>))) \\<bind>\n                     (\\<lambda>s.\n                         ASSERT\n                          (ss_stack s \\<noteq> [] \\<and>\n                           u \\<in> on_stack s) \\<bind>\n                         (\\<lambda>_.\n                             let s = s\\<lparr>ss_stack :=\n          tl (ss_stack s)\\<rparr>\n                             in Let (s\\<lparr>on_stack :=\n          on_stack s - {u}\\<rparr>)\n                                 RETURN) \\<bind>\n                         (\\<lambda>s.\n                             RETURN (simple_state.more s) \\<bind>\n                             (\\<lambda>e.\n                                 RETURN\n                                  (s\\<lparr>simple_state.more :=\n        e\\<rparr>))) \\<bind>\n                         RETURN))) \\<bind>\n         (\\<lambda>r.\n             ASSERT\n              ((case x of\n                (u, s) \\<Rightarrow>\n                  \\<lambda>s'.\n                     rwof\n                      (RETURN\n                        \\<lparr>cycc_state_impl.break =\n                                  False\\<rparr> \\<bind>\n                       (\\<lambda>e.\n                           RETURN\n                            \\<lparr>ss_stack = [], on_stack = {},\n                               visited = {}, \\<dots> = e\\<rparr>))\n                      (gen_dfs_defs.gen_cond\n                        (gen_param_dfs_defs.gds (pre_simple_impl.gbs G)\n                          cycc_params_impl simple_state.more_update)\n                        (g_V0 G))\n                      (rec_impl_defs.gen_step' G\n                        (gen_param_dfs_defs.gds (pre_simple_impl.gbs G)\n                          cycc_params_impl simple_state.more_update)\n                        cycc_impl.get_pending cycc_impl.get_stack\n                        (\\<lambda>u vo s.\n                            case vo of None \\<Rightarrow> RETURN s\n                            | Some v \\<Rightarrow>\n                                ASSERT (ss_stack s \\<noteq> []) \\<bind>\n                                (\\<lambda>_.\n                                    let (u, Vs) = hd (ss_stack s)\n                                    in RETURN\n  (s\\<lparr>ss_stack := (u, Vs - {v}) # tl (ss_stack s)\\<rparr>))))\n                      s' \\<and>\n                     (\\<not> cycc_state_impl.break s' \\<longrightarrow>\n                      cycc_impl.get_stack s' =\n                      tl (cycc_impl.get_stack s) \\<and>\n                      cycc_impl.get_pending s' =\n                      cycc_impl.get_pending s - {u} \\<times> UNIV \\<and>\n                      {v. v \\<in> visited s}\n                      \\<subseteq> {v. v \\<in> visited s'}))\n                r) \\<bind>\n             (\\<lambda>_. RETURN r))))\n                                    (v0, s))) \\<bind>\n                (\\<lambda>s. RETURN (cycc_state_impl.break s))))", "apply (autoref_monadic (trace))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "concrete_definition cyc_checker_rec_code uses cyc_checker_rec_impl"], ["", "prepare_code_thms cyc_checker_rec_code_def"], ["", "export_code cyc_checker_rec_code checking SML"], ["", "lemma cyc_checker_rec_code_correct:\n  assumes 1: \"fb_graph G\"\n  assumes 2: \"(Gi, G) \\<in> \\<langle>Rm, Id\\<rangle>g_impl_rel_ext\"\n  assumes 4: \"cyc_checker_rec_code Gi = dRETURN x\"\n  shows \"x \\<longleftrightarrow> (\\<not>acyclic (g_E G \\<inter> ((g_E G)\\<^sup>* `` g_V0 G) \\<times> UNIV))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x =\n    (\\<not> acyclic\n             (g_E G \\<inter> (g_E G)\\<^sup>* `` g_V0 G \\<times> UNIV))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x =\n    (\\<not> acyclic\n             (g_E G \\<inter> (g_E G)\\<^sup>* `` g_V0 G \\<times> UNIV))", "note cyc_checker_rec_code.refine[OF 2]"], ["proof (state)\nthis:\n  nres_of (cyc_checker_rec_code Gi)\n  \\<le> \\<Down> bool_rel (cyc_checker_rec_impl G)\n\ngoal (1 subgoal):\n 1. x =\n    (\\<not> acyclic\n             (g_E G \\<inter> (g_E G)\\<^sup>* `` g_V0 G \\<times> UNIV))", "also"], ["proof (state)\nthis:\n  nres_of (cyc_checker_rec_code Gi)\n  \\<le> \\<Down> bool_rel (cyc_checker_rec_impl G)\n\ngoal (1 subgoal):\n 1. x =\n    (\\<not> acyclic\n             (g_E G \\<inter> (g_E G)\\<^sup>* `` g_V0 G \\<times> UNIV))", "note cyc_checker_rec_impl_refine"], ["proof (state)\nthis:\n  cyc_checker_rec_impl ?G \\<le> \\<Down> bool_rel (cyc_checker ?G)\n\ngoal (1 subgoal):\n 1. x =\n    (\\<not> acyclic\n             (g_E G \\<inter> (g_E G)\\<^sup>* `` g_V0 G \\<times> UNIV))", "also"], ["proof (state)\nthis:\n  cyc_checker_rec_impl ?G \\<le> \\<Down> bool_rel (cyc_checker ?G)\n\ngoal (1 subgoal):\n 1. x =\n    (\\<not> acyclic\n             (g_E G \\<inter> (g_E G)\\<^sup>* `` g_V0 G \\<times> UNIV))", "note cyc_checker_correct"], ["proof (state)\nthis:\n  cyc_checker ?G \\<le> cyc_checker_spec ?G\n\ngoal (1 subgoal):\n 1. x =\n    (\\<not> acyclic\n             (g_E G \\<inter> (g_E G)\\<^sup>* `` g_V0 G \\<times> UNIV))", "finally"], ["proof (chain)\npicking this:\n  nres_of (cyc_checker_rec_code Gi) \\<le> cyc_checker_spec G", "show ?thesis"], ["proof (prove)\nusing this:\n  nres_of (cyc_checker_rec_code Gi) \\<le> cyc_checker_spec G\n\ngoal (1 subgoal):\n 1. x =\n    (\\<not> acyclic\n             (g_E G \\<inter> (g_E G)\\<^sup>* `` g_V0 G \\<times> UNIV))", "using 1 4"], ["proof (prove)\nusing this:\n  nres_of (cyc_checker_rec_code Gi) \\<le> cyc_checker_spec G\n  fb_graph G\n  cyc_checker_rec_code Gi = dRETURN x\n\ngoal (1 subgoal):\n 1. x =\n    (\\<not> acyclic\n             (g_E G \\<inter> (g_E G)\\<^sup>* `` g_V0 G \\<times> UNIV))", "unfolding cyc_checker_spec_def"], ["proof (prove)\nusing this:\n  nres_of (cyc_checker_rec_code Gi)\n  \\<le> ASSERT (fb_graph G) \\<bind>\n        (\\<lambda>_.\n            SPEC\n             (\\<lambda>r.\n                 r =\n                 (\\<not> acyclic\n                          (g_E G \\<inter>\n                           (g_E G)\\<^sup>* `` g_V0 G \\<times> UNIV))))\n  fb_graph G\n  cyc_checker_rec_code Gi = dRETURN x\n\ngoal (1 subgoal):\n 1. x =\n    (\\<not> acyclic\n             (g_E G \\<inter> (g_E G)\\<^sup>* `` g_V0 G \\<times> UNIV))", "by auto"], ["proof (state)\nthis:\n  x =\n  (\\<not> acyclic (g_E G \\<inter> (g_E G)\\<^sup>* `` g_V0 G \\<times> UNIV))\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>And, again, for the total correct version. \n  Note that we generate a plain implementation, not inside a monad:\\<close>"], ["", "schematic_goal cyc_checker_implT:\n  defines \"V \\<equiv> Id :: ('v \\<times> 'v::hashable) set\"\n  assumes [unfolded V_def,autoref_rules]:\n    \"(Gi, G) \\<in> \\<langle>Rm, V\\<rangle>g_impl_rel_ext\"\n  notes [unfolded V_def,autoref_tyrel] = \n    TYRELI[where R=\"\\<langle>V\\<rangle>dflt_ahs_rel\"]\n    TYRELI[where R=\"\\<langle>V \\<times>\\<^sub>r \\<langle>V\\<rangle>list_set_rel\\<rangle>ras_rel\"]\n  shows \"RETURN (?c::?'c) \\<le>\\<Down>?R (cyc_checker_implT G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RETURN ?c \\<le> \\<Down> ?R (cyc_checker_implT G)", "unfolding DFS_code_unfold"], ["proof (prove)\ngoal (1 subgoal):\n 1. RETURN ?c\n    \\<le> \\<Down> ?R\n           (ASSERT\n             (graph G \\<and> finite ((g_E G)\\<^sup>* `` g_V0 G)) \\<bind>\n            (\\<lambda>_.\n                RETURN \\<lparr>cycc_state_impl.break = False\\<rparr> \\<bind>\n                (\\<lambda>e.\n                    RETURN\n                     \\<lparr>ss_stack = [], on_stack = {}, visited = {},\n                        \\<dots> = e\\<rparr>) \\<bind>\n                FOREACH\\<^sub>C\\<^bsup>\\<lambda>it s.\n    rwof\n     (RETURN \\<lparr>cycc_state_impl.break = False\\<rparr> \\<bind>\n      (\\<lambda>e.\n          RETURN\n           \\<lparr>ss_stack = [], on_stack = {}, visited = {},\n              \\<dots> = e\\<rparr>))\n     (gen_dfs_defs.gen_cond\n       (gen_param_dfs_defs.gds (pre_simple_impl.gbs G) cycc_params_impl\n         simple_state.more_update)\n       (g_V0 G))\n     (gen_dfs_defs.gen_step\n       (gen_param_dfs_defs.gds (pre_simple_impl.gbs G) cycc_params_impl\n         simple_state.more_update)\n       (g_V0 G))\n     s \\<and>\n    (\\<not> cycc_state_impl.break s \\<longrightarrow>\n     ss_stack s = []) \\<and>\n    g_V0 G - it \\<subseteq> {v. v \\<in> visited s}\\<^esup>\n                 (g_V0 G) (\\<lambda>x. \\<not> cycc_state_impl.break x)\n                 (\\<lambda>v0 s.\n                     let s0 = s\n                     in if v0 \\<in> visited s then RETURN s\n                        else ASSERT (v0 \\<notin> visited s) \\<bind>\n                             (\\<lambda>_.\n                                 let s = s\n \\<lparr>ss_stack := [(v0, g_E G `` {v0})]\\<rparr>;\n                                     s = s\\<lparr>on_stack := {v0}\\<rparr>\n                                 in Let (s\n   \\<lparr>visited := insert v0 (visited s)\\<rparr>)\n                                     RETURN) \\<bind>\n                             (\\<lambda>s.\n                                 RETURN (simple_state.more s) \\<bind>\n                                 (\\<lambda>e.\n                                     RETURN\n(s\\<lparr>simple_state.more := e\\<rparr>))) \\<bind>\n                             WHILE\\<^sub>T\\<^bsup>\\<lambda>s.\n               rwof\n                (RETURN\n                  \\<lparr>cycc_state_impl.break = False\\<rparr> \\<bind>\n                 (\\<lambda>e.\n                     RETURN\n                      \\<lparr>ss_stack = [], on_stack = {}, visited = {},\n                         \\<dots> = e\\<rparr>))\n                (gen_dfs_defs.gen_cond\n                  (gen_param_dfs_defs.gds (pre_simple_impl.gbs G)\n                    cycc_params_impl simple_state.more_update)\n                  (g_V0 G))\n                (gen_dfs_defs.gen_step\n                  (gen_param_dfs_defs.gds (pre_simple_impl.gbs G)\n                    cycc_params_impl simple_state.more_update)\n                  (g_V0 G))\n                s \\<and>\n               insert v0 {v. v \\<in> visited s0}\n               \\<subseteq> {v. v \\<in> visited s}\\<^esup>\n                              (\\<lambda>s.\n                                  \\<not> cycc_state_impl.break s \\<and>\n                                  ss_stack s \\<noteq> [])\n                              (\\<lambda>s.\n                                  ASSERT (ss_stack s \\<noteq> []) \\<bind>\n                                  (\\<lambda>_.\nlet (u, Vs) = hd (ss_stack s)\nin if Vs = {} then RETURN (u, None, s)\n   else SPEC (\\<lambda>v. v \\<in> Vs) \\<bind>\n        (\\<lambda>v.\n            let Vs = Vs - {v};\n                s = s\\<lparr>ss_stack := (u, Vs) # tl (ss_stack s)\\<rparr>\n            in RETURN (u, Some v, s))) \\<bind>\n                                  (\\<lambda>(u, Vs, s).\ncase Vs of\nNone \\<Rightarrow>\n  ASSERT (ss_stack s \\<noteq> [] \\<and> u \\<in> on_stack s) \\<bind>\n  (\\<lambda>_.\n      let s = s\\<lparr>ss_stack := tl (ss_stack s)\\<rparr>\n      in Let (s\\<lparr>on_stack := on_stack s - {u}\\<rparr>) RETURN) \\<bind>\n  (\\<lambda>s.\n      RETURN (simple_state.more s) \\<bind>\n      (\\<lambda>e. RETURN (s\\<lparr>simple_state.more := e\\<rparr>)))\n| Some v \\<Rightarrow>\n    if v \\<in> visited s\n    then if v \\<in> visited s - on_stack s\n         then RETURN s \\<bind>\n              (\\<lambda>s.\n                  RETURN (simple_state.more s) \\<bind>\n                  (\\<lambda>e.\n                      RETURN (s\\<lparr>simple_state.more := e\\<rparr>)))\n         else RETURN s \\<bind>\n              (\\<lambda>s.\n                  RETURN\n                   \\<lparr>cycc_state_impl.break = True\\<rparr> \\<bind>\n                  (\\<lambda>e.\n                      RETURN (s\\<lparr>simple_state.more := e\\<rparr>)))\n    else ASSERT (v \\<notin> on_stack s \\<and> v \\<notin> visited s) \\<bind>\n         (\\<lambda>_.\n             let s = s\\<lparr>ss_stack :=\n                                (v, g_E G `` {v}) # ss_stack s\\<rparr>;\n                 s = s\\<lparr>on_stack := insert v (on_stack s)\\<rparr>\n             in Let (s\\<lparr>visited := insert v (visited s)\\<rparr>)\n                 RETURN) \\<bind>\n         (\\<lambda>s.\n             RETURN (simple_state.more s) \\<bind>\n             (\\<lambda>e.\n                 RETURN\n                  (s\\<lparr>simple_state.more := e\\<rparr>)))))) \\<bind>\n                (\\<lambda>s. RETURN (cycc_state_impl.break s))))", "using [[autoref_trace_failed_id, goals_limit=1]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. RETURN ?c\n    \\<le> \\<Down> ?R\n           (ASSERT\n             (graph G \\<and> finite ((g_E G)\\<^sup>* `` g_V0 G)) \\<bind>\n            (\\<lambda>_.\n                RETURN \\<lparr>cycc_state_impl.break = False\\<rparr> \\<bind>\n                (\\<lambda>e.\n                    RETURN\n                     \\<lparr>ss_stack = [], on_stack = {}, visited = {},\n                        \\<dots> = e\\<rparr>) \\<bind>\n                FOREACH\\<^sub>C\\<^bsup>\\<lambda>it s.\n    rwof\n     (RETURN \\<lparr>cycc_state_impl.break = False\\<rparr> \\<bind>\n      (\\<lambda>e.\n          RETURN\n           \\<lparr>ss_stack = [], on_stack = {}, visited = {},\n              \\<dots> = e\\<rparr>))\n     (gen_dfs_defs.gen_cond\n       (gen_param_dfs_defs.gds (pre_simple_impl.gbs G) cycc_params_impl\n         simple_state.more_update)\n       (g_V0 G))\n     (gen_dfs_defs.gen_step\n       (gen_param_dfs_defs.gds (pre_simple_impl.gbs G) cycc_params_impl\n         simple_state.more_update)\n       (g_V0 G))\n     s \\<and>\n    (\\<not> cycc_state_impl.break s \\<longrightarrow>\n     ss_stack s = []) \\<and>\n    g_V0 G - it \\<subseteq> {v. v \\<in> visited s}\\<^esup>\n                 (g_V0 G) (\\<lambda>x. \\<not> cycc_state_impl.break x)\n                 (\\<lambda>v0 s.\n                     let s0 = s\n                     in if v0 \\<in> visited s then RETURN s\n                        else ASSERT (v0 \\<notin> visited s) \\<bind>\n                             (\\<lambda>_.\n                                 let s = s\n \\<lparr>ss_stack := [(v0, g_E G `` {v0})]\\<rparr>;\n                                     s = s\\<lparr>on_stack := {v0}\\<rparr>\n                                 in Let (s\n   \\<lparr>visited := insert v0 (visited s)\\<rparr>)\n                                     RETURN) \\<bind>\n                             (\\<lambda>s.\n                                 RETURN (simple_state.more s) \\<bind>\n                                 (\\<lambda>e.\n                                     RETURN\n(s\\<lparr>simple_state.more := e\\<rparr>))) \\<bind>\n                             WHILE\\<^sub>T\\<^bsup>\\<lambda>s.\n               rwof\n                (RETURN\n                  \\<lparr>cycc_state_impl.break = False\\<rparr> \\<bind>\n                 (\\<lambda>e.\n                     RETURN\n                      \\<lparr>ss_stack = [], on_stack = {}, visited = {},\n                         \\<dots> = e\\<rparr>))\n                (gen_dfs_defs.gen_cond\n                  (gen_param_dfs_defs.gds (pre_simple_impl.gbs G)\n                    cycc_params_impl simple_state.more_update)\n                  (g_V0 G))\n                (gen_dfs_defs.gen_step\n                  (gen_param_dfs_defs.gds (pre_simple_impl.gbs G)\n                    cycc_params_impl simple_state.more_update)\n                  (g_V0 G))\n                s \\<and>\n               insert v0 {v. v \\<in> visited s0}\n               \\<subseteq> {v. v \\<in> visited s}\\<^esup>\n                              (\\<lambda>s.\n                                  \\<not> cycc_state_impl.break s \\<and>\n                                  ss_stack s \\<noteq> [])\n                              (\\<lambda>s.\n                                  ASSERT (ss_stack s \\<noteq> []) \\<bind>\n                                  (\\<lambda>_.\nlet (u, Vs) = hd (ss_stack s)\nin if Vs = {} then RETURN (u, None, s)\n   else SPEC (\\<lambda>v. v \\<in> Vs) \\<bind>\n        (\\<lambda>v.\n            let Vs = Vs - {v};\n                s = s\\<lparr>ss_stack := (u, Vs) # tl (ss_stack s)\\<rparr>\n            in RETURN (u, Some v, s))) \\<bind>\n                                  (\\<lambda>(u, Vs, s).\ncase Vs of\nNone \\<Rightarrow>\n  ASSERT (ss_stack s \\<noteq> [] \\<and> u \\<in> on_stack s) \\<bind>\n  (\\<lambda>_.\n      let s = s\\<lparr>ss_stack := tl (ss_stack s)\\<rparr>\n      in Let (s\\<lparr>on_stack := on_stack s - {u}\\<rparr>) RETURN) \\<bind>\n  (\\<lambda>s.\n      RETURN (simple_state.more s) \\<bind>\n      (\\<lambda>e. RETURN (s\\<lparr>simple_state.more := e\\<rparr>)))\n| Some v \\<Rightarrow>\n    if v \\<in> visited s\n    then if v \\<in> visited s - on_stack s\n         then RETURN s \\<bind>\n              (\\<lambda>s.\n                  RETURN (simple_state.more s) \\<bind>\n                  (\\<lambda>e.\n                      RETURN (s\\<lparr>simple_state.more := e\\<rparr>)))\n         else RETURN s \\<bind>\n              (\\<lambda>s.\n                  RETURN\n                   \\<lparr>cycc_state_impl.break = True\\<rparr> \\<bind>\n                  (\\<lambda>e.\n                      RETURN (s\\<lparr>simple_state.more := e\\<rparr>)))\n    else ASSERT (v \\<notin> on_stack s \\<and> v \\<notin> visited s) \\<bind>\n         (\\<lambda>_.\n             let s = s\\<lparr>ss_stack :=\n                                (v, g_E G `` {v}) # ss_stack s\\<rparr>;\n                 s = s\\<lparr>on_stack := insert v (on_stack s)\\<rparr>\n             in Let (s\\<lparr>visited := insert v (visited s)\\<rparr>)\n                 RETURN) \\<bind>\n         (\\<lambda>s.\n             RETURN (simple_state.more s) \\<bind>\n             (\\<lambda>e.\n                 RETURN\n                  (s\\<lparr>simple_state.more := e\\<rparr>)))))) \\<bind>\n                (\\<lambda>s. RETURN (cycc_state_impl.break s))))", "apply (autoref_monadic (trace,plain))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "concrete_definition cyc_checker_codeT uses cyc_checker_implT"], ["", "export_code cyc_checker_codeT checking SML"], ["", "theorem cyc_checker_codeT_correct:\n  assumes 1: \"graph G\" \"finite (graph_defs.reachable G)\"\n  assumes 2: \"(Gi, G) \\<in> \\<langle>Rm, Id\\<rangle>g_impl_rel_ext\"\n  shows \"cyc_checker_codeT Gi \\<longleftrightarrow> (\\<not>acyclic (g_E G \\<inter> ((g_E G)\\<^sup>* `` g_V0 G) \\<times> UNIV))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cyc_checker_codeT Gi =\n    (\\<not> acyclic\n             (g_E G \\<inter> (g_E G)\\<^sup>* `` g_V0 G \\<times> UNIV))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cyc_checker_codeT Gi =\n    (\\<not> acyclic\n             (g_E G \\<inter> (g_E G)\\<^sup>* `` g_V0 G \\<times> UNIV))", "note cyc_checker_codeT.refine[OF 2]"], ["proof (state)\nthis:\n  RETURN (cyc_checker_codeT Gi) \\<le> \\<Down> bool_rel (cyc_checker_implT G)\n\ngoal (1 subgoal):\n 1. cyc_checker_codeT Gi =\n    (\\<not> acyclic\n             (g_E G \\<inter> (g_E G)\\<^sup>* `` g_V0 G \\<times> UNIV))", "also"], ["proof (state)\nthis:\n  RETURN (cyc_checker_codeT Gi) \\<le> \\<Down> bool_rel (cyc_checker_implT G)\n\ngoal (1 subgoal):\n 1. cyc_checker_codeT Gi =\n    (\\<not> acyclic\n             (g_E G \\<inter> (g_E G)\\<^sup>* `` g_V0 G \\<times> UNIV))", "note cyc_checker_implT_refine"], ["proof (state)\nthis:\n  cyc_checker_implT ?G \\<le> \\<Down> bool_rel (cyc_checkerT ?G)\n\ngoal (1 subgoal):\n 1. cyc_checker_codeT Gi =\n    (\\<not> acyclic\n             (g_E G \\<inter> (g_E G)\\<^sup>* `` g_V0 G \\<times> UNIV))", "also"], ["proof (state)\nthis:\n  cyc_checker_implT ?G \\<le> \\<Down> bool_rel (cyc_checkerT ?G)\n\ngoal (1 subgoal):\n 1. cyc_checker_codeT Gi =\n    (\\<not> acyclic\n             (g_E G \\<inter> (g_E G)\\<^sup>* `` g_V0 G \\<times> UNIV))", "note cyc_checkerT_correct"], ["proof (state)\nthis:\n  cyc_checkerT ?G \\<le> cyc_checkerT_spec ?G\n\ngoal (1 subgoal):\n 1. cyc_checker_codeT Gi =\n    (\\<not> acyclic\n             (g_E G \\<inter> (g_E G)\\<^sup>* `` g_V0 G \\<times> UNIV))", "finally"], ["proof (chain)\npicking this:\n  RETURN (cyc_checker_codeT Gi) \\<le> cyc_checkerT_spec G", "show ?thesis"], ["proof (prove)\nusing this:\n  RETURN (cyc_checker_codeT Gi) \\<le> cyc_checkerT_spec G\n\ngoal (1 subgoal):\n 1. cyc_checker_codeT Gi =\n    (\\<not> acyclic\n             (g_E G \\<inter> (g_E G)\\<^sup>* `` g_V0 G \\<times> UNIV))", "using 1"], ["proof (prove)\nusing this:\n  RETURN (cyc_checker_codeT Gi) \\<le> cyc_checkerT_spec G\n  graph G\n  finite ((g_E G)\\<^sup>* `` g_V0 G)\n\ngoal (1 subgoal):\n 1. cyc_checker_codeT Gi =\n    (\\<not> acyclic\n             (g_E G \\<inter> (g_E G)\\<^sup>* `` g_V0 G \\<times> UNIV))", "unfolding cyc_checkerT_spec_def"], ["proof (prove)\nusing this:\n  RETURN (cyc_checker_codeT Gi)\n  \\<le> ASSERT (graph G \\<and> finite ((g_E G)\\<^sup>* `` g_V0 G)) \\<bind>\n        (\\<lambda>_.\n            SPEC\n             (\\<lambda>r.\n                 r =\n                 (\\<not> acyclic\n                          (g_E G \\<inter>\n                           (g_E G)\\<^sup>* `` g_V0 G \\<times> UNIV))))\n  graph G\n  finite ((g_E G)\\<^sup>* `` g_V0 G)\n\ngoal (1 subgoal):\n 1. cyc_checker_codeT Gi =\n    (\\<not> acyclic\n             (g_E G \\<inter> (g_E G)\\<^sup>* `` g_V0 G \\<times> UNIV))", "by auto"], ["proof (state)\nthis:\n  cyc_checker_codeT Gi =\n  (\\<not> acyclic (g_E G \\<inter> (g_E G)\\<^sup>* `` g_V0 G \\<times> UNIV))\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}