{"file_name": "/home/qj213/afp-2021-10-22/thys/DFS_Framework/Invars/DFS_Invars_Basic.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/DFS_Framework", "problem_names": ["lemma timing_common_inv: \n    \"is_invar timing_common_inv\"", "lemmas s_timing_common_inv = \n    timing_common_inv[THEN make_invar_thm]", "lemma timing_less_counter:\n    \"v \\<in> dom (discovered s) \\<Longrightarrow> \\<delta> s v < counter s\"\n    \"v \\<in> dom (finished s) \\<Longrightarrow> \\<phi> s v < counter s\"", "lemma disc_lt_fin:\n    \"v \\<in> dom (finished s) \\<Longrightarrow> \\<delta> s v < \\<phi> s v\"", "lemma disc_unequal:\n    assumes \"v \\<in> dom (discovered s)\" \"w \\<in> dom (discovered s)\"\n    and \"v \\<noteq> w\"\n    shows \"\\<delta> s v \\<noteq> \\<delta> s w\"", "lemma fin_unequal:\n    assumes \"v \\<in> dom (finished s)\" \"w \\<in> dom (finished s)\"\n    and \"v \\<noteq> w\"\n    shows \"\\<phi> s v \\<noteq> \\<phi> s w\"", "lemma finished_succ_fin:\n    assumes \"v \\<in> dom (finished s)\"\n    and \"w \\<in> succ v\"\n    shows \"\\<delta> s w < \\<phi> s v\"", "lemma i_prev_stack_discover_all:\n    \"is_invar (\\<lambda>s. \\<forall> n < length (stack s). \\<forall> v \\<in> set (drop (Suc n) (stack s)). \n                   \\<delta> s (stack s ! n) > \\<delta> s v)\"", "lemmas prev_stack_discover_all \n    = i_prev_stack_discover_all[THEN make_invar_thm]", "lemma prev_stack_discover:\n    \"\\<lbrakk>n < length (stack s); v \\<in> set (drop (Suc n) (stack s)) \\<rbrakk>\n     \\<Longrightarrow> \\<delta> s (stack s ! n) > \\<delta> s v\"", "lemma Suc_stack_discover:\n    assumes n: \"n < (length (stack s)) - 1\"\n    shows \"\\<delta> s (stack s ! n) > \\<delta> s (stack s ! Suc n)\"", "lemma tl_lt_stack_hd_discover:\n    assumes notempty: \"stack s \\<noteq> []\"\n    and \"x \\<in> set (tl (stack s))\"\n    shows \"\\<delta> s x < \\<delta> s (hd (stack s))\"", "lemma stack_nth_order:\n    assumes l: \"i < length (stack s)\" \"j < length (stack s)\"\n    shows \"\\<delta> s (stack s ! i) < \\<delta> s (stack s ! j) \\<longleftrightarrow> i > j\" (is \"\\<delta> s ?i < \\<delta> s ?j \\<longleftrightarrow> _\")", "lemma i_parenthesis: \"is_invar parenthesis\"", "lemma parenthesis:\n    assumes \"v \\<in> dom (finished s)\" \"w \\<in> dom (discovered s)\"\n    and \"\\<delta> s v < \\<delta> s w\"\n    shows \"\\<phi> s v < \\<delta> s w \\<comment> \\<open>disjoint\\<close>\n           \\<or> (\\<phi> s v > \\<delta> s w \\<and> w \\<in> dom (finished s) \\<and> \\<phi> s w < \\<phi> s v)\"", "lemma parenthesis_contained:\n    assumes \"v \\<in> dom (finished s)\" \"w \\<in> dom (discovered s)\"\n    and \"\\<delta> s v < \\<delta> s w\" \"\\<phi> s v > \\<delta> s w\"\n    shows \"w \\<in> dom (finished s) \\<and> \\<phi> s w < \\<phi> s v\"", "lemma parenthesis_disjoint:\n    assumes \"v \\<in> dom (finished s)\" \"w \\<in> dom (discovered s)\"\n    and \"\\<delta> s v < \\<delta> s w\" \"\\<phi> s w > \\<phi> s v\"\n    shows \"\\<phi> s v < \\<delta> s w\"", "lemma finished_succ_contained:\n    assumes \"v \\<in> dom (finished s)\"\n    and \"w \\<in> succ v\"\n    and \"\\<delta> s v < \\<delta> s w\"\n    shows \"w \\<in> dom (finished s) \\<and> \\<phi> s w < \\<phi> s v\"", "lemma \"is_invar (\\<lambda>s. finite (edges s))\"", "lemma edgesE_CB:\n    assumes \"x \\<in> edges s\"\n    and \"x \\<in> tree_edges s \\<Longrightarrow> P\"\n    and \"x \\<in> cross_edges s \\<union> back_edges s \\<Longrightarrow> P\"\n    shows \"P\"", "lemma i_edges_basic:\n    \"is_invar edges_basic\"", "lemmas (in DFS_invar) edges_basic = i_edges_basic[THEN make_invar_thm]", "lemma i_edges_covered: \n    \"is_invar (\\<lambda>s. (E \\<inter> dom (discovered s) \\<times> UNIV) - pending s = edges s)\"", "lemmas edges_covered = \n    i_edges_covered[THEN make_invar_thm]", "lemma edges_ss_reachable_edges:\n    \"edges s \\<subseteq> E \\<inter> reachable \\<times> UNIV\"", "lemma nc_edges_covered:\n    assumes \"\\<not>cond s\" \"\\<not>is_break param s\"\n    shows \"E \\<inter> reachable \\<times> UNIV = edges s\"", "lemma \n    tree_edges_ssE: \"tree_edges s \\<subseteq> E\" and\n    tree_edges_not_pending: \"tree_edges s \\<subseteq> - pending s\" and\n    tree_edge_is_succ: \"(v,w) \\<in> tree_edges s \\<Longrightarrow> w \\<in> succ v\" and\n    tree_edges_discovered: \"Field (tree_edges s) \\<subseteq> dom (discovered s)\" and\n\n    cross_edges_ssE: \"cross_edges s \\<subseteq> E\" and\n    cross_edges_not_pending: \"cross_edges s \\<subseteq> - pending s\" and\n    cross_edge_is_succ: \"(v,w) \\<in> cross_edges s \\<Longrightarrow> w \\<in> succ v\" and\n    cross_edges_discovered: \"Field (cross_edges s) \\<subseteq> dom (discovered s)\" and\n\n    back_edges_ssE: \"back_edges s \\<subseteq> E\" and\n    back_edges_not_pending: \"back_edges s \\<subseteq> - pending s\" and\n    back_edge_is_succ: \"(v,w) \\<in> back_edges s \\<Longrightarrow> w \\<in> succ v\" and\n    back_edges_discovered: \"Field (back_edges s) \\<subseteq> dom (discovered s)\"", "lemma edges_disjoint: \n   \"back_edges s \\<inter> cross_edges s = {}\"\n   \"back_edges s \\<inter> tree_edges s = {}\"\n   \"cross_edges s \\<inter> tree_edges s = {}\"", "lemma tree_edge_imp_discovered:\n    \"(v,w) \\<in> tree_edges s \\<Longrightarrow> v \\<in> dom (discovered s)\"\n    \"(v,w) \\<in> tree_edges s \\<Longrightarrow> w \\<in> dom (discovered s)\"", "lemma back_edge_imp_discovered:\n    \"(v,w) \\<in> back_edges s \\<Longrightarrow> v \\<in> dom (discovered s)\"\n    \"(v,w) \\<in> back_edges s \\<Longrightarrow> w \\<in> dom (discovered s)\"", "lemma cross_edge_imp_discovered:\n    \"(v,w) \\<in> cross_edges s \\<Longrightarrow> v \\<in> dom (discovered s)\"\n    \"(v,w) \\<in> cross_edges s \\<Longrightarrow> w \\<in> dom (discovered s)\"", "lemma edge_imp_discovered:\n    \"(v,w) \\<in> edges s \\<Longrightarrow> v \\<in> dom (discovered s)\"\n    \"(v,w) \\<in> edges s \\<Longrightarrow> w \\<in> dom (discovered s)\"", "lemma tree_edges_finite[simp, intro!]: \"finite (tree_edges s)\"", "lemma cross_edges_finite[simp, intro!]: \"finite (cross_edges s)\"", "lemma back_edges_finite[simp, intro!]: \"finite (back_edges s)\"", "lemma edges_finite: \"finite (edges s)\"", "lemma tree_edge_disc_lt_fin:\n    \"(v,w) \\<in> tree_edges s \\<Longrightarrow> v \\<in> dom (finished s) \\<Longrightarrow> \\<delta> s w < \\<phi> s v\"", "lemma back_edge_disc_lt_fin:\n    \"(v,w) \\<in> back_edges s \\<Longrightarrow> v \\<in> dom (finished s) \\<Longrightarrow> \\<delta> s w < \\<phi> s v\"", "lemma cross_edge_disc_lt_fin:\n    \"(v,w) \\<in> cross_edges s \\<Longrightarrow> v \\<in> dom (finished s) \\<Longrightarrow> \\<delta> s w < \\<phi> s v\"", "lemma i_stack_is_tree_path:\n    \"is_invar (\\<lambda>s. stack s \\<noteq> [] \\<longrightarrow> (\\<exists>v0 \\<in> V0. \n        path (tree_edges s) v0 (rev (tl (stack s))) (hd (stack s))))\"", "lemmas stack_is_tree_path = \n    i_stack_is_tree_path[THEN make_invar_thm, rule_format]", "lemma stack_is_path:\n    \"stack s \\<noteq> [] \\<Longrightarrow> \\<exists>v0\\<in>V0. path E v0 (rev (tl (stack s))) (hd (stack s))\"", "lemma hd_succ_stack_is_path:\n    assumes ne: \"stack s \\<noteq> []\"\n    and succ: \"v \\<in> succ (hd (stack s))\"\n    shows \"\\<exists>v0\\<in>V0. path E v0 (rev (stack s)) v\"", "lemma tl_stack_hd_tree_path:\n    assumes \"stack s \\<noteq> []\"\n    and \"v \\<in> set (tl (stack s))\"\n    shows \"(v, hd (stack s)) \\<in> (tree_edges s)\\<^sup>+\"", "lemma i_tree_discovered_inv: \n    \"is_invar tree_discovered_inv\"", "lemmas (in DFS_invar) tree_discovered_inv = \n    i_tree_discovered_inv[THEN make_invar_thm]", "lemma (in DFS_invar) discovered_iff_tree_path:\n    \"v \\<notin> V0 \\<Longrightarrow> v \\<in> dom (discovered s) \\<longleftrightarrow> (\\<exists>v0\\<in>V0. (v0,v) \\<in> (tree_edges s)\\<^sup>+)\"", "lemma i_tree_one_predecessor:\n    \"is_invar (\\<lambda>s. \\<forall>(v,v') \\<in> tree_edges s. \\<forall>y. y \\<noteq> v \\<longrightarrow> (y,v') \\<notin> tree_edges s)\"", "lemma (in DFS_invar) tree_one_predecessor:\n    assumes \"(v,w) \\<in> tree_edges s\"\n    and \"a \\<noteq> v\"\n    shows \"(a,w) \\<notin> tree_edges s\"", "lemma (in DFS_invar) tree_eq_rule:\n    \"\\<lbrakk>(v,w) \\<in> tree_edges s; (u,w) \\<in> tree_edges s\\<rbrakk> \\<Longrightarrow> v=u\"", "lemma i_tree_edge_disc:\n    \"is_invar (\\<lambda>s. \\<forall>(v,v') \\<in> tree_edges s. \\<delta> s v < \\<delta> s v')\"", "lemma tree_edge_disc:\n    \"(v,w) \\<in> tree_edges s \\<Longrightarrow> \\<delta> s v < \\<delta> s w\"", "lemma tree_path_disc:\n    \"(v,w) \\<in> (tree_edges s)\\<^sup>+ \\<Longrightarrow> \\<delta> s v < \\<delta> s w\"", "lemma no_loop_in_tree:\n    \"(v,v) \\<notin> (tree_edges s)\\<^sup>+\"", "lemma tree_acyclic:\n    \"acyclic (tree_edges s)\"", "lemma no_self_loop_in_tree:\n    \"(v,v) \\<notin> tree_edges s\"", "lemma tree_edge_unequal:\n    \"(v,w) \\<in> tree_edges s \\<Longrightarrow> v \\<noteq> w\"", "lemma tree_path_unequal:\n    \"(v,w) \\<in> (tree_edges s)\\<^sup>+ \\<Longrightarrow> v \\<noteq> w\"", "lemma tree_subpath':\n    assumes x: \"(x,v) \\<in> (tree_edges s)\\<^sup>+\"\n    and y: \"(y,v) \\<in> (tree_edges s)\\<^sup>+\"\n    and \"x \\<noteq> y\"\n    shows \"(x,y) \\<in> (tree_edges s)\\<^sup>+ \\<or> (y,x) \\<in> (tree_edges s)\\<^sup>+\"", "lemma tree_subpath:\n    assumes \"(x,v) \\<in> (tree_edges s)\\<^sup>+\"\n    and \"(y,v) \\<in> (tree_edges s)\\<^sup>+\"\n    and \\<delta>: \"\\<delta> s x < \\<delta> s y\"\n    shows \"(x,y) \\<in> (tree_edges s)\\<^sup>+\"", "lemma on_stack_is_tree_path:\n    assumes x: \"x \\<in> set (stack s)\"\n    and y: \"y \\<in> set (stack s)\"\n    and \\<delta>: \"\\<delta> s x < \\<delta> s y\"\n    shows \"(x,y) \\<in> (tree_edges s)\\<^sup>+\"", "lemma hd_stack_tree_path_finished:\n    assumes \"stack s \\<noteq> []\"\n    assumes \"(hd (stack s), v) \\<in> (tree_edges s)\\<^sup>+\"\n    shows \"v \\<in> dom (finished s)\"", "lemma tree_edge_impl_parenthesis:\n    assumes t: \"(v,w) \\<in> tree_edges s\"\n    and f: \"v \\<in> dom (finished s)\"\n    shows \"w \\<in> dom (finished s) \n      \\<and> \\<delta> s v < \\<delta> s w\n      \\<and> \\<phi> s w < \\<phi> s v \"", "lemma tree_path_impl_parenthesis:\n    assumes \"(v,w) \\<in> (tree_edges s)\\<^sup>+\"\n    and \"v \\<in> dom (finished s)\"\n    shows \"w \\<in> dom (finished s) \n      \\<and> \\<delta> s v < \\<delta> s w\n      \\<and> \\<phi> s w < \\<phi> s v \"", "lemma nc_reachable_v0_parenthesis:\n    assumes C: \"\\<not> cond s\" \"\\<not> is_break param s\"\n    and v: \"v \\<in> reachable\" \"v \\<notin> V0\"\n    obtains v0 where \"v0 \\<in> V0\"\n                 and \"\\<delta> s v0 < \\<delta> s v \\<and> \\<phi> s v < \\<phi> s v0 \"", "lemma paren_imp_tree_reach:\n    \"is_invar paren_imp_tree_reach\"", "lemmas s_paren_imp_tree_reach =\n    paren_imp_tree_reach[THEN make_invar_thm]", "lemma parenthesis_impl_tree_path_not_finished:\n    assumes \"v \\<in> dom (discovered s)\"\n    and \"w \\<in> dom (finished s)\"\n    and \"\\<delta> s v < \\<delta> s w\"\n    and \"v \\<notin> dom (finished s)\"\n    shows \"(v,w) \\<in> (tree_edges s)\\<^sup>+\"", "lemma parenthesis_impl_tree_path:\n    assumes \"v \\<in> dom (finished s)\" \"w \\<in> dom (finished s)\"\n    and \"\\<delta> s v < \\<delta> s w\" \"\\<phi> s v > \\<phi> s w\"\n    shows \"(v,w) \\<in> (tree_edges s)\\<^sup>+\"", "lemma tree_path_iff_parenthesis:\n    assumes \"v \\<in> dom (finished s)\" \"w \\<in> dom (finished s)\"\n    shows \"(v,w) \\<in> (tree_edges s)\\<^sup>+ \\<longleftrightarrow> \\<delta> s v < \\<delta> s w \\<and> \\<phi> s v > \\<phi> s w\"", "lemma no_pending_succ_impl_path_in_tree:\n    assumes v: \"v \\<in> dom (discovered s)\" \"pending s `` {v} = {}\"\n    and w: \"w \\<in> succ v\"\n    and \\<delta>: \"\\<delta> s v < \\<delta> s w\"\n    shows \"(v,w) \\<in> (tree_edges s)\\<^sup>+\"", "lemma finished_succ_impl_path_in_tree:\n    assumes f:  \"v \\<in> dom (finished s)\"\n    and s: \"w \\<in> succ v\"\n    and \\<delta>: \"\\<delta> s v < \\<delta> s w\"\n    shows \"(v,w) \\<in> (tree_edges s)\\<^sup>+\"", "lemma i_cross_edges_finished: \"is_invar (\\<lambda>s. \\<forall>(u,v)\\<in>cross_edges s. \n    v \\<in> dom (finished s) \\<and> (u \\<in> dom (finished s) \\<longrightarrow> \\<phi> s v < \\<phi> s u))\"", "lemmas cross_edges_finished \n    = i_cross_edges_finished[THEN make_invar_thm]", "lemma cross_edges_target_finished: \n    \"(u,v)\\<in>cross_edges s \\<Longrightarrow> v \\<in> dom (finished s)\"", "lemma cross_edges_finished_decr: \n    \"\\<lbrakk>(u,v)\\<in>cross_edges s; u\\<in>dom (finished s)\\<rbrakk> \\<Longrightarrow> \\<phi> s v < \\<phi> s u\"", "lemma cross_edge_unequal:\n    assumes cross: \"(v,w) \\<in> cross_edges s\"\n    shows \"v \\<noteq> w\"", "lemma i_back_edge_impl_tree_path:\n    \"is_invar (\\<lambda>s. \\<forall>(v,w) \\<in> back_edges s. (w,v) \\<in> (tree_edges s)\\<^sup>+ \\<or> w = v)\"", "lemma back_edge_impl_tree_path:\n    \"\\<lbrakk>(v,w) \\<in> back_edges s; v \\<noteq> w\\<rbrakk> \\<Longrightarrow> (w,v) \\<in> (tree_edges s)\\<^sup>+\"", "lemma back_edge_disc:\n    assumes \"(v,w) \\<in> back_edges s\"\n    shows \"\\<delta> s w \\<le> \\<delta> s v\"", "lemma back_edges_tree_disjoint:\n    \"back_edges s \\<inter> tree_edges s = {}\"", "lemma back_edges_tree_pathes_disjoint:\n    \"back_edges s \\<inter> (tree_edges s)\\<^sup>+ = {}\"", "lemma back_edge_finished:\n    assumes \"(v,w) \\<in> back_edges s\"\n    and \"w \\<in> dom (finished s)\"\n    shows \"v \\<in> dom (finished s) \\<and> \\<phi> s v \\<le> \\<phi> s w\"", "lemma i_disc_imp_back_edge_or_pending:\n    \"is_invar (\\<lambda>s. \\<forall>(v,w) \\<in> E. \n        v \\<in> dom (discovered s) \\<and> w \\<in> dom (discovered s)\n      \\<and> \\<delta> s v \\<ge> \\<delta> s w\n      \\<and> (w \\<in> dom (finished s) \\<longrightarrow> v \\<in> dom (finished s) \\<and> \\<phi> s w \\<ge> \\<phi> s v)\n      \\<longrightarrow> (v,w) \\<in> back_edges s \\<or> (v,w) \\<in> pending s)\"", "lemma disc_imp_back_edge_or_pending:\n    \"\\<lbrakk>w \\<in> succ v; v \\<in> dom (discovered s); w \\<in> dom (discovered s); \\<delta> s w \\<le> \\<delta> s v;\n      (w \\<in> dom (finished s) \\<Longrightarrow> v \\<in> dom (finished s) \\<and> \\<phi> s v \\<le> \\<phi> s w)\\<rbrakk>\n     \\<Longrightarrow> (v, w) \\<in> back_edges s \\<or> (v, w) \\<in> pending s\"", "lemma finished_imp_back_edge:\n    \"\\<lbrakk>w \\<in> succ v; v \\<in> dom (finished s); w \\<in> dom (finished s); \n      \\<delta> s w \\<le> \\<delta> s v; \\<phi> s v \\<le> \\<phi> s w\\<rbrakk>\n     \\<Longrightarrow> (v, w) \\<in> back_edges s\"", "lemma finished_not_finished_imp_back_edge:\n    \"\\<lbrakk>w \\<in> succ v; v \\<in> dom (finished s); w \\<in> dom (discovered s);\n      w \\<notin> dom (finished s);\n      \\<delta> s w \\<le> \\<delta> s v\\<rbrakk>\n     \\<Longrightarrow> (v, w) \\<in> back_edges s\"", "lemma finished_self_loop_in_back_edges:\n    assumes \"v \\<in> dom (finished s)\"\n    and \"(v,v) \\<in> E\"\n    shows \"(v,v) \\<in> back_edges s\"", "lemma tree_cross_acyclic:\n      \"acyclic (tree_edges s \\<union> cross_edges s)\" (is \"acyclic ?E\")", "lemma cycle_contains_back_edge:\n    assumes cycle: \"(u,u) \\<in> (edges s)\\<^sup>+\"\n    shows \"\\<exists>v w. (u,v) \\<in> (edges s)\\<^sup>* \\<and> (v,w) \\<in> back_edges s \\<and> (w,u) \\<in> (edges s)\\<^sup>*\"", "lemma cycle_needs_back_edge:\n    assumes \"back_edges s = {}\"\n    shows \"acyclic (edges s)\"", "lemma back_edge_closes_cycle:\n    assumes \"back_edges s \\<noteq> {}\"\n    shows \"\\<not> acyclic (edges s)\"", "lemma back_edge_closes_reachable_cycle:\n    \"back_edges s \\<noteq> {} \\<Longrightarrow> \\<not> acyclic (E \\<inter> reachable \\<times> UNIV)\"", "lemma cycle_iff_back_edges:\n    \"acyclic (edges s) \\<longleftrightarrow> back_edges s = {}\"", "lemma white_path:\n    \"it_dfs \\<le> SPEC(\\<lambda>s. \\<forall>x \\<in> reachable. \\<forall>y \\<in> reachable. \\<not> is_break param s \\<longrightarrow> \n            white_path s x y \\<longleftrightarrow> (x,y) \\<in> (tree_edges s)\\<^sup>*)\""], "translations": [["", "lemma timing_common_inv: \n    \"is_invar timing_common_inv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_invar timing_common_inv", "proof (induction rule: is_invarI)"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>e. timing_common_inv (empty_state e)\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>timing_common_inv s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s = []; v0 \\<notin> dom (discovered s);\n        v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> timing_common_inv s'\n 3. \\<And>s s' u e.\n       \\<lbrakk>timing_common_inv s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; pending s `` {u} = {};\n        u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> timing_common_inv s'\n 4. \\<And>s s' u v e c b.\n       \\<lbrakk>timing_common_inv s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); u = hd (stack s);\n        cross_edges s \\<subseteq> c; back_edges s \\<subseteq> b;\n        s' = s\n        \\<lparr>pending := pending s - {(u, v)}, state.more := e,\n           cross_edges := c, back_edges := b\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> timing_common_inv s'\n 5. \\<And>s s' u v e.\n       \\<lbrakk>timing_common_inv s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> timing_common_inv s'", "case (finish s s')"], ["proof (state)\nthis:\n  timing_common_inv s\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s \\<noteq> []\n  pending s `` {u_} = {}\n  u_ = hd (stack s)\n  s' = finish u_ s\\<lparr>state.more := e_\\<rparr>\n\ngoal (5 subgoals):\n 1. \\<And>e. timing_common_inv (empty_state e)\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>timing_common_inv s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s = []; v0 \\<notin> dom (discovered s);\n        v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> timing_common_inv s'\n 3. \\<And>s s' u e.\n       \\<lbrakk>timing_common_inv s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; pending s `` {u} = {};\n        u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> timing_common_inv s'\n 4. \\<And>s s' u v e c b.\n       \\<lbrakk>timing_common_inv s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); u = hd (stack s);\n        cross_edges s \\<subseteq> c; back_edges s \\<subseteq> b;\n        s' = s\n        \\<lparr>pending := pending s - {(u, v)}, state.more := e,\n           cross_edges := c, back_edges := b\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> timing_common_inv s'\n 5. \\<And>s s' u v e.\n       \\<lbrakk>timing_common_inv s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> timing_common_inv s'", "then"], ["proof (chain)\npicking this:\n  timing_common_inv s\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s \\<noteq> []\n  pending s `` {u_} = {}\n  u_ = hd (stack s)\n  s' = finish u_ s\\<lparr>state.more := e_\\<rparr>", "interpret DFS_invar where s=s"], ["proof (prove)\nusing this:\n  timing_common_inv s\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s \\<noteq> []\n  pending s `` {u_} = {}\n  u_ = hd (stack s)\n  s' = finish u_ s\\<lparr>state.more := e_\\<rparr>\n\ngoal (1 subgoal):\n 1. DFS_invar G param s", "by simp"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>e. timing_common_inv (empty_state e)\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>timing_common_inv s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s = []; v0 \\<notin> dom (discovered s);\n        v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> timing_common_inv s'\n 3. \\<And>s s' u e.\n       \\<lbrakk>timing_common_inv s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; pending s `` {u} = {};\n        u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> timing_common_inv s'\n 4. \\<And>s s' u v e c b.\n       \\<lbrakk>timing_common_inv s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); u = hd (stack s);\n        cross_edges s \\<subseteq> c; back_edges s \\<subseteq> b;\n        s' = s\n        \\<lparr>pending := pending s - {(u, v)}, state.more := e,\n           cross_edges := c, back_edges := b\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> timing_common_inv s'\n 5. \\<And>s s' u v e.\n       \\<lbrakk>timing_common_inv s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> timing_common_inv s'", "from finish"], ["proof (chain)\npicking this:\n  timing_common_inv s\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s \\<noteq> []\n  pending s `` {u_} = {}\n  u_ = hd (stack s)\n  s' = finish u_ s\\<lparr>state.more := e_\\<rparr>", "have NE: \"stack s \\<noteq> []\""], ["proof (prove)\nusing this:\n  timing_common_inv s\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s \\<noteq> []\n  pending s `` {u_} = {}\n  u_ = hd (stack s)\n  s' = finish u_ s\\<lparr>state.more := e_\\<rparr>\n\ngoal (1 subgoal):\n 1. stack s \\<noteq> []", "by (simp add: cond_alt)"], ["proof (state)\nthis:\n  stack s \\<noteq> []\n\ngoal (5 subgoals):\n 1. \\<And>e. timing_common_inv (empty_state e)\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>timing_common_inv s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s = []; v0 \\<notin> dom (discovered s);\n        v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> timing_common_inv s'\n 3. \\<And>s s' u e.\n       \\<lbrakk>timing_common_inv s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; pending s `` {u} = {};\n        u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> timing_common_inv s'\n 4. \\<And>s s' u v e c b.\n       \\<lbrakk>timing_common_inv s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); u = hd (stack s);\n        cross_edges s \\<subseteq> c; back_edges s \\<subseteq> b;\n        s' = s\n        \\<lparr>pending := pending s - {(u, v)}, state.more := e,\n           cross_edges := c, back_edges := b\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> timing_common_inv s'\n 5. \\<And>s s' u v e.\n       \\<lbrakk>timing_common_inv s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> timing_common_inv s'", "have *: \"hd (stack s) \\<notin> dom (finished s)\" \"hd (stack s) \\<in> dom (discovered s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hd (stack s) \\<notin> dom (finished s) &&&\n    hd (stack s) \\<in> dom (discovered s)", "using stack_not_finished stack_discovered hd_in_set[OF NE]"], ["proof (prove)\nusing this:\n  ?x \\<in> set (stack s) \\<Longrightarrow> ?x \\<notin> dom (finished s)\n  set (stack s) \\<subseteq> dom (discovered s)\n  hd (stack s) \\<in> set (stack s)\n\ngoal (1 subgoal):\n 1. hd (stack s) \\<notin> dom (finished s) &&&\n    hd (stack s) \\<in> dom (discovered s)", "by blast+"], ["proof (state)\nthis:\n  hd (stack s) \\<notin> dom (finished s)\n  hd (stack s) \\<in> dom (discovered s)\n\ngoal (5 subgoals):\n 1. \\<And>e. timing_common_inv (empty_state e)\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>timing_common_inv s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s = []; v0 \\<notin> dom (discovered s);\n        v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> timing_common_inv s'\n 3. \\<And>s s' u e.\n       \\<lbrakk>timing_common_inv s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; pending s `` {u} = {};\n        u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> timing_common_inv s'\n 4. \\<And>s s' u v e c b.\n       \\<lbrakk>timing_common_inv s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); u = hd (stack s);\n        cross_edges s \\<subseteq> c; back_edges s \\<subseteq> b;\n        s' = s\n        \\<lparr>pending := pending s - {(u, v)}, state.more := e,\n           cross_edges := c, back_edges := b\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> timing_common_inv s'\n 5. \\<And>s s' u v e.\n       \\<lbrakk>timing_common_inv s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> timing_common_inv s'", "from discovered_closed"], ["proof (chain)\npicking this:\n  discovered_closed s", "have \n      \"(E - pending s) `` {hd (stack s)} \\<subseteq> dom (discovered s)\""], ["proof (prove)\nusing this:\n  discovered_closed s\n\ngoal (1 subgoal):\n 1. (E - pending s) `` {hd (stack s)} \\<subseteq> dom (discovered s)", "using hd_in_set[OF NE]"], ["proof (prove)\nusing this:\n  discovered_closed s\n  hd (stack s) \\<in> set (stack s)\n\ngoal (1 subgoal):\n 1. (E - pending s) `` {hd (stack s)} \\<subseteq> dom (discovered s)", "by (auto simp add: discovered_closed_def)"], ["proof (state)\nthis:\n  (E - pending s) `` {hd (stack s)} \\<subseteq> dom (discovered s)\n\ngoal (5 subgoals):\n 1. \\<And>e. timing_common_inv (empty_state e)\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>timing_common_inv s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s = []; v0 \\<notin> dom (discovered s);\n        v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> timing_common_inv s'\n 3. \\<And>s s' u e.\n       \\<lbrakk>timing_common_inv s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; pending s `` {u} = {};\n        u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> timing_common_inv s'\n 4. \\<And>s s' u v e c b.\n       \\<lbrakk>timing_common_inv s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); u = hd (stack s);\n        cross_edges s \\<subseteq> c; back_edges s \\<subseteq> b;\n        s' = s\n        \\<lparr>pending := pending s - {(u, v)}, state.more := e,\n           cross_edges := c, back_edges := b\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> timing_common_inv s'\n 5. \\<And>s s' u v e.\n       \\<lbrakk>timing_common_inv s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> timing_common_inv s'", "hence succ_hd: \"pending s `` {hd (stack s)} = {} \n      \\<Longrightarrow> succ (hd (stack s)) \\<subseteq> dom (discovered s)\""], ["proof (prove)\nusing this:\n  (E - pending s) `` {hd (stack s)} \\<subseteq> dom (discovered s)\n\ngoal (1 subgoal):\n 1. pending s `` {hd (stack s)} = {} \\<Longrightarrow>\n    E `` {hd (stack s)} \\<subseteq> dom (discovered s)", "by blast"], ["proof (state)\nthis:\n  pending s `` {hd (stack s)} = {} \\<Longrightarrow>\n  E `` {hd (stack s)} \\<subseteq> dom (discovered s)\n\ngoal (5 subgoals):\n 1. \\<And>e. timing_common_inv (empty_state e)\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>timing_common_inv s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s = []; v0 \\<notin> dom (discovered s);\n        v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> timing_common_inv s'\n 3. \\<And>s s' u e.\n       \\<lbrakk>timing_common_inv s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; pending s `` {u} = {};\n        u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> timing_common_inv s'\n 4. \\<And>s s' u v e c b.\n       \\<lbrakk>timing_common_inv s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); u = hd (stack s);\n        cross_edges s \\<subseteq> c; back_edges s \\<subseteq> b;\n        s' = s\n        \\<lparr>pending := pending s - {(u, v)}, state.more := e,\n           cross_edges := c, back_edges := b\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> timing_common_inv s'\n 5. \\<And>s s' u v e.\n       \\<lbrakk>timing_common_inv s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> timing_common_inv s'", "from finish"], ["proof (chain)\npicking this:\n  timing_common_inv s\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s \\<noteq> []\n  pending s `` {u_} = {}\n  u_ = hd (stack s)\n  s' = finish u_ s\\<lparr>state.more := e_\\<rparr>", "show ?case"], ["proof (prove)\nusing this:\n  timing_common_inv s\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s \\<noteq> []\n  pending s `` {u_} = {}\n  u_ = hd (stack s)\n  s' = finish u_ s\\<lparr>state.more := e_\\<rparr>\n\ngoal (1 subgoal):\n 1. timing_common_inv s'", "apply (simp add: timing_common_inv_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<forall>v\\<in>dom (finished s).\n                 \\<delta> s v < \\<phi> s v) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<forall>w\\<in>dom (discovered s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<delta> s v \\<noteq> \\<delta> s w) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>dom (finished s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<phi> s v \\<noteq> \\<phi> s w) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<delta> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<phi> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>E `` {v}. \\<delta> s w < \\<phi> s v);\n     cond s; DFS_invar G param s;\n     DFS_invar G param\n      (finish (hd (stack s)) s\\<lparr>state.more := e_\\<rparr>);\n     stack s \\<noteq> []; pending s `` {hd (stack s)} = {};\n     u_ = hd (stack s);\n     s' = finish (hd (stack s)) s\\<lparr>state.more := e_\\<rparr>\\<rbrakk>\n    \\<Longrightarrow> \\<delta> s (hd (stack s)) < counter s \\<and>\n                      (hd (stack s) \\<in> dom (finished s) \\<longrightarrow>\n                       \\<delta> s (hd (stack s)) < counter s) \\<and>\n                      (\\<forall>w\\<in>dom (finished s).\n                          hd (stack s) \\<noteq> w \\<longrightarrow>\n                          counter s \\<noteq> \\<phi> s w) \\<and>\n                      (\\<forall>v\\<in>dom (finished s).\n                          (v = hd (stack s) \\<longrightarrow>\n                           (\\<forall>w\\<in>dom (finished s).\n                               hd (stack s) \\<noteq> w \\<longrightarrow>\n                               counter s \\<noteq> \\<phi> s w)) \\<and>\n                          (v \\<noteq> hd (stack s) \\<longrightarrow>\n                           \\<phi> s v \\<noteq> counter s \\<and>\n                           (hd (stack s)\n                            \\<in> dom (finished s) \\<longrightarrow>\n                            \\<phi> s v \\<noteq> counter s))) \\<and>\n                      (\\<forall>v\\<in>dom (discovered s).\n                          \\<delta> s v < Suc (counter s)) \\<and>\n                      (\\<forall>v\\<in>dom (finished s).\n                          v \\<noteq> hd (stack s) \\<longrightarrow>\n                          \\<phi> s v < Suc (counter s)) \\<and>\n                      (\\<forall>w\\<in>E `` {hd (stack s)}.\n                          \\<delta> s w < counter s) \\<and>\n                      (hd (stack s) \\<in> dom (finished s) \\<longrightarrow>\n                       (\\<forall>w\\<in>E `` {hd (stack s)}.\n                           \\<delta> s w < counter s))", "apply (intro conjI)"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<lbrakk>(\\<forall>v\\<in>dom (finished s).\n                 \\<delta> s v < \\<phi> s v) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<forall>w\\<in>dom (discovered s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<delta> s v \\<noteq> \\<delta> s w) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>dom (finished s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<phi> s v \\<noteq> \\<phi> s w) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<delta> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<phi> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>E `` {v}. \\<delta> s w < \\<phi> s v);\n     cond s; DFS_invar G param s;\n     DFS_invar G param\n      (finish (hd (stack s)) s\\<lparr>state.more := e_\\<rparr>);\n     stack s \\<noteq> []; pending s `` {hd (stack s)} = {};\n     u_ = hd (stack s);\n     s' = finish (hd (stack s)) s\\<lparr>state.more := e_\\<rparr>\\<rbrakk>\n    \\<Longrightarrow> \\<delta> s (hd (stack s)) < counter s\n 2. \\<lbrakk>(\\<forall>v\\<in>dom (finished s).\n                 \\<delta> s v < \\<phi> s v) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<forall>w\\<in>dom (discovered s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<delta> s v \\<noteq> \\<delta> s w) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>dom (finished s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<phi> s v \\<noteq> \\<phi> s w) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<delta> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<phi> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>E `` {v}. \\<delta> s w < \\<phi> s v);\n     cond s; DFS_invar G param s;\n     DFS_invar G param\n      (finish (hd (stack s)) s\\<lparr>state.more := e_\\<rparr>);\n     stack s \\<noteq> []; pending s `` {hd (stack s)} = {};\n     u_ = hd (stack s);\n     s' = finish (hd (stack s)) s\\<lparr>state.more := e_\\<rparr>\\<rbrakk>\n    \\<Longrightarrow> hd (stack s) \\<in> dom (finished s) \\<longrightarrow>\n                      \\<delta> s (hd (stack s)) < counter s\n 3. \\<lbrakk>(\\<forall>v\\<in>dom (finished s).\n                 \\<delta> s v < \\<phi> s v) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<forall>w\\<in>dom (discovered s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<delta> s v \\<noteq> \\<delta> s w) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>dom (finished s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<phi> s v \\<noteq> \\<phi> s w) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<delta> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<phi> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>E `` {v}. \\<delta> s w < \\<phi> s v);\n     cond s; DFS_invar G param s;\n     DFS_invar G param\n      (finish (hd (stack s)) s\\<lparr>state.more := e_\\<rparr>);\n     stack s \\<noteq> []; pending s `` {hd (stack s)} = {};\n     u_ = hd (stack s);\n     s' = finish (hd (stack s)) s\\<lparr>state.more := e_\\<rparr>\\<rbrakk>\n    \\<Longrightarrow> \\<forall>w\\<in>dom (finished s).\n                         hd (stack s) \\<noteq> w \\<longrightarrow>\n                         counter s \\<noteq> \\<phi> s w\n 4. \\<lbrakk>(\\<forall>v\\<in>dom (finished s).\n                 \\<delta> s v < \\<phi> s v) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<forall>w\\<in>dom (discovered s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<delta> s v \\<noteq> \\<delta> s w) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>dom (finished s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<phi> s v \\<noteq> \\<phi> s w) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<delta> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<phi> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>E `` {v}. \\<delta> s w < \\<phi> s v);\n     cond s; DFS_invar G param s;\n     DFS_invar G param\n      (finish (hd (stack s)) s\\<lparr>state.more := e_\\<rparr>);\n     stack s \\<noteq> []; pending s `` {hd (stack s)} = {};\n     u_ = hd (stack s);\n     s' = finish (hd (stack s)) s\\<lparr>state.more := e_\\<rparr>\\<rbrakk>\n    \\<Longrightarrow> \\<forall>v\\<in>dom (finished s).\n                         (v = hd (stack s) \\<longrightarrow>\n                          (\\<forall>w\\<in>dom (finished s).\n                              hd (stack s) \\<noteq> w \\<longrightarrow>\n                              counter s \\<noteq> \\<phi> s w)) \\<and>\n                         (v \\<noteq> hd (stack s) \\<longrightarrow>\n                          \\<phi> s v \\<noteq> counter s \\<and>\n                          (hd (stack s)\n                           \\<in> dom (finished s) \\<longrightarrow>\n                           \\<phi> s v \\<noteq> counter s))\n 5. \\<lbrakk>(\\<forall>v\\<in>dom (finished s).\n                 \\<delta> s v < \\<phi> s v) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<forall>w\\<in>dom (discovered s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<delta> s v \\<noteq> \\<delta> s w) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>dom (finished s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<phi> s v \\<noteq> \\<phi> s w) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<delta> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<phi> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>E `` {v}. \\<delta> s w < \\<phi> s v);\n     cond s; DFS_invar G param s;\n     DFS_invar G param\n      (finish (hd (stack s)) s\\<lparr>state.more := e_\\<rparr>);\n     stack s \\<noteq> []; pending s `` {hd (stack s)} = {};\n     u_ = hd (stack s);\n     s' = finish (hd (stack s)) s\\<lparr>state.more := e_\\<rparr>\\<rbrakk>\n    \\<Longrightarrow> \\<forall>v\\<in>dom (discovered s).\n                         \\<delta> s v < Suc (counter s)\n 6. \\<lbrakk>(\\<forall>v\\<in>dom (finished s).\n                 \\<delta> s v < \\<phi> s v) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<forall>w\\<in>dom (discovered s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<delta> s v \\<noteq> \\<delta> s w) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>dom (finished s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<phi> s v \\<noteq> \\<phi> s w) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<delta> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<phi> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>E `` {v}. \\<delta> s w < \\<phi> s v);\n     cond s; DFS_invar G param s;\n     DFS_invar G param\n      (finish (hd (stack s)) s\\<lparr>state.more := e_\\<rparr>);\n     stack s \\<noteq> []; pending s `` {hd (stack s)} = {};\n     u_ = hd (stack s);\n     s' = finish (hd (stack s)) s\\<lparr>state.more := e_\\<rparr>\\<rbrakk>\n    \\<Longrightarrow> \\<forall>v\\<in>dom (finished s).\n                         v \\<noteq> hd (stack s) \\<longrightarrow>\n                         \\<phi> s v < Suc (counter s)\n 7. \\<lbrakk>(\\<forall>v\\<in>dom (finished s).\n                 \\<delta> s v < \\<phi> s v) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<forall>w\\<in>dom (discovered s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<delta> s v \\<noteq> \\<delta> s w) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>dom (finished s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<phi> s v \\<noteq> \\<phi> s w) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<delta> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<phi> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>E `` {v}. \\<delta> s w < \\<phi> s v);\n     cond s; DFS_invar G param s;\n     DFS_invar G param\n      (finish (hd (stack s)) s\\<lparr>state.more := e_\\<rparr>);\n     stack s \\<noteq> []; pending s `` {hd (stack s)} = {};\n     u_ = hd (stack s);\n     s' = finish (hd (stack s)) s\\<lparr>state.more := e_\\<rparr>\\<rbrakk>\n    \\<Longrightarrow> \\<forall>w\\<in>E `` {hd (stack s)}.\n                         \\<delta> s w < counter s\n 8. \\<lbrakk>(\\<forall>v\\<in>dom (finished s).\n                 \\<delta> s v < \\<phi> s v) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<forall>w\\<in>dom (discovered s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<delta> s v \\<noteq> \\<delta> s w) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>dom (finished s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<phi> s v \\<noteq> \\<phi> s w) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<delta> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<phi> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>E `` {v}. \\<delta> s w < \\<phi> s v);\n     cond s; DFS_invar G param s;\n     DFS_invar G param\n      (finish (hd (stack s)) s\\<lparr>state.more := e_\\<rparr>);\n     stack s \\<noteq> []; pending s `` {hd (stack s)} = {};\n     u_ = hd (stack s);\n     s' = finish (hd (stack s)) s\\<lparr>state.more := e_\\<rparr>\\<rbrakk>\n    \\<Longrightarrow> hd (stack s) \\<in> dom (finished s) \\<longrightarrow>\n                      (\\<forall>w\\<in>E `` {hd (stack s)}.\n                          \\<delta> s w < counter s)", "using *"], ["proof (prove)\nusing this:\n  hd (stack s) \\<notin> dom (finished s)\n  hd (stack s) \\<in> dom (discovered s)\n\ngoal (8 subgoals):\n 1. \\<lbrakk>(\\<forall>v\\<in>dom (finished s).\n                 \\<delta> s v < \\<phi> s v) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<forall>w\\<in>dom (discovered s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<delta> s v \\<noteq> \\<delta> s w) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>dom (finished s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<phi> s v \\<noteq> \\<phi> s w) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<delta> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<phi> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>E `` {v}. \\<delta> s w < \\<phi> s v);\n     cond s; DFS_invar G param s;\n     DFS_invar G param\n      (finish (hd (stack s)) s\\<lparr>state.more := e_\\<rparr>);\n     stack s \\<noteq> []; pending s `` {hd (stack s)} = {};\n     u_ = hd (stack s);\n     s' = finish (hd (stack s)) s\\<lparr>state.more := e_\\<rparr>\\<rbrakk>\n    \\<Longrightarrow> \\<delta> s (hd (stack s)) < counter s\n 2. \\<lbrakk>(\\<forall>v\\<in>dom (finished s).\n                 \\<delta> s v < \\<phi> s v) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<forall>w\\<in>dom (discovered s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<delta> s v \\<noteq> \\<delta> s w) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>dom (finished s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<phi> s v \\<noteq> \\<phi> s w) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<delta> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<phi> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>E `` {v}. \\<delta> s w < \\<phi> s v);\n     cond s; DFS_invar G param s;\n     DFS_invar G param\n      (finish (hd (stack s)) s\\<lparr>state.more := e_\\<rparr>);\n     stack s \\<noteq> []; pending s `` {hd (stack s)} = {};\n     u_ = hd (stack s);\n     s' = finish (hd (stack s)) s\\<lparr>state.more := e_\\<rparr>\\<rbrakk>\n    \\<Longrightarrow> hd (stack s) \\<in> dom (finished s) \\<longrightarrow>\n                      \\<delta> s (hd (stack s)) < counter s\n 3. \\<lbrakk>(\\<forall>v\\<in>dom (finished s).\n                 \\<delta> s v < \\<phi> s v) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<forall>w\\<in>dom (discovered s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<delta> s v \\<noteq> \\<delta> s w) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>dom (finished s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<phi> s v \\<noteq> \\<phi> s w) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<delta> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<phi> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>E `` {v}. \\<delta> s w < \\<phi> s v);\n     cond s; DFS_invar G param s;\n     DFS_invar G param\n      (finish (hd (stack s)) s\\<lparr>state.more := e_\\<rparr>);\n     stack s \\<noteq> []; pending s `` {hd (stack s)} = {};\n     u_ = hd (stack s);\n     s' = finish (hd (stack s)) s\\<lparr>state.more := e_\\<rparr>\\<rbrakk>\n    \\<Longrightarrow> \\<forall>w\\<in>dom (finished s).\n                         hd (stack s) \\<noteq> w \\<longrightarrow>\n                         counter s \\<noteq> \\<phi> s w\n 4. \\<lbrakk>(\\<forall>v\\<in>dom (finished s).\n                 \\<delta> s v < \\<phi> s v) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<forall>w\\<in>dom (discovered s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<delta> s v \\<noteq> \\<delta> s w) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>dom (finished s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<phi> s v \\<noteq> \\<phi> s w) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<delta> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<phi> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>E `` {v}. \\<delta> s w < \\<phi> s v);\n     cond s; DFS_invar G param s;\n     DFS_invar G param\n      (finish (hd (stack s)) s\\<lparr>state.more := e_\\<rparr>);\n     stack s \\<noteq> []; pending s `` {hd (stack s)} = {};\n     u_ = hd (stack s);\n     s' = finish (hd (stack s)) s\\<lparr>state.more := e_\\<rparr>\\<rbrakk>\n    \\<Longrightarrow> \\<forall>v\\<in>dom (finished s).\n                         (v = hd (stack s) \\<longrightarrow>\n                          (\\<forall>w\\<in>dom (finished s).\n                              hd (stack s) \\<noteq> w \\<longrightarrow>\n                              counter s \\<noteq> \\<phi> s w)) \\<and>\n                         (v \\<noteq> hd (stack s) \\<longrightarrow>\n                          \\<phi> s v \\<noteq> counter s \\<and>\n                          (hd (stack s)\n                           \\<in> dom (finished s) \\<longrightarrow>\n                           \\<phi> s v \\<noteq> counter s))\n 5. \\<lbrakk>(\\<forall>v\\<in>dom (finished s).\n                 \\<delta> s v < \\<phi> s v) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<forall>w\\<in>dom (discovered s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<delta> s v \\<noteq> \\<delta> s w) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>dom (finished s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<phi> s v \\<noteq> \\<phi> s w) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<delta> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<phi> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>E `` {v}. \\<delta> s w < \\<phi> s v);\n     cond s; DFS_invar G param s;\n     DFS_invar G param\n      (finish (hd (stack s)) s\\<lparr>state.more := e_\\<rparr>);\n     stack s \\<noteq> []; pending s `` {hd (stack s)} = {};\n     u_ = hd (stack s);\n     s' = finish (hd (stack s)) s\\<lparr>state.more := e_\\<rparr>\\<rbrakk>\n    \\<Longrightarrow> \\<forall>v\\<in>dom (discovered s).\n                         \\<delta> s v < Suc (counter s)\n 6. \\<lbrakk>(\\<forall>v\\<in>dom (finished s).\n                 \\<delta> s v < \\<phi> s v) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<forall>w\\<in>dom (discovered s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<delta> s v \\<noteq> \\<delta> s w) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>dom (finished s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<phi> s v \\<noteq> \\<phi> s w) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<delta> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<phi> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>E `` {v}. \\<delta> s w < \\<phi> s v);\n     cond s; DFS_invar G param s;\n     DFS_invar G param\n      (finish (hd (stack s)) s\\<lparr>state.more := e_\\<rparr>);\n     stack s \\<noteq> []; pending s `` {hd (stack s)} = {};\n     u_ = hd (stack s);\n     s' = finish (hd (stack s)) s\\<lparr>state.more := e_\\<rparr>\\<rbrakk>\n    \\<Longrightarrow> \\<forall>v\\<in>dom (finished s).\n                         v \\<noteq> hd (stack s) \\<longrightarrow>\n                         \\<phi> s v < Suc (counter s)\n 7. \\<lbrakk>(\\<forall>v\\<in>dom (finished s).\n                 \\<delta> s v < \\<phi> s v) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<forall>w\\<in>dom (discovered s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<delta> s v \\<noteq> \\<delta> s w) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>dom (finished s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<phi> s v \\<noteq> \\<phi> s w) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<delta> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<phi> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>E `` {v}. \\<delta> s w < \\<phi> s v);\n     cond s; DFS_invar G param s;\n     DFS_invar G param\n      (finish (hd (stack s)) s\\<lparr>state.more := e_\\<rparr>);\n     stack s \\<noteq> []; pending s `` {hd (stack s)} = {};\n     u_ = hd (stack s);\n     s' = finish (hd (stack s)) s\\<lparr>state.more := e_\\<rparr>\\<rbrakk>\n    \\<Longrightarrow> \\<forall>w\\<in>E `` {hd (stack s)}.\n                         \\<delta> s w < counter s\n 8. \\<lbrakk>(\\<forall>v\\<in>dom (finished s).\n                 \\<delta> s v < \\<phi> s v) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<forall>w\\<in>dom (discovered s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<delta> s v \\<noteq> \\<delta> s w) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>dom (finished s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<phi> s v \\<noteq> \\<phi> s w) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<delta> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<phi> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>E `` {v}. \\<delta> s w < \\<phi> s v);\n     cond s; DFS_invar G param s;\n     DFS_invar G param\n      (finish (hd (stack s)) s\\<lparr>state.more := e_\\<rparr>);\n     stack s \\<noteq> []; pending s `` {hd (stack s)} = {};\n     u_ = hd (stack s);\n     s' = finish (hd (stack s)) s\\<lparr>state.more := e_\\<rparr>\\<rbrakk>\n    \\<Longrightarrow> hd (stack s) \\<in> dom (finished s) \\<longrightarrow>\n                      (\\<forall>w\\<in>E `` {hd (stack s)}.\n                          \\<delta> s w < counter s)", "apply simp"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<lbrakk>(\\<forall>v\\<in>dom (finished s).\n                 \\<delta> s v < \\<phi> s v) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<forall>w\\<in>dom (discovered s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<delta> s v \\<noteq> \\<delta> s w) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>dom (finished s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<phi> s v \\<noteq> \\<phi> s w) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<delta> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<phi> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>E `` {v}. \\<delta> s w < \\<phi> s v);\n     cond s; DFS_invar G param s;\n     DFS_invar G param\n      (finish (hd (stack s)) s\\<lparr>state.more := e_\\<rparr>);\n     stack s \\<noteq> []; pending s `` {hd (stack s)} = {};\n     u_ = hd (stack s);\n     s' = finish (hd (stack s)) s\\<lparr>state.more := e_\\<rparr>\\<rbrakk>\n    \\<Longrightarrow> hd (stack s) \\<in> dom (finished s) \\<longrightarrow>\n                      \\<delta> s (hd (stack s)) < counter s\n 2. \\<lbrakk>(\\<forall>v\\<in>dom (finished s).\n                 \\<delta> s v < \\<phi> s v) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<forall>w\\<in>dom (discovered s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<delta> s v \\<noteq> \\<delta> s w) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>dom (finished s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<phi> s v \\<noteq> \\<phi> s w) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<delta> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<phi> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>E `` {v}. \\<delta> s w < \\<phi> s v);\n     cond s; DFS_invar G param s;\n     DFS_invar G param\n      (finish (hd (stack s)) s\\<lparr>state.more := e_\\<rparr>);\n     stack s \\<noteq> []; pending s `` {hd (stack s)} = {};\n     u_ = hd (stack s);\n     s' = finish (hd (stack s)) s\\<lparr>state.more := e_\\<rparr>\\<rbrakk>\n    \\<Longrightarrow> \\<forall>w\\<in>dom (finished s).\n                         hd (stack s) \\<noteq> w \\<longrightarrow>\n                         counter s \\<noteq> \\<phi> s w\n 3. \\<lbrakk>(\\<forall>v\\<in>dom (finished s).\n                 \\<delta> s v < \\<phi> s v) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<forall>w\\<in>dom (discovered s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<delta> s v \\<noteq> \\<delta> s w) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>dom (finished s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<phi> s v \\<noteq> \\<phi> s w) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<delta> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<phi> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>E `` {v}. \\<delta> s w < \\<phi> s v);\n     cond s; DFS_invar G param s;\n     DFS_invar G param\n      (finish (hd (stack s)) s\\<lparr>state.more := e_\\<rparr>);\n     stack s \\<noteq> []; pending s `` {hd (stack s)} = {};\n     u_ = hd (stack s);\n     s' = finish (hd (stack s)) s\\<lparr>state.more := e_\\<rparr>\\<rbrakk>\n    \\<Longrightarrow> \\<forall>v\\<in>dom (finished s).\n                         (v = hd (stack s) \\<longrightarrow>\n                          (\\<forall>w\\<in>dom (finished s).\n                              hd (stack s) \\<noteq> w \\<longrightarrow>\n                              counter s \\<noteq> \\<phi> s w)) \\<and>\n                         (v \\<noteq> hd (stack s) \\<longrightarrow>\n                          \\<phi> s v \\<noteq> counter s \\<and>\n                          (hd (stack s)\n                           \\<in> dom (finished s) \\<longrightarrow>\n                           \\<phi> s v \\<noteq> counter s))\n 4. \\<lbrakk>(\\<forall>v\\<in>dom (finished s).\n                 \\<delta> s v < \\<phi> s v) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<forall>w\\<in>dom (discovered s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<delta> s v \\<noteq> \\<delta> s w) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>dom (finished s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<phi> s v \\<noteq> \\<phi> s w) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<delta> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<phi> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>E `` {v}. \\<delta> s w < \\<phi> s v);\n     cond s; DFS_invar G param s;\n     DFS_invar G param\n      (finish (hd (stack s)) s\\<lparr>state.more := e_\\<rparr>);\n     stack s \\<noteq> []; pending s `` {hd (stack s)} = {};\n     u_ = hd (stack s);\n     s' = finish (hd (stack s)) s\\<lparr>state.more := e_\\<rparr>\\<rbrakk>\n    \\<Longrightarrow> \\<forall>v\\<in>dom (discovered s).\n                         \\<delta> s v < Suc (counter s)\n 5. \\<lbrakk>(\\<forall>v\\<in>dom (finished s).\n                 \\<delta> s v < \\<phi> s v) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<forall>w\\<in>dom (discovered s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<delta> s v \\<noteq> \\<delta> s w) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>dom (finished s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<phi> s v \\<noteq> \\<phi> s w) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<delta> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<phi> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>E `` {v}. \\<delta> s w < \\<phi> s v);\n     cond s; DFS_invar G param s;\n     DFS_invar G param\n      (finish (hd (stack s)) s\\<lparr>state.more := e_\\<rparr>);\n     stack s \\<noteq> []; pending s `` {hd (stack s)} = {};\n     u_ = hd (stack s);\n     s' = finish (hd (stack s)) s\\<lparr>state.more := e_\\<rparr>\\<rbrakk>\n    \\<Longrightarrow> \\<forall>v\\<in>dom (finished s).\n                         v \\<noteq> hd (stack s) \\<longrightarrow>\n                         \\<phi> s v < Suc (counter s)\n 6. \\<lbrakk>(\\<forall>v\\<in>dom (finished s).\n                 \\<delta> s v < \\<phi> s v) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<forall>w\\<in>dom (discovered s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<delta> s v \\<noteq> \\<delta> s w) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>dom (finished s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<phi> s v \\<noteq> \\<phi> s w) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<delta> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<phi> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>E `` {v}. \\<delta> s w < \\<phi> s v);\n     cond s; DFS_invar G param s;\n     DFS_invar G param\n      (finish (hd (stack s)) s\\<lparr>state.more := e_\\<rparr>);\n     stack s \\<noteq> []; pending s `` {hd (stack s)} = {};\n     u_ = hd (stack s);\n     s' = finish (hd (stack s)) s\\<lparr>state.more := e_\\<rparr>\\<rbrakk>\n    \\<Longrightarrow> \\<forall>w\\<in>E `` {hd (stack s)}.\n                         \\<delta> s w < counter s\n 7. \\<lbrakk>(\\<forall>v\\<in>dom (finished s).\n                 \\<delta> s v < \\<phi> s v) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<forall>w\\<in>dom (discovered s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<delta> s v \\<noteq> \\<delta> s w) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>dom (finished s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<phi> s v \\<noteq> \\<phi> s w) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<delta> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<phi> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>E `` {v}. \\<delta> s w < \\<phi> s v);\n     cond s; DFS_invar G param s;\n     DFS_invar G param\n      (finish (hd (stack s)) s\\<lparr>state.more := e_\\<rparr>);\n     stack s \\<noteq> []; pending s `` {hd (stack s)} = {};\n     u_ = hd (stack s);\n     s' = finish (hd (stack s)) s\\<lparr>state.more := e_\\<rparr>\\<rbrakk>\n    \\<Longrightarrow> hd (stack s) \\<in> dom (finished s) \\<longrightarrow>\n                      (\\<forall>w\\<in>E `` {hd (stack s)}.\n                          \\<delta> s w < counter s)", "using *"], ["proof (prove)\nusing this:\n  hd (stack s) \\<notin> dom (finished s)\n  hd (stack s) \\<in> dom (discovered s)\n\ngoal (7 subgoals):\n 1. \\<lbrakk>(\\<forall>v\\<in>dom (finished s).\n                 \\<delta> s v < \\<phi> s v) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<forall>w\\<in>dom (discovered s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<delta> s v \\<noteq> \\<delta> s w) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>dom (finished s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<phi> s v \\<noteq> \\<phi> s w) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<delta> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<phi> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>E `` {v}. \\<delta> s w < \\<phi> s v);\n     cond s; DFS_invar G param s;\n     DFS_invar G param\n      (finish (hd (stack s)) s\\<lparr>state.more := e_\\<rparr>);\n     stack s \\<noteq> []; pending s `` {hd (stack s)} = {};\n     u_ = hd (stack s);\n     s' = finish (hd (stack s)) s\\<lparr>state.more := e_\\<rparr>\\<rbrakk>\n    \\<Longrightarrow> hd (stack s) \\<in> dom (finished s) \\<longrightarrow>\n                      \\<delta> s (hd (stack s)) < counter s\n 2. \\<lbrakk>(\\<forall>v\\<in>dom (finished s).\n                 \\<delta> s v < \\<phi> s v) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<forall>w\\<in>dom (discovered s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<delta> s v \\<noteq> \\<delta> s w) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>dom (finished s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<phi> s v \\<noteq> \\<phi> s w) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<delta> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<phi> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>E `` {v}. \\<delta> s w < \\<phi> s v);\n     cond s; DFS_invar G param s;\n     DFS_invar G param\n      (finish (hd (stack s)) s\\<lparr>state.more := e_\\<rparr>);\n     stack s \\<noteq> []; pending s `` {hd (stack s)} = {};\n     u_ = hd (stack s);\n     s' = finish (hd (stack s)) s\\<lparr>state.more := e_\\<rparr>\\<rbrakk>\n    \\<Longrightarrow> \\<forall>w\\<in>dom (finished s).\n                         hd (stack s) \\<noteq> w \\<longrightarrow>\n                         counter s \\<noteq> \\<phi> s w\n 3. \\<lbrakk>(\\<forall>v\\<in>dom (finished s).\n                 \\<delta> s v < \\<phi> s v) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<forall>w\\<in>dom (discovered s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<delta> s v \\<noteq> \\<delta> s w) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>dom (finished s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<phi> s v \\<noteq> \\<phi> s w) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<delta> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<phi> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>E `` {v}. \\<delta> s w < \\<phi> s v);\n     cond s; DFS_invar G param s;\n     DFS_invar G param\n      (finish (hd (stack s)) s\\<lparr>state.more := e_\\<rparr>);\n     stack s \\<noteq> []; pending s `` {hd (stack s)} = {};\n     u_ = hd (stack s);\n     s' = finish (hd (stack s)) s\\<lparr>state.more := e_\\<rparr>\\<rbrakk>\n    \\<Longrightarrow> \\<forall>v\\<in>dom (finished s).\n                         (v = hd (stack s) \\<longrightarrow>\n                          (\\<forall>w\\<in>dom (finished s).\n                              hd (stack s) \\<noteq> w \\<longrightarrow>\n                              counter s \\<noteq> \\<phi> s w)) \\<and>\n                         (v \\<noteq> hd (stack s) \\<longrightarrow>\n                          \\<phi> s v \\<noteq> counter s \\<and>\n                          (hd (stack s)\n                           \\<in> dom (finished s) \\<longrightarrow>\n                           \\<phi> s v \\<noteq> counter s))\n 4. \\<lbrakk>(\\<forall>v\\<in>dom (finished s).\n                 \\<delta> s v < \\<phi> s v) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<forall>w\\<in>dom (discovered s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<delta> s v \\<noteq> \\<delta> s w) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>dom (finished s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<phi> s v \\<noteq> \\<phi> s w) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<delta> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<phi> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>E `` {v}. \\<delta> s w < \\<phi> s v);\n     cond s; DFS_invar G param s;\n     DFS_invar G param\n      (finish (hd (stack s)) s\\<lparr>state.more := e_\\<rparr>);\n     stack s \\<noteq> []; pending s `` {hd (stack s)} = {};\n     u_ = hd (stack s);\n     s' = finish (hd (stack s)) s\\<lparr>state.more := e_\\<rparr>\\<rbrakk>\n    \\<Longrightarrow> \\<forall>v\\<in>dom (discovered s).\n                         \\<delta> s v < Suc (counter s)\n 5. \\<lbrakk>(\\<forall>v\\<in>dom (finished s).\n                 \\<delta> s v < \\<phi> s v) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<forall>w\\<in>dom (discovered s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<delta> s v \\<noteq> \\<delta> s w) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>dom (finished s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<phi> s v \\<noteq> \\<phi> s w) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<delta> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<phi> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>E `` {v}. \\<delta> s w < \\<phi> s v);\n     cond s; DFS_invar G param s;\n     DFS_invar G param\n      (finish (hd (stack s)) s\\<lparr>state.more := e_\\<rparr>);\n     stack s \\<noteq> []; pending s `` {hd (stack s)} = {};\n     u_ = hd (stack s);\n     s' = finish (hd (stack s)) s\\<lparr>state.more := e_\\<rparr>\\<rbrakk>\n    \\<Longrightarrow> \\<forall>v\\<in>dom (finished s).\n                         v \\<noteq> hd (stack s) \\<longrightarrow>\n                         \\<phi> s v < Suc (counter s)\n 6. \\<lbrakk>(\\<forall>v\\<in>dom (finished s).\n                 \\<delta> s v < \\<phi> s v) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<forall>w\\<in>dom (discovered s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<delta> s v \\<noteq> \\<delta> s w) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>dom (finished s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<phi> s v \\<noteq> \\<phi> s w) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<delta> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<phi> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>E `` {v}. \\<delta> s w < \\<phi> s v);\n     cond s; DFS_invar G param s;\n     DFS_invar G param\n      (finish (hd (stack s)) s\\<lparr>state.more := e_\\<rparr>);\n     stack s \\<noteq> []; pending s `` {hd (stack s)} = {};\n     u_ = hd (stack s);\n     s' = finish (hd (stack s)) s\\<lparr>state.more := e_\\<rparr>\\<rbrakk>\n    \\<Longrightarrow> \\<forall>w\\<in>E `` {hd (stack s)}.\n                         \\<delta> s w < counter s\n 7. \\<lbrakk>(\\<forall>v\\<in>dom (finished s).\n                 \\<delta> s v < \\<phi> s v) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<forall>w\\<in>dom (discovered s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<delta> s v \\<noteq> \\<delta> s w) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>dom (finished s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<phi> s v \\<noteq> \\<phi> s w) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<delta> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<phi> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>E `` {v}. \\<delta> s w < \\<phi> s v);\n     cond s; DFS_invar G param s;\n     DFS_invar G param\n      (finish (hd (stack s)) s\\<lparr>state.more := e_\\<rparr>);\n     stack s \\<noteq> []; pending s `` {hd (stack s)} = {};\n     u_ = hd (stack s);\n     s' = finish (hd (stack s)) s\\<lparr>state.more := e_\\<rparr>\\<rbrakk>\n    \\<Longrightarrow> hd (stack s) \\<in> dom (finished s) \\<longrightarrow>\n                      (\\<forall>w\\<in>E `` {hd (stack s)}.\n                          \\<delta> s w < counter s)", "apply simp"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>(\\<forall>v\\<in>dom (finished s).\n                 \\<delta> s v < \\<phi> s v) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<forall>w\\<in>dom (discovered s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<delta> s v \\<noteq> \\<delta> s w) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>dom (finished s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<phi> s v \\<noteq> \\<phi> s w) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<delta> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<phi> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>E `` {v}. \\<delta> s w < \\<phi> s v);\n     cond s; DFS_invar G param s;\n     DFS_invar G param\n      (finish (hd (stack s)) s\\<lparr>state.more := e_\\<rparr>);\n     stack s \\<noteq> []; pending s `` {hd (stack s)} = {};\n     u_ = hd (stack s);\n     s' = finish (hd (stack s)) s\\<lparr>state.more := e_\\<rparr>\\<rbrakk>\n    \\<Longrightarrow> \\<forall>w\\<in>dom (finished s).\n                         hd (stack s) \\<noteq> w \\<longrightarrow>\n                         counter s \\<noteq> \\<phi> s w\n 2. \\<lbrakk>(\\<forall>v\\<in>dom (finished s).\n                 \\<delta> s v < \\<phi> s v) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<forall>w\\<in>dom (discovered s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<delta> s v \\<noteq> \\<delta> s w) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>dom (finished s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<phi> s v \\<noteq> \\<phi> s w) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<delta> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<phi> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>E `` {v}. \\<delta> s w < \\<phi> s v);\n     cond s; DFS_invar G param s;\n     DFS_invar G param\n      (finish (hd (stack s)) s\\<lparr>state.more := e_\\<rparr>);\n     stack s \\<noteq> []; pending s `` {hd (stack s)} = {};\n     u_ = hd (stack s);\n     s' = finish (hd (stack s)) s\\<lparr>state.more := e_\\<rparr>\\<rbrakk>\n    \\<Longrightarrow> \\<forall>v\\<in>dom (finished s).\n                         (v = hd (stack s) \\<longrightarrow>\n                          (\\<forall>w\\<in>dom (finished s).\n                              hd (stack s) \\<noteq> w \\<longrightarrow>\n                              counter s \\<noteq> \\<phi> s w)) \\<and>\n                         (v \\<noteq> hd (stack s) \\<longrightarrow>\n                          \\<phi> s v \\<noteq> counter s \\<and>\n                          (hd (stack s)\n                           \\<in> dom (finished s) \\<longrightarrow>\n                           \\<phi> s v \\<noteq> counter s))\n 3. \\<lbrakk>(\\<forall>v\\<in>dom (finished s).\n                 \\<delta> s v < \\<phi> s v) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<forall>w\\<in>dom (discovered s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<delta> s v \\<noteq> \\<delta> s w) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>dom (finished s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<phi> s v \\<noteq> \\<phi> s w) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<delta> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<phi> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>E `` {v}. \\<delta> s w < \\<phi> s v);\n     cond s; DFS_invar G param s;\n     DFS_invar G param\n      (finish (hd (stack s)) s\\<lparr>state.more := e_\\<rparr>);\n     stack s \\<noteq> []; pending s `` {hd (stack s)} = {};\n     u_ = hd (stack s);\n     s' = finish (hd (stack s)) s\\<lparr>state.more := e_\\<rparr>\\<rbrakk>\n    \\<Longrightarrow> \\<forall>v\\<in>dom (discovered s).\n                         \\<delta> s v < Suc (counter s)\n 4. \\<lbrakk>(\\<forall>v\\<in>dom (finished s).\n                 \\<delta> s v < \\<phi> s v) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<forall>w\\<in>dom (discovered s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<delta> s v \\<noteq> \\<delta> s w) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>dom (finished s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<phi> s v \\<noteq> \\<phi> s w) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<delta> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<phi> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>E `` {v}. \\<delta> s w < \\<phi> s v);\n     cond s; DFS_invar G param s;\n     DFS_invar G param\n      (finish (hd (stack s)) s\\<lparr>state.more := e_\\<rparr>);\n     stack s \\<noteq> []; pending s `` {hd (stack s)} = {};\n     u_ = hd (stack s);\n     s' = finish (hd (stack s)) s\\<lparr>state.more := e_\\<rparr>\\<rbrakk>\n    \\<Longrightarrow> \\<forall>v\\<in>dom (finished s).\n                         v \\<noteq> hd (stack s) \\<longrightarrow>\n                         \\<phi> s v < Suc (counter s)\n 5. \\<lbrakk>(\\<forall>v\\<in>dom (finished s).\n                 \\<delta> s v < \\<phi> s v) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<forall>w\\<in>dom (discovered s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<delta> s v \\<noteq> \\<delta> s w) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>dom (finished s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<phi> s v \\<noteq> \\<phi> s w) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<delta> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<phi> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>E `` {v}. \\<delta> s w < \\<phi> s v);\n     cond s; DFS_invar G param s;\n     DFS_invar G param\n      (finish (hd (stack s)) s\\<lparr>state.more := e_\\<rparr>);\n     stack s \\<noteq> []; pending s `` {hd (stack s)} = {};\n     u_ = hd (stack s);\n     s' = finish (hd (stack s)) s\\<lparr>state.more := e_\\<rparr>\\<rbrakk>\n    \\<Longrightarrow> \\<forall>w\\<in>E `` {hd (stack s)}.\n                         \\<delta> s w < counter s\n 6. \\<lbrakk>(\\<forall>v\\<in>dom (finished s).\n                 \\<delta> s v < \\<phi> s v) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<forall>w\\<in>dom (discovered s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<delta> s v \\<noteq> \\<delta> s w) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>dom (finished s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<phi> s v \\<noteq> \\<phi> s w) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<delta> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<phi> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>E `` {v}. \\<delta> s w < \\<phi> s v);\n     cond s; DFS_invar G param s;\n     DFS_invar G param\n      (finish (hd (stack s)) s\\<lparr>state.more := e_\\<rparr>);\n     stack s \\<noteq> []; pending s `` {hd (stack s)} = {};\n     u_ = hd (stack s);\n     s' = finish (hd (stack s)) s\\<lparr>state.more := e_\\<rparr>\\<rbrakk>\n    \\<Longrightarrow> hd (stack s) \\<in> dom (finished s) \\<longrightarrow>\n                      (\\<forall>w\\<in>E `` {hd (stack s)}.\n                          \\<delta> s w < counter s)", "apply (metis less_irrefl)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>(\\<forall>v\\<in>dom (finished s).\n                 \\<delta> s v < \\<phi> s v) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<forall>w\\<in>dom (discovered s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<delta> s v \\<noteq> \\<delta> s w) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>dom (finished s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<phi> s v \\<noteq> \\<phi> s w) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<delta> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<phi> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>E `` {v}. \\<delta> s w < \\<phi> s v);\n     cond s; DFS_invar G param s;\n     DFS_invar G param\n      (finish (hd (stack s)) s\\<lparr>state.more := e_\\<rparr>);\n     stack s \\<noteq> []; pending s `` {hd (stack s)} = {};\n     u_ = hd (stack s);\n     s' = finish (hd (stack s)) s\\<lparr>state.more := e_\\<rparr>\\<rbrakk>\n    \\<Longrightarrow> \\<forall>v\\<in>dom (finished s).\n                         (v = hd (stack s) \\<longrightarrow>\n                          (\\<forall>w\\<in>dom (finished s).\n                              hd (stack s) \\<noteq> w \\<longrightarrow>\n                              counter s \\<noteq> \\<phi> s w)) \\<and>\n                         (v \\<noteq> hd (stack s) \\<longrightarrow>\n                          \\<phi> s v \\<noteq> counter s \\<and>\n                          (hd (stack s)\n                           \\<in> dom (finished s) \\<longrightarrow>\n                           \\<phi> s v \\<noteq> counter s))\n 2. \\<lbrakk>(\\<forall>v\\<in>dom (finished s).\n                 \\<delta> s v < \\<phi> s v) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<forall>w\\<in>dom (discovered s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<delta> s v \\<noteq> \\<delta> s w) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>dom (finished s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<phi> s v \\<noteq> \\<phi> s w) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<delta> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<phi> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>E `` {v}. \\<delta> s w < \\<phi> s v);\n     cond s; DFS_invar G param s;\n     DFS_invar G param\n      (finish (hd (stack s)) s\\<lparr>state.more := e_\\<rparr>);\n     stack s \\<noteq> []; pending s `` {hd (stack s)} = {};\n     u_ = hd (stack s);\n     s' = finish (hd (stack s)) s\\<lparr>state.more := e_\\<rparr>\\<rbrakk>\n    \\<Longrightarrow> \\<forall>v\\<in>dom (discovered s).\n                         \\<delta> s v < Suc (counter s)\n 3. \\<lbrakk>(\\<forall>v\\<in>dom (finished s).\n                 \\<delta> s v < \\<phi> s v) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<forall>w\\<in>dom (discovered s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<delta> s v \\<noteq> \\<delta> s w) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>dom (finished s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<phi> s v \\<noteq> \\<phi> s w) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<delta> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<phi> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>E `` {v}. \\<delta> s w < \\<phi> s v);\n     cond s; DFS_invar G param s;\n     DFS_invar G param\n      (finish (hd (stack s)) s\\<lparr>state.more := e_\\<rparr>);\n     stack s \\<noteq> []; pending s `` {hd (stack s)} = {};\n     u_ = hd (stack s);\n     s' = finish (hd (stack s)) s\\<lparr>state.more := e_\\<rparr>\\<rbrakk>\n    \\<Longrightarrow> \\<forall>v\\<in>dom (finished s).\n                         v \\<noteq> hd (stack s) \\<longrightarrow>\n                         \\<phi> s v < Suc (counter s)\n 4. \\<lbrakk>(\\<forall>v\\<in>dom (finished s).\n                 \\<delta> s v < \\<phi> s v) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<forall>w\\<in>dom (discovered s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<delta> s v \\<noteq> \\<delta> s w) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>dom (finished s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<phi> s v \\<noteq> \\<phi> s w) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<delta> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<phi> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>E `` {v}. \\<delta> s w < \\<phi> s v);\n     cond s; DFS_invar G param s;\n     DFS_invar G param\n      (finish (hd (stack s)) s\\<lparr>state.more := e_\\<rparr>);\n     stack s \\<noteq> []; pending s `` {hd (stack s)} = {};\n     u_ = hd (stack s);\n     s' = finish (hd (stack s)) s\\<lparr>state.more := e_\\<rparr>\\<rbrakk>\n    \\<Longrightarrow> \\<forall>w\\<in>E `` {hd (stack s)}.\n                         \\<delta> s w < counter s\n 5. \\<lbrakk>(\\<forall>v\\<in>dom (finished s).\n                 \\<delta> s v < \\<phi> s v) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<forall>w\\<in>dom (discovered s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<delta> s v \\<noteq> \\<delta> s w) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>dom (finished s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<phi> s v \\<noteq> \\<phi> s w) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<delta> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<phi> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>E `` {v}. \\<delta> s w < \\<phi> s v);\n     cond s; DFS_invar G param s;\n     DFS_invar G param\n      (finish (hd (stack s)) s\\<lparr>state.more := e_\\<rparr>);\n     stack s \\<noteq> []; pending s `` {hd (stack s)} = {};\n     u_ = hd (stack s);\n     s' = finish (hd (stack s)) s\\<lparr>state.more := e_\\<rparr>\\<rbrakk>\n    \\<Longrightarrow> hd (stack s) \\<in> dom (finished s) \\<longrightarrow>\n                      (\\<forall>w\\<in>E `` {hd (stack s)}.\n                          \\<delta> s w < counter s)", "apply (metis less_irrefl)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>(\\<forall>v\\<in>dom (finished s).\n                 \\<delta> s v < \\<phi> s v) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<forall>w\\<in>dom (discovered s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<delta> s v \\<noteq> \\<delta> s w) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>dom (finished s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<phi> s v \\<noteq> \\<phi> s w) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<delta> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<phi> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>E `` {v}. \\<delta> s w < \\<phi> s v);\n     cond s; DFS_invar G param s;\n     DFS_invar G param\n      (finish (hd (stack s)) s\\<lparr>state.more := e_\\<rparr>);\n     stack s \\<noteq> []; pending s `` {hd (stack s)} = {};\n     u_ = hd (stack s);\n     s' = finish (hd (stack s)) s\\<lparr>state.more := e_\\<rparr>\\<rbrakk>\n    \\<Longrightarrow> \\<forall>v\\<in>dom (discovered s).\n                         \\<delta> s v < Suc (counter s)\n 2. \\<lbrakk>(\\<forall>v\\<in>dom (finished s).\n                 \\<delta> s v < \\<phi> s v) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<forall>w\\<in>dom (discovered s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<delta> s v \\<noteq> \\<delta> s w) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>dom (finished s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<phi> s v \\<noteq> \\<phi> s w) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<delta> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<phi> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>E `` {v}. \\<delta> s w < \\<phi> s v);\n     cond s; DFS_invar G param s;\n     DFS_invar G param\n      (finish (hd (stack s)) s\\<lparr>state.more := e_\\<rparr>);\n     stack s \\<noteq> []; pending s `` {hd (stack s)} = {};\n     u_ = hd (stack s);\n     s' = finish (hd (stack s)) s\\<lparr>state.more := e_\\<rparr>\\<rbrakk>\n    \\<Longrightarrow> \\<forall>v\\<in>dom (finished s).\n                         v \\<noteq> hd (stack s) \\<longrightarrow>\n                         \\<phi> s v < Suc (counter s)\n 3. \\<lbrakk>(\\<forall>v\\<in>dom (finished s).\n                 \\<delta> s v < \\<phi> s v) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<forall>w\\<in>dom (discovered s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<delta> s v \\<noteq> \\<delta> s w) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>dom (finished s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<phi> s v \\<noteq> \\<phi> s w) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<delta> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<phi> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>E `` {v}. \\<delta> s w < \\<phi> s v);\n     cond s; DFS_invar G param s;\n     DFS_invar G param\n      (finish (hd (stack s)) s\\<lparr>state.more := e_\\<rparr>);\n     stack s \\<noteq> []; pending s `` {hd (stack s)} = {};\n     u_ = hd (stack s);\n     s' = finish (hd (stack s)) s\\<lparr>state.more := e_\\<rparr>\\<rbrakk>\n    \\<Longrightarrow> \\<forall>w\\<in>E `` {hd (stack s)}.\n                         \\<delta> s w < counter s\n 4. \\<lbrakk>(\\<forall>v\\<in>dom (finished s).\n                 \\<delta> s v < \\<phi> s v) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<forall>w\\<in>dom (discovered s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<delta> s v \\<noteq> \\<delta> s w) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>dom (finished s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<phi> s v \\<noteq> \\<phi> s w) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<delta> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<phi> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>E `` {v}. \\<delta> s w < \\<phi> s v);\n     cond s; DFS_invar G param s;\n     DFS_invar G param\n      (finish (hd (stack s)) s\\<lparr>state.more := e_\\<rparr>);\n     stack s \\<noteq> []; pending s `` {hd (stack s)} = {};\n     u_ = hd (stack s);\n     s' = finish (hd (stack s)) s\\<lparr>state.more := e_\\<rparr>\\<rbrakk>\n    \\<Longrightarrow> hd (stack s) \\<in> dom (finished s) \\<longrightarrow>\n                      (\\<forall>w\\<in>E `` {hd (stack s)}.\n                          \\<delta> s w < counter s)", "apply (metis less_SucI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>(\\<forall>v\\<in>dom (finished s).\n                 \\<delta> s v < \\<phi> s v) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<forall>w\\<in>dom (discovered s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<delta> s v \\<noteq> \\<delta> s w) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>dom (finished s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<phi> s v \\<noteq> \\<phi> s w) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<delta> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<phi> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>E `` {v}. \\<delta> s w < \\<phi> s v);\n     cond s; DFS_invar G param s;\n     DFS_invar G param\n      (finish (hd (stack s)) s\\<lparr>state.more := e_\\<rparr>);\n     stack s \\<noteq> []; pending s `` {hd (stack s)} = {};\n     u_ = hd (stack s);\n     s' = finish (hd (stack s)) s\\<lparr>state.more := e_\\<rparr>\\<rbrakk>\n    \\<Longrightarrow> \\<forall>v\\<in>dom (finished s).\n                         v \\<noteq> hd (stack s) \\<longrightarrow>\n                         \\<phi> s v < Suc (counter s)\n 2. \\<lbrakk>(\\<forall>v\\<in>dom (finished s).\n                 \\<delta> s v < \\<phi> s v) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<forall>w\\<in>dom (discovered s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<delta> s v \\<noteq> \\<delta> s w) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>dom (finished s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<phi> s v \\<noteq> \\<phi> s w) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<delta> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<phi> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>E `` {v}. \\<delta> s w < \\<phi> s v);\n     cond s; DFS_invar G param s;\n     DFS_invar G param\n      (finish (hd (stack s)) s\\<lparr>state.more := e_\\<rparr>);\n     stack s \\<noteq> []; pending s `` {hd (stack s)} = {};\n     u_ = hd (stack s);\n     s' = finish (hd (stack s)) s\\<lparr>state.more := e_\\<rparr>\\<rbrakk>\n    \\<Longrightarrow> \\<forall>w\\<in>E `` {hd (stack s)}.\n                         \\<delta> s w < counter s\n 3. \\<lbrakk>(\\<forall>v\\<in>dom (finished s).\n                 \\<delta> s v < \\<phi> s v) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<forall>w\\<in>dom (discovered s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<delta> s v \\<noteq> \\<delta> s w) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>dom (finished s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<phi> s v \\<noteq> \\<phi> s w) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<delta> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<phi> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>E `` {v}. \\<delta> s w < \\<phi> s v);\n     cond s; DFS_invar G param s;\n     DFS_invar G param\n      (finish (hd (stack s)) s\\<lparr>state.more := e_\\<rparr>);\n     stack s \\<noteq> []; pending s `` {hd (stack s)} = {};\n     u_ = hd (stack s);\n     s' = finish (hd (stack s)) s\\<lparr>state.more := e_\\<rparr>\\<rbrakk>\n    \\<Longrightarrow> hd (stack s) \\<in> dom (finished s) \\<longrightarrow>\n                      (\\<forall>w\\<in>E `` {hd (stack s)}.\n                          \\<delta> s w < counter s)", "apply (metis less_SucI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>(\\<forall>v\\<in>dom (finished s).\n                 \\<delta> s v < \\<phi> s v) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<forall>w\\<in>dom (discovered s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<delta> s v \\<noteq> \\<delta> s w) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>dom (finished s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<phi> s v \\<noteq> \\<phi> s w) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<delta> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<phi> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>E `` {v}. \\<delta> s w < \\<phi> s v);\n     cond s; DFS_invar G param s;\n     DFS_invar G param\n      (finish (hd (stack s)) s\\<lparr>state.more := e_\\<rparr>);\n     stack s \\<noteq> []; pending s `` {hd (stack s)} = {};\n     u_ = hd (stack s);\n     s' = finish (hd (stack s)) s\\<lparr>state.more := e_\\<rparr>\\<rbrakk>\n    \\<Longrightarrow> \\<forall>w\\<in>E `` {hd (stack s)}.\n                         \\<delta> s w < counter s\n 2. \\<lbrakk>(\\<forall>v\\<in>dom (finished s).\n                 \\<delta> s v < \\<phi> s v) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<forall>w\\<in>dom (discovered s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<delta> s v \\<noteq> \\<delta> s w) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>dom (finished s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<phi> s v \\<noteq> \\<phi> s w) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<delta> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<phi> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>E `` {v}. \\<delta> s w < \\<phi> s v);\n     cond s; DFS_invar G param s;\n     DFS_invar G param\n      (finish (hd (stack s)) s\\<lparr>state.more := e_\\<rparr>);\n     stack s \\<noteq> []; pending s `` {hd (stack s)} = {};\n     u_ = hd (stack s);\n     s' = finish (hd (stack s)) s\\<lparr>state.more := e_\\<rparr>\\<rbrakk>\n    \\<Longrightarrow> hd (stack s) \\<in> dom (finished s) \\<longrightarrow>\n                      (\\<forall>w\\<in>E `` {hd (stack s)}.\n                          \\<delta> s w < counter s)", "apply (blast dest!: succ_hd)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<forall>v\\<in>dom (finished s).\n                 \\<delta> s v < \\<phi> s v) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<forall>w\\<in>dom (discovered s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<delta> s v \\<noteq> \\<delta> s w) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>dom (finished s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<phi> s v \\<noteq> \\<phi> s w) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<delta> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<phi> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>E `` {v}. \\<delta> s w < \\<phi> s v);\n     cond s; DFS_invar G param s;\n     DFS_invar G param\n      (finish (hd (stack s)) s\\<lparr>state.more := e_\\<rparr>);\n     stack s \\<noteq> []; pending s `` {hd (stack s)} = {};\n     u_ = hd (stack s);\n     s' = finish (hd (stack s)) s\\<lparr>state.more := e_\\<rparr>\\<rbrakk>\n    \\<Longrightarrow> hd (stack s) \\<in> dom (finished s) \\<longrightarrow>\n                      (\\<forall>w\\<in>E `` {hd (stack s)}.\n                          \\<delta> s w < counter s)", "using *"], ["proof (prove)\nusing this:\n  hd (stack s) \\<notin> dom (finished s)\n  hd (stack s) \\<in> dom (discovered s)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<forall>v\\<in>dom (finished s).\n                 \\<delta> s v < \\<phi> s v) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<forall>w\\<in>dom (discovered s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<delta> s v \\<noteq> \\<delta> s w) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>dom (finished s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<phi> s v \\<noteq> \\<phi> s w) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<delta> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<phi> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>E `` {v}. \\<delta> s w < \\<phi> s v);\n     cond s; DFS_invar G param s;\n     DFS_invar G param\n      (finish (hd (stack s)) s\\<lparr>state.more := e_\\<rparr>);\n     stack s \\<noteq> []; pending s `` {hd (stack s)} = {};\n     u_ = hd (stack s);\n     s' = finish (hd (stack s)) s\\<lparr>state.more := e_\\<rparr>\\<rbrakk>\n    \\<Longrightarrow> hd (stack s) \\<in> dom (finished s) \\<longrightarrow>\n                      (\\<forall>w\\<in>E `` {hd (stack s)}.\n                          \\<delta> s w < counter s)", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  timing_common_inv s'\n\ngoal (4 subgoals):\n 1. \\<And>e. timing_common_inv (empty_state e)\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>timing_common_inv s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s = []; v0 \\<notin> dom (discovered s);\n        v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> timing_common_inv s'\n 3. \\<And>s s' u v e c b.\n       \\<lbrakk>timing_common_inv s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); u = hd (stack s);\n        cross_edges s \\<subseteq> c; back_edges s \\<subseteq> b;\n        s' = s\n        \\<lparr>pending := pending s - {(u, v)}, state.more := e,\n           cross_edges := c, back_edges := b\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> timing_common_inv s'\n 4. \\<And>s s' u v e.\n       \\<lbrakk>timing_common_inv s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> timing_common_inv s'", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>e. timing_common_inv (empty_state e)\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>timing_common_inv s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s = []; v0 \\<notin> dom (discovered s);\n        v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> timing_common_inv s'\n 3. \\<And>s s' u v e c b.\n       \\<lbrakk>timing_common_inv s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); u = hd (stack s);\n        cross_edges s \\<subseteq> c; back_edges s \\<subseteq> b;\n        s' = s\n        \\<lparr>pending := pending s - {(u, v)}, state.more := e,\n           cross_edges := c, back_edges := b\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> timing_common_inv s'\n 4. \\<And>s s' u v e.\n       \\<lbrakk>timing_common_inv s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> timing_common_inv s'", "case (discover s)"], ["proof (state)\nthis:\n  timing_common_inv s\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'_\n  s'_ = discover u_ v_ (s\\<lparr>pending := pending s - {(u_, v_)}\\<rparr>)\n  \\<lparr>state.more := e_\\<rparr>\n  stack s \\<noteq> []\n  v_ \\<in> pending s `` {u_}\n  v_ \\<notin> dom (discovered s)\n  u_ = hd (stack s)\n\ngoal (4 subgoals):\n 1. \\<And>e. timing_common_inv (empty_state e)\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>timing_common_inv s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s = []; v0 \\<notin> dom (discovered s);\n        v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> timing_common_inv s'\n 3. \\<And>s s' u v e c b.\n       \\<lbrakk>timing_common_inv s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); u = hd (stack s);\n        cross_edges s \\<subseteq> c; back_edges s \\<subseteq> b;\n        s' = s\n        \\<lparr>pending := pending s - {(u, v)}, state.more := e,\n           cross_edges := c, back_edges := b\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> timing_common_inv s'\n 4. \\<And>s s' u v e.\n       \\<lbrakk>timing_common_inv s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> timing_common_inv s'", "then"], ["proof (chain)\npicking this:\n  timing_common_inv s\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'_\n  s'_ = discover u_ v_ (s\\<lparr>pending := pending s - {(u_, v_)}\\<rparr>)\n  \\<lparr>state.more := e_\\<rparr>\n  stack s \\<noteq> []\n  v_ \\<in> pending s `` {u_}\n  v_ \\<notin> dom (discovered s)\n  u_ = hd (stack s)", "interpret DFS_invar where s=s"], ["proof (prove)\nusing this:\n  timing_common_inv s\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'_\n  s'_ = discover u_ v_ (s\\<lparr>pending := pending s - {(u_, v_)}\\<rparr>)\n  \\<lparr>state.more := e_\\<rparr>\n  stack s \\<noteq> []\n  v_ \\<in> pending s `` {u_}\n  v_ \\<notin> dom (discovered s)\n  u_ = hd (stack s)\n\ngoal (1 subgoal):\n 1. DFS_invar G param s", "by simp"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>e. timing_common_inv (empty_state e)\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>timing_common_inv s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s = []; v0 \\<notin> dom (discovered s);\n        v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> timing_common_inv s'\n 3. \\<And>s s' u v e c b.\n       \\<lbrakk>timing_common_inv s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); u = hd (stack s);\n        cross_edges s \\<subseteq> c; back_edges s \\<subseteq> b;\n        s' = s\n        \\<lparr>pending := pending s - {(u, v)}, state.more := e,\n           cross_edges := c, back_edges := b\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> timing_common_inv s'\n 4. \\<And>s s' u v e.\n       \\<lbrakk>timing_common_inv s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> timing_common_inv s'", "from discover"], ["proof (chain)\npicking this:\n  timing_common_inv s\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'_\n  s'_ = discover u_ v_ (s\\<lparr>pending := pending s - {(u_, v_)}\\<rparr>)\n  \\<lparr>state.more := e_\\<rparr>\n  stack s \\<noteq> []\n  v_ \\<in> pending s `` {u_}\n  v_ \\<notin> dom (discovered s)\n  u_ = hd (stack s)", "show ?case"], ["proof (prove)\nusing this:\n  timing_common_inv s\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'_\n  s'_ = discover u_ v_ (s\\<lparr>pending := pending s - {(u_, v_)}\\<rparr>)\n  \\<lparr>state.more := e_\\<rparr>\n  stack s \\<noteq> []\n  v_ \\<in> pending s `` {u_}\n  v_ \\<notin> dom (discovered s)\n  u_ = hd (stack s)\n\ngoal (1 subgoal):\n 1. timing_common_inv s'_", "apply (simp add: timing_common_inv_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<forall>v\\<in>dom (finished s).\n                 \\<delta> s v < \\<phi> s v) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<forall>w\\<in>dom (discovered s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<delta> s v \\<noteq> \\<delta> s w) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>dom (finished s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<phi> s v \\<noteq> \\<phi> s w) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<delta> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<phi> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>E `` {v}. \\<delta> s w < \\<phi> s v);\n     cond s; DFS_invar G param s;\n     DFS_invar G param\n      (discover (hd (stack s)) v_\n        (s\\<lparr>pending := pending s - {(hd (stack s), v_)}\\<rparr>)\n       \\<lparr>state.more := e_\\<rparr>);\n     s'_ =\n     discover (hd (stack s)) v_\n      (s\\<lparr>pending := pending s - {(hd (stack s), v_)}\\<rparr>)\n     \\<lparr>state.more := e_\\<rparr>;\n     stack s \\<noteq> []; (hd (stack s), v_) \\<in> pending s;\n     v_ \\<notin> dom (discovered s); u_ = hd (stack s)\\<rbrakk>\n    \\<Longrightarrow> (v_ \\<in> dom (finished s) \\<longrightarrow>\n                       counter s < \\<phi> s v_) \\<and>\n                      (\\<forall>w\\<in>dom (discovered s).\n                          v_ \\<noteq> w \\<longrightarrow>\n                          counter s \\<noteq> \\<delta> s w) \\<and>\n                      (\\<forall>va\\<in>dom (discovered s).\n                          (va = v_ \\<longrightarrow>\n                           (\\<forall>w\\<in>dom (discovered s).\n                               v_ \\<noteq> w \\<longrightarrow>\n                               counter s \\<noteq> \\<delta> s w)) \\<and>\n                          (va \\<noteq> v_ \\<longrightarrow>\n                           \\<delta> s va \\<noteq> counter s)) \\<and>\n                      (\\<forall>va\\<in>dom (discovered s).\n                          va \\<noteq> v_ \\<longrightarrow>\n                          \\<delta> s va < Suc (counter s)) \\<and>\n                      (\\<forall>v\\<in>dom (finished s).\n                          \\<phi> s v < Suc (counter s)) \\<and>\n                      (\\<forall>va\\<in>dom (finished s).\n                          (va, v_) \\<in> E \\<longrightarrow>\n                          counter s < \\<phi> s va)", "apply (intro conjI)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>(\\<forall>v\\<in>dom (finished s).\n                 \\<delta> s v < \\<phi> s v) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<forall>w\\<in>dom (discovered s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<delta> s v \\<noteq> \\<delta> s w) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>dom (finished s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<phi> s v \\<noteq> \\<phi> s w) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<delta> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<phi> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>E `` {v}. \\<delta> s w < \\<phi> s v);\n     cond s; DFS_invar G param s;\n     DFS_invar G param\n      (discover (hd (stack s)) v_\n        (s\\<lparr>pending := pending s - {(hd (stack s), v_)}\\<rparr>)\n       \\<lparr>state.more := e_\\<rparr>);\n     s'_ =\n     discover (hd (stack s)) v_\n      (s\\<lparr>pending := pending s - {(hd (stack s), v_)}\\<rparr>)\n     \\<lparr>state.more := e_\\<rparr>;\n     stack s \\<noteq> []; (hd (stack s), v_) \\<in> pending s;\n     v_ \\<notin> dom (discovered s); u_ = hd (stack s)\\<rbrakk>\n    \\<Longrightarrow> v_ \\<in> dom (finished s) \\<longrightarrow>\n                      counter s < \\<phi> s v_\n 2. \\<lbrakk>(\\<forall>v\\<in>dom (finished s).\n                 \\<delta> s v < \\<phi> s v) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<forall>w\\<in>dom (discovered s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<delta> s v \\<noteq> \\<delta> s w) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>dom (finished s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<phi> s v \\<noteq> \\<phi> s w) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<delta> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<phi> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>E `` {v}. \\<delta> s w < \\<phi> s v);\n     cond s; DFS_invar G param s;\n     DFS_invar G param\n      (discover (hd (stack s)) v_\n        (s\\<lparr>pending := pending s - {(hd (stack s), v_)}\\<rparr>)\n       \\<lparr>state.more := e_\\<rparr>);\n     s'_ =\n     discover (hd (stack s)) v_\n      (s\\<lparr>pending := pending s - {(hd (stack s), v_)}\\<rparr>)\n     \\<lparr>state.more := e_\\<rparr>;\n     stack s \\<noteq> []; (hd (stack s), v_) \\<in> pending s;\n     v_ \\<notin> dom (discovered s); u_ = hd (stack s)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>w\\<in>dom (discovered s).\n                         v_ \\<noteq> w \\<longrightarrow>\n                         counter s \\<noteq> \\<delta> s w\n 3. \\<lbrakk>(\\<forall>v\\<in>dom (finished s).\n                 \\<delta> s v < \\<phi> s v) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<forall>w\\<in>dom (discovered s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<delta> s v \\<noteq> \\<delta> s w) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>dom (finished s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<phi> s v \\<noteq> \\<phi> s w) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<delta> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<phi> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>E `` {v}. \\<delta> s w < \\<phi> s v);\n     cond s; DFS_invar G param s;\n     DFS_invar G param\n      (discover (hd (stack s)) v_\n        (s\\<lparr>pending := pending s - {(hd (stack s), v_)}\\<rparr>)\n       \\<lparr>state.more := e_\\<rparr>);\n     s'_ =\n     discover (hd (stack s)) v_\n      (s\\<lparr>pending := pending s - {(hd (stack s), v_)}\\<rparr>)\n     \\<lparr>state.more := e_\\<rparr>;\n     stack s \\<noteq> []; (hd (stack s), v_) \\<in> pending s;\n     v_ \\<notin> dom (discovered s); u_ = hd (stack s)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>va\\<in>dom (discovered s).\n                         (va = v_ \\<longrightarrow>\n                          (\\<forall>w\\<in>dom (discovered s).\n                              v_ \\<noteq> w \\<longrightarrow>\n                              counter s \\<noteq> \\<delta> s w)) \\<and>\n                         (va \\<noteq> v_ \\<longrightarrow>\n                          \\<delta> s va \\<noteq> counter s)\n 4. \\<lbrakk>(\\<forall>v\\<in>dom (finished s).\n                 \\<delta> s v < \\<phi> s v) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<forall>w\\<in>dom (discovered s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<delta> s v \\<noteq> \\<delta> s w) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>dom (finished s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<phi> s v \\<noteq> \\<phi> s w) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<delta> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<phi> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>E `` {v}. \\<delta> s w < \\<phi> s v);\n     cond s; DFS_invar G param s;\n     DFS_invar G param\n      (discover (hd (stack s)) v_\n        (s\\<lparr>pending := pending s - {(hd (stack s), v_)}\\<rparr>)\n       \\<lparr>state.more := e_\\<rparr>);\n     s'_ =\n     discover (hd (stack s)) v_\n      (s\\<lparr>pending := pending s - {(hd (stack s), v_)}\\<rparr>)\n     \\<lparr>state.more := e_\\<rparr>;\n     stack s \\<noteq> []; (hd (stack s), v_) \\<in> pending s;\n     v_ \\<notin> dom (discovered s); u_ = hd (stack s)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>va\\<in>dom (discovered s).\n                         va \\<noteq> v_ \\<longrightarrow>\n                         \\<delta> s va < Suc (counter s)\n 5. \\<lbrakk>(\\<forall>v\\<in>dom (finished s).\n                 \\<delta> s v < \\<phi> s v) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<forall>w\\<in>dom (discovered s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<delta> s v \\<noteq> \\<delta> s w) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>dom (finished s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<phi> s v \\<noteq> \\<phi> s w) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<delta> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<phi> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>E `` {v}. \\<delta> s w < \\<phi> s v);\n     cond s; DFS_invar G param s;\n     DFS_invar G param\n      (discover (hd (stack s)) v_\n        (s\\<lparr>pending := pending s - {(hd (stack s), v_)}\\<rparr>)\n       \\<lparr>state.more := e_\\<rparr>);\n     s'_ =\n     discover (hd (stack s)) v_\n      (s\\<lparr>pending := pending s - {(hd (stack s), v_)}\\<rparr>)\n     \\<lparr>state.more := e_\\<rparr>;\n     stack s \\<noteq> []; (hd (stack s), v_) \\<in> pending s;\n     v_ \\<notin> dom (discovered s); u_ = hd (stack s)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>v\\<in>dom (finished s).\n                         \\<phi> s v < Suc (counter s)\n 6. \\<lbrakk>(\\<forall>v\\<in>dom (finished s).\n                 \\<delta> s v < \\<phi> s v) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<forall>w\\<in>dom (discovered s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<delta> s v \\<noteq> \\<delta> s w) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>dom (finished s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<phi> s v \\<noteq> \\<phi> s w) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<delta> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<phi> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>E `` {v}. \\<delta> s w < \\<phi> s v);\n     cond s; DFS_invar G param s;\n     DFS_invar G param\n      (discover (hd (stack s)) v_\n        (s\\<lparr>pending := pending s - {(hd (stack s), v_)}\\<rparr>)\n       \\<lparr>state.more := e_\\<rparr>);\n     s'_ =\n     discover (hd (stack s)) v_\n      (s\\<lparr>pending := pending s - {(hd (stack s), v_)}\\<rparr>)\n     \\<lparr>state.more := e_\\<rparr>;\n     stack s \\<noteq> []; (hd (stack s), v_) \\<in> pending s;\n     v_ \\<notin> dom (discovered s); u_ = hd (stack s)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>va\\<in>dom (finished s).\n                         (va, v_) \\<in> E \\<longrightarrow>\n                         counter s < \\<phi> s va", "using finished_discovered"], ["proof (prove)\nusing this:\n  dom (finished s) \\<subseteq> dom (discovered s)\n\ngoal (6 subgoals):\n 1. \\<lbrakk>(\\<forall>v\\<in>dom (finished s).\n                 \\<delta> s v < \\<phi> s v) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<forall>w\\<in>dom (discovered s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<delta> s v \\<noteq> \\<delta> s w) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>dom (finished s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<phi> s v \\<noteq> \\<phi> s w) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<delta> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<phi> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>E `` {v}. \\<delta> s w < \\<phi> s v);\n     cond s; DFS_invar G param s;\n     DFS_invar G param\n      (discover (hd (stack s)) v_\n        (s\\<lparr>pending := pending s - {(hd (stack s), v_)}\\<rparr>)\n       \\<lparr>state.more := e_\\<rparr>);\n     s'_ =\n     discover (hd (stack s)) v_\n      (s\\<lparr>pending := pending s - {(hd (stack s), v_)}\\<rparr>)\n     \\<lparr>state.more := e_\\<rparr>;\n     stack s \\<noteq> []; (hd (stack s), v_) \\<in> pending s;\n     v_ \\<notin> dom (discovered s); u_ = hd (stack s)\\<rbrakk>\n    \\<Longrightarrow> v_ \\<in> dom (finished s) \\<longrightarrow>\n                      counter s < \\<phi> s v_\n 2. \\<lbrakk>(\\<forall>v\\<in>dom (finished s).\n                 \\<delta> s v < \\<phi> s v) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<forall>w\\<in>dom (discovered s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<delta> s v \\<noteq> \\<delta> s w) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>dom (finished s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<phi> s v \\<noteq> \\<phi> s w) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<delta> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<phi> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>E `` {v}. \\<delta> s w < \\<phi> s v);\n     cond s; DFS_invar G param s;\n     DFS_invar G param\n      (discover (hd (stack s)) v_\n        (s\\<lparr>pending := pending s - {(hd (stack s), v_)}\\<rparr>)\n       \\<lparr>state.more := e_\\<rparr>);\n     s'_ =\n     discover (hd (stack s)) v_\n      (s\\<lparr>pending := pending s - {(hd (stack s), v_)}\\<rparr>)\n     \\<lparr>state.more := e_\\<rparr>;\n     stack s \\<noteq> []; (hd (stack s), v_) \\<in> pending s;\n     v_ \\<notin> dom (discovered s); u_ = hd (stack s)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>w\\<in>dom (discovered s).\n                         v_ \\<noteq> w \\<longrightarrow>\n                         counter s \\<noteq> \\<delta> s w\n 3. \\<lbrakk>(\\<forall>v\\<in>dom (finished s).\n                 \\<delta> s v < \\<phi> s v) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<forall>w\\<in>dom (discovered s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<delta> s v \\<noteq> \\<delta> s w) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>dom (finished s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<phi> s v \\<noteq> \\<phi> s w) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<delta> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<phi> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>E `` {v}. \\<delta> s w < \\<phi> s v);\n     cond s; DFS_invar G param s;\n     DFS_invar G param\n      (discover (hd (stack s)) v_\n        (s\\<lparr>pending := pending s - {(hd (stack s), v_)}\\<rparr>)\n       \\<lparr>state.more := e_\\<rparr>);\n     s'_ =\n     discover (hd (stack s)) v_\n      (s\\<lparr>pending := pending s - {(hd (stack s), v_)}\\<rparr>)\n     \\<lparr>state.more := e_\\<rparr>;\n     stack s \\<noteq> []; (hd (stack s), v_) \\<in> pending s;\n     v_ \\<notin> dom (discovered s); u_ = hd (stack s)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>va\\<in>dom (discovered s).\n                         (va = v_ \\<longrightarrow>\n                          (\\<forall>w\\<in>dom (discovered s).\n                              v_ \\<noteq> w \\<longrightarrow>\n                              counter s \\<noteq> \\<delta> s w)) \\<and>\n                         (va \\<noteq> v_ \\<longrightarrow>\n                          \\<delta> s va \\<noteq> counter s)\n 4. \\<lbrakk>(\\<forall>v\\<in>dom (finished s).\n                 \\<delta> s v < \\<phi> s v) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<forall>w\\<in>dom (discovered s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<delta> s v \\<noteq> \\<delta> s w) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>dom (finished s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<phi> s v \\<noteq> \\<phi> s w) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<delta> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<phi> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>E `` {v}. \\<delta> s w < \\<phi> s v);\n     cond s; DFS_invar G param s;\n     DFS_invar G param\n      (discover (hd (stack s)) v_\n        (s\\<lparr>pending := pending s - {(hd (stack s), v_)}\\<rparr>)\n       \\<lparr>state.more := e_\\<rparr>);\n     s'_ =\n     discover (hd (stack s)) v_\n      (s\\<lparr>pending := pending s - {(hd (stack s), v_)}\\<rparr>)\n     \\<lparr>state.more := e_\\<rparr>;\n     stack s \\<noteq> []; (hd (stack s), v_) \\<in> pending s;\n     v_ \\<notin> dom (discovered s); u_ = hd (stack s)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>va\\<in>dom (discovered s).\n                         va \\<noteq> v_ \\<longrightarrow>\n                         \\<delta> s va < Suc (counter s)\n 5. \\<lbrakk>(\\<forall>v\\<in>dom (finished s).\n                 \\<delta> s v < \\<phi> s v) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<forall>w\\<in>dom (discovered s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<delta> s v \\<noteq> \\<delta> s w) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>dom (finished s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<phi> s v \\<noteq> \\<phi> s w) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<delta> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<phi> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>E `` {v}. \\<delta> s w < \\<phi> s v);\n     cond s; DFS_invar G param s;\n     DFS_invar G param\n      (discover (hd (stack s)) v_\n        (s\\<lparr>pending := pending s - {(hd (stack s), v_)}\\<rparr>)\n       \\<lparr>state.more := e_\\<rparr>);\n     s'_ =\n     discover (hd (stack s)) v_\n      (s\\<lparr>pending := pending s - {(hd (stack s), v_)}\\<rparr>)\n     \\<lparr>state.more := e_\\<rparr>;\n     stack s \\<noteq> []; (hd (stack s), v_) \\<in> pending s;\n     v_ \\<notin> dom (discovered s); u_ = hd (stack s)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>v\\<in>dom (finished s).\n                         \\<phi> s v < Suc (counter s)\n 6. \\<lbrakk>(\\<forall>v\\<in>dom (finished s).\n                 \\<delta> s v < \\<phi> s v) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<forall>w\\<in>dom (discovered s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<delta> s v \\<noteq> \\<delta> s w) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>dom (finished s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<phi> s v \\<noteq> \\<phi> s w) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<delta> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<phi> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>E `` {v}. \\<delta> s w < \\<phi> s v);\n     cond s; DFS_invar G param s;\n     DFS_invar G param\n      (discover (hd (stack s)) v_\n        (s\\<lparr>pending := pending s - {(hd (stack s), v_)}\\<rparr>)\n       \\<lparr>state.more := e_\\<rparr>);\n     s'_ =\n     discover (hd (stack s)) v_\n      (s\\<lparr>pending := pending s - {(hd (stack s), v_)}\\<rparr>)\n     \\<lparr>state.more := e_\\<rparr>;\n     stack s \\<noteq> []; (hd (stack s), v_) \\<in> pending s;\n     v_ \\<notin> dom (discovered s); u_ = hd (stack s)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>va\\<in>dom (finished s).\n                         (va, v_) \\<in> E \\<longrightarrow>\n                         counter s < \\<phi> s va", "apply fastforce"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>(\\<forall>v\\<in>dom (finished s).\n                 \\<delta> s v < \\<phi> s v) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<forall>w\\<in>dom (discovered s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<delta> s v \\<noteq> \\<delta> s w) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>dom (finished s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<phi> s v \\<noteq> \\<phi> s w) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<delta> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<phi> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>E `` {v}. \\<delta> s w < \\<phi> s v);\n     cond s; DFS_invar G param s;\n     DFS_invar G param\n      (discover (hd (stack s)) v_\n        (s\\<lparr>pending := pending s - {(hd (stack s), v_)}\\<rparr>)\n       \\<lparr>state.more := e_\\<rparr>);\n     s'_ =\n     discover (hd (stack s)) v_\n      (s\\<lparr>pending := pending s - {(hd (stack s), v_)}\\<rparr>)\n     \\<lparr>state.more := e_\\<rparr>;\n     stack s \\<noteq> []; (hd (stack s), v_) \\<in> pending s;\n     v_ \\<notin> dom (discovered s); u_ = hd (stack s)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>w\\<in>dom (discovered s).\n                         v_ \\<noteq> w \\<longrightarrow>\n                         counter s \\<noteq> \\<delta> s w\n 2. \\<lbrakk>(\\<forall>v\\<in>dom (finished s).\n                 \\<delta> s v < \\<phi> s v) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<forall>w\\<in>dom (discovered s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<delta> s v \\<noteq> \\<delta> s w) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>dom (finished s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<phi> s v \\<noteq> \\<phi> s w) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<delta> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<phi> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>E `` {v}. \\<delta> s w < \\<phi> s v);\n     cond s; DFS_invar G param s;\n     DFS_invar G param\n      (discover (hd (stack s)) v_\n        (s\\<lparr>pending := pending s - {(hd (stack s), v_)}\\<rparr>)\n       \\<lparr>state.more := e_\\<rparr>);\n     s'_ =\n     discover (hd (stack s)) v_\n      (s\\<lparr>pending := pending s - {(hd (stack s), v_)}\\<rparr>)\n     \\<lparr>state.more := e_\\<rparr>;\n     stack s \\<noteq> []; (hd (stack s), v_) \\<in> pending s;\n     v_ \\<notin> dom (discovered s); u_ = hd (stack s)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>va\\<in>dom (discovered s).\n                         (va = v_ \\<longrightarrow>\n                          (\\<forall>w\\<in>dom (discovered s).\n                              v_ \\<noteq> w \\<longrightarrow>\n                              counter s \\<noteq> \\<delta> s w)) \\<and>\n                         (va \\<noteq> v_ \\<longrightarrow>\n                          \\<delta> s va \\<noteq> counter s)\n 3. \\<lbrakk>(\\<forall>v\\<in>dom (finished s).\n                 \\<delta> s v < \\<phi> s v) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<forall>w\\<in>dom (discovered s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<delta> s v \\<noteq> \\<delta> s w) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>dom (finished s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<phi> s v \\<noteq> \\<phi> s w) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<delta> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<phi> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>E `` {v}. \\<delta> s w < \\<phi> s v);\n     cond s; DFS_invar G param s;\n     DFS_invar G param\n      (discover (hd (stack s)) v_\n        (s\\<lparr>pending := pending s - {(hd (stack s), v_)}\\<rparr>)\n       \\<lparr>state.more := e_\\<rparr>);\n     s'_ =\n     discover (hd (stack s)) v_\n      (s\\<lparr>pending := pending s - {(hd (stack s), v_)}\\<rparr>)\n     \\<lparr>state.more := e_\\<rparr>;\n     stack s \\<noteq> []; (hd (stack s), v_) \\<in> pending s;\n     v_ \\<notin> dom (discovered s); u_ = hd (stack s)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>va\\<in>dom (discovered s).\n                         va \\<noteq> v_ \\<longrightarrow>\n                         \\<delta> s va < Suc (counter s)\n 4. \\<lbrakk>(\\<forall>v\\<in>dom (finished s).\n                 \\<delta> s v < \\<phi> s v) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<forall>w\\<in>dom (discovered s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<delta> s v \\<noteq> \\<delta> s w) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>dom (finished s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<phi> s v \\<noteq> \\<phi> s w) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<delta> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<phi> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>E `` {v}. \\<delta> s w < \\<phi> s v);\n     cond s; DFS_invar G param s;\n     DFS_invar G param\n      (discover (hd (stack s)) v_\n        (s\\<lparr>pending := pending s - {(hd (stack s), v_)}\\<rparr>)\n       \\<lparr>state.more := e_\\<rparr>);\n     s'_ =\n     discover (hd (stack s)) v_\n      (s\\<lparr>pending := pending s - {(hd (stack s), v_)}\\<rparr>)\n     \\<lparr>state.more := e_\\<rparr>;\n     stack s \\<noteq> []; (hd (stack s), v_) \\<in> pending s;\n     v_ \\<notin> dom (discovered s); u_ = hd (stack s)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>v\\<in>dom (finished s).\n                         \\<phi> s v < Suc (counter s)\n 5. \\<lbrakk>(\\<forall>v\\<in>dom (finished s).\n                 \\<delta> s v < \\<phi> s v) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<forall>w\\<in>dom (discovered s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<delta> s v \\<noteq> \\<delta> s w) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>dom (finished s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<phi> s v \\<noteq> \\<phi> s w) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<delta> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<phi> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>E `` {v}. \\<delta> s w < \\<phi> s v);\n     cond s; DFS_invar G param s;\n     DFS_invar G param\n      (discover (hd (stack s)) v_\n        (s\\<lparr>pending := pending s - {(hd (stack s), v_)}\\<rparr>)\n       \\<lparr>state.more := e_\\<rparr>);\n     s'_ =\n     discover (hd (stack s)) v_\n      (s\\<lparr>pending := pending s - {(hd (stack s), v_)}\\<rparr>)\n     \\<lparr>state.more := e_\\<rparr>;\n     stack s \\<noteq> []; (hd (stack s), v_) \\<in> pending s;\n     v_ \\<notin> dom (discovered s); u_ = hd (stack s)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>va\\<in>dom (finished s).\n                         (va, v_) \\<in> E \\<longrightarrow>\n                         counter s < \\<phi> s va", "apply (metis less_irrefl)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>(\\<forall>v\\<in>dom (finished s).\n                 \\<delta> s v < \\<phi> s v) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<forall>w\\<in>dom (discovered s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<delta> s v \\<noteq> \\<delta> s w) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>dom (finished s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<phi> s v \\<noteq> \\<phi> s w) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<delta> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<phi> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>E `` {v}. \\<delta> s w < \\<phi> s v);\n     cond s; DFS_invar G param s;\n     DFS_invar G param\n      (discover (hd (stack s)) v_\n        (s\\<lparr>pending := pending s - {(hd (stack s), v_)}\\<rparr>)\n       \\<lparr>state.more := e_\\<rparr>);\n     s'_ =\n     discover (hd (stack s)) v_\n      (s\\<lparr>pending := pending s - {(hd (stack s), v_)}\\<rparr>)\n     \\<lparr>state.more := e_\\<rparr>;\n     stack s \\<noteq> []; (hd (stack s), v_) \\<in> pending s;\n     v_ \\<notin> dom (discovered s); u_ = hd (stack s)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>va\\<in>dom (discovered s).\n                         (va = v_ \\<longrightarrow>\n                          (\\<forall>w\\<in>dom (discovered s).\n                              v_ \\<noteq> w \\<longrightarrow>\n                              counter s \\<noteq> \\<delta> s w)) \\<and>\n                         (va \\<noteq> v_ \\<longrightarrow>\n                          \\<delta> s va \\<noteq> counter s)\n 2. \\<lbrakk>(\\<forall>v\\<in>dom (finished s).\n                 \\<delta> s v < \\<phi> s v) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<forall>w\\<in>dom (discovered s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<delta> s v \\<noteq> \\<delta> s w) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>dom (finished s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<phi> s v \\<noteq> \\<phi> s w) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<delta> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<phi> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>E `` {v}. \\<delta> s w < \\<phi> s v);\n     cond s; DFS_invar G param s;\n     DFS_invar G param\n      (discover (hd (stack s)) v_\n        (s\\<lparr>pending := pending s - {(hd (stack s), v_)}\\<rparr>)\n       \\<lparr>state.more := e_\\<rparr>);\n     s'_ =\n     discover (hd (stack s)) v_\n      (s\\<lparr>pending := pending s - {(hd (stack s), v_)}\\<rparr>)\n     \\<lparr>state.more := e_\\<rparr>;\n     stack s \\<noteq> []; (hd (stack s), v_) \\<in> pending s;\n     v_ \\<notin> dom (discovered s); u_ = hd (stack s)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>va\\<in>dom (discovered s).\n                         va \\<noteq> v_ \\<longrightarrow>\n                         \\<delta> s va < Suc (counter s)\n 3. \\<lbrakk>(\\<forall>v\\<in>dom (finished s).\n                 \\<delta> s v < \\<phi> s v) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<forall>w\\<in>dom (discovered s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<delta> s v \\<noteq> \\<delta> s w) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>dom (finished s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<phi> s v \\<noteq> \\<phi> s w) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<delta> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<phi> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>E `` {v}. \\<delta> s w < \\<phi> s v);\n     cond s; DFS_invar G param s;\n     DFS_invar G param\n      (discover (hd (stack s)) v_\n        (s\\<lparr>pending := pending s - {(hd (stack s), v_)}\\<rparr>)\n       \\<lparr>state.more := e_\\<rparr>);\n     s'_ =\n     discover (hd (stack s)) v_\n      (s\\<lparr>pending := pending s - {(hd (stack s), v_)}\\<rparr>)\n     \\<lparr>state.more := e_\\<rparr>;\n     stack s \\<noteq> []; (hd (stack s), v_) \\<in> pending s;\n     v_ \\<notin> dom (discovered s); u_ = hd (stack s)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>v\\<in>dom (finished s).\n                         \\<phi> s v < Suc (counter s)\n 4. \\<lbrakk>(\\<forall>v\\<in>dom (finished s).\n                 \\<delta> s v < \\<phi> s v) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<forall>w\\<in>dom (discovered s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<delta> s v \\<noteq> \\<delta> s w) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>dom (finished s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<phi> s v \\<noteq> \\<phi> s w) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<delta> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<phi> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>E `` {v}. \\<delta> s w < \\<phi> s v);\n     cond s; DFS_invar G param s;\n     DFS_invar G param\n      (discover (hd (stack s)) v_\n        (s\\<lparr>pending := pending s - {(hd (stack s), v_)}\\<rparr>)\n       \\<lparr>state.more := e_\\<rparr>);\n     s'_ =\n     discover (hd (stack s)) v_\n      (s\\<lparr>pending := pending s - {(hd (stack s), v_)}\\<rparr>)\n     \\<lparr>state.more := e_\\<rparr>;\n     stack s \\<noteq> []; (hd (stack s), v_) \\<in> pending s;\n     v_ \\<notin> dom (discovered s); u_ = hd (stack s)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>va\\<in>dom (finished s).\n                         (va, v_) \\<in> E \\<longrightarrow>\n                         counter s < \\<phi> s va", "apply (metis less_irrefl)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>(\\<forall>v\\<in>dom (finished s).\n                 \\<delta> s v < \\<phi> s v) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<forall>w\\<in>dom (discovered s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<delta> s v \\<noteq> \\<delta> s w) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>dom (finished s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<phi> s v \\<noteq> \\<phi> s w) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<delta> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<phi> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>E `` {v}. \\<delta> s w < \\<phi> s v);\n     cond s; DFS_invar G param s;\n     DFS_invar G param\n      (discover (hd (stack s)) v_\n        (s\\<lparr>pending := pending s - {(hd (stack s), v_)}\\<rparr>)\n       \\<lparr>state.more := e_\\<rparr>);\n     s'_ =\n     discover (hd (stack s)) v_\n      (s\\<lparr>pending := pending s - {(hd (stack s), v_)}\\<rparr>)\n     \\<lparr>state.more := e_\\<rparr>;\n     stack s \\<noteq> []; (hd (stack s), v_) \\<in> pending s;\n     v_ \\<notin> dom (discovered s); u_ = hd (stack s)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>va\\<in>dom (discovered s).\n                         va \\<noteq> v_ \\<longrightarrow>\n                         \\<delta> s va < Suc (counter s)\n 2. \\<lbrakk>(\\<forall>v\\<in>dom (finished s).\n                 \\<delta> s v < \\<phi> s v) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<forall>w\\<in>dom (discovered s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<delta> s v \\<noteq> \\<delta> s w) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>dom (finished s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<phi> s v \\<noteq> \\<phi> s w) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<delta> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<phi> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>E `` {v}. \\<delta> s w < \\<phi> s v);\n     cond s; DFS_invar G param s;\n     DFS_invar G param\n      (discover (hd (stack s)) v_\n        (s\\<lparr>pending := pending s - {(hd (stack s), v_)}\\<rparr>)\n       \\<lparr>state.more := e_\\<rparr>);\n     s'_ =\n     discover (hd (stack s)) v_\n      (s\\<lparr>pending := pending s - {(hd (stack s), v_)}\\<rparr>)\n     \\<lparr>state.more := e_\\<rparr>;\n     stack s \\<noteq> []; (hd (stack s), v_) \\<in> pending s;\n     v_ \\<notin> dom (discovered s); u_ = hd (stack s)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>v\\<in>dom (finished s).\n                         \\<phi> s v < Suc (counter s)\n 3. \\<lbrakk>(\\<forall>v\\<in>dom (finished s).\n                 \\<delta> s v < \\<phi> s v) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<forall>w\\<in>dom (discovered s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<delta> s v \\<noteq> \\<delta> s w) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>dom (finished s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<phi> s v \\<noteq> \\<phi> s w) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<delta> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<phi> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>E `` {v}. \\<delta> s w < \\<phi> s v);\n     cond s; DFS_invar G param s;\n     DFS_invar G param\n      (discover (hd (stack s)) v_\n        (s\\<lparr>pending := pending s - {(hd (stack s), v_)}\\<rparr>)\n       \\<lparr>state.more := e_\\<rparr>);\n     s'_ =\n     discover (hd (stack s)) v_\n      (s\\<lparr>pending := pending s - {(hd (stack s), v_)}\\<rparr>)\n     \\<lparr>state.more := e_\\<rparr>;\n     stack s \\<noteq> []; (hd (stack s), v_) \\<in> pending s;\n     v_ \\<notin> dom (discovered s); u_ = hd (stack s)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>va\\<in>dom (finished s).\n                         (va, v_) \\<in> E \\<longrightarrow>\n                         counter s < \\<phi> s va", "apply (metis less_SucI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>(\\<forall>v\\<in>dom (finished s).\n                 \\<delta> s v < \\<phi> s v) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<forall>w\\<in>dom (discovered s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<delta> s v \\<noteq> \\<delta> s w) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>dom (finished s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<phi> s v \\<noteq> \\<phi> s w) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<delta> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<phi> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>E `` {v}. \\<delta> s w < \\<phi> s v);\n     cond s; DFS_invar G param s;\n     DFS_invar G param\n      (discover (hd (stack s)) v_\n        (s\\<lparr>pending := pending s - {(hd (stack s), v_)}\\<rparr>)\n       \\<lparr>state.more := e_\\<rparr>);\n     s'_ =\n     discover (hd (stack s)) v_\n      (s\\<lparr>pending := pending s - {(hd (stack s), v_)}\\<rparr>)\n     \\<lparr>state.more := e_\\<rparr>;\n     stack s \\<noteq> []; (hd (stack s), v_) \\<in> pending s;\n     v_ \\<notin> dom (discovered s); u_ = hd (stack s)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>v\\<in>dom (finished s).\n                         \\<phi> s v < Suc (counter s)\n 2. \\<lbrakk>(\\<forall>v\\<in>dom (finished s).\n                 \\<delta> s v < \\<phi> s v) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<forall>w\\<in>dom (discovered s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<delta> s v \\<noteq> \\<delta> s w) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>dom (finished s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<phi> s v \\<noteq> \\<phi> s w) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<delta> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<phi> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>E `` {v}. \\<delta> s w < \\<phi> s v);\n     cond s; DFS_invar G param s;\n     DFS_invar G param\n      (discover (hd (stack s)) v_\n        (s\\<lparr>pending := pending s - {(hd (stack s), v_)}\\<rparr>)\n       \\<lparr>state.more := e_\\<rparr>);\n     s'_ =\n     discover (hd (stack s)) v_\n      (s\\<lparr>pending := pending s - {(hd (stack s), v_)}\\<rparr>)\n     \\<lparr>state.more := e_\\<rparr>;\n     stack s \\<noteq> []; (hd (stack s), v_) \\<in> pending s;\n     v_ \\<notin> dom (discovered s); u_ = hd (stack s)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>va\\<in>dom (finished s).\n                         (va, v_) \\<in> E \\<longrightarrow>\n                         counter s < \\<phi> s va", "apply (metis less_SucI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<forall>v\\<in>dom (finished s).\n                 \\<delta> s v < \\<phi> s v) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<forall>w\\<in>dom (discovered s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<delta> s v \\<noteq> \\<delta> s w) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>dom (finished s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<phi> s v \\<noteq> \\<phi> s w) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<delta> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<phi> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>E `` {v}. \\<delta> s w < \\<phi> s v);\n     cond s; DFS_invar G param s;\n     DFS_invar G param\n      (discover (hd (stack s)) v_\n        (s\\<lparr>pending := pending s - {(hd (stack s), v_)}\\<rparr>)\n       \\<lparr>state.more := e_\\<rparr>);\n     s'_ =\n     discover (hd (stack s)) v_\n      (s\\<lparr>pending := pending s - {(hd (stack s), v_)}\\<rparr>)\n     \\<lparr>state.more := e_\\<rparr>;\n     stack s \\<noteq> []; (hd (stack s), v_) \\<in> pending s;\n     v_ \\<notin> dom (discovered s); u_ = hd (stack s)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>va\\<in>dom (finished s).\n                         (va, v_) \\<in> E \\<longrightarrow>\n                         counter s < \\<phi> s va", "using finished_imp_succ_discovered"], ["proof (prove)\nusing this:\n  \\<lbrakk>?v \\<in> dom (finished s); ?w \\<in> E `` {?v}\\<rbrakk>\n  \\<Longrightarrow> ?w \\<in> dom (discovered s)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<forall>v\\<in>dom (finished s).\n                 \\<delta> s v < \\<phi> s v) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<forall>w\\<in>dom (discovered s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<delta> s v \\<noteq> \\<delta> s w) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>dom (finished s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<phi> s v \\<noteq> \\<phi> s w) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<delta> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<phi> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>E `` {v}. \\<delta> s w < \\<phi> s v);\n     cond s; DFS_invar G param s;\n     DFS_invar G param\n      (discover (hd (stack s)) v_\n        (s\\<lparr>pending := pending s - {(hd (stack s), v_)}\\<rparr>)\n       \\<lparr>state.more := e_\\<rparr>);\n     s'_ =\n     discover (hd (stack s)) v_\n      (s\\<lparr>pending := pending s - {(hd (stack s), v_)}\\<rparr>)\n     \\<lparr>state.more := e_\\<rparr>;\n     stack s \\<noteq> []; (hd (stack s), v_) \\<in> pending s;\n     v_ \\<notin> dom (discovered s); u_ = hd (stack s)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>va\\<in>dom (finished s).\n                         (va, v_) \\<in> E \\<longrightarrow>\n                         counter s < \\<phi> s va", "apply fastforce"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  timing_common_inv s'_\n\ngoal (3 subgoals):\n 1. \\<And>e. timing_common_inv (empty_state e)\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>timing_common_inv s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s = []; v0 \\<notin> dom (discovered s);\n        v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> timing_common_inv s'\n 3. \\<And>s s' u v e c b.\n       \\<lbrakk>timing_common_inv s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); u = hd (stack s);\n        cross_edges s \\<subseteq> c; back_edges s \\<subseteq> b;\n        s' = s\n        \\<lparr>pending := pending s - {(u, v)}, state.more := e,\n           cross_edges := c, back_edges := b\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> timing_common_inv s'", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>e. timing_common_inv (empty_state e)\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>timing_common_inv s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s = []; v0 \\<notin> dom (discovered s);\n        v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> timing_common_inv s'\n 3. \\<And>s s' u v e c b.\n       \\<lbrakk>timing_common_inv s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); u = hd (stack s);\n        cross_edges s \\<subseteq> c; back_edges s \\<subseteq> b;\n        s' = s\n        \\<lparr>pending := pending s - {(u, v)}, state.more := e,\n           cross_edges := c, back_edges := b\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> timing_common_inv s'", "case (new_root s s' v0)"], ["proof (state)\nthis:\n  timing_common_inv s\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  v0 \\<in> V0\n  s' = new_root v0 s\\<lparr>state.more := e_\\<rparr>\n  stack s = []\n  v0 \\<notin> dom (discovered s)\n\ngoal (3 subgoals):\n 1. \\<And>e. timing_common_inv (empty_state e)\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>timing_common_inv s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s = []; v0 \\<notin> dom (discovered s);\n        v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> timing_common_inv s'\n 3. \\<And>s s' u v e c b.\n       \\<lbrakk>timing_common_inv s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); u = hd (stack s);\n        cross_edges s \\<subseteq> c; back_edges s \\<subseteq> b;\n        s' = s\n        \\<lparr>pending := pending s - {(u, v)}, state.more := e,\n           cross_edges := c, back_edges := b\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> timing_common_inv s'", "then"], ["proof (chain)\npicking this:\n  timing_common_inv s\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  v0 \\<in> V0\n  s' = new_root v0 s\\<lparr>state.more := e_\\<rparr>\n  stack s = []\n  v0 \\<notin> dom (discovered s)", "interpret DFS_invar where s=s"], ["proof (prove)\nusing this:\n  timing_common_inv s\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  v0 \\<in> V0\n  s' = new_root v0 s\\<lparr>state.more := e_\\<rparr>\n  stack s = []\n  v0 \\<notin> dom (discovered s)\n\ngoal (1 subgoal):\n 1. DFS_invar G param s", "by simp"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>e. timing_common_inv (empty_state e)\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>timing_common_inv s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s = []; v0 \\<notin> dom (discovered s);\n        v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> timing_common_inv s'\n 3. \\<And>s s' u v e c b.\n       \\<lbrakk>timing_common_inv s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); u = hd (stack s);\n        cross_edges s \\<subseteq> c; back_edges s \\<subseteq> b;\n        s' = s\n        \\<lparr>pending := pending s - {(u, v)}, state.more := e,\n           cross_edges := c, back_edges := b\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> timing_common_inv s'", "from new_root"], ["proof (chain)\npicking this:\n  timing_common_inv s\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  v0 \\<in> V0\n  s' = new_root v0 s\\<lparr>state.more := e_\\<rparr>\n  stack s = []\n  v0 \\<notin> dom (discovered s)", "show ?case"], ["proof (prove)\nusing this:\n  timing_common_inv s\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  v0 \\<in> V0\n  s' = new_root v0 s\\<lparr>state.more := e_\\<rparr>\n  stack s = []\n  v0 \\<notin> dom (discovered s)\n\ngoal (1 subgoal):\n 1. timing_common_inv s'", "apply (simp add: timing_common_inv_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<forall>v\\<in>dom (finished s).\n                 \\<delta> s v < \\<phi> s v) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<forall>w\\<in>dom (discovered s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<delta> s v \\<noteq> \\<delta> s w) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>dom (finished s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<phi> s v \\<noteq> \\<phi> s w) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<delta> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<phi> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>E `` {v}. \\<delta> s w < \\<phi> s v);\n     cond s; DFS_invar G param s;\n     DFS_invar G param (new_root v0 s\\<lparr>state.more := e_\\<rparr>);\n     v0 \\<in> V0; s' = new_root v0 s\\<lparr>state.more := e_\\<rparr>;\n     stack s = []; v0 \\<notin> dom (discovered s)\\<rbrakk>\n    \\<Longrightarrow> (v0 \\<in> dom (finished s) \\<longrightarrow>\n                       counter s < \\<phi> s v0) \\<and>\n                      (\\<forall>w\\<in>dom (discovered s).\n                          v0 \\<noteq> w \\<longrightarrow>\n                          counter s \\<noteq> \\<delta> s w) \\<and>\n                      (\\<forall>v\\<in>dom (discovered s).\n                          (v = v0 \\<longrightarrow>\n                           (\\<forall>w\\<in>dom (discovered s).\n                               v0 \\<noteq> w \\<longrightarrow>\n                               counter s \\<noteq> \\<delta> s w)) \\<and>\n                          (v \\<noteq> v0 \\<longrightarrow>\n                           \\<delta> s v \\<noteq> counter s)) \\<and>\n                      (\\<forall>v\\<in>dom (discovered s).\n                          v \\<noteq> v0 \\<longrightarrow>\n                          \\<delta> s v < Suc (counter s)) \\<and>\n                      (\\<forall>v\\<in>dom (finished s).\n                          \\<phi> s v < Suc (counter s)) \\<and>\n                      (\\<forall>v\\<in>dom (finished s).\n                          (v, v0) \\<in> E \\<longrightarrow>\n                          counter s < \\<phi> s v)", "apply (intro conjI)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>(\\<forall>v\\<in>dom (finished s).\n                 \\<delta> s v < \\<phi> s v) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<forall>w\\<in>dom (discovered s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<delta> s v \\<noteq> \\<delta> s w) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>dom (finished s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<phi> s v \\<noteq> \\<phi> s w) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<delta> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<phi> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>E `` {v}. \\<delta> s w < \\<phi> s v);\n     cond s; DFS_invar G param s;\n     DFS_invar G param (new_root v0 s\\<lparr>state.more := e_\\<rparr>);\n     v0 \\<in> V0; s' = new_root v0 s\\<lparr>state.more := e_\\<rparr>;\n     stack s = []; v0 \\<notin> dom (discovered s)\\<rbrakk>\n    \\<Longrightarrow> v0 \\<in> dom (finished s) \\<longrightarrow>\n                      counter s < \\<phi> s v0\n 2. \\<lbrakk>(\\<forall>v\\<in>dom (finished s).\n                 \\<delta> s v < \\<phi> s v) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<forall>w\\<in>dom (discovered s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<delta> s v \\<noteq> \\<delta> s w) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>dom (finished s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<phi> s v \\<noteq> \\<phi> s w) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<delta> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<phi> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>E `` {v}. \\<delta> s w < \\<phi> s v);\n     cond s; DFS_invar G param s;\n     DFS_invar G param (new_root v0 s\\<lparr>state.more := e_\\<rparr>);\n     v0 \\<in> V0; s' = new_root v0 s\\<lparr>state.more := e_\\<rparr>;\n     stack s = []; v0 \\<notin> dom (discovered s)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>w\\<in>dom (discovered s).\n                         v0 \\<noteq> w \\<longrightarrow>\n                         counter s \\<noteq> \\<delta> s w\n 3. \\<lbrakk>(\\<forall>v\\<in>dom (finished s).\n                 \\<delta> s v < \\<phi> s v) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<forall>w\\<in>dom (discovered s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<delta> s v \\<noteq> \\<delta> s w) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>dom (finished s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<phi> s v \\<noteq> \\<phi> s w) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<delta> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<phi> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>E `` {v}. \\<delta> s w < \\<phi> s v);\n     cond s; DFS_invar G param s;\n     DFS_invar G param (new_root v0 s\\<lparr>state.more := e_\\<rparr>);\n     v0 \\<in> V0; s' = new_root v0 s\\<lparr>state.more := e_\\<rparr>;\n     stack s = []; v0 \\<notin> dom (discovered s)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>v\\<in>dom (discovered s).\n                         (v = v0 \\<longrightarrow>\n                          (\\<forall>w\\<in>dom (discovered s).\n                              v0 \\<noteq> w \\<longrightarrow>\n                              counter s \\<noteq> \\<delta> s w)) \\<and>\n                         (v \\<noteq> v0 \\<longrightarrow>\n                          \\<delta> s v \\<noteq> counter s)\n 4. \\<lbrakk>(\\<forall>v\\<in>dom (finished s).\n                 \\<delta> s v < \\<phi> s v) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<forall>w\\<in>dom (discovered s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<delta> s v \\<noteq> \\<delta> s w) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>dom (finished s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<phi> s v \\<noteq> \\<phi> s w) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<delta> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<phi> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>E `` {v}. \\<delta> s w < \\<phi> s v);\n     cond s; DFS_invar G param s;\n     DFS_invar G param (new_root v0 s\\<lparr>state.more := e_\\<rparr>);\n     v0 \\<in> V0; s' = new_root v0 s\\<lparr>state.more := e_\\<rparr>;\n     stack s = []; v0 \\<notin> dom (discovered s)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>v\\<in>dom (discovered s).\n                         v \\<noteq> v0 \\<longrightarrow>\n                         \\<delta> s v < Suc (counter s)\n 5. \\<lbrakk>(\\<forall>v\\<in>dom (finished s).\n                 \\<delta> s v < \\<phi> s v) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<forall>w\\<in>dom (discovered s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<delta> s v \\<noteq> \\<delta> s w) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>dom (finished s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<phi> s v \\<noteq> \\<phi> s w) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<delta> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<phi> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>E `` {v}. \\<delta> s w < \\<phi> s v);\n     cond s; DFS_invar G param s;\n     DFS_invar G param (new_root v0 s\\<lparr>state.more := e_\\<rparr>);\n     v0 \\<in> V0; s' = new_root v0 s\\<lparr>state.more := e_\\<rparr>;\n     stack s = []; v0 \\<notin> dom (discovered s)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>v\\<in>dom (finished s).\n                         \\<phi> s v < Suc (counter s)\n 6. \\<lbrakk>(\\<forall>v\\<in>dom (finished s).\n                 \\<delta> s v < \\<phi> s v) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<forall>w\\<in>dom (discovered s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<delta> s v \\<noteq> \\<delta> s w) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>dom (finished s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<phi> s v \\<noteq> \\<phi> s w) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<delta> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<phi> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>E `` {v}. \\<delta> s w < \\<phi> s v);\n     cond s; DFS_invar G param s;\n     DFS_invar G param (new_root v0 s\\<lparr>state.more := e_\\<rparr>);\n     v0 \\<in> V0; s' = new_root v0 s\\<lparr>state.more := e_\\<rparr>;\n     stack s = []; v0 \\<notin> dom (discovered s)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>v\\<in>dom (finished s).\n                         (v, v0) \\<in> E \\<longrightarrow>\n                         counter s < \\<phi> s v", "using finished_discovered"], ["proof (prove)\nusing this:\n  dom (finished s) \\<subseteq> dom (discovered s)\n\ngoal (6 subgoals):\n 1. \\<lbrakk>(\\<forall>v\\<in>dom (finished s).\n                 \\<delta> s v < \\<phi> s v) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<forall>w\\<in>dom (discovered s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<delta> s v \\<noteq> \\<delta> s w) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>dom (finished s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<phi> s v \\<noteq> \\<phi> s w) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<delta> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<phi> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>E `` {v}. \\<delta> s w < \\<phi> s v);\n     cond s; DFS_invar G param s;\n     DFS_invar G param (new_root v0 s\\<lparr>state.more := e_\\<rparr>);\n     v0 \\<in> V0; s' = new_root v0 s\\<lparr>state.more := e_\\<rparr>;\n     stack s = []; v0 \\<notin> dom (discovered s)\\<rbrakk>\n    \\<Longrightarrow> v0 \\<in> dom (finished s) \\<longrightarrow>\n                      counter s < \\<phi> s v0\n 2. \\<lbrakk>(\\<forall>v\\<in>dom (finished s).\n                 \\<delta> s v < \\<phi> s v) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<forall>w\\<in>dom (discovered s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<delta> s v \\<noteq> \\<delta> s w) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>dom (finished s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<phi> s v \\<noteq> \\<phi> s w) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<delta> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<phi> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>E `` {v}. \\<delta> s w < \\<phi> s v);\n     cond s; DFS_invar G param s;\n     DFS_invar G param (new_root v0 s\\<lparr>state.more := e_\\<rparr>);\n     v0 \\<in> V0; s' = new_root v0 s\\<lparr>state.more := e_\\<rparr>;\n     stack s = []; v0 \\<notin> dom (discovered s)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>w\\<in>dom (discovered s).\n                         v0 \\<noteq> w \\<longrightarrow>\n                         counter s \\<noteq> \\<delta> s w\n 3. \\<lbrakk>(\\<forall>v\\<in>dom (finished s).\n                 \\<delta> s v < \\<phi> s v) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<forall>w\\<in>dom (discovered s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<delta> s v \\<noteq> \\<delta> s w) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>dom (finished s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<phi> s v \\<noteq> \\<phi> s w) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<delta> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<phi> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>E `` {v}. \\<delta> s w < \\<phi> s v);\n     cond s; DFS_invar G param s;\n     DFS_invar G param (new_root v0 s\\<lparr>state.more := e_\\<rparr>);\n     v0 \\<in> V0; s' = new_root v0 s\\<lparr>state.more := e_\\<rparr>;\n     stack s = []; v0 \\<notin> dom (discovered s)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>v\\<in>dom (discovered s).\n                         (v = v0 \\<longrightarrow>\n                          (\\<forall>w\\<in>dom (discovered s).\n                              v0 \\<noteq> w \\<longrightarrow>\n                              counter s \\<noteq> \\<delta> s w)) \\<and>\n                         (v \\<noteq> v0 \\<longrightarrow>\n                          \\<delta> s v \\<noteq> counter s)\n 4. \\<lbrakk>(\\<forall>v\\<in>dom (finished s).\n                 \\<delta> s v < \\<phi> s v) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<forall>w\\<in>dom (discovered s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<delta> s v \\<noteq> \\<delta> s w) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>dom (finished s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<phi> s v \\<noteq> \\<phi> s w) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<delta> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<phi> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>E `` {v}. \\<delta> s w < \\<phi> s v);\n     cond s; DFS_invar G param s;\n     DFS_invar G param (new_root v0 s\\<lparr>state.more := e_\\<rparr>);\n     v0 \\<in> V0; s' = new_root v0 s\\<lparr>state.more := e_\\<rparr>;\n     stack s = []; v0 \\<notin> dom (discovered s)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>v\\<in>dom (discovered s).\n                         v \\<noteq> v0 \\<longrightarrow>\n                         \\<delta> s v < Suc (counter s)\n 5. \\<lbrakk>(\\<forall>v\\<in>dom (finished s).\n                 \\<delta> s v < \\<phi> s v) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<forall>w\\<in>dom (discovered s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<delta> s v \\<noteq> \\<delta> s w) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>dom (finished s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<phi> s v \\<noteq> \\<phi> s w) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<delta> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<phi> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>E `` {v}. \\<delta> s w < \\<phi> s v);\n     cond s; DFS_invar G param s;\n     DFS_invar G param (new_root v0 s\\<lparr>state.more := e_\\<rparr>);\n     v0 \\<in> V0; s' = new_root v0 s\\<lparr>state.more := e_\\<rparr>;\n     stack s = []; v0 \\<notin> dom (discovered s)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>v\\<in>dom (finished s).\n                         \\<phi> s v < Suc (counter s)\n 6. \\<lbrakk>(\\<forall>v\\<in>dom (finished s).\n                 \\<delta> s v < \\<phi> s v) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<forall>w\\<in>dom (discovered s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<delta> s v \\<noteq> \\<delta> s w) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>dom (finished s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<phi> s v \\<noteq> \\<phi> s w) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<delta> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<phi> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>E `` {v}. \\<delta> s w < \\<phi> s v);\n     cond s; DFS_invar G param s;\n     DFS_invar G param (new_root v0 s\\<lparr>state.more := e_\\<rparr>);\n     v0 \\<in> V0; s' = new_root v0 s\\<lparr>state.more := e_\\<rparr>;\n     stack s = []; v0 \\<notin> dom (discovered s)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>v\\<in>dom (finished s).\n                         (v, v0) \\<in> E \\<longrightarrow>\n                         counter s < \\<phi> s v", "apply fastforce"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>(\\<forall>v\\<in>dom (finished s).\n                 \\<delta> s v < \\<phi> s v) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<forall>w\\<in>dom (discovered s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<delta> s v \\<noteq> \\<delta> s w) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>dom (finished s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<phi> s v \\<noteq> \\<phi> s w) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<delta> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<phi> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>E `` {v}. \\<delta> s w < \\<phi> s v);\n     cond s; DFS_invar G param s;\n     DFS_invar G param (new_root v0 s\\<lparr>state.more := e_\\<rparr>);\n     v0 \\<in> V0; s' = new_root v0 s\\<lparr>state.more := e_\\<rparr>;\n     stack s = []; v0 \\<notin> dom (discovered s)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>w\\<in>dom (discovered s).\n                         v0 \\<noteq> w \\<longrightarrow>\n                         counter s \\<noteq> \\<delta> s w\n 2. \\<lbrakk>(\\<forall>v\\<in>dom (finished s).\n                 \\<delta> s v < \\<phi> s v) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<forall>w\\<in>dom (discovered s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<delta> s v \\<noteq> \\<delta> s w) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>dom (finished s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<phi> s v \\<noteq> \\<phi> s w) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<delta> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<phi> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>E `` {v}. \\<delta> s w < \\<phi> s v);\n     cond s; DFS_invar G param s;\n     DFS_invar G param (new_root v0 s\\<lparr>state.more := e_\\<rparr>);\n     v0 \\<in> V0; s' = new_root v0 s\\<lparr>state.more := e_\\<rparr>;\n     stack s = []; v0 \\<notin> dom (discovered s)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>v\\<in>dom (discovered s).\n                         (v = v0 \\<longrightarrow>\n                          (\\<forall>w\\<in>dom (discovered s).\n                              v0 \\<noteq> w \\<longrightarrow>\n                              counter s \\<noteq> \\<delta> s w)) \\<and>\n                         (v \\<noteq> v0 \\<longrightarrow>\n                          \\<delta> s v \\<noteq> counter s)\n 3. \\<lbrakk>(\\<forall>v\\<in>dom (finished s).\n                 \\<delta> s v < \\<phi> s v) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<forall>w\\<in>dom (discovered s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<delta> s v \\<noteq> \\<delta> s w) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>dom (finished s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<phi> s v \\<noteq> \\<phi> s w) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<delta> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<phi> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>E `` {v}. \\<delta> s w < \\<phi> s v);\n     cond s; DFS_invar G param s;\n     DFS_invar G param (new_root v0 s\\<lparr>state.more := e_\\<rparr>);\n     v0 \\<in> V0; s' = new_root v0 s\\<lparr>state.more := e_\\<rparr>;\n     stack s = []; v0 \\<notin> dom (discovered s)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>v\\<in>dom (discovered s).\n                         v \\<noteq> v0 \\<longrightarrow>\n                         \\<delta> s v < Suc (counter s)\n 4. \\<lbrakk>(\\<forall>v\\<in>dom (finished s).\n                 \\<delta> s v < \\<phi> s v) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<forall>w\\<in>dom (discovered s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<delta> s v \\<noteq> \\<delta> s w) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>dom (finished s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<phi> s v \\<noteq> \\<phi> s w) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<delta> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<phi> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>E `` {v}. \\<delta> s w < \\<phi> s v);\n     cond s; DFS_invar G param s;\n     DFS_invar G param (new_root v0 s\\<lparr>state.more := e_\\<rparr>);\n     v0 \\<in> V0; s' = new_root v0 s\\<lparr>state.more := e_\\<rparr>;\n     stack s = []; v0 \\<notin> dom (discovered s)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>v\\<in>dom (finished s).\n                         \\<phi> s v < Suc (counter s)\n 5. \\<lbrakk>(\\<forall>v\\<in>dom (finished s).\n                 \\<delta> s v < \\<phi> s v) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<forall>w\\<in>dom (discovered s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<delta> s v \\<noteq> \\<delta> s w) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>dom (finished s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<phi> s v \\<noteq> \\<phi> s w) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<delta> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<phi> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>E `` {v}. \\<delta> s w < \\<phi> s v);\n     cond s; DFS_invar G param s;\n     DFS_invar G param (new_root v0 s\\<lparr>state.more := e_\\<rparr>);\n     v0 \\<in> V0; s' = new_root v0 s\\<lparr>state.more := e_\\<rparr>;\n     stack s = []; v0 \\<notin> dom (discovered s)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>v\\<in>dom (finished s).\n                         (v, v0) \\<in> E \\<longrightarrow>\n                         counter s < \\<phi> s v", "apply (metis less_irrefl)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>(\\<forall>v\\<in>dom (finished s).\n                 \\<delta> s v < \\<phi> s v) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<forall>w\\<in>dom (discovered s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<delta> s v \\<noteq> \\<delta> s w) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>dom (finished s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<phi> s v \\<noteq> \\<phi> s w) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<delta> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<phi> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>E `` {v}. \\<delta> s w < \\<phi> s v);\n     cond s; DFS_invar G param s;\n     DFS_invar G param (new_root v0 s\\<lparr>state.more := e_\\<rparr>);\n     v0 \\<in> V0; s' = new_root v0 s\\<lparr>state.more := e_\\<rparr>;\n     stack s = []; v0 \\<notin> dom (discovered s)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>v\\<in>dom (discovered s).\n                         (v = v0 \\<longrightarrow>\n                          (\\<forall>w\\<in>dom (discovered s).\n                              v0 \\<noteq> w \\<longrightarrow>\n                              counter s \\<noteq> \\<delta> s w)) \\<and>\n                         (v \\<noteq> v0 \\<longrightarrow>\n                          \\<delta> s v \\<noteq> counter s)\n 2. \\<lbrakk>(\\<forall>v\\<in>dom (finished s).\n                 \\<delta> s v < \\<phi> s v) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<forall>w\\<in>dom (discovered s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<delta> s v \\<noteq> \\<delta> s w) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>dom (finished s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<phi> s v \\<noteq> \\<phi> s w) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<delta> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<phi> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>E `` {v}. \\<delta> s w < \\<phi> s v);\n     cond s; DFS_invar G param s;\n     DFS_invar G param (new_root v0 s\\<lparr>state.more := e_\\<rparr>);\n     v0 \\<in> V0; s' = new_root v0 s\\<lparr>state.more := e_\\<rparr>;\n     stack s = []; v0 \\<notin> dom (discovered s)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>v\\<in>dom (discovered s).\n                         v \\<noteq> v0 \\<longrightarrow>\n                         \\<delta> s v < Suc (counter s)\n 3. \\<lbrakk>(\\<forall>v\\<in>dom (finished s).\n                 \\<delta> s v < \\<phi> s v) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<forall>w\\<in>dom (discovered s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<delta> s v \\<noteq> \\<delta> s w) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>dom (finished s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<phi> s v \\<noteq> \\<phi> s w) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<delta> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<phi> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>E `` {v}. \\<delta> s w < \\<phi> s v);\n     cond s; DFS_invar G param s;\n     DFS_invar G param (new_root v0 s\\<lparr>state.more := e_\\<rparr>);\n     v0 \\<in> V0; s' = new_root v0 s\\<lparr>state.more := e_\\<rparr>;\n     stack s = []; v0 \\<notin> dom (discovered s)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>v\\<in>dom (finished s).\n                         \\<phi> s v < Suc (counter s)\n 4. \\<lbrakk>(\\<forall>v\\<in>dom (finished s).\n                 \\<delta> s v < \\<phi> s v) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<forall>w\\<in>dom (discovered s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<delta> s v \\<noteq> \\<delta> s w) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>dom (finished s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<phi> s v \\<noteq> \\<phi> s w) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<delta> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<phi> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>E `` {v}. \\<delta> s w < \\<phi> s v);\n     cond s; DFS_invar G param s;\n     DFS_invar G param (new_root v0 s\\<lparr>state.more := e_\\<rparr>);\n     v0 \\<in> V0; s' = new_root v0 s\\<lparr>state.more := e_\\<rparr>;\n     stack s = []; v0 \\<notin> dom (discovered s)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>v\\<in>dom (finished s).\n                         (v, v0) \\<in> E \\<longrightarrow>\n                         counter s < \\<phi> s v", "apply (metis less_irrefl)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>(\\<forall>v\\<in>dom (finished s).\n                 \\<delta> s v < \\<phi> s v) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<forall>w\\<in>dom (discovered s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<delta> s v \\<noteq> \\<delta> s w) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>dom (finished s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<phi> s v \\<noteq> \\<phi> s w) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<delta> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<phi> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>E `` {v}. \\<delta> s w < \\<phi> s v);\n     cond s; DFS_invar G param s;\n     DFS_invar G param (new_root v0 s\\<lparr>state.more := e_\\<rparr>);\n     v0 \\<in> V0; s' = new_root v0 s\\<lparr>state.more := e_\\<rparr>;\n     stack s = []; v0 \\<notin> dom (discovered s)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>v\\<in>dom (discovered s).\n                         v \\<noteq> v0 \\<longrightarrow>\n                         \\<delta> s v < Suc (counter s)\n 2. \\<lbrakk>(\\<forall>v\\<in>dom (finished s).\n                 \\<delta> s v < \\<phi> s v) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<forall>w\\<in>dom (discovered s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<delta> s v \\<noteq> \\<delta> s w) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>dom (finished s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<phi> s v \\<noteq> \\<phi> s w) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<delta> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<phi> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>E `` {v}. \\<delta> s w < \\<phi> s v);\n     cond s; DFS_invar G param s;\n     DFS_invar G param (new_root v0 s\\<lparr>state.more := e_\\<rparr>);\n     v0 \\<in> V0; s' = new_root v0 s\\<lparr>state.more := e_\\<rparr>;\n     stack s = []; v0 \\<notin> dom (discovered s)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>v\\<in>dom (finished s).\n                         \\<phi> s v < Suc (counter s)\n 3. \\<lbrakk>(\\<forall>v\\<in>dom (finished s).\n                 \\<delta> s v < \\<phi> s v) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<forall>w\\<in>dom (discovered s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<delta> s v \\<noteq> \\<delta> s w) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>dom (finished s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<phi> s v \\<noteq> \\<phi> s w) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<delta> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<phi> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>E `` {v}. \\<delta> s w < \\<phi> s v);\n     cond s; DFS_invar G param s;\n     DFS_invar G param (new_root v0 s\\<lparr>state.more := e_\\<rparr>);\n     v0 \\<in> V0; s' = new_root v0 s\\<lparr>state.more := e_\\<rparr>;\n     stack s = []; v0 \\<notin> dom (discovered s)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>v\\<in>dom (finished s).\n                         (v, v0) \\<in> E \\<longrightarrow>\n                         counter s < \\<phi> s v", "apply (metis less_SucI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>(\\<forall>v\\<in>dom (finished s).\n                 \\<delta> s v < \\<phi> s v) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<forall>w\\<in>dom (discovered s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<delta> s v \\<noteq> \\<delta> s w) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>dom (finished s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<phi> s v \\<noteq> \\<phi> s w) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<delta> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<phi> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>E `` {v}. \\<delta> s w < \\<phi> s v);\n     cond s; DFS_invar G param s;\n     DFS_invar G param (new_root v0 s\\<lparr>state.more := e_\\<rparr>);\n     v0 \\<in> V0; s' = new_root v0 s\\<lparr>state.more := e_\\<rparr>;\n     stack s = []; v0 \\<notin> dom (discovered s)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>v\\<in>dom (finished s).\n                         \\<phi> s v < Suc (counter s)\n 2. \\<lbrakk>(\\<forall>v\\<in>dom (finished s).\n                 \\<delta> s v < \\<phi> s v) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<forall>w\\<in>dom (discovered s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<delta> s v \\<noteq> \\<delta> s w) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>dom (finished s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<phi> s v \\<noteq> \\<phi> s w) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<delta> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<phi> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>E `` {v}. \\<delta> s w < \\<phi> s v);\n     cond s; DFS_invar G param s;\n     DFS_invar G param (new_root v0 s\\<lparr>state.more := e_\\<rparr>);\n     v0 \\<in> V0; s' = new_root v0 s\\<lparr>state.more := e_\\<rparr>;\n     stack s = []; v0 \\<notin> dom (discovered s)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>v\\<in>dom (finished s).\n                         (v, v0) \\<in> E \\<longrightarrow>\n                         counter s < \\<phi> s v", "apply (metis less_SucI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<forall>v\\<in>dom (finished s).\n                 \\<delta> s v < \\<phi> s v) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<forall>w\\<in>dom (discovered s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<delta> s v \\<noteq> \\<delta> s w) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>dom (finished s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<phi> s v \\<noteq> \\<phi> s w) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<delta> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<phi> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>E `` {v}. \\<delta> s w < \\<phi> s v);\n     cond s; DFS_invar G param s;\n     DFS_invar G param (new_root v0 s\\<lparr>state.more := e_\\<rparr>);\n     v0 \\<in> V0; s' = new_root v0 s\\<lparr>state.more := e_\\<rparr>;\n     stack s = []; v0 \\<notin> dom (discovered s)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>v\\<in>dom (finished s).\n                         (v, v0) \\<in> E \\<longrightarrow>\n                         counter s < \\<phi> s v", "using finished_imp_succ_discovered"], ["proof (prove)\nusing this:\n  \\<lbrakk>?v \\<in> dom (finished s); ?w \\<in> E `` {?v}\\<rbrakk>\n  \\<Longrightarrow> ?w \\<in> dom (discovered s)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<forall>v\\<in>dom (finished s).\n                 \\<delta> s v < \\<phi> s v) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<forall>w\\<in>dom (discovered s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<delta> s v \\<noteq> \\<delta> s w) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>dom (finished s).\n                    v \\<noteq> w \\<longrightarrow>\n                    \\<phi> s v \\<noteq> \\<phi> s w) \\<and>\n             (\\<forall>v\\<in>dom (discovered s).\n                 \\<delta> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<phi> s v < counter s) \\<and>\n             (\\<forall>v\\<in>dom (finished s).\n                 \\<forall>w\\<in>E `` {v}. \\<delta> s w < \\<phi> s v);\n     cond s; DFS_invar G param s;\n     DFS_invar G param (new_root v0 s\\<lparr>state.more := e_\\<rparr>);\n     v0 \\<in> V0; s' = new_root v0 s\\<lparr>state.more := e_\\<rparr>;\n     stack s = []; v0 \\<notin> dom (discovered s)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>v\\<in>dom (finished s).\n                         (v, v0) \\<in> E \\<longrightarrow>\n                         counter s < \\<phi> s v", "apply fastforce"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  timing_common_inv s'\n\ngoal (2 subgoals):\n 1. \\<And>e. timing_common_inv (empty_state e)\n 2. \\<And>s s' u v e c b.\n       \\<lbrakk>timing_common_inv s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); u = hd (stack s);\n        cross_edges s \\<subseteq> c; back_edges s \\<subseteq> b;\n        s' = s\n        \\<lparr>pending := pending s - {(u, v)}, state.more := e,\n           cross_edges := c, back_edges := b\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> timing_common_inv s'", "qed (simp_all add: timing_common_inv_def)"], ["", "end"], ["", "end"], ["", "context DFS_invar begin"], ["", "context begin"], ["", "interpretation timing_syntax"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemmas s_timing_common_inv = \n    timing_common_inv[THEN make_invar_thm]"], ["", "lemma timing_less_counter:\n    \"v \\<in> dom (discovered s) \\<Longrightarrow> \\<delta> s v < counter s\"\n    \"v \\<in> dom (finished s) \\<Longrightarrow> \\<phi> s v < counter s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (v \\<in> dom (discovered s) \\<Longrightarrow>\n     \\<delta> s v < counter s) &&&\n    (v \\<in> dom (finished s) \\<Longrightarrow> \\<phi> s v < counter s)", "using s_timing_common_inv"], ["proof (prove)\nusing this:\n  timing_common_inv s\n\ngoal (1 subgoal):\n 1. (v \\<in> dom (discovered s) \\<Longrightarrow>\n     \\<delta> s v < counter s) &&&\n    (v \\<in> dom (finished s) \\<Longrightarrow> \\<phi> s v < counter s)", "by (auto simp add: timing_common_inv_def)"], ["", "lemma disc_lt_fin:\n    \"v \\<in> dom (finished s) \\<Longrightarrow> \\<delta> s v < \\<phi> s v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> dom (finished s) \\<Longrightarrow> \\<delta> s v < \\<phi> s v", "using s_timing_common_inv"], ["proof (prove)\nusing this:\n  timing_common_inv s\n\ngoal (1 subgoal):\n 1. v \\<in> dom (finished s) \\<Longrightarrow> \\<delta> s v < \\<phi> s v", "by (auto simp add: timing_common_inv_def)"], ["", "lemma disc_unequal:\n    assumes \"v \\<in> dom (discovered s)\" \"w \\<in> dom (discovered s)\"\n    and \"v \\<noteq> w\"\n    shows \"\\<delta> s v \\<noteq> \\<delta> s w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<delta> s v \\<noteq> \\<delta> s w", "using s_timing_common_inv assms"], ["proof (prove)\nusing this:\n  timing_common_inv s\n  v \\<in> dom (discovered s)\n  w \\<in> dom (discovered s)\n  v \\<noteq> w\n\ngoal (1 subgoal):\n 1. \\<delta> s v \\<noteq> \\<delta> s w", "by (auto simp add: timing_common_inv_def)"], ["", "lemma fin_unequal:\n    assumes \"v \\<in> dom (finished s)\" \"w \\<in> dom (finished s)\"\n    and \"v \\<noteq> w\"\n    shows \"\\<phi> s v \\<noteq> \\<phi> s w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<phi> s v \\<noteq> \\<phi> s w", "using s_timing_common_inv assms"], ["proof (prove)\nusing this:\n  timing_common_inv s\n  v \\<in> dom (finished s)\n  w \\<in> dom (finished s)\n  v \\<noteq> w\n\ngoal (1 subgoal):\n 1. \\<phi> s v \\<noteq> \\<phi> s w", "by (auto simp add: timing_common_inv_def)"], ["", "lemma finished_succ_fin:\n    assumes \"v \\<in> dom (finished s)\"\n    and \"w \\<in> succ v\"\n    shows \"\\<delta> s w < \\<phi> s v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<delta> s w < \\<phi> s v", "using assms s_timing_common_inv"], ["proof (prove)\nusing this:\n  v \\<in> dom (finished s)\n  w \\<in> E `` {v}\n  timing_common_inv s\n\ngoal (1 subgoal):\n 1. \\<delta> s w < \\<phi> s v", "by (simp add: timing_common_inv_def)"], ["", "end"], ["", "end"], ["", "context param_DFS begin"], ["", "context begin"], ["", "interpretation timing_syntax"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma i_prev_stack_discover_all:\n    \"is_invar (\\<lambda>s. \\<forall> n < length (stack s). \\<forall> v \\<in> set (drop (Suc n) (stack s)). \n                   \\<delta> s (stack s ! n) > \\<delta> s v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_invar\n     (\\<lambda>s.\n         \\<forall>n<length (stack s).\n            \\<forall>v\\<in>set (drop (Suc n) (stack s)).\n               \\<delta> s v < \\<delta> s (stack s ! n))", "proof (induct rule: is_invarI)"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>e.\n       \\<forall>n<length (stack (empty_state e)).\n          \\<forall>v\\<in>set (drop (Suc n) (stack (empty_state e))).\n             \\<delta> (empty_state e) v\n             < \\<delta> (empty_state e) (stack (empty_state e) ! n)\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>\\<forall>n<length (stack s).\n                   \\<forall>v\\<in>set (drop (Suc n) (stack s)).\n                      \\<delta> s v < \\<delta> s (stack s ! n);\n        cond s; DFS_invar G param s; DFS_invar G param s'; stack s = [];\n        v0 \\<notin> dom (discovered s); v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>n<length (stack s').\n                            \\<forall>v\\<in>set (drop (Suc n) (stack s')).\n                               \\<delta> s' v < \\<delta> s' (stack s' ! n)\n 3. \\<And>s s' u e.\n       \\<lbrakk>\\<forall>n<length (stack s).\n                   \\<forall>v\\<in>set (drop (Suc n) (stack s)).\n                      \\<delta> s v < \\<delta> s (stack s ! n);\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; pending s `` {u} = {}; u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>n<length (stack s').\n                            \\<forall>v\\<in>set (drop (Suc n) (stack s')).\n                               \\<delta> s' v < \\<delta> s' (stack s' ! n)\n 4. \\<And>s s' u v e c b.\n       \\<lbrakk>\\<forall>n<length (stack s).\n                   \\<forall>v\\<in>set (drop (Suc n) (stack s)).\n                      \\<delta> s v < \\<delta> s (stack s ! n);\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); u = hd (stack s);\n        cross_edges s \\<subseteq> c; back_edges s \\<subseteq> b;\n        s' = s\n        \\<lparr>pending := pending s - {(u, v)}, state.more := e,\n           cross_edges := c, back_edges := b\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>n<length (stack s').\n                            \\<forall>v\\<in>set (drop (Suc n) (stack s')).\n                               \\<delta> s' v < \\<delta> s' (stack s' ! n)\n 5. \\<And>s s' u v e.\n       \\<lbrakk>\\<forall>n<length (stack s).\n                   \\<forall>v\\<in>set (drop (Suc n) (stack s)).\n                      \\<delta> s v < \\<delta> s (stack s ! n);\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>n<length (stack s').\n                            \\<forall>v\\<in>set (drop (Suc n) (stack s')).\n                               \\<delta> s' v < \\<delta> s' (stack s' ! n)", "case (finish s)"], ["proof (state)\nthis:\n  \\<forall>n<length (stack s).\n     \\<forall>v\\<in>set (drop (Suc n) (stack s)).\n        \\<delta> s v < \\<delta> s (stack s ! n)\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'_\n  stack s \\<noteq> []\n  pending s `` {u_} = {}\n  u_ = hd (stack s)\n  s'_ = finish u_ s\\<lparr>state.more := e_\\<rparr>\n\ngoal (5 subgoals):\n 1. \\<And>e.\n       \\<forall>n<length (stack (empty_state e)).\n          \\<forall>v\\<in>set (drop (Suc n) (stack (empty_state e))).\n             \\<delta> (empty_state e) v\n             < \\<delta> (empty_state e) (stack (empty_state e) ! n)\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>\\<forall>n<length (stack s).\n                   \\<forall>v\\<in>set (drop (Suc n) (stack s)).\n                      \\<delta> s v < \\<delta> s (stack s ! n);\n        cond s; DFS_invar G param s; DFS_invar G param s'; stack s = [];\n        v0 \\<notin> dom (discovered s); v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>n<length (stack s').\n                            \\<forall>v\\<in>set (drop (Suc n) (stack s')).\n                               \\<delta> s' v < \\<delta> s' (stack s' ! n)\n 3. \\<And>s s' u e.\n       \\<lbrakk>\\<forall>n<length (stack s).\n                   \\<forall>v\\<in>set (drop (Suc n) (stack s)).\n                      \\<delta> s v < \\<delta> s (stack s ! n);\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; pending s `` {u} = {}; u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>n<length (stack s').\n                            \\<forall>v\\<in>set (drop (Suc n) (stack s')).\n                               \\<delta> s' v < \\<delta> s' (stack s' ! n)\n 4. \\<And>s s' u v e c b.\n       \\<lbrakk>\\<forall>n<length (stack s).\n                   \\<forall>v\\<in>set (drop (Suc n) (stack s)).\n                      \\<delta> s v < \\<delta> s (stack s ! n);\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); u = hd (stack s);\n        cross_edges s \\<subseteq> c; back_edges s \\<subseteq> b;\n        s' = s\n        \\<lparr>pending := pending s - {(u, v)}, state.more := e,\n           cross_edges := c, back_edges := b\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>n<length (stack s').\n                            \\<forall>v\\<in>set (drop (Suc n) (stack s')).\n                               \\<delta> s' v < \\<delta> s' (stack s' ! n)\n 5. \\<And>s s' u v e.\n       \\<lbrakk>\\<forall>n<length (stack s).\n                   \\<forall>v\\<in>set (drop (Suc n) (stack s)).\n                      \\<delta> s v < \\<delta> s (stack s ! n);\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>n<length (stack s').\n                            \\<forall>v\\<in>set (drop (Suc n) (stack s')).\n                               \\<delta> s' v < \\<delta> s' (stack s' ! n)", "thus ?case"], ["proof (prove)\nusing this:\n  \\<forall>n<length (stack s).\n     \\<forall>v\\<in>set (drop (Suc n) (stack s)).\n        \\<delta> s v < \\<delta> s (stack s ! n)\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'_\n  stack s \\<noteq> []\n  pending s `` {u_} = {}\n  u_ = hd (stack s)\n  s'_ = finish u_ s\\<lparr>state.more := e_\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<forall>n<length (stack s'_).\n       \\<forall>v\\<in>set (drop (Suc n) (stack s'_)).\n          \\<delta> s'_ v < \\<delta> s'_ (stack s'_ ! n)", "by (cases \"stack s\") auto"], ["proof (state)\nthis:\n  \\<forall>n<length (stack s'_).\n     \\<forall>v\\<in>set (drop (Suc n) (stack s'_)).\n        \\<delta> s'_ v < \\<delta> s'_ (stack s'_ ! n)\n\ngoal (4 subgoals):\n 1. \\<And>e.\n       \\<forall>n<length (stack (empty_state e)).\n          \\<forall>v\\<in>set (drop (Suc n) (stack (empty_state e))).\n             \\<delta> (empty_state e) v\n             < \\<delta> (empty_state e) (stack (empty_state e) ! n)\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>\\<forall>n<length (stack s).\n                   \\<forall>v\\<in>set (drop (Suc n) (stack s)).\n                      \\<delta> s v < \\<delta> s (stack s ! n);\n        cond s; DFS_invar G param s; DFS_invar G param s'; stack s = [];\n        v0 \\<notin> dom (discovered s); v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>n<length (stack s').\n                            \\<forall>v\\<in>set (drop (Suc n) (stack s')).\n                               \\<delta> s' v < \\<delta> s' (stack s' ! n)\n 3. \\<And>s s' u v e c b.\n       \\<lbrakk>\\<forall>n<length (stack s).\n                   \\<forall>v\\<in>set (drop (Suc n) (stack s)).\n                      \\<delta> s v < \\<delta> s (stack s ! n);\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); u = hd (stack s);\n        cross_edges s \\<subseteq> c; back_edges s \\<subseteq> b;\n        s' = s\n        \\<lparr>pending := pending s - {(u, v)}, state.more := e,\n           cross_edges := c, back_edges := b\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>n<length (stack s').\n                            \\<forall>v\\<in>set (drop (Suc n) (stack s')).\n                               \\<delta> s' v < \\<delta> s' (stack s' ! n)\n 4. \\<And>s s' u v e.\n       \\<lbrakk>\\<forall>n<length (stack s).\n                   \\<forall>v\\<in>set (drop (Suc n) (stack s)).\n                      \\<delta> s v < \\<delta> s (stack s ! n);\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>n<length (stack s').\n                            \\<forall>v\\<in>set (drop (Suc n) (stack s')).\n                               \\<delta> s' v < \\<delta> s' (stack s' ! n)", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>e.\n       \\<forall>n<length (stack (empty_state e)).\n          \\<forall>v\\<in>set (drop (Suc n) (stack (empty_state e))).\n             \\<delta> (empty_state e) v\n             < \\<delta> (empty_state e) (stack (empty_state e) ! n)\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>\\<forall>n<length (stack s).\n                   \\<forall>v\\<in>set (drop (Suc n) (stack s)).\n                      \\<delta> s v < \\<delta> s (stack s ! n);\n        cond s; DFS_invar G param s; DFS_invar G param s'; stack s = [];\n        v0 \\<notin> dom (discovered s); v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>n<length (stack s').\n                            \\<forall>v\\<in>set (drop (Suc n) (stack s')).\n                               \\<delta> s' v < \\<delta> s' (stack s' ! n)\n 3. \\<And>s s' u v e c b.\n       \\<lbrakk>\\<forall>n<length (stack s).\n                   \\<forall>v\\<in>set (drop (Suc n) (stack s)).\n                      \\<delta> s v < \\<delta> s (stack s ! n);\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); u = hd (stack s);\n        cross_edges s \\<subseteq> c; back_edges s \\<subseteq> b;\n        s' = s\n        \\<lparr>pending := pending s - {(u, v)}, state.more := e,\n           cross_edges := c, back_edges := b\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>n<length (stack s').\n                            \\<forall>v\\<in>set (drop (Suc n) (stack s')).\n                               \\<delta> s' v < \\<delta> s' (stack s' ! n)\n 4. \\<And>s s' u v e.\n       \\<lbrakk>\\<forall>n<length (stack s).\n                   \\<forall>v\\<in>set (drop (Suc n) (stack s)).\n                      \\<delta> s v < \\<delta> s (stack s ! n);\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>n<length (stack s').\n                            \\<forall>v\\<in>set (drop (Suc n) (stack s')).\n                               \\<delta> s' v < \\<delta> s' (stack s' ! n)", "case (discover s s' u v)"], ["proof (state)\nthis:\n  \\<forall>n<length (stack s).\n     \\<forall>v\\<in>set (drop (Suc n) (stack s)).\n        \\<delta> s v < \\<delta> s (stack s ! n)\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s \\<noteq> []\n  v \\<in> pending s `` {u}\n  v \\<notin> dom (discovered s)\n  u = hd (stack s)\n  s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n  \\<lparr>state.more := e_\\<rparr>\n\ngoal (4 subgoals):\n 1. \\<And>e.\n       \\<forall>n<length (stack (empty_state e)).\n          \\<forall>v\\<in>set (drop (Suc n) (stack (empty_state e))).\n             \\<delta> (empty_state e) v\n             < \\<delta> (empty_state e) (stack (empty_state e) ! n)\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>\\<forall>n<length (stack s).\n                   \\<forall>v\\<in>set (drop (Suc n) (stack s)).\n                      \\<delta> s v < \\<delta> s (stack s ! n);\n        cond s; DFS_invar G param s; DFS_invar G param s'; stack s = [];\n        v0 \\<notin> dom (discovered s); v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>n<length (stack s').\n                            \\<forall>v\\<in>set (drop (Suc n) (stack s')).\n                               \\<delta> s' v < \\<delta> s' (stack s' ! n)\n 3. \\<And>s s' u v e c b.\n       \\<lbrakk>\\<forall>n<length (stack s).\n                   \\<forall>v\\<in>set (drop (Suc n) (stack s)).\n                      \\<delta> s v < \\<delta> s (stack s ! n);\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); u = hd (stack s);\n        cross_edges s \\<subseteq> c; back_edges s \\<subseteq> b;\n        s' = s\n        \\<lparr>pending := pending s - {(u, v)}, state.more := e,\n           cross_edges := c, back_edges := b\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>n<length (stack s').\n                            \\<forall>v\\<in>set (drop (Suc n) (stack s')).\n                               \\<delta> s' v < \\<delta> s' (stack s' ! n)\n 4. \\<And>s s' u v e.\n       \\<lbrakk>\\<forall>n<length (stack s).\n                   \\<forall>v\\<in>set (drop (Suc n) (stack s)).\n                      \\<delta> s v < \\<delta> s (stack s ! n);\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>n<length (stack s').\n                            \\<forall>v\\<in>set (drop (Suc n) (stack s')).\n                               \\<delta> s' v < \\<delta> s' (stack s' ! n)", "hence EQ[simp]: \"discovered s' = (discovered s)(v \\<mapsto> counter s)\"\n                    \"stack s' = v#stack s\""], ["proof (prove)\nusing this:\n  \\<forall>n<length (stack s).\n     \\<forall>v\\<in>set (drop (Suc n) (stack s)).\n        \\<delta> s v < \\<delta> s (stack s ! n)\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s \\<noteq> []\n  v \\<in> pending s `` {u}\n  v \\<notin> dom (discovered s)\n  u = hd (stack s)\n  s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n  \\<lparr>state.more := e_\\<rparr>\n\ngoal (1 subgoal):\n 1. discovered s' = discovered s(v \\<mapsto> counter s) &&&\n    stack s' = v # stack s", "by simp_all"], ["proof (state)\nthis:\n  discovered s' = discovered s(v \\<mapsto> counter s)\n  stack s' = v # stack s\n\ngoal (4 subgoals):\n 1. \\<And>e.\n       \\<forall>n<length (stack (empty_state e)).\n          \\<forall>v\\<in>set (drop (Suc n) (stack (empty_state e))).\n             \\<delta> (empty_state e) v\n             < \\<delta> (empty_state e) (stack (empty_state e) ! n)\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>\\<forall>n<length (stack s).\n                   \\<forall>v\\<in>set (drop (Suc n) (stack s)).\n                      \\<delta> s v < \\<delta> s (stack s ! n);\n        cond s; DFS_invar G param s; DFS_invar G param s'; stack s = [];\n        v0 \\<notin> dom (discovered s); v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>n<length (stack s').\n                            \\<forall>v\\<in>set (drop (Suc n) (stack s')).\n                               \\<delta> s' v < \\<delta> s' (stack s' ! n)\n 3. \\<And>s s' u v e c b.\n       \\<lbrakk>\\<forall>n<length (stack s).\n                   \\<forall>v\\<in>set (drop (Suc n) (stack s)).\n                      \\<delta> s v < \\<delta> s (stack s ! n);\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); u = hd (stack s);\n        cross_edges s \\<subseteq> c; back_edges s \\<subseteq> b;\n        s' = s\n        \\<lparr>pending := pending s - {(u, v)}, state.more := e,\n           cross_edges := c, back_edges := b\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>n<length (stack s').\n                            \\<forall>v\\<in>set (drop (Suc n) (stack s')).\n                               \\<delta> s' v < \\<delta> s' (stack s' ! n)\n 4. \\<And>s s' u v e.\n       \\<lbrakk>\\<forall>n<length (stack s).\n                   \\<forall>v\\<in>set (drop (Suc n) (stack s)).\n                      \\<delta> s v < \\<delta> s (stack s ! n);\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>n<length (stack s').\n                            \\<forall>v\\<in>set (drop (Suc n) (stack s')).\n                               \\<delta> s' v < \\<delta> s' (stack s' ! n)", "from discover"], ["proof (chain)\npicking this:\n  \\<forall>n<length (stack s).\n     \\<forall>v\\<in>set (drop (Suc n) (stack s)).\n        \\<delta> s v < \\<delta> s (stack s ! n)\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s \\<noteq> []\n  v \\<in> pending s `` {u}\n  v \\<notin> dom (discovered s)\n  u = hd (stack s)\n  s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n  \\<lparr>state.more := e_\\<rparr>", "interpret DFS_invar where s=s"], ["proof (prove)\nusing this:\n  \\<forall>n<length (stack s).\n     \\<forall>v\\<in>set (drop (Suc n) (stack s)).\n        \\<delta> s v < \\<delta> s (stack s ! n)\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s \\<noteq> []\n  v \\<in> pending s `` {u}\n  v \\<notin> dom (discovered s)\n  u = hd (stack s)\n  s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n  \\<lparr>state.more := e_\\<rparr>\n\ngoal (1 subgoal):\n 1. DFS_invar G param s", "by simp"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>e.\n       \\<forall>n<length (stack (empty_state e)).\n          \\<forall>v\\<in>set (drop (Suc n) (stack (empty_state e))).\n             \\<delta> (empty_state e) v\n             < \\<delta> (empty_state e) (stack (empty_state e) ! n)\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>\\<forall>n<length (stack s).\n                   \\<forall>v\\<in>set (drop (Suc n) (stack s)).\n                      \\<delta> s v < \\<delta> s (stack s ! n);\n        cond s; DFS_invar G param s; DFS_invar G param s'; stack s = [];\n        v0 \\<notin> dom (discovered s); v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>n<length (stack s').\n                            \\<forall>v\\<in>set (drop (Suc n) (stack s')).\n                               \\<delta> s' v < \\<delta> s' (stack s' ! n)\n 3. \\<And>s s' u v e c b.\n       \\<lbrakk>\\<forall>n<length (stack s).\n                   \\<forall>v\\<in>set (drop (Suc n) (stack s)).\n                      \\<delta> s v < \\<delta> s (stack s ! n);\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); u = hd (stack s);\n        cross_edges s \\<subseteq> c; back_edges s \\<subseteq> b;\n        s' = s\n        \\<lparr>pending := pending s - {(u, v)}, state.more := e,\n           cross_edges := c, back_edges := b\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>n<length (stack s').\n                            \\<forall>v\\<in>set (drop (Suc n) (stack s')).\n                               \\<delta> s' v < \\<delta> s' (stack s' ! n)\n 4. \\<And>s s' u v e.\n       \\<lbrakk>\\<forall>n<length (stack s).\n                   \\<forall>v\\<in>set (drop (Suc n) (stack s)).\n                      \\<delta> s v < \\<delta> s (stack s ! n);\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>n<length (stack s').\n                            \\<forall>v\\<in>set (drop (Suc n) (stack s')).\n                               \\<delta> s' v < \\<delta> s' (stack s' ! n)", "from discover stack_discovered"], ["proof (chain)\npicking this:\n  \\<forall>n<length (stack s).\n     \\<forall>v\\<in>set (drop (Suc n) (stack s)).\n        \\<delta> s v < \\<delta> s (stack s ! n)\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s \\<noteq> []\n  v \\<in> pending s `` {u}\n  v \\<notin> dom (discovered s)\n  u = hd (stack s)\n  s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n  \\<lparr>state.more := e_\\<rparr>\n  set (stack s) \\<subseteq> dom (discovered s)", "have v_ni: \"v \\<notin> set (stack s)\""], ["proof (prove)\nusing this:\n  \\<forall>n<length (stack s).\n     \\<forall>v\\<in>set (drop (Suc n) (stack s)).\n        \\<delta> s v < \\<delta> s (stack s ! n)\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s \\<noteq> []\n  v \\<in> pending s `` {u}\n  v \\<notin> dom (discovered s)\n  u = hd (stack s)\n  s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n  \\<lparr>state.more := e_\\<rparr>\n  set (stack s) \\<subseteq> dom (discovered s)\n\ngoal (1 subgoal):\n 1. v \\<notin> set (stack s)", "by auto"], ["proof (state)\nthis:\n  v \\<notin> set (stack s)\n\ngoal (4 subgoals):\n 1. \\<And>e.\n       \\<forall>n<length (stack (empty_state e)).\n          \\<forall>v\\<in>set (drop (Suc n) (stack (empty_state e))).\n             \\<delta> (empty_state e) v\n             < \\<delta> (empty_state e) (stack (empty_state e) ! n)\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>\\<forall>n<length (stack s).\n                   \\<forall>v\\<in>set (drop (Suc n) (stack s)).\n                      \\<delta> s v < \\<delta> s (stack s ! n);\n        cond s; DFS_invar G param s; DFS_invar G param s'; stack s = [];\n        v0 \\<notin> dom (discovered s); v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>n<length (stack s').\n                            \\<forall>v\\<in>set (drop (Suc n) (stack s')).\n                               \\<delta> s' v < \\<delta> s' (stack s' ! n)\n 3. \\<And>s s' u v e c b.\n       \\<lbrakk>\\<forall>n<length (stack s).\n                   \\<forall>v\\<in>set (drop (Suc n) (stack s)).\n                      \\<delta> s v < \\<delta> s (stack s ! n);\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); u = hd (stack s);\n        cross_edges s \\<subseteq> c; back_edges s \\<subseteq> b;\n        s' = s\n        \\<lparr>pending := pending s - {(u, v)}, state.more := e,\n           cross_edges := c, back_edges := b\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>n<length (stack s').\n                            \\<forall>v\\<in>set (drop (Suc n) (stack s')).\n                               \\<delta> s' v < \\<delta> s' (stack s' ! n)\n 4. \\<And>s s' u v e.\n       \\<lbrakk>\\<forall>n<length (stack s).\n                   \\<forall>v\\<in>set (drop (Suc n) (stack s)).\n                      \\<delta> s v < \\<delta> s (stack s ! n);\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>n<length (stack s').\n                            \\<forall>v\\<in>set (drop (Suc n) (stack s')).\n                               \\<delta> s' v < \\<delta> s' (stack s' ! n)", "from stack_discovered timing_less_counter"], ["proof (chain)\npicking this:\n  set (stack s) \\<subseteq> dom (discovered s)\n  ?v \\<in> dom (discovered s) \\<Longrightarrow> \\<delta> s ?v < counter s\n  ?v \\<in> dom (finished s) \\<Longrightarrow> \\<phi> s ?v < counter s", "have \n      \"\\<And>w. w \\<in> set (stack s) \\<Longrightarrow> \\<delta> s w < counter s\""], ["proof (prove)\nusing this:\n  set (stack s) \\<subseteq> dom (discovered s)\n  ?v \\<in> dom (discovered s) \\<Longrightarrow> \\<delta> s ?v < counter s\n  ?v \\<in> dom (finished s) \\<Longrightarrow> \\<phi> s ?v < counter s\n\ngoal (1 subgoal):\n 1. \\<And>w.\n       w \\<in> set (stack s) \\<Longrightarrow> \\<delta> s w < counter s", "by blast"], ["proof (state)\nthis:\n  ?w5 \\<in> set (stack s) \\<Longrightarrow> \\<delta> s ?w5 < counter s\n\ngoal (4 subgoals):\n 1. \\<And>e.\n       \\<forall>n<length (stack (empty_state e)).\n          \\<forall>v\\<in>set (drop (Suc n) (stack (empty_state e))).\n             \\<delta> (empty_state e) v\n             < \\<delta> (empty_state e) (stack (empty_state e) ! n)\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>\\<forall>n<length (stack s).\n                   \\<forall>v\\<in>set (drop (Suc n) (stack s)).\n                      \\<delta> s v < \\<delta> s (stack s ! n);\n        cond s; DFS_invar G param s; DFS_invar G param s'; stack s = [];\n        v0 \\<notin> dom (discovered s); v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>n<length (stack s').\n                            \\<forall>v\\<in>set (drop (Suc n) (stack s')).\n                               \\<delta> s' v < \\<delta> s' (stack s' ! n)\n 3. \\<And>s s' u v e c b.\n       \\<lbrakk>\\<forall>n<length (stack s).\n                   \\<forall>v\\<in>set (drop (Suc n) (stack s)).\n                      \\<delta> s v < \\<delta> s (stack s ! n);\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); u = hd (stack s);\n        cross_edges s \\<subseteq> c; back_edges s \\<subseteq> b;\n        s' = s\n        \\<lparr>pending := pending s - {(u, v)}, state.more := e,\n           cross_edges := c, back_edges := b\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>n<length (stack s').\n                            \\<forall>v\\<in>set (drop (Suc n) (stack s')).\n                               \\<delta> s' v < \\<delta> s' (stack s' ! n)\n 4. \\<And>s s' u v e.\n       \\<lbrakk>\\<forall>n<length (stack s).\n                   \\<forall>v\\<in>set (drop (Suc n) (stack s)).\n                      \\<delta> s v < \\<delta> s (stack s ! n);\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>n<length (stack s').\n                            \\<forall>v\\<in>set (drop (Suc n) (stack s')).\n                               \\<delta> s' v < \\<delta> s' (stack s' ! n)", "with v_ni"], ["proof (chain)\npicking this:\n  v \\<notin> set (stack s)\n  ?w5 \\<in> set (stack s) \\<Longrightarrow> \\<delta> s ?w5 < counter s", "have \"\\<And>w. w \\<in> set (stack s) \\<Longrightarrow> \\<delta> s' w < \\<delta> s' v\""], ["proof (prove)\nusing this:\n  v \\<notin> set (stack s)\n  ?w5 \\<in> set (stack s) \\<Longrightarrow> \\<delta> s ?w5 < counter s\n\ngoal (1 subgoal):\n 1. \\<And>w.\n       w \\<in> set (stack s) \\<Longrightarrow> \\<delta> s' w < \\<delta> s' v", "by auto"], ["proof (state)\nthis:\n  ?w5 \\<in> set (stack s) \\<Longrightarrow> \\<delta> s' ?w5 < \\<delta> s' v\n\ngoal (4 subgoals):\n 1. \\<And>e.\n       \\<forall>n<length (stack (empty_state e)).\n          \\<forall>v\\<in>set (drop (Suc n) (stack (empty_state e))).\n             \\<delta> (empty_state e) v\n             < \\<delta> (empty_state e) (stack (empty_state e) ! n)\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>\\<forall>n<length (stack s).\n                   \\<forall>v\\<in>set (drop (Suc n) (stack s)).\n                      \\<delta> s v < \\<delta> s (stack s ! n);\n        cond s; DFS_invar G param s; DFS_invar G param s'; stack s = [];\n        v0 \\<notin> dom (discovered s); v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>n<length (stack s').\n                            \\<forall>v\\<in>set (drop (Suc n) (stack s')).\n                               \\<delta> s' v < \\<delta> s' (stack s' ! n)\n 3. \\<And>s s' u v e c b.\n       \\<lbrakk>\\<forall>n<length (stack s).\n                   \\<forall>v\\<in>set (drop (Suc n) (stack s)).\n                      \\<delta> s v < \\<delta> s (stack s ! n);\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); u = hd (stack s);\n        cross_edges s \\<subseteq> c; back_edges s \\<subseteq> b;\n        s' = s\n        \\<lparr>pending := pending s - {(u, v)}, state.more := e,\n           cross_edges := c, back_edges := b\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>n<length (stack s').\n                            \\<forall>v\\<in>set (drop (Suc n) (stack s')).\n                               \\<delta> s' v < \\<delta> s' (stack s' ! n)\n 4. \\<And>s s' u v e.\n       \\<lbrakk>\\<forall>n<length (stack s).\n                   \\<forall>v\\<in>set (drop (Suc n) (stack s)).\n                      \\<delta> s v < \\<delta> s (stack s ! n);\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>n<length (stack s').\n                            \\<forall>v\\<in>set (drop (Suc n) (stack s')).\n                               \\<delta> s' v < \\<delta> s' (stack s' ! n)", "hence \"\\<And>w. w \\<in> set (drop (Suc 0) (stack s')) \\<Longrightarrow> \\<delta> s' w < \\<delta> s' (stack s' ! 0)\""], ["proof (prove)\nusing this:\n  ?w5 \\<in> set (stack s) \\<Longrightarrow> \\<delta> s' ?w5 < \\<delta> s' v\n\ngoal (1 subgoal):\n 1. \\<And>w.\n       w \\<in> set (drop (Suc 0) (stack s')) \\<Longrightarrow>\n       \\<delta> s' w < \\<delta> s' (stack s' ! 0)", "by auto"], ["proof (state)\nthis:\n  ?w5 \\<in> set (drop (Suc 0) (stack s')) \\<Longrightarrow>\n  \\<delta> s' ?w5 < \\<delta> s' (stack s' ! 0)\n\ngoal (4 subgoals):\n 1. \\<And>e.\n       \\<forall>n<length (stack (empty_state e)).\n          \\<forall>v\\<in>set (drop (Suc n) (stack (empty_state e))).\n             \\<delta> (empty_state e) v\n             < \\<delta> (empty_state e) (stack (empty_state e) ! n)\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>\\<forall>n<length (stack s).\n                   \\<forall>v\\<in>set (drop (Suc n) (stack s)).\n                      \\<delta> s v < \\<delta> s (stack s ! n);\n        cond s; DFS_invar G param s; DFS_invar G param s'; stack s = [];\n        v0 \\<notin> dom (discovered s); v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>n<length (stack s').\n                            \\<forall>v\\<in>set (drop (Suc n) (stack s')).\n                               \\<delta> s' v < \\<delta> s' (stack s' ! n)\n 3. \\<And>s s' u v e c b.\n       \\<lbrakk>\\<forall>n<length (stack s).\n                   \\<forall>v\\<in>set (drop (Suc n) (stack s)).\n                      \\<delta> s v < \\<delta> s (stack s ! n);\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); u = hd (stack s);\n        cross_edges s \\<subseteq> c; back_edges s \\<subseteq> b;\n        s' = s\n        \\<lparr>pending := pending s - {(u, v)}, state.more := e,\n           cross_edges := c, back_edges := b\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>n<length (stack s').\n                            \\<forall>v\\<in>set (drop (Suc n) (stack s')).\n                               \\<delta> s' v < \\<delta> s' (stack s' ! n)\n 4. \\<And>s s' u v e.\n       \\<lbrakk>\\<forall>n<length (stack s).\n                   \\<forall>v\\<in>set (drop (Suc n) (stack s)).\n                      \\<delta> s v < \\<delta> s (stack s ! n);\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>n<length (stack s').\n                            \\<forall>v\\<in>set (drop (Suc n) (stack s')).\n                               \\<delta> s' v < \\<delta> s' (stack s' ! n)", "moreover"], ["proof (state)\nthis:\n  ?w5 \\<in> set (drop (Suc 0) (stack s')) \\<Longrightarrow>\n  \\<delta> s' ?w5 < \\<delta> s' (stack s' ! 0)\n\ngoal (4 subgoals):\n 1. \\<And>e.\n       \\<forall>n<length (stack (empty_state e)).\n          \\<forall>v\\<in>set (drop (Suc n) (stack (empty_state e))).\n             \\<delta> (empty_state e) v\n             < \\<delta> (empty_state e) (stack (empty_state e) ! n)\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>\\<forall>n<length (stack s).\n                   \\<forall>v\\<in>set (drop (Suc n) (stack s)).\n                      \\<delta> s v < \\<delta> s (stack s ! n);\n        cond s; DFS_invar G param s; DFS_invar G param s'; stack s = [];\n        v0 \\<notin> dom (discovered s); v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>n<length (stack s').\n                            \\<forall>v\\<in>set (drop (Suc n) (stack s')).\n                               \\<delta> s' v < \\<delta> s' (stack s' ! n)\n 3. \\<And>s s' u v e c b.\n       \\<lbrakk>\\<forall>n<length (stack s).\n                   \\<forall>v\\<in>set (drop (Suc n) (stack s)).\n                      \\<delta> s v < \\<delta> s (stack s ! n);\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); u = hd (stack s);\n        cross_edges s \\<subseteq> c; back_edges s \\<subseteq> b;\n        s' = s\n        \\<lparr>pending := pending s - {(u, v)}, state.more := e,\n           cross_edges := c, back_edges := b\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>n<length (stack s').\n                            \\<forall>v\\<in>set (drop (Suc n) (stack s')).\n                               \\<delta> s' v < \\<delta> s' (stack s' ! n)\n 4. \\<And>s s' u v e.\n       \\<lbrakk>\\<forall>n<length (stack s).\n                   \\<forall>v\\<in>set (drop (Suc n) (stack s)).\n                      \\<delta> s v < \\<delta> s (stack s ! n);\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>n<length (stack s').\n                            \\<forall>v\\<in>set (drop (Suc n) (stack s')).\n                               \\<delta> s' v < \\<delta> s' (stack s' ! n)", "from v_ni"], ["proof (chain)\npicking this:\n  v \\<notin> set (stack s)", "have \n      \"\\<And>n. \\<lbrakk>n < (length (stack s')); n > 0\\<rbrakk>\n      \\<Longrightarrow> \\<delta> s' (stack s' ! n) = \\<delta> s (stack s' ! n)\""], ["proof (prove)\nusing this:\n  v \\<notin> set (stack s)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>n < length (stack s'); 0 < n\\<rbrakk>\n       \\<Longrightarrow> \\<delta> s' (stack s' ! n) =\n                         \\<delta> s (stack s' ! n)", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>?n5 < length (stack s'); 0 < ?n5\\<rbrakk>\n  \\<Longrightarrow> \\<delta> s' (stack s' ! ?n5) =\n                    \\<delta> s (stack s' ! ?n5)\n\ngoal (4 subgoals):\n 1. \\<And>e.\n       \\<forall>n<length (stack (empty_state e)).\n          \\<forall>v\\<in>set (drop (Suc n) (stack (empty_state e))).\n             \\<delta> (empty_state e) v\n             < \\<delta> (empty_state e) (stack (empty_state e) ! n)\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>\\<forall>n<length (stack s).\n                   \\<forall>v\\<in>set (drop (Suc n) (stack s)).\n                      \\<delta> s v < \\<delta> s (stack s ! n);\n        cond s; DFS_invar G param s; DFS_invar G param s'; stack s = [];\n        v0 \\<notin> dom (discovered s); v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>n<length (stack s').\n                            \\<forall>v\\<in>set (drop (Suc n) (stack s')).\n                               \\<delta> s' v < \\<delta> s' (stack s' ! n)\n 3. \\<And>s s' u v e c b.\n       \\<lbrakk>\\<forall>n<length (stack s).\n                   \\<forall>v\\<in>set (drop (Suc n) (stack s)).\n                      \\<delta> s v < \\<delta> s (stack s ! n);\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); u = hd (stack s);\n        cross_edges s \\<subseteq> c; back_edges s \\<subseteq> b;\n        s' = s\n        \\<lparr>pending := pending s - {(u, v)}, state.more := e,\n           cross_edges := c, back_edges := b\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>n<length (stack s').\n                            \\<forall>v\\<in>set (drop (Suc n) (stack s')).\n                               \\<delta> s' v < \\<delta> s' (stack s' ! n)\n 4. \\<And>s s' u v e.\n       \\<lbrakk>\\<forall>n<length (stack s).\n                   \\<forall>v\\<in>set (drop (Suc n) (stack s)).\n                      \\<delta> s v < \\<delta> s (stack s ! n);\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>n<length (stack s').\n                            \\<forall>v\\<in>set (drop (Suc n) (stack s')).\n                               \\<delta> s' v < \\<delta> s' (stack s' ! n)", "with discover(1) v_ni"], ["proof (chain)\npicking this:\n  \\<forall>n<length (stack s).\n     \\<forall>v\\<in>set (drop (Suc n) (stack s)).\n        \\<delta> s v < \\<delta> s (stack s ! n)\n  v \\<notin> set (stack s)\n  \\<lbrakk>?n5 < length (stack s'); 0 < ?n5\\<rbrakk>\n  \\<Longrightarrow> \\<delta> s' (stack s' ! ?n5) =\n                    \\<delta> s (stack s' ! ?n5)", "have  \"\\<And>n. \\<lbrakk>n < (length (stack s')) - 1; n > 0\\<rbrakk> \n      \\<Longrightarrow> \\<forall> w \\<in> set (drop (Suc n) (stack s')). \\<delta> s' (stack s' ! n) > \\<delta> s' w\""], ["proof (prove)\nusing this:\n  \\<forall>n<length (stack s).\n     \\<forall>v\\<in>set (drop (Suc n) (stack s)).\n        \\<delta> s v < \\<delta> s (stack s ! n)\n  v \\<notin> set (stack s)\n  \\<lbrakk>?n5 < length (stack s'); 0 < ?n5\\<rbrakk>\n  \\<Longrightarrow> \\<delta> s' (stack s' ! ?n5) =\n                    \\<delta> s (stack s' ! ?n5)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>n < length (stack s') - 1; 0 < n\\<rbrakk>\n       \\<Longrightarrow> \\<forall>w\\<in>set (drop (Suc n) (stack s')).\n                            \\<delta> s' w < \\<delta> s' (stack s' ! n)", "by (auto dest: in_set_dropD)"], ["proof (state)\nthis:\n  \\<lbrakk>?n5 < length (stack s') - 1; 0 < ?n5\\<rbrakk>\n  \\<Longrightarrow> \\<forall>w\\<in>set (drop (Suc ?n5) (stack s')).\n                       \\<delta> s' w < \\<delta> s' (stack s' ! ?n5)\n\ngoal (4 subgoals):\n 1. \\<And>e.\n       \\<forall>n<length (stack (empty_state e)).\n          \\<forall>v\\<in>set (drop (Suc n) (stack (empty_state e))).\n             \\<delta> (empty_state e) v\n             < \\<delta> (empty_state e) (stack (empty_state e) ! n)\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>\\<forall>n<length (stack s).\n                   \\<forall>v\\<in>set (drop (Suc n) (stack s)).\n                      \\<delta> s v < \\<delta> s (stack s ! n);\n        cond s; DFS_invar G param s; DFS_invar G param s'; stack s = [];\n        v0 \\<notin> dom (discovered s); v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>n<length (stack s').\n                            \\<forall>v\\<in>set (drop (Suc n) (stack s')).\n                               \\<delta> s' v < \\<delta> s' (stack s' ! n)\n 3. \\<And>s s' u v e c b.\n       \\<lbrakk>\\<forall>n<length (stack s).\n                   \\<forall>v\\<in>set (drop (Suc n) (stack s)).\n                      \\<delta> s v < \\<delta> s (stack s ! n);\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); u = hd (stack s);\n        cross_edges s \\<subseteq> c; back_edges s \\<subseteq> b;\n        s' = s\n        \\<lparr>pending := pending s - {(u, v)}, state.more := e,\n           cross_edges := c, back_edges := b\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>n<length (stack s').\n                            \\<forall>v\\<in>set (drop (Suc n) (stack s')).\n                               \\<delta> s' v < \\<delta> s' (stack s' ! n)\n 4. \\<And>s s' u v e.\n       \\<lbrakk>\\<forall>n<length (stack s).\n                   \\<forall>v\\<in>set (drop (Suc n) (stack s)).\n                      \\<delta> s v < \\<delta> s (stack s ! n);\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>n<length (stack s').\n                            \\<forall>v\\<in>set (drop (Suc n) (stack s')).\n                               \\<delta> s' v < \\<delta> s' (stack s' ! n)", "ultimately"], ["proof (chain)\npicking this:\n  ?w5 \\<in> set (drop (Suc 0) (stack s')) \\<Longrightarrow>\n  \\<delta> s' ?w5 < \\<delta> s' (stack s' ! 0)\n  \\<lbrakk>?n5 < length (stack s') - 1; 0 < ?n5\\<rbrakk>\n  \\<Longrightarrow> \\<forall>w\\<in>set (drop (Suc ?n5) (stack s')).\n                       \\<delta> s' w < \\<delta> s' (stack s' ! ?n5)", "show ?case"], ["proof (prove)\nusing this:\n  ?w5 \\<in> set (drop (Suc 0) (stack s')) \\<Longrightarrow>\n  \\<delta> s' ?w5 < \\<delta> s' (stack s' ! 0)\n  \\<lbrakk>?n5 < length (stack s') - 1; 0 < ?n5\\<rbrakk>\n  \\<Longrightarrow> \\<forall>w\\<in>set (drop (Suc ?n5) (stack s')).\n                       \\<delta> s' w < \\<delta> s' (stack s' ! ?n5)\n\ngoal (1 subgoal):\n 1. \\<forall>n<length (stack s').\n       \\<forall>v\\<in>set (drop (Suc n) (stack s')).\n          \\<delta> s' v < \\<delta> s' (stack s' ! n)", "by (metis drop_Suc_Cons length_drop length_pos_if_in_set length_tl \n        list.sel(3) neq0_conv nth_Cons_0 EQ(2) zero_less_diff)"], ["proof (state)\nthis:\n  \\<forall>n<length (stack s').\n     \\<forall>v\\<in>set (drop (Suc n) (stack s')).\n        \\<delta> s' v < \\<delta> s' (stack s' ! n)\n\ngoal (3 subgoals):\n 1. \\<And>e.\n       \\<forall>n<length (stack (empty_state e)).\n          \\<forall>v\\<in>set (drop (Suc n) (stack (empty_state e))).\n             \\<delta> (empty_state e) v\n             < \\<delta> (empty_state e) (stack (empty_state e) ! n)\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>\\<forall>n<length (stack s).\n                   \\<forall>v\\<in>set (drop (Suc n) (stack s)).\n                      \\<delta> s v < \\<delta> s (stack s ! n);\n        cond s; DFS_invar G param s; DFS_invar G param s'; stack s = [];\n        v0 \\<notin> dom (discovered s); v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>n<length (stack s').\n                            \\<forall>v\\<in>set (drop (Suc n) (stack s')).\n                               \\<delta> s' v < \\<delta> s' (stack s' ! n)\n 3. \\<And>s s' u v e c b.\n       \\<lbrakk>\\<forall>n<length (stack s).\n                   \\<forall>v\\<in>set (drop (Suc n) (stack s)).\n                      \\<delta> s v < \\<delta> s (stack s ! n);\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); u = hd (stack s);\n        cross_edges s \\<subseteq> c; back_edges s \\<subseteq> b;\n        s' = s\n        \\<lparr>pending := pending s - {(u, v)}, state.more := e,\n           cross_edges := c, back_edges := b\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>n<length (stack s').\n                            \\<forall>v\\<in>set (drop (Suc n) (stack s')).\n                               \\<delta> s' v < \\<delta> s' (stack s' ! n)", "qed simp_all"], ["", "end"], ["", "end"], ["", "context DFS_invar begin"], ["", "context begin"], ["", "interpretation timing_syntax"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemmas prev_stack_discover_all \n    = i_prev_stack_discover_all[THEN make_invar_thm]"], ["", "lemma prev_stack_discover:\n    \"\\<lbrakk>n < length (stack s); v \\<in> set (drop (Suc n) (stack s)) \\<rbrakk>\n     \\<Longrightarrow> \\<delta> s (stack s ! n) > \\<delta> s v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n < length (stack s);\n     v \\<in> set (drop (Suc n) (stack s))\\<rbrakk>\n    \\<Longrightarrow> \\<delta> s v < \\<delta> s (stack s ! n)", "by (metis prev_stack_discover_all)"], ["", "lemma Suc_stack_discover:\n    assumes n: \"n < (length (stack s)) - 1\"\n    shows \"\\<delta> s (stack s ! n) > \\<delta> s (stack s ! Suc n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<delta> s (stack s ! Suc n) < \\<delta> s (stack s ! n)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<delta> s (stack s ! Suc n) < \\<delta> s (stack s ! n)", "from prev_stack_discover assms"], ["proof (chain)\npicking this:\n  \\<lbrakk>?n < length (stack s);\n   ?v \\<in> set (drop (Suc ?n) (stack s))\\<rbrakk>\n  \\<Longrightarrow> \\<delta> s ?v < \\<delta> s (stack s ! ?n)\n  n < length (stack s) - 1", "have \n      \"\\<And> v. v \\<in> set (drop (Suc n) (stack s)) \\<Longrightarrow> \\<delta> s (stack s ! n) > \\<delta> s v\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?n < length (stack s);\n   ?v \\<in> set (drop (Suc ?n) (stack s))\\<rbrakk>\n  \\<Longrightarrow> \\<delta> s ?v < \\<delta> s (stack s ! ?n)\n  n < length (stack s) - 1\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       v \\<in> set (drop (Suc n) (stack s)) \\<Longrightarrow>\n       \\<delta> s v < \\<delta> s (stack s ! n)", "by fastforce"], ["proof (state)\nthis:\n  ?v5 \\<in> set (drop (Suc n) (stack s)) \\<Longrightarrow>\n  \\<delta> s ?v5 < \\<delta> s (stack s ! n)\n\ngoal (1 subgoal):\n 1. \\<delta> s (stack s ! Suc n) < \\<delta> s (stack s ! n)", "moreover"], ["proof (state)\nthis:\n  ?v5 \\<in> set (drop (Suc n) (stack s)) \\<Longrightarrow>\n  \\<delta> s ?v5 < \\<delta> s (stack s ! n)\n\ngoal (1 subgoal):\n 1. \\<delta> s (stack s ! Suc n) < \\<delta> s (stack s ! n)", "from n"], ["proof (chain)\npicking this:\n  n < length (stack s) - 1", "have \"stack s ! Suc n \\<in> set (drop (Suc n) (stack s))\""], ["proof (prove)\nusing this:\n  n < length (stack s) - 1\n\ngoal (1 subgoal):\n 1. stack s ! Suc n \\<in> set (drop (Suc n) (stack s))", "using in_set_conv_nth"], ["proof (prove)\nusing this:\n  n < length (stack s) - 1\n  (?x \\<in> set ?xs) = (\\<exists>i<length ?xs. ?xs ! i = ?x)\n\ngoal (1 subgoal):\n 1. stack s ! Suc n \\<in> set (drop (Suc n) (stack s))", "by fastforce"], ["proof (state)\nthis:\n  stack s ! Suc n \\<in> set (drop (Suc n) (stack s))\n\ngoal (1 subgoal):\n 1. \\<delta> s (stack s ! Suc n) < \\<delta> s (stack s ! n)", "ultimately"], ["proof (chain)\npicking this:\n  ?v5 \\<in> set (drop (Suc n) (stack s)) \\<Longrightarrow>\n  \\<delta> s ?v5 < \\<delta> s (stack s ! n)\n  stack s ! Suc n \\<in> set (drop (Suc n) (stack s))", "show ?thesis"], ["proof (prove)\nusing this:\n  ?v5 \\<in> set (drop (Suc n) (stack s)) \\<Longrightarrow>\n  \\<delta> s ?v5 < \\<delta> s (stack s ! n)\n  stack s ! Suc n \\<in> set (drop (Suc n) (stack s))\n\ngoal (1 subgoal):\n 1. \\<delta> s (stack s ! Suc n) < \\<delta> s (stack s ! n)", "."], ["proof (state)\nthis:\n  \\<delta> s (stack s ! Suc n) < \\<delta> s (stack s ! n)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma tl_lt_stack_hd_discover:\n    assumes notempty: \"stack s \\<noteq> []\"\n    and \"x \\<in> set (tl (stack s))\"\n    shows \"\\<delta> s x < \\<delta> s (hd (stack s))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<delta> s x < \\<delta> s (hd (stack s))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<delta> s x < \\<delta> s (hd (stack s))", "from notempty"], ["proof (chain)\npicking this:\n  stack s \\<noteq> []", "obtain y ys where \"stack s = y#ys\""], ["proof (prove)\nusing this:\n  stack s \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<And>y ys.\n        stack s = y # ys \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis list.exhaust)"], ["proof (state)\nthis:\n  stack s = y # ys\n\ngoal (1 subgoal):\n 1. \\<delta> s x < \\<delta> s (hd (stack s))", "with assms"], ["proof (chain)\npicking this:\n  stack s \\<noteq> []\n  x \\<in> set (tl (stack s))\n  stack s = y # ys", "show ?thesis"], ["proof (prove)\nusing this:\n  stack s \\<noteq> []\n  x \\<in> set (tl (stack s))\n  stack s = y # ys\n\ngoal (1 subgoal):\n 1. \\<delta> s x < \\<delta> s (hd (stack s))", "using prev_stack_discover"], ["proof (prove)\nusing this:\n  stack s \\<noteq> []\n  x \\<in> set (tl (stack s))\n  stack s = y # ys\n  \\<lbrakk>?n < length (stack s);\n   ?v \\<in> set (drop (Suc ?n) (stack s))\\<rbrakk>\n  \\<Longrightarrow> \\<delta> s ?v < \\<delta> s (stack s ! ?n)\n\ngoal (1 subgoal):\n 1. \\<delta> s x < \\<delta> s (hd (stack s))", "by (cases ys) force+"], ["proof (state)\nthis:\n  \\<delta> s x < \\<delta> s (hd (stack s))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma stack_nth_order:\n    assumes l: \"i < length (stack s)\" \"j < length (stack s)\"\n    shows \"\\<delta> s (stack s ! i) < \\<delta> s (stack s ! j) \\<longleftrightarrow> i > j\" (is \"\\<delta> s ?i < \\<delta> s ?j \\<longleftrightarrow> _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<delta> s (stack s ! i) < \\<delta> s (stack s ! j)) = (j < i)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<delta> s (stack s ! i) < \\<delta> s (stack s ! j) \\<Longrightarrow>\n    j < i\n 2. j < i \\<Longrightarrow>\n    \\<delta> s (stack s ! i) < \\<delta> s (stack s ! j)", "assume \\<delta>: \"\\<delta> s ?i < \\<delta> s ?j\""], ["proof (state)\nthis:\n  \\<delta> s (stack s ! i) < \\<delta> s (stack s ! j)\n\ngoal (2 subgoals):\n 1. \\<delta> s (stack s ! i) < \\<delta> s (stack s ! j) \\<Longrightarrow>\n    j < i\n 2. j < i \\<Longrightarrow>\n    \\<delta> s (stack s ! i) < \\<delta> s (stack s ! j)", "from l stack_set_def"], ["proof (chain)\npicking this:\n  i < length (stack s)\n  j < length (stack s)\n  set (stack s) = dom (discovered s) - dom (finished s)", "have \n      disc: \"?i \\<in> dom (discovered s)\" \"?j \\<in> dom (discovered s)\""], ["proof (prove)\nusing this:\n  i < length (stack s)\n  j < length (stack s)\n  set (stack s) = dom (discovered s) - dom (finished s)\n\ngoal (1 subgoal):\n 1. stack s ! i \\<in> dom (discovered s) &&&\n    stack s ! j \\<in> dom (discovered s)", "by auto"], ["proof (state)\nthis:\n  stack s ! i \\<in> dom (discovered s)\n  stack s ! j \\<in> dom (discovered s)\n\ngoal (2 subgoals):\n 1. \\<delta> s (stack s ! i) < \\<delta> s (stack s ! j) \\<Longrightarrow>\n    j < i\n 2. j < i \\<Longrightarrow>\n    \\<delta> s (stack s ! i) < \\<delta> s (stack s ! j)", "with disc_unequal[OF disc] \\<delta>"], ["proof (chain)\npicking this:\n  stack s ! i \\<noteq> stack s ! j \\<Longrightarrow>\n  \\<delta> s (stack s ! i) \\<noteq> \\<delta> s (stack s ! j)\n  \\<delta> s (stack s ! i) < \\<delta> s (stack s ! j)\n  stack s ! i \\<in> dom (discovered s)\n  stack s ! j \\<in> dom (discovered s)", "have \"i \\<noteq> j\""], ["proof (prove)\nusing this:\n  stack s ! i \\<noteq> stack s ! j \\<Longrightarrow>\n  \\<delta> s (stack s ! i) \\<noteq> \\<delta> s (stack s ! j)\n  \\<delta> s (stack s ! i) < \\<delta> s (stack s ! j)\n  stack s ! i \\<in> dom (discovered s)\n  stack s ! j \\<in> dom (discovered s)\n\ngoal (1 subgoal):\n 1. i \\<noteq> j", "by auto"], ["proof (state)\nthis:\n  i \\<noteq> j\n\ngoal (2 subgoals):\n 1. \\<delta> s (stack s ! i) < \\<delta> s (stack s ! j) \\<Longrightarrow>\n    j < i\n 2. j < i \\<Longrightarrow>\n    \\<delta> s (stack s ! i) < \\<delta> s (stack s ! j)", "moreover"], ["proof (state)\nthis:\n  i \\<noteq> j\n\ngoal (2 subgoals):\n 1. \\<delta> s (stack s ! i) < \\<delta> s (stack s ! j) \\<Longrightarrow>\n    j < i\n 2. j < i \\<Longrightarrow>\n    \\<delta> s (stack s ! i) < \\<delta> s (stack s ! j)", "{"], ["proof (state)\nthis:\n  i \\<noteq> j\n\ngoal (2 subgoals):\n 1. \\<delta> s (stack s ! i) < \\<delta> s (stack s ! j) \\<Longrightarrow>\n    j < i\n 2. j < i \\<Longrightarrow>\n    \\<delta> s (stack s ! i) < \\<delta> s (stack s ! j)", "assume \"i < j\""], ["proof (state)\nthis:\n  i < j\n\ngoal (2 subgoals):\n 1. \\<delta> s (stack s ! i) < \\<delta> s (stack s ! j) \\<Longrightarrow>\n    j < i\n 2. j < i \\<Longrightarrow>\n    \\<delta> s (stack s ! i) < \\<delta> s (stack s ! j)", "with l"], ["proof (chain)\npicking this:\n  i < length (stack s)\n  j < length (stack s)\n  i < j", "have \"stack s ! j \\<in> set (drop (Suc i) (stack s))\""], ["proof (prove)\nusing this:\n  i < length (stack s)\n  j < length (stack s)\n  i < j\n\ngoal (1 subgoal):\n 1. stack s ! j \\<in> set (drop (Suc i) (stack s))", "using in_set_drop_conv_nth[of \"stack s ! j\" \"Suc i\" \"stack s\"]"], ["proof (prove)\nusing this:\n  i < length (stack s)\n  j < length (stack s)\n  i < j\n  (stack s ! j \\<in> set (drop (Suc i) (stack s))) =\n  (\\<exists>ia\\<ge>Suc i.\n      ia < length (stack s) \\<and> stack s ! j = stack s ! ia)\n\ngoal (1 subgoal):\n 1. stack s ! j \\<in> set (drop (Suc i) (stack s))", "by fastforce"], ["proof (state)\nthis:\n  stack s ! j \\<in> set (drop (Suc i) (stack s))\n\ngoal (2 subgoals):\n 1. \\<delta> s (stack s ! i) < \\<delta> s (stack s ! j) \\<Longrightarrow>\n    j < i\n 2. j < i \\<Longrightarrow>\n    \\<delta> s (stack s ! i) < \\<delta> s (stack s ! j)", "with prev_stack_discover l"], ["proof (chain)\npicking this:\n  \\<lbrakk>?n < length (stack s);\n   ?v \\<in> set (drop (Suc ?n) (stack s))\\<rbrakk>\n  \\<Longrightarrow> \\<delta> s ?v < \\<delta> s (stack s ! ?n)\n  i < length (stack s)\n  j < length (stack s)\n  stack s ! j \\<in> set (drop (Suc i) (stack s))", "have \"\\<delta> s (stack s ! j) < \\<delta> s (stack s ! i)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?n < length (stack s);\n   ?v \\<in> set (drop (Suc ?n) (stack s))\\<rbrakk>\n  \\<Longrightarrow> \\<delta> s ?v < \\<delta> s (stack s ! ?n)\n  i < length (stack s)\n  j < length (stack s)\n  stack s ! j \\<in> set (drop (Suc i) (stack s))\n\ngoal (1 subgoal):\n 1. \\<delta> s (stack s ! j) < \\<delta> s (stack s ! i)", "by simp"], ["proof (state)\nthis:\n  \\<delta> s (stack s ! j) < \\<delta> s (stack s ! i)\n\ngoal (2 subgoals):\n 1. \\<delta> s (stack s ! i) < \\<delta> s (stack s ! j) \\<Longrightarrow>\n    j < i\n 2. j < i \\<Longrightarrow>\n    \\<delta> s (stack s ! i) < \\<delta> s (stack s ! j)", "with \\<delta>"], ["proof (chain)\npicking this:\n  \\<delta> s (stack s ! i) < \\<delta> s (stack s ! j)\n  \\<delta> s (stack s ! j) < \\<delta> s (stack s ! i)", "have \"False\""], ["proof (prove)\nusing this:\n  \\<delta> s (stack s ! i) < \\<delta> s (stack s ! j)\n  \\<delta> s (stack s ! j) < \\<delta> s (stack s ! i)\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. \\<delta> s (stack s ! i) < \\<delta> s (stack s ! j) \\<Longrightarrow>\n    j < i\n 2. j < i \\<Longrightarrow>\n    \\<delta> s (stack s ! i) < \\<delta> s (stack s ! j)", "}"], ["proof (state)\nthis:\n  i < j \\<Longrightarrow> False\n\ngoal (2 subgoals):\n 1. \\<delta> s (stack s ! i) < \\<delta> s (stack s ! j) \\<Longrightarrow>\n    j < i\n 2. j < i \\<Longrightarrow>\n    \\<delta> s (stack s ! i) < \\<delta> s (stack s ! j)", "ultimately"], ["proof (chain)\npicking this:\n  i \\<noteq> j\n  i < j \\<Longrightarrow> False", "show \"i > j\""], ["proof (prove)\nusing this:\n  i \\<noteq> j\n  i < j \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. j < i", "by force"], ["proof (state)\nthis:\n  j < i\n\ngoal (1 subgoal):\n 1. j < i \\<Longrightarrow>\n    \\<delta> s (stack s ! i) < \\<delta> s (stack s ! j)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. j < i \\<Longrightarrow>\n    \\<delta> s (stack s ! i) < \\<delta> s (stack s ! j)", "assume \"i > j\""], ["proof (state)\nthis:\n  j < i\n\ngoal (1 subgoal):\n 1. j < i \\<Longrightarrow>\n    \\<delta> s (stack s ! i) < \\<delta> s (stack s ! j)", "with l"], ["proof (chain)\npicking this:\n  i < length (stack s)\n  j < length (stack s)\n  j < i", "have \"stack s ! i \\<in> set (drop (Suc j) (stack s))\""], ["proof (prove)\nusing this:\n  i < length (stack s)\n  j < length (stack s)\n  j < i\n\ngoal (1 subgoal):\n 1. stack s ! i \\<in> set (drop (Suc j) (stack s))", "using in_set_drop_conv_nth[of \"stack s ! i\" \"Suc j\" \"stack s\"]"], ["proof (prove)\nusing this:\n  i < length (stack s)\n  j < length (stack s)\n  j < i\n  (stack s ! i \\<in> set (drop (Suc j) (stack s))) =\n  (\\<exists>ia\\<ge>Suc j.\n      ia < length (stack s) \\<and> stack s ! i = stack s ! ia)\n\ngoal (1 subgoal):\n 1. stack s ! i \\<in> set (drop (Suc j) (stack s))", "by fastforce"], ["proof (state)\nthis:\n  stack s ! i \\<in> set (drop (Suc j) (stack s))\n\ngoal (1 subgoal):\n 1. j < i \\<Longrightarrow>\n    \\<delta> s (stack s ! i) < \\<delta> s (stack s ! j)", "with prev_stack_discover l"], ["proof (chain)\npicking this:\n  \\<lbrakk>?n < length (stack s);\n   ?v \\<in> set (drop (Suc ?n) (stack s))\\<rbrakk>\n  \\<Longrightarrow> \\<delta> s ?v < \\<delta> s (stack s ! ?n)\n  i < length (stack s)\n  j < length (stack s)\n  stack s ! i \\<in> set (drop (Suc j) (stack s))", "show \"\\<delta> s ?i < \\<delta> s ?j\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?n < length (stack s);\n   ?v \\<in> set (drop (Suc ?n) (stack s))\\<rbrakk>\n  \\<Longrightarrow> \\<delta> s ?v < \\<delta> s (stack s ! ?n)\n  i < length (stack s)\n  j < length (stack s)\n  stack s ! i \\<in> set (drop (Suc j) (stack s))\n\ngoal (1 subgoal):\n 1. \\<delta> s (stack s ! i) < \\<delta> s (stack s ! j)", "by simp"], ["proof (state)\nthis:\n  \\<delta> s (stack s ! i) < \\<delta> s (stack s ! j)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"], ["", "subsection \\<open>Paranthesis Theorem\\<close>"], ["", "(* Parenthesis Thm *)"], ["", "context param_DFS begin"], ["", "context begin"], ["", "interpretation timing_syntax"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "definition \"parenthesis s \\<equiv>\n    \\<forall>v \\<in> dom (discovered s). \\<forall>w \\<in> dom (discovered s).\n     \\<delta> s v < \\<delta> s w \\<and> v \\<in> dom (finished s) \\<longrightarrow> (\n             \\<phi> s v < \\<delta> s w \\<comment> \\<open>disjoint\\<close>\n           \\<or> (\\<phi> s v > \\<delta> s w \\<and> w \\<in> dom (finished s) \\<and> \\<phi> s w < \\<phi> s v))\""], ["", "lemma i_parenthesis: \"is_invar parenthesis\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_invar parenthesis", "proof (induct rule: is_invarI)"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>e. parenthesis (empty_state e)\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>parenthesis s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s = []; v0 \\<notin> dom (discovered s);\n        v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> parenthesis s'\n 3. \\<And>s s' u e.\n       \\<lbrakk>parenthesis s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; pending s `` {u} = {};\n        u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> parenthesis s'\n 4. \\<And>s s' u v e c b.\n       \\<lbrakk>parenthesis s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); u = hd (stack s);\n        cross_edges s \\<subseteq> c; back_edges s \\<subseteq> b;\n        s' = s\n        \\<lparr>pending := pending s - {(u, v)}, state.more := e,\n           cross_edges := c, back_edges := b\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> parenthesis s'\n 5. \\<And>s s' u v e.\n       \\<lbrakk>parenthesis s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> parenthesis s'", "case (finish s s')"], ["proof (state)\nthis:\n  parenthesis s\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s \\<noteq> []\n  pending s `` {u_} = {}\n  u_ = hd (stack s)\n  s' = finish u_ s\\<lparr>state.more := e_\\<rparr>\n\ngoal (5 subgoals):\n 1. \\<And>e. parenthesis (empty_state e)\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>parenthesis s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s = []; v0 \\<notin> dom (discovered s);\n        v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> parenthesis s'\n 3. \\<And>s s' u e.\n       \\<lbrakk>parenthesis s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; pending s `` {u} = {};\n        u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> parenthesis s'\n 4. \\<And>s s' u v e c b.\n       \\<lbrakk>parenthesis s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); u = hd (stack s);\n        cross_edges s \\<subseteq> c; back_edges s \\<subseteq> b;\n        s' = s\n        \\<lparr>pending := pending s - {(u, v)}, state.more := e,\n           cross_edges := c, back_edges := b\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> parenthesis s'\n 5. \\<And>s s' u v e.\n       \\<lbrakk>parenthesis s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> parenthesis s'", "hence EQ[simp]: \"discovered s' = discovered s\" \n                    \"counter s' = Suc (counter s)\"\n                    \"finished s' = finished s(hd (stack s) \\<mapsto> counter s)\""], ["proof (prove)\nusing this:\n  parenthesis s\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s \\<noteq> []\n  pending s `` {u_} = {}\n  u_ = hd (stack s)\n  s' = finish u_ s\\<lparr>state.more := e_\\<rparr>\n\ngoal (1 subgoal):\n 1. discovered s' = discovered s &&&\n    counter s' = Suc (counter s) &&&\n    finished s' = finished s(hd (stack s) \\<mapsto> counter s)", "by simp_all"], ["proof (state)\nthis:\n  discovered s' = discovered s\n  counter s' = Suc (counter s)\n  finished s' = finished s(hd (stack s) \\<mapsto> counter s)\n\ngoal (5 subgoals):\n 1. \\<And>e. parenthesis (empty_state e)\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>parenthesis s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s = []; v0 \\<notin> dom (discovered s);\n        v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> parenthesis s'\n 3. \\<And>s s' u e.\n       \\<lbrakk>parenthesis s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; pending s `` {u} = {};\n        u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> parenthesis s'\n 4. \\<And>s s' u v e c b.\n       \\<lbrakk>parenthesis s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); u = hd (stack s);\n        cross_edges s \\<subseteq> c; back_edges s \\<subseteq> b;\n        s' = s\n        \\<lparr>pending := pending s - {(u, v)}, state.more := e,\n           cross_edges := c, back_edges := b\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> parenthesis s'\n 5. \\<And>s s' u v e.\n       \\<lbrakk>parenthesis s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> parenthesis s'", "from finish"], ["proof (chain)\npicking this:\n  parenthesis s\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s \\<noteq> []\n  pending s `` {u_} = {}\n  u_ = hd (stack s)\n  s' = finish u_ s\\<lparr>state.more := e_\\<rparr>", "interpret DFS_invar where s=s"], ["proof (prove)\nusing this:\n  parenthesis s\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s \\<noteq> []\n  pending s `` {u_} = {}\n  u_ = hd (stack s)\n  s' = finish u_ s\\<lparr>state.more := e_\\<rparr>\n\ngoal (1 subgoal):\n 1. DFS_invar G param s", "by simp"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>e. parenthesis (empty_state e)\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>parenthesis s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s = []; v0 \\<notin> dom (discovered s);\n        v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> parenthesis s'\n 3. \\<And>s s' u e.\n       \\<lbrakk>parenthesis s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; pending s `` {u} = {};\n        u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> parenthesis s'\n 4. \\<And>s s' u v e c b.\n       \\<lbrakk>parenthesis s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); u = hd (stack s);\n        cross_edges s \\<subseteq> c; back_edges s \\<subseteq> b;\n        s' = s\n        \\<lparr>pending := pending s - {(u, v)}, state.more := e,\n           cross_edges := c, back_edges := b\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> parenthesis s'\n 5. \\<And>s s' u v e.\n       \\<lbrakk>parenthesis s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> parenthesis s'", "from finish"], ["proof (chain)\npicking this:\n  parenthesis s\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s \\<noteq> []\n  pending s `` {u_} = {}\n  u_ = hd (stack s)\n  s' = finish u_ s\\<lparr>state.more := e_\\<rparr>", "have NE[simp]: \"stack s \\<noteq> []\""], ["proof (prove)\nusing this:\n  parenthesis s\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s \\<noteq> []\n  pending s `` {u_} = {}\n  u_ = hd (stack s)\n  s' = finish u_ s\\<lparr>state.more := e_\\<rparr>\n\ngoal (1 subgoal):\n 1. stack s \\<noteq> []", "by (simp add: cond_alt)"], ["proof (state)\nthis:\n  stack s \\<noteq> []\n\ngoal (5 subgoals):\n 1. \\<And>e. parenthesis (empty_state e)\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>parenthesis s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s = []; v0 \\<notin> dom (discovered s);\n        v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> parenthesis s'\n 3. \\<And>s s' u e.\n       \\<lbrakk>parenthesis s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; pending s `` {u} = {};\n        u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> parenthesis s'\n 4. \\<And>s s' u v e c b.\n       \\<lbrakk>parenthesis s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); u = hd (stack s);\n        cross_edges s \\<subseteq> c; back_edges s \\<subseteq> b;\n        s' = s\n        \\<lparr>pending := pending s - {(u, v)}, state.more := e,\n           cross_edges := c, back_edges := b\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> parenthesis s'\n 5. \\<And>s s' u v e.\n       \\<lbrakk>parenthesis s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> parenthesis s'", "{"], ["proof (state)\nthis:\n  stack s \\<noteq> []\n\ngoal (5 subgoals):\n 1. \\<And>e. parenthesis (empty_state e)\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>parenthesis s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s = []; v0 \\<notin> dom (discovered s);\n        v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> parenthesis s'\n 3. \\<And>s s' u e.\n       \\<lbrakk>parenthesis s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; pending s `` {u} = {};\n        u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> parenthesis s'\n 4. \\<And>s s' u v e c b.\n       \\<lbrakk>parenthesis s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); u = hd (stack s);\n        cross_edges s \\<subseteq> c; back_edges s \\<subseteq> b;\n        s' = s\n        \\<lparr>pending := pending s - {(u, v)}, state.more := e,\n           cross_edges := c, back_edges := b\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> parenthesis s'\n 5. \\<And>s s' u v e.\n       \\<lbrakk>parenthesis s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> parenthesis s'", "fix x y"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>e. parenthesis (empty_state e)\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>parenthesis s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s = []; v0 \\<notin> dom (discovered s);\n        v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> parenthesis s'\n 3. \\<And>s s' u e.\n       \\<lbrakk>parenthesis s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; pending s `` {u} = {};\n        u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> parenthesis s'\n 4. \\<And>s s' u v e c b.\n       \\<lbrakk>parenthesis s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); u = hd (stack s);\n        cross_edges s \\<subseteq> c; back_edges s \\<subseteq> b;\n        s' = s\n        \\<lparr>pending := pending s - {(u, v)}, state.more := e,\n           cross_edges := c, back_edges := b\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> parenthesis s'\n 5. \\<And>s s' u v e.\n       \\<lbrakk>parenthesis s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> parenthesis s'", "assume  dom: \"x \\<in> dom (discovered s')\" \"y \\<in> dom (discovered s')\"\n        and \\<delta>: \"\\<delta> s' x < \\<delta> s' y\"\n        and f: \"x \\<in> dom (finished s')\""], ["proof (state)\nthis:\n  x \\<in> dom (discovered s')\n  y \\<in> dom (discovered s')\n  \\<delta> s' x < \\<delta> s' y\n  x \\<in> dom (finished s')\n\ngoal (5 subgoals):\n 1. \\<And>e. parenthesis (empty_state e)\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>parenthesis s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s = []; v0 \\<notin> dom (discovered s);\n        v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> parenthesis s'\n 3. \\<And>s s' u e.\n       \\<lbrakk>parenthesis s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; pending s `` {u} = {};\n        u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> parenthesis s'\n 4. \\<And>s s' u v e c b.\n       \\<lbrakk>parenthesis s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); u = hd (stack s);\n        cross_edges s \\<subseteq> c; back_edges s \\<subseteq> b;\n        s' = s\n        \\<lparr>pending := pending s - {(u, v)}, state.more := e,\n           cross_edges := c, back_edges := b\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> parenthesis s'\n 5. \\<And>s s' u v e.\n       \\<lbrakk>parenthesis s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> parenthesis s'", "hence neq: \"x \\<noteq> y\""], ["proof (prove)\nusing this:\n  x \\<in> dom (discovered s')\n  y \\<in> dom (discovered s')\n  \\<delta> s' x < \\<delta> s' y\n  x \\<in> dom (finished s')\n\ngoal (1 subgoal):\n 1. x \\<noteq> y", "by force"], ["proof (state)\nthis:\n  x \\<noteq> y\n\ngoal (5 subgoals):\n 1. \\<And>e. parenthesis (empty_state e)\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>parenthesis s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s = []; v0 \\<notin> dom (discovered s);\n        v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> parenthesis s'\n 3. \\<And>s s' u e.\n       \\<lbrakk>parenthesis s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; pending s `` {u} = {};\n        u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> parenthesis s'\n 4. \\<And>s s' u v e c b.\n       \\<lbrakk>parenthesis s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); u = hd (stack s);\n        cross_edges s \\<subseteq> c; back_edges s \\<subseteq> b;\n        s' = s\n        \\<lparr>pending := pending s - {(u, v)}, state.more := e,\n           cross_edges := c, back_edges := b\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> parenthesis s'\n 5. \\<And>s s' u v e.\n       \\<lbrakk>parenthesis s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> parenthesis s'", "note assms = dom \\<delta> f EQ"], ["proof (state)\nthis:\n  x \\<in> dom (discovered s')\n  y \\<in> dom (discovered s')\n  \\<delta> s' x < \\<delta> s' y\n  x \\<in> dom (finished s')\n  discovered s' = discovered s\n  counter s' = Suc (counter s)\n  finished s' = finished s(hd (stack s) \\<mapsto> counter s)\n\ngoal (5 subgoals):\n 1. \\<And>e. parenthesis (empty_state e)\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>parenthesis s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s = []; v0 \\<notin> dom (discovered s);\n        v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> parenthesis s'\n 3. \\<And>s s' u e.\n       \\<lbrakk>parenthesis s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; pending s `` {u} = {};\n        u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> parenthesis s'\n 4. \\<And>s s' u v e c b.\n       \\<lbrakk>parenthesis s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); u = hd (stack s);\n        cross_edges s \\<subseteq> c; back_edges s \\<subseteq> b;\n        s' = s\n        \\<lparr>pending := pending s - {(u, v)}, state.more := e,\n           cross_edges := c, back_edges := b\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> parenthesis s'\n 5. \\<And>s s' u v e.\n       \\<lbrakk>parenthesis s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> parenthesis s'", "let ?DISJ = \"\\<phi> s' x < \\<delta> s' y\""], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>e. parenthesis (empty_state e)\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>parenthesis s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s = []; v0 \\<notin> dom (discovered s);\n        v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> parenthesis s'\n 3. \\<And>s s' u e.\n       \\<lbrakk>parenthesis s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; pending s `` {u} = {};\n        u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> parenthesis s'\n 4. \\<And>s s' u v e c b.\n       \\<lbrakk>parenthesis s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); u = hd (stack s);\n        cross_edges s \\<subseteq> c; back_edges s \\<subseteq> b;\n        s' = s\n        \\<lparr>pending := pending s - {(u, v)}, state.more := e,\n           cross_edges := c, back_edges := b\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> parenthesis s'\n 5. \\<And>s s' u v e.\n       \\<lbrakk>parenthesis s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> parenthesis s'", "let ?IN = \"\\<delta> s' y < \\<phi> s' x \\<and> y \\<in> dom (finished s') \\<and> \\<phi> s' y < \\<phi> s' x\""], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>e. parenthesis (empty_state e)\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>parenthesis s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s = []; v0 \\<notin> dom (discovered s);\n        v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> parenthesis s'\n 3. \\<And>s s' u e.\n       \\<lbrakk>parenthesis s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; pending s `` {u} = {};\n        u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> parenthesis s'\n 4. \\<And>s s' u v e c b.\n       \\<lbrakk>parenthesis s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); u = hd (stack s);\n        cross_edges s \\<subseteq> c; back_edges s \\<subseteq> b;\n        s' = s\n        \\<lparr>pending := pending s - {(u, v)}, state.more := e,\n           cross_edges := c, back_edges := b\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> parenthesis s'\n 5. \\<And>s s' u v e.\n       \\<lbrakk>parenthesis s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> parenthesis s'", "have \"?DISJ \\<or> ?IN\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<phi> s' x < \\<delta> s' y \\<or>\n    \\<delta> s' y < \\<phi> s' x \\<and>\n    y \\<in> dom (finished s') \\<and> \\<phi> s' y < \\<phi> s' x", "proof (cases \"x = hd (stack s)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x = hd (stack s) \\<Longrightarrow>\n    \\<phi> s' x < \\<delta> s' y \\<or>\n    \\<delta> s' y < \\<phi> s' x \\<and>\n    y \\<in> dom (finished s') \\<and> \\<phi> s' y < \\<phi> s' x\n 2. x \\<noteq> hd (stack s) \\<Longrightarrow>\n    \\<phi> s' x < \\<delta> s' y \\<or>\n    \\<delta> s' y < \\<phi> s' x \\<and>\n    y \\<in> dom (finished s') \\<and> \\<phi> s' y < \\<phi> s' x", "case True"], ["proof (state)\nthis:\n  x = hd (stack s)\n\ngoal (2 subgoals):\n 1. x = hd (stack s) \\<Longrightarrow>\n    \\<phi> s' x < \\<delta> s' y \\<or>\n    \\<delta> s' y < \\<phi> s' x \\<and>\n    y \\<in> dom (finished s') \\<and> \\<phi> s' y < \\<phi> s' x\n 2. x \\<noteq> hd (stack s) \\<Longrightarrow>\n    \\<phi> s' x < \\<delta> s' y \\<or>\n    \\<delta> s' y < \\<phi> s' x \\<and>\n    y \\<in> dom (finished s') \\<and> \\<phi> s' y < \\<phi> s' x", "note x_is_hd = this"], ["proof (state)\nthis:\n  x = hd (stack s)\n\ngoal (2 subgoals):\n 1. x = hd (stack s) \\<Longrightarrow>\n    \\<phi> s' x < \\<delta> s' y \\<or>\n    \\<delta> s' y < \\<phi> s' x \\<and>\n    y \\<in> dom (finished s') \\<and> \\<phi> s' y < \\<phi> s' x\n 2. x \\<noteq> hd (stack s) \\<Longrightarrow>\n    \\<phi> s' x < \\<delta> s' y \\<or>\n    \\<delta> s' y < \\<phi> s' x \\<and>\n    y \\<in> dom (finished s') \\<and> \\<phi> s' y < \\<phi> s' x", "hence \\<phi>x: \"\\<phi> s' x = counter s\""], ["proof (prove)\nusing this:\n  x = hd (stack s)\n\ngoal (1 subgoal):\n 1. \\<phi> s' x = counter s", "by simp"], ["proof (state)\nthis:\n  \\<phi> s' x = counter s\n\ngoal (2 subgoals):\n 1. x = hd (stack s) \\<Longrightarrow>\n    \\<phi> s' x < \\<delta> s' y \\<or>\n    \\<delta> s' y < \\<phi> s' x \\<and>\n    y \\<in> dom (finished s') \\<and> \\<phi> s' y < \\<phi> s' x\n 2. x \\<noteq> hd (stack s) \\<Longrightarrow>\n    \\<phi> s' x < \\<delta> s' y \\<or>\n    \\<delta> s' y < \\<phi> s' x \\<and>\n    y \\<in> dom (finished s') \\<and> \\<phi> s' y < \\<phi> s' x", "from x_is_hd neq"], ["proof (chain)\npicking this:\n  x = hd (stack s)\n  x \\<noteq> y", "have y_not_hd: \"y \\<noteq> hd (stack s)\""], ["proof (prove)\nusing this:\n  x = hd (stack s)\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. y \\<noteq> hd (stack s)", "by simp"], ["proof (state)\nthis:\n  y \\<noteq> hd (stack s)\n\ngoal (2 subgoals):\n 1. x = hd (stack s) \\<Longrightarrow>\n    \\<phi> s' x < \\<delta> s' y \\<or>\n    \\<delta> s' y < \\<phi> s' x \\<and>\n    y \\<in> dom (finished s') \\<and> \\<phi> s' y < \\<phi> s' x\n 2. x \\<noteq> hd (stack s) \\<Longrightarrow>\n    \\<phi> s' x < \\<delta> s' y \\<or>\n    \\<delta> s' y < \\<phi> s' x \\<and>\n    y \\<in> dom (finished s') \\<and> \\<phi> s' y < \\<phi> s' x", "have \"\\<delta> s y < \\<phi> s' x \\<and> y \\<in> dom (finished s) \\<and> \\<phi> s y < \\<phi> s' x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<delta> s y < \\<phi> s' x \\<and>\n    y \\<in> dom (finished s) \\<and> \\<phi> s y < \\<phi> s' x", "proof (cases \"y \\<in> set (stack s)\")\n          \\<comment> \\<open>y on stack is not possible: According to @{thm [display] \\<delta>} it is discovered after @{text \"x (= hd (stack s))\"}\\<close>"], ["proof (state)\ngoal (2 subgoals):\n 1. y \\<in> set (stack s) \\<Longrightarrow>\n    \\<delta> s y < \\<phi> s' x \\<and>\n    y \\<in> dom (finished s) \\<and> \\<phi> s y < \\<phi> s' x\n 2. y \\<notin> set (stack s) \\<Longrightarrow>\n    \\<delta> s y < \\<phi> s' x \\<and>\n    y \\<in> dom (finished s) \\<and> \\<phi> s y < \\<phi> s' x", "case True"], ["proof (state)\nthis:\n  y \\<in> set (stack s)\n\ngoal (2 subgoals):\n 1. y \\<in> set (stack s) \\<Longrightarrow>\n    \\<delta> s y < \\<phi> s' x \\<and>\n    y \\<in> dom (finished s) \\<and> \\<phi> s y < \\<phi> s' x\n 2. y \\<notin> set (stack s) \\<Longrightarrow>\n    \\<delta> s y < \\<phi> s' x \\<and>\n    y \\<in> dom (finished s) \\<and> \\<phi> s y < \\<phi> s' x", "with y_not_hd"], ["proof (chain)\npicking this:\n  y \\<noteq> hd (stack s)\n  y \\<in> set (stack s)", "have \"y \\<in> set (tl (stack s))\""], ["proof (prove)\nusing this:\n  y \\<noteq> hd (stack s)\n  y \\<in> set (stack s)\n\ngoal (1 subgoal):\n 1. y \\<in> set (tl (stack s))", "by (cases \"stack s\") simp_all"], ["proof (state)\nthis:\n  y \\<in> set (tl (stack s))\n\ngoal (2 subgoals):\n 1. y \\<in> set (stack s) \\<Longrightarrow>\n    \\<delta> s y < \\<phi> s' x \\<and>\n    y \\<in> dom (finished s) \\<and> \\<phi> s y < \\<phi> s' x\n 2. y \\<notin> set (stack s) \\<Longrightarrow>\n    \\<delta> s y < \\<phi> s' x \\<and>\n    y \\<in> dom (finished s) \\<and> \\<phi> s y < \\<phi> s' x", "with tl_lt_stack_hd_discover[OF NE] \\<delta> x_is_hd"], ["proof (chain)\npicking this:\n  ?x \\<in> set (tl (stack s)) \\<Longrightarrow>\n  \\<delta> s ?x < \\<delta> s (hd (stack s))\n  \\<delta> s' x < \\<delta> s' y\n  x = hd (stack s)\n  y \\<in> set (tl (stack s))", "have \"\\<delta> s y < \\<delta> s x\""], ["proof (prove)\nusing this:\n  ?x \\<in> set (tl (stack s)) \\<Longrightarrow>\n  \\<delta> s ?x < \\<delta> s (hd (stack s))\n  \\<delta> s' x < \\<delta> s' y\n  x = hd (stack s)\n  y \\<in> set (tl (stack s))\n\ngoal (1 subgoal):\n 1. \\<delta> s y < \\<delta> s x", "by simp"], ["proof (state)\nthis:\n  \\<delta> s y < \\<delta> s x\n\ngoal (2 subgoals):\n 1. y \\<in> set (stack s) \\<Longrightarrow>\n    \\<delta> s y < \\<phi> s' x \\<and>\n    y \\<in> dom (finished s) \\<and> \\<phi> s y < \\<phi> s' x\n 2. y \\<notin> set (stack s) \\<Longrightarrow>\n    \\<delta> s y < \\<phi> s' x \\<and>\n    y \\<in> dom (finished s) \\<and> \\<phi> s y < \\<phi> s' x", "with \\<delta>"], ["proof (chain)\npicking this:\n  \\<delta> s' x < \\<delta> s' y\n  \\<delta> s y < \\<delta> s x", "have False"], ["proof (prove)\nusing this:\n  \\<delta> s' x < \\<delta> s' y\n  \\<delta> s y < \\<delta> s x\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. y \\<in> set (stack s) \\<Longrightarrow>\n    \\<delta> s y < \\<phi> s' x \\<and>\n    y \\<in> dom (finished s) \\<and> \\<phi> s y < \\<phi> s' x\n 2. y \\<notin> set (stack s) \\<Longrightarrow>\n    \\<delta> s y < \\<phi> s' x \\<and>\n    y \\<in> dom (finished s) \\<and> \\<phi> s y < \\<phi> s' x", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. \\<delta> s y < \\<phi> s' x \\<and>\n    y \\<in> dom (finished s) \\<and> \\<phi> s y < \\<phi> s' x", ".."], ["proof (state)\nthis:\n  \\<delta> s y < \\<phi> s' x \\<and>\n  y \\<in> dom (finished s) \\<and> \\<phi> s y < \\<phi> s' x\n\ngoal (1 subgoal):\n 1. y \\<notin> set (stack s) \\<Longrightarrow>\n    \\<delta> s y < \\<phi> s' x \\<and>\n    y \\<in> dom (finished s) \\<and> \\<phi> s y < \\<phi> s' x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. y \\<notin> set (stack s) \\<Longrightarrow>\n    \\<delta> s y < \\<phi> s' x \\<and>\n    y \\<in> dom (finished s) \\<and> \\<phi> s y < \\<phi> s' x", "case False \\<comment> \\<open>y must be a successor of @{text \"x (= (hd (stack s)))\"}\\<close>"], ["proof (state)\nthis:\n  y \\<notin> set (stack s)\n\ngoal (1 subgoal):\n 1. y \\<notin> set (stack s) \\<Longrightarrow>\n    \\<delta> s y < \\<phi> s' x \\<and>\n    y \\<in> dom (finished s) \\<and> \\<phi> s y < \\<phi> s' x", "from dom"], ["proof (chain)\npicking this:\n  x \\<in> dom (discovered s')\n  y \\<in> dom (discovered s')", "have \"y \\<in> dom (discovered s)\""], ["proof (prove)\nusing this:\n  x \\<in> dom (discovered s')\n  y \\<in> dom (discovered s')\n\ngoal (1 subgoal):\n 1. y \\<in> dom (discovered s)", "by simp"], ["proof (state)\nthis:\n  y \\<in> dom (discovered s)\n\ngoal (1 subgoal):\n 1. y \\<notin> set (stack s) \\<Longrightarrow>\n    \\<delta> s y < \\<phi> s' x \\<and>\n    y \\<in> dom (finished s) \\<and> \\<phi> s y < \\<phi> s' x", "with False discovered_not_stack_imp_finished"], ["proof (chain)\npicking this:\n  y \\<notin> set (stack s)\n  \\<lbrakk>?x \\<in> dom (discovered s); ?x \\<notin> set (stack s)\\<rbrakk>\n  \\<Longrightarrow> ?x \\<in> dom (finished s)\n  y \\<in> dom (discovered s)", "have *: \n            \"y \\<in> dom (finished s)\""], ["proof (prove)\nusing this:\n  y \\<notin> set (stack s)\n  \\<lbrakk>?x \\<in> dom (discovered s); ?x \\<notin> set (stack s)\\<rbrakk>\n  \\<Longrightarrow> ?x \\<in> dom (finished s)\n  y \\<in> dom (discovered s)\n\ngoal (1 subgoal):\n 1. y \\<in> dom (finished s)", "by simp"], ["proof (state)\nthis:\n  y \\<in> dom (finished s)\n\ngoal (1 subgoal):\n 1. y \\<notin> set (stack s) \\<Longrightarrow>\n    \\<delta> s y < \\<phi> s' x \\<and>\n    y \\<in> dom (finished s) \\<and> \\<phi> s y < \\<phi> s' x", "moreover"], ["proof (state)\nthis:\n  y \\<in> dom (finished s)\n\ngoal (1 subgoal):\n 1. y \\<notin> set (stack s) \\<Longrightarrow>\n    \\<delta> s y < \\<phi> s' x \\<and>\n    y \\<in> dom (finished s) \\<and> \\<phi> s y < \\<phi> s' x", "with timing_less_counter \\<phi>x"], ["proof (chain)\npicking this:\n  ?v \\<in> dom (discovered s) \\<Longrightarrow> \\<delta> s ?v < counter s\n  ?v \\<in> dom (finished s) \\<Longrightarrow> \\<phi> s ?v < counter s\n  \\<phi> s' x = counter s\n  y \\<in> dom (finished s)", "have \"\\<phi> s y < \\<phi> s' x\""], ["proof (prove)\nusing this:\n  ?v \\<in> dom (discovered s) \\<Longrightarrow> \\<delta> s ?v < counter s\n  ?v \\<in> dom (finished s) \\<Longrightarrow> \\<phi> s ?v < counter s\n  \\<phi> s' x = counter s\n  y \\<in> dom (finished s)\n\ngoal (1 subgoal):\n 1. \\<phi> s y < \\<phi> s' x", "by simp"], ["proof (state)\nthis:\n  \\<phi> s y < \\<phi> s' x\n\ngoal (1 subgoal):\n 1. y \\<notin> set (stack s) \\<Longrightarrow>\n    \\<delta> s y < \\<phi> s' x \\<and>\n    y \\<in> dom (finished s) \\<and> \\<phi> s y < \\<phi> s' x", "moreover"], ["proof (state)\nthis:\n  \\<phi> s y < \\<phi> s' x\n\ngoal (1 subgoal):\n 1. y \\<notin> set (stack s) \\<Longrightarrow>\n    \\<delta> s y < \\<phi> s' x \\<and>\n    y \\<in> dom (finished s) \\<and> \\<phi> s y < \\<phi> s' x", "with * disc_lt_fin \\<phi>x"], ["proof (chain)\npicking this:\n  y \\<in> dom (finished s)\n  ?v \\<in> dom (finished s) \\<Longrightarrow> \\<delta> s ?v < \\<phi> s ?v\n  \\<phi> s' x = counter s\n  \\<phi> s y < \\<phi> s' x", "have \"\\<delta> s y < \\<phi> s' x\""], ["proof (prove)\nusing this:\n  y \\<in> dom (finished s)\n  ?v \\<in> dom (finished s) \\<Longrightarrow> \\<delta> s ?v < \\<phi> s ?v\n  \\<phi> s' x = counter s\n  \\<phi> s y < \\<phi> s' x\n\ngoal (1 subgoal):\n 1. \\<delta> s y < \\<phi> s' x", "by (metis less_trans)"], ["proof (state)\nthis:\n  \\<delta> s y < \\<phi> s' x\n\ngoal (1 subgoal):\n 1. y \\<notin> set (stack s) \\<Longrightarrow>\n    \\<delta> s y < \\<phi> s' x \\<and>\n    y \\<in> dom (finished s) \\<and> \\<phi> s y < \\<phi> s' x", "ultimately"], ["proof (chain)\npicking this:\n  y \\<in> dom (finished s)\n  \\<phi> s y < \\<phi> s' x\n  \\<delta> s y < \\<phi> s' x", "show ?thesis"], ["proof (prove)\nusing this:\n  y \\<in> dom (finished s)\n  \\<phi> s y < \\<phi> s' x\n  \\<delta> s y < \\<phi> s' x\n\ngoal (1 subgoal):\n 1. \\<delta> s y < \\<phi> s' x \\<and>\n    y \\<in> dom (finished s) \\<and> \\<phi> s y < \\<phi> s' x", "by simp"], ["proof (state)\nthis:\n  \\<delta> s y < \\<phi> s' x \\<and>\n  y \\<in> dom (finished s) \\<and> \\<phi> s y < \\<phi> s' x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<delta> s y < \\<phi> s' x \\<and>\n  y \\<in> dom (finished s) \\<and> \\<phi> s y < \\<phi> s' x\n\ngoal (2 subgoals):\n 1. x = hd (stack s) \\<Longrightarrow>\n    \\<phi> s' x < \\<delta> s' y \\<or>\n    \\<delta> s' y < \\<phi> s' x \\<and>\n    y \\<in> dom (finished s') \\<and> \\<phi> s' y < \\<phi> s' x\n 2. x \\<noteq> hd (stack s) \\<Longrightarrow>\n    \\<phi> s' x < \\<delta> s' y \\<or>\n    \\<delta> s' y < \\<phi> s' x \\<and>\n    y \\<in> dom (finished s') \\<and> \\<phi> s' y < \\<phi> s' x", "with y_not_hd"], ["proof (chain)\npicking this:\n  y \\<noteq> hd (stack s)\n  \\<delta> s y < \\<phi> s' x \\<and>\n  y \\<in> dom (finished s) \\<and> \\<phi> s y < \\<phi> s' x", "show ?thesis"], ["proof (prove)\nusing this:\n  y \\<noteq> hd (stack s)\n  \\<delta> s y < \\<phi> s' x \\<and>\n  y \\<in> dom (finished s) \\<and> \\<phi> s y < \\<phi> s' x\n\ngoal (1 subgoal):\n 1. \\<phi> s' x < \\<delta> s' y \\<or>\n    \\<delta> s' y < \\<phi> s' x \\<and>\n    y \\<in> dom (finished s') \\<and> \\<phi> s' y < \\<phi> s' x", "by simp"], ["proof (state)\nthis:\n  \\<phi> s' x < \\<delta> s' y \\<or>\n  \\<delta> s' y < \\<phi> s' x \\<and>\n  y \\<in> dom (finished s') \\<and> \\<phi> s' y < \\<phi> s' x\n\ngoal (1 subgoal):\n 1. x \\<noteq> hd (stack s) \\<Longrightarrow>\n    \\<phi> s' x < \\<delta> s' y \\<or>\n    \\<delta> s' y < \\<phi> s' x \\<and>\n    y \\<in> dom (finished s') \\<and> \\<phi> s' y < \\<phi> s' x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<noteq> hd (stack s) \\<Longrightarrow>\n    \\<phi> s' x < \\<delta> s' y \\<or>\n    \\<delta> s' y < \\<phi> s' x \\<and>\n    y \\<in> dom (finished s') \\<and> \\<phi> s' y < \\<phi> s' x", "case False"], ["proof (state)\nthis:\n  x \\<noteq> hd (stack s)\n\ngoal (1 subgoal):\n 1. x \\<noteq> hd (stack s) \\<Longrightarrow>\n    \\<phi> s' x < \\<delta> s' y \\<or>\n    \\<delta> s' y < \\<phi> s' x \\<and>\n    y \\<in> dom (finished s') \\<and> \\<phi> s' y < \\<phi> s' x", "note [simp] = this"], ["proof (state)\nthis:\n  x \\<noteq> hd (stack s)\n\ngoal (1 subgoal):\n 1. x \\<noteq> hd (stack s) \\<Longrightarrow>\n    \\<phi> s' x < \\<delta> s' y \\<or>\n    \\<delta> s' y < \\<phi> s' x \\<and>\n    y \\<in> dom (finished s') \\<and> \\<phi> s' y < \\<phi> s' x", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<phi> s' x < \\<delta> s' y \\<or>\n    \\<delta> s' y < \\<phi> s' x \\<and>\n    y \\<in> dom (finished s') \\<and> \\<phi> s' y < \\<phi> s' x", "proof (cases \"y = hd (stack s)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. y = hd (stack s) \\<Longrightarrow>\n    \\<phi> s' x < \\<delta> s' y \\<or>\n    \\<delta> s' y < \\<phi> s' x \\<and>\n    y \\<in> dom (finished s') \\<and> \\<phi> s' y < \\<phi> s' x\n 2. y \\<noteq> hd (stack s) \\<Longrightarrow>\n    \\<phi> s' x < \\<delta> s' y \\<or>\n    \\<delta> s' y < \\<phi> s' x \\<and>\n    y \\<in> dom (finished s') \\<and> \\<phi> s' y < \\<phi> s' x", "case False"], ["proof (state)\nthis:\n  y \\<noteq> hd (stack s)\n\ngoal (2 subgoals):\n 1. y = hd (stack s) \\<Longrightarrow>\n    \\<phi> s' x < \\<delta> s' y \\<or>\n    \\<delta> s' y < \\<phi> s' x \\<and>\n    y \\<in> dom (finished s') \\<and> \\<phi> s' y < \\<phi> s' x\n 2. y \\<noteq> hd (stack s) \\<Longrightarrow>\n    \\<phi> s' x < \\<delta> s' y \\<or>\n    \\<delta> s' y < \\<phi> s' x \\<and>\n    y \\<in> dom (finished s') \\<and> \\<phi> s' y < \\<phi> s' x", "with finish assms"], ["proof (chain)\npicking this:\n  parenthesis s\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s \\<noteq> []\n  pending s `` {u_} = {}\n  u_ = hd (stack s)\n  s' = finish u_ s\\<lparr>state.more := e_\\<rparr>\n  x \\<in> dom (discovered s')\n  y \\<in> dom (discovered s')\n  \\<delta> s' x < \\<delta> s' y\n  x \\<in> dom (finished s')\n  discovered s' = discovered s\n  counter s' = Suc (counter s)\n  finished s' = finished s(hd (stack s) \\<mapsto> counter s)\n  y \\<noteq> hd (stack s)", "show ?thesis"], ["proof (prove)\nusing this:\n  parenthesis s\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s \\<noteq> []\n  pending s `` {u_} = {}\n  u_ = hd (stack s)\n  s' = finish u_ s\\<lparr>state.more := e_\\<rparr>\n  x \\<in> dom (discovered s')\n  y \\<in> dom (discovered s')\n  \\<delta> s' x < \\<delta> s' y\n  x \\<in> dom (finished s')\n  discovered s' = discovered s\n  counter s' = Suc (counter s)\n  finished s' = finished s(hd (stack s) \\<mapsto> counter s)\n  y \\<noteq> hd (stack s)\n\ngoal (1 subgoal):\n 1. \\<phi> s' x < \\<delta> s' y \\<or>\n    \\<delta> s' y < \\<phi> s' x \\<and>\n    y \\<in> dom (finished s') \\<and> \\<phi> s' y < \\<phi> s' x", "by (simp add: parenthesis_def)"], ["proof (state)\nthis:\n  \\<phi> s' x < \\<delta> s' y \\<or>\n  \\<delta> s' y < \\<phi> s' x \\<and>\n  y \\<in> dom (finished s') \\<and> \\<phi> s' y < \\<phi> s' x\n\ngoal (1 subgoal):\n 1. y = hd (stack s) \\<Longrightarrow>\n    \\<phi> s' x < \\<delta> s' y \\<or>\n    \\<delta> s' y < \\<phi> s' x \\<and>\n    y \\<in> dom (finished s') \\<and> \\<phi> s' y < \\<phi> s' x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. y = hd (stack s) \\<Longrightarrow>\n    \\<phi> s' x < \\<delta> s' y \\<or>\n    \\<delta> s' y < \\<phi> s' x \\<and>\n    y \\<in> dom (finished s') \\<and> \\<phi> s' y < \\<phi> s' x", "case True"], ["proof (state)\nthis:\n  y = hd (stack s)\n\ngoal (1 subgoal):\n 1. y = hd (stack s) \\<Longrightarrow>\n    \\<phi> s' x < \\<delta> s' y \\<or>\n    \\<delta> s' y < \\<phi> s' x \\<and>\n    y \\<in> dom (finished s') \\<and> \\<phi> s' y < \\<phi> s' x", "with stack_not_finished"], ["proof (chain)\npicking this:\n  ?x \\<in> set (stack s) \\<Longrightarrow> ?x \\<notin> dom (finished s)\n  y = hd (stack s)", "have \"y \\<notin> dom (finished s)\""], ["proof (prove)\nusing this:\n  ?x \\<in> set (stack s) \\<Longrightarrow> ?x \\<notin> dom (finished s)\n  y = hd (stack s)\n\ngoal (1 subgoal):\n 1. y \\<notin> dom (finished s)", "using hd_in_set[OF NE]"], ["proof (prove)\nusing this:\n  ?x \\<in> set (stack s) \\<Longrightarrow> ?x \\<notin> dom (finished s)\n  y = hd (stack s)\n  hd (stack s) \\<in> set (stack s)\n\ngoal (1 subgoal):\n 1. y \\<notin> dom (finished s)", "by auto"], ["proof (state)\nthis:\n  y \\<notin> dom (finished s)\n\ngoal (1 subgoal):\n 1. y = hd (stack s) \\<Longrightarrow>\n    \\<phi> s' x < \\<delta> s' y \\<or>\n    \\<delta> s' y < \\<phi> s' x \\<and>\n    y \\<in> dom (finished s') \\<and> \\<phi> s' y < \\<phi> s' x", "with finish assms"], ["proof (chain)\npicking this:\n  parenthesis s\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s \\<noteq> []\n  pending s `` {u_} = {}\n  u_ = hd (stack s)\n  s' = finish u_ s\\<lparr>state.more := e_\\<rparr>\n  x \\<in> dom (discovered s')\n  y \\<in> dom (discovered s')\n  \\<delta> s' x < \\<delta> s' y\n  x \\<in> dom (finished s')\n  discovered s' = discovered s\n  counter s' = Suc (counter s)\n  finished s' = finished s(hd (stack s) \\<mapsto> counter s)\n  y \\<notin> dom (finished s)", "have \"\\<phi> s x < \\<delta> s y\""], ["proof (prove)\nusing this:\n  parenthesis s\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s \\<noteq> []\n  pending s `` {u_} = {}\n  u_ = hd (stack s)\n  s' = finish u_ s\\<lparr>state.more := e_\\<rparr>\n  x \\<in> dom (discovered s')\n  y \\<in> dom (discovered s')\n  \\<delta> s' x < \\<delta> s' y\n  x \\<in> dom (finished s')\n  discovered s' = discovered s\n  counter s' = Suc (counter s)\n  finished s' = finished s(hd (stack s) \\<mapsto> counter s)\n  y \\<notin> dom (finished s)\n\ngoal (1 subgoal):\n 1. \\<phi> s x < \\<delta> s y", "unfolding parenthesis_def"], ["proof (prove)\nusing this:\n  \\<forall>v\\<in>dom (discovered s).\n     \\<forall>w\\<in>dom (discovered s).\n        \\<delta> s v < \\<delta> s w \\<and>\n        v \\<in> dom (finished s) \\<longrightarrow>\n        \\<phi> s v < \\<delta> s w \\<or>\n        \\<delta> s w < \\<phi> s v \\<and>\n        w \\<in> dom (finished s) \\<and> \\<phi> s w < \\<phi> s v\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s \\<noteq> []\n  pending s `` {u_} = {}\n  u_ = hd (stack s)\n  s' = finish u_ s\\<lparr>state.more := e_\\<rparr>\n  x \\<in> dom (discovered s')\n  y \\<in> dom (discovered s')\n  \\<delta> s' x < \\<delta> s' y\n  x \\<in> dom (finished s')\n  discovered s' = discovered s\n  counter s' = Suc (counter s)\n  finished s' = finished s(hd (stack s) \\<mapsto> counter s)\n  y \\<notin> dom (finished s)\n\ngoal (1 subgoal):\n 1. \\<phi> s x < \\<delta> s y", "by auto"], ["proof (state)\nthis:\n  \\<phi> s x < \\<delta> s y\n\ngoal (1 subgoal):\n 1. y = hd (stack s) \\<Longrightarrow>\n    \\<phi> s' x < \\<delta> s' y \\<or>\n    \\<delta> s' y < \\<phi> s' x \\<and>\n    y \\<in> dom (finished s') \\<and> \\<phi> s' y < \\<phi> s' x", "hence ?DISJ"], ["proof (prove)\nusing this:\n  \\<phi> s x < \\<delta> s y\n\ngoal (1 subgoal):\n 1. \\<phi> s' x < \\<delta> s' y", "by simp"], ["proof (state)\nthis:\n  \\<phi> s' x < \\<delta> s' y\n\ngoal (1 subgoal):\n 1. y = hd (stack s) \\<Longrightarrow>\n    \\<phi> s' x < \\<delta> s' y \\<or>\n    \\<delta> s' y < \\<phi> s' x \\<and>\n    y \\<in> dom (finished s') \\<and> \\<phi> s' y < \\<phi> s' x", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<phi> s' x < \\<delta> s' y\n\ngoal (1 subgoal):\n 1. \\<phi> s' x < \\<delta> s' y \\<or>\n    \\<delta> s' y < \\<phi> s' x \\<and>\n    y \\<in> dom (finished s') \\<and> \\<phi> s' y < \\<phi> s' x", ".."], ["proof (state)\nthis:\n  \\<phi> s' x < \\<delta> s' y \\<or>\n  \\<delta> s' y < \\<phi> s' x \\<and>\n  y \\<in> dom (finished s') \\<and> \\<phi> s' y < \\<phi> s' x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<phi> s' x < \\<delta> s' y \\<or>\n  \\<delta> s' y < \\<phi> s' x \\<and>\n  y \\<in> dom (finished s') \\<and> \\<phi> s' y < \\<phi> s' x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<phi> s' x < \\<delta> s' y \\<or>\n  \\<delta> s' y < \\<phi> s' x \\<and>\n  y \\<in> dom (finished s') \\<and> \\<phi> s' y < \\<phi> s' x\n\ngoal (5 subgoals):\n 1. \\<And>e. parenthesis (empty_state e)\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>parenthesis s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s = []; v0 \\<notin> dom (discovered s);\n        v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> parenthesis s'\n 3. \\<And>s s' u e.\n       \\<lbrakk>parenthesis s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; pending s `` {u} = {};\n        u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> parenthesis s'\n 4. \\<And>s s' u v e c b.\n       \\<lbrakk>parenthesis s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); u = hd (stack s);\n        cross_edges s \\<subseteq> c; back_edges s \\<subseteq> b;\n        s' = s\n        \\<lparr>pending := pending s - {(u, v)}, state.more := e,\n           cross_edges := c, back_edges := b\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> parenthesis s'\n 5. \\<And>s s' u v e.\n       \\<lbrakk>parenthesis s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> parenthesis s'", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?x7 \\<in> dom (discovered s'); ?y7 \\<in> dom (discovered s');\n   \\<delta> s' ?x7 < \\<delta> s' ?y7; ?x7 \\<in> dom (finished s')\\<rbrakk>\n  \\<Longrightarrow> \\<phi> s' ?x7 < \\<delta> s' ?y7 \\<or>\n                    \\<delta> s' ?y7 < \\<phi> s' ?x7 \\<and>\n                    ?y7 \\<in> dom (finished s') \\<and>\n                    \\<phi> s' ?y7 < \\<phi> s' ?x7\n\ngoal (5 subgoals):\n 1. \\<And>e. parenthesis (empty_state e)\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>parenthesis s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s = []; v0 \\<notin> dom (discovered s);\n        v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> parenthesis s'\n 3. \\<And>s s' u e.\n       \\<lbrakk>parenthesis s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; pending s `` {u} = {};\n        u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> parenthesis s'\n 4. \\<And>s s' u v e c b.\n       \\<lbrakk>parenthesis s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); u = hd (stack s);\n        cross_edges s \\<subseteq> c; back_edges s \\<subseteq> b;\n        s' = s\n        \\<lparr>pending := pending s - {(u, v)}, state.more := e,\n           cross_edges := c, back_edges := b\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> parenthesis s'\n 5. \\<And>s s' u v e.\n       \\<lbrakk>parenthesis s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> parenthesis s'", "thus ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x7 \\<in> dom (discovered s'); ?y7 \\<in> dom (discovered s');\n   \\<delta> s' ?x7 < \\<delta> s' ?y7; ?x7 \\<in> dom (finished s')\\<rbrakk>\n  \\<Longrightarrow> \\<phi> s' ?x7 < \\<delta> s' ?y7 \\<or>\n                    \\<delta> s' ?y7 < \\<phi> s' ?x7 \\<and>\n                    ?y7 \\<in> dom (finished s') \\<and>\n                    \\<phi> s' ?y7 < \\<phi> s' ?x7\n\ngoal (1 subgoal):\n 1. parenthesis s'", "by (simp add: parenthesis_def)"], ["proof (state)\nthis:\n  parenthesis s'\n\ngoal (4 subgoals):\n 1. \\<And>e. parenthesis (empty_state e)\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>parenthesis s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s = []; v0 \\<notin> dom (discovered s);\n        v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> parenthesis s'\n 3. \\<And>s s' u v e c b.\n       \\<lbrakk>parenthesis s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); u = hd (stack s);\n        cross_edges s \\<subseteq> c; back_edges s \\<subseteq> b;\n        s' = s\n        \\<lparr>pending := pending s - {(u, v)}, state.more := e,\n           cross_edges := c, back_edges := b\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> parenthesis s'\n 4. \\<And>s s' u v e.\n       \\<lbrakk>parenthesis s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> parenthesis s'", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>e. parenthesis (empty_state e)\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>parenthesis s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s = []; v0 \\<notin> dom (discovered s);\n        v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> parenthesis s'\n 3. \\<And>s s' u v e c b.\n       \\<lbrakk>parenthesis s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); u = hd (stack s);\n        cross_edges s \\<subseteq> c; back_edges s \\<subseteq> b;\n        s' = s\n        \\<lparr>pending := pending s - {(u, v)}, state.more := e,\n           cross_edges := c, back_edges := b\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> parenthesis s'\n 4. \\<And>s s' u v e.\n       \\<lbrakk>parenthesis s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> parenthesis s'", "case (discover s s' u v)"], ["proof (state)\nthis:\n  parenthesis s\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s \\<noteq> []\n  v \\<in> pending s `` {u}\n  v \\<notin> dom (discovered s)\n  u = hd (stack s)\n  s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n  \\<lparr>state.more := e_\\<rparr>\n\ngoal (4 subgoals):\n 1. \\<And>e. parenthesis (empty_state e)\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>parenthesis s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s = []; v0 \\<notin> dom (discovered s);\n        v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> parenthesis s'\n 3. \\<And>s s' u v e c b.\n       \\<lbrakk>parenthesis s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); u = hd (stack s);\n        cross_edges s \\<subseteq> c; back_edges s \\<subseteq> b;\n        s' = s\n        \\<lparr>pending := pending s - {(u, v)}, state.more := e,\n           cross_edges := c, back_edges := b\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> parenthesis s'\n 4. \\<And>s s' u v e.\n       \\<lbrakk>parenthesis s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> parenthesis s'", "hence EQ[simp]: \"discovered s' = (discovered s)(v \\<mapsto> counter s)\" \n                    \"finished s' = finished s\"\n                    \"counter s' = Suc (counter s)\""], ["proof (prove)\nusing this:\n  parenthesis s\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s \\<noteq> []\n  v \\<in> pending s `` {u}\n  v \\<notin> dom (discovered s)\n  u = hd (stack s)\n  s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n  \\<lparr>state.more := e_\\<rparr>\n\ngoal (1 subgoal):\n 1. discovered s' = discovered s(v \\<mapsto> counter s) &&&\n    finished s' = finished s &&& counter s' = Suc (counter s)", "by simp_all"], ["proof (state)\nthis:\n  discovered s' = discovered s(v \\<mapsto> counter s)\n  finished s' = finished s\n  counter s' = Suc (counter s)\n\ngoal (4 subgoals):\n 1. \\<And>e. parenthesis (empty_state e)\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>parenthesis s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s = []; v0 \\<notin> dom (discovered s);\n        v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> parenthesis s'\n 3. \\<And>s s' u v e c b.\n       \\<lbrakk>parenthesis s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); u = hd (stack s);\n        cross_edges s \\<subseteq> c; back_edges s \\<subseteq> b;\n        s' = s\n        \\<lparr>pending := pending s - {(u, v)}, state.more := e,\n           cross_edges := c, back_edges := b\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> parenthesis s'\n 4. \\<And>s s' u v e.\n       \\<lbrakk>parenthesis s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> parenthesis s'", "from discover"], ["proof (chain)\npicking this:\n  parenthesis s\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s \\<noteq> []\n  v \\<in> pending s `` {u}\n  v \\<notin> dom (discovered s)\n  u = hd (stack s)\n  s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n  \\<lparr>state.more := e_\\<rparr>", "interpret DFS_invar where s=s"], ["proof (prove)\nusing this:\n  parenthesis s\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s \\<noteq> []\n  v \\<in> pending s `` {u}\n  v \\<notin> dom (discovered s)\n  u = hd (stack s)\n  s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n  \\<lparr>state.more := e_\\<rparr>\n\ngoal (1 subgoal):\n 1. DFS_invar G param s", "by simp"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>e. parenthesis (empty_state e)\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>parenthesis s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s = []; v0 \\<notin> dom (discovered s);\n        v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> parenthesis s'\n 3. \\<And>s s' u v e c b.\n       \\<lbrakk>parenthesis s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); u = hd (stack s);\n        cross_edges s \\<subseteq> c; back_edges s \\<subseteq> b;\n        s' = s\n        \\<lparr>pending := pending s - {(u, v)}, state.more := e,\n           cross_edges := c, back_edges := b\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> parenthesis s'\n 4. \\<And>s s' u v e.\n       \\<lbrakk>parenthesis s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> parenthesis s'", "from discover finished_discovered"], ["proof (chain)\npicking this:\n  parenthesis s\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s \\<noteq> []\n  v \\<in> pending s `` {u}\n  v \\<notin> dom (discovered s)\n  u = hd (stack s)\n  s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n  \\<lparr>state.more := e_\\<rparr>\n  dom (finished s) \\<subseteq> dom (discovered s)", "have \n      V': \"v \\<notin> dom (discovered s)\" \"v \\<notin> dom (finished s)\""], ["proof (prove)\nusing this:\n  parenthesis s\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s \\<noteq> []\n  v \\<in> pending s `` {u}\n  v \\<notin> dom (discovered s)\n  u = hd (stack s)\n  s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n  \\<lparr>state.more := e_\\<rparr>\n  dom (finished s) \\<subseteq> dom (discovered s)\n\ngoal (1 subgoal):\n 1. v \\<notin> dom (discovered s) &&& v \\<notin> dom (finished s)", "by auto"], ["proof (state)\nthis:\n  v \\<notin> dom (discovered s)\n  v \\<notin> dom (finished s)\n\ngoal (4 subgoals):\n 1. \\<And>e. parenthesis (empty_state e)\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>parenthesis s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s = []; v0 \\<notin> dom (discovered s);\n        v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> parenthesis s'\n 3. \\<And>s s' u v e c b.\n       \\<lbrakk>parenthesis s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); u = hd (stack s);\n        cross_edges s \\<subseteq> c; back_edges s \\<subseteq> b;\n        s' = s\n        \\<lparr>pending := pending s - {(u, v)}, state.more := e,\n           cross_edges := c, back_edges := b\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> parenthesis s'\n 4. \\<And>s s' u v e.\n       \\<lbrakk>parenthesis s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> parenthesis s'", "{"], ["proof (state)\nthis:\n  v \\<notin> dom (discovered s)\n  v \\<notin> dom (finished s)\n\ngoal (4 subgoals):\n 1. \\<And>e. parenthesis (empty_state e)\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>parenthesis s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s = []; v0 \\<notin> dom (discovered s);\n        v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> parenthesis s'\n 3. \\<And>s s' u v e c b.\n       \\<lbrakk>parenthesis s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); u = hd (stack s);\n        cross_edges s \\<subseteq> c; back_edges s \\<subseteq> b;\n        s' = s\n        \\<lparr>pending := pending s - {(u, v)}, state.more := e,\n           cross_edges := c, back_edges := b\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> parenthesis s'\n 4. \\<And>s s' u v e.\n       \\<lbrakk>parenthesis s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> parenthesis s'", "fix x y"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>e. parenthesis (empty_state e)\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>parenthesis s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s = []; v0 \\<notin> dom (discovered s);\n        v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> parenthesis s'\n 3. \\<And>s s' u v e c b.\n       \\<lbrakk>parenthesis s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); u = hd (stack s);\n        cross_edges s \\<subseteq> c; back_edges s \\<subseteq> b;\n        s' = s\n        \\<lparr>pending := pending s - {(u, v)}, state.more := e,\n           cross_edges := c, back_edges := b\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> parenthesis s'\n 4. \\<And>s s' u v e.\n       \\<lbrakk>parenthesis s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> parenthesis s'", "assume  dom: \"x \\<in> dom (discovered s')\" \"y \\<in> dom (discovered s')\"\n        and \\<delta>: \"\\<delta> s' x < \\<delta> s' y\"\n        and f: \"x \\<in> dom (finished s')\""], ["proof (state)\nthis:\n  x \\<in> dom (discovered s')\n  y \\<in> dom (discovered s')\n  \\<delta> s' x < \\<delta> s' y\n  x \\<in> dom (finished s')\n\ngoal (4 subgoals):\n 1. \\<And>e. parenthesis (empty_state e)\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>parenthesis s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s = []; v0 \\<notin> dom (discovered s);\n        v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> parenthesis s'\n 3. \\<And>s s' u v e c b.\n       \\<lbrakk>parenthesis s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); u = hd (stack s);\n        cross_edges s \\<subseteq> c; back_edges s \\<subseteq> b;\n        s' = s\n        \\<lparr>pending := pending s - {(u, v)}, state.more := e,\n           cross_edges := c, back_edges := b\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> parenthesis s'\n 4. \\<And>s s' u v e.\n       \\<lbrakk>parenthesis s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> parenthesis s'", "let ?DISJ = \"\\<phi> s' x < \\<delta> s' y\""], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>e. parenthesis (empty_state e)\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>parenthesis s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s = []; v0 \\<notin> dom (discovered s);\n        v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> parenthesis s'\n 3. \\<And>s s' u v e c b.\n       \\<lbrakk>parenthesis s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); u = hd (stack s);\n        cross_edges s \\<subseteq> c; back_edges s \\<subseteq> b;\n        s' = s\n        \\<lparr>pending := pending s - {(u, v)}, state.more := e,\n           cross_edges := c, back_edges := b\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> parenthesis s'\n 4. \\<And>s s' u v e.\n       \\<lbrakk>parenthesis s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> parenthesis s'", "let ?IN = \"\\<delta> s' y < \\<phi> s' x \\<and> y \\<in> dom (finished s') \\<and> \\<phi> s' y < \\<phi> s' x\""], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>e. parenthesis (empty_state e)\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>parenthesis s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s = []; v0 \\<notin> dom (discovered s);\n        v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> parenthesis s'\n 3. \\<And>s s' u v e c b.\n       \\<lbrakk>parenthesis s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); u = hd (stack s);\n        cross_edges s \\<subseteq> c; back_edges s \\<subseteq> b;\n        s' = s\n        \\<lparr>pending := pending s - {(u, v)}, state.more := e,\n           cross_edges := c, back_edges := b\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> parenthesis s'\n 4. \\<And>s s' u v e.\n       \\<lbrakk>parenthesis s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> parenthesis s'", "from dom V' f"], ["proof (chain)\npicking this:\n  x \\<in> dom (discovered s')\n  y \\<in> dom (discovered s')\n  v \\<notin> dom (discovered s)\n  v \\<notin> dom (finished s)\n  x \\<in> dom (finished s')", "have x: \"x \\<in> dom (discovered s)\"\"x \\<noteq> v\""], ["proof (prove)\nusing this:\n  x \\<in> dom (discovered s')\n  y \\<in> dom (discovered s')\n  v \\<notin> dom (discovered s)\n  v \\<notin> dom (finished s)\n  x \\<in> dom (finished s')\n\ngoal (1 subgoal):\n 1. x \\<in> dom (discovered s) &&& x \\<noteq> v", "by auto"], ["proof (state)\nthis:\n  x \\<in> dom (discovered s)\n  x \\<noteq> v\n\ngoal (4 subgoals):\n 1. \\<And>e. parenthesis (empty_state e)\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>parenthesis s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s = []; v0 \\<notin> dom (discovered s);\n        v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> parenthesis s'\n 3. \\<And>s s' u v e c b.\n       \\<lbrakk>parenthesis s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); u = hd (stack s);\n        cross_edges s \\<subseteq> c; back_edges s \\<subseteq> b;\n        s' = s\n        \\<lparr>pending := pending s - {(u, v)}, state.more := e,\n           cross_edges := c, back_edges := b\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> parenthesis s'\n 4. \\<And>s s' u v e.\n       \\<lbrakk>parenthesis s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> parenthesis s'", "have \"?DISJ \\<or> ?IN\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<phi> s' x < \\<delta> s' y \\<or>\n    \\<delta> s' y < \\<phi> s' x \\<and>\n    y \\<in> dom (finished s') \\<and> \\<phi> s' y < \\<phi> s' x", "proof (cases \"y = v\")"], ["proof (state)\ngoal (2 subgoals):\n 1. y = v \\<Longrightarrow>\n    \\<phi> s' x < \\<delta> s' y \\<or>\n    \\<delta> s' y < \\<phi> s' x \\<and>\n    y \\<in> dom (finished s') \\<and> \\<phi> s' y < \\<phi> s' x\n 2. y \\<noteq> v \\<Longrightarrow>\n    \\<phi> s' x < \\<delta> s' y \\<or>\n    \\<delta> s' y < \\<phi> s' x \\<and>\n    y \\<in> dom (finished s') \\<and> \\<phi> s' y < \\<phi> s' x", "case True"], ["proof (state)\nthis:\n  y = v\n\ngoal (2 subgoals):\n 1. y = v \\<Longrightarrow>\n    \\<phi> s' x < \\<delta> s' y \\<or>\n    \\<delta> s' y < \\<phi> s' x \\<and>\n    y \\<in> dom (finished s') \\<and> \\<phi> s' y < \\<phi> s' x\n 2. y \\<noteq> v \\<Longrightarrow>\n    \\<phi> s' x < \\<delta> s' y \\<or>\n    \\<delta> s' y < \\<phi> s' x \\<and>\n    y \\<in> dom (finished s') \\<and> \\<phi> s' y < \\<phi> s' x", "hence \"\\<delta> s' y = counter s\""], ["proof (prove)\nusing this:\n  y = v\n\ngoal (1 subgoal):\n 1. \\<delta> s' y = counter s", "by simp"], ["proof (state)\nthis:\n  \\<delta> s' y = counter s\n\ngoal (2 subgoals):\n 1. y = v \\<Longrightarrow>\n    \\<phi> s' x < \\<delta> s' y \\<or>\n    \\<delta> s' y < \\<phi> s' x \\<and>\n    y \\<in> dom (finished s') \\<and> \\<phi> s' y < \\<phi> s' x\n 2. y \\<noteq> v \\<Longrightarrow>\n    \\<phi> s' x < \\<delta> s' y \\<or>\n    \\<delta> s' y < \\<phi> s' x \\<and>\n    y \\<in> dom (finished s') \\<and> \\<phi> s' y < \\<phi> s' x", "moreover"], ["proof (state)\nthis:\n  \\<delta> s' y = counter s\n\ngoal (2 subgoals):\n 1. y = v \\<Longrightarrow>\n    \\<phi> s' x < \\<delta> s' y \\<or>\n    \\<delta> s' y < \\<phi> s' x \\<and>\n    y \\<in> dom (finished s') \\<and> \\<phi> s' y < \\<phi> s' x\n 2. y \\<noteq> v \\<Longrightarrow>\n    \\<phi> s' x < \\<delta> s' y \\<or>\n    \\<delta> s' y < \\<phi> s' x \\<and>\n    y \\<in> dom (finished s') \\<and> \\<phi> s' y < \\<phi> s' x", "from timing_less_counter x f"], ["proof (chain)\npicking this:\n  ?v \\<in> dom (discovered s) \\<Longrightarrow> \\<delta> s ?v < counter s\n  ?v \\<in> dom (finished s) \\<Longrightarrow> \\<phi> s ?v < counter s\n  x \\<in> dom (discovered s)\n  x \\<noteq> v\n  x \\<in> dom (finished s')", "have \"\\<phi> s' x < counter s\""], ["proof (prove)\nusing this:\n  ?v \\<in> dom (discovered s) \\<Longrightarrow> \\<delta> s ?v < counter s\n  ?v \\<in> dom (finished s) \\<Longrightarrow> \\<phi> s ?v < counter s\n  x \\<in> dom (discovered s)\n  x \\<noteq> v\n  x \\<in> dom (finished s')\n\ngoal (1 subgoal):\n 1. \\<phi> s' x < counter s", "by auto"], ["proof (state)\nthis:\n  \\<phi> s' x < counter s\n\ngoal (2 subgoals):\n 1. y = v \\<Longrightarrow>\n    \\<phi> s' x < \\<delta> s' y \\<or>\n    \\<delta> s' y < \\<phi> s' x \\<and>\n    y \\<in> dom (finished s') \\<and> \\<phi> s' y < \\<phi> s' x\n 2. y \\<noteq> v \\<Longrightarrow>\n    \\<phi> s' x < \\<delta> s' y \\<or>\n    \\<delta> s' y < \\<phi> s' x \\<and>\n    y \\<in> dom (finished s') \\<and> \\<phi> s' y < \\<phi> s' x", "ultimately"], ["proof (chain)\npicking this:\n  \\<delta> s' y = counter s\n  \\<phi> s' x < counter s", "have \"?DISJ\""], ["proof (prove)\nusing this:\n  \\<delta> s' y = counter s\n  \\<phi> s' x < counter s\n\ngoal (1 subgoal):\n 1. \\<phi> s' x < \\<delta> s' y", "by simp"], ["proof (state)\nthis:\n  \\<phi> s' x < \\<delta> s' y\n\ngoal (2 subgoals):\n 1. y = v \\<Longrightarrow>\n    \\<phi> s' x < \\<delta> s' y \\<or>\n    \\<delta> s' y < \\<phi> s' x \\<and>\n    y \\<in> dom (finished s') \\<and> \\<phi> s' y < \\<phi> s' x\n 2. y \\<noteq> v \\<Longrightarrow>\n    \\<phi> s' x < \\<delta> s' y \\<or>\n    \\<delta> s' y < \\<phi> s' x \\<and>\n    y \\<in> dom (finished s') \\<and> \\<phi> s' y < \\<phi> s' x", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<phi> s' x < \\<delta> s' y\n\ngoal (1 subgoal):\n 1. \\<phi> s' x < \\<delta> s' y \\<or>\n    \\<delta> s' y < \\<phi> s' x \\<and>\n    y \\<in> dom (finished s') \\<and> \\<phi> s' y < \\<phi> s' x", ".."], ["proof (state)\nthis:\n  \\<phi> s' x < \\<delta> s' y \\<or>\n  \\<delta> s' y < \\<phi> s' x \\<and>\n  y \\<in> dom (finished s') \\<and> \\<phi> s' y < \\<phi> s' x\n\ngoal (1 subgoal):\n 1. y \\<noteq> v \\<Longrightarrow>\n    \\<phi> s' x < \\<delta> s' y \\<or>\n    \\<delta> s' y < \\<phi> s' x \\<and>\n    y \\<in> dom (finished s') \\<and> \\<phi> s' y < \\<phi> s' x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. y \\<noteq> v \\<Longrightarrow>\n    \\<phi> s' x < \\<delta> s' y \\<or>\n    \\<delta> s' y < \\<phi> s' x \\<and>\n    y \\<in> dom (finished s') \\<and> \\<phi> s' y < \\<phi> s' x", "case False"], ["proof (state)\nthis:\n  y \\<noteq> v\n\ngoal (1 subgoal):\n 1. y \\<noteq> v \\<Longrightarrow>\n    \\<phi> s' x < \\<delta> s' y \\<or>\n    \\<delta> s' y < \\<phi> s' x \\<and>\n    y \\<in> dom (finished s') \\<and> \\<phi> s' y < \\<phi> s' x", "with dom"], ["proof (chain)\npicking this:\n  x \\<in> dom (discovered s')\n  y \\<in> dom (discovered s')\n  y \\<noteq> v", "have \"y \\<in> dom (discovered s)\""], ["proof (prove)\nusing this:\n  x \\<in> dom (discovered s')\n  y \\<in> dom (discovered s')\n  y \\<noteq> v\n\ngoal (1 subgoal):\n 1. y \\<in> dom (discovered s)", "by simp"], ["proof (state)\nthis:\n  y \\<in> dom (discovered s)\n\ngoal (1 subgoal):\n 1. y \\<noteq> v \\<Longrightarrow>\n    \\<phi> s' x < \\<delta> s' y \\<or>\n    \\<delta> s' y < \\<phi> s' x \\<and>\n    y \\<in> dom (finished s') \\<and> \\<phi> s' y < \\<phi> s' x", "with discover False \\<delta> f x"], ["proof (chain)\npicking this:\n  parenthesis s\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s \\<noteq> []\n  v \\<in> pending s `` {u}\n  v \\<notin> dom (discovered s)\n  u = hd (stack s)\n  s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n  \\<lparr>state.more := e_\\<rparr>\n  y \\<noteq> v\n  \\<delta> s' x < \\<delta> s' y\n  x \\<in> dom (finished s')\n  x \\<in> dom (discovered s)\n  x \\<noteq> v\n  y \\<in> dom (discovered s)", "show ?thesis"], ["proof (prove)\nusing this:\n  parenthesis s\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s \\<noteq> []\n  v \\<in> pending s `` {u}\n  v \\<notin> dom (discovered s)\n  u = hd (stack s)\n  s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n  \\<lparr>state.more := e_\\<rparr>\n  y \\<noteq> v\n  \\<delta> s' x < \\<delta> s' y\n  x \\<in> dom (finished s')\n  x \\<in> dom (discovered s)\n  x \\<noteq> v\n  y \\<in> dom (discovered s)\n\ngoal (1 subgoal):\n 1. \\<phi> s' x < \\<delta> s' y \\<or>\n    \\<delta> s' y < \\<phi> s' x \\<and>\n    y \\<in> dom (finished s') \\<and> \\<phi> s' y < \\<phi> s' x", "by (simp add: parenthesis_def)"], ["proof (state)\nthis:\n  \\<phi> s' x < \\<delta> s' y \\<or>\n  \\<delta> s' y < \\<phi> s' x \\<and>\n  y \\<in> dom (finished s') \\<and> \\<phi> s' y < \\<phi> s' x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<phi> s' x < \\<delta> s' y \\<or>\n  \\<delta> s' y < \\<phi> s' x \\<and>\n  y \\<in> dom (finished s') \\<and> \\<phi> s' y < \\<phi> s' x\n\ngoal (4 subgoals):\n 1. \\<And>e. parenthesis (empty_state e)\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>parenthesis s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s = []; v0 \\<notin> dom (discovered s);\n        v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> parenthesis s'\n 3. \\<And>s s' u v e c b.\n       \\<lbrakk>parenthesis s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); u = hd (stack s);\n        cross_edges s \\<subseteq> c; back_edges s \\<subseteq> b;\n        s' = s\n        \\<lparr>pending := pending s - {(u, v)}, state.more := e,\n           cross_edges := c, back_edges := b\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> parenthesis s'\n 4. \\<And>s s' u v e.\n       \\<lbrakk>parenthesis s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> parenthesis s'", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?x7 \\<in> dom (discovered s'); ?y7 \\<in> dom (discovered s');\n   \\<delta> s' ?x7 < \\<delta> s' ?y7; ?x7 \\<in> dom (finished s')\\<rbrakk>\n  \\<Longrightarrow> \\<phi> s' ?x7 < \\<delta> s' ?y7 \\<or>\n                    \\<delta> s' ?y7 < \\<phi> s' ?x7 \\<and>\n                    ?y7 \\<in> dom (finished s') \\<and>\n                    \\<phi> s' ?y7 < \\<phi> s' ?x7\n\ngoal (4 subgoals):\n 1. \\<And>e. parenthesis (empty_state e)\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>parenthesis s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s = []; v0 \\<notin> dom (discovered s);\n        v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> parenthesis s'\n 3. \\<And>s s' u v e c b.\n       \\<lbrakk>parenthesis s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); u = hd (stack s);\n        cross_edges s \\<subseteq> c; back_edges s \\<subseteq> b;\n        s' = s\n        \\<lparr>pending := pending s - {(u, v)}, state.more := e,\n           cross_edges := c, back_edges := b\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> parenthesis s'\n 4. \\<And>s s' u v e.\n       \\<lbrakk>parenthesis s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> parenthesis s'", "thus ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x7 \\<in> dom (discovered s'); ?y7 \\<in> dom (discovered s');\n   \\<delta> s' ?x7 < \\<delta> s' ?y7; ?x7 \\<in> dom (finished s')\\<rbrakk>\n  \\<Longrightarrow> \\<phi> s' ?x7 < \\<delta> s' ?y7 \\<or>\n                    \\<delta> s' ?y7 < \\<phi> s' ?x7 \\<and>\n                    ?y7 \\<in> dom (finished s') \\<and>\n                    \\<phi> s' ?y7 < \\<phi> s' ?x7\n\ngoal (1 subgoal):\n 1. parenthesis s'", "by (simp add: parenthesis_def)"], ["proof (state)\nthis:\n  parenthesis s'\n\ngoal (3 subgoals):\n 1. \\<And>e. parenthesis (empty_state e)\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>parenthesis s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s = []; v0 \\<notin> dom (discovered s);\n        v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> parenthesis s'\n 3. \\<And>s s' u v e c b.\n       \\<lbrakk>parenthesis s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); u = hd (stack s);\n        cross_edges s \\<subseteq> c; back_edges s \\<subseteq> b;\n        s' = s\n        \\<lparr>pending := pending s - {(u, v)}, state.more := e,\n           cross_edges := c, back_edges := b\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> parenthesis s'", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>e. parenthesis (empty_state e)\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>parenthesis s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s = []; v0 \\<notin> dom (discovered s);\n        v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> parenthesis s'\n 3. \\<And>s s' u v e c b.\n       \\<lbrakk>parenthesis s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); u = hd (stack s);\n        cross_edges s \\<subseteq> c; back_edges s \\<subseteq> b;\n        s' = s\n        \\<lparr>pending := pending s - {(u, v)}, state.more := e,\n           cross_edges := c, back_edges := b\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> parenthesis s'", "case (new_root s s' v0)"], ["proof (state)\nthis:\n  parenthesis s\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s = []\n  v0 \\<notin> dom (discovered s)\n  v0 \\<in> V0\n  s' = new_root v0 s\\<lparr>state.more := e_\\<rparr>\n\ngoal (3 subgoals):\n 1. \\<And>e. parenthesis (empty_state e)\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>parenthesis s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s = []; v0 \\<notin> dom (discovered s);\n        v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> parenthesis s'\n 3. \\<And>s s' u v e c b.\n       \\<lbrakk>parenthesis s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); u = hd (stack s);\n        cross_edges s \\<subseteq> c; back_edges s \\<subseteq> b;\n        s' = s\n        \\<lparr>pending := pending s - {(u, v)}, state.more := e,\n           cross_edges := c, back_edges := b\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> parenthesis s'", "then"], ["proof (chain)\npicking this:\n  parenthesis s\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s = []\n  v0 \\<notin> dom (discovered s)\n  v0 \\<in> V0\n  s' = new_root v0 s\\<lparr>state.more := e_\\<rparr>", "interpret DFS_invar where s=s"], ["proof (prove)\nusing this:\n  parenthesis s\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s = []\n  v0 \\<notin> dom (discovered s)\n  v0 \\<in> V0\n  s' = new_root v0 s\\<lparr>state.more := e_\\<rparr>\n\ngoal (1 subgoal):\n 1. DFS_invar G param s", "by simp"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>e. parenthesis (empty_state e)\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>parenthesis s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s = []; v0 \\<notin> dom (discovered s);\n        v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> parenthesis s'\n 3. \\<And>s s' u v e c b.\n       \\<lbrakk>parenthesis s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); u = hd (stack s);\n        cross_edges s \\<subseteq> c; back_edges s \\<subseteq> b;\n        s' = s\n        \\<lparr>pending := pending s - {(u, v)}, state.more := e,\n           cross_edges := c, back_edges := b\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> parenthesis s'", "from finished_discovered new_root"], ["proof (chain)\npicking this:\n  dom (finished s) \\<subseteq> dom (discovered s)\n  parenthesis s\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s = []\n  v0 \\<notin> dom (discovered s)\n  v0 \\<in> V0\n  s' = new_root v0 s\\<lparr>state.more := e_\\<rparr>", "have \"v0 \\<notin> dom (finished s')\""], ["proof (prove)\nusing this:\n  dom (finished s) \\<subseteq> dom (discovered s)\n  parenthesis s\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s = []\n  v0 \\<notin> dom (discovered s)\n  v0 \\<in> V0\n  s' = new_root v0 s\\<lparr>state.more := e_\\<rparr>\n\ngoal (1 subgoal):\n 1. v0 \\<notin> dom (finished s')", "by auto"], ["proof (state)\nthis:\n  v0 \\<notin> dom (finished s')\n\ngoal (3 subgoals):\n 1. \\<And>e. parenthesis (empty_state e)\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>parenthesis s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s = []; v0 \\<notin> dom (discovered s);\n        v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> parenthesis s'\n 3. \\<And>s s' u v e c b.\n       \\<lbrakk>parenthesis s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); u = hd (stack s);\n        cross_edges s \\<subseteq> c; back_edges s \\<subseteq> b;\n        s' = s\n        \\<lparr>pending := pending s - {(u, v)}, state.more := e,\n           cross_edges := c, back_edges := b\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> parenthesis s'", "with new_root timing_less_counter"], ["proof (chain)\npicking this:\n  parenthesis s\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s = []\n  v0 \\<notin> dom (discovered s)\n  v0 \\<in> V0\n  s' = new_root v0 s\\<lparr>state.more := e_\\<rparr>\n  ?v \\<in> dom (discovered s) \\<Longrightarrow> \\<delta> s ?v < counter s\n  ?v \\<in> dom (finished s) \\<Longrightarrow> \\<phi> s ?v < counter s\n  v0 \\<notin> dom (finished s')", "show ?case"], ["proof (prove)\nusing this:\n  parenthesis s\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s = []\n  v0 \\<notin> dom (discovered s)\n  v0 \\<in> V0\n  s' = new_root v0 s\\<lparr>state.more := e_\\<rparr>\n  ?v \\<in> dom (discovered s) \\<Longrightarrow> \\<delta> s ?v < counter s\n  ?v \\<in> dom (finished s) \\<Longrightarrow> \\<phi> s ?v < counter s\n  v0 \\<notin> dom (finished s')\n\ngoal (1 subgoal):\n 1. parenthesis s'", "by (simp add: parenthesis_def)"], ["proof (state)\nthis:\n  parenthesis s'\n\ngoal (2 subgoals):\n 1. \\<And>e. parenthesis (empty_state e)\n 2. \\<And>s s' u v e c b.\n       \\<lbrakk>parenthesis s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); u = hd (stack s);\n        cross_edges s \\<subseteq> c; back_edges s \\<subseteq> b;\n        s' = s\n        \\<lparr>pending := pending s - {(u, v)}, state.more := e,\n           cross_edges := c, back_edges := b\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> parenthesis s'", "qed (simp_all add: parenthesis_def)"], ["", "end"], ["", "end"], ["", "context DFS_invar begin"], ["", "context begin"], ["", "interpretation timing_syntax"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma parenthesis:\n    assumes \"v \\<in> dom (finished s)\" \"w \\<in> dom (discovered s)\"\n    and \"\\<delta> s v < \\<delta> s w\"\n    shows \"\\<phi> s v < \\<delta> s w \\<comment> \\<open>disjoint\\<close>\n           \\<or> (\\<phi> s v > \\<delta> s w \\<and> w \\<in> dom (finished s) \\<and> \\<phi> s w < \\<phi> s v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<phi> s v < \\<delta> s w \\<or>\n    \\<delta> s w < \\<phi> s v \\<and>\n    w \\<in> dom (finished s) \\<and> \\<phi> s w < \\<phi> s v", "using assms"], ["proof (prove)\nusing this:\n  v \\<in> dom (finished s)\n  w \\<in> dom (discovered s)\n  \\<delta> s v < \\<delta> s w\n\ngoal (1 subgoal):\n 1. \\<phi> s v < \\<delta> s w \\<or>\n    \\<delta> s w < \\<phi> s v \\<and>\n    w \\<in> dom (finished s) \\<and> \\<phi> s w < \\<phi> s v", "using i_parenthesis[THEN make_invar_thm]"], ["proof (prove)\nusing this:\n  v \\<in> dom (finished s)\n  w \\<in> dom (discovered s)\n  \\<delta> s v < \\<delta> s w\n  parenthesis s\n\ngoal (1 subgoal):\n 1. \\<phi> s v < \\<delta> s w \\<or>\n    \\<delta> s w < \\<phi> s v \\<and>\n    w \\<in> dom (finished s) \\<and> \\<phi> s w < \\<phi> s v", "using finished_discovered"], ["proof (prove)\nusing this:\n  v \\<in> dom (finished s)\n  w \\<in> dom (discovered s)\n  \\<delta> s v < \\<delta> s w\n  parenthesis s\n  dom (finished s) \\<subseteq> dom (discovered s)\n\ngoal (1 subgoal):\n 1. \\<phi> s v < \\<delta> s w \\<or>\n    \\<delta> s w < \\<phi> s v \\<and>\n    w \\<in> dom (finished s) \\<and> \\<phi> s w < \\<phi> s v", "unfolding parenthesis_def"], ["proof (prove)\nusing this:\n  v \\<in> dom (finished s)\n  w \\<in> dom (discovered s)\n  \\<delta> s v < \\<delta> s w\n  \\<forall>v\\<in>dom (discovered s).\n     \\<forall>w\\<in>dom (discovered s).\n        \\<delta> s v < \\<delta> s w \\<and>\n        v \\<in> dom (finished s) \\<longrightarrow>\n        \\<phi> s v < \\<delta> s w \\<or>\n        \\<delta> s w < \\<phi> s v \\<and>\n        w \\<in> dom (finished s) \\<and> \\<phi> s w < \\<phi> s v\n  dom (finished s) \\<subseteq> dom (discovered s)\n\ngoal (1 subgoal):\n 1. \\<phi> s v < \\<delta> s w \\<or>\n    \\<delta> s w < \\<phi> s v \\<and>\n    w \\<in> dom (finished s) \\<and> \\<phi> s w < \\<phi> s v", "by blast"], ["", "lemma parenthesis_contained:\n    assumes \"v \\<in> dom (finished s)\" \"w \\<in> dom (discovered s)\"\n    and \"\\<delta> s v < \\<delta> s w\" \"\\<phi> s v > \\<delta> s w\"\n    shows \"w \\<in> dom (finished s) \\<and> \\<phi> s w < \\<phi> s v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w \\<in> dom (finished s) \\<and> \\<phi> s w < \\<phi> s v", "using parenthesis assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>?v \\<in> dom (finished s); ?w \\<in> dom (discovered s);\n   \\<delta> s ?v < \\<delta> s ?w\\<rbrakk>\n  \\<Longrightarrow> \\<phi> s ?v < \\<delta> s ?w \\<or>\n                    \\<delta> s ?w < \\<phi> s ?v \\<and>\n                    ?w \\<in> dom (finished s) \\<and>\n                    \\<phi> s ?w < \\<phi> s ?v\n  v \\<in> dom (finished s)\n  w \\<in> dom (discovered s)\n  \\<delta> s v < \\<delta> s w\n  \\<delta> s w < \\<phi> s v\n\ngoal (1 subgoal):\n 1. w \\<in> dom (finished s) \\<and> \\<phi> s w < \\<phi> s v", "by force"], ["", "lemma parenthesis_disjoint:\n    assumes \"v \\<in> dom (finished s)\" \"w \\<in> dom (discovered s)\"\n    and \"\\<delta> s v < \\<delta> s w\" \"\\<phi> s w > \\<phi> s v\"\n    shows \"\\<phi> s v < \\<delta> s w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<phi> s v < \\<delta> s w", "using parenthesis assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>?v \\<in> dom (finished s); ?w \\<in> dom (discovered s);\n   \\<delta> s ?v < \\<delta> s ?w\\<rbrakk>\n  \\<Longrightarrow> \\<phi> s ?v < \\<delta> s ?w \\<or>\n                    \\<delta> s ?w < \\<phi> s ?v \\<and>\n                    ?w \\<in> dom (finished s) \\<and>\n                    \\<phi> s ?w < \\<phi> s ?v\n  v \\<in> dom (finished s)\n  w \\<in> dom (discovered s)\n  \\<delta> s v < \\<delta> s w\n  \\<phi> s v < \\<phi> s w\n\ngoal (1 subgoal):\n 1. \\<phi> s v < \\<delta> s w", "by force"], ["", "lemma finished_succ_contained:\n    assumes \"v \\<in> dom (finished s)\"\n    and \"w \\<in> succ v\"\n    and \"\\<delta> s v < \\<delta> s w\"\n    shows \"w \\<in> dom (finished s) \\<and> \\<phi> s w < \\<phi> s v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w \\<in> dom (finished s) \\<and> \\<phi> s w < \\<phi> s v", "using finished_succ_fin finished_imp_succ_discovered parenthesis_contained"], ["proof (prove)\nusing this:\n  \\<lbrakk>?v \\<in> dom (finished s); ?w \\<in> E `` {?v}\\<rbrakk>\n  \\<Longrightarrow> \\<delta> s ?w < \\<phi> s ?v\n  \\<lbrakk>?v \\<in> dom (finished s); ?w \\<in> E `` {?v}\\<rbrakk>\n  \\<Longrightarrow> ?w \\<in> dom (discovered s)\n  \\<lbrakk>?v \\<in> dom (finished s); ?w \\<in> dom (discovered s);\n   \\<delta> s ?v < \\<delta> s ?w; \\<delta> s ?w < \\<phi> s ?v\\<rbrakk>\n  \\<Longrightarrow> ?w \\<in> dom (finished s) \\<and>\n                    \\<phi> s ?w < \\<phi> s ?v\n\ngoal (1 subgoal):\n 1. w \\<in> dom (finished s) \\<and> \\<phi> s w < \\<phi> s v", "using assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>?v \\<in> dom (finished s); ?w \\<in> E `` {?v}\\<rbrakk>\n  \\<Longrightarrow> \\<delta> s ?w < \\<phi> s ?v\n  \\<lbrakk>?v \\<in> dom (finished s); ?w \\<in> E `` {?v}\\<rbrakk>\n  \\<Longrightarrow> ?w \\<in> dom (discovered s)\n  \\<lbrakk>?v \\<in> dom (finished s); ?w \\<in> dom (discovered s);\n   \\<delta> s ?v < \\<delta> s ?w; \\<delta> s ?w < \\<phi> s ?v\\<rbrakk>\n  \\<Longrightarrow> ?w \\<in> dom (finished s) \\<and>\n                    \\<phi> s ?w < \\<phi> s ?v\n  v \\<in> dom (finished s)\n  w \\<in> E `` {v}\n  \\<delta> s v < \\<delta> s w\n\ngoal (1 subgoal):\n 1. w \\<in> dom (finished s) \\<and> \\<phi> s w < \\<phi> s v", "by metis"], ["", "end"], ["", "end"], ["", "subsection \\<open>Edge Types\\<close>"], ["", "context param_DFS \nbegin"], ["", "abbreviation \"edges s \\<equiv> tree_edges s \\<union> cross_edges s \\<union> back_edges s\""], ["", "(* Demo for simple invariant proof *)"], ["", "lemma \"is_invar (\\<lambda>s. finite (edges s))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_invar\n     (\\<lambda>s.\n         finite (tree_edges s \\<union> cross_edges s \\<union> back_edges s))", "by (induction rule: establish_invarI) auto"], ["", "text \\<open>Sometimes it's useful to just chose between tree-edges and non-tree.\\<close>"], ["", "lemma edgesE_CB:\n    assumes \"x \\<in> edges s\"\n    and \"x \\<in> tree_edges s \\<Longrightarrow> P\"\n    and \"x \\<in> cross_edges s \\<union> back_edges s \\<Longrightarrow> P\"\n    shows \"P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P", "using assms"], ["proof (prove)\nusing this:\n  x \\<in> tree_edges s \\<union> cross_edges s \\<union> back_edges s\n  x \\<in> tree_edges s \\<Longrightarrow> P\n  x \\<in> cross_edges s \\<union> back_edges s \\<Longrightarrow> P\n\ngoal (1 subgoal):\n 1. P", "by auto"], ["", "definition \"edges_basic s \\<equiv> \n     Field (back_edges s) \\<subseteq> dom (discovered s) \\<and> back_edges s \\<subseteq> E - pending s\n   \\<and> Field (cross_edges s) \\<subseteq> dom (discovered s) \\<and> cross_edges s \\<subseteq> E - pending s\n   \\<and> Field (tree_edges s) \\<subseteq> dom (discovered s) \\<and> tree_edges s \\<subseteq> E - pending s\n   \\<and> back_edges s \\<inter> cross_edges s = {}\n   \\<and> back_edges s \\<inter> tree_edges s = {}\n   \\<and> cross_edges s \\<inter> tree_edges s = {}\n   \""], ["", "lemma i_edges_basic:\n    \"is_invar edges_basic\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_invar edges_basic", "unfolding edges_basic_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_invar\n     (\\<lambda>s.\n         Field (back_edges s) \\<subseteq> dom (discovered s) \\<and>\n         back_edges s \\<subseteq> E - pending s \\<and>\n         Field (cross_edges s) \\<subseteq> dom (discovered s) \\<and>\n         cross_edges s \\<subseteq> E - pending s \\<and>\n         Field (tree_edges s) \\<subseteq> dom (discovered s) \\<and>\n         tree_edges s \\<subseteq> E - pending s \\<and>\n         back_edges s \\<inter> cross_edges s = {} \\<and>\n         back_edges s \\<inter> tree_edges s = {} \\<and>\n         cross_edges s \\<inter> tree_edges s = {})", "proof (induct rule: is_invarI_full)"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>e.\n       Field (back_edges (empty_state e))\n       \\<subseteq> dom (discovered (empty_state e)) \\<and>\n       back_edges (empty_state e)\n       \\<subseteq> E - pending (empty_state e) \\<and>\n       Field (cross_edges (empty_state e))\n       \\<subseteq> dom (discovered (empty_state e)) \\<and>\n       cross_edges (empty_state e)\n       \\<subseteq> E - pending (empty_state e) \\<and>\n       Field (tree_edges (empty_state e))\n       \\<subseteq> dom (discovered (empty_state e)) \\<and>\n       tree_edges (empty_state e)\n       \\<subseteq> E - pending (empty_state e) \\<and>\n       back_edges (empty_state e) \\<inter> cross_edges (empty_state e) =\n       {} \\<and>\n       back_edges (empty_state e) \\<inter> tree_edges (empty_state e) =\n       {} \\<and>\n       cross_edges (empty_state e) \\<inter> tree_edges (empty_state e) = {}\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>Field (back_edges s) \\<subseteq> dom (discovered s) \\<and>\n                back_edges s \\<subseteq> E - pending s \\<and>\n                Field (cross_edges s) \\<subseteq> dom (discovered s) \\<and>\n                cross_edges s \\<subseteq> E - pending s \\<and>\n                Field (tree_edges s) \\<subseteq> dom (discovered s) \\<and>\n                tree_edges s \\<subseteq> E - pending s \\<and>\n                back_edges s \\<inter> cross_edges s = {} \\<and>\n                back_edges s \\<inter> tree_edges s = {} \\<and>\n                cross_edges s \\<inter> tree_edges s = {};\n        cond s; DFS_invar G param s; DFS_invar G param s'; stack s = [];\n        v0 \\<notin> dom (discovered s); v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> Field (back_edges s')\n                         \\<subseteq> dom (discovered s') \\<and>\n                         back_edges s' \\<subseteq> E - pending s' \\<and>\n                         Field (cross_edges s')\n                         \\<subseteq> dom (discovered s') \\<and>\n                         cross_edges s' \\<subseteq> E - pending s' \\<and>\n                         Field (tree_edges s')\n                         \\<subseteq> dom (discovered s') \\<and>\n                         tree_edges s' \\<subseteq> E - pending s' \\<and>\n                         back_edges s' \\<inter> cross_edges s' = {} \\<and>\n                         back_edges s' \\<inter> tree_edges s' = {} \\<and>\n                         cross_edges s' \\<inter> tree_edges s' = {}\n 3. \\<And>s s' u e.\n       \\<lbrakk>Field (back_edges s) \\<subseteq> dom (discovered s) \\<and>\n                back_edges s \\<subseteq> E - pending s \\<and>\n                Field (cross_edges s) \\<subseteq> dom (discovered s) \\<and>\n                cross_edges s \\<subseteq> E - pending s \\<and>\n                Field (tree_edges s) \\<subseteq> dom (discovered s) \\<and>\n                tree_edges s \\<subseteq> E - pending s \\<and>\n                back_edges s \\<inter> cross_edges s = {} \\<and>\n                back_edges s \\<inter> tree_edges s = {} \\<and>\n                cross_edges s \\<inter> tree_edges s = {};\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; pending s `` {u} = {}; u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> Field (back_edges s')\n                         \\<subseteq> dom (discovered s') \\<and>\n                         back_edges s' \\<subseteq> E - pending s' \\<and>\n                         Field (cross_edges s')\n                         \\<subseteq> dom (discovered s') \\<and>\n                         cross_edges s' \\<subseteq> E - pending s' \\<and>\n                         Field (tree_edges s')\n                         \\<subseteq> dom (discovered s') \\<and>\n                         tree_edges s' \\<subseteq> E - pending s' \\<and>\n                         back_edges s' \\<inter> cross_edges s' = {} \\<and>\n                         back_edges s' \\<inter> tree_edges s' = {} \\<and>\n                         cross_edges s' \\<inter> tree_edges s' = {}\n 4. \\<And>s s' u v e.\n       \\<lbrakk>Field (back_edges s) \\<subseteq> dom (discovered s) \\<and>\n                back_edges s \\<subseteq> E - pending s \\<and>\n                Field (cross_edges s) \\<subseteq> dom (discovered s) \\<and>\n                cross_edges s \\<subseteq> E - pending s \\<and>\n                Field (tree_edges s) \\<subseteq> dom (discovered s) \\<and>\n                tree_edges s \\<subseteq> E - pending s \\<and>\n                back_edges s \\<inter> cross_edges s = {} \\<and>\n                back_edges s \\<inter> tree_edges s = {} \\<and>\n                cross_edges s \\<inter> tree_edges s = {};\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        u = hd (stack s);\n        s' =\n        cross_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> Field (back_edges s')\n                         \\<subseteq> dom (discovered s') \\<and>\n                         back_edges s' \\<subseteq> E - pending s' \\<and>\n                         Field (cross_edges s')\n                         \\<subseteq> dom (discovered s') \\<and>\n                         cross_edges s' \\<subseteq> E - pending s' \\<and>\n                         Field (tree_edges s')\n                         \\<subseteq> dom (discovered s') \\<and>\n                         tree_edges s' \\<subseteq> E - pending s' \\<and>\n                         back_edges s' \\<inter> cross_edges s' = {} \\<and>\n                         back_edges s' \\<inter> tree_edges s' = {} \\<and>\n                         cross_edges s' \\<inter> tree_edges s' = {}\n 5. \\<And>s s' u v e.\n       \\<lbrakk>Field (back_edges s) \\<subseteq> dom (discovered s) \\<and>\n                back_edges s \\<subseteq> E - pending s \\<and>\n                Field (cross_edges s) \\<subseteq> dom (discovered s) \\<and>\n                cross_edges s \\<subseteq> E - pending s \\<and>\n                Field (tree_edges s) \\<subseteq> dom (discovered s) \\<and>\n                tree_edges s \\<subseteq> E - pending s \\<and>\n                back_edges s \\<inter> cross_edges s = {} \\<and>\n                back_edges s \\<inter> tree_edges s = {} \\<and>\n                cross_edges s \\<inter> tree_edges s = {};\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        u = hd (stack s);\n        s' =\n        back_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> Field (back_edges s')\n                         \\<subseteq> dom (discovered s') \\<and>\n                         back_edges s' \\<subseteq> E - pending s' \\<and>\n                         Field (cross_edges s')\n                         \\<subseteq> dom (discovered s') \\<and>\n                         cross_edges s' \\<subseteq> E - pending s' \\<and>\n                         Field (tree_edges s')\n                         \\<subseteq> dom (discovered s') \\<and>\n                         tree_edges s' \\<subseteq> E - pending s' \\<and>\n                         back_edges s' \\<inter> cross_edges s' = {} \\<and>\n                         back_edges s' \\<inter> tree_edges s' = {} \\<and>\n                         cross_edges s' \\<inter> tree_edges s' = {}\n 6. \\<And>s s' u v e.\n       \\<lbrakk>Field (back_edges s) \\<subseteq> dom (discovered s) \\<and>\n                back_edges s \\<subseteq> E - pending s \\<and>\n                Field (cross_edges s) \\<subseteq> dom (discovered s) \\<and>\n                cross_edges s \\<subseteq> E - pending s \\<and>\n                Field (tree_edges s) \\<subseteq> dom (discovered s) \\<and>\n                tree_edges s \\<subseteq> E - pending s \\<and>\n                back_edges s \\<inter> cross_edges s = {} \\<and>\n                back_edges s \\<inter> tree_edges s = {} \\<and>\n                cross_edges s \\<inter> tree_edges s = {};\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> Field (back_edges s')\n                         \\<subseteq> dom (discovered s') \\<and>\n                         back_edges s' \\<subseteq> E - pending s' \\<and>\n                         Field (cross_edges s')\n                         \\<subseteq> dom (discovered s') \\<and>\n                         cross_edges s' \\<subseteq> E - pending s' \\<and>\n                         Field (tree_edges s')\n                         \\<subseteq> dom (discovered s') \\<and>\n                         tree_edges s' \\<subseteq> E - pending s' \\<and>\n                         back_edges s' \\<inter> cross_edges s' = {} \\<and>\n                         back_edges s' \\<inter> tree_edges s' = {} \\<and>\n                         cross_edges s' \\<inter> tree_edges s' = {}", "case (back_edge s)"], ["proof (state)\nthis:\n  Field (back_edges s) \\<subseteq> dom (discovered s) \\<and>\n  back_edges s \\<subseteq> E - pending s \\<and>\n  Field (cross_edges s) \\<subseteq> dom (discovered s) \\<and>\n  cross_edges s \\<subseteq> E - pending s \\<and>\n  Field (tree_edges s) \\<subseteq> dom (discovered s) \\<and>\n  tree_edges s \\<subseteq> E - pending s \\<and>\n  back_edges s \\<inter> cross_edges s = {} \\<and>\n  back_edges s \\<inter> tree_edges s = {} \\<and>\n  cross_edges s \\<inter> tree_edges s = {}\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'_\n  stack s \\<noteq> []\n  v_ \\<in> pending s `` {u_}\n  v_ \\<in> dom (discovered s)\n  v_ \\<notin> dom (finished s)\n  u_ = hd (stack s)\n  s'_ = back_edge u_ v_ (s\\<lparr>pending := pending s - {(u_, v_)}\\<rparr>)\n  \\<lparr>state.more := e_\\<rparr>\n\ngoal (6 subgoals):\n 1. \\<And>e.\n       Field (back_edges (empty_state e))\n       \\<subseteq> dom (discovered (empty_state e)) \\<and>\n       back_edges (empty_state e)\n       \\<subseteq> E - pending (empty_state e) \\<and>\n       Field (cross_edges (empty_state e))\n       \\<subseteq> dom (discovered (empty_state e)) \\<and>\n       cross_edges (empty_state e)\n       \\<subseteq> E - pending (empty_state e) \\<and>\n       Field (tree_edges (empty_state e))\n       \\<subseteq> dom (discovered (empty_state e)) \\<and>\n       tree_edges (empty_state e)\n       \\<subseteq> E - pending (empty_state e) \\<and>\n       back_edges (empty_state e) \\<inter> cross_edges (empty_state e) =\n       {} \\<and>\n       back_edges (empty_state e) \\<inter> tree_edges (empty_state e) =\n       {} \\<and>\n       cross_edges (empty_state e) \\<inter> tree_edges (empty_state e) = {}\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>Field (back_edges s) \\<subseteq> dom (discovered s) \\<and>\n                back_edges s \\<subseteq> E - pending s \\<and>\n                Field (cross_edges s) \\<subseteq> dom (discovered s) \\<and>\n                cross_edges s \\<subseteq> E - pending s \\<and>\n                Field (tree_edges s) \\<subseteq> dom (discovered s) \\<and>\n                tree_edges s \\<subseteq> E - pending s \\<and>\n                back_edges s \\<inter> cross_edges s = {} \\<and>\n                back_edges s \\<inter> tree_edges s = {} \\<and>\n                cross_edges s \\<inter> tree_edges s = {};\n        cond s; DFS_invar G param s; DFS_invar G param s'; stack s = [];\n        v0 \\<notin> dom (discovered s); v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> Field (back_edges s')\n                         \\<subseteq> dom (discovered s') \\<and>\n                         back_edges s' \\<subseteq> E - pending s' \\<and>\n                         Field (cross_edges s')\n                         \\<subseteq> dom (discovered s') \\<and>\n                         cross_edges s' \\<subseteq> E - pending s' \\<and>\n                         Field (tree_edges s')\n                         \\<subseteq> dom (discovered s') \\<and>\n                         tree_edges s' \\<subseteq> E - pending s' \\<and>\n                         back_edges s' \\<inter> cross_edges s' = {} \\<and>\n                         back_edges s' \\<inter> tree_edges s' = {} \\<and>\n                         cross_edges s' \\<inter> tree_edges s' = {}\n 3. \\<And>s s' u e.\n       \\<lbrakk>Field (back_edges s) \\<subseteq> dom (discovered s) \\<and>\n                back_edges s \\<subseteq> E - pending s \\<and>\n                Field (cross_edges s) \\<subseteq> dom (discovered s) \\<and>\n                cross_edges s \\<subseteq> E - pending s \\<and>\n                Field (tree_edges s) \\<subseteq> dom (discovered s) \\<and>\n                tree_edges s \\<subseteq> E - pending s \\<and>\n                back_edges s \\<inter> cross_edges s = {} \\<and>\n                back_edges s \\<inter> tree_edges s = {} \\<and>\n                cross_edges s \\<inter> tree_edges s = {};\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; pending s `` {u} = {}; u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> Field (back_edges s')\n                         \\<subseteq> dom (discovered s') \\<and>\n                         back_edges s' \\<subseteq> E - pending s' \\<and>\n                         Field (cross_edges s')\n                         \\<subseteq> dom (discovered s') \\<and>\n                         cross_edges s' \\<subseteq> E - pending s' \\<and>\n                         Field (tree_edges s')\n                         \\<subseteq> dom (discovered s') \\<and>\n                         tree_edges s' \\<subseteq> E - pending s' \\<and>\n                         back_edges s' \\<inter> cross_edges s' = {} \\<and>\n                         back_edges s' \\<inter> tree_edges s' = {} \\<and>\n                         cross_edges s' \\<inter> tree_edges s' = {}\n 4. \\<And>s s' u v e.\n       \\<lbrakk>Field (back_edges s) \\<subseteq> dom (discovered s) \\<and>\n                back_edges s \\<subseteq> E - pending s \\<and>\n                Field (cross_edges s) \\<subseteq> dom (discovered s) \\<and>\n                cross_edges s \\<subseteq> E - pending s \\<and>\n                Field (tree_edges s) \\<subseteq> dom (discovered s) \\<and>\n                tree_edges s \\<subseteq> E - pending s \\<and>\n                back_edges s \\<inter> cross_edges s = {} \\<and>\n                back_edges s \\<inter> tree_edges s = {} \\<and>\n                cross_edges s \\<inter> tree_edges s = {};\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        u = hd (stack s);\n        s' =\n        cross_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> Field (back_edges s')\n                         \\<subseteq> dom (discovered s') \\<and>\n                         back_edges s' \\<subseteq> E - pending s' \\<and>\n                         Field (cross_edges s')\n                         \\<subseteq> dom (discovered s') \\<and>\n                         cross_edges s' \\<subseteq> E - pending s' \\<and>\n                         Field (tree_edges s')\n                         \\<subseteq> dom (discovered s') \\<and>\n                         tree_edges s' \\<subseteq> E - pending s' \\<and>\n                         back_edges s' \\<inter> cross_edges s' = {} \\<and>\n                         back_edges s' \\<inter> tree_edges s' = {} \\<and>\n                         cross_edges s' \\<inter> tree_edges s' = {}\n 5. \\<And>s s' u v e.\n       \\<lbrakk>Field (back_edges s) \\<subseteq> dom (discovered s) \\<and>\n                back_edges s \\<subseteq> E - pending s \\<and>\n                Field (cross_edges s) \\<subseteq> dom (discovered s) \\<and>\n                cross_edges s \\<subseteq> E - pending s \\<and>\n                Field (tree_edges s) \\<subseteq> dom (discovered s) \\<and>\n                tree_edges s \\<subseteq> E - pending s \\<and>\n                back_edges s \\<inter> cross_edges s = {} \\<and>\n                back_edges s \\<inter> tree_edges s = {} \\<and>\n                cross_edges s \\<inter> tree_edges s = {};\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        u = hd (stack s);\n        s' =\n        back_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> Field (back_edges s')\n                         \\<subseteq> dom (discovered s') \\<and>\n                         back_edges s' \\<subseteq> E - pending s' \\<and>\n                         Field (cross_edges s')\n                         \\<subseteq> dom (discovered s') \\<and>\n                         cross_edges s' \\<subseteq> E - pending s' \\<and>\n                         Field (tree_edges s')\n                         \\<subseteq> dom (discovered s') \\<and>\n                         tree_edges s' \\<subseteq> E - pending s' \\<and>\n                         back_edges s' \\<inter> cross_edges s' = {} \\<and>\n                         back_edges s' \\<inter> tree_edges s' = {} \\<and>\n                         cross_edges s' \\<inter> tree_edges s' = {}\n 6. \\<And>s s' u v e.\n       \\<lbrakk>Field (back_edges s) \\<subseteq> dom (discovered s) \\<and>\n                back_edges s \\<subseteq> E - pending s \\<and>\n                Field (cross_edges s) \\<subseteq> dom (discovered s) \\<and>\n                cross_edges s \\<subseteq> E - pending s \\<and>\n                Field (tree_edges s) \\<subseteq> dom (discovered s) \\<and>\n                tree_edges s \\<subseteq> E - pending s \\<and>\n                back_edges s \\<inter> cross_edges s = {} \\<and>\n                back_edges s \\<inter> tree_edges s = {} \\<and>\n                cross_edges s \\<inter> tree_edges s = {};\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> Field (back_edges s')\n                         \\<subseteq> dom (discovered s') \\<and>\n                         back_edges s' \\<subseteq> E - pending s' \\<and>\n                         Field (cross_edges s')\n                         \\<subseteq> dom (discovered s') \\<and>\n                         cross_edges s' \\<subseteq> E - pending s' \\<and>\n                         Field (tree_edges s')\n                         \\<subseteq> dom (discovered s') \\<and>\n                         tree_edges s' \\<subseteq> E - pending s' \\<and>\n                         back_edges s' \\<inter> cross_edges s' = {} \\<and>\n                         back_edges s' \\<inter> tree_edges s' = {} \\<and>\n                         cross_edges s' \\<inter> tree_edges s' = {}", "then"], ["proof (chain)\npicking this:\n  Field (back_edges s) \\<subseteq> dom (discovered s) \\<and>\n  back_edges s \\<subseteq> E - pending s \\<and>\n  Field (cross_edges s) \\<subseteq> dom (discovered s) \\<and>\n  cross_edges s \\<subseteq> E - pending s \\<and>\n  Field (tree_edges s) \\<subseteq> dom (discovered s) \\<and>\n  tree_edges s \\<subseteq> E - pending s \\<and>\n  back_edges s \\<inter> cross_edges s = {} \\<and>\n  back_edges s \\<inter> tree_edges s = {} \\<and>\n  cross_edges s \\<inter> tree_edges s = {}\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'_\n  stack s \\<noteq> []\n  v_ \\<in> pending s `` {u_}\n  v_ \\<in> dom (discovered s)\n  v_ \\<notin> dom (finished s)\n  u_ = hd (stack s)\n  s'_ = back_edge u_ v_ (s\\<lparr>pending := pending s - {(u_, v_)}\\<rparr>)\n  \\<lparr>state.more := e_\\<rparr>", "interpret DFS_invar where s=s"], ["proof (prove)\nusing this:\n  Field (back_edges s) \\<subseteq> dom (discovered s) \\<and>\n  back_edges s \\<subseteq> E - pending s \\<and>\n  Field (cross_edges s) \\<subseteq> dom (discovered s) \\<and>\n  cross_edges s \\<subseteq> E - pending s \\<and>\n  Field (tree_edges s) \\<subseteq> dom (discovered s) \\<and>\n  tree_edges s \\<subseteq> E - pending s \\<and>\n  back_edges s \\<inter> cross_edges s = {} \\<and>\n  back_edges s \\<inter> tree_edges s = {} \\<and>\n  cross_edges s \\<inter> tree_edges s = {}\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'_\n  stack s \\<noteq> []\n  v_ \\<in> pending s `` {u_}\n  v_ \\<in> dom (discovered s)\n  v_ \\<notin> dom (finished s)\n  u_ = hd (stack s)\n  s'_ = back_edge u_ v_ (s\\<lparr>pending := pending s - {(u_, v_)}\\<rparr>)\n  \\<lparr>state.more := e_\\<rparr>\n\ngoal (1 subgoal):\n 1. DFS_invar G param s", "by simp"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>e.\n       Field (back_edges (empty_state e))\n       \\<subseteq> dom (discovered (empty_state e)) \\<and>\n       back_edges (empty_state e)\n       \\<subseteq> E - pending (empty_state e) \\<and>\n       Field (cross_edges (empty_state e))\n       \\<subseteq> dom (discovered (empty_state e)) \\<and>\n       cross_edges (empty_state e)\n       \\<subseteq> E - pending (empty_state e) \\<and>\n       Field (tree_edges (empty_state e))\n       \\<subseteq> dom (discovered (empty_state e)) \\<and>\n       tree_edges (empty_state e)\n       \\<subseteq> E - pending (empty_state e) \\<and>\n       back_edges (empty_state e) \\<inter> cross_edges (empty_state e) =\n       {} \\<and>\n       back_edges (empty_state e) \\<inter> tree_edges (empty_state e) =\n       {} \\<and>\n       cross_edges (empty_state e) \\<inter> tree_edges (empty_state e) = {}\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>Field (back_edges s) \\<subseteq> dom (discovered s) \\<and>\n                back_edges s \\<subseteq> E - pending s \\<and>\n                Field (cross_edges s) \\<subseteq> dom (discovered s) \\<and>\n                cross_edges s \\<subseteq> E - pending s \\<and>\n                Field (tree_edges s) \\<subseteq> dom (discovered s) \\<and>\n                tree_edges s \\<subseteq> E - pending s \\<and>\n                back_edges s \\<inter> cross_edges s = {} \\<and>\n                back_edges s \\<inter> tree_edges s = {} \\<and>\n                cross_edges s \\<inter> tree_edges s = {};\n        cond s; DFS_invar G param s; DFS_invar G param s'; stack s = [];\n        v0 \\<notin> dom (discovered s); v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> Field (back_edges s')\n                         \\<subseteq> dom (discovered s') \\<and>\n                         back_edges s' \\<subseteq> E - pending s' \\<and>\n                         Field (cross_edges s')\n                         \\<subseteq> dom (discovered s') \\<and>\n                         cross_edges s' \\<subseteq> E - pending s' \\<and>\n                         Field (tree_edges s')\n                         \\<subseteq> dom (discovered s') \\<and>\n                         tree_edges s' \\<subseteq> E - pending s' \\<and>\n                         back_edges s' \\<inter> cross_edges s' = {} \\<and>\n                         back_edges s' \\<inter> tree_edges s' = {} \\<and>\n                         cross_edges s' \\<inter> tree_edges s' = {}\n 3. \\<And>s s' u e.\n       \\<lbrakk>Field (back_edges s) \\<subseteq> dom (discovered s) \\<and>\n                back_edges s \\<subseteq> E - pending s \\<and>\n                Field (cross_edges s) \\<subseteq> dom (discovered s) \\<and>\n                cross_edges s \\<subseteq> E - pending s \\<and>\n                Field (tree_edges s) \\<subseteq> dom (discovered s) \\<and>\n                tree_edges s \\<subseteq> E - pending s \\<and>\n                back_edges s \\<inter> cross_edges s = {} \\<and>\n                back_edges s \\<inter> tree_edges s = {} \\<and>\n                cross_edges s \\<inter> tree_edges s = {};\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; pending s `` {u} = {}; u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> Field (back_edges s')\n                         \\<subseteq> dom (discovered s') \\<and>\n                         back_edges s' \\<subseteq> E - pending s' \\<and>\n                         Field (cross_edges s')\n                         \\<subseteq> dom (discovered s') \\<and>\n                         cross_edges s' \\<subseteq> E - pending s' \\<and>\n                         Field (tree_edges s')\n                         \\<subseteq> dom (discovered s') \\<and>\n                         tree_edges s' \\<subseteq> E - pending s' \\<and>\n                         back_edges s' \\<inter> cross_edges s' = {} \\<and>\n                         back_edges s' \\<inter> tree_edges s' = {} \\<and>\n                         cross_edges s' \\<inter> tree_edges s' = {}\n 4. \\<And>s s' u v e.\n       \\<lbrakk>Field (back_edges s) \\<subseteq> dom (discovered s) \\<and>\n                back_edges s \\<subseteq> E - pending s \\<and>\n                Field (cross_edges s) \\<subseteq> dom (discovered s) \\<and>\n                cross_edges s \\<subseteq> E - pending s \\<and>\n                Field (tree_edges s) \\<subseteq> dom (discovered s) \\<and>\n                tree_edges s \\<subseteq> E - pending s \\<and>\n                back_edges s \\<inter> cross_edges s = {} \\<and>\n                back_edges s \\<inter> tree_edges s = {} \\<and>\n                cross_edges s \\<inter> tree_edges s = {};\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        u = hd (stack s);\n        s' =\n        cross_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> Field (back_edges s')\n                         \\<subseteq> dom (discovered s') \\<and>\n                         back_edges s' \\<subseteq> E - pending s' \\<and>\n                         Field (cross_edges s')\n                         \\<subseteq> dom (discovered s') \\<and>\n                         cross_edges s' \\<subseteq> E - pending s' \\<and>\n                         Field (tree_edges s')\n                         \\<subseteq> dom (discovered s') \\<and>\n                         tree_edges s' \\<subseteq> E - pending s' \\<and>\n                         back_edges s' \\<inter> cross_edges s' = {} \\<and>\n                         back_edges s' \\<inter> tree_edges s' = {} \\<and>\n                         cross_edges s' \\<inter> tree_edges s' = {}\n 5. \\<And>s s' u v e.\n       \\<lbrakk>Field (back_edges s) \\<subseteq> dom (discovered s) \\<and>\n                back_edges s \\<subseteq> E - pending s \\<and>\n                Field (cross_edges s) \\<subseteq> dom (discovered s) \\<and>\n                cross_edges s \\<subseteq> E - pending s \\<and>\n                Field (tree_edges s) \\<subseteq> dom (discovered s) \\<and>\n                tree_edges s \\<subseteq> E - pending s \\<and>\n                back_edges s \\<inter> cross_edges s = {} \\<and>\n                back_edges s \\<inter> tree_edges s = {} \\<and>\n                cross_edges s \\<inter> tree_edges s = {};\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        u = hd (stack s);\n        s' =\n        back_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> Field (back_edges s')\n                         \\<subseteq> dom (discovered s') \\<and>\n                         back_edges s' \\<subseteq> E - pending s' \\<and>\n                         Field (cross_edges s')\n                         \\<subseteq> dom (discovered s') \\<and>\n                         cross_edges s' \\<subseteq> E - pending s' \\<and>\n                         Field (tree_edges s')\n                         \\<subseteq> dom (discovered s') \\<and>\n                         tree_edges s' \\<subseteq> E - pending s' \\<and>\n                         back_edges s' \\<inter> cross_edges s' = {} \\<and>\n                         back_edges s' \\<inter> tree_edges s' = {} \\<and>\n                         cross_edges s' \\<inter> tree_edges s' = {}\n 6. \\<And>s s' u v e.\n       \\<lbrakk>Field (back_edges s) \\<subseteq> dom (discovered s) \\<and>\n                back_edges s \\<subseteq> E - pending s \\<and>\n                Field (cross_edges s) \\<subseteq> dom (discovered s) \\<and>\n                cross_edges s \\<subseteq> E - pending s \\<and>\n                Field (tree_edges s) \\<subseteq> dom (discovered s) \\<and>\n                tree_edges s \\<subseteq> E - pending s \\<and>\n                back_edges s \\<inter> cross_edges s = {} \\<and>\n                back_edges s \\<inter> tree_edges s = {} \\<and>\n                cross_edges s \\<inter> tree_edges s = {};\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> Field (back_edges s')\n                         \\<subseteq> dom (discovered s') \\<and>\n                         back_edges s' \\<subseteq> E - pending s' \\<and>\n                         Field (cross_edges s')\n                         \\<subseteq> dom (discovered s') \\<and>\n                         cross_edges s' \\<subseteq> E - pending s' \\<and>\n                         Field (tree_edges s')\n                         \\<subseteq> dom (discovered s') \\<and>\n                         tree_edges s' \\<subseteq> E - pending s' \\<and>\n                         back_edges s' \\<inter> cross_edges s' = {} \\<and>\n                         back_edges s' \\<inter> tree_edges s' = {} \\<and>\n                         cross_edges s' \\<inter> tree_edges s' = {}", "from back_edge"], ["proof (chain)\npicking this:\n  Field (back_edges s) \\<subseteq> dom (discovered s) \\<and>\n  back_edges s \\<subseteq> E - pending s \\<and>\n  Field (cross_edges s) \\<subseteq> dom (discovered s) \\<and>\n  cross_edges s \\<subseteq> E - pending s \\<and>\n  Field (tree_edges s) \\<subseteq> dom (discovered s) \\<and>\n  tree_edges s \\<subseteq> E - pending s \\<and>\n  back_edges s \\<inter> cross_edges s = {} \\<and>\n  back_edges s \\<inter> tree_edges s = {} \\<and>\n  cross_edges s \\<inter> tree_edges s = {}\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'_\n  stack s \\<noteq> []\n  v_ \\<in> pending s `` {u_}\n  v_ \\<in> dom (discovered s)\n  v_ \\<notin> dom (finished s)\n  u_ = hd (stack s)\n  s'_ = back_edge u_ v_ (s\\<lparr>pending := pending s - {(u_, v_)}\\<rparr>)\n  \\<lparr>state.more := e_\\<rparr>", "show ?case"], ["proof (prove)\nusing this:\n  Field (back_edges s) \\<subseteq> dom (discovered s) \\<and>\n  back_edges s \\<subseteq> E - pending s \\<and>\n  Field (cross_edges s) \\<subseteq> dom (discovered s) \\<and>\n  cross_edges s \\<subseteq> E - pending s \\<and>\n  Field (tree_edges s) \\<subseteq> dom (discovered s) \\<and>\n  tree_edges s \\<subseteq> E - pending s \\<and>\n  back_edges s \\<inter> cross_edges s = {} \\<and>\n  back_edges s \\<inter> tree_edges s = {} \\<and>\n  cross_edges s \\<inter> tree_edges s = {}\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'_\n  stack s \\<noteq> []\n  v_ \\<in> pending s `` {u_}\n  v_ \\<in> dom (discovered s)\n  v_ \\<notin> dom (finished s)\n  u_ = hd (stack s)\n  s'_ = back_edge u_ v_ (s\\<lparr>pending := pending s - {(u_, v_)}\\<rparr>)\n  \\<lparr>state.more := e_\\<rparr>\n\ngoal (1 subgoal):\n 1. Field (back_edges s'_) \\<subseteq> dom (discovered s'_) \\<and>\n    back_edges s'_ \\<subseteq> E - pending s'_ \\<and>\n    Field (cross_edges s'_) \\<subseteq> dom (discovered s'_) \\<and>\n    cross_edges s'_ \\<subseteq> E - pending s'_ \\<and>\n    Field (tree_edges s'_) \\<subseteq> dom (discovered s'_) \\<and>\n    tree_edges s'_ \\<subseteq> E - pending s'_ \\<and>\n    back_edges s'_ \\<inter> cross_edges s'_ = {} \\<and>\n    back_edges s'_ \\<inter> tree_edges s'_ = {} \\<and>\n    cross_edges s'_ \\<inter> tree_edges s'_ = {}", "by (auto dest: pendingD)"], ["proof (state)\nthis:\n  Field (back_edges s'_) \\<subseteq> dom (discovered s'_) \\<and>\n  back_edges s'_ \\<subseteq> E - pending s'_ \\<and>\n  Field (cross_edges s'_) \\<subseteq> dom (discovered s'_) \\<and>\n  cross_edges s'_ \\<subseteq> E - pending s'_ \\<and>\n  Field (tree_edges s'_) \\<subseteq> dom (discovered s'_) \\<and>\n  tree_edges s'_ \\<subseteq> E - pending s'_ \\<and>\n  back_edges s'_ \\<inter> cross_edges s'_ = {} \\<and>\n  back_edges s'_ \\<inter> tree_edges s'_ = {} \\<and>\n  cross_edges s'_ \\<inter> tree_edges s'_ = {}\n\ngoal (5 subgoals):\n 1. \\<And>e.\n       Field (back_edges (empty_state e))\n       \\<subseteq> dom (discovered (empty_state e)) \\<and>\n       back_edges (empty_state e)\n       \\<subseteq> E - pending (empty_state e) \\<and>\n       Field (cross_edges (empty_state e))\n       \\<subseteq> dom (discovered (empty_state e)) \\<and>\n       cross_edges (empty_state e)\n       \\<subseteq> E - pending (empty_state e) \\<and>\n       Field (tree_edges (empty_state e))\n       \\<subseteq> dom (discovered (empty_state e)) \\<and>\n       tree_edges (empty_state e)\n       \\<subseteq> E - pending (empty_state e) \\<and>\n       back_edges (empty_state e) \\<inter> cross_edges (empty_state e) =\n       {} \\<and>\n       back_edges (empty_state e) \\<inter> tree_edges (empty_state e) =\n       {} \\<and>\n       cross_edges (empty_state e) \\<inter> tree_edges (empty_state e) = {}\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>Field (back_edges s) \\<subseteq> dom (discovered s) \\<and>\n                back_edges s \\<subseteq> E - pending s \\<and>\n                Field (cross_edges s) \\<subseteq> dom (discovered s) \\<and>\n                cross_edges s \\<subseteq> E - pending s \\<and>\n                Field (tree_edges s) \\<subseteq> dom (discovered s) \\<and>\n                tree_edges s \\<subseteq> E - pending s \\<and>\n                back_edges s \\<inter> cross_edges s = {} \\<and>\n                back_edges s \\<inter> tree_edges s = {} \\<and>\n                cross_edges s \\<inter> tree_edges s = {};\n        cond s; DFS_invar G param s; DFS_invar G param s'; stack s = [];\n        v0 \\<notin> dom (discovered s); v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> Field (back_edges s')\n                         \\<subseteq> dom (discovered s') \\<and>\n                         back_edges s' \\<subseteq> E - pending s' \\<and>\n                         Field (cross_edges s')\n                         \\<subseteq> dom (discovered s') \\<and>\n                         cross_edges s' \\<subseteq> E - pending s' \\<and>\n                         Field (tree_edges s')\n                         \\<subseteq> dom (discovered s') \\<and>\n                         tree_edges s' \\<subseteq> E - pending s' \\<and>\n                         back_edges s' \\<inter> cross_edges s' = {} \\<and>\n                         back_edges s' \\<inter> tree_edges s' = {} \\<and>\n                         cross_edges s' \\<inter> tree_edges s' = {}\n 3. \\<And>s s' u e.\n       \\<lbrakk>Field (back_edges s) \\<subseteq> dom (discovered s) \\<and>\n                back_edges s \\<subseteq> E - pending s \\<and>\n                Field (cross_edges s) \\<subseteq> dom (discovered s) \\<and>\n                cross_edges s \\<subseteq> E - pending s \\<and>\n                Field (tree_edges s) \\<subseteq> dom (discovered s) \\<and>\n                tree_edges s \\<subseteq> E - pending s \\<and>\n                back_edges s \\<inter> cross_edges s = {} \\<and>\n                back_edges s \\<inter> tree_edges s = {} \\<and>\n                cross_edges s \\<inter> tree_edges s = {};\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; pending s `` {u} = {}; u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> Field (back_edges s')\n                         \\<subseteq> dom (discovered s') \\<and>\n                         back_edges s' \\<subseteq> E - pending s' \\<and>\n                         Field (cross_edges s')\n                         \\<subseteq> dom (discovered s') \\<and>\n                         cross_edges s' \\<subseteq> E - pending s' \\<and>\n                         Field (tree_edges s')\n                         \\<subseteq> dom (discovered s') \\<and>\n                         tree_edges s' \\<subseteq> E - pending s' \\<and>\n                         back_edges s' \\<inter> cross_edges s' = {} \\<and>\n                         back_edges s' \\<inter> tree_edges s' = {} \\<and>\n                         cross_edges s' \\<inter> tree_edges s' = {}\n 4. \\<And>s s' u v e.\n       \\<lbrakk>Field (back_edges s) \\<subseteq> dom (discovered s) \\<and>\n                back_edges s \\<subseteq> E - pending s \\<and>\n                Field (cross_edges s) \\<subseteq> dom (discovered s) \\<and>\n                cross_edges s \\<subseteq> E - pending s \\<and>\n                Field (tree_edges s) \\<subseteq> dom (discovered s) \\<and>\n                tree_edges s \\<subseteq> E - pending s \\<and>\n                back_edges s \\<inter> cross_edges s = {} \\<and>\n                back_edges s \\<inter> tree_edges s = {} \\<and>\n                cross_edges s \\<inter> tree_edges s = {};\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        u = hd (stack s);\n        s' =\n        cross_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> Field (back_edges s')\n                         \\<subseteq> dom (discovered s') \\<and>\n                         back_edges s' \\<subseteq> E - pending s' \\<and>\n                         Field (cross_edges s')\n                         \\<subseteq> dom (discovered s') \\<and>\n                         cross_edges s' \\<subseteq> E - pending s' \\<and>\n                         Field (tree_edges s')\n                         \\<subseteq> dom (discovered s') \\<and>\n                         tree_edges s' \\<subseteq> E - pending s' \\<and>\n                         back_edges s' \\<inter> cross_edges s' = {} \\<and>\n                         back_edges s' \\<inter> tree_edges s' = {} \\<and>\n                         cross_edges s' \\<inter> tree_edges s' = {}\n 5. \\<And>s s' u v e.\n       \\<lbrakk>Field (back_edges s) \\<subseteq> dom (discovered s) \\<and>\n                back_edges s \\<subseteq> E - pending s \\<and>\n                Field (cross_edges s) \\<subseteq> dom (discovered s) \\<and>\n                cross_edges s \\<subseteq> E - pending s \\<and>\n                Field (tree_edges s) \\<subseteq> dom (discovered s) \\<and>\n                tree_edges s \\<subseteq> E - pending s \\<and>\n                back_edges s \\<inter> cross_edges s = {} \\<and>\n                back_edges s \\<inter> tree_edges s = {} \\<and>\n                cross_edges s \\<inter> tree_edges s = {};\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> Field (back_edges s')\n                         \\<subseteq> dom (discovered s') \\<and>\n                         back_edges s' \\<subseteq> E - pending s' \\<and>\n                         Field (cross_edges s')\n                         \\<subseteq> dom (discovered s') \\<and>\n                         cross_edges s' \\<subseteq> E - pending s' \\<and>\n                         Field (tree_edges s')\n                         \\<subseteq> dom (discovered s') \\<and>\n                         tree_edges s' \\<subseteq> E - pending s' \\<and>\n                         back_edges s' \\<inter> cross_edges s' = {} \\<and>\n                         back_edges s' \\<inter> tree_edges s' = {} \\<and>\n                         cross_edges s' \\<inter> tree_edges s' = {}", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>e.\n       Field (back_edges (empty_state e))\n       \\<subseteq> dom (discovered (empty_state e)) \\<and>\n       back_edges (empty_state e)\n       \\<subseteq> E - pending (empty_state e) \\<and>\n       Field (cross_edges (empty_state e))\n       \\<subseteq> dom (discovered (empty_state e)) \\<and>\n       cross_edges (empty_state e)\n       \\<subseteq> E - pending (empty_state e) \\<and>\n       Field (tree_edges (empty_state e))\n       \\<subseteq> dom (discovered (empty_state e)) \\<and>\n       tree_edges (empty_state e)\n       \\<subseteq> E - pending (empty_state e) \\<and>\n       back_edges (empty_state e) \\<inter> cross_edges (empty_state e) =\n       {} \\<and>\n       back_edges (empty_state e) \\<inter> tree_edges (empty_state e) =\n       {} \\<and>\n       cross_edges (empty_state e) \\<inter> tree_edges (empty_state e) = {}\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>Field (back_edges s) \\<subseteq> dom (discovered s) \\<and>\n                back_edges s \\<subseteq> E - pending s \\<and>\n                Field (cross_edges s) \\<subseteq> dom (discovered s) \\<and>\n                cross_edges s \\<subseteq> E - pending s \\<and>\n                Field (tree_edges s) \\<subseteq> dom (discovered s) \\<and>\n                tree_edges s \\<subseteq> E - pending s \\<and>\n                back_edges s \\<inter> cross_edges s = {} \\<and>\n                back_edges s \\<inter> tree_edges s = {} \\<and>\n                cross_edges s \\<inter> tree_edges s = {};\n        cond s; DFS_invar G param s; DFS_invar G param s'; stack s = [];\n        v0 \\<notin> dom (discovered s); v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> Field (back_edges s')\n                         \\<subseteq> dom (discovered s') \\<and>\n                         back_edges s' \\<subseteq> E - pending s' \\<and>\n                         Field (cross_edges s')\n                         \\<subseteq> dom (discovered s') \\<and>\n                         cross_edges s' \\<subseteq> E - pending s' \\<and>\n                         Field (tree_edges s')\n                         \\<subseteq> dom (discovered s') \\<and>\n                         tree_edges s' \\<subseteq> E - pending s' \\<and>\n                         back_edges s' \\<inter> cross_edges s' = {} \\<and>\n                         back_edges s' \\<inter> tree_edges s' = {} \\<and>\n                         cross_edges s' \\<inter> tree_edges s' = {}\n 3. \\<And>s s' u e.\n       \\<lbrakk>Field (back_edges s) \\<subseteq> dom (discovered s) \\<and>\n                back_edges s \\<subseteq> E - pending s \\<and>\n                Field (cross_edges s) \\<subseteq> dom (discovered s) \\<and>\n                cross_edges s \\<subseteq> E - pending s \\<and>\n                Field (tree_edges s) \\<subseteq> dom (discovered s) \\<and>\n                tree_edges s \\<subseteq> E - pending s \\<and>\n                back_edges s \\<inter> cross_edges s = {} \\<and>\n                back_edges s \\<inter> tree_edges s = {} \\<and>\n                cross_edges s \\<inter> tree_edges s = {};\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; pending s `` {u} = {}; u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> Field (back_edges s')\n                         \\<subseteq> dom (discovered s') \\<and>\n                         back_edges s' \\<subseteq> E - pending s' \\<and>\n                         Field (cross_edges s')\n                         \\<subseteq> dom (discovered s') \\<and>\n                         cross_edges s' \\<subseteq> E - pending s' \\<and>\n                         Field (tree_edges s')\n                         \\<subseteq> dom (discovered s') \\<and>\n                         tree_edges s' \\<subseteq> E - pending s' \\<and>\n                         back_edges s' \\<inter> cross_edges s' = {} \\<and>\n                         back_edges s' \\<inter> tree_edges s' = {} \\<and>\n                         cross_edges s' \\<inter> tree_edges s' = {}\n 4. \\<And>s s' u v e.\n       \\<lbrakk>Field (back_edges s) \\<subseteq> dom (discovered s) \\<and>\n                back_edges s \\<subseteq> E - pending s \\<and>\n                Field (cross_edges s) \\<subseteq> dom (discovered s) \\<and>\n                cross_edges s \\<subseteq> E - pending s \\<and>\n                Field (tree_edges s) \\<subseteq> dom (discovered s) \\<and>\n                tree_edges s \\<subseteq> E - pending s \\<and>\n                back_edges s \\<inter> cross_edges s = {} \\<and>\n                back_edges s \\<inter> tree_edges s = {} \\<and>\n                cross_edges s \\<inter> tree_edges s = {};\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        u = hd (stack s);\n        s' =\n        cross_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> Field (back_edges s')\n                         \\<subseteq> dom (discovered s') \\<and>\n                         back_edges s' \\<subseteq> E - pending s' \\<and>\n                         Field (cross_edges s')\n                         \\<subseteq> dom (discovered s') \\<and>\n                         cross_edges s' \\<subseteq> E - pending s' \\<and>\n                         Field (tree_edges s')\n                         \\<subseteq> dom (discovered s') \\<and>\n                         tree_edges s' \\<subseteq> E - pending s' \\<and>\n                         back_edges s' \\<inter> cross_edges s' = {} \\<and>\n                         back_edges s' \\<inter> tree_edges s' = {} \\<and>\n                         cross_edges s' \\<inter> tree_edges s' = {}\n 5. \\<And>s s' u v e.\n       \\<lbrakk>Field (back_edges s) \\<subseteq> dom (discovered s) \\<and>\n                back_edges s \\<subseteq> E - pending s \\<and>\n                Field (cross_edges s) \\<subseteq> dom (discovered s) \\<and>\n                cross_edges s \\<subseteq> E - pending s \\<and>\n                Field (tree_edges s) \\<subseteq> dom (discovered s) \\<and>\n                tree_edges s \\<subseteq> E - pending s \\<and>\n                back_edges s \\<inter> cross_edges s = {} \\<and>\n                back_edges s \\<inter> tree_edges s = {} \\<and>\n                cross_edges s \\<inter> tree_edges s = {};\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> Field (back_edges s')\n                         \\<subseteq> dom (discovered s') \\<and>\n                         back_edges s' \\<subseteq> E - pending s' \\<and>\n                         Field (cross_edges s')\n                         \\<subseteq> dom (discovered s') \\<and>\n                         cross_edges s' \\<subseteq> E - pending s' \\<and>\n                         Field (tree_edges s')\n                         \\<subseteq> dom (discovered s') \\<and>\n                         tree_edges s' \\<subseteq> E - pending s' \\<and>\n                         back_edges s' \\<inter> cross_edges s' = {} \\<and>\n                         back_edges s' \\<inter> tree_edges s' = {} \\<and>\n                         cross_edges s' \\<inter> tree_edges s' = {}", "case (cross_edge s)"], ["proof (state)\nthis:\n  Field (back_edges s) \\<subseteq> dom (discovered s) \\<and>\n  back_edges s \\<subseteq> E - pending s \\<and>\n  Field (cross_edges s) \\<subseteq> dom (discovered s) \\<and>\n  cross_edges s \\<subseteq> E - pending s \\<and>\n  Field (tree_edges s) \\<subseteq> dom (discovered s) \\<and>\n  tree_edges s \\<subseteq> E - pending s \\<and>\n  back_edges s \\<inter> cross_edges s = {} \\<and>\n  back_edges s \\<inter> tree_edges s = {} \\<and>\n  cross_edges s \\<inter> tree_edges s = {}\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'_\n  stack s \\<noteq> []\n  v_ \\<in> pending s `` {u_}\n  v_ \\<in> dom (discovered s)\n  v_ \\<in> dom (finished s)\n  u_ = hd (stack s)\n  s'_ =\n  cross_edge u_ v_ (s\\<lparr>pending := pending s - {(u_, v_)}\\<rparr>)\n  \\<lparr>state.more := e_\\<rparr>\n\ngoal (5 subgoals):\n 1. \\<And>e.\n       Field (back_edges (empty_state e))\n       \\<subseteq> dom (discovered (empty_state e)) \\<and>\n       back_edges (empty_state e)\n       \\<subseteq> E - pending (empty_state e) \\<and>\n       Field (cross_edges (empty_state e))\n       \\<subseteq> dom (discovered (empty_state e)) \\<and>\n       cross_edges (empty_state e)\n       \\<subseteq> E - pending (empty_state e) \\<and>\n       Field (tree_edges (empty_state e))\n       \\<subseteq> dom (discovered (empty_state e)) \\<and>\n       tree_edges (empty_state e)\n       \\<subseteq> E - pending (empty_state e) \\<and>\n       back_edges (empty_state e) \\<inter> cross_edges (empty_state e) =\n       {} \\<and>\n       back_edges (empty_state e) \\<inter> tree_edges (empty_state e) =\n       {} \\<and>\n       cross_edges (empty_state e) \\<inter> tree_edges (empty_state e) = {}\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>Field (back_edges s) \\<subseteq> dom (discovered s) \\<and>\n                back_edges s \\<subseteq> E - pending s \\<and>\n                Field (cross_edges s) \\<subseteq> dom (discovered s) \\<and>\n                cross_edges s \\<subseteq> E - pending s \\<and>\n                Field (tree_edges s) \\<subseteq> dom (discovered s) \\<and>\n                tree_edges s \\<subseteq> E - pending s \\<and>\n                back_edges s \\<inter> cross_edges s = {} \\<and>\n                back_edges s \\<inter> tree_edges s = {} \\<and>\n                cross_edges s \\<inter> tree_edges s = {};\n        cond s; DFS_invar G param s; DFS_invar G param s'; stack s = [];\n        v0 \\<notin> dom (discovered s); v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> Field (back_edges s')\n                         \\<subseteq> dom (discovered s') \\<and>\n                         back_edges s' \\<subseteq> E - pending s' \\<and>\n                         Field (cross_edges s')\n                         \\<subseteq> dom (discovered s') \\<and>\n                         cross_edges s' \\<subseteq> E - pending s' \\<and>\n                         Field (tree_edges s')\n                         \\<subseteq> dom (discovered s') \\<and>\n                         tree_edges s' \\<subseteq> E - pending s' \\<and>\n                         back_edges s' \\<inter> cross_edges s' = {} \\<and>\n                         back_edges s' \\<inter> tree_edges s' = {} \\<and>\n                         cross_edges s' \\<inter> tree_edges s' = {}\n 3. \\<And>s s' u e.\n       \\<lbrakk>Field (back_edges s) \\<subseteq> dom (discovered s) \\<and>\n                back_edges s \\<subseteq> E - pending s \\<and>\n                Field (cross_edges s) \\<subseteq> dom (discovered s) \\<and>\n                cross_edges s \\<subseteq> E - pending s \\<and>\n                Field (tree_edges s) \\<subseteq> dom (discovered s) \\<and>\n                tree_edges s \\<subseteq> E - pending s \\<and>\n                back_edges s \\<inter> cross_edges s = {} \\<and>\n                back_edges s \\<inter> tree_edges s = {} \\<and>\n                cross_edges s \\<inter> tree_edges s = {};\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; pending s `` {u} = {}; u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> Field (back_edges s')\n                         \\<subseteq> dom (discovered s') \\<and>\n                         back_edges s' \\<subseteq> E - pending s' \\<and>\n                         Field (cross_edges s')\n                         \\<subseteq> dom (discovered s') \\<and>\n                         cross_edges s' \\<subseteq> E - pending s' \\<and>\n                         Field (tree_edges s')\n                         \\<subseteq> dom (discovered s') \\<and>\n                         tree_edges s' \\<subseteq> E - pending s' \\<and>\n                         back_edges s' \\<inter> cross_edges s' = {} \\<and>\n                         back_edges s' \\<inter> tree_edges s' = {} \\<and>\n                         cross_edges s' \\<inter> tree_edges s' = {}\n 4. \\<And>s s' u v e.\n       \\<lbrakk>Field (back_edges s) \\<subseteq> dom (discovered s) \\<and>\n                back_edges s \\<subseteq> E - pending s \\<and>\n                Field (cross_edges s) \\<subseteq> dom (discovered s) \\<and>\n                cross_edges s \\<subseteq> E - pending s \\<and>\n                Field (tree_edges s) \\<subseteq> dom (discovered s) \\<and>\n                tree_edges s \\<subseteq> E - pending s \\<and>\n                back_edges s \\<inter> cross_edges s = {} \\<and>\n                back_edges s \\<inter> tree_edges s = {} \\<and>\n                cross_edges s \\<inter> tree_edges s = {};\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        u = hd (stack s);\n        s' =\n        cross_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> Field (back_edges s')\n                         \\<subseteq> dom (discovered s') \\<and>\n                         back_edges s' \\<subseteq> E - pending s' \\<and>\n                         Field (cross_edges s')\n                         \\<subseteq> dom (discovered s') \\<and>\n                         cross_edges s' \\<subseteq> E - pending s' \\<and>\n                         Field (tree_edges s')\n                         \\<subseteq> dom (discovered s') \\<and>\n                         tree_edges s' \\<subseteq> E - pending s' \\<and>\n                         back_edges s' \\<inter> cross_edges s' = {} \\<and>\n                         back_edges s' \\<inter> tree_edges s' = {} \\<and>\n                         cross_edges s' \\<inter> tree_edges s' = {}\n 5. \\<And>s s' u v e.\n       \\<lbrakk>Field (back_edges s) \\<subseteq> dom (discovered s) \\<and>\n                back_edges s \\<subseteq> E - pending s \\<and>\n                Field (cross_edges s) \\<subseteq> dom (discovered s) \\<and>\n                cross_edges s \\<subseteq> E - pending s \\<and>\n                Field (tree_edges s) \\<subseteq> dom (discovered s) \\<and>\n                tree_edges s \\<subseteq> E - pending s \\<and>\n                back_edges s \\<inter> cross_edges s = {} \\<and>\n                back_edges s \\<inter> tree_edges s = {} \\<and>\n                cross_edges s \\<inter> tree_edges s = {};\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> Field (back_edges s')\n                         \\<subseteq> dom (discovered s') \\<and>\n                         back_edges s' \\<subseteq> E - pending s' \\<and>\n                         Field (cross_edges s')\n                         \\<subseteq> dom (discovered s') \\<and>\n                         cross_edges s' \\<subseteq> E - pending s' \\<and>\n                         Field (tree_edges s')\n                         \\<subseteq> dom (discovered s') \\<and>\n                         tree_edges s' \\<subseteq> E - pending s' \\<and>\n                         back_edges s' \\<inter> cross_edges s' = {} \\<and>\n                         back_edges s' \\<inter> tree_edges s' = {} \\<and>\n                         cross_edges s' \\<inter> tree_edges s' = {}", "then"], ["proof (chain)\npicking this:\n  Field (back_edges s) \\<subseteq> dom (discovered s) \\<and>\n  back_edges s \\<subseteq> E - pending s \\<and>\n  Field (cross_edges s) \\<subseteq> dom (discovered s) \\<and>\n  cross_edges s \\<subseteq> E - pending s \\<and>\n  Field (tree_edges s) \\<subseteq> dom (discovered s) \\<and>\n  tree_edges s \\<subseteq> E - pending s \\<and>\n  back_edges s \\<inter> cross_edges s = {} \\<and>\n  back_edges s \\<inter> tree_edges s = {} \\<and>\n  cross_edges s \\<inter> tree_edges s = {}\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'_\n  stack s \\<noteq> []\n  v_ \\<in> pending s `` {u_}\n  v_ \\<in> dom (discovered s)\n  v_ \\<in> dom (finished s)\n  u_ = hd (stack s)\n  s'_ =\n  cross_edge u_ v_ (s\\<lparr>pending := pending s - {(u_, v_)}\\<rparr>)\n  \\<lparr>state.more := e_\\<rparr>", "interpret DFS_invar where s=s"], ["proof (prove)\nusing this:\n  Field (back_edges s) \\<subseteq> dom (discovered s) \\<and>\n  back_edges s \\<subseteq> E - pending s \\<and>\n  Field (cross_edges s) \\<subseteq> dom (discovered s) \\<and>\n  cross_edges s \\<subseteq> E - pending s \\<and>\n  Field (tree_edges s) \\<subseteq> dom (discovered s) \\<and>\n  tree_edges s \\<subseteq> E - pending s \\<and>\n  back_edges s \\<inter> cross_edges s = {} \\<and>\n  back_edges s \\<inter> tree_edges s = {} \\<and>\n  cross_edges s \\<inter> tree_edges s = {}\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'_\n  stack s \\<noteq> []\n  v_ \\<in> pending s `` {u_}\n  v_ \\<in> dom (discovered s)\n  v_ \\<in> dom (finished s)\n  u_ = hd (stack s)\n  s'_ =\n  cross_edge u_ v_ (s\\<lparr>pending := pending s - {(u_, v_)}\\<rparr>)\n  \\<lparr>state.more := e_\\<rparr>\n\ngoal (1 subgoal):\n 1. DFS_invar G param s", "by simp"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>e.\n       Field (back_edges (empty_state e))\n       \\<subseteq> dom (discovered (empty_state e)) \\<and>\n       back_edges (empty_state e)\n       \\<subseteq> E - pending (empty_state e) \\<and>\n       Field (cross_edges (empty_state e))\n       \\<subseteq> dom (discovered (empty_state e)) \\<and>\n       cross_edges (empty_state e)\n       \\<subseteq> E - pending (empty_state e) \\<and>\n       Field (tree_edges (empty_state e))\n       \\<subseteq> dom (discovered (empty_state e)) \\<and>\n       tree_edges (empty_state e)\n       \\<subseteq> E - pending (empty_state e) \\<and>\n       back_edges (empty_state e) \\<inter> cross_edges (empty_state e) =\n       {} \\<and>\n       back_edges (empty_state e) \\<inter> tree_edges (empty_state e) =\n       {} \\<and>\n       cross_edges (empty_state e) \\<inter> tree_edges (empty_state e) = {}\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>Field (back_edges s) \\<subseteq> dom (discovered s) \\<and>\n                back_edges s \\<subseteq> E - pending s \\<and>\n                Field (cross_edges s) \\<subseteq> dom (discovered s) \\<and>\n                cross_edges s \\<subseteq> E - pending s \\<and>\n                Field (tree_edges s) \\<subseteq> dom (discovered s) \\<and>\n                tree_edges s \\<subseteq> E - pending s \\<and>\n                back_edges s \\<inter> cross_edges s = {} \\<and>\n                back_edges s \\<inter> tree_edges s = {} \\<and>\n                cross_edges s \\<inter> tree_edges s = {};\n        cond s; DFS_invar G param s; DFS_invar G param s'; stack s = [];\n        v0 \\<notin> dom (discovered s); v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> Field (back_edges s')\n                         \\<subseteq> dom (discovered s') \\<and>\n                         back_edges s' \\<subseteq> E - pending s' \\<and>\n                         Field (cross_edges s')\n                         \\<subseteq> dom (discovered s') \\<and>\n                         cross_edges s' \\<subseteq> E - pending s' \\<and>\n                         Field (tree_edges s')\n                         \\<subseteq> dom (discovered s') \\<and>\n                         tree_edges s' \\<subseteq> E - pending s' \\<and>\n                         back_edges s' \\<inter> cross_edges s' = {} \\<and>\n                         back_edges s' \\<inter> tree_edges s' = {} \\<and>\n                         cross_edges s' \\<inter> tree_edges s' = {}\n 3. \\<And>s s' u e.\n       \\<lbrakk>Field (back_edges s) \\<subseteq> dom (discovered s) \\<and>\n                back_edges s \\<subseteq> E - pending s \\<and>\n                Field (cross_edges s) \\<subseteq> dom (discovered s) \\<and>\n                cross_edges s \\<subseteq> E - pending s \\<and>\n                Field (tree_edges s) \\<subseteq> dom (discovered s) \\<and>\n                tree_edges s \\<subseteq> E - pending s \\<and>\n                back_edges s \\<inter> cross_edges s = {} \\<and>\n                back_edges s \\<inter> tree_edges s = {} \\<and>\n                cross_edges s \\<inter> tree_edges s = {};\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; pending s `` {u} = {}; u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> Field (back_edges s')\n                         \\<subseteq> dom (discovered s') \\<and>\n                         back_edges s' \\<subseteq> E - pending s' \\<and>\n                         Field (cross_edges s')\n                         \\<subseteq> dom (discovered s') \\<and>\n                         cross_edges s' \\<subseteq> E - pending s' \\<and>\n                         Field (tree_edges s')\n                         \\<subseteq> dom (discovered s') \\<and>\n                         tree_edges s' \\<subseteq> E - pending s' \\<and>\n                         back_edges s' \\<inter> cross_edges s' = {} \\<and>\n                         back_edges s' \\<inter> tree_edges s' = {} \\<and>\n                         cross_edges s' \\<inter> tree_edges s' = {}\n 4. \\<And>s s' u v e.\n       \\<lbrakk>Field (back_edges s) \\<subseteq> dom (discovered s) \\<and>\n                back_edges s \\<subseteq> E - pending s \\<and>\n                Field (cross_edges s) \\<subseteq> dom (discovered s) \\<and>\n                cross_edges s \\<subseteq> E - pending s \\<and>\n                Field (tree_edges s) \\<subseteq> dom (discovered s) \\<and>\n                tree_edges s \\<subseteq> E - pending s \\<and>\n                back_edges s \\<inter> cross_edges s = {} \\<and>\n                back_edges s \\<inter> tree_edges s = {} \\<and>\n                cross_edges s \\<inter> tree_edges s = {};\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        u = hd (stack s);\n        s' =\n        cross_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> Field (back_edges s')\n                         \\<subseteq> dom (discovered s') \\<and>\n                         back_edges s' \\<subseteq> E - pending s' \\<and>\n                         Field (cross_edges s')\n                         \\<subseteq> dom (discovered s') \\<and>\n                         cross_edges s' \\<subseteq> E - pending s' \\<and>\n                         Field (tree_edges s')\n                         \\<subseteq> dom (discovered s') \\<and>\n                         tree_edges s' \\<subseteq> E - pending s' \\<and>\n                         back_edges s' \\<inter> cross_edges s' = {} \\<and>\n                         back_edges s' \\<inter> tree_edges s' = {} \\<and>\n                         cross_edges s' \\<inter> tree_edges s' = {}\n 5. \\<And>s s' u v e.\n       \\<lbrakk>Field (back_edges s) \\<subseteq> dom (discovered s) \\<and>\n                back_edges s \\<subseteq> E - pending s \\<and>\n                Field (cross_edges s) \\<subseteq> dom (discovered s) \\<and>\n                cross_edges s \\<subseteq> E - pending s \\<and>\n                Field (tree_edges s) \\<subseteq> dom (discovered s) \\<and>\n                tree_edges s \\<subseteq> E - pending s \\<and>\n                back_edges s \\<inter> cross_edges s = {} \\<and>\n                back_edges s \\<inter> tree_edges s = {} \\<and>\n                cross_edges s \\<inter> tree_edges s = {};\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> Field (back_edges s')\n                         \\<subseteq> dom (discovered s') \\<and>\n                         back_edges s' \\<subseteq> E - pending s' \\<and>\n                         Field (cross_edges s')\n                         \\<subseteq> dom (discovered s') \\<and>\n                         cross_edges s' \\<subseteq> E - pending s' \\<and>\n                         Field (tree_edges s')\n                         \\<subseteq> dom (discovered s') \\<and>\n                         tree_edges s' \\<subseteq> E - pending s' \\<and>\n                         back_edges s' \\<inter> cross_edges s' = {} \\<and>\n                         back_edges s' \\<inter> tree_edges s' = {} \\<and>\n                         cross_edges s' \\<inter> tree_edges s' = {}", "from cross_edge"], ["proof (chain)\npicking this:\n  Field (back_edges s) \\<subseteq> dom (discovered s) \\<and>\n  back_edges s \\<subseteq> E - pending s \\<and>\n  Field (cross_edges s) \\<subseteq> dom (discovered s) \\<and>\n  cross_edges s \\<subseteq> E - pending s \\<and>\n  Field (tree_edges s) \\<subseteq> dom (discovered s) \\<and>\n  tree_edges s \\<subseteq> E - pending s \\<and>\n  back_edges s \\<inter> cross_edges s = {} \\<and>\n  back_edges s \\<inter> tree_edges s = {} \\<and>\n  cross_edges s \\<inter> tree_edges s = {}\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'_\n  stack s \\<noteq> []\n  v_ \\<in> pending s `` {u_}\n  v_ \\<in> dom (discovered s)\n  v_ \\<in> dom (finished s)\n  u_ = hd (stack s)\n  s'_ =\n  cross_edge u_ v_ (s\\<lparr>pending := pending s - {(u_, v_)}\\<rparr>)\n  \\<lparr>state.more := e_\\<rparr>", "show ?case"], ["proof (prove)\nusing this:\n  Field (back_edges s) \\<subseteq> dom (discovered s) \\<and>\n  back_edges s \\<subseteq> E - pending s \\<and>\n  Field (cross_edges s) \\<subseteq> dom (discovered s) \\<and>\n  cross_edges s \\<subseteq> E - pending s \\<and>\n  Field (tree_edges s) \\<subseteq> dom (discovered s) \\<and>\n  tree_edges s \\<subseteq> E - pending s \\<and>\n  back_edges s \\<inter> cross_edges s = {} \\<and>\n  back_edges s \\<inter> tree_edges s = {} \\<and>\n  cross_edges s \\<inter> tree_edges s = {}\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'_\n  stack s \\<noteq> []\n  v_ \\<in> pending s `` {u_}\n  v_ \\<in> dom (discovered s)\n  v_ \\<in> dom (finished s)\n  u_ = hd (stack s)\n  s'_ =\n  cross_edge u_ v_ (s\\<lparr>pending := pending s - {(u_, v_)}\\<rparr>)\n  \\<lparr>state.more := e_\\<rparr>\n\ngoal (1 subgoal):\n 1. Field (back_edges s'_) \\<subseteq> dom (discovered s'_) \\<and>\n    back_edges s'_ \\<subseteq> E - pending s'_ \\<and>\n    Field (cross_edges s'_) \\<subseteq> dom (discovered s'_) \\<and>\n    cross_edges s'_ \\<subseteq> E - pending s'_ \\<and>\n    Field (tree_edges s'_) \\<subseteq> dom (discovered s'_) \\<and>\n    tree_edges s'_ \\<subseteq> E - pending s'_ \\<and>\n    back_edges s'_ \\<inter> cross_edges s'_ = {} \\<and>\n    back_edges s'_ \\<inter> tree_edges s'_ = {} \\<and>\n    cross_edges s'_ \\<inter> tree_edges s'_ = {}", "by (auto dest: pendingD)"], ["proof (state)\nthis:\n  Field (back_edges s'_) \\<subseteq> dom (discovered s'_) \\<and>\n  back_edges s'_ \\<subseteq> E - pending s'_ \\<and>\n  Field (cross_edges s'_) \\<subseteq> dom (discovered s'_) \\<and>\n  cross_edges s'_ \\<subseteq> E - pending s'_ \\<and>\n  Field (tree_edges s'_) \\<subseteq> dom (discovered s'_) \\<and>\n  tree_edges s'_ \\<subseteq> E - pending s'_ \\<and>\n  back_edges s'_ \\<inter> cross_edges s'_ = {} \\<and>\n  back_edges s'_ \\<inter> tree_edges s'_ = {} \\<and>\n  cross_edges s'_ \\<inter> tree_edges s'_ = {}\n\ngoal (4 subgoals):\n 1. \\<And>e.\n       Field (back_edges (empty_state e))\n       \\<subseteq> dom (discovered (empty_state e)) \\<and>\n       back_edges (empty_state e)\n       \\<subseteq> E - pending (empty_state e) \\<and>\n       Field (cross_edges (empty_state e))\n       \\<subseteq> dom (discovered (empty_state e)) \\<and>\n       cross_edges (empty_state e)\n       \\<subseteq> E - pending (empty_state e) \\<and>\n       Field (tree_edges (empty_state e))\n       \\<subseteq> dom (discovered (empty_state e)) \\<and>\n       tree_edges (empty_state e)\n       \\<subseteq> E - pending (empty_state e) \\<and>\n       back_edges (empty_state e) \\<inter> cross_edges (empty_state e) =\n       {} \\<and>\n       back_edges (empty_state e) \\<inter> tree_edges (empty_state e) =\n       {} \\<and>\n       cross_edges (empty_state e) \\<inter> tree_edges (empty_state e) = {}\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>Field (back_edges s) \\<subseteq> dom (discovered s) \\<and>\n                back_edges s \\<subseteq> E - pending s \\<and>\n                Field (cross_edges s) \\<subseteq> dom (discovered s) \\<and>\n                cross_edges s \\<subseteq> E - pending s \\<and>\n                Field (tree_edges s) \\<subseteq> dom (discovered s) \\<and>\n                tree_edges s \\<subseteq> E - pending s \\<and>\n                back_edges s \\<inter> cross_edges s = {} \\<and>\n                back_edges s \\<inter> tree_edges s = {} \\<and>\n                cross_edges s \\<inter> tree_edges s = {};\n        cond s; DFS_invar G param s; DFS_invar G param s'; stack s = [];\n        v0 \\<notin> dom (discovered s); v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> Field (back_edges s')\n                         \\<subseteq> dom (discovered s') \\<and>\n                         back_edges s' \\<subseteq> E - pending s' \\<and>\n                         Field (cross_edges s')\n                         \\<subseteq> dom (discovered s') \\<and>\n                         cross_edges s' \\<subseteq> E - pending s' \\<and>\n                         Field (tree_edges s')\n                         \\<subseteq> dom (discovered s') \\<and>\n                         tree_edges s' \\<subseteq> E - pending s' \\<and>\n                         back_edges s' \\<inter> cross_edges s' = {} \\<and>\n                         back_edges s' \\<inter> tree_edges s' = {} \\<and>\n                         cross_edges s' \\<inter> tree_edges s' = {}\n 3. \\<And>s s' u e.\n       \\<lbrakk>Field (back_edges s) \\<subseteq> dom (discovered s) \\<and>\n                back_edges s \\<subseteq> E - pending s \\<and>\n                Field (cross_edges s) \\<subseteq> dom (discovered s) \\<and>\n                cross_edges s \\<subseteq> E - pending s \\<and>\n                Field (tree_edges s) \\<subseteq> dom (discovered s) \\<and>\n                tree_edges s \\<subseteq> E - pending s \\<and>\n                back_edges s \\<inter> cross_edges s = {} \\<and>\n                back_edges s \\<inter> tree_edges s = {} \\<and>\n                cross_edges s \\<inter> tree_edges s = {};\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; pending s `` {u} = {}; u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> Field (back_edges s')\n                         \\<subseteq> dom (discovered s') \\<and>\n                         back_edges s' \\<subseteq> E - pending s' \\<and>\n                         Field (cross_edges s')\n                         \\<subseteq> dom (discovered s') \\<and>\n                         cross_edges s' \\<subseteq> E - pending s' \\<and>\n                         Field (tree_edges s')\n                         \\<subseteq> dom (discovered s') \\<and>\n                         tree_edges s' \\<subseteq> E - pending s' \\<and>\n                         back_edges s' \\<inter> cross_edges s' = {} \\<and>\n                         back_edges s' \\<inter> tree_edges s' = {} \\<and>\n                         cross_edges s' \\<inter> tree_edges s' = {}\n 4. \\<And>s s' u v e.\n       \\<lbrakk>Field (back_edges s) \\<subseteq> dom (discovered s) \\<and>\n                back_edges s \\<subseteq> E - pending s \\<and>\n                Field (cross_edges s) \\<subseteq> dom (discovered s) \\<and>\n                cross_edges s \\<subseteq> E - pending s \\<and>\n                Field (tree_edges s) \\<subseteq> dom (discovered s) \\<and>\n                tree_edges s \\<subseteq> E - pending s \\<and>\n                back_edges s \\<inter> cross_edges s = {} \\<and>\n                back_edges s \\<inter> tree_edges s = {} \\<and>\n                cross_edges s \\<inter> tree_edges s = {};\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> Field (back_edges s')\n                         \\<subseteq> dom (discovered s') \\<and>\n                         back_edges s' \\<subseteq> E - pending s' \\<and>\n                         Field (cross_edges s')\n                         \\<subseteq> dom (discovered s') \\<and>\n                         cross_edges s' \\<subseteq> E - pending s' \\<and>\n                         Field (tree_edges s')\n                         \\<subseteq> dom (discovered s') \\<and>\n                         tree_edges s' \\<subseteq> E - pending s' \\<and>\n                         back_edges s' \\<inter> cross_edges s' = {} \\<and>\n                         back_edges s' \\<inter> tree_edges s' = {} \\<and>\n                         cross_edges s' \\<inter> tree_edges s' = {}", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>e.\n       Field (back_edges (empty_state e))\n       \\<subseteq> dom (discovered (empty_state e)) \\<and>\n       back_edges (empty_state e)\n       \\<subseteq> E - pending (empty_state e) \\<and>\n       Field (cross_edges (empty_state e))\n       \\<subseteq> dom (discovered (empty_state e)) \\<and>\n       cross_edges (empty_state e)\n       \\<subseteq> E - pending (empty_state e) \\<and>\n       Field (tree_edges (empty_state e))\n       \\<subseteq> dom (discovered (empty_state e)) \\<and>\n       tree_edges (empty_state e)\n       \\<subseteq> E - pending (empty_state e) \\<and>\n       back_edges (empty_state e) \\<inter> cross_edges (empty_state e) =\n       {} \\<and>\n       back_edges (empty_state e) \\<inter> tree_edges (empty_state e) =\n       {} \\<and>\n       cross_edges (empty_state e) \\<inter> tree_edges (empty_state e) = {}\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>Field (back_edges s) \\<subseteq> dom (discovered s) \\<and>\n                back_edges s \\<subseteq> E - pending s \\<and>\n                Field (cross_edges s) \\<subseteq> dom (discovered s) \\<and>\n                cross_edges s \\<subseteq> E - pending s \\<and>\n                Field (tree_edges s) \\<subseteq> dom (discovered s) \\<and>\n                tree_edges s \\<subseteq> E - pending s \\<and>\n                back_edges s \\<inter> cross_edges s = {} \\<and>\n                back_edges s \\<inter> tree_edges s = {} \\<and>\n                cross_edges s \\<inter> tree_edges s = {};\n        cond s; DFS_invar G param s; DFS_invar G param s'; stack s = [];\n        v0 \\<notin> dom (discovered s); v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> Field (back_edges s')\n                         \\<subseteq> dom (discovered s') \\<and>\n                         back_edges s' \\<subseteq> E - pending s' \\<and>\n                         Field (cross_edges s')\n                         \\<subseteq> dom (discovered s') \\<and>\n                         cross_edges s' \\<subseteq> E - pending s' \\<and>\n                         Field (tree_edges s')\n                         \\<subseteq> dom (discovered s') \\<and>\n                         tree_edges s' \\<subseteq> E - pending s' \\<and>\n                         back_edges s' \\<inter> cross_edges s' = {} \\<and>\n                         back_edges s' \\<inter> tree_edges s' = {} \\<and>\n                         cross_edges s' \\<inter> tree_edges s' = {}\n 3. \\<And>s s' u e.\n       \\<lbrakk>Field (back_edges s) \\<subseteq> dom (discovered s) \\<and>\n                back_edges s \\<subseteq> E - pending s \\<and>\n                Field (cross_edges s) \\<subseteq> dom (discovered s) \\<and>\n                cross_edges s \\<subseteq> E - pending s \\<and>\n                Field (tree_edges s) \\<subseteq> dom (discovered s) \\<and>\n                tree_edges s \\<subseteq> E - pending s \\<and>\n                back_edges s \\<inter> cross_edges s = {} \\<and>\n                back_edges s \\<inter> tree_edges s = {} \\<and>\n                cross_edges s \\<inter> tree_edges s = {};\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; pending s `` {u} = {}; u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> Field (back_edges s')\n                         \\<subseteq> dom (discovered s') \\<and>\n                         back_edges s' \\<subseteq> E - pending s' \\<and>\n                         Field (cross_edges s')\n                         \\<subseteq> dom (discovered s') \\<and>\n                         cross_edges s' \\<subseteq> E - pending s' \\<and>\n                         Field (tree_edges s')\n                         \\<subseteq> dom (discovered s') \\<and>\n                         tree_edges s' \\<subseteq> E - pending s' \\<and>\n                         back_edges s' \\<inter> cross_edges s' = {} \\<and>\n                         back_edges s' \\<inter> tree_edges s' = {} \\<and>\n                         cross_edges s' \\<inter> tree_edges s' = {}\n 4. \\<And>s s' u v e.\n       \\<lbrakk>Field (back_edges s) \\<subseteq> dom (discovered s) \\<and>\n                back_edges s \\<subseteq> E - pending s \\<and>\n                Field (cross_edges s) \\<subseteq> dom (discovered s) \\<and>\n                cross_edges s \\<subseteq> E - pending s \\<and>\n                Field (tree_edges s) \\<subseteq> dom (discovered s) \\<and>\n                tree_edges s \\<subseteq> E - pending s \\<and>\n                back_edges s \\<inter> cross_edges s = {} \\<and>\n                back_edges s \\<inter> tree_edges s = {} \\<and>\n                cross_edges s \\<inter> tree_edges s = {};\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> Field (back_edges s')\n                         \\<subseteq> dom (discovered s') \\<and>\n                         back_edges s' \\<subseteq> E - pending s' \\<and>\n                         Field (cross_edges s')\n                         \\<subseteq> dom (discovered s') \\<and>\n                         cross_edges s' \\<subseteq> E - pending s' \\<and>\n                         Field (tree_edges s')\n                         \\<subseteq> dom (discovered s') \\<and>\n                         tree_edges s' \\<subseteq> E - pending s' \\<and>\n                         back_edges s' \\<inter> cross_edges s' = {} \\<and>\n                         back_edges s' \\<inter> tree_edges s' = {} \\<and>\n                         cross_edges s' \\<inter> tree_edges s' = {}", "case (discover s)"], ["proof (state)\nthis:\n  Field (back_edges s) \\<subseteq> dom (discovered s) \\<and>\n  back_edges s \\<subseteq> E - pending s \\<and>\n  Field (cross_edges s) \\<subseteq> dom (discovered s) \\<and>\n  cross_edges s \\<subseteq> E - pending s \\<and>\n  Field (tree_edges s) \\<subseteq> dom (discovered s) \\<and>\n  tree_edges s \\<subseteq> E - pending s \\<and>\n  back_edges s \\<inter> cross_edges s = {} \\<and>\n  back_edges s \\<inter> tree_edges s = {} \\<and>\n  cross_edges s \\<inter> tree_edges s = {}\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'_\n  stack s \\<noteq> []\n  v_ \\<in> pending s `` {u_}\n  v_ \\<notin> dom (discovered s)\n  u_ = hd (stack s)\n  s'_ = discover u_ v_ (s\\<lparr>pending := pending s - {(u_, v_)}\\<rparr>)\n  \\<lparr>state.more := e_\\<rparr>\n\ngoal (4 subgoals):\n 1. \\<And>e.\n       Field (back_edges (empty_state e))\n       \\<subseteq> dom (discovered (empty_state e)) \\<and>\n       back_edges (empty_state e)\n       \\<subseteq> E - pending (empty_state e) \\<and>\n       Field (cross_edges (empty_state e))\n       \\<subseteq> dom (discovered (empty_state e)) \\<and>\n       cross_edges (empty_state e)\n       \\<subseteq> E - pending (empty_state e) \\<and>\n       Field (tree_edges (empty_state e))\n       \\<subseteq> dom (discovered (empty_state e)) \\<and>\n       tree_edges (empty_state e)\n       \\<subseteq> E - pending (empty_state e) \\<and>\n       back_edges (empty_state e) \\<inter> cross_edges (empty_state e) =\n       {} \\<and>\n       back_edges (empty_state e) \\<inter> tree_edges (empty_state e) =\n       {} \\<and>\n       cross_edges (empty_state e) \\<inter> tree_edges (empty_state e) = {}\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>Field (back_edges s) \\<subseteq> dom (discovered s) \\<and>\n                back_edges s \\<subseteq> E - pending s \\<and>\n                Field (cross_edges s) \\<subseteq> dom (discovered s) \\<and>\n                cross_edges s \\<subseteq> E - pending s \\<and>\n                Field (tree_edges s) \\<subseteq> dom (discovered s) \\<and>\n                tree_edges s \\<subseteq> E - pending s \\<and>\n                back_edges s \\<inter> cross_edges s = {} \\<and>\n                back_edges s \\<inter> tree_edges s = {} \\<and>\n                cross_edges s \\<inter> tree_edges s = {};\n        cond s; DFS_invar G param s; DFS_invar G param s'; stack s = [];\n        v0 \\<notin> dom (discovered s); v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> Field (back_edges s')\n                         \\<subseteq> dom (discovered s') \\<and>\n                         back_edges s' \\<subseteq> E - pending s' \\<and>\n                         Field (cross_edges s')\n                         \\<subseteq> dom (discovered s') \\<and>\n                         cross_edges s' \\<subseteq> E - pending s' \\<and>\n                         Field (tree_edges s')\n                         \\<subseteq> dom (discovered s') \\<and>\n                         tree_edges s' \\<subseteq> E - pending s' \\<and>\n                         back_edges s' \\<inter> cross_edges s' = {} \\<and>\n                         back_edges s' \\<inter> tree_edges s' = {} \\<and>\n                         cross_edges s' \\<inter> tree_edges s' = {}\n 3. \\<And>s s' u e.\n       \\<lbrakk>Field (back_edges s) \\<subseteq> dom (discovered s) \\<and>\n                back_edges s \\<subseteq> E - pending s \\<and>\n                Field (cross_edges s) \\<subseteq> dom (discovered s) \\<and>\n                cross_edges s \\<subseteq> E - pending s \\<and>\n                Field (tree_edges s) \\<subseteq> dom (discovered s) \\<and>\n                tree_edges s \\<subseteq> E - pending s \\<and>\n                back_edges s \\<inter> cross_edges s = {} \\<and>\n                back_edges s \\<inter> tree_edges s = {} \\<and>\n                cross_edges s \\<inter> tree_edges s = {};\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; pending s `` {u} = {}; u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> Field (back_edges s')\n                         \\<subseteq> dom (discovered s') \\<and>\n                         back_edges s' \\<subseteq> E - pending s' \\<and>\n                         Field (cross_edges s')\n                         \\<subseteq> dom (discovered s') \\<and>\n                         cross_edges s' \\<subseteq> E - pending s' \\<and>\n                         Field (tree_edges s')\n                         \\<subseteq> dom (discovered s') \\<and>\n                         tree_edges s' \\<subseteq> E - pending s' \\<and>\n                         back_edges s' \\<inter> cross_edges s' = {} \\<and>\n                         back_edges s' \\<inter> tree_edges s' = {} \\<and>\n                         cross_edges s' \\<inter> tree_edges s' = {}\n 4. \\<And>s s' u v e.\n       \\<lbrakk>Field (back_edges s) \\<subseteq> dom (discovered s) \\<and>\n                back_edges s \\<subseteq> E - pending s \\<and>\n                Field (cross_edges s) \\<subseteq> dom (discovered s) \\<and>\n                cross_edges s \\<subseteq> E - pending s \\<and>\n                Field (tree_edges s) \\<subseteq> dom (discovered s) \\<and>\n                tree_edges s \\<subseteq> E - pending s \\<and>\n                back_edges s \\<inter> cross_edges s = {} \\<and>\n                back_edges s \\<inter> tree_edges s = {} \\<and>\n                cross_edges s \\<inter> tree_edges s = {};\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> Field (back_edges s')\n                         \\<subseteq> dom (discovered s') \\<and>\n                         back_edges s' \\<subseteq> E - pending s' \\<and>\n                         Field (cross_edges s')\n                         \\<subseteq> dom (discovered s') \\<and>\n                         cross_edges s' \\<subseteq> E - pending s' \\<and>\n                         Field (tree_edges s')\n                         \\<subseteq> dom (discovered s') \\<and>\n                         tree_edges s' \\<subseteq> E - pending s' \\<and>\n                         back_edges s' \\<inter> cross_edges s' = {} \\<and>\n                         back_edges s' \\<inter> tree_edges s' = {} \\<and>\n                         cross_edges s' \\<inter> tree_edges s' = {}", "then"], ["proof (chain)\npicking this:\n  Field (back_edges s) \\<subseteq> dom (discovered s) \\<and>\n  back_edges s \\<subseteq> E - pending s \\<and>\n  Field (cross_edges s) \\<subseteq> dom (discovered s) \\<and>\n  cross_edges s \\<subseteq> E - pending s \\<and>\n  Field (tree_edges s) \\<subseteq> dom (discovered s) \\<and>\n  tree_edges s \\<subseteq> E - pending s \\<and>\n  back_edges s \\<inter> cross_edges s = {} \\<and>\n  back_edges s \\<inter> tree_edges s = {} \\<and>\n  cross_edges s \\<inter> tree_edges s = {}\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'_\n  stack s \\<noteq> []\n  v_ \\<in> pending s `` {u_}\n  v_ \\<notin> dom (discovered s)\n  u_ = hd (stack s)\n  s'_ = discover u_ v_ (s\\<lparr>pending := pending s - {(u_, v_)}\\<rparr>)\n  \\<lparr>state.more := e_\\<rparr>", "interpret DFS_invar where s=s"], ["proof (prove)\nusing this:\n  Field (back_edges s) \\<subseteq> dom (discovered s) \\<and>\n  back_edges s \\<subseteq> E - pending s \\<and>\n  Field (cross_edges s) \\<subseteq> dom (discovered s) \\<and>\n  cross_edges s \\<subseteq> E - pending s \\<and>\n  Field (tree_edges s) \\<subseteq> dom (discovered s) \\<and>\n  tree_edges s \\<subseteq> E - pending s \\<and>\n  back_edges s \\<inter> cross_edges s = {} \\<and>\n  back_edges s \\<inter> tree_edges s = {} \\<and>\n  cross_edges s \\<inter> tree_edges s = {}\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'_\n  stack s \\<noteq> []\n  v_ \\<in> pending s `` {u_}\n  v_ \\<notin> dom (discovered s)\n  u_ = hd (stack s)\n  s'_ = discover u_ v_ (s\\<lparr>pending := pending s - {(u_, v_)}\\<rparr>)\n  \\<lparr>state.more := e_\\<rparr>\n\ngoal (1 subgoal):\n 1. DFS_invar G param s", "by simp"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>e.\n       Field (back_edges (empty_state e))\n       \\<subseteq> dom (discovered (empty_state e)) \\<and>\n       back_edges (empty_state e)\n       \\<subseteq> E - pending (empty_state e) \\<and>\n       Field (cross_edges (empty_state e))\n       \\<subseteq> dom (discovered (empty_state e)) \\<and>\n       cross_edges (empty_state e)\n       \\<subseteq> E - pending (empty_state e) \\<and>\n       Field (tree_edges (empty_state e))\n       \\<subseteq> dom (discovered (empty_state e)) \\<and>\n       tree_edges (empty_state e)\n       \\<subseteq> E - pending (empty_state e) \\<and>\n       back_edges (empty_state e) \\<inter> cross_edges (empty_state e) =\n       {} \\<and>\n       back_edges (empty_state e) \\<inter> tree_edges (empty_state e) =\n       {} \\<and>\n       cross_edges (empty_state e) \\<inter> tree_edges (empty_state e) = {}\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>Field (back_edges s) \\<subseteq> dom (discovered s) \\<and>\n                back_edges s \\<subseteq> E - pending s \\<and>\n                Field (cross_edges s) \\<subseteq> dom (discovered s) \\<and>\n                cross_edges s \\<subseteq> E - pending s \\<and>\n                Field (tree_edges s) \\<subseteq> dom (discovered s) \\<and>\n                tree_edges s \\<subseteq> E - pending s \\<and>\n                back_edges s \\<inter> cross_edges s = {} \\<and>\n                back_edges s \\<inter> tree_edges s = {} \\<and>\n                cross_edges s \\<inter> tree_edges s = {};\n        cond s; DFS_invar G param s; DFS_invar G param s'; stack s = [];\n        v0 \\<notin> dom (discovered s); v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> Field (back_edges s')\n                         \\<subseteq> dom (discovered s') \\<and>\n                         back_edges s' \\<subseteq> E - pending s' \\<and>\n                         Field (cross_edges s')\n                         \\<subseteq> dom (discovered s') \\<and>\n                         cross_edges s' \\<subseteq> E - pending s' \\<and>\n                         Field (tree_edges s')\n                         \\<subseteq> dom (discovered s') \\<and>\n                         tree_edges s' \\<subseteq> E - pending s' \\<and>\n                         back_edges s' \\<inter> cross_edges s' = {} \\<and>\n                         back_edges s' \\<inter> tree_edges s' = {} \\<and>\n                         cross_edges s' \\<inter> tree_edges s' = {}\n 3. \\<And>s s' u e.\n       \\<lbrakk>Field (back_edges s) \\<subseteq> dom (discovered s) \\<and>\n                back_edges s \\<subseteq> E - pending s \\<and>\n                Field (cross_edges s) \\<subseteq> dom (discovered s) \\<and>\n                cross_edges s \\<subseteq> E - pending s \\<and>\n                Field (tree_edges s) \\<subseteq> dom (discovered s) \\<and>\n                tree_edges s \\<subseteq> E - pending s \\<and>\n                back_edges s \\<inter> cross_edges s = {} \\<and>\n                back_edges s \\<inter> tree_edges s = {} \\<and>\n                cross_edges s \\<inter> tree_edges s = {};\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; pending s `` {u} = {}; u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> Field (back_edges s')\n                         \\<subseteq> dom (discovered s') \\<and>\n                         back_edges s' \\<subseteq> E - pending s' \\<and>\n                         Field (cross_edges s')\n                         \\<subseteq> dom (discovered s') \\<and>\n                         cross_edges s' \\<subseteq> E - pending s' \\<and>\n                         Field (tree_edges s')\n                         \\<subseteq> dom (discovered s') \\<and>\n                         tree_edges s' \\<subseteq> E - pending s' \\<and>\n                         back_edges s' \\<inter> cross_edges s' = {} \\<and>\n                         back_edges s' \\<inter> tree_edges s' = {} \\<and>\n                         cross_edges s' \\<inter> tree_edges s' = {}\n 4. \\<And>s s' u v e.\n       \\<lbrakk>Field (back_edges s) \\<subseteq> dom (discovered s) \\<and>\n                back_edges s \\<subseteq> E - pending s \\<and>\n                Field (cross_edges s) \\<subseteq> dom (discovered s) \\<and>\n                cross_edges s \\<subseteq> E - pending s \\<and>\n                Field (tree_edges s) \\<subseteq> dom (discovered s) \\<and>\n                tree_edges s \\<subseteq> E - pending s \\<and>\n                back_edges s \\<inter> cross_edges s = {} \\<and>\n                back_edges s \\<inter> tree_edges s = {} \\<and>\n                cross_edges s \\<inter> tree_edges s = {};\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> Field (back_edges s')\n                         \\<subseteq> dom (discovered s') \\<and>\n                         back_edges s' \\<subseteq> E - pending s' \\<and>\n                         Field (cross_edges s')\n                         \\<subseteq> dom (discovered s') \\<and>\n                         cross_edges s' \\<subseteq> E - pending s' \\<and>\n                         Field (tree_edges s')\n                         \\<subseteq> dom (discovered s') \\<and>\n                         tree_edges s' \\<subseteq> E - pending s' \\<and>\n                         back_edges s' \\<inter> cross_edges s' = {} \\<and>\n                         back_edges s' \\<inter> tree_edges s' = {} \\<and>\n                         cross_edges s' \\<inter> tree_edges s' = {}", "from discover"], ["proof (chain)\npicking this:\n  Field (back_edges s) \\<subseteq> dom (discovered s) \\<and>\n  back_edges s \\<subseteq> E - pending s \\<and>\n  Field (cross_edges s) \\<subseteq> dom (discovered s) \\<and>\n  cross_edges s \\<subseteq> E - pending s \\<and>\n  Field (tree_edges s) \\<subseteq> dom (discovered s) \\<and>\n  tree_edges s \\<subseteq> E - pending s \\<and>\n  back_edges s \\<inter> cross_edges s = {} \\<and>\n  back_edges s \\<inter> tree_edges s = {} \\<and>\n  cross_edges s \\<inter> tree_edges s = {}\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'_\n  stack s \\<noteq> []\n  v_ \\<in> pending s `` {u_}\n  v_ \\<notin> dom (discovered s)\n  u_ = hd (stack s)\n  s'_ = discover u_ v_ (s\\<lparr>pending := pending s - {(u_, v_)}\\<rparr>)\n  \\<lparr>state.more := e_\\<rparr>", "show ?case"], ["proof (prove)\nusing this:\n  Field (back_edges s) \\<subseteq> dom (discovered s) \\<and>\n  back_edges s \\<subseteq> E - pending s \\<and>\n  Field (cross_edges s) \\<subseteq> dom (discovered s) \\<and>\n  cross_edges s \\<subseteq> E - pending s \\<and>\n  Field (tree_edges s) \\<subseteq> dom (discovered s) \\<and>\n  tree_edges s \\<subseteq> E - pending s \\<and>\n  back_edges s \\<inter> cross_edges s = {} \\<and>\n  back_edges s \\<inter> tree_edges s = {} \\<and>\n  cross_edges s \\<inter> tree_edges s = {}\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'_\n  stack s \\<noteq> []\n  v_ \\<in> pending s `` {u_}\n  v_ \\<notin> dom (discovered s)\n  u_ = hd (stack s)\n  s'_ = discover u_ v_ (s\\<lparr>pending := pending s - {(u_, v_)}\\<rparr>)\n  \\<lparr>state.more := e_\\<rparr>\n\ngoal (1 subgoal):\n 1. Field (back_edges s'_) \\<subseteq> dom (discovered s'_) \\<and>\n    back_edges s'_ \\<subseteq> E - pending s'_ \\<and>\n    Field (cross_edges s'_) \\<subseteq> dom (discovered s'_) \\<and>\n    cross_edges s'_ \\<subseteq> E - pending s'_ \\<and>\n    Field (tree_edges s'_) \\<subseteq> dom (discovered s'_) \\<and>\n    tree_edges s'_ \\<subseteq> E - pending s'_ \\<and>\n    back_edges s'_ \\<inter> cross_edges s'_ = {} \\<and>\n    back_edges s'_ \\<inter> tree_edges s'_ = {} \\<and>\n    cross_edges s'_ \\<inter> tree_edges s'_ = {}", "(* Speed optimized proof, using only auto takes too long *)"], ["proof (prove)\nusing this:\n  Field (back_edges s) \\<subseteq> dom (discovered s) \\<and>\n  back_edges s \\<subseteq> E - pending s \\<and>\n  Field (cross_edges s) \\<subseteq> dom (discovered s) \\<and>\n  cross_edges s \\<subseteq> E - pending s \\<and>\n  Field (tree_edges s) \\<subseteq> dom (discovered s) \\<and>\n  tree_edges s \\<subseteq> E - pending s \\<and>\n  back_edges s \\<inter> cross_edges s = {} \\<and>\n  back_edges s \\<inter> tree_edges s = {} \\<and>\n  cross_edges s \\<inter> tree_edges s = {}\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'_\n  stack s \\<noteq> []\n  v_ \\<in> pending s `` {u_}\n  v_ \\<notin> dom (discovered s)\n  u_ = hd (stack s)\n  s'_ = discover u_ v_ (s\\<lparr>pending := pending s - {(u_, v_)}\\<rparr>)\n  \\<lparr>state.more := e_\\<rparr>\n\ngoal (1 subgoal):\n 1. Field (back_edges s'_) \\<subseteq> dom (discovered s'_) \\<and>\n    back_edges s'_ \\<subseteq> E - pending s'_ \\<and>\n    Field (cross_edges s'_) \\<subseteq> dom (discovered s'_) \\<and>\n    cross_edges s'_ \\<subseteq> E - pending s'_ \\<and>\n    Field (tree_edges s'_) \\<subseteq> dom (discovered s'_) \\<and>\n    tree_edges s'_ \\<subseteq> E - pending s'_ \\<and>\n    back_edges s'_ \\<inter> cross_edges s'_ = {} \\<and>\n    back_edges s'_ \\<inter> tree_edges s'_ = {} \\<and>\n    cross_edges s'_ \\<inter> tree_edges s'_ = {}", "apply (simp add: Field_def Range_def Domain_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Collect (Domainp (\\<lambda>x xa. (x, xa) \\<in> back_edges s))\n             \\<subseteq> dom (discovered s) \\<and>\n             Collect (Rangep (\\<lambda>x xa. (x, xa) \\<in> back_edges s))\n             \\<subseteq> dom (discovered s) \\<and>\n             back_edges s \\<subseteq> E - pending s \\<and>\n             Collect (Domainp (\\<lambda>x xa. (x, xa) \\<in> cross_edges s))\n             \\<subseteq> dom (discovered s) \\<and>\n             Collect (Rangep (\\<lambda>x xa. (x, xa) \\<in> cross_edges s))\n             \\<subseteq> dom (discovered s) \\<and>\n             cross_edges s \\<subseteq> E - pending s \\<and>\n             Collect (Domainp (\\<lambda>x xa. (x, xa) \\<in> tree_edges s))\n             \\<subseteq> dom (discovered s) \\<and>\n             Collect (Rangep (\\<lambda>x xa. (x, xa) \\<in> tree_edges s))\n             \\<subseteq> dom (discovered s) \\<and>\n             tree_edges s \\<subseteq> E - pending s \\<and>\n             back_edges s \\<inter> cross_edges s = {} \\<and>\n             back_edges s \\<inter> tree_edges s = {} \\<and>\n             cross_edges s \\<inter> tree_edges s = {};\n     cond s; DFS_invar G param s;\n     DFS_invar G param\n      (discover (hd (stack s)) v_\n        (s\\<lparr>pending := pending s - {(hd (stack s), v_)}\\<rparr>)\n       \\<lparr>state.more := e_\\<rparr>);\n     stack s \\<noteq> []; (hd (stack s), v_) \\<in> pending s;\n     v_ \\<notin> dom (discovered s); u_ = hd (stack s);\n     s'_ =\n     discover (hd (stack s)) v_\n      (s\\<lparr>pending := pending s - {(hd (stack s), v_)}\\<rparr>)\n     \\<lparr>state.more := e_\\<rparr>\\<rbrakk>\n    \\<Longrightarrow> Collect\n                       (Domainp (\\<lambda>x xa. (x, xa) \\<in> back_edges s))\n                      \\<subseteq> insert v_ (dom (discovered s)) \\<and>\n                      Collect\n                       (Rangep (\\<lambda>x xa. (x, xa) \\<in> back_edges s))\n                      \\<subseteq> insert v_ (dom (discovered s)) \\<and>\n                      back_edges s\n                      \\<subseteq> E -\n                                  (pending s - {(hd (stack s), v_)} \\<union>\n                                   {v_} \\<times> E `` {v_}) \\<and>\n                      Collect\n                       (Domainp\n                         (\\<lambda>x xa. (x, xa) \\<in> cross_edges s))\n                      \\<subseteq> insert v_ (dom (discovered s)) \\<and>\n                      Collect\n                       (Rangep (\\<lambda>x xa. (x, xa) \\<in> cross_edges s))\n                      \\<subseteq> insert v_ (dom (discovered s)) \\<and>\n                      cross_edges s\n                      \\<subseteq> E -\n                                  (pending s - {(hd (stack s), v_)} \\<union>\n                                   {v_} \\<times> E `` {v_}) \\<and>\n                      Collect\n                       (Domainp\n                         (\\<lambda>x xa.\n                             x = hd (stack s) \\<and> xa = v_ \\<or>\n                             (x, xa) \\<in> tree_edges s))\n                      \\<subseteq> insert v_ (dom (discovered s)) \\<and>\n                      Collect\n                       (Rangep\n                         (\\<lambda>x xa.\n                             x = hd (stack s) \\<and> xa = v_ \\<or>\n                             (x, xa) \\<in> tree_edges s))\n                      \\<subseteq> insert v_ (dom (discovered s)) \\<and>\n                      (hd (stack s), v_) \\<in> E \\<and>\n                      (hd (stack s) = v_ \\<longrightarrow>\n                       (v_, v_) \\<notin> E) \\<and>\n                      tree_edges s\n                      \\<subseteq> E -\n                                  (pending s - {(hd (stack s), v_)} \\<union>\n                                   {v_} \\<times> E `` {v_}) \\<and>\n                      (hd (stack s), v_) \\<notin> back_edges s \\<and>\n                      (hd (stack s), v_) \\<notin> cross_edges s", "apply (drule pendingD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Collect (Domainp (\\<lambda>x xa. (x, xa) \\<in> back_edges s))\n             \\<subseteq> dom (discovered s) \\<and>\n             Collect (Rangep (\\<lambda>x xa. (x, xa) \\<in> back_edges s))\n             \\<subseteq> dom (discovered s) \\<and>\n             back_edges s \\<subseteq> E - pending s \\<and>\n             Collect (Domainp (\\<lambda>x xa. (x, xa) \\<in> cross_edges s))\n             \\<subseteq> dom (discovered s) \\<and>\n             Collect (Rangep (\\<lambda>x xa. (x, xa) \\<in> cross_edges s))\n             \\<subseteq> dom (discovered s) \\<and>\n             cross_edges s \\<subseteq> E - pending s \\<and>\n             Collect (Domainp (\\<lambda>x xa. (x, xa) \\<in> tree_edges s))\n             \\<subseteq> dom (discovered s) \\<and>\n             Collect (Rangep (\\<lambda>x xa. (x, xa) \\<in> tree_edges s))\n             \\<subseteq> dom (discovered s) \\<and>\n             tree_edges s \\<subseteq> E - pending s \\<and>\n             back_edges s \\<inter> cross_edges s = {} \\<and>\n             back_edges s \\<inter> tree_edges s = {} \\<and>\n             cross_edges s \\<inter> tree_edges s = {};\n     cond s; DFS_invar G param s;\n     DFS_invar G param\n      (discover (hd (stack s)) v_\n        (s\\<lparr>pending := pending s - {(hd (stack s), v_)}\\<rparr>)\n       \\<lparr>state.more := e_\\<rparr>);\n     stack s \\<noteq> []; v_ \\<notin> dom (discovered s); u_ = hd (stack s);\n     s'_ =\n     discover (hd (stack s)) v_\n      (s\\<lparr>pending := pending s - {(hd (stack s), v_)}\\<rparr>)\n     \\<lparr>state.more := e_\\<rparr>;\n     (hd (stack s), v_) \\<in> E \\<and>\n     hd (stack s) \\<in> dom (discovered s)\\<rbrakk>\n    \\<Longrightarrow> Collect\n                       (Domainp (\\<lambda>x xa. (x, xa) \\<in> back_edges s))\n                      \\<subseteq> insert v_ (dom (discovered s)) \\<and>\n                      Collect\n                       (Rangep (\\<lambda>x xa. (x, xa) \\<in> back_edges s))\n                      \\<subseteq> insert v_ (dom (discovered s)) \\<and>\n                      back_edges s\n                      \\<subseteq> E -\n                                  (pending s - {(hd (stack s), v_)} \\<union>\n                                   {v_} \\<times> E `` {v_}) \\<and>\n                      Collect\n                       (Domainp\n                         (\\<lambda>x xa. (x, xa) \\<in> cross_edges s))\n                      \\<subseteq> insert v_ (dom (discovered s)) \\<and>\n                      Collect\n                       (Rangep (\\<lambda>x xa. (x, xa) \\<in> cross_edges s))\n                      \\<subseteq> insert v_ (dom (discovered s)) \\<and>\n                      cross_edges s\n                      \\<subseteq> E -\n                                  (pending s - {(hd (stack s), v_)} \\<union>\n                                   {v_} \\<times> E `` {v_}) \\<and>\n                      Collect\n                       (Domainp\n                         (\\<lambda>x xa.\n                             x = hd (stack s) \\<and> xa = v_ \\<or>\n                             (x, xa) \\<in> tree_edges s))\n                      \\<subseteq> insert v_ (dom (discovered s)) \\<and>\n                      Collect\n                       (Rangep\n                         (\\<lambda>x xa.\n                             x = hd (stack s) \\<and> xa = v_ \\<or>\n                             (x, xa) \\<in> tree_edges s))\n                      \\<subseteq> insert v_ (dom (discovered s)) \\<and>\n                      (hd (stack s), v_) \\<in> E \\<and>\n                      (hd (stack s) = v_ \\<longrightarrow>\n                       (v_, v_) \\<notin> E) \\<and>\n                      tree_edges s\n                      \\<subseteq> E -\n                                  (pending s - {(hd (stack s), v_)} \\<union>\n                                   {v_} \\<times> E `` {v_}) \\<and>\n                      (hd (stack s), v_) \\<notin> back_edges s \\<and>\n                      (hd (stack s), v_) \\<notin> cross_edges s", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Collect (Domainp (\\<lambda>x xa. (x, xa) \\<in> back_edges s))\n             \\<subseteq> dom (discovered s) \\<and>\n             Collect (Rangep (\\<lambda>x xa. (x, xa) \\<in> back_edges s))\n             \\<subseteq> dom (discovered s) \\<and>\n             back_edges s \\<subseteq> E - pending s \\<and>\n             Collect (Domainp (\\<lambda>x xa. (x, xa) \\<in> cross_edges s))\n             \\<subseteq> dom (discovered s) \\<and>\n             Collect (Rangep (\\<lambda>x xa. (x, xa) \\<in> cross_edges s))\n             \\<subseteq> dom (discovered s) \\<and>\n             cross_edges s \\<subseteq> E - pending s \\<and>\n             Collect (Domainp (\\<lambda>x xa. (x, xa) \\<in> tree_edges s))\n             \\<subseteq> dom (discovered s) \\<and>\n             Collect (Rangep (\\<lambda>x xa. (x, xa) \\<in> tree_edges s))\n             \\<subseteq> dom (discovered s) \\<and>\n             tree_edges s \\<subseteq> E - pending s \\<and>\n             back_edges s \\<inter> cross_edges s = {} \\<and>\n             back_edges s \\<inter> tree_edges s = {} \\<and>\n             cross_edges s \\<inter> tree_edges s = {};\n     cond s; DFS_invar G param s;\n     DFS_invar G param\n      (discover (hd (stack s)) v_\n        (s\\<lparr>pending := pending s - {(hd (stack s), v_)}\\<rparr>)\n       \\<lparr>state.more := e_\\<rparr>);\n     stack s \\<noteq> []; v_ \\<notin> dom (discovered s); u_ = hd (stack s);\n     s'_ =\n     discover (hd (stack s)) v_\n      (s\\<lparr>pending := pending s - {(hd (stack s), v_)}\\<rparr>)\n     \\<lparr>state.more := e_\\<rparr>;\n     (hd (stack s), v_) \\<in> E \\<and>\n     hd (stack s) \\<in> dom (discovered s)\\<rbrakk>\n    \\<Longrightarrow> Collect\n                       (Domainp (\\<lambda>x xa. (x, xa) \\<in> back_edges s))\n                      \\<subseteq> insert v_ (dom (discovered s)) \\<and>\n                      Collect\n                       (Rangep (\\<lambda>x xa. (x, xa) \\<in> back_edges s))\n                      \\<subseteq> insert v_ (dom (discovered s)) \\<and>\n                      back_edges s\n                      \\<subseteq> E -\n                                  (pending s - {(hd (stack s), v_)} \\<union>\n                                   {v_} \\<times> E `` {v_}) \\<and>\n                      Collect\n                       (Domainp\n                         (\\<lambda>x xa. (x, xa) \\<in> cross_edges s))\n                      \\<subseteq> insert v_ (dom (discovered s)) \\<and>\n                      Collect\n                       (Rangep (\\<lambda>x xa. (x, xa) \\<in> cross_edges s))\n                      \\<subseteq> insert v_ (dom (discovered s)) \\<and>\n                      cross_edges s\n                      \\<subseteq> E -\n                                  (pending s - {(hd (stack s), v_)} \\<union>\n                                   {v_} \\<times> E `` {v_}) \\<and>\n                      Collect\n                       (Domainp\n                         (\\<lambda>x xa.\n                             x = hd (stack s) \\<and> xa = v_ \\<or>\n                             (x, xa) \\<in> tree_edges s))\n                      \\<subseteq> insert v_ (dom (discovered s)) \\<and>\n                      Collect\n                       (Rangep\n                         (\\<lambda>x xa.\n                             x = hd (stack s) \\<and> xa = v_ \\<or>\n                             (x, xa) \\<in> tree_edges s))\n                      \\<subseteq> insert v_ (dom (discovered s)) \\<and>\n                      (hd (stack s) = v_ \\<longrightarrow>\n                       (v_, v_) \\<notin> E) \\<and>\n                      tree_edges s\n                      \\<subseteq> E -\n                                  (pending s - {(hd (stack s), v_)} \\<union>\n                                   {v_} \\<times> E `` {v_}) \\<and>\n                      (hd (stack s), v_) \\<notin> back_edges s \\<and>\n                      (hd (stack s), v_) \\<notin> cross_edges s", "by (blast)"], ["proof (state)\nthis:\n  Field (back_edges s'_) \\<subseteq> dom (discovered s'_) \\<and>\n  back_edges s'_ \\<subseteq> E - pending s'_ \\<and>\n  Field (cross_edges s'_) \\<subseteq> dom (discovered s'_) \\<and>\n  cross_edges s'_ \\<subseteq> E - pending s'_ \\<and>\n  Field (tree_edges s'_) \\<subseteq> dom (discovered s'_) \\<and>\n  tree_edges s'_ \\<subseteq> E - pending s'_ \\<and>\n  back_edges s'_ \\<inter> cross_edges s'_ = {} \\<and>\n  back_edges s'_ \\<inter> tree_edges s'_ = {} \\<and>\n  cross_edges s'_ \\<inter> tree_edges s'_ = {}\n\ngoal (3 subgoals):\n 1. \\<And>e.\n       Field (back_edges (empty_state e))\n       \\<subseteq> dom (discovered (empty_state e)) \\<and>\n       back_edges (empty_state e)\n       \\<subseteq> E - pending (empty_state e) \\<and>\n       Field (cross_edges (empty_state e))\n       \\<subseteq> dom (discovered (empty_state e)) \\<and>\n       cross_edges (empty_state e)\n       \\<subseteq> E - pending (empty_state e) \\<and>\n       Field (tree_edges (empty_state e))\n       \\<subseteq> dom (discovered (empty_state e)) \\<and>\n       tree_edges (empty_state e)\n       \\<subseteq> E - pending (empty_state e) \\<and>\n       back_edges (empty_state e) \\<inter> cross_edges (empty_state e) =\n       {} \\<and>\n       back_edges (empty_state e) \\<inter> tree_edges (empty_state e) =\n       {} \\<and>\n       cross_edges (empty_state e) \\<inter> tree_edges (empty_state e) = {}\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>Field (back_edges s) \\<subseteq> dom (discovered s) \\<and>\n                back_edges s \\<subseteq> E - pending s \\<and>\n                Field (cross_edges s) \\<subseteq> dom (discovered s) \\<and>\n                cross_edges s \\<subseteq> E - pending s \\<and>\n                Field (tree_edges s) \\<subseteq> dom (discovered s) \\<and>\n                tree_edges s \\<subseteq> E - pending s \\<and>\n                back_edges s \\<inter> cross_edges s = {} \\<and>\n                back_edges s \\<inter> tree_edges s = {} \\<and>\n                cross_edges s \\<inter> tree_edges s = {};\n        cond s; DFS_invar G param s; DFS_invar G param s'; stack s = [];\n        v0 \\<notin> dom (discovered s); v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> Field (back_edges s')\n                         \\<subseteq> dom (discovered s') \\<and>\n                         back_edges s' \\<subseteq> E - pending s' \\<and>\n                         Field (cross_edges s')\n                         \\<subseteq> dom (discovered s') \\<and>\n                         cross_edges s' \\<subseteq> E - pending s' \\<and>\n                         Field (tree_edges s')\n                         \\<subseteq> dom (discovered s') \\<and>\n                         tree_edges s' \\<subseteq> E - pending s' \\<and>\n                         back_edges s' \\<inter> cross_edges s' = {} \\<and>\n                         back_edges s' \\<inter> tree_edges s' = {} \\<and>\n                         cross_edges s' \\<inter> tree_edges s' = {}\n 3. \\<And>s s' u e.\n       \\<lbrakk>Field (back_edges s) \\<subseteq> dom (discovered s) \\<and>\n                back_edges s \\<subseteq> E - pending s \\<and>\n                Field (cross_edges s) \\<subseteq> dom (discovered s) \\<and>\n                cross_edges s \\<subseteq> E - pending s \\<and>\n                Field (tree_edges s) \\<subseteq> dom (discovered s) \\<and>\n                tree_edges s \\<subseteq> E - pending s \\<and>\n                back_edges s \\<inter> cross_edges s = {} \\<and>\n                back_edges s \\<inter> tree_edges s = {} \\<and>\n                cross_edges s \\<inter> tree_edges s = {};\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; pending s `` {u} = {}; u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> Field (back_edges s')\n                         \\<subseteq> dom (discovered s') \\<and>\n                         back_edges s' \\<subseteq> E - pending s' \\<and>\n                         Field (cross_edges s')\n                         \\<subseteq> dom (discovered s') \\<and>\n                         cross_edges s' \\<subseteq> E - pending s' \\<and>\n                         Field (tree_edges s')\n                         \\<subseteq> dom (discovered s') \\<and>\n                         tree_edges s' \\<subseteq> E - pending s' \\<and>\n                         back_edges s' \\<inter> cross_edges s' = {} \\<and>\n                         back_edges s' \\<inter> tree_edges s' = {} \\<and>\n                         cross_edges s' \\<inter> tree_edges s' = {}", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>e.\n       Field (back_edges (empty_state e))\n       \\<subseteq> dom (discovered (empty_state e)) \\<and>\n       back_edges (empty_state e)\n       \\<subseteq> E - pending (empty_state e) \\<and>\n       Field (cross_edges (empty_state e))\n       \\<subseteq> dom (discovered (empty_state e)) \\<and>\n       cross_edges (empty_state e)\n       \\<subseteq> E - pending (empty_state e) \\<and>\n       Field (tree_edges (empty_state e))\n       \\<subseteq> dom (discovered (empty_state e)) \\<and>\n       tree_edges (empty_state e)\n       \\<subseteq> E - pending (empty_state e) \\<and>\n       back_edges (empty_state e) \\<inter> cross_edges (empty_state e) =\n       {} \\<and>\n       back_edges (empty_state e) \\<inter> tree_edges (empty_state e) =\n       {} \\<and>\n       cross_edges (empty_state e) \\<inter> tree_edges (empty_state e) = {}\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>Field (back_edges s) \\<subseteq> dom (discovered s) \\<and>\n                back_edges s \\<subseteq> E - pending s \\<and>\n                Field (cross_edges s) \\<subseteq> dom (discovered s) \\<and>\n                cross_edges s \\<subseteq> E - pending s \\<and>\n                Field (tree_edges s) \\<subseteq> dom (discovered s) \\<and>\n                tree_edges s \\<subseteq> E - pending s \\<and>\n                back_edges s \\<inter> cross_edges s = {} \\<and>\n                back_edges s \\<inter> tree_edges s = {} \\<and>\n                cross_edges s \\<inter> tree_edges s = {};\n        cond s; DFS_invar G param s; DFS_invar G param s'; stack s = [];\n        v0 \\<notin> dom (discovered s); v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> Field (back_edges s')\n                         \\<subseteq> dom (discovered s') \\<and>\n                         back_edges s' \\<subseteq> E - pending s' \\<and>\n                         Field (cross_edges s')\n                         \\<subseteq> dom (discovered s') \\<and>\n                         cross_edges s' \\<subseteq> E - pending s' \\<and>\n                         Field (tree_edges s')\n                         \\<subseteq> dom (discovered s') \\<and>\n                         tree_edges s' \\<subseteq> E - pending s' \\<and>\n                         back_edges s' \\<inter> cross_edges s' = {} \\<and>\n                         back_edges s' \\<inter> tree_edges s' = {} \\<and>\n                         cross_edges s' \\<inter> tree_edges s' = {}\n 3. \\<And>s s' u e.\n       \\<lbrakk>Field (back_edges s) \\<subseteq> dom (discovered s) \\<and>\n                back_edges s \\<subseteq> E - pending s \\<and>\n                Field (cross_edges s) \\<subseteq> dom (discovered s) \\<and>\n                cross_edges s \\<subseteq> E - pending s \\<and>\n                Field (tree_edges s) \\<subseteq> dom (discovered s) \\<and>\n                tree_edges s \\<subseteq> E - pending s \\<and>\n                back_edges s \\<inter> cross_edges s = {} \\<and>\n                back_edges s \\<inter> tree_edges s = {} \\<and>\n                cross_edges s \\<inter> tree_edges s = {};\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; pending s `` {u} = {}; u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> Field (back_edges s')\n                         \\<subseteq> dom (discovered s') \\<and>\n                         back_edges s' \\<subseteq> E - pending s' \\<and>\n                         Field (cross_edges s')\n                         \\<subseteq> dom (discovered s') \\<and>\n                         cross_edges s' \\<subseteq> E - pending s' \\<and>\n                         Field (tree_edges s')\n                         \\<subseteq> dom (discovered s') \\<and>\n                         tree_edges s' \\<subseteq> E - pending s' \\<and>\n                         back_edges s' \\<inter> cross_edges s' = {} \\<and>\n                         back_edges s' \\<inter> tree_edges s' = {} \\<and>\n                         cross_edges s' \\<inter> tree_edges s' = {}", "case (new_root s)"], ["proof (state)\nthis:\n  Field (back_edges s) \\<subseteq> dom (discovered s) \\<and>\n  back_edges s \\<subseteq> E - pending s \\<and>\n  Field (cross_edges s) \\<subseteq> dom (discovered s) \\<and>\n  cross_edges s \\<subseteq> E - pending s \\<and>\n  Field (tree_edges s) \\<subseteq> dom (discovered s) \\<and>\n  tree_edges s \\<subseteq> E - pending s \\<and>\n  back_edges s \\<inter> cross_edges s = {} \\<and>\n  back_edges s \\<inter> tree_edges s = {} \\<and>\n  cross_edges s \\<inter> tree_edges s = {}\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'_\n  stack s = []\n  v0_ \\<notin> dom (discovered s)\n  v0_ \\<in> V0\n  s'_ = new_root v0_ s\\<lparr>state.more := e_\\<rparr>\n\ngoal (3 subgoals):\n 1. \\<And>e.\n       Field (back_edges (empty_state e))\n       \\<subseteq> dom (discovered (empty_state e)) \\<and>\n       back_edges (empty_state e)\n       \\<subseteq> E - pending (empty_state e) \\<and>\n       Field (cross_edges (empty_state e))\n       \\<subseteq> dom (discovered (empty_state e)) \\<and>\n       cross_edges (empty_state e)\n       \\<subseteq> E - pending (empty_state e) \\<and>\n       Field (tree_edges (empty_state e))\n       \\<subseteq> dom (discovered (empty_state e)) \\<and>\n       tree_edges (empty_state e)\n       \\<subseteq> E - pending (empty_state e) \\<and>\n       back_edges (empty_state e) \\<inter> cross_edges (empty_state e) =\n       {} \\<and>\n       back_edges (empty_state e) \\<inter> tree_edges (empty_state e) =\n       {} \\<and>\n       cross_edges (empty_state e) \\<inter> tree_edges (empty_state e) = {}\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>Field (back_edges s) \\<subseteq> dom (discovered s) \\<and>\n                back_edges s \\<subseteq> E - pending s \\<and>\n                Field (cross_edges s) \\<subseteq> dom (discovered s) \\<and>\n                cross_edges s \\<subseteq> E - pending s \\<and>\n                Field (tree_edges s) \\<subseteq> dom (discovered s) \\<and>\n                tree_edges s \\<subseteq> E - pending s \\<and>\n                back_edges s \\<inter> cross_edges s = {} \\<and>\n                back_edges s \\<inter> tree_edges s = {} \\<and>\n                cross_edges s \\<inter> tree_edges s = {};\n        cond s; DFS_invar G param s; DFS_invar G param s'; stack s = [];\n        v0 \\<notin> dom (discovered s); v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> Field (back_edges s')\n                         \\<subseteq> dom (discovered s') \\<and>\n                         back_edges s' \\<subseteq> E - pending s' \\<and>\n                         Field (cross_edges s')\n                         \\<subseteq> dom (discovered s') \\<and>\n                         cross_edges s' \\<subseteq> E - pending s' \\<and>\n                         Field (tree_edges s')\n                         \\<subseteq> dom (discovered s') \\<and>\n                         tree_edges s' \\<subseteq> E - pending s' \\<and>\n                         back_edges s' \\<inter> cross_edges s' = {} \\<and>\n                         back_edges s' \\<inter> tree_edges s' = {} \\<and>\n                         cross_edges s' \\<inter> tree_edges s' = {}\n 3. \\<And>s s' u e.\n       \\<lbrakk>Field (back_edges s) \\<subseteq> dom (discovered s) \\<and>\n                back_edges s \\<subseteq> E - pending s \\<and>\n                Field (cross_edges s) \\<subseteq> dom (discovered s) \\<and>\n                cross_edges s \\<subseteq> E - pending s \\<and>\n                Field (tree_edges s) \\<subseteq> dom (discovered s) \\<and>\n                tree_edges s \\<subseteq> E - pending s \\<and>\n                back_edges s \\<inter> cross_edges s = {} \\<and>\n                back_edges s \\<inter> tree_edges s = {} \\<and>\n                cross_edges s \\<inter> tree_edges s = {};\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; pending s `` {u} = {}; u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> Field (back_edges s')\n                         \\<subseteq> dom (discovered s') \\<and>\n                         back_edges s' \\<subseteq> E - pending s' \\<and>\n                         Field (cross_edges s')\n                         \\<subseteq> dom (discovered s') \\<and>\n                         cross_edges s' \\<subseteq> E - pending s' \\<and>\n                         Field (tree_edges s')\n                         \\<subseteq> dom (discovered s') \\<and>\n                         tree_edges s' \\<subseteq> E - pending s' \\<and>\n                         back_edges s' \\<inter> cross_edges s' = {} \\<and>\n                         back_edges s' \\<inter> tree_edges s' = {} \\<and>\n                         cross_edges s' \\<inter> tree_edges s' = {}", "thus ?case"], ["proof (prove)\nusing this:\n  Field (back_edges s) \\<subseteq> dom (discovered s) \\<and>\n  back_edges s \\<subseteq> E - pending s \\<and>\n  Field (cross_edges s) \\<subseteq> dom (discovered s) \\<and>\n  cross_edges s \\<subseteq> E - pending s \\<and>\n  Field (tree_edges s) \\<subseteq> dom (discovered s) \\<and>\n  tree_edges s \\<subseteq> E - pending s \\<and>\n  back_edges s \\<inter> cross_edges s = {} \\<and>\n  back_edges s \\<inter> tree_edges s = {} \\<and>\n  cross_edges s \\<inter> tree_edges s = {}\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'_\n  stack s = []\n  v0_ \\<notin> dom (discovered s)\n  v0_ \\<in> V0\n  s'_ = new_root v0_ s\\<lparr>state.more := e_\\<rparr>\n\ngoal (1 subgoal):\n 1. Field (back_edges s'_) \\<subseteq> dom (discovered s'_) \\<and>\n    back_edges s'_ \\<subseteq> E - pending s'_ \\<and>\n    Field (cross_edges s'_) \\<subseteq> dom (discovered s'_) \\<and>\n    cross_edges s'_ \\<subseteq> E - pending s'_ \\<and>\n    Field (tree_edges s'_) \\<subseteq> dom (discovered s'_) \\<and>\n    tree_edges s'_ \\<subseteq> E - pending s'_ \\<and>\n    back_edges s'_ \\<inter> cross_edges s'_ = {} \\<and>\n    back_edges s'_ \\<inter> tree_edges s'_ = {} \\<and>\n    cross_edges s'_ \\<inter> tree_edges s'_ = {}", "by (simp add: Field_def) blast"], ["proof (state)\nthis:\n  Field (back_edges s'_) \\<subseteq> dom (discovered s'_) \\<and>\n  back_edges s'_ \\<subseteq> E - pending s'_ \\<and>\n  Field (cross_edges s'_) \\<subseteq> dom (discovered s'_) \\<and>\n  cross_edges s'_ \\<subseteq> E - pending s'_ \\<and>\n  Field (tree_edges s'_) \\<subseteq> dom (discovered s'_) \\<and>\n  tree_edges s'_ \\<subseteq> E - pending s'_ \\<and>\n  back_edges s'_ \\<inter> cross_edges s'_ = {} \\<and>\n  back_edges s'_ \\<inter> tree_edges s'_ = {} \\<and>\n  cross_edges s'_ \\<inter> tree_edges s'_ = {}\n\ngoal (2 subgoals):\n 1. \\<And>e.\n       Field (back_edges (empty_state e))\n       \\<subseteq> dom (discovered (empty_state e)) \\<and>\n       back_edges (empty_state e)\n       \\<subseteq> E - pending (empty_state e) \\<and>\n       Field (cross_edges (empty_state e))\n       \\<subseteq> dom (discovered (empty_state e)) \\<and>\n       cross_edges (empty_state e)\n       \\<subseteq> E - pending (empty_state e) \\<and>\n       Field (tree_edges (empty_state e))\n       \\<subseteq> dom (discovered (empty_state e)) \\<and>\n       tree_edges (empty_state e)\n       \\<subseteq> E - pending (empty_state e) \\<and>\n       back_edges (empty_state e) \\<inter> cross_edges (empty_state e) =\n       {} \\<and>\n       back_edges (empty_state e) \\<inter> tree_edges (empty_state e) =\n       {} \\<and>\n       cross_edges (empty_state e) \\<inter> tree_edges (empty_state e) = {}\n 2. \\<And>s s' u e.\n       \\<lbrakk>Field (back_edges s) \\<subseteq> dom (discovered s) \\<and>\n                back_edges s \\<subseteq> E - pending s \\<and>\n                Field (cross_edges s) \\<subseteq> dom (discovered s) \\<and>\n                cross_edges s \\<subseteq> E - pending s \\<and>\n                Field (tree_edges s) \\<subseteq> dom (discovered s) \\<and>\n                tree_edges s \\<subseteq> E - pending s \\<and>\n                back_edges s \\<inter> cross_edges s = {} \\<and>\n                back_edges s \\<inter> tree_edges s = {} \\<and>\n                cross_edges s \\<inter> tree_edges s = {};\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; pending s `` {u} = {}; u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> Field (back_edges s')\n                         \\<subseteq> dom (discovered s') \\<and>\n                         back_edges s' \\<subseteq> E - pending s' \\<and>\n                         Field (cross_edges s')\n                         \\<subseteq> dom (discovered s') \\<and>\n                         cross_edges s' \\<subseteq> E - pending s' \\<and>\n                         Field (tree_edges s')\n                         \\<subseteq> dom (discovered s') \\<and>\n                         tree_edges s' \\<subseteq> E - pending s' \\<and>\n                         back_edges s' \\<inter> cross_edges s' = {} \\<and>\n                         back_edges s' \\<inter> tree_edges s' = {} \\<and>\n                         cross_edges s' \\<inter> tree_edges s' = {}", "qed auto"], ["", "lemmas (in DFS_invar) edges_basic = i_edges_basic[THEN make_invar_thm]"], ["", "lemma i_edges_covered: \n    \"is_invar (\\<lambda>s. (E \\<inter> dom (discovered s) \\<times> UNIV) - pending s = edges s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_invar\n     (\\<lambda>s.\n         E \\<inter> dom (discovered s) \\<times> UNIV - pending s =\n         tree_edges s \\<union> cross_edges s \\<union> back_edges s)", "proof (induction rule: is_invarI_full)"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>e.\n       E \\<inter> dom (discovered (empty_state e)) \\<times> UNIV -\n       pending (empty_state e) =\n       tree_edges (empty_state e) \\<union>\n       cross_edges (empty_state e) \\<union>\n       back_edges (empty_state e)\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>E \\<inter> dom (discovered s) \\<times> UNIV - pending s =\n                tree_edges s \\<union> cross_edges s \\<union> back_edges s;\n        cond s; DFS_invar G param s; DFS_invar G param s'; stack s = [];\n        v0 \\<notin> dom (discovered s); v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> E \\<inter> dom (discovered s') \\<times> UNIV -\n                         pending s' =\n                         tree_edges s' \\<union> cross_edges s' \\<union>\n                         back_edges s'\n 3. \\<And>s s' u e.\n       \\<lbrakk>E \\<inter> dom (discovered s) \\<times> UNIV - pending s =\n                tree_edges s \\<union> cross_edges s \\<union> back_edges s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; pending s `` {u} = {}; u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> E \\<inter> dom (discovered s') \\<times> UNIV -\n                         pending s' =\n                         tree_edges s' \\<union> cross_edges s' \\<union>\n                         back_edges s'\n 4. \\<And>s s' u v e.\n       \\<lbrakk>E \\<inter> dom (discovered s) \\<times> UNIV - pending s =\n                tree_edges s \\<union> cross_edges s \\<union> back_edges s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        u = hd (stack s);\n        s' =\n        cross_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> E \\<inter> dom (discovered s') \\<times> UNIV -\n                         pending s' =\n                         tree_edges s' \\<union> cross_edges s' \\<union>\n                         back_edges s'\n 5. \\<And>s s' u v e.\n       \\<lbrakk>E \\<inter> dom (discovered s) \\<times> UNIV - pending s =\n                tree_edges s \\<union> cross_edges s \\<union> back_edges s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        u = hd (stack s);\n        s' =\n        back_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> E \\<inter> dom (discovered s') \\<times> UNIV -\n                         pending s' =\n                         tree_edges s' \\<union> cross_edges s' \\<union>\n                         back_edges s'\n 6. \\<And>s s' u v e.\n       \\<lbrakk>E \\<inter> dom (discovered s) \\<times> UNIV - pending s =\n                tree_edges s \\<union> cross_edges s \\<union> back_edges s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> E \\<inter> dom (discovered s') \\<times> UNIV -\n                         pending s' =\n                         tree_edges s' \\<union> cross_edges s' \\<union>\n                         back_edges s'", "case (new_root s s' v0)"], ["proof (state)\nthis:\n  E \\<inter> dom (discovered s) \\<times> UNIV - pending s =\n  tree_edges s \\<union> cross_edges s \\<union> back_edges s\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  v0 \\<in> V0\n  s' = new_root v0 s\\<lparr>state.more := e_\\<rparr>\n  stack s = []\n  v0 \\<notin> dom (discovered s)\n\ngoal (6 subgoals):\n 1. \\<And>e.\n       E \\<inter> dom (discovered (empty_state e)) \\<times> UNIV -\n       pending (empty_state e) =\n       tree_edges (empty_state e) \\<union>\n       cross_edges (empty_state e) \\<union>\n       back_edges (empty_state e)\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>E \\<inter> dom (discovered s) \\<times> UNIV - pending s =\n                tree_edges s \\<union> cross_edges s \\<union> back_edges s;\n        cond s; DFS_invar G param s; DFS_invar G param s'; stack s = [];\n        v0 \\<notin> dom (discovered s); v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> E \\<inter> dom (discovered s') \\<times> UNIV -\n                         pending s' =\n                         tree_edges s' \\<union> cross_edges s' \\<union>\n                         back_edges s'\n 3. \\<And>s s' u e.\n       \\<lbrakk>E \\<inter> dom (discovered s) \\<times> UNIV - pending s =\n                tree_edges s \\<union> cross_edges s \\<union> back_edges s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; pending s `` {u} = {}; u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> E \\<inter> dom (discovered s') \\<times> UNIV -\n                         pending s' =\n                         tree_edges s' \\<union> cross_edges s' \\<union>\n                         back_edges s'\n 4. \\<And>s s' u v e.\n       \\<lbrakk>E \\<inter> dom (discovered s) \\<times> UNIV - pending s =\n                tree_edges s \\<union> cross_edges s \\<union> back_edges s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        u = hd (stack s);\n        s' =\n        cross_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> E \\<inter> dom (discovered s') \\<times> UNIV -\n                         pending s' =\n                         tree_edges s' \\<union> cross_edges s' \\<union>\n                         back_edges s'\n 5. \\<And>s s' u v e.\n       \\<lbrakk>E \\<inter> dom (discovered s) \\<times> UNIV - pending s =\n                tree_edges s \\<union> cross_edges s \\<union> back_edges s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        u = hd (stack s);\n        s' =\n        back_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> E \\<inter> dom (discovered s') \\<times> UNIV -\n                         pending s' =\n                         tree_edges s' \\<union> cross_edges s' \\<union>\n                         back_edges s'\n 6. \\<And>s s' u v e.\n       \\<lbrakk>E \\<inter> dom (discovered s) \\<times> UNIV - pending s =\n                tree_edges s \\<union> cross_edges s \\<union> back_edges s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> E \\<inter> dom (discovered s') \\<times> UNIV -\n                         pending s' =\n                         tree_edges s' \\<union> cross_edges s' \\<union>\n                         back_edges s'", "interpret DFS_invar G param s"], ["proof (prove)\ngoal (1 subgoal):\n 1. DFS_invar G param s", "by fact"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>e.\n       E \\<inter> dom (discovered (empty_state e)) \\<times> UNIV -\n       pending (empty_state e) =\n       tree_edges (empty_state e) \\<union>\n       cross_edges (empty_state e) \\<union>\n       back_edges (empty_state e)\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>E \\<inter> dom (discovered s) \\<times> UNIV - pending s =\n                tree_edges s \\<union> cross_edges s \\<union> back_edges s;\n        cond s; DFS_invar G param s; DFS_invar G param s'; stack s = [];\n        v0 \\<notin> dom (discovered s); v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> E \\<inter> dom (discovered s') \\<times> UNIV -\n                         pending s' =\n                         tree_edges s' \\<union> cross_edges s' \\<union>\n                         back_edges s'\n 3. \\<And>s s' u e.\n       \\<lbrakk>E \\<inter> dom (discovered s) \\<times> UNIV - pending s =\n                tree_edges s \\<union> cross_edges s \\<union> back_edges s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; pending s `` {u} = {}; u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> E \\<inter> dom (discovered s') \\<times> UNIV -\n                         pending s' =\n                         tree_edges s' \\<union> cross_edges s' \\<union>\n                         back_edges s'\n 4. \\<And>s s' u v e.\n       \\<lbrakk>E \\<inter> dom (discovered s) \\<times> UNIV - pending s =\n                tree_edges s \\<union> cross_edges s \\<union> back_edges s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        u = hd (stack s);\n        s' =\n        cross_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> E \\<inter> dom (discovered s') \\<times> UNIV -\n                         pending s' =\n                         tree_edges s' \\<union> cross_edges s' \\<union>\n                         back_edges s'\n 5. \\<And>s s' u v e.\n       \\<lbrakk>E \\<inter> dom (discovered s) \\<times> UNIV - pending s =\n                tree_edges s \\<union> cross_edges s \\<union> back_edges s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        u = hd (stack s);\n        s' =\n        back_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> E \\<inter> dom (discovered s') \\<times> UNIV -\n                         pending s' =\n                         tree_edges s' \\<union> cross_edges s' \\<union>\n                         back_edges s'\n 6. \\<And>s s' u v e.\n       \\<lbrakk>E \\<inter> dom (discovered s) \\<times> UNIV - pending s =\n                tree_edges s \\<union> cross_edges s \\<union> back_edges s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> E \\<inter> dom (discovered s') \\<times> UNIV -\n                         pending s' =\n                         tree_edges s' \\<union> cross_edges s' \\<union>\n                         back_edges s'", "from new_root empty_stack_imp_empty_pending"], ["proof (chain)\npicking this:\n  E \\<inter> dom (discovered s) \\<times> UNIV - pending s =\n  tree_edges s \\<union> cross_edges s \\<union> back_edges s\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  v0 \\<in> V0\n  s' = new_root v0 s\\<lparr>state.more := e_\\<rparr>\n  stack s = []\n  v0 \\<notin> dom (discovered s)\n  stack s = [] \\<Longrightarrow> pending s = {}", "have [simp]: \"pending s = {}\""], ["proof (prove)\nusing this:\n  E \\<inter> dom (discovered s) \\<times> UNIV - pending s =\n  tree_edges s \\<union> cross_edges s \\<union> back_edges s\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  v0 \\<in> V0\n  s' = new_root v0 s\\<lparr>state.more := e_\\<rparr>\n  stack s = []\n  v0 \\<notin> dom (discovered s)\n  stack s = [] \\<Longrightarrow> pending s = {}\n\ngoal (1 subgoal):\n 1. pending s = {}", "by simp"], ["proof (state)\nthis:\n  pending s = {}\n\ngoal (6 subgoals):\n 1. \\<And>e.\n       E \\<inter> dom (discovered (empty_state e)) \\<times> UNIV -\n       pending (empty_state e) =\n       tree_edges (empty_state e) \\<union>\n       cross_edges (empty_state e) \\<union>\n       back_edges (empty_state e)\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>E \\<inter> dom (discovered s) \\<times> UNIV - pending s =\n                tree_edges s \\<union> cross_edges s \\<union> back_edges s;\n        cond s; DFS_invar G param s; DFS_invar G param s'; stack s = [];\n        v0 \\<notin> dom (discovered s); v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> E \\<inter> dom (discovered s') \\<times> UNIV -\n                         pending s' =\n                         tree_edges s' \\<union> cross_edges s' \\<union>\n                         back_edges s'\n 3. \\<And>s s' u e.\n       \\<lbrakk>E \\<inter> dom (discovered s) \\<times> UNIV - pending s =\n                tree_edges s \\<union> cross_edges s \\<union> back_edges s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; pending s `` {u} = {}; u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> E \\<inter> dom (discovered s') \\<times> UNIV -\n                         pending s' =\n                         tree_edges s' \\<union> cross_edges s' \\<union>\n                         back_edges s'\n 4. \\<And>s s' u v e.\n       \\<lbrakk>E \\<inter> dom (discovered s) \\<times> UNIV - pending s =\n                tree_edges s \\<union> cross_edges s \\<union> back_edges s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        u = hd (stack s);\n        s' =\n        cross_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> E \\<inter> dom (discovered s') \\<times> UNIV -\n                         pending s' =\n                         tree_edges s' \\<union> cross_edges s' \\<union>\n                         back_edges s'\n 5. \\<And>s s' u v e.\n       \\<lbrakk>E \\<inter> dom (discovered s) \\<times> UNIV - pending s =\n                tree_edges s \\<union> cross_edges s \\<union> back_edges s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        u = hd (stack s);\n        s' =\n        back_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> E \\<inter> dom (discovered s') \\<times> UNIV -\n                         pending s' =\n                         tree_edges s' \\<union> cross_edges s' \\<union>\n                         back_edges s'\n 6. \\<And>s s' u v e.\n       \\<lbrakk>E \\<inter> dom (discovered s) \\<times> UNIV - pending s =\n                tree_edges s \\<union> cross_edges s \\<union> back_edges s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> E \\<inter> dom (discovered s') \\<times> UNIV -\n                         pending s' =\n                         tree_edges s' \\<union> cross_edges s' \\<union>\n                         back_edges s'", "from \\<open>v0 \\<notin> dom (discovered s)\\<close>"], ["proof (chain)\npicking this:\n  v0 \\<notin> dom (discovered s)", "have [simp]: \"E \\<inter> insert v0 (dom (discovered s)) \\<times> UNIV - {v0} \\<times> succ v0 \n      = E \\<inter> dom (discovered s) \\<times> UNIV\""], ["proof (prove)\nusing this:\n  v0 \\<notin> dom (discovered s)\n\ngoal (1 subgoal):\n 1. E \\<inter> insert v0 (dom (discovered s)) \\<times> UNIV -\n    {v0} \\<times> E `` {v0} =\n    E \\<inter> dom (discovered s) \\<times> UNIV", "by auto"], ["proof (state)\nthis:\n  E \\<inter> insert v0 (dom (discovered s)) \\<times> UNIV -\n  {v0} \\<times> E `` {v0} =\n  E \\<inter> dom (discovered s) \\<times> UNIV\n\ngoal (6 subgoals):\n 1. \\<And>e.\n       E \\<inter> dom (discovered (empty_state e)) \\<times> UNIV -\n       pending (empty_state e) =\n       tree_edges (empty_state e) \\<union>\n       cross_edges (empty_state e) \\<union>\n       back_edges (empty_state e)\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>E \\<inter> dom (discovered s) \\<times> UNIV - pending s =\n                tree_edges s \\<union> cross_edges s \\<union> back_edges s;\n        cond s; DFS_invar G param s; DFS_invar G param s'; stack s = [];\n        v0 \\<notin> dom (discovered s); v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> E \\<inter> dom (discovered s') \\<times> UNIV -\n                         pending s' =\n                         tree_edges s' \\<union> cross_edges s' \\<union>\n                         back_edges s'\n 3. \\<And>s s' u e.\n       \\<lbrakk>E \\<inter> dom (discovered s) \\<times> UNIV - pending s =\n                tree_edges s \\<union> cross_edges s \\<union> back_edges s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; pending s `` {u} = {}; u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> E \\<inter> dom (discovered s') \\<times> UNIV -\n                         pending s' =\n                         tree_edges s' \\<union> cross_edges s' \\<union>\n                         back_edges s'\n 4. \\<And>s s' u v e.\n       \\<lbrakk>E \\<inter> dom (discovered s) \\<times> UNIV - pending s =\n                tree_edges s \\<union> cross_edges s \\<union> back_edges s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        u = hd (stack s);\n        s' =\n        cross_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> E \\<inter> dom (discovered s') \\<times> UNIV -\n                         pending s' =\n                         tree_edges s' \\<union> cross_edges s' \\<union>\n                         back_edges s'\n 5. \\<And>s s' u v e.\n       \\<lbrakk>E \\<inter> dom (discovered s) \\<times> UNIV - pending s =\n                tree_edges s \\<union> cross_edges s \\<union> back_edges s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        u = hd (stack s);\n        s' =\n        back_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> E \\<inter> dom (discovered s') \\<times> UNIV -\n                         pending s' =\n                         tree_edges s' \\<union> cross_edges s' \\<union>\n                         back_edges s'\n 6. \\<And>s s' u v e.\n       \\<lbrakk>E \\<inter> dom (discovered s) \\<times> UNIV - pending s =\n                tree_edges s \\<union> cross_edges s \\<union> back_edges s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> E \\<inter> dom (discovered s') \\<times> UNIV -\n                         pending s' =\n                         tree_edges s' \\<union> cross_edges s' \\<union>\n                         back_edges s'", "from new_root"], ["proof (chain)\npicking this:\n  E \\<inter> dom (discovered s) \\<times> UNIV - pending s =\n  tree_edges s \\<union> cross_edges s \\<union> back_edges s\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  v0 \\<in> V0\n  s' = new_root v0 s\\<lparr>state.more := e_\\<rparr>\n  stack s = []\n  v0 \\<notin> dom (discovered s)", "show ?case"], ["proof (prove)\nusing this:\n  E \\<inter> dom (discovered s) \\<times> UNIV - pending s =\n  tree_edges s \\<union> cross_edges s \\<union> back_edges s\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  v0 \\<in> V0\n  s' = new_root v0 s\\<lparr>state.more := e_\\<rparr>\n  stack s = []\n  v0 \\<notin> dom (discovered s)\n\ngoal (1 subgoal):\n 1. E \\<inter> dom (discovered s') \\<times> UNIV - pending s' =\n    tree_edges s' \\<union> cross_edges s' \\<union> back_edges s'", "by simp"], ["proof (state)\nthis:\n  E \\<inter> dom (discovered s') \\<times> UNIV - pending s' =\n  tree_edges s' \\<union> cross_edges s' \\<union> back_edges s'\n\ngoal (5 subgoals):\n 1. \\<And>e.\n       E \\<inter> dom (discovered (empty_state e)) \\<times> UNIV -\n       pending (empty_state e) =\n       tree_edges (empty_state e) \\<union>\n       cross_edges (empty_state e) \\<union>\n       back_edges (empty_state e)\n 2. \\<And>s s' u e.\n       \\<lbrakk>E \\<inter> dom (discovered s) \\<times> UNIV - pending s =\n                tree_edges s \\<union> cross_edges s \\<union> back_edges s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; pending s `` {u} = {}; u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> E \\<inter> dom (discovered s') \\<times> UNIV -\n                         pending s' =\n                         tree_edges s' \\<union> cross_edges s' \\<union>\n                         back_edges s'\n 3. \\<And>s s' u v e.\n       \\<lbrakk>E \\<inter> dom (discovered s) \\<times> UNIV - pending s =\n                tree_edges s \\<union> cross_edges s \\<union> back_edges s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        u = hd (stack s);\n        s' =\n        cross_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> E \\<inter> dom (discovered s') \\<times> UNIV -\n                         pending s' =\n                         tree_edges s' \\<union> cross_edges s' \\<union>\n                         back_edges s'\n 4. \\<And>s s' u v e.\n       \\<lbrakk>E \\<inter> dom (discovered s) \\<times> UNIV - pending s =\n                tree_edges s \\<union> cross_edges s \\<union> back_edges s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        u = hd (stack s);\n        s' =\n        back_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> E \\<inter> dom (discovered s') \\<times> UNIV -\n                         pending s' =\n                         tree_edges s' \\<union> cross_edges s' \\<union>\n                         back_edges s'\n 5. \\<And>s s' u v e.\n       \\<lbrakk>E \\<inter> dom (discovered s) \\<times> UNIV - pending s =\n                tree_edges s \\<union> cross_edges s \\<union> back_edges s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> E \\<inter> dom (discovered s') \\<times> UNIV -\n                         pending s' =\n                         tree_edges s' \\<union> cross_edges s' \\<union>\n                         back_edges s'", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>e.\n       E \\<inter> dom (discovered (empty_state e)) \\<times> UNIV -\n       pending (empty_state e) =\n       tree_edges (empty_state e) \\<union>\n       cross_edges (empty_state e) \\<union>\n       back_edges (empty_state e)\n 2. \\<And>s s' u e.\n       \\<lbrakk>E \\<inter> dom (discovered s) \\<times> UNIV - pending s =\n                tree_edges s \\<union> cross_edges s \\<union> back_edges s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; pending s `` {u} = {}; u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> E \\<inter> dom (discovered s') \\<times> UNIV -\n                         pending s' =\n                         tree_edges s' \\<union> cross_edges s' \\<union>\n                         back_edges s'\n 3. \\<And>s s' u v e.\n       \\<lbrakk>E \\<inter> dom (discovered s) \\<times> UNIV - pending s =\n                tree_edges s \\<union> cross_edges s \\<union> back_edges s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        u = hd (stack s);\n        s' =\n        cross_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> E \\<inter> dom (discovered s') \\<times> UNIV -\n                         pending s' =\n                         tree_edges s' \\<union> cross_edges s' \\<union>\n                         back_edges s'\n 4. \\<And>s s' u v e.\n       \\<lbrakk>E \\<inter> dom (discovered s) \\<times> UNIV - pending s =\n                tree_edges s \\<union> cross_edges s \\<union> back_edges s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        u = hd (stack s);\n        s' =\n        back_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> E \\<inter> dom (discovered s') \\<times> UNIV -\n                         pending s' =\n                         tree_edges s' \\<union> cross_edges s' \\<union>\n                         back_edges s'\n 5. \\<And>s s' u v e.\n       \\<lbrakk>E \\<inter> dom (discovered s) \\<times> UNIV - pending s =\n                tree_edges s \\<union> cross_edges s \\<union> back_edges s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> E \\<inter> dom (discovered s') \\<times> UNIV -\n                         pending s' =\n                         tree_edges s' \\<union> cross_edges s' \\<union>\n                         back_edges s'", "case (cross_edge s s' u v)"], ["proof (state)\nthis:\n  E \\<inter> dom (discovered s) \\<times> UNIV - pending s =\n  tree_edges s \\<union> cross_edges s \\<union> back_edges s\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s \\<noteq> []\n  v \\<in> pending s `` {u}\n  v \\<in> dom (discovered s)\n  v \\<in> dom (finished s)\n  u = hd (stack s)\n  s' = cross_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n  \\<lparr>state.more := e_\\<rparr>\n\ngoal (5 subgoals):\n 1. \\<And>e.\n       E \\<inter> dom (discovered (empty_state e)) \\<times> UNIV -\n       pending (empty_state e) =\n       tree_edges (empty_state e) \\<union>\n       cross_edges (empty_state e) \\<union>\n       back_edges (empty_state e)\n 2. \\<And>s s' u e.\n       \\<lbrakk>E \\<inter> dom (discovered s) \\<times> UNIV - pending s =\n                tree_edges s \\<union> cross_edges s \\<union> back_edges s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; pending s `` {u} = {}; u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> E \\<inter> dom (discovered s') \\<times> UNIV -\n                         pending s' =\n                         tree_edges s' \\<union> cross_edges s' \\<union>\n                         back_edges s'\n 3. \\<And>s s' u v e.\n       \\<lbrakk>E \\<inter> dom (discovered s) \\<times> UNIV - pending s =\n                tree_edges s \\<union> cross_edges s \\<union> back_edges s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        u = hd (stack s);\n        s' =\n        cross_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> E \\<inter> dom (discovered s') \\<times> UNIV -\n                         pending s' =\n                         tree_edges s' \\<union> cross_edges s' \\<union>\n                         back_edges s'\n 4. \\<And>s s' u v e.\n       \\<lbrakk>E \\<inter> dom (discovered s) \\<times> UNIV - pending s =\n                tree_edges s \\<union> cross_edges s \\<union> back_edges s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        u = hd (stack s);\n        s' =\n        back_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> E \\<inter> dom (discovered s') \\<times> UNIV -\n                         pending s' =\n                         tree_edges s' \\<union> cross_edges s' \\<union>\n                         back_edges s'\n 5. \\<And>s s' u v e.\n       \\<lbrakk>E \\<inter> dom (discovered s) \\<times> UNIV - pending s =\n                tree_edges s \\<union> cross_edges s \\<union> back_edges s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> E \\<inter> dom (discovered s') \\<times> UNIV -\n                         pending s' =\n                         tree_edges s' \\<union> cross_edges s' \\<union>\n                         back_edges s'", "interpret DFS_invar G param s"], ["proof (prove)\ngoal (1 subgoal):\n 1. DFS_invar G param s", "by fact"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>e.\n       E \\<inter> dom (discovered (empty_state e)) \\<times> UNIV -\n       pending (empty_state e) =\n       tree_edges (empty_state e) \\<union>\n       cross_edges (empty_state e) \\<union>\n       back_edges (empty_state e)\n 2. \\<And>s s' u e.\n       \\<lbrakk>E \\<inter> dom (discovered s) \\<times> UNIV - pending s =\n                tree_edges s \\<union> cross_edges s \\<union> back_edges s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; pending s `` {u} = {}; u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> E \\<inter> dom (discovered s') \\<times> UNIV -\n                         pending s' =\n                         tree_edges s' \\<union> cross_edges s' \\<union>\n                         back_edges s'\n 3. \\<And>s s' u v e.\n       \\<lbrakk>E \\<inter> dom (discovered s) \\<times> UNIV - pending s =\n                tree_edges s \\<union> cross_edges s \\<union> back_edges s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        u = hd (stack s);\n        s' =\n        cross_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> E \\<inter> dom (discovered s') \\<times> UNIV -\n                         pending s' =\n                         tree_edges s' \\<union> cross_edges s' \\<union>\n                         back_edges s'\n 4. \\<And>s s' u v e.\n       \\<lbrakk>E \\<inter> dom (discovered s) \\<times> UNIV - pending s =\n                tree_edges s \\<union> cross_edges s \\<union> back_edges s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        u = hd (stack s);\n        s' =\n        back_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> E \\<inter> dom (discovered s') \\<times> UNIV -\n                         pending s' =\n                         tree_edges s' \\<union> cross_edges s' \\<union>\n                         back_edges s'\n 5. \\<And>s s' u v e.\n       \\<lbrakk>E \\<inter> dom (discovered s) \\<times> UNIV - pending s =\n                tree_edges s \\<union> cross_edges s \\<union> back_edges s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> E \\<inter> dom (discovered s') \\<times> UNIV -\n                         pending s' =\n                         tree_edges s' \\<union> cross_edges s' \\<union>\n                         back_edges s'", "from cross_edge stack_discovered"], ["proof (chain)\npicking this:\n  E \\<inter> dom (discovered s) \\<times> UNIV - pending s =\n  tree_edges s \\<union> cross_edges s \\<union> back_edges s\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s \\<noteq> []\n  v \\<in> pending s `` {u}\n  v \\<in> dom (discovered s)\n  v \\<in> dom (finished s)\n  u = hd (stack s)\n  s' = cross_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n  \\<lparr>state.more := e_\\<rparr>\n  set (stack s) \\<subseteq> dom (discovered s)", "have \"u \\<in> dom (discovered s)\""], ["proof (prove)\nusing this:\n  E \\<inter> dom (discovered s) \\<times> UNIV - pending s =\n  tree_edges s \\<union> cross_edges s \\<union> back_edges s\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s \\<noteq> []\n  v \\<in> pending s `` {u}\n  v \\<in> dom (discovered s)\n  v \\<in> dom (finished s)\n  u = hd (stack s)\n  s' = cross_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n  \\<lparr>state.more := e_\\<rparr>\n  set (stack s) \\<subseteq> dom (discovered s)\n\ngoal (1 subgoal):\n 1. u \\<in> dom (discovered s)", "by (cases \"stack s\") auto"], ["proof (state)\nthis:\n  u \\<in> dom (discovered s)\n\ngoal (5 subgoals):\n 1. \\<And>e.\n       E \\<inter> dom (discovered (empty_state e)) \\<times> UNIV -\n       pending (empty_state e) =\n       tree_edges (empty_state e) \\<union>\n       cross_edges (empty_state e) \\<union>\n       back_edges (empty_state e)\n 2. \\<And>s s' u e.\n       \\<lbrakk>E \\<inter> dom (discovered s) \\<times> UNIV - pending s =\n                tree_edges s \\<union> cross_edges s \\<union> back_edges s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; pending s `` {u} = {}; u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> E \\<inter> dom (discovered s') \\<times> UNIV -\n                         pending s' =\n                         tree_edges s' \\<union> cross_edges s' \\<union>\n                         back_edges s'\n 3. \\<And>s s' u v e.\n       \\<lbrakk>E \\<inter> dom (discovered s) \\<times> UNIV - pending s =\n                tree_edges s \\<union> cross_edges s \\<union> back_edges s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        u = hd (stack s);\n        s' =\n        cross_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> E \\<inter> dom (discovered s') \\<times> UNIV -\n                         pending s' =\n                         tree_edges s' \\<union> cross_edges s' \\<union>\n                         back_edges s'\n 4. \\<And>s s' u v e.\n       \\<lbrakk>E \\<inter> dom (discovered s) \\<times> UNIV - pending s =\n                tree_edges s \\<union> cross_edges s \\<union> back_edges s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        u = hd (stack s);\n        s' =\n        back_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> E \\<inter> dom (discovered s') \\<times> UNIV -\n                         pending s' =\n                         tree_edges s' \\<union> cross_edges s' \\<union>\n                         back_edges s'\n 5. \\<And>s s' u v e.\n       \\<lbrakk>E \\<inter> dom (discovered s) \\<times> UNIV - pending s =\n                tree_edges s \\<union> cross_edges s \\<union> back_edges s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> E \\<inter> dom (discovered s') \\<times> UNIV -\n                         pending s' =\n                         tree_edges s' \\<union> cross_edges s' \\<union>\n                         back_edges s'", "with cross_edge(2-) pending_ssE"], ["proof (chain)\npicking this:\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s \\<noteq> []\n  v \\<in> pending s `` {u}\n  v \\<in> dom (discovered s)\n  v \\<in> dom (finished s)\n  u = hd (stack s)\n  s' = cross_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n  \\<lparr>state.more := e_\\<rparr>\n  pending s \\<subseteq> E\n  u \\<in> dom (discovered s)", "have \n      \"E \\<inter> dom (discovered s) \\<times> UNIV - (pending s - {(hd (stack s), v)})\n      = insert (hd (stack s), v) (E \\<inter> dom (discovered s) \\<times> UNIV - pending s)\""], ["proof (prove)\nusing this:\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s \\<noteq> []\n  v \\<in> pending s `` {u}\n  v \\<in> dom (discovered s)\n  v \\<in> dom (finished s)\n  u = hd (stack s)\n  s' = cross_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n  \\<lparr>state.more := e_\\<rparr>\n  pending s \\<subseteq> E\n  u \\<in> dom (discovered s)\n\ngoal (1 subgoal):\n 1. E \\<inter> dom (discovered s) \\<times> UNIV -\n    (pending s - {(hd (stack s), v)}) =\n    insert (hd (stack s), v)\n     (E \\<inter> dom (discovered s) \\<times> UNIV - pending s)", "by auto"], ["proof (state)\nthis:\n  E \\<inter> dom (discovered s) \\<times> UNIV -\n  (pending s - {(hd (stack s), v)}) =\n  insert (hd (stack s), v)\n   (E \\<inter> dom (discovered s) \\<times> UNIV - pending s)\n\ngoal (5 subgoals):\n 1. \\<And>e.\n       E \\<inter> dom (discovered (empty_state e)) \\<times> UNIV -\n       pending (empty_state e) =\n       tree_edges (empty_state e) \\<union>\n       cross_edges (empty_state e) \\<union>\n       back_edges (empty_state e)\n 2. \\<And>s s' u e.\n       \\<lbrakk>E \\<inter> dom (discovered s) \\<times> UNIV - pending s =\n                tree_edges s \\<union> cross_edges s \\<union> back_edges s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; pending s `` {u} = {}; u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> E \\<inter> dom (discovered s') \\<times> UNIV -\n                         pending s' =\n                         tree_edges s' \\<union> cross_edges s' \\<union>\n                         back_edges s'\n 3. \\<And>s s' u v e.\n       \\<lbrakk>E \\<inter> dom (discovered s) \\<times> UNIV - pending s =\n                tree_edges s \\<union> cross_edges s \\<union> back_edges s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        u = hd (stack s);\n        s' =\n        cross_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> E \\<inter> dom (discovered s') \\<times> UNIV -\n                         pending s' =\n                         tree_edges s' \\<union> cross_edges s' \\<union>\n                         back_edges s'\n 4. \\<And>s s' u v e.\n       \\<lbrakk>E \\<inter> dom (discovered s) \\<times> UNIV - pending s =\n                tree_edges s \\<union> cross_edges s \\<union> back_edges s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        u = hd (stack s);\n        s' =\n        back_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> E \\<inter> dom (discovered s') \\<times> UNIV -\n                         pending s' =\n                         tree_edges s' \\<union> cross_edges s' \\<union>\n                         back_edges s'\n 5. \\<And>s s' u v e.\n       \\<lbrakk>E \\<inter> dom (discovered s) \\<times> UNIV - pending s =\n                tree_edges s \\<union> cross_edges s \\<union> back_edges s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> E \\<inter> dom (discovered s') \\<times> UNIV -\n                         pending s' =\n                         tree_edges s' \\<union> cross_edges s' \\<union>\n                         back_edges s'", "thus ?case"], ["proof (prove)\nusing this:\n  E \\<inter> dom (discovered s) \\<times> UNIV -\n  (pending s - {(hd (stack s), v)}) =\n  insert (hd (stack s), v)\n   (E \\<inter> dom (discovered s) \\<times> UNIV - pending s)\n\ngoal (1 subgoal):\n 1. E \\<inter> dom (discovered s') \\<times> UNIV - pending s' =\n    tree_edges s' \\<union> cross_edges s' \\<union> back_edges s'", "using cross_edge"], ["proof (prove)\nusing this:\n  E \\<inter> dom (discovered s) \\<times> UNIV -\n  (pending s - {(hd (stack s), v)}) =\n  insert (hd (stack s), v)\n   (E \\<inter> dom (discovered s) \\<times> UNIV - pending s)\n  E \\<inter> dom (discovered s) \\<times> UNIV - pending s =\n  tree_edges s \\<union> cross_edges s \\<union> back_edges s\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s \\<noteq> []\n  v \\<in> pending s `` {u}\n  v \\<in> dom (discovered s)\n  v \\<in> dom (finished s)\n  u = hd (stack s)\n  s' = cross_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n  \\<lparr>state.more := e_\\<rparr>\n\ngoal (1 subgoal):\n 1. E \\<inter> dom (discovered s') \\<times> UNIV - pending s' =\n    tree_edges s' \\<union> cross_edges s' \\<union> back_edges s'", "by simp"], ["proof (state)\nthis:\n  E \\<inter> dom (discovered s') \\<times> UNIV - pending s' =\n  tree_edges s' \\<union> cross_edges s' \\<union> back_edges s'\n\ngoal (4 subgoals):\n 1. \\<And>e.\n       E \\<inter> dom (discovered (empty_state e)) \\<times> UNIV -\n       pending (empty_state e) =\n       tree_edges (empty_state e) \\<union>\n       cross_edges (empty_state e) \\<union>\n       back_edges (empty_state e)\n 2. \\<And>s s' u e.\n       \\<lbrakk>E \\<inter> dom (discovered s) \\<times> UNIV - pending s =\n                tree_edges s \\<union> cross_edges s \\<union> back_edges s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; pending s `` {u} = {}; u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> E \\<inter> dom (discovered s') \\<times> UNIV -\n                         pending s' =\n                         tree_edges s' \\<union> cross_edges s' \\<union>\n                         back_edges s'\n 3. \\<And>s s' u v e.\n       \\<lbrakk>E \\<inter> dom (discovered s) \\<times> UNIV - pending s =\n                tree_edges s \\<union> cross_edges s \\<union> back_edges s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        u = hd (stack s);\n        s' =\n        back_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> E \\<inter> dom (discovered s') \\<times> UNIV -\n                         pending s' =\n                         tree_edges s' \\<union> cross_edges s' \\<union>\n                         back_edges s'\n 4. \\<And>s s' u v e.\n       \\<lbrakk>E \\<inter> dom (discovered s) \\<times> UNIV - pending s =\n                tree_edges s \\<union> cross_edges s \\<union> back_edges s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> E \\<inter> dom (discovered s') \\<times> UNIV -\n                         pending s' =\n                         tree_edges s' \\<union> cross_edges s' \\<union>\n                         back_edges s'", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>e.\n       E \\<inter> dom (discovered (empty_state e)) \\<times> UNIV -\n       pending (empty_state e) =\n       tree_edges (empty_state e) \\<union>\n       cross_edges (empty_state e) \\<union>\n       back_edges (empty_state e)\n 2. \\<And>s s' u e.\n       \\<lbrakk>E \\<inter> dom (discovered s) \\<times> UNIV - pending s =\n                tree_edges s \\<union> cross_edges s \\<union> back_edges s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; pending s `` {u} = {}; u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> E \\<inter> dom (discovered s') \\<times> UNIV -\n                         pending s' =\n                         tree_edges s' \\<union> cross_edges s' \\<union>\n                         back_edges s'\n 3. \\<And>s s' u v e.\n       \\<lbrakk>E \\<inter> dom (discovered s) \\<times> UNIV - pending s =\n                tree_edges s \\<union> cross_edges s \\<union> back_edges s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        u = hd (stack s);\n        s' =\n        back_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> E \\<inter> dom (discovered s') \\<times> UNIV -\n                         pending s' =\n                         tree_edges s' \\<union> cross_edges s' \\<union>\n                         back_edges s'\n 4. \\<And>s s' u v e.\n       \\<lbrakk>E \\<inter> dom (discovered s) \\<times> UNIV - pending s =\n                tree_edges s \\<union> cross_edges s \\<union> back_edges s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> E \\<inter> dom (discovered s') \\<times> UNIV -\n                         pending s' =\n                         tree_edges s' \\<union> cross_edges s' \\<union>\n                         back_edges s'", "case (back_edge s s' u v)"], ["proof (state)\nthis:\n  E \\<inter> dom (discovered s) \\<times> UNIV - pending s =\n  tree_edges s \\<union> cross_edges s \\<union> back_edges s\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s \\<noteq> []\n  v \\<in> pending s `` {u}\n  v \\<in> dom (discovered s)\n  v \\<notin> dom (finished s)\n  u = hd (stack s)\n  s' = back_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n  \\<lparr>state.more := e_\\<rparr>\n\ngoal (4 subgoals):\n 1. \\<And>e.\n       E \\<inter> dom (discovered (empty_state e)) \\<times> UNIV -\n       pending (empty_state e) =\n       tree_edges (empty_state e) \\<union>\n       cross_edges (empty_state e) \\<union>\n       back_edges (empty_state e)\n 2. \\<And>s s' u e.\n       \\<lbrakk>E \\<inter> dom (discovered s) \\<times> UNIV - pending s =\n                tree_edges s \\<union> cross_edges s \\<union> back_edges s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; pending s `` {u} = {}; u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> E \\<inter> dom (discovered s') \\<times> UNIV -\n                         pending s' =\n                         tree_edges s' \\<union> cross_edges s' \\<union>\n                         back_edges s'\n 3. \\<And>s s' u v e.\n       \\<lbrakk>E \\<inter> dom (discovered s) \\<times> UNIV - pending s =\n                tree_edges s \\<union> cross_edges s \\<union> back_edges s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        u = hd (stack s);\n        s' =\n        back_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> E \\<inter> dom (discovered s') \\<times> UNIV -\n                         pending s' =\n                         tree_edges s' \\<union> cross_edges s' \\<union>\n                         back_edges s'\n 4. \\<And>s s' u v e.\n       \\<lbrakk>E \\<inter> dom (discovered s) \\<times> UNIV - pending s =\n                tree_edges s \\<union> cross_edges s \\<union> back_edges s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> E \\<inter> dom (discovered s') \\<times> UNIV -\n                         pending s' =\n                         tree_edges s' \\<union> cross_edges s' \\<union>\n                         back_edges s'", "interpret DFS_invar G param s"], ["proof (prove)\ngoal (1 subgoal):\n 1. DFS_invar G param s", "by fact"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>e.\n       E \\<inter> dom (discovered (empty_state e)) \\<times> UNIV -\n       pending (empty_state e) =\n       tree_edges (empty_state e) \\<union>\n       cross_edges (empty_state e) \\<union>\n       back_edges (empty_state e)\n 2. \\<And>s s' u e.\n       \\<lbrakk>E \\<inter> dom (discovered s) \\<times> UNIV - pending s =\n                tree_edges s \\<union> cross_edges s \\<union> back_edges s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; pending s `` {u} = {}; u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> E \\<inter> dom (discovered s') \\<times> UNIV -\n                         pending s' =\n                         tree_edges s' \\<union> cross_edges s' \\<union>\n                         back_edges s'\n 3. \\<And>s s' u v e.\n       \\<lbrakk>E \\<inter> dom (discovered s) \\<times> UNIV - pending s =\n                tree_edges s \\<union> cross_edges s \\<union> back_edges s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        u = hd (stack s);\n        s' =\n        back_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> E \\<inter> dom (discovered s') \\<times> UNIV -\n                         pending s' =\n                         tree_edges s' \\<union> cross_edges s' \\<union>\n                         back_edges s'\n 4. \\<And>s s' u v e.\n       \\<lbrakk>E \\<inter> dom (discovered s) \\<times> UNIV - pending s =\n                tree_edges s \\<union> cross_edges s \\<union> back_edges s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> E \\<inter> dom (discovered s') \\<times> UNIV -\n                         pending s' =\n                         tree_edges s' \\<union> cross_edges s' \\<union>\n                         back_edges s'", "from back_edge stack_discovered"], ["proof (chain)\npicking this:\n  E \\<inter> dom (discovered s) \\<times> UNIV - pending s =\n  tree_edges s \\<union> cross_edges s \\<union> back_edges s\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s \\<noteq> []\n  v \\<in> pending s `` {u}\n  v \\<in> dom (discovered s)\n  v \\<notin> dom (finished s)\n  u = hd (stack s)\n  s' = back_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n  \\<lparr>state.more := e_\\<rparr>\n  set (stack s) \\<subseteq> dom (discovered s)", "have \"u \\<in> dom (discovered s)\""], ["proof (prove)\nusing this:\n  E \\<inter> dom (discovered s) \\<times> UNIV - pending s =\n  tree_edges s \\<union> cross_edges s \\<union> back_edges s\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s \\<noteq> []\n  v \\<in> pending s `` {u}\n  v \\<in> dom (discovered s)\n  v \\<notin> dom (finished s)\n  u = hd (stack s)\n  s' = back_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n  \\<lparr>state.more := e_\\<rparr>\n  set (stack s) \\<subseteq> dom (discovered s)\n\ngoal (1 subgoal):\n 1. u \\<in> dom (discovered s)", "by (cases \"stack s\") auto"], ["proof (state)\nthis:\n  u \\<in> dom (discovered s)\n\ngoal (4 subgoals):\n 1. \\<And>e.\n       E \\<inter> dom (discovered (empty_state e)) \\<times> UNIV -\n       pending (empty_state e) =\n       tree_edges (empty_state e) \\<union>\n       cross_edges (empty_state e) \\<union>\n       back_edges (empty_state e)\n 2. \\<And>s s' u e.\n       \\<lbrakk>E \\<inter> dom (discovered s) \\<times> UNIV - pending s =\n                tree_edges s \\<union> cross_edges s \\<union> back_edges s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; pending s `` {u} = {}; u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> E \\<inter> dom (discovered s') \\<times> UNIV -\n                         pending s' =\n                         tree_edges s' \\<union> cross_edges s' \\<union>\n                         back_edges s'\n 3. \\<And>s s' u v e.\n       \\<lbrakk>E \\<inter> dom (discovered s) \\<times> UNIV - pending s =\n                tree_edges s \\<union> cross_edges s \\<union> back_edges s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        u = hd (stack s);\n        s' =\n        back_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> E \\<inter> dom (discovered s') \\<times> UNIV -\n                         pending s' =\n                         tree_edges s' \\<union> cross_edges s' \\<union>\n                         back_edges s'\n 4. \\<And>s s' u v e.\n       \\<lbrakk>E \\<inter> dom (discovered s) \\<times> UNIV - pending s =\n                tree_edges s \\<union> cross_edges s \\<union> back_edges s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> E \\<inter> dom (discovered s') \\<times> UNIV -\n                         pending s' =\n                         tree_edges s' \\<union> cross_edges s' \\<union>\n                         back_edges s'", "with back_edge(2-) pending_ssE"], ["proof (chain)\npicking this:\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s \\<noteq> []\n  v \\<in> pending s `` {u}\n  v \\<in> dom (discovered s)\n  v \\<notin> dom (finished s)\n  u = hd (stack s)\n  s' = back_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n  \\<lparr>state.more := e_\\<rparr>\n  pending s \\<subseteq> E\n  u \\<in> dom (discovered s)", "have \n      \"E \\<inter> dom (discovered s) \\<times> UNIV - (pending s - {(hd (stack s), v)})\n      = insert (hd (stack s), v) (E \\<inter> dom (discovered s) \\<times> UNIV - pending s)\""], ["proof (prove)\nusing this:\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s \\<noteq> []\n  v \\<in> pending s `` {u}\n  v \\<in> dom (discovered s)\n  v \\<notin> dom (finished s)\n  u = hd (stack s)\n  s' = back_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n  \\<lparr>state.more := e_\\<rparr>\n  pending s \\<subseteq> E\n  u \\<in> dom (discovered s)\n\ngoal (1 subgoal):\n 1. E \\<inter> dom (discovered s) \\<times> UNIV -\n    (pending s - {(hd (stack s), v)}) =\n    insert (hd (stack s), v)\n     (E \\<inter> dom (discovered s) \\<times> UNIV - pending s)", "by auto"], ["proof (state)\nthis:\n  E \\<inter> dom (discovered s) \\<times> UNIV -\n  (pending s - {(hd (stack s), v)}) =\n  insert (hd (stack s), v)\n   (E \\<inter> dom (discovered s) \\<times> UNIV - pending s)\n\ngoal (4 subgoals):\n 1. \\<And>e.\n       E \\<inter> dom (discovered (empty_state e)) \\<times> UNIV -\n       pending (empty_state e) =\n       tree_edges (empty_state e) \\<union>\n       cross_edges (empty_state e) \\<union>\n       back_edges (empty_state e)\n 2. \\<And>s s' u e.\n       \\<lbrakk>E \\<inter> dom (discovered s) \\<times> UNIV - pending s =\n                tree_edges s \\<union> cross_edges s \\<union> back_edges s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; pending s `` {u} = {}; u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> E \\<inter> dom (discovered s') \\<times> UNIV -\n                         pending s' =\n                         tree_edges s' \\<union> cross_edges s' \\<union>\n                         back_edges s'\n 3. \\<And>s s' u v e.\n       \\<lbrakk>E \\<inter> dom (discovered s) \\<times> UNIV - pending s =\n                tree_edges s \\<union> cross_edges s \\<union> back_edges s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        u = hd (stack s);\n        s' =\n        back_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> E \\<inter> dom (discovered s') \\<times> UNIV -\n                         pending s' =\n                         tree_edges s' \\<union> cross_edges s' \\<union>\n                         back_edges s'\n 4. \\<And>s s' u v e.\n       \\<lbrakk>E \\<inter> dom (discovered s) \\<times> UNIV - pending s =\n                tree_edges s \\<union> cross_edges s \\<union> back_edges s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> E \\<inter> dom (discovered s') \\<times> UNIV -\n                         pending s' =\n                         tree_edges s' \\<union> cross_edges s' \\<union>\n                         back_edges s'", "thus ?case"], ["proof (prove)\nusing this:\n  E \\<inter> dom (discovered s) \\<times> UNIV -\n  (pending s - {(hd (stack s), v)}) =\n  insert (hd (stack s), v)\n   (E \\<inter> dom (discovered s) \\<times> UNIV - pending s)\n\ngoal (1 subgoal):\n 1. E \\<inter> dom (discovered s') \\<times> UNIV - pending s' =\n    tree_edges s' \\<union> cross_edges s' \\<union> back_edges s'", "using back_edge"], ["proof (prove)\nusing this:\n  E \\<inter> dom (discovered s) \\<times> UNIV -\n  (pending s - {(hd (stack s), v)}) =\n  insert (hd (stack s), v)\n   (E \\<inter> dom (discovered s) \\<times> UNIV - pending s)\n  E \\<inter> dom (discovered s) \\<times> UNIV - pending s =\n  tree_edges s \\<union> cross_edges s \\<union> back_edges s\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s \\<noteq> []\n  v \\<in> pending s `` {u}\n  v \\<in> dom (discovered s)\n  v \\<notin> dom (finished s)\n  u = hd (stack s)\n  s' = back_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n  \\<lparr>state.more := e_\\<rparr>\n\ngoal (1 subgoal):\n 1. E \\<inter> dom (discovered s') \\<times> UNIV - pending s' =\n    tree_edges s' \\<union> cross_edges s' \\<union> back_edges s'", "by simp"], ["proof (state)\nthis:\n  E \\<inter> dom (discovered s') \\<times> UNIV - pending s' =\n  tree_edges s' \\<union> cross_edges s' \\<union> back_edges s'\n\ngoal (3 subgoals):\n 1. \\<And>e.\n       E \\<inter> dom (discovered (empty_state e)) \\<times> UNIV -\n       pending (empty_state e) =\n       tree_edges (empty_state e) \\<union>\n       cross_edges (empty_state e) \\<union>\n       back_edges (empty_state e)\n 2. \\<And>s s' u e.\n       \\<lbrakk>E \\<inter> dom (discovered s) \\<times> UNIV - pending s =\n                tree_edges s \\<union> cross_edges s \\<union> back_edges s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; pending s `` {u} = {}; u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> E \\<inter> dom (discovered s') \\<times> UNIV -\n                         pending s' =\n                         tree_edges s' \\<union> cross_edges s' \\<union>\n                         back_edges s'\n 3. \\<And>s s' u v e.\n       \\<lbrakk>E \\<inter> dom (discovered s) \\<times> UNIV - pending s =\n                tree_edges s \\<union> cross_edges s \\<union> back_edges s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> E \\<inter> dom (discovered s') \\<times> UNIV -\n                         pending s' =\n                         tree_edges s' \\<union> cross_edges s' \\<union>\n                         back_edges s'", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>e.\n       E \\<inter> dom (discovered (empty_state e)) \\<times> UNIV -\n       pending (empty_state e) =\n       tree_edges (empty_state e) \\<union>\n       cross_edges (empty_state e) \\<union>\n       back_edges (empty_state e)\n 2. \\<And>s s' u e.\n       \\<lbrakk>E \\<inter> dom (discovered s) \\<times> UNIV - pending s =\n                tree_edges s \\<union> cross_edges s \\<union> back_edges s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; pending s `` {u} = {}; u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> E \\<inter> dom (discovered s') \\<times> UNIV -\n                         pending s' =\n                         tree_edges s' \\<union> cross_edges s' \\<union>\n                         back_edges s'\n 3. \\<And>s s' u v e.\n       \\<lbrakk>E \\<inter> dom (discovered s) \\<times> UNIV - pending s =\n                tree_edges s \\<union> cross_edges s \\<union> back_edges s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> E \\<inter> dom (discovered s') \\<times> UNIV -\n                         pending s' =\n                         tree_edges s' \\<union> cross_edges s' \\<union>\n                         back_edges s'", "case (discover s s' u v)"], ["proof (state)\nthis:\n  E \\<inter> dom (discovered s) \\<times> UNIV - pending s =\n  tree_edges s \\<union> cross_edges s \\<union> back_edges s\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n  \\<lparr>state.more := e_\\<rparr>\n  stack s \\<noteq> []\n  v \\<in> pending s `` {u}\n  v \\<notin> dom (discovered s)\n  u = hd (stack s)\n\ngoal (3 subgoals):\n 1. \\<And>e.\n       E \\<inter> dom (discovered (empty_state e)) \\<times> UNIV -\n       pending (empty_state e) =\n       tree_edges (empty_state e) \\<union>\n       cross_edges (empty_state e) \\<union>\n       back_edges (empty_state e)\n 2. \\<And>s s' u e.\n       \\<lbrakk>E \\<inter> dom (discovered s) \\<times> UNIV - pending s =\n                tree_edges s \\<union> cross_edges s \\<union> back_edges s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; pending s `` {u} = {}; u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> E \\<inter> dom (discovered s') \\<times> UNIV -\n                         pending s' =\n                         tree_edges s' \\<union> cross_edges s' \\<union>\n                         back_edges s'\n 3. \\<And>s s' u v e.\n       \\<lbrakk>E \\<inter> dom (discovered s) \\<times> UNIV - pending s =\n                tree_edges s \\<union> cross_edges s \\<union> back_edges s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> E \\<inter> dom (discovered s') \\<times> UNIV -\n                         pending s' =\n                         tree_edges s' \\<union> cross_edges s' \\<union>\n                         back_edges s'", "interpret DFS_invar G param s"], ["proof (prove)\ngoal (1 subgoal):\n 1. DFS_invar G param s", "by fact"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>e.\n       E \\<inter> dom (discovered (empty_state e)) \\<times> UNIV -\n       pending (empty_state e) =\n       tree_edges (empty_state e) \\<union>\n       cross_edges (empty_state e) \\<union>\n       back_edges (empty_state e)\n 2. \\<And>s s' u e.\n       \\<lbrakk>E \\<inter> dom (discovered s) \\<times> UNIV - pending s =\n                tree_edges s \\<union> cross_edges s \\<union> back_edges s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; pending s `` {u} = {}; u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> E \\<inter> dom (discovered s') \\<times> UNIV -\n                         pending s' =\n                         tree_edges s' \\<union> cross_edges s' \\<union>\n                         back_edges s'\n 3. \\<And>s s' u v e.\n       \\<lbrakk>E \\<inter> dom (discovered s) \\<times> UNIV - pending s =\n                tree_edges s \\<union> cross_edges s \\<union> back_edges s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> E \\<inter> dom (discovered s') \\<times> UNIV -\n                         pending s' =\n                         tree_edges s' \\<union> cross_edges s' \\<union>\n                         back_edges s'", "from discover stack_discovered"], ["proof (chain)\npicking this:\n  E \\<inter> dom (discovered s) \\<times> UNIV - pending s =\n  tree_edges s \\<union> cross_edges s \\<union> back_edges s\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n  \\<lparr>state.more := e_\\<rparr>\n  stack s \\<noteq> []\n  v \\<in> pending s `` {u}\n  v \\<notin> dom (discovered s)\n  u = hd (stack s)\n  set (stack s) \\<subseteq> dom (discovered s)", "have \"u \\<in> dom (discovered s)\""], ["proof (prove)\nusing this:\n  E \\<inter> dom (discovered s) \\<times> UNIV - pending s =\n  tree_edges s \\<union> cross_edges s \\<union> back_edges s\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n  \\<lparr>state.more := e_\\<rparr>\n  stack s \\<noteq> []\n  v \\<in> pending s `` {u}\n  v \\<notin> dom (discovered s)\n  u = hd (stack s)\n  set (stack s) \\<subseteq> dom (discovered s)\n\ngoal (1 subgoal):\n 1. u \\<in> dom (discovered s)", "by (cases \"stack s\") auto"], ["proof (state)\nthis:\n  u \\<in> dom (discovered s)\n\ngoal (3 subgoals):\n 1. \\<And>e.\n       E \\<inter> dom (discovered (empty_state e)) \\<times> UNIV -\n       pending (empty_state e) =\n       tree_edges (empty_state e) \\<union>\n       cross_edges (empty_state e) \\<union>\n       back_edges (empty_state e)\n 2. \\<And>s s' u e.\n       \\<lbrakk>E \\<inter> dom (discovered s) \\<times> UNIV - pending s =\n                tree_edges s \\<union> cross_edges s \\<union> back_edges s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; pending s `` {u} = {}; u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> E \\<inter> dom (discovered s') \\<times> UNIV -\n                         pending s' =\n                         tree_edges s' \\<union> cross_edges s' \\<union>\n                         back_edges s'\n 3. \\<And>s s' u v e.\n       \\<lbrakk>E \\<inter> dom (discovered s) \\<times> UNIV - pending s =\n                tree_edges s \\<union> cross_edges s \\<union> back_edges s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> E \\<inter> dom (discovered s') \\<times> UNIV -\n                         pending s' =\n                         tree_edges s' \\<union> cross_edges s' \\<union>\n                         back_edges s'", "with discover(2-) pending_ssE"], ["proof (chain)\npicking this:\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n  \\<lparr>state.more := e_\\<rparr>\n  stack s \\<noteq> []\n  v \\<in> pending s `` {u}\n  v \\<notin> dom (discovered s)\n  u = hd (stack s)\n  pending s \\<subseteq> E\n  u \\<in> dom (discovered s)", "have \n      \"E \\<inter> insert v (dom (discovered s)) \\<times> UNIV \n        - (pending s - {(hd (stack s), v)} \\<union> {v} \\<times> succ v)\n      = insert (hd (stack s), v) (E \\<inter> dom (discovered s) \\<times> UNIV - pending s)\""], ["proof (prove)\nusing this:\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n  \\<lparr>state.more := e_\\<rparr>\n  stack s \\<noteq> []\n  v \\<in> pending s `` {u}\n  v \\<notin> dom (discovered s)\n  u = hd (stack s)\n  pending s \\<subseteq> E\n  u \\<in> dom (discovered s)\n\ngoal (1 subgoal):\n 1. E \\<inter> insert v (dom (discovered s)) \\<times> UNIV -\n    (pending s - {(hd (stack s), v)} \\<union> {v} \\<times> E `` {v}) =\n    insert (hd (stack s), v)\n     (E \\<inter> dom (discovered s) \\<times> UNIV - pending s)", "by auto"], ["proof (state)\nthis:\n  E \\<inter> insert v (dom (discovered s)) \\<times> UNIV -\n  (pending s - {(hd (stack s), v)} \\<union> {v} \\<times> E `` {v}) =\n  insert (hd (stack s), v)\n   (E \\<inter> dom (discovered s) \\<times> UNIV - pending s)\n\ngoal (3 subgoals):\n 1. \\<And>e.\n       E \\<inter> dom (discovered (empty_state e)) \\<times> UNIV -\n       pending (empty_state e) =\n       tree_edges (empty_state e) \\<union>\n       cross_edges (empty_state e) \\<union>\n       back_edges (empty_state e)\n 2. \\<And>s s' u e.\n       \\<lbrakk>E \\<inter> dom (discovered s) \\<times> UNIV - pending s =\n                tree_edges s \\<union> cross_edges s \\<union> back_edges s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; pending s `` {u} = {}; u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> E \\<inter> dom (discovered s') \\<times> UNIV -\n                         pending s' =\n                         tree_edges s' \\<union> cross_edges s' \\<union>\n                         back_edges s'\n 3. \\<And>s s' u v e.\n       \\<lbrakk>E \\<inter> dom (discovered s) \\<times> UNIV - pending s =\n                tree_edges s \\<union> cross_edges s \\<union> back_edges s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> E \\<inter> dom (discovered s') \\<times> UNIV -\n                         pending s' =\n                         tree_edges s' \\<union> cross_edges s' \\<union>\n                         back_edges s'", "thus ?case"], ["proof (prove)\nusing this:\n  E \\<inter> insert v (dom (discovered s)) \\<times> UNIV -\n  (pending s - {(hd (stack s), v)} \\<union> {v} \\<times> E `` {v}) =\n  insert (hd (stack s), v)\n   (E \\<inter> dom (discovered s) \\<times> UNIV - pending s)\n\ngoal (1 subgoal):\n 1. E \\<inter> dom (discovered s') \\<times> UNIV - pending s' =\n    tree_edges s' \\<union> cross_edges s' \\<union> back_edges s'", "using discover"], ["proof (prove)\nusing this:\n  E \\<inter> insert v (dom (discovered s)) \\<times> UNIV -\n  (pending s - {(hd (stack s), v)} \\<union> {v} \\<times> E `` {v}) =\n  insert (hd (stack s), v)\n   (E \\<inter> dom (discovered s) \\<times> UNIV - pending s)\n  E \\<inter> dom (discovered s) \\<times> UNIV - pending s =\n  tree_edges s \\<union> cross_edges s \\<union> back_edges s\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n  \\<lparr>state.more := e_\\<rparr>\n  stack s \\<noteq> []\n  v \\<in> pending s `` {u}\n  v \\<notin> dom (discovered s)\n  u = hd (stack s)\n\ngoal (1 subgoal):\n 1. E \\<inter> dom (discovered s') \\<times> UNIV - pending s' =\n    tree_edges s' \\<union> cross_edges s' \\<union> back_edges s'", "by simp"], ["proof (state)\nthis:\n  E \\<inter> dom (discovered s') \\<times> UNIV - pending s' =\n  tree_edges s' \\<union> cross_edges s' \\<union> back_edges s'\n\ngoal (2 subgoals):\n 1. \\<And>e.\n       E \\<inter> dom (discovered (empty_state e)) \\<times> UNIV -\n       pending (empty_state e) =\n       tree_edges (empty_state e) \\<union>\n       cross_edges (empty_state e) \\<union>\n       back_edges (empty_state e)\n 2. \\<And>s s' u e.\n       \\<lbrakk>E \\<inter> dom (discovered s) \\<times> UNIV - pending s =\n                tree_edges s \\<union> cross_edges s \\<union> back_edges s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; pending s `` {u} = {}; u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> E \\<inter> dom (discovered s') \\<times> UNIV -\n                         pending s' =\n                         tree_edges s' \\<union> cross_edges s' \\<union>\n                         back_edges s'", "qed simp_all"], ["", "end"], ["", "context DFS_invar begin"], ["", "lemmas edges_covered = \n    i_edges_covered[THEN make_invar_thm]"], ["", "lemma edges_ss_reachable_edges:\n    \"edges s \\<subseteq> E \\<inter> reachable \\<times> UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tree_edges s \\<union> cross_edges s \\<union> back_edges s\n    \\<subseteq> E \\<inter> reachable \\<times> UNIV", "using edges_covered discovered_reachable"], ["proof (prove)\nusing this:\n  E \\<inter> dom (discovered s) \\<times> UNIV - pending s =\n  tree_edges s \\<union> cross_edges s \\<union> back_edges s\n  dom (discovered s) \\<subseteq> reachable\n\ngoal (1 subgoal):\n 1. tree_edges s \\<union> cross_edges s \\<union> back_edges s\n    \\<subseteq> E \\<inter> reachable \\<times> UNIV", "by (fast intro: rtrancl_image_advance_rtrancl)"], ["", "lemma nc_edges_covered:\n    assumes \"\\<not>cond s\" \"\\<not>is_break param s\"\n    shows \"E \\<inter> reachable \\<times> UNIV = edges s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. E \\<inter> reachable \\<times> UNIV =\n    tree_edges s \\<union> cross_edges s \\<union> back_edges s", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. E \\<inter> reachable \\<times> UNIV =\n    tree_edges s \\<union> cross_edges s \\<union> back_edges s", "from assms"], ["proof (chain)\npicking this:\n  \\<not> cond s\n  \\<not> is_break param s", "have [simp]: \"stack s = []\""], ["proof (prove)\nusing this:\n  \\<not> cond s\n  \\<not> is_break param s\n\ngoal (1 subgoal):\n 1. stack s = []", "unfolding cond_def"], ["proof (prove)\nusing this:\n  \\<not> ((V0 \\<subseteq> {v. is_discovered v s} \\<longrightarrow>\n           \\<not> is_empty_stack s) \\<and>\n          \\<not> is_break param s)\n  \\<not> is_break param s\n\ngoal (1 subgoal):\n 1. stack s = []", "by (auto simp: pred_defs)"], ["proof (state)\nthis:\n  stack s = []\n\ngoal (1 subgoal):\n 1. E \\<inter> reachable \\<times> UNIV =\n    tree_edges s \\<union> cross_edges s \\<union> back_edges s", "hence [simp]: \"pending s = {}\""], ["proof (prove)\nusing this:\n  stack s = []\n\ngoal (1 subgoal):\n 1. pending s = {}", "by (rule empty_stack_imp_empty_pending)"], ["proof (state)\nthis:\n  pending s = {}\n\ngoal (1 subgoal):\n 1. E \\<inter> reachable \\<times> UNIV =\n    tree_edges s \\<union> cross_edges s \\<union> back_edges s", "from edges_covered nc_discovered_eq_reachable[OF assms]"], ["proof (chain)\npicking this:\n  E \\<inter> dom (discovered s) \\<times> UNIV - pending s =\n  tree_edges s \\<union> cross_edges s \\<union> back_edges s\n  dom (discovered s) = reachable", "show ?thesis"], ["proof (prove)\nusing this:\n  E \\<inter> dom (discovered s) \\<times> UNIV - pending s =\n  tree_edges s \\<union> cross_edges s \\<union> back_edges s\n  dom (discovered s) = reachable\n\ngoal (1 subgoal):\n 1. E \\<inter> reachable \\<times> UNIV =\n    tree_edges s \\<union> cross_edges s \\<union> back_edges s", "by simp"], ["proof (state)\nthis:\n  E \\<inter> reachable \\<times> UNIV =\n  tree_edges s \\<union> cross_edges s \\<union> back_edges s\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma \n    tree_edges_ssE: \"tree_edges s \\<subseteq> E\" and\n    tree_edges_not_pending: \"tree_edges s \\<subseteq> - pending s\" and\n    tree_edge_is_succ: \"(v,w) \\<in> tree_edges s \\<Longrightarrow> w \\<in> succ v\" and\n    tree_edges_discovered: \"Field (tree_edges s) \\<subseteq> dom (discovered s)\" and\n\n    cross_edges_ssE: \"cross_edges s \\<subseteq> E\" and\n    cross_edges_not_pending: \"cross_edges s \\<subseteq> - pending s\" and\n    cross_edge_is_succ: \"(v,w) \\<in> cross_edges s \\<Longrightarrow> w \\<in> succ v\" and\n    cross_edges_discovered: \"Field (cross_edges s) \\<subseteq> dom (discovered s)\" and\n\n    back_edges_ssE: \"back_edges s \\<subseteq> E\" and\n    back_edges_not_pending: \"back_edges s \\<subseteq> - pending s\" and\n    back_edge_is_succ: \"(v,w) \\<in> back_edges s \\<Longrightarrow> w \\<in> succ v\" and\n    back_edges_discovered: \"Field (back_edges s) \\<subseteq> dom (discovered s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((tree_edges s \\<subseteq> E &&&\n      tree_edges s \\<subseteq> - pending s &&&\n      ((v, w) \\<in> tree_edges s \\<Longrightarrow> w \\<in> E `` {v})) &&&\n     Field (tree_edges s) \\<subseteq> dom (discovered s) &&&\n     cross_edges s \\<subseteq> E &&&\n     cross_edges s \\<subseteq> - pending s) &&&\n    (((v, w) \\<in> cross_edges s \\<Longrightarrow> w \\<in> E `` {v}) &&&\n     Field (cross_edges s) \\<subseteq> dom (discovered s) &&&\n     back_edges s \\<subseteq> E) &&&\n    back_edges s \\<subseteq> - pending s &&&\n    ((v, w) \\<in> back_edges s \\<Longrightarrow> w \\<in> E `` {v}) &&&\n    Field (back_edges s) \\<subseteq> dom (discovered s)", "using edges_basic"], ["proof (prove)\nusing this:\n  edges_basic s\n\ngoal (1 subgoal):\n 1. ((tree_edges s \\<subseteq> E &&&\n      tree_edges s \\<subseteq> - pending s &&&\n      ((v, w) \\<in> tree_edges s \\<Longrightarrow> w \\<in> E `` {v})) &&&\n     Field (tree_edges s) \\<subseteq> dom (discovered s) &&&\n     cross_edges s \\<subseteq> E &&&\n     cross_edges s \\<subseteq> - pending s) &&&\n    (((v, w) \\<in> cross_edges s \\<Longrightarrow> w \\<in> E `` {v}) &&&\n     Field (cross_edges s) \\<subseteq> dom (discovered s) &&&\n     back_edges s \\<subseteq> E) &&&\n    back_edges s \\<subseteq> - pending s &&&\n    ((v, w) \\<in> back_edges s \\<Longrightarrow> w \\<in> E `` {v}) &&&\n    Field (back_edges s) \\<subseteq> dom (discovered s)", "unfolding edges_basic_def"], ["proof (prove)\nusing this:\n  Field (back_edges s) \\<subseteq> dom (discovered s) \\<and>\n  back_edges s \\<subseteq> E - pending s \\<and>\n  Field (cross_edges s) \\<subseteq> dom (discovered s) \\<and>\n  cross_edges s \\<subseteq> E - pending s \\<and>\n  Field (tree_edges s) \\<subseteq> dom (discovered s) \\<and>\n  tree_edges s \\<subseteq> E - pending s \\<and>\n  back_edges s \\<inter> cross_edges s = {} \\<and>\n  back_edges s \\<inter> tree_edges s = {} \\<and>\n  cross_edges s \\<inter> tree_edges s = {}\n\ngoal (1 subgoal):\n 1. ((tree_edges s \\<subseteq> E &&&\n      tree_edges s \\<subseteq> - pending s &&&\n      ((v, w) \\<in> tree_edges s \\<Longrightarrow> w \\<in> E `` {v})) &&&\n     Field (tree_edges s) \\<subseteq> dom (discovered s) &&&\n     cross_edges s \\<subseteq> E &&&\n     cross_edges s \\<subseteq> - pending s) &&&\n    (((v, w) \\<in> cross_edges s \\<Longrightarrow> w \\<in> E `` {v}) &&&\n     Field (cross_edges s) \\<subseteq> dom (discovered s) &&&\n     back_edges s \\<subseteq> E) &&&\n    back_edges s \\<subseteq> - pending s &&&\n    ((v, w) \\<in> back_edges s \\<Longrightarrow> w \\<in> E `` {v}) &&&\n    Field (back_edges s) \\<subseteq> dom (discovered s)", "by auto"], ["", "lemma edges_disjoint: \n   \"back_edges s \\<inter> cross_edges s = {}\"\n   \"back_edges s \\<inter> tree_edges s = {}\"\n   \"cross_edges s \\<inter> tree_edges s = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. back_edges s \\<inter> cross_edges s = {} &&&\n    back_edges s \\<inter> tree_edges s = {} &&&\n    cross_edges s \\<inter> tree_edges s = {}", "using edges_basic"], ["proof (prove)\nusing this:\n  edges_basic s\n\ngoal (1 subgoal):\n 1. back_edges s \\<inter> cross_edges s = {} &&&\n    back_edges s \\<inter> tree_edges s = {} &&&\n    cross_edges s \\<inter> tree_edges s = {}", "unfolding edges_basic_def"], ["proof (prove)\nusing this:\n  Field (back_edges s) \\<subseteq> dom (discovered s) \\<and>\n  back_edges s \\<subseteq> E - pending s \\<and>\n  Field (cross_edges s) \\<subseteq> dom (discovered s) \\<and>\n  cross_edges s \\<subseteq> E - pending s \\<and>\n  Field (tree_edges s) \\<subseteq> dom (discovered s) \\<and>\n  tree_edges s \\<subseteq> E - pending s \\<and>\n  back_edges s \\<inter> cross_edges s = {} \\<and>\n  back_edges s \\<inter> tree_edges s = {} \\<and>\n  cross_edges s \\<inter> tree_edges s = {}\n\ngoal (1 subgoal):\n 1. back_edges s \\<inter> cross_edges s = {} &&&\n    back_edges s \\<inter> tree_edges s = {} &&&\n    cross_edges s \\<inter> tree_edges s = {}", "by auto"], ["", "lemma tree_edge_imp_discovered:\n    \"(v,w) \\<in> tree_edges s \\<Longrightarrow> v \\<in> dom (discovered s)\"\n    \"(v,w) \\<in> tree_edges s \\<Longrightarrow> w \\<in> dom (discovered s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((v, w) \\<in> tree_edges s \\<Longrightarrow>\n     v \\<in> dom (discovered s)) &&&\n    ((v, w) \\<in> tree_edges s \\<Longrightarrow> w \\<in> dom (discovered s))", "using tree_edges_discovered"], ["proof (prove)\nusing this:\n  Field (tree_edges s) \\<subseteq> dom (discovered s)\n\ngoal (1 subgoal):\n 1. ((v, w) \\<in> tree_edges s \\<Longrightarrow>\n     v \\<in> dom (discovered s)) &&&\n    ((v, w) \\<in> tree_edges s \\<Longrightarrow> w \\<in> dom (discovered s))", "by (auto simp add: Field_def)"], ["", "lemma back_edge_imp_discovered:\n    \"(v,w) \\<in> back_edges s \\<Longrightarrow> v \\<in> dom (discovered s)\"\n    \"(v,w) \\<in> back_edges s \\<Longrightarrow> w \\<in> dom (discovered s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((v, w) \\<in> back_edges s \\<Longrightarrow>\n     v \\<in> dom (discovered s)) &&&\n    ((v, w) \\<in> back_edges s \\<Longrightarrow> w \\<in> dom (discovered s))", "using back_edges_discovered"], ["proof (prove)\nusing this:\n  Field (back_edges s) \\<subseteq> dom (discovered s)\n\ngoal (1 subgoal):\n 1. ((v, w) \\<in> back_edges s \\<Longrightarrow>\n     v \\<in> dom (discovered s)) &&&\n    ((v, w) \\<in> back_edges s \\<Longrightarrow> w \\<in> dom (discovered s))", "by (auto simp add: Field_def)"], ["", "lemma cross_edge_imp_discovered:\n    \"(v,w) \\<in> cross_edges s \\<Longrightarrow> v \\<in> dom (discovered s)\"\n    \"(v,w) \\<in> cross_edges s \\<Longrightarrow> w \\<in> dom (discovered s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((v, w) \\<in> cross_edges s \\<Longrightarrow>\n     v \\<in> dom (discovered s)) &&&\n    ((v, w) \\<in> cross_edges s \\<Longrightarrow>\n     w \\<in> dom (discovered s))", "using cross_edges_discovered"], ["proof (prove)\nusing this:\n  Field (cross_edges s) \\<subseteq> dom (discovered s)\n\ngoal (1 subgoal):\n 1. ((v, w) \\<in> cross_edges s \\<Longrightarrow>\n     v \\<in> dom (discovered s)) &&&\n    ((v, w) \\<in> cross_edges s \\<Longrightarrow>\n     w \\<in> dom (discovered s))", "by (auto simp add: Field_def)"], ["", "lemma edge_imp_discovered:\n    \"(v,w) \\<in> edges s \\<Longrightarrow> v \\<in> dom (discovered s)\"\n    \"(v,w) \\<in> edges s \\<Longrightarrow> w \\<in> dom (discovered s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((v, w)\n     \\<in> tree_edges s \\<union> cross_edges s \\<union>\n           back_edges s \\<Longrightarrow>\n     v \\<in> dom (discovered s)) &&&\n    ((v, w)\n     \\<in> tree_edges s \\<union> cross_edges s \\<union>\n           back_edges s \\<Longrightarrow>\n     w \\<in> dom (discovered s))", "using tree_edge_imp_discovered cross_edge_imp_discovered back_edge_imp_discovered"], ["proof (prove)\nusing this:\n  (?v, ?w) \\<in> tree_edges s \\<Longrightarrow> ?v \\<in> dom (discovered s)\n  (?v, ?w) \\<in> tree_edges s \\<Longrightarrow> ?w \\<in> dom (discovered s)\n  (?v, ?w) \\<in> cross_edges s \\<Longrightarrow> ?v \\<in> dom (discovered s)\n  (?v, ?w) \\<in> cross_edges s \\<Longrightarrow> ?w \\<in> dom (discovered s)\n  (?v, ?w) \\<in> back_edges s \\<Longrightarrow> ?v \\<in> dom (discovered s)\n  (?v, ?w) \\<in> back_edges s \\<Longrightarrow> ?w \\<in> dom (discovered s)\n\ngoal (1 subgoal):\n 1. ((v, w)\n     \\<in> tree_edges s \\<union> cross_edges s \\<union>\n           back_edges s \\<Longrightarrow>\n     v \\<in> dom (discovered s)) &&&\n    ((v, w)\n     \\<in> tree_edges s \\<union> cross_edges s \\<union>\n           back_edges s \\<Longrightarrow>\n     w \\<in> dom (discovered s))", "by blast+"], ["", "lemma tree_edges_finite[simp, intro!]: \"finite (tree_edges s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (tree_edges s)", "using finite_subset[OF tree_edges_discovered discovered_finite]"], ["proof (prove)\nusing this:\n  finite (Field (tree_edges s))\n\ngoal (1 subgoal):\n 1. finite (tree_edges s)", "by simp"], ["", "lemma cross_edges_finite[simp, intro!]: \"finite (cross_edges s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (cross_edges s)", "using finite_subset[OF cross_edges_discovered discovered_finite]"], ["proof (prove)\nusing this:\n  finite (Field (cross_edges s))\n\ngoal (1 subgoal):\n 1. finite (cross_edges s)", "by simp"], ["", "lemma back_edges_finite[simp, intro!]: \"finite (back_edges s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (back_edges s)", "using finite_subset[OF back_edges_discovered discovered_finite]"], ["proof (prove)\nusing this:\n  finite (Field (back_edges s))\n\ngoal (1 subgoal):\n 1. finite (back_edges s)", "by simp"], ["", "lemma edges_finite: \"finite (edges s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (tree_edges s \\<union> cross_edges s \\<union> back_edges s)", "by auto"], ["", "end"], ["", "subsubsection \\<open>Properties of the DFS Tree\\<close>"], ["", "(* Tree *)"], ["", "context DFS_invar begin"], ["", "context begin"], ["", "interpretation timing_syntax"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma tree_edge_disc_lt_fin:\n    \"(v,w) \\<in> tree_edges s \\<Longrightarrow> v \\<in> dom (finished s) \\<Longrightarrow> \\<delta> s w < \\<phi> s v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(v, w) \\<in> tree_edges s; v \\<in> dom (finished s)\\<rbrakk>\n    \\<Longrightarrow> \\<delta> s w < \\<phi> s v", "by (metis finished_succ_fin tree_edge_is_succ)"], ["", "lemma back_edge_disc_lt_fin:\n    \"(v,w) \\<in> back_edges s \\<Longrightarrow> v \\<in> dom (finished s) \\<Longrightarrow> \\<delta> s w < \\<phi> s v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(v, w) \\<in> back_edges s; v \\<in> dom (finished s)\\<rbrakk>\n    \\<Longrightarrow> \\<delta> s w < \\<phi> s v", "by (metis finished_succ_fin back_edge_is_succ)"], ["", "lemma cross_edge_disc_lt_fin:\n    \"(v,w) \\<in> cross_edges s \\<Longrightarrow> v \\<in> dom (finished s) \\<Longrightarrow> \\<delta> s w < \\<phi> s v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(v, w) \\<in> cross_edges s; v \\<in> dom (finished s)\\<rbrakk>\n    \\<Longrightarrow> \\<delta> s w < \\<phi> s v", "by (metis finished_succ_fin cross_edge_is_succ)"], ["", "end"], ["", "end"], ["", "(* Stack & Tree *)"], ["", "context param_DFS begin"], ["", "lemma i_stack_is_tree_path:\n    \"is_invar (\\<lambda>s. stack s \\<noteq> [] \\<longrightarrow> (\\<exists>v0 \\<in> V0. \n        path (tree_edges s) v0 (rev (tl (stack s))) (hd (stack s))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_invar\n     (\\<lambda>s.\n         stack s \\<noteq> [] \\<longrightarrow>\n         (\\<exists>v0\\<in>V0.\n             path (tree_edges s) v0 (rev (tl (stack s))) (hd (stack s))))", "proof (induct rule: is_invarI)"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>e.\n       stack (empty_state e) \\<noteq> [] \\<longrightarrow>\n       (\\<exists>v0\\<in>V0.\n           path (tree_edges (empty_state e)) v0\n            (rev (tl (stack (empty_state e)))) (hd (stack (empty_state e))))\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>stack s \\<noteq> [] \\<longrightarrow>\n                (\\<exists>v0\\<in>V0.\n                    path (tree_edges s) v0 (rev (tl (stack s)))\n                     (hd (stack s)));\n        cond s; DFS_invar G param s; DFS_invar G param s'; stack s = [];\n        v0 \\<notin> dom (discovered s); v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> stack s' \\<noteq> [] \\<longrightarrow>\n                         (\\<exists>v0\\<in>V0.\n                             path (tree_edges s') v0 (rev (tl (stack s')))\n                              (hd (stack s')))\n 3. \\<And>s s' u e.\n       \\<lbrakk>stack s \\<noteq> [] \\<longrightarrow>\n                (\\<exists>v0\\<in>V0.\n                    path (tree_edges s) v0 (rev (tl (stack s)))\n                     (hd (stack s)));\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; pending s `` {u} = {}; u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> stack s' \\<noteq> [] \\<longrightarrow>\n                         (\\<exists>v0\\<in>V0.\n                             path (tree_edges s') v0 (rev (tl (stack s')))\n                              (hd (stack s')))\n 4. \\<And>s s' u v e c b.\n       \\<lbrakk>stack s \\<noteq> [] \\<longrightarrow>\n                (\\<exists>v0\\<in>V0.\n                    path (tree_edges s) v0 (rev (tl (stack s)))\n                     (hd (stack s)));\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); u = hd (stack s);\n        cross_edges s \\<subseteq> c; back_edges s \\<subseteq> b;\n        s' = s\n        \\<lparr>pending := pending s - {(u, v)}, state.more := e,\n           cross_edges := c, back_edges := b\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> stack s' \\<noteq> [] \\<longrightarrow>\n                         (\\<exists>v0\\<in>V0.\n                             path (tree_edges s') v0 (rev (tl (stack s')))\n                              (hd (stack s')))\n 5. \\<And>s s' u v e.\n       \\<lbrakk>stack s \\<noteq> [] \\<longrightarrow>\n                (\\<exists>v0\\<in>V0.\n                    path (tree_edges s) v0 (rev (tl (stack s)))\n                     (hd (stack s)));\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> stack s' \\<noteq> [] \\<longrightarrow>\n                         (\\<exists>v0\\<in>V0.\n                             path (tree_edges s') v0 (rev (tl (stack s')))\n                              (hd (stack s')))", "case (discover s s' u v)"], ["proof (state)\nthis:\n  stack s \\<noteq> [] \\<longrightarrow>\n  (\\<exists>v0\\<in>V0.\n      path (tree_edges s) v0 (rev (tl (stack s))) (hd (stack s)))\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s \\<noteq> []\n  v \\<in> pending s `` {u}\n  v \\<notin> dom (discovered s)\n  u = hd (stack s)\n  s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n  \\<lparr>state.more := e_\\<rparr>\n\ngoal (5 subgoals):\n 1. \\<And>e.\n       stack (empty_state e) \\<noteq> [] \\<longrightarrow>\n       (\\<exists>v0\\<in>V0.\n           path (tree_edges (empty_state e)) v0\n            (rev (tl (stack (empty_state e)))) (hd (stack (empty_state e))))\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>stack s \\<noteq> [] \\<longrightarrow>\n                (\\<exists>v0\\<in>V0.\n                    path (tree_edges s) v0 (rev (tl (stack s)))\n                     (hd (stack s)));\n        cond s; DFS_invar G param s; DFS_invar G param s'; stack s = [];\n        v0 \\<notin> dom (discovered s); v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> stack s' \\<noteq> [] \\<longrightarrow>\n                         (\\<exists>v0\\<in>V0.\n                             path (tree_edges s') v0 (rev (tl (stack s')))\n                              (hd (stack s')))\n 3. \\<And>s s' u e.\n       \\<lbrakk>stack s \\<noteq> [] \\<longrightarrow>\n                (\\<exists>v0\\<in>V0.\n                    path (tree_edges s) v0 (rev (tl (stack s)))\n                     (hd (stack s)));\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; pending s `` {u} = {}; u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> stack s' \\<noteq> [] \\<longrightarrow>\n                         (\\<exists>v0\\<in>V0.\n                             path (tree_edges s') v0 (rev (tl (stack s')))\n                              (hd (stack s')))\n 4. \\<And>s s' u v e c b.\n       \\<lbrakk>stack s \\<noteq> [] \\<longrightarrow>\n                (\\<exists>v0\\<in>V0.\n                    path (tree_edges s) v0 (rev (tl (stack s)))\n                     (hd (stack s)));\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); u = hd (stack s);\n        cross_edges s \\<subseteq> c; back_edges s \\<subseteq> b;\n        s' = s\n        \\<lparr>pending := pending s - {(u, v)}, state.more := e,\n           cross_edges := c, back_edges := b\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> stack s' \\<noteq> [] \\<longrightarrow>\n                         (\\<exists>v0\\<in>V0.\n                             path (tree_edges s') v0 (rev (tl (stack s')))\n                              (hd (stack s')))\n 5. \\<And>s s' u v e.\n       \\<lbrakk>stack s \\<noteq> [] \\<longrightarrow>\n                (\\<exists>v0\\<in>V0.\n                    path (tree_edges s) v0 (rev (tl (stack s)))\n                     (hd (stack s)));\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> stack s' \\<noteq> [] \\<longrightarrow>\n                         (\\<exists>v0\\<in>V0.\n                             path (tree_edges s') v0 (rev (tl (stack s')))\n                              (hd (stack s')))", "hence EQ[simp]: \"stack s' = v # stack s\"\n                    \"tree_edges s' = insert (hd (stack s), v) (tree_edges s)\""], ["proof (prove)\nusing this:\n  stack s \\<noteq> [] \\<longrightarrow>\n  (\\<exists>v0\\<in>V0.\n      path (tree_edges s) v0 (rev (tl (stack s))) (hd (stack s)))\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s \\<noteq> []\n  v \\<in> pending s `` {u}\n  v \\<notin> dom (discovered s)\n  u = hd (stack s)\n  s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n  \\<lparr>state.more := e_\\<rparr>\n\ngoal (1 subgoal):\n 1. stack s' = v # stack s &&&\n    tree_edges s' = insert (hd (stack s), v) (tree_edges s)", "by simp_all"], ["proof (state)\nthis:\n  stack s' = v # stack s\n  tree_edges s' = insert (hd (stack s), v) (tree_edges s)\n\ngoal (5 subgoals):\n 1. \\<And>e.\n       stack (empty_state e) \\<noteq> [] \\<longrightarrow>\n       (\\<exists>v0\\<in>V0.\n           path (tree_edges (empty_state e)) v0\n            (rev (tl (stack (empty_state e)))) (hd (stack (empty_state e))))\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>stack s \\<noteq> [] \\<longrightarrow>\n                (\\<exists>v0\\<in>V0.\n                    path (tree_edges s) v0 (rev (tl (stack s)))\n                     (hd (stack s)));\n        cond s; DFS_invar G param s; DFS_invar G param s'; stack s = [];\n        v0 \\<notin> dom (discovered s); v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> stack s' \\<noteq> [] \\<longrightarrow>\n                         (\\<exists>v0\\<in>V0.\n                             path (tree_edges s') v0 (rev (tl (stack s')))\n                              (hd (stack s')))\n 3. \\<And>s s' u e.\n       \\<lbrakk>stack s \\<noteq> [] \\<longrightarrow>\n                (\\<exists>v0\\<in>V0.\n                    path (tree_edges s) v0 (rev (tl (stack s)))\n                     (hd (stack s)));\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; pending s `` {u} = {}; u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> stack s' \\<noteq> [] \\<longrightarrow>\n                         (\\<exists>v0\\<in>V0.\n                             path (tree_edges s') v0 (rev (tl (stack s')))\n                              (hd (stack s')))\n 4. \\<And>s s' u v e c b.\n       \\<lbrakk>stack s \\<noteq> [] \\<longrightarrow>\n                (\\<exists>v0\\<in>V0.\n                    path (tree_edges s) v0 (rev (tl (stack s)))\n                     (hd (stack s)));\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); u = hd (stack s);\n        cross_edges s \\<subseteq> c; back_edges s \\<subseteq> b;\n        s' = s\n        \\<lparr>pending := pending s - {(u, v)}, state.more := e,\n           cross_edges := c, back_edges := b\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> stack s' \\<noteq> [] \\<longrightarrow>\n                         (\\<exists>v0\\<in>V0.\n                             path (tree_edges s') v0 (rev (tl (stack s')))\n                              (hd (stack s')))\n 5. \\<And>s s' u v e.\n       \\<lbrakk>stack s \\<noteq> [] \\<longrightarrow>\n                (\\<exists>v0\\<in>V0.\n                    path (tree_edges s) v0 (rev (tl (stack s)))\n                     (hd (stack s)));\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> stack s' \\<noteq> [] \\<longrightarrow>\n                         (\\<exists>v0\\<in>V0.\n                             path (tree_edges s') v0 (rev (tl (stack s')))\n                              (hd (stack s')))", "from discover"], ["proof (chain)\npicking this:\n  stack s \\<noteq> [] \\<longrightarrow>\n  (\\<exists>v0\\<in>V0.\n      path (tree_edges s) v0 (rev (tl (stack s))) (hd (stack s)))\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s \\<noteq> []\n  v \\<in> pending s `` {u}\n  v \\<notin> dom (discovered s)\n  u = hd (stack s)\n  s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n  \\<lparr>state.more := e_\\<rparr>", "have NE[simp]: \"stack s \\<noteq> []\""], ["proof (prove)\nusing this:\n  stack s \\<noteq> [] \\<longrightarrow>\n  (\\<exists>v0\\<in>V0.\n      path (tree_edges s) v0 (rev (tl (stack s))) (hd (stack s)))\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s \\<noteq> []\n  v \\<in> pending s `` {u}\n  v \\<notin> dom (discovered s)\n  u = hd (stack s)\n  s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n  \\<lparr>state.more := e_\\<rparr>\n\ngoal (1 subgoal):\n 1. stack s \\<noteq> []", "by simp"], ["proof (state)\nthis:\n  stack s \\<noteq> []\n\ngoal (5 subgoals):\n 1. \\<And>e.\n       stack (empty_state e) \\<noteq> [] \\<longrightarrow>\n       (\\<exists>v0\\<in>V0.\n           path (tree_edges (empty_state e)) v0\n            (rev (tl (stack (empty_state e)))) (hd (stack (empty_state e))))\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>stack s \\<noteq> [] \\<longrightarrow>\n                (\\<exists>v0\\<in>V0.\n                    path (tree_edges s) v0 (rev (tl (stack s)))\n                     (hd (stack s)));\n        cond s; DFS_invar G param s; DFS_invar G param s'; stack s = [];\n        v0 \\<notin> dom (discovered s); v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> stack s' \\<noteq> [] \\<longrightarrow>\n                         (\\<exists>v0\\<in>V0.\n                             path (tree_edges s') v0 (rev (tl (stack s')))\n                              (hd (stack s')))\n 3. \\<And>s s' u e.\n       \\<lbrakk>stack s \\<noteq> [] \\<longrightarrow>\n                (\\<exists>v0\\<in>V0.\n                    path (tree_edges s) v0 (rev (tl (stack s)))\n                     (hd (stack s)));\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; pending s `` {u} = {}; u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> stack s' \\<noteq> [] \\<longrightarrow>\n                         (\\<exists>v0\\<in>V0.\n                             path (tree_edges s') v0 (rev (tl (stack s')))\n                              (hd (stack s')))\n 4. \\<And>s s' u v e c b.\n       \\<lbrakk>stack s \\<noteq> [] \\<longrightarrow>\n                (\\<exists>v0\\<in>V0.\n                    path (tree_edges s) v0 (rev (tl (stack s)))\n                     (hd (stack s)));\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); u = hd (stack s);\n        cross_edges s \\<subseteq> c; back_edges s \\<subseteq> b;\n        s' = s\n        \\<lparr>pending := pending s - {(u, v)}, state.more := e,\n           cross_edges := c, back_edges := b\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> stack s' \\<noteq> [] \\<longrightarrow>\n                         (\\<exists>v0\\<in>V0.\n                             path (tree_edges s') v0 (rev (tl (stack s')))\n                              (hd (stack s')))\n 5. \\<And>s s' u v e.\n       \\<lbrakk>stack s \\<noteq> [] \\<longrightarrow>\n                (\\<exists>v0\\<in>V0.\n                    path (tree_edges s) v0 (rev (tl (stack s)))\n                     (hd (stack s)));\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> stack s' \\<noteq> [] \\<longrightarrow>\n                         (\\<exists>v0\\<in>V0.\n                             path (tree_edges s') v0 (rev (tl (stack s')))\n                              (hd (stack s')))", "from discover"], ["proof (chain)\npicking this:\n  stack s \\<noteq> [] \\<longrightarrow>\n  (\\<exists>v0\\<in>V0.\n      path (tree_edges s) v0 (rev (tl (stack s))) (hd (stack s)))\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s \\<noteq> []\n  v \\<in> pending s `` {u}\n  v \\<notin> dom (discovered s)\n  u = hd (stack s)\n  s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n  \\<lparr>state.more := e_\\<rparr>", "obtain v0 where \n      \"v0 \\<in> V0\"\n      \"path (tree_edges s) v0 (rev (tl (stack s))) (hd (stack s))\""], ["proof (prove)\nusing this:\n  stack s \\<noteq> [] \\<longrightarrow>\n  (\\<exists>v0\\<in>V0.\n      path (tree_edges s) v0 (rev (tl (stack s))) (hd (stack s)))\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s \\<noteq> []\n  v \\<in> pending s `` {u}\n  v \\<notin> dom (discovered s)\n  u = hd (stack s)\n  s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n  \\<lparr>state.more := e_\\<rparr>\n\ngoal (1 subgoal):\n 1. (\\<And>v0.\n        \\<lbrakk>v0 \\<in> V0;\n         path (tree_edges s) v0 (rev (tl (stack s))) (hd (stack s))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  v0 \\<in> V0\n  path (tree_edges s) v0 (rev (tl (stack s))) (hd (stack s))\n\ngoal (5 subgoals):\n 1. \\<And>e.\n       stack (empty_state e) \\<noteq> [] \\<longrightarrow>\n       (\\<exists>v0\\<in>V0.\n           path (tree_edges (empty_state e)) v0\n            (rev (tl (stack (empty_state e)))) (hd (stack (empty_state e))))\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>stack s \\<noteq> [] \\<longrightarrow>\n                (\\<exists>v0\\<in>V0.\n                    path (tree_edges s) v0 (rev (tl (stack s)))\n                     (hd (stack s)));\n        cond s; DFS_invar G param s; DFS_invar G param s'; stack s = [];\n        v0 \\<notin> dom (discovered s); v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> stack s' \\<noteq> [] \\<longrightarrow>\n                         (\\<exists>v0\\<in>V0.\n                             path (tree_edges s') v0 (rev (tl (stack s')))\n                              (hd (stack s')))\n 3. \\<And>s s' u e.\n       \\<lbrakk>stack s \\<noteq> [] \\<longrightarrow>\n                (\\<exists>v0\\<in>V0.\n                    path (tree_edges s) v0 (rev (tl (stack s)))\n                     (hd (stack s)));\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; pending s `` {u} = {}; u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> stack s' \\<noteq> [] \\<longrightarrow>\n                         (\\<exists>v0\\<in>V0.\n                             path (tree_edges s') v0 (rev (tl (stack s')))\n                              (hd (stack s')))\n 4. \\<And>s s' u v e c b.\n       \\<lbrakk>stack s \\<noteq> [] \\<longrightarrow>\n                (\\<exists>v0\\<in>V0.\n                    path (tree_edges s) v0 (rev (tl (stack s)))\n                     (hd (stack s)));\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); u = hd (stack s);\n        cross_edges s \\<subseteq> c; back_edges s \\<subseteq> b;\n        s' = s\n        \\<lparr>pending := pending s - {(u, v)}, state.more := e,\n           cross_edges := c, back_edges := b\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> stack s' \\<noteq> [] \\<longrightarrow>\n                         (\\<exists>v0\\<in>V0.\n                             path (tree_edges s') v0 (rev (tl (stack s')))\n                              (hd (stack s')))\n 5. \\<And>s s' u v e.\n       \\<lbrakk>stack s \\<noteq> [] \\<longrightarrow>\n                (\\<exists>v0\\<in>V0.\n                    path (tree_edges s) v0 (rev (tl (stack s)))\n                     (hd (stack s)));\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> stack s' \\<noteq> [] \\<longrightarrow>\n                         (\\<exists>v0\\<in>V0.\n                             path (tree_edges s') v0 (rev (tl (stack s')))\n                              (hd (stack s')))", "with path_mono[OF _ this(2)] EQ"], ["proof (chain)\npicking this:\n  tree_edges s \\<subseteq> ?E' \\<Longrightarrow>\n  path ?E' v0 (rev (tl (stack s))) (hd (stack s))\n  stack s' = v # stack s\n  tree_edges s' = insert (hd (stack s), v) (tree_edges s)\n  v0 \\<in> V0\n  path (tree_edges s) v0 (rev (tl (stack s))) (hd (stack s))", "have \n      \"path (tree_edges s') v0 (rev (tl (stack s))) (hd (stack s))\""], ["proof (prove)\nusing this:\n  tree_edges s \\<subseteq> ?E' \\<Longrightarrow>\n  path ?E' v0 (rev (tl (stack s))) (hd (stack s))\n  stack s' = v # stack s\n  tree_edges s' = insert (hd (stack s), v) (tree_edges s)\n  v0 \\<in> V0\n  path (tree_edges s) v0 (rev (tl (stack s))) (hd (stack s))\n\ngoal (1 subgoal):\n 1. path (tree_edges s') v0 (rev (tl (stack s))) (hd (stack s))", "by blast"], ["proof (state)\nthis:\n  path (tree_edges s') v0 (rev (tl (stack s))) (hd (stack s))\n\ngoal (5 subgoals):\n 1. \\<And>e.\n       stack (empty_state e) \\<noteq> [] \\<longrightarrow>\n       (\\<exists>v0\\<in>V0.\n           path (tree_edges (empty_state e)) v0\n            (rev (tl (stack (empty_state e)))) (hd (stack (empty_state e))))\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>stack s \\<noteq> [] \\<longrightarrow>\n                (\\<exists>v0\\<in>V0.\n                    path (tree_edges s) v0 (rev (tl (stack s)))\n                     (hd (stack s)));\n        cond s; DFS_invar G param s; DFS_invar G param s'; stack s = [];\n        v0 \\<notin> dom (discovered s); v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> stack s' \\<noteq> [] \\<longrightarrow>\n                         (\\<exists>v0\\<in>V0.\n                             path (tree_edges s') v0 (rev (tl (stack s')))\n                              (hd (stack s')))\n 3. \\<And>s s' u e.\n       \\<lbrakk>stack s \\<noteq> [] \\<longrightarrow>\n                (\\<exists>v0\\<in>V0.\n                    path (tree_edges s) v0 (rev (tl (stack s)))\n                     (hd (stack s)));\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; pending s `` {u} = {}; u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> stack s' \\<noteq> [] \\<longrightarrow>\n                         (\\<exists>v0\\<in>V0.\n                             path (tree_edges s') v0 (rev (tl (stack s')))\n                              (hd (stack s')))\n 4. \\<And>s s' u v e c b.\n       \\<lbrakk>stack s \\<noteq> [] \\<longrightarrow>\n                (\\<exists>v0\\<in>V0.\n                    path (tree_edges s) v0 (rev (tl (stack s)))\n                     (hd (stack s)));\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); u = hd (stack s);\n        cross_edges s \\<subseteq> c; back_edges s \\<subseteq> b;\n        s' = s\n        \\<lparr>pending := pending s - {(u, v)}, state.more := e,\n           cross_edges := c, back_edges := b\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> stack s' \\<noteq> [] \\<longrightarrow>\n                         (\\<exists>v0\\<in>V0.\n                             path (tree_edges s') v0 (rev (tl (stack s')))\n                              (hd (stack s')))\n 5. \\<And>s s' u v e.\n       \\<lbrakk>stack s \\<noteq> [] \\<longrightarrow>\n                (\\<exists>v0\\<in>V0.\n                    path (tree_edges s) v0 (rev (tl (stack s)))\n                     (hd (stack s)));\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> stack s' \\<noteq> [] \\<longrightarrow>\n                         (\\<exists>v0\\<in>V0.\n                             path (tree_edges s') v0 (rev (tl (stack s')))\n                              (hd (stack s')))", "with \\<open>v0 \\<in> V0\\<close>"], ["proof (chain)\npicking this:\n  v0 \\<in> V0\n  path (tree_edges s') v0 (rev (tl (stack s))) (hd (stack s))", "show ?case"], ["proof (prove)\nusing this:\n  v0 \\<in> V0\n  path (tree_edges s') v0 (rev (tl (stack s))) (hd (stack s))\n\ngoal (1 subgoal):\n 1. stack s' \\<noteq> [] \\<longrightarrow>\n    (\\<exists>v0\\<in>V0.\n        path (tree_edges s') v0 (rev (tl (stack s'))) (hd (stack s')))", "by (cases \"stack s\") (auto simp: path_simps)"], ["proof (state)\nthis:\n  stack s' \\<noteq> [] \\<longrightarrow>\n  (\\<exists>v0\\<in>V0.\n      path (tree_edges s') v0 (rev (tl (stack s'))) (hd (stack s')))\n\ngoal (4 subgoals):\n 1. \\<And>e.\n       stack (empty_state e) \\<noteq> [] \\<longrightarrow>\n       (\\<exists>v0\\<in>V0.\n           path (tree_edges (empty_state e)) v0\n            (rev (tl (stack (empty_state e)))) (hd (stack (empty_state e))))\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>stack s \\<noteq> [] \\<longrightarrow>\n                (\\<exists>v0\\<in>V0.\n                    path (tree_edges s) v0 (rev (tl (stack s)))\n                     (hd (stack s)));\n        cond s; DFS_invar G param s; DFS_invar G param s'; stack s = [];\n        v0 \\<notin> dom (discovered s); v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> stack s' \\<noteq> [] \\<longrightarrow>\n                         (\\<exists>v0\\<in>V0.\n                             path (tree_edges s') v0 (rev (tl (stack s')))\n                              (hd (stack s')))\n 3. \\<And>s s' u e.\n       \\<lbrakk>stack s \\<noteq> [] \\<longrightarrow>\n                (\\<exists>v0\\<in>V0.\n                    path (tree_edges s) v0 (rev (tl (stack s)))\n                     (hd (stack s)));\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; pending s `` {u} = {}; u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> stack s' \\<noteq> [] \\<longrightarrow>\n                         (\\<exists>v0\\<in>V0.\n                             path (tree_edges s') v0 (rev (tl (stack s')))\n                              (hd (stack s')))\n 4. \\<And>s s' u v e c b.\n       \\<lbrakk>stack s \\<noteq> [] \\<longrightarrow>\n                (\\<exists>v0\\<in>V0.\n                    path (tree_edges s) v0 (rev (tl (stack s)))\n                     (hd (stack s)));\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); u = hd (stack s);\n        cross_edges s \\<subseteq> c; back_edges s \\<subseteq> b;\n        s' = s\n        \\<lparr>pending := pending s - {(u, v)}, state.more := e,\n           cross_edges := c, back_edges := b\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> stack s' \\<noteq> [] \\<longrightarrow>\n                         (\\<exists>v0\\<in>V0.\n                             path (tree_edges s') v0 (rev (tl (stack s')))\n                              (hd (stack s')))", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>e.\n       stack (empty_state e) \\<noteq> [] \\<longrightarrow>\n       (\\<exists>v0\\<in>V0.\n           path (tree_edges (empty_state e)) v0\n            (rev (tl (stack (empty_state e)))) (hd (stack (empty_state e))))\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>stack s \\<noteq> [] \\<longrightarrow>\n                (\\<exists>v0\\<in>V0.\n                    path (tree_edges s) v0 (rev (tl (stack s)))\n                     (hd (stack s)));\n        cond s; DFS_invar G param s; DFS_invar G param s'; stack s = [];\n        v0 \\<notin> dom (discovered s); v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> stack s' \\<noteq> [] \\<longrightarrow>\n                         (\\<exists>v0\\<in>V0.\n                             path (tree_edges s') v0 (rev (tl (stack s')))\n                              (hd (stack s')))\n 3. \\<And>s s' u e.\n       \\<lbrakk>stack s \\<noteq> [] \\<longrightarrow>\n                (\\<exists>v0\\<in>V0.\n                    path (tree_edges s) v0 (rev (tl (stack s)))\n                     (hd (stack s)));\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; pending s `` {u} = {}; u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> stack s' \\<noteq> [] \\<longrightarrow>\n                         (\\<exists>v0\\<in>V0.\n                             path (tree_edges s') v0 (rev (tl (stack s')))\n                              (hd (stack s')))\n 4. \\<And>s s' u v e c b.\n       \\<lbrakk>stack s \\<noteq> [] \\<longrightarrow>\n                (\\<exists>v0\\<in>V0.\n                    path (tree_edges s) v0 (rev (tl (stack s)))\n                     (hd (stack s)));\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); u = hd (stack s);\n        cross_edges s \\<subseteq> c; back_edges s \\<subseteq> b;\n        s' = s\n        \\<lparr>pending := pending s - {(u, v)}, state.more := e,\n           cross_edges := c, back_edges := b\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> stack s' \\<noteq> [] \\<longrightarrow>\n                         (\\<exists>v0\\<in>V0.\n                             path (tree_edges s') v0 (rev (tl (stack s')))\n                              (hd (stack s')))", "case (finish s s')"], ["proof (state)\nthis:\n  stack s \\<noteq> [] \\<longrightarrow>\n  (\\<exists>v0\\<in>V0.\n      path (tree_edges s) v0 (rev (tl (stack s))) (hd (stack s)))\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s \\<noteq> []\n  pending s `` {u_} = {}\n  u_ = hd (stack s)\n  s' = finish u_ s\\<lparr>state.more := e_\\<rparr>\n\ngoal (4 subgoals):\n 1. \\<And>e.\n       stack (empty_state e) \\<noteq> [] \\<longrightarrow>\n       (\\<exists>v0\\<in>V0.\n           path (tree_edges (empty_state e)) v0\n            (rev (tl (stack (empty_state e)))) (hd (stack (empty_state e))))\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>stack s \\<noteq> [] \\<longrightarrow>\n                (\\<exists>v0\\<in>V0.\n                    path (tree_edges s) v0 (rev (tl (stack s)))\n                     (hd (stack s)));\n        cond s; DFS_invar G param s; DFS_invar G param s'; stack s = [];\n        v0 \\<notin> dom (discovered s); v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> stack s' \\<noteq> [] \\<longrightarrow>\n                         (\\<exists>v0\\<in>V0.\n                             path (tree_edges s') v0 (rev (tl (stack s')))\n                              (hd (stack s')))\n 3. \\<And>s s' u e.\n       \\<lbrakk>stack s \\<noteq> [] \\<longrightarrow>\n                (\\<exists>v0\\<in>V0.\n                    path (tree_edges s) v0 (rev (tl (stack s)))\n                     (hd (stack s)));\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; pending s `` {u} = {}; u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> stack s' \\<noteq> [] \\<longrightarrow>\n                         (\\<exists>v0\\<in>V0.\n                             path (tree_edges s') v0 (rev (tl (stack s')))\n                              (hd (stack s')))\n 4. \\<And>s s' u v e c b.\n       \\<lbrakk>stack s \\<noteq> [] \\<longrightarrow>\n                (\\<exists>v0\\<in>V0.\n                    path (tree_edges s) v0 (rev (tl (stack s)))\n                     (hd (stack s)));\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); u = hd (stack s);\n        cross_edges s \\<subseteq> c; back_edges s \\<subseteq> b;\n        s' = s\n        \\<lparr>pending := pending s - {(u, v)}, state.more := e,\n           cross_edges := c, back_edges := b\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> stack s' \\<noteq> [] \\<longrightarrow>\n                         (\\<exists>v0\\<in>V0.\n                             path (tree_edges s') v0 (rev (tl (stack s')))\n                              (hd (stack s')))", "hence EQ[simp]: \"stack s' = tl (stack s)\"\n                    \"tree_edges s' = tree_edges s\""], ["proof (prove)\nusing this:\n  stack s \\<noteq> [] \\<longrightarrow>\n  (\\<exists>v0\\<in>V0.\n      path (tree_edges s) v0 (rev (tl (stack s))) (hd (stack s)))\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s \\<noteq> []\n  pending s `` {u_} = {}\n  u_ = hd (stack s)\n  s' = finish u_ s\\<lparr>state.more := e_\\<rparr>\n\ngoal (1 subgoal):\n 1. stack s' = tl (stack s) &&& tree_edges s' = tree_edges s", "by simp_all"], ["proof (state)\nthis:\n  stack s' = tl (stack s)\n  tree_edges s' = tree_edges s\n\ngoal (4 subgoals):\n 1. \\<And>e.\n       stack (empty_state e) \\<noteq> [] \\<longrightarrow>\n       (\\<exists>v0\\<in>V0.\n           path (tree_edges (empty_state e)) v0\n            (rev (tl (stack (empty_state e)))) (hd (stack (empty_state e))))\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>stack s \\<noteq> [] \\<longrightarrow>\n                (\\<exists>v0\\<in>V0.\n                    path (tree_edges s) v0 (rev (tl (stack s)))\n                     (hd (stack s)));\n        cond s; DFS_invar G param s; DFS_invar G param s'; stack s = [];\n        v0 \\<notin> dom (discovered s); v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> stack s' \\<noteq> [] \\<longrightarrow>\n                         (\\<exists>v0\\<in>V0.\n                             path (tree_edges s') v0 (rev (tl (stack s')))\n                              (hd (stack s')))\n 3. \\<And>s s' u e.\n       \\<lbrakk>stack s \\<noteq> [] \\<longrightarrow>\n                (\\<exists>v0\\<in>V0.\n                    path (tree_edges s) v0 (rev (tl (stack s)))\n                     (hd (stack s)));\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; pending s `` {u} = {}; u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> stack s' \\<noteq> [] \\<longrightarrow>\n                         (\\<exists>v0\\<in>V0.\n                             path (tree_edges s') v0 (rev (tl (stack s')))\n                              (hd (stack s')))\n 4. \\<And>s s' u v e c b.\n       \\<lbrakk>stack s \\<noteq> [] \\<longrightarrow>\n                (\\<exists>v0\\<in>V0.\n                    path (tree_edges s) v0 (rev (tl (stack s)))\n                     (hd (stack s)));\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); u = hd (stack s);\n        cross_edges s \\<subseteq> c; back_edges s \\<subseteq> b;\n        s' = s\n        \\<lparr>pending := pending s - {(u, v)}, state.more := e,\n           cross_edges := c, back_edges := b\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> stack s' \\<noteq> [] \\<longrightarrow>\n                         (\\<exists>v0\\<in>V0.\n                             path (tree_edges s') v0 (rev (tl (stack s')))\n                              (hd (stack s')))", "from finish"], ["proof (chain)\npicking this:\n  stack s \\<noteq> [] \\<longrightarrow>\n  (\\<exists>v0\\<in>V0.\n      path (tree_edges s) v0 (rev (tl (stack s))) (hd (stack s)))\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s \\<noteq> []\n  pending s `` {u_} = {}\n  u_ = hd (stack s)\n  s' = finish u_ s\\<lparr>state.more := e_\\<rparr>", "obtain v0 where\n      \"v0 \\<in> V0\"\n      \"path (tree_edges s) v0 (rev (tl (stack s))) (hd (stack s))\""], ["proof (prove)\nusing this:\n  stack s \\<noteq> [] \\<longrightarrow>\n  (\\<exists>v0\\<in>V0.\n      path (tree_edges s) v0 (rev (tl (stack s))) (hd (stack s)))\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s \\<noteq> []\n  pending s `` {u_} = {}\n  u_ = hd (stack s)\n  s' = finish u_ s\\<lparr>state.more := e_\\<rparr>\n\ngoal (1 subgoal):\n 1. (\\<And>v0.\n        \\<lbrakk>v0 \\<in> V0;\n         path (tree_edges s) v0 (rev (tl (stack s))) (hd (stack s))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  v0 \\<in> V0\n  path (tree_edges s) v0 (rev (tl (stack s))) (hd (stack s))\n\ngoal (4 subgoals):\n 1. \\<And>e.\n       stack (empty_state e) \\<noteq> [] \\<longrightarrow>\n       (\\<exists>v0\\<in>V0.\n           path (tree_edges (empty_state e)) v0\n            (rev (tl (stack (empty_state e)))) (hd (stack (empty_state e))))\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>stack s \\<noteq> [] \\<longrightarrow>\n                (\\<exists>v0\\<in>V0.\n                    path (tree_edges s) v0 (rev (tl (stack s)))\n                     (hd (stack s)));\n        cond s; DFS_invar G param s; DFS_invar G param s'; stack s = [];\n        v0 \\<notin> dom (discovered s); v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> stack s' \\<noteq> [] \\<longrightarrow>\n                         (\\<exists>v0\\<in>V0.\n                             path (tree_edges s') v0 (rev (tl (stack s')))\n                              (hd (stack s')))\n 3. \\<And>s s' u e.\n       \\<lbrakk>stack s \\<noteq> [] \\<longrightarrow>\n                (\\<exists>v0\\<in>V0.\n                    path (tree_edges s) v0 (rev (tl (stack s)))\n                     (hd (stack s)));\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; pending s `` {u} = {}; u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> stack s' \\<noteq> [] \\<longrightarrow>\n                         (\\<exists>v0\\<in>V0.\n                             path (tree_edges s') v0 (rev (tl (stack s')))\n                              (hd (stack s')))\n 4. \\<And>s s' u v e c b.\n       \\<lbrakk>stack s \\<noteq> [] \\<longrightarrow>\n                (\\<exists>v0\\<in>V0.\n                    path (tree_edges s) v0 (rev (tl (stack s)))\n                     (hd (stack s)));\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); u = hd (stack s);\n        cross_edges s \\<subseteq> c; back_edges s \\<subseteq> b;\n        s' = s\n        \\<lparr>pending := pending s - {(u, v)}, state.more := e,\n           cross_edges := c, back_edges := b\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> stack s' \\<noteq> [] \\<longrightarrow>\n                         (\\<exists>v0\\<in>V0.\n                             path (tree_edges s') v0 (rev (tl (stack s')))\n                              (hd (stack s')))", "hence P: \"path (tree_edges s') v0 (rev (stack s')) (hd (stack s))\""], ["proof (prove)\nusing this:\n  v0 \\<in> V0\n  path (tree_edges s) v0 (rev (tl (stack s))) (hd (stack s))\n\ngoal (1 subgoal):\n 1. path (tree_edges s') v0 (rev (stack s')) (hd (stack s))", "by simp"], ["proof (state)\nthis:\n  path (tree_edges s') v0 (rev (stack s')) (hd (stack s))\n\ngoal (4 subgoals):\n 1. \\<And>e.\n       stack (empty_state e) \\<noteq> [] \\<longrightarrow>\n       (\\<exists>v0\\<in>V0.\n           path (tree_edges (empty_state e)) v0\n            (rev (tl (stack (empty_state e)))) (hd (stack (empty_state e))))\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>stack s \\<noteq> [] \\<longrightarrow>\n                (\\<exists>v0\\<in>V0.\n                    path (tree_edges s) v0 (rev (tl (stack s)))\n                     (hd (stack s)));\n        cond s; DFS_invar G param s; DFS_invar G param s'; stack s = [];\n        v0 \\<notin> dom (discovered s); v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> stack s' \\<noteq> [] \\<longrightarrow>\n                         (\\<exists>v0\\<in>V0.\n                             path (tree_edges s') v0 (rev (tl (stack s')))\n                              (hd (stack s')))\n 3. \\<And>s s' u e.\n       \\<lbrakk>stack s \\<noteq> [] \\<longrightarrow>\n                (\\<exists>v0\\<in>V0.\n                    path (tree_edges s) v0 (rev (tl (stack s)))\n                     (hd (stack s)));\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; pending s `` {u} = {}; u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> stack s' \\<noteq> [] \\<longrightarrow>\n                         (\\<exists>v0\\<in>V0.\n                             path (tree_edges s') v0 (rev (tl (stack s')))\n                              (hd (stack s')))\n 4. \\<And>s s' u v e c b.\n       \\<lbrakk>stack s \\<noteq> [] \\<longrightarrow>\n                (\\<exists>v0\\<in>V0.\n                    path (tree_edges s) v0 (rev (tl (stack s)))\n                     (hd (stack s)));\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); u = hd (stack s);\n        cross_edges s \\<subseteq> c; back_edges s \\<subseteq> b;\n        s' = s\n        \\<lparr>pending := pending s - {(u, v)}, state.more := e,\n           cross_edges := c, back_edges := b\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> stack s' \\<noteq> [] \\<longrightarrow>\n                         (\\<exists>v0\\<in>V0.\n                             path (tree_edges s') v0 (rev (tl (stack s')))\n                              (hd (stack s')))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. stack s' \\<noteq> [] \\<longrightarrow>\n    (\\<exists>v0\\<in>V0.\n        path (tree_edges s') v0 (rev (tl (stack s'))) (hd (stack s')))", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. stack s' \\<noteq> [] \\<Longrightarrow>\n    \\<exists>v0\\<in>V0.\n       path (tree_edges s') v0 (rev (tl (stack s'))) (hd (stack s'))", "assume A: \"stack s' \\<noteq> []\""], ["proof (state)\nthis:\n  stack s' \\<noteq> []\n\ngoal (1 subgoal):\n 1. stack s' \\<noteq> [] \\<Longrightarrow>\n    \\<exists>v0\\<in>V0.\n       path (tree_edges s') v0 (rev (tl (stack s'))) (hd (stack s'))", "with P"], ["proof (chain)\npicking this:\n  path (tree_edges s') v0 (rev (stack s')) (hd (stack s))\n  stack s' \\<noteq> []", "have \"(hd (stack s'), hd (stack s)) \\<in> tree_edges s'\""], ["proof (prove)\nusing this:\n  path (tree_edges s') v0 (rev (stack s')) (hd (stack s))\n  stack s' \\<noteq> []\n\ngoal (1 subgoal):\n 1. (hd (stack s'), hd (stack s)) \\<in> tree_edges s'", "by (auto simp: neq_Nil_conv path_simps)"], ["proof (state)\nthis:\n  (hd (stack s'), hd (stack s)) \\<in> tree_edges s'\n\ngoal (1 subgoal):\n 1. stack s' \\<noteq> [] \\<Longrightarrow>\n    \\<exists>v0\\<in>V0.\n       path (tree_edges s') v0 (rev (tl (stack s'))) (hd (stack s'))", "moreover"], ["proof (state)\nthis:\n  (hd (stack s'), hd (stack s)) \\<in> tree_edges s'\n\ngoal (1 subgoal):\n 1. stack s' \\<noteq> [] \\<Longrightarrow>\n    \\<exists>v0\\<in>V0.\n       path (tree_edges s') v0 (rev (tl (stack s'))) (hd (stack s'))", "from P A"], ["proof (chain)\npicking this:\n  path (tree_edges s') v0 (rev (stack s')) (hd (stack s))\n  stack s' \\<noteq> []", "have \n        \"path (tree_edges s') v0 (rev (tl (stack s')) @ [hd (stack s')]) (hd (stack s))\""], ["proof (prove)\nusing this:\n  path (tree_edges s') v0 (rev (stack s')) (hd (stack s))\n  stack s' \\<noteq> []\n\ngoal (1 subgoal):\n 1. path (tree_edges s') v0 (rev (tl (stack s')) @ [hd (stack s')])\n     (hd (stack s))", "by (simp)"], ["proof (state)\nthis:\n  path (tree_edges s') v0 (rev (tl (stack s')) @ [hd (stack s')])\n   (hd (stack s))\n\ngoal (1 subgoal):\n 1. stack s' \\<noteq> [] \\<Longrightarrow>\n    \\<exists>v0\\<in>V0.\n       path (tree_edges s') v0 (rev (tl (stack s'))) (hd (stack s'))", "moreover"], ["proof (state)\nthis:\n  path (tree_edges s') v0 (rev (tl (stack s')) @ [hd (stack s')])\n   (hd (stack s))\n\ngoal (1 subgoal):\n 1. stack s' \\<noteq> [] \\<Longrightarrow>\n    \\<exists>v0\\<in>V0.\n       path (tree_edges s') v0 (rev (tl (stack s'))) (hd (stack s'))", "note \\<open>v0 \\<in> V0\\<close>"], ["proof (state)\nthis:\n  v0 \\<in> V0\n\ngoal (1 subgoal):\n 1. stack s' \\<noteq> [] \\<Longrightarrow>\n    \\<exists>v0\\<in>V0.\n       path (tree_edges s') v0 (rev (tl (stack s'))) (hd (stack s'))", "ultimately"], ["proof (chain)\npicking this:\n  (hd (stack s'), hd (stack s)) \\<in> tree_edges s'\n  path (tree_edges s') v0 (rev (tl (stack s')) @ [hd (stack s')])\n   (hd (stack s))\n  v0 \\<in> V0", "show \"\\<exists>v0\\<in>V0. path (tree_edges s') v0 (rev (tl (stack s'))) (hd (stack s'))\""], ["proof (prove)\nusing this:\n  (hd (stack s'), hd (stack s)) \\<in> tree_edges s'\n  path (tree_edges s') v0 (rev (tl (stack s')) @ [hd (stack s')])\n   (hd (stack s))\n  v0 \\<in> V0\n\ngoal (1 subgoal):\n 1. \\<exists>v0\\<in>V0.\n       path (tree_edges s') v0 (rev (tl (stack s'))) (hd (stack s'))", "by (auto simp add: path_append_conv)"], ["proof (state)\nthis:\n  \\<exists>v0\\<in>V0.\n     path (tree_edges s') v0 (rev (tl (stack s'))) (hd (stack s'))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  stack s' \\<noteq> [] \\<longrightarrow>\n  (\\<exists>v0\\<in>V0.\n      path (tree_edges s') v0 (rev (tl (stack s'))) (hd (stack s')))\n\ngoal (3 subgoals):\n 1. \\<And>e.\n       stack (empty_state e) \\<noteq> [] \\<longrightarrow>\n       (\\<exists>v0\\<in>V0.\n           path (tree_edges (empty_state e)) v0\n            (rev (tl (stack (empty_state e)))) (hd (stack (empty_state e))))\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>stack s \\<noteq> [] \\<longrightarrow>\n                (\\<exists>v0\\<in>V0.\n                    path (tree_edges s) v0 (rev (tl (stack s)))\n                     (hd (stack s)));\n        cond s; DFS_invar G param s; DFS_invar G param s'; stack s = [];\n        v0 \\<notin> dom (discovered s); v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> stack s' \\<noteq> [] \\<longrightarrow>\n                         (\\<exists>v0\\<in>V0.\n                             path (tree_edges s') v0 (rev (tl (stack s')))\n                              (hd (stack s')))\n 3. \\<And>s s' u v e c b.\n       \\<lbrakk>stack s \\<noteq> [] \\<longrightarrow>\n                (\\<exists>v0\\<in>V0.\n                    path (tree_edges s) v0 (rev (tl (stack s)))\n                     (hd (stack s)));\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); u = hd (stack s);\n        cross_edges s \\<subseteq> c; back_edges s \\<subseteq> b;\n        s' = s\n        \\<lparr>pending := pending s - {(u, v)}, state.more := e,\n           cross_edges := c, back_edges := b\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> stack s' \\<noteq> [] \\<longrightarrow>\n                         (\\<exists>v0\\<in>V0.\n                             path (tree_edges s') v0 (rev (tl (stack s')))\n                              (hd (stack s')))", "qed simp_all"], ["", "end"], ["", "context DFS_invar begin"], ["", "lemmas stack_is_tree_path = \n    i_stack_is_tree_path[THEN make_invar_thm, rule_format]"], ["", "lemma stack_is_path:\n    \"stack s \\<noteq> [] \\<Longrightarrow> \\<exists>v0\\<in>V0. path E v0 (rev (tl (stack s))) (hd (stack s))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stack s \\<noteq> [] \\<Longrightarrow>\n    \\<exists>v0\\<in>V0. path E v0 (rev (tl (stack s))) (hd (stack s))", "using stack_is_tree_path path_mono[OF tree_edges_ssE]"], ["proof (prove)\nusing this:\n  stack s \\<noteq> [] \\<Longrightarrow>\n  \\<exists>v0\\<in>V0.\n     path (tree_edges s) v0 (rev (tl (stack s))) (hd (stack s))\n  path (tree_edges s) ?u ?p ?v \\<Longrightarrow> path E ?u ?p ?v\n\ngoal (1 subgoal):\n 1. stack s \\<noteq> [] \\<Longrightarrow>\n    \\<exists>v0\\<in>V0. path E v0 (rev (tl (stack s))) (hd (stack s))", "by blast"], ["", "lemma hd_succ_stack_is_path:\n    assumes ne: \"stack s \\<noteq> []\"\n    and succ: \"v \\<in> succ (hd (stack s))\"\n    shows \"\\<exists>v0\\<in>V0. path E v0 (rev (stack s)) v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>v0\\<in>V0. path E v0 (rev (stack s)) v", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>v0\\<in>V0. path E v0 (rev (stack s)) v", "from stack_is_path[OF ne] succ"], ["proof (chain)\npicking this:\n  \\<exists>v0\\<in>V0. path E v0 (rev (tl (stack s))) (hd (stack s))\n  v \\<in> E `` {hd (stack s)}", "obtain v0 where\n      \"v0 \\<in> V0\"\n      \"path E v0 (rev (tl (stack s)) @ [hd (stack s)]) v\""], ["proof (prove)\nusing this:\n  \\<exists>v0\\<in>V0. path E v0 (rev (tl (stack s))) (hd (stack s))\n  v \\<in> E `` {hd (stack s)}\n\ngoal (1 subgoal):\n 1. (\\<And>v0.\n        \\<lbrakk>v0 \\<in> V0;\n         path E v0 (rev (tl (stack s)) @ [hd (stack s)]) v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp add: path_append_conv)"], ["proof (state)\nthis:\n  v0 \\<in> V0\n  path E v0 (rev (tl (stack s)) @ [hd (stack s)]) v\n\ngoal (1 subgoal):\n 1. \\<exists>v0\\<in>V0. path E v0 (rev (stack s)) v", "thus ?thesis"], ["proof (prove)\nusing this:\n  v0 \\<in> V0\n  path E v0 (rev (tl (stack s)) @ [hd (stack s)]) v\n\ngoal (1 subgoal):\n 1. \\<exists>v0\\<in>V0. path E v0 (rev (stack s)) v", "using ne"], ["proof (prove)\nusing this:\n  v0 \\<in> V0\n  path E v0 (rev (tl (stack s)) @ [hd (stack s)]) v\n  stack s \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<exists>v0\\<in>V0. path E v0 (rev (stack s)) v", "by (cases \"stack s\") auto"], ["proof (state)\nthis:\n  \\<exists>v0\\<in>V0. path E v0 (rev (stack s)) v\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma tl_stack_hd_tree_path:\n    assumes \"stack s \\<noteq> []\"\n    and \"v \\<in> set (tl (stack s))\"\n    shows \"(v, hd (stack s)) \\<in> (tree_edges s)\\<^sup>+\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (v, hd (stack s)) \\<in> (tree_edges s)\\<^sup>+", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (v, hd (stack s)) \\<in> (tree_edges s)\\<^sup>+", "from stack_is_tree_path assms"], ["proof (chain)\npicking this:\n  stack s \\<noteq> [] \\<Longrightarrow>\n  \\<exists>v0\\<in>V0.\n     path (tree_edges s) v0 (rev (tl (stack s))) (hd (stack s))\n  stack s \\<noteq> []\n  v \\<in> set (tl (stack s))", "obtain v0 where \n      \"path (tree_edges s) v0 (rev (tl (stack s))) (hd (stack s))\""], ["proof (prove)\nusing this:\n  stack s \\<noteq> [] \\<Longrightarrow>\n  \\<exists>v0\\<in>V0.\n     path (tree_edges s) v0 (rev (tl (stack s))) (hd (stack s))\n  stack s \\<noteq> []\n  v \\<in> set (tl (stack s))\n\ngoal (1 subgoal):\n 1. (\\<And>v0.\n        path (tree_edges s) v0 (rev (tl (stack s)))\n         (hd (stack s)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  path (tree_edges s) v0 (rev (tl (stack s))) (hd (stack s))\n\ngoal (1 subgoal):\n 1. (v, hd (stack s)) \\<in> (tree_edges s)\\<^sup>+", "from assms path_member_reach_end[OF this]"], ["proof (chain)\npicking this:\n  stack s \\<noteq> []\n  v \\<in> set (tl (stack s))\n  ?v \\<in> set (rev (tl (stack s))) \\<Longrightarrow>\n  (?v, hd (stack s)) \\<in> (tree_edges s)\\<^sup>+", "show ?thesis"], ["proof (prove)\nusing this:\n  stack s \\<noteq> []\n  v \\<in> set (tl (stack s))\n  ?v \\<in> set (rev (tl (stack s))) \\<Longrightarrow>\n  (?v, hd (stack s)) \\<in> (tree_edges s)\\<^sup>+\n\ngoal (1 subgoal):\n 1. (v, hd (stack s)) \\<in> (tree_edges s)\\<^sup>+", "by simp"], ["proof (state)\nthis:\n  (v, hd (stack s)) \\<in> (tree_edges s)\\<^sup>+\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "context param_DFS begin"], ["", "definition \"tree_discovered_inv s \\<equiv>\n                       (tree_edges s = {} \\<longrightarrow> dom (discovered s) \\<subseteq> V0 \\<and> (stack s = [] \\<or> (\\<exists>v0\\<in>V0. stack s = [v0])))\n                     \\<and> (tree_edges s \\<noteq> {} \\<longrightarrow> (tree_edges s)\\<^sup>+ `` V0 \\<union> V0 = dom (discovered s) \\<union> V0)\""], ["", "lemma i_tree_discovered_inv: \n    \"is_invar tree_discovered_inv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_invar tree_discovered_inv", "proof (induct rule: is_invarI)"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>e. tree_discovered_inv (empty_state e)\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>tree_discovered_inv s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s = []; v0 \\<notin> dom (discovered s);\n        v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> tree_discovered_inv s'\n 3. \\<And>s s' u e.\n       \\<lbrakk>tree_discovered_inv s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; pending s `` {u} = {};\n        u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> tree_discovered_inv s'\n 4. \\<And>s s' u v e c b.\n       \\<lbrakk>tree_discovered_inv s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); u = hd (stack s);\n        cross_edges s \\<subseteq> c; back_edges s \\<subseteq> b;\n        s' = s\n        \\<lparr>pending := pending s - {(u, v)}, state.more := e,\n           cross_edges := c, back_edges := b\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> tree_discovered_inv s'\n 5. \\<And>s s' u v e.\n       \\<lbrakk>tree_discovered_inv s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> tree_discovered_inv s'", "case (discover s s' u v)"], ["proof (state)\nthis:\n  tree_discovered_inv s\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s \\<noteq> []\n  v \\<in> pending s `` {u}\n  v \\<notin> dom (discovered s)\n  u = hd (stack s)\n  s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n  \\<lparr>state.more := e_\\<rparr>\n\ngoal (5 subgoals):\n 1. \\<And>e. tree_discovered_inv (empty_state e)\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>tree_discovered_inv s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s = []; v0 \\<notin> dom (discovered s);\n        v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> tree_discovered_inv s'\n 3. \\<And>s s' u e.\n       \\<lbrakk>tree_discovered_inv s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; pending s `` {u} = {};\n        u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> tree_discovered_inv s'\n 4. \\<And>s s' u v e c b.\n       \\<lbrakk>tree_discovered_inv s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); u = hd (stack s);\n        cross_edges s \\<subseteq> c; back_edges s \\<subseteq> b;\n        s' = s\n        \\<lparr>pending := pending s - {(u, v)}, state.more := e,\n           cross_edges := c, back_edges := b\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> tree_discovered_inv s'\n 5. \\<And>s s' u v e.\n       \\<lbrakk>tree_discovered_inv s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> tree_discovered_inv s'", "hence EQ[simp]: \"stack s' = v # stack s\"\n                    \"tree_edges s' = insert (hd (stack s), v) (tree_edges s)\"\n                    \"discovered s' = (discovered s)(v \\<mapsto> counter s)\""], ["proof (prove)\nusing this:\n  tree_discovered_inv s\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s \\<noteq> []\n  v \\<in> pending s `` {u}\n  v \\<notin> dom (discovered s)\n  u = hd (stack s)\n  s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n  \\<lparr>state.more := e_\\<rparr>\n\ngoal (1 subgoal):\n 1. stack s' = v # stack s &&&\n    tree_edges s' = insert (hd (stack s), v) (tree_edges s) &&&\n    discovered s' = discovered s(v \\<mapsto> counter s)", "by simp_all"], ["proof (state)\nthis:\n  stack s' = v # stack s\n  tree_edges s' = insert (hd (stack s), v) (tree_edges s)\n  discovered s' = discovered s(v \\<mapsto> counter s)\n\ngoal (5 subgoals):\n 1. \\<And>e. tree_discovered_inv (empty_state e)\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>tree_discovered_inv s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s = []; v0 \\<notin> dom (discovered s);\n        v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> tree_discovered_inv s'\n 3. \\<And>s s' u e.\n       \\<lbrakk>tree_discovered_inv s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; pending s `` {u} = {};\n        u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> tree_discovered_inv s'\n 4. \\<And>s s' u v e c b.\n       \\<lbrakk>tree_discovered_inv s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); u = hd (stack s);\n        cross_edges s \\<subseteq> c; back_edges s \\<subseteq> b;\n        s' = s\n        \\<lparr>pending := pending s - {(u, v)}, state.more := e,\n           cross_edges := c, back_edges := b\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> tree_discovered_inv s'\n 5. \\<And>s s' u v e.\n       \\<lbrakk>tree_discovered_inv s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> tree_discovered_inv s'", "from discover"], ["proof (chain)\npicking this:\n  tree_discovered_inv s\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s \\<noteq> []\n  v \\<in> pending s `` {u}\n  v \\<notin> dom (discovered s)\n  u = hd (stack s)\n  s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n  \\<lparr>state.more := e_\\<rparr>", "interpret DFS_invar where s=s"], ["proof (prove)\nusing this:\n  tree_discovered_inv s\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s \\<noteq> []\n  v \\<in> pending s `` {u}\n  v \\<notin> dom (discovered s)\n  u = hd (stack s)\n  s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n  \\<lparr>state.more := e_\\<rparr>\n\ngoal (1 subgoal):\n 1. DFS_invar G param s", "by simp"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>e. tree_discovered_inv (empty_state e)\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>tree_discovered_inv s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s = []; v0 \\<notin> dom (discovered s);\n        v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> tree_discovered_inv s'\n 3. \\<And>s s' u e.\n       \\<lbrakk>tree_discovered_inv s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; pending s `` {u} = {};\n        u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> tree_discovered_inv s'\n 4. \\<And>s s' u v e c b.\n       \\<lbrakk>tree_discovered_inv s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); u = hd (stack s);\n        cross_edges s \\<subseteq> c; back_edges s \\<subseteq> b;\n        s' = s\n        \\<lparr>pending := pending s - {(u, v)}, state.more := e,\n           cross_edges := c, back_edges := b\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> tree_discovered_inv s'\n 5. \\<And>s s' u v e.\n       \\<lbrakk>tree_discovered_inv s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> tree_discovered_inv s'", "from discover"], ["proof (chain)\npicking this:\n  tree_discovered_inv s\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s \\<noteq> []\n  v \\<in> pending s `` {u}\n  v \\<notin> dom (discovered s)\n  u = hd (stack s)\n  s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n  \\<lparr>state.more := e_\\<rparr>", "have NE[simp]: \"stack s \\<noteq> []\""], ["proof (prove)\nusing this:\n  tree_discovered_inv s\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s \\<noteq> []\n  v \\<in> pending s `` {u}\n  v \\<notin> dom (discovered s)\n  u = hd (stack s)\n  s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n  \\<lparr>state.more := e_\\<rparr>\n\ngoal (1 subgoal):\n 1. stack s \\<noteq> []", "by simp"], ["proof (state)\nthis:\n  stack s \\<noteq> []\n\ngoal (5 subgoals):\n 1. \\<And>e. tree_discovered_inv (empty_state e)\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>tree_discovered_inv s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s = []; v0 \\<notin> dom (discovered s);\n        v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> tree_discovered_inv s'\n 3. \\<And>s s' u e.\n       \\<lbrakk>tree_discovered_inv s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; pending s `` {u} = {};\n        u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> tree_discovered_inv s'\n 4. \\<And>s s' u v e c b.\n       \\<lbrakk>tree_discovered_inv s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); u = hd (stack s);\n        cross_edges s \\<subseteq> c; back_edges s \\<subseteq> b;\n        s' = s\n        \\<lparr>pending := pending s - {(u, v)}, state.more := e,\n           cross_edges := c, back_edges := b\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> tree_discovered_inv s'\n 5. \\<And>s s' u v e.\n       \\<lbrakk>tree_discovered_inv s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> tree_discovered_inv s'", "note TDI = \\<open>tree_discovered_inv s\\<close>[unfolded tree_discovered_inv_def]"], ["proof (state)\nthis:\n  (tree_edges s = {} \\<longrightarrow>\n   dom (discovered s) \\<subseteq> V0 \\<and>\n   (stack s = [] \\<or> (\\<exists>v0\\<in>V0. stack s = [v0]))) \\<and>\n  (tree_edges s \\<noteq> {} \\<longrightarrow>\n   (tree_edges s)\\<^sup>+ `` V0 \\<union> V0 =\n   dom (discovered s) \\<union> V0)\n\ngoal (5 subgoals):\n 1. \\<And>e. tree_discovered_inv (empty_state e)\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>tree_discovered_inv s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s = []; v0 \\<notin> dom (discovered s);\n        v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> tree_discovered_inv s'\n 3. \\<And>s s' u e.\n       \\<lbrakk>tree_discovered_inv s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; pending s `` {u} = {};\n        u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> tree_discovered_inv s'\n 4. \\<And>s s' u v e c b.\n       \\<lbrakk>tree_discovered_inv s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); u = hd (stack s);\n        cross_edges s \\<subseteq> c; back_edges s \\<subseteq> b;\n        s' = s\n        \\<lparr>pending := pending s - {(u, v)}, state.more := e,\n           cross_edges := c, back_edges := b\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> tree_discovered_inv s'\n 5. \\<And>s s' u v e.\n       \\<lbrakk>tree_discovered_inv s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> tree_discovered_inv s'", "have \"tree_edges s' = {} \\<longrightarrow> dom (discovered s') \\<subseteq> V0 \\<and> (stack s' = [] \\<or> (\\<exists>v0\\<in>V0. stack s' = [v0]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tree_edges s' = {} \\<longrightarrow>\n    dom (discovered s') \\<subseteq> V0 \\<and>\n    (stack s' = [] \\<or> (\\<exists>v0\\<in>V0. stack s' = [v0]))", "by simp \\<comment> \\<open>@{text \"tree_edges s' \\<noteq> {}\"}\\<close>"], ["proof (state)\nthis:\n  tree_edges s' = {} \\<longrightarrow>\n  dom (discovered s') \\<subseteq> V0 \\<and>\n  (stack s' = [] \\<or> (\\<exists>v0\\<in>V0. stack s' = [v0]))\n\ngoal (5 subgoals):\n 1. \\<And>e. tree_discovered_inv (empty_state e)\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>tree_discovered_inv s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s = []; v0 \\<notin> dom (discovered s);\n        v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> tree_discovered_inv s'\n 3. \\<And>s s' u e.\n       \\<lbrakk>tree_discovered_inv s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; pending s `` {u} = {};\n        u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> tree_discovered_inv s'\n 4. \\<And>s s' u v e c b.\n       \\<lbrakk>tree_discovered_inv s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); u = hd (stack s);\n        cross_edges s \\<subseteq> c; back_edges s \\<subseteq> b;\n        s' = s\n        \\<lparr>pending := pending s - {(u, v)}, state.more := e,\n           cross_edges := c, back_edges := b\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> tree_discovered_inv s'\n 5. \\<And>s s' u v e.\n       \\<lbrakk>tree_discovered_inv s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> tree_discovered_inv s'", "moreover"], ["proof (state)\nthis:\n  tree_edges s' = {} \\<longrightarrow>\n  dom (discovered s') \\<subseteq> V0 \\<and>\n  (stack s' = [] \\<or> (\\<exists>v0\\<in>V0. stack s' = [v0]))\n\ngoal (5 subgoals):\n 1. \\<And>e. tree_discovered_inv (empty_state e)\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>tree_discovered_inv s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s = []; v0 \\<notin> dom (discovered s);\n        v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> tree_discovered_inv s'\n 3. \\<And>s s' u e.\n       \\<lbrakk>tree_discovered_inv s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; pending s `` {u} = {};\n        u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> tree_discovered_inv s'\n 4. \\<And>s s' u v e c b.\n       \\<lbrakk>tree_discovered_inv s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); u = hd (stack s);\n        cross_edges s \\<subseteq> c; back_edges s \\<subseteq> b;\n        s' = s\n        \\<lparr>pending := pending s - {(u, v)}, state.more := e,\n           cross_edges := c, back_edges := b\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> tree_discovered_inv s'\n 5. \\<And>s s' u v e.\n       \\<lbrakk>tree_discovered_inv s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> tree_discovered_inv s'", "{"], ["proof (state)\nthis:\n  tree_edges s' = {} \\<longrightarrow>\n  dom (discovered s') \\<subseteq> V0 \\<and>\n  (stack s' = [] \\<or> (\\<exists>v0\\<in>V0. stack s' = [v0]))\n\ngoal (5 subgoals):\n 1. \\<And>e. tree_discovered_inv (empty_state e)\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>tree_discovered_inv s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s = []; v0 \\<notin> dom (discovered s);\n        v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> tree_discovered_inv s'\n 3. \\<And>s s' u e.\n       \\<lbrakk>tree_discovered_inv s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; pending s `` {u} = {};\n        u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> tree_discovered_inv s'\n 4. \\<And>s s' u v e c b.\n       \\<lbrakk>tree_discovered_inv s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); u = hd (stack s);\n        cross_edges s \\<subseteq> c; back_edges s \\<subseteq> b;\n        s' = s\n        \\<lparr>pending := pending s - {(u, v)}, state.more := e,\n           cross_edges := c, back_edges := b\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> tree_discovered_inv s'\n 5. \\<And>s s' u v e.\n       \\<lbrakk>tree_discovered_inv s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> tree_discovered_inv s'", "fix x"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>e. tree_discovered_inv (empty_state e)\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>tree_discovered_inv s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s = []; v0 \\<notin> dom (discovered s);\n        v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> tree_discovered_inv s'\n 3. \\<And>s s' u e.\n       \\<lbrakk>tree_discovered_inv s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; pending s `` {u} = {};\n        u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> tree_discovered_inv s'\n 4. \\<And>s s' u v e c b.\n       \\<lbrakk>tree_discovered_inv s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); u = hd (stack s);\n        cross_edges s \\<subseteq> c; back_edges s \\<subseteq> b;\n        s' = s\n        \\<lparr>pending := pending s - {(u, v)}, state.more := e,\n           cross_edges := c, back_edges := b\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> tree_discovered_inv s'\n 5. \\<And>s s' u v e.\n       \\<lbrakk>tree_discovered_inv s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> tree_discovered_inv s'", "assume A: \"x \\<in> (tree_edges s')\\<^sup>+ `` V0 \\<union> V0\" \"x \\<notin> V0\""], ["proof (state)\nthis:\n  x \\<in> (tree_edges s')\\<^sup>+ `` V0 \\<union> V0\n  x \\<notin> V0\n\ngoal (5 subgoals):\n 1. \\<And>e. tree_discovered_inv (empty_state e)\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>tree_discovered_inv s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s = []; v0 \\<notin> dom (discovered s);\n        v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> tree_discovered_inv s'\n 3. \\<And>s s' u e.\n       \\<lbrakk>tree_discovered_inv s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; pending s `` {u} = {};\n        u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> tree_discovered_inv s'\n 4. \\<And>s s' u v e c b.\n       \\<lbrakk>tree_discovered_inv s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); u = hd (stack s);\n        cross_edges s \\<subseteq> c; back_edges s \\<subseteq> b;\n        s' = s\n        \\<lparr>pending := pending s - {(u, v)}, state.more := e,\n           cross_edges := c, back_edges := b\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> tree_discovered_inv s'\n 5. \\<And>s s' u v e.\n       \\<lbrakk>tree_discovered_inv s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> tree_discovered_inv s'", "then"], ["proof (chain)\npicking this:\n  x \\<in> (tree_edges s')\\<^sup>+ `` V0 \\<union> V0\n  x \\<notin> V0", "obtain y where y: \"(y,x) \\<in> (tree_edges s')\\<^sup>+\" \"y \\<in> V0\""], ["proof (prove)\nusing this:\n  x \\<in> (tree_edges s')\\<^sup>+ `` V0 \\<union> V0\n  x \\<notin> V0\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>(y, x) \\<in> (tree_edges s')\\<^sup>+; y \\<in> V0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  (y, x) \\<in> (tree_edges s')\\<^sup>+\n  y \\<in> V0\n\ngoal (5 subgoals):\n 1. \\<And>e. tree_discovered_inv (empty_state e)\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>tree_discovered_inv s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s = []; v0 \\<notin> dom (discovered s);\n        v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> tree_discovered_inv s'\n 3. \\<And>s s' u e.\n       \\<lbrakk>tree_discovered_inv s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; pending s `` {u} = {};\n        u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> tree_discovered_inv s'\n 4. \\<And>s s' u v e c b.\n       \\<lbrakk>tree_discovered_inv s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); u = hd (stack s);\n        cross_edges s \\<subseteq> c; back_edges s \\<subseteq> b;\n        s' = s\n        \\<lparr>pending := pending s - {(u, v)}, state.more := e,\n           cross_edges := c, back_edges := b\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> tree_discovered_inv s'\n 5. \\<And>s s' u v e.\n       \\<lbrakk>tree_discovered_inv s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> tree_discovered_inv s'", "have \"x \\<in> dom (discovered s') \\<union> V0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> dom (discovered s') \\<union> V0", "proof (cases \"tree_edges s = {}\")"], ["proof (state)\ngoal (2 subgoals):\n 1. tree_edges s = {} \\<Longrightarrow>\n    x \\<in> dom (discovered s') \\<union> V0\n 2. tree_edges s \\<noteq> {} \\<Longrightarrow>\n    x \\<in> dom (discovered s') \\<union> V0", "case True"], ["proof (state)\nthis:\n  tree_edges s = {}\n\ngoal (2 subgoals):\n 1. tree_edges s = {} \\<Longrightarrow>\n    x \\<in> dom (discovered s') \\<union> V0\n 2. tree_edges s \\<noteq> {} \\<Longrightarrow>\n    x \\<in> dom (discovered s') \\<union> V0", "with discover A"], ["proof (chain)\npicking this:\n  tree_discovered_inv s\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s \\<noteq> []\n  v \\<in> pending s `` {u}\n  v \\<notin> dom (discovered s)\n  u = hd (stack s)\n  s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n  \\<lparr>state.more := e_\\<rparr>\n  x \\<in> (tree_edges s')\\<^sup>+ `` V0 \\<union> V0\n  x \\<notin> V0\n  tree_edges s = {}", "have \"(tree_edges s')\\<^sup>+ = {(hd (stack s), v)}\""], ["proof (prove)\nusing this:\n  tree_discovered_inv s\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s \\<noteq> []\n  v \\<in> pending s `` {u}\n  v \\<notin> dom (discovered s)\n  u = hd (stack s)\n  s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n  \\<lparr>state.more := e_\\<rparr>\n  x \\<in> (tree_edges s')\\<^sup>+ `` V0 \\<union> V0\n  x \\<notin> V0\n  tree_edges s = {}\n\ngoal (1 subgoal):\n 1. (tree_edges s')\\<^sup>+ = {(hd (stack s), v)}", "by (simp add: trancl_single)"], ["proof (state)\nthis:\n  (tree_edges s')\\<^sup>+ = {(hd (stack s), v)}\n\ngoal (2 subgoals):\n 1. tree_edges s = {} \\<Longrightarrow>\n    x \\<in> dom (discovered s') \\<union> V0\n 2. tree_edges s \\<noteq> {} \\<Longrightarrow>\n    x \\<in> dom (discovered s') \\<union> V0", "with A"], ["proof (chain)\npicking this:\n  x \\<in> (tree_edges s')\\<^sup>+ `` V0 \\<union> V0\n  x \\<notin> V0\n  (tree_edges s')\\<^sup>+ = {(hd (stack s), v)}", "show ?thesis"], ["proof (prove)\nusing this:\n  x \\<in> (tree_edges s')\\<^sup>+ `` V0 \\<union> V0\n  x \\<notin> V0\n  (tree_edges s')\\<^sup>+ = {(hd (stack s), v)}\n\ngoal (1 subgoal):\n 1. x \\<in> dom (discovered s') \\<union> V0", "by auto"], ["proof (state)\nthis:\n  x \\<in> dom (discovered s') \\<union> V0\n\ngoal (1 subgoal):\n 1. tree_edges s \\<noteq> {} \\<Longrightarrow>\n    x \\<in> dom (discovered s') \\<union> V0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. tree_edges s \\<noteq> {} \\<Longrightarrow>\n    x \\<in> dom (discovered s') \\<union> V0", "case False"], ["proof (state)\nthis:\n  tree_edges s \\<noteq> {}\n\ngoal (1 subgoal):\n 1. tree_edges s \\<noteq> {} \\<Longrightarrow>\n    x \\<in> dom (discovered s') \\<union> V0", "note t_ne = this"], ["proof (state)\nthis:\n  tree_edges s \\<noteq> {}\n\ngoal (1 subgoal):\n 1. tree_edges s \\<noteq> {} \\<Longrightarrow>\n    x \\<in> dom (discovered s') \\<union> V0", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> dom (discovered s') \\<union> V0", "proof (cases \"x = v\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x = v \\<Longrightarrow> x \\<in> dom (discovered s') \\<union> V0\n 2. x \\<noteq> v \\<Longrightarrow> x \\<in> dom (discovered s') \\<union> V0", "case True"], ["proof (state)\nthis:\n  x = v\n\ngoal (2 subgoals):\n 1. x = v \\<Longrightarrow> x \\<in> dom (discovered s') \\<union> V0\n 2. x \\<noteq> v \\<Longrightarrow> x \\<in> dom (discovered s') \\<union> V0", "thus ?thesis"], ["proof (prove)\nusing this:\n  x = v\n\ngoal (1 subgoal):\n 1. x \\<in> dom (discovered s') \\<union> V0", "by simp"], ["proof (state)\nthis:\n  x \\<in> dom (discovered s') \\<union> V0\n\ngoal (1 subgoal):\n 1. x \\<noteq> v \\<Longrightarrow> x \\<in> dom (discovered s') \\<union> V0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<noteq> v \\<Longrightarrow> x \\<in> dom (discovered s') \\<union> V0", "case False"], ["proof (state)\nthis:\n  x \\<noteq> v\n\ngoal (1 subgoal):\n 1. x \\<noteq> v \\<Longrightarrow> x \\<in> dom (discovered s') \\<union> V0", "with y"], ["proof (chain)\npicking this:\n  (y, x) \\<in> (tree_edges s')\\<^sup>+\n  y \\<in> V0\n  x \\<noteq> v", "have \"(y,x) \\<in> (tree_edges s)\\<^sup>+\""], ["proof (prove)\nusing this:\n  (y, x) \\<in> (tree_edges s')\\<^sup>+\n  y \\<in> V0\n  x \\<noteq> v\n\ngoal (1 subgoal):\n 1. (y, x) \\<in> (tree_edges s)\\<^sup>+", "proof (induct rule: trancl_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ya.\n       \\<lbrakk>(y, ya) \\<in> tree_edges s'; y \\<in> V0;\n        ya \\<noteq> v\\<rbrakk>\n       \\<Longrightarrow> (y, ya) \\<in> (tree_edges s)\\<^sup>+\n 2. \\<And>ya z.\n       \\<lbrakk>(y, ya) \\<in> (tree_edges s')\\<^sup>+;\n        (ya, z) \\<in> tree_edges s';\n        \\<lbrakk>y \\<in> V0; ya \\<noteq> v\\<rbrakk>\n        \\<Longrightarrow> (y, ya) \\<in> (tree_edges s)\\<^sup>+;\n        y \\<in> V0; z \\<noteq> v\\<rbrakk>\n       \\<Longrightarrow> (y, z) \\<in> (tree_edges s)\\<^sup>+", "case (step a b)"], ["proof (state)\nthis:\n  (y, a) \\<in> (tree_edges s')\\<^sup>+\n  (a, b) \\<in> tree_edges s'\n  \\<lbrakk>y \\<in> V0; a \\<noteq> v\\<rbrakk>\n  \\<Longrightarrow> (y, a) \\<in> (tree_edges s)\\<^sup>+\n  y \\<in> V0\n  b \\<noteq> v\n\ngoal (2 subgoals):\n 1. \\<And>ya.\n       \\<lbrakk>(y, ya) \\<in> tree_edges s'; y \\<in> V0;\n        ya \\<noteq> v\\<rbrakk>\n       \\<Longrightarrow> (y, ya) \\<in> (tree_edges s)\\<^sup>+\n 2. \\<And>ya z.\n       \\<lbrakk>(y, ya) \\<in> (tree_edges s')\\<^sup>+;\n        (ya, z) \\<in> tree_edges s';\n        \\<lbrakk>y \\<in> V0; ya \\<noteq> v\\<rbrakk>\n        \\<Longrightarrow> (y, ya) \\<in> (tree_edges s)\\<^sup>+;\n        y \\<in> V0; z \\<noteq> v\\<rbrakk>\n       \\<Longrightarrow> (y, z) \\<in> (tree_edges s)\\<^sup>+", "hence \"(a,b) \\<in> tree_edges s\""], ["proof (prove)\nusing this:\n  (y, a) \\<in> (tree_edges s')\\<^sup>+\n  (a, b) \\<in> tree_edges s'\n  \\<lbrakk>y \\<in> V0; a \\<noteq> v\\<rbrakk>\n  \\<Longrightarrow> (y, a) \\<in> (tree_edges s)\\<^sup>+\n  y \\<in> V0\n  b \\<noteq> v\n\ngoal (1 subgoal):\n 1. (a, b) \\<in> tree_edges s", "by simp"], ["proof (state)\nthis:\n  (a, b) \\<in> tree_edges s\n\ngoal (2 subgoals):\n 1. \\<And>ya.\n       \\<lbrakk>(y, ya) \\<in> tree_edges s'; y \\<in> V0;\n        ya \\<noteq> v\\<rbrakk>\n       \\<Longrightarrow> (y, ya) \\<in> (tree_edges s)\\<^sup>+\n 2. \\<And>ya z.\n       \\<lbrakk>(y, ya) \\<in> (tree_edges s')\\<^sup>+;\n        (ya, z) \\<in> tree_edges s';\n        \\<lbrakk>y \\<in> V0; ya \\<noteq> v\\<rbrakk>\n        \\<Longrightarrow> (y, ya) \\<in> (tree_edges s)\\<^sup>+;\n        y \\<in> V0; z \\<noteq> v\\<rbrakk>\n       \\<Longrightarrow> (y, z) \\<in> (tree_edges s)\\<^sup>+", "with tree_edge_imp_discovered"], ["proof (chain)\npicking this:\n  (?v, ?w) \\<in> tree_edges s \\<Longrightarrow> ?v \\<in> dom (discovered s)\n  (?v, ?w) \\<in> tree_edges s \\<Longrightarrow> ?w \\<in> dom (discovered s)\n  (a, b) \\<in> tree_edges s", "have \"a \\<in> dom (discovered s)\""], ["proof (prove)\nusing this:\n  (?v, ?w) \\<in> tree_edges s \\<Longrightarrow> ?v \\<in> dom (discovered s)\n  (?v, ?w) \\<in> tree_edges s \\<Longrightarrow> ?w \\<in> dom (discovered s)\n  (a, b) \\<in> tree_edges s\n\ngoal (1 subgoal):\n 1. a \\<in> dom (discovered s)", "by simp"], ["proof (state)\nthis:\n  a \\<in> dom (discovered s)\n\ngoal (2 subgoals):\n 1. \\<And>ya.\n       \\<lbrakk>(y, ya) \\<in> tree_edges s'; y \\<in> V0;\n        ya \\<noteq> v\\<rbrakk>\n       \\<Longrightarrow> (y, ya) \\<in> (tree_edges s)\\<^sup>+\n 2. \\<And>ya z.\n       \\<lbrakk>(y, ya) \\<in> (tree_edges s')\\<^sup>+;\n        (ya, z) \\<in> tree_edges s';\n        \\<lbrakk>y \\<in> V0; ya \\<noteq> v\\<rbrakk>\n        \\<Longrightarrow> (y, ya) \\<in> (tree_edges s)\\<^sup>+;\n        y \\<in> V0; z \\<noteq> v\\<rbrakk>\n       \\<Longrightarrow> (y, z) \\<in> (tree_edges s)\\<^sup>+", "with discover"], ["proof (chain)\npicking this:\n  tree_discovered_inv s\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s \\<noteq> []\n  v \\<in> pending s `` {u}\n  v \\<notin> dom (discovered s)\n  u = hd (stack s)\n  s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n  \\<lparr>state.more := e_\\<rparr>\n  a \\<in> dom (discovered s)", "have \"a \\<noteq> v\""], ["proof (prove)\nusing this:\n  tree_discovered_inv s\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s \\<noteq> []\n  v \\<in> pending s `` {u}\n  v \\<notin> dom (discovered s)\n  u = hd (stack s)\n  s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n  \\<lparr>state.more := e_\\<rparr>\n  a \\<in> dom (discovered s)\n\ngoal (1 subgoal):\n 1. a \\<noteq> v", "by blast"], ["proof (state)\nthis:\n  a \\<noteq> v\n\ngoal (2 subgoals):\n 1. \\<And>ya.\n       \\<lbrakk>(y, ya) \\<in> tree_edges s'; y \\<in> V0;\n        ya \\<noteq> v\\<rbrakk>\n       \\<Longrightarrow> (y, ya) \\<in> (tree_edges s)\\<^sup>+\n 2. \\<And>ya z.\n       \\<lbrakk>(y, ya) \\<in> (tree_edges s')\\<^sup>+;\n        (ya, z) \\<in> tree_edges s';\n        \\<lbrakk>y \\<in> V0; ya \\<noteq> v\\<rbrakk>\n        \\<Longrightarrow> (y, ya) \\<in> (tree_edges s)\\<^sup>+;\n        y \\<in> V0; z \\<noteq> v\\<rbrakk>\n       \\<Longrightarrow> (y, z) \\<in> (tree_edges s)\\<^sup>+", "with step"], ["proof (chain)\npicking this:\n  (y, a) \\<in> (tree_edges s')\\<^sup>+\n  (a, b) \\<in> tree_edges s'\n  \\<lbrakk>y \\<in> V0; a \\<noteq> v\\<rbrakk>\n  \\<Longrightarrow> (y, a) \\<in> (tree_edges s)\\<^sup>+\n  y \\<in> V0\n  b \\<noteq> v\n  a \\<noteq> v", "show ?case"], ["proof (prove)\nusing this:\n  (y, a) \\<in> (tree_edges s')\\<^sup>+\n  (a, b) \\<in> tree_edges s'\n  \\<lbrakk>y \\<in> V0; a \\<noteq> v\\<rbrakk>\n  \\<Longrightarrow> (y, a) \\<in> (tree_edges s)\\<^sup>+\n  y \\<in> V0\n  b \\<noteq> v\n  a \\<noteq> v\n\ngoal (1 subgoal):\n 1. (y, b) \\<in> (tree_edges s)\\<^sup>+", "by auto"], ["proof (state)\nthis:\n  (y, b) \\<in> (tree_edges s)\\<^sup>+\n\ngoal (1 subgoal):\n 1. \\<And>ya.\n       \\<lbrakk>(y, ya) \\<in> tree_edges s'; y \\<in> V0;\n        ya \\<noteq> v\\<rbrakk>\n       \\<Longrightarrow> (y, ya) \\<in> (tree_edges s)\\<^sup>+", "qed simp"], ["proof (state)\nthis:\n  (y, x) \\<in> (tree_edges s)\\<^sup>+\n\ngoal (1 subgoal):\n 1. x \\<noteq> v \\<Longrightarrow> x \\<in> dom (discovered s') \\<union> V0", "with \\<open>y \\<in> V0\\<close>"], ["proof (chain)\npicking this:\n  y \\<in> V0\n  (y, x) \\<in> (tree_edges s)\\<^sup>+", "have \"x \\<in> (tree_edges s)\\<^sup>+ `` V0\""], ["proof (prove)\nusing this:\n  y \\<in> V0\n  (y, x) \\<in> (tree_edges s)\\<^sup>+\n\ngoal (1 subgoal):\n 1. x \\<in> (tree_edges s)\\<^sup>+ `` V0", "by auto"], ["proof (state)\nthis:\n  x \\<in> (tree_edges s)\\<^sup>+ `` V0\n\ngoal (1 subgoal):\n 1. x \\<noteq> v \\<Longrightarrow> x \\<in> dom (discovered s') \\<union> V0", "with t_ne TDI"], ["proof (chain)\npicking this:\n  tree_edges s \\<noteq> {}\n  (tree_edges s = {} \\<longrightarrow>\n   dom (discovered s) \\<subseteq> V0 \\<and>\n   (stack s = [] \\<or> (\\<exists>v0\\<in>V0. stack s = [v0]))) \\<and>\n  (tree_edges s \\<noteq> {} \\<longrightarrow>\n   (tree_edges s)\\<^sup>+ `` V0 \\<union> V0 =\n   dom (discovered s) \\<union> V0)\n  x \\<in> (tree_edges s)\\<^sup>+ `` V0", "show ?thesis"], ["proof (prove)\nusing this:\n  tree_edges s \\<noteq> {}\n  (tree_edges s = {} \\<longrightarrow>\n   dom (discovered s) \\<subseteq> V0 \\<and>\n   (stack s = [] \\<or> (\\<exists>v0\\<in>V0. stack s = [v0]))) \\<and>\n  (tree_edges s \\<noteq> {} \\<longrightarrow>\n   (tree_edges s)\\<^sup>+ `` V0 \\<union> V0 =\n   dom (discovered s) \\<union> V0)\n  x \\<in> (tree_edges s)\\<^sup>+ `` V0\n\ngoal (1 subgoal):\n 1. x \\<in> dom (discovered s') \\<union> V0", "by auto"], ["proof (state)\nthis:\n  x \\<in> dom (discovered s') \\<union> V0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x \\<in> dom (discovered s') \\<union> V0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x \\<in> dom (discovered s') \\<union> V0\n\ngoal (5 subgoals):\n 1. \\<And>e. tree_discovered_inv (empty_state e)\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>tree_discovered_inv s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s = []; v0 \\<notin> dom (discovered s);\n        v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> tree_discovered_inv s'\n 3. \\<And>s s' u e.\n       \\<lbrakk>tree_discovered_inv s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; pending s `` {u} = {};\n        u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> tree_discovered_inv s'\n 4. \\<And>s s' u v e c b.\n       \\<lbrakk>tree_discovered_inv s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); u = hd (stack s);\n        cross_edges s \\<subseteq> c; back_edges s \\<subseteq> b;\n        s' = s\n        \\<lparr>pending := pending s - {(u, v)}, state.more := e,\n           cross_edges := c, back_edges := b\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> tree_discovered_inv s'\n 5. \\<And>s s' u v e.\n       \\<lbrakk>tree_discovered_inv s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> tree_discovered_inv s'", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?x9 \\<in> (tree_edges s')\\<^sup>+ `` V0 \\<union> V0;\n   ?x9 \\<notin> V0\\<rbrakk>\n  \\<Longrightarrow> ?x9 \\<in> dom (discovered s') \\<union> V0\n\ngoal (5 subgoals):\n 1. \\<And>e. tree_discovered_inv (empty_state e)\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>tree_discovered_inv s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s = []; v0 \\<notin> dom (discovered s);\n        v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> tree_discovered_inv s'\n 3. \\<And>s s' u e.\n       \\<lbrakk>tree_discovered_inv s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; pending s `` {u} = {};\n        u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> tree_discovered_inv s'\n 4. \\<And>s s' u v e c b.\n       \\<lbrakk>tree_discovered_inv s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); u = hd (stack s);\n        cross_edges s \\<subseteq> c; back_edges s \\<subseteq> b;\n        s' = s\n        \\<lparr>pending := pending s - {(u, v)}, state.more := e,\n           cross_edges := c, back_edges := b\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> tree_discovered_inv s'\n 5. \\<And>s s' u v e.\n       \\<lbrakk>tree_discovered_inv s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> tree_discovered_inv s'", "note t_d = this"], ["proof (state)\nthis:\n  \\<lbrakk>?x9 \\<in> (tree_edges s')\\<^sup>+ `` V0 \\<union> V0;\n   ?x9 \\<notin> V0\\<rbrakk>\n  \\<Longrightarrow> ?x9 \\<in> dom (discovered s') \\<union> V0\n\ngoal (5 subgoals):\n 1. \\<And>e. tree_discovered_inv (empty_state e)\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>tree_discovered_inv s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s = []; v0 \\<notin> dom (discovered s);\n        v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> tree_discovered_inv s'\n 3. \\<And>s s' u e.\n       \\<lbrakk>tree_discovered_inv s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; pending s `` {u} = {};\n        u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> tree_discovered_inv s'\n 4. \\<And>s s' u v e c b.\n       \\<lbrakk>tree_discovered_inv s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); u = hd (stack s);\n        cross_edges s \\<subseteq> c; back_edges s \\<subseteq> b;\n        s' = s\n        \\<lparr>pending := pending s - {(u, v)}, state.more := e,\n           cross_edges := c, back_edges := b\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> tree_discovered_inv s'\n 5. \\<And>s s' u v e.\n       \\<lbrakk>tree_discovered_inv s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> tree_discovered_inv s'", "{"], ["proof (state)\nthis:\n  \\<lbrakk>?x9 \\<in> (tree_edges s')\\<^sup>+ `` V0 \\<union> V0;\n   ?x9 \\<notin> V0\\<rbrakk>\n  \\<Longrightarrow> ?x9 \\<in> dom (discovered s') \\<union> V0\n\ngoal (5 subgoals):\n 1. \\<And>e. tree_discovered_inv (empty_state e)\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>tree_discovered_inv s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s = []; v0 \\<notin> dom (discovered s);\n        v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> tree_discovered_inv s'\n 3. \\<And>s s' u e.\n       \\<lbrakk>tree_discovered_inv s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; pending s `` {u} = {};\n        u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> tree_discovered_inv s'\n 4. \\<And>s s' u v e c b.\n       \\<lbrakk>tree_discovered_inv s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); u = hd (stack s);\n        cross_edges s \\<subseteq> c; back_edges s \\<subseteq> b;\n        s' = s\n        \\<lparr>pending := pending s - {(u, v)}, state.more := e,\n           cross_edges := c, back_edges := b\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> tree_discovered_inv s'\n 5. \\<And>s s' u v e.\n       \\<lbrakk>tree_discovered_inv s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> tree_discovered_inv s'", "fix x"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>e. tree_discovered_inv (empty_state e)\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>tree_discovered_inv s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s = []; v0 \\<notin> dom (discovered s);\n        v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> tree_discovered_inv s'\n 3. \\<And>s s' u e.\n       \\<lbrakk>tree_discovered_inv s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; pending s `` {u} = {};\n        u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> tree_discovered_inv s'\n 4. \\<And>s s' u v e c b.\n       \\<lbrakk>tree_discovered_inv s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); u = hd (stack s);\n        cross_edges s \\<subseteq> c; back_edges s \\<subseteq> b;\n        s' = s\n        \\<lparr>pending := pending s - {(u, v)}, state.more := e,\n           cross_edges := c, back_edges := b\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> tree_discovered_inv s'\n 5. \\<And>s s' u v e.\n       \\<lbrakk>tree_discovered_inv s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> tree_discovered_inv s'", "assume \"x \\<in> dom (discovered s') \\<union> V0\" \"x \\<notin> V0\""], ["proof (state)\nthis:\n  x \\<in> dom (discovered s') \\<union> V0\n  x \\<notin> V0\n\ngoal (5 subgoals):\n 1. \\<And>e. tree_discovered_inv (empty_state e)\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>tree_discovered_inv s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s = []; v0 \\<notin> dom (discovered s);\n        v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> tree_discovered_inv s'\n 3. \\<And>s s' u e.\n       \\<lbrakk>tree_discovered_inv s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; pending s `` {u} = {};\n        u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> tree_discovered_inv s'\n 4. \\<And>s s' u v e c b.\n       \\<lbrakk>tree_discovered_inv s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); u = hd (stack s);\n        cross_edges s \\<subseteq> c; back_edges s \\<subseteq> b;\n        s' = s\n        \\<lparr>pending := pending s - {(u, v)}, state.more := e,\n           cross_edges := c, back_edges := b\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> tree_discovered_inv s'\n 5. \\<And>s s' u v e.\n       \\<lbrakk>tree_discovered_inv s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> tree_discovered_inv s'", "hence A: \"x \\<in> dom (discovered s')\""], ["proof (prove)\nusing this:\n  x \\<in> dom (discovered s') \\<union> V0\n  x \\<notin> V0\n\ngoal (1 subgoal):\n 1. x \\<in> dom (discovered s')", "by simp"], ["proof (state)\nthis:\n  x \\<in> dom (discovered s')\n\ngoal (5 subgoals):\n 1. \\<And>e. tree_discovered_inv (empty_state e)\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>tree_discovered_inv s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s = []; v0 \\<notin> dom (discovered s);\n        v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> tree_discovered_inv s'\n 3. \\<And>s s' u e.\n       \\<lbrakk>tree_discovered_inv s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; pending s `` {u} = {};\n        u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> tree_discovered_inv s'\n 4. \\<And>s s' u v e c b.\n       \\<lbrakk>tree_discovered_inv s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); u = hd (stack s);\n        cross_edges s \\<subseteq> c; back_edges s \\<subseteq> b;\n        s' = s\n        \\<lparr>pending := pending s - {(u, v)}, state.more := e,\n           cross_edges := c, back_edges := b\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> tree_discovered_inv s'\n 5. \\<And>s s' u v e.\n       \\<lbrakk>tree_discovered_inv s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> tree_discovered_inv s'", "have \"x \\<in> (tree_edges s')\\<^sup>+ `` V0 \\<union> V0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> (tree_edges s')\\<^sup>+ `` V0 \\<union> V0", "proof (cases \"tree_edges s = {}\")"], ["proof (state)\ngoal (2 subgoals):\n 1. tree_edges s = {} \\<Longrightarrow>\n    x \\<in> (tree_edges s')\\<^sup>+ `` V0 \\<union> V0\n 2. tree_edges s \\<noteq> {} \\<Longrightarrow>\n    x \\<in> (tree_edges s')\\<^sup>+ `` V0 \\<union> V0", "case True"], ["proof (state)\nthis:\n  tree_edges s = {}\n\ngoal (2 subgoals):\n 1. tree_edges s = {} \\<Longrightarrow>\n    x \\<in> (tree_edges s')\\<^sup>+ `` V0 \\<union> V0\n 2. tree_edges s \\<noteq> {} \\<Longrightarrow>\n    x \\<in> (tree_edges s')\\<^sup>+ `` V0 \\<union> V0", "with trancl_single"], ["proof (chain)\npicking this:\n  {(?a, ?b)}\\<^sup>+ = {(?a, ?b)}\n  tree_edges s = {}", "have \"(tree_edges s')\\<^sup>+ = {(hd (stack s), v)}\""], ["proof (prove)\nusing this:\n  {(?a, ?b)}\\<^sup>+ = {(?a, ?b)}\n  tree_edges s = {}\n\ngoal (1 subgoal):\n 1. (tree_edges s')\\<^sup>+ = {(hd (stack s), v)}", "by simp"], ["proof (state)\nthis:\n  (tree_edges s')\\<^sup>+ = {(hd (stack s), v)}\n\ngoal (2 subgoals):\n 1. tree_edges s = {} \\<Longrightarrow>\n    x \\<in> (tree_edges s')\\<^sup>+ `` V0 \\<union> V0\n 2. tree_edges s \\<noteq> {} \\<Longrightarrow>\n    x \\<in> (tree_edges s')\\<^sup>+ `` V0 \\<union> V0", "moreover"], ["proof (state)\nthis:\n  (tree_edges s')\\<^sup>+ = {(hd (stack s), v)}\n\ngoal (2 subgoals):\n 1. tree_edges s = {} \\<Longrightarrow>\n    x \\<in> (tree_edges s')\\<^sup>+ `` V0 \\<union> V0\n 2. tree_edges s \\<noteq> {} \\<Longrightarrow>\n    x \\<in> (tree_edges s')\\<^sup>+ `` V0 \\<union> V0", "from True TDI"], ["proof (chain)\npicking this:\n  tree_edges s = {}\n  (tree_edges s = {} \\<longrightarrow>\n   dom (discovered s) \\<subseteq> V0 \\<and>\n   (stack s = [] \\<or> (\\<exists>v0\\<in>V0. stack s = [v0]))) \\<and>\n  (tree_edges s \\<noteq> {} \\<longrightarrow>\n   (tree_edges s)\\<^sup>+ `` V0 \\<union> V0 =\n   dom (discovered s) \\<union> V0)", "have \"hd (stack s) \\<in> V0\" \"dom (discovered s) \\<subseteq> V0\""], ["proof (prove)\nusing this:\n  tree_edges s = {}\n  (tree_edges s = {} \\<longrightarrow>\n   dom (discovered s) \\<subseteq> V0 \\<and>\n   (stack s = [] \\<or> (\\<exists>v0\\<in>V0. stack s = [v0]))) \\<and>\n  (tree_edges s \\<noteq> {} \\<longrightarrow>\n   (tree_edges s)\\<^sup>+ `` V0 \\<union> V0 =\n   dom (discovered s) \\<union> V0)\n\ngoal (1 subgoal):\n 1. hd (stack s) \\<in> V0 &&& dom (discovered s) \\<subseteq> V0", "by auto"], ["proof (state)\nthis:\n  hd (stack s) \\<in> V0\n  dom (discovered s) \\<subseteq> V0\n\ngoal (2 subgoals):\n 1. tree_edges s = {} \\<Longrightarrow>\n    x \\<in> (tree_edges s')\\<^sup>+ `` V0 \\<union> V0\n 2. tree_edges s \\<noteq> {} \\<Longrightarrow>\n    x \\<in> (tree_edges s')\\<^sup>+ `` V0 \\<union> V0", "ultimately"], ["proof (chain)\npicking this:\n  (tree_edges s')\\<^sup>+ = {(hd (stack s), v)}\n  hd (stack s) \\<in> V0\n  dom (discovered s) \\<subseteq> V0", "show ?thesis"], ["proof (prove)\nusing this:\n  (tree_edges s')\\<^sup>+ = {(hd (stack s), v)}\n  hd (stack s) \\<in> V0\n  dom (discovered s) \\<subseteq> V0\n\ngoal (1 subgoal):\n 1. x \\<in> (tree_edges s')\\<^sup>+ `` V0 \\<union> V0", "using A \\<open>x\\<notin>V0\\<close>"], ["proof (prove)\nusing this:\n  (tree_edges s')\\<^sup>+ = {(hd (stack s), v)}\n  hd (stack s) \\<in> V0\n  dom (discovered s) \\<subseteq> V0\n  x \\<in> dom (discovered s')\n  x \\<notin> V0\n\ngoal (1 subgoal):\n 1. x \\<in> (tree_edges s')\\<^sup>+ `` V0 \\<union> V0", "by auto"], ["proof (state)\nthis:\n  x \\<in> (tree_edges s')\\<^sup>+ `` V0 \\<union> V0\n\ngoal (1 subgoal):\n 1. tree_edges s \\<noteq> {} \\<Longrightarrow>\n    x \\<in> (tree_edges s')\\<^sup>+ `` V0 \\<union> V0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. tree_edges s \\<noteq> {} \\<Longrightarrow>\n    x \\<in> (tree_edges s')\\<^sup>+ `` V0 \\<union> V0", "case False"], ["proof (state)\nthis:\n  tree_edges s \\<noteq> {}\n\ngoal (1 subgoal):\n 1. tree_edges s \\<noteq> {} \\<Longrightarrow>\n    x \\<in> (tree_edges s')\\<^sup>+ `` V0 \\<union> V0", "note t_ne = this"], ["proof (state)\nthis:\n  tree_edges s \\<noteq> {}\n\ngoal (1 subgoal):\n 1. tree_edges s \\<noteq> {} \\<Longrightarrow>\n    x \\<in> (tree_edges s')\\<^sup>+ `` V0 \\<union> V0", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> (tree_edges s')\\<^sup>+ `` V0 \\<union> V0", "proof (cases \"x=v\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x = v \\<Longrightarrow>\n    x \\<in> (tree_edges s')\\<^sup>+ `` V0 \\<union> V0\n 2. x \\<noteq> v \\<Longrightarrow>\n    x \\<in> (tree_edges s')\\<^sup>+ `` V0 \\<union> V0", "case False"], ["proof (state)\nthis:\n  x \\<noteq> v\n\ngoal (2 subgoals):\n 1. x = v \\<Longrightarrow>\n    x \\<in> (tree_edges s')\\<^sup>+ `` V0 \\<union> V0\n 2. x \\<noteq> v \\<Longrightarrow>\n    x \\<in> (tree_edges s')\\<^sup>+ `` V0 \\<union> V0", "with A"], ["proof (chain)\npicking this:\n  x \\<in> dom (discovered s')\n  x \\<noteq> v", "have \"x \\<in> dom (discovered s)\""], ["proof (prove)\nusing this:\n  x \\<in> dom (discovered s')\n  x \\<noteq> v\n\ngoal (1 subgoal):\n 1. x \\<in> dom (discovered s)", "by simp"], ["proof (state)\nthis:\n  x \\<in> dom (discovered s)\n\ngoal (2 subgoals):\n 1. x = v \\<Longrightarrow>\n    x \\<in> (tree_edges s')\\<^sup>+ `` V0 \\<union> V0\n 2. x \\<noteq> v \\<Longrightarrow>\n    x \\<in> (tree_edges s')\\<^sup>+ `` V0 \\<union> V0", "with TDI t_ne \\<open>x \\<notin> V0\\<close>"], ["proof (chain)\npicking this:\n  (tree_edges s = {} \\<longrightarrow>\n   dom (discovered s) \\<subseteq> V0 \\<and>\n   (stack s = [] \\<or> (\\<exists>v0\\<in>V0. stack s = [v0]))) \\<and>\n  (tree_edges s \\<noteq> {} \\<longrightarrow>\n   (tree_edges s)\\<^sup>+ `` V0 \\<union> V0 =\n   dom (discovered s) \\<union> V0)\n  tree_edges s \\<noteq> {}\n  x \\<notin> V0\n  x \\<in> dom (discovered s)", "have \"x \\<in> (tree_edges s)\\<^sup>+ `` V0\""], ["proof (prove)\nusing this:\n  (tree_edges s = {} \\<longrightarrow>\n   dom (discovered s) \\<subseteq> V0 \\<and>\n   (stack s = [] \\<or> (\\<exists>v0\\<in>V0. stack s = [v0]))) \\<and>\n  (tree_edges s \\<noteq> {} \\<longrightarrow>\n   (tree_edges s)\\<^sup>+ `` V0 \\<union> V0 =\n   dom (discovered s) \\<union> V0)\n  tree_edges s \\<noteq> {}\n  x \\<notin> V0\n  x \\<in> dom (discovered s)\n\ngoal (1 subgoal):\n 1. x \\<in> (tree_edges s)\\<^sup>+ `` V0", "by auto"], ["proof (state)\nthis:\n  x \\<in> (tree_edges s)\\<^sup>+ `` V0\n\ngoal (2 subgoals):\n 1. x = v \\<Longrightarrow>\n    x \\<in> (tree_edges s')\\<^sup>+ `` V0 \\<union> V0\n 2. x \\<noteq> v \\<Longrightarrow>\n    x \\<in> (tree_edges s')\\<^sup>+ `` V0 \\<union> V0", "with trancl_sub_insert_trancl"], ["proof (chain)\npicking this:\n  ?R\\<^sup>+ \\<subseteq> (insert ?x ?R)\\<^sup>+\n  x \\<in> (tree_edges s)\\<^sup>+ `` V0", "show ?thesis"], ["proof (prove)\nusing this:\n  ?R\\<^sup>+ \\<subseteq> (insert ?x ?R)\\<^sup>+\n  x \\<in> (tree_edges s)\\<^sup>+ `` V0\n\ngoal (1 subgoal):\n 1. x \\<in> (tree_edges s')\\<^sup>+ `` V0 \\<union> V0", "by simp blast"], ["proof (state)\nthis:\n  x \\<in> (tree_edges s')\\<^sup>+ `` V0 \\<union> V0\n\ngoal (1 subgoal):\n 1. x = v \\<Longrightarrow>\n    x \\<in> (tree_edges s')\\<^sup>+ `` V0 \\<union> V0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x = v \\<Longrightarrow>\n    x \\<in> (tree_edges s')\\<^sup>+ `` V0 \\<union> V0", "case True"], ["proof (state)\nthis:\n  x = v\n\ngoal (1 subgoal):\n 1. x = v \\<Longrightarrow>\n    x \\<in> (tree_edges s')\\<^sup>+ `` V0 \\<union> V0", "from t_ne TDI"], ["proof (chain)\npicking this:\n  tree_edges s \\<noteq> {}\n  (tree_edges s = {} \\<longrightarrow>\n   dom (discovered s) \\<subseteq> V0 \\<and>\n   (stack s = [] \\<or> (\\<exists>v0\\<in>V0. stack s = [v0]))) \\<and>\n  (tree_edges s \\<noteq> {} \\<longrightarrow>\n   (tree_edges s)\\<^sup>+ `` V0 \\<union> V0 =\n   dom (discovered s) \\<union> V0)", "have \"dom (discovered s) \\<union> V0 = (tree_edges s)\\<^sup>+ `` V0 \\<union> V0\""], ["proof (prove)\nusing this:\n  tree_edges s \\<noteq> {}\n  (tree_edges s = {} \\<longrightarrow>\n   dom (discovered s) \\<subseteq> V0 \\<and>\n   (stack s = [] \\<or> (\\<exists>v0\\<in>V0. stack s = [v0]))) \\<and>\n  (tree_edges s \\<noteq> {} \\<longrightarrow>\n   (tree_edges s)\\<^sup>+ `` V0 \\<union> V0 =\n   dom (discovered s) \\<union> V0)\n\ngoal (1 subgoal):\n 1. dom (discovered s) \\<union> V0 =\n    (tree_edges s)\\<^sup>+ `` V0 \\<union> V0", "by simp"], ["proof (state)\nthis:\n  dom (discovered s) \\<union> V0 = (tree_edges s)\\<^sup>+ `` V0 \\<union> V0\n\ngoal (1 subgoal):\n 1. x = v \\<Longrightarrow>\n    x \\<in> (tree_edges s')\\<^sup>+ `` V0 \\<union> V0", "moreover"], ["proof (state)\nthis:\n  dom (discovered s) \\<union> V0 = (tree_edges s)\\<^sup>+ `` V0 \\<union> V0\n\ngoal (1 subgoal):\n 1. x = v \\<Longrightarrow>\n    x \\<in> (tree_edges s')\\<^sup>+ `` V0 \\<union> V0", "from stack_is_tree_path[OF NE]"], ["proof (chain)\npicking this:\n  \\<exists>v0\\<in>V0.\n     path (tree_edges s) v0 (rev (tl (stack s))) (hd (stack s))", "obtain v0 where \"v0 \\<in> V0\" and \n            \"(v0, hd (stack s)) \\<in> (tree_edges s)\\<^sup>*\""], ["proof (prove)\nusing this:\n  \\<exists>v0\\<in>V0.\n     path (tree_edges s) v0 (rev (tl (stack s))) (hd (stack s))\n\ngoal (1 subgoal):\n 1. (\\<And>v0.\n        \\<lbrakk>v0 \\<in> V0;\n         (v0, hd (stack s)) \\<in> (tree_edges s)\\<^sup>*\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (blast intro!: path_is_rtrancl)"], ["proof (state)\nthis:\n  v0 \\<in> V0\n  (v0, hd (stack s)) \\<in> (tree_edges s)\\<^sup>*\n\ngoal (1 subgoal):\n 1. x = v \\<Longrightarrow>\n    x \\<in> (tree_edges s')\\<^sup>+ `` V0 \\<union> V0", "with EQ"], ["proof (chain)\npicking this:\n  stack s' = v # stack s\n  tree_edges s' = insert (hd (stack s), v) (tree_edges s)\n  discovered s' = discovered s(v \\<mapsto> counter s)\n  v0 \\<in> V0\n  (v0, hd (stack s)) \\<in> (tree_edges s)\\<^sup>*", "have \"(v0, hd (stack s)) \\<in> (tree_edges s')\\<^sup>*\""], ["proof (prove)\nusing this:\n  stack s' = v # stack s\n  tree_edges s' = insert (hd (stack s), v) (tree_edges s)\n  discovered s' = discovered s(v \\<mapsto> counter s)\n  v0 \\<in> V0\n  (v0, hd (stack s)) \\<in> (tree_edges s)\\<^sup>*\n\ngoal (1 subgoal):\n 1. (v0, hd (stack s)) \\<in> (tree_edges s')\\<^sup>*", "by (auto intro: rtrancl_mono_mp)"], ["proof (state)\nthis:\n  (v0, hd (stack s)) \\<in> (tree_edges s')\\<^sup>*\n\ngoal (1 subgoal):\n 1. x = v \\<Longrightarrow>\n    x \\<in> (tree_edges s')\\<^sup>+ `` V0 \\<union> V0", "ultimately"], ["proof (chain)\npicking this:\n  dom (discovered s) \\<union> V0 = (tree_edges s)\\<^sup>+ `` V0 \\<union> V0\n  (v0, hd (stack s)) \\<in> (tree_edges s')\\<^sup>*", "show ?thesis"], ["proof (prove)\nusing this:\n  dom (discovered s) \\<union> V0 = (tree_edges s)\\<^sup>+ `` V0 \\<union> V0\n  (v0, hd (stack s)) \\<in> (tree_edges s')\\<^sup>*\n\ngoal (1 subgoal):\n 1. x \\<in> (tree_edges s')\\<^sup>+ `` V0 \\<union> V0", "using \\<open>v0 \\<in> V0\\<close> True"], ["proof (prove)\nusing this:\n  dom (discovered s) \\<union> V0 = (tree_edges s)\\<^sup>+ `` V0 \\<union> V0\n  (v0, hd (stack s)) \\<in> (tree_edges s')\\<^sup>*\n  v0 \\<in> V0\n  x = v\n\ngoal (1 subgoal):\n 1. x \\<in> (tree_edges s')\\<^sup>+ `` V0 \\<union> V0", "by (auto elim: rtrancl_into_trancl1)"], ["proof (state)\nthis:\n  x \\<in> (tree_edges s')\\<^sup>+ `` V0 \\<union> V0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x \\<in> (tree_edges s')\\<^sup>+ `` V0 \\<union> V0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x \\<in> (tree_edges s')\\<^sup>+ `` V0 \\<union> V0\n\ngoal (5 subgoals):\n 1. \\<And>e. tree_discovered_inv (empty_state e)\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>tree_discovered_inv s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s = []; v0 \\<notin> dom (discovered s);\n        v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> tree_discovered_inv s'\n 3. \\<And>s s' u e.\n       \\<lbrakk>tree_discovered_inv s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; pending s `` {u} = {};\n        u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> tree_discovered_inv s'\n 4. \\<And>s s' u v e c b.\n       \\<lbrakk>tree_discovered_inv s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); u = hd (stack s);\n        cross_edges s \\<subseteq> c; back_edges s \\<subseteq> b;\n        s' = s\n        \\<lparr>pending := pending s - {(u, v)}, state.more := e,\n           cross_edges := c, back_edges := b\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> tree_discovered_inv s'\n 5. \\<And>s s' u v e.\n       \\<lbrakk>tree_discovered_inv s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> tree_discovered_inv s'", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?x9 \\<in> dom (discovered s') \\<union> V0;\n   ?x9 \\<notin> V0\\<rbrakk>\n  \\<Longrightarrow> ?x9 \\<in> (tree_edges s')\\<^sup>+ `` V0 \\<union> V0\n\ngoal (5 subgoals):\n 1. \\<And>e. tree_discovered_inv (empty_state e)\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>tree_discovered_inv s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s = []; v0 \\<notin> dom (discovered s);\n        v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> tree_discovered_inv s'\n 3. \\<And>s s' u e.\n       \\<lbrakk>tree_discovered_inv s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; pending s `` {u} = {};\n        u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> tree_discovered_inv s'\n 4. \\<And>s s' u v e c b.\n       \\<lbrakk>tree_discovered_inv s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); u = hd (stack s);\n        cross_edges s \\<subseteq> c; back_edges s \\<subseteq> b;\n        s' = s\n        \\<lparr>pending := pending s - {(u, v)}, state.more := e,\n           cross_edges := c, back_edges := b\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> tree_discovered_inv s'\n 5. \\<And>s s' u v e.\n       \\<lbrakk>tree_discovered_inv s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> tree_discovered_inv s'", "with t_d"], ["proof (chain)\npicking this:\n  \\<lbrakk>?x9 \\<in> (tree_edges s')\\<^sup>+ `` V0 \\<union> V0;\n   ?x9 \\<notin> V0\\<rbrakk>\n  \\<Longrightarrow> ?x9 \\<in> dom (discovered s') \\<union> V0\n  \\<lbrakk>?x9 \\<in> dom (discovered s') \\<union> V0;\n   ?x9 \\<notin> V0\\<rbrakk>\n  \\<Longrightarrow> ?x9 \\<in> (tree_edges s')\\<^sup>+ `` V0 \\<union> V0", "have \"(tree_edges s')\\<^sup>+ `` V0 \\<union> V0 = dom (discovered s') \\<union> V0\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?x9 \\<in> (tree_edges s')\\<^sup>+ `` V0 \\<union> V0;\n   ?x9 \\<notin> V0\\<rbrakk>\n  \\<Longrightarrow> ?x9 \\<in> dom (discovered s') \\<union> V0\n  \\<lbrakk>?x9 \\<in> dom (discovered s') \\<union> V0;\n   ?x9 \\<notin> V0\\<rbrakk>\n  \\<Longrightarrow> ?x9 \\<in> (tree_edges s')\\<^sup>+ `` V0 \\<union> V0\n\ngoal (1 subgoal):\n 1. (tree_edges s')\\<^sup>+ `` V0 \\<union> V0 =\n    dom (discovered s') \\<union> V0", "by blast"], ["proof (state)\nthis:\n  (tree_edges s')\\<^sup>+ `` V0 \\<union> V0 =\n  dom (discovered s') \\<union> V0\n\ngoal (5 subgoals):\n 1. \\<And>e. tree_discovered_inv (empty_state e)\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>tree_discovered_inv s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s = []; v0 \\<notin> dom (discovered s);\n        v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> tree_discovered_inv s'\n 3. \\<And>s s' u e.\n       \\<lbrakk>tree_discovered_inv s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; pending s `` {u} = {};\n        u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> tree_discovered_inv s'\n 4. \\<And>s s' u v e c b.\n       \\<lbrakk>tree_discovered_inv s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); u = hd (stack s);\n        cross_edges s \\<subseteq> c; back_edges s \\<subseteq> b;\n        s' = s\n        \\<lparr>pending := pending s - {(u, v)}, state.more := e,\n           cross_edges := c, back_edges := b\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> tree_discovered_inv s'\n 5. \\<And>s s' u v e.\n       \\<lbrakk>tree_discovered_inv s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> tree_discovered_inv s'", "ultimately"], ["proof (chain)\npicking this:\n  tree_edges s' = {} \\<longrightarrow>\n  dom (discovered s') \\<subseteq> V0 \\<and>\n  (stack s' = [] \\<or> (\\<exists>v0\\<in>V0. stack s' = [v0]))\n  (tree_edges s')\\<^sup>+ `` V0 \\<union> V0 =\n  dom (discovered s') \\<union> V0", "show ?case"], ["proof (prove)\nusing this:\n  tree_edges s' = {} \\<longrightarrow>\n  dom (discovered s') \\<subseteq> V0 \\<and>\n  (stack s' = [] \\<or> (\\<exists>v0\\<in>V0. stack s' = [v0]))\n  (tree_edges s')\\<^sup>+ `` V0 \\<union> V0 =\n  dom (discovered s') \\<union> V0\n\ngoal (1 subgoal):\n 1. tree_discovered_inv s'", "by (simp add: tree_discovered_inv_def)"], ["proof (state)\nthis:\n  tree_discovered_inv s'\n\ngoal (4 subgoals):\n 1. \\<And>e. tree_discovered_inv (empty_state e)\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>tree_discovered_inv s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s = []; v0 \\<notin> dom (discovered s);\n        v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> tree_discovered_inv s'\n 3. \\<And>s s' u e.\n       \\<lbrakk>tree_discovered_inv s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; pending s `` {u} = {};\n        u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> tree_discovered_inv s'\n 4. \\<And>s s' u v e c b.\n       \\<lbrakk>tree_discovered_inv s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); u = hd (stack s);\n        cross_edges s \\<subseteq> c; back_edges s \\<subseteq> b;\n        s' = s\n        \\<lparr>pending := pending s - {(u, v)}, state.more := e,\n           cross_edges := c, back_edges := b\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> tree_discovered_inv s'", "qed (auto simp add: tree_discovered_inv_def)"], ["", "lemmas (in DFS_invar) tree_discovered_inv = \n    i_tree_discovered_inv[THEN make_invar_thm]"], ["", "lemma (in DFS_invar) discovered_iff_tree_path:\n    \"v \\<notin> V0 \\<Longrightarrow> v \\<in> dom (discovered s) \\<longleftrightarrow> (\\<exists>v0\\<in>V0. (v0,v) \\<in> (tree_edges s)\\<^sup>+)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<notin> V0 \\<Longrightarrow>\n    (v \\<in> dom (discovered s)) =\n    (\\<exists>v0\\<in>V0. (v0, v) \\<in> (tree_edges s)\\<^sup>+)", "using tree_discovered_inv"], ["proof (prove)\nusing this:\n  tree_discovered_inv s\n\ngoal (1 subgoal):\n 1. v \\<notin> V0 \\<Longrightarrow>\n    (v \\<in> dom (discovered s)) =\n    (\\<exists>v0\\<in>V0. (v0, v) \\<in> (tree_edges s)\\<^sup>+)", "by (auto simp add: tree_discovered_inv_def)"], ["", "lemma i_tree_one_predecessor:\n    \"is_invar (\\<lambda>s. \\<forall>(v,v') \\<in> tree_edges s. \\<forall>y. y \\<noteq> v \\<longrightarrow> (y,v') \\<notin> tree_edges s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_invar\n     (\\<lambda>s.\n         \\<forall>(v, v')\\<in>tree_edges s.\n            \\<forall>y.\n               y \\<noteq> v \\<longrightarrow> (y, v') \\<notin> tree_edges s)", "proof (induct rule: is_invarI)"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>e.\n       \\<forall>(v, v')\\<in>tree_edges (empty_state e).\n          \\<forall>y.\n             y \\<noteq> v \\<longrightarrow>\n             (y, v') \\<notin> tree_edges (empty_state e)\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>\\<forall>(v, v')\\<in>tree_edges s.\n                   \\<forall>y.\n                      y \\<noteq> v \\<longrightarrow>\n                      (y, v') \\<notin> tree_edges s;\n        cond s; DFS_invar G param s; DFS_invar G param s'; stack s = [];\n        v0 \\<notin> dom (discovered s); v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, v')\\<in>tree_edges s'.\n                            \\<forall>y.\n                               y \\<noteq> v \\<longrightarrow>\n                               (y, v') \\<notin> tree_edges s'\n 3. \\<And>s s' u e.\n       \\<lbrakk>\\<forall>(v, v')\\<in>tree_edges s.\n                   \\<forall>y.\n                      y \\<noteq> v \\<longrightarrow>\n                      (y, v') \\<notin> tree_edges s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; pending s `` {u} = {}; u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, v')\\<in>tree_edges s'.\n                            \\<forall>y.\n                               y \\<noteq> v \\<longrightarrow>\n                               (y, v') \\<notin> tree_edges s'\n 4. \\<And>s s' u v e c b.\n       \\<lbrakk>\\<forall>(v, v')\\<in>tree_edges s.\n                   \\<forall>y.\n                      y \\<noteq> v \\<longrightarrow>\n                      (y, v') \\<notin> tree_edges s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); u = hd (stack s);\n        cross_edges s \\<subseteq> c; back_edges s \\<subseteq> b;\n        s' = s\n        \\<lparr>pending := pending s - {(u, v)}, state.more := e,\n           cross_edges := c, back_edges := b\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, v')\\<in>tree_edges s'.\n                            \\<forall>y.\n                               y \\<noteq> v \\<longrightarrow>\n                               (y, v') \\<notin> tree_edges s'\n 5. \\<And>s s' u v e.\n       \\<lbrakk>\\<forall>(v, v')\\<in>tree_edges s.\n                   \\<forall>y.\n                      y \\<noteq> v \\<longrightarrow>\n                      (y, v') \\<notin> tree_edges s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, v')\\<in>tree_edges s'.\n                            \\<forall>y.\n                               y \\<noteq> v \\<longrightarrow>\n                               (y, v') \\<notin> tree_edges s'", "case (discover s s' u v)"], ["proof (state)\nthis:\n  \\<forall>(v, v')\\<in>tree_edges s.\n     \\<forall>y.\n        y \\<noteq> v \\<longrightarrow> (y, v') \\<notin> tree_edges s\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s \\<noteq> []\n  v \\<in> pending s `` {u}\n  v \\<notin> dom (discovered s)\n  u = hd (stack s)\n  s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n  \\<lparr>state.more := e_\\<rparr>\n\ngoal (5 subgoals):\n 1. \\<And>e.\n       \\<forall>(v, v')\\<in>tree_edges (empty_state e).\n          \\<forall>y.\n             y \\<noteq> v \\<longrightarrow>\n             (y, v') \\<notin> tree_edges (empty_state e)\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>\\<forall>(v, v')\\<in>tree_edges s.\n                   \\<forall>y.\n                      y \\<noteq> v \\<longrightarrow>\n                      (y, v') \\<notin> tree_edges s;\n        cond s; DFS_invar G param s; DFS_invar G param s'; stack s = [];\n        v0 \\<notin> dom (discovered s); v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, v')\\<in>tree_edges s'.\n                            \\<forall>y.\n                               y \\<noteq> v \\<longrightarrow>\n                               (y, v') \\<notin> tree_edges s'\n 3. \\<And>s s' u e.\n       \\<lbrakk>\\<forall>(v, v')\\<in>tree_edges s.\n                   \\<forall>y.\n                      y \\<noteq> v \\<longrightarrow>\n                      (y, v') \\<notin> tree_edges s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; pending s `` {u} = {}; u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, v')\\<in>tree_edges s'.\n                            \\<forall>y.\n                               y \\<noteq> v \\<longrightarrow>\n                               (y, v') \\<notin> tree_edges s'\n 4. \\<And>s s' u v e c b.\n       \\<lbrakk>\\<forall>(v, v')\\<in>tree_edges s.\n                   \\<forall>y.\n                      y \\<noteq> v \\<longrightarrow>\n                      (y, v') \\<notin> tree_edges s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); u = hd (stack s);\n        cross_edges s \\<subseteq> c; back_edges s \\<subseteq> b;\n        s' = s\n        \\<lparr>pending := pending s - {(u, v)}, state.more := e,\n           cross_edges := c, back_edges := b\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, v')\\<in>tree_edges s'.\n                            \\<forall>y.\n                               y \\<noteq> v \\<longrightarrow>\n                               (y, v') \\<notin> tree_edges s'\n 5. \\<And>s s' u v e.\n       \\<lbrakk>\\<forall>(v, v')\\<in>tree_edges s.\n                   \\<forall>y.\n                      y \\<noteq> v \\<longrightarrow>\n                      (y, v') \\<notin> tree_edges s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, v')\\<in>tree_edges s'.\n                            \\<forall>y.\n                               y \\<noteq> v \\<longrightarrow>\n                               (y, v') \\<notin> tree_edges s'", "hence EQ[simp]: \"tree_edges s' = insert (hd (stack s),v) (tree_edges s)\""], ["proof (prove)\nusing this:\n  \\<forall>(v, v')\\<in>tree_edges s.\n     \\<forall>y.\n        y \\<noteq> v \\<longrightarrow> (y, v') \\<notin> tree_edges s\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s \\<noteq> []\n  v \\<in> pending s `` {u}\n  v \\<notin> dom (discovered s)\n  u = hd (stack s)\n  s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n  \\<lparr>state.more := e_\\<rparr>\n\ngoal (1 subgoal):\n 1. tree_edges s' = insert (hd (stack s), v) (tree_edges s)", "by simp"], ["proof (state)\nthis:\n  tree_edges s' = insert (hd (stack s), v) (tree_edges s)\n\ngoal (5 subgoals):\n 1. \\<And>e.\n       \\<forall>(v, v')\\<in>tree_edges (empty_state e).\n          \\<forall>y.\n             y \\<noteq> v \\<longrightarrow>\n             (y, v') \\<notin> tree_edges (empty_state e)\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>\\<forall>(v, v')\\<in>tree_edges s.\n                   \\<forall>y.\n                      y \\<noteq> v \\<longrightarrow>\n                      (y, v') \\<notin> tree_edges s;\n        cond s; DFS_invar G param s; DFS_invar G param s'; stack s = [];\n        v0 \\<notin> dom (discovered s); v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, v')\\<in>tree_edges s'.\n                            \\<forall>y.\n                               y \\<noteq> v \\<longrightarrow>\n                               (y, v') \\<notin> tree_edges s'\n 3. \\<And>s s' u e.\n       \\<lbrakk>\\<forall>(v, v')\\<in>tree_edges s.\n                   \\<forall>y.\n                      y \\<noteq> v \\<longrightarrow>\n                      (y, v') \\<notin> tree_edges s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; pending s `` {u} = {}; u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, v')\\<in>tree_edges s'.\n                            \\<forall>y.\n                               y \\<noteq> v \\<longrightarrow>\n                               (y, v') \\<notin> tree_edges s'\n 4. \\<And>s s' u v e c b.\n       \\<lbrakk>\\<forall>(v, v')\\<in>tree_edges s.\n                   \\<forall>y.\n                      y \\<noteq> v \\<longrightarrow>\n                      (y, v') \\<notin> tree_edges s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); u = hd (stack s);\n        cross_edges s \\<subseteq> c; back_edges s \\<subseteq> b;\n        s' = s\n        \\<lparr>pending := pending s - {(u, v)}, state.more := e,\n           cross_edges := c, back_edges := b\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, v')\\<in>tree_edges s'.\n                            \\<forall>y.\n                               y \\<noteq> v \\<longrightarrow>\n                               (y, v') \\<notin> tree_edges s'\n 5. \\<And>s s' u v e.\n       \\<lbrakk>\\<forall>(v, v')\\<in>tree_edges s.\n                   \\<forall>y.\n                      y \\<noteq> v \\<longrightarrow>\n                      (y, v') \\<notin> tree_edges s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, v')\\<in>tree_edges s'.\n                            \\<forall>y.\n                               y \\<noteq> v \\<longrightarrow>\n                               (y, v') \\<notin> tree_edges s'", "from discover"], ["proof (chain)\npicking this:\n  \\<forall>(v, v')\\<in>tree_edges s.\n     \\<forall>y.\n        y \\<noteq> v \\<longrightarrow> (y, v') \\<notin> tree_edges s\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s \\<noteq> []\n  v \\<in> pending s `` {u}\n  v \\<notin> dom (discovered s)\n  u = hd (stack s)\n  s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n  \\<lparr>state.more := e_\\<rparr>", "interpret DFS_invar where s=s"], ["proof (prove)\nusing this:\n  \\<forall>(v, v')\\<in>tree_edges s.\n     \\<forall>y.\n        y \\<noteq> v \\<longrightarrow> (y, v') \\<notin> tree_edges s\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s \\<noteq> []\n  v \\<in> pending s `` {u}\n  v \\<notin> dom (discovered s)\n  u = hd (stack s)\n  s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n  \\<lparr>state.more := e_\\<rparr>\n\ngoal (1 subgoal):\n 1. DFS_invar G param s", "by simp"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>e.\n       \\<forall>(v, v')\\<in>tree_edges (empty_state e).\n          \\<forall>y.\n             y \\<noteq> v \\<longrightarrow>\n             (y, v') \\<notin> tree_edges (empty_state e)\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>\\<forall>(v, v')\\<in>tree_edges s.\n                   \\<forall>y.\n                      y \\<noteq> v \\<longrightarrow>\n                      (y, v') \\<notin> tree_edges s;\n        cond s; DFS_invar G param s; DFS_invar G param s'; stack s = [];\n        v0 \\<notin> dom (discovered s); v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, v')\\<in>tree_edges s'.\n                            \\<forall>y.\n                               y \\<noteq> v \\<longrightarrow>\n                               (y, v') \\<notin> tree_edges s'\n 3. \\<And>s s' u e.\n       \\<lbrakk>\\<forall>(v, v')\\<in>tree_edges s.\n                   \\<forall>y.\n                      y \\<noteq> v \\<longrightarrow>\n                      (y, v') \\<notin> tree_edges s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; pending s `` {u} = {}; u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, v')\\<in>tree_edges s'.\n                            \\<forall>y.\n                               y \\<noteq> v \\<longrightarrow>\n                               (y, v') \\<notin> tree_edges s'\n 4. \\<And>s s' u v e c b.\n       \\<lbrakk>\\<forall>(v, v')\\<in>tree_edges s.\n                   \\<forall>y.\n                      y \\<noteq> v \\<longrightarrow>\n                      (y, v') \\<notin> tree_edges s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); u = hd (stack s);\n        cross_edges s \\<subseteq> c; back_edges s \\<subseteq> b;\n        s' = s\n        \\<lparr>pending := pending s - {(u, v)}, state.more := e,\n           cross_edges := c, back_edges := b\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, v')\\<in>tree_edges s'.\n                            \\<forall>y.\n                               y \\<noteq> v \\<longrightarrow>\n                               (y, v') \\<notin> tree_edges s'\n 5. \\<And>s s' u v e.\n       \\<lbrakk>\\<forall>(v, v')\\<in>tree_edges s.\n                   \\<forall>y.\n                      y \\<noteq> v \\<longrightarrow>\n                      (y, v') \\<notin> tree_edges s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, v')\\<in>tree_edges s'.\n                            \\<forall>y.\n                               y \\<noteq> v \\<longrightarrow>\n                               (y, v') \\<notin> tree_edges s'", "from discover"], ["proof (chain)\npicking this:\n  \\<forall>(v, v')\\<in>tree_edges s.\n     \\<forall>y.\n        y \\<noteq> v \\<longrightarrow> (y, v') \\<notin> tree_edges s\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s \\<noteq> []\n  v \\<in> pending s `` {u}\n  v \\<notin> dom (discovered s)\n  u = hd (stack s)\n  s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n  \\<lparr>state.more := e_\\<rparr>", "have NE[simp]: \"stack s \\<noteq> []\""], ["proof (prove)\nusing this:\n  \\<forall>(v, v')\\<in>tree_edges s.\n     \\<forall>y.\n        y \\<noteq> v \\<longrightarrow> (y, v') \\<notin> tree_edges s\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s \\<noteq> []\n  v \\<in> pending s `` {u}\n  v \\<notin> dom (discovered s)\n  u = hd (stack s)\n  s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n  \\<lparr>state.more := e_\\<rparr>\n\ngoal (1 subgoal):\n 1. stack s \\<noteq> []", "by (simp add: cond_alt)"], ["proof (state)\nthis:\n  stack s \\<noteq> []\n\ngoal (5 subgoals):\n 1. \\<And>e.\n       \\<forall>(v, v')\\<in>tree_edges (empty_state e).\n          \\<forall>y.\n             y \\<noteq> v \\<longrightarrow>\n             (y, v') \\<notin> tree_edges (empty_state e)\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>\\<forall>(v, v')\\<in>tree_edges s.\n                   \\<forall>y.\n                      y \\<noteq> v \\<longrightarrow>\n                      (y, v') \\<notin> tree_edges s;\n        cond s; DFS_invar G param s; DFS_invar G param s'; stack s = [];\n        v0 \\<notin> dom (discovered s); v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, v')\\<in>tree_edges s'.\n                            \\<forall>y.\n                               y \\<noteq> v \\<longrightarrow>\n                               (y, v') \\<notin> tree_edges s'\n 3. \\<And>s s' u e.\n       \\<lbrakk>\\<forall>(v, v')\\<in>tree_edges s.\n                   \\<forall>y.\n                      y \\<noteq> v \\<longrightarrow>\n                      (y, v') \\<notin> tree_edges s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; pending s `` {u} = {}; u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, v')\\<in>tree_edges s'.\n                            \\<forall>y.\n                               y \\<noteq> v \\<longrightarrow>\n                               (y, v') \\<notin> tree_edges s'\n 4. \\<And>s s' u v e c b.\n       \\<lbrakk>\\<forall>(v, v')\\<in>tree_edges s.\n                   \\<forall>y.\n                      y \\<noteq> v \\<longrightarrow>\n                      (y, v') \\<notin> tree_edges s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); u = hd (stack s);\n        cross_edges s \\<subseteq> c; back_edges s \\<subseteq> b;\n        s' = s\n        \\<lparr>pending := pending s - {(u, v)}, state.more := e,\n           cross_edges := c, back_edges := b\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, v')\\<in>tree_edges s'.\n                            \\<forall>y.\n                               y \\<noteq> v \\<longrightarrow>\n                               (y, v') \\<notin> tree_edges s'\n 5. \\<And>s s' u v e.\n       \\<lbrakk>\\<forall>(v, v')\\<in>tree_edges s.\n                   \\<forall>y.\n                      y \\<noteq> v \\<longrightarrow>\n                      (y, v') \\<notin> tree_edges s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, v')\\<in>tree_edges s'.\n                            \\<forall>y.\n                               y \\<noteq> v \\<longrightarrow>\n                               (y, v') \\<notin> tree_edges s'", "{"], ["proof (state)\nthis:\n  stack s \\<noteq> []\n\ngoal (5 subgoals):\n 1. \\<And>e.\n       \\<forall>(v, v')\\<in>tree_edges (empty_state e).\n          \\<forall>y.\n             y \\<noteq> v \\<longrightarrow>\n             (y, v') \\<notin> tree_edges (empty_state e)\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>\\<forall>(v, v')\\<in>tree_edges s.\n                   \\<forall>y.\n                      y \\<noteq> v \\<longrightarrow>\n                      (y, v') \\<notin> tree_edges s;\n        cond s; DFS_invar G param s; DFS_invar G param s'; stack s = [];\n        v0 \\<notin> dom (discovered s); v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, v')\\<in>tree_edges s'.\n                            \\<forall>y.\n                               y \\<noteq> v \\<longrightarrow>\n                               (y, v') \\<notin> tree_edges s'\n 3. \\<And>s s' u e.\n       \\<lbrakk>\\<forall>(v, v')\\<in>tree_edges s.\n                   \\<forall>y.\n                      y \\<noteq> v \\<longrightarrow>\n                      (y, v') \\<notin> tree_edges s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; pending s `` {u} = {}; u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, v')\\<in>tree_edges s'.\n                            \\<forall>y.\n                               y \\<noteq> v \\<longrightarrow>\n                               (y, v') \\<notin> tree_edges s'\n 4. \\<And>s s' u v e c b.\n       \\<lbrakk>\\<forall>(v, v')\\<in>tree_edges s.\n                   \\<forall>y.\n                      y \\<noteq> v \\<longrightarrow>\n                      (y, v') \\<notin> tree_edges s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); u = hd (stack s);\n        cross_edges s \\<subseteq> c; back_edges s \\<subseteq> b;\n        s' = s\n        \\<lparr>pending := pending s - {(u, v)}, state.more := e,\n           cross_edges := c, back_edges := b\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, v')\\<in>tree_edges s'.\n                            \\<forall>y.\n                               y \\<noteq> v \\<longrightarrow>\n                               (y, v') \\<notin> tree_edges s'\n 5. \\<And>s s' u v e.\n       \\<lbrakk>\\<forall>(v, v')\\<in>tree_edges s.\n                   \\<forall>y.\n                      y \\<noteq> v \\<longrightarrow>\n                      (y, v') \\<notin> tree_edges s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, v')\\<in>tree_edges s'.\n                            \\<forall>y.\n                               y \\<noteq> v \\<longrightarrow>\n                               (y, v') \\<notin> tree_edges s'", "fix w w' y"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>e.\n       \\<forall>(v, v')\\<in>tree_edges (empty_state e).\n          \\<forall>y.\n             y \\<noteq> v \\<longrightarrow>\n             (y, v') \\<notin> tree_edges (empty_state e)\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>\\<forall>(v, v')\\<in>tree_edges s.\n                   \\<forall>y.\n                      y \\<noteq> v \\<longrightarrow>\n                      (y, v') \\<notin> tree_edges s;\n        cond s; DFS_invar G param s; DFS_invar G param s'; stack s = [];\n        v0 \\<notin> dom (discovered s); v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, v')\\<in>tree_edges s'.\n                            \\<forall>y.\n                               y \\<noteq> v \\<longrightarrow>\n                               (y, v') \\<notin> tree_edges s'\n 3. \\<And>s s' u e.\n       \\<lbrakk>\\<forall>(v, v')\\<in>tree_edges s.\n                   \\<forall>y.\n                      y \\<noteq> v \\<longrightarrow>\n                      (y, v') \\<notin> tree_edges s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; pending s `` {u} = {}; u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, v')\\<in>tree_edges s'.\n                            \\<forall>y.\n                               y \\<noteq> v \\<longrightarrow>\n                               (y, v') \\<notin> tree_edges s'\n 4. \\<And>s s' u v e c b.\n       \\<lbrakk>\\<forall>(v, v')\\<in>tree_edges s.\n                   \\<forall>y.\n                      y \\<noteq> v \\<longrightarrow>\n                      (y, v') \\<notin> tree_edges s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); u = hd (stack s);\n        cross_edges s \\<subseteq> c; back_edges s \\<subseteq> b;\n        s' = s\n        \\<lparr>pending := pending s - {(u, v)}, state.more := e,\n           cross_edges := c, back_edges := b\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, v')\\<in>tree_edges s'.\n                            \\<forall>y.\n                               y \\<noteq> v \\<longrightarrow>\n                               (y, v') \\<notin> tree_edges s'\n 5. \\<And>s s' u v e.\n       \\<lbrakk>\\<forall>(v, v')\\<in>tree_edges s.\n                   \\<forall>y.\n                      y \\<noteq> v \\<longrightarrow>\n                      (y, v') \\<notin> tree_edges s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, v')\\<in>tree_edges s'.\n                            \\<forall>y.\n                               y \\<noteq> v \\<longrightarrow>\n                               (y, v') \\<notin> tree_edges s'", "assume *: \"(w,w') \\<in> tree_edges s'\"\n        and  \"y \\<noteq> w\""], ["proof (state)\nthis:\n  (w, w') \\<in> tree_edges s'\n  y \\<noteq> w\n\ngoal (5 subgoals):\n 1. \\<And>e.\n       \\<forall>(v, v')\\<in>tree_edges (empty_state e).\n          \\<forall>y.\n             y \\<noteq> v \\<longrightarrow>\n             (y, v') \\<notin> tree_edges (empty_state e)\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>\\<forall>(v, v')\\<in>tree_edges s.\n                   \\<forall>y.\n                      y \\<noteq> v \\<longrightarrow>\n                      (y, v') \\<notin> tree_edges s;\n        cond s; DFS_invar G param s; DFS_invar G param s'; stack s = [];\n        v0 \\<notin> dom (discovered s); v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, v')\\<in>tree_edges s'.\n                            \\<forall>y.\n                               y \\<noteq> v \\<longrightarrow>\n                               (y, v') \\<notin> tree_edges s'\n 3. \\<And>s s' u e.\n       \\<lbrakk>\\<forall>(v, v')\\<in>tree_edges s.\n                   \\<forall>y.\n                      y \\<noteq> v \\<longrightarrow>\n                      (y, v') \\<notin> tree_edges s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; pending s `` {u} = {}; u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, v')\\<in>tree_edges s'.\n                            \\<forall>y.\n                               y \\<noteq> v \\<longrightarrow>\n                               (y, v') \\<notin> tree_edges s'\n 4. \\<And>s s' u v e c b.\n       \\<lbrakk>\\<forall>(v, v')\\<in>tree_edges s.\n                   \\<forall>y.\n                      y \\<noteq> v \\<longrightarrow>\n                      (y, v') \\<notin> tree_edges s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); u = hd (stack s);\n        cross_edges s \\<subseteq> c; back_edges s \\<subseteq> b;\n        s' = s\n        \\<lparr>pending := pending s - {(u, v)}, state.more := e,\n           cross_edges := c, back_edges := b\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, v')\\<in>tree_edges s'.\n                            \\<forall>y.\n                               y \\<noteq> v \\<longrightarrow>\n                               (y, v') \\<notin> tree_edges s'\n 5. \\<And>s s' u v e.\n       \\<lbrakk>\\<forall>(v, v')\\<in>tree_edges s.\n                   \\<forall>y.\n                      y \\<noteq> v \\<longrightarrow>\n                      (y, v') \\<notin> tree_edges s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, v')\\<in>tree_edges s'.\n                            \\<forall>y.\n                               y \\<noteq> v \\<longrightarrow>\n                               (y, v') \\<notin> tree_edges s'", "from discover stack_discovered"], ["proof (chain)\npicking this:\n  \\<forall>(v, v')\\<in>tree_edges s.\n     \\<forall>y.\n        y \\<noteq> v \\<longrightarrow> (y, v') \\<notin> tree_edges s\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s \\<noteq> []\n  v \\<in> pending s `` {u}\n  v \\<notin> dom (discovered s)\n  u = hd (stack s)\n  s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n  \\<lparr>state.more := e_\\<rparr>\n  set (stack s) \\<subseteq> dom (discovered s)", "have v_hd: \"hd (stack s) \\<noteq> v\""], ["proof (prove)\nusing this:\n  \\<forall>(v, v')\\<in>tree_edges s.\n     \\<forall>y.\n        y \\<noteq> v \\<longrightarrow> (y, v') \\<notin> tree_edges s\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s \\<noteq> []\n  v \\<in> pending s `` {u}\n  v \\<notin> dom (discovered s)\n  u = hd (stack s)\n  s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n  \\<lparr>state.more := e_\\<rparr>\n  set (stack s) \\<subseteq> dom (discovered s)\n\ngoal (1 subgoal):\n 1. hd (stack s) \\<noteq> v", "using hd_in_set[OF NE]"], ["proof (prove)\nusing this:\n  \\<forall>(v, v')\\<in>tree_edges s.\n     \\<forall>y.\n        y \\<noteq> v \\<longrightarrow> (y, v') \\<notin> tree_edges s\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s \\<noteq> []\n  v \\<in> pending s `` {u}\n  v \\<notin> dom (discovered s)\n  u = hd (stack s)\n  s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n  \\<lparr>state.more := e_\\<rparr>\n  set (stack s) \\<subseteq> dom (discovered s)\n  hd (stack s) \\<in> set (stack s)\n\ngoal (1 subgoal):\n 1. hd (stack s) \\<noteq> v", "by blast"], ["proof (state)\nthis:\n  hd (stack s) \\<noteq> v\n\ngoal (5 subgoals):\n 1. \\<And>e.\n       \\<forall>(v, v')\\<in>tree_edges (empty_state e).\n          \\<forall>y.\n             y \\<noteq> v \\<longrightarrow>\n             (y, v') \\<notin> tree_edges (empty_state e)\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>\\<forall>(v, v')\\<in>tree_edges s.\n                   \\<forall>y.\n                      y \\<noteq> v \\<longrightarrow>\n                      (y, v') \\<notin> tree_edges s;\n        cond s; DFS_invar G param s; DFS_invar G param s'; stack s = [];\n        v0 \\<notin> dom (discovered s); v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, v')\\<in>tree_edges s'.\n                            \\<forall>y.\n                               y \\<noteq> v \\<longrightarrow>\n                               (y, v') \\<notin> tree_edges s'\n 3. \\<And>s s' u e.\n       \\<lbrakk>\\<forall>(v, v')\\<in>tree_edges s.\n                   \\<forall>y.\n                      y \\<noteq> v \\<longrightarrow>\n                      (y, v') \\<notin> tree_edges s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; pending s `` {u} = {}; u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, v')\\<in>tree_edges s'.\n                            \\<forall>y.\n                               y \\<noteq> v \\<longrightarrow>\n                               (y, v') \\<notin> tree_edges s'\n 4. \\<And>s s' u v e c b.\n       \\<lbrakk>\\<forall>(v, v')\\<in>tree_edges s.\n                   \\<forall>y.\n                      y \\<noteq> v \\<longrightarrow>\n                      (y, v') \\<notin> tree_edges s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); u = hd (stack s);\n        cross_edges s \\<subseteq> c; back_edges s \\<subseteq> b;\n        s' = s\n        \\<lparr>pending := pending s - {(u, v)}, state.more := e,\n           cross_edges := c, back_edges := b\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, v')\\<in>tree_edges s'.\n                            \\<forall>y.\n                               y \\<noteq> v \\<longrightarrow>\n                               (y, v') \\<notin> tree_edges s'\n 5. \\<And>s s' u v e.\n       \\<lbrakk>\\<forall>(v, v')\\<in>tree_edges s.\n                   \\<forall>y.\n                      y \\<noteq> v \\<longrightarrow>\n                      (y, v') \\<notin> tree_edges s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, v')\\<in>tree_edges s'.\n                            \\<forall>y.\n                               y \\<noteq> v \\<longrightarrow>\n                               (y, v') \\<notin> tree_edges s'", "from discover tree_edges_discovered"], ["proof (chain)\npicking this:\n  \\<forall>(v, v')\\<in>tree_edges s.\n     \\<forall>y.\n        y \\<noteq> v \\<longrightarrow> (y, v') \\<notin> tree_edges s\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s \\<noteq> []\n  v \\<in> pending s `` {u}\n  v \\<notin> dom (discovered s)\n  u = hd (stack s)\n  s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n  \\<lparr>state.more := e_\\<rparr>\n  Field (tree_edges s) \\<subseteq> dom (discovered s)", "have \n        v_notin_tree: \"\\<forall>(x,x') \\<in> tree_edges s. x \\<noteq> v \\<and> x' \\<noteq> v\""], ["proof (prove)\nusing this:\n  \\<forall>(v, v')\\<in>tree_edges s.\n     \\<forall>y.\n        y \\<noteq> v \\<longrightarrow> (y, v') \\<notin> tree_edges s\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s \\<noteq> []\n  v \\<in> pending s `` {u}\n  v \\<notin> dom (discovered s)\n  u = hd (stack s)\n  s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n  \\<lparr>state.more := e_\\<rparr>\n  Field (tree_edges s) \\<subseteq> dom (discovered s)\n\ngoal (1 subgoal):\n 1. \\<forall>(x, x')\\<in>tree_edges s. x \\<noteq> v \\<and> x' \\<noteq> v", "by (blast intro!: Field_not_elem)"], ["proof (state)\nthis:\n  \\<forall>(x, x')\\<in>tree_edges s. x \\<noteq> v \\<and> x' \\<noteq> v\n\ngoal (5 subgoals):\n 1. \\<And>e.\n       \\<forall>(v, v')\\<in>tree_edges (empty_state e).\n          \\<forall>y.\n             y \\<noteq> v \\<longrightarrow>\n             (y, v') \\<notin> tree_edges (empty_state e)\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>\\<forall>(v, v')\\<in>tree_edges s.\n                   \\<forall>y.\n                      y \\<noteq> v \\<longrightarrow>\n                      (y, v') \\<notin> tree_edges s;\n        cond s; DFS_invar G param s; DFS_invar G param s'; stack s = [];\n        v0 \\<notin> dom (discovered s); v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, v')\\<in>tree_edges s'.\n                            \\<forall>y.\n                               y \\<noteq> v \\<longrightarrow>\n                               (y, v') \\<notin> tree_edges s'\n 3. \\<And>s s' u e.\n       \\<lbrakk>\\<forall>(v, v')\\<in>tree_edges s.\n                   \\<forall>y.\n                      y \\<noteq> v \\<longrightarrow>\n                      (y, v') \\<notin> tree_edges s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; pending s `` {u} = {}; u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, v')\\<in>tree_edges s'.\n                            \\<forall>y.\n                               y \\<noteq> v \\<longrightarrow>\n                               (y, v') \\<notin> tree_edges s'\n 4. \\<And>s s' u v e c b.\n       \\<lbrakk>\\<forall>(v, v')\\<in>tree_edges s.\n                   \\<forall>y.\n                      y \\<noteq> v \\<longrightarrow>\n                      (y, v') \\<notin> tree_edges s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); u = hd (stack s);\n        cross_edges s \\<subseteq> c; back_edges s \\<subseteq> b;\n        s' = s\n        \\<lparr>pending := pending s - {(u, v)}, state.more := e,\n           cross_edges := c, back_edges := b\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, v')\\<in>tree_edges s'.\n                            \\<forall>y.\n                               y \\<noteq> v \\<longrightarrow>\n                               (y, v') \\<notin> tree_edges s'\n 5. \\<And>s s' u v e.\n       \\<lbrakk>\\<forall>(v, v')\\<in>tree_edges s.\n                   \\<forall>y.\n                      y \\<noteq> v \\<longrightarrow>\n                      (y, v') \\<notin> tree_edges s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, v')\\<in>tree_edges s'.\n                            \\<forall>y.\n                               y \\<noteq> v \\<longrightarrow>\n                               (y, v') \\<notin> tree_edges s'", "have \"(y,w') \\<notin> tree_edges s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (y, w') \\<notin> tree_edges s'", "proof (cases \"w = hd (stack s)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. w = hd (stack s) \\<Longrightarrow> (y, w') \\<notin> tree_edges s'\n 2. w \\<noteq> hd (stack s) \\<Longrightarrow> (y, w') \\<notin> tree_edges s'", "case True"], ["proof (state)\nthis:\n  w = hd (stack s)\n\ngoal (2 subgoals):\n 1. w = hd (stack s) \\<Longrightarrow> (y, w') \\<notin> tree_edges s'\n 2. w \\<noteq> hd (stack s) \\<Longrightarrow> (y, w') \\<notin> tree_edges s'", "have \"(y,v) \\<notin> tree_edges s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (y, v) \\<notin> tree_edges s'", "proof (rule notI)"], ["proof (state)\ngoal (1 subgoal):\n 1. (y, v) \\<in> tree_edges s' \\<Longrightarrow> False", "assume \"(y,v) \\<in> tree_edges s'\""], ["proof (state)\nthis:\n  (y, v) \\<in> tree_edges s'\n\ngoal (1 subgoal):\n 1. (y, v) \\<in> tree_edges s' \\<Longrightarrow> False", "with True \\<open>y\\<noteq>w\\<close>"], ["proof (chain)\npicking this:\n  w = hd (stack s)\n  y \\<noteq> w\n  (y, v) \\<in> tree_edges s'", "have \"(y,v) \\<in> tree_edges s\""], ["proof (prove)\nusing this:\n  w = hd (stack s)\n  y \\<noteq> w\n  (y, v) \\<in> tree_edges s'\n\ngoal (1 subgoal):\n 1. (y, v) \\<in> tree_edges s", "by simp"], ["proof (state)\nthis:\n  (y, v) \\<in> tree_edges s\n\ngoal (1 subgoal):\n 1. (y, v) \\<in> tree_edges s' \\<Longrightarrow> False", "with v_notin_tree"], ["proof (chain)\npicking this:\n  \\<forall>(x, x')\\<in>tree_edges s. x \\<noteq> v \\<and> x' \\<noteq> v\n  (y, v) \\<in> tree_edges s", "show False"], ["proof (prove)\nusing this:\n  \\<forall>(x, x')\\<in>tree_edges s. x \\<noteq> v \\<and> x' \\<noteq> v\n  (y, v) \\<in> tree_edges s\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (y, v) \\<notin> tree_edges s'\n\ngoal (2 subgoals):\n 1. w = hd (stack s) \\<Longrightarrow> (y, w') \\<notin> tree_edges s'\n 2. w \\<noteq> hd (stack s) \\<Longrightarrow> (y, w') \\<notin> tree_edges s'", "with True * \\<open>y\\<noteq>w\\<close> v_hd"], ["proof (chain)\npicking this:\n  w = hd (stack s)\n  (w, w') \\<in> tree_edges s'\n  y \\<noteq> w\n  hd (stack s) \\<noteq> v\n  (y, v) \\<notin> tree_edges s'", "show ?thesis"], ["proof (prove)\nusing this:\n  w = hd (stack s)\n  (w, w') \\<in> tree_edges s'\n  y \\<noteq> w\n  hd (stack s) \\<noteq> v\n  (y, v) \\<notin> tree_edges s'\n\ngoal (1 subgoal):\n 1. (y, w') \\<notin> tree_edges s'", "apply (cases \"w = v\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>w = hd (stack s); (w, w') \\<in> tree_edges s'; y \\<noteq> w;\n     hd (stack s) \\<noteq> v; (y, v) \\<notin> tree_edges s'; w = v\\<rbrakk>\n    \\<Longrightarrow> (y, w') \\<notin> tree_edges s'\n 2. \\<lbrakk>w = hd (stack s); (w, w') \\<in> tree_edges s'; y \\<noteq> w;\n     hd (stack s) \\<noteq> v; (y, v) \\<notin> tree_edges s';\n     w \\<noteq> v\\<rbrakk>\n    \\<Longrightarrow> (y, w') \\<notin> tree_edges s'", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>w = hd (stack s); (w, w') \\<in> tree_edges s'; y \\<noteq> w;\n     hd (stack s) \\<noteq> v; (y, v) \\<notin> tree_edges s';\n     w \\<noteq> v\\<rbrakk>\n    \\<Longrightarrow> (y, w') \\<notin> tree_edges s'", "using discover"], ["proof (prove)\nusing this:\n  \\<forall>(v, v')\\<in>tree_edges s.\n     \\<forall>y.\n        y \\<noteq> v \\<longrightarrow> (y, v') \\<notin> tree_edges s\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s \\<noteq> []\n  v \\<in> pending s `` {u}\n  v \\<notin> dom (discovered s)\n  u = hd (stack s)\n  s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n  \\<lparr>state.more := e_\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>w = hd (stack s); (w, w') \\<in> tree_edges s'; y \\<noteq> w;\n     hd (stack s) \\<noteq> v; (y, v) \\<notin> tree_edges s';\n     w \\<noteq> v\\<rbrakk>\n    \\<Longrightarrow> (y, w') \\<notin> tree_edges s'", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>w = hd (stack s);\n     w' = v \\<or> (hd (stack s), w') \\<in> tree_edges s;\n     y \\<noteq> hd (stack s); hd (stack s) \\<noteq> v;\n     (y, v) \\<notin> tree_edges s;\n     \\<forall>x\\<in>tree_edges s.\n        case x of\n        (v, v') \\<Rightarrow>\n          \\<forall>y.\n             y \\<noteq> v \\<longrightarrow> (y, v') \\<notin> tree_edges s;\n     cond s; DFS_invar G param s;\n     DFS_invar G param\n      (discover (hd (stack s)) v\n        (s\\<lparr>pending := pending s - {(hd (stack s), v)}\\<rparr>)\n       \\<lparr>state.more := e_\\<rparr>);\n     (hd (stack s), v) \\<in> pending s; v \\<notin> dom (discovered s);\n     u = hd (stack s);\n     s' =\n     discover (hd (stack s)) v\n      (s\\<lparr>pending := pending s - {(hd (stack s), v)}\\<rparr>)\n     \\<lparr>state.more := e_\\<rparr>\\<rbrakk>\n    \\<Longrightarrow> (y, w') \\<notin> tree_edges s", "apply blast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (y, w') \\<notin> tree_edges s'\n\ngoal (1 subgoal):\n 1. w \\<noteq> hd (stack s) \\<Longrightarrow> (y, w') \\<notin> tree_edges s'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. w \\<noteq> hd (stack s) \\<Longrightarrow> (y, w') \\<notin> tree_edges s'", "case False"], ["proof (state)\nthis:\n  w \\<noteq> hd (stack s)\n\ngoal (1 subgoal):\n 1. w \\<noteq> hd (stack s) \\<Longrightarrow> (y, w') \\<notin> tree_edges s'", "with v_notin_tree * \\<open>y\\<noteq>w\\<close> v_hd"], ["proof (chain)\npicking this:\n  \\<forall>(x, x')\\<in>tree_edges s. x \\<noteq> v \\<and> x' \\<noteq> v\n  (w, w') \\<in> tree_edges s'\n  y \\<noteq> w\n  hd (stack s) \\<noteq> v\n  w \\<noteq> hd (stack s)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>(x, x')\\<in>tree_edges s. x \\<noteq> v \\<and> x' \\<noteq> v\n  (w, w') \\<in> tree_edges s'\n  y \\<noteq> w\n  hd (stack s) \\<noteq> v\n  w \\<noteq> hd (stack s)\n\ngoal (1 subgoal):\n 1. (y, w') \\<notin> tree_edges s'", "apply (cases \"w' = v\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>(x, x')\\<in>tree_edges s.\n                x \\<noteq> v \\<and> x' \\<noteq> v;\n     (w, w') \\<in> tree_edges s'; y \\<noteq> w; hd (stack s) \\<noteq> v;\n     w \\<noteq> hd (stack s); w' = v\\<rbrakk>\n    \\<Longrightarrow> (y, w') \\<notin> tree_edges s'\n 2. \\<lbrakk>\\<forall>(x, x')\\<in>tree_edges s.\n                x \\<noteq> v \\<and> x' \\<noteq> v;\n     (w, w') \\<in> tree_edges s'; y \\<noteq> w; hd (stack s) \\<noteq> v;\n     w \\<noteq> hd (stack s); w' \\<noteq> v\\<rbrakk>\n    \\<Longrightarrow> (y, w') \\<notin> tree_edges s'", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>x\\<in>tree_edges s.\n                case x of\n                (x, x') \\<Rightarrow> x \\<noteq> v \\<and> x' \\<noteq> v;\n     (w, v) \\<in> tree_edges s; y \\<noteq> w; hd (stack s) \\<noteq> v;\n     w \\<noteq> hd (stack s); w' = v\\<rbrakk>\n    \\<Longrightarrow> y \\<noteq> hd (stack s) \\<and>\n                      (y, v) \\<notin> tree_edges s\n 2. \\<lbrakk>\\<forall>(x, x')\\<in>tree_edges s.\n                x \\<noteq> v \\<and> x' \\<noteq> v;\n     (w, w') \\<in> tree_edges s'; y \\<noteq> w; hd (stack s) \\<noteq> v;\n     w \\<noteq> hd (stack s); w' \\<noteq> v\\<rbrakk>\n    \\<Longrightarrow> (y, w') \\<notin> tree_edges s'", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>(x, x')\\<in>tree_edges s.\n                x \\<noteq> v \\<and> x' \\<noteq> v;\n     (w, w') \\<in> tree_edges s'; y \\<noteq> w; hd (stack s) \\<noteq> v;\n     w \\<noteq> hd (stack s); w' \\<noteq> v\\<rbrakk>\n    \\<Longrightarrow> (y, w') \\<notin> tree_edges s'", "using discover"], ["proof (prove)\nusing this:\n  \\<forall>(v, v')\\<in>tree_edges s.\n     \\<forall>y.\n        y \\<noteq> v \\<longrightarrow> (y, v') \\<notin> tree_edges s\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s \\<noteq> []\n  v \\<in> pending s `` {u}\n  v \\<notin> dom (discovered s)\n  u = hd (stack s)\n  s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n  \\<lparr>state.more := e_\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>(x, x')\\<in>tree_edges s.\n                x \\<noteq> v \\<and> x' \\<noteq> v;\n     (w, w') \\<in> tree_edges s'; y \\<noteq> w; hd (stack s) \\<noteq> v;\n     w \\<noteq> hd (stack s); w' \\<noteq> v\\<rbrakk>\n    \\<Longrightarrow> (y, w') \\<notin> tree_edges s'", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>x\\<in>tree_edges s.\n                case x of\n                (x, x') \\<Rightarrow> x \\<noteq> v \\<and> x' \\<noteq> v;\n     (w, w') \\<in> tree_edges s; y \\<noteq> w; hd (stack s) \\<noteq> v;\n     w \\<noteq> hd (stack s); w' \\<noteq> v;\n     \\<forall>x\\<in>tree_edges s.\n        case x of\n        (v, v') \\<Rightarrow>\n          \\<forall>y.\n             y \\<noteq> v \\<longrightarrow> (y, v') \\<notin> tree_edges s;\n     cond s; DFS_invar G param s;\n     DFS_invar G param\n      (discover (hd (stack s)) v\n        (s\\<lparr>pending := pending s - {(hd (stack s), v)}\\<rparr>)\n       \\<lparr>state.more := e_\\<rparr>);\n     (hd (stack s), v) \\<in> pending s; v \\<notin> dom (discovered s);\n     u = hd (stack s);\n     s' =\n     discover (hd (stack s)) v\n      (s\\<lparr>pending := pending s - {(hd (stack s), v)}\\<rparr>)\n     \\<lparr>state.more := e_\\<rparr>\\<rbrakk>\n    \\<Longrightarrow> (y, w') \\<notin> tree_edges s", "apply blast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (y, w') \\<notin> tree_edges s'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (y, w') \\<notin> tree_edges s'\n\ngoal (5 subgoals):\n 1. \\<And>e.\n       \\<forall>(v, v')\\<in>tree_edges (empty_state e).\n          \\<forall>y.\n             y \\<noteq> v \\<longrightarrow>\n             (y, v') \\<notin> tree_edges (empty_state e)\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>\\<forall>(v, v')\\<in>tree_edges s.\n                   \\<forall>y.\n                      y \\<noteq> v \\<longrightarrow>\n                      (y, v') \\<notin> tree_edges s;\n        cond s; DFS_invar G param s; DFS_invar G param s'; stack s = [];\n        v0 \\<notin> dom (discovered s); v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, v')\\<in>tree_edges s'.\n                            \\<forall>y.\n                               y \\<noteq> v \\<longrightarrow>\n                               (y, v') \\<notin> tree_edges s'\n 3. \\<And>s s' u e.\n       \\<lbrakk>\\<forall>(v, v')\\<in>tree_edges s.\n                   \\<forall>y.\n                      y \\<noteq> v \\<longrightarrow>\n                      (y, v') \\<notin> tree_edges s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; pending s `` {u} = {}; u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, v')\\<in>tree_edges s'.\n                            \\<forall>y.\n                               y \\<noteq> v \\<longrightarrow>\n                               (y, v') \\<notin> tree_edges s'\n 4. \\<And>s s' u v e c b.\n       \\<lbrakk>\\<forall>(v, v')\\<in>tree_edges s.\n                   \\<forall>y.\n                      y \\<noteq> v \\<longrightarrow>\n                      (y, v') \\<notin> tree_edges s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); u = hd (stack s);\n        cross_edges s \\<subseteq> c; back_edges s \\<subseteq> b;\n        s' = s\n        \\<lparr>pending := pending s - {(u, v)}, state.more := e,\n           cross_edges := c, back_edges := b\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, v')\\<in>tree_edges s'.\n                            \\<forall>y.\n                               y \\<noteq> v \\<longrightarrow>\n                               (y, v') \\<notin> tree_edges s'\n 5. \\<And>s s' u v e.\n       \\<lbrakk>\\<forall>(v, v')\\<in>tree_edges s.\n                   \\<forall>y.\n                      y \\<noteq> v \\<longrightarrow>\n                      (y, v') \\<notin> tree_edges s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, v')\\<in>tree_edges s'.\n                            \\<forall>y.\n                               y \\<noteq> v \\<longrightarrow>\n                               (y, v') \\<notin> tree_edges s'", "}"], ["proof (state)\nthis:\n  \\<lbrakk>(?w9, ?w'9) \\<in> tree_edges s'; ?y9 \\<noteq> ?w9\\<rbrakk>\n  \\<Longrightarrow> (?y9, ?w'9) \\<notin> tree_edges s'\n\ngoal (5 subgoals):\n 1. \\<And>e.\n       \\<forall>(v, v')\\<in>tree_edges (empty_state e).\n          \\<forall>y.\n             y \\<noteq> v \\<longrightarrow>\n             (y, v') \\<notin> tree_edges (empty_state e)\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>\\<forall>(v, v')\\<in>tree_edges s.\n                   \\<forall>y.\n                      y \\<noteq> v \\<longrightarrow>\n                      (y, v') \\<notin> tree_edges s;\n        cond s; DFS_invar G param s; DFS_invar G param s'; stack s = [];\n        v0 \\<notin> dom (discovered s); v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, v')\\<in>tree_edges s'.\n                            \\<forall>y.\n                               y \\<noteq> v \\<longrightarrow>\n                               (y, v') \\<notin> tree_edges s'\n 3. \\<And>s s' u e.\n       \\<lbrakk>\\<forall>(v, v')\\<in>tree_edges s.\n                   \\<forall>y.\n                      y \\<noteq> v \\<longrightarrow>\n                      (y, v') \\<notin> tree_edges s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; pending s `` {u} = {}; u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, v')\\<in>tree_edges s'.\n                            \\<forall>y.\n                               y \\<noteq> v \\<longrightarrow>\n                               (y, v') \\<notin> tree_edges s'\n 4. \\<And>s s' u v e c b.\n       \\<lbrakk>\\<forall>(v, v')\\<in>tree_edges s.\n                   \\<forall>y.\n                      y \\<noteq> v \\<longrightarrow>\n                      (y, v') \\<notin> tree_edges s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); u = hd (stack s);\n        cross_edges s \\<subseteq> c; back_edges s \\<subseteq> b;\n        s' = s\n        \\<lparr>pending := pending s - {(u, v)}, state.more := e,\n           cross_edges := c, back_edges := b\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, v')\\<in>tree_edges s'.\n                            \\<forall>y.\n                               y \\<noteq> v \\<longrightarrow>\n                               (y, v') \\<notin> tree_edges s'\n 5. \\<And>s s' u v e.\n       \\<lbrakk>\\<forall>(v, v')\\<in>tree_edges s.\n                   \\<forall>y.\n                      y \\<noteq> v \\<longrightarrow>\n                      (y, v') \\<notin> tree_edges s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, v')\\<in>tree_edges s'.\n                            \\<forall>y.\n                               y \\<noteq> v \\<longrightarrow>\n                               (y, v') \\<notin> tree_edges s'", "thus ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>(?w9, ?w'9) \\<in> tree_edges s'; ?y9 \\<noteq> ?w9\\<rbrakk>\n  \\<Longrightarrow> (?y9, ?w'9) \\<notin> tree_edges s'\n\ngoal (1 subgoal):\n 1. \\<forall>(v, v')\\<in>tree_edges s'.\n       \\<forall>y.\n          y \\<noteq> v \\<longrightarrow> (y, v') \\<notin> tree_edges s'", "by blast"], ["proof (state)\nthis:\n  \\<forall>(v, v')\\<in>tree_edges s'.\n     \\<forall>y.\n        y \\<noteq> v \\<longrightarrow> (y, v') \\<notin> tree_edges s'\n\ngoal (4 subgoals):\n 1. \\<And>e.\n       \\<forall>(v, v')\\<in>tree_edges (empty_state e).\n          \\<forall>y.\n             y \\<noteq> v \\<longrightarrow>\n             (y, v') \\<notin> tree_edges (empty_state e)\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>\\<forall>(v, v')\\<in>tree_edges s.\n                   \\<forall>y.\n                      y \\<noteq> v \\<longrightarrow>\n                      (y, v') \\<notin> tree_edges s;\n        cond s; DFS_invar G param s; DFS_invar G param s'; stack s = [];\n        v0 \\<notin> dom (discovered s); v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, v')\\<in>tree_edges s'.\n                            \\<forall>y.\n                               y \\<noteq> v \\<longrightarrow>\n                               (y, v') \\<notin> tree_edges s'\n 3. \\<And>s s' u e.\n       \\<lbrakk>\\<forall>(v, v')\\<in>tree_edges s.\n                   \\<forall>y.\n                      y \\<noteq> v \\<longrightarrow>\n                      (y, v') \\<notin> tree_edges s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; pending s `` {u} = {}; u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, v')\\<in>tree_edges s'.\n                            \\<forall>y.\n                               y \\<noteq> v \\<longrightarrow>\n                               (y, v') \\<notin> tree_edges s'\n 4. \\<And>s s' u v e c b.\n       \\<lbrakk>\\<forall>(v, v')\\<in>tree_edges s.\n                   \\<forall>y.\n                      y \\<noteq> v \\<longrightarrow>\n                      (y, v') \\<notin> tree_edges s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); u = hd (stack s);\n        cross_edges s \\<subseteq> c; back_edges s \\<subseteq> b;\n        s' = s\n        \\<lparr>pending := pending s - {(u, v)}, state.more := e,\n           cross_edges := c, back_edges := b\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, v')\\<in>tree_edges s'.\n                            \\<forall>y.\n                               y \\<noteq> v \\<longrightarrow>\n                               (y, v') \\<notin> tree_edges s'", "qed simp_all"], ["", "lemma (in DFS_invar) tree_one_predecessor:\n    assumes \"(v,w) \\<in> tree_edges s\"\n    and \"a \\<noteq> v\"\n    shows \"(a,w) \\<notin> tree_edges s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a, w) \\<notin> tree_edges s", "using assms make_invar_thm[OF i_tree_one_predecessor]"], ["proof (prove)\nusing this:\n  (v, w) \\<in> tree_edges s\n  a \\<noteq> v\n  \\<forall>(v, v')\\<in>tree_edges s.\n     \\<forall>y.\n        y \\<noteq> v \\<longrightarrow> (y, v') \\<notin> tree_edges s\n\ngoal (1 subgoal):\n 1. (a, w) \\<notin> tree_edges s", "by blast"], ["", "lemma (in DFS_invar) tree_eq_rule:\n    \"\\<lbrakk>(v,w) \\<in> tree_edges s; (u,w) \\<in> tree_edges s\\<rbrakk> \\<Longrightarrow> v=u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(v, w) \\<in> tree_edges s; (u, w) \\<in> tree_edges s\\<rbrakk>\n    \\<Longrightarrow> v = u", "using tree_one_predecessor"], ["proof (prove)\nusing this:\n  \\<lbrakk>(?v, ?w) \\<in> tree_edges s; ?a \\<noteq> ?v\\<rbrakk>\n  \\<Longrightarrow> (?a, ?w) \\<notin> tree_edges s\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(v, w) \\<in> tree_edges s; (u, w) \\<in> tree_edges s\\<rbrakk>\n    \\<Longrightarrow> v = u", "by blast"], ["", "context begin"], ["", "interpretation timing_syntax"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma i_tree_edge_disc:\n    \"is_invar (\\<lambda>s. \\<forall>(v,v') \\<in> tree_edges s. \\<delta> s v < \\<delta> s v')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_invar\n     (\\<lambda>s.\n         \\<forall>(v, v')\\<in>tree_edges s. \\<delta> s v < \\<delta> s v')", "proof (induct rule: is_invarI)"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>e.\n       \\<forall>(v, v')\\<in>tree_edges (empty_state e).\n          \\<delta> (empty_state e) v < \\<delta> (empty_state e) v'\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>\\<forall>(v, v')\\<in>tree_edges s.\n                   \\<delta> s v < \\<delta> s v';\n        cond s; DFS_invar G param s; DFS_invar G param s'; stack s = [];\n        v0 \\<notin> dom (discovered s); v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, v')\\<in>tree_edges s'.\n                            \\<delta> s' v < \\<delta> s' v'\n 3. \\<And>s s' u e.\n       \\<lbrakk>\\<forall>(v, v')\\<in>tree_edges s.\n                   \\<delta> s v < \\<delta> s v';\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; pending s `` {u} = {}; u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, v')\\<in>tree_edges s'.\n                            \\<delta> s' v < \\<delta> s' v'\n 4. \\<And>s s' u v e c b.\n       \\<lbrakk>\\<forall>(v, v')\\<in>tree_edges s.\n                   \\<delta> s v < \\<delta> s v';\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); u = hd (stack s);\n        cross_edges s \\<subseteq> c; back_edges s \\<subseteq> b;\n        s' = s\n        \\<lparr>pending := pending s - {(u, v)}, state.more := e,\n           cross_edges := c, back_edges := b\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, v')\\<in>tree_edges s'.\n                            \\<delta> s' v < \\<delta> s' v'\n 5. \\<And>s s' u v e.\n       \\<lbrakk>\\<forall>(v, v')\\<in>tree_edges s.\n                   \\<delta> s v < \\<delta> s v';\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, v')\\<in>tree_edges s'.\n                            \\<delta> s' v < \\<delta> s' v'", "case (discover s s' u v)"], ["proof (state)\nthis:\n  \\<forall>(v, v')\\<in>tree_edges s. \\<delta> s v < \\<delta> s v'\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s \\<noteq> []\n  v \\<in> pending s `` {u}\n  v \\<notin> dom (discovered s)\n  u = hd (stack s)\n  s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n  \\<lparr>state.more := e_\\<rparr>\n\ngoal (5 subgoals):\n 1. \\<And>e.\n       \\<forall>(v, v')\\<in>tree_edges (empty_state e).\n          \\<delta> (empty_state e) v < \\<delta> (empty_state e) v'\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>\\<forall>(v, v')\\<in>tree_edges s.\n                   \\<delta> s v < \\<delta> s v';\n        cond s; DFS_invar G param s; DFS_invar G param s'; stack s = [];\n        v0 \\<notin> dom (discovered s); v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, v')\\<in>tree_edges s'.\n                            \\<delta> s' v < \\<delta> s' v'\n 3. \\<And>s s' u e.\n       \\<lbrakk>\\<forall>(v, v')\\<in>tree_edges s.\n                   \\<delta> s v < \\<delta> s v';\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; pending s `` {u} = {}; u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, v')\\<in>tree_edges s'.\n                            \\<delta> s' v < \\<delta> s' v'\n 4. \\<And>s s' u v e c b.\n       \\<lbrakk>\\<forall>(v, v')\\<in>tree_edges s.\n                   \\<delta> s v < \\<delta> s v';\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); u = hd (stack s);\n        cross_edges s \\<subseteq> c; back_edges s \\<subseteq> b;\n        s' = s\n        \\<lparr>pending := pending s - {(u, v)}, state.more := e,\n           cross_edges := c, back_edges := b\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, v')\\<in>tree_edges s'.\n                            \\<delta> s' v < \\<delta> s' v'\n 5. \\<And>s s' u v e.\n       \\<lbrakk>\\<forall>(v, v')\\<in>tree_edges s.\n                   \\<delta> s v < \\<delta> s v';\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, v')\\<in>tree_edges s'.\n                            \\<delta> s' v < \\<delta> s' v'", "hence EQ[simp]: \"tree_edges s' = insert (hd (stack s), v) (tree_edges s)\"\n                    \"discovered s' = (discovered s)(v \\<mapsto> counter s)\""], ["proof (prove)\nusing this:\n  \\<forall>(v, v')\\<in>tree_edges s. \\<delta> s v < \\<delta> s v'\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s \\<noteq> []\n  v \\<in> pending s `` {u}\n  v \\<notin> dom (discovered s)\n  u = hd (stack s)\n  s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n  \\<lparr>state.more := e_\\<rparr>\n\ngoal (1 subgoal):\n 1. tree_edges s' = insert (hd (stack s), v) (tree_edges s) &&&\n    discovered s' = discovered s(v \\<mapsto> counter s)", "by simp_all"], ["proof (state)\nthis:\n  tree_edges s' = insert (hd (stack s), v) (tree_edges s)\n  discovered s' = discovered s(v \\<mapsto> counter s)\n\ngoal (5 subgoals):\n 1. \\<And>e.\n       \\<forall>(v, v')\\<in>tree_edges (empty_state e).\n          \\<delta> (empty_state e) v < \\<delta> (empty_state e) v'\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>\\<forall>(v, v')\\<in>tree_edges s.\n                   \\<delta> s v < \\<delta> s v';\n        cond s; DFS_invar G param s; DFS_invar G param s'; stack s = [];\n        v0 \\<notin> dom (discovered s); v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, v')\\<in>tree_edges s'.\n                            \\<delta> s' v < \\<delta> s' v'\n 3. \\<And>s s' u e.\n       \\<lbrakk>\\<forall>(v, v')\\<in>tree_edges s.\n                   \\<delta> s v < \\<delta> s v';\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; pending s `` {u} = {}; u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, v')\\<in>tree_edges s'.\n                            \\<delta> s' v < \\<delta> s' v'\n 4. \\<And>s s' u v e c b.\n       \\<lbrakk>\\<forall>(v, v')\\<in>tree_edges s.\n                   \\<delta> s v < \\<delta> s v';\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); u = hd (stack s);\n        cross_edges s \\<subseteq> c; back_edges s \\<subseteq> b;\n        s' = s\n        \\<lparr>pending := pending s - {(u, v)}, state.more := e,\n           cross_edges := c, back_edges := b\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, v')\\<in>tree_edges s'.\n                            \\<delta> s' v < \\<delta> s' v'\n 5. \\<And>s s' u v e.\n       \\<lbrakk>\\<forall>(v, v')\\<in>tree_edges s.\n                   \\<delta> s v < \\<delta> s v';\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, v')\\<in>tree_edges s'.\n                            \\<delta> s' v < \\<delta> s' v'", "from discover"], ["proof (chain)\npicking this:\n  \\<forall>(v, v')\\<in>tree_edges s. \\<delta> s v < \\<delta> s v'\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s \\<noteq> []\n  v \\<in> pending s `` {u}\n  v \\<notin> dom (discovered s)\n  u = hd (stack s)\n  s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n  \\<lparr>state.more := e_\\<rparr>", "interpret DFS_invar where s=s"], ["proof (prove)\nusing this:\n  \\<forall>(v, v')\\<in>tree_edges s. \\<delta> s v < \\<delta> s v'\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s \\<noteq> []\n  v \\<in> pending s `` {u}\n  v \\<notin> dom (discovered s)\n  u = hd (stack s)\n  s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n  \\<lparr>state.more := e_\\<rparr>\n\ngoal (1 subgoal):\n 1. DFS_invar G param s", "by simp"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>e.\n       \\<forall>(v, v')\\<in>tree_edges (empty_state e).\n          \\<delta> (empty_state e) v < \\<delta> (empty_state e) v'\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>\\<forall>(v, v')\\<in>tree_edges s.\n                   \\<delta> s v < \\<delta> s v';\n        cond s; DFS_invar G param s; DFS_invar G param s'; stack s = [];\n        v0 \\<notin> dom (discovered s); v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, v')\\<in>tree_edges s'.\n                            \\<delta> s' v < \\<delta> s' v'\n 3. \\<And>s s' u e.\n       \\<lbrakk>\\<forall>(v, v')\\<in>tree_edges s.\n                   \\<delta> s v < \\<delta> s v';\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; pending s `` {u} = {}; u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, v')\\<in>tree_edges s'.\n                            \\<delta> s' v < \\<delta> s' v'\n 4. \\<And>s s' u v e c b.\n       \\<lbrakk>\\<forall>(v, v')\\<in>tree_edges s.\n                   \\<delta> s v < \\<delta> s v';\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); u = hd (stack s);\n        cross_edges s \\<subseteq> c; back_edges s \\<subseteq> b;\n        s' = s\n        \\<lparr>pending := pending s - {(u, v)}, state.more := e,\n           cross_edges := c, back_edges := b\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, v')\\<in>tree_edges s'.\n                            \\<delta> s' v < \\<delta> s' v'\n 5. \\<And>s s' u v e.\n       \\<lbrakk>\\<forall>(v, v')\\<in>tree_edges s.\n                   \\<delta> s v < \\<delta> s v';\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, v')\\<in>tree_edges s'.\n                            \\<delta> s' v < \\<delta> s' v'", "from discover"], ["proof (chain)\npicking this:\n  \\<forall>(v, v')\\<in>tree_edges s. \\<delta> s v < \\<delta> s v'\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s \\<noteq> []\n  v \\<in> pending s `` {u}\n  v \\<notin> dom (discovered s)\n  u = hd (stack s)\n  s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n  \\<lparr>state.more := e_\\<rparr>", "have NE[simp]: \"stack s \\<noteq> []\""], ["proof (prove)\nusing this:\n  \\<forall>(v, v')\\<in>tree_edges s. \\<delta> s v < \\<delta> s v'\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s \\<noteq> []\n  v \\<in> pending s `` {u}\n  v \\<notin> dom (discovered s)\n  u = hd (stack s)\n  s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n  \\<lparr>state.more := e_\\<rparr>\n\ngoal (1 subgoal):\n 1. stack s \\<noteq> []", "by (simp add: cond_alt)"], ["proof (state)\nthis:\n  stack s \\<noteq> []\n\ngoal (5 subgoals):\n 1. \\<And>e.\n       \\<forall>(v, v')\\<in>tree_edges (empty_state e).\n          \\<delta> (empty_state e) v < \\<delta> (empty_state e) v'\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>\\<forall>(v, v')\\<in>tree_edges s.\n                   \\<delta> s v < \\<delta> s v';\n        cond s; DFS_invar G param s; DFS_invar G param s'; stack s = [];\n        v0 \\<notin> dom (discovered s); v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, v')\\<in>tree_edges s'.\n                            \\<delta> s' v < \\<delta> s' v'\n 3. \\<And>s s' u e.\n       \\<lbrakk>\\<forall>(v, v')\\<in>tree_edges s.\n                   \\<delta> s v < \\<delta> s v';\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; pending s `` {u} = {}; u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, v')\\<in>tree_edges s'.\n                            \\<delta> s' v < \\<delta> s' v'\n 4. \\<And>s s' u v e c b.\n       \\<lbrakk>\\<forall>(v, v')\\<in>tree_edges s.\n                   \\<delta> s v < \\<delta> s v';\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); u = hd (stack s);\n        cross_edges s \\<subseteq> c; back_edges s \\<subseteq> b;\n        s' = s\n        \\<lparr>pending := pending s - {(u, v)}, state.more := e,\n           cross_edges := c, back_edges := b\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, v')\\<in>tree_edges s'.\n                            \\<delta> s' v < \\<delta> s' v'\n 5. \\<And>s s' u v e.\n       \\<lbrakk>\\<forall>(v, v')\\<in>tree_edges s.\n                   \\<delta> s v < \\<delta> s v';\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, v')\\<in>tree_edges s'.\n                            \\<delta> s' v < \\<delta> s' v'", "from discover tree_edges_discovered"], ["proof (chain)\npicking this:\n  \\<forall>(v, v')\\<in>tree_edges s. \\<delta> s v < \\<delta> s v'\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s \\<noteq> []\n  v \\<in> pending s `` {u}\n  v \\<notin> dom (discovered s)\n  u = hd (stack s)\n  s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n  \\<lparr>state.more := e_\\<rparr>\n  Field (tree_edges s) \\<subseteq> dom (discovered s)", "have \n      v_notin_tree: \"\\<forall>(x,x') \\<in> tree_edges s. x \\<noteq> v \\<and> x' \\<noteq> v\""], ["proof (prove)\nusing this:\n  \\<forall>(v, v')\\<in>tree_edges s. \\<delta> s v < \\<delta> s v'\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s \\<noteq> []\n  v \\<in> pending s `` {u}\n  v \\<notin> dom (discovered s)\n  u = hd (stack s)\n  s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n  \\<lparr>state.more := e_\\<rparr>\n  Field (tree_edges s) \\<subseteq> dom (discovered s)\n\ngoal (1 subgoal):\n 1. \\<forall>(x, x')\\<in>tree_edges s. x \\<noteq> v \\<and> x' \\<noteq> v", "by (blast intro!: Field_not_elem)"], ["proof (state)\nthis:\n  \\<forall>(x, x')\\<in>tree_edges s. x \\<noteq> v \\<and> x' \\<noteq> v\n\ngoal (5 subgoals):\n 1. \\<And>e.\n       \\<forall>(v, v')\\<in>tree_edges (empty_state e).\n          \\<delta> (empty_state e) v < \\<delta> (empty_state e) v'\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>\\<forall>(v, v')\\<in>tree_edges s.\n                   \\<delta> s v < \\<delta> s v';\n        cond s; DFS_invar G param s; DFS_invar G param s'; stack s = [];\n        v0 \\<notin> dom (discovered s); v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, v')\\<in>tree_edges s'.\n                            \\<delta> s' v < \\<delta> s' v'\n 3. \\<And>s s' u e.\n       \\<lbrakk>\\<forall>(v, v')\\<in>tree_edges s.\n                   \\<delta> s v < \\<delta> s v';\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; pending s `` {u} = {}; u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, v')\\<in>tree_edges s'.\n                            \\<delta> s' v < \\<delta> s' v'\n 4. \\<And>s s' u v e c b.\n       \\<lbrakk>\\<forall>(v, v')\\<in>tree_edges s.\n                   \\<delta> s v < \\<delta> s v';\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); u = hd (stack s);\n        cross_edges s \\<subseteq> c; back_edges s \\<subseteq> b;\n        s' = s\n        \\<lparr>pending := pending s - {(u, v)}, state.more := e,\n           cross_edges := c, back_edges := b\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, v')\\<in>tree_edges s'.\n                            \\<delta> s' v < \\<delta> s' v'\n 5. \\<And>s s' u v e.\n       \\<lbrakk>\\<forall>(v, v')\\<in>tree_edges s.\n                   \\<delta> s v < \\<delta> s v';\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, v')\\<in>tree_edges s'.\n                            \\<delta> s' v < \\<delta> s' v'", "from discover stack_discovered"], ["proof (chain)\npicking this:\n  \\<forall>(v, v')\\<in>tree_edges s. \\<delta> s v < \\<delta> s v'\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s \\<noteq> []\n  v \\<in> pending s `` {u}\n  v \\<notin> dom (discovered s)\n  u = hd (stack s)\n  s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n  \\<lparr>state.more := e_\\<rparr>\n  set (stack s) \\<subseteq> dom (discovered s)", "have \n      v_hd: \"hd (stack s) \\<noteq> v\""], ["proof (prove)\nusing this:\n  \\<forall>(v, v')\\<in>tree_edges s. \\<delta> s v < \\<delta> s v'\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s \\<noteq> []\n  v \\<in> pending s `` {u}\n  v \\<notin> dom (discovered s)\n  u = hd (stack s)\n  s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n  \\<lparr>state.more := e_\\<rparr>\n  set (stack s) \\<subseteq> dom (discovered s)\n\ngoal (1 subgoal):\n 1. hd (stack s) \\<noteq> v", "using hd_in_set[OF NE]"], ["proof (prove)\nusing this:\n  \\<forall>(v, v')\\<in>tree_edges s. \\<delta> s v < \\<delta> s v'\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s \\<noteq> []\n  v \\<in> pending s `` {u}\n  v \\<notin> dom (discovered s)\n  u = hd (stack s)\n  s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n  \\<lparr>state.more := e_\\<rparr>\n  set (stack s) \\<subseteq> dom (discovered s)\n  hd (stack s) \\<in> set (stack s)\n\ngoal (1 subgoal):\n 1. hd (stack s) \\<noteq> v", "by blast"], ["proof (state)\nthis:\n  hd (stack s) \\<noteq> v\n\ngoal (5 subgoals):\n 1. \\<And>e.\n       \\<forall>(v, v')\\<in>tree_edges (empty_state e).\n          \\<delta> (empty_state e) v < \\<delta> (empty_state e) v'\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>\\<forall>(v, v')\\<in>tree_edges s.\n                   \\<delta> s v < \\<delta> s v';\n        cond s; DFS_invar G param s; DFS_invar G param s'; stack s = [];\n        v0 \\<notin> dom (discovered s); v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, v')\\<in>tree_edges s'.\n                            \\<delta> s' v < \\<delta> s' v'\n 3. \\<And>s s' u e.\n       \\<lbrakk>\\<forall>(v, v')\\<in>tree_edges s.\n                   \\<delta> s v < \\<delta> s v';\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; pending s `` {u} = {}; u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, v')\\<in>tree_edges s'.\n                            \\<delta> s' v < \\<delta> s' v'\n 4. \\<And>s s' u v e c b.\n       \\<lbrakk>\\<forall>(v, v')\\<in>tree_edges s.\n                   \\<delta> s v < \\<delta> s v';\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); u = hd (stack s);\n        cross_edges s \\<subseteq> c; back_edges s \\<subseteq> b;\n        s' = s\n        \\<lparr>pending := pending s - {(u, v)}, state.more := e,\n           cross_edges := c, back_edges := b\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, v')\\<in>tree_edges s'.\n                            \\<delta> s' v < \\<delta> s' v'\n 5. \\<And>s s' u v e.\n       \\<lbrakk>\\<forall>(v, v')\\<in>tree_edges s.\n                   \\<delta> s v < \\<delta> s v';\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, v')\\<in>tree_edges s'.\n                            \\<delta> s' v < \\<delta> s' v'", "{"], ["proof (state)\nthis:\n  hd (stack s) \\<noteq> v\n\ngoal (5 subgoals):\n 1. \\<And>e.\n       \\<forall>(v, v')\\<in>tree_edges (empty_state e).\n          \\<delta> (empty_state e) v < \\<delta> (empty_state e) v'\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>\\<forall>(v, v')\\<in>tree_edges s.\n                   \\<delta> s v < \\<delta> s v';\n        cond s; DFS_invar G param s; DFS_invar G param s'; stack s = [];\n        v0 \\<notin> dom (discovered s); v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, v')\\<in>tree_edges s'.\n                            \\<delta> s' v < \\<delta> s' v'\n 3. \\<And>s s' u e.\n       \\<lbrakk>\\<forall>(v, v')\\<in>tree_edges s.\n                   \\<delta> s v < \\<delta> s v';\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; pending s `` {u} = {}; u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, v')\\<in>tree_edges s'.\n                            \\<delta> s' v < \\<delta> s' v'\n 4. \\<And>s s' u v e c b.\n       \\<lbrakk>\\<forall>(v, v')\\<in>tree_edges s.\n                   \\<delta> s v < \\<delta> s v';\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); u = hd (stack s);\n        cross_edges s \\<subseteq> c; back_edges s \\<subseteq> b;\n        s' = s\n        \\<lparr>pending := pending s - {(u, v)}, state.more := e,\n           cross_edges := c, back_edges := b\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, v')\\<in>tree_edges s'.\n                            \\<delta> s' v < \\<delta> s' v'\n 5. \\<And>s s' u v e.\n       \\<lbrakk>\\<forall>(v, v')\\<in>tree_edges s.\n                   \\<delta> s v < \\<delta> s v';\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, v')\\<in>tree_edges s'.\n                            \\<delta> s' v < \\<delta> s' v'", "fix a b"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>e.\n       \\<forall>(v, v')\\<in>tree_edges (empty_state e).\n          \\<delta> (empty_state e) v < \\<delta> (empty_state e) v'\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>\\<forall>(v, v')\\<in>tree_edges s.\n                   \\<delta> s v < \\<delta> s v';\n        cond s; DFS_invar G param s; DFS_invar G param s'; stack s = [];\n        v0 \\<notin> dom (discovered s); v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, v')\\<in>tree_edges s'.\n                            \\<delta> s' v < \\<delta> s' v'\n 3. \\<And>s s' u e.\n       \\<lbrakk>\\<forall>(v, v')\\<in>tree_edges s.\n                   \\<delta> s v < \\<delta> s v';\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; pending s `` {u} = {}; u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, v')\\<in>tree_edges s'.\n                            \\<delta> s' v < \\<delta> s' v'\n 4. \\<And>s s' u v e c b.\n       \\<lbrakk>\\<forall>(v, v')\\<in>tree_edges s.\n                   \\<delta> s v < \\<delta> s v';\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); u = hd (stack s);\n        cross_edges s \\<subseteq> c; back_edges s \\<subseteq> b;\n        s' = s\n        \\<lparr>pending := pending s - {(u, v)}, state.more := e,\n           cross_edges := c, back_edges := b\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, v')\\<in>tree_edges s'.\n                            \\<delta> s' v < \\<delta> s' v'\n 5. \\<And>s s' u v e.\n       \\<lbrakk>\\<forall>(v, v')\\<in>tree_edges s.\n                   \\<delta> s v < \\<delta> s v';\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, v')\\<in>tree_edges s'.\n                            \\<delta> s' v < \\<delta> s' v'", "assume T: \"(a,b) \\<in> tree_edges s'\""], ["proof (state)\nthis:\n  (a, b) \\<in> tree_edges s'\n\ngoal (5 subgoals):\n 1. \\<And>e.\n       \\<forall>(v, v')\\<in>tree_edges (empty_state e).\n          \\<delta> (empty_state e) v < \\<delta> (empty_state e) v'\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>\\<forall>(v, v')\\<in>tree_edges s.\n                   \\<delta> s v < \\<delta> s v';\n        cond s; DFS_invar G param s; DFS_invar G param s'; stack s = [];\n        v0 \\<notin> dom (discovered s); v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, v')\\<in>tree_edges s'.\n                            \\<delta> s' v < \\<delta> s' v'\n 3. \\<And>s s' u e.\n       \\<lbrakk>\\<forall>(v, v')\\<in>tree_edges s.\n                   \\<delta> s v < \\<delta> s v';\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; pending s `` {u} = {}; u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, v')\\<in>tree_edges s'.\n                            \\<delta> s' v < \\<delta> s' v'\n 4. \\<And>s s' u v e c b.\n       \\<lbrakk>\\<forall>(v, v')\\<in>tree_edges s.\n                   \\<delta> s v < \\<delta> s v';\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); u = hd (stack s);\n        cross_edges s \\<subseteq> c; back_edges s \\<subseteq> b;\n        s' = s\n        \\<lparr>pending := pending s - {(u, v)}, state.more := e,\n           cross_edges := c, back_edges := b\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, v')\\<in>tree_edges s'.\n                            \\<delta> s' v < \\<delta> s' v'\n 5. \\<And>s s' u v e.\n       \\<lbrakk>\\<forall>(v, v')\\<in>tree_edges s.\n                   \\<delta> s v < \\<delta> s v';\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, v')\\<in>tree_edges s'.\n                            \\<delta> s' v < \\<delta> s' v'", "have \"\\<delta> s' a < \\<delta> s' b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<delta> s' a < \\<delta> s' b", "proof (cases \"b = v\")"], ["proof (state)\ngoal (2 subgoals):\n 1. b = v \\<Longrightarrow> \\<delta> s' a < \\<delta> s' b\n 2. b \\<noteq> v \\<Longrightarrow> \\<delta> s' a < \\<delta> s' b", "case True"], ["proof (state)\nthis:\n  b = v\n\ngoal (2 subgoals):\n 1. b = v \\<Longrightarrow> \\<delta> s' a < \\<delta> s' b\n 2. b \\<noteq> v \\<Longrightarrow> \\<delta> s' a < \\<delta> s' b", "with T v_notin_tree"], ["proof (chain)\npicking this:\n  (a, b) \\<in> tree_edges s'\n  \\<forall>(x, x')\\<in>tree_edges s. x \\<noteq> v \\<and> x' \\<noteq> v\n  b = v", "have [simp]: \"a = hd (stack s)\""], ["proof (prove)\nusing this:\n  (a, b) \\<in> tree_edges s'\n  \\<forall>(x, x')\\<in>tree_edges s. x \\<noteq> v \\<and> x' \\<noteq> v\n  b = v\n\ngoal (1 subgoal):\n 1. a = hd (stack s)", "by auto"], ["proof (state)\nthis:\n  a = hd (stack s)\n\ngoal (2 subgoals):\n 1. b = v \\<Longrightarrow> \\<delta> s' a < \\<delta> s' b\n 2. b \\<noteq> v \\<Longrightarrow> \\<delta> s' a < \\<delta> s' b", "with stack_discovered"], ["proof (chain)\npicking this:\n  set (stack s) \\<subseteq> dom (discovered s)\n  a = hd (stack s)", "have \"a \\<in> dom (discovered s)\""], ["proof (prove)\nusing this:\n  set (stack s) \\<subseteq> dom (discovered s)\n  a = hd (stack s)\n\ngoal (1 subgoal):\n 1. a \\<in> dom (discovered s)", "by (metis hd_in_set NE subsetD)"], ["proof (state)\nthis:\n  a \\<in> dom (discovered s)\n\ngoal (2 subgoals):\n 1. b = v \\<Longrightarrow> \\<delta> s' a < \\<delta> s' b\n 2. b \\<noteq> v \\<Longrightarrow> \\<delta> s' a < \\<delta> s' b", "with v_hd True timing_less_counter"], ["proof (chain)\npicking this:\n  hd (stack s) \\<noteq> v\n  b = v\n  ?v \\<in> dom (discovered s) \\<Longrightarrow> \\<delta> s ?v < counter s\n  ?v \\<in> dom (finished s) \\<Longrightarrow> \\<phi> s ?v < counter s\n  a \\<in> dom (discovered s)", "show ?thesis"], ["proof (prove)\nusing this:\n  hd (stack s) \\<noteq> v\n  b = v\n  ?v \\<in> dom (discovered s) \\<Longrightarrow> \\<delta> s ?v < counter s\n  ?v \\<in> dom (finished s) \\<Longrightarrow> \\<phi> s ?v < counter s\n  a \\<in> dom (discovered s)\n\ngoal (1 subgoal):\n 1. \\<delta> s' a < \\<delta> s' b", "by simp"], ["proof (state)\nthis:\n  \\<delta> s' a < \\<delta> s' b\n\ngoal (1 subgoal):\n 1. b \\<noteq> v \\<Longrightarrow> \\<delta> s' a < \\<delta> s' b", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. b \\<noteq> v \\<Longrightarrow> \\<delta> s' a < \\<delta> s' b", "case False"], ["proof (state)\nthis:\n  b \\<noteq> v\n\ngoal (1 subgoal):\n 1. b \\<noteq> v \\<Longrightarrow> \\<delta> s' a < \\<delta> s' b", "with v_notin_tree T"], ["proof (chain)\npicking this:\n  \\<forall>(x, x')\\<in>tree_edges s. x \\<noteq> v \\<and> x' \\<noteq> v\n  (a, b) \\<in> tree_edges s'\n  b \\<noteq> v", "have \"(a,b) \\<in> tree_edges s\" \"a \\<noteq> v\""], ["proof (prove)\nusing this:\n  \\<forall>(x, x')\\<in>tree_edges s. x \\<noteq> v \\<and> x' \\<noteq> v\n  (a, b) \\<in> tree_edges s'\n  b \\<noteq> v\n\ngoal (1 subgoal):\n 1. (a, b) \\<in> tree_edges s &&& a \\<noteq> v", "by auto"], ["proof (state)\nthis:\n  (a, b) \\<in> tree_edges s\n  a \\<noteq> v\n\ngoal (1 subgoal):\n 1. b \\<noteq> v \\<Longrightarrow> \\<delta> s' a < \\<delta> s' b", "with discover"], ["proof (chain)\npicking this:\n  \\<forall>(v, v')\\<in>tree_edges s. \\<delta> s v < \\<delta> s v'\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s \\<noteq> []\n  v \\<in> pending s `` {u}\n  v \\<notin> dom (discovered s)\n  u = hd (stack s)\n  s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n  \\<lparr>state.more := e_\\<rparr>\n  (a, b) \\<in> tree_edges s\n  a \\<noteq> v", "have \"\\<delta> s a < \\<delta> s b\""], ["proof (prove)\nusing this:\n  \\<forall>(v, v')\\<in>tree_edges s. \\<delta> s v < \\<delta> s v'\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s \\<noteq> []\n  v \\<in> pending s `` {u}\n  v \\<notin> dom (discovered s)\n  u = hd (stack s)\n  s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n  \\<lparr>state.more := e_\\<rparr>\n  (a, b) \\<in> tree_edges s\n  a \\<noteq> v\n\ngoal (1 subgoal):\n 1. \\<delta> s a < \\<delta> s b", "by auto"], ["proof (state)\nthis:\n  \\<delta> s a < \\<delta> s b\n\ngoal (1 subgoal):\n 1. b \\<noteq> v \\<Longrightarrow> \\<delta> s' a < \\<delta> s' b", "with False \\<open>a\\<noteq>v\\<close>"], ["proof (chain)\npicking this:\n  b \\<noteq> v\n  a \\<noteq> v\n  \\<delta> s a < \\<delta> s b", "show ?thesis"], ["proof (prove)\nusing this:\n  b \\<noteq> v\n  a \\<noteq> v\n  \\<delta> s a < \\<delta> s b\n\ngoal (1 subgoal):\n 1. \\<delta> s' a < \\<delta> s' b", "by simp"], ["proof (state)\nthis:\n  \\<delta> s' a < \\<delta> s' b\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<delta> s' a < \\<delta> s' b\n\ngoal (5 subgoals):\n 1. \\<And>e.\n       \\<forall>(v, v')\\<in>tree_edges (empty_state e).\n          \\<delta> (empty_state e) v < \\<delta> (empty_state e) v'\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>\\<forall>(v, v')\\<in>tree_edges s.\n                   \\<delta> s v < \\<delta> s v';\n        cond s; DFS_invar G param s; DFS_invar G param s'; stack s = [];\n        v0 \\<notin> dom (discovered s); v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, v')\\<in>tree_edges s'.\n                            \\<delta> s' v < \\<delta> s' v'\n 3. \\<And>s s' u e.\n       \\<lbrakk>\\<forall>(v, v')\\<in>tree_edges s.\n                   \\<delta> s v < \\<delta> s v';\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; pending s `` {u} = {}; u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, v')\\<in>tree_edges s'.\n                            \\<delta> s' v < \\<delta> s' v'\n 4. \\<And>s s' u v e c b.\n       \\<lbrakk>\\<forall>(v, v')\\<in>tree_edges s.\n                   \\<delta> s v < \\<delta> s v';\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); u = hd (stack s);\n        cross_edges s \\<subseteq> c; back_edges s \\<subseteq> b;\n        s' = s\n        \\<lparr>pending := pending s - {(u, v)}, state.more := e,\n           cross_edges := c, back_edges := b\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, v')\\<in>tree_edges s'.\n                            \\<delta> s' v < \\<delta> s' v'\n 5. \\<And>s s' u v e.\n       \\<lbrakk>\\<forall>(v, v')\\<in>tree_edges s.\n                   \\<delta> s v < \\<delta> s v';\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, v')\\<in>tree_edges s'.\n                            \\<delta> s' v < \\<delta> s' v'", "}"], ["proof (state)\nthis:\n  (?a9, ?b9) \\<in> tree_edges s' \\<Longrightarrow>\n  \\<delta> s' ?a9 < \\<delta> s' ?b9\n\ngoal (5 subgoals):\n 1. \\<And>e.\n       \\<forall>(v, v')\\<in>tree_edges (empty_state e).\n          \\<delta> (empty_state e) v < \\<delta> (empty_state e) v'\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>\\<forall>(v, v')\\<in>tree_edges s.\n                   \\<delta> s v < \\<delta> s v';\n        cond s; DFS_invar G param s; DFS_invar G param s'; stack s = [];\n        v0 \\<notin> dom (discovered s); v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, v')\\<in>tree_edges s'.\n                            \\<delta> s' v < \\<delta> s' v'\n 3. \\<And>s s' u e.\n       \\<lbrakk>\\<forall>(v, v')\\<in>tree_edges s.\n                   \\<delta> s v < \\<delta> s v';\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; pending s `` {u} = {}; u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, v')\\<in>tree_edges s'.\n                            \\<delta> s' v < \\<delta> s' v'\n 4. \\<And>s s' u v e c b.\n       \\<lbrakk>\\<forall>(v, v')\\<in>tree_edges s.\n                   \\<delta> s v < \\<delta> s v';\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); u = hd (stack s);\n        cross_edges s \\<subseteq> c; back_edges s \\<subseteq> b;\n        s' = s\n        \\<lparr>pending := pending s - {(u, v)}, state.more := e,\n           cross_edges := c, back_edges := b\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, v')\\<in>tree_edges s'.\n                            \\<delta> s' v < \\<delta> s' v'\n 5. \\<And>s s' u v e.\n       \\<lbrakk>\\<forall>(v, v')\\<in>tree_edges s.\n                   \\<delta> s v < \\<delta> s v';\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, v')\\<in>tree_edges s'.\n                            \\<delta> s' v < \\<delta> s' v'", "thus ?case"], ["proof (prove)\nusing this:\n  (?a9, ?b9) \\<in> tree_edges s' \\<Longrightarrow>\n  \\<delta> s' ?a9 < \\<delta> s' ?b9\n\ngoal (1 subgoal):\n 1. \\<forall>(v, v')\\<in>tree_edges s'. \\<delta> s' v < \\<delta> s' v'", "by blast"], ["proof (state)\nthis:\n  \\<forall>(v, v')\\<in>tree_edges s'. \\<delta> s' v < \\<delta> s' v'\n\ngoal (4 subgoals):\n 1. \\<And>e.\n       \\<forall>(v, v')\\<in>tree_edges (empty_state e).\n          \\<delta> (empty_state e) v < \\<delta> (empty_state e) v'\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>\\<forall>(v, v')\\<in>tree_edges s.\n                   \\<delta> s v < \\<delta> s v';\n        cond s; DFS_invar G param s; DFS_invar G param s'; stack s = [];\n        v0 \\<notin> dom (discovered s); v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, v')\\<in>tree_edges s'.\n                            \\<delta> s' v < \\<delta> s' v'\n 3. \\<And>s s' u e.\n       \\<lbrakk>\\<forall>(v, v')\\<in>tree_edges s.\n                   \\<delta> s v < \\<delta> s v';\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; pending s `` {u} = {}; u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, v')\\<in>tree_edges s'.\n                            \\<delta> s' v < \\<delta> s' v'\n 4. \\<And>s s' u v e c b.\n       \\<lbrakk>\\<forall>(v, v')\\<in>tree_edges s.\n                   \\<delta> s v < \\<delta> s v';\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); u = hd (stack s);\n        cross_edges s \\<subseteq> c; back_edges s \\<subseteq> b;\n        s' = s\n        \\<lparr>pending := pending s - {(u, v)}, state.more := e,\n           cross_edges := c, back_edges := b\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, v')\\<in>tree_edges s'.\n                            \\<delta> s' v < \\<delta> s' v'", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>e.\n       \\<forall>(v, v')\\<in>tree_edges (empty_state e).\n          \\<delta> (empty_state e) v < \\<delta> (empty_state e) v'\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>\\<forall>(v, v')\\<in>tree_edges s.\n                   \\<delta> s v < \\<delta> s v';\n        cond s; DFS_invar G param s; DFS_invar G param s'; stack s = [];\n        v0 \\<notin> dom (discovered s); v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, v')\\<in>tree_edges s'.\n                            \\<delta> s' v < \\<delta> s' v'\n 3. \\<And>s s' u e.\n       \\<lbrakk>\\<forall>(v, v')\\<in>tree_edges s.\n                   \\<delta> s v < \\<delta> s v';\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; pending s `` {u} = {}; u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, v')\\<in>tree_edges s'.\n                            \\<delta> s' v < \\<delta> s' v'\n 4. \\<And>s s' u v e c b.\n       \\<lbrakk>\\<forall>(v, v')\\<in>tree_edges s.\n                   \\<delta> s v < \\<delta> s v';\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); u = hd (stack s);\n        cross_edges s \\<subseteq> c; back_edges s \\<subseteq> b;\n        s' = s\n        \\<lparr>pending := pending s - {(u, v)}, state.more := e,\n           cross_edges := c, back_edges := b\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, v')\\<in>tree_edges s'.\n                            \\<delta> s' v < \\<delta> s' v'", "case (new_root s s' v0)"], ["proof (state)\nthis:\n  \\<forall>(v, v')\\<in>tree_edges s. \\<delta> s v < \\<delta> s v'\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s = []\n  v0 \\<notin> dom (discovered s)\n  v0 \\<in> V0\n  s' = new_root v0 s\\<lparr>state.more := e_\\<rparr>\n\ngoal (4 subgoals):\n 1. \\<And>e.\n       \\<forall>(v, v')\\<in>tree_edges (empty_state e).\n          \\<delta> (empty_state e) v < \\<delta> (empty_state e) v'\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>\\<forall>(v, v')\\<in>tree_edges s.\n                   \\<delta> s v < \\<delta> s v';\n        cond s; DFS_invar G param s; DFS_invar G param s'; stack s = [];\n        v0 \\<notin> dom (discovered s); v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, v')\\<in>tree_edges s'.\n                            \\<delta> s' v < \\<delta> s' v'\n 3. \\<And>s s' u e.\n       \\<lbrakk>\\<forall>(v, v')\\<in>tree_edges s.\n                   \\<delta> s v < \\<delta> s v';\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; pending s `` {u} = {}; u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, v')\\<in>tree_edges s'.\n                            \\<delta> s' v < \\<delta> s' v'\n 4. \\<And>s s' u v e c b.\n       \\<lbrakk>\\<forall>(v, v')\\<in>tree_edges s.\n                   \\<delta> s v < \\<delta> s v';\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); u = hd (stack s);\n        cross_edges s \\<subseteq> c; back_edges s \\<subseteq> b;\n        s' = s\n        \\<lparr>pending := pending s - {(u, v)}, state.more := e,\n           cross_edges := c, back_edges := b\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, v')\\<in>tree_edges s'.\n                            \\<delta> s' v < \\<delta> s' v'", "then"], ["proof (chain)\npicking this:\n  \\<forall>(v, v')\\<in>tree_edges s. \\<delta> s v < \\<delta> s v'\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s = []\n  v0 \\<notin> dom (discovered s)\n  v0 \\<in> V0\n  s' = new_root v0 s\\<lparr>state.more := e_\\<rparr>", "interpret DFS_invar where s=s"], ["proof (prove)\nusing this:\n  \\<forall>(v, v')\\<in>tree_edges s. \\<delta> s v < \\<delta> s v'\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s = []\n  v0 \\<notin> dom (discovered s)\n  v0 \\<in> V0\n  s' = new_root v0 s\\<lparr>state.more := e_\\<rparr>\n\ngoal (1 subgoal):\n 1. DFS_invar G param s", "by simp"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>e.\n       \\<forall>(v, v')\\<in>tree_edges (empty_state e).\n          \\<delta> (empty_state e) v < \\<delta> (empty_state e) v'\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>\\<forall>(v, v')\\<in>tree_edges s.\n                   \\<delta> s v < \\<delta> s v';\n        cond s; DFS_invar G param s; DFS_invar G param s'; stack s = [];\n        v0 \\<notin> dom (discovered s); v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, v')\\<in>tree_edges s'.\n                            \\<delta> s' v < \\<delta> s' v'\n 3. \\<And>s s' u e.\n       \\<lbrakk>\\<forall>(v, v')\\<in>tree_edges s.\n                   \\<delta> s v < \\<delta> s v';\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; pending s `` {u} = {}; u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, v')\\<in>tree_edges s'.\n                            \\<delta> s' v < \\<delta> s' v'\n 4. \\<And>s s' u v e c b.\n       \\<lbrakk>\\<forall>(v, v')\\<in>tree_edges s.\n                   \\<delta> s v < \\<delta> s v';\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); u = hd (stack s);\n        cross_edges s \\<subseteq> c; back_edges s \\<subseteq> b;\n        s' = s\n        \\<lparr>pending := pending s - {(u, v)}, state.more := e,\n           cross_edges := c, back_edges := b\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, v')\\<in>tree_edges s'.\n                            \\<delta> s' v < \\<delta> s' v'", "from new_root"], ["proof (chain)\npicking this:\n  \\<forall>(v, v')\\<in>tree_edges s. \\<delta> s v < \\<delta> s v'\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s = []\n  v0 \\<notin> dom (discovered s)\n  v0 \\<in> V0\n  s' = new_root v0 s\\<lparr>state.more := e_\\<rparr>", "have \"tree_edges s' = tree_edges s\""], ["proof (prove)\nusing this:\n  \\<forall>(v, v')\\<in>tree_edges s. \\<delta> s v < \\<delta> s v'\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s = []\n  v0 \\<notin> dom (discovered s)\n  v0 \\<in> V0\n  s' = new_root v0 s\\<lparr>state.more := e_\\<rparr>\n\ngoal (1 subgoal):\n 1. tree_edges s' = tree_edges s", "by simp"], ["proof (state)\nthis:\n  tree_edges s' = tree_edges s\n\ngoal (4 subgoals):\n 1. \\<And>e.\n       \\<forall>(v, v')\\<in>tree_edges (empty_state e).\n          \\<delta> (empty_state e) v < \\<delta> (empty_state e) v'\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>\\<forall>(v, v')\\<in>tree_edges s.\n                   \\<delta> s v < \\<delta> s v';\n        cond s; DFS_invar G param s; DFS_invar G param s'; stack s = [];\n        v0 \\<notin> dom (discovered s); v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, v')\\<in>tree_edges s'.\n                            \\<delta> s' v < \\<delta> s' v'\n 3. \\<And>s s' u e.\n       \\<lbrakk>\\<forall>(v, v')\\<in>tree_edges s.\n                   \\<delta> s v < \\<delta> s v';\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; pending s `` {u} = {}; u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, v')\\<in>tree_edges s'.\n                            \\<delta> s' v < \\<delta> s' v'\n 4. \\<And>s s' u v e c b.\n       \\<lbrakk>\\<forall>(v, v')\\<in>tree_edges s.\n                   \\<delta> s v < \\<delta> s v';\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); u = hd (stack s);\n        cross_edges s \\<subseteq> c; back_edges s \\<subseteq> b;\n        s' = s\n        \\<lparr>pending := pending s - {(u, v)}, state.more := e,\n           cross_edges := c, back_edges := b\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, v')\\<in>tree_edges s'.\n                            \\<delta> s' v < \\<delta> s' v'", "moreover"], ["proof (state)\nthis:\n  tree_edges s' = tree_edges s\n\ngoal (4 subgoals):\n 1. \\<And>e.\n       \\<forall>(v, v')\\<in>tree_edges (empty_state e).\n          \\<delta> (empty_state e) v < \\<delta> (empty_state e) v'\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>\\<forall>(v, v')\\<in>tree_edges s.\n                   \\<delta> s v < \\<delta> s v';\n        cond s; DFS_invar G param s; DFS_invar G param s'; stack s = [];\n        v0 \\<notin> dom (discovered s); v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, v')\\<in>tree_edges s'.\n                            \\<delta> s' v < \\<delta> s' v'\n 3. \\<And>s s' u e.\n       \\<lbrakk>\\<forall>(v, v')\\<in>tree_edges s.\n                   \\<delta> s v < \\<delta> s v';\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; pending s `` {u} = {}; u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, v')\\<in>tree_edges s'.\n                            \\<delta> s' v < \\<delta> s' v'\n 4. \\<And>s s' u v e c b.\n       \\<lbrakk>\\<forall>(v, v')\\<in>tree_edges s.\n                   \\<delta> s v < \\<delta> s v';\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); u = hd (stack s);\n        cross_edges s \\<subseteq> c; back_edges s \\<subseteq> b;\n        s' = s\n        \\<lparr>pending := pending s - {(u, v)}, state.more := e,\n           cross_edges := c, back_edges := b\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, v')\\<in>tree_edges s'.\n                            \\<delta> s' v < \\<delta> s' v'", "from tree_edge_imp_discovered new_root"], ["proof (chain)\npicking this:\n  (?v, ?w) \\<in> tree_edges s \\<Longrightarrow> ?v \\<in> dom (discovered s)\n  (?v, ?w) \\<in> tree_edges s \\<Longrightarrow> ?w \\<in> dom (discovered s)\n  \\<forall>(v, v')\\<in>tree_edges s. \\<delta> s v < \\<delta> s v'\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s = []\n  v0 \\<notin> dom (discovered s)\n  v0 \\<in> V0\n  s' = new_root v0 s\\<lparr>state.more := e_\\<rparr>", "have \"\\<forall>(v,v') \\<in> tree_edges s. v \\<noteq> v0 \\<and> v' \\<noteq> v0\""], ["proof (prove)\nusing this:\n  (?v, ?w) \\<in> tree_edges s \\<Longrightarrow> ?v \\<in> dom (discovered s)\n  (?v, ?w) \\<in> tree_edges s \\<Longrightarrow> ?w \\<in> dom (discovered s)\n  \\<forall>(v, v')\\<in>tree_edges s. \\<delta> s v < \\<delta> s v'\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s = []\n  v0 \\<notin> dom (discovered s)\n  v0 \\<in> V0\n  s' = new_root v0 s\\<lparr>state.more := e_\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<forall>(v, v')\\<in>tree_edges s. v \\<noteq> v0 \\<and> v' \\<noteq> v0", "by blast"], ["proof (state)\nthis:\n  \\<forall>(v, v')\\<in>tree_edges s. v \\<noteq> v0 \\<and> v' \\<noteq> v0\n\ngoal (4 subgoals):\n 1. \\<And>e.\n       \\<forall>(v, v')\\<in>tree_edges (empty_state e).\n          \\<delta> (empty_state e) v < \\<delta> (empty_state e) v'\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>\\<forall>(v, v')\\<in>tree_edges s.\n                   \\<delta> s v < \\<delta> s v';\n        cond s; DFS_invar G param s; DFS_invar G param s'; stack s = [];\n        v0 \\<notin> dom (discovered s); v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, v')\\<in>tree_edges s'.\n                            \\<delta> s' v < \\<delta> s' v'\n 3. \\<And>s s' u e.\n       \\<lbrakk>\\<forall>(v, v')\\<in>tree_edges s.\n                   \\<delta> s v < \\<delta> s v';\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; pending s `` {u} = {}; u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, v')\\<in>tree_edges s'.\n                            \\<delta> s' v < \\<delta> s' v'\n 4. \\<And>s s' u v e c b.\n       \\<lbrakk>\\<forall>(v, v')\\<in>tree_edges s.\n                   \\<delta> s v < \\<delta> s v';\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); u = hd (stack s);\n        cross_edges s \\<subseteq> c; back_edges s \\<subseteq> b;\n        s' = s\n        \\<lparr>pending := pending s - {(u, v)}, state.more := e,\n           cross_edges := c, back_edges := b\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, v')\\<in>tree_edges s'.\n                            \\<delta> s' v < \\<delta> s' v'", "ultimately"], ["proof (chain)\npicking this:\n  tree_edges s' = tree_edges s\n  \\<forall>(v, v')\\<in>tree_edges s. v \\<noteq> v0 \\<and> v' \\<noteq> v0", "show ?case"], ["proof (prove)\nusing this:\n  tree_edges s' = tree_edges s\n  \\<forall>(v, v')\\<in>tree_edges s. v \\<noteq> v0 \\<and> v' \\<noteq> v0\n\ngoal (1 subgoal):\n 1. \\<forall>(v, v')\\<in>tree_edges s'. \\<delta> s' v < \\<delta> s' v'", "using new_root"], ["proof (prove)\nusing this:\n  tree_edges s' = tree_edges s\n  \\<forall>(v, v')\\<in>tree_edges s. v \\<noteq> v0 \\<and> v' \\<noteq> v0\n  \\<forall>(v, v')\\<in>tree_edges s. \\<delta> s v < \\<delta> s v'\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s = []\n  v0 \\<notin> dom (discovered s)\n  v0 \\<in> V0\n  s' = new_root v0 s\\<lparr>state.more := e_\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<forall>(v, v')\\<in>tree_edges s'. \\<delta> s' v < \\<delta> s' v'", "by auto"], ["proof (state)\nthis:\n  \\<forall>(v, v')\\<in>tree_edges s'. \\<delta> s' v < \\<delta> s' v'\n\ngoal (3 subgoals):\n 1. \\<And>e.\n       \\<forall>(v, v')\\<in>tree_edges (empty_state e).\n          \\<delta> (empty_state e) v < \\<delta> (empty_state e) v'\n 2. \\<And>s s' u e.\n       \\<lbrakk>\\<forall>(v, v')\\<in>tree_edges s.\n                   \\<delta> s v < \\<delta> s v';\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; pending s `` {u} = {}; u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, v')\\<in>tree_edges s'.\n                            \\<delta> s' v < \\<delta> s' v'\n 3. \\<And>s s' u v e c b.\n       \\<lbrakk>\\<forall>(v, v')\\<in>tree_edges s.\n                   \\<delta> s v < \\<delta> s v';\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); u = hd (stack s);\n        cross_edges s \\<subseteq> c; back_edges s \\<subseteq> b;\n        s' = s\n        \\<lparr>pending := pending s - {(u, v)}, state.more := e,\n           cross_edges := c, back_edges := b\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, v')\\<in>tree_edges s'.\n                            \\<delta> s' v < \\<delta> s' v'", "qed simp_all"], ["", "end"], ["", "end"], ["", "context DFS_invar begin"], ["", "context begin"], ["", "interpretation timing_syntax"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma tree_edge_disc:\n    \"(v,w) \\<in> tree_edges s \\<Longrightarrow> \\<delta> s v < \\<delta> s w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (v, w) \\<in> tree_edges s \\<Longrightarrow> \\<delta> s v < \\<delta> s w", "using i_tree_edge_disc[THEN make_invar_thm]"], ["proof (prove)\nusing this:\n  \\<forall>(v, v')\\<in>tree_edges s. \\<delta> s v < \\<delta> s v'\n\ngoal (1 subgoal):\n 1. (v, w) \\<in> tree_edges s \\<Longrightarrow> \\<delta> s v < \\<delta> s w", "by blast"], ["", "lemma tree_path_disc:\n    \"(v,w) \\<in> (tree_edges s)\\<^sup>+ \\<Longrightarrow> \\<delta> s v < \\<delta> s w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (v, w) \\<in> (tree_edges s)\\<^sup>+ \\<Longrightarrow>\n    \\<delta> s v < \\<delta> s w", "by (auto elim!: trancl_induct dest: tree_edge_disc)"], ["", "lemma no_loop_in_tree:\n    \"(v,v) \\<notin> (tree_edges s)\\<^sup>+\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (v, v) \\<notin> (tree_edges s)\\<^sup>+", "using tree_path_disc"], ["proof (prove)\nusing this:\n  (?v, ?w) \\<in> (tree_edges s)\\<^sup>+ \\<Longrightarrow>\n  \\<delta> s ?v < \\<delta> s ?w\n\ngoal (1 subgoal):\n 1. (v, v) \\<notin> (tree_edges s)\\<^sup>+", "by auto"], ["", "lemma tree_acyclic:\n    \"acyclic (tree_edges s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. acyclic (tree_edges s)", "by (metis acyclicI no_loop_in_tree)"], ["", "lemma no_self_loop_in_tree:\n    \"(v,v) \\<notin> tree_edges s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (v, v) \\<notin> tree_edges s", "using tree_edge_disc"], ["proof (prove)\nusing this:\n  (?v, ?w) \\<in> tree_edges s \\<Longrightarrow>\n  \\<delta> s ?v < \\<delta> s ?w\n\ngoal (1 subgoal):\n 1. (v, v) \\<notin> tree_edges s", "by auto"], ["", "lemma tree_edge_unequal:\n    \"(v,w) \\<in> tree_edges s \\<Longrightarrow> v \\<noteq> w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (v, w) \\<in> tree_edges s \\<Longrightarrow> v \\<noteq> w", "by (metis no_self_loop_in_tree)"], ["", "lemma tree_path_unequal:\n    \"(v,w) \\<in> (tree_edges s)\\<^sup>+ \\<Longrightarrow> v \\<noteq> w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (v, w) \\<in> (tree_edges s)\\<^sup>+ \\<Longrightarrow> v \\<noteq> w", "by (metis no_loop_in_tree)"], ["", "lemma tree_subpath':\n    assumes x: \"(x,v) \\<in> (tree_edges s)\\<^sup>+\"\n    and y: \"(y,v) \\<in> (tree_edges s)\\<^sup>+\"\n    and \"x \\<noteq> y\"\n    shows \"(x,y) \\<in> (tree_edges s)\\<^sup>+ \\<or> (y,x) \\<in> (tree_edges s)\\<^sup>+\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x, y) \\<in> (tree_edges s)\\<^sup>+ \\<or>\n    (y, x) \\<in> (tree_edges s)\\<^sup>+", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (x, y) \\<in> (tree_edges s)\\<^sup>+ \\<or>\n    (y, x) \\<in> (tree_edges s)\\<^sup>+", "from x"], ["proof (chain)\npicking this:\n  (x, v) \\<in> (tree_edges s)\\<^sup>+", "obtain px where px: \"path (tree_edges s) x px v\" and \"px \\<noteq> []\""], ["proof (prove)\nusing this:\n  (x, v) \\<in> (tree_edges s)\\<^sup>+\n\ngoal (1 subgoal):\n 1. (\\<And>px.\n        \\<lbrakk>path (tree_edges s) x px v; px \\<noteq> []\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using trancl_is_path"], ["proof (prove)\nusing this:\n  (x, v) \\<in> (tree_edges s)\\<^sup>+\n  \\<lbrakk>(?u, ?v) \\<in> ?E\\<^sup>+;\n   \\<And>l.\n      \\<lbrakk>l \\<noteq> []; path ?E ?u l ?v\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>px.\n        \\<lbrakk>path (tree_edges s) x px v; px \\<noteq> []\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  path (tree_edges s) x px v\n  px \\<noteq> []\n\ngoal (1 subgoal):\n 1. (x, y) \\<in> (tree_edges s)\\<^sup>+ \\<or>\n    (y, x) \\<in> (tree_edges s)\\<^sup>+", "from y"], ["proof (chain)\npicking this:\n  (y, v) \\<in> (tree_edges s)\\<^sup>+", "obtain py where py: \"path (tree_edges s) y py v\" and \"py \\<noteq> []\""], ["proof (prove)\nusing this:\n  (y, v) \\<in> (tree_edges s)\\<^sup>+\n\ngoal (1 subgoal):\n 1. (\\<And>py.\n        \\<lbrakk>path (tree_edges s) y py v; py \\<noteq> []\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using trancl_is_path"], ["proof (prove)\nusing this:\n  (y, v) \\<in> (tree_edges s)\\<^sup>+\n  \\<lbrakk>(?u, ?v) \\<in> ?E\\<^sup>+;\n   \\<And>l.\n      \\<lbrakk>l \\<noteq> []; path ?E ?u l ?v\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>py.\n        \\<lbrakk>path (tree_edges s) y py v; py \\<noteq> []\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  path (tree_edges s) y py v\n  py \\<noteq> []\n\ngoal (1 subgoal):\n 1. (x, y) \\<in> (tree_edges s)\\<^sup>+ \\<or>\n    (y, x) \\<in> (tree_edges s)\\<^sup>+", "from \\<open>px \\<noteq> []\\<close> \\<open>py \\<noteq> []\\<close> px py"], ["proof (chain)\npicking this:\n  px \\<noteq> []\n  py \\<noteq> []\n  path (tree_edges s) x px v\n  path (tree_edges s) y py v", "show ?thesis"], ["proof (prove)\nusing this:\n  px \\<noteq> []\n  py \\<noteq> []\n  path (tree_edges s) x px v\n  path (tree_edges s) y py v\n\ngoal (1 subgoal):\n 1. (x, y) \\<in> (tree_edges s)\\<^sup>+ \\<or>\n    (y, x) \\<in> (tree_edges s)\\<^sup>+", "proof (induction arbitrary: v rule: rev_nonempty_induct2')"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>xa ya v.\n       \\<lbrakk>path (tree_edges s) x [xa] v;\n        path (tree_edges s) y [ya] v\\<rbrakk>\n       \\<Longrightarrow> (x, y) \\<in> (tree_edges s)\\<^sup>+ \\<or>\n                         (y, x) \\<in> (tree_edges s)\\<^sup>+\n 2. \\<And>xa xs ya v.\n       \\<lbrakk>xs \\<noteq> []; path (tree_edges s) x (xs @ [xa]) v;\n        path (tree_edges s) y [ya] v\\<rbrakk>\n       \\<Longrightarrow> (x, y) \\<in> (tree_edges s)\\<^sup>+ \\<or>\n                         (y, x) \\<in> (tree_edges s)\\<^sup>+\n 3. \\<And>xa ya ys v.\n       \\<lbrakk>ys \\<noteq> []; path (tree_edges s) x [xa] v;\n        path (tree_edges s) y (ys @ [ya]) v\\<rbrakk>\n       \\<Longrightarrow> (x, y) \\<in> (tree_edges s)\\<^sup>+ \\<or>\n                         (y, x) \\<in> (tree_edges s)\\<^sup>+\n 4. \\<And>xa xs ya ys v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>path (tree_edges s) x xs v;\n                    path (tree_edges s) y ys v\\<rbrakk>\n                   \\<Longrightarrow> (x, y)\n                                     \\<in> (tree_edges s)\\<^sup>+ \\<or>\n                                     (y, x) \\<in> (tree_edges s)\\<^sup>+;\n        xs \\<noteq> []; ys \\<noteq> []; path (tree_edges s) x (xs @ [xa]) v;\n        path (tree_edges s) y (ys @ [ya]) v\\<rbrakk>\n       \\<Longrightarrow> (x, y) \\<in> (tree_edges s)\\<^sup>+ \\<or>\n                         (y, x) \\<in> (tree_edges s)\\<^sup>+", "case (single)"], ["proof (state)\nthis:\n  path (tree_edges s) x [x_] v\n  path (tree_edges s) y [y_] v\n\ngoal (4 subgoals):\n 1. \\<And>xa ya v.\n       \\<lbrakk>path (tree_edges s) x [xa] v;\n        path (tree_edges s) y [ya] v\\<rbrakk>\n       \\<Longrightarrow> (x, y) \\<in> (tree_edges s)\\<^sup>+ \\<or>\n                         (y, x) \\<in> (tree_edges s)\\<^sup>+\n 2. \\<And>xa xs ya v.\n       \\<lbrakk>xs \\<noteq> []; path (tree_edges s) x (xs @ [xa]) v;\n        path (tree_edges s) y [ya] v\\<rbrakk>\n       \\<Longrightarrow> (x, y) \\<in> (tree_edges s)\\<^sup>+ \\<or>\n                         (y, x) \\<in> (tree_edges s)\\<^sup>+\n 3. \\<And>xa ya ys v.\n       \\<lbrakk>ys \\<noteq> []; path (tree_edges s) x [xa] v;\n        path (tree_edges s) y (ys @ [ya]) v\\<rbrakk>\n       \\<Longrightarrow> (x, y) \\<in> (tree_edges s)\\<^sup>+ \\<or>\n                         (y, x) \\<in> (tree_edges s)\\<^sup>+\n 4. \\<And>xa xs ya ys v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>path (tree_edges s) x xs v;\n                    path (tree_edges s) y ys v\\<rbrakk>\n                   \\<Longrightarrow> (x, y)\n                                     \\<in> (tree_edges s)\\<^sup>+ \\<or>\n                                     (y, x) \\<in> (tree_edges s)\\<^sup>+;\n        xs \\<noteq> []; ys \\<noteq> []; path (tree_edges s) x (xs @ [xa]) v;\n        path (tree_edges s) y (ys @ [ya]) v\\<rbrakk>\n       \\<Longrightarrow> (x, y) \\<in> (tree_edges s)\\<^sup>+ \\<or>\n                         (y, x) \\<in> (tree_edges s)\\<^sup>+", "hence \"(x,v) \\<in> tree_edges s\" \"(y,v) \\<in> tree_edges s\""], ["proof (prove)\nusing this:\n  path (tree_edges s) x [x_] v\n  path (tree_edges s) y [y_] v\n\ngoal (1 subgoal):\n 1. (x, v) \\<in> tree_edges s &&& (y, v) \\<in> tree_edges s", "by (simp_all add: path_simps)"], ["proof (state)\nthis:\n  (x, v) \\<in> tree_edges s\n  (y, v) \\<in> tree_edges s\n\ngoal (4 subgoals):\n 1. \\<And>xa ya v.\n       \\<lbrakk>path (tree_edges s) x [xa] v;\n        path (tree_edges s) y [ya] v\\<rbrakk>\n       \\<Longrightarrow> (x, y) \\<in> (tree_edges s)\\<^sup>+ \\<or>\n                         (y, x) \\<in> (tree_edges s)\\<^sup>+\n 2. \\<And>xa xs ya v.\n       \\<lbrakk>xs \\<noteq> []; path (tree_edges s) x (xs @ [xa]) v;\n        path (tree_edges s) y [ya] v\\<rbrakk>\n       \\<Longrightarrow> (x, y) \\<in> (tree_edges s)\\<^sup>+ \\<or>\n                         (y, x) \\<in> (tree_edges s)\\<^sup>+\n 3. \\<And>xa ya ys v.\n       \\<lbrakk>ys \\<noteq> []; path (tree_edges s) x [xa] v;\n        path (tree_edges s) y (ys @ [ya]) v\\<rbrakk>\n       \\<Longrightarrow> (x, y) \\<in> (tree_edges s)\\<^sup>+ \\<or>\n                         (y, x) \\<in> (tree_edges s)\\<^sup>+\n 4. \\<And>xa xs ya ys v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>path (tree_edges s) x xs v;\n                    path (tree_edges s) y ys v\\<rbrakk>\n                   \\<Longrightarrow> (x, y)\n                                     \\<in> (tree_edges s)\\<^sup>+ \\<or>\n                                     (y, x) \\<in> (tree_edges s)\\<^sup>+;\n        xs \\<noteq> []; ys \\<noteq> []; path (tree_edges s) x (xs @ [xa]) v;\n        path (tree_edges s) y (ys @ [ya]) v\\<rbrakk>\n       \\<Longrightarrow> (x, y) \\<in> (tree_edges s)\\<^sup>+ \\<or>\n                         (y, x) \\<in> (tree_edges s)\\<^sup>+", "with tree_eq_rule"], ["proof (chain)\npicking this:\n  \\<lbrakk>(?v, ?w) \\<in> tree_edges s; (?u, ?w) \\<in> tree_edges s\\<rbrakk>\n  \\<Longrightarrow> ?v = ?u\n  (x, v) \\<in> tree_edges s\n  (y, v) \\<in> tree_edges s", "have \"x=y\""], ["proof (prove)\nusing this:\n  \\<lbrakk>(?v, ?w) \\<in> tree_edges s; (?u, ?w) \\<in> tree_edges s\\<rbrakk>\n  \\<Longrightarrow> ?v = ?u\n  (x, v) \\<in> tree_edges s\n  (y, v) \\<in> tree_edges s\n\ngoal (1 subgoal):\n 1. x = y", "by simp"], ["proof (state)\nthis:\n  x = y\n\ngoal (4 subgoals):\n 1. \\<And>xa ya v.\n       \\<lbrakk>path (tree_edges s) x [xa] v;\n        path (tree_edges s) y [ya] v\\<rbrakk>\n       \\<Longrightarrow> (x, y) \\<in> (tree_edges s)\\<^sup>+ \\<or>\n                         (y, x) \\<in> (tree_edges s)\\<^sup>+\n 2. \\<And>xa xs ya v.\n       \\<lbrakk>xs \\<noteq> []; path (tree_edges s) x (xs @ [xa]) v;\n        path (tree_edges s) y [ya] v\\<rbrakk>\n       \\<Longrightarrow> (x, y) \\<in> (tree_edges s)\\<^sup>+ \\<or>\n                         (y, x) \\<in> (tree_edges s)\\<^sup>+\n 3. \\<And>xa ya ys v.\n       \\<lbrakk>ys \\<noteq> []; path (tree_edges s) x [xa] v;\n        path (tree_edges s) y (ys @ [ya]) v\\<rbrakk>\n       \\<Longrightarrow> (x, y) \\<in> (tree_edges s)\\<^sup>+ \\<or>\n                         (y, x) \\<in> (tree_edges s)\\<^sup>+\n 4. \\<And>xa xs ya ys v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>path (tree_edges s) x xs v;\n                    path (tree_edges s) y ys v\\<rbrakk>\n                   \\<Longrightarrow> (x, y)\n                                     \\<in> (tree_edges s)\\<^sup>+ \\<or>\n                                     (y, x) \\<in> (tree_edges s)\\<^sup>+;\n        xs \\<noteq> []; ys \\<noteq> []; path (tree_edges s) x (xs @ [xa]) v;\n        path (tree_edges s) y (ys @ [ya]) v\\<rbrakk>\n       \\<Longrightarrow> (x, y) \\<in> (tree_edges s)\\<^sup>+ \\<or>\n                         (y, x) \\<in> (tree_edges s)\\<^sup>+", "with \\<open>x\\<noteq>y\\<close>"], ["proof (chain)\npicking this:\n  x \\<noteq> y\n  x = y", "show ?case"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  x = y\n\ngoal (1 subgoal):\n 1. (x, y) \\<in> (tree_edges s)\\<^sup>+ \\<or>\n    (y, x) \\<in> (tree_edges s)\\<^sup>+", "by contradiction"], ["proof (state)\nthis:\n  (x, y) \\<in> (tree_edges s)\\<^sup>+ \\<or>\n  (y, x) \\<in> (tree_edges s)\\<^sup>+\n\ngoal (3 subgoals):\n 1. \\<And>xa xs ya v.\n       \\<lbrakk>xs \\<noteq> []; path (tree_edges s) x (xs @ [xa]) v;\n        path (tree_edges s) y [ya] v\\<rbrakk>\n       \\<Longrightarrow> (x, y) \\<in> (tree_edges s)\\<^sup>+ \\<or>\n                         (y, x) \\<in> (tree_edges s)\\<^sup>+\n 2. \\<And>xa ya ys v.\n       \\<lbrakk>ys \\<noteq> []; path (tree_edges s) x [xa] v;\n        path (tree_edges s) y (ys @ [ya]) v\\<rbrakk>\n       \\<Longrightarrow> (x, y) \\<in> (tree_edges s)\\<^sup>+ \\<or>\n                         (y, x) \\<in> (tree_edges s)\\<^sup>+\n 3. \\<And>xa xs ya ys v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>path (tree_edges s) x xs v;\n                    path (tree_edges s) y ys v\\<rbrakk>\n                   \\<Longrightarrow> (x, y)\n                                     \\<in> (tree_edges s)\\<^sup>+ \\<or>\n                                     (y, x) \\<in> (tree_edges s)\\<^sup>+;\n        xs \\<noteq> []; ys \\<noteq> []; path (tree_edges s) x (xs @ [xa]) v;\n        path (tree_edges s) y (ys @ [ya]) v\\<rbrakk>\n       \\<Longrightarrow> (x, y) \\<in> (tree_edges s)\\<^sup>+ \\<or>\n                         (y, x) \\<in> (tree_edges s)\\<^sup>+", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>xa xs ya v.\n       \\<lbrakk>xs \\<noteq> []; path (tree_edges s) x (xs @ [xa]) v;\n        path (tree_edges s) y [ya] v\\<rbrakk>\n       \\<Longrightarrow> (x, y) \\<in> (tree_edges s)\\<^sup>+ \\<or>\n                         (y, x) \\<in> (tree_edges s)\\<^sup>+\n 2. \\<And>xa ya ys v.\n       \\<lbrakk>ys \\<noteq> []; path (tree_edges s) x [xa] v;\n        path (tree_edges s) y (ys @ [ya]) v\\<rbrakk>\n       \\<Longrightarrow> (x, y) \\<in> (tree_edges s)\\<^sup>+ \\<or>\n                         (y, x) \\<in> (tree_edges s)\\<^sup>+\n 3. \\<And>xa xs ya ys v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>path (tree_edges s) x xs v;\n                    path (tree_edges s) y ys v\\<rbrakk>\n                   \\<Longrightarrow> (x, y)\n                                     \\<in> (tree_edges s)\\<^sup>+ \\<or>\n                                     (y, x) \\<in> (tree_edges s)\\<^sup>+;\n        xs \\<noteq> []; ys \\<noteq> []; path (tree_edges s) x (xs @ [xa]) v;\n        path (tree_edges s) y (ys @ [ya]) v\\<rbrakk>\n       \\<Longrightarrow> (x, y) \\<in> (tree_edges s)\\<^sup>+ \\<or>\n                         (y, x) \\<in> (tree_edges s)\\<^sup>+", "case (snocl a as)"], ["proof (state)\nthis:\n  as \\<noteq> []\n  path (tree_edges s) x (as @ [a]) v\n  path (tree_edges s) y [y_] v\n\ngoal (3 subgoals):\n 1. \\<And>xa xs ya v.\n       \\<lbrakk>xs \\<noteq> []; path (tree_edges s) x (xs @ [xa]) v;\n        path (tree_edges s) y [ya] v\\<rbrakk>\n       \\<Longrightarrow> (x, y) \\<in> (tree_edges s)\\<^sup>+ \\<or>\n                         (y, x) \\<in> (tree_edges s)\\<^sup>+\n 2. \\<And>xa ya ys v.\n       \\<lbrakk>ys \\<noteq> []; path (tree_edges s) x [xa] v;\n        path (tree_edges s) y (ys @ [ya]) v\\<rbrakk>\n       \\<Longrightarrow> (x, y) \\<in> (tree_edges s)\\<^sup>+ \\<or>\n                         (y, x) \\<in> (tree_edges s)\\<^sup>+\n 3. \\<And>xa xs ya ys v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>path (tree_edges s) x xs v;\n                    path (tree_edges s) y ys v\\<rbrakk>\n                   \\<Longrightarrow> (x, y)\n                                     \\<in> (tree_edges s)\\<^sup>+ \\<or>\n                                     (y, x) \\<in> (tree_edges s)\\<^sup>+;\n        xs \\<noteq> []; ys \\<noteq> []; path (tree_edges s) x (xs @ [xa]) v;\n        path (tree_edges s) y (ys @ [ya]) v\\<rbrakk>\n       \\<Longrightarrow> (x, y) \\<in> (tree_edges s)\\<^sup>+ \\<or>\n                         (y, x) \\<in> (tree_edges s)\\<^sup>+", "hence \"(y,v) \\<in> tree_edges s\""], ["proof (prove)\nusing this:\n  as \\<noteq> []\n  path (tree_edges s) x (as @ [a]) v\n  path (tree_edges s) y [y_] v\n\ngoal (1 subgoal):\n 1. (y, v) \\<in> tree_edges s", "by (simp add: path_simps)"], ["proof (state)\nthis:\n  (y, v) \\<in> tree_edges s\n\ngoal (3 subgoals):\n 1. \\<And>xa xs ya v.\n       \\<lbrakk>xs \\<noteq> []; path (tree_edges s) x (xs @ [xa]) v;\n        path (tree_edges s) y [ya] v\\<rbrakk>\n       \\<Longrightarrow> (x, y) \\<in> (tree_edges s)\\<^sup>+ \\<or>\n                         (y, x) \\<in> (tree_edges s)\\<^sup>+\n 2. \\<And>xa ya ys v.\n       \\<lbrakk>ys \\<noteq> []; path (tree_edges s) x [xa] v;\n        path (tree_edges s) y (ys @ [ya]) v\\<rbrakk>\n       \\<Longrightarrow> (x, y) \\<in> (tree_edges s)\\<^sup>+ \\<or>\n                         (y, x) \\<in> (tree_edges s)\\<^sup>+\n 3. \\<And>xa xs ya ys v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>path (tree_edges s) x xs v;\n                    path (tree_edges s) y ys v\\<rbrakk>\n                   \\<Longrightarrow> (x, y)\n                                     \\<in> (tree_edges s)\\<^sup>+ \\<or>\n                                     (y, x) \\<in> (tree_edges s)\\<^sup>+;\n        xs \\<noteq> []; ys \\<noteq> []; path (tree_edges s) x (xs @ [xa]) v;\n        path (tree_edges s) y (ys @ [ya]) v\\<rbrakk>\n       \\<Longrightarrow> (x, y) \\<in> (tree_edges s)\\<^sup>+ \\<or>\n                         (y, x) \\<in> (tree_edges s)\\<^sup>+", "moreover"], ["proof (state)\nthis:\n  (y, v) \\<in> tree_edges s\n\ngoal (3 subgoals):\n 1. \\<And>xa xs ya v.\n       \\<lbrakk>xs \\<noteq> []; path (tree_edges s) x (xs @ [xa]) v;\n        path (tree_edges s) y [ya] v\\<rbrakk>\n       \\<Longrightarrow> (x, y) \\<in> (tree_edges s)\\<^sup>+ \\<or>\n                         (y, x) \\<in> (tree_edges s)\\<^sup>+\n 2. \\<And>xa ya ys v.\n       \\<lbrakk>ys \\<noteq> []; path (tree_edges s) x [xa] v;\n        path (tree_edges s) y (ys @ [ya]) v\\<rbrakk>\n       \\<Longrightarrow> (x, y) \\<in> (tree_edges s)\\<^sup>+ \\<or>\n                         (y, x) \\<in> (tree_edges s)\\<^sup>+\n 3. \\<And>xa xs ya ys v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>path (tree_edges s) x xs v;\n                    path (tree_edges s) y ys v\\<rbrakk>\n                   \\<Longrightarrow> (x, y)\n                                     \\<in> (tree_edges s)\\<^sup>+ \\<or>\n                                     (y, x) \\<in> (tree_edges s)\\<^sup>+;\n        xs \\<noteq> []; ys \\<noteq> []; path (tree_edges s) x (xs @ [xa]) v;\n        path (tree_edges s) y (ys @ [ya]) v\\<rbrakk>\n       \\<Longrightarrow> (x, y) \\<in> (tree_edges s)\\<^sup>+ \\<or>\n                         (y, x) \\<in> (tree_edges s)\\<^sup>+", "from snocl"], ["proof (chain)\npicking this:\n  as \\<noteq> []\n  path (tree_edges s) x (as @ [a]) v\n  path (tree_edges s) y [y_] v", "have \"path (tree_edges s) x as a\" \"(a,v) \\<in> tree_edges s\""], ["proof (prove)\nusing this:\n  as \\<noteq> []\n  path (tree_edges s) x (as @ [a]) v\n  path (tree_edges s) y [y_] v\n\ngoal (1 subgoal):\n 1. path (tree_edges s) x as a &&& (a, v) \\<in> tree_edges s", "by (simp_all add: path_simps)"], ["proof (state)\nthis:\n  path (tree_edges s) x as a\n  (a, v) \\<in> tree_edges s\n\ngoal (3 subgoals):\n 1. \\<And>xa xs ya v.\n       \\<lbrakk>xs \\<noteq> []; path (tree_edges s) x (xs @ [xa]) v;\n        path (tree_edges s) y [ya] v\\<rbrakk>\n       \\<Longrightarrow> (x, y) \\<in> (tree_edges s)\\<^sup>+ \\<or>\n                         (y, x) \\<in> (tree_edges s)\\<^sup>+\n 2. \\<And>xa ya ys v.\n       \\<lbrakk>ys \\<noteq> []; path (tree_edges s) x [xa] v;\n        path (tree_edges s) y (ys @ [ya]) v\\<rbrakk>\n       \\<Longrightarrow> (x, y) \\<in> (tree_edges s)\\<^sup>+ \\<or>\n                         (y, x) \\<in> (tree_edges s)\\<^sup>+\n 3. \\<And>xa xs ya ys v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>path (tree_edges s) x xs v;\n                    path (tree_edges s) y ys v\\<rbrakk>\n                   \\<Longrightarrow> (x, y)\n                                     \\<in> (tree_edges s)\\<^sup>+ \\<or>\n                                     (y, x) \\<in> (tree_edges s)\\<^sup>+;\n        xs \\<noteq> []; ys \\<noteq> []; path (tree_edges s) x (xs @ [xa]) v;\n        path (tree_edges s) y (ys @ [ya]) v\\<rbrakk>\n       \\<Longrightarrow> (x, y) \\<in> (tree_edges s)\\<^sup>+ \\<or>\n                         (y, x) \\<in> (tree_edges s)\\<^sup>+", "ultimately"], ["proof (chain)\npicking this:\n  (y, v) \\<in> tree_edges s\n  path (tree_edges s) x as a\n  (a, v) \\<in> tree_edges s", "have \"path (tree_edges s) x as y\""], ["proof (prove)\nusing this:\n  (y, v) \\<in> tree_edges s\n  path (tree_edges s) x as a\n  (a, v) \\<in> tree_edges s\n\ngoal (1 subgoal):\n 1. path (tree_edges s) x as y", "using tree_eq_rule"], ["proof (prove)\nusing this:\n  (y, v) \\<in> tree_edges s\n  path (tree_edges s) x as a\n  (a, v) \\<in> tree_edges s\n  \\<lbrakk>(?v, ?w) \\<in> tree_edges s; (?u, ?w) \\<in> tree_edges s\\<rbrakk>\n  \\<Longrightarrow> ?v = ?u\n\ngoal (1 subgoal):\n 1. path (tree_edges s) x as y", "by auto"], ["proof (state)\nthis:\n  path (tree_edges s) x as y\n\ngoal (3 subgoals):\n 1. \\<And>xa xs ya v.\n       \\<lbrakk>xs \\<noteq> []; path (tree_edges s) x (xs @ [xa]) v;\n        path (tree_edges s) y [ya] v\\<rbrakk>\n       \\<Longrightarrow> (x, y) \\<in> (tree_edges s)\\<^sup>+ \\<or>\n                         (y, x) \\<in> (tree_edges s)\\<^sup>+\n 2. \\<And>xa ya ys v.\n       \\<lbrakk>ys \\<noteq> []; path (tree_edges s) x [xa] v;\n        path (tree_edges s) y (ys @ [ya]) v\\<rbrakk>\n       \\<Longrightarrow> (x, y) \\<in> (tree_edges s)\\<^sup>+ \\<or>\n                         (y, x) \\<in> (tree_edges s)\\<^sup>+\n 3. \\<And>xa xs ya ys v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>path (tree_edges s) x xs v;\n                    path (tree_edges s) y ys v\\<rbrakk>\n                   \\<Longrightarrow> (x, y)\n                                     \\<in> (tree_edges s)\\<^sup>+ \\<or>\n                                     (y, x) \\<in> (tree_edges s)\\<^sup>+;\n        xs \\<noteq> []; ys \\<noteq> []; path (tree_edges s) x (xs @ [xa]) v;\n        path (tree_edges s) y (ys @ [ya]) v\\<rbrakk>\n       \\<Longrightarrow> (x, y) \\<in> (tree_edges s)\\<^sup>+ \\<or>\n                         (y, x) \\<in> (tree_edges s)\\<^sup>+", "with path_is_trancl \\<open>as \\<noteq> []\\<close>"], ["proof (chain)\npicking this:\n  \\<lbrakk>path ?E ?u ?l ?v; ?l \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> (?u, ?v) \\<in> ?E\\<^sup>+\n  as \\<noteq> []\n  path (tree_edges s) x as y", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>path ?E ?u ?l ?v; ?l \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> (?u, ?v) \\<in> ?E\\<^sup>+\n  as \\<noteq> []\n  path (tree_edges s) x as y\n\ngoal (1 subgoal):\n 1. (x, y) \\<in> (tree_edges s)\\<^sup>+ \\<or>\n    (y, x) \\<in> (tree_edges s)\\<^sup>+", "by metis"], ["proof (state)\nthis:\n  (x, y) \\<in> (tree_edges s)\\<^sup>+ \\<or>\n  (y, x) \\<in> (tree_edges s)\\<^sup>+\n\ngoal (2 subgoals):\n 1. \\<And>xa ya ys v.\n       \\<lbrakk>ys \\<noteq> []; path (tree_edges s) x [xa] v;\n        path (tree_edges s) y (ys @ [ya]) v\\<rbrakk>\n       \\<Longrightarrow> (x, y) \\<in> (tree_edges s)\\<^sup>+ \\<or>\n                         (y, x) \\<in> (tree_edges s)\\<^sup>+\n 2. \\<And>xa xs ya ys v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>path (tree_edges s) x xs v;\n                    path (tree_edges s) y ys v\\<rbrakk>\n                   \\<Longrightarrow> (x, y)\n                                     \\<in> (tree_edges s)\\<^sup>+ \\<or>\n                                     (y, x) \\<in> (tree_edges s)\\<^sup>+;\n        xs \\<noteq> []; ys \\<noteq> []; path (tree_edges s) x (xs @ [xa]) v;\n        path (tree_edges s) y (ys @ [ya]) v\\<rbrakk>\n       \\<Longrightarrow> (x, y) \\<in> (tree_edges s)\\<^sup>+ \\<or>\n                         (y, x) \\<in> (tree_edges s)\\<^sup>+", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xa ya ys v.\n       \\<lbrakk>ys \\<noteq> []; path (tree_edges s) x [xa] v;\n        path (tree_edges s) y (ys @ [ya]) v\\<rbrakk>\n       \\<Longrightarrow> (x, y) \\<in> (tree_edges s)\\<^sup>+ \\<or>\n                         (y, x) \\<in> (tree_edges s)\\<^sup>+\n 2. \\<And>xa xs ya ys v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>path (tree_edges s) x xs v;\n                    path (tree_edges s) y ys v\\<rbrakk>\n                   \\<Longrightarrow> (x, y)\n                                     \\<in> (tree_edges s)\\<^sup>+ \\<or>\n                                     (y, x) \\<in> (tree_edges s)\\<^sup>+;\n        xs \\<noteq> []; ys \\<noteq> []; path (tree_edges s) x (xs @ [xa]) v;\n        path (tree_edges s) y (ys @ [ya]) v\\<rbrakk>\n       \\<Longrightarrow> (x, y) \\<in> (tree_edges s)\\<^sup>+ \\<or>\n                         (y, x) \\<in> (tree_edges s)\\<^sup>+", "case (snocr _ a as)"], ["proof (state)\nthis:\n  as \\<noteq> []\n  path (tree_edges s) x [x_] v\n  path (tree_edges s) y (as @ [a]) v\n\ngoal (2 subgoals):\n 1. \\<And>xa ya ys v.\n       \\<lbrakk>ys \\<noteq> []; path (tree_edges s) x [xa] v;\n        path (tree_edges s) y (ys @ [ya]) v\\<rbrakk>\n       \\<Longrightarrow> (x, y) \\<in> (tree_edges s)\\<^sup>+ \\<or>\n                         (y, x) \\<in> (tree_edges s)\\<^sup>+\n 2. \\<And>xa xs ya ys v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>path (tree_edges s) x xs v;\n                    path (tree_edges s) y ys v\\<rbrakk>\n                   \\<Longrightarrow> (x, y)\n                                     \\<in> (tree_edges s)\\<^sup>+ \\<or>\n                                     (y, x) \\<in> (tree_edges s)\\<^sup>+;\n        xs \\<noteq> []; ys \\<noteq> []; path (tree_edges s) x (xs @ [xa]) v;\n        path (tree_edges s) y (ys @ [ya]) v\\<rbrakk>\n       \\<Longrightarrow> (x, y) \\<in> (tree_edges s)\\<^sup>+ \\<or>\n                         (y, x) \\<in> (tree_edges s)\\<^sup>+", "hence \"(x,v) \\<in> tree_edges s\""], ["proof (prove)\nusing this:\n  as \\<noteq> []\n  path (tree_edges s) x [x_] v\n  path (tree_edges s) y (as @ [a]) v\n\ngoal (1 subgoal):\n 1. (x, v) \\<in> tree_edges s", "by (simp add: path_simps)"], ["proof (state)\nthis:\n  (x, v) \\<in> tree_edges s\n\ngoal (2 subgoals):\n 1. \\<And>xa ya ys v.\n       \\<lbrakk>ys \\<noteq> []; path (tree_edges s) x [xa] v;\n        path (tree_edges s) y (ys @ [ya]) v\\<rbrakk>\n       \\<Longrightarrow> (x, y) \\<in> (tree_edges s)\\<^sup>+ \\<or>\n                         (y, x) \\<in> (tree_edges s)\\<^sup>+\n 2. \\<And>xa xs ya ys v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>path (tree_edges s) x xs v;\n                    path (tree_edges s) y ys v\\<rbrakk>\n                   \\<Longrightarrow> (x, y)\n                                     \\<in> (tree_edges s)\\<^sup>+ \\<or>\n                                     (y, x) \\<in> (tree_edges s)\\<^sup>+;\n        xs \\<noteq> []; ys \\<noteq> []; path (tree_edges s) x (xs @ [xa]) v;\n        path (tree_edges s) y (ys @ [ya]) v\\<rbrakk>\n       \\<Longrightarrow> (x, y) \\<in> (tree_edges s)\\<^sup>+ \\<or>\n                         (y, x) \\<in> (tree_edges s)\\<^sup>+", "moreover"], ["proof (state)\nthis:\n  (x, v) \\<in> tree_edges s\n\ngoal (2 subgoals):\n 1. \\<And>xa ya ys v.\n       \\<lbrakk>ys \\<noteq> []; path (tree_edges s) x [xa] v;\n        path (tree_edges s) y (ys @ [ya]) v\\<rbrakk>\n       \\<Longrightarrow> (x, y) \\<in> (tree_edges s)\\<^sup>+ \\<or>\n                         (y, x) \\<in> (tree_edges s)\\<^sup>+\n 2. \\<And>xa xs ya ys v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>path (tree_edges s) x xs v;\n                    path (tree_edges s) y ys v\\<rbrakk>\n                   \\<Longrightarrow> (x, y)\n                                     \\<in> (tree_edges s)\\<^sup>+ \\<or>\n                                     (y, x) \\<in> (tree_edges s)\\<^sup>+;\n        xs \\<noteq> []; ys \\<noteq> []; path (tree_edges s) x (xs @ [xa]) v;\n        path (tree_edges s) y (ys @ [ya]) v\\<rbrakk>\n       \\<Longrightarrow> (x, y) \\<in> (tree_edges s)\\<^sup>+ \\<or>\n                         (y, x) \\<in> (tree_edges s)\\<^sup>+", "from snocr"], ["proof (chain)\npicking this:\n  as \\<noteq> []\n  path (tree_edges s) x [x_] v\n  path (tree_edges s) y (as @ [a]) v", "have \"path (tree_edges s) y as a\" \"(a,v) \\<in> tree_edges s\""], ["proof (prove)\nusing this:\n  as \\<noteq> []\n  path (tree_edges s) x [x_] v\n  path (tree_edges s) y (as @ [a]) v\n\ngoal (1 subgoal):\n 1. path (tree_edges s) y as a &&& (a, v) \\<in> tree_edges s", "by (simp_all add: path_simps)"], ["proof (state)\nthis:\n  path (tree_edges s) y as a\n  (a, v) \\<in> tree_edges s\n\ngoal (2 subgoals):\n 1. \\<And>xa ya ys v.\n       \\<lbrakk>ys \\<noteq> []; path (tree_edges s) x [xa] v;\n        path (tree_edges s) y (ys @ [ya]) v\\<rbrakk>\n       \\<Longrightarrow> (x, y) \\<in> (tree_edges s)\\<^sup>+ \\<or>\n                         (y, x) \\<in> (tree_edges s)\\<^sup>+\n 2. \\<And>xa xs ya ys v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>path (tree_edges s) x xs v;\n                    path (tree_edges s) y ys v\\<rbrakk>\n                   \\<Longrightarrow> (x, y)\n                                     \\<in> (tree_edges s)\\<^sup>+ \\<or>\n                                     (y, x) \\<in> (tree_edges s)\\<^sup>+;\n        xs \\<noteq> []; ys \\<noteq> []; path (tree_edges s) x (xs @ [xa]) v;\n        path (tree_edges s) y (ys @ [ya]) v\\<rbrakk>\n       \\<Longrightarrow> (x, y) \\<in> (tree_edges s)\\<^sup>+ \\<or>\n                         (y, x) \\<in> (tree_edges s)\\<^sup>+", "ultimately"], ["proof (chain)\npicking this:\n  (x, v) \\<in> tree_edges s\n  path (tree_edges s) y as a\n  (a, v) \\<in> tree_edges s", "have \"path (tree_edges s) y as x\""], ["proof (prove)\nusing this:\n  (x, v) \\<in> tree_edges s\n  path (tree_edges s) y as a\n  (a, v) \\<in> tree_edges s\n\ngoal (1 subgoal):\n 1. path (tree_edges s) y as x", "using tree_eq_rule"], ["proof (prove)\nusing this:\n  (x, v) \\<in> tree_edges s\n  path (tree_edges s) y as a\n  (a, v) \\<in> tree_edges s\n  \\<lbrakk>(?v, ?w) \\<in> tree_edges s; (?u, ?w) \\<in> tree_edges s\\<rbrakk>\n  \\<Longrightarrow> ?v = ?u\n\ngoal (1 subgoal):\n 1. path (tree_edges s) y as x", "by auto"], ["proof (state)\nthis:\n  path (tree_edges s) y as x\n\ngoal (2 subgoals):\n 1. \\<And>xa ya ys v.\n       \\<lbrakk>ys \\<noteq> []; path (tree_edges s) x [xa] v;\n        path (tree_edges s) y (ys @ [ya]) v\\<rbrakk>\n       \\<Longrightarrow> (x, y) \\<in> (tree_edges s)\\<^sup>+ \\<or>\n                         (y, x) \\<in> (tree_edges s)\\<^sup>+\n 2. \\<And>xa xs ya ys v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>path (tree_edges s) x xs v;\n                    path (tree_edges s) y ys v\\<rbrakk>\n                   \\<Longrightarrow> (x, y)\n                                     \\<in> (tree_edges s)\\<^sup>+ \\<or>\n                                     (y, x) \\<in> (tree_edges s)\\<^sup>+;\n        xs \\<noteq> []; ys \\<noteq> []; path (tree_edges s) x (xs @ [xa]) v;\n        path (tree_edges s) y (ys @ [ya]) v\\<rbrakk>\n       \\<Longrightarrow> (x, y) \\<in> (tree_edges s)\\<^sup>+ \\<or>\n                         (y, x) \\<in> (tree_edges s)\\<^sup>+", "with path_is_trancl \\<open>as \\<noteq> []\\<close>"], ["proof (chain)\npicking this:\n  \\<lbrakk>path ?E ?u ?l ?v; ?l \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> (?u, ?v) \\<in> ?E\\<^sup>+\n  as \\<noteq> []\n  path (tree_edges s) y as x", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>path ?E ?u ?l ?v; ?l \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> (?u, ?v) \\<in> ?E\\<^sup>+\n  as \\<noteq> []\n  path (tree_edges s) y as x\n\ngoal (1 subgoal):\n 1. (x, y) \\<in> (tree_edges s)\\<^sup>+ \\<or>\n    (y, x) \\<in> (tree_edges s)\\<^sup>+", "by metis"], ["proof (state)\nthis:\n  (x, y) \\<in> (tree_edges s)\\<^sup>+ \\<or>\n  (y, x) \\<in> (tree_edges s)\\<^sup>+\n\ngoal (1 subgoal):\n 1. \\<And>xa xs ya ys v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>path (tree_edges s) x xs v;\n                    path (tree_edges s) y ys v\\<rbrakk>\n                   \\<Longrightarrow> (x, y)\n                                     \\<in> (tree_edges s)\\<^sup>+ \\<or>\n                                     (y, x) \\<in> (tree_edges s)\\<^sup>+;\n        xs \\<noteq> []; ys \\<noteq> []; path (tree_edges s) x (xs @ [xa]) v;\n        path (tree_edges s) y (ys @ [ya]) v\\<rbrakk>\n       \\<Longrightarrow> (x, y) \\<in> (tree_edges s)\\<^sup>+ \\<or>\n                         (y, x) \\<in> (tree_edges s)\\<^sup>+", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa xs ya ys v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>path (tree_edges s) x xs v;\n                    path (tree_edges s) y ys v\\<rbrakk>\n                   \\<Longrightarrow> (x, y)\n                                     \\<in> (tree_edges s)\\<^sup>+ \\<or>\n                                     (y, x) \\<in> (tree_edges s)\\<^sup>+;\n        xs \\<noteq> []; ys \\<noteq> []; path (tree_edges s) x (xs @ [xa]) v;\n        path (tree_edges s) y (ys @ [ya]) v\\<rbrakk>\n       \\<Longrightarrow> (x, y) \\<in> (tree_edges s)\\<^sup>+ \\<or>\n                         (y, x) \\<in> (tree_edges s)\\<^sup>+", "case (snoclr a as b bs)"], ["proof (state)\nthis:\n  \\<lbrakk>path (tree_edges s) x as ?v7;\n   path (tree_edges s) y bs ?v7\\<rbrakk>\n  \\<Longrightarrow> (x, y) \\<in> (tree_edges s)\\<^sup>+ \\<or>\n                    (y, x) \\<in> (tree_edges s)\\<^sup>+\n  as \\<noteq> []\n  bs \\<noteq> []\n  path (tree_edges s) x (as @ [a]) v\n  path (tree_edges s) y (bs @ [b]) v\n\ngoal (1 subgoal):\n 1. \\<And>xa xs ya ys v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>path (tree_edges s) x xs v;\n                    path (tree_edges s) y ys v\\<rbrakk>\n                   \\<Longrightarrow> (x, y)\n                                     \\<in> (tree_edges s)\\<^sup>+ \\<or>\n                                     (y, x) \\<in> (tree_edges s)\\<^sup>+;\n        xs \\<noteq> []; ys \\<noteq> []; path (tree_edges s) x (xs @ [xa]) v;\n        path (tree_edges s) y (ys @ [ya]) v\\<rbrakk>\n       \\<Longrightarrow> (x, y) \\<in> (tree_edges s)\\<^sup>+ \\<or>\n                         (y, x) \\<in> (tree_edges s)\\<^sup>+", "hence \n        \"path (tree_edges s) x as a\" \"(a,v) \\<in> tree_edges s\"\n        \"path (tree_edges s) y bs b\" \"(b,v) \\<in> tree_edges s\""], ["proof (prove)\nusing this:\n  \\<lbrakk>path (tree_edges s) x as ?v7;\n   path (tree_edges s) y bs ?v7\\<rbrakk>\n  \\<Longrightarrow> (x, y) \\<in> (tree_edges s)\\<^sup>+ \\<or>\n                    (y, x) \\<in> (tree_edges s)\\<^sup>+\n  as \\<noteq> []\n  bs \\<noteq> []\n  path (tree_edges s) x (as @ [a]) v\n  path (tree_edges s) y (bs @ [b]) v\n\ngoal (1 subgoal):\n 1. (path (tree_edges s) x as a &&& (a, v) \\<in> tree_edges s) &&&\n    path (tree_edges s) y bs b &&& (b, v) \\<in> tree_edges s", "by (simp_all add: path_simps)"], ["proof (state)\nthis:\n  path (tree_edges s) x as a\n  (a, v) \\<in> tree_edges s\n  path (tree_edges s) y bs b\n  (b, v) \\<in> tree_edges s\n\ngoal (1 subgoal):\n 1. \\<And>xa xs ya ys v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>path (tree_edges s) x xs v;\n                    path (tree_edges s) y ys v\\<rbrakk>\n                   \\<Longrightarrow> (x, y)\n                                     \\<in> (tree_edges s)\\<^sup>+ \\<or>\n                                     (y, x) \\<in> (tree_edges s)\\<^sup>+;\n        xs \\<noteq> []; ys \\<noteq> []; path (tree_edges s) x (xs @ [xa]) v;\n        path (tree_edges s) y (ys @ [ya]) v\\<rbrakk>\n       \\<Longrightarrow> (x, y) \\<in> (tree_edges s)\\<^sup>+ \\<or>\n                         (y, x) \\<in> (tree_edges s)\\<^sup>+", "moreover"], ["proof (state)\nthis:\n  path (tree_edges s) x as a\n  (a, v) \\<in> tree_edges s\n  path (tree_edges s) y bs b\n  (b, v) \\<in> tree_edges s\n\ngoal (1 subgoal):\n 1. \\<And>xa xs ya ys v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>path (tree_edges s) x xs v;\n                    path (tree_edges s) y ys v\\<rbrakk>\n                   \\<Longrightarrow> (x, y)\n                                     \\<in> (tree_edges s)\\<^sup>+ \\<or>\n                                     (y, x) \\<in> (tree_edges s)\\<^sup>+;\n        xs \\<noteq> []; ys \\<noteq> []; path (tree_edges s) x (xs @ [xa]) v;\n        path (tree_edges s) y (ys @ [ya]) v\\<rbrakk>\n       \\<Longrightarrow> (x, y) \\<in> (tree_edges s)\\<^sup>+ \\<or>\n                         (y, x) \\<in> (tree_edges s)\\<^sup>+", "hence \"a=b\""], ["proof (prove)\nusing this:\n  path (tree_edges s) x as a\n  (a, v) \\<in> tree_edges s\n  path (tree_edges s) y bs b\n  (b, v) \\<in> tree_edges s\n\ngoal (1 subgoal):\n 1. a = b", "using tree_eq_rule"], ["proof (prove)\nusing this:\n  path (tree_edges s) x as a\n  (a, v) \\<in> tree_edges s\n  path (tree_edges s) y bs b\n  (b, v) \\<in> tree_edges s\n  \\<lbrakk>(?v, ?w) \\<in> tree_edges s; (?u, ?w) \\<in> tree_edges s\\<rbrakk>\n  \\<Longrightarrow> ?v = ?u\n\ngoal (1 subgoal):\n 1. a = b", "by simp"], ["proof (state)\nthis:\n  a = b\n\ngoal (1 subgoal):\n 1. \\<And>xa xs ya ys v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>path (tree_edges s) x xs v;\n                    path (tree_edges s) y ys v\\<rbrakk>\n                   \\<Longrightarrow> (x, y)\n                                     \\<in> (tree_edges s)\\<^sup>+ \\<or>\n                                     (y, x) \\<in> (tree_edges s)\\<^sup>+;\n        xs \\<noteq> []; ys \\<noteq> []; path (tree_edges s) x (xs @ [xa]) v;\n        path (tree_edges s) y (ys @ [ya]) v\\<rbrakk>\n       \\<Longrightarrow> (x, y) \\<in> (tree_edges s)\\<^sup>+ \\<or>\n                         (y, x) \\<in> (tree_edges s)\\<^sup>+", "ultimately"], ["proof (chain)\npicking this:\n  path (tree_edges s) x as a\n  (a, v) \\<in> tree_edges s\n  path (tree_edges s) y bs b\n  (b, v) \\<in> tree_edges s\n  a = b", "show ?thesis"], ["proof (prove)\nusing this:\n  path (tree_edges s) x as a\n  (a, v) \\<in> tree_edges s\n  path (tree_edges s) y bs b\n  (b, v) \\<in> tree_edges s\n  a = b\n\ngoal (1 subgoal):\n 1. (x, y) \\<in> (tree_edges s)\\<^sup>+ \\<or>\n    (y, x) \\<in> (tree_edges s)\\<^sup>+", "using snoclr.IH"], ["proof (prove)\nusing this:\n  path (tree_edges s) x as a\n  (a, v) \\<in> tree_edges s\n  path (tree_edges s) y bs b\n  (b, v) \\<in> tree_edges s\n  a = b\n  \\<lbrakk>path (tree_edges s) x as ?v7;\n   path (tree_edges s) y bs ?v7\\<rbrakk>\n  \\<Longrightarrow> (x, y) \\<in> (tree_edges s)\\<^sup>+ \\<or>\n                    (y, x) \\<in> (tree_edges s)\\<^sup>+\n\ngoal (1 subgoal):\n 1. (x, y) \\<in> (tree_edges s)\\<^sup>+ \\<or>\n    (y, x) \\<in> (tree_edges s)\\<^sup>+", "by metis"], ["proof (state)\nthis:\n  (x, y) \\<in> (tree_edges s)\\<^sup>+ \\<or>\n  (y, x) \\<in> (tree_edges s)\\<^sup>+\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (x, y) \\<in> (tree_edges s)\\<^sup>+ \\<or>\n  (y, x) \\<in> (tree_edges s)\\<^sup>+\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma tree_subpath:\n    assumes \"(x,v) \\<in> (tree_edges s)\\<^sup>+\"\n    and \"(y,v) \\<in> (tree_edges s)\\<^sup>+\"\n    and \\<delta>: \"\\<delta> s x < \\<delta> s y\"\n    shows \"(x,y) \\<in> (tree_edges s)\\<^sup>+\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x, y) \\<in> (tree_edges s)\\<^sup>+", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (x, y) \\<in> (tree_edges s)\\<^sup>+", "from \\<delta>"], ["proof (chain)\npicking this:\n  \\<delta> s x < \\<delta> s y", "have \"x \\<noteq> y\""], ["proof (prove)\nusing this:\n  \\<delta> s x < \\<delta> s y\n\ngoal (1 subgoal):\n 1. x \\<noteq> y", "by auto"], ["proof (state)\nthis:\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. (x, y) \\<in> (tree_edges s)\\<^sup>+", "with assms tree_subpath'"], ["proof (chain)\npicking this:\n  (x, v) \\<in> (tree_edges s)\\<^sup>+\n  (y, v) \\<in> (tree_edges s)\\<^sup>+\n  \\<delta> s x < \\<delta> s y\n  \\<lbrakk>(?x, ?v) \\<in> (tree_edges s)\\<^sup>+;\n   (?y, ?v) \\<in> (tree_edges s)\\<^sup>+; ?x \\<noteq> ?y\\<rbrakk>\n  \\<Longrightarrow> (?x, ?y) \\<in> (tree_edges s)\\<^sup>+ \\<or>\n                    (?y, ?x) \\<in> (tree_edges s)\\<^sup>+\n  x \\<noteq> y", "have \"(x,y) \\<in> (tree_edges s)\\<^sup>+ \\<or> (y,x) \\<in> (tree_edges s)\\<^sup>+\""], ["proof (prove)\nusing this:\n  (x, v) \\<in> (tree_edges s)\\<^sup>+\n  (y, v) \\<in> (tree_edges s)\\<^sup>+\n  \\<delta> s x < \\<delta> s y\n  \\<lbrakk>(?x, ?v) \\<in> (tree_edges s)\\<^sup>+;\n   (?y, ?v) \\<in> (tree_edges s)\\<^sup>+; ?x \\<noteq> ?y\\<rbrakk>\n  \\<Longrightarrow> (?x, ?y) \\<in> (tree_edges s)\\<^sup>+ \\<or>\n                    (?y, ?x) \\<in> (tree_edges s)\\<^sup>+\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. (x, y) \\<in> (tree_edges s)\\<^sup>+ \\<or>\n    (y, x) \\<in> (tree_edges s)\\<^sup>+", "by simp"], ["proof (state)\nthis:\n  (x, y) \\<in> (tree_edges s)\\<^sup>+ \\<or>\n  (y, x) \\<in> (tree_edges s)\\<^sup>+\n\ngoal (1 subgoal):\n 1. (x, y) \\<in> (tree_edges s)\\<^sup>+", "moreover"], ["proof (state)\nthis:\n  (x, y) \\<in> (tree_edges s)\\<^sup>+ \\<or>\n  (y, x) \\<in> (tree_edges s)\\<^sup>+\n\ngoal (1 subgoal):\n 1. (x, y) \\<in> (tree_edges s)\\<^sup>+", "from \\<delta> tree_path_disc"], ["proof (chain)\npicking this:\n  \\<delta> s x < \\<delta> s y\n  (?v, ?w) \\<in> (tree_edges s)\\<^sup>+ \\<Longrightarrow>\n  \\<delta> s ?v < \\<delta> s ?w", "have \"(y,x) \\<notin> (tree_edges s)\\<^sup>+\""], ["proof (prove)\nusing this:\n  \\<delta> s x < \\<delta> s y\n  (?v, ?w) \\<in> (tree_edges s)\\<^sup>+ \\<Longrightarrow>\n  \\<delta> s ?v < \\<delta> s ?w\n\ngoal (1 subgoal):\n 1. (y, x) \\<notin> (tree_edges s)\\<^sup>+", "by force"], ["proof (state)\nthis:\n  (y, x) \\<notin> (tree_edges s)\\<^sup>+\n\ngoal (1 subgoal):\n 1. (x, y) \\<in> (tree_edges s)\\<^sup>+", "ultimately"], ["proof (chain)\npicking this:\n  (x, y) \\<in> (tree_edges s)\\<^sup>+ \\<or>\n  (y, x) \\<in> (tree_edges s)\\<^sup>+\n  (y, x) \\<notin> (tree_edges s)\\<^sup>+", "show ?thesis"], ["proof (prove)\nusing this:\n  (x, y) \\<in> (tree_edges s)\\<^sup>+ \\<or>\n  (y, x) \\<in> (tree_edges s)\\<^sup>+\n  (y, x) \\<notin> (tree_edges s)\\<^sup>+\n\ngoal (1 subgoal):\n 1. (x, y) \\<in> (tree_edges s)\\<^sup>+", "by simp"], ["proof (state)\nthis:\n  (x, y) \\<in> (tree_edges s)\\<^sup>+\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma on_stack_is_tree_path:\n    assumes x: \"x \\<in> set (stack s)\"\n    and y: \"y \\<in> set (stack s)\"\n    and \\<delta>: \"\\<delta> s x < \\<delta> s y\"\n    shows \"(x,y) \\<in> (tree_edges s)\\<^sup>+\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x, y) \\<in> (tree_edges s)\\<^sup>+", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (x, y) \\<in> (tree_edges s)\\<^sup>+", "from x"], ["proof (chain)\npicking this:\n  x \\<in> set (stack s)", "obtain i where i: \"stack s ! i = x\" \"i < length (stack s)\""], ["proof (prove)\nusing this:\n  x \\<in> set (stack s)\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>stack s ! i = x; i < length (stack s)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis in_set_conv_nth)"], ["proof (state)\nthis:\n  stack s ! i = x\n  i < length (stack s)\n\ngoal (1 subgoal):\n 1. (x, y) \\<in> (tree_edges s)\\<^sup>+", "from y"], ["proof (chain)\npicking this:\n  y \\<in> set (stack s)", "obtain j where j: \"stack s ! j = y\" \"j < length (stack s)\""], ["proof (prove)\nusing this:\n  y \\<in> set (stack s)\n\ngoal (1 subgoal):\n 1. (\\<And>j.\n        \\<lbrakk>stack s ! j = y; j < length (stack s)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis in_set_conv_nth)"], ["proof (state)\nthis:\n  stack s ! j = y\n  j < length (stack s)\n\ngoal (1 subgoal):\n 1. (x, y) \\<in> (tree_edges s)\\<^sup>+", "with i \\<delta> stack_nth_order"], ["proof (chain)\npicking this:\n  stack s ! i = x\n  i < length (stack s)\n  \\<delta> s x < \\<delta> s y\n  \\<lbrakk>?i < length (stack s); ?j < length (stack s)\\<rbrakk>\n  \\<Longrightarrow> (\\<delta> s (stack s ! ?i)\n                     < \\<delta> s (stack s ! ?j)) =\n                    (?j < ?i)\n  stack s ! j = y\n  j < length (stack s)", "have \"j < i\""], ["proof (prove)\nusing this:\n  stack s ! i = x\n  i < length (stack s)\n  \\<delta> s x < \\<delta> s y\n  \\<lbrakk>?i < length (stack s); ?j < length (stack s)\\<rbrakk>\n  \\<Longrightarrow> (\\<delta> s (stack s ! ?i)\n                     < \\<delta> s (stack s ! ?j)) =\n                    (?j < ?i)\n  stack s ! j = y\n  j < length (stack s)\n\ngoal (1 subgoal):\n 1. j < i", "by force"], ["proof (state)\nthis:\n  j < i\n\ngoal (1 subgoal):\n 1. (x, y) \\<in> (tree_edges s)\\<^sup>+", "from x"], ["proof (chain)\npicking this:\n  x \\<in> set (stack s)", "have ne[simp]: \"stack s \\<noteq> []\""], ["proof (prove)\nusing this:\n  x \\<in> set (stack s)\n\ngoal (1 subgoal):\n 1. stack s \\<noteq> []", "by auto"], ["proof (state)\nthis:\n  stack s \\<noteq> []\n\ngoal (1 subgoal):\n 1. (x, y) \\<in> (tree_edges s)\\<^sup>+", "from \\<open>j<i\\<close>"], ["proof (chain)\npicking this:\n  j < i", "have \"x \\<in> set (tl (stack s))\""], ["proof (prove)\nusing this:\n  j < i\n\ngoal (1 subgoal):\n 1. x \\<in> set (tl (stack s))", "using nth_mem nth_tl[OF ne, of \"i - 1\"] i"], ["proof (prove)\nusing this:\n  j < i\n  ?n < length ?xs \\<Longrightarrow> ?xs ! ?n \\<in> set ?xs\n  tl (stack s) ! (i - 1) = stack s ! Suc (i - 1)\n  stack s ! i = x\n  i < length (stack s)\n\ngoal (1 subgoal):\n 1. x \\<in> set (tl (stack s))", "by auto"], ["proof (state)\nthis:\n  x \\<in> set (tl (stack s))\n\ngoal (1 subgoal):\n 1. (x, y) \\<in> (tree_edges s)\\<^sup>+", "with tl_stack_hd_tree_path"], ["proof (chain)\npicking this:\n  \\<lbrakk>stack s \\<noteq> []; ?v \\<in> set (tl (stack s))\\<rbrakk>\n  \\<Longrightarrow> (?v, hd (stack s)) \\<in> (tree_edges s)\\<^sup>+\n  x \\<in> set (tl (stack s))", "have \n      x_path: \"(x, hd (stack s)) \\<in> (tree_edges s)\\<^sup>+\""], ["proof (prove)\nusing this:\n  \\<lbrakk>stack s \\<noteq> []; ?v \\<in> set (tl (stack s))\\<rbrakk>\n  \\<Longrightarrow> (?v, hd (stack s)) \\<in> (tree_edges s)\\<^sup>+\n  x \\<in> set (tl (stack s))\n\ngoal (1 subgoal):\n 1. (x, hd (stack s)) \\<in> (tree_edges s)\\<^sup>+", "by simp"], ["proof (state)\nthis:\n  (x, hd (stack s)) \\<in> (tree_edges s)\\<^sup>+\n\ngoal (1 subgoal):\n 1. (x, y) \\<in> (tree_edges s)\\<^sup>+", "then"], ["proof (chain)\npicking this:\n  (x, hd (stack s)) \\<in> (tree_edges s)\\<^sup>+", "show ?thesis"], ["proof (prove)\nusing this:\n  (x, hd (stack s)) \\<in> (tree_edges s)\\<^sup>+\n\ngoal (1 subgoal):\n 1. (x, y) \\<in> (tree_edges s)\\<^sup>+", "proof (cases \"j=0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>(x, hd (stack s)) \\<in> (tree_edges s)\\<^sup>+; j = 0\\<rbrakk>\n    \\<Longrightarrow> (x, y) \\<in> (tree_edges s)\\<^sup>+\n 2. \\<lbrakk>(x, hd (stack s)) \\<in> (tree_edges s)\\<^sup>+;\n     j \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> (x, y) \\<in> (tree_edges s)\\<^sup>+", "case True"], ["proof (state)\nthis:\n  j = 0\n\ngoal (2 subgoals):\n 1. \\<lbrakk>(x, hd (stack s)) \\<in> (tree_edges s)\\<^sup>+; j = 0\\<rbrakk>\n    \\<Longrightarrow> (x, y) \\<in> (tree_edges s)\\<^sup>+\n 2. \\<lbrakk>(x, hd (stack s)) \\<in> (tree_edges s)\\<^sup>+;\n     j \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> (x, y) \\<in> (tree_edges s)\\<^sup>+", "with j"], ["proof (chain)\npicking this:\n  stack s ! j = y\n  j < length (stack s)\n  j = 0", "have \"hd (stack s) = y\""], ["proof (prove)\nusing this:\n  stack s ! j = y\n  j < length (stack s)\n  j = 0\n\ngoal (1 subgoal):\n 1. hd (stack s) = y", "by (metis hd_conv_nth ne)"], ["proof (state)\nthis:\n  hd (stack s) = y\n\ngoal (2 subgoals):\n 1. \\<lbrakk>(x, hd (stack s)) \\<in> (tree_edges s)\\<^sup>+; j = 0\\<rbrakk>\n    \\<Longrightarrow> (x, y) \\<in> (tree_edges s)\\<^sup>+\n 2. \\<lbrakk>(x, hd (stack s)) \\<in> (tree_edges s)\\<^sup>+;\n     j \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> (x, y) \\<in> (tree_edges s)\\<^sup>+", "with x_path"], ["proof (chain)\npicking this:\n  (x, hd (stack s)) \\<in> (tree_edges s)\\<^sup>+\n  hd (stack s) = y", "show ?thesis"], ["proof (prove)\nusing this:\n  (x, hd (stack s)) \\<in> (tree_edges s)\\<^sup>+\n  hd (stack s) = y\n\ngoal (1 subgoal):\n 1. (x, y) \\<in> (tree_edges s)\\<^sup>+", "by simp"], ["proof (state)\nthis:\n  (x, y) \\<in> (tree_edges s)\\<^sup>+\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(x, hd (stack s)) \\<in> (tree_edges s)\\<^sup>+;\n     j \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> (x, y) \\<in> (tree_edges s)\\<^sup>+", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>(x, hd (stack s)) \\<in> (tree_edges s)\\<^sup>+;\n     j \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> (x, y) \\<in> (tree_edges s)\\<^sup>+", "case False"], ["proof (state)\nthis:\n  j \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(x, hd (stack s)) \\<in> (tree_edges s)\\<^sup>+;\n     j \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> (x, y) \\<in> (tree_edges s)\\<^sup>+", "hence \"y \\<in> set (tl (stack s))\""], ["proof (prove)\nusing this:\n  j \\<noteq> 0\n\ngoal (1 subgoal):\n 1. y \\<in> set (tl (stack s))", "using nth_mem nth_tl[OF ne, of \"j - 1\"] j"], ["proof (prove)\nusing this:\n  j \\<noteq> 0\n  ?n < length ?xs \\<Longrightarrow> ?xs ! ?n \\<in> set ?xs\n  tl (stack s) ! (j - 1) = stack s ! Suc (j - 1)\n  stack s ! j = y\n  j < length (stack s)\n\ngoal (1 subgoal):\n 1. y \\<in> set (tl (stack s))", "by auto"], ["proof (state)\nthis:\n  y \\<in> set (tl (stack s))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(x, hd (stack s)) \\<in> (tree_edges s)\\<^sup>+;\n     j \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> (x, y) \\<in> (tree_edges s)\\<^sup>+", "with tl_stack_hd_tree_path"], ["proof (chain)\npicking this:\n  \\<lbrakk>stack s \\<noteq> []; ?v \\<in> set (tl (stack s))\\<rbrakk>\n  \\<Longrightarrow> (?v, hd (stack s)) \\<in> (tree_edges s)\\<^sup>+\n  y \\<in> set (tl (stack s))", "have \"(y, hd (stack s)) \\<in> (tree_edges s)\\<^sup>+\""], ["proof (prove)\nusing this:\n  \\<lbrakk>stack s \\<noteq> []; ?v \\<in> set (tl (stack s))\\<rbrakk>\n  \\<Longrightarrow> (?v, hd (stack s)) \\<in> (tree_edges s)\\<^sup>+\n  y \\<in> set (tl (stack s))\n\ngoal (1 subgoal):\n 1. (y, hd (stack s)) \\<in> (tree_edges s)\\<^sup>+", "by simp"], ["proof (state)\nthis:\n  (y, hd (stack s)) \\<in> (tree_edges s)\\<^sup>+\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(x, hd (stack s)) \\<in> (tree_edges s)\\<^sup>+;\n     j \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> (x, y) \\<in> (tree_edges s)\\<^sup>+", "with x_path \\<delta>"], ["proof (chain)\npicking this:\n  (x, hd (stack s)) \\<in> (tree_edges s)\\<^sup>+\n  \\<delta> s x < \\<delta> s y\n  (y, hd (stack s)) \\<in> (tree_edges s)\\<^sup>+", "show ?thesis"], ["proof (prove)\nusing this:\n  (x, hd (stack s)) \\<in> (tree_edges s)\\<^sup>+\n  \\<delta> s x < \\<delta> s y\n  (y, hd (stack s)) \\<in> (tree_edges s)\\<^sup>+\n\ngoal (1 subgoal):\n 1. (x, y) \\<in> (tree_edges s)\\<^sup>+", "using tree_subpath"], ["proof (prove)\nusing this:\n  (x, hd (stack s)) \\<in> (tree_edges s)\\<^sup>+\n  \\<delta> s x < \\<delta> s y\n  (y, hd (stack s)) \\<in> (tree_edges s)\\<^sup>+\n  \\<lbrakk>(?x, ?v) \\<in> (tree_edges s)\\<^sup>+;\n   (?y, ?v) \\<in> (tree_edges s)\\<^sup>+;\n   \\<delta> s ?x < \\<delta> s ?y\\<rbrakk>\n  \\<Longrightarrow> (?x, ?y) \\<in> (tree_edges s)\\<^sup>+\n\ngoal (1 subgoal):\n 1. (x, y) \\<in> (tree_edges s)\\<^sup>+", "by metis"], ["proof (state)\nthis:\n  (x, y) \\<in> (tree_edges s)\\<^sup>+\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (x, y) \\<in> (tree_edges s)\\<^sup>+\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma hd_stack_tree_path_finished:\n    assumes \"stack s \\<noteq> []\"\n    assumes \"(hd (stack s), v) \\<in> (tree_edges s)\\<^sup>+\"\n    shows \"v \\<in> dom (finished s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> dom (finished s)", "proof (cases \"v \\<in> set (stack s)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. v \\<in> set (stack s) \\<Longrightarrow> v \\<in> dom (finished s)\n 2. v \\<notin> set (stack s) \\<Longrightarrow> v \\<in> dom (finished s)", "case True"], ["proof (state)\nthis:\n  v \\<in> set (stack s)\n\ngoal (2 subgoals):\n 1. v \\<in> set (stack s) \\<Longrightarrow> v \\<in> dom (finished s)\n 2. v \\<notin> set (stack s) \\<Longrightarrow> v \\<in> dom (finished s)", "from assms no_loop_in_tree"], ["proof (chain)\npicking this:\n  stack s \\<noteq> []\n  (hd (stack s), v) \\<in> (tree_edges s)\\<^sup>+\n  (?v, ?v) \\<notin> (tree_edges s)\\<^sup>+", "have \"hd (stack s) \\<noteq> v\""], ["proof (prove)\nusing this:\n  stack s \\<noteq> []\n  (hd (stack s), v) \\<in> (tree_edges s)\\<^sup>+\n  (?v, ?v) \\<notin> (tree_edges s)\\<^sup>+\n\ngoal (1 subgoal):\n 1. hd (stack s) \\<noteq> v", "by auto"], ["proof (state)\nthis:\n  hd (stack s) \\<noteq> v\n\ngoal (2 subgoals):\n 1. v \\<in> set (stack s) \\<Longrightarrow> v \\<in> dom (finished s)\n 2. v \\<notin> set (stack s) \\<Longrightarrow> v \\<in> dom (finished s)", "with True"], ["proof (chain)\npicking this:\n  v \\<in> set (stack s)\n  hd (stack s) \\<noteq> v", "have \"v \\<in> set (tl (stack s))\""], ["proof (prove)\nusing this:\n  v \\<in> set (stack s)\n  hd (stack s) \\<noteq> v\n\ngoal (1 subgoal):\n 1. v \\<in> set (tl (stack s))", "by (cases \"stack s\") auto"], ["proof (state)\nthis:\n  v \\<in> set (tl (stack s))\n\ngoal (2 subgoals):\n 1. v \\<in> set (stack s) \\<Longrightarrow> v \\<in> dom (finished s)\n 2. v \\<notin> set (stack s) \\<Longrightarrow> v \\<in> dom (finished s)", "with tl_stack_hd_tree_path assms"], ["proof (chain)\npicking this:\n  \\<lbrakk>stack s \\<noteq> []; ?v \\<in> set (tl (stack s))\\<rbrakk>\n  \\<Longrightarrow> (?v, hd (stack s)) \\<in> (tree_edges s)\\<^sup>+\n  stack s \\<noteq> []\n  (hd (stack s), v) \\<in> (tree_edges s)\\<^sup>+\n  v \\<in> set (tl (stack s))", "have \"(hd (stack s), hd (stack s)) \\<in> (tree_edges s)\\<^sup>+\""], ["proof (prove)\nusing this:\n  \\<lbrakk>stack s \\<noteq> []; ?v \\<in> set (tl (stack s))\\<rbrakk>\n  \\<Longrightarrow> (?v, hd (stack s)) \\<in> (tree_edges s)\\<^sup>+\n  stack s \\<noteq> []\n  (hd (stack s), v) \\<in> (tree_edges s)\\<^sup>+\n  v \\<in> set (tl (stack s))\n\ngoal (1 subgoal):\n 1. (hd (stack s), hd (stack s)) \\<in> (tree_edges s)\\<^sup>+", "by (metis trancl_trans)"], ["proof (state)\nthis:\n  (hd (stack s), hd (stack s)) \\<in> (tree_edges s)\\<^sup>+\n\ngoal (2 subgoals):\n 1. v \\<in> set (stack s) \\<Longrightarrow> v \\<in> dom (finished s)\n 2. v \\<notin> set (stack s) \\<Longrightarrow> v \\<in> dom (finished s)", "with no_loop_in_tree"], ["proof (chain)\npicking this:\n  (?v, ?v) \\<notin> (tree_edges s)\\<^sup>+\n  (hd (stack s), hd (stack s)) \\<in> (tree_edges s)\\<^sup>+", "show ?thesis"], ["proof (prove)\nusing this:\n  (?v, ?v) \\<notin> (tree_edges s)\\<^sup>+\n  (hd (stack s), hd (stack s)) \\<in> (tree_edges s)\\<^sup>+\n\ngoal (1 subgoal):\n 1. v \\<in> dom (finished s)", "by contradiction"], ["proof (state)\nthis:\n  v \\<in> dom (finished s)\n\ngoal (1 subgoal):\n 1. v \\<notin> set (stack s) \\<Longrightarrow> v \\<in> dom (finished s)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. v \\<notin> set (stack s) \\<Longrightarrow> v \\<in> dom (finished s)", "case False"], ["proof (state)\nthis:\n  v \\<notin> set (stack s)\n\ngoal (1 subgoal):\n 1. v \\<notin> set (stack s) \\<Longrightarrow> v \\<in> dom (finished s)", "from assms"], ["proof (chain)\npicking this:\n  stack s \\<noteq> []\n  (hd (stack s), v) \\<in> (tree_edges s)\\<^sup>+", "obtain x where \"(x,v) \\<in> tree_edges s\""], ["proof (prove)\nusing this:\n  stack s \\<noteq> []\n  (hd (stack s), v) \\<in> (tree_edges s)\\<^sup>+\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        (x, v) \\<in> tree_edges s \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis tranclE)"], ["proof (state)\nthis:\n  (x, v) \\<in> tree_edges s\n\ngoal (1 subgoal):\n 1. v \\<notin> set (stack s) \\<Longrightarrow> v \\<in> dom (finished s)", "with tree_edge_imp_discovered"], ["proof (chain)\npicking this:\n  (?v, ?w) \\<in> tree_edges s \\<Longrightarrow> ?v \\<in> dom (discovered s)\n  (?v, ?w) \\<in> tree_edges s \\<Longrightarrow> ?w \\<in> dom (discovered s)\n  (x, v) \\<in> tree_edges s", "have \"v \\<in> dom (discovered s)\""], ["proof (prove)\nusing this:\n  (?v, ?w) \\<in> tree_edges s \\<Longrightarrow> ?v \\<in> dom (discovered s)\n  (?v, ?w) \\<in> tree_edges s \\<Longrightarrow> ?w \\<in> dom (discovered s)\n  (x, v) \\<in> tree_edges s\n\ngoal (1 subgoal):\n 1. v \\<in> dom (discovered s)", "by blast"], ["proof (state)\nthis:\n  v \\<in> dom (discovered s)\n\ngoal (1 subgoal):\n 1. v \\<notin> set (stack s) \\<Longrightarrow> v \\<in> dom (finished s)", "with False"], ["proof (chain)\npicking this:\n  v \\<notin> set (stack s)\n  v \\<in> dom (discovered s)", "show ?thesis"], ["proof (prove)\nusing this:\n  v \\<notin> set (stack s)\n  v \\<in> dom (discovered s)\n\ngoal (1 subgoal):\n 1. v \\<in> dom (finished s)", "by (simp add: stack_set_def)"], ["proof (state)\nthis:\n  v \\<in> dom (finished s)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma tree_edge_impl_parenthesis:\n    assumes t: \"(v,w) \\<in> tree_edges s\"\n    and f: \"v \\<in> dom (finished s)\"\n    shows \"w \\<in> dom (finished s) \n      \\<and> \\<delta> s v < \\<delta> s w\n      \\<and> \\<phi> s w < \\<phi> s v \""], ["proof (prove)\ngoal (1 subgoal):\n 1. w \\<in> dom (finished s) \\<and>\n    \\<delta> s v < \\<delta> s w \\<and> \\<phi> s w < \\<phi> s v", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. w \\<in> dom (finished s) \\<and>\n    \\<delta> s v < \\<delta> s w \\<and> \\<phi> s w < \\<phi> s v", "from tree_edge_disc_lt_fin assms"], ["proof (chain)\npicking this:\n  \\<lbrakk>(?v, ?w) \\<in> tree_edges s; ?v \\<in> dom (finished s)\\<rbrakk>\n  \\<Longrightarrow> \\<delta> s ?w < \\<phi> s ?v\n  (v, w) \\<in> tree_edges s\n  v \\<in> dom (finished s)", "have \"\\<delta> s w < \\<phi> s v\""], ["proof (prove)\nusing this:\n  \\<lbrakk>(?v, ?w) \\<in> tree_edges s; ?v \\<in> dom (finished s)\\<rbrakk>\n  \\<Longrightarrow> \\<delta> s ?w < \\<phi> s ?v\n  (v, w) \\<in> tree_edges s\n  v \\<in> dom (finished s)\n\ngoal (1 subgoal):\n 1. \\<delta> s w < \\<phi> s v", "by simp"], ["proof (state)\nthis:\n  \\<delta> s w < \\<phi> s v\n\ngoal (1 subgoal):\n 1. w \\<in> dom (finished s) \\<and>\n    \\<delta> s v < \\<delta> s w \\<and> \\<phi> s w < \\<phi> s v", "with f tree_edge_imp_discovered[OF t] tree_edge_disc[OF t]"], ["proof (chain)\npicking this:\n  v \\<in> dom (finished s)\n  v \\<in> dom (discovered s)\n  w \\<in> dom (discovered s)\n  \\<delta> s v < \\<delta> s w\n  \\<delta> s w < \\<phi> s v", "show ?thesis"], ["proof (prove)\nusing this:\n  v \\<in> dom (finished s)\n  v \\<in> dom (discovered s)\n  w \\<in> dom (discovered s)\n  \\<delta> s v < \\<delta> s w\n  \\<delta> s w < \\<phi> s v\n\ngoal (1 subgoal):\n 1. w \\<in> dom (finished s) \\<and>\n    \\<delta> s v < \\<delta> s w \\<and> \\<phi> s w < \\<phi> s v", "using parenthesis_contained"], ["proof (prove)\nusing this:\n  v \\<in> dom (finished s)\n  v \\<in> dom (discovered s)\n  w \\<in> dom (discovered s)\n  \\<delta> s v < \\<delta> s w\n  \\<delta> s w < \\<phi> s v\n  \\<lbrakk>?v \\<in> dom (finished s); ?w \\<in> dom (discovered s);\n   \\<delta> s ?v < \\<delta> s ?w; \\<delta> s ?w < \\<phi> s ?v\\<rbrakk>\n  \\<Longrightarrow> ?w \\<in> dom (finished s) \\<and>\n                    \\<phi> s ?w < \\<phi> s ?v\n\ngoal (1 subgoal):\n 1. w \\<in> dom (finished s) \\<and>\n    \\<delta> s v < \\<delta> s w \\<and> \\<phi> s w < \\<phi> s v", "by metis"], ["proof (state)\nthis:\n  w \\<in> dom (finished s) \\<and>\n  \\<delta> s v < \\<delta> s w \\<and> \\<phi> s w < \\<phi> s v\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma tree_path_impl_parenthesis:\n    assumes \"(v,w) \\<in> (tree_edges s)\\<^sup>+\"\n    and \"v \\<in> dom (finished s)\"\n    shows \"w \\<in> dom (finished s) \n      \\<and> \\<delta> s v < \\<delta> s w\n      \\<and> \\<phi> s w < \\<phi> s v \""], ["proof (prove)\ngoal (1 subgoal):\n 1. w \\<in> dom (finished s) \\<and>\n    \\<delta> s v < \\<delta> s w \\<and> \\<phi> s w < \\<phi> s v", "using assms"], ["proof (prove)\nusing this:\n  (v, w) \\<in> (tree_edges s)\\<^sup>+\n  v \\<in> dom (finished s)\n\ngoal (1 subgoal):\n 1. w \\<in> dom (finished s) \\<and>\n    \\<delta> s v < \\<delta> s w \\<and> \\<phi> s w < \\<phi> s v", "by (auto elim!: trancl_induct dest: tree_edge_impl_parenthesis)"], ["", "lemma nc_reachable_v0_parenthesis:\n    assumes C: \"\\<not> cond s\" \"\\<not> is_break param s\"\n    and v: \"v \\<in> reachable\" \"v \\<notin> V0\"\n    obtains v0 where \"v0 \\<in> V0\"\n                 and \"\\<delta> s v0 < \\<delta> s v \\<and> \\<phi> s v < \\<phi> s v0 \""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>v0.\n        \\<lbrakk>v0 \\<in> V0;\n         \\<delta> s v0 < \\<delta> s v \\<and>\n         \\<phi> s v < \\<phi> s v0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>v0.\n        \\<lbrakk>v0 \\<in> V0;\n         \\<delta> s v0 < \\<delta> s v \\<and>\n         \\<phi> s v < \\<phi> s v0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from nc_discovered_eq_reachable[OF C] discovered_iff_tree_path v"], ["proof (chain)\npicking this:\n  dom (discovered s) = reachable\n  ?v \\<notin> V0 \\<Longrightarrow>\n  (?v \\<in> dom (discovered s)) =\n  (\\<exists>v0\\<in>V0. (v0, ?v) \\<in> (tree_edges s)\\<^sup>+)\n  v \\<in> reachable\n  v \\<notin> V0", "obtain v0 where \"v0 \\<in> V0\" and\n      \"(v0,v) \\<in> (tree_edges s)\\<^sup>+\""], ["proof (prove)\nusing this:\n  dom (discovered s) = reachable\n  ?v \\<notin> V0 \\<Longrightarrow>\n  (?v \\<in> dom (discovered s)) =\n  (\\<exists>v0\\<in>V0. (v0, ?v) \\<in> (tree_edges s)\\<^sup>+)\n  v \\<in> reachable\n  v \\<notin> V0\n\ngoal (1 subgoal):\n 1. (\\<And>v0.\n        \\<lbrakk>v0 \\<in> V0; (v0, v) \\<in> (tree_edges s)\\<^sup>+\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  v0 \\<in> V0\n  (v0, v) \\<in> (tree_edges s)\\<^sup>+\n\ngoal (1 subgoal):\n 1. (\\<And>v0.\n        \\<lbrakk>v0 \\<in> V0;\n         \\<delta> s v0 < \\<delta> s v \\<and>\n         \\<phi> s v < \\<phi> s v0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  v0 \\<in> V0\n  (v0, v) \\<in> (tree_edges s)\\<^sup>+\n\ngoal (1 subgoal):\n 1. (\\<And>v0.\n        \\<lbrakk>v0 \\<in> V0;\n         \\<delta> s v0 < \\<delta> s v \\<and>\n         \\<phi> s v < \\<phi> s v0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "with nc_V0_finished[OF C]"], ["proof (chain)\npicking this:\n  V0 \\<subseteq> dom (finished s)\n  v0 \\<in> V0\n  (v0, v) \\<in> (tree_edges s)\\<^sup>+", "have \"v0 \\<in> dom (finished s)\""], ["proof (prove)\nusing this:\n  V0 \\<subseteq> dom (finished s)\n  v0 \\<in> V0\n  (v0, v) \\<in> (tree_edges s)\\<^sup>+\n\ngoal (1 subgoal):\n 1. v0 \\<in> dom (finished s)", "by auto"], ["proof (state)\nthis:\n  v0 \\<in> dom (finished s)\n\ngoal (1 subgoal):\n 1. (\\<And>v0.\n        \\<lbrakk>v0 \\<in> V0;\n         \\<delta> s v0 < \\<delta> s v \\<and>\n         \\<phi> s v < \\<phi> s v0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "ultimately"], ["proof (chain)\npicking this:\n  v0 \\<in> V0\n  (v0, v) \\<in> (tree_edges s)\\<^sup>+\n  v0 \\<in> dom (finished s)", "show ?thesis"], ["proof (prove)\nusing this:\n  v0 \\<in> V0\n  (v0, v) \\<in> (tree_edges s)\\<^sup>+\n  v0 \\<in> dom (finished s)\n\ngoal (1 subgoal):\n 1. thesis", "using tree_path_impl_parenthesis that[OF \\<open>v0 \\<in> V0\\<close>]"], ["proof (prove)\nusing this:\n  v0 \\<in> V0\n  (v0, v) \\<in> (tree_edges s)\\<^sup>+\n  v0 \\<in> dom (finished s)\n  \\<lbrakk>(?v, ?w) \\<in> (tree_edges s)\\<^sup>+;\n   ?v \\<in> dom (finished s)\\<rbrakk>\n  \\<Longrightarrow> ?w \\<in> dom (finished s) \\<and>\n                    \\<delta> s ?v < \\<delta> s ?w \\<and>\n                    \\<phi> s ?w < \\<phi> s ?v\n  \\<delta> s v0 < \\<delta> s v \\<and>\n  \\<phi> s v < \\<phi> s v0 \\<Longrightarrow>\n  thesis\n\ngoal (1 subgoal):\n 1. thesis", "by simp"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"], ["", "context param_DFS begin"], ["", "context begin"], ["", "interpretation timing_syntax"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "definition paren_imp_tree_reach where\n    \"paren_imp_tree_reach s \\<equiv> \\<forall>v \\<in> dom (discovered s). \\<forall>w \\<in> dom (finished s). \n        \\<delta> s v < \\<delta> s w \\<and> (v \\<notin> dom (finished s) \\<or> \\<phi> s v > \\<phi> s w) \n               \\<longrightarrow> (v,w) \\<in> (tree_edges s)\\<^sup>+\""], ["", "lemma paren_imp_tree_reach:\n    \"is_invar paren_imp_tree_reach\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_invar paren_imp_tree_reach", "unfolding paren_imp_tree_reach_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_invar\n     (\\<lambda>s.\n         \\<forall>v\\<in>dom (discovered s).\n            \\<forall>w\\<in>dom (finished s).\n               \\<delta> s v < \\<delta> s w \\<and>\n               (v \\<notin> dom (finished s) \\<or>\n                \\<phi> s w < \\<phi> s v) \\<longrightarrow>\n               (v, w) \\<in> (tree_edges s)\\<^sup>+)", "proof (induct rule: is_invarI)"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>e.\n       \\<forall>v\\<in>dom (discovered (empty_state e)).\n          \\<forall>w\\<in>dom (finished (empty_state e)).\n             \\<delta> (empty_state e) v < \\<delta> (empty_state e) w \\<and>\n             (v \\<notin> dom (finished (empty_state e)) \\<or>\n              \\<phi> (empty_state e) w\n              < \\<phi> (empty_state e) v) \\<longrightarrow>\n             (v, w) \\<in> (tree_edges (empty_state e))\\<^sup>+\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>\\<forall>v\\<in>dom (discovered s).\n                   \\<forall>w\\<in>dom (finished s).\n                      \\<delta> s v < \\<delta> s w \\<and>\n                      (v \\<notin> dom (finished s) \\<or>\n                       \\<phi> s w < \\<phi> s v) \\<longrightarrow>\n                      (v, w) \\<in> (tree_edges s)\\<^sup>+;\n        cond s; DFS_invar G param s; DFS_invar G param s'; stack s = [];\n        v0 \\<notin> dom (discovered s); v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>v\\<in>dom (discovered s').\n                            \\<forall>w\\<in>dom (finished s').\n                               \\<delta> s' v < \\<delta> s' w \\<and>\n                               (v \\<notin> dom (finished s') \\<or>\n                                \\<phi> s' w < \\<phi> s' v) \\<longrightarrow>\n                               (v, w) \\<in> (tree_edges s')\\<^sup>+\n 3. \\<And>s s' u e.\n       \\<lbrakk>\\<forall>v\\<in>dom (discovered s).\n                   \\<forall>w\\<in>dom (finished s).\n                      \\<delta> s v < \\<delta> s w \\<and>\n                      (v \\<notin> dom (finished s) \\<or>\n                       \\<phi> s w < \\<phi> s v) \\<longrightarrow>\n                      (v, w) \\<in> (tree_edges s)\\<^sup>+;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; pending s `` {u} = {}; u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>v\\<in>dom (discovered s').\n                            \\<forall>w\\<in>dom (finished s').\n                               \\<delta> s' v < \\<delta> s' w \\<and>\n                               (v \\<notin> dom (finished s') \\<or>\n                                \\<phi> s' w < \\<phi> s' v) \\<longrightarrow>\n                               (v, w) \\<in> (tree_edges s')\\<^sup>+\n 4. \\<And>s s' u v e c b.\n       \\<lbrakk>\\<forall>v\\<in>dom (discovered s).\n                   \\<forall>w\\<in>dom (finished s).\n                      \\<delta> s v < \\<delta> s w \\<and>\n                      (v \\<notin> dom (finished s) \\<or>\n                       \\<phi> s w < \\<phi> s v) \\<longrightarrow>\n                      (v, w) \\<in> (tree_edges s)\\<^sup>+;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); u = hd (stack s);\n        cross_edges s \\<subseteq> c; back_edges s \\<subseteq> b;\n        s' = s\n        \\<lparr>pending := pending s - {(u, v)}, state.more := e,\n           cross_edges := c, back_edges := b\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>v\\<in>dom (discovered s').\n                            \\<forall>w\\<in>dom (finished s').\n                               \\<delta> s' v < \\<delta> s' w \\<and>\n                               (v \\<notin> dom (finished s') \\<or>\n                                \\<phi> s' w < \\<phi> s' v) \\<longrightarrow>\n                               (v, w) \\<in> (tree_edges s')\\<^sup>+\n 5. \\<And>s s' u v e.\n       \\<lbrakk>\\<forall>v\\<in>dom (discovered s).\n                   \\<forall>w\\<in>dom (finished s).\n                      \\<delta> s v < \\<delta> s w \\<and>\n                      (v \\<notin> dom (finished s) \\<or>\n                       \\<phi> s w < \\<phi> s v) \\<longrightarrow>\n                      (v, w) \\<in> (tree_edges s)\\<^sup>+;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>v\\<in>dom (discovered s').\n                            \\<forall>w\\<in>dom (finished s').\n                               \\<delta> s' v < \\<delta> s' w \\<and>\n                               (v \\<notin> dom (finished s') \\<or>\n                                \\<phi> s' w < \\<phi> s' v) \\<longrightarrow>\n                               (v, w) \\<in> (tree_edges s')\\<^sup>+", "case (discover s s' u v)"], ["proof (state)\nthis:\n  \\<forall>v\\<in>dom (discovered s).\n     \\<forall>w\\<in>dom (finished s).\n        \\<delta> s v < \\<delta> s w \\<and>\n        (v \\<notin> dom (finished s) \\<or>\n         \\<phi> s w < \\<phi> s v) \\<longrightarrow>\n        (v, w) \\<in> (tree_edges s)\\<^sup>+\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s \\<noteq> []\n  v \\<in> pending s `` {u}\n  v \\<notin> dom (discovered s)\n  u = hd (stack s)\n  s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n  \\<lparr>state.more := e_\\<rparr>\n\ngoal (5 subgoals):\n 1. \\<And>e.\n       \\<forall>v\\<in>dom (discovered (empty_state e)).\n          \\<forall>w\\<in>dom (finished (empty_state e)).\n             \\<delta> (empty_state e) v < \\<delta> (empty_state e) w \\<and>\n             (v \\<notin> dom (finished (empty_state e)) \\<or>\n              \\<phi> (empty_state e) w\n              < \\<phi> (empty_state e) v) \\<longrightarrow>\n             (v, w) \\<in> (tree_edges (empty_state e))\\<^sup>+\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>\\<forall>v\\<in>dom (discovered s).\n                   \\<forall>w\\<in>dom (finished s).\n                      \\<delta> s v < \\<delta> s w \\<and>\n                      (v \\<notin> dom (finished s) \\<or>\n                       \\<phi> s w < \\<phi> s v) \\<longrightarrow>\n                      (v, w) \\<in> (tree_edges s)\\<^sup>+;\n        cond s; DFS_invar G param s; DFS_invar G param s'; stack s = [];\n        v0 \\<notin> dom (discovered s); v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>v\\<in>dom (discovered s').\n                            \\<forall>w\\<in>dom (finished s').\n                               \\<delta> s' v < \\<delta> s' w \\<and>\n                               (v \\<notin> dom (finished s') \\<or>\n                                \\<phi> s' w < \\<phi> s' v) \\<longrightarrow>\n                               (v, w) \\<in> (tree_edges s')\\<^sup>+\n 3. \\<And>s s' u e.\n       \\<lbrakk>\\<forall>v\\<in>dom (discovered s).\n                   \\<forall>w\\<in>dom (finished s).\n                      \\<delta> s v < \\<delta> s w \\<and>\n                      (v \\<notin> dom (finished s) \\<or>\n                       \\<phi> s w < \\<phi> s v) \\<longrightarrow>\n                      (v, w) \\<in> (tree_edges s)\\<^sup>+;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; pending s `` {u} = {}; u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>v\\<in>dom (discovered s').\n                            \\<forall>w\\<in>dom (finished s').\n                               \\<delta> s' v < \\<delta> s' w \\<and>\n                               (v \\<notin> dom (finished s') \\<or>\n                                \\<phi> s' w < \\<phi> s' v) \\<longrightarrow>\n                               (v, w) \\<in> (tree_edges s')\\<^sup>+\n 4. \\<And>s s' u v e c b.\n       \\<lbrakk>\\<forall>v\\<in>dom (discovered s).\n                   \\<forall>w\\<in>dom (finished s).\n                      \\<delta> s v < \\<delta> s w \\<and>\n                      (v \\<notin> dom (finished s) \\<or>\n                       \\<phi> s w < \\<phi> s v) \\<longrightarrow>\n                      (v, w) \\<in> (tree_edges s)\\<^sup>+;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); u = hd (stack s);\n        cross_edges s \\<subseteq> c; back_edges s \\<subseteq> b;\n        s' = s\n        \\<lparr>pending := pending s - {(u, v)}, state.more := e,\n           cross_edges := c, back_edges := b\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>v\\<in>dom (discovered s').\n                            \\<forall>w\\<in>dom (finished s').\n                               \\<delta> s' v < \\<delta> s' w \\<and>\n                               (v \\<notin> dom (finished s') \\<or>\n                                \\<phi> s' w < \\<phi> s' v) \\<longrightarrow>\n                               (v, w) \\<in> (tree_edges s')\\<^sup>+\n 5. \\<And>s s' u v e.\n       \\<lbrakk>\\<forall>v\\<in>dom (discovered s).\n                   \\<forall>w\\<in>dom (finished s).\n                      \\<delta> s v < \\<delta> s w \\<and>\n                      (v \\<notin> dom (finished s) \\<or>\n                       \\<phi> s w < \\<phi> s v) \\<longrightarrow>\n                      (v, w) \\<in> (tree_edges s)\\<^sup>+;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>v\\<in>dom (discovered s').\n                            \\<forall>w\\<in>dom (finished s').\n                               \\<delta> s' v < \\<delta> s' w \\<and>\n                               (v \\<notin> dom (finished s') \\<or>\n                                \\<phi> s' w < \\<phi> s' v) \\<longrightarrow>\n                               (v, w) \\<in> (tree_edges s')\\<^sup>+", "hence EQ[simp]: \"tree_edges s' = insert (hd (stack s), v) (tree_edges s)\"\n                    \"finished s' = finished s\"\n                    \"discovered s' = (discovered s)(v \\<mapsto> counter s)\""], ["proof (prove)\nusing this:\n  \\<forall>v\\<in>dom (discovered s).\n     \\<forall>w\\<in>dom (finished s).\n        \\<delta> s v < \\<delta> s w \\<and>\n        (v \\<notin> dom (finished s) \\<or>\n         \\<phi> s w < \\<phi> s v) \\<longrightarrow>\n        (v, w) \\<in> (tree_edges s)\\<^sup>+\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s \\<noteq> []\n  v \\<in> pending s `` {u}\n  v \\<notin> dom (discovered s)\n  u = hd (stack s)\n  s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n  \\<lparr>state.more := e_\\<rparr>\n\ngoal (1 subgoal):\n 1. tree_edges s' = insert (hd (stack s), v) (tree_edges s) &&&\n    finished s' = finished s &&&\n    discovered s' = discovered s(v \\<mapsto> counter s)", "by simp_all"], ["proof (state)\nthis:\n  tree_edges s' = insert (hd (stack s), v) (tree_edges s)\n  finished s' = finished s\n  discovered s' = discovered s(v \\<mapsto> counter s)\n\ngoal (5 subgoals):\n 1. \\<And>e.\n       \\<forall>v\\<in>dom (discovered (empty_state e)).\n          \\<forall>w\\<in>dom (finished (empty_state e)).\n             \\<delta> (empty_state e) v < \\<delta> (empty_state e) w \\<and>\n             (v \\<notin> dom (finished (empty_state e)) \\<or>\n              \\<phi> (empty_state e) w\n              < \\<phi> (empty_state e) v) \\<longrightarrow>\n             (v, w) \\<in> (tree_edges (empty_state e))\\<^sup>+\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>\\<forall>v\\<in>dom (discovered s).\n                   \\<forall>w\\<in>dom (finished s).\n                      \\<delta> s v < \\<delta> s w \\<and>\n                      (v \\<notin> dom (finished s) \\<or>\n                       \\<phi> s w < \\<phi> s v) \\<longrightarrow>\n                      (v, w) \\<in> (tree_edges s)\\<^sup>+;\n        cond s; DFS_invar G param s; DFS_invar G param s'; stack s = [];\n        v0 \\<notin> dom (discovered s); v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>v\\<in>dom (discovered s').\n                            \\<forall>w\\<in>dom (finished s').\n                               \\<delta> s' v < \\<delta> s' w \\<and>\n                               (v \\<notin> dom (finished s') \\<or>\n                                \\<phi> s' w < \\<phi> s' v) \\<longrightarrow>\n                               (v, w) \\<in> (tree_edges s')\\<^sup>+\n 3. \\<And>s s' u e.\n       \\<lbrakk>\\<forall>v\\<in>dom (discovered s).\n                   \\<forall>w\\<in>dom (finished s).\n                      \\<delta> s v < \\<delta> s w \\<and>\n                      (v \\<notin> dom (finished s) \\<or>\n                       \\<phi> s w < \\<phi> s v) \\<longrightarrow>\n                      (v, w) \\<in> (tree_edges s)\\<^sup>+;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; pending s `` {u} = {}; u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>v\\<in>dom (discovered s').\n                            \\<forall>w\\<in>dom (finished s').\n                               \\<delta> s' v < \\<delta> s' w \\<and>\n                               (v \\<notin> dom (finished s') \\<or>\n                                \\<phi> s' w < \\<phi> s' v) \\<longrightarrow>\n                               (v, w) \\<in> (tree_edges s')\\<^sup>+\n 4. \\<And>s s' u v e c b.\n       \\<lbrakk>\\<forall>v\\<in>dom (discovered s).\n                   \\<forall>w\\<in>dom (finished s).\n                      \\<delta> s v < \\<delta> s w \\<and>\n                      (v \\<notin> dom (finished s) \\<or>\n                       \\<phi> s w < \\<phi> s v) \\<longrightarrow>\n                      (v, w) \\<in> (tree_edges s)\\<^sup>+;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); u = hd (stack s);\n        cross_edges s \\<subseteq> c; back_edges s \\<subseteq> b;\n        s' = s\n        \\<lparr>pending := pending s - {(u, v)}, state.more := e,\n           cross_edges := c, back_edges := b\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>v\\<in>dom (discovered s').\n                            \\<forall>w\\<in>dom (finished s').\n                               \\<delta> s' v < \\<delta> s' w \\<and>\n                               (v \\<notin> dom (finished s') \\<or>\n                                \\<phi> s' w < \\<phi> s' v) \\<longrightarrow>\n                               (v, w) \\<in> (tree_edges s')\\<^sup>+\n 5. \\<And>s s' u v e.\n       \\<lbrakk>\\<forall>v\\<in>dom (discovered s).\n                   \\<forall>w\\<in>dom (finished s).\n                      \\<delta> s v < \\<delta> s w \\<and>\n                      (v \\<notin> dom (finished s) \\<or>\n                       \\<phi> s w < \\<phi> s v) \\<longrightarrow>\n                      (v, w) \\<in> (tree_edges s)\\<^sup>+;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>v\\<in>dom (discovered s').\n                            \\<forall>w\\<in>dom (finished s').\n                               \\<delta> s' v < \\<delta> s' w \\<and>\n                               (v \\<notin> dom (finished s') \\<or>\n                                \\<phi> s' w < \\<phi> s' v) \\<longrightarrow>\n                               (v, w) \\<in> (tree_edges s')\\<^sup>+", "from discover"], ["proof (chain)\npicking this:\n  \\<forall>v\\<in>dom (discovered s).\n     \\<forall>w\\<in>dom (finished s).\n        \\<delta> s v < \\<delta> s w \\<and>\n        (v \\<notin> dom (finished s) \\<or>\n         \\<phi> s w < \\<phi> s v) \\<longrightarrow>\n        (v, w) \\<in> (tree_edges s)\\<^sup>+\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s \\<noteq> []\n  v \\<in> pending s `` {u}\n  v \\<notin> dom (discovered s)\n  u = hd (stack s)\n  s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n  \\<lparr>state.more := e_\\<rparr>", "interpret DFS_invar where s=s"], ["proof (prove)\nusing this:\n  \\<forall>v\\<in>dom (discovered s).\n     \\<forall>w\\<in>dom (finished s).\n        \\<delta> s v < \\<delta> s w \\<and>\n        (v \\<notin> dom (finished s) \\<or>\n         \\<phi> s w < \\<phi> s v) \\<longrightarrow>\n        (v, w) \\<in> (tree_edges s)\\<^sup>+\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s \\<noteq> []\n  v \\<in> pending s `` {u}\n  v \\<notin> dom (discovered s)\n  u = hd (stack s)\n  s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n  \\<lparr>state.more := e_\\<rparr>\n\ngoal (1 subgoal):\n 1. DFS_invar G param s", "by simp"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>e.\n       \\<forall>v\\<in>dom (discovered (empty_state e)).\n          \\<forall>w\\<in>dom (finished (empty_state e)).\n             \\<delta> (empty_state e) v < \\<delta> (empty_state e) w \\<and>\n             (v \\<notin> dom (finished (empty_state e)) \\<or>\n              \\<phi> (empty_state e) w\n              < \\<phi> (empty_state e) v) \\<longrightarrow>\n             (v, w) \\<in> (tree_edges (empty_state e))\\<^sup>+\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>\\<forall>v\\<in>dom (discovered s).\n                   \\<forall>w\\<in>dom (finished s).\n                      \\<delta> s v < \\<delta> s w \\<and>\n                      (v \\<notin> dom (finished s) \\<or>\n                       \\<phi> s w < \\<phi> s v) \\<longrightarrow>\n                      (v, w) \\<in> (tree_edges s)\\<^sup>+;\n        cond s; DFS_invar G param s; DFS_invar G param s'; stack s = [];\n        v0 \\<notin> dom (discovered s); v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>v\\<in>dom (discovered s').\n                            \\<forall>w\\<in>dom (finished s').\n                               \\<delta> s' v < \\<delta> s' w \\<and>\n                               (v \\<notin> dom (finished s') \\<or>\n                                \\<phi> s' w < \\<phi> s' v) \\<longrightarrow>\n                               (v, w) \\<in> (tree_edges s')\\<^sup>+\n 3. \\<And>s s' u e.\n       \\<lbrakk>\\<forall>v\\<in>dom (discovered s).\n                   \\<forall>w\\<in>dom (finished s).\n                      \\<delta> s v < \\<delta> s w \\<and>\n                      (v \\<notin> dom (finished s) \\<or>\n                       \\<phi> s w < \\<phi> s v) \\<longrightarrow>\n                      (v, w) \\<in> (tree_edges s)\\<^sup>+;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; pending s `` {u} = {}; u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>v\\<in>dom (discovered s').\n                            \\<forall>w\\<in>dom (finished s').\n                               \\<delta> s' v < \\<delta> s' w \\<and>\n                               (v \\<notin> dom (finished s') \\<or>\n                                \\<phi> s' w < \\<phi> s' v) \\<longrightarrow>\n                               (v, w) \\<in> (tree_edges s')\\<^sup>+\n 4. \\<And>s s' u v e c b.\n       \\<lbrakk>\\<forall>v\\<in>dom (discovered s).\n                   \\<forall>w\\<in>dom (finished s).\n                      \\<delta> s v < \\<delta> s w \\<and>\n                      (v \\<notin> dom (finished s) \\<or>\n                       \\<phi> s w < \\<phi> s v) \\<longrightarrow>\n                      (v, w) \\<in> (tree_edges s)\\<^sup>+;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); u = hd (stack s);\n        cross_edges s \\<subseteq> c; back_edges s \\<subseteq> b;\n        s' = s\n        \\<lparr>pending := pending s - {(u, v)}, state.more := e,\n           cross_edges := c, back_edges := b\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>v\\<in>dom (discovered s').\n                            \\<forall>w\\<in>dom (finished s').\n                               \\<delta> s' v < \\<delta> s' w \\<and>\n                               (v \\<notin> dom (finished s') \\<or>\n                                \\<phi> s' w < \\<phi> s' v) \\<longrightarrow>\n                               (v, w) \\<in> (tree_edges s')\\<^sup>+\n 5. \\<And>s s' u v e.\n       \\<lbrakk>\\<forall>v\\<in>dom (discovered s).\n                   \\<forall>w\\<in>dom (finished s).\n                      \\<delta> s v < \\<delta> s w \\<and>\n                      (v \\<notin> dom (finished s) \\<or>\n                       \\<phi> s w < \\<phi> s v) \\<longrightarrow>\n                      (v, w) \\<in> (tree_edges s)\\<^sup>+;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>v\\<in>dom (discovered s').\n                            \\<forall>w\\<in>dom (finished s').\n                               \\<delta> s' v < \\<delta> s' w \\<and>\n                               (v \\<notin> dom (finished s') \\<or>\n                                \\<phi> s' w < \\<phi> s' v) \\<longrightarrow>\n                               (v, w) \\<in> (tree_edges s')\\<^sup>+", "from discover"], ["proof (chain)\npicking this:\n  \\<forall>v\\<in>dom (discovered s).\n     \\<forall>w\\<in>dom (finished s).\n        \\<delta> s v < \\<delta> s w \\<and>\n        (v \\<notin> dom (finished s) \\<or>\n         \\<phi> s w < \\<phi> s v) \\<longrightarrow>\n        (v, w) \\<in> (tree_edges s)\\<^sup>+\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s \\<noteq> []\n  v \\<in> pending s `` {u}\n  v \\<notin> dom (discovered s)\n  u = hd (stack s)\n  s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n  \\<lparr>state.more := e_\\<rparr>", "have NE[simp]: \"stack s \\<noteq> []\""], ["proof (prove)\nusing this:\n  \\<forall>v\\<in>dom (discovered s).\n     \\<forall>w\\<in>dom (finished s).\n        \\<delta> s v < \\<delta> s w \\<and>\n        (v \\<notin> dom (finished s) \\<or>\n         \\<phi> s w < \\<phi> s v) \\<longrightarrow>\n        (v, w) \\<in> (tree_edges s)\\<^sup>+\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s \\<noteq> []\n  v \\<in> pending s `` {u}\n  v \\<notin> dom (discovered s)\n  u = hd (stack s)\n  s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n  \\<lparr>state.more := e_\\<rparr>\n\ngoal (1 subgoal):\n 1. stack s \\<noteq> []", "by (simp add: cond_alt)"], ["proof (state)\nthis:\n  stack s \\<noteq> []\n\ngoal (5 subgoals):\n 1. \\<And>e.\n       \\<forall>v\\<in>dom (discovered (empty_state e)).\n          \\<forall>w\\<in>dom (finished (empty_state e)).\n             \\<delta> (empty_state e) v < \\<delta> (empty_state e) w \\<and>\n             (v \\<notin> dom (finished (empty_state e)) \\<or>\n              \\<phi> (empty_state e) w\n              < \\<phi> (empty_state e) v) \\<longrightarrow>\n             (v, w) \\<in> (tree_edges (empty_state e))\\<^sup>+\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>\\<forall>v\\<in>dom (discovered s).\n                   \\<forall>w\\<in>dom (finished s).\n                      \\<delta> s v < \\<delta> s w \\<and>\n                      (v \\<notin> dom (finished s) \\<or>\n                       \\<phi> s w < \\<phi> s v) \\<longrightarrow>\n                      (v, w) \\<in> (tree_edges s)\\<^sup>+;\n        cond s; DFS_invar G param s; DFS_invar G param s'; stack s = [];\n        v0 \\<notin> dom (discovered s); v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>v\\<in>dom (discovered s').\n                            \\<forall>w\\<in>dom (finished s').\n                               \\<delta> s' v < \\<delta> s' w \\<and>\n                               (v \\<notin> dom (finished s') \\<or>\n                                \\<phi> s' w < \\<phi> s' v) \\<longrightarrow>\n                               (v, w) \\<in> (tree_edges s')\\<^sup>+\n 3. \\<And>s s' u e.\n       \\<lbrakk>\\<forall>v\\<in>dom (discovered s).\n                   \\<forall>w\\<in>dom (finished s).\n                      \\<delta> s v < \\<delta> s w \\<and>\n                      (v \\<notin> dom (finished s) \\<or>\n                       \\<phi> s w < \\<phi> s v) \\<longrightarrow>\n                      (v, w) \\<in> (tree_edges s)\\<^sup>+;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; pending s `` {u} = {}; u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>v\\<in>dom (discovered s').\n                            \\<forall>w\\<in>dom (finished s').\n                               \\<delta> s' v < \\<delta> s' w \\<and>\n                               (v \\<notin> dom (finished s') \\<or>\n                                \\<phi> s' w < \\<phi> s' v) \\<longrightarrow>\n                               (v, w) \\<in> (tree_edges s')\\<^sup>+\n 4. \\<And>s s' u v e c b.\n       \\<lbrakk>\\<forall>v\\<in>dom (discovered s).\n                   \\<forall>w\\<in>dom (finished s).\n                      \\<delta> s v < \\<delta> s w \\<and>\n                      (v \\<notin> dom (finished s) \\<or>\n                       \\<phi> s w < \\<phi> s v) \\<longrightarrow>\n                      (v, w) \\<in> (tree_edges s)\\<^sup>+;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); u = hd (stack s);\n        cross_edges s \\<subseteq> c; back_edges s \\<subseteq> b;\n        s' = s\n        \\<lparr>pending := pending s - {(u, v)}, state.more := e,\n           cross_edges := c, back_edges := b\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>v\\<in>dom (discovered s').\n                            \\<forall>w\\<in>dom (finished s').\n                               \\<delta> s' v < \\<delta> s' w \\<and>\n                               (v \\<notin> dom (finished s') \\<or>\n                                \\<phi> s' w < \\<phi> s' v) \\<longrightarrow>\n                               (v, w) \\<in> (tree_edges s')\\<^sup>+\n 5. \\<And>s s' u v e.\n       \\<lbrakk>\\<forall>v\\<in>dom (discovered s).\n                   \\<forall>w\\<in>dom (finished s).\n                      \\<delta> s v < \\<delta> s w \\<and>\n                      (v \\<notin> dom (finished s) \\<or>\n                       \\<phi> s w < \\<phi> s v) \\<longrightarrow>\n                      (v, w) \\<in> (tree_edges s)\\<^sup>+;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>v\\<in>dom (discovered s').\n                            \\<forall>w\\<in>dom (finished s').\n                               \\<delta> s' v < \\<delta> s' w \\<and>\n                               (v \\<notin> dom (finished s') \\<or>\n                                \\<phi> s' w < \\<phi> s' v) \\<longrightarrow>\n                               (v, w) \\<in> (tree_edges s')\\<^sup>+", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>dom (discovered s').\n       \\<forall>w\\<in>dom (finished s').\n          \\<delta> s' v < \\<delta> s' w \\<and>\n          (v \\<notin> dom (finished s') \\<or>\n           \\<phi> s' w < \\<phi> s' v) \\<longrightarrow>\n          (v, w) \\<in> (tree_edges s')\\<^sup>+", "proof (intro ballI impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v w.\n       \\<lbrakk>v \\<in> dom (discovered s'); w \\<in> dom (finished s');\n        \\<delta> s' v < \\<delta> s' w \\<and>\n        (v \\<notin> dom (finished s') \\<or>\n         \\<phi> s' w < \\<phi> s' v)\\<rbrakk>\n       \\<Longrightarrow> (v, w) \\<in> (tree_edges s')\\<^sup>+", "fix a b"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v w.\n       \\<lbrakk>v \\<in> dom (discovered s'); w \\<in> dom (finished s');\n        \\<delta> s' v < \\<delta> s' w \\<and>\n        (v \\<notin> dom (finished s') \\<or>\n         \\<phi> s' w < \\<phi> s' v)\\<rbrakk>\n       \\<Longrightarrow> (v, w) \\<in> (tree_edges s')\\<^sup>+", "assume F:\"a \\<in> dom (discovered s')\" \"b \\<in> dom (finished s')\"\n        and D: \"\\<delta> s' a < \\<delta> s' b \\<and> (a \\<notin> dom (finished s') \\<or> \\<phi> s' a > \\<phi> s' b)\""], ["proof (state)\nthis:\n  a \\<in> dom (discovered s')\n  b \\<in> dom (finished s')\n  \\<delta> s' a < \\<delta> s' b \\<and>\n  (a \\<notin> dom (finished s') \\<or> \\<phi> s' b < \\<phi> s' a)\n\ngoal (1 subgoal):\n 1. \\<And>v w.\n       \\<lbrakk>v \\<in> dom (discovered s'); w \\<in> dom (finished s');\n        \\<delta> s' v < \\<delta> s' w \\<and>\n        (v \\<notin> dom (finished s') \\<or>\n         \\<phi> s' w < \\<phi> s' v)\\<rbrakk>\n       \\<Longrightarrow> (v, w) \\<in> (tree_edges s')\\<^sup>+", "from F finished_discovered discover"], ["proof (chain)\npicking this:\n  a \\<in> dom (discovered s')\n  b \\<in> dom (finished s')\n  dom (finished s) \\<subseteq> dom (discovered s)\n  \\<forall>v\\<in>dom (discovered s).\n     \\<forall>w\\<in>dom (finished s).\n        \\<delta> s v < \\<delta> s w \\<and>\n        (v \\<notin> dom (finished s) \\<or>\n         \\<phi> s w < \\<phi> s v) \\<longrightarrow>\n        (v, w) \\<in> (tree_edges s)\\<^sup>+\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s \\<noteq> []\n  v \\<in> pending s `` {u}\n  v \\<notin> dom (discovered s)\n  u = hd (stack s)\n  s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n  \\<lparr>state.more := e_\\<rparr>", "have \"b \\<noteq> v\""], ["proof (prove)\nusing this:\n  a \\<in> dom (discovered s')\n  b \\<in> dom (finished s')\n  dom (finished s) \\<subseteq> dom (discovered s)\n  \\<forall>v\\<in>dom (discovered s).\n     \\<forall>w\\<in>dom (finished s).\n        \\<delta> s v < \\<delta> s w \\<and>\n        (v \\<notin> dom (finished s) \\<or>\n         \\<phi> s w < \\<phi> s v) \\<longrightarrow>\n        (v, w) \\<in> (tree_edges s)\\<^sup>+\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s \\<noteq> []\n  v \\<in> pending s `` {u}\n  v \\<notin> dom (discovered s)\n  u = hd (stack s)\n  s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n  \\<lparr>state.more := e_\\<rparr>\n\ngoal (1 subgoal):\n 1. b \\<noteq> v", "by auto"], ["proof (state)\nthis:\n  b \\<noteq> v\n\ngoal (1 subgoal):\n 1. \\<And>v w.\n       \\<lbrakk>v \\<in> dom (discovered s'); w \\<in> dom (finished s');\n        \\<delta> s' v < \\<delta> s' w \\<and>\n        (v \\<notin> dom (finished s') \\<or>\n         \\<phi> s' w < \\<phi> s' v)\\<rbrakk>\n       \\<Longrightarrow> (v, w) \\<in> (tree_edges s')\\<^sup>+", "show \"(a,b) \\<in> (tree_edges s')\\<^sup>+\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a, b) \\<in> (tree_edges s')\\<^sup>+", "proof (cases \"a = v\")"], ["proof (state)\ngoal (2 subgoals):\n 1. a = v \\<Longrightarrow> (a, b) \\<in> (tree_edges s')\\<^sup>+\n 2. a \\<noteq> v \\<Longrightarrow> (a, b) \\<in> (tree_edges s')\\<^sup>+", "case True"], ["proof (state)\nthis:\n  a = v\n\ngoal (2 subgoals):\n 1. a = v \\<Longrightarrow> (a, b) \\<in> (tree_edges s')\\<^sup>+\n 2. a \\<noteq> v \\<Longrightarrow> (a, b) \\<in> (tree_edges s')\\<^sup>+", "with D \\<open>b\\<noteq>v\\<close>"], ["proof (chain)\npicking this:\n  \\<delta> s' a < \\<delta> s' b \\<and>\n  (a \\<notin> dom (finished s') \\<or> \\<phi> s' b < \\<phi> s' a)\n  b \\<noteq> v\n  a = v", "have \"counter s < \\<delta> s b\""], ["proof (prove)\nusing this:\n  \\<delta> s' a < \\<delta> s' b \\<and>\n  (a \\<notin> dom (finished s') \\<or> \\<phi> s' b < \\<phi> s' a)\n  b \\<noteq> v\n  a = v\n\ngoal (1 subgoal):\n 1. counter s < \\<delta> s b", "by simp"], ["proof (state)\nthis:\n  counter s < \\<delta> s b\n\ngoal (2 subgoals):\n 1. a = v \\<Longrightarrow> (a, b) \\<in> (tree_edges s')\\<^sup>+\n 2. a \\<noteq> v \\<Longrightarrow> (a, b) \\<in> (tree_edges s')\\<^sup>+", "also"], ["proof (state)\nthis:\n  counter s < \\<delta> s b\n\ngoal (2 subgoals):\n 1. a = v \\<Longrightarrow> (a, b) \\<in> (tree_edges s')\\<^sup>+\n 2. a \\<noteq> v \\<Longrightarrow> (a, b) \\<in> (tree_edges s')\\<^sup>+", "from F"], ["proof (chain)\npicking this:\n  a \\<in> dom (discovered s')\n  b \\<in> dom (finished s')", "have \"b \\<in> dom (discovered s)\""], ["proof (prove)\nusing this:\n  a \\<in> dom (discovered s')\n  b \\<in> dom (finished s')\n\ngoal (1 subgoal):\n 1. b \\<in> dom (discovered s)", "using finished_discovered"], ["proof (prove)\nusing this:\n  a \\<in> dom (discovered s')\n  b \\<in> dom (finished s')\n  dom (finished s) \\<subseteq> dom (discovered s)\n\ngoal (1 subgoal):\n 1. b \\<in> dom (discovered s)", "by auto"], ["proof (state)\nthis:\n  b \\<in> dom (discovered s)\n\ngoal (2 subgoals):\n 1. a = v \\<Longrightarrow> (a, b) \\<in> (tree_edges s')\\<^sup>+\n 2. a \\<noteq> v \\<Longrightarrow> (a, b) \\<in> (tree_edges s')\\<^sup>+", "with timing_less_counter"], ["proof (chain)\npicking this:\n  ?v \\<in> dom (discovered s) \\<Longrightarrow> \\<delta> s ?v < counter s\n  ?v \\<in> dom (finished s) \\<Longrightarrow> \\<phi> s ?v < counter s\n  b \\<in> dom (discovered s)", "have \"\\<delta> s b < counter s\""], ["proof (prove)\nusing this:\n  ?v \\<in> dom (discovered s) \\<Longrightarrow> \\<delta> s ?v < counter s\n  ?v \\<in> dom (finished s) \\<Longrightarrow> \\<phi> s ?v < counter s\n  b \\<in> dom (discovered s)\n\ngoal (1 subgoal):\n 1. \\<delta> s b < counter s", "by simp"], ["proof (state)\nthis:\n  \\<delta> s b < counter s\n\ngoal (2 subgoals):\n 1. a = v \\<Longrightarrow> (a, b) \\<in> (tree_edges s')\\<^sup>+\n 2. a \\<noteq> v \\<Longrightarrow> (a, b) \\<in> (tree_edges s')\\<^sup>+", "finally"], ["proof (chain)\npicking this:\n  ?P", "have False"], ["proof (prove)\nusing this:\n  ?P\n\ngoal (1 subgoal):\n 1. False", "."], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. a = v \\<Longrightarrow> (a, b) \\<in> (tree_edges s')\\<^sup>+\n 2. a \\<noteq> v \\<Longrightarrow> (a, b) \\<in> (tree_edges s')\\<^sup>+", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. (a, b) \\<in> (tree_edges s')\\<^sup>+", ".."], ["proof (state)\nthis:\n  (a, b) \\<in> (tree_edges s')\\<^sup>+\n\ngoal (1 subgoal):\n 1. a \\<noteq> v \\<Longrightarrow> (a, b) \\<in> (tree_edges s')\\<^sup>+", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. a \\<noteq> v \\<Longrightarrow> (a, b) \\<in> (tree_edges s')\\<^sup>+", "case False"], ["proof (state)\nthis:\n  a \\<noteq> v\n\ngoal (1 subgoal):\n 1. a \\<noteq> v \\<Longrightarrow> (a, b) \\<in> (tree_edges s')\\<^sup>+", "with \\<open>b\\<noteq>v\\<close> F D discover"], ["proof (chain)\npicking this:\n  b \\<noteq> v\n  a \\<in> dom (discovered s')\n  b \\<in> dom (finished s')\n  \\<delta> s' a < \\<delta> s' b \\<and>\n  (a \\<notin> dom (finished s') \\<or> \\<phi> s' b < \\<phi> s' a)\n  \\<forall>v\\<in>dom (discovered s).\n     \\<forall>w\\<in>dom (finished s).\n        \\<delta> s v < \\<delta> s w \\<and>\n        (v \\<notin> dom (finished s) \\<or>\n         \\<phi> s w < \\<phi> s v) \\<longrightarrow>\n        (v, w) \\<in> (tree_edges s)\\<^sup>+\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s \\<noteq> []\n  v \\<in> pending s `` {u}\n  v \\<notin> dom (discovered s)\n  u = hd (stack s)\n  s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n  \\<lparr>state.more := e_\\<rparr>\n  a \\<noteq> v", "have \"(a,b) \\<in> (tree_edges s)\\<^sup>+\""], ["proof (prove)\nusing this:\n  b \\<noteq> v\n  a \\<in> dom (discovered s')\n  b \\<in> dom (finished s')\n  \\<delta> s' a < \\<delta> s' b \\<and>\n  (a \\<notin> dom (finished s') \\<or> \\<phi> s' b < \\<phi> s' a)\n  \\<forall>v\\<in>dom (discovered s).\n     \\<forall>w\\<in>dom (finished s).\n        \\<delta> s v < \\<delta> s w \\<and>\n        (v \\<notin> dom (finished s) \\<or>\n         \\<phi> s w < \\<phi> s v) \\<longrightarrow>\n        (v, w) \\<in> (tree_edges s)\\<^sup>+\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s \\<noteq> []\n  v \\<in> pending s `` {u}\n  v \\<notin> dom (discovered s)\n  u = hd (stack s)\n  s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n  \\<lparr>state.more := e_\\<rparr>\n  a \\<noteq> v\n\ngoal (1 subgoal):\n 1. (a, b) \\<in> (tree_edges s)\\<^sup>+", "by simp"], ["proof (state)\nthis:\n  (a, b) \\<in> (tree_edges s)\\<^sup>+\n\ngoal (1 subgoal):\n 1. a \\<noteq> v \\<Longrightarrow> (a, b) \\<in> (tree_edges s')\\<^sup>+", "thus ?thesis"], ["proof (prove)\nusing this:\n  (a, b) \\<in> (tree_edges s)\\<^sup>+\n\ngoal (1 subgoal):\n 1. (a, b) \\<in> (tree_edges s')\\<^sup>+", "by (auto intro: trancl_mono_mp)"], ["proof (state)\nthis:\n  (a, b) \\<in> (tree_edges s')\\<^sup>+\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (a, b) \\<in> (tree_edges s')\\<^sup>+\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>v\\<in>dom (discovered s').\n     \\<forall>w\\<in>dom (finished s').\n        \\<delta> s' v < \\<delta> s' w \\<and>\n        (v \\<notin> dom (finished s') \\<or>\n         \\<phi> s' w < \\<phi> s' v) \\<longrightarrow>\n        (v, w) \\<in> (tree_edges s')\\<^sup>+\n\ngoal (4 subgoals):\n 1. \\<And>e.\n       \\<forall>v\\<in>dom (discovered (empty_state e)).\n          \\<forall>w\\<in>dom (finished (empty_state e)).\n             \\<delta> (empty_state e) v < \\<delta> (empty_state e) w \\<and>\n             (v \\<notin> dom (finished (empty_state e)) \\<or>\n              \\<phi> (empty_state e) w\n              < \\<phi> (empty_state e) v) \\<longrightarrow>\n             (v, w) \\<in> (tree_edges (empty_state e))\\<^sup>+\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>\\<forall>v\\<in>dom (discovered s).\n                   \\<forall>w\\<in>dom (finished s).\n                      \\<delta> s v < \\<delta> s w \\<and>\n                      (v \\<notin> dom (finished s) \\<or>\n                       \\<phi> s w < \\<phi> s v) \\<longrightarrow>\n                      (v, w) \\<in> (tree_edges s)\\<^sup>+;\n        cond s; DFS_invar G param s; DFS_invar G param s'; stack s = [];\n        v0 \\<notin> dom (discovered s); v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>v\\<in>dom (discovered s').\n                            \\<forall>w\\<in>dom (finished s').\n                               \\<delta> s' v < \\<delta> s' w \\<and>\n                               (v \\<notin> dom (finished s') \\<or>\n                                \\<phi> s' w < \\<phi> s' v) \\<longrightarrow>\n                               (v, w) \\<in> (tree_edges s')\\<^sup>+\n 3. \\<And>s s' u e.\n       \\<lbrakk>\\<forall>v\\<in>dom (discovered s).\n                   \\<forall>w\\<in>dom (finished s).\n                      \\<delta> s v < \\<delta> s w \\<and>\n                      (v \\<notin> dom (finished s) \\<or>\n                       \\<phi> s w < \\<phi> s v) \\<longrightarrow>\n                      (v, w) \\<in> (tree_edges s)\\<^sup>+;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; pending s `` {u} = {}; u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>v\\<in>dom (discovered s').\n                            \\<forall>w\\<in>dom (finished s').\n                               \\<delta> s' v < \\<delta> s' w \\<and>\n                               (v \\<notin> dom (finished s') \\<or>\n                                \\<phi> s' w < \\<phi> s' v) \\<longrightarrow>\n                               (v, w) \\<in> (tree_edges s')\\<^sup>+\n 4. \\<And>s s' u v e c b.\n       \\<lbrakk>\\<forall>v\\<in>dom (discovered s).\n                   \\<forall>w\\<in>dom (finished s).\n                      \\<delta> s v < \\<delta> s w \\<and>\n                      (v \\<notin> dom (finished s) \\<or>\n                       \\<phi> s w < \\<phi> s v) \\<longrightarrow>\n                      (v, w) \\<in> (tree_edges s)\\<^sup>+;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); u = hd (stack s);\n        cross_edges s \\<subseteq> c; back_edges s \\<subseteq> b;\n        s' = s\n        \\<lparr>pending := pending s - {(u, v)}, state.more := e,\n           cross_edges := c, back_edges := b\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>v\\<in>dom (discovered s').\n                            \\<forall>w\\<in>dom (finished s').\n                               \\<delta> s' v < \\<delta> s' w \\<and>\n                               (v \\<notin> dom (finished s') \\<or>\n                                \\<phi> s' w < \\<phi> s' v) \\<longrightarrow>\n                               (v, w) \\<in> (tree_edges s')\\<^sup>+", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>e.\n       \\<forall>v\\<in>dom (discovered (empty_state e)).\n          \\<forall>w\\<in>dom (finished (empty_state e)).\n             \\<delta> (empty_state e) v < \\<delta> (empty_state e) w \\<and>\n             (v \\<notin> dom (finished (empty_state e)) \\<or>\n              \\<phi> (empty_state e) w\n              < \\<phi> (empty_state e) v) \\<longrightarrow>\n             (v, w) \\<in> (tree_edges (empty_state e))\\<^sup>+\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>\\<forall>v\\<in>dom (discovered s).\n                   \\<forall>w\\<in>dom (finished s).\n                      \\<delta> s v < \\<delta> s w \\<and>\n                      (v \\<notin> dom (finished s) \\<or>\n                       \\<phi> s w < \\<phi> s v) \\<longrightarrow>\n                      (v, w) \\<in> (tree_edges s)\\<^sup>+;\n        cond s; DFS_invar G param s; DFS_invar G param s'; stack s = [];\n        v0 \\<notin> dom (discovered s); v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>v\\<in>dom (discovered s').\n                            \\<forall>w\\<in>dom (finished s').\n                               \\<delta> s' v < \\<delta> s' w \\<and>\n                               (v \\<notin> dom (finished s') \\<or>\n                                \\<phi> s' w < \\<phi> s' v) \\<longrightarrow>\n                               (v, w) \\<in> (tree_edges s')\\<^sup>+\n 3. \\<And>s s' u e.\n       \\<lbrakk>\\<forall>v\\<in>dom (discovered s).\n                   \\<forall>w\\<in>dom (finished s).\n                      \\<delta> s v < \\<delta> s w \\<and>\n                      (v \\<notin> dom (finished s) \\<or>\n                       \\<phi> s w < \\<phi> s v) \\<longrightarrow>\n                      (v, w) \\<in> (tree_edges s)\\<^sup>+;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; pending s `` {u} = {}; u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>v\\<in>dom (discovered s').\n                            \\<forall>w\\<in>dom (finished s').\n                               \\<delta> s' v < \\<delta> s' w \\<and>\n                               (v \\<notin> dom (finished s') \\<or>\n                                \\<phi> s' w < \\<phi> s' v) \\<longrightarrow>\n                               (v, w) \\<in> (tree_edges s')\\<^sup>+\n 4. \\<And>s s' u v e c b.\n       \\<lbrakk>\\<forall>v\\<in>dom (discovered s).\n                   \\<forall>w\\<in>dom (finished s).\n                      \\<delta> s v < \\<delta> s w \\<and>\n                      (v \\<notin> dom (finished s) \\<or>\n                       \\<phi> s w < \\<phi> s v) \\<longrightarrow>\n                      (v, w) \\<in> (tree_edges s)\\<^sup>+;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); u = hd (stack s);\n        cross_edges s \\<subseteq> c; back_edges s \\<subseteq> b;\n        s' = s\n        \\<lparr>pending := pending s - {(u, v)}, state.more := e,\n           cross_edges := c, back_edges := b\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>v\\<in>dom (discovered s').\n                            \\<forall>w\\<in>dom (finished s').\n                               \\<delta> s' v < \\<delta> s' w \\<and>\n                               (v \\<notin> dom (finished s') \\<or>\n                                \\<phi> s' w < \\<phi> s' v) \\<longrightarrow>\n                               (v, w) \\<in> (tree_edges s')\\<^sup>+", "case (finish s s' u)"], ["proof (state)\nthis:\n  \\<forall>v\\<in>dom (discovered s).\n     \\<forall>w\\<in>dom (finished s).\n        \\<delta> s v < \\<delta> s w \\<and>\n        (v \\<notin> dom (finished s) \\<or>\n         \\<phi> s w < \\<phi> s v) \\<longrightarrow>\n        (v, w) \\<in> (tree_edges s)\\<^sup>+\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s \\<noteq> []\n  pending s `` {u} = {}\n  u = hd (stack s)\n  s' = finish u s\\<lparr>state.more := e_\\<rparr>\n\ngoal (4 subgoals):\n 1. \\<And>e.\n       \\<forall>v\\<in>dom (discovered (empty_state e)).\n          \\<forall>w\\<in>dom (finished (empty_state e)).\n             \\<delta> (empty_state e) v < \\<delta> (empty_state e) w \\<and>\n             (v \\<notin> dom (finished (empty_state e)) \\<or>\n              \\<phi> (empty_state e) w\n              < \\<phi> (empty_state e) v) \\<longrightarrow>\n             (v, w) \\<in> (tree_edges (empty_state e))\\<^sup>+\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>\\<forall>v\\<in>dom (discovered s).\n                   \\<forall>w\\<in>dom (finished s).\n                      \\<delta> s v < \\<delta> s w \\<and>\n                      (v \\<notin> dom (finished s) \\<or>\n                       \\<phi> s w < \\<phi> s v) \\<longrightarrow>\n                      (v, w) \\<in> (tree_edges s)\\<^sup>+;\n        cond s; DFS_invar G param s; DFS_invar G param s'; stack s = [];\n        v0 \\<notin> dom (discovered s); v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>v\\<in>dom (discovered s').\n                            \\<forall>w\\<in>dom (finished s').\n                               \\<delta> s' v < \\<delta> s' w \\<and>\n                               (v \\<notin> dom (finished s') \\<or>\n                                \\<phi> s' w < \\<phi> s' v) \\<longrightarrow>\n                               (v, w) \\<in> (tree_edges s')\\<^sup>+\n 3. \\<And>s s' u e.\n       \\<lbrakk>\\<forall>v\\<in>dom (discovered s).\n                   \\<forall>w\\<in>dom (finished s).\n                      \\<delta> s v < \\<delta> s w \\<and>\n                      (v \\<notin> dom (finished s) \\<or>\n                       \\<phi> s w < \\<phi> s v) \\<longrightarrow>\n                      (v, w) \\<in> (tree_edges s)\\<^sup>+;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; pending s `` {u} = {}; u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>v\\<in>dom (discovered s').\n                            \\<forall>w\\<in>dom (finished s').\n                               \\<delta> s' v < \\<delta> s' w \\<and>\n                               (v \\<notin> dom (finished s') \\<or>\n                                \\<phi> s' w < \\<phi> s' v) \\<longrightarrow>\n                               (v, w) \\<in> (tree_edges s')\\<^sup>+\n 4. \\<And>s s' u v e c b.\n       \\<lbrakk>\\<forall>v\\<in>dom (discovered s).\n                   \\<forall>w\\<in>dom (finished s).\n                      \\<delta> s v < \\<delta> s w \\<and>\n                      (v \\<notin> dom (finished s) \\<or>\n                       \\<phi> s w < \\<phi> s v) \\<longrightarrow>\n                      (v, w) \\<in> (tree_edges s)\\<^sup>+;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); u = hd (stack s);\n        cross_edges s \\<subseteq> c; back_edges s \\<subseteq> b;\n        s' = s\n        \\<lparr>pending := pending s - {(u, v)}, state.more := e,\n           cross_edges := c, back_edges := b\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>v\\<in>dom (discovered s').\n                            \\<forall>w\\<in>dom (finished s').\n                               \\<delta> s' v < \\<delta> s' w \\<and>\n                               (v \\<notin> dom (finished s') \\<or>\n                                \\<phi> s' w < \\<phi> s' v) \\<longrightarrow>\n                               (v, w) \\<in> (tree_edges s')\\<^sup>+", "hence EQ[simp]: \"tree_edges s' = tree_edges s\"\n                    \"finished s' = (finished s)(hd (stack s) \\<mapsto> counter s)\"\n                    \"discovered s' = discovered s\"\n                    \"stack s' = tl (stack s)\""], ["proof (prove)\nusing this:\n  \\<forall>v\\<in>dom (discovered s).\n     \\<forall>w\\<in>dom (finished s).\n        \\<delta> s v < \\<delta> s w \\<and>\n        (v \\<notin> dom (finished s) \\<or>\n         \\<phi> s w < \\<phi> s v) \\<longrightarrow>\n        (v, w) \\<in> (tree_edges s)\\<^sup>+\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s \\<noteq> []\n  pending s `` {u} = {}\n  u = hd (stack s)\n  s' = finish u s\\<lparr>state.more := e_\\<rparr>\n\ngoal (1 subgoal):\n 1. (tree_edges s' = tree_edges s &&&\n     finished s' = finished s(hd (stack s) \\<mapsto> counter s)) &&&\n    discovered s' = discovered s &&& stack s' = tl (stack s)", "by simp_all"], ["proof (state)\nthis:\n  tree_edges s' = tree_edges s\n  finished s' = finished s(hd (stack s) \\<mapsto> counter s)\n  discovered s' = discovered s\n  stack s' = tl (stack s)\n\ngoal (4 subgoals):\n 1. \\<And>e.\n       \\<forall>v\\<in>dom (discovered (empty_state e)).\n          \\<forall>w\\<in>dom (finished (empty_state e)).\n             \\<delta> (empty_state e) v < \\<delta> (empty_state e) w \\<and>\n             (v \\<notin> dom (finished (empty_state e)) \\<or>\n              \\<phi> (empty_state e) w\n              < \\<phi> (empty_state e) v) \\<longrightarrow>\n             (v, w) \\<in> (tree_edges (empty_state e))\\<^sup>+\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>\\<forall>v\\<in>dom (discovered s).\n                   \\<forall>w\\<in>dom (finished s).\n                      \\<delta> s v < \\<delta> s w \\<and>\n                      (v \\<notin> dom (finished s) \\<or>\n                       \\<phi> s w < \\<phi> s v) \\<longrightarrow>\n                      (v, w) \\<in> (tree_edges s)\\<^sup>+;\n        cond s; DFS_invar G param s; DFS_invar G param s'; stack s = [];\n        v0 \\<notin> dom (discovered s); v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>v\\<in>dom (discovered s').\n                            \\<forall>w\\<in>dom (finished s').\n                               \\<delta> s' v < \\<delta> s' w \\<and>\n                               (v \\<notin> dom (finished s') \\<or>\n                                \\<phi> s' w < \\<phi> s' v) \\<longrightarrow>\n                               (v, w) \\<in> (tree_edges s')\\<^sup>+\n 3. \\<And>s s' u e.\n       \\<lbrakk>\\<forall>v\\<in>dom (discovered s).\n                   \\<forall>w\\<in>dom (finished s).\n                      \\<delta> s v < \\<delta> s w \\<and>\n                      (v \\<notin> dom (finished s) \\<or>\n                       \\<phi> s w < \\<phi> s v) \\<longrightarrow>\n                      (v, w) \\<in> (tree_edges s)\\<^sup>+;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; pending s `` {u} = {}; u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>v\\<in>dom (discovered s').\n                            \\<forall>w\\<in>dom (finished s').\n                               \\<delta> s' v < \\<delta> s' w \\<and>\n                               (v \\<notin> dom (finished s') \\<or>\n                                \\<phi> s' w < \\<phi> s' v) \\<longrightarrow>\n                               (v, w) \\<in> (tree_edges s')\\<^sup>+\n 4. \\<And>s s' u v e c b.\n       \\<lbrakk>\\<forall>v\\<in>dom (discovered s).\n                   \\<forall>w\\<in>dom (finished s).\n                      \\<delta> s v < \\<delta> s w \\<and>\n                      (v \\<notin> dom (finished s) \\<or>\n                       \\<phi> s w < \\<phi> s v) \\<longrightarrow>\n                      (v, w) \\<in> (tree_edges s)\\<^sup>+;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); u = hd (stack s);\n        cross_edges s \\<subseteq> c; back_edges s \\<subseteq> b;\n        s' = s\n        \\<lparr>pending := pending s - {(u, v)}, state.more := e,\n           cross_edges := c, back_edges := b\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>v\\<in>dom (discovered s').\n                            \\<forall>w\\<in>dom (finished s').\n                               \\<delta> s' v < \\<delta> s' w \\<and>\n                               (v \\<notin> dom (finished s') \\<or>\n                                \\<phi> s' w < \\<phi> s' v) \\<longrightarrow>\n                               (v, w) \\<in> (tree_edges s')\\<^sup>+", "from finish"], ["proof (chain)\npicking this:\n  \\<forall>v\\<in>dom (discovered s).\n     \\<forall>w\\<in>dom (finished s).\n        \\<delta> s v < \\<delta> s w \\<and>\n        (v \\<notin> dom (finished s) \\<or>\n         \\<phi> s w < \\<phi> s v) \\<longrightarrow>\n        (v, w) \\<in> (tree_edges s)\\<^sup>+\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s \\<noteq> []\n  pending s `` {u} = {}\n  u = hd (stack s)\n  s' = finish u s\\<lparr>state.more := e_\\<rparr>", "interpret DFS_invar where s=s"], ["proof (prove)\nusing this:\n  \\<forall>v\\<in>dom (discovered s).\n     \\<forall>w\\<in>dom (finished s).\n        \\<delta> s v < \\<delta> s w \\<and>\n        (v \\<notin> dom (finished s) \\<or>\n         \\<phi> s w < \\<phi> s v) \\<longrightarrow>\n        (v, w) \\<in> (tree_edges s)\\<^sup>+\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s \\<noteq> []\n  pending s `` {u} = {}\n  u = hd (stack s)\n  s' = finish u s\\<lparr>state.more := e_\\<rparr>\n\ngoal (1 subgoal):\n 1. DFS_invar G param s", "by simp"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>e.\n       \\<forall>v\\<in>dom (discovered (empty_state e)).\n          \\<forall>w\\<in>dom (finished (empty_state e)).\n             \\<delta> (empty_state e) v < \\<delta> (empty_state e) w \\<and>\n             (v \\<notin> dom (finished (empty_state e)) \\<or>\n              \\<phi> (empty_state e) w\n              < \\<phi> (empty_state e) v) \\<longrightarrow>\n             (v, w) \\<in> (tree_edges (empty_state e))\\<^sup>+\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>\\<forall>v\\<in>dom (discovered s).\n                   \\<forall>w\\<in>dom (finished s).\n                      \\<delta> s v < \\<delta> s w \\<and>\n                      (v \\<notin> dom (finished s) \\<or>\n                       \\<phi> s w < \\<phi> s v) \\<longrightarrow>\n                      (v, w) \\<in> (tree_edges s)\\<^sup>+;\n        cond s; DFS_invar G param s; DFS_invar G param s'; stack s = [];\n        v0 \\<notin> dom (discovered s); v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>v\\<in>dom (discovered s').\n                            \\<forall>w\\<in>dom (finished s').\n                               \\<delta> s' v < \\<delta> s' w \\<and>\n                               (v \\<notin> dom (finished s') \\<or>\n                                \\<phi> s' w < \\<phi> s' v) \\<longrightarrow>\n                               (v, w) \\<in> (tree_edges s')\\<^sup>+\n 3. \\<And>s s' u e.\n       \\<lbrakk>\\<forall>v\\<in>dom (discovered s).\n                   \\<forall>w\\<in>dom (finished s).\n                      \\<delta> s v < \\<delta> s w \\<and>\n                      (v \\<notin> dom (finished s) \\<or>\n                       \\<phi> s w < \\<phi> s v) \\<longrightarrow>\n                      (v, w) \\<in> (tree_edges s)\\<^sup>+;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; pending s `` {u} = {}; u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>v\\<in>dom (discovered s').\n                            \\<forall>w\\<in>dom (finished s').\n                               \\<delta> s' v < \\<delta> s' w \\<and>\n                               (v \\<notin> dom (finished s') \\<or>\n                                \\<phi> s' w < \\<phi> s' v) \\<longrightarrow>\n                               (v, w) \\<in> (tree_edges s')\\<^sup>+\n 4. \\<And>s s' u v e c b.\n       \\<lbrakk>\\<forall>v\\<in>dom (discovered s).\n                   \\<forall>w\\<in>dom (finished s).\n                      \\<delta> s v < \\<delta> s w \\<and>\n                      (v \\<notin> dom (finished s) \\<or>\n                       \\<phi> s w < \\<phi> s v) \\<longrightarrow>\n                      (v, w) \\<in> (tree_edges s)\\<^sup>+;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); u = hd (stack s);\n        cross_edges s \\<subseteq> c; back_edges s \\<subseteq> b;\n        s' = s\n        \\<lparr>pending := pending s - {(u, v)}, state.more := e,\n           cross_edges := c, back_edges := b\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>v\\<in>dom (discovered s').\n                            \\<forall>w\\<in>dom (finished s').\n                               \\<delta> s' v < \\<delta> s' w \\<and>\n                               (v \\<notin> dom (finished s') \\<or>\n                                \\<phi> s' w < \\<phi> s' v) \\<longrightarrow>\n                               (v, w) \\<in> (tree_edges s')\\<^sup>+", "from finish"], ["proof (chain)\npicking this:\n  \\<forall>v\\<in>dom (discovered s).\n     \\<forall>w\\<in>dom (finished s).\n        \\<delta> s v < \\<delta> s w \\<and>\n        (v \\<notin> dom (finished s) \\<or>\n         \\<phi> s w < \\<phi> s v) \\<longrightarrow>\n        (v, w) \\<in> (tree_edges s)\\<^sup>+\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s \\<noteq> []\n  pending s `` {u} = {}\n  u = hd (stack s)\n  s' = finish u s\\<lparr>state.more := e_\\<rparr>", "have NE[simp]: \"stack s \\<noteq> []\""], ["proof (prove)\nusing this:\n  \\<forall>v\\<in>dom (discovered s).\n     \\<forall>w\\<in>dom (finished s).\n        \\<delta> s v < \\<delta> s w \\<and>\n        (v \\<notin> dom (finished s) \\<or>\n         \\<phi> s w < \\<phi> s v) \\<longrightarrow>\n        (v, w) \\<in> (tree_edges s)\\<^sup>+\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s \\<noteq> []\n  pending s `` {u} = {}\n  u = hd (stack s)\n  s' = finish u s\\<lparr>state.more := e_\\<rparr>\n\ngoal (1 subgoal):\n 1. stack s \\<noteq> []", "by (simp add: cond_alt)"], ["proof (state)\nthis:\n  stack s \\<noteq> []\n\ngoal (4 subgoals):\n 1. \\<And>e.\n       \\<forall>v\\<in>dom (discovered (empty_state e)).\n          \\<forall>w\\<in>dom (finished (empty_state e)).\n             \\<delta> (empty_state e) v < \\<delta> (empty_state e) w \\<and>\n             (v \\<notin> dom (finished (empty_state e)) \\<or>\n              \\<phi> (empty_state e) w\n              < \\<phi> (empty_state e) v) \\<longrightarrow>\n             (v, w) \\<in> (tree_edges (empty_state e))\\<^sup>+\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>\\<forall>v\\<in>dom (discovered s).\n                   \\<forall>w\\<in>dom (finished s).\n                      \\<delta> s v < \\<delta> s w \\<and>\n                      (v \\<notin> dom (finished s) \\<or>\n                       \\<phi> s w < \\<phi> s v) \\<longrightarrow>\n                      (v, w) \\<in> (tree_edges s)\\<^sup>+;\n        cond s; DFS_invar G param s; DFS_invar G param s'; stack s = [];\n        v0 \\<notin> dom (discovered s); v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>v\\<in>dom (discovered s').\n                            \\<forall>w\\<in>dom (finished s').\n                               \\<delta> s' v < \\<delta> s' w \\<and>\n                               (v \\<notin> dom (finished s') \\<or>\n                                \\<phi> s' w < \\<phi> s' v) \\<longrightarrow>\n                               (v, w) \\<in> (tree_edges s')\\<^sup>+\n 3. \\<And>s s' u e.\n       \\<lbrakk>\\<forall>v\\<in>dom (discovered s).\n                   \\<forall>w\\<in>dom (finished s).\n                      \\<delta> s v < \\<delta> s w \\<and>\n                      (v \\<notin> dom (finished s) \\<or>\n                       \\<phi> s w < \\<phi> s v) \\<longrightarrow>\n                      (v, w) \\<in> (tree_edges s)\\<^sup>+;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; pending s `` {u} = {}; u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>v\\<in>dom (discovered s').\n                            \\<forall>w\\<in>dom (finished s').\n                               \\<delta> s' v < \\<delta> s' w \\<and>\n                               (v \\<notin> dom (finished s') \\<or>\n                                \\<phi> s' w < \\<phi> s' v) \\<longrightarrow>\n                               (v, w) \\<in> (tree_edges s')\\<^sup>+\n 4. \\<And>s s' u v e c b.\n       \\<lbrakk>\\<forall>v\\<in>dom (discovered s).\n                   \\<forall>w\\<in>dom (finished s).\n                      \\<delta> s v < \\<delta> s w \\<and>\n                      (v \\<notin> dom (finished s) \\<or>\n                       \\<phi> s w < \\<phi> s v) \\<longrightarrow>\n                      (v, w) \\<in> (tree_edges s)\\<^sup>+;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); u = hd (stack s);\n        cross_edges s \\<subseteq> c; back_edges s \\<subseteq> b;\n        s' = s\n        \\<lparr>pending := pending s - {(u, v)}, state.more := e,\n           cross_edges := c, back_edges := b\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>v\\<in>dom (discovered s').\n                            \\<forall>w\\<in>dom (finished s').\n                               \\<delta> s' v < \\<delta> s' w \\<and>\n                               (v \\<notin> dom (finished s') \\<or>\n                                \\<phi> s' w < \\<phi> s' v) \\<longrightarrow>\n                               (v, w) \\<in> (tree_edges s')\\<^sup>+", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>dom (discovered s').\n       \\<forall>w\\<in>dom (finished s').\n          \\<delta> s' v < \\<delta> s' w \\<and>\n          (v \\<notin> dom (finished s') \\<or>\n           \\<phi> s' w < \\<phi> s' v) \\<longrightarrow>\n          (v, w) \\<in> (tree_edges s')\\<^sup>+", "proof (intro ballI impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v w.\n       \\<lbrakk>v \\<in> dom (discovered s'); w \\<in> dom (finished s');\n        \\<delta> s' v < \\<delta> s' w \\<and>\n        (v \\<notin> dom (finished s') \\<or>\n         \\<phi> s' w < \\<phi> s' v)\\<rbrakk>\n       \\<Longrightarrow> (v, w) \\<in> (tree_edges s')\\<^sup>+", "fix a b"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v w.\n       \\<lbrakk>v \\<in> dom (discovered s'); w \\<in> dom (finished s');\n        \\<delta> s' v < \\<delta> s' w \\<and>\n        (v \\<notin> dom (finished s') \\<or>\n         \\<phi> s' w < \\<phi> s' v)\\<rbrakk>\n       \\<Longrightarrow> (v, w) \\<in> (tree_edges s')\\<^sup>+", "assume F: \"a \\<in> dom (discovered s')\" \"b \\<in> dom (finished s')\"\n        and paren: \"\\<delta> s' a < \\<delta> s' b \\<and> (a \\<notin> dom (finished s') \\<or> \\<phi> s' a > \\<phi> s' b)\""], ["proof (state)\nthis:\n  a \\<in> dom (discovered s')\n  b \\<in> dom (finished s')\n  \\<delta> s' a < \\<delta> s' b \\<and>\n  (a \\<notin> dom (finished s') \\<or> \\<phi> s' b < \\<phi> s' a)\n\ngoal (1 subgoal):\n 1. \\<And>v w.\n       \\<lbrakk>v \\<in> dom (discovered s'); w \\<in> dom (finished s');\n        \\<delta> s' v < \\<delta> s' w \\<and>\n        (v \\<notin> dom (finished s') \\<or>\n         \\<phi> s' w < \\<phi> s' v)\\<rbrakk>\n       \\<Longrightarrow> (v, w) \\<in> (tree_edges s')\\<^sup>+", "hence \"a \\<noteq> b\""], ["proof (prove)\nusing this:\n  a \\<in> dom (discovered s')\n  b \\<in> dom (finished s')\n  \\<delta> s' a < \\<delta> s' b \\<and>\n  (a \\<notin> dom (finished s') \\<or> \\<phi> s' b < \\<phi> s' a)\n\ngoal (1 subgoal):\n 1. a \\<noteq> b", "by auto"], ["proof (state)\nthis:\n  a \\<noteq> b\n\ngoal (1 subgoal):\n 1. \\<And>v w.\n       \\<lbrakk>v \\<in> dom (discovered s'); w \\<in> dom (finished s');\n        \\<delta> s' v < \\<delta> s' w \\<and>\n        (v \\<notin> dom (finished s') \\<or>\n         \\<phi> s' w < \\<phi> s' v)\\<rbrakk>\n       \\<Longrightarrow> (v, w) \\<in> (tree_edges s')\\<^sup>+", "show \"(a,b) \\<in> (tree_edges s')\\<^sup>+\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a, b) \\<in> (tree_edges s')\\<^sup>+", "proof (cases \"b = hd (stack s)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. b = hd (stack s) \\<Longrightarrow> (a, b) \\<in> (tree_edges s')\\<^sup>+\n 2. b \\<noteq> hd (stack s) \\<Longrightarrow>\n    (a, b) \\<in> (tree_edges s')\\<^sup>+", "case True"], ["proof (state)\nthis:\n  b = hd (stack s)\n\ngoal (2 subgoals):\n 1. b = hd (stack s) \\<Longrightarrow> (a, b) \\<in> (tree_edges s')\\<^sup>+\n 2. b \\<noteq> hd (stack s) \\<Longrightarrow>\n    (a, b) \\<in> (tree_edges s')\\<^sup>+", "hence \\<phi>b: \"\\<phi> s' b = counter s\""], ["proof (prove)\nusing this:\n  b = hd (stack s)\n\ngoal (1 subgoal):\n 1. \\<phi> s' b = counter s", "by simp"], ["proof (state)\nthis:\n  \\<phi> s' b = counter s\n\ngoal (2 subgoals):\n 1. b = hd (stack s) \\<Longrightarrow> (a, b) \\<in> (tree_edges s')\\<^sup>+\n 2. b \\<noteq> hd (stack s) \\<Longrightarrow>\n    (a, b) \\<in> (tree_edges s')\\<^sup>+", "have \"a \\<in> set (stack s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<in> set (stack s)", "unfolding stack_set_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<in> dom (discovered s) - dom (finished s)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. a \\<in> dom (discovered s)\n 2. a \\<notin> dom (finished s)", "from F"], ["proof (chain)\npicking this:\n  a \\<in> dom (discovered s')\n  b \\<in> dom (finished s')", "show \"a \\<in> dom (discovered s)\""], ["proof (prove)\nusing this:\n  a \\<in> dom (discovered s')\n  b \\<in> dom (finished s')\n\ngoal (1 subgoal):\n 1. a \\<in> dom (discovered s)", "by simp"], ["proof (state)\nthis:\n  a \\<in> dom (discovered s)\n\ngoal (1 subgoal):\n 1. a \\<notin> dom (finished s)", "from True \\<open>a\\<noteq>b\\<close> \\<phi>b paren"], ["proof (chain)\npicking this:\n  b = hd (stack s)\n  a \\<noteq> b\n  \\<phi> s' b = counter s\n  \\<delta> s' a < \\<delta> s' b \\<and>\n  (a \\<notin> dom (finished s') \\<or> \\<phi> s' b < \\<phi> s' a)", "have \"a \\<in> dom (finished s) \\<longrightarrow> \\<phi> s a > counter s\""], ["proof (prove)\nusing this:\n  b = hd (stack s)\n  a \\<noteq> b\n  \\<phi> s' b = counter s\n  \\<delta> s' a < \\<delta> s' b \\<and>\n  (a \\<notin> dom (finished s') \\<or> \\<phi> s' b < \\<phi> s' a)\n\ngoal (1 subgoal):\n 1. a \\<in> dom (finished s) \\<longrightarrow> counter s < \\<phi> s a", "by simp"], ["proof (state)\nthis:\n  a \\<in> dom (finished s) \\<longrightarrow> counter s < \\<phi> s a\n\ngoal (1 subgoal):\n 1. a \\<notin> dom (finished s)", "with timing_less_counter"], ["proof (chain)\npicking this:\n  ?v \\<in> dom (discovered s) \\<Longrightarrow> \\<delta> s ?v < counter s\n  ?v \\<in> dom (finished s) \\<Longrightarrow> \\<phi> s ?v < counter s\n  a \\<in> dom (finished s) \\<longrightarrow> counter s < \\<phi> s a", "show \"a \\<notin> dom (finished s)\""], ["proof (prove)\nusing this:\n  ?v \\<in> dom (discovered s) \\<Longrightarrow> \\<delta> s ?v < counter s\n  ?v \\<in> dom (finished s) \\<Longrightarrow> \\<phi> s ?v < counter s\n  a \\<in> dom (finished s) \\<longrightarrow> counter s < \\<phi> s a\n\ngoal (1 subgoal):\n 1. a \\<notin> dom (finished s)", "by force"], ["proof (state)\nthis:\n  a \\<notin> dom (finished s)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  a \\<in> set (stack s)\n\ngoal (2 subgoals):\n 1. b = hd (stack s) \\<Longrightarrow> (a, b) \\<in> (tree_edges s')\\<^sup>+\n 2. b \\<noteq> hd (stack s) \\<Longrightarrow>\n    (a, b) \\<in> (tree_edges s')\\<^sup>+", "with paren True on_stack_is_tree_path"], ["proof (chain)\npicking this:\n  \\<delta> s' a < \\<delta> s' b \\<and>\n  (a \\<notin> dom (finished s') \\<or> \\<phi> s' b < \\<phi> s' a)\n  b = hd (stack s)\n  \\<lbrakk>?x \\<in> set (stack s); ?y \\<in> set (stack s);\n   \\<delta> s ?x < \\<delta> s ?y\\<rbrakk>\n  \\<Longrightarrow> (?x, ?y) \\<in> (tree_edges s)\\<^sup>+\n  a \\<in> set (stack s)", "have \"(a,b) \\<in> (tree_edges s)\\<^sup>+\""], ["proof (prove)\nusing this:\n  \\<delta> s' a < \\<delta> s' b \\<and>\n  (a \\<notin> dom (finished s') \\<or> \\<phi> s' b < \\<phi> s' a)\n  b = hd (stack s)\n  \\<lbrakk>?x \\<in> set (stack s); ?y \\<in> set (stack s);\n   \\<delta> s ?x < \\<delta> s ?y\\<rbrakk>\n  \\<Longrightarrow> (?x, ?y) \\<in> (tree_edges s)\\<^sup>+\n  a \\<in> set (stack s)\n\ngoal (1 subgoal):\n 1. (a, b) \\<in> (tree_edges s)\\<^sup>+", "by auto"], ["proof (state)\nthis:\n  (a, b) \\<in> (tree_edges s)\\<^sup>+\n\ngoal (2 subgoals):\n 1. b = hd (stack s) \\<Longrightarrow> (a, b) \\<in> (tree_edges s')\\<^sup>+\n 2. b \\<noteq> hd (stack s) \\<Longrightarrow>\n    (a, b) \\<in> (tree_edges s')\\<^sup>+", "thus ?thesis"], ["proof (prove)\nusing this:\n  (a, b) \\<in> (tree_edges s)\\<^sup>+\n\ngoal (1 subgoal):\n 1. (a, b) \\<in> (tree_edges s')\\<^sup>+", "by (auto intro: trancl_mono_mp)"], ["proof (state)\nthis:\n  (a, b) \\<in> (tree_edges s')\\<^sup>+\n\ngoal (1 subgoal):\n 1. b \\<noteq> hd (stack s) \\<Longrightarrow>\n    (a, b) \\<in> (tree_edges s')\\<^sup>+", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. b \\<noteq> hd (stack s) \\<Longrightarrow>\n    (a, b) \\<in> (tree_edges s')\\<^sup>+", "case False"], ["proof (state)\nthis:\n  b \\<noteq> hd (stack s)\n\ngoal (1 subgoal):\n 1. b \\<noteq> hd (stack s) \\<Longrightarrow>\n    (a, b) \\<in> (tree_edges s')\\<^sup>+", "note b_not_hd = this"], ["proof (state)\nthis:\n  b \\<noteq> hd (stack s)\n\ngoal (1 subgoal):\n 1. b \\<noteq> hd (stack s) \\<Longrightarrow>\n    (a, b) \\<in> (tree_edges s')\\<^sup>+", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (a, b) \\<in> (tree_edges s')\\<^sup>+", "proof (cases \"a = hd (stack s)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. a = hd (stack s) \\<Longrightarrow> (a, b) \\<in> (tree_edges s')\\<^sup>+\n 2. a \\<noteq> hd (stack s) \\<Longrightarrow>\n    (a, b) \\<in> (tree_edges s')\\<^sup>+", "case False"], ["proof (state)\nthis:\n  a \\<noteq> hd (stack s)\n\ngoal (2 subgoals):\n 1. a = hd (stack s) \\<Longrightarrow> (a, b) \\<in> (tree_edges s')\\<^sup>+\n 2. a \\<noteq> hd (stack s) \\<Longrightarrow>\n    (a, b) \\<in> (tree_edges s')\\<^sup>+", "with b_not_hd F paren finish"], ["proof (chain)\npicking this:\n  b \\<noteq> hd (stack s)\n  a \\<in> dom (discovered s')\n  b \\<in> dom (finished s')\n  \\<delta> s' a < \\<delta> s' b \\<and>\n  (a \\<notin> dom (finished s') \\<or> \\<phi> s' b < \\<phi> s' a)\n  \\<forall>v\\<in>dom (discovered s).\n     \\<forall>w\\<in>dom (finished s).\n        \\<delta> s v < \\<delta> s w \\<and>\n        (v \\<notin> dom (finished s) \\<or>\n         \\<phi> s w < \\<phi> s v) \\<longrightarrow>\n        (v, w) \\<in> (tree_edges s)\\<^sup>+\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s \\<noteq> []\n  pending s `` {u} = {}\n  u = hd (stack s)\n  s' = finish u s\\<lparr>state.more := e_\\<rparr>\n  a \\<noteq> hd (stack s)", "show ?thesis"], ["proof (prove)\nusing this:\n  b \\<noteq> hd (stack s)\n  a \\<in> dom (discovered s')\n  b \\<in> dom (finished s')\n  \\<delta> s' a < \\<delta> s' b \\<and>\n  (a \\<notin> dom (finished s') \\<or> \\<phi> s' b < \\<phi> s' a)\n  \\<forall>v\\<in>dom (discovered s).\n     \\<forall>w\\<in>dom (finished s).\n        \\<delta> s v < \\<delta> s w \\<and>\n        (v \\<notin> dom (finished s) \\<or>\n         \\<phi> s w < \\<phi> s v) \\<longrightarrow>\n        (v, w) \\<in> (tree_edges s)\\<^sup>+\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s \\<noteq> []\n  pending s `` {u} = {}\n  u = hd (stack s)\n  s' = finish u s\\<lparr>state.more := e_\\<rparr>\n  a \\<noteq> hd (stack s)\n\ngoal (1 subgoal):\n 1. (a, b) \\<in> (tree_edges s')\\<^sup>+", "by simp"], ["proof (state)\nthis:\n  (a, b) \\<in> (tree_edges s')\\<^sup>+\n\ngoal (1 subgoal):\n 1. a = hd (stack s) \\<Longrightarrow> (a, b) \\<in> (tree_edges s')\\<^sup>+", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. a = hd (stack s) \\<Longrightarrow> (a, b) \\<in> (tree_edges s')\\<^sup>+", "case True"], ["proof (state)\nthis:\n  a = hd (stack s)\n\ngoal (1 subgoal):\n 1. a = hd (stack s) \\<Longrightarrow> (a, b) \\<in> (tree_edges s')\\<^sup>+", "with paren b_not_hd F"], ["proof (chain)\npicking this:\n  \\<delta> s' a < \\<delta> s' b \\<and>\n  (a \\<notin> dom (finished s') \\<or> \\<phi> s' b < \\<phi> s' a)\n  b \\<noteq> hd (stack s)\n  a \\<in> dom (discovered s')\n  b \\<in> dom (finished s')\n  a = hd (stack s)", "have \n            \"a \\<in> dom (discovered s)\" \"b \\<in> dom (finished s)\"  \"\\<delta> s a < \\<delta> s b\""], ["proof (prove)\nusing this:\n  \\<delta> s' a < \\<delta> s' b \\<and>\n  (a \\<notin> dom (finished s') \\<or> \\<phi> s' b < \\<phi> s' a)\n  b \\<noteq> hd (stack s)\n  a \\<in> dom (discovered s')\n  b \\<in> dom (finished s')\n  a = hd (stack s)\n\ngoal (1 subgoal):\n 1. a \\<in> dom (discovered s) &&&\n    b \\<in> dom (finished s) &&& \\<delta> s a < \\<delta> s b", "by simp_all"], ["proof (state)\nthis:\n  a \\<in> dom (discovered s)\n  b \\<in> dom (finished s)\n  \\<delta> s a < \\<delta> s b\n\ngoal (1 subgoal):\n 1. a = hd (stack s) \\<Longrightarrow> (a, b) \\<in> (tree_edges s')\\<^sup>+", "moreover"], ["proof (state)\nthis:\n  a \\<in> dom (discovered s)\n  b \\<in> dom (finished s)\n  \\<delta> s a < \\<delta> s b\n\ngoal (1 subgoal):\n 1. a = hd (stack s) \\<Longrightarrow> (a, b) \\<in> (tree_edges s')\\<^sup>+", "from True stack_not_finished"], ["proof (chain)\npicking this:\n  a = hd (stack s)\n  ?x \\<in> set (stack s) \\<Longrightarrow> ?x \\<notin> dom (finished s)", "have \"a \\<notin> dom (finished s)\""], ["proof (prove)\nusing this:\n  a = hd (stack s)\n  ?x \\<in> set (stack s) \\<Longrightarrow> ?x \\<notin> dom (finished s)\n\ngoal (1 subgoal):\n 1. a \\<notin> dom (finished s)", "by simp"], ["proof (state)\nthis:\n  a \\<notin> dom (finished s)\n\ngoal (1 subgoal):\n 1. a = hd (stack s) \\<Longrightarrow> (a, b) \\<in> (tree_edges s')\\<^sup>+", "ultimately"], ["proof (chain)\npicking this:\n  a \\<in> dom (discovered s)\n  b \\<in> dom (finished s)\n  \\<delta> s a < \\<delta> s b\n  a \\<notin> dom (finished s)", "show ?thesis"], ["proof (prove)\nusing this:\n  a \\<in> dom (discovered s)\n  b \\<in> dom (finished s)\n  \\<delta> s a < \\<delta> s b\n  a \\<notin> dom (finished s)\n\ngoal (1 subgoal):\n 1. (a, b) \\<in> (tree_edges s')\\<^sup>+", "by (simp add: finish)"], ["proof (state)\nthis:\n  (a, b) \\<in> (tree_edges s')\\<^sup>+\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (a, b) \\<in> (tree_edges s')\\<^sup>+\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (a, b) \\<in> (tree_edges s')\\<^sup>+\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>v\\<in>dom (discovered s').\n     \\<forall>w\\<in>dom (finished s').\n        \\<delta> s' v < \\<delta> s' w \\<and>\n        (v \\<notin> dom (finished s') \\<or>\n         \\<phi> s' w < \\<phi> s' v) \\<longrightarrow>\n        (v, w) \\<in> (tree_edges s')\\<^sup>+\n\ngoal (3 subgoals):\n 1. \\<And>e.\n       \\<forall>v\\<in>dom (discovered (empty_state e)).\n          \\<forall>w\\<in>dom (finished (empty_state e)).\n             \\<delta> (empty_state e) v < \\<delta> (empty_state e) w \\<and>\n             (v \\<notin> dom (finished (empty_state e)) \\<or>\n              \\<phi> (empty_state e) w\n              < \\<phi> (empty_state e) v) \\<longrightarrow>\n             (v, w) \\<in> (tree_edges (empty_state e))\\<^sup>+\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>\\<forall>v\\<in>dom (discovered s).\n                   \\<forall>w\\<in>dom (finished s).\n                      \\<delta> s v < \\<delta> s w \\<and>\n                      (v \\<notin> dom (finished s) \\<or>\n                       \\<phi> s w < \\<phi> s v) \\<longrightarrow>\n                      (v, w) \\<in> (tree_edges s)\\<^sup>+;\n        cond s; DFS_invar G param s; DFS_invar G param s'; stack s = [];\n        v0 \\<notin> dom (discovered s); v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>v\\<in>dom (discovered s').\n                            \\<forall>w\\<in>dom (finished s').\n                               \\<delta> s' v < \\<delta> s' w \\<and>\n                               (v \\<notin> dom (finished s') \\<or>\n                                \\<phi> s' w < \\<phi> s' v) \\<longrightarrow>\n                               (v, w) \\<in> (tree_edges s')\\<^sup>+\n 3. \\<And>s s' u v e c b.\n       \\<lbrakk>\\<forall>v\\<in>dom (discovered s).\n                   \\<forall>w\\<in>dom (finished s).\n                      \\<delta> s v < \\<delta> s w \\<and>\n                      (v \\<notin> dom (finished s) \\<or>\n                       \\<phi> s w < \\<phi> s v) \\<longrightarrow>\n                      (v, w) \\<in> (tree_edges s)\\<^sup>+;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); u = hd (stack s);\n        cross_edges s \\<subseteq> c; back_edges s \\<subseteq> b;\n        s' = s\n        \\<lparr>pending := pending s - {(u, v)}, state.more := e,\n           cross_edges := c, back_edges := b\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>v\\<in>dom (discovered s').\n                            \\<forall>w\\<in>dom (finished s').\n                               \\<delta> s' v < \\<delta> s' w \\<and>\n                               (v \\<notin> dom (finished s') \\<or>\n                                \\<phi> s' w < \\<phi> s' v) \\<longrightarrow>\n                               (v, w) \\<in> (tree_edges s')\\<^sup>+", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>e.\n       \\<forall>v\\<in>dom (discovered (empty_state e)).\n          \\<forall>w\\<in>dom (finished (empty_state e)).\n             \\<delta> (empty_state e) v < \\<delta> (empty_state e) w \\<and>\n             (v \\<notin> dom (finished (empty_state e)) \\<or>\n              \\<phi> (empty_state e) w\n              < \\<phi> (empty_state e) v) \\<longrightarrow>\n             (v, w) \\<in> (tree_edges (empty_state e))\\<^sup>+\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>\\<forall>v\\<in>dom (discovered s).\n                   \\<forall>w\\<in>dom (finished s).\n                      \\<delta> s v < \\<delta> s w \\<and>\n                      (v \\<notin> dom (finished s) \\<or>\n                       \\<phi> s w < \\<phi> s v) \\<longrightarrow>\n                      (v, w) \\<in> (tree_edges s)\\<^sup>+;\n        cond s; DFS_invar G param s; DFS_invar G param s'; stack s = [];\n        v0 \\<notin> dom (discovered s); v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>v\\<in>dom (discovered s').\n                            \\<forall>w\\<in>dom (finished s').\n                               \\<delta> s' v < \\<delta> s' w \\<and>\n                               (v \\<notin> dom (finished s') \\<or>\n                                \\<phi> s' w < \\<phi> s' v) \\<longrightarrow>\n                               (v, w) \\<in> (tree_edges s')\\<^sup>+\n 3. \\<And>s s' u v e c b.\n       \\<lbrakk>\\<forall>v\\<in>dom (discovered s).\n                   \\<forall>w\\<in>dom (finished s).\n                      \\<delta> s v < \\<delta> s w \\<and>\n                      (v \\<notin> dom (finished s) \\<or>\n                       \\<phi> s w < \\<phi> s v) \\<longrightarrow>\n                      (v, w) \\<in> (tree_edges s)\\<^sup>+;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); u = hd (stack s);\n        cross_edges s \\<subseteq> c; back_edges s \\<subseteq> b;\n        s' = s\n        \\<lparr>pending := pending s - {(u, v)}, state.more := e,\n           cross_edges := c, back_edges := b\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>v\\<in>dom (discovered s').\n                            \\<forall>w\\<in>dom (finished s').\n                               \\<delta> s' v < \\<delta> s' w \\<and>\n                               (v \\<notin> dom (finished s') \\<or>\n                                \\<phi> s' w < \\<phi> s' v) \\<longrightarrow>\n                               (v, w) \\<in> (tree_edges s')\\<^sup>+", "case (new_root s s' v0)"], ["proof (state)\nthis:\n  \\<forall>v\\<in>dom (discovered s).\n     \\<forall>w\\<in>dom (finished s).\n        \\<delta> s v < \\<delta> s w \\<and>\n        (v \\<notin> dom (finished s) \\<or>\n         \\<phi> s w < \\<phi> s v) \\<longrightarrow>\n        (v, w) \\<in> (tree_edges s)\\<^sup>+\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s = []\n  v0 \\<notin> dom (discovered s)\n  v0 \\<in> V0\n  s' = new_root v0 s\\<lparr>state.more := e_\\<rparr>\n\ngoal (3 subgoals):\n 1. \\<And>e.\n       \\<forall>v\\<in>dom (discovered (empty_state e)).\n          \\<forall>w\\<in>dom (finished (empty_state e)).\n             \\<delta> (empty_state e) v < \\<delta> (empty_state e) w \\<and>\n             (v \\<notin> dom (finished (empty_state e)) \\<or>\n              \\<phi> (empty_state e) w\n              < \\<phi> (empty_state e) v) \\<longrightarrow>\n             (v, w) \\<in> (tree_edges (empty_state e))\\<^sup>+\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>\\<forall>v\\<in>dom (discovered s).\n                   \\<forall>w\\<in>dom (finished s).\n                      \\<delta> s v < \\<delta> s w \\<and>\n                      (v \\<notin> dom (finished s) \\<or>\n                       \\<phi> s w < \\<phi> s v) \\<longrightarrow>\n                      (v, w) \\<in> (tree_edges s)\\<^sup>+;\n        cond s; DFS_invar G param s; DFS_invar G param s'; stack s = [];\n        v0 \\<notin> dom (discovered s); v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>v\\<in>dom (discovered s').\n                            \\<forall>w\\<in>dom (finished s').\n                               \\<delta> s' v < \\<delta> s' w \\<and>\n                               (v \\<notin> dom (finished s') \\<or>\n                                \\<phi> s' w < \\<phi> s' v) \\<longrightarrow>\n                               (v, w) \\<in> (tree_edges s')\\<^sup>+\n 3. \\<And>s s' u v e c b.\n       \\<lbrakk>\\<forall>v\\<in>dom (discovered s).\n                   \\<forall>w\\<in>dom (finished s).\n                      \\<delta> s v < \\<delta> s w \\<and>\n                      (v \\<notin> dom (finished s) \\<or>\n                       \\<phi> s w < \\<phi> s v) \\<longrightarrow>\n                      (v, w) \\<in> (tree_edges s)\\<^sup>+;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); u = hd (stack s);\n        cross_edges s \\<subseteq> c; back_edges s \\<subseteq> b;\n        s' = s\n        \\<lparr>pending := pending s - {(u, v)}, state.more := e,\n           cross_edges := c, back_edges := b\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>v\\<in>dom (discovered s').\n                            \\<forall>w\\<in>dom (finished s').\n                               \\<delta> s' v < \\<delta> s' w \\<and>\n                               (v \\<notin> dom (finished s') \\<or>\n                                \\<phi> s' w < \\<phi> s' v) \\<longrightarrow>\n                               (v, w) \\<in> (tree_edges s')\\<^sup>+", "then"], ["proof (chain)\npicking this:\n  \\<forall>v\\<in>dom (discovered s).\n     \\<forall>w\\<in>dom (finished s).\n        \\<delta> s v < \\<delta> s w \\<and>\n        (v \\<notin> dom (finished s) \\<or>\n         \\<phi> s w < \\<phi> s v) \\<longrightarrow>\n        (v, w) \\<in> (tree_edges s)\\<^sup>+\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s = []\n  v0 \\<notin> dom (discovered s)\n  v0 \\<in> V0\n  s' = new_root v0 s\\<lparr>state.more := e_\\<rparr>", "interpret DFS_invar where s=s"], ["proof (prove)\nusing this:\n  \\<forall>v\\<in>dom (discovered s).\n     \\<forall>w\\<in>dom (finished s).\n        \\<delta> s v < \\<delta> s w \\<and>\n        (v \\<notin> dom (finished s) \\<or>\n         \\<phi> s w < \\<phi> s v) \\<longrightarrow>\n        (v, w) \\<in> (tree_edges s)\\<^sup>+\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s = []\n  v0 \\<notin> dom (discovered s)\n  v0 \\<in> V0\n  s' = new_root v0 s\\<lparr>state.more := e_\\<rparr>\n\ngoal (1 subgoal):\n 1. DFS_invar G param s", "by simp"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>e.\n       \\<forall>v\\<in>dom (discovered (empty_state e)).\n          \\<forall>w\\<in>dom (finished (empty_state e)).\n             \\<delta> (empty_state e) v < \\<delta> (empty_state e) w \\<and>\n             (v \\<notin> dom (finished (empty_state e)) \\<or>\n              \\<phi> (empty_state e) w\n              < \\<phi> (empty_state e) v) \\<longrightarrow>\n             (v, w) \\<in> (tree_edges (empty_state e))\\<^sup>+\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>\\<forall>v\\<in>dom (discovered s).\n                   \\<forall>w\\<in>dom (finished s).\n                      \\<delta> s v < \\<delta> s w \\<and>\n                      (v \\<notin> dom (finished s) \\<or>\n                       \\<phi> s w < \\<phi> s v) \\<longrightarrow>\n                      (v, w) \\<in> (tree_edges s)\\<^sup>+;\n        cond s; DFS_invar G param s; DFS_invar G param s'; stack s = [];\n        v0 \\<notin> dom (discovered s); v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>v\\<in>dom (discovered s').\n                            \\<forall>w\\<in>dom (finished s').\n                               \\<delta> s' v < \\<delta> s' w \\<and>\n                               (v \\<notin> dom (finished s') \\<or>\n                                \\<phi> s' w < \\<phi> s' v) \\<longrightarrow>\n                               (v, w) \\<in> (tree_edges s')\\<^sup>+\n 3. \\<And>s s' u v e c b.\n       \\<lbrakk>\\<forall>v\\<in>dom (discovered s).\n                   \\<forall>w\\<in>dom (finished s).\n                      \\<delta> s v < \\<delta> s w \\<and>\n                      (v \\<notin> dom (finished s) \\<or>\n                       \\<phi> s w < \\<phi> s v) \\<longrightarrow>\n                      (v, w) \\<in> (tree_edges s)\\<^sup>+;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); u = hd (stack s);\n        cross_edges s \\<subseteq> c; back_edges s \\<subseteq> b;\n        s' = s\n        \\<lparr>pending := pending s - {(u, v)}, state.more := e,\n           cross_edges := c, back_edges := b\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>v\\<in>dom (discovered s').\n                            \\<forall>w\\<in>dom (finished s').\n                               \\<delta> s' v < \\<delta> s' w \\<and>\n                               (v \\<notin> dom (finished s') \\<or>\n                                \\<phi> s' w < \\<phi> s' v) \\<longrightarrow>\n                               (v, w) \\<in> (tree_edges s')\\<^sup>+", "from new_root finished_discovered"], ["proof (chain)\npicking this:\n  \\<forall>v\\<in>dom (discovered s).\n     \\<forall>w\\<in>dom (finished s).\n        \\<delta> s v < \\<delta> s w \\<and>\n        (v \\<notin> dom (finished s) \\<or>\n         \\<phi> s w < \\<phi> s v) \\<longrightarrow>\n        (v, w) \\<in> (tree_edges s)\\<^sup>+\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s = []\n  v0 \\<notin> dom (discovered s)\n  v0 \\<in> V0\n  s' = new_root v0 s\\<lparr>state.more := e_\\<rparr>\n  dom (finished s) \\<subseteq> dom (discovered s)", "have \"v0 \\<notin> dom (finished s)\""], ["proof (prove)\nusing this:\n  \\<forall>v\\<in>dom (discovered s).\n     \\<forall>w\\<in>dom (finished s).\n        \\<delta> s v < \\<delta> s w \\<and>\n        (v \\<notin> dom (finished s) \\<or>\n         \\<phi> s w < \\<phi> s v) \\<longrightarrow>\n        (v, w) \\<in> (tree_edges s)\\<^sup>+\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s = []\n  v0 \\<notin> dom (discovered s)\n  v0 \\<in> V0\n  s' = new_root v0 s\\<lparr>state.more := e_\\<rparr>\n  dom (finished s) \\<subseteq> dom (discovered s)\n\ngoal (1 subgoal):\n 1. v0 \\<notin> dom (finished s)", "by auto"], ["proof (state)\nthis:\n  v0 \\<notin> dom (finished s)\n\ngoal (3 subgoals):\n 1. \\<And>e.\n       \\<forall>v\\<in>dom (discovered (empty_state e)).\n          \\<forall>w\\<in>dom (finished (empty_state e)).\n             \\<delta> (empty_state e) v < \\<delta> (empty_state e) w \\<and>\n             (v \\<notin> dom (finished (empty_state e)) \\<or>\n              \\<phi> (empty_state e) w\n              < \\<phi> (empty_state e) v) \\<longrightarrow>\n             (v, w) \\<in> (tree_edges (empty_state e))\\<^sup>+\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>\\<forall>v\\<in>dom (discovered s).\n                   \\<forall>w\\<in>dom (finished s).\n                      \\<delta> s v < \\<delta> s w \\<and>\n                      (v \\<notin> dom (finished s) \\<or>\n                       \\<phi> s w < \\<phi> s v) \\<longrightarrow>\n                      (v, w) \\<in> (tree_edges s)\\<^sup>+;\n        cond s; DFS_invar G param s; DFS_invar G param s'; stack s = [];\n        v0 \\<notin> dom (discovered s); v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>v\\<in>dom (discovered s').\n                            \\<forall>w\\<in>dom (finished s').\n                               \\<delta> s' v < \\<delta> s' w \\<and>\n                               (v \\<notin> dom (finished s') \\<or>\n                                \\<phi> s' w < \\<phi> s' v) \\<longrightarrow>\n                               (v, w) \\<in> (tree_edges s')\\<^sup>+\n 3. \\<And>s s' u v e c b.\n       \\<lbrakk>\\<forall>v\\<in>dom (discovered s).\n                   \\<forall>w\\<in>dom (finished s).\n                      \\<delta> s v < \\<delta> s w \\<and>\n                      (v \\<notin> dom (finished s) \\<or>\n                       \\<phi> s w < \\<phi> s v) \\<longrightarrow>\n                      (v, w) \\<in> (tree_edges s)\\<^sup>+;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); u = hd (stack s);\n        cross_edges s \\<subseteq> c; back_edges s \\<subseteq> b;\n        s' = s\n        \\<lparr>pending := pending s - {(u, v)}, state.more := e,\n           cross_edges := c, back_edges := b\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>v\\<in>dom (discovered s').\n                            \\<forall>w\\<in>dom (finished s').\n                               \\<delta> s' v < \\<delta> s' w \\<and>\n                               (v \\<notin> dom (finished s') \\<or>\n                                \\<phi> s' w < \\<phi> s' v) \\<longrightarrow>\n                               (v, w) \\<in> (tree_edges s')\\<^sup>+", "moreover"], ["proof (state)\nthis:\n  v0 \\<notin> dom (finished s)\n\ngoal (3 subgoals):\n 1. \\<And>e.\n       \\<forall>v\\<in>dom (discovered (empty_state e)).\n          \\<forall>w\\<in>dom (finished (empty_state e)).\n             \\<delta> (empty_state e) v < \\<delta> (empty_state e) w \\<and>\n             (v \\<notin> dom (finished (empty_state e)) \\<or>\n              \\<phi> (empty_state e) w\n              < \\<phi> (empty_state e) v) \\<longrightarrow>\n             (v, w) \\<in> (tree_edges (empty_state e))\\<^sup>+\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>\\<forall>v\\<in>dom (discovered s).\n                   \\<forall>w\\<in>dom (finished s).\n                      \\<delta> s v < \\<delta> s w \\<and>\n                      (v \\<notin> dom (finished s) \\<or>\n                       \\<phi> s w < \\<phi> s v) \\<longrightarrow>\n                      (v, w) \\<in> (tree_edges s)\\<^sup>+;\n        cond s; DFS_invar G param s; DFS_invar G param s'; stack s = [];\n        v0 \\<notin> dom (discovered s); v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>v\\<in>dom (discovered s').\n                            \\<forall>w\\<in>dom (finished s').\n                               \\<delta> s' v < \\<delta> s' w \\<and>\n                               (v \\<notin> dom (finished s') \\<or>\n                                \\<phi> s' w < \\<phi> s' v) \\<longrightarrow>\n                               (v, w) \\<in> (tree_edges s')\\<^sup>+\n 3. \\<And>s s' u v e c b.\n       \\<lbrakk>\\<forall>v\\<in>dom (discovered s).\n                   \\<forall>w\\<in>dom (finished s).\n                      \\<delta> s v < \\<delta> s w \\<and>\n                      (v \\<notin> dom (finished s) \\<or>\n                       \\<phi> s w < \\<phi> s v) \\<longrightarrow>\n                      (v, w) \\<in> (tree_edges s)\\<^sup>+;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); u = hd (stack s);\n        cross_edges s \\<subseteq> c; back_edges s \\<subseteq> b;\n        s' = s\n        \\<lparr>pending := pending s - {(u, v)}, state.more := e,\n           cross_edges := c, back_edges := b\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>v\\<in>dom (discovered s').\n                            \\<forall>w\\<in>dom (finished s').\n                               \\<delta> s' v < \\<delta> s' w \\<and>\n                               (v \\<notin> dom (finished s') \\<or>\n                                \\<phi> s' w < \\<phi> s' v) \\<longrightarrow>\n                               (v, w) \\<in> (tree_edges s')\\<^sup>+", "note timing_less_counter finished_discovered"], ["proof (state)\nthis:\n  ?v \\<in> dom (discovered s) \\<Longrightarrow> \\<delta> s ?v < counter s\n  ?v \\<in> dom (finished s) \\<Longrightarrow> \\<phi> s ?v < counter s\n  dom (finished s) \\<subseteq> dom (discovered s)\n\ngoal (3 subgoals):\n 1. \\<And>e.\n       \\<forall>v\\<in>dom (discovered (empty_state e)).\n          \\<forall>w\\<in>dom (finished (empty_state e)).\n             \\<delta> (empty_state e) v < \\<delta> (empty_state e) w \\<and>\n             (v \\<notin> dom (finished (empty_state e)) \\<or>\n              \\<phi> (empty_state e) w\n              < \\<phi> (empty_state e) v) \\<longrightarrow>\n             (v, w) \\<in> (tree_edges (empty_state e))\\<^sup>+\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>\\<forall>v\\<in>dom (discovered s).\n                   \\<forall>w\\<in>dom (finished s).\n                      \\<delta> s v < \\<delta> s w \\<and>\n                      (v \\<notin> dom (finished s) \\<or>\n                       \\<phi> s w < \\<phi> s v) \\<longrightarrow>\n                      (v, w) \\<in> (tree_edges s)\\<^sup>+;\n        cond s; DFS_invar G param s; DFS_invar G param s'; stack s = [];\n        v0 \\<notin> dom (discovered s); v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>v\\<in>dom (discovered s').\n                            \\<forall>w\\<in>dom (finished s').\n                               \\<delta> s' v < \\<delta> s' w \\<and>\n                               (v \\<notin> dom (finished s') \\<or>\n                                \\<phi> s' w < \\<phi> s' v) \\<longrightarrow>\n                               (v, w) \\<in> (tree_edges s')\\<^sup>+\n 3. \\<And>s s' u v e c b.\n       \\<lbrakk>\\<forall>v\\<in>dom (discovered s).\n                   \\<forall>w\\<in>dom (finished s).\n                      \\<delta> s v < \\<delta> s w \\<and>\n                      (v \\<notin> dom (finished s) \\<or>\n                       \\<phi> s w < \\<phi> s v) \\<longrightarrow>\n                      (v, w) \\<in> (tree_edges s)\\<^sup>+;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); u = hd (stack s);\n        cross_edges s \\<subseteq> c; back_edges s \\<subseteq> b;\n        s' = s\n        \\<lparr>pending := pending s - {(u, v)}, state.more := e,\n           cross_edges := c, back_edges := b\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>v\\<in>dom (discovered s').\n                            \\<forall>w\\<in>dom (finished s').\n                               \\<delta> s' v < \\<delta> s' w \\<and>\n                               (v \\<notin> dom (finished s') \\<or>\n                                \\<phi> s' w < \\<phi> s' v) \\<longrightarrow>\n                               (v, w) \\<in> (tree_edges s')\\<^sup>+", "ultimately"], ["proof (chain)\npicking this:\n  v0 \\<notin> dom (finished s)\n  ?v \\<in> dom (discovered s) \\<Longrightarrow> \\<delta> s ?v < counter s\n  ?v \\<in> dom (finished s) \\<Longrightarrow> \\<phi> s ?v < counter s\n  dom (finished s) \\<subseteq> dom (discovered s)", "show ?case"], ["proof (prove)\nusing this:\n  v0 \\<notin> dom (finished s)\n  ?v \\<in> dom (discovered s) \\<Longrightarrow> \\<delta> s ?v < counter s\n  ?v \\<in> dom (finished s) \\<Longrightarrow> \\<phi> s ?v < counter s\n  dom (finished s) \\<subseteq> dom (discovered s)\n\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>dom (discovered s').\n       \\<forall>w\\<in>dom (finished s').\n          \\<delta> s' v < \\<delta> s' w \\<and>\n          (v \\<notin> dom (finished s') \\<or>\n           \\<phi> s' w < \\<phi> s' v) \\<longrightarrow>\n          (v, w) \\<in> (tree_edges s')\\<^sup>+", "using new_root"], ["proof (prove)\nusing this:\n  v0 \\<notin> dom (finished s)\n  ?v \\<in> dom (discovered s) \\<Longrightarrow> \\<delta> s ?v < counter s\n  ?v \\<in> dom (finished s) \\<Longrightarrow> \\<phi> s ?v < counter s\n  dom (finished s) \\<subseteq> dom (discovered s)\n  \\<forall>v\\<in>dom (discovered s).\n     \\<forall>w\\<in>dom (finished s).\n        \\<delta> s v < \\<delta> s w \\<and>\n        (v \\<notin> dom (finished s) \\<or>\n         \\<phi> s w < \\<phi> s v) \\<longrightarrow>\n        (v, w) \\<in> (tree_edges s)\\<^sup>+\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s = []\n  v0 \\<notin> dom (discovered s)\n  v0 \\<in> V0\n  s' = new_root v0 s\\<lparr>state.more := e_\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>dom (discovered s').\n       \\<forall>w\\<in>dom (finished s').\n          \\<delta> s' v < \\<delta> s' w \\<and>\n          (v \\<notin> dom (finished s') \\<or>\n           \\<phi> s' w < \\<phi> s' v) \\<longrightarrow>\n          (v, w) \\<in> (tree_edges s')\\<^sup>+", "by clarsimp force"], ["proof (state)\nthis:\n  \\<forall>v\\<in>dom (discovered s').\n     \\<forall>w\\<in>dom (finished s').\n        \\<delta> s' v < \\<delta> s' w \\<and>\n        (v \\<notin> dom (finished s') \\<or>\n         \\<phi> s' w < \\<phi> s' v) \\<longrightarrow>\n        (v, w) \\<in> (tree_edges s')\\<^sup>+\n\ngoal (2 subgoals):\n 1. \\<And>e.\n       \\<forall>v\\<in>dom (discovered (empty_state e)).\n          \\<forall>w\\<in>dom (finished (empty_state e)).\n             \\<delta> (empty_state e) v < \\<delta> (empty_state e) w \\<and>\n             (v \\<notin> dom (finished (empty_state e)) \\<or>\n              \\<phi> (empty_state e) w\n              < \\<phi> (empty_state e) v) \\<longrightarrow>\n             (v, w) \\<in> (tree_edges (empty_state e))\\<^sup>+\n 2. \\<And>s s' u v e c b.\n       \\<lbrakk>\\<forall>v\\<in>dom (discovered s).\n                   \\<forall>w\\<in>dom (finished s).\n                      \\<delta> s v < \\<delta> s w \\<and>\n                      (v \\<notin> dom (finished s) \\<or>\n                       \\<phi> s w < \\<phi> s v) \\<longrightarrow>\n                      (v, w) \\<in> (tree_edges s)\\<^sup>+;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); u = hd (stack s);\n        cross_edges s \\<subseteq> c; back_edges s \\<subseteq> b;\n        s' = s\n        \\<lparr>pending := pending s - {(u, v)}, state.more := e,\n           cross_edges := c, back_edges := b\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>v\\<in>dom (discovered s').\n                            \\<forall>w\\<in>dom (finished s').\n                               \\<delta> s' v < \\<delta> s' w \\<and>\n                               (v \\<notin> dom (finished s') \\<or>\n                                \\<phi> s' w < \\<phi> s' v) \\<longrightarrow>\n                               (v, w) \\<in> (tree_edges s')\\<^sup>+", "qed simp_all"], ["", "end"], ["", "end"], ["", "context DFS_invar begin"], ["", "context begin"], ["", "interpretation timing_syntax"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemmas s_paren_imp_tree_reach =\n    paren_imp_tree_reach[THEN make_invar_thm]"], ["", "lemma parenthesis_impl_tree_path_not_finished:\n    assumes \"v \\<in> dom (discovered s)\"\n    and \"w \\<in> dom (finished s)\"\n    and \"\\<delta> s v < \\<delta> s w\"\n    and \"v \\<notin> dom (finished s)\"\n    shows \"(v,w) \\<in> (tree_edges s)\\<^sup>+\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (v, w) \\<in> (tree_edges s)\\<^sup>+", "using s_paren_imp_tree_reach assms"], ["proof (prove)\nusing this:\n  paren_imp_tree_reach s\n  v \\<in> dom (discovered s)\n  w \\<in> dom (finished s)\n  \\<delta> s v < \\<delta> s w\n  v \\<notin> dom (finished s)\n\ngoal (1 subgoal):\n 1. (v, w) \\<in> (tree_edges s)\\<^sup>+", "by (auto simp add: paren_imp_tree_reach_def)"], ["", "lemma parenthesis_impl_tree_path:\n    assumes \"v \\<in> dom (finished s)\" \"w \\<in> dom (finished s)\"\n    and \"\\<delta> s v < \\<delta> s w\" \"\\<phi> s v > \\<phi> s w\"\n    shows \"(v,w) \\<in> (tree_edges s)\\<^sup>+\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (v, w) \\<in> (tree_edges s)\\<^sup>+", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (v, w) \\<in> (tree_edges s)\\<^sup>+", "from assms(1)"], ["proof (chain)\npicking this:\n  v \\<in> dom (finished s)", "have \"v \\<in> dom (discovered s)\""], ["proof (prove)\nusing this:\n  v \\<in> dom (finished s)\n\ngoal (1 subgoal):\n 1. v \\<in> dom (discovered s)", "using finished_discovered"], ["proof (prove)\nusing this:\n  v \\<in> dom (finished s)\n  dom (finished s) \\<subseteq> dom (discovered s)\n\ngoal (1 subgoal):\n 1. v \\<in> dom (discovered s)", "by blast"], ["proof (state)\nthis:\n  v \\<in> dom (discovered s)\n\ngoal (1 subgoal):\n 1. (v, w) \\<in> (tree_edges s)\\<^sup>+", "with assms"], ["proof (chain)\npicking this:\n  v \\<in> dom (finished s)\n  w \\<in> dom (finished s)\n  \\<delta> s v < \\<delta> s w\n  \\<phi> s w < \\<phi> s v\n  v \\<in> dom (discovered s)", "show ?thesis"], ["proof (prove)\nusing this:\n  v \\<in> dom (finished s)\n  w \\<in> dom (finished s)\n  \\<delta> s v < \\<delta> s w\n  \\<phi> s w < \\<phi> s v\n  v \\<in> dom (discovered s)\n\ngoal (1 subgoal):\n 1. (v, w) \\<in> (tree_edges s)\\<^sup>+", "using s_paren_imp_tree_reach assms"], ["proof (prove)\nusing this:\n  v \\<in> dom (finished s)\n  w \\<in> dom (finished s)\n  \\<delta> s v < \\<delta> s w\n  \\<phi> s w < \\<phi> s v\n  v \\<in> dom (discovered s)\n  paren_imp_tree_reach s\n  v \\<in> dom (finished s)\n  w \\<in> dom (finished s)\n  \\<delta> s v < \\<delta> s w\n  \\<phi> s w < \\<phi> s v\n\ngoal (1 subgoal):\n 1. (v, w) \\<in> (tree_edges s)\\<^sup>+", "by (auto simp add: paren_imp_tree_reach_def)"], ["proof (state)\nthis:\n  (v, w) \\<in> (tree_edges s)\\<^sup>+\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma tree_path_iff_parenthesis:\n    assumes \"v \\<in> dom (finished s)\" \"w \\<in> dom (finished s)\"\n    shows \"(v,w) \\<in> (tree_edges s)\\<^sup>+ \\<longleftrightarrow> \\<delta> s v < \\<delta> s w \\<and> \\<phi> s v > \\<phi> s w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((v, w) \\<in> (tree_edges s)\\<^sup>+) =\n    (\\<delta> s v < \\<delta> s w \\<and> \\<phi> s w < \\<phi> s v)", "using assms"], ["proof (prove)\nusing this:\n  v \\<in> dom (finished s)\n  w \\<in> dom (finished s)\n\ngoal (1 subgoal):\n 1. ((v, w) \\<in> (tree_edges s)\\<^sup>+) =\n    (\\<delta> s v < \\<delta> s w \\<and> \\<phi> s w < \\<phi> s v)", "by (metis parenthesis_impl_tree_path tree_path_impl_parenthesis)"], ["", "lemma no_pending_succ_impl_path_in_tree:\n    assumes v: \"v \\<in> dom (discovered s)\" \"pending s `` {v} = {}\"\n    and w: \"w \\<in> succ v\"\n    and \\<delta>: \"\\<delta> s v < \\<delta> s w\"\n    shows \"(v,w) \\<in> (tree_edges s)\\<^sup>+\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (v, w) \\<in> (tree_edges s)\\<^sup>+", "proof (cases \"v \\<in> dom (finished s)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. v \\<in> dom (finished s) \\<Longrightarrow>\n    (v, w) \\<in> (tree_edges s)\\<^sup>+\n 2. v \\<notin> dom (finished s) \\<Longrightarrow>\n    (v, w) \\<in> (tree_edges s)\\<^sup>+", "case True"], ["proof (state)\nthis:\n  v \\<in> dom (finished s)\n\ngoal (2 subgoals):\n 1. v \\<in> dom (finished s) \\<Longrightarrow>\n    (v, w) \\<in> (tree_edges s)\\<^sup>+\n 2. v \\<notin> dom (finished s) \\<Longrightarrow>\n    (v, w) \\<in> (tree_edges s)\\<^sup>+", "with assms assms"], ["proof (chain)\npicking this:\n  v \\<in> dom (discovered s)\n  pending s `` {v} = {}\n  w \\<in> E `` {v}\n  \\<delta> s v < \\<delta> s w\n  v \\<in> dom (discovered s)\n  pending s `` {v} = {}\n  w \\<in> E `` {v}\n  \\<delta> s v < \\<delta> s w\n  v \\<in> dom (finished s)", "have \"\\<delta> s w < \\<phi> s v\" \"w \\<in> dom (discovered s)\""], ["proof (prove)\nusing this:\n  v \\<in> dom (discovered s)\n  pending s `` {v} = {}\n  w \\<in> E `` {v}\n  \\<delta> s v < \\<delta> s w\n  v \\<in> dom (discovered s)\n  pending s `` {v} = {}\n  w \\<in> E `` {v}\n  \\<delta> s v < \\<delta> s w\n  v \\<in> dom (finished s)\n\ngoal (1 subgoal):\n 1. \\<delta> s w < \\<phi> s v &&& w \\<in> dom (discovered s)", "using finished_succ_fin finished_imp_succ_discovered"], ["proof (prove)\nusing this:\n  v \\<in> dom (discovered s)\n  pending s `` {v} = {}\n  w \\<in> E `` {v}\n  \\<delta> s v < \\<delta> s w\n  v \\<in> dom (discovered s)\n  pending s `` {v} = {}\n  w \\<in> E `` {v}\n  \\<delta> s v < \\<delta> s w\n  v \\<in> dom (finished s)\n  \\<lbrakk>?v \\<in> dom (finished s); ?w \\<in> E `` {?v}\\<rbrakk>\n  \\<Longrightarrow> \\<delta> s ?w < \\<phi> s ?v\n  \\<lbrakk>?v \\<in> dom (finished s); ?w \\<in> E `` {?v}\\<rbrakk>\n  \\<Longrightarrow> ?w \\<in> dom (discovered s)\n\ngoal (1 subgoal):\n 1. \\<delta> s w < \\<phi> s v &&& w \\<in> dom (discovered s)", "by simp_all"], ["proof (state)\nthis:\n  \\<delta> s w < \\<phi> s v\n  w \\<in> dom (discovered s)\n\ngoal (2 subgoals):\n 1. v \\<in> dom (finished s) \\<Longrightarrow>\n    (v, w) \\<in> (tree_edges s)\\<^sup>+\n 2. v \\<notin> dom (finished s) \\<Longrightarrow>\n    (v, w) \\<in> (tree_edges s)\\<^sup>+", "with True \\<delta>"], ["proof (chain)\npicking this:\n  v \\<in> dom (finished s)\n  \\<delta> s v < \\<delta> s w\n  \\<delta> s w < \\<phi> s v\n  w \\<in> dom (discovered s)", "show ?thesis"], ["proof (prove)\nusing this:\n  v \\<in> dom (finished s)\n  \\<delta> s v < \\<delta> s w\n  \\<delta> s w < \\<phi> s v\n  w \\<in> dom (discovered s)\n\ngoal (1 subgoal):\n 1. (v, w) \\<in> (tree_edges s)\\<^sup>+", "using parenthesis_contained parenthesis_impl_tree_path"], ["proof (prove)\nusing this:\n  v \\<in> dom (finished s)\n  \\<delta> s v < \\<delta> s w\n  \\<delta> s w < \\<phi> s v\n  w \\<in> dom (discovered s)\n  \\<lbrakk>?v \\<in> dom (finished s); ?w \\<in> dom (discovered s);\n   \\<delta> s ?v < \\<delta> s ?w; \\<delta> s ?w < \\<phi> s ?v\\<rbrakk>\n  \\<Longrightarrow> ?w \\<in> dom (finished s) \\<and>\n                    \\<phi> s ?w < \\<phi> s ?v\n  \\<lbrakk>?v \\<in> dom (finished s); ?w \\<in> dom (finished s);\n   \\<delta> s ?v < \\<delta> s ?w; \\<phi> s ?w < \\<phi> s ?v\\<rbrakk>\n  \\<Longrightarrow> (?v, ?w) \\<in> (tree_edges s)\\<^sup>+\n\ngoal (1 subgoal):\n 1. (v, w) \\<in> (tree_edges s)\\<^sup>+", "by blast"], ["proof (state)\nthis:\n  (v, w) \\<in> (tree_edges s)\\<^sup>+\n\ngoal (1 subgoal):\n 1. v \\<notin> dom (finished s) \\<Longrightarrow>\n    (v, w) \\<in> (tree_edges s)\\<^sup>+", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. v \\<notin> dom (finished s) \\<Longrightarrow>\n    (v, w) \\<in> (tree_edges s)\\<^sup>+", "case False"], ["proof (state)\nthis:\n  v \\<notin> dom (finished s)\n\ngoal (1 subgoal):\n 1. v \\<notin> dom (finished s) \\<Longrightarrow>\n    (v, w) \\<in> (tree_edges s)\\<^sup>+", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (v, w) \\<in> (tree_edges s)\\<^sup>+", "proof (cases \"w \\<in> dom (finished s)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. w \\<in> dom (finished s) \\<Longrightarrow>\n    (v, w) \\<in> (tree_edges s)\\<^sup>+\n 2. w \\<notin> dom (finished s) \\<Longrightarrow>\n    (v, w) \\<in> (tree_edges s)\\<^sup>+", "case True"], ["proof (state)\nthis:\n  w \\<in> dom (finished s)\n\ngoal (2 subgoals):\n 1. w \\<in> dom (finished s) \\<Longrightarrow>\n    (v, w) \\<in> (tree_edges s)\\<^sup>+\n 2. w \\<notin> dom (finished s) \\<Longrightarrow>\n    (v, w) \\<in> (tree_edges s)\\<^sup>+", "with False v \\<delta>"], ["proof (chain)\npicking this:\n  v \\<notin> dom (finished s)\n  v \\<in> dom (discovered s)\n  pending s `` {v} = {}\n  \\<delta> s v < \\<delta> s w\n  w \\<in> dom (finished s)", "show ?thesis"], ["proof (prove)\nusing this:\n  v \\<notin> dom (finished s)\n  v \\<in> dom (discovered s)\n  pending s `` {v} = {}\n  \\<delta> s v < \\<delta> s w\n  w \\<in> dom (finished s)\n\ngoal (1 subgoal):\n 1. (v, w) \\<in> (tree_edges s)\\<^sup>+", "by (simp add: parenthesis_impl_tree_path_not_finished)"], ["proof (state)\nthis:\n  (v, w) \\<in> (tree_edges s)\\<^sup>+\n\ngoal (1 subgoal):\n 1. w \\<notin> dom (finished s) \\<Longrightarrow>\n    (v, w) \\<in> (tree_edges s)\\<^sup>+", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. w \\<notin> dom (finished s) \\<Longrightarrow>\n    (v, w) \\<in> (tree_edges s)\\<^sup>+", "case False"], ["proof (state)\nthis:\n  w \\<notin> dom (finished s)\n\ngoal (1 subgoal):\n 1. w \\<notin> dom (finished s) \\<Longrightarrow>\n    (v, w) \\<in> (tree_edges s)\\<^sup>+", "with \\<open>v \\<notin> dom (finished s)\\<close> no_pending_imp_succ_discovered v w"], ["proof (chain)\npicking this:\n  v \\<notin> dom (finished s)\n  \\<lbrakk>?u \\<in> dom (discovered s); pending s `` {?u} = {};\n   ?v \\<in> E `` {?u}\\<rbrakk>\n  \\<Longrightarrow> ?v \\<in> dom (discovered s)\n  v \\<in> dom (discovered s)\n  pending s `` {v} = {}\n  w \\<in> E `` {v}\n  w \\<notin> dom (finished s)", "have \n        \"v \\<in> set (stack s)\" \"w \\<in> set (stack s)\""], ["proof (prove)\nusing this:\n  v \\<notin> dom (finished s)\n  \\<lbrakk>?u \\<in> dom (discovered s); pending s `` {?u} = {};\n   ?v \\<in> E `` {?u}\\<rbrakk>\n  \\<Longrightarrow> ?v \\<in> dom (discovered s)\n  v \\<in> dom (discovered s)\n  pending s `` {v} = {}\n  w \\<in> E `` {v}\n  w \\<notin> dom (finished s)\n\ngoal (1 subgoal):\n 1. v \\<in> set (stack s) &&& w \\<in> set (stack s)", "by (simp_all add: stack_set_def)"], ["proof (state)\nthis:\n  v \\<in> set (stack s)\n  w \\<in> set (stack s)\n\ngoal (1 subgoal):\n 1. w \\<notin> dom (finished s) \\<Longrightarrow>\n    (v, w) \\<in> (tree_edges s)\\<^sup>+", "with on_stack_is_tree_path \\<delta>"], ["proof (chain)\npicking this:\n  \\<lbrakk>?x \\<in> set (stack s); ?y \\<in> set (stack s);\n   \\<delta> s ?x < \\<delta> s ?y\\<rbrakk>\n  \\<Longrightarrow> (?x, ?y) \\<in> (tree_edges s)\\<^sup>+\n  \\<delta> s v < \\<delta> s w\n  v \\<in> set (stack s)\n  w \\<in> set (stack s)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<in> set (stack s); ?y \\<in> set (stack s);\n   \\<delta> s ?x < \\<delta> s ?y\\<rbrakk>\n  \\<Longrightarrow> (?x, ?y) \\<in> (tree_edges s)\\<^sup>+\n  \\<delta> s v < \\<delta> s w\n  v \\<in> set (stack s)\n  w \\<in> set (stack s)\n\ngoal (1 subgoal):\n 1. (v, w) \\<in> (tree_edges s)\\<^sup>+", "by simp"], ["proof (state)\nthis:\n  (v, w) \\<in> (tree_edges s)\\<^sup>+\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (v, w) \\<in> (tree_edges s)\\<^sup>+\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma finished_succ_impl_path_in_tree:\n    assumes f:  \"v \\<in> dom (finished s)\"\n    and s: \"w \\<in> succ v\"\n    and \\<delta>: \"\\<delta> s v < \\<delta> s w\"\n    shows \"(v,w) \\<in> (tree_edges s)\\<^sup>+\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (v, w) \\<in> (tree_edges s)\\<^sup>+", "using no_pending_succ_impl_path_in_tree finished_no_pending finished_discovered"], ["proof (prove)\nusing this:\n  \\<lbrakk>?v \\<in> dom (discovered s); pending s `` {?v} = {};\n   ?w \\<in> E `` {?v}; \\<delta> s ?v < \\<delta> s ?w\\<rbrakk>\n  \\<Longrightarrow> (?v, ?w) \\<in> (tree_edges s)\\<^sup>+\n  ?v \\<in> dom (finished s) \\<Longrightarrow> pending s `` {?v} = {}\n  dom (finished s) \\<subseteq> dom (discovered s)\n\ngoal (1 subgoal):\n 1. (v, w) \\<in> (tree_edges s)\\<^sup>+", "using assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>?v \\<in> dom (discovered s); pending s `` {?v} = {};\n   ?w \\<in> E `` {?v}; \\<delta> s ?v < \\<delta> s ?w\\<rbrakk>\n  \\<Longrightarrow> (?v, ?w) \\<in> (tree_edges s)\\<^sup>+\n  ?v \\<in> dom (finished s) \\<Longrightarrow> pending s `` {?v} = {}\n  dom (finished s) \\<subseteq> dom (discovered s)\n  v \\<in> dom (finished s)\n  w \\<in> E `` {v}\n  \\<delta> s v < \\<delta> s w\n\ngoal (1 subgoal):\n 1. (v, w) \\<in> (tree_edges s)\\<^sup>+", "by blast"], ["", "end"], ["", "end"], ["", "subsubsection \\<open>Properties of Cross Edges\\<close>"], ["", "(* Cross Edges *)"], ["", "context param_DFS begin"], ["", "context begin"], ["", "interpretation timing_syntax"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma i_cross_edges_finished: \"is_invar (\\<lambda>s. \\<forall>(u,v)\\<in>cross_edges s. \n    v \\<in> dom (finished s) \\<and> (u \\<in> dom (finished s) \\<longrightarrow> \\<phi> s v < \\<phi> s u))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_invar\n     (\\<lambda>s.\n         \\<forall>(u, v)\\<in>cross_edges s.\n            v \\<in> dom (finished s) \\<and>\n            (u \\<in> dom (finished s) \\<longrightarrow>\n             \\<phi> s v < \\<phi> s u))", "proof (induction rule: is_invarI_full)"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>e.\n       \\<forall>(u, v)\\<in>cross_edges (empty_state e).\n          v \\<in> dom (finished (empty_state e)) \\<and>\n          (u \\<in> dom (finished (empty_state e)) \\<longrightarrow>\n           \\<phi> (empty_state e) v < \\<phi> (empty_state e) u)\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>\\<forall>(u, v)\\<in>cross_edges s.\n                   v \\<in> dom (finished s) \\<and>\n                   (u \\<in> dom (finished s) \\<longrightarrow>\n                    \\<phi> s v < \\<phi> s u);\n        cond s; DFS_invar G param s; DFS_invar G param s'; stack s = [];\n        v0 \\<notin> dom (discovered s); v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(u, v)\\<in>cross_edges s'.\n                            v \\<in> dom (finished s') \\<and>\n                            (u \\<in> dom (finished s') \\<longrightarrow>\n                             \\<phi> s' v < \\<phi> s' u)\n 3. \\<And>s s' u e.\n       \\<lbrakk>\\<forall>(u, v)\\<in>cross_edges s.\n                   v \\<in> dom (finished s) \\<and>\n                   (u \\<in> dom (finished s) \\<longrightarrow>\n                    \\<phi> s v < \\<phi> s u);\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; pending s `` {u} = {}; u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(u, v)\\<in>cross_edges s'.\n                            v \\<in> dom (finished s') \\<and>\n                            (u \\<in> dom (finished s') \\<longrightarrow>\n                             \\<phi> s' v < \\<phi> s' u)\n 4. \\<And>s s' u v e.\n       \\<lbrakk>\\<forall>(u, v)\\<in>cross_edges s.\n                   v \\<in> dom (finished s) \\<and>\n                   (u \\<in> dom (finished s) \\<longrightarrow>\n                    \\<phi> s v < \\<phi> s u);\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        u = hd (stack s);\n        s' =\n        cross_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(u, v)\\<in>cross_edges s'.\n                            v \\<in> dom (finished s') \\<and>\n                            (u \\<in> dom (finished s') \\<longrightarrow>\n                             \\<phi> s' v < \\<phi> s' u)\n 5. \\<And>s s' u v e.\n       \\<lbrakk>\\<forall>(u, v)\\<in>cross_edges s.\n                   v \\<in> dom (finished s) \\<and>\n                   (u \\<in> dom (finished s) \\<longrightarrow>\n                    \\<phi> s v < \\<phi> s u);\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        u = hd (stack s);\n        s' =\n        back_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(u, v)\\<in>cross_edges s'.\n                            v \\<in> dom (finished s') \\<and>\n                            (u \\<in> dom (finished s') \\<longrightarrow>\n                             \\<phi> s' v < \\<phi> s' u)\n 6. \\<And>s s' u v e.\n       \\<lbrakk>\\<forall>(u, v)\\<in>cross_edges s.\n                   v \\<in> dom (finished s) \\<and>\n                   (u \\<in> dom (finished s) \\<longrightarrow>\n                    \\<phi> s v < \\<phi> s u);\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(u, v)\\<in>cross_edges s'.\n                            v \\<in> dom (finished s') \\<and>\n                            (u \\<in> dom (finished s') \\<longrightarrow>\n                             \\<phi> s' v < \\<phi> s' u)", "case (finish s s' u e)"], ["proof (state)\nthis:\n  \\<forall>(u, v)\\<in>cross_edges s.\n     v \\<in> dom (finished s) \\<and>\n     (u \\<in> dom (finished s) \\<longrightarrow> \\<phi> s v < \\<phi> s u)\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s \\<noteq> []\n  pending s `` {u} = {}\n  u = hd (stack s)\n  s' = finish u s\\<lparr>state.more := e\\<rparr>\n\ngoal (6 subgoals):\n 1. \\<And>e.\n       \\<forall>(u, v)\\<in>cross_edges (empty_state e).\n          v \\<in> dom (finished (empty_state e)) \\<and>\n          (u \\<in> dom (finished (empty_state e)) \\<longrightarrow>\n           \\<phi> (empty_state e) v < \\<phi> (empty_state e) u)\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>\\<forall>(u, v)\\<in>cross_edges s.\n                   v \\<in> dom (finished s) \\<and>\n                   (u \\<in> dom (finished s) \\<longrightarrow>\n                    \\<phi> s v < \\<phi> s u);\n        cond s; DFS_invar G param s; DFS_invar G param s'; stack s = [];\n        v0 \\<notin> dom (discovered s); v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(u, v)\\<in>cross_edges s'.\n                            v \\<in> dom (finished s') \\<and>\n                            (u \\<in> dom (finished s') \\<longrightarrow>\n                             \\<phi> s' v < \\<phi> s' u)\n 3. \\<And>s s' u e.\n       \\<lbrakk>\\<forall>(u, v)\\<in>cross_edges s.\n                   v \\<in> dom (finished s) \\<and>\n                   (u \\<in> dom (finished s) \\<longrightarrow>\n                    \\<phi> s v < \\<phi> s u);\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; pending s `` {u} = {}; u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(u, v)\\<in>cross_edges s'.\n                            v \\<in> dom (finished s') \\<and>\n                            (u \\<in> dom (finished s') \\<longrightarrow>\n                             \\<phi> s' v < \\<phi> s' u)\n 4. \\<And>s s' u v e.\n       \\<lbrakk>\\<forall>(u, v)\\<in>cross_edges s.\n                   v \\<in> dom (finished s) \\<and>\n                   (u \\<in> dom (finished s) \\<longrightarrow>\n                    \\<phi> s v < \\<phi> s u);\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        u = hd (stack s);\n        s' =\n        cross_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(u, v)\\<in>cross_edges s'.\n                            v \\<in> dom (finished s') \\<and>\n                            (u \\<in> dom (finished s') \\<longrightarrow>\n                             \\<phi> s' v < \\<phi> s' u)\n 5. \\<And>s s' u v e.\n       \\<lbrakk>\\<forall>(u, v)\\<in>cross_edges s.\n                   v \\<in> dom (finished s) \\<and>\n                   (u \\<in> dom (finished s) \\<longrightarrow>\n                    \\<phi> s v < \\<phi> s u);\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        u = hd (stack s);\n        s' =\n        back_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(u, v)\\<in>cross_edges s'.\n                            v \\<in> dom (finished s') \\<and>\n                            (u \\<in> dom (finished s') \\<longrightarrow>\n                             \\<phi> s' v < \\<phi> s' u)\n 6. \\<And>s s' u v e.\n       \\<lbrakk>\\<forall>(u, v)\\<in>cross_edges s.\n                   v \\<in> dom (finished s) \\<and>\n                   (u \\<in> dom (finished s) \\<longrightarrow>\n                    \\<phi> s v < \\<phi> s u);\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(u, v)\\<in>cross_edges s'.\n                            v \\<in> dom (finished s') \\<and>\n                            (u \\<in> dom (finished s') \\<longrightarrow>\n                             \\<phi> s' v < \\<phi> s' u)", "interpret DFS_invar G param s"], ["proof (prove)\ngoal (1 subgoal):\n 1. DFS_invar G param s", "by fact"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>e.\n       \\<forall>(u, v)\\<in>cross_edges (empty_state e).\n          v \\<in> dom (finished (empty_state e)) \\<and>\n          (u \\<in> dom (finished (empty_state e)) \\<longrightarrow>\n           \\<phi> (empty_state e) v < \\<phi> (empty_state e) u)\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>\\<forall>(u, v)\\<in>cross_edges s.\n                   v \\<in> dom (finished s) \\<and>\n                   (u \\<in> dom (finished s) \\<longrightarrow>\n                    \\<phi> s v < \\<phi> s u);\n        cond s; DFS_invar G param s; DFS_invar G param s'; stack s = [];\n        v0 \\<notin> dom (discovered s); v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(u, v)\\<in>cross_edges s'.\n                            v \\<in> dom (finished s') \\<and>\n                            (u \\<in> dom (finished s') \\<longrightarrow>\n                             \\<phi> s' v < \\<phi> s' u)\n 3. \\<And>s s' u e.\n       \\<lbrakk>\\<forall>(u, v)\\<in>cross_edges s.\n                   v \\<in> dom (finished s) \\<and>\n                   (u \\<in> dom (finished s) \\<longrightarrow>\n                    \\<phi> s v < \\<phi> s u);\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; pending s `` {u} = {}; u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(u, v)\\<in>cross_edges s'.\n                            v \\<in> dom (finished s') \\<and>\n                            (u \\<in> dom (finished s') \\<longrightarrow>\n                             \\<phi> s' v < \\<phi> s' u)\n 4. \\<And>s s' u v e.\n       \\<lbrakk>\\<forall>(u, v)\\<in>cross_edges s.\n                   v \\<in> dom (finished s) \\<and>\n                   (u \\<in> dom (finished s) \\<longrightarrow>\n                    \\<phi> s v < \\<phi> s u);\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        u = hd (stack s);\n        s' =\n        cross_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(u, v)\\<in>cross_edges s'.\n                            v \\<in> dom (finished s') \\<and>\n                            (u \\<in> dom (finished s') \\<longrightarrow>\n                             \\<phi> s' v < \\<phi> s' u)\n 5. \\<And>s s' u v e.\n       \\<lbrakk>\\<forall>(u, v)\\<in>cross_edges s.\n                   v \\<in> dom (finished s) \\<and>\n                   (u \\<in> dom (finished s) \\<longrightarrow>\n                    \\<phi> s v < \\<phi> s u);\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        u = hd (stack s);\n        s' =\n        back_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(u, v)\\<in>cross_edges s'.\n                            v \\<in> dom (finished s') \\<and>\n                            (u \\<in> dom (finished s') \\<longrightarrow>\n                             \\<phi> s' v < \\<phi> s' u)\n 6. \\<And>s s' u v e.\n       \\<lbrakk>\\<forall>(u, v)\\<in>cross_edges s.\n                   v \\<in> dom (finished s) \\<and>\n                   (u \\<in> dom (finished s) \\<longrightarrow>\n                    \\<phi> s v < \\<phi> s u);\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(u, v)\\<in>cross_edges s'.\n                            v \\<in> dom (finished s') \\<and>\n                            (u \\<in> dom (finished s') \\<longrightarrow>\n                             \\<phi> s' v < \\<phi> s' u)", "from finish stack_not_finished"], ["proof (chain)\npicking this:\n  \\<forall>(u, v)\\<in>cross_edges s.\n     v \\<in> dom (finished s) \\<and>\n     (u \\<in> dom (finished s) \\<longrightarrow> \\<phi> s v < \\<phi> s u)\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s \\<noteq> []\n  pending s `` {u} = {}\n  u = hd (stack s)\n  s' = finish u s\\<lparr>state.more := e\\<rparr>\n  ?x \\<in> set (stack s) \\<Longrightarrow> ?x \\<notin> dom (finished s)", "have \"u \\<notin> dom (finished s)\""], ["proof (prove)\nusing this:\n  \\<forall>(u, v)\\<in>cross_edges s.\n     v \\<in> dom (finished s) \\<and>\n     (u \\<in> dom (finished s) \\<longrightarrow> \\<phi> s v < \\<phi> s u)\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s \\<noteq> []\n  pending s `` {u} = {}\n  u = hd (stack s)\n  s' = finish u s\\<lparr>state.more := e\\<rparr>\n  ?x \\<in> set (stack s) \\<Longrightarrow> ?x \\<notin> dom (finished s)\n\ngoal (1 subgoal):\n 1. u \\<notin> dom (finished s)", "by auto"], ["proof (state)\nthis:\n  u \\<notin> dom (finished s)\n\ngoal (6 subgoals):\n 1. \\<And>e.\n       \\<forall>(u, v)\\<in>cross_edges (empty_state e).\n          v \\<in> dom (finished (empty_state e)) \\<and>\n          (u \\<in> dom (finished (empty_state e)) \\<longrightarrow>\n           \\<phi> (empty_state e) v < \\<phi> (empty_state e) u)\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>\\<forall>(u, v)\\<in>cross_edges s.\n                   v \\<in> dom (finished s) \\<and>\n                   (u \\<in> dom (finished s) \\<longrightarrow>\n                    \\<phi> s v < \\<phi> s u);\n        cond s; DFS_invar G param s; DFS_invar G param s'; stack s = [];\n        v0 \\<notin> dom (discovered s); v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(u, v)\\<in>cross_edges s'.\n                            v \\<in> dom (finished s') \\<and>\n                            (u \\<in> dom (finished s') \\<longrightarrow>\n                             \\<phi> s' v < \\<phi> s' u)\n 3. \\<And>s s' u e.\n       \\<lbrakk>\\<forall>(u, v)\\<in>cross_edges s.\n                   v \\<in> dom (finished s) \\<and>\n                   (u \\<in> dom (finished s) \\<longrightarrow>\n                    \\<phi> s v < \\<phi> s u);\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; pending s `` {u} = {}; u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(u, v)\\<in>cross_edges s'.\n                            v \\<in> dom (finished s') \\<and>\n                            (u \\<in> dom (finished s') \\<longrightarrow>\n                             \\<phi> s' v < \\<phi> s' u)\n 4. \\<And>s s' u v e.\n       \\<lbrakk>\\<forall>(u, v)\\<in>cross_edges s.\n                   v \\<in> dom (finished s) \\<and>\n                   (u \\<in> dom (finished s) \\<longrightarrow>\n                    \\<phi> s v < \\<phi> s u);\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        u = hd (stack s);\n        s' =\n        cross_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(u, v)\\<in>cross_edges s'.\n                            v \\<in> dom (finished s') \\<and>\n                            (u \\<in> dom (finished s') \\<longrightarrow>\n                             \\<phi> s' v < \\<phi> s' u)\n 5. \\<And>s s' u v e.\n       \\<lbrakk>\\<forall>(u, v)\\<in>cross_edges s.\n                   v \\<in> dom (finished s) \\<and>\n                   (u \\<in> dom (finished s) \\<longrightarrow>\n                    \\<phi> s v < \\<phi> s u);\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        u = hd (stack s);\n        s' =\n        back_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(u, v)\\<in>cross_edges s'.\n                            v \\<in> dom (finished s') \\<and>\n                            (u \\<in> dom (finished s') \\<longrightarrow>\n                             \\<phi> s' v < \\<phi> s' u)\n 6. \\<And>s s' u v e.\n       \\<lbrakk>\\<forall>(u, v)\\<in>cross_edges s.\n                   v \\<in> dom (finished s) \\<and>\n                   (u \\<in> dom (finished s) \\<longrightarrow>\n                    \\<phi> s v < \\<phi> s u);\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(u, v)\\<in>cross_edges s'.\n                            v \\<in> dom (finished s') \\<and>\n                            (u \\<in> dom (finished s') \\<longrightarrow>\n                             \\<phi> s' v < \\<phi> s' u)", "with finish"], ["proof (chain)\npicking this:\n  \\<forall>(u, v)\\<in>cross_edges s.\n     v \\<in> dom (finished s) \\<and>\n     (u \\<in> dom (finished s) \\<longrightarrow> \\<phi> s v < \\<phi> s u)\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s \\<noteq> []\n  pending s `` {u} = {}\n  u = hd (stack s)\n  s' = finish u s\\<lparr>state.more := e\\<rparr>\n  u \\<notin> dom (finished s)", "show ?case"], ["proof (prove)\nusing this:\n  \\<forall>(u, v)\\<in>cross_edges s.\n     v \\<in> dom (finished s) \\<and>\n     (u \\<in> dom (finished s) \\<longrightarrow> \\<phi> s v < \\<phi> s u)\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s \\<noteq> []\n  pending s `` {u} = {}\n  u = hd (stack s)\n  s' = finish u s\\<lparr>state.more := e\\<rparr>\n  u \\<notin> dom (finished s)\n\ngoal (1 subgoal):\n 1. \\<forall>(u, v)\\<in>cross_edges s'.\n       v \\<in> dom (finished s') \\<and>\n       (u \\<in> dom (finished s') \\<longrightarrow>\n        \\<phi> s' v < \\<phi> s' u)", "by (auto intro: timing_less_counter)"], ["proof (state)\nthis:\n  \\<forall>(u, v)\\<in>cross_edges s'.\n     v \\<in> dom (finished s') \\<and>\n     (u \\<in> dom (finished s') \\<longrightarrow> \\<phi> s' v < \\<phi> s' u)\n\ngoal (5 subgoals):\n 1. \\<And>e.\n       \\<forall>(u, v)\\<in>cross_edges (empty_state e).\n          v \\<in> dom (finished (empty_state e)) \\<and>\n          (u \\<in> dom (finished (empty_state e)) \\<longrightarrow>\n           \\<phi> (empty_state e) v < \\<phi> (empty_state e) u)\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>\\<forall>(u, v)\\<in>cross_edges s.\n                   v \\<in> dom (finished s) \\<and>\n                   (u \\<in> dom (finished s) \\<longrightarrow>\n                    \\<phi> s v < \\<phi> s u);\n        cond s; DFS_invar G param s; DFS_invar G param s'; stack s = [];\n        v0 \\<notin> dom (discovered s); v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(u, v)\\<in>cross_edges s'.\n                            v \\<in> dom (finished s') \\<and>\n                            (u \\<in> dom (finished s') \\<longrightarrow>\n                             \\<phi> s' v < \\<phi> s' u)\n 3. \\<And>s s' u v e.\n       \\<lbrakk>\\<forall>(u, v)\\<in>cross_edges s.\n                   v \\<in> dom (finished s) \\<and>\n                   (u \\<in> dom (finished s) \\<longrightarrow>\n                    \\<phi> s v < \\<phi> s u);\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        u = hd (stack s);\n        s' =\n        cross_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(u, v)\\<in>cross_edges s'.\n                            v \\<in> dom (finished s') \\<and>\n                            (u \\<in> dom (finished s') \\<longrightarrow>\n                             \\<phi> s' v < \\<phi> s' u)\n 4. \\<And>s s' u v e.\n       \\<lbrakk>\\<forall>(u, v)\\<in>cross_edges s.\n                   v \\<in> dom (finished s) \\<and>\n                   (u \\<in> dom (finished s) \\<longrightarrow>\n                    \\<phi> s v < \\<phi> s u);\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        u = hd (stack s);\n        s' =\n        back_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(u, v)\\<in>cross_edges s'.\n                            v \\<in> dom (finished s') \\<and>\n                            (u \\<in> dom (finished s') \\<longrightarrow>\n                             \\<phi> s' v < \\<phi> s' u)\n 5. \\<And>s s' u v e.\n       \\<lbrakk>\\<forall>(u, v)\\<in>cross_edges s.\n                   v \\<in> dom (finished s) \\<and>\n                   (u \\<in> dom (finished s) \\<longrightarrow>\n                    \\<phi> s v < \\<phi> s u);\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(u, v)\\<in>cross_edges s'.\n                            v \\<in> dom (finished s') \\<and>\n                            (u \\<in> dom (finished s') \\<longrightarrow>\n                             \\<phi> s' v < \\<phi> s' u)", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>e.\n       \\<forall>(u, v)\\<in>cross_edges (empty_state e).\n          v \\<in> dom (finished (empty_state e)) \\<and>\n          (u \\<in> dom (finished (empty_state e)) \\<longrightarrow>\n           \\<phi> (empty_state e) v < \\<phi> (empty_state e) u)\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>\\<forall>(u, v)\\<in>cross_edges s.\n                   v \\<in> dom (finished s) \\<and>\n                   (u \\<in> dom (finished s) \\<longrightarrow>\n                    \\<phi> s v < \\<phi> s u);\n        cond s; DFS_invar G param s; DFS_invar G param s'; stack s = [];\n        v0 \\<notin> dom (discovered s); v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(u, v)\\<in>cross_edges s'.\n                            v \\<in> dom (finished s') \\<and>\n                            (u \\<in> dom (finished s') \\<longrightarrow>\n                             \\<phi> s' v < \\<phi> s' u)\n 3. \\<And>s s' u v e.\n       \\<lbrakk>\\<forall>(u, v)\\<in>cross_edges s.\n                   v \\<in> dom (finished s) \\<and>\n                   (u \\<in> dom (finished s) \\<longrightarrow>\n                    \\<phi> s v < \\<phi> s u);\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        u = hd (stack s);\n        s' =\n        cross_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(u, v)\\<in>cross_edges s'.\n                            v \\<in> dom (finished s') \\<and>\n                            (u \\<in> dom (finished s') \\<longrightarrow>\n                             \\<phi> s' v < \\<phi> s' u)\n 4. \\<And>s s' u v e.\n       \\<lbrakk>\\<forall>(u, v)\\<in>cross_edges s.\n                   v \\<in> dom (finished s) \\<and>\n                   (u \\<in> dom (finished s) \\<longrightarrow>\n                    \\<phi> s v < \\<phi> s u);\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        u = hd (stack s);\n        s' =\n        back_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(u, v)\\<in>cross_edges s'.\n                            v \\<in> dom (finished s') \\<and>\n                            (u \\<in> dom (finished s') \\<longrightarrow>\n                             \\<phi> s' v < \\<phi> s' u)\n 5. \\<And>s s' u v e.\n       \\<lbrakk>\\<forall>(u, v)\\<in>cross_edges s.\n                   v \\<in> dom (finished s) \\<and>\n                   (u \\<in> dom (finished s) \\<longrightarrow>\n                    \\<phi> s v < \\<phi> s u);\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(u, v)\\<in>cross_edges s'.\n                            v \\<in> dom (finished s') \\<and>\n                            (u \\<in> dom (finished s') \\<longrightarrow>\n                             \\<phi> s' v < \\<phi> s' u)", "case (cross_edge s s' u v e)"], ["proof (state)\nthis:\n  \\<forall>(u, v)\\<in>cross_edges s.\n     v \\<in> dom (finished s) \\<and>\n     (u \\<in> dom (finished s) \\<longrightarrow> \\<phi> s v < \\<phi> s u)\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s \\<noteq> []\n  v \\<in> pending s `` {u}\n  v \\<in> dom (discovered s)\n  v \\<in> dom (finished s)\n  u = hd (stack s)\n  s' = cross_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n  \\<lparr>state.more := e\\<rparr>\n\ngoal (5 subgoals):\n 1. \\<And>e.\n       \\<forall>(u, v)\\<in>cross_edges (empty_state e).\n          v \\<in> dom (finished (empty_state e)) \\<and>\n          (u \\<in> dom (finished (empty_state e)) \\<longrightarrow>\n           \\<phi> (empty_state e) v < \\<phi> (empty_state e) u)\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>\\<forall>(u, v)\\<in>cross_edges s.\n                   v \\<in> dom (finished s) \\<and>\n                   (u \\<in> dom (finished s) \\<longrightarrow>\n                    \\<phi> s v < \\<phi> s u);\n        cond s; DFS_invar G param s; DFS_invar G param s'; stack s = [];\n        v0 \\<notin> dom (discovered s); v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(u, v)\\<in>cross_edges s'.\n                            v \\<in> dom (finished s') \\<and>\n                            (u \\<in> dom (finished s') \\<longrightarrow>\n                             \\<phi> s' v < \\<phi> s' u)\n 3. \\<And>s s' u v e.\n       \\<lbrakk>\\<forall>(u, v)\\<in>cross_edges s.\n                   v \\<in> dom (finished s) \\<and>\n                   (u \\<in> dom (finished s) \\<longrightarrow>\n                    \\<phi> s v < \\<phi> s u);\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        u = hd (stack s);\n        s' =\n        cross_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(u, v)\\<in>cross_edges s'.\n                            v \\<in> dom (finished s') \\<and>\n                            (u \\<in> dom (finished s') \\<longrightarrow>\n                             \\<phi> s' v < \\<phi> s' u)\n 4. \\<And>s s' u v e.\n       \\<lbrakk>\\<forall>(u, v)\\<in>cross_edges s.\n                   v \\<in> dom (finished s) \\<and>\n                   (u \\<in> dom (finished s) \\<longrightarrow>\n                    \\<phi> s v < \\<phi> s u);\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        u = hd (stack s);\n        s' =\n        back_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(u, v)\\<in>cross_edges s'.\n                            v \\<in> dom (finished s') \\<and>\n                            (u \\<in> dom (finished s') \\<longrightarrow>\n                             \\<phi> s' v < \\<phi> s' u)\n 5. \\<And>s s' u v e.\n       \\<lbrakk>\\<forall>(u, v)\\<in>cross_edges s.\n                   v \\<in> dom (finished s) \\<and>\n                   (u \\<in> dom (finished s) \\<longrightarrow>\n                    \\<phi> s v < \\<phi> s u);\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(u, v)\\<in>cross_edges s'.\n                            v \\<in> dom (finished s') \\<and>\n                            (u \\<in> dom (finished s') \\<longrightarrow>\n                             \\<phi> s' v < \\<phi> s' u)", "interpret DFS_invar G param s"], ["proof (prove)\ngoal (1 subgoal):\n 1. DFS_invar G param s", "by fact"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>e.\n       \\<forall>(u, v)\\<in>cross_edges (empty_state e).\n          v \\<in> dom (finished (empty_state e)) \\<and>\n          (u \\<in> dom (finished (empty_state e)) \\<longrightarrow>\n           \\<phi> (empty_state e) v < \\<phi> (empty_state e) u)\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>\\<forall>(u, v)\\<in>cross_edges s.\n                   v \\<in> dom (finished s) \\<and>\n                   (u \\<in> dom (finished s) \\<longrightarrow>\n                    \\<phi> s v < \\<phi> s u);\n        cond s; DFS_invar G param s; DFS_invar G param s'; stack s = [];\n        v0 \\<notin> dom (discovered s); v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(u, v)\\<in>cross_edges s'.\n                            v \\<in> dom (finished s') \\<and>\n                            (u \\<in> dom (finished s') \\<longrightarrow>\n                             \\<phi> s' v < \\<phi> s' u)\n 3. \\<And>s s' u v e.\n       \\<lbrakk>\\<forall>(u, v)\\<in>cross_edges s.\n                   v \\<in> dom (finished s) \\<and>\n                   (u \\<in> dom (finished s) \\<longrightarrow>\n                    \\<phi> s v < \\<phi> s u);\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        u = hd (stack s);\n        s' =\n        cross_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(u, v)\\<in>cross_edges s'.\n                            v \\<in> dom (finished s') \\<and>\n                            (u \\<in> dom (finished s') \\<longrightarrow>\n                             \\<phi> s' v < \\<phi> s' u)\n 4. \\<And>s s' u v e.\n       \\<lbrakk>\\<forall>(u, v)\\<in>cross_edges s.\n                   v \\<in> dom (finished s) \\<and>\n                   (u \\<in> dom (finished s) \\<longrightarrow>\n                    \\<phi> s v < \\<phi> s u);\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        u = hd (stack s);\n        s' =\n        back_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(u, v)\\<in>cross_edges s'.\n                            v \\<in> dom (finished s') \\<and>\n                            (u \\<in> dom (finished s') \\<longrightarrow>\n                             \\<phi> s' v < \\<phi> s' u)\n 5. \\<And>s s' u v e.\n       \\<lbrakk>\\<forall>(u, v)\\<in>cross_edges s.\n                   v \\<in> dom (finished s) \\<and>\n                   (u \\<in> dom (finished s) \\<longrightarrow>\n                    \\<phi> s v < \\<phi> s u);\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(u, v)\\<in>cross_edges s'.\n                            v \\<in> dom (finished s') \\<and>\n                            (u \\<in> dom (finished s') \\<longrightarrow>\n                             \\<phi> s' v < \\<phi> s' u)", "from cross_edge stack_not_finished"], ["proof (chain)\npicking this:\n  \\<forall>(u, v)\\<in>cross_edges s.\n     v \\<in> dom (finished s) \\<and>\n     (u \\<in> dom (finished s) \\<longrightarrow> \\<phi> s v < \\<phi> s u)\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s \\<noteq> []\n  v \\<in> pending s `` {u}\n  v \\<in> dom (discovered s)\n  v \\<in> dom (finished s)\n  u = hd (stack s)\n  s' = cross_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n  \\<lparr>state.more := e\\<rparr>\n  ?x \\<in> set (stack s) \\<Longrightarrow> ?x \\<notin> dom (finished s)", "have \"u \\<notin> dom (finished s)\""], ["proof (prove)\nusing this:\n  \\<forall>(u, v)\\<in>cross_edges s.\n     v \\<in> dom (finished s) \\<and>\n     (u \\<in> dom (finished s) \\<longrightarrow> \\<phi> s v < \\<phi> s u)\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s \\<noteq> []\n  v \\<in> pending s `` {u}\n  v \\<in> dom (discovered s)\n  v \\<in> dom (finished s)\n  u = hd (stack s)\n  s' = cross_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n  \\<lparr>state.more := e\\<rparr>\n  ?x \\<in> set (stack s) \\<Longrightarrow> ?x \\<notin> dom (finished s)\n\ngoal (1 subgoal):\n 1. u \\<notin> dom (finished s)", "by auto"], ["proof (state)\nthis:\n  u \\<notin> dom (finished s)\n\ngoal (5 subgoals):\n 1. \\<And>e.\n       \\<forall>(u, v)\\<in>cross_edges (empty_state e).\n          v \\<in> dom (finished (empty_state e)) \\<and>\n          (u \\<in> dom (finished (empty_state e)) \\<longrightarrow>\n           \\<phi> (empty_state e) v < \\<phi> (empty_state e) u)\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>\\<forall>(u, v)\\<in>cross_edges s.\n                   v \\<in> dom (finished s) \\<and>\n                   (u \\<in> dom (finished s) \\<longrightarrow>\n                    \\<phi> s v < \\<phi> s u);\n        cond s; DFS_invar G param s; DFS_invar G param s'; stack s = [];\n        v0 \\<notin> dom (discovered s); v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(u, v)\\<in>cross_edges s'.\n                            v \\<in> dom (finished s') \\<and>\n                            (u \\<in> dom (finished s') \\<longrightarrow>\n                             \\<phi> s' v < \\<phi> s' u)\n 3. \\<And>s s' u v e.\n       \\<lbrakk>\\<forall>(u, v)\\<in>cross_edges s.\n                   v \\<in> dom (finished s) \\<and>\n                   (u \\<in> dom (finished s) \\<longrightarrow>\n                    \\<phi> s v < \\<phi> s u);\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        u = hd (stack s);\n        s' =\n        cross_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(u, v)\\<in>cross_edges s'.\n                            v \\<in> dom (finished s') \\<and>\n                            (u \\<in> dom (finished s') \\<longrightarrow>\n                             \\<phi> s' v < \\<phi> s' u)\n 4. \\<And>s s' u v e.\n       \\<lbrakk>\\<forall>(u, v)\\<in>cross_edges s.\n                   v \\<in> dom (finished s) \\<and>\n                   (u \\<in> dom (finished s) \\<longrightarrow>\n                    \\<phi> s v < \\<phi> s u);\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        u = hd (stack s);\n        s' =\n        back_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(u, v)\\<in>cross_edges s'.\n                            v \\<in> dom (finished s') \\<and>\n                            (u \\<in> dom (finished s') \\<longrightarrow>\n                             \\<phi> s' v < \\<phi> s' u)\n 5. \\<And>s s' u v e.\n       \\<lbrakk>\\<forall>(u, v)\\<in>cross_edges s.\n                   v \\<in> dom (finished s) \\<and>\n                   (u \\<in> dom (finished s) \\<longrightarrow>\n                    \\<phi> s v < \\<phi> s u);\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(u, v)\\<in>cross_edges s'.\n                            v \\<in> dom (finished s') \\<and>\n                            (u \\<in> dom (finished s') \\<longrightarrow>\n                             \\<phi> s' v < \\<phi> s' u)", "with cross_edge"], ["proof (chain)\npicking this:\n  \\<forall>(u, v)\\<in>cross_edges s.\n     v \\<in> dom (finished s) \\<and>\n     (u \\<in> dom (finished s) \\<longrightarrow> \\<phi> s v < \\<phi> s u)\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s \\<noteq> []\n  v \\<in> pending s `` {u}\n  v \\<in> dom (discovered s)\n  v \\<in> dom (finished s)\n  u = hd (stack s)\n  s' = cross_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n  \\<lparr>state.more := e\\<rparr>\n  u \\<notin> dom (finished s)", "show ?case"], ["proof (prove)\nusing this:\n  \\<forall>(u, v)\\<in>cross_edges s.\n     v \\<in> dom (finished s) \\<and>\n     (u \\<in> dom (finished s) \\<longrightarrow> \\<phi> s v < \\<phi> s u)\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s \\<noteq> []\n  v \\<in> pending s `` {u}\n  v \\<in> dom (discovered s)\n  v \\<in> dom (finished s)\n  u = hd (stack s)\n  s' = cross_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n  \\<lparr>state.more := e\\<rparr>\n  u \\<notin> dom (finished s)\n\ngoal (1 subgoal):\n 1. \\<forall>(u, v)\\<in>cross_edges s'.\n       v \\<in> dom (finished s') \\<and>\n       (u \\<in> dom (finished s') \\<longrightarrow>\n        \\<phi> s' v < \\<phi> s' u)", "by (auto intro: timing_less_counter)"], ["proof (state)\nthis:\n  \\<forall>(u, v)\\<in>cross_edges s'.\n     v \\<in> dom (finished s') \\<and>\n     (u \\<in> dom (finished s') \\<longrightarrow> \\<phi> s' v < \\<phi> s' u)\n\ngoal (4 subgoals):\n 1. \\<And>e.\n       \\<forall>(u, v)\\<in>cross_edges (empty_state e).\n          v \\<in> dom (finished (empty_state e)) \\<and>\n          (u \\<in> dom (finished (empty_state e)) \\<longrightarrow>\n           \\<phi> (empty_state e) v < \\<phi> (empty_state e) u)\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>\\<forall>(u, v)\\<in>cross_edges s.\n                   v \\<in> dom (finished s) \\<and>\n                   (u \\<in> dom (finished s) \\<longrightarrow>\n                    \\<phi> s v < \\<phi> s u);\n        cond s; DFS_invar G param s; DFS_invar G param s'; stack s = [];\n        v0 \\<notin> dom (discovered s); v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(u, v)\\<in>cross_edges s'.\n                            v \\<in> dom (finished s') \\<and>\n                            (u \\<in> dom (finished s') \\<longrightarrow>\n                             \\<phi> s' v < \\<phi> s' u)\n 3. \\<And>s s' u v e.\n       \\<lbrakk>\\<forall>(u, v)\\<in>cross_edges s.\n                   v \\<in> dom (finished s) \\<and>\n                   (u \\<in> dom (finished s) \\<longrightarrow>\n                    \\<phi> s v < \\<phi> s u);\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        u = hd (stack s);\n        s' =\n        back_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(u, v)\\<in>cross_edges s'.\n                            v \\<in> dom (finished s') \\<and>\n                            (u \\<in> dom (finished s') \\<longrightarrow>\n                             \\<phi> s' v < \\<phi> s' u)\n 4. \\<And>s s' u v e.\n       \\<lbrakk>\\<forall>(u, v)\\<in>cross_edges s.\n                   v \\<in> dom (finished s) \\<and>\n                   (u \\<in> dom (finished s) \\<longrightarrow>\n                    \\<phi> s v < \\<phi> s u);\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(u, v)\\<in>cross_edges s'.\n                            v \\<in> dom (finished s') \\<and>\n                            (u \\<in> dom (finished s') \\<longrightarrow>\n                             \\<phi> s' v < \\<phi> s' u)", "qed simp_all"], ["", "end"], ["", "end"], ["", "context DFS_invar begin"], ["", "context begin"], ["", "interpretation timing_syntax"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemmas cross_edges_finished \n    = i_cross_edges_finished[THEN make_invar_thm]"], ["", "lemma cross_edges_target_finished: \n    \"(u,v)\\<in>cross_edges s \\<Longrightarrow> v \\<in> dom (finished s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (u, v) \\<in> cross_edges s \\<Longrightarrow> v \\<in> dom (finished s)", "using cross_edges_finished"], ["proof (prove)\nusing this:\n  \\<forall>(u, v)\\<in>cross_edges s.\n     v \\<in> dom (finished s) \\<and>\n     (u \\<in> dom (finished s) \\<longrightarrow> \\<phi> s v < \\<phi> s u)\n\ngoal (1 subgoal):\n 1. (u, v) \\<in> cross_edges s \\<Longrightarrow> v \\<in> dom (finished s)", "by auto"], ["", "lemma cross_edges_finished_decr: \n    \"\\<lbrakk>(u,v)\\<in>cross_edges s; u\\<in>dom (finished s)\\<rbrakk> \\<Longrightarrow> \\<phi> s v < \\<phi> s u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(u, v) \\<in> cross_edges s; u \\<in> dom (finished s)\\<rbrakk>\n    \\<Longrightarrow> \\<phi> s v < \\<phi> s u", "using cross_edges_finished"], ["proof (prove)\nusing this:\n  \\<forall>(u, v)\\<in>cross_edges s.\n     v \\<in> dom (finished s) \\<and>\n     (u \\<in> dom (finished s) \\<longrightarrow> \\<phi> s v < \\<phi> s u)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(u, v) \\<in> cross_edges s; u \\<in> dom (finished s)\\<rbrakk>\n    \\<Longrightarrow> \\<phi> s v < \\<phi> s u", "by auto"], ["", "lemma cross_edge_unequal:\n    assumes cross: \"(v,w) \\<in> cross_edges s\"\n    shows \"v \\<noteq> w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<noteq> w", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. v \\<noteq> w", "from cross_edges_target_finished[OF cross]"], ["proof (chain)\npicking this:\n  w \\<in> dom (finished s)", "have \n      w_fin: \"w \\<in> dom (finished s)\""], ["proof (prove)\nusing this:\n  w \\<in> dom (finished s)\n\ngoal (1 subgoal):\n 1. w \\<in> dom (finished s)", "."], ["proof (state)\nthis:\n  w \\<in> dom (finished s)\n\ngoal (1 subgoal):\n 1. v \\<noteq> w", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<noteq> w", "proof (cases \"v \\<in> dom (finished s)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. v \\<in> dom (finished s) \\<Longrightarrow> v \\<noteq> w\n 2. v \\<notin> dom (finished s) \\<Longrightarrow> v \\<noteq> w", "case True"], ["proof (state)\nthis:\n  v \\<in> dom (finished s)\n\ngoal (2 subgoals):\n 1. v \\<in> dom (finished s) \\<Longrightarrow> v \\<noteq> w\n 2. v \\<notin> dom (finished s) \\<Longrightarrow> v \\<noteq> w", "with cross_edges_finished_decr[OF cross]"], ["proof (chain)\npicking this:\n  v \\<in> dom (finished s) \\<Longrightarrow> \\<phi> s w < \\<phi> s v\n  v \\<in> dom (finished s)", "show ?thesis"], ["proof (prove)\nusing this:\n  v \\<in> dom (finished s) \\<Longrightarrow> \\<phi> s w < \\<phi> s v\n  v \\<in> dom (finished s)\n\ngoal (1 subgoal):\n 1. v \\<noteq> w", "by force"], ["proof (state)\nthis:\n  v \\<noteq> w\n\ngoal (1 subgoal):\n 1. v \\<notin> dom (finished s) \\<Longrightarrow> v \\<noteq> w", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. v \\<notin> dom (finished s) \\<Longrightarrow> v \\<noteq> w", "case False"], ["proof (state)\nthis:\n  v \\<notin> dom (finished s)\n\ngoal (1 subgoal):\n 1. v \\<notin> dom (finished s) \\<Longrightarrow> v \\<noteq> w", "with w_fin"], ["proof (chain)\npicking this:\n  w \\<in> dom (finished s)\n  v \\<notin> dom (finished s)", "show ?thesis"], ["proof (prove)\nusing this:\n  w \\<in> dom (finished s)\n  v \\<notin> dom (finished s)\n\ngoal (1 subgoal):\n 1. v \\<noteq> w", "by force"], ["proof (state)\nthis:\n  v \\<noteq> w\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  v \\<noteq> w\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"], ["", "subsubsection \\<open>Properties of Back Edges\\<close>"], ["", "(* Back Edges *)"], ["", "context param_DFS begin"], ["", "context begin"], ["", "interpretation timing_syntax"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma i_back_edge_impl_tree_path:\n    \"is_invar (\\<lambda>s. \\<forall>(v,w) \\<in> back_edges s. (w,v) \\<in> (tree_edges s)\\<^sup>+ \\<or> w = v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_invar\n     (\\<lambda>s.\n         \\<forall>(v, w)\\<in>back_edges s.\n            (w, v) \\<in> (tree_edges s)\\<^sup>+ \\<or> w = v)", "proof (induct rule: is_invarI_full)"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>e.\n       \\<forall>(v, w)\\<in>back_edges (empty_state e).\n          (w, v) \\<in> (tree_edges (empty_state e))\\<^sup>+ \\<or> w = v\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>\\<forall>(v, w)\\<in>back_edges s.\n                   (w, v) \\<in> (tree_edges s)\\<^sup>+ \\<or> w = v;\n        cond s; DFS_invar G param s; DFS_invar G param s'; stack s = [];\n        v0 \\<notin> dom (discovered s); v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, w)\\<in>back_edges s'.\n                            (w, v) \\<in> (tree_edges s')\\<^sup>+ \\<or> w = v\n 3. \\<And>s s' u e.\n       \\<lbrakk>\\<forall>(v, w)\\<in>back_edges s.\n                   (w, v) \\<in> (tree_edges s)\\<^sup>+ \\<or> w = v;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; pending s `` {u} = {}; u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, w)\\<in>back_edges s'.\n                            (w, v) \\<in> (tree_edges s')\\<^sup>+ \\<or> w = v\n 4. \\<And>s s' u v e.\n       \\<lbrakk>\\<forall>(v, w)\\<in>back_edges s.\n                   (w, v) \\<in> (tree_edges s)\\<^sup>+ \\<or> w = v;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        u = hd (stack s);\n        s' =\n        cross_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, w)\\<in>back_edges s'.\n                            (w, v) \\<in> (tree_edges s')\\<^sup>+ \\<or> w = v\n 5. \\<And>s s' u v e.\n       \\<lbrakk>\\<forall>(v, w)\\<in>back_edges s.\n                   (w, v) \\<in> (tree_edges s)\\<^sup>+ \\<or> w = v;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        u = hd (stack s);\n        s' =\n        back_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, w)\\<in>back_edges s'.\n                            (w, v) \\<in> (tree_edges s')\\<^sup>+ \\<or> w = v\n 6. \\<And>s s' u v e.\n       \\<lbrakk>\\<forall>(v, w)\\<in>back_edges s.\n                   (w, v) \\<in> (tree_edges s)\\<^sup>+ \\<or> w = v;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, w)\\<in>back_edges s'.\n                            (w, v) \\<in> (tree_edges s')\\<^sup>+ \\<or> w = v", "case (back_edge s s' u v)"], ["proof (state)\nthis:\n  \\<forall>(v, w)\\<in>back_edges s.\n     (w, v) \\<in> (tree_edges s)\\<^sup>+ \\<or> w = v\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s \\<noteq> []\n  v \\<in> pending s `` {u}\n  v \\<in> dom (discovered s)\n  v \\<notin> dom (finished s)\n  u = hd (stack s)\n  s' = back_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n  \\<lparr>state.more := e_\\<rparr>\n\ngoal (6 subgoals):\n 1. \\<And>e.\n       \\<forall>(v, w)\\<in>back_edges (empty_state e).\n          (w, v) \\<in> (tree_edges (empty_state e))\\<^sup>+ \\<or> w = v\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>\\<forall>(v, w)\\<in>back_edges s.\n                   (w, v) \\<in> (tree_edges s)\\<^sup>+ \\<or> w = v;\n        cond s; DFS_invar G param s; DFS_invar G param s'; stack s = [];\n        v0 \\<notin> dom (discovered s); v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, w)\\<in>back_edges s'.\n                            (w, v) \\<in> (tree_edges s')\\<^sup>+ \\<or> w = v\n 3. \\<And>s s' u e.\n       \\<lbrakk>\\<forall>(v, w)\\<in>back_edges s.\n                   (w, v) \\<in> (tree_edges s)\\<^sup>+ \\<or> w = v;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; pending s `` {u} = {}; u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, w)\\<in>back_edges s'.\n                            (w, v) \\<in> (tree_edges s')\\<^sup>+ \\<or> w = v\n 4. \\<And>s s' u v e.\n       \\<lbrakk>\\<forall>(v, w)\\<in>back_edges s.\n                   (w, v) \\<in> (tree_edges s)\\<^sup>+ \\<or> w = v;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        u = hd (stack s);\n        s' =\n        cross_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, w)\\<in>back_edges s'.\n                            (w, v) \\<in> (tree_edges s')\\<^sup>+ \\<or> w = v\n 5. \\<And>s s' u v e.\n       \\<lbrakk>\\<forall>(v, w)\\<in>back_edges s.\n                   (w, v) \\<in> (tree_edges s)\\<^sup>+ \\<or> w = v;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        u = hd (stack s);\n        s' =\n        back_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, w)\\<in>back_edges s'.\n                            (w, v) \\<in> (tree_edges s')\\<^sup>+ \\<or> w = v\n 6. \\<And>s s' u v e.\n       \\<lbrakk>\\<forall>(v, w)\\<in>back_edges s.\n                   (w, v) \\<in> (tree_edges s)\\<^sup>+ \\<or> w = v;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, w)\\<in>back_edges s'.\n                            (w, v) \\<in> (tree_edges s')\\<^sup>+ \\<or> w = v", "then"], ["proof (chain)\npicking this:\n  \\<forall>(v, w)\\<in>back_edges s.\n     (w, v) \\<in> (tree_edges s)\\<^sup>+ \\<or> w = v\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s \\<noteq> []\n  v \\<in> pending s `` {u}\n  v \\<in> dom (discovered s)\n  v \\<notin> dom (finished s)\n  u = hd (stack s)\n  s' = back_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n  \\<lparr>state.more := e_\\<rparr>", "interpret DFS_invar where s=s"], ["proof (prove)\nusing this:\n  \\<forall>(v, w)\\<in>back_edges s.\n     (w, v) \\<in> (tree_edges s)\\<^sup>+ \\<or> w = v\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s \\<noteq> []\n  v \\<in> pending s `` {u}\n  v \\<in> dom (discovered s)\n  v \\<notin> dom (finished s)\n  u = hd (stack s)\n  s' = back_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n  \\<lparr>state.more := e_\\<rparr>\n\ngoal (1 subgoal):\n 1. DFS_invar G param s", "by simp"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>e.\n       \\<forall>(v, w)\\<in>back_edges (empty_state e).\n          (w, v) \\<in> (tree_edges (empty_state e))\\<^sup>+ \\<or> w = v\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>\\<forall>(v, w)\\<in>back_edges s.\n                   (w, v) \\<in> (tree_edges s)\\<^sup>+ \\<or> w = v;\n        cond s; DFS_invar G param s; DFS_invar G param s'; stack s = [];\n        v0 \\<notin> dom (discovered s); v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, w)\\<in>back_edges s'.\n                            (w, v) \\<in> (tree_edges s')\\<^sup>+ \\<or> w = v\n 3. \\<And>s s' u e.\n       \\<lbrakk>\\<forall>(v, w)\\<in>back_edges s.\n                   (w, v) \\<in> (tree_edges s)\\<^sup>+ \\<or> w = v;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; pending s `` {u} = {}; u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, w)\\<in>back_edges s'.\n                            (w, v) \\<in> (tree_edges s')\\<^sup>+ \\<or> w = v\n 4. \\<And>s s' u v e.\n       \\<lbrakk>\\<forall>(v, w)\\<in>back_edges s.\n                   (w, v) \\<in> (tree_edges s)\\<^sup>+ \\<or> w = v;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        u = hd (stack s);\n        s' =\n        cross_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, w)\\<in>back_edges s'.\n                            (w, v) \\<in> (tree_edges s')\\<^sup>+ \\<or> w = v\n 5. \\<And>s s' u v e.\n       \\<lbrakk>\\<forall>(v, w)\\<in>back_edges s.\n                   (w, v) \\<in> (tree_edges s)\\<^sup>+ \\<or> w = v;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        u = hd (stack s);\n        s' =\n        back_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, w)\\<in>back_edges s'.\n                            (w, v) \\<in> (tree_edges s')\\<^sup>+ \\<or> w = v\n 6. \\<And>s s' u v e.\n       \\<lbrakk>\\<forall>(v, w)\\<in>back_edges s.\n                   (w, v) \\<in> (tree_edges s)\\<^sup>+ \\<or> w = v;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, w)\\<in>back_edges s'.\n                            (w, v) \\<in> (tree_edges s')\\<^sup>+ \\<or> w = v", "from back_edge"], ["proof (chain)\npicking this:\n  \\<forall>(v, w)\\<in>back_edges s.\n     (w, v) \\<in> (tree_edges s)\\<^sup>+ \\<or> w = v\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s \\<noteq> []\n  v \\<in> pending s `` {u}\n  v \\<in> dom (discovered s)\n  v \\<notin> dom (finished s)\n  u = hd (stack s)\n  s' = back_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n  \\<lparr>state.more := e_\\<rparr>", "have st: \"v \\<in> set (stack s)\" \"u \\<in> set (stack s)\""], ["proof (prove)\nusing this:\n  \\<forall>(v, w)\\<in>back_edges s.\n     (w, v) \\<in> (tree_edges s)\\<^sup>+ \\<or> w = v\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s \\<noteq> []\n  v \\<in> pending s `` {u}\n  v \\<in> dom (discovered s)\n  v \\<notin> dom (finished s)\n  u = hd (stack s)\n  s' = back_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n  \\<lparr>state.more := e_\\<rparr>\n\ngoal (1 subgoal):\n 1. v \\<in> set (stack s) &&& u \\<in> set (stack s)", "using stack_set_def"], ["proof (prove)\nusing this:\n  \\<forall>(v, w)\\<in>back_edges s.\n     (w, v) \\<in> (tree_edges s)\\<^sup>+ \\<or> w = v\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s \\<noteq> []\n  v \\<in> pending s `` {u}\n  v \\<in> dom (discovered s)\n  v \\<notin> dom (finished s)\n  u = hd (stack s)\n  s' = back_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n  \\<lparr>state.more := e_\\<rparr>\n  set (stack s) = dom (discovered s) - dom (finished s)\n\ngoal (1 subgoal):\n 1. v \\<in> set (stack s) &&& u \\<in> set (stack s)", "by auto"], ["proof (state)\nthis:\n  v \\<in> set (stack s)\n  u \\<in> set (stack s)\n\ngoal (6 subgoals):\n 1. \\<And>e.\n       \\<forall>(v, w)\\<in>back_edges (empty_state e).\n          (w, v) \\<in> (tree_edges (empty_state e))\\<^sup>+ \\<or> w = v\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>\\<forall>(v, w)\\<in>back_edges s.\n                   (w, v) \\<in> (tree_edges s)\\<^sup>+ \\<or> w = v;\n        cond s; DFS_invar G param s; DFS_invar G param s'; stack s = [];\n        v0 \\<notin> dom (discovered s); v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, w)\\<in>back_edges s'.\n                            (w, v) \\<in> (tree_edges s')\\<^sup>+ \\<or> w = v\n 3. \\<And>s s' u e.\n       \\<lbrakk>\\<forall>(v, w)\\<in>back_edges s.\n                   (w, v) \\<in> (tree_edges s)\\<^sup>+ \\<or> w = v;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; pending s `` {u} = {}; u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, w)\\<in>back_edges s'.\n                            (w, v) \\<in> (tree_edges s')\\<^sup>+ \\<or> w = v\n 4. \\<And>s s' u v e.\n       \\<lbrakk>\\<forall>(v, w)\\<in>back_edges s.\n                   (w, v) \\<in> (tree_edges s)\\<^sup>+ \\<or> w = v;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        u = hd (stack s);\n        s' =\n        cross_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, w)\\<in>back_edges s'.\n                            (w, v) \\<in> (tree_edges s')\\<^sup>+ \\<or> w = v\n 5. \\<And>s s' u v e.\n       \\<lbrakk>\\<forall>(v, w)\\<in>back_edges s.\n                   (w, v) \\<in> (tree_edges s)\\<^sup>+ \\<or> w = v;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        u = hd (stack s);\n        s' =\n        back_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, w)\\<in>back_edges s'.\n                            (w, v) \\<in> (tree_edges s')\\<^sup>+ \\<or> w = v\n 6. \\<And>s s' u v e.\n       \\<lbrakk>\\<forall>(v, w)\\<in>back_edges s.\n                   (w, v) \\<in> (tree_edges s)\\<^sup>+ \\<or> w = v;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, w)\\<in>back_edges s'.\n                            (w, v) \\<in> (tree_edges s')\\<^sup>+ \\<or> w = v", "have \"(v,u) \\<in> (tree_edges s)\\<^sup>+ \\<or> u = v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (v, u) \\<in> (tree_edges s)\\<^sup>+ \\<or> u = v", "proof (rule disjCI)"], ["proof (state)\ngoal (1 subgoal):\n 1. u \\<noteq> v \\<Longrightarrow> (v, u) \\<in> (tree_edges s)\\<^sup>+", "assume \"u \\<noteq> v\""], ["proof (state)\nthis:\n  u \\<noteq> v\n\ngoal (1 subgoal):\n 1. u \\<noteq> v \\<Longrightarrow> (v, u) \\<in> (tree_edges s)\\<^sup>+", "with st back_edge"], ["proof (chain)\npicking this:\n  v \\<in> set (stack s)\n  u \\<in> set (stack s)\n  \\<forall>(v, w)\\<in>back_edges s.\n     (w, v) \\<in> (tree_edges s)\\<^sup>+ \\<or> w = v\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s \\<noteq> []\n  v \\<in> pending s `` {u}\n  v \\<in> dom (discovered s)\n  v \\<notin> dom (finished s)\n  u = hd (stack s)\n  s' = back_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n  \\<lparr>state.more := e_\\<rparr>\n  u \\<noteq> v", "have \"v \\<in> set (tl (stack s))\""], ["proof (prove)\nusing this:\n  v \\<in> set (stack s)\n  u \\<in> set (stack s)\n  \\<forall>(v, w)\\<in>back_edges s.\n     (w, v) \\<in> (tree_edges s)\\<^sup>+ \\<or> w = v\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s \\<noteq> []\n  v \\<in> pending s `` {u}\n  v \\<in> dom (discovered s)\n  v \\<notin> dom (finished s)\n  u = hd (stack s)\n  s' = back_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n  \\<lparr>state.more := e_\\<rparr>\n  u \\<noteq> v\n\ngoal (1 subgoal):\n 1. v \\<in> set (tl (stack s))", "by (metis not_hd_in_tl)"], ["proof (state)\nthis:\n  v \\<in> set (tl (stack s))\n\ngoal (1 subgoal):\n 1. u \\<noteq> v \\<Longrightarrow> (v, u) \\<in> (tree_edges s)\\<^sup>+", "with tl_lt_stack_hd_discover st back_edge"], ["proof (chain)\npicking this:\n  \\<lbrakk>stack s \\<noteq> []; ?x \\<in> set (tl (stack s))\\<rbrakk>\n  \\<Longrightarrow> \\<delta> s ?x < \\<delta> s (hd (stack s))\n  v \\<in> set (stack s)\n  u \\<in> set (stack s)\n  \\<forall>(v, w)\\<in>back_edges s.\n     (w, v) \\<in> (tree_edges s)\\<^sup>+ \\<or> w = v\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s \\<noteq> []\n  v \\<in> pending s `` {u}\n  v \\<in> dom (discovered s)\n  v \\<notin> dom (finished s)\n  u = hd (stack s)\n  s' = back_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n  \\<lparr>state.more := e_\\<rparr>\n  v \\<in> set (tl (stack s))", "have \"\\<delta> s v < \\<delta> s u\""], ["proof (prove)\nusing this:\n  \\<lbrakk>stack s \\<noteq> []; ?x \\<in> set (tl (stack s))\\<rbrakk>\n  \\<Longrightarrow> \\<delta> s ?x < \\<delta> s (hd (stack s))\n  v \\<in> set (stack s)\n  u \\<in> set (stack s)\n  \\<forall>(v, w)\\<in>back_edges s.\n     (w, v) \\<in> (tree_edges s)\\<^sup>+ \\<or> w = v\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s \\<noteq> []\n  v \\<in> pending s `` {u}\n  v \\<in> dom (discovered s)\n  v \\<notin> dom (finished s)\n  u = hd (stack s)\n  s' = back_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n  \\<lparr>state.more := e_\\<rparr>\n  v \\<in> set (tl (stack s))\n\ngoal (1 subgoal):\n 1. \\<delta> s v < \\<delta> s u", "by simp"], ["proof (state)\nthis:\n  \\<delta> s v < \\<delta> s u\n\ngoal (1 subgoal):\n 1. u \\<noteq> v \\<Longrightarrow> (v, u) \\<in> (tree_edges s)\\<^sup>+", "with on_stack_is_tree_path st"], ["proof (chain)\npicking this:\n  \\<lbrakk>?x \\<in> set (stack s); ?y \\<in> set (stack s);\n   \\<delta> s ?x < \\<delta> s ?y\\<rbrakk>\n  \\<Longrightarrow> (?x, ?y) \\<in> (tree_edges s)\\<^sup>+\n  v \\<in> set (stack s)\n  u \\<in> set (stack s)\n  \\<delta> s v < \\<delta> s u", "show \"(v,u) \\<in> (tree_edges s)\\<^sup>+\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<in> set (stack s); ?y \\<in> set (stack s);\n   \\<delta> s ?x < \\<delta> s ?y\\<rbrakk>\n  \\<Longrightarrow> (?x, ?y) \\<in> (tree_edges s)\\<^sup>+\n  v \\<in> set (stack s)\n  u \\<in> set (stack s)\n  \\<delta> s v < \\<delta> s u\n\ngoal (1 subgoal):\n 1. (v, u) \\<in> (tree_edges s)\\<^sup>+", "by simp"], ["proof (state)\nthis:\n  (v, u) \\<in> (tree_edges s)\\<^sup>+\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (v, u) \\<in> (tree_edges s)\\<^sup>+ \\<or> u = v\n\ngoal (6 subgoals):\n 1. \\<And>e.\n       \\<forall>(v, w)\\<in>back_edges (empty_state e).\n          (w, v) \\<in> (tree_edges (empty_state e))\\<^sup>+ \\<or> w = v\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>\\<forall>(v, w)\\<in>back_edges s.\n                   (w, v) \\<in> (tree_edges s)\\<^sup>+ \\<or> w = v;\n        cond s; DFS_invar G param s; DFS_invar G param s'; stack s = [];\n        v0 \\<notin> dom (discovered s); v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, w)\\<in>back_edges s'.\n                            (w, v) \\<in> (tree_edges s')\\<^sup>+ \\<or> w = v\n 3. \\<And>s s' u e.\n       \\<lbrakk>\\<forall>(v, w)\\<in>back_edges s.\n                   (w, v) \\<in> (tree_edges s)\\<^sup>+ \\<or> w = v;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; pending s `` {u} = {}; u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, w)\\<in>back_edges s'.\n                            (w, v) \\<in> (tree_edges s')\\<^sup>+ \\<or> w = v\n 4. \\<And>s s' u v e.\n       \\<lbrakk>\\<forall>(v, w)\\<in>back_edges s.\n                   (w, v) \\<in> (tree_edges s)\\<^sup>+ \\<or> w = v;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        u = hd (stack s);\n        s' =\n        cross_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, w)\\<in>back_edges s'.\n                            (w, v) \\<in> (tree_edges s')\\<^sup>+ \\<or> w = v\n 5. \\<And>s s' u v e.\n       \\<lbrakk>\\<forall>(v, w)\\<in>back_edges s.\n                   (w, v) \\<in> (tree_edges s)\\<^sup>+ \\<or> w = v;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        u = hd (stack s);\n        s' =\n        back_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, w)\\<in>back_edges s'.\n                            (w, v) \\<in> (tree_edges s')\\<^sup>+ \\<or> w = v\n 6. \\<And>s s' u v e.\n       \\<lbrakk>\\<forall>(v, w)\\<in>back_edges s.\n                   (w, v) \\<in> (tree_edges s)\\<^sup>+ \\<or> w = v;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, w)\\<in>back_edges s'.\n                            (w, v) \\<in> (tree_edges s')\\<^sup>+ \\<or> w = v", "with back_edge"], ["proof (chain)\npicking this:\n  \\<forall>(v, w)\\<in>back_edges s.\n     (w, v) \\<in> (tree_edges s)\\<^sup>+ \\<or> w = v\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s \\<noteq> []\n  v \\<in> pending s `` {u}\n  v \\<in> dom (discovered s)\n  v \\<notin> dom (finished s)\n  u = hd (stack s)\n  s' = back_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n  \\<lparr>state.more := e_\\<rparr>\n  (v, u) \\<in> (tree_edges s)\\<^sup>+ \\<or> u = v", "show ?case"], ["proof (prove)\nusing this:\n  \\<forall>(v, w)\\<in>back_edges s.\n     (w, v) \\<in> (tree_edges s)\\<^sup>+ \\<or> w = v\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s \\<noteq> []\n  v \\<in> pending s `` {u}\n  v \\<in> dom (discovered s)\n  v \\<notin> dom (finished s)\n  u = hd (stack s)\n  s' = back_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n  \\<lparr>state.more := e_\\<rparr>\n  (v, u) \\<in> (tree_edges s)\\<^sup>+ \\<or> u = v\n\ngoal (1 subgoal):\n 1. \\<forall>(v, w)\\<in>back_edges s'.\n       (w, v) \\<in> (tree_edges s')\\<^sup>+ \\<or> w = v", "by auto"], ["proof (state)\nthis:\n  \\<forall>(v, w)\\<in>back_edges s'.\n     (w, v) \\<in> (tree_edges s')\\<^sup>+ \\<or> w = v\n\ngoal (5 subgoals):\n 1. \\<And>e.\n       \\<forall>(v, w)\\<in>back_edges (empty_state e).\n          (w, v) \\<in> (tree_edges (empty_state e))\\<^sup>+ \\<or> w = v\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>\\<forall>(v, w)\\<in>back_edges s.\n                   (w, v) \\<in> (tree_edges s)\\<^sup>+ \\<or> w = v;\n        cond s; DFS_invar G param s; DFS_invar G param s'; stack s = [];\n        v0 \\<notin> dom (discovered s); v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, w)\\<in>back_edges s'.\n                            (w, v) \\<in> (tree_edges s')\\<^sup>+ \\<or> w = v\n 3. \\<And>s s' u e.\n       \\<lbrakk>\\<forall>(v, w)\\<in>back_edges s.\n                   (w, v) \\<in> (tree_edges s)\\<^sup>+ \\<or> w = v;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; pending s `` {u} = {}; u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, w)\\<in>back_edges s'.\n                            (w, v) \\<in> (tree_edges s')\\<^sup>+ \\<or> w = v\n 4. \\<And>s s' u v e.\n       \\<lbrakk>\\<forall>(v, w)\\<in>back_edges s.\n                   (w, v) \\<in> (tree_edges s)\\<^sup>+ \\<or> w = v;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        u = hd (stack s);\n        s' =\n        cross_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, w)\\<in>back_edges s'.\n                            (w, v) \\<in> (tree_edges s')\\<^sup>+ \\<or> w = v\n 5. \\<And>s s' u v e.\n       \\<lbrakk>\\<forall>(v, w)\\<in>back_edges s.\n                   (w, v) \\<in> (tree_edges s)\\<^sup>+ \\<or> w = v;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, w)\\<in>back_edges s'.\n                            (w, v) \\<in> (tree_edges s')\\<^sup>+ \\<or> w = v", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>e.\n       \\<forall>(v, w)\\<in>back_edges (empty_state e).\n          (w, v) \\<in> (tree_edges (empty_state e))\\<^sup>+ \\<or> w = v\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>\\<forall>(v, w)\\<in>back_edges s.\n                   (w, v) \\<in> (tree_edges s)\\<^sup>+ \\<or> w = v;\n        cond s; DFS_invar G param s; DFS_invar G param s'; stack s = [];\n        v0 \\<notin> dom (discovered s); v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, w)\\<in>back_edges s'.\n                            (w, v) \\<in> (tree_edges s')\\<^sup>+ \\<or> w = v\n 3. \\<And>s s' u e.\n       \\<lbrakk>\\<forall>(v, w)\\<in>back_edges s.\n                   (w, v) \\<in> (tree_edges s)\\<^sup>+ \\<or> w = v;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; pending s `` {u} = {}; u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, w)\\<in>back_edges s'.\n                            (w, v) \\<in> (tree_edges s')\\<^sup>+ \\<or> w = v\n 4. \\<And>s s' u v e.\n       \\<lbrakk>\\<forall>(v, w)\\<in>back_edges s.\n                   (w, v) \\<in> (tree_edges s)\\<^sup>+ \\<or> w = v;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        u = hd (stack s);\n        s' =\n        cross_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, w)\\<in>back_edges s'.\n                            (w, v) \\<in> (tree_edges s')\\<^sup>+ \\<or> w = v\n 5. \\<And>s s' u v e.\n       \\<lbrakk>\\<forall>(v, w)\\<in>back_edges s.\n                   (w, v) \\<in> (tree_edges s)\\<^sup>+ \\<or> w = v;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, w)\\<in>back_edges s'.\n                            (w, v) \\<in> (tree_edges s')\\<^sup>+ \\<or> w = v", "case discover"], ["proof (state)\nthis:\n  \\<forall>(v, w)\\<in>back_edges s_.\n     (w, v) \\<in> (tree_edges s_)\\<^sup>+ \\<or> w = v\n  cond s_\n  DFS_invar G param s_\n  DFS_invar G param s'_\n  stack s_ \\<noteq> []\n  v_ \\<in> pending s_ `` {u_}\n  v_ \\<notin> dom (discovered s_)\n  u_ = hd (stack s_)\n  s'_ =\n  discover u_ v_ (s_\\<lparr>pending := pending s_ - {(u_, v_)}\\<rparr>)\n  \\<lparr>state.more := e_\\<rparr>\n\ngoal (5 subgoals):\n 1. \\<And>e.\n       \\<forall>(v, w)\\<in>back_edges (empty_state e).\n          (w, v) \\<in> (tree_edges (empty_state e))\\<^sup>+ \\<or> w = v\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>\\<forall>(v, w)\\<in>back_edges s.\n                   (w, v) \\<in> (tree_edges s)\\<^sup>+ \\<or> w = v;\n        cond s; DFS_invar G param s; DFS_invar G param s'; stack s = [];\n        v0 \\<notin> dom (discovered s); v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, w)\\<in>back_edges s'.\n                            (w, v) \\<in> (tree_edges s')\\<^sup>+ \\<or> w = v\n 3. \\<And>s s' u e.\n       \\<lbrakk>\\<forall>(v, w)\\<in>back_edges s.\n                   (w, v) \\<in> (tree_edges s)\\<^sup>+ \\<or> w = v;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; pending s `` {u} = {}; u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, w)\\<in>back_edges s'.\n                            (w, v) \\<in> (tree_edges s')\\<^sup>+ \\<or> w = v\n 4. \\<And>s s' u v e.\n       \\<lbrakk>\\<forall>(v, w)\\<in>back_edges s.\n                   (w, v) \\<in> (tree_edges s)\\<^sup>+ \\<or> w = v;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        u = hd (stack s);\n        s' =\n        cross_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, w)\\<in>back_edges s'.\n                            (w, v) \\<in> (tree_edges s')\\<^sup>+ \\<or> w = v\n 5. \\<And>s s' u v e.\n       \\<lbrakk>\\<forall>(v, w)\\<in>back_edges s.\n                   (w, v) \\<in> (tree_edges s)\\<^sup>+ \\<or> w = v;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, w)\\<in>back_edges s'.\n                            (w, v) \\<in> (tree_edges s')\\<^sup>+ \\<or> w = v", "thus ?case"], ["proof (prove)\nusing this:\n  \\<forall>(v, w)\\<in>back_edges s_.\n     (w, v) \\<in> (tree_edges s_)\\<^sup>+ \\<or> w = v\n  cond s_\n  DFS_invar G param s_\n  DFS_invar G param s'_\n  stack s_ \\<noteq> []\n  v_ \\<in> pending s_ `` {u_}\n  v_ \\<notin> dom (discovered s_)\n  u_ = hd (stack s_)\n  s'_ =\n  discover u_ v_ (s_\\<lparr>pending := pending s_ - {(u_, v_)}\\<rparr>)\n  \\<lparr>state.more := e_\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<forall>(v, w)\\<in>back_edges s'_.\n       (w, v) \\<in> (tree_edges s'_)\\<^sup>+ \\<or> w = v", "using trancl_sub_insert_trancl"], ["proof (prove)\nusing this:\n  \\<forall>(v, w)\\<in>back_edges s_.\n     (w, v) \\<in> (tree_edges s_)\\<^sup>+ \\<or> w = v\n  cond s_\n  DFS_invar G param s_\n  DFS_invar G param s'_\n  stack s_ \\<noteq> []\n  v_ \\<in> pending s_ `` {u_}\n  v_ \\<notin> dom (discovered s_)\n  u_ = hd (stack s_)\n  s'_ =\n  discover u_ v_ (s_\\<lparr>pending := pending s_ - {(u_, v_)}\\<rparr>)\n  \\<lparr>state.more := e_\\<rparr>\n  ?R\\<^sup>+ \\<subseteq> (insert ?x ?R)\\<^sup>+\n\ngoal (1 subgoal):\n 1. \\<forall>(v, w)\\<in>back_edges s'_.\n       (w, v) \\<in> (tree_edges s'_)\\<^sup>+ \\<or> w = v", "by force"], ["proof (state)\nthis:\n  \\<forall>(v, w)\\<in>back_edges s'_.\n     (w, v) \\<in> (tree_edges s'_)\\<^sup>+ \\<or> w = v\n\ngoal (4 subgoals):\n 1. \\<And>e.\n       \\<forall>(v, w)\\<in>back_edges (empty_state e).\n          (w, v) \\<in> (tree_edges (empty_state e))\\<^sup>+ \\<or> w = v\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>\\<forall>(v, w)\\<in>back_edges s.\n                   (w, v) \\<in> (tree_edges s)\\<^sup>+ \\<or> w = v;\n        cond s; DFS_invar G param s; DFS_invar G param s'; stack s = [];\n        v0 \\<notin> dom (discovered s); v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, w)\\<in>back_edges s'.\n                            (w, v) \\<in> (tree_edges s')\\<^sup>+ \\<or> w = v\n 3. \\<And>s s' u e.\n       \\<lbrakk>\\<forall>(v, w)\\<in>back_edges s.\n                   (w, v) \\<in> (tree_edges s)\\<^sup>+ \\<or> w = v;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; pending s `` {u} = {}; u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, w)\\<in>back_edges s'.\n                            (w, v) \\<in> (tree_edges s')\\<^sup>+ \\<or> w = v\n 4. \\<And>s s' u v e.\n       \\<lbrakk>\\<forall>(v, w)\\<in>back_edges s.\n                   (w, v) \\<in> (tree_edges s)\\<^sup>+ \\<or> w = v;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        u = hd (stack s);\n        s' =\n        cross_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, w)\\<in>back_edges s'.\n                            (w, v) \\<in> (tree_edges s')\\<^sup>+ \\<or> w = v", "qed simp_all"], ["", "end"], ["", "end"], ["", "context DFS_invar begin"], ["", "context begin"], ["", "interpretation timing_syntax"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma back_edge_impl_tree_path:\n    \"\\<lbrakk>(v,w) \\<in> back_edges s; v \\<noteq> w\\<rbrakk> \\<Longrightarrow> (w,v) \\<in> (tree_edges s)\\<^sup>+\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(v, w) \\<in> back_edges s; v \\<noteq> w\\<rbrakk>\n    \\<Longrightarrow> (w, v) \\<in> (tree_edges s)\\<^sup>+", "using i_back_edge_impl_tree_path[THEN make_invar_thm]"], ["proof (prove)\nusing this:\n  \\<forall>(v, w)\\<in>back_edges s.\n     (w, v) \\<in> (tree_edges s)\\<^sup>+ \\<or> w = v\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(v, w) \\<in> back_edges s; v \\<noteq> w\\<rbrakk>\n    \\<Longrightarrow> (w, v) \\<in> (tree_edges s)\\<^sup>+", "by blast"], ["", "lemma back_edge_disc:\n    assumes \"(v,w) \\<in> back_edges s\"\n    shows \"\\<delta> s w \\<le> \\<delta> s v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<delta> s w \\<le> \\<delta> s v", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> \\<delta> s w \\<le> \\<delta> s v\n 2. \\<not> ?P \\<Longrightarrow> \\<delta> s w \\<le> \\<delta> s v", "assume \"v\\<noteq>w\""], ["proof (state)\nthis:\n  v \\<noteq> w\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> \\<delta> s w \\<le> \\<delta> s v\n 2. \\<not> ?P \\<Longrightarrow> \\<delta> s w \\<le> \\<delta> s v", "with assms back_edge_impl_tree_path"], ["proof (chain)\npicking this:\n  (v, w) \\<in> back_edges s\n  \\<lbrakk>(?v, ?w) \\<in> back_edges s; ?v \\<noteq> ?w\\<rbrakk>\n  \\<Longrightarrow> (?w, ?v) \\<in> (tree_edges s)\\<^sup>+\n  v \\<noteq> w", "have \"(w,v) \\<in> (tree_edges s)\\<^sup>+\""], ["proof (prove)\nusing this:\n  (v, w) \\<in> back_edges s\n  \\<lbrakk>(?v, ?w) \\<in> back_edges s; ?v \\<noteq> ?w\\<rbrakk>\n  \\<Longrightarrow> (?w, ?v) \\<in> (tree_edges s)\\<^sup>+\n  v \\<noteq> w\n\ngoal (1 subgoal):\n 1. (w, v) \\<in> (tree_edges s)\\<^sup>+", "by simp"], ["proof (state)\nthis:\n  (w, v) \\<in> (tree_edges s)\\<^sup>+\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> \\<delta> s w \\<le> \\<delta> s v\n 2. \\<not> ?P \\<Longrightarrow> \\<delta> s w \\<le> \\<delta> s v", "with tree_path_disc"], ["proof (chain)\npicking this:\n  (?v, ?w) \\<in> (tree_edges s)\\<^sup>+ \\<Longrightarrow>\n  \\<delta> s ?v < \\<delta> s ?w\n  (w, v) \\<in> (tree_edges s)\\<^sup>+", "show ?thesis"], ["proof (prove)\nusing this:\n  (?v, ?w) \\<in> (tree_edges s)\\<^sup>+ \\<Longrightarrow>\n  \\<delta> s ?v < \\<delta> s ?w\n  (w, v) \\<in> (tree_edges s)\\<^sup>+\n\ngoal (1 subgoal):\n 1. \\<delta> s w \\<le> \\<delta> s v", "by force"], ["proof (state)\nthis:\n  \\<delta> s w \\<le> \\<delta> s v\n\ngoal (1 subgoal):\n 1. \\<not> v \\<noteq> w \\<Longrightarrow> \\<delta> s w \\<le> \\<delta> s v", "qed simp"], ["", "lemma back_edges_tree_disjoint:\n    \"back_edges s \\<inter> tree_edges s = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. back_edges s \\<inter> tree_edges s = {}", "using back_edge_disc tree_edge_disc"], ["proof (prove)\nusing this:\n  (?v, ?w) \\<in> back_edges s \\<Longrightarrow>\n  \\<delta> s ?w \\<le> \\<delta> s ?v\n  (?v, ?w) \\<in> tree_edges s \\<Longrightarrow>\n  \\<delta> s ?v < \\<delta> s ?w\n\ngoal (1 subgoal):\n 1. back_edges s \\<inter> tree_edges s = {}", "by force"], ["", "lemma back_edges_tree_pathes_disjoint:\n    \"back_edges s \\<inter> (tree_edges s)\\<^sup>+ = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. back_edges s \\<inter> (tree_edges s)\\<^sup>+ = {}", "using back_edge_disc tree_path_disc"], ["proof (prove)\nusing this:\n  (?v, ?w) \\<in> back_edges s \\<Longrightarrow>\n  \\<delta> s ?w \\<le> \\<delta> s ?v\n  (?v, ?w) \\<in> (tree_edges s)\\<^sup>+ \\<Longrightarrow>\n  \\<delta> s ?v < \\<delta> s ?w\n\ngoal (1 subgoal):\n 1. back_edges s \\<inter> (tree_edges s)\\<^sup>+ = {}", "by force"], ["", "lemma back_edge_finished:\n    assumes \"(v,w) \\<in> back_edges s\"\n    and \"w \\<in> dom (finished s)\"\n    shows \"v \\<in> dom (finished s) \\<and> \\<phi> s v \\<le> \\<phi> s w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> dom (finished s) \\<and> \\<phi> s v \\<le> \\<phi> s w", "proof (cases \"v=w\")"], ["proof (state)\ngoal (2 subgoals):\n 1. v = w \\<Longrightarrow>\n    v \\<in> dom (finished s) \\<and> \\<phi> s v \\<le> \\<phi> s w\n 2. v \\<noteq> w \\<Longrightarrow>\n    v \\<in> dom (finished s) \\<and> \\<phi> s v \\<le> \\<phi> s w", "case True"], ["proof (state)\nthis:\n  v = w\n\ngoal (2 subgoals):\n 1. v = w \\<Longrightarrow>\n    v \\<in> dom (finished s) \\<and> \\<phi> s v \\<le> \\<phi> s w\n 2. v \\<noteq> w \\<Longrightarrow>\n    v \\<in> dom (finished s) \\<and> \\<phi> s v \\<le> \\<phi> s w", "with assms"], ["proof (chain)\npicking this:\n  (v, w) \\<in> back_edges s\n  w \\<in> dom (finished s)\n  v = w", "show ?thesis"], ["proof (prove)\nusing this:\n  (v, w) \\<in> back_edges s\n  w \\<in> dom (finished s)\n  v = w\n\ngoal (1 subgoal):\n 1. v \\<in> dom (finished s) \\<and> \\<phi> s v \\<le> \\<phi> s w", "by simp"], ["proof (state)\nthis:\n  v \\<in> dom (finished s) \\<and> \\<phi> s v \\<le> \\<phi> s w\n\ngoal (1 subgoal):\n 1. v \\<noteq> w \\<Longrightarrow>\n    v \\<in> dom (finished s) \\<and> \\<phi> s v \\<le> \\<phi> s w", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. v \\<noteq> w \\<Longrightarrow>\n    v \\<in> dom (finished s) \\<and> \\<phi> s v \\<le> \\<phi> s w", "case False"], ["proof (state)\nthis:\n  v \\<noteq> w\n\ngoal (1 subgoal):\n 1. v \\<noteq> w \\<Longrightarrow>\n    v \\<in> dom (finished s) \\<and> \\<phi> s v \\<le> \\<phi> s w", "with back_edge_impl_tree_path assms"], ["proof (chain)\npicking this:\n  \\<lbrakk>(?v, ?w) \\<in> back_edges s; ?v \\<noteq> ?w\\<rbrakk>\n  \\<Longrightarrow> (?w, ?v) \\<in> (tree_edges s)\\<^sup>+\n  (v, w) \\<in> back_edges s\n  w \\<in> dom (finished s)\n  v \\<noteq> w", "have \"(w,v) \\<in> (tree_edges s)\\<^sup>+\""], ["proof (prove)\nusing this:\n  \\<lbrakk>(?v, ?w) \\<in> back_edges s; ?v \\<noteq> ?w\\<rbrakk>\n  \\<Longrightarrow> (?w, ?v) \\<in> (tree_edges s)\\<^sup>+\n  (v, w) \\<in> back_edges s\n  w \\<in> dom (finished s)\n  v \\<noteq> w\n\ngoal (1 subgoal):\n 1. (w, v) \\<in> (tree_edges s)\\<^sup>+", "by simp"], ["proof (state)\nthis:\n  (w, v) \\<in> (tree_edges s)\\<^sup>+\n\ngoal (1 subgoal):\n 1. v \\<noteq> w \\<Longrightarrow>\n    v \\<in> dom (finished s) \\<and> \\<phi> s v \\<le> \\<phi> s w", "with tree_path_impl_parenthesis assms"], ["proof (chain)\npicking this:\n  \\<lbrakk>(?v, ?w) \\<in> (tree_edges s)\\<^sup>+;\n   ?v \\<in> dom (finished s)\\<rbrakk>\n  \\<Longrightarrow> ?w \\<in> dom (finished s) \\<and>\n                    \\<delta> s ?v < \\<delta> s ?w \\<and>\n                    \\<phi> s ?w < \\<phi> s ?v\n  (v, w) \\<in> back_edges s\n  w \\<in> dom (finished s)\n  (w, v) \\<in> (tree_edges s)\\<^sup>+", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>(?v, ?w) \\<in> (tree_edges s)\\<^sup>+;\n   ?v \\<in> dom (finished s)\\<rbrakk>\n  \\<Longrightarrow> ?w \\<in> dom (finished s) \\<and>\n                    \\<delta> s ?v < \\<delta> s ?w \\<and>\n                    \\<phi> s ?w < \\<phi> s ?v\n  (v, w) \\<in> back_edges s\n  w \\<in> dom (finished s)\n  (w, v) \\<in> (tree_edges s)\\<^sup>+\n\ngoal (1 subgoal):\n 1. v \\<in> dom (finished s) \\<and> \\<phi> s v \\<le> \\<phi> s w", "by fastforce"], ["proof (state)\nthis:\n  v \\<in> dom (finished s) \\<and> \\<phi> s v \\<le> \\<phi> s w\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"], ["", "context param_DFS begin"], ["", "context begin"], ["", "interpretation timing_syntax"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "(* The lemma should probably replaced by:\n     is_invar (\\<lambda>s. \\<forall>(v,w) \\<in> (tree_edges s)\\<^sup>+. v \\<in> succ w \\<longrightarrow> (w,v) \\<in> back_edges s \\<or> (w,v) \\<in> pending s)\n  *)"], ["", "lemma i_disc_imp_back_edge_or_pending:\n    \"is_invar (\\<lambda>s. \\<forall>(v,w) \\<in> E. \n        v \\<in> dom (discovered s) \\<and> w \\<in> dom (discovered s)\n      \\<and> \\<delta> s v \\<ge> \\<delta> s w\n      \\<and> (w \\<in> dom (finished s) \\<longrightarrow> v \\<in> dom (finished s) \\<and> \\<phi> s w \\<ge> \\<phi> s v)\n      \\<longrightarrow> (v,w) \\<in> back_edges s \\<or> (v,w) \\<in> pending s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_invar\n     (\\<lambda>s.\n         \\<forall>(v, w)\\<in>E.\n            v \\<in> dom (discovered s) \\<and>\n            w \\<in> dom (discovered s) \\<and>\n            \\<delta> s w \\<le> \\<delta> s v \\<and>\n            (w \\<in> dom (finished s) \\<longrightarrow>\n             v \\<in> dom (finished s) \\<and>\n             \\<phi> s v \\<le> \\<phi> s w) \\<longrightarrow>\n            (v, w) \\<in> back_edges s \\<or> (v, w) \\<in> pending s)", "proof (induct rule: is_invarI_full)"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>e.\n       \\<forall>(v, w)\\<in>E.\n          v \\<in> dom (discovered (empty_state e)) \\<and>\n          w \\<in> dom (discovered (empty_state e)) \\<and>\n          \\<delta> (empty_state e) w \\<le> \\<delta> (empty_state e) v \\<and>\n          (w \\<in> dom (finished (empty_state e)) \\<longrightarrow>\n           v \\<in> dom (finished (empty_state e)) \\<and>\n           \\<phi> (empty_state e) v\n           \\<le> \\<phi> (empty_state e) w) \\<longrightarrow>\n          (v, w) \\<in> back_edges (empty_state e) \\<or>\n          (v, w) \\<in> pending (empty_state e)\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>\\<forall>(v, w)\\<in>E.\n                   v \\<in> dom (discovered s) \\<and>\n                   w \\<in> dom (discovered s) \\<and>\n                   \\<delta> s w \\<le> \\<delta> s v \\<and>\n                   (w \\<in> dom (finished s) \\<longrightarrow>\n                    v \\<in> dom (finished s) \\<and>\n                    \\<phi> s v \\<le> \\<phi> s w) \\<longrightarrow>\n                   (v, w) \\<in> back_edges s \\<or> (v, w) \\<in> pending s;\n        cond s; DFS_invar G param s; DFS_invar G param s'; stack s = [];\n        v0 \\<notin> dom (discovered s); v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, w)\\<in>E.\n                            v \\<in> dom (discovered s') \\<and>\n                            w \\<in> dom (discovered s') \\<and>\n                            \\<delta> s' w \\<le> \\<delta> s' v \\<and>\n                            (w \\<in> dom (finished s') \\<longrightarrow>\n                             v \\<in> dom (finished s') \\<and>\n                             \\<phi> s' v\n                             \\<le> \\<phi> s' w) \\<longrightarrow>\n                            (v, w) \\<in> back_edges s' \\<or>\n                            (v, w) \\<in> pending s'\n 3. \\<And>s s' u e.\n       \\<lbrakk>\\<forall>(v, w)\\<in>E.\n                   v \\<in> dom (discovered s) \\<and>\n                   w \\<in> dom (discovered s) \\<and>\n                   \\<delta> s w \\<le> \\<delta> s v \\<and>\n                   (w \\<in> dom (finished s) \\<longrightarrow>\n                    v \\<in> dom (finished s) \\<and>\n                    \\<phi> s v \\<le> \\<phi> s w) \\<longrightarrow>\n                   (v, w) \\<in> back_edges s \\<or> (v, w) \\<in> pending s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; pending s `` {u} = {}; u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, w)\\<in>E.\n                            v \\<in> dom (discovered s') \\<and>\n                            w \\<in> dom (discovered s') \\<and>\n                            \\<delta> s' w \\<le> \\<delta> s' v \\<and>\n                            (w \\<in> dom (finished s') \\<longrightarrow>\n                             v \\<in> dom (finished s') \\<and>\n                             \\<phi> s' v\n                             \\<le> \\<phi> s' w) \\<longrightarrow>\n                            (v, w) \\<in> back_edges s' \\<or>\n                            (v, w) \\<in> pending s'\n 4. \\<And>s s' u v e.\n       \\<lbrakk>\\<forall>(v, w)\\<in>E.\n                   v \\<in> dom (discovered s) \\<and>\n                   w \\<in> dom (discovered s) \\<and>\n                   \\<delta> s w \\<le> \\<delta> s v \\<and>\n                   (w \\<in> dom (finished s) \\<longrightarrow>\n                    v \\<in> dom (finished s) \\<and>\n                    \\<phi> s v \\<le> \\<phi> s w) \\<longrightarrow>\n                   (v, w) \\<in> back_edges s \\<or> (v, w) \\<in> pending s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        u = hd (stack s);\n        s' =\n        cross_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, w)\\<in>E.\n                            v \\<in> dom (discovered s') \\<and>\n                            w \\<in> dom (discovered s') \\<and>\n                            \\<delta> s' w \\<le> \\<delta> s' v \\<and>\n                            (w \\<in> dom (finished s') \\<longrightarrow>\n                             v \\<in> dom (finished s') \\<and>\n                             \\<phi> s' v\n                             \\<le> \\<phi> s' w) \\<longrightarrow>\n                            (v, w) \\<in> back_edges s' \\<or>\n                            (v, w) \\<in> pending s'\n 5. \\<And>s s' u v e.\n       \\<lbrakk>\\<forall>(v, w)\\<in>E.\n                   v \\<in> dom (discovered s) \\<and>\n                   w \\<in> dom (discovered s) \\<and>\n                   \\<delta> s w \\<le> \\<delta> s v \\<and>\n                   (w \\<in> dom (finished s) \\<longrightarrow>\n                    v \\<in> dom (finished s) \\<and>\n                    \\<phi> s v \\<le> \\<phi> s w) \\<longrightarrow>\n                   (v, w) \\<in> back_edges s \\<or> (v, w) \\<in> pending s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        u = hd (stack s);\n        s' =\n        back_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, w)\\<in>E.\n                            v \\<in> dom (discovered s') \\<and>\n                            w \\<in> dom (discovered s') \\<and>\n                            \\<delta> s' w \\<le> \\<delta> s' v \\<and>\n                            (w \\<in> dom (finished s') \\<longrightarrow>\n                             v \\<in> dom (finished s') \\<and>\n                             \\<phi> s' v\n                             \\<le> \\<phi> s' w) \\<longrightarrow>\n                            (v, w) \\<in> back_edges s' \\<or>\n                            (v, w) \\<in> pending s'\n 6. \\<And>s s' u v e.\n       \\<lbrakk>\\<forall>(v, w)\\<in>E.\n                   v \\<in> dom (discovered s) \\<and>\n                   w \\<in> dom (discovered s) \\<and>\n                   \\<delta> s w \\<le> \\<delta> s v \\<and>\n                   (w \\<in> dom (finished s) \\<longrightarrow>\n                    v \\<in> dom (finished s) \\<and>\n                    \\<phi> s v \\<le> \\<phi> s w) \\<longrightarrow>\n                   (v, w) \\<in> back_edges s \\<or> (v, w) \\<in> pending s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, w)\\<in>E.\n                            v \\<in> dom (discovered s') \\<and>\n                            w \\<in> dom (discovered s') \\<and>\n                            \\<delta> s' w \\<le> \\<delta> s' v \\<and>\n                            (w \\<in> dom (finished s') \\<longrightarrow>\n                             v \\<in> dom (finished s') \\<and>\n                             \\<phi> s' v\n                             \\<le> \\<phi> s' w) \\<longrightarrow>\n                            (v, w) \\<in> back_edges s' \\<or>\n                            (v, w) \\<in> pending s'", "case (cross_edge s s' u v)"], ["proof (state)\nthis:\n  \\<forall>(v, w)\\<in>E.\n     v \\<in> dom (discovered s) \\<and>\n     w \\<in> dom (discovered s) \\<and>\n     \\<delta> s w \\<le> \\<delta> s v \\<and>\n     (w \\<in> dom (finished s) \\<longrightarrow>\n      v \\<in> dom (finished s) \\<and>\n      \\<phi> s v \\<le> \\<phi> s w) \\<longrightarrow>\n     (v, w) \\<in> back_edges s \\<or> (v, w) \\<in> pending s\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s \\<noteq> []\n  v \\<in> pending s `` {u}\n  v \\<in> dom (discovered s)\n  v \\<in> dom (finished s)\n  u = hd (stack s)\n  s' = cross_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n  \\<lparr>state.more := e_\\<rparr>\n\ngoal (6 subgoals):\n 1. \\<And>e.\n       \\<forall>(v, w)\\<in>E.\n          v \\<in> dom (discovered (empty_state e)) \\<and>\n          w \\<in> dom (discovered (empty_state e)) \\<and>\n          \\<delta> (empty_state e) w \\<le> \\<delta> (empty_state e) v \\<and>\n          (w \\<in> dom (finished (empty_state e)) \\<longrightarrow>\n           v \\<in> dom (finished (empty_state e)) \\<and>\n           \\<phi> (empty_state e) v\n           \\<le> \\<phi> (empty_state e) w) \\<longrightarrow>\n          (v, w) \\<in> back_edges (empty_state e) \\<or>\n          (v, w) \\<in> pending (empty_state e)\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>\\<forall>(v, w)\\<in>E.\n                   v \\<in> dom (discovered s) \\<and>\n                   w \\<in> dom (discovered s) \\<and>\n                   \\<delta> s w \\<le> \\<delta> s v \\<and>\n                   (w \\<in> dom (finished s) \\<longrightarrow>\n                    v \\<in> dom (finished s) \\<and>\n                    \\<phi> s v \\<le> \\<phi> s w) \\<longrightarrow>\n                   (v, w) \\<in> back_edges s \\<or> (v, w) \\<in> pending s;\n        cond s; DFS_invar G param s; DFS_invar G param s'; stack s = [];\n        v0 \\<notin> dom (discovered s); v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, w)\\<in>E.\n                            v \\<in> dom (discovered s') \\<and>\n                            w \\<in> dom (discovered s') \\<and>\n                            \\<delta> s' w \\<le> \\<delta> s' v \\<and>\n                            (w \\<in> dom (finished s') \\<longrightarrow>\n                             v \\<in> dom (finished s') \\<and>\n                             \\<phi> s' v\n                             \\<le> \\<phi> s' w) \\<longrightarrow>\n                            (v, w) \\<in> back_edges s' \\<or>\n                            (v, w) \\<in> pending s'\n 3. \\<And>s s' u e.\n       \\<lbrakk>\\<forall>(v, w)\\<in>E.\n                   v \\<in> dom (discovered s) \\<and>\n                   w \\<in> dom (discovered s) \\<and>\n                   \\<delta> s w \\<le> \\<delta> s v \\<and>\n                   (w \\<in> dom (finished s) \\<longrightarrow>\n                    v \\<in> dom (finished s) \\<and>\n                    \\<phi> s v \\<le> \\<phi> s w) \\<longrightarrow>\n                   (v, w) \\<in> back_edges s \\<or> (v, w) \\<in> pending s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; pending s `` {u} = {}; u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, w)\\<in>E.\n                            v \\<in> dom (discovered s') \\<and>\n                            w \\<in> dom (discovered s') \\<and>\n                            \\<delta> s' w \\<le> \\<delta> s' v \\<and>\n                            (w \\<in> dom (finished s') \\<longrightarrow>\n                             v \\<in> dom (finished s') \\<and>\n                             \\<phi> s' v\n                             \\<le> \\<phi> s' w) \\<longrightarrow>\n                            (v, w) \\<in> back_edges s' \\<or>\n                            (v, w) \\<in> pending s'\n 4. \\<And>s s' u v e.\n       \\<lbrakk>\\<forall>(v, w)\\<in>E.\n                   v \\<in> dom (discovered s) \\<and>\n                   w \\<in> dom (discovered s) \\<and>\n                   \\<delta> s w \\<le> \\<delta> s v \\<and>\n                   (w \\<in> dom (finished s) \\<longrightarrow>\n                    v \\<in> dom (finished s) \\<and>\n                    \\<phi> s v \\<le> \\<phi> s w) \\<longrightarrow>\n                   (v, w) \\<in> back_edges s \\<or> (v, w) \\<in> pending s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        u = hd (stack s);\n        s' =\n        cross_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, w)\\<in>E.\n                            v \\<in> dom (discovered s') \\<and>\n                            w \\<in> dom (discovered s') \\<and>\n                            \\<delta> s' w \\<le> \\<delta> s' v \\<and>\n                            (w \\<in> dom (finished s') \\<longrightarrow>\n                             v \\<in> dom (finished s') \\<and>\n                             \\<phi> s' v\n                             \\<le> \\<phi> s' w) \\<longrightarrow>\n                            (v, w) \\<in> back_edges s' \\<or>\n                            (v, w) \\<in> pending s'\n 5. \\<And>s s' u v e.\n       \\<lbrakk>\\<forall>(v, w)\\<in>E.\n                   v \\<in> dom (discovered s) \\<and>\n                   w \\<in> dom (discovered s) \\<and>\n                   \\<delta> s w \\<le> \\<delta> s v \\<and>\n                   (w \\<in> dom (finished s) \\<longrightarrow>\n                    v \\<in> dom (finished s) \\<and>\n                    \\<phi> s v \\<le> \\<phi> s w) \\<longrightarrow>\n                   (v, w) \\<in> back_edges s \\<or> (v, w) \\<in> pending s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        u = hd (stack s);\n        s' =\n        back_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, w)\\<in>E.\n                            v \\<in> dom (discovered s') \\<and>\n                            w \\<in> dom (discovered s') \\<and>\n                            \\<delta> s' w \\<le> \\<delta> s' v \\<and>\n                            (w \\<in> dom (finished s') \\<longrightarrow>\n                             v \\<in> dom (finished s') \\<and>\n                             \\<phi> s' v\n                             \\<le> \\<phi> s' w) \\<longrightarrow>\n                            (v, w) \\<in> back_edges s' \\<or>\n                            (v, w) \\<in> pending s'\n 6. \\<And>s s' u v e.\n       \\<lbrakk>\\<forall>(v, w)\\<in>E.\n                   v \\<in> dom (discovered s) \\<and>\n                   w \\<in> dom (discovered s) \\<and>\n                   \\<delta> s w \\<le> \\<delta> s v \\<and>\n                   (w \\<in> dom (finished s) \\<longrightarrow>\n                    v \\<in> dom (finished s) \\<and>\n                    \\<phi> s v \\<le> \\<phi> s w) \\<longrightarrow>\n                   (v, w) \\<in> back_edges s \\<or> (v, w) \\<in> pending s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, w)\\<in>E.\n                            v \\<in> dom (discovered s') \\<and>\n                            w \\<in> dom (discovered s') \\<and>\n                            \\<delta> s' w \\<le> \\<delta> s' v \\<and>\n                            (w \\<in> dom (finished s') \\<longrightarrow>\n                             v \\<in> dom (finished s') \\<and>\n                             \\<phi> s' v\n                             \\<le> \\<phi> s' w) \\<longrightarrow>\n                            (v, w) \\<in> back_edges s' \\<or>\n                            (v, w) \\<in> pending s'", "then"], ["proof (chain)\npicking this:\n  \\<forall>(v, w)\\<in>E.\n     v \\<in> dom (discovered s) \\<and>\n     w \\<in> dom (discovered s) \\<and>\n     \\<delta> s w \\<le> \\<delta> s v \\<and>\n     (w \\<in> dom (finished s) \\<longrightarrow>\n      v \\<in> dom (finished s) \\<and>\n      \\<phi> s v \\<le> \\<phi> s w) \\<longrightarrow>\n     (v, w) \\<in> back_edges s \\<or> (v, w) \\<in> pending s\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s \\<noteq> []\n  v \\<in> pending s `` {u}\n  v \\<in> dom (discovered s)\n  v \\<in> dom (finished s)\n  u = hd (stack s)\n  s' = cross_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n  \\<lparr>state.more := e_\\<rparr>", "interpret DFS_invar where s=s"], ["proof (prove)\nusing this:\n  \\<forall>(v, w)\\<in>E.\n     v \\<in> dom (discovered s) \\<and>\n     w \\<in> dom (discovered s) \\<and>\n     \\<delta> s w \\<le> \\<delta> s v \\<and>\n     (w \\<in> dom (finished s) \\<longrightarrow>\n      v \\<in> dom (finished s) \\<and>\n      \\<phi> s v \\<le> \\<phi> s w) \\<longrightarrow>\n     (v, w) \\<in> back_edges s \\<or> (v, w) \\<in> pending s\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s \\<noteq> []\n  v \\<in> pending s `` {u}\n  v \\<in> dom (discovered s)\n  v \\<in> dom (finished s)\n  u = hd (stack s)\n  s' = cross_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n  \\<lparr>state.more := e_\\<rparr>\n\ngoal (1 subgoal):\n 1. DFS_invar G param s", "by simp"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>e.\n       \\<forall>(v, w)\\<in>E.\n          v \\<in> dom (discovered (empty_state e)) \\<and>\n          w \\<in> dom (discovered (empty_state e)) \\<and>\n          \\<delta> (empty_state e) w \\<le> \\<delta> (empty_state e) v \\<and>\n          (w \\<in> dom (finished (empty_state e)) \\<longrightarrow>\n           v \\<in> dom (finished (empty_state e)) \\<and>\n           \\<phi> (empty_state e) v\n           \\<le> \\<phi> (empty_state e) w) \\<longrightarrow>\n          (v, w) \\<in> back_edges (empty_state e) \\<or>\n          (v, w) \\<in> pending (empty_state e)\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>\\<forall>(v, w)\\<in>E.\n                   v \\<in> dom (discovered s) \\<and>\n                   w \\<in> dom (discovered s) \\<and>\n                   \\<delta> s w \\<le> \\<delta> s v \\<and>\n                   (w \\<in> dom (finished s) \\<longrightarrow>\n                    v \\<in> dom (finished s) \\<and>\n                    \\<phi> s v \\<le> \\<phi> s w) \\<longrightarrow>\n                   (v, w) \\<in> back_edges s \\<or> (v, w) \\<in> pending s;\n        cond s; DFS_invar G param s; DFS_invar G param s'; stack s = [];\n        v0 \\<notin> dom (discovered s); v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, w)\\<in>E.\n                            v \\<in> dom (discovered s') \\<and>\n                            w \\<in> dom (discovered s') \\<and>\n                            \\<delta> s' w \\<le> \\<delta> s' v \\<and>\n                            (w \\<in> dom (finished s') \\<longrightarrow>\n                             v \\<in> dom (finished s') \\<and>\n                             \\<phi> s' v\n                             \\<le> \\<phi> s' w) \\<longrightarrow>\n                            (v, w) \\<in> back_edges s' \\<or>\n                            (v, w) \\<in> pending s'\n 3. \\<And>s s' u e.\n       \\<lbrakk>\\<forall>(v, w)\\<in>E.\n                   v \\<in> dom (discovered s) \\<and>\n                   w \\<in> dom (discovered s) \\<and>\n                   \\<delta> s w \\<le> \\<delta> s v \\<and>\n                   (w \\<in> dom (finished s) \\<longrightarrow>\n                    v \\<in> dom (finished s) \\<and>\n                    \\<phi> s v \\<le> \\<phi> s w) \\<longrightarrow>\n                   (v, w) \\<in> back_edges s \\<or> (v, w) \\<in> pending s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; pending s `` {u} = {}; u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, w)\\<in>E.\n                            v \\<in> dom (discovered s') \\<and>\n                            w \\<in> dom (discovered s') \\<and>\n                            \\<delta> s' w \\<le> \\<delta> s' v \\<and>\n                            (w \\<in> dom (finished s') \\<longrightarrow>\n                             v \\<in> dom (finished s') \\<and>\n                             \\<phi> s' v\n                             \\<le> \\<phi> s' w) \\<longrightarrow>\n                            (v, w) \\<in> back_edges s' \\<or>\n                            (v, w) \\<in> pending s'\n 4. \\<And>s s' u v e.\n       \\<lbrakk>\\<forall>(v, w)\\<in>E.\n                   v \\<in> dom (discovered s) \\<and>\n                   w \\<in> dom (discovered s) \\<and>\n                   \\<delta> s w \\<le> \\<delta> s v \\<and>\n                   (w \\<in> dom (finished s) \\<longrightarrow>\n                    v \\<in> dom (finished s) \\<and>\n                    \\<phi> s v \\<le> \\<phi> s w) \\<longrightarrow>\n                   (v, w) \\<in> back_edges s \\<or> (v, w) \\<in> pending s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        u = hd (stack s);\n        s' =\n        cross_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, w)\\<in>E.\n                            v \\<in> dom (discovered s') \\<and>\n                            w \\<in> dom (discovered s') \\<and>\n                            \\<delta> s' w \\<le> \\<delta> s' v \\<and>\n                            (w \\<in> dom (finished s') \\<longrightarrow>\n                             v \\<in> dom (finished s') \\<and>\n                             \\<phi> s' v\n                             \\<le> \\<phi> s' w) \\<longrightarrow>\n                            (v, w) \\<in> back_edges s' \\<or>\n                            (v, w) \\<in> pending s'\n 5. \\<And>s s' u v e.\n       \\<lbrakk>\\<forall>(v, w)\\<in>E.\n                   v \\<in> dom (discovered s) \\<and>\n                   w \\<in> dom (discovered s) \\<and>\n                   \\<delta> s w \\<le> \\<delta> s v \\<and>\n                   (w \\<in> dom (finished s) \\<longrightarrow>\n                    v \\<in> dom (finished s) \\<and>\n                    \\<phi> s v \\<le> \\<phi> s w) \\<longrightarrow>\n                   (v, w) \\<in> back_edges s \\<or> (v, w) \\<in> pending s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        u = hd (stack s);\n        s' =\n        back_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, w)\\<in>E.\n                            v \\<in> dom (discovered s') \\<and>\n                            w \\<in> dom (discovered s') \\<and>\n                            \\<delta> s' w \\<le> \\<delta> s' v \\<and>\n                            (w \\<in> dom (finished s') \\<longrightarrow>\n                             v \\<in> dom (finished s') \\<and>\n                             \\<phi> s' v\n                             \\<le> \\<phi> s' w) \\<longrightarrow>\n                            (v, w) \\<in> back_edges s' \\<or>\n                            (v, w) \\<in> pending s'\n 6. \\<And>s s' u v e.\n       \\<lbrakk>\\<forall>(v, w)\\<in>E.\n                   v \\<in> dom (discovered s) \\<and>\n                   w \\<in> dom (discovered s) \\<and>\n                   \\<delta> s w \\<le> \\<delta> s v \\<and>\n                   (w \\<in> dom (finished s) \\<longrightarrow>\n                    v \\<in> dom (finished s) \\<and>\n                    \\<phi> s v \\<le> \\<phi> s w) \\<longrightarrow>\n                   (v, w) \\<in> back_edges s \\<or> (v, w) \\<in> pending s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, w)\\<in>E.\n                            v \\<in> dom (discovered s') \\<and>\n                            w \\<in> dom (discovered s') \\<and>\n                            \\<delta> s' w \\<le> \\<delta> s' v \\<and>\n                            (w \\<in> dom (finished s') \\<longrightarrow>\n                             v \\<in> dom (finished s') \\<and>\n                             \\<phi> s' v\n                             \\<le> \\<phi> s' w) \\<longrightarrow>\n                            (v, w) \\<in> back_edges s' \\<or>\n                            (v, w) \\<in> pending s'", "from cross_edge stack_not_finished[of u]"], ["proof (chain)\npicking this:\n  \\<forall>(v, w)\\<in>E.\n     v \\<in> dom (discovered s) \\<and>\n     w \\<in> dom (discovered s) \\<and>\n     \\<delta> s w \\<le> \\<delta> s v \\<and>\n     (w \\<in> dom (finished s) \\<longrightarrow>\n      v \\<in> dom (finished s) \\<and>\n      \\<phi> s v \\<le> \\<phi> s w) \\<longrightarrow>\n     (v, w) \\<in> back_edges s \\<or> (v, w) \\<in> pending s\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s \\<noteq> []\n  v \\<in> pending s `` {u}\n  v \\<in> dom (discovered s)\n  v \\<in> dom (finished s)\n  u = hd (stack s)\n  s' = cross_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n  \\<lparr>state.more := e_\\<rparr>\n  u \\<in> set (stack s) \\<Longrightarrow> u \\<notin> dom (finished s)", "have \"u \\<notin> dom (finished s)\""], ["proof (prove)\nusing this:\n  \\<forall>(v, w)\\<in>E.\n     v \\<in> dom (discovered s) \\<and>\n     w \\<in> dom (discovered s) \\<and>\n     \\<delta> s w \\<le> \\<delta> s v \\<and>\n     (w \\<in> dom (finished s) \\<longrightarrow>\n      v \\<in> dom (finished s) \\<and>\n      \\<phi> s v \\<le> \\<phi> s w) \\<longrightarrow>\n     (v, w) \\<in> back_edges s \\<or> (v, w) \\<in> pending s\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s \\<noteq> []\n  v \\<in> pending s `` {u}\n  v \\<in> dom (discovered s)\n  v \\<in> dom (finished s)\n  u = hd (stack s)\n  s' = cross_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n  \\<lparr>state.more := e_\\<rparr>\n  u \\<in> set (stack s) \\<Longrightarrow> u \\<notin> dom (finished s)\n\ngoal (1 subgoal):\n 1. u \\<notin> dom (finished s)", "using hd_in_set"], ["proof (prove)\nusing this:\n  \\<forall>(v, w)\\<in>E.\n     v \\<in> dom (discovered s) \\<and>\n     w \\<in> dom (discovered s) \\<and>\n     \\<delta> s w \\<le> \\<delta> s v \\<and>\n     (w \\<in> dom (finished s) \\<longrightarrow>\n      v \\<in> dom (finished s) \\<and>\n      \\<phi> s v \\<le> \\<phi> s w) \\<longrightarrow>\n     (v, w) \\<in> back_edges s \\<or> (v, w) \\<in> pending s\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s \\<noteq> []\n  v \\<in> pending s `` {u}\n  v \\<in> dom (discovered s)\n  v \\<in> dom (finished s)\n  u = hd (stack s)\n  s' = cross_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n  \\<lparr>state.more := e_\\<rparr>\n  u \\<in> set (stack s) \\<Longrightarrow> u \\<notin> dom (finished s)\n  ?xs \\<noteq> [] \\<Longrightarrow> hd ?xs \\<in> set ?xs\n\ngoal (1 subgoal):\n 1. u \\<notin> dom (finished s)", "by (auto simp add: cond_alt)"], ["proof (state)\nthis:\n  u \\<notin> dom (finished s)\n\ngoal (6 subgoals):\n 1. \\<And>e.\n       \\<forall>(v, w)\\<in>E.\n          v \\<in> dom (discovered (empty_state e)) \\<and>\n          w \\<in> dom (discovered (empty_state e)) \\<and>\n          \\<delta> (empty_state e) w \\<le> \\<delta> (empty_state e) v \\<and>\n          (w \\<in> dom (finished (empty_state e)) \\<longrightarrow>\n           v \\<in> dom (finished (empty_state e)) \\<and>\n           \\<phi> (empty_state e) v\n           \\<le> \\<phi> (empty_state e) w) \\<longrightarrow>\n          (v, w) \\<in> back_edges (empty_state e) \\<or>\n          (v, w) \\<in> pending (empty_state e)\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>\\<forall>(v, w)\\<in>E.\n                   v \\<in> dom (discovered s) \\<and>\n                   w \\<in> dom (discovered s) \\<and>\n                   \\<delta> s w \\<le> \\<delta> s v \\<and>\n                   (w \\<in> dom (finished s) \\<longrightarrow>\n                    v \\<in> dom (finished s) \\<and>\n                    \\<phi> s v \\<le> \\<phi> s w) \\<longrightarrow>\n                   (v, w) \\<in> back_edges s \\<or> (v, w) \\<in> pending s;\n        cond s; DFS_invar G param s; DFS_invar G param s'; stack s = [];\n        v0 \\<notin> dom (discovered s); v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, w)\\<in>E.\n                            v \\<in> dom (discovered s') \\<and>\n                            w \\<in> dom (discovered s') \\<and>\n                            \\<delta> s' w \\<le> \\<delta> s' v \\<and>\n                            (w \\<in> dom (finished s') \\<longrightarrow>\n                             v \\<in> dom (finished s') \\<and>\n                             \\<phi> s' v\n                             \\<le> \\<phi> s' w) \\<longrightarrow>\n                            (v, w) \\<in> back_edges s' \\<or>\n                            (v, w) \\<in> pending s'\n 3. \\<And>s s' u e.\n       \\<lbrakk>\\<forall>(v, w)\\<in>E.\n                   v \\<in> dom (discovered s) \\<and>\n                   w \\<in> dom (discovered s) \\<and>\n                   \\<delta> s w \\<le> \\<delta> s v \\<and>\n                   (w \\<in> dom (finished s) \\<longrightarrow>\n                    v \\<in> dom (finished s) \\<and>\n                    \\<phi> s v \\<le> \\<phi> s w) \\<longrightarrow>\n                   (v, w) \\<in> back_edges s \\<or> (v, w) \\<in> pending s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; pending s `` {u} = {}; u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, w)\\<in>E.\n                            v \\<in> dom (discovered s') \\<and>\n                            w \\<in> dom (discovered s') \\<and>\n                            \\<delta> s' w \\<le> \\<delta> s' v \\<and>\n                            (w \\<in> dom (finished s') \\<longrightarrow>\n                             v \\<in> dom (finished s') \\<and>\n                             \\<phi> s' v\n                             \\<le> \\<phi> s' w) \\<longrightarrow>\n                            (v, w) \\<in> back_edges s' \\<or>\n                            (v, w) \\<in> pending s'\n 4. \\<And>s s' u v e.\n       \\<lbrakk>\\<forall>(v, w)\\<in>E.\n                   v \\<in> dom (discovered s) \\<and>\n                   w \\<in> dom (discovered s) \\<and>\n                   \\<delta> s w \\<le> \\<delta> s v \\<and>\n                   (w \\<in> dom (finished s) \\<longrightarrow>\n                    v \\<in> dom (finished s) \\<and>\n                    \\<phi> s v \\<le> \\<phi> s w) \\<longrightarrow>\n                   (v, w) \\<in> back_edges s \\<or> (v, w) \\<in> pending s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        u = hd (stack s);\n        s' =\n        cross_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, w)\\<in>E.\n                            v \\<in> dom (discovered s') \\<and>\n                            w \\<in> dom (discovered s') \\<and>\n                            \\<delta> s' w \\<le> \\<delta> s' v \\<and>\n                            (w \\<in> dom (finished s') \\<longrightarrow>\n                             v \\<in> dom (finished s') \\<and>\n                             \\<phi> s' v\n                             \\<le> \\<phi> s' w) \\<longrightarrow>\n                            (v, w) \\<in> back_edges s' \\<or>\n                            (v, w) \\<in> pending s'\n 5. \\<And>s s' u v e.\n       \\<lbrakk>\\<forall>(v, w)\\<in>E.\n                   v \\<in> dom (discovered s) \\<and>\n                   w \\<in> dom (discovered s) \\<and>\n                   \\<delta> s w \\<le> \\<delta> s v \\<and>\n                   (w \\<in> dom (finished s) \\<longrightarrow>\n                    v \\<in> dom (finished s) \\<and>\n                    \\<phi> s v \\<le> \\<phi> s w) \\<longrightarrow>\n                   (v, w) \\<in> back_edges s \\<or> (v, w) \\<in> pending s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        u = hd (stack s);\n        s' =\n        back_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, w)\\<in>E.\n                            v \\<in> dom (discovered s') \\<and>\n                            w \\<in> dom (discovered s') \\<and>\n                            \\<delta> s' w \\<le> \\<delta> s' v \\<and>\n                            (w \\<in> dom (finished s') \\<longrightarrow>\n                             v \\<in> dom (finished s') \\<and>\n                             \\<phi> s' v\n                             \\<le> \\<phi> s' w) \\<longrightarrow>\n                            (v, w) \\<in> back_edges s' \\<or>\n                            (v, w) \\<in> pending s'\n 6. \\<And>s s' u v e.\n       \\<lbrakk>\\<forall>(v, w)\\<in>E.\n                   v \\<in> dom (discovered s) \\<and>\n                   w \\<in> dom (discovered s) \\<and>\n                   \\<delta> s w \\<le> \\<delta> s v \\<and>\n                   (w \\<in> dom (finished s) \\<longrightarrow>\n                    v \\<in> dom (finished s) \\<and>\n                    \\<phi> s v \\<le> \\<phi> s w) \\<longrightarrow>\n                   (v, w) \\<in> back_edges s \\<or> (v, w) \\<in> pending s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, w)\\<in>E.\n                            v \\<in> dom (discovered s') \\<and>\n                            w \\<in> dom (discovered s') \\<and>\n                            \\<delta> s' w \\<le> \\<delta> s' v \\<and>\n                            (w \\<in> dom (finished s') \\<longrightarrow>\n                             v \\<in> dom (finished s') \\<and>\n                             \\<phi> s' v\n                             \\<le> \\<phi> s' w) \\<longrightarrow>\n                            (v, w) \\<in> back_edges s' \\<or>\n                            (v, w) \\<in> pending s'", "with cross_edge"], ["proof (chain)\npicking this:\n  \\<forall>(v, w)\\<in>E.\n     v \\<in> dom (discovered s) \\<and>\n     w \\<in> dom (discovered s) \\<and>\n     \\<delta> s w \\<le> \\<delta> s v \\<and>\n     (w \\<in> dom (finished s) \\<longrightarrow>\n      v \\<in> dom (finished s) \\<and>\n      \\<phi> s v \\<le> \\<phi> s w) \\<longrightarrow>\n     (v, w) \\<in> back_edges s \\<or> (v, w) \\<in> pending s\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s \\<noteq> []\n  v \\<in> pending s `` {u}\n  v \\<in> dom (discovered s)\n  v \\<in> dom (finished s)\n  u = hd (stack s)\n  s' = cross_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n  \\<lparr>state.more := e_\\<rparr>\n  u \\<notin> dom (finished s)", "show ?case"], ["proof (prove)\nusing this:\n  \\<forall>(v, w)\\<in>E.\n     v \\<in> dom (discovered s) \\<and>\n     w \\<in> dom (discovered s) \\<and>\n     \\<delta> s w \\<le> \\<delta> s v \\<and>\n     (w \\<in> dom (finished s) \\<longrightarrow>\n      v \\<in> dom (finished s) \\<and>\n      \\<phi> s v \\<le> \\<phi> s w) \\<longrightarrow>\n     (v, w) \\<in> back_edges s \\<or> (v, w) \\<in> pending s\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s \\<noteq> []\n  v \\<in> pending s `` {u}\n  v \\<in> dom (discovered s)\n  v \\<in> dom (finished s)\n  u = hd (stack s)\n  s' = cross_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n  \\<lparr>state.more := e_\\<rparr>\n  u \\<notin> dom (finished s)\n\ngoal (1 subgoal):\n 1. \\<forall>(v, w)\\<in>E.\n       v \\<in> dom (discovered s') \\<and>\n       w \\<in> dom (discovered s') \\<and>\n       \\<delta> s' w \\<le> \\<delta> s' v \\<and>\n       (w \\<in> dom (finished s') \\<longrightarrow>\n        v \\<in> dom (finished s') \\<and>\n        \\<phi> s' v \\<le> \\<phi> s' w) \\<longrightarrow>\n       (v, w) \\<in> back_edges s' \\<or> (v, w) \\<in> pending s'", "by auto"], ["proof (state)\nthis:\n  \\<forall>(v, w)\\<in>E.\n     v \\<in> dom (discovered s') \\<and>\n     w \\<in> dom (discovered s') \\<and>\n     \\<delta> s' w \\<le> \\<delta> s' v \\<and>\n     (w \\<in> dom (finished s') \\<longrightarrow>\n      v \\<in> dom (finished s') \\<and>\n      \\<phi> s' v \\<le> \\<phi> s' w) \\<longrightarrow>\n     (v, w) \\<in> back_edges s' \\<or> (v, w) \\<in> pending s'\n\ngoal (5 subgoals):\n 1. \\<And>e.\n       \\<forall>(v, w)\\<in>E.\n          v \\<in> dom (discovered (empty_state e)) \\<and>\n          w \\<in> dom (discovered (empty_state e)) \\<and>\n          \\<delta> (empty_state e) w \\<le> \\<delta> (empty_state e) v \\<and>\n          (w \\<in> dom (finished (empty_state e)) \\<longrightarrow>\n           v \\<in> dom (finished (empty_state e)) \\<and>\n           \\<phi> (empty_state e) v\n           \\<le> \\<phi> (empty_state e) w) \\<longrightarrow>\n          (v, w) \\<in> back_edges (empty_state e) \\<or>\n          (v, w) \\<in> pending (empty_state e)\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>\\<forall>(v, w)\\<in>E.\n                   v \\<in> dom (discovered s) \\<and>\n                   w \\<in> dom (discovered s) \\<and>\n                   \\<delta> s w \\<le> \\<delta> s v \\<and>\n                   (w \\<in> dom (finished s) \\<longrightarrow>\n                    v \\<in> dom (finished s) \\<and>\n                    \\<phi> s v \\<le> \\<phi> s w) \\<longrightarrow>\n                   (v, w) \\<in> back_edges s \\<or> (v, w) \\<in> pending s;\n        cond s; DFS_invar G param s; DFS_invar G param s'; stack s = [];\n        v0 \\<notin> dom (discovered s); v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, w)\\<in>E.\n                            v \\<in> dom (discovered s') \\<and>\n                            w \\<in> dom (discovered s') \\<and>\n                            \\<delta> s' w \\<le> \\<delta> s' v \\<and>\n                            (w \\<in> dom (finished s') \\<longrightarrow>\n                             v \\<in> dom (finished s') \\<and>\n                             \\<phi> s' v\n                             \\<le> \\<phi> s' w) \\<longrightarrow>\n                            (v, w) \\<in> back_edges s' \\<or>\n                            (v, w) \\<in> pending s'\n 3. \\<And>s s' u e.\n       \\<lbrakk>\\<forall>(v, w)\\<in>E.\n                   v \\<in> dom (discovered s) \\<and>\n                   w \\<in> dom (discovered s) \\<and>\n                   \\<delta> s w \\<le> \\<delta> s v \\<and>\n                   (w \\<in> dom (finished s) \\<longrightarrow>\n                    v \\<in> dom (finished s) \\<and>\n                    \\<phi> s v \\<le> \\<phi> s w) \\<longrightarrow>\n                   (v, w) \\<in> back_edges s \\<or> (v, w) \\<in> pending s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; pending s `` {u} = {}; u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, w)\\<in>E.\n                            v \\<in> dom (discovered s') \\<and>\n                            w \\<in> dom (discovered s') \\<and>\n                            \\<delta> s' w \\<le> \\<delta> s' v \\<and>\n                            (w \\<in> dom (finished s') \\<longrightarrow>\n                             v \\<in> dom (finished s') \\<and>\n                             \\<phi> s' v\n                             \\<le> \\<phi> s' w) \\<longrightarrow>\n                            (v, w) \\<in> back_edges s' \\<or>\n                            (v, w) \\<in> pending s'\n 4. \\<And>s s' u v e.\n       \\<lbrakk>\\<forall>(v, w)\\<in>E.\n                   v \\<in> dom (discovered s) \\<and>\n                   w \\<in> dom (discovered s) \\<and>\n                   \\<delta> s w \\<le> \\<delta> s v \\<and>\n                   (w \\<in> dom (finished s) \\<longrightarrow>\n                    v \\<in> dom (finished s) \\<and>\n                    \\<phi> s v \\<le> \\<phi> s w) \\<longrightarrow>\n                   (v, w) \\<in> back_edges s \\<or> (v, w) \\<in> pending s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        u = hd (stack s);\n        s' =\n        back_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, w)\\<in>E.\n                            v \\<in> dom (discovered s') \\<and>\n                            w \\<in> dom (discovered s') \\<and>\n                            \\<delta> s' w \\<le> \\<delta> s' v \\<and>\n                            (w \\<in> dom (finished s') \\<longrightarrow>\n                             v \\<in> dom (finished s') \\<and>\n                             \\<phi> s' v\n                             \\<le> \\<phi> s' w) \\<longrightarrow>\n                            (v, w) \\<in> back_edges s' \\<or>\n                            (v, w) \\<in> pending s'\n 5. \\<And>s s' u v e.\n       \\<lbrakk>\\<forall>(v, w)\\<in>E.\n                   v \\<in> dom (discovered s) \\<and>\n                   w \\<in> dom (discovered s) \\<and>\n                   \\<delta> s w \\<le> \\<delta> s v \\<and>\n                   (w \\<in> dom (finished s) \\<longrightarrow>\n                    v \\<in> dom (finished s) \\<and>\n                    \\<phi> s v \\<le> \\<phi> s w) \\<longrightarrow>\n                   (v, w) \\<in> back_edges s \\<or> (v, w) \\<in> pending s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, w)\\<in>E.\n                            v \\<in> dom (discovered s') \\<and>\n                            w \\<in> dom (discovered s') \\<and>\n                            \\<delta> s' w \\<le> \\<delta> s' v \\<and>\n                            (w \\<in> dom (finished s') \\<longrightarrow>\n                             v \\<in> dom (finished s') \\<and>\n                             \\<phi> s' v\n                             \\<le> \\<phi> s' w) \\<longrightarrow>\n                            (v, w) \\<in> back_edges s' \\<or>\n                            (v, w) \\<in> pending s'", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>e.\n       \\<forall>(v, w)\\<in>E.\n          v \\<in> dom (discovered (empty_state e)) \\<and>\n          w \\<in> dom (discovered (empty_state e)) \\<and>\n          \\<delta> (empty_state e) w \\<le> \\<delta> (empty_state e) v \\<and>\n          (w \\<in> dom (finished (empty_state e)) \\<longrightarrow>\n           v \\<in> dom (finished (empty_state e)) \\<and>\n           \\<phi> (empty_state e) v\n           \\<le> \\<phi> (empty_state e) w) \\<longrightarrow>\n          (v, w) \\<in> back_edges (empty_state e) \\<or>\n          (v, w) \\<in> pending (empty_state e)\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>\\<forall>(v, w)\\<in>E.\n                   v \\<in> dom (discovered s) \\<and>\n                   w \\<in> dom (discovered s) \\<and>\n                   \\<delta> s w \\<le> \\<delta> s v \\<and>\n                   (w \\<in> dom (finished s) \\<longrightarrow>\n                    v \\<in> dom (finished s) \\<and>\n                    \\<phi> s v \\<le> \\<phi> s w) \\<longrightarrow>\n                   (v, w) \\<in> back_edges s \\<or> (v, w) \\<in> pending s;\n        cond s; DFS_invar G param s; DFS_invar G param s'; stack s = [];\n        v0 \\<notin> dom (discovered s); v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, w)\\<in>E.\n                            v \\<in> dom (discovered s') \\<and>\n                            w \\<in> dom (discovered s') \\<and>\n                            \\<delta> s' w \\<le> \\<delta> s' v \\<and>\n                            (w \\<in> dom (finished s') \\<longrightarrow>\n                             v \\<in> dom (finished s') \\<and>\n                             \\<phi> s' v\n                             \\<le> \\<phi> s' w) \\<longrightarrow>\n                            (v, w) \\<in> back_edges s' \\<or>\n                            (v, w) \\<in> pending s'\n 3. \\<And>s s' u e.\n       \\<lbrakk>\\<forall>(v, w)\\<in>E.\n                   v \\<in> dom (discovered s) \\<and>\n                   w \\<in> dom (discovered s) \\<and>\n                   \\<delta> s w \\<le> \\<delta> s v \\<and>\n                   (w \\<in> dom (finished s) \\<longrightarrow>\n                    v \\<in> dom (finished s) \\<and>\n                    \\<phi> s v \\<le> \\<phi> s w) \\<longrightarrow>\n                   (v, w) \\<in> back_edges s \\<or> (v, w) \\<in> pending s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; pending s `` {u} = {}; u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, w)\\<in>E.\n                            v \\<in> dom (discovered s') \\<and>\n                            w \\<in> dom (discovered s') \\<and>\n                            \\<delta> s' w \\<le> \\<delta> s' v \\<and>\n                            (w \\<in> dom (finished s') \\<longrightarrow>\n                             v \\<in> dom (finished s') \\<and>\n                             \\<phi> s' v\n                             \\<le> \\<phi> s' w) \\<longrightarrow>\n                            (v, w) \\<in> back_edges s' \\<or>\n                            (v, w) \\<in> pending s'\n 4. \\<And>s s' u v e.\n       \\<lbrakk>\\<forall>(v, w)\\<in>E.\n                   v \\<in> dom (discovered s) \\<and>\n                   w \\<in> dom (discovered s) \\<and>\n                   \\<delta> s w \\<le> \\<delta> s v \\<and>\n                   (w \\<in> dom (finished s) \\<longrightarrow>\n                    v \\<in> dom (finished s) \\<and>\n                    \\<phi> s v \\<le> \\<phi> s w) \\<longrightarrow>\n                   (v, w) \\<in> back_edges s \\<or> (v, w) \\<in> pending s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        u = hd (stack s);\n        s' =\n        back_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, w)\\<in>E.\n                            v \\<in> dom (discovered s') \\<and>\n                            w \\<in> dom (discovered s') \\<and>\n                            \\<delta> s' w \\<le> \\<delta> s' v \\<and>\n                            (w \\<in> dom (finished s') \\<longrightarrow>\n                             v \\<in> dom (finished s') \\<and>\n                             \\<phi> s' v\n                             \\<le> \\<phi> s' w) \\<longrightarrow>\n                            (v, w) \\<in> back_edges s' \\<or>\n                            (v, w) \\<in> pending s'\n 5. \\<And>s s' u v e.\n       \\<lbrakk>\\<forall>(v, w)\\<in>E.\n                   v \\<in> dom (discovered s) \\<and>\n                   w \\<in> dom (discovered s) \\<and>\n                   \\<delta> s w \\<le> \\<delta> s v \\<and>\n                   (w \\<in> dom (finished s) \\<longrightarrow>\n                    v \\<in> dom (finished s) \\<and>\n                    \\<phi> s v \\<le> \\<phi> s w) \\<longrightarrow>\n                   (v, w) \\<in> back_edges s \\<or> (v, w) \\<in> pending s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, w)\\<in>E.\n                            v \\<in> dom (discovered s') \\<and>\n                            w \\<in> dom (discovered s') \\<and>\n                            \\<delta> s' w \\<le> \\<delta> s' v \\<and>\n                            (w \\<in> dom (finished s') \\<longrightarrow>\n                             v \\<in> dom (finished s') \\<and>\n                             \\<phi> s' v\n                             \\<le> \\<phi> s' w) \\<longrightarrow>\n                            (v, w) \\<in> back_edges s' \\<or>\n                            (v, w) \\<in> pending s'", "case (finish s s' u v)"], ["proof (state)\nthis:\n  \\<forall>(v, w)\\<in>E.\n     v \\<in> dom (discovered s) \\<and>\n     w \\<in> dom (discovered s) \\<and>\n     \\<delta> s w \\<le> \\<delta> s v \\<and>\n     (w \\<in> dom (finished s) \\<longrightarrow>\n      v \\<in> dom (finished s) \\<and>\n      \\<phi> s v \\<le> \\<phi> s w) \\<longrightarrow>\n     (v, w) \\<in> back_edges s \\<or> (v, w) \\<in> pending s\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s \\<noteq> []\n  pending s `` {u} = {}\n  u = hd (stack s)\n  s' = finish u s\\<lparr>state.more := v\\<rparr>\n\ngoal (5 subgoals):\n 1. \\<And>e.\n       \\<forall>(v, w)\\<in>E.\n          v \\<in> dom (discovered (empty_state e)) \\<and>\n          w \\<in> dom (discovered (empty_state e)) \\<and>\n          \\<delta> (empty_state e) w \\<le> \\<delta> (empty_state e) v \\<and>\n          (w \\<in> dom (finished (empty_state e)) \\<longrightarrow>\n           v \\<in> dom (finished (empty_state e)) \\<and>\n           \\<phi> (empty_state e) v\n           \\<le> \\<phi> (empty_state e) w) \\<longrightarrow>\n          (v, w) \\<in> back_edges (empty_state e) \\<or>\n          (v, w) \\<in> pending (empty_state e)\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>\\<forall>(v, w)\\<in>E.\n                   v \\<in> dom (discovered s) \\<and>\n                   w \\<in> dom (discovered s) \\<and>\n                   \\<delta> s w \\<le> \\<delta> s v \\<and>\n                   (w \\<in> dom (finished s) \\<longrightarrow>\n                    v \\<in> dom (finished s) \\<and>\n                    \\<phi> s v \\<le> \\<phi> s w) \\<longrightarrow>\n                   (v, w) \\<in> back_edges s \\<or> (v, w) \\<in> pending s;\n        cond s; DFS_invar G param s; DFS_invar G param s'; stack s = [];\n        v0 \\<notin> dom (discovered s); v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, w)\\<in>E.\n                            v \\<in> dom (discovered s') \\<and>\n                            w \\<in> dom (discovered s') \\<and>\n                            \\<delta> s' w \\<le> \\<delta> s' v \\<and>\n                            (w \\<in> dom (finished s') \\<longrightarrow>\n                             v \\<in> dom (finished s') \\<and>\n                             \\<phi> s' v\n                             \\<le> \\<phi> s' w) \\<longrightarrow>\n                            (v, w) \\<in> back_edges s' \\<or>\n                            (v, w) \\<in> pending s'\n 3. \\<And>s s' u e.\n       \\<lbrakk>\\<forall>(v, w)\\<in>E.\n                   v \\<in> dom (discovered s) \\<and>\n                   w \\<in> dom (discovered s) \\<and>\n                   \\<delta> s w \\<le> \\<delta> s v \\<and>\n                   (w \\<in> dom (finished s) \\<longrightarrow>\n                    v \\<in> dom (finished s) \\<and>\n                    \\<phi> s v \\<le> \\<phi> s w) \\<longrightarrow>\n                   (v, w) \\<in> back_edges s \\<or> (v, w) \\<in> pending s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; pending s `` {u} = {}; u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, w)\\<in>E.\n                            v \\<in> dom (discovered s') \\<and>\n                            w \\<in> dom (discovered s') \\<and>\n                            \\<delta> s' w \\<le> \\<delta> s' v \\<and>\n                            (w \\<in> dom (finished s') \\<longrightarrow>\n                             v \\<in> dom (finished s') \\<and>\n                             \\<phi> s' v\n                             \\<le> \\<phi> s' w) \\<longrightarrow>\n                            (v, w) \\<in> back_edges s' \\<or>\n                            (v, w) \\<in> pending s'\n 4. \\<And>s s' u v e.\n       \\<lbrakk>\\<forall>(v, w)\\<in>E.\n                   v \\<in> dom (discovered s) \\<and>\n                   w \\<in> dom (discovered s) \\<and>\n                   \\<delta> s w \\<le> \\<delta> s v \\<and>\n                   (w \\<in> dom (finished s) \\<longrightarrow>\n                    v \\<in> dom (finished s) \\<and>\n                    \\<phi> s v \\<le> \\<phi> s w) \\<longrightarrow>\n                   (v, w) \\<in> back_edges s \\<or> (v, w) \\<in> pending s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        u = hd (stack s);\n        s' =\n        back_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, w)\\<in>E.\n                            v \\<in> dom (discovered s') \\<and>\n                            w \\<in> dom (discovered s') \\<and>\n                            \\<delta> s' w \\<le> \\<delta> s' v \\<and>\n                            (w \\<in> dom (finished s') \\<longrightarrow>\n                             v \\<in> dom (finished s') \\<and>\n                             \\<phi> s' v\n                             \\<le> \\<phi> s' w) \\<longrightarrow>\n                            (v, w) \\<in> back_edges s' \\<or>\n                            (v, w) \\<in> pending s'\n 5. \\<And>s s' u v e.\n       \\<lbrakk>\\<forall>(v, w)\\<in>E.\n                   v \\<in> dom (discovered s) \\<and>\n                   w \\<in> dom (discovered s) \\<and>\n                   \\<delta> s w \\<le> \\<delta> s v \\<and>\n                   (w \\<in> dom (finished s) \\<longrightarrow>\n                    v \\<in> dom (finished s) \\<and>\n                    \\<phi> s v \\<le> \\<phi> s w) \\<longrightarrow>\n                   (v, w) \\<in> back_edges s \\<or> (v, w) \\<in> pending s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, w)\\<in>E.\n                            v \\<in> dom (discovered s') \\<and>\n                            w \\<in> dom (discovered s') \\<and>\n                            \\<delta> s' w \\<le> \\<delta> s' v \\<and>\n                            (w \\<in> dom (finished s') \\<longrightarrow>\n                             v \\<in> dom (finished s') \\<and>\n                             \\<phi> s' v\n                             \\<le> \\<phi> s' w) \\<longrightarrow>\n                            (v, w) \\<in> back_edges s' \\<or>\n                            (v, w) \\<in> pending s'", "then"], ["proof (chain)\npicking this:\n  \\<forall>(v, w)\\<in>E.\n     v \\<in> dom (discovered s) \\<and>\n     w \\<in> dom (discovered s) \\<and>\n     \\<delta> s w \\<le> \\<delta> s v \\<and>\n     (w \\<in> dom (finished s) \\<longrightarrow>\n      v \\<in> dom (finished s) \\<and>\n      \\<phi> s v \\<le> \\<phi> s w) \\<longrightarrow>\n     (v, w) \\<in> back_edges s \\<or> (v, w) \\<in> pending s\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s \\<noteq> []\n  pending s `` {u} = {}\n  u = hd (stack s)\n  s' = finish u s\\<lparr>state.more := v\\<rparr>", "interpret DFS_invar where s=s"], ["proof (prove)\nusing this:\n  \\<forall>(v, w)\\<in>E.\n     v \\<in> dom (discovered s) \\<and>\n     w \\<in> dom (discovered s) \\<and>\n     \\<delta> s w \\<le> \\<delta> s v \\<and>\n     (w \\<in> dom (finished s) \\<longrightarrow>\n      v \\<in> dom (finished s) \\<and>\n      \\<phi> s v \\<le> \\<phi> s w) \\<longrightarrow>\n     (v, w) \\<in> back_edges s \\<or> (v, w) \\<in> pending s\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s \\<noteq> []\n  pending s `` {u} = {}\n  u = hd (stack s)\n  s' = finish u s\\<lparr>state.more := v\\<rparr>\n\ngoal (1 subgoal):\n 1. DFS_invar G param s", "by simp"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>e.\n       \\<forall>(v, w)\\<in>E.\n          v \\<in> dom (discovered (empty_state e)) \\<and>\n          w \\<in> dom (discovered (empty_state e)) \\<and>\n          \\<delta> (empty_state e) w \\<le> \\<delta> (empty_state e) v \\<and>\n          (w \\<in> dom (finished (empty_state e)) \\<longrightarrow>\n           v \\<in> dom (finished (empty_state e)) \\<and>\n           \\<phi> (empty_state e) v\n           \\<le> \\<phi> (empty_state e) w) \\<longrightarrow>\n          (v, w) \\<in> back_edges (empty_state e) \\<or>\n          (v, w) \\<in> pending (empty_state e)\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>\\<forall>(v, w)\\<in>E.\n                   v \\<in> dom (discovered s) \\<and>\n                   w \\<in> dom (discovered s) \\<and>\n                   \\<delta> s w \\<le> \\<delta> s v \\<and>\n                   (w \\<in> dom (finished s) \\<longrightarrow>\n                    v \\<in> dom (finished s) \\<and>\n                    \\<phi> s v \\<le> \\<phi> s w) \\<longrightarrow>\n                   (v, w) \\<in> back_edges s \\<or> (v, w) \\<in> pending s;\n        cond s; DFS_invar G param s; DFS_invar G param s'; stack s = [];\n        v0 \\<notin> dom (discovered s); v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, w)\\<in>E.\n                            v \\<in> dom (discovered s') \\<and>\n                            w \\<in> dom (discovered s') \\<and>\n                            \\<delta> s' w \\<le> \\<delta> s' v \\<and>\n                            (w \\<in> dom (finished s') \\<longrightarrow>\n                             v \\<in> dom (finished s') \\<and>\n                             \\<phi> s' v\n                             \\<le> \\<phi> s' w) \\<longrightarrow>\n                            (v, w) \\<in> back_edges s' \\<or>\n                            (v, w) \\<in> pending s'\n 3. \\<And>s s' u e.\n       \\<lbrakk>\\<forall>(v, w)\\<in>E.\n                   v \\<in> dom (discovered s) \\<and>\n                   w \\<in> dom (discovered s) \\<and>\n                   \\<delta> s w \\<le> \\<delta> s v \\<and>\n                   (w \\<in> dom (finished s) \\<longrightarrow>\n                    v \\<in> dom (finished s) \\<and>\n                    \\<phi> s v \\<le> \\<phi> s w) \\<longrightarrow>\n                   (v, w) \\<in> back_edges s \\<or> (v, w) \\<in> pending s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; pending s `` {u} = {}; u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, w)\\<in>E.\n                            v \\<in> dom (discovered s') \\<and>\n                            w \\<in> dom (discovered s') \\<and>\n                            \\<delta> s' w \\<le> \\<delta> s' v \\<and>\n                            (w \\<in> dom (finished s') \\<longrightarrow>\n                             v \\<in> dom (finished s') \\<and>\n                             \\<phi> s' v\n                             \\<le> \\<phi> s' w) \\<longrightarrow>\n                            (v, w) \\<in> back_edges s' \\<or>\n                            (v, w) \\<in> pending s'\n 4. \\<And>s s' u v e.\n       \\<lbrakk>\\<forall>(v, w)\\<in>E.\n                   v \\<in> dom (discovered s) \\<and>\n                   w \\<in> dom (discovered s) \\<and>\n                   \\<delta> s w \\<le> \\<delta> s v \\<and>\n                   (w \\<in> dom (finished s) \\<longrightarrow>\n                    v \\<in> dom (finished s) \\<and>\n                    \\<phi> s v \\<le> \\<phi> s w) \\<longrightarrow>\n                   (v, w) \\<in> back_edges s \\<or> (v, w) \\<in> pending s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        u = hd (stack s);\n        s' =\n        back_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, w)\\<in>E.\n                            v \\<in> dom (discovered s') \\<and>\n                            w \\<in> dom (discovered s') \\<and>\n                            \\<delta> s' w \\<le> \\<delta> s' v \\<and>\n                            (w \\<in> dom (finished s') \\<longrightarrow>\n                             v \\<in> dom (finished s') \\<and>\n                             \\<phi> s' v\n                             \\<le> \\<phi> s' w) \\<longrightarrow>\n                            (v, w) \\<in> back_edges s' \\<or>\n                            (v, w) \\<in> pending s'\n 5. \\<And>s s' u v e.\n       \\<lbrakk>\\<forall>(v, w)\\<in>E.\n                   v \\<in> dom (discovered s) \\<and>\n                   w \\<in> dom (discovered s) \\<and>\n                   \\<delta> s w \\<le> \\<delta> s v \\<and>\n                   (w \\<in> dom (finished s) \\<longrightarrow>\n                    v \\<in> dom (finished s) \\<and>\n                    \\<phi> s v \\<le> \\<phi> s w) \\<longrightarrow>\n                   (v, w) \\<in> back_edges s \\<or> (v, w) \\<in> pending s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, w)\\<in>E.\n                            v \\<in> dom (discovered s') \\<and>\n                            w \\<in> dom (discovered s') \\<and>\n                            \\<delta> s' w \\<le> \\<delta> s' v \\<and>\n                            (w \\<in> dom (finished s') \\<longrightarrow>\n                             v \\<in> dom (finished s') \\<and>\n                             \\<phi> s' v\n                             \\<le> \\<phi> s' w) \\<longrightarrow>\n                            (v, w) \\<in> back_edges s' \\<or>\n                            (v, w) \\<in> pending s'", "from finish"], ["proof (chain)\npicking this:\n  \\<forall>(v, w)\\<in>E.\n     v \\<in> dom (discovered s) \\<and>\n     w \\<in> dom (discovered s) \\<and>\n     \\<delta> s w \\<le> \\<delta> s v \\<and>\n     (w \\<in> dom (finished s) \\<longrightarrow>\n      v \\<in> dom (finished s) \\<and>\n      \\<phi> s v \\<le> \\<phi> s w) \\<longrightarrow>\n     (v, w) \\<in> back_edges s \\<or> (v, w) \\<in> pending s\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s \\<noteq> []\n  pending s `` {u} = {}\n  u = hd (stack s)\n  s' = finish u s\\<lparr>state.more := v\\<rparr>", "have \n      IH: \"\\<And>v w. \\<lbrakk>w \\<in> succ v; v \\<in> dom (discovered s); w \\<in> dom (discovered s); \n                  \\<delta> s w \\<le> \\<delta> s v;\n                  (w \\<in> dom (finished s) \\<Longrightarrow> v \\<in> dom (finished s) \\<and> \\<phi> s v \\<le> \\<phi> s w)\\<rbrakk>\n                 \\<Longrightarrow> (v, w) \\<in> back_edges s \\<or> (v, w) \\<in> pending s\""], ["proof (prove)\nusing this:\n  \\<forall>(v, w)\\<in>E.\n     v \\<in> dom (discovered s) \\<and>\n     w \\<in> dom (discovered s) \\<and>\n     \\<delta> s w \\<le> \\<delta> s v \\<and>\n     (w \\<in> dom (finished s) \\<longrightarrow>\n      v \\<in> dom (finished s) \\<and>\n      \\<phi> s v \\<le> \\<phi> s w) \\<longrightarrow>\n     (v, w) \\<in> back_edges s \\<or> (v, w) \\<in> pending s\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s \\<noteq> []\n  pending s `` {u} = {}\n  u = hd (stack s)\n  s' = finish u s\\<lparr>state.more := v\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<And>v w.\n       \\<lbrakk>w \\<in> E `` {v}; v \\<in> dom (discovered s);\n        w \\<in> dom (discovered s); \\<delta> s w \\<le> \\<delta> s v;\n        w \\<in> dom (finished s) \\<Longrightarrow>\n        v \\<in> dom (finished s) \\<and> \\<phi> s v \\<le> \\<phi> s w\\<rbrakk>\n       \\<Longrightarrow> (v, w) \\<in> back_edges s \\<or>\n                         (v, w) \\<in> pending s", "by blast"], ["proof (state)\nthis:\n  \\<lbrakk>?w7 \\<in> E `` {?v7}; ?v7 \\<in> dom (discovered s);\n   ?w7 \\<in> dom (discovered s); \\<delta> s ?w7 \\<le> \\<delta> s ?v7;\n   ?w7 \\<in> dom (finished s) \\<Longrightarrow>\n   ?v7 \\<in> dom (finished s) \\<and>\n   \\<phi> s ?v7 \\<le> \\<phi> s ?w7\\<rbrakk>\n  \\<Longrightarrow> (?v7, ?w7) \\<in> back_edges s \\<or>\n                    (?v7, ?w7) \\<in> pending s\n\ngoal (5 subgoals):\n 1. \\<And>e.\n       \\<forall>(v, w)\\<in>E.\n          v \\<in> dom (discovered (empty_state e)) \\<and>\n          w \\<in> dom (discovered (empty_state e)) \\<and>\n          \\<delta> (empty_state e) w \\<le> \\<delta> (empty_state e) v \\<and>\n          (w \\<in> dom (finished (empty_state e)) \\<longrightarrow>\n           v \\<in> dom (finished (empty_state e)) \\<and>\n           \\<phi> (empty_state e) v\n           \\<le> \\<phi> (empty_state e) w) \\<longrightarrow>\n          (v, w) \\<in> back_edges (empty_state e) \\<or>\n          (v, w) \\<in> pending (empty_state e)\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>\\<forall>(v, w)\\<in>E.\n                   v \\<in> dom (discovered s) \\<and>\n                   w \\<in> dom (discovered s) \\<and>\n                   \\<delta> s w \\<le> \\<delta> s v \\<and>\n                   (w \\<in> dom (finished s) \\<longrightarrow>\n                    v \\<in> dom (finished s) \\<and>\n                    \\<phi> s v \\<le> \\<phi> s w) \\<longrightarrow>\n                   (v, w) \\<in> back_edges s \\<or> (v, w) \\<in> pending s;\n        cond s; DFS_invar G param s; DFS_invar G param s'; stack s = [];\n        v0 \\<notin> dom (discovered s); v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, w)\\<in>E.\n                            v \\<in> dom (discovered s') \\<and>\n                            w \\<in> dom (discovered s') \\<and>\n                            \\<delta> s' w \\<le> \\<delta> s' v \\<and>\n                            (w \\<in> dom (finished s') \\<longrightarrow>\n                             v \\<in> dom (finished s') \\<and>\n                             \\<phi> s' v\n                             \\<le> \\<phi> s' w) \\<longrightarrow>\n                            (v, w) \\<in> back_edges s' \\<or>\n                            (v, w) \\<in> pending s'\n 3. \\<And>s s' u e.\n       \\<lbrakk>\\<forall>(v, w)\\<in>E.\n                   v \\<in> dom (discovered s) \\<and>\n                   w \\<in> dom (discovered s) \\<and>\n                   \\<delta> s w \\<le> \\<delta> s v \\<and>\n                   (w \\<in> dom (finished s) \\<longrightarrow>\n                    v \\<in> dom (finished s) \\<and>\n                    \\<phi> s v \\<le> \\<phi> s w) \\<longrightarrow>\n                   (v, w) \\<in> back_edges s \\<or> (v, w) \\<in> pending s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; pending s `` {u} = {}; u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, w)\\<in>E.\n                            v \\<in> dom (discovered s') \\<and>\n                            w \\<in> dom (discovered s') \\<and>\n                            \\<delta> s' w \\<le> \\<delta> s' v \\<and>\n                            (w \\<in> dom (finished s') \\<longrightarrow>\n                             v \\<in> dom (finished s') \\<and>\n                             \\<phi> s' v\n                             \\<le> \\<phi> s' w) \\<longrightarrow>\n                            (v, w) \\<in> back_edges s' \\<or>\n                            (v, w) \\<in> pending s'\n 4. \\<And>s s' u v e.\n       \\<lbrakk>\\<forall>(v, w)\\<in>E.\n                   v \\<in> dom (discovered s) \\<and>\n                   w \\<in> dom (discovered s) \\<and>\n                   \\<delta> s w \\<le> \\<delta> s v \\<and>\n                   (w \\<in> dom (finished s) \\<longrightarrow>\n                    v \\<in> dom (finished s) \\<and>\n                    \\<phi> s v \\<le> \\<phi> s w) \\<longrightarrow>\n                   (v, w) \\<in> back_edges s \\<or> (v, w) \\<in> pending s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        u = hd (stack s);\n        s' =\n        back_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, w)\\<in>E.\n                            v \\<in> dom (discovered s') \\<and>\n                            w \\<in> dom (discovered s') \\<and>\n                            \\<delta> s' w \\<le> \\<delta> s' v \\<and>\n                            (w \\<in> dom (finished s') \\<longrightarrow>\n                             v \\<in> dom (finished s') \\<and>\n                             \\<phi> s' v\n                             \\<le> \\<phi> s' w) \\<longrightarrow>\n                            (v, w) \\<in> back_edges s' \\<or>\n                            (v, w) \\<in> pending s'\n 5. \\<And>s s' u v e.\n       \\<lbrakk>\\<forall>(v, w)\\<in>E.\n                   v \\<in> dom (discovered s) \\<and>\n                   w \\<in> dom (discovered s) \\<and>\n                   \\<delta> s w \\<le> \\<delta> s v \\<and>\n                   (w \\<in> dom (finished s) \\<longrightarrow>\n                    v \\<in> dom (finished s) \\<and>\n                    \\<phi> s v \\<le> \\<phi> s w) \\<longrightarrow>\n                   (v, w) \\<in> back_edges s \\<or> (v, w) \\<in> pending s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, w)\\<in>E.\n                            v \\<in> dom (discovered s') \\<and>\n                            w \\<in> dom (discovered s') \\<and>\n                            \\<delta> s' w \\<le> \\<delta> s' v \\<and>\n                            (w \\<in> dom (finished s') \\<longrightarrow>\n                             v \\<in> dom (finished s') \\<and>\n                             \\<phi> s' v\n                             \\<le> \\<phi> s' w) \\<longrightarrow>\n                            (v, w) \\<in> back_edges s' \\<or>\n                            (v, w) \\<in> pending s'", "from finish"], ["proof (chain)\npicking this:\n  \\<forall>(v, w)\\<in>E.\n     v \\<in> dom (discovered s) \\<and>\n     w \\<in> dom (discovered s) \\<and>\n     \\<delta> s w \\<le> \\<delta> s v \\<and>\n     (w \\<in> dom (finished s) \\<longrightarrow>\n      v \\<in> dom (finished s) \\<and>\n      \\<phi> s v \\<le> \\<phi> s w) \\<longrightarrow>\n     (v, w) \\<in> back_edges s \\<or> (v, w) \\<in> pending s\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s \\<noteq> []\n  pending s `` {u} = {}\n  u = hd (stack s)\n  s' = finish u s\\<lparr>state.more := v\\<rparr>", "have ne[simp]: \"stack s \\<noteq> []\"\n                 and p[simp]: \"pending s `` {hd (stack s)} = {}\""], ["proof (prove)\nusing this:\n  \\<forall>(v, w)\\<in>E.\n     v \\<in> dom (discovered s) \\<and>\n     w \\<in> dom (discovered s) \\<and>\n     \\<delta> s w \\<le> \\<delta> s v \\<and>\n     (w \\<in> dom (finished s) \\<longrightarrow>\n      v \\<in> dom (finished s) \\<and>\n      \\<phi> s v \\<le> \\<phi> s w) \\<longrightarrow>\n     (v, w) \\<in> back_edges s \\<or> (v, w) \\<in> pending s\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s \\<noteq> []\n  pending s `` {u} = {}\n  u = hd (stack s)\n  s' = finish u s\\<lparr>state.more := v\\<rparr>\n\ngoal (1 subgoal):\n 1. stack s \\<noteq> [] &&& pending s `` {hd (stack s)} = {}", "by (simp_all)"], ["proof (state)\nthis:\n  stack s \\<noteq> []\n  pending s `` {hd (stack s)} = {}\n\ngoal (5 subgoals):\n 1. \\<And>e.\n       \\<forall>(v, w)\\<in>E.\n          v \\<in> dom (discovered (empty_state e)) \\<and>\n          w \\<in> dom (discovered (empty_state e)) \\<and>\n          \\<delta> (empty_state e) w \\<le> \\<delta> (empty_state e) v \\<and>\n          (w \\<in> dom (finished (empty_state e)) \\<longrightarrow>\n           v \\<in> dom (finished (empty_state e)) \\<and>\n           \\<phi> (empty_state e) v\n           \\<le> \\<phi> (empty_state e) w) \\<longrightarrow>\n          (v, w) \\<in> back_edges (empty_state e) \\<or>\n          (v, w) \\<in> pending (empty_state e)\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>\\<forall>(v, w)\\<in>E.\n                   v \\<in> dom (discovered s) \\<and>\n                   w \\<in> dom (discovered s) \\<and>\n                   \\<delta> s w \\<le> \\<delta> s v \\<and>\n                   (w \\<in> dom (finished s) \\<longrightarrow>\n                    v \\<in> dom (finished s) \\<and>\n                    \\<phi> s v \\<le> \\<phi> s w) \\<longrightarrow>\n                   (v, w) \\<in> back_edges s \\<or> (v, w) \\<in> pending s;\n        cond s; DFS_invar G param s; DFS_invar G param s'; stack s = [];\n        v0 \\<notin> dom (discovered s); v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, w)\\<in>E.\n                            v \\<in> dom (discovered s') \\<and>\n                            w \\<in> dom (discovered s') \\<and>\n                            \\<delta> s' w \\<le> \\<delta> s' v \\<and>\n                            (w \\<in> dom (finished s') \\<longrightarrow>\n                             v \\<in> dom (finished s') \\<and>\n                             \\<phi> s' v\n                             \\<le> \\<phi> s' w) \\<longrightarrow>\n                            (v, w) \\<in> back_edges s' \\<or>\n                            (v, w) \\<in> pending s'\n 3. \\<And>s s' u e.\n       \\<lbrakk>\\<forall>(v, w)\\<in>E.\n                   v \\<in> dom (discovered s) \\<and>\n                   w \\<in> dom (discovered s) \\<and>\n                   \\<delta> s w \\<le> \\<delta> s v \\<and>\n                   (w \\<in> dom (finished s) \\<longrightarrow>\n                    v \\<in> dom (finished s) \\<and>\n                    \\<phi> s v \\<le> \\<phi> s w) \\<longrightarrow>\n                   (v, w) \\<in> back_edges s \\<or> (v, w) \\<in> pending s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; pending s `` {u} = {}; u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, w)\\<in>E.\n                            v \\<in> dom (discovered s') \\<and>\n                            w \\<in> dom (discovered s') \\<and>\n                            \\<delta> s' w \\<le> \\<delta> s' v \\<and>\n                            (w \\<in> dom (finished s') \\<longrightarrow>\n                             v \\<in> dom (finished s') \\<and>\n                             \\<phi> s' v\n                             \\<le> \\<phi> s' w) \\<longrightarrow>\n                            (v, w) \\<in> back_edges s' \\<or>\n                            (v, w) \\<in> pending s'\n 4. \\<And>s s' u v e.\n       \\<lbrakk>\\<forall>(v, w)\\<in>E.\n                   v \\<in> dom (discovered s) \\<and>\n                   w \\<in> dom (discovered s) \\<and>\n                   \\<delta> s w \\<le> \\<delta> s v \\<and>\n                   (w \\<in> dom (finished s) \\<longrightarrow>\n                    v \\<in> dom (finished s) \\<and>\n                    \\<phi> s v \\<le> \\<phi> s w) \\<longrightarrow>\n                   (v, w) \\<in> back_edges s \\<or> (v, w) \\<in> pending s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        u = hd (stack s);\n        s' =\n        back_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, w)\\<in>E.\n                            v \\<in> dom (discovered s') \\<and>\n                            w \\<in> dom (discovered s') \\<and>\n                            \\<delta> s' w \\<le> \\<delta> s' v \\<and>\n                            (w \\<in> dom (finished s') \\<longrightarrow>\n                             v \\<in> dom (finished s') \\<and>\n                             \\<phi> s' v\n                             \\<le> \\<phi> s' w) \\<longrightarrow>\n                            (v, w) \\<in> back_edges s' \\<or>\n                            (v, w) \\<in> pending s'\n 5. \\<And>s s' u v e.\n       \\<lbrakk>\\<forall>(v, w)\\<in>E.\n                   v \\<in> dom (discovered s) \\<and>\n                   w \\<in> dom (discovered s) \\<and>\n                   \\<delta> s w \\<le> \\<delta> s v \\<and>\n                   (w \\<in> dom (finished s) \\<longrightarrow>\n                    v \\<in> dom (finished s) \\<and>\n                    \\<phi> s v \\<le> \\<phi> s w) \\<longrightarrow>\n                   (v, w) \\<in> back_edges s \\<or> (v, w) \\<in> pending s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, w)\\<in>E.\n                            v \\<in> dom (discovered s') \\<and>\n                            w \\<in> dom (discovered s') \\<and>\n                            \\<delta> s' w \\<le> \\<delta> s' v \\<and>\n                            (w \\<in> dom (finished s') \\<longrightarrow>\n                             v \\<in> dom (finished s') \\<and>\n                             \\<phi> s' v\n                             \\<le> \\<phi> s' w) \\<longrightarrow>\n                            (v, w) \\<in> back_edges s' \\<or>\n                            (v, w) \\<in> pending s'", "from hd_in_set[OF ne]"], ["proof (chain)\npicking this:\n  hd (stack s) \\<in> set (stack s)", "have disc: \"hd (stack s) \\<in> dom (discovered s)\" \n                            and not_fin: \"hd (stack s) \\<notin> dom (finished s)\""], ["proof (prove)\nusing this:\n  hd (stack s) \\<in> set (stack s)\n\ngoal (1 subgoal):\n 1. hd (stack s) \\<in> dom (discovered s) &&&\n    hd (stack s) \\<notin> dom (finished s)", "using stack_discovered stack_not_finished"], ["proof (prove)\nusing this:\n  hd (stack s) \\<in> set (stack s)\n  set (stack s) \\<subseteq> dom (discovered s)\n  ?x \\<in> set (stack s) \\<Longrightarrow> ?x \\<notin> dom (finished s)\n\ngoal (1 subgoal):\n 1. hd (stack s) \\<in> dom (discovered s) &&&\n    hd (stack s) \\<notin> dom (finished s)", "by blast+"], ["proof (state)\nthis:\n  hd (stack s) \\<in> dom (discovered s)\n  hd (stack s) \\<notin> dom (finished s)\n\ngoal (5 subgoals):\n 1. \\<And>e.\n       \\<forall>(v, w)\\<in>E.\n          v \\<in> dom (discovered (empty_state e)) \\<and>\n          w \\<in> dom (discovered (empty_state e)) \\<and>\n          \\<delta> (empty_state e) w \\<le> \\<delta> (empty_state e) v \\<and>\n          (w \\<in> dom (finished (empty_state e)) \\<longrightarrow>\n           v \\<in> dom (finished (empty_state e)) \\<and>\n           \\<phi> (empty_state e) v\n           \\<le> \\<phi> (empty_state e) w) \\<longrightarrow>\n          (v, w) \\<in> back_edges (empty_state e) \\<or>\n          (v, w) \\<in> pending (empty_state e)\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>\\<forall>(v, w)\\<in>E.\n                   v \\<in> dom (discovered s) \\<and>\n                   w \\<in> dom (discovered s) \\<and>\n                   \\<delta> s w \\<le> \\<delta> s v \\<and>\n                   (w \\<in> dom (finished s) \\<longrightarrow>\n                    v \\<in> dom (finished s) \\<and>\n                    \\<phi> s v \\<le> \\<phi> s w) \\<longrightarrow>\n                   (v, w) \\<in> back_edges s \\<or> (v, w) \\<in> pending s;\n        cond s; DFS_invar G param s; DFS_invar G param s'; stack s = [];\n        v0 \\<notin> dom (discovered s); v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, w)\\<in>E.\n                            v \\<in> dom (discovered s') \\<and>\n                            w \\<in> dom (discovered s') \\<and>\n                            \\<delta> s' w \\<le> \\<delta> s' v \\<and>\n                            (w \\<in> dom (finished s') \\<longrightarrow>\n                             v \\<in> dom (finished s') \\<and>\n                             \\<phi> s' v\n                             \\<le> \\<phi> s' w) \\<longrightarrow>\n                            (v, w) \\<in> back_edges s' \\<or>\n                            (v, w) \\<in> pending s'\n 3. \\<And>s s' u e.\n       \\<lbrakk>\\<forall>(v, w)\\<in>E.\n                   v \\<in> dom (discovered s) \\<and>\n                   w \\<in> dom (discovered s) \\<and>\n                   \\<delta> s w \\<le> \\<delta> s v \\<and>\n                   (w \\<in> dom (finished s) \\<longrightarrow>\n                    v \\<in> dom (finished s) \\<and>\n                    \\<phi> s v \\<le> \\<phi> s w) \\<longrightarrow>\n                   (v, w) \\<in> back_edges s \\<or> (v, w) \\<in> pending s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; pending s `` {u} = {}; u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, w)\\<in>E.\n                            v \\<in> dom (discovered s') \\<and>\n                            w \\<in> dom (discovered s') \\<and>\n                            \\<delta> s' w \\<le> \\<delta> s' v \\<and>\n                            (w \\<in> dom (finished s') \\<longrightarrow>\n                             v \\<in> dom (finished s') \\<and>\n                             \\<phi> s' v\n                             \\<le> \\<phi> s' w) \\<longrightarrow>\n                            (v, w) \\<in> back_edges s' \\<or>\n                            (v, w) \\<in> pending s'\n 4. \\<And>s s' u v e.\n       \\<lbrakk>\\<forall>(v, w)\\<in>E.\n                   v \\<in> dom (discovered s) \\<and>\n                   w \\<in> dom (discovered s) \\<and>\n                   \\<delta> s w \\<le> \\<delta> s v \\<and>\n                   (w \\<in> dom (finished s) \\<longrightarrow>\n                    v \\<in> dom (finished s) \\<and>\n                    \\<phi> s v \\<le> \\<phi> s w) \\<longrightarrow>\n                   (v, w) \\<in> back_edges s \\<or> (v, w) \\<in> pending s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        u = hd (stack s);\n        s' =\n        back_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, w)\\<in>E.\n                            v \\<in> dom (discovered s') \\<and>\n                            w \\<in> dom (discovered s') \\<and>\n                            \\<delta> s' w \\<le> \\<delta> s' v \\<and>\n                            (w \\<in> dom (finished s') \\<longrightarrow>\n                             v \\<in> dom (finished s') \\<and>\n                             \\<phi> s' v\n                             \\<le> \\<phi> s' w) \\<longrightarrow>\n                            (v, w) \\<in> back_edges s' \\<or>\n                            (v, w) \\<in> pending s'\n 5. \\<And>s s' u v e.\n       \\<lbrakk>\\<forall>(v, w)\\<in>E.\n                   v \\<in> dom (discovered s) \\<and>\n                   w \\<in> dom (discovered s) \\<and>\n                   \\<delta> s w \\<le> \\<delta> s v \\<and>\n                   (w \\<in> dom (finished s) \\<longrightarrow>\n                    v \\<in> dom (finished s) \\<and>\n                    \\<phi> s v \\<le> \\<phi> s w) \\<longrightarrow>\n                   (v, w) \\<in> back_edges s \\<or> (v, w) \\<in> pending s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, w)\\<in>E.\n                            v \\<in> dom (discovered s') \\<and>\n                            w \\<in> dom (discovered s') \\<and>\n                            \\<delta> s' w \\<le> \\<delta> s' v \\<and>\n                            (w \\<in> dom (finished s') \\<longrightarrow>\n                             v \\<in> dom (finished s') \\<and>\n                             \\<phi> s' v\n                             \\<le> \\<phi> s' w) \\<longrightarrow>\n                            (v, w) \\<in> back_edges s' \\<or>\n                            (v, w) \\<in> pending s'", "{"], ["proof (state)\nthis:\n  hd (stack s) \\<in> dom (discovered s)\n  hd (stack s) \\<notin> dom (finished s)\n\ngoal (5 subgoals):\n 1. \\<And>e.\n       \\<forall>(v, w)\\<in>E.\n          v \\<in> dom (discovered (empty_state e)) \\<and>\n          w \\<in> dom (discovered (empty_state e)) \\<and>\n          \\<delta> (empty_state e) w \\<le> \\<delta> (empty_state e) v \\<and>\n          (w \\<in> dom (finished (empty_state e)) \\<longrightarrow>\n           v \\<in> dom (finished (empty_state e)) \\<and>\n           \\<phi> (empty_state e) v\n           \\<le> \\<phi> (empty_state e) w) \\<longrightarrow>\n          (v, w) \\<in> back_edges (empty_state e) \\<or>\n          (v, w) \\<in> pending (empty_state e)\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>\\<forall>(v, w)\\<in>E.\n                   v \\<in> dom (discovered s) \\<and>\n                   w \\<in> dom (discovered s) \\<and>\n                   \\<delta> s w \\<le> \\<delta> s v \\<and>\n                   (w \\<in> dom (finished s) \\<longrightarrow>\n                    v \\<in> dom (finished s) \\<and>\n                    \\<phi> s v \\<le> \\<phi> s w) \\<longrightarrow>\n                   (v, w) \\<in> back_edges s \\<or> (v, w) \\<in> pending s;\n        cond s; DFS_invar G param s; DFS_invar G param s'; stack s = [];\n        v0 \\<notin> dom (discovered s); v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, w)\\<in>E.\n                            v \\<in> dom (discovered s') \\<and>\n                            w \\<in> dom (discovered s') \\<and>\n                            \\<delta> s' w \\<le> \\<delta> s' v \\<and>\n                            (w \\<in> dom (finished s') \\<longrightarrow>\n                             v \\<in> dom (finished s') \\<and>\n                             \\<phi> s' v\n                             \\<le> \\<phi> s' w) \\<longrightarrow>\n                            (v, w) \\<in> back_edges s' \\<or>\n                            (v, w) \\<in> pending s'\n 3. \\<And>s s' u e.\n       \\<lbrakk>\\<forall>(v, w)\\<in>E.\n                   v \\<in> dom (discovered s) \\<and>\n                   w \\<in> dom (discovered s) \\<and>\n                   \\<delta> s w \\<le> \\<delta> s v \\<and>\n                   (w \\<in> dom (finished s) \\<longrightarrow>\n                    v \\<in> dom (finished s) \\<and>\n                    \\<phi> s v \\<le> \\<phi> s w) \\<longrightarrow>\n                   (v, w) \\<in> back_edges s \\<or> (v, w) \\<in> pending s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; pending s `` {u} = {}; u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, w)\\<in>E.\n                            v \\<in> dom (discovered s') \\<and>\n                            w \\<in> dom (discovered s') \\<and>\n                            \\<delta> s' w \\<le> \\<delta> s' v \\<and>\n                            (w \\<in> dom (finished s') \\<longrightarrow>\n                             v \\<in> dom (finished s') \\<and>\n                             \\<phi> s' v\n                             \\<le> \\<phi> s' w) \\<longrightarrow>\n                            (v, w) \\<in> back_edges s' \\<or>\n                            (v, w) \\<in> pending s'\n 4. \\<And>s s' u v e.\n       \\<lbrakk>\\<forall>(v, w)\\<in>E.\n                   v \\<in> dom (discovered s) \\<and>\n                   w \\<in> dom (discovered s) \\<and>\n                   \\<delta> s w \\<le> \\<delta> s v \\<and>\n                   (w \\<in> dom (finished s) \\<longrightarrow>\n                    v \\<in> dom (finished s) \\<and>\n                    \\<phi> s v \\<le> \\<phi> s w) \\<longrightarrow>\n                   (v, w) \\<in> back_edges s \\<or> (v, w) \\<in> pending s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        u = hd (stack s);\n        s' =\n        back_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, w)\\<in>E.\n                            v \\<in> dom (discovered s') \\<and>\n                            w \\<in> dom (discovered s') \\<and>\n                            \\<delta> s' w \\<le> \\<delta> s' v \\<and>\n                            (w \\<in> dom (finished s') \\<longrightarrow>\n                             v \\<in> dom (finished s') \\<and>\n                             \\<phi> s' v\n                             \\<le> \\<phi> s' w) \\<longrightarrow>\n                            (v, w) \\<in> back_edges s' \\<or>\n                            (v, w) \\<in> pending s'\n 5. \\<And>s s' u v e.\n       \\<lbrakk>\\<forall>(v, w)\\<in>E.\n                   v \\<in> dom (discovered s) \\<and>\n                   w \\<in> dom (discovered s) \\<and>\n                   \\<delta> s w \\<le> \\<delta> s v \\<and>\n                   (w \\<in> dom (finished s) \\<longrightarrow>\n                    v \\<in> dom (finished s) \\<and>\n                    \\<phi> s v \\<le> \\<phi> s w) \\<longrightarrow>\n                   (v, w) \\<in> back_edges s \\<or> (v, w) \\<in> pending s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, w)\\<in>E.\n                            v \\<in> dom (discovered s') \\<and>\n                            w \\<in> dom (discovered s') \\<and>\n                            \\<delta> s' w \\<le> \\<delta> s' v \\<and>\n                            (w \\<in> dom (finished s') \\<longrightarrow>\n                             v \\<in> dom (finished s') \\<and>\n                             \\<phi> s' v\n                             \\<le> \\<phi> s' w) \\<longrightarrow>\n                            (v, w) \\<in> back_edges s' \\<or>\n                            (v, w) \\<in> pending s'", "fix w"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>e.\n       \\<forall>(v, w)\\<in>E.\n          v \\<in> dom (discovered (empty_state e)) \\<and>\n          w \\<in> dom (discovered (empty_state e)) \\<and>\n          \\<delta> (empty_state e) w \\<le> \\<delta> (empty_state e) v \\<and>\n          (w \\<in> dom (finished (empty_state e)) \\<longrightarrow>\n           v \\<in> dom (finished (empty_state e)) \\<and>\n           \\<phi> (empty_state e) v\n           \\<le> \\<phi> (empty_state e) w) \\<longrightarrow>\n          (v, w) \\<in> back_edges (empty_state e) \\<or>\n          (v, w) \\<in> pending (empty_state e)\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>\\<forall>(v, w)\\<in>E.\n                   v \\<in> dom (discovered s) \\<and>\n                   w \\<in> dom (discovered s) \\<and>\n                   \\<delta> s w \\<le> \\<delta> s v \\<and>\n                   (w \\<in> dom (finished s) \\<longrightarrow>\n                    v \\<in> dom (finished s) \\<and>\n                    \\<phi> s v \\<le> \\<phi> s w) \\<longrightarrow>\n                   (v, w) \\<in> back_edges s \\<or> (v, w) \\<in> pending s;\n        cond s; DFS_invar G param s; DFS_invar G param s'; stack s = [];\n        v0 \\<notin> dom (discovered s); v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, w)\\<in>E.\n                            v \\<in> dom (discovered s') \\<and>\n                            w \\<in> dom (discovered s') \\<and>\n                            \\<delta> s' w \\<le> \\<delta> s' v \\<and>\n                            (w \\<in> dom (finished s') \\<longrightarrow>\n                             v \\<in> dom (finished s') \\<and>\n                             \\<phi> s' v\n                             \\<le> \\<phi> s' w) \\<longrightarrow>\n                            (v, w) \\<in> back_edges s' \\<or>\n                            (v, w) \\<in> pending s'\n 3. \\<And>s s' u e.\n       \\<lbrakk>\\<forall>(v, w)\\<in>E.\n                   v \\<in> dom (discovered s) \\<and>\n                   w \\<in> dom (discovered s) \\<and>\n                   \\<delta> s w \\<le> \\<delta> s v \\<and>\n                   (w \\<in> dom (finished s) \\<longrightarrow>\n                    v \\<in> dom (finished s) \\<and>\n                    \\<phi> s v \\<le> \\<phi> s w) \\<longrightarrow>\n                   (v, w) \\<in> back_edges s \\<or> (v, w) \\<in> pending s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; pending s `` {u} = {}; u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, w)\\<in>E.\n                            v \\<in> dom (discovered s') \\<and>\n                            w \\<in> dom (discovered s') \\<and>\n                            \\<delta> s' w \\<le> \\<delta> s' v \\<and>\n                            (w \\<in> dom (finished s') \\<longrightarrow>\n                             v \\<in> dom (finished s') \\<and>\n                             \\<phi> s' v\n                             \\<le> \\<phi> s' w) \\<longrightarrow>\n                            (v, w) \\<in> back_edges s' \\<or>\n                            (v, w) \\<in> pending s'\n 4. \\<And>s s' u v e.\n       \\<lbrakk>\\<forall>(v, w)\\<in>E.\n                   v \\<in> dom (discovered s) \\<and>\n                   w \\<in> dom (discovered s) \\<and>\n                   \\<delta> s w \\<le> \\<delta> s v \\<and>\n                   (w \\<in> dom (finished s) \\<longrightarrow>\n                    v \\<in> dom (finished s) \\<and>\n                    \\<phi> s v \\<le> \\<phi> s w) \\<longrightarrow>\n                   (v, w) \\<in> back_edges s \\<or> (v, w) \\<in> pending s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        u = hd (stack s);\n        s' =\n        back_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, w)\\<in>E.\n                            v \\<in> dom (discovered s') \\<and>\n                            w \\<in> dom (discovered s') \\<and>\n                            \\<delta> s' w \\<le> \\<delta> s' v \\<and>\n                            (w \\<in> dom (finished s') \\<longrightarrow>\n                             v \\<in> dom (finished s') \\<and>\n                             \\<phi> s' v\n                             \\<le> \\<phi> s' w) \\<longrightarrow>\n                            (v, w) \\<in> back_edges s' \\<or>\n                            (v, w) \\<in> pending s'\n 5. \\<And>s s' u v e.\n       \\<lbrakk>\\<forall>(v, w)\\<in>E.\n                   v \\<in> dom (discovered s) \\<and>\n                   w \\<in> dom (discovered s) \\<and>\n                   \\<delta> s w \\<le> \\<delta> s v \\<and>\n                   (w \\<in> dom (finished s) \\<longrightarrow>\n                    v \\<in> dom (finished s) \\<and>\n                    \\<phi> s v \\<le> \\<phi> s w) \\<longrightarrow>\n                   (v, w) \\<in> back_edges s \\<or> (v, w) \\<in> pending s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, w)\\<in>E.\n                            v \\<in> dom (discovered s') \\<and>\n                            w \\<in> dom (discovered s') \\<and>\n                            \\<delta> s' w \\<le> \\<delta> s' v \\<and>\n                            (w \\<in> dom (finished s') \\<longrightarrow>\n                             v \\<in> dom (finished s') \\<and>\n                             \\<phi> s' v\n                             \\<le> \\<phi> s' w) \\<longrightarrow>\n                            (v, w) \\<in> back_edges s' \\<or>\n                            (v, w) \\<in> pending s'", "assume w: \"w \\<in> succ (hd (stack s))\" \"w \\<noteq> hd (stack s)\" \"w \\<in> dom (discovered s)\"\n        and f: \"w \\<in> dom (finished s) \\<longrightarrow> counter s \\<le> \\<phi> s w\"\n        and \\<delta>: \"\\<delta> s w \\<le> \\<delta> s (hd (stack s))\""], ["proof (state)\nthis:\n  w \\<in> E `` {hd (stack s)}\n  w \\<noteq> hd (stack s)\n  w \\<in> dom (discovered s)\n  w \\<in> dom (finished s) \\<longrightarrow> counter s \\<le> \\<phi> s w\n  \\<delta> s w \\<le> \\<delta> s (hd (stack s))\n\ngoal (5 subgoals):\n 1. \\<And>e.\n       \\<forall>(v, w)\\<in>E.\n          v \\<in> dom (discovered (empty_state e)) \\<and>\n          w \\<in> dom (discovered (empty_state e)) \\<and>\n          \\<delta> (empty_state e) w \\<le> \\<delta> (empty_state e) v \\<and>\n          (w \\<in> dom (finished (empty_state e)) \\<longrightarrow>\n           v \\<in> dom (finished (empty_state e)) \\<and>\n           \\<phi> (empty_state e) v\n           \\<le> \\<phi> (empty_state e) w) \\<longrightarrow>\n          (v, w) \\<in> back_edges (empty_state e) \\<or>\n          (v, w) \\<in> pending (empty_state e)\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>\\<forall>(v, w)\\<in>E.\n                   v \\<in> dom (discovered s) \\<and>\n                   w \\<in> dom (discovered s) \\<and>\n                   \\<delta> s w \\<le> \\<delta> s v \\<and>\n                   (w \\<in> dom (finished s) \\<longrightarrow>\n                    v \\<in> dom (finished s) \\<and>\n                    \\<phi> s v \\<le> \\<phi> s w) \\<longrightarrow>\n                   (v, w) \\<in> back_edges s \\<or> (v, w) \\<in> pending s;\n        cond s; DFS_invar G param s; DFS_invar G param s'; stack s = [];\n        v0 \\<notin> dom (discovered s); v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, w)\\<in>E.\n                            v \\<in> dom (discovered s') \\<and>\n                            w \\<in> dom (discovered s') \\<and>\n                            \\<delta> s' w \\<le> \\<delta> s' v \\<and>\n                            (w \\<in> dom (finished s') \\<longrightarrow>\n                             v \\<in> dom (finished s') \\<and>\n                             \\<phi> s' v\n                             \\<le> \\<phi> s' w) \\<longrightarrow>\n                            (v, w) \\<in> back_edges s' \\<or>\n                            (v, w) \\<in> pending s'\n 3. \\<And>s s' u e.\n       \\<lbrakk>\\<forall>(v, w)\\<in>E.\n                   v \\<in> dom (discovered s) \\<and>\n                   w \\<in> dom (discovered s) \\<and>\n                   \\<delta> s w \\<le> \\<delta> s v \\<and>\n                   (w \\<in> dom (finished s) \\<longrightarrow>\n                    v \\<in> dom (finished s) \\<and>\n                    \\<phi> s v \\<le> \\<phi> s w) \\<longrightarrow>\n                   (v, w) \\<in> back_edges s \\<or> (v, w) \\<in> pending s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; pending s `` {u} = {}; u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, w)\\<in>E.\n                            v \\<in> dom (discovered s') \\<and>\n                            w \\<in> dom (discovered s') \\<and>\n                            \\<delta> s' w \\<le> \\<delta> s' v \\<and>\n                            (w \\<in> dom (finished s') \\<longrightarrow>\n                             v \\<in> dom (finished s') \\<and>\n                             \\<phi> s' v\n                             \\<le> \\<phi> s' w) \\<longrightarrow>\n                            (v, w) \\<in> back_edges s' \\<or>\n                            (v, w) \\<in> pending s'\n 4. \\<And>s s' u v e.\n       \\<lbrakk>\\<forall>(v, w)\\<in>E.\n                   v \\<in> dom (discovered s) \\<and>\n                   w \\<in> dom (discovered s) \\<and>\n                   \\<delta> s w \\<le> \\<delta> s v \\<and>\n                   (w \\<in> dom (finished s) \\<longrightarrow>\n                    v \\<in> dom (finished s) \\<and>\n                    \\<phi> s v \\<le> \\<phi> s w) \\<longrightarrow>\n                   (v, w) \\<in> back_edges s \\<or> (v, w) \\<in> pending s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        u = hd (stack s);\n        s' =\n        back_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, w)\\<in>E.\n                            v \\<in> dom (discovered s') \\<and>\n                            w \\<in> dom (discovered s') \\<and>\n                            \\<delta> s' w \\<le> \\<delta> s' v \\<and>\n                            (w \\<in> dom (finished s') \\<longrightarrow>\n                             v \\<in> dom (finished s') \\<and>\n                             \\<phi> s' v\n                             \\<le> \\<phi> s' w) \\<longrightarrow>\n                            (v, w) \\<in> back_edges s' \\<or>\n                            (v, w) \\<in> pending s'\n 5. \\<And>s s' u v e.\n       \\<lbrakk>\\<forall>(v, w)\\<in>E.\n                   v \\<in> dom (discovered s) \\<and>\n                   w \\<in> dom (discovered s) \\<and>\n                   \\<delta> s w \\<le> \\<delta> s v \\<and>\n                   (w \\<in> dom (finished s) \\<longrightarrow>\n                    v \\<in> dom (finished s) \\<and>\n                    \\<phi> s v \\<le> \\<phi> s w) \\<longrightarrow>\n                   (v, w) \\<in> back_edges s \\<or> (v, w) \\<in> pending s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, w)\\<in>E.\n                            v \\<in> dom (discovered s') \\<and>\n                            w \\<in> dom (discovered s') \\<and>\n                            \\<delta> s' w \\<le> \\<delta> s' v \\<and>\n                            (w \\<in> dom (finished s') \\<longrightarrow>\n                             v \\<in> dom (finished s') \\<and>\n                             \\<phi> s' v\n                             \\<le> \\<phi> s' w) \\<longrightarrow>\n                            (v, w) \\<in> back_edges s' \\<or>\n                            (v, w) \\<in> pending s'", "with timing_less_counter"], ["proof (chain)\npicking this:\n  ?v \\<in> dom (discovered s) \\<Longrightarrow> \\<delta> s ?v < counter s\n  ?v \\<in> dom (finished s) \\<Longrightarrow> \\<phi> s ?v < counter s\n  w \\<in> E `` {hd (stack s)}\n  w \\<noteq> hd (stack s)\n  w \\<in> dom (discovered s)\n  w \\<in> dom (finished s) \\<longrightarrow> counter s \\<le> \\<phi> s w\n  \\<delta> s w \\<le> \\<delta> s (hd (stack s))", "have \"w \\<notin> dom (finished s)\""], ["proof (prove)\nusing this:\n  ?v \\<in> dom (discovered s) \\<Longrightarrow> \\<delta> s ?v < counter s\n  ?v \\<in> dom (finished s) \\<Longrightarrow> \\<phi> s ?v < counter s\n  w \\<in> E `` {hd (stack s)}\n  w \\<noteq> hd (stack s)\n  w \\<in> dom (discovered s)\n  w \\<in> dom (finished s) \\<longrightarrow> counter s \\<le> \\<phi> s w\n  \\<delta> s w \\<le> \\<delta> s (hd (stack s))\n\ngoal (1 subgoal):\n 1. w \\<notin> dom (finished s)", "by force"], ["proof (state)\nthis:\n  w \\<notin> dom (finished s)\n\ngoal (5 subgoals):\n 1. \\<And>e.\n       \\<forall>(v, w)\\<in>E.\n          v \\<in> dom (discovered (empty_state e)) \\<and>\n          w \\<in> dom (discovered (empty_state e)) \\<and>\n          \\<delta> (empty_state e) w \\<le> \\<delta> (empty_state e) v \\<and>\n          (w \\<in> dom (finished (empty_state e)) \\<longrightarrow>\n           v \\<in> dom (finished (empty_state e)) \\<and>\n           \\<phi> (empty_state e) v\n           \\<le> \\<phi> (empty_state e) w) \\<longrightarrow>\n          (v, w) \\<in> back_edges (empty_state e) \\<or>\n          (v, w) \\<in> pending (empty_state e)\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>\\<forall>(v, w)\\<in>E.\n                   v \\<in> dom (discovered s) \\<and>\n                   w \\<in> dom (discovered s) \\<and>\n                   \\<delta> s w \\<le> \\<delta> s v \\<and>\n                   (w \\<in> dom (finished s) \\<longrightarrow>\n                    v \\<in> dom (finished s) \\<and>\n                    \\<phi> s v \\<le> \\<phi> s w) \\<longrightarrow>\n                   (v, w) \\<in> back_edges s \\<or> (v, w) \\<in> pending s;\n        cond s; DFS_invar G param s; DFS_invar G param s'; stack s = [];\n        v0 \\<notin> dom (discovered s); v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, w)\\<in>E.\n                            v \\<in> dom (discovered s') \\<and>\n                            w \\<in> dom (discovered s') \\<and>\n                            \\<delta> s' w \\<le> \\<delta> s' v \\<and>\n                            (w \\<in> dom (finished s') \\<longrightarrow>\n                             v \\<in> dom (finished s') \\<and>\n                             \\<phi> s' v\n                             \\<le> \\<phi> s' w) \\<longrightarrow>\n                            (v, w) \\<in> back_edges s' \\<or>\n                            (v, w) \\<in> pending s'\n 3. \\<And>s s' u e.\n       \\<lbrakk>\\<forall>(v, w)\\<in>E.\n                   v \\<in> dom (discovered s) \\<and>\n                   w \\<in> dom (discovered s) \\<and>\n                   \\<delta> s w \\<le> \\<delta> s v \\<and>\n                   (w \\<in> dom (finished s) \\<longrightarrow>\n                    v \\<in> dom (finished s) \\<and>\n                    \\<phi> s v \\<le> \\<phi> s w) \\<longrightarrow>\n                   (v, w) \\<in> back_edges s \\<or> (v, w) \\<in> pending s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; pending s `` {u} = {}; u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, w)\\<in>E.\n                            v \\<in> dom (discovered s') \\<and>\n                            w \\<in> dom (discovered s') \\<and>\n                            \\<delta> s' w \\<le> \\<delta> s' v \\<and>\n                            (w \\<in> dom (finished s') \\<longrightarrow>\n                             v \\<in> dom (finished s') \\<and>\n                             \\<phi> s' v\n                             \\<le> \\<phi> s' w) \\<longrightarrow>\n                            (v, w) \\<in> back_edges s' \\<or>\n                            (v, w) \\<in> pending s'\n 4. \\<And>s s' u v e.\n       \\<lbrakk>\\<forall>(v, w)\\<in>E.\n                   v \\<in> dom (discovered s) \\<and>\n                   w \\<in> dom (discovered s) \\<and>\n                   \\<delta> s w \\<le> \\<delta> s v \\<and>\n                   (w \\<in> dom (finished s) \\<longrightarrow>\n                    v \\<in> dom (finished s) \\<and>\n                    \\<phi> s v \\<le> \\<phi> s w) \\<longrightarrow>\n                   (v, w) \\<in> back_edges s \\<or> (v, w) \\<in> pending s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        u = hd (stack s);\n        s' =\n        back_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, w)\\<in>E.\n                            v \\<in> dom (discovered s') \\<and>\n                            w \\<in> dom (discovered s') \\<and>\n                            \\<delta> s' w \\<le> \\<delta> s' v \\<and>\n                            (w \\<in> dom (finished s') \\<longrightarrow>\n                             v \\<in> dom (finished s') \\<and>\n                             \\<phi> s' v\n                             \\<le> \\<phi> s' w) \\<longrightarrow>\n                            (v, w) \\<in> back_edges s' \\<or>\n                            (v, w) \\<in> pending s'\n 5. \\<And>s s' u v e.\n       \\<lbrakk>\\<forall>(v, w)\\<in>E.\n                   v \\<in> dom (discovered s) \\<and>\n                   w \\<in> dom (discovered s) \\<and>\n                   \\<delta> s w \\<le> \\<delta> s v \\<and>\n                   (w \\<in> dom (finished s) \\<longrightarrow>\n                    v \\<in> dom (finished s) \\<and>\n                    \\<phi> s v \\<le> \\<phi> s w) \\<longrightarrow>\n                   (v, w) \\<in> back_edges s \\<or> (v, w) \\<in> pending s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, w)\\<in>E.\n                            v \\<in> dom (discovered s') \\<and>\n                            w \\<in> dom (discovered s') \\<and>\n                            \\<delta> s' w \\<le> \\<delta> s' v \\<and>\n                            (w \\<in> dom (finished s') \\<longrightarrow>\n                             v \\<in> dom (finished s') \\<and>\n                             \\<phi> s' v\n                             \\<le> \\<phi> s' w) \\<longrightarrow>\n                            (v, w) \\<in> back_edges s' \\<or>\n                            (v, w) \\<in> pending s'", "with finish w \\<delta> disc"], ["proof (chain)\npicking this:\n  \\<forall>(v, w)\\<in>E.\n     v \\<in> dom (discovered s) \\<and>\n     w \\<in> dom (discovered s) \\<and>\n     \\<delta> s w \\<le> \\<delta> s v \\<and>\n     (w \\<in> dom (finished s) \\<longrightarrow>\n      v \\<in> dom (finished s) \\<and>\n      \\<phi> s v \\<le> \\<phi> s w) \\<longrightarrow>\n     (v, w) \\<in> back_edges s \\<or> (v, w) \\<in> pending s\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s \\<noteq> []\n  pending s `` {u} = {}\n  u = hd (stack s)\n  s' = finish u s\\<lparr>state.more := v\\<rparr>\n  w \\<in> E `` {hd (stack s)}\n  w \\<noteq> hd (stack s)\n  w \\<in> dom (discovered s)\n  \\<delta> s w \\<le> \\<delta> s (hd (stack s))\n  hd (stack s) \\<in> dom (discovered s)\n  w \\<notin> dom (finished s)", "have \"(hd (stack s), w) \\<in> back_edges s\""], ["proof (prove)\nusing this:\n  \\<forall>(v, w)\\<in>E.\n     v \\<in> dom (discovered s) \\<and>\n     w \\<in> dom (discovered s) \\<and>\n     \\<delta> s w \\<le> \\<delta> s v \\<and>\n     (w \\<in> dom (finished s) \\<longrightarrow>\n      v \\<in> dom (finished s) \\<and>\n      \\<phi> s v \\<le> \\<phi> s w) \\<longrightarrow>\n     (v, w) \\<in> back_edges s \\<or> (v, w) \\<in> pending s\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s \\<noteq> []\n  pending s `` {u} = {}\n  u = hd (stack s)\n  s' = finish u s\\<lparr>state.more := v\\<rparr>\n  w \\<in> E `` {hd (stack s)}\n  w \\<noteq> hd (stack s)\n  w \\<in> dom (discovered s)\n  \\<delta> s w \\<le> \\<delta> s (hd (stack s))\n  hd (stack s) \\<in> dom (discovered s)\n  w \\<notin> dom (finished s)\n\ngoal (1 subgoal):\n 1. (hd (stack s), w) \\<in> back_edges s", "by blast"], ["proof (state)\nthis:\n  (hd (stack s), w) \\<in> back_edges s\n\ngoal (5 subgoals):\n 1. \\<And>e.\n       \\<forall>(v, w)\\<in>E.\n          v \\<in> dom (discovered (empty_state e)) \\<and>\n          w \\<in> dom (discovered (empty_state e)) \\<and>\n          \\<delta> (empty_state e) w \\<le> \\<delta> (empty_state e) v \\<and>\n          (w \\<in> dom (finished (empty_state e)) \\<longrightarrow>\n           v \\<in> dom (finished (empty_state e)) \\<and>\n           \\<phi> (empty_state e) v\n           \\<le> \\<phi> (empty_state e) w) \\<longrightarrow>\n          (v, w) \\<in> back_edges (empty_state e) \\<or>\n          (v, w) \\<in> pending (empty_state e)\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>\\<forall>(v, w)\\<in>E.\n                   v \\<in> dom (discovered s) \\<and>\n                   w \\<in> dom (discovered s) \\<and>\n                   \\<delta> s w \\<le> \\<delta> s v \\<and>\n                   (w \\<in> dom (finished s) \\<longrightarrow>\n                    v \\<in> dom (finished s) \\<and>\n                    \\<phi> s v \\<le> \\<phi> s w) \\<longrightarrow>\n                   (v, w) \\<in> back_edges s \\<or> (v, w) \\<in> pending s;\n        cond s; DFS_invar G param s; DFS_invar G param s'; stack s = [];\n        v0 \\<notin> dom (discovered s); v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, w)\\<in>E.\n                            v \\<in> dom (discovered s') \\<and>\n                            w \\<in> dom (discovered s') \\<and>\n                            \\<delta> s' w \\<le> \\<delta> s' v \\<and>\n                            (w \\<in> dom (finished s') \\<longrightarrow>\n                             v \\<in> dom (finished s') \\<and>\n                             \\<phi> s' v\n                             \\<le> \\<phi> s' w) \\<longrightarrow>\n                            (v, w) \\<in> back_edges s' \\<or>\n                            (v, w) \\<in> pending s'\n 3. \\<And>s s' u e.\n       \\<lbrakk>\\<forall>(v, w)\\<in>E.\n                   v \\<in> dom (discovered s) \\<and>\n                   w \\<in> dom (discovered s) \\<and>\n                   \\<delta> s w \\<le> \\<delta> s v \\<and>\n                   (w \\<in> dom (finished s) \\<longrightarrow>\n                    v \\<in> dom (finished s) \\<and>\n                    \\<phi> s v \\<le> \\<phi> s w) \\<longrightarrow>\n                   (v, w) \\<in> back_edges s \\<or> (v, w) \\<in> pending s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; pending s `` {u} = {}; u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, w)\\<in>E.\n                            v \\<in> dom (discovered s') \\<and>\n                            w \\<in> dom (discovered s') \\<and>\n                            \\<delta> s' w \\<le> \\<delta> s' v \\<and>\n                            (w \\<in> dom (finished s') \\<longrightarrow>\n                             v \\<in> dom (finished s') \\<and>\n                             \\<phi> s' v\n                             \\<le> \\<phi> s' w) \\<longrightarrow>\n                            (v, w) \\<in> back_edges s' \\<or>\n                            (v, w) \\<in> pending s'\n 4. \\<And>s s' u v e.\n       \\<lbrakk>\\<forall>(v, w)\\<in>E.\n                   v \\<in> dom (discovered s) \\<and>\n                   w \\<in> dom (discovered s) \\<and>\n                   \\<delta> s w \\<le> \\<delta> s v \\<and>\n                   (w \\<in> dom (finished s) \\<longrightarrow>\n                    v \\<in> dom (finished s) \\<and>\n                    \\<phi> s v \\<le> \\<phi> s w) \\<longrightarrow>\n                   (v, w) \\<in> back_edges s \\<or> (v, w) \\<in> pending s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        u = hd (stack s);\n        s' =\n        back_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, w)\\<in>E.\n                            v \\<in> dom (discovered s') \\<and>\n                            w \\<in> dom (discovered s') \\<and>\n                            \\<delta> s' w \\<le> \\<delta> s' v \\<and>\n                            (w \\<in> dom (finished s') \\<longrightarrow>\n                             v \\<in> dom (finished s') \\<and>\n                             \\<phi> s' v\n                             \\<le> \\<phi> s' w) \\<longrightarrow>\n                            (v, w) \\<in> back_edges s' \\<or>\n                            (v, w) \\<in> pending s'\n 5. \\<And>s s' u v e.\n       \\<lbrakk>\\<forall>(v, w)\\<in>E.\n                   v \\<in> dom (discovered s) \\<and>\n                   w \\<in> dom (discovered s) \\<and>\n                   \\<delta> s w \\<le> \\<delta> s v \\<and>\n                   (w \\<in> dom (finished s) \\<longrightarrow>\n                    v \\<in> dom (finished s) \\<and>\n                    \\<phi> s v \\<le> \\<phi> s w) \\<longrightarrow>\n                   (v, w) \\<in> back_edges s \\<or> (v, w) \\<in> pending s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, w)\\<in>E.\n                            v \\<in> dom (discovered s') \\<and>\n                            w \\<in> dom (discovered s') \\<and>\n                            \\<delta> s' w \\<le> \\<delta> s' v \\<and>\n                            (w \\<in> dom (finished s') \\<longrightarrow>\n                             v \\<in> dom (finished s') \\<and>\n                             \\<phi> s' v\n                             \\<le> \\<phi> s' w) \\<longrightarrow>\n                            (v, w) \\<in> back_edges s' \\<or>\n                            (v, w) \\<in> pending s'", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?w9 \\<in> E `` {hd (stack s)}; ?w9 \\<noteq> hd (stack s);\n   ?w9 \\<in> dom (discovered s);\n   ?w9 \\<in> dom (finished s) \\<longrightarrow>\n   counter s \\<le> \\<phi> s ?w9;\n   \\<delta> s ?w9 \\<le> \\<delta> s (hd (stack s))\\<rbrakk>\n  \\<Longrightarrow> (hd (stack s), ?w9) \\<in> back_edges s\n\ngoal (5 subgoals):\n 1. \\<And>e.\n       \\<forall>(v, w)\\<in>E.\n          v \\<in> dom (discovered (empty_state e)) \\<and>\n          w \\<in> dom (discovered (empty_state e)) \\<and>\n          \\<delta> (empty_state e) w \\<le> \\<delta> (empty_state e) v \\<and>\n          (w \\<in> dom (finished (empty_state e)) \\<longrightarrow>\n           v \\<in> dom (finished (empty_state e)) \\<and>\n           \\<phi> (empty_state e) v\n           \\<le> \\<phi> (empty_state e) w) \\<longrightarrow>\n          (v, w) \\<in> back_edges (empty_state e) \\<or>\n          (v, w) \\<in> pending (empty_state e)\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>\\<forall>(v, w)\\<in>E.\n                   v \\<in> dom (discovered s) \\<and>\n                   w \\<in> dom (discovered s) \\<and>\n                   \\<delta> s w \\<le> \\<delta> s v \\<and>\n                   (w \\<in> dom (finished s) \\<longrightarrow>\n                    v \\<in> dom (finished s) \\<and>\n                    \\<phi> s v \\<le> \\<phi> s w) \\<longrightarrow>\n                   (v, w) \\<in> back_edges s \\<or> (v, w) \\<in> pending s;\n        cond s; DFS_invar G param s; DFS_invar G param s'; stack s = [];\n        v0 \\<notin> dom (discovered s); v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, w)\\<in>E.\n                            v \\<in> dom (discovered s') \\<and>\n                            w \\<in> dom (discovered s') \\<and>\n                            \\<delta> s' w \\<le> \\<delta> s' v \\<and>\n                            (w \\<in> dom (finished s') \\<longrightarrow>\n                             v \\<in> dom (finished s') \\<and>\n                             \\<phi> s' v\n                             \\<le> \\<phi> s' w) \\<longrightarrow>\n                            (v, w) \\<in> back_edges s' \\<or>\n                            (v, w) \\<in> pending s'\n 3. \\<And>s s' u e.\n       \\<lbrakk>\\<forall>(v, w)\\<in>E.\n                   v \\<in> dom (discovered s) \\<and>\n                   w \\<in> dom (discovered s) \\<and>\n                   \\<delta> s w \\<le> \\<delta> s v \\<and>\n                   (w \\<in> dom (finished s) \\<longrightarrow>\n                    v \\<in> dom (finished s) \\<and>\n                    \\<phi> s v \\<le> \\<phi> s w) \\<longrightarrow>\n                   (v, w) \\<in> back_edges s \\<or> (v, w) \\<in> pending s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; pending s `` {u} = {}; u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, w)\\<in>E.\n                            v \\<in> dom (discovered s') \\<and>\n                            w \\<in> dom (discovered s') \\<and>\n                            \\<delta> s' w \\<le> \\<delta> s' v \\<and>\n                            (w \\<in> dom (finished s') \\<longrightarrow>\n                             v \\<in> dom (finished s') \\<and>\n                             \\<phi> s' v\n                             \\<le> \\<phi> s' w) \\<longrightarrow>\n                            (v, w) \\<in> back_edges s' \\<or>\n                            (v, w) \\<in> pending s'\n 4. \\<And>s s' u v e.\n       \\<lbrakk>\\<forall>(v, w)\\<in>E.\n                   v \\<in> dom (discovered s) \\<and>\n                   w \\<in> dom (discovered s) \\<and>\n                   \\<delta> s w \\<le> \\<delta> s v \\<and>\n                   (w \\<in> dom (finished s) \\<longrightarrow>\n                    v \\<in> dom (finished s) \\<and>\n                    \\<phi> s v \\<le> \\<phi> s w) \\<longrightarrow>\n                   (v, w) \\<in> back_edges s \\<or> (v, w) \\<in> pending s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        u = hd (stack s);\n        s' =\n        back_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, w)\\<in>E.\n                            v \\<in> dom (discovered s') \\<and>\n                            w \\<in> dom (discovered s') \\<and>\n                            \\<delta> s' w \\<le> \\<delta> s' v \\<and>\n                            (w \\<in> dom (finished s') \\<longrightarrow>\n                             v \\<in> dom (finished s') \\<and>\n                             \\<phi> s' v\n                             \\<le> \\<phi> s' w) \\<longrightarrow>\n                            (v, w) \\<in> back_edges s' \\<or>\n                            (v, w) \\<in> pending s'\n 5. \\<And>s s' u v e.\n       \\<lbrakk>\\<forall>(v, w)\\<in>E.\n                   v \\<in> dom (discovered s) \\<and>\n                   w \\<in> dom (discovered s) \\<and>\n                   \\<delta> s w \\<le> \\<delta> s v \\<and>\n                   (w \\<in> dom (finished s) \\<longrightarrow>\n                    v \\<in> dom (finished s) \\<and>\n                    \\<phi> s v \\<le> \\<phi> s w) \\<longrightarrow>\n                   (v, w) \\<in> back_edges s \\<or> (v, w) \\<in> pending s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, w)\\<in>E.\n                            v \\<in> dom (discovered s') \\<and>\n                            w \\<in> dom (discovered s') \\<and>\n                            \\<delta> s' w \\<le> \\<delta> s' v \\<and>\n                            (w \\<in> dom (finished s') \\<longrightarrow>\n                             v \\<in> dom (finished s') \\<and>\n                             \\<phi> s' v\n                             \\<le> \\<phi> s' w) \\<longrightarrow>\n                            (v, w) \\<in> back_edges s' \\<or>\n                            (v, w) \\<in> pending s'", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>?w9 \\<in> E `` {hd (stack s)}; ?w9 \\<noteq> hd (stack s);\n   ?w9 \\<in> dom (discovered s);\n   ?w9 \\<in> dom (finished s) \\<longrightarrow>\n   counter s \\<le> \\<phi> s ?w9;\n   \\<delta> s ?w9 \\<le> \\<delta> s (hd (stack s))\\<rbrakk>\n  \\<Longrightarrow> (hd (stack s), ?w9) \\<in> back_edges s\n\ngoal (5 subgoals):\n 1. \\<And>e.\n       \\<forall>(v, w)\\<in>E.\n          v \\<in> dom (discovered (empty_state e)) \\<and>\n          w \\<in> dom (discovered (empty_state e)) \\<and>\n          \\<delta> (empty_state e) w \\<le> \\<delta> (empty_state e) v \\<and>\n          (w \\<in> dom (finished (empty_state e)) \\<longrightarrow>\n           v \\<in> dom (finished (empty_state e)) \\<and>\n           \\<phi> (empty_state e) v\n           \\<le> \\<phi> (empty_state e) w) \\<longrightarrow>\n          (v, w) \\<in> back_edges (empty_state e) \\<or>\n          (v, w) \\<in> pending (empty_state e)\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>\\<forall>(v, w)\\<in>E.\n                   v \\<in> dom (discovered s) \\<and>\n                   w \\<in> dom (discovered s) \\<and>\n                   \\<delta> s w \\<le> \\<delta> s v \\<and>\n                   (w \\<in> dom (finished s) \\<longrightarrow>\n                    v \\<in> dom (finished s) \\<and>\n                    \\<phi> s v \\<le> \\<phi> s w) \\<longrightarrow>\n                   (v, w) \\<in> back_edges s \\<or> (v, w) \\<in> pending s;\n        cond s; DFS_invar G param s; DFS_invar G param s'; stack s = [];\n        v0 \\<notin> dom (discovered s); v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, w)\\<in>E.\n                            v \\<in> dom (discovered s') \\<and>\n                            w \\<in> dom (discovered s') \\<and>\n                            \\<delta> s' w \\<le> \\<delta> s' v \\<and>\n                            (w \\<in> dom (finished s') \\<longrightarrow>\n                             v \\<in> dom (finished s') \\<and>\n                             \\<phi> s' v\n                             \\<le> \\<phi> s' w) \\<longrightarrow>\n                            (v, w) \\<in> back_edges s' \\<or>\n                            (v, w) \\<in> pending s'\n 3. \\<And>s s' u e.\n       \\<lbrakk>\\<forall>(v, w)\\<in>E.\n                   v \\<in> dom (discovered s) \\<and>\n                   w \\<in> dom (discovered s) \\<and>\n                   \\<delta> s w \\<le> \\<delta> s v \\<and>\n                   (w \\<in> dom (finished s) \\<longrightarrow>\n                    v \\<in> dom (finished s) \\<and>\n                    \\<phi> s v \\<le> \\<phi> s w) \\<longrightarrow>\n                   (v, w) \\<in> back_edges s \\<or> (v, w) \\<in> pending s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; pending s `` {u} = {}; u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, w)\\<in>E.\n                            v \\<in> dom (discovered s') \\<and>\n                            w \\<in> dom (discovered s') \\<and>\n                            \\<delta> s' w \\<le> \\<delta> s' v \\<and>\n                            (w \\<in> dom (finished s') \\<longrightarrow>\n                             v \\<in> dom (finished s') \\<and>\n                             \\<phi> s' v\n                             \\<le> \\<phi> s' w) \\<longrightarrow>\n                            (v, w) \\<in> back_edges s' \\<or>\n                            (v, w) \\<in> pending s'\n 4. \\<And>s s' u v e.\n       \\<lbrakk>\\<forall>(v, w)\\<in>E.\n                   v \\<in> dom (discovered s) \\<and>\n                   w \\<in> dom (discovered s) \\<and>\n                   \\<delta> s w \\<le> \\<delta> s v \\<and>\n                   (w \\<in> dom (finished s) \\<longrightarrow>\n                    v \\<in> dom (finished s) \\<and>\n                    \\<phi> s v \\<le> \\<phi> s w) \\<longrightarrow>\n                   (v, w) \\<in> back_edges s \\<or> (v, w) \\<in> pending s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        u = hd (stack s);\n        s' =\n        back_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, w)\\<in>E.\n                            v \\<in> dom (discovered s') \\<and>\n                            w \\<in> dom (discovered s') \\<and>\n                            \\<delta> s' w \\<le> \\<delta> s' v \\<and>\n                            (w \\<in> dom (finished s') \\<longrightarrow>\n                             v \\<in> dom (finished s') \\<and>\n                             \\<phi> s' v\n                             \\<le> \\<phi> s' w) \\<longrightarrow>\n                            (v, w) \\<in> back_edges s' \\<or>\n                            (v, w) \\<in> pending s'\n 5. \\<And>s s' u v e.\n       \\<lbrakk>\\<forall>(v, w)\\<in>E.\n                   v \\<in> dom (discovered s) \\<and>\n                   w \\<in> dom (discovered s) \\<and>\n                   \\<delta> s w \\<le> \\<delta> s v \\<and>\n                   (w \\<in> dom (finished s) \\<longrightarrow>\n                    v \\<in> dom (finished s) \\<and>\n                    \\<phi> s v \\<le> \\<phi> s w) \\<longrightarrow>\n                   (v, w) \\<in> back_edges s \\<or> (v, w) \\<in> pending s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, w)\\<in>E.\n                            v \\<in> dom (discovered s') \\<and>\n                            w \\<in> dom (discovered s') \\<and>\n                            \\<delta> s' w \\<le> \\<delta> s' v \\<and>\n                            (w \\<in> dom (finished s') \\<longrightarrow>\n                             v \\<in> dom (finished s') \\<and>\n                             \\<phi> s' v\n                             \\<le> \\<phi> s' w) \\<longrightarrow>\n                            (v, w) \\<in> back_edges s' \\<or>\n                            (v, w) \\<in> pending s'", "{"], ["proof (state)\nthis:\n  \\<lbrakk>?w9 \\<in> E `` {hd (stack s)}; ?w9 \\<noteq> hd (stack s);\n   ?w9 \\<in> dom (discovered s);\n   ?w9 \\<in> dom (finished s) \\<longrightarrow>\n   counter s \\<le> \\<phi> s ?w9;\n   \\<delta> s ?w9 \\<le> \\<delta> s (hd (stack s))\\<rbrakk>\n  \\<Longrightarrow> (hd (stack s), ?w9) \\<in> back_edges s\n\ngoal (5 subgoals):\n 1. \\<And>e.\n       \\<forall>(v, w)\\<in>E.\n          v \\<in> dom (discovered (empty_state e)) \\<and>\n          w \\<in> dom (discovered (empty_state e)) \\<and>\n          \\<delta> (empty_state e) w \\<le> \\<delta> (empty_state e) v \\<and>\n          (w \\<in> dom (finished (empty_state e)) \\<longrightarrow>\n           v \\<in> dom (finished (empty_state e)) \\<and>\n           \\<phi> (empty_state e) v\n           \\<le> \\<phi> (empty_state e) w) \\<longrightarrow>\n          (v, w) \\<in> back_edges (empty_state e) \\<or>\n          (v, w) \\<in> pending (empty_state e)\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>\\<forall>(v, w)\\<in>E.\n                   v \\<in> dom (discovered s) \\<and>\n                   w \\<in> dom (discovered s) \\<and>\n                   \\<delta> s w \\<le> \\<delta> s v \\<and>\n                   (w \\<in> dom (finished s) \\<longrightarrow>\n                    v \\<in> dom (finished s) \\<and>\n                    \\<phi> s v \\<le> \\<phi> s w) \\<longrightarrow>\n                   (v, w) \\<in> back_edges s \\<or> (v, w) \\<in> pending s;\n        cond s; DFS_invar G param s; DFS_invar G param s'; stack s = [];\n        v0 \\<notin> dom (discovered s); v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, w)\\<in>E.\n                            v \\<in> dom (discovered s') \\<and>\n                            w \\<in> dom (discovered s') \\<and>\n                            \\<delta> s' w \\<le> \\<delta> s' v \\<and>\n                            (w \\<in> dom (finished s') \\<longrightarrow>\n                             v \\<in> dom (finished s') \\<and>\n                             \\<phi> s' v\n                             \\<le> \\<phi> s' w) \\<longrightarrow>\n                            (v, w) \\<in> back_edges s' \\<or>\n                            (v, w) \\<in> pending s'\n 3. \\<And>s s' u e.\n       \\<lbrakk>\\<forall>(v, w)\\<in>E.\n                   v \\<in> dom (discovered s) \\<and>\n                   w \\<in> dom (discovered s) \\<and>\n                   \\<delta> s w \\<le> \\<delta> s v \\<and>\n                   (w \\<in> dom (finished s) \\<longrightarrow>\n                    v \\<in> dom (finished s) \\<and>\n                    \\<phi> s v \\<le> \\<phi> s w) \\<longrightarrow>\n                   (v, w) \\<in> back_edges s \\<or> (v, w) \\<in> pending s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; pending s `` {u} = {}; u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, w)\\<in>E.\n                            v \\<in> dom (discovered s') \\<and>\n                            w \\<in> dom (discovered s') \\<and>\n                            \\<delta> s' w \\<le> \\<delta> s' v \\<and>\n                            (w \\<in> dom (finished s') \\<longrightarrow>\n                             v \\<in> dom (finished s') \\<and>\n                             \\<phi> s' v\n                             \\<le> \\<phi> s' w) \\<longrightarrow>\n                            (v, w) \\<in> back_edges s' \\<or>\n                            (v, w) \\<in> pending s'\n 4. \\<And>s s' u v e.\n       \\<lbrakk>\\<forall>(v, w)\\<in>E.\n                   v \\<in> dom (discovered s) \\<and>\n                   w \\<in> dom (discovered s) \\<and>\n                   \\<delta> s w \\<le> \\<delta> s v \\<and>\n                   (w \\<in> dom (finished s) \\<longrightarrow>\n                    v \\<in> dom (finished s) \\<and>\n                    \\<phi> s v \\<le> \\<phi> s w) \\<longrightarrow>\n                   (v, w) \\<in> back_edges s \\<or> (v, w) \\<in> pending s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        u = hd (stack s);\n        s' =\n        back_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, w)\\<in>E.\n                            v \\<in> dom (discovered s') \\<and>\n                            w \\<in> dom (discovered s') \\<and>\n                            \\<delta> s' w \\<le> \\<delta> s' v \\<and>\n                            (w \\<in> dom (finished s') \\<longrightarrow>\n                             v \\<in> dom (finished s') \\<and>\n                             \\<phi> s' v\n                             \\<le> \\<phi> s' w) \\<longrightarrow>\n                            (v, w) \\<in> back_edges s' \\<or>\n                            (v, w) \\<in> pending s'\n 5. \\<And>s s' u v e.\n       \\<lbrakk>\\<forall>(v, w)\\<in>E.\n                   v \\<in> dom (discovered s) \\<and>\n                   w \\<in> dom (discovered s) \\<and>\n                   \\<delta> s w \\<le> \\<delta> s v \\<and>\n                   (w \\<in> dom (finished s) \\<longrightarrow>\n                    v \\<in> dom (finished s) \\<and>\n                    \\<phi> s v \\<le> \\<phi> s w) \\<longrightarrow>\n                   (v, w) \\<in> back_edges s \\<or> (v, w) \\<in> pending s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, w)\\<in>E.\n                            v \\<in> dom (discovered s') \\<and>\n                            w \\<in> dom (discovered s') \\<and>\n                            \\<delta> s' w \\<le> \\<delta> s' v \\<and>\n                            (w \\<in> dom (finished s') \\<longrightarrow>\n                             v \\<in> dom (finished s') \\<and>\n                             \\<phi> s' v\n                             \\<le> \\<phi> s' w) \\<longrightarrow>\n                            (v, w) \\<in> back_edges s' \\<or>\n                            (v, w) \\<in> pending s'", "fix w"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>e.\n       \\<forall>(v, w)\\<in>E.\n          v \\<in> dom (discovered (empty_state e)) \\<and>\n          w \\<in> dom (discovered (empty_state e)) \\<and>\n          \\<delta> (empty_state e) w \\<le> \\<delta> (empty_state e) v \\<and>\n          (w \\<in> dom (finished (empty_state e)) \\<longrightarrow>\n           v \\<in> dom (finished (empty_state e)) \\<and>\n           \\<phi> (empty_state e) v\n           \\<le> \\<phi> (empty_state e) w) \\<longrightarrow>\n          (v, w) \\<in> back_edges (empty_state e) \\<or>\n          (v, w) \\<in> pending (empty_state e)\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>\\<forall>(v, w)\\<in>E.\n                   v \\<in> dom (discovered s) \\<and>\n                   w \\<in> dom (discovered s) \\<and>\n                   \\<delta> s w \\<le> \\<delta> s v \\<and>\n                   (w \\<in> dom (finished s) \\<longrightarrow>\n                    v \\<in> dom (finished s) \\<and>\n                    \\<phi> s v \\<le> \\<phi> s w) \\<longrightarrow>\n                   (v, w) \\<in> back_edges s \\<or> (v, w) \\<in> pending s;\n        cond s; DFS_invar G param s; DFS_invar G param s'; stack s = [];\n        v0 \\<notin> dom (discovered s); v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, w)\\<in>E.\n                            v \\<in> dom (discovered s') \\<and>\n                            w \\<in> dom (discovered s') \\<and>\n                            \\<delta> s' w \\<le> \\<delta> s' v \\<and>\n                            (w \\<in> dom (finished s') \\<longrightarrow>\n                             v \\<in> dom (finished s') \\<and>\n                             \\<phi> s' v\n                             \\<le> \\<phi> s' w) \\<longrightarrow>\n                            (v, w) \\<in> back_edges s' \\<or>\n                            (v, w) \\<in> pending s'\n 3. \\<And>s s' u e.\n       \\<lbrakk>\\<forall>(v, w)\\<in>E.\n                   v \\<in> dom (discovered s) \\<and>\n                   w \\<in> dom (discovered s) \\<and>\n                   \\<delta> s w \\<le> \\<delta> s v \\<and>\n                   (w \\<in> dom (finished s) \\<longrightarrow>\n                    v \\<in> dom (finished s) \\<and>\n                    \\<phi> s v \\<le> \\<phi> s w) \\<longrightarrow>\n                   (v, w) \\<in> back_edges s \\<or> (v, w) \\<in> pending s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; pending s `` {u} = {}; u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, w)\\<in>E.\n                            v \\<in> dom (discovered s') \\<and>\n                            w \\<in> dom (discovered s') \\<and>\n                            \\<delta> s' w \\<le> \\<delta> s' v \\<and>\n                            (w \\<in> dom (finished s') \\<longrightarrow>\n                             v \\<in> dom (finished s') \\<and>\n                             \\<phi> s' v\n                             \\<le> \\<phi> s' w) \\<longrightarrow>\n                            (v, w) \\<in> back_edges s' \\<or>\n                            (v, w) \\<in> pending s'\n 4. \\<And>s s' u v e.\n       \\<lbrakk>\\<forall>(v, w)\\<in>E.\n                   v \\<in> dom (discovered s) \\<and>\n                   w \\<in> dom (discovered s) \\<and>\n                   \\<delta> s w \\<le> \\<delta> s v \\<and>\n                   (w \\<in> dom (finished s) \\<longrightarrow>\n                    v \\<in> dom (finished s) \\<and>\n                    \\<phi> s v \\<le> \\<phi> s w) \\<longrightarrow>\n                   (v, w) \\<in> back_edges s \\<or> (v, w) \\<in> pending s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        u = hd (stack s);\n        s' =\n        back_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, w)\\<in>E.\n                            v \\<in> dom (discovered s') \\<and>\n                            w \\<in> dom (discovered s') \\<and>\n                            \\<delta> s' w \\<le> \\<delta> s' v \\<and>\n                            (w \\<in> dom (finished s') \\<longrightarrow>\n                             v \\<in> dom (finished s') \\<and>\n                             \\<phi> s' v\n                             \\<le> \\<phi> s' w) \\<longrightarrow>\n                            (v, w) \\<in> back_edges s' \\<or>\n                            (v, w) \\<in> pending s'\n 5. \\<And>s s' u v e.\n       \\<lbrakk>\\<forall>(v, w)\\<in>E.\n                   v \\<in> dom (discovered s) \\<and>\n                   w \\<in> dom (discovered s) \\<and>\n                   \\<delta> s w \\<le> \\<delta> s v \\<and>\n                   (w \\<in> dom (finished s) \\<longrightarrow>\n                    v \\<in> dom (finished s) \\<and>\n                    \\<phi> s v \\<le> \\<phi> s w) \\<longrightarrow>\n                   (v, w) \\<in> back_edges s \\<or> (v, w) \\<in> pending s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, w)\\<in>E.\n                            v \\<in> dom (discovered s') \\<and>\n                            w \\<in> dom (discovered s') \\<and>\n                            \\<delta> s' w \\<le> \\<delta> s' v \\<and>\n                            (w \\<in> dom (finished s') \\<longrightarrow>\n                             v \\<in> dom (finished s') \\<and>\n                             \\<phi> s' v\n                             \\<le> \\<phi> s' w) \\<longrightarrow>\n                            (v, w) \\<in> back_edges s' \\<or>\n                            (v, w) \\<in> pending s'", "assume \"hd (stack s) \\<in> succ w\" \"w \\<noteq> hd (stack s)\"\n      and \"w \\<in> dom (finished s)\" \"\\<delta> s (hd (stack s)) \\<le> \\<delta> s w\""], ["proof (state)\nthis:\n  hd (stack s) \\<in> E `` {w}\n  w \\<noteq> hd (stack s)\n  w \\<in> dom (finished s)\n  \\<delta> s (hd (stack s)) \\<le> \\<delta> s w\n\ngoal (5 subgoals):\n 1. \\<And>e.\n       \\<forall>(v, w)\\<in>E.\n          v \\<in> dom (discovered (empty_state e)) \\<and>\n          w \\<in> dom (discovered (empty_state e)) \\<and>\n          \\<delta> (empty_state e) w \\<le> \\<delta> (empty_state e) v \\<and>\n          (w \\<in> dom (finished (empty_state e)) \\<longrightarrow>\n           v \\<in> dom (finished (empty_state e)) \\<and>\n           \\<phi> (empty_state e) v\n           \\<le> \\<phi> (empty_state e) w) \\<longrightarrow>\n          (v, w) \\<in> back_edges (empty_state e) \\<or>\n          (v, w) \\<in> pending (empty_state e)\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>\\<forall>(v, w)\\<in>E.\n                   v \\<in> dom (discovered s) \\<and>\n                   w \\<in> dom (discovered s) \\<and>\n                   \\<delta> s w \\<le> \\<delta> s v \\<and>\n                   (w \\<in> dom (finished s) \\<longrightarrow>\n                    v \\<in> dom (finished s) \\<and>\n                    \\<phi> s v \\<le> \\<phi> s w) \\<longrightarrow>\n                   (v, w) \\<in> back_edges s \\<or> (v, w) \\<in> pending s;\n        cond s; DFS_invar G param s; DFS_invar G param s'; stack s = [];\n        v0 \\<notin> dom (discovered s); v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, w)\\<in>E.\n                            v \\<in> dom (discovered s') \\<and>\n                            w \\<in> dom (discovered s') \\<and>\n                            \\<delta> s' w \\<le> \\<delta> s' v \\<and>\n                            (w \\<in> dom (finished s') \\<longrightarrow>\n                             v \\<in> dom (finished s') \\<and>\n                             \\<phi> s' v\n                             \\<le> \\<phi> s' w) \\<longrightarrow>\n                            (v, w) \\<in> back_edges s' \\<or>\n                            (v, w) \\<in> pending s'\n 3. \\<And>s s' u e.\n       \\<lbrakk>\\<forall>(v, w)\\<in>E.\n                   v \\<in> dom (discovered s) \\<and>\n                   w \\<in> dom (discovered s) \\<and>\n                   \\<delta> s w \\<le> \\<delta> s v \\<and>\n                   (w \\<in> dom (finished s) \\<longrightarrow>\n                    v \\<in> dom (finished s) \\<and>\n                    \\<phi> s v \\<le> \\<phi> s w) \\<longrightarrow>\n                   (v, w) \\<in> back_edges s \\<or> (v, w) \\<in> pending s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; pending s `` {u} = {}; u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, w)\\<in>E.\n                            v \\<in> dom (discovered s') \\<and>\n                            w \\<in> dom (discovered s') \\<and>\n                            \\<delta> s' w \\<le> \\<delta> s' v \\<and>\n                            (w \\<in> dom (finished s') \\<longrightarrow>\n                             v \\<in> dom (finished s') \\<and>\n                             \\<phi> s' v\n                             \\<le> \\<phi> s' w) \\<longrightarrow>\n                            (v, w) \\<in> back_edges s' \\<or>\n                            (v, w) \\<in> pending s'\n 4. \\<And>s s' u v e.\n       \\<lbrakk>\\<forall>(v, w)\\<in>E.\n                   v \\<in> dom (discovered s) \\<and>\n                   w \\<in> dom (discovered s) \\<and>\n                   \\<delta> s w \\<le> \\<delta> s v \\<and>\n                   (w \\<in> dom (finished s) \\<longrightarrow>\n                    v \\<in> dom (finished s) \\<and>\n                    \\<phi> s v \\<le> \\<phi> s w) \\<longrightarrow>\n                   (v, w) \\<in> back_edges s \\<or> (v, w) \\<in> pending s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        u = hd (stack s);\n        s' =\n        back_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, w)\\<in>E.\n                            v \\<in> dom (discovered s') \\<and>\n                            w \\<in> dom (discovered s') \\<and>\n                            \\<delta> s' w \\<le> \\<delta> s' v \\<and>\n                            (w \\<in> dom (finished s') \\<longrightarrow>\n                             v \\<in> dom (finished s') \\<and>\n                             \\<phi> s' v\n                             \\<le> \\<phi> s' w) \\<longrightarrow>\n                            (v, w) \\<in> back_edges s' \\<or>\n                            (v, w) \\<in> pending s'\n 5. \\<And>s s' u v e.\n       \\<lbrakk>\\<forall>(v, w)\\<in>E.\n                   v \\<in> dom (discovered s) \\<and>\n                   w \\<in> dom (discovered s) \\<and>\n                   \\<delta> s w \\<le> \\<delta> s v \\<and>\n                   (w \\<in> dom (finished s) \\<longrightarrow>\n                    v \\<in> dom (finished s) \\<and>\n                    \\<phi> s v \\<le> \\<phi> s w) \\<longrightarrow>\n                   (v, w) \\<in> back_edges s \\<or> (v, w) \\<in> pending s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, w)\\<in>E.\n                            v \\<in> dom (discovered s') \\<and>\n                            w \\<in> dom (discovered s') \\<and>\n                            \\<delta> s' w \\<le> \\<delta> s' v \\<and>\n                            (w \\<in> dom (finished s') \\<longrightarrow>\n                             v \\<in> dom (finished s') \\<and>\n                             \\<phi> s' v\n                             \\<le> \\<phi> s' w) \\<longrightarrow>\n                            (v, w) \\<in> back_edges s' \\<or>\n                            (v, w) \\<in> pending s'", "with IH[of \"hd (stack s)\" w] disc not_fin"], ["proof (chain)\npicking this:\n  \\<lbrakk>hd (stack s) \\<in> E `` {w}; w \\<in> dom (discovered s);\n   hd (stack s) \\<in> dom (discovered s);\n   \\<delta> s (hd (stack s)) \\<le> \\<delta> s w;\n   hd (stack s) \\<in> dom (finished s) \\<Longrightarrow>\n   w \\<in> dom (finished s) \\<and>\n   \\<phi> s w \\<le> \\<phi> s (hd (stack s))\\<rbrakk>\n  \\<Longrightarrow> (w, hd (stack s)) \\<in> back_edges s \\<or>\n                    (w, hd (stack s)) \\<in> pending s\n  hd (stack s) \\<in> dom (discovered s)\n  hd (stack s) \\<notin> dom (finished s)\n  hd (stack s) \\<in> E `` {w}\n  w \\<noteq> hd (stack s)\n  w \\<in> dom (finished s)\n  \\<delta> s (hd (stack s)) \\<le> \\<delta> s w", "have\n        \"(w, hd (stack s)) \\<in> back_edges s\""], ["proof (prove)\nusing this:\n  \\<lbrakk>hd (stack s) \\<in> E `` {w}; w \\<in> dom (discovered s);\n   hd (stack s) \\<in> dom (discovered s);\n   \\<delta> s (hd (stack s)) \\<le> \\<delta> s w;\n   hd (stack s) \\<in> dom (finished s) \\<Longrightarrow>\n   w \\<in> dom (finished s) \\<and>\n   \\<phi> s w \\<le> \\<phi> s (hd (stack s))\\<rbrakk>\n  \\<Longrightarrow> (w, hd (stack s)) \\<in> back_edges s \\<or>\n                    (w, hd (stack s)) \\<in> pending s\n  hd (stack s) \\<in> dom (discovered s)\n  hd (stack s) \\<notin> dom (finished s)\n  hd (stack s) \\<in> E `` {w}\n  w \\<noteq> hd (stack s)\n  w \\<in> dom (finished s)\n  \\<delta> s (hd (stack s)) \\<le> \\<delta> s w\n\ngoal (1 subgoal):\n 1. (w, hd (stack s)) \\<in> back_edges s", "using finished_discovered finished_no_pending[of w]"], ["proof (prove)\nusing this:\n  \\<lbrakk>hd (stack s) \\<in> E `` {w}; w \\<in> dom (discovered s);\n   hd (stack s) \\<in> dom (discovered s);\n   \\<delta> s (hd (stack s)) \\<le> \\<delta> s w;\n   hd (stack s) \\<in> dom (finished s) \\<Longrightarrow>\n   w \\<in> dom (finished s) \\<and>\n   \\<phi> s w \\<le> \\<phi> s (hd (stack s))\\<rbrakk>\n  \\<Longrightarrow> (w, hd (stack s)) \\<in> back_edges s \\<or>\n                    (w, hd (stack s)) \\<in> pending s\n  hd (stack s) \\<in> dom (discovered s)\n  hd (stack s) \\<notin> dom (finished s)\n  hd (stack s) \\<in> E `` {w}\n  w \\<noteq> hd (stack s)\n  w \\<in> dom (finished s)\n  \\<delta> s (hd (stack s)) \\<le> \\<delta> s w\n  dom (finished s) \\<subseteq> dom (discovered s)\n  w \\<in> dom (finished s) \\<Longrightarrow> pending s `` {w} = {}\n\ngoal (1 subgoal):\n 1. (w, hd (stack s)) \\<in> back_edges s", "by blast"], ["proof (state)\nthis:\n  (w, hd (stack s)) \\<in> back_edges s\n\ngoal (5 subgoals):\n 1. \\<And>e.\n       \\<forall>(v, w)\\<in>E.\n          v \\<in> dom (discovered (empty_state e)) \\<and>\n          w \\<in> dom (discovered (empty_state e)) \\<and>\n          \\<delta> (empty_state e) w \\<le> \\<delta> (empty_state e) v \\<and>\n          (w \\<in> dom (finished (empty_state e)) \\<longrightarrow>\n           v \\<in> dom (finished (empty_state e)) \\<and>\n           \\<phi> (empty_state e) v\n           \\<le> \\<phi> (empty_state e) w) \\<longrightarrow>\n          (v, w) \\<in> back_edges (empty_state e) \\<or>\n          (v, w) \\<in> pending (empty_state e)\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>\\<forall>(v, w)\\<in>E.\n                   v \\<in> dom (discovered s) \\<and>\n                   w \\<in> dom (discovered s) \\<and>\n                   \\<delta> s w \\<le> \\<delta> s v \\<and>\n                   (w \\<in> dom (finished s) \\<longrightarrow>\n                    v \\<in> dom (finished s) \\<and>\n                    \\<phi> s v \\<le> \\<phi> s w) \\<longrightarrow>\n                   (v, w) \\<in> back_edges s \\<or> (v, w) \\<in> pending s;\n        cond s; DFS_invar G param s; DFS_invar G param s'; stack s = [];\n        v0 \\<notin> dom (discovered s); v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, w)\\<in>E.\n                            v \\<in> dom (discovered s') \\<and>\n                            w \\<in> dom (discovered s') \\<and>\n                            \\<delta> s' w \\<le> \\<delta> s' v \\<and>\n                            (w \\<in> dom (finished s') \\<longrightarrow>\n                             v \\<in> dom (finished s') \\<and>\n                             \\<phi> s' v\n                             \\<le> \\<phi> s' w) \\<longrightarrow>\n                            (v, w) \\<in> back_edges s' \\<or>\n                            (v, w) \\<in> pending s'\n 3. \\<And>s s' u e.\n       \\<lbrakk>\\<forall>(v, w)\\<in>E.\n                   v \\<in> dom (discovered s) \\<and>\n                   w \\<in> dom (discovered s) \\<and>\n                   \\<delta> s w \\<le> \\<delta> s v \\<and>\n                   (w \\<in> dom (finished s) \\<longrightarrow>\n                    v \\<in> dom (finished s) \\<and>\n                    \\<phi> s v \\<le> \\<phi> s w) \\<longrightarrow>\n                   (v, w) \\<in> back_edges s \\<or> (v, w) \\<in> pending s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; pending s `` {u} = {}; u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, w)\\<in>E.\n                            v \\<in> dom (discovered s') \\<and>\n                            w \\<in> dom (discovered s') \\<and>\n                            \\<delta> s' w \\<le> \\<delta> s' v \\<and>\n                            (w \\<in> dom (finished s') \\<longrightarrow>\n                             v \\<in> dom (finished s') \\<and>\n                             \\<phi> s' v\n                             \\<le> \\<phi> s' w) \\<longrightarrow>\n                            (v, w) \\<in> back_edges s' \\<or>\n                            (v, w) \\<in> pending s'\n 4. \\<And>s s' u v e.\n       \\<lbrakk>\\<forall>(v, w)\\<in>E.\n                   v \\<in> dom (discovered s) \\<and>\n                   w \\<in> dom (discovered s) \\<and>\n                   \\<delta> s w \\<le> \\<delta> s v \\<and>\n                   (w \\<in> dom (finished s) \\<longrightarrow>\n                    v \\<in> dom (finished s) \\<and>\n                    \\<phi> s v \\<le> \\<phi> s w) \\<longrightarrow>\n                   (v, w) \\<in> back_edges s \\<or> (v, w) \\<in> pending s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        u = hd (stack s);\n        s' =\n        back_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, w)\\<in>E.\n                            v \\<in> dom (discovered s') \\<and>\n                            w \\<in> dom (discovered s') \\<and>\n                            \\<delta> s' w \\<le> \\<delta> s' v \\<and>\n                            (w \\<in> dom (finished s') \\<longrightarrow>\n                             v \\<in> dom (finished s') \\<and>\n                             \\<phi> s' v\n                             \\<le> \\<phi> s' w) \\<longrightarrow>\n                            (v, w) \\<in> back_edges s' \\<or>\n                            (v, w) \\<in> pending s'\n 5. \\<And>s s' u v e.\n       \\<lbrakk>\\<forall>(v, w)\\<in>E.\n                   v \\<in> dom (discovered s) \\<and>\n                   w \\<in> dom (discovered s) \\<and>\n                   \\<delta> s w \\<le> \\<delta> s v \\<and>\n                   (w \\<in> dom (finished s) \\<longrightarrow>\n                    v \\<in> dom (finished s) \\<and>\n                    \\<phi> s v \\<le> \\<phi> s w) \\<longrightarrow>\n                   (v, w) \\<in> back_edges s \\<or> (v, w) \\<in> pending s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, w)\\<in>E.\n                            v \\<in> dom (discovered s') \\<and>\n                            w \\<in> dom (discovered s') \\<and>\n                            \\<delta> s' w \\<le> \\<delta> s' v \\<and>\n                            (w \\<in> dom (finished s') \\<longrightarrow>\n                             v \\<in> dom (finished s') \\<and>\n                             \\<phi> s' v\n                             \\<le> \\<phi> s' w) \\<longrightarrow>\n                            (v, w) \\<in> back_edges s' \\<or>\n                            (v, w) \\<in> pending s'", "}"], ["proof (state)\nthis:\n  \\<lbrakk>hd (stack s) \\<in> E `` {?w9}; ?w9 \\<noteq> hd (stack s);\n   ?w9 \\<in> dom (finished s);\n   \\<delta> s (hd (stack s)) \\<le> \\<delta> s ?w9\\<rbrakk>\n  \\<Longrightarrow> (?w9, hd (stack s)) \\<in> back_edges s\n\ngoal (5 subgoals):\n 1. \\<And>e.\n       \\<forall>(v, w)\\<in>E.\n          v \\<in> dom (discovered (empty_state e)) \\<and>\n          w \\<in> dom (discovered (empty_state e)) \\<and>\n          \\<delta> (empty_state e) w \\<le> \\<delta> (empty_state e) v \\<and>\n          (w \\<in> dom (finished (empty_state e)) \\<longrightarrow>\n           v \\<in> dom (finished (empty_state e)) \\<and>\n           \\<phi> (empty_state e) v\n           \\<le> \\<phi> (empty_state e) w) \\<longrightarrow>\n          (v, w) \\<in> back_edges (empty_state e) \\<or>\n          (v, w) \\<in> pending (empty_state e)\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>\\<forall>(v, w)\\<in>E.\n                   v \\<in> dom (discovered s) \\<and>\n                   w \\<in> dom (discovered s) \\<and>\n                   \\<delta> s w \\<le> \\<delta> s v \\<and>\n                   (w \\<in> dom (finished s) \\<longrightarrow>\n                    v \\<in> dom (finished s) \\<and>\n                    \\<phi> s v \\<le> \\<phi> s w) \\<longrightarrow>\n                   (v, w) \\<in> back_edges s \\<or> (v, w) \\<in> pending s;\n        cond s; DFS_invar G param s; DFS_invar G param s'; stack s = [];\n        v0 \\<notin> dom (discovered s); v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, w)\\<in>E.\n                            v \\<in> dom (discovered s') \\<and>\n                            w \\<in> dom (discovered s') \\<and>\n                            \\<delta> s' w \\<le> \\<delta> s' v \\<and>\n                            (w \\<in> dom (finished s') \\<longrightarrow>\n                             v \\<in> dom (finished s') \\<and>\n                             \\<phi> s' v\n                             \\<le> \\<phi> s' w) \\<longrightarrow>\n                            (v, w) \\<in> back_edges s' \\<or>\n                            (v, w) \\<in> pending s'\n 3. \\<And>s s' u e.\n       \\<lbrakk>\\<forall>(v, w)\\<in>E.\n                   v \\<in> dom (discovered s) \\<and>\n                   w \\<in> dom (discovered s) \\<and>\n                   \\<delta> s w \\<le> \\<delta> s v \\<and>\n                   (w \\<in> dom (finished s) \\<longrightarrow>\n                    v \\<in> dom (finished s) \\<and>\n                    \\<phi> s v \\<le> \\<phi> s w) \\<longrightarrow>\n                   (v, w) \\<in> back_edges s \\<or> (v, w) \\<in> pending s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; pending s `` {u} = {}; u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, w)\\<in>E.\n                            v \\<in> dom (discovered s') \\<and>\n                            w \\<in> dom (discovered s') \\<and>\n                            \\<delta> s' w \\<le> \\<delta> s' v \\<and>\n                            (w \\<in> dom (finished s') \\<longrightarrow>\n                             v \\<in> dom (finished s') \\<and>\n                             \\<phi> s' v\n                             \\<le> \\<phi> s' w) \\<longrightarrow>\n                            (v, w) \\<in> back_edges s' \\<or>\n                            (v, w) \\<in> pending s'\n 4. \\<And>s s' u v e.\n       \\<lbrakk>\\<forall>(v, w)\\<in>E.\n                   v \\<in> dom (discovered s) \\<and>\n                   w \\<in> dom (discovered s) \\<and>\n                   \\<delta> s w \\<le> \\<delta> s v \\<and>\n                   (w \\<in> dom (finished s) \\<longrightarrow>\n                    v \\<in> dom (finished s) \\<and>\n                    \\<phi> s v \\<le> \\<phi> s w) \\<longrightarrow>\n                   (v, w) \\<in> back_edges s \\<or> (v, w) \\<in> pending s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        u = hd (stack s);\n        s' =\n        back_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, w)\\<in>E.\n                            v \\<in> dom (discovered s') \\<and>\n                            w \\<in> dom (discovered s') \\<and>\n                            \\<delta> s' w \\<le> \\<delta> s' v \\<and>\n                            (w \\<in> dom (finished s') \\<longrightarrow>\n                             v \\<in> dom (finished s') \\<and>\n                             \\<phi> s' v\n                             \\<le> \\<phi> s' w) \\<longrightarrow>\n                            (v, w) \\<in> back_edges s' \\<or>\n                            (v, w) \\<in> pending s'\n 5. \\<And>s s' u v e.\n       \\<lbrakk>\\<forall>(v, w)\\<in>E.\n                   v \\<in> dom (discovered s) \\<and>\n                   w \\<in> dom (discovered s) \\<and>\n                   \\<delta> s w \\<le> \\<delta> s v \\<and>\n                   (w \\<in> dom (finished s) \\<longrightarrow>\n                    v \\<in> dom (finished s) \\<and>\n                    \\<phi> s v \\<le> \\<phi> s w) \\<longrightarrow>\n                   (v, w) \\<in> back_edges s \\<or> (v, w) \\<in> pending s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, w)\\<in>E.\n                            v \\<in> dom (discovered s') \\<and>\n                            w \\<in> dom (discovered s') \\<and>\n                            \\<delta> s' w \\<le> \\<delta> s' v \\<and>\n                            (w \\<in> dom (finished s') \\<longrightarrow>\n                             v \\<in> dom (finished s') \\<and>\n                             \\<phi> s' v\n                             \\<le> \\<phi> s' w) \\<longrightarrow>\n                            (v, w) \\<in> back_edges s' \\<or>\n                            (v, w) \\<in> pending s'", "ultimately"], ["proof (chain)\npicking this:\n  \\<lbrakk>?w9 \\<in> E `` {hd (stack s)}; ?w9 \\<noteq> hd (stack s);\n   ?w9 \\<in> dom (discovered s);\n   ?w9 \\<in> dom (finished s) \\<longrightarrow>\n   counter s \\<le> \\<phi> s ?w9;\n   \\<delta> s ?w9 \\<le> \\<delta> s (hd (stack s))\\<rbrakk>\n  \\<Longrightarrow> (hd (stack s), ?w9) \\<in> back_edges s\n  \\<lbrakk>hd (stack s) \\<in> E `` {?w9}; ?w9 \\<noteq> hd (stack s);\n   ?w9 \\<in> dom (finished s);\n   \\<delta> s (hd (stack s)) \\<le> \\<delta> s ?w9\\<rbrakk>\n  \\<Longrightarrow> (?w9, hd (stack s)) \\<in> back_edges s", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>?w9 \\<in> E `` {hd (stack s)}; ?w9 \\<noteq> hd (stack s);\n   ?w9 \\<in> dom (discovered s);\n   ?w9 \\<in> dom (finished s) \\<longrightarrow>\n   counter s \\<le> \\<phi> s ?w9;\n   \\<delta> s ?w9 \\<le> \\<delta> s (hd (stack s))\\<rbrakk>\n  \\<Longrightarrow> (hd (stack s), ?w9) \\<in> back_edges s\n  \\<lbrakk>hd (stack s) \\<in> E `` {?w9}; ?w9 \\<noteq> hd (stack s);\n   ?w9 \\<in> dom (finished s);\n   \\<delta> s (hd (stack s)) \\<le> \\<delta> s ?w9\\<rbrakk>\n  \\<Longrightarrow> (?w9, hd (stack s)) \\<in> back_edges s\n\ngoal (1 subgoal):\n 1. \\<forall>(v, w)\\<in>E.\n       v \\<in> dom (discovered s') \\<and>\n       w \\<in> dom (discovered s') \\<and>\n       \\<delta> s' w \\<le> \\<delta> s' v \\<and>\n       (w \\<in> dom (finished s') \\<longrightarrow>\n        v \\<in> dom (finished s') \\<and>\n        \\<phi> s' v \\<le> \\<phi> s' w) \\<longrightarrow>\n       (v, w) \\<in> back_edges s' \\<or> (v, w) \\<in> pending s'", "using finish"], ["proof (prove)\nusing this:\n  \\<lbrakk>?w9 \\<in> E `` {hd (stack s)}; ?w9 \\<noteq> hd (stack s);\n   ?w9 \\<in> dom (discovered s);\n   ?w9 \\<in> dom (finished s) \\<longrightarrow>\n   counter s \\<le> \\<phi> s ?w9;\n   \\<delta> s ?w9 \\<le> \\<delta> s (hd (stack s))\\<rbrakk>\n  \\<Longrightarrow> (hd (stack s), ?w9) \\<in> back_edges s\n  \\<lbrakk>hd (stack s) \\<in> E `` {?w9}; ?w9 \\<noteq> hd (stack s);\n   ?w9 \\<in> dom (finished s);\n   \\<delta> s (hd (stack s)) \\<le> \\<delta> s ?w9\\<rbrakk>\n  \\<Longrightarrow> (?w9, hd (stack s)) \\<in> back_edges s\n  \\<forall>(v, w)\\<in>E.\n     v \\<in> dom (discovered s) \\<and>\n     w \\<in> dom (discovered s) \\<and>\n     \\<delta> s w \\<le> \\<delta> s v \\<and>\n     (w \\<in> dom (finished s) \\<longrightarrow>\n      v \\<in> dom (finished s) \\<and>\n      \\<phi> s v \\<le> \\<phi> s w) \\<longrightarrow>\n     (v, w) \\<in> back_edges s \\<or> (v, w) \\<in> pending s\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s \\<noteq> []\n  pending s `` {u} = {}\n  u = hd (stack s)\n  s' = finish u s\\<lparr>state.more := v\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<forall>(v, w)\\<in>E.\n       v \\<in> dom (discovered s') \\<and>\n       w \\<in> dom (discovered s') \\<and>\n       \\<delta> s' w \\<le> \\<delta> s' v \\<and>\n       (w \\<in> dom (finished s') \\<longrightarrow>\n        v \\<in> dom (finished s') \\<and>\n        \\<phi> s' v \\<le> \\<phi> s' w) \\<longrightarrow>\n       (v, w) \\<in> back_edges s' \\<or> (v, w) \\<in> pending s'", "by clarsimp auto"], ["proof (state)\nthis:\n  \\<forall>(v, w)\\<in>E.\n     v \\<in> dom (discovered s') \\<and>\n     w \\<in> dom (discovered s') \\<and>\n     \\<delta> s' w \\<le> \\<delta> s' v \\<and>\n     (w \\<in> dom (finished s') \\<longrightarrow>\n      v \\<in> dom (finished s') \\<and>\n      \\<phi> s' v \\<le> \\<phi> s' w) \\<longrightarrow>\n     (v, w) \\<in> back_edges s' \\<or> (v, w) \\<in> pending s'\n\ngoal (4 subgoals):\n 1. \\<And>e.\n       \\<forall>(v, w)\\<in>E.\n          v \\<in> dom (discovered (empty_state e)) \\<and>\n          w \\<in> dom (discovered (empty_state e)) \\<and>\n          \\<delta> (empty_state e) w \\<le> \\<delta> (empty_state e) v \\<and>\n          (w \\<in> dom (finished (empty_state e)) \\<longrightarrow>\n           v \\<in> dom (finished (empty_state e)) \\<and>\n           \\<phi> (empty_state e) v\n           \\<le> \\<phi> (empty_state e) w) \\<longrightarrow>\n          (v, w) \\<in> back_edges (empty_state e) \\<or>\n          (v, w) \\<in> pending (empty_state e)\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>\\<forall>(v, w)\\<in>E.\n                   v \\<in> dom (discovered s) \\<and>\n                   w \\<in> dom (discovered s) \\<and>\n                   \\<delta> s w \\<le> \\<delta> s v \\<and>\n                   (w \\<in> dom (finished s) \\<longrightarrow>\n                    v \\<in> dom (finished s) \\<and>\n                    \\<phi> s v \\<le> \\<phi> s w) \\<longrightarrow>\n                   (v, w) \\<in> back_edges s \\<or> (v, w) \\<in> pending s;\n        cond s; DFS_invar G param s; DFS_invar G param s'; stack s = [];\n        v0 \\<notin> dom (discovered s); v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, w)\\<in>E.\n                            v \\<in> dom (discovered s') \\<and>\n                            w \\<in> dom (discovered s') \\<and>\n                            \\<delta> s' w \\<le> \\<delta> s' v \\<and>\n                            (w \\<in> dom (finished s') \\<longrightarrow>\n                             v \\<in> dom (finished s') \\<and>\n                             \\<phi> s' v\n                             \\<le> \\<phi> s' w) \\<longrightarrow>\n                            (v, w) \\<in> back_edges s' \\<or>\n                            (v, w) \\<in> pending s'\n 3. \\<And>s s' u v e.\n       \\<lbrakk>\\<forall>(v, w)\\<in>E.\n                   v \\<in> dom (discovered s) \\<and>\n                   w \\<in> dom (discovered s) \\<and>\n                   \\<delta> s w \\<le> \\<delta> s v \\<and>\n                   (w \\<in> dom (finished s) \\<longrightarrow>\n                    v \\<in> dom (finished s) \\<and>\n                    \\<phi> s v \\<le> \\<phi> s w) \\<longrightarrow>\n                   (v, w) \\<in> back_edges s \\<or> (v, w) \\<in> pending s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        u = hd (stack s);\n        s' =\n        back_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, w)\\<in>E.\n                            v \\<in> dom (discovered s') \\<and>\n                            w \\<in> dom (discovered s') \\<and>\n                            \\<delta> s' w \\<le> \\<delta> s' v \\<and>\n                            (w \\<in> dom (finished s') \\<longrightarrow>\n                             v \\<in> dom (finished s') \\<and>\n                             \\<phi> s' v\n                             \\<le> \\<phi> s' w) \\<longrightarrow>\n                            (v, w) \\<in> back_edges s' \\<or>\n                            (v, w) \\<in> pending s'\n 4. \\<And>s s' u v e.\n       \\<lbrakk>\\<forall>(v, w)\\<in>E.\n                   v \\<in> dom (discovered s) \\<and>\n                   w \\<in> dom (discovered s) \\<and>\n                   \\<delta> s w \\<le> \\<delta> s v \\<and>\n                   (w \\<in> dom (finished s) \\<longrightarrow>\n                    v \\<in> dom (finished s) \\<and>\n                    \\<phi> s v \\<le> \\<phi> s w) \\<longrightarrow>\n                   (v, w) \\<in> back_edges s \\<or> (v, w) \\<in> pending s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, w)\\<in>E.\n                            v \\<in> dom (discovered s') \\<and>\n                            w \\<in> dom (discovered s') \\<and>\n                            \\<delta> s' w \\<le> \\<delta> s' v \\<and>\n                            (w \\<in> dom (finished s') \\<longrightarrow>\n                             v \\<in> dom (finished s') \\<and>\n                             \\<phi> s' v\n                             \\<le> \\<phi> s' w) \\<longrightarrow>\n                            (v, w) \\<in> back_edges s' \\<or>\n                            (v, w) \\<in> pending s'", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>e.\n       \\<forall>(v, w)\\<in>E.\n          v \\<in> dom (discovered (empty_state e)) \\<and>\n          w \\<in> dom (discovered (empty_state e)) \\<and>\n          \\<delta> (empty_state e) w \\<le> \\<delta> (empty_state e) v \\<and>\n          (w \\<in> dom (finished (empty_state e)) \\<longrightarrow>\n           v \\<in> dom (finished (empty_state e)) \\<and>\n           \\<phi> (empty_state e) v\n           \\<le> \\<phi> (empty_state e) w) \\<longrightarrow>\n          (v, w) \\<in> back_edges (empty_state e) \\<or>\n          (v, w) \\<in> pending (empty_state e)\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>\\<forall>(v, w)\\<in>E.\n                   v \\<in> dom (discovered s) \\<and>\n                   w \\<in> dom (discovered s) \\<and>\n                   \\<delta> s w \\<le> \\<delta> s v \\<and>\n                   (w \\<in> dom (finished s) \\<longrightarrow>\n                    v \\<in> dom (finished s) \\<and>\n                    \\<phi> s v \\<le> \\<phi> s w) \\<longrightarrow>\n                   (v, w) \\<in> back_edges s \\<or> (v, w) \\<in> pending s;\n        cond s; DFS_invar G param s; DFS_invar G param s'; stack s = [];\n        v0 \\<notin> dom (discovered s); v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, w)\\<in>E.\n                            v \\<in> dom (discovered s') \\<and>\n                            w \\<in> dom (discovered s') \\<and>\n                            \\<delta> s' w \\<le> \\<delta> s' v \\<and>\n                            (w \\<in> dom (finished s') \\<longrightarrow>\n                             v \\<in> dom (finished s') \\<and>\n                             \\<phi> s' v\n                             \\<le> \\<phi> s' w) \\<longrightarrow>\n                            (v, w) \\<in> back_edges s' \\<or>\n                            (v, w) \\<in> pending s'\n 3. \\<And>s s' u v e.\n       \\<lbrakk>\\<forall>(v, w)\\<in>E.\n                   v \\<in> dom (discovered s) \\<and>\n                   w \\<in> dom (discovered s) \\<and>\n                   \\<delta> s w \\<le> \\<delta> s v \\<and>\n                   (w \\<in> dom (finished s) \\<longrightarrow>\n                    v \\<in> dom (finished s) \\<and>\n                    \\<phi> s v \\<le> \\<phi> s w) \\<longrightarrow>\n                   (v, w) \\<in> back_edges s \\<or> (v, w) \\<in> pending s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        u = hd (stack s);\n        s' =\n        back_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, w)\\<in>E.\n                            v \\<in> dom (discovered s') \\<and>\n                            w \\<in> dom (discovered s') \\<and>\n                            \\<delta> s' w \\<le> \\<delta> s' v \\<and>\n                            (w \\<in> dom (finished s') \\<longrightarrow>\n                             v \\<in> dom (finished s') \\<and>\n                             \\<phi> s' v\n                             \\<le> \\<phi> s' w) \\<longrightarrow>\n                            (v, w) \\<in> back_edges s' \\<or>\n                            (v, w) \\<in> pending s'\n 4. \\<And>s s' u v e.\n       \\<lbrakk>\\<forall>(v, w)\\<in>E.\n                   v \\<in> dom (discovered s) \\<and>\n                   w \\<in> dom (discovered s) \\<and>\n                   \\<delta> s w \\<le> \\<delta> s v \\<and>\n                   (w \\<in> dom (finished s) \\<longrightarrow>\n                    v \\<in> dom (finished s) \\<and>\n                    \\<phi> s v \\<le> \\<phi> s w) \\<longrightarrow>\n                   (v, w) \\<in> back_edges s \\<or> (v, w) \\<in> pending s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, w)\\<in>E.\n                            v \\<in> dom (discovered s') \\<and>\n                            w \\<in> dom (discovered s') \\<and>\n                            \\<delta> s' w \\<le> \\<delta> s' v \\<and>\n                            (w \\<in> dom (finished s') \\<longrightarrow>\n                             v \\<in> dom (finished s') \\<and>\n                             \\<phi> s' v\n                             \\<le> \\<phi> s' w) \\<longrightarrow>\n                            (v, w) \\<in> back_edges s' \\<or>\n                            (v, w) \\<in> pending s'", "case (discover s s' u v)"], ["proof (state)\nthis:\n  \\<forall>(v, w)\\<in>E.\n     v \\<in> dom (discovered s) \\<and>\n     w \\<in> dom (discovered s) \\<and>\n     \\<delta> s w \\<le> \\<delta> s v \\<and>\n     (w \\<in> dom (finished s) \\<longrightarrow>\n      v \\<in> dom (finished s) \\<and>\n      \\<phi> s v \\<le> \\<phi> s w) \\<longrightarrow>\n     (v, w) \\<in> back_edges s \\<or> (v, w) \\<in> pending s\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s \\<noteq> []\n  v \\<in> pending s `` {u}\n  v \\<notin> dom (discovered s)\n  u = hd (stack s)\n  s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n  \\<lparr>state.more := e_\\<rparr>\n\ngoal (4 subgoals):\n 1. \\<And>e.\n       \\<forall>(v, w)\\<in>E.\n          v \\<in> dom (discovered (empty_state e)) \\<and>\n          w \\<in> dom (discovered (empty_state e)) \\<and>\n          \\<delta> (empty_state e) w \\<le> \\<delta> (empty_state e) v \\<and>\n          (w \\<in> dom (finished (empty_state e)) \\<longrightarrow>\n           v \\<in> dom (finished (empty_state e)) \\<and>\n           \\<phi> (empty_state e) v\n           \\<le> \\<phi> (empty_state e) w) \\<longrightarrow>\n          (v, w) \\<in> back_edges (empty_state e) \\<or>\n          (v, w) \\<in> pending (empty_state e)\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>\\<forall>(v, w)\\<in>E.\n                   v \\<in> dom (discovered s) \\<and>\n                   w \\<in> dom (discovered s) \\<and>\n                   \\<delta> s w \\<le> \\<delta> s v \\<and>\n                   (w \\<in> dom (finished s) \\<longrightarrow>\n                    v \\<in> dom (finished s) \\<and>\n                    \\<phi> s v \\<le> \\<phi> s w) \\<longrightarrow>\n                   (v, w) \\<in> back_edges s \\<or> (v, w) \\<in> pending s;\n        cond s; DFS_invar G param s; DFS_invar G param s'; stack s = [];\n        v0 \\<notin> dom (discovered s); v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, w)\\<in>E.\n                            v \\<in> dom (discovered s') \\<and>\n                            w \\<in> dom (discovered s') \\<and>\n                            \\<delta> s' w \\<le> \\<delta> s' v \\<and>\n                            (w \\<in> dom (finished s') \\<longrightarrow>\n                             v \\<in> dom (finished s') \\<and>\n                             \\<phi> s' v\n                             \\<le> \\<phi> s' w) \\<longrightarrow>\n                            (v, w) \\<in> back_edges s' \\<or>\n                            (v, w) \\<in> pending s'\n 3. \\<And>s s' u v e.\n       \\<lbrakk>\\<forall>(v, w)\\<in>E.\n                   v \\<in> dom (discovered s) \\<and>\n                   w \\<in> dom (discovered s) \\<and>\n                   \\<delta> s w \\<le> \\<delta> s v \\<and>\n                   (w \\<in> dom (finished s) \\<longrightarrow>\n                    v \\<in> dom (finished s) \\<and>\n                    \\<phi> s v \\<le> \\<phi> s w) \\<longrightarrow>\n                   (v, w) \\<in> back_edges s \\<or> (v, w) \\<in> pending s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        u = hd (stack s);\n        s' =\n        back_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, w)\\<in>E.\n                            v \\<in> dom (discovered s') \\<and>\n                            w \\<in> dom (discovered s') \\<and>\n                            \\<delta> s' w \\<le> \\<delta> s' v \\<and>\n                            (w \\<in> dom (finished s') \\<longrightarrow>\n                             v \\<in> dom (finished s') \\<and>\n                             \\<phi> s' v\n                             \\<le> \\<phi> s' w) \\<longrightarrow>\n                            (v, w) \\<in> back_edges s' \\<or>\n                            (v, w) \\<in> pending s'\n 4. \\<And>s s' u v e.\n       \\<lbrakk>\\<forall>(v, w)\\<in>E.\n                   v \\<in> dom (discovered s) \\<and>\n                   w \\<in> dom (discovered s) \\<and>\n                   \\<delta> s w \\<le> \\<delta> s v \\<and>\n                   (w \\<in> dom (finished s) \\<longrightarrow>\n                    v \\<in> dom (finished s) \\<and>\n                    \\<phi> s v \\<le> \\<phi> s w) \\<longrightarrow>\n                   (v, w) \\<in> back_edges s \\<or> (v, w) \\<in> pending s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, w)\\<in>E.\n                            v \\<in> dom (discovered s') \\<and>\n                            w \\<in> dom (discovered s') \\<and>\n                            \\<delta> s' w \\<le> \\<delta> s' v \\<and>\n                            (w \\<in> dom (finished s') \\<longrightarrow>\n                             v \\<in> dom (finished s') \\<and>\n                             \\<phi> s' v\n                             \\<le> \\<phi> s' w) \\<longrightarrow>\n                            (v, w) \\<in> back_edges s' \\<or>\n                            (v, w) \\<in> pending s'", "then"], ["proof (chain)\npicking this:\n  \\<forall>(v, w)\\<in>E.\n     v \\<in> dom (discovered s) \\<and>\n     w \\<in> dom (discovered s) \\<and>\n     \\<delta> s w \\<le> \\<delta> s v \\<and>\n     (w \\<in> dom (finished s) \\<longrightarrow>\n      v \\<in> dom (finished s) \\<and>\n      \\<phi> s v \\<le> \\<phi> s w) \\<longrightarrow>\n     (v, w) \\<in> back_edges s \\<or> (v, w) \\<in> pending s\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s \\<noteq> []\n  v \\<in> pending s `` {u}\n  v \\<notin> dom (discovered s)\n  u = hd (stack s)\n  s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n  \\<lparr>state.more := e_\\<rparr>", "interpret DFS_invar where s=s"], ["proof (prove)\nusing this:\n  \\<forall>(v, w)\\<in>E.\n     v \\<in> dom (discovered s) \\<and>\n     w \\<in> dom (discovered s) \\<and>\n     \\<delta> s w \\<le> \\<delta> s v \\<and>\n     (w \\<in> dom (finished s) \\<longrightarrow>\n      v \\<in> dom (finished s) \\<and>\n      \\<phi> s v \\<le> \\<phi> s w) \\<longrightarrow>\n     (v, w) \\<in> back_edges s \\<or> (v, w) \\<in> pending s\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s \\<noteq> []\n  v \\<in> pending s `` {u}\n  v \\<notin> dom (discovered s)\n  u = hd (stack s)\n  s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n  \\<lparr>state.more := e_\\<rparr>\n\ngoal (1 subgoal):\n 1. DFS_invar G param s", "by simp"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>e.\n       \\<forall>(v, w)\\<in>E.\n          v \\<in> dom (discovered (empty_state e)) \\<and>\n          w \\<in> dom (discovered (empty_state e)) \\<and>\n          \\<delta> (empty_state e) w \\<le> \\<delta> (empty_state e) v \\<and>\n          (w \\<in> dom (finished (empty_state e)) \\<longrightarrow>\n           v \\<in> dom (finished (empty_state e)) \\<and>\n           \\<phi> (empty_state e) v\n           \\<le> \\<phi> (empty_state e) w) \\<longrightarrow>\n          (v, w) \\<in> back_edges (empty_state e) \\<or>\n          (v, w) \\<in> pending (empty_state e)\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>\\<forall>(v, w)\\<in>E.\n                   v \\<in> dom (discovered s) \\<and>\n                   w \\<in> dom (discovered s) \\<and>\n                   \\<delta> s w \\<le> \\<delta> s v \\<and>\n                   (w \\<in> dom (finished s) \\<longrightarrow>\n                    v \\<in> dom (finished s) \\<and>\n                    \\<phi> s v \\<le> \\<phi> s w) \\<longrightarrow>\n                   (v, w) \\<in> back_edges s \\<or> (v, w) \\<in> pending s;\n        cond s; DFS_invar G param s; DFS_invar G param s'; stack s = [];\n        v0 \\<notin> dom (discovered s); v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, w)\\<in>E.\n                            v \\<in> dom (discovered s') \\<and>\n                            w \\<in> dom (discovered s') \\<and>\n                            \\<delta> s' w \\<le> \\<delta> s' v \\<and>\n                            (w \\<in> dom (finished s') \\<longrightarrow>\n                             v \\<in> dom (finished s') \\<and>\n                             \\<phi> s' v\n                             \\<le> \\<phi> s' w) \\<longrightarrow>\n                            (v, w) \\<in> back_edges s' \\<or>\n                            (v, w) \\<in> pending s'\n 3. \\<And>s s' u v e.\n       \\<lbrakk>\\<forall>(v, w)\\<in>E.\n                   v \\<in> dom (discovered s) \\<and>\n                   w \\<in> dom (discovered s) \\<and>\n                   \\<delta> s w \\<le> \\<delta> s v \\<and>\n                   (w \\<in> dom (finished s) \\<longrightarrow>\n                    v \\<in> dom (finished s) \\<and>\n                    \\<phi> s v \\<le> \\<phi> s w) \\<longrightarrow>\n                   (v, w) \\<in> back_edges s \\<or> (v, w) \\<in> pending s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        u = hd (stack s);\n        s' =\n        back_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, w)\\<in>E.\n                            v \\<in> dom (discovered s') \\<and>\n                            w \\<in> dom (discovered s') \\<and>\n                            \\<delta> s' w \\<le> \\<delta> s' v \\<and>\n                            (w \\<in> dom (finished s') \\<longrightarrow>\n                             v \\<in> dom (finished s') \\<and>\n                             \\<phi> s' v\n                             \\<le> \\<phi> s' w) \\<longrightarrow>\n                            (v, w) \\<in> back_edges s' \\<or>\n                            (v, w) \\<in> pending s'\n 4. \\<And>s s' u v e.\n       \\<lbrakk>\\<forall>(v, w)\\<in>E.\n                   v \\<in> dom (discovered s) \\<and>\n                   w \\<in> dom (discovered s) \\<and>\n                   \\<delta> s w \\<le> \\<delta> s v \\<and>\n                   (w \\<in> dom (finished s) \\<longrightarrow>\n                    v \\<in> dom (finished s) \\<and>\n                    \\<phi> s v \\<le> \\<phi> s w) \\<longrightarrow>\n                   (v, w) \\<in> back_edges s \\<or> (v, w) \\<in> pending s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, w)\\<in>E.\n                            v \\<in> dom (discovered s') \\<and>\n                            w \\<in> dom (discovered s') \\<and>\n                            \\<delta> s' w \\<le> \\<delta> s' v \\<and>\n                            (w \\<in> dom (finished s') \\<longrightarrow>\n                             v \\<in> dom (finished s') \\<and>\n                             \\<phi> s' v\n                             \\<le> \\<phi> s' w) \\<longrightarrow>\n                            (v, w) \\<in> back_edges s' \\<or>\n                            (v, w) \\<in> pending s'", "from discover"], ["proof (chain)\npicking this:\n  \\<forall>(v, w)\\<in>E.\n     v \\<in> dom (discovered s) \\<and>\n     w \\<in> dom (discovered s) \\<and>\n     \\<delta> s w \\<le> \\<delta> s v \\<and>\n     (w \\<in> dom (finished s) \\<longrightarrow>\n      v \\<in> dom (finished s) \\<and>\n      \\<phi> s v \\<le> \\<phi> s w) \\<longrightarrow>\n     (v, w) \\<in> back_edges s \\<or> (v, w) \\<in> pending s\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s \\<noteq> []\n  v \\<in> pending s `` {u}\n  v \\<notin> dom (discovered s)\n  u = hd (stack s)\n  s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n  \\<lparr>state.more := e_\\<rparr>", "show ?case"], ["proof (prove)\nusing this:\n  \\<forall>(v, w)\\<in>E.\n     v \\<in> dom (discovered s) \\<and>\n     w \\<in> dom (discovered s) \\<and>\n     \\<delta> s w \\<le> \\<delta> s v \\<and>\n     (w \\<in> dom (finished s) \\<longrightarrow>\n      v \\<in> dom (finished s) \\<and>\n      \\<phi> s v \\<le> \\<phi> s w) \\<longrightarrow>\n     (v, w) \\<in> back_edges s \\<or> (v, w) \\<in> pending s\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s \\<noteq> []\n  v \\<in> pending s `` {u}\n  v \\<notin> dom (discovered s)\n  u = hd (stack s)\n  s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n  \\<lparr>state.more := e_\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<forall>(v, w)\\<in>E.\n       v \\<in> dom (discovered s') \\<and>\n       w \\<in> dom (discovered s') \\<and>\n       \\<delta> s' w \\<le> \\<delta> s' v \\<and>\n       (w \\<in> dom (finished s') \\<longrightarrow>\n        v \\<in> dom (finished s') \\<and>\n        \\<phi> s' v \\<le> \\<phi> s' w) \\<longrightarrow>\n       (v, w) \\<in> back_edges s' \\<or> (v, w) \\<in> pending s'", "using timing_less_counter"], ["proof (prove)\nusing this:\n  \\<forall>(v, w)\\<in>E.\n     v \\<in> dom (discovered s) \\<and>\n     w \\<in> dom (discovered s) \\<and>\n     \\<delta> s w \\<le> \\<delta> s v \\<and>\n     (w \\<in> dom (finished s) \\<longrightarrow>\n      v \\<in> dom (finished s) \\<and>\n      \\<phi> s v \\<le> \\<phi> s w) \\<longrightarrow>\n     (v, w) \\<in> back_edges s \\<or> (v, w) \\<in> pending s\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s \\<noteq> []\n  v \\<in> pending s `` {u}\n  v \\<notin> dom (discovered s)\n  u = hd (stack s)\n  s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n  \\<lparr>state.more := e_\\<rparr>\n  ?v \\<in> dom (discovered s) \\<Longrightarrow> \\<delta> s ?v < counter s\n  ?v \\<in> dom (finished s) \\<Longrightarrow> \\<phi> s ?v < counter s\n\ngoal (1 subgoal):\n 1. \\<forall>(v, w)\\<in>E.\n       v \\<in> dom (discovered s') \\<and>\n       w \\<in> dom (discovered s') \\<and>\n       \\<delta> s' w \\<le> \\<delta> s' v \\<and>\n       (w \\<in> dom (finished s') \\<longrightarrow>\n        v \\<in> dom (finished s') \\<and>\n        \\<phi> s' v \\<le> \\<phi> s' w) \\<longrightarrow>\n       (v, w) \\<in> back_edges s' \\<or> (v, w) \\<in> pending s'", "by clarsimp fastforce"], ["proof (state)\nthis:\n  \\<forall>(v, w)\\<in>E.\n     v \\<in> dom (discovered s') \\<and>\n     w \\<in> dom (discovered s') \\<and>\n     \\<delta> s' w \\<le> \\<delta> s' v \\<and>\n     (w \\<in> dom (finished s') \\<longrightarrow>\n      v \\<in> dom (finished s') \\<and>\n      \\<phi> s' v \\<le> \\<phi> s' w) \\<longrightarrow>\n     (v, w) \\<in> back_edges s' \\<or> (v, w) \\<in> pending s'\n\ngoal (3 subgoals):\n 1. \\<And>e.\n       \\<forall>(v, w)\\<in>E.\n          v \\<in> dom (discovered (empty_state e)) \\<and>\n          w \\<in> dom (discovered (empty_state e)) \\<and>\n          \\<delta> (empty_state e) w \\<le> \\<delta> (empty_state e) v \\<and>\n          (w \\<in> dom (finished (empty_state e)) \\<longrightarrow>\n           v \\<in> dom (finished (empty_state e)) \\<and>\n           \\<phi> (empty_state e) v\n           \\<le> \\<phi> (empty_state e) w) \\<longrightarrow>\n          (v, w) \\<in> back_edges (empty_state e) \\<or>\n          (v, w) \\<in> pending (empty_state e)\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>\\<forall>(v, w)\\<in>E.\n                   v \\<in> dom (discovered s) \\<and>\n                   w \\<in> dom (discovered s) \\<and>\n                   \\<delta> s w \\<le> \\<delta> s v \\<and>\n                   (w \\<in> dom (finished s) \\<longrightarrow>\n                    v \\<in> dom (finished s) \\<and>\n                    \\<phi> s v \\<le> \\<phi> s w) \\<longrightarrow>\n                   (v, w) \\<in> back_edges s \\<or> (v, w) \\<in> pending s;\n        cond s; DFS_invar G param s; DFS_invar G param s'; stack s = [];\n        v0 \\<notin> dom (discovered s); v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, w)\\<in>E.\n                            v \\<in> dom (discovered s') \\<and>\n                            w \\<in> dom (discovered s') \\<and>\n                            \\<delta> s' w \\<le> \\<delta> s' v \\<and>\n                            (w \\<in> dom (finished s') \\<longrightarrow>\n                             v \\<in> dom (finished s') \\<and>\n                             \\<phi> s' v\n                             \\<le> \\<phi> s' w) \\<longrightarrow>\n                            (v, w) \\<in> back_edges s' \\<or>\n                            (v, w) \\<in> pending s'\n 3. \\<And>s s' u v e.\n       \\<lbrakk>\\<forall>(v, w)\\<in>E.\n                   v \\<in> dom (discovered s) \\<and>\n                   w \\<in> dom (discovered s) \\<and>\n                   \\<delta> s w \\<le> \\<delta> s v \\<and>\n                   (w \\<in> dom (finished s) \\<longrightarrow>\n                    v \\<in> dom (finished s) \\<and>\n                    \\<phi> s v \\<le> \\<phi> s w) \\<longrightarrow>\n                   (v, w) \\<in> back_edges s \\<or> (v, w) \\<in> pending s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        u = hd (stack s);\n        s' =\n        back_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, w)\\<in>E.\n                            v \\<in> dom (discovered s') \\<and>\n                            w \\<in> dom (discovered s') \\<and>\n                            \\<delta> s' w \\<le> \\<delta> s' v \\<and>\n                            (w \\<in> dom (finished s') \\<longrightarrow>\n                             v \\<in> dom (finished s') \\<and>\n                             \\<phi> s' v\n                             \\<le> \\<phi> s' w) \\<longrightarrow>\n                            (v, w) \\<in> back_edges s' \\<or>\n                            (v, w) \\<in> pending s'", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>e.\n       \\<forall>(v, w)\\<in>E.\n          v \\<in> dom (discovered (empty_state e)) \\<and>\n          w \\<in> dom (discovered (empty_state e)) \\<and>\n          \\<delta> (empty_state e) w \\<le> \\<delta> (empty_state e) v \\<and>\n          (w \\<in> dom (finished (empty_state e)) \\<longrightarrow>\n           v \\<in> dom (finished (empty_state e)) \\<and>\n           \\<phi> (empty_state e) v\n           \\<le> \\<phi> (empty_state e) w) \\<longrightarrow>\n          (v, w) \\<in> back_edges (empty_state e) \\<or>\n          (v, w) \\<in> pending (empty_state e)\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>\\<forall>(v, w)\\<in>E.\n                   v \\<in> dom (discovered s) \\<and>\n                   w \\<in> dom (discovered s) \\<and>\n                   \\<delta> s w \\<le> \\<delta> s v \\<and>\n                   (w \\<in> dom (finished s) \\<longrightarrow>\n                    v \\<in> dom (finished s) \\<and>\n                    \\<phi> s v \\<le> \\<phi> s w) \\<longrightarrow>\n                   (v, w) \\<in> back_edges s \\<or> (v, w) \\<in> pending s;\n        cond s; DFS_invar G param s; DFS_invar G param s'; stack s = [];\n        v0 \\<notin> dom (discovered s); v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, w)\\<in>E.\n                            v \\<in> dom (discovered s') \\<and>\n                            w \\<in> dom (discovered s') \\<and>\n                            \\<delta> s' w \\<le> \\<delta> s' v \\<and>\n                            (w \\<in> dom (finished s') \\<longrightarrow>\n                             v \\<in> dom (finished s') \\<and>\n                             \\<phi> s' v\n                             \\<le> \\<phi> s' w) \\<longrightarrow>\n                            (v, w) \\<in> back_edges s' \\<or>\n                            (v, w) \\<in> pending s'\n 3. \\<And>s s' u v e.\n       \\<lbrakk>\\<forall>(v, w)\\<in>E.\n                   v \\<in> dom (discovered s) \\<and>\n                   w \\<in> dom (discovered s) \\<and>\n                   \\<delta> s w \\<le> \\<delta> s v \\<and>\n                   (w \\<in> dom (finished s) \\<longrightarrow>\n                    v \\<in> dom (finished s) \\<and>\n                    \\<phi> s v \\<le> \\<phi> s w) \\<longrightarrow>\n                   (v, w) \\<in> back_edges s \\<or> (v, w) \\<in> pending s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        u = hd (stack s);\n        s' =\n        back_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, w)\\<in>E.\n                            v \\<in> dom (discovered s') \\<and>\n                            w \\<in> dom (discovered s') \\<and>\n                            \\<delta> s' w \\<le> \\<delta> s' v \\<and>\n                            (w \\<in> dom (finished s') \\<longrightarrow>\n                             v \\<in> dom (finished s') \\<and>\n                             \\<phi> s' v\n                             \\<le> \\<phi> s' w) \\<longrightarrow>\n                            (v, w) \\<in> back_edges s' \\<or>\n                            (v, w) \\<in> pending s'", "case (new_root s s' v0)"], ["proof (state)\nthis:\n  \\<forall>(v, w)\\<in>E.\n     v \\<in> dom (discovered s) \\<and>\n     w \\<in> dom (discovered s) \\<and>\n     \\<delta> s w \\<le> \\<delta> s v \\<and>\n     (w \\<in> dom (finished s) \\<longrightarrow>\n      v \\<in> dom (finished s) \\<and>\n      \\<phi> s v \\<le> \\<phi> s w) \\<longrightarrow>\n     (v, w) \\<in> back_edges s \\<or> (v, w) \\<in> pending s\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s = []\n  v0 \\<notin> dom (discovered s)\n  v0 \\<in> V0\n  s' = new_root v0 s\\<lparr>state.more := e_\\<rparr>\n\ngoal (3 subgoals):\n 1. \\<And>e.\n       \\<forall>(v, w)\\<in>E.\n          v \\<in> dom (discovered (empty_state e)) \\<and>\n          w \\<in> dom (discovered (empty_state e)) \\<and>\n          \\<delta> (empty_state e) w \\<le> \\<delta> (empty_state e) v \\<and>\n          (w \\<in> dom (finished (empty_state e)) \\<longrightarrow>\n           v \\<in> dom (finished (empty_state e)) \\<and>\n           \\<phi> (empty_state e) v\n           \\<le> \\<phi> (empty_state e) w) \\<longrightarrow>\n          (v, w) \\<in> back_edges (empty_state e) \\<or>\n          (v, w) \\<in> pending (empty_state e)\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>\\<forall>(v, w)\\<in>E.\n                   v \\<in> dom (discovered s) \\<and>\n                   w \\<in> dom (discovered s) \\<and>\n                   \\<delta> s w \\<le> \\<delta> s v \\<and>\n                   (w \\<in> dom (finished s) \\<longrightarrow>\n                    v \\<in> dom (finished s) \\<and>\n                    \\<phi> s v \\<le> \\<phi> s w) \\<longrightarrow>\n                   (v, w) \\<in> back_edges s \\<or> (v, w) \\<in> pending s;\n        cond s; DFS_invar G param s; DFS_invar G param s'; stack s = [];\n        v0 \\<notin> dom (discovered s); v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, w)\\<in>E.\n                            v \\<in> dom (discovered s') \\<and>\n                            w \\<in> dom (discovered s') \\<and>\n                            \\<delta> s' w \\<le> \\<delta> s' v \\<and>\n                            (w \\<in> dom (finished s') \\<longrightarrow>\n                             v \\<in> dom (finished s') \\<and>\n                             \\<phi> s' v\n                             \\<le> \\<phi> s' w) \\<longrightarrow>\n                            (v, w) \\<in> back_edges s' \\<or>\n                            (v, w) \\<in> pending s'\n 3. \\<And>s s' u v e.\n       \\<lbrakk>\\<forall>(v, w)\\<in>E.\n                   v \\<in> dom (discovered s) \\<and>\n                   w \\<in> dom (discovered s) \\<and>\n                   \\<delta> s w \\<le> \\<delta> s v \\<and>\n                   (w \\<in> dom (finished s) \\<longrightarrow>\n                    v \\<in> dom (finished s) \\<and>\n                    \\<phi> s v \\<le> \\<phi> s w) \\<longrightarrow>\n                   (v, w) \\<in> back_edges s \\<or> (v, w) \\<in> pending s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        u = hd (stack s);\n        s' =\n        back_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, w)\\<in>E.\n                            v \\<in> dom (discovered s') \\<and>\n                            w \\<in> dom (discovered s') \\<and>\n                            \\<delta> s' w \\<le> \\<delta> s' v \\<and>\n                            (w \\<in> dom (finished s') \\<longrightarrow>\n                             v \\<in> dom (finished s') \\<and>\n                             \\<phi> s' v\n                             \\<le> \\<phi> s' w) \\<longrightarrow>\n                            (v, w) \\<in> back_edges s' \\<or>\n                            (v, w) \\<in> pending s'", "then"], ["proof (chain)\npicking this:\n  \\<forall>(v, w)\\<in>E.\n     v \\<in> dom (discovered s) \\<and>\n     w \\<in> dom (discovered s) \\<and>\n     \\<delta> s w \\<le> \\<delta> s v \\<and>\n     (w \\<in> dom (finished s) \\<longrightarrow>\n      v \\<in> dom (finished s) \\<and>\n      \\<phi> s v \\<le> \\<phi> s w) \\<longrightarrow>\n     (v, w) \\<in> back_edges s \\<or> (v, w) \\<in> pending s\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s = []\n  v0 \\<notin> dom (discovered s)\n  v0 \\<in> V0\n  s' = new_root v0 s\\<lparr>state.more := e_\\<rparr>", "interpret DFS_invar where s=s"], ["proof (prove)\nusing this:\n  \\<forall>(v, w)\\<in>E.\n     v \\<in> dom (discovered s) \\<and>\n     w \\<in> dom (discovered s) \\<and>\n     \\<delta> s w \\<le> \\<delta> s v \\<and>\n     (w \\<in> dom (finished s) \\<longrightarrow>\n      v \\<in> dom (finished s) \\<and>\n      \\<phi> s v \\<le> \\<phi> s w) \\<longrightarrow>\n     (v, w) \\<in> back_edges s \\<or> (v, w) \\<in> pending s\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s = []\n  v0 \\<notin> dom (discovered s)\n  v0 \\<in> V0\n  s' = new_root v0 s\\<lparr>state.more := e_\\<rparr>\n\ngoal (1 subgoal):\n 1. DFS_invar G param s", "by simp"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>e.\n       \\<forall>(v, w)\\<in>E.\n          v \\<in> dom (discovered (empty_state e)) \\<and>\n          w \\<in> dom (discovered (empty_state e)) \\<and>\n          \\<delta> (empty_state e) w \\<le> \\<delta> (empty_state e) v \\<and>\n          (w \\<in> dom (finished (empty_state e)) \\<longrightarrow>\n           v \\<in> dom (finished (empty_state e)) \\<and>\n           \\<phi> (empty_state e) v\n           \\<le> \\<phi> (empty_state e) w) \\<longrightarrow>\n          (v, w) \\<in> back_edges (empty_state e) \\<or>\n          (v, w) \\<in> pending (empty_state e)\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>\\<forall>(v, w)\\<in>E.\n                   v \\<in> dom (discovered s) \\<and>\n                   w \\<in> dom (discovered s) \\<and>\n                   \\<delta> s w \\<le> \\<delta> s v \\<and>\n                   (w \\<in> dom (finished s) \\<longrightarrow>\n                    v \\<in> dom (finished s) \\<and>\n                    \\<phi> s v \\<le> \\<phi> s w) \\<longrightarrow>\n                   (v, w) \\<in> back_edges s \\<or> (v, w) \\<in> pending s;\n        cond s; DFS_invar G param s; DFS_invar G param s'; stack s = [];\n        v0 \\<notin> dom (discovered s); v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, w)\\<in>E.\n                            v \\<in> dom (discovered s') \\<and>\n                            w \\<in> dom (discovered s') \\<and>\n                            \\<delta> s' w \\<le> \\<delta> s' v \\<and>\n                            (w \\<in> dom (finished s') \\<longrightarrow>\n                             v \\<in> dom (finished s') \\<and>\n                             \\<phi> s' v\n                             \\<le> \\<phi> s' w) \\<longrightarrow>\n                            (v, w) \\<in> back_edges s' \\<or>\n                            (v, w) \\<in> pending s'\n 3. \\<And>s s' u v e.\n       \\<lbrakk>\\<forall>(v, w)\\<in>E.\n                   v \\<in> dom (discovered s) \\<and>\n                   w \\<in> dom (discovered s) \\<and>\n                   \\<delta> s w \\<le> \\<delta> s v \\<and>\n                   (w \\<in> dom (finished s) \\<longrightarrow>\n                    v \\<in> dom (finished s) \\<and>\n                    \\<phi> s v \\<le> \\<phi> s w) \\<longrightarrow>\n                   (v, w) \\<in> back_edges s \\<or> (v, w) \\<in> pending s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        u = hd (stack s);\n        s' =\n        back_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, w)\\<in>E.\n                            v \\<in> dom (discovered s') \\<and>\n                            w \\<in> dom (discovered s') \\<and>\n                            \\<delta> s' w \\<le> \\<delta> s' v \\<and>\n                            (w \\<in> dom (finished s') \\<longrightarrow>\n                             v \\<in> dom (finished s') \\<and>\n                             \\<phi> s' v\n                             \\<le> \\<phi> s' w) \\<longrightarrow>\n                            (v, w) \\<in> back_edges s' \\<or>\n                            (v, w) \\<in> pending s'", "from new_root empty_stack_imp_empty_pending"], ["proof (chain)\npicking this:\n  \\<forall>(v, w)\\<in>E.\n     v \\<in> dom (discovered s) \\<and>\n     w \\<in> dom (discovered s) \\<and>\n     \\<delta> s w \\<le> \\<delta> s v \\<and>\n     (w \\<in> dom (finished s) \\<longrightarrow>\n      v \\<in> dom (finished s) \\<and>\n      \\<phi> s v \\<le> \\<phi> s w) \\<longrightarrow>\n     (v, w) \\<in> back_edges s \\<or> (v, w) \\<in> pending s\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s = []\n  v0 \\<notin> dom (discovered s)\n  v0 \\<in> V0\n  s' = new_root v0 s\\<lparr>state.more := e_\\<rparr>\n  stack s = [] \\<Longrightarrow> pending s = {}", "have \"pending s = {}\""], ["proof (prove)\nusing this:\n  \\<forall>(v, w)\\<in>E.\n     v \\<in> dom (discovered s) \\<and>\n     w \\<in> dom (discovered s) \\<and>\n     \\<delta> s w \\<le> \\<delta> s v \\<and>\n     (w \\<in> dom (finished s) \\<longrightarrow>\n      v \\<in> dom (finished s) \\<and>\n      \\<phi> s v \\<le> \\<phi> s w) \\<longrightarrow>\n     (v, w) \\<in> back_edges s \\<or> (v, w) \\<in> pending s\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s = []\n  v0 \\<notin> dom (discovered s)\n  v0 \\<in> V0\n  s' = new_root v0 s\\<lparr>state.more := e_\\<rparr>\n  stack s = [] \\<Longrightarrow> pending s = {}\n\ngoal (1 subgoal):\n 1. pending s = {}", "by simp"], ["proof (state)\nthis:\n  pending s = {}\n\ngoal (3 subgoals):\n 1. \\<And>e.\n       \\<forall>(v, w)\\<in>E.\n          v \\<in> dom (discovered (empty_state e)) \\<and>\n          w \\<in> dom (discovered (empty_state e)) \\<and>\n          \\<delta> (empty_state e) w \\<le> \\<delta> (empty_state e) v \\<and>\n          (w \\<in> dom (finished (empty_state e)) \\<longrightarrow>\n           v \\<in> dom (finished (empty_state e)) \\<and>\n           \\<phi> (empty_state e) v\n           \\<le> \\<phi> (empty_state e) w) \\<longrightarrow>\n          (v, w) \\<in> back_edges (empty_state e) \\<or>\n          (v, w) \\<in> pending (empty_state e)\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>\\<forall>(v, w)\\<in>E.\n                   v \\<in> dom (discovered s) \\<and>\n                   w \\<in> dom (discovered s) \\<and>\n                   \\<delta> s w \\<le> \\<delta> s v \\<and>\n                   (w \\<in> dom (finished s) \\<longrightarrow>\n                    v \\<in> dom (finished s) \\<and>\n                    \\<phi> s v \\<le> \\<phi> s w) \\<longrightarrow>\n                   (v, w) \\<in> back_edges s \\<or> (v, w) \\<in> pending s;\n        cond s; DFS_invar G param s; DFS_invar G param s'; stack s = [];\n        v0 \\<notin> dom (discovered s); v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, w)\\<in>E.\n                            v \\<in> dom (discovered s') \\<and>\n                            w \\<in> dom (discovered s') \\<and>\n                            \\<delta> s' w \\<le> \\<delta> s' v \\<and>\n                            (w \\<in> dom (finished s') \\<longrightarrow>\n                             v \\<in> dom (finished s') \\<and>\n                             \\<phi> s' v\n                             \\<le> \\<phi> s' w) \\<longrightarrow>\n                            (v, w) \\<in> back_edges s' \\<or>\n                            (v, w) \\<in> pending s'\n 3. \\<And>s s' u v e.\n       \\<lbrakk>\\<forall>(v, w)\\<in>E.\n                   v \\<in> dom (discovered s) \\<and>\n                   w \\<in> dom (discovered s) \\<and>\n                   \\<delta> s w \\<le> \\<delta> s v \\<and>\n                   (w \\<in> dom (finished s) \\<longrightarrow>\n                    v \\<in> dom (finished s) \\<and>\n                    \\<phi> s v \\<le> \\<phi> s w) \\<longrightarrow>\n                   (v, w) \\<in> back_edges s \\<or> (v, w) \\<in> pending s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        u = hd (stack s);\n        s' =\n        back_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, w)\\<in>E.\n                            v \\<in> dom (discovered s') \\<and>\n                            w \\<in> dom (discovered s') \\<and>\n                            \\<delta> s' w \\<le> \\<delta> s' v \\<and>\n                            (w \\<in> dom (finished s') \\<longrightarrow>\n                             v \\<in> dom (finished s') \\<and>\n                             \\<phi> s' v\n                             \\<le> \\<phi> s' w) \\<longrightarrow>\n                            (v, w) \\<in> back_edges s' \\<or>\n                            (v, w) \\<in> pending s'", "with new_root"], ["proof (chain)\npicking this:\n  \\<forall>(v, w)\\<in>E.\n     v \\<in> dom (discovered s) \\<and>\n     w \\<in> dom (discovered s) \\<and>\n     \\<delta> s w \\<le> \\<delta> s v \\<and>\n     (w \\<in> dom (finished s) \\<longrightarrow>\n      v \\<in> dom (finished s) \\<and>\n      \\<phi> s v \\<le> \\<phi> s w) \\<longrightarrow>\n     (v, w) \\<in> back_edges s \\<or> (v, w) \\<in> pending s\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s = []\n  v0 \\<notin> dom (discovered s)\n  v0 \\<in> V0\n  s' = new_root v0 s\\<lparr>state.more := e_\\<rparr>\n  pending s = {}", "show ?case"], ["proof (prove)\nusing this:\n  \\<forall>(v, w)\\<in>E.\n     v \\<in> dom (discovered s) \\<and>\n     w \\<in> dom (discovered s) \\<and>\n     \\<delta> s w \\<le> \\<delta> s v \\<and>\n     (w \\<in> dom (finished s) \\<longrightarrow>\n      v \\<in> dom (finished s) \\<and>\n      \\<phi> s v \\<le> \\<phi> s w) \\<longrightarrow>\n     (v, w) \\<in> back_edges s \\<or> (v, w) \\<in> pending s\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s = []\n  v0 \\<notin> dom (discovered s)\n  v0 \\<in> V0\n  s' = new_root v0 s\\<lparr>state.more := e_\\<rparr>\n  pending s = {}\n\ngoal (1 subgoal):\n 1. \\<forall>(v, w)\\<in>E.\n       v \\<in> dom (discovered s') \\<and>\n       w \\<in> dom (discovered s') \\<and>\n       \\<delta> s' w \\<le> \\<delta> s' v \\<and>\n       (w \\<in> dom (finished s') \\<longrightarrow>\n        v \\<in> dom (finished s') \\<and>\n        \\<phi> s' v \\<le> \\<phi> s' w) \\<longrightarrow>\n       (v, w) \\<in> back_edges s' \\<or> (v, w) \\<in> pending s'", "using timing_less_counter"], ["proof (prove)\nusing this:\n  \\<forall>(v, w)\\<in>E.\n     v \\<in> dom (discovered s) \\<and>\n     w \\<in> dom (discovered s) \\<and>\n     \\<delta> s w \\<le> \\<delta> s v \\<and>\n     (w \\<in> dom (finished s) \\<longrightarrow>\n      v \\<in> dom (finished s) \\<and>\n      \\<phi> s v \\<le> \\<phi> s w) \\<longrightarrow>\n     (v, w) \\<in> back_edges s \\<or> (v, w) \\<in> pending s\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s = []\n  v0 \\<notin> dom (discovered s)\n  v0 \\<in> V0\n  s' = new_root v0 s\\<lparr>state.more := e_\\<rparr>\n  pending s = {}\n  ?v \\<in> dom (discovered s) \\<Longrightarrow> \\<delta> s ?v < counter s\n  ?v \\<in> dom (finished s) \\<Longrightarrow> \\<phi> s ?v < counter s\n\ngoal (1 subgoal):\n 1. \\<forall>(v, w)\\<in>E.\n       v \\<in> dom (discovered s') \\<and>\n       w \\<in> dom (discovered s') \\<and>\n       \\<delta> s' w \\<le> \\<delta> s' v \\<and>\n       (w \\<in> dom (finished s') \\<longrightarrow>\n        v \\<in> dom (finished s') \\<and>\n        \\<phi> s' v \\<le> \\<phi> s' w) \\<longrightarrow>\n       (v, w) \\<in> back_edges s' \\<or> (v, w) \\<in> pending s'", "by clarsimp fastforce"], ["proof (state)\nthis:\n  \\<forall>(v, w)\\<in>E.\n     v \\<in> dom (discovered s') \\<and>\n     w \\<in> dom (discovered s') \\<and>\n     \\<delta> s' w \\<le> \\<delta> s' v \\<and>\n     (w \\<in> dom (finished s') \\<longrightarrow>\n      v \\<in> dom (finished s') \\<and>\n      \\<phi> s' v \\<le> \\<phi> s' w) \\<longrightarrow>\n     (v, w) \\<in> back_edges s' \\<or> (v, w) \\<in> pending s'\n\ngoal (2 subgoals):\n 1. \\<And>e.\n       \\<forall>(v, w)\\<in>E.\n          v \\<in> dom (discovered (empty_state e)) \\<and>\n          w \\<in> dom (discovered (empty_state e)) \\<and>\n          \\<delta> (empty_state e) w \\<le> \\<delta> (empty_state e) v \\<and>\n          (w \\<in> dom (finished (empty_state e)) \\<longrightarrow>\n           v \\<in> dom (finished (empty_state e)) \\<and>\n           \\<phi> (empty_state e) v\n           \\<le> \\<phi> (empty_state e) w) \\<longrightarrow>\n          (v, w) \\<in> back_edges (empty_state e) \\<or>\n          (v, w) \\<in> pending (empty_state e)\n 2. \\<And>s s' u v e.\n       \\<lbrakk>\\<forall>(v, w)\\<in>E.\n                   v \\<in> dom (discovered s) \\<and>\n                   w \\<in> dom (discovered s) \\<and>\n                   \\<delta> s w \\<le> \\<delta> s v \\<and>\n                   (w \\<in> dom (finished s) \\<longrightarrow>\n                    v \\<in> dom (finished s) \\<and>\n                    \\<phi> s v \\<le> \\<phi> s w) \\<longrightarrow>\n                   (v, w) \\<in> back_edges s \\<or> (v, w) \\<in> pending s;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        u = hd (stack s);\n        s' =\n        back_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(v, w)\\<in>E.\n                            v \\<in> dom (discovered s') \\<and>\n                            w \\<in> dom (discovered s') \\<and>\n                            \\<delta> s' w \\<le> \\<delta> s' v \\<and>\n                            (w \\<in> dom (finished s') \\<longrightarrow>\n                             v \\<in> dom (finished s') \\<and>\n                             \\<phi> s' v\n                             \\<le> \\<phi> s' w) \\<longrightarrow>\n                            (v, w) \\<in> back_edges s' \\<or>\n                            (v, w) \\<in> pending s'", "qed auto"], ["", "end"], ["", "end"], ["", "context DFS_invar begin"], ["", "context begin"], ["", "interpretation timing_syntax"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma disc_imp_back_edge_or_pending:\n    \"\\<lbrakk>w \\<in> succ v; v \\<in> dom (discovered s); w \\<in> dom (discovered s); \\<delta> s w \\<le> \\<delta> s v;\n      (w \\<in> dom (finished s) \\<Longrightarrow> v \\<in> dom (finished s) \\<and> \\<phi> s v \\<le> \\<phi> s w)\\<rbrakk>\n     \\<Longrightarrow> (v, w) \\<in> back_edges s \\<or> (v, w) \\<in> pending s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>w \\<in> E `` {v}; v \\<in> dom (discovered s);\n     w \\<in> dom (discovered s); \\<delta> s w \\<le> \\<delta> s v;\n     w \\<in> dom (finished s) \\<Longrightarrow>\n     v \\<in> dom (finished s) \\<and> \\<phi> s v \\<le> \\<phi> s w\\<rbrakk>\n    \\<Longrightarrow> (v, w) \\<in> back_edges s \\<or> (v, w) \\<in> pending s", "using i_disc_imp_back_edge_or_pending[THEN make_invar_thm]"], ["proof (prove)\nusing this:\n  \\<forall>(v, w)\\<in>E.\n     v \\<in> dom (discovered s) \\<and>\n     w \\<in> dom (discovered s) \\<and>\n     \\<delta> s w \\<le> \\<delta> s v \\<and>\n     (w \\<in> dom (finished s) \\<longrightarrow>\n      v \\<in> dom (finished s) \\<and>\n      \\<phi> s v \\<le> \\<phi> s w) \\<longrightarrow>\n     (v, w) \\<in> back_edges s \\<or> (v, w) \\<in> pending s\n\ngoal (1 subgoal):\n 1. \\<lbrakk>w \\<in> E `` {v}; v \\<in> dom (discovered s);\n     w \\<in> dom (discovered s); \\<delta> s w \\<le> \\<delta> s v;\n     w \\<in> dom (finished s) \\<Longrightarrow>\n     v \\<in> dom (finished s) \\<and> \\<phi> s v \\<le> \\<phi> s w\\<rbrakk>\n    \\<Longrightarrow> (v, w) \\<in> back_edges s \\<or> (v, w) \\<in> pending s", "by blast"], ["", "lemma finished_imp_back_edge:\n    \"\\<lbrakk>w \\<in> succ v; v \\<in> dom (finished s); w \\<in> dom (finished s); \n      \\<delta> s w \\<le> \\<delta> s v; \\<phi> s v \\<le> \\<phi> s w\\<rbrakk>\n     \\<Longrightarrow> (v, w) \\<in> back_edges s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>w \\<in> E `` {v}; v \\<in> dom (finished s);\n     w \\<in> dom (finished s); \\<delta> s w \\<le> \\<delta> s v;\n     \\<phi> s v \\<le> \\<phi> s w\\<rbrakk>\n    \\<Longrightarrow> (v, w) \\<in> back_edges s", "using disc_imp_back_edge_or_pending finished_discovered finished_no_pending"], ["proof (prove)\nusing this:\n  \\<lbrakk>?w \\<in> E `` {?v}; ?v \\<in> dom (discovered s);\n   ?w \\<in> dom (discovered s); \\<delta> s ?w \\<le> \\<delta> s ?v;\n   ?w \\<in> dom (finished s) \\<Longrightarrow>\n   ?v \\<in> dom (finished s) \\<and> \\<phi> s ?v \\<le> \\<phi> s ?w\\<rbrakk>\n  \\<Longrightarrow> (?v, ?w) \\<in> back_edges s \\<or>\n                    (?v, ?w) \\<in> pending s\n  dom (finished s) \\<subseteq> dom (discovered s)\n  ?v \\<in> dom (finished s) \\<Longrightarrow> pending s `` {?v} = {}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>w \\<in> E `` {v}; v \\<in> dom (finished s);\n     w \\<in> dom (finished s); \\<delta> s w \\<le> \\<delta> s v;\n     \\<phi> s v \\<le> \\<phi> s w\\<rbrakk>\n    \\<Longrightarrow> (v, w) \\<in> back_edges s", "by fast"], ["", "lemma finished_not_finished_imp_back_edge:\n    \"\\<lbrakk>w \\<in> succ v; v \\<in> dom (finished s); w \\<in> dom (discovered s);\n      w \\<notin> dom (finished s);\n      \\<delta> s w \\<le> \\<delta> s v\\<rbrakk>\n     \\<Longrightarrow> (v, w) \\<in> back_edges s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>w \\<in> E `` {v}; v \\<in> dom (finished s);\n     w \\<in> dom (discovered s); w \\<notin> dom (finished s);\n     \\<delta> s w \\<le> \\<delta> s v\\<rbrakk>\n    \\<Longrightarrow> (v, w) \\<in> back_edges s", "using disc_imp_back_edge_or_pending finished_discovered finished_no_pending"], ["proof (prove)\nusing this:\n  \\<lbrakk>?w \\<in> E `` {?v}; ?v \\<in> dom (discovered s);\n   ?w \\<in> dom (discovered s); \\<delta> s ?w \\<le> \\<delta> s ?v;\n   ?w \\<in> dom (finished s) \\<Longrightarrow>\n   ?v \\<in> dom (finished s) \\<and> \\<phi> s ?v \\<le> \\<phi> s ?w\\<rbrakk>\n  \\<Longrightarrow> (?v, ?w) \\<in> back_edges s \\<or>\n                    (?v, ?w) \\<in> pending s\n  dom (finished s) \\<subseteq> dom (discovered s)\n  ?v \\<in> dom (finished s) \\<Longrightarrow> pending s `` {?v} = {}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>w \\<in> E `` {v}; v \\<in> dom (finished s);\n     w \\<in> dom (discovered s); w \\<notin> dom (finished s);\n     \\<delta> s w \\<le> \\<delta> s v\\<rbrakk>\n    \\<Longrightarrow> (v, w) \\<in> back_edges s", "by fast"], ["", "lemma finished_self_loop_in_back_edges:\n    assumes \"v \\<in> dom (finished s)\"\n    and \"(v,v) \\<in> E\"\n    shows \"(v,v) \\<in> back_edges s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (v, v) \\<in> back_edges s", "using assms"], ["proof (prove)\nusing this:\n  v \\<in> dom (finished s)\n  (v, v) \\<in> E\n\ngoal (1 subgoal):\n 1. (v, v) \\<in> back_edges s", "using finished_imp_back_edge"], ["proof (prove)\nusing this:\n  v \\<in> dom (finished s)\n  (v, v) \\<in> E\n  \\<lbrakk>?w \\<in> E `` {?v}; ?v \\<in> dom (finished s);\n   ?w \\<in> dom (finished s); \\<delta> s ?w \\<le> \\<delta> s ?v;\n   \\<phi> s ?v \\<le> \\<phi> s ?w\\<rbrakk>\n  \\<Longrightarrow> (?v, ?w) \\<in> back_edges s\n\ngoal (1 subgoal):\n 1. (v, v) \\<in> back_edges s", "by blast"], ["", "end"], ["", "end"], ["", "(* Back edges and Cycles *)"], ["", "context DFS_invar begin"], ["", "context begin"], ["", "interpretation timing_syntax"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "(* Cross and tree_edges edges are always acyclic *)"], ["", "lemma tree_cross_acyclic:\n      \"acyclic (tree_edges s \\<union> cross_edges s)\" (is \"acyclic ?E\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. acyclic (tree_edges s \\<union> cross_edges s)", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> acyclic (tree_edges s \\<union> cross_edges s) \\<Longrightarrow>\n    False", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> acyclic (tree_edges s \\<union> cross_edges s) \\<Longrightarrow>\n    False", "fix u v"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> acyclic (tree_edges s \\<union> cross_edges s) \\<Longrightarrow>\n    False", "assume *: \"u \\<in> dom (finished s)\" and \"(u,v) \\<in> ?E\\<^sup>+\""], ["proof (state)\nthis:\n  u \\<in> dom (finished s)\n  (u, v) \\<in> (tree_edges s \\<union> cross_edges s)\\<^sup>+\n\ngoal (1 subgoal):\n 1. \\<not> acyclic (tree_edges s \\<union> cross_edges s) \\<Longrightarrow>\n    False", "from this(2)"], ["proof (chain)\npicking this:\n  (u, v) \\<in> (tree_edges s \\<union> cross_edges s)\\<^sup>+", "have \"\\<phi> s v < \\<phi> s u \\<and> v \\<in> dom (finished s)\""], ["proof (prove)\nusing this:\n  (u, v) \\<in> (tree_edges s \\<union> cross_edges s)\\<^sup>+\n\ngoal (1 subgoal):\n 1. \\<phi> s v < \\<phi> s u \\<and> v \\<in> dom (finished s)", "proof induct"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>y.\n       (u, y) \\<in> tree_edges s \\<union> cross_edges s \\<Longrightarrow>\n       \\<phi> s y < \\<phi> s u \\<and> y \\<in> dom (finished s)\n 2. \\<And>y z.\n       \\<lbrakk>(u, y) \\<in> (tree_edges s \\<union> cross_edges s)\\<^sup>+;\n        (y, z) \\<in> tree_edges s \\<union> cross_edges s;\n        \\<phi> s y < \\<phi> s u \\<and> y \\<in> dom (finished s)\\<rbrakk>\n       \\<Longrightarrow> \\<phi> s z < \\<phi> s u \\<and>\n                         z \\<in> dom (finished s)", "case base"], ["proof (state)\nthis:\n  (u, y_) \\<in> tree_edges s \\<union> cross_edges s\n\ngoal (2 subgoals):\n 1. \\<And>y.\n       (u, y) \\<in> tree_edges s \\<union> cross_edges s \\<Longrightarrow>\n       \\<phi> s y < \\<phi> s u \\<and> y \\<in> dom (finished s)\n 2. \\<And>y z.\n       \\<lbrakk>(u, y) \\<in> (tree_edges s \\<union> cross_edges s)\\<^sup>+;\n        (y, z) \\<in> tree_edges s \\<union> cross_edges s;\n        \\<phi> s y < \\<phi> s u \\<and> y \\<in> dom (finished s)\\<rbrakk>\n       \\<Longrightarrow> \\<phi> s z < \\<phi> s u \\<and>\n                         z \\<in> dom (finished s)", "thus ?case"], ["proof (prove)\nusing this:\n  (u, y_) \\<in> tree_edges s \\<union> cross_edges s\n\ngoal (1 subgoal):\n 1. \\<phi> s y_ < \\<phi> s u \\<and> y_ \\<in> dom (finished s)", "by (metis Un_iff * cross_edges_finished_decr cross_edges_target_finished tree_edge_impl_parenthesis)"], ["proof (state)\nthis:\n  \\<phi> s y_ < \\<phi> s u \\<and> y_ \\<in> dom (finished s)\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>(u, y) \\<in> (tree_edges s \\<union> cross_edges s)\\<^sup>+;\n        (y, z) \\<in> tree_edges s \\<union> cross_edges s;\n        \\<phi> s y < \\<phi> s u \\<and> y \\<in> dom (finished s)\\<rbrakk>\n       \\<Longrightarrow> \\<phi> s z < \\<phi> s u \\<and>\n                         z \\<in> dom (finished s)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>(u, y) \\<in> (tree_edges s \\<union> cross_edges s)\\<^sup>+;\n        (y, z) \\<in> tree_edges s \\<union> cross_edges s;\n        \\<phi> s y < \\<phi> s u \\<and> y \\<in> dom (finished s)\\<rbrakk>\n       \\<Longrightarrow> \\<phi> s z < \\<phi> s u \\<and>\n                         z \\<in> dom (finished s)", "case (step v w)"], ["proof (state)\nthis:\n  (u, v) \\<in> (tree_edges s \\<union> cross_edges s)\\<^sup>+\n  (v, w) \\<in> tree_edges s \\<union> cross_edges s\n  \\<phi> s v < \\<phi> s u \\<and> v \\<in> dom (finished s)\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>(u, y) \\<in> (tree_edges s \\<union> cross_edges s)\\<^sup>+;\n        (y, z) \\<in> tree_edges s \\<union> cross_edges s;\n        \\<phi> s y < \\<phi> s u \\<and> y \\<in> dom (finished s)\\<rbrakk>\n       \\<Longrightarrow> \\<phi> s z < \\<phi> s u \\<and>\n                         z \\<in> dom (finished s)", "hence \"\\<phi> s w < \\<phi> s v \\<and> w \\<in> dom (finished s)\""], ["proof (prove)\nusing this:\n  (u, v) \\<in> (tree_edges s \\<union> cross_edges s)\\<^sup>+\n  (v, w) \\<in> tree_edges s \\<union> cross_edges s\n  \\<phi> s v < \\<phi> s u \\<and> v \\<in> dom (finished s)\n\ngoal (1 subgoal):\n 1. \\<phi> s w < \\<phi> s v \\<and> w \\<in> dom (finished s)", "by (metis Un_iff cross_edges_finished_decr cross_edges_target_finished tree_edge_impl_parenthesis)"], ["proof (state)\nthis:\n  \\<phi> s w < \\<phi> s v \\<and> w \\<in> dom (finished s)\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>(u, y) \\<in> (tree_edges s \\<union> cross_edges s)\\<^sup>+;\n        (y, z) \\<in> tree_edges s \\<union> cross_edges s;\n        \\<phi> s y < \\<phi> s u \\<and> y \\<in> dom (finished s)\\<rbrakk>\n       \\<Longrightarrow> \\<phi> s z < \\<phi> s u \\<and>\n                         z \\<in> dom (finished s)", "with step"], ["proof (chain)\npicking this:\n  (u, v) \\<in> (tree_edges s \\<union> cross_edges s)\\<^sup>+\n  (v, w) \\<in> tree_edges s \\<union> cross_edges s\n  \\<phi> s v < \\<phi> s u \\<and> v \\<in> dom (finished s)\n  \\<phi> s w < \\<phi> s v \\<and> w \\<in> dom (finished s)", "show ?case"], ["proof (prove)\nusing this:\n  (u, v) \\<in> (tree_edges s \\<union> cross_edges s)\\<^sup>+\n  (v, w) \\<in> tree_edges s \\<union> cross_edges s\n  \\<phi> s v < \\<phi> s u \\<and> v \\<in> dom (finished s)\n  \\<phi> s w < \\<phi> s v \\<and> w \\<in> dom (finished s)\n\ngoal (1 subgoal):\n 1. \\<phi> s w < \\<phi> s u \\<and> w \\<in> dom (finished s)", "by auto"], ["proof (state)\nthis:\n  \\<phi> s w < \\<phi> s u \\<and> w \\<in> dom (finished s)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<phi> s v < \\<phi> s u \\<and> v \\<in> dom (finished s)\n\ngoal (1 subgoal):\n 1. \\<not> acyclic (tree_edges s \\<union> cross_edges s) \\<Longrightarrow>\n    False", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?u9 \\<in> dom (finished s);\n   (?u9, ?v9) \\<in> (tree_edges s \\<union> cross_edges s)\\<^sup>+\\<rbrakk>\n  \\<Longrightarrow> \\<phi> s ?v9 < \\<phi> s ?u9 \\<and>\n                    ?v9 \\<in> dom (finished s)\n\ngoal (1 subgoal):\n 1. \\<not> acyclic (tree_edges s \\<union> cross_edges s) \\<Longrightarrow>\n    False", "note aux = this"], ["proof (state)\nthis:\n  \\<lbrakk>?u9 \\<in> dom (finished s);\n   (?u9, ?v9) \\<in> (tree_edges s \\<union> cross_edges s)\\<^sup>+\\<rbrakk>\n  \\<Longrightarrow> \\<phi> s ?v9 < \\<phi> s ?u9 \\<and>\n                    ?v9 \\<in> dom (finished s)\n\ngoal (1 subgoal):\n 1. \\<not> acyclic (tree_edges s \\<union> cross_edges s) \\<Longrightarrow>\n    False", "assume \"\\<not> acyclic ?E\""], ["proof (state)\nthis:\n  \\<not> acyclic (tree_edges s \\<union> cross_edges s)\n\ngoal (1 subgoal):\n 1. \\<not> acyclic (tree_edges s \\<union> cross_edges s) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<not> acyclic (tree_edges s \\<union> cross_edges s)", "obtain u where path: \"(u,u) \\<in> ?E\\<^sup>+\""], ["proof (prove)\nusing this:\n  \\<not> acyclic (tree_edges s \\<union> cross_edges s)\n\ngoal (1 subgoal):\n 1. (\\<And>u.\n        (u, u)\n        \\<in> (tree_edges s \\<union>\n               cross_edges s)\\<^sup>+ \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (auto simp add: acyclic_def)"], ["proof (state)\nthis:\n  (u, u) \\<in> (tree_edges s \\<union> cross_edges s)\\<^sup>+\n\ngoal (1 subgoal):\n 1. \\<not> acyclic (tree_edges s \\<union> cross_edges s) \\<Longrightarrow>\n    False", "show False"], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> False\n 2. \\<not> ?P \\<Longrightarrow> False", "assume \"u \\<in> dom (finished s)\""], ["proof (state)\nthis:\n  u \\<in> dom (finished s)\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> False\n 2. \\<not> ?P \\<Longrightarrow> False", "with aux path"], ["proof (chain)\npicking this:\n  \\<lbrakk>?u9 \\<in> dom (finished s);\n   (?u9, ?v9) \\<in> (tree_edges s \\<union> cross_edges s)\\<^sup>+\\<rbrakk>\n  \\<Longrightarrow> \\<phi> s ?v9 < \\<phi> s ?u9 \\<and>\n                    ?v9 \\<in> dom (finished s)\n  (u, u) \\<in> (tree_edges s \\<union> cross_edges s)\\<^sup>+\n  u \\<in> dom (finished s)", "show False"], ["proof (prove)\nusing this:\n  \\<lbrakk>?u9 \\<in> dom (finished s);\n   (?u9, ?v9) \\<in> (tree_edges s \\<union> cross_edges s)\\<^sup>+\\<rbrakk>\n  \\<Longrightarrow> \\<phi> s ?v9 < \\<phi> s ?u9 \\<and>\n                    ?v9 \\<in> dom (finished s)\n  (u, u) \\<in> (tree_edges s \\<union> cross_edges s)\\<^sup>+\n  u \\<in> dom (finished s)\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. u \\<notin> dom (finished s) \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. u \\<notin> dom (finished s) \\<Longrightarrow> False", "assume *: \"u \\<notin> dom (finished s)\""], ["proof (state)\nthis:\n  u \\<notin> dom (finished s)\n\ngoal (1 subgoal):\n 1. u \\<notin> dom (finished s) \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  u \\<notin> dom (finished s)\n\ngoal (1 subgoal):\n 1. u \\<notin> dom (finished s) \\<Longrightarrow> False", "from no_loop_in_tree"], ["proof (chain)\npicking this:\n  (?v, ?v) \\<notin> (tree_edges s)\\<^sup>+", "have \"(u,u) \\<notin> (tree_edges s)\\<^sup>+\""], ["proof (prove)\nusing this:\n  (?v, ?v) \\<notin> (tree_edges s)\\<^sup>+\n\ngoal (1 subgoal):\n 1. (u, u) \\<notin> (tree_edges s)\\<^sup>+", "."], ["proof (state)\nthis:\n  (u, u) \\<notin> (tree_edges s)\\<^sup>+\n\ngoal (1 subgoal):\n 1. u \\<notin> dom (finished s) \\<Longrightarrow> False", "with trancl_union_outside[OF path]"], ["proof (chain)\npicking this:\n  (u, u) \\<notin> (tree_edges s)\\<^sup>+ \\<Longrightarrow>\n  \\<exists>x y.\n     (u, x) \\<in> (tree_edges s \\<union> cross_edges s)\\<^sup>* \\<and>\n     (x, y) \\<in> cross_edges s \\<and>\n     (y, u) \\<in> (tree_edges s \\<union> cross_edges s)\\<^sup>*\n  (u, u) \\<notin> (tree_edges s)\\<^sup>+", "obtain x y where \"(u,x) \\<in> ?E\\<^sup>*\" \"(x,y) \\<in> cross_edges s\" \"(y,u) \\<in> ?E\\<^sup>*\""], ["proof (prove)\nusing this:\n  (u, u) \\<notin> (tree_edges s)\\<^sup>+ \\<Longrightarrow>\n  \\<exists>x y.\n     (u, x) \\<in> (tree_edges s \\<union> cross_edges s)\\<^sup>* \\<and>\n     (x, y) \\<in> cross_edges s \\<and>\n     (y, u) \\<in> (tree_edges s \\<union> cross_edges s)\\<^sup>*\n  (u, u) \\<notin> (tree_edges s)\\<^sup>+\n\ngoal (1 subgoal):\n 1. (\\<And>x y.\n        \\<lbrakk>(u, x) \\<in> (tree_edges s \\<union> cross_edges s)\\<^sup>*;\n         (x, y) \\<in> cross_edges s;\n         (y, u) \\<in> (tree_edges s \\<union> cross_edges s)\\<^sup>*\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  (u, x) \\<in> (tree_edges s \\<union> cross_edges s)\\<^sup>*\n  (x, y) \\<in> cross_edges s\n  (y, u) \\<in> (tree_edges s \\<union> cross_edges s)\\<^sup>*\n\ngoal (1 subgoal):\n 1. u \\<notin> dom (finished s) \\<Longrightarrow> False", "with cross_edges_target_finished"], ["proof (chain)\npicking this:\n  (?u, ?v) \\<in> cross_edges s \\<Longrightarrow> ?v \\<in> dom (finished s)\n  (u, x) \\<in> (tree_edges s \\<union> cross_edges s)\\<^sup>*\n  (x, y) \\<in> cross_edges s\n  (y, u) \\<in> (tree_edges s \\<union> cross_edges s)\\<^sup>*", "have \"y \\<in> dom (finished s)\""], ["proof (prove)\nusing this:\n  (?u, ?v) \\<in> cross_edges s \\<Longrightarrow> ?v \\<in> dom (finished s)\n  (u, x) \\<in> (tree_edges s \\<union> cross_edges s)\\<^sup>*\n  (x, y) \\<in> cross_edges s\n  (y, u) \\<in> (tree_edges s \\<union> cross_edges s)\\<^sup>*\n\ngoal (1 subgoal):\n 1. y \\<in> dom (finished s)", "by simp"], ["proof (state)\nthis:\n  y \\<in> dom (finished s)\n\ngoal (1 subgoal):\n 1. u \\<notin> dom (finished s) \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  y \\<in> dom (finished s)\n\ngoal (1 subgoal):\n 1. u \\<notin> dom (finished s) \\<Longrightarrow> False", "with * \\<open>(y,u) \\<in> ?E\\<^sup>*\\<close>"], ["proof (chain)\npicking this:\n  u \\<notin> dom (finished s)\n  (y, u) \\<in> (tree_edges s \\<union> cross_edges s)\\<^sup>*\n  y \\<in> dom (finished s)", "have \"(y,u) \\<in> ?E\\<^sup>+\""], ["proof (prove)\nusing this:\n  u \\<notin> dom (finished s)\n  (y, u) \\<in> (tree_edges s \\<union> cross_edges s)\\<^sup>*\n  y \\<in> dom (finished s)\n\ngoal (1 subgoal):\n 1. (y, u) \\<in> (tree_edges s \\<union> cross_edges s)\\<^sup>+", "by (auto simp add: rtrancl_eq_or_trancl)"], ["proof (state)\nthis:\n  (y, u) \\<in> (tree_edges s \\<union> cross_edges s)\\<^sup>+\n\ngoal (1 subgoal):\n 1. u \\<notin> dom (finished s) \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  u \\<notin> dom (finished s)\n  y \\<in> dom (finished s)\n  (y, u) \\<in> (tree_edges s \\<union> cross_edges s)\\<^sup>+", "show False"], ["proof (prove)\nusing this:\n  u \\<notin> dom (finished s)\n  y \\<in> dom (finished s)\n  (y, u) \\<in> (tree_edges s \\<union> cross_edges s)\\<^sup>+\n\ngoal (1 subgoal):\n 1. False", "by (metis aux)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "lemma cycle_contains_back_edge:\n    assumes cycle: \"(u,u) \\<in> (edges s)\\<^sup>+\"\n    shows \"\\<exists>v w. (u,v) \\<in> (edges s)\\<^sup>* \\<and> (v,w) \\<in> back_edges s \\<and> (w,u) \\<in> (edges s)\\<^sup>*\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>v w.\n       (u, v)\n       \\<in> (tree_edges s \\<union> cross_edges s \\<union>\n              back_edges s)\\<^sup>* \\<and>\n       (v, w) \\<in> back_edges s \\<and>\n       (w, u)\n       \\<in> (tree_edges s \\<union> cross_edges s \\<union>\n              back_edges s)\\<^sup>*", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>v w.\n       (u, v)\n       \\<in> (tree_edges s \\<union> cross_edges s \\<union>\n              back_edges s)\\<^sup>* \\<and>\n       (v, w) \\<in> back_edges s \\<and>\n       (w, u)\n       \\<in> (tree_edges s \\<union> cross_edges s \\<union>\n              back_edges s)\\<^sup>*", "from tree_cross_acyclic"], ["proof (chain)\npicking this:\n  acyclic (tree_edges s \\<union> cross_edges s)", "have \"(u,u) \\<notin> (tree_edges s \\<union> cross_edges s)\\<^sup>+\""], ["proof (prove)\nusing this:\n  acyclic (tree_edges s \\<union> cross_edges s)\n\ngoal (1 subgoal):\n 1. (u, u) \\<notin> (tree_edges s \\<union> cross_edges s)\\<^sup>+", "by (simp add: acyclic_def)"], ["proof (state)\nthis:\n  (u, u) \\<notin> (tree_edges s \\<union> cross_edges s)\\<^sup>+\n\ngoal (1 subgoal):\n 1. \\<exists>v w.\n       (u, v)\n       \\<in> (tree_edges s \\<union> cross_edges s \\<union>\n              back_edges s)\\<^sup>* \\<and>\n       (v, w) \\<in> back_edges s \\<and>\n       (w, u)\n       \\<in> (tree_edges s \\<union> cross_edges s \\<union>\n              back_edges s)\\<^sup>*", "with trancl_union_outside[OF cycle]"], ["proof (chain)\npicking this:\n  (u, u)\n  \\<notin> (tree_edges s \\<union> cross_edges s)\\<^sup>+ \\<Longrightarrow>\n  \\<exists>x y.\n     (u, x)\n     \\<in> (tree_edges s \\<union> cross_edges s \\<union>\n            back_edges s)\\<^sup>* \\<and>\n     (x, y) \\<in> back_edges s \\<and>\n     (y, u)\n     \\<in> (tree_edges s \\<union> cross_edges s \\<union>\n            back_edges s)\\<^sup>*\n  (u, u) \\<notin> (tree_edges s \\<union> cross_edges s)\\<^sup>+", "show ?thesis"], ["proof (prove)\nusing this:\n  (u, u)\n  \\<notin> (tree_edges s \\<union> cross_edges s)\\<^sup>+ \\<Longrightarrow>\n  \\<exists>x y.\n     (u, x)\n     \\<in> (tree_edges s \\<union> cross_edges s \\<union>\n            back_edges s)\\<^sup>* \\<and>\n     (x, y) \\<in> back_edges s \\<and>\n     (y, u)\n     \\<in> (tree_edges s \\<union> cross_edges s \\<union>\n            back_edges s)\\<^sup>*\n  (u, u) \\<notin> (tree_edges s \\<union> cross_edges s)\\<^sup>+\n\ngoal (1 subgoal):\n 1. \\<exists>v w.\n       (u, v)\n       \\<in> (tree_edges s \\<union> cross_edges s \\<union>\n              back_edges s)\\<^sup>* \\<and>\n       (v, w) \\<in> back_edges s \\<and>\n       (w, u)\n       \\<in> (tree_edges s \\<union> cross_edges s \\<union>\n              back_edges s)\\<^sup>*", "."], ["proof (state)\nthis:\n  \\<exists>v w.\n     (u, v)\n     \\<in> (tree_edges s \\<union> cross_edges s \\<union>\n            back_edges s)\\<^sup>* \\<and>\n     (v, w) \\<in> back_edges s \\<and>\n     (w, u)\n     \\<in> (tree_edges s \\<union> cross_edges s \\<union>\n            back_edges s)\\<^sup>*\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cycle_needs_back_edge:\n    assumes \"back_edges s = {}\"\n    shows \"acyclic (edges s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. acyclic (tree_edges s \\<union> cross_edges s \\<union> back_edges s)", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> acyclic\n            (tree_edges s \\<union> cross_edges s \\<union>\n             back_edges s) \\<Longrightarrow>\n    False", "assume \"\\<not> acyclic (edges s)\""], ["proof (state)\nthis:\n  \\<not> acyclic (tree_edges s \\<union> cross_edges s \\<union> back_edges s)\n\ngoal (1 subgoal):\n 1. \\<not> acyclic\n            (tree_edges s \\<union> cross_edges s \\<union>\n             back_edges s) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<not> acyclic (tree_edges s \\<union> cross_edges s \\<union> back_edges s)", "obtain u where \"(u,u) \\<in> (edges s)\\<^sup>+\""], ["proof (prove)\nusing this:\n  \\<not> acyclic (tree_edges s \\<union> cross_edges s \\<union> back_edges s)\n\ngoal (1 subgoal):\n 1. (\\<And>u.\n        (u, u)\n        \\<in> (tree_edges s \\<union> cross_edges s \\<union>\n               back_edges s)\\<^sup>+ \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: acyclic_def)"], ["proof (state)\nthis:\n  (u, u)\n  \\<in> (tree_edges s \\<union> cross_edges s \\<union> back_edges s)\\<^sup>+\n\ngoal (1 subgoal):\n 1. \\<not> acyclic\n            (tree_edges s \\<union> cross_edges s \\<union>\n             back_edges s) \\<Longrightarrow>\n    False", "with assms"], ["proof (chain)\npicking this:\n  back_edges s = {}\n  (u, u)\n  \\<in> (tree_edges s \\<union> cross_edges s \\<union> back_edges s)\\<^sup>+", "have \"(u,u) \\<in> (tree_edges s \\<union> cross_edges s)\\<^sup>+\""], ["proof (prove)\nusing this:\n  back_edges s = {}\n  (u, u)\n  \\<in> (tree_edges s \\<union> cross_edges s \\<union> back_edges s)\\<^sup>+\n\ngoal (1 subgoal):\n 1. (u, u) \\<in> (tree_edges s \\<union> cross_edges s)\\<^sup>+", "by auto"], ["proof (state)\nthis:\n  (u, u) \\<in> (tree_edges s \\<union> cross_edges s)\\<^sup>+\n\ngoal (1 subgoal):\n 1. \\<not> acyclic\n            (tree_edges s \\<union> cross_edges s \\<union>\n             back_edges s) \\<Longrightarrow>\n    False", "with tree_cross_acyclic"], ["proof (chain)\npicking this:\n  acyclic (tree_edges s \\<union> cross_edges s)\n  (u, u) \\<in> (tree_edges s \\<union> cross_edges s)\\<^sup>+", "show False"], ["proof (prove)\nusing this:\n  acyclic (tree_edges s \\<union> cross_edges s)\n  (u, u) \\<in> (tree_edges s \\<union> cross_edges s)\\<^sup>+\n\ngoal (1 subgoal):\n 1. False", "by (simp add: acyclic_def)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma back_edge_closes_cycle:\n    assumes \"back_edges s \\<noteq> {}\"\n    shows \"\\<not> acyclic (edges s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> acyclic\n            (tree_edges s \\<union> cross_edges s \\<union> back_edges s)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> acyclic\n            (tree_edges s \\<union> cross_edges s \\<union> back_edges s)", "from assms"], ["proof (chain)\npicking this:\n  back_edges s \\<noteq> {}", "obtain v w where be: \"(v,w) \\<in> back_edges s\""], ["proof (prove)\nusing this:\n  back_edges s \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>v w.\n        (v, w) \\<in> back_edges s \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  (v, w) \\<in> back_edges s\n\ngoal (1 subgoal):\n 1. \\<not> acyclic\n            (tree_edges s \\<union> cross_edges s \\<union> back_edges s)", "hence \"(w,w) \\<in> (edges s)\\<^sup>+\""], ["proof (prove)\nusing this:\n  (v, w) \\<in> back_edges s\n\ngoal (1 subgoal):\n 1. (w, w)\n    \\<in> (tree_edges s \\<union> cross_edges s \\<union>\n           back_edges s)\\<^sup>+", "proof (cases \"v=w\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>(v, w) \\<in> back_edges s; v = w\\<rbrakk>\n    \\<Longrightarrow> (w, w)\n                      \\<in> (tree_edges s \\<union> cross_edges s \\<union>\n                             back_edges s)\\<^sup>+\n 2. \\<lbrakk>(v, w) \\<in> back_edges s; v \\<noteq> w\\<rbrakk>\n    \\<Longrightarrow> (w, w)\n                      \\<in> (tree_edges s \\<union> cross_edges s \\<union>\n                             back_edges s)\\<^sup>+", "case False"], ["proof (state)\nthis:\n  v \\<noteq> w\n\ngoal (2 subgoals):\n 1. \\<lbrakk>(v, w) \\<in> back_edges s; v = w\\<rbrakk>\n    \\<Longrightarrow> (w, w)\n                      \\<in> (tree_edges s \\<union> cross_edges s \\<union>\n                             back_edges s)\\<^sup>+\n 2. \\<lbrakk>(v, w) \\<in> back_edges s; v \\<noteq> w\\<rbrakk>\n    \\<Longrightarrow> (w, w)\n                      \\<in> (tree_edges s \\<union> cross_edges s \\<union>\n                             back_edges s)\\<^sup>+", "with be back_edge_impl_tree_path"], ["proof (chain)\npicking this:\n  (v, w) \\<in> back_edges s\n  \\<lbrakk>(?v, ?w) \\<in> back_edges s; ?v \\<noteq> ?w\\<rbrakk>\n  \\<Longrightarrow> (?w, ?v) \\<in> (tree_edges s)\\<^sup>+\n  v \\<noteq> w", "have \"(w,v) \\<in> (tree_edges s)\\<^sup>+\""], ["proof (prove)\nusing this:\n  (v, w) \\<in> back_edges s\n  \\<lbrakk>(?v, ?w) \\<in> back_edges s; ?v \\<noteq> ?w\\<rbrakk>\n  \\<Longrightarrow> (?w, ?v) \\<in> (tree_edges s)\\<^sup>+\n  v \\<noteq> w\n\ngoal (1 subgoal):\n 1. (w, v) \\<in> (tree_edges s)\\<^sup>+", "by simp"], ["proof (state)\nthis:\n  (w, v) \\<in> (tree_edges s)\\<^sup>+\n\ngoal (2 subgoals):\n 1. \\<lbrakk>(v, w) \\<in> back_edges s; v = w\\<rbrakk>\n    \\<Longrightarrow> (w, w)\n                      \\<in> (tree_edges s \\<union> cross_edges s \\<union>\n                             back_edges s)\\<^sup>+\n 2. \\<lbrakk>(v, w) \\<in> back_edges s; v \\<noteq> w\\<rbrakk>\n    \\<Longrightarrow> (w, w)\n                      \\<in> (tree_edges s \\<union> cross_edges s \\<union>\n                             back_edges s)\\<^sup>+", "hence \"(w,v) \\<in> (edges s)\\<^sup>+\""], ["proof (prove)\nusing this:\n  (w, v) \\<in> (tree_edges s)\\<^sup>+\n\ngoal (1 subgoal):\n 1. (w, v)\n    \\<in> (tree_edges s \\<union> cross_edges s \\<union>\n           back_edges s)\\<^sup>+", "by (blast intro: trancl_mono_mp)"], ["proof (state)\nthis:\n  (w, v)\n  \\<in> (tree_edges s \\<union> cross_edges s \\<union> back_edges s)\\<^sup>+\n\ngoal (2 subgoals):\n 1. \\<lbrakk>(v, w) \\<in> back_edges s; v = w\\<rbrakk>\n    \\<Longrightarrow> (w, w)\n                      \\<in> (tree_edges s \\<union> cross_edges s \\<union>\n                             back_edges s)\\<^sup>+\n 2. \\<lbrakk>(v, w) \\<in> back_edges s; v \\<noteq> w\\<rbrakk>\n    \\<Longrightarrow> (w, w)\n                      \\<in> (tree_edges s \\<union> cross_edges s \\<union>\n                             back_edges s)\\<^sup>+", "also"], ["proof (state)\nthis:\n  (w, v)\n  \\<in> (tree_edges s \\<union> cross_edges s \\<union> back_edges s)\\<^sup>+\n\ngoal (2 subgoals):\n 1. \\<lbrakk>(v, w) \\<in> back_edges s; v = w\\<rbrakk>\n    \\<Longrightarrow> (w, w)\n                      \\<in> (tree_edges s \\<union> cross_edges s \\<union>\n                             back_edges s)\\<^sup>+\n 2. \\<lbrakk>(v, w) \\<in> back_edges s; v \\<noteq> w\\<rbrakk>\n    \\<Longrightarrow> (w, w)\n                      \\<in> (tree_edges s \\<union> cross_edges s \\<union>\n                             back_edges s)\\<^sup>+", "from be"], ["proof (chain)\npicking this:\n  (v, w) \\<in> back_edges s", "have \"(v,w) \\<in> edges s\""], ["proof (prove)\nusing this:\n  (v, w) \\<in> back_edges s\n\ngoal (1 subgoal):\n 1. (v, w) \\<in> tree_edges s \\<union> cross_edges s \\<union> back_edges s", "by simp"], ["proof (state)\nthis:\n  (v, w) \\<in> tree_edges s \\<union> cross_edges s \\<union> back_edges s\n\ngoal (2 subgoals):\n 1. \\<lbrakk>(v, w) \\<in> back_edges s; v = w\\<rbrakk>\n    \\<Longrightarrow> (w, w)\n                      \\<in> (tree_edges s \\<union> cross_edges s \\<union>\n                             back_edges s)\\<^sup>+\n 2. \\<lbrakk>(v, w) \\<in> back_edges s; v \\<noteq> w\\<rbrakk>\n    \\<Longrightarrow> (w, w)\n                      \\<in> (tree_edges s \\<union> cross_edges s \\<union>\n                             back_edges s)\\<^sup>+", "finally"], ["proof (chain)\npicking this:\n  (w, w)\n  \\<in> (tree_edges s \\<union> cross_edges s \\<union> back_edges s)\\<^sup>+", "show ?thesis"], ["proof (prove)\nusing this:\n  (w, w)\n  \\<in> (tree_edges s \\<union> cross_edges s \\<union> back_edges s)\\<^sup>+\n\ngoal (1 subgoal):\n 1. (w, w)\n    \\<in> (tree_edges s \\<union> cross_edges s \\<union>\n           back_edges s)\\<^sup>+", "."], ["proof (state)\nthis:\n  (w, w)\n  \\<in> (tree_edges s \\<union> cross_edges s \\<union> back_edges s)\\<^sup>+\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(v, w) \\<in> back_edges s; v = w\\<rbrakk>\n    \\<Longrightarrow> (w, w)\n                      \\<in> (tree_edges s \\<union> cross_edges s \\<union>\n                             back_edges s)\\<^sup>+", "qed auto"], ["proof (state)\nthis:\n  (w, w)\n  \\<in> (tree_edges s \\<union> cross_edges s \\<union> back_edges s)\\<^sup>+\n\ngoal (1 subgoal):\n 1. \\<not> acyclic\n            (tree_edges s \\<union> cross_edges s \\<union> back_edges s)", "thus ?thesis"], ["proof (prove)\nusing this:\n  (w, w)\n  \\<in> (tree_edges s \\<union> cross_edges s \\<union> back_edges s)\\<^sup>+\n\ngoal (1 subgoal):\n 1. \\<not> acyclic\n            (tree_edges s \\<union> cross_edges s \\<union> back_edges s)", "by (auto simp add: acyclic_def)"], ["proof (state)\nthis:\n  \\<not> acyclic (tree_edges s \\<union> cross_edges s \\<union> back_edges s)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma back_edge_closes_reachable_cycle:\n    \"back_edges s \\<noteq> {} \\<Longrightarrow> \\<not> acyclic (E \\<inter> reachable \\<times> UNIV)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. back_edges s \\<noteq> {} \\<Longrightarrow>\n    \\<not> acyclic (E \\<inter> reachable \\<times> UNIV)", "by (metis back_edge_closes_cycle edges_ss_reachable_edges cyclic_subset)"], ["", "lemma cycle_iff_back_edges:\n    \"acyclic (edges s) \\<longleftrightarrow> back_edges s = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. acyclic (tree_edges s \\<union> cross_edges s \\<union> back_edges s) =\n    (back_edges s = {})", "by (metis back_edge_closes_cycle cycle_needs_back_edge)"], ["", "end"], ["", "subsection \\<open>White Path Theorem\\<close>"], ["", "context DFS begin"], ["", "context begin"], ["", "interpretation timing_syntax"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "definition white_path where\n    \"white_path s x y \\<equiv> x\\<noteq>y \n       \\<longrightarrow> (\\<exists>p. path E x p y \\<and> \n               (\\<delta> s x < \\<delta> s y \\<and> (\\<forall> v \\<in> set (tl p). \\<delta> s x < \\<delta> s v)))\""], ["", "lemma white_path:\n    \"it_dfs \\<le> SPEC(\\<lambda>s. \\<forall>x \\<in> reachable. \\<forall>y \\<in> reachable. \\<not> is_break param s \\<longrightarrow> \n            white_path s x y \\<longleftrightarrow> (x,y) \\<in> (tree_edges s)\\<^sup>*)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. it_dfs\n    \\<le> SPEC\n           (\\<lambda>s.\n               \\<forall>x\\<in>reachable.\n                  \\<forall>y\\<in>reachable.\n                     \\<not> is_break param s \\<longrightarrow>\n                     white_path s x y =\n                     ((x, y) \\<in> (tree_edges s)\\<^sup>*))", "proof (rule it_dfs_SPEC, intro ballI impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s x y.\n       \\<lbrakk>DFS_invar G param s; \\<not> cond s; x \\<in> reachable;\n        y \\<in> reachable; \\<not> is_break param s\\<rbrakk>\n       \\<Longrightarrow> white_path s x y =\n                         ((x, y) \\<in> (tree_edges s)\\<^sup>*)", "fix s x y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s x y.\n       \\<lbrakk>DFS_invar G param s; \\<not> cond s; x \\<in> reachable;\n        y \\<in> reachable; \\<not> is_break param s\\<rbrakk>\n       \\<Longrightarrow> white_path s x y =\n                         ((x, y) \\<in> (tree_edges s)\\<^sup>*)", "assume DI: \"DFS_invar G param s\"\n      and C: \"\\<not> cond s\" \"\\<not> is_break param s\"\n      and reach: \"x \\<in> reachable\" \"y \\<in> reachable\""], ["proof (state)\nthis:\n  DFS_invar G param s\n  \\<not> cond s\n  \\<not> is_break param s\n  x \\<in> reachable\n  y \\<in> reachable\n\ngoal (1 subgoal):\n 1. \\<And>s x y.\n       \\<lbrakk>DFS_invar G param s; \\<not> cond s; x \\<in> reachable;\n        y \\<in> reachable; \\<not> is_break param s\\<rbrakk>\n       \\<Longrightarrow> white_path s x y =\n                         ((x, y) \\<in> (tree_edges s)\\<^sup>*)", "from DI"], ["proof (chain)\npicking this:\n  DFS_invar G param s", "interpret DFS_invar where s=s"], ["proof (prove)\nusing this:\n  DFS_invar G param s\n\ngoal (1 subgoal):\n 1. DFS_invar G param s", "."], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s x y.\n       \\<lbrakk>DFS_invar G param s; \\<not> cond s; x \\<in> reachable;\n        y \\<in> reachable; \\<not> is_break param s\\<rbrakk>\n       \\<Longrightarrow> white_path s x y =\n                         ((x, y) \\<in> (tree_edges s)\\<^sup>*)", "note fin_eq_reach = nc_finished_eq_reachable[OF C]"], ["proof (state)\nthis:\n  dom (finished s) = reachable\n\ngoal (1 subgoal):\n 1. \\<And>s x y.\n       \\<lbrakk>DFS_invar G param s; \\<not> cond s; x \\<in> reachable;\n        y \\<in> reachable; \\<not> is_break param s\\<rbrakk>\n       \\<Longrightarrow> white_path s x y =\n                         ((x, y) \\<in> (tree_edges s)\\<^sup>*)", "show \"white_path s x y \\<longleftrightarrow> (x,y) \\<in> (tree_edges s)\\<^sup>*\""], ["proof (prove)\ngoal (1 subgoal):\n 1. white_path s x y = ((x, y) \\<in> (tree_edges s)\\<^sup>*)", "proof (cases \"x=y\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x = y \\<Longrightarrow>\n    white_path s x y = ((x, y) \\<in> (tree_edges s)\\<^sup>*)\n 2. x \\<noteq> y \\<Longrightarrow>\n    white_path s x y = ((x, y) \\<in> (tree_edges s)\\<^sup>*)", "case True"], ["proof (state)\nthis:\n  x = y\n\ngoal (2 subgoals):\n 1. x = y \\<Longrightarrow>\n    white_path s x y = ((x, y) \\<in> (tree_edges s)\\<^sup>*)\n 2. x \\<noteq> y \\<Longrightarrow>\n    white_path s x y = ((x, y) \\<in> (tree_edges s)\\<^sup>*)", "thus ?thesis"], ["proof (prove)\nusing this:\n  x = y\n\ngoal (1 subgoal):\n 1. white_path s x y = ((x, y) \\<in> (tree_edges s)\\<^sup>*)", "by (simp add: white_path_def)"], ["proof (state)\nthis:\n  white_path s x y = ((x, y) \\<in> (tree_edges s)\\<^sup>*)\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow>\n    white_path s x y = ((x, y) \\<in> (tree_edges s)\\<^sup>*)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow>\n    white_path s x y = ((x, y) \\<in> (tree_edges s)\\<^sup>*)", "case False"], ["proof (state)\nthis:\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow>\n    white_path s x y = ((x, y) \\<in> (tree_edges s)\\<^sup>*)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. white_path s x y = ((x, y) \\<in> (tree_edges s)\\<^sup>*)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. white_path s x y \\<Longrightarrow> (x, y) \\<in> (tree_edges s)\\<^sup>*\n 2. (x, y) \\<in> (tree_edges s)\\<^sup>* \\<Longrightarrow> white_path s x y", "assume \"(x,y) \\<in> (tree_edges s)\\<^sup>*\""], ["proof (state)\nthis:\n  (x, y) \\<in> (tree_edges s)\\<^sup>*\n\ngoal (2 subgoals):\n 1. white_path s x y \\<Longrightarrow> (x, y) \\<in> (tree_edges s)\\<^sup>*\n 2. (x, y) \\<in> (tree_edges s)\\<^sup>* \\<Longrightarrow> white_path s x y", "with \\<open>x\\<noteq>y\\<close>"], ["proof (chain)\npicking this:\n  x \\<noteq> y\n  (x, y) \\<in> (tree_edges s)\\<^sup>*", "have T: \"(x,y) \\<in> (tree_edges s)\\<^sup>+\""], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  (x, y) \\<in> (tree_edges s)\\<^sup>*\n\ngoal (1 subgoal):\n 1. (x, y) \\<in> (tree_edges s)\\<^sup>+", "by (metis rtranclD)"], ["proof (state)\nthis:\n  (x, y) \\<in> (tree_edges s)\\<^sup>+\n\ngoal (2 subgoals):\n 1. white_path s x y \\<Longrightarrow> (x, y) \\<in> (tree_edges s)\\<^sup>*\n 2. (x, y) \\<in> (tree_edges s)\\<^sup>* \\<Longrightarrow> white_path s x y", "then"], ["proof (chain)\npicking this:\n  (x, y) \\<in> (tree_edges s)\\<^sup>+", "obtain p where P: \"path (tree_edges s) x p y\""], ["proof (prove)\nusing this:\n  (x, y) \\<in> (tree_edges s)\\<^sup>+\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        path (tree_edges s) x p y \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis trancl_is_path)"], ["proof (state)\nthis:\n  path (tree_edges s) x p y\n\ngoal (2 subgoals):\n 1. white_path s x y \\<Longrightarrow> (x, y) \\<in> (tree_edges s)\\<^sup>*\n 2. (x, y) \\<in> (tree_edges s)\\<^sup>* \\<Longrightarrow> white_path s x y", "with tree_edges_ssE"], ["proof (chain)\npicking this:\n  tree_edges s \\<subseteq> E\n  path (tree_edges s) x p y", "have \"path E x p y\""], ["proof (prove)\nusing this:\n  tree_edges s \\<subseteq> E\n  path (tree_edges s) x p y\n\ngoal (1 subgoal):\n 1. path E x p y", "using path_mono[where E=\"tree_edges s\"]"], ["proof (prove)\nusing this:\n  tree_edges s \\<subseteq> E\n  path (tree_edges s) x p y\n  \\<lbrakk>tree_edges s \\<subseteq> ?E';\n   path (tree_edges s) ?u ?p ?v\\<rbrakk>\n  \\<Longrightarrow> path ?E' ?u ?p ?v\n\ngoal (1 subgoal):\n 1. path E x p y", "by simp"], ["proof (state)\nthis:\n  path E x p y\n\ngoal (2 subgoals):\n 1. white_path s x y \\<Longrightarrow> (x, y) \\<in> (tree_edges s)\\<^sup>*\n 2. (x, y) \\<in> (tree_edges s)\\<^sup>* \\<Longrightarrow> white_path s x y", "moreover"], ["proof (state)\nthis:\n  path E x p y\n\ngoal (2 subgoals):\n 1. white_path s x y \\<Longrightarrow> (x, y) \\<in> (tree_edges s)\\<^sup>*\n 2. (x, y) \\<in> (tree_edges s)\\<^sup>* \\<Longrightarrow> white_path s x y", "from P"], ["proof (chain)\npicking this:\n  path (tree_edges s) x p y", "have \"\\<delta> s x < \\<delta> s y \\<and> (\\<forall> v \\<in> set (tl p). \\<delta> s x < \\<delta> s v)\""], ["proof (prove)\nusing this:\n  path (tree_edges s) x p y\n\ngoal (1 subgoal):\n 1. \\<delta> s x < \\<delta> s y \\<and>\n    (\\<forall>v\\<in>set (tl p). \\<delta> s x < \\<delta> s v)", "using \\<open>x\\<noteq>y\\<close>"], ["proof (prove)\nusing this:\n  path (tree_edges s) x p y\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. \\<delta> s x < \\<delta> s y \\<and>\n    (\\<forall>v\\<in>set (tl p). \\<delta> s x < \\<delta> s v)", "proof (induct rule: path_tl_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>u.\n       (x, u) \\<in> tree_edges s \\<Longrightarrow>\n       \\<delta> s x < \\<delta> s u\n 2. \\<And>u v.\n       \\<lbrakk>(x, u) \\<in> (tree_edges s)\\<^sup>+;\n        (u, v) \\<in> tree_edges s; \\<delta> s x < \\<delta> s u\\<rbrakk>\n       \\<Longrightarrow> \\<delta> s x < \\<delta> s v", "case (single u)"], ["proof (state)\nthis:\n  (x, u) \\<in> tree_edges s\n\ngoal (2 subgoals):\n 1. \\<And>u.\n       (x, u) \\<in> tree_edges s \\<Longrightarrow>\n       \\<delta> s x < \\<delta> s u\n 2. \\<And>u v.\n       \\<lbrakk>(x, u) \\<in> (tree_edges s)\\<^sup>+;\n        (u, v) \\<in> tree_edges s; \\<delta> s x < \\<delta> s u\\<rbrakk>\n       \\<Longrightarrow> \\<delta> s x < \\<delta> s v", "thus ?case"], ["proof (prove)\nusing this:\n  (x, u) \\<in> tree_edges s\n\ngoal (1 subgoal):\n 1. \\<delta> s x < \\<delta> s u", "by (fact tree_edge_disc)"], ["proof (state)\nthis:\n  \\<delta> s x < \\<delta> s u\n\ngoal (1 subgoal):\n 1. \\<And>u v.\n       \\<lbrakk>(x, u) \\<in> (tree_edges s)\\<^sup>+;\n        (u, v) \\<in> tree_edges s; \\<delta> s x < \\<delta> s u\\<rbrakk>\n       \\<Longrightarrow> \\<delta> s x < \\<delta> s v", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>u v.\n       \\<lbrakk>(x, u) \\<in> (tree_edges s)\\<^sup>+;\n        (u, v) \\<in> tree_edges s; \\<delta> s x < \\<delta> s u\\<rbrakk>\n       \\<Longrightarrow> \\<delta> s x < \\<delta> s v", "case (step u v)"], ["proof (state)\nthis:\n  (x, u) \\<in> (tree_edges s)\\<^sup>+\n  (u, v) \\<in> tree_edges s\n  \\<delta> s x < \\<delta> s u\n\ngoal (1 subgoal):\n 1. \\<And>u v.\n       \\<lbrakk>(x, u) \\<in> (tree_edges s)\\<^sup>+;\n        (u, v) \\<in> tree_edges s; \\<delta> s x < \\<delta> s u\\<rbrakk>\n       \\<Longrightarrow> \\<delta> s x < \\<delta> s v", "note \\<open>\\<delta> s x < \\<delta> s u\\<close>"], ["proof (state)\nthis:\n  \\<delta> s x < \\<delta> s u\n\ngoal (1 subgoal):\n 1. \\<And>u v.\n       \\<lbrakk>(x, u) \\<in> (tree_edges s)\\<^sup>+;\n        (u, v) \\<in> tree_edges s; \\<delta> s x < \\<delta> s u\\<rbrakk>\n       \\<Longrightarrow> \\<delta> s x < \\<delta> s v", "also"], ["proof (state)\nthis:\n  \\<delta> s x < \\<delta> s u\n\ngoal (1 subgoal):\n 1. \\<And>u v.\n       \\<lbrakk>(x, u) \\<in> (tree_edges s)\\<^sup>+;\n        (u, v) \\<in> tree_edges s; \\<delta> s x < \\<delta> s u\\<rbrakk>\n       \\<Longrightarrow> \\<delta> s x < \\<delta> s v", "from step"], ["proof (chain)\npicking this:\n  (x, u) \\<in> (tree_edges s)\\<^sup>+\n  (u, v) \\<in> tree_edges s\n  \\<delta> s x < \\<delta> s u", "have \"\\<delta> s u < \\<delta> s v\""], ["proof (prove)\nusing this:\n  (x, u) \\<in> (tree_edges s)\\<^sup>+\n  (u, v) \\<in> tree_edges s\n  \\<delta> s x < \\<delta> s u\n\ngoal (1 subgoal):\n 1. \\<delta> s u < \\<delta> s v", "by (metis tree_edge_disc)"], ["proof (state)\nthis:\n  \\<delta> s u < \\<delta> s v\n\ngoal (1 subgoal):\n 1. \\<And>u v.\n       \\<lbrakk>(x, u) \\<in> (tree_edges s)\\<^sup>+;\n        (u, v) \\<in> tree_edges s; \\<delta> s x < \\<delta> s u\\<rbrakk>\n       \\<Longrightarrow> \\<delta> s x < \\<delta> s v", "finally"], ["proof (chain)\npicking this:\n  \\<delta> s x < \\<delta> s v", "show ?case"], ["proof (prove)\nusing this:\n  \\<delta> s x < \\<delta> s v\n\ngoal (1 subgoal):\n 1. \\<delta> s x < \\<delta> s v", "."], ["proof (state)\nthis:\n  \\<delta> s x < \\<delta> s v\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<delta> s x < \\<delta> s y \\<and>\n  (\\<forall>v\\<in>set (tl p). \\<delta> s x < \\<delta> s v)\n\ngoal (2 subgoals):\n 1. white_path s x y \\<Longrightarrow> (x, y) \\<in> (tree_edges s)\\<^sup>*\n 2. (x, y) \\<in> (tree_edges s)\\<^sup>* \\<Longrightarrow> white_path s x y", "ultimately"], ["proof (chain)\npicking this:\n  path E x p y\n  \\<delta> s x < \\<delta> s y \\<and>\n  (\\<forall>v\\<in>set (tl p). \\<delta> s x < \\<delta> s v)", "show \"white_path s x y\""], ["proof (prove)\nusing this:\n  path E x p y\n  \\<delta> s x < \\<delta> s y \\<and>\n  (\\<forall>v\\<in>set (tl p). \\<delta> s x < \\<delta> s v)\n\ngoal (1 subgoal):\n 1. white_path s x y", "by (auto simp add: \\<open>x\\<noteq>y\\<close> white_path_def)"], ["proof (state)\nthis:\n  white_path s x y\n\ngoal (1 subgoal):\n 1. white_path s x y \\<Longrightarrow> (x, y) \\<in> (tree_edges s)\\<^sup>*", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. white_path s x y \\<Longrightarrow> (x, y) \\<in> (tree_edges s)\\<^sup>*", "assume \"white_path s x y\""], ["proof (state)\nthis:\n  white_path s x y\n\ngoal (1 subgoal):\n 1. white_path s x y \\<Longrightarrow> (x, y) \\<in> (tree_edges s)\\<^sup>*", "with \\<open>x\\<noteq>y\\<close>"], ["proof (chain)\npicking this:\n  x \\<noteq> y\n  white_path s x y", "obtain p where \n            P:\"path E x p y\" and\n            white: \"\\<delta> s x < \\<delta> s y \\<and> (\\<forall> v \\<in> set (tl p). \\<delta> s x < \\<delta> s v)\""], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  white_path s x y\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>path E x p y;\n         \\<delta> s x < \\<delta> s y \\<and>\n         (\\<forall>v\\<in>set (tl p). \\<delta> s x < \\<delta> s v)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding white_path_def"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  x \\<noteq> y \\<longrightarrow>\n  (\\<exists>p.\n      path E x p y \\<and>\n      \\<delta> s x < \\<delta> s y \\<and>\n      (\\<forall>v\\<in>set (tl p). \\<delta> s x < \\<delta> s v))\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>path E x p y;\n         \\<delta> s x < \\<delta> s y \\<and>\n         (\\<forall>v\\<in>set (tl p). \\<delta> s x < \\<delta> s v)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  path E x p y\n  \\<delta> s x < \\<delta> s y \\<and>\n  (\\<forall>v\\<in>set (tl p). \\<delta> s x < \\<delta> s v)\n\ngoal (1 subgoal):\n 1. white_path s x y \\<Longrightarrow> (x, y) \\<in> (tree_edges s)\\<^sup>*", "hence \"p \\<noteq> []\""], ["proof (prove)\nusing this:\n  path E x p y\n  \\<delta> s x < \\<delta> s y \\<and>\n  (\\<forall>v\\<in>set (tl p). \\<delta> s x < \\<delta> s v)\n\ngoal (1 subgoal):\n 1. p \\<noteq> []", "by auto"], ["proof (state)\nthis:\n  p \\<noteq> []\n\ngoal (1 subgoal):\n 1. white_path s x y \\<Longrightarrow> (x, y) \\<in> (tree_edges s)\\<^sup>*", "thus \"(x,y) \\<in> (tree_edges s)\\<^sup>*\""], ["proof (prove)\nusing this:\n  p \\<noteq> []\n\ngoal (1 subgoal):\n 1. (x, y) \\<in> (tree_edges s)\\<^sup>*", "using P white reach(2)"], ["proof (prove)\nusing this:\n  p \\<noteq> []\n  path E x p y\n  \\<delta> s x < \\<delta> s y \\<and>\n  (\\<forall>v\\<in>set (tl p). \\<delta> s x < \\<delta> s v)\n  y \\<in> reachable\n\ngoal (1 subgoal):\n 1. (x, y) \\<in> (tree_edges s)\\<^sup>*", "proof (induction p arbitrary: y rule: rev_nonempty_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xa y.\n       \\<lbrakk>path E x [xa] y;\n        \\<delta> s x < \\<delta> s y \\<and>\n        (\\<forall>v\\<in>set (tl [xa]). \\<delta> s x < \\<delta> s v);\n        y \\<in> reachable\\<rbrakk>\n       \\<Longrightarrow> (x, y) \\<in> (tree_edges s)\\<^sup>*\n 2. \\<And>xa xs y.\n       \\<lbrakk>xs \\<noteq> [];\n        \\<And>y.\n           \\<lbrakk>path E x xs y;\n            \\<delta> s x < \\<delta> s y \\<and>\n            (\\<forall>v\\<in>set (tl xs). \\<delta> s x < \\<delta> s v);\n            y \\<in> reachable\\<rbrakk>\n           \\<Longrightarrow> (x, y) \\<in> (tree_edges s)\\<^sup>*;\n        path E x (xs @ [xa]) y;\n        \\<delta> s x < \\<delta> s y \\<and>\n        (\\<forall>v\\<in>set (tl (xs @ [xa])). \\<delta> s x < \\<delta> s v);\n        y \\<in> reachable\\<rbrakk>\n       \\<Longrightarrow> (x, y) \\<in> (tree_edges s)\\<^sup>*", "case single"], ["proof (state)\nthis:\n  path E x [x_] y\n  \\<delta> s x < \\<delta> s y \\<and>\n  (\\<forall>v\\<in>set (tl [x_]). \\<delta> s x < \\<delta> s v)\n  y \\<in> reachable\n\ngoal (2 subgoals):\n 1. \\<And>xa y.\n       \\<lbrakk>path E x [xa] y;\n        \\<delta> s x < \\<delta> s y \\<and>\n        (\\<forall>v\\<in>set (tl [xa]). \\<delta> s x < \\<delta> s v);\n        y \\<in> reachable\\<rbrakk>\n       \\<Longrightarrow> (x, y) \\<in> (tree_edges s)\\<^sup>*\n 2. \\<And>xa xs y.\n       \\<lbrakk>xs \\<noteq> [];\n        \\<And>y.\n           \\<lbrakk>path E x xs y;\n            \\<delta> s x < \\<delta> s y \\<and>\n            (\\<forall>v\\<in>set (tl xs). \\<delta> s x < \\<delta> s v);\n            y \\<in> reachable\\<rbrakk>\n           \\<Longrightarrow> (x, y) \\<in> (tree_edges s)\\<^sup>*;\n        path E x (xs @ [xa]) y;\n        \\<delta> s x < \\<delta> s y \\<and>\n        (\\<forall>v\\<in>set (tl (xs @ [xa])). \\<delta> s x < \\<delta> s v);\n        y \\<in> reachable\\<rbrakk>\n       \\<Longrightarrow> (x, y) \\<in> (tree_edges s)\\<^sup>*", "hence \"y \\<in> succ x\""], ["proof (prove)\nusing this:\n  path E x [x_] y\n  \\<delta> s x < \\<delta> s y \\<and>\n  (\\<forall>v\\<in>set (tl [x_]). \\<delta> s x < \\<delta> s v)\n  y \\<in> reachable\n\ngoal (1 subgoal):\n 1. y \\<in> E `` {x}", "by (simp add: path_cons_conv)"], ["proof (state)\nthis:\n  y \\<in> E `` {x}\n\ngoal (2 subgoals):\n 1. \\<And>xa y.\n       \\<lbrakk>path E x [xa] y;\n        \\<delta> s x < \\<delta> s y \\<and>\n        (\\<forall>v\\<in>set (tl [xa]). \\<delta> s x < \\<delta> s v);\n        y \\<in> reachable\\<rbrakk>\n       \\<Longrightarrow> (x, y) \\<in> (tree_edges s)\\<^sup>*\n 2. \\<And>xa xs y.\n       \\<lbrakk>xs \\<noteq> [];\n        \\<And>y.\n           \\<lbrakk>path E x xs y;\n            \\<delta> s x < \\<delta> s y \\<and>\n            (\\<forall>v\\<in>set (tl xs). \\<delta> s x < \\<delta> s v);\n            y \\<in> reachable\\<rbrakk>\n           \\<Longrightarrow> (x, y) \\<in> (tree_edges s)\\<^sup>*;\n        path E x (xs @ [xa]) y;\n        \\<delta> s x < \\<delta> s y \\<and>\n        (\\<forall>v\\<in>set (tl (xs @ [xa])). \\<delta> s x < \\<delta> s v);\n        y \\<in> reachable\\<rbrakk>\n       \\<Longrightarrow> (x, y) \\<in> (tree_edges s)\\<^sup>*", "with reach single"], ["proof (chain)\npicking this:\n  x \\<in> reachable\n  y__ \\<in> reachable\n  path E x [x_] y\n  \\<delta> s x < \\<delta> s y \\<and>\n  (\\<forall>v\\<in>set (tl [x_]). \\<delta> s x < \\<delta> s v)\n  y \\<in> reachable\n  y \\<in> E `` {x}", "show ?case"], ["proof (prove)\nusing this:\n  x \\<in> reachable\n  y__ \\<in> reachable\n  path E x [x_] y\n  \\<delta> s x < \\<delta> s y \\<and>\n  (\\<forall>v\\<in>set (tl [x_]). \\<delta> s x < \\<delta> s v)\n  y \\<in> reachable\n  y \\<in> E `` {x}\n\ngoal (1 subgoal):\n 1. (x, y) \\<in> (tree_edges s)\\<^sup>*", "using fin_eq_reach finished_succ_impl_path_in_tree[of x y]"], ["proof (prove)\nusing this:\n  x \\<in> reachable\n  y__ \\<in> reachable\n  path E x [x_] y\n  \\<delta> s x < \\<delta> s y \\<and>\n  (\\<forall>v\\<in>set (tl [x_]). \\<delta> s x < \\<delta> s v)\n  y \\<in> reachable\n  y \\<in> E `` {x}\n  dom (finished s) = reachable\n  \\<lbrakk>x \\<in> dom (finished s); y \\<in> E `` {x};\n   \\<delta> s x < \\<delta> s y\\<rbrakk>\n  \\<Longrightarrow> (x, y) \\<in> (tree_edges s)\\<^sup>+\n\ngoal (1 subgoal):\n 1. (x, y) \\<in> (tree_edges s)\\<^sup>*", "by simp"], ["proof (state)\nthis:\n  (x, y) \\<in> (tree_edges s)\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<And>xa xs y.\n       \\<lbrakk>xs \\<noteq> [];\n        \\<And>y.\n           \\<lbrakk>path E x xs y;\n            \\<delta> s x < \\<delta> s y \\<and>\n            (\\<forall>v\\<in>set (tl xs). \\<delta> s x < \\<delta> s v);\n            y \\<in> reachable\\<rbrakk>\n           \\<Longrightarrow> (x, y) \\<in> (tree_edges s)\\<^sup>*;\n        path E x (xs @ [xa]) y;\n        \\<delta> s x < \\<delta> s y \\<and>\n        (\\<forall>v\\<in>set (tl (xs @ [xa])). \\<delta> s x < \\<delta> s v);\n        y \\<in> reachable\\<rbrakk>\n       \\<Longrightarrow> (x, y) \\<in> (tree_edges s)\\<^sup>*", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa xs y.\n       \\<lbrakk>xs \\<noteq> [];\n        \\<And>y.\n           \\<lbrakk>path E x xs y;\n            \\<delta> s x < \\<delta> s y \\<and>\n            (\\<forall>v\\<in>set (tl xs). \\<delta> s x < \\<delta> s v);\n            y \\<in> reachable\\<rbrakk>\n           \\<Longrightarrow> (x, y) \\<in> (tree_edges s)\\<^sup>*;\n        path E x (xs @ [xa]) y;\n        \\<delta> s x < \\<delta> s y \\<and>\n        (\\<forall>v\\<in>set (tl (xs @ [xa])). \\<delta> s x < \\<delta> s v);\n        y \\<in> reachable\\<rbrakk>\n       \\<Longrightarrow> (x, y) \\<in> (tree_edges s)\\<^sup>*", "case (snoc u us)"], ["proof (state)\nthis:\n  us \\<noteq> []\n  \\<lbrakk>path E x us ?y8;\n   \\<delta> s x < \\<delta> s ?y8 \\<and>\n   (\\<forall>v\\<in>set (tl us). \\<delta> s x < \\<delta> s v);\n   ?y8 \\<in> reachable\\<rbrakk>\n  \\<Longrightarrow> (x, ?y8) \\<in> (tree_edges s)\\<^sup>*\n  path E x (us @ [u]) y\n  \\<delta> s x < \\<delta> s y \\<and>\n  (\\<forall>v\\<in>set (tl (us @ [u])). \\<delta> s x < \\<delta> s v)\n  y \\<in> reachable\n\ngoal (1 subgoal):\n 1. \\<And>xa xs y.\n       \\<lbrakk>xs \\<noteq> [];\n        \\<And>y.\n           \\<lbrakk>path E x xs y;\n            \\<delta> s x < \\<delta> s y \\<and>\n            (\\<forall>v\\<in>set (tl xs). \\<delta> s x < \\<delta> s v);\n            y \\<in> reachable\\<rbrakk>\n           \\<Longrightarrow> (x, y) \\<in> (tree_edges s)\\<^sup>*;\n        path E x (xs @ [xa]) y;\n        \\<delta> s x < \\<delta> s y \\<and>\n        (\\<forall>v\\<in>set (tl (xs @ [xa])). \\<delta> s x < \\<delta> s v);\n        y \\<in> reachable\\<rbrakk>\n       \\<Longrightarrow> (x, y) \\<in> (tree_edges s)\\<^sup>*", "hence \"path E x us u\""], ["proof (prove)\nusing this:\n  us \\<noteq> []\n  \\<lbrakk>path E x us ?y8;\n   \\<delta> s x < \\<delta> s ?y8 \\<and>\n   (\\<forall>v\\<in>set (tl us). \\<delta> s x < \\<delta> s v);\n   ?y8 \\<in> reachable\\<rbrakk>\n  \\<Longrightarrow> (x, ?y8) \\<in> (tree_edges s)\\<^sup>*\n  path E x (us @ [u]) y\n  \\<delta> s x < \\<delta> s y \\<and>\n  (\\<forall>v\\<in>set (tl (us @ [u])). \\<delta> s x < \\<delta> s v)\n  y \\<in> reachable\n\ngoal (1 subgoal):\n 1. path E x us u", "by (simp add: path_append_conv)"], ["proof (state)\nthis:\n  path E x us u\n\ngoal (1 subgoal):\n 1. \\<And>xa xs y.\n       \\<lbrakk>xs \\<noteq> [];\n        \\<And>y.\n           \\<lbrakk>path E x xs y;\n            \\<delta> s x < \\<delta> s y \\<and>\n            (\\<forall>v\\<in>set (tl xs). \\<delta> s x < \\<delta> s v);\n            y \\<in> reachable\\<rbrakk>\n           \\<Longrightarrow> (x, y) \\<in> (tree_edges s)\\<^sup>*;\n        path E x (xs @ [xa]) y;\n        \\<delta> s x < \\<delta> s y \\<and>\n        (\\<forall>v\\<in>set (tl (xs @ [xa])). \\<delta> s x < \\<delta> s v);\n        y \\<in> reachable\\<rbrakk>\n       \\<Longrightarrow> (x, y) \\<in> (tree_edges s)\\<^sup>*", "moreover"], ["proof (state)\nthis:\n  path E x us u\n\ngoal (1 subgoal):\n 1. \\<And>xa xs y.\n       \\<lbrakk>xs \\<noteq> [];\n        \\<And>y.\n           \\<lbrakk>path E x xs y;\n            \\<delta> s x < \\<delta> s y \\<and>\n            (\\<forall>v\\<in>set (tl xs). \\<delta> s x < \\<delta> s v);\n            y \\<in> reachable\\<rbrakk>\n           \\<Longrightarrow> (x, y) \\<in> (tree_edges s)\\<^sup>*;\n        path E x (xs @ [xa]) y;\n        \\<delta> s x < \\<delta> s y \\<and>\n        (\\<forall>v\\<in>set (tl (xs @ [xa])). \\<delta> s x < \\<delta> s v);\n        y \\<in> reachable\\<rbrakk>\n       \\<Longrightarrow> (x, y) \\<in> (tree_edges s)\\<^sup>*", "hence \"(x,u) \\<in> E\\<^sup>*\""], ["proof (prove)\nusing this:\n  path E x us u\n\ngoal (1 subgoal):\n 1. (x, u) \\<in> E\\<^sup>*", "by (simp add: path_is_rtrancl)"], ["proof (state)\nthis:\n  (x, u) \\<in> E\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<And>xa xs y.\n       \\<lbrakk>xs \\<noteq> [];\n        \\<And>y.\n           \\<lbrakk>path E x xs y;\n            \\<delta> s x < \\<delta> s y \\<and>\n            (\\<forall>v\\<in>set (tl xs). \\<delta> s x < \\<delta> s v);\n            y \\<in> reachable\\<rbrakk>\n           \\<Longrightarrow> (x, y) \\<in> (tree_edges s)\\<^sup>*;\n        path E x (xs @ [xa]) y;\n        \\<delta> s x < \\<delta> s y \\<and>\n        (\\<forall>v\\<in>set (tl (xs @ [xa])). \\<delta> s x < \\<delta> s v);\n        y \\<in> reachable\\<rbrakk>\n       \\<Longrightarrow> (x, y) \\<in> (tree_edges s)\\<^sup>*", "with reach"], ["proof (chain)\npicking this:\n  x \\<in> reachable\n  y__ \\<in> reachable\n  (x, u) \\<in> E\\<^sup>*", "have ureach: \"u \\<in> reachable\""], ["proof (prove)\nusing this:\n  x \\<in> reachable\n  y__ \\<in> reachable\n  (x, u) \\<in> E\\<^sup>*\n\ngoal (1 subgoal):\n 1. u \\<in> reachable", "by (metis rtrancl_image_advance_rtrancl)"], ["proof (state)\nthis:\n  u \\<in> reachable\n\ngoal (1 subgoal):\n 1. \\<And>xa xs y.\n       \\<lbrakk>xs \\<noteq> [];\n        \\<And>y.\n           \\<lbrakk>path E x xs y;\n            \\<delta> s x < \\<delta> s y \\<and>\n            (\\<forall>v\\<in>set (tl xs). \\<delta> s x < \\<delta> s v);\n            y \\<in> reachable\\<rbrakk>\n           \\<Longrightarrow> (x, y) \\<in> (tree_edges s)\\<^sup>*;\n        path E x (xs @ [xa]) y;\n        \\<delta> s x < \\<delta> s y \\<and>\n        (\\<forall>v\\<in>set (tl (xs @ [xa])). \\<delta> s x < \\<delta> s v);\n        y \\<in> reachable\\<rbrakk>\n       \\<Longrightarrow> (x, y) \\<in> (tree_edges s)\\<^sup>*", "moreover"], ["proof (state)\nthis:\n  u \\<in> reachable\n\ngoal (1 subgoal):\n 1. \\<And>xa xs y.\n       \\<lbrakk>xs \\<noteq> [];\n        \\<And>y.\n           \\<lbrakk>path E x xs y;\n            \\<delta> s x < \\<delta> s y \\<and>\n            (\\<forall>v\\<in>set (tl xs). \\<delta> s x < \\<delta> s v);\n            y \\<in> reachable\\<rbrakk>\n           \\<Longrightarrow> (x, y) \\<in> (tree_edges s)\\<^sup>*;\n        path E x (xs @ [xa]) y;\n        \\<delta> s x < \\<delta> s y \\<and>\n        (\\<forall>v\\<in>set (tl (xs @ [xa])). \\<delta> s x < \\<delta> s v);\n        y \\<in> reachable\\<rbrakk>\n       \\<Longrightarrow> (x, y) \\<in> (tree_edges s)\\<^sup>*", "from snoc"], ["proof (chain)\npicking this:\n  us \\<noteq> []\n  \\<lbrakk>path E x us ?y8;\n   \\<delta> s x < \\<delta> s ?y8 \\<and>\n   (\\<forall>v\\<in>set (tl us). \\<delta> s x < \\<delta> s v);\n   ?y8 \\<in> reachable\\<rbrakk>\n  \\<Longrightarrow> (x, ?y8) \\<in> (tree_edges s)\\<^sup>*\n  path E x (us @ [u]) y\n  \\<delta> s x < \\<delta> s y \\<and>\n  (\\<forall>v\\<in>set (tl (us @ [u])). \\<delta> s x < \\<delta> s v)\n  y \\<in> reachable", "have \"\\<delta> s x < \\<delta> s u\" \"(\\<forall>v\\<in>set (tl us). \\<delta> s x < \\<delta> s v)\""], ["proof (prove)\nusing this:\n  us \\<noteq> []\n  \\<lbrakk>path E x us ?y8;\n   \\<delta> s x < \\<delta> s ?y8 \\<and>\n   (\\<forall>v\\<in>set (tl us). \\<delta> s x < \\<delta> s v);\n   ?y8 \\<in> reachable\\<rbrakk>\n  \\<Longrightarrow> (x, ?y8) \\<in> (tree_edges s)\\<^sup>*\n  path E x (us @ [u]) y\n  \\<delta> s x < \\<delta> s y \\<and>\n  (\\<forall>v\\<in>set (tl (us @ [u])). \\<delta> s x < \\<delta> s v)\n  y \\<in> reachable\n\ngoal (1 subgoal):\n 1. \\<delta> s x < \\<delta> s u &&&\n    \\<forall>v\\<in>set (tl us). \\<delta> s x < \\<delta> s v", "by simp_all"], ["proof (state)\nthis:\n  \\<delta> s x < \\<delta> s u\n  \\<forall>v\\<in>set (tl us). \\<delta> s x < \\<delta> s v\n\ngoal (1 subgoal):\n 1. \\<And>xa xs y.\n       \\<lbrakk>xs \\<noteq> [];\n        \\<And>y.\n           \\<lbrakk>path E x xs y;\n            \\<delta> s x < \\<delta> s y \\<and>\n            (\\<forall>v\\<in>set (tl xs). \\<delta> s x < \\<delta> s v);\n            y \\<in> reachable\\<rbrakk>\n           \\<Longrightarrow> (x, y) \\<in> (tree_edges s)\\<^sup>*;\n        path E x (xs @ [xa]) y;\n        \\<delta> s x < \\<delta> s y \\<and>\n        (\\<forall>v\\<in>set (tl (xs @ [xa])). \\<delta> s x < \\<delta> s v);\n        y \\<in> reachable\\<rbrakk>\n       \\<Longrightarrow> (x, y) \\<in> (tree_edges s)\\<^sup>*", "ultimately"], ["proof (chain)\npicking this:\n  path E x us u\n  u \\<in> reachable\n  \\<delta> s x < \\<delta> s u\n  \\<forall>v\\<in>set (tl us). \\<delta> s x < \\<delta> s v", "have x_u: \"(x,u) \\<in> (tree_edges s)\\<^sup>*\""], ["proof (prove)\nusing this:\n  path E x us u\n  u \\<in> reachable\n  \\<delta> s x < \\<delta> s u\n  \\<forall>v\\<in>set (tl us). \\<delta> s x < \\<delta> s v\n\ngoal (1 subgoal):\n 1. (x, u) \\<in> (tree_edges s)\\<^sup>*", "by (metis snoc.IH)"], ["proof (state)\nthis:\n  (x, u) \\<in> (tree_edges s)\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<And>xa xs y.\n       \\<lbrakk>xs \\<noteq> [];\n        \\<And>y.\n           \\<lbrakk>path E x xs y;\n            \\<delta> s x < \\<delta> s y \\<and>\n            (\\<forall>v\\<in>set (tl xs). \\<delta> s x < \\<delta> s v);\n            y \\<in> reachable\\<rbrakk>\n           \\<Longrightarrow> (x, y) \\<in> (tree_edges s)\\<^sup>*;\n        path E x (xs @ [xa]) y;\n        \\<delta> s x < \\<delta> s y \\<and>\n        (\\<forall>v\\<in>set (tl (xs @ [xa])). \\<delta> s x < \\<delta> s v);\n        y \\<in> reachable\\<rbrakk>\n       \\<Longrightarrow> (x, y) \\<in> (tree_edges s)\\<^sup>*", "from snoc"], ["proof (chain)\npicking this:\n  us \\<noteq> []\n  \\<lbrakk>path E x us ?y8;\n   \\<delta> s x < \\<delta> s ?y8 \\<and>\n   (\\<forall>v\\<in>set (tl us). \\<delta> s x < \\<delta> s v);\n   ?y8 \\<in> reachable\\<rbrakk>\n  \\<Longrightarrow> (x, ?y8) \\<in> (tree_edges s)\\<^sup>*\n  path E x (us @ [u]) y\n  \\<delta> s x < \\<delta> s y \\<and>\n  (\\<forall>v\\<in>set (tl (us @ [u])). \\<delta> s x < \\<delta> s v)\n  y \\<in> reachable", "have \"y \\<in> succ u\""], ["proof (prove)\nusing this:\n  us \\<noteq> []\n  \\<lbrakk>path E x us ?y8;\n   \\<delta> s x < \\<delta> s ?y8 \\<and>\n   (\\<forall>v\\<in>set (tl us). \\<delta> s x < \\<delta> s v);\n   ?y8 \\<in> reachable\\<rbrakk>\n  \\<Longrightarrow> (x, ?y8) \\<in> (tree_edges s)\\<^sup>*\n  path E x (us @ [u]) y\n  \\<delta> s x < \\<delta> s y \\<and>\n  (\\<forall>v\\<in>set (tl (us @ [u])). \\<delta> s x < \\<delta> s v)\n  y \\<in> reachable\n\ngoal (1 subgoal):\n 1. y \\<in> E `` {u}", "by (simp add: path_append_conv)"], ["proof (state)\nthis:\n  y \\<in> E `` {u}\n\ngoal (1 subgoal):\n 1. \\<And>xa xs y.\n       \\<lbrakk>xs \\<noteq> [];\n        \\<And>y.\n           \\<lbrakk>path E x xs y;\n            \\<delta> s x < \\<delta> s y \\<and>\n            (\\<forall>v\\<in>set (tl xs). \\<delta> s x < \\<delta> s v);\n            y \\<in> reachable\\<rbrakk>\n           \\<Longrightarrow> (x, y) \\<in> (tree_edges s)\\<^sup>*;\n        path E x (xs @ [xa]) y;\n        \\<delta> s x < \\<delta> s y \\<and>\n        (\\<forall>v\\<in>set (tl (xs @ [xa])). \\<delta> s x < \\<delta> s v);\n        y \\<in> reachable\\<rbrakk>\n       \\<Longrightarrow> (x, y) \\<in> (tree_edges s)\\<^sup>*", "from snoc(5) fin_eq_reach finished_discovered"], ["proof (chain)\npicking this:\n  y \\<in> reachable\n  dom (finished s) = reachable\n  dom (finished s) \\<subseteq> dom (discovered s)", "have \n            y_f_d: \"y \\<in> dom (finished s)\" \"y \\<in> dom (discovered s)\""], ["proof (prove)\nusing this:\n  y \\<in> reachable\n  dom (finished s) = reachable\n  dom (finished s) \\<subseteq> dom (discovered s)\n\ngoal (1 subgoal):\n 1. y \\<in> dom (finished s) &&& y \\<in> dom (discovered s)", "by auto"], ["proof (state)\nthis:\n  y \\<in> dom (finished s)\n  y \\<in> dom (discovered s)\n\ngoal (1 subgoal):\n 1. \\<And>xa xs y.\n       \\<lbrakk>xs \\<noteq> [];\n        \\<And>y.\n           \\<lbrakk>path E x xs y;\n            \\<delta> s x < \\<delta> s y \\<and>\n            (\\<forall>v\\<in>set (tl xs). \\<delta> s x < \\<delta> s v);\n            y \\<in> reachable\\<rbrakk>\n           \\<Longrightarrow> (x, y) \\<in> (tree_edges s)\\<^sup>*;\n        path E x (xs @ [xa]) y;\n        \\<delta> s x < \\<delta> s y \\<and>\n        (\\<forall>v\\<in>set (tl (xs @ [xa])). \\<delta> s x < \\<delta> s v);\n        y \\<in> reachable\\<rbrakk>\n       \\<Longrightarrow> (x, y) \\<in> (tree_edges s)\\<^sup>*", "from \\<open>y \\<in> succ u\\<close> ureach fin_eq_reach"], ["proof (chain)\npicking this:\n  y \\<in> E `` {u}\n  u \\<in> reachable\n  dom (finished s) = reachable", "have \"\\<delta> s y < \\<phi> s u\""], ["proof (prove)\nusing this:\n  y \\<in> E `` {u}\n  u \\<in> reachable\n  dom (finished s) = reachable\n\ngoal (1 subgoal):\n 1. \\<delta> s y < \\<phi> s u", "using finished_succ_fin"], ["proof (prove)\nusing this:\n  y \\<in> E `` {u}\n  u \\<in> reachable\n  dom (finished s) = reachable\n  \\<lbrakk>?v \\<in> dom (finished s); ?w \\<in> E `` {?v}\\<rbrakk>\n  \\<Longrightarrow> \\<delta> s ?w < \\<phi> s ?v\n\ngoal (1 subgoal):\n 1. \\<delta> s y < \\<phi> s u", "by simp"], ["proof (state)\nthis:\n  \\<delta> s y < \\<phi> s u\n\ngoal (1 subgoal):\n 1. \\<And>xa xs y.\n       \\<lbrakk>xs \\<noteq> [];\n        \\<And>y.\n           \\<lbrakk>path E x xs y;\n            \\<delta> s x < \\<delta> s y \\<and>\n            (\\<forall>v\\<in>set (tl xs). \\<delta> s x < \\<delta> s v);\n            y \\<in> reachable\\<rbrakk>\n           \\<Longrightarrow> (x, y) \\<in> (tree_edges s)\\<^sup>*;\n        path E x (xs @ [xa]) y;\n        \\<delta> s x < \\<delta> s y \\<and>\n        (\\<forall>v\\<in>set (tl (xs @ [xa])). \\<delta> s x < \\<delta> s v);\n        y \\<in> reachable\\<rbrakk>\n       \\<Longrightarrow> (x, y) \\<in> (tree_edges s)\\<^sup>*", "also"], ["proof (state)\nthis:\n  \\<delta> s y < \\<phi> s u\n\ngoal (1 subgoal):\n 1. \\<And>xa xs y.\n       \\<lbrakk>xs \\<noteq> [];\n        \\<And>y.\n           \\<lbrakk>path E x xs y;\n            \\<delta> s x < \\<delta> s y \\<and>\n            (\\<forall>v\\<in>set (tl xs). \\<delta> s x < \\<delta> s v);\n            y \\<in> reachable\\<rbrakk>\n           \\<Longrightarrow> (x, y) \\<in> (tree_edges s)\\<^sup>*;\n        path E x (xs @ [xa]) y;\n        \\<delta> s x < \\<delta> s y \\<and>\n        (\\<forall>v\\<in>set (tl (xs @ [xa])). \\<delta> s x < \\<delta> s v);\n        y \\<in> reachable\\<rbrakk>\n       \\<Longrightarrow> (x, y) \\<in> (tree_edges s)\\<^sup>*", "from \\<open>\\<delta> s x < \\<delta> s u\\<close>"], ["proof (chain)\npicking this:\n  \\<delta> s x < \\<delta> s u", "have \"x \\<noteq> u\""], ["proof (prove)\nusing this:\n  \\<delta> s x < \\<delta> s u\n\ngoal (1 subgoal):\n 1. x \\<noteq> u", "by auto"], ["proof (state)\nthis:\n  x \\<noteq> u\n\ngoal (1 subgoal):\n 1. \\<And>xa xs y.\n       \\<lbrakk>xs \\<noteq> [];\n        \\<And>y.\n           \\<lbrakk>path E x xs y;\n            \\<delta> s x < \\<delta> s y \\<and>\n            (\\<forall>v\\<in>set (tl xs). \\<delta> s x < \\<delta> s v);\n            y \\<in> reachable\\<rbrakk>\n           \\<Longrightarrow> (x, y) \\<in> (tree_edges s)\\<^sup>*;\n        path E x (xs @ [xa]) y;\n        \\<delta> s x < \\<delta> s y \\<and>\n        (\\<forall>v\\<in>set (tl (xs @ [xa])). \\<delta> s x < \\<delta> s v);\n        y \\<in> reachable\\<rbrakk>\n       \\<Longrightarrow> (x, y) \\<in> (tree_edges s)\\<^sup>*", "with x_u"], ["proof (chain)\npicking this:\n  (x, u) \\<in> (tree_edges s)\\<^sup>*\n  x \\<noteq> u", "have \"(x,u) \\<in> (tree_edges s)\\<^sup>+\""], ["proof (prove)\nusing this:\n  (x, u) \\<in> (tree_edges s)\\<^sup>*\n  x \\<noteq> u\n\ngoal (1 subgoal):\n 1. (x, u) \\<in> (tree_edges s)\\<^sup>+", "by (metis rtrancl_eq_or_trancl)"], ["proof (state)\nthis:\n  (x, u) \\<in> (tree_edges s)\\<^sup>+\n\ngoal (1 subgoal):\n 1. \\<And>xa xs y.\n       \\<lbrakk>xs \\<noteq> [];\n        \\<And>y.\n           \\<lbrakk>path E x xs y;\n            \\<delta> s x < \\<delta> s y \\<and>\n            (\\<forall>v\\<in>set (tl xs). \\<delta> s x < \\<delta> s v);\n            y \\<in> reachable\\<rbrakk>\n           \\<Longrightarrow> (x, y) \\<in> (tree_edges s)\\<^sup>*;\n        path E x (xs @ [xa]) y;\n        \\<delta> s x < \\<delta> s y \\<and>\n        (\\<forall>v\\<in>set (tl (xs @ [xa])). \\<delta> s x < \\<delta> s v);\n        y \\<in> reachable\\<rbrakk>\n       \\<Longrightarrow> (x, y) \\<in> (tree_edges s)\\<^sup>*", "with fin_eq_reach reach"], ["proof (chain)\npicking this:\n  dom (finished s) = reachable\n  x \\<in> reachable\n  y__ \\<in> reachable\n  (x, u) \\<in> (tree_edges s)\\<^sup>+", "have \"\\<phi> s u < \\<phi> s x\""], ["proof (prove)\nusing this:\n  dom (finished s) = reachable\n  x \\<in> reachable\n  y__ \\<in> reachable\n  (x, u) \\<in> (tree_edges s)\\<^sup>+\n\ngoal (1 subgoal):\n 1. \\<phi> s u < \\<phi> s x", "using tree_path_impl_parenthesis"], ["proof (prove)\nusing this:\n  dom (finished s) = reachable\n  x \\<in> reachable\n  y__ \\<in> reachable\n  (x, u) \\<in> (tree_edges s)\\<^sup>+\n  \\<lbrakk>(?v, ?w) \\<in> (tree_edges s)\\<^sup>+;\n   ?v \\<in> dom (finished s)\\<rbrakk>\n  \\<Longrightarrow> ?w \\<in> dom (finished s) \\<and>\n                    \\<delta> s ?v < \\<delta> s ?w \\<and>\n                    \\<phi> s ?w < \\<phi> s ?v\n\ngoal (1 subgoal):\n 1. \\<phi> s u < \\<phi> s x", "by simp"], ["proof (state)\nthis:\n  \\<phi> s u < \\<phi> s x\n\ngoal (1 subgoal):\n 1. \\<And>xa xs y.\n       \\<lbrakk>xs \\<noteq> [];\n        \\<And>y.\n           \\<lbrakk>path E x xs y;\n            \\<delta> s x < \\<delta> s y \\<and>\n            (\\<forall>v\\<in>set (tl xs). \\<delta> s x < \\<delta> s v);\n            y \\<in> reachable\\<rbrakk>\n           \\<Longrightarrow> (x, y) \\<in> (tree_edges s)\\<^sup>*;\n        path E x (xs @ [xa]) y;\n        \\<delta> s x < \\<delta> s y \\<and>\n        (\\<forall>v\\<in>set (tl (xs @ [xa])). \\<delta> s x < \\<delta> s v);\n        y \\<in> reachable\\<rbrakk>\n       \\<Longrightarrow> (x, y) \\<in> (tree_edges s)\\<^sup>*", "finally"], ["proof (chain)\npicking this:\n  \\<delta> s y < \\<phi> s x", "have \"\\<phi> s y < \\<phi> s x\""], ["proof (prove)\nusing this:\n  \\<delta> s y < \\<phi> s x\n\ngoal (1 subgoal):\n 1. \\<phi> s y < \\<phi> s x", "using reach fin_eq_reach y_f_d snoc"], ["proof (prove)\nusing this:\n  \\<delta> s y < \\<phi> s x\n  x \\<in> reachable\n  y__ \\<in> reachable\n  dom (finished s) = reachable\n  y \\<in> dom (finished s)\n  y \\<in> dom (discovered s)\n  us \\<noteq> []\n  \\<lbrakk>path E x us ?y8;\n   \\<delta> s x < \\<delta> s ?y8 \\<and>\n   (\\<forall>v\\<in>set (tl us). \\<delta> s x < \\<delta> s v);\n   ?y8 \\<in> reachable\\<rbrakk>\n  \\<Longrightarrow> (x, ?y8) \\<in> (tree_edges s)\\<^sup>*\n  path E x (us @ [u]) y\n  \\<delta> s x < \\<delta> s y \\<and>\n  (\\<forall>v\\<in>set (tl (us @ [u])). \\<delta> s x < \\<delta> s v)\n  y \\<in> reachable\n\ngoal (1 subgoal):\n 1. \\<phi> s y < \\<phi> s x", "using parenthesis_contained"], ["proof (prove)\nusing this:\n  \\<delta> s y < \\<phi> s x\n  x \\<in> reachable\n  y__ \\<in> reachable\n  dom (finished s) = reachable\n  y \\<in> dom (finished s)\n  y \\<in> dom (discovered s)\n  us \\<noteq> []\n  \\<lbrakk>path E x us ?y8;\n   \\<delta> s x < \\<delta> s ?y8 \\<and>\n   (\\<forall>v\\<in>set (tl us). \\<delta> s x < \\<delta> s v);\n   ?y8 \\<in> reachable\\<rbrakk>\n  \\<Longrightarrow> (x, ?y8) \\<in> (tree_edges s)\\<^sup>*\n  path E x (us @ [u]) y\n  \\<delta> s x < \\<delta> s y \\<and>\n  (\\<forall>v\\<in>set (tl (us @ [u])). \\<delta> s x < \\<delta> s v)\n  y \\<in> reachable\n  \\<lbrakk>?v \\<in> dom (finished s); ?w \\<in> dom (discovered s);\n   \\<delta> s ?v < \\<delta> s ?w; \\<delta> s ?w < \\<phi> s ?v\\<rbrakk>\n  \\<Longrightarrow> ?w \\<in> dom (finished s) \\<and>\n                    \\<phi> s ?w < \\<phi> s ?v\n\ngoal (1 subgoal):\n 1. \\<phi> s y < \\<phi> s x", "by blast"], ["proof (state)\nthis:\n  \\<phi> s y < \\<phi> s x\n\ngoal (1 subgoal):\n 1. \\<And>xa xs y.\n       \\<lbrakk>xs \\<noteq> [];\n        \\<And>y.\n           \\<lbrakk>path E x xs y;\n            \\<delta> s x < \\<delta> s y \\<and>\n            (\\<forall>v\\<in>set (tl xs). \\<delta> s x < \\<delta> s v);\n            y \\<in> reachable\\<rbrakk>\n           \\<Longrightarrow> (x, y) \\<in> (tree_edges s)\\<^sup>*;\n        path E x (xs @ [xa]) y;\n        \\<delta> s x < \\<delta> s y \\<and>\n        (\\<forall>v\\<in>set (tl (xs @ [xa])). \\<delta> s x < \\<delta> s v);\n        y \\<in> reachable\\<rbrakk>\n       \\<Longrightarrow> (x, y) \\<in> (tree_edges s)\\<^sup>*", "hence \"(x,y) \\<in> (tree_edges s)\\<^sup>+\""], ["proof (prove)\nusing this:\n  \\<phi> s y < \\<phi> s x\n\ngoal (1 subgoal):\n 1. (x, y) \\<in> (tree_edges s)\\<^sup>+", "using reach fin_eq_reach y_f_d snoc"], ["proof (prove)\nusing this:\n  \\<phi> s y < \\<phi> s x\n  x \\<in> reachable\n  y__ \\<in> reachable\n  dom (finished s) = reachable\n  y \\<in> dom (finished s)\n  y \\<in> dom (discovered s)\n  us \\<noteq> []\n  \\<lbrakk>path E x us ?y8;\n   \\<delta> s x < \\<delta> s ?y8 \\<and>\n   (\\<forall>v\\<in>set (tl us). \\<delta> s x < \\<delta> s v);\n   ?y8 \\<in> reachable\\<rbrakk>\n  \\<Longrightarrow> (x, ?y8) \\<in> (tree_edges s)\\<^sup>*\n  path E x (us @ [u]) y\n  \\<delta> s x < \\<delta> s y \\<and>\n  (\\<forall>v\\<in>set (tl (us @ [u])). \\<delta> s x < \\<delta> s v)\n  y \\<in> reachable\n\ngoal (1 subgoal):\n 1. (x, y) \\<in> (tree_edges s)\\<^sup>+", "using parenthesis_impl_tree_path"], ["proof (prove)\nusing this:\n  \\<phi> s y < \\<phi> s x\n  x \\<in> reachable\n  y__ \\<in> reachable\n  dom (finished s) = reachable\n  y \\<in> dom (finished s)\n  y \\<in> dom (discovered s)\n  us \\<noteq> []\n  \\<lbrakk>path E x us ?y8;\n   \\<delta> s x < \\<delta> s ?y8 \\<and>\n   (\\<forall>v\\<in>set (tl us). \\<delta> s x < \\<delta> s v);\n   ?y8 \\<in> reachable\\<rbrakk>\n  \\<Longrightarrow> (x, ?y8) \\<in> (tree_edges s)\\<^sup>*\n  path E x (us @ [u]) y\n  \\<delta> s x < \\<delta> s y \\<and>\n  (\\<forall>v\\<in>set (tl (us @ [u])). \\<delta> s x < \\<delta> s v)\n  y \\<in> reachable\n  \\<lbrakk>?v \\<in> dom (finished s); ?w \\<in> dom (finished s);\n   \\<delta> s ?v < \\<delta> s ?w; \\<phi> s ?w < \\<phi> s ?v\\<rbrakk>\n  \\<Longrightarrow> (?v, ?w) \\<in> (tree_edges s)\\<^sup>+\n\ngoal (1 subgoal):\n 1. (x, y) \\<in> (tree_edges s)\\<^sup>+", "by blast"], ["proof (state)\nthis:\n  (x, y) \\<in> (tree_edges s)\\<^sup>+\n\ngoal (1 subgoal):\n 1. \\<And>xa xs y.\n       \\<lbrakk>xs \\<noteq> [];\n        \\<And>y.\n           \\<lbrakk>path E x xs y;\n            \\<delta> s x < \\<delta> s y \\<and>\n            (\\<forall>v\\<in>set (tl xs). \\<delta> s x < \\<delta> s v);\n            y \\<in> reachable\\<rbrakk>\n           \\<Longrightarrow> (x, y) \\<in> (tree_edges s)\\<^sup>*;\n        path E x (xs @ [xa]) y;\n        \\<delta> s x < \\<delta> s y \\<and>\n        (\\<forall>v\\<in>set (tl (xs @ [xa])). \\<delta> s x < \\<delta> s v);\n        y \\<in> reachable\\<rbrakk>\n       \\<Longrightarrow> (x, y) \\<in> (tree_edges s)\\<^sup>*", "thus ?case"], ["proof (prove)\nusing this:\n  (x, y) \\<in> (tree_edges s)\\<^sup>+\n\ngoal (1 subgoal):\n 1. (x, y) \\<in> (tree_edges s)\\<^sup>*", "by auto"], ["proof (state)\nthis:\n  (x, y) \\<in> (tree_edges s)\\<^sup>*\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (x, y) \\<in> (tree_edges s)\\<^sup>*\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  white_path s x y = ((x, y) \\<in> (tree_edges s)\\<^sup>*)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  white_path s x y = ((x, y) \\<in> (tree_edges s)\\<^sup>*)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"], ["", "end"]]}