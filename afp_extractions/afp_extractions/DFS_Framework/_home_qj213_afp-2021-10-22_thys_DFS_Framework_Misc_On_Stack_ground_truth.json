{"file_name": "/home/qj213/afp-2021-10-22/thys/DFS_Framework/Misc/On_Stack.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/DFS_Framework", "problem_names": ["lemma stack_rel_def: \"\\<langle>vrel\\<rangle>stack_rel lrel srel \\<equiv> {\n  ((li,si),l). (li,l)\\<in>\\<langle>vrel\\<rangle>lrel \\<and> (si,set l)\\<in>\\<langle>vrel\\<rangle>srel \\<and> distinct l}\"", "lemmas [autoref_rel_intf] \n  = REL_INTFI[of \"stack_rel lrel srel\" i_list for lrel srel]", "lemma autoref_stack_empty[OF GEN_OP_D GEN_OP_D]:\n  assumes \"(el,[])\\<in>\\<langle>vrel\\<rangle>lrel\"\n  assumes \"(es,{})\\<in>\\<langle>vrel\\<rangle>srel\"\n  shows \"((el,es),[]) \\<in> \\<langle>vrel\\<rangle>stack_rel lrel srel\"", "lemma autoref_stack_push:\n  assumes \"GEN_OP push op_list_append_elem (\\<langle>vrel\\<rangle>lrel \\<rightarrow> vrel \\<rightarrow> \\<langle>vrel\\<rangle>lrel)\"\n  assumes \"GEN_OP ins insert (vrel \\<rightarrow> \\<langle>vrel\\<rangle>srel \\<rightarrow> \\<langle>vrel\\<rangle>srel)\"\n  assumes \"SIDE_PRECOND (v\\<notin>set l)\"\n  assumes \"(vi,v)\\<in>vrel\"\n  assumes \"(si,l)\\<in>\\<langle>vrel\\<rangle>stack_rel lrel srel\"\n  shows \"(stack_push push ins si vi,\n    (OP op_list_append_elem ::: \\<langle>vrel\\<rangle>stack_rel lrel srel \\<rightarrow> vrel \\<rightarrow> \\<langle>vrel\\<rangle>stack_rel lrel srel)\n      $l$v) \\<in> \\<langle>vrel\\<rangle>stack_rel lrel srel\"", "lemma autoref_stack_sng:\n  assumes \"GEN_OP lsng op_list_singleton (vrel \\<rightarrow> \\<langle>vrel\\<rangle>lrel)\"\n  assumes \"GEN_OP sins insert (vrel \\<rightarrow> \\<langle>vrel\\<rangle>srel \\<rightarrow> \\<langle>vrel\\<rangle>srel)\"\n  assumes \"GEN_OP semp {} (\\<langle>vrel\\<rangle>srel)\"\n  shows \"(\\<lambda>v. (lsng v, sins v semp),op_list_singleton) \n    \\<in> vrel \\<rightarrow> \\<langle>vrel\\<rangle>stack_rel lrel srel\"", "lemma autoref_stack_pop:\n  assumes POPR: \"\\<And>el l. \\<lbrakk> (el,l)\\<in>\\<langle>vrel\\<rangle>lrel; l\\<noteq>[] \\<rbrakk> \n    \\<Longrightarrow> (lpop el,(OP butlast ::: \\<langle>vrel\\<rangle>lrel \\<rightarrow> \\<langle>vrel\\<rangle>lrel)$l)\\<in> \\<langle>vrel\\<rangle>lrel\"\n  assumes TOPR: \"\\<And>el l. \\<lbrakk> (el,l)\\<in>\\<langle>vrel\\<rangle>lrel; l\\<noteq>[] \\<rbrakk> \n    \\<Longrightarrow> (ltop el,(OP last ::: \\<langle>vrel\\<rangle>lrel \\<rightarrow> vrel)$l)\\<in> vrel\"\n  assumes DELR: \"GEN_OP del op_set_delete (vrel \\<rightarrow> \\<langle>vrel\\<rangle>srel \\<rightarrow> \\<langle>vrel\\<rangle>srel)\"\n  assumes NE: \"SIDE_PRECOND (l \\<noteq> [])\"\n  assumes R: \"(si,l)\\<in>\\<langle>vrel\\<rangle>stack_rel lrel srel\"\n  shows \"(stack_pop lpop ltop del si,\n    (OP butlast ::: \\<langle>vrel\\<rangle>stack_rel lrel srel \\<rightarrow> \\<langle>vrel\\<rangle>stack_rel lrel srel)\n      $l) \\<in> \\<langle>vrel\\<rangle>stack_rel lrel srel\"", "lemma autoref_stack_set: \n  shows \"(snd, set) \\<in> \\<langle>vrel\\<rangle>stack_rel lrel srel \\<rightarrow> \\<langle>vrel\\<rangle>srel\"", "lemma autoref_stack_is_Nil: \n  assumes \"GEN_OP ini is_Nil (\\<langle>vrel\\<rangle>lrel \\<rightarrow> bool_rel)\"\n  shows \"(ini o fst, is_Nil) \\<in> \\<langle>vrel\\<rangle>stack_rel lrel srel \\<rightarrow> bool_rel\"", "lemma autoref_stack_ltop: \n  assumes TOPR: \"\\<And>el l. \\<lbrakk> (el,l)\\<in>\\<langle>vrel\\<rangle>lrel; l\\<noteq>[] \\<rbrakk> \n    \\<Longrightarrow> (ltop el,(OP last ::: \\<langle>vrel\\<rangle>lrel \\<rightarrow> vrel)$l)\\<in> vrel\"\n  assumes NE: \"SIDE_PRECOND (l \\<noteq> [])\"\n  assumes R: \"(si,l)\\<in>\\<langle>vrel\\<rangle>stack_rel lrel srel\"\n  shows \"(ltop (fst si), (OP last ::: \\<langle>vrel\\<rangle>stack_rel lrel srel \\<rightarrow> vrel)$l) \\<in> vrel\"", "lemmas stack_autoref_rules \n  = autoref_stack_empty autoref_stack_push autoref_stack_sng autoref_stack_pop\n    autoref_stack_set autoref_stack_is_Nil autoref_stack_ltop", "lemmas as_ahs_stack_rules \n  = stack_autoref_rules[where lrel = as_rel and srel = dflt_ahs_rel]"], "translations": [["", "lemma stack_rel_def: \"\\<langle>vrel\\<rangle>stack_rel lrel srel \\<equiv> {\n  ((li,si),l). (li,l)\\<in>\\<langle>vrel\\<rangle>lrel \\<and> (si,set l)\\<in>\\<langle>vrel\\<rangle>srel \\<and> distinct l}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>vrel\\<rangle>stack_rel lrel srel \\<equiv>\n    {((li, si), l).\n     (li, l) \\<in> \\<langle>vrel\\<rangle>lrel \\<and>\n     (si, set l) \\<in> \\<langle>vrel\\<rangle>srel \\<and> distinct l}", "unfolding stack_rel_internal_def relAPP_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {((li, si), l).\n     (li, l) \\<in> lrel vrel \\<and>\n     (si, set l) \\<in> srel vrel \\<and> distinct l} \\<equiv>\n    {((li, si), l).\n     (li, l) \\<in> lrel vrel \\<and>\n     (si, set l) \\<in> srel vrel \\<and> distinct l}", "by auto"], ["", "lemmas [autoref_rel_intf] \n  = REL_INTFI[of \"stack_rel lrel srel\" i_list for lrel srel]"], ["", "context \n  fixes lrel :: \"('xi \\<times> 'x) set \\<Rightarrow> ('xli \\<times> 'x list) set\"\n  and srel :: \"('xi \\<times> 'x) set \\<Rightarrow> ('xsi \\<times> 'x set) set\"\nbegin"], ["", "context begin"], ["", "interpretation autoref_syn"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma autoref_stack_empty[OF GEN_OP_D GEN_OP_D]:\n  assumes \"(el,[])\\<in>\\<langle>vrel\\<rangle>lrel\"\n  assumes \"(es,{})\\<in>\\<langle>vrel\\<rangle>srel\"\n  shows \"((el,es),[]) \\<in> \\<langle>vrel\\<rangle>stack_rel lrel srel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((el, es), []) \\<in> \\<langle>vrel\\<rangle>stack_rel lrel srel", "using assms"], ["proof (prove)\nusing this:\n  (el, []) \\<in> \\<langle>vrel\\<rangle>lrel\n  (es, {}) \\<in> \\<langle>vrel\\<rangle>srel\n\ngoal (1 subgoal):\n 1. ((el, es), []) \\<in> \\<langle>vrel\\<rangle>stack_rel lrel srel", "unfolding stack_rel_def"], ["proof (prove)\nusing this:\n  (el, []) \\<in> \\<langle>vrel\\<rangle>lrel\n  (es, {}) \\<in> \\<langle>vrel\\<rangle>srel\n\ngoal (1 subgoal):\n 1. ((el, es), [])\n    \\<in> {((li, si), l).\n           (li, l) \\<in> \\<langle>vrel\\<rangle>lrel \\<and>\n           (si, set l) \\<in> \\<langle>vrel\\<rangle>srel \\<and> distinct l}", "by auto"], ["", "primrec stack_push::\"_::type\" \n  where \"stack_push push ins (el,es) v = (push el v, ins v es)\""], ["", "lemma autoref_stack_push:\n  assumes \"GEN_OP push op_list_append_elem (\\<langle>vrel\\<rangle>lrel \\<rightarrow> vrel \\<rightarrow> \\<langle>vrel\\<rangle>lrel)\"\n  assumes \"GEN_OP ins insert (vrel \\<rightarrow> \\<langle>vrel\\<rangle>srel \\<rightarrow> \\<langle>vrel\\<rangle>srel)\"\n  assumes \"SIDE_PRECOND (v\\<notin>set l)\"\n  assumes \"(vi,v)\\<in>vrel\"\n  assumes \"(si,l)\\<in>\\<langle>vrel\\<rangle>stack_rel lrel srel\"\n  shows \"(stack_push push ins si vi,\n    (OP op_list_append_elem ::: \\<langle>vrel\\<rangle>stack_rel lrel srel \\<rightarrow> vrel \\<rightarrow> \\<langle>vrel\\<rangle>stack_rel lrel srel)\n      $l$v) \\<in> \\<langle>vrel\\<rangle>stack_rel lrel srel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (stack_push push ins si vi,\n     (OP op_list_append_elem :::\n      \\<langle>vrel\\<rangle>stack_rel lrel srel \\<rightarrow>\n      vrel \\<rightarrow> \\<langle>vrel\\<rangle>stack_rel lrel srel) $\n     l $\n     v)\n    \\<in> \\<langle>vrel\\<rangle>stack_rel lrel srel", "using assms"], ["proof (prove)\nusing this:\n  GEN_OP push op_list_append_elem\n   (\\<langle>vrel\\<rangle>lrel \\<rightarrow>\n    vrel \\<rightarrow> \\<langle>vrel\\<rangle>lrel)\n  GEN_OP ins insert\n   (vrel \\<rightarrow>\n    \\<langle>vrel\\<rangle>srel \\<rightarrow> \\<langle>vrel\\<rangle>srel)\n  SIDE_PRECOND (v \\<notin> set l)\n  (vi, v) \\<in> vrel\n  (si, l) \\<in> \\<langle>vrel\\<rangle>stack_rel lrel srel\n\ngoal (1 subgoal):\n 1. (stack_push push ins si vi,\n     (OP op_list_append_elem :::\n      \\<langle>vrel\\<rangle>stack_rel lrel srel \\<rightarrow>\n      vrel \\<rightarrow> \\<langle>vrel\\<rangle>stack_rel lrel srel) $\n     l $\n     v)\n    \\<in> \\<langle>vrel\\<rangle>stack_rel lrel srel", "unfolding stack_rel_def"], ["proof (prove)\nusing this:\n  GEN_OP push op_list_append_elem\n   (\\<langle>vrel\\<rangle>lrel \\<rightarrow>\n    vrel \\<rightarrow> \\<langle>vrel\\<rangle>lrel)\n  GEN_OP ins insert\n   (vrel \\<rightarrow>\n    \\<langle>vrel\\<rangle>srel \\<rightarrow> \\<langle>vrel\\<rangle>srel)\n  SIDE_PRECOND (v \\<notin> set l)\n  (vi, v) \\<in> vrel\n  (si, l)\n  \\<in> {((li, si), l).\n         (li, l) \\<in> \\<langle>vrel\\<rangle>lrel \\<and>\n         (si, set l) \\<in> \\<langle>vrel\\<rangle>srel \\<and> distinct l}\n\ngoal (1 subgoal):\n 1. (stack_push push ins si vi,\n     (OP op_list_append_elem :::\n      {((li, si), l).\n       (li, l) \\<in> \\<langle>vrel\\<rangle>lrel \\<and>\n       (si, set l) \\<in> \\<langle>vrel\\<rangle>srel \\<and>\n       distinct l} \\<rightarrow>\n      vrel \\<rightarrow>\n      {((li, si), l).\n       (li, l) \\<in> \\<langle>vrel\\<rangle>lrel \\<and>\n       (si, set l) \\<in> \\<langle>vrel\\<rangle>srel \\<and> distinct l}) $\n     l $\n     v)\n    \\<in> {((li, si), l).\n           (li, l) \\<in> \\<langle>vrel\\<rangle>lrel \\<and>\n           (si, set l) \\<in> \\<langle>vrel\\<rangle>srel \\<and> distinct l}", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>(push, op_list_append_elem)\n                \\<in> \\<langle>vrel\\<rangle>lrel \\<rightarrow>\n                      vrel \\<rightarrow> \\<langle>vrel\\<rangle>lrel;\n        (ins, insert)\n        \\<in> vrel \\<rightarrow>\n              \\<langle>vrel\\<rangle>srel \\<rightarrow>\n              \\<langle>vrel\\<rangle>srel;\n        v \\<notin> set l; (vi, v) \\<in> vrel; si = (x, y);\n        (x, l) \\<in> \\<langle>vrel\\<rangle>lrel;\n        (y, set l) \\<in> \\<langle>vrel\\<rangle>srel; distinct l\\<rbrakk>\n       \\<Longrightarrow> (push x vi, l @ [v])\n                         \\<in> \\<langle>vrel\\<rangle>lrel\n 2. \\<And>x y.\n       \\<lbrakk>(push, op_list_append_elem)\n                \\<in> \\<langle>vrel\\<rangle>lrel \\<rightarrow>\n                      vrel \\<rightarrow> \\<langle>vrel\\<rangle>lrel;\n        (ins, insert)\n        \\<in> vrel \\<rightarrow>\n              \\<langle>vrel\\<rangle>srel \\<rightarrow>\n              \\<langle>vrel\\<rangle>srel;\n        v \\<notin> set l; (vi, v) \\<in> vrel; si = (x, y);\n        (x, l) \\<in> \\<langle>vrel\\<rangle>lrel;\n        (y, set l) \\<in> \\<langle>vrel\\<rangle>srel; distinct l\\<rbrakk>\n       \\<Longrightarrow> (ins vi y, insert v (set l))\n                         \\<in> \\<langle>vrel\\<rangle>srel", "apply (unfold op_list_append_elem_def[symmetric])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>(push, op_list_append_elem)\n                \\<in> \\<langle>vrel\\<rangle>lrel \\<rightarrow>\n                      vrel \\<rightarrow> \\<langle>vrel\\<rangle>lrel;\n        (ins, insert)\n        \\<in> vrel \\<rightarrow>\n              \\<langle>vrel\\<rangle>srel \\<rightarrow>\n              \\<langle>vrel\\<rangle>srel;\n        v \\<notin> set l; (vi, v) \\<in> vrel; si = (x, y);\n        (x, l) \\<in> \\<langle>vrel\\<rangle>lrel;\n        (y, set l) \\<in> \\<langle>vrel\\<rangle>srel; distinct l\\<rbrakk>\n       \\<Longrightarrow> (push x vi, op_list_append_elem l v)\n                         \\<in> \\<langle>vrel\\<rangle>lrel\n 2. \\<And>x y.\n       \\<lbrakk>(push, op_list_append_elem)\n                \\<in> \\<langle>vrel\\<rangle>lrel \\<rightarrow>\n                      vrel \\<rightarrow> \\<langle>vrel\\<rangle>lrel;\n        (ins, insert)\n        \\<in> vrel \\<rightarrow>\n              \\<langle>vrel\\<rangle>srel \\<rightarrow>\n              \\<langle>vrel\\<rangle>srel;\n        v \\<notin> set l; (vi, v) \\<in> vrel; si = (x, y);\n        (x, l) \\<in> \\<langle>vrel\\<rangle>lrel;\n        (y, set l) \\<in> \\<langle>vrel\\<rangle>srel; distinct l\\<rbrakk>\n       \\<Longrightarrow> (ins vi y, insert v (set l))\n                         \\<in> \\<langle>vrel\\<rangle>srel", "apply parametricity+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma autoref_stack_sng:\n  assumes \"GEN_OP lsng op_list_singleton (vrel \\<rightarrow> \\<langle>vrel\\<rangle>lrel)\"\n  assumes \"GEN_OP sins insert (vrel \\<rightarrow> \\<langle>vrel\\<rangle>srel \\<rightarrow> \\<langle>vrel\\<rangle>srel)\"\n  assumes \"GEN_OP semp {} (\\<langle>vrel\\<rangle>srel)\"\n  shows \"(\\<lambda>v. (lsng v, sins v semp),op_list_singleton) \n    \\<in> vrel \\<rightarrow> \\<langle>vrel\\<rangle>stack_rel lrel srel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>v. (lsng v, sins v semp), op_list_singleton)\n    \\<in> vrel \\<rightarrow> \\<langle>vrel\\<rangle>stack_rel lrel srel", "using assms"], ["proof (prove)\nusing this:\n  GEN_OP lsng op_list_singleton\n   (vrel \\<rightarrow> \\<langle>vrel\\<rangle>lrel)\n  GEN_OP sins insert\n   (vrel \\<rightarrow>\n    \\<langle>vrel\\<rangle>srel \\<rightarrow> \\<langle>vrel\\<rangle>srel)\n  GEN_OP semp {} (\\<langle>vrel\\<rangle>srel)\n\ngoal (1 subgoal):\n 1. (\\<lambda>v. (lsng v, sins v semp), op_list_singleton)\n    \\<in> vrel \\<rightarrow> \\<langle>vrel\\<rangle>stack_rel lrel srel", "unfolding stack_rel_def autoref_tag_defs"], ["proof (prove)\nusing this:\n  (lsng, op_list_singleton)\n  \\<in> vrel \\<rightarrow> \\<langle>vrel\\<rangle>lrel\n  (sins, insert)\n  \\<in> vrel \\<rightarrow>\n        \\<langle>vrel\\<rangle>srel \\<rightarrow> \\<langle>vrel\\<rangle>srel\n  (semp, {}) \\<in> \\<langle>vrel\\<rangle>srel\n\ngoal (1 subgoal):\n 1. (\\<lambda>v. (lsng v, sins v semp), op_list_singleton)\n    \\<in> vrel \\<rightarrow>\n          {((li, si), l).\n           (li, l) \\<in> \\<langle>vrel\\<rangle>lrel \\<and>\n           (si, set l) \\<in> \\<langle>vrel\\<rangle>srel \\<and> distinct l}", "by (fastforce simp: op_list_singleton_def[abs_def] dest: fun_relD)"], ["", "primrec stack_pop::\"_::type\" \n  where \"stack_pop lpop ltop del (el,es) \n    = (let v = ltop el; el = lpop el; es = del v es in (el,es))\""], ["", "lemma autoref_stack_pop:\n  assumes POPR: \"\\<And>el l. \\<lbrakk> (el,l)\\<in>\\<langle>vrel\\<rangle>lrel; l\\<noteq>[] \\<rbrakk> \n    \\<Longrightarrow> (lpop el,(OP butlast ::: \\<langle>vrel\\<rangle>lrel \\<rightarrow> \\<langle>vrel\\<rangle>lrel)$l)\\<in> \\<langle>vrel\\<rangle>lrel\"\n  assumes TOPR: \"\\<And>el l. \\<lbrakk> (el,l)\\<in>\\<langle>vrel\\<rangle>lrel; l\\<noteq>[] \\<rbrakk> \n    \\<Longrightarrow> (ltop el,(OP last ::: \\<langle>vrel\\<rangle>lrel \\<rightarrow> vrel)$l)\\<in> vrel\"\n  assumes DELR: \"GEN_OP del op_set_delete (vrel \\<rightarrow> \\<langle>vrel\\<rangle>srel \\<rightarrow> \\<langle>vrel\\<rangle>srel)\"\n  assumes NE: \"SIDE_PRECOND (l \\<noteq> [])\"\n  assumes R: \"(si,l)\\<in>\\<langle>vrel\\<rangle>stack_rel lrel srel\"\n  shows \"(stack_pop lpop ltop del si,\n    (OP butlast ::: \\<langle>vrel\\<rangle>stack_rel lrel srel \\<rightarrow> \\<langle>vrel\\<rangle>stack_rel lrel srel)\n      $l) \\<in> \\<langle>vrel\\<rangle>stack_rel lrel srel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (stack_pop lpop ltop del si,\n     (OP butlast :::\n      \\<langle>vrel\\<rangle>stack_rel lrel srel \\<rightarrow>\n      \\<langle>vrel\\<rangle>stack_rel lrel srel) $\n     l)\n    \\<in> \\<langle>vrel\\<rangle>stack_rel lrel srel", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (stack_pop lpop ltop del si,\n     (OP butlast :::\n      \\<langle>vrel\\<rangle>stack_rel lrel srel \\<rightarrow>\n      \\<langle>vrel\\<rangle>stack_rel lrel srel) $\n     l)\n    \\<in> \\<langle>vrel\\<rangle>stack_rel lrel srel", "note POPR TOPR DELR"], ["proof (state)\nthis:\n  \\<lbrakk>(?el, ?l) \\<in> \\<langle>vrel\\<rangle>lrel;\n   ?l \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> (lpop ?el,\n                     (OP butlast :::\n                      \\<langle>vrel\\<rangle>lrel \\<rightarrow>\n                      \\<langle>vrel\\<rangle>lrel) $\n                     ?l)\n                    \\<in> \\<langle>vrel\\<rangle>lrel\n  \\<lbrakk>(?el, ?l) \\<in> \\<langle>vrel\\<rangle>lrel;\n   ?l \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> (ltop ?el,\n                     (OP last :::\n                      \\<langle>vrel\\<rangle>lrel \\<rightarrow> vrel) $\n                     ?l)\n                    \\<in> vrel\n  GEN_OP del op_set_delete\n   (vrel \\<rightarrow>\n    \\<langle>vrel\\<rangle>srel \\<rightarrow> \\<langle>vrel\\<rangle>srel)\n\ngoal (1 subgoal):\n 1. (stack_pop lpop ltop del si,\n     (OP butlast :::\n      \\<langle>vrel\\<rangle>stack_rel lrel srel \\<rightarrow>\n      \\<langle>vrel\\<rangle>stack_rel lrel srel) $\n     l)\n    \\<in> \\<langle>vrel\\<rangle>stack_rel lrel srel", "note [param] = this[unfolded autoref_tag_defs]"], ["proof (state)\nthis:\n  \\<lbrakk>(?el, ?l) \\<in> \\<langle>vrel\\<rangle>lrel;\n   ?l \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> (lpop ?el, butlast ?l) \\<in> \\<langle>vrel\\<rangle>lrel\n  \\<lbrakk>(?el, ?l) \\<in> \\<langle>vrel\\<rangle>lrel;\n   ?l \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> (ltop ?el, last ?l) \\<in> vrel\n  (del, op_set_delete)\n  \\<in> vrel \\<rightarrow>\n        \\<langle>vrel\\<rangle>srel \\<rightarrow> \\<langle>vrel\\<rangle>srel\n\ngoal (1 subgoal):\n 1. (stack_pop lpop ltop del si,\n     (OP butlast :::\n      \\<langle>vrel\\<rangle>stack_rel lrel srel \\<rightarrow>\n      \\<langle>vrel\\<rangle>stack_rel lrel srel) $\n     l)\n    \\<in> \\<langle>vrel\\<rangle>stack_rel lrel srel", "have AUX: \"set (butlast l) = op_set_delete (last l) (set l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (butlast l) = op_set_delete (last l) (set l)", "using NE R"], ["proof (prove)\nusing this:\n  SIDE_PRECOND (l \\<noteq> [])\n  (si, l) \\<in> \\<langle>vrel\\<rangle>stack_rel lrel srel\n\ngoal (1 subgoal):\n 1. set (butlast l) = op_set_delete (last l) (set l)", "unfolding stack_rel_def"], ["proof (prove)\nusing this:\n  SIDE_PRECOND (l \\<noteq> [])\n  (si, l)\n  \\<in> {((li, si), l).\n         (li, l) \\<in> \\<langle>vrel\\<rangle>lrel \\<and>\n         (si, set l) \\<in> \\<langle>vrel\\<rangle>srel \\<and> distinct l}\n\ngoal (1 subgoal):\n 1. set (butlast l) = op_set_delete (last l) (set l)", "by (cases l rule: rev_cases) auto"], ["proof (state)\nthis:\n  set (butlast l) = op_set_delete (last l) (set l)\n\ngoal (1 subgoal):\n 1. (stack_pop lpop ltop del si,\n     (OP butlast :::\n      \\<langle>vrel\\<rangle>stack_rel lrel srel \\<rightarrow>\n      \\<langle>vrel\\<rangle>stack_rel lrel srel) $\n     l)\n    \\<in> \\<langle>vrel\\<rangle>stack_rel lrel srel", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (stack_pop lpop ltop del si,\n     (OP butlast :::\n      \\<langle>vrel\\<rangle>stack_rel lrel srel \\<rightarrow>\n      \\<langle>vrel\\<rangle>stack_rel lrel srel) $\n     l)\n    \\<in> \\<langle>vrel\\<rangle>stack_rel lrel srel", "using NE R"], ["proof (prove)\nusing this:\n  SIDE_PRECOND (l \\<noteq> [])\n  (si, l) \\<in> \\<langle>vrel\\<rangle>stack_rel lrel srel\n\ngoal (1 subgoal):\n 1. (stack_pop lpop ltop del si,\n     (OP butlast :::\n      \\<langle>vrel\\<rangle>stack_rel lrel srel \\<rightarrow>\n      \\<langle>vrel\\<rangle>stack_rel lrel srel) $\n     l)\n    \\<in> \\<langle>vrel\\<rangle>stack_rel lrel srel", "unfolding stack_rel_def autoref_tag_defs"], ["proof (prove)\nusing this:\n  l \\<noteq> []\n  (si, l)\n  \\<in> {((li, si), l).\n         (li, l) \\<in> \\<langle>vrel\\<rangle>lrel \\<and>\n         (si, set l) \\<in> \\<langle>vrel\\<rangle>srel \\<and> distinct l}\n\ngoal (1 subgoal):\n 1. (stack_pop lpop ltop del si, butlast l)\n    \\<in> {((li, si), l).\n           (li, l) \\<in> \\<langle>vrel\\<rangle>lrel \\<and>\n           (si, set l) \\<in> \\<langle>vrel\\<rangle>srel \\<and> distinct l}", "apply (clarsimp simp: distinct_butlast, intro conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>l \\<noteq> []; si = (x, y);\n        (x, l) \\<in> \\<langle>vrel\\<rangle>lrel;\n        (y, set l) \\<in> \\<langle>vrel\\<rangle>srel; distinct l;\n        l \\<noteq> [];\n        (si, l)\n        \\<in> {((li, si), l).\n               (li, l) \\<in> \\<langle>vrel\\<rangle>lrel \\<and>\n               (si, set l) \\<in> \\<langle>vrel\\<rangle>srel \\<and>\n               distinct l}\\<rbrakk>\n       \\<Longrightarrow> (lpop x, butlast l)\n                         \\<in> \\<langle>vrel\\<rangle>lrel\n 2. \\<And>x y.\n       \\<lbrakk>l \\<noteq> []; si = (x, y);\n        (x, l) \\<in> \\<langle>vrel\\<rangle>lrel;\n        (y, set l) \\<in> \\<langle>vrel\\<rangle>srel; distinct l;\n        l \\<noteq> [];\n        (si, l)\n        \\<in> {((li, si), l).\n               (li, l) \\<in> \\<langle>vrel\\<rangle>lrel \\<and>\n               (si, set l) \\<in> \\<langle>vrel\\<rangle>srel \\<and>\n               distinct l}\\<rbrakk>\n       \\<Longrightarrow> (del (ltop x) y, set (butlast l))\n                         \\<in> \\<langle>vrel\\<rangle>srel", "apply parametricity"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>l \\<noteq> []; si = (x, y);\n        (x, l) \\<in> \\<langle>vrel\\<rangle>lrel;\n        (y, set l) \\<in> \\<langle>vrel\\<rangle>srel; distinct l;\n        l \\<noteq> [];\n        (si, l)\n        \\<in> {((li, si), l).\n               (li, l) \\<in> \\<langle>vrel\\<rangle>lrel \\<and>\n               (si, set l) \\<in> \\<langle>vrel\\<rangle>srel \\<and>\n               distinct l}\\<rbrakk>\n       \\<Longrightarrow> (del (ltop x) y, set (butlast l))\n                         \\<in> \\<langle>vrel\\<rangle>srel", "apply (subst AUX)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>l \\<noteq> []; si = (x, y);\n        (x, l) \\<in> \\<langle>vrel\\<rangle>lrel;\n        (y, set l) \\<in> \\<langle>vrel\\<rangle>srel; distinct l;\n        l \\<noteq> [];\n        (si, l)\n        \\<in> {((li, si), l).\n               (li, l) \\<in> \\<langle>vrel\\<rangle>lrel \\<and>\n               (si, set l) \\<in> \\<langle>vrel\\<rangle>srel \\<and>\n               distinct l}\\<rbrakk>\n       \\<Longrightarrow> (del (ltop x) y, op_set_delete (last l) (set l))\n                         \\<in> \\<langle>vrel\\<rangle>srel", "apply parametricity"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (stack_pop lpop ltop del si,\n   (OP butlast :::\n    \\<langle>vrel\\<rangle>stack_rel lrel srel \\<rightarrow>\n    \\<langle>vrel\\<rangle>stack_rel lrel srel) $\n   l)\n  \\<in> \\<langle>vrel\\<rangle>stack_rel lrel srel\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma autoref_stack_set: \n  shows \"(snd, set) \\<in> \\<langle>vrel\\<rangle>stack_rel lrel srel \\<rightarrow> \\<langle>vrel\\<rangle>srel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (snd, set)\n    \\<in> \\<langle>vrel\\<rangle>stack_rel lrel srel \\<rightarrow>\n          \\<langle>vrel\\<rangle>srel", "unfolding stack_rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (snd, set)\n    \\<in> {((li, si), l).\n           (li, l) \\<in> \\<langle>vrel\\<rangle>lrel \\<and>\n           (si, set l) \\<in> \\<langle>vrel\\<rangle>srel \\<and>\n           distinct l} \\<rightarrow>\n          \\<langle>vrel\\<rangle>srel", "by auto"], ["", "lemma autoref_stack_is_Nil: \n  assumes \"GEN_OP ini is_Nil (\\<langle>vrel\\<rangle>lrel \\<rightarrow> bool_rel)\"\n  shows \"(ini o fst, is_Nil) \\<in> \\<langle>vrel\\<rangle>stack_rel lrel srel \\<rightarrow> bool_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ini \\<circ> fst, is_Nil)\n    \\<in> \\<langle>vrel\\<rangle>stack_rel lrel srel \\<rightarrow> bool_rel", "using assms"], ["proof (prove)\nusing this:\n  GEN_OP ini is_Nil (\\<langle>vrel\\<rangle>lrel \\<rightarrow> bool_rel)\n\ngoal (1 subgoal):\n 1. (ini \\<circ> fst, is_Nil)\n    \\<in> \\<langle>vrel\\<rangle>stack_rel lrel srel \\<rightarrow> bool_rel", "unfolding stack_rel_def"], ["proof (prove)\nusing this:\n  GEN_OP ini is_Nil (\\<langle>vrel\\<rangle>lrel \\<rightarrow> bool_rel)\n\ngoal (1 subgoal):\n 1. (ini \\<circ> fst, is_Nil)\n    \\<in> {((li, si), l).\n           (li, l) \\<in> \\<langle>vrel\\<rangle>lrel \\<and>\n           (si, set l) \\<in> \\<langle>vrel\\<rangle>srel \\<and>\n           distinct l} \\<rightarrow>\n          bool_rel", "by (auto dest: fun_relD)"], ["", "lemma autoref_stack_ltop: \n  assumes TOPR: \"\\<And>el l. \\<lbrakk> (el,l)\\<in>\\<langle>vrel\\<rangle>lrel; l\\<noteq>[] \\<rbrakk> \n    \\<Longrightarrow> (ltop el,(OP last ::: \\<langle>vrel\\<rangle>lrel \\<rightarrow> vrel)$l)\\<in> vrel\"\n  assumes NE: \"SIDE_PRECOND (l \\<noteq> [])\"\n  assumes R: \"(si,l)\\<in>\\<langle>vrel\\<rangle>stack_rel lrel srel\"\n  shows \"(ltop (fst si), (OP last ::: \\<langle>vrel\\<rangle>stack_rel lrel srel \\<rightarrow> vrel)$l) \\<in> vrel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ltop (fst si),\n     (OP last :::\n      \\<langle>vrel\\<rangle>stack_rel lrel srel \\<rightarrow> vrel) $\n     l)\n    \\<in> vrel", "using assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>(?el, ?l) \\<in> \\<langle>vrel\\<rangle>lrel;\n   ?l \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> (ltop ?el,\n                     (OP last :::\n                      \\<langle>vrel\\<rangle>lrel \\<rightarrow> vrel) $\n                     ?l)\n                    \\<in> vrel\n  SIDE_PRECOND (l \\<noteq> [])\n  (si, l) \\<in> \\<langle>vrel\\<rangle>stack_rel lrel srel\n\ngoal (1 subgoal):\n 1. (ltop (fst si),\n     (OP last :::\n      \\<langle>vrel\\<rangle>stack_rel lrel srel \\<rightarrow> vrel) $\n     l)\n    \\<in> vrel", "unfolding stack_rel_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>(?el, ?l) \\<in> \\<langle>vrel\\<rangle>lrel;\n   ?l \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> (ltop ?el,\n                     (OP last :::\n                      \\<langle>vrel\\<rangle>lrel \\<rightarrow> vrel) $\n                     ?l)\n                    \\<in> vrel\n  SIDE_PRECOND (l \\<noteq> [])\n  (si, l)\n  \\<in> {((li, si), l).\n         (li, l) \\<in> \\<langle>vrel\\<rangle>lrel \\<and>\n         (si, set l) \\<in> \\<langle>vrel\\<rangle>srel \\<and> distinct l}\n\ngoal (1 subgoal):\n 1. (ltop (fst si),\n     (OP last :::\n      {((li, si), l).\n       (li, l) \\<in> \\<langle>vrel\\<rangle>lrel \\<and>\n       (si, set l) \\<in> \\<langle>vrel\\<rangle>srel \\<and>\n       distinct l} \\<rightarrow>\n      vrel) $\n     l)\n    \\<in> vrel", "by (auto dest: fun_relD)"], ["", "lemmas stack_autoref_rules \n  = autoref_stack_empty autoref_stack_push autoref_stack_sng autoref_stack_pop\n    autoref_stack_set autoref_stack_is_Nil autoref_stack_ltop"], ["", "end"], ["", "end"], ["", "abbreviation \"as_ahs_stack_rel \\<equiv> stack_rel as_rel dflt_ahs_rel\""], ["", "lemmas as_ahs_stack_rules \n  = stack_autoref_rules[where lrel = as_rel and srel = dflt_ahs_rel]"], ["", "schematic_goal \n  notes [autoref_rules] = as_ahs_stack_rules\n  shows \"(?c::?'c, set (butlast ([1::nat]@[2]))) \\<in> ?R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c, set (butlast ([1] @ [2]))) \\<in> ?R", "apply (autoref (trace,keep_goal))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"]]}