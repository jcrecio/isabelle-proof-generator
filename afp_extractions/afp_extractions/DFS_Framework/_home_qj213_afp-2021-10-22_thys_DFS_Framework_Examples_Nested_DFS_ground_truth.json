{"file_name": "/home/qj213/afp-2021-10-22/thys/DFS_Framework/Examples/Nested_DFS.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/DFS_Framework", "problem_names": ["lemma closed_restrict_aux:\n  assumes CL: \"E``F \\<subseteq> F \\<union> S\"\n  assumes NR: \"E\\<^sup>*``U \\<inter> S = {}\"\n  assumes SS: \"U \\<subseteq> F\"\n  shows \"E\\<^sup>*``U \\<subseteq> F\"\n  \\<comment> \\<open>Auxiliary lemma to show that nodes reachable from a finished node must  \n      be finished if, additionally, no stack node is reachable\\<close>", "lemma lasso_more_cong[cong]:\"state.more s = state.more s' \\<Longrightarrow> lasso s = lasso s'\"", "lemma red_more_cong[cong]: \"state.more s = state.more s' \\<Longrightarrow> red s = red s'\"", "lemma [simp]: \"s\\<lparr> state.more := \\<lparr> lasso = foo, red = bar \\<rparr> \\<rparr> = s \\<lparr> lasso := foo, red := bar \\<rparr>\"", "lemma BlueDFSI: \n  assumes \"fb_graph G\" \n  shows \"BlueDFS G\"", "lemma BlueDFS_invar_eq[simp]:\n  shows \"DFS_invar G blue_dfs_params s \\<longleftrightarrow> BlueDFS_invar G accpt s\"", "lemma (in BlueDFS_invar) red_DFS_precond_aux:\n    assumes BI: \"blue_basic_invar s\"\n    assumes [simp]: \"lasso s = None\"\n    assumes SNE: \"stack s \\<noteq> []\"\n    shows\n      \"fb_graph (G \\<lparr> g_V0 := {hd (stack s)} \\<rparr>)\"\n    and \"fb_graph (G \\<lparr> g_E := E \\<inter> UNIV \\<times> - red s, g_V0 := {hd (stack s)} \\<rparr>)\" \n    and \"restr_invar E (red s) (\\<lambda>x. x \\<in> set (stack s))\"", "lemma (in BlueDFS_invar) red_dfs_pres_bbi:\n    assumes BI: \"blue_basic_invar s\"\n    assumes [simp]: \"lasso s = None\" and SNE: \"stack s \\<noteq> []\"\n    assumes \"pending s `` {hd (stack s)} = {}\"\n    shows \"run_red_dfs (hd (stack s)) (finish (hd (stack s)) s) \\<le>\\<^sub>n\n      SPEC (\\<lambda>e. \n        DFS_invar G blue_dfs_params (finish (hd (stack s)) s\\<lparr>state.more := e\\<rparr>) \n        \\<longrightarrow> blue_basic_invar (finish (hd (stack s)) s\\<lparr>state.more := e\\<rparr>))\"", "lemma blue_basic_invar: \"is_invar blue_basic_invar\"", "lemmas (in BlueDFS_invar) s_blue_basic_invar \n    = blue_basic_invar[THEN make_invar_thm]", "lemmas (in BlueDFS_invar) red_DFS_precond \n    = red_DFS_precond_aux[OF s_blue_basic_invar]", "lemma red_closed:\n      \"E `` red s \\<subseteq> red s\"", "lemma red_stack_disjoint:\n      \"set (stack s) \\<inter> red s = {}\"", "lemma red_finished: \"red s \\<subseteq> dom (finished s)\"", "lemma all_nodes_colored: \"white s \\<union> blue s \\<union> cyan s \\<union> red s = UNIV \"", "lemma colors_disjoint:\n      \"white s \\<inter> (blue s \\<union> cyan s \\<union> red s) = {}\"\n      \"blue s \\<inter> (white s \\<union> cyan s \\<union> red s) = {}\"\n      \"cyan s \\<inter> (white s \\<union> blue s \\<union> red s) = {}\"\n      \"red s \\<inter> (white s \\<union> blue s \\<union> cyan s) = {}\"", "lemma (in BlueDFS) i_no_accpt_cyle_in_finish:\n    \"is_invar (\\<lambda>s. lasso s = None \\<longrightarrow> (\\<forall>x. accpt x \\<and> x \\<in> dom (finished s) \\<longrightarrow> (x,x) \\<notin> E\\<^sup>+))\"", "lemma no_accpt_cycle_in_finish:\n    \"\\<lbrakk>lasso s = None; accpt v; v \\<in> dom (finished s)\\<rbrakk> \\<Longrightarrow> (v,v) \\<notin> E\\<^sup>+\"", "lemma (in BlueDFS_invar) se_back_edge_lasso_inv:\n    assumes b_inv: \"lasso_inv s\"\n    and ne: \"stack s \\<noteq> []\"\n    and R: \"lasso s = None\"\n    and p:\"(hd (stack s), v) \\<in> pending s\"\n    and v: \"v \\<in> dom (discovered s)\" \"v \\<notin> dom (finished s)\"\n    and s': \"s' = back_edge (hd (stack s)) v (s\\<lparr>pending := pending s - {(u,v)}\\<rparr>)\"\n    shows \"se_back_edge (hd (stack s)) v s'\n                \\<le> SPEC (\\<lambda>e. DFS_invar G blue_dfs_params (s'\\<lparr>state.more := e\\<rparr>) \\<longrightarrow>\n                            lasso_inv (s'\\<lparr>state.more := e\\<rparr>))\"", "lemma lasso_inv:\n    \"is_invar lasso_inv\"", "lemmas s_lasso_inv = lasso_inv[THEN make_invar_thm]", "lemma \n    assumes \"lasso s = Some (pr,pl)\"\n    shows loop_nonempty: \"pl \\<noteq> []\"\n    and accpt_loop: \"accpt (hd pl)\"\n    and loop_is_path: \"path E (hd pl) pl (hd pl)\"\n    and loop_reachable: \"\\<exists>v0\\<in>V0. path E v0 pr (hd pl)\"", "lemma blue_dfs_correct:\n    assumes NC: \"\\<not> cond s\"\n    shows \"case lasso s of\n      None \\<Rightarrow> \\<not>(\\<exists>v0\\<in>V0. \\<exists>v. (v0,v) \\<in> E\\<^sup>* \\<and> accpt v \\<and> (v,v) \\<in> E\\<^sup>+)\n    | Some (pr,pl) \\<Rightarrow> (\\<exists>v0\\<in>V0. \\<exists>v. \n        path E v0 pr v \\<and> accpt v \\<and> pl\\<noteq>[] \\<and> path E v pl v)\"", "theorem nested_dfs_correct: \n  assumes \"fb_graph G\"\n  shows \"nested_dfs G accpt \\<le> SPEC (nested_dfs_spec G accpt)\"", "lemma mk_blue_witness_impl[refine]:\n  \"\\<lbrakk> (si,s)\\<in>bdfs_rel; (ri,r)\\<in>\\<langle>Id, \\<langle>Id\\<rangle>list_rel \\<times>\\<^sub>r Id\\<rangle>sum_rel \\<rbrakk> \n  \\<Longrightarrow> (mk_blue_witness_impl si ri, mk_blue_witness s r)\\<in>bdfs_erel\"", "lemma cyan_impl[refine]: \"\\<lbrakk>(si,s)\\<in>bdfs_rel\\<rbrakk> \\<Longrightarrow> (cyan_impl si, cyan s)\\<in>Id\"", "lemma run_red_dfs_impl[refine]: \"\\<lbrakk>(Gi,G)\\<in>Id; (ui,u)\\<in>Id; (si,s)\\<in>bdfs_rel\\<rbrakk> \n    \\<Longrightarrow> run_red_dfs_impl Gi ui si \\<le>\\<Down>bdfs_erel (run_red_dfs TYPE('a) G u s)\"", "lemma se_back_edge_impl[refine]: \"\\<lbrakk> (accpti,accpt)\\<in>Id; (ui,u)\\<in>Id; (vi,v)\\<in>Id; (si,s)\\<in>bdfs_rel \\<rbrakk> \n    \\<Longrightarrow> se_back_edge_impl accpt ui vi si \\<le>\\<Down>bdfs_erel (se_back_edge accpt u v s)\"", "lemma NOOP_impl: \"(si, s) \\<in> bdfs_rel \n    \\<Longrightarrow> RETURN (simple_state.more si) \\<le> \\<Down> bdfs_erel (NOOP s)\"", "lemmas bdfs_params_impl_simps[simp, DFS_code_unfold] = \n    gen_parameterization.simps[mk_record_simp, OF bdfs_params_impl_def]", "lemmas impl = impl.simple_tailrec_refine", "lemma nested_dfs_impl[refine]: \n  assumes \"(Gi,G)\\<in>Id\"\n  assumes \"(accpti,accpt)\\<in>Id\"\n  shows \"nested_dfs_impl Gi accpti \\<le>\\<Down>(\\<langle>\\<langle>Id\\<rangle>list_rel \\<times>\\<^sub>r \\<langle>Id\\<rangle>list_rel\\<rangle>option_rel) \n    (nested_dfs G accpt)\"", "lemmas [autoref_rel_intf] = REL_INTFI[of bdfs_state_erel' i_bdfs_state_ext]", "lemma [autoref_rules]:\n  fixes ns_rel vis_rel Vi\n  defines \"R \\<equiv> \\<langle>ns_rel,vis_rel,\\<langle>Vi\\<rangle>bdfs_state_erel'\\<rangle>ss_impl_rel\"\n  shows \n    \"(bdfs_state_impl'_ext, bdfs_state_impl_ext) \n      \\<in> \\<langle>\\<langle>Vi\\<rangle>list_rel \\<times>\\<^sub>r \\<langle>Vi\\<rangle>list_rel\\<rangle>option_rel \\<rightarrow> \\<langle>Vi\\<rangle>dflt_ahs_rel \\<rightarrow> unit_rel \\<rightarrow> \\<langle>Vi\\<rangle>bdfs_state_erel'\"\n    \"(lasso_impl', lasso_impl) \\<in> R \\<rightarrow> \\<langle>\\<langle>Vi\\<rangle>list_rel \\<times>\\<^sub>r \\<langle>Vi\\<rangle>list_rel\\<rangle>option_rel\"\n    \"(red_impl', red_impl) \\<in> R \\<rightarrow> \\<langle>Vi\\<rangle>dflt_ahs_rel\"", "theorem nested_dfs_autoref[autoref_rules]:\n  assumes \"PREFER_id V\"\n  shows \"(\\<lambda> G accpt. nres_of (nested_dfs_code G accpt),nested_dfs) \\<in>\n    \\<langle>Rm, V\\<rangle>g_impl_rel_ext \\<rightarrow> (V \\<rightarrow> bool_rel) \\<rightarrow>\n    \\<langle>\\<langle>\\<langle>V\\<rangle>list_rel \\<times>\\<^sub>r \\<langle>V\\<rangle>list_rel\\<rangle>option_rel\\<rangle>nres_rel\""], "translations": [["", "lemma closed_restrict_aux:\n  assumes CL: \"E``F \\<subseteq> F \\<union> S\"\n  assumes NR: \"E\\<^sup>*``U \\<inter> S = {}\"\n  assumes SS: \"U \\<subseteq> F\"\n  shows \"E\\<^sup>*``U \\<subseteq> F\"\n  \\<comment> \\<open>Auxiliary lemma to show that nodes reachable from a finished node must  \n      be finished if, additionally, no stack node is reachable\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. E\\<^sup>* `` U \\<subseteq> F", "proof clarify"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>(xa, x) \\<in> E\\<^sup>*; xa \\<in> U\\<rbrakk>\n       \\<Longrightarrow> x \\<in> F", "fix u v"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>(xa, x) \\<in> E\\<^sup>*; xa \\<in> U\\<rbrakk>\n       \\<Longrightarrow> x \\<in> F", "assume A: \"(u,v)\\<in>E\\<^sup>*\" \"u\\<in>U\""], ["proof (state)\nthis:\n  (u, v) \\<in> E\\<^sup>*\n  u \\<in> U\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>(xa, x) \\<in> E\\<^sup>*; xa \\<in> U\\<rbrakk>\n       \\<Longrightarrow> x \\<in> F", "hence M: \"E\\<^sup>*``{u} \\<inter> S = {}\" \"u\\<in>F\""], ["proof (prove)\nusing this:\n  (u, v) \\<in> E\\<^sup>*\n  u \\<in> U\n\ngoal (1 subgoal):\n 1. E\\<^sup>* `` {u} \\<inter> S = {} &&& u \\<in> F", "using NR SS"], ["proof (prove)\nusing this:\n  (u, v) \\<in> E\\<^sup>*\n  u \\<in> U\n  E\\<^sup>* `` U \\<inter> S = {}\n  U \\<subseteq> F\n\ngoal (1 subgoal):\n 1. E\\<^sup>* `` {u} \\<inter> S = {} &&& u \\<in> F", "by blast+"], ["proof (state)\nthis:\n  E\\<^sup>* `` {u} \\<inter> S = {}\n  u \\<in> F\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>(xa, x) \\<in> E\\<^sup>*; xa \\<in> U\\<rbrakk>\n       \\<Longrightarrow> x \\<in> F", "from A(1) M"], ["proof (chain)\npicking this:\n  (u, v) \\<in> E\\<^sup>*\n  E\\<^sup>* `` {u} \\<inter> S = {}\n  u \\<in> F", "show \"v\\<in>F\""], ["proof (prove)\nusing this:\n  (u, v) \\<in> E\\<^sup>*\n  E\\<^sup>* `` {u} \\<inter> S = {}\n  u \\<in> F\n\ngoal (1 subgoal):\n 1. v \\<in> F", "apply (induct rule: converse_rtrancl_induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>E\\<^sup>* `` {v} \\<inter> S = {}; v \\<in> F\\<rbrakk>\n    \\<Longrightarrow> v \\<in> F\n 2. \\<And>y z.\n       \\<lbrakk>(y, z) \\<in> E; (z, v) \\<in> E\\<^sup>*;\n        \\<lbrakk>E\\<^sup>* `` {z} \\<inter> S = {}; z \\<in> F\\<rbrakk>\n        \\<Longrightarrow> v \\<in> F;\n        E\\<^sup>* `` {y} \\<inter> S = {}; y \\<in> F\\<rbrakk>\n       \\<Longrightarrow> v \\<in> F", "using CL"], ["proof (prove)\nusing this:\n  E `` F \\<subseteq> F \\<union> S\n\ngoal (2 subgoals):\n 1. \\<lbrakk>E\\<^sup>* `` {v} \\<inter> S = {}; v \\<in> F\\<rbrakk>\n    \\<Longrightarrow> v \\<in> F\n 2. \\<And>y z.\n       \\<lbrakk>(y, z) \\<in> E; (z, v) \\<in> E\\<^sup>*;\n        \\<lbrakk>E\\<^sup>* `` {z} \\<inter> S = {}; z \\<in> F\\<rbrakk>\n        \\<Longrightarrow> v \\<in> F;\n        E\\<^sup>* `` {y} \\<inter> S = {}; y \\<in> F\\<rbrakk>\n       \\<Longrightarrow> v \\<in> F", "apply (auto dest: rtrancl_Image_advance_ss)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  v \\<in> F\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Instantiation of the Framework\\<close>"], ["", "record 'v blue_dfs_state = \"'v state\" +\n  lasso :: \"('v list \\<times> 'v list) option\" (* pr \\<times> pl *)\n  red  :: \"'v set\""], ["", "type_synonym 'v blue_dfs_param = \"('v, ('v,unit) blue_dfs_state_ext) parameterization\""], ["", "lemma lasso_more_cong[cong]:\"state.more s = state.more s' \\<Longrightarrow> lasso s = lasso s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. state.more s = state.more s' \\<Longrightarrow> lasso s = lasso s'", "by (cases s, cases s') simp"], ["", "lemma red_more_cong[cong]: \"state.more s = state.more s' \\<Longrightarrow> red s = red s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. state.more s = state.more s' \\<Longrightarrow> red s = red s'", "by (cases s, cases s') simp"], ["", "lemma [simp]: \"s\\<lparr> state.more := \\<lparr> lasso = foo, red = bar \\<rparr> \\<rparr> = s \\<lparr> lasso := foo, red := bar \\<rparr>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s\\<lparr>state.more := \\<lparr>lasso = foo, red = bar\\<rparr>\\<rparr> =\n    s\\<lparr>lasso := foo, red := bar\\<rparr>", "by (cases s) simp"], ["", "abbreviation \"dropWhileNot v \\<equiv> dropWhile ((\\<noteq>) v)\""], ["", "abbreviation \"takeWhileNot v \\<equiv> takeWhile ((\\<noteq>) v)\""], ["", "locale BlueDFS_defs = graph_defs G\n  for G :: \"('v, 'more) graph_rec_scheme\"  +\n  fixes accpt :: \"'v \\<Rightarrow> bool\"\nbegin"], ["", "definition \"blue s \\<equiv> dom (finished s) - red s\""], ["", "definition \"cyan s \\<equiv> set (stack s)\""], ["", "definition \"white s \\<equiv> - dom (discovered s)\""], ["", "abbreviation \"red_dfs R ss x \\<equiv> find_path1_restr_spec (G \\<lparr> g_V0 := {x} \\<rparr>) ss R\""], ["", "definition mk_blue_witness \n    :: \"'v blue_dfs_state \\<Rightarrow> 'v fpr_result \\<Rightarrow> ('v,unit) blue_dfs_state_ext\"\n    where\n    \"mk_blue_witness s redS \\<equiv> case redS of\n                 Inl R' \\<Rightarrow> \\<lparr> lasso = None, red = (R' \\<^cancel>\\<open>\\<union> red s\\<close>) \\<rparr>\n               | Inr (vs, v) \\<Rightarrow> let rs = rev (stack s) in \n                             \\<lparr> lasso = Some (rs, vs@dropWhileNot v rs), red = red s\\<rparr>\""], ["", "definition run_red_dfs \n    :: \"'v \\<Rightarrow> 'v blue_dfs_state \\<Rightarrow> ('v,unit) blue_dfs_state_ext nres\" \n    where\n    \"run_red_dfs u s \\<equiv> case lasso s of None \\<Rightarrow> do {\n             redS \\<leftarrow> red_dfs (red s) (\\<lambda>x. x = u \\<or> x \\<in> cyan s) u;\n             RETURN (mk_blue_witness s redS)\n           }\n          | _ \\<Rightarrow> NOOP s\""], ["", "text \\<open> Schwoon-Esparza extension \\<close>"], ["", "definition \"se_back_edge u v s \\<equiv> case lasso s of\n    None \\<Rightarrow> \n      \\<comment> \\<open>it's a back edge, so \\<open>u\\<close> and \\<open>v\\<close> are both on stack\\<close>\n      \\<comment> \\<open>we differentiate whether \\<open>u\\<close> or \\<open>v\\<close> is the 'culprit'\\<close>\n      \\<comment> \\<open>to generate a better counter example\\<close>\n      if accpt u then\n         let rs = rev (tl (stack s));\n             ur = rs;\n             ul = u#dropWhileNot v rs\n         in RETURN \\<lparr>lasso = Some (ur,ul), red = red s\\<rparr>\n      else if accpt v then\n         let rs = rev (stack s);\n             vr = takeWhileNot v rs;\n             vl = dropWhileNot v rs\n         in RETURN \\<lparr>lasso = Some (vr,vl), red = red s\\<rparr>\n      else NOOP s\n  | _ \\<Rightarrow> NOOP s\""], ["", "definition blue_dfs_params :: \"'v blue_dfs_param\"\n    where \"blue_dfs_params = \\<lparr>\n    on_init = RETURN \\<lparr> lasso = None, red = {} \\<rparr>,\n    on_new_root = \\<lambda>v0 s. NOOP s,\n    on_discover = \\<lambda>u v s. NOOP s,\n    on_finish = \\<lambda>u s. if accpt u then run_red_dfs u s else NOOP s,\n    on_back_edge = se_back_edge,\n    on_cross_edge = \\<lambda>u v s. NOOP s,\n    is_break = \\<lambda>s. lasso s \\<noteq> None \\<rparr>\""], ["", "schematic_goal blue_dfs_params_simps[simp]:\n    \"on_init blue_dfs_params = ?OI\"\n    \"on_new_root blue_dfs_params = ?ONR\"\n    \"on_discover blue_dfs_params = ?OD\"\n    \"on_finish blue_dfs_params = ?OF\"\n    \"on_back_edge blue_dfs_params = ?OBE\"\n    \"on_cross_edge blue_dfs_params = ?OCE\"\n    \"is_break blue_dfs_params = ?IB\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (on_init blue_dfs_params = ?OI &&&\n     on_new_root blue_dfs_params = ?ONR &&&\n     on_discover blue_dfs_params = ?OD) &&&\n    (on_finish blue_dfs_params = ?OF &&&\n     on_back_edge blue_dfs_params = ?OBE) &&&\n    on_cross_edge blue_dfs_params = ?OCE &&& is_break blue_dfs_params = ?IB", "unfolding blue_dfs_params_def gen_parameterization.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. (RETURN \\<lparr>lasso = None, red = {}\\<rparr> = ?OI &&&\n     (\\<lambda>v0. NOOP) = ?ONR &&& (\\<lambda>u v. NOOP) = ?OD) &&&\n    ((\\<lambda>u s. if accpt u then run_red_dfs u s else NOOP s) = ?OF &&&\n     se_back_edge = ?OBE) &&&\n    (\\<lambda>u v. NOOP) = ?OCE &&&\n    (\\<lambda>s. lasso s \\<noteq> None) = ?IB", "by (rule refl)+"], ["", "sublocale param_DFS_defs G blue_dfs_params"], ["proof (prove)\ngoal:\nNo subgoals!", "by unfold_locales"], ["", "end"], ["", "locale BlueDFS = BlueDFS_defs G accpt + param_DFS G blue_dfs_params\n  for G :: \"('v, 'more) graph_rec_scheme\" and accpt :: \"'v \\<Rightarrow> bool\""], ["", "lemma BlueDFSI: \n  assumes \"fb_graph G\" \n  shows \"BlueDFS G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. BlueDFS G", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. BlueDFS G", "interpret fb_graph G"], ["proof (prove)\ngoal (1 subgoal):\n 1. fb_graph G", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. BlueDFS G", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. BlueDFS G", "by unfold_locales"], ["proof (state)\nthis:\n  BlueDFS G\n\ngoal:\nNo subgoals!", "qed"], ["", "locale BlueDFS_invar = BlueDFS +\n  DFS_invar where param = blue_dfs_params"], ["", "context BlueDFS_defs begin"], ["", "lemma BlueDFS_invar_eq[simp]:\n  shows \"DFS_invar G blue_dfs_params s \\<longleftrightarrow> BlueDFS_invar G accpt s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DFS_invar G blue_dfs_params s = BlueDFS_invar G accpt s", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. DFS_invar G blue_dfs_params s \\<Longrightarrow> BlueDFS_invar G accpt s\n 2. BlueDFS_invar G accpt s \\<Longrightarrow> DFS_invar G blue_dfs_params s", "assume \"DFS_invar G blue_dfs_params s\""], ["proof (state)\nthis:\n  DFS_invar G blue_dfs_params s\n\ngoal (2 subgoals):\n 1. DFS_invar G blue_dfs_params s \\<Longrightarrow> BlueDFS_invar G accpt s\n 2. BlueDFS_invar G accpt s \\<Longrightarrow> DFS_invar G blue_dfs_params s", "interpret DFS_invar G blue_dfs_params s"], ["proof (prove)\ngoal (1 subgoal):\n 1. DFS_invar G blue_dfs_params s", "by fact"], ["proof (state)\ngoal (2 subgoals):\n 1. DFS_invar G blue_dfs_params s \\<Longrightarrow> BlueDFS_invar G accpt s\n 2. BlueDFS_invar G accpt s \\<Longrightarrow> DFS_invar G blue_dfs_params s", "show \"BlueDFS_invar G accpt s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. BlueDFS_invar G accpt s", "by unfold_locales"], ["proof (state)\nthis:\n  BlueDFS_invar G accpt s\n\ngoal (1 subgoal):\n 1. BlueDFS_invar G accpt s \\<Longrightarrow> DFS_invar G blue_dfs_params s", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. BlueDFS_invar G accpt s \\<Longrightarrow> DFS_invar G blue_dfs_params s", "assume \"BlueDFS_invar G accpt s\""], ["proof (state)\nthis:\n  BlueDFS_invar G accpt s\n\ngoal (1 subgoal):\n 1. BlueDFS_invar G accpt s \\<Longrightarrow> DFS_invar G blue_dfs_params s", "then"], ["proof (chain)\npicking this:\n  BlueDFS_invar G accpt s", "interpret BlueDFS_invar G accpt s"], ["proof (prove)\nusing this:\n  BlueDFS_invar G accpt s\n\ngoal (1 subgoal):\n 1. BlueDFS_invar G accpt s", "."], ["proof (state)\ngoal (1 subgoal):\n 1. BlueDFS_invar G accpt s \\<Longrightarrow> DFS_invar G blue_dfs_params s", "show \"DFS_invar G blue_dfs_params s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DFS_invar G blue_dfs_params s", "by unfold_locales"], ["proof (state)\nthis:\n  DFS_invar G blue_dfs_params s\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsection \\<open>Correctness Proof\\<close>"], ["", "context BlueDFS begin"], ["", "definition \"blue_basic_invar s \\<equiv> \n    case lasso s of\n      None \\<Rightarrow> restr_invar E (red s) (\\<lambda>x. x\\<in>set (stack s)) \n        \\<and> red s \\<subseteq> dom (finished s)\n    | Some l \\<Rightarrow> True\""], ["", "lemma (in BlueDFS_invar) red_DFS_precond_aux:\n    assumes BI: \"blue_basic_invar s\"\n    assumes [simp]: \"lasso s = None\"\n    assumes SNE: \"stack s \\<noteq> []\"\n    shows\n      \"fb_graph (G \\<lparr> g_V0 := {hd (stack s)} \\<rparr>)\"\n    and \"fb_graph (G \\<lparr> g_E := E \\<inter> UNIV \\<times> - red s, g_V0 := {hd (stack s)} \\<rparr>)\" \n    and \"restr_invar E (red s) (\\<lambda>x. x \\<in> set (stack s))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fb_graph (G\\<lparr>g_V0 := {hd (stack s)}\\<rparr>) &&&\n    fb_graph\n     (G\\<lparr>g_E := E \\<inter> UNIV \\<times> - red s,\n          g_V0 := {hd (stack s)}\\<rparr>) &&&\n    restr_invar E (red s) (\\<lambda>x. x \\<in> set (stack s))", "using stack_reachable \\<open>stack s \\<noteq> []\\<close>"], ["proof (prove)\nusing this:\n  set (stack s) \\<subseteq> reachable\n  stack s \\<noteq> []\n\ngoal (1 subgoal):\n 1. fb_graph (G\\<lparr>g_V0 := {hd (stack s)}\\<rparr>) &&&\n    fb_graph\n     (G\\<lparr>g_E := E \\<inter> UNIV \\<times> - red s,\n          g_V0 := {hd (stack s)}\\<rparr>) &&&\n    restr_invar E (red s) (\\<lambda>x. x \\<in> set (stack s))", "apply (rule_tac fb_graph_subset, auto) []"], ["proof (prove)\ngoal (2 subgoals):\n 1. fb_graph\n     (G\\<lparr>g_E := E \\<inter> UNIV \\<times> - red s,\n          g_V0 := {hd (stack s)}\\<rparr>)\n 2. restr_invar E (red s) (\\<lambda>x. x \\<in> set (stack s))", "using stack_reachable \\<open>stack s \\<noteq> []\\<close>"], ["proof (prove)\nusing this:\n  set (stack s) \\<subseteq> reachable\n  stack s \\<noteq> []\n\ngoal (2 subgoals):\n 1. fb_graph\n     (G\\<lparr>g_E := E \\<inter> UNIV \\<times> - red s,\n          g_V0 := {hd (stack s)}\\<rparr>)\n 2. restr_invar E (red s) (\\<lambda>x. x \\<in> set (stack s))", "apply (rule_tac fb_graph_subset, auto) []"], ["proof (prove)\ngoal (1 subgoal):\n 1. restr_invar E (red s) (\\<lambda>x. x \\<in> set (stack s))", "using BI"], ["proof (prove)\nusing this:\n  blue_basic_invar s\n\ngoal (1 subgoal):\n 1. restr_invar E (red s) (\\<lambda>x. x \\<in> set (stack s))", "apply (simp add: blue_basic_invar_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma (in BlueDFS_invar) red_dfs_pres_bbi:\n    assumes BI: \"blue_basic_invar s\"\n    assumes [simp]: \"lasso s = None\" and SNE: \"stack s \\<noteq> []\"\n    assumes \"pending s `` {hd (stack s)} = {}\"\n    shows \"run_red_dfs (hd (stack s)) (finish (hd (stack s)) s) \\<le>\\<^sub>n\n      SPEC (\\<lambda>e. \n        DFS_invar G blue_dfs_params (finish (hd (stack s)) s\\<lparr>state.more := e\\<rparr>) \n        \\<longrightarrow> blue_basic_invar (finish (hd (stack s)) s\\<lparr>state.more := e\\<rparr>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. run_red_dfs (hd (stack s)) (finish (hd (stack s)) s) \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>e.\n         DFS_invar G blue_dfs_params\n          (finish (hd (stack s)) s\n           \\<lparr>state.more := e\\<rparr>) \\<longrightarrow>\n         blue_basic_invar\n          (finish (hd (stack s)) s\\<lparr>state.more := e\\<rparr>))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. run_red_dfs (hd (stack s)) (finish (hd (stack s)) s) \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>e.\n         DFS_invar G blue_dfs_params\n          (finish (hd (stack s)) s\n           \\<lparr>state.more := e\\<rparr>) \\<longrightarrow>\n         blue_basic_invar\n          (finish (hd (stack s)) s\\<lparr>state.more := e\\<rparr>))", "have [simp]: \"(\\<lambda>x. x = hd (stack s) \\<or> x \\<in> cyan (finish (hd (stack s)) s)) = \n      (\\<lambda>x. x\\<in>set (stack s))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x.\n        x = hd (stack s) \\<or> x \\<in> cyan (finish (hd (stack s)) s)) =\n    (\\<lambda>x. x \\<in> set (stack s))", "using \\<open>stack s \\<noteq> []\\<close>"], ["proof (prove)\nusing this:\n  stack s \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<lambda>x.\n        x = hd (stack s) \\<or> x \\<in> cyan (finish (hd (stack s)) s)) =\n    (\\<lambda>x. x \\<in> set (stack s))", "unfolding finish_def cyan_def"], ["proof (prove)\nusing this:\n  stack s \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<lambda>x.\n        x = hd (stack s) \\<or>\n        x \\<in> set (stack\n                      (let f = finished s(hd (stack s) \\<mapsto> counter s);\n                           c = counter s + 1; st = tl (stack s)\n                       in s\\<lparr>finished := f, counter := c,\n                              stack := st\\<rparr>))) =\n    (\\<lambda>x. x \\<in> set (stack s))", "by (auto simp: neq_Nil_conv)"], ["proof (state)\nthis:\n  (\\<lambda>x.\n      x = hd (stack s) \\<or> x \\<in> cyan (finish (hd (stack s)) s)) =\n  (\\<lambda>x. x \\<in> set (stack s))\n\ngoal (1 subgoal):\n 1. run_red_dfs (hd (stack s)) (finish (hd (stack s)) s) \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>e.\n         DFS_invar G blue_dfs_params\n          (finish (hd (stack s)) s\n           \\<lparr>state.more := e\\<rparr>) \\<longrightarrow>\n         blue_basic_invar\n          (finish (hd (stack s)) s\\<lparr>state.more := e\\<rparr>))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. run_red_dfs (hd (stack s)) (finish (hd (stack s)) s) \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>e.\n         DFS_invar G blue_dfs_params\n          (finish (hd (stack s)) s\n           \\<lparr>state.more := e\\<rparr>) \\<longrightarrow>\n         blue_basic_invar\n          (finish (hd (stack s)) s\\<lparr>state.more := e\\<rparr>))", "unfolding run_red_dfs_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case lasso (finish (hd (stack s)) s) of\n     None \\<Rightarrow>\n       red_dfs (red (finish (hd (stack s)) s))\n        (\\<lambda>x.\n            x = hd (stack s) \\<or> x \\<in> cyan (finish (hd (stack s)) s))\n        (hd (stack s)) \\<bind>\n       (\\<lambda>redS.\n           RETURN (mk_blue_witness (finish (hd (stack s)) s) redS))\n     | Some a \\<Rightarrow> NOOP (finish (hd (stack s)) s)) \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>e.\n         DFS_invar G blue_dfs_params\n          (finish (hd (stack s)) s\n           \\<lparr>state.more := e\\<rparr>) \\<longrightarrow>\n         blue_basic_invar\n          (finish (hd (stack s)) s\\<lparr>state.more := e\\<rparr>))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. red_dfs (red s) (\\<lambda>x. x \\<in> set (stack s))\n     (hd (stack s)) \\<bind>\n    (\\<lambda>redS.\n        RETURN\n         (mk_blue_witness (finish (hd (stack s)) s) redS)) \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>e.\n         BlueDFS_invar G accpt\n          (finish (hd (stack s)) s\n           \\<lparr>state.more := e\\<rparr>) \\<longrightarrow>\n         blue_basic_invar\n          (finish (hd (stack s)) s\\<lparr>state.more := e\\<rparr>))", "apply (refine_vcg)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>fb_graph (G\\<lparr>g_V0 := {hd (stack s)}\\<rparr>) \\<and>\n                restr_invar (g_E (G\\<lparr>g_V0 := {hd (stack s)}\\<rparr>))\n                 (red s) (\\<lambda>x. x \\<in> set (stack s));\n        x \\<in> Collect\n                 (find_path1_restr_pred\n                   (G\\<lparr>g_V0 := {hd (stack s)}\\<rparr>)\n                   (\\<lambda>x. x \\<in> set (stack s)) (red s));\n        BlueDFS_invar G accpt\n         (finish (hd (stack s)) s\n          \\<lparr>state.more :=\n                    mk_blue_witness (finish (hd (stack s)) s)\n                     x\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> blue_basic_invar\n                          (finish (hd (stack s)) s\n                           \\<lparr>state.more :=\n                                     mk_blue_witness\n(finish (hd (stack s)) s) x\\<rparr>)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>fb_graph (G\\<lparr>g_V0 := {hd (stack s)}\\<rparr>) \\<and>\n                restr_invar E (red s) (\\<lambda>x. x \\<in> set (stack s));\n        find_path1_restr_pred (G\\<lparr>g_V0 := {hd (stack s)}\\<rparr>)\n         (\\<lambda>x. x \\<in> set (stack s)) (red s) x;\n        BlueDFS_invar G accpt\n         (finish (hd (stack s)) s\n          \\<lparr>state.more :=\n                    mk_blue_witness (finish (hd (stack s)) s)\n                     x\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> blue_basic_invar\n                          (finish (hd (stack s)) s\n                           \\<lparr>state.more :=\n                                     mk_blue_witness\n(finish (hd (stack s)) s) x\\<rparr>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>fb_graph (G\\<lparr>g_V0 := {hd (stack s)}\\<rparr>) \\<and>\n                restr_invar E (red s) (\\<lambda>x. x \\<in> set (stack s));\n        find_path1_restr_pred (G\\<lparr>g_V0 := {hd (stack s)}\\<rparr>)\n         (\\<lambda>x. x \\<in> set (stack s)) (red s) x;\n        BlueDFS_invar G accpt\n         (finish (hd (stack s)) s\n          \\<lparr>state.more :=\n                    mk_blue_witness (finish (hd (stack s)) s)\n                     x\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> blue_basic_invar\n                          (finish (hd (stack s)) s\n                           \\<lparr>state.more :=\n                                     mk_blue_witness\n(finish (hd (stack s)) s) x\\<rparr>)", "fix fp1"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>fb_graph (G\\<lparr>g_V0 := {hd (stack s)}\\<rparr>) \\<and>\n                restr_invar E (red s) (\\<lambda>x. x \\<in> set (stack s));\n        find_path1_restr_pred (G\\<lparr>g_V0 := {hd (stack s)}\\<rparr>)\n         (\\<lambda>x. x \\<in> set (stack s)) (red s) x;\n        BlueDFS_invar G accpt\n         (finish (hd (stack s)) s\n          \\<lparr>state.more :=\n                    mk_blue_witness (finish (hd (stack s)) s)\n                     x\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> blue_basic_invar\n                          (finish (hd (stack s)) s\n                           \\<lparr>state.more :=\n                                     mk_blue_witness\n(finish (hd (stack s)) s) x\\<rparr>)", "define s' where \"s' = finish (hd (stack s)) s\""], ["proof (state)\nthis:\n  s' = finish (hd (stack s)) s\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>fb_graph (G\\<lparr>g_V0 := {hd (stack s)}\\<rparr>) \\<and>\n                restr_invar E (red s) (\\<lambda>x. x \\<in> set (stack s));\n        find_path1_restr_pred (G\\<lparr>g_V0 := {hd (stack s)}\\<rparr>)\n         (\\<lambda>x. x \\<in> set (stack s)) (red s) x;\n        BlueDFS_invar G accpt\n         (finish (hd (stack s)) s\n          \\<lparr>state.more :=\n                    mk_blue_witness (finish (hd (stack s)) s)\n                     x\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> blue_basic_invar\n                          (finish (hd (stack s)) s\n                           \\<lparr>state.more :=\n                                     mk_blue_witness\n(finish (hd (stack s)) s) x\\<rparr>)", "assume FP_spec: \n        \"find_path1_restr_pred (G \\<lparr> g_V0 := {hd (stack s)} \\<rparr>) (\\<lambda>x. x \\<in> set (stack s)) (red s) fp1\""], ["proof (state)\nthis:\n  find_path1_restr_pred (G\\<lparr>g_V0 := {hd (stack s)}\\<rparr>)\n   (\\<lambda>x. x \\<in> set (stack s)) (red s) fp1\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>fb_graph (G\\<lparr>g_V0 := {hd (stack s)}\\<rparr>) \\<and>\n                restr_invar E (red s) (\\<lambda>x. x \\<in> set (stack s));\n        find_path1_restr_pred (G\\<lparr>g_V0 := {hd (stack s)}\\<rparr>)\n         (\\<lambda>x. x \\<in> set (stack s)) (red s) x;\n        BlueDFS_invar G accpt\n         (finish (hd (stack s)) s\n          \\<lparr>state.more :=\n                    mk_blue_witness (finish (hd (stack s)) s)\n                     x\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> blue_basic_invar\n                          (finish (hd (stack s)) s\n                           \\<lparr>state.more :=\n                                     mk_blue_witness\n(finish (hd (stack s)) s) x\\<rparr>)", "assume \"BlueDFS_invar G accpt (s'\\<lparr>state.more := mk_blue_witness s' fp1\\<rparr>)\""], ["proof (state)\nthis:\n  BlueDFS_invar G accpt\n   (s'\\<lparr>state.more := mk_blue_witness s' fp1\\<rparr>)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>fb_graph (G\\<lparr>g_V0 := {hd (stack s)}\\<rparr>) \\<and>\n                restr_invar E (red s) (\\<lambda>x. x \\<in> set (stack s));\n        find_path1_restr_pred (G\\<lparr>g_V0 := {hd (stack s)}\\<rparr>)\n         (\\<lambda>x. x \\<in> set (stack s)) (red s) x;\n        BlueDFS_invar G accpt\n         (finish (hd (stack s)) s\n          \\<lparr>state.more :=\n                    mk_blue_witness (finish (hd (stack s)) s)\n                     x\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> blue_basic_invar\n                          (finish (hd (stack s)) s\n                           \\<lparr>state.more :=\n                                     mk_blue_witness\n(finish (hd (stack s)) s) x\\<rparr>)", "then"], ["proof (chain)\npicking this:\n  BlueDFS_invar G accpt\n   (s'\\<lparr>state.more := mk_blue_witness s' fp1\\<rparr>)", "interpret i: BlueDFS_invar G accpt \"(s'\\<lparr>state.more := mk_blue_witness s' fp1\\<rparr>)\""], ["proof (prove)\nusing this:\n  BlueDFS_invar G accpt\n   (s'\\<lparr>state.more := mk_blue_witness s' fp1\\<rparr>)\n\ngoal (1 subgoal):\n 1. BlueDFS_invar G accpt\n     (s'\\<lparr>state.more := mk_blue_witness s' fp1\\<rparr>)", "by simp"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>fb_graph (G\\<lparr>g_V0 := {hd (stack s)}\\<rparr>) \\<and>\n                restr_invar E (red s) (\\<lambda>x. x \\<in> set (stack s));\n        find_path1_restr_pred (G\\<lparr>g_V0 := {hd (stack s)}\\<rparr>)\n         (\\<lambda>x. x \\<in> set (stack s)) (red s) x;\n        BlueDFS_invar G accpt\n         (finish (hd (stack s)) s\n          \\<lparr>state.more :=\n                    mk_blue_witness (finish (hd (stack s)) s)\n                     x\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> blue_basic_invar\n                          (finish (hd (stack s)) s\n                           \\<lparr>state.more :=\n                                     mk_blue_witness\n(finish (hd (stack s)) s) x\\<rparr>)", "have [simp]: \n        \"red s' = red s\" \n        \"discovered s' = discovered s\" \n        \"dom (finished s') = insert (hd (stack s)) (dom (finished s))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. red s' = red s &&&\n    discovered s' = discovered s &&&\n    dom (finished s') = insert (hd (stack s)) (dom (finished s))", "unfolding s'_def finish_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. red (let f = finished s(hd (stack s) \\<mapsto> counter s);\n             c = counter s + 1; st = tl (stack s)\n         in s\\<lparr>finished := f, counter := c, stack := st\\<rparr>) =\n    red s &&&\n    discovered\n     (let f = finished s(hd (stack s) \\<mapsto> counter s);\n          c = counter s + 1; st = tl (stack s)\n      in s\\<lparr>finished := f, counter := c, stack := st\\<rparr>) =\n    discovered s &&&\n    dom (finished\n          (let f = finished s(hd (stack s) \\<mapsto> counter s);\n               c = counter s + 1; st = tl (stack s)\n           in s\\<lparr>finished := f, counter := c, stack := st\\<rparr>)) =\n    insert (hd (stack s)) (dom (finished s))", "by auto"], ["proof (state)\nthis:\n  red s' = red s\n  discovered s' = discovered s\n  dom (finished s') = insert (hd (stack s)) (dom (finished s))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>fb_graph (G\\<lparr>g_V0 := {hd (stack s)}\\<rparr>) \\<and>\n                restr_invar E (red s) (\\<lambda>x. x \\<in> set (stack s));\n        find_path1_restr_pred (G\\<lparr>g_V0 := {hd (stack s)}\\<rparr>)\n         (\\<lambda>x. x \\<in> set (stack s)) (red s) x;\n        BlueDFS_invar G accpt\n         (finish (hd (stack s)) s\n          \\<lparr>state.more :=\n                    mk_blue_witness (finish (hd (stack s)) s)\n                     x\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> blue_basic_invar\n                          (finish (hd (stack s)) s\n                           \\<lparr>state.more :=\n                                     mk_blue_witness\n(finish (hd (stack s)) s) x\\<rparr>)", "{"], ["proof (state)\nthis:\n  red s' = red s\n  discovered s' = discovered s\n  dom (finished s') = insert (hd (stack s)) (dom (finished s))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>fb_graph (G\\<lparr>g_V0 := {hd (stack s)}\\<rparr>) \\<and>\n                restr_invar E (red s) (\\<lambda>x. x \\<in> set (stack s));\n        find_path1_restr_pred (G\\<lparr>g_V0 := {hd (stack s)}\\<rparr>)\n         (\\<lambda>x. x \\<in> set (stack s)) (red s) x;\n        BlueDFS_invar G accpt\n         (finish (hd (stack s)) s\n          \\<lparr>state.more :=\n                    mk_blue_witness (finish (hd (stack s)) s)\n                     x\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> blue_basic_invar\n                          (finish (hd (stack s)) s\n                           \\<lparr>state.more :=\n                                     mk_blue_witness\n(finish (hd (stack s)) s) x\\<rparr>)", "fix R'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>fb_graph (G\\<lparr>g_V0 := {hd (stack s)}\\<rparr>) \\<and>\n                restr_invar E (red s) (\\<lambda>x. x \\<in> set (stack s));\n        find_path1_restr_pred (G\\<lparr>g_V0 := {hd (stack s)}\\<rparr>)\n         (\\<lambda>x. x \\<in> set (stack s)) (red s) x;\n        BlueDFS_invar G accpt\n         (finish (hd (stack s)) s\n          \\<lparr>state.more :=\n                    mk_blue_witness (finish (hd (stack s)) s)\n                     x\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> blue_basic_invar\n                          (finish (hd (stack s)) s\n                           \\<lparr>state.more :=\n                                     mk_blue_witness\n(finish (hd (stack s)) s) x\\<rparr>)", "assume [simp]: \"fp1 = Inl R'\""], ["proof (state)\nthis:\n  fp1 = Inl R'\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>fb_graph (G\\<lparr>g_V0 := {hd (stack s)}\\<rparr>) \\<and>\n                restr_invar E (red s) (\\<lambda>x. x \\<in> set (stack s));\n        find_path1_restr_pred (G\\<lparr>g_V0 := {hd (stack s)}\\<rparr>)\n         (\\<lambda>x. x \\<in> set (stack s)) (red s) x;\n        BlueDFS_invar G accpt\n         (finish (hd (stack s)) s\n          \\<lparr>state.more :=\n                    mk_blue_witness (finish (hd (stack s)) s)\n                     x\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> blue_basic_invar\n                          (finish (hd (stack s)) s\n                           \\<lparr>state.more :=\n                                     mk_blue_witness\n(finish (hd (stack s)) s) x\\<rparr>)", "from FP_spec[unfolded find_path1_restr_pred_def, simplified]"], ["proof (chain)\npicking this:\n  R' = red s \\<union> E\\<^sup>+ `` {hd (stack s)} \\<and>\n  restr_invar E R' (\\<lambda>x. x \\<in> set (stack s))", "have \n          R'FMT: \"R' = red s \\<union> E\\<^sup>+ `` {hd (stack s)}\" \n          and RI: \"restr_invar E R' (\\<lambda>x. x \\<in> set (stack s))\""], ["proof (prove)\nusing this:\n  R' = red s \\<union> E\\<^sup>+ `` {hd (stack s)} \\<and>\n  restr_invar E R' (\\<lambda>x. x \\<in> set (stack s))\n\ngoal (1 subgoal):\n 1. R' = red s \\<union> E\\<^sup>+ `` {hd (stack s)} &&&\n    restr_invar E R' (\\<lambda>x. x \\<in> set (stack s))", "by auto"], ["proof (state)\nthis:\n  R' = red s \\<union> E\\<^sup>+ `` {hd (stack s)}\n  restr_invar E R' (\\<lambda>x. x \\<in> set (stack s))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>fb_graph (G\\<lparr>g_V0 := {hd (stack s)}\\<rparr>) \\<and>\n                restr_invar E (red s) (\\<lambda>x. x \\<in> set (stack s));\n        find_path1_restr_pred (G\\<lparr>g_V0 := {hd (stack s)}\\<rparr>)\n         (\\<lambda>x. x \\<in> set (stack s)) (red s) x;\n        BlueDFS_invar G accpt\n         (finish (hd (stack s)) s\n          \\<lparr>state.more :=\n                    mk_blue_witness (finish (hd (stack s)) s)\n                     x\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> blue_basic_invar\n                          (finish (hd (stack s)) s\n                           \\<lparr>state.more :=\n                                     mk_blue_witness\n(finish (hd (stack s)) s) x\\<rparr>)", "from BI"], ["proof (chain)\npicking this:\n  blue_basic_invar s", "have \"red s \\<subseteq> dom (finished s)\""], ["proof (prove)\nusing this:\n  blue_basic_invar s\n\ngoal (1 subgoal):\n 1. red s \\<subseteq> dom (finished s)", "unfolding blue_basic_invar_def"], ["proof (prove)\nusing this:\n  case lasso s of\n  None \\<Rightarrow>\n    restr_invar E (red s) (\\<lambda>x. x \\<in> set (stack s)) \\<and>\n    red s \\<subseteq> dom (finished s)\n  | Some l \\<Rightarrow> True\n\ngoal (1 subgoal):\n 1. red s \\<subseteq> dom (finished s)", "by auto"], ["proof (state)\nthis:\n  red s \\<subseteq> dom (finished s)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>fb_graph (G\\<lparr>g_V0 := {hd (stack s)}\\<rparr>) \\<and>\n                restr_invar E (red s) (\\<lambda>x. x \\<in> set (stack s));\n        find_path1_restr_pred (G\\<lparr>g_V0 := {hd (stack s)}\\<rparr>)\n         (\\<lambda>x. x \\<in> set (stack s)) (red s) x;\n        BlueDFS_invar G accpt\n         (finish (hd (stack s)) s\n          \\<lparr>state.more :=\n                    mk_blue_witness (finish (hd (stack s)) s)\n                     x\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> blue_basic_invar\n                          (finish (hd (stack s)) s\n                           \\<lparr>state.more :=\n                                     mk_blue_witness\n(finish (hd (stack s)) s) x\\<rparr>)", "also"], ["proof (state)\nthis:\n  red s \\<subseteq> dom (finished s)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>fb_graph (G\\<lparr>g_V0 := {hd (stack s)}\\<rparr>) \\<and>\n                restr_invar E (red s) (\\<lambda>x. x \\<in> set (stack s));\n        find_path1_restr_pred (G\\<lparr>g_V0 := {hd (stack s)}\\<rparr>)\n         (\\<lambda>x. x \\<in> set (stack s)) (red s) x;\n        BlueDFS_invar G accpt\n         (finish (hd (stack s)) s\n          \\<lparr>state.more :=\n                    mk_blue_witness (finish (hd (stack s)) s)\n                     x\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> blue_basic_invar\n                          (finish (hd (stack s)) s\n                           \\<lparr>state.more :=\n                                     mk_blue_witness\n(finish (hd (stack s)) s) x\\<rparr>)", "have \"E\\<^sup>+ `` {hd (stack s)} \\<subseteq> dom (finished s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. E\\<^sup>+ `` {hd (stack s)} \\<subseteq> dom (finished s)", "proof (intro subsetI, elim ImageE, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>(hd (stack s), x) \\<in> E\\<^sup>+;\n        xa = hd (stack s)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> dom (finished s)", "fix v"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>(hd (stack s), x) \\<in> E\\<^sup>+;\n        xa = hd (stack s)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> dom (finished s)", "assume \"(hd (stack s),v)\\<in>E\\<^sup>+\""], ["proof (state)\nthis:\n  (hd (stack s), v) \\<in> E\\<^sup>+\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>(hd (stack s), x) \\<in> E\\<^sup>+;\n        xa = hd (stack s)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> dom (finished s)", "then"], ["proof (chain)\npicking this:\n  (hd (stack s), v) \\<in> E\\<^sup>+", "obtain u where \"(hd (stack s),u)\\<in>E\" and \"(u,v)\\<in>E\\<^sup>*\""], ["proof (prove)\nusing this:\n  (hd (stack s), v) \\<in> E\\<^sup>+\n\ngoal (1 subgoal):\n 1. (\\<And>u.\n        \\<lbrakk>(hd (stack s), u) \\<in> E; (u, v) \\<in> E\\<^sup>*\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: trancl_unfold_left)"], ["proof (state)\nthis:\n  (hd (stack s), u) \\<in> E\n  (u, v) \\<in> E\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>(hd (stack s), x) \\<in> E\\<^sup>+;\n        xa = hd (stack s)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> dom (finished s)", "from RI"], ["proof (chain)\npicking this:\n  restr_invar E R' (\\<lambda>x. x \\<in> set (stack s))", "have NR: \"E\\<^sup>+ `` {hd (stack s)} \\<inter> set (stack s) = {}\""], ["proof (prove)\nusing this:\n  restr_invar E R' (\\<lambda>x. x \\<in> set (stack s))\n\ngoal (1 subgoal):\n 1. E\\<^sup>+ `` {hd (stack s)} \\<inter> set (stack s) = {}", "unfolding restr_invar_def"], ["proof (prove)\nusing this:\n  E `` R' \\<subseteq> R' \\<and> R' \\<inter> {x. x \\<in> set (stack s)} = {}\n\ngoal (1 subgoal):\n 1. E\\<^sup>+ `` {hd (stack s)} \\<inter> set (stack s) = {}", "by (auto simp: R'FMT)"], ["proof (state)\nthis:\n  E\\<^sup>+ `` {hd (stack s)} \\<inter> set (stack s) = {}\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>(hd (stack s), x) \\<in> E\\<^sup>+;\n        xa = hd (stack s)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> dom (finished s)", "with \\<open>(hd (stack s),u)\\<in>E\\<close>"], ["proof (chain)\npicking this:\n  (hd (stack s), u) \\<in> E\n  E\\<^sup>+ `` {hd (stack s)} \\<inter> set (stack s) = {}", "have \"u\\<notin>set (stack s)\""], ["proof (prove)\nusing this:\n  (hd (stack s), u) \\<in> E\n  E\\<^sup>+ `` {hd (stack s)} \\<inter> set (stack s) = {}\n\ngoal (1 subgoal):\n 1. u \\<notin> set (stack s)", "by auto"], ["proof (state)\nthis:\n  u \\<notin> set (stack s)\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>(hd (stack s), x) \\<in> E\\<^sup>+;\n        xa = hd (stack s)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> dom (finished s)", "with i.finished_closed[simplified] \\<open>(hd (stack s),u)\\<in>E\\<close>"], ["proof (chain)\npicking this:\n  E `` insert (hd (stack s)) (dom (finished s))\n  \\<subseteq> dom (discovered s)\n  (hd (stack s), u) \\<in> E\n  u \\<notin> set (stack s)", "have UID: \"u\\<in>dom (finished s)\""], ["proof (prove)\nusing this:\n  E `` insert (hd (stack s)) (dom (finished s))\n  \\<subseteq> dom (discovered s)\n  (hd (stack s), u) \\<in> E\n  u \\<notin> set (stack s)\n\ngoal (1 subgoal):\n 1. u \\<in> dom (finished s)", "by (auto simp: stack_set_def)"], ["proof (state)\nthis:\n  u \\<in> dom (finished s)\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>(hd (stack s), x) \\<in> E\\<^sup>+;\n        xa = hd (stack s)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> dom (finished s)", "from NR \\<open>(hd (stack s),u)\\<in>E\\<close>"], ["proof (chain)\npicking this:\n  E\\<^sup>+ `` {hd (stack s)} \\<inter> set (stack s) = {}\n  (hd (stack s), u) \\<in> E", "have NR': \"E\\<^sup>*``{u} \\<inter> set (stack s) = {}\""], ["proof (prove)\nusing this:\n  E\\<^sup>+ `` {hd (stack s)} \\<inter> set (stack s) = {}\n  (hd (stack s), u) \\<in> E\n\ngoal (1 subgoal):\n 1. E\\<^sup>* `` {u} \\<inter> set (stack s) = {}", "by (auto simp: trancl_unfold_left)"], ["proof (state)\nthis:\n  E\\<^sup>* `` {u} \\<inter> set (stack s) = {}\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>(hd (stack s), x) \\<in> E\\<^sup>+;\n        xa = hd (stack s)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> dom (finished s)", "have CL: \"E `` dom (finished s) \\<subseteq> dom (finished s) \\<union> set (stack s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. E `` dom (finished s)\n    \\<subseteq> dom (finished s) \\<union> set (stack s)", "using finished_closed discovered_eq_finished_un_stack"], ["proof (prove)\nusing this:\n  E `` dom (finished s) \\<subseteq> dom (discovered s)\n  dom (discovered s) = dom (finished s) \\<union> set (stack s)\n\ngoal (1 subgoal):\n 1. E `` dom (finished s)\n    \\<subseteq> dom (finished s) \\<union> set (stack s)", "by simp"], ["proof (state)\nthis:\n  E `` dom (finished s) \\<subseteq> dom (finished s) \\<union> set (stack s)\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>(hd (stack s), x) \\<in> E\\<^sup>+;\n        xa = hd (stack s)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> dom (finished s)", "from closed_restrict_aux[OF CL NR'] UID"], ["proof (chain)\npicking this:\n  {u} \\<subseteq> dom (finished s) \\<Longrightarrow>\n  E\\<^sup>* `` {u} \\<subseteq> dom (finished s)\n  u \\<in> dom (finished s)", "have \"E\\<^sup>* `` {u} \\<subseteq> dom (finished s)\""], ["proof (prove)\nusing this:\n  {u} \\<subseteq> dom (finished s) \\<Longrightarrow>\n  E\\<^sup>* `` {u} \\<subseteq> dom (finished s)\n  u \\<in> dom (finished s)\n\ngoal (1 subgoal):\n 1. E\\<^sup>* `` {u} \\<subseteq> dom (finished s)", "by simp"], ["proof (state)\nthis:\n  E\\<^sup>* `` {u} \\<subseteq> dom (finished s)\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>(hd (stack s), x) \\<in> E\\<^sup>+;\n        xa = hd (stack s)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> dom (finished s)", "with \\<open>(u,v)\\<in>E\\<^sup>*\\<close>"], ["proof (chain)\npicking this:\n  (u, v) \\<in> E\\<^sup>*\n  E\\<^sup>* `` {u} \\<subseteq> dom (finished s)", "show \"v \\<in> dom (finished s)\""], ["proof (prove)\nusing this:\n  (u, v) \\<in> E\\<^sup>*\n  E\\<^sup>* `` {u} \\<subseteq> dom (finished s)\n\ngoal (1 subgoal):\n 1. v \\<in> dom (finished s)", "by auto"], ["proof (state)\nthis:\n  v \\<in> dom (finished s)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  E\\<^sup>+ `` {hd (stack s)} \\<subseteq> dom (finished s)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>fb_graph (G\\<lparr>g_V0 := {hd (stack s)}\\<rparr>) \\<and>\n                restr_invar E (red s) (\\<lambda>x. x \\<in> set (stack s));\n        find_path1_restr_pred (G\\<lparr>g_V0 := {hd (stack s)}\\<rparr>)\n         (\\<lambda>x. x \\<in> set (stack s)) (red s) x;\n        BlueDFS_invar G accpt\n         (finish (hd (stack s)) s\n          \\<lparr>state.more :=\n                    mk_blue_witness (finish (hd (stack s)) s)\n                     x\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> blue_basic_invar\n                          (finish (hd (stack s)) s\n                           \\<lparr>state.more :=\n                                     mk_blue_witness\n(finish (hd (stack s)) s) x\\<rparr>)", "finally (sup_least)"], ["proof (chain)\npicking this:\n  red s \\<union> E\\<^sup>+ `` {hd (stack s)} \\<subseteq> dom (finished s)", "have \"R' \\<subseteq> dom (finished s) \\<and> red s \\<subseteq> dom (finished s)\""], ["proof (prove)\nusing this:\n  red s \\<union> E\\<^sup>+ `` {hd (stack s)} \\<subseteq> dom (finished s)\n\ngoal (1 subgoal):\n 1. R' \\<subseteq> dom (finished s) \\<and>\n    red s \\<subseteq> dom (finished s)", "by (simp add: R'FMT)"], ["proof (state)\nthis:\n  R' \\<subseteq> dom (finished s) \\<and> red s \\<subseteq> dom (finished s)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>fb_graph (G\\<lparr>g_V0 := {hd (stack s)}\\<rparr>) \\<and>\n                restr_invar E (red s) (\\<lambda>x. x \\<in> set (stack s));\n        find_path1_restr_pred (G\\<lparr>g_V0 := {hd (stack s)}\\<rparr>)\n         (\\<lambda>x. x \\<in> set (stack s)) (red s) x;\n        BlueDFS_invar G accpt\n         (finish (hd (stack s)) s\n          \\<lparr>state.more :=\n                    mk_blue_witness (finish (hd (stack s)) s)\n                     x\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> blue_basic_invar\n                          (finish (hd (stack s)) s\n                           \\<lparr>state.more :=\n                                     mk_blue_witness\n(finish (hd (stack s)) s) x\\<rparr>)", "}"], ["proof (state)\nthis:\n  fp1 = Inl ?R'10 \\<Longrightarrow>\n  ?R'10 \\<subseteq> dom (finished s) \\<and>\n  red s \\<subseteq> dom (finished s)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>fb_graph (G\\<lparr>g_V0 := {hd (stack s)}\\<rparr>) \\<and>\n                restr_invar E (red s) (\\<lambda>x. x \\<in> set (stack s));\n        find_path1_restr_pred (G\\<lparr>g_V0 := {hd (stack s)}\\<rparr>)\n         (\\<lambda>x. x \\<in> set (stack s)) (red s) x;\n        BlueDFS_invar G accpt\n         (finish (hd (stack s)) s\n          \\<lparr>state.more :=\n                    mk_blue_witness (finish (hd (stack s)) s)\n                     x\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> blue_basic_invar\n                          (finish (hd (stack s)) s\n                           \\<lparr>state.more :=\n                                     mk_blue_witness\n(finish (hd (stack s)) s) x\\<rparr>)", "note aux1 = this"], ["proof (state)\nthis:\n  fp1 = Inl ?R'10 \\<Longrightarrow>\n  ?R'10 \\<subseteq> dom (finished s) \\<and>\n  red s \\<subseteq> dom (finished s)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>fb_graph (G\\<lparr>g_V0 := {hd (stack s)}\\<rparr>) \\<and>\n                restr_invar E (red s) (\\<lambda>x. x \\<in> set (stack s));\n        find_path1_restr_pred (G\\<lparr>g_V0 := {hd (stack s)}\\<rparr>)\n         (\\<lambda>x. x \\<in> set (stack s)) (red s) x;\n        BlueDFS_invar G accpt\n         (finish (hd (stack s)) s\n          \\<lparr>state.more :=\n                    mk_blue_witness (finish (hd (stack s)) s)\n                     x\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> blue_basic_invar\n                          (finish (hd (stack s)) s\n                           \\<lparr>state.more :=\n                                     mk_blue_witness\n(finish (hd (stack s)) s) x\\<rparr>)", "show \"blue_basic_invar (s'\\<lparr>state.more := mk_blue_witness s' fp1\\<rparr>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. blue_basic_invar\n     (s'\\<lparr>state.more := mk_blue_witness s' fp1\\<rparr>)", "unfolding blue_basic_invar_def mk_blue_witness_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. case lasso\n          (s'\\<lparr>state.more :=\n                       case fp1 of\n                       Inl R' \\<Rightarrow>\n                         \\<lparr>lasso = None, red = R'\\<rparr>\n                       | Inr (vs, v) \\<Rightarrow>\n                           let rs = rev (stack s')\n                           in \\<lparr>lasso =\n  Some (rs, vs @ dropWhileNot v rs),\n                                 red = red s'\\<rparr>\\<rparr>) of\n    None \\<Rightarrow>\n      restr_invar E\n       (red (s'\\<lparr>state.more :=\n                         case fp1 of\n                         Inl R' \\<Rightarrow>\n                           \\<lparr>lasso = None, red = R'\\<rparr>\n                         | Inr (vs, v) \\<Rightarrow>\n                             let rs = rev (stack s')\n                             in \\<lparr>lasso =\n    Some (rs, vs @ dropWhileNot v rs),\n                                   red = red s'\\<rparr>\\<rparr>))\n       (\\<lambda>x.\n           x \\<in> set (stack\n                         (s'\\<lparr>state.more :=\ncase fp1 of Inl R' \\<Rightarrow> \\<lparr>lasso = None, red = R'\\<rparr>\n| Inr (vs, v) \\<Rightarrow>\n    let rs = rev (stack s')\n    in \\<lparr>lasso = Some (rs, vs @ dropWhileNot v rs),\n          red = red s'\\<rparr>\\<rparr>))) \\<and>\n      red (s'\\<lparr>state.more :=\n                       case fp1 of\n                       Inl R' \\<Rightarrow>\n                         \\<lparr>lasso = None, red = R'\\<rparr>\n                       | Inr (vs, v) \\<Rightarrow>\n                           let rs = rev (stack s')\n                           in \\<lparr>lasso =\n  Some (rs, vs @ dropWhileNot v rs),\n                                 red = red s'\\<rparr>\\<rparr>)\n      \\<subseteq> dom (finished\n                        (s'\\<lparr>state.more :=\n                                     case fp1 of\n                                     Inl R' \\<Rightarrow>\n \\<lparr>lasso = None, red = R'\\<rparr>\n                                     | Inr (vs, v) \\<Rightarrow>\n   let rs = rev (stack s')\n   in \\<lparr>lasso = Some (rs, vs @ dropWhileNot v rs),\n         red = red s'\\<rparr>\\<rparr>))\n    | Some l \\<Rightarrow> True", "apply (simp split: option.splits sum.splits)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x1.\n       fp1 = Inl x1 \\<longrightarrow>\n       restr_invar E x1 (\\<lambda>x. x \\<in> set (stack s')) \\<and>\n       x1 \\<subseteq> insert (hd (stack s)) (dom (finished s))", "apply (intro allI conjI impI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       fp1 = Inl x1 \\<Longrightarrow>\n       restr_invar E x1 (\\<lambda>x. x \\<in> set (stack s'))\n 2. \\<And>x1.\n       fp1 = Inl x1 \\<Longrightarrow>\n       x1 \\<subseteq> insert (hd (stack s)) (dom (finished s))", "using FP_spec SNE"], ["proof (prove)\nusing this:\n  find_path1_restr_pred (G\\<lparr>g_V0 := {hd (stack s)}\\<rparr>)\n   (\\<lambda>x. x \\<in> set (stack s)) (red s) fp1\n  stack s \\<noteq> []\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       fp1 = Inl x1 \\<Longrightarrow>\n       restr_invar E x1 (\\<lambda>x. x \\<in> set (stack s'))\n 2. \\<And>x1.\n       fp1 = Inl x1 \\<Longrightarrow>\n       x1 \\<subseteq> insert (hd (stack s)) (dom (finished s))", "apply (auto \n          simp: s'_def blue_basic_invar_def find_path1_restr_pred_def\n          simp: restr_invar_def\n          simp: neq_Nil_conv) []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1.\n       fp1 = Inl x1 \\<Longrightarrow>\n       x1 \\<subseteq> insert (hd (stack s)) (dom (finished s))", "apply (auto dest!: aux1) []"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  blue_basic_invar (s'\\<lparr>state.more := mk_blue_witness s' fp1\\<rparr>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  run_red_dfs (hd (stack s)) (finish (hd (stack s)) s) \\<le>\\<^sub>n\n  SPEC\n   (\\<lambda>e.\n       DFS_invar G blue_dfs_params\n        (finish (hd (stack s)) s\n         \\<lparr>state.more := e\\<rparr>) \\<longrightarrow>\n       blue_basic_invar\n        (finish (hd (stack s)) s\\<lparr>state.more := e\\<rparr>))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma blue_basic_invar: \"is_invar blue_basic_invar\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_invar blue_basic_invar", "proof (induct rule: establish_invarI)"], ["proof (state)\ngoal (6 subgoals):\n 1. on_init blue_dfs_params \\<le>\\<^sub>n\n    SPEC (\\<lambda>x. blue_basic_invar (empty_state x))\n 2. \\<And>s s' v0.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; blue_basic_invar s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s = []; v0 \\<in> V0;\n        v0 \\<notin> dom (discovered s); s' = new_root v0 s\\<rbrakk>\n       \\<Longrightarrow> on_new_root blue_dfs_params v0 s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              blue_basic_invar\n                               (s'\\<lparr>state.more := x\\<rparr>))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; blue_basic_invar s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish blue_dfs_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              blue_basic_invar\n                               (s'\\<lparr>state.more := x\\<rparr>))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; blue_basic_invar s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              blue_basic_invar\n                               (s'\\<lparr>state.more := x\\<rparr>))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; blue_basic_invar s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              blue_basic_invar\n                               (s'\\<lparr>state.more := x\\<rparr>))\n 6. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; blue_basic_invar s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<notin> dom (discovered s);\n        s' =\n        discover u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              blue_basic_invar\n                               (s'\\<lparr>state.more := x\\<rparr>))", "case (finish s)"], ["proof (state)\nthis:\n  DFS_invar G blue_dfs_params s\n  blue_basic_invar s\n  cond s\n  \\<not> is_break blue_dfs_params s\n  stack s \\<noteq> []\n  u_ = hd (stack s)\n  pending s `` {u_} = {}\n  s'_ = finish u_ s\n\ngoal (6 subgoals):\n 1. on_init blue_dfs_params \\<le>\\<^sub>n\n    SPEC (\\<lambda>x. blue_basic_invar (empty_state x))\n 2. \\<And>s s' v0.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; blue_basic_invar s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s = []; v0 \\<in> V0;\n        v0 \\<notin> dom (discovered s); s' = new_root v0 s\\<rbrakk>\n       \\<Longrightarrow> on_new_root blue_dfs_params v0 s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              blue_basic_invar\n                               (s'\\<lparr>state.more := x\\<rparr>))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; blue_basic_invar s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish blue_dfs_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              blue_basic_invar\n                               (s'\\<lparr>state.more := x\\<rparr>))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; blue_basic_invar s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              blue_basic_invar\n                               (s'\\<lparr>state.more := x\\<rparr>))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; blue_basic_invar s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              blue_basic_invar\n                               (s'\\<lparr>state.more := x\\<rparr>))\n 6. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; blue_basic_invar s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<notin> dom (discovered s);\n        s' =\n        discover u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              blue_basic_invar\n                               (s'\\<lparr>state.more := x\\<rparr>))", "then"], ["proof (chain)\npicking this:\n  DFS_invar G blue_dfs_params s\n  blue_basic_invar s\n  cond s\n  \\<not> is_break blue_dfs_params s\n  stack s \\<noteq> []\n  u_ = hd (stack s)\n  pending s `` {u_} = {}\n  s'_ = finish u_ s", "interpret BlueDFS_invar where s=s"], ["proof (prove)\nusing this:\n  DFS_invar G blue_dfs_params s\n  blue_basic_invar s\n  cond s\n  \\<not> is_break blue_dfs_params s\n  stack s \\<noteq> []\n  u_ = hd (stack s)\n  pending s `` {u_} = {}\n  s'_ = finish u_ s\n\ngoal (1 subgoal):\n 1. BlueDFS_invar G accpt s", "by simp"], ["proof (state)\ngoal (6 subgoals):\n 1. on_init blue_dfs_params \\<le>\\<^sub>n\n    SPEC (\\<lambda>x. blue_basic_invar (empty_state x))\n 2. \\<And>s s' v0.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; blue_basic_invar s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s = []; v0 \\<in> V0;\n        v0 \\<notin> dom (discovered s); s' = new_root v0 s\\<rbrakk>\n       \\<Longrightarrow> on_new_root blue_dfs_params v0 s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              blue_basic_invar\n                               (s'\\<lparr>state.more := x\\<rparr>))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; blue_basic_invar s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish blue_dfs_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              blue_basic_invar\n                               (s'\\<lparr>state.more := x\\<rparr>))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; blue_basic_invar s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              blue_basic_invar\n                               (s'\\<lparr>state.more := x\\<rparr>))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; blue_basic_invar s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              blue_basic_invar\n                               (s'\\<lparr>state.more := x\\<rparr>))\n 6. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; blue_basic_invar s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<notin> dom (discovered s);\n        s' =\n        discover u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              blue_basic_invar\n                               (s'\\<lparr>state.more := x\\<rparr>))", "have [simp]: \"(\\<lambda>x. x = hd (stack s) \\<or> x \\<in> cyan (finish (hd (stack s)) s)) = \n      (\\<lambda>x. x\\<in>set (stack s))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x.\n        x = hd (stack s) \\<or> x \\<in> cyan (finish (hd (stack s)) s)) =\n    (\\<lambda>x. x \\<in> set (stack s))", "using \\<open>stack s \\<noteq> []\\<close>"], ["proof (prove)\nusing this:\n  stack s \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<lambda>x.\n        x = hd (stack s) \\<or> x \\<in> cyan (finish (hd (stack s)) s)) =\n    (\\<lambda>x. x \\<in> set (stack s))", "unfolding finish_def cyan_def"], ["proof (prove)\nusing this:\n  stack s \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<lambda>x.\n        x = hd (stack s) \\<or>\n        x \\<in> set (stack\n                      (let f = finished s(hd (stack s) \\<mapsto> counter s);\n                           c = counter s + 1; st = tl (stack s)\n                       in s\\<lparr>finished := f, counter := c,\n                              stack := st\\<rparr>))) =\n    (\\<lambda>x. x \\<in> set (stack s))", "by (auto simp: neq_Nil_conv)"], ["proof (state)\nthis:\n  (\\<lambda>x.\n      x = hd (stack s) \\<or> x \\<in> cyan (finish (hd (stack s)) s)) =\n  (\\<lambda>x. x \\<in> set (stack s))\n\ngoal (6 subgoals):\n 1. on_init blue_dfs_params \\<le>\\<^sub>n\n    SPEC (\\<lambda>x. blue_basic_invar (empty_state x))\n 2. \\<And>s s' v0.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; blue_basic_invar s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s = []; v0 \\<in> V0;\n        v0 \\<notin> dom (discovered s); s' = new_root v0 s\\<rbrakk>\n       \\<Longrightarrow> on_new_root blue_dfs_params v0 s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              blue_basic_invar\n                               (s'\\<lparr>state.more := x\\<rparr>))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; blue_basic_invar s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish blue_dfs_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              blue_basic_invar\n                               (s'\\<lparr>state.more := x\\<rparr>))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; blue_basic_invar s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              blue_basic_invar\n                               (s'\\<lparr>state.more := x\\<rparr>))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; blue_basic_invar s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              blue_basic_invar\n                               (s'\\<lparr>state.more := x\\<rparr>))\n 6. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; blue_basic_invar s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<notin> dom (discovered s);\n        s' =\n        discover u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              blue_basic_invar\n                               (s'\\<lparr>state.more := x\\<rparr>))", "from finish"], ["proof (chain)\npicking this:\n  DFS_invar G blue_dfs_params s\n  blue_basic_invar s\n  cond s\n  \\<not> is_break blue_dfs_params s\n  stack s \\<noteq> []\n  u_ = hd (stack s)\n  pending s `` {u_} = {}\n  s'_ = finish u_ s", "show ?case"], ["proof (prove)\nusing this:\n  DFS_invar G blue_dfs_params s\n  blue_basic_invar s\n  cond s\n  \\<not> is_break blue_dfs_params s\n  stack s \\<noteq> []\n  u_ = hd (stack s)\n  pending s `` {u_} = {}\n  s'_ = finish u_ s\n\ngoal (1 subgoal):\n 1. on_finish blue_dfs_params u_ s'_ \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         DFS_invar G blue_dfs_params\n          (s'_\\<lparr>state.more := x\\<rparr>) \\<longrightarrow>\n         blue_basic_invar (s'_\\<lparr>state.more := x\\<rparr>))", "apply (simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>BlueDFS_invar G accpt s; blue_basic_invar s; cond s;\n     lasso s = None; stack s \\<noteq> []; u_ = hd (stack s);\n     pending s `` {hd (stack s)} = {};\n     s'_ = finish (hd (stack s)) s\\<rbrakk>\n    \\<Longrightarrow> (accpt (hd (stack s)) \\<longrightarrow>\n                       run_red_dfs (hd (stack s))\n                        (finish (hd (stack s)) s) \\<le>\\<^sub>n\n                       SPEC\n                        (\\<lambda>x.\n                            BlueDFS_invar G accpt\n                             (finish (hd (stack s)) s\n                              \\<lparr>state.more :=\n  x\\<rparr>) \\<longrightarrow>\n                            blue_basic_invar\n                             (finish (hd (stack s)) s\n                              \\<lparr>state.more := x\\<rparr>))) \\<and>\n                      (\\<not> accpt (hd (stack s)) \\<longrightarrow>\n                       BlueDFS_invar G accpt\n                        (finish (hd (stack s)) s\n                         \\<lparr>state.more :=\n                                   state.more s\\<rparr>) \\<longrightarrow>\n                       blue_basic_invar\n                        (finish (hd (stack s)) s\n                         \\<lparr>state.more := state.more s\\<rparr>))", "apply (intro conjI impI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>BlueDFS_invar G accpt s; blue_basic_invar s; cond s;\n     lasso s = None; stack s \\<noteq> []; u_ = hd (stack s);\n     pending s `` {hd (stack s)} = {}; s'_ = finish (hd (stack s)) s;\n     accpt (hd (stack s))\\<rbrakk>\n    \\<Longrightarrow> run_red_dfs (hd (stack s))\n                       (finish (hd (stack s)) s) \\<le>\\<^sub>n\n                      SPEC\n                       (\\<lambda>x.\n                           BlueDFS_invar G accpt\n                            (finish (hd (stack s)) s\n                             \\<lparr>state.more :=\n x\\<rparr>) \\<longrightarrow>\n                           blue_basic_invar\n                            (finish (hd (stack s)) s\n                             \\<lparr>state.more := x\\<rparr>))\n 2. \\<lbrakk>BlueDFS_invar G accpt s; blue_basic_invar s; cond s;\n     lasso s = None; stack s \\<noteq> []; u_ = hd (stack s);\n     pending s `` {hd (stack s)} = {}; s'_ = finish (hd (stack s)) s;\n     \\<not> accpt (hd (stack s));\n     BlueDFS_invar G accpt\n      (finish (hd (stack s)) s\n       \\<lparr>state.more := state.more s\\<rparr>)\\<rbrakk>\n    \\<Longrightarrow> blue_basic_invar\n                       (finish (hd (stack s)) s\n                        \\<lparr>state.more := state.more s\\<rparr>)", "apply (rule leof_trans[OF red_dfs_pres_bbi], assumption+, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>BlueDFS_invar G accpt s; blue_basic_invar s; cond s;\n     lasso s = None; stack s \\<noteq> []; u_ = hd (stack s);\n     pending s `` {hd (stack s)} = {}; s'_ = finish (hd (stack s)) s;\n     \\<not> accpt (hd (stack s));\n     BlueDFS_invar G accpt\n      (finish (hd (stack s)) s\n       \\<lparr>state.more := state.more s\\<rparr>)\\<rbrakk>\n    \\<Longrightarrow> blue_basic_invar\n                       (finish (hd (stack s)) s\n                        \\<lparr>state.more := state.more s\\<rparr>)", "apply (auto simp: restr_invar_def blue_basic_invar_def neq_Nil_conv) []"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  on_finish blue_dfs_params u_ s'_ \\<le>\\<^sub>n\n  SPEC\n   (\\<lambda>x.\n       DFS_invar G blue_dfs_params\n        (s'_\\<lparr>state.more := x\\<rparr>) \\<longrightarrow>\n       blue_basic_invar (s'_\\<lparr>state.more := x\\<rparr>))\n\ngoal (5 subgoals):\n 1. on_init blue_dfs_params \\<le>\\<^sub>n\n    SPEC (\\<lambda>x. blue_basic_invar (empty_state x))\n 2. \\<And>s s' v0.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; blue_basic_invar s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s = []; v0 \\<in> V0;\n        v0 \\<notin> dom (discovered s); s' = new_root v0 s\\<rbrakk>\n       \\<Longrightarrow> on_new_root blue_dfs_params v0 s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              blue_basic_invar\n                               (s'\\<lparr>state.more := x\\<rparr>))\n 3. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; blue_basic_invar s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              blue_basic_invar\n                               (s'\\<lparr>state.more := x\\<rparr>))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; blue_basic_invar s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              blue_basic_invar\n                               (s'\\<lparr>state.more := x\\<rparr>))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; blue_basic_invar s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<notin> dom (discovered s);\n        s' =\n        discover u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              blue_basic_invar\n                               (s'\\<lparr>state.more := x\\<rparr>))", "qed (auto simp: blue_basic_invar_def cond_def se_back_edge_def\n            simp: restr_invar_def empty_state_def pred_defs\n            simp: DFS_invar.discovered_eq_finished_un_stack\n            simp del: BlueDFS_invar_eq\n            split: option.splits)"], ["", "lemmas (in BlueDFS_invar) s_blue_basic_invar \n    = blue_basic_invar[THEN make_invar_thm]"], ["", "lemmas (in BlueDFS_invar) red_DFS_precond \n    = red_DFS_precond_aux[OF s_blue_basic_invar]"], ["", "sublocale DFS G blue_dfs_params"], ["proof (prove)\ngoal (1 subgoal):\n 1. DFS G blue_dfs_params", "apply unfold_locales"], ["proof (prove)\ngoal (6 subgoals):\n 1. nofail (on_init blue_dfs_params)\n 2. \\<And>v0 s.\n       pre_on_new_root v0 s \\<Longrightarrow>\n       nofail (on_new_root blue_dfs_params v0 s)\n 3. \\<And>u s.\n       pre_on_finish u s \\<Longrightarrow>\n       nofail (on_finish blue_dfs_params u s)\n 4. \\<And>u v s.\n       pre_on_cross_edge u v s \\<Longrightarrow>\n       nofail (on_cross_edge blue_dfs_params u v s)\n 5. \\<And>u v s.\n       pre_on_back_edge u v s \\<Longrightarrow>\n       nofail (on_back_edge blue_dfs_params u v s)\n 6. \\<And>u v s.\n       pre_on_discover u v s \\<Longrightarrow>\n       nofail (on_discover blue_dfs_params u v s)", "apply (clarsimp_all \n      simp:  se_back_edge_def run_red_dfs_def refine_pw_simps pre_on_defs\n      split: option.splits)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>sa.\n       \\<lbrakk>BlueDFS_invar G accpt sa; cond sa; stack sa \\<noteq> [];\n        pending sa `` {hd (stack sa)} = {}; lasso sa = None;\n        accpt (hd (stack sa))\\<rbrakk>\n       \\<Longrightarrow> nofail\n                          (red_dfs (red sa)\n                            (\\<lambda>x.\n                                x = hd (stack sa) \\<or>\n                                x \\<in> cyan (finish (hd (stack sa)) sa))\n                            (hd (stack sa)))", "unfolding nofail_SPEC_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>sa.\n       \\<lbrakk>BlueDFS_invar G accpt sa; cond sa; stack sa \\<noteq> [];\n        pending sa `` {hd (stack sa)} = {}; lasso sa = None;\n        accpt (hd (stack sa))\\<rbrakk>\n       \\<Longrightarrow> red_dfs (red sa)\n                          (\\<lambda>x.\n                              x = hd (stack sa) \\<or>\n                              x \\<in> cyan (finish (hd (stack sa)) sa))\n                          (hd (stack sa))\n                         \\<le> SPEC (\\<lambda>_. True)", "apply (refine_vcg)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>sa.\n       \\<lbrakk>BlueDFS_invar G accpt sa; cond sa; stack sa \\<noteq> [];\n        pending sa `` {hd (stack sa)} = {}; lasso sa = None;\n        accpt (hd (stack sa))\\<rbrakk>\n       \\<Longrightarrow> fb_graph (G\\<lparr>g_V0 := {hd (stack sa)}\\<rparr>)\n 2. \\<And>sa.\n       \\<lbrakk>BlueDFS_invar G accpt sa; cond sa; stack sa \\<noteq> [];\n        pending sa `` {hd (stack sa)} = {}; lasso sa = None;\n        accpt (hd (stack sa))\\<rbrakk>\n       \\<Longrightarrow> restr_invar\n                          (g_E (G\\<lparr>g_V0 := {hd (stack sa)}\\<rparr>))\n                          (red sa)\n                          (\\<lambda>x.\n                              x = hd (stack sa) \\<or>\n                              x \\<in> cyan (finish (hd (stack sa)) sa))\n 3. \\<And>sa x.\n       \\<lbrakk>BlueDFS_invar G accpt sa; cond sa; stack sa \\<noteq> [];\n        pending sa `` {hd (stack sa)} = {}; lasso sa = None;\n        accpt (hd (stack sa));\n        fb_graph (G\\<lparr>g_V0 := {hd (stack sa)}\\<rparr>) \\<and>\n        restr_invar (g_E (G\\<lparr>g_V0 := {hd (stack sa)}\\<rparr>))\n         (red sa)\n         (\\<lambda>x.\n             x = hd (stack sa) \\<or>\n             x \\<in> cyan (finish (hd (stack sa)) sa));\n        find_path1_restr_pred (G\\<lparr>g_V0 := {hd (stack sa)}\\<rparr>)\n         (\\<lambda>x.\n             x = hd (stack sa) \\<or>\n             x \\<in> cyan (finish (hd (stack sa)) sa))\n         (red sa) x\\<rbrakk>\n       \\<Longrightarrow> True", "apply (erule BlueDFS_invar.red_DFS_precond, auto) []"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>sa.\n       \\<lbrakk>BlueDFS_invar G accpt sa; cond sa; stack sa \\<noteq> [];\n        pending sa `` {hd (stack sa)} = {}; lasso sa = None;\n        accpt (hd (stack sa))\\<rbrakk>\n       \\<Longrightarrow> restr_invar\n                          (g_E (G\\<lparr>g_V0 := {hd (stack sa)}\\<rparr>))\n                          (red sa)\n                          (\\<lambda>x.\n                              x = hd (stack sa) \\<or>\n                              x \\<in> cyan (finish (hd (stack sa)) sa))\n 2. \\<And>sa x.\n       \\<lbrakk>BlueDFS_invar G accpt sa; cond sa; stack sa \\<noteq> [];\n        pending sa `` {hd (stack sa)} = {}; lasso sa = None;\n        accpt (hd (stack sa));\n        fb_graph (G\\<lparr>g_V0 := {hd (stack sa)}\\<rparr>) \\<and>\n        restr_invar (g_E (G\\<lparr>g_V0 := {hd (stack sa)}\\<rparr>))\n         (red sa)\n         (\\<lambda>x.\n             x = hd (stack sa) \\<or>\n             x \\<in> cyan (finish (hd (stack sa)) sa));\n        find_path1_restr_pred (G\\<lparr>g_V0 := {hd (stack sa)}\\<rparr>)\n         (\\<lambda>x.\n             x = hd (stack sa) \\<or>\n             x \\<in> cyan (finish (hd (stack sa)) sa))\n         (red sa) x\\<rbrakk>\n       \\<Longrightarrow> True", "apply (simp add: cyan_def finish_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>sa.\n       \\<lbrakk>BlueDFS_invar G accpt sa; cond sa; stack sa \\<noteq> [];\n        pending sa `` {hd (stack sa)} = {}; lasso sa = None;\n        accpt (hd (stack sa))\\<rbrakk>\n       \\<Longrightarrow> restr_invar E (red sa)\n                          (\\<lambda>x. x \\<in> set (stack sa))\n 2. \\<And>sa x.\n       \\<lbrakk>BlueDFS_invar G accpt sa; cond sa; stack sa \\<noteq> [];\n        pending sa `` {hd (stack sa)} = {}; lasso sa = None;\n        accpt (hd (stack sa));\n        fb_graph (G\\<lparr>g_V0 := {hd (stack sa)}\\<rparr>) \\<and>\n        restr_invar (g_E (G\\<lparr>g_V0 := {hd (stack sa)}\\<rparr>))\n         (red sa)\n         (\\<lambda>x.\n             x = hd (stack sa) \\<or>\n             x \\<in> cyan (finish (hd (stack sa)) sa));\n        find_path1_restr_pred (G\\<lparr>g_V0 := {hd (stack sa)}\\<rparr>)\n         (\\<lambda>x.\n             x = hd (stack sa) \\<or>\n             x \\<in> cyan (finish (hd (stack sa)) sa))\n         (red sa) x\\<rbrakk>\n       \\<Longrightarrow> True", "apply (erule BlueDFS_invar.red_DFS_precond, auto) []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>sa x.\n       \\<lbrakk>BlueDFS_invar G accpt sa; cond sa; stack sa \\<noteq> [];\n        pending sa `` {hd (stack sa)} = {}; lasso sa = None;\n        accpt (hd (stack sa));\n        fb_graph (G\\<lparr>g_V0 := {hd (stack sa)}\\<rparr>) \\<and>\n        restr_invar (g_E (G\\<lparr>g_V0 := {hd (stack sa)}\\<rparr>))\n         (red sa)\n         (\\<lambda>x.\n             x = hd (stack sa) \\<or>\n             x \\<in> cyan (finish (hd (stack sa)) sa));\n        find_path1_restr_pred (G\\<lparr>g_V0 := {hd (stack sa)}\\<rparr>)\n         (\\<lambda>x.\n             x = hd (stack sa) \\<or>\n             x \\<in> cyan (finish (hd (stack sa)) sa))\n         (red sa) x\\<rbrakk>\n       \\<Longrightarrow> True", "apply (rule TrueI)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "context BlueDFS_invar\nbegin"], ["", "context assumes [simp]: \"lasso s = None\"\n  begin"], ["", "lemma red_closed:\n      \"E `` red s \\<subseteq> red s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. E `` red s \\<subseteq> red s", "using s_blue_basic_invar"], ["proof (prove)\nusing this:\n  blue_basic_invar s\n\ngoal (1 subgoal):\n 1. E `` red s \\<subseteq> red s", "unfolding blue_basic_invar_def restr_invar_def"], ["proof (prove)\nusing this:\n  case lasso s of\n  None \\<Rightarrow>\n    (E `` red s \\<subseteq> red s \\<and>\n     red s \\<inter> {x. x \\<in> set (stack s)} = {}) \\<and>\n    red s \\<subseteq> dom (finished s)\n  | Some l \\<Rightarrow> True\n\ngoal (1 subgoal):\n 1. E `` red s \\<subseteq> red s", "by simp"], ["", "lemma red_stack_disjoint:\n      \"set (stack s) \\<inter> red s = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (stack s) \\<inter> red s = {}", "using s_blue_basic_invar"], ["proof (prove)\nusing this:\n  blue_basic_invar s\n\ngoal (1 subgoal):\n 1. set (stack s) \\<inter> red s = {}", "unfolding blue_basic_invar_def restr_invar_def"], ["proof (prove)\nusing this:\n  case lasso s of\n  None \\<Rightarrow>\n    (E `` red s \\<subseteq> red s \\<and>\n     red s \\<inter> {x. x \\<in> set (stack s)} = {}) \\<and>\n    red s \\<subseteq> dom (finished s)\n  | Some l \\<Rightarrow> True\n\ngoal (1 subgoal):\n 1. set (stack s) \\<inter> red s = {}", "by auto"], ["", "lemma red_finished: \"red s \\<subseteq> dom (finished s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. red s \\<subseteq> dom (finished s)", "using s_blue_basic_invar"], ["proof (prove)\nusing this:\n  blue_basic_invar s\n\ngoal (1 subgoal):\n 1. red s \\<subseteq> dom (finished s)", "unfolding blue_basic_invar_def"], ["proof (prove)\nusing this:\n  case lasso s of\n  None \\<Rightarrow>\n    restr_invar E (red s) (\\<lambda>x. x \\<in> set (stack s)) \\<and>\n    red s \\<subseteq> dom (finished s)\n  | Some l \\<Rightarrow> True\n\ngoal (1 subgoal):\n 1. red s \\<subseteq> dom (finished s)", "by auto"], ["", "(* Play of Colors *)"], ["", "lemma all_nodes_colored: \"white s \\<union> blue s \\<union> cyan s \\<union> red s = UNIV \""], ["proof (prove)\ngoal (1 subgoal):\n 1. white s \\<union> blue s \\<union> cyan s \\<union> red s = UNIV", "unfolding white_def blue_def cyan_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. - dom (discovered s) \\<union> (dom (finished s) - red s) \\<union>\n    set (stack s) \\<union>\n    red s =\n    UNIV", "by (auto simp: stack_set_def)"], ["", "lemma colors_disjoint:\n      \"white s \\<inter> (blue s \\<union> cyan s \\<union> red s) = {}\"\n      \"blue s \\<inter> (white s \\<union> cyan s \\<union> red s) = {}\"\n      \"cyan s \\<inter> (white s \\<union> blue s \\<union> red s) = {}\"\n      \"red s \\<inter> (white s \\<union> blue s \\<union> cyan s) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (white s \\<inter> (blue s \\<union> cyan s \\<union> red s) = {} &&&\n     blue s \\<inter> (white s \\<union> cyan s \\<union> red s) = {}) &&&\n    cyan s \\<inter> (white s \\<union> blue s \\<union> red s) = {} &&&\n    red s \\<inter> (white s \\<union> blue s \\<union> cyan s) = {}", "unfolding white_def blue_def cyan_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (- dom (discovered s) \\<inter>\n     (dom (finished s) - red s \\<union> set (stack s) \\<union> red s) =\n     {} &&&\n     (dom (finished s) - red s) \\<inter>\n     (- dom (discovered s) \\<union> set (stack s) \\<union> red s) =\n     {}) &&&\n    set (stack s) \\<inter>\n    (- dom (discovered s) \\<union> (dom (finished s) - red s) \\<union>\n     red s) =\n    {} &&&\n    red s \\<inter>\n    (- dom (discovered s) \\<union> (dom (finished s) - red s) \\<union>\n     set (stack s)) =\n    {}", "using finished_discovered red_finished"], ["proof (prove)\nusing this:\n  dom (finished s) \\<subseteq> dom (discovered s)\n  red s \\<subseteq> dom (finished s)\n\ngoal (1 subgoal):\n 1. (- dom (discovered s) \\<inter>\n     (dom (finished s) - red s \\<union> set (stack s) \\<union> red s) =\n     {} &&&\n     (dom (finished s) - red s) \\<inter>\n     (- dom (discovered s) \\<union> set (stack s) \\<union> red s) =\n     {}) &&&\n    set (stack s) \\<inter>\n    (- dom (discovered s) \\<union> (dom (finished s) - red s) \\<union>\n     red s) =\n    {} &&&\n    red s \\<inter>\n    (- dom (discovered s) \\<union> (dom (finished s) - red s) \\<union>\n     set (stack s)) =\n    {}", "unfolding stack_set_def"], ["proof (prove)\nusing this:\n  dom (finished s) \\<subseteq> dom (discovered s)\n  red s \\<subseteq> dom (finished s)\n\ngoal (1 subgoal):\n 1. (- dom (discovered s) \\<inter>\n     (dom (finished s) - red s \\<union>\n      (dom (discovered s) - dom (finished s)) \\<union>\n      red s) =\n     {} &&&\n     (dom (finished s) - red s) \\<inter>\n     (- dom (discovered s) \\<union>\n      (dom (discovered s) - dom (finished s)) \\<union>\n      red s) =\n     {}) &&&\n    (dom (discovered s) - dom (finished s)) \\<inter>\n    (- dom (discovered s) \\<union> (dom (finished s) - red s) \\<union>\n     red s) =\n    {} &&&\n    red s \\<inter>\n    (- dom (discovered s) \\<union> (dom (finished s) - red s) \\<union>\n     (dom (discovered s) - dom (finished s))) =\n    {}", "by blast+"], ["", "end"], ["", "lemma (in BlueDFS) i_no_accpt_cyle_in_finish:\n    \"is_invar (\\<lambda>s. lasso s = None \\<longrightarrow> (\\<forall>x. accpt x \\<and> x \\<in> dom (finished s) \\<longrightarrow> (x,x) \\<notin> E\\<^sup>+))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_invar\n     (\\<lambda>s.\n         lasso s = None \\<longrightarrow>\n         (\\<forall>x.\n             accpt x \\<and> x \\<in> dom (finished s) \\<longrightarrow>\n             (x, x) \\<notin> E\\<^sup>+))", "proof (induct rule: establish_invarI)"], ["proof (state)\ngoal (6 subgoals):\n 1. on_init blue_dfs_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         lasso (empty_state x) = None \\<longrightarrow>\n         (\\<forall>xa.\n             accpt xa \\<and>\n             xa \\<in> dom (finished (empty_state x)) \\<longrightarrow>\n             (xa, xa) \\<notin> E\\<^sup>+))\n 2. \\<And>s s' v0.\n       \\<lbrakk>DFS_invar G blue_dfs_params s;\n        lasso s = None \\<longrightarrow>\n        (\\<forall>x.\n            accpt x \\<and> x \\<in> dom (finished s) \\<longrightarrow>\n            (x, x) \\<notin> E\\<^sup>+);\n        cond s; \\<not> is_break blue_dfs_params s; stack s = [];\n        v0 \\<in> V0; v0 \\<notin> dom (discovered s);\n        s' = new_root v0 s\\<rbrakk>\n       \\<Longrightarrow> on_new_root blue_dfs_params v0 s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso (s'\\<lparr>state.more := x\\<rparr>) =\n                              None \\<longrightarrow>\n                              (\\<forall>xa.\n                                  accpt xa \\<and>\n                                  xa \\<in> dom\n      (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                                  (xa, xa) \\<notin> E\\<^sup>+))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G blue_dfs_params s;\n        lasso s = None \\<longrightarrow>\n        (\\<forall>x.\n            accpt x \\<and> x \\<in> dom (finished s) \\<longrightarrow>\n            (x, x) \\<notin> E\\<^sup>+);\n        cond s; \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish blue_dfs_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso (s'\\<lparr>state.more := x\\<rparr>) =\n                              None \\<longrightarrow>\n                              (\\<forall>xa.\n                                  accpt xa \\<and>\n                                  xa \\<in> dom\n      (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                                  (xa, xa) \\<notin> E\\<^sup>+))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s;\n        lasso s = None \\<longrightarrow>\n        (\\<forall>x.\n            accpt x \\<and> x \\<in> dom (finished s) \\<longrightarrow>\n            (x, x) \\<notin> E\\<^sup>+);\n        cond s; \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso (s'\\<lparr>state.more := x\\<rparr>) =\n                              None \\<longrightarrow>\n                              (\\<forall>xa.\n                                  accpt xa \\<and>\n                                  xa \\<in> dom\n      (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                                  (xa, xa) \\<notin> E\\<^sup>+))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s;\n        lasso s = None \\<longrightarrow>\n        (\\<forall>x.\n            accpt x \\<and> x \\<in> dom (finished s) \\<longrightarrow>\n            (x, x) \\<notin> E\\<^sup>+);\n        cond s; \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso (s'\\<lparr>state.more := x\\<rparr>) =\n                              None \\<longrightarrow>\n                              (\\<forall>xa.\n                                  accpt xa \\<and>\n                                  xa \\<in> dom\n      (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                                  (xa, xa) \\<notin> E\\<^sup>+))\n 6. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s;\n        lasso s = None \\<longrightarrow>\n        (\\<forall>x.\n            accpt x \\<and> x \\<in> dom (finished s) \\<longrightarrow>\n            (x, x) \\<notin> E\\<^sup>+);\n        cond s; \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<notin> dom (discovered s);\n        s' =\n        discover u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso (s'\\<lparr>state.more := x\\<rparr>) =\n                              None \\<longrightarrow>\n                              (\\<forall>xa.\n                                  accpt xa \\<and>\n                                  xa \\<in> dom\n      (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                                  (xa, xa) \\<notin> E\\<^sup>+))", "case (finish s s' u)"], ["proof (state)\nthis:\n  DFS_invar G blue_dfs_params s\n  lasso s = None \\<longrightarrow>\n  (\\<forall>x.\n      accpt x \\<and> x \\<in> dom (finished s) \\<longrightarrow>\n      (x, x) \\<notin> E\\<^sup>+)\n  cond s\n  \\<not> is_break blue_dfs_params s\n  stack s \\<noteq> []\n  u = hd (stack s)\n  pending s `` {u} = {}\n  s' = finish u s\n\ngoal (6 subgoals):\n 1. on_init blue_dfs_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         lasso (empty_state x) = None \\<longrightarrow>\n         (\\<forall>xa.\n             accpt xa \\<and>\n             xa \\<in> dom (finished (empty_state x)) \\<longrightarrow>\n             (xa, xa) \\<notin> E\\<^sup>+))\n 2. \\<And>s s' v0.\n       \\<lbrakk>DFS_invar G blue_dfs_params s;\n        lasso s = None \\<longrightarrow>\n        (\\<forall>x.\n            accpt x \\<and> x \\<in> dom (finished s) \\<longrightarrow>\n            (x, x) \\<notin> E\\<^sup>+);\n        cond s; \\<not> is_break blue_dfs_params s; stack s = [];\n        v0 \\<in> V0; v0 \\<notin> dom (discovered s);\n        s' = new_root v0 s\\<rbrakk>\n       \\<Longrightarrow> on_new_root blue_dfs_params v0 s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso (s'\\<lparr>state.more := x\\<rparr>) =\n                              None \\<longrightarrow>\n                              (\\<forall>xa.\n                                  accpt xa \\<and>\n                                  xa \\<in> dom\n      (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                                  (xa, xa) \\<notin> E\\<^sup>+))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G blue_dfs_params s;\n        lasso s = None \\<longrightarrow>\n        (\\<forall>x.\n            accpt x \\<and> x \\<in> dom (finished s) \\<longrightarrow>\n            (x, x) \\<notin> E\\<^sup>+);\n        cond s; \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish blue_dfs_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso (s'\\<lparr>state.more := x\\<rparr>) =\n                              None \\<longrightarrow>\n                              (\\<forall>xa.\n                                  accpt xa \\<and>\n                                  xa \\<in> dom\n      (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                                  (xa, xa) \\<notin> E\\<^sup>+))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s;\n        lasso s = None \\<longrightarrow>\n        (\\<forall>x.\n            accpt x \\<and> x \\<in> dom (finished s) \\<longrightarrow>\n            (x, x) \\<notin> E\\<^sup>+);\n        cond s; \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso (s'\\<lparr>state.more := x\\<rparr>) =\n                              None \\<longrightarrow>\n                              (\\<forall>xa.\n                                  accpt xa \\<and>\n                                  xa \\<in> dom\n      (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                                  (xa, xa) \\<notin> E\\<^sup>+))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s;\n        lasso s = None \\<longrightarrow>\n        (\\<forall>x.\n            accpt x \\<and> x \\<in> dom (finished s) \\<longrightarrow>\n            (x, x) \\<notin> E\\<^sup>+);\n        cond s; \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso (s'\\<lparr>state.more := x\\<rparr>) =\n                              None \\<longrightarrow>\n                              (\\<forall>xa.\n                                  accpt xa \\<and>\n                                  xa \\<in> dom\n      (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                                  (xa, xa) \\<notin> E\\<^sup>+))\n 6. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s;\n        lasso s = None \\<longrightarrow>\n        (\\<forall>x.\n            accpt x \\<and> x \\<in> dom (finished s) \\<longrightarrow>\n            (x, x) \\<notin> E\\<^sup>+);\n        cond s; \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<notin> dom (discovered s);\n        s' =\n        discover u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso (s'\\<lparr>state.more := x\\<rparr>) =\n                              None \\<longrightarrow>\n                              (\\<forall>xa.\n                                  accpt xa \\<and>\n                                  xa \\<in> dom\n      (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                                  (xa, xa) \\<notin> E\\<^sup>+))", "then"], ["proof (chain)\npicking this:\n  DFS_invar G blue_dfs_params s\n  lasso s = None \\<longrightarrow>\n  (\\<forall>x.\n      accpt x \\<and> x \\<in> dom (finished s) \\<longrightarrow>\n      (x, x) \\<notin> E\\<^sup>+)\n  cond s\n  \\<not> is_break blue_dfs_params s\n  stack s \\<noteq> []\n  u = hd (stack s)\n  pending s `` {u} = {}\n  s' = finish u s", "interpret BlueDFS_invar where s=s"], ["proof (prove)\nusing this:\n  DFS_invar G blue_dfs_params s\n  lasso s = None \\<longrightarrow>\n  (\\<forall>x.\n      accpt x \\<and> x \\<in> dom (finished s) \\<longrightarrow>\n      (x, x) \\<notin> E\\<^sup>+)\n  cond s\n  \\<not> is_break blue_dfs_params s\n  stack s \\<noteq> []\n  u = hd (stack s)\n  pending s `` {u} = {}\n  s' = finish u s\n\ngoal (1 subgoal):\n 1. BlueDFS_invar G accpt s", "by simp"], ["proof (state)\ngoal (6 subgoals):\n 1. on_init blue_dfs_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         lasso (empty_state x) = None \\<longrightarrow>\n         (\\<forall>xa.\n             accpt xa \\<and>\n             xa \\<in> dom (finished (empty_state x)) \\<longrightarrow>\n             (xa, xa) \\<notin> E\\<^sup>+))\n 2. \\<And>s s' v0.\n       \\<lbrakk>DFS_invar G blue_dfs_params s;\n        lasso s = None \\<longrightarrow>\n        (\\<forall>x.\n            accpt x \\<and> x \\<in> dom (finished s) \\<longrightarrow>\n            (x, x) \\<notin> E\\<^sup>+);\n        cond s; \\<not> is_break blue_dfs_params s; stack s = [];\n        v0 \\<in> V0; v0 \\<notin> dom (discovered s);\n        s' = new_root v0 s\\<rbrakk>\n       \\<Longrightarrow> on_new_root blue_dfs_params v0 s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso (s'\\<lparr>state.more := x\\<rparr>) =\n                              None \\<longrightarrow>\n                              (\\<forall>xa.\n                                  accpt xa \\<and>\n                                  xa \\<in> dom\n      (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                                  (xa, xa) \\<notin> E\\<^sup>+))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G blue_dfs_params s;\n        lasso s = None \\<longrightarrow>\n        (\\<forall>x.\n            accpt x \\<and> x \\<in> dom (finished s) \\<longrightarrow>\n            (x, x) \\<notin> E\\<^sup>+);\n        cond s; \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish blue_dfs_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso (s'\\<lparr>state.more := x\\<rparr>) =\n                              None \\<longrightarrow>\n                              (\\<forall>xa.\n                                  accpt xa \\<and>\n                                  xa \\<in> dom\n      (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                                  (xa, xa) \\<notin> E\\<^sup>+))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s;\n        lasso s = None \\<longrightarrow>\n        (\\<forall>x.\n            accpt x \\<and> x \\<in> dom (finished s) \\<longrightarrow>\n            (x, x) \\<notin> E\\<^sup>+);\n        cond s; \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso (s'\\<lparr>state.more := x\\<rparr>) =\n                              None \\<longrightarrow>\n                              (\\<forall>xa.\n                                  accpt xa \\<and>\n                                  xa \\<in> dom\n      (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                                  (xa, xa) \\<notin> E\\<^sup>+))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s;\n        lasso s = None \\<longrightarrow>\n        (\\<forall>x.\n            accpt x \\<and> x \\<in> dom (finished s) \\<longrightarrow>\n            (x, x) \\<notin> E\\<^sup>+);\n        cond s; \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso (s'\\<lparr>state.more := x\\<rparr>) =\n                              None \\<longrightarrow>\n                              (\\<forall>xa.\n                                  accpt xa \\<and>\n                                  xa \\<in> dom\n      (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                                  (xa, xa) \\<notin> E\\<^sup>+))\n 6. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s;\n        lasso s = None \\<longrightarrow>\n        (\\<forall>x.\n            accpt x \\<and> x \\<in> dom (finished s) \\<longrightarrow>\n            (x, x) \\<notin> E\\<^sup>+);\n        cond s; \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<notin> dom (discovered s);\n        s' =\n        discover u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso (s'\\<lparr>state.more := x\\<rparr>) =\n                              None \\<longrightarrow>\n                              (\\<forall>xa.\n                                  accpt xa \\<and>\n                                  xa \\<in> dom\n      (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                                  (xa, xa) \\<notin> E\\<^sup>+))", "let ?onstack = \"\\<lambda>x. x\\<in>set (stack s)\""], ["proof (state)\ngoal (6 subgoals):\n 1. on_init blue_dfs_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         lasso (empty_state x) = None \\<longrightarrow>\n         (\\<forall>xa.\n             accpt xa \\<and>\n             xa \\<in> dom (finished (empty_state x)) \\<longrightarrow>\n             (xa, xa) \\<notin> E\\<^sup>+))\n 2. \\<And>s s' v0.\n       \\<lbrakk>DFS_invar G blue_dfs_params s;\n        lasso s = None \\<longrightarrow>\n        (\\<forall>x.\n            accpt x \\<and> x \\<in> dom (finished s) \\<longrightarrow>\n            (x, x) \\<notin> E\\<^sup>+);\n        cond s; \\<not> is_break blue_dfs_params s; stack s = [];\n        v0 \\<in> V0; v0 \\<notin> dom (discovered s);\n        s' = new_root v0 s\\<rbrakk>\n       \\<Longrightarrow> on_new_root blue_dfs_params v0 s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso (s'\\<lparr>state.more := x\\<rparr>) =\n                              None \\<longrightarrow>\n                              (\\<forall>xa.\n                                  accpt xa \\<and>\n                                  xa \\<in> dom\n      (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                                  (xa, xa) \\<notin> E\\<^sup>+))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G blue_dfs_params s;\n        lasso s = None \\<longrightarrow>\n        (\\<forall>x.\n            accpt x \\<and> x \\<in> dom (finished s) \\<longrightarrow>\n            (x, x) \\<notin> E\\<^sup>+);\n        cond s; \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish blue_dfs_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso (s'\\<lparr>state.more := x\\<rparr>) =\n                              None \\<longrightarrow>\n                              (\\<forall>xa.\n                                  accpt xa \\<and>\n                                  xa \\<in> dom\n      (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                                  (xa, xa) \\<notin> E\\<^sup>+))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s;\n        lasso s = None \\<longrightarrow>\n        (\\<forall>x.\n            accpt x \\<and> x \\<in> dom (finished s) \\<longrightarrow>\n            (x, x) \\<notin> E\\<^sup>+);\n        cond s; \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso (s'\\<lparr>state.more := x\\<rparr>) =\n                              None \\<longrightarrow>\n                              (\\<forall>xa.\n                                  accpt xa \\<and>\n                                  xa \\<in> dom\n      (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                                  (xa, xa) \\<notin> E\\<^sup>+))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s;\n        lasso s = None \\<longrightarrow>\n        (\\<forall>x.\n            accpt x \\<and> x \\<in> dom (finished s) \\<longrightarrow>\n            (x, x) \\<notin> E\\<^sup>+);\n        cond s; \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso (s'\\<lparr>state.more := x\\<rparr>) =\n                              None \\<longrightarrow>\n                              (\\<forall>xa.\n                                  accpt xa \\<and>\n                                  xa \\<in> dom\n      (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                                  (xa, xa) \\<notin> E\\<^sup>+))\n 6. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s;\n        lasso s = None \\<longrightarrow>\n        (\\<forall>x.\n            accpt x \\<and> x \\<in> dom (finished s) \\<longrightarrow>\n            (x, x) \\<notin> E\\<^sup>+);\n        cond s; \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<notin> dom (discovered s);\n        s' =\n        discover u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso (s'\\<lparr>state.more := x\\<rparr>) =\n                              None \\<longrightarrow>\n                              (\\<forall>xa.\n                                  accpt xa \\<and>\n                                  xa \\<in> dom\n      (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                                  (xa, xa) \\<notin> E\\<^sup>+))", "let ?rE = \"rel_restrict E (red s)\""], ["proof (state)\ngoal (6 subgoals):\n 1. on_init blue_dfs_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         lasso (empty_state x) = None \\<longrightarrow>\n         (\\<forall>xa.\n             accpt xa \\<and>\n             xa \\<in> dom (finished (empty_state x)) \\<longrightarrow>\n             (xa, xa) \\<notin> E\\<^sup>+))\n 2. \\<And>s s' v0.\n       \\<lbrakk>DFS_invar G blue_dfs_params s;\n        lasso s = None \\<longrightarrow>\n        (\\<forall>x.\n            accpt x \\<and> x \\<in> dom (finished s) \\<longrightarrow>\n            (x, x) \\<notin> E\\<^sup>+);\n        cond s; \\<not> is_break blue_dfs_params s; stack s = [];\n        v0 \\<in> V0; v0 \\<notin> dom (discovered s);\n        s' = new_root v0 s\\<rbrakk>\n       \\<Longrightarrow> on_new_root blue_dfs_params v0 s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso (s'\\<lparr>state.more := x\\<rparr>) =\n                              None \\<longrightarrow>\n                              (\\<forall>xa.\n                                  accpt xa \\<and>\n                                  xa \\<in> dom\n      (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                                  (xa, xa) \\<notin> E\\<^sup>+))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G blue_dfs_params s;\n        lasso s = None \\<longrightarrow>\n        (\\<forall>x.\n            accpt x \\<and> x \\<in> dom (finished s) \\<longrightarrow>\n            (x, x) \\<notin> E\\<^sup>+);\n        cond s; \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish blue_dfs_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso (s'\\<lparr>state.more := x\\<rparr>) =\n                              None \\<longrightarrow>\n                              (\\<forall>xa.\n                                  accpt xa \\<and>\n                                  xa \\<in> dom\n      (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                                  (xa, xa) \\<notin> E\\<^sup>+))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s;\n        lasso s = None \\<longrightarrow>\n        (\\<forall>x.\n            accpt x \\<and> x \\<in> dom (finished s) \\<longrightarrow>\n            (x, x) \\<notin> E\\<^sup>+);\n        cond s; \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso (s'\\<lparr>state.more := x\\<rparr>) =\n                              None \\<longrightarrow>\n                              (\\<forall>xa.\n                                  accpt xa \\<and>\n                                  xa \\<in> dom\n      (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                                  (xa, xa) \\<notin> E\\<^sup>+))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s;\n        lasso s = None \\<longrightarrow>\n        (\\<forall>x.\n            accpt x \\<and> x \\<in> dom (finished s) \\<longrightarrow>\n            (x, x) \\<notin> E\\<^sup>+);\n        cond s; \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso (s'\\<lparr>state.more := x\\<rparr>) =\n                              None \\<longrightarrow>\n                              (\\<forall>xa.\n                                  accpt xa \\<and>\n                                  xa \\<in> dom\n      (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                                  (xa, xa) \\<notin> E\\<^sup>+))\n 6. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s;\n        lasso s = None \\<longrightarrow>\n        (\\<forall>x.\n            accpt x \\<and> x \\<in> dom (finished s) \\<longrightarrow>\n            (x, x) \\<notin> E\\<^sup>+);\n        cond s; \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<notin> dom (discovered s);\n        s' =\n        discover u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso (s'\\<lparr>state.more := x\\<rparr>) =\n                              None \\<longrightarrow>\n                              (\\<forall>xa.\n                                  accpt xa \\<and>\n                                  xa \\<in> dom\n      (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                                  (xa, xa) \\<notin> E\\<^sup>+))", "from finish"], ["proof (chain)\npicking this:\n  DFS_invar G blue_dfs_params s\n  lasso s = None \\<longrightarrow>\n  (\\<forall>x.\n      accpt x \\<and> x \\<in> dom (finished s) \\<longrightarrow>\n      (x, x) \\<notin> E\\<^sup>+)\n  cond s\n  \\<not> is_break blue_dfs_params s\n  stack s \\<noteq> []\n  u = hd (stack s)\n  pending s `` {u} = {}\n  s' = finish u s", "obtain sh st where [simp]: \"stack s = sh#st\""], ["proof (prove)\nusing this:\n  DFS_invar G blue_dfs_params s\n  lasso s = None \\<longrightarrow>\n  (\\<forall>x.\n      accpt x \\<and> x \\<in> dom (finished s) \\<longrightarrow>\n      (x, x) \\<notin> E\\<^sup>+)\n  cond s\n  \\<not> is_break blue_dfs_params s\n  stack s \\<noteq> []\n  u = hd (stack s)\n  pending s `` {u} = {}\n  s' = finish u s\n\ngoal (1 subgoal):\n 1. (\\<And>sh st.\n        stack s = sh # st \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: neq_Nil_conv)"], ["proof (state)\nthis:\n  stack s = sh # st\n\ngoal (6 subgoals):\n 1. on_init blue_dfs_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         lasso (empty_state x) = None \\<longrightarrow>\n         (\\<forall>xa.\n             accpt xa \\<and>\n             xa \\<in> dom (finished (empty_state x)) \\<longrightarrow>\n             (xa, xa) \\<notin> E\\<^sup>+))\n 2. \\<And>s s' v0.\n       \\<lbrakk>DFS_invar G blue_dfs_params s;\n        lasso s = None \\<longrightarrow>\n        (\\<forall>x.\n            accpt x \\<and> x \\<in> dom (finished s) \\<longrightarrow>\n            (x, x) \\<notin> E\\<^sup>+);\n        cond s; \\<not> is_break blue_dfs_params s; stack s = [];\n        v0 \\<in> V0; v0 \\<notin> dom (discovered s);\n        s' = new_root v0 s\\<rbrakk>\n       \\<Longrightarrow> on_new_root blue_dfs_params v0 s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso (s'\\<lparr>state.more := x\\<rparr>) =\n                              None \\<longrightarrow>\n                              (\\<forall>xa.\n                                  accpt xa \\<and>\n                                  xa \\<in> dom\n      (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                                  (xa, xa) \\<notin> E\\<^sup>+))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G blue_dfs_params s;\n        lasso s = None \\<longrightarrow>\n        (\\<forall>x.\n            accpt x \\<and> x \\<in> dom (finished s) \\<longrightarrow>\n            (x, x) \\<notin> E\\<^sup>+);\n        cond s; \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish blue_dfs_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso (s'\\<lparr>state.more := x\\<rparr>) =\n                              None \\<longrightarrow>\n                              (\\<forall>xa.\n                                  accpt xa \\<and>\n                                  xa \\<in> dom\n      (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                                  (xa, xa) \\<notin> E\\<^sup>+))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s;\n        lasso s = None \\<longrightarrow>\n        (\\<forall>x.\n            accpt x \\<and> x \\<in> dom (finished s) \\<longrightarrow>\n            (x, x) \\<notin> E\\<^sup>+);\n        cond s; \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso (s'\\<lparr>state.more := x\\<rparr>) =\n                              None \\<longrightarrow>\n                              (\\<forall>xa.\n                                  accpt xa \\<and>\n                                  xa \\<in> dom\n      (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                                  (xa, xa) \\<notin> E\\<^sup>+))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s;\n        lasso s = None \\<longrightarrow>\n        (\\<forall>x.\n            accpt x \\<and> x \\<in> dom (finished s) \\<longrightarrow>\n            (x, x) \\<notin> E\\<^sup>+);\n        cond s; \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso (s'\\<lparr>state.more := x\\<rparr>) =\n                              None \\<longrightarrow>\n                              (\\<forall>xa.\n                                  accpt xa \\<and>\n                                  xa \\<in> dom\n      (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                                  (xa, xa) \\<notin> E\\<^sup>+))\n 6. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s;\n        lasso s = None \\<longrightarrow>\n        (\\<forall>x.\n            accpt x \\<and> x \\<in> dom (finished s) \\<longrightarrow>\n            (x, x) \\<notin> E\\<^sup>+);\n        cond s; \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<notin> dom (discovered s);\n        s' =\n        discover u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso (s'\\<lparr>state.more := x\\<rparr>) =\n                              None \\<longrightarrow>\n                              (\\<forall>xa.\n                                  accpt xa \\<and>\n                                  xa \\<in> dom\n      (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                                  (xa, xa) \\<notin> E\\<^sup>+))", "have 1: \"g_E (G \\<lparr> g_V0 := {hd (stack s)} \\<rparr>) = E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g_E (G\\<lparr>g_V0 := {hd (stack s)}\\<rparr>) = E", "by simp"], ["proof (state)\nthis:\n  g_E (G\\<lparr>g_V0 := {hd (stack s)}\\<rparr>) = E\n\ngoal (6 subgoals):\n 1. on_init blue_dfs_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         lasso (empty_state x) = None \\<longrightarrow>\n         (\\<forall>xa.\n             accpt xa \\<and>\n             xa \\<in> dom (finished (empty_state x)) \\<longrightarrow>\n             (xa, xa) \\<notin> E\\<^sup>+))\n 2. \\<And>s s' v0.\n       \\<lbrakk>DFS_invar G blue_dfs_params s;\n        lasso s = None \\<longrightarrow>\n        (\\<forall>x.\n            accpt x \\<and> x \\<in> dom (finished s) \\<longrightarrow>\n            (x, x) \\<notin> E\\<^sup>+);\n        cond s; \\<not> is_break blue_dfs_params s; stack s = [];\n        v0 \\<in> V0; v0 \\<notin> dom (discovered s);\n        s' = new_root v0 s\\<rbrakk>\n       \\<Longrightarrow> on_new_root blue_dfs_params v0 s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso (s'\\<lparr>state.more := x\\<rparr>) =\n                              None \\<longrightarrow>\n                              (\\<forall>xa.\n                                  accpt xa \\<and>\n                                  xa \\<in> dom\n      (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                                  (xa, xa) \\<notin> E\\<^sup>+))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G blue_dfs_params s;\n        lasso s = None \\<longrightarrow>\n        (\\<forall>x.\n            accpt x \\<and> x \\<in> dom (finished s) \\<longrightarrow>\n            (x, x) \\<notin> E\\<^sup>+);\n        cond s; \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish blue_dfs_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso (s'\\<lparr>state.more := x\\<rparr>) =\n                              None \\<longrightarrow>\n                              (\\<forall>xa.\n                                  accpt xa \\<and>\n                                  xa \\<in> dom\n      (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                                  (xa, xa) \\<notin> E\\<^sup>+))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s;\n        lasso s = None \\<longrightarrow>\n        (\\<forall>x.\n            accpt x \\<and> x \\<in> dom (finished s) \\<longrightarrow>\n            (x, x) \\<notin> E\\<^sup>+);\n        cond s; \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso (s'\\<lparr>state.more := x\\<rparr>) =\n                              None \\<longrightarrow>\n                              (\\<forall>xa.\n                                  accpt xa \\<and>\n                                  xa \\<in> dom\n      (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                                  (xa, xa) \\<notin> E\\<^sup>+))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s;\n        lasso s = None \\<longrightarrow>\n        (\\<forall>x.\n            accpt x \\<and> x \\<in> dom (finished s) \\<longrightarrow>\n            (x, x) \\<notin> E\\<^sup>+);\n        cond s; \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso (s'\\<lparr>state.more := x\\<rparr>) =\n                              None \\<longrightarrow>\n                              (\\<forall>xa.\n                                  accpt xa \\<and>\n                                  xa \\<in> dom\n      (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                                  (xa, xa) \\<notin> E\\<^sup>+))\n 6. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s;\n        lasso s = None \\<longrightarrow>\n        (\\<forall>x.\n            accpt x \\<and> x \\<in> dom (finished s) \\<longrightarrow>\n            (x, x) \\<notin> E\\<^sup>+);\n        cond s; \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<notin> dom (discovered s);\n        s' =\n        discover u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso (s'\\<lparr>state.more := x\\<rparr>) =\n                              None \\<longrightarrow>\n                              (\\<forall>xa.\n                                  accpt xa \\<and>\n                                  xa \\<in> dom\n      (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                                  (xa, xa) \\<notin> E\\<^sup>+))", "{"], ["proof (state)\nthis:\n  g_E (G\\<lparr>g_V0 := {hd (stack s)}\\<rparr>) = E\n\ngoal (6 subgoals):\n 1. on_init blue_dfs_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         lasso (empty_state x) = None \\<longrightarrow>\n         (\\<forall>xa.\n             accpt xa \\<and>\n             xa \\<in> dom (finished (empty_state x)) \\<longrightarrow>\n             (xa, xa) \\<notin> E\\<^sup>+))\n 2. \\<And>s s' v0.\n       \\<lbrakk>DFS_invar G blue_dfs_params s;\n        lasso s = None \\<longrightarrow>\n        (\\<forall>x.\n            accpt x \\<and> x \\<in> dom (finished s) \\<longrightarrow>\n            (x, x) \\<notin> E\\<^sup>+);\n        cond s; \\<not> is_break blue_dfs_params s; stack s = [];\n        v0 \\<in> V0; v0 \\<notin> dom (discovered s);\n        s' = new_root v0 s\\<rbrakk>\n       \\<Longrightarrow> on_new_root blue_dfs_params v0 s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso (s'\\<lparr>state.more := x\\<rparr>) =\n                              None \\<longrightarrow>\n                              (\\<forall>xa.\n                                  accpt xa \\<and>\n                                  xa \\<in> dom\n      (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                                  (xa, xa) \\<notin> E\\<^sup>+))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G blue_dfs_params s;\n        lasso s = None \\<longrightarrow>\n        (\\<forall>x.\n            accpt x \\<and> x \\<in> dom (finished s) \\<longrightarrow>\n            (x, x) \\<notin> E\\<^sup>+);\n        cond s; \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish blue_dfs_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso (s'\\<lparr>state.more := x\\<rparr>) =\n                              None \\<longrightarrow>\n                              (\\<forall>xa.\n                                  accpt xa \\<and>\n                                  xa \\<in> dom\n      (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                                  (xa, xa) \\<notin> E\\<^sup>+))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s;\n        lasso s = None \\<longrightarrow>\n        (\\<forall>x.\n            accpt x \\<and> x \\<in> dom (finished s) \\<longrightarrow>\n            (x, x) \\<notin> E\\<^sup>+);\n        cond s; \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso (s'\\<lparr>state.more := x\\<rparr>) =\n                              None \\<longrightarrow>\n                              (\\<forall>xa.\n                                  accpt xa \\<and>\n                                  xa \\<in> dom\n      (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                                  (xa, xa) \\<notin> E\\<^sup>+))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s;\n        lasso s = None \\<longrightarrow>\n        (\\<forall>x.\n            accpt x \\<and> x \\<in> dom (finished s) \\<longrightarrow>\n            (x, x) \\<notin> E\\<^sup>+);\n        cond s; \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso (s'\\<lparr>state.more := x\\<rparr>) =\n                              None \\<longrightarrow>\n                              (\\<forall>xa.\n                                  accpt xa \\<and>\n                                  xa \\<in> dom\n      (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                                  (xa, xa) \\<notin> E\\<^sup>+))\n 6. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s;\n        lasso s = None \\<longrightarrow>\n        (\\<forall>x.\n            accpt x \\<and> x \\<in> dom (finished s) \\<longrightarrow>\n            (x, x) \\<notin> E\\<^sup>+);\n        cond s; \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<notin> dom (discovered s);\n        s' =\n        discover u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso (s'\\<lparr>state.more := x\\<rparr>) =\n                              None \\<longrightarrow>\n                              (\\<forall>xa.\n                                  accpt xa \\<and>\n                                  xa \\<in> dom\n      (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                                  (xa, xa) \\<notin> E\\<^sup>+))", "(* TODO/FIXME: Ughly proof structure! *)"], ["proof (state)\nthis:\n  g_E (G\\<lparr>g_V0 := {hd (stack s)}\\<rparr>) = E\n\ngoal (6 subgoals):\n 1. on_init blue_dfs_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         lasso (empty_state x) = None \\<longrightarrow>\n         (\\<forall>xa.\n             accpt xa \\<and>\n             xa \\<in> dom (finished (empty_state x)) \\<longrightarrow>\n             (xa, xa) \\<notin> E\\<^sup>+))\n 2. \\<And>s s' v0.\n       \\<lbrakk>DFS_invar G blue_dfs_params s;\n        lasso s = None \\<longrightarrow>\n        (\\<forall>x.\n            accpt x \\<and> x \\<in> dom (finished s) \\<longrightarrow>\n            (x, x) \\<notin> E\\<^sup>+);\n        cond s; \\<not> is_break blue_dfs_params s; stack s = [];\n        v0 \\<in> V0; v0 \\<notin> dom (discovered s);\n        s' = new_root v0 s\\<rbrakk>\n       \\<Longrightarrow> on_new_root blue_dfs_params v0 s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso (s'\\<lparr>state.more := x\\<rparr>) =\n                              None \\<longrightarrow>\n                              (\\<forall>xa.\n                                  accpt xa \\<and>\n                                  xa \\<in> dom\n      (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                                  (xa, xa) \\<notin> E\\<^sup>+))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G blue_dfs_params s;\n        lasso s = None \\<longrightarrow>\n        (\\<forall>x.\n            accpt x \\<and> x \\<in> dom (finished s) \\<longrightarrow>\n            (x, x) \\<notin> E\\<^sup>+);\n        cond s; \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish blue_dfs_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso (s'\\<lparr>state.more := x\\<rparr>) =\n                              None \\<longrightarrow>\n                              (\\<forall>xa.\n                                  accpt xa \\<and>\n                                  xa \\<in> dom\n      (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                                  (xa, xa) \\<notin> E\\<^sup>+))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s;\n        lasso s = None \\<longrightarrow>\n        (\\<forall>x.\n            accpt x \\<and> x \\<in> dom (finished s) \\<longrightarrow>\n            (x, x) \\<notin> E\\<^sup>+);\n        cond s; \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso (s'\\<lparr>state.more := x\\<rparr>) =\n                              None \\<longrightarrow>\n                              (\\<forall>xa.\n                                  accpt xa \\<and>\n                                  xa \\<in> dom\n      (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                                  (xa, xa) \\<notin> E\\<^sup>+))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s;\n        lasso s = None \\<longrightarrow>\n        (\\<forall>x.\n            accpt x \\<and> x \\<in> dom (finished s) \\<longrightarrow>\n            (x, x) \\<notin> E\\<^sup>+);\n        cond s; \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso (s'\\<lparr>state.more := x\\<rparr>) =\n                              None \\<longrightarrow>\n                              (\\<forall>xa.\n                                  accpt xa \\<and>\n                                  xa \\<in> dom\n      (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                                  (xa, xa) \\<notin> E\\<^sup>+))\n 6. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s;\n        lasso s = None \\<longrightarrow>\n        (\\<forall>x.\n            accpt x \\<and> x \\<in> dom (finished s) \\<longrightarrow>\n            (x, x) \\<notin> E\\<^sup>+);\n        cond s; \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<notin> dom (discovered s);\n        s' =\n        discover u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso (s'\\<lparr>state.more := x\\<rparr>) =\n                              None \\<longrightarrow>\n                              (\\<forall>xa.\n                                  accpt xa \\<and>\n                                  xa \\<in> dom\n      (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                                  (xa, xa) \\<notin> E\\<^sup>+))", "fix R'::\"'v set\""], ["proof (state)\ngoal (6 subgoals):\n 1. on_init blue_dfs_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         lasso (empty_state x) = None \\<longrightarrow>\n         (\\<forall>xa.\n             accpt xa \\<and>\n             xa \\<in> dom (finished (empty_state x)) \\<longrightarrow>\n             (xa, xa) \\<notin> E\\<^sup>+))\n 2. \\<And>s s' v0.\n       \\<lbrakk>DFS_invar G blue_dfs_params s;\n        lasso s = None \\<longrightarrow>\n        (\\<forall>x.\n            accpt x \\<and> x \\<in> dom (finished s) \\<longrightarrow>\n            (x, x) \\<notin> E\\<^sup>+);\n        cond s; \\<not> is_break blue_dfs_params s; stack s = [];\n        v0 \\<in> V0; v0 \\<notin> dom (discovered s);\n        s' = new_root v0 s\\<rbrakk>\n       \\<Longrightarrow> on_new_root blue_dfs_params v0 s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso (s'\\<lparr>state.more := x\\<rparr>) =\n                              None \\<longrightarrow>\n                              (\\<forall>xa.\n                                  accpt xa \\<and>\n                                  xa \\<in> dom\n      (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                                  (xa, xa) \\<notin> E\\<^sup>+))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G blue_dfs_params s;\n        lasso s = None \\<longrightarrow>\n        (\\<forall>x.\n            accpt x \\<and> x \\<in> dom (finished s) \\<longrightarrow>\n            (x, x) \\<notin> E\\<^sup>+);\n        cond s; \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish blue_dfs_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso (s'\\<lparr>state.more := x\\<rparr>) =\n                              None \\<longrightarrow>\n                              (\\<forall>xa.\n                                  accpt xa \\<and>\n                                  xa \\<in> dom\n      (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                                  (xa, xa) \\<notin> E\\<^sup>+))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s;\n        lasso s = None \\<longrightarrow>\n        (\\<forall>x.\n            accpt x \\<and> x \\<in> dom (finished s) \\<longrightarrow>\n            (x, x) \\<notin> E\\<^sup>+);\n        cond s; \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso (s'\\<lparr>state.more := x\\<rparr>) =\n                              None \\<longrightarrow>\n                              (\\<forall>xa.\n                                  accpt xa \\<and>\n                                  xa \\<in> dom\n      (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                                  (xa, xa) \\<notin> E\\<^sup>+))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s;\n        lasso s = None \\<longrightarrow>\n        (\\<forall>x.\n            accpt x \\<and> x \\<in> dom (finished s) \\<longrightarrow>\n            (x, x) \\<notin> E\\<^sup>+);\n        cond s; \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso (s'\\<lparr>state.more := x\\<rparr>) =\n                              None \\<longrightarrow>\n                              (\\<forall>xa.\n                                  accpt xa \\<and>\n                                  xa \\<in> dom\n      (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                                  (xa, xa) \\<notin> E\\<^sup>+))\n 6. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s;\n        lasso s = None \\<longrightarrow>\n        (\\<forall>x.\n            accpt x \\<and> x \\<in> dom (finished s) \\<longrightarrow>\n            (x, x) \\<notin> E\\<^sup>+);\n        cond s; \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<notin> dom (discovered s);\n        s' =\n        discover u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso (s'\\<lparr>state.more := x\\<rparr>) =\n                              None \\<longrightarrow>\n                              (\\<forall>xa.\n                                  accpt xa \\<and>\n                                  xa \\<in> dom\n      (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                                  (xa, xa) \\<notin> E\\<^sup>+))", "let ?R' = \"R' \\<^cancel>\\<open>\\<union> red s\\<close>\""], ["proof (state)\ngoal (6 subgoals):\n 1. on_init blue_dfs_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         lasso (empty_state x) = None \\<longrightarrow>\n         (\\<forall>xa.\n             accpt xa \\<and>\n             xa \\<in> dom (finished (empty_state x)) \\<longrightarrow>\n             (xa, xa) \\<notin> E\\<^sup>+))\n 2. \\<And>s s' v0.\n       \\<lbrakk>DFS_invar G blue_dfs_params s;\n        lasso s = None \\<longrightarrow>\n        (\\<forall>x.\n            accpt x \\<and> x \\<in> dom (finished s) \\<longrightarrow>\n            (x, x) \\<notin> E\\<^sup>+);\n        cond s; \\<not> is_break blue_dfs_params s; stack s = [];\n        v0 \\<in> V0; v0 \\<notin> dom (discovered s);\n        s' = new_root v0 s\\<rbrakk>\n       \\<Longrightarrow> on_new_root blue_dfs_params v0 s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso (s'\\<lparr>state.more := x\\<rparr>) =\n                              None \\<longrightarrow>\n                              (\\<forall>xa.\n                                  accpt xa \\<and>\n                                  xa \\<in> dom\n      (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                                  (xa, xa) \\<notin> E\\<^sup>+))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G blue_dfs_params s;\n        lasso s = None \\<longrightarrow>\n        (\\<forall>x.\n            accpt x \\<and> x \\<in> dom (finished s) \\<longrightarrow>\n            (x, x) \\<notin> E\\<^sup>+);\n        cond s; \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish blue_dfs_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso (s'\\<lparr>state.more := x\\<rparr>) =\n                              None \\<longrightarrow>\n                              (\\<forall>xa.\n                                  accpt xa \\<and>\n                                  xa \\<in> dom\n      (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                                  (xa, xa) \\<notin> E\\<^sup>+))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s;\n        lasso s = None \\<longrightarrow>\n        (\\<forall>x.\n            accpt x \\<and> x \\<in> dom (finished s) \\<longrightarrow>\n            (x, x) \\<notin> E\\<^sup>+);\n        cond s; \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso (s'\\<lparr>state.more := x\\<rparr>) =\n                              None \\<longrightarrow>\n                              (\\<forall>xa.\n                                  accpt xa \\<and>\n                                  xa \\<in> dom\n      (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                                  (xa, xa) \\<notin> E\\<^sup>+))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s;\n        lasso s = None \\<longrightarrow>\n        (\\<forall>x.\n            accpt x \\<and> x \\<in> dom (finished s) \\<longrightarrow>\n            (x, x) \\<notin> E\\<^sup>+);\n        cond s; \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso (s'\\<lparr>state.more := x\\<rparr>) =\n                              None \\<longrightarrow>\n                              (\\<forall>xa.\n                                  accpt xa \\<and>\n                                  xa \\<in> dom\n      (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                                  (xa, xa) \\<notin> E\\<^sup>+))\n 6. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s;\n        lasso s = None \\<longrightarrow>\n        (\\<forall>x.\n            accpt x \\<and> x \\<in> dom (finished s) \\<longrightarrow>\n            (x, x) \\<notin> E\\<^sup>+);\n        cond s; \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<notin> dom (discovered s);\n        s' =\n        discover u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso (s'\\<lparr>state.more := x\\<rparr>) =\n                              None \\<longrightarrow>\n                              (\\<forall>xa.\n                                  accpt xa \\<and>\n                                  xa \\<in> dom\n      (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                                  (xa, xa) \\<notin> E\\<^sup>+))", "let ?s = \"s'\\<lparr> lasso := None, red := ?R'\\<rparr>\""], ["proof (state)\ngoal (6 subgoals):\n 1. on_init blue_dfs_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         lasso (empty_state x) = None \\<longrightarrow>\n         (\\<forall>xa.\n             accpt xa \\<and>\n             xa \\<in> dom (finished (empty_state x)) \\<longrightarrow>\n             (xa, xa) \\<notin> E\\<^sup>+))\n 2. \\<And>s s' v0.\n       \\<lbrakk>DFS_invar G blue_dfs_params s;\n        lasso s = None \\<longrightarrow>\n        (\\<forall>x.\n            accpt x \\<and> x \\<in> dom (finished s) \\<longrightarrow>\n            (x, x) \\<notin> E\\<^sup>+);\n        cond s; \\<not> is_break blue_dfs_params s; stack s = [];\n        v0 \\<in> V0; v0 \\<notin> dom (discovered s);\n        s' = new_root v0 s\\<rbrakk>\n       \\<Longrightarrow> on_new_root blue_dfs_params v0 s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso (s'\\<lparr>state.more := x\\<rparr>) =\n                              None \\<longrightarrow>\n                              (\\<forall>xa.\n                                  accpt xa \\<and>\n                                  xa \\<in> dom\n      (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                                  (xa, xa) \\<notin> E\\<^sup>+))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G blue_dfs_params s;\n        lasso s = None \\<longrightarrow>\n        (\\<forall>x.\n            accpt x \\<and> x \\<in> dom (finished s) \\<longrightarrow>\n            (x, x) \\<notin> E\\<^sup>+);\n        cond s; \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish blue_dfs_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso (s'\\<lparr>state.more := x\\<rparr>) =\n                              None \\<longrightarrow>\n                              (\\<forall>xa.\n                                  accpt xa \\<and>\n                                  xa \\<in> dom\n      (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                                  (xa, xa) \\<notin> E\\<^sup>+))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s;\n        lasso s = None \\<longrightarrow>\n        (\\<forall>x.\n            accpt x \\<and> x \\<in> dom (finished s) \\<longrightarrow>\n            (x, x) \\<notin> E\\<^sup>+);\n        cond s; \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso (s'\\<lparr>state.more := x\\<rparr>) =\n                              None \\<longrightarrow>\n                              (\\<forall>xa.\n                                  accpt xa \\<and>\n                                  xa \\<in> dom\n      (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                                  (xa, xa) \\<notin> E\\<^sup>+))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s;\n        lasso s = None \\<longrightarrow>\n        (\\<forall>x.\n            accpt x \\<and> x \\<in> dom (finished s) \\<longrightarrow>\n            (x, x) \\<notin> E\\<^sup>+);\n        cond s; \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso (s'\\<lparr>state.more := x\\<rparr>) =\n                              None \\<longrightarrow>\n                              (\\<forall>xa.\n                                  accpt xa \\<and>\n                                  xa \\<in> dom\n      (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                                  (xa, xa) \\<notin> E\\<^sup>+))\n 6. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s;\n        lasso s = None \\<longrightarrow>\n        (\\<forall>x.\n            accpt x \\<and> x \\<in> dom (finished s) \\<longrightarrow>\n            (x, x) \\<notin> E\\<^sup>+);\n        cond s; \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<notin> dom (discovered s);\n        s' =\n        discover u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso (s'\\<lparr>state.more := x\\<rparr>) =\n                              None \\<longrightarrow>\n                              (\\<forall>xa.\n                                  accpt xa \\<and>\n                                  xa \\<in> dom\n      (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                                  (xa, xa) \\<notin> E\\<^sup>+))", "assume \"\\<And>v. (hd (stack s), v) \\<in> ?rE\\<^sup>+ \\<Longrightarrow> \\<not> ?onstack v\"\n      and accpt: \"accpt u\"\n      and NL[simp]: \"lasso s = None\""], ["proof (state)\nthis:\n  (hd (stack s), ?v8)\n  \\<in> (rel_restrict E (red s))\\<^sup>+ \\<Longrightarrow>\n  ?v8 \\<notin> set (stack s)\n  accpt u\n  lasso s = None\n\ngoal (6 subgoals):\n 1. on_init blue_dfs_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         lasso (empty_state x) = None \\<longrightarrow>\n         (\\<forall>xa.\n             accpt xa \\<and>\n             xa \\<in> dom (finished (empty_state x)) \\<longrightarrow>\n             (xa, xa) \\<notin> E\\<^sup>+))\n 2. \\<And>s s' v0.\n       \\<lbrakk>DFS_invar G blue_dfs_params s;\n        lasso s = None \\<longrightarrow>\n        (\\<forall>x.\n            accpt x \\<and> x \\<in> dom (finished s) \\<longrightarrow>\n            (x, x) \\<notin> E\\<^sup>+);\n        cond s; \\<not> is_break blue_dfs_params s; stack s = [];\n        v0 \\<in> V0; v0 \\<notin> dom (discovered s);\n        s' = new_root v0 s\\<rbrakk>\n       \\<Longrightarrow> on_new_root blue_dfs_params v0 s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso (s'\\<lparr>state.more := x\\<rparr>) =\n                              None \\<longrightarrow>\n                              (\\<forall>xa.\n                                  accpt xa \\<and>\n                                  xa \\<in> dom\n      (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                                  (xa, xa) \\<notin> E\\<^sup>+))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G blue_dfs_params s;\n        lasso s = None \\<longrightarrow>\n        (\\<forall>x.\n            accpt x \\<and> x \\<in> dom (finished s) \\<longrightarrow>\n            (x, x) \\<notin> E\\<^sup>+);\n        cond s; \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish blue_dfs_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso (s'\\<lparr>state.more := x\\<rparr>) =\n                              None \\<longrightarrow>\n                              (\\<forall>xa.\n                                  accpt xa \\<and>\n                                  xa \\<in> dom\n      (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                                  (xa, xa) \\<notin> E\\<^sup>+))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s;\n        lasso s = None \\<longrightarrow>\n        (\\<forall>x.\n            accpt x \\<and> x \\<in> dom (finished s) \\<longrightarrow>\n            (x, x) \\<notin> E\\<^sup>+);\n        cond s; \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso (s'\\<lparr>state.more := x\\<rparr>) =\n                              None \\<longrightarrow>\n                              (\\<forall>xa.\n                                  accpt xa \\<and>\n                                  xa \\<in> dom\n      (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                                  (xa, xa) \\<notin> E\\<^sup>+))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s;\n        lasso s = None \\<longrightarrow>\n        (\\<forall>x.\n            accpt x \\<and> x \\<in> dom (finished s) \\<longrightarrow>\n            (x, x) \\<notin> E\\<^sup>+);\n        cond s; \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso (s'\\<lparr>state.more := x\\<rparr>) =\n                              None \\<longrightarrow>\n                              (\\<forall>xa.\n                                  accpt xa \\<and>\n                                  xa \\<in> dom\n      (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                                  (xa, xa) \\<notin> E\\<^sup>+))\n 6. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s;\n        lasso s = None \\<longrightarrow>\n        (\\<forall>x.\n            accpt x \\<and> x \\<in> dom (finished s) \\<longrightarrow>\n            (x, x) \\<notin> E\\<^sup>+);\n        cond s; \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<notin> dom (discovered s);\n        s' =\n        discover u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso (s'\\<lparr>state.more := x\\<rparr>) =\n                              None \\<longrightarrow>\n                              (\\<forall>xa.\n                                  accpt xa \\<and>\n                                  xa \\<in> dom\n      (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                                  (xa, xa) \\<notin> E\\<^sup>+))", "hence no_hd_cycle: \"(hd (stack s), hd (stack s)) \\<notin> ?rE\\<^sup>+\""], ["proof (prove)\nusing this:\n  (hd (stack s), ?v8)\n  \\<in> (rel_restrict E (red s))\\<^sup>+ \\<Longrightarrow>\n  ?v8 \\<notin> set (stack s)\n  accpt u\n  lasso s = None\n\ngoal (1 subgoal):\n 1. (hd (stack s), hd (stack s)) \\<notin> (rel_restrict E (red s))\\<^sup>+", "by auto"], ["proof (state)\nthis:\n  (hd (stack s), hd (stack s)) \\<notin> (rel_restrict E (red s))\\<^sup>+\n\ngoal (6 subgoals):\n 1. on_init blue_dfs_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         lasso (empty_state x) = None \\<longrightarrow>\n         (\\<forall>xa.\n             accpt xa \\<and>\n             xa \\<in> dom (finished (empty_state x)) \\<longrightarrow>\n             (xa, xa) \\<notin> E\\<^sup>+))\n 2. \\<And>s s' v0.\n       \\<lbrakk>DFS_invar G blue_dfs_params s;\n        lasso s = None \\<longrightarrow>\n        (\\<forall>x.\n            accpt x \\<and> x \\<in> dom (finished s) \\<longrightarrow>\n            (x, x) \\<notin> E\\<^sup>+);\n        cond s; \\<not> is_break blue_dfs_params s; stack s = [];\n        v0 \\<in> V0; v0 \\<notin> dom (discovered s);\n        s' = new_root v0 s\\<rbrakk>\n       \\<Longrightarrow> on_new_root blue_dfs_params v0 s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso (s'\\<lparr>state.more := x\\<rparr>) =\n                              None \\<longrightarrow>\n                              (\\<forall>xa.\n                                  accpt xa \\<and>\n                                  xa \\<in> dom\n      (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                                  (xa, xa) \\<notin> E\\<^sup>+))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G blue_dfs_params s;\n        lasso s = None \\<longrightarrow>\n        (\\<forall>x.\n            accpt x \\<and> x \\<in> dom (finished s) \\<longrightarrow>\n            (x, x) \\<notin> E\\<^sup>+);\n        cond s; \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish blue_dfs_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso (s'\\<lparr>state.more := x\\<rparr>) =\n                              None \\<longrightarrow>\n                              (\\<forall>xa.\n                                  accpt xa \\<and>\n                                  xa \\<in> dom\n      (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                                  (xa, xa) \\<notin> E\\<^sup>+))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s;\n        lasso s = None \\<longrightarrow>\n        (\\<forall>x.\n            accpt x \\<and> x \\<in> dom (finished s) \\<longrightarrow>\n            (x, x) \\<notin> E\\<^sup>+);\n        cond s; \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso (s'\\<lparr>state.more := x\\<rparr>) =\n                              None \\<longrightarrow>\n                              (\\<forall>xa.\n                                  accpt xa \\<and>\n                                  xa \\<in> dom\n      (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                                  (xa, xa) \\<notin> E\\<^sup>+))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s;\n        lasso s = None \\<longrightarrow>\n        (\\<forall>x.\n            accpt x \\<and> x \\<in> dom (finished s) \\<longrightarrow>\n            (x, x) \\<notin> E\\<^sup>+);\n        cond s; \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso (s'\\<lparr>state.more := x\\<rparr>) =\n                              None \\<longrightarrow>\n                              (\\<forall>xa.\n                                  accpt xa \\<and>\n                                  xa \\<in> dom\n      (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                                  (xa, xa) \\<notin> E\\<^sup>+))\n 6. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s;\n        lasso s = None \\<longrightarrow>\n        (\\<forall>x.\n            accpt x \\<and> x \\<in> dom (finished s) \\<longrightarrow>\n            (x, x) \\<notin> E\\<^sup>+);\n        cond s; \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<notin> dom (discovered s);\n        s' =\n        discover u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso (s'\\<lparr>state.more := x\\<rparr>) =\n                              None \\<longrightarrow>\n                              (\\<forall>xa.\n                                  accpt xa \\<and>\n                                  xa \\<in> dom\n      (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                                  (xa, xa) \\<notin> E\\<^sup>+))", "from finish"], ["proof (chain)\npicking this:\n  DFS_invar G blue_dfs_params s\n  lasso s = None \\<longrightarrow>\n  (\\<forall>x.\n      accpt x \\<and> x \\<in> dom (finished s) \\<longrightarrow>\n      (x, x) \\<notin> E\\<^sup>+)\n  cond s\n  \\<not> is_break blue_dfs_params s\n  stack s \\<noteq> []\n  u = hd (stack s)\n  pending s `` {u} = {}\n  s' = finish u s", "have \"stack s \\<noteq> []\""], ["proof (prove)\nusing this:\n  DFS_invar G blue_dfs_params s\n  lasso s = None \\<longrightarrow>\n  (\\<forall>x.\n      accpt x \\<and> x \\<in> dom (finished s) \\<longrightarrow>\n      (x, x) \\<notin> E\\<^sup>+)\n  cond s\n  \\<not> is_break blue_dfs_params s\n  stack s \\<noteq> []\n  u = hd (stack s)\n  pending s `` {u} = {}\n  s' = finish u s\n\ngoal (1 subgoal):\n 1. stack s \\<noteq> []", "by simp"], ["proof (state)\nthis:\n  stack s \\<noteq> []\n\ngoal (6 subgoals):\n 1. on_init blue_dfs_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         lasso (empty_state x) = None \\<longrightarrow>\n         (\\<forall>xa.\n             accpt xa \\<and>\n             xa \\<in> dom (finished (empty_state x)) \\<longrightarrow>\n             (xa, xa) \\<notin> E\\<^sup>+))\n 2. \\<And>s s' v0.\n       \\<lbrakk>DFS_invar G blue_dfs_params s;\n        lasso s = None \\<longrightarrow>\n        (\\<forall>x.\n            accpt x \\<and> x \\<in> dom (finished s) \\<longrightarrow>\n            (x, x) \\<notin> E\\<^sup>+);\n        cond s; \\<not> is_break blue_dfs_params s; stack s = [];\n        v0 \\<in> V0; v0 \\<notin> dom (discovered s);\n        s' = new_root v0 s\\<rbrakk>\n       \\<Longrightarrow> on_new_root blue_dfs_params v0 s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso (s'\\<lparr>state.more := x\\<rparr>) =\n                              None \\<longrightarrow>\n                              (\\<forall>xa.\n                                  accpt xa \\<and>\n                                  xa \\<in> dom\n      (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                                  (xa, xa) \\<notin> E\\<^sup>+))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G blue_dfs_params s;\n        lasso s = None \\<longrightarrow>\n        (\\<forall>x.\n            accpt x \\<and> x \\<in> dom (finished s) \\<longrightarrow>\n            (x, x) \\<notin> E\\<^sup>+);\n        cond s; \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish blue_dfs_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso (s'\\<lparr>state.more := x\\<rparr>) =\n                              None \\<longrightarrow>\n                              (\\<forall>xa.\n                                  accpt xa \\<and>\n                                  xa \\<in> dom\n      (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                                  (xa, xa) \\<notin> E\\<^sup>+))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s;\n        lasso s = None \\<longrightarrow>\n        (\\<forall>x.\n            accpt x \\<and> x \\<in> dom (finished s) \\<longrightarrow>\n            (x, x) \\<notin> E\\<^sup>+);\n        cond s; \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso (s'\\<lparr>state.more := x\\<rparr>) =\n                              None \\<longrightarrow>\n                              (\\<forall>xa.\n                                  accpt xa \\<and>\n                                  xa \\<in> dom\n      (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                                  (xa, xa) \\<notin> E\\<^sup>+))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s;\n        lasso s = None \\<longrightarrow>\n        (\\<forall>x.\n            accpt x \\<and> x \\<in> dom (finished s) \\<longrightarrow>\n            (x, x) \\<notin> E\\<^sup>+);\n        cond s; \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso (s'\\<lparr>state.more := x\\<rparr>) =\n                              None \\<longrightarrow>\n                              (\\<forall>xa.\n                                  accpt xa \\<and>\n                                  xa \\<in> dom\n      (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                                  (xa, xa) \\<notin> E\\<^sup>+))\n 6. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s;\n        lasso s = None \\<longrightarrow>\n        (\\<forall>x.\n            accpt x \\<and> x \\<in> dom (finished s) \\<longrightarrow>\n            (x, x) \\<notin> E\\<^sup>+);\n        cond s; \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<notin> dom (discovered s);\n        s' =\n        discover u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso (s'\\<lparr>state.more := x\\<rparr>) =\n                              None \\<longrightarrow>\n                              (\\<forall>xa.\n                                  accpt xa \\<and>\n                                  xa \\<in> dom\n      (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                                  (xa, xa) \\<notin> E\\<^sup>+))", "from hd_in_set[OF this]"], ["proof (chain)\npicking this:\n  hd (stack s) \\<in> set (stack s)", "have \"hd (stack s) \\<notin> red s\""], ["proof (prove)\nusing this:\n  hd (stack s) \\<in> set (stack s)\n\ngoal (1 subgoal):\n 1. hd (stack s) \\<notin> red s", "using red_stack_disjoint"], ["proof (prove)\nusing this:\n  hd (stack s) \\<in> set (stack s)\n  lasso s = None \\<Longrightarrow> set (stack s) \\<inter> red s = {}\n\ngoal (1 subgoal):\n 1. hd (stack s) \\<notin> red s", "by auto"], ["proof (state)\nthis:\n  hd (stack s) \\<notin> red s\n\ngoal (6 subgoals):\n 1. on_init blue_dfs_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         lasso (empty_state x) = None \\<longrightarrow>\n         (\\<forall>xa.\n             accpt xa \\<and>\n             xa \\<in> dom (finished (empty_state x)) \\<longrightarrow>\n             (xa, xa) \\<notin> E\\<^sup>+))\n 2. \\<And>s s' v0.\n       \\<lbrakk>DFS_invar G blue_dfs_params s;\n        lasso s = None \\<longrightarrow>\n        (\\<forall>x.\n            accpt x \\<and> x \\<in> dom (finished s) \\<longrightarrow>\n            (x, x) \\<notin> E\\<^sup>+);\n        cond s; \\<not> is_break blue_dfs_params s; stack s = [];\n        v0 \\<in> V0; v0 \\<notin> dom (discovered s);\n        s' = new_root v0 s\\<rbrakk>\n       \\<Longrightarrow> on_new_root blue_dfs_params v0 s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso (s'\\<lparr>state.more := x\\<rparr>) =\n                              None \\<longrightarrow>\n                              (\\<forall>xa.\n                                  accpt xa \\<and>\n                                  xa \\<in> dom\n      (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                                  (xa, xa) \\<notin> E\\<^sup>+))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G blue_dfs_params s;\n        lasso s = None \\<longrightarrow>\n        (\\<forall>x.\n            accpt x \\<and> x \\<in> dom (finished s) \\<longrightarrow>\n            (x, x) \\<notin> E\\<^sup>+);\n        cond s; \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish blue_dfs_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso (s'\\<lparr>state.more := x\\<rparr>) =\n                              None \\<longrightarrow>\n                              (\\<forall>xa.\n                                  accpt xa \\<and>\n                                  xa \\<in> dom\n      (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                                  (xa, xa) \\<notin> E\\<^sup>+))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s;\n        lasso s = None \\<longrightarrow>\n        (\\<forall>x.\n            accpt x \\<and> x \\<in> dom (finished s) \\<longrightarrow>\n            (x, x) \\<notin> E\\<^sup>+);\n        cond s; \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso (s'\\<lparr>state.more := x\\<rparr>) =\n                              None \\<longrightarrow>\n                              (\\<forall>xa.\n                                  accpt xa \\<and>\n                                  xa \\<in> dom\n      (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                                  (xa, xa) \\<notin> E\\<^sup>+))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s;\n        lasso s = None \\<longrightarrow>\n        (\\<forall>x.\n            accpt x \\<and> x \\<in> dom (finished s) \\<longrightarrow>\n            (x, x) \\<notin> E\\<^sup>+);\n        cond s; \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso (s'\\<lparr>state.more := x\\<rparr>) =\n                              None \\<longrightarrow>\n                              (\\<forall>xa.\n                                  accpt xa \\<and>\n                                  xa \\<in> dom\n      (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                                  (xa, xa) \\<notin> E\\<^sup>+))\n 6. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s;\n        lasso s = None \\<longrightarrow>\n        (\\<forall>x.\n            accpt x \\<and> x \\<in> dom (finished s) \\<longrightarrow>\n            (x, x) \\<notin> E\\<^sup>+);\n        cond s; \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<notin> dom (discovered s);\n        s' =\n        discover u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso (s'\\<lparr>state.more := x\\<rparr>) =\n                              None \\<longrightarrow>\n                              (\\<forall>xa.\n                                  accpt xa \\<and>\n                                  xa \\<in> dom\n      (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                                  (xa, xa) \\<notin> E\\<^sup>+))", "hence \"(hd (stack s),hd (stack s)) \\<notin> E\\<^sup>+\""], ["proof (prove)\nusing this:\n  hd (stack s) \\<notin> red s\n\ngoal (1 subgoal):\n 1. (hd (stack s), hd (stack s)) \\<notin> E\\<^sup>+", "using no_hd_cycle rel_restrict_tranclI red_closed[OF NL]"], ["proof (prove)\nusing this:\n  hd (stack s) \\<notin> red s\n  (hd (stack s), hd (stack s)) \\<notin> (rel_restrict E (red s))\\<^sup>+\n  \\<lbrakk>(?x, ?y) \\<in> ?E\\<^sup>+; ?x \\<notin> ?R; ?y \\<notin> ?R;\n   ?E `` ?R \\<subseteq> ?R\\<rbrakk>\n  \\<Longrightarrow> (?x, ?y) \\<in> (rel_restrict ?E ?R)\\<^sup>+\n  E `` red s \\<subseteq> red s\n\ngoal (1 subgoal):\n 1. (hd (stack s), hd (stack s)) \\<notin> E\\<^sup>+", "by metis"], ["proof (state)\nthis:\n  (hd (stack s), hd (stack s)) \\<notin> E\\<^sup>+\n\ngoal (6 subgoals):\n 1. on_init blue_dfs_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         lasso (empty_state x) = None \\<longrightarrow>\n         (\\<forall>xa.\n             accpt xa \\<and>\n             xa \\<in> dom (finished (empty_state x)) \\<longrightarrow>\n             (xa, xa) \\<notin> E\\<^sup>+))\n 2. \\<And>s s' v0.\n       \\<lbrakk>DFS_invar G blue_dfs_params s;\n        lasso s = None \\<longrightarrow>\n        (\\<forall>x.\n            accpt x \\<and> x \\<in> dom (finished s) \\<longrightarrow>\n            (x, x) \\<notin> E\\<^sup>+);\n        cond s; \\<not> is_break blue_dfs_params s; stack s = [];\n        v0 \\<in> V0; v0 \\<notin> dom (discovered s);\n        s' = new_root v0 s\\<rbrakk>\n       \\<Longrightarrow> on_new_root blue_dfs_params v0 s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso (s'\\<lparr>state.more := x\\<rparr>) =\n                              None \\<longrightarrow>\n                              (\\<forall>xa.\n                                  accpt xa \\<and>\n                                  xa \\<in> dom\n      (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                                  (xa, xa) \\<notin> E\\<^sup>+))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G blue_dfs_params s;\n        lasso s = None \\<longrightarrow>\n        (\\<forall>x.\n            accpt x \\<and> x \\<in> dom (finished s) \\<longrightarrow>\n            (x, x) \\<notin> E\\<^sup>+);\n        cond s; \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish blue_dfs_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso (s'\\<lparr>state.more := x\\<rparr>) =\n                              None \\<longrightarrow>\n                              (\\<forall>xa.\n                                  accpt xa \\<and>\n                                  xa \\<in> dom\n      (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                                  (xa, xa) \\<notin> E\\<^sup>+))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s;\n        lasso s = None \\<longrightarrow>\n        (\\<forall>x.\n            accpt x \\<and> x \\<in> dom (finished s) \\<longrightarrow>\n            (x, x) \\<notin> E\\<^sup>+);\n        cond s; \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso (s'\\<lparr>state.more := x\\<rparr>) =\n                              None \\<longrightarrow>\n                              (\\<forall>xa.\n                                  accpt xa \\<and>\n                                  xa \\<in> dom\n      (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                                  (xa, xa) \\<notin> E\\<^sup>+))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s;\n        lasso s = None \\<longrightarrow>\n        (\\<forall>x.\n            accpt x \\<and> x \\<in> dom (finished s) \\<longrightarrow>\n            (x, x) \\<notin> E\\<^sup>+);\n        cond s; \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso (s'\\<lparr>state.more := x\\<rparr>) =\n                              None \\<longrightarrow>\n                              (\\<forall>xa.\n                                  accpt xa \\<and>\n                                  xa \\<in> dom\n      (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                                  (xa, xa) \\<notin> E\\<^sup>+))\n 6. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s;\n        lasso s = None \\<longrightarrow>\n        (\\<forall>x.\n            accpt x \\<and> x \\<in> dom (finished s) \\<longrightarrow>\n            (x, x) \\<notin> E\\<^sup>+);\n        cond s; \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<notin> dom (discovered s);\n        s' =\n        discover u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso (s'\\<lparr>state.more := x\\<rparr>) =\n                              None \\<longrightarrow>\n                              (\\<forall>xa.\n                                  accpt xa \\<and>\n                                  xa \\<in> dom\n      (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                                  (xa, xa) \\<notin> E\\<^sup>+))", "with accpt finish"], ["proof (chain)\npicking this:\n  accpt u\n  DFS_invar G blue_dfs_params s\n  lasso s = None \\<longrightarrow>\n  (\\<forall>x.\n      accpt x \\<and> x \\<in> dom (finished s) \\<longrightarrow>\n      (x, x) \\<notin> E\\<^sup>+)\n  cond s\n  \\<not> is_break blue_dfs_params s\n  stack s \\<noteq> []\n  u = hd (stack s)\n  pending s `` {u} = {}\n  s' = finish u s\n  (hd (stack s), hd (stack s)) \\<notin> E\\<^sup>+", "have \n        \"\\<forall>x. accpt x \\<and> x \\<in> dom (finished ?s) \\<longrightarrow> (x,x) \\<notin> E\\<^sup>+\""], ["proof (prove)\nusing this:\n  accpt u\n  DFS_invar G blue_dfs_params s\n  lasso s = None \\<longrightarrow>\n  (\\<forall>x.\n      accpt x \\<and> x \\<in> dom (finished s) \\<longrightarrow>\n      (x, x) \\<notin> E\\<^sup>+)\n  cond s\n  \\<not> is_break blue_dfs_params s\n  stack s \\<noteq> []\n  u = hd (stack s)\n  pending s `` {u} = {}\n  s' = finish u s\n  (hd (stack s), hd (stack s)) \\<notin> E\\<^sup>+\n\ngoal (1 subgoal):\n 1. \\<forall>x.\n       accpt x \\<and>\n       x \\<in> dom (finished\n                     (lasso_update Map.empty s'\n                      \\<lparr>red := R'\\<rparr>)) \\<longrightarrow>\n       (x, x) \\<notin> E\\<^sup>+", "by auto"], ["proof (state)\nthis:\n  \\<forall>x.\n     accpt x \\<and>\n     x \\<in> dom (finished\n                   (lasso_update Map.empty s'\n                    \\<lparr>red := R'\\<rparr>)) \\<longrightarrow>\n     (x, x) \\<notin> E\\<^sup>+\n\ngoal (6 subgoals):\n 1. on_init blue_dfs_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         lasso (empty_state x) = None \\<longrightarrow>\n         (\\<forall>xa.\n             accpt xa \\<and>\n             xa \\<in> dom (finished (empty_state x)) \\<longrightarrow>\n             (xa, xa) \\<notin> E\\<^sup>+))\n 2. \\<And>s s' v0.\n       \\<lbrakk>DFS_invar G blue_dfs_params s;\n        lasso s = None \\<longrightarrow>\n        (\\<forall>x.\n            accpt x \\<and> x \\<in> dom (finished s) \\<longrightarrow>\n            (x, x) \\<notin> E\\<^sup>+);\n        cond s; \\<not> is_break blue_dfs_params s; stack s = [];\n        v0 \\<in> V0; v0 \\<notin> dom (discovered s);\n        s' = new_root v0 s\\<rbrakk>\n       \\<Longrightarrow> on_new_root blue_dfs_params v0 s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso (s'\\<lparr>state.more := x\\<rparr>) =\n                              None \\<longrightarrow>\n                              (\\<forall>xa.\n                                  accpt xa \\<and>\n                                  xa \\<in> dom\n      (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                                  (xa, xa) \\<notin> E\\<^sup>+))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G blue_dfs_params s;\n        lasso s = None \\<longrightarrow>\n        (\\<forall>x.\n            accpt x \\<and> x \\<in> dom (finished s) \\<longrightarrow>\n            (x, x) \\<notin> E\\<^sup>+);\n        cond s; \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish blue_dfs_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso (s'\\<lparr>state.more := x\\<rparr>) =\n                              None \\<longrightarrow>\n                              (\\<forall>xa.\n                                  accpt xa \\<and>\n                                  xa \\<in> dom\n      (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                                  (xa, xa) \\<notin> E\\<^sup>+))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s;\n        lasso s = None \\<longrightarrow>\n        (\\<forall>x.\n            accpt x \\<and> x \\<in> dom (finished s) \\<longrightarrow>\n            (x, x) \\<notin> E\\<^sup>+);\n        cond s; \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso (s'\\<lparr>state.more := x\\<rparr>) =\n                              None \\<longrightarrow>\n                              (\\<forall>xa.\n                                  accpt xa \\<and>\n                                  xa \\<in> dom\n      (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                                  (xa, xa) \\<notin> E\\<^sup>+))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s;\n        lasso s = None \\<longrightarrow>\n        (\\<forall>x.\n            accpt x \\<and> x \\<in> dom (finished s) \\<longrightarrow>\n            (x, x) \\<notin> E\\<^sup>+);\n        cond s; \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso (s'\\<lparr>state.more := x\\<rparr>) =\n                              None \\<longrightarrow>\n                              (\\<forall>xa.\n                                  accpt xa \\<and>\n                                  xa \\<in> dom\n      (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                                  (xa, xa) \\<notin> E\\<^sup>+))\n 6. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s;\n        lasso s = None \\<longrightarrow>\n        (\\<forall>x.\n            accpt x \\<and> x \\<in> dom (finished s) \\<longrightarrow>\n            (x, x) \\<notin> E\\<^sup>+);\n        cond s; \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<notin> dom (discovered s);\n        s' =\n        discover u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso (s'\\<lparr>state.more := x\\<rparr>) =\n                              None \\<longrightarrow>\n                              (\\<forall>xa.\n                                  accpt xa \\<and>\n                                  xa \\<in> dom\n      (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                                  (xa, xa) \\<notin> E\\<^sup>+))", "}"], ["proof (state)\nthis:\n  \\<lbrakk>\\<And>v.\n              (hd (stack s), v)\n              \\<in> (rel_restrict E (red s))\\<^sup>+ \\<Longrightarrow>\n              v \\<notin> set (stack s);\n   accpt u; lasso s = None\\<rbrakk>\n  \\<Longrightarrow> \\<forall>x.\n                       accpt x \\<and>\n                       x \\<in> dom (finished\n                                     (lasso_update Map.empty s'\n\\<lparr>red := ?R'10\\<rparr>)) \\<longrightarrow>\n                       (x, x) \\<notin> E\\<^sup>+\n\ngoal (6 subgoals):\n 1. on_init blue_dfs_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         lasso (empty_state x) = None \\<longrightarrow>\n         (\\<forall>xa.\n             accpt xa \\<and>\n             xa \\<in> dom (finished (empty_state x)) \\<longrightarrow>\n             (xa, xa) \\<notin> E\\<^sup>+))\n 2. \\<And>s s' v0.\n       \\<lbrakk>DFS_invar G blue_dfs_params s;\n        lasso s = None \\<longrightarrow>\n        (\\<forall>x.\n            accpt x \\<and> x \\<in> dom (finished s) \\<longrightarrow>\n            (x, x) \\<notin> E\\<^sup>+);\n        cond s; \\<not> is_break blue_dfs_params s; stack s = [];\n        v0 \\<in> V0; v0 \\<notin> dom (discovered s);\n        s' = new_root v0 s\\<rbrakk>\n       \\<Longrightarrow> on_new_root blue_dfs_params v0 s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso (s'\\<lparr>state.more := x\\<rparr>) =\n                              None \\<longrightarrow>\n                              (\\<forall>xa.\n                                  accpt xa \\<and>\n                                  xa \\<in> dom\n      (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                                  (xa, xa) \\<notin> E\\<^sup>+))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G blue_dfs_params s;\n        lasso s = None \\<longrightarrow>\n        (\\<forall>x.\n            accpt x \\<and> x \\<in> dom (finished s) \\<longrightarrow>\n            (x, x) \\<notin> E\\<^sup>+);\n        cond s; \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish blue_dfs_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso (s'\\<lparr>state.more := x\\<rparr>) =\n                              None \\<longrightarrow>\n                              (\\<forall>xa.\n                                  accpt xa \\<and>\n                                  xa \\<in> dom\n      (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                                  (xa, xa) \\<notin> E\\<^sup>+))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s;\n        lasso s = None \\<longrightarrow>\n        (\\<forall>x.\n            accpt x \\<and> x \\<in> dom (finished s) \\<longrightarrow>\n            (x, x) \\<notin> E\\<^sup>+);\n        cond s; \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso (s'\\<lparr>state.more := x\\<rparr>) =\n                              None \\<longrightarrow>\n                              (\\<forall>xa.\n                                  accpt xa \\<and>\n                                  xa \\<in> dom\n      (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                                  (xa, xa) \\<notin> E\\<^sup>+))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s;\n        lasso s = None \\<longrightarrow>\n        (\\<forall>x.\n            accpt x \\<and> x \\<in> dom (finished s) \\<longrightarrow>\n            (x, x) \\<notin> E\\<^sup>+);\n        cond s; \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso (s'\\<lparr>state.more := x\\<rparr>) =\n                              None \\<longrightarrow>\n                              (\\<forall>xa.\n                                  accpt xa \\<and>\n                                  xa \\<in> dom\n      (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                                  (xa, xa) \\<notin> E\\<^sup>+))\n 6. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s;\n        lasso s = None \\<longrightarrow>\n        (\\<forall>x.\n            accpt x \\<and> x \\<in> dom (finished s) \\<longrightarrow>\n            (x, x) \\<notin> E\\<^sup>+);\n        cond s; \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<notin> dom (discovered s);\n        s' =\n        discover u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso (s'\\<lparr>state.more := x\\<rparr>) =\n                              None \\<longrightarrow>\n                              (\\<forall>xa.\n                                  accpt xa \\<and>\n                                  xa \\<in> dom\n      (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                                  (xa, xa) \\<notin> E\\<^sup>+))", "with finish"], ["proof (chain)\npicking this:\n  DFS_invar G blue_dfs_params s\n  lasso s = None \\<longrightarrow>\n  (\\<forall>x.\n      accpt x \\<and> x \\<in> dom (finished s) \\<longrightarrow>\n      (x, x) \\<notin> E\\<^sup>+)\n  cond s\n  \\<not> is_break blue_dfs_params s\n  stack s \\<noteq> []\n  u = hd (stack s)\n  pending s `` {u} = {}\n  s' = finish u s\n  \\<lbrakk>\\<And>v.\n              (hd (stack s), v)\n              \\<in> (rel_restrict E (red s))\\<^sup>+ \\<Longrightarrow>\n              v \\<notin> set (stack s);\n   accpt u; lasso s = None\\<rbrakk>\n  \\<Longrightarrow> \\<forall>x.\n                       accpt x \\<and>\n                       x \\<in> dom (finished\n                                     (lasso_update Map.empty s'\n\\<lparr>red := ?R'10\\<rparr>)) \\<longrightarrow>\n                       (x, x) \\<notin> E\\<^sup>+", "have\n      \"red_dfs (red s) ?onstack (hd (stack s))\n         \\<le> SPEC (\\<lambda>x. \\<forall>R. x = Inl R \\<longrightarrow>\n             DFS_invar G blue_dfs_params (lasso_update Map.empty s'\\<lparr>red := R \\<^cancel>\\<open>\\<union> red s\\<close>\\<rparr>) \\<longrightarrow>\n             (\\<forall>x. accpt x \\<and> x\\<in>dom (finished s') \\<longrightarrow> (x, x) \\<notin> E\\<^sup>+))\""], ["proof (prove)\nusing this:\n  DFS_invar G blue_dfs_params s\n  lasso s = None \\<longrightarrow>\n  (\\<forall>x.\n      accpt x \\<and> x \\<in> dom (finished s) \\<longrightarrow>\n      (x, x) \\<notin> E\\<^sup>+)\n  cond s\n  \\<not> is_break blue_dfs_params s\n  stack s \\<noteq> []\n  u = hd (stack s)\n  pending s `` {u} = {}\n  s' = finish u s\n  \\<lbrakk>\\<And>v.\n              (hd (stack s), v)\n              \\<in> (rel_restrict E (red s))\\<^sup>+ \\<Longrightarrow>\n              v \\<notin> set (stack s);\n   accpt u; lasso s = None\\<rbrakk>\n  \\<Longrightarrow> \\<forall>x.\n                       accpt x \\<and>\n                       x \\<in> dom (finished\n                                     (lasso_update Map.empty s'\n\\<lparr>red := ?R'10\\<rparr>)) \\<longrightarrow>\n                       (x, x) \\<notin> E\\<^sup>+\n\ngoal (1 subgoal):\n 1. red_dfs (red s) (\\<lambda>x. x \\<in> set (stack s)) (hd (stack s))\n    \\<le> SPEC\n           (\\<lambda>x.\n               \\<forall>R.\n                  x = Inl R \\<longrightarrow>\n                  DFS_invar G blue_dfs_params\n                   (lasso_update Map.empty s'\n                    \\<lparr>red := R\\<rparr>) \\<longrightarrow>\n                  (\\<forall>x.\n                      accpt x \\<and>\n                      x \\<in> dom (finished s') \\<longrightarrow>\n                      (x, x) \\<notin> E\\<^sup>+))", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>DFS_invar G blue_dfs_params s;\n     lasso s = None \\<longrightarrow>\n     (\\<forall>x.\n         accpt x \\<and> x \\<in> dom (finished s) \\<longrightarrow>\n         (x, x) \\<notin> E\\<^sup>+);\n     cond s; \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n     u = hd (stack s); pending s `` {u} = {}; s' = finish u s;\n     \\<And>R'.\n        \\<lbrakk>\\<And>v.\n                    (hd (stack s), v)\n                    \\<in> (rel_restrict E (red s))\\<^sup>+ \\<Longrightarrow>\n                    v \\<notin> set (stack s);\n         accpt u; lasso s = None\\<rbrakk>\n        \\<Longrightarrow> \\<forall>x.\n                             accpt x \\<and>\n                             x \\<in> dom\n(finished\n  (lasso_update Map.empty s'\\<lparr>red := R'\\<rparr>)) \\<longrightarrow>\n                             (x, x) \\<notin> E\\<^sup>+\\<rbrakk>\n    \\<Longrightarrow> red_dfs (red s) (\\<lambda>x. x \\<in> set (stack s))\n                       (hd (stack s))\n                      \\<le> SPEC\n                             (\\<lambda>x.\n                                 \\<forall>R.\n                                    x = Inl R \\<longrightarrow>\n                                    DFS_invar G blue_dfs_params\n                                     (lasso_update Map.empty s'\n\\<lparr>red := R\\<rparr>) \\<longrightarrow>\n                                    (\\<forall>x.\n  accpt x \\<and> x \\<in> dom (finished s') \\<longrightarrow>\n  (x, x) \\<notin> E\\<^sup>+))", "apply (rule find_path1_restr_spec_rule, intro conjI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>DFS_invar G blue_dfs_params s;\n     lasso s = None \\<longrightarrow>\n     (\\<forall>x.\n         accpt x \\<and> x \\<in> dom (finished s) \\<longrightarrow>\n         (x, x) \\<notin> E\\<^sup>+);\n     cond s; \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n     u = hd (stack s); pending s `` {u} = {}; s' = finish u s;\n     \\<And>R'.\n        \\<lbrakk>\\<And>v.\n                    (hd (stack s), v)\n                    \\<in> (rel_restrict E (red s))\\<^sup>+ \\<Longrightarrow>\n                    v \\<notin> set (stack s);\n         accpt u; lasso s = None\\<rbrakk>\n        \\<Longrightarrow> \\<forall>x.\n                             accpt x \\<and>\n                             x \\<in> dom\n(finished\n  (lasso_update Map.empty s'\\<lparr>red := R'\\<rparr>)) \\<longrightarrow>\n                             (x, x) \\<notin> E\\<^sup>+\\<rbrakk>\n    \\<Longrightarrow> fb_graph (G\\<lparr>g_V0 := {hd (stack s)}\\<rparr>)\n 2. \\<lbrakk>DFS_invar G blue_dfs_params s;\n     lasso s = None \\<longrightarrow>\n     (\\<forall>x.\n         accpt x \\<and> x \\<in> dom (finished s) \\<longrightarrow>\n         (x, x) \\<notin> E\\<^sup>+);\n     cond s; \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n     u = hd (stack s); pending s `` {u} = {}; s' = finish u s;\n     \\<And>R'.\n        \\<lbrakk>\\<And>v.\n                    (hd (stack s), v)\n                    \\<in> (rel_restrict E (red s))\\<^sup>+ \\<Longrightarrow>\n                    v \\<notin> set (stack s);\n         accpt u; lasso s = None\\<rbrakk>\n        \\<Longrightarrow> \\<forall>x.\n                             accpt x \\<and>\n                             x \\<in> dom\n(finished\n  (lasso_update Map.empty s'\\<lparr>red := R'\\<rparr>)) \\<longrightarrow>\n                             (x, x) \\<notin> E\\<^sup>+\\<rbrakk>\n    \\<Longrightarrow> restr_invar\n                       (g_E (G\\<lparr>g_V0 := {hd (stack s)}\\<rparr>))\n                       (red s) (\\<lambda>x. x \\<in> set (stack s))\n 3. \\<lbrakk>DFS_invar G blue_dfs_params s;\n     lasso s = None \\<longrightarrow>\n     (\\<forall>x.\n         accpt x \\<and> x \\<in> dom (finished s) \\<longrightarrow>\n         (x, x) \\<notin> E\\<^sup>+);\n     cond s; \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n     u = hd (stack s); pending s `` {u} = {}; s' = finish u s;\n     \\<And>R'.\n        \\<lbrakk>\\<And>v.\n                    (hd (stack s), v)\n                    \\<in> (rel_restrict E (red s))\\<^sup>+ \\<Longrightarrow>\n                    v \\<notin> set (stack s);\n         accpt u; lasso s = None\\<rbrakk>\n        \\<Longrightarrow> \\<forall>x.\n                             accpt x \\<and>\n                             x \\<in> dom\n(finished\n  (lasso_update Map.empty s'\\<lparr>red := R'\\<rparr>)) \\<longrightarrow>\n                             (x, x) \\<notin> E\\<^sup>+;\n     fb_graph (G\\<lparr>g_V0 := {hd (stack s)}\\<rparr>) \\<and>\n     restr_invar (g_E (G\\<lparr>g_V0 := {hd (stack s)}\\<rparr>)) (red s)\n      (\\<lambda>x. x \\<in> set (stack s))\\<rbrakk>\n    \\<Longrightarrow> SPEC\n                       (find_path1_restr_pred\n                         (G\\<lparr>g_V0 := {hd (stack s)}\\<rparr>)\n                         (\\<lambda>x. x \\<in> set (stack s)) (red s))\n                      \\<le> SPEC\n                             (\\<lambda>x.\n                                 \\<forall>R.\n                                    x = Inl R \\<longrightarrow>\n                                    DFS_invar G blue_dfs_params\n                                     (lasso_update Map.empty s'\n\\<lparr>red := R\\<rparr>) \\<longrightarrow>\n                                    (\\<forall>x.\n  accpt x \\<and> x \\<in> dom (finished s') \\<longrightarrow>\n  (x, x) \\<notin> E\\<^sup>+))", "apply (rule red_DFS_precond, simp_all) []"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>DFS_invar G blue_dfs_params s;\n     lasso s = None \\<longrightarrow>\n     (\\<forall>x.\n         accpt x \\<and> x \\<in> dom (finished s) \\<longrightarrow>\n         (x, x) \\<notin> E\\<^sup>+);\n     cond s; \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n     u = hd (stack s); pending s `` {u} = {}; s' = finish u s;\n     \\<And>R'.\n        \\<lbrakk>\\<And>v.\n                    (hd (stack s), v)\n                    \\<in> (rel_restrict E (red s))\\<^sup>+ \\<Longrightarrow>\n                    v \\<notin> set (stack s);\n         accpt u; lasso s = None\\<rbrakk>\n        \\<Longrightarrow> \\<forall>x.\n                             accpt x \\<and>\n                             x \\<in> dom\n(finished\n  (lasso_update Map.empty s'\\<lparr>red := R'\\<rparr>)) \\<longrightarrow>\n                             (x, x) \\<notin> E\\<^sup>+\\<rbrakk>\n    \\<Longrightarrow> restr_invar\n                       (g_E (G\\<lparr>g_V0 := {hd (stack s)}\\<rparr>))\n                       (red s) (\\<lambda>x. x \\<in> set (stack s))\n 2. \\<lbrakk>DFS_invar G blue_dfs_params s;\n     lasso s = None \\<longrightarrow>\n     (\\<forall>x.\n         accpt x \\<and> x \\<in> dom (finished s) \\<longrightarrow>\n         (x, x) \\<notin> E\\<^sup>+);\n     cond s; \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n     u = hd (stack s); pending s `` {u} = {}; s' = finish u s;\n     \\<And>R'.\n        \\<lbrakk>\\<And>v.\n                    (hd (stack s), v)\n                    \\<in> (rel_restrict E (red s))\\<^sup>+ \\<Longrightarrow>\n                    v \\<notin> set (stack s);\n         accpt u; lasso s = None\\<rbrakk>\n        \\<Longrightarrow> \\<forall>x.\n                             accpt x \\<and>\n                             x \\<in> dom\n(finished\n  (lasso_update Map.empty s'\\<lparr>red := R'\\<rparr>)) \\<longrightarrow>\n                             (x, x) \\<notin> E\\<^sup>+;\n     fb_graph (G\\<lparr>g_V0 := {hd (stack s)}\\<rparr>) \\<and>\n     restr_invar (g_E (G\\<lparr>g_V0 := {hd (stack s)}\\<rparr>)) (red s)\n      (\\<lambda>x. x \\<in> set (stack s))\\<rbrakk>\n    \\<Longrightarrow> SPEC\n                       (find_path1_restr_pred\n                         (G\\<lparr>g_V0 := {hd (stack s)}\\<rparr>)\n                         (\\<lambda>x. x \\<in> set (stack s)) (red s))\n                      \\<le> SPEC\n                             (\\<lambda>x.\n                                 \\<forall>R.\n                                    x = Inl R \\<longrightarrow>\n                                    DFS_invar G blue_dfs_params\n                                     (lasso_update Map.empty s'\n\\<lparr>red := R\\<rparr>) \\<longrightarrow>\n                                    (\\<forall>x.\n  accpt x \\<and> x \\<in> dom (finished s') \\<longrightarrow>\n  (x, x) \\<notin> E\\<^sup>+))", "unfolding 1"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>DFS_invar G blue_dfs_params s;\n     lasso s = None \\<longrightarrow>\n     (\\<forall>x.\n         accpt x \\<and> x \\<in> dom (finished s) \\<longrightarrow>\n         (x, x) \\<notin> E\\<^sup>+);\n     cond s; \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n     u = hd (stack s); pending s `` {u} = {}; s' = finish u s;\n     \\<And>R'.\n        \\<lbrakk>\\<And>v.\n                    (hd (stack s), v)\n                    \\<in> (rel_restrict E (red s))\\<^sup>+ \\<Longrightarrow>\n                    v \\<notin> set (stack s);\n         accpt u; lasso s = None\\<rbrakk>\n        \\<Longrightarrow> \\<forall>x.\n                             accpt x \\<and>\n                             x \\<in> dom\n(finished\n  (lasso_update Map.empty s'\\<lparr>red := R'\\<rparr>)) \\<longrightarrow>\n                             (x, x) \\<notin> E\\<^sup>+\\<rbrakk>\n    \\<Longrightarrow> restr_invar E (red s)\n                       (\\<lambda>x. x \\<in> set (stack s))\n 2. \\<lbrakk>DFS_invar G blue_dfs_params s;\n     lasso s = None \\<longrightarrow>\n     (\\<forall>x.\n         accpt x \\<and> x \\<in> dom (finished s) \\<longrightarrow>\n         (x, x) \\<notin> E\\<^sup>+);\n     cond s; \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n     u = hd (stack s); pending s `` {u} = {}; s' = finish u s;\n     \\<And>R'.\n        \\<lbrakk>\\<And>v.\n                    (hd (stack s), v)\n                    \\<in> (rel_restrict E (red s))\\<^sup>+ \\<Longrightarrow>\n                    v \\<notin> set (stack s);\n         accpt u; lasso s = None\\<rbrakk>\n        \\<Longrightarrow> \\<forall>x.\n                             accpt x \\<and>\n                             x \\<in> dom\n(finished\n  (lasso_update Map.empty s'\\<lparr>red := R'\\<rparr>)) \\<longrightarrow>\n                             (x, x) \\<notin> E\\<^sup>+;\n     fb_graph (G\\<lparr>g_V0 := {hd (stack s)}\\<rparr>) \\<and>\n     restr_invar E (red s) (\\<lambda>x. x \\<in> set (stack s))\\<rbrakk>\n    \\<Longrightarrow> SPEC\n                       (find_path1_restr_pred\n                         (G\\<lparr>g_V0 := {hd (stack s)}\\<rparr>)\n                         (\\<lambda>x. x \\<in> set (stack s)) (red s))\n                      \\<le> SPEC\n                             (\\<lambda>x.\n                                 \\<forall>R.\n                                    x = Inl R \\<longrightarrow>\n                                    DFS_invar G blue_dfs_params\n                                     (lasso_update Map.empty s'\n\\<lparr>red := R\\<rparr>) \\<longrightarrow>\n                                    (\\<forall>x.\n  accpt x \\<and> x \\<in> dom (finished s') \\<longrightarrow>\n  (x, x) \\<notin> E\\<^sup>+))", "apply (rule red_DFS_precond, simp_all) []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>DFS_invar G blue_dfs_params s;\n     lasso s = None \\<longrightarrow>\n     (\\<forall>x.\n         accpt x \\<and> x \\<in> dom (finished s) \\<longrightarrow>\n         (x, x) \\<notin> E\\<^sup>+);\n     cond s; \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n     u = hd (stack s); pending s `` {u} = {}; s' = finish u s;\n     \\<And>R'.\n        \\<lbrakk>\\<And>v.\n                    (hd (stack s), v)\n                    \\<in> (rel_restrict E (red s))\\<^sup>+ \\<Longrightarrow>\n                    v \\<notin> set (stack s);\n         accpt u; lasso s = None\\<rbrakk>\n        \\<Longrightarrow> \\<forall>x.\n                             accpt x \\<and>\n                             x \\<in> dom\n(finished\n  (lasso_update Map.empty s'\\<lparr>red := R'\\<rparr>)) \\<longrightarrow>\n                             (x, x) \\<notin> E\\<^sup>+;\n     fb_graph (G\\<lparr>g_V0 := {hd (stack s)}\\<rparr>) \\<and>\n     restr_invar E (red s) (\\<lambda>x. x \\<in> set (stack s))\\<rbrakk>\n    \\<Longrightarrow> SPEC\n                       (find_path1_restr_pred\n                         (G\\<lparr>g_V0 := {hd (stack s)}\\<rparr>)\n                         (\\<lambda>x. x \\<in> set (stack s)) (red s))\n                      \\<le> SPEC\n                             (\\<lambda>x.\n                                 \\<forall>R.\n                                    x = Inl R \\<longrightarrow>\n                                    DFS_invar G blue_dfs_params\n                                     (lasso_update Map.empty s'\n\\<lparr>red := R\\<rparr>) \\<longrightarrow>\n                                    (\\<forall>x.\n  accpt x \\<and> x \\<in> dom (finished s') \\<longrightarrow>\n  (x, x) \\<notin> E\\<^sup>+))", "apply (auto simp: find_path1_restr_pred_def restr_invar_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  red_dfs (red s) (\\<lambda>x. x \\<in> set (stack s)) (hd (stack s))\n  \\<le> SPEC\n         (\\<lambda>x.\n             \\<forall>R.\n                x = Inl R \\<longrightarrow>\n                DFS_invar G blue_dfs_params\n                 (lasso_update Map.empty s'\n                  \\<lparr>red := R\\<rparr>) \\<longrightarrow>\n                (\\<forall>x.\n                    accpt x \\<and>\n                    x \\<in> dom (finished s') \\<longrightarrow>\n                    (x, x) \\<notin> E\\<^sup>+))\n\ngoal (6 subgoals):\n 1. on_init blue_dfs_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         lasso (empty_state x) = None \\<longrightarrow>\n         (\\<forall>xa.\n             accpt xa \\<and>\n             xa \\<in> dom (finished (empty_state x)) \\<longrightarrow>\n             (xa, xa) \\<notin> E\\<^sup>+))\n 2. \\<And>s s' v0.\n       \\<lbrakk>DFS_invar G blue_dfs_params s;\n        lasso s = None \\<longrightarrow>\n        (\\<forall>x.\n            accpt x \\<and> x \\<in> dom (finished s) \\<longrightarrow>\n            (x, x) \\<notin> E\\<^sup>+);\n        cond s; \\<not> is_break blue_dfs_params s; stack s = [];\n        v0 \\<in> V0; v0 \\<notin> dom (discovered s);\n        s' = new_root v0 s\\<rbrakk>\n       \\<Longrightarrow> on_new_root blue_dfs_params v0 s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso (s'\\<lparr>state.more := x\\<rparr>) =\n                              None \\<longrightarrow>\n                              (\\<forall>xa.\n                                  accpt xa \\<and>\n                                  xa \\<in> dom\n      (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                                  (xa, xa) \\<notin> E\\<^sup>+))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G blue_dfs_params s;\n        lasso s = None \\<longrightarrow>\n        (\\<forall>x.\n            accpt x \\<and> x \\<in> dom (finished s) \\<longrightarrow>\n            (x, x) \\<notin> E\\<^sup>+);\n        cond s; \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish blue_dfs_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso (s'\\<lparr>state.more := x\\<rparr>) =\n                              None \\<longrightarrow>\n                              (\\<forall>xa.\n                                  accpt xa \\<and>\n                                  xa \\<in> dom\n      (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                                  (xa, xa) \\<notin> E\\<^sup>+))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s;\n        lasso s = None \\<longrightarrow>\n        (\\<forall>x.\n            accpt x \\<and> x \\<in> dom (finished s) \\<longrightarrow>\n            (x, x) \\<notin> E\\<^sup>+);\n        cond s; \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso (s'\\<lparr>state.more := x\\<rparr>) =\n                              None \\<longrightarrow>\n                              (\\<forall>xa.\n                                  accpt xa \\<and>\n                                  xa \\<in> dom\n      (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                                  (xa, xa) \\<notin> E\\<^sup>+))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s;\n        lasso s = None \\<longrightarrow>\n        (\\<forall>x.\n            accpt x \\<and> x \\<in> dom (finished s) \\<longrightarrow>\n            (x, x) \\<notin> E\\<^sup>+);\n        cond s; \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso (s'\\<lparr>state.more := x\\<rparr>) =\n                              None \\<longrightarrow>\n                              (\\<forall>xa.\n                                  accpt xa \\<and>\n                                  xa \\<in> dom\n      (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                                  (xa, xa) \\<notin> E\\<^sup>+))\n 6. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s;\n        lasso s = None \\<longrightarrow>\n        (\\<forall>x.\n            accpt x \\<and> x \\<in> dom (finished s) \\<longrightarrow>\n            (x, x) \\<notin> E\\<^sup>+);\n        cond s; \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<notin> dom (discovered s);\n        s' =\n        discover u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso (s'\\<lparr>state.more := x\\<rparr>) =\n                              None \\<longrightarrow>\n                              (\\<forall>xa.\n                                  accpt xa \\<and>\n                                  xa \\<in> dom\n      (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                                  (xa, xa) \\<notin> E\\<^sup>+))", "note aux = leof_trans[OF this[simplified,THEN leof_lift]]"], ["proof (state)\nthis:\n  SPEC\n   (\\<lambda>x.\n       \\<forall>R.\n          x = Inl R \\<longrightarrow>\n          BlueDFS_invar G accpt\n           (lasso_update Map.empty s'\n            \\<lparr>red := R\\<rparr>) \\<longrightarrow>\n          (\\<forall>x.\n              accpt x \\<and> x \\<in> dom (finished s') \\<longrightarrow>\n              (x, x) \\<notin> E\\<^sup>+)) \\<le>\\<^sub>n\n  ?c \\<Longrightarrow>\n  red_dfs (red s) (\\<lambda>x. x = sh \\<or> x \\<in> set st) sh \\<le>\\<^sub>n\n  ?c\n\ngoal (6 subgoals):\n 1. on_init blue_dfs_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         lasso (empty_state x) = None \\<longrightarrow>\n         (\\<forall>xa.\n             accpt xa \\<and>\n             xa \\<in> dom (finished (empty_state x)) \\<longrightarrow>\n             (xa, xa) \\<notin> E\\<^sup>+))\n 2. \\<And>s s' v0.\n       \\<lbrakk>DFS_invar G blue_dfs_params s;\n        lasso s = None \\<longrightarrow>\n        (\\<forall>x.\n            accpt x \\<and> x \\<in> dom (finished s) \\<longrightarrow>\n            (x, x) \\<notin> E\\<^sup>+);\n        cond s; \\<not> is_break blue_dfs_params s; stack s = [];\n        v0 \\<in> V0; v0 \\<notin> dom (discovered s);\n        s' = new_root v0 s\\<rbrakk>\n       \\<Longrightarrow> on_new_root blue_dfs_params v0 s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso (s'\\<lparr>state.more := x\\<rparr>) =\n                              None \\<longrightarrow>\n                              (\\<forall>xa.\n                                  accpt xa \\<and>\n                                  xa \\<in> dom\n      (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                                  (xa, xa) \\<notin> E\\<^sup>+))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G blue_dfs_params s;\n        lasso s = None \\<longrightarrow>\n        (\\<forall>x.\n            accpt x \\<and> x \\<in> dom (finished s) \\<longrightarrow>\n            (x, x) \\<notin> E\\<^sup>+);\n        cond s; \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish blue_dfs_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso (s'\\<lparr>state.more := x\\<rparr>) =\n                              None \\<longrightarrow>\n                              (\\<forall>xa.\n                                  accpt xa \\<and>\n                                  xa \\<in> dom\n      (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                                  (xa, xa) \\<notin> E\\<^sup>+))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s;\n        lasso s = None \\<longrightarrow>\n        (\\<forall>x.\n            accpt x \\<and> x \\<in> dom (finished s) \\<longrightarrow>\n            (x, x) \\<notin> E\\<^sup>+);\n        cond s; \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso (s'\\<lparr>state.more := x\\<rparr>) =\n                              None \\<longrightarrow>\n                              (\\<forall>xa.\n                                  accpt xa \\<and>\n                                  xa \\<in> dom\n      (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                                  (xa, xa) \\<notin> E\\<^sup>+))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s;\n        lasso s = None \\<longrightarrow>\n        (\\<forall>x.\n            accpt x \\<and> x \\<in> dom (finished s) \\<longrightarrow>\n            (x, x) \\<notin> E\\<^sup>+);\n        cond s; \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso (s'\\<lparr>state.more := x\\<rparr>) =\n                              None \\<longrightarrow>\n                              (\\<forall>xa.\n                                  accpt xa \\<and>\n                                  xa \\<in> dom\n      (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                                  (xa, xa) \\<notin> E\\<^sup>+))\n 6. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s;\n        lasso s = None \\<longrightarrow>\n        (\\<forall>x.\n            accpt x \\<and> x \\<in> dom (finished s) \\<longrightarrow>\n            (x, x) \\<notin> E\\<^sup>+);\n        cond s; \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<notin> dom (discovered s);\n        s' =\n        discover u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso (s'\\<lparr>state.more := x\\<rparr>) =\n                              None \\<longrightarrow>\n                              (\\<forall>xa.\n                                  accpt xa \\<and>\n                                  xa \\<in> dom\n      (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                                  (xa, xa) \\<notin> E\\<^sup>+))", "note [refine_vcg del] = find_path1_restr_spec_rule"], ["proof (state)\nthis:\n  \\<lbrakk>fb_graph ?G \\<and> restr_invar (g_E ?G) ?R ?P;\n   fb_graph ?G \\<and> restr_invar (g_E ?G) ?R ?P \\<Longrightarrow>\n   SPEC (find_path1_restr_pred ?G ?P ?R) \\<le> ?m\\<rbrakk>\n  \\<Longrightarrow> find_path1_restr_spec ?G ?P ?R \\<le> ?m\n  (fb_graph ?G \\<and> restr_invar (g_E ?G) ?R ?P \\<Longrightarrow>\n   SPEC (find_path1_restr_pred ?G ?P ?R) \\<le>\\<^sub>n ?m) \\<Longrightarrow>\n  find_path1_restr_spec ?G ?P ?R \\<le>\\<^sub>n ?m\n\ngoal (6 subgoals):\n 1. on_init blue_dfs_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         lasso (empty_state x) = None \\<longrightarrow>\n         (\\<forall>xa.\n             accpt xa \\<and>\n             xa \\<in> dom (finished (empty_state x)) \\<longrightarrow>\n             (xa, xa) \\<notin> E\\<^sup>+))\n 2. \\<And>s s' v0.\n       \\<lbrakk>DFS_invar G blue_dfs_params s;\n        lasso s = None \\<longrightarrow>\n        (\\<forall>x.\n            accpt x \\<and> x \\<in> dom (finished s) \\<longrightarrow>\n            (x, x) \\<notin> E\\<^sup>+);\n        cond s; \\<not> is_break blue_dfs_params s; stack s = [];\n        v0 \\<in> V0; v0 \\<notin> dom (discovered s);\n        s' = new_root v0 s\\<rbrakk>\n       \\<Longrightarrow> on_new_root blue_dfs_params v0 s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso (s'\\<lparr>state.more := x\\<rparr>) =\n                              None \\<longrightarrow>\n                              (\\<forall>xa.\n                                  accpt xa \\<and>\n                                  xa \\<in> dom\n      (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                                  (xa, xa) \\<notin> E\\<^sup>+))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G blue_dfs_params s;\n        lasso s = None \\<longrightarrow>\n        (\\<forall>x.\n            accpt x \\<and> x \\<in> dom (finished s) \\<longrightarrow>\n            (x, x) \\<notin> E\\<^sup>+);\n        cond s; \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish blue_dfs_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso (s'\\<lparr>state.more := x\\<rparr>) =\n                              None \\<longrightarrow>\n                              (\\<forall>xa.\n                                  accpt xa \\<and>\n                                  xa \\<in> dom\n      (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                                  (xa, xa) \\<notin> E\\<^sup>+))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s;\n        lasso s = None \\<longrightarrow>\n        (\\<forall>x.\n            accpt x \\<and> x \\<in> dom (finished s) \\<longrightarrow>\n            (x, x) \\<notin> E\\<^sup>+);\n        cond s; \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso (s'\\<lparr>state.more := x\\<rparr>) =\n                              None \\<longrightarrow>\n                              (\\<forall>xa.\n                                  accpt xa \\<and>\n                                  xa \\<in> dom\n      (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                                  (xa, xa) \\<notin> E\\<^sup>+))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s;\n        lasso s = None \\<longrightarrow>\n        (\\<forall>x.\n            accpt x \\<and> x \\<in> dom (finished s) \\<longrightarrow>\n            (x, x) \\<notin> E\\<^sup>+);\n        cond s; \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso (s'\\<lparr>state.more := x\\<rparr>) =\n                              None \\<longrightarrow>\n                              (\\<forall>xa.\n                                  accpt xa \\<and>\n                                  xa \\<in> dom\n      (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                                  (xa, xa) \\<notin> E\\<^sup>+))\n 6. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s;\n        lasso s = None \\<longrightarrow>\n        (\\<forall>x.\n            accpt x \\<and> x \\<in> dom (finished s) \\<longrightarrow>\n            (x, x) \\<notin> E\\<^sup>+);\n        cond s; \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<notin> dom (discovered s);\n        s' =\n        discover u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso (s'\\<lparr>state.more := x\\<rparr>) =\n                              None \\<longrightarrow>\n                              (\\<forall>xa.\n                                  accpt xa \\<and>\n                                  xa \\<in> dom\n      (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                                  (xa, xa) \\<notin> E\\<^sup>+))", "from finish"], ["proof (chain)\npicking this:\n  DFS_invar G blue_dfs_params s\n  lasso s = None \\<longrightarrow>\n  (\\<forall>x.\n      accpt x \\<and> x \\<in> dom (finished s) \\<longrightarrow>\n      (x, x) \\<notin> E\\<^sup>+)\n  cond s\n  \\<not> is_break blue_dfs_params s\n  stack s \\<noteq> []\n  u = hd (stack s)\n  pending s `` {u} = {}\n  s' = finish u s", "show ?case"], ["proof (prove)\nusing this:\n  DFS_invar G blue_dfs_params s\n  lasso s = None \\<longrightarrow>\n  (\\<forall>x.\n      accpt x \\<and> x \\<in> dom (finished s) \\<longrightarrow>\n      (x, x) \\<notin> E\\<^sup>+)\n  cond s\n  \\<not> is_break blue_dfs_params s\n  stack s \\<noteq> []\n  u = hd (stack s)\n  pending s `` {u} = {}\n  s' = finish u s\n\ngoal (1 subgoal):\n 1. on_finish blue_dfs_params u s' \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         DFS_invar G blue_dfs_params\n          (s'\\<lparr>state.more := x\\<rparr>) \\<longrightarrow>\n         lasso (s'\\<lparr>state.more := x\\<rparr>) = None \\<longrightarrow>\n         (\\<forall>xa.\n             accpt xa \\<and>\n             xa \\<in> dom (finished\n                            (s'\\<lparr>state.more :=\n   x\\<rparr>)) \\<longrightarrow>\n             (xa, xa) \\<notin> E\\<^sup>+))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>BlueDFS_invar G accpt s;\n     \\<forall>x.\n        accpt x \\<and> x \\<in> dom (finished s) \\<longrightarrow>\n        (x, x) \\<notin> E\\<^sup>+;\n     cond s; lasso s = None; u = sh; pending s `` {sh} = {};\n     s' = finish sh s\\<rbrakk>\n    \\<Longrightarrow> (accpt sh \\<longrightarrow>\n                       run_red_dfs sh (finish sh s) \\<le>\\<^sub>n\n                       SPEC\n                        (\\<lambda>x.\n                            BlueDFS_invar G accpt\n                             (finish sh s\n                              \\<lparr>state.more :=\n  x\\<rparr>) \\<longrightarrow>\n                            lasso (s'\\<lparr>state.more := x\\<rparr>) =\n                            None \\<longrightarrow>\n                            (\\<forall>x.\n                                accpt x \\<and>\n                                (x = sh \\<or>\n                                 x \\<in> dom (finished s)) \\<longrightarrow>\n                                (x, x) \\<notin> E\\<^sup>+))) \\<and>\n                      (\\<not> accpt sh \\<longrightarrow>\n                       BlueDFS_invar G accpt\n                        (finish sh s\n                         \\<lparr>state.more :=\n                                   state.more s\\<rparr>) \\<longrightarrow>\n                       (\\<forall>x.\n                           accpt x \\<and>\n                           (x = sh \\<or>\n                            x \\<in> dom (finished s)) \\<longrightarrow>\n                           (x, x) \\<notin> E\\<^sup>+))", "apply (intro conjI impI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>BlueDFS_invar G accpt s;\n     \\<forall>x.\n        accpt x \\<and> x \\<in> dom (finished s) \\<longrightarrow>\n        (x, x) \\<notin> E\\<^sup>+;\n     cond s; lasso s = None; u = sh; pending s `` {sh} = {};\n     s' = finish sh s; accpt sh\\<rbrakk>\n    \\<Longrightarrow> run_red_dfs sh (finish sh s) \\<le>\\<^sub>n\n                      SPEC\n                       (\\<lambda>x.\n                           BlueDFS_invar G accpt\n                            (finish sh s\n                             \\<lparr>state.more :=\n x\\<rparr>) \\<longrightarrow>\n                           lasso (s'\\<lparr>state.more := x\\<rparr>) =\n                           None \\<longrightarrow>\n                           (\\<forall>x.\n                               accpt x \\<and>\n                               (x = sh \\<or>\n                                x \\<in> dom (finished s)) \\<longrightarrow>\n                               (x, x) \\<notin> E\\<^sup>+))\n 2. \\<lbrakk>BlueDFS_invar G accpt s;\n     \\<forall>x.\n        accpt x \\<and> x \\<in> dom (finished s) \\<longrightarrow>\n        (x, x) \\<notin> E\\<^sup>+;\n     cond s; lasso s = None; u = sh; pending s `` {sh} = {};\n     s' = finish sh s; \\<not> accpt sh;\n     BlueDFS_invar G accpt\n      (finish sh s\\<lparr>state.more := state.more s\\<rparr>)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x.\n                         accpt x \\<and>\n                         (x = sh \\<or>\n                          x \\<in> dom (finished s)) \\<longrightarrow>\n                         (x, x) \\<notin> E\\<^sup>+", "unfolding run_red_dfs_def mk_blue_witness_def cyan_def"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>BlueDFS_invar G accpt s;\n     \\<forall>x.\n        accpt x \\<and> x \\<in> dom (finished s) \\<longrightarrow>\n        (x, x) \\<notin> E\\<^sup>+;\n     cond s; lasso s = None; u = sh; pending s `` {sh} = {};\n     s' = finish sh s; accpt sh\\<rbrakk>\n    \\<Longrightarrow> (case lasso (finish sh s) of\n                       None \\<Rightarrow>\n                         red_dfs (red (finish sh s))\n                          (\\<lambda>x.\n                              x = sh \\<or>\n                              x \\<in> set (stack (finish sh s)))\n                          sh \\<bind>\n                         (\\<lambda>redS.\n                             RETURN\n                              (case redS of\n                               Inl R' \\<Rightarrow>\n                                 \\<lparr>lasso = None, red = R'\\<rparr>\n                               | Inr (vs, v) \\<Rightarrow>\n                                   let rs = rev (stack (finish sh s))\n                                   in \\<lparr>lasso =\n          Some (rs, vs @ dropWhileNot v rs),\n   red = red (finish sh s)\\<rparr>))\n                       | Some a \\<Rightarrow>\n                           NOOP (finish sh s)) \\<le>\\<^sub>n\n                      SPEC\n                       (\\<lambda>x.\n                           BlueDFS_invar G accpt\n                            (finish sh s\n                             \\<lparr>state.more :=\n x\\<rparr>) \\<longrightarrow>\n                           lasso (s'\\<lparr>state.more := x\\<rparr>) =\n                           None \\<longrightarrow>\n                           (\\<forall>x.\n                               accpt x \\<and>\n                               (x = sh \\<or>\n                                x \\<in> dom (finished s)) \\<longrightarrow>\n                               (x, x) \\<notin> E\\<^sup>+))\n 2. \\<lbrakk>BlueDFS_invar G accpt s;\n     \\<forall>x.\n        accpt x \\<and> x \\<in> dom (finished s) \\<longrightarrow>\n        (x, x) \\<notin> E\\<^sup>+;\n     cond s; lasso s = None; u = sh; pending s `` {sh} = {};\n     s' = finish sh s; \\<not> accpt sh;\n     BlueDFS_invar G accpt\n      (finish sh s\\<lparr>state.more := state.more s\\<rparr>)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x.\n                         accpt x \\<and>\n                         (x = sh \\<or>\n                          x \\<in> dom (finished s)) \\<longrightarrow>\n                         (x, x) \\<notin> E\\<^sup>+", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>BlueDFS_invar G accpt s;\n     \\<forall>x.\n        accpt x \\<and> x \\<in> dom (finished s) \\<longrightarrow>\n        (x, x) \\<notin> E\\<^sup>+;\n     cond s; lasso s = None; u = sh; pending s `` {sh} = {}; accpt sh;\n     s' = finish sh s\\<rbrakk>\n    \\<Longrightarrow> red_dfs (red s)\n                       (\\<lambda>x. x = sh \\<or> x \\<in> set st) sh \\<bind>\n                      (\\<lambda>redS.\n                          RETURN\n                           (case redS of\n                            Inl R' \\<Rightarrow>\n                              \\<lparr>lasso = None, red = R'\\<rparr>\n                            | Inr (vs, v) \\<Rightarrow>\n                                let rs = rev (stack (finish sh s))\n                                in \\<lparr>lasso =\n       Some (rs, vs @ dropWhileNot v rs),\nred = red (finish sh s)\\<rparr>)) \\<le>\\<^sub>n\n                      SPEC\n                       (\\<lambda>x.\n                           BlueDFS_invar G accpt\n                            (finish sh s\n                             \\<lparr>state.more :=\n x\\<rparr>) \\<longrightarrow>\n                           lasso\n                            (finish sh s\\<lparr>state.more := x\\<rparr>) =\n                           None \\<longrightarrow>\n                           (\\<forall>x.\n                               accpt x \\<and>\n                               (x = sh \\<or>\n                                x \\<in> dom (finished s)) \\<longrightarrow>\n                               (x, x) \\<notin> E\\<^sup>+))\n 2. \\<lbrakk>BlueDFS_invar G accpt s;\n     \\<forall>x.\n        accpt x \\<and> x \\<in> dom (finished s) \\<longrightarrow>\n        (x, x) \\<notin> E\\<^sup>+;\n     cond s; lasso s = None; u = sh; pending s `` {sh} = {};\n     s' = finish sh s; \\<not> accpt sh;\n     BlueDFS_invar G accpt\n      (finish sh s\\<lparr>state.more := state.more s\\<rparr>)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x.\n                         accpt x \\<and>\n                         (x = sh \\<or>\n                          x \\<in> dom (finished s)) \\<longrightarrow>\n                         (x, x) \\<notin> E\\<^sup>+", "apply (refine_vcg aux)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       \\<lbrakk>BlueDFS_invar G accpt s;\n        \\<forall>x.\n           accpt x \\<and> x \\<in> dom (finished s) \\<longrightarrow>\n           (x, x) \\<notin> E\\<^sup>+;\n        cond s; lasso s = None; u = sh; pending s `` {sh} = {}; accpt sh;\n        s' = finish sh s;\n        x \\<in> {x. \\<forall>R.\n                       x = Inl R \\<longrightarrow>\n                       BlueDFS_invar G accpt\n                        (lasso_update Map.empty s'\n                         \\<lparr>red := R\\<rparr>) \\<longrightarrow>\n                       (\\<forall>x.\n                           accpt x \\<and>\n                           x \\<in> dom (finished s') \\<longrightarrow>\n                           (x, x) \\<notin> E\\<^sup>+)};\n        BlueDFS_invar G accpt\n         (finish sh s\n          \\<lparr>state.more :=\n                    case x of\n                    Inl R' \\<Rightarrow>\n                      \\<lparr>lasso = None, red = R'\\<rparr>\n                    | Inr (vs, v) \\<Rightarrow>\n                        let rs = rev (stack (finish sh s))\n                        in \\<lparr>lasso =\n                                     Some (rs, vs @ dropWhileNot v rs),\n                              red = red (finish sh s)\\<rparr>\\<rparr>);\n        lasso\n         (finish sh s\n          \\<lparr>state.more :=\n                    case x of\n                    Inl R' \\<Rightarrow>\n                      \\<lparr>lasso = None, red = R'\\<rparr>\n                    | Inr (vs, v) \\<Rightarrow>\n                        let rs = rev (stack (finish sh s))\n                        in \\<lparr>lasso =\n                                     Some (rs, vs @ dropWhileNot v rs),\n                              red = red (finish sh s)\\<rparr>\\<rparr>) =\n        None;\n        accpt xa \\<and> (xa = sh \\<or> xa \\<in> dom (finished s))\\<rbrakk>\n       \\<Longrightarrow> (xa, xa) \\<notin> E\\<^sup>+\n 2. \\<lbrakk>BlueDFS_invar G accpt s;\n     \\<forall>x.\n        accpt x \\<and> x \\<in> dom (finished s) \\<longrightarrow>\n        (x, x) \\<notin> E\\<^sup>+;\n     cond s; lasso s = None; u = sh; pending s `` {sh} = {};\n     s' = finish sh s; \\<not> accpt sh;\n     BlueDFS_invar G accpt\n      (finish sh s\\<lparr>state.more := state.more s\\<rparr>)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x.\n                         accpt x \\<and>\n                         (x = sh \\<or>\n                          x \\<in> dom (finished s)) \\<longrightarrow>\n                         (x, x) \\<notin> E\\<^sup>+", "apply (auto split: sum.splits)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  on_finish blue_dfs_params u s' \\<le>\\<^sub>n\n  SPEC\n   (\\<lambda>x.\n       DFS_invar G blue_dfs_params\n        (s'\\<lparr>state.more := x\\<rparr>) \\<longrightarrow>\n       lasso (s'\\<lparr>state.more := x\\<rparr>) = None \\<longrightarrow>\n       (\\<forall>xa.\n           accpt xa \\<and>\n           xa \\<in> dom (finished\n                          (s'\\<lparr>state.more :=\n x\\<rparr>)) \\<longrightarrow>\n           (xa, xa) \\<notin> E\\<^sup>+))\n\ngoal (5 subgoals):\n 1. on_init blue_dfs_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         lasso (empty_state x) = None \\<longrightarrow>\n         (\\<forall>xa.\n             accpt xa \\<and>\n             xa \\<in> dom (finished (empty_state x)) \\<longrightarrow>\n             (xa, xa) \\<notin> E\\<^sup>+))\n 2. \\<And>s s' v0.\n       \\<lbrakk>DFS_invar G blue_dfs_params s;\n        lasso s = None \\<longrightarrow>\n        (\\<forall>x.\n            accpt x \\<and> x \\<in> dom (finished s) \\<longrightarrow>\n            (x, x) \\<notin> E\\<^sup>+);\n        cond s; \\<not> is_break blue_dfs_params s; stack s = [];\n        v0 \\<in> V0; v0 \\<notin> dom (discovered s);\n        s' = new_root v0 s\\<rbrakk>\n       \\<Longrightarrow> on_new_root blue_dfs_params v0 s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso (s'\\<lparr>state.more := x\\<rparr>) =\n                              None \\<longrightarrow>\n                              (\\<forall>xa.\n                                  accpt xa \\<and>\n                                  xa \\<in> dom\n      (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                                  (xa, xa) \\<notin> E\\<^sup>+))\n 3. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s;\n        lasso s = None \\<longrightarrow>\n        (\\<forall>x.\n            accpt x \\<and> x \\<in> dom (finished s) \\<longrightarrow>\n            (x, x) \\<notin> E\\<^sup>+);\n        cond s; \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso (s'\\<lparr>state.more := x\\<rparr>) =\n                              None \\<longrightarrow>\n                              (\\<forall>xa.\n                                  accpt xa \\<and>\n                                  xa \\<in> dom\n      (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                                  (xa, xa) \\<notin> E\\<^sup>+))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s;\n        lasso s = None \\<longrightarrow>\n        (\\<forall>x.\n            accpt x \\<and> x \\<in> dom (finished s) \\<longrightarrow>\n            (x, x) \\<notin> E\\<^sup>+);\n        cond s; \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso (s'\\<lparr>state.more := x\\<rparr>) =\n                              None \\<longrightarrow>\n                              (\\<forall>xa.\n                                  accpt xa \\<and>\n                                  xa \\<in> dom\n      (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                                  (xa, xa) \\<notin> E\\<^sup>+))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s;\n        lasso s = None \\<longrightarrow>\n        (\\<forall>x.\n            accpt x \\<and> x \\<in> dom (finished s) \\<longrightarrow>\n            (x, x) \\<notin> E\\<^sup>+);\n        cond s; \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<notin> dom (discovered s);\n        s' =\n        discover u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso (s'\\<lparr>state.more := x\\<rparr>) =\n                              None \\<longrightarrow>\n                              (\\<forall>xa.\n                                  accpt xa \\<and>\n                                  xa \\<in> dom\n      (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                                  (xa, xa) \\<notin> E\\<^sup>+))", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. on_init blue_dfs_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         lasso (empty_state x) = None \\<longrightarrow>\n         (\\<forall>xa.\n             accpt xa \\<and>\n             xa \\<in> dom (finished (empty_state x)) \\<longrightarrow>\n             (xa, xa) \\<notin> E\\<^sup>+))\n 2. \\<And>s s' v0.\n       \\<lbrakk>DFS_invar G blue_dfs_params s;\n        lasso s = None \\<longrightarrow>\n        (\\<forall>x.\n            accpt x \\<and> x \\<in> dom (finished s) \\<longrightarrow>\n            (x, x) \\<notin> E\\<^sup>+);\n        cond s; \\<not> is_break blue_dfs_params s; stack s = [];\n        v0 \\<in> V0; v0 \\<notin> dom (discovered s);\n        s' = new_root v0 s\\<rbrakk>\n       \\<Longrightarrow> on_new_root blue_dfs_params v0 s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso (s'\\<lparr>state.more := x\\<rparr>) =\n                              None \\<longrightarrow>\n                              (\\<forall>xa.\n                                  accpt xa \\<and>\n                                  xa \\<in> dom\n      (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                                  (xa, xa) \\<notin> E\\<^sup>+))\n 3. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s;\n        lasso s = None \\<longrightarrow>\n        (\\<forall>x.\n            accpt x \\<and> x \\<in> dom (finished s) \\<longrightarrow>\n            (x, x) \\<notin> E\\<^sup>+);\n        cond s; \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso (s'\\<lparr>state.more := x\\<rparr>) =\n                              None \\<longrightarrow>\n                              (\\<forall>xa.\n                                  accpt xa \\<and>\n                                  xa \\<in> dom\n      (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                                  (xa, xa) \\<notin> E\\<^sup>+))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s;\n        lasso s = None \\<longrightarrow>\n        (\\<forall>x.\n            accpt x \\<and> x \\<in> dom (finished s) \\<longrightarrow>\n            (x, x) \\<notin> E\\<^sup>+);\n        cond s; \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso (s'\\<lparr>state.more := x\\<rparr>) =\n                              None \\<longrightarrow>\n                              (\\<forall>xa.\n                                  accpt xa \\<and>\n                                  xa \\<in> dom\n      (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                                  (xa, xa) \\<notin> E\\<^sup>+))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s;\n        lasso s = None \\<longrightarrow>\n        (\\<forall>x.\n            accpt x \\<and> x \\<in> dom (finished s) \\<longrightarrow>\n            (x, x) \\<notin> E\\<^sup>+);\n        cond s; \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<notin> dom (discovered s);\n        s' =\n        discover u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso (s'\\<lparr>state.more := x\\<rparr>) =\n                              None \\<longrightarrow>\n                              (\\<forall>xa.\n                                  accpt xa \\<and>\n                                  xa \\<in> dom\n      (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                                  (xa, xa) \\<notin> E\\<^sup>+))", "case back_edge"], ["proof (state)\nthis:\n  DFS_invar G blue_dfs_params s_\n  lasso s_ = None \\<longrightarrow>\n  (\\<forall>x.\n      accpt x \\<and> x \\<in> dom (finished s_) \\<longrightarrow>\n      (x, x) \\<notin> E\\<^sup>+)\n  cond s_\n  \\<not> is_break blue_dfs_params s_\n  stack s_ \\<noteq> []\n  (u_, v_) \\<in> pending s_\n  u_ = hd (stack s_)\n  v_ \\<in> dom (discovered s_)\n  v_ \\<notin> dom (finished s_)\n  s'_ =\n  back_edge u_ v_ (s_\\<lparr>pending := pending s_ - {(u_, v_)}\\<rparr>)\n\ngoal (5 subgoals):\n 1. on_init blue_dfs_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         lasso (empty_state x) = None \\<longrightarrow>\n         (\\<forall>xa.\n             accpt xa \\<and>\n             xa \\<in> dom (finished (empty_state x)) \\<longrightarrow>\n             (xa, xa) \\<notin> E\\<^sup>+))\n 2. \\<And>s s' v0.\n       \\<lbrakk>DFS_invar G blue_dfs_params s;\n        lasso s = None \\<longrightarrow>\n        (\\<forall>x.\n            accpt x \\<and> x \\<in> dom (finished s) \\<longrightarrow>\n            (x, x) \\<notin> E\\<^sup>+);\n        cond s; \\<not> is_break blue_dfs_params s; stack s = [];\n        v0 \\<in> V0; v0 \\<notin> dom (discovered s);\n        s' = new_root v0 s\\<rbrakk>\n       \\<Longrightarrow> on_new_root blue_dfs_params v0 s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso (s'\\<lparr>state.more := x\\<rparr>) =\n                              None \\<longrightarrow>\n                              (\\<forall>xa.\n                                  accpt xa \\<and>\n                                  xa \\<in> dom\n      (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                                  (xa, xa) \\<notin> E\\<^sup>+))\n 3. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s;\n        lasso s = None \\<longrightarrow>\n        (\\<forall>x.\n            accpt x \\<and> x \\<in> dom (finished s) \\<longrightarrow>\n            (x, x) \\<notin> E\\<^sup>+);\n        cond s; \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso (s'\\<lparr>state.more := x\\<rparr>) =\n                              None \\<longrightarrow>\n                              (\\<forall>xa.\n                                  accpt xa \\<and>\n                                  xa \\<in> dom\n      (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                                  (xa, xa) \\<notin> E\\<^sup>+))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s;\n        lasso s = None \\<longrightarrow>\n        (\\<forall>x.\n            accpt x \\<and> x \\<in> dom (finished s) \\<longrightarrow>\n            (x, x) \\<notin> E\\<^sup>+);\n        cond s; \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso (s'\\<lparr>state.more := x\\<rparr>) =\n                              None \\<longrightarrow>\n                              (\\<forall>xa.\n                                  accpt xa \\<and>\n                                  xa \\<in> dom\n      (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                                  (xa, xa) \\<notin> E\\<^sup>+))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s;\n        lasso s = None \\<longrightarrow>\n        (\\<forall>x.\n            accpt x \\<and> x \\<in> dom (finished s) \\<longrightarrow>\n            (x, x) \\<notin> E\\<^sup>+);\n        cond s; \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<notin> dom (discovered s);\n        s' =\n        discover u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso (s'\\<lparr>state.more := x\\<rparr>) =\n                              None \\<longrightarrow>\n                              (\\<forall>xa.\n                                  accpt xa \\<and>\n                                  xa \\<in> dom\n      (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                                  (xa, xa) \\<notin> E\\<^sup>+))", "thus ?case"], ["proof (prove)\nusing this:\n  DFS_invar G blue_dfs_params s_\n  lasso s_ = None \\<longrightarrow>\n  (\\<forall>x.\n      accpt x \\<and> x \\<in> dom (finished s_) \\<longrightarrow>\n      (x, x) \\<notin> E\\<^sup>+)\n  cond s_\n  \\<not> is_break blue_dfs_params s_\n  stack s_ \\<noteq> []\n  (u_, v_) \\<in> pending s_\n  u_ = hd (stack s_)\n  v_ \\<in> dom (discovered s_)\n  v_ \\<notin> dom (finished s_)\n  s'_ =\n  back_edge u_ v_ (s_\\<lparr>pending := pending s_ - {(u_, v_)}\\<rparr>)\n\ngoal (1 subgoal):\n 1. on_back_edge blue_dfs_params u_ v_ s'_ \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         DFS_invar G blue_dfs_params\n          (s'_\\<lparr>state.more := x\\<rparr>) \\<longrightarrow>\n         lasso (s'_\\<lparr>state.more := x\\<rparr>) = None \\<longrightarrow>\n         (\\<forall>xa.\n             accpt xa \\<and>\n             xa \\<in> dom (finished\n                            (s'_\\<lparr>state.more :=\n    x\\<rparr>)) \\<longrightarrow>\n             (xa, xa) \\<notin> E\\<^sup>+))", "by (simp add: se_back_edge_def split: option.split)"], ["proof (state)\nthis:\n  on_back_edge blue_dfs_params u_ v_ s'_ \\<le>\\<^sub>n\n  SPEC\n   (\\<lambda>x.\n       DFS_invar G blue_dfs_params\n        (s'_\\<lparr>state.more := x\\<rparr>) \\<longrightarrow>\n       lasso (s'_\\<lparr>state.more := x\\<rparr>) = None \\<longrightarrow>\n       (\\<forall>xa.\n           accpt xa \\<and>\n           xa \\<in> dom (finished\n                          (s'_\\<lparr>state.more :=\n  x\\<rparr>)) \\<longrightarrow>\n           (xa, xa) \\<notin> E\\<^sup>+))\n\ngoal (4 subgoals):\n 1. on_init blue_dfs_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         lasso (empty_state x) = None \\<longrightarrow>\n         (\\<forall>xa.\n             accpt xa \\<and>\n             xa \\<in> dom (finished (empty_state x)) \\<longrightarrow>\n             (xa, xa) \\<notin> E\\<^sup>+))\n 2. \\<And>s s' v0.\n       \\<lbrakk>DFS_invar G blue_dfs_params s;\n        lasso s = None \\<longrightarrow>\n        (\\<forall>x.\n            accpt x \\<and> x \\<in> dom (finished s) \\<longrightarrow>\n            (x, x) \\<notin> E\\<^sup>+);\n        cond s; \\<not> is_break blue_dfs_params s; stack s = [];\n        v0 \\<in> V0; v0 \\<notin> dom (discovered s);\n        s' = new_root v0 s\\<rbrakk>\n       \\<Longrightarrow> on_new_root blue_dfs_params v0 s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso (s'\\<lparr>state.more := x\\<rparr>) =\n                              None \\<longrightarrow>\n                              (\\<forall>xa.\n                                  accpt xa \\<and>\n                                  xa \\<in> dom\n      (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                                  (xa, xa) \\<notin> E\\<^sup>+))\n 3. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s;\n        lasso s = None \\<longrightarrow>\n        (\\<forall>x.\n            accpt x \\<and> x \\<in> dom (finished s) \\<longrightarrow>\n            (x, x) \\<notin> E\\<^sup>+);\n        cond s; \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso (s'\\<lparr>state.more := x\\<rparr>) =\n                              None \\<longrightarrow>\n                              (\\<forall>xa.\n                                  accpt xa \\<and>\n                                  xa \\<in> dom\n      (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                                  (xa, xa) \\<notin> E\\<^sup>+))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s;\n        lasso s = None \\<longrightarrow>\n        (\\<forall>x.\n            accpt x \\<and> x \\<in> dom (finished s) \\<longrightarrow>\n            (x, x) \\<notin> E\\<^sup>+);\n        cond s; \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<notin> dom (discovered s);\n        s' =\n        discover u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso (s'\\<lparr>state.more := x\\<rparr>) =\n                              None \\<longrightarrow>\n                              (\\<forall>xa.\n                                  accpt xa \\<and>\n                                  xa \\<in> dom\n      (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                                  (xa, xa) \\<notin> E\\<^sup>+))", "qed simp_all"], ["", "lemma no_accpt_cycle_in_finish:\n    \"\\<lbrakk>lasso s = None; accpt v; v \\<in> dom (finished s)\\<rbrakk> \\<Longrightarrow> (v,v) \\<notin> E\\<^sup>+\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>lasso s = None; accpt v; v \\<in> dom (finished s)\\<rbrakk>\n    \\<Longrightarrow> (v, v) \\<notin> E\\<^sup>+", "using i_no_accpt_cyle_in_finish[THEN make_invar_thm]"], ["proof (prove)\nusing this:\n  lasso s = None \\<longrightarrow>\n  (\\<forall>x.\n      accpt x \\<and> x \\<in> dom (finished s) \\<longrightarrow>\n      (x, x) \\<notin> E\\<^sup>+)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>lasso s = None; accpt v; v \\<in> dom (finished s)\\<rbrakk>\n    \\<Longrightarrow> (v, v) \\<notin> E\\<^sup>+", "by blast"], ["", "end"], ["", "context BlueDFS\nbegin"], ["", "definition lasso_inv where\n    \"lasso_inv s \\<equiv> \\<forall>pr pl. lasso s = Some (pr,pl) \\<longrightarrow> \n                                      pl \\<noteq> []\n                                    \\<and> (\\<exists>v0\\<in>V0. path E v0 pr (hd pl)) \n                                    \\<and> accpt (hd pl) \n                                    \\<and> path E (hd pl) pl (hd pl)\""], ["", "lemma (in BlueDFS_invar) se_back_edge_lasso_inv:\n    assumes b_inv: \"lasso_inv s\"\n    and ne: \"stack s \\<noteq> []\"\n    and R: \"lasso s = None\"\n    and p:\"(hd (stack s), v) \\<in> pending s\"\n    and v: \"v \\<in> dom (discovered s)\" \"v \\<notin> dom (finished s)\"\n    and s': \"s' = back_edge (hd (stack s)) v (s\\<lparr>pending := pending s - {(u,v)}\\<rparr>)\"\n    shows \"se_back_edge (hd (stack s)) v s'\n                \\<le> SPEC (\\<lambda>e. DFS_invar G blue_dfs_params (s'\\<lparr>state.more := e\\<rparr>) \\<longrightarrow>\n                            lasso_inv (s'\\<lparr>state.more := e\\<rparr>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. se_back_edge (hd (stack s)) v s'\n    \\<le> SPEC\n           (\\<lambda>e.\n               DFS_invar G blue_dfs_params\n                (s'\\<lparr>state.more := e\\<rparr>) \\<longrightarrow>\n               lasso_inv (s'\\<lparr>state.more := e\\<rparr>))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. se_back_edge (hd (stack s)) v s'\n    \\<le> SPEC\n           (\\<lambda>e.\n               DFS_invar G blue_dfs_params\n                (s'\\<lparr>state.more := e\\<rparr>) \\<longrightarrow>\n               lasso_inv (s'\\<lparr>state.more := e\\<rparr>))", "from v stack_set_def"], ["proof (chain)\npicking this:\n  v \\<in> dom (discovered s)\n  v \\<notin> dom (finished s)\n  set (stack s) = dom (discovered s) - dom (finished s)", "have v_in: \"v \\<in> set (stack s)\""], ["proof (prove)\nusing this:\n  v \\<in> dom (discovered s)\n  v \\<notin> dom (finished s)\n  set (stack s) = dom (discovered s) - dom (finished s)\n\ngoal (1 subgoal):\n 1. v \\<in> set (stack s)", "by simp"], ["proof (state)\nthis:\n  v \\<in> set (stack s)\n\ngoal (1 subgoal):\n 1. se_back_edge (hd (stack s)) v s'\n    \\<le> SPEC\n           (\\<lambda>e.\n               DFS_invar G blue_dfs_params\n                (s'\\<lparr>state.more := e\\<rparr>) \\<longrightarrow>\n               lasso_inv (s'\\<lparr>state.more := e\\<rparr>))", "from p"], ["proof (chain)\npicking this:\n  (hd (stack s), v) \\<in> pending s", "have uv_edg: \"(hd (stack s), v) \\<in> E\""], ["proof (prove)\nusing this:\n  (hd (stack s), v) \\<in> pending s\n\ngoal (1 subgoal):\n 1. (hd (stack s), v) \\<in> E", "by (auto dest: pendingD)"], ["proof (state)\nthis:\n  (hd (stack s), v) \\<in> E\n\ngoal (1 subgoal):\n 1. se_back_edge (hd (stack s)) v s'\n    \\<le> SPEC\n           (\\<lambda>e.\n               DFS_invar G blue_dfs_params\n                (s'\\<lparr>state.more := e\\<rparr>) \\<longrightarrow>\n               lasso_inv (s'\\<lparr>state.more := e\\<rparr>))", "{"], ["proof (state)\nthis:\n  (hd (stack s), v) \\<in> E\n\ngoal (1 subgoal):\n 1. se_back_edge (hd (stack s)) v s'\n    \\<le> SPEC\n           (\\<lambda>e.\n               DFS_invar G blue_dfs_params\n                (s'\\<lparr>state.more := e\\<rparr>) \\<longrightarrow>\n               lasso_inv (s'\\<lparr>state.more := e\\<rparr>))", "assume accpt: \"accpt (hd (stack s))\""], ["proof (state)\nthis:\n  accpt (hd (stack s))\n\ngoal (1 subgoal):\n 1. se_back_edge (hd (stack s)) v s'\n    \\<le> SPEC\n           (\\<lambda>e.\n               DFS_invar G blue_dfs_params\n                (s'\\<lparr>state.more := e\\<rparr>) \\<longrightarrow>\n               lasso_inv (s'\\<lparr>state.more := e\\<rparr>))", "let ?ur = \"rev (tl (stack s))\""], ["proof (state)\ngoal (1 subgoal):\n 1. se_back_edge (hd (stack s)) v s'\n    \\<le> SPEC\n           (\\<lambda>e.\n               DFS_invar G blue_dfs_params\n                (s'\\<lparr>state.more := e\\<rparr>) \\<longrightarrow>\n               lasso_inv (s'\\<lparr>state.more := e\\<rparr>))", "let ?ul = \"hd (stack s)#dropWhileNot v (rev (tl (stack s)))\""], ["proof (state)\ngoal (1 subgoal):\n 1. se_back_edge (hd (stack s)) v s'\n    \\<le> SPEC\n           (\\<lambda>e.\n               DFS_invar G blue_dfs_params\n                (s'\\<lparr>state.more := e\\<rparr>) \\<longrightarrow>\n               lasso_inv (s'\\<lparr>state.more := e\\<rparr>))", "let ?s = \"s'\\<lparr>lasso := Some (?ur, ?ul), red := red s\\<rparr>\""], ["proof (state)\ngoal (1 subgoal):\n 1. se_back_edge (hd (stack s)) v s'\n    \\<le> SPEC\n           (\\<lambda>e.\n               DFS_invar G blue_dfs_params\n                (s'\\<lparr>state.more := e\\<rparr>) \\<longrightarrow>\n               lasso_inv (s'\\<lparr>state.more := e\\<rparr>))", "assume \"DFS_invar G blue_dfs_params ?s\""], ["proof (state)\nthis:\n  DFS_invar G blue_dfs_params\n   (s'\\<lparr>lasso :=\n                Some\n                 (rev (tl (stack s)),\n                  hd (stack s) # dropWhileNot v (rev (tl (stack s)))),\n         red := red s\\<rparr>)\n\ngoal (1 subgoal):\n 1. se_back_edge (hd (stack s)) v s'\n    \\<le> SPEC\n           (\\<lambda>e.\n               DFS_invar G blue_dfs_params\n                (s'\\<lparr>state.more := e\\<rparr>) \\<longrightarrow>\n               lasso_inv (s'\\<lparr>state.more := e\\<rparr>))", "have [simp]: \"stack ?s = stack s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stack\n     (s'\\<lparr>lasso :=\n                  Some\n                   (rev (tl (stack s)),\n                    hd (stack s) # dropWhileNot v (rev (tl (stack s)))),\n           red := red s\\<rparr>) =\n    stack s", "by (simp add: s')"], ["proof (state)\nthis:\n  stack\n   (s'\\<lparr>lasso :=\n                Some\n                 (rev (tl (stack s)),\n                  hd (stack s) # dropWhileNot v (rev (tl (stack s)))),\n         red := red s\\<rparr>) =\n  stack s\n\ngoal (1 subgoal):\n 1. se_back_edge (hd (stack s)) v s'\n    \\<le> SPEC\n           (\\<lambda>e.\n               DFS_invar G blue_dfs_params\n                (s'\\<lparr>state.more := e\\<rparr>) \\<longrightarrow>\n               lasso_inv (s'\\<lparr>state.more := e\\<rparr>))", "have hd_ul[simp]: \"hd ?ul = hd (stack s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hd (hd (stack s) # dropWhileNot v (rev (tl (stack s)))) = hd (stack s)", "by simp"], ["proof (state)\nthis:\n  hd (hd (stack s) # dropWhileNot v (rev (tl (stack s)))) = hd (stack s)\n\ngoal (1 subgoal):\n 1. se_back_edge (hd (stack s)) v s'\n    \\<le> SPEC\n           (\\<lambda>e.\n               DFS_invar G blue_dfs_params\n                (s'\\<lparr>state.more := e\\<rparr>) \\<longrightarrow>\n               lasso_inv (s'\\<lparr>state.more := e\\<rparr>))", "have \"?ul \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hd (stack s) # dropWhileNot v (rev (tl (stack s))) \\<noteq> []", "by simp"], ["proof (state)\nthis:\n  hd (stack s) # dropWhileNot v (rev (tl (stack s))) \\<noteq> []\n\ngoal (1 subgoal):\n 1. se_back_edge (hd (stack s)) v s'\n    \\<le> SPEC\n           (\\<lambda>e.\n               DFS_invar G blue_dfs_params\n                (s'\\<lparr>state.more := e\\<rparr>) \\<longrightarrow>\n               lasso_inv (s'\\<lparr>state.more := e\\<rparr>))", "moreover"], ["proof (state)\nthis:\n  hd (stack s) # dropWhileNot v (rev (tl (stack s))) \\<noteq> []\n\ngoal (1 subgoal):\n 1. se_back_edge (hd (stack s)) v s'\n    \\<le> SPEC\n           (\\<lambda>e.\n               DFS_invar G blue_dfs_params\n                (s'\\<lparr>state.more := e\\<rparr>) \\<longrightarrow>\n               lasso_inv (s'\\<lparr>state.more := e\\<rparr>))", "have P:\"\\<exists>v0\\<in>V0. path E v0 ?ur (hd ?ul)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>v0\\<in>V0.\n       path E v0 (rev (tl (stack s)))\n        (hd (hd (stack s) # dropWhileNot v (rev (tl (stack s)))))", "using stack_is_path[OF ne]"], ["proof (prove)\nusing this:\n  \\<exists>v0\\<in>V0. path E v0 (rev (tl (stack s))) (hd (stack s))\n\ngoal (1 subgoal):\n 1. \\<exists>v0\\<in>V0.\n       path E v0 (rev (tl (stack s)))\n        (hd (hd (stack s) # dropWhileNot v (rev (tl (stack s)))))", "by auto"], ["proof (state)\nthis:\n  \\<exists>v0\\<in>V0.\n     path E v0 (rev (tl (stack s)))\n      (hd (hd (stack s) # dropWhileNot v (rev (tl (stack s)))))\n\ngoal (1 subgoal):\n 1. se_back_edge (hd (stack s)) v s'\n    \\<le> SPEC\n           (\\<lambda>e.\n               DFS_invar G blue_dfs_params\n                (s'\\<lparr>state.more := e\\<rparr>) \\<longrightarrow>\n               lasso_inv (s'\\<lparr>state.more := e\\<rparr>))", "moreover"], ["proof (state)\nthis:\n  \\<exists>v0\\<in>V0.\n     path E v0 (rev (tl (stack s)))\n      (hd (hd (stack s) # dropWhileNot v (rev (tl (stack s)))))\n\ngoal (1 subgoal):\n 1. se_back_edge (hd (stack s)) v s'\n    \\<le> SPEC\n           (\\<lambda>e.\n               DFS_invar G blue_dfs_params\n                (s'\\<lparr>state.more := e\\<rparr>) \\<longrightarrow>\n               lasso_inv (s'\\<lparr>state.more := e\\<rparr>))", "from accpt"], ["proof (chain)\npicking this:\n  accpt (hd (stack s))", "have \"accpt (hd ?ul)\""], ["proof (prove)\nusing this:\n  accpt (hd (stack s))\n\ngoal (1 subgoal):\n 1. accpt (hd (hd (stack s) # dropWhileNot v (rev (tl (stack s)))))", "by simp"], ["proof (state)\nthis:\n  accpt (hd (hd (stack s) # dropWhileNot v (rev (tl (stack s)))))\n\ngoal (1 subgoal):\n 1. se_back_edge (hd (stack s)) v s'\n    \\<le> SPEC\n           (\\<lambda>e.\n               DFS_invar G blue_dfs_params\n                (s'\\<lparr>state.more := e\\<rparr>) \\<longrightarrow>\n               lasso_inv (s'\\<lparr>state.more := e\\<rparr>))", "moreover"], ["proof (state)\nthis:\n  accpt (hd (hd (stack s) # dropWhileNot v (rev (tl (stack s)))))\n\ngoal (1 subgoal):\n 1. se_back_edge (hd (stack s)) v s'\n    \\<le> SPEC\n           (\\<lambda>e.\n               DFS_invar G blue_dfs_params\n                (s'\\<lparr>state.more := e\\<rparr>) \\<longrightarrow>\n               lasso_inv (s'\\<lparr>state.more := e\\<rparr>))", "have \"path E (hd ?ul) ?ul (hd ?ul)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path E (hd (hd (stack s) # dropWhileNot v (rev (tl (stack s)))))\n     (hd (stack s) # dropWhileNot v (rev (tl (stack s))))\n     (hd (hd (stack s) # dropWhileNot v (rev (tl (stack s)))))", "proof (cases \"v = hd (stack s)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. v = hd (stack s) \\<Longrightarrow>\n    path E (hd (hd (stack s) # dropWhileNot v (rev (tl (stack s)))))\n     (hd (stack s) # dropWhileNot v (rev (tl (stack s))))\n     (hd (hd (stack s) # dropWhileNot v (rev (tl (stack s)))))\n 2. v \\<noteq> hd (stack s) \\<Longrightarrow>\n    path E (hd (hd (stack s) # dropWhileNot v (rev (tl (stack s)))))\n     (hd (stack s) # dropWhileNot v (rev (tl (stack s))))\n     (hd (hd (stack s) # dropWhileNot v (rev (tl (stack s)))))", "case True"], ["proof (state)\nthis:\n  v = hd (stack s)\n\ngoal (2 subgoals):\n 1. v = hd (stack s) \\<Longrightarrow>\n    path E (hd (hd (stack s) # dropWhileNot v (rev (tl (stack s)))))\n     (hd (stack s) # dropWhileNot v (rev (tl (stack s))))\n     (hd (hd (stack s) # dropWhileNot v (rev (tl (stack s)))))\n 2. v \\<noteq> hd (stack s) \\<Longrightarrow>\n    path E (hd (hd (stack s) # dropWhileNot v (rev (tl (stack s)))))\n     (hd (stack s) # dropWhileNot v (rev (tl (stack s))))\n     (hd (hd (stack s) # dropWhileNot v (rev (tl (stack s)))))", "with distinct_hd_tl stack_distinct"], ["proof (chain)\npicking this:\n  \\<lbrakk>distinct ?xs; ?x = hd ?xs\\<rbrakk>\n  \\<Longrightarrow> ?x \\<notin> set (tl ?xs)\n  distinct (stack s)\n  v = hd (stack s)", "have ul: \"?ul = [hd (stack s)]\""], ["proof (prove)\nusing this:\n  \\<lbrakk>distinct ?xs; ?x = hd ?xs\\<rbrakk>\n  \\<Longrightarrow> ?x \\<notin> set (tl ?xs)\n  distinct (stack s)\n  v = hd (stack s)\n\ngoal (1 subgoal):\n 1. hd (stack s) # dropWhileNot v (rev (tl (stack s))) = [hd (stack s)]", "by force"], ["proof (state)\nthis:\n  hd (stack s) # dropWhileNot v (rev (tl (stack s))) = [hd (stack s)]\n\ngoal (2 subgoals):\n 1. v = hd (stack s) \\<Longrightarrow>\n    path E (hd (hd (stack s) # dropWhileNot v (rev (tl (stack s)))))\n     (hd (stack s) # dropWhileNot v (rev (tl (stack s))))\n     (hd (hd (stack s) # dropWhileNot v (rev (tl (stack s)))))\n 2. v \\<noteq> hd (stack s) \\<Longrightarrow>\n    path E (hd (hd (stack s) # dropWhileNot v (rev (tl (stack s)))))\n     (hd (stack s) # dropWhileNot v (rev (tl (stack s))))\n     (hd (hd (stack s) # dropWhileNot v (rev (tl (stack s)))))", "from True uv_edg"], ["proof (chain)\npicking this:\n  v = hd (stack s)\n  (hd (stack s), v) \\<in> E", "show ?thesis"], ["proof (prove)\nusing this:\n  v = hd (stack s)\n  (hd (stack s), v) \\<in> E\n\ngoal (1 subgoal):\n 1. path E (hd (hd (stack s) # dropWhileNot v (rev (tl (stack s)))))\n     (hd (stack s) # dropWhileNot v (rev (tl (stack s))))\n     (hd (hd (stack s) # dropWhileNot v (rev (tl (stack s)))))", "by (subst ul)+ (simp add: path1)"], ["proof (state)\nthis:\n  path E (hd (hd (stack s) # dropWhileNot v (rev (tl (stack s)))))\n   (hd (stack s) # dropWhileNot v (rev (tl (stack s))))\n   (hd (hd (stack s) # dropWhileNot v (rev (tl (stack s)))))\n\ngoal (1 subgoal):\n 1. v \\<noteq> hd (stack s) \\<Longrightarrow>\n    path E (hd (hd (stack s) # dropWhileNot v (rev (tl (stack s)))))\n     (hd (stack s) # dropWhileNot v (rev (tl (stack s))))\n     (hd (hd (stack s) # dropWhileNot v (rev (tl (stack s)))))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. v \\<noteq> hd (stack s) \\<Longrightarrow>\n    path E (hd (hd (stack s) # dropWhileNot v (rev (tl (stack s)))))\n     (hd (stack s) # dropWhileNot v (rev (tl (stack s))))\n     (hd (hd (stack s) # dropWhileNot v (rev (tl (stack s)))))", "case False"], ["proof (state)\nthis:\n  v \\<noteq> hd (stack s)\n\ngoal (1 subgoal):\n 1. v \\<noteq> hd (stack s) \\<Longrightarrow>\n    path E (hd (hd (stack s) # dropWhileNot v (rev (tl (stack s)))))\n     (hd (stack s) # dropWhileNot v (rev (tl (stack s))))\n     (hd (hd (stack s) # dropWhileNot v (rev (tl (stack s)))))", "with v_in ne"], ["proof (chain)\npicking this:\n  v \\<in> set (stack s)\n  stack s \\<noteq> []\n  v \\<noteq> hd (stack s)", "have \"v \\<in> set ?ur\""], ["proof (prove)\nusing this:\n  v \\<in> set (stack s)\n  stack s \\<noteq> []\n  v \\<noteq> hd (stack s)\n\ngoal (1 subgoal):\n 1. v \\<in> set (rev (tl (stack s)))", "by (auto simp add: neq_Nil_conv)"], ["proof (state)\nthis:\n  v \\<in> set (rev (tl (stack s)))\n\ngoal (1 subgoal):\n 1. v \\<noteq> hd (stack s) \\<Longrightarrow>\n    path E (hd (hd (stack s) # dropWhileNot v (rev (tl (stack s)))))\n     (hd (stack s) # dropWhileNot v (rev (tl (stack s))))\n     (hd (hd (stack s) # dropWhileNot v (rev (tl (stack s)))))", "with P"], ["proof (chain)\npicking this:\n  \\<exists>v0\\<in>V0.\n     path E v0 (rev (tl (stack s)))\n      (hd (hd (stack s) # dropWhileNot v (rev (tl (stack s)))))\n  v \\<in> set (rev (tl (stack s)))", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>v0\\<in>V0.\n     path E v0 (rev (tl (stack s)))\n      (hd (hd (stack s) # dropWhileNot v (rev (tl (stack s)))))\n  v \\<in> set (rev (tl (stack s)))\n\ngoal (1 subgoal):\n 1. path E (hd (hd (stack s) # dropWhileNot v (rev (tl (stack s)))))\n     (hd (stack s) # dropWhileNot v (rev (tl (stack s))))\n     (hd (hd (stack s) # dropWhileNot v (rev (tl (stack s)))))", "by (fastforce intro: path_prepend \n                           dropWhileNot_path[where p=\"?ur\"]\n                           uv_edg)"], ["proof (state)\nthis:\n  path E (hd (hd (stack s) # dropWhileNot v (rev (tl (stack s)))))\n   (hd (stack s) # dropWhileNot v (rev (tl (stack s))))\n   (hd (hd (stack s) # dropWhileNot v (rev (tl (stack s)))))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  path E (hd (hd (stack s) # dropWhileNot v (rev (tl (stack s)))))\n   (hd (stack s) # dropWhileNot v (rev (tl (stack s))))\n   (hd (hd (stack s) # dropWhileNot v (rev (tl (stack s)))))\n\ngoal (1 subgoal):\n 1. se_back_edge (hd (stack s)) v s'\n    \\<le> SPEC\n           (\\<lambda>e.\n               DFS_invar G blue_dfs_params\n                (s'\\<lparr>state.more := e\\<rparr>) \\<longrightarrow>\n               lasso_inv (s'\\<lparr>state.more := e\\<rparr>))", "ultimately"], ["proof (chain)\npicking this:\n  hd (stack s) # dropWhileNot v (rev (tl (stack s))) \\<noteq> []\n  \\<exists>v0\\<in>V0.\n     path E v0 (rev (tl (stack s)))\n      (hd (hd (stack s) # dropWhileNot v (rev (tl (stack s)))))\n  accpt (hd (hd (stack s) # dropWhileNot v (rev (tl (stack s)))))\n  path E (hd (hd (stack s) # dropWhileNot v (rev (tl (stack s)))))\n   (hd (stack s) # dropWhileNot v (rev (tl (stack s))))\n   (hd (hd (stack s) # dropWhileNot v (rev (tl (stack s)))))", "have \"lasso_inv ?s\""], ["proof (prove)\nusing this:\n  hd (stack s) # dropWhileNot v (rev (tl (stack s))) \\<noteq> []\n  \\<exists>v0\\<in>V0.\n     path E v0 (rev (tl (stack s)))\n      (hd (hd (stack s) # dropWhileNot v (rev (tl (stack s)))))\n  accpt (hd (hd (stack s) # dropWhileNot v (rev (tl (stack s)))))\n  path E (hd (hd (stack s) # dropWhileNot v (rev (tl (stack s)))))\n   (hd (stack s) # dropWhileNot v (rev (tl (stack s))))\n   (hd (hd (stack s) # dropWhileNot v (rev (tl (stack s)))))\n\ngoal (1 subgoal):\n 1. lasso_inv\n     (s'\\<lparr>lasso :=\n                  Some\n                   (rev (tl (stack s)),\n                    hd (stack s) # dropWhileNot v (rev (tl (stack s)))),\n           red := red s\\<rparr>)", "by (simp add: lasso_inv_def)"], ["proof (state)\nthis:\n  lasso_inv\n   (s'\\<lparr>lasso :=\n                Some\n                 (rev (tl (stack s)),\n                  hd (stack s) # dropWhileNot v (rev (tl (stack s)))),\n         red := red s\\<rparr>)\n\ngoal (1 subgoal):\n 1. se_back_edge (hd (stack s)) v s'\n    \\<le> SPEC\n           (\\<lambda>e.\n               DFS_invar G blue_dfs_params\n                (s'\\<lparr>state.more := e\\<rparr>) \\<longrightarrow>\n               lasso_inv (s'\\<lparr>state.more := e\\<rparr>))", "}"], ["proof (state)\nthis:\n  \\<lbrakk>accpt (hd (stack s));\n   DFS_invar G blue_dfs_params\n    (s'\\<lparr>lasso :=\n                 Some\n                  (rev (tl (stack s)),\n                   hd (stack s) # dropWhileNot v (rev (tl (stack s)))),\n          red := red s\\<rparr>)\\<rbrakk>\n  \\<Longrightarrow> lasso_inv\n                     (s'\\<lparr>lasso :=\n                                  Some\n                                   (rev (tl (stack s)),\n                                    hd (stack s) #\n                                    dropWhileNot v (rev (tl (stack s)))),\n                           red := red s\\<rparr>)\n\ngoal (1 subgoal):\n 1. se_back_edge (hd (stack s)) v s'\n    \\<le> SPEC\n           (\\<lambda>e.\n               DFS_invar G blue_dfs_params\n                (s'\\<lparr>state.more := e\\<rparr>) \\<longrightarrow>\n               lasso_inv (s'\\<lparr>state.more := e\\<rparr>))", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>accpt (hd (stack s));\n   DFS_invar G blue_dfs_params\n    (s'\\<lparr>lasso :=\n                 Some\n                  (rev (tl (stack s)),\n                   hd (stack s) # dropWhileNot v (rev (tl (stack s)))),\n          red := red s\\<rparr>)\\<rbrakk>\n  \\<Longrightarrow> lasso_inv\n                     (s'\\<lparr>lasso :=\n                                  Some\n                                   (rev (tl (stack s)),\n                                    hd (stack s) #\n                                    dropWhileNot v (rev (tl (stack s)))),\n                           red := red s\\<rparr>)\n\ngoal (1 subgoal):\n 1. se_back_edge (hd (stack s)) v s'\n    \\<le> SPEC\n           (\\<lambda>e.\n               DFS_invar G blue_dfs_params\n                (s'\\<lparr>state.more := e\\<rparr>) \\<longrightarrow>\n               lasso_inv (s'\\<lparr>state.more := e\\<rparr>))", "{"], ["proof (state)\nthis:\n  \\<lbrakk>accpt (hd (stack s));\n   DFS_invar G blue_dfs_params\n    (s'\\<lparr>lasso :=\n                 Some\n                  (rev (tl (stack s)),\n                   hd (stack s) # dropWhileNot v (rev (tl (stack s)))),\n          red := red s\\<rparr>)\\<rbrakk>\n  \\<Longrightarrow> lasso_inv\n                     (s'\\<lparr>lasso :=\n                                  Some\n                                   (rev (tl (stack s)),\n                                    hd (stack s) #\n                                    dropWhileNot v (rev (tl (stack s)))),\n                           red := red s\\<rparr>)\n\ngoal (1 subgoal):\n 1. se_back_edge (hd (stack s)) v s'\n    \\<le> SPEC\n           (\\<lambda>e.\n               DFS_invar G blue_dfs_params\n                (s'\\<lparr>state.more := e\\<rparr>) \\<longrightarrow>\n               lasso_inv (s'\\<lparr>state.more := e\\<rparr>))", "assume accpt: \"accpt v\""], ["proof (state)\nthis:\n  accpt v\n\ngoal (1 subgoal):\n 1. se_back_edge (hd (stack s)) v s'\n    \\<le> SPEC\n           (\\<lambda>e.\n               DFS_invar G blue_dfs_params\n                (s'\\<lparr>state.more := e\\<rparr>) \\<longrightarrow>\n               lasso_inv (s'\\<lparr>state.more := e\\<rparr>))", "let ?vr = \"takeWhileNot v (rev (stack s))\""], ["proof (state)\ngoal (1 subgoal):\n 1. se_back_edge (hd (stack s)) v s'\n    \\<le> SPEC\n           (\\<lambda>e.\n               DFS_invar G blue_dfs_params\n                (s'\\<lparr>state.more := e\\<rparr>) \\<longrightarrow>\n               lasso_inv (s'\\<lparr>state.more := e\\<rparr>))", "let ?vl = \"dropWhileNot v (rev (stack s))\""], ["proof (state)\ngoal (1 subgoal):\n 1. se_back_edge (hd (stack s)) v s'\n    \\<le> SPEC\n           (\\<lambda>e.\n               DFS_invar G blue_dfs_params\n                (s'\\<lparr>state.more := e\\<rparr>) \\<longrightarrow>\n               lasso_inv (s'\\<lparr>state.more := e\\<rparr>))", "let ?s = \"s'\\<lparr>lasso := Some(?vr, ?vl), red := red s\\<rparr>\""], ["proof (state)\ngoal (1 subgoal):\n 1. se_back_edge (hd (stack s)) v s'\n    \\<le> SPEC\n           (\\<lambda>e.\n               DFS_invar G blue_dfs_params\n                (s'\\<lparr>state.more := e\\<rparr>) \\<longrightarrow>\n               lasso_inv (s'\\<lparr>state.more := e\\<rparr>))", "assume \"DFS_invar G blue_dfs_params ?s\""], ["proof (state)\nthis:\n  DFS_invar G blue_dfs_params\n   (s'\\<lparr>lasso :=\n                Some\n                 (takeWhileNot v (rev (stack s)),\n                  dropWhileNot v (rev (stack s))),\n         red := red s\\<rparr>)\n\ngoal (1 subgoal):\n 1. se_back_edge (hd (stack s)) v s'\n    \\<le> SPEC\n           (\\<lambda>e.\n               DFS_invar G blue_dfs_params\n                (s'\\<lparr>state.more := e\\<rparr>) \\<longrightarrow>\n               lasso_inv (s'\\<lparr>state.more := e\\<rparr>))", "have [simp]: \"stack ?s = stack s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stack\n     (s'\\<lparr>lasso :=\n                  Some\n                   (takeWhileNot v (rev (stack s)),\n                    dropWhileNot v (rev (stack s))),\n           red := red s\\<rparr>) =\n    stack s", "by (simp add: s')"], ["proof (state)\nthis:\n  stack\n   (s'\\<lparr>lasso :=\n                Some\n                 (takeWhileNot v (rev (stack s)),\n                  dropWhileNot v (rev (stack s))),\n         red := red s\\<rparr>) =\n  stack s\n\ngoal (1 subgoal):\n 1. se_back_edge (hd (stack s)) v s'\n    \\<le> SPEC\n           (\\<lambda>e.\n               DFS_invar G blue_dfs_params\n                (s'\\<lparr>state.more := e\\<rparr>) \\<longrightarrow>\n               lasso_inv (s'\\<lparr>state.more := e\\<rparr>))", "from ne v_in"], ["proof (chain)\npicking this:\n  stack s \\<noteq> []\n  v \\<in> set (stack s)", "have hd_vl[simp]: \"hd ?vl = v\""], ["proof (prove)\nusing this:\n  stack s \\<noteq> []\n  v \\<in> set (stack s)\n\ngoal (1 subgoal):\n 1. hd (dropWhileNot v (rev (stack s))) = v", "by (induct (\"stack s\") rule: rev_nonempty_induct) auto"], ["proof (state)\nthis:\n  hd (dropWhileNot v (rev (stack s))) = v\n\ngoal (1 subgoal):\n 1. se_back_edge (hd (stack s)) v s'\n    \\<le> SPEC\n           (\\<lambda>e.\n               DFS_invar G blue_dfs_params\n                (s'\\<lparr>state.more := e\\<rparr>) \\<longrightarrow>\n               lasso_inv (s'\\<lparr>state.more := e\\<rparr>))", "from v_in"], ["proof (chain)\npicking this:\n  v \\<in> set (stack s)", "have \"?vl \\<noteq> []\""], ["proof (prove)\nusing this:\n  v \\<in> set (stack s)\n\ngoal (1 subgoal):\n 1. dropWhileNot v (rev (stack s)) \\<noteq> []", "by simp"], ["proof (state)\nthis:\n  dropWhileNot v (rev (stack s)) \\<noteq> []\n\ngoal (1 subgoal):\n 1. se_back_edge (hd (stack s)) v s'\n    \\<le> SPEC\n           (\\<lambda>e.\n               DFS_invar G blue_dfs_params\n                (s'\\<lparr>state.more := e\\<rparr>) \\<longrightarrow>\n               lasso_inv (s'\\<lparr>state.more := e\\<rparr>))", "moreover"], ["proof (state)\nthis:\n  dropWhileNot v (rev (stack s)) \\<noteq> []\n\ngoal (1 subgoal):\n 1. se_back_edge (hd (stack s)) v s'\n    \\<le> SPEC\n           (\\<lambda>e.\n               DFS_invar G blue_dfs_params\n                (s'\\<lparr>state.more := e\\<rparr>) \\<longrightarrow>\n               lasso_inv (s'\\<lparr>state.more := e\\<rparr>))", "from hd_succ_stack_is_path[OF ne] uv_edg"], ["proof (chain)\npicking this:\n  ?v \\<in> E `` {hd (stack s)} \\<Longrightarrow>\n  \\<exists>v0\\<in>V0. path E v0 (rev (stack s)) ?v\n  (hd (stack s), v) \\<in> E", "have \n        P: \"\\<exists>v0\\<in>V0. path E v0 (rev (stack s)) v\""], ["proof (prove)\nusing this:\n  ?v \\<in> E `` {hd (stack s)} \\<Longrightarrow>\n  \\<exists>v0\\<in>V0. path E v0 (rev (stack s)) ?v\n  (hd (stack s), v) \\<in> E\n\ngoal (1 subgoal):\n 1. \\<exists>v0\\<in>V0. path E v0 (rev (stack s)) v", "by auto"], ["proof (state)\nthis:\n  \\<exists>v0\\<in>V0. path E v0 (rev (stack s)) v\n\ngoal (1 subgoal):\n 1. se_back_edge (hd (stack s)) v s'\n    \\<le> SPEC\n           (\\<lambda>e.\n               DFS_invar G blue_dfs_params\n                (s'\\<lparr>state.more := e\\<rparr>) \\<longrightarrow>\n               lasso_inv (s'\\<lparr>state.more := e\\<rparr>))", "with ne v_in"], ["proof (chain)\npicking this:\n  stack s \\<noteq> []\n  v \\<in> set (stack s)\n  \\<exists>v0\\<in>V0. path E v0 (rev (stack s)) v", "have \"\\<exists>v0\\<in>V0. path E v0 ?vr (hd ?vl)\""], ["proof (prove)\nusing this:\n  stack s \\<noteq> []\n  v \\<in> set (stack s)\n  \\<exists>v0\\<in>V0. path E v0 (rev (stack s)) v\n\ngoal (1 subgoal):\n 1. \\<exists>v0\\<in>V0.\n       path E v0 (takeWhileNot v (rev (stack s)))\n        (hd (dropWhileNot v (rev (stack s))))", "by (force intro: takeWhileNot_path)"], ["proof (state)\nthis:\n  \\<exists>v0\\<in>V0.\n     path E v0 (takeWhileNot v (rev (stack s)))\n      (hd (dropWhileNot v (rev (stack s))))\n\ngoal (1 subgoal):\n 1. se_back_edge (hd (stack s)) v s'\n    \\<le> SPEC\n           (\\<lambda>e.\n               DFS_invar G blue_dfs_params\n                (s'\\<lparr>state.more := e\\<rparr>) \\<longrightarrow>\n               lasso_inv (s'\\<lparr>state.more := e\\<rparr>))", "moreover"], ["proof (state)\nthis:\n  \\<exists>v0\\<in>V0.\n     path E v0 (takeWhileNot v (rev (stack s)))\n      (hd (dropWhileNot v (rev (stack s))))\n\ngoal (1 subgoal):\n 1. se_back_edge (hd (stack s)) v s'\n    \\<le> SPEC\n           (\\<lambda>e.\n               DFS_invar G blue_dfs_params\n                (s'\\<lparr>state.more := e\\<rparr>) \\<longrightarrow>\n               lasso_inv (s'\\<lparr>state.more := e\\<rparr>))", "from accpt"], ["proof (chain)\npicking this:\n  accpt v", "have \"accpt (hd ?vl)\""], ["proof (prove)\nusing this:\n  accpt v\n\ngoal (1 subgoal):\n 1. accpt (hd (dropWhileNot v (rev (stack s))))", "by simp"], ["proof (state)\nthis:\n  accpt (hd (dropWhileNot v (rev (stack s))))\n\ngoal (1 subgoal):\n 1. se_back_edge (hd (stack s)) v s'\n    \\<le> SPEC\n           (\\<lambda>e.\n               DFS_invar G blue_dfs_params\n                (s'\\<lparr>state.more := e\\<rparr>) \\<longrightarrow>\n               lasso_inv (s'\\<lparr>state.more := e\\<rparr>))", "moreover"], ["proof (state)\nthis:\n  accpt (hd (dropWhileNot v (rev (stack s))))\n\ngoal (1 subgoal):\n 1. se_back_edge (hd (stack s)) v s'\n    \\<le> SPEC\n           (\\<lambda>e.\n               DFS_invar G blue_dfs_params\n                (s'\\<lparr>state.more := e\\<rparr>) \\<longrightarrow>\n               lasso_inv (s'\\<lparr>state.more := e\\<rparr>))", "from P ne v_in"], ["proof (chain)\npicking this:\n  \\<exists>v0\\<in>V0. path E v0 (rev (stack s)) v\n  stack s \\<noteq> []\n  v \\<in> set (stack s)", "have \"path E (hd ?vl) ?vl (hd ?vl)\""], ["proof (prove)\nusing this:\n  \\<exists>v0\\<in>V0. path E v0 (rev (stack s)) v\n  stack s \\<noteq> []\n  v \\<in> set (stack s)\n\ngoal (1 subgoal):\n 1. path E (hd (dropWhileNot v (rev (stack s))))\n     (dropWhileNot v (rev (stack s))) (hd (dropWhileNot v (rev (stack s))))", "by (force intro: dropWhileNot_path)"], ["proof (state)\nthis:\n  path E (hd (dropWhileNot v (rev (stack s))))\n   (dropWhileNot v (rev (stack s))) (hd (dropWhileNot v (rev (stack s))))\n\ngoal (1 subgoal):\n 1. se_back_edge (hd (stack s)) v s'\n    \\<le> SPEC\n           (\\<lambda>e.\n               DFS_invar G blue_dfs_params\n                (s'\\<lparr>state.more := e\\<rparr>) \\<longrightarrow>\n               lasso_inv (s'\\<lparr>state.more := e\\<rparr>))", "ultimately"], ["proof (chain)\npicking this:\n  dropWhileNot v (rev (stack s)) \\<noteq> []\n  \\<exists>v0\\<in>V0.\n     path E v0 (takeWhileNot v (rev (stack s)))\n      (hd (dropWhileNot v (rev (stack s))))\n  accpt (hd (dropWhileNot v (rev (stack s))))\n  path E (hd (dropWhileNot v (rev (stack s))))\n   (dropWhileNot v (rev (stack s))) (hd (dropWhileNot v (rev (stack s))))", "have \"lasso_inv ?s\""], ["proof (prove)\nusing this:\n  dropWhileNot v (rev (stack s)) \\<noteq> []\n  \\<exists>v0\\<in>V0.\n     path E v0 (takeWhileNot v (rev (stack s)))\n      (hd (dropWhileNot v (rev (stack s))))\n  accpt (hd (dropWhileNot v (rev (stack s))))\n  path E (hd (dropWhileNot v (rev (stack s))))\n   (dropWhileNot v (rev (stack s))) (hd (dropWhileNot v (rev (stack s))))\n\ngoal (1 subgoal):\n 1. lasso_inv\n     (s'\\<lparr>lasso :=\n                  Some\n                   (takeWhileNot v (rev (stack s)),\n                    dropWhileNot v (rev (stack s))),\n           red := red s\\<rparr>)", "by (simp add: lasso_inv_def)"], ["proof (state)\nthis:\n  lasso_inv\n   (s'\\<lparr>lasso :=\n                Some\n                 (takeWhileNot v (rev (stack s)),\n                  dropWhileNot v (rev (stack s))),\n         red := red s\\<rparr>)\n\ngoal (1 subgoal):\n 1. se_back_edge (hd (stack s)) v s'\n    \\<le> SPEC\n           (\\<lambda>e.\n               DFS_invar G blue_dfs_params\n                (s'\\<lparr>state.more := e\\<rparr>) \\<longrightarrow>\n               lasso_inv (s'\\<lparr>state.more := e\\<rparr>))", "}"], ["proof (state)\nthis:\n  \\<lbrakk>accpt v;\n   DFS_invar G blue_dfs_params\n    (s'\\<lparr>lasso :=\n                 Some\n                  (takeWhileNot v (rev (stack s)),\n                   dropWhileNot v (rev (stack s))),\n          red := red s\\<rparr>)\\<rbrakk>\n  \\<Longrightarrow> lasso_inv\n                     (s'\\<lparr>lasso :=\n                                  Some\n                                   (takeWhileNot v (rev (stack s)),\n                                    dropWhileNot v (rev (stack s))),\n                           red := red s\\<rparr>)\n\ngoal (1 subgoal):\n 1. se_back_edge (hd (stack s)) v s'\n    \\<le> SPEC\n           (\\<lambda>e.\n               DFS_invar G blue_dfs_params\n                (s'\\<lparr>state.more := e\\<rparr>) \\<longrightarrow>\n               lasso_inv (s'\\<lparr>state.more := e\\<rparr>))", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>accpt v;\n   DFS_invar G blue_dfs_params\n    (s'\\<lparr>lasso :=\n                 Some\n                  (takeWhileNot v (rev (stack s)),\n                   dropWhileNot v (rev (stack s))),\n          red := red s\\<rparr>)\\<rbrakk>\n  \\<Longrightarrow> lasso_inv\n                     (s'\\<lparr>lasso :=\n                                  Some\n                                   (takeWhileNot v (rev (stack s)),\n                                    dropWhileNot v (rev (stack s))),\n                           red := red s\\<rparr>)\n\ngoal (1 subgoal):\n 1. se_back_edge (hd (stack s)) v s'\n    \\<le> SPEC\n           (\\<lambda>e.\n               DFS_invar G blue_dfs_params\n                (s'\\<lparr>state.more := e\\<rparr>) \\<longrightarrow>\n               lasso_inv (s'\\<lparr>state.more := e\\<rparr>))", "{"], ["proof (state)\nthis:\n  \\<lbrakk>accpt v;\n   DFS_invar G blue_dfs_params\n    (s'\\<lparr>lasso :=\n                 Some\n                  (takeWhileNot v (rev (stack s)),\n                   dropWhileNot v (rev (stack s))),\n          red := red s\\<rparr>)\\<rbrakk>\n  \\<Longrightarrow> lasso_inv\n                     (s'\\<lparr>lasso :=\n                                  Some\n                                   (takeWhileNot v (rev (stack s)),\n                                    dropWhileNot v (rev (stack s))),\n                           red := red s\\<rparr>)\n\ngoal (1 subgoal):\n 1. se_back_edge (hd (stack s)) v s'\n    \\<le> SPEC\n           (\\<lambda>e.\n               DFS_invar G blue_dfs_params\n                (s'\\<lparr>state.more := e\\<rparr>) \\<longrightarrow>\n               lasso_inv (s'\\<lparr>state.more := e\\<rparr>))", "assume \"\\<not> accpt (hd (stack s))\" \"\\<not> accpt v\""], ["proof (state)\nthis:\n  \\<not> accpt (hd (stack s))\n  \\<not> accpt v\n\ngoal (1 subgoal):\n 1. se_back_edge (hd (stack s)) v s'\n    \\<le> SPEC\n           (\\<lambda>e.\n               DFS_invar G blue_dfs_params\n                (s'\\<lparr>state.more := e\\<rparr>) \\<longrightarrow>\n               lasso_inv (s'\\<lparr>state.more := e\\<rparr>))", "let ?s = \"s'\\<lparr>state.more := state.more s'\\<rparr>\""], ["proof (state)\ngoal (1 subgoal):\n 1. se_back_edge (hd (stack s)) v s'\n    \\<le> SPEC\n           (\\<lambda>e.\n               DFS_invar G blue_dfs_params\n                (s'\\<lparr>state.more := e\\<rparr>) \\<longrightarrow>\n               lasso_inv (s'\\<lparr>state.more := e\\<rparr>))", "assume \"DFS_invar G blue_dfs_params ?s\""], ["proof (state)\nthis:\n  DFS_invar G blue_dfs_params\n   (s'\\<lparr>state.more := state.more s'\\<rparr>)\n\ngoal (1 subgoal):\n 1. se_back_edge (hd (stack s)) v s'\n    \\<le> SPEC\n           (\\<lambda>e.\n               DFS_invar G blue_dfs_params\n                (s'\\<lparr>state.more := e\\<rparr>) \\<longrightarrow>\n               lasso_inv (s'\\<lparr>state.more := e\\<rparr>))", "from assms"], ["proof (chain)\npicking this:\n  lasso_inv s\n  stack s \\<noteq> []\n  lasso s = None\n  (hd (stack s), v) \\<in> pending s\n  v \\<in> dom (discovered s)\n  v \\<notin> dom (finished s)\n  s' =\n  back_edge (hd (stack s)) v\n   (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)", "have \"lasso_inv ?s\""], ["proof (prove)\nusing this:\n  lasso_inv s\n  stack s \\<noteq> []\n  lasso s = None\n  (hd (stack s), v) \\<in> pending s\n  v \\<in> dom (discovered s)\n  v \\<notin> dom (finished s)\n  s' =\n  back_edge (hd (stack s)) v\n   (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n\ngoal (1 subgoal):\n 1. lasso_inv (s'\\<lparr>state.more := state.more s'\\<rparr>)", "by (auto simp add: lasso_inv_def)"], ["proof (state)\nthis:\n  lasso_inv (s'\\<lparr>state.more := state.more s'\\<rparr>)\n\ngoal (1 subgoal):\n 1. se_back_edge (hd (stack s)) v s'\n    \\<le> SPEC\n           (\\<lambda>e.\n               DFS_invar G blue_dfs_params\n                (s'\\<lparr>state.more := e\\<rparr>) \\<longrightarrow>\n               lasso_inv (s'\\<lparr>state.more := e\\<rparr>))", "}"], ["proof (state)\nthis:\n  \\<lbrakk>\\<not> accpt (hd (stack s)); \\<not> accpt v;\n   DFS_invar G blue_dfs_params\n    (s'\\<lparr>state.more := state.more s'\\<rparr>)\\<rbrakk>\n  \\<Longrightarrow> lasso_inv\n                     (s'\\<lparr>state.more := state.more s'\\<rparr>)\n\ngoal (1 subgoal):\n 1. se_back_edge (hd (stack s)) v s'\n    \\<le> SPEC\n           (\\<lambda>e.\n               DFS_invar G blue_dfs_params\n                (s'\\<lparr>state.more := e\\<rparr>) \\<longrightarrow>\n               lasso_inv (s'\\<lparr>state.more := e\\<rparr>))", "(* TODO: Clean up this proof, separate logical arguments from framework \n      boilerplate! *)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<not> accpt (hd (stack s)); \\<not> accpt v;\n   DFS_invar G blue_dfs_params\n    (s'\\<lparr>state.more := state.more s'\\<rparr>)\\<rbrakk>\n  \\<Longrightarrow> lasso_inv\n                     (s'\\<lparr>state.more := state.more s'\\<rparr>)\n\ngoal (1 subgoal):\n 1. se_back_edge (hd (stack s)) v s'\n    \\<le> SPEC\n           (\\<lambda>e.\n               DFS_invar G blue_dfs_params\n                (s'\\<lparr>state.more := e\\<rparr>) \\<longrightarrow>\n               lasso_inv (s'\\<lparr>state.more := e\\<rparr>))", "ultimately"], ["proof (chain)\npicking this:\n  \\<lbrakk>accpt (hd (stack s));\n   DFS_invar G blue_dfs_params\n    (s'\\<lparr>lasso :=\n                 Some\n                  (rev (tl (stack s)),\n                   hd (stack s) # dropWhileNot v (rev (tl (stack s)))),\n          red := red s\\<rparr>)\\<rbrakk>\n  \\<Longrightarrow> lasso_inv\n                     (s'\\<lparr>lasso :=\n                                  Some\n                                   (rev (tl (stack s)),\n                                    hd (stack s) #\n                                    dropWhileNot v (rev (tl (stack s)))),\n                           red := red s\\<rparr>)\n  \\<lbrakk>accpt v;\n   DFS_invar G blue_dfs_params\n    (s'\\<lparr>lasso :=\n                 Some\n                  (takeWhileNot v (rev (stack s)),\n                   dropWhileNot v (rev (stack s))),\n          red := red s\\<rparr>)\\<rbrakk>\n  \\<Longrightarrow> lasso_inv\n                     (s'\\<lparr>lasso :=\n                                  Some\n                                   (takeWhileNot v (rev (stack s)),\n                                    dropWhileNot v (rev (stack s))),\n                           red := red s\\<rparr>)\n  \\<lbrakk>\\<not> accpt (hd (stack s)); \\<not> accpt v;\n   DFS_invar G blue_dfs_params\n    (s'\\<lparr>state.more := state.more s'\\<rparr>)\\<rbrakk>\n  \\<Longrightarrow> lasso_inv\n                     (s'\\<lparr>state.more := state.more s'\\<rparr>)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>accpt (hd (stack s));\n   DFS_invar G blue_dfs_params\n    (s'\\<lparr>lasso :=\n                 Some\n                  (rev (tl (stack s)),\n                   hd (stack s) # dropWhileNot v (rev (tl (stack s)))),\n          red := red s\\<rparr>)\\<rbrakk>\n  \\<Longrightarrow> lasso_inv\n                     (s'\\<lparr>lasso :=\n                                  Some\n                                   (rev (tl (stack s)),\n                                    hd (stack s) #\n                                    dropWhileNot v (rev (tl (stack s)))),\n                           red := red s\\<rparr>)\n  \\<lbrakk>accpt v;\n   DFS_invar G blue_dfs_params\n    (s'\\<lparr>lasso :=\n                 Some\n                  (takeWhileNot v (rev (stack s)),\n                   dropWhileNot v (rev (stack s))),\n          red := red s\\<rparr>)\\<rbrakk>\n  \\<Longrightarrow> lasso_inv\n                     (s'\\<lparr>lasso :=\n                                  Some\n                                   (takeWhileNot v (rev (stack s)),\n                                    dropWhileNot v (rev (stack s))),\n                           red := red s\\<rparr>)\n  \\<lbrakk>\\<not> accpt (hd (stack s)); \\<not> accpt v;\n   DFS_invar G blue_dfs_params\n    (s'\\<lparr>state.more := state.more s'\\<rparr>)\\<rbrakk>\n  \\<Longrightarrow> lasso_inv\n                     (s'\\<lparr>state.more := state.more s'\\<rparr>)\n\ngoal (1 subgoal):\n 1. se_back_edge (hd (stack s)) v s'\n    \\<le> SPEC\n           (\\<lambda>e.\n               DFS_invar G blue_dfs_params\n                (s'\\<lparr>state.more := e\\<rparr>) \\<longrightarrow>\n               lasso_inv (s'\\<lparr>state.more := e\\<rparr>))", "using R s'"], ["proof (prove)\nusing this:\n  \\<lbrakk>accpt (hd (stack s));\n   DFS_invar G blue_dfs_params\n    (s'\\<lparr>lasso :=\n                 Some\n                  (rev (tl (stack s)),\n                   hd (stack s) # dropWhileNot v (rev (tl (stack s)))),\n          red := red s\\<rparr>)\\<rbrakk>\n  \\<Longrightarrow> lasso_inv\n                     (s'\\<lparr>lasso :=\n                                  Some\n                                   (rev (tl (stack s)),\n                                    hd (stack s) #\n                                    dropWhileNot v (rev (tl (stack s)))),\n                           red := red s\\<rparr>)\n  \\<lbrakk>accpt v;\n   DFS_invar G blue_dfs_params\n    (s'\\<lparr>lasso :=\n                 Some\n                  (takeWhileNot v (rev (stack s)),\n                   dropWhileNot v (rev (stack s))),\n          red := red s\\<rparr>)\\<rbrakk>\n  \\<Longrightarrow> lasso_inv\n                     (s'\\<lparr>lasso :=\n                                  Some\n                                   (takeWhileNot v (rev (stack s)),\n                                    dropWhileNot v (rev (stack s))),\n                           red := red s\\<rparr>)\n  \\<lbrakk>\\<not> accpt (hd (stack s)); \\<not> accpt v;\n   DFS_invar G blue_dfs_params\n    (s'\\<lparr>state.more := state.more s'\\<rparr>)\\<rbrakk>\n  \\<Longrightarrow> lasso_inv\n                     (s'\\<lparr>state.more := state.more s'\\<rparr>)\n  lasso s = None\n  s' =\n  back_edge (hd (stack s)) v\n   (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n\ngoal (1 subgoal):\n 1. se_back_edge (hd (stack s)) v s'\n    \\<le> SPEC\n           (\\<lambda>e.\n               DFS_invar G blue_dfs_params\n                (s'\\<lparr>state.more := e\\<rparr>) \\<longrightarrow>\n               lasso_inv (s'\\<lparr>state.more := e\\<rparr>))", "unfolding se_back_edge_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>accpt (hd (stack s));\n   DFS_invar G blue_dfs_params\n    (s'\\<lparr>lasso :=\n                 Some\n                  (rev (tl (stack s)),\n                   hd (stack s) # dropWhileNot v (rev (tl (stack s)))),\n          red := red s\\<rparr>)\\<rbrakk>\n  \\<Longrightarrow> lasso_inv\n                     (s'\\<lparr>lasso :=\n                                  Some\n                                   (rev (tl (stack s)),\n                                    hd (stack s) #\n                                    dropWhileNot v (rev (tl (stack s)))),\n                           red := red s\\<rparr>)\n  \\<lbrakk>accpt v;\n   DFS_invar G blue_dfs_params\n    (s'\\<lparr>lasso :=\n                 Some\n                  (takeWhileNot v (rev (stack s)),\n                   dropWhileNot v (rev (stack s))),\n          red := red s\\<rparr>)\\<rbrakk>\n  \\<Longrightarrow> lasso_inv\n                     (s'\\<lparr>lasso :=\n                                  Some\n                                   (takeWhileNot v (rev (stack s)),\n                                    dropWhileNot v (rev (stack s))),\n                           red := red s\\<rparr>)\n  \\<lbrakk>\\<not> accpt (hd (stack s)); \\<not> accpt v;\n   DFS_invar G blue_dfs_params\n    (s'\\<lparr>state.more := state.more s'\\<rparr>)\\<rbrakk>\n  \\<Longrightarrow> lasso_inv\n                     (s'\\<lparr>state.more := state.more s'\\<rparr>)\n  lasso s = None\n  s' =\n  back_edge (hd (stack s)) v\n   (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n\ngoal (1 subgoal):\n 1. (case lasso s' of\n     None \\<Rightarrow>\n       if accpt (hd (stack s))\n       then let rs = rev (tl (stack s')); ur = rs;\n                ul = hd (stack s) # dropWhileNot v rs\n            in RETURN \\<lparr>lasso = Some (ur, ul), red = red s'\\<rparr>\n       else if accpt v\n            then let rs = rev (stack s'); vr = takeWhileNot v rs;\n                     vl = dropWhileNot v rs\n                 in RETURN\n                     \\<lparr>lasso = Some (vr, vl), red = red s'\\<rparr>\n            else NOOP s'\n     | Some a \\<Rightarrow> NOOP s')\n    \\<le> SPEC\n           (\\<lambda>e.\n               DFS_invar G blue_dfs_params\n                (s'\\<lparr>state.more := e\\<rparr>) \\<longrightarrow>\n               lasso_inv (s'\\<lparr>state.more := e\\<rparr>))", "by (auto split: option.splits)"], ["proof (state)\nthis:\n  se_back_edge (hd (stack s)) v s'\n  \\<le> SPEC\n         (\\<lambda>e.\n             DFS_invar G blue_dfs_params\n              (s'\\<lparr>state.more := e\\<rparr>) \\<longrightarrow>\n             lasso_inv (s'\\<lparr>state.more := e\\<rparr>))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lasso_inv:\n    \"is_invar lasso_inv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_invar lasso_inv", "proof (induct rule: establish_invarI)"], ["proof (state)\ngoal (6 subgoals):\n 1. on_init blue_dfs_params \\<le>\\<^sub>n\n    SPEC (\\<lambda>x. lasso_inv (empty_state x))\n 2. \\<And>s s' v0.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; lasso_inv s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s = []; v0 \\<in> V0;\n        v0 \\<notin> dom (discovered s); s' = new_root v0 s\\<rbrakk>\n       \\<Longrightarrow> on_new_root blue_dfs_params v0 s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso_inv (s'\\<lparr>state.more := x\\<rparr>))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; lasso_inv s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish blue_dfs_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso_inv (s'\\<lparr>state.more := x\\<rparr>))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; lasso_inv s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso_inv (s'\\<lparr>state.more := x\\<rparr>))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; lasso_inv s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso_inv (s'\\<lparr>state.more := x\\<rparr>))\n 6. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; lasso_inv s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<notin> dom (discovered s);\n        s' =\n        discover u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso_inv (s'\\<lparr>state.more := x\\<rparr>))", "case (finish s s' u)"], ["proof (state)\nthis:\n  DFS_invar G blue_dfs_params s\n  lasso_inv s\n  cond s\n  \\<not> is_break blue_dfs_params s\n  stack s \\<noteq> []\n  u = hd (stack s)\n  pending s `` {u} = {}\n  s' = finish u s\n\ngoal (6 subgoals):\n 1. on_init blue_dfs_params \\<le>\\<^sub>n\n    SPEC (\\<lambda>x. lasso_inv (empty_state x))\n 2. \\<And>s s' v0.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; lasso_inv s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s = []; v0 \\<in> V0;\n        v0 \\<notin> dom (discovered s); s' = new_root v0 s\\<rbrakk>\n       \\<Longrightarrow> on_new_root blue_dfs_params v0 s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso_inv (s'\\<lparr>state.more := x\\<rparr>))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; lasso_inv s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish blue_dfs_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso_inv (s'\\<lparr>state.more := x\\<rparr>))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; lasso_inv s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso_inv (s'\\<lparr>state.more := x\\<rparr>))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; lasso_inv s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso_inv (s'\\<lparr>state.more := x\\<rparr>))\n 6. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; lasso_inv s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<notin> dom (discovered s);\n        s' =\n        discover u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso_inv (s'\\<lparr>state.more := x\\<rparr>))", "then"], ["proof (chain)\npicking this:\n  DFS_invar G blue_dfs_params s\n  lasso_inv s\n  cond s\n  \\<not> is_break blue_dfs_params s\n  stack s \\<noteq> []\n  u = hd (stack s)\n  pending s `` {u} = {}\n  s' = finish u s", "interpret BlueDFS_invar where s=s"], ["proof (prove)\nusing this:\n  DFS_invar G blue_dfs_params s\n  lasso_inv s\n  cond s\n  \\<not> is_break blue_dfs_params s\n  stack s \\<noteq> []\n  u = hd (stack s)\n  pending s `` {u} = {}\n  s' = finish u s\n\ngoal (1 subgoal):\n 1. BlueDFS_invar G accpt s", "by simp"], ["proof (state)\ngoal (6 subgoals):\n 1. on_init blue_dfs_params \\<le>\\<^sub>n\n    SPEC (\\<lambda>x. lasso_inv (empty_state x))\n 2. \\<And>s s' v0.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; lasso_inv s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s = []; v0 \\<in> V0;\n        v0 \\<notin> dom (discovered s); s' = new_root v0 s\\<rbrakk>\n       \\<Longrightarrow> on_new_root blue_dfs_params v0 s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso_inv (s'\\<lparr>state.more := x\\<rparr>))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; lasso_inv s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish blue_dfs_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso_inv (s'\\<lparr>state.more := x\\<rparr>))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; lasso_inv s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso_inv (s'\\<lparr>state.more := x\\<rparr>))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; lasso_inv s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso_inv (s'\\<lparr>state.more := x\\<rparr>))\n 6. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; lasso_inv s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<notin> dom (discovered s);\n        s' =\n        discover u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso_inv (s'\\<lparr>state.more := x\\<rparr>))", "(* TODO/FIXME: Ughly proof structure *)"], ["proof (state)\ngoal (6 subgoals):\n 1. on_init blue_dfs_params \\<le>\\<^sub>n\n    SPEC (\\<lambda>x. lasso_inv (empty_state x))\n 2. \\<And>s s' v0.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; lasso_inv s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s = []; v0 \\<in> V0;\n        v0 \\<notin> dom (discovered s); s' = new_root v0 s\\<rbrakk>\n       \\<Longrightarrow> on_new_root blue_dfs_params v0 s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso_inv (s'\\<lparr>state.more := x\\<rparr>))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; lasso_inv s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish blue_dfs_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso_inv (s'\\<lparr>state.more := x\\<rparr>))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; lasso_inv s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso_inv (s'\\<lparr>state.more := x\\<rparr>))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; lasso_inv s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso_inv (s'\\<lparr>state.more := x\\<rparr>))\n 6. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; lasso_inv s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<notin> dom (discovered s);\n        s' =\n        discover u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso_inv (s'\\<lparr>state.more := x\\<rparr>))", "let ?onstack = \"\\<lambda>x. x \\<in> set (stack s)\""], ["proof (state)\ngoal (6 subgoals):\n 1. on_init blue_dfs_params \\<le>\\<^sub>n\n    SPEC (\\<lambda>x. lasso_inv (empty_state x))\n 2. \\<And>s s' v0.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; lasso_inv s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s = []; v0 \\<in> V0;\n        v0 \\<notin> dom (discovered s); s' = new_root v0 s\\<rbrakk>\n       \\<Longrightarrow> on_new_root blue_dfs_params v0 s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso_inv (s'\\<lparr>state.more := x\\<rparr>))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; lasso_inv s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish blue_dfs_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso_inv (s'\\<lparr>state.more := x\\<rparr>))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; lasso_inv s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso_inv (s'\\<lparr>state.more := x\\<rparr>))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; lasso_inv s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso_inv (s'\\<lparr>state.more := x\\<rparr>))\n 6. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; lasso_inv s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<notin> dom (discovered s);\n        s' =\n        discover u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso_inv (s'\\<lparr>state.more := x\\<rparr>))", "let ?rE = \"rel_restrict E (red s)\""], ["proof (state)\ngoal (6 subgoals):\n 1. on_init blue_dfs_params \\<le>\\<^sub>n\n    SPEC (\\<lambda>x. lasso_inv (empty_state x))\n 2. \\<And>s s' v0.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; lasso_inv s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s = []; v0 \\<in> V0;\n        v0 \\<notin> dom (discovered s); s' = new_root v0 s\\<rbrakk>\n       \\<Longrightarrow> on_new_root blue_dfs_params v0 s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso_inv (s'\\<lparr>state.more := x\\<rparr>))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; lasso_inv s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish blue_dfs_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso_inv (s'\\<lparr>state.more := x\\<rparr>))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; lasso_inv s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso_inv (s'\\<lparr>state.more := x\\<rparr>))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; lasso_inv s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso_inv (s'\\<lparr>state.more := x\\<rparr>))\n 6. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; lasso_inv s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<notin> dom (discovered s);\n        s' =\n        discover u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso_inv (s'\\<lparr>state.more := x\\<rparr>))", "let ?revs = \"rev (tl (stack s))\""], ["proof (state)\ngoal (6 subgoals):\n 1. on_init blue_dfs_params \\<le>\\<^sub>n\n    SPEC (\\<lambda>x. lasso_inv (empty_state x))\n 2. \\<And>s s' v0.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; lasso_inv s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s = []; v0 \\<in> V0;\n        v0 \\<notin> dom (discovered s); s' = new_root v0 s\\<rbrakk>\n       \\<Longrightarrow> on_new_root blue_dfs_params v0 s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso_inv (s'\\<lparr>state.more := x\\<rparr>))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; lasso_inv s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish blue_dfs_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso_inv (s'\\<lparr>state.more := x\\<rparr>))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; lasso_inv s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso_inv (s'\\<lparr>state.more := x\\<rparr>))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; lasso_inv s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso_inv (s'\\<lparr>state.more := x\\<rparr>))\n 6. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; lasso_inv s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<notin> dom (discovered s);\n        s' =\n        discover u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso_inv (s'\\<lparr>state.more := x\\<rparr>))", "note ne = \\<open>stack s \\<noteq> []\\<close>"], ["proof (state)\nthis:\n  stack s \\<noteq> []\n\ngoal (6 subgoals):\n 1. on_init blue_dfs_params \\<le>\\<^sub>n\n    SPEC (\\<lambda>x. lasso_inv (empty_state x))\n 2. \\<And>s s' v0.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; lasso_inv s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s = []; v0 \\<in> V0;\n        v0 \\<notin> dom (discovered s); s' = new_root v0 s\\<rbrakk>\n       \\<Longrightarrow> on_new_root blue_dfs_params v0 s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso_inv (s'\\<lparr>state.more := x\\<rparr>))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; lasso_inv s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish blue_dfs_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso_inv (s'\\<lparr>state.more := x\\<rparr>))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; lasso_inv s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso_inv (s'\\<lparr>state.more := x\\<rparr>))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; lasso_inv s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso_inv (s'\\<lparr>state.more := x\\<rparr>))\n 6. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; lasso_inv s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<notin> dom (discovered s);\n        s' =\n        discover u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso_inv (s'\\<lparr>state.more := x\\<rparr>))", "note [simp] = \\<open>u=hd (stack s)\\<close>"], ["proof (state)\nthis:\n  u = hd (stack s)\n\ngoal (6 subgoals):\n 1. on_init blue_dfs_params \\<le>\\<^sub>n\n    SPEC (\\<lambda>x. lasso_inv (empty_state x))\n 2. \\<And>s s' v0.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; lasso_inv s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s = []; v0 \\<in> V0;\n        v0 \\<notin> dom (discovered s); s' = new_root v0 s\\<rbrakk>\n       \\<Longrightarrow> on_new_root blue_dfs_params v0 s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso_inv (s'\\<lparr>state.more := x\\<rparr>))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; lasso_inv s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish blue_dfs_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso_inv (s'\\<lparr>state.more := x\\<rparr>))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; lasso_inv s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso_inv (s'\\<lparr>state.more := x\\<rparr>))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; lasso_inv s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso_inv (s'\\<lparr>state.more := x\\<rparr>))\n 6. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; lasso_inv s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<notin> dom (discovered s);\n        s' =\n        discover u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso_inv (s'\\<lparr>state.more := x\\<rparr>))", "from finish"], ["proof (chain)\npicking this:\n  DFS_invar G blue_dfs_params s\n  lasso_inv s\n  cond s\n  \\<not> is_break blue_dfs_params s\n  stack s \\<noteq> []\n  u = hd (stack s)\n  pending s `` {u} = {}\n  s' = finish u s", "have [simp]: \n      \"\\<And>x. x = hd (stack s) \\<or> x \\<in> set (stack s') \\<longleftrightarrow> x\\<in>set (stack s)\"\n      \"red s' = red s\"\n      \"lasso s' = lasso s\""], ["proof (prove)\nusing this:\n  DFS_invar G blue_dfs_params s\n  lasso_inv s\n  cond s\n  \\<not> is_break blue_dfs_params s\n  stack s \\<noteq> []\n  u = hd (stack s)\n  pending s `` {u} = {}\n  s' = finish u s\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        (x = hd (stack s) \\<or> x \\<in> set (stack s')) =\n        (x \\<in> set (stack s))) &&&\n    red s' = red s &&& lasso s' = lasso s", "by (auto simp: neq_Nil_conv)"], ["proof (state)\nthis:\n  (?x9 = hd (stack s) \\<or> ?x9 \\<in> set (stack s')) =\n  (?x9 \\<in> set (stack s))\n  red s' = red s\n  lasso s' = lasso s\n\ngoal (6 subgoals):\n 1. on_init blue_dfs_params \\<le>\\<^sub>n\n    SPEC (\\<lambda>x. lasso_inv (empty_state x))\n 2. \\<And>s s' v0.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; lasso_inv s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s = []; v0 \\<in> V0;\n        v0 \\<notin> dom (discovered s); s' = new_root v0 s\\<rbrakk>\n       \\<Longrightarrow> on_new_root blue_dfs_params v0 s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso_inv (s'\\<lparr>state.more := x\\<rparr>))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; lasso_inv s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish blue_dfs_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso_inv (s'\\<lparr>state.more := x\\<rparr>))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; lasso_inv s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso_inv (s'\\<lparr>state.more := x\\<rparr>))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; lasso_inv s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso_inv (s'\\<lparr>state.more := x\\<rparr>))\n 6. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; lasso_inv s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<notin> dom (discovered s);\n        s' =\n        discover u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso_inv (s'\\<lparr>state.more := x\\<rparr>))", "{"], ["proof (state)\nthis:\n  (?x9 = hd (stack s) \\<or> ?x9 \\<in> set (stack s')) =\n  (?x9 \\<in> set (stack s))\n  red s' = red s\n  lasso s' = lasso s\n\ngoal (6 subgoals):\n 1. on_init blue_dfs_params \\<le>\\<^sub>n\n    SPEC (\\<lambda>x. lasso_inv (empty_state x))\n 2. \\<And>s s' v0.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; lasso_inv s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s = []; v0 \\<in> V0;\n        v0 \\<notin> dom (discovered s); s' = new_root v0 s\\<rbrakk>\n       \\<Longrightarrow> on_new_root blue_dfs_params v0 s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso_inv (s'\\<lparr>state.more := x\\<rparr>))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; lasso_inv s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish blue_dfs_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso_inv (s'\\<lparr>state.more := x\\<rparr>))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; lasso_inv s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso_inv (s'\\<lparr>state.more := x\\<rparr>))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; lasso_inv s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso_inv (s'\\<lparr>state.more := x\\<rparr>))\n 6. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; lasso_inv s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<notin> dom (discovered s);\n        s' =\n        discover u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso_inv (s'\\<lparr>state.more := x\\<rparr>))", "fix v vs"], ["proof (state)\ngoal (6 subgoals):\n 1. on_init blue_dfs_params \\<le>\\<^sub>n\n    SPEC (\\<lambda>x. lasso_inv (empty_state x))\n 2. \\<And>s s' v0.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; lasso_inv s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s = []; v0 \\<in> V0;\n        v0 \\<notin> dom (discovered s); s' = new_root v0 s\\<rbrakk>\n       \\<Longrightarrow> on_new_root blue_dfs_params v0 s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso_inv (s'\\<lparr>state.more := x\\<rparr>))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; lasso_inv s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish blue_dfs_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso_inv (s'\\<lparr>state.more := x\\<rparr>))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; lasso_inv s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso_inv (s'\\<lparr>state.more := x\\<rparr>))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; lasso_inv s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso_inv (s'\\<lparr>state.more := x\\<rparr>))\n 6. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; lasso_inv s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<notin> dom (discovered s);\n        s' =\n        discover u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso_inv (s'\\<lparr>state.more := x\\<rparr>))", "let ?cyc = \"vs @ dropWhileNot v ?revs\""], ["proof (state)\ngoal (6 subgoals):\n 1. on_init blue_dfs_params \\<le>\\<^sub>n\n    SPEC (\\<lambda>x. lasso_inv (empty_state x))\n 2. \\<And>s s' v0.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; lasso_inv s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s = []; v0 \\<in> V0;\n        v0 \\<notin> dom (discovered s); s' = new_root v0 s\\<rbrakk>\n       \\<Longrightarrow> on_new_root blue_dfs_params v0 s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso_inv (s'\\<lparr>state.more := x\\<rparr>))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; lasso_inv s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish blue_dfs_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso_inv (s'\\<lparr>state.more := x\\<rparr>))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; lasso_inv s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso_inv (s'\\<lparr>state.more := x\\<rparr>))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; lasso_inv s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso_inv (s'\\<lparr>state.more := x\\<rparr>))\n 6. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; lasso_inv s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<notin> dom (discovered s);\n        s' =\n        discover u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso_inv (s'\\<lparr>state.more := x\\<rparr>))", "let ?s = \"s'\\<lparr>lasso := Some (?revs, ?cyc), red := red s\\<rparr>\""], ["proof (state)\ngoal (6 subgoals):\n 1. on_init blue_dfs_params \\<le>\\<^sub>n\n    SPEC (\\<lambda>x. lasso_inv (empty_state x))\n 2. \\<And>s s' v0.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; lasso_inv s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s = []; v0 \\<in> V0;\n        v0 \\<notin> dom (discovered s); s' = new_root v0 s\\<rbrakk>\n       \\<Longrightarrow> on_new_root blue_dfs_params v0 s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso_inv (s'\\<lparr>state.more := x\\<rparr>))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; lasso_inv s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish blue_dfs_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso_inv (s'\\<lparr>state.more := x\\<rparr>))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; lasso_inv s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso_inv (s'\\<lparr>state.more := x\\<rparr>))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; lasso_inv s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso_inv (s'\\<lparr>state.more := x\\<rparr>))\n 6. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; lasso_inv s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<notin> dom (discovered s);\n        s' =\n        discover u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso_inv (s'\\<lparr>state.more := x\\<rparr>))", "assume \"DFS_invar G blue_dfs_params ?s\"\n        and vs: \"vs \\<noteq> []\" \"path ?rE (hd (stack s)) vs v\"\n        and v: \"?onstack v\"\n        and accpt: \"accpt (hd (stack s))\""], ["proof (state)\nthis:\n  DFS_invar G blue_dfs_params\n   (s'\\<lparr>lasso :=\n                Some\n                 (rev (tl (stack s)),\n                  vs @ dropWhileNot v (rev (tl (stack s)))),\n         red := red s\\<rparr>)\n  vs \\<noteq> []\n  path (rel_restrict E (red s)) (hd (stack s)) vs v\n  v \\<in> set (stack s)\n  accpt (hd (stack s))\n\ngoal (6 subgoals):\n 1. on_init blue_dfs_params \\<le>\\<^sub>n\n    SPEC (\\<lambda>x. lasso_inv (empty_state x))\n 2. \\<And>s s' v0.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; lasso_inv s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s = []; v0 \\<in> V0;\n        v0 \\<notin> dom (discovered s); s' = new_root v0 s\\<rbrakk>\n       \\<Longrightarrow> on_new_root blue_dfs_params v0 s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso_inv (s'\\<lparr>state.more := x\\<rparr>))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; lasso_inv s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish blue_dfs_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso_inv (s'\\<lparr>state.more := x\\<rparr>))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; lasso_inv s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso_inv (s'\\<lparr>state.more := x\\<rparr>))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; lasso_inv s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso_inv (s'\\<lparr>state.more := x\\<rparr>))\n 6. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; lasso_inv s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<notin> dom (discovered s);\n        s' =\n        discover u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso_inv (s'\\<lparr>state.more := x\\<rparr>))", "from vs"], ["proof (chain)\npicking this:\n  vs \\<noteq> []\n  path (rel_restrict E (red s)) (hd (stack s)) vs v", "have P: \"path E (hd (stack s)) vs v\""], ["proof (prove)\nusing this:\n  vs \\<noteq> []\n  path (rel_restrict E (red s)) (hd (stack s)) vs v\n\ngoal (1 subgoal):\n 1. path E (hd (stack s)) vs v", "by (metis path_mono rel_restrict_sub)"], ["proof (state)\nthis:\n  path E (hd (stack s)) vs v\n\ngoal (6 subgoals):\n 1. on_init blue_dfs_params \\<le>\\<^sub>n\n    SPEC (\\<lambda>x. lasso_inv (empty_state x))\n 2. \\<And>s s' v0.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; lasso_inv s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s = []; v0 \\<in> V0;\n        v0 \\<notin> dom (discovered s); s' = new_root v0 s\\<rbrakk>\n       \\<Longrightarrow> on_new_root blue_dfs_params v0 s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso_inv (s'\\<lparr>state.more := x\\<rparr>))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; lasso_inv s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish blue_dfs_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso_inv (s'\\<lparr>state.more := x\\<rparr>))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; lasso_inv s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso_inv (s'\\<lparr>state.more := x\\<rparr>))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; lasso_inv s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso_inv (s'\\<lparr>state.more := x\\<rparr>))\n 6. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; lasso_inv s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<notin> dom (discovered s);\n        s' =\n        discover u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso_inv (s'\\<lparr>state.more := x\\<rparr>))", "have hds[simp]: \"hd vs = hd (stack s)\" \"hd ?cyc = hd (stack s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hd vs = hd (stack s) &&&\n    hd (vs @ dropWhileNot v (rev (tl (stack s)))) = hd (stack s)", "using vs path_hd"], ["proof (prove)\nusing this:\n  vs \\<noteq> []\n  path (rel_restrict E (red s)) (hd (stack s)) vs v\n  \\<lbrakk>?p \\<noteq> []; path ?E ?v ?p ?w\\<rbrakk>\n  \\<Longrightarrow> hd ?p = ?v\n\ngoal (1 subgoal):\n 1. hd vs = hd (stack s) &&&\n    hd (vs @ dropWhileNot v (rev (tl (stack s)))) = hd (stack s)", "by simp_all"], ["proof (state)\nthis:\n  hd vs = hd (stack s)\n  hd (vs @ dropWhileNot v (rev (tl (stack s)))) = hd (stack s)\n\ngoal (6 subgoals):\n 1. on_init blue_dfs_params \\<le>\\<^sub>n\n    SPEC (\\<lambda>x. lasso_inv (empty_state x))\n 2. \\<And>s s' v0.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; lasso_inv s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s = []; v0 \\<in> V0;\n        v0 \\<notin> dom (discovered s); s' = new_root v0 s\\<rbrakk>\n       \\<Longrightarrow> on_new_root blue_dfs_params v0 s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso_inv (s'\\<lparr>state.more := x\\<rparr>))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; lasso_inv s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish blue_dfs_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso_inv (s'\\<lparr>state.more := x\\<rparr>))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; lasso_inv s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso_inv (s'\\<lparr>state.more := x\\<rparr>))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; lasso_inv s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso_inv (s'\\<lparr>state.more := x\\<rparr>))\n 6. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; lasso_inv s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<notin> dom (discovered s);\n        s' =\n        discover u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso_inv (s'\\<lparr>state.more := x\\<rparr>))", "from vs"], ["proof (chain)\npicking this:\n  vs \\<noteq> []\n  path (rel_restrict E (red s)) (hd (stack s)) vs v", "have \"?cyc \\<noteq> []\""], ["proof (prove)\nusing this:\n  vs \\<noteq> []\n  path (rel_restrict E (red s)) (hd (stack s)) vs v\n\ngoal (1 subgoal):\n 1. vs @ dropWhileNot v (rev (tl (stack s))) \\<noteq> []", "by simp"], ["proof (state)\nthis:\n  vs @ dropWhileNot v (rev (tl (stack s))) \\<noteq> []\n\ngoal (6 subgoals):\n 1. on_init blue_dfs_params \\<le>\\<^sub>n\n    SPEC (\\<lambda>x. lasso_inv (empty_state x))\n 2. \\<And>s s' v0.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; lasso_inv s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s = []; v0 \\<in> V0;\n        v0 \\<notin> dom (discovered s); s' = new_root v0 s\\<rbrakk>\n       \\<Longrightarrow> on_new_root blue_dfs_params v0 s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso_inv (s'\\<lparr>state.more := x\\<rparr>))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; lasso_inv s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish blue_dfs_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso_inv (s'\\<lparr>state.more := x\\<rparr>))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; lasso_inv s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso_inv (s'\\<lparr>state.more := x\\<rparr>))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; lasso_inv s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso_inv (s'\\<lparr>state.more := x\\<rparr>))\n 6. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; lasso_inv s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<notin> dom (discovered s);\n        s' =\n        discover u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso_inv (s'\\<lparr>state.more := x\\<rparr>))", "moreover"], ["proof (state)\nthis:\n  vs @ dropWhileNot v (rev (tl (stack s))) \\<noteq> []\n\ngoal (6 subgoals):\n 1. on_init blue_dfs_params \\<le>\\<^sub>n\n    SPEC (\\<lambda>x. lasso_inv (empty_state x))\n 2. \\<And>s s' v0.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; lasso_inv s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s = []; v0 \\<in> V0;\n        v0 \\<notin> dom (discovered s); s' = new_root v0 s\\<rbrakk>\n       \\<Longrightarrow> on_new_root blue_dfs_params v0 s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso_inv (s'\\<lparr>state.more := x\\<rparr>))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; lasso_inv s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish blue_dfs_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso_inv (s'\\<lparr>state.more := x\\<rparr>))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; lasso_inv s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso_inv (s'\\<lparr>state.more := x\\<rparr>))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; lasso_inv s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso_inv (s'\\<lparr>state.more := x\\<rparr>))\n 6. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; lasso_inv s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<notin> dom (discovered s);\n        s' =\n        discover u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso_inv (s'\\<lparr>state.more := x\\<rparr>))", "have P0: \"\\<exists>v0\\<in>V0. path E v0 ?revs (hd ?cyc)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>v0\\<in>V0.\n       path E v0 (rev (tl (stack s)))\n        (hd (vs @ dropWhileNot v (rev (tl (stack s)))))", "using stack_is_path[OF ne]"], ["proof (prove)\nusing this:\n  \\<exists>v0\\<in>V0. path E v0 (rev (tl (stack s))) (hd (stack s))\n\ngoal (1 subgoal):\n 1. \\<exists>v0\\<in>V0.\n       path E v0 (rev (tl (stack s)))\n        (hd (vs @ dropWhileNot v (rev (tl (stack s)))))", "by auto"], ["proof (state)\nthis:\n  \\<exists>v0\\<in>V0.\n     path E v0 (rev (tl (stack s)))\n      (hd (vs @ dropWhileNot v (rev (tl (stack s)))))\n\ngoal (6 subgoals):\n 1. on_init blue_dfs_params \\<le>\\<^sub>n\n    SPEC (\\<lambda>x. lasso_inv (empty_state x))\n 2. \\<And>s s' v0.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; lasso_inv s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s = []; v0 \\<in> V0;\n        v0 \\<notin> dom (discovered s); s' = new_root v0 s\\<rbrakk>\n       \\<Longrightarrow> on_new_root blue_dfs_params v0 s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso_inv (s'\\<lparr>state.more := x\\<rparr>))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; lasso_inv s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish blue_dfs_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso_inv (s'\\<lparr>state.more := x\\<rparr>))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; lasso_inv s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso_inv (s'\\<lparr>state.more := x\\<rparr>))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; lasso_inv s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso_inv (s'\\<lparr>state.more := x\\<rparr>))\n 6. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; lasso_inv s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<notin> dom (discovered s);\n        s' =\n        discover u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso_inv (s'\\<lparr>state.more := x\\<rparr>))", "moreover"], ["proof (state)\nthis:\n  \\<exists>v0\\<in>V0.\n     path E v0 (rev (tl (stack s)))\n      (hd (vs @ dropWhileNot v (rev (tl (stack s)))))\n\ngoal (6 subgoals):\n 1. on_init blue_dfs_params \\<le>\\<^sub>n\n    SPEC (\\<lambda>x. lasso_inv (empty_state x))\n 2. \\<And>s s' v0.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; lasso_inv s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s = []; v0 \\<in> V0;\n        v0 \\<notin> dom (discovered s); s' = new_root v0 s\\<rbrakk>\n       \\<Longrightarrow> on_new_root blue_dfs_params v0 s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso_inv (s'\\<lparr>state.more := x\\<rparr>))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; lasso_inv s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish blue_dfs_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso_inv (s'\\<lparr>state.more := x\\<rparr>))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; lasso_inv s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso_inv (s'\\<lparr>state.more := x\\<rparr>))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; lasso_inv s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso_inv (s'\\<lparr>state.more := x\\<rparr>))\n 6. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; lasso_inv s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<notin> dom (discovered s);\n        s' =\n        discover u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso_inv (s'\\<lparr>state.more := x\\<rparr>))", "from accpt"], ["proof (chain)\npicking this:\n  accpt (hd (stack s))", "have \"accpt (hd ?cyc)\""], ["proof (prove)\nusing this:\n  accpt (hd (stack s))\n\ngoal (1 subgoal):\n 1. accpt (hd (vs @ dropWhileNot v (rev (tl (stack s)))))", "by simp"], ["proof (state)\nthis:\n  accpt (hd (vs @ dropWhileNot v (rev (tl (stack s)))))\n\ngoal (6 subgoals):\n 1. on_init blue_dfs_params \\<le>\\<^sub>n\n    SPEC (\\<lambda>x. lasso_inv (empty_state x))\n 2. \\<And>s s' v0.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; lasso_inv s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s = []; v0 \\<in> V0;\n        v0 \\<notin> dom (discovered s); s' = new_root v0 s\\<rbrakk>\n       \\<Longrightarrow> on_new_root blue_dfs_params v0 s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso_inv (s'\\<lparr>state.more := x\\<rparr>))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; lasso_inv s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish blue_dfs_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso_inv (s'\\<lparr>state.more := x\\<rparr>))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; lasso_inv s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso_inv (s'\\<lparr>state.more := x\\<rparr>))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; lasso_inv s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso_inv (s'\\<lparr>state.more := x\\<rparr>))\n 6. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; lasso_inv s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<notin> dom (discovered s);\n        s' =\n        discover u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso_inv (s'\\<lparr>state.more := x\\<rparr>))", "moreover"], ["proof (state)\nthis:\n  accpt (hd (vs @ dropWhileNot v (rev (tl (stack s)))))\n\ngoal (6 subgoals):\n 1. on_init blue_dfs_params \\<le>\\<^sub>n\n    SPEC (\\<lambda>x. lasso_inv (empty_state x))\n 2. \\<And>s s' v0.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; lasso_inv s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s = []; v0 \\<in> V0;\n        v0 \\<notin> dom (discovered s); s' = new_root v0 s\\<rbrakk>\n       \\<Longrightarrow> on_new_root blue_dfs_params v0 s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso_inv (s'\\<lparr>state.more := x\\<rparr>))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; lasso_inv s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish blue_dfs_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso_inv (s'\\<lparr>state.more := x\\<rparr>))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; lasso_inv s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso_inv (s'\\<lparr>state.more := x\\<rparr>))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; lasso_inv s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso_inv (s'\\<lparr>state.more := x\\<rparr>))\n 6. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; lasso_inv s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<notin> dom (discovered s);\n        s' =\n        discover u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso_inv (s'\\<lparr>state.more := x\\<rparr>))", "have \"path E (hd ?cyc) ?cyc (hd ?cyc)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path E (hd (vs @ dropWhileNot v (rev (tl (stack s)))))\n     (vs @ dropWhileNot v (rev (tl (stack s))))\n     (hd (vs @ dropWhileNot v (rev (tl (stack s)))))", "proof (cases \"tl (stack s) = []\")"], ["proof (state)\ngoal (2 subgoals):\n 1. tl (stack s) = [] \\<Longrightarrow>\n    path E (hd (vs @ dropWhileNot v (rev (tl (stack s)))))\n     (vs @ dropWhileNot v (rev (tl (stack s))))\n     (hd (vs @ dropWhileNot v (rev (tl (stack s)))))\n 2. tl (stack s) \\<noteq> [] \\<Longrightarrow>\n    path E (hd (vs @ dropWhileNot v (rev (tl (stack s)))))\n     (vs @ dropWhileNot v (rev (tl (stack s))))\n     (hd (vs @ dropWhileNot v (rev (tl (stack s)))))", "case True"], ["proof (state)\nthis:\n  tl (stack s) = []\n\ngoal (2 subgoals):\n 1. tl (stack s) = [] \\<Longrightarrow>\n    path E (hd (vs @ dropWhileNot v (rev (tl (stack s)))))\n     (vs @ dropWhileNot v (rev (tl (stack s))))\n     (hd (vs @ dropWhileNot v (rev (tl (stack s)))))\n 2. tl (stack s) \\<noteq> [] \\<Longrightarrow>\n    path E (hd (vs @ dropWhileNot v (rev (tl (stack s)))))\n     (vs @ dropWhileNot v (rev (tl (stack s))))\n     (hd (vs @ dropWhileNot v (rev (tl (stack s)))))", "with ne last_stack_in_V0"], ["proof (chain)\npicking this:\n  stack s \\<noteq> []\n  stack s \\<noteq> [] \\<Longrightarrow> last (stack s) \\<in> V0\n  tl (stack s) = []", "obtain v0 where \"v0 \\<in> V0\"\n          and [simp]: \"stack s = [v0]\""], ["proof (prove)\nusing this:\n  stack s \\<noteq> []\n  stack s \\<noteq> [] \\<Longrightarrow> last (stack s) \\<in> V0\n  tl (stack s) = []\n\ngoal (1 subgoal):\n 1. (\\<And>v0.\n        \\<lbrakk>v0 \\<in> V0; stack s = [v0]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: neq_Nil_conv)"], ["proof (state)\nthis:\n  v0 \\<in> V0\n  stack s = [v0]\n\ngoal (2 subgoals):\n 1. tl (stack s) = [] \\<Longrightarrow>\n    path E (hd (vs @ dropWhileNot v (rev (tl (stack s)))))\n     (vs @ dropWhileNot v (rev (tl (stack s))))\n     (hd (vs @ dropWhileNot v (rev (tl (stack s)))))\n 2. tl (stack s) \\<noteq> [] \\<Longrightarrow>\n    path E (hd (vs @ dropWhileNot v (rev (tl (stack s)))))\n     (vs @ dropWhileNot v (rev (tl (stack s))))\n     (hd (vs @ dropWhileNot v (rev (tl (stack s)))))", "with v True finish"], ["proof (chain)\npicking this:\n  v \\<in> set (stack s)\n  tl (stack s) = []\n  DFS_invar G blue_dfs_params s\n  lasso_inv s\n  cond s\n  \\<not> is_break blue_dfs_params s\n  stack s \\<noteq> []\n  u = hd (stack s)\n  pending s `` {u} = {}\n  s' = finish u s\n  v0 \\<in> V0\n  stack s = [v0]", "have [simp]: \"v = v0\""], ["proof (prove)\nusing this:\n  v \\<in> set (stack s)\n  tl (stack s) = []\n  DFS_invar G blue_dfs_params s\n  lasso_inv s\n  cond s\n  \\<not> is_break blue_dfs_params s\n  stack s \\<noteq> []\n  u = hd (stack s)\n  pending s `` {u} = {}\n  s' = finish u s\n  v0 \\<in> V0\n  stack s = [v0]\n\ngoal (1 subgoal):\n 1. v = v0", "by simp"], ["proof (state)\nthis:\n  v = v0\n\ngoal (2 subgoals):\n 1. tl (stack s) = [] \\<Longrightarrow>\n    path E (hd (vs @ dropWhileNot v (rev (tl (stack s)))))\n     (vs @ dropWhileNot v (rev (tl (stack s))))\n     (hd (vs @ dropWhileNot v (rev (tl (stack s)))))\n 2. tl (stack s) \\<noteq> [] \\<Longrightarrow>\n    path E (hd (vs @ dropWhileNot v (rev (tl (stack s)))))\n     (vs @ dropWhileNot v (rev (tl (stack s))))\n     (hd (vs @ dropWhileNot v (rev (tl (stack s)))))", "from True P"], ["proof (chain)\npicking this:\n  tl (stack s) = []\n  path E (hd (stack s)) vs v", "show ?thesis"], ["proof (prove)\nusing this:\n  tl (stack s) = []\n  path E (hd (stack s)) vs v\n\ngoal (1 subgoal):\n 1. path E (hd (vs @ dropWhileNot v (rev (tl (stack s)))))\n     (vs @ dropWhileNot v (rev (tl (stack s))))\n     (hd (vs @ dropWhileNot v (rev (tl (stack s)))))", "by simp"], ["proof (state)\nthis:\n  path E (hd (vs @ dropWhileNot v (rev (tl (stack s)))))\n   (vs @ dropWhileNot v (rev (tl (stack s))))\n   (hd (vs @ dropWhileNot v (rev (tl (stack s)))))\n\ngoal (1 subgoal):\n 1. tl (stack s) \\<noteq> [] \\<Longrightarrow>\n    path E (hd (vs @ dropWhileNot v (rev (tl (stack s)))))\n     (vs @ dropWhileNot v (rev (tl (stack s))))\n     (hd (vs @ dropWhileNot v (rev (tl (stack s)))))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. tl (stack s) \\<noteq> [] \\<Longrightarrow>\n    path E (hd (vs @ dropWhileNot v (rev (tl (stack s)))))\n     (vs @ dropWhileNot v (rev (tl (stack s))))\n     (hd (vs @ dropWhileNot v (rev (tl (stack s)))))", "case False"], ["proof (state)\nthis:\n  tl (stack s) \\<noteq> []\n\ngoal (1 subgoal):\n 1. tl (stack s) \\<noteq> [] \\<Longrightarrow>\n    path E (hd (vs @ dropWhileNot v (rev (tl (stack s)))))\n     (vs @ dropWhileNot v (rev (tl (stack s))))\n     (hd (vs @ dropWhileNot v (rev (tl (stack s)))))", "note tl_ne = this"], ["proof (state)\nthis:\n  tl (stack s) \\<noteq> []\n\ngoal (1 subgoal):\n 1. tl (stack s) \\<noteq> [] \\<Longrightarrow>\n    path E (hd (vs @ dropWhileNot v (rev (tl (stack s)))))\n     (vs @ dropWhileNot v (rev (tl (stack s))))\n     (hd (vs @ dropWhileNot v (rev (tl (stack s)))))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. path E (hd (vs @ dropWhileNot v (rev (tl (stack s)))))\n     (vs @ dropWhileNot v (rev (tl (stack s))))\n     (hd (vs @ dropWhileNot v (rev (tl (stack s)))))", "proof (cases \"v = hd (stack s)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. v = hd (stack s) \\<Longrightarrow>\n    path E (hd (vs @ dropWhileNot v (rev (tl (stack s)))))\n     (vs @ dropWhileNot v (rev (tl (stack s))))\n     (hd (vs @ dropWhileNot v (rev (tl (stack s)))))\n 2. v \\<noteq> hd (stack s) \\<Longrightarrow>\n    path E (hd (vs @ dropWhileNot v (rev (tl (stack s)))))\n     (vs @ dropWhileNot v (rev (tl (stack s))))\n     (hd (vs @ dropWhileNot v (rev (tl (stack s)))))", "case True"], ["proof (state)\nthis:\n  v = hd (stack s)\n\ngoal (2 subgoals):\n 1. v = hd (stack s) \\<Longrightarrow>\n    path E (hd (vs @ dropWhileNot v (rev (tl (stack s)))))\n     (vs @ dropWhileNot v (rev (tl (stack s))))\n     (hd (vs @ dropWhileNot v (rev (tl (stack s)))))\n 2. v \\<noteq> hd (stack s) \\<Longrightarrow>\n    path E (hd (vs @ dropWhileNot v (rev (tl (stack s)))))\n     (vs @ dropWhileNot v (rev (tl (stack s))))\n     (hd (vs @ dropWhileNot v (rev (tl (stack s)))))", "hence \"v \\<notin> set ?revs\""], ["proof (prove)\nusing this:\n  v = hd (stack s)\n\ngoal (1 subgoal):\n 1. v \\<notin> set (rev (tl (stack s)))", "using ne stack_distinct"], ["proof (prove)\nusing this:\n  v = hd (stack s)\n  stack s \\<noteq> []\n  distinct (stack s)\n\ngoal (1 subgoal):\n 1. v \\<notin> set (rev (tl (stack s)))", "by (auto simp: neq_Nil_conv)"], ["proof (state)\nthis:\n  v \\<notin> set (rev (tl (stack s)))\n\ngoal (2 subgoals):\n 1. v = hd (stack s) \\<Longrightarrow>\n    path E (hd (vs @ dropWhileNot v (rev (tl (stack s)))))\n     (vs @ dropWhileNot v (rev (tl (stack s))))\n     (hd (vs @ dropWhileNot v (rev (tl (stack s)))))\n 2. v \\<noteq> hd (stack s) \\<Longrightarrow>\n    path E (hd (vs @ dropWhileNot v (rev (tl (stack s)))))\n     (vs @ dropWhileNot v (rev (tl (stack s))))\n     (hd (vs @ dropWhileNot v (rev (tl (stack s)))))", "hence \"?cyc = vs\""], ["proof (prove)\nusing this:\n  v \\<notin> set (rev (tl (stack s)))\n\ngoal (1 subgoal):\n 1. vs @ dropWhileNot v (rev (tl (stack s))) = vs", "by fastforce"], ["proof (state)\nthis:\n  vs @ dropWhileNot v (rev (tl (stack s))) = vs\n\ngoal (2 subgoals):\n 1. v = hd (stack s) \\<Longrightarrow>\n    path E (hd (vs @ dropWhileNot v (rev (tl (stack s)))))\n     (vs @ dropWhileNot v (rev (tl (stack s))))\n     (hd (vs @ dropWhileNot v (rev (tl (stack s)))))\n 2. v \\<noteq> hd (stack s) \\<Longrightarrow>\n    path E (hd (vs @ dropWhileNot v (rev (tl (stack s)))))\n     (vs @ dropWhileNot v (rev (tl (stack s))))\n     (hd (vs @ dropWhileNot v (rev (tl (stack s)))))", "with P True"], ["proof (chain)\npicking this:\n  path E (hd (stack s)) vs v\n  v = hd (stack s)\n  vs @ dropWhileNot v (rev (tl (stack s))) = vs", "show ?thesis"], ["proof (prove)\nusing this:\n  path E (hd (stack s)) vs v\n  v = hd (stack s)\n  vs @ dropWhileNot v (rev (tl (stack s))) = vs\n\ngoal (1 subgoal):\n 1. path E (hd (vs @ dropWhileNot v (rev (tl (stack s)))))\n     (vs @ dropWhileNot v (rev (tl (stack s))))\n     (hd (vs @ dropWhileNot v (rev (tl (stack s)))))", "by (simp del: dropWhile_eq_Nil_conv)"], ["proof (state)\nthis:\n  path E (hd (vs @ dropWhileNot v (rev (tl (stack s)))))\n   (vs @ dropWhileNot v (rev (tl (stack s))))\n   (hd (vs @ dropWhileNot v (rev (tl (stack s)))))\n\ngoal (1 subgoal):\n 1. v \\<noteq> hd (stack s) \\<Longrightarrow>\n    path E (hd (vs @ dropWhileNot v (rev (tl (stack s)))))\n     (vs @ dropWhileNot v (rev (tl (stack s))))\n     (hd (vs @ dropWhileNot v (rev (tl (stack s)))))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. v \\<noteq> hd (stack s) \\<Longrightarrow>\n    path E (hd (vs @ dropWhileNot v (rev (tl (stack s)))))\n     (vs @ dropWhileNot v (rev (tl (stack s))))\n     (hd (vs @ dropWhileNot v (rev (tl (stack s)))))", "case False"], ["proof (state)\nthis:\n  v \\<noteq> hd (stack s)\n\ngoal (1 subgoal):\n 1. v \\<noteq> hd (stack s) \\<Longrightarrow>\n    path E (hd (vs @ dropWhileNot v (rev (tl (stack s)))))\n     (vs @ dropWhileNot v (rev (tl (stack s))))\n     (hd (vs @ dropWhileNot v (rev (tl (stack s)))))", "with finish v"], ["proof (chain)\npicking this:\n  DFS_invar G blue_dfs_params s\n  lasso_inv s\n  cond s\n  \\<not> is_break blue_dfs_params s\n  stack s \\<noteq> []\n  u = hd (stack s)\n  pending s `` {u} = {}\n  s' = finish u s\n  v \\<in> set (stack s)\n  v \\<noteq> hd (stack s)", "have \"v \\<in> set ?revs\""], ["proof (prove)\nusing this:\n  DFS_invar G blue_dfs_params s\n  lasso_inv s\n  cond s\n  \\<not> is_break blue_dfs_params s\n  stack s \\<noteq> []\n  u = hd (stack s)\n  pending s `` {u} = {}\n  s' = finish u s\n  v \\<in> set (stack s)\n  v \\<noteq> hd (stack s)\n\ngoal (1 subgoal):\n 1. v \\<in> set (rev (tl (stack s)))", "by (auto simp: neq_Nil_conv)"], ["proof (state)\nthis:\n  v \\<in> set (rev (tl (stack s)))\n\ngoal (1 subgoal):\n 1. v \\<noteq> hd (stack s) \\<Longrightarrow>\n    path E (hd (vs @ dropWhileNot v (rev (tl (stack s)))))\n     (vs @ dropWhileNot v (rev (tl (stack s))))\n     (hd (vs @ dropWhileNot v (rev (tl (stack s)))))", "with tl_ne False P0"], ["proof (chain)\npicking this:\n  tl (stack s) \\<noteq> []\n  v \\<noteq> hd (stack s)\n  \\<exists>v0\\<in>V0.\n     path E v0 (rev (tl (stack s)))\n      (hd (vs @ dropWhileNot v (rev (tl (stack s)))))\n  v \\<in> set (rev (tl (stack s)))", "show ?thesis"], ["proof (prove)\nusing this:\n  tl (stack s) \\<noteq> []\n  v \\<noteq> hd (stack s)\n  \\<exists>v0\\<in>V0.\n     path E v0 (rev (tl (stack s)))\n      (hd (vs @ dropWhileNot v (rev (tl (stack s)))))\n  v \\<in> set (rev (tl (stack s)))\n\ngoal (1 subgoal):\n 1. path E (hd (vs @ dropWhileNot v (rev (tl (stack s)))))\n     (vs @ dropWhileNot v (rev (tl (stack s))))\n     (hd (vs @ dropWhileNot v (rev (tl (stack s)))))", "by (force intro: path_conc[OF P] \n                dropWhileNot_path[where p=\"?revs\"])"], ["proof (state)\nthis:\n  path E (hd (vs @ dropWhileNot v (rev (tl (stack s)))))\n   (vs @ dropWhileNot v (rev (tl (stack s))))\n   (hd (vs @ dropWhileNot v (rev (tl (stack s)))))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  path E (hd (vs @ dropWhileNot v (rev (tl (stack s)))))\n   (vs @ dropWhileNot v (rev (tl (stack s))))\n   (hd (vs @ dropWhileNot v (rev (tl (stack s)))))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  path E (hd (vs @ dropWhileNot v (rev (tl (stack s)))))\n   (vs @ dropWhileNot v (rev (tl (stack s))))\n   (hd (vs @ dropWhileNot v (rev (tl (stack s)))))\n\ngoal (6 subgoals):\n 1. on_init blue_dfs_params \\<le>\\<^sub>n\n    SPEC (\\<lambda>x. lasso_inv (empty_state x))\n 2. \\<And>s s' v0.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; lasso_inv s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s = []; v0 \\<in> V0;\n        v0 \\<notin> dom (discovered s); s' = new_root v0 s\\<rbrakk>\n       \\<Longrightarrow> on_new_root blue_dfs_params v0 s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso_inv (s'\\<lparr>state.more := x\\<rparr>))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; lasso_inv s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish blue_dfs_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso_inv (s'\\<lparr>state.more := x\\<rparr>))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; lasso_inv s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso_inv (s'\\<lparr>state.more := x\\<rparr>))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; lasso_inv s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso_inv (s'\\<lparr>state.more := x\\<rparr>))\n 6. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; lasso_inv s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<notin> dom (discovered s);\n        s' =\n        discover u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso_inv (s'\\<lparr>state.more := x\\<rparr>))", "ultimately"], ["proof (chain)\npicking this:\n  vs @ dropWhileNot v (rev (tl (stack s))) \\<noteq> []\n  \\<exists>v0\\<in>V0.\n     path E v0 (rev (tl (stack s)))\n      (hd (vs @ dropWhileNot v (rev (tl (stack s)))))\n  accpt (hd (vs @ dropWhileNot v (rev (tl (stack s)))))\n  path E (hd (vs @ dropWhileNot v (rev (tl (stack s)))))\n   (vs @ dropWhileNot v (rev (tl (stack s))))\n   (hd (vs @ dropWhileNot v (rev (tl (stack s)))))", "have \"lasso_inv ?s\""], ["proof (prove)\nusing this:\n  vs @ dropWhileNot v (rev (tl (stack s))) \\<noteq> []\n  \\<exists>v0\\<in>V0.\n     path E v0 (rev (tl (stack s)))\n      (hd (vs @ dropWhileNot v (rev (tl (stack s)))))\n  accpt (hd (vs @ dropWhileNot v (rev (tl (stack s)))))\n  path E (hd (vs @ dropWhileNot v (rev (tl (stack s)))))\n   (vs @ dropWhileNot v (rev (tl (stack s))))\n   (hd (vs @ dropWhileNot v (rev (tl (stack s)))))\n\ngoal (1 subgoal):\n 1. lasso_inv\n     (s'\\<lparr>lasso :=\n                  Some\n                   (rev (tl (stack s)),\n                    vs @ dropWhileNot v (rev (tl (stack s)))),\n           red := red s\\<rparr>)", "by (simp add: lasso_inv_def)"], ["proof (state)\nthis:\n  lasso_inv\n   (s'\\<lparr>lasso :=\n                Some\n                 (rev (tl (stack s)),\n                  vs @ dropWhileNot v (rev (tl (stack s)))),\n         red := red s\\<rparr>)\n\ngoal (6 subgoals):\n 1. on_init blue_dfs_params \\<le>\\<^sub>n\n    SPEC (\\<lambda>x. lasso_inv (empty_state x))\n 2. \\<And>s s' v0.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; lasso_inv s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s = []; v0 \\<in> V0;\n        v0 \\<notin> dom (discovered s); s' = new_root v0 s\\<rbrakk>\n       \\<Longrightarrow> on_new_root blue_dfs_params v0 s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso_inv (s'\\<lparr>state.more := x\\<rparr>))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; lasso_inv s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish blue_dfs_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso_inv (s'\\<lparr>state.more := x\\<rparr>))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; lasso_inv s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso_inv (s'\\<lparr>state.more := x\\<rparr>))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; lasso_inv s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso_inv (s'\\<lparr>state.more := x\\<rparr>))\n 6. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; lasso_inv s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<notin> dom (discovered s);\n        s' =\n        discover u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso_inv (s'\\<lparr>state.more := x\\<rparr>))", "}"], ["proof (state)\nthis:\n  \\<lbrakk>DFS_invar G blue_dfs_params\n            (s'\\<lparr>lasso :=\n                         Some\n                          (rev (tl (stack s)),\n                           ?vs11 @ dropWhileNot ?v11 (rev (tl (stack s)))),\n                  red := red s\\<rparr>);\n   ?vs11 \\<noteq> [];\n   path (rel_restrict E (red s)) (hd (stack s)) ?vs11 ?v11;\n   ?v11 \\<in> set (stack s); accpt (hd (stack s))\\<rbrakk>\n  \\<Longrightarrow> lasso_inv\n                     (s'\\<lparr>lasso :=\n                                  Some\n                                   (rev (tl (stack s)),\n                                    ?vs11 @\n                                    dropWhileNot ?v11 (rev (tl (stack s)))),\n                           red := red s\\<rparr>)\n\ngoal (6 subgoals):\n 1. on_init blue_dfs_params \\<le>\\<^sub>n\n    SPEC (\\<lambda>x. lasso_inv (empty_state x))\n 2. \\<And>s s' v0.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; lasso_inv s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s = []; v0 \\<in> V0;\n        v0 \\<notin> dom (discovered s); s' = new_root v0 s\\<rbrakk>\n       \\<Longrightarrow> on_new_root blue_dfs_params v0 s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso_inv (s'\\<lparr>state.more := x\\<rparr>))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; lasso_inv s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish blue_dfs_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso_inv (s'\\<lparr>state.more := x\\<rparr>))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; lasso_inv s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso_inv (s'\\<lparr>state.more := x\\<rparr>))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; lasso_inv s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso_inv (s'\\<lparr>state.more := x\\<rparr>))\n 6. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; lasso_inv s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<notin> dom (discovered s);\n        s' =\n        discover u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso_inv (s'\\<lparr>state.more := x\\<rparr>))", "hence \"accpt (hd (stack s)) \\<longrightarrow> lasso s = None \\<longrightarrow>\n            red_dfs (red s) ?onstack (hd (stack s)) \\<le> SPEC (\\<lambda>rs. \\<forall>vs v. \n                rs = Inr (vs,v) \\<longrightarrow>\n                  DFS_invar G blue_dfs_params (s'\\<lparr>lasso := Some (?revs, vs @ dropWhileNot v ?revs), red:= red s\\<rparr>) \\<longrightarrow>\n                   lasso_inv (s'\\<lparr>lasso := Some (?revs, vs @ dropWhileNot v ?revs), red:=red s\\<rparr>))\""], ["proof (prove)\nusing this:\n  \\<lbrakk>DFS_invar G blue_dfs_params\n            (s'\\<lparr>lasso :=\n                         Some\n                          (rev (tl (stack s)),\n                           ?vs11 @ dropWhileNot ?v11 (rev (tl (stack s)))),\n                  red := red s\\<rparr>);\n   ?vs11 \\<noteq> [];\n   path (rel_restrict E (red s)) (hd (stack s)) ?vs11 ?v11;\n   ?v11 \\<in> set (stack s); accpt (hd (stack s))\\<rbrakk>\n  \\<Longrightarrow> lasso_inv\n                     (s'\\<lparr>lasso :=\n                                  Some\n                                   (rev (tl (stack s)),\n                                    ?vs11 @\n                                    dropWhileNot ?v11 (rev (tl (stack s)))),\n                           red := red s\\<rparr>)\n\ngoal (1 subgoal):\n 1. accpt (hd (stack s)) \\<longrightarrow>\n    lasso s = None \\<longrightarrow>\n    red_dfs (red s) (\\<lambda>x. x \\<in> set (stack s)) (hd (stack s))\n    \\<le> SPEC\n           (\\<lambda>rs.\n               \\<forall>vs v.\n                  rs = Inr (vs, v) \\<longrightarrow>\n                  DFS_invar G blue_dfs_params\n                   (s'\\<lparr>lasso :=\n                                Some\n                                 (rev (tl (stack s)),\n                                  vs @ dropWhileNot v (rev (tl (stack s)))),\n                         red := red s\\<rparr>) \\<longrightarrow>\n                  lasso_inv\n                   (s'\\<lparr>lasso :=\n                                Some\n                                 (rev (tl (stack s)),\n                                  vs @ dropWhileNot v (rev (tl (stack s)))),\n                         red := red s\\<rparr>))", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>vs v.\n                \\<lbrakk>BlueDFS_invar G accpt\n                          (s'\\<lparr>lasso :=\n Some (rev (tl (stack s)), vs @ dropWhileNot v (rev (tl (stack s)))),\n                                red := red s\\<rparr>);\n                 vs \\<noteq> [];\n                 path (rel_restrict E (red s)) (hd (stack s)) vs v;\n                 v \\<in> set (stack s)\\<rbrakk>\n                \\<Longrightarrow> lasso_inv\n                                   (s'\\<lparr>lasso :=\n          Some\n           (rev (tl (stack s)), vs @ dropWhileNot v (rev (tl (stack s)))),\n   red := red s\\<rparr>);\n     accpt (hd (stack s)); lasso s = None\\<rbrakk>\n    \\<Longrightarrow> red_dfs (red s) (\\<lambda>x. x \\<in> set (stack s))\n                       (hd (stack s))\n                      \\<le> SPEC\n                             (\\<lambda>rs.\n                                 \\<forall>vs v.\n                                    rs = Inr (vs, v) \\<longrightarrow>\n                                    BlueDFS_invar G accpt\n                                     (s'\n\\<lparr>lasso :=\n          Some\n           (rev (tl (stack s)), vs @ dropWhileNot v (rev (tl (stack s)))),\n   red := red s\\<rparr>) \\<longrightarrow>\n                                    lasso_inv\n                                     (s'\n\\<lparr>lasso :=\n          Some\n           (rev (tl (stack s)), vs @ dropWhileNot v (rev (tl (stack s)))),\n   red := red s\\<rparr>))", "apply (rule find_path1_restr_spec_rule, intro conjI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<And>vs v.\n                \\<lbrakk>BlueDFS_invar G accpt\n                          (s'\\<lparr>lasso :=\n Some (rev (tl (stack s)), vs @ dropWhileNot v (rev (tl (stack s)))),\n                                red := red s\\<rparr>);\n                 vs \\<noteq> [];\n                 path (rel_restrict E (red s)) (hd (stack s)) vs v;\n                 v \\<in> set (stack s)\\<rbrakk>\n                \\<Longrightarrow> lasso_inv\n                                   (s'\\<lparr>lasso :=\n          Some\n           (rev (tl (stack s)), vs @ dropWhileNot v (rev (tl (stack s)))),\n   red := red s\\<rparr>);\n     accpt (hd (stack s)); lasso s = None\\<rbrakk>\n    \\<Longrightarrow> fb_graph (G\\<lparr>g_V0 := {hd (stack s)}\\<rparr>)\n 2. \\<lbrakk>\\<And>vs v.\n                \\<lbrakk>BlueDFS_invar G accpt\n                          (s'\\<lparr>lasso :=\n Some (rev (tl (stack s)), vs @ dropWhileNot v (rev (tl (stack s)))),\n                                red := red s\\<rparr>);\n                 vs \\<noteq> [];\n                 path (rel_restrict E (red s)) (hd (stack s)) vs v;\n                 v \\<in> set (stack s)\\<rbrakk>\n                \\<Longrightarrow> lasso_inv\n                                   (s'\\<lparr>lasso :=\n          Some\n           (rev (tl (stack s)), vs @ dropWhileNot v (rev (tl (stack s)))),\n   red := red s\\<rparr>);\n     accpt (hd (stack s)); lasso s = None\\<rbrakk>\n    \\<Longrightarrow> restr_invar\n                       (g_E (G\\<lparr>g_V0 := {hd (stack s)}\\<rparr>))\n                       (red s) (\\<lambda>x. x \\<in> set (stack s))\n 3. \\<lbrakk>\\<And>vs v.\n                \\<lbrakk>BlueDFS_invar G accpt\n                          (s'\\<lparr>lasso :=\n Some (rev (tl (stack s)), vs @ dropWhileNot v (rev (tl (stack s)))),\n                                red := red s\\<rparr>);\n                 vs \\<noteq> [];\n                 path (rel_restrict E (red s)) (hd (stack s)) vs v;\n                 v \\<in> set (stack s)\\<rbrakk>\n                \\<Longrightarrow> lasso_inv\n                                   (s'\\<lparr>lasso :=\n          Some\n           (rev (tl (stack s)), vs @ dropWhileNot v (rev (tl (stack s)))),\n   red := red s\\<rparr>);\n     accpt (hd (stack s)); lasso s = None;\n     fb_graph (G\\<lparr>g_V0 := {hd (stack s)}\\<rparr>) \\<and>\n     restr_invar (g_E (G\\<lparr>g_V0 := {hd (stack s)}\\<rparr>)) (red s)\n      (\\<lambda>x. x \\<in> set (stack s))\\<rbrakk>\n    \\<Longrightarrow> SPEC\n                       (find_path1_restr_pred\n                         (G\\<lparr>g_V0 := {hd (stack s)}\\<rparr>)\n                         (\\<lambda>x. x \\<in> set (stack s)) (red s))\n                      \\<le> SPEC\n                             (\\<lambda>rs.\n                                 \\<forall>vs v.\n                                    rs = Inr (vs, v) \\<longrightarrow>\n                                    BlueDFS_invar G accpt\n                                     (s'\n\\<lparr>lasso :=\n          Some\n           (rev (tl (stack s)), vs @ dropWhileNot v (rev (tl (stack s)))),\n   red := red s\\<rparr>) \\<longrightarrow>\n                                    lasso_inv\n                                     (s'\n\\<lparr>lasso :=\n          Some\n           (rev (tl (stack s)), vs @ dropWhileNot v (rev (tl (stack s)))),\n   red := red s\\<rparr>))", "apply (rule red_DFS_precond, simp_all add: ne) []"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>vs v.\n                \\<lbrakk>BlueDFS_invar G accpt\n                          (s'\\<lparr>lasso :=\n Some (rev (tl (stack s)), vs @ dropWhileNot v (rev (tl (stack s)))),\n                                red := red s\\<rparr>);\n                 vs \\<noteq> [];\n                 path (rel_restrict E (red s)) (hd (stack s)) vs v;\n                 v \\<in> set (stack s)\\<rbrakk>\n                \\<Longrightarrow> lasso_inv\n                                   (s'\\<lparr>lasso :=\n          Some\n           (rev (tl (stack s)), vs @ dropWhileNot v (rev (tl (stack s)))),\n   red := red s\\<rparr>);\n     accpt (hd (stack s)); lasso s = None\\<rbrakk>\n    \\<Longrightarrow> restr_invar\n                       (g_E (G\\<lparr>g_V0 := {hd (stack s)}\\<rparr>))\n                       (red s) (\\<lambda>x. x \\<in> set (stack s))\n 2. \\<lbrakk>\\<And>vs v.\n                \\<lbrakk>BlueDFS_invar G accpt\n                          (s'\\<lparr>lasso :=\n Some (rev (tl (stack s)), vs @ dropWhileNot v (rev (tl (stack s)))),\n                                red := red s\\<rparr>);\n                 vs \\<noteq> [];\n                 path (rel_restrict E (red s)) (hd (stack s)) vs v;\n                 v \\<in> set (stack s)\\<rbrakk>\n                \\<Longrightarrow> lasso_inv\n                                   (s'\\<lparr>lasso :=\n          Some\n           (rev (tl (stack s)), vs @ dropWhileNot v (rev (tl (stack s)))),\n   red := red s\\<rparr>);\n     accpt (hd (stack s)); lasso s = None;\n     fb_graph (G\\<lparr>g_V0 := {hd (stack s)}\\<rparr>) \\<and>\n     restr_invar (g_E (G\\<lparr>g_V0 := {hd (stack s)}\\<rparr>)) (red s)\n      (\\<lambda>x. x \\<in> set (stack s))\\<rbrakk>\n    \\<Longrightarrow> SPEC\n                       (find_path1_restr_pred\n                         (G\\<lparr>g_V0 := {hd (stack s)}\\<rparr>)\n                         (\\<lambda>x. x \\<in> set (stack s)) (red s))\n                      \\<le> SPEC\n                             (\\<lambda>rs.\n                                 \\<forall>vs v.\n                                    rs = Inr (vs, v) \\<longrightarrow>\n                                    BlueDFS_invar G accpt\n                                     (s'\n\\<lparr>lasso :=\n          Some\n           (rev (tl (stack s)), vs @ dropWhileNot v (rev (tl (stack s)))),\n   red := red s\\<rparr>) \\<longrightarrow>\n                                    lasso_inv\n                                     (s'\n\\<lparr>lasso :=\n          Some\n           (rev (tl (stack s)), vs @ dropWhileNot v (rev (tl (stack s)))),\n   red := red s\\<rparr>))", "apply (simp, rule red_DFS_precond, simp_all add: ne) []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>vs v.\n                \\<lbrakk>BlueDFS_invar G accpt\n                          (s'\\<lparr>lasso :=\n Some (rev (tl (stack s)), vs @ dropWhileNot v (rev (tl (stack s)))),\n                                red := red s\\<rparr>);\n                 vs \\<noteq> [];\n                 path (rel_restrict E (red s)) (hd (stack s)) vs v;\n                 v \\<in> set (stack s)\\<rbrakk>\n                \\<Longrightarrow> lasso_inv\n                                   (s'\\<lparr>lasso :=\n          Some\n           (rev (tl (stack s)), vs @ dropWhileNot v (rev (tl (stack s)))),\n   red := red s\\<rparr>);\n     accpt (hd (stack s)); lasso s = None;\n     fb_graph (G\\<lparr>g_V0 := {hd (stack s)}\\<rparr>) \\<and>\n     restr_invar (g_E (G\\<lparr>g_V0 := {hd (stack s)}\\<rparr>)) (red s)\n      (\\<lambda>x. x \\<in> set (stack s))\\<rbrakk>\n    \\<Longrightarrow> SPEC\n                       (find_path1_restr_pred\n                         (G\\<lparr>g_V0 := {hd (stack s)}\\<rparr>)\n                         (\\<lambda>x. x \\<in> set (stack s)) (red s))\n                      \\<le> SPEC\n                             (\\<lambda>rs.\n                                 \\<forall>vs v.\n                                    rs = Inr (vs, v) \\<longrightarrow>\n                                    BlueDFS_invar G accpt\n                                     (s'\n\\<lparr>lasso :=\n          Some\n           (rev (tl (stack s)), vs @ dropWhileNot v (rev (tl (stack s)))),\n   red := red s\\<rparr>) \\<longrightarrow>\n                                    lasso_inv\n                                     (s'\n\\<lparr>lasso :=\n          Some\n           (rev (tl (stack s)), vs @ dropWhileNot v (rev (tl (stack s)))),\n   red := red s\\<rparr>))", "using red_stack_disjoint ne"], ["proof (prove)\nusing this:\n  lasso s = None \\<Longrightarrow> set (stack s) \\<inter> red s = {}\n  stack s \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>vs v.\n                \\<lbrakk>BlueDFS_invar G accpt\n                          (s'\\<lparr>lasso :=\n Some (rev (tl (stack s)), vs @ dropWhileNot v (rev (tl (stack s)))),\n                                red := red s\\<rparr>);\n                 vs \\<noteq> [];\n                 path (rel_restrict E (red s)) (hd (stack s)) vs v;\n                 v \\<in> set (stack s)\\<rbrakk>\n                \\<Longrightarrow> lasso_inv\n                                   (s'\\<lparr>lasso :=\n          Some\n           (rev (tl (stack s)), vs @ dropWhileNot v (rev (tl (stack s)))),\n   red := red s\\<rparr>);\n     accpt (hd (stack s)); lasso s = None;\n     fb_graph (G\\<lparr>g_V0 := {hd (stack s)}\\<rparr>) \\<and>\n     restr_invar (g_E (G\\<lparr>g_V0 := {hd (stack s)}\\<rparr>)) (red s)\n      (\\<lambda>x. x \\<in> set (stack s))\\<rbrakk>\n    \\<Longrightarrow> SPEC\n                       (find_path1_restr_pred\n                         (G\\<lparr>g_V0 := {hd (stack s)}\\<rparr>)\n                         (\\<lambda>x. x \\<in> set (stack s)) (red s))\n                      \\<le> SPEC\n                             (\\<lambda>rs.\n                                 \\<forall>vs v.\n                                    rs = Inr (vs, v) \\<longrightarrow>\n                                    BlueDFS_invar G accpt\n                                     (s'\n\\<lparr>lasso :=\n          Some\n           (rev (tl (stack s)), vs @ dropWhileNot v (rev (tl (stack s)))),\n   red := red s\\<rparr>) \\<longrightarrow>\n                                    lasso_inv\n                                     (s'\n\\<lparr>lasso :=\n          Some\n           (rev (tl (stack s)), vs @ dropWhileNot v (rev (tl (stack s)))),\n   red := red s\\<rparr>))", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>vs v.\n       \\<lbrakk>\\<And>vs v.\n                   \\<lbrakk>BlueDFS_invar G accpt\n                             (s'\\<lparr>lasso :=\n    Some (rev (tl (stack s)), vs @ dropWhileNot v (rev (tl (stack s)))),\n                                   red := red s\\<rparr>);\n                    vs \\<noteq> [];\n                    path (rel_restrict E (red s)) (hd (stack s)) vs v;\n                    v \\<in> set (stack s)\\<rbrakk>\n                   \\<Longrightarrow> lasso_inv\n(s'\\<lparr>lasso :=\n             Some\n              (rev (tl (stack s)),\n               vs @ dropWhileNot v (rev (tl (stack s)))),\n      red := red s\\<rparr>);\n        accpt (hd (stack s)); lasso s = None;\n        set (stack s) \\<inter> red s = {}; stack s \\<noteq> [];\n        find_path1_restr_pred (G\\<lparr>g_V0 := {hd (stack s)}\\<rparr>)\n         (\\<lambda>x. x \\<in> set (stack s)) (red s) (Inr (vs, v));\n        fb_graph (G\\<lparr>g_V0 := {hd (stack s)}\\<rparr>);\n        restr_invar E (red s) (\\<lambda>x. x \\<in> set (stack s));\n        BlueDFS_invar G accpt\n         (s'\\<lparr>lasso :=\n                      Some\n                       (rev (tl (stack s)),\n                        vs @ dropWhileNot v (rev (tl (stack s)))),\n               red := red s\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> lasso_inv\n                          (s'\\<lparr>lasso :=\n Some (rev (tl (stack s)), vs @ dropWhileNot v (rev (tl (stack s)))),\n                                red := red s\\<rparr>)", "apply rprems"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>vs v.\n       \\<lbrakk>accpt (hd (stack s)); lasso s = None;\n        set (stack s) \\<inter> red s = {}; stack s \\<noteq> [];\n        find_path1_restr_pred (G\\<lparr>g_V0 := {hd (stack s)}\\<rparr>)\n         (\\<lambda>x. x \\<in> set (stack s)) (red s) (Inr (vs, v));\n        fb_graph (G\\<lparr>g_V0 := {hd (stack s)}\\<rparr>);\n        restr_invar E (red s) (\\<lambda>x. x \\<in> set (stack s));\n        BlueDFS_invar G accpt\n         (s'\\<lparr>lasso :=\n                      Some\n                       (rev (tl (stack s)),\n                        vs @ dropWhileNot v (rev (tl (stack s)))),\n               red := red s\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> BlueDFS_invar G accpt\n                          (s'\\<lparr>lasso :=\n Some (rev (tl (stack s)), vs @ dropWhileNot v (rev (tl (stack s)))),\n                                red := red s\\<rparr>)\n 2. \\<And>vs v.\n       \\<lbrakk>accpt (hd (stack s)); lasso s = None;\n        set (stack s) \\<inter> red s = {}; stack s \\<noteq> [];\n        find_path1_restr_pred (G\\<lparr>g_V0 := {hd (stack s)}\\<rparr>)\n         (\\<lambda>x. x \\<in> set (stack s)) (red s) (Inr (vs, v));\n        fb_graph (G\\<lparr>g_V0 := {hd (stack s)}\\<rparr>);\n        restr_invar E (red s) (\\<lambda>x. x \\<in> set (stack s));\n        BlueDFS_invar G accpt\n         (s'\\<lparr>lasso :=\n                      Some\n                       (rev (tl (stack s)),\n                        vs @ dropWhileNot v (rev (tl (stack s)))),\n               red := red s\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> vs \\<noteq> []\n 3. \\<And>vs v.\n       \\<lbrakk>accpt (hd (stack s)); lasso s = None;\n        set (stack s) \\<inter> red s = {}; stack s \\<noteq> [];\n        find_path1_restr_pred (G\\<lparr>g_V0 := {hd (stack s)}\\<rparr>)\n         (\\<lambda>x. x \\<in> set (stack s)) (red s) (Inr (vs, v));\n        fb_graph (G\\<lparr>g_V0 := {hd (stack s)}\\<rparr>);\n        restr_invar E (red s) (\\<lambda>x. x \\<in> set (stack s));\n        BlueDFS_invar G accpt\n         (s'\\<lparr>lasso :=\n                      Some\n                       (rev (tl (stack s)),\n                        vs @ dropWhileNot v (rev (tl (stack s)))),\n               red := red s\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> path (rel_restrict E (red s)) (hd (stack s)) vs v\n 4. \\<And>vs v.\n       \\<lbrakk>accpt (hd (stack s)); lasso s = None;\n        set (stack s) \\<inter> red s = {}; stack s \\<noteq> [];\n        find_path1_restr_pred (G\\<lparr>g_V0 := {hd (stack s)}\\<rparr>)\n         (\\<lambda>x. x \\<in> set (stack s)) (red s) (Inr (vs, v));\n        fb_graph (G\\<lparr>g_V0 := {hd (stack s)}\\<rparr>);\n        restr_invar E (red s) (\\<lambda>x. x \\<in> set (stack s));\n        BlueDFS_invar G accpt\n         (s'\\<lparr>lasso :=\n                      Some\n                       (rev (tl (stack s)),\n                        vs @ dropWhileNot v (rev (tl (stack s)))),\n               red := red s\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> v \\<in> set (stack s)", "apply (simp_all add: find_path1_restr_pred_def restr_invar_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>vs v.\n       \\<lbrakk>accpt (hd (stack s)); lasso s = None;\n        set (stack s) \\<inter> red s = {}; stack s \\<noteq> [];\n        v \\<in> set (stack s) \\<and>\n        vs \\<noteq> [] \\<and>\n        path (E \\<inter> UNIV \\<times> - red s) (hd (stack s)) vs v;\n        fb_graph (G\\<lparr>g_V0 := {hd (stack s)}\\<rparr>);\n        E `` red s \\<subseteq> red s \\<and>\n        red s \\<inter> set (stack s) = {};\n        BlueDFS_invar G accpt\n         (s'\\<lparr>lasso :=\n                      Some\n                       (rev (tl (stack s)),\n                        vs @ dropWhileNot v (rev (tl (stack s)))),\n               red := red s\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> path (rel_restrict E (red s)) (hd (stack s)) vs v", "apply (fastforce intro: path_restrict_tl rel_restrictI)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  accpt (hd (stack s)) \\<longrightarrow>\n  lasso s = None \\<longrightarrow>\n  red_dfs (red s) (\\<lambda>x. x \\<in> set (stack s)) (hd (stack s))\n  \\<le> SPEC\n         (\\<lambda>rs.\n             \\<forall>vs v.\n                rs = Inr (vs, v) \\<longrightarrow>\n                DFS_invar G blue_dfs_params\n                 (s'\\<lparr>lasso :=\n                              Some\n                               (rev (tl (stack s)),\n                                vs @ dropWhileNot v (rev (tl (stack s)))),\n                       red := red s\\<rparr>) \\<longrightarrow>\n                lasso_inv\n                 (s'\\<lparr>lasso :=\n                              Some\n                               (rev (tl (stack s)),\n                                vs @ dropWhileNot v (rev (tl (stack s)))),\n                       red := red s\\<rparr>))\n\ngoal (6 subgoals):\n 1. on_init blue_dfs_params \\<le>\\<^sub>n\n    SPEC (\\<lambda>x. lasso_inv (empty_state x))\n 2. \\<And>s s' v0.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; lasso_inv s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s = []; v0 \\<in> V0;\n        v0 \\<notin> dom (discovered s); s' = new_root v0 s\\<rbrakk>\n       \\<Longrightarrow> on_new_root blue_dfs_params v0 s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso_inv (s'\\<lparr>state.more := x\\<rparr>))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; lasso_inv s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish blue_dfs_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso_inv (s'\\<lparr>state.more := x\\<rparr>))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; lasso_inv s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso_inv (s'\\<lparr>state.more := x\\<rparr>))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; lasso_inv s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso_inv (s'\\<lparr>state.more := x\\<rparr>))\n 6. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; lasso_inv s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<notin> dom (discovered s);\n        s' =\n        discover u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso_inv (s'\\<lparr>state.more := x\\<rparr>))", "note aux1 = this[rule_format,THEN leof_lift]"], ["proof (state)\nthis:\n  \\<lbrakk>accpt (hd (stack s)); lasso s = None\\<rbrakk>\n  \\<Longrightarrow> red_dfs (red s) (\\<lambda>x. x \\<in> set (stack s))\n                     (hd (stack s)) \\<le>\\<^sub>n\n                    SPEC\n                     (\\<lambda>rs.\n                         \\<forall>vs v.\n                            rs = Inr (vs, v) \\<longrightarrow>\n                            DFS_invar G blue_dfs_params\n                             (s'\\<lparr>lasso :=\n    Some (rev (tl (stack s)), vs @ dropWhileNot v (rev (tl (stack s)))),\n                                   red := red s\\<rparr>) \\<longrightarrow>\n                            lasso_inv\n                             (s'\\<lparr>lasso :=\n    Some (rev (tl (stack s)), vs @ dropWhileNot v (rev (tl (stack s)))),\n                                   red := red s\\<rparr>))\n\ngoal (6 subgoals):\n 1. on_init blue_dfs_params \\<le>\\<^sub>n\n    SPEC (\\<lambda>x. lasso_inv (empty_state x))\n 2. \\<And>s s' v0.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; lasso_inv s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s = []; v0 \\<in> V0;\n        v0 \\<notin> dom (discovered s); s' = new_root v0 s\\<rbrakk>\n       \\<Longrightarrow> on_new_root blue_dfs_params v0 s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso_inv (s'\\<lparr>state.more := x\\<rparr>))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; lasso_inv s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish blue_dfs_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso_inv (s'\\<lparr>state.more := x\\<rparr>))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; lasso_inv s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso_inv (s'\\<lparr>state.more := x\\<rparr>))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; lasso_inv s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso_inv (s'\\<lparr>state.more := x\\<rparr>))\n 6. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; lasso_inv s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<notin> dom (discovered s);\n        s' =\n        discover u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso_inv (s'\\<lparr>state.more := x\\<rparr>))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. on_finish blue_dfs_params u s' \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         DFS_invar G blue_dfs_params\n          (s'\\<lparr>state.more := x\\<rparr>) \\<longrightarrow>\n         lasso_inv (s'\\<lparr>state.more := x\\<rparr>))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. (accpt (hd (stack s)) \\<longrightarrow>\n     run_red_dfs (hd (stack s)) s' \\<le>\\<^sub>n\n     SPEC\n      (\\<lambda>x.\n          BlueDFS_invar G accpt\n           (s'\\<lparr>state.more := x\\<rparr>) \\<longrightarrow>\n          lasso_inv (s'\\<lparr>state.more := x\\<rparr>))) \\<and>\n    (\\<not> accpt (hd (stack s)) \\<longrightarrow>\n     BlueDFS_invar G accpt s' \\<longrightarrow> lasso_inv s')", "unfolding run_red_dfs_def mk_blue_witness_def cyan_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (accpt (hd (stack s)) \\<longrightarrow>\n     (case lasso s' of\n      None \\<Rightarrow>\n        red_dfs (red s')\n         (\\<lambda>x. x = hd (stack s) \\<or> x \\<in> set (stack s'))\n         (hd (stack s)) \\<bind>\n        (\\<lambda>redS.\n            RETURN\n             (case redS of\n              Inl R' \\<Rightarrow> \\<lparr>lasso = None, red = R'\\<rparr>\n              | Inr (vs, v) \\<Rightarrow>\n                  let rs = rev (stack s')\n                  in \\<lparr>lasso = Some (rs, vs @ dropWhileNot v rs),\n                        red = red s'\\<rparr>))\n      | Some a \\<Rightarrow> NOOP s') \\<le>\\<^sub>n\n     SPEC\n      (\\<lambda>x.\n          BlueDFS_invar G accpt\n           (s'\\<lparr>state.more := x\\<rparr>) \\<longrightarrow>\n          lasso_inv (s'\\<lparr>state.more := x\\<rparr>))) \\<and>\n    (\\<not> accpt (hd (stack s)) \\<longrightarrow>\n     BlueDFS_invar G accpt s' \\<longrightarrow> lasso_inv s')", "apply (simp \n        add: run_red_dfs_def mk_blue_witness_def cyan_def\n        split: option.splits)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (lasso s = None \\<longrightarrow>\n     (accpt (hd (stack s)) \\<longrightarrow>\n      red_dfs (red s) (\\<lambda>x. x \\<in> set (stack s))\n       (hd (stack s)) \\<bind>\n      (\\<lambda>redS.\n          RETURN\n           (case redS of\n            Inl R' \\<Rightarrow> \\<lparr>lasso = None, red = R'\\<rparr>\n            | Inr (vs, v) \\<Rightarrow>\n                let rs = rev (stack s')\n                in \\<lparr>lasso = Some (rs, vs @ dropWhileNot v rs),\n                      red = red s'\\<rparr>)) \\<le>\\<^sub>n\n      SPEC\n       (\\<lambda>x.\n           BlueDFS_invar G accpt\n            (s'\\<lparr>state.more := x\\<rparr>) \\<longrightarrow>\n           lasso_inv (s'\\<lparr>state.more := x\\<rparr>))) \\<and>\n     (\\<not> accpt (hd (stack s)) \\<longrightarrow>\n      BlueDFS_invar G accpt s' \\<longrightarrow> lasso_inv s')) \\<and>\n    ((\\<exists>a b. lasso s = Some (a, b)) \\<longrightarrow>\n     BlueDFS_invar G accpt s' \\<longrightarrow> lasso_inv s')", "apply (intro conjI impI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>lasso s = None; accpt (hd (stack s))\\<rbrakk>\n    \\<Longrightarrow> red_dfs (red s) (\\<lambda>x. x \\<in> set (stack s))\n                       (hd (stack s)) \\<bind>\n                      (\\<lambda>redS.\n                          RETURN\n                           (case redS of\n                            Inl R' \\<Rightarrow>\n                              \\<lparr>lasso = None, red = R'\\<rparr>\n                            | Inr (vs, v) \\<Rightarrow>\n                                let rs = rev (stack s')\n                                in \\<lparr>lasso =\n       Some (rs, vs @ dropWhileNot v rs),\nred = red s'\\<rparr>)) \\<le>\\<^sub>n\n                      SPEC\n                       (\\<lambda>x.\n                           BlueDFS_invar G accpt\n                            (s'\\<lparr>state.more :=\n   x\\<rparr>) \\<longrightarrow>\n                           lasso_inv (s'\\<lparr>state.more := x\\<rparr>))\n 2. \\<lbrakk>lasso s = None; \\<not> accpt (hd (stack s));\n     BlueDFS_invar G accpt s'\\<rbrakk>\n    \\<Longrightarrow> lasso_inv s'\n 3. \\<lbrakk>\\<exists>a b. lasso s = Some (a, b);\n     BlueDFS_invar G accpt s'\\<rbrakk>\n    \\<Longrightarrow> lasso_inv s'", "apply (refine_vcg leof_trans[OF aux1])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>lasso s = None; accpt (hd (stack s));\n        x \\<in> {rs.\n                 \\<forall>vs v.\n                    rs = Inr (vs, v) \\<longrightarrow>\n                    DFS_invar G blue_dfs_params\n                     (s'\\<lparr>lasso :=\n                                  Some\n                                   (rev (tl (stack s)),\n                                    vs @\n                                    dropWhileNot v (rev (tl (stack s)))),\n                           red := red s\\<rparr>) \\<longrightarrow>\n                    lasso_inv\n                     (s'\\<lparr>lasso :=\n                                  Some\n                                   (rev (tl (stack s)),\n                                    vs @\n                                    dropWhileNot v (rev (tl (stack s)))),\n                           red := red s\\<rparr>)};\n        BlueDFS_invar G accpt\n         (s'\\<lparr>state.more :=\n                      case x of\n                      Inl R' \\<Rightarrow>\n                        \\<lparr>lasso = None, red = R'\\<rparr>\n                      | Inr (vs, v) \\<Rightarrow>\n                          let rs = rev (stack s')\n                          in \\<lparr>lasso =\n Some (rs, vs @ dropWhileNot v rs),\n                                red = red s'\\<rparr>\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> lasso_inv\n                          (s'\\<lparr>state.more :=\n case x of Inl R' \\<Rightarrow> \\<lparr>lasso = None, red = R'\\<rparr>\n | Inr (vs, v) \\<Rightarrow>\n     let rs = rev (stack s')\n     in \\<lparr>lasso = Some (rs, vs @ dropWhileNot v rs),\n           red = red s'\\<rparr>\\<rparr>)\n 2. \\<lbrakk>lasso s = None; \\<not> accpt (hd (stack s));\n     BlueDFS_invar G accpt s'\\<rbrakk>\n    \\<Longrightarrow> lasso_inv s'\n 3. \\<lbrakk>\\<exists>a b. lasso s = Some (a, b);\n     BlueDFS_invar G accpt s'\\<rbrakk>\n    \\<Longrightarrow> lasso_inv s'", "using finish"], ["proof (prove)\nusing this:\n  DFS_invar G blue_dfs_params s\n  lasso_inv s\n  cond s\n  \\<not> is_break blue_dfs_params s\n  stack s \\<noteq> []\n  u = hd (stack s)\n  pending s `` {u} = {}\n  s' = finish u s\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>lasso s = None; accpt (hd (stack s));\n        x \\<in> {rs.\n                 \\<forall>vs v.\n                    rs = Inr (vs, v) \\<longrightarrow>\n                    DFS_invar G blue_dfs_params\n                     (s'\\<lparr>lasso :=\n                                  Some\n                                   (rev (tl (stack s)),\n                                    vs @\n                                    dropWhileNot v (rev (tl (stack s)))),\n                           red := red s\\<rparr>) \\<longrightarrow>\n                    lasso_inv\n                     (s'\\<lparr>lasso :=\n                                  Some\n                                   (rev (tl (stack s)),\n                                    vs @\n                                    dropWhileNot v (rev (tl (stack s)))),\n                           red := red s\\<rparr>)};\n        BlueDFS_invar G accpt\n         (s'\\<lparr>state.more :=\n                      case x of\n                      Inl R' \\<Rightarrow>\n                        \\<lparr>lasso = None, red = R'\\<rparr>\n                      | Inr (vs, v) \\<Rightarrow>\n                          let rs = rev (stack s')\n                          in \\<lparr>lasso =\n Some (rs, vs @ dropWhileNot v rs),\n                                red = red s'\\<rparr>\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> lasso_inv\n                          (s'\\<lparr>state.more :=\n case x of Inl R' \\<Rightarrow> \\<lparr>lasso = None, red = R'\\<rparr>\n | Inr (vs, v) \\<Rightarrow>\n     let rs = rev (stack s')\n     in \\<lparr>lasso = Some (rs, vs @ dropWhileNot v rs),\n           red = red s'\\<rparr>\\<rparr>)\n 2. \\<lbrakk>lasso s = None; \\<not> accpt (hd (stack s));\n     BlueDFS_invar G accpt s'\\<rbrakk>\n    \\<Longrightarrow> lasso_inv s'\n 3. \\<lbrakk>\\<exists>a b. lasso s = Some (a, b);\n     BlueDFS_invar G accpt s'\\<rbrakk>\n    \\<Longrightarrow> lasso_inv s'", "apply (auto simp add: lasso_inv_def split: sum.split)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  on_finish blue_dfs_params u s' \\<le>\\<^sub>n\n  SPEC\n   (\\<lambda>x.\n       DFS_invar G blue_dfs_params\n        (s'\\<lparr>state.more := x\\<rparr>) \\<longrightarrow>\n       lasso_inv (s'\\<lparr>state.more := x\\<rparr>))\n\ngoal (5 subgoals):\n 1. on_init blue_dfs_params \\<le>\\<^sub>n\n    SPEC (\\<lambda>x. lasso_inv (empty_state x))\n 2. \\<And>s s' v0.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; lasso_inv s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s = []; v0 \\<in> V0;\n        v0 \\<notin> dom (discovered s); s' = new_root v0 s\\<rbrakk>\n       \\<Longrightarrow> on_new_root blue_dfs_params v0 s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso_inv (s'\\<lparr>state.more := x\\<rparr>))\n 3. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; lasso_inv s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso_inv (s'\\<lparr>state.more := x\\<rparr>))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; lasso_inv s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso_inv (s'\\<lparr>state.more := x\\<rparr>))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; lasso_inv s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<notin> dom (discovered s);\n        s' =\n        discover u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso_inv (s'\\<lparr>state.more := x\\<rparr>))", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. on_init blue_dfs_params \\<le>\\<^sub>n\n    SPEC (\\<lambda>x. lasso_inv (empty_state x))\n 2. \\<And>s s' v0.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; lasso_inv s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s = []; v0 \\<in> V0;\n        v0 \\<notin> dom (discovered s); s' = new_root v0 s\\<rbrakk>\n       \\<Longrightarrow> on_new_root blue_dfs_params v0 s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso_inv (s'\\<lparr>state.more := x\\<rparr>))\n 3. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; lasso_inv s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso_inv (s'\\<lparr>state.more := x\\<rparr>))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; lasso_inv s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso_inv (s'\\<lparr>state.more := x\\<rparr>))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; lasso_inv s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<notin> dom (discovered s);\n        s' =\n        discover u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso_inv (s'\\<lparr>state.more := x\\<rparr>))", "case (back_edge s s' u v)"], ["proof (state)\nthis:\n  DFS_invar G blue_dfs_params s\n  lasso_inv s\n  cond s\n  \\<not> is_break blue_dfs_params s\n  stack s \\<noteq> []\n  (u, v) \\<in> pending s\n  u = hd (stack s)\n  v \\<in> dom (discovered s)\n  v \\<notin> dom (finished s)\n  s' = back_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n\ngoal (5 subgoals):\n 1. on_init blue_dfs_params \\<le>\\<^sub>n\n    SPEC (\\<lambda>x. lasso_inv (empty_state x))\n 2. \\<And>s s' v0.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; lasso_inv s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s = []; v0 \\<in> V0;\n        v0 \\<notin> dom (discovered s); s' = new_root v0 s\\<rbrakk>\n       \\<Longrightarrow> on_new_root blue_dfs_params v0 s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso_inv (s'\\<lparr>state.more := x\\<rparr>))\n 3. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; lasso_inv s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso_inv (s'\\<lparr>state.more := x\\<rparr>))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; lasso_inv s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso_inv (s'\\<lparr>state.more := x\\<rparr>))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; lasso_inv s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<notin> dom (discovered s);\n        s' =\n        discover u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso_inv (s'\\<lparr>state.more := x\\<rparr>))", "then"], ["proof (chain)\npicking this:\n  DFS_invar G blue_dfs_params s\n  lasso_inv s\n  cond s\n  \\<not> is_break blue_dfs_params s\n  stack s \\<noteq> []\n  (u, v) \\<in> pending s\n  u = hd (stack s)\n  v \\<in> dom (discovered s)\n  v \\<notin> dom (finished s)\n  s' = back_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)", "interpret BlueDFS_invar where s=s"], ["proof (prove)\nusing this:\n  DFS_invar G blue_dfs_params s\n  lasso_inv s\n  cond s\n  \\<not> is_break blue_dfs_params s\n  stack s \\<noteq> []\n  (u, v) \\<in> pending s\n  u = hd (stack s)\n  v \\<in> dom (discovered s)\n  v \\<notin> dom (finished s)\n  s' = back_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n\ngoal (1 subgoal):\n 1. BlueDFS_invar G accpt s", "by simp"], ["proof (state)\ngoal (5 subgoals):\n 1. on_init blue_dfs_params \\<le>\\<^sub>n\n    SPEC (\\<lambda>x. lasso_inv (empty_state x))\n 2. \\<And>s s' v0.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; lasso_inv s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s = []; v0 \\<in> V0;\n        v0 \\<notin> dom (discovered s); s' = new_root v0 s\\<rbrakk>\n       \\<Longrightarrow> on_new_root blue_dfs_params v0 s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso_inv (s'\\<lparr>state.more := x\\<rparr>))\n 3. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; lasso_inv s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso_inv (s'\\<lparr>state.more := x\\<rparr>))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; lasso_inv s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso_inv (s'\\<lparr>state.more := x\\<rparr>))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; lasso_inv s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<notin> dom (discovered s);\n        s' =\n        discover u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso_inv (s'\\<lparr>state.more := x\\<rparr>))", "from back_edge se_back_edge_lasso_inv[THEN leof_lift]"], ["proof (chain)\npicking this:\n  DFS_invar G blue_dfs_params s\n  lasso_inv s\n  cond s\n  \\<not> is_break blue_dfs_params s\n  stack s \\<noteq> []\n  (u, v) \\<in> pending s\n  u = hd (stack s)\n  v \\<in> dom (discovered s)\n  v \\<notin> dom (finished s)\n  s' = back_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n  \\<lbrakk>lasso_inv s; stack s \\<noteq> []; lasso s = None;\n   (hd (stack s), ?v1) \\<in> pending s; ?v1 \\<in> dom (discovered s);\n   ?v1 \\<notin> dom (finished s);\n   ?s'1 =\n   back_edge (hd (stack s)) ?v1\n    (s\\<lparr>pending := pending s - {(?u1, ?v1)}\\<rparr>)\\<rbrakk>\n  \\<Longrightarrow> se_back_edge (hd (stack s)) ?v1 ?s'1 \\<le>\\<^sub>n\n                    SPEC\n                     (\\<lambda>e.\n                         DFS_invar G blue_dfs_params\n                          (?s'1\n                           \\<lparr>state.more :=\n                                     e\\<rparr>) \\<longrightarrow>\n                         lasso_inv (?s'1\\<lparr>state.more := e\\<rparr>))", "show ?case"], ["proof (prove)\nusing this:\n  DFS_invar G blue_dfs_params s\n  lasso_inv s\n  cond s\n  \\<not> is_break blue_dfs_params s\n  stack s \\<noteq> []\n  (u, v) \\<in> pending s\n  u = hd (stack s)\n  v \\<in> dom (discovered s)\n  v \\<notin> dom (finished s)\n  s' = back_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n  \\<lbrakk>lasso_inv s; stack s \\<noteq> []; lasso s = None;\n   (hd (stack s), ?v1) \\<in> pending s; ?v1 \\<in> dom (discovered s);\n   ?v1 \\<notin> dom (finished s);\n   ?s'1 =\n   back_edge (hd (stack s)) ?v1\n    (s\\<lparr>pending := pending s - {(?u1, ?v1)}\\<rparr>)\\<rbrakk>\n  \\<Longrightarrow> se_back_edge (hd (stack s)) ?v1 ?s'1 \\<le>\\<^sub>n\n                    SPEC\n                     (\\<lambda>e.\n                         DFS_invar G blue_dfs_params\n                          (?s'1\n                           \\<lparr>state.more :=\n                                     e\\<rparr>) \\<longrightarrow>\n                         lasso_inv (?s'1\\<lparr>state.more := e\\<rparr>))\n\ngoal (1 subgoal):\n 1. on_back_edge blue_dfs_params u v s' \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         DFS_invar G blue_dfs_params\n          (s'\\<lparr>state.more := x\\<rparr>) \\<longrightarrow>\n         lasso_inv (s'\\<lparr>state.more := x\\<rparr>))", "by auto"], ["proof (state)\nthis:\n  on_back_edge blue_dfs_params u v s' \\<le>\\<^sub>n\n  SPEC\n   (\\<lambda>x.\n       DFS_invar G blue_dfs_params\n        (s'\\<lparr>state.more := x\\<rparr>) \\<longrightarrow>\n       lasso_inv (s'\\<lparr>state.more := x\\<rparr>))\n\ngoal (4 subgoals):\n 1. on_init blue_dfs_params \\<le>\\<^sub>n\n    SPEC (\\<lambda>x. lasso_inv (empty_state x))\n 2. \\<And>s s' v0.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; lasso_inv s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s = []; v0 \\<in> V0;\n        v0 \\<notin> dom (discovered s); s' = new_root v0 s\\<rbrakk>\n       \\<Longrightarrow> on_new_root blue_dfs_params v0 s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso_inv (s'\\<lparr>state.more := x\\<rparr>))\n 3. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; lasso_inv s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso_inv (s'\\<lparr>state.more := x\\<rparr>))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G blue_dfs_params s; lasso_inv s; cond s;\n        \\<not> is_break blue_dfs_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<notin> dom (discovered s);\n        s' =\n        discover u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover blue_dfs_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G blue_dfs_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              lasso_inv (s'\\<lparr>state.more := x\\<rparr>))", "qed (simp_all add: lasso_inv_def empty_state_def)"], ["", "end"], ["", "context BlueDFS_invar\nbegin"], ["", "lemmas s_lasso_inv = lasso_inv[THEN make_invar_thm]"], ["", "lemma \n    assumes \"lasso s = Some (pr,pl)\"\n    shows loop_nonempty: \"pl \\<noteq> []\"\n    and accpt_loop: \"accpt (hd pl)\"\n    and loop_is_path: \"path E (hd pl) pl (hd pl)\"\n    and loop_reachable: \"\\<exists>v0\\<in>V0. path E v0 pr (hd pl)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (pl \\<noteq> [] &&& accpt (hd pl)) &&&\n    path E (hd pl) pl (hd pl) &&& \\<exists>v0\\<in>V0. path E v0 pr (hd pl)", "using assms s_lasso_inv"], ["proof (prove)\nusing this:\n  lasso s = Some (pr, pl)\n  lasso_inv s\n\ngoal (1 subgoal):\n 1. (pl \\<noteq> [] &&& accpt (hd pl)) &&&\n    path E (hd pl) pl (hd pl) &&& \\<exists>v0\\<in>V0. path E v0 pr (hd pl)", "by (simp_all add: lasso_inv_def)"], ["", "lemma blue_dfs_correct:\n    assumes NC: \"\\<not> cond s\"\n    shows \"case lasso s of\n      None \\<Rightarrow> \\<not>(\\<exists>v0\\<in>V0. \\<exists>v. (v0,v) \\<in> E\\<^sup>* \\<and> accpt v \\<and> (v,v) \\<in> E\\<^sup>+)\n    | Some (pr,pl) \\<Rightarrow> (\\<exists>v0\\<in>V0. \\<exists>v. \n        path E v0 pr v \\<and> accpt v \\<and> pl\\<noteq>[] \\<and> path E v pl v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. case lasso s of\n    None \\<Rightarrow>\n      \\<not> (\\<exists>v0\\<in>V0.\n                 \\<exists>v.\n                    (v0, v) \\<in> E\\<^sup>* \\<and>\n                    accpt v \\<and> (v, v) \\<in> E\\<^sup>+)\n    | Some (pr, pl) \\<Rightarrow>\n        \\<exists>v0\\<in>V0.\n           \\<exists>v.\n              path E v0 pr v \\<and>\n              accpt v \\<and> pl \\<noteq> [] \\<and> path E v pl v", "proof (cases \"lasso s\")"], ["proof (state)\ngoal (2 subgoals):\n 1. lasso s = None \\<Longrightarrow>\n    case lasso s of\n    None \\<Rightarrow>\n      \\<not> (\\<exists>v0\\<in>V0.\n                 \\<exists>v.\n                    (v0, v) \\<in> E\\<^sup>* \\<and>\n                    accpt v \\<and> (v, v) \\<in> E\\<^sup>+)\n    | Some (pr, pl) \\<Rightarrow>\n        \\<exists>v0\\<in>V0.\n           \\<exists>v.\n              path E v0 pr v \\<and>\n              accpt v \\<and> pl \\<noteq> [] \\<and> path E v pl v\n 2. \\<And>a.\n       lasso s = Some a \\<Longrightarrow>\n       case lasso s of\n       None \\<Rightarrow>\n         \\<not> (\\<exists>v0\\<in>V0.\n                    \\<exists>v.\n                       (v0, v) \\<in> E\\<^sup>* \\<and>\n                       accpt v \\<and> (v, v) \\<in> E\\<^sup>+)\n       | Some (pr, pl) \\<Rightarrow>\n           \\<exists>v0\\<in>V0.\n              \\<exists>v.\n                 path E v0 pr v \\<and>\n                 accpt v \\<and> pl \\<noteq> [] \\<and> path E v pl v", "case None"], ["proof (state)\nthis:\n  lasso s = None\n\ngoal (2 subgoals):\n 1. lasso s = None \\<Longrightarrow>\n    case lasso s of\n    None \\<Rightarrow>\n      \\<not> (\\<exists>v0\\<in>V0.\n                 \\<exists>v.\n                    (v0, v) \\<in> E\\<^sup>* \\<and>\n                    accpt v \\<and> (v, v) \\<in> E\\<^sup>+)\n    | Some (pr, pl) \\<Rightarrow>\n        \\<exists>v0\\<in>V0.\n           \\<exists>v.\n              path E v0 pr v \\<and>\n              accpt v \\<and> pl \\<noteq> [] \\<and> path E v pl v\n 2. \\<And>a.\n       lasso s = Some a \\<Longrightarrow>\n       case lasso s of\n       None \\<Rightarrow>\n         \\<not> (\\<exists>v0\\<in>V0.\n                    \\<exists>v.\n                       (v0, v) \\<in> E\\<^sup>* \\<and>\n                       accpt v \\<and> (v, v) \\<in> E\\<^sup>+)\n       | Some (pr, pl) \\<Rightarrow>\n           \\<exists>v0\\<in>V0.\n              \\<exists>v.\n                 path E v0 pr v \\<and>\n                 accpt v \\<and> pl \\<noteq> [] \\<and> path E v pl v", "moreover"], ["proof (state)\nthis:\n  lasso s = None\n\ngoal (2 subgoals):\n 1. lasso s = None \\<Longrightarrow>\n    case lasso s of\n    None \\<Rightarrow>\n      \\<not> (\\<exists>v0\\<in>V0.\n                 \\<exists>v.\n                    (v0, v) \\<in> E\\<^sup>* \\<and>\n                    accpt v \\<and> (v, v) \\<in> E\\<^sup>+)\n    | Some (pr, pl) \\<Rightarrow>\n        \\<exists>v0\\<in>V0.\n           \\<exists>v.\n              path E v0 pr v \\<and>\n              accpt v \\<and> pl \\<noteq> [] \\<and> path E v pl v\n 2. \\<And>a.\n       lasso s = Some a \\<Longrightarrow>\n       case lasso s of\n       None \\<Rightarrow>\n         \\<not> (\\<exists>v0\\<in>V0.\n                    \\<exists>v.\n                       (v0, v) \\<in> E\\<^sup>* \\<and>\n                       accpt v \\<and> (v, v) \\<in> E\\<^sup>+)\n       | Some (pr, pl) \\<Rightarrow>\n           \\<exists>v0\\<in>V0.\n              \\<exists>v.\n                 path E v0 pr v \\<and>\n                 accpt v \\<and> pl \\<noteq> [] \\<and> path E v pl v", "{"], ["proof (state)\nthis:\n  lasso s = None\n\ngoal (2 subgoals):\n 1. lasso s = None \\<Longrightarrow>\n    case lasso s of\n    None \\<Rightarrow>\n      \\<not> (\\<exists>v0\\<in>V0.\n                 \\<exists>v.\n                    (v0, v) \\<in> E\\<^sup>* \\<and>\n                    accpt v \\<and> (v, v) \\<in> E\\<^sup>+)\n    | Some (pr, pl) \\<Rightarrow>\n        \\<exists>v0\\<in>V0.\n           \\<exists>v.\n              path E v0 pr v \\<and>\n              accpt v \\<and> pl \\<noteq> [] \\<and> path E v pl v\n 2. \\<And>a.\n       lasso s = Some a \\<Longrightarrow>\n       case lasso s of\n       None \\<Rightarrow>\n         \\<not> (\\<exists>v0\\<in>V0.\n                    \\<exists>v.\n                       (v0, v) \\<in> E\\<^sup>* \\<and>\n                       accpt v \\<and> (v, v) \\<in> E\\<^sup>+)\n       | Some (pr, pl) \\<Rightarrow>\n           \\<exists>v0\\<in>V0.\n              \\<exists>v.\n                 path E v0 pr v \\<and>\n                 accpt v \\<and> pl \\<noteq> [] \\<and> path E v pl v", "fix v v0"], ["proof (state)\ngoal (2 subgoals):\n 1. lasso s = None \\<Longrightarrow>\n    case lasso s of\n    None \\<Rightarrow>\n      \\<not> (\\<exists>v0\\<in>V0.\n                 \\<exists>v.\n                    (v0, v) \\<in> E\\<^sup>* \\<and>\n                    accpt v \\<and> (v, v) \\<in> E\\<^sup>+)\n    | Some (pr, pl) \\<Rightarrow>\n        \\<exists>v0\\<in>V0.\n           \\<exists>v.\n              path E v0 pr v \\<and>\n              accpt v \\<and> pl \\<noteq> [] \\<and> path E v pl v\n 2. \\<And>a.\n       lasso s = Some a \\<Longrightarrow>\n       case lasso s of\n       None \\<Rightarrow>\n         \\<not> (\\<exists>v0\\<in>V0.\n                    \\<exists>v.\n                       (v0, v) \\<in> E\\<^sup>* \\<and>\n                       accpt v \\<and> (v, v) \\<in> E\\<^sup>+)\n       | Some (pr, pl) \\<Rightarrow>\n           \\<exists>v0\\<in>V0.\n              \\<exists>v.\n                 path E v0 pr v \\<and>\n                 accpt v \\<and> pl \\<noteq> [] \\<and> path E v pl v", "assume \"v0 \\<in> V0\" \"(v0,v) \\<in> E\\<^sup>*\" \"accpt v\" \"(v,v) \\<in> E\\<^sup>+\""], ["proof (state)\nthis:\n  v0 \\<in> V0\n  (v0, v) \\<in> E\\<^sup>*\n  accpt v\n  (v, v) \\<in> E\\<^sup>+\n\ngoal (2 subgoals):\n 1. lasso s = None \\<Longrightarrow>\n    case lasso s of\n    None \\<Rightarrow>\n      \\<not> (\\<exists>v0\\<in>V0.\n                 \\<exists>v.\n                    (v0, v) \\<in> E\\<^sup>* \\<and>\n                    accpt v \\<and> (v, v) \\<in> E\\<^sup>+)\n    | Some (pr, pl) \\<Rightarrow>\n        \\<exists>v0\\<in>V0.\n           \\<exists>v.\n              path E v0 pr v \\<and>\n              accpt v \\<and> pl \\<noteq> [] \\<and> path E v pl v\n 2. \\<And>a.\n       lasso s = Some a \\<Longrightarrow>\n       case lasso s of\n       None \\<Rightarrow>\n         \\<not> (\\<exists>v0\\<in>V0.\n                    \\<exists>v.\n                       (v0, v) \\<in> E\\<^sup>* \\<and>\n                       accpt v \\<and> (v, v) \\<in> E\\<^sup>+)\n       | Some (pr, pl) \\<Rightarrow>\n           \\<exists>v0\\<in>V0.\n              \\<exists>v.\n                 path E v0 pr v \\<and>\n                 accpt v \\<and> pl \\<noteq> [] \\<and> path E v pl v", "moreover"], ["proof (state)\nthis:\n  v0 \\<in> V0\n  (v0, v) \\<in> E\\<^sup>*\n  accpt v\n  (v, v) \\<in> E\\<^sup>+\n\ngoal (2 subgoals):\n 1. lasso s = None \\<Longrightarrow>\n    case lasso s of\n    None \\<Rightarrow>\n      \\<not> (\\<exists>v0\\<in>V0.\n                 \\<exists>v.\n                    (v0, v) \\<in> E\\<^sup>* \\<and>\n                    accpt v \\<and> (v, v) \\<in> E\\<^sup>+)\n    | Some (pr, pl) \\<Rightarrow>\n        \\<exists>v0\\<in>V0.\n           \\<exists>v.\n              path E v0 pr v \\<and>\n              accpt v \\<and> pl \\<noteq> [] \\<and> path E v pl v\n 2. \\<And>a.\n       lasso s = Some a \\<Longrightarrow>\n       case lasso s of\n       None \\<Rightarrow>\n         \\<not> (\\<exists>v0\\<in>V0.\n                    \\<exists>v.\n                       (v0, v) \\<in> E\\<^sup>* \\<and>\n                       accpt v \\<and> (v, v) \\<in> E\\<^sup>+)\n       | Some (pr, pl) \\<Rightarrow>\n           \\<exists>v0\\<in>V0.\n              \\<exists>v.\n                 path E v0 pr v \\<and>\n                 accpt v \\<and> pl \\<noteq> [] \\<and> path E v pl v", "hence \"v \\<in> reachable\""], ["proof (prove)\nusing this:\n  v0 \\<in> V0\n  (v0, v) \\<in> E\\<^sup>*\n  accpt v\n  (v, v) \\<in> E\\<^sup>+\n\ngoal (1 subgoal):\n 1. v \\<in> reachable", "by (auto)"], ["proof (state)\nthis:\n  v \\<in> reachable\n\ngoal (2 subgoals):\n 1. lasso s = None \\<Longrightarrow>\n    case lasso s of\n    None \\<Rightarrow>\n      \\<not> (\\<exists>v0\\<in>V0.\n                 \\<exists>v.\n                    (v0, v) \\<in> E\\<^sup>* \\<and>\n                    accpt v \\<and> (v, v) \\<in> E\\<^sup>+)\n    | Some (pr, pl) \\<Rightarrow>\n        \\<exists>v0\\<in>V0.\n           \\<exists>v.\n              path E v0 pr v \\<and>\n              accpt v \\<and> pl \\<noteq> [] \\<and> path E v pl v\n 2. \\<And>a.\n       lasso s = Some a \\<Longrightarrow>\n       case lasso s of\n       None \\<Rightarrow>\n         \\<not> (\\<exists>v0\\<in>V0.\n                    \\<exists>v.\n                       (v0, v) \\<in> E\\<^sup>* \\<and>\n                       accpt v \\<and> (v, v) \\<in> E\\<^sup>+)\n       | Some (pr, pl) \\<Rightarrow>\n           \\<exists>v0\\<in>V0.\n              \\<exists>v.\n                 path E v0 pr v \\<and>\n                 accpt v \\<and> pl \\<noteq> [] \\<and> path E v pl v", "with nc_finished_eq_reachable NC None"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<not> cond s; \\<not> is_break blue_dfs_params s\\<rbrakk>\n  \\<Longrightarrow> dom (finished s) = reachable\n  \\<not> cond s\n  lasso s = None\n  v \\<in> reachable", "have \"v \\<in> dom (finished s)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> cond s; \\<not> is_break blue_dfs_params s\\<rbrakk>\n  \\<Longrightarrow> dom (finished s) = reachable\n  \\<not> cond s\n  lasso s = None\n  v \\<in> reachable\n\ngoal (1 subgoal):\n 1. v \\<in> dom (finished s)", "by simp"], ["proof (state)\nthis:\n  v \\<in> dom (finished s)\n\ngoal (2 subgoals):\n 1. lasso s = None \\<Longrightarrow>\n    case lasso s of\n    None \\<Rightarrow>\n      \\<not> (\\<exists>v0\\<in>V0.\n                 \\<exists>v.\n                    (v0, v) \\<in> E\\<^sup>* \\<and>\n                    accpt v \\<and> (v, v) \\<in> E\\<^sup>+)\n    | Some (pr, pl) \\<Rightarrow>\n        \\<exists>v0\\<in>V0.\n           \\<exists>v.\n              path E v0 pr v \\<and>\n              accpt v \\<and> pl \\<noteq> [] \\<and> path E v pl v\n 2. \\<And>a.\n       lasso s = Some a \\<Longrightarrow>\n       case lasso s of\n       None \\<Rightarrow>\n         \\<not> (\\<exists>v0\\<in>V0.\n                    \\<exists>v.\n                       (v0, v) \\<in> E\\<^sup>* \\<and>\n                       accpt v \\<and> (v, v) \\<in> E\\<^sup>+)\n       | Some (pr, pl) \\<Rightarrow>\n           \\<exists>v0\\<in>V0.\n              \\<exists>v.\n                 path E v0 pr v \\<and>\n                 accpt v \\<and> pl \\<noteq> [] \\<and> path E v pl v", "moreover"], ["proof (state)\nthis:\n  v \\<in> dom (finished s)\n\ngoal (2 subgoals):\n 1. lasso s = None \\<Longrightarrow>\n    case lasso s of\n    None \\<Rightarrow>\n      \\<not> (\\<exists>v0\\<in>V0.\n                 \\<exists>v.\n                    (v0, v) \\<in> E\\<^sup>* \\<and>\n                    accpt v \\<and> (v, v) \\<in> E\\<^sup>+)\n    | Some (pr, pl) \\<Rightarrow>\n        \\<exists>v0\\<in>V0.\n           \\<exists>v.\n              path E v0 pr v \\<and>\n              accpt v \\<and> pl \\<noteq> [] \\<and> path E v pl v\n 2. \\<And>a.\n       lasso s = Some a \\<Longrightarrow>\n       case lasso s of\n       None \\<Rightarrow>\n         \\<not> (\\<exists>v0\\<in>V0.\n                    \\<exists>v.\n                       (v0, v) \\<in> E\\<^sup>* \\<and>\n                       accpt v \\<and> (v, v) \\<in> E\\<^sup>+)\n       | Some (pr, pl) \\<Rightarrow>\n           \\<exists>v0\\<in>V0.\n              \\<exists>v.\n                 path E v0 pr v \\<and>\n                 accpt v \\<and> pl \\<noteq> [] \\<and> path E v pl v", "note no_accpt_cycle_in_finish None"], ["proof (state)\nthis:\n  \\<lbrakk>lasso s = None; accpt ?v; ?v \\<in> dom (finished s)\\<rbrakk>\n  \\<Longrightarrow> (?v, ?v) \\<notin> E\\<^sup>+\n  lasso s = None\n\ngoal (2 subgoals):\n 1. lasso s = None \\<Longrightarrow>\n    case lasso s of\n    None \\<Rightarrow>\n      \\<not> (\\<exists>v0\\<in>V0.\n                 \\<exists>v.\n                    (v0, v) \\<in> E\\<^sup>* \\<and>\n                    accpt v \\<and> (v, v) \\<in> E\\<^sup>+)\n    | Some (pr, pl) \\<Rightarrow>\n        \\<exists>v0\\<in>V0.\n           \\<exists>v.\n              path E v0 pr v \\<and>\n              accpt v \\<and> pl \\<noteq> [] \\<and> path E v pl v\n 2. \\<And>a.\n       lasso s = Some a \\<Longrightarrow>\n       case lasso s of\n       None \\<Rightarrow>\n         \\<not> (\\<exists>v0\\<in>V0.\n                    \\<exists>v.\n                       (v0, v) \\<in> E\\<^sup>* \\<and>\n                       accpt v \\<and> (v, v) \\<in> E\\<^sup>+)\n       | Some (pr, pl) \\<Rightarrow>\n           \\<exists>v0\\<in>V0.\n              \\<exists>v.\n                 path E v0 pr v \\<and>\n                 accpt v \\<and> pl \\<noteq> [] \\<and> path E v pl v", "ultimately"], ["proof (chain)\npicking this:\n  v0 \\<in> V0\n  (v0, v) \\<in> E\\<^sup>*\n  accpt v\n  (v, v) \\<in> E\\<^sup>+\n  v \\<in> dom (finished s)\n  \\<lbrakk>lasso s = None; accpt ?v; ?v \\<in> dom (finished s)\\<rbrakk>\n  \\<Longrightarrow> (?v, ?v) \\<notin> E\\<^sup>+\n  lasso s = None", "have False"], ["proof (prove)\nusing this:\n  v0 \\<in> V0\n  (v0, v) \\<in> E\\<^sup>*\n  accpt v\n  (v, v) \\<in> E\\<^sup>+\n  v \\<in> dom (finished s)\n  \\<lbrakk>lasso s = None; accpt ?v; ?v \\<in> dom (finished s)\\<rbrakk>\n  \\<Longrightarrow> (?v, ?v) \\<notin> E\\<^sup>+\n  lasso s = None\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. lasso s = None \\<Longrightarrow>\n    case lasso s of\n    None \\<Rightarrow>\n      \\<not> (\\<exists>v0\\<in>V0.\n                 \\<exists>v.\n                    (v0, v) \\<in> E\\<^sup>* \\<and>\n                    accpt v \\<and> (v, v) \\<in> E\\<^sup>+)\n    | Some (pr, pl) \\<Rightarrow>\n        \\<exists>v0\\<in>V0.\n           \\<exists>v.\n              path E v0 pr v \\<and>\n              accpt v \\<and> pl \\<noteq> [] \\<and> path E v pl v\n 2. \\<And>a.\n       lasso s = Some a \\<Longrightarrow>\n       case lasso s of\n       None \\<Rightarrow>\n         \\<not> (\\<exists>v0\\<in>V0.\n                    \\<exists>v.\n                       (v0, v) \\<in> E\\<^sup>* \\<and>\n                       accpt v \\<and> (v, v) \\<in> E\\<^sup>+)\n       | Some (pr, pl) \\<Rightarrow>\n           \\<exists>v0\\<in>V0.\n              \\<exists>v.\n                 path E v0 pr v \\<and>\n                 accpt v \\<and> pl \\<noteq> [] \\<and> path E v pl v", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?v0.11 \\<in> V0; (?v0.11, ?v11) \\<in> E\\<^sup>*; accpt ?v11;\n   (?v11, ?v11) \\<in> E\\<^sup>+\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (2 subgoals):\n 1. lasso s = None \\<Longrightarrow>\n    case lasso s of\n    None \\<Rightarrow>\n      \\<not> (\\<exists>v0\\<in>V0.\n                 \\<exists>v.\n                    (v0, v) \\<in> E\\<^sup>* \\<and>\n                    accpt v \\<and> (v, v) \\<in> E\\<^sup>+)\n    | Some (pr, pl) \\<Rightarrow>\n        \\<exists>v0\\<in>V0.\n           \\<exists>v.\n              path E v0 pr v \\<and>\n              accpt v \\<and> pl \\<noteq> [] \\<and> path E v pl v\n 2. \\<And>a.\n       lasso s = Some a \\<Longrightarrow>\n       case lasso s of\n       None \\<Rightarrow>\n         \\<not> (\\<exists>v0\\<in>V0.\n                    \\<exists>v.\n                       (v0, v) \\<in> E\\<^sup>* \\<and>\n                       accpt v \\<and> (v, v) \\<in> E\\<^sup>+)\n       | Some (pr, pl) \\<Rightarrow>\n           \\<exists>v0\\<in>V0.\n              \\<exists>v.\n                 path E v0 pr v \\<and>\n                 accpt v \\<and> pl \\<noteq> [] \\<and> path E v pl v", "ultimately"], ["proof (chain)\npicking this:\n  lasso s = None\n  \\<lbrakk>?v0.11 \\<in> V0; (?v0.11, ?v11) \\<in> E\\<^sup>*; accpt ?v11;\n   (?v11, ?v11) \\<in> E\\<^sup>+\\<rbrakk>\n  \\<Longrightarrow> False", "show ?thesis"], ["proof (prove)\nusing this:\n  lasso s = None\n  \\<lbrakk>?v0.11 \\<in> V0; (?v0.11, ?v11) \\<in> E\\<^sup>*; accpt ?v11;\n   (?v11, ?v11) \\<in> E\\<^sup>+\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. case lasso s of\n    None \\<Rightarrow>\n      \\<not> (\\<exists>v0\\<in>V0.\n                 \\<exists>v.\n                    (v0, v) \\<in> E\\<^sup>* \\<and>\n                    accpt v \\<and> (v, v) \\<in> E\\<^sup>+)\n    | Some (pr, pl) \\<Rightarrow>\n        \\<exists>v0\\<in>V0.\n           \\<exists>v.\n              path E v0 pr v \\<and>\n              accpt v \\<and> pl \\<noteq> [] \\<and> path E v pl v", "by auto"], ["proof (state)\nthis:\n  case lasso s of\n  None \\<Rightarrow>\n    \\<not> (\\<exists>v0\\<in>V0.\n               \\<exists>v.\n                  (v0, v) \\<in> E\\<^sup>* \\<and>\n                  accpt v \\<and> (v, v) \\<in> E\\<^sup>+)\n  | Some (pr, pl) \\<Rightarrow>\n      \\<exists>v0\\<in>V0.\n         \\<exists>v.\n            path E v0 pr v \\<and>\n            accpt v \\<and> pl \\<noteq> [] \\<and> path E v pl v\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       lasso s = Some a \\<Longrightarrow>\n       case lasso s of\n       None \\<Rightarrow>\n         \\<not> (\\<exists>v0\\<in>V0.\n                    \\<exists>v.\n                       (v0, v) \\<in> E\\<^sup>* \\<and>\n                       accpt v \\<and> (v, v) \\<in> E\\<^sup>+)\n       | Some (pr, pl) \\<Rightarrow>\n           \\<exists>v0\\<in>V0.\n              \\<exists>v.\n                 path E v0 pr v \\<and>\n                 accpt v \\<and> pl \\<noteq> [] \\<and> path E v pl v", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       lasso s = Some a \\<Longrightarrow>\n       case lasso s of\n       None \\<Rightarrow>\n         \\<not> (\\<exists>v0\\<in>V0.\n                    \\<exists>v.\n                       (v0, v) \\<in> E\\<^sup>* \\<and>\n                       accpt v \\<and> (v, v) \\<in> E\\<^sup>+)\n       | Some (pr, pl) \\<Rightarrow>\n           \\<exists>v0\\<in>V0.\n              \\<exists>v.\n                 path E v0 pr v \\<and>\n                 accpt v \\<and> pl \\<noteq> [] \\<and> path E v pl v", "case (Some prpl)"], ["proof (state)\nthis:\n  lasso s = Some prpl\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       lasso s = Some a \\<Longrightarrow>\n       case lasso s of\n       None \\<Rightarrow>\n         \\<not> (\\<exists>v0\\<in>V0.\n                    \\<exists>v.\n                       (v0, v) \\<in> E\\<^sup>* \\<and>\n                       accpt v \\<and> (v, v) \\<in> E\\<^sup>+)\n       | Some (pr, pl) \\<Rightarrow>\n           \\<exists>v0\\<in>V0.\n              \\<exists>v.\n                 path E v0 pr v \\<and>\n                 accpt v \\<and> pl \\<noteq> [] \\<and> path E v pl v", "with s_lasso_inv"], ["proof (chain)\npicking this:\n  lasso_inv s\n  lasso s = Some prpl", "show ?thesis"], ["proof (prove)\nusing this:\n  lasso_inv s\n  lasso s = Some prpl\n\ngoal (1 subgoal):\n 1. case lasso s of\n    None \\<Rightarrow>\n      \\<not> (\\<exists>v0\\<in>V0.\n                 \\<exists>v.\n                    (v0, v) \\<in> E\\<^sup>* \\<and>\n                    accpt v \\<and> (v, v) \\<in> E\\<^sup>+)\n    | Some (pr, pl) \\<Rightarrow>\n        \\<exists>v0\\<in>V0.\n           \\<exists>v.\n              path E v0 pr v \\<and>\n              accpt v \\<and> pl \\<noteq> [] \\<and> path E v pl v", "by (cases prpl) \n         (auto intro: path_is_rtrancl path_is_trancl simp: lasso_inv_def)"], ["proof (state)\nthis:\n  case lasso s of\n  None \\<Rightarrow>\n    \\<not> (\\<exists>v0\\<in>V0.\n               \\<exists>v.\n                  (v0, v) \\<in> E\\<^sup>* \\<and>\n                  accpt v \\<and> (v, v) \\<in> E\\<^sup>+)\n  | Some (pr, pl) \\<Rightarrow>\n      \\<exists>v0\\<in>V0.\n         \\<exists>v.\n            path E v0 pr v \\<and>\n            accpt v \\<and> pl \\<noteq> [] \\<and> path E v pl v\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsection \\<open>Interface\\<close>"], ["", "interpretation BlueDFS_defs for G accpt"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "definition \"nested_dfs_spec G accpt \\<equiv> \\<lambda>r. case r of\n  None \\<Rightarrow> \\<not>(\\<exists>v0\\<in>g_V0 G. \\<exists>v. (v0,v) \\<in> (g_E G)\\<^sup>* \\<and> accpt v \\<and> (v,v) \\<in> (g_E G)\\<^sup>+)\n| Some (pr,pl) \\<Rightarrow> (\\<exists>v0\\<in>g_V0 G. \\<exists>v. \n    path (g_E G) v0 pr v \\<and> accpt v \\<and> pl\\<noteq>[] \\<and> path (g_E G) v pl v)\""], ["", "definition \"nested_dfs G accpt \\<equiv> do {\n  ASSERT (fb_graph G);\n  s \\<leftarrow> it_dfs TYPE('a) G accpt;\n  RETURN (lasso s)\n}\""], ["", "theorem nested_dfs_correct: \n  assumes \"fb_graph G\"\n  shows \"nested_dfs G accpt \\<le> SPEC (nested_dfs_spec G accpt)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nested_dfs G accpt \\<le> SPEC (nested_dfs_spec G accpt)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. nested_dfs G accpt \\<le> SPEC (nested_dfs_spec G accpt)", "interpret fb_graph G"], ["proof (prove)\ngoal (1 subgoal):\n 1. fb_graph G", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. nested_dfs G accpt \\<le> SPEC (nested_dfs_spec G accpt)", "interpret BlueDFS G accpt"], ["proof (prove)\ngoal (1 subgoal):\n 1. BlueDFS G", "by unfold_locales"], ["proof (state)\ngoal (1 subgoal):\n 1. nested_dfs G accpt \\<le> SPEC (nested_dfs_spec G accpt)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. nested_dfs G accpt \\<le> SPEC (nested_dfs_spec G accpt)", "unfolding nested_dfs_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ASSERT (fb_graph G) \\<bind>\n    (\\<lambda>_.\n        param_DFS_defs.it_dfs G\n         (BlueDFS_defs.blue_dfs_params G accpt) \\<bind>\n        (\\<lambda>s. RETURN (lasso s)))\n    \\<le> SPEC (nested_dfs_spec G accpt)", "apply (refine_rcg refine_vcg)"], ["proof (prove)\ngoal (2 subgoals):\n 1. fb_graph G\n 2. fb_graph G \\<Longrightarrow>\n    param_DFS_defs.it_dfs G (BlueDFS_defs.blue_dfs_params G accpt)\n    \\<le> SPEC\n           (\\<lambda>s.\n               RETURN (lasso s) \\<le> SPEC (nested_dfs_spec G accpt))", "apply fact"], ["proof (prove)\ngoal (1 subgoal):\n 1. fb_graph G \\<Longrightarrow>\n    param_DFS_defs.it_dfs G (BlueDFS_defs.blue_dfs_params G accpt)\n    \\<le> SPEC\n           (\\<lambda>s.\n               RETURN (lasso s) \\<le> SPEC (nested_dfs_spec G accpt))", "apply (rule weaken_SPEC[OF it_dfs_correct])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>fb_graph G;\n        DFS_invar G (BlueDFS_defs.blue_dfs_params G accpt) x \\<and>\n        \\<not> param_DFS_defs.cond G (BlueDFS_defs.blue_dfs_params G accpt)\n                x\\<rbrakk>\n       \\<Longrightarrow> RETURN (lasso x)\n                         \\<le> SPEC (nested_dfs_spec G accpt)", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>fb_graph G; BlueDFS_invar G accpt x;\n        \\<not> param_DFS_defs.cond G (BlueDFS_defs.blue_dfs_params G accpt)\n                x\\<rbrakk>\n       \\<Longrightarrow> nested_dfs_spec G accpt (lasso x)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>fb_graph G; BlueDFS_invar G accpt x;\n        \\<not> param_DFS_defs.cond G (BlueDFS_defs.blue_dfs_params G accpt)\n                x\\<rbrakk>\n       \\<Longrightarrow> nested_dfs_spec G accpt (lasso x)", "fix s"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>fb_graph G; BlueDFS_invar G accpt x;\n        \\<not> param_DFS_defs.cond G (BlueDFS_defs.blue_dfs_params G accpt)\n                x\\<rbrakk>\n       \\<Longrightarrow> nested_dfs_spec G accpt (lasso x)", "assume \"BlueDFS_invar G accpt s\""], ["proof (state)\nthis:\n  BlueDFS_invar G accpt s\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>fb_graph G; BlueDFS_invar G accpt x;\n        \\<not> param_DFS_defs.cond G (BlueDFS_defs.blue_dfs_params G accpt)\n                x\\<rbrakk>\n       \\<Longrightarrow> nested_dfs_spec G accpt (lasso x)", "then"], ["proof (chain)\npicking this:\n  BlueDFS_invar G accpt s", "interpret BlueDFS_invar G accpt s"], ["proof (prove)\nusing this:\n  BlueDFS_invar G accpt s\n\ngoal (1 subgoal):\n 1. BlueDFS_invar G accpt s", "."], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>fb_graph G; BlueDFS_invar G accpt x;\n        \\<not> param_DFS_defs.cond G (BlueDFS_defs.blue_dfs_params G accpt)\n                x\\<rbrakk>\n       \\<Longrightarrow> nested_dfs_spec G accpt (lasso x)", "assume \"\\<not>cond TYPE('b) G accpt s\""], ["proof (state)\nthis:\n  \\<not> param_DFS_defs.cond G (BlueDFS_defs.blue_dfs_params G accpt) s\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>fb_graph G; BlueDFS_invar G accpt x;\n        \\<not> param_DFS_defs.cond G (BlueDFS_defs.blue_dfs_params G accpt)\n                x\\<rbrakk>\n       \\<Longrightarrow> nested_dfs_spec G accpt (lasso x)", "from blue_dfs_correct[OF this]"], ["proof (chain)\npicking this:\n  case lasso s of\n  None \\<Rightarrow>\n    \\<not> (\\<exists>v0\\<in>g_V0 G.\n               \\<exists>v.\n                  (v0, v) \\<in> (g_E G)\\<^sup>* \\<and>\n                  accpt v \\<and> (v, v) \\<in> (g_E G)\\<^sup>+)\n  | Some (pr, pl) \\<Rightarrow>\n      \\<exists>v0\\<in>g_V0 G.\n         \\<exists>v.\n            path (g_E G) v0 pr v \\<and>\n            accpt v \\<and> pl \\<noteq> [] \\<and> path (g_E G) v pl v", "show \"nested_dfs_spec G accpt (lasso s)\""], ["proof (prove)\nusing this:\n  case lasso s of\n  None \\<Rightarrow>\n    \\<not> (\\<exists>v0\\<in>g_V0 G.\n               \\<exists>v.\n                  (v0, v) \\<in> (g_E G)\\<^sup>* \\<and>\n                  accpt v \\<and> (v, v) \\<in> (g_E G)\\<^sup>+)\n  | Some (pr, pl) \\<Rightarrow>\n      \\<exists>v0\\<in>g_V0 G.\n         \\<exists>v.\n            path (g_E G) v0 pr v \\<and>\n            accpt v \\<and> pl \\<noteq> [] \\<and> path (g_E G) v pl v\n\ngoal (1 subgoal):\n 1. nested_dfs_spec G accpt (lasso s)", "unfolding nested_dfs_spec_def"], ["proof (prove)\nusing this:\n  case lasso s of\n  None \\<Rightarrow>\n    \\<not> (\\<exists>v0\\<in>g_V0 G.\n               \\<exists>v.\n                  (v0, v) \\<in> (g_E G)\\<^sup>* \\<and>\n                  accpt v \\<and> (v, v) \\<in> (g_E G)\\<^sup>+)\n  | Some (pr, pl) \\<Rightarrow>\n      \\<exists>v0\\<in>g_V0 G.\n         \\<exists>v.\n            path (g_E G) v0 pr v \\<and>\n            accpt v \\<and> pl \\<noteq> [] \\<and> path (g_E G) v pl v\n\ngoal (1 subgoal):\n 1. case lasso s of\n    None \\<Rightarrow>\n      \\<not> (\\<exists>v0\\<in>g_V0 G.\n                 \\<exists>v.\n                    (v0, v) \\<in> (g_E G)\\<^sup>* \\<and>\n                    accpt v \\<and> (v, v) \\<in> (g_E G)\\<^sup>+)\n    | Some (pr, pl) \\<Rightarrow>\n        \\<exists>v0\\<in>g_V0 G.\n           \\<exists>v.\n              path (g_E G) v0 pr v \\<and>\n              accpt v \\<and> pl \\<noteq> [] \\<and> path (g_E G) v pl v", "by simp"], ["proof (state)\nthis:\n  nested_dfs_spec G accpt (lasso s)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  nested_dfs G accpt \\<le> SPEC (nested_dfs_spec G accpt)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Implementation\\<close>"], ["", "record 'v bdfs_state_impl = \"'v simple_state\" +\n  lasso_impl :: \"('v list \\<times> 'v list) option\"\n  red_impl :: \"'v set\""], ["", "definition \"bdfs_erel \\<equiv> {(\\<lparr>lasso_impl=li,red_impl=ri\\<rparr>,\\<lparr>lasso=l, red=r\\<rparr>) \n  | li ri l r. li=l \\<and> ri=r}\""], ["", "abbreviation \"bdfs_rel \\<equiv> \\<langle>bdfs_erel\\<rangle>simple_state_rel\""], ["", "definition mk_blue_witness_impl\n  :: \"'v bdfs_state_impl \\<Rightarrow> 'v fpr_result \\<Rightarrow> ('v,unit) bdfs_state_impl_ext\"\n  where\n  \"mk_blue_witness_impl s redS \\<equiv> \n    case redS of\n      Inl R' \\<Rightarrow> \\<lparr> lasso_impl = None, red_impl = (R' \\<^cancel>\\<open>\\<union> red_impl s\\<close>) \\<rparr>\n    | Inr (vs, v) \\<Rightarrow> let \n        rs = rev (map fst (CAST (ss_stack s))) \n      in \\<lparr> \n        lasso_impl = Some (rs, vs@dropWhileNot v rs), \n        red_impl = red_impl s\\<rparr>\""], ["", "lemma mk_blue_witness_impl[refine]:\n  \"\\<lbrakk> (si,s)\\<in>bdfs_rel; (ri,r)\\<in>\\<langle>Id, \\<langle>Id\\<rangle>list_rel \\<times>\\<^sub>r Id\\<rangle>sum_rel \\<rbrakk> \n  \\<Longrightarrow> (mk_blue_witness_impl si ri, mk_blue_witness s r)\\<in>bdfs_erel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(si, s) \\<in> bdfs_rel;\n     (ri, r) \\<in> \\<langle>Id,\n     \\<langle>Id\\<rangle>list_rel \\<times>\\<^sub>r\n     Id\\<rangle>sum_rel\\<rbrakk>\n    \\<Longrightarrow> (mk_blue_witness_impl si ri, mk_blue_witness s r)\n                      \\<in> bdfs_erel", "unfolding mk_blue_witness_impl_def mk_blue_witness_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(si, s) \\<in> bdfs_rel;\n     (ri, r) \\<in> \\<langle>Id,\n     \\<langle>Id\\<rangle>list_rel \\<times>\\<^sub>r\n     Id\\<rangle>sum_rel\\<rbrakk>\n    \\<Longrightarrow> (case ri of\n                       Inl R' \\<Rightarrow>\n                         \\<lparr>lasso_impl = None, red_impl = R'\\<rparr>\n                       | Inr (vs, v) \\<Rightarrow>\n                           let rs = rev (map fst (CAST (ss_stack si)))\n                           in \\<lparr>lasso_impl =\n  Some (rs, vs @ dropWhileNot v rs),\n                                 red_impl = red_impl si\\<rparr>,\n                       case r of\n                       Inl R' \\<Rightarrow>\n                         \\<lparr>lasso = None, red = R'\\<rparr>\n                       | Inr (vs, v) \\<Rightarrow>\n                           let rs = rev (stack s)\n                           in \\<lparr>lasso =\n  Some (rs, vs @ dropWhileNot v rs),\n                                 red = red s\\<rparr>)\n                      \\<in> bdfs_erel", "apply parametricity"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>(si, s) \\<in> bdfs_rel;\n     (ri, r) \\<in> \\<langle>Id,\n     \\<langle>Id\\<rangle>list_rel \\<times>\\<^sub>r\n     Id\\<rangle>sum_rel\\<rbrakk>\n    \\<Longrightarrow> (\\<lambda>R'.\n                          \\<lparr>lasso_impl = None, red_impl = R'\\<rparr>,\n                       \\<lambda>R'. \\<lparr>lasso = None, red = R'\\<rparr>)\n                      \\<in> Id \\<rightarrow> bdfs_erel\n 2. \\<And>a a' aa a'a.\n       \\<lbrakk>(si, s) \\<in> bdfs_rel;\n        (ri, r) \\<in> \\<langle>Id,\n        \\<langle>Id\\<rangle>list_rel \\<times>\\<^sub>r Id\\<rangle>sum_rel;\n        (a, a') \\<in> \\<langle>Id\\<rangle>list_rel;\n        (aa, a'a) \\<in> Id\\<rbrakk>\n       \\<Longrightarrow> (map fst (CAST (ss_stack si)), stack s)\n                         \\<in> \\<langle>?R50 a a' aa a'a\\<rangle>list_rel\n 3. \\<And>a a' aa a'a.\n       \\<lbrakk>(si, s) \\<in> bdfs_rel;\n        (ri, r) \\<in> \\<langle>Id,\n        \\<langle>Id\\<rangle>list_rel \\<times>\\<^sub>r Id\\<rangle>sum_rel;\n        (a, a') \\<in> \\<langle>Id\\<rangle>list_rel;\n        (aa, a'a) \\<in> Id\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>rs.\n                             \\<lparr>lasso_impl =\n Some (rs, a @ dropWhileNot aa rs),\n                                red_impl = red_impl si\\<rparr>,\n                          \\<lambda>rs.\n                             \\<lparr>lasso =\n Some (rs, a' @ dropWhileNot a'a rs),\n                                red = red s\\<rparr>)\n                         \\<in> \\<langle>?R50 a a' aa\n   a'a\\<rangle>list_rel \\<rightarrow>\n                               bdfs_erel", "apply (cases si, cases s)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>ss_stack on_stack visited lasso_impl red_impl counter discovered\n       finished pending stack tree_edges back_edges cross_edges lasso red.\n       \\<lbrakk>(si, s) \\<in> bdfs_rel;\n        (ri, r) \\<in> \\<langle>Id,\n        \\<langle>Id\\<rangle>list_rel \\<times>\\<^sub>r Id\\<rangle>sum_rel;\n        si =\n        \\<lparr>ss_stack = ss_stack, on_stack = on_stack, visited = visited,\n           lasso_impl = lasso_impl, red_impl = red_impl\\<rparr>;\n        s =\n        \\<lparr>counter = counter, discovered = discovered,\n           finished = finished, pending = pending, stack = stack,\n           tree_edges = tree_edges, back_edges = back_edges,\n           cross_edges = cross_edges, lasso = lasso,\n           red = red\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>R'.\n                             \\<lparr>lasso_impl = None,\n                                red_impl = R'\\<rparr>,\n                          \\<lambda>R'.\n                             \\<lparr>lasso = None, red = R'\\<rparr>)\n                         \\<in> Id \\<rightarrow> bdfs_erel\n 2. \\<And>a a' aa a'a.\n       \\<lbrakk>(si, s) \\<in> bdfs_rel;\n        (ri, r) \\<in> \\<langle>Id,\n        \\<langle>Id\\<rangle>list_rel \\<times>\\<^sub>r Id\\<rangle>sum_rel;\n        (a, a') \\<in> \\<langle>Id\\<rangle>list_rel;\n        (aa, a'a) \\<in> Id\\<rbrakk>\n       \\<Longrightarrow> (map fst (CAST (ss_stack si)), stack s)\n                         \\<in> \\<langle>?R50 a a' aa a'a\\<rangle>list_rel\n 3. \\<And>a a' aa a'a.\n       \\<lbrakk>(si, s) \\<in> bdfs_rel;\n        (ri, r) \\<in> \\<langle>Id,\n        \\<langle>Id\\<rangle>list_rel \\<times>\\<^sub>r Id\\<rangle>sum_rel;\n        (a, a') \\<in> \\<langle>Id\\<rangle>list_rel;\n        (aa, a'a) \\<in> Id\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>rs.\n                             \\<lparr>lasso_impl =\n Some (rs, a @ dropWhileNot aa rs),\n                                red_impl = red_impl si\\<rparr>,\n                          \\<lambda>rs.\n                             \\<lparr>lasso =\n Some (rs, a' @ dropWhileNot a'a rs),\n                                red = red s\\<rparr>)\n                         \\<in> \\<langle>?R50 a a' aa\n   a'a\\<rangle>list_rel \\<rightarrow>\n                               bdfs_erel", "apply (auto simp: bdfs_erel_def simple_state_rel_def) []"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(si, s) \\<in> bdfs_rel;\n        (ri, r) \\<in> \\<langle>Id,\n        \\<langle>Id\\<rangle>list_rel \\<times>\\<^sub>r Id\\<rangle>sum_rel;\n        (a, a') \\<in> \\<langle>Id\\<rangle>list_rel;\n        (aa, a'a) \\<in> Id\\<rbrakk>\n       \\<Longrightarrow> (map fst (CAST (ss_stack si)), stack s)\n                         \\<in> \\<langle>?R50 a a' aa a'a\\<rangle>list_rel\n 2. \\<And>a a' aa a'a.\n       \\<lbrakk>(si, s) \\<in> bdfs_rel;\n        (ri, r) \\<in> \\<langle>Id,\n        \\<langle>Id\\<rangle>list_rel \\<times>\\<^sub>r Id\\<rangle>sum_rel;\n        (a, a') \\<in> \\<langle>Id\\<rangle>list_rel;\n        (aa, a'a) \\<in> Id\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>rs.\n                             \\<lparr>lasso_impl =\n Some (rs, a @ dropWhileNot aa rs),\n                                red_impl = red_impl si\\<rparr>,\n                          \\<lambda>rs.\n                             \\<lparr>lasso =\n Some (rs, a' @ dropWhileNot a'a rs),\n                                red = red s\\<rparr>)\n                         \\<in> \\<langle>?R50 a a' aa\n   a'a\\<rangle>list_rel \\<rightarrow>\n                               bdfs_erel", "apply (rule introR[where R=\"\\<langle>Id\\<rangle>list_rel\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(si, s) \\<in> bdfs_rel;\n        (ri, r) \\<in> \\<langle>Id,\n        \\<langle>Id\\<rangle>list_rel \\<times>\\<^sub>r Id\\<rangle>sum_rel;\n        (a, a') \\<in> \\<langle>Id\\<rangle>list_rel;\n        (aa, a'a) \\<in> Id\\<rbrakk>\n       \\<Longrightarrow> (map fst (CAST (ss_stack si)), stack s)\n                         \\<in> \\<langle>Id\\<rangle>list_rel\n 2. \\<And>a a' aa a'a.\n       \\<lbrakk>(si, s) \\<in> bdfs_rel;\n        (ri, r) \\<in> \\<langle>Id,\n        \\<langle>Id\\<rangle>list_rel \\<times>\\<^sub>r Id\\<rangle>sum_rel;\n        (a, a') \\<in> \\<langle>Id\\<rangle>list_rel;\n        (aa, a'a) \\<in> Id\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>rs.\n                             \\<lparr>lasso_impl =\n Some (rs, a @ dropWhileNot aa rs),\n                                red_impl = red_impl si\\<rparr>,\n                          \\<lambda>rs.\n                             \\<lparr>lasso =\n Some (rs, a' @ dropWhileNot a'a rs),\n                                red = red s\\<rparr>)\n                         \\<in> \\<langle>Id\\<rangle>list_rel \\<rightarrow>\n                               bdfs_erel", "apply (cases si, cases s)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a a' aa a'a ss_stacka on_stack visited lasso_impl red_impl counter\n       discovered finished pending stacka tree_edges back_edges cross_edges\n       lasso red.\n       \\<lbrakk>(si, s) \\<in> bdfs_rel;\n        (ri, r) \\<in> \\<langle>Id,\n        \\<langle>Id\\<rangle>list_rel \\<times>\\<^sub>r Id\\<rangle>sum_rel;\n        (a, a') \\<in> \\<langle>Id\\<rangle>list_rel; (aa, a'a) \\<in> Id;\n        si =\n        \\<lparr>ss_stack = ss_stacka, on_stack = on_stack,\n           visited = visited, lasso_impl = lasso_impl,\n           red_impl = red_impl\\<rparr>;\n        s =\n        \\<lparr>counter = counter, discovered = discovered,\n           finished = finished, pending = pending, stack = stacka,\n           tree_edges = tree_edges, back_edges = back_edges,\n           cross_edges = cross_edges, lasso = lasso,\n           red = red\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> (map fst (CAST (ss_stack si)), stack s)\n                         \\<in> \\<langle>Id\\<rangle>list_rel\n 2. \\<And>a a' aa a'a.\n       \\<lbrakk>(si, s) \\<in> bdfs_rel;\n        (ri, r) \\<in> \\<langle>Id,\n        \\<langle>Id\\<rangle>list_rel \\<times>\\<^sub>r Id\\<rangle>sum_rel;\n        (a, a') \\<in> \\<langle>Id\\<rangle>list_rel;\n        (aa, a'a) \\<in> Id\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>rs.\n                             \\<lparr>lasso_impl =\n Some (rs, a @ dropWhileNot aa rs),\n                                red_impl = red_impl si\\<rparr>,\n                          \\<lambda>rs.\n                             \\<lparr>lasso =\n Some (rs, a' @ dropWhileNot a'a rs),\n                                red = red s\\<rparr>)\n                         \\<in> \\<langle>Id\\<rangle>list_rel \\<rightarrow>\n                               bdfs_erel", "apply (auto simp: bdfs_erel_def simple_state_rel_def comp_def) []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(si, s) \\<in> bdfs_rel;\n        (ri, r) \\<in> \\<langle>Id,\n        \\<langle>Id\\<rangle>list_rel \\<times>\\<^sub>r Id\\<rangle>sum_rel;\n        (a, a') \\<in> \\<langle>Id\\<rangle>list_rel;\n        (aa, a'a) \\<in> Id\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>rs.\n                             \\<lparr>lasso_impl =\n Some (rs, a @ dropWhileNot aa rs),\n                                red_impl = red_impl si\\<rparr>,\n                          \\<lambda>rs.\n                             \\<lparr>lasso =\n Some (rs, a' @ dropWhileNot a'a rs),\n                                red = red s\\<rparr>)\n                         \\<in> \\<langle>Id\\<rangle>list_rel \\<rightarrow>\n                               bdfs_erel", "apply (cases si, cases s)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a ss_stack on_stack visited lasso_impl red_impla counter\n       discovered finished pending stack tree_edges back_edges cross_edges\n       lasso reda.\n       \\<lbrakk>(si, s) \\<in> bdfs_rel;\n        (ri, r) \\<in> \\<langle>Id,\n        \\<langle>Id\\<rangle>list_rel \\<times>\\<^sub>r Id\\<rangle>sum_rel;\n        (a, a') \\<in> \\<langle>Id\\<rangle>list_rel; (aa, a'a) \\<in> Id;\n        si =\n        \\<lparr>ss_stack = ss_stack, on_stack = on_stack, visited = visited,\n           lasso_impl = lasso_impl, red_impl = red_impla\\<rparr>;\n        s =\n        \\<lparr>counter = counter, discovered = discovered,\n           finished = finished, pending = pending, stack = stack,\n           tree_edges = tree_edges, back_edges = back_edges,\n           cross_edges = cross_edges, lasso = lasso,\n           red = reda\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>rs.\n                             \\<lparr>lasso_impl =\n Some (rs, a @ dropWhileNot aa rs),\n                                red_impl = red_impl si\\<rparr>,\n                          \\<lambda>rs.\n                             \\<lparr>lasso =\n Some (rs, a' @ dropWhileNot a'a rs),\n                                red = red s\\<rparr>)\n                         \\<in> \\<langle>Id\\<rangle>list_rel \\<rightarrow>\n                               bdfs_erel", "apply (auto simp: bdfs_erel_def simple_state_rel_def) []"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "definition \"cyan_impl s \\<equiv> on_stack s\""], ["", "lemma cyan_impl[refine]: \"\\<lbrakk>(si,s)\\<in>bdfs_rel\\<rbrakk> \\<Longrightarrow> (cyan_impl si, cyan s)\\<in>Id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (si, s) \\<in> bdfs_rel \\<Longrightarrow> (cyan_impl si, cyan s) \\<in> Id", "unfolding cyan_impl_def cyan_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (si, s) \\<in> bdfs_rel \\<Longrightarrow>\n    (on_stack si, set (stack s)) \\<in> Id", "by (auto simp: bdfs_erel_def simple_state_rel_def)"], ["", "definition run_red_dfs_impl \n  :: \"('v, 'more) graph_rec_scheme \\<Rightarrow> 'v \\<Rightarrow> 'v bdfs_state_impl \\<Rightarrow> ('v,unit) bdfs_state_impl_ext nres\" \n  where\n  \"run_red_dfs_impl G u s \\<equiv> case lasso_impl s of None \\<Rightarrow> do {\n           redS \\<leftarrow> red_dfs TYPE('more) G (red_impl s) (\\<lambda>x. x = u \\<or> x \\<in> cyan_impl s) u;\n           RETURN (mk_blue_witness_impl s redS)\n         }\n        | _ \\<Rightarrow> RETURN (simple_state.more s)\""], ["", "lemma run_red_dfs_impl[refine]: \"\\<lbrakk>(Gi,G)\\<in>Id; (ui,u)\\<in>Id; (si,s)\\<in>bdfs_rel\\<rbrakk> \n    \\<Longrightarrow> run_red_dfs_impl Gi ui si \\<le>\\<Down>bdfs_erel (run_red_dfs TYPE('a) G u s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(Gi, G) \\<in> Id; (ui, u) \\<in> Id;\n     (si, s) \\<in> bdfs_rel\\<rbrakk>\n    \\<Longrightarrow> run_red_dfs_impl Gi ui si\n                      \\<le> \\<Down> bdfs_erel\n                             (BlueDFS_defs.run_red_dfs G u s)", "unfolding run_red_dfs_impl_def run_red_dfs_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(Gi, G) \\<in> Id; (ui, u) \\<in> Id;\n     (si, s) \\<in> bdfs_rel\\<rbrakk>\n    \\<Longrightarrow> (case lasso_impl si of\n                       None \\<Rightarrow>\n                         find_path1_restr_spec\n                          (Gi\\<lparr>g_V0 := {ui}\\<rparr>)\n                          (\\<lambda>x. x = ui \\<or> x \\<in> cyan_impl si)\n                          (red_impl si) \\<bind>\n                         (\\<lambda>redS.\n                             RETURN (mk_blue_witness_impl si redS))\n                       | Some a \\<Rightarrow> RETURN (simple_state.more si))\n                      \\<le> \\<Down> bdfs_erel\n                             (case lasso s of\n                              None \\<Rightarrow>\n                                find_path1_restr_spec\n                                 (G\\<lparr>g_V0 := {u}\\<rparr>)\n                                 (\\<lambda>x. x = u \\<or> x \\<in> cyan s)\n                                 (red s) \\<bind>\n                                (\\<lambda>redS.\n                                    RETURN (mk_blue_witness s redS))\n                              | Some a \\<Rightarrow> NOOP s)", "apply refine_rcg"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>(Gi, G) \\<in> Id; (ui, u) \\<in> Id;\n     (si, s) \\<in> bdfs_rel\\<rbrakk>\n    \\<Longrightarrow> (lasso_impl si, lasso s)\n                      \\<in> \\<langle>?Ra\\<rangle>option_rel\n 2. \\<lbrakk>(Gi, G) \\<in> Id; (ui, u) \\<in> Id; (si, s) \\<in> bdfs_rel;\n     lasso_impl si = None; lasso s = None\\<rbrakk>\n    \\<Longrightarrow> find_path1_restr_spec (Gi\\<lparr>g_V0 := {ui}\\<rparr>)\n                       (\\<lambda>x. x = ui \\<or> x \\<in> cyan_impl si)\n                       (red_impl si)\n                      \\<le> \\<Down> ?R'1\n                             (find_path1_restr_spec\n                               (G\\<lparr>g_V0 := {u}\\<rparr>)\n                               (\\<lambda>x. x = u \\<or> x \\<in> cyan s)\n                               (red s))\n 3. \\<And>redS redSa.\n       \\<lbrakk>(Gi, G) \\<in> Id; (ui, u) \\<in> Id; (si, s) \\<in> bdfs_rel;\n        lasso_impl si = None; lasso s = None;\n        (redS, redSa) \\<in> ?R'1\\<rbrakk>\n       \\<Longrightarrow> (redS, redSa) \\<in> \\<langle>Id,\n                         \\<langle>Id\\<rangle>list_rel \\<times>\\<^sub>r\n                         Id\\<rangle>sum_rel\n 4. \\<And>x x'.\n       \\<lbrakk>(Gi, G) \\<in> Id; (ui, u) \\<in> Id; (si, s) \\<in> bdfs_rel;\n        lasso_impl si = Some x; lasso s = Some x';\n        (x, x') \\<in> ?Ra\\<rbrakk>\n       \\<Longrightarrow> (simple_state.more si, state.more s)\n                         \\<in> bdfs_erel", "apply refine_dref_type"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>(Gi, G) \\<in> Id; (ui, u) \\<in> Id;\n     (si, s) \\<in> bdfs_rel\\<rbrakk>\n    \\<Longrightarrow> (lasso_impl si, lasso s)\n                      \\<in> \\<langle>\\<langle>Id\\<rangle>list_rel \\<times>\\<^sub>r\n                                     \\<langle>Id\\<rangle>list_rel\\<rangle>option_rel\n 2. \\<lbrakk>(Gi, G) \\<in> Id; (ui, u) \\<in> Id; (si, s) \\<in> bdfs_rel;\n     lasso_impl si = None; lasso s = None\\<rbrakk>\n    \\<Longrightarrow> find_path1_restr_spec (Gi\\<lparr>g_V0 := {ui}\\<rparr>)\n                       (\\<lambda>x. x = ui \\<or> x \\<in> cyan_impl si)\n                       (red_impl si)\n                      \\<le> \\<Down> Id\n                             (find_path1_restr_spec\n                               (G\\<lparr>g_V0 := {u}\\<rparr>)\n                               (\\<lambda>x. x = u \\<or> x \\<in> cyan s)\n                               (red s))\n 3. \\<And>redS redSa.\n       \\<lbrakk>(Gi, G) \\<in> Id; (ui, u) \\<in> Id; (si, s) \\<in> bdfs_rel;\n        lasso_impl si = None; lasso s = None;\n        (redS, redSa) \\<in> Id\\<rbrakk>\n       \\<Longrightarrow> (redS, redSa) \\<in> \\<langle>Id,\n                         \\<langle>Id\\<rangle>list_rel \\<times>\\<^sub>r\n                         Id\\<rangle>sum_rel\n 4. \\<And>x x'.\n       \\<lbrakk>(Gi, G) \\<in> Id; (ui, u) \\<in> Id; (si, s) \\<in> bdfs_rel;\n        lasso_impl si = Some x; lasso s = Some x';\n        (x, x')\n        \\<in> \\<langle>Id\\<rangle>list_rel \\<times>\\<^sub>r\n              \\<langle>Id\\<rangle>list_rel\\<rbrakk>\n       \\<Longrightarrow> (simple_state.more si, state.more s)\n                         \\<in> bdfs_erel", "apply (cases si, cases s, auto simp: bdfs_erel_def simple_state_rel_def) []"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>(Gi, G) \\<in> Id; (ui, u) \\<in> Id; (si, s) \\<in> bdfs_rel;\n     lasso_impl si = None; lasso s = None\\<rbrakk>\n    \\<Longrightarrow> find_path1_restr_spec (Gi\\<lparr>g_V0 := {ui}\\<rparr>)\n                       (\\<lambda>x. x = ui \\<or> x \\<in> cyan_impl si)\n                       (red_impl si)\n                      \\<le> \\<Down> Id\n                             (find_path1_restr_spec\n                               (G\\<lparr>g_V0 := {u}\\<rparr>)\n                               (\\<lambda>x. x = u \\<or> x \\<in> cyan s)\n                               (red s))\n 2. \\<And>redS redSa.\n       \\<lbrakk>(Gi, G) \\<in> Id; (ui, u) \\<in> Id; (si, s) \\<in> bdfs_rel;\n        lasso_impl si = None; lasso s = None;\n        (redS, redSa) \\<in> Id\\<rbrakk>\n       \\<Longrightarrow> (redS, redSa) \\<in> \\<langle>Id,\n                         \\<langle>Id\\<rangle>list_rel \\<times>\\<^sub>r\n                         Id\\<rangle>sum_rel\n 3. \\<And>x x'.\n       \\<lbrakk>(Gi, G) \\<in> Id; (ui, u) \\<in> Id; (si, s) \\<in> bdfs_rel;\n        lasso_impl si = Some x; lasso s = Some x';\n        (x, x')\n        \\<in> \\<langle>Id\\<rangle>list_rel \\<times>\\<^sub>r\n              \\<langle>Id\\<rangle>list_rel\\<rbrakk>\n       \\<Longrightarrow> (simple_state.more si, state.more s)\n                         \\<in> bdfs_erel", "apply (cases si, cases s, \n      auto simp: bdfs_erel_def simple_state_rel_def cyan_impl_def cyan_def) []"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>redS redSa.\n       \\<lbrakk>(Gi, G) \\<in> Id; (ui, u) \\<in> Id; (si, s) \\<in> bdfs_rel;\n        lasso_impl si = None; lasso s = None;\n        (redS, redSa) \\<in> Id\\<rbrakk>\n       \\<Longrightarrow> (redS, redSa) \\<in> \\<langle>Id,\n                         \\<langle>Id\\<rangle>list_rel \\<times>\\<^sub>r\n                         Id\\<rangle>sum_rel\n 2. \\<And>x x'.\n       \\<lbrakk>(Gi, G) \\<in> Id; (ui, u) \\<in> Id; (si, s) \\<in> bdfs_rel;\n        lasso_impl si = Some x; lasso s = Some x';\n        (x, x')\n        \\<in> \\<langle>Id\\<rangle>list_rel \\<times>\\<^sub>r\n              \\<langle>Id\\<rangle>list_rel\\<rbrakk>\n       \\<Longrightarrow> (simple_state.more si, state.more s)\n                         \\<in> bdfs_erel", "apply (auto simp: bdfs_erel_def simple_state_rel_def) [2]"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "definition \"se_back_edge_impl accpt u v s \\<equiv> case lasso_impl s of\n    None \\<Rightarrow> \n      if accpt u then\n         let rs = rev (map fst (tl (CAST (ss_stack s))));\n             ur = rs;\n             ul = u#dropWhileNot v rs\n         in RETURN \\<lparr>lasso_impl = Some (ur,ul), red_impl = red_impl s\\<rparr>\n      else if accpt v then\n         let rs = rev (map fst (CAST (ss_stack s)));\n             vr = takeWhileNot v rs;\n             vl = dropWhileNot v rs\n         in RETURN \\<lparr>lasso_impl = Some (vr,vl), red_impl = red_impl s\\<rparr>\n      else RETURN (simple_state.more s)\n  | _ \\<Rightarrow> RETURN (simple_state.more s)\""], ["", "lemma se_back_edge_impl[refine]: \"\\<lbrakk> (accpti,accpt)\\<in>Id; (ui,u)\\<in>Id; (vi,v)\\<in>Id; (si,s)\\<in>bdfs_rel \\<rbrakk> \n    \\<Longrightarrow> se_back_edge_impl accpt ui vi si \\<le>\\<Down>bdfs_erel (se_back_edge accpt u v s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(accpti, accpt) \\<in> Id; (ui, u) \\<in> Id; (vi, v) \\<in> Id;\n     (si, s) \\<in> bdfs_rel\\<rbrakk>\n    \\<Longrightarrow> se_back_edge_impl accpt ui vi si\n                      \\<le> \\<Down> bdfs_erel (se_back_edge accpt u v s)", "unfolding se_back_edge_impl_def se_back_edge_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(accpti, accpt) \\<in> Id; (ui, u) \\<in> Id; (vi, v) \\<in> Id;\n     (si, s) \\<in> bdfs_rel\\<rbrakk>\n    \\<Longrightarrow> (case lasso_impl si of\n                       None \\<Rightarrow>\n                         if accpt ui\n                         then let rs = rev\n  (map fst (tl (CAST (ss_stack si))));\n                                  ur = rs; ul = ui # dropWhileNot vi rs\n                              in RETURN\n                                  \\<lparr>lasso_impl = Some (ur, ul),\n                                     red_impl = red_impl si\\<rparr>\n                         else if accpt vi\n                              then let rs =\n   rev (map fst (CAST (ss_stack si)));\n vr = takeWhileNot vi rs; vl = dropWhileNot vi rs\n                                   in RETURN\n \\<lparr>lasso_impl = Some (vr, vl), red_impl = red_impl si\\<rparr>\n                              else RETURN (simple_state.more si)\n                       | Some a \\<Rightarrow> RETURN (simple_state.more si))\n                      \\<le> \\<Down> bdfs_erel\n                             (case lasso s of\n                              None \\<Rightarrow>\n                                if accpt u\n                                then let rs = rev (tl (stack s)); ur = rs;\n   ul = u # dropWhileNot v rs\n                                     in RETURN\n   \\<lparr>lasso = Some (ur, ul), red = red s\\<rparr>\n                                else if accpt v\n                                     then let rs = rev (stack s);\n        vr = takeWhileNot v rs; vl = dropWhileNot v rs\n    in RETURN \\<lparr>lasso = Some (vr, vl), red = red s\\<rparr>\n                                     else NOOP s\n                              | Some a \\<Rightarrow> NOOP s)", "apply refine_rcg"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<lbrakk>(accpti, accpt) \\<in> Id; (ui, u) \\<in> Id; (vi, v) \\<in> Id;\n     (si, s) \\<in> bdfs_rel\\<rbrakk>\n    \\<Longrightarrow> (lasso_impl si, lasso s)\n                      \\<in> \\<langle>?Ra\\<rangle>option_rel\n 2. \\<lbrakk>(accpti, accpt) \\<in> Id; (ui, u) \\<in> Id; (vi, v) \\<in> Id;\n     (si, s) \\<in> bdfs_rel; lasso_impl si = None; lasso s = None\\<rbrakk>\n    \\<Longrightarrow> accpt ui = accpt u\n 3. \\<lbrakk>(accpti, accpt) \\<in> Id; (ui, u) \\<in> Id; (vi, v) \\<in> Id;\n     (si, s) \\<in> bdfs_rel; lasso_impl si = None; lasso s = None; accpt ui;\n     accpt u\\<rbrakk>\n    \\<Longrightarrow> (\\<lparr>lasso_impl =\n                                 Some\n                                  (rev (map fst (tl (CAST (ss_stack si)))),\n                                   ui #\n                                   dropWhileNot vi\n                                    (rev\n(map fst (tl (CAST (ss_stack si)))))),\n                          red_impl = red_impl si\\<rparr>,\n                       \\<lparr>lasso =\n                                 Some\n                                  (rev (tl (stack s)),\n                                   u # dropWhileNot v (rev (tl (stack s)))),\n                          red = red s\\<rparr>)\n                      \\<in> bdfs_erel\n 4. \\<lbrakk>(accpti, accpt) \\<in> Id; (ui, u) \\<in> Id; (vi, v) \\<in> Id;\n     (si, s) \\<in> bdfs_rel; lasso_impl si = None; lasso s = None;\n     \\<not> accpt ui; \\<not> accpt u\\<rbrakk>\n    \\<Longrightarrow> accpt vi = accpt v\n 5. \\<lbrakk>(accpti, accpt) \\<in> Id; (ui, u) \\<in> Id; (vi, v) \\<in> Id;\n     (si, s) \\<in> bdfs_rel; lasso_impl si = None; lasso s = None;\n     \\<not> accpt ui; \\<not> accpt u; accpt vi; accpt v\\<rbrakk>\n    \\<Longrightarrow> (\\<lparr>lasso_impl =\n                                 Some\n                                  (takeWhileNot vi\n                                    (rev (map fst (CAST (ss_stack si)))),\n                                   dropWhileNot vi\n                                    (rev (map fst (CAST (ss_stack si))))),\n                          red_impl = red_impl si\\<rparr>,\n                       \\<lparr>lasso =\n                                 Some\n                                  (takeWhileNot v (rev (stack s)),\n                                   dropWhileNot v (rev (stack s))),\n                          red = red s\\<rparr>)\n                      \\<in> bdfs_erel\n 6. \\<lbrakk>(accpti, accpt) \\<in> Id; (ui, u) \\<in> Id; (vi, v) \\<in> Id;\n     (si, s) \\<in> bdfs_rel; lasso_impl si = None; lasso s = None;\n     \\<not> accpt ui; \\<not> accpt u; \\<not> accpt vi;\n     \\<not> accpt v\\<rbrakk>\n    \\<Longrightarrow> (simple_state.more si, state.more s) \\<in> bdfs_erel\n 7. \\<And>x x'.\n       \\<lbrakk>(accpti, accpt) \\<in> Id; (ui, u) \\<in> Id;\n        (vi, v) \\<in> Id; (si, s) \\<in> bdfs_rel; lasso_impl si = Some x;\n        lasso s = Some x'; (x, x') \\<in> ?Ra\\<rbrakk>\n       \\<Longrightarrow> (simple_state.more si, state.more s)\n                         \\<in> bdfs_erel", "apply refine_dref_type"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<lbrakk>(accpti, accpt) \\<in> Id; (ui, u) \\<in> Id; (vi, v) \\<in> Id;\n     (si, s) \\<in> bdfs_rel\\<rbrakk>\n    \\<Longrightarrow> (lasso_impl si, lasso s)\n                      \\<in> \\<langle>\\<langle>Id\\<rangle>list_rel \\<times>\\<^sub>r\n                                     \\<langle>Id\\<rangle>list_rel\\<rangle>option_rel\n 2. \\<lbrakk>(accpti, accpt) \\<in> Id; (ui, u) \\<in> Id; (vi, v) \\<in> Id;\n     (si, s) \\<in> bdfs_rel; lasso_impl si = None; lasso s = None\\<rbrakk>\n    \\<Longrightarrow> accpt ui = accpt u\n 3. \\<lbrakk>(accpti, accpt) \\<in> Id; (ui, u) \\<in> Id; (vi, v) \\<in> Id;\n     (si, s) \\<in> bdfs_rel; lasso_impl si = None; lasso s = None; accpt ui;\n     accpt u\\<rbrakk>\n    \\<Longrightarrow> (\\<lparr>lasso_impl =\n                                 Some\n                                  (rev (map fst (tl (CAST (ss_stack si)))),\n                                   ui #\n                                   dropWhileNot vi\n                                    (rev\n(map fst (tl (CAST (ss_stack si)))))),\n                          red_impl = red_impl si\\<rparr>,\n                       \\<lparr>lasso =\n                                 Some\n                                  (rev (tl (stack s)),\n                                   u # dropWhileNot v (rev (tl (stack s)))),\n                          red = red s\\<rparr>)\n                      \\<in> bdfs_erel\n 4. \\<lbrakk>(accpti, accpt) \\<in> Id; (ui, u) \\<in> Id; (vi, v) \\<in> Id;\n     (si, s) \\<in> bdfs_rel; lasso_impl si = None; lasso s = None;\n     \\<not> accpt ui; \\<not> accpt u\\<rbrakk>\n    \\<Longrightarrow> accpt vi = accpt v\n 5. \\<lbrakk>(accpti, accpt) \\<in> Id; (ui, u) \\<in> Id; (vi, v) \\<in> Id;\n     (si, s) \\<in> bdfs_rel; lasso_impl si = None; lasso s = None;\n     \\<not> accpt ui; \\<not> accpt u; accpt vi; accpt v\\<rbrakk>\n    \\<Longrightarrow> (\\<lparr>lasso_impl =\n                                 Some\n                                  (takeWhileNot vi\n                                    (rev (map fst (CAST (ss_stack si)))),\n                                   dropWhileNot vi\n                                    (rev (map fst (CAST (ss_stack si))))),\n                          red_impl = red_impl si\\<rparr>,\n                       \\<lparr>lasso =\n                                 Some\n                                  (takeWhileNot v (rev (stack s)),\n                                   dropWhileNot v (rev (stack s))),\n                          red = red s\\<rparr>)\n                      \\<in> bdfs_erel\n 6. \\<lbrakk>(accpti, accpt) \\<in> Id; (ui, u) \\<in> Id; (vi, v) \\<in> Id;\n     (si, s) \\<in> bdfs_rel; lasso_impl si = None; lasso s = None;\n     \\<not> accpt ui; \\<not> accpt u; \\<not> accpt vi;\n     \\<not> accpt v\\<rbrakk>\n    \\<Longrightarrow> (simple_state.more si, state.more s) \\<in> bdfs_erel\n 7. \\<And>x x'.\n       \\<lbrakk>(accpti, accpt) \\<in> Id; (ui, u) \\<in> Id;\n        (vi, v) \\<in> Id; (si, s) \\<in> bdfs_rel; lasso_impl si = Some x;\n        lasso s = Some x';\n        (x, x')\n        \\<in> \\<langle>Id\\<rangle>list_rel \\<times>\\<^sub>r\n              \\<langle>Id\\<rangle>list_rel\\<rbrakk>\n       \\<Longrightarrow> (simple_state.more si, state.more s)\n                         \\<in> bdfs_erel", "apply simp_all"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>accpti = accpt; ui = u; vi = v; (si, s) \\<in> bdfs_rel\\<rbrakk>\n    \\<Longrightarrow> lasso_impl si = lasso s\n 2. \\<lbrakk>accpti = accpt; ui = u; vi = v; (si, s) \\<in> bdfs_rel;\n     lasso_impl si = None; lasso s = None; accpt u\\<rbrakk>\n    \\<Longrightarrow> (\\<lparr>lasso_impl =\n                                 Some\n                                  (rev (map fst (tl (ss_stack si))),\n                                   u #\n                                   dropWhileNot v\n                                    (rev (map fst (tl (ss_stack si))))),\n                          red_impl = red_impl si\\<rparr>,\n                       \\<lparr>lasso =\n                                 Some\n                                  (rev (tl (stack s)),\n                                   u # dropWhileNot v (rev (tl (stack s)))),\n                          red = red s\\<rparr>)\n                      \\<in> bdfs_erel\n 3. \\<lbrakk>accpti = accpt; ui = u; vi = v; (si, s) \\<in> bdfs_rel;\n     lasso_impl si = None; lasso s = None; \\<not> accpt u; accpt v\\<rbrakk>\n    \\<Longrightarrow> (\\<lparr>lasso_impl =\n                                 Some\n                                  (takeWhileNot v\n                                    (rev (map fst (ss_stack si))),\n                                   dropWhileNot v\n                                    (rev (map fst (ss_stack si)))),\n                          red_impl = red_impl si\\<rparr>,\n                       \\<lparr>lasso =\n                                 Some\n                                  (takeWhileNot v (rev (stack s)),\n                                   dropWhileNot v (rev (stack s))),\n                          red = red s\\<rparr>)\n                      \\<in> bdfs_erel\n 4. \\<lbrakk>accpti = accpt; ui = u; vi = v; (si, s) \\<in> bdfs_rel;\n     lasso_impl si = None; lasso s = None; \\<not> accpt u;\n     \\<not> accpt v\\<rbrakk>\n    \\<Longrightarrow> (simple_state.more si, state.more s) \\<in> bdfs_erel\n 5. \\<And>x x'.\n       \\<lbrakk>accpti = accpt; ui = u; vi = v; (si, s) \\<in> bdfs_rel;\n        lasso_impl si = Some x'; lasso s = Some x'; x = x'\\<rbrakk>\n       \\<Longrightarrow> (simple_state.more si, state.more s)\n                         \\<in> bdfs_erel", "apply (simp_all add: bdfs_erel_def simple_state_rel_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>accpti = accpt; ui = u; vi = v;\n     ss_stack si = map (\\<lambda>u. (u, pending s `` {u})) (stack s) \\<and>\n     on_stack si = set (stack s) \\<and>\n     visited si = dom (discovered s) \\<and>\n     dom (finished s) = dom (discovered s) - set (stack s) \\<and>\n     set (stack s) \\<subseteq> dom (discovered s) \\<and>\n     (\\<exists>li ri.\n         simple_state.more si =\n         \\<lparr>lasso_impl = li, red_impl = ri\\<rparr> \\<and>\n         state.more s = \\<lparr>lasso = li, red = ri\\<rparr>)\\<rbrakk>\n    \\<Longrightarrow> lasso_impl si = lasso s\n 2. \\<lbrakk>accpti = accpt; ui = u; vi = v;\n     ss_stack si = map (\\<lambda>u. (u, pending s `` {u})) (stack s) \\<and>\n     on_stack si = set (stack s) \\<and>\n     visited si = dom (discovered s) \\<and>\n     dom (finished s) = dom (discovered s) - set (stack s) \\<and>\n     set (stack s) \\<subseteq> dom (discovered s) \\<and>\n     (\\<exists>li ri.\n         simple_state.more si =\n         \\<lparr>lasso_impl = li, red_impl = ri\\<rparr> \\<and>\n         state.more s = \\<lparr>lasso = li, red = ri\\<rparr>);\n     lasso_impl si = None; lasso s = None; accpt u\\<rbrakk>\n    \\<Longrightarrow> tl (stack s) =\n                      map fst\n                       (tl (map (\\<lambda>u. (u, pending s `` {u}))\n                             (stack s))) \\<and>\n                      dropWhileNot v (rev (tl (stack s))) =\n                      dropWhileNot v\n                       (rev (map fst\n                              (tl (map (\\<lambda>u. (u, pending s `` {u}))\n                                    (stack s))))) \\<and>\n                      red s = red_impl si\n 3. \\<lbrakk>accpti = accpt; ui = u; vi = v;\n     ss_stack si = map (\\<lambda>u. (u, pending s `` {u})) (stack s) \\<and>\n     on_stack si = set (stack s) \\<and>\n     visited si = dom (discovered s) \\<and>\n     dom (finished s) = dom (discovered s) - set (stack s) \\<and>\n     set (stack s) \\<subseteq> dom (discovered s) \\<and>\n     (\\<exists>li ri.\n         simple_state.more si =\n         \\<lparr>lasso_impl = li, red_impl = ri\\<rparr> \\<and>\n         state.more s = \\<lparr>lasso = li, red = ri\\<rparr>);\n     lasso_impl si = None; lasso s = None; \\<not> accpt u; accpt v\\<rbrakk>\n    \\<Longrightarrow> takeWhileNot v (rev (stack s)) =\n                      takeWhileNot v\n                       (rev (map (fst \\<circ>\n                                  (\\<lambda>u. (u, pending s `` {u})))\n                              (stack s))) \\<and>\n                      dropWhileNot v (rev (stack s)) =\n                      dropWhileNot v\n                       (rev (map (fst \\<circ>\n                                  (\\<lambda>u. (u, pending s `` {u})))\n                              (stack s))) \\<and>\n                      red s = red_impl si", "apply (cases si, cases s, (auto) [])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>accpti = accpt; ui = u; vi = v;\n     ss_stack si = map (\\<lambda>u. (u, pending s `` {u})) (stack s) \\<and>\n     on_stack si = set (stack s) \\<and>\n     visited si = dom (discovered s) \\<and>\n     dom (finished s) = dom (discovered s) - set (stack s) \\<and>\n     set (stack s) \\<subseteq> dom (discovered s) \\<and>\n     (\\<exists>li ri.\n         simple_state.more si =\n         \\<lparr>lasso_impl = li, red_impl = ri\\<rparr> \\<and>\n         state.more s = \\<lparr>lasso = li, red = ri\\<rparr>);\n     lasso_impl si = None; lasso s = None; accpt u\\<rbrakk>\n    \\<Longrightarrow> tl (stack s) =\n                      map fst\n                       (tl (map (\\<lambda>u. (u, pending s `` {u}))\n                             (stack s))) \\<and>\n                      dropWhileNot v (rev (tl (stack s))) =\n                      dropWhileNot v\n                       (rev (map fst\n                              (tl (map (\\<lambda>u. (u, pending s `` {u}))\n                                    (stack s))))) \\<and>\n                      red s = red_impl si\n 2. \\<lbrakk>accpti = accpt; ui = u; vi = v;\n     ss_stack si = map (\\<lambda>u. (u, pending s `` {u})) (stack s) \\<and>\n     on_stack si = set (stack s) \\<and>\n     visited si = dom (discovered s) \\<and>\n     dom (finished s) = dom (discovered s) - set (stack s) \\<and>\n     set (stack s) \\<subseteq> dom (discovered s) \\<and>\n     (\\<exists>li ri.\n         simple_state.more si =\n         \\<lparr>lasso_impl = li, red_impl = ri\\<rparr> \\<and>\n         state.more s = \\<lparr>lasso = li, red = ri\\<rparr>);\n     lasso_impl si = None; lasso s = None; \\<not> accpt u; accpt v\\<rbrakk>\n    \\<Longrightarrow> takeWhileNot v (rev (stack s)) =\n                      takeWhileNot v\n                       (rev (map (fst \\<circ>\n                                  (\\<lambda>u. (u, pending s `` {u})))\n                              (stack s))) \\<and>\n                      dropWhileNot v (rev (stack s)) =\n                      dropWhileNot v\n                       (rev (map (fst \\<circ>\n                                  (\\<lambda>u. (u, pending s `` {u})))\n                              (stack s))) \\<and>\n                      red s = red_impl si", "apply (cases si, cases s, (auto simp: map_tl comp_def) [])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>accpti = accpt; ui = u; vi = v;\n     ss_stack si = map (\\<lambda>u. (u, pending s `` {u})) (stack s) \\<and>\n     on_stack si = set (stack s) \\<and>\n     visited si = dom (discovered s) \\<and>\n     dom (finished s) = dom (discovered s) - set (stack s) \\<and>\n     set (stack s) \\<subseteq> dom (discovered s) \\<and>\n     (\\<exists>li ri.\n         simple_state.more si =\n         \\<lparr>lasso_impl = li, red_impl = ri\\<rparr> \\<and>\n         state.more s = \\<lparr>lasso = li, red = ri\\<rparr>);\n     lasso_impl si = None; lasso s = None; \\<not> accpt u; accpt v\\<rbrakk>\n    \\<Longrightarrow> takeWhileNot v (rev (stack s)) =\n                      takeWhileNot v\n                       (rev (map (fst \\<circ>\n                                  (\\<lambda>u. (u, pending s `` {u})))\n                              (stack s))) \\<and>\n                      dropWhileNot v (rev (stack s)) =\n                      dropWhileNot v\n                       (rev (map (fst \\<circ>\n                                  (\\<lambda>u. (u, pending s `` {u})))\n                              (stack s))) \\<and>\n                      red s = red_impl si", "apply (cases si, cases s, (auto simp: comp_def) [])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma NOOP_impl: \"(si, s) \\<in> bdfs_rel \n    \\<Longrightarrow> RETURN (simple_state.more si) \\<le> \\<Down> bdfs_erel (NOOP s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (si, s) \\<in> bdfs_rel \\<Longrightarrow>\n    RETURN (simple_state.more si) \\<le> \\<Down> bdfs_erel (NOOP s)", "apply (simp add: pw_le_iff refine_pw_simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (si, s) \\<in> bdfs_rel \\<Longrightarrow>\n    (simple_state.more si, state.more s) \\<in> bdfs_erel", "apply (auto simp: simple_state_rel_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "definition bdfs_params_impl \n    :: \"('v, 'more) graph_rec_scheme \\<Rightarrow> ('v \\<Rightarrow> bool) \\<Rightarrow> ('v,'v bdfs_state_impl,('v,unit)bdfs_state_impl_ext) gen_parameterization\"\n  where \"bdfs_params_impl G accpt \\<equiv> \\<lparr>\n    on_init = RETURN \\<lparr>lasso_impl = None, red_impl = {}\\<rparr>,\n    on_new_root = \\<lambda>v0 s. RETURN (simple_state.more s),\n    on_discover = \\<lambda>u v s. RETURN (simple_state.more s),\n    on_finish = \\<lambda>u s. \n      if accpt u then run_red_dfs_impl G u s else RETURN (simple_state.more s),\n    on_back_edge = se_back_edge_impl accpt,\n    on_cross_edge = \\<lambda>u v s. RETURN (simple_state.more s),\n    is_break = \\<lambda>s. lasso_impl s \\<noteq> None \\<rparr>\""], ["", "lemmas bdfs_params_impl_simps[simp, DFS_code_unfold] = \n    gen_parameterization.simps[mk_record_simp, OF bdfs_params_impl_def]"], ["", "interpretation impl: simple_impl_defs G \"bdfs_params_impl G accpt\" \"blue_dfs_params TYPE('a) G accpt\"\n    for G accpt"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "context BlueDFS begin"], ["", "sublocale impl: simple_impl G blue_dfs_params \"bdfs_params_impl G accpt\" bdfs_erel"], ["proof (prove)\ngoal (1 subgoal):\n 1. simple_impl G local.blue_dfs_params (bdfs_params_impl G accpt) bdfs_erel", "apply unfold_locales"], ["proof (prove)\ngoal (8 subgoals):\n 1. (simple_state.more_update, state.more_update)\n    \\<in> (bdfs_erel \\<rightarrow> bdfs_erel) \\<rightarrow>\n          bdfs_rel \\<rightarrow> bdfs_rel\n 2. on_init (bdfs_params_impl G accpt)\n    \\<le> \\<Down> bdfs_erel (on_init local.blue_dfs_params)\n 3. (is_break (bdfs_params_impl G accpt), is_break local.blue_dfs_params)\n    \\<in> bdfs_rel \\<rightarrow> bool_rel\n 4. \\<And>v0 s v0i si si' s'.\n       \\<lbrakk>local.gen_dfs.pre_new_root v0 s; (v0i, v0) \\<in> Id;\n        (si, s) \\<in> bdfs_rel; (si', s') \\<in> bdfs_rel;\n        nf_inres (gbs_new_root local.gbs v0 s) s'\\<rbrakk>\n       \\<Longrightarrow> on_new_root (bdfs_params_impl G accpt) v0i si'\n                         \\<le> \\<Down> bdfs_erel\n                                (on_new_root local.blue_dfs_params v0 s')\n 5. \\<And>v s0 s vi si si' s'.\n       \\<lbrakk>local.gen_dfs.pre_finish v s0 s; (vi, v) \\<in> Id;\n        (si, s) \\<in> bdfs_rel; (si', s') \\<in> bdfs_rel;\n        nf_inres (gbs_finish local.gbs v s) s'\\<rbrakk>\n       \\<Longrightarrow> on_finish (bdfs_params_impl G accpt) vi si'\n                         \\<le> \\<Down> bdfs_erel\n                                (on_finish local.blue_dfs_params v s')\n 6. \\<And>u v s0 s ui vi si si' s'.\n       \\<lbrakk>local.gen_dfs.pre_cross_edge u v s0 s; (ui, u) \\<in> Id;\n        (vi, v) \\<in> Id; (si, s) \\<in> bdfs_rel; (si', s') \\<in> bdfs_rel;\n        nf_inres (gbs_cross_edge local.gbs u v s) s'\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge (bdfs_params_impl G accpt) ui vi si'\n                         \\<le> \\<Down> bdfs_erel\n                                (on_cross_edge local.blue_dfs_params u v s')\n 7. \\<And>u v s0 s ui vi si si' s'.\n       \\<lbrakk>local.gen_dfs.pre_back_edge u v s0 s; (ui, u) \\<in> Id;\n        (vi, v) \\<in> Id; (si, s) \\<in> bdfs_rel; (si', s') \\<in> bdfs_rel;\n        nf_inres (gbs_back_edge local.gbs u v s) s'\\<rbrakk>\n       \\<Longrightarrow> on_back_edge (bdfs_params_impl G accpt) ui vi si'\n                         \\<le> \\<Down> bdfs_erel\n                                (on_back_edge local.blue_dfs_params u v s')\n 8. \\<And>u v s0 s ui vi si si' s'.\n       \\<lbrakk>local.gen_dfs.pre_discover u v s0 s; (ui, u) \\<in> Id;\n        (vi, v) \\<in> Id; (si, s) \\<in> bdfs_rel; (si', s') \\<in> bdfs_rel;\n        nf_inres (gbs_discover local.gbs u v s) s'\\<rbrakk>\n       \\<Longrightarrow> on_discover (bdfs_params_impl G accpt) ui vi si'\n                         \\<le> \\<Down> bdfs_erel\n                                (on_discover local.blue_dfs_params u v s')", "apply (simp_all \n      add: bdfs_params_impl_def run_red_dfs_impl se_back_edge_impl NOOP_impl)"], ["proof (prove)\ngoal (7 subgoals):\n 1. (simple_state.more_update, state.more_update)\n    \\<in> (bdfs_erel \\<rightarrow> bdfs_erel) \\<rightarrow>\n          bdfs_rel \\<rightarrow> bdfs_rel\n 2. (\\<lparr>lasso_impl = None, red_impl = {}\\<rparr>,\n     \\<lparr>lasso = None, red = {}\\<rparr>)\n    \\<in> bdfs_erel\n 3. (\\<lambda>s. \\<exists>a b. lasso_impl s = Some (a, b),\n     \\<lambda>s. \\<exists>a b. lasso s = Some (a, b))\n    \\<in> bdfs_rel \\<rightarrow> bool_rel\n 4. \\<And>v0 s v0i si si' s'.\n       \\<lbrakk>local.gen_dfs.pre_new_root v0 s; v0i = v0;\n        (si, s) \\<in> bdfs_rel; (si', s') \\<in> bdfs_rel;\n        nf_inres (RETURN (local.new_root v0 s)) s'\\<rbrakk>\n       \\<Longrightarrow> (simple_state.more si', state.more s')\n                         \\<in> bdfs_erel\n 5. \\<And>v s0 s vi si si' s'.\n       \\<lbrakk>local.gen_dfs.pre_finish v s0 s; vi = v;\n        (si, s) \\<in> bdfs_rel; (si', s') \\<in> bdfs_rel;\n        nf_inres (RETURN (local.finish v s)) s'\\<rbrakk>\n       \\<Longrightarrow> \\<not> accpt v \\<longrightarrow>\n                         (simple_state.more si', state.more s')\n                         \\<in> bdfs_erel\n 6. \\<And>u v s0 s ui vi si si' s'.\n       \\<lbrakk>local.gen_dfs.pre_cross_edge u v s0 s; ui = u; vi = v;\n        (si, s) \\<in> bdfs_rel; (si', s') \\<in> bdfs_rel;\n        nf_inres (RETURN (local.cross_edge u v s)) s'\\<rbrakk>\n       \\<Longrightarrow> (simple_state.more si', state.more s')\n                         \\<in> bdfs_erel\n 7. \\<And>u v s0 s ui vi si si' s'.\n       \\<lbrakk>local.gen_dfs.pre_discover u v s0 s; ui = u; vi = v;\n        (si, s) \\<in> bdfs_rel; (si', s') \\<in> bdfs_rel;\n        nf_inres (RETURN (local.discover u v s)) s'\\<rbrakk>\n       \\<Longrightarrow> (simple_state.more si', state.more s')\n                         \\<in> bdfs_erel", "apply parametricity"], ["proof (prove)\ngoal (6 subgoals):\n 1. (\\<lparr>lasso_impl = None, red_impl = {}\\<rparr>,\n     \\<lparr>lasso = None, red = {}\\<rparr>)\n    \\<in> bdfs_erel\n 2. (\\<lambda>s. \\<exists>a b. lasso_impl s = Some (a, b),\n     \\<lambda>s. \\<exists>a b. lasso s = Some (a, b))\n    \\<in> bdfs_rel \\<rightarrow> bool_rel\n 3. \\<And>v0 s v0i si si' s'.\n       \\<lbrakk>local.gen_dfs.pre_new_root v0 s; v0i = v0;\n        (si, s) \\<in> bdfs_rel; (si', s') \\<in> bdfs_rel;\n        nf_inres (RETURN (local.new_root v0 s)) s'\\<rbrakk>\n       \\<Longrightarrow> (simple_state.more si', state.more s')\n                         \\<in> bdfs_erel\n 4. \\<And>v s0 s vi si si' s'.\n       \\<lbrakk>local.gen_dfs.pre_finish v s0 s; vi = v;\n        (si, s) \\<in> bdfs_rel; (si', s') \\<in> bdfs_rel;\n        nf_inres (RETURN (local.finish v s)) s'\\<rbrakk>\n       \\<Longrightarrow> \\<not> accpt v \\<longrightarrow>\n                         (simple_state.more si', state.more s')\n                         \\<in> bdfs_erel\n 5. \\<And>u v s0 s ui vi si si' s'.\n       \\<lbrakk>local.gen_dfs.pre_cross_edge u v s0 s; ui = u; vi = v;\n        (si, s) \\<in> bdfs_rel; (si', s') \\<in> bdfs_rel;\n        nf_inres (RETURN (local.cross_edge u v s)) s'\\<rbrakk>\n       \\<Longrightarrow> (simple_state.more si', state.more s')\n                         \\<in> bdfs_erel\n 6. \\<And>u v s0 s ui vi si si' s'.\n       \\<lbrakk>local.gen_dfs.pre_discover u v s0 s; ui = u; vi = v;\n        (si, s) \\<in> bdfs_rel; (si', s') \\<in> bdfs_rel;\n        nf_inres (RETURN (local.discover u v s)) s'\\<rbrakk>\n       \\<Longrightarrow> (simple_state.more si', state.more s')\n                         \\<in> bdfs_erel", "apply (clarsimp_all simp: pw_le_iff refine_pw_simps bdfs_erel_def simple_state_rel_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' li ri.\n       \\<lbrakk>ss_stack a =\n                map (\\<lambda>u. (u, pending a' `` {u})) (stack a');\n        on_stack a = set (stack a'); visited a = dom (discovered a');\n        dom (finished a') = dom (discovered a') - set (stack a');\n        set (stack a') \\<subseteq> dom (discovered a');\n        simple_state.more a =\n        \\<lparr>lasso_impl = li, red_impl = ri\\<rparr>;\n        state.more a' = \\<lparr>lasso = li, red = ri\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>aa b. lasso_impl a = Some (aa, b)) =\n                         (\\<exists>a b. lasso a' = Some (a, b))", "apply (rename_tac si s x y, case_tac si, case_tac s)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>si s x y ss_stacka on_stacka visiteda lasso_impla red_impl counter\n       discovereda finisheda pendinga stacka tree_edges back_edges\n       cross_edges lassoa red.\n       \\<lbrakk>ss_stack si =\n                map (\\<lambda>u. (u, pending s `` {u})) (stack s);\n        on_stack si = set (stack s); visited si = dom (discovered s);\n        dom (finished s) = dom (discovered s) - set (stack s);\n        set (stack s) \\<subseteq> dom (discovered s);\n        simple_state.more si = \\<lparr>lasso_impl = x, red_impl = y\\<rparr>;\n        state.more s = \\<lparr>lasso = x, red = y\\<rparr>;\n        si =\n        \\<lparr>ss_stack = ss_stacka, on_stack = on_stacka,\n           visited = visiteda, lasso_impl = lasso_impla,\n           red_impl = red_impl\\<rparr>;\n        s =\n        \\<lparr>counter = counter, discovered = discovereda,\n           finished = finisheda, pending = pendinga, stack = stacka,\n           tree_edges = tree_edges, back_edges = back_edges,\n           cross_edges = cross_edges, lasso = lassoa,\n           red = red\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>a b. lasso_impl si = Some (a, b)) =\n                         (\\<exists>a b. lasso s = Some (a, b))", "apply (auto simp add: bdfs_erel_def simple_state_rel_def) []"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemmas impl = impl.simple_tailrec_refine"], ["", "end"], ["", "definition \"nested_dfs_impl G accpt \\<equiv> do {\n  ASSERT (fb_graph G);\n  s \\<leftarrow> impl.tailrec_impl TYPE('a) G accpt;\n  RETURN (lasso_impl s)\n}\""], ["", "lemma nested_dfs_impl[refine]: \n  assumes \"(Gi,G)\\<in>Id\"\n  assumes \"(accpti,accpt)\\<in>Id\"\n  shows \"nested_dfs_impl Gi accpti \\<le>\\<Down>(\\<langle>\\<langle>Id\\<rangle>list_rel \\<times>\\<^sub>r \\<langle>Id\\<rangle>list_rel\\<rangle>option_rel) \n    (nested_dfs G accpt)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nested_dfs_impl Gi accpti\n    \\<le> \\<Down>\n           (\\<langle>\\<langle>Id\\<rangle>list_rel \\<times>\\<^sub>r\n                     \\<langle>Id\\<rangle>list_rel\\<rangle>option_rel)\n           (nested_dfs G accpt)", "using assms"], ["proof (prove)\nusing this:\n  (Gi, G) \\<in> Id\n  (accpti, accpt) \\<in> Id\n\ngoal (1 subgoal):\n 1. nested_dfs_impl Gi accpti\n    \\<le> \\<Down>\n           (\\<langle>\\<langle>Id\\<rangle>list_rel \\<times>\\<^sub>r\n                     \\<langle>Id\\<rangle>list_rel\\<rangle>option_rel)\n           (nested_dfs G accpt)", "unfolding nested_dfs_impl_def nested_dfs_def"], ["proof (prove)\nusing this:\n  (Gi, G) \\<in> Id\n  (accpti, accpt) \\<in> Id\n\ngoal (1 subgoal):\n 1. ASSERT (fb_graph Gi) \\<bind>\n    (\\<lambda>_.\n        tailrec_impl_defs.tailrec_impl Gi\n         (gen_param_dfs_defs.gds (pre_simple_impl.gbs Gi)\n           (bdfs_params_impl Gi accpti) simple_state.more_update) \\<bind>\n        (\\<lambda>s. RETURN (lasso_impl s)))\n    \\<le> \\<Down>\n           (\\<langle>\\<langle>Id\\<rangle>list_rel \\<times>\\<^sub>r\n                     \\<langle>Id\\<rangle>list_rel\\<rangle>option_rel)\n           (ASSERT (fb_graph G) \\<bind>\n            (\\<lambda>_.\n                param_DFS_defs.it_dfs G\n                 (BlueDFS_defs.blue_dfs_params G accpt) \\<bind>\n                (\\<lambda>s. RETURN (lasso s))))", "apply refine_rcg"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>(Gi, G) \\<in> Id; (accpti, accpt) \\<in> Id; fb_graph G\\<rbrakk>\n    \\<Longrightarrow> fb_graph Gi\n 2. \\<lbrakk>(Gi, G) \\<in> Id; (accpti, accpt) \\<in> Id; fb_graph G;\n     fb_graph Gi\\<rbrakk>\n    \\<Longrightarrow> tailrec_impl_defs.tailrec_impl Gi\n                       (gen_param_dfs_defs.gds (pre_simple_impl.gbs Gi)\n                         (bdfs_params_impl Gi accpti)\n                         simple_state.more_update)\n                      \\<le> \\<Down> ?R'4\n                             (param_DFS_defs.it_dfs G\n                               (BlueDFS_defs.blue_dfs_params G accpt))\n 3. \\<And>s sa.\n       \\<lbrakk>(Gi, G) \\<in> Id; (accpti, accpt) \\<in> Id; fb_graph G;\n        fb_graph Gi; (s, sa) \\<in> ?R'4\\<rbrakk>\n       \\<Longrightarrow> (lasso_impl s, lasso sa)\n                         \\<in> \\<langle>\\<langle>Id\\<rangle>list_rel \\<times>\\<^sub>r\n  \\<langle>Id\\<rangle>list_rel\\<rangle>option_rel", "apply simp_all"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>Gi = G; accpti = accpt; fb_graph G\\<rbrakk>\n    \\<Longrightarrow> tailrec_impl_defs.tailrec_impl G\n                       (gen_param_dfs_defs.gds (pre_simple_impl.gbs G)\n                         (bdfs_params_impl G accpt)\n                         simple_state.more_update)\n                      \\<le> \\<Down> ?R'4\n                             (param_DFS_defs.it_dfs G\n                               (BlueDFS_defs.blue_dfs_params G accpt))\n 2. \\<And>s sa.\n       \\<lbrakk>Gi = G; accpti = accpt; fb_graph G;\n        (s, sa) \\<in> ?R'4\\<rbrakk>\n       \\<Longrightarrow> lasso_impl s = lasso sa", "apply (rule intro_prgR[where R=bdfs_rel])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>Gi = G; accpti = accpt; fb_graph G\\<rbrakk>\n    \\<Longrightarrow> tailrec_impl_defs.tailrec_impl G\n                       (gen_param_dfs_defs.gds (pre_simple_impl.gbs G)\n                         (bdfs_params_impl G accpt)\n                         simple_state.more_update)\n                      \\<le> \\<Down> bdfs_rel\n                             (param_DFS_defs.it_dfs G\n                               (BlueDFS_defs.blue_dfs_params G accpt))\n 2. \\<And>s sa.\n       \\<lbrakk>Gi = G; accpti = accpt; fb_graph G;\n        (s, sa) \\<in> bdfs_rel\\<rbrakk>\n       \\<Longrightarrow> lasso_impl s = lasso sa", "defer"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s sa.\n       \\<lbrakk>Gi = G; accpti = accpt; fb_graph G;\n        (s, sa) \\<in> bdfs_rel\\<rbrakk>\n       \\<Longrightarrow> lasso_impl s = lasso sa\n 2. \\<lbrakk>Gi = G; accpti = accpt; fb_graph G\\<rbrakk>\n    \\<Longrightarrow> tailrec_impl_defs.tailrec_impl G\n                       (gen_param_dfs_defs.gds (pre_simple_impl.gbs G)\n                         (bdfs_params_impl G accpt)\n                         simple_state.more_update)\n                      \\<le> \\<Down> bdfs_rel\n                             (param_DFS_defs.it_dfs G\n                               (BlueDFS_defs.blue_dfs_params G accpt))", "apply (rename_tac si s)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>si s.\n       \\<lbrakk>Gi = G; accpti = accpt; fb_graph G;\n        (si, s) \\<in> bdfs_rel\\<rbrakk>\n       \\<Longrightarrow> lasso_impl si = lasso s\n 2. \\<lbrakk>Gi = G; accpti = accpt; fb_graph G\\<rbrakk>\n    \\<Longrightarrow> tailrec_impl_defs.tailrec_impl G\n                       (gen_param_dfs_defs.gds (pre_simple_impl.gbs G)\n                         (bdfs_params_impl G accpt)\n                         simple_state.more_update)\n                      \\<le> \\<Down> bdfs_rel\n                             (param_DFS_defs.it_dfs G\n                               (BlueDFS_defs.blue_dfs_params G accpt))", "apply (case_tac si, case_tac s)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>si s ss_stack on_stack visited lasso_impla red_impl counter\n       discovered finished pending stack tree_edges back_edges cross_edges\n       lassoa red.\n       \\<lbrakk>Gi = G; accpti = accpt; fb_graph G; (si, s) \\<in> bdfs_rel;\n        si =\n        \\<lparr>ss_stack = ss_stack, on_stack = on_stack, visited = visited,\n           lasso_impl = lasso_impla, red_impl = red_impl\\<rparr>;\n        s =\n        \\<lparr>counter = counter, discovered = discovered,\n           finished = finished, pending = pending, stack = stack,\n           tree_edges = tree_edges, back_edges = back_edges,\n           cross_edges = cross_edges, lasso = lassoa,\n           red = red\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> lasso_impl si = lasso s\n 2. \\<lbrakk>Gi = G; accpti = accpt; fb_graph G\\<rbrakk>\n    \\<Longrightarrow> tailrec_impl_defs.tailrec_impl G\n                       (gen_param_dfs_defs.gds (pre_simple_impl.gbs G)\n                         (bdfs_params_impl G accpt)\n                         simple_state.more_update)\n                      \\<le> \\<Down> bdfs_rel\n                             (param_DFS_defs.it_dfs G\n                               (BlueDFS_defs.blue_dfs_params G accpt))", "apply (auto simp: bdfs_erel_def simple_state_rel_def) []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Gi = G; accpti = accpt; fb_graph G\\<rbrakk>\n    \\<Longrightarrow> tailrec_impl_defs.tailrec_impl G\n                       (gen_param_dfs_defs.gds (pre_simple_impl.gbs G)\n                         (bdfs_params_impl G accpt)\n                         simple_state.more_update)\n                      \\<le> \\<Down> bdfs_rel\n                             (param_DFS_defs.it_dfs G\n                               (BlueDFS_defs.blue_dfs_params G accpt))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>Gi = G; accpti = accpt; fb_graph G\\<rbrakk>\n    \\<Longrightarrow> tailrec_impl_defs.tailrec_impl G\n                       (gen_param_dfs_defs.gds (pre_simple_impl.gbs G)\n                         (bdfs_params_impl G accpt)\n                         simple_state.more_update)\n                      \\<le> \\<Down> bdfs_rel\n                             (param_DFS_defs.it_dfs G\n                               (BlueDFS_defs.blue_dfs_params G accpt))", "assume \"fb_graph G\""], ["proof (state)\nthis:\n  fb_graph G\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Gi = G; accpti = accpt; fb_graph G\\<rbrakk>\n    \\<Longrightarrow> tailrec_impl_defs.tailrec_impl G\n                       (gen_param_dfs_defs.gds (pre_simple_impl.gbs G)\n                         (bdfs_params_impl G accpt)\n                         simple_state.more_update)\n                      \\<le> \\<Down> bdfs_rel\n                             (param_DFS_defs.it_dfs G\n                               (BlueDFS_defs.blue_dfs_params G accpt))", "then"], ["proof (chain)\npicking this:\n  fb_graph G", "interpret fb_graph G"], ["proof (prove)\nusing this:\n  fb_graph G\n\ngoal (1 subgoal):\n 1. fb_graph G", "."], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>Gi = G; accpti = accpt; fb_graph G\\<rbrakk>\n    \\<Longrightarrow> tailrec_impl_defs.tailrec_impl G\n                       (gen_param_dfs_defs.gds (pre_simple_impl.gbs G)\n                         (bdfs_params_impl G accpt)\n                         simple_state.more_update)\n                      \\<le> \\<Down> bdfs_rel\n                             (param_DFS_defs.it_dfs G\n                               (BlueDFS_defs.blue_dfs_params G accpt))", "interpret BlueDFS G"], ["proof (prove)\ngoal (1 subgoal):\n 1. BlueDFS G", "by unfold_locales"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>Gi = G; accpti = accpt; fb_graph G\\<rbrakk>\n    \\<Longrightarrow> tailrec_impl_defs.tailrec_impl G\n                       (gen_param_dfs_defs.gds (pre_simple_impl.gbs G)\n                         (bdfs_params_impl G accpt)\n                         simple_state.more_update)\n                      \\<le> \\<Down> bdfs_rel\n                             (param_DFS_defs.it_dfs G\n                               (BlueDFS_defs.blue_dfs_params G accpt))", "from impl"], ["proof (chain)\npicking this:\n  tailrec_impl_defs.tailrec_impl G\n   (gen_param_dfs_defs.gds (pre_simple_impl.gbs G)\n     (bdfs_params_impl G accpt) simple_state.more_update)\n  \\<le> \\<Down> bdfs_rel\n         (param_DFS_defs.it_dfs G (BlueDFS_defs.blue_dfs_params G accpt))", "show \"impl.tailrec_impl TYPE('b) G accpt \\<le>\\<Down>bdfs_rel (it_dfs TYPE('b) G accpt)\""], ["proof (prove)\nusing this:\n  tailrec_impl_defs.tailrec_impl G\n   (gen_param_dfs_defs.gds (pre_simple_impl.gbs G)\n     (bdfs_params_impl G accpt) simple_state.more_update)\n  \\<le> \\<Down> bdfs_rel\n         (param_DFS_defs.it_dfs G (BlueDFS_defs.blue_dfs_params G accpt))\n\ngoal (1 subgoal):\n 1. tailrec_impl_defs.tailrec_impl G\n     (gen_param_dfs_defs.gds (pre_simple_impl.gbs G)\n       (bdfs_params_impl G accpt) simple_state.more_update)\n    \\<le> \\<Down> bdfs_rel\n           (param_DFS_defs.it_dfs G (BlueDFS_defs.blue_dfs_params G accpt))", "."], ["proof (state)\nthis:\n  tailrec_impl_defs.tailrec_impl G\n   (gen_param_dfs_defs.gds (pre_simple_impl.gbs G)\n     (bdfs_params_impl G accpt) simple_state.more_update)\n  \\<le> \\<Down> bdfs_rel\n         (param_DFS_defs.it_dfs G (BlueDFS_defs.blue_dfs_params G accpt))\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Synthesis of Executable Code\\<close>"], ["", "(* Straightforward autoref implementation *)"], ["", "record ('v,'si,'nsi)bdfs_state_impl' = \"('si,'nsi)simple_state_impl\" +\n  lasso_impl' :: \"('v list \\<times> 'v list) option\"\n  red_impl' :: 'nsi"], ["", "definition [to_relAPP]: \"bdfs_state_erel' Vi \\<equiv> {\n  (\\<lparr>lasso_impl' = li, red_impl'=ri\\<rparr>,\\<lparr>lasso_impl = l, red_impl = r\\<rparr>) | li ri l r.\n    (li,l)\\<in>\\<langle>\\<langle>Vi\\<rangle>list_rel \\<times>\\<^sub>r \\<langle>Vi\\<rangle>list_rel\\<rangle>option_rel \\<and> (ri,r)\\<in>\\<langle>Vi\\<rangle>dflt_ahs_rel}\""], ["", "consts \n  i_bdfs_state_ext :: \"interface \\<Rightarrow> interface\""], ["", "lemmas [autoref_rel_intf] = REL_INTFI[of bdfs_state_erel' i_bdfs_state_ext]"], ["", "lemma [autoref_rules]:\n  fixes ns_rel vis_rel Vi\n  defines \"R \\<equiv> \\<langle>ns_rel,vis_rel,\\<langle>Vi\\<rangle>bdfs_state_erel'\\<rangle>ss_impl_rel\"\n  shows \n    \"(bdfs_state_impl'_ext, bdfs_state_impl_ext) \n      \\<in> \\<langle>\\<langle>Vi\\<rangle>list_rel \\<times>\\<^sub>r \\<langle>Vi\\<rangle>list_rel\\<rangle>option_rel \\<rightarrow> \\<langle>Vi\\<rangle>dflt_ahs_rel \\<rightarrow> unit_rel \\<rightarrow> \\<langle>Vi\\<rangle>bdfs_state_erel'\"\n    \"(lasso_impl', lasso_impl) \\<in> R \\<rightarrow> \\<langle>\\<langle>Vi\\<rangle>list_rel \\<times>\\<^sub>r \\<langle>Vi\\<rangle>list_rel\\<rangle>option_rel\"\n    \"(red_impl', red_impl) \\<in> R \\<rightarrow> \\<langle>Vi\\<rangle>dflt_ahs_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (bdfs_state_impl'_ext, bdfs_state_impl_ext)\n    \\<in> \\<langle>\\<langle>Vi\\<rangle>list_rel \\<times>\\<^sub>r\n                   \\<langle>Vi\\<rangle>list_rel\\<rangle>option_rel \\<rightarrow>\n          \\<langle>Vi\\<rangle>ahs_rel bounded_hashcode_nat \\<rightarrow>\n          unit_rel \\<rightarrow> \\<langle>Vi\\<rangle>bdfs_state_erel' &&&\n    (lasso_impl', lasso_impl)\n    \\<in> R \\<rightarrow>\n          \\<langle>\\<langle>Vi\\<rangle>list_rel \\<times>\\<^sub>r\n                   \\<langle>Vi\\<rangle>list_rel\\<rangle>option_rel &&&\n    (red_impl', red_impl)\n    \\<in> R \\<rightarrow> \\<langle>Vi\\<rangle>ahs_rel bounded_hashcode_nat", "unfolding bdfs_state_erel'_def ss_impl_rel_def R_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (bdfs_state_impl'_ext, bdfs_state_impl_ext)\n    \\<in> \\<langle>\\<langle>Vi\\<rangle>list_rel \\<times>\\<^sub>r\n                   \\<langle>Vi\\<rangle>list_rel\\<rangle>option_rel \\<rightarrow>\n          \\<langle>Vi\\<rangle>ahs_rel bounded_hashcode_nat \\<rightarrow>\n          unit_rel \\<rightarrow>\n          {(\\<lparr>lasso_impl' = li, red_impl' = ri\\<rparr>,\n            \\<lparr>lasso_impl = l, red_impl = r\\<rparr>) |\n           li ri l r.\n           (li, l)\n           \\<in> \\<langle>\\<langle>Vi\\<rangle>list_rel \\<times>\\<^sub>r\n                          \\<langle>Vi\\<rangle>list_rel\\<rangle>option_rel \\<and>\n           (ri, r)\n           \\<in> \\<langle>Vi\\<rangle>ahs_rel bounded_hashcode_nat} &&&\n    (lasso_impl', lasso_impl)\n    \\<in> {(\\<lparr>ss_stack_impl = si, ss_on_stack_impl = osi,\n               ss_visited_impl = visi, \\<dots> = mi\\<rparr>,\n            \\<lparr>ss_stack = s, on_stack = os, visited = vis,\n               \\<dots> = m\\<rparr>) |\n           si osi visi mi s os vis m.\n           (si, s) \\<in> ns_rel \\<and>\n           (osi, os) \\<in> vis_rel \\<and>\n           (visi, vis) \\<in> vis_rel \\<and>\n           (mi, m)\n           \\<in> {(\\<lparr>lasso_impl' = li, red_impl' = ri\\<rparr>,\n                   \\<lparr>lasso_impl = l, red_impl = r\\<rparr>) |\n                  li ri l r.\n                  (li, l)\n                  \\<in> \\<langle>\\<langle>Vi\\<rangle>list_rel \\<times>\\<^sub>r\n                                 \\<langle>Vi\\<rangle>list_rel\\<rangle>option_rel \\<and>\n                  (ri, r)\n                  \\<in> \\<langle>Vi\\<rangle>ahs_rel\n       bounded_hashcode_nat}} \\<rightarrow>\n          \\<langle>\\<langle>Vi\\<rangle>list_rel \\<times>\\<^sub>r\n                   \\<langle>Vi\\<rangle>list_rel\\<rangle>option_rel &&&\n    (red_impl', red_impl)\n    \\<in> {(\\<lparr>ss_stack_impl = si, ss_on_stack_impl = osi,\n               ss_visited_impl = visi, \\<dots> = mi\\<rparr>,\n            \\<lparr>ss_stack = s, on_stack = os, visited = vis,\n               \\<dots> = m\\<rparr>) |\n           si osi visi mi s os vis m.\n           (si, s) \\<in> ns_rel \\<and>\n           (osi, os) \\<in> vis_rel \\<and>\n           (visi, vis) \\<in> vis_rel \\<and>\n           (mi, m)\n           \\<in> {(\\<lparr>lasso_impl' = li, red_impl' = ri\\<rparr>,\n                   \\<lparr>lasso_impl = l, red_impl = r\\<rparr>) |\n                  li ri l r.\n                  (li, l)\n                  \\<in> \\<langle>\\<langle>Vi\\<rangle>list_rel \\<times>\\<^sub>r\n                                 \\<langle>Vi\\<rangle>list_rel\\<rangle>option_rel \\<and>\n                  (ri, r)\n                  \\<in> \\<langle>Vi\\<rangle>ahs_rel\n       bounded_hashcode_nat}} \\<rightarrow>\n          \\<langle>Vi\\<rangle>ahs_rel bounded_hashcode_nat", "by auto"], ["", "schematic_goal nested_dfs_code:\n  assumes Vid: \"V = (Id :: ('v::hashable \\<times> 'v) set)\"\n  assumes [unfolded Vid, autoref_rules]:\n    \"(Gi, G) \\<in> \\<langle>Rm, V\\<rangle>g_impl_rel_ext\"\n    \"(accpti,accpt) \\<in> (V \\<rightarrow> bool_rel)\"\n  notes [unfolded Vid, autoref_tyrel] = \n    TYRELI[where R=\"\\<langle>V\\<rangle>dflt_ahs_rel\"]\n    TYRELI[where R=\"\\<langle>V\\<rangle>ras_rel\"]\n  shows \"(nres_of ?c, nested_dfs_impl G accpt) \n    \\<in> \\<langle>\\<langle>\\<langle>V\\<rangle>list_rel \\<times>\\<^sub>r \\<langle>V\\<rangle>list_rel\\<rangle>option_rel\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (nres_of ?c, nested_dfs_impl G accpt)\n    \\<in> \\<langle>\\<langle>\\<langle>V\\<rangle>list_rel \\<times>\\<^sub>r\n                            \\<langle>V\\<rangle>list_rel\\<rangle>option_rel\\<rangle>nres_rel", "unfolding nested_dfs_impl_def[abs_def] Vid \n    se_back_edge_impl_def run_red_dfs_impl_def mk_blue_witness_impl_def\n    cyan_impl_def\n    DFS_code_unfold"], ["proof (prove)\ngoal (1 subgoal):\n 1. (nres_of ?c,\n     ASSERT (fb_graph G) \\<bind>\n     (\\<lambda>_.\n         RETURN \\<lparr>lasso_impl = None, red_impl = {}\\<rparr> \\<bind>\n         (\\<lambda>e.\n             RETURN\n              \\<lparr>ss_stack = [], on_stack = {}, visited = {},\n                 \\<dots> = e\\<rparr>) \\<bind>\n         FOREACH\\<^sub>C\\<^bsup>\\<lambda>it s.\n                                   rwof\n                                    (RETURN\n\\<lparr>lasso_impl = None, red_impl = {}\\<rparr> \\<bind>\n                                     (\\<lambda>e.\n   RETURN\n    \\<lparr>ss_stack = [], on_stack = {}, visited = {},\n       \\<dots> = e\\<rparr>))\n                                    (gen_dfs_defs.gen_cond\n(gen_param_dfs_defs.gds (pre_simple_impl.gbs G) (bdfs_params_impl G accpt)\n  simple_state.more_update)\n(g_V0 G))\n                                    (gen_dfs_defs.gen_step\n(gen_param_dfs_defs.gds (pre_simple_impl.gbs G) (bdfs_params_impl G accpt)\n  simple_state.more_update)\n(g_V0 G))\n                                    s \\<and>\n                                   (\\<not> lasso_impl s \\<noteq>\n     None \\<longrightarrow>\n                                    ss_stack s = []) \\<and>\n                                   g_V0 G - it\n                                   \\<subseteq> {v.\n          v \\<in> visited s}\\<^esup>\n          (g_V0 G) (\\<lambda>x. \\<not> lasso_impl x \\<noteq> None)\n          (\\<lambda>v0 s.\n              let s0 = s\n              in if v0 \\<in> visited s then RETURN s\n                 else ASSERT (v0 \\<notin> visited s) \\<bind>\n                      (\\<lambda>_.\n                          let s = s\\<lparr>ss_stack :=\n       [(v0, g_E G `` {v0})]\\<rparr>;\n                              s = s\\<lparr>on_stack := {v0}\\<rparr>\n                          in Let (s\\<lparr>visited :=\n       insert v0 (visited s)\\<rparr>)\n                              RETURN) \\<bind>\n                      (\\<lambda>s.\n                          RETURN (simple_state.more s) \\<bind>\n                          (\\<lambda>e.\n                              RETURN\n                               (s\\<lparr>simple_state.more :=\n     e\\<rparr>))) \\<bind>\n                      WHILE\\<^bsup>\\<lambda>s.\nrwof\n (RETURN \\<lparr>lasso_impl = None, red_impl = {}\\<rparr> \\<bind>\n  (\\<lambda>e.\n      RETURN\n       \\<lparr>ss_stack = [], on_stack = {}, visited = {},\n          \\<dots> = e\\<rparr>))\n (gen_dfs_defs.gen_cond\n   (gen_param_dfs_defs.gds (pre_simple_impl.gbs G)\n     (bdfs_params_impl G accpt) simple_state.more_update)\n   (g_V0 G))\n (gen_dfs_defs.gen_step\n   (gen_param_dfs_defs.gds (pre_simple_impl.gbs G)\n     (bdfs_params_impl G accpt) simple_state.more_update)\n   (g_V0 G))\n s \\<and>\ninsert v0 {v. v \\<in> visited s0} \\<subseteq> {v. v \\<in> visited s}\\<^esup>\n                       (\\<lambda>s.\n                           \\<not> lasso_impl s \\<noteq> None \\<and>\n                           ss_stack s \\<noteq> [])\n                       (\\<lambda>s.\n                           ASSERT (ss_stack s \\<noteq> []) \\<bind>\n                           (\\<lambda>_.\n                               let (u, Vs) = hd (ss_stack s)\n                               in if Vs = {} then RETURN (u, None, s)\n                                  else SPEC (\\<lambda>v. v \\<in> Vs) \\<bind>\n (\\<lambda>v.\n     let Vs = Vs - {v};\n         s = s\\<lparr>ss_stack := (u, Vs) # tl (ss_stack s)\\<rparr>\n     in RETURN (u, Some v, s))) \\<bind>\n                           (\\<lambda>(u, Vs, s).\n                               case Vs of\n                               None \\<Rightarrow>\n                                 ASSERT\n                                  (ss_stack s \\<noteq> [] \\<and>\n                                   u \\<in> on_stack s) \\<bind>\n                                 (\\<lambda>_.\n                                     let s = s\n     \\<lparr>ss_stack := tl (ss_stack s)\\<rparr>\n                                     in Let\n   (s\\<lparr>on_stack := on_stack s - {u}\\<rparr>) RETURN) \\<bind>\n                                 (\\<lambda>s.\n                                     (if accpt u\nthen case lasso_impl s of\n     None \\<Rightarrow>\n       find_path1_restr_spec (G\\<lparr>g_V0 := {u}\\<rparr>)\n        (\\<lambda>x. x = u \\<or> x \\<in> on_stack s) (red_impl s) \\<bind>\n       (\\<lambda>redS.\n           RETURN\n            (case redS of\n             Inl R' \\<Rightarrow>\n               \\<lparr>lasso_impl = None, red_impl = R'\\<rparr>\n             | Inr (vs, v) \\<Rightarrow>\n                 let rs = rev (map fst (CAST (ss_stack s)))\n                 in \\<lparr>lasso_impl = Some (rs, vs @ dropWhileNot v rs),\n                       red_impl = red_impl s\\<rparr>))\n     | Some a \\<Rightarrow> RETURN (simple_state.more s)\nelse RETURN (simple_state.more s)) \\<bind>\n                                     (\\<lambda>e.\n   RETURN (s\\<lparr>simple_state.more := e\\<rparr>)))\n                               | Some v \\<Rightarrow>\n                                   if v \\<in> visited s\n                                   then if v \\<in> visited s - on_stack s\n  then RETURN s \\<bind>\n       (\\<lambda>s.\n           RETURN (simple_state.more s) \\<bind>\n           (\\<lambda>e. RETURN (s\\<lparr>simple_state.more := e\\<rparr>)))\n  else RETURN s \\<bind>\n       (\\<lambda>s.\n           (case lasso_impl s of\n            None \\<Rightarrow>\n              if accpt u\n              then let rs = rev (map fst (tl (CAST (ss_stack s)))); ur = rs;\n                       ul = u # dropWhileNot v rs\n                   in RETURN\n                       \\<lparr>lasso_impl = Some (ur, ul),\n                          red_impl = red_impl s\\<rparr>\n              else if accpt v\n                   then let rs = rev (map fst (CAST (ss_stack s)));\n                            vr = takeWhileNot v rs; vl = dropWhileNot v rs\n                        in RETURN\n                            \\<lparr>lasso_impl = Some (vr, vl),\n                               red_impl = red_impl s\\<rparr>\n                   else RETURN (simple_state.more s)\n            | Some a \\<Rightarrow> RETURN (simple_state.more s)) \\<bind>\n           (\\<lambda>e. RETURN (s\\<lparr>simple_state.more := e\\<rparr>)))\n                                   else ASSERT\n   (v \\<notin> on_stack s \\<and> v \\<notin> visited s) \\<bind>\n  (\\<lambda>_.\n      let s = s\\<lparr>ss_stack := (v, g_E G `` {v}) # ss_stack s\\<rparr>;\n          s = s\\<lparr>on_stack := insert v (on_stack s)\\<rparr>\n      in Let (s\\<lparr>visited := insert v (visited s)\\<rparr>)\n          RETURN) \\<bind>\n  (\\<lambda>s.\n      RETURN (simple_state.more s) \\<bind>\n      (\\<lambda>e.\n          RETURN (s\\<lparr>simple_state.more := e\\<rparr>)))))) \\<bind>\n         (\\<lambda>s. RETURN (lasso_impl s))))\n    \\<in> \\<langle>\\<langle>\\<langle>Id\\<rangle>list_rel \\<times>\\<^sub>r\n                            \\<langle>Id\\<rangle>list_rel\\<rangle>option_rel\\<rangle>nres_rel", "(*apply (subst aux1)*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (nres_of ?c,\n     ASSERT (fb_graph G) \\<bind>\n     (\\<lambda>_.\n         RETURN \\<lparr>lasso_impl = None, red_impl = {}\\<rparr> \\<bind>\n         (\\<lambda>e.\n             RETURN\n              \\<lparr>ss_stack = [], on_stack = {}, visited = {},\n                 \\<dots> = e\\<rparr>) \\<bind>\n         FOREACH\\<^sub>C\\<^bsup>\\<lambda>it s.\n                                   rwof\n                                    (RETURN\n\\<lparr>lasso_impl = None, red_impl = {}\\<rparr> \\<bind>\n                                     (\\<lambda>e.\n   RETURN\n    \\<lparr>ss_stack = [], on_stack = {}, visited = {},\n       \\<dots> = e\\<rparr>))\n                                    (gen_dfs_defs.gen_cond\n(gen_param_dfs_defs.gds (pre_simple_impl.gbs G) (bdfs_params_impl G accpt)\n  simple_state.more_update)\n(g_V0 G))\n                                    (gen_dfs_defs.gen_step\n(gen_param_dfs_defs.gds (pre_simple_impl.gbs G) (bdfs_params_impl G accpt)\n  simple_state.more_update)\n(g_V0 G))\n                                    s \\<and>\n                                   (\\<not> lasso_impl s \\<noteq>\n     None \\<longrightarrow>\n                                    ss_stack s = []) \\<and>\n                                   g_V0 G - it\n                                   \\<subseteq> {v.\n          v \\<in> visited s}\\<^esup>\n          (g_V0 G) (\\<lambda>x. \\<not> lasso_impl x \\<noteq> None)\n          (\\<lambda>v0 s.\n              let s0 = s\n              in if v0 \\<in> visited s then RETURN s\n                 else ASSERT (v0 \\<notin> visited s) \\<bind>\n                      (\\<lambda>_.\n                          let s = s\\<lparr>ss_stack :=\n       [(v0, g_E G `` {v0})]\\<rparr>;\n                              s = s\\<lparr>on_stack := {v0}\\<rparr>\n                          in Let (s\\<lparr>visited :=\n       insert v0 (visited s)\\<rparr>)\n                              RETURN) \\<bind>\n                      (\\<lambda>s.\n                          RETURN (simple_state.more s) \\<bind>\n                          (\\<lambda>e.\n                              RETURN\n                               (s\\<lparr>simple_state.more :=\n     e\\<rparr>))) \\<bind>\n                      WHILE\\<^bsup>\\<lambda>s.\nrwof\n (RETURN \\<lparr>lasso_impl = None, red_impl = {}\\<rparr> \\<bind>\n  (\\<lambda>e.\n      RETURN\n       \\<lparr>ss_stack = [], on_stack = {}, visited = {},\n          \\<dots> = e\\<rparr>))\n (gen_dfs_defs.gen_cond\n   (gen_param_dfs_defs.gds (pre_simple_impl.gbs G)\n     (bdfs_params_impl G accpt) simple_state.more_update)\n   (g_V0 G))\n (gen_dfs_defs.gen_step\n   (gen_param_dfs_defs.gds (pre_simple_impl.gbs G)\n     (bdfs_params_impl G accpt) simple_state.more_update)\n   (g_V0 G))\n s \\<and>\ninsert v0 {v. v \\<in> visited s0} \\<subseteq> {v. v \\<in> visited s}\\<^esup>\n                       (\\<lambda>s.\n                           \\<not> lasso_impl s \\<noteq> None \\<and>\n                           ss_stack s \\<noteq> [])\n                       (\\<lambda>s.\n                           ASSERT (ss_stack s \\<noteq> []) \\<bind>\n                           (\\<lambda>_.\n                               let (u, Vs) = hd (ss_stack s)\n                               in if Vs = {} then RETURN (u, None, s)\n                                  else SPEC (\\<lambda>v. v \\<in> Vs) \\<bind>\n (\\<lambda>v.\n     let Vs = Vs - {v};\n         s = s\\<lparr>ss_stack := (u, Vs) # tl (ss_stack s)\\<rparr>\n     in RETURN (u, Some v, s))) \\<bind>\n                           (\\<lambda>(u, Vs, s).\n                               case Vs of\n                               None \\<Rightarrow>\n                                 ASSERT\n                                  (ss_stack s \\<noteq> [] \\<and>\n                                   u \\<in> on_stack s) \\<bind>\n                                 (\\<lambda>_.\n                                     let s = s\n     \\<lparr>ss_stack := tl (ss_stack s)\\<rparr>\n                                     in Let\n   (s\\<lparr>on_stack := on_stack s - {u}\\<rparr>) RETURN) \\<bind>\n                                 (\\<lambda>s.\n                                     (if accpt u\nthen case lasso_impl s of\n     None \\<Rightarrow>\n       find_path1_restr_spec (G\\<lparr>g_V0 := {u}\\<rparr>)\n        (\\<lambda>x. x = u \\<or> x \\<in> on_stack s) (red_impl s) \\<bind>\n       (\\<lambda>redS.\n           RETURN\n            (case redS of\n             Inl R' \\<Rightarrow>\n               \\<lparr>lasso_impl = None, red_impl = R'\\<rparr>\n             | Inr (vs, v) \\<Rightarrow>\n                 let rs = rev (map fst (CAST (ss_stack s)))\n                 in \\<lparr>lasso_impl = Some (rs, vs @ dropWhileNot v rs),\n                       red_impl = red_impl s\\<rparr>))\n     | Some a \\<Rightarrow> RETURN (simple_state.more s)\nelse RETURN (simple_state.more s)) \\<bind>\n                                     (\\<lambda>e.\n   RETURN (s\\<lparr>simple_state.more := e\\<rparr>)))\n                               | Some v \\<Rightarrow>\n                                   if v \\<in> visited s\n                                   then if v \\<in> visited s - on_stack s\n  then RETURN s \\<bind>\n       (\\<lambda>s.\n           RETURN (simple_state.more s) \\<bind>\n           (\\<lambda>e. RETURN (s\\<lparr>simple_state.more := e\\<rparr>)))\n  else RETURN s \\<bind>\n       (\\<lambda>s.\n           (case lasso_impl s of\n            None \\<Rightarrow>\n              if accpt u\n              then let rs = rev (map fst (tl (CAST (ss_stack s)))); ur = rs;\n                       ul = u # dropWhileNot v rs\n                   in RETURN\n                       \\<lparr>lasso_impl = Some (ur, ul),\n                          red_impl = red_impl s\\<rparr>\n              else if accpt v\n                   then let rs = rev (map fst (CAST (ss_stack s)));\n                            vr = takeWhileNot v rs; vl = dropWhileNot v rs\n                        in RETURN\n                            \\<lparr>lasso_impl = Some (vr, vl),\n                               red_impl = red_impl s\\<rparr>\n                   else RETURN (simple_state.more s)\n            | Some a \\<Rightarrow> RETURN (simple_state.more s)) \\<bind>\n           (\\<lambda>e. RETURN (s\\<lparr>simple_state.more := e\\<rparr>)))\n                                   else ASSERT\n   (v \\<notin> on_stack s \\<and> v \\<notin> visited s) \\<bind>\n  (\\<lambda>_.\n      let s = s\\<lparr>ss_stack := (v, g_E G `` {v}) # ss_stack s\\<rparr>;\n          s = s\\<lparr>on_stack := insert v (on_stack s)\\<rparr>\n      in Let (s\\<lparr>visited := insert v (visited s)\\<rparr>)\n          RETURN) \\<bind>\n  (\\<lambda>s.\n      RETURN (simple_state.more s) \\<bind>\n      (\\<lambda>e.\n          RETURN (s\\<lparr>simple_state.more := e\\<rparr>)))))) \\<bind>\n         (\\<lambda>s. RETURN (lasso_impl s))))\n    \\<in> \\<langle>\\<langle>\\<langle>Id\\<rangle>list_rel \\<times>\\<^sub>r\n                            \\<langle>Id\\<rangle>list_rel\\<rangle>option_rel\\<rangle>nres_rel", "using [[autoref_trace_failed_id]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (nres_of ?c,\n     ASSERT (fb_graph G) \\<bind>\n     (\\<lambda>_.\n         RETURN \\<lparr>lasso_impl = None, red_impl = {}\\<rparr> \\<bind>\n         (\\<lambda>e.\n             RETURN\n              \\<lparr>ss_stack = [], on_stack = {}, visited = {},\n                 \\<dots> = e\\<rparr>) \\<bind>\n         FOREACH\\<^sub>C\\<^bsup>\\<lambda>it s.\n                                   rwof\n                                    (RETURN\n\\<lparr>lasso_impl = None, red_impl = {}\\<rparr> \\<bind>\n                                     (\\<lambda>e.\n   RETURN\n    \\<lparr>ss_stack = [], on_stack = {}, visited = {},\n       \\<dots> = e\\<rparr>))\n                                    (gen_dfs_defs.gen_cond\n(gen_param_dfs_defs.gds (pre_simple_impl.gbs G) (bdfs_params_impl G accpt)\n  simple_state.more_update)\n(g_V0 G))\n                                    (gen_dfs_defs.gen_step\n(gen_param_dfs_defs.gds (pre_simple_impl.gbs G) (bdfs_params_impl G accpt)\n  simple_state.more_update)\n(g_V0 G))\n                                    s \\<and>\n                                   (\\<not> lasso_impl s \\<noteq>\n     None \\<longrightarrow>\n                                    ss_stack s = []) \\<and>\n                                   g_V0 G - it\n                                   \\<subseteq> {v.\n          v \\<in> visited s}\\<^esup>\n          (g_V0 G) (\\<lambda>x. \\<not> lasso_impl x \\<noteq> None)\n          (\\<lambda>v0 s.\n              let s0 = s\n              in if v0 \\<in> visited s then RETURN s\n                 else ASSERT (v0 \\<notin> visited s) \\<bind>\n                      (\\<lambda>_.\n                          let s = s\\<lparr>ss_stack :=\n       [(v0, g_E G `` {v0})]\\<rparr>;\n                              s = s\\<lparr>on_stack := {v0}\\<rparr>\n                          in Let (s\\<lparr>visited :=\n       insert v0 (visited s)\\<rparr>)\n                              RETURN) \\<bind>\n                      (\\<lambda>s.\n                          RETURN (simple_state.more s) \\<bind>\n                          (\\<lambda>e.\n                              RETURN\n                               (s\\<lparr>simple_state.more :=\n     e\\<rparr>))) \\<bind>\n                      WHILE\\<^bsup>\\<lambda>s.\nrwof\n (RETURN \\<lparr>lasso_impl = None, red_impl = {}\\<rparr> \\<bind>\n  (\\<lambda>e.\n      RETURN\n       \\<lparr>ss_stack = [], on_stack = {}, visited = {},\n          \\<dots> = e\\<rparr>))\n (gen_dfs_defs.gen_cond\n   (gen_param_dfs_defs.gds (pre_simple_impl.gbs G)\n     (bdfs_params_impl G accpt) simple_state.more_update)\n   (g_V0 G))\n (gen_dfs_defs.gen_step\n   (gen_param_dfs_defs.gds (pre_simple_impl.gbs G)\n     (bdfs_params_impl G accpt) simple_state.more_update)\n   (g_V0 G))\n s \\<and>\ninsert v0 {v. v \\<in> visited s0} \\<subseteq> {v. v \\<in> visited s}\\<^esup>\n                       (\\<lambda>s.\n                           \\<not> lasso_impl s \\<noteq> None \\<and>\n                           ss_stack s \\<noteq> [])\n                       (\\<lambda>s.\n                           ASSERT (ss_stack s \\<noteq> []) \\<bind>\n                           (\\<lambda>_.\n                               let (u, Vs) = hd (ss_stack s)\n                               in if Vs = {} then RETURN (u, None, s)\n                                  else SPEC (\\<lambda>v. v \\<in> Vs) \\<bind>\n (\\<lambda>v.\n     let Vs = Vs - {v};\n         s = s\\<lparr>ss_stack := (u, Vs) # tl (ss_stack s)\\<rparr>\n     in RETURN (u, Some v, s))) \\<bind>\n                           (\\<lambda>(u, Vs, s).\n                               case Vs of\n                               None \\<Rightarrow>\n                                 ASSERT\n                                  (ss_stack s \\<noteq> [] \\<and>\n                                   u \\<in> on_stack s) \\<bind>\n                                 (\\<lambda>_.\n                                     let s = s\n     \\<lparr>ss_stack := tl (ss_stack s)\\<rparr>\n                                     in Let\n   (s\\<lparr>on_stack := on_stack s - {u}\\<rparr>) RETURN) \\<bind>\n                                 (\\<lambda>s.\n                                     (if accpt u\nthen case lasso_impl s of\n     None \\<Rightarrow>\n       find_path1_restr_spec (G\\<lparr>g_V0 := {u}\\<rparr>)\n        (\\<lambda>x. x = u \\<or> x \\<in> on_stack s) (red_impl s) \\<bind>\n       (\\<lambda>redS.\n           RETURN\n            (case redS of\n             Inl R' \\<Rightarrow>\n               \\<lparr>lasso_impl = None, red_impl = R'\\<rparr>\n             | Inr (vs, v) \\<Rightarrow>\n                 let rs = rev (map fst (CAST (ss_stack s)))\n                 in \\<lparr>lasso_impl = Some (rs, vs @ dropWhileNot v rs),\n                       red_impl = red_impl s\\<rparr>))\n     | Some a \\<Rightarrow> RETURN (simple_state.more s)\nelse RETURN (simple_state.more s)) \\<bind>\n                                     (\\<lambda>e.\n   RETURN (s\\<lparr>simple_state.more := e\\<rparr>)))\n                               | Some v \\<Rightarrow>\n                                   if v \\<in> visited s\n                                   then if v \\<in> visited s - on_stack s\n  then RETURN s \\<bind>\n       (\\<lambda>s.\n           RETURN (simple_state.more s) \\<bind>\n           (\\<lambda>e. RETURN (s\\<lparr>simple_state.more := e\\<rparr>)))\n  else RETURN s \\<bind>\n       (\\<lambda>s.\n           (case lasso_impl s of\n            None \\<Rightarrow>\n              if accpt u\n              then let rs = rev (map fst (tl (CAST (ss_stack s)))); ur = rs;\n                       ul = u # dropWhileNot v rs\n                   in RETURN\n                       \\<lparr>lasso_impl = Some (ur, ul),\n                          red_impl = red_impl s\\<rparr>\n              else if accpt v\n                   then let rs = rev (map fst (CAST (ss_stack s)));\n                            vr = takeWhileNot v rs; vl = dropWhileNot v rs\n                        in RETURN\n                            \\<lparr>lasso_impl = Some (vr, vl),\n                               red_impl = red_impl s\\<rparr>\n                   else RETURN (simple_state.more s)\n            | Some a \\<Rightarrow> RETURN (simple_state.more s)) \\<bind>\n           (\\<lambda>e. RETURN (s\\<lparr>simple_state.more := e\\<rparr>)))\n                                   else ASSERT\n   (v \\<notin> on_stack s \\<and> v \\<notin> visited s) \\<bind>\n  (\\<lambda>_.\n      let s = s\\<lparr>ss_stack := (v, g_E G `` {v}) # ss_stack s\\<rparr>;\n          s = s\\<lparr>on_stack := insert v (on_stack s)\\<rparr>\n      in Let (s\\<lparr>visited := insert v (visited s)\\<rparr>)\n          RETURN) \\<bind>\n  (\\<lambda>s.\n      RETURN (simple_state.more s) \\<bind>\n      (\\<lambda>e.\n          RETURN (s\\<lparr>simple_state.more := e\\<rparr>)))))) \\<bind>\n         (\\<lambda>s. RETURN (lasso_impl s))))\n    \\<in> \\<langle>\\<langle>\\<langle>Id\\<rangle>list_rel \\<times>\\<^sub>r\n                            \\<langle>Id\\<rangle>list_rel\\<rangle>option_rel\\<rangle>nres_rel", "apply (autoref_monadic (trace))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "concrete_definition nested_dfs_code uses nested_dfs_code"], ["", "export_code nested_dfs_code checking SML"], ["", "subsection \\<open>Conclusion\\<close>"], ["", "text \\<open>\n  We have implemented an efficiently executable nested DFS algorithm.\n  The following theorem declares this implementation to the Autoref tool,\n  such that it uses it to synthesize efficient code for @{const nested_dfs}.\n  Note that you will need the lemma @{thm [source] nested_dfs_correct} to link\n  @{const nested_dfs} to an abstract specification, which is usually done in \n  a previous refinement step.\n\\<close>"], ["", "theorem nested_dfs_autoref[autoref_rules]:\n  assumes \"PREFER_id V\"\n  shows \"(\\<lambda> G accpt. nres_of (nested_dfs_code G accpt),nested_dfs) \\<in>\n    \\<langle>Rm, V\\<rangle>g_impl_rel_ext \\<rightarrow> (V \\<rightarrow> bool_rel) \\<rightarrow>\n    \\<langle>\\<langle>\\<langle>V\\<rangle>list_rel \\<times>\\<^sub>r \\<langle>V\\<rangle>list_rel\\<rangle>option_rel\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>G accpt. nres_of (nested_dfs_code G accpt), nested_dfs)\n    \\<in> \\<langle>Rm, V\\<rangle>g_impl_rel_ext \\<rightarrow>\n          (V \\<rightarrow> bool_rel) \\<rightarrow>\n          \\<langle>\\<langle>\\<langle>V\\<rangle>list_rel \\<times>\\<^sub>r\n                            \\<langle>V\\<rangle>list_rel\\<rangle>option_rel\\<rangle>nres_rel", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<lambda>G accpt. nres_of (nested_dfs_code G accpt), nested_dfs)\n    \\<in> \\<langle>Rm, V\\<rangle>g_impl_rel_ext \\<rightarrow>\n          (V \\<rightarrow> bool_rel) \\<rightarrow>\n          \\<langle>\\<langle>\\<langle>V\\<rangle>list_rel \\<times>\\<^sub>r\n                            \\<langle>V\\<rangle>list_rel\\<rangle>option_rel\\<rangle>nres_rel", "from assms"], ["proof (chain)\npicking this:\n  PREFER_id V", "have Vid: \"V=Id\""], ["proof (prove)\nusing this:\n  PREFER_id V\n\ngoal (1 subgoal):\n 1. V = Id", "by simp"], ["proof (state)\nthis:\n  V = Id\n\ngoal (1 subgoal):\n 1. (\\<lambda>G accpt. nres_of (nested_dfs_code G accpt), nested_dfs)\n    \\<in> \\<langle>Rm, V\\<rangle>g_impl_rel_ext \\<rightarrow>\n          (V \\<rightarrow> bool_rel) \\<rightarrow>\n          \\<langle>\\<langle>\\<langle>V\\<rangle>list_rel \\<times>\\<^sub>r\n                            \\<langle>V\\<rangle>list_rel\\<rangle>option_rel\\<rangle>nres_rel", "note nested_dfs_code.refine[OF Vid,param_fo, THEN nres_relD]"], ["proof (state)\nthis:\n  \\<lbrakk>(?Gi1, ?G1) \\<in> \\<langle>?Rm1, V\\<rangle>g_impl_rel_ext;\n   (?accpti1, ?accpt1) \\<in> V \\<rightarrow> bool_rel\\<rbrakk>\n  \\<Longrightarrow> nres_of (nested_dfs_code ?Gi1 ?accpti1)\n                    \\<le> \\<Down>\n                           (\\<langle>\\<langle>V\\<rangle>list_rel \\<times>\\<^sub>r\n                                     \\<langle>V\\<rangle>list_rel\\<rangle>option_rel)\n                           (nested_dfs_impl ?G1 ?accpt1)\n\ngoal (1 subgoal):\n 1. (\\<lambda>G accpt. nres_of (nested_dfs_code G accpt), nested_dfs)\n    \\<in> \\<langle>Rm, V\\<rangle>g_impl_rel_ext \\<rightarrow>\n          (V \\<rightarrow> bool_rel) \\<rightarrow>\n          \\<langle>\\<langle>\\<langle>V\\<rangle>list_rel \\<times>\\<^sub>r\n                            \\<langle>V\\<rangle>list_rel\\<rangle>option_rel\\<rangle>nres_rel", "also"], ["proof (state)\nthis:\n  \\<lbrakk>(?Gi1, ?G1) \\<in> \\<langle>?Rm1, V\\<rangle>g_impl_rel_ext;\n   (?accpti1, ?accpt1) \\<in> V \\<rightarrow> bool_rel\\<rbrakk>\n  \\<Longrightarrow> nres_of (nested_dfs_code ?Gi1 ?accpti1)\n                    \\<le> \\<Down>\n                           (\\<langle>\\<langle>V\\<rangle>list_rel \\<times>\\<^sub>r\n                                     \\<langle>V\\<rangle>list_rel\\<rangle>option_rel)\n                           (nested_dfs_impl ?G1 ?accpt1)\n\ngoal (1 subgoal):\n 1. (\\<lambda>G accpt. nres_of (nested_dfs_code G accpt), nested_dfs)\n    \\<in> \\<langle>Rm, V\\<rangle>g_impl_rel_ext \\<rightarrow>\n          (V \\<rightarrow> bool_rel) \\<rightarrow>\n          \\<langle>\\<langle>\\<langle>V\\<rangle>list_rel \\<times>\\<^sub>r\n                            \\<langle>V\\<rangle>list_rel\\<rangle>option_rel\\<rangle>nres_rel", "note nested_dfs_impl"], ["proof (state)\nthis:\n  \\<lbrakk>(?Gi, ?G) \\<in> Id; (?accpti, ?accpt) \\<in> Id\\<rbrakk>\n  \\<Longrightarrow> nested_dfs_impl ?Gi ?accpti\n                    \\<le> \\<Down>\n                           (\\<langle>\\<langle>Id\\<rangle>list_rel \\<times>\\<^sub>r\n                                     \\<langle>Id\\<rangle>list_rel\\<rangle>option_rel)\n                           (nested_dfs ?G ?accpt)\n\ngoal (1 subgoal):\n 1. (\\<lambda>G accpt. nres_of (nested_dfs_code G accpt), nested_dfs)\n    \\<in> \\<langle>Rm, V\\<rangle>g_impl_rel_ext \\<rightarrow>\n          (V \\<rightarrow> bool_rel) \\<rightarrow>\n          \\<langle>\\<langle>\\<langle>V\\<rangle>list_rel \\<times>\\<^sub>r\n                            \\<langle>V\\<rangle>list_rel\\<rangle>option_rel\\<rangle>nres_rel", "finally"], ["proof (chain)\npicking this:\n  \\<lbrakk>(?Gi3, ?Gi1) \\<in> \\<langle>?Rm3, V\\<rangle>g_impl_rel_ext;\n   (?accpti3, ?accpti1) \\<in> V \\<rightarrow> bool_rel;\n   (?Gi1, ?G1) \\<in> Id; (?accpti1, ?accpt1) \\<in> Id\\<rbrakk>\n  \\<Longrightarrow> nres_of (nested_dfs_code ?Gi3 ?accpti3)\n                    \\<le> \\<Down>\n                           (\\<langle>\\<langle>V\\<rangle>list_rel \\<times>\\<^sub>r\n                                     \\<langle>V\\<rangle>list_rel\\<rangle>option_rel)\n                           (\\<Down>\n                             (\\<langle>\\<langle>Id\\<rangle>list_rel \\<times>\\<^sub>r\n \\<langle>Id\\<rangle>list_rel\\<rangle>option_rel)\n                             (nested_dfs ?G1 ?accpt1))", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>(?Gi3, ?Gi1) \\<in> \\<langle>?Rm3, V\\<rangle>g_impl_rel_ext;\n   (?accpti3, ?accpti1) \\<in> V \\<rightarrow> bool_rel;\n   (?Gi1, ?G1) \\<in> Id; (?accpti1, ?accpt1) \\<in> Id\\<rbrakk>\n  \\<Longrightarrow> nres_of (nested_dfs_code ?Gi3 ?accpti3)\n                    \\<le> \\<Down>\n                           (\\<langle>\\<langle>V\\<rangle>list_rel \\<times>\\<^sub>r\n                                     \\<langle>V\\<rangle>list_rel\\<rangle>option_rel)\n                           (\\<Down>\n                             (\\<langle>\\<langle>Id\\<rangle>list_rel \\<times>\\<^sub>r\n \\<langle>Id\\<rangle>list_rel\\<rangle>option_rel)\n                             (nested_dfs ?G1 ?accpt1))\n\ngoal (1 subgoal):\n 1. (\\<lambda>G accpt. nres_of (nested_dfs_code G accpt), nested_dfs)\n    \\<in> \\<langle>Rm, V\\<rangle>g_impl_rel_ext \\<rightarrow>\n          (V \\<rightarrow> bool_rel) \\<rightarrow>\n          \\<langle>\\<langle>\\<langle>V\\<rangle>list_rel \\<times>\\<^sub>r\n                            \\<langle>V\\<rangle>list_rel\\<rangle>option_rel\\<rangle>nres_rel", "by (fastforce intro: nres_relI)"], ["proof (state)\nthis:\n  (\\<lambda>G accpt. nres_of (nested_dfs_code G accpt), nested_dfs)\n  \\<in> \\<langle>Rm, V\\<rangle>g_impl_rel_ext \\<rightarrow>\n        (V \\<rightarrow> bool_rel) \\<rightarrow>\n        \\<langle>\\<langle>\\<langle>V\\<rangle>list_rel \\<times>\\<^sub>r\n                          \\<langle>V\\<rangle>list_rel\\<rangle>option_rel\\<rangle>nres_rel\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}