{"file_name": "/home/qj213/afp-2021-10-22/thys/Shivers-CFA/ExCFSV.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Shivers-CFA", "problem_names": ["lemma benv_in_ve_upds:\n  assumes eq_length: \"length vs = length ds\"\n      and \"\\<forall>\\<beta>\\<in>benv_in_ve ve. Q \\<beta>\"\n      and \"\\<forall>d'\\<in>set ds. \\<forall>\\<beta>\\<in>benv_in_d d'. Q \\<beta>\"\n  shows   \"\\<forall>\\<beta>\\<in>benv_in_ve (ve(map (\\<lambda>v. (v, b'')) vs [\\<mapsto>] ds)). Q \\<beta>\"", "lemma benv_in_eval:\n  assumes \"\\<forall>\\<beta>'\\<in>benv_in_ve ve. Q \\<beta>'\"\n      and \"Q \\<beta>\"\n  shows \"\\<forall>\\<beta>\\<in>benv_in_d (\\<A> v \\<beta> ve). Q \\<beta>\"", "lemma contours_in_ve_empty[simp]: \"contours_in_ve Map.empty = {}\"", "lemma contours_in_ve_upds:\n  assumes eq_length: \"length vs = length ds\"\n      and \"\\<forall>b'\\<in>contours_in_ve ve. Q b'\"\n      and \"\\<forall>d'\\<in>set ds. \\<forall>b'\\<in>contours_in_d d'. Q b'\"\n  shows   \"\\<forall>b'\\<in>contours_in_ve (ve(map (\\<lambda>v. (v, b'')) vs [\\<mapsto>] ds)). Q b'\"", "lemma contours_in_ve_upds_binds:\n  assumes \"\\<forall>b'\\<in>contours_in_ve ve. Q b'\"\n      and \"\\<forall>b'\\<in>ran \\<beta>'. Q b'\"\n  shows   \"\\<forall>b'\\<in>contours_in_ve (ve ++ map_of (map (\\<lambda>(v,l). ((v,b''), \\<A> (L l) \\<beta>' ve)) ls)). Q b'\"", "lemma contours_in_eval:\n  assumes \"\\<forall>b'\\<in>contours_in_ve ve. Q b'\"\n      and \"\\<forall>b'\\<in> ran \\<beta>. Q b'\"\n  shows \"\\<forall>b'\\<in>contours_in_d (\\<A> f \\<beta> ve). Q b'\"", "lemma cc_single_valued':\n      \"\\<lbrakk> \\<forall>b' \\<in> contours_in_ve ve. b' < b\n       ; \\<forall>b' \\<in> contours_in_d d. b' < b\n       ; \\<forall>d' \\<in> set ds. \\<forall>b' \\<in> contours_in_d d'. b' < b\n       \\<rbrakk>\n       \\<Longrightarrow>\n       (   single_valued (\\<F>\\<cdot>(Discr (d,ds,ve,b)))\n       \\<and> (\\<forall> ((lab,\\<beta>),t) \\<in> \\<F>\\<cdot>(Discr (d,ds,ve, b)). \\<exists> b'. b' \\<in> ran \\<beta> \\<and> b \\<le> b')\n       )\"\n  and \"\\<lbrakk> b \\<in> ran \\<beta>'\n       ; \\<forall>b'\\<in>ran \\<beta>'. b' \\<le> b\n       ; \\<forall>b' \\<in> contours_in_ve ve. b' \\<le> b\n       \\<rbrakk>\n       \\<Longrightarrow>\n       (   single_valued (\\<C>\\<cdot>(Discr (c,\\<beta>',ve,b)))\n       \\<and> (\\<forall> ((lab,\\<beta>),t) \\<in> \\<C>\\<cdot>(Discr (c,\\<beta>',ve,b)). \\<exists> b'. b' \\<in> ran \\<beta> \\<and> b \\<le> b')\n       )\"", "lemma \"single_valued (\\<PR> prog)\""], "translations": [["", "lemma benv_in_ve_upds:\n  assumes eq_length: \"length vs = length ds\"\n      and \"\\<forall>\\<beta>\\<in>benv_in_ve ve. Q \\<beta>\"\n      and \"\\<forall>d'\\<in>set ds. \\<forall>\\<beta>\\<in>benv_in_d d'. Q \\<beta>\"\n  shows   \"\\<forall>\\<beta>\\<in>benv_in_ve (ve(map (\\<lambda>v. (v, b'')) vs [\\<mapsto>] ds)). Q \\<beta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<beta>\n             \\<in>benv_in_ve\n                   (ve(map (\\<lambda>v. (v, b'')) vs [\\<mapsto>] ds)).\n       Q \\<beta>", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<beta>.\n       \\<beta>\n       \\<in> benv_in_ve\n              (ve(map (\\<lambda>v. (v, b'')) vs [\\<mapsto>]\n               ds)) \\<Longrightarrow>\n       Q \\<beta>", "fix \\<beta>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<beta>.\n       \\<beta>\n       \\<in> benv_in_ve\n              (ve(map (\\<lambda>v. (v, b'')) vs [\\<mapsto>]\n               ds)) \\<Longrightarrow>\n       Q \\<beta>", "assume ass:\"\\<beta> \\<in> benv_in_ve (ve(map (\\<lambda>v. (v, b'')) vs [\\<mapsto>] ds))\""], ["proof (state)\nthis:\n  \\<beta>\n  \\<in> benv_in_ve (ve(map (\\<lambda>v. (v, b'')) vs [\\<mapsto>] ds))\n\ngoal (1 subgoal):\n 1. \\<And>\\<beta>.\n       \\<beta>\n       \\<in> benv_in_ve\n              (ve(map (\\<lambda>v. (v, b'')) vs [\\<mapsto>]\n               ds)) \\<Longrightarrow>\n       Q \\<beta>", "then"], ["proof (chain)\npicking this:\n  \\<beta>\n  \\<in> benv_in_ve (ve(map (\\<lambda>v. (v, b'')) vs [\\<mapsto>] ds))", "obtain d where \"\\<beta>\\<in>benv_in_d d\" and \"d \\<in> ran (ve(map (\\<lambda>v. (v, b'')) vs [\\<mapsto>] ds))\""], ["proof (prove)\nusing this:\n  \\<beta>\n  \\<in> benv_in_ve (ve(map (\\<lambda>v. (v, b'')) vs [\\<mapsto>] ds))\n\ngoal (1 subgoal):\n 1. (\\<And>d.\n        \\<lbrakk>\\<beta> \\<in> benv_in_d d;\n         d \\<in> ran (ve(map (\\<lambda>v. (v, b'')) vs [\\<mapsto>]\n                      ds))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding benv_in_ve_def"], ["proof (prove)\nusing this:\n  \\<beta>\n  \\<in> \\<Union>\n         {benv_in_d d |d.\n          d \\<in> ran (ve(map (\\<lambda>v. (v, b'')) vs [\\<mapsto>] ds))}\n\ngoal (1 subgoal):\n 1. (\\<And>d.\n        \\<lbrakk>\\<beta> \\<in> benv_in_d d;\n         d \\<in> ran (ve(map (\\<lambda>v. (v, b'')) vs [\\<mapsto>]\n                      ds))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  \\<beta> \\<in> benv_in_d d\n  d \\<in> ran (ve(map (\\<lambda>v. (v, b'')) vs [\\<mapsto>] ds))\n\ngoal (1 subgoal):\n 1. \\<And>\\<beta>.\n       \\<beta>\n       \\<in> benv_in_ve\n              (ve(map (\\<lambda>v. (v, b'')) vs [\\<mapsto>]\n               ds)) \\<Longrightarrow>\n       Q \\<beta>", "moreover"], ["proof (state)\nthis:\n  \\<beta> \\<in> benv_in_d d\n  d \\<in> ran (ve(map (\\<lambda>v. (v, b'')) vs [\\<mapsto>] ds))\n\ngoal (1 subgoal):\n 1. \\<And>\\<beta>.\n       \\<beta>\n       \\<in> benv_in_ve\n              (ve(map (\\<lambda>v. (v, b'')) vs [\\<mapsto>]\n               ds)) \\<Longrightarrow>\n       Q \\<beta>", "have \"ran (ve(map (\\<lambda>v. (v, b'')) vs [\\<mapsto>] ds)) \\<subseteq> ran ve \\<union> set ds\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ran (ve(map (\\<lambda>v. (v, b'')) vs [\\<mapsto>] ds))\n    \\<subseteq> ran ve \\<union> set ds", "using eq_length"], ["proof (prove)\nusing this:\n  length vs = length ds\n\ngoal (1 subgoal):\n 1. ran (ve(map (\\<lambda>v. (v, b'')) vs [\\<mapsto>] ds))\n    \\<subseteq> ran ve \\<union> set ds", "by(auto intro!:ran_upds)"], ["proof (state)\nthis:\n  ran (ve(map (\\<lambda>v. (v, b'')) vs [\\<mapsto>] ds))\n  \\<subseteq> ran ve \\<union> set ds\n\ngoal (1 subgoal):\n 1. \\<And>\\<beta>.\n       \\<beta>\n       \\<in> benv_in_ve\n              (ve(map (\\<lambda>v. (v, b'')) vs [\\<mapsto>]\n               ds)) \\<Longrightarrow>\n       Q \\<beta>", "ultimately"], ["proof (chain)\npicking this:\n  \\<beta> \\<in> benv_in_d d\n  d \\<in> ran (ve(map (\\<lambda>v. (v, b'')) vs [\\<mapsto>] ds))\n  ran (ve(map (\\<lambda>v. (v, b'')) vs [\\<mapsto>] ds))\n  \\<subseteq> ran ve \\<union> set ds", "have \"d \\<in> ran ve \\<or> d \\<in> set ds\""], ["proof (prove)\nusing this:\n  \\<beta> \\<in> benv_in_d d\n  d \\<in> ran (ve(map (\\<lambda>v. (v, b'')) vs [\\<mapsto>] ds))\n  ran (ve(map (\\<lambda>v. (v, b'')) vs [\\<mapsto>] ds))\n  \\<subseteq> ran ve \\<union> set ds\n\ngoal (1 subgoal):\n 1. d \\<in> ran ve \\<or> d \\<in> set ds", "by auto"], ["proof (state)\nthis:\n  d \\<in> ran ve \\<or> d \\<in> set ds\n\ngoal (1 subgoal):\n 1. \\<And>\\<beta>.\n       \\<beta>\n       \\<in> benv_in_ve\n              (ve(map (\\<lambda>v. (v, b'')) vs [\\<mapsto>]\n               ds)) \\<Longrightarrow>\n       Q \\<beta>", "thus \"Q \\<beta>\""], ["proof (prove)\nusing this:\n  d \\<in> ran ve \\<or> d \\<in> set ds\n\ngoal (1 subgoal):\n 1. Q \\<beta>", "using assms(2,3) \\<open>\\<beta>\\<in>benv_in_d d\\<close>"], ["proof (prove)\nusing this:\n  d \\<in> ran ve \\<or> d \\<in> set ds\n  \\<forall>\\<beta>\\<in>benv_in_ve ve. Q \\<beta>\n  \\<forall>d'\\<in>set ds. \\<forall>\\<beta>\\<in>benv_in_d d'. Q \\<beta>\n  \\<beta> \\<in> benv_in_d d\n\ngoal (1 subgoal):\n 1. Q \\<beta>", "unfolding benv_in_ve_def"], ["proof (prove)\nusing this:\n  d \\<in> ran ve \\<or> d \\<in> set ds\n  \\<forall>\\<beta>\\<in>\\<Union> {benv_in_d d |d. d \\<in> ran ve}. Q \\<beta>\n  \\<forall>d'\\<in>set ds. \\<forall>\\<beta>\\<in>benv_in_d d'. Q \\<beta>\n  \\<beta> \\<in> benv_in_d d\n\ngoal (1 subgoal):\n 1. Q \\<beta>", "by auto"], ["proof (state)\nthis:\n  Q \\<beta>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma benv_in_eval:\n  assumes \"\\<forall>\\<beta>'\\<in>benv_in_ve ve. Q \\<beta>'\"\n      and \"Q \\<beta>\"\n  shows \"\\<forall>\\<beta>\\<in>benv_in_d (\\<A> v \\<beta> ve). Q \\<beta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<beta>\\<in>benv_in_d (\\<A> v \\<beta> ve). Q \\<beta>", "proof(cases v)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x1.\n       v = L x1 \\<Longrightarrow>\n       \\<forall>\\<beta>\\<in>benv_in_d (\\<A> v \\<beta> ve). Q \\<beta>\n 2. \\<And>x21 x22.\n       v = R x21 x22 \\<Longrightarrow>\n       \\<forall>\\<beta>\\<in>benv_in_d (\\<A> v \\<beta> ve). Q \\<beta>\n 3. \\<And>x31 x32.\n       v = C x31 x32 \\<Longrightarrow>\n       \\<forall>\\<beta>\\<in>benv_in_d (\\<A> v \\<beta> ve). Q \\<beta>\n 4. \\<And>x4.\n       v = P x4 \\<Longrightarrow>\n       \\<forall>\\<beta>\\<in>benv_in_d (\\<A> v \\<beta> ve). Q \\<beta>", "case (R _ var)"], ["proof (state)\nthis:\n  v = R x21_ var\n\ngoal (4 subgoals):\n 1. \\<And>x1.\n       v = L x1 \\<Longrightarrow>\n       \\<forall>\\<beta>\\<in>benv_in_d (\\<A> v \\<beta> ve). Q \\<beta>\n 2. \\<And>x21 x22.\n       v = R x21 x22 \\<Longrightarrow>\n       \\<forall>\\<beta>\\<in>benv_in_d (\\<A> v \\<beta> ve). Q \\<beta>\n 3. \\<And>x31 x32.\n       v = C x31 x32 \\<Longrightarrow>\n       \\<forall>\\<beta>\\<in>benv_in_d (\\<A> v \\<beta> ve). Q \\<beta>\n 4. \\<And>x4.\n       v = P x4 \\<Longrightarrow>\n       \\<forall>\\<beta>\\<in>benv_in_d (\\<A> v \\<beta> ve). Q \\<beta>", "thus ?thesis"], ["proof (prove)\nusing this:\n  v = R x21_ var\n\ngoal (1 subgoal):\n 1. \\<forall>\\<beta>\\<in>benv_in_d (\\<A> v \\<beta> ve). Q \\<beta>", "proof (cases \"\\<beta> (fst var)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>v = R x21_ var; \\<beta> (fst var) = None\\<rbrakk>\n    \\<Longrightarrow> \\<forall>\\<beta>\\<in>benv_in_d (\\<A> v \\<beta> ve).\n                         Q \\<beta>\n 2. \\<And>a.\n       \\<lbrakk>v = R x21_ var; \\<beta> (fst var) = Some a\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<beta>\\<in>benv_in_d (\\<A> v \\<beta> ve).\n                            Q \\<beta>", "case None"], ["proof (state)\nthis:\n  \\<beta> (fst var) = None\n\ngoal (2 subgoals):\n 1. \\<lbrakk>v = R x21_ var; \\<beta> (fst var) = None\\<rbrakk>\n    \\<Longrightarrow> \\<forall>\\<beta>\\<in>benv_in_d (\\<A> v \\<beta> ve).\n                         Q \\<beta>\n 2. \\<And>a.\n       \\<lbrakk>v = R x21_ var; \\<beta> (fst var) = Some a\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<beta>\\<in>benv_in_d (\\<A> v \\<beta> ve).\n                            Q \\<beta>", "with R"], ["proof (chain)\npicking this:\n  v = R x21_ var\n  \\<beta> (fst var) = None", "show ?thesis"], ["proof (prove)\nusing this:\n  v = R x21_ var\n  \\<beta> (fst var) = None\n\ngoal (1 subgoal):\n 1. \\<forall>\\<beta>\\<in>benv_in_d (\\<A> v \\<beta> ve). Q \\<beta>", "by simp"], ["proof (state)\nthis:\n  \\<forall>\\<beta>\\<in>benv_in_d (\\<A> v \\<beta> ve). Q \\<beta>\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>v = R x21_ var; \\<beta> (fst var) = Some a\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<beta>\\<in>benv_in_d (\\<A> v \\<beta> ve).\n                            Q \\<beta>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>v = R x21_ var; \\<beta> (fst var) = Some a\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<beta>\\<in>benv_in_d (\\<A> v \\<beta> ve).\n                            Q \\<beta>", "case (Some cnt)"], ["proof (state)\nthis:\n  \\<beta> (fst var) = Some cnt\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>v = R x21_ var; \\<beta> (fst var) = Some a\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<beta>\\<in>benv_in_d (\\<A> v \\<beta> ve).\n                            Q \\<beta>", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<beta>\\<in>benv_in_d (\\<A> v \\<beta> ve). Q \\<beta>", "proof (cases \"ve (var,cnt)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. ve (var, cnt) = None \\<Longrightarrow>\n    \\<forall>\\<beta>\\<in>benv_in_d (\\<A> v \\<beta> ve). Q \\<beta>\n 2. \\<And>a.\n       ve (var, cnt) = Some a \\<Longrightarrow>\n       \\<forall>\\<beta>\\<in>benv_in_d (\\<A> v \\<beta> ve). Q \\<beta>", "case None"], ["proof (state)\nthis:\n  ve (var, cnt) = None\n\ngoal (2 subgoals):\n 1. ve (var, cnt) = None \\<Longrightarrow>\n    \\<forall>\\<beta>\\<in>benv_in_d (\\<A> v \\<beta> ve). Q \\<beta>\n 2. \\<And>a.\n       ve (var, cnt) = Some a \\<Longrightarrow>\n       \\<forall>\\<beta>\\<in>benv_in_d (\\<A> v \\<beta> ve). Q \\<beta>", "with Some R"], ["proof (chain)\npicking this:\n  \\<beta> (fst var) = Some cnt\n  v = R x21_ var\n  ve (var, cnt) = None", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<beta> (fst var) = Some cnt\n  v = R x21_ var\n  ve (var, cnt) = None\n\ngoal (1 subgoal):\n 1. \\<forall>\\<beta>\\<in>benv_in_d (\\<A> v \\<beta> ve). Q \\<beta>", "by simp"], ["proof (state)\nthis:\n  \\<forall>\\<beta>\\<in>benv_in_d (\\<A> v \\<beta> ve). Q \\<beta>\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       ve (var, cnt) = Some a \\<Longrightarrow>\n       \\<forall>\\<beta>\\<in>benv_in_d (\\<A> v \\<beta> ve). Q \\<beta>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       ve (var, cnt) = Some a \\<Longrightarrow>\n       \\<forall>\\<beta>\\<in>benv_in_d (\\<A> v \\<beta> ve). Q \\<beta>", "case (Some d)"], ["proof (state)\nthis:\n  ve (var, cnt) = Some d\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       ve (var, cnt) = Some a \\<Longrightarrow>\n       \\<forall>\\<beta>\\<in>benv_in_d (\\<A> v \\<beta> ve). Q \\<beta>", "hence \"d \\<in> ran ve\""], ["proof (prove)\nusing this:\n  ve (var, cnt) = Some d\n\ngoal (1 subgoal):\n 1. d \\<in> ran ve", "unfolding ran_def"], ["proof (prove)\nusing this:\n  ve (var, cnt) = Some d\n\ngoal (1 subgoal):\n 1. d \\<in> {b. \\<exists>a. ve a = Some b}", "by blast"], ["proof (state)\nthis:\n  d \\<in> ran ve\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       ve (var, cnt) = Some a \\<Longrightarrow>\n       \\<forall>\\<beta>\\<in>benv_in_d (\\<A> v \\<beta> ve). Q \\<beta>", "thus ?thesis"], ["proof (prove)\nusing this:\n  d \\<in> ran ve\n\ngoal (1 subgoal):\n 1. \\<forall>\\<beta>\\<in>benv_in_d (\\<A> v \\<beta> ve). Q \\<beta>", "using Some \\<open>\\<beta> (fst var) = Some cnt\\<close> R assms(1)"], ["proof (prove)\nusing this:\n  d \\<in> ran ve\n  ve (var, cnt) = Some d\n  \\<beta> (fst var) = Some cnt\n  v = R x21_ var\n  \\<forall>\\<beta>'\\<in>benv_in_ve ve. Q \\<beta>'\n\ngoal (1 subgoal):\n 1. \\<forall>\\<beta>\\<in>benv_in_d (\\<A> v \\<beta> ve). Q \\<beta>", "unfolding benv_in_ve_def"], ["proof (prove)\nusing this:\n  d \\<in> ran ve\n  ve (var, cnt) = Some d\n  \\<beta> (fst var) = Some cnt\n  v = R x21_ var\n  \\<forall>\\<beta>'\\<in>\\<Union> {benv_in_d d |d. d \\<in> ran ve}.\n     Q \\<beta>'\n\ngoal (1 subgoal):\n 1. \\<forall>\\<beta>\\<in>benv_in_d (\\<A> v \\<beta> ve). Q \\<beta>", "by auto"], ["proof (state)\nthis:\n  \\<forall>\\<beta>\\<in>benv_in_d (\\<A> v \\<beta> ve). Q \\<beta>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>\\<beta>\\<in>benv_in_d (\\<A> v \\<beta> ve). Q \\<beta>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>\\<beta>\\<in>benv_in_d (\\<A> v \\<beta> ve). Q \\<beta>\n\ngoal (3 subgoals):\n 1. \\<And>x1.\n       v = L x1 \\<Longrightarrow>\n       \\<forall>\\<beta>\\<in>benv_in_d (\\<A> v \\<beta> ve). Q \\<beta>\n 2. \\<And>x31 x32.\n       v = C x31 x32 \\<Longrightarrow>\n       \\<forall>\\<beta>\\<in>benv_in_d (\\<A> v \\<beta> ve). Q \\<beta>\n 3. \\<And>x4.\n       v = P x4 \\<Longrightarrow>\n       \\<forall>\\<beta>\\<in>benv_in_d (\\<A> v \\<beta> ve). Q \\<beta>", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x1.\n       v = L x1 \\<Longrightarrow>\n       \\<forall>\\<beta>\\<in>benv_in_d (\\<A> v \\<beta> ve). Q \\<beta>\n 2. \\<And>x31 x32.\n       v = C x31 x32 \\<Longrightarrow>\n       \\<forall>\\<beta>\\<in>benv_in_d (\\<A> v \\<beta> ve). Q \\<beta>\n 3. \\<And>x4.\n       v = P x4 \\<Longrightarrow>\n       \\<forall>\\<beta>\\<in>benv_in_d (\\<A> v \\<beta> ve). Q \\<beta>", "case (L l)"], ["proof (state)\nthis:\n  v = L l\n\ngoal (3 subgoals):\n 1. \\<And>x1.\n       v = L x1 \\<Longrightarrow>\n       \\<forall>\\<beta>\\<in>benv_in_d (\\<A> v \\<beta> ve). Q \\<beta>\n 2. \\<And>x31 x32.\n       v = C x31 x32 \\<Longrightarrow>\n       \\<forall>\\<beta>\\<in>benv_in_d (\\<A> v \\<beta> ve). Q \\<beta>\n 3. \\<And>x4.\n       v = P x4 \\<Longrightarrow>\n       \\<forall>\\<beta>\\<in>benv_in_d (\\<A> v \\<beta> ve). Q \\<beta>", "thus ?thesis"], ["proof (prove)\nusing this:\n  v = L l\n\ngoal (1 subgoal):\n 1. \\<forall>\\<beta>\\<in>benv_in_d (\\<A> v \\<beta> ve). Q \\<beta>", "using assms(2)"], ["proof (prove)\nusing this:\n  v = L l\n  Q \\<beta>\n\ngoal (1 subgoal):\n 1. \\<forall>\\<beta>\\<in>benv_in_d (\\<A> v \\<beta> ve). Q \\<beta>", "by simp"], ["proof (state)\nthis:\n  \\<forall>\\<beta>\\<in>benv_in_d (\\<A> v \\<beta> ve). Q \\<beta>\n\ngoal (2 subgoals):\n 1. \\<And>x31 x32.\n       v = C x31 x32 \\<Longrightarrow>\n       \\<forall>\\<beta>\\<in>benv_in_d (\\<A> v \\<beta> ve). Q \\<beta>\n 2. \\<And>x4.\n       v = P x4 \\<Longrightarrow>\n       \\<forall>\\<beta>\\<in>benv_in_d (\\<A> v \\<beta> ve). Q \\<beta>", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x31 x32.\n       v = C x31 x32 \\<Longrightarrow>\n       \\<forall>\\<beta>\\<in>benv_in_d (\\<A> v \\<beta> ve). Q \\<beta>\n 2. \\<And>x4.\n       v = P x4 \\<Longrightarrow>\n       \\<forall>\\<beta>\\<in>benv_in_d (\\<A> v \\<beta> ve). Q \\<beta>", "case C"], ["proof (state)\nthis:\n  v = C x31_ x32_\n\ngoal (2 subgoals):\n 1. \\<And>x31 x32.\n       v = C x31 x32 \\<Longrightarrow>\n       \\<forall>\\<beta>\\<in>benv_in_d (\\<A> v \\<beta> ve). Q \\<beta>\n 2. \\<And>x4.\n       v = P x4 \\<Longrightarrow>\n       \\<forall>\\<beta>\\<in>benv_in_d (\\<A> v \\<beta> ve). Q \\<beta>", "thus ?thesis"], ["proof (prove)\nusing this:\n  v = C x31_ x32_\n\ngoal (1 subgoal):\n 1. \\<forall>\\<beta>\\<in>benv_in_d (\\<A> v \\<beta> ve). Q \\<beta>", "by simp"], ["proof (state)\nthis:\n  \\<forall>\\<beta>\\<in>benv_in_d (\\<A> v \\<beta> ve). Q \\<beta>\n\ngoal (1 subgoal):\n 1. \\<And>x4.\n       v = P x4 \\<Longrightarrow>\n       \\<forall>\\<beta>\\<in>benv_in_d (\\<A> v \\<beta> ve). Q \\<beta>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x4.\n       v = P x4 \\<Longrightarrow>\n       \\<forall>\\<beta>\\<in>benv_in_d (\\<A> v \\<beta> ve). Q \\<beta>", "case P"], ["proof (state)\nthis:\n  v = P x4_\n\ngoal (1 subgoal):\n 1. \\<And>x4.\n       v = P x4 \\<Longrightarrow>\n       \\<forall>\\<beta>\\<in>benv_in_d (\\<A> v \\<beta> ve). Q \\<beta>", "thus ?thesis"], ["proof (prove)\nusing this:\n  v = P x4_\n\ngoal (1 subgoal):\n 1. \\<forall>\\<beta>\\<in>benv_in_d (\\<A> v \\<beta> ve). Q \\<beta>", "by simp"], ["proof (state)\nthis:\n  \\<forall>\\<beta>\\<in>benv_in_d (\\<A> v \\<beta> ve). Q \\<beta>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma contours_in_ve_empty[simp]: \"contours_in_ve Map.empty = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. contours_in_ve Map.empty = {}", "unfolding contours_in_ve_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> {contours_in_d d |d. d \\<in> ran Map.empty} = {}", "by auto"], ["", "lemma contours_in_ve_upds:\n  assumes eq_length: \"length vs = length ds\"\n      and \"\\<forall>b'\\<in>contours_in_ve ve. Q b'\"\n      and \"\\<forall>d'\\<in>set ds. \\<forall>b'\\<in>contours_in_d d'. Q b'\"\n  shows   \"\\<forall>b'\\<in>contours_in_ve (ve(map (\\<lambda>v. (v, b'')) vs [\\<mapsto>] ds)). Q b'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>b'\\<in>contours_in_ve\n                     (ve(map (\\<lambda>v. (v, b'')) vs [\\<mapsto>] ds)).\n       Q b'", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>b'\\<in>contours_in_ve\n                     (ve(map (\\<lambda>v. (v, b'')) vs [\\<mapsto>] ds)).\n       Q b'", "have \"ran (ve(map (\\<lambda>v. (v, b'')) vs [\\<mapsto>] ds)) \\<subseteq> ran ve \\<union> set ds\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ran (ve(map (\\<lambda>v. (v, b'')) vs [\\<mapsto>] ds))\n    \\<subseteq> ran ve \\<union> set ds", "using eq_length"], ["proof (prove)\nusing this:\n  length vs = length ds\n\ngoal (1 subgoal):\n 1. ran (ve(map (\\<lambda>v. (v, b'')) vs [\\<mapsto>] ds))\n    \\<subseteq> ran ve \\<union> set ds", "by(auto intro!:ran_upds)"], ["proof (state)\nthis:\n  ran (ve(map (\\<lambda>v. (v, b'')) vs [\\<mapsto>] ds))\n  \\<subseteq> ran ve \\<union> set ds\n\ngoal (1 subgoal):\n 1. \\<forall>b'\\<in>contours_in_ve\n                     (ve(map (\\<lambda>v. (v, b'')) vs [\\<mapsto>] ds)).\n       Q b'", "thus ?thesis"], ["proof (prove)\nusing this:\n  ran (ve(map (\\<lambda>v. (v, b'')) vs [\\<mapsto>] ds))\n  \\<subseteq> ran ve \\<union> set ds\n\ngoal (1 subgoal):\n 1. \\<forall>b'\\<in>contours_in_ve\n                     (ve(map (\\<lambda>v. (v, b'')) vs [\\<mapsto>] ds)).\n       Q b'", "using assms(2,3)"], ["proof (prove)\nusing this:\n  ran (ve(map (\\<lambda>v. (v, b'')) vs [\\<mapsto>] ds))\n  \\<subseteq> ran ve \\<union> set ds\n  \\<forall>b'\\<in>contours_in_ve ve. Q b'\n  \\<forall>d'\\<in>set ds. \\<forall>b'\\<in>contours_in_d d'. Q b'\n\ngoal (1 subgoal):\n 1. \\<forall>b'\\<in>contours_in_ve\n                     (ve(map (\\<lambda>v. (v, b'')) vs [\\<mapsto>] ds)).\n       Q b'", "unfolding contours_in_ve_def"], ["proof (prove)\nusing this:\n  ran (ve(map (\\<lambda>v. (v, b'')) vs [\\<mapsto>] ds))\n  \\<subseteq> ran ve \\<union> set ds\n  \\<forall>b'\\<in>\\<Union> {contours_in_d d |d. d \\<in> ran ve}. Q b'\n  \\<forall>d'\\<in>set ds. \\<forall>b'\\<in>contours_in_d d'. Q b'\n\ngoal (1 subgoal):\n 1. \\<forall>b'\\<in>\\<Union>\n                     {contours_in_d d |d.\n                      d \\<in> ran (ve(map (\\<lambda>v. (v, b'')) vs \n                                   [\\<mapsto>] ds))}.\n       Q b'", "by blast"], ["proof (state)\nthis:\n  \\<forall>b'\\<in>contours_in_ve\n                   (ve(map (\\<lambda>v. (v, b'')) vs [\\<mapsto>] ds)).\n     Q b'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma contours_in_ve_upds_binds:\n  assumes \"\\<forall>b'\\<in>contours_in_ve ve. Q b'\"\n      and \"\\<forall>b'\\<in>ran \\<beta>'. Q b'\"\n  shows   \"\\<forall>b'\\<in>contours_in_ve (ve ++ map_of (map (\\<lambda>(v,l). ((v,b''), \\<A> (L l) \\<beta>' ve)) ls)). Q b'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>b'\\<in>contours_in_ve\n                     (ve ++\n                      map_of\n                       (map (\\<lambda>(v, l).\n                                ((v, b''), \\<A> (L l) \\<beta>' ve))\n                         ls)).\n       Q b'", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>b'.\n       b' \\<in> contours_in_ve\n                 (ve ++\n                  map_of\n                   (map (\\<lambda>(v, l).\n                            ((v, b''), \\<A> (L l) \\<beta>' ve))\n                     ls)) \\<Longrightarrow>\n       Q b'", "fix b'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>b'.\n       b' \\<in> contours_in_ve\n                 (ve ++\n                  map_of\n                   (map (\\<lambda>(v, l).\n                            ((v, b''), \\<A> (L l) \\<beta>' ve))\n                     ls)) \\<Longrightarrow>\n       Q b'", "assume \"b'\\<in>contours_in_ve (ve ++ map_of (map (\\<lambda>(v,l). ((v,b''), \\<A> (L l) \\<beta>' ve)) ls))\""], ["proof (state)\nthis:\n  b' \\<in> contours_in_ve\n            (ve ++\n             map_of\n              (map (\\<lambda>(v, l). ((v, b''), \\<A> (L l) \\<beta>' ve))\n                ls))\n\ngoal (1 subgoal):\n 1. \\<And>b'.\n       b' \\<in> contours_in_ve\n                 (ve ++\n                  map_of\n                   (map (\\<lambda>(v, l).\n                            ((v, b''), \\<A> (L l) \\<beta>' ve))\n                     ls)) \\<Longrightarrow>\n       Q b'", "then"], ["proof (chain)\npicking this:\n  b' \\<in> contours_in_ve\n            (ve ++\n             map_of\n              (map (\\<lambda>(v, l). ((v, b''), \\<A> (L l) \\<beta>' ve))\n                ls))", "obtain d where d:\"d \\<in> ran (ve ++ map_of (map (\\<lambda>(v,l). ((v,b''), \\<A> (L l) \\<beta>' ve)) ls))\" and b:\"b' \\<in> contours_in_d d\""], ["proof (prove)\nusing this:\n  b' \\<in> contours_in_ve\n            (ve ++\n             map_of\n              (map (\\<lambda>(v, l). ((v, b''), \\<A> (L l) \\<beta>' ve))\n                ls))\n\ngoal (1 subgoal):\n 1. (\\<And>d.\n        \\<lbrakk>d \\<in> ran (ve ++\n                              map_of\n                               (map (\\<lambda>(v, l).\n  ((v, b''), \\<A> (L l) \\<beta>' ve))\n                                 ls));\n         b' \\<in> contours_in_d d\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding contours_in_ve_def"], ["proof (prove)\nusing this:\n  b' \\<in> \\<Union>\n            {contours_in_d d |d.\n             d \\<in> ran (ve ++\n                          map_of\n                           (map (\\<lambda>(v, l).\n                                    ((v, b''), \\<A> (L l) \\<beta>' ve))\n                             ls))}\n\ngoal (1 subgoal):\n 1. (\\<And>d.\n        \\<lbrakk>d \\<in> ran (ve ++\n                              map_of\n                               (map (\\<lambda>(v, l).\n  ((v, b''), \\<A> (L l) \\<beta>' ve))\n                                 ls));\n         b' \\<in> contours_in_d d\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  d \\<in> ran (ve ++\n               map_of\n                (map (\\<lambda>(v, l). ((v, b''), \\<A> (L l) \\<beta>' ve))\n                  ls))\n  b' \\<in> contours_in_d d\n\ngoal (1 subgoal):\n 1. \\<And>b'.\n       b' \\<in> contours_in_ve\n                 (ve ++\n                  map_of\n                   (map (\\<lambda>(v, l).\n                            ((v, b''), \\<A> (L l) \\<beta>' ve))\n                     ls)) \\<Longrightarrow>\n       Q b'", "have \"ran (ve ++ map_of (map (\\<lambda>(v,l). ((v,b''), \\<A> (L l) \\<beta>' ve)) ls)) \\<subseteq> ran ve \\<union> ran (map_of (map (\\<lambda>(v,l). ((v,b''), \\<A> (L l) \\<beta>' ve)) ls))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ran (ve ++\n         map_of\n          (map (\\<lambda>(v, l). ((v, b''), \\<A> (L l) \\<beta>' ve)) ls))\n    \\<subseteq> ran ve \\<union>\n                ran (map_of\n                      (map (\\<lambda>(v, l).\n                               ((v, b''), \\<A> (L l) \\<beta>' ve))\n                        ls))", "by(auto intro!:ran_concat)"], ["proof (state)\nthis:\n  ran (ve ++\n       map_of\n        (map (\\<lambda>(v, l). ((v, b''), \\<A> (L l) \\<beta>' ve)) ls))\n  \\<subseteq> ran ve \\<union>\n              ran (map_of\n                    (map (\\<lambda>(v, l).\n                             ((v, b''), \\<A> (L l) \\<beta>' ve))\n                      ls))\n\ngoal (1 subgoal):\n 1. \\<And>b'.\n       b' \\<in> contours_in_ve\n                 (ve ++\n                  map_of\n                   (map (\\<lambda>(v, l).\n                            ((v, b''), \\<A> (L l) \\<beta>' ve))\n                     ls)) \\<Longrightarrow>\n       Q b'", "also"], ["proof (state)\nthis:\n  ran (ve ++\n       map_of\n        (map (\\<lambda>(v, l). ((v, b''), \\<A> (L l) \\<beta>' ve)) ls))\n  \\<subseteq> ran ve \\<union>\n              ran (map_of\n                    (map (\\<lambda>(v, l).\n                             ((v, b''), \\<A> (L l) \\<beta>' ve))\n                      ls))\n\ngoal (1 subgoal):\n 1. \\<And>b'.\n       b' \\<in> contours_in_ve\n                 (ve ++\n                  map_of\n                   (map (\\<lambda>(v, l).\n                            ((v, b''), \\<A> (L l) \\<beta>' ve))\n                     ls)) \\<Longrightarrow>\n       Q b'", "have \"\\<dots> \\<subseteq> ran ve \\<union> snd ` set (map (\\<lambda>(v,l). ((v,b''), \\<A> (L l) \\<beta>' ve)) ls)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ran ve \\<union>\n    ran (map_of\n          (map (\\<lambda>(v, l). ((v, b''), \\<A> (L l) \\<beta>' ve)) ls))\n    \\<subseteq> ran ve \\<union>\n                snd `\n                set (map (\\<lambda>(v, l).\n                             ((v, b''), \\<A> (L l) \\<beta>' ve))\n                      ls)", "by (rule Un_mono[of \"ran ve\" \"ran ve\", OF subset_refl ran_map_of])"], ["proof (state)\nthis:\n  ran ve \\<union>\n  ran (map_of\n        (map (\\<lambda>(v, l). ((v, b''), \\<A> (L l) \\<beta>' ve)) ls))\n  \\<subseteq> ran ve \\<union>\n              snd `\n              set (map (\\<lambda>(v, l). ((v, b''), \\<A> (L l) \\<beta>' ve))\n                    ls)\n\ngoal (1 subgoal):\n 1. \\<And>b'.\n       b' \\<in> contours_in_ve\n                 (ve ++\n                  map_of\n                   (map (\\<lambda>(v, l).\n                            ((v, b''), \\<A> (L l) \\<beta>' ve))\n                     ls)) \\<Longrightarrow>\n       Q b'", "also"], ["proof (state)\nthis:\n  ran ve \\<union>\n  ran (map_of\n        (map (\\<lambda>(v, l). ((v, b''), \\<A> (L l) \\<beta>' ve)) ls))\n  \\<subseteq> ran ve \\<union>\n              snd `\n              set (map (\\<lambda>(v, l). ((v, b''), \\<A> (L l) \\<beta>' ve))\n                    ls)\n\ngoal (1 subgoal):\n 1. \\<And>b'.\n       b' \\<in> contours_in_ve\n                 (ve ++\n                  map_of\n                   (map (\\<lambda>(v, l).\n                            ((v, b''), \\<A> (L l) \\<beta>' ve))\n                     ls)) \\<Longrightarrow>\n       Q b'", "have \"\\<dots> \\<subseteq> ran ve \\<union> set (map (\\<lambda>(v,l). (\\<A> (L l) \\<beta>' ve)) ls)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ran ve \\<union>\n    snd ` set (map (\\<lambda>(v, l). ((v, b''), \\<A> (L l) \\<beta>' ve)) ls)\n    \\<subseteq> ran ve \\<union>\n                set (map (\\<lambda>(v, l). \\<A> (L l) \\<beta>' ve) ls)", "by (rule Un_mono[of \"ran ve\" \"ran ve\", OF subset_refl ])auto"], ["proof (state)\nthis:\n  ran ve \\<union>\n  snd ` set (map (\\<lambda>(v, l). ((v, b''), \\<A> (L l) \\<beta>' ve)) ls)\n  \\<subseteq> ran ve \\<union>\n              set (map (\\<lambda>(v, l). \\<A> (L l) \\<beta>' ve) ls)\n\ngoal (1 subgoal):\n 1. \\<And>b'.\n       b' \\<in> contours_in_ve\n                 (ve ++\n                  map_of\n                   (map (\\<lambda>(v, l).\n                            ((v, b''), \\<A> (L l) \\<beta>' ve))\n                     ls)) \\<Longrightarrow>\n       Q b'", "finally"], ["proof (chain)\npicking this:\n  ran (ve ++\n       map_of\n        (map (\\<lambda>(v, l). ((v, b''), \\<A> (L l) \\<beta>' ve)) ls))\n  \\<subseteq> ran ve \\<union>\n              set (map (\\<lambda>(v, l). \\<A> (L l) \\<beta>' ve) ls)", "have \"d \\<in>  ran ve \\<union> set (map (\\<lambda>(v,l). (\\<A> (L l) \\<beta>' ve)) ls)\""], ["proof (prove)\nusing this:\n  ran (ve ++\n       map_of\n        (map (\\<lambda>(v, l). ((v, b''), \\<A> (L l) \\<beta>' ve)) ls))\n  \\<subseteq> ran ve \\<union>\n              set (map (\\<lambda>(v, l). \\<A> (L l) \\<beta>' ve) ls)\n\ngoal (1 subgoal):\n 1. d \\<in> ran ve \\<union>\n            set (map (\\<lambda>(v, l). \\<A> (L l) \\<beta>' ve) ls)", "using d"], ["proof (prove)\nusing this:\n  ran (ve ++\n       map_of\n        (map (\\<lambda>(v, l). ((v, b''), \\<A> (L l) \\<beta>' ve)) ls))\n  \\<subseteq> ran ve \\<union>\n              set (map (\\<lambda>(v, l). \\<A> (L l) \\<beta>' ve) ls)\n  d \\<in> ran (ve ++\n               map_of\n                (map (\\<lambda>(v, l). ((v, b''), \\<A> (L l) \\<beta>' ve))\n                  ls))\n\ngoal (1 subgoal):\n 1. d \\<in> ran ve \\<union>\n            set (map (\\<lambda>(v, l). \\<A> (L l) \\<beta>' ve) ls)", "by auto"], ["proof (state)\nthis:\n  d \\<in> ran ve \\<union>\n          set (map (\\<lambda>(v, l). \\<A> (L l) \\<beta>' ve) ls)\n\ngoal (1 subgoal):\n 1. \\<And>b'.\n       b' \\<in> contours_in_ve\n                 (ve ++\n                  map_of\n                   (map (\\<lambda>(v, l).\n                            ((v, b''), \\<A> (L l) \\<beta>' ve))\n                     ls)) \\<Longrightarrow>\n       Q b'", "thus \"Q b'\""], ["proof (prove)\nusing this:\n  d \\<in> ran ve \\<union>\n          set (map (\\<lambda>(v, l). \\<A> (L l) \\<beta>' ve) ls)\n\ngoal (1 subgoal):\n 1. Q b'", "using assms b"], ["proof (prove)\nusing this:\n  d \\<in> ran ve \\<union>\n          set (map (\\<lambda>(v, l). \\<A> (L l) \\<beta>' ve) ls)\n  \\<forall>b'\\<in>contours_in_ve ve. Q b'\n  \\<forall>b'\\<in>ran \\<beta>'. Q b'\n  b' \\<in> contours_in_d d\n\ngoal (1 subgoal):\n 1. Q b'", "unfolding contours_in_ve_def"], ["proof (prove)\nusing this:\n  d \\<in> ran ve \\<union>\n          set (map (\\<lambda>(v, l). \\<A> (L l) \\<beta>' ve) ls)\n  \\<forall>b'\\<in>\\<Union> {contours_in_d d |d. d \\<in> ran ve}. Q b'\n  \\<forall>b'\\<in>ran \\<beta>'. Q b'\n  b' \\<in> contours_in_d d\n\ngoal (1 subgoal):\n 1. Q b'", "by auto"], ["proof (state)\nthis:\n  Q b'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma contours_in_eval:\n  assumes \"\\<forall>b'\\<in>contours_in_ve ve. Q b'\"\n      and \"\\<forall>b'\\<in> ran \\<beta>. Q b'\"\n  shows \"\\<forall>b'\\<in>contours_in_d (\\<A> f \\<beta> ve). Q b'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>b'\\<in>contours_in_d (\\<A> f \\<beta> ve). Q b'", "unfolding contours_in_ve_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>b'\\<in>contours_in_d (\\<A> f \\<beta> ve). Q b'", "proof(cases f)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x1.\n       f = L x1 \\<Longrightarrow>\n       \\<forall>b'\\<in>contours_in_d (\\<A> f \\<beta> ve). Q b'\n 2. \\<And>x21 x22.\n       f = R x21 x22 \\<Longrightarrow>\n       \\<forall>b'\\<in>contours_in_d (\\<A> f \\<beta> ve). Q b'\n 3. \\<And>x31 x32.\n       f = C x31 x32 \\<Longrightarrow>\n       \\<forall>b'\\<in>contours_in_d (\\<A> f \\<beta> ve). Q b'\n 4. \\<And>x4.\n       f = P x4 \\<Longrightarrow>\n       \\<forall>b'\\<in>contours_in_d (\\<A> f \\<beta> ve). Q b'", "case (R _ var)"], ["proof (state)\nthis:\n  f = R x21_ var\n\ngoal (4 subgoals):\n 1. \\<And>x1.\n       f = L x1 \\<Longrightarrow>\n       \\<forall>b'\\<in>contours_in_d (\\<A> f \\<beta> ve). Q b'\n 2. \\<And>x21 x22.\n       f = R x21 x22 \\<Longrightarrow>\n       \\<forall>b'\\<in>contours_in_d (\\<A> f \\<beta> ve). Q b'\n 3. \\<And>x31 x32.\n       f = C x31 x32 \\<Longrightarrow>\n       \\<forall>b'\\<in>contours_in_d (\\<A> f \\<beta> ve). Q b'\n 4. \\<And>x4.\n       f = P x4 \\<Longrightarrow>\n       \\<forall>b'\\<in>contours_in_d (\\<A> f \\<beta> ve). Q b'", "thus ?thesis"], ["proof (prove)\nusing this:\n  f = R x21_ var\n\ngoal (1 subgoal):\n 1. \\<forall>b'\\<in>contours_in_d (\\<A> f \\<beta> ve). Q b'", "proof (cases \"\\<beta> (fst var)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>f = R x21_ var; \\<beta> (fst var) = None\\<rbrakk>\n    \\<Longrightarrow> \\<forall>b'\\<in>contours_in_d (\\<A> f \\<beta> ve).\n                         Q b'\n 2. \\<And>a.\n       \\<lbrakk>f = R x21_ var; \\<beta> (fst var) = Some a\\<rbrakk>\n       \\<Longrightarrow> \\<forall>b'\\<in>contours_in_d (\\<A> f \\<beta> ve).\n                            Q b'", "case None"], ["proof (state)\nthis:\n  \\<beta> (fst var) = None\n\ngoal (2 subgoals):\n 1. \\<lbrakk>f = R x21_ var; \\<beta> (fst var) = None\\<rbrakk>\n    \\<Longrightarrow> \\<forall>b'\\<in>contours_in_d (\\<A> f \\<beta> ve).\n                         Q b'\n 2. \\<And>a.\n       \\<lbrakk>f = R x21_ var; \\<beta> (fst var) = Some a\\<rbrakk>\n       \\<Longrightarrow> \\<forall>b'\\<in>contours_in_d (\\<A> f \\<beta> ve).\n                            Q b'", "with R"], ["proof (chain)\npicking this:\n  f = R x21_ var\n  \\<beta> (fst var) = None", "show ?thesis"], ["proof (prove)\nusing this:\n  f = R x21_ var\n  \\<beta> (fst var) = None\n\ngoal (1 subgoal):\n 1. \\<forall>b'\\<in>contours_in_d (\\<A> f \\<beta> ve). Q b'", "by simp"], ["proof (state)\nthis:\n  \\<forall>b'\\<in>contours_in_d (\\<A> f \\<beta> ve). Q b'\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>f = R x21_ var; \\<beta> (fst var) = Some a\\<rbrakk>\n       \\<Longrightarrow> \\<forall>b'\\<in>contours_in_d (\\<A> f \\<beta> ve).\n                            Q b'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>f = R x21_ var; \\<beta> (fst var) = Some a\\<rbrakk>\n       \\<Longrightarrow> \\<forall>b'\\<in>contours_in_d (\\<A> f \\<beta> ve).\n                            Q b'", "case (Some cnt)"], ["proof (state)\nthis:\n  \\<beta> (fst var) = Some cnt\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>f = R x21_ var; \\<beta> (fst var) = Some a\\<rbrakk>\n       \\<Longrightarrow> \\<forall>b'\\<in>contours_in_d (\\<A> f \\<beta> ve).\n                            Q b'", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>b'\\<in>contours_in_d (\\<A> f \\<beta> ve). Q b'", "proof (cases \"ve (var,cnt)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. ve (var, cnt) = None \\<Longrightarrow>\n    \\<forall>b'\\<in>contours_in_d (\\<A> f \\<beta> ve). Q b'\n 2. \\<And>a.\n       ve (var, cnt) = Some a \\<Longrightarrow>\n       \\<forall>b'\\<in>contours_in_d (\\<A> f \\<beta> ve). Q b'", "case None"], ["proof (state)\nthis:\n  ve (var, cnt) = None\n\ngoal (2 subgoals):\n 1. ve (var, cnt) = None \\<Longrightarrow>\n    \\<forall>b'\\<in>contours_in_d (\\<A> f \\<beta> ve). Q b'\n 2. \\<And>a.\n       ve (var, cnt) = Some a \\<Longrightarrow>\n       \\<forall>b'\\<in>contours_in_d (\\<A> f \\<beta> ve). Q b'", "with Some R"], ["proof (chain)\npicking this:\n  \\<beta> (fst var) = Some cnt\n  f = R x21_ var\n  ve (var, cnt) = None", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<beta> (fst var) = Some cnt\n  f = R x21_ var\n  ve (var, cnt) = None\n\ngoal (1 subgoal):\n 1. \\<forall>b'\\<in>contours_in_d (\\<A> f \\<beta> ve). Q b'", "by simp"], ["proof (state)\nthis:\n  \\<forall>b'\\<in>contours_in_d (\\<A> f \\<beta> ve). Q b'\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       ve (var, cnt) = Some a \\<Longrightarrow>\n       \\<forall>b'\\<in>contours_in_d (\\<A> f \\<beta> ve). Q b'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       ve (var, cnt) = Some a \\<Longrightarrow>\n       \\<forall>b'\\<in>contours_in_d (\\<A> f \\<beta> ve). Q b'", "case (Some d)"], ["proof (state)\nthis:\n  ve (var, cnt) = Some d\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       ve (var, cnt) = Some a \\<Longrightarrow>\n       \\<forall>b'\\<in>contours_in_d (\\<A> f \\<beta> ve). Q b'", "hence \"d \\<in> ran ve\""], ["proof (prove)\nusing this:\n  ve (var, cnt) = Some d\n\ngoal (1 subgoal):\n 1. d \\<in> ran ve", "unfolding ran_def"], ["proof (prove)\nusing this:\n  ve (var, cnt) = Some d\n\ngoal (1 subgoal):\n 1. d \\<in> {b. \\<exists>a. ve a = Some b}", "by blast"], ["proof (state)\nthis:\n  d \\<in> ran ve\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       ve (var, cnt) = Some a \\<Longrightarrow>\n       \\<forall>b'\\<in>contours_in_d (\\<A> f \\<beta> ve). Q b'", "thus ?thesis"], ["proof (prove)\nusing this:\n  d \\<in> ran ve\n\ngoal (1 subgoal):\n 1. \\<forall>b'\\<in>contours_in_d (\\<A> f \\<beta> ve). Q b'", "using Some \\<open>\\<beta> (fst var) = Some cnt\\<close> R \\<open>\\<forall>b'\\<in>contours_in_ve ve. Q b'\\<close>"], ["proof (prove)\nusing this:\n  d \\<in> ran ve\n  ve (var, cnt) = Some d\n  \\<beta> (fst var) = Some cnt\n  f = R x21_ var\n  \\<forall>b'\\<in>contours_in_ve ve. Q b'\n\ngoal (1 subgoal):\n 1. \\<forall>b'\\<in>contours_in_d (\\<A> f \\<beta> ve). Q b'", "unfolding contours_in_ve_def"], ["proof (prove)\nusing this:\n  d \\<in> ran ve\n  ve (var, cnt) = Some d\n  \\<beta> (fst var) = Some cnt\n  f = R x21_ var\n  \\<forall>b'\\<in>\\<Union> {contours_in_d d |d. d \\<in> ran ve}. Q b'\n\ngoal (1 subgoal):\n 1. \\<forall>b'\\<in>contours_in_d (\\<A> f \\<beta> ve). Q b'", "by auto"], ["proof (state)\nthis:\n  \\<forall>b'\\<in>contours_in_d (\\<A> f \\<beta> ve). Q b'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>b'\\<in>contours_in_d (\\<A> f \\<beta> ve). Q b'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>b'\\<in>contours_in_d (\\<A> f \\<beta> ve). Q b'\n\ngoal (3 subgoals):\n 1. \\<And>x1.\n       f = L x1 \\<Longrightarrow>\n       \\<forall>b'\\<in>contours_in_d (\\<A> f \\<beta> ve). Q b'\n 2. \\<And>x31 x32.\n       f = C x31 x32 \\<Longrightarrow>\n       \\<forall>b'\\<in>contours_in_d (\\<A> f \\<beta> ve). Q b'\n 3. \\<And>x4.\n       f = P x4 \\<Longrightarrow>\n       \\<forall>b'\\<in>contours_in_d (\\<A> f \\<beta> ve). Q b'", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x1.\n       f = L x1 \\<Longrightarrow>\n       \\<forall>b'\\<in>contours_in_d (\\<A> f \\<beta> ve). Q b'\n 2. \\<And>x31 x32.\n       f = C x31 x32 \\<Longrightarrow>\n       \\<forall>b'\\<in>contours_in_d (\\<A> f \\<beta> ve). Q b'\n 3. \\<And>x4.\n       f = P x4 \\<Longrightarrow>\n       \\<forall>b'\\<in>contours_in_d (\\<A> f \\<beta> ve). Q b'", "case (L l)"], ["proof (state)\nthis:\n  f = L l\n\ngoal (3 subgoals):\n 1. \\<And>x1.\n       f = L x1 \\<Longrightarrow>\n       \\<forall>b'\\<in>contours_in_d (\\<A> f \\<beta> ve). Q b'\n 2. \\<And>x31 x32.\n       f = C x31 x32 \\<Longrightarrow>\n       \\<forall>b'\\<in>contours_in_d (\\<A> f \\<beta> ve). Q b'\n 3. \\<And>x4.\n       f = P x4 \\<Longrightarrow>\n       \\<forall>b'\\<in>contours_in_d (\\<A> f \\<beta> ve). Q b'", "thus ?thesis"], ["proof (prove)\nusing this:\n  f = L l\n\ngoal (1 subgoal):\n 1. \\<forall>b'\\<in>contours_in_d (\\<A> f \\<beta> ve). Q b'", "using \\<open>\\<forall>b'\\<in> ran \\<beta>. Q b'\\<close>"], ["proof (prove)\nusing this:\n  f = L l\n  \\<forall>b'\\<in>ran \\<beta>. Q b'\n\ngoal (1 subgoal):\n 1. \\<forall>b'\\<in>contours_in_d (\\<A> f \\<beta> ve). Q b'", "by simp"], ["proof (state)\nthis:\n  \\<forall>b'\\<in>contours_in_d (\\<A> f \\<beta> ve). Q b'\n\ngoal (2 subgoals):\n 1. \\<And>x31 x32.\n       f = C x31 x32 \\<Longrightarrow>\n       \\<forall>b'\\<in>contours_in_d (\\<A> f \\<beta> ve). Q b'\n 2. \\<And>x4.\n       f = P x4 \\<Longrightarrow>\n       \\<forall>b'\\<in>contours_in_d (\\<A> f \\<beta> ve). Q b'", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x31 x32.\n       f = C x31 x32 \\<Longrightarrow>\n       \\<forall>b'\\<in>contours_in_d (\\<A> f \\<beta> ve). Q b'\n 2. \\<And>x4.\n       f = P x4 \\<Longrightarrow>\n       \\<forall>b'\\<in>contours_in_d (\\<A> f \\<beta> ve). Q b'", "case C"], ["proof (state)\nthis:\n  f = C x31_ x32_\n\ngoal (2 subgoals):\n 1. \\<And>x31 x32.\n       f = C x31 x32 \\<Longrightarrow>\n       \\<forall>b'\\<in>contours_in_d (\\<A> f \\<beta> ve). Q b'\n 2. \\<And>x4.\n       f = P x4 \\<Longrightarrow>\n       \\<forall>b'\\<in>contours_in_d (\\<A> f \\<beta> ve). Q b'", "thus ?thesis"], ["proof (prove)\nusing this:\n  f = C x31_ x32_\n\ngoal (1 subgoal):\n 1. \\<forall>b'\\<in>contours_in_d (\\<A> f \\<beta> ve). Q b'", "by simp"], ["proof (state)\nthis:\n  \\<forall>b'\\<in>contours_in_d (\\<A> f \\<beta> ve). Q b'\n\ngoal (1 subgoal):\n 1. \\<And>x4.\n       f = P x4 \\<Longrightarrow>\n       \\<forall>b'\\<in>contours_in_d (\\<A> f \\<beta> ve). Q b'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x4.\n       f = P x4 \\<Longrightarrow>\n       \\<forall>b'\\<in>contours_in_d (\\<A> f \\<beta> ve). Q b'", "case P"], ["proof (state)\nthis:\n  f = P x4_\n\ngoal (1 subgoal):\n 1. \\<And>x4.\n       f = P x4 \\<Longrightarrow>\n       \\<forall>b'\\<in>contours_in_d (\\<A> f \\<beta> ve). Q b'", "thus ?thesis"], ["proof (prove)\nusing this:\n  f = P x4_\n\ngoal (1 subgoal):\n 1. \\<forall>b'\\<in>contours_in_d (\\<A> f \\<beta> ve). Q b'", "by simp"], ["proof (state)\nthis:\n  \\<forall>b'\\<in>contours_in_d (\\<A> f \\<beta> ve). Q b'\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>The proof\\<close>"], ["", "text \\<open>\nThe set returned by \\<open>\\<F>\\<close> and \\<open>\\<C>\\<close> is actually a partial map from callsite/binding environment pairs to called values. The corresponding predicate in Isabelle is \\<open>single_valued\\<close>.\n\nWe would like to show an auxiliary result about the contour counter passed to \\<open>\\<F>\\<close> and \\<open>\\<C>\\<close> (such that it is an unused counter when passed to \\<open>\\<F>\\<close> and others) first. Unfortunately, this is not possible with induction proofs over fixed points: While proving the inductive case, one does not show results for the function in question, but for an information-theoretical approximation. Thus, any previously shown results are not available.\nWe therefore intertwine the two inductions in one large proof.\n\nThis is a proof by fixpoint induction, so we have are obliged to show that the predicate is admissible and that it holds for the base case, i.e. the empty set. For the proof of admissibiliy, @{theory HOLCF} provides a number of introduction lemmas that, together with some additions in @{theory \"Shivers-CFA.HOLCFUtils\"} and the continuity lemmas, mechanically proove admissibiliy. The base case is trivial.\n\nThe remaining case is the preservation of the properties when applying the recursive equations to a function known to have have the desired property. Here, we break the proof into the various cases that occur in the definitions of \\<open>\\<F>\\<close> and \\<open>\\<C>\\<close> and use the induction hypothesises.\n\\<close>"], ["", "lemma cc_single_valued':\n      \"\\<lbrakk> \\<forall>b' \\<in> contours_in_ve ve. b' < b\n       ; \\<forall>b' \\<in> contours_in_d d. b' < b\n       ; \\<forall>d' \\<in> set ds. \\<forall>b' \\<in> contours_in_d d'. b' < b\n       \\<rbrakk>\n       \\<Longrightarrow>\n       (   single_valued (\\<F>\\<cdot>(Discr (d,ds,ve,b)))\n       \\<and> (\\<forall> ((lab,\\<beta>),t) \\<in> \\<F>\\<cdot>(Discr (d,ds,ve, b)). \\<exists> b'. b' \\<in> ran \\<beta> \\<and> b \\<le> b')\n       )\"\n  and \"\\<lbrakk> b \\<in> ran \\<beta>'\n       ; \\<forall>b'\\<in>ran \\<beta>'. b' \\<le> b\n       ; \\<forall>b' \\<in> contours_in_ve ve. b' \\<le> b\n       \\<rbrakk>\n       \\<Longrightarrow>\n       (   single_valued (\\<C>\\<cdot>(Discr (c,\\<beta>',ve,b)))\n       \\<and> (\\<forall> ((lab,\\<beta>),t) \\<in> \\<C>\\<cdot>(Discr (c,\\<beta>',ve,b)). \\<exists> b'. b' \\<in> ran \\<beta> \\<and> b \\<le> b')\n       )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n      \\<forall>b'\\<in>contours_in_d d. b' < b;\n      \\<forall>d'\\<in>set ds.\n         \\<forall>b'\\<in>contours_in_d d'. b' < b\\<rbrakk>\n     \\<Longrightarrow> single_valued\n                        (\\<F>\\<cdot>(Discr (d, ds, ve, b))) \\<and>\n                       (\\<forall>((lab, \\<beta>), t)\n                                 \\<in>\\<F>\\<cdot>(Discr (d, ds, ve, b)).\n                           \\<exists>b'.\n                              b' \\<in> ran \\<beta> \\<and> b \\<le> b')) &&&\n    (\\<lbrakk>b \\<in> ran \\<beta>';\n      \\<forall>b'\\<in>ran \\<beta>'. b' \\<le> b;\n      \\<forall>b'\\<in>contours_in_ve ve. b' \\<le> b\\<rbrakk>\n     \\<Longrightarrow> single_valued\n                        (\\<C>\\<cdot>(Discr (c, \\<beta>', ve, b))) \\<and>\n                       (\\<forall>((lab, \\<beta>), t)\n                                 \\<in>\\<C>\\<cdot>\n(Discr (c, \\<beta>', ve, b)).\n                           \\<exists>b'.\n                              b' \\<in> ran \\<beta> \\<and> b \\<le> b'))", "proof(induct arbitrary:d ds ve b c \\<beta>' rule:evalF_evalC_induct)"], ["proof (state)\ngoal (5 subgoals):\n 1. adm (\\<lambda>(evalF, evalC).\n            (\\<forall>x xa xb xc.\n                (\\<forall>b'\\<in>contours_in_ve xb.\n                    b' < xc) \\<longrightarrow>\n                (\\<forall>b'\\<in>contours_in_d x. b' < xc) \\<longrightarrow>\n                (\\<forall>d'\\<in>set xa.\n                    \\<forall>b'\\<in>contours_in_d d'.\n                       b' < xc) \\<longrightarrow>\n                single_valued (evalF\\<cdot>(Discr (x, xa, xb, xc))) \\<and>\n                (\\<forall>((lab, \\<beta>), t)\n                          \\<in>evalF\\<cdot>(Discr (x, xa, xb, xc)).\n                    \\<exists>b'.\n                       b' \\<in> ran \\<beta> \\<and> xc \\<le> b')) \\<and>\n            (\\<forall>x xa xb xc.\n                xa \\<in> ran xc \\<longrightarrow>\n                (\\<forall>b'\\<in>ran xc. b' \\<le> xa) \\<longrightarrow>\n                (\\<forall>b'\\<in>contours_in_ve x.\n                    b' \\<le> xa) \\<longrightarrow>\n                single_valued (evalC\\<cdot>(Discr (xb, xc, x, xa))) \\<and>\n                (\\<forall>((lab, \\<beta>), t)\n                          \\<in>evalC\\<cdot>(Discr (xb, xc, x, xa)).\n                    \\<exists>b'. b' \\<in> ran \\<beta> \\<and> xa \\<le> b')))\n 2. \\<And>d ds ve b.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        \\<forall>b'\\<in>contours_in_d d. b' < b;\n        \\<forall>d'\\<in>set ds.\n           \\<forall>b'\\<in>contours_in_d d'. b' < b\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (\\<bottom>\\<cdot>(Discr (d, ds, ve, b))) \\<and>\n                         (\\<forall>((lab, \\<beta>), t)\n                                   \\<in>\\<bottom>\\<cdot>\n  (Discr (d, ds, ve, b)).\n                             \\<exists>b'.\n                                b' \\<in> ran \\<beta> \\<and> b \\<le> b')\n 3. \\<And>ve b c \\<beta>'.\n       \\<lbrakk>b \\<in> ran \\<beta>';\n        \\<forall>b'\\<in>ran \\<beta>'. b' \\<le> b;\n        \\<forall>b'\\<in>contours_in_ve ve. b' \\<le> b\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (\\<bottom>\\<cdot>\n                           (Discr (c, \\<beta>', ve, b))) \\<and>\n                         (\\<forall>((lab, \\<beta>), t)\n                                   \\<in>\\<bottom>\\<cdot>\n  (Discr (c, \\<beta>', ve, b)).\n                             \\<exists>b'.\n                                b' \\<in> ran \\<beta> \\<and> b \\<le> b')\n 4. \\<And>a b d ds ve ba.\n       \\<lbrakk>\\<And>d ds ve b.\n                   \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n                    \\<forall>b'\\<in>contours_in_d d. b' < b;\n                    \\<forall>d'\\<in>set ds.\n                       \\<forall>b'\\<in>contours_in_d d'. b' < b\\<rbrakk>\n                   \\<Longrightarrow> single_valued\n(a\\<cdot>(Discr (d, ds, ve, b))) \\<and>\n                                     (\\<forall>((lab, \\<beta>), t)\n         \\<in>a\\<cdot>(Discr (d, ds, ve, b)).\n   \\<exists>b'. b' \\<in> ran \\<beta> \\<and> b \\<le> b');\n        \\<And>ve ba c \\<beta>'.\n           \\<lbrakk>ba \\<in> ran \\<beta>';\n            \\<forall>b'\\<in>ran \\<beta>'. b' \\<le> ba;\n            \\<forall>b'\\<in>contours_in_ve ve. b' \\<le> ba\\<rbrakk>\n           \\<Longrightarrow> single_valued\n                              (b\\<cdot>(Discr (c, \\<beta>', ve, ba))) \\<and>\n                             (\\<forall>((lab, \\<beta>), t)\n \\<in>b\\<cdot>(Discr (c, \\<beta>', ve, ba)).\n                                 \\<exists>b'.\n                                    b' \\<in> ran \\<beta> \\<and>\n                                    ba \\<le> b');\n        \\<forall>b'\\<in>contours_in_ve ve. b' < ba;\n        \\<forall>b'\\<in>contours_in_d d. b' < ba;\n        \\<forall>d'\\<in>set ds.\n           \\<forall>b'\\<in>contours_in_d d'. b' < ba\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          ((\\<Lambda> fstate.\n                               case undiscr fstate of\n                               (DI int, ba) \\<Rightarrow> \\<bottom>\n                               | (DC (Lambda lab vs c, \\<beta>), as, ve,\n                                  ba) \\<Rightarrow>\n                                   if length vs = length as\n                                   then let \\<beta>' = \\<beta>(lab \\<mapsto>\n        ba);\n      ve' = ve(map (\\<lambda>v. (v, ba)) vs [\\<mapsto>] as)\n  in b\\<cdot>(Discr (c, \\<beta>', ve', ba))\n                                   else \\<bottom>\n                               | (DP (Plus c), [], bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (Plus c), [DI a1], bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (Plus c), [DI a1, DI a2],\n                                  bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (Plus c), [DI a1, DI a2, cnt], ve,\n                                  b) \\<Rightarrow>\n                                   if isProc cnt\n                                   then let b' = nb b c;\n      \\<beta> = [c \\<mapsto> b]\n  in a\\<cdot>(Discr (cnt, [DI (a1 + a2)], ve, b')) \\<union>\n     {((c, \\<beta>), cnt)}\n                                   else \\<bottom>\n                               | (DP (Plus c),\n                                  DI a1 # DI a2 # cnt # aa # lista,\n                                  bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (Plus c), DI a1 # _ # lista,\n                                  bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (Plus c), _ # list, bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (prim.If ct cf), [], bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (prim.If ct cf), [DI v],\n                                  bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (prim.If ct cf), [DI v, contt],\n                                  bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (prim.If ct cf), [DI v, contt, contf],\n                                  ve, b) \\<Rightarrow>\n                                   if isProc contt \\<and> isProc contf\n                                   then if v \\<noteq> 0\n  then let b' = nb b ct; \\<beta> = [ct \\<mapsto> b]\n       in a\\<cdot>(Discr (contt, [], ve, b')) \\<union>\n          {((ct, \\<beta>), contt)}\n  else let b' = nb b cf; \\<beta> = [cf \\<mapsto> b]\n       in a\\<cdot>(Discr (contf, [], ve, b')) \\<union>\n          {((cf, \\<beta>), contf)}\n                                   else \\<bottom>\n                               | (DP (prim.If ct cf),\n                                  DI v # contt # contf # ab # lista,\n                                  bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (prim.If ct cf), _ # list,\n                                  bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (Stop, [], bb) \\<Rightarrow> \\<bottom>\n                               | (Stop, [DI i], x, xa) \\<Rightarrow> {}\n                               | (Stop, DI i # a # lista, bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (Stop, _ # list, bb) \\<Rightarrow>\n                                   \\<bottom>)\\<cdot>\n                           (Discr (d, ds, ve, ba))) \\<and>\n                         (\\<forall>((lab, \\<beta>), t)\n                                   \\<in>(\\<Lambda> fstate.\n      case undiscr fstate of (DI int, ba) \\<Rightarrow> \\<bottom>\n      | (DC (Lambda lab vs c, \\<beta>), as, ve, ba) \\<Rightarrow>\n          if length vs = length as\n          then let \\<beta>' = \\<beta>(lab \\<mapsto> ba);\n                   ve' = ve(map (\\<lambda>v. (v, ba)) vs [\\<mapsto>] as)\n               in b\\<cdot>(Discr (c, \\<beta>', ve', ba))\n          else \\<bottom>\n      | (DP (Plus c), [], bb) \\<Rightarrow> \\<bottom>\n      | (DP (Plus c), [DI a1], bb) \\<Rightarrow> \\<bottom>\n      | (DP (Plus c), [DI a1, DI a2], bb) \\<Rightarrow> \\<bottom>\n      | (DP (Plus c), [DI a1, DI a2, cnt], ve, b) \\<Rightarrow>\n          if isProc cnt\n          then let b' = nb b c; \\<beta> = [c \\<mapsto> b]\n               in a\\<cdot>(Discr (cnt, [DI (a1 + a2)], ve, b')) \\<union>\n                  {((c, \\<beta>), cnt)}\n          else \\<bottom>\n      | (DP (Plus c), DI a1 # DI a2 # cnt # aa # lista, bb) \\<Rightarrow>\n          \\<bottom>\n      | (DP (Plus c), DI a1 # _ # lista, bb) \\<Rightarrow> \\<bottom>\n      | (DP (Plus c), _ # list, bb) \\<Rightarrow> \\<bottom>\n      | (DP (prim.If ct cf), [], bb) \\<Rightarrow> \\<bottom>\n      | (DP (prim.If ct cf), [DI v], bb) \\<Rightarrow> \\<bottom>\n      | (DP (prim.If ct cf), [DI v, contt], bb) \\<Rightarrow> \\<bottom>\n      | (DP (prim.If ct cf), [DI v, contt, contf], ve, b) \\<Rightarrow>\n          if isProc contt \\<and> isProc contf\n          then if v \\<noteq> 0\n               then let b' = nb b ct; \\<beta> = [ct \\<mapsto> b]\n                    in a\\<cdot>(Discr (contt, [], ve, b')) \\<union>\n                       {((ct, \\<beta>), contt)}\n               else let b' = nb b cf; \\<beta> = [cf \\<mapsto> b]\n                    in a\\<cdot>(Discr (contf, [], ve, b')) \\<union>\n                       {((cf, \\<beta>), contf)}\n          else \\<bottom>\n      | (DP (prim.If ct cf), DI v # contt # contf # ab # lista,\n         bb) \\<Rightarrow>\n          \\<bottom>\n      | (DP (prim.If ct cf), _ # list, bb) \\<Rightarrow> \\<bottom>\n      | (Stop, [], bb) \\<Rightarrow> \\<bottom>\n      | (Stop, [DI i], x, xa) \\<Rightarrow> {}\n      | (Stop, DI i # a # lista, bb) \\<Rightarrow> \\<bottom>\n      | (Stop, _ # list, bb) \\<Rightarrow> \\<bottom>)\\<cdot>\n  (Discr (d, ds, ve, ba)).\n                             \\<exists>b'.\n                                b' \\<in> ran \\<beta> \\<and> ba \\<le> b')\n 5. \\<And>a b ve ba c \\<beta>'.\n       \\<lbrakk>\\<And>d ds ve b.\n                   \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n                    \\<forall>b'\\<in>contours_in_d d. b' < b;\n                    \\<forall>d'\\<in>set ds.\n                       \\<forall>b'\\<in>contours_in_d d'. b' < b\\<rbrakk>\n                   \\<Longrightarrow> single_valued\n(a\\<cdot>(Discr (d, ds, ve, b))) \\<and>\n                                     (\\<forall>((lab, \\<beta>), t)\n         \\<in>a\\<cdot>(Discr (d, ds, ve, b)).\n   \\<exists>b'. b' \\<in> ran \\<beta> \\<and> b \\<le> b');\n        \\<And>ve ba c \\<beta>'.\n           \\<lbrakk>ba \\<in> ran \\<beta>';\n            \\<forall>b'\\<in>ran \\<beta>'. b' \\<le> ba;\n            \\<forall>b'\\<in>contours_in_ve ve. b' \\<le> ba\\<rbrakk>\n           \\<Longrightarrow> single_valued\n                              (b\\<cdot>(Discr (c, \\<beta>', ve, ba))) \\<and>\n                             (\\<forall>((lab, \\<beta>), t)\n \\<in>b\\<cdot>(Discr (c, \\<beta>', ve, ba)).\n                                 \\<exists>b'.\n                                    b' \\<in> ran \\<beta> \\<and>\n                                    ba \\<le> b');\n        ba \\<in> ran \\<beta>'; \\<forall>b'\\<in>ran \\<beta>'. b' \\<le> ba;\n        \\<forall>b'\\<in>contours_in_ve ve. b' \\<le> ba\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          ((\\<Lambda> cstate.\n                               case undiscr cstate of\n                               (App lab f vs, \\<beta>, ve, b) \\<Rightarrow>\n                                 let f' = \\<A> f \\<beta> ve;\n                                     as =\n map (\\<lambda>v. \\<A> v \\<beta> ve) vs;\n                                     b' = nb b lab\n                                 in if isProc f'\n                                    then a\\<cdot>\n   (Discr (f', as, ve, b')) \\<union>\n   {((lab, \\<beta>), f')}\n                                    else \\<bottom>\n                               | (call.Let lab ls c', \\<beta>, ve,\n                                  ba) \\<Rightarrow>\n                                   let b' = nb ba lab;\n \\<beta>' = \\<beta>(lab \\<mapsto> b');\n ve' =\n   ve ++\n   map_of (map (\\<lambda>(v, l). ((v, b'), \\<A> (L l) \\<beta>' ve)) ls)\n                                   in b\\<cdot>\n(Discr (c', \\<beta>', ve', b')))\\<cdot>\n                           (Discr (c, \\<beta>', ve, ba))) \\<and>\n                         (\\<forall>((lab, \\<beta>), t)\n                                   \\<in>(\\<Lambda> cstate.\n      case undiscr cstate of\n      (App lab f vs, \\<beta>, ve, b) \\<Rightarrow>\n        let f' = \\<A> f \\<beta> ve;\n            as = map (\\<lambda>v. \\<A> v \\<beta> ve) vs; b' = nb b lab\n        in if isProc f'\n           then a\\<cdot>(Discr (f', as, ve, b')) \\<union>\n                {((lab, \\<beta>), f')}\n           else \\<bottom>\n      | (call.Let lab ls c', \\<beta>, ve, ba) \\<Rightarrow>\n          let b' = nb ba lab; \\<beta>' = \\<beta>(lab \\<mapsto> b');\n              ve' =\n                ve ++\n                map_of\n                 (map (\\<lambda>(v, l). ((v, b'), \\<A> (L l) \\<beta>' ve))\n                   ls)\n          in b\\<cdot>(Discr (c', \\<beta>', ve', b')))\\<cdot>\n  (Discr (c, \\<beta>', ve, ba)).\n                             \\<exists>b'.\n                                b' \\<in> ran \\<beta> \\<and> ba \\<le> b')", "case Admissibility"], ["proof (state)\nthis:\n  \n\ngoal (5 subgoals):\n 1. adm (\\<lambda>(evalF, evalC).\n            (\\<forall>x xa xb xc.\n                (\\<forall>b'\\<in>contours_in_ve xb.\n                    b' < xc) \\<longrightarrow>\n                (\\<forall>b'\\<in>contours_in_d x. b' < xc) \\<longrightarrow>\n                (\\<forall>d'\\<in>set xa.\n                    \\<forall>b'\\<in>contours_in_d d'.\n                       b' < xc) \\<longrightarrow>\n                single_valued (evalF\\<cdot>(Discr (x, xa, xb, xc))) \\<and>\n                (\\<forall>((lab, \\<beta>), t)\n                          \\<in>evalF\\<cdot>(Discr (x, xa, xb, xc)).\n                    \\<exists>b'.\n                       b' \\<in> ran \\<beta> \\<and> xc \\<le> b')) \\<and>\n            (\\<forall>x xa xb xc.\n                xa \\<in> ran xc \\<longrightarrow>\n                (\\<forall>b'\\<in>ran xc. b' \\<le> xa) \\<longrightarrow>\n                (\\<forall>b'\\<in>contours_in_ve x.\n                    b' \\<le> xa) \\<longrightarrow>\n                single_valued (evalC\\<cdot>(Discr (xb, xc, x, xa))) \\<and>\n                (\\<forall>((lab, \\<beta>), t)\n                          \\<in>evalC\\<cdot>(Discr (xb, xc, x, xa)).\n                    \\<exists>b'. b' \\<in> ran \\<beta> \\<and> xa \\<le> b')))\n 2. \\<And>d ds ve b.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        \\<forall>b'\\<in>contours_in_d d. b' < b;\n        \\<forall>d'\\<in>set ds.\n           \\<forall>b'\\<in>contours_in_d d'. b' < b\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (\\<bottom>\\<cdot>(Discr (d, ds, ve, b))) \\<and>\n                         (\\<forall>((lab, \\<beta>), t)\n                                   \\<in>\\<bottom>\\<cdot>\n  (Discr (d, ds, ve, b)).\n                             \\<exists>b'.\n                                b' \\<in> ran \\<beta> \\<and> b \\<le> b')\n 3. \\<And>ve b c \\<beta>'.\n       \\<lbrakk>b \\<in> ran \\<beta>';\n        \\<forall>b'\\<in>ran \\<beta>'. b' \\<le> b;\n        \\<forall>b'\\<in>contours_in_ve ve. b' \\<le> b\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (\\<bottom>\\<cdot>\n                           (Discr (c, \\<beta>', ve, b))) \\<and>\n                         (\\<forall>((lab, \\<beta>), t)\n                                   \\<in>\\<bottom>\\<cdot>\n  (Discr (c, \\<beta>', ve, b)).\n                             \\<exists>b'.\n                                b' \\<in> ran \\<beta> \\<and> b \\<le> b')\n 4. \\<And>a b d ds ve ba.\n       \\<lbrakk>\\<And>d ds ve b.\n                   \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n                    \\<forall>b'\\<in>contours_in_d d. b' < b;\n                    \\<forall>d'\\<in>set ds.\n                       \\<forall>b'\\<in>contours_in_d d'. b' < b\\<rbrakk>\n                   \\<Longrightarrow> single_valued\n(a\\<cdot>(Discr (d, ds, ve, b))) \\<and>\n                                     (\\<forall>((lab, \\<beta>), t)\n         \\<in>a\\<cdot>(Discr (d, ds, ve, b)).\n   \\<exists>b'. b' \\<in> ran \\<beta> \\<and> b \\<le> b');\n        \\<And>ve ba c \\<beta>'.\n           \\<lbrakk>ba \\<in> ran \\<beta>';\n            \\<forall>b'\\<in>ran \\<beta>'. b' \\<le> ba;\n            \\<forall>b'\\<in>contours_in_ve ve. b' \\<le> ba\\<rbrakk>\n           \\<Longrightarrow> single_valued\n                              (b\\<cdot>(Discr (c, \\<beta>', ve, ba))) \\<and>\n                             (\\<forall>((lab, \\<beta>), t)\n \\<in>b\\<cdot>(Discr (c, \\<beta>', ve, ba)).\n                                 \\<exists>b'.\n                                    b' \\<in> ran \\<beta> \\<and>\n                                    ba \\<le> b');\n        \\<forall>b'\\<in>contours_in_ve ve. b' < ba;\n        \\<forall>b'\\<in>contours_in_d d. b' < ba;\n        \\<forall>d'\\<in>set ds.\n           \\<forall>b'\\<in>contours_in_d d'. b' < ba\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          ((\\<Lambda> fstate.\n                               case undiscr fstate of\n                               (DI int, ba) \\<Rightarrow> \\<bottom>\n                               | (DC (Lambda lab vs c, \\<beta>), as, ve,\n                                  ba) \\<Rightarrow>\n                                   if length vs = length as\n                                   then let \\<beta>' = \\<beta>(lab \\<mapsto>\n        ba);\n      ve' = ve(map (\\<lambda>v. (v, ba)) vs [\\<mapsto>] as)\n  in b\\<cdot>(Discr (c, \\<beta>', ve', ba))\n                                   else \\<bottom>\n                               | (DP (Plus c), [], bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (Plus c), [DI a1], bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (Plus c), [DI a1, DI a2],\n                                  bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (Plus c), [DI a1, DI a2, cnt], ve,\n                                  b) \\<Rightarrow>\n                                   if isProc cnt\n                                   then let b' = nb b c;\n      \\<beta> = [c \\<mapsto> b]\n  in a\\<cdot>(Discr (cnt, [DI (a1 + a2)], ve, b')) \\<union>\n     {((c, \\<beta>), cnt)}\n                                   else \\<bottom>\n                               | (DP (Plus c),\n                                  DI a1 # DI a2 # cnt # aa # lista,\n                                  bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (Plus c), DI a1 # _ # lista,\n                                  bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (Plus c), _ # list, bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (prim.If ct cf), [], bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (prim.If ct cf), [DI v],\n                                  bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (prim.If ct cf), [DI v, contt],\n                                  bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (prim.If ct cf), [DI v, contt, contf],\n                                  ve, b) \\<Rightarrow>\n                                   if isProc contt \\<and> isProc contf\n                                   then if v \\<noteq> 0\n  then let b' = nb b ct; \\<beta> = [ct \\<mapsto> b]\n       in a\\<cdot>(Discr (contt, [], ve, b')) \\<union>\n          {((ct, \\<beta>), contt)}\n  else let b' = nb b cf; \\<beta> = [cf \\<mapsto> b]\n       in a\\<cdot>(Discr (contf, [], ve, b')) \\<union>\n          {((cf, \\<beta>), contf)}\n                                   else \\<bottom>\n                               | (DP (prim.If ct cf),\n                                  DI v # contt # contf # ab # lista,\n                                  bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (prim.If ct cf), _ # list,\n                                  bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (Stop, [], bb) \\<Rightarrow> \\<bottom>\n                               | (Stop, [DI i], x, xa) \\<Rightarrow> {}\n                               | (Stop, DI i # a # lista, bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (Stop, _ # list, bb) \\<Rightarrow>\n                                   \\<bottom>)\\<cdot>\n                           (Discr (d, ds, ve, ba))) \\<and>\n                         (\\<forall>((lab, \\<beta>), t)\n                                   \\<in>(\\<Lambda> fstate.\n      case undiscr fstate of (DI int, ba) \\<Rightarrow> \\<bottom>\n      | (DC (Lambda lab vs c, \\<beta>), as, ve, ba) \\<Rightarrow>\n          if length vs = length as\n          then let \\<beta>' = \\<beta>(lab \\<mapsto> ba);\n                   ve' = ve(map (\\<lambda>v. (v, ba)) vs [\\<mapsto>] as)\n               in b\\<cdot>(Discr (c, \\<beta>', ve', ba))\n          else \\<bottom>\n      | (DP (Plus c), [], bb) \\<Rightarrow> \\<bottom>\n      | (DP (Plus c), [DI a1], bb) \\<Rightarrow> \\<bottom>\n      | (DP (Plus c), [DI a1, DI a2], bb) \\<Rightarrow> \\<bottom>\n      | (DP (Plus c), [DI a1, DI a2, cnt], ve, b) \\<Rightarrow>\n          if isProc cnt\n          then let b' = nb b c; \\<beta> = [c \\<mapsto> b]\n               in a\\<cdot>(Discr (cnt, [DI (a1 + a2)], ve, b')) \\<union>\n                  {((c, \\<beta>), cnt)}\n          else \\<bottom>\n      | (DP (Plus c), DI a1 # DI a2 # cnt # aa # lista, bb) \\<Rightarrow>\n          \\<bottom>\n      | (DP (Plus c), DI a1 # _ # lista, bb) \\<Rightarrow> \\<bottom>\n      | (DP (Plus c), _ # list, bb) \\<Rightarrow> \\<bottom>\n      | (DP (prim.If ct cf), [], bb) \\<Rightarrow> \\<bottom>\n      | (DP (prim.If ct cf), [DI v], bb) \\<Rightarrow> \\<bottom>\n      | (DP (prim.If ct cf), [DI v, contt], bb) \\<Rightarrow> \\<bottom>\n      | (DP (prim.If ct cf), [DI v, contt, contf], ve, b) \\<Rightarrow>\n          if isProc contt \\<and> isProc contf\n          then if v \\<noteq> 0\n               then let b' = nb b ct; \\<beta> = [ct \\<mapsto> b]\n                    in a\\<cdot>(Discr (contt, [], ve, b')) \\<union>\n                       {((ct, \\<beta>), contt)}\n               else let b' = nb b cf; \\<beta> = [cf \\<mapsto> b]\n                    in a\\<cdot>(Discr (contf, [], ve, b')) \\<union>\n                       {((cf, \\<beta>), contf)}\n          else \\<bottom>\n      | (DP (prim.If ct cf), DI v # contt # contf # ab # lista,\n         bb) \\<Rightarrow>\n          \\<bottom>\n      | (DP (prim.If ct cf), _ # list, bb) \\<Rightarrow> \\<bottom>\n      | (Stop, [], bb) \\<Rightarrow> \\<bottom>\n      | (Stop, [DI i], x, xa) \\<Rightarrow> {}\n      | (Stop, DI i # a # lista, bb) \\<Rightarrow> \\<bottom>\n      | (Stop, _ # list, bb) \\<Rightarrow> \\<bottom>)\\<cdot>\n  (Discr (d, ds, ve, ba)).\n                             \\<exists>b'.\n                                b' \\<in> ran \\<beta> \\<and> ba \\<le> b')\n 5. \\<And>a b ve ba c \\<beta>'.\n       \\<lbrakk>\\<And>d ds ve b.\n                   \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n                    \\<forall>b'\\<in>contours_in_d d. b' < b;\n                    \\<forall>d'\\<in>set ds.\n                       \\<forall>b'\\<in>contours_in_d d'. b' < b\\<rbrakk>\n                   \\<Longrightarrow> single_valued\n(a\\<cdot>(Discr (d, ds, ve, b))) \\<and>\n                                     (\\<forall>((lab, \\<beta>), t)\n         \\<in>a\\<cdot>(Discr (d, ds, ve, b)).\n   \\<exists>b'. b' \\<in> ran \\<beta> \\<and> b \\<le> b');\n        \\<And>ve ba c \\<beta>'.\n           \\<lbrakk>ba \\<in> ran \\<beta>';\n            \\<forall>b'\\<in>ran \\<beta>'. b' \\<le> ba;\n            \\<forall>b'\\<in>contours_in_ve ve. b' \\<le> ba\\<rbrakk>\n           \\<Longrightarrow> single_valued\n                              (b\\<cdot>(Discr (c, \\<beta>', ve, ba))) \\<and>\n                             (\\<forall>((lab, \\<beta>), t)\n \\<in>b\\<cdot>(Discr (c, \\<beta>', ve, ba)).\n                                 \\<exists>b'.\n                                    b' \\<in> ran \\<beta> \\<and>\n                                    ba \\<le> b');\n        ba \\<in> ran \\<beta>'; \\<forall>b'\\<in>ran \\<beta>'. b' \\<le> ba;\n        \\<forall>b'\\<in>contours_in_ve ve. b' \\<le> ba\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          ((\\<Lambda> cstate.\n                               case undiscr cstate of\n                               (App lab f vs, \\<beta>, ve, b) \\<Rightarrow>\n                                 let f' = \\<A> f \\<beta> ve;\n                                     as =\n map (\\<lambda>v. \\<A> v \\<beta> ve) vs;\n                                     b' = nb b lab\n                                 in if isProc f'\n                                    then a\\<cdot>\n   (Discr (f', as, ve, b')) \\<union>\n   {((lab, \\<beta>), f')}\n                                    else \\<bottom>\n                               | (call.Let lab ls c', \\<beta>, ve,\n                                  ba) \\<Rightarrow>\n                                   let b' = nb ba lab;\n \\<beta>' = \\<beta>(lab \\<mapsto> b');\n ve' =\n   ve ++\n   map_of (map (\\<lambda>(v, l). ((v, b'), \\<A> (L l) \\<beta>' ve)) ls)\n                                   in b\\<cdot>\n(Discr (c', \\<beta>', ve', b')))\\<cdot>\n                           (Discr (c, \\<beta>', ve, ba))) \\<and>\n                         (\\<forall>((lab, \\<beta>), t)\n                                   \\<in>(\\<Lambda> cstate.\n      case undiscr cstate of\n      (App lab f vs, \\<beta>, ve, b) \\<Rightarrow>\n        let f' = \\<A> f \\<beta> ve;\n            as = map (\\<lambda>v. \\<A> v \\<beta> ve) vs; b' = nb b lab\n        in if isProc f'\n           then a\\<cdot>(Discr (f', as, ve, b')) \\<union>\n                {((lab, \\<beta>), f')}\n           else \\<bottom>\n      | (call.Let lab ls c', \\<beta>, ve, ba) \\<Rightarrow>\n          let b' = nb ba lab; \\<beta>' = \\<beta>(lab \\<mapsto> b');\n              ve' =\n                ve ++\n                map_of\n                 (map (\\<lambda>(v, l). ((v, b'), \\<A> (L l) \\<beta>' ve))\n                   ls)\n          in b\\<cdot>(Discr (c', \\<beta>', ve', b')))\\<cdot>\n  (Discr (c, \\<beta>', ve, ba)).\n                             \\<exists>b'.\n                                b' \\<in> ran \\<beta> \\<and> ba \\<le> b')", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. adm (\\<lambda>(evalF, evalC).\n            (\\<forall>x xa xaa xaaa.\n                (\\<forall>b'\\<in>contours_in_ve xaa.\n                    b' < xaaa) \\<longrightarrow>\n                (\\<forall>b'\\<in>contours_in_d x.\n                    b' < xaaa) \\<longrightarrow>\n                (\\<forall>d'\\<in>set xa.\n                    \\<forall>b'\\<in>contours_in_d d'.\n                       b' < xaaa) \\<longrightarrow>\n                single_valued\n                 (evalF\\<cdot>(Discr (x, xa, xaa, xaaa))) \\<and>\n                (\\<forall>a\\<in>evalF\\<cdot>(Discr (x, xa, xaa, xaaa)).\n                    case a of\n                    (a, b) \\<Rightarrow>\n                      (case a of\n                       (lab, \\<beta>) \\<Rightarrow>\n                         \\<lambda>t.\n                            \\<exists>b'.\n                               b' \\<in> ran \\<beta> \\<and> xaaa \\<le> b')\n                       b)) \\<and>\n            (\\<forall>x xa xaa xaaa.\n                xa \\<in> ran xaaa \\<longrightarrow>\n                (\\<forall>b'\\<in>ran xaaa. b' \\<le> xa) \\<longrightarrow>\n                (\\<forall>b'\\<in>contours_in_ve x.\n                    b' \\<le> xa) \\<longrightarrow>\n                single_valued\n                 (evalC\\<cdot>(Discr (xaa, xaaa, x, xa))) \\<and>\n                (\\<forall>a\\<in>evalC\\<cdot>(Discr (xaa, xaaa, x, xa)).\n                    case a of\n                    (a, b) \\<Rightarrow>\n                      (case a of\n                       (lab, \\<beta>) \\<Rightarrow>\n                         \\<lambda>t.\n                            \\<exists>b'.\n                               b' \\<in> ran \\<beta> \\<and> xa \\<le> b')\n                       b)))", "by (intro adm_lemmas adm_ball' adm_prod_split adm_not_conj adm_not_mem adm_single_valued cont2cont)"], ["proof (state)\nthis:\n  adm (\\<lambda>(evalF, evalC).\n          (\\<forall>x xa xaa xaaa.\n              (\\<forall>b'\\<in>contours_in_ve xaa.\n                  b' < xaaa) \\<longrightarrow>\n              (\\<forall>b'\\<in>contours_in_d x. b' < xaaa) \\<longrightarrow>\n              (\\<forall>d'\\<in>set xa.\n                  \\<forall>b'\\<in>contours_in_d d'.\n                     b' < xaaa) \\<longrightarrow>\n              single_valued (evalF\\<cdot>(Discr (x, xa, xaa, xaaa))) \\<and>\n              (\\<forall>a\\<in>evalF\\<cdot>(Discr (x, xa, xaa, xaaa)).\n                  case a of\n                  (a, b) \\<Rightarrow>\n                    (case a of\n                     (lab, \\<beta>) \\<Rightarrow>\n                       \\<lambda>t.\n                          \\<exists>b'.\n                             b' \\<in> ran \\<beta> \\<and> xaaa \\<le> b')\n                     b)) \\<and>\n          (\\<forall>x xa xaa xaaa.\n              xa \\<in> ran xaaa \\<longrightarrow>\n              (\\<forall>b'\\<in>ran xaaa. b' \\<le> xa) \\<longrightarrow>\n              (\\<forall>b'\\<in>contours_in_ve x.\n                  b' \\<le> xa) \\<longrightarrow>\n              single_valued (evalC\\<cdot>(Discr (xaa, xaaa, x, xa))) \\<and>\n              (\\<forall>a\\<in>evalC\\<cdot>(Discr (xaa, xaaa, x, xa)).\n                  case a of\n                  (a, b) \\<Rightarrow>\n                    (case a of\n                     (lab, \\<beta>) \\<Rightarrow>\n                       \\<lambda>t.\n                          \\<exists>b'.\n                             b' \\<in> ran \\<beta> \\<and> xa \\<le> b')\n                     b)))\n\ngoal (4 subgoals):\n 1. \\<And>d ds ve b.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        \\<forall>b'\\<in>contours_in_d d. b' < b;\n        \\<forall>d'\\<in>set ds.\n           \\<forall>b'\\<in>contours_in_d d'. b' < b\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (\\<bottom>\\<cdot>(Discr (d, ds, ve, b))) \\<and>\n                         (\\<forall>((lab, \\<beta>), t)\n                                   \\<in>\\<bottom>\\<cdot>\n  (Discr (d, ds, ve, b)).\n                             \\<exists>b'.\n                                b' \\<in> ran \\<beta> \\<and> b \\<le> b')\n 2. \\<And>ve b c \\<beta>'.\n       \\<lbrakk>b \\<in> ran \\<beta>';\n        \\<forall>b'\\<in>ran \\<beta>'. b' \\<le> b;\n        \\<forall>b'\\<in>contours_in_ve ve. b' \\<le> b\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (\\<bottom>\\<cdot>\n                           (Discr (c, \\<beta>', ve, b))) \\<and>\n                         (\\<forall>((lab, \\<beta>), t)\n                                   \\<in>\\<bottom>\\<cdot>\n  (Discr (c, \\<beta>', ve, b)).\n                             \\<exists>b'.\n                                b' \\<in> ran \\<beta> \\<and> b \\<le> b')\n 3. \\<And>a b d ds ve ba.\n       \\<lbrakk>\\<And>d ds ve b.\n                   \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n                    \\<forall>b'\\<in>contours_in_d d. b' < b;\n                    \\<forall>d'\\<in>set ds.\n                       \\<forall>b'\\<in>contours_in_d d'. b' < b\\<rbrakk>\n                   \\<Longrightarrow> single_valued\n(a\\<cdot>(Discr (d, ds, ve, b))) \\<and>\n                                     (\\<forall>((lab, \\<beta>), t)\n         \\<in>a\\<cdot>(Discr (d, ds, ve, b)).\n   \\<exists>b'. b' \\<in> ran \\<beta> \\<and> b \\<le> b');\n        \\<And>ve ba c \\<beta>'.\n           \\<lbrakk>ba \\<in> ran \\<beta>';\n            \\<forall>b'\\<in>ran \\<beta>'. b' \\<le> ba;\n            \\<forall>b'\\<in>contours_in_ve ve. b' \\<le> ba\\<rbrakk>\n           \\<Longrightarrow> single_valued\n                              (b\\<cdot>(Discr (c, \\<beta>', ve, ba))) \\<and>\n                             (\\<forall>((lab, \\<beta>), t)\n \\<in>b\\<cdot>(Discr (c, \\<beta>', ve, ba)).\n                                 \\<exists>b'.\n                                    b' \\<in> ran \\<beta> \\<and>\n                                    ba \\<le> b');\n        \\<forall>b'\\<in>contours_in_ve ve. b' < ba;\n        \\<forall>b'\\<in>contours_in_d d. b' < ba;\n        \\<forall>d'\\<in>set ds.\n           \\<forall>b'\\<in>contours_in_d d'. b' < ba\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          ((\\<Lambda> fstate.\n                               case undiscr fstate of\n                               (DI int, ba) \\<Rightarrow> \\<bottom>\n                               | (DC (Lambda lab vs c, \\<beta>), as, ve,\n                                  ba) \\<Rightarrow>\n                                   if length vs = length as\n                                   then let \\<beta>' = \\<beta>(lab \\<mapsto>\n        ba);\n      ve' = ve(map (\\<lambda>v. (v, ba)) vs [\\<mapsto>] as)\n  in b\\<cdot>(Discr (c, \\<beta>', ve', ba))\n                                   else \\<bottom>\n                               | (DP (Plus c), [], bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (Plus c), [DI a1], bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (Plus c), [DI a1, DI a2],\n                                  bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (Plus c), [DI a1, DI a2, cnt], ve,\n                                  b) \\<Rightarrow>\n                                   if isProc cnt\n                                   then let b' = nb b c;\n      \\<beta> = [c \\<mapsto> b]\n  in a\\<cdot>(Discr (cnt, [DI (a1 + a2)], ve, b')) \\<union>\n     {((c, \\<beta>), cnt)}\n                                   else \\<bottom>\n                               | (DP (Plus c),\n                                  DI a1 # DI a2 # cnt # aa # lista,\n                                  bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (Plus c), DI a1 # _ # lista,\n                                  bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (Plus c), _ # list, bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (prim.If ct cf), [], bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (prim.If ct cf), [DI v],\n                                  bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (prim.If ct cf), [DI v, contt],\n                                  bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (prim.If ct cf), [DI v, contt, contf],\n                                  ve, b) \\<Rightarrow>\n                                   if isProc contt \\<and> isProc contf\n                                   then if v \\<noteq> 0\n  then let b' = nb b ct; \\<beta> = [ct \\<mapsto> b]\n       in a\\<cdot>(Discr (contt, [], ve, b')) \\<union>\n          {((ct, \\<beta>), contt)}\n  else let b' = nb b cf; \\<beta> = [cf \\<mapsto> b]\n       in a\\<cdot>(Discr (contf, [], ve, b')) \\<union>\n          {((cf, \\<beta>), contf)}\n                                   else \\<bottom>\n                               | (DP (prim.If ct cf),\n                                  DI v # contt # contf # ab # lista,\n                                  bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (prim.If ct cf), _ # list,\n                                  bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (Stop, [], bb) \\<Rightarrow> \\<bottom>\n                               | (Stop, [DI i], x, xa) \\<Rightarrow> {}\n                               | (Stop, DI i # a # lista, bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (Stop, _ # list, bb) \\<Rightarrow>\n                                   \\<bottom>)\\<cdot>\n                           (Discr (d, ds, ve, ba))) \\<and>\n                         (\\<forall>((lab, \\<beta>), t)\n                                   \\<in>(\\<Lambda> fstate.\n      case undiscr fstate of (DI int, ba) \\<Rightarrow> \\<bottom>\n      | (DC (Lambda lab vs c, \\<beta>), as, ve, ba) \\<Rightarrow>\n          if length vs = length as\n          then let \\<beta>' = \\<beta>(lab \\<mapsto> ba);\n                   ve' = ve(map (\\<lambda>v. (v, ba)) vs [\\<mapsto>] as)\n               in b\\<cdot>(Discr (c, \\<beta>', ve', ba))\n          else \\<bottom>\n      | (DP (Plus c), [], bb) \\<Rightarrow> \\<bottom>\n      | (DP (Plus c), [DI a1], bb) \\<Rightarrow> \\<bottom>\n      | (DP (Plus c), [DI a1, DI a2], bb) \\<Rightarrow> \\<bottom>\n      | (DP (Plus c), [DI a1, DI a2, cnt], ve, b) \\<Rightarrow>\n          if isProc cnt\n          then let b' = nb b c; \\<beta> = [c \\<mapsto> b]\n               in a\\<cdot>(Discr (cnt, [DI (a1 + a2)], ve, b')) \\<union>\n                  {((c, \\<beta>), cnt)}\n          else \\<bottom>\n      | (DP (Plus c), DI a1 # DI a2 # cnt # aa # lista, bb) \\<Rightarrow>\n          \\<bottom>\n      | (DP (Plus c), DI a1 # _ # lista, bb) \\<Rightarrow> \\<bottom>\n      | (DP (Plus c), _ # list, bb) \\<Rightarrow> \\<bottom>\n      | (DP (prim.If ct cf), [], bb) \\<Rightarrow> \\<bottom>\n      | (DP (prim.If ct cf), [DI v], bb) \\<Rightarrow> \\<bottom>\n      | (DP (prim.If ct cf), [DI v, contt], bb) \\<Rightarrow> \\<bottom>\n      | (DP (prim.If ct cf), [DI v, contt, contf], ve, b) \\<Rightarrow>\n          if isProc contt \\<and> isProc contf\n          then if v \\<noteq> 0\n               then let b' = nb b ct; \\<beta> = [ct \\<mapsto> b]\n                    in a\\<cdot>(Discr (contt, [], ve, b')) \\<union>\n                       {((ct, \\<beta>), contt)}\n               else let b' = nb b cf; \\<beta> = [cf \\<mapsto> b]\n                    in a\\<cdot>(Discr (contf, [], ve, b')) \\<union>\n                       {((cf, \\<beta>), contf)}\n          else \\<bottom>\n      | (DP (prim.If ct cf), DI v # contt # contf # ab # lista,\n         bb) \\<Rightarrow>\n          \\<bottom>\n      | (DP (prim.If ct cf), _ # list, bb) \\<Rightarrow> \\<bottom>\n      | (Stop, [], bb) \\<Rightarrow> \\<bottom>\n      | (Stop, [DI i], x, xa) \\<Rightarrow> {}\n      | (Stop, DI i # a # lista, bb) \\<Rightarrow> \\<bottom>\n      | (Stop, _ # list, bb) \\<Rightarrow> \\<bottom>)\\<cdot>\n  (Discr (d, ds, ve, ba)).\n                             \\<exists>b'.\n                                b' \\<in> ran \\<beta> \\<and> ba \\<le> b')\n 4. \\<And>a b ve ba c \\<beta>'.\n       \\<lbrakk>\\<And>d ds ve b.\n                   \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n                    \\<forall>b'\\<in>contours_in_d d. b' < b;\n                    \\<forall>d'\\<in>set ds.\n                       \\<forall>b'\\<in>contours_in_d d'. b' < b\\<rbrakk>\n                   \\<Longrightarrow> single_valued\n(a\\<cdot>(Discr (d, ds, ve, b))) \\<and>\n                                     (\\<forall>((lab, \\<beta>), t)\n         \\<in>a\\<cdot>(Discr (d, ds, ve, b)).\n   \\<exists>b'. b' \\<in> ran \\<beta> \\<and> b \\<le> b');\n        \\<And>ve ba c \\<beta>'.\n           \\<lbrakk>ba \\<in> ran \\<beta>';\n            \\<forall>b'\\<in>ran \\<beta>'. b' \\<le> ba;\n            \\<forall>b'\\<in>contours_in_ve ve. b' \\<le> ba\\<rbrakk>\n           \\<Longrightarrow> single_valued\n                              (b\\<cdot>(Discr (c, \\<beta>', ve, ba))) \\<and>\n                             (\\<forall>((lab, \\<beta>), t)\n \\<in>b\\<cdot>(Discr (c, \\<beta>', ve, ba)).\n                                 \\<exists>b'.\n                                    b' \\<in> ran \\<beta> \\<and>\n                                    ba \\<le> b');\n        ba \\<in> ran \\<beta>'; \\<forall>b'\\<in>ran \\<beta>'. b' \\<le> ba;\n        \\<forall>b'\\<in>contours_in_ve ve. b' \\<le> ba\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          ((\\<Lambda> cstate.\n                               case undiscr cstate of\n                               (App lab f vs, \\<beta>, ve, b) \\<Rightarrow>\n                                 let f' = \\<A> f \\<beta> ve;\n                                     as =\n map (\\<lambda>v. \\<A> v \\<beta> ve) vs;\n                                     b' = nb b lab\n                                 in if isProc f'\n                                    then a\\<cdot>\n   (Discr (f', as, ve, b')) \\<union>\n   {((lab, \\<beta>), f')}\n                                    else \\<bottom>\n                               | (call.Let lab ls c', \\<beta>, ve,\n                                  ba) \\<Rightarrow>\n                                   let b' = nb ba lab;\n \\<beta>' = \\<beta>(lab \\<mapsto> b');\n ve' =\n   ve ++\n   map_of (map (\\<lambda>(v, l). ((v, b'), \\<A> (L l) \\<beta>' ve)) ls)\n                                   in b\\<cdot>\n(Discr (c', \\<beta>', ve', b')))\\<cdot>\n                           (Discr (c, \\<beta>', ve, ba))) \\<and>\n                         (\\<forall>((lab, \\<beta>), t)\n                                   \\<in>(\\<Lambda> cstate.\n      case undiscr cstate of\n      (App lab f vs, \\<beta>, ve, b) \\<Rightarrow>\n        let f' = \\<A> f \\<beta> ve;\n            as = map (\\<lambda>v. \\<A> v \\<beta> ve) vs; b' = nb b lab\n        in if isProc f'\n           then a\\<cdot>(Discr (f', as, ve, b')) \\<union>\n                {((lab, \\<beta>), f')}\n           else \\<bottom>\n      | (call.Let lab ls c', \\<beta>, ve, ba) \\<Rightarrow>\n          let b' = nb ba lab; \\<beta>' = \\<beta>(lab \\<mapsto> b');\n              ve' =\n                ve ++\n                map_of\n                 (map (\\<lambda>(v, l). ((v, b'), \\<A> (L l) \\<beta>' ve))\n                   ls)\n          in b\\<cdot>(Discr (c', \\<beta>', ve', b')))\\<cdot>\n  (Discr (c, \\<beta>', ve, ba)).\n                             \\<exists>b'.\n                                b' \\<in> ran \\<beta> \\<and> ba \\<le> b')", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>d ds ve b.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        \\<forall>b'\\<in>contours_in_d d. b' < b;\n        \\<forall>d'\\<in>set ds.\n           \\<forall>b'\\<in>contours_in_d d'. b' < b\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (\\<bottom>\\<cdot>(Discr (d, ds, ve, b))) \\<and>\n                         (\\<forall>((lab, \\<beta>), t)\n                                   \\<in>\\<bottom>\\<cdot>\n  (Discr (d, ds, ve, b)).\n                             \\<exists>b'.\n                                b' \\<in> ran \\<beta> \\<and> b \\<le> b')\n 2. \\<And>ve b c \\<beta>'.\n       \\<lbrakk>b \\<in> ran \\<beta>';\n        \\<forall>b'\\<in>ran \\<beta>'. b' \\<le> b;\n        \\<forall>b'\\<in>contours_in_ve ve. b' \\<le> b\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (\\<bottom>\\<cdot>\n                           (Discr (c, \\<beta>', ve, b))) \\<and>\n                         (\\<forall>((lab, \\<beta>), t)\n                                   \\<in>\\<bottom>\\<cdot>\n  (Discr (c, \\<beta>', ve, b)).\n                             \\<exists>b'.\n                                b' \\<in> ran \\<beta> \\<and> b \\<le> b')\n 3. \\<And>a b d ds ve ba.\n       \\<lbrakk>\\<And>d ds ve b.\n                   \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n                    \\<forall>b'\\<in>contours_in_d d. b' < b;\n                    \\<forall>d'\\<in>set ds.\n                       \\<forall>b'\\<in>contours_in_d d'. b' < b\\<rbrakk>\n                   \\<Longrightarrow> single_valued\n(a\\<cdot>(Discr (d, ds, ve, b))) \\<and>\n                                     (\\<forall>((lab, \\<beta>), t)\n         \\<in>a\\<cdot>(Discr (d, ds, ve, b)).\n   \\<exists>b'. b' \\<in> ran \\<beta> \\<and> b \\<le> b');\n        \\<And>ve ba c \\<beta>'.\n           \\<lbrakk>ba \\<in> ran \\<beta>';\n            \\<forall>b'\\<in>ran \\<beta>'. b' \\<le> ba;\n            \\<forall>b'\\<in>contours_in_ve ve. b' \\<le> ba\\<rbrakk>\n           \\<Longrightarrow> single_valued\n                              (b\\<cdot>(Discr (c, \\<beta>', ve, ba))) \\<and>\n                             (\\<forall>((lab, \\<beta>), t)\n \\<in>b\\<cdot>(Discr (c, \\<beta>', ve, ba)).\n                                 \\<exists>b'.\n                                    b' \\<in> ran \\<beta> \\<and>\n                                    ba \\<le> b');\n        \\<forall>b'\\<in>contours_in_ve ve. b' < ba;\n        \\<forall>b'\\<in>contours_in_d d. b' < ba;\n        \\<forall>d'\\<in>set ds.\n           \\<forall>b'\\<in>contours_in_d d'. b' < ba\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          ((\\<Lambda> fstate.\n                               case undiscr fstate of\n                               (DI int, ba) \\<Rightarrow> \\<bottom>\n                               | (DC (Lambda lab vs c, \\<beta>), as, ve,\n                                  ba) \\<Rightarrow>\n                                   if length vs = length as\n                                   then let \\<beta>' = \\<beta>(lab \\<mapsto>\n        ba);\n      ve' = ve(map (\\<lambda>v. (v, ba)) vs [\\<mapsto>] as)\n  in b\\<cdot>(Discr (c, \\<beta>', ve', ba))\n                                   else \\<bottom>\n                               | (DP (Plus c), [], bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (Plus c), [DI a1], bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (Plus c), [DI a1, DI a2],\n                                  bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (Plus c), [DI a1, DI a2, cnt], ve,\n                                  b) \\<Rightarrow>\n                                   if isProc cnt\n                                   then let b' = nb b c;\n      \\<beta> = [c \\<mapsto> b]\n  in a\\<cdot>(Discr (cnt, [DI (a1 + a2)], ve, b')) \\<union>\n     {((c, \\<beta>), cnt)}\n                                   else \\<bottom>\n                               | (DP (Plus c),\n                                  DI a1 # DI a2 # cnt # aa # lista,\n                                  bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (Plus c), DI a1 # _ # lista,\n                                  bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (Plus c), _ # list, bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (prim.If ct cf), [], bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (prim.If ct cf), [DI v],\n                                  bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (prim.If ct cf), [DI v, contt],\n                                  bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (prim.If ct cf), [DI v, contt, contf],\n                                  ve, b) \\<Rightarrow>\n                                   if isProc contt \\<and> isProc contf\n                                   then if v \\<noteq> 0\n  then let b' = nb b ct; \\<beta> = [ct \\<mapsto> b]\n       in a\\<cdot>(Discr (contt, [], ve, b')) \\<union>\n          {((ct, \\<beta>), contt)}\n  else let b' = nb b cf; \\<beta> = [cf \\<mapsto> b]\n       in a\\<cdot>(Discr (contf, [], ve, b')) \\<union>\n          {((cf, \\<beta>), contf)}\n                                   else \\<bottom>\n                               | (DP (prim.If ct cf),\n                                  DI v # contt # contf # ab # lista,\n                                  bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (prim.If ct cf), _ # list,\n                                  bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (Stop, [], bb) \\<Rightarrow> \\<bottom>\n                               | (Stop, [DI i], x, xa) \\<Rightarrow> {}\n                               | (Stop, DI i # a # lista, bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (Stop, _ # list, bb) \\<Rightarrow>\n                                   \\<bottom>)\\<cdot>\n                           (Discr (d, ds, ve, ba))) \\<and>\n                         (\\<forall>((lab, \\<beta>), t)\n                                   \\<in>(\\<Lambda> fstate.\n      case undiscr fstate of (DI int, ba) \\<Rightarrow> \\<bottom>\n      | (DC (Lambda lab vs c, \\<beta>), as, ve, ba) \\<Rightarrow>\n          if length vs = length as\n          then let \\<beta>' = \\<beta>(lab \\<mapsto> ba);\n                   ve' = ve(map (\\<lambda>v. (v, ba)) vs [\\<mapsto>] as)\n               in b\\<cdot>(Discr (c, \\<beta>', ve', ba))\n          else \\<bottom>\n      | (DP (Plus c), [], bb) \\<Rightarrow> \\<bottom>\n      | (DP (Plus c), [DI a1], bb) \\<Rightarrow> \\<bottom>\n      | (DP (Plus c), [DI a1, DI a2], bb) \\<Rightarrow> \\<bottom>\n      | (DP (Plus c), [DI a1, DI a2, cnt], ve, b) \\<Rightarrow>\n          if isProc cnt\n          then let b' = nb b c; \\<beta> = [c \\<mapsto> b]\n               in a\\<cdot>(Discr (cnt, [DI (a1 + a2)], ve, b')) \\<union>\n                  {((c, \\<beta>), cnt)}\n          else \\<bottom>\n      | (DP (Plus c), DI a1 # DI a2 # cnt # aa # lista, bb) \\<Rightarrow>\n          \\<bottom>\n      | (DP (Plus c), DI a1 # _ # lista, bb) \\<Rightarrow> \\<bottom>\n      | (DP (Plus c), _ # list, bb) \\<Rightarrow> \\<bottom>\n      | (DP (prim.If ct cf), [], bb) \\<Rightarrow> \\<bottom>\n      | (DP (prim.If ct cf), [DI v], bb) \\<Rightarrow> \\<bottom>\n      | (DP (prim.If ct cf), [DI v, contt], bb) \\<Rightarrow> \\<bottom>\n      | (DP (prim.If ct cf), [DI v, contt, contf], ve, b) \\<Rightarrow>\n          if isProc contt \\<and> isProc contf\n          then if v \\<noteq> 0\n               then let b' = nb b ct; \\<beta> = [ct \\<mapsto> b]\n                    in a\\<cdot>(Discr (contt, [], ve, b')) \\<union>\n                       {((ct, \\<beta>), contt)}\n               else let b' = nb b cf; \\<beta> = [cf \\<mapsto> b]\n                    in a\\<cdot>(Discr (contf, [], ve, b')) \\<union>\n                       {((cf, \\<beta>), contf)}\n          else \\<bottom>\n      | (DP (prim.If ct cf), DI v # contt # contf # ab # lista,\n         bb) \\<Rightarrow>\n          \\<bottom>\n      | (DP (prim.If ct cf), _ # list, bb) \\<Rightarrow> \\<bottom>\n      | (Stop, [], bb) \\<Rightarrow> \\<bottom>\n      | (Stop, [DI i], x, xa) \\<Rightarrow> {}\n      | (Stop, DI i # a # lista, bb) \\<Rightarrow> \\<bottom>\n      | (Stop, _ # list, bb) \\<Rightarrow> \\<bottom>)\\<cdot>\n  (Discr (d, ds, ve, ba)).\n                             \\<exists>b'.\n                                b' \\<in> ran \\<beta> \\<and> ba \\<le> b')\n 4. \\<And>a b ve ba c \\<beta>'.\n       \\<lbrakk>\\<And>d ds ve b.\n                   \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n                    \\<forall>b'\\<in>contours_in_d d. b' < b;\n                    \\<forall>d'\\<in>set ds.\n                       \\<forall>b'\\<in>contours_in_d d'. b' < b\\<rbrakk>\n                   \\<Longrightarrow> single_valued\n(a\\<cdot>(Discr (d, ds, ve, b))) \\<and>\n                                     (\\<forall>((lab, \\<beta>), t)\n         \\<in>a\\<cdot>(Discr (d, ds, ve, b)).\n   \\<exists>b'. b' \\<in> ran \\<beta> \\<and> b \\<le> b');\n        \\<And>ve ba c \\<beta>'.\n           \\<lbrakk>ba \\<in> ran \\<beta>';\n            \\<forall>b'\\<in>ran \\<beta>'. b' \\<le> ba;\n            \\<forall>b'\\<in>contours_in_ve ve. b' \\<le> ba\\<rbrakk>\n           \\<Longrightarrow> single_valued\n                              (b\\<cdot>(Discr (c, \\<beta>', ve, ba))) \\<and>\n                             (\\<forall>((lab, \\<beta>), t)\n \\<in>b\\<cdot>(Discr (c, \\<beta>', ve, ba)).\n                                 \\<exists>b'.\n                                    b' \\<in> ran \\<beta> \\<and>\n                                    ba \\<le> b');\n        ba \\<in> ran \\<beta>'; \\<forall>b'\\<in>ran \\<beta>'. b' \\<le> ba;\n        \\<forall>b'\\<in>contours_in_ve ve. b' \\<le> ba\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          ((\\<Lambda> cstate.\n                               case undiscr cstate of\n                               (App lab f vs, \\<beta>, ve, b) \\<Rightarrow>\n                                 let f' = \\<A> f \\<beta> ve;\n                                     as =\n map (\\<lambda>v. \\<A> v \\<beta> ve) vs;\n                                     b' = nb b lab\n                                 in if isProc f'\n                                    then a\\<cdot>\n   (Discr (f', as, ve, b')) \\<union>\n   {((lab, \\<beta>), f')}\n                                    else \\<bottom>\n                               | (call.Let lab ls c', \\<beta>, ve,\n                                  ba) \\<Rightarrow>\n                                   let b' = nb ba lab;\n \\<beta>' = \\<beta>(lab \\<mapsto> b');\n ve' =\n   ve ++\n   map_of (map (\\<lambda>(v, l). ((v, b'), \\<A> (L l) \\<beta>' ve)) ls)\n                                   in b\\<cdot>\n(Discr (c', \\<beta>', ve', b')))\\<cdot>\n                           (Discr (c, \\<beta>', ve, ba))) \\<and>\n                         (\\<forall>((lab, \\<beta>), t)\n                                   \\<in>(\\<Lambda> cstate.\n      case undiscr cstate of\n      (App lab f vs, \\<beta>, ve, b) \\<Rightarrow>\n        let f' = \\<A> f \\<beta> ve;\n            as = map (\\<lambda>v. \\<A> v \\<beta> ve) vs; b' = nb b lab\n        in if isProc f'\n           then a\\<cdot>(Discr (f', as, ve, b')) \\<union>\n                {((lab, \\<beta>), f')}\n           else \\<bottom>\n      | (call.Let lab ls c', \\<beta>, ve, ba) \\<Rightarrow>\n          let b' = nb ba lab; \\<beta>' = \\<beta>(lab \\<mapsto> b');\n              ve' =\n                ve ++\n                map_of\n                 (map (\\<lambda>(v, l). ((v, b'), \\<A> (L l) \\<beta>' ve))\n                   ls)\n          in b\\<cdot>(Discr (c', \\<beta>', ve', b')))\\<cdot>\n  (Discr (c, \\<beta>', ve, ba)).\n                             \\<exists>b'.\n                                b' \\<in> ran \\<beta> \\<and> ba \\<le> b')", "case Bottom"], ["proof (state)\nthis:\n  \n\ngoal (4 subgoals):\n 1. \\<And>d ds ve b.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        \\<forall>b'\\<in>contours_in_d d. b' < b;\n        \\<forall>d'\\<in>set ds.\n           \\<forall>b'\\<in>contours_in_d d'. b' < b\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (\\<bottom>\\<cdot>(Discr (d, ds, ve, b))) \\<and>\n                         (\\<forall>((lab, \\<beta>), t)\n                                   \\<in>\\<bottom>\\<cdot>\n  (Discr (d, ds, ve, b)).\n                             \\<exists>b'.\n                                b' \\<in> ran \\<beta> \\<and> b \\<le> b')\n 2. \\<And>ve b c \\<beta>'.\n       \\<lbrakk>b \\<in> ran \\<beta>';\n        \\<forall>b'\\<in>ran \\<beta>'. b' \\<le> b;\n        \\<forall>b'\\<in>contours_in_ve ve. b' \\<le> b\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (\\<bottom>\\<cdot>\n                           (Discr (c, \\<beta>', ve, b))) \\<and>\n                         (\\<forall>((lab, \\<beta>), t)\n                                   \\<in>\\<bottom>\\<cdot>\n  (Discr (c, \\<beta>', ve, b)).\n                             \\<exists>b'.\n                                b' \\<in> ran \\<beta> \\<and> b \\<le> b')\n 3. \\<And>a b d ds ve ba.\n       \\<lbrakk>\\<And>d ds ve b.\n                   \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n                    \\<forall>b'\\<in>contours_in_d d. b' < b;\n                    \\<forall>d'\\<in>set ds.\n                       \\<forall>b'\\<in>contours_in_d d'. b' < b\\<rbrakk>\n                   \\<Longrightarrow> single_valued\n(a\\<cdot>(Discr (d, ds, ve, b))) \\<and>\n                                     (\\<forall>((lab, \\<beta>), t)\n         \\<in>a\\<cdot>(Discr (d, ds, ve, b)).\n   \\<exists>b'. b' \\<in> ran \\<beta> \\<and> b \\<le> b');\n        \\<And>ve ba c \\<beta>'.\n           \\<lbrakk>ba \\<in> ran \\<beta>';\n            \\<forall>b'\\<in>ran \\<beta>'. b' \\<le> ba;\n            \\<forall>b'\\<in>contours_in_ve ve. b' \\<le> ba\\<rbrakk>\n           \\<Longrightarrow> single_valued\n                              (b\\<cdot>(Discr (c, \\<beta>', ve, ba))) \\<and>\n                             (\\<forall>((lab, \\<beta>), t)\n \\<in>b\\<cdot>(Discr (c, \\<beta>', ve, ba)).\n                                 \\<exists>b'.\n                                    b' \\<in> ran \\<beta> \\<and>\n                                    ba \\<le> b');\n        \\<forall>b'\\<in>contours_in_ve ve. b' < ba;\n        \\<forall>b'\\<in>contours_in_d d. b' < ba;\n        \\<forall>d'\\<in>set ds.\n           \\<forall>b'\\<in>contours_in_d d'. b' < ba\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          ((\\<Lambda> fstate.\n                               case undiscr fstate of\n                               (DI int, ba) \\<Rightarrow> \\<bottom>\n                               | (DC (Lambda lab vs c, \\<beta>), as, ve,\n                                  ba) \\<Rightarrow>\n                                   if length vs = length as\n                                   then let \\<beta>' = \\<beta>(lab \\<mapsto>\n        ba);\n      ve' = ve(map (\\<lambda>v. (v, ba)) vs [\\<mapsto>] as)\n  in b\\<cdot>(Discr (c, \\<beta>', ve', ba))\n                                   else \\<bottom>\n                               | (DP (Plus c), [], bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (Plus c), [DI a1], bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (Plus c), [DI a1, DI a2],\n                                  bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (Plus c), [DI a1, DI a2, cnt], ve,\n                                  b) \\<Rightarrow>\n                                   if isProc cnt\n                                   then let b' = nb b c;\n      \\<beta> = [c \\<mapsto> b]\n  in a\\<cdot>(Discr (cnt, [DI (a1 + a2)], ve, b')) \\<union>\n     {((c, \\<beta>), cnt)}\n                                   else \\<bottom>\n                               | (DP (Plus c),\n                                  DI a1 # DI a2 # cnt # aa # lista,\n                                  bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (Plus c), DI a1 # _ # lista,\n                                  bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (Plus c), _ # list, bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (prim.If ct cf), [], bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (prim.If ct cf), [DI v],\n                                  bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (prim.If ct cf), [DI v, contt],\n                                  bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (prim.If ct cf), [DI v, contt, contf],\n                                  ve, b) \\<Rightarrow>\n                                   if isProc contt \\<and> isProc contf\n                                   then if v \\<noteq> 0\n  then let b' = nb b ct; \\<beta> = [ct \\<mapsto> b]\n       in a\\<cdot>(Discr (contt, [], ve, b')) \\<union>\n          {((ct, \\<beta>), contt)}\n  else let b' = nb b cf; \\<beta> = [cf \\<mapsto> b]\n       in a\\<cdot>(Discr (contf, [], ve, b')) \\<union>\n          {((cf, \\<beta>), contf)}\n                                   else \\<bottom>\n                               | (DP (prim.If ct cf),\n                                  DI v # contt # contf # ab # lista,\n                                  bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (prim.If ct cf), _ # list,\n                                  bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (Stop, [], bb) \\<Rightarrow> \\<bottom>\n                               | (Stop, [DI i], x, xa) \\<Rightarrow> {}\n                               | (Stop, DI i # a # lista, bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (Stop, _ # list, bb) \\<Rightarrow>\n                                   \\<bottom>)\\<cdot>\n                           (Discr (d, ds, ve, ba))) \\<and>\n                         (\\<forall>((lab, \\<beta>), t)\n                                   \\<in>(\\<Lambda> fstate.\n      case undiscr fstate of (DI int, ba) \\<Rightarrow> \\<bottom>\n      | (DC (Lambda lab vs c, \\<beta>), as, ve, ba) \\<Rightarrow>\n          if length vs = length as\n          then let \\<beta>' = \\<beta>(lab \\<mapsto> ba);\n                   ve' = ve(map (\\<lambda>v. (v, ba)) vs [\\<mapsto>] as)\n               in b\\<cdot>(Discr (c, \\<beta>', ve', ba))\n          else \\<bottom>\n      | (DP (Plus c), [], bb) \\<Rightarrow> \\<bottom>\n      | (DP (Plus c), [DI a1], bb) \\<Rightarrow> \\<bottom>\n      | (DP (Plus c), [DI a1, DI a2], bb) \\<Rightarrow> \\<bottom>\n      | (DP (Plus c), [DI a1, DI a2, cnt], ve, b) \\<Rightarrow>\n          if isProc cnt\n          then let b' = nb b c; \\<beta> = [c \\<mapsto> b]\n               in a\\<cdot>(Discr (cnt, [DI (a1 + a2)], ve, b')) \\<union>\n                  {((c, \\<beta>), cnt)}\n          else \\<bottom>\n      | (DP (Plus c), DI a1 # DI a2 # cnt # aa # lista, bb) \\<Rightarrow>\n          \\<bottom>\n      | (DP (Plus c), DI a1 # _ # lista, bb) \\<Rightarrow> \\<bottom>\n      | (DP (Plus c), _ # list, bb) \\<Rightarrow> \\<bottom>\n      | (DP (prim.If ct cf), [], bb) \\<Rightarrow> \\<bottom>\n      | (DP (prim.If ct cf), [DI v], bb) \\<Rightarrow> \\<bottom>\n      | (DP (prim.If ct cf), [DI v, contt], bb) \\<Rightarrow> \\<bottom>\n      | (DP (prim.If ct cf), [DI v, contt, contf], ve, b) \\<Rightarrow>\n          if isProc contt \\<and> isProc contf\n          then if v \\<noteq> 0\n               then let b' = nb b ct; \\<beta> = [ct \\<mapsto> b]\n                    in a\\<cdot>(Discr (contt, [], ve, b')) \\<union>\n                       {((ct, \\<beta>), contt)}\n               else let b' = nb b cf; \\<beta> = [cf \\<mapsto> b]\n                    in a\\<cdot>(Discr (contf, [], ve, b')) \\<union>\n                       {((cf, \\<beta>), contf)}\n          else \\<bottom>\n      | (DP (prim.If ct cf), DI v # contt # contf # ab # lista,\n         bb) \\<Rightarrow>\n          \\<bottom>\n      | (DP (prim.If ct cf), _ # list, bb) \\<Rightarrow> \\<bottom>\n      | (Stop, [], bb) \\<Rightarrow> \\<bottom>\n      | (Stop, [DI i], x, xa) \\<Rightarrow> {}\n      | (Stop, DI i # a # lista, bb) \\<Rightarrow> \\<bottom>\n      | (Stop, _ # list, bb) \\<Rightarrow> \\<bottom>)\\<cdot>\n  (Discr (d, ds, ve, ba)).\n                             \\<exists>b'.\n                                b' \\<in> ran \\<beta> \\<and> ba \\<le> b')\n 4. \\<And>a b ve ba c \\<beta>'.\n       \\<lbrakk>\\<And>d ds ve b.\n                   \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n                    \\<forall>b'\\<in>contours_in_d d. b' < b;\n                    \\<forall>d'\\<in>set ds.\n                       \\<forall>b'\\<in>contours_in_d d'. b' < b\\<rbrakk>\n                   \\<Longrightarrow> single_valued\n(a\\<cdot>(Discr (d, ds, ve, b))) \\<and>\n                                     (\\<forall>((lab, \\<beta>), t)\n         \\<in>a\\<cdot>(Discr (d, ds, ve, b)).\n   \\<exists>b'. b' \\<in> ran \\<beta> \\<and> b \\<le> b');\n        \\<And>ve ba c \\<beta>'.\n           \\<lbrakk>ba \\<in> ran \\<beta>';\n            \\<forall>b'\\<in>ran \\<beta>'. b' \\<le> ba;\n            \\<forall>b'\\<in>contours_in_ve ve. b' \\<le> ba\\<rbrakk>\n           \\<Longrightarrow> single_valued\n                              (b\\<cdot>(Discr (c, \\<beta>', ve, ba))) \\<and>\n                             (\\<forall>((lab, \\<beta>), t)\n \\<in>b\\<cdot>(Discr (c, \\<beta>', ve, ba)).\n                                 \\<exists>b'.\n                                    b' \\<in> ran \\<beta> \\<and>\n                                    ba \\<le> b');\n        ba \\<in> ran \\<beta>'; \\<forall>b'\\<in>ran \\<beta>'. b' \\<le> ba;\n        \\<forall>b'\\<in>contours_in_ve ve. b' \\<le> ba\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          ((\\<Lambda> cstate.\n                               case undiscr cstate of\n                               (App lab f vs, \\<beta>, ve, b) \\<Rightarrow>\n                                 let f' = \\<A> f \\<beta> ve;\n                                     as =\n map (\\<lambda>v. \\<A> v \\<beta> ve) vs;\n                                     b' = nb b lab\n                                 in if isProc f'\n                                    then a\\<cdot>\n   (Discr (f', as, ve, b')) \\<union>\n   {((lab, \\<beta>), f')}\n                                    else \\<bottom>\n                               | (call.Let lab ls c', \\<beta>, ve,\n                                  ba) \\<Rightarrow>\n                                   let b' = nb ba lab;\n \\<beta>' = \\<beta>(lab \\<mapsto> b');\n ve' =\n   ve ++\n   map_of (map (\\<lambda>(v, l). ((v, b'), \\<A> (L l) \\<beta>' ve)) ls)\n                                   in b\\<cdot>\n(Discr (c', \\<beta>', ve', b')))\\<cdot>\n                           (Discr (c, \\<beta>', ve, ba))) \\<and>\n                         (\\<forall>((lab, \\<beta>), t)\n                                   \\<in>(\\<Lambda> cstate.\n      case undiscr cstate of\n      (App lab f vs, \\<beta>, ve, b) \\<Rightarrow>\n        let f' = \\<A> f \\<beta> ve;\n            as = map (\\<lambda>v. \\<A> v \\<beta> ve) vs; b' = nb b lab\n        in if isProc f'\n           then a\\<cdot>(Discr (f', as, ve, b')) \\<union>\n                {((lab, \\<beta>), f')}\n           else \\<bottom>\n      | (call.Let lab ls c', \\<beta>, ve, ba) \\<Rightarrow>\n          let b' = nb ba lab; \\<beta>' = \\<beta>(lab \\<mapsto> b');\n              ve' =\n                ve ++\n                map_of\n                 (map (\\<lambda>(v, l). ((v, b'), \\<A> (L l) \\<beta>' ve))\n                   ls)\n          in b\\<cdot>(Discr (c', \\<beta>', ve', b')))\\<cdot>\n  (Discr (c, \\<beta>', ve, ba)).\n                             \\<exists>b'.\n                                b' \\<in> ran \\<beta> \\<and> ba \\<le> b')", "{"], ["proof (state)\nthis:\n  \n\ngoal (4 subgoals):\n 1. \\<And>d ds ve b.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        \\<forall>b'\\<in>contours_in_d d. b' < b;\n        \\<forall>d'\\<in>set ds.\n           \\<forall>b'\\<in>contours_in_d d'. b' < b\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (\\<bottom>\\<cdot>(Discr (d, ds, ve, b))) \\<and>\n                         (\\<forall>((lab, \\<beta>), t)\n                                   \\<in>\\<bottom>\\<cdot>\n  (Discr (d, ds, ve, b)).\n                             \\<exists>b'.\n                                b' \\<in> ran \\<beta> \\<and> b \\<le> b')\n 2. \\<And>ve b c \\<beta>'.\n       \\<lbrakk>b \\<in> ran \\<beta>';\n        \\<forall>b'\\<in>ran \\<beta>'. b' \\<le> b;\n        \\<forall>b'\\<in>contours_in_ve ve. b' \\<le> b\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (\\<bottom>\\<cdot>\n                           (Discr (c, \\<beta>', ve, b))) \\<and>\n                         (\\<forall>((lab, \\<beta>), t)\n                                   \\<in>\\<bottom>\\<cdot>\n  (Discr (c, \\<beta>', ve, b)).\n                             \\<exists>b'.\n                                b' \\<in> ran \\<beta> \\<and> b \\<le> b')\n 3. \\<And>a b d ds ve ba.\n       \\<lbrakk>\\<And>d ds ve b.\n                   \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n                    \\<forall>b'\\<in>contours_in_d d. b' < b;\n                    \\<forall>d'\\<in>set ds.\n                       \\<forall>b'\\<in>contours_in_d d'. b' < b\\<rbrakk>\n                   \\<Longrightarrow> single_valued\n(a\\<cdot>(Discr (d, ds, ve, b))) \\<and>\n                                     (\\<forall>((lab, \\<beta>), t)\n         \\<in>a\\<cdot>(Discr (d, ds, ve, b)).\n   \\<exists>b'. b' \\<in> ran \\<beta> \\<and> b \\<le> b');\n        \\<And>ve ba c \\<beta>'.\n           \\<lbrakk>ba \\<in> ran \\<beta>';\n            \\<forall>b'\\<in>ran \\<beta>'. b' \\<le> ba;\n            \\<forall>b'\\<in>contours_in_ve ve. b' \\<le> ba\\<rbrakk>\n           \\<Longrightarrow> single_valued\n                              (b\\<cdot>(Discr (c, \\<beta>', ve, ba))) \\<and>\n                             (\\<forall>((lab, \\<beta>), t)\n \\<in>b\\<cdot>(Discr (c, \\<beta>', ve, ba)).\n                                 \\<exists>b'.\n                                    b' \\<in> ran \\<beta> \\<and>\n                                    ba \\<le> b');\n        \\<forall>b'\\<in>contours_in_ve ve. b' < ba;\n        \\<forall>b'\\<in>contours_in_d d. b' < ba;\n        \\<forall>d'\\<in>set ds.\n           \\<forall>b'\\<in>contours_in_d d'. b' < ba\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          ((\\<Lambda> fstate.\n                               case undiscr fstate of\n                               (DI int, ba) \\<Rightarrow> \\<bottom>\n                               | (DC (Lambda lab vs c, \\<beta>), as, ve,\n                                  ba) \\<Rightarrow>\n                                   if length vs = length as\n                                   then let \\<beta>' = \\<beta>(lab \\<mapsto>\n        ba);\n      ve' = ve(map (\\<lambda>v. (v, ba)) vs [\\<mapsto>] as)\n  in b\\<cdot>(Discr (c, \\<beta>', ve', ba))\n                                   else \\<bottom>\n                               | (DP (Plus c), [], bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (Plus c), [DI a1], bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (Plus c), [DI a1, DI a2],\n                                  bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (Plus c), [DI a1, DI a2, cnt], ve,\n                                  b) \\<Rightarrow>\n                                   if isProc cnt\n                                   then let b' = nb b c;\n      \\<beta> = [c \\<mapsto> b]\n  in a\\<cdot>(Discr (cnt, [DI (a1 + a2)], ve, b')) \\<union>\n     {((c, \\<beta>), cnt)}\n                                   else \\<bottom>\n                               | (DP (Plus c),\n                                  DI a1 # DI a2 # cnt # aa # lista,\n                                  bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (Plus c), DI a1 # _ # lista,\n                                  bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (Plus c), _ # list, bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (prim.If ct cf), [], bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (prim.If ct cf), [DI v],\n                                  bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (prim.If ct cf), [DI v, contt],\n                                  bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (prim.If ct cf), [DI v, contt, contf],\n                                  ve, b) \\<Rightarrow>\n                                   if isProc contt \\<and> isProc contf\n                                   then if v \\<noteq> 0\n  then let b' = nb b ct; \\<beta> = [ct \\<mapsto> b]\n       in a\\<cdot>(Discr (contt, [], ve, b')) \\<union>\n          {((ct, \\<beta>), contt)}\n  else let b' = nb b cf; \\<beta> = [cf \\<mapsto> b]\n       in a\\<cdot>(Discr (contf, [], ve, b')) \\<union>\n          {((cf, \\<beta>), contf)}\n                                   else \\<bottom>\n                               | (DP (prim.If ct cf),\n                                  DI v # contt # contf # ab # lista,\n                                  bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (prim.If ct cf), _ # list,\n                                  bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (Stop, [], bb) \\<Rightarrow> \\<bottom>\n                               | (Stop, [DI i], x, xa) \\<Rightarrow> {}\n                               | (Stop, DI i # a # lista, bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (Stop, _ # list, bb) \\<Rightarrow>\n                                   \\<bottom>)\\<cdot>\n                           (Discr (d, ds, ve, ba))) \\<and>\n                         (\\<forall>((lab, \\<beta>), t)\n                                   \\<in>(\\<Lambda> fstate.\n      case undiscr fstate of (DI int, ba) \\<Rightarrow> \\<bottom>\n      | (DC (Lambda lab vs c, \\<beta>), as, ve, ba) \\<Rightarrow>\n          if length vs = length as\n          then let \\<beta>' = \\<beta>(lab \\<mapsto> ba);\n                   ve' = ve(map (\\<lambda>v. (v, ba)) vs [\\<mapsto>] as)\n               in b\\<cdot>(Discr (c, \\<beta>', ve', ba))\n          else \\<bottom>\n      | (DP (Plus c), [], bb) \\<Rightarrow> \\<bottom>\n      | (DP (Plus c), [DI a1], bb) \\<Rightarrow> \\<bottom>\n      | (DP (Plus c), [DI a1, DI a2], bb) \\<Rightarrow> \\<bottom>\n      | (DP (Plus c), [DI a1, DI a2, cnt], ve, b) \\<Rightarrow>\n          if isProc cnt\n          then let b' = nb b c; \\<beta> = [c \\<mapsto> b]\n               in a\\<cdot>(Discr (cnt, [DI (a1 + a2)], ve, b')) \\<union>\n                  {((c, \\<beta>), cnt)}\n          else \\<bottom>\n      | (DP (Plus c), DI a1 # DI a2 # cnt # aa # lista, bb) \\<Rightarrow>\n          \\<bottom>\n      | (DP (Plus c), DI a1 # _ # lista, bb) \\<Rightarrow> \\<bottom>\n      | (DP (Plus c), _ # list, bb) \\<Rightarrow> \\<bottom>\n      | (DP (prim.If ct cf), [], bb) \\<Rightarrow> \\<bottom>\n      | (DP (prim.If ct cf), [DI v], bb) \\<Rightarrow> \\<bottom>\n      | (DP (prim.If ct cf), [DI v, contt], bb) \\<Rightarrow> \\<bottom>\n      | (DP (prim.If ct cf), [DI v, contt, contf], ve, b) \\<Rightarrow>\n          if isProc contt \\<and> isProc contf\n          then if v \\<noteq> 0\n               then let b' = nb b ct; \\<beta> = [ct \\<mapsto> b]\n                    in a\\<cdot>(Discr (contt, [], ve, b')) \\<union>\n                       {((ct, \\<beta>), contt)}\n               else let b' = nb b cf; \\<beta> = [cf \\<mapsto> b]\n                    in a\\<cdot>(Discr (contf, [], ve, b')) \\<union>\n                       {((cf, \\<beta>), contf)}\n          else \\<bottom>\n      | (DP (prim.If ct cf), DI v # contt # contf # ab # lista,\n         bb) \\<Rightarrow>\n          \\<bottom>\n      | (DP (prim.If ct cf), _ # list, bb) \\<Rightarrow> \\<bottom>\n      | (Stop, [], bb) \\<Rightarrow> \\<bottom>\n      | (Stop, [DI i], x, xa) \\<Rightarrow> {}\n      | (Stop, DI i # a # lista, bb) \\<Rightarrow> \\<bottom>\n      | (Stop, _ # list, bb) \\<Rightarrow> \\<bottom>)\\<cdot>\n  (Discr (d, ds, ve, ba)).\n                             \\<exists>b'.\n                                b' \\<in> ran \\<beta> \\<and> ba \\<le> b')\n 4. \\<And>a b ve ba c \\<beta>'.\n       \\<lbrakk>\\<And>d ds ve b.\n                   \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n                    \\<forall>b'\\<in>contours_in_d d. b' < b;\n                    \\<forall>d'\\<in>set ds.\n                       \\<forall>b'\\<in>contours_in_d d'. b' < b\\<rbrakk>\n                   \\<Longrightarrow> single_valued\n(a\\<cdot>(Discr (d, ds, ve, b))) \\<and>\n                                     (\\<forall>((lab, \\<beta>), t)\n         \\<in>a\\<cdot>(Discr (d, ds, ve, b)).\n   \\<exists>b'. b' \\<in> ran \\<beta> \\<and> b \\<le> b');\n        \\<And>ve ba c \\<beta>'.\n           \\<lbrakk>ba \\<in> ran \\<beta>';\n            \\<forall>b'\\<in>ran \\<beta>'. b' \\<le> ba;\n            \\<forall>b'\\<in>contours_in_ve ve. b' \\<le> ba\\<rbrakk>\n           \\<Longrightarrow> single_valued\n                              (b\\<cdot>(Discr (c, \\<beta>', ve, ba))) \\<and>\n                             (\\<forall>((lab, \\<beta>), t)\n \\<in>b\\<cdot>(Discr (c, \\<beta>', ve, ba)).\n                                 \\<exists>b'.\n                                    b' \\<in> ran \\<beta> \\<and>\n                                    ba \\<le> b');\n        ba \\<in> ran \\<beta>'; \\<forall>b'\\<in>ran \\<beta>'. b' \\<le> ba;\n        \\<forall>b'\\<in>contours_in_ve ve. b' \\<le> ba\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          ((\\<Lambda> cstate.\n                               case undiscr cstate of\n                               (App lab f vs, \\<beta>, ve, b) \\<Rightarrow>\n                                 let f' = \\<A> f \\<beta> ve;\n                                     as =\n map (\\<lambda>v. \\<A> v \\<beta> ve) vs;\n                                     b' = nb b lab\n                                 in if isProc f'\n                                    then a\\<cdot>\n   (Discr (f', as, ve, b')) \\<union>\n   {((lab, \\<beta>), f')}\n                                    else \\<bottom>\n                               | (call.Let lab ls c', \\<beta>, ve,\n                                  ba) \\<Rightarrow>\n                                   let b' = nb ba lab;\n \\<beta>' = \\<beta>(lab \\<mapsto> b');\n ve' =\n   ve ++\n   map_of (map (\\<lambda>(v, l). ((v, b'), \\<A> (L l) \\<beta>' ve)) ls)\n                                   in b\\<cdot>\n(Discr (c', \\<beta>', ve', b')))\\<cdot>\n                           (Discr (c, \\<beta>', ve, ba))) \\<and>\n                         (\\<forall>((lab, \\<beta>), t)\n                                   \\<in>(\\<Lambda> cstate.\n      case undiscr cstate of\n      (App lab f vs, \\<beta>, ve, b) \\<Rightarrow>\n        let f' = \\<A> f \\<beta> ve;\n            as = map (\\<lambda>v. \\<A> v \\<beta> ve) vs; b' = nb b lab\n        in if isProc f'\n           then a\\<cdot>(Discr (f', as, ve, b')) \\<union>\n                {((lab, \\<beta>), f')}\n           else \\<bottom>\n      | (call.Let lab ls c', \\<beta>, ve, ba) \\<Rightarrow>\n          let b' = nb ba lab; \\<beta>' = \\<beta>(lab \\<mapsto> b');\n              ve' =\n                ve ++\n                map_of\n                 (map (\\<lambda>(v, l). ((v, b'), \\<A> (L l) \\<beta>' ve))\n                   ls)\n          in b\\<cdot>(Discr (c', \\<beta>', ve', b')))\\<cdot>\n  (Discr (c, \\<beta>', ve, ba)).\n                             \\<exists>b'.\n                                b' \\<in> ran \\<beta> \\<and> ba \\<le> b')", "case 1"], ["proof (state)\nthis:\n  \\<forall>b'\\<in>contours_in_ve ve. b' < b\n  \\<forall>b'\\<in>contours_in_d d. b' < b\n  \\<forall>d'\\<in>set ds. \\<forall>b'\\<in>contours_in_d d'. b' < b\n\ngoal (4 subgoals):\n 1. \\<And>d ds ve b.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        \\<forall>b'\\<in>contours_in_d d. b' < b;\n        \\<forall>d'\\<in>set ds.\n           \\<forall>b'\\<in>contours_in_d d'. b' < b\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (\\<bottom>\\<cdot>(Discr (d, ds, ve, b))) \\<and>\n                         (\\<forall>((lab, \\<beta>), t)\n                                   \\<in>\\<bottom>\\<cdot>\n  (Discr (d, ds, ve, b)).\n                             \\<exists>b'.\n                                b' \\<in> ran \\<beta> \\<and> b \\<le> b')\n 2. \\<And>ve b c \\<beta>'.\n       \\<lbrakk>b \\<in> ran \\<beta>';\n        \\<forall>b'\\<in>ran \\<beta>'. b' \\<le> b;\n        \\<forall>b'\\<in>contours_in_ve ve. b' \\<le> b\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (\\<bottom>\\<cdot>\n                           (Discr (c, \\<beta>', ve, b))) \\<and>\n                         (\\<forall>((lab, \\<beta>), t)\n                                   \\<in>\\<bottom>\\<cdot>\n  (Discr (c, \\<beta>', ve, b)).\n                             \\<exists>b'.\n                                b' \\<in> ran \\<beta> \\<and> b \\<le> b')\n 3. \\<And>a b d ds ve ba.\n       \\<lbrakk>\\<And>d ds ve b.\n                   \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n                    \\<forall>b'\\<in>contours_in_d d. b' < b;\n                    \\<forall>d'\\<in>set ds.\n                       \\<forall>b'\\<in>contours_in_d d'. b' < b\\<rbrakk>\n                   \\<Longrightarrow> single_valued\n(a\\<cdot>(Discr (d, ds, ve, b))) \\<and>\n                                     (\\<forall>((lab, \\<beta>), t)\n         \\<in>a\\<cdot>(Discr (d, ds, ve, b)).\n   \\<exists>b'. b' \\<in> ran \\<beta> \\<and> b \\<le> b');\n        \\<And>ve ba c \\<beta>'.\n           \\<lbrakk>ba \\<in> ran \\<beta>';\n            \\<forall>b'\\<in>ran \\<beta>'. b' \\<le> ba;\n            \\<forall>b'\\<in>contours_in_ve ve. b' \\<le> ba\\<rbrakk>\n           \\<Longrightarrow> single_valued\n                              (b\\<cdot>(Discr (c, \\<beta>', ve, ba))) \\<and>\n                             (\\<forall>((lab, \\<beta>), t)\n \\<in>b\\<cdot>(Discr (c, \\<beta>', ve, ba)).\n                                 \\<exists>b'.\n                                    b' \\<in> ran \\<beta> \\<and>\n                                    ba \\<le> b');\n        \\<forall>b'\\<in>contours_in_ve ve. b' < ba;\n        \\<forall>b'\\<in>contours_in_d d. b' < ba;\n        \\<forall>d'\\<in>set ds.\n           \\<forall>b'\\<in>contours_in_d d'. b' < ba\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          ((\\<Lambda> fstate.\n                               case undiscr fstate of\n                               (DI int, ba) \\<Rightarrow> \\<bottom>\n                               | (DC (Lambda lab vs c, \\<beta>), as, ve,\n                                  ba) \\<Rightarrow>\n                                   if length vs = length as\n                                   then let \\<beta>' = \\<beta>(lab \\<mapsto>\n        ba);\n      ve' = ve(map (\\<lambda>v. (v, ba)) vs [\\<mapsto>] as)\n  in b\\<cdot>(Discr (c, \\<beta>', ve', ba))\n                                   else \\<bottom>\n                               | (DP (Plus c), [], bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (Plus c), [DI a1], bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (Plus c), [DI a1, DI a2],\n                                  bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (Plus c), [DI a1, DI a2, cnt], ve,\n                                  b) \\<Rightarrow>\n                                   if isProc cnt\n                                   then let b' = nb b c;\n      \\<beta> = [c \\<mapsto> b]\n  in a\\<cdot>(Discr (cnt, [DI (a1 + a2)], ve, b')) \\<union>\n     {((c, \\<beta>), cnt)}\n                                   else \\<bottom>\n                               | (DP (Plus c),\n                                  DI a1 # DI a2 # cnt # aa # lista,\n                                  bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (Plus c), DI a1 # _ # lista,\n                                  bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (Plus c), _ # list, bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (prim.If ct cf), [], bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (prim.If ct cf), [DI v],\n                                  bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (prim.If ct cf), [DI v, contt],\n                                  bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (prim.If ct cf), [DI v, contt, contf],\n                                  ve, b) \\<Rightarrow>\n                                   if isProc contt \\<and> isProc contf\n                                   then if v \\<noteq> 0\n  then let b' = nb b ct; \\<beta> = [ct \\<mapsto> b]\n       in a\\<cdot>(Discr (contt, [], ve, b')) \\<union>\n          {((ct, \\<beta>), contt)}\n  else let b' = nb b cf; \\<beta> = [cf \\<mapsto> b]\n       in a\\<cdot>(Discr (contf, [], ve, b')) \\<union>\n          {((cf, \\<beta>), contf)}\n                                   else \\<bottom>\n                               | (DP (prim.If ct cf),\n                                  DI v # contt # contf # ab # lista,\n                                  bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (prim.If ct cf), _ # list,\n                                  bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (Stop, [], bb) \\<Rightarrow> \\<bottom>\n                               | (Stop, [DI i], x, xa) \\<Rightarrow> {}\n                               | (Stop, DI i # a # lista, bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (Stop, _ # list, bb) \\<Rightarrow>\n                                   \\<bottom>)\\<cdot>\n                           (Discr (d, ds, ve, ba))) \\<and>\n                         (\\<forall>((lab, \\<beta>), t)\n                                   \\<in>(\\<Lambda> fstate.\n      case undiscr fstate of (DI int, ba) \\<Rightarrow> \\<bottom>\n      | (DC (Lambda lab vs c, \\<beta>), as, ve, ba) \\<Rightarrow>\n          if length vs = length as\n          then let \\<beta>' = \\<beta>(lab \\<mapsto> ba);\n                   ve' = ve(map (\\<lambda>v. (v, ba)) vs [\\<mapsto>] as)\n               in b\\<cdot>(Discr (c, \\<beta>', ve', ba))\n          else \\<bottom>\n      | (DP (Plus c), [], bb) \\<Rightarrow> \\<bottom>\n      | (DP (Plus c), [DI a1], bb) \\<Rightarrow> \\<bottom>\n      | (DP (Plus c), [DI a1, DI a2], bb) \\<Rightarrow> \\<bottom>\n      | (DP (Plus c), [DI a1, DI a2, cnt], ve, b) \\<Rightarrow>\n          if isProc cnt\n          then let b' = nb b c; \\<beta> = [c \\<mapsto> b]\n               in a\\<cdot>(Discr (cnt, [DI (a1 + a2)], ve, b')) \\<union>\n                  {((c, \\<beta>), cnt)}\n          else \\<bottom>\n      | (DP (Plus c), DI a1 # DI a2 # cnt # aa # lista, bb) \\<Rightarrow>\n          \\<bottom>\n      | (DP (Plus c), DI a1 # _ # lista, bb) \\<Rightarrow> \\<bottom>\n      | (DP (Plus c), _ # list, bb) \\<Rightarrow> \\<bottom>\n      | (DP (prim.If ct cf), [], bb) \\<Rightarrow> \\<bottom>\n      | (DP (prim.If ct cf), [DI v], bb) \\<Rightarrow> \\<bottom>\n      | (DP (prim.If ct cf), [DI v, contt], bb) \\<Rightarrow> \\<bottom>\n      | (DP (prim.If ct cf), [DI v, contt, contf], ve, b) \\<Rightarrow>\n          if isProc contt \\<and> isProc contf\n          then if v \\<noteq> 0\n               then let b' = nb b ct; \\<beta> = [ct \\<mapsto> b]\n                    in a\\<cdot>(Discr (contt, [], ve, b')) \\<union>\n                       {((ct, \\<beta>), contt)}\n               else let b' = nb b cf; \\<beta> = [cf \\<mapsto> b]\n                    in a\\<cdot>(Discr (contf, [], ve, b')) \\<union>\n                       {((cf, \\<beta>), contf)}\n          else \\<bottom>\n      | (DP (prim.If ct cf), DI v # contt # contf # ab # lista,\n         bb) \\<Rightarrow>\n          \\<bottom>\n      | (DP (prim.If ct cf), _ # list, bb) \\<Rightarrow> \\<bottom>\n      | (Stop, [], bb) \\<Rightarrow> \\<bottom>\n      | (Stop, [DI i], x, xa) \\<Rightarrow> {}\n      | (Stop, DI i # a # lista, bb) \\<Rightarrow> \\<bottom>\n      | (Stop, _ # list, bb) \\<Rightarrow> \\<bottom>)\\<cdot>\n  (Discr (d, ds, ve, ba)).\n                             \\<exists>b'.\n                                b' \\<in> ran \\<beta> \\<and> ba \\<le> b')\n 4. \\<And>a b ve ba c \\<beta>'.\n       \\<lbrakk>\\<And>d ds ve b.\n                   \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n                    \\<forall>b'\\<in>contours_in_d d. b' < b;\n                    \\<forall>d'\\<in>set ds.\n                       \\<forall>b'\\<in>contours_in_d d'. b' < b\\<rbrakk>\n                   \\<Longrightarrow> single_valued\n(a\\<cdot>(Discr (d, ds, ve, b))) \\<and>\n                                     (\\<forall>((lab, \\<beta>), t)\n         \\<in>a\\<cdot>(Discr (d, ds, ve, b)).\n   \\<exists>b'. b' \\<in> ran \\<beta> \\<and> b \\<le> b');\n        \\<And>ve ba c \\<beta>'.\n           \\<lbrakk>ba \\<in> ran \\<beta>';\n            \\<forall>b'\\<in>ran \\<beta>'. b' \\<le> ba;\n            \\<forall>b'\\<in>contours_in_ve ve. b' \\<le> ba\\<rbrakk>\n           \\<Longrightarrow> single_valued\n                              (b\\<cdot>(Discr (c, \\<beta>', ve, ba))) \\<and>\n                             (\\<forall>((lab, \\<beta>), t)\n \\<in>b\\<cdot>(Discr (c, \\<beta>', ve, ba)).\n                                 \\<exists>b'.\n                                    b' \\<in> ran \\<beta> \\<and>\n                                    ba \\<le> b');\n        ba \\<in> ran \\<beta>'; \\<forall>b'\\<in>ran \\<beta>'. b' \\<le> ba;\n        \\<forall>b'\\<in>contours_in_ve ve. b' \\<le> ba\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          ((\\<Lambda> cstate.\n                               case undiscr cstate of\n                               (App lab f vs, \\<beta>, ve, b) \\<Rightarrow>\n                                 let f' = \\<A> f \\<beta> ve;\n                                     as =\n map (\\<lambda>v. \\<A> v \\<beta> ve) vs;\n                                     b' = nb b lab\n                                 in if isProc f'\n                                    then a\\<cdot>\n   (Discr (f', as, ve, b')) \\<union>\n   {((lab, \\<beta>), f')}\n                                    else \\<bottom>\n                               | (call.Let lab ls c', \\<beta>, ve,\n                                  ba) \\<Rightarrow>\n                                   let b' = nb ba lab;\n \\<beta>' = \\<beta>(lab \\<mapsto> b');\n ve' =\n   ve ++\n   map_of (map (\\<lambda>(v, l). ((v, b'), \\<A> (L l) \\<beta>' ve)) ls)\n                                   in b\\<cdot>\n(Discr (c', \\<beta>', ve', b')))\\<cdot>\n                           (Discr (c, \\<beta>', ve, ba))) \\<and>\n                         (\\<forall>((lab, \\<beta>), t)\n                                   \\<in>(\\<Lambda> cstate.\n      case undiscr cstate of\n      (App lab f vs, \\<beta>, ve, b) \\<Rightarrow>\n        let f' = \\<A> f \\<beta> ve;\n            as = map (\\<lambda>v. \\<A> v \\<beta> ve) vs; b' = nb b lab\n        in if isProc f'\n           then a\\<cdot>(Discr (f', as, ve, b')) \\<union>\n                {((lab, \\<beta>), f')}\n           else \\<bottom>\n      | (call.Let lab ls c', \\<beta>, ve, ba) \\<Rightarrow>\n          let b' = nb ba lab; \\<beta>' = \\<beta>(lab \\<mapsto> b');\n              ve' =\n                ve ++\n                map_of\n                 (map (\\<lambda>(v, l). ((v, b'), \\<A> (L l) \\<beta>' ve))\n                   ls)\n          in b\\<cdot>(Discr (c', \\<beta>', ve', b')))\\<cdot>\n  (Discr (c, \\<beta>', ve, ba)).\n                             \\<exists>b'.\n                                b' \\<in> ran \\<beta> \\<and> ba \\<le> b')", "thus ?case"], ["proof (prove)\nusing this:\n  \\<forall>b'\\<in>contours_in_ve ve. b' < b\n  \\<forall>b'\\<in>contours_in_d d. b' < b\n  \\<forall>d'\\<in>set ds. \\<forall>b'\\<in>contours_in_d d'. b' < b\n\ngoal (1 subgoal):\n 1. single_valued (\\<bottom>\\<cdot>(Discr (d, ds, ve, b))) \\<and>\n    (\\<forall>a\\<in>\\<bottom>\\<cdot>(Discr (d, ds, ve, b)).\n        case a of\n        (a, b) \\<Rightarrow>\n          (case a of\n           (lab, \\<beta>) \\<Rightarrow>\n             \\<lambda>t.\n                \\<exists>b'. b' \\<in> ran \\<beta> \\<and> b \\<le> b')\n           b)", "by auto"], ["proof (state)\nthis:\n  single_valued (\\<bottom>\\<cdot>(Discr (d, ds, ve, b))) \\<and>\n  (\\<forall>a\\<in>\\<bottom>\\<cdot>(Discr (d, ds, ve, b)).\n      case a of\n      (a, b) \\<Rightarrow>\n        (case a of\n         (lab, \\<beta>) \\<Rightarrow>\n           \\<lambda>t. \\<exists>b'. b' \\<in> ran \\<beta> \\<and> b \\<le> b')\n         b)\n\ngoal (3 subgoals):\n 1. \\<And>ve b c \\<beta>'.\n       \\<lbrakk>b \\<in> ran \\<beta>';\n        \\<forall>b'\\<in>ran \\<beta>'. b' \\<le> b;\n        \\<forall>b'\\<in>contours_in_ve ve. b' \\<le> b\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (\\<bottom>\\<cdot>\n                           (Discr (c, \\<beta>', ve, b))) \\<and>\n                         (\\<forall>((lab, \\<beta>), t)\n                                   \\<in>\\<bottom>\\<cdot>\n  (Discr (c, \\<beta>', ve, b)).\n                             \\<exists>b'.\n                                b' \\<in> ran \\<beta> \\<and> b \\<le> b')\n 2. \\<And>a b d ds ve ba.\n       \\<lbrakk>\\<And>d ds ve b.\n                   \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n                    \\<forall>b'\\<in>contours_in_d d. b' < b;\n                    \\<forall>d'\\<in>set ds.\n                       \\<forall>b'\\<in>contours_in_d d'. b' < b\\<rbrakk>\n                   \\<Longrightarrow> single_valued\n(a\\<cdot>(Discr (d, ds, ve, b))) \\<and>\n                                     (\\<forall>((lab, \\<beta>), t)\n         \\<in>a\\<cdot>(Discr (d, ds, ve, b)).\n   \\<exists>b'. b' \\<in> ran \\<beta> \\<and> b \\<le> b');\n        \\<And>ve ba c \\<beta>'.\n           \\<lbrakk>ba \\<in> ran \\<beta>';\n            \\<forall>b'\\<in>ran \\<beta>'. b' \\<le> ba;\n            \\<forall>b'\\<in>contours_in_ve ve. b' \\<le> ba\\<rbrakk>\n           \\<Longrightarrow> single_valued\n                              (b\\<cdot>(Discr (c, \\<beta>', ve, ba))) \\<and>\n                             (\\<forall>((lab, \\<beta>), t)\n \\<in>b\\<cdot>(Discr (c, \\<beta>', ve, ba)).\n                                 \\<exists>b'.\n                                    b' \\<in> ran \\<beta> \\<and>\n                                    ba \\<le> b');\n        \\<forall>b'\\<in>contours_in_ve ve. b' < ba;\n        \\<forall>b'\\<in>contours_in_d d. b' < ba;\n        \\<forall>d'\\<in>set ds.\n           \\<forall>b'\\<in>contours_in_d d'. b' < ba\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          ((\\<Lambda> fstate.\n                               case undiscr fstate of\n                               (DI int, ba) \\<Rightarrow> \\<bottom>\n                               | (DC (Lambda lab vs c, \\<beta>), as, ve,\n                                  ba) \\<Rightarrow>\n                                   if length vs = length as\n                                   then let \\<beta>' = \\<beta>(lab \\<mapsto>\n        ba);\n      ve' = ve(map (\\<lambda>v. (v, ba)) vs [\\<mapsto>] as)\n  in b\\<cdot>(Discr (c, \\<beta>', ve', ba))\n                                   else \\<bottom>\n                               | (DP (Plus c), [], bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (Plus c), [DI a1], bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (Plus c), [DI a1, DI a2],\n                                  bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (Plus c), [DI a1, DI a2, cnt], ve,\n                                  b) \\<Rightarrow>\n                                   if isProc cnt\n                                   then let b' = nb b c;\n      \\<beta> = [c \\<mapsto> b]\n  in a\\<cdot>(Discr (cnt, [DI (a1 + a2)], ve, b')) \\<union>\n     {((c, \\<beta>), cnt)}\n                                   else \\<bottom>\n                               | (DP (Plus c),\n                                  DI a1 # DI a2 # cnt # aa # lista,\n                                  bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (Plus c), DI a1 # _ # lista,\n                                  bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (Plus c), _ # list, bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (prim.If ct cf), [], bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (prim.If ct cf), [DI v],\n                                  bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (prim.If ct cf), [DI v, contt],\n                                  bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (prim.If ct cf), [DI v, contt, contf],\n                                  ve, b) \\<Rightarrow>\n                                   if isProc contt \\<and> isProc contf\n                                   then if v \\<noteq> 0\n  then let b' = nb b ct; \\<beta> = [ct \\<mapsto> b]\n       in a\\<cdot>(Discr (contt, [], ve, b')) \\<union>\n          {((ct, \\<beta>), contt)}\n  else let b' = nb b cf; \\<beta> = [cf \\<mapsto> b]\n       in a\\<cdot>(Discr (contf, [], ve, b')) \\<union>\n          {((cf, \\<beta>), contf)}\n                                   else \\<bottom>\n                               | (DP (prim.If ct cf),\n                                  DI v # contt # contf # ab # lista,\n                                  bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (prim.If ct cf), _ # list,\n                                  bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (Stop, [], bb) \\<Rightarrow> \\<bottom>\n                               | (Stop, [DI i], x, xa) \\<Rightarrow> {}\n                               | (Stop, DI i # a # lista, bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (Stop, _ # list, bb) \\<Rightarrow>\n                                   \\<bottom>)\\<cdot>\n                           (Discr (d, ds, ve, ba))) \\<and>\n                         (\\<forall>((lab, \\<beta>), t)\n                                   \\<in>(\\<Lambda> fstate.\n      case undiscr fstate of (DI int, ba) \\<Rightarrow> \\<bottom>\n      | (DC (Lambda lab vs c, \\<beta>), as, ve, ba) \\<Rightarrow>\n          if length vs = length as\n          then let \\<beta>' = \\<beta>(lab \\<mapsto> ba);\n                   ve' = ve(map (\\<lambda>v. (v, ba)) vs [\\<mapsto>] as)\n               in b\\<cdot>(Discr (c, \\<beta>', ve', ba))\n          else \\<bottom>\n      | (DP (Plus c), [], bb) \\<Rightarrow> \\<bottom>\n      | (DP (Plus c), [DI a1], bb) \\<Rightarrow> \\<bottom>\n      | (DP (Plus c), [DI a1, DI a2], bb) \\<Rightarrow> \\<bottom>\n      | (DP (Plus c), [DI a1, DI a2, cnt], ve, b) \\<Rightarrow>\n          if isProc cnt\n          then let b' = nb b c; \\<beta> = [c \\<mapsto> b]\n               in a\\<cdot>(Discr (cnt, [DI (a1 + a2)], ve, b')) \\<union>\n                  {((c, \\<beta>), cnt)}\n          else \\<bottom>\n      | (DP (Plus c), DI a1 # DI a2 # cnt # aa # lista, bb) \\<Rightarrow>\n          \\<bottom>\n      | (DP (Plus c), DI a1 # _ # lista, bb) \\<Rightarrow> \\<bottom>\n      | (DP (Plus c), _ # list, bb) \\<Rightarrow> \\<bottom>\n      | (DP (prim.If ct cf), [], bb) \\<Rightarrow> \\<bottom>\n      | (DP (prim.If ct cf), [DI v], bb) \\<Rightarrow> \\<bottom>\n      | (DP (prim.If ct cf), [DI v, contt], bb) \\<Rightarrow> \\<bottom>\n      | (DP (prim.If ct cf), [DI v, contt, contf], ve, b) \\<Rightarrow>\n          if isProc contt \\<and> isProc contf\n          then if v \\<noteq> 0\n               then let b' = nb b ct; \\<beta> = [ct \\<mapsto> b]\n                    in a\\<cdot>(Discr (contt, [], ve, b')) \\<union>\n                       {((ct, \\<beta>), contt)}\n               else let b' = nb b cf; \\<beta> = [cf \\<mapsto> b]\n                    in a\\<cdot>(Discr (contf, [], ve, b')) \\<union>\n                       {((cf, \\<beta>), contf)}\n          else \\<bottom>\n      | (DP (prim.If ct cf), DI v # contt # contf # ab # lista,\n         bb) \\<Rightarrow>\n          \\<bottom>\n      | (DP (prim.If ct cf), _ # list, bb) \\<Rightarrow> \\<bottom>\n      | (Stop, [], bb) \\<Rightarrow> \\<bottom>\n      | (Stop, [DI i], x, xa) \\<Rightarrow> {}\n      | (Stop, DI i # a # lista, bb) \\<Rightarrow> \\<bottom>\n      | (Stop, _ # list, bb) \\<Rightarrow> \\<bottom>)\\<cdot>\n  (Discr (d, ds, ve, ba)).\n                             \\<exists>b'.\n                                b' \\<in> ran \\<beta> \\<and> ba \\<le> b')\n 3. \\<And>a b ve ba c \\<beta>'.\n       \\<lbrakk>\\<And>d ds ve b.\n                   \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n                    \\<forall>b'\\<in>contours_in_d d. b' < b;\n                    \\<forall>d'\\<in>set ds.\n                       \\<forall>b'\\<in>contours_in_d d'. b' < b\\<rbrakk>\n                   \\<Longrightarrow> single_valued\n(a\\<cdot>(Discr (d, ds, ve, b))) \\<and>\n                                     (\\<forall>((lab, \\<beta>), t)\n         \\<in>a\\<cdot>(Discr (d, ds, ve, b)).\n   \\<exists>b'. b' \\<in> ran \\<beta> \\<and> b \\<le> b');\n        \\<And>ve ba c \\<beta>'.\n           \\<lbrakk>ba \\<in> ran \\<beta>';\n            \\<forall>b'\\<in>ran \\<beta>'. b' \\<le> ba;\n            \\<forall>b'\\<in>contours_in_ve ve. b' \\<le> ba\\<rbrakk>\n           \\<Longrightarrow> single_valued\n                              (b\\<cdot>(Discr (c, \\<beta>', ve, ba))) \\<and>\n                             (\\<forall>((lab, \\<beta>), t)\n \\<in>b\\<cdot>(Discr (c, \\<beta>', ve, ba)).\n                                 \\<exists>b'.\n                                    b' \\<in> ran \\<beta> \\<and>\n                                    ba \\<le> b');\n        ba \\<in> ran \\<beta>'; \\<forall>b'\\<in>ran \\<beta>'. b' \\<le> ba;\n        \\<forall>b'\\<in>contours_in_ve ve. b' \\<le> ba\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          ((\\<Lambda> cstate.\n                               case undiscr cstate of\n                               (App lab f vs, \\<beta>, ve, b) \\<Rightarrow>\n                                 let f' = \\<A> f \\<beta> ve;\n                                     as =\n map (\\<lambda>v. \\<A> v \\<beta> ve) vs;\n                                     b' = nb b lab\n                                 in if isProc f'\n                                    then a\\<cdot>\n   (Discr (f', as, ve, b')) \\<union>\n   {((lab, \\<beta>), f')}\n                                    else \\<bottom>\n                               | (call.Let lab ls c', \\<beta>, ve,\n                                  ba) \\<Rightarrow>\n                                   let b' = nb ba lab;\n \\<beta>' = \\<beta>(lab \\<mapsto> b');\n ve' =\n   ve ++\n   map_of (map (\\<lambda>(v, l). ((v, b'), \\<A> (L l) \\<beta>' ve)) ls)\n                                   in b\\<cdot>\n(Discr (c', \\<beta>', ve', b')))\\<cdot>\n                           (Discr (c, \\<beta>', ve, ba))) \\<and>\n                         (\\<forall>((lab, \\<beta>), t)\n                                   \\<in>(\\<Lambda> cstate.\n      case undiscr cstate of\n      (App lab f vs, \\<beta>, ve, b) \\<Rightarrow>\n        let f' = \\<A> f \\<beta> ve;\n            as = map (\\<lambda>v. \\<A> v \\<beta> ve) vs; b' = nb b lab\n        in if isProc f'\n           then a\\<cdot>(Discr (f', as, ve, b')) \\<union>\n                {((lab, \\<beta>), f')}\n           else \\<bottom>\n      | (call.Let lab ls c', \\<beta>, ve, ba) \\<Rightarrow>\n          let b' = nb ba lab; \\<beta>' = \\<beta>(lab \\<mapsto> b');\n              ve' =\n                ve ++\n                map_of\n                 (map (\\<lambda>(v, l). ((v, b'), \\<A> (L l) \\<beta>' ve))\n                   ls)\n          in b\\<cdot>(Discr (c', \\<beta>', ve', b')))\\<cdot>\n  (Discr (c, \\<beta>', ve, ba)).\n                             \\<exists>b'.\n                                b' \\<in> ran \\<beta> \\<and> ba \\<le> b')", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>ve b c \\<beta>'.\n       \\<lbrakk>b \\<in> ran \\<beta>';\n        \\<forall>b'\\<in>ran \\<beta>'. b' \\<le> b;\n        \\<forall>b'\\<in>contours_in_ve ve. b' \\<le> b\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (\\<bottom>\\<cdot>\n                           (Discr (c, \\<beta>', ve, b))) \\<and>\n                         (\\<forall>((lab, \\<beta>), t)\n                                   \\<in>\\<bottom>\\<cdot>\n  (Discr (c, \\<beta>', ve, b)).\n                             \\<exists>b'.\n                                b' \\<in> ran \\<beta> \\<and> b \\<le> b')\n 2. \\<And>a b d ds ve ba.\n       \\<lbrakk>\\<And>d ds ve b.\n                   \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n                    \\<forall>b'\\<in>contours_in_d d. b' < b;\n                    \\<forall>d'\\<in>set ds.\n                       \\<forall>b'\\<in>contours_in_d d'. b' < b\\<rbrakk>\n                   \\<Longrightarrow> single_valued\n(a\\<cdot>(Discr (d, ds, ve, b))) \\<and>\n                                     (\\<forall>((lab, \\<beta>), t)\n         \\<in>a\\<cdot>(Discr (d, ds, ve, b)).\n   \\<exists>b'. b' \\<in> ran \\<beta> \\<and> b \\<le> b');\n        \\<And>ve ba c \\<beta>'.\n           \\<lbrakk>ba \\<in> ran \\<beta>';\n            \\<forall>b'\\<in>ran \\<beta>'. b' \\<le> ba;\n            \\<forall>b'\\<in>contours_in_ve ve. b' \\<le> ba\\<rbrakk>\n           \\<Longrightarrow> single_valued\n                              (b\\<cdot>(Discr (c, \\<beta>', ve, ba))) \\<and>\n                             (\\<forall>((lab, \\<beta>), t)\n \\<in>b\\<cdot>(Discr (c, \\<beta>', ve, ba)).\n                                 \\<exists>b'.\n                                    b' \\<in> ran \\<beta> \\<and>\n                                    ba \\<le> b');\n        \\<forall>b'\\<in>contours_in_ve ve. b' < ba;\n        \\<forall>b'\\<in>contours_in_d d. b' < ba;\n        \\<forall>d'\\<in>set ds.\n           \\<forall>b'\\<in>contours_in_d d'. b' < ba\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          ((\\<Lambda> fstate.\n                               case undiscr fstate of\n                               (DI int, ba) \\<Rightarrow> \\<bottom>\n                               | (DC (Lambda lab vs c, \\<beta>), as, ve,\n                                  ba) \\<Rightarrow>\n                                   if length vs = length as\n                                   then let \\<beta>' = \\<beta>(lab \\<mapsto>\n        ba);\n      ve' = ve(map (\\<lambda>v. (v, ba)) vs [\\<mapsto>] as)\n  in b\\<cdot>(Discr (c, \\<beta>', ve', ba))\n                                   else \\<bottom>\n                               | (DP (Plus c), [], bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (Plus c), [DI a1], bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (Plus c), [DI a1, DI a2],\n                                  bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (Plus c), [DI a1, DI a2, cnt], ve,\n                                  b) \\<Rightarrow>\n                                   if isProc cnt\n                                   then let b' = nb b c;\n      \\<beta> = [c \\<mapsto> b]\n  in a\\<cdot>(Discr (cnt, [DI (a1 + a2)], ve, b')) \\<union>\n     {((c, \\<beta>), cnt)}\n                                   else \\<bottom>\n                               | (DP (Plus c),\n                                  DI a1 # DI a2 # cnt # aa # lista,\n                                  bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (Plus c), DI a1 # _ # lista,\n                                  bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (Plus c), _ # list, bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (prim.If ct cf), [], bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (prim.If ct cf), [DI v],\n                                  bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (prim.If ct cf), [DI v, contt],\n                                  bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (prim.If ct cf), [DI v, contt, contf],\n                                  ve, b) \\<Rightarrow>\n                                   if isProc contt \\<and> isProc contf\n                                   then if v \\<noteq> 0\n  then let b' = nb b ct; \\<beta> = [ct \\<mapsto> b]\n       in a\\<cdot>(Discr (contt, [], ve, b')) \\<union>\n          {((ct, \\<beta>), contt)}\n  else let b' = nb b cf; \\<beta> = [cf \\<mapsto> b]\n       in a\\<cdot>(Discr (contf, [], ve, b')) \\<union>\n          {((cf, \\<beta>), contf)}\n                                   else \\<bottom>\n                               | (DP (prim.If ct cf),\n                                  DI v # contt # contf # ab # lista,\n                                  bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (prim.If ct cf), _ # list,\n                                  bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (Stop, [], bb) \\<Rightarrow> \\<bottom>\n                               | (Stop, [DI i], x, xa) \\<Rightarrow> {}\n                               | (Stop, DI i # a # lista, bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (Stop, _ # list, bb) \\<Rightarrow>\n                                   \\<bottom>)\\<cdot>\n                           (Discr (d, ds, ve, ba))) \\<and>\n                         (\\<forall>((lab, \\<beta>), t)\n                                   \\<in>(\\<Lambda> fstate.\n      case undiscr fstate of (DI int, ba) \\<Rightarrow> \\<bottom>\n      | (DC (Lambda lab vs c, \\<beta>), as, ve, ba) \\<Rightarrow>\n          if length vs = length as\n          then let \\<beta>' = \\<beta>(lab \\<mapsto> ba);\n                   ve' = ve(map (\\<lambda>v. (v, ba)) vs [\\<mapsto>] as)\n               in b\\<cdot>(Discr (c, \\<beta>', ve', ba))\n          else \\<bottom>\n      | (DP (Plus c), [], bb) \\<Rightarrow> \\<bottom>\n      | (DP (Plus c), [DI a1], bb) \\<Rightarrow> \\<bottom>\n      | (DP (Plus c), [DI a1, DI a2], bb) \\<Rightarrow> \\<bottom>\n      | (DP (Plus c), [DI a1, DI a2, cnt], ve, b) \\<Rightarrow>\n          if isProc cnt\n          then let b' = nb b c; \\<beta> = [c \\<mapsto> b]\n               in a\\<cdot>(Discr (cnt, [DI (a1 + a2)], ve, b')) \\<union>\n                  {((c, \\<beta>), cnt)}\n          else \\<bottom>\n      | (DP (Plus c), DI a1 # DI a2 # cnt # aa # lista, bb) \\<Rightarrow>\n          \\<bottom>\n      | (DP (Plus c), DI a1 # _ # lista, bb) \\<Rightarrow> \\<bottom>\n      | (DP (Plus c), _ # list, bb) \\<Rightarrow> \\<bottom>\n      | (DP (prim.If ct cf), [], bb) \\<Rightarrow> \\<bottom>\n      | (DP (prim.If ct cf), [DI v], bb) \\<Rightarrow> \\<bottom>\n      | (DP (prim.If ct cf), [DI v, contt], bb) \\<Rightarrow> \\<bottom>\n      | (DP (prim.If ct cf), [DI v, contt, contf], ve, b) \\<Rightarrow>\n          if isProc contt \\<and> isProc contf\n          then if v \\<noteq> 0\n               then let b' = nb b ct; \\<beta> = [ct \\<mapsto> b]\n                    in a\\<cdot>(Discr (contt, [], ve, b')) \\<union>\n                       {((ct, \\<beta>), contt)}\n               else let b' = nb b cf; \\<beta> = [cf \\<mapsto> b]\n                    in a\\<cdot>(Discr (contf, [], ve, b')) \\<union>\n                       {((cf, \\<beta>), contf)}\n          else \\<bottom>\n      | (DP (prim.If ct cf), DI v # contt # contf # ab # lista,\n         bb) \\<Rightarrow>\n          \\<bottom>\n      | (DP (prim.If ct cf), _ # list, bb) \\<Rightarrow> \\<bottom>\n      | (Stop, [], bb) \\<Rightarrow> \\<bottom>\n      | (Stop, [DI i], x, xa) \\<Rightarrow> {}\n      | (Stop, DI i # a # lista, bb) \\<Rightarrow> \\<bottom>\n      | (Stop, _ # list, bb) \\<Rightarrow> \\<bottom>)\\<cdot>\n  (Discr (d, ds, ve, ba)).\n                             \\<exists>b'.\n                                b' \\<in> ran \\<beta> \\<and> ba \\<le> b')\n 3. \\<And>a b ve ba c \\<beta>'.\n       \\<lbrakk>\\<And>d ds ve b.\n                   \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n                    \\<forall>b'\\<in>contours_in_d d. b' < b;\n                    \\<forall>d'\\<in>set ds.\n                       \\<forall>b'\\<in>contours_in_d d'. b' < b\\<rbrakk>\n                   \\<Longrightarrow> single_valued\n(a\\<cdot>(Discr (d, ds, ve, b))) \\<and>\n                                     (\\<forall>((lab, \\<beta>), t)\n         \\<in>a\\<cdot>(Discr (d, ds, ve, b)).\n   \\<exists>b'. b' \\<in> ran \\<beta> \\<and> b \\<le> b');\n        \\<And>ve ba c \\<beta>'.\n           \\<lbrakk>ba \\<in> ran \\<beta>';\n            \\<forall>b'\\<in>ran \\<beta>'. b' \\<le> ba;\n            \\<forall>b'\\<in>contours_in_ve ve. b' \\<le> ba\\<rbrakk>\n           \\<Longrightarrow> single_valued\n                              (b\\<cdot>(Discr (c, \\<beta>', ve, ba))) \\<and>\n                             (\\<forall>((lab, \\<beta>), t)\n \\<in>b\\<cdot>(Discr (c, \\<beta>', ve, ba)).\n                                 \\<exists>b'.\n                                    b' \\<in> ran \\<beta> \\<and>\n                                    ba \\<le> b');\n        ba \\<in> ran \\<beta>'; \\<forall>b'\\<in>ran \\<beta>'. b' \\<le> ba;\n        \\<forall>b'\\<in>contours_in_ve ve. b' \\<le> ba\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          ((\\<Lambda> cstate.\n                               case undiscr cstate of\n                               (App lab f vs, \\<beta>, ve, b) \\<Rightarrow>\n                                 let f' = \\<A> f \\<beta> ve;\n                                     as =\n map (\\<lambda>v. \\<A> v \\<beta> ve) vs;\n                                     b' = nb b lab\n                                 in if isProc f'\n                                    then a\\<cdot>\n   (Discr (f', as, ve, b')) \\<union>\n   {((lab, \\<beta>), f')}\n                                    else \\<bottom>\n                               | (call.Let lab ls c', \\<beta>, ve,\n                                  ba) \\<Rightarrow>\n                                   let b' = nb ba lab;\n \\<beta>' = \\<beta>(lab \\<mapsto> b');\n ve' =\n   ve ++\n   map_of (map (\\<lambda>(v, l). ((v, b'), \\<A> (L l) \\<beta>' ve)) ls)\n                                   in b\\<cdot>\n(Discr (c', \\<beta>', ve', b')))\\<cdot>\n                           (Discr (c, \\<beta>', ve, ba))) \\<and>\n                         (\\<forall>((lab, \\<beta>), t)\n                                   \\<in>(\\<Lambda> cstate.\n      case undiscr cstate of\n      (App lab f vs, \\<beta>, ve, b) \\<Rightarrow>\n        let f' = \\<A> f \\<beta> ve;\n            as = map (\\<lambda>v. \\<A> v \\<beta> ve) vs; b' = nb b lab\n        in if isProc f'\n           then a\\<cdot>(Discr (f', as, ve, b')) \\<union>\n                {((lab, \\<beta>), f')}\n           else \\<bottom>\n      | (call.Let lab ls c', \\<beta>, ve, ba) \\<Rightarrow>\n          let b' = nb ba lab; \\<beta>' = \\<beta>(lab \\<mapsto> b');\n              ve' =\n                ve ++\n                map_of\n                 (map (\\<lambda>(v, l). ((v, b'), \\<A> (L l) \\<beta>' ve))\n                   ls)\n          in b\\<cdot>(Discr (c', \\<beta>', ve', b')))\\<cdot>\n  (Discr (c, \\<beta>', ve, ba)).\n                             \\<exists>b'.\n                                b' \\<in> ran \\<beta> \\<and> ba \\<le> b')", "case 2"], ["proof (state)\nthis:\n  b \\<in> ran \\<beta>'\n  \\<forall>b'\\<in>ran \\<beta>'. b' \\<le> b\n  \\<forall>b'\\<in>contours_in_ve ve. b' \\<le> b\n\ngoal (3 subgoals):\n 1. \\<And>ve b c \\<beta>'.\n       \\<lbrakk>b \\<in> ran \\<beta>';\n        \\<forall>b'\\<in>ran \\<beta>'. b' \\<le> b;\n        \\<forall>b'\\<in>contours_in_ve ve. b' \\<le> b\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (\\<bottom>\\<cdot>\n                           (Discr (c, \\<beta>', ve, b))) \\<and>\n                         (\\<forall>((lab, \\<beta>), t)\n                                   \\<in>\\<bottom>\\<cdot>\n  (Discr (c, \\<beta>', ve, b)).\n                             \\<exists>b'.\n                                b' \\<in> ran \\<beta> \\<and> b \\<le> b')\n 2. \\<And>a b d ds ve ba.\n       \\<lbrakk>\\<And>d ds ve b.\n                   \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n                    \\<forall>b'\\<in>contours_in_d d. b' < b;\n                    \\<forall>d'\\<in>set ds.\n                       \\<forall>b'\\<in>contours_in_d d'. b' < b\\<rbrakk>\n                   \\<Longrightarrow> single_valued\n(a\\<cdot>(Discr (d, ds, ve, b))) \\<and>\n                                     (\\<forall>((lab, \\<beta>), t)\n         \\<in>a\\<cdot>(Discr (d, ds, ve, b)).\n   \\<exists>b'. b' \\<in> ran \\<beta> \\<and> b \\<le> b');\n        \\<And>ve ba c \\<beta>'.\n           \\<lbrakk>ba \\<in> ran \\<beta>';\n            \\<forall>b'\\<in>ran \\<beta>'. b' \\<le> ba;\n            \\<forall>b'\\<in>contours_in_ve ve. b' \\<le> ba\\<rbrakk>\n           \\<Longrightarrow> single_valued\n                              (b\\<cdot>(Discr (c, \\<beta>', ve, ba))) \\<and>\n                             (\\<forall>((lab, \\<beta>), t)\n \\<in>b\\<cdot>(Discr (c, \\<beta>', ve, ba)).\n                                 \\<exists>b'.\n                                    b' \\<in> ran \\<beta> \\<and>\n                                    ba \\<le> b');\n        \\<forall>b'\\<in>contours_in_ve ve. b' < ba;\n        \\<forall>b'\\<in>contours_in_d d. b' < ba;\n        \\<forall>d'\\<in>set ds.\n           \\<forall>b'\\<in>contours_in_d d'. b' < ba\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          ((\\<Lambda> fstate.\n                               case undiscr fstate of\n                               (DI int, ba) \\<Rightarrow> \\<bottom>\n                               | (DC (Lambda lab vs c, \\<beta>), as, ve,\n                                  ba) \\<Rightarrow>\n                                   if length vs = length as\n                                   then let \\<beta>' = \\<beta>(lab \\<mapsto>\n        ba);\n      ve' = ve(map (\\<lambda>v. (v, ba)) vs [\\<mapsto>] as)\n  in b\\<cdot>(Discr (c, \\<beta>', ve', ba))\n                                   else \\<bottom>\n                               | (DP (Plus c), [], bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (Plus c), [DI a1], bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (Plus c), [DI a1, DI a2],\n                                  bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (Plus c), [DI a1, DI a2, cnt], ve,\n                                  b) \\<Rightarrow>\n                                   if isProc cnt\n                                   then let b' = nb b c;\n      \\<beta> = [c \\<mapsto> b]\n  in a\\<cdot>(Discr (cnt, [DI (a1 + a2)], ve, b')) \\<union>\n     {((c, \\<beta>), cnt)}\n                                   else \\<bottom>\n                               | (DP (Plus c),\n                                  DI a1 # DI a2 # cnt # aa # lista,\n                                  bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (Plus c), DI a1 # _ # lista,\n                                  bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (Plus c), _ # list, bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (prim.If ct cf), [], bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (prim.If ct cf), [DI v],\n                                  bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (prim.If ct cf), [DI v, contt],\n                                  bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (prim.If ct cf), [DI v, contt, contf],\n                                  ve, b) \\<Rightarrow>\n                                   if isProc contt \\<and> isProc contf\n                                   then if v \\<noteq> 0\n  then let b' = nb b ct; \\<beta> = [ct \\<mapsto> b]\n       in a\\<cdot>(Discr (contt, [], ve, b')) \\<union>\n          {((ct, \\<beta>), contt)}\n  else let b' = nb b cf; \\<beta> = [cf \\<mapsto> b]\n       in a\\<cdot>(Discr (contf, [], ve, b')) \\<union>\n          {((cf, \\<beta>), contf)}\n                                   else \\<bottom>\n                               | (DP (prim.If ct cf),\n                                  DI v # contt # contf # ab # lista,\n                                  bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (prim.If ct cf), _ # list,\n                                  bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (Stop, [], bb) \\<Rightarrow> \\<bottom>\n                               | (Stop, [DI i], x, xa) \\<Rightarrow> {}\n                               | (Stop, DI i # a # lista, bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (Stop, _ # list, bb) \\<Rightarrow>\n                                   \\<bottom>)\\<cdot>\n                           (Discr (d, ds, ve, ba))) \\<and>\n                         (\\<forall>((lab, \\<beta>), t)\n                                   \\<in>(\\<Lambda> fstate.\n      case undiscr fstate of (DI int, ba) \\<Rightarrow> \\<bottom>\n      | (DC (Lambda lab vs c, \\<beta>), as, ve, ba) \\<Rightarrow>\n          if length vs = length as\n          then let \\<beta>' = \\<beta>(lab \\<mapsto> ba);\n                   ve' = ve(map (\\<lambda>v. (v, ba)) vs [\\<mapsto>] as)\n               in b\\<cdot>(Discr (c, \\<beta>', ve', ba))\n          else \\<bottom>\n      | (DP (Plus c), [], bb) \\<Rightarrow> \\<bottom>\n      | (DP (Plus c), [DI a1], bb) \\<Rightarrow> \\<bottom>\n      | (DP (Plus c), [DI a1, DI a2], bb) \\<Rightarrow> \\<bottom>\n      | (DP (Plus c), [DI a1, DI a2, cnt], ve, b) \\<Rightarrow>\n          if isProc cnt\n          then let b' = nb b c; \\<beta> = [c \\<mapsto> b]\n               in a\\<cdot>(Discr (cnt, [DI (a1 + a2)], ve, b')) \\<union>\n                  {((c, \\<beta>), cnt)}\n          else \\<bottom>\n      | (DP (Plus c), DI a1 # DI a2 # cnt # aa # lista, bb) \\<Rightarrow>\n          \\<bottom>\n      | (DP (Plus c), DI a1 # _ # lista, bb) \\<Rightarrow> \\<bottom>\n      | (DP (Plus c), _ # list, bb) \\<Rightarrow> \\<bottom>\n      | (DP (prim.If ct cf), [], bb) \\<Rightarrow> \\<bottom>\n      | (DP (prim.If ct cf), [DI v], bb) \\<Rightarrow> \\<bottom>\n      | (DP (prim.If ct cf), [DI v, contt], bb) \\<Rightarrow> \\<bottom>\n      | (DP (prim.If ct cf), [DI v, contt, contf], ve, b) \\<Rightarrow>\n          if isProc contt \\<and> isProc contf\n          then if v \\<noteq> 0\n               then let b' = nb b ct; \\<beta> = [ct \\<mapsto> b]\n                    in a\\<cdot>(Discr (contt, [], ve, b')) \\<union>\n                       {((ct, \\<beta>), contt)}\n               else let b' = nb b cf; \\<beta> = [cf \\<mapsto> b]\n                    in a\\<cdot>(Discr (contf, [], ve, b')) \\<union>\n                       {((cf, \\<beta>), contf)}\n          else \\<bottom>\n      | (DP (prim.If ct cf), DI v # contt # contf # ab # lista,\n         bb) \\<Rightarrow>\n          \\<bottom>\n      | (DP (prim.If ct cf), _ # list, bb) \\<Rightarrow> \\<bottom>\n      | (Stop, [], bb) \\<Rightarrow> \\<bottom>\n      | (Stop, [DI i], x, xa) \\<Rightarrow> {}\n      | (Stop, DI i # a # lista, bb) \\<Rightarrow> \\<bottom>\n      | (Stop, _ # list, bb) \\<Rightarrow> \\<bottom>)\\<cdot>\n  (Discr (d, ds, ve, ba)).\n                             \\<exists>b'.\n                                b' \\<in> ran \\<beta> \\<and> ba \\<le> b')\n 3. \\<And>a b ve ba c \\<beta>'.\n       \\<lbrakk>\\<And>d ds ve b.\n                   \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n                    \\<forall>b'\\<in>contours_in_d d. b' < b;\n                    \\<forall>d'\\<in>set ds.\n                       \\<forall>b'\\<in>contours_in_d d'. b' < b\\<rbrakk>\n                   \\<Longrightarrow> single_valued\n(a\\<cdot>(Discr (d, ds, ve, b))) \\<and>\n                                     (\\<forall>((lab, \\<beta>), t)\n         \\<in>a\\<cdot>(Discr (d, ds, ve, b)).\n   \\<exists>b'. b' \\<in> ran \\<beta> \\<and> b \\<le> b');\n        \\<And>ve ba c \\<beta>'.\n           \\<lbrakk>ba \\<in> ran \\<beta>';\n            \\<forall>b'\\<in>ran \\<beta>'. b' \\<le> ba;\n            \\<forall>b'\\<in>contours_in_ve ve. b' \\<le> ba\\<rbrakk>\n           \\<Longrightarrow> single_valued\n                              (b\\<cdot>(Discr (c, \\<beta>', ve, ba))) \\<and>\n                             (\\<forall>((lab, \\<beta>), t)\n \\<in>b\\<cdot>(Discr (c, \\<beta>', ve, ba)).\n                                 \\<exists>b'.\n                                    b' \\<in> ran \\<beta> \\<and>\n                                    ba \\<le> b');\n        ba \\<in> ran \\<beta>'; \\<forall>b'\\<in>ran \\<beta>'. b' \\<le> ba;\n        \\<forall>b'\\<in>contours_in_ve ve. b' \\<le> ba\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          ((\\<Lambda> cstate.\n                               case undiscr cstate of\n                               (App lab f vs, \\<beta>, ve, b) \\<Rightarrow>\n                                 let f' = \\<A> f \\<beta> ve;\n                                     as =\n map (\\<lambda>v. \\<A> v \\<beta> ve) vs;\n                                     b' = nb b lab\n                                 in if isProc f'\n                                    then a\\<cdot>\n   (Discr (f', as, ve, b')) \\<union>\n   {((lab, \\<beta>), f')}\n                                    else \\<bottom>\n                               | (call.Let lab ls c', \\<beta>, ve,\n                                  ba) \\<Rightarrow>\n                                   let b' = nb ba lab;\n \\<beta>' = \\<beta>(lab \\<mapsto> b');\n ve' =\n   ve ++\n   map_of (map (\\<lambda>(v, l). ((v, b'), \\<A> (L l) \\<beta>' ve)) ls)\n                                   in b\\<cdot>\n(Discr (c', \\<beta>', ve', b')))\\<cdot>\n                           (Discr (c, \\<beta>', ve, ba))) \\<and>\n                         (\\<forall>((lab, \\<beta>), t)\n                                   \\<in>(\\<Lambda> cstate.\n      case undiscr cstate of\n      (App lab f vs, \\<beta>, ve, b) \\<Rightarrow>\n        let f' = \\<A> f \\<beta> ve;\n            as = map (\\<lambda>v. \\<A> v \\<beta> ve) vs; b' = nb b lab\n        in if isProc f'\n           then a\\<cdot>(Discr (f', as, ve, b')) \\<union>\n                {((lab, \\<beta>), f')}\n           else \\<bottom>\n      | (call.Let lab ls c', \\<beta>, ve, ba) \\<Rightarrow>\n          let b' = nb ba lab; \\<beta>' = \\<beta>(lab \\<mapsto> b');\n              ve' =\n                ve ++\n                map_of\n                 (map (\\<lambda>(v, l). ((v, b'), \\<A> (L l) \\<beta>' ve))\n                   ls)\n          in b\\<cdot>(Discr (c', \\<beta>', ve', b')))\\<cdot>\n  (Discr (c, \\<beta>', ve, ba)).\n                             \\<exists>b'.\n                                b' \\<in> ran \\<beta> \\<and> ba \\<le> b')", "thus ?case"], ["proof (prove)\nusing this:\n  b \\<in> ran \\<beta>'\n  \\<forall>b'\\<in>ran \\<beta>'. b' \\<le> b\n  \\<forall>b'\\<in>contours_in_ve ve. b' \\<le> b\n\ngoal (1 subgoal):\n 1. single_valued (\\<bottom>\\<cdot>(Discr (c, \\<beta>', ve, b))) \\<and>\n    (\\<forall>a\\<in>\\<bottom>\\<cdot>(Discr (c, \\<beta>', ve, b)).\n        case a of\n        (a, b) \\<Rightarrow>\n          (case a of\n           (lab, \\<beta>) \\<Rightarrow>\n             \\<lambda>t.\n                \\<exists>b'. b' \\<in> ran \\<beta> \\<and> b \\<le> b')\n           b)", "by auto"], ["proof (state)\nthis:\n  single_valued (\\<bottom>\\<cdot>(Discr (c, \\<beta>', ve, b))) \\<and>\n  (\\<forall>a\\<in>\\<bottom>\\<cdot>(Discr (c, \\<beta>', ve, b)).\n      case a of\n      (a, b) \\<Rightarrow>\n        (case a of\n         (lab, \\<beta>) \\<Rightarrow>\n           \\<lambda>t. \\<exists>b'. b' \\<in> ran \\<beta> \\<and> b \\<le> b')\n         b)\n\ngoal (2 subgoals):\n 1. \\<And>a b d ds ve ba.\n       \\<lbrakk>\\<And>d ds ve b.\n                   \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n                    \\<forall>b'\\<in>contours_in_d d. b' < b;\n                    \\<forall>d'\\<in>set ds.\n                       \\<forall>b'\\<in>contours_in_d d'. b' < b\\<rbrakk>\n                   \\<Longrightarrow> single_valued\n(a\\<cdot>(Discr (d, ds, ve, b))) \\<and>\n                                     (\\<forall>((lab, \\<beta>), t)\n         \\<in>a\\<cdot>(Discr (d, ds, ve, b)).\n   \\<exists>b'. b' \\<in> ran \\<beta> \\<and> b \\<le> b');\n        \\<And>ve ba c \\<beta>'.\n           \\<lbrakk>ba \\<in> ran \\<beta>';\n            \\<forall>b'\\<in>ran \\<beta>'. b' \\<le> ba;\n            \\<forall>b'\\<in>contours_in_ve ve. b' \\<le> ba\\<rbrakk>\n           \\<Longrightarrow> single_valued\n                              (b\\<cdot>(Discr (c, \\<beta>', ve, ba))) \\<and>\n                             (\\<forall>((lab, \\<beta>), t)\n \\<in>b\\<cdot>(Discr (c, \\<beta>', ve, ba)).\n                                 \\<exists>b'.\n                                    b' \\<in> ran \\<beta> \\<and>\n                                    ba \\<le> b');\n        \\<forall>b'\\<in>contours_in_ve ve. b' < ba;\n        \\<forall>b'\\<in>contours_in_d d. b' < ba;\n        \\<forall>d'\\<in>set ds.\n           \\<forall>b'\\<in>contours_in_d d'. b' < ba\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          ((\\<Lambda> fstate.\n                               case undiscr fstate of\n                               (DI int, ba) \\<Rightarrow> \\<bottom>\n                               | (DC (Lambda lab vs c, \\<beta>), as, ve,\n                                  ba) \\<Rightarrow>\n                                   if length vs = length as\n                                   then let \\<beta>' = \\<beta>(lab \\<mapsto>\n        ba);\n      ve' = ve(map (\\<lambda>v. (v, ba)) vs [\\<mapsto>] as)\n  in b\\<cdot>(Discr (c, \\<beta>', ve', ba))\n                                   else \\<bottom>\n                               | (DP (Plus c), [], bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (Plus c), [DI a1], bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (Plus c), [DI a1, DI a2],\n                                  bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (Plus c), [DI a1, DI a2, cnt], ve,\n                                  b) \\<Rightarrow>\n                                   if isProc cnt\n                                   then let b' = nb b c;\n      \\<beta> = [c \\<mapsto> b]\n  in a\\<cdot>(Discr (cnt, [DI (a1 + a2)], ve, b')) \\<union>\n     {((c, \\<beta>), cnt)}\n                                   else \\<bottom>\n                               | (DP (Plus c),\n                                  DI a1 # DI a2 # cnt # aa # lista,\n                                  bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (Plus c), DI a1 # _ # lista,\n                                  bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (Plus c), _ # list, bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (prim.If ct cf), [], bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (prim.If ct cf), [DI v],\n                                  bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (prim.If ct cf), [DI v, contt],\n                                  bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (prim.If ct cf), [DI v, contt, contf],\n                                  ve, b) \\<Rightarrow>\n                                   if isProc contt \\<and> isProc contf\n                                   then if v \\<noteq> 0\n  then let b' = nb b ct; \\<beta> = [ct \\<mapsto> b]\n       in a\\<cdot>(Discr (contt, [], ve, b')) \\<union>\n          {((ct, \\<beta>), contt)}\n  else let b' = nb b cf; \\<beta> = [cf \\<mapsto> b]\n       in a\\<cdot>(Discr (contf, [], ve, b')) \\<union>\n          {((cf, \\<beta>), contf)}\n                                   else \\<bottom>\n                               | (DP (prim.If ct cf),\n                                  DI v # contt # contf # ab # lista,\n                                  bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (prim.If ct cf), _ # list,\n                                  bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (Stop, [], bb) \\<Rightarrow> \\<bottom>\n                               | (Stop, [DI i], x, xa) \\<Rightarrow> {}\n                               | (Stop, DI i # a # lista, bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (Stop, _ # list, bb) \\<Rightarrow>\n                                   \\<bottom>)\\<cdot>\n                           (Discr (d, ds, ve, ba))) \\<and>\n                         (\\<forall>((lab, \\<beta>), t)\n                                   \\<in>(\\<Lambda> fstate.\n      case undiscr fstate of (DI int, ba) \\<Rightarrow> \\<bottom>\n      | (DC (Lambda lab vs c, \\<beta>), as, ve, ba) \\<Rightarrow>\n          if length vs = length as\n          then let \\<beta>' = \\<beta>(lab \\<mapsto> ba);\n                   ve' = ve(map (\\<lambda>v. (v, ba)) vs [\\<mapsto>] as)\n               in b\\<cdot>(Discr (c, \\<beta>', ve', ba))\n          else \\<bottom>\n      | (DP (Plus c), [], bb) \\<Rightarrow> \\<bottom>\n      | (DP (Plus c), [DI a1], bb) \\<Rightarrow> \\<bottom>\n      | (DP (Plus c), [DI a1, DI a2], bb) \\<Rightarrow> \\<bottom>\n      | (DP (Plus c), [DI a1, DI a2, cnt], ve, b) \\<Rightarrow>\n          if isProc cnt\n          then let b' = nb b c; \\<beta> = [c \\<mapsto> b]\n               in a\\<cdot>(Discr (cnt, [DI (a1 + a2)], ve, b')) \\<union>\n                  {((c, \\<beta>), cnt)}\n          else \\<bottom>\n      | (DP (Plus c), DI a1 # DI a2 # cnt # aa # lista, bb) \\<Rightarrow>\n          \\<bottom>\n      | (DP (Plus c), DI a1 # _ # lista, bb) \\<Rightarrow> \\<bottom>\n      | (DP (Plus c), _ # list, bb) \\<Rightarrow> \\<bottom>\n      | (DP (prim.If ct cf), [], bb) \\<Rightarrow> \\<bottom>\n      | (DP (prim.If ct cf), [DI v], bb) \\<Rightarrow> \\<bottom>\n      | (DP (prim.If ct cf), [DI v, contt], bb) \\<Rightarrow> \\<bottom>\n      | (DP (prim.If ct cf), [DI v, contt, contf], ve, b) \\<Rightarrow>\n          if isProc contt \\<and> isProc contf\n          then if v \\<noteq> 0\n               then let b' = nb b ct; \\<beta> = [ct \\<mapsto> b]\n                    in a\\<cdot>(Discr (contt, [], ve, b')) \\<union>\n                       {((ct, \\<beta>), contt)}\n               else let b' = nb b cf; \\<beta> = [cf \\<mapsto> b]\n                    in a\\<cdot>(Discr (contf, [], ve, b')) \\<union>\n                       {((cf, \\<beta>), contf)}\n          else \\<bottom>\n      | (DP (prim.If ct cf), DI v # contt # contf # ab # lista,\n         bb) \\<Rightarrow>\n          \\<bottom>\n      | (DP (prim.If ct cf), _ # list, bb) \\<Rightarrow> \\<bottom>\n      | (Stop, [], bb) \\<Rightarrow> \\<bottom>\n      | (Stop, [DI i], x, xa) \\<Rightarrow> {}\n      | (Stop, DI i # a # lista, bb) \\<Rightarrow> \\<bottom>\n      | (Stop, _ # list, bb) \\<Rightarrow> \\<bottom>)\\<cdot>\n  (Discr (d, ds, ve, ba)).\n                             \\<exists>b'.\n                                b' \\<in> ran \\<beta> \\<and> ba \\<le> b')\n 2. \\<And>a b ve ba c \\<beta>'.\n       \\<lbrakk>\\<And>d ds ve b.\n                   \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n                    \\<forall>b'\\<in>contours_in_d d. b' < b;\n                    \\<forall>d'\\<in>set ds.\n                       \\<forall>b'\\<in>contours_in_d d'. b' < b\\<rbrakk>\n                   \\<Longrightarrow> single_valued\n(a\\<cdot>(Discr (d, ds, ve, b))) \\<and>\n                                     (\\<forall>((lab, \\<beta>), t)\n         \\<in>a\\<cdot>(Discr (d, ds, ve, b)).\n   \\<exists>b'. b' \\<in> ran \\<beta> \\<and> b \\<le> b');\n        \\<And>ve ba c \\<beta>'.\n           \\<lbrakk>ba \\<in> ran \\<beta>';\n            \\<forall>b'\\<in>ran \\<beta>'. b' \\<le> ba;\n            \\<forall>b'\\<in>contours_in_ve ve. b' \\<le> ba\\<rbrakk>\n           \\<Longrightarrow> single_valued\n                              (b\\<cdot>(Discr (c, \\<beta>', ve, ba))) \\<and>\n                             (\\<forall>((lab, \\<beta>), t)\n \\<in>b\\<cdot>(Discr (c, \\<beta>', ve, ba)).\n                                 \\<exists>b'.\n                                    b' \\<in> ran \\<beta> \\<and>\n                                    ba \\<le> b');\n        ba \\<in> ran \\<beta>'; \\<forall>b'\\<in>ran \\<beta>'. b' \\<le> ba;\n        \\<forall>b'\\<in>contours_in_ve ve. b' \\<le> ba\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          ((\\<Lambda> cstate.\n                               case undiscr cstate of\n                               (App lab f vs, \\<beta>, ve, b) \\<Rightarrow>\n                                 let f' = \\<A> f \\<beta> ve;\n                                     as =\n map (\\<lambda>v. \\<A> v \\<beta> ve) vs;\n                                     b' = nb b lab\n                                 in if isProc f'\n                                    then a\\<cdot>\n   (Discr (f', as, ve, b')) \\<union>\n   {((lab, \\<beta>), f')}\n                                    else \\<bottom>\n                               | (call.Let lab ls c', \\<beta>, ve,\n                                  ba) \\<Rightarrow>\n                                   let b' = nb ba lab;\n \\<beta>' = \\<beta>(lab \\<mapsto> b');\n ve' =\n   ve ++\n   map_of (map (\\<lambda>(v, l). ((v, b'), \\<A> (L l) \\<beta>' ve)) ls)\n                                   in b\\<cdot>\n(Discr (c', \\<beta>', ve', b')))\\<cdot>\n                           (Discr (c, \\<beta>', ve, ba))) \\<and>\n                         (\\<forall>((lab, \\<beta>), t)\n                                   \\<in>(\\<Lambda> cstate.\n      case undiscr cstate of\n      (App lab f vs, \\<beta>, ve, b) \\<Rightarrow>\n        let f' = \\<A> f \\<beta> ve;\n            as = map (\\<lambda>v. \\<A> v \\<beta> ve) vs; b' = nb b lab\n        in if isProc f'\n           then a\\<cdot>(Discr (f', as, ve, b')) \\<union>\n                {((lab, \\<beta>), f')}\n           else \\<bottom>\n      | (call.Let lab ls c', \\<beta>, ve, ba) \\<Rightarrow>\n          let b' = nb ba lab; \\<beta>' = \\<beta>(lab \\<mapsto> b');\n              ve' =\n                ve ++\n                map_of\n                 (map (\\<lambda>(v, l). ((v, b'), \\<A> (L l) \\<beta>' ve))\n                   ls)\n          in b\\<cdot>(Discr (c', \\<beta>', ve', b')))\\<cdot>\n  (Discr (c, \\<beta>', ve, ba)).\n                             \\<exists>b'.\n                                b' \\<in> ran \\<beta> \\<and> ba \\<le> b')", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?ba2 \\<in> ran ?\\<beta>''2;\n   \\<forall>b'\\<in>ran ?\\<beta>''2. b' \\<le> ?ba2;\n   \\<forall>b'\\<in>contours_in_ve ?vea2. b' \\<le> ?ba2\\<rbrakk>\n  \\<Longrightarrow> single_valued\n                     (\\<bottom>\\<cdot>\n                      (Discr (?ca2, ?\\<beta>''2, ?vea2, ?ba2))) \\<and>\n                    (\\<forall>a\\<in>\\<bottom>\\<cdot>\n                                    (Discr\n(?ca2, ?\\<beta>''2, ?vea2, ?ba2)).\n                        case a of\n                        (a, b) \\<Rightarrow>\n                          (case a of\n                           (lab, \\<beta>) \\<Rightarrow>\n                             \\<lambda>t.\n                                \\<exists>b'.\n                                   b' \\<in> ran \\<beta> \\<and>\n                                   ?ba2 \\<le> b')\n                           b)\n\ngoal (2 subgoals):\n 1. \\<And>a b d ds ve ba.\n       \\<lbrakk>\\<And>d ds ve b.\n                   \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n                    \\<forall>b'\\<in>contours_in_d d. b' < b;\n                    \\<forall>d'\\<in>set ds.\n                       \\<forall>b'\\<in>contours_in_d d'. b' < b\\<rbrakk>\n                   \\<Longrightarrow> single_valued\n(a\\<cdot>(Discr (d, ds, ve, b))) \\<and>\n                                     (\\<forall>((lab, \\<beta>), t)\n         \\<in>a\\<cdot>(Discr (d, ds, ve, b)).\n   \\<exists>b'. b' \\<in> ran \\<beta> \\<and> b \\<le> b');\n        \\<And>ve ba c \\<beta>'.\n           \\<lbrakk>ba \\<in> ran \\<beta>';\n            \\<forall>b'\\<in>ran \\<beta>'. b' \\<le> ba;\n            \\<forall>b'\\<in>contours_in_ve ve. b' \\<le> ba\\<rbrakk>\n           \\<Longrightarrow> single_valued\n                              (b\\<cdot>(Discr (c, \\<beta>', ve, ba))) \\<and>\n                             (\\<forall>((lab, \\<beta>), t)\n \\<in>b\\<cdot>(Discr (c, \\<beta>', ve, ba)).\n                                 \\<exists>b'.\n                                    b' \\<in> ran \\<beta> \\<and>\n                                    ba \\<le> b');\n        \\<forall>b'\\<in>contours_in_ve ve. b' < ba;\n        \\<forall>b'\\<in>contours_in_d d. b' < ba;\n        \\<forall>d'\\<in>set ds.\n           \\<forall>b'\\<in>contours_in_d d'. b' < ba\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          ((\\<Lambda> fstate.\n                               case undiscr fstate of\n                               (DI int, ba) \\<Rightarrow> \\<bottom>\n                               | (DC (Lambda lab vs c, \\<beta>), as, ve,\n                                  ba) \\<Rightarrow>\n                                   if length vs = length as\n                                   then let \\<beta>' = \\<beta>(lab \\<mapsto>\n        ba);\n      ve' = ve(map (\\<lambda>v. (v, ba)) vs [\\<mapsto>] as)\n  in b\\<cdot>(Discr (c, \\<beta>', ve', ba))\n                                   else \\<bottom>\n                               | (DP (Plus c), [], bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (Plus c), [DI a1], bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (Plus c), [DI a1, DI a2],\n                                  bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (Plus c), [DI a1, DI a2, cnt], ve,\n                                  b) \\<Rightarrow>\n                                   if isProc cnt\n                                   then let b' = nb b c;\n      \\<beta> = [c \\<mapsto> b]\n  in a\\<cdot>(Discr (cnt, [DI (a1 + a2)], ve, b')) \\<union>\n     {((c, \\<beta>), cnt)}\n                                   else \\<bottom>\n                               | (DP (Plus c),\n                                  DI a1 # DI a2 # cnt # aa # lista,\n                                  bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (Plus c), DI a1 # _ # lista,\n                                  bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (Plus c), _ # list, bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (prim.If ct cf), [], bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (prim.If ct cf), [DI v],\n                                  bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (prim.If ct cf), [DI v, contt],\n                                  bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (prim.If ct cf), [DI v, contt, contf],\n                                  ve, b) \\<Rightarrow>\n                                   if isProc contt \\<and> isProc contf\n                                   then if v \\<noteq> 0\n  then let b' = nb b ct; \\<beta> = [ct \\<mapsto> b]\n       in a\\<cdot>(Discr (contt, [], ve, b')) \\<union>\n          {((ct, \\<beta>), contt)}\n  else let b' = nb b cf; \\<beta> = [cf \\<mapsto> b]\n       in a\\<cdot>(Discr (contf, [], ve, b')) \\<union>\n          {((cf, \\<beta>), contf)}\n                                   else \\<bottom>\n                               | (DP (prim.If ct cf),\n                                  DI v # contt # contf # ab # lista,\n                                  bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (prim.If ct cf), _ # list,\n                                  bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (Stop, [], bb) \\<Rightarrow> \\<bottom>\n                               | (Stop, [DI i], x, xa) \\<Rightarrow> {}\n                               | (Stop, DI i # a # lista, bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (Stop, _ # list, bb) \\<Rightarrow>\n                                   \\<bottom>)\\<cdot>\n                           (Discr (d, ds, ve, ba))) \\<and>\n                         (\\<forall>((lab, \\<beta>), t)\n                                   \\<in>(\\<Lambda> fstate.\n      case undiscr fstate of (DI int, ba) \\<Rightarrow> \\<bottom>\n      | (DC (Lambda lab vs c, \\<beta>), as, ve, ba) \\<Rightarrow>\n          if length vs = length as\n          then let \\<beta>' = \\<beta>(lab \\<mapsto> ba);\n                   ve' = ve(map (\\<lambda>v. (v, ba)) vs [\\<mapsto>] as)\n               in b\\<cdot>(Discr (c, \\<beta>', ve', ba))\n          else \\<bottom>\n      | (DP (Plus c), [], bb) \\<Rightarrow> \\<bottom>\n      | (DP (Plus c), [DI a1], bb) \\<Rightarrow> \\<bottom>\n      | (DP (Plus c), [DI a1, DI a2], bb) \\<Rightarrow> \\<bottom>\n      | (DP (Plus c), [DI a1, DI a2, cnt], ve, b) \\<Rightarrow>\n          if isProc cnt\n          then let b' = nb b c; \\<beta> = [c \\<mapsto> b]\n               in a\\<cdot>(Discr (cnt, [DI (a1 + a2)], ve, b')) \\<union>\n                  {((c, \\<beta>), cnt)}\n          else \\<bottom>\n      | (DP (Plus c), DI a1 # DI a2 # cnt # aa # lista, bb) \\<Rightarrow>\n          \\<bottom>\n      | (DP (Plus c), DI a1 # _ # lista, bb) \\<Rightarrow> \\<bottom>\n      | (DP (Plus c), _ # list, bb) \\<Rightarrow> \\<bottom>\n      | (DP (prim.If ct cf), [], bb) \\<Rightarrow> \\<bottom>\n      | (DP (prim.If ct cf), [DI v], bb) \\<Rightarrow> \\<bottom>\n      | (DP (prim.If ct cf), [DI v, contt], bb) \\<Rightarrow> \\<bottom>\n      | (DP (prim.If ct cf), [DI v, contt, contf], ve, b) \\<Rightarrow>\n          if isProc contt \\<and> isProc contf\n          then if v \\<noteq> 0\n               then let b' = nb b ct; \\<beta> = [ct \\<mapsto> b]\n                    in a\\<cdot>(Discr (contt, [], ve, b')) \\<union>\n                       {((ct, \\<beta>), contt)}\n               else let b' = nb b cf; \\<beta> = [cf \\<mapsto> b]\n                    in a\\<cdot>(Discr (contf, [], ve, b')) \\<union>\n                       {((cf, \\<beta>), contf)}\n          else \\<bottom>\n      | (DP (prim.If ct cf), DI v # contt # contf # ab # lista,\n         bb) \\<Rightarrow>\n          \\<bottom>\n      | (DP (prim.If ct cf), _ # list, bb) \\<Rightarrow> \\<bottom>\n      | (Stop, [], bb) \\<Rightarrow> \\<bottom>\n      | (Stop, [DI i], x, xa) \\<Rightarrow> {}\n      | (Stop, DI i # a # lista, bb) \\<Rightarrow> \\<bottom>\n      | (Stop, _ # list, bb) \\<Rightarrow> \\<bottom>)\\<cdot>\n  (Discr (d, ds, ve, ba)).\n                             \\<exists>b'.\n                                b' \\<in> ran \\<beta> \\<and> ba \\<le> b')\n 2. \\<And>a b ve ba c \\<beta>'.\n       \\<lbrakk>\\<And>d ds ve b.\n                   \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n                    \\<forall>b'\\<in>contours_in_d d. b' < b;\n                    \\<forall>d'\\<in>set ds.\n                       \\<forall>b'\\<in>contours_in_d d'. b' < b\\<rbrakk>\n                   \\<Longrightarrow> single_valued\n(a\\<cdot>(Discr (d, ds, ve, b))) \\<and>\n                                     (\\<forall>((lab, \\<beta>), t)\n         \\<in>a\\<cdot>(Discr (d, ds, ve, b)).\n   \\<exists>b'. b' \\<in> ran \\<beta> \\<and> b \\<le> b');\n        \\<And>ve ba c \\<beta>'.\n           \\<lbrakk>ba \\<in> ran \\<beta>';\n            \\<forall>b'\\<in>ran \\<beta>'. b' \\<le> ba;\n            \\<forall>b'\\<in>contours_in_ve ve. b' \\<le> ba\\<rbrakk>\n           \\<Longrightarrow> single_valued\n                              (b\\<cdot>(Discr (c, \\<beta>', ve, ba))) \\<and>\n                             (\\<forall>((lab, \\<beta>), t)\n \\<in>b\\<cdot>(Discr (c, \\<beta>', ve, ba)).\n                                 \\<exists>b'.\n                                    b' \\<in> ran \\<beta> \\<and>\n                                    ba \\<le> b');\n        ba \\<in> ran \\<beta>'; \\<forall>b'\\<in>ran \\<beta>'. b' \\<le> ba;\n        \\<forall>b'\\<in>contours_in_ve ve. b' \\<le> ba\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          ((\\<Lambda> cstate.\n                               case undiscr cstate of\n                               (App lab f vs, \\<beta>, ve, b) \\<Rightarrow>\n                                 let f' = \\<A> f \\<beta> ve;\n                                     as =\n map (\\<lambda>v. \\<A> v \\<beta> ve) vs;\n                                     b' = nb b lab\n                                 in if isProc f'\n                                    then a\\<cdot>\n   (Discr (f', as, ve, b')) \\<union>\n   {((lab, \\<beta>), f')}\n                                    else \\<bottom>\n                               | (call.Let lab ls c', \\<beta>, ve,\n                                  ba) \\<Rightarrow>\n                                   let b' = nb ba lab;\n \\<beta>' = \\<beta>(lab \\<mapsto> b');\n ve' =\n   ve ++\n   map_of (map (\\<lambda>(v, l). ((v, b'), \\<A> (L l) \\<beta>' ve)) ls)\n                                   in b\\<cdot>\n(Discr (c', \\<beta>', ve', b')))\\<cdot>\n                           (Discr (c, \\<beta>', ve, ba))) \\<and>\n                         (\\<forall>((lab, \\<beta>), t)\n                                   \\<in>(\\<Lambda> cstate.\n      case undiscr cstate of\n      (App lab f vs, \\<beta>, ve, b) \\<Rightarrow>\n        let f' = \\<A> f \\<beta> ve;\n            as = map (\\<lambda>v. \\<A> v \\<beta> ve) vs; b' = nb b lab\n        in if isProc f'\n           then a\\<cdot>(Discr (f', as, ve, b')) \\<union>\n                {((lab, \\<beta>), f')}\n           else \\<bottom>\n      | (call.Let lab ls c', \\<beta>, ve, ba) \\<Rightarrow>\n          let b' = nb ba lab; \\<beta>' = \\<beta>(lab \\<mapsto> b');\n              ve' =\n                ve ++\n                map_of\n                 (map (\\<lambda>(v, l). ((v, b'), \\<A> (L l) \\<beta>' ve))\n                   ls)\n          in b\\<cdot>(Discr (c', \\<beta>', ve', b')))\\<cdot>\n  (Discr (c, \\<beta>', ve, ba)).\n                             \\<exists>b'.\n                                b' \\<in> ran \\<beta> \\<and> ba \\<le> b')", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a b d ds ve ba.\n       \\<lbrakk>\\<And>d ds ve b.\n                   \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n                    \\<forall>b'\\<in>contours_in_d d. b' < b;\n                    \\<forall>d'\\<in>set ds.\n                       \\<forall>b'\\<in>contours_in_d d'. b' < b\\<rbrakk>\n                   \\<Longrightarrow> single_valued\n(a\\<cdot>(Discr (d, ds, ve, b))) \\<and>\n                                     (\\<forall>((lab, \\<beta>), t)\n         \\<in>a\\<cdot>(Discr (d, ds, ve, b)).\n   \\<exists>b'. b' \\<in> ran \\<beta> \\<and> b \\<le> b');\n        \\<And>ve ba c \\<beta>'.\n           \\<lbrakk>ba \\<in> ran \\<beta>';\n            \\<forall>b'\\<in>ran \\<beta>'. b' \\<le> ba;\n            \\<forall>b'\\<in>contours_in_ve ve. b' \\<le> ba\\<rbrakk>\n           \\<Longrightarrow> single_valued\n                              (b\\<cdot>(Discr (c, \\<beta>', ve, ba))) \\<and>\n                             (\\<forall>((lab, \\<beta>), t)\n \\<in>b\\<cdot>(Discr (c, \\<beta>', ve, ba)).\n                                 \\<exists>b'.\n                                    b' \\<in> ran \\<beta> \\<and>\n                                    ba \\<le> b');\n        \\<forall>b'\\<in>contours_in_ve ve. b' < ba;\n        \\<forall>b'\\<in>contours_in_d d. b' < ba;\n        \\<forall>d'\\<in>set ds.\n           \\<forall>b'\\<in>contours_in_d d'. b' < ba\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          ((\\<Lambda> fstate.\n                               case undiscr fstate of\n                               (DI int, ba) \\<Rightarrow> \\<bottom>\n                               | (DC (Lambda lab vs c, \\<beta>), as, ve,\n                                  ba) \\<Rightarrow>\n                                   if length vs = length as\n                                   then let \\<beta>' = \\<beta>(lab \\<mapsto>\n        ba);\n      ve' = ve(map (\\<lambda>v. (v, ba)) vs [\\<mapsto>] as)\n  in b\\<cdot>(Discr (c, \\<beta>', ve', ba))\n                                   else \\<bottom>\n                               | (DP (Plus c), [], bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (Plus c), [DI a1], bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (Plus c), [DI a1, DI a2],\n                                  bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (Plus c), [DI a1, DI a2, cnt], ve,\n                                  b) \\<Rightarrow>\n                                   if isProc cnt\n                                   then let b' = nb b c;\n      \\<beta> = [c \\<mapsto> b]\n  in a\\<cdot>(Discr (cnt, [DI (a1 + a2)], ve, b')) \\<union>\n     {((c, \\<beta>), cnt)}\n                                   else \\<bottom>\n                               | (DP (Plus c),\n                                  DI a1 # DI a2 # cnt # aa # lista,\n                                  bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (Plus c), DI a1 # _ # lista,\n                                  bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (Plus c), _ # list, bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (prim.If ct cf), [], bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (prim.If ct cf), [DI v],\n                                  bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (prim.If ct cf), [DI v, contt],\n                                  bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (prim.If ct cf), [DI v, contt, contf],\n                                  ve, b) \\<Rightarrow>\n                                   if isProc contt \\<and> isProc contf\n                                   then if v \\<noteq> 0\n  then let b' = nb b ct; \\<beta> = [ct \\<mapsto> b]\n       in a\\<cdot>(Discr (contt, [], ve, b')) \\<union>\n          {((ct, \\<beta>), contt)}\n  else let b' = nb b cf; \\<beta> = [cf \\<mapsto> b]\n       in a\\<cdot>(Discr (contf, [], ve, b')) \\<union>\n          {((cf, \\<beta>), contf)}\n                                   else \\<bottom>\n                               | (DP (prim.If ct cf),\n                                  DI v # contt # contf # ab # lista,\n                                  bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (prim.If ct cf), _ # list,\n                                  bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (Stop, [], bb) \\<Rightarrow> \\<bottom>\n                               | (Stop, [DI i], x, xa) \\<Rightarrow> {}\n                               | (Stop, DI i # a # lista, bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (Stop, _ # list, bb) \\<Rightarrow>\n                                   \\<bottom>)\\<cdot>\n                           (Discr (d, ds, ve, ba))) \\<and>\n                         (\\<forall>((lab, \\<beta>), t)\n                                   \\<in>(\\<Lambda> fstate.\n      case undiscr fstate of (DI int, ba) \\<Rightarrow> \\<bottom>\n      | (DC (Lambda lab vs c, \\<beta>), as, ve, ba) \\<Rightarrow>\n          if length vs = length as\n          then let \\<beta>' = \\<beta>(lab \\<mapsto> ba);\n                   ve' = ve(map (\\<lambda>v. (v, ba)) vs [\\<mapsto>] as)\n               in b\\<cdot>(Discr (c, \\<beta>', ve', ba))\n          else \\<bottom>\n      | (DP (Plus c), [], bb) \\<Rightarrow> \\<bottom>\n      | (DP (Plus c), [DI a1], bb) \\<Rightarrow> \\<bottom>\n      | (DP (Plus c), [DI a1, DI a2], bb) \\<Rightarrow> \\<bottom>\n      | (DP (Plus c), [DI a1, DI a2, cnt], ve, b) \\<Rightarrow>\n          if isProc cnt\n          then let b' = nb b c; \\<beta> = [c \\<mapsto> b]\n               in a\\<cdot>(Discr (cnt, [DI (a1 + a2)], ve, b')) \\<union>\n                  {((c, \\<beta>), cnt)}\n          else \\<bottom>\n      | (DP (Plus c), DI a1 # DI a2 # cnt # aa # lista, bb) \\<Rightarrow>\n          \\<bottom>\n      | (DP (Plus c), DI a1 # _ # lista, bb) \\<Rightarrow> \\<bottom>\n      | (DP (Plus c), _ # list, bb) \\<Rightarrow> \\<bottom>\n      | (DP (prim.If ct cf), [], bb) \\<Rightarrow> \\<bottom>\n      | (DP (prim.If ct cf), [DI v], bb) \\<Rightarrow> \\<bottom>\n      | (DP (prim.If ct cf), [DI v, contt], bb) \\<Rightarrow> \\<bottom>\n      | (DP (prim.If ct cf), [DI v, contt, contf], ve, b) \\<Rightarrow>\n          if isProc contt \\<and> isProc contf\n          then if v \\<noteq> 0\n               then let b' = nb b ct; \\<beta> = [ct \\<mapsto> b]\n                    in a\\<cdot>(Discr (contt, [], ve, b')) \\<union>\n                       {((ct, \\<beta>), contt)}\n               else let b' = nb b cf; \\<beta> = [cf \\<mapsto> b]\n                    in a\\<cdot>(Discr (contf, [], ve, b')) \\<union>\n                       {((cf, \\<beta>), contf)}\n          else \\<bottom>\n      | (DP (prim.If ct cf), DI v # contt # contf # ab # lista,\n         bb) \\<Rightarrow>\n          \\<bottom>\n      | (DP (prim.If ct cf), _ # list, bb) \\<Rightarrow> \\<bottom>\n      | (Stop, [], bb) \\<Rightarrow> \\<bottom>\n      | (Stop, [DI i], x, xa) \\<Rightarrow> {}\n      | (Stop, DI i # a # lista, bb) \\<Rightarrow> \\<bottom>\n      | (Stop, _ # list, bb) \\<Rightarrow> \\<bottom>)\\<cdot>\n  (Discr (d, ds, ve, ba)).\n                             \\<exists>b'.\n                                b' \\<in> ran \\<beta> \\<and> ba \\<le> b')\n 2. \\<And>a b ve ba c \\<beta>'.\n       \\<lbrakk>\\<And>d ds ve b.\n                   \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n                    \\<forall>b'\\<in>contours_in_d d. b' < b;\n                    \\<forall>d'\\<in>set ds.\n                       \\<forall>b'\\<in>contours_in_d d'. b' < b\\<rbrakk>\n                   \\<Longrightarrow> single_valued\n(a\\<cdot>(Discr (d, ds, ve, b))) \\<and>\n                                     (\\<forall>((lab, \\<beta>), t)\n         \\<in>a\\<cdot>(Discr (d, ds, ve, b)).\n   \\<exists>b'. b' \\<in> ran \\<beta> \\<and> b \\<le> b');\n        \\<And>ve ba c \\<beta>'.\n           \\<lbrakk>ba \\<in> ran \\<beta>';\n            \\<forall>b'\\<in>ran \\<beta>'. b' \\<le> ba;\n            \\<forall>b'\\<in>contours_in_ve ve. b' \\<le> ba\\<rbrakk>\n           \\<Longrightarrow> single_valued\n                              (b\\<cdot>(Discr (c, \\<beta>', ve, ba))) \\<and>\n                             (\\<forall>((lab, \\<beta>), t)\n \\<in>b\\<cdot>(Discr (c, \\<beta>', ve, ba)).\n                                 \\<exists>b'.\n                                    b' \\<in> ran \\<beta> \\<and>\n                                    ba \\<le> b');\n        ba \\<in> ran \\<beta>'; \\<forall>b'\\<in>ran \\<beta>'. b' \\<le> ba;\n        \\<forall>b'\\<in>contours_in_ve ve. b' \\<le> ba\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          ((\\<Lambda> cstate.\n                               case undiscr cstate of\n                               (App lab f vs, \\<beta>, ve, b) \\<Rightarrow>\n                                 let f' = \\<A> f \\<beta> ve;\n                                     as =\n map (\\<lambda>v. \\<A> v \\<beta> ve) vs;\n                                     b' = nb b lab\n                                 in if isProc f'\n                                    then a\\<cdot>\n   (Discr (f', as, ve, b')) \\<union>\n   {((lab, \\<beta>), f')}\n                                    else \\<bottom>\n                               | (call.Let lab ls c', \\<beta>, ve,\n                                  ba) \\<Rightarrow>\n                                   let b' = nb ba lab;\n \\<beta>' = \\<beta>(lab \\<mapsto> b');\n ve' =\n   ve ++\n   map_of (map (\\<lambda>(v, l). ((v, b'), \\<A> (L l) \\<beta>' ve)) ls)\n                                   in b\\<cdot>\n(Discr (c', \\<beta>', ve', b')))\\<cdot>\n                           (Discr (c, \\<beta>', ve, ba))) \\<and>\n                         (\\<forall>((lab, \\<beta>), t)\n                                   \\<in>(\\<Lambda> cstate.\n      case undiscr cstate of\n      (App lab f vs, \\<beta>, ve, b) \\<Rightarrow>\n        let f' = \\<A> f \\<beta> ve;\n            as = map (\\<lambda>v. \\<A> v \\<beta> ve) vs; b' = nb b lab\n        in if isProc f'\n           then a\\<cdot>(Discr (f', as, ve, b')) \\<union>\n                {((lab, \\<beta>), f')}\n           else \\<bottom>\n      | (call.Let lab ls c', \\<beta>, ve, ba) \\<Rightarrow>\n          let b' = nb ba lab; \\<beta>' = \\<beta>(lab \\<mapsto> b');\n              ve' =\n                ve ++\n                map_of\n                 (map (\\<lambda>(v, l). ((v, b'), \\<A> (L l) \\<beta>' ve))\n                   ls)\n          in b\\<cdot>(Discr (c', \\<beta>', ve', b')))\\<cdot>\n  (Discr (c, \\<beta>', ve, ba)).\n                             \\<exists>b'.\n                                b' \\<in> ran \\<beta> \\<and> ba \\<le> b')", "case (Next evalF evalC)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ?ve. b' < ?b;\n   \\<forall>b'\\<in>contours_in_d ?d. b' < ?b;\n   \\<forall>d'\\<in>set ?ds.\n      \\<forall>b'\\<in>contours_in_d d'. b' < ?b\\<rbrakk>\n  \\<Longrightarrow> single_valued\n                     (evalF\\<cdot>(Discr (?d, ?ds, ?ve, ?b))) \\<and>\n                    (\\<forall>a\\<in>evalF\\<cdot>(Discr (?d, ?ds, ?ve, ?b)).\n                        case a of\n                        (a, b) \\<Rightarrow>\n                          (case a of\n                           (lab, \\<beta>) \\<Rightarrow>\n                             \\<lambda>t.\n                                \\<exists>b'.\n                                   b' \\<in> ran \\<beta> \\<and> ?b \\<le> b')\n                           b)\n  \\<lbrakk>?b \\<in> ran ?\\<beta>';\n   \\<forall>b'\\<in>ran ?\\<beta>'. b' \\<le> ?b;\n   \\<forall>b'\\<in>contours_in_ve ?ve. b' \\<le> ?b\\<rbrakk>\n  \\<Longrightarrow> single_valued\n                     (evalC\\<cdot>(Discr (?c, ?\\<beta>', ?ve, ?b))) \\<and>\n                    (\\<forall>a\\<in>evalC\\<cdot>\n                                    (Discr (?c, ?\\<beta>', ?ve, ?b)).\n                        case a of\n                        (a, b) \\<Rightarrow>\n                          (case a of\n                           (lab, \\<beta>) \\<Rightarrow>\n                             \\<lambda>t.\n                                \\<exists>b'.\n                                   b' \\<in> ran \\<beta> \\<and> ?b \\<le> b')\n                           b)\n\ngoal (2 subgoals):\n 1. \\<And>a b d ds ve ba.\n       \\<lbrakk>\\<And>d ds ve b.\n                   \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n                    \\<forall>b'\\<in>contours_in_d d. b' < b;\n                    \\<forall>d'\\<in>set ds.\n                       \\<forall>b'\\<in>contours_in_d d'. b' < b\\<rbrakk>\n                   \\<Longrightarrow> single_valued\n(a\\<cdot>(Discr (d, ds, ve, b))) \\<and>\n                                     (\\<forall>((lab, \\<beta>), t)\n         \\<in>a\\<cdot>(Discr (d, ds, ve, b)).\n   \\<exists>b'. b' \\<in> ran \\<beta> \\<and> b \\<le> b');\n        \\<And>ve ba c \\<beta>'.\n           \\<lbrakk>ba \\<in> ran \\<beta>';\n            \\<forall>b'\\<in>ran \\<beta>'. b' \\<le> ba;\n            \\<forall>b'\\<in>contours_in_ve ve. b' \\<le> ba\\<rbrakk>\n           \\<Longrightarrow> single_valued\n                              (b\\<cdot>(Discr (c, \\<beta>', ve, ba))) \\<and>\n                             (\\<forall>((lab, \\<beta>), t)\n \\<in>b\\<cdot>(Discr (c, \\<beta>', ve, ba)).\n                                 \\<exists>b'.\n                                    b' \\<in> ran \\<beta> \\<and>\n                                    ba \\<le> b');\n        \\<forall>b'\\<in>contours_in_ve ve. b' < ba;\n        \\<forall>b'\\<in>contours_in_d d. b' < ba;\n        \\<forall>d'\\<in>set ds.\n           \\<forall>b'\\<in>contours_in_d d'. b' < ba\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          ((\\<Lambda> fstate.\n                               case undiscr fstate of\n                               (DI int, ba) \\<Rightarrow> \\<bottom>\n                               | (DC (Lambda lab vs c, \\<beta>), as, ve,\n                                  ba) \\<Rightarrow>\n                                   if length vs = length as\n                                   then let \\<beta>' = \\<beta>(lab \\<mapsto>\n        ba);\n      ve' = ve(map (\\<lambda>v. (v, ba)) vs [\\<mapsto>] as)\n  in b\\<cdot>(Discr (c, \\<beta>', ve', ba))\n                                   else \\<bottom>\n                               | (DP (Plus c), [], bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (Plus c), [DI a1], bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (Plus c), [DI a1, DI a2],\n                                  bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (Plus c), [DI a1, DI a2, cnt], ve,\n                                  b) \\<Rightarrow>\n                                   if isProc cnt\n                                   then let b' = nb b c;\n      \\<beta> = [c \\<mapsto> b]\n  in a\\<cdot>(Discr (cnt, [DI (a1 + a2)], ve, b')) \\<union>\n     {((c, \\<beta>), cnt)}\n                                   else \\<bottom>\n                               | (DP (Plus c),\n                                  DI a1 # DI a2 # cnt # aa # lista,\n                                  bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (Plus c), DI a1 # _ # lista,\n                                  bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (Plus c), _ # list, bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (prim.If ct cf), [], bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (prim.If ct cf), [DI v],\n                                  bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (prim.If ct cf), [DI v, contt],\n                                  bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (prim.If ct cf), [DI v, contt, contf],\n                                  ve, b) \\<Rightarrow>\n                                   if isProc contt \\<and> isProc contf\n                                   then if v \\<noteq> 0\n  then let b' = nb b ct; \\<beta> = [ct \\<mapsto> b]\n       in a\\<cdot>(Discr (contt, [], ve, b')) \\<union>\n          {((ct, \\<beta>), contt)}\n  else let b' = nb b cf; \\<beta> = [cf \\<mapsto> b]\n       in a\\<cdot>(Discr (contf, [], ve, b')) \\<union>\n          {((cf, \\<beta>), contf)}\n                                   else \\<bottom>\n                               | (DP (prim.If ct cf),\n                                  DI v # contt # contf # ab # lista,\n                                  bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (prim.If ct cf), _ # list,\n                                  bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (Stop, [], bb) \\<Rightarrow> \\<bottom>\n                               | (Stop, [DI i], x, xa) \\<Rightarrow> {}\n                               | (Stop, DI i # a # lista, bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (Stop, _ # list, bb) \\<Rightarrow>\n                                   \\<bottom>)\\<cdot>\n                           (Discr (d, ds, ve, ba))) \\<and>\n                         (\\<forall>((lab, \\<beta>), t)\n                                   \\<in>(\\<Lambda> fstate.\n      case undiscr fstate of (DI int, ba) \\<Rightarrow> \\<bottom>\n      | (DC (Lambda lab vs c, \\<beta>), as, ve, ba) \\<Rightarrow>\n          if length vs = length as\n          then let \\<beta>' = \\<beta>(lab \\<mapsto> ba);\n                   ve' = ve(map (\\<lambda>v. (v, ba)) vs [\\<mapsto>] as)\n               in b\\<cdot>(Discr (c, \\<beta>', ve', ba))\n          else \\<bottom>\n      | (DP (Plus c), [], bb) \\<Rightarrow> \\<bottom>\n      | (DP (Plus c), [DI a1], bb) \\<Rightarrow> \\<bottom>\n      | (DP (Plus c), [DI a1, DI a2], bb) \\<Rightarrow> \\<bottom>\n      | (DP (Plus c), [DI a1, DI a2, cnt], ve, b) \\<Rightarrow>\n          if isProc cnt\n          then let b' = nb b c; \\<beta> = [c \\<mapsto> b]\n               in a\\<cdot>(Discr (cnt, [DI (a1 + a2)], ve, b')) \\<union>\n                  {((c, \\<beta>), cnt)}\n          else \\<bottom>\n      | (DP (Plus c), DI a1 # DI a2 # cnt # aa # lista, bb) \\<Rightarrow>\n          \\<bottom>\n      | (DP (Plus c), DI a1 # _ # lista, bb) \\<Rightarrow> \\<bottom>\n      | (DP (Plus c), _ # list, bb) \\<Rightarrow> \\<bottom>\n      | (DP (prim.If ct cf), [], bb) \\<Rightarrow> \\<bottom>\n      | (DP (prim.If ct cf), [DI v], bb) \\<Rightarrow> \\<bottom>\n      | (DP (prim.If ct cf), [DI v, contt], bb) \\<Rightarrow> \\<bottom>\n      | (DP (prim.If ct cf), [DI v, contt, contf], ve, b) \\<Rightarrow>\n          if isProc contt \\<and> isProc contf\n          then if v \\<noteq> 0\n               then let b' = nb b ct; \\<beta> = [ct \\<mapsto> b]\n                    in a\\<cdot>(Discr (contt, [], ve, b')) \\<union>\n                       {((ct, \\<beta>), contt)}\n               else let b' = nb b cf; \\<beta> = [cf \\<mapsto> b]\n                    in a\\<cdot>(Discr (contf, [], ve, b')) \\<union>\n                       {((cf, \\<beta>), contf)}\n          else \\<bottom>\n      | (DP (prim.If ct cf), DI v # contt # contf # ab # lista,\n         bb) \\<Rightarrow>\n          \\<bottom>\n      | (DP (prim.If ct cf), _ # list, bb) \\<Rightarrow> \\<bottom>\n      | (Stop, [], bb) \\<Rightarrow> \\<bottom>\n      | (Stop, [DI i], x, xa) \\<Rightarrow> {}\n      | (Stop, DI i # a # lista, bb) \\<Rightarrow> \\<bottom>\n      | (Stop, _ # list, bb) \\<Rightarrow> \\<bottom>)\\<cdot>\n  (Discr (d, ds, ve, ba)).\n                             \\<exists>b'.\n                                b' \\<in> ran \\<beta> \\<and> ba \\<le> b')\n 2. \\<And>a b ve ba c \\<beta>'.\n       \\<lbrakk>\\<And>d ds ve b.\n                   \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n                    \\<forall>b'\\<in>contours_in_d d. b' < b;\n                    \\<forall>d'\\<in>set ds.\n                       \\<forall>b'\\<in>contours_in_d d'. b' < b\\<rbrakk>\n                   \\<Longrightarrow> single_valued\n(a\\<cdot>(Discr (d, ds, ve, b))) \\<and>\n                                     (\\<forall>((lab, \\<beta>), t)\n         \\<in>a\\<cdot>(Discr (d, ds, ve, b)).\n   \\<exists>b'. b' \\<in> ran \\<beta> \\<and> b \\<le> b');\n        \\<And>ve ba c \\<beta>'.\n           \\<lbrakk>ba \\<in> ran \\<beta>';\n            \\<forall>b'\\<in>ran \\<beta>'. b' \\<le> ba;\n            \\<forall>b'\\<in>contours_in_ve ve. b' \\<le> ba\\<rbrakk>\n           \\<Longrightarrow> single_valued\n                              (b\\<cdot>(Discr (c, \\<beta>', ve, ba))) \\<and>\n                             (\\<forall>((lab, \\<beta>), t)\n \\<in>b\\<cdot>(Discr (c, \\<beta>', ve, ba)).\n                                 \\<exists>b'.\n                                    b' \\<in> ran \\<beta> \\<and>\n                                    ba \\<le> b');\n        ba \\<in> ran \\<beta>'; \\<forall>b'\\<in>ran \\<beta>'. b' \\<le> ba;\n        \\<forall>b'\\<in>contours_in_ve ve. b' \\<le> ba\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          ((\\<Lambda> cstate.\n                               case undiscr cstate of\n                               (App lab f vs, \\<beta>, ve, b) \\<Rightarrow>\n                                 let f' = \\<A> f \\<beta> ve;\n                                     as =\n map (\\<lambda>v. \\<A> v \\<beta> ve) vs;\n                                     b' = nb b lab\n                                 in if isProc f'\n                                    then a\\<cdot>\n   (Discr (f', as, ve, b')) \\<union>\n   {((lab, \\<beta>), f')}\n                                    else \\<bottom>\n                               | (call.Let lab ls c', \\<beta>, ve,\n                                  ba) \\<Rightarrow>\n                                   let b' = nb ba lab;\n \\<beta>' = \\<beta>(lab \\<mapsto> b');\n ve' =\n   ve ++\n   map_of (map (\\<lambda>(v, l). ((v, b'), \\<A> (L l) \\<beta>' ve)) ls)\n                                   in b\\<cdot>\n(Discr (c', \\<beta>', ve', b')))\\<cdot>\n                           (Discr (c, \\<beta>', ve, ba))) \\<and>\n                         (\\<forall>((lab, \\<beta>), t)\n                                   \\<in>(\\<Lambda> cstate.\n      case undiscr cstate of\n      (App lab f vs, \\<beta>, ve, b) \\<Rightarrow>\n        let f' = \\<A> f \\<beta> ve;\n            as = map (\\<lambda>v. \\<A> v \\<beta> ve) vs; b' = nb b lab\n        in if isProc f'\n           then a\\<cdot>(Discr (f', as, ve, b')) \\<union>\n                {((lab, \\<beta>), f')}\n           else \\<bottom>\n      | (call.Let lab ls c', \\<beta>, ve, ba) \\<Rightarrow>\n          let b' = nb ba lab; \\<beta>' = \\<beta>(lab \\<mapsto> b');\n              ve' =\n                ve ++\n                map_of\n                 (map (\\<lambda>(v, l). ((v, b'), \\<A> (L l) \\<beta>' ve))\n                   ls)\n          in b\\<cdot>(Discr (c', \\<beta>', ve', b')))\\<cdot>\n  (Discr (c, \\<beta>', ve, ba)).\n                             \\<exists>b'.\n                                b' \\<in> ran \\<beta> \\<and> ba \\<le> b')", "txt \\<open>Nicer names for the hypothesises:\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ?ve. b' < ?b;\n   \\<forall>b'\\<in>contours_in_d ?d. b' < ?b;\n   \\<forall>d'\\<in>set ?ds.\n      \\<forall>b'\\<in>contours_in_d d'. b' < ?b\\<rbrakk>\n  \\<Longrightarrow> single_valued\n                     (evalF\\<cdot>(Discr (?d, ?ds, ?ve, ?b))) \\<and>\n                    (\\<forall>a\\<in>evalF\\<cdot>(Discr (?d, ?ds, ?ve, ?b)).\n                        case a of\n                        (a, b) \\<Rightarrow>\n                          (case a of\n                           (lab, \\<beta>) \\<Rightarrow>\n                             \\<lambda>t.\n                                \\<exists>b'.\n                                   b' \\<in> ran \\<beta> \\<and> ?b \\<le> b')\n                           b)\n  \\<lbrakk>?b \\<in> ran ?\\<beta>';\n   \\<forall>b'\\<in>ran ?\\<beta>'. b' \\<le> ?b;\n   \\<forall>b'\\<in>contours_in_ve ?ve. b' \\<le> ?b\\<rbrakk>\n  \\<Longrightarrow> single_valued\n                     (evalC\\<cdot>(Discr (?c, ?\\<beta>', ?ve, ?b))) \\<and>\n                    (\\<forall>a\\<in>evalC\\<cdot>\n                                    (Discr (?c, ?\\<beta>', ?ve, ?b)).\n                        case a of\n                        (a, b) \\<Rightarrow>\n                          (case a of\n                           (lab, \\<beta>) \\<Rightarrow>\n                             \\<lambda>t.\n                                \\<exists>b'.\n                                   b' \\<in> ran \\<beta> \\<and> ?b \\<le> b')\n                           b)\n\ngoal (2 subgoals):\n 1. \\<And>a b d ds ve ba.\n       \\<lbrakk>\\<And>d ds ve b.\n                   \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n                    \\<forall>b'\\<in>contours_in_d d. b' < b;\n                    \\<forall>d'\\<in>set ds.\n                       \\<forall>b'\\<in>contours_in_d d'. b' < b\\<rbrakk>\n                   \\<Longrightarrow> single_valued\n(a\\<cdot>(Discr (d, ds, ve, b))) \\<and>\n                                     (\\<forall>((lab, \\<beta>), t)\n         \\<in>a\\<cdot>(Discr (d, ds, ve, b)).\n   \\<exists>b'. b' \\<in> ran \\<beta> \\<and> b \\<le> b');\n        \\<And>ve ba c \\<beta>'.\n           \\<lbrakk>ba \\<in> ran \\<beta>';\n            \\<forall>b'\\<in>ran \\<beta>'. b' \\<le> ba;\n            \\<forall>b'\\<in>contours_in_ve ve. b' \\<le> ba\\<rbrakk>\n           \\<Longrightarrow> single_valued\n                              (b\\<cdot>(Discr (c, \\<beta>', ve, ba))) \\<and>\n                             (\\<forall>((lab, \\<beta>), t)\n \\<in>b\\<cdot>(Discr (c, \\<beta>', ve, ba)).\n                                 \\<exists>b'.\n                                    b' \\<in> ran \\<beta> \\<and>\n                                    ba \\<le> b');\n        \\<forall>b'\\<in>contours_in_ve ve. b' < ba;\n        \\<forall>b'\\<in>contours_in_d d. b' < ba;\n        \\<forall>d'\\<in>set ds.\n           \\<forall>b'\\<in>contours_in_d d'. b' < ba\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          ((\\<Lambda> fstate.\n                               case undiscr fstate of\n                               (DI int, ba) \\<Rightarrow> \\<bottom>\n                               | (DC (Lambda lab vs c, \\<beta>), as, ve,\n                                  ba) \\<Rightarrow>\n                                   if length vs = length as\n                                   then let \\<beta>' = \\<beta>(lab \\<mapsto>\n        ba);\n      ve' = ve(map (\\<lambda>v. (v, ba)) vs [\\<mapsto>] as)\n  in b\\<cdot>(Discr (c, \\<beta>', ve', ba))\n                                   else \\<bottom>\n                               | (DP (Plus c), [], bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (Plus c), [DI a1], bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (Plus c), [DI a1, DI a2],\n                                  bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (Plus c), [DI a1, DI a2, cnt], ve,\n                                  b) \\<Rightarrow>\n                                   if isProc cnt\n                                   then let b' = nb b c;\n      \\<beta> = [c \\<mapsto> b]\n  in a\\<cdot>(Discr (cnt, [DI (a1 + a2)], ve, b')) \\<union>\n     {((c, \\<beta>), cnt)}\n                                   else \\<bottom>\n                               | (DP (Plus c),\n                                  DI a1 # DI a2 # cnt # aa # lista,\n                                  bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (Plus c), DI a1 # _ # lista,\n                                  bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (Plus c), _ # list, bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (prim.If ct cf), [], bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (prim.If ct cf), [DI v],\n                                  bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (prim.If ct cf), [DI v, contt],\n                                  bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (prim.If ct cf), [DI v, contt, contf],\n                                  ve, b) \\<Rightarrow>\n                                   if isProc contt \\<and> isProc contf\n                                   then if v \\<noteq> 0\n  then let b' = nb b ct; \\<beta> = [ct \\<mapsto> b]\n       in a\\<cdot>(Discr (contt, [], ve, b')) \\<union>\n          {((ct, \\<beta>), contt)}\n  else let b' = nb b cf; \\<beta> = [cf \\<mapsto> b]\n       in a\\<cdot>(Discr (contf, [], ve, b')) \\<union>\n          {((cf, \\<beta>), contf)}\n                                   else \\<bottom>\n                               | (DP (prim.If ct cf),\n                                  DI v # contt # contf # ab # lista,\n                                  bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (prim.If ct cf), _ # list,\n                                  bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (Stop, [], bb) \\<Rightarrow> \\<bottom>\n                               | (Stop, [DI i], x, xa) \\<Rightarrow> {}\n                               | (Stop, DI i # a # lista, bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (Stop, _ # list, bb) \\<Rightarrow>\n                                   \\<bottom>)\\<cdot>\n                           (Discr (d, ds, ve, ba))) \\<and>\n                         (\\<forall>((lab, \\<beta>), t)\n                                   \\<in>(\\<Lambda> fstate.\n      case undiscr fstate of (DI int, ba) \\<Rightarrow> \\<bottom>\n      | (DC (Lambda lab vs c, \\<beta>), as, ve, ba) \\<Rightarrow>\n          if length vs = length as\n          then let \\<beta>' = \\<beta>(lab \\<mapsto> ba);\n                   ve' = ve(map (\\<lambda>v. (v, ba)) vs [\\<mapsto>] as)\n               in b\\<cdot>(Discr (c, \\<beta>', ve', ba))\n          else \\<bottom>\n      | (DP (Plus c), [], bb) \\<Rightarrow> \\<bottom>\n      | (DP (Plus c), [DI a1], bb) \\<Rightarrow> \\<bottom>\n      | (DP (Plus c), [DI a1, DI a2], bb) \\<Rightarrow> \\<bottom>\n      | (DP (Plus c), [DI a1, DI a2, cnt], ve, b) \\<Rightarrow>\n          if isProc cnt\n          then let b' = nb b c; \\<beta> = [c \\<mapsto> b]\n               in a\\<cdot>(Discr (cnt, [DI (a1 + a2)], ve, b')) \\<union>\n                  {((c, \\<beta>), cnt)}\n          else \\<bottom>\n      | (DP (Plus c), DI a1 # DI a2 # cnt # aa # lista, bb) \\<Rightarrow>\n          \\<bottom>\n      | (DP (Plus c), DI a1 # _ # lista, bb) \\<Rightarrow> \\<bottom>\n      | (DP (Plus c), _ # list, bb) \\<Rightarrow> \\<bottom>\n      | (DP (prim.If ct cf), [], bb) \\<Rightarrow> \\<bottom>\n      | (DP (prim.If ct cf), [DI v], bb) \\<Rightarrow> \\<bottom>\n      | (DP (prim.If ct cf), [DI v, contt], bb) \\<Rightarrow> \\<bottom>\n      | (DP (prim.If ct cf), [DI v, contt, contf], ve, b) \\<Rightarrow>\n          if isProc contt \\<and> isProc contf\n          then if v \\<noteq> 0\n               then let b' = nb b ct; \\<beta> = [ct \\<mapsto> b]\n                    in a\\<cdot>(Discr (contt, [], ve, b')) \\<union>\n                       {((ct, \\<beta>), contt)}\n               else let b' = nb b cf; \\<beta> = [cf \\<mapsto> b]\n                    in a\\<cdot>(Discr (contf, [], ve, b')) \\<union>\n                       {((cf, \\<beta>), contf)}\n          else \\<bottom>\n      | (DP (prim.If ct cf), DI v # contt # contf # ab # lista,\n         bb) \\<Rightarrow>\n          \\<bottom>\n      | (DP (prim.If ct cf), _ # list, bb) \\<Rightarrow> \\<bottom>\n      | (Stop, [], bb) \\<Rightarrow> \\<bottom>\n      | (Stop, [DI i], x, xa) \\<Rightarrow> {}\n      | (Stop, DI i # a # lista, bb) \\<Rightarrow> \\<bottom>\n      | (Stop, _ # list, bb) \\<Rightarrow> \\<bottom>)\\<cdot>\n  (Discr (d, ds, ve, ba)).\n                             \\<exists>b'.\n                                b' \\<in> ran \\<beta> \\<and> ba \\<le> b')\n 2. \\<And>a b ve ba c \\<beta>'.\n       \\<lbrakk>\\<And>d ds ve b.\n                   \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n                    \\<forall>b'\\<in>contours_in_d d. b' < b;\n                    \\<forall>d'\\<in>set ds.\n                       \\<forall>b'\\<in>contours_in_d d'. b' < b\\<rbrakk>\n                   \\<Longrightarrow> single_valued\n(a\\<cdot>(Discr (d, ds, ve, b))) \\<and>\n                                     (\\<forall>((lab, \\<beta>), t)\n         \\<in>a\\<cdot>(Discr (d, ds, ve, b)).\n   \\<exists>b'. b' \\<in> ran \\<beta> \\<and> b \\<le> b');\n        \\<And>ve ba c \\<beta>'.\n           \\<lbrakk>ba \\<in> ran \\<beta>';\n            \\<forall>b'\\<in>ran \\<beta>'. b' \\<le> ba;\n            \\<forall>b'\\<in>contours_in_ve ve. b' \\<le> ba\\<rbrakk>\n           \\<Longrightarrow> single_valued\n                              (b\\<cdot>(Discr (c, \\<beta>', ve, ba))) \\<and>\n                             (\\<forall>((lab, \\<beta>), t)\n \\<in>b\\<cdot>(Discr (c, \\<beta>', ve, ba)).\n                                 \\<exists>b'.\n                                    b' \\<in> ran \\<beta> \\<and>\n                                    ba \\<le> b');\n        ba \\<in> ran \\<beta>'; \\<forall>b'\\<in>ran \\<beta>'. b' \\<le> ba;\n        \\<forall>b'\\<in>contours_in_ve ve. b' \\<le> ba\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          ((\\<Lambda> cstate.\n                               case undiscr cstate of\n                               (App lab f vs, \\<beta>, ve, b) \\<Rightarrow>\n                                 let f' = \\<A> f \\<beta> ve;\n                                     as =\n map (\\<lambda>v. \\<A> v \\<beta> ve) vs;\n                                     b' = nb b lab\n                                 in if isProc f'\n                                    then a\\<cdot>\n   (Discr (f', as, ve, b')) \\<union>\n   {((lab, \\<beta>), f')}\n                                    else \\<bottom>\n                               | (call.Let lab ls c', \\<beta>, ve,\n                                  ba) \\<Rightarrow>\n                                   let b' = nb ba lab;\n \\<beta>' = \\<beta>(lab \\<mapsto> b');\n ve' =\n   ve ++\n   map_of (map (\\<lambda>(v, l). ((v, b'), \\<A> (L l) \\<beta>' ve)) ls)\n                                   in b\\<cdot>\n(Discr (c', \\<beta>', ve', b')))\\<cdot>\n                           (Discr (c, \\<beta>', ve, ba))) \\<and>\n                         (\\<forall>((lab, \\<beta>), t)\n                                   \\<in>(\\<Lambda> cstate.\n      case undiscr cstate of\n      (App lab f vs, \\<beta>, ve, b) \\<Rightarrow>\n        let f' = \\<A> f \\<beta> ve;\n            as = map (\\<lambda>v. \\<A> v \\<beta> ve) vs; b' = nb b lab\n        in if isProc f'\n           then a\\<cdot>(Discr (f', as, ve, b')) \\<union>\n                {((lab, \\<beta>), f')}\n           else \\<bottom>\n      | (call.Let lab ls c', \\<beta>, ve, ba) \\<Rightarrow>\n          let b' = nb ba lab; \\<beta>' = \\<beta>(lab \\<mapsto> b');\n              ve' =\n                ve ++\n                map_of\n                 (map (\\<lambda>(v, l). ((v, b'), \\<A> (L l) \\<beta>' ve))\n                   ls)\n          in b\\<cdot>(Discr (c', \\<beta>', ve', b')))\\<cdot>\n  (Discr (c, \\<beta>', ve, ba)).\n                             \\<exists>b'.\n                                b' \\<in> ran \\<beta> \\<and> ba \\<le> b')", "note hyps_F_sv = Next.hyps(1)[THEN conjunct1]"], ["proof (state)\nthis:\n  \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ?ve1. b' < ?b1;\n   \\<forall>b'\\<in>contours_in_d ?d1. b' < ?b1;\n   \\<forall>d'\\<in>set ?ds1.\n      \\<forall>b'\\<in>contours_in_d d'. b' < ?b1\\<rbrakk>\n  \\<Longrightarrow> single_valued\n                     (evalF\\<cdot>(Discr (?d1, ?ds1, ?ve1, ?b1)))\n\ngoal (2 subgoals):\n 1. \\<And>a b d ds ve ba.\n       \\<lbrakk>\\<And>d ds ve b.\n                   \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n                    \\<forall>b'\\<in>contours_in_d d. b' < b;\n                    \\<forall>d'\\<in>set ds.\n                       \\<forall>b'\\<in>contours_in_d d'. b' < b\\<rbrakk>\n                   \\<Longrightarrow> single_valued\n(a\\<cdot>(Discr (d, ds, ve, b))) \\<and>\n                                     (\\<forall>((lab, \\<beta>), t)\n         \\<in>a\\<cdot>(Discr (d, ds, ve, b)).\n   \\<exists>b'. b' \\<in> ran \\<beta> \\<and> b \\<le> b');\n        \\<And>ve ba c \\<beta>'.\n           \\<lbrakk>ba \\<in> ran \\<beta>';\n            \\<forall>b'\\<in>ran \\<beta>'. b' \\<le> ba;\n            \\<forall>b'\\<in>contours_in_ve ve. b' \\<le> ba\\<rbrakk>\n           \\<Longrightarrow> single_valued\n                              (b\\<cdot>(Discr (c, \\<beta>', ve, ba))) \\<and>\n                             (\\<forall>((lab, \\<beta>), t)\n \\<in>b\\<cdot>(Discr (c, \\<beta>', ve, ba)).\n                                 \\<exists>b'.\n                                    b' \\<in> ran \\<beta> \\<and>\n                                    ba \\<le> b');\n        \\<forall>b'\\<in>contours_in_ve ve. b' < ba;\n        \\<forall>b'\\<in>contours_in_d d. b' < ba;\n        \\<forall>d'\\<in>set ds.\n           \\<forall>b'\\<in>contours_in_d d'. b' < ba\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          ((\\<Lambda> fstate.\n                               case undiscr fstate of\n                               (DI int, ba) \\<Rightarrow> \\<bottom>\n                               | (DC (Lambda lab vs c, \\<beta>), as, ve,\n                                  ba) \\<Rightarrow>\n                                   if length vs = length as\n                                   then let \\<beta>' = \\<beta>(lab \\<mapsto>\n        ba);\n      ve' = ve(map (\\<lambda>v. (v, ba)) vs [\\<mapsto>] as)\n  in b\\<cdot>(Discr (c, \\<beta>', ve', ba))\n                                   else \\<bottom>\n                               | (DP (Plus c), [], bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (Plus c), [DI a1], bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (Plus c), [DI a1, DI a2],\n                                  bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (Plus c), [DI a1, DI a2, cnt], ve,\n                                  b) \\<Rightarrow>\n                                   if isProc cnt\n                                   then let b' = nb b c;\n      \\<beta> = [c \\<mapsto> b]\n  in a\\<cdot>(Discr (cnt, [DI (a1 + a2)], ve, b')) \\<union>\n     {((c, \\<beta>), cnt)}\n                                   else \\<bottom>\n                               | (DP (Plus c),\n                                  DI a1 # DI a2 # cnt # aa # lista,\n                                  bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (Plus c), DI a1 # _ # lista,\n                                  bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (Plus c), _ # list, bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (prim.If ct cf), [], bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (prim.If ct cf), [DI v],\n                                  bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (prim.If ct cf), [DI v, contt],\n                                  bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (prim.If ct cf), [DI v, contt, contf],\n                                  ve, b) \\<Rightarrow>\n                                   if isProc contt \\<and> isProc contf\n                                   then if v \\<noteq> 0\n  then let b' = nb b ct; \\<beta> = [ct \\<mapsto> b]\n       in a\\<cdot>(Discr (contt, [], ve, b')) \\<union>\n          {((ct, \\<beta>), contt)}\n  else let b' = nb b cf; \\<beta> = [cf \\<mapsto> b]\n       in a\\<cdot>(Discr (contf, [], ve, b')) \\<union>\n          {((cf, \\<beta>), contf)}\n                                   else \\<bottom>\n                               | (DP (prim.If ct cf),\n                                  DI v # contt # contf # ab # lista,\n                                  bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (prim.If ct cf), _ # list,\n                                  bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (Stop, [], bb) \\<Rightarrow> \\<bottom>\n                               | (Stop, [DI i], x, xa) \\<Rightarrow> {}\n                               | (Stop, DI i # a # lista, bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (Stop, _ # list, bb) \\<Rightarrow>\n                                   \\<bottom>)\\<cdot>\n                           (Discr (d, ds, ve, ba))) \\<and>\n                         (\\<forall>((lab, \\<beta>), t)\n                                   \\<in>(\\<Lambda> fstate.\n      case undiscr fstate of (DI int, ba) \\<Rightarrow> \\<bottom>\n      | (DC (Lambda lab vs c, \\<beta>), as, ve, ba) \\<Rightarrow>\n          if length vs = length as\n          then let \\<beta>' = \\<beta>(lab \\<mapsto> ba);\n                   ve' = ve(map (\\<lambda>v. (v, ba)) vs [\\<mapsto>] as)\n               in b\\<cdot>(Discr (c, \\<beta>', ve', ba))\n          else \\<bottom>\n      | (DP (Plus c), [], bb) \\<Rightarrow> \\<bottom>\n      | (DP (Plus c), [DI a1], bb) \\<Rightarrow> \\<bottom>\n      | (DP (Plus c), [DI a1, DI a2], bb) \\<Rightarrow> \\<bottom>\n      | (DP (Plus c), [DI a1, DI a2, cnt], ve, b) \\<Rightarrow>\n          if isProc cnt\n          then let b' = nb b c; \\<beta> = [c \\<mapsto> b]\n               in a\\<cdot>(Discr (cnt, [DI (a1 + a2)], ve, b')) \\<union>\n                  {((c, \\<beta>), cnt)}\n          else \\<bottom>\n      | (DP (Plus c), DI a1 # DI a2 # cnt # aa # lista, bb) \\<Rightarrow>\n          \\<bottom>\n      | (DP (Plus c), DI a1 # _ # lista, bb) \\<Rightarrow> \\<bottom>\n      | (DP (Plus c), _ # list, bb) \\<Rightarrow> \\<bottom>\n      | (DP (prim.If ct cf), [], bb) \\<Rightarrow> \\<bottom>\n      | (DP (prim.If ct cf), [DI v], bb) \\<Rightarrow> \\<bottom>\n      | (DP (prim.If ct cf), [DI v, contt], bb) \\<Rightarrow> \\<bottom>\n      | (DP (prim.If ct cf), [DI v, contt, contf], ve, b) \\<Rightarrow>\n          if isProc contt \\<and> isProc contf\n          then if v \\<noteq> 0\n               then let b' = nb b ct; \\<beta> = [ct \\<mapsto> b]\n                    in a\\<cdot>(Discr (contt, [], ve, b')) \\<union>\n                       {((ct, \\<beta>), contt)}\n               else let b' = nb b cf; \\<beta> = [cf \\<mapsto> b]\n                    in a\\<cdot>(Discr (contf, [], ve, b')) \\<union>\n                       {((cf, \\<beta>), contf)}\n          else \\<bottom>\n      | (DP (prim.If ct cf), DI v # contt # contf # ab # lista,\n         bb) \\<Rightarrow>\n          \\<bottom>\n      | (DP (prim.If ct cf), _ # list, bb) \\<Rightarrow> \\<bottom>\n      | (Stop, [], bb) \\<Rightarrow> \\<bottom>\n      | (Stop, [DI i], x, xa) \\<Rightarrow> {}\n      | (Stop, DI i # a # lista, bb) \\<Rightarrow> \\<bottom>\n      | (Stop, _ # list, bb) \\<Rightarrow> \\<bottom>)\\<cdot>\n  (Discr (d, ds, ve, ba)).\n                             \\<exists>b'.\n                                b' \\<in> ran \\<beta> \\<and> ba \\<le> b')\n 2. \\<And>a b ve ba c \\<beta>'.\n       \\<lbrakk>\\<And>d ds ve b.\n                   \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n                    \\<forall>b'\\<in>contours_in_d d. b' < b;\n                    \\<forall>d'\\<in>set ds.\n                       \\<forall>b'\\<in>contours_in_d d'. b' < b\\<rbrakk>\n                   \\<Longrightarrow> single_valued\n(a\\<cdot>(Discr (d, ds, ve, b))) \\<and>\n                                     (\\<forall>((lab, \\<beta>), t)\n         \\<in>a\\<cdot>(Discr (d, ds, ve, b)).\n   \\<exists>b'. b' \\<in> ran \\<beta> \\<and> b \\<le> b');\n        \\<And>ve ba c \\<beta>'.\n           \\<lbrakk>ba \\<in> ran \\<beta>';\n            \\<forall>b'\\<in>ran \\<beta>'. b' \\<le> ba;\n            \\<forall>b'\\<in>contours_in_ve ve. b' \\<le> ba\\<rbrakk>\n           \\<Longrightarrow> single_valued\n                              (b\\<cdot>(Discr (c, \\<beta>', ve, ba))) \\<and>\n                             (\\<forall>((lab, \\<beta>), t)\n \\<in>b\\<cdot>(Discr (c, \\<beta>', ve, ba)).\n                                 \\<exists>b'.\n                                    b' \\<in> ran \\<beta> \\<and>\n                                    ba \\<le> b');\n        ba \\<in> ran \\<beta>'; \\<forall>b'\\<in>ran \\<beta>'. b' \\<le> ba;\n        \\<forall>b'\\<in>contours_in_ve ve. b' \\<le> ba\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          ((\\<Lambda> cstate.\n                               case undiscr cstate of\n                               (App lab f vs, \\<beta>, ve, b) \\<Rightarrow>\n                                 let f' = \\<A> f \\<beta> ve;\n                                     as =\n map (\\<lambda>v. \\<A> v \\<beta> ve) vs;\n                                     b' = nb b lab\n                                 in if isProc f'\n                                    then a\\<cdot>\n   (Discr (f', as, ve, b')) \\<union>\n   {((lab, \\<beta>), f')}\n                                    else \\<bottom>\n                               | (call.Let lab ls c', \\<beta>, ve,\n                                  ba) \\<Rightarrow>\n                                   let b' = nb ba lab;\n \\<beta>' = \\<beta>(lab \\<mapsto> b');\n ve' =\n   ve ++\n   map_of (map (\\<lambda>(v, l). ((v, b'), \\<A> (L l) \\<beta>' ve)) ls)\n                                   in b\\<cdot>\n(Discr (c', \\<beta>', ve', b')))\\<cdot>\n                           (Discr (c, \\<beta>', ve, ba))) \\<and>\n                         (\\<forall>((lab, \\<beta>), t)\n                                   \\<in>(\\<Lambda> cstate.\n      case undiscr cstate of\n      (App lab f vs, \\<beta>, ve, b) \\<Rightarrow>\n        let f' = \\<A> f \\<beta> ve;\n            as = map (\\<lambda>v. \\<A> v \\<beta> ve) vs; b' = nb b lab\n        in if isProc f'\n           then a\\<cdot>(Discr (f', as, ve, b')) \\<union>\n                {((lab, \\<beta>), f')}\n           else \\<bottom>\n      | (call.Let lab ls c', \\<beta>, ve, ba) \\<Rightarrow>\n          let b' = nb ba lab; \\<beta>' = \\<beta>(lab \\<mapsto> b');\n              ve' =\n                ve ++\n                map_of\n                 (map (\\<lambda>(v, l). ((v, b'), \\<A> (L l) \\<beta>' ve))\n                   ls)\n          in b\\<cdot>(Discr (c', \\<beta>', ve', b')))\\<cdot>\n  (Discr (c, \\<beta>', ve, ba)).\n                             \\<exists>b'.\n                                b' \\<in> ran \\<beta> \\<and> ba \\<le> b')", "note hyps_F_b = Next.hyps(1)[THEN conjunct2, THEN bspec]"], ["proof (state)\nthis:\n  \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ?ve2. b' < ?b2;\n   \\<forall>b'\\<in>contours_in_d ?d2. b' < ?b2;\n   \\<forall>d'\\<in>set ?ds2. \\<forall>b'\\<in>contours_in_d d'. b' < ?b2;\n   ?x \\<in> evalF\\<cdot>(Discr (?d2, ?ds2, ?ve2, ?b2))\\<rbrakk>\n  \\<Longrightarrow> case ?x of\n                    (a, b) \\<Rightarrow>\n                      (case a of\n                       (lab, \\<beta>) \\<Rightarrow>\n                         \\<lambda>t.\n                            \\<exists>b'.\n                               b' \\<in> ran \\<beta> \\<and> ?b2 \\<le> b')\n                       b\n\ngoal (2 subgoals):\n 1. \\<And>a b d ds ve ba.\n       \\<lbrakk>\\<And>d ds ve b.\n                   \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n                    \\<forall>b'\\<in>contours_in_d d. b' < b;\n                    \\<forall>d'\\<in>set ds.\n                       \\<forall>b'\\<in>contours_in_d d'. b' < b\\<rbrakk>\n                   \\<Longrightarrow> single_valued\n(a\\<cdot>(Discr (d, ds, ve, b))) \\<and>\n                                     (\\<forall>((lab, \\<beta>), t)\n         \\<in>a\\<cdot>(Discr (d, ds, ve, b)).\n   \\<exists>b'. b' \\<in> ran \\<beta> \\<and> b \\<le> b');\n        \\<And>ve ba c \\<beta>'.\n           \\<lbrakk>ba \\<in> ran \\<beta>';\n            \\<forall>b'\\<in>ran \\<beta>'. b' \\<le> ba;\n            \\<forall>b'\\<in>contours_in_ve ve. b' \\<le> ba\\<rbrakk>\n           \\<Longrightarrow> single_valued\n                              (b\\<cdot>(Discr (c, \\<beta>', ve, ba))) \\<and>\n                             (\\<forall>((lab, \\<beta>), t)\n \\<in>b\\<cdot>(Discr (c, \\<beta>', ve, ba)).\n                                 \\<exists>b'.\n                                    b' \\<in> ran \\<beta> \\<and>\n                                    ba \\<le> b');\n        \\<forall>b'\\<in>contours_in_ve ve. b' < ba;\n        \\<forall>b'\\<in>contours_in_d d. b' < ba;\n        \\<forall>d'\\<in>set ds.\n           \\<forall>b'\\<in>contours_in_d d'. b' < ba\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          ((\\<Lambda> fstate.\n                               case undiscr fstate of\n                               (DI int, ba) \\<Rightarrow> \\<bottom>\n                               | (DC (Lambda lab vs c, \\<beta>), as, ve,\n                                  ba) \\<Rightarrow>\n                                   if length vs = length as\n                                   then let \\<beta>' = \\<beta>(lab \\<mapsto>\n        ba);\n      ve' = ve(map (\\<lambda>v. (v, ba)) vs [\\<mapsto>] as)\n  in b\\<cdot>(Discr (c, \\<beta>', ve', ba))\n                                   else \\<bottom>\n                               | (DP (Plus c), [], bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (Plus c), [DI a1], bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (Plus c), [DI a1, DI a2],\n                                  bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (Plus c), [DI a1, DI a2, cnt], ve,\n                                  b) \\<Rightarrow>\n                                   if isProc cnt\n                                   then let b' = nb b c;\n      \\<beta> = [c \\<mapsto> b]\n  in a\\<cdot>(Discr (cnt, [DI (a1 + a2)], ve, b')) \\<union>\n     {((c, \\<beta>), cnt)}\n                                   else \\<bottom>\n                               | (DP (Plus c),\n                                  DI a1 # DI a2 # cnt # aa # lista,\n                                  bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (Plus c), DI a1 # _ # lista,\n                                  bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (Plus c), _ # list, bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (prim.If ct cf), [], bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (prim.If ct cf), [DI v],\n                                  bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (prim.If ct cf), [DI v, contt],\n                                  bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (prim.If ct cf), [DI v, contt, contf],\n                                  ve, b) \\<Rightarrow>\n                                   if isProc contt \\<and> isProc contf\n                                   then if v \\<noteq> 0\n  then let b' = nb b ct; \\<beta> = [ct \\<mapsto> b]\n       in a\\<cdot>(Discr (contt, [], ve, b')) \\<union>\n          {((ct, \\<beta>), contt)}\n  else let b' = nb b cf; \\<beta> = [cf \\<mapsto> b]\n       in a\\<cdot>(Discr (contf, [], ve, b')) \\<union>\n          {((cf, \\<beta>), contf)}\n                                   else \\<bottom>\n                               | (DP (prim.If ct cf),\n                                  DI v # contt # contf # ab # lista,\n                                  bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (prim.If ct cf), _ # list,\n                                  bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (Stop, [], bb) \\<Rightarrow> \\<bottom>\n                               | (Stop, [DI i], x, xa) \\<Rightarrow> {}\n                               | (Stop, DI i # a # lista, bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (Stop, _ # list, bb) \\<Rightarrow>\n                                   \\<bottom>)\\<cdot>\n                           (Discr (d, ds, ve, ba))) \\<and>\n                         (\\<forall>((lab, \\<beta>), t)\n                                   \\<in>(\\<Lambda> fstate.\n      case undiscr fstate of (DI int, ba) \\<Rightarrow> \\<bottom>\n      | (DC (Lambda lab vs c, \\<beta>), as, ve, ba) \\<Rightarrow>\n          if length vs = length as\n          then let \\<beta>' = \\<beta>(lab \\<mapsto> ba);\n                   ve' = ve(map (\\<lambda>v. (v, ba)) vs [\\<mapsto>] as)\n               in b\\<cdot>(Discr (c, \\<beta>', ve', ba))\n          else \\<bottom>\n      | (DP (Plus c), [], bb) \\<Rightarrow> \\<bottom>\n      | (DP (Plus c), [DI a1], bb) \\<Rightarrow> \\<bottom>\n      | (DP (Plus c), [DI a1, DI a2], bb) \\<Rightarrow> \\<bottom>\n      | (DP (Plus c), [DI a1, DI a2, cnt], ve, b) \\<Rightarrow>\n          if isProc cnt\n          then let b' = nb b c; \\<beta> = [c \\<mapsto> b]\n               in a\\<cdot>(Discr (cnt, [DI (a1 + a2)], ve, b')) \\<union>\n                  {((c, \\<beta>), cnt)}\n          else \\<bottom>\n      | (DP (Plus c), DI a1 # DI a2 # cnt # aa # lista, bb) \\<Rightarrow>\n          \\<bottom>\n      | (DP (Plus c), DI a1 # _ # lista, bb) \\<Rightarrow> \\<bottom>\n      | (DP (Plus c), _ # list, bb) \\<Rightarrow> \\<bottom>\n      | (DP (prim.If ct cf), [], bb) \\<Rightarrow> \\<bottom>\n      | (DP (prim.If ct cf), [DI v], bb) \\<Rightarrow> \\<bottom>\n      | (DP (prim.If ct cf), [DI v, contt], bb) \\<Rightarrow> \\<bottom>\n      | (DP (prim.If ct cf), [DI v, contt, contf], ve, b) \\<Rightarrow>\n          if isProc contt \\<and> isProc contf\n          then if v \\<noteq> 0\n               then let b' = nb b ct; \\<beta> = [ct \\<mapsto> b]\n                    in a\\<cdot>(Discr (contt, [], ve, b')) \\<union>\n                       {((ct, \\<beta>), contt)}\n               else let b' = nb b cf; \\<beta> = [cf \\<mapsto> b]\n                    in a\\<cdot>(Discr (contf, [], ve, b')) \\<union>\n                       {((cf, \\<beta>), contf)}\n          else \\<bottom>\n      | (DP (prim.If ct cf), DI v # contt # contf # ab # lista,\n         bb) \\<Rightarrow>\n          \\<bottom>\n      | (DP (prim.If ct cf), _ # list, bb) \\<Rightarrow> \\<bottom>\n      | (Stop, [], bb) \\<Rightarrow> \\<bottom>\n      | (Stop, [DI i], x, xa) \\<Rightarrow> {}\n      | (Stop, DI i # a # lista, bb) \\<Rightarrow> \\<bottom>\n      | (Stop, _ # list, bb) \\<Rightarrow> \\<bottom>)\\<cdot>\n  (Discr (d, ds, ve, ba)).\n                             \\<exists>b'.\n                                b' \\<in> ran \\<beta> \\<and> ba \\<le> b')\n 2. \\<And>a b ve ba c \\<beta>'.\n       \\<lbrakk>\\<And>d ds ve b.\n                   \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n                    \\<forall>b'\\<in>contours_in_d d. b' < b;\n                    \\<forall>d'\\<in>set ds.\n                       \\<forall>b'\\<in>contours_in_d d'. b' < b\\<rbrakk>\n                   \\<Longrightarrow> single_valued\n(a\\<cdot>(Discr (d, ds, ve, b))) \\<and>\n                                     (\\<forall>((lab, \\<beta>), t)\n         \\<in>a\\<cdot>(Discr (d, ds, ve, b)).\n   \\<exists>b'. b' \\<in> ran \\<beta> \\<and> b \\<le> b');\n        \\<And>ve ba c \\<beta>'.\n           \\<lbrakk>ba \\<in> ran \\<beta>';\n            \\<forall>b'\\<in>ran \\<beta>'. b' \\<le> ba;\n            \\<forall>b'\\<in>contours_in_ve ve. b' \\<le> ba\\<rbrakk>\n           \\<Longrightarrow> single_valued\n                              (b\\<cdot>(Discr (c, \\<beta>', ve, ba))) \\<and>\n                             (\\<forall>((lab, \\<beta>), t)\n \\<in>b\\<cdot>(Discr (c, \\<beta>', ve, ba)).\n                                 \\<exists>b'.\n                                    b' \\<in> ran \\<beta> \\<and>\n                                    ba \\<le> b');\n        ba \\<in> ran \\<beta>'; \\<forall>b'\\<in>ran \\<beta>'. b' \\<le> ba;\n        \\<forall>b'\\<in>contours_in_ve ve. b' \\<le> ba\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          ((\\<Lambda> cstate.\n                               case undiscr cstate of\n                               (App lab f vs, \\<beta>, ve, b) \\<Rightarrow>\n                                 let f' = \\<A> f \\<beta> ve;\n                                     as =\n map (\\<lambda>v. \\<A> v \\<beta> ve) vs;\n                                     b' = nb b lab\n                                 in if isProc f'\n                                    then a\\<cdot>\n   (Discr (f', as, ve, b')) \\<union>\n   {((lab, \\<beta>), f')}\n                                    else \\<bottom>\n                               | (call.Let lab ls c', \\<beta>, ve,\n                                  ba) \\<Rightarrow>\n                                   let b' = nb ba lab;\n \\<beta>' = \\<beta>(lab \\<mapsto> b');\n ve' =\n   ve ++\n   map_of (map (\\<lambda>(v, l). ((v, b'), \\<A> (L l) \\<beta>' ve)) ls)\n                                   in b\\<cdot>\n(Discr (c', \\<beta>', ve', b')))\\<cdot>\n                           (Discr (c, \\<beta>', ve, ba))) \\<and>\n                         (\\<forall>((lab, \\<beta>), t)\n                                   \\<in>(\\<Lambda> cstate.\n      case undiscr cstate of\n      (App lab f vs, \\<beta>, ve, b) \\<Rightarrow>\n        let f' = \\<A> f \\<beta> ve;\n            as = map (\\<lambda>v. \\<A> v \\<beta> ve) vs; b' = nb b lab\n        in if isProc f'\n           then a\\<cdot>(Discr (f', as, ve, b')) \\<union>\n                {((lab, \\<beta>), f')}\n           else \\<bottom>\n      | (call.Let lab ls c', \\<beta>, ve, ba) \\<Rightarrow>\n          let b' = nb ba lab; \\<beta>' = \\<beta>(lab \\<mapsto> b');\n              ve' =\n                ve ++\n                map_of\n                 (map (\\<lambda>(v, l). ((v, b'), \\<A> (L l) \\<beta>' ve))\n                   ls)\n          in b\\<cdot>(Discr (c', \\<beta>', ve', b')))\\<cdot>\n  (Discr (c, \\<beta>', ve, ba)).\n                             \\<exists>b'.\n                                b' \\<in> ran \\<beta> \\<and> ba \\<le> b')", "note hyps_C_sv = Next.hyps(2)[THEN conjunct1]"], ["proof (state)\nthis:\n  \\<lbrakk>?b1 \\<in> ran ?\\<beta>'1;\n   \\<forall>b'\\<in>ran ?\\<beta>'1. b' \\<le> ?b1;\n   \\<forall>b'\\<in>contours_in_ve ?ve1. b' \\<le> ?b1\\<rbrakk>\n  \\<Longrightarrow> single_valued\n                     (evalC\\<cdot>(Discr (?c1, ?\\<beta>'1, ?ve1, ?b1)))\n\ngoal (2 subgoals):\n 1. \\<And>a b d ds ve ba.\n       \\<lbrakk>\\<And>d ds ve b.\n                   \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n                    \\<forall>b'\\<in>contours_in_d d. b' < b;\n                    \\<forall>d'\\<in>set ds.\n                       \\<forall>b'\\<in>contours_in_d d'. b' < b\\<rbrakk>\n                   \\<Longrightarrow> single_valued\n(a\\<cdot>(Discr (d, ds, ve, b))) \\<and>\n                                     (\\<forall>((lab, \\<beta>), t)\n         \\<in>a\\<cdot>(Discr (d, ds, ve, b)).\n   \\<exists>b'. b' \\<in> ran \\<beta> \\<and> b \\<le> b');\n        \\<And>ve ba c \\<beta>'.\n           \\<lbrakk>ba \\<in> ran \\<beta>';\n            \\<forall>b'\\<in>ran \\<beta>'. b' \\<le> ba;\n            \\<forall>b'\\<in>contours_in_ve ve. b' \\<le> ba\\<rbrakk>\n           \\<Longrightarrow> single_valued\n                              (b\\<cdot>(Discr (c, \\<beta>', ve, ba))) \\<and>\n                             (\\<forall>((lab, \\<beta>), t)\n \\<in>b\\<cdot>(Discr (c, \\<beta>', ve, ba)).\n                                 \\<exists>b'.\n                                    b' \\<in> ran \\<beta> \\<and>\n                                    ba \\<le> b');\n        \\<forall>b'\\<in>contours_in_ve ve. b' < ba;\n        \\<forall>b'\\<in>contours_in_d d. b' < ba;\n        \\<forall>d'\\<in>set ds.\n           \\<forall>b'\\<in>contours_in_d d'. b' < ba\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          ((\\<Lambda> fstate.\n                               case undiscr fstate of\n                               (DI int, ba) \\<Rightarrow> \\<bottom>\n                               | (DC (Lambda lab vs c, \\<beta>), as, ve,\n                                  ba) \\<Rightarrow>\n                                   if length vs = length as\n                                   then let \\<beta>' = \\<beta>(lab \\<mapsto>\n        ba);\n      ve' = ve(map (\\<lambda>v. (v, ba)) vs [\\<mapsto>] as)\n  in b\\<cdot>(Discr (c, \\<beta>', ve', ba))\n                                   else \\<bottom>\n                               | (DP (Plus c), [], bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (Plus c), [DI a1], bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (Plus c), [DI a1, DI a2],\n                                  bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (Plus c), [DI a1, DI a2, cnt], ve,\n                                  b) \\<Rightarrow>\n                                   if isProc cnt\n                                   then let b' = nb b c;\n      \\<beta> = [c \\<mapsto> b]\n  in a\\<cdot>(Discr (cnt, [DI (a1 + a2)], ve, b')) \\<union>\n     {((c, \\<beta>), cnt)}\n                                   else \\<bottom>\n                               | (DP (Plus c),\n                                  DI a1 # DI a2 # cnt # aa # lista,\n                                  bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (Plus c), DI a1 # _ # lista,\n                                  bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (Plus c), _ # list, bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (prim.If ct cf), [], bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (prim.If ct cf), [DI v],\n                                  bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (prim.If ct cf), [DI v, contt],\n                                  bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (prim.If ct cf), [DI v, contt, contf],\n                                  ve, b) \\<Rightarrow>\n                                   if isProc contt \\<and> isProc contf\n                                   then if v \\<noteq> 0\n  then let b' = nb b ct; \\<beta> = [ct \\<mapsto> b]\n       in a\\<cdot>(Discr (contt, [], ve, b')) \\<union>\n          {((ct, \\<beta>), contt)}\n  else let b' = nb b cf; \\<beta> = [cf \\<mapsto> b]\n       in a\\<cdot>(Discr (contf, [], ve, b')) \\<union>\n          {((cf, \\<beta>), contf)}\n                                   else \\<bottom>\n                               | (DP (prim.If ct cf),\n                                  DI v # contt # contf # ab # lista,\n                                  bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (prim.If ct cf), _ # list,\n                                  bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (Stop, [], bb) \\<Rightarrow> \\<bottom>\n                               | (Stop, [DI i], x, xa) \\<Rightarrow> {}\n                               | (Stop, DI i # a # lista, bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (Stop, _ # list, bb) \\<Rightarrow>\n                                   \\<bottom>)\\<cdot>\n                           (Discr (d, ds, ve, ba))) \\<and>\n                         (\\<forall>((lab, \\<beta>), t)\n                                   \\<in>(\\<Lambda> fstate.\n      case undiscr fstate of (DI int, ba) \\<Rightarrow> \\<bottom>\n      | (DC (Lambda lab vs c, \\<beta>), as, ve, ba) \\<Rightarrow>\n          if length vs = length as\n          then let \\<beta>' = \\<beta>(lab \\<mapsto> ba);\n                   ve' = ve(map (\\<lambda>v. (v, ba)) vs [\\<mapsto>] as)\n               in b\\<cdot>(Discr (c, \\<beta>', ve', ba))\n          else \\<bottom>\n      | (DP (Plus c), [], bb) \\<Rightarrow> \\<bottom>\n      | (DP (Plus c), [DI a1], bb) \\<Rightarrow> \\<bottom>\n      | (DP (Plus c), [DI a1, DI a2], bb) \\<Rightarrow> \\<bottom>\n      | (DP (Plus c), [DI a1, DI a2, cnt], ve, b) \\<Rightarrow>\n          if isProc cnt\n          then let b' = nb b c; \\<beta> = [c \\<mapsto> b]\n               in a\\<cdot>(Discr (cnt, [DI (a1 + a2)], ve, b')) \\<union>\n                  {((c, \\<beta>), cnt)}\n          else \\<bottom>\n      | (DP (Plus c), DI a1 # DI a2 # cnt # aa # lista, bb) \\<Rightarrow>\n          \\<bottom>\n      | (DP (Plus c), DI a1 # _ # lista, bb) \\<Rightarrow> \\<bottom>\n      | (DP (Plus c), _ # list, bb) \\<Rightarrow> \\<bottom>\n      | (DP (prim.If ct cf), [], bb) \\<Rightarrow> \\<bottom>\n      | (DP (prim.If ct cf), [DI v], bb) \\<Rightarrow> \\<bottom>\n      | (DP (prim.If ct cf), [DI v, contt], bb) \\<Rightarrow> \\<bottom>\n      | (DP (prim.If ct cf), [DI v, contt, contf], ve, b) \\<Rightarrow>\n          if isProc contt \\<and> isProc contf\n          then if v \\<noteq> 0\n               then let b' = nb b ct; \\<beta> = [ct \\<mapsto> b]\n                    in a\\<cdot>(Discr (contt, [], ve, b')) \\<union>\n                       {((ct, \\<beta>), contt)}\n               else let b' = nb b cf; \\<beta> = [cf \\<mapsto> b]\n                    in a\\<cdot>(Discr (contf, [], ve, b')) \\<union>\n                       {((cf, \\<beta>), contf)}\n          else \\<bottom>\n      | (DP (prim.If ct cf), DI v # contt # contf # ab # lista,\n         bb) \\<Rightarrow>\n          \\<bottom>\n      | (DP (prim.If ct cf), _ # list, bb) \\<Rightarrow> \\<bottom>\n      | (Stop, [], bb) \\<Rightarrow> \\<bottom>\n      | (Stop, [DI i], x, xa) \\<Rightarrow> {}\n      | (Stop, DI i # a # lista, bb) \\<Rightarrow> \\<bottom>\n      | (Stop, _ # list, bb) \\<Rightarrow> \\<bottom>)\\<cdot>\n  (Discr (d, ds, ve, ba)).\n                             \\<exists>b'.\n                                b' \\<in> ran \\<beta> \\<and> ba \\<le> b')\n 2. \\<And>a b ve ba c \\<beta>'.\n       \\<lbrakk>\\<And>d ds ve b.\n                   \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n                    \\<forall>b'\\<in>contours_in_d d. b' < b;\n                    \\<forall>d'\\<in>set ds.\n                       \\<forall>b'\\<in>contours_in_d d'. b' < b\\<rbrakk>\n                   \\<Longrightarrow> single_valued\n(a\\<cdot>(Discr (d, ds, ve, b))) \\<and>\n                                     (\\<forall>((lab, \\<beta>), t)\n         \\<in>a\\<cdot>(Discr (d, ds, ve, b)).\n   \\<exists>b'. b' \\<in> ran \\<beta> \\<and> b \\<le> b');\n        \\<And>ve ba c \\<beta>'.\n           \\<lbrakk>ba \\<in> ran \\<beta>';\n            \\<forall>b'\\<in>ran \\<beta>'. b' \\<le> ba;\n            \\<forall>b'\\<in>contours_in_ve ve. b' \\<le> ba\\<rbrakk>\n           \\<Longrightarrow> single_valued\n                              (b\\<cdot>(Discr (c, \\<beta>', ve, ba))) \\<and>\n                             (\\<forall>((lab, \\<beta>), t)\n \\<in>b\\<cdot>(Discr (c, \\<beta>', ve, ba)).\n                                 \\<exists>b'.\n                                    b' \\<in> ran \\<beta> \\<and>\n                                    ba \\<le> b');\n        ba \\<in> ran \\<beta>'; \\<forall>b'\\<in>ran \\<beta>'. b' \\<le> ba;\n        \\<forall>b'\\<in>contours_in_ve ve. b' \\<le> ba\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          ((\\<Lambda> cstate.\n                               case undiscr cstate of\n                               (App lab f vs, \\<beta>, ve, b) \\<Rightarrow>\n                                 let f' = \\<A> f \\<beta> ve;\n                                     as =\n map (\\<lambda>v. \\<A> v \\<beta> ve) vs;\n                                     b' = nb b lab\n                                 in if isProc f'\n                                    then a\\<cdot>\n   (Discr (f', as, ve, b')) \\<union>\n   {((lab, \\<beta>), f')}\n                                    else \\<bottom>\n                               | (call.Let lab ls c', \\<beta>, ve,\n                                  ba) \\<Rightarrow>\n                                   let b' = nb ba lab;\n \\<beta>' = \\<beta>(lab \\<mapsto> b');\n ve' =\n   ve ++\n   map_of (map (\\<lambda>(v, l). ((v, b'), \\<A> (L l) \\<beta>' ve)) ls)\n                                   in b\\<cdot>\n(Discr (c', \\<beta>', ve', b')))\\<cdot>\n                           (Discr (c, \\<beta>', ve, ba))) \\<and>\n                         (\\<forall>((lab, \\<beta>), t)\n                                   \\<in>(\\<Lambda> cstate.\n      case undiscr cstate of\n      (App lab f vs, \\<beta>, ve, b) \\<Rightarrow>\n        let f' = \\<A> f \\<beta> ve;\n            as = map (\\<lambda>v. \\<A> v \\<beta> ve) vs; b' = nb b lab\n        in if isProc f'\n           then a\\<cdot>(Discr (f', as, ve, b')) \\<union>\n                {((lab, \\<beta>), f')}\n           else \\<bottom>\n      | (call.Let lab ls c', \\<beta>, ve, ba) \\<Rightarrow>\n          let b' = nb ba lab; \\<beta>' = \\<beta>(lab \\<mapsto> b');\n              ve' =\n                ve ++\n                map_of\n                 (map (\\<lambda>(v, l). ((v, b'), \\<A> (L l) \\<beta>' ve))\n                   ls)\n          in b\\<cdot>(Discr (c', \\<beta>', ve', b')))\\<cdot>\n  (Discr (c, \\<beta>', ve, ba)).\n                             \\<exists>b'.\n                                b' \\<in> ran \\<beta> \\<and> ba \\<le> b')", "note hyps_C_b = Next.hyps(2)[THEN conjunct2, THEN bspec]"], ["proof (state)\nthis:\n  \\<lbrakk>?b2 \\<in> ran ?\\<beta>'2;\n   \\<forall>b'\\<in>ran ?\\<beta>'2. b' \\<le> ?b2;\n   \\<forall>b'\\<in>contours_in_ve ?ve2. b' \\<le> ?b2;\n   ?x \\<in> evalC\\<cdot>(Discr (?c2, ?\\<beta>'2, ?ve2, ?b2))\\<rbrakk>\n  \\<Longrightarrow> case ?x of\n                    (a, b) \\<Rightarrow>\n                      (case a of\n                       (lab, \\<beta>) \\<Rightarrow>\n                         \\<lambda>t.\n                            \\<exists>b'.\n                               b' \\<in> ran \\<beta> \\<and> ?b2 \\<le> b')\n                       b\n\ngoal (2 subgoals):\n 1. \\<And>a b d ds ve ba.\n       \\<lbrakk>\\<And>d ds ve b.\n                   \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n                    \\<forall>b'\\<in>contours_in_d d. b' < b;\n                    \\<forall>d'\\<in>set ds.\n                       \\<forall>b'\\<in>contours_in_d d'. b' < b\\<rbrakk>\n                   \\<Longrightarrow> single_valued\n(a\\<cdot>(Discr (d, ds, ve, b))) \\<and>\n                                     (\\<forall>((lab, \\<beta>), t)\n         \\<in>a\\<cdot>(Discr (d, ds, ve, b)).\n   \\<exists>b'. b' \\<in> ran \\<beta> \\<and> b \\<le> b');\n        \\<And>ve ba c \\<beta>'.\n           \\<lbrakk>ba \\<in> ran \\<beta>';\n            \\<forall>b'\\<in>ran \\<beta>'. b' \\<le> ba;\n            \\<forall>b'\\<in>contours_in_ve ve. b' \\<le> ba\\<rbrakk>\n           \\<Longrightarrow> single_valued\n                              (b\\<cdot>(Discr (c, \\<beta>', ve, ba))) \\<and>\n                             (\\<forall>((lab, \\<beta>), t)\n \\<in>b\\<cdot>(Discr (c, \\<beta>', ve, ba)).\n                                 \\<exists>b'.\n                                    b' \\<in> ran \\<beta> \\<and>\n                                    ba \\<le> b');\n        \\<forall>b'\\<in>contours_in_ve ve. b' < ba;\n        \\<forall>b'\\<in>contours_in_d d. b' < ba;\n        \\<forall>d'\\<in>set ds.\n           \\<forall>b'\\<in>contours_in_d d'. b' < ba\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          ((\\<Lambda> fstate.\n                               case undiscr fstate of\n                               (DI int, ba) \\<Rightarrow> \\<bottom>\n                               | (DC (Lambda lab vs c, \\<beta>), as, ve,\n                                  ba) \\<Rightarrow>\n                                   if length vs = length as\n                                   then let \\<beta>' = \\<beta>(lab \\<mapsto>\n        ba);\n      ve' = ve(map (\\<lambda>v. (v, ba)) vs [\\<mapsto>] as)\n  in b\\<cdot>(Discr (c, \\<beta>', ve', ba))\n                                   else \\<bottom>\n                               | (DP (Plus c), [], bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (Plus c), [DI a1], bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (Plus c), [DI a1, DI a2],\n                                  bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (Plus c), [DI a1, DI a2, cnt], ve,\n                                  b) \\<Rightarrow>\n                                   if isProc cnt\n                                   then let b' = nb b c;\n      \\<beta> = [c \\<mapsto> b]\n  in a\\<cdot>(Discr (cnt, [DI (a1 + a2)], ve, b')) \\<union>\n     {((c, \\<beta>), cnt)}\n                                   else \\<bottom>\n                               | (DP (Plus c),\n                                  DI a1 # DI a2 # cnt # aa # lista,\n                                  bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (Plus c), DI a1 # _ # lista,\n                                  bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (Plus c), _ # list, bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (prim.If ct cf), [], bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (prim.If ct cf), [DI v],\n                                  bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (prim.If ct cf), [DI v, contt],\n                                  bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (prim.If ct cf), [DI v, contt, contf],\n                                  ve, b) \\<Rightarrow>\n                                   if isProc contt \\<and> isProc contf\n                                   then if v \\<noteq> 0\n  then let b' = nb b ct; \\<beta> = [ct \\<mapsto> b]\n       in a\\<cdot>(Discr (contt, [], ve, b')) \\<union>\n          {((ct, \\<beta>), contt)}\n  else let b' = nb b cf; \\<beta> = [cf \\<mapsto> b]\n       in a\\<cdot>(Discr (contf, [], ve, b')) \\<union>\n          {((cf, \\<beta>), contf)}\n                                   else \\<bottom>\n                               | (DP (prim.If ct cf),\n                                  DI v # contt # contf # ab # lista,\n                                  bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (prim.If ct cf), _ # list,\n                                  bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (Stop, [], bb) \\<Rightarrow> \\<bottom>\n                               | (Stop, [DI i], x, xa) \\<Rightarrow> {}\n                               | (Stop, DI i # a # lista, bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (Stop, _ # list, bb) \\<Rightarrow>\n                                   \\<bottom>)\\<cdot>\n                           (Discr (d, ds, ve, ba))) \\<and>\n                         (\\<forall>((lab, \\<beta>), t)\n                                   \\<in>(\\<Lambda> fstate.\n      case undiscr fstate of (DI int, ba) \\<Rightarrow> \\<bottom>\n      | (DC (Lambda lab vs c, \\<beta>), as, ve, ba) \\<Rightarrow>\n          if length vs = length as\n          then let \\<beta>' = \\<beta>(lab \\<mapsto> ba);\n                   ve' = ve(map (\\<lambda>v. (v, ba)) vs [\\<mapsto>] as)\n               in b\\<cdot>(Discr (c, \\<beta>', ve', ba))\n          else \\<bottom>\n      | (DP (Plus c), [], bb) \\<Rightarrow> \\<bottom>\n      | (DP (Plus c), [DI a1], bb) \\<Rightarrow> \\<bottom>\n      | (DP (Plus c), [DI a1, DI a2], bb) \\<Rightarrow> \\<bottom>\n      | (DP (Plus c), [DI a1, DI a2, cnt], ve, b) \\<Rightarrow>\n          if isProc cnt\n          then let b' = nb b c; \\<beta> = [c \\<mapsto> b]\n               in a\\<cdot>(Discr (cnt, [DI (a1 + a2)], ve, b')) \\<union>\n                  {((c, \\<beta>), cnt)}\n          else \\<bottom>\n      | (DP (Plus c), DI a1 # DI a2 # cnt # aa # lista, bb) \\<Rightarrow>\n          \\<bottom>\n      | (DP (Plus c), DI a1 # _ # lista, bb) \\<Rightarrow> \\<bottom>\n      | (DP (Plus c), _ # list, bb) \\<Rightarrow> \\<bottom>\n      | (DP (prim.If ct cf), [], bb) \\<Rightarrow> \\<bottom>\n      | (DP (prim.If ct cf), [DI v], bb) \\<Rightarrow> \\<bottom>\n      | (DP (prim.If ct cf), [DI v, contt], bb) \\<Rightarrow> \\<bottom>\n      | (DP (prim.If ct cf), [DI v, contt, contf], ve, b) \\<Rightarrow>\n          if isProc contt \\<and> isProc contf\n          then if v \\<noteq> 0\n               then let b' = nb b ct; \\<beta> = [ct \\<mapsto> b]\n                    in a\\<cdot>(Discr (contt, [], ve, b')) \\<union>\n                       {((ct, \\<beta>), contt)}\n               else let b' = nb b cf; \\<beta> = [cf \\<mapsto> b]\n                    in a\\<cdot>(Discr (contf, [], ve, b')) \\<union>\n                       {((cf, \\<beta>), contf)}\n          else \\<bottom>\n      | (DP (prim.If ct cf), DI v # contt # contf # ab # lista,\n         bb) \\<Rightarrow>\n          \\<bottom>\n      | (DP (prim.If ct cf), _ # list, bb) \\<Rightarrow> \\<bottom>\n      | (Stop, [], bb) \\<Rightarrow> \\<bottom>\n      | (Stop, [DI i], x, xa) \\<Rightarrow> {}\n      | (Stop, DI i # a # lista, bb) \\<Rightarrow> \\<bottom>\n      | (Stop, _ # list, bb) \\<Rightarrow> \\<bottom>)\\<cdot>\n  (Discr (d, ds, ve, ba)).\n                             \\<exists>b'.\n                                b' \\<in> ran \\<beta> \\<and> ba \\<le> b')\n 2. \\<And>a b ve ba c \\<beta>'.\n       \\<lbrakk>\\<And>d ds ve b.\n                   \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n                    \\<forall>b'\\<in>contours_in_d d. b' < b;\n                    \\<forall>d'\\<in>set ds.\n                       \\<forall>b'\\<in>contours_in_d d'. b' < b\\<rbrakk>\n                   \\<Longrightarrow> single_valued\n(a\\<cdot>(Discr (d, ds, ve, b))) \\<and>\n                                     (\\<forall>((lab, \\<beta>), t)\n         \\<in>a\\<cdot>(Discr (d, ds, ve, b)).\n   \\<exists>b'. b' \\<in> ran \\<beta> \\<and> b \\<le> b');\n        \\<And>ve ba c \\<beta>'.\n           \\<lbrakk>ba \\<in> ran \\<beta>';\n            \\<forall>b'\\<in>ran \\<beta>'. b' \\<le> ba;\n            \\<forall>b'\\<in>contours_in_ve ve. b' \\<le> ba\\<rbrakk>\n           \\<Longrightarrow> single_valued\n                              (b\\<cdot>(Discr (c, \\<beta>', ve, ba))) \\<and>\n                             (\\<forall>((lab, \\<beta>), t)\n \\<in>b\\<cdot>(Discr (c, \\<beta>', ve, ba)).\n                                 \\<exists>b'.\n                                    b' \\<in> ran \\<beta> \\<and>\n                                    ba \\<le> b');\n        ba \\<in> ran \\<beta>'; \\<forall>b'\\<in>ran \\<beta>'. b' \\<le> ba;\n        \\<forall>b'\\<in>contours_in_ve ve. b' \\<le> ba\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          ((\\<Lambda> cstate.\n                               case undiscr cstate of\n                               (App lab f vs, \\<beta>, ve, b) \\<Rightarrow>\n                                 let f' = \\<A> f \\<beta> ve;\n                                     as =\n map (\\<lambda>v. \\<A> v \\<beta> ve) vs;\n                                     b' = nb b lab\n                                 in if isProc f'\n                                    then a\\<cdot>\n   (Discr (f', as, ve, b')) \\<union>\n   {((lab, \\<beta>), f')}\n                                    else \\<bottom>\n                               | (call.Let lab ls c', \\<beta>, ve,\n                                  ba) \\<Rightarrow>\n                                   let b' = nb ba lab;\n \\<beta>' = \\<beta>(lab \\<mapsto> b');\n ve' =\n   ve ++\n   map_of (map (\\<lambda>(v, l). ((v, b'), \\<A> (L l) \\<beta>' ve)) ls)\n                                   in b\\<cdot>\n(Discr (c', \\<beta>', ve', b')))\\<cdot>\n                           (Discr (c, \\<beta>', ve, ba))) \\<and>\n                         (\\<forall>((lab, \\<beta>), t)\n                                   \\<in>(\\<Lambda> cstate.\n      case undiscr cstate of\n      (App lab f vs, \\<beta>, ve, b) \\<Rightarrow>\n        let f' = \\<A> f \\<beta> ve;\n            as = map (\\<lambda>v. \\<A> v \\<beta> ve) vs; b' = nb b lab\n        in if isProc f'\n           then a\\<cdot>(Discr (f', as, ve, b')) \\<union>\n                {((lab, \\<beta>), f')}\n           else \\<bottom>\n      | (call.Let lab ls c', \\<beta>, ve, ba) \\<Rightarrow>\n          let b' = nb ba lab; \\<beta>' = \\<beta>(lab \\<mapsto> b');\n              ve' =\n                ve ++\n                map_of\n                 (map (\\<lambda>(v, l). ((v, b'), \\<A> (L l) \\<beta>' ve))\n                   ls)\n          in b\\<cdot>(Discr (c', \\<beta>', ve', b')))\\<cdot>\n  (Discr (c, \\<beta>', ve, ba)).\n                             \\<exists>b'.\n                                b' \\<in> ran \\<beta> \\<and> ba \\<le> b')", "{"], ["proof (state)\nthis:\n  \\<lbrakk>?b2 \\<in> ran ?\\<beta>'2;\n   \\<forall>b'\\<in>ran ?\\<beta>'2. b' \\<le> ?b2;\n   \\<forall>b'\\<in>contours_in_ve ?ve2. b' \\<le> ?b2;\n   ?x \\<in> evalC\\<cdot>(Discr (?c2, ?\\<beta>'2, ?ve2, ?b2))\\<rbrakk>\n  \\<Longrightarrow> case ?x of\n                    (a, b) \\<Rightarrow>\n                      (case a of\n                       (lab, \\<beta>) \\<Rightarrow>\n                         \\<lambda>t.\n                            \\<exists>b'.\n                               b' \\<in> ran \\<beta> \\<and> ?b2 \\<le> b')\n                       b\n\ngoal (2 subgoals):\n 1. \\<And>a b d ds ve ba.\n       \\<lbrakk>\\<And>d ds ve b.\n                   \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n                    \\<forall>b'\\<in>contours_in_d d. b' < b;\n                    \\<forall>d'\\<in>set ds.\n                       \\<forall>b'\\<in>contours_in_d d'. b' < b\\<rbrakk>\n                   \\<Longrightarrow> single_valued\n(a\\<cdot>(Discr (d, ds, ve, b))) \\<and>\n                                     (\\<forall>((lab, \\<beta>), t)\n         \\<in>a\\<cdot>(Discr (d, ds, ve, b)).\n   \\<exists>b'. b' \\<in> ran \\<beta> \\<and> b \\<le> b');\n        \\<And>ve ba c \\<beta>'.\n           \\<lbrakk>ba \\<in> ran \\<beta>';\n            \\<forall>b'\\<in>ran \\<beta>'. b' \\<le> ba;\n            \\<forall>b'\\<in>contours_in_ve ve. b' \\<le> ba\\<rbrakk>\n           \\<Longrightarrow> single_valued\n                              (b\\<cdot>(Discr (c, \\<beta>', ve, ba))) \\<and>\n                             (\\<forall>((lab, \\<beta>), t)\n \\<in>b\\<cdot>(Discr (c, \\<beta>', ve, ba)).\n                                 \\<exists>b'.\n                                    b' \\<in> ran \\<beta> \\<and>\n                                    ba \\<le> b');\n        \\<forall>b'\\<in>contours_in_ve ve. b' < ba;\n        \\<forall>b'\\<in>contours_in_d d. b' < ba;\n        \\<forall>d'\\<in>set ds.\n           \\<forall>b'\\<in>contours_in_d d'. b' < ba\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          ((\\<Lambda> fstate.\n                               case undiscr fstate of\n                               (DI int, ba) \\<Rightarrow> \\<bottom>\n                               | (DC (Lambda lab vs c, \\<beta>), as, ve,\n                                  ba) \\<Rightarrow>\n                                   if length vs = length as\n                                   then let \\<beta>' = \\<beta>(lab \\<mapsto>\n        ba);\n      ve' = ve(map (\\<lambda>v. (v, ba)) vs [\\<mapsto>] as)\n  in b\\<cdot>(Discr (c, \\<beta>', ve', ba))\n                                   else \\<bottom>\n                               | (DP (Plus c), [], bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (Plus c), [DI a1], bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (Plus c), [DI a1, DI a2],\n                                  bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (Plus c), [DI a1, DI a2, cnt], ve,\n                                  b) \\<Rightarrow>\n                                   if isProc cnt\n                                   then let b' = nb b c;\n      \\<beta> = [c \\<mapsto> b]\n  in a\\<cdot>(Discr (cnt, [DI (a1 + a2)], ve, b')) \\<union>\n     {((c, \\<beta>), cnt)}\n                                   else \\<bottom>\n                               | (DP (Plus c),\n                                  DI a1 # DI a2 # cnt # aa # lista,\n                                  bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (Plus c), DI a1 # _ # lista,\n                                  bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (Plus c), _ # list, bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (prim.If ct cf), [], bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (prim.If ct cf), [DI v],\n                                  bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (prim.If ct cf), [DI v, contt],\n                                  bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (prim.If ct cf), [DI v, contt, contf],\n                                  ve, b) \\<Rightarrow>\n                                   if isProc contt \\<and> isProc contf\n                                   then if v \\<noteq> 0\n  then let b' = nb b ct; \\<beta> = [ct \\<mapsto> b]\n       in a\\<cdot>(Discr (contt, [], ve, b')) \\<union>\n          {((ct, \\<beta>), contt)}\n  else let b' = nb b cf; \\<beta> = [cf \\<mapsto> b]\n       in a\\<cdot>(Discr (contf, [], ve, b')) \\<union>\n          {((cf, \\<beta>), contf)}\n                                   else \\<bottom>\n                               | (DP (prim.If ct cf),\n                                  DI v # contt # contf # ab # lista,\n                                  bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (prim.If ct cf), _ # list,\n                                  bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (Stop, [], bb) \\<Rightarrow> \\<bottom>\n                               | (Stop, [DI i], x, xa) \\<Rightarrow> {}\n                               | (Stop, DI i # a # lista, bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (Stop, _ # list, bb) \\<Rightarrow>\n                                   \\<bottom>)\\<cdot>\n                           (Discr (d, ds, ve, ba))) \\<and>\n                         (\\<forall>((lab, \\<beta>), t)\n                                   \\<in>(\\<Lambda> fstate.\n      case undiscr fstate of (DI int, ba) \\<Rightarrow> \\<bottom>\n      | (DC (Lambda lab vs c, \\<beta>), as, ve, ba) \\<Rightarrow>\n          if length vs = length as\n          then let \\<beta>' = \\<beta>(lab \\<mapsto> ba);\n                   ve' = ve(map (\\<lambda>v. (v, ba)) vs [\\<mapsto>] as)\n               in b\\<cdot>(Discr (c, \\<beta>', ve', ba))\n          else \\<bottom>\n      | (DP (Plus c), [], bb) \\<Rightarrow> \\<bottom>\n      | (DP (Plus c), [DI a1], bb) \\<Rightarrow> \\<bottom>\n      | (DP (Plus c), [DI a1, DI a2], bb) \\<Rightarrow> \\<bottom>\n      | (DP (Plus c), [DI a1, DI a2, cnt], ve, b) \\<Rightarrow>\n          if isProc cnt\n          then let b' = nb b c; \\<beta> = [c \\<mapsto> b]\n               in a\\<cdot>(Discr (cnt, [DI (a1 + a2)], ve, b')) \\<union>\n                  {((c, \\<beta>), cnt)}\n          else \\<bottom>\n      | (DP (Plus c), DI a1 # DI a2 # cnt # aa # lista, bb) \\<Rightarrow>\n          \\<bottom>\n      | (DP (Plus c), DI a1 # _ # lista, bb) \\<Rightarrow> \\<bottom>\n      | (DP (Plus c), _ # list, bb) \\<Rightarrow> \\<bottom>\n      | (DP (prim.If ct cf), [], bb) \\<Rightarrow> \\<bottom>\n      | (DP (prim.If ct cf), [DI v], bb) \\<Rightarrow> \\<bottom>\n      | (DP (prim.If ct cf), [DI v, contt], bb) \\<Rightarrow> \\<bottom>\n      | (DP (prim.If ct cf), [DI v, contt, contf], ve, b) \\<Rightarrow>\n          if isProc contt \\<and> isProc contf\n          then if v \\<noteq> 0\n               then let b' = nb b ct; \\<beta> = [ct \\<mapsto> b]\n                    in a\\<cdot>(Discr (contt, [], ve, b')) \\<union>\n                       {((ct, \\<beta>), contt)}\n               else let b' = nb b cf; \\<beta> = [cf \\<mapsto> b]\n                    in a\\<cdot>(Discr (contf, [], ve, b')) \\<union>\n                       {((cf, \\<beta>), contf)}\n          else \\<bottom>\n      | (DP (prim.If ct cf), DI v # contt # contf # ab # lista,\n         bb) \\<Rightarrow>\n          \\<bottom>\n      | (DP (prim.If ct cf), _ # list, bb) \\<Rightarrow> \\<bottom>\n      | (Stop, [], bb) \\<Rightarrow> \\<bottom>\n      | (Stop, [DI i], x, xa) \\<Rightarrow> {}\n      | (Stop, DI i # a # lista, bb) \\<Rightarrow> \\<bottom>\n      | (Stop, _ # list, bb) \\<Rightarrow> \\<bottom>)\\<cdot>\n  (Discr (d, ds, ve, ba)).\n                             \\<exists>b'.\n                                b' \\<in> ran \\<beta> \\<and> ba \\<le> b')\n 2. \\<And>a b ve ba c \\<beta>'.\n       \\<lbrakk>\\<And>d ds ve b.\n                   \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n                    \\<forall>b'\\<in>contours_in_d d. b' < b;\n                    \\<forall>d'\\<in>set ds.\n                       \\<forall>b'\\<in>contours_in_d d'. b' < b\\<rbrakk>\n                   \\<Longrightarrow> single_valued\n(a\\<cdot>(Discr (d, ds, ve, b))) \\<and>\n                                     (\\<forall>((lab, \\<beta>), t)\n         \\<in>a\\<cdot>(Discr (d, ds, ve, b)).\n   \\<exists>b'. b' \\<in> ran \\<beta> \\<and> b \\<le> b');\n        \\<And>ve ba c \\<beta>'.\n           \\<lbrakk>ba \\<in> ran \\<beta>';\n            \\<forall>b'\\<in>ran \\<beta>'. b' \\<le> ba;\n            \\<forall>b'\\<in>contours_in_ve ve. b' \\<le> ba\\<rbrakk>\n           \\<Longrightarrow> single_valued\n                              (b\\<cdot>(Discr (c, \\<beta>', ve, ba))) \\<and>\n                             (\\<forall>((lab, \\<beta>), t)\n \\<in>b\\<cdot>(Discr (c, \\<beta>', ve, ba)).\n                                 \\<exists>b'.\n                                    b' \\<in> ran \\<beta> \\<and>\n                                    ba \\<le> b');\n        ba \\<in> ran \\<beta>'; \\<forall>b'\\<in>ran \\<beta>'. b' \\<le> ba;\n        \\<forall>b'\\<in>contours_in_ve ve. b' \\<le> ba\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          ((\\<Lambda> cstate.\n                               case undiscr cstate of\n                               (App lab f vs, \\<beta>, ve, b) \\<Rightarrow>\n                                 let f' = \\<A> f \\<beta> ve;\n                                     as =\n map (\\<lambda>v. \\<A> v \\<beta> ve) vs;\n                                     b' = nb b lab\n                                 in if isProc f'\n                                    then a\\<cdot>\n   (Discr (f', as, ve, b')) \\<union>\n   {((lab, \\<beta>), f')}\n                                    else \\<bottom>\n                               | (call.Let lab ls c', \\<beta>, ve,\n                                  ba) \\<Rightarrow>\n                                   let b' = nb ba lab;\n \\<beta>' = \\<beta>(lab \\<mapsto> b');\n ve' =\n   ve ++\n   map_of (map (\\<lambda>(v, l). ((v, b'), \\<A> (L l) \\<beta>' ve)) ls)\n                                   in b\\<cdot>\n(Discr (c', \\<beta>', ve', b')))\\<cdot>\n                           (Discr (c, \\<beta>', ve, ba))) \\<and>\n                         (\\<forall>((lab, \\<beta>), t)\n                                   \\<in>(\\<Lambda> cstate.\n      case undiscr cstate of\n      (App lab f vs, \\<beta>, ve, b) \\<Rightarrow>\n        let f' = \\<A> f \\<beta> ve;\n            as = map (\\<lambda>v. \\<A> v \\<beta> ve) vs; b' = nb b lab\n        in if isProc f'\n           then a\\<cdot>(Discr (f', as, ve, b')) \\<union>\n                {((lab, \\<beta>), f')}\n           else \\<bottom>\n      | (call.Let lab ls c', \\<beta>, ve, ba) \\<Rightarrow>\n          let b' = nb ba lab; \\<beta>' = \\<beta>(lab \\<mapsto> b');\n              ve' =\n                ve ++\n                map_of\n                 (map (\\<lambda>(v, l). ((v, b'), \\<A> (L l) \\<beta>' ve))\n                   ls)\n          in b\\<cdot>(Discr (c', \\<beta>', ve', b')))\\<cdot>\n  (Discr (c, \\<beta>', ve, ba)).\n                             \\<exists>b'.\n                                b' \\<in> ran \\<beta> \\<and> ba \\<le> b')", "case (1 d ds ve b)"], ["proof (state)\nthis:\n  \\<forall>b'\\<in>contours_in_ve ve. b' < b\n  \\<forall>b'\\<in>contours_in_d d. b' < b\n  \\<forall>d'\\<in>set ds. \\<forall>b'\\<in>contours_in_d d'. b' < b\n\ngoal (2 subgoals):\n 1. \\<And>a b d ds ve ba.\n       \\<lbrakk>\\<And>d ds ve b.\n                   \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n                    \\<forall>b'\\<in>contours_in_d d. b' < b;\n                    \\<forall>d'\\<in>set ds.\n                       \\<forall>b'\\<in>contours_in_d d'. b' < b\\<rbrakk>\n                   \\<Longrightarrow> single_valued\n(a\\<cdot>(Discr (d, ds, ve, b))) \\<and>\n                                     (\\<forall>((lab, \\<beta>), t)\n         \\<in>a\\<cdot>(Discr (d, ds, ve, b)).\n   \\<exists>b'. b' \\<in> ran \\<beta> \\<and> b \\<le> b');\n        \\<And>ve ba c \\<beta>'.\n           \\<lbrakk>ba \\<in> ran \\<beta>';\n            \\<forall>b'\\<in>ran \\<beta>'. b' \\<le> ba;\n            \\<forall>b'\\<in>contours_in_ve ve. b' \\<le> ba\\<rbrakk>\n           \\<Longrightarrow> single_valued\n                              (b\\<cdot>(Discr (c, \\<beta>', ve, ba))) \\<and>\n                             (\\<forall>((lab, \\<beta>), t)\n \\<in>b\\<cdot>(Discr (c, \\<beta>', ve, ba)).\n                                 \\<exists>b'.\n                                    b' \\<in> ran \\<beta> \\<and>\n                                    ba \\<le> b');\n        \\<forall>b'\\<in>contours_in_ve ve. b' < ba;\n        \\<forall>b'\\<in>contours_in_d d. b' < ba;\n        \\<forall>d'\\<in>set ds.\n           \\<forall>b'\\<in>contours_in_d d'. b' < ba\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          ((\\<Lambda> fstate.\n                               case undiscr fstate of\n                               (DI int, ba) \\<Rightarrow> \\<bottom>\n                               | (DC (Lambda lab vs c, \\<beta>), as, ve,\n                                  ba) \\<Rightarrow>\n                                   if length vs = length as\n                                   then let \\<beta>' = \\<beta>(lab \\<mapsto>\n        ba);\n      ve' = ve(map (\\<lambda>v. (v, ba)) vs [\\<mapsto>] as)\n  in b\\<cdot>(Discr (c, \\<beta>', ve', ba))\n                                   else \\<bottom>\n                               | (DP (Plus c), [], bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (Plus c), [DI a1], bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (Plus c), [DI a1, DI a2],\n                                  bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (Plus c), [DI a1, DI a2, cnt], ve,\n                                  b) \\<Rightarrow>\n                                   if isProc cnt\n                                   then let b' = nb b c;\n      \\<beta> = [c \\<mapsto> b]\n  in a\\<cdot>(Discr (cnt, [DI (a1 + a2)], ve, b')) \\<union>\n     {((c, \\<beta>), cnt)}\n                                   else \\<bottom>\n                               | (DP (Plus c),\n                                  DI a1 # DI a2 # cnt # aa # lista,\n                                  bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (Plus c), DI a1 # _ # lista,\n                                  bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (Plus c), _ # list, bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (prim.If ct cf), [], bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (prim.If ct cf), [DI v],\n                                  bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (prim.If ct cf), [DI v, contt],\n                                  bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (prim.If ct cf), [DI v, contt, contf],\n                                  ve, b) \\<Rightarrow>\n                                   if isProc contt \\<and> isProc contf\n                                   then if v \\<noteq> 0\n  then let b' = nb b ct; \\<beta> = [ct \\<mapsto> b]\n       in a\\<cdot>(Discr (contt, [], ve, b')) \\<union>\n          {((ct, \\<beta>), contt)}\n  else let b' = nb b cf; \\<beta> = [cf \\<mapsto> b]\n       in a\\<cdot>(Discr (contf, [], ve, b')) \\<union>\n          {((cf, \\<beta>), contf)}\n                                   else \\<bottom>\n                               | (DP (prim.If ct cf),\n                                  DI v # contt # contf # ab # lista,\n                                  bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (DP (prim.If ct cf), _ # list,\n                                  bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (Stop, [], bb) \\<Rightarrow> \\<bottom>\n                               | (Stop, [DI i], x, xa) \\<Rightarrow> {}\n                               | (Stop, DI i # a # lista, bb) \\<Rightarrow>\n                                   \\<bottom>\n                               | (Stop, _ # list, bb) \\<Rightarrow>\n                                   \\<bottom>)\\<cdot>\n                           (Discr (d, ds, ve, ba))) \\<and>\n                         (\\<forall>((lab, \\<beta>), t)\n                                   \\<in>(\\<Lambda> fstate.\n      case undiscr fstate of (DI int, ba) \\<Rightarrow> \\<bottom>\n      | (DC (Lambda lab vs c, \\<beta>), as, ve, ba) \\<Rightarrow>\n          if length vs = length as\n          then let \\<beta>' = \\<beta>(lab \\<mapsto> ba);\n                   ve' = ve(map (\\<lambda>v. (v, ba)) vs [\\<mapsto>] as)\n               in b\\<cdot>(Discr (c, \\<beta>', ve', ba))\n          else \\<bottom>\n      | (DP (Plus c), [], bb) \\<Rightarrow> \\<bottom>\n      | (DP (Plus c), [DI a1], bb) \\<Rightarrow> \\<bottom>\n      | (DP (Plus c), [DI a1, DI a2], bb) \\<Rightarrow> \\<bottom>\n      | (DP (Plus c), [DI a1, DI a2, cnt], ve, b) \\<Rightarrow>\n          if isProc cnt\n          then let b' = nb b c; \\<beta> = [c \\<mapsto> b]\n               in a\\<cdot>(Discr (cnt, [DI (a1 + a2)], ve, b')) \\<union>\n                  {((c, \\<beta>), cnt)}\n          else \\<bottom>\n      | (DP (Plus c), DI a1 # DI a2 # cnt # aa # lista, bb) \\<Rightarrow>\n          \\<bottom>\n      | (DP (Plus c), DI a1 # _ # lista, bb) \\<Rightarrow> \\<bottom>\n      | (DP (Plus c), _ # list, bb) \\<Rightarrow> \\<bottom>\n      | (DP (prim.If ct cf), [], bb) \\<Rightarrow> \\<bottom>\n      | (DP (prim.If ct cf), [DI v], bb) \\<Rightarrow> \\<bottom>\n      | (DP (prim.If ct cf), [DI v, contt], bb) \\<Rightarrow> \\<bottom>\n      | (DP (prim.If ct cf), [DI v, contt, contf], ve, b) \\<Rightarrow>\n          if isProc contt \\<and> isProc contf\n          then if v \\<noteq> 0\n               then let b' = nb b ct; \\<beta> = [ct \\<mapsto> b]\n                    in a\\<cdot>(Discr (contt, [], ve, b')) \\<union>\n                       {((ct, \\<beta>), contt)}\n               else let b' = nb b cf; \\<beta> = [cf \\<mapsto> b]\n                    in a\\<cdot>(Discr (contf, [], ve, b')) \\<union>\n                       {((cf, \\<beta>), contf)}\n          else \\<bottom>\n      | (DP (prim.If ct cf), DI v # contt # contf # ab # lista,\n         bb) \\<Rightarrow>\n          \\<bottom>\n      | (DP (prim.If ct cf), _ # list, bb) \\<Rightarrow> \\<bottom>\n      | (Stop, [], bb) \\<Rightarrow> \\<bottom>\n      | (Stop, [DI i], x, xa) \\<Rightarrow> {}\n      | (Stop, DI i # a # lista, bb) \\<Rightarrow> \\<bottom>\n      | (Stop, _ # list, bb) \\<Rightarrow> \\<bottom>)\\<cdot>\n  (Discr (d, ds, ve, ba)).\n                             \\<exists>b'.\n                                b' \\<in> ran \\<beta> \\<and> ba \\<le> b')\n 2. \\<And>a b ve ba c \\<beta>'.\n       \\<lbrakk>\\<And>d ds ve b.\n                   \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n                    \\<forall>b'\\<in>contours_in_d d. b' < b;\n                    \\<forall>d'\\<in>set ds.\n                       \\<forall>b'\\<in>contours_in_d d'. b' < b\\<rbrakk>\n                   \\<Longrightarrow> single_valued\n(a\\<cdot>(Discr (d, ds, ve, b))) \\<and>\n                                     (\\<forall>((lab, \\<beta>), t)\n         \\<in>a\\<cdot>(Discr (d, ds, ve, b)).\n   \\<exists>b'. b' \\<in> ran \\<beta> \\<and> b \\<le> b');\n        \\<And>ve ba c \\<beta>'.\n           \\<lbrakk>ba \\<in> ran \\<beta>';\n            \\<forall>b'\\<in>ran \\<beta>'. b' \\<le> ba;\n            \\<forall>b'\\<in>contours_in_ve ve. b' \\<le> ba\\<rbrakk>\n           \\<Longrightarrow> single_valued\n                              (b\\<cdot>(Discr (c, \\<beta>', ve, ba))) \\<and>\n                             (\\<forall>((lab, \\<beta>), t)\n \\<in>b\\<cdot>(Discr (c, \\<beta>', ve, ba)).\n                                 \\<exists>b'.\n                                    b' \\<in> ran \\<beta> \\<and>\n                                    ba \\<le> b');\n        ba \\<in> ran \\<beta>'; \\<forall>b'\\<in>ran \\<beta>'. b' \\<le> ba;\n        \\<forall>b'\\<in>contours_in_ve ve. b' \\<le> ba\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          ((\\<Lambda> cstate.\n                               case undiscr cstate of\n                               (App lab f vs, \\<beta>, ve, b) \\<Rightarrow>\n                                 let f' = \\<A> f \\<beta> ve;\n                                     as =\n map (\\<lambda>v. \\<A> v \\<beta> ve) vs;\n                                     b' = nb b lab\n                                 in if isProc f'\n                                    then a\\<cdot>\n   (Discr (f', as, ve, b')) \\<union>\n   {((lab, \\<beta>), f')}\n                                    else \\<bottom>\n                               | (call.Let lab ls c', \\<beta>, ve,\n                                  ba) \\<Rightarrow>\n                                   let b' = nb ba lab;\n \\<beta>' = \\<beta>(lab \\<mapsto> b');\n ve' =\n   ve ++\n   map_of (map (\\<lambda>(v, l). ((v, b'), \\<A> (L l) \\<beta>' ve)) ls)\n                                   in b\\<cdot>\n(Discr (c', \\<beta>', ve', b')))\\<cdot>\n                           (Discr (c, \\<beta>', ve, ba))) \\<and>\n                         (\\<forall>((lab, \\<beta>), t)\n                                   \\<in>(\\<Lambda> cstate.\n      case undiscr cstate of\n      (App lab f vs, \\<beta>, ve, b) \\<Rightarrow>\n        let f' = \\<A> f \\<beta> ve;\n            as = map (\\<lambda>v. \\<A> v \\<beta> ve) vs; b' = nb b lab\n        in if isProc f'\n           then a\\<cdot>(Discr (f', as, ve, b')) \\<union>\n                {((lab, \\<beta>), f')}\n           else \\<bottom>\n      | (call.Let lab ls c', \\<beta>, ve, ba) \\<Rightarrow>\n          let b' = nb ba lab; \\<beta>' = \\<beta>(lab \\<mapsto> b');\n              ve' =\n                ve ++\n                map_of\n                 (map (\\<lambda>(v, l). ((v, b'), \\<A> (L l) \\<beta>' ve))\n                   ls)\n          in b\\<cdot>(Discr (c', \\<beta>', ve', b')))\\<cdot>\n  (Discr (c, \\<beta>', ve, ba)).\n                             \\<exists>b'.\n                                b' \\<in> ran \\<beta> \\<and> ba \\<le> b')", "thus ?case"], ["proof (prove)\nusing this:\n  \\<forall>b'\\<in>contours_in_ve ve. b' < b\n  \\<forall>b'\\<in>contours_in_d d. b' < b\n  \\<forall>d'\\<in>set ds. \\<forall>b'\\<in>contours_in_d d'. b' < b\n\ngoal (1 subgoal):\n 1. single_valued\n     ((\\<Lambda> fstate.\n          case undiscr fstate of (DI int, ba) \\<Rightarrow> \\<bottom>\n          | (DC (Lambda lab vs c, \\<beta>), as, ve, b) \\<Rightarrow>\n              if length vs = length as\n              then let \\<beta>' = \\<beta>(lab \\<mapsto> b);\n                       ve' = ve(map (\\<lambda>v. (v, b)) vs [\\<mapsto>] as)\n                   in evalC\\<cdot>(Discr (c, \\<beta>', ve', b))\n              else \\<bottom>\n          | (DP (Plus c), [], bb) \\<Rightarrow> \\<bottom>\n          | (DP (Plus c), [DI a1], bb) \\<Rightarrow> \\<bottom>\n          | (DP (Plus c), [DI a1, DI a2], bb) \\<Rightarrow> \\<bottom>\n          | (DP (Plus c), [DI a1, DI a2, cnt], ve, b) \\<Rightarrow>\n              if isProc cnt\n              then let b' = nb b c; \\<beta> = [c \\<mapsto> b]\n                   in evalF\\<cdot>\n                      (Discr (cnt, [DI (a1 + a2)], ve, b')) \\<union>\n                      {((c, \\<beta>), cnt)}\n              else \\<bottom>\n          | (DP (Plus c), DI a1 # DI a2 # cnt # aa # lista,\n             bb) \\<Rightarrow>\n              \\<bottom>\n          | (DP (Plus c), DI a1 # _ # lista, bb) \\<Rightarrow> \\<bottom>\n          | (DP (Plus c), _ # list, bb) \\<Rightarrow> \\<bottom>\n          | (DP (prim.If ct cf), [], bb) \\<Rightarrow> \\<bottom>\n          | (DP (prim.If ct cf), [DI v], bb) \\<Rightarrow> \\<bottom>\n          | (DP (prim.If ct cf), [DI v, contt], bb) \\<Rightarrow> \\<bottom>\n          | (DP (prim.If ct cf), [DI v, contt, contf], ve, b) \\<Rightarrow>\n              if isProc contt \\<and> isProc contf\n              then if v \\<noteq> 0\n                   then let b' = nb b ct; \\<beta> = [ct \\<mapsto> b]\n                        in evalF\\<cdot>(Discr (contt, [], ve, b')) \\<union>\n                           {((ct, \\<beta>), contt)}\n                   else let b' = nb b cf; \\<beta> = [cf \\<mapsto> b]\n                        in evalF\\<cdot>(Discr (contf, [], ve, b')) \\<union>\n                           {((cf, \\<beta>), contf)}\n              else \\<bottom>\n          | (DP (prim.If ct cf), DI v # contt # contf # ab # lista,\n             bb) \\<Rightarrow>\n              \\<bottom>\n          | (DP (prim.If ct cf), _ # list, bb) \\<Rightarrow> \\<bottom>\n          | (Stop, [], bb) \\<Rightarrow> \\<bottom>\n          | (Stop, [DI i], x, xa) \\<Rightarrow> {}\n          | (Stop, DI i # a # lista, bb) \\<Rightarrow> \\<bottom>\n          | (Stop, _ # list, bb) \\<Rightarrow> \\<bottom>)\\<cdot>\n      (Discr (d, ds, ve, b))) \\<and>\n    (\\<forall>a\\<in>(\\<Lambda> fstate.\n                        case undiscr fstate of\n                        (DI int, ba) \\<Rightarrow> \\<bottom>\n                        | (DC (Lambda lab vs c, \\<beta>), as, ve,\n                           b) \\<Rightarrow>\n                            if length vs = length as\n                            then let \\<beta>' = \\<beta>(lab \\<mapsto> b);\n                                     ve' = ve(map (\\<lambda>v. (v, b)) vs \n [\\<mapsto>] as)\n                                 in evalC\\<cdot>\n                                    (Discr (c, \\<beta>', ve', b))\n                            else \\<bottom>\n                        | (DP (Plus c), [], bb) \\<Rightarrow> \\<bottom>\n                        | (DP (Plus c), [DI a1], bb) \\<Rightarrow> \\<bottom>\n                        | (DP (Plus c), [DI a1, DI a2], bb) \\<Rightarrow>\n                            \\<bottom>\n                        | (DP (Plus c), [DI a1, DI a2, cnt], ve,\n                           b) \\<Rightarrow>\n                            if isProc cnt\n                            then let b' = nb b c; \\<beta> = [c \\<mapsto> b]\n                                 in evalF\\<cdot>\n                                    (Discr\n(cnt, [DI (a1 + a2)], ve, b')) \\<union>\n                                    {((c, \\<beta>), cnt)}\n                            else \\<bottom>\n                        | (DP (Plus c), DI a1 # DI a2 # cnt # aa # lista,\n                           bb) \\<Rightarrow>\n                            \\<bottom>\n                        | (DP (Plus c), DI a1 # _ # lista, bb) \\<Rightarrow>\n                            \\<bottom>\n                        | (DP (Plus c), _ # list, bb) \\<Rightarrow>\n                            \\<bottom>\n                        | (DP (prim.If ct cf), [], bb) \\<Rightarrow>\n                            \\<bottom>\n                        | (DP (prim.If ct cf), [DI v], bb) \\<Rightarrow>\n                            \\<bottom>\n                        | (DP (prim.If ct cf), [DI v, contt],\n                           bb) \\<Rightarrow>\n                            \\<bottom>\n                        | (DP (prim.If ct cf), [DI v, contt, contf], ve,\n                           b) \\<Rightarrow>\n                            if isProc contt \\<and> isProc contf\n                            then if v \\<noteq> 0\n                                 then let b' = nb b ct;\n    \\<beta> = [ct \\<mapsto> b]\nin evalF\\<cdot>(Discr (contt, [], ve, b')) \\<union> {((ct, \\<beta>), contt)}\n                                 else let b' = nb b cf;\n    \\<beta> = [cf \\<mapsto> b]\nin evalF\\<cdot>(Discr (contf, [], ve, b')) \\<union> {((cf, \\<beta>), contf)}\n                            else \\<bottom>\n                        | (DP (prim.If ct cf),\n                           DI v # contt # contf # ab # lista,\n                           bb) \\<Rightarrow>\n                            \\<bottom>\n                        | (DP (prim.If ct cf), _ # list, bb) \\<Rightarrow>\n                            \\<bottom>\n                        | (Stop, [], bb) \\<Rightarrow> \\<bottom>\n                        | (Stop, [DI i], x, xa) \\<Rightarrow> {}\n                        | (Stop, DI i # a # lista, bb) \\<Rightarrow>\n                            \\<bottom>\n                        | (Stop, _ # list, bb) \\<Rightarrow>\n                            \\<bottom>)\\<cdot>\n                    (Discr (d, ds, ve, b)).\n        case a of\n        (a, b) \\<Rightarrow>\n          (case a of\n           (lab, \\<beta>) \\<Rightarrow>\n             \\<lambda>t.\n                \\<exists>b'. b' \\<in> ran \\<beta> \\<and> b \\<le> b')\n           b)", "proof (cases \"(d,ds,ve,b)\" rule:fstate_case, auto simp del:Un_insert_left Un_insert_right)"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>x2a x1a x2aa x3.\n       \\<lbrakk>d = DC (Lambda x1a x2aa x3, x2a); length x2aa = length ds;\n        \\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        \\<forall>b'\\<in>ran x2a. b' < b;\n        \\<forall>d'\\<in>set ds.\n           \\<forall>b'\\<in>contours_in_d d'. b' < b\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (evalC\\<cdot>\n                           (Discr\n                             (x3, x2a(x1a \\<mapsto> b), ve\n                              (map (\\<lambda>v. (v, b)) x2aa [\\<mapsto>]\n                              ds), b)))\n 2. \\<And>x2a x1a x2aa x3 a b bb.\n       \\<lbrakk>d = DC (Lambda x1a x2aa x3, x2a); length x2aa = length ds;\n        \\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        \\<forall>b'\\<in>ran x2a. b' < b;\n        \\<forall>d'\\<in>set ds. \\<forall>b'\\<in>contours_in_d d'. b' < b;\n        ((a, b), bb)\n        \\<in> evalC\\<cdot>\n              (Discr\n                (x3, x2a(x1a \\<mapsto> b), ve(map (\\<lambda>v. (v, b)) x2aa \n                 [\\<mapsto>] ds), b))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran b \\<and> b \\<le> b'\n 3. \\<And>x1 x1a x1aa x21b.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21b. b' < b; d = DP (Plus x1);\n        ds = [DI x1a, DI x1aa, x21b]; isProc x21b\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (evalF\\<cdot>\n                           (Discr\n                             (x21b, [DI (x1a + x1aa)], ve,\n                              nb b x1)) \\<union>\n                           {((x1, [x1 \\<mapsto> b]), x21b)})\n 4. \\<And>x1 x1a x1aa x21b aa baa bb.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21b. b' < b; d = DP (Plus x1);\n        ds = [DI x1a, DI x1aa, x21b]; isProc x21b;\n        ((aa, baa), bb)\n        \\<in> evalF\\<cdot>\n              (Discr (x21b, [DI (x1a + x1aa)], ve, nb b x1))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran baa \\<and> b \\<le> b'\n 5. \\<And>x21 x22 x1 x21aa x21aaa.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI x1, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; x1 \\<noteq> 0;\n        isProc x21aa; isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (evalF\\<cdot>\n                           (Discr (x21aa, [], ve, nb b x21)) \\<union>\n                           {((x21, [x21 \\<mapsto> b]), x21aa)})\n 6. \\<And>x21 x22 x1 x21aa x21aaa aa baa bb.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI x1, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; x1 \\<noteq> 0;\n        isProc x21aa; isProc x21aaa;\n        ((aa, baa), bb)\n        \\<in> evalF\\<cdot>(Discr (x21aa, [], ve, nb b x21))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran baa \\<and> b \\<le> b'\n 7. \\<And>x21 x22 x21aa x21aaa.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; isProc x21aa;\n        isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (evalF\\<cdot>\n                           (Discr (x21aaa, [], ve, nb b x22)) \\<union>\n                           {((x22, [x22 \\<mapsto> b]), x21aaa)})\n 8. \\<And>x21 x22 x21aa x21aaa aa baa bb.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; isProc x21aa;\n        isProc x21aaa;\n        ((aa, baa), bb)\n        \\<in> evalF\\<cdot>(Discr (x21aaa, [], ve, nb b x22))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran baa \\<and> b \\<le> b'", "txt \\<open>Case Closure\\<close>"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>x2a x1a x2aa x3.\n       \\<lbrakk>d = DC (Lambda x1a x2aa x3, x2a); length x2aa = length ds;\n        \\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        \\<forall>b'\\<in>ran x2a. b' < b;\n        \\<forall>d'\\<in>set ds.\n           \\<forall>b'\\<in>contours_in_d d'. b' < b\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (evalC\\<cdot>\n                           (Discr\n                             (x3, x2a(x1a \\<mapsto> b), ve\n                              (map (\\<lambda>v. (v, b)) x2aa [\\<mapsto>]\n                              ds), b)))\n 2. \\<And>x2a x1a x2aa x3 a b bb.\n       \\<lbrakk>d = DC (Lambda x1a x2aa x3, x2a); length x2aa = length ds;\n        \\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        \\<forall>b'\\<in>ran x2a. b' < b;\n        \\<forall>d'\\<in>set ds. \\<forall>b'\\<in>contours_in_d d'. b' < b;\n        ((a, b), bb)\n        \\<in> evalC\\<cdot>\n              (Discr\n                (x3, x2a(x1a \\<mapsto> b), ve(map (\\<lambda>v. (v, b)) x2aa \n                 [\\<mapsto>] ds), b))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran b \\<and> b \\<le> b'\n 3. \\<And>x1 x1a x1aa x21b.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21b. b' < b; d = DP (Plus x1);\n        ds = [DI x1a, DI x1aa, x21b]; isProc x21b\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (evalF\\<cdot>\n                           (Discr\n                             (x21b, [DI (x1a + x1aa)], ve,\n                              nb b x1)) \\<union>\n                           {((x1, [x1 \\<mapsto> b]), x21b)})\n 4. \\<And>x1 x1a x1aa x21b aa baa bb.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21b. b' < b; d = DP (Plus x1);\n        ds = [DI x1a, DI x1aa, x21b]; isProc x21b;\n        ((aa, baa), bb)\n        \\<in> evalF\\<cdot>\n              (Discr (x21b, [DI (x1a + x1aa)], ve, nb b x1))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran baa \\<and> b \\<le> b'\n 5. \\<And>x21 x22 x1 x21aa x21aaa.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI x1, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; x1 \\<noteq> 0;\n        isProc x21aa; isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (evalF\\<cdot>\n                           (Discr (x21aa, [], ve, nb b x21)) \\<union>\n                           {((x21, [x21 \\<mapsto> b]), x21aa)})\n 6. \\<And>x21 x22 x1 x21aa x21aaa aa baa bb.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI x1, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; x1 \\<noteq> 0;\n        isProc x21aa; isProc x21aaa;\n        ((aa, baa), bb)\n        \\<in> evalF\\<cdot>(Discr (x21aa, [], ve, nb b x21))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran baa \\<and> b \\<le> b'\n 7. \\<And>x21 x22 x21aa x21aaa.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; isProc x21aa;\n        isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (evalF\\<cdot>\n                           (Discr (x21aaa, [], ve, nb b x22)) \\<union>\n                           {((x22, [x22 \\<mapsto> b]), x21aaa)})\n 8. \\<And>x21 x22 x21aa x21aaa aa baa bb.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; isProc x21aa;\n        isProc x21aaa;\n        ((aa, baa), bb)\n        \\<in> evalF\\<cdot>(Discr (x21aaa, [], ve, nb b x22))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran baa \\<and> b \\<le> b'", "fix lab' and vs :: \"var list\" and c and \\<beta>' :: benv"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>x2a x1a x2aa x3.\n       \\<lbrakk>d = DC (Lambda x1a x2aa x3, x2a); length x2aa = length ds;\n        \\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        \\<forall>b'\\<in>ran x2a. b' < b;\n        \\<forall>d'\\<in>set ds.\n           \\<forall>b'\\<in>contours_in_d d'. b' < b\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (evalC\\<cdot>\n                           (Discr\n                             (x3, x2a(x1a \\<mapsto> b), ve\n                              (map (\\<lambda>v. (v, b)) x2aa [\\<mapsto>]\n                              ds), b)))\n 2. \\<And>x2a x1a x2aa x3 a b bb.\n       \\<lbrakk>d = DC (Lambda x1a x2aa x3, x2a); length x2aa = length ds;\n        \\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        \\<forall>b'\\<in>ran x2a. b' < b;\n        \\<forall>d'\\<in>set ds. \\<forall>b'\\<in>contours_in_d d'. b' < b;\n        ((a, b), bb)\n        \\<in> evalC\\<cdot>\n              (Discr\n                (x3, x2a(x1a \\<mapsto> b), ve(map (\\<lambda>v. (v, b)) x2aa \n                 [\\<mapsto>] ds), b))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran b \\<and> b \\<le> b'\n 3. \\<And>x1 x1a x1aa x21b.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21b. b' < b; d = DP (Plus x1);\n        ds = [DI x1a, DI x1aa, x21b]; isProc x21b\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (evalF\\<cdot>\n                           (Discr\n                             (x21b, [DI (x1a + x1aa)], ve,\n                              nb b x1)) \\<union>\n                           {((x1, [x1 \\<mapsto> b]), x21b)})\n 4. \\<And>x1 x1a x1aa x21b aa baa bb.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21b. b' < b; d = DP (Plus x1);\n        ds = [DI x1a, DI x1aa, x21b]; isProc x21b;\n        ((aa, baa), bb)\n        \\<in> evalF\\<cdot>\n              (Discr (x21b, [DI (x1a + x1aa)], ve, nb b x1))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran baa \\<and> b \\<le> b'\n 5. \\<And>x21 x22 x1 x21aa x21aaa.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI x1, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; x1 \\<noteq> 0;\n        isProc x21aa; isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (evalF\\<cdot>\n                           (Discr (x21aa, [], ve, nb b x21)) \\<union>\n                           {((x21, [x21 \\<mapsto> b]), x21aa)})\n 6. \\<And>x21 x22 x1 x21aa x21aaa aa baa bb.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI x1, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; x1 \\<noteq> 0;\n        isProc x21aa; isProc x21aaa;\n        ((aa, baa), bb)\n        \\<in> evalF\\<cdot>(Discr (x21aa, [], ve, nb b x21))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran baa \\<and> b \\<le> b'\n 7. \\<And>x21 x22 x21aa x21aaa.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; isProc x21aa;\n        isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (evalF\\<cdot>\n                           (Discr (x21aaa, [], ve, nb b x22)) \\<union>\n                           {((x22, [x22 \\<mapsto> b]), x21aaa)})\n 8. \\<And>x21 x22 x21aa x21aaa aa baa bb.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; isProc x21aa;\n        isProc x21aaa;\n        ((aa, baa), bb)\n        \\<in> evalF\\<cdot>(Discr (x21aaa, [], ve, nb b x22))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran baa \\<and> b \\<le> b'", "assume prem_d: \"\\<forall>b'\\<in>ran \\<beta>'. b' < b\""], ["proof (state)\nthis:\n  \\<forall>b'\\<in>ran \\<beta>'. b' < b\n\ngoal (8 subgoals):\n 1. \\<And>x2a x1a x2aa x3.\n       \\<lbrakk>d = DC (Lambda x1a x2aa x3, x2a); length x2aa = length ds;\n        \\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        \\<forall>b'\\<in>ran x2a. b' < b;\n        \\<forall>d'\\<in>set ds.\n           \\<forall>b'\\<in>contours_in_d d'. b' < b\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (evalC\\<cdot>\n                           (Discr\n                             (x3, x2a(x1a \\<mapsto> b), ve\n                              (map (\\<lambda>v. (v, b)) x2aa [\\<mapsto>]\n                              ds), b)))\n 2. \\<And>x2a x1a x2aa x3 a b bb.\n       \\<lbrakk>d = DC (Lambda x1a x2aa x3, x2a); length x2aa = length ds;\n        \\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        \\<forall>b'\\<in>ran x2a. b' < b;\n        \\<forall>d'\\<in>set ds. \\<forall>b'\\<in>contours_in_d d'. b' < b;\n        ((a, b), bb)\n        \\<in> evalC\\<cdot>\n              (Discr\n                (x3, x2a(x1a \\<mapsto> b), ve(map (\\<lambda>v. (v, b)) x2aa \n                 [\\<mapsto>] ds), b))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran b \\<and> b \\<le> b'\n 3. \\<And>x1 x1a x1aa x21b.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21b. b' < b; d = DP (Plus x1);\n        ds = [DI x1a, DI x1aa, x21b]; isProc x21b\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (evalF\\<cdot>\n                           (Discr\n                             (x21b, [DI (x1a + x1aa)], ve,\n                              nb b x1)) \\<union>\n                           {((x1, [x1 \\<mapsto> b]), x21b)})\n 4. \\<And>x1 x1a x1aa x21b aa baa bb.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21b. b' < b; d = DP (Plus x1);\n        ds = [DI x1a, DI x1aa, x21b]; isProc x21b;\n        ((aa, baa), bb)\n        \\<in> evalF\\<cdot>\n              (Discr (x21b, [DI (x1a + x1aa)], ve, nb b x1))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran baa \\<and> b \\<le> b'\n 5. \\<And>x21 x22 x1 x21aa x21aaa.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI x1, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; x1 \\<noteq> 0;\n        isProc x21aa; isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (evalF\\<cdot>\n                           (Discr (x21aa, [], ve, nb b x21)) \\<union>\n                           {((x21, [x21 \\<mapsto> b]), x21aa)})\n 6. \\<And>x21 x22 x1 x21aa x21aaa aa baa bb.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI x1, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; x1 \\<noteq> 0;\n        isProc x21aa; isProc x21aaa;\n        ((aa, baa), bb)\n        \\<in> evalF\\<cdot>(Discr (x21aa, [], ve, nb b x21))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran baa \\<and> b \\<le> b'\n 7. \\<And>x21 x22 x21aa x21aaa.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; isProc x21aa;\n        isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (evalF\\<cdot>\n                           (Discr (x21aaa, [], ve, nb b x22)) \\<union>\n                           {((x22, [x22 \\<mapsto> b]), x21aaa)})\n 8. \\<And>x21 x22 x21aa x21aaa aa baa bb.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; isProc x21aa;\n        isProc x21aaa;\n        ((aa, baa), bb)\n        \\<in> evalF\\<cdot>(Discr (x21aaa, [], ve, nb b x22))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran baa \\<and> b \\<le> b'", "assume eq_length: \"length vs = length ds\""], ["proof (state)\nthis:\n  length vs = length ds\n\ngoal (8 subgoals):\n 1. \\<And>x2a x1a x2aa x3.\n       \\<lbrakk>d = DC (Lambda x1a x2aa x3, x2a); length x2aa = length ds;\n        \\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        \\<forall>b'\\<in>ran x2a. b' < b;\n        \\<forall>d'\\<in>set ds.\n           \\<forall>b'\\<in>contours_in_d d'. b' < b\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (evalC\\<cdot>\n                           (Discr\n                             (x3, x2a(x1a \\<mapsto> b), ve\n                              (map (\\<lambda>v. (v, b)) x2aa [\\<mapsto>]\n                              ds), b)))\n 2. \\<And>x2a x1a x2aa x3 a b bb.\n       \\<lbrakk>d = DC (Lambda x1a x2aa x3, x2a); length x2aa = length ds;\n        \\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        \\<forall>b'\\<in>ran x2a. b' < b;\n        \\<forall>d'\\<in>set ds. \\<forall>b'\\<in>contours_in_d d'. b' < b;\n        ((a, b), bb)\n        \\<in> evalC\\<cdot>\n              (Discr\n                (x3, x2a(x1a \\<mapsto> b), ve(map (\\<lambda>v. (v, b)) x2aa \n                 [\\<mapsto>] ds), b))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran b \\<and> b \\<le> b'\n 3. \\<And>x1 x1a x1aa x21b.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21b. b' < b; d = DP (Plus x1);\n        ds = [DI x1a, DI x1aa, x21b]; isProc x21b\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (evalF\\<cdot>\n                           (Discr\n                             (x21b, [DI (x1a + x1aa)], ve,\n                              nb b x1)) \\<union>\n                           {((x1, [x1 \\<mapsto> b]), x21b)})\n 4. \\<And>x1 x1a x1aa x21b aa baa bb.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21b. b' < b; d = DP (Plus x1);\n        ds = [DI x1a, DI x1aa, x21b]; isProc x21b;\n        ((aa, baa), bb)\n        \\<in> evalF\\<cdot>\n              (Discr (x21b, [DI (x1a + x1aa)], ve, nb b x1))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran baa \\<and> b \\<le> b'\n 5. \\<And>x21 x22 x1 x21aa x21aaa.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI x1, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; x1 \\<noteq> 0;\n        isProc x21aa; isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (evalF\\<cdot>\n                           (Discr (x21aa, [], ve, nb b x21)) \\<union>\n                           {((x21, [x21 \\<mapsto> b]), x21aa)})\n 6. \\<And>x21 x22 x1 x21aa x21aaa aa baa bb.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI x1, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; x1 \\<noteq> 0;\n        isProc x21aa; isProc x21aaa;\n        ((aa, baa), bb)\n        \\<in> evalF\\<cdot>(Discr (x21aa, [], ve, nb b x21))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran baa \\<and> b \\<le> b'\n 7. \\<And>x21 x22 x21aa x21aaa.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; isProc x21aa;\n        isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (evalF\\<cdot>\n                           (Discr (x21aaa, [], ve, nb b x22)) \\<union>\n                           {((x22, [x22 \\<mapsto> b]), x21aaa)})\n 8. \\<And>x21 x22 x21aa x21aaa aa baa bb.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; isProc x21aa;\n        isProc x21aaa;\n        ((aa, baa), bb)\n        \\<in> evalF\\<cdot>(Discr (x21aaa, [], ve, nb b x22))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran baa \\<and> b \\<le> b'", "have new: \"b\\<in>ran (\\<beta>'(lab' \\<mapsto> b))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b \\<in> ran (\\<beta>'(lab' \\<mapsto> b))", "by simp"], ["proof (state)\nthis:\n  b \\<in> ran (\\<beta>'(lab' \\<mapsto> b))\n\ngoal (8 subgoals):\n 1. \\<And>x2a x1a x2aa x3.\n       \\<lbrakk>d = DC (Lambda x1a x2aa x3, x2a); length x2aa = length ds;\n        \\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        \\<forall>b'\\<in>ran x2a. b' < b;\n        \\<forall>d'\\<in>set ds.\n           \\<forall>b'\\<in>contours_in_d d'. b' < b\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (evalC\\<cdot>\n                           (Discr\n                             (x3, x2a(x1a \\<mapsto> b), ve\n                              (map (\\<lambda>v. (v, b)) x2aa [\\<mapsto>]\n                              ds), b)))\n 2. \\<And>x2a x1a x2aa x3 a b bb.\n       \\<lbrakk>d = DC (Lambda x1a x2aa x3, x2a); length x2aa = length ds;\n        \\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        \\<forall>b'\\<in>ran x2a. b' < b;\n        \\<forall>d'\\<in>set ds. \\<forall>b'\\<in>contours_in_d d'. b' < b;\n        ((a, b), bb)\n        \\<in> evalC\\<cdot>\n              (Discr\n                (x3, x2a(x1a \\<mapsto> b), ve(map (\\<lambda>v. (v, b)) x2aa \n                 [\\<mapsto>] ds), b))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran b \\<and> b \\<le> b'\n 3. \\<And>x1 x1a x1aa x21b.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21b. b' < b; d = DP (Plus x1);\n        ds = [DI x1a, DI x1aa, x21b]; isProc x21b\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (evalF\\<cdot>\n                           (Discr\n                             (x21b, [DI (x1a + x1aa)], ve,\n                              nb b x1)) \\<union>\n                           {((x1, [x1 \\<mapsto> b]), x21b)})\n 4. \\<And>x1 x1a x1aa x21b aa baa bb.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21b. b' < b; d = DP (Plus x1);\n        ds = [DI x1a, DI x1aa, x21b]; isProc x21b;\n        ((aa, baa), bb)\n        \\<in> evalF\\<cdot>\n              (Discr (x21b, [DI (x1a + x1aa)], ve, nb b x1))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran baa \\<and> b \\<le> b'\n 5. \\<And>x21 x22 x1 x21aa x21aaa.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI x1, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; x1 \\<noteq> 0;\n        isProc x21aa; isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (evalF\\<cdot>\n                           (Discr (x21aa, [], ve, nb b x21)) \\<union>\n                           {((x21, [x21 \\<mapsto> b]), x21aa)})\n 6. \\<And>x21 x22 x1 x21aa x21aaa aa baa bb.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI x1, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; x1 \\<noteq> 0;\n        isProc x21aa; isProc x21aaa;\n        ((aa, baa), bb)\n        \\<in> evalF\\<cdot>(Discr (x21aa, [], ve, nb b x21))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran baa \\<and> b \\<le> b'\n 7. \\<And>x21 x22 x21aa x21aaa.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; isProc x21aa;\n        isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (evalF\\<cdot>\n                           (Discr (x21aaa, [], ve, nb b x22)) \\<union>\n                           {((x22, [x22 \\<mapsto> b]), x21aaa)})\n 8. \\<And>x21 x22 x21aa x21aaa aa baa bb.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; isProc x21aa;\n        isProc x21aaa;\n        ((aa, baa), bb)\n        \\<in> evalF\\<cdot>(Discr (x21aaa, [], ve, nb b x22))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran baa \\<and> b \\<le> b'", "have b_dom_beta: \"\\<forall>b'\\<in> ran (\\<beta>'(lab' \\<mapsto> b)). b' \\<le> b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>b'\\<in>ran (\\<beta>'(lab' \\<mapsto> b)). b' \\<le> b", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>b'.\n       b' \\<in> ran (\\<beta>'(lab' \\<mapsto> b)) \\<Longrightarrow>\n       b' \\<le> b", "fix b'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>b'.\n       b' \\<in> ran (\\<beta>'(lab' \\<mapsto> b)) \\<Longrightarrow>\n       b' \\<le> b", "assume \"b' \\<in> ran (\\<beta>'(lab' \\<mapsto> b))\""], ["proof (state)\nthis:\n  b' \\<in> ran (\\<beta>'(lab' \\<mapsto> b))\n\ngoal (1 subgoal):\n 1. \\<And>b'.\n       b' \\<in> ran (\\<beta>'(lab' \\<mapsto> b)) \\<Longrightarrow>\n       b' \\<le> b", "hence \"b' \\<in> ran \\<beta>' \\<or> b' \\<le> b\""], ["proof (prove)\nusing this:\n  b' \\<in> ran (\\<beta>'(lab' \\<mapsto> b))\n\ngoal (1 subgoal):\n 1. b' \\<in> ran \\<beta>' \\<or> b' \\<le> b", "by (auto dest:ran_upd[THEN subsetD])"], ["proof (state)\nthis:\n  b' \\<in> ran \\<beta>' \\<or> b' \\<le> b\n\ngoal (1 subgoal):\n 1. \\<And>b'.\n       b' \\<in> ran (\\<beta>'(lab' \\<mapsto> b)) \\<Longrightarrow>\n       b' \\<le> b", "thus \"b' \\<le> b\""], ["proof (prove)\nusing this:\n  b' \\<in> ran \\<beta>' \\<or> b' \\<le> b\n\ngoal (1 subgoal):\n 1. b' \\<le> b", "using prem_d"], ["proof (prove)\nusing this:\n  b' \\<in> ran \\<beta>' \\<or> b' \\<le> b\n  \\<forall>b'\\<in>ran \\<beta>'. b' < b\n\ngoal (1 subgoal):\n 1. b' \\<le> b", "by auto"], ["proof (state)\nthis:\n  b' \\<le> b\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>b'\\<in>ran (\\<beta>'(lab' \\<mapsto> b)). b' \\<le> b\n\ngoal (8 subgoals):\n 1. \\<And>x2a x1a x2aa x3.\n       \\<lbrakk>d = DC (Lambda x1a x2aa x3, x2a); length x2aa = length ds;\n        \\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        \\<forall>b'\\<in>ran x2a. b' < b;\n        \\<forall>d'\\<in>set ds.\n           \\<forall>b'\\<in>contours_in_d d'. b' < b\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (evalC\\<cdot>\n                           (Discr\n                             (x3, x2a(x1a \\<mapsto> b), ve\n                              (map (\\<lambda>v. (v, b)) x2aa [\\<mapsto>]\n                              ds), b)))\n 2. \\<And>x2a x1a x2aa x3 a b bb.\n       \\<lbrakk>d = DC (Lambda x1a x2aa x3, x2a); length x2aa = length ds;\n        \\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        \\<forall>b'\\<in>ran x2a. b' < b;\n        \\<forall>d'\\<in>set ds. \\<forall>b'\\<in>contours_in_d d'. b' < b;\n        ((a, b), bb)\n        \\<in> evalC\\<cdot>\n              (Discr\n                (x3, x2a(x1a \\<mapsto> b), ve(map (\\<lambda>v. (v, b)) x2aa \n                 [\\<mapsto>] ds), b))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran b \\<and> b \\<le> b'\n 3. \\<And>x1 x1a x1aa x21b.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21b. b' < b; d = DP (Plus x1);\n        ds = [DI x1a, DI x1aa, x21b]; isProc x21b\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (evalF\\<cdot>\n                           (Discr\n                             (x21b, [DI (x1a + x1aa)], ve,\n                              nb b x1)) \\<union>\n                           {((x1, [x1 \\<mapsto> b]), x21b)})\n 4. \\<And>x1 x1a x1aa x21b aa baa bb.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21b. b' < b; d = DP (Plus x1);\n        ds = [DI x1a, DI x1aa, x21b]; isProc x21b;\n        ((aa, baa), bb)\n        \\<in> evalF\\<cdot>\n              (Discr (x21b, [DI (x1a + x1aa)], ve, nb b x1))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran baa \\<and> b \\<le> b'\n 5. \\<And>x21 x22 x1 x21aa x21aaa.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI x1, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; x1 \\<noteq> 0;\n        isProc x21aa; isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (evalF\\<cdot>\n                           (Discr (x21aa, [], ve, nb b x21)) \\<union>\n                           {((x21, [x21 \\<mapsto> b]), x21aa)})\n 6. \\<And>x21 x22 x1 x21aa x21aaa aa baa bb.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI x1, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; x1 \\<noteq> 0;\n        isProc x21aa; isProc x21aaa;\n        ((aa, baa), bb)\n        \\<in> evalF\\<cdot>(Discr (x21aa, [], ve, nb b x21))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran baa \\<and> b \\<le> b'\n 7. \\<And>x21 x22 x21aa x21aaa.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; isProc x21aa;\n        isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (evalF\\<cdot>\n                           (Discr (x21aaa, [], ve, nb b x22)) \\<union>\n                           {((x22, [x22 \\<mapsto> b]), x21aaa)})\n 8. \\<And>x21 x22 x21aa x21aaa aa baa bb.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; isProc x21aa;\n        isProc x21aaa;\n        ((aa, baa), bb)\n        \\<in> evalF\\<cdot>(Discr (x21aaa, [], ve, nb b x22))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran baa \\<and> b \\<le> b'", "from contours_in_ve_upds[OF eq_length \"1.prems\"(1) \"1.prems\"(3)]"], ["proof (chain)\npicking this:\n  \\<forall>b'\\<in>contours_in_ve\n                   (ve(map (\\<lambda>v. (v, ?b'')) vs [\\<mapsto>] ds)).\n     b' < b", "have b_dom_ve: \"\\<forall>b'\\<in>contours_in_ve (ve(map (\\<lambda>v. (v, b)) vs [\\<mapsto>] ds)). b' \\<le> b\""], ["proof (prove)\nusing this:\n  \\<forall>b'\\<in>contours_in_ve\n                   (ve(map (\\<lambda>v. (v, ?b'')) vs [\\<mapsto>] ds)).\n     b' < b\n\ngoal (1 subgoal):\n 1. \\<forall>b'\\<in>contours_in_ve\n                     (ve(map (\\<lambda>v. (v, b)) vs [\\<mapsto>] ds)).\n       b' \\<le> b", "by auto"], ["proof (state)\nthis:\n  \\<forall>b'\\<in>contours_in_ve\n                   (ve(map (\\<lambda>v. (v, b)) vs [\\<mapsto>] ds)).\n     b' \\<le> b\n\ngoal (8 subgoals):\n 1. \\<And>x2a x1a x2aa x3.\n       \\<lbrakk>d = DC (Lambda x1a x2aa x3, x2a); length x2aa = length ds;\n        \\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        \\<forall>b'\\<in>ran x2a. b' < b;\n        \\<forall>d'\\<in>set ds.\n           \\<forall>b'\\<in>contours_in_d d'. b' < b\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (evalC\\<cdot>\n                           (Discr\n                             (x3, x2a(x1a \\<mapsto> b), ve\n                              (map (\\<lambda>v. (v, b)) x2aa [\\<mapsto>]\n                              ds), b)))\n 2. \\<And>x2a x1a x2aa x3 a b bb.\n       \\<lbrakk>d = DC (Lambda x1a x2aa x3, x2a); length x2aa = length ds;\n        \\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        \\<forall>b'\\<in>ran x2a. b' < b;\n        \\<forall>d'\\<in>set ds. \\<forall>b'\\<in>contours_in_d d'. b' < b;\n        ((a, b), bb)\n        \\<in> evalC\\<cdot>\n              (Discr\n                (x3, x2a(x1a \\<mapsto> b), ve(map (\\<lambda>v. (v, b)) x2aa \n                 [\\<mapsto>] ds), b))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran b \\<and> b \\<le> b'\n 3. \\<And>x1 x1a x1aa x21b.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21b. b' < b; d = DP (Plus x1);\n        ds = [DI x1a, DI x1aa, x21b]; isProc x21b\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (evalF\\<cdot>\n                           (Discr\n                             (x21b, [DI (x1a + x1aa)], ve,\n                              nb b x1)) \\<union>\n                           {((x1, [x1 \\<mapsto> b]), x21b)})\n 4. \\<And>x1 x1a x1aa x21b aa baa bb.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21b. b' < b; d = DP (Plus x1);\n        ds = [DI x1a, DI x1aa, x21b]; isProc x21b;\n        ((aa, baa), bb)\n        \\<in> evalF\\<cdot>\n              (Discr (x21b, [DI (x1a + x1aa)], ve, nb b x1))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran baa \\<and> b \\<le> b'\n 5. \\<And>x21 x22 x1 x21aa x21aaa.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI x1, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; x1 \\<noteq> 0;\n        isProc x21aa; isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (evalF\\<cdot>\n                           (Discr (x21aa, [], ve, nb b x21)) \\<union>\n                           {((x21, [x21 \\<mapsto> b]), x21aa)})\n 6. \\<And>x21 x22 x1 x21aa x21aaa aa baa bb.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI x1, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; x1 \\<noteq> 0;\n        isProc x21aa; isProc x21aaa;\n        ((aa, baa), bb)\n        \\<in> evalF\\<cdot>(Discr (x21aa, [], ve, nb b x21))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran baa \\<and> b \\<le> b'\n 7. \\<And>x21 x22 x21aa x21aaa.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; isProc x21aa;\n        isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (evalF\\<cdot>\n                           (Discr (x21aaa, [], ve, nb b x22)) \\<union>\n                           {((x22, [x22 \\<mapsto> b]), x21aaa)})\n 8. \\<And>x21 x22 x21aa x21aaa aa baa bb.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; isProc x21aa;\n        isProc x21aaa;\n        ((aa, baa), bb)\n        \\<in> evalF\\<cdot>(Discr (x21aaa, [], ve, nb b x22))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran baa \\<and> b \\<le> b'", "show \"single_valued (evalC\\<cdot>(Discr (c, \\<beta>'(lab' \\<mapsto> b), ve(map (\\<lambda>v. (v, b)) vs [\\<mapsto>] ds), b)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. single_valued\n     (evalC\\<cdot>\n      (Discr\n        (c, \\<beta>'(lab' \\<mapsto> b), ve(map (\\<lambda>v. (v, b)) vs \n         [\\<mapsto>] ds), b)))", "by (rule hyps_C_sv[OF new b_dom_beta b_dom_ve, of c])"], ["proof (state)\nthis:\n  single_valued\n   (evalC\\<cdot>\n    (Discr\n      (c, \\<beta>'(lab' \\<mapsto> b), ve(map (\\<lambda>v. (v, b)) vs \n       [\\<mapsto>] ds), b)))\n\ngoal (7 subgoals):\n 1. \\<And>x2a x1a x2aa x3 a b bb.\n       \\<lbrakk>d = DC (Lambda x1a x2aa x3, x2a); length x2aa = length ds;\n        \\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        \\<forall>b'\\<in>ran x2a. b' < b;\n        \\<forall>d'\\<in>set ds. \\<forall>b'\\<in>contours_in_d d'. b' < b;\n        ((a, b), bb)\n        \\<in> evalC\\<cdot>\n              (Discr\n                (x3, x2a(x1a \\<mapsto> b), ve(map (\\<lambda>v. (v, b)) x2aa \n                 [\\<mapsto>] ds), b))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran b \\<and> b \\<le> b'\n 2. \\<And>x1 x1a x1aa x21b.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21b. b' < b; d = DP (Plus x1);\n        ds = [DI x1a, DI x1aa, x21b]; isProc x21b\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (evalF\\<cdot>\n                           (Discr\n                             (x21b, [DI (x1a + x1aa)], ve,\n                              nb b x1)) \\<union>\n                           {((x1, [x1 \\<mapsto> b]), x21b)})\n 3. \\<And>x1 x1a x1aa x21b aa baa bb.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21b. b' < b; d = DP (Plus x1);\n        ds = [DI x1a, DI x1aa, x21b]; isProc x21b;\n        ((aa, baa), bb)\n        \\<in> evalF\\<cdot>\n              (Discr (x21b, [DI (x1a + x1aa)], ve, nb b x1))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran baa \\<and> b \\<le> b'\n 4. \\<And>x21 x22 x1 x21aa x21aaa.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI x1, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; x1 \\<noteq> 0;\n        isProc x21aa; isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (evalF\\<cdot>\n                           (Discr (x21aa, [], ve, nb b x21)) \\<union>\n                           {((x21, [x21 \\<mapsto> b]), x21aa)})\n 5. \\<And>x21 x22 x1 x21aa x21aaa aa baa bb.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI x1, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; x1 \\<noteq> 0;\n        isProc x21aa; isProc x21aaa;\n        ((aa, baa), bb)\n        \\<in> evalF\\<cdot>(Discr (x21aa, [], ve, nb b x21))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran baa \\<and> b \\<le> b'\n 6. \\<And>x21 x22 x21aa x21aaa.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; isProc x21aa;\n        isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (evalF\\<cdot>\n                           (Discr (x21aaa, [], ve, nb b x22)) \\<union>\n                           {((x22, [x22 \\<mapsto> b]), x21aaa)})\n 7. \\<And>x21 x22 x21aa x21aaa aa baa bb.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; isProc x21aa;\n        isProc x21aaa;\n        ((aa, baa), bb)\n        \\<in> evalF\\<cdot>(Discr (x21aaa, [], ve, nb b x22))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran baa \\<and> b \\<le> b'", "fix lab and \\<beta> and t"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>x2a x1a x2aa x3 a b bb.\n       \\<lbrakk>d = DC (Lambda x1a x2aa x3, x2a); length x2aa = length ds;\n        \\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        \\<forall>b'\\<in>ran x2a. b' < b;\n        \\<forall>d'\\<in>set ds. \\<forall>b'\\<in>contours_in_d d'. b' < b;\n        ((a, b), bb)\n        \\<in> evalC\\<cdot>\n              (Discr\n                (x3, x2a(x1a \\<mapsto> b), ve(map (\\<lambda>v. (v, b)) x2aa \n                 [\\<mapsto>] ds), b))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran b \\<and> b \\<le> b'\n 2. \\<And>x1 x1a x1aa x21b.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21b. b' < b; d = DP (Plus x1);\n        ds = [DI x1a, DI x1aa, x21b]; isProc x21b\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (evalF\\<cdot>\n                           (Discr\n                             (x21b, [DI (x1a + x1aa)], ve,\n                              nb b x1)) \\<union>\n                           {((x1, [x1 \\<mapsto> b]), x21b)})\n 3. \\<And>x1 x1a x1aa x21b aa baa bb.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21b. b' < b; d = DP (Plus x1);\n        ds = [DI x1a, DI x1aa, x21b]; isProc x21b;\n        ((aa, baa), bb)\n        \\<in> evalF\\<cdot>\n              (Discr (x21b, [DI (x1a + x1aa)], ve, nb b x1))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran baa \\<and> b \\<le> b'\n 4. \\<And>x21 x22 x1 x21aa x21aaa.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI x1, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; x1 \\<noteq> 0;\n        isProc x21aa; isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (evalF\\<cdot>\n                           (Discr (x21aa, [], ve, nb b x21)) \\<union>\n                           {((x21, [x21 \\<mapsto> b]), x21aa)})\n 5. \\<And>x21 x22 x1 x21aa x21aaa aa baa bb.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI x1, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; x1 \\<noteq> 0;\n        isProc x21aa; isProc x21aaa;\n        ((aa, baa), bb)\n        \\<in> evalF\\<cdot>(Discr (x21aa, [], ve, nb b x21))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran baa \\<and> b \\<le> b'\n 6. \\<And>x21 x22 x21aa x21aaa.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; isProc x21aa;\n        isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (evalF\\<cdot>\n                           (Discr (x21aaa, [], ve, nb b x22)) \\<union>\n                           {((x22, [x22 \\<mapsto> b]), x21aaa)})\n 7. \\<And>x21 x22 x21aa x21aaa aa baa bb.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; isProc x21aa;\n        isProc x21aaa;\n        ((aa, baa), bb)\n        \\<in> evalF\\<cdot>(Discr (x21aaa, [], ve, nb b x22))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran baa \\<and> b \\<le> b'", "assume \"((lab, \\<beta>), t)\\<in> evalC\\<cdot>(Discr(c, \\<beta>'(lab' \\<mapsto> b), ve(map (\\<lambda>v. (v, b)) vs [\\<mapsto>] ds),b))\""], ["proof (state)\nthis:\n  ((lab, \\<beta>), t)\n  \\<in> evalC\\<cdot>\n        (Discr\n          (c, \\<beta>'(lab' \\<mapsto> b), ve(map (\\<lambda>v. (v, b)) vs \n           [\\<mapsto>] ds), b))\n\ngoal (7 subgoals):\n 1. \\<And>x2a x1a x2aa x3 a b bb.\n       \\<lbrakk>d = DC (Lambda x1a x2aa x3, x2a); length x2aa = length ds;\n        \\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        \\<forall>b'\\<in>ran x2a. b' < b;\n        \\<forall>d'\\<in>set ds. \\<forall>b'\\<in>contours_in_d d'. b' < b;\n        ((a, b), bb)\n        \\<in> evalC\\<cdot>\n              (Discr\n                (x3, x2a(x1a \\<mapsto> b), ve(map (\\<lambda>v. (v, b)) x2aa \n                 [\\<mapsto>] ds), b))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran b \\<and> b \\<le> b'\n 2. \\<And>x1 x1a x1aa x21b.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21b. b' < b; d = DP (Plus x1);\n        ds = [DI x1a, DI x1aa, x21b]; isProc x21b\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (evalF\\<cdot>\n                           (Discr\n                             (x21b, [DI (x1a + x1aa)], ve,\n                              nb b x1)) \\<union>\n                           {((x1, [x1 \\<mapsto> b]), x21b)})\n 3. \\<And>x1 x1a x1aa x21b aa baa bb.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21b. b' < b; d = DP (Plus x1);\n        ds = [DI x1a, DI x1aa, x21b]; isProc x21b;\n        ((aa, baa), bb)\n        \\<in> evalF\\<cdot>\n              (Discr (x21b, [DI (x1a + x1aa)], ve, nb b x1))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran baa \\<and> b \\<le> b'\n 4. \\<And>x21 x22 x1 x21aa x21aaa.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI x1, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; x1 \\<noteq> 0;\n        isProc x21aa; isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (evalF\\<cdot>\n                           (Discr (x21aa, [], ve, nb b x21)) \\<union>\n                           {((x21, [x21 \\<mapsto> b]), x21aa)})\n 5. \\<And>x21 x22 x1 x21aa x21aaa aa baa bb.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI x1, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; x1 \\<noteq> 0;\n        isProc x21aa; isProc x21aaa;\n        ((aa, baa), bb)\n        \\<in> evalF\\<cdot>(Discr (x21aa, [], ve, nb b x21))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran baa \\<and> b \\<le> b'\n 6. \\<And>x21 x22 x21aa x21aaa.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; isProc x21aa;\n        isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (evalF\\<cdot>\n                           (Discr (x21aaa, [], ve, nb b x22)) \\<union>\n                           {((x22, [x22 \\<mapsto> b]), x21aaa)})\n 7. \\<And>x21 x22 x21aa x21aaa aa baa bb.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; isProc x21aa;\n        isProc x21aaa;\n        ((aa, baa), bb)\n        \\<in> evalF\\<cdot>(Discr (x21aaa, [], ve, nb b x22))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran baa \\<and> b \\<le> b'", "thus \"\\<exists>b'. b' \\<in> ran \\<beta> \\<and> b \\<le> b'\""], ["proof (prove)\nusing this:\n  ((lab, \\<beta>), t)\n  \\<in> evalC\\<cdot>\n        (Discr\n          (c, \\<beta>'(lab' \\<mapsto> b), ve(map (\\<lambda>v. (v, b)) vs \n           [\\<mapsto>] ds), b))\n\ngoal (1 subgoal):\n 1. \\<exists>b'. b' \\<in> ran \\<beta> \\<and> b \\<le> b'", "by (auto dest: hyps_C_b[OF new b_dom_beta b_dom_ve])"], ["proof (state)\nthis:\n  \\<exists>b'. b' \\<in> ran \\<beta> \\<and> b \\<le> b'\n\ngoal (6 subgoals):\n 1. \\<And>x1 x1a x1aa x21b.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21b. b' < b; d = DP (Plus x1);\n        ds = [DI x1a, DI x1aa, x21b]; isProc x21b\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (evalF\\<cdot>\n                           (Discr\n                             (x21b, [DI (x1a + x1aa)], ve,\n                              nb b x1)) \\<union>\n                           {((x1, [x1 \\<mapsto> b]), x21b)})\n 2. \\<And>x1 x1a x1aa x21b aa baa bb.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21b. b' < b; d = DP (Plus x1);\n        ds = [DI x1a, DI x1aa, x21b]; isProc x21b;\n        ((aa, baa), bb)\n        \\<in> evalF\\<cdot>\n              (Discr (x21b, [DI (x1a + x1aa)], ve, nb b x1))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran baa \\<and> b \\<le> b'\n 3. \\<And>x21 x22 x1 x21aa x21aaa.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI x1, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; x1 \\<noteq> 0;\n        isProc x21aa; isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (evalF\\<cdot>\n                           (Discr (x21aa, [], ve, nb b x21)) \\<union>\n                           {((x21, [x21 \\<mapsto> b]), x21aa)})\n 4. \\<And>x21 x22 x1 x21aa x21aaa aa baa bb.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI x1, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; x1 \\<noteq> 0;\n        isProc x21aa; isProc x21aaa;\n        ((aa, baa), bb)\n        \\<in> evalF\\<cdot>(Discr (x21aa, [], ve, nb b x21))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran baa \\<and> b \\<le> b'\n 5. \\<And>x21 x22 x21aa x21aaa.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; isProc x21aa;\n        isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (evalF\\<cdot>\n                           (Discr (x21aaa, [], ve, nb b x22)) \\<union>\n                           {((x22, [x22 \\<mapsto> b]), x21aaa)})\n 6. \\<And>x21 x22 x21aa x21aaa aa baa bb.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; isProc x21aa;\n        isProc x21aaa;\n        ((aa, baa), bb)\n        \\<in> evalF\\<cdot>(Discr (x21aaa, [], ve, nb b x22))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran baa \\<and> b \\<le> b'", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>x1 x1a x1aa x21b.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21b. b' < b; d = DP (Plus x1);\n        ds = [DI x1a, DI x1aa, x21b]; isProc x21b\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (evalF\\<cdot>\n                           (Discr\n                             (x21b, [DI (x1a + x1aa)], ve,\n                              nb b x1)) \\<union>\n                           {((x1, [x1 \\<mapsto> b]), x21b)})\n 2. \\<And>x1 x1a x1aa x21b aa baa bb.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21b. b' < b; d = DP (Plus x1);\n        ds = [DI x1a, DI x1aa, x21b]; isProc x21b;\n        ((aa, baa), bb)\n        \\<in> evalF\\<cdot>\n              (Discr (x21b, [DI (x1a + x1aa)], ve, nb b x1))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran baa \\<and> b \\<le> b'\n 3. \\<And>x21 x22 x1 x21aa x21aaa.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI x1, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; x1 \\<noteq> 0;\n        isProc x21aa; isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (evalF\\<cdot>\n                           (Discr (x21aa, [], ve, nb b x21)) \\<union>\n                           {((x21, [x21 \\<mapsto> b]), x21aa)})\n 4. \\<And>x21 x22 x1 x21aa x21aaa aa baa bb.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI x1, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; x1 \\<noteq> 0;\n        isProc x21aa; isProc x21aaa;\n        ((aa, baa), bb)\n        \\<in> evalF\\<cdot>(Discr (x21aa, [], ve, nb b x21))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran baa \\<and> b \\<le> b'\n 5. \\<And>x21 x22 x21aa x21aaa.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; isProc x21aa;\n        isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (evalF\\<cdot>\n                           (Discr (x21aaa, [], ve, nb b x22)) \\<union>\n                           {((x22, [x22 \\<mapsto> b]), x21aaa)})\n 6. \\<And>x21 x22 x21aa x21aaa aa baa bb.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; isProc x21aa;\n        isProc x21aaa;\n        ((aa, baa), bb)\n        \\<in> evalF\\<cdot>(Discr (x21aaa, [], ve, nb b x22))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran baa \\<and> b \\<le> b'", "txt \\<open>Case Plus\\<close>"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>x1 x1a x1aa x21b.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21b. b' < b; d = DP (Plus x1);\n        ds = [DI x1a, DI x1aa, x21b]; isProc x21b\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (evalF\\<cdot>\n                           (Discr\n                             (x21b, [DI (x1a + x1aa)], ve,\n                              nb b x1)) \\<union>\n                           {((x1, [x1 \\<mapsto> b]), x21b)})\n 2. \\<And>x1 x1a x1aa x21b aa baa bb.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21b. b' < b; d = DP (Plus x1);\n        ds = [DI x1a, DI x1aa, x21b]; isProc x21b;\n        ((aa, baa), bb)\n        \\<in> evalF\\<cdot>\n              (Discr (x21b, [DI (x1a + x1aa)], ve, nb b x1))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran baa \\<and> b \\<le> b'\n 3. \\<And>x21 x22 x1 x21aa x21aaa.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI x1, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; x1 \\<noteq> 0;\n        isProc x21aa; isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (evalF\\<cdot>\n                           (Discr (x21aa, [], ve, nb b x21)) \\<union>\n                           {((x21, [x21 \\<mapsto> b]), x21aa)})\n 4. \\<And>x21 x22 x1 x21aa x21aaa aa baa bb.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI x1, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; x1 \\<noteq> 0;\n        isProc x21aa; isProc x21aaa;\n        ((aa, baa), bb)\n        \\<in> evalF\\<cdot>(Discr (x21aa, [], ve, nb b x21))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran baa \\<and> b \\<le> b'\n 5. \\<And>x21 x22 x21aa x21aaa.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; isProc x21aa;\n        isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (evalF\\<cdot>\n                           (Discr (x21aaa, [], ve, nb b x22)) \\<union>\n                           {((x22, [x22 \\<mapsto> b]), x21aaa)})\n 6. \\<And>x21 x22 x21aa x21aaa aa baa bb.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; isProc x21aa;\n        isProc x21aaa;\n        ((aa, baa), bb)\n        \\<in> evalF\\<cdot>(Discr (x21aaa, [], ve, nb b x22))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran baa \\<and> b \\<le> b'", "fix cp and i1 and i2 and cnt"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>x1 x1a x1aa x21b.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21b. b' < b; d = DP (Plus x1);\n        ds = [DI x1a, DI x1aa, x21b]; isProc x21b\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (evalF\\<cdot>\n                           (Discr\n                             (x21b, [DI (x1a + x1aa)], ve,\n                              nb b x1)) \\<union>\n                           {((x1, [x1 \\<mapsto> b]), x21b)})\n 2. \\<And>x1 x1a x1aa x21b aa baa bb.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21b. b' < b; d = DP (Plus x1);\n        ds = [DI x1a, DI x1aa, x21b]; isProc x21b;\n        ((aa, baa), bb)\n        \\<in> evalF\\<cdot>\n              (Discr (x21b, [DI (x1a + x1aa)], ve, nb b x1))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran baa \\<and> b \\<le> b'\n 3. \\<And>x21 x22 x1 x21aa x21aaa.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI x1, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; x1 \\<noteq> 0;\n        isProc x21aa; isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (evalF\\<cdot>\n                           (Discr (x21aa, [], ve, nb b x21)) \\<union>\n                           {((x21, [x21 \\<mapsto> b]), x21aa)})\n 4. \\<And>x21 x22 x1 x21aa x21aaa aa baa bb.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI x1, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; x1 \\<noteq> 0;\n        isProc x21aa; isProc x21aaa;\n        ((aa, baa), bb)\n        \\<in> evalF\\<cdot>(Discr (x21aa, [], ve, nb b x21))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran baa \\<and> b \\<le> b'\n 5. \\<And>x21 x22 x21aa x21aaa.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; isProc x21aa;\n        isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (evalF\\<cdot>\n                           (Discr (x21aaa, [], ve, nb b x22)) \\<union>\n                           {((x22, [x22 \\<mapsto> b]), x21aaa)})\n 6. \\<And>x21 x22 x21aa x21aaa aa baa bb.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; isProc x21aa;\n        isProc x21aaa;\n        ((aa, baa), bb)\n        \\<in> evalF\\<cdot>(Discr (x21aaa, [], ve, nb b x22))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran baa \\<and> b \\<le> b'", "assume \"\\<forall>b'\\<in>contours_in_d cnt. b' < b\""], ["proof (state)\nthis:\n  \\<forall>b'\\<in>contours_in_d cnt. b' < b\n\ngoal (6 subgoals):\n 1. \\<And>x1 x1a x1aa x21b.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21b. b' < b; d = DP (Plus x1);\n        ds = [DI x1a, DI x1aa, x21b]; isProc x21b\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (evalF\\<cdot>\n                           (Discr\n                             (x21b, [DI (x1a + x1aa)], ve,\n                              nb b x1)) \\<union>\n                           {((x1, [x1 \\<mapsto> b]), x21b)})\n 2. \\<And>x1 x1a x1aa x21b aa baa bb.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21b. b' < b; d = DP (Plus x1);\n        ds = [DI x1a, DI x1aa, x21b]; isProc x21b;\n        ((aa, baa), bb)\n        \\<in> evalF\\<cdot>\n              (Discr (x21b, [DI (x1a + x1aa)], ve, nb b x1))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran baa \\<and> b \\<le> b'\n 3. \\<And>x21 x22 x1 x21aa x21aaa.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI x1, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; x1 \\<noteq> 0;\n        isProc x21aa; isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (evalF\\<cdot>\n                           (Discr (x21aa, [], ve, nb b x21)) \\<union>\n                           {((x21, [x21 \\<mapsto> b]), x21aa)})\n 4. \\<And>x21 x22 x1 x21aa x21aaa aa baa bb.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI x1, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; x1 \\<noteq> 0;\n        isProc x21aa; isProc x21aaa;\n        ((aa, baa), bb)\n        \\<in> evalF\\<cdot>(Discr (x21aa, [], ve, nb b x21))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran baa \\<and> b \\<le> b'\n 5. \\<And>x21 x22 x21aa x21aaa.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; isProc x21aa;\n        isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (evalF\\<cdot>\n                           (Discr (x21aaa, [], ve, nb b x22)) \\<union>\n                           {((x22, [x22 \\<mapsto> b]), x21aaa)})\n 6. \\<And>x21 x22 x21aa x21aaa aa baa bb.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; isProc x21aa;\n        isProc x21aaa;\n        ((aa, baa), bb)\n        \\<in> evalF\\<cdot>(Discr (x21aaa, [], ve, nb b x22))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran baa \\<and> b \\<le> b'", "hence b_dom_d: \"\\<forall>b'\\<in>contours_in_d cnt. b' < nb b cp\""], ["proof (prove)\nusing this:\n  \\<forall>b'\\<in>contours_in_d cnt. b' < b\n\ngoal (1 subgoal):\n 1. \\<forall>b'\\<in>contours_in_d cnt. b' < nb b cp", "by auto"], ["proof (state)\nthis:\n  \\<forall>b'\\<in>contours_in_d cnt. b' < nb b cp\n\ngoal (6 subgoals):\n 1. \\<And>x1 x1a x1aa x21b.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21b. b' < b; d = DP (Plus x1);\n        ds = [DI x1a, DI x1aa, x21b]; isProc x21b\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (evalF\\<cdot>\n                           (Discr\n                             (x21b, [DI (x1a + x1aa)], ve,\n                              nb b x1)) \\<union>\n                           {((x1, [x1 \\<mapsto> b]), x21b)})\n 2. \\<And>x1 x1a x1aa x21b aa baa bb.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21b. b' < b; d = DP (Plus x1);\n        ds = [DI x1a, DI x1aa, x21b]; isProc x21b;\n        ((aa, baa), bb)\n        \\<in> evalF\\<cdot>\n              (Discr (x21b, [DI (x1a + x1aa)], ve, nb b x1))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran baa \\<and> b \\<le> b'\n 3. \\<And>x21 x22 x1 x21aa x21aaa.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI x1, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; x1 \\<noteq> 0;\n        isProc x21aa; isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (evalF\\<cdot>\n                           (Discr (x21aa, [], ve, nb b x21)) \\<union>\n                           {((x21, [x21 \\<mapsto> b]), x21aa)})\n 4. \\<And>x21 x22 x1 x21aa x21aaa aa baa bb.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI x1, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; x1 \\<noteq> 0;\n        isProc x21aa; isProc x21aaa;\n        ((aa, baa), bb)\n        \\<in> evalF\\<cdot>(Discr (x21aa, [], ve, nb b x21))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran baa \\<and> b \\<le> b'\n 5. \\<And>x21 x22 x21aa x21aaa.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; isProc x21aa;\n        isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (evalF\\<cdot>\n                           (Discr (x21aaa, [], ve, nb b x22)) \\<union>\n                           {((x22, [x22 \\<mapsto> b]), x21aaa)})\n 6. \\<And>x21 x22 x21aa x21aaa aa baa bb.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; isProc x21aa;\n        isProc x21aaa;\n        ((aa, baa), bb)\n        \\<in> evalF\\<cdot>(Discr (x21aaa, [], ve, nb b x22))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran baa \\<and> b \\<le> b'", "have b_dom_ds: \"\\<forall>d' \\<in> set [DI (i1+i2)]. \\<forall>b'\\<in>contours_in_d d'. b' < nb b cp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>d'\\<in>set [DI (i1 + i2)].\n       \\<forall>b'\\<in>contours_in_d d'. b' < nb b cp", "by auto"], ["proof (state)\nthis:\n  \\<forall>d'\\<in>set [DI (i1 + i2)].\n     \\<forall>b'\\<in>contours_in_d d'. b' < nb b cp\n\ngoal (6 subgoals):\n 1. \\<And>x1 x1a x1aa x21b.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21b. b' < b; d = DP (Plus x1);\n        ds = [DI x1a, DI x1aa, x21b]; isProc x21b\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (evalF\\<cdot>\n                           (Discr\n                             (x21b, [DI (x1a + x1aa)], ve,\n                              nb b x1)) \\<union>\n                           {((x1, [x1 \\<mapsto> b]), x21b)})\n 2. \\<And>x1 x1a x1aa x21b aa baa bb.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21b. b' < b; d = DP (Plus x1);\n        ds = [DI x1a, DI x1aa, x21b]; isProc x21b;\n        ((aa, baa), bb)\n        \\<in> evalF\\<cdot>\n              (Discr (x21b, [DI (x1a + x1aa)], ve, nb b x1))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran baa \\<and> b \\<le> b'\n 3. \\<And>x21 x22 x1 x21aa x21aaa.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI x1, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; x1 \\<noteq> 0;\n        isProc x21aa; isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (evalF\\<cdot>\n                           (Discr (x21aa, [], ve, nb b x21)) \\<union>\n                           {((x21, [x21 \\<mapsto> b]), x21aa)})\n 4. \\<And>x21 x22 x1 x21aa x21aaa aa baa bb.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI x1, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; x1 \\<noteq> 0;\n        isProc x21aa; isProc x21aaa;\n        ((aa, baa), bb)\n        \\<in> evalF\\<cdot>(Discr (x21aa, [], ve, nb b x21))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran baa \\<and> b \\<le> b'\n 5. \\<And>x21 x22 x21aa x21aaa.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; isProc x21aa;\n        isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (evalF\\<cdot>\n                           (Discr (x21aaa, [], ve, nb b x22)) \\<union>\n                           {((x22, [x22 \\<mapsto> b]), x21aaa)})\n 6. \\<And>x21 x22 x21aa x21aaa aa baa bb.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; isProc x21aa;\n        isProc x21aaa;\n        ((aa, baa), bb)\n        \\<in> evalF\\<cdot>(Discr (x21aaa, [], ve, nb b x22))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran baa \\<and> b \\<le> b'", "have b_dom_ve: \"\\<forall>b' \\<in> contours_in_ve ve. b' < nb b cp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>b'\\<in>contours_in_ve ve. b' < nb b cp", "using \"1.prems\"(1)"], ["proof (prove)\nusing this:\n  \\<forall>b'\\<in>contours_in_ve ve. b' < b\n\ngoal (1 subgoal):\n 1. \\<forall>b'\\<in>contours_in_ve ve. b' < nb b cp", "by auto"], ["proof (state)\nthis:\n  \\<forall>b'\\<in>contours_in_ve ve. b' < nb b cp\n\ngoal (6 subgoals):\n 1. \\<And>x1 x1a x1aa x21b.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21b. b' < b; d = DP (Plus x1);\n        ds = [DI x1a, DI x1aa, x21b]; isProc x21b\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (evalF\\<cdot>\n                           (Discr\n                             (x21b, [DI (x1a + x1aa)], ve,\n                              nb b x1)) \\<union>\n                           {((x1, [x1 \\<mapsto> b]), x21b)})\n 2. \\<And>x1 x1a x1aa x21b aa baa bb.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21b. b' < b; d = DP (Plus x1);\n        ds = [DI x1a, DI x1aa, x21b]; isProc x21b;\n        ((aa, baa), bb)\n        \\<in> evalF\\<cdot>\n              (Discr (x21b, [DI (x1a + x1aa)], ve, nb b x1))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran baa \\<and> b \\<le> b'\n 3. \\<And>x21 x22 x1 x21aa x21aaa.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI x1, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; x1 \\<noteq> 0;\n        isProc x21aa; isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (evalF\\<cdot>\n                           (Discr (x21aa, [], ve, nb b x21)) \\<union>\n                           {((x21, [x21 \\<mapsto> b]), x21aa)})\n 4. \\<And>x21 x22 x1 x21aa x21aaa aa baa bb.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI x1, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; x1 \\<noteq> 0;\n        isProc x21aa; isProc x21aaa;\n        ((aa, baa), bb)\n        \\<in> evalF\\<cdot>(Discr (x21aa, [], ve, nb b x21))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran baa \\<and> b \\<le> b'\n 5. \\<And>x21 x22 x21aa x21aaa.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; isProc x21aa;\n        isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (evalF\\<cdot>\n                           (Discr (x21aaa, [], ve, nb b x22)) \\<union>\n                           {((x22, [x22 \\<mapsto> b]), x21aaa)})\n 6. \\<And>x21 x22 x21aa x21aaa aa baa bb.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; isProc x21aa;\n        isProc x21aaa;\n        ((aa, baa), bb)\n        \\<in> evalF\\<cdot>(Discr (x21aaa, [], ve, nb b x22))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran baa \\<and> b \\<le> b'", "{"], ["proof (state)\nthis:\n  \\<forall>b'\\<in>contours_in_ve ve. b' < nb b cp\n\ngoal (6 subgoals):\n 1. \\<And>x1 x1a x1aa x21b.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21b. b' < b; d = DP (Plus x1);\n        ds = [DI x1a, DI x1aa, x21b]; isProc x21b\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (evalF\\<cdot>\n                           (Discr\n                             (x21b, [DI (x1a + x1aa)], ve,\n                              nb b x1)) \\<union>\n                           {((x1, [x1 \\<mapsto> b]), x21b)})\n 2. \\<And>x1 x1a x1aa x21b aa baa bb.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21b. b' < b; d = DP (Plus x1);\n        ds = [DI x1a, DI x1aa, x21b]; isProc x21b;\n        ((aa, baa), bb)\n        \\<in> evalF\\<cdot>\n              (Discr (x21b, [DI (x1a + x1aa)], ve, nb b x1))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran baa \\<and> b \\<le> b'\n 3. \\<And>x21 x22 x1 x21aa x21aaa.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI x1, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; x1 \\<noteq> 0;\n        isProc x21aa; isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (evalF\\<cdot>\n                           (Discr (x21aa, [], ve, nb b x21)) \\<union>\n                           {((x21, [x21 \\<mapsto> b]), x21aa)})\n 4. \\<And>x21 x22 x1 x21aa x21aaa aa baa bb.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI x1, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; x1 \\<noteq> 0;\n        isProc x21aa; isProc x21aaa;\n        ((aa, baa), bb)\n        \\<in> evalF\\<cdot>(Discr (x21aa, [], ve, nb b x21))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran baa \\<and> b \\<le> b'\n 5. \\<And>x21 x22 x21aa x21aaa.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; isProc x21aa;\n        isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (evalF\\<cdot>\n                           (Discr (x21aaa, [], ve, nb b x22)) \\<union>\n                           {((x22, [x22 \\<mapsto> b]), x21aaa)})\n 6. \\<And>x21 x22 x21aa x21aaa aa baa bb.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; isProc x21aa;\n        isProc x21aaa;\n        ((aa, baa), bb)\n        \\<in> evalF\\<cdot>(Discr (x21aaa, [], ve, nb b x22))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran baa \\<and> b \\<le> b'", "fix t"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>x1 x1a x1aa x21b.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21b. b' < b; d = DP (Plus x1);\n        ds = [DI x1a, DI x1aa, x21b]; isProc x21b\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (evalF\\<cdot>\n                           (Discr\n                             (x21b, [DI (x1a + x1aa)], ve,\n                              nb b x1)) \\<union>\n                           {((x1, [x1 \\<mapsto> b]), x21b)})\n 2. \\<And>x1 x1a x1aa x21b aa baa bb.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21b. b' < b; d = DP (Plus x1);\n        ds = [DI x1a, DI x1aa, x21b]; isProc x21b;\n        ((aa, baa), bb)\n        \\<in> evalF\\<cdot>\n              (Discr (x21b, [DI (x1a + x1aa)], ve, nb b x1))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran baa \\<and> b \\<le> b'\n 3. \\<And>x21 x22 x1 x21aa x21aaa.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI x1, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; x1 \\<noteq> 0;\n        isProc x21aa; isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (evalF\\<cdot>\n                           (Discr (x21aa, [], ve, nb b x21)) \\<union>\n                           {((x21, [x21 \\<mapsto> b]), x21aa)})\n 4. \\<And>x21 x22 x1 x21aa x21aaa aa baa bb.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI x1, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; x1 \\<noteq> 0;\n        isProc x21aa; isProc x21aaa;\n        ((aa, baa), bb)\n        \\<in> evalF\\<cdot>(Discr (x21aa, [], ve, nb b x21))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran baa \\<and> b \\<le> b'\n 5. \\<And>x21 x22 x21aa x21aaa.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; isProc x21aa;\n        isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (evalF\\<cdot>\n                           (Discr (x21aaa, [], ve, nb b x22)) \\<union>\n                           {((x22, [x22 \\<mapsto> b]), x21aaa)})\n 6. \\<And>x21 x22 x21aa x21aaa aa baa bb.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; isProc x21aa;\n        isProc x21aaa;\n        ((aa, baa), bb)\n        \\<in> evalF\\<cdot>(Discr (x21aaa, [], ve, nb b x22))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran baa \\<and> b \\<le> b'", "assume \"((cp,[cp \\<mapsto> b]), t) \\<in> evalF\\<cdot>(Discr (cnt, [DI (i1 + i2)], ve, nb b cp))\""], ["proof (state)\nthis:\n  ((cp, [cp \\<mapsto> b]), t)\n  \\<in> evalF\\<cdot>(Discr (cnt, [DI (i1 + i2)], ve, nb b cp))\n\ngoal (6 subgoals):\n 1. \\<And>x1 x1a x1aa x21b.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21b. b' < b; d = DP (Plus x1);\n        ds = [DI x1a, DI x1aa, x21b]; isProc x21b\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (evalF\\<cdot>\n                           (Discr\n                             (x21b, [DI (x1a + x1aa)], ve,\n                              nb b x1)) \\<union>\n                           {((x1, [x1 \\<mapsto> b]), x21b)})\n 2. \\<And>x1 x1a x1aa x21b aa baa bb.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21b. b' < b; d = DP (Plus x1);\n        ds = [DI x1a, DI x1aa, x21b]; isProc x21b;\n        ((aa, baa), bb)\n        \\<in> evalF\\<cdot>\n              (Discr (x21b, [DI (x1a + x1aa)], ve, nb b x1))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran baa \\<and> b \\<le> b'\n 3. \\<And>x21 x22 x1 x21aa x21aaa.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI x1, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; x1 \\<noteq> 0;\n        isProc x21aa; isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (evalF\\<cdot>\n                           (Discr (x21aa, [], ve, nb b x21)) \\<union>\n                           {((x21, [x21 \\<mapsto> b]), x21aa)})\n 4. \\<And>x21 x22 x1 x21aa x21aaa aa baa bb.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI x1, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; x1 \\<noteq> 0;\n        isProc x21aa; isProc x21aaa;\n        ((aa, baa), bb)\n        \\<in> evalF\\<cdot>(Discr (x21aa, [], ve, nb b x21))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran baa \\<and> b \\<le> b'\n 5. \\<And>x21 x22 x21aa x21aaa.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; isProc x21aa;\n        isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (evalF\\<cdot>\n                           (Discr (x21aaa, [], ve, nb b x22)) \\<union>\n                           {((x22, [x22 \\<mapsto> b]), x21aaa)})\n 6. \\<And>x21 x22 x21aa x21aaa aa baa bb.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; isProc x21aa;\n        isProc x21aaa;\n        ((aa, baa), bb)\n        \\<in> evalF\\<cdot>(Discr (x21aaa, [], ve, nb b x22))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran baa \\<and> b \\<le> b'", "hence False"], ["proof (prove)\nusing this:\n  ((cp, [cp \\<mapsto> b]), t)\n  \\<in> evalF\\<cdot>(Discr (cnt, [DI (i1 + i2)], ve, nb b cp))\n\ngoal (1 subgoal):\n 1. False", "by (auto dest:hyps_F_b[OF b_dom_ve b_dom_d b_dom_ds])"], ["proof (state)\nthis:\n  False\n\ngoal (6 subgoals):\n 1. \\<And>x1 x1a x1aa x21b.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21b. b' < b; d = DP (Plus x1);\n        ds = [DI x1a, DI x1aa, x21b]; isProc x21b\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (evalF\\<cdot>\n                           (Discr\n                             (x21b, [DI (x1a + x1aa)], ve,\n                              nb b x1)) \\<union>\n                           {((x1, [x1 \\<mapsto> b]), x21b)})\n 2. \\<And>x1 x1a x1aa x21b aa baa bb.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21b. b' < b; d = DP (Plus x1);\n        ds = [DI x1a, DI x1aa, x21b]; isProc x21b;\n        ((aa, baa), bb)\n        \\<in> evalF\\<cdot>\n              (Discr (x21b, [DI (x1a + x1aa)], ve, nb b x1))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran baa \\<and> b \\<le> b'\n 3. \\<And>x21 x22 x1 x21aa x21aaa.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI x1, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; x1 \\<noteq> 0;\n        isProc x21aa; isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (evalF\\<cdot>\n                           (Discr (x21aa, [], ve, nb b x21)) \\<union>\n                           {((x21, [x21 \\<mapsto> b]), x21aa)})\n 4. \\<And>x21 x22 x1 x21aa x21aaa aa baa bb.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI x1, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; x1 \\<noteq> 0;\n        isProc x21aa; isProc x21aaa;\n        ((aa, baa), bb)\n        \\<in> evalF\\<cdot>(Discr (x21aa, [], ve, nb b x21))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran baa \\<and> b \\<le> b'\n 5. \\<And>x21 x22 x21aa x21aaa.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; isProc x21aa;\n        isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (evalF\\<cdot>\n                           (Discr (x21aaa, [], ve, nb b x22)) \\<union>\n                           {((x22, [x22 \\<mapsto> b]), x21aaa)})\n 6. \\<And>x21 x22 x21aa x21aaa aa baa bb.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; isProc x21aa;\n        isProc x21aaa;\n        ((aa, baa), bb)\n        \\<in> evalF\\<cdot>(Discr (x21aaa, [], ve, nb b x22))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran baa \\<and> b \\<le> b'", "}"], ["proof (state)\nthis:\n  ((cp, [cp \\<mapsto> b]), ?t2)\n  \\<in> evalF\\<cdot>\n        (Discr (cnt, [DI (i1 + i2)], ve, nb b cp)) \\<Longrightarrow>\n  False\n\ngoal (6 subgoals):\n 1. \\<And>x1 x1a x1aa x21b.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21b. b' < b; d = DP (Plus x1);\n        ds = [DI x1a, DI x1aa, x21b]; isProc x21b\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (evalF\\<cdot>\n                           (Discr\n                             (x21b, [DI (x1a + x1aa)], ve,\n                              nb b x1)) \\<union>\n                           {((x1, [x1 \\<mapsto> b]), x21b)})\n 2. \\<And>x1 x1a x1aa x21b aa baa bb.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21b. b' < b; d = DP (Plus x1);\n        ds = [DI x1a, DI x1aa, x21b]; isProc x21b;\n        ((aa, baa), bb)\n        \\<in> evalF\\<cdot>\n              (Discr (x21b, [DI (x1a + x1aa)], ve, nb b x1))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran baa \\<and> b \\<le> b'\n 3. \\<And>x21 x22 x1 x21aa x21aaa.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI x1, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; x1 \\<noteq> 0;\n        isProc x21aa; isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (evalF\\<cdot>\n                           (Discr (x21aa, [], ve, nb b x21)) \\<union>\n                           {((x21, [x21 \\<mapsto> b]), x21aa)})\n 4. \\<And>x21 x22 x1 x21aa x21aaa aa baa bb.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI x1, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; x1 \\<noteq> 0;\n        isProc x21aa; isProc x21aaa;\n        ((aa, baa), bb)\n        \\<in> evalF\\<cdot>(Discr (x21aa, [], ve, nb b x21))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran baa \\<and> b \\<le> b'\n 5. \\<And>x21 x22 x21aa x21aaa.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; isProc x21aa;\n        isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (evalF\\<cdot>\n                           (Discr (x21aaa, [], ve, nb b x22)) \\<union>\n                           {((x22, [x22 \\<mapsto> b]), x21aaa)})\n 6. \\<And>x21 x22 x21aa x21aaa aa baa bb.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; isProc x21aa;\n        isProc x21aaa;\n        ((aa, baa), bb)\n        \\<in> evalF\\<cdot>(Discr (x21aaa, [], ve, nb b x22))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran baa \\<and> b \\<le> b'", "with hyps_F_sv[OF b_dom_ve b_dom_d b_dom_ds]"], ["proof (chain)\npicking this:\n  single_valued (evalF\\<cdot>(Discr (cnt, [DI (i1 + i2)], ve, nb b cp)))\n  ((cp, [cp \\<mapsto> b]), ?t2)\n  \\<in> evalF\\<cdot>\n        (Discr (cnt, [DI (i1 + i2)], ve, nb b cp)) \\<Longrightarrow>\n  False", "show \"single_valued ((evalF\\<cdot>(Discr (cnt, [DI (i1 + i2)], ve, nb b cp)))\n                      \\<union> {((cp, [cp \\<mapsto> b]), cnt)})\""], ["proof (prove)\nusing this:\n  single_valued (evalF\\<cdot>(Discr (cnt, [DI (i1 + i2)], ve, nb b cp)))\n  ((cp, [cp \\<mapsto> b]), ?t2)\n  \\<in> evalF\\<cdot>\n        (Discr (cnt, [DI (i1 + i2)], ve, nb b cp)) \\<Longrightarrow>\n  False\n\ngoal (1 subgoal):\n 1. single_valued\n     (evalF\\<cdot>(Discr (cnt, [DI (i1 + i2)], ve, nb b cp)) \\<union>\n      {((cp, [cp \\<mapsto> b]), cnt)})", "by (auto intro:single_valued_insert)"], ["proof (state)\nthis:\n  single_valued\n   (evalF\\<cdot>(Discr (cnt, [DI (i1 + i2)], ve, nb b cp)) \\<union>\n    {((cp, [cp \\<mapsto> b]), cnt)})\n\ngoal (5 subgoals):\n 1. \\<And>x1 x1a x1aa x21b aa baa bb.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21b. b' < b; d = DP (Plus x1);\n        ds = [DI x1a, DI x1aa, x21b]; isProc x21b;\n        ((aa, baa), bb)\n        \\<in> evalF\\<cdot>\n              (Discr (x21b, [DI (x1a + x1aa)], ve, nb b x1))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran baa \\<and> b \\<le> b'\n 2. \\<And>x21 x22 x1 x21aa x21aaa.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI x1, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; x1 \\<noteq> 0;\n        isProc x21aa; isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (evalF\\<cdot>\n                           (Discr (x21aa, [], ve, nb b x21)) \\<union>\n                           {((x21, [x21 \\<mapsto> b]), x21aa)})\n 3. \\<And>x21 x22 x1 x21aa x21aaa aa baa bb.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI x1, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; x1 \\<noteq> 0;\n        isProc x21aa; isProc x21aaa;\n        ((aa, baa), bb)\n        \\<in> evalF\\<cdot>(Discr (x21aa, [], ve, nb b x21))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran baa \\<and> b \\<le> b'\n 4. \\<And>x21 x22 x21aa x21aaa.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; isProc x21aa;\n        isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (evalF\\<cdot>\n                           (Discr (x21aaa, [], ve, nb b x22)) \\<union>\n                           {((x22, [x22 \\<mapsto> b]), x21aaa)})\n 5. \\<And>x21 x22 x21aa x21aaa aa baa bb.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; isProc x21aa;\n        isProc x21aaa;\n        ((aa, baa), bb)\n        \\<in> evalF\\<cdot>(Discr (x21aaa, [], ve, nb b x22))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran baa \\<and> b \\<le> b'", "fix lab \\<beta> t"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>x1 x1a x1aa x21b aa baa bb.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21b. b' < b; d = DP (Plus x1);\n        ds = [DI x1a, DI x1aa, x21b]; isProc x21b;\n        ((aa, baa), bb)\n        \\<in> evalF\\<cdot>\n              (Discr (x21b, [DI (x1a + x1aa)], ve, nb b x1))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran baa \\<and> b \\<le> b'\n 2. \\<And>x21 x22 x1 x21aa x21aaa.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI x1, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; x1 \\<noteq> 0;\n        isProc x21aa; isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (evalF\\<cdot>\n                           (Discr (x21aa, [], ve, nb b x21)) \\<union>\n                           {((x21, [x21 \\<mapsto> b]), x21aa)})\n 3. \\<And>x21 x22 x1 x21aa x21aaa aa baa bb.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI x1, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; x1 \\<noteq> 0;\n        isProc x21aa; isProc x21aaa;\n        ((aa, baa), bb)\n        \\<in> evalF\\<cdot>(Discr (x21aa, [], ve, nb b x21))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran baa \\<and> b \\<le> b'\n 4. \\<And>x21 x22 x21aa x21aaa.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; isProc x21aa;\n        isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (evalF\\<cdot>\n                           (Discr (x21aaa, [], ve, nb b x22)) \\<union>\n                           {((x22, [x22 \\<mapsto> b]), x21aaa)})\n 5. \\<And>x21 x22 x21aa x21aaa aa baa bb.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; isProc x21aa;\n        isProc x21aaa;\n        ((aa, baa), bb)\n        \\<in> evalF\\<cdot>(Discr (x21aaa, [], ve, nb b x22))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran baa \\<and> b \\<le> b'", "assume \"((lab, \\<beta>), t) \\<in> evalF\\<cdot>(Discr (cnt, [DI (i1 + i2)], ve, nb b cp))\""], ["proof (state)\nthis:\n  ((lab, \\<beta>), t)\n  \\<in> evalF\\<cdot>(Discr (cnt, [DI (i1 + i2)], ve, nb b cp))\n\ngoal (5 subgoals):\n 1. \\<And>x1 x1a x1aa x21b aa baa bb.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21b. b' < b; d = DP (Plus x1);\n        ds = [DI x1a, DI x1aa, x21b]; isProc x21b;\n        ((aa, baa), bb)\n        \\<in> evalF\\<cdot>\n              (Discr (x21b, [DI (x1a + x1aa)], ve, nb b x1))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran baa \\<and> b \\<le> b'\n 2. \\<And>x21 x22 x1 x21aa x21aaa.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI x1, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; x1 \\<noteq> 0;\n        isProc x21aa; isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (evalF\\<cdot>\n                           (Discr (x21aa, [], ve, nb b x21)) \\<union>\n                           {((x21, [x21 \\<mapsto> b]), x21aa)})\n 3. \\<And>x21 x22 x1 x21aa x21aaa aa baa bb.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI x1, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; x1 \\<noteq> 0;\n        isProc x21aa; isProc x21aaa;\n        ((aa, baa), bb)\n        \\<in> evalF\\<cdot>(Discr (x21aa, [], ve, nb b x21))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran baa \\<and> b \\<le> b'\n 4. \\<And>x21 x22 x21aa x21aaa.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; isProc x21aa;\n        isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (evalF\\<cdot>\n                           (Discr (x21aaa, [], ve, nb b x22)) \\<union>\n                           {((x22, [x22 \\<mapsto> b]), x21aaa)})\n 5. \\<And>x21 x22 x21aa x21aaa aa baa bb.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; isProc x21aa;\n        isProc x21aaa;\n        ((aa, baa), bb)\n        \\<in> evalF\\<cdot>(Discr (x21aaa, [], ve, nb b x22))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran baa \\<and> b \\<le> b'", "thus \"\\<exists>b'. b' \\<in> ran \\<beta> \\<and> b \\<le> b'\""], ["proof (prove)\nusing this:\n  ((lab, \\<beta>), t)\n  \\<in> evalF\\<cdot>(Discr (cnt, [DI (i1 + i2)], ve, nb b cp))\n\ngoal (1 subgoal):\n 1. \\<exists>b'. b' \\<in> ran \\<beta> \\<and> b \\<le> b'", "by (auto dest: hyps_F_b[OF b_dom_ve b_dom_d b_dom_ds])"], ["proof (state)\nthis:\n  \\<exists>b'. b' \\<in> ran \\<beta> \\<and> b \\<le> b'\n\ngoal (4 subgoals):\n 1. \\<And>x21 x22 x1 x21aa x21aaa.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI x1, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; x1 \\<noteq> 0;\n        isProc x21aa; isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (evalF\\<cdot>\n                           (Discr (x21aa, [], ve, nb b x21)) \\<union>\n                           {((x21, [x21 \\<mapsto> b]), x21aa)})\n 2. \\<And>x21 x22 x1 x21aa x21aaa aa baa bb.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI x1, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; x1 \\<noteq> 0;\n        isProc x21aa; isProc x21aaa;\n        ((aa, baa), bb)\n        \\<in> evalF\\<cdot>(Discr (x21aa, [], ve, nb b x21))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran baa \\<and> b \\<le> b'\n 3. \\<And>x21 x22 x21aa x21aaa.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; isProc x21aa;\n        isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (evalF\\<cdot>\n                           (Discr (x21aaa, [], ve, nb b x22)) \\<union>\n                           {((x22, [x22 \\<mapsto> b]), x21aaa)})\n 4. \\<And>x21 x22 x21aa x21aaa aa baa bb.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; isProc x21aa;\n        isProc x21aaa;\n        ((aa, baa), bb)\n        \\<in> evalF\\<cdot>(Discr (x21aaa, [], ve, nb b x22))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran baa \\<and> b \\<le> b'", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x21 x22 x1 x21aa x21aaa.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI x1, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; x1 \\<noteq> 0;\n        isProc x21aa; isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (evalF\\<cdot>\n                           (Discr (x21aa, [], ve, nb b x21)) \\<union>\n                           {((x21, [x21 \\<mapsto> b]), x21aa)})\n 2. \\<And>x21 x22 x1 x21aa x21aaa aa baa bb.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI x1, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; x1 \\<noteq> 0;\n        isProc x21aa; isProc x21aaa;\n        ((aa, baa), bb)\n        \\<in> evalF\\<cdot>(Discr (x21aa, [], ve, nb b x21))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran baa \\<and> b \\<le> b'\n 3. \\<And>x21 x22 x21aa x21aaa.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; isProc x21aa;\n        isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (evalF\\<cdot>\n                           (Discr (x21aaa, [], ve, nb b x22)) \\<union>\n                           {((x22, [x22 \\<mapsto> b]), x21aaa)})\n 4. \\<And>x21 x22 x21aa x21aaa aa baa bb.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; isProc x21aa;\n        isProc x21aaa;\n        ((aa, baa), bb)\n        \\<in> evalF\\<cdot>(Discr (x21aaa, [], ve, nb b x22))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran baa \\<and> b \\<le> b'", "txt \\<open>Case If (true branch)\\<close>"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x21 x22 x1 x21aa x21aaa.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI x1, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; x1 \\<noteq> 0;\n        isProc x21aa; isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (evalF\\<cdot>\n                           (Discr (x21aa, [], ve, nb b x21)) \\<union>\n                           {((x21, [x21 \\<mapsto> b]), x21aa)})\n 2. \\<And>x21 x22 x1 x21aa x21aaa aa baa bb.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI x1, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; x1 \\<noteq> 0;\n        isProc x21aa; isProc x21aaa;\n        ((aa, baa), bb)\n        \\<in> evalF\\<cdot>(Discr (x21aa, [], ve, nb b x21))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran baa \\<and> b \\<le> b'\n 3. \\<And>x21 x22 x21aa x21aaa.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; isProc x21aa;\n        isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (evalF\\<cdot>\n                           (Discr (x21aaa, [], ve, nb b x22)) \\<union>\n                           {((x22, [x22 \\<mapsto> b]), x21aaa)})\n 4. \\<And>x21 x22 x21aa x21aaa aa baa bb.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; isProc x21aa;\n        isProc x21aaa;\n        ((aa, baa), bb)\n        \\<in> evalF\\<cdot>(Discr (x21aaa, [], ve, nb b x22))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran baa \\<and> b \\<le> b'", "fix cp1 cp2 i cntt cntf"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x21 x22 x1 x21aa x21aaa.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI x1, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; x1 \\<noteq> 0;\n        isProc x21aa; isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (evalF\\<cdot>\n                           (Discr (x21aa, [], ve, nb b x21)) \\<union>\n                           {((x21, [x21 \\<mapsto> b]), x21aa)})\n 2. \\<And>x21 x22 x1 x21aa x21aaa aa baa bb.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI x1, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; x1 \\<noteq> 0;\n        isProc x21aa; isProc x21aaa;\n        ((aa, baa), bb)\n        \\<in> evalF\\<cdot>(Discr (x21aa, [], ve, nb b x21))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran baa \\<and> b \\<le> b'\n 3. \\<And>x21 x22 x21aa x21aaa.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; isProc x21aa;\n        isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (evalF\\<cdot>\n                           (Discr (x21aaa, [], ve, nb b x22)) \\<union>\n                           {((x22, [x22 \\<mapsto> b]), x21aaa)})\n 4. \\<And>x21 x22 x21aa x21aaa aa baa bb.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; isProc x21aa;\n        isProc x21aaa;\n        ((aa, baa), bb)\n        \\<in> evalF\\<cdot>(Discr (x21aaa, [], ve, nb b x22))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran baa \\<and> b \\<le> b'", "assume \"\\<forall>b'\\<in>contours_in_d cntt. b' < b\""], ["proof (state)\nthis:\n  \\<forall>b'\\<in>contours_in_d cntt. b' < b\n\ngoal (4 subgoals):\n 1. \\<And>x21 x22 x1 x21aa x21aaa.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI x1, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; x1 \\<noteq> 0;\n        isProc x21aa; isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (evalF\\<cdot>\n                           (Discr (x21aa, [], ve, nb b x21)) \\<union>\n                           {((x21, [x21 \\<mapsto> b]), x21aa)})\n 2. \\<And>x21 x22 x1 x21aa x21aaa aa baa bb.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI x1, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; x1 \\<noteq> 0;\n        isProc x21aa; isProc x21aaa;\n        ((aa, baa), bb)\n        \\<in> evalF\\<cdot>(Discr (x21aa, [], ve, nb b x21))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran baa \\<and> b \\<le> b'\n 3. \\<And>x21 x22 x21aa x21aaa.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; isProc x21aa;\n        isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (evalF\\<cdot>\n                           (Discr (x21aaa, [], ve, nb b x22)) \\<union>\n                           {((x22, [x22 \\<mapsto> b]), x21aaa)})\n 4. \\<And>x21 x22 x21aa x21aaa aa baa bb.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; isProc x21aa;\n        isProc x21aaa;\n        ((aa, baa), bb)\n        \\<in> evalF\\<cdot>(Discr (x21aaa, [], ve, nb b x22))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran baa \\<and> b \\<le> b'", "hence b_dom_d: \"\\<forall>b'\\<in>contours_in_d cntt. b' < nb b cp1\""], ["proof (prove)\nusing this:\n  \\<forall>b'\\<in>contours_in_d cntt. b' < b\n\ngoal (1 subgoal):\n 1. \\<forall>b'\\<in>contours_in_d cntt. b' < nb b cp1", "by auto"], ["proof (state)\nthis:\n  \\<forall>b'\\<in>contours_in_d cntt. b' < nb b cp1\n\ngoal (4 subgoals):\n 1. \\<And>x21 x22 x1 x21aa x21aaa.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI x1, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; x1 \\<noteq> 0;\n        isProc x21aa; isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (evalF\\<cdot>\n                           (Discr (x21aa, [], ve, nb b x21)) \\<union>\n                           {((x21, [x21 \\<mapsto> b]), x21aa)})\n 2. \\<And>x21 x22 x1 x21aa x21aaa aa baa bb.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI x1, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; x1 \\<noteq> 0;\n        isProc x21aa; isProc x21aaa;\n        ((aa, baa), bb)\n        \\<in> evalF\\<cdot>(Discr (x21aa, [], ve, nb b x21))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran baa \\<and> b \\<le> b'\n 3. \\<And>x21 x22 x21aa x21aaa.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; isProc x21aa;\n        isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (evalF\\<cdot>\n                           (Discr (x21aaa, [], ve, nb b x22)) \\<union>\n                           {((x22, [x22 \\<mapsto> b]), x21aaa)})\n 4. \\<And>x21 x22 x21aa x21aaa aa baa bb.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; isProc x21aa;\n        isProc x21aaa;\n        ((aa, baa), bb)\n        \\<in> evalF\\<cdot>(Discr (x21aaa, [], ve, nb b x22))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran baa \\<and> b \\<le> b'", "have b_dom_ds: \"\\<forall>d' \\<in> set []. \\<forall>b'\\<in>contours_in_d d'. b' < nb b cp1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>d'\\<in>set []. \\<forall>b'\\<in>contours_in_d d'. b' < nb b cp1", "by auto"], ["proof (state)\nthis:\n  \\<forall>d'\\<in>set []. \\<forall>b'\\<in>contours_in_d d'. b' < nb b cp1\n\ngoal (4 subgoals):\n 1. \\<And>x21 x22 x1 x21aa x21aaa.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI x1, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; x1 \\<noteq> 0;\n        isProc x21aa; isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (evalF\\<cdot>\n                           (Discr (x21aa, [], ve, nb b x21)) \\<union>\n                           {((x21, [x21 \\<mapsto> b]), x21aa)})\n 2. \\<And>x21 x22 x1 x21aa x21aaa aa baa bb.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI x1, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; x1 \\<noteq> 0;\n        isProc x21aa; isProc x21aaa;\n        ((aa, baa), bb)\n        \\<in> evalF\\<cdot>(Discr (x21aa, [], ve, nb b x21))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran baa \\<and> b \\<le> b'\n 3. \\<And>x21 x22 x21aa x21aaa.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; isProc x21aa;\n        isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (evalF\\<cdot>\n                           (Discr (x21aaa, [], ve, nb b x22)) \\<union>\n                           {((x22, [x22 \\<mapsto> b]), x21aaa)})\n 4. \\<And>x21 x22 x21aa x21aaa aa baa bb.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; isProc x21aa;\n        isProc x21aaa;\n        ((aa, baa), bb)\n        \\<in> evalF\\<cdot>(Discr (x21aaa, [], ve, nb b x22))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran baa \\<and> b \\<le> b'", "have b_dom_ve: \"\\<forall>b' \\<in> contours_in_ve ve. b' < nb b cp1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>b'\\<in>contours_in_ve ve. b' < nb b cp1", "using \"1.prems\"(1)"], ["proof (prove)\nusing this:\n  \\<forall>b'\\<in>contours_in_ve ve. b' < b\n\ngoal (1 subgoal):\n 1. \\<forall>b'\\<in>contours_in_ve ve. b' < nb b cp1", "by auto"], ["proof (state)\nthis:\n  \\<forall>b'\\<in>contours_in_ve ve. b' < nb b cp1\n\ngoal (4 subgoals):\n 1. \\<And>x21 x22 x1 x21aa x21aaa.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI x1, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; x1 \\<noteq> 0;\n        isProc x21aa; isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (evalF\\<cdot>\n                           (Discr (x21aa, [], ve, nb b x21)) \\<union>\n                           {((x21, [x21 \\<mapsto> b]), x21aa)})\n 2. \\<And>x21 x22 x1 x21aa x21aaa aa baa bb.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI x1, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; x1 \\<noteq> 0;\n        isProc x21aa; isProc x21aaa;\n        ((aa, baa), bb)\n        \\<in> evalF\\<cdot>(Discr (x21aa, [], ve, nb b x21))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran baa \\<and> b \\<le> b'\n 3. \\<And>x21 x22 x21aa x21aaa.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; isProc x21aa;\n        isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (evalF\\<cdot>\n                           (Discr (x21aaa, [], ve, nb b x22)) \\<union>\n                           {((x22, [x22 \\<mapsto> b]), x21aaa)})\n 4. \\<And>x21 x22 x21aa x21aaa aa baa bb.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; isProc x21aa;\n        isProc x21aaa;\n        ((aa, baa), bb)\n        \\<in> evalF\\<cdot>(Discr (x21aaa, [], ve, nb b x22))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran baa \\<and> b \\<le> b'", "{"], ["proof (state)\nthis:\n  \\<forall>b'\\<in>contours_in_ve ve. b' < nb b cp1\n\ngoal (4 subgoals):\n 1. \\<And>x21 x22 x1 x21aa x21aaa.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI x1, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; x1 \\<noteq> 0;\n        isProc x21aa; isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (evalF\\<cdot>\n                           (Discr (x21aa, [], ve, nb b x21)) \\<union>\n                           {((x21, [x21 \\<mapsto> b]), x21aa)})\n 2. \\<And>x21 x22 x1 x21aa x21aaa aa baa bb.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI x1, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; x1 \\<noteq> 0;\n        isProc x21aa; isProc x21aaa;\n        ((aa, baa), bb)\n        \\<in> evalF\\<cdot>(Discr (x21aa, [], ve, nb b x21))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran baa \\<and> b \\<le> b'\n 3. \\<And>x21 x22 x21aa x21aaa.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; isProc x21aa;\n        isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (evalF\\<cdot>\n                           (Discr (x21aaa, [], ve, nb b x22)) \\<union>\n                           {((x22, [x22 \\<mapsto> b]), x21aaa)})\n 4. \\<And>x21 x22 x21aa x21aaa aa baa bb.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; isProc x21aa;\n        isProc x21aaa;\n        ((aa, baa), bb)\n        \\<in> evalF\\<cdot>(Discr (x21aaa, [], ve, nb b x22))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran baa \\<and> b \\<le> b'", "fix t"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x21 x22 x1 x21aa x21aaa.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI x1, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; x1 \\<noteq> 0;\n        isProc x21aa; isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (evalF\\<cdot>\n                           (Discr (x21aa, [], ve, nb b x21)) \\<union>\n                           {((x21, [x21 \\<mapsto> b]), x21aa)})\n 2. \\<And>x21 x22 x1 x21aa x21aaa aa baa bb.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI x1, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; x1 \\<noteq> 0;\n        isProc x21aa; isProc x21aaa;\n        ((aa, baa), bb)\n        \\<in> evalF\\<cdot>(Discr (x21aa, [], ve, nb b x21))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran baa \\<and> b \\<le> b'\n 3. \\<And>x21 x22 x21aa x21aaa.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; isProc x21aa;\n        isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (evalF\\<cdot>\n                           (Discr (x21aaa, [], ve, nb b x22)) \\<union>\n                           {((x22, [x22 \\<mapsto> b]), x21aaa)})\n 4. \\<And>x21 x22 x21aa x21aaa aa baa bb.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; isProc x21aa;\n        isProc x21aaa;\n        ((aa, baa), bb)\n        \\<in> evalF\\<cdot>(Discr (x21aaa, [], ve, nb b x22))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran baa \\<and> b \\<le> b'", "assume \"((cp1,[cp1 \\<mapsto> b]), t) \\<in> evalF\\<cdot>(Discr (cntt, [], ve, nb b cp1))\""], ["proof (state)\nthis:\n  ((cp1, [cp1 \\<mapsto> b]), t)\n  \\<in> evalF\\<cdot>(Discr (cntt, [], ve, nb b cp1))\n\ngoal (4 subgoals):\n 1. \\<And>x21 x22 x1 x21aa x21aaa.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI x1, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; x1 \\<noteq> 0;\n        isProc x21aa; isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (evalF\\<cdot>\n                           (Discr (x21aa, [], ve, nb b x21)) \\<union>\n                           {((x21, [x21 \\<mapsto> b]), x21aa)})\n 2. \\<And>x21 x22 x1 x21aa x21aaa aa baa bb.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI x1, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; x1 \\<noteq> 0;\n        isProc x21aa; isProc x21aaa;\n        ((aa, baa), bb)\n        \\<in> evalF\\<cdot>(Discr (x21aa, [], ve, nb b x21))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran baa \\<and> b \\<le> b'\n 3. \\<And>x21 x22 x21aa x21aaa.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; isProc x21aa;\n        isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (evalF\\<cdot>\n                           (Discr (x21aaa, [], ve, nb b x22)) \\<union>\n                           {((x22, [x22 \\<mapsto> b]), x21aaa)})\n 4. \\<And>x21 x22 x21aa x21aaa aa baa bb.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; isProc x21aa;\n        isProc x21aaa;\n        ((aa, baa), bb)\n        \\<in> evalF\\<cdot>(Discr (x21aaa, [], ve, nb b x22))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran baa \\<and> b \\<le> b'", "hence False"], ["proof (prove)\nusing this:\n  ((cp1, [cp1 \\<mapsto> b]), t)\n  \\<in> evalF\\<cdot>(Discr (cntt, [], ve, nb b cp1))\n\ngoal (1 subgoal):\n 1. False", "by (auto dest:hyps_F_b[OF b_dom_ve b_dom_d b_dom_ds])"], ["proof (state)\nthis:\n  False\n\ngoal (4 subgoals):\n 1. \\<And>x21 x22 x1 x21aa x21aaa.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI x1, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; x1 \\<noteq> 0;\n        isProc x21aa; isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (evalF\\<cdot>\n                           (Discr (x21aa, [], ve, nb b x21)) \\<union>\n                           {((x21, [x21 \\<mapsto> b]), x21aa)})\n 2. \\<And>x21 x22 x1 x21aa x21aaa aa baa bb.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI x1, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; x1 \\<noteq> 0;\n        isProc x21aa; isProc x21aaa;\n        ((aa, baa), bb)\n        \\<in> evalF\\<cdot>(Discr (x21aa, [], ve, nb b x21))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran baa \\<and> b \\<le> b'\n 3. \\<And>x21 x22 x21aa x21aaa.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; isProc x21aa;\n        isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (evalF\\<cdot>\n                           (Discr (x21aaa, [], ve, nb b x22)) \\<union>\n                           {((x22, [x22 \\<mapsto> b]), x21aaa)})\n 4. \\<And>x21 x22 x21aa x21aaa aa baa bb.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; isProc x21aa;\n        isProc x21aaa;\n        ((aa, baa), bb)\n        \\<in> evalF\\<cdot>(Discr (x21aaa, [], ve, nb b x22))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran baa \\<and> b \\<le> b'", "}"], ["proof (state)\nthis:\n  ((cp1, [cp1 \\<mapsto> b]), ?t2)\n  \\<in> evalF\\<cdot>(Discr (cntt, [], ve, nb b cp1)) \\<Longrightarrow>\n  False\n\ngoal (4 subgoals):\n 1. \\<And>x21 x22 x1 x21aa x21aaa.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI x1, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; x1 \\<noteq> 0;\n        isProc x21aa; isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (evalF\\<cdot>\n                           (Discr (x21aa, [], ve, nb b x21)) \\<union>\n                           {((x21, [x21 \\<mapsto> b]), x21aa)})\n 2. \\<And>x21 x22 x1 x21aa x21aaa aa baa bb.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI x1, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; x1 \\<noteq> 0;\n        isProc x21aa; isProc x21aaa;\n        ((aa, baa), bb)\n        \\<in> evalF\\<cdot>(Discr (x21aa, [], ve, nb b x21))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran baa \\<and> b \\<le> b'\n 3. \\<And>x21 x22 x21aa x21aaa.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; isProc x21aa;\n        isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (evalF\\<cdot>\n                           (Discr (x21aaa, [], ve, nb b x22)) \\<union>\n                           {((x22, [x22 \\<mapsto> b]), x21aaa)})\n 4. \\<And>x21 x22 x21aa x21aaa aa baa bb.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; isProc x21aa;\n        isProc x21aaa;\n        ((aa, baa), bb)\n        \\<in> evalF\\<cdot>(Discr (x21aaa, [], ve, nb b x22))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran baa \\<and> b \\<le> b'", "with Next.hyps(1)[OF b_dom_ve b_dom_d b_dom_ds, THEN conjunct1]"], ["proof (chain)\npicking this:\n  single_valued (evalF\\<cdot>(Discr (cntt, [], ve, nb b cp1)))\n  ((cp1, [cp1 \\<mapsto> b]), ?t2)\n  \\<in> evalF\\<cdot>(Discr (cntt, [], ve, nb b cp1)) \\<Longrightarrow>\n  False", "show \"single_valued ((evalF\\<cdot>(Discr (cntt, [], ve, nb b cp1)))\n                       \\<union> {((cp1, [cp1 \\<mapsto> b]), cntt)})\""], ["proof (prove)\nusing this:\n  single_valued (evalF\\<cdot>(Discr (cntt, [], ve, nb b cp1)))\n  ((cp1, [cp1 \\<mapsto> b]), ?t2)\n  \\<in> evalF\\<cdot>(Discr (cntt, [], ve, nb b cp1)) \\<Longrightarrow>\n  False\n\ngoal (1 subgoal):\n 1. single_valued\n     (evalF\\<cdot>(Discr (cntt, [], ve, nb b cp1)) \\<union>\n      {((cp1, [cp1 \\<mapsto> b]), cntt)})", "by (auto intro:single_valued_insert)"], ["proof (state)\nthis:\n  single_valued\n   (evalF\\<cdot>(Discr (cntt, [], ve, nb b cp1)) \\<union>\n    {((cp1, [cp1 \\<mapsto> b]), cntt)})\n\ngoal (3 subgoals):\n 1. \\<And>x21 x22 x1 x21aa x21aaa aa baa bb.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI x1, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; x1 \\<noteq> 0;\n        isProc x21aa; isProc x21aaa;\n        ((aa, baa), bb)\n        \\<in> evalF\\<cdot>(Discr (x21aa, [], ve, nb b x21))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran baa \\<and> b \\<le> b'\n 2. \\<And>x21 x22 x21aa x21aaa.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; isProc x21aa;\n        isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (evalF\\<cdot>\n                           (Discr (x21aaa, [], ve, nb b x22)) \\<union>\n                           {((x22, [x22 \\<mapsto> b]), x21aaa)})\n 3. \\<And>x21 x22 x21aa x21aaa aa baa bb.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; isProc x21aa;\n        isProc x21aaa;\n        ((aa, baa), bb)\n        \\<in> evalF\\<cdot>(Discr (x21aaa, [], ve, nb b x22))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran baa \\<and> b \\<le> b'", "fix lab \\<beta> t"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x21 x22 x1 x21aa x21aaa aa baa bb.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI x1, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; x1 \\<noteq> 0;\n        isProc x21aa; isProc x21aaa;\n        ((aa, baa), bb)\n        \\<in> evalF\\<cdot>(Discr (x21aa, [], ve, nb b x21))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran baa \\<and> b \\<le> b'\n 2. \\<And>x21 x22 x21aa x21aaa.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; isProc x21aa;\n        isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (evalF\\<cdot>\n                           (Discr (x21aaa, [], ve, nb b x22)) \\<union>\n                           {((x22, [x22 \\<mapsto> b]), x21aaa)})\n 3. \\<And>x21 x22 x21aa x21aaa aa baa bb.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; isProc x21aa;\n        isProc x21aaa;\n        ((aa, baa), bb)\n        \\<in> evalF\\<cdot>(Discr (x21aaa, [], ve, nb b x22))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran baa \\<and> b \\<le> b'", "assume \"((lab, \\<beta>), t) \\<in> evalF\\<cdot>(Discr (cntt, [], ve, nb b cp1))\""], ["proof (state)\nthis:\n  ((lab, \\<beta>), t) \\<in> evalF\\<cdot>(Discr (cntt, [], ve, nb b cp1))\n\ngoal (3 subgoals):\n 1. \\<And>x21 x22 x1 x21aa x21aaa aa baa bb.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI x1, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; x1 \\<noteq> 0;\n        isProc x21aa; isProc x21aaa;\n        ((aa, baa), bb)\n        \\<in> evalF\\<cdot>(Discr (x21aa, [], ve, nb b x21))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran baa \\<and> b \\<le> b'\n 2. \\<And>x21 x22 x21aa x21aaa.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; isProc x21aa;\n        isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (evalF\\<cdot>\n                           (Discr (x21aaa, [], ve, nb b x22)) \\<union>\n                           {((x22, [x22 \\<mapsto> b]), x21aaa)})\n 3. \\<And>x21 x22 x21aa x21aaa aa baa bb.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; isProc x21aa;\n        isProc x21aaa;\n        ((aa, baa), bb)\n        \\<in> evalF\\<cdot>(Discr (x21aaa, [], ve, nb b x22))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran baa \\<and> b \\<le> b'", "thus \"\\<exists>b'. b' \\<in> ran \\<beta> \\<and> b \\<le> b'\""], ["proof (prove)\nusing this:\n  ((lab, \\<beta>), t) \\<in> evalF\\<cdot>(Discr (cntt, [], ve, nb b cp1))\n\ngoal (1 subgoal):\n 1. \\<exists>b'. b' \\<in> ran \\<beta> \\<and> b \\<le> b'", "by (auto dest: hyps_F_b[OF b_dom_ve b_dom_d b_dom_ds])"], ["proof (state)\nthis:\n  \\<exists>b'. b' \\<in> ran \\<beta> \\<and> b \\<le> b'\n\ngoal (2 subgoals):\n 1. \\<And>x21 x22 x21aa x21aaa.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; isProc x21aa;\n        isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (evalF\\<cdot>\n                           (Discr (x21aaa, [], ve, nb b x22)) \\<union>\n                           {((x22, [x22 \\<mapsto> b]), x21aaa)})\n 2. \\<And>x21 x22 x21aa x21aaa aa baa bb.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; isProc x21aa;\n        isProc x21aaa;\n        ((aa, baa), bb)\n        \\<in> evalF\\<cdot>(Discr (x21aaa, [], ve, nb b x22))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran baa \\<and> b \\<le> b'", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x21 x22 x21aa x21aaa.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; isProc x21aa;\n        isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (evalF\\<cdot>\n                           (Discr (x21aaa, [], ve, nb b x22)) \\<union>\n                           {((x22, [x22 \\<mapsto> b]), x21aaa)})\n 2. \\<And>x21 x22 x21aa x21aaa aa baa bb.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; isProc x21aa;\n        isProc x21aaa;\n        ((aa, baa), bb)\n        \\<in> evalF\\<cdot>(Discr (x21aaa, [], ve, nb b x22))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran baa \\<and> b \\<le> b'", "txt \\<open>Case If (false branch). Variable names swapped for easier code reuse.\\<close>"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x21 x22 x21aa x21aaa.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; isProc x21aa;\n        isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (evalF\\<cdot>\n                           (Discr (x21aaa, [], ve, nb b x22)) \\<union>\n                           {((x22, [x22 \\<mapsto> b]), x21aaa)})\n 2. \\<And>x21 x22 x21aa x21aaa aa baa bb.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; isProc x21aa;\n        isProc x21aaa;\n        ((aa, baa), bb)\n        \\<in> evalF\\<cdot>(Discr (x21aaa, [], ve, nb b x22))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran baa \\<and> b \\<le> b'", "fix cp2 cp1 i cntf cntt"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x21 x22 x21aa x21aaa.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; isProc x21aa;\n        isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (evalF\\<cdot>\n                           (Discr (x21aaa, [], ve, nb b x22)) \\<union>\n                           {((x22, [x22 \\<mapsto> b]), x21aaa)})\n 2. \\<And>x21 x22 x21aa x21aaa aa baa bb.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; isProc x21aa;\n        isProc x21aaa;\n        ((aa, baa), bb)\n        \\<in> evalF\\<cdot>(Discr (x21aaa, [], ve, nb b x22))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran baa \\<and> b \\<le> b'", "assume \"\\<forall>b'\\<in>contours_in_d cntt. b' < b\""], ["proof (state)\nthis:\n  \\<forall>b'\\<in>contours_in_d cntt. b' < b\n\ngoal (2 subgoals):\n 1. \\<And>x21 x22 x21aa x21aaa.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; isProc x21aa;\n        isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (evalF\\<cdot>\n                           (Discr (x21aaa, [], ve, nb b x22)) \\<union>\n                           {((x22, [x22 \\<mapsto> b]), x21aaa)})\n 2. \\<And>x21 x22 x21aa x21aaa aa baa bb.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; isProc x21aa;\n        isProc x21aaa;\n        ((aa, baa), bb)\n        \\<in> evalF\\<cdot>(Discr (x21aaa, [], ve, nb b x22))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran baa \\<and> b \\<le> b'", "hence b_dom_d: \"\\<forall>b'\\<in>contours_in_d cntt. b' < nb b cp1\""], ["proof (prove)\nusing this:\n  \\<forall>b'\\<in>contours_in_d cntt. b' < b\n\ngoal (1 subgoal):\n 1. \\<forall>b'\\<in>contours_in_d cntt. b' < nb b cp1", "by auto"], ["proof (state)\nthis:\n  \\<forall>b'\\<in>contours_in_d cntt. b' < nb b cp1\n\ngoal (2 subgoals):\n 1. \\<And>x21 x22 x21aa x21aaa.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; isProc x21aa;\n        isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (evalF\\<cdot>\n                           (Discr (x21aaa, [], ve, nb b x22)) \\<union>\n                           {((x22, [x22 \\<mapsto> b]), x21aaa)})\n 2. \\<And>x21 x22 x21aa x21aaa aa baa bb.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; isProc x21aa;\n        isProc x21aaa;\n        ((aa, baa), bb)\n        \\<in> evalF\\<cdot>(Discr (x21aaa, [], ve, nb b x22))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran baa \\<and> b \\<le> b'", "have b_dom_ds: \"\\<forall>d' \\<in> set []. \\<forall>b'\\<in>contours_in_d d'. b' < nb b cp1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>d'\\<in>set []. \\<forall>b'\\<in>contours_in_d d'. b' < nb b cp1", "by auto"], ["proof (state)\nthis:\n  \\<forall>d'\\<in>set []. \\<forall>b'\\<in>contours_in_d d'. b' < nb b cp1\n\ngoal (2 subgoals):\n 1. \\<And>x21 x22 x21aa x21aaa.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; isProc x21aa;\n        isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (evalF\\<cdot>\n                           (Discr (x21aaa, [], ve, nb b x22)) \\<union>\n                           {((x22, [x22 \\<mapsto> b]), x21aaa)})\n 2. \\<And>x21 x22 x21aa x21aaa aa baa bb.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; isProc x21aa;\n        isProc x21aaa;\n        ((aa, baa), bb)\n        \\<in> evalF\\<cdot>(Discr (x21aaa, [], ve, nb b x22))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran baa \\<and> b \\<le> b'", "have b_dom_ve: \"\\<forall>b' \\<in> contours_in_ve ve. b' < nb b cp1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>b'\\<in>contours_in_ve ve. b' < nb b cp1", "using \"1.prems\"(1)"], ["proof (prove)\nusing this:\n  \\<forall>b'\\<in>contours_in_ve ve. b' < b\n\ngoal (1 subgoal):\n 1. \\<forall>b'\\<in>contours_in_ve ve. b' < nb b cp1", "by auto"], ["proof (state)\nthis:\n  \\<forall>b'\\<in>contours_in_ve ve. b' < nb b cp1\n\ngoal (2 subgoals):\n 1. \\<And>x21 x22 x21aa x21aaa.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; isProc x21aa;\n        isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (evalF\\<cdot>\n                           (Discr (x21aaa, [], ve, nb b x22)) \\<union>\n                           {((x22, [x22 \\<mapsto> b]), x21aaa)})\n 2. \\<And>x21 x22 x21aa x21aaa aa baa bb.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; isProc x21aa;\n        isProc x21aaa;\n        ((aa, baa), bb)\n        \\<in> evalF\\<cdot>(Discr (x21aaa, [], ve, nb b x22))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran baa \\<and> b \\<le> b'", "{"], ["proof (state)\nthis:\n  \\<forall>b'\\<in>contours_in_ve ve. b' < nb b cp1\n\ngoal (2 subgoals):\n 1. \\<And>x21 x22 x21aa x21aaa.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; isProc x21aa;\n        isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (evalF\\<cdot>\n                           (Discr (x21aaa, [], ve, nb b x22)) \\<union>\n                           {((x22, [x22 \\<mapsto> b]), x21aaa)})\n 2. \\<And>x21 x22 x21aa x21aaa aa baa bb.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; isProc x21aa;\n        isProc x21aaa;\n        ((aa, baa), bb)\n        \\<in> evalF\\<cdot>(Discr (x21aaa, [], ve, nb b x22))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran baa \\<and> b \\<le> b'", "fix t"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x21 x22 x21aa x21aaa.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; isProc x21aa;\n        isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (evalF\\<cdot>\n                           (Discr (x21aaa, [], ve, nb b x22)) \\<union>\n                           {((x22, [x22 \\<mapsto> b]), x21aaa)})\n 2. \\<And>x21 x22 x21aa x21aaa aa baa bb.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; isProc x21aa;\n        isProc x21aaa;\n        ((aa, baa), bb)\n        \\<in> evalF\\<cdot>(Discr (x21aaa, [], ve, nb b x22))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran baa \\<and> b \\<le> b'", "assume \"((cp1,[cp1 \\<mapsto> b]), t) \\<in> evalF\\<cdot>(Discr (cntt, [], ve, nb b cp1))\""], ["proof (state)\nthis:\n  ((cp1, [cp1 \\<mapsto> b]), t)\n  \\<in> evalF\\<cdot>(Discr (cntt, [], ve, nb b cp1))\n\ngoal (2 subgoals):\n 1. \\<And>x21 x22 x21aa x21aaa.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; isProc x21aa;\n        isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (evalF\\<cdot>\n                           (Discr (x21aaa, [], ve, nb b x22)) \\<union>\n                           {((x22, [x22 \\<mapsto> b]), x21aaa)})\n 2. \\<And>x21 x22 x21aa x21aaa aa baa bb.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; isProc x21aa;\n        isProc x21aaa;\n        ((aa, baa), bb)\n        \\<in> evalF\\<cdot>(Discr (x21aaa, [], ve, nb b x22))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran baa \\<and> b \\<le> b'", "hence False"], ["proof (prove)\nusing this:\n  ((cp1, [cp1 \\<mapsto> b]), t)\n  \\<in> evalF\\<cdot>(Discr (cntt, [], ve, nb b cp1))\n\ngoal (1 subgoal):\n 1. False", "by (auto dest:hyps_F_b[OF b_dom_ve b_dom_d b_dom_ds])"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. \\<And>x21 x22 x21aa x21aaa.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; isProc x21aa;\n        isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (evalF\\<cdot>\n                           (Discr (x21aaa, [], ve, nb b x22)) \\<union>\n                           {((x22, [x22 \\<mapsto> b]), x21aaa)})\n 2. \\<And>x21 x22 x21aa x21aaa aa baa bb.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; isProc x21aa;\n        isProc x21aaa;\n        ((aa, baa), bb)\n        \\<in> evalF\\<cdot>(Discr (x21aaa, [], ve, nb b x22))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran baa \\<and> b \\<le> b'", "}"], ["proof (state)\nthis:\n  ((cp1, [cp1 \\<mapsto> b]), ?t2)\n  \\<in> evalF\\<cdot>(Discr (cntt, [], ve, nb b cp1)) \\<Longrightarrow>\n  False\n\ngoal (2 subgoals):\n 1. \\<And>x21 x22 x21aa x21aaa.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; isProc x21aa;\n        isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (evalF\\<cdot>\n                           (Discr (x21aaa, [], ve, nb b x22)) \\<union>\n                           {((x22, [x22 \\<mapsto> b]), x21aaa)})\n 2. \\<And>x21 x22 x21aa x21aaa aa baa bb.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; isProc x21aa;\n        isProc x21aaa;\n        ((aa, baa), bb)\n        \\<in> evalF\\<cdot>(Discr (x21aaa, [], ve, nb b x22))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran baa \\<and> b \\<le> b'", "with Next.hyps(1)[OF b_dom_ve b_dom_d b_dom_ds, THEN conjunct1]"], ["proof (chain)\npicking this:\n  single_valued (evalF\\<cdot>(Discr (cntt, [], ve, nb b cp1)))\n  ((cp1, [cp1 \\<mapsto> b]), ?t2)\n  \\<in> evalF\\<cdot>(Discr (cntt, [], ve, nb b cp1)) \\<Longrightarrow>\n  False", "show \"single_valued ((evalF\\<cdot>(Discr (cntt, [], ve, nb b cp1)))\n                       \\<union> {((cp1, [cp1 \\<mapsto> b]), cntt)})\""], ["proof (prove)\nusing this:\n  single_valued (evalF\\<cdot>(Discr (cntt, [], ve, nb b cp1)))\n  ((cp1, [cp1 \\<mapsto> b]), ?t2)\n  \\<in> evalF\\<cdot>(Discr (cntt, [], ve, nb b cp1)) \\<Longrightarrow>\n  False\n\ngoal (1 subgoal):\n 1. single_valued\n     (evalF\\<cdot>(Discr (cntt, [], ve, nb b cp1)) \\<union>\n      {((cp1, [cp1 \\<mapsto> b]), cntt)})", "by (auto intro:single_valued_insert)"], ["proof (state)\nthis:\n  single_valued\n   (evalF\\<cdot>(Discr (cntt, [], ve, nb b cp1)) \\<union>\n    {((cp1, [cp1 \\<mapsto> b]), cntt)})\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x21aa x21aaa aa baa bb.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; isProc x21aa;\n        isProc x21aaa;\n        ((aa, baa), bb)\n        \\<in> evalF\\<cdot>(Discr (x21aaa, [], ve, nb b x22))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran baa \\<and> b \\<le> b'", "fix lab \\<beta> t"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x21aa x21aaa aa baa bb.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; isProc x21aa;\n        isProc x21aaa;\n        ((aa, baa), bb)\n        \\<in> evalF\\<cdot>(Discr (x21aaa, [], ve, nb b x22))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran baa \\<and> b \\<le> b'", "assume \"((lab, \\<beta>), t) \\<in> evalF\\<cdot>(Discr (cntt, [], ve, nb b cp1))\""], ["proof (state)\nthis:\n  ((lab, \\<beta>), t) \\<in> evalF\\<cdot>(Discr (cntt, [], ve, nb b cp1))\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x21aa x21aaa aa baa bb.\n       \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa];\n        \\<forall>b'\\<in>contours_in_d x21aa. b' < b;\n        \\<forall>b'\\<in>contours_in_d x21aaa. b' < b; isProc x21aa;\n        isProc x21aaa;\n        ((aa, baa), bb)\n        \\<in> evalF\\<cdot>(Discr (x21aaa, [], ve, nb b x22))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran baa \\<and> b \\<le> b'", "thus \"\\<exists>b'. b' \\<in> ran \\<beta> \\<and> b \\<le> b'\""], ["proof (prove)\nusing this:\n  ((lab, \\<beta>), t) \\<in> evalF\\<cdot>(Discr (cntt, [], ve, nb b cp1))\n\ngoal (1 subgoal):\n 1. \\<exists>b'. b' \\<in> ran \\<beta> \\<and> b \\<le> b'", "by (auto dest: hyps_F_b[OF b_dom_ve b_dom_d b_dom_ds])"], ["proof (state)\nthis:\n  \\<exists>b'. b' \\<in> ran \\<beta> \\<and> b \\<le> b'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  single_valued\n   ((\\<Lambda> fstate.\n        case undiscr fstate of (DI int, ba) \\<Rightarrow> \\<bottom>\n        | (DC (Lambda lab vs c, \\<beta>), as, ve, b) \\<Rightarrow>\n            if length vs = length as\n            then let \\<beta>' = \\<beta>(lab \\<mapsto> b);\n                     ve' = ve(map (\\<lambda>v. (v, b)) vs [\\<mapsto>] as)\n                 in evalC\\<cdot>(Discr (c, \\<beta>', ve', b))\n            else \\<bottom>\n        | (DP (Plus c), [], bb) \\<Rightarrow> \\<bottom>\n        | (DP (Plus c), [DI a1], bb) \\<Rightarrow> \\<bottom>\n        | (DP (Plus c), [DI a1, DI a2], bb) \\<Rightarrow> \\<bottom>\n        | (DP (Plus c), [DI a1, DI a2, cnt], ve, b) \\<Rightarrow>\n            if isProc cnt\n            then let b' = nb b c; \\<beta> = [c \\<mapsto> b]\n                 in evalF\\<cdot>\n                    (Discr (cnt, [DI (a1 + a2)], ve, b')) \\<union>\n                    {((c, \\<beta>), cnt)}\n            else \\<bottom>\n        | (DP (Plus c), DI a1 # DI a2 # cnt # aa # lista, bb) \\<Rightarrow>\n            \\<bottom>\n        | (DP (Plus c), DI a1 # _ # lista, bb) \\<Rightarrow> \\<bottom>\n        | (DP (Plus c), _ # list, bb) \\<Rightarrow> \\<bottom>\n        | (DP (prim.If ct cf), [], bb) \\<Rightarrow> \\<bottom>\n        | (DP (prim.If ct cf), [DI v], bb) \\<Rightarrow> \\<bottom>\n        | (DP (prim.If ct cf), [DI v, contt], bb) \\<Rightarrow> \\<bottom>\n        | (DP (prim.If ct cf), [DI v, contt, contf], ve, b) \\<Rightarrow>\n            if isProc contt \\<and> isProc contf\n            then if v \\<noteq> 0\n                 then let b' = nb b ct; \\<beta> = [ct \\<mapsto> b]\n                      in evalF\\<cdot>(Discr (contt, [], ve, b')) \\<union>\n                         {((ct, \\<beta>), contt)}\n                 else let b' = nb b cf; \\<beta> = [cf \\<mapsto> b]\n                      in evalF\\<cdot>(Discr (contf, [], ve, b')) \\<union>\n                         {((cf, \\<beta>), contf)}\n            else \\<bottom>\n        | (DP (prim.If ct cf), DI v # contt # contf # ab # lista,\n           bb) \\<Rightarrow>\n            \\<bottom>\n        | (DP (prim.If ct cf), _ # list, bb) \\<Rightarrow> \\<bottom>\n        | (Stop, [], bb) \\<Rightarrow> \\<bottom>\n        | (Stop, [DI i], x, xa) \\<Rightarrow> {}\n        | (Stop, DI i # a # lista, bb) \\<Rightarrow> \\<bottom>\n        | (Stop, _ # list, bb) \\<Rightarrow> \\<bottom>)\\<cdot>\n    (Discr (d, ds, ve, b))) \\<and>\n  (\\<forall>a\\<in>(\\<Lambda> fstate.\n                      case undiscr fstate of\n                      (DI int, ba) \\<Rightarrow> \\<bottom>\n                      | (DC (Lambda lab vs c, \\<beta>), as, ve,\n                         b) \\<Rightarrow>\n                          if length vs = length as\n                          then let \\<beta>' = \\<beta>(lab \\<mapsto> b);\n                                   ve' = ve(map (\\<lambda>v. (v, b)) vs \n                                     [\\<mapsto>] as)\n                               in evalC\\<cdot>(Discr (c, \\<beta>', ve', b))\n                          else \\<bottom>\n                      | (DP (Plus c), [], bb) \\<Rightarrow> \\<bottom>\n                      | (DP (Plus c), [DI a1], bb) \\<Rightarrow> \\<bottom>\n                      | (DP (Plus c), [DI a1, DI a2], bb) \\<Rightarrow>\n                          \\<bottom>\n                      | (DP (Plus c), [DI a1, DI a2, cnt], ve,\n                         b) \\<Rightarrow>\n                          if isProc cnt\n                          then let b' = nb b c; \\<beta> = [c \\<mapsto> b]\n                               in evalF\\<cdot>\n                                  (Discr\n                                    (cnt, [DI (a1 + a2)], ve, b')) \\<union>\n                                  {((c, \\<beta>), cnt)}\n                          else \\<bottom>\n                      | (DP (Plus c), DI a1 # DI a2 # cnt # aa # lista,\n                         bb) \\<Rightarrow>\n                          \\<bottom>\n                      | (DP (Plus c), DI a1 # _ # lista, bb) \\<Rightarrow>\n                          \\<bottom>\n                      | (DP (Plus c), _ # list, bb) \\<Rightarrow> \\<bottom>\n                      | (DP (prim.If ct cf), [], bb) \\<Rightarrow> \\<bottom>\n                      | (DP (prim.If ct cf), [DI v], bb) \\<Rightarrow>\n                          \\<bottom>\n                      | (DP (prim.If ct cf), [DI v, contt],\n                         bb) \\<Rightarrow>\n                          \\<bottom>\n                      | (DP (prim.If ct cf), [DI v, contt, contf], ve,\n                         b) \\<Rightarrow>\n                          if isProc contt \\<and> isProc contf\n                          then if v \\<noteq> 0\n                               then let b' = nb b ct;\n  \\<beta> = [ct \\<mapsto> b]\n                                    in evalF\\<cdot>\n (Discr (contt, [], ve, b')) \\<union>\n {((ct, \\<beta>), contt)}\n                               else let b' = nb b cf;\n  \\<beta> = [cf \\<mapsto> b]\n                                    in evalF\\<cdot>\n (Discr (contf, [], ve, b')) \\<union>\n {((cf, \\<beta>), contf)}\n                          else \\<bottom>\n                      | (DP (prim.If ct cf),\n                         DI v # contt # contf # ab # lista,\n                         bb) \\<Rightarrow>\n                          \\<bottom>\n                      | (DP (prim.If ct cf), _ # list, bb) \\<Rightarrow>\n                          \\<bottom>\n                      | (Stop, [], bb) \\<Rightarrow> \\<bottom>\n                      | (Stop, [DI i], x, xa) \\<Rightarrow> {}\n                      | (Stop, DI i # a # lista, bb) \\<Rightarrow> \\<bottom>\n                      | (Stop, _ # list, bb) \\<Rightarrow> \\<bottom>)\\<cdot>\n                  (Discr (d, ds, ve, b)).\n      case a of\n      (a, b) \\<Rightarrow>\n        (case a of\n         (lab, \\<beta>) \\<Rightarrow>\n           \\<lambda>t. \\<exists>b'. b' \\<in> ran \\<beta> \\<and> b \\<le> b')\n         b)\n\ngoal (1 subgoal):\n 1. \\<And>a b ve ba c \\<beta>'.\n       \\<lbrakk>\\<And>d ds ve b.\n                   \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n                    \\<forall>b'\\<in>contours_in_d d. b' < b;\n                    \\<forall>d'\\<in>set ds.\n                       \\<forall>b'\\<in>contours_in_d d'. b' < b\\<rbrakk>\n                   \\<Longrightarrow> single_valued\n(a\\<cdot>(Discr (d, ds, ve, b))) \\<and>\n                                     (\\<forall>((lab, \\<beta>), t)\n         \\<in>a\\<cdot>(Discr (d, ds, ve, b)).\n   \\<exists>b'. b' \\<in> ran \\<beta> \\<and> b \\<le> b');\n        \\<And>ve ba c \\<beta>'.\n           \\<lbrakk>ba \\<in> ran \\<beta>';\n            \\<forall>b'\\<in>ran \\<beta>'. b' \\<le> ba;\n            \\<forall>b'\\<in>contours_in_ve ve. b' \\<le> ba\\<rbrakk>\n           \\<Longrightarrow> single_valued\n                              (b\\<cdot>(Discr (c, \\<beta>', ve, ba))) \\<and>\n                             (\\<forall>((lab, \\<beta>), t)\n \\<in>b\\<cdot>(Discr (c, \\<beta>', ve, ba)).\n                                 \\<exists>b'.\n                                    b' \\<in> ran \\<beta> \\<and>\n                                    ba \\<le> b');\n        ba \\<in> ran \\<beta>'; \\<forall>b'\\<in>ran \\<beta>'. b' \\<le> ba;\n        \\<forall>b'\\<in>contours_in_ve ve. b' \\<le> ba\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          ((\\<Lambda> cstate.\n                               case undiscr cstate of\n                               (App lab f vs, \\<beta>, ve, b) \\<Rightarrow>\n                                 let f' = \\<A> f \\<beta> ve;\n                                     as =\n map (\\<lambda>v. \\<A> v \\<beta> ve) vs;\n                                     b' = nb b lab\n                                 in if isProc f'\n                                    then a\\<cdot>\n   (Discr (f', as, ve, b')) \\<union>\n   {((lab, \\<beta>), f')}\n                                    else \\<bottom>\n                               | (call.Let lab ls c', \\<beta>, ve,\n                                  ba) \\<Rightarrow>\n                                   let b' = nb ba lab;\n \\<beta>' = \\<beta>(lab \\<mapsto> b');\n ve' =\n   ve ++\n   map_of (map (\\<lambda>(v, l). ((v, b'), \\<A> (L l) \\<beta>' ve)) ls)\n                                   in b\\<cdot>\n(Discr (c', \\<beta>', ve', b')))\\<cdot>\n                           (Discr (c, \\<beta>', ve, ba))) \\<and>\n                         (\\<forall>((lab, \\<beta>), t)\n                                   \\<in>(\\<Lambda> cstate.\n      case undiscr cstate of\n      (App lab f vs, \\<beta>, ve, b) \\<Rightarrow>\n        let f' = \\<A> f \\<beta> ve;\n            as = map (\\<lambda>v. \\<A> v \\<beta> ve) vs; b' = nb b lab\n        in if isProc f'\n           then a\\<cdot>(Discr (f', as, ve, b')) \\<union>\n                {((lab, \\<beta>), f')}\n           else \\<bottom>\n      | (call.Let lab ls c', \\<beta>, ve, ba) \\<Rightarrow>\n          let b' = nb ba lab; \\<beta>' = \\<beta>(lab \\<mapsto> b');\n              ve' =\n                ve ++\n                map_of\n                 (map (\\<lambda>(v, l). ((v, b'), \\<A> (L l) \\<beta>' ve))\n                   ls)\n          in b\\<cdot>(Discr (c', \\<beta>', ve', b')))\\<cdot>\n  (Discr (c, \\<beta>', ve, ba)).\n                             \\<exists>b'.\n                                b' \\<in> ran \\<beta> \\<and> ba \\<le> b')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b ve ba c \\<beta>'.\n       \\<lbrakk>\\<And>d ds ve b.\n                   \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n                    \\<forall>b'\\<in>contours_in_d d. b' < b;\n                    \\<forall>d'\\<in>set ds.\n                       \\<forall>b'\\<in>contours_in_d d'. b' < b\\<rbrakk>\n                   \\<Longrightarrow> single_valued\n(a\\<cdot>(Discr (d, ds, ve, b))) \\<and>\n                                     (\\<forall>((lab, \\<beta>), t)\n         \\<in>a\\<cdot>(Discr (d, ds, ve, b)).\n   \\<exists>b'. b' \\<in> ran \\<beta> \\<and> b \\<le> b');\n        \\<And>ve ba c \\<beta>'.\n           \\<lbrakk>ba \\<in> ran \\<beta>';\n            \\<forall>b'\\<in>ran \\<beta>'. b' \\<le> ba;\n            \\<forall>b'\\<in>contours_in_ve ve. b' \\<le> ba\\<rbrakk>\n           \\<Longrightarrow> single_valued\n                              (b\\<cdot>(Discr (c, \\<beta>', ve, ba))) \\<and>\n                             (\\<forall>((lab, \\<beta>), t)\n \\<in>b\\<cdot>(Discr (c, \\<beta>', ve, ba)).\n                                 \\<exists>b'.\n                                    b' \\<in> ran \\<beta> \\<and>\n                                    ba \\<le> b');\n        ba \\<in> ran \\<beta>'; \\<forall>b'\\<in>ran \\<beta>'. b' \\<le> ba;\n        \\<forall>b'\\<in>contours_in_ve ve. b' \\<le> ba\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          ((\\<Lambda> cstate.\n                               case undiscr cstate of\n                               (App lab f vs, \\<beta>, ve, b) \\<Rightarrow>\n                                 let f' = \\<A> f \\<beta> ve;\n                                     as =\n map (\\<lambda>v. \\<A> v \\<beta> ve) vs;\n                                     b' = nb b lab\n                                 in if isProc f'\n                                    then a\\<cdot>\n   (Discr (f', as, ve, b')) \\<union>\n   {((lab, \\<beta>), f')}\n                                    else \\<bottom>\n                               | (call.Let lab ls c', \\<beta>, ve,\n                                  ba) \\<Rightarrow>\n                                   let b' = nb ba lab;\n \\<beta>' = \\<beta>(lab \\<mapsto> b');\n ve' =\n   ve ++\n   map_of (map (\\<lambda>(v, l). ((v, b'), \\<A> (L l) \\<beta>' ve)) ls)\n                                   in b\\<cdot>\n(Discr (c', \\<beta>', ve', b')))\\<cdot>\n                           (Discr (c, \\<beta>', ve, ba))) \\<and>\n                         (\\<forall>((lab, \\<beta>), t)\n                                   \\<in>(\\<Lambda> cstate.\n      case undiscr cstate of\n      (App lab f vs, \\<beta>, ve, b) \\<Rightarrow>\n        let f' = \\<A> f \\<beta> ve;\n            as = map (\\<lambda>v. \\<A> v \\<beta> ve) vs; b' = nb b lab\n        in if isProc f'\n           then a\\<cdot>(Discr (f', as, ve, b')) \\<union>\n                {((lab, \\<beta>), f')}\n           else \\<bottom>\n      | (call.Let lab ls c', \\<beta>, ve, ba) \\<Rightarrow>\n          let b' = nb ba lab; \\<beta>' = \\<beta>(lab \\<mapsto> b');\n              ve' =\n                ve ++\n                map_of\n                 (map (\\<lambda>(v, l). ((v, b'), \\<A> (L l) \\<beta>' ve))\n                   ls)\n          in b\\<cdot>(Discr (c', \\<beta>', ve', b')))\\<cdot>\n  (Discr (c, \\<beta>', ve, ba)).\n                             \\<exists>b'.\n                                b' \\<in> ran \\<beta> \\<and> ba \\<le> b')", "case (2 ve b c \\<beta>')"], ["proof (state)\nthis:\n  b \\<in> ran \\<beta>'\n  \\<forall>b'\\<in>ran \\<beta>'. b' \\<le> b\n  \\<forall>b'\\<in>contours_in_ve ve. b' \\<le> b\n\ngoal (1 subgoal):\n 1. \\<And>a b ve ba c \\<beta>'.\n       \\<lbrakk>\\<And>d ds ve b.\n                   \\<lbrakk>\\<forall>b'\\<in>contours_in_ve ve. b' < b;\n                    \\<forall>b'\\<in>contours_in_d d. b' < b;\n                    \\<forall>d'\\<in>set ds.\n                       \\<forall>b'\\<in>contours_in_d d'. b' < b\\<rbrakk>\n                   \\<Longrightarrow> single_valued\n(a\\<cdot>(Discr (d, ds, ve, b))) \\<and>\n                                     (\\<forall>((lab, \\<beta>), t)\n         \\<in>a\\<cdot>(Discr (d, ds, ve, b)).\n   \\<exists>b'. b' \\<in> ran \\<beta> \\<and> b \\<le> b');\n        \\<And>ve ba c \\<beta>'.\n           \\<lbrakk>ba \\<in> ran \\<beta>';\n            \\<forall>b'\\<in>ran \\<beta>'. b' \\<le> ba;\n            \\<forall>b'\\<in>contours_in_ve ve. b' \\<le> ba\\<rbrakk>\n           \\<Longrightarrow> single_valued\n                              (b\\<cdot>(Discr (c, \\<beta>', ve, ba))) \\<and>\n                             (\\<forall>((lab, \\<beta>), t)\n \\<in>b\\<cdot>(Discr (c, \\<beta>', ve, ba)).\n                                 \\<exists>b'.\n                                    b' \\<in> ran \\<beta> \\<and>\n                                    ba \\<le> b');\n        ba \\<in> ran \\<beta>'; \\<forall>b'\\<in>ran \\<beta>'. b' \\<le> ba;\n        \\<forall>b'\\<in>contours_in_ve ve. b' \\<le> ba\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          ((\\<Lambda> cstate.\n                               case undiscr cstate of\n                               (App lab f vs, \\<beta>, ve, b) \\<Rightarrow>\n                                 let f' = \\<A> f \\<beta> ve;\n                                     as =\n map (\\<lambda>v. \\<A> v \\<beta> ve) vs;\n                                     b' = nb b lab\n                                 in if isProc f'\n                                    then a\\<cdot>\n   (Discr (f', as, ve, b')) \\<union>\n   {((lab, \\<beta>), f')}\n                                    else \\<bottom>\n                               | (call.Let lab ls c', \\<beta>, ve,\n                                  ba) \\<Rightarrow>\n                                   let b' = nb ba lab;\n \\<beta>' = \\<beta>(lab \\<mapsto> b');\n ve' =\n   ve ++\n   map_of (map (\\<lambda>(v, l). ((v, b'), \\<A> (L l) \\<beta>' ve)) ls)\n                                   in b\\<cdot>\n(Discr (c', \\<beta>', ve', b')))\\<cdot>\n                           (Discr (c, \\<beta>', ve, ba))) \\<and>\n                         (\\<forall>((lab, \\<beta>), t)\n                                   \\<in>(\\<Lambda> cstate.\n      case undiscr cstate of\n      (App lab f vs, \\<beta>, ve, b) \\<Rightarrow>\n        let f' = \\<A> f \\<beta> ve;\n            as = map (\\<lambda>v. \\<A> v \\<beta> ve) vs; b' = nb b lab\n        in if isProc f'\n           then a\\<cdot>(Discr (f', as, ve, b')) \\<union>\n                {((lab, \\<beta>), f')}\n           else \\<bottom>\n      | (call.Let lab ls c', \\<beta>, ve, ba) \\<Rightarrow>\n          let b' = nb ba lab; \\<beta>' = \\<beta>(lab \\<mapsto> b');\n              ve' =\n                ve ++\n                map_of\n                 (map (\\<lambda>(v, l). ((v, b'), \\<A> (L l) \\<beta>' ve))\n                   ls)\n          in b\\<cdot>(Discr (c', \\<beta>', ve', b')))\\<cdot>\n  (Discr (c, \\<beta>', ve, ba)).\n                             \\<exists>b'.\n                                b' \\<in> ran \\<beta> \\<and> ba \\<le> b')", "thus ?case"], ["proof (prove)\nusing this:\n  b \\<in> ran \\<beta>'\n  \\<forall>b'\\<in>ran \\<beta>'. b' \\<le> b\n  \\<forall>b'\\<in>contours_in_ve ve. b' \\<le> b\n\ngoal (1 subgoal):\n 1. single_valued\n     ((\\<Lambda> cstate.\n          case undiscr cstate of\n          (App lab f vs, \\<beta>, ve, b) \\<Rightarrow>\n            let f' = \\<A> f \\<beta> ve;\n                as = map (\\<lambda>v. \\<A> v \\<beta> ve) vs; b' = nb b lab\n            in if isProc f'\n               then evalF\\<cdot>(Discr (f', as, ve, b')) \\<union>\n                    {((lab, \\<beta>), f')}\n               else \\<bottom>\n          | (call.Let lab ls c', \\<beta>, ve, b) \\<Rightarrow>\n              let b' = nb b lab; \\<beta>' = \\<beta>(lab \\<mapsto> b');\n                  ve' =\n                    ve ++\n                    map_of\n                     (map (\\<lambda>(v, l).\n                              ((v, b'), \\<A> (L l) \\<beta>' ve))\n                       ls)\n              in evalC\\<cdot>(Discr (c', \\<beta>', ve', b')))\\<cdot>\n      (Discr (c, \\<beta>', ve, b))) \\<and>\n    (\\<forall>a\\<in>(\\<Lambda> cstate.\n                        case undiscr cstate of\n                        (App lab f vs, \\<beta>, ve, b) \\<Rightarrow>\n                          let f' = \\<A> f \\<beta> ve;\n                              as = map (\\<lambda>v. \\<A> v \\<beta> ve) vs;\n                              b' = nb b lab\n                          in if isProc f'\n                             then evalF\\<cdot>\n                                  (Discr (f', as, ve, b')) \\<union>\n                                  {((lab, \\<beta>), f')}\n                             else \\<bottom>\n                        | (call.Let lab ls c', \\<beta>, ve, b) \\<Rightarrow>\n                            let b' = nb b lab;\n                                \\<beta>' = \\<beta>(lab \\<mapsto> b');\n                                ve' =\n                                  ve ++\n                                  map_of\n                                   (map (\\<lambda>(v, l).\n      ((v, b'), \\<A> (L l) \\<beta>' ve))\n                                     ls)\n                            in evalC\\<cdot>\n                               (Discr (c', \\<beta>', ve', b')))\\<cdot>\n                    (Discr (c, \\<beta>', ve, b)).\n        case a of\n        (a, b) \\<Rightarrow>\n          (case a of\n           (lab, \\<beta>) \\<Rightarrow>\n             \\<lambda>t.\n                \\<exists>b'. b' \\<in> ran \\<beta> \\<and> b \\<le> b')\n           b)", "proof (cases c, auto simp add:HOL.Let_def simp del:Un_insert_left Un_insert_right evalV.simps)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x11 x12 x13.\n       \\<lbrakk>c = App x11 x12 x13; b \\<in> ran \\<beta>';\n        \\<forall>b'\\<in>ran \\<beta>'. b' \\<le> b;\n        \\<forall>b'\\<in>contours_in_ve ve. b' \\<le> b;\n        isProc (\\<A> x12 \\<beta>' ve)\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (evalF\\<cdot>\n                           (Discr\n                             (\\<A> x12 \\<beta>' ve,\n                              map (\\<lambda>v. \\<A> v \\<beta>' ve) x13, ve,\n                              nb b x11)) \\<union>\n                           {((x11, \\<beta>'), \\<A> x12 \\<beta>' ve)})\n 2. \\<And>x11 x12 x13 a b baa.\n       \\<lbrakk>c = App x11 x12 x13; b \\<in> ran \\<beta>';\n        \\<forall>b'\\<in>ran \\<beta>'. b' \\<le> b;\n        \\<forall>b'\\<in>contours_in_ve ve. b' \\<le> b;\n        isProc (\\<A> x12 \\<beta>' ve);\n        ((a, b), baa)\n        \\<in> evalF\\<cdot>\n              (Discr\n                (\\<A> x12 \\<beta>' ve,\n                 map (\\<lambda>v. \\<A> v \\<beta>' ve) x13, ve,\n                 nb b x11))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran b \\<and> b \\<le> b'\n 3. \\<And>x21 x22 x23.\n       \\<lbrakk>c = call.Let x21 x22 x23; b \\<in> ran \\<beta>';\n        \\<forall>b'\\<in>ran \\<beta>'. b' \\<le> b;\n        \\<forall>b'\\<in>contours_in_ve ve. b' \\<le> b\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (evalC\\<cdot>\n                           (Discr\n                             (x23, \\<beta>'(x21 \\<mapsto> nb b x21),\n                              ve ++\n                              map_of\n                               (map (\\<lambda>(v, l).\n  ((v, nb b x21), \\<A> (L l) (\\<beta>'(x21 \\<mapsto> nb b x21)) ve))\n                                 x22),\n                              nb b x21)))\n 4. \\<And>x21 x22 x23 a b bb.\n       \\<lbrakk>c = call.Let x21 x22 x23; b \\<in> ran \\<beta>';\n        \\<forall>b'\\<in>ran \\<beta>'. b' \\<le> b;\n        \\<forall>b'\\<in>contours_in_ve ve. b' \\<le> b;\n        ((a, b), bb)\n        \\<in> evalC\\<cdot>\n              (Discr\n                (x23, \\<beta>'(x21 \\<mapsto> nb b x21),\n                 ve ++\n                 map_of\n                  (map (\\<lambda>(v, l).\n                           ((v, nb b x21),\n                            \\<A> (L l) (\\<beta>'(x21 \\<mapsto> nb b x21))\n                             ve))\n                    x22),\n                 nb b x21))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran b \\<and> b \\<le> b'", "txt \\<open>Case App\\<close>"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x11 x12 x13.\n       \\<lbrakk>c = App x11 x12 x13; b \\<in> ran \\<beta>';\n        \\<forall>b'\\<in>ran \\<beta>'. b' \\<le> b;\n        \\<forall>b'\\<in>contours_in_ve ve. b' \\<le> b;\n        isProc (\\<A> x12 \\<beta>' ve)\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (evalF\\<cdot>\n                           (Discr\n                             (\\<A> x12 \\<beta>' ve,\n                              map (\\<lambda>v. \\<A> v \\<beta>' ve) x13, ve,\n                              nb b x11)) \\<union>\n                           {((x11, \\<beta>'), \\<A> x12 \\<beta>' ve)})\n 2. \\<And>x11 x12 x13 a b baa.\n       \\<lbrakk>c = App x11 x12 x13; b \\<in> ran \\<beta>';\n        \\<forall>b'\\<in>ran \\<beta>'. b' \\<le> b;\n        \\<forall>b'\\<in>contours_in_ve ve. b' \\<le> b;\n        isProc (\\<A> x12 \\<beta>' ve);\n        ((a, b), baa)\n        \\<in> evalF\\<cdot>\n              (Discr\n                (\\<A> x12 \\<beta>' ve,\n                 map (\\<lambda>v. \\<A> v \\<beta>' ve) x13, ve,\n                 nb b x11))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran b \\<and> b \\<le> b'\n 3. \\<And>x21 x22 x23.\n       \\<lbrakk>c = call.Let x21 x22 x23; b \\<in> ran \\<beta>';\n        \\<forall>b'\\<in>ran \\<beta>'. b' \\<le> b;\n        \\<forall>b'\\<in>contours_in_ve ve. b' \\<le> b\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (evalC\\<cdot>\n                           (Discr\n                             (x23, \\<beta>'(x21 \\<mapsto> nb b x21),\n                              ve ++\n                              map_of\n                               (map (\\<lambda>(v, l).\n  ((v, nb b x21), \\<A> (L l) (\\<beta>'(x21 \\<mapsto> nb b x21)) ve))\n                                 x22),\n                              nb b x21)))\n 4. \\<And>x21 x22 x23 a b bb.\n       \\<lbrakk>c = call.Let x21 x22 x23; b \\<in> ran \\<beta>';\n        \\<forall>b'\\<in>ran \\<beta>'. b' \\<le> b;\n        \\<forall>b'\\<in>contours_in_ve ve. b' \\<le> b;\n        ((a, b), bb)\n        \\<in> evalC\\<cdot>\n              (Discr\n                (x23, \\<beta>'(x21 \\<mapsto> nb b x21),\n                 ve ++\n                 map_of\n                  (map (\\<lambda>(v, l).\n                           ((v, nb b x21),\n                            \\<A> (L l) (\\<beta>'(x21 \\<mapsto> nb b x21))\n                             ve))\n                    x22),\n                 nb b x21))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran b \\<and> b \\<le> b'", "fix lab' f vs"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x11 x12 x13.\n       \\<lbrakk>c = App x11 x12 x13; b \\<in> ran \\<beta>';\n        \\<forall>b'\\<in>ran \\<beta>'. b' \\<le> b;\n        \\<forall>b'\\<in>contours_in_ve ve. b' \\<le> b;\n        isProc (\\<A> x12 \\<beta>' ve)\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (evalF\\<cdot>\n                           (Discr\n                             (\\<A> x12 \\<beta>' ve,\n                              map (\\<lambda>v. \\<A> v \\<beta>' ve) x13, ve,\n                              nb b x11)) \\<union>\n                           {((x11, \\<beta>'), \\<A> x12 \\<beta>' ve)})\n 2. \\<And>x11 x12 x13 a b baa.\n       \\<lbrakk>c = App x11 x12 x13; b \\<in> ran \\<beta>';\n        \\<forall>b'\\<in>ran \\<beta>'. b' \\<le> b;\n        \\<forall>b'\\<in>contours_in_ve ve. b' \\<le> b;\n        isProc (\\<A> x12 \\<beta>' ve);\n        ((a, b), baa)\n        \\<in> evalF\\<cdot>\n              (Discr\n                (\\<A> x12 \\<beta>' ve,\n                 map (\\<lambda>v. \\<A> v \\<beta>' ve) x13, ve,\n                 nb b x11))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran b \\<and> b \\<le> b'\n 3. \\<And>x21 x22 x23.\n       \\<lbrakk>c = call.Let x21 x22 x23; b \\<in> ran \\<beta>';\n        \\<forall>b'\\<in>ran \\<beta>'. b' \\<le> b;\n        \\<forall>b'\\<in>contours_in_ve ve. b' \\<le> b\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (evalC\\<cdot>\n                           (Discr\n                             (x23, \\<beta>'(x21 \\<mapsto> nb b x21),\n                              ve ++\n                              map_of\n                               (map (\\<lambda>(v, l).\n  ((v, nb b x21), \\<A> (L l) (\\<beta>'(x21 \\<mapsto> nb b x21)) ve))\n                                 x22),\n                              nb b x21)))\n 4. \\<And>x21 x22 x23 a b bb.\n       \\<lbrakk>c = call.Let x21 x22 x23; b \\<in> ran \\<beta>';\n        \\<forall>b'\\<in>ran \\<beta>'. b' \\<le> b;\n        \\<forall>b'\\<in>contours_in_ve ve. b' \\<le> b;\n        ((a, b), bb)\n        \\<in> evalC\\<cdot>\n              (Discr\n                (x23, \\<beta>'(x21 \\<mapsto> nb b x21),\n                 ve ++\n                 map_of\n                  (map (\\<lambda>(v, l).\n                           ((v, nb b x21),\n                            \\<A> (L l) (\\<beta>'(x21 \\<mapsto> nb b x21))\n                             ve))\n                    x22),\n                 nb b x21))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran b \\<and> b \\<le> b'", "have prem2': \"\\<forall>b'\\<in>ran \\<beta>'. b' < nb b lab'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>b'\\<in>ran \\<beta>'. b' < nb b lab'", "using \"2.prems\"(2)"], ["proof (prove)\nusing this:\n  \\<forall>b'\\<in>ran \\<beta>'. b' \\<le> b\n\ngoal (1 subgoal):\n 1. \\<forall>b'\\<in>ran \\<beta>'. b' < nb b lab'", "by auto"], ["proof (state)\nthis:\n  \\<forall>b'\\<in>ran \\<beta>'. b' < nb b lab'\n\ngoal (4 subgoals):\n 1. \\<And>x11 x12 x13.\n       \\<lbrakk>c = App x11 x12 x13; b \\<in> ran \\<beta>';\n        \\<forall>b'\\<in>ran \\<beta>'. b' \\<le> b;\n        \\<forall>b'\\<in>contours_in_ve ve. b' \\<le> b;\n        isProc (\\<A> x12 \\<beta>' ve)\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (evalF\\<cdot>\n                           (Discr\n                             (\\<A> x12 \\<beta>' ve,\n                              map (\\<lambda>v. \\<A> v \\<beta>' ve) x13, ve,\n                              nb b x11)) \\<union>\n                           {((x11, \\<beta>'), \\<A> x12 \\<beta>' ve)})\n 2. \\<And>x11 x12 x13 a b baa.\n       \\<lbrakk>c = App x11 x12 x13; b \\<in> ran \\<beta>';\n        \\<forall>b'\\<in>ran \\<beta>'. b' \\<le> b;\n        \\<forall>b'\\<in>contours_in_ve ve. b' \\<le> b;\n        isProc (\\<A> x12 \\<beta>' ve);\n        ((a, b), baa)\n        \\<in> evalF\\<cdot>\n              (Discr\n                (\\<A> x12 \\<beta>' ve,\n                 map (\\<lambda>v. \\<A> v \\<beta>' ve) x13, ve,\n                 nb b x11))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran b \\<and> b \\<le> b'\n 3. \\<And>x21 x22 x23.\n       \\<lbrakk>c = call.Let x21 x22 x23; b \\<in> ran \\<beta>';\n        \\<forall>b'\\<in>ran \\<beta>'. b' \\<le> b;\n        \\<forall>b'\\<in>contours_in_ve ve. b' \\<le> b\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (evalC\\<cdot>\n                           (Discr\n                             (x23, \\<beta>'(x21 \\<mapsto> nb b x21),\n                              ve ++\n                              map_of\n                               (map (\\<lambda>(v, l).\n  ((v, nb b x21), \\<A> (L l) (\\<beta>'(x21 \\<mapsto> nb b x21)) ve))\n                                 x22),\n                              nb b x21)))\n 4. \\<And>x21 x22 x23 a b bb.\n       \\<lbrakk>c = call.Let x21 x22 x23; b \\<in> ran \\<beta>';\n        \\<forall>b'\\<in>ran \\<beta>'. b' \\<le> b;\n        \\<forall>b'\\<in>contours_in_ve ve. b' \\<le> b;\n        ((a, b), bb)\n        \\<in> evalC\\<cdot>\n              (Discr\n                (x23, \\<beta>'(x21 \\<mapsto> nb b x21),\n                 ve ++\n                 map_of\n                  (map (\\<lambda>(v, l).\n                           ((v, nb b x21),\n                            \\<A> (L l) (\\<beta>'(x21 \\<mapsto> nb b x21))\n                             ve))\n                    x22),\n                 nb b x21))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran b \\<and> b \\<le> b'", "have prem3': \"\\<forall>b'\\<in>contours_in_ve ve. b' < nb b lab'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>b'\\<in>contours_in_ve ve. b' < nb b lab'", "using \"2.prems\"(3)"], ["proof (prove)\nusing this:\n  \\<forall>b'\\<in>contours_in_ve ve. b' \\<le> b\n\ngoal (1 subgoal):\n 1. \\<forall>b'\\<in>contours_in_ve ve. b' < nb b lab'", "by auto"], ["proof (state)\nthis:\n  \\<forall>b'\\<in>contours_in_ve ve. b' < nb b lab'\n\ngoal (4 subgoals):\n 1. \\<And>x11 x12 x13.\n       \\<lbrakk>c = App x11 x12 x13; b \\<in> ran \\<beta>';\n        \\<forall>b'\\<in>ran \\<beta>'. b' \\<le> b;\n        \\<forall>b'\\<in>contours_in_ve ve. b' \\<le> b;\n        isProc (\\<A> x12 \\<beta>' ve)\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (evalF\\<cdot>\n                           (Discr\n                             (\\<A> x12 \\<beta>' ve,\n                              map (\\<lambda>v. \\<A> v \\<beta>' ve) x13, ve,\n                              nb b x11)) \\<union>\n                           {((x11, \\<beta>'), \\<A> x12 \\<beta>' ve)})\n 2. \\<And>x11 x12 x13 a b baa.\n       \\<lbrakk>c = App x11 x12 x13; b \\<in> ran \\<beta>';\n        \\<forall>b'\\<in>ran \\<beta>'. b' \\<le> b;\n        \\<forall>b'\\<in>contours_in_ve ve. b' \\<le> b;\n        isProc (\\<A> x12 \\<beta>' ve);\n        ((a, b), baa)\n        \\<in> evalF\\<cdot>\n              (Discr\n                (\\<A> x12 \\<beta>' ve,\n                 map (\\<lambda>v. \\<A> v \\<beta>' ve) x13, ve,\n                 nb b x11))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran b \\<and> b \\<le> b'\n 3. \\<And>x21 x22 x23.\n       \\<lbrakk>c = call.Let x21 x22 x23; b \\<in> ran \\<beta>';\n        \\<forall>b'\\<in>ran \\<beta>'. b' \\<le> b;\n        \\<forall>b'\\<in>contours_in_ve ve. b' \\<le> b\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (evalC\\<cdot>\n                           (Discr\n                             (x23, \\<beta>'(x21 \\<mapsto> nb b x21),\n                              ve ++\n                              map_of\n                               (map (\\<lambda>(v, l).\n  ((v, nb b x21), \\<A> (L l) (\\<beta>'(x21 \\<mapsto> nb b x21)) ve))\n                                 x22),\n                              nb b x21)))\n 4. \\<And>x21 x22 x23 a b bb.\n       \\<lbrakk>c = call.Let x21 x22 x23; b \\<in> ran \\<beta>';\n        \\<forall>b'\\<in>ran \\<beta>'. b' \\<le> b;\n        \\<forall>b'\\<in>contours_in_ve ve. b' \\<le> b;\n        ((a, b), bb)\n        \\<in> evalC\\<cdot>\n              (Discr\n                (x23, \\<beta>'(x21 \\<mapsto> nb b x21),\n                 ve ++\n                 map_of\n                  (map (\\<lambda>(v, l).\n                           ((v, nb b x21),\n                            \\<A> (L l) (\\<beta>'(x21 \\<mapsto> nb b x21))\n                             ve))\n                    x22),\n                 nb b x21))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran b \\<and> b \\<le> b'", "note c_in_e = contours_in_eval[OF prem3' prem2']"], ["proof (state)\nthis:\n  \\<forall>b'\\<in>contours_in_d (\\<A> ?f \\<beta>' ve). b' < nb b lab'\n\ngoal (4 subgoals):\n 1. \\<And>x11 x12 x13.\n       \\<lbrakk>c = App x11 x12 x13; b \\<in> ran \\<beta>';\n        \\<forall>b'\\<in>ran \\<beta>'. b' \\<le> b;\n        \\<forall>b'\\<in>contours_in_ve ve. b' \\<le> b;\n        isProc (\\<A> x12 \\<beta>' ve)\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (evalF\\<cdot>\n                           (Discr\n                             (\\<A> x12 \\<beta>' ve,\n                              map (\\<lambda>v. \\<A> v \\<beta>' ve) x13, ve,\n                              nb b x11)) \\<union>\n                           {((x11, \\<beta>'), \\<A> x12 \\<beta>' ve)})\n 2. \\<And>x11 x12 x13 a b baa.\n       \\<lbrakk>c = App x11 x12 x13; b \\<in> ran \\<beta>';\n        \\<forall>b'\\<in>ran \\<beta>'. b' \\<le> b;\n        \\<forall>b'\\<in>contours_in_ve ve. b' \\<le> b;\n        isProc (\\<A> x12 \\<beta>' ve);\n        ((a, b), baa)\n        \\<in> evalF\\<cdot>\n              (Discr\n                (\\<A> x12 \\<beta>' ve,\n                 map (\\<lambda>v. \\<A> v \\<beta>' ve) x13, ve,\n                 nb b x11))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran b \\<and> b \\<le> b'\n 3. \\<And>x21 x22 x23.\n       \\<lbrakk>c = call.Let x21 x22 x23; b \\<in> ran \\<beta>';\n        \\<forall>b'\\<in>ran \\<beta>'. b' \\<le> b;\n        \\<forall>b'\\<in>contours_in_ve ve. b' \\<le> b\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (evalC\\<cdot>\n                           (Discr\n                             (x23, \\<beta>'(x21 \\<mapsto> nb b x21),\n                              ve ++\n                              map_of\n                               (map (\\<lambda>(v, l).\n  ((v, nb b x21), \\<A> (L l) (\\<beta>'(x21 \\<mapsto> nb b x21)) ve))\n                                 x22),\n                              nb b x21)))\n 4. \\<And>x21 x22 x23 a b bb.\n       \\<lbrakk>c = call.Let x21 x22 x23; b \\<in> ran \\<beta>';\n        \\<forall>b'\\<in>ran \\<beta>'. b' \\<le> b;\n        \\<forall>b'\\<in>contours_in_ve ve. b' \\<le> b;\n        ((a, b), bb)\n        \\<in> evalC\\<cdot>\n              (Discr\n                (x23, \\<beta>'(x21 \\<mapsto> nb b x21),\n                 ve ++\n                 map_of\n                  (map (\\<lambda>(v, l).\n                           ((v, nb b x21),\n                            \\<A> (L l) (\\<beta>'(x21 \\<mapsto> nb b x21))\n                             ve))\n                    x22),\n                 nb b x21))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran b \\<and> b \\<le> b'", "have b_dom_d: \"\\<forall>b'\\<in>contours_in_d (evalV f \\<beta>' ve). b' < nb b lab'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>b'\\<in>contours_in_d (\\<A> f \\<beta>' ve). b' < nb b lab'", "by(rule c_in_e)"], ["proof (state)\nthis:\n  \\<forall>b'\\<in>contours_in_d (\\<A> f \\<beta>' ve). b' < nb b lab'\n\ngoal (4 subgoals):\n 1. \\<And>x11 x12 x13.\n       \\<lbrakk>c = App x11 x12 x13; b \\<in> ran \\<beta>';\n        \\<forall>b'\\<in>ran \\<beta>'. b' \\<le> b;\n        \\<forall>b'\\<in>contours_in_ve ve. b' \\<le> b;\n        isProc (\\<A> x12 \\<beta>' ve)\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (evalF\\<cdot>\n                           (Discr\n                             (\\<A> x12 \\<beta>' ve,\n                              map (\\<lambda>v. \\<A> v \\<beta>' ve) x13, ve,\n                              nb b x11)) \\<union>\n                           {((x11, \\<beta>'), \\<A> x12 \\<beta>' ve)})\n 2. \\<And>x11 x12 x13 a b baa.\n       \\<lbrakk>c = App x11 x12 x13; b \\<in> ran \\<beta>';\n        \\<forall>b'\\<in>ran \\<beta>'. b' \\<le> b;\n        \\<forall>b'\\<in>contours_in_ve ve. b' \\<le> b;\n        isProc (\\<A> x12 \\<beta>' ve);\n        ((a, b), baa)\n        \\<in> evalF\\<cdot>\n              (Discr\n                (\\<A> x12 \\<beta>' ve,\n                 map (\\<lambda>v. \\<A> v \\<beta>' ve) x13, ve,\n                 nb b x11))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran b \\<and> b \\<le> b'\n 3. \\<And>x21 x22 x23.\n       \\<lbrakk>c = call.Let x21 x22 x23; b \\<in> ran \\<beta>';\n        \\<forall>b'\\<in>ran \\<beta>'. b' \\<le> b;\n        \\<forall>b'\\<in>contours_in_ve ve. b' \\<le> b\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (evalC\\<cdot>\n                           (Discr\n                             (x23, \\<beta>'(x21 \\<mapsto> nb b x21),\n                              ve ++\n                              map_of\n                               (map (\\<lambda>(v, l).\n  ((v, nb b x21), \\<A> (L l) (\\<beta>'(x21 \\<mapsto> nb b x21)) ve))\n                                 x22),\n                              nb b x21)))\n 4. \\<And>x21 x22 x23 a b bb.\n       \\<lbrakk>c = call.Let x21 x22 x23; b \\<in> ran \\<beta>';\n        \\<forall>b'\\<in>ran \\<beta>'. b' \\<le> b;\n        \\<forall>b'\\<in>contours_in_ve ve. b' \\<le> b;\n        ((a, b), bb)\n        \\<in> evalC\\<cdot>\n              (Discr\n                (x23, \\<beta>'(x21 \\<mapsto> nb b x21),\n                 ve ++\n                 map_of\n                  (map (\\<lambda>(v, l).\n                           ((v, nb b x21),\n                            \\<A> (L l) (\\<beta>'(x21 \\<mapsto> nb b x21))\n                             ve))\n                    x22),\n                 nb b x21))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran b \\<and> b \\<le> b'", "have b_dom_ds: \"\\<forall>d' \\<in> set (map (\\<lambda>v. evalV v \\<beta>' ve) vs). \\<forall>b'\\<in>contours_in_d d'. b' < nb b lab'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>d'\\<in>set (map (\\<lambda>v. \\<A> v \\<beta>' ve) vs).\n       \\<forall>b'\\<in>contours_in_d d'. b' < nb b lab'", "using c_in_e"], ["proof (prove)\nusing this:\n  \\<forall>b'\\<in>contours_in_d (\\<A> ?f \\<beta>' ve). b' < nb b lab'\n\ngoal (1 subgoal):\n 1. \\<forall>d'\\<in>set (map (\\<lambda>v. \\<A> v \\<beta>' ve) vs).\n       \\<forall>b'\\<in>contours_in_d d'. b' < nb b lab'", "by auto"], ["proof (state)\nthis:\n  \\<forall>d'\\<in>set (map (\\<lambda>v. \\<A> v \\<beta>' ve) vs).\n     \\<forall>b'\\<in>contours_in_d d'. b' < nb b lab'\n\ngoal (4 subgoals):\n 1. \\<And>x11 x12 x13.\n       \\<lbrakk>c = App x11 x12 x13; b \\<in> ran \\<beta>';\n        \\<forall>b'\\<in>ran \\<beta>'. b' \\<le> b;\n        \\<forall>b'\\<in>contours_in_ve ve. b' \\<le> b;\n        isProc (\\<A> x12 \\<beta>' ve)\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (evalF\\<cdot>\n                           (Discr\n                             (\\<A> x12 \\<beta>' ve,\n                              map (\\<lambda>v. \\<A> v \\<beta>' ve) x13, ve,\n                              nb b x11)) \\<union>\n                           {((x11, \\<beta>'), \\<A> x12 \\<beta>' ve)})\n 2. \\<And>x11 x12 x13 a b baa.\n       \\<lbrakk>c = App x11 x12 x13; b \\<in> ran \\<beta>';\n        \\<forall>b'\\<in>ran \\<beta>'. b' \\<le> b;\n        \\<forall>b'\\<in>contours_in_ve ve. b' \\<le> b;\n        isProc (\\<A> x12 \\<beta>' ve);\n        ((a, b), baa)\n        \\<in> evalF\\<cdot>\n              (Discr\n                (\\<A> x12 \\<beta>' ve,\n                 map (\\<lambda>v. \\<A> v \\<beta>' ve) x13, ve,\n                 nb b x11))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran b \\<and> b \\<le> b'\n 3. \\<And>x21 x22 x23.\n       \\<lbrakk>c = call.Let x21 x22 x23; b \\<in> ran \\<beta>';\n        \\<forall>b'\\<in>ran \\<beta>'. b' \\<le> b;\n        \\<forall>b'\\<in>contours_in_ve ve. b' \\<le> b\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (evalC\\<cdot>\n                           (Discr\n                             (x23, \\<beta>'(x21 \\<mapsto> nb b x21),\n                              ve ++\n                              map_of\n                               (map (\\<lambda>(v, l).\n  ((v, nb b x21), \\<A> (L l) (\\<beta>'(x21 \\<mapsto> nb b x21)) ve))\n                                 x22),\n                              nb b x21)))\n 4. \\<And>x21 x22 x23 a b bb.\n       \\<lbrakk>c = call.Let x21 x22 x23; b \\<in> ran \\<beta>';\n        \\<forall>b'\\<in>ran \\<beta>'. b' \\<le> b;\n        \\<forall>b'\\<in>contours_in_ve ve. b' \\<le> b;\n        ((a, b), bb)\n        \\<in> evalC\\<cdot>\n              (Discr\n                (x23, \\<beta>'(x21 \\<mapsto> nb b x21),\n                 ve ++\n                 map_of\n                  (map (\\<lambda>(v, l).\n                           ((v, nb b x21),\n                            \\<A> (L l) (\\<beta>'(x21 \\<mapsto> nb b x21))\n                             ve))\n                    x22),\n                 nb b x21))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran b \\<and> b \\<le> b'", "have b_dom_ve: \"\\<forall>b' \\<in> contours_in_ve ve. b' < nb b lab'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>b'\\<in>contours_in_ve ve. b' < nb b lab'", "by (rule prem3')"], ["proof (state)\nthis:\n  \\<forall>b'\\<in>contours_in_ve ve. b' < nb b lab'\n\ngoal (4 subgoals):\n 1. \\<And>x11 x12 x13.\n       \\<lbrakk>c = App x11 x12 x13; b \\<in> ran \\<beta>';\n        \\<forall>b'\\<in>ran \\<beta>'. b' \\<le> b;\n        \\<forall>b'\\<in>contours_in_ve ve. b' \\<le> b;\n        isProc (\\<A> x12 \\<beta>' ve)\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (evalF\\<cdot>\n                           (Discr\n                             (\\<A> x12 \\<beta>' ve,\n                              map (\\<lambda>v. \\<A> v \\<beta>' ve) x13, ve,\n                              nb b x11)) \\<union>\n                           {((x11, \\<beta>'), \\<A> x12 \\<beta>' ve)})\n 2. \\<And>x11 x12 x13 a b baa.\n       \\<lbrakk>c = App x11 x12 x13; b \\<in> ran \\<beta>';\n        \\<forall>b'\\<in>ran \\<beta>'. b' \\<le> b;\n        \\<forall>b'\\<in>contours_in_ve ve. b' \\<le> b;\n        isProc (\\<A> x12 \\<beta>' ve);\n        ((a, b), baa)\n        \\<in> evalF\\<cdot>\n              (Discr\n                (\\<A> x12 \\<beta>' ve,\n                 map (\\<lambda>v. \\<A> v \\<beta>' ve) x13, ve,\n                 nb b x11))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran b \\<and> b \\<le> b'\n 3. \\<And>x21 x22 x23.\n       \\<lbrakk>c = call.Let x21 x22 x23; b \\<in> ran \\<beta>';\n        \\<forall>b'\\<in>ran \\<beta>'. b' \\<le> b;\n        \\<forall>b'\\<in>contours_in_ve ve. b' \\<le> b\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (evalC\\<cdot>\n                           (Discr\n                             (x23, \\<beta>'(x21 \\<mapsto> nb b x21),\n                              ve ++\n                              map_of\n                               (map (\\<lambda>(v, l).\n  ((v, nb b x21), \\<A> (L l) (\\<beta>'(x21 \\<mapsto> nb b x21)) ve))\n                                 x22),\n                              nb b x21)))\n 4. \\<And>x21 x22 x23 a b bb.\n       \\<lbrakk>c = call.Let x21 x22 x23; b \\<in> ran \\<beta>';\n        \\<forall>b'\\<in>ran \\<beta>'. b' \\<le> b;\n        \\<forall>b'\\<in>contours_in_ve ve. b' \\<le> b;\n        ((a, b), bb)\n        \\<in> evalC\\<cdot>\n              (Discr\n                (x23, \\<beta>'(x21 \\<mapsto> nb b x21),\n                 ve ++\n                 map_of\n                  (map (\\<lambda>(v, l).\n                           ((v, nb b x21),\n                            \\<A> (L l) (\\<beta>'(x21 \\<mapsto> nb b x21))\n                             ve))\n                    x22),\n                 nb b x21))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran b \\<and> b \\<le> b'", "have \"\\<forall>y. ((lab', \\<beta>'), y) \\<notin> evalF\\<cdot>(Discr (evalV f \\<beta>' ve, map (\\<lambda>v. evalV v \\<beta>' ve) vs, ve, nb b lab'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>y.\n       ((lab', \\<beta>'), y)\n       \\<notin> evalF\\<cdot>\n                (Discr\n                  (\\<A> f \\<beta>' ve,\n                   map (\\<lambda>v. \\<A> v \\<beta>' ve) vs, ve, nb b lab'))", "proof(rule allI, rule notI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       ((lab', \\<beta>'), y)\n       \\<in> evalF\\<cdot>\n             (Discr\n               (\\<A> f \\<beta>' ve, map (\\<lambda>v. \\<A> v \\<beta>' ve) vs,\n                ve, nb b lab')) \\<Longrightarrow>\n       False", "fix y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       ((lab', \\<beta>'), y)\n       \\<in> evalF\\<cdot>\n             (Discr\n               (\\<A> f \\<beta>' ve, map (\\<lambda>v. \\<A> v \\<beta>' ve) vs,\n                ve, nb b lab')) \\<Longrightarrow>\n       False", "assume \"((lab', \\<beta>'), y) \\<in> evalF\\<cdot>(Discr (evalV f \\<beta>' ve, map (\\<lambda>v. evalV v \\<beta>' ve) vs, ve, nb b lab'))\""], ["proof (state)\nthis:\n  ((lab', \\<beta>'), y)\n  \\<in> evalF\\<cdot>\n        (Discr\n          (\\<A> f \\<beta>' ve, map (\\<lambda>v. \\<A> v \\<beta>' ve) vs, ve,\n           nb b lab'))\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       ((lab', \\<beta>'), y)\n       \\<in> evalF\\<cdot>\n             (Discr\n               (\\<A> f \\<beta>' ve, map (\\<lambda>v. \\<A> v \\<beta>' ve) vs,\n                ve, nb b lab')) \\<Longrightarrow>\n       False", "hence \"\\<exists>b'. b' \\<in> ran \\<beta>' \\<and> nb b lab' \\<le> b'\""], ["proof (prove)\nusing this:\n  ((lab', \\<beta>'), y)\n  \\<in> evalF\\<cdot>\n        (Discr\n          (\\<A> f \\<beta>' ve, map (\\<lambda>v. \\<A> v \\<beta>' ve) vs, ve,\n           nb b lab'))\n\ngoal (1 subgoal):\n 1. \\<exists>b'. b' \\<in> ran \\<beta>' \\<and> nb b lab' \\<le> b'", "by (auto dest: hyps_F_b[OF b_dom_ve b_dom_d b_dom_ds])"], ["proof (state)\nthis:\n  \\<exists>b'. b' \\<in> ran \\<beta>' \\<and> nb b lab' \\<le> b'\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       ((lab', \\<beta>'), y)\n       \\<in> evalF\\<cdot>\n             (Discr\n               (\\<A> f \\<beta>' ve, map (\\<lambda>v. \\<A> v \\<beta>' ve) vs,\n                ve, nb b lab')) \\<Longrightarrow>\n       False", "thus False"], ["proof (prove)\nusing this:\n  \\<exists>b'. b' \\<in> ran \\<beta>' \\<and> nb b lab' \\<le> b'\n\ngoal (1 subgoal):\n 1. False", "using prem2'"], ["proof (prove)\nusing this:\n  \\<exists>b'. b' \\<in> ran \\<beta>' \\<and> nb b lab' \\<le> b'\n  \\<forall>b'\\<in>ran \\<beta>'. b' < nb b lab'\n\ngoal (1 subgoal):\n 1. False", "by (auto iff:less_le_not_le)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>y.\n     ((lab', \\<beta>'), y)\n     \\<notin> evalF\\<cdot>\n              (Discr\n                (\\<A> f \\<beta>' ve,\n                 map (\\<lambda>v. \\<A> v \\<beta>' ve) vs, ve, nb b lab'))\n\ngoal (4 subgoals):\n 1. \\<And>x11 x12 x13.\n       \\<lbrakk>c = App x11 x12 x13; b \\<in> ran \\<beta>';\n        \\<forall>b'\\<in>ran \\<beta>'. b' \\<le> b;\n        \\<forall>b'\\<in>contours_in_ve ve. b' \\<le> b;\n        isProc (\\<A> x12 \\<beta>' ve)\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (evalF\\<cdot>\n                           (Discr\n                             (\\<A> x12 \\<beta>' ve,\n                              map (\\<lambda>v. \\<A> v \\<beta>' ve) x13, ve,\n                              nb b x11)) \\<union>\n                           {((x11, \\<beta>'), \\<A> x12 \\<beta>' ve)})\n 2. \\<And>x11 x12 x13 a b baa.\n       \\<lbrakk>c = App x11 x12 x13; b \\<in> ran \\<beta>';\n        \\<forall>b'\\<in>ran \\<beta>'. b' \\<le> b;\n        \\<forall>b'\\<in>contours_in_ve ve. b' \\<le> b;\n        isProc (\\<A> x12 \\<beta>' ve);\n        ((a, b), baa)\n        \\<in> evalF\\<cdot>\n              (Discr\n                (\\<A> x12 \\<beta>' ve,\n                 map (\\<lambda>v. \\<A> v \\<beta>' ve) x13, ve,\n                 nb b x11))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran b \\<and> b \\<le> b'\n 3. \\<And>x21 x22 x23.\n       \\<lbrakk>c = call.Let x21 x22 x23; b \\<in> ran \\<beta>';\n        \\<forall>b'\\<in>ran \\<beta>'. b' \\<le> b;\n        \\<forall>b'\\<in>contours_in_ve ve. b' \\<le> b\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (evalC\\<cdot>\n                           (Discr\n                             (x23, \\<beta>'(x21 \\<mapsto> nb b x21),\n                              ve ++\n                              map_of\n                               (map (\\<lambda>(v, l).\n  ((v, nb b x21), \\<A> (L l) (\\<beta>'(x21 \\<mapsto> nb b x21)) ve))\n                                 x22),\n                              nb b x21)))\n 4. \\<And>x21 x22 x23 a b bb.\n       \\<lbrakk>c = call.Let x21 x22 x23; b \\<in> ran \\<beta>';\n        \\<forall>b'\\<in>ran \\<beta>'. b' \\<le> b;\n        \\<forall>b'\\<in>contours_in_ve ve. b' \\<le> b;\n        ((a, b), bb)\n        \\<in> evalC\\<cdot>\n              (Discr\n                (x23, \\<beta>'(x21 \\<mapsto> nb b x21),\n                 ve ++\n                 map_of\n                  (map (\\<lambda>(v, l).\n                           ((v, nb b x21),\n                            \\<A> (L l) (\\<beta>'(x21 \\<mapsto> nb b x21))\n                             ve))\n                    x22),\n                 nb b x21))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran b \\<and> b \\<le> b'", "with hyps_F_sv[OF b_dom_ve b_dom_d b_dom_ds]"], ["proof (chain)\npicking this:\n  single_valued\n   (evalF\\<cdot>\n    (Discr\n      (\\<A> f \\<beta>' ve, map (\\<lambda>v. \\<A> v \\<beta>' ve) vs, ve,\n       nb b lab')))\n  \\<forall>y.\n     ((lab', \\<beta>'), y)\n     \\<notin> evalF\\<cdot>\n              (Discr\n                (\\<A> f \\<beta>' ve,\n                 map (\\<lambda>v. \\<A> v \\<beta>' ve) vs, ve, nb b lab'))", "show \"single_valued (evalF\\<cdot>(Discr (evalV f \\<beta>' ve, map (\\<lambda>v. evalV v \\<beta>' ve) vs, ve, nb b lab'))\n                       \\<union> {((lab', \\<beta>'), evalV f \\<beta>' ve)})\""], ["proof (prove)\nusing this:\n  single_valued\n   (evalF\\<cdot>\n    (Discr\n      (\\<A> f \\<beta>' ve, map (\\<lambda>v. \\<A> v \\<beta>' ve) vs, ve,\n       nb b lab')))\n  \\<forall>y.\n     ((lab', \\<beta>'), y)\n     \\<notin> evalF\\<cdot>\n              (Discr\n                (\\<A> f \\<beta>' ve,\n                 map (\\<lambda>v. \\<A> v \\<beta>' ve) vs, ve, nb b lab'))\n\ngoal (1 subgoal):\n 1. single_valued\n     (evalF\\<cdot>\n      (Discr\n        (\\<A> f \\<beta>' ve, map (\\<lambda>v. \\<A> v \\<beta>' ve) vs, ve,\n         nb b lab')) \\<union>\n      {((lab', \\<beta>'), \\<A> f \\<beta>' ve)})", "by(auto intro:single_valued_insert)"], ["proof (state)\nthis:\n  single_valued\n   (evalF\\<cdot>\n    (Discr\n      (\\<A> f \\<beta>' ve, map (\\<lambda>v. \\<A> v \\<beta>' ve) vs, ve,\n       nb b lab')) \\<union>\n    {((lab', \\<beta>'), \\<A> f \\<beta>' ve)})\n\ngoal (3 subgoals):\n 1. \\<And>x11 x12 x13 a b baa.\n       \\<lbrakk>c = App x11 x12 x13; b \\<in> ran \\<beta>';\n        \\<forall>b'\\<in>ran \\<beta>'. b' \\<le> b;\n        \\<forall>b'\\<in>contours_in_ve ve. b' \\<le> b;\n        isProc (\\<A> x12 \\<beta>' ve);\n        ((a, b), baa)\n        \\<in> evalF\\<cdot>\n              (Discr\n                (\\<A> x12 \\<beta>' ve,\n                 map (\\<lambda>v. \\<A> v \\<beta>' ve) x13, ve,\n                 nb b x11))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran b \\<and> b \\<le> b'\n 2. \\<And>x21 x22 x23.\n       \\<lbrakk>c = call.Let x21 x22 x23; b \\<in> ran \\<beta>';\n        \\<forall>b'\\<in>ran \\<beta>'. b' \\<le> b;\n        \\<forall>b'\\<in>contours_in_ve ve. b' \\<le> b\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (evalC\\<cdot>\n                           (Discr\n                             (x23, \\<beta>'(x21 \\<mapsto> nb b x21),\n                              ve ++\n                              map_of\n                               (map (\\<lambda>(v, l).\n  ((v, nb b x21), \\<A> (L l) (\\<beta>'(x21 \\<mapsto> nb b x21)) ve))\n                                 x22),\n                              nb b x21)))\n 3. \\<And>x21 x22 x23 a b bb.\n       \\<lbrakk>c = call.Let x21 x22 x23; b \\<in> ran \\<beta>';\n        \\<forall>b'\\<in>ran \\<beta>'. b' \\<le> b;\n        \\<forall>b'\\<in>contours_in_ve ve. b' \\<le> b;\n        ((a, b), bb)\n        \\<in> evalC\\<cdot>\n              (Discr\n                (x23, \\<beta>'(x21 \\<mapsto> nb b x21),\n                 ve ++\n                 map_of\n                  (map (\\<lambda>(v, l).\n                           ((v, nb b x21),\n                            \\<A> (L l) (\\<beta>'(x21 \\<mapsto> nb b x21))\n                             ve))\n                    x22),\n                 nb b x21))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran b \\<and> b \\<le> b'", "fix lab \\<beta> t"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x11 x12 x13 a b baa.\n       \\<lbrakk>c = App x11 x12 x13; b \\<in> ran \\<beta>';\n        \\<forall>b'\\<in>ran \\<beta>'. b' \\<le> b;\n        \\<forall>b'\\<in>contours_in_ve ve. b' \\<le> b;\n        isProc (\\<A> x12 \\<beta>' ve);\n        ((a, b), baa)\n        \\<in> evalF\\<cdot>\n              (Discr\n                (\\<A> x12 \\<beta>' ve,\n                 map (\\<lambda>v. \\<A> v \\<beta>' ve) x13, ve,\n                 nb b x11))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran b \\<and> b \\<le> b'\n 2. \\<And>x21 x22 x23.\n       \\<lbrakk>c = call.Let x21 x22 x23; b \\<in> ran \\<beta>';\n        \\<forall>b'\\<in>ran \\<beta>'. b' \\<le> b;\n        \\<forall>b'\\<in>contours_in_ve ve. b' \\<le> b\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (evalC\\<cdot>\n                           (Discr\n                             (x23, \\<beta>'(x21 \\<mapsto> nb b x21),\n                              ve ++\n                              map_of\n                               (map (\\<lambda>(v, l).\n  ((v, nb b x21), \\<A> (L l) (\\<beta>'(x21 \\<mapsto> nb b x21)) ve))\n                                 x22),\n                              nb b x21)))\n 3. \\<And>x21 x22 x23 a b bb.\n       \\<lbrakk>c = call.Let x21 x22 x23; b \\<in> ran \\<beta>';\n        \\<forall>b'\\<in>ran \\<beta>'. b' \\<le> b;\n        \\<forall>b'\\<in>contours_in_ve ve. b' \\<le> b;\n        ((a, b), bb)\n        \\<in> evalC\\<cdot>\n              (Discr\n                (x23, \\<beta>'(x21 \\<mapsto> nb b x21),\n                 ve ++\n                 map_of\n                  (map (\\<lambda>(v, l).\n                           ((v, nb b x21),\n                            \\<A> (L l) (\\<beta>'(x21 \\<mapsto> nb b x21))\n                             ve))\n                    x22),\n                 nb b x21))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran b \\<and> b \\<le> b'", "assume \"((lab, \\<beta>), t) \\<in> (evalF\\<cdot>(Discr (evalV f \\<beta>' ve, map (\\<lambda>v. evalV v \\<beta>' ve) vs, ve, nb b lab')))\""], ["proof (state)\nthis:\n  ((lab, \\<beta>), t)\n  \\<in> evalF\\<cdot>\n        (Discr\n          (\\<A> f \\<beta>' ve, map (\\<lambda>v. \\<A> v \\<beta>' ve) vs, ve,\n           nb b lab'))\n\ngoal (3 subgoals):\n 1. \\<And>x11 x12 x13 a b baa.\n       \\<lbrakk>c = App x11 x12 x13; b \\<in> ran \\<beta>';\n        \\<forall>b'\\<in>ran \\<beta>'. b' \\<le> b;\n        \\<forall>b'\\<in>contours_in_ve ve. b' \\<le> b;\n        isProc (\\<A> x12 \\<beta>' ve);\n        ((a, b), baa)\n        \\<in> evalF\\<cdot>\n              (Discr\n                (\\<A> x12 \\<beta>' ve,\n                 map (\\<lambda>v. \\<A> v \\<beta>' ve) x13, ve,\n                 nb b x11))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran b \\<and> b \\<le> b'\n 2. \\<And>x21 x22 x23.\n       \\<lbrakk>c = call.Let x21 x22 x23; b \\<in> ran \\<beta>';\n        \\<forall>b'\\<in>ran \\<beta>'. b' \\<le> b;\n        \\<forall>b'\\<in>contours_in_ve ve. b' \\<le> b\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (evalC\\<cdot>\n                           (Discr\n                             (x23, \\<beta>'(x21 \\<mapsto> nb b x21),\n                              ve ++\n                              map_of\n                               (map (\\<lambda>(v, l).\n  ((v, nb b x21), \\<A> (L l) (\\<beta>'(x21 \\<mapsto> nb b x21)) ve))\n                                 x22),\n                              nb b x21)))\n 3. \\<And>x21 x22 x23 a b bb.\n       \\<lbrakk>c = call.Let x21 x22 x23; b \\<in> ran \\<beta>';\n        \\<forall>b'\\<in>ran \\<beta>'. b' \\<le> b;\n        \\<forall>b'\\<in>contours_in_ve ve. b' \\<le> b;\n        ((a, b), bb)\n        \\<in> evalC\\<cdot>\n              (Discr\n                (x23, \\<beta>'(x21 \\<mapsto> nb b x21),\n                 ve ++\n                 map_of\n                  (map (\\<lambda>(v, l).\n                           ((v, nb b x21),\n                            \\<A> (L l) (\\<beta>'(x21 \\<mapsto> nb b x21))\n                             ve))\n                    x22),\n                 nb b x21))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran b \\<and> b \\<le> b'", "thus \"\\<exists>b'. b' \\<in> ran \\<beta> \\<and> b \\<le> b'\""], ["proof (prove)\nusing this:\n  ((lab, \\<beta>), t)\n  \\<in> evalF\\<cdot>\n        (Discr\n          (\\<A> f \\<beta>' ve, map (\\<lambda>v. \\<A> v \\<beta>' ve) vs, ve,\n           nb b lab'))\n\ngoal (1 subgoal):\n 1. \\<exists>b'. b' \\<in> ran \\<beta> \\<and> b \\<le> b'", "by (auto dest: hyps_F_b[OF b_dom_ve b_dom_d b_dom_ds])"], ["proof (state)\nthis:\n  \\<exists>b'. b' \\<in> ran \\<beta> \\<and> b \\<le> b'\n\ngoal (2 subgoals):\n 1. \\<And>x21 x22 x23.\n       \\<lbrakk>c = call.Let x21 x22 x23; b \\<in> ran \\<beta>';\n        \\<forall>b'\\<in>ran \\<beta>'. b' \\<le> b;\n        \\<forall>b'\\<in>contours_in_ve ve. b' \\<le> b\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (evalC\\<cdot>\n                           (Discr\n                             (x23, \\<beta>'(x21 \\<mapsto> nb b x21),\n                              ve ++\n                              map_of\n                               (map (\\<lambda>(v, l).\n  ((v, nb b x21), \\<A> (L l) (\\<beta>'(x21 \\<mapsto> nb b x21)) ve))\n                                 x22),\n                              nb b x21)))\n 2. \\<And>x21 x22 x23 a b bb.\n       \\<lbrakk>c = call.Let x21 x22 x23; b \\<in> ran \\<beta>';\n        \\<forall>b'\\<in>ran \\<beta>'. b' \\<le> b;\n        \\<forall>b'\\<in>contours_in_ve ve. b' \\<le> b;\n        ((a, b), bb)\n        \\<in> evalC\\<cdot>\n              (Discr\n                (x23, \\<beta>'(x21 \\<mapsto> nb b x21),\n                 ve ++\n                 map_of\n                  (map (\\<lambda>(v, l).\n                           ((v, nb b x21),\n                            \\<A> (L l) (\\<beta>'(x21 \\<mapsto> nb b x21))\n                             ve))\n                    x22),\n                 nb b x21))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran b \\<and> b \\<le> b'", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x21 x22 x23.\n       \\<lbrakk>c = call.Let x21 x22 x23; b \\<in> ran \\<beta>';\n        \\<forall>b'\\<in>ran \\<beta>'. b' \\<le> b;\n        \\<forall>b'\\<in>contours_in_ve ve. b' \\<le> b\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (evalC\\<cdot>\n                           (Discr\n                             (x23, \\<beta>'(x21 \\<mapsto> nb b x21),\n                              ve ++\n                              map_of\n                               (map (\\<lambda>(v, l).\n  ((v, nb b x21), \\<A> (L l) (\\<beta>'(x21 \\<mapsto> nb b x21)) ve))\n                                 x22),\n                              nb b x21)))\n 2. \\<And>x21 x22 x23 a b bb.\n       \\<lbrakk>c = call.Let x21 x22 x23; b \\<in> ran \\<beta>';\n        \\<forall>b'\\<in>ran \\<beta>'. b' \\<le> b;\n        \\<forall>b'\\<in>contours_in_ve ve. b' \\<le> b;\n        ((a, b), bb)\n        \\<in> evalC\\<cdot>\n              (Discr\n                (x23, \\<beta>'(x21 \\<mapsto> nb b x21),\n                 ve ++\n                 map_of\n                  (map (\\<lambda>(v, l).\n                           ((v, nb b x21),\n                            \\<A> (L l) (\\<beta>'(x21 \\<mapsto> nb b x21))\n                             ve))\n                    x22),\n                 nb b x21))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran b \\<and> b \\<le> b'", "txt \\<open>Case Let\\<close>"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x21 x22 x23.\n       \\<lbrakk>c = call.Let x21 x22 x23; b \\<in> ran \\<beta>';\n        \\<forall>b'\\<in>ran \\<beta>'. b' \\<le> b;\n        \\<forall>b'\\<in>contours_in_ve ve. b' \\<le> b\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (evalC\\<cdot>\n                           (Discr\n                             (x23, \\<beta>'(x21 \\<mapsto> nb b x21),\n                              ve ++\n                              map_of\n                               (map (\\<lambda>(v, l).\n  ((v, nb b x21), \\<A> (L l) (\\<beta>'(x21 \\<mapsto> nb b x21)) ve))\n                                 x22),\n                              nb b x21)))\n 2. \\<And>x21 x22 x23 a b bb.\n       \\<lbrakk>c = call.Let x21 x22 x23; b \\<in> ran \\<beta>';\n        \\<forall>b'\\<in>ran \\<beta>'. b' \\<le> b;\n        \\<forall>b'\\<in>contours_in_ve ve. b' \\<le> b;\n        ((a, b), bb)\n        \\<in> evalC\\<cdot>\n              (Discr\n                (x23, \\<beta>'(x21 \\<mapsto> nb b x21),\n                 ve ++\n                 map_of\n                  (map (\\<lambda>(v, l).\n                           ((v, nb b x21),\n                            \\<A> (L l) (\\<beta>'(x21 \\<mapsto> nb b x21))\n                             ve))\n                    x22),\n                 nb b x21))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran b \\<and> b \\<le> b'", "fix lab' ls c'"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x21 x22 x23.\n       \\<lbrakk>c = call.Let x21 x22 x23; b \\<in> ran \\<beta>';\n        \\<forall>b'\\<in>ran \\<beta>'. b' \\<le> b;\n        \\<forall>b'\\<in>contours_in_ve ve. b' \\<le> b\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (evalC\\<cdot>\n                           (Discr\n                             (x23, \\<beta>'(x21 \\<mapsto> nb b x21),\n                              ve ++\n                              map_of\n                               (map (\\<lambda>(v, l).\n  ((v, nb b x21), \\<A> (L l) (\\<beta>'(x21 \\<mapsto> nb b x21)) ve))\n                                 x22),\n                              nb b x21)))\n 2. \\<And>x21 x22 x23 a b bb.\n       \\<lbrakk>c = call.Let x21 x22 x23; b \\<in> ran \\<beta>';\n        \\<forall>b'\\<in>ran \\<beta>'. b' \\<le> b;\n        \\<forall>b'\\<in>contours_in_ve ve. b' \\<le> b;\n        ((a, b), bb)\n        \\<in> evalC\\<cdot>\n              (Discr\n                (x23, \\<beta>'(x21 \\<mapsto> nb b x21),\n                 ve ++\n                 map_of\n                  (map (\\<lambda>(v, l).\n                           ((v, nb b x21),\n                            \\<A> (L l) (\\<beta>'(x21 \\<mapsto> nb b x21))\n                             ve))\n                    x22),\n                 nb b x21))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran b \\<and> b \\<le> b'", "have prem2': \"\\<forall>b'\\<in>ran (\\<beta>'(lab' \\<mapsto> nb b lab')). b' \\<le> nb b lab'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>b'\\<in>ran (\\<beta>'(lab' \\<mapsto> nb b lab')).\n       b' \\<le> nb b lab'", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>b'.\n       b' \\<in> ran (\\<beta>'(lab' \\<mapsto> nb b lab')) \\<Longrightarrow>\n       b' \\<le> nb b lab'", "fix b'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>b'.\n       b' \\<in> ran (\\<beta>'(lab' \\<mapsto> nb b lab')) \\<Longrightarrow>\n       b' \\<le> nb b lab'", "assume \"b'\\<in>ran (\\<beta>'(lab' \\<mapsto> nb b lab'))\""], ["proof (state)\nthis:\n  b' \\<in> ran (\\<beta>'(lab' \\<mapsto> nb b lab'))\n\ngoal (1 subgoal):\n 1. \\<And>b'.\n       b' \\<in> ran (\\<beta>'(lab' \\<mapsto> nb b lab')) \\<Longrightarrow>\n       b' \\<le> nb b lab'", "hence \"b' \\<in> ran \\<beta>' \\<or> b' = nb b lab'\""], ["proof (prove)\nusing this:\n  b' \\<in> ran (\\<beta>'(lab' \\<mapsto> nb b lab'))\n\ngoal (1 subgoal):\n 1. b' \\<in> ran \\<beta>' \\<or> b' = nb b lab'", "by (auto dest:ran_upd[THEN subsetD])"], ["proof (state)\nthis:\n  b' \\<in> ran \\<beta>' \\<or> b' = nb b lab'\n\ngoal (1 subgoal):\n 1. \\<And>b'.\n       b' \\<in> ran (\\<beta>'(lab' \\<mapsto> nb b lab')) \\<Longrightarrow>\n       b' \\<le> nb b lab'", "thus \"b' \\<le> nb b lab'\""], ["proof (prove)\nusing this:\n  b' \\<in> ran \\<beta>' \\<or> b' = nb b lab'\n\ngoal (1 subgoal):\n 1. b' \\<le> nb b lab'", "using \"2.prems\"(2)"], ["proof (prove)\nusing this:\n  b' \\<in> ran \\<beta>' \\<or> b' = nb b lab'\n  \\<forall>b'\\<in>ran \\<beta>'. b' \\<le> b\n\ngoal (1 subgoal):\n 1. b' \\<le> nb b lab'", "by auto"], ["proof (state)\nthis:\n  b' \\<le> nb b lab'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>b'\\<in>ran (\\<beta>'(lab' \\<mapsto> nb b lab')).\n     b' \\<le> nb b lab'\n\ngoal (2 subgoals):\n 1. \\<And>x21 x22 x23.\n       \\<lbrakk>c = call.Let x21 x22 x23; b \\<in> ran \\<beta>';\n        \\<forall>b'\\<in>ran \\<beta>'. b' \\<le> b;\n        \\<forall>b'\\<in>contours_in_ve ve. b' \\<le> b\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (evalC\\<cdot>\n                           (Discr\n                             (x23, \\<beta>'(x21 \\<mapsto> nb b x21),\n                              ve ++\n                              map_of\n                               (map (\\<lambda>(v, l).\n  ((v, nb b x21), \\<A> (L l) (\\<beta>'(x21 \\<mapsto> nb b x21)) ve))\n                                 x22),\n                              nb b x21)))\n 2. \\<And>x21 x22 x23 a b bb.\n       \\<lbrakk>c = call.Let x21 x22 x23; b \\<in> ran \\<beta>';\n        \\<forall>b'\\<in>ran \\<beta>'. b' \\<le> b;\n        \\<forall>b'\\<in>contours_in_ve ve. b' \\<le> b;\n        ((a, b), bb)\n        \\<in> evalC\\<cdot>\n              (Discr\n                (x23, \\<beta>'(x21 \\<mapsto> nb b x21),\n                 ve ++\n                 map_of\n                  (map (\\<lambda>(v, l).\n                           ((v, nb b x21),\n                            \\<A> (L l) (\\<beta>'(x21 \\<mapsto> nb b x21))\n                             ve))\n                    x22),\n                 nb b x21))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran b \\<and> b \\<le> b'", "have prem3': \"\\<forall>b'\\<in>contours_in_ve ve. b' \\<le> nb b lab'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>b'\\<in>contours_in_ve ve. b' \\<le> nb b lab'", "using \"2.prems\"(3)"], ["proof (prove)\nusing this:\n  \\<forall>b'\\<in>contours_in_ve ve. b' \\<le> b\n\ngoal (1 subgoal):\n 1. \\<forall>b'\\<in>contours_in_ve ve. b' \\<le> nb b lab'", "by auto"], ["proof (state)\nthis:\n  \\<forall>b'\\<in>contours_in_ve ve. b' \\<le> nb b lab'\n\ngoal (2 subgoals):\n 1. \\<And>x21 x22 x23.\n       \\<lbrakk>c = call.Let x21 x22 x23; b \\<in> ran \\<beta>';\n        \\<forall>b'\\<in>ran \\<beta>'. b' \\<le> b;\n        \\<forall>b'\\<in>contours_in_ve ve. b' \\<le> b\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (evalC\\<cdot>\n                           (Discr\n                             (x23, \\<beta>'(x21 \\<mapsto> nb b x21),\n                              ve ++\n                              map_of\n                               (map (\\<lambda>(v, l).\n  ((v, nb b x21), \\<A> (L l) (\\<beta>'(x21 \\<mapsto> nb b x21)) ve))\n                                 x22),\n                              nb b x21)))\n 2. \\<And>x21 x22 x23 a b bb.\n       \\<lbrakk>c = call.Let x21 x22 x23; b \\<in> ran \\<beta>';\n        \\<forall>b'\\<in>ran \\<beta>'. b' \\<le> b;\n        \\<forall>b'\\<in>contours_in_ve ve. b' \\<le> b;\n        ((a, b), bb)\n        \\<in> evalC\\<cdot>\n              (Discr\n                (x23, \\<beta>'(x21 \\<mapsto> nb b x21),\n                 ve ++\n                 map_of\n                  (map (\\<lambda>(v, l).\n                           ((v, nb b x21),\n                            \\<A> (L l) (\\<beta>'(x21 \\<mapsto> nb b x21))\n                             ve))\n                    x22),\n                 nb b x21))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran b \\<and> b \\<le> b'", "note c_in_e = contours_in_eval[OF prem3' prem2']"], ["proof (state)\nthis:\n  \\<forall>b'\\<in>contours_in_d\n                   (\\<A> ?f (\\<beta>'(lab' \\<mapsto> nb b lab')) ve).\n     b' \\<le> nb b lab'\n\ngoal (2 subgoals):\n 1. \\<And>x21 x22 x23.\n       \\<lbrakk>c = call.Let x21 x22 x23; b \\<in> ran \\<beta>';\n        \\<forall>b'\\<in>ran \\<beta>'. b' \\<le> b;\n        \\<forall>b'\\<in>contours_in_ve ve. b' \\<le> b\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (evalC\\<cdot>\n                           (Discr\n                             (x23, \\<beta>'(x21 \\<mapsto> nb b x21),\n                              ve ++\n                              map_of\n                               (map (\\<lambda>(v, l).\n  ((v, nb b x21), \\<A> (L l) (\\<beta>'(x21 \\<mapsto> nb b x21)) ve))\n                                 x22),\n                              nb b x21)))\n 2. \\<And>x21 x22 x23 a b bb.\n       \\<lbrakk>c = call.Let x21 x22 x23; b \\<in> ran \\<beta>';\n        \\<forall>b'\\<in>ran \\<beta>'. b' \\<le> b;\n        \\<forall>b'\\<in>contours_in_ve ve. b' \\<le> b;\n        ((a, b), bb)\n        \\<in> evalC\\<cdot>\n              (Discr\n                (x23, \\<beta>'(x21 \\<mapsto> nb b x21),\n                 ve ++\n                 map_of\n                  (map (\\<lambda>(v, l).\n                           ((v, nb b x21),\n                            \\<A> (L l) (\\<beta>'(x21 \\<mapsto> nb b x21))\n                             ve))\n                    x22),\n                 nb b x21))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran b \\<and> b \\<le> b'", "note c_in_ve' = contours_in_ve_upds_binds[OF prem3' prem2']"], ["proof (state)\nthis:\n  \\<forall>b'\\<in>contours_in_ve\n                   (ve ++\n                    map_of\n                     (map (\\<lambda>(v, l).\n                              ((v, ?b''),\n                               \\<A> (L l)\n                                (\\<beta>'(lab' \\<mapsto> nb b lab')) ve))\n                       ?ls)).\n     b' \\<le> nb b lab'\n\ngoal (2 subgoals):\n 1. \\<And>x21 x22 x23.\n       \\<lbrakk>c = call.Let x21 x22 x23; b \\<in> ran \\<beta>';\n        \\<forall>b'\\<in>ran \\<beta>'. b' \\<le> b;\n        \\<forall>b'\\<in>contours_in_ve ve. b' \\<le> b\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (evalC\\<cdot>\n                           (Discr\n                             (x23, \\<beta>'(x21 \\<mapsto> nb b x21),\n                              ve ++\n                              map_of\n                               (map (\\<lambda>(v, l).\n  ((v, nb b x21), \\<A> (L l) (\\<beta>'(x21 \\<mapsto> nb b x21)) ve))\n                                 x22),\n                              nb b x21)))\n 2. \\<And>x21 x22 x23 a b bb.\n       \\<lbrakk>c = call.Let x21 x22 x23; b \\<in> ran \\<beta>';\n        \\<forall>b'\\<in>ran \\<beta>'. b' \\<le> b;\n        \\<forall>b'\\<in>contours_in_ve ve. b' \\<le> b;\n        ((a, b), bb)\n        \\<in> evalC\\<cdot>\n              (Discr\n                (x23, \\<beta>'(x21 \\<mapsto> nb b x21),\n                 ve ++\n                 map_of\n                  (map (\\<lambda>(v, l).\n                           ((v, nb b x21),\n                            \\<A> (L l) (\\<beta>'(x21 \\<mapsto> nb b x21))\n                             ve))\n                    x22),\n                 nb b x21))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran b \\<and> b \\<le> b'", "have b_dom_ve: \"\\<forall>b' \\<in> contours_in_ve (ve ++ map_of (map (\\<lambda>(v,l). ((v,nb b lab'), evalV (L l) ((\\<beta>'(lab' \\<mapsto> nb b lab'))) ve)) ls)). b' \\<le> nb b lab'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>b'\\<in>contours_in_ve\n                     (ve ++\n                      map_of\n                       (map (\\<lambda>(v, l).\n                                ((v, nb b lab'),\n                                 \\<A> (L l)\n                                  (\\<beta>'(lab' \\<mapsto> nb b lab')) ve))\n                         ls)).\n       b' \\<le> nb b lab'", "by (rule c_in_ve')"], ["proof (state)\nthis:\n  \\<forall>b'\\<in>contours_in_ve\n                   (ve ++\n                    map_of\n                     (map (\\<lambda>(v, l).\n                              ((v, nb b lab'),\n                               \\<A> (L l)\n                                (\\<beta>'(lab' \\<mapsto> nb b lab')) ve))\n                       ls)).\n     b' \\<le> nb b lab'\n\ngoal (2 subgoals):\n 1. \\<And>x21 x22 x23.\n       \\<lbrakk>c = call.Let x21 x22 x23; b \\<in> ran \\<beta>';\n        \\<forall>b'\\<in>ran \\<beta>'. b' \\<le> b;\n        \\<forall>b'\\<in>contours_in_ve ve. b' \\<le> b\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (evalC\\<cdot>\n                           (Discr\n                             (x23, \\<beta>'(x21 \\<mapsto> nb b x21),\n                              ve ++\n                              map_of\n                               (map (\\<lambda>(v, l).\n  ((v, nb b x21), \\<A> (L l) (\\<beta>'(x21 \\<mapsto> nb b x21)) ve))\n                                 x22),\n                              nb b x21)))\n 2. \\<And>x21 x22 x23 a b bb.\n       \\<lbrakk>c = call.Let x21 x22 x23; b \\<in> ran \\<beta>';\n        \\<forall>b'\\<in>ran \\<beta>'. b' \\<le> b;\n        \\<forall>b'\\<in>contours_in_ve ve. b' \\<le> b;\n        ((a, b), bb)\n        \\<in> evalC\\<cdot>\n              (Discr\n                (x23, \\<beta>'(x21 \\<mapsto> nb b x21),\n                 ve ++\n                 map_of\n                  (map (\\<lambda>(v, l).\n                           ((v, nb b x21),\n                            \\<A> (L l) (\\<beta>'(x21 \\<mapsto> nb b x21))\n                             ve))\n                    x22),\n                 nb b x21))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran b \\<and> b \\<le> b'", "have b_dom_beta: \"\\<forall>b'\\<in>ran (\\<beta>'(lab' \\<mapsto> nb b lab')). b' \\<le> nb b lab'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>b'\\<in>ran (\\<beta>'(lab' \\<mapsto> nb b lab')).\n       b' \\<le> nb b lab'", "by (rule prem2')"], ["proof (state)\nthis:\n  \\<forall>b'\\<in>ran (\\<beta>'(lab' \\<mapsto> nb b lab')).\n     b' \\<le> nb b lab'\n\ngoal (2 subgoals):\n 1. \\<And>x21 x22 x23.\n       \\<lbrakk>c = call.Let x21 x22 x23; b \\<in> ran \\<beta>';\n        \\<forall>b'\\<in>ran \\<beta>'. b' \\<le> b;\n        \\<forall>b'\\<in>contours_in_ve ve. b' \\<le> b\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (evalC\\<cdot>\n                           (Discr\n                             (x23, \\<beta>'(x21 \\<mapsto> nb b x21),\n                              ve ++\n                              map_of\n                               (map (\\<lambda>(v, l).\n  ((v, nb b x21), \\<A> (L l) (\\<beta>'(x21 \\<mapsto> nb b x21)) ve))\n                                 x22),\n                              nb b x21)))\n 2. \\<And>x21 x22 x23 a b bb.\n       \\<lbrakk>c = call.Let x21 x22 x23; b \\<in> ran \\<beta>';\n        \\<forall>b'\\<in>ran \\<beta>'. b' \\<le> b;\n        \\<forall>b'\\<in>contours_in_ve ve. b' \\<le> b;\n        ((a, b), bb)\n        \\<in> evalC\\<cdot>\n              (Discr\n                (x23, \\<beta>'(x21 \\<mapsto> nb b x21),\n                 ve ++\n                 map_of\n                  (map (\\<lambda>(v, l).\n                           ((v, nb b x21),\n                            \\<A> (L l) (\\<beta>'(x21 \\<mapsto> nb b x21))\n                             ve))\n                    x22),\n                 nb b x21))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran b \\<and> b \\<le> b'", "have new: \"nb b lab' \\<in> ran (\\<beta>'(lab' \\<mapsto> nb b lab'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nb b lab' \\<in> ran (\\<beta>'(lab' \\<mapsto> nb b lab'))", "by simp"], ["proof (state)\nthis:\n  nb b lab' \\<in> ran (\\<beta>'(lab' \\<mapsto> nb b lab'))\n\ngoal (2 subgoals):\n 1. \\<And>x21 x22 x23.\n       \\<lbrakk>c = call.Let x21 x22 x23; b \\<in> ran \\<beta>';\n        \\<forall>b'\\<in>ran \\<beta>'. b' \\<le> b;\n        \\<forall>b'\\<in>contours_in_ve ve. b' \\<le> b\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (evalC\\<cdot>\n                           (Discr\n                             (x23, \\<beta>'(x21 \\<mapsto> nb b x21),\n                              ve ++\n                              map_of\n                               (map (\\<lambda>(v, l).\n  ((v, nb b x21), \\<A> (L l) (\\<beta>'(x21 \\<mapsto> nb b x21)) ve))\n                                 x22),\n                              nb b x21)))\n 2. \\<And>x21 x22 x23 a b bb.\n       \\<lbrakk>c = call.Let x21 x22 x23; b \\<in> ran \\<beta>';\n        \\<forall>b'\\<in>ran \\<beta>'. b' \\<le> b;\n        \\<forall>b'\\<in>contours_in_ve ve. b' \\<le> b;\n        ((a, b), bb)\n        \\<in> evalC\\<cdot>\n              (Discr\n                (x23, \\<beta>'(x21 \\<mapsto> nb b x21),\n                 ve ++\n                 map_of\n                  (map (\\<lambda>(v, l).\n                           ((v, nb b x21),\n                            \\<A> (L l) (\\<beta>'(x21 \\<mapsto> nb b x21))\n                             ve))\n                    x22),\n                 nb b x21))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran b \\<and> b \\<le> b'", "from hyps_C_sv[OF new b_dom_beta b_dom_ve, of c']"], ["proof (chain)\npicking this:\n  single_valued\n   (evalC\\<cdot>\n    (Discr\n      (c', \\<beta>'(lab' \\<mapsto> nb b lab'),\n       ve ++\n       map_of\n        (map (\\<lambda>(v, l).\n                 ((v, nb b lab'),\n                  \\<A> (L l) (\\<beta>'(lab' \\<mapsto> nb b lab')) ve))\n          ls),\n       nb b lab')))", "show \"single_valued (evalC\\<cdot>(Discr (c', \\<beta>'(lab' \\<mapsto> nb b lab'),\n       ve ++ map_of (map (\\<lambda>(v, l).((v, nb b lab'), evalV (L l) (\\<beta>'(lab' \\<mapsto> nb b lab')) ve))ls),\n       nb b lab')))\""], ["proof (prove)\nusing this:\n  single_valued\n   (evalC\\<cdot>\n    (Discr\n      (c', \\<beta>'(lab' \\<mapsto> nb b lab'),\n       ve ++\n       map_of\n        (map (\\<lambda>(v, l).\n                 ((v, nb b lab'),\n                  \\<A> (L l) (\\<beta>'(lab' \\<mapsto> nb b lab')) ve))\n          ls),\n       nb b lab')))\n\ngoal (1 subgoal):\n 1. single_valued\n     (evalC\\<cdot>\n      (Discr\n        (c', \\<beta>'(lab' \\<mapsto> nb b lab'),\n         ve ++\n         map_of\n          (map (\\<lambda>(v, l).\n                   ((v, nb b lab'),\n                    \\<A> (L l) (\\<beta>'(lab' \\<mapsto> nb b lab')) ve))\n            ls),\n         nb b lab')))", "."], ["proof (state)\nthis:\n  single_valued\n   (evalC\\<cdot>\n    (Discr\n      (c', \\<beta>'(lab' \\<mapsto> nb b lab'),\n       ve ++\n       map_of\n        (map (\\<lambda>(v, l).\n                 ((v, nb b lab'),\n                  \\<A> (L l) (\\<beta>'(lab' \\<mapsto> nb b lab')) ve))\n          ls),\n       nb b lab')))\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23 a b bb.\n       \\<lbrakk>c = call.Let x21 x22 x23; b \\<in> ran \\<beta>';\n        \\<forall>b'\\<in>ran \\<beta>'. b' \\<le> b;\n        \\<forall>b'\\<in>contours_in_ve ve. b' \\<le> b;\n        ((a, b), bb)\n        \\<in> evalC\\<cdot>\n              (Discr\n                (x23, \\<beta>'(x21 \\<mapsto> nb b x21),\n                 ve ++\n                 map_of\n                  (map (\\<lambda>(v, l).\n                           ((v, nb b x21),\n                            \\<A> (L l) (\\<beta>'(x21 \\<mapsto> nb b x21))\n                             ve))\n                    x22),\n                 nb b x21))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran b \\<and> b \\<le> b'", "fix lab \\<beta> t"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23 a b bb.\n       \\<lbrakk>c = call.Let x21 x22 x23; b \\<in> ran \\<beta>';\n        \\<forall>b'\\<in>ran \\<beta>'. b' \\<le> b;\n        \\<forall>b'\\<in>contours_in_ve ve. b' \\<le> b;\n        ((a, b), bb)\n        \\<in> evalC\\<cdot>\n              (Discr\n                (x23, \\<beta>'(x21 \\<mapsto> nb b x21),\n                 ve ++\n                 map_of\n                  (map (\\<lambda>(v, l).\n                           ((v, nb b x21),\n                            \\<A> (L l) (\\<beta>'(x21 \\<mapsto> nb b x21))\n                             ve))\n                    x22),\n                 nb b x21))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran b \\<and> b \\<le> b'", "assume \"((lab, \\<beta>), t) \\<in> evalC\\<cdot>(Discr (c', \\<beta>'(lab' \\<mapsto> nb b lab'),\n       ve ++ map_of (map (\\<lambda>(v, l).((v, nb b lab'), \\<A> (L l) (\\<beta>'(lab' \\<mapsto> nb b lab')) ve))ls),\n       nb b lab'))\""], ["proof (state)\nthis:\n  ((lab, \\<beta>), t)\n  \\<in> evalC\\<cdot>\n        (Discr\n          (c', \\<beta>'(lab' \\<mapsto> nb b lab'),\n           ve ++\n           map_of\n            (map (\\<lambda>(v, l).\n                     ((v, nb b lab'),\n                      \\<A> (L l) (\\<beta>'(lab' \\<mapsto> nb b lab')) ve))\n              ls),\n           nb b lab'))\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23 a b bb.\n       \\<lbrakk>c = call.Let x21 x22 x23; b \\<in> ran \\<beta>';\n        \\<forall>b'\\<in>ran \\<beta>'. b' \\<le> b;\n        \\<forall>b'\\<in>contours_in_ve ve. b' \\<le> b;\n        ((a, b), bb)\n        \\<in> evalC\\<cdot>\n              (Discr\n                (x23, \\<beta>'(x21 \\<mapsto> nb b x21),\n                 ve ++\n                 map_of\n                  (map (\\<lambda>(v, l).\n                           ((v, nb b x21),\n                            \\<A> (L l) (\\<beta>'(x21 \\<mapsto> nb b x21))\n                             ve))\n                    x22),\n                 nb b x21))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. b' \\<in> ran b \\<and> b \\<le> b'", "thus \"\\<exists>b'. b' \\<in> ran \\<beta> \\<and> b \\<le> b'\""], ["proof (prove)\nusing this:\n  ((lab, \\<beta>), t)\n  \\<in> evalC\\<cdot>\n        (Discr\n          (c', \\<beta>'(lab' \\<mapsto> nb b lab'),\n           ve ++\n           map_of\n            (map (\\<lambda>(v, l).\n                     ((v, nb b lab'),\n                      \\<A> (L l) (\\<beta>'(lab' \\<mapsto> nb b lab')) ve))\n              ls),\n           nb b lab'))\n\ngoal (1 subgoal):\n 1. \\<exists>b'. b' \\<in> ran \\<beta> \\<and> b \\<le> b'", "by -(drule hyps_C_b[OF new b_dom_beta b_dom_ve], auto)"], ["proof (state)\nthis:\n  \\<exists>b'. b' \\<in> ran \\<beta> \\<and> b \\<le> b'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  single_valued\n   ((\\<Lambda> cstate.\n        case undiscr cstate of\n        (App lab f vs, \\<beta>, ve, b) \\<Rightarrow>\n          let f' = \\<A> f \\<beta> ve;\n              as = map (\\<lambda>v. \\<A> v \\<beta> ve) vs; b' = nb b lab\n          in if isProc f'\n             then evalF\\<cdot>(Discr (f', as, ve, b')) \\<union>\n                  {((lab, \\<beta>), f')}\n             else \\<bottom>\n        | (call.Let lab ls c', \\<beta>, ve, b) \\<Rightarrow>\n            let b' = nb b lab; \\<beta>' = \\<beta>(lab \\<mapsto> b');\n                ve' =\n                  ve ++\n                  map_of\n                   (map (\\<lambda>(v, l). ((v, b'), \\<A> (L l) \\<beta>' ve))\n                     ls)\n            in evalC\\<cdot>(Discr (c', \\<beta>', ve', b')))\\<cdot>\n    (Discr (c, \\<beta>', ve, b))) \\<and>\n  (\\<forall>a\\<in>(\\<Lambda> cstate.\n                      case undiscr cstate of\n                      (App lab f vs, \\<beta>, ve, b) \\<Rightarrow>\n                        let f' = \\<A> f \\<beta> ve;\n                            as = map (\\<lambda>v. \\<A> v \\<beta> ve) vs;\n                            b' = nb b lab\n                        in if isProc f'\n                           then evalF\\<cdot>\n                                (Discr (f', as, ve, b')) \\<union>\n                                {((lab, \\<beta>), f')}\n                           else \\<bottom>\n                      | (call.Let lab ls c', \\<beta>, ve, b) \\<Rightarrow>\n                          let b' = nb b lab;\n                              \\<beta>' = \\<beta>(lab \\<mapsto> b');\n                              ve' =\n                                ve ++\n                                map_of\n                                 (map (\\<lambda>(v, l).\n    ((v, b'), \\<A> (L l) \\<beta>' ve))\n                                   ls)\n                          in evalC\\<cdot>\n                             (Discr (c', \\<beta>', ve', b')))\\<cdot>\n                  (Discr (c, \\<beta>', ve, b)).\n      case a of\n      (a, b) \\<Rightarrow>\n        (case a of\n         (lab, \\<beta>) \\<Rightarrow>\n           \\<lambda>t. \\<exists>b'. b' \\<in> ran \\<beta> \\<and> b \\<le> b')\n         b)\n\ngoal:\nNo subgoals!", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?ba2 \\<in> ran ?\\<beta>''2;\n   \\<forall>b'\\<in>ran ?\\<beta>''2. b' \\<le> ?ba2;\n   \\<forall>b'\\<in>contours_in_ve ?vea2. b' \\<le> ?ba2\\<rbrakk>\n  \\<Longrightarrow> single_valued\n                     ((\\<Lambda> cstate.\n                          case undiscr cstate of\n                          (App lab f vs, \\<beta>, ve, b) \\<Rightarrow>\n                            let f' = \\<A> f \\<beta> ve;\n                                as = map (\\<lambda>v. \\<A> v \\<beta> ve) vs;\n                                b' = nb b lab\n                            in if isProc f'\n                               then evalF\\<cdot>\n                                    (Discr (f', as, ve, b')) \\<union>\n                                    {((lab, \\<beta>), f')}\n                               else \\<bottom>\n                          | (call.Let lab ls c', \\<beta>, ve,\n                             b) \\<Rightarrow>\n                              let b' = nb b lab;\n                                  \\<beta>' = \\<beta>(lab \\<mapsto> b');\n                                  ve' =\n                                    ve ++\n                                    map_of\n                                     (map\n (\\<lambda>(v, l). ((v, b'), \\<A> (L l) \\<beta>' ve)) ls)\n                              in evalC\\<cdot>\n                                 (Discr (c', \\<beta>', ve', b')))\\<cdot>\n                      (Discr (?ca2, ?\\<beta>''2, ?vea2, ?ba2))) \\<and>\n                    (\\<forall>a\\<in>(\\<Lambda> cstate.\n  case undiscr cstate of\n  (App lab f vs, \\<beta>, ve, b) \\<Rightarrow>\n    let f' = \\<A> f \\<beta> ve; as = map (\\<lambda>v. \\<A> v \\<beta> ve) vs;\n        b' = nb b lab\n    in if isProc f'\n       then evalF\\<cdot>(Discr (f', as, ve, b')) \\<union>\n            {((lab, \\<beta>), f')}\n       else \\<bottom>\n  | (call.Let lab ls c', \\<beta>, ve, b) \\<Rightarrow>\n      let b' = nb b lab; \\<beta>' = \\<beta>(lab \\<mapsto> b');\n          ve' =\n            ve ++\n            map_of\n             (map (\\<lambda>(v, l). ((v, b'), \\<A> (L l) \\<beta>' ve)) ls)\n      in evalC\\<cdot>(Discr (c', \\<beta>', ve', b')))\\<cdot>\n                                    (Discr\n(?ca2, ?\\<beta>''2, ?vea2, ?ba2)).\n                        case a of\n                        (a, b) \\<Rightarrow>\n                          (case a of\n                           (lab, \\<beta>) \\<Rightarrow>\n                             \\<lambda>t.\n                                \\<exists>b'.\n                                   b' \\<in> ran \\<beta> \\<and>\n                                   ?ba2 \\<le> b')\n                           b)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma \"single_valued (\\<PR> prog)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. single_valued (\\<PR> prog)", "unfolding evalCPS_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. single_valued\n     (let ve = Map.empty; \\<beta> = Map.empty; f = \\<A> (L prog) \\<beta> ve\n      in \\<F>\\<cdot>(Discr (f, [Stop], ve, \\<binit>)))", "by ((subst HOL.Let_def)+, rule cc_single_valued'[THEN conjunct1], auto)"], ["", "end"]]}