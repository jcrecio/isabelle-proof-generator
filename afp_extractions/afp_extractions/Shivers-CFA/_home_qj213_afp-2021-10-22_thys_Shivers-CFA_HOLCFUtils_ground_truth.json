{"file_name": "/home/qj213/afp-2021-10-22/thys/Shivers-CFA/HOLCFUtils.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Shivers-CFA", "problem_names": ["lemma is_lub_bool: \"S <<| (True \\<in> S)\"", "lemma lub_bool: \"lub S = (True \\<in> S)\"", "lemma bottom_eq_False[simp]: \"\\<bottom> = False\"", "lemma sqsubset_is_subset: \"A \\<sqsubseteq> B \\<longleftrightarrow> A \\<subseteq> B\"", "lemma is_lub_set: \"S <<| \\<Union>S\"", "lemma lub_is_union: \"lub S = \\<Union>S\"", "lemma emptyset_is_bot[simp]: \"{} \\<sqsubseteq> S\"", "lemma bot_bool_is_emptyset[simp]: \"\\<bottom> = {}\"", "lemma cont2cont_disj [simp, cont2cont]:\n  assumes f: \"cont (\\<lambda>x. f x)\" and g: \"cont (\\<lambda>x. g x)\"\n  shows \"cont (\\<lambda>x. f x \\<or> g x)\"", "lemma cont2cont_imp[simp, cont2cont]:\n  assumes f: \"cont (\\<lambda>x. \\<not> f x)\" and g: \"cont (\\<lambda>x. g x)\"\n  shows \"cont (\\<lambda>x. f x \\<longrightarrow> g x)\"", "lemma cont2cont_Collect [simp, cont2cont]:\n  assumes \"\\<And>y. cont (\\<lambda>x. f x y)\"\n  shows \"cont (\\<lambda>x. {y. f x y})\"", "lemma cont2cont_mem [simp, cont2cont]:\n  assumes \"cont (\\<lambda>x. f x)\"\n  shows \"cont (\\<lambda>x. y \\<in> f x)\"", "lemma cont2cont_union [simp, cont2cont]:\n  \"cont (\\<lambda>x. f x) \\<Longrightarrow> cont (\\<lambda>x. g x)\n\\<Longrightarrow> cont (\\<lambda>x. f x \\<union> g x)\"", "lemma cont2cont_insert [simp, cont2cont]:\n  assumes \"cont (\\<lambda>x. f x)\"\n  shows \"cont (\\<lambda>x. insert y (f x))\"", "lemmas adm_subset = adm_below[where ?'b = \"'a::type set\", unfolded sqsubset_is_subset]", "lemma cont2cont_UNION[cont2cont,simp]:\n  assumes \"cont f\"\n      and \"\\<And> y. cont (\\<lambda>x. g x y)\"\n  shows \"cont (\\<lambda>x. \\<Union>y\\<in> f x. g x y)\"", "lemma cont2cont_Let_simple[simp,cont2cont]:\n  assumes \"cont (\\<lambda>x. g x t)\"\n  shows \"cont (\\<lambda>x. let y = t in g x y)\"", "lemma cont2cont_case_list [simp, cont2cont]:\n  assumes \"\\<And>y. cont (\\<lambda>x. f1 x)\"\n     and  \"\\<And>y z. cont (\\<lambda>x. f2 x y z)\"\n  shows \"cont (\\<lambda>x. case_list (f1 x) (f2 x) l)\"", "lemma adm_not_mem:\n  assumes \"cont (\\<lambda>x. f x)\"\n  shows \"adm (\\<lambda>x. y \\<notin> f x)\"", "lemma adm_id[simp]: \"adm (\\<lambda>x . x)\"", "lemma adm_Not[simp]: \"adm Not\"", "lemma adm_prod_split:\n  assumes \"adm (\\<lambda>p. f (fst p) (snd p))\"\n  shows \"adm (\\<lambda>(x,y). f x y)\"", "lemma adm_ball':\n  assumes \"\\<And> y. adm (\\<lambda>x. y \\<in> A x \\<longrightarrow> P x y)\"\n  shows \"adm (\\<lambda>x. \\<forall>y \\<in> A x . P x y)\"", "lemma adm_not_conj:\n  \"\\<lbrakk>adm (\\<lambda>x. \\<not> P x); adm (\\<lambda>x. \\<not> Q x)\\<rbrakk> \\<Longrightarrow> adm (\\<lambda>x. \\<not> (P x \\<and> Q x))\"", "lemma adm_single_valued:\n assumes \"cont (\\<lambda>x. f x)\"\n shows \"adm (\\<lambda>x. single_valued (f x))\""], "translations": [["", "lemma is_lub_bool: \"S <<| (True \\<in> S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S <<| (True \\<in> S)", "unfolding is_lub_def is_ub_def below_bool_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>y\\<in>S. y \\<longrightarrow> True \\<in> S) \\<and>\n    (\\<forall>u.\n        (\\<forall>y\\<in>S. y \\<longrightarrow> u) \\<longrightarrow>\n        True \\<in> S \\<longrightarrow> u)", "by auto"], ["", "lemma lub_bool: \"lub S = (True \\<in> S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lub S = (True \\<in> S)", "using is_lub_bool"], ["proof (prove)\nusing this:\n  ?S <<| (True \\<in> ?S)\n\ngoal (1 subgoal):\n 1. lub S = (True \\<in> S)", "by (rule lub_eqI)"], ["", "lemma bottom_eq_False[simp]: \"\\<bottom> = False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bottom> = False", "by (rule below_antisym [OF minimal], simp add: below_bool_def)"], ["", "text \\<open>\nTo convert between the squared syntax used by @{theory HOLCF} and the regular, round syntax for sets, we state some of the equivalencies.\n\\<close>"], ["", "instantiation set :: (type) po\nbegin"], ["", "definition\n  \"A \\<sqsubseteq> B \\<longleftrightarrow> A \\<subseteq> B\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a set, po_class)", "by standard (unfold below_set_def, fast+)"], ["", "end"], ["", "lemma sqsubset_is_subset: \"A \\<sqsubseteq> B \\<longleftrightarrow> A \\<subseteq> B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A \\<sqsubseteq> B) = (A \\<subseteq> B)", "by (fact below_set_def)"], ["", "lemma is_lub_set: \"S <<| \\<Union>S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S <<| \\<Union> S", "unfolding is_lub_def is_ub_def below_set_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>y\\<in>S. y \\<subseteq> \\<Union> S) \\<and>\n    (\\<forall>u.\n        (\\<forall>y\\<in>S. y \\<subseteq> u) \\<longrightarrow>\n        \\<Union> S \\<subseteq> u)", "by fast"], ["", "lemma lub_is_union: \"lub S = \\<Union>S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lub S = \\<Union> S", "using is_lub_set"], ["proof (prove)\nusing this:\n  ?S <<| \\<Union> ?S\n\ngoal (1 subgoal):\n 1. lub S = \\<Union> S", "by (rule lub_eqI)"], ["", "instance set :: (type) cpo"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a set, cpo_class)", "by standard (fast intro: is_lub_set)"], ["", "lemma emptyset_is_bot[simp]: \"{} \\<sqsubseteq> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {} \\<sqsubseteq> S", "by (simp add:sqsubset_is_subset)"], ["", "instance set :: (type) pcpo"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a set, pcpo_class)", "by standard (fast intro: emptyset_is_bot)"], ["", "lemma bot_bool_is_emptyset[simp]: \"\\<bottom> = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bottom> = {}", "using emptyset_is_bot"], ["proof (prove)\nusing this:\n  {} \\<sqsubseteq> ?S\n\ngoal (1 subgoal):\n 1. \\<bottom> = {}", "by (rule bottomI [symmetric])"], ["", "text \\<open>\nTo actually use these instance in \\<open>fixrec\\<close> definitions or fixed-point inductions, we need continuity requrements for various boolean and set operations.\n\\<close>"], ["", "lemma cont2cont_disj [simp, cont2cont]:\n  assumes f: \"cont (\\<lambda>x. f x)\" and g: \"cont (\\<lambda>x. g x)\"\n  shows \"cont (\\<lambda>x. f x \\<or> g x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cont (\\<lambda>x. f x \\<or> g x)", "apply (rule cont_apply [OF f])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x. cont (\\<lambda>y. y \\<or> g x)\n 2. \\<And>y. cont (\\<lambda>x. y \\<or> g x)", "apply (rule chfindom_monofun2cont)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x. monofun (\\<lambda>y. y \\<or> g x)\n 2. \\<And>y. cont (\\<lambda>x. y \\<or> g x)", "apply (rule monofunI, simp add: below_bool_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y. cont (\\<lambda>x. y \\<or> g x)", "apply (rule cont_compose [OF _ g])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y. cont ((\\<or>) y)", "apply (rule chfindom_monofun2cont)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y. monofun ((\\<or>) y)", "apply (rule monofunI, simp add: below_bool_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma cont2cont_imp[simp, cont2cont]:\n  assumes f: \"cont (\\<lambda>x. \\<not> f x)\" and g: \"cont (\\<lambda>x. g x)\"\n  shows \"cont (\\<lambda>x. f x \\<longrightarrow> g x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cont (\\<lambda>x. f x \\<longrightarrow> g x)", "unfolding imp_conv_disj"], ["proof (prove)\ngoal (1 subgoal):\n 1. cont (\\<lambda>x. \\<not> f x \\<or> g x)", "by (rule cont2cont_disj[OF f g])"], ["", "lemma cont2cont_Collect [simp, cont2cont]:\n  assumes \"\\<And>y. cont (\\<lambda>x. f x y)\"\n  shows \"cont (\\<lambda>x. {y. f x y})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cont (\\<lambda>x. {y. f x y})", "apply (rule contI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Y.\n       chain Y \\<Longrightarrow>\n       range (\\<lambda>i. {y. f (Y i) y}) <<| {y. f (\\<Squnion>i. Y i) y}", "apply (subst cont2contlubE [OF assms], assumption)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Y.\n       chain Y \\<Longrightarrow>\n       range (\\<lambda>i. Collect (f (Y i))) <<| {y. \\<Squnion>i. f (Y i) y}", "apply (auto simp add: is_lub_def is_ub_def below_set_def lub_bool)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma cont2cont_mem [simp, cont2cont]:\n  assumes \"cont (\\<lambda>x. f x)\"\n  shows \"cont (\\<lambda>x. y \\<in> f x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cont (\\<lambda>x. y \\<in> f x)", "apply (rule cont_compose [OF _ assms])"], ["proof (prove)\ngoal (1 subgoal):\n 1. cont ((\\<in>) y)", "apply (rule contI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Y.\n       chain Y \\<Longrightarrow>\n       range (\\<lambda>i. y \\<in> Y i) <<| (y \\<in> (\\<Squnion>i. Y i))", "apply (auto simp add: is_lub_def is_ub_def below_bool_def lub_is_union)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma cont2cont_union [simp, cont2cont]:\n  \"cont (\\<lambda>x. f x) \\<Longrightarrow> cont (\\<lambda>x. g x)\n\\<Longrightarrow> cont (\\<lambda>x. f x \\<union> g x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>cont f; cont g\\<rbrakk>\n    \\<Longrightarrow> cont (\\<lambda>x. f x \\<union> g x)", "unfolding Un_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>cont f; cont g\\<rbrakk>\n    \\<Longrightarrow> cont\n                       (\\<lambda>x. {xa. xa \\<in> f x \\<or> xa \\<in> g x})", "by simp"], ["", "lemma cont2cont_insert [simp, cont2cont]:\n  assumes \"cont (\\<lambda>x. f x)\"\n  shows \"cont (\\<lambda>x. insert y (f x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cont (\\<lambda>x. insert y (f x))", "unfolding insert_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. cont (\\<lambda>x. {x. x = y} \\<union> f x)", "using assms"], ["proof (prove)\nusing this:\n  cont f\n\ngoal (1 subgoal):\n 1. cont (\\<lambda>x. {x. x = y} \\<union> f x)", "by (intro cont2cont)"], ["", "lemmas adm_subset = adm_below[where ?'b = \"'a::type set\", unfolded sqsubset_is_subset]"], ["", "lemma cont2cont_UNION[cont2cont,simp]:\n  assumes \"cont f\"\n      and \"\\<And> y. cont (\\<lambda>x. g x y)\"\n  shows \"cont (\\<lambda>x. \\<Union>y\\<in> f x. g x y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cont (\\<lambda>x. \\<Union> (g x ` f x))", "proof(induct rule: contI2[case_names Mono Limit])"], ["proof (state)\ngoal (2 subgoals):\n 1. monofun (\\<lambda>x. \\<Union> (g x ` f x))\n 2. \\<And>Y.\n       \\<lbrakk>chain Y;\n        chain (\\<lambda>i. \\<Union> (g (Y i) ` f (Y i)))\\<rbrakk>\n       \\<Longrightarrow> \\<Union>\n                          (g (\\<Squnion>i. Y i) `\n                           f (\\<Squnion>i. Y i)) \\<sqsubseteq>\n                         (\\<Squnion>i. \\<Union> (g (Y i) ` f (Y i)))", "case Mono"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. monofun (\\<lambda>x. \\<Union> (g x ` f x))\n 2. \\<And>Y.\n       \\<lbrakk>chain Y;\n        chain (\\<lambda>i. \\<Union> (g (Y i) ` f (Y i)))\\<rbrakk>\n       \\<Longrightarrow> \\<Union>\n                          (g (\\<Squnion>i. Y i) `\n                           f (\\<Squnion>i. Y i)) \\<sqsubseteq>\n                         (\\<Squnion>i. \\<Union> (g (Y i) ` f (Y i)))", "show \"monofun (\\<lambda>x. \\<Union>y\\<in>f x. g x y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monofun (\\<lambda>x. \\<Union> (g x ` f x))", "by (rule monofunI)(auto iff:sqsubset_is_subset dest: monofunE[OF assms(1)[THEN cont2mono]] monofunE[OF assms(2)[THEN cont2mono]])"], ["proof (state)\nthis:\n  monofun (\\<lambda>x. \\<Union> (g x ` f x))\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       \\<lbrakk>chain Y;\n        chain (\\<lambda>i. \\<Union> (g (Y i) ` f (Y i)))\\<rbrakk>\n       \\<Longrightarrow> \\<Union>\n                          (g (\\<Squnion>i. Y i) `\n                           f (\\<Squnion>i. Y i)) \\<sqsubseteq>\n                         (\\<Squnion>i. \\<Union> (g (Y i) ` f (Y i)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Y.\n       \\<lbrakk>chain Y;\n        chain (\\<lambda>i. \\<Union> (g (Y i) ` f (Y i)))\\<rbrakk>\n       \\<Longrightarrow> \\<Union>\n                          (g (\\<Squnion>i. Y i) `\n                           f (\\<Squnion>i. Y i)) \\<sqsubseteq>\n                         (\\<Squnion>i. \\<Union> (g (Y i) ` f (Y i)))", "case (Limit Y)"], ["proof (state)\nthis:\n  chain Y\n  chain (\\<lambda>i. \\<Union> (g (Y i) ` f (Y i)))\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       \\<lbrakk>chain Y;\n        chain (\\<lambda>i. \\<Union> (g (Y i) ` f (Y i)))\\<rbrakk>\n       \\<Longrightarrow> \\<Union>\n                          (g (\\<Squnion>i. Y i) `\n                           f (\\<Squnion>i. Y i)) \\<sqsubseteq>\n                         (\\<Squnion>i. \\<Union> (g (Y i) ` f (Y i)))", "have \"(\\<Union>y\\<in>f (\\<Squnion> i. Y i). g (\\<Squnion> j. Y j) y) \\<subseteq> (\\<Squnion> k. \\<Union>y\\<in>f (Y k). g (Y k) y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> (g (\\<Squnion>j. Y j) ` f (\\<Squnion>i. Y i))\n    \\<subseteq> (\\<Squnion>k. \\<Union> (g (Y k) ` f (Y k)))", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<Union>\n                (g (\\<Squnion>j. Y j) `\n                 f (\\<Squnion>i. Y i)) \\<Longrightarrow>\n       x \\<in> (\\<Squnion>k. \\<Union> (g (Y k) ` f (Y k)))", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<Union>\n                (g (\\<Squnion>j. Y j) `\n                 f (\\<Squnion>i. Y i)) \\<Longrightarrow>\n       x \\<in> (\\<Squnion>k. \\<Union> (g (Y k) ` f (Y k)))", "assume \"x \\<in> (\\<Union>y\\<in>f (\\<Squnion> i. Y i). g (\\<Squnion> j. Y j) y)\""], ["proof (state)\nthis:\n  x \\<in> \\<Union> (g (\\<Squnion>j. Y j) ` f (\\<Squnion>i. Y i))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<Union>\n                (g (\\<Squnion>j. Y j) `\n                 f (\\<Squnion>i. Y i)) \\<Longrightarrow>\n       x \\<in> (\\<Squnion>k. \\<Union> (g (Y k) ` f (Y k)))", "then"], ["proof (chain)\npicking this:\n  x \\<in> \\<Union> (g (\\<Squnion>j. Y j) ` f (\\<Squnion>i. Y i))", "obtain y where \"y\\<in>f (\\<Squnion> i. Y i)\" and \"x\\<in> g (\\<Squnion> j. Y j) y\""], ["proof (prove)\nusing this:\n  x \\<in> \\<Union> (g (\\<Squnion>j. Y j) ` f (\\<Squnion>i. Y i))\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<in> f (\\<Squnion>i. Y i);\n         x \\<in> g (\\<Squnion>j. Y j) y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  y \\<in> f (\\<Squnion>i. Y i)\n  x \\<in> g (\\<Squnion>j. Y j) y\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<Union>\n                (g (\\<Squnion>j. Y j) `\n                 f (\\<Squnion>i. Y i)) \\<Longrightarrow>\n       x \\<in> (\\<Squnion>k. \\<Union> (g (Y k) ` f (Y k)))", "hence \"y \\<in> (\\<Squnion> i. f (Y i))\" and \"x\\<in> (\\<Squnion> j. g (Y j) y)\""], ["proof (prove)\nusing this:\n  y \\<in> f (\\<Squnion>i. Y i)\n  x \\<in> g (\\<Squnion>j. Y j) y\n\ngoal (1 subgoal):\n 1. y \\<in> (\\<Squnion>i. f (Y i)) &&& x \\<in> (\\<Squnion>j. g (Y j) y)", "by (auto simp add: cont2contlubE[OF assms(1) Limit(1)] cont2contlubE[OF assms(2) Limit(1)])"], ["proof (state)\nthis:\n  y \\<in> (\\<Squnion>i. f (Y i))\n  x \\<in> (\\<Squnion>j. g (Y j) y)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<Union>\n                (g (\\<Squnion>j. Y j) `\n                 f (\\<Squnion>i. Y i)) \\<Longrightarrow>\n       x \\<in> (\\<Squnion>k. \\<Union> (g (Y k) ` f (Y k)))", "then"], ["proof (chain)\npicking this:\n  y \\<in> (\\<Squnion>i. f (Y i))\n  x \\<in> (\\<Squnion>j. g (Y j) y)", "obtain i and j where yi: \"y\\<in> f (Y i)\" and xj: \"x\\<in> g (Y j) y\""], ["proof (prove)\nusing this:\n  y \\<in> (\\<Squnion>i. f (Y i))\n  x \\<in> (\\<Squnion>j. g (Y j) y)\n\ngoal (1 subgoal):\n 1. (\\<And>i j.\n        \\<lbrakk>y \\<in> f (Y i); x \\<in> g (Y j) y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp add:lub_is_union)"], ["proof (state)\nthis:\n  y \\<in> f (Y i)\n  x \\<in> g (Y j) y\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<Union>\n                (g (\\<Squnion>j. Y j) `\n                 f (\\<Squnion>i. Y i)) \\<Longrightarrow>\n       x \\<in> (\\<Squnion>k. \\<Union> (g (Y k) ` f (Y k)))", "obtain k where \"i\\<le>k\" and \"j\\<le>k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>k.\n        \\<lbrakk>i \\<le> k; j \\<le> k\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (erule_tac x = \"max i j\" in meta_allE)auto"], ["proof (state)\nthis:\n  i \\<le> k\n  j \\<le> k\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<Union>\n                (g (\\<Squnion>j. Y j) `\n                 f (\\<Squnion>i. Y i)) \\<Longrightarrow>\n       x \\<in> (\\<Squnion>k. \\<Union> (g (Y k) ` f (Y k)))", "from yi and xj"], ["proof (chain)\npicking this:\n  y \\<in> f (Y i)\n  x \\<in> g (Y j) y", "have \"y \\<in> f (Y k)\" and \"x\\<in> g (Y k) y\""], ["proof (prove)\nusing this:\n  y \\<in> f (Y i)\n  x \\<in> g (Y j) y\n\ngoal (1 subgoal):\n 1. y \\<in> f (Y k) &&& x \\<in> g (Y k) y", "using monofunE[OF assms(1)[THEN cont2mono], OF chain_mono[OF Limit(1) \\<open>i\\<le>k\\<close>]]\n        and monofunE[OF assms(2)[THEN cont2mono], OF chain_mono[OF Limit(1) \\<open>j\\<le>k\\<close>]]"], ["proof (prove)\nusing this:\n  y \\<in> f (Y i)\n  x \\<in> g (Y j) y\n  f (Y i) \\<sqsubseteq> f (Y k)\n  g (Y j) ?y2 \\<sqsubseteq> g (Y k) ?y2\n\ngoal (1 subgoal):\n 1. y \\<in> f (Y k) &&& x \\<in> g (Y k) y", "by (auto simp add:sqsubset_is_subset)"], ["proof (state)\nthis:\n  y \\<in> f (Y k)\n  x \\<in> g (Y k) y\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<Union>\n                (g (\\<Squnion>j. Y j) `\n                 f (\\<Squnion>i. Y i)) \\<Longrightarrow>\n       x \\<in> (\\<Squnion>k. \\<Union> (g (Y k) ` f (Y k)))", "hence \"x\\<in> (\\<Union>y\\<in> f (Y k). g (Y k) y)\""], ["proof (prove)\nusing this:\n  y \\<in> f (Y k)\n  x \\<in> g (Y k) y\n\ngoal (1 subgoal):\n 1. x \\<in> \\<Union> (g (Y k) ` f (Y k))", "by auto"], ["proof (state)\nthis:\n  x \\<in> \\<Union> (g (Y k) ` f (Y k))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<Union>\n                (g (\\<Squnion>j. Y j) `\n                 f (\\<Squnion>i. Y i)) \\<Longrightarrow>\n       x \\<in> (\\<Squnion>k. \\<Union> (g (Y k) ` f (Y k)))", "thus \"x\\<in> (\\<Squnion> k. \\<Union>y\\<in>f (Y k). g (Y k) y)\""], ["proof (prove)\nusing this:\n  x \\<in> \\<Union> (g (Y k) ` f (Y k))\n\ngoal (1 subgoal):\n 1. x \\<in> (\\<Squnion>k. \\<Union> (g (Y k) ` f (Y k)))", "by (auto simp add:lub_is_union)"], ["proof (state)\nthis:\n  x \\<in> (\\<Squnion>k. \\<Union> (g (Y k) ` f (Y k)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<Union> (g (\\<Squnion>j. Y j) ` f (\\<Squnion>i. Y i))\n  \\<subseteq> (\\<Squnion>k. \\<Union> (g (Y k) ` f (Y k)))\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       \\<lbrakk>chain Y;\n        chain (\\<lambda>i. \\<Union> (g (Y i) ` f (Y i)))\\<rbrakk>\n       \\<Longrightarrow> \\<Union>\n                          (g (\\<Squnion>i. Y i) `\n                           f (\\<Squnion>i. Y i)) \\<sqsubseteq>\n                         (\\<Squnion>i. \\<Union> (g (Y i) ` f (Y i)))", "thus ?case"], ["proof (prove)\nusing this:\n  \\<Union> (g (\\<Squnion>j. Y j) ` f (\\<Squnion>i. Y i))\n  \\<subseteq> (\\<Squnion>k. \\<Union> (g (Y k) ` f (Y k)))\n\ngoal (1 subgoal):\n 1. \\<Union> (g (\\<Squnion>i. Y i) ` f (\\<Squnion>i. Y i)) \\<sqsubseteq>\n    (\\<Squnion>i. \\<Union> (g (Y i) ` f (Y i)))", "by (simp add:sqsubset_is_subset)"], ["proof (state)\nthis:\n  \\<Union> (g (\\<Squnion>i. Y i) ` f (\\<Squnion>i. Y i)) \\<sqsubseteq>\n  (\\<Squnion>i. \\<Union> (g (Y i) ` f (Y i)))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cont2cont_Let_simple[simp,cont2cont]:\n  assumes \"cont (\\<lambda>x. g x t)\"\n  shows \"cont (\\<lambda>x. let y = t in g x y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cont (\\<lambda>x. Let t (g x))", "unfolding Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. cont (\\<lambda>x. g x t)", "using assms"], ["proof (prove)\nusing this:\n  cont (\\<lambda>x. g x t)\n\ngoal (1 subgoal):\n 1. cont (\\<lambda>x. g x t)", "."], ["", "lemma cont2cont_case_list [simp, cont2cont]:\n  assumes \"\\<And>y. cont (\\<lambda>x. f1 x)\"\n     and  \"\\<And>y z. cont (\\<lambda>x. f2 x y z)\"\n  shows \"cont (\\<lambda>x. case_list (f1 x) (f2 x) l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cont\n     (\\<lambda>x.\n         case l of [] \\<Rightarrow> f1 x | xa # xb \\<Rightarrow> f2 x xa xb)", "using assms"], ["proof (prove)\nusing this:\n  cont f1\n  cont (\\<lambda>x. f2 x ?y ?z)\n\ngoal (1 subgoal):\n 1. cont\n     (\\<lambda>x.\n         case l of [] \\<Rightarrow> f1 x | xa # xb \\<Rightarrow> f2 x xa xb)", "by (cases l) auto"], ["", "text \\<open>As with the continuity lemmas, we need admissibility lemmas.\\<close>"], ["", "lemma adm_not_mem:\n  assumes \"cont (\\<lambda>x. f x)\"\n  shows \"adm (\\<lambda>x. y \\<notin> f x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adm (\\<lambda>x. y \\<notin> f x)", "using assms"], ["proof (prove)\nusing this:\n  cont f\n\ngoal (1 subgoal):\n 1. adm (\\<lambda>x. y \\<notin> f x)", "apply (erule_tac t = f in adm_subst)"], ["proof (prove)\ngoal (1 subgoal):\n 1. adm ((\\<notin>) y)", "proof (rule admI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Y.\n       \\<lbrakk>chain Y; \\<forall>i. y \\<notin> Y i\\<rbrakk>\n       \\<Longrightarrow> y \\<notin> (\\<Squnion>i. Y i)", "fix Y :: \"nat \\<Rightarrow> 'b set\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Y.\n       \\<lbrakk>chain Y; \\<forall>i. y \\<notin> Y i\\<rbrakk>\n       \\<Longrightarrow> y \\<notin> (\\<Squnion>i. Y i)", "assume chain: \"chain Y\""], ["proof (state)\nthis:\n  chain Y\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       \\<lbrakk>chain Y; \\<forall>i. y \\<notin> Y i\\<rbrakk>\n       \\<Longrightarrow> y \\<notin> (\\<Squnion>i. Y i)", "assume \"\\<forall>i. y \\<notin> Y i\""], ["proof (state)\nthis:\n  \\<forall>i. y \\<notin> Y i\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       \\<lbrakk>chain Y; \\<forall>i. y \\<notin> Y i\\<rbrakk>\n       \\<Longrightarrow> y \\<notin> (\\<Squnion>i. Y i)", "hence  \"(\\<Squnion> i. y \\<in> Y i) = False\""], ["proof (prove)\nusing this:\n  \\<forall>i. y \\<notin> Y i\n\ngoal (1 subgoal):\n 1. (\\<Squnion>i. y \\<in> Y i) = False", "by auto"], ["proof (state)\nthis:\n  (\\<Squnion>i. y \\<in> Y i) = False\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       \\<lbrakk>chain Y; \\<forall>i. y \\<notin> Y i\\<rbrakk>\n       \\<Longrightarrow> y \\<notin> (\\<Squnion>i. Y i)", "thus \"y \\<notin> (\\<Squnion> i. Y i)\""], ["proof (prove)\nusing this:\n  (\\<Squnion>i. y \\<in> Y i) = False\n\ngoal (1 subgoal):\n 1. y \\<notin> (\\<Squnion>i. Y i)", "using chain"], ["proof (prove)\nusing this:\n  (\\<Squnion>i. y \\<in> Y i) = False\n  chain Y\n\ngoal (1 subgoal):\n 1. y \\<notin> (\\<Squnion>i. Y i)", "unfolding lub_bool lub_is_union"], ["proof (prove)\nusing this:\n  (True \\<in> range (\\<lambda>i. y \\<in> Y i)) = False\n  chain Y\n\ngoal (1 subgoal):\n 1. y \\<notin> \\<Union> (range Y)", "by auto"], ["proof (state)\nthis:\n  y \\<notin> (\\<Squnion>i. Y i)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma adm_id[simp]: \"adm (\\<lambda>x . x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adm (\\<lambda>x. x)", "by (rule adm_chfin)"], ["", "lemma adm_Not[simp]: \"adm Not\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adm Not", "by (rule adm_chfin)"], ["", "lemma adm_prod_split:\n  assumes \"adm (\\<lambda>p. f (fst p) (snd p))\"\n  shows \"adm (\\<lambda>(x,y). f x y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adm (\\<lambda>(x, y). f x y)", "using assms"], ["proof (prove)\nusing this:\n  adm (\\<lambda>p. f (fst p) (snd p))\n\ngoal (1 subgoal):\n 1. adm (\\<lambda>(x, y). f x y)", "unfolding split_def"], ["proof (prove)\nusing this:\n  adm (\\<lambda>p. f (fst p) (snd p))\n\ngoal (1 subgoal):\n 1. adm (\\<lambda>p. f (fst p) (snd p))", "."], ["", "lemma adm_ball':\n  assumes \"\\<And> y. adm (\\<lambda>x. y \\<in> A x \\<longrightarrow> P x y)\"\n  shows \"adm (\\<lambda>x. \\<forall>y \\<in> A x . P x y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adm (\\<lambda>x. \\<forall>y\\<in>A x. P x y)", "by (subst Ball_def, rule adm_all[OF assms])"], ["", "lemma adm_not_conj:\n  \"\\<lbrakk>adm (\\<lambda>x. \\<not> P x); adm (\\<lambda>x. \\<not> Q x)\\<rbrakk> \\<Longrightarrow> adm (\\<lambda>x. \\<not> (P x \\<and> Q x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>adm (\\<lambda>x. \\<not> P x);\n     adm (\\<lambda>x. \\<not> Q x)\\<rbrakk>\n    \\<Longrightarrow> adm (\\<lambda>x. \\<not> (P x \\<and> Q x))", "by simp"], ["", "lemma adm_single_valued:\n assumes \"cont (\\<lambda>x. f x)\"\n shows \"adm (\\<lambda>x. single_valued (f x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adm (\\<lambda>x. single_valued (f x))", "using assms"], ["proof (prove)\nusing this:\n  cont f\n\ngoal (1 subgoal):\n 1. adm (\\<lambda>x. single_valued (f x))", "unfolding single_valued_def"], ["proof (prove)\nusing this:\n  cont f\n\ngoal (1 subgoal):\n 1. adm (\\<lambda>x.\n            \\<forall>xa y.\n               (xa, y) \\<in> f x \\<longrightarrow>\n               (\\<forall>z. (xa, z) \\<in> f x \\<longrightarrow> y = z))", "by (intro adm_lemmas adm_not_mem cont2cont adm_subst[of f])"], ["", "text \\<open>\nTo match Shivers' syntax we introduce the power-syntax for iterated function application.\n\\<close>"], ["", "abbreviation niceiterate (\"(_\\<^bsup>_\\<^esup>)\" [1000] 1000)\n  where \"niceiterate f i \\<equiv> iterate i\\<cdot>f\""], ["", "end"]]}