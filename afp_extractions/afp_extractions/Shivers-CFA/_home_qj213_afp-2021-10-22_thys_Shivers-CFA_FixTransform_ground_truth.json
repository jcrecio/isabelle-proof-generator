{"file_name": "/home/qj213/afp-2021-10-22/thys/Shivers-CFA/FixTransform.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Shivers-CFA", "problem_names": ["lemma fix_transform:\n  assumes \"\\<And>x. g\\<cdot>(f\\<cdot>x)=x\"\n  shows \"fix\\<cdot>F = g\\<cdot>(fix\\<cdot>(f oo F oo g))\"", "lemma cont2cont_case_sum[simp,cont2cont]:\n  assumes \"cont f\" and \"cont g\"\n  shows \"cont (\\<lambda>x. case_sum (f x) (g x) s)\"", "lemma cont2cont_circ[simp,cont2cont]:\n \"cont (\\<lambda>f. f \\<circ> g)\"", "lemma cont2cont_split_pair[cont2cont,simp]:\n assumes f1: \"cont f\"\n     and f2: \"\\<And> x. cont (f x)\"\n     and g1: \"cont g\"\n     and g2: \"\\<And> x. cont (g x)\"\n shows \"cont (\\<lambda>(a, b). (f a b, g a b))\"", "lemma sum_to_tup_app:\n \"sum_to_tup\\<cdot>f = (\\<Lambda> x. f\\<cdot>(Discr (Inl (undiscr x))), \\<Lambda> x. f\\<cdot>(Discr (Inr (undiscr x))))\"", "lemma tup_to_sum_app:\n  \"tup_to_sum\\<cdot>p = (\\<Lambda> s. (\\<lambda>(f,g).\n          case undiscr s of Inl x \\<Rightarrow> f\\<cdot>(Discr x)\n                          | Inr x \\<Rightarrow> g\\<cdot>(Discr x)) p)\"", "lemma discr_app[simp]:\n  \"(\\<Lambda> s. f s)\\<cdot>(Discr x) = f (Discr x)\"", "lemma tup_to_sum_to_tup[simp]:\n  shows   \"sum_to_tup\\<cdot>(tup_to_sum\\<cdot>F) = F\"", "lemma fix_transform_pair_sum:\n  shows \"fix\\<cdot>F = sum_to_tup\\<cdot>(fix\\<cdot>(tup_to_sum oo F oo sum_to_tup))\"", "lemma tup_sum_oo[simp]:\n assumes f1: \"cont F\"\n     and f2: \"\\<And> x. cont (F x)\"\n     and g1: \"cont G\"\n     and g2: \"\\<And> x. cont (G x)\"\nshows  \"tup_to_sum oo (\\<Lambda> p. (\\<lambda>(a, b). (F a b, G a b)) p) oo sum_to_tup\n  = (\\<Lambda> f s. (case undiscr s of\n        Inl x \\<Rightarrow>\n          F (\\<Lambda> s. f\\<cdot>(Discr (Inl (undiscr s))))\n           (\\<Lambda> s. f\\<cdot>(Discr (Inr (undiscr s))))\\<cdot>\n          (Discr x)\n        | Inr x \\<Rightarrow>\n            G (\\<Lambda> s. f\\<cdot>(Discr (Inl (undiscr s))))\n             (\\<Lambda> s. f\\<cdot>(Discr (Inr (undiscr s))))\\<cdot>\n            (Discr x)))\"", "lemma fst_sum_to_tup[simp]:\n  \"fst (sum_to_tup\\<cdot>x) = (\\<Lambda> xa. x\\<cdot>(Discr (Inl (undiscr xa))))\""], "translations": [["", "lemma fix_transform:\n  assumes \"\\<And>x. g\\<cdot>(f\\<cdot>x)=x\"\n  shows \"fix\\<cdot>F = g\\<cdot>(fix\\<cdot>(f oo F oo g))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fix\\<cdot>F = g\\<cdot>(fix\\<cdot>(f oo F oo g))", "using assms"], ["proof (prove)\nusing this:\n  g\\<cdot>(f\\<cdot>?x) = ?x\n\ngoal (1 subgoal):\n 1. fix\\<cdot>F = g\\<cdot>(fix\\<cdot>(f oo F oo g))", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x. g\\<cdot>(f\\<cdot>x) = x) \\<Longrightarrow>\n    fix\\<cdot>F = g\\<cdot>(fix\\<cdot>(f oo F oo g))", "apply (rule parallel_fix_ind)"], ["proof (prove)\ngoal (3 subgoals):\n 1. (\\<And>x. g\\<cdot>(f\\<cdot>x) = x) \\<Longrightarrow>\n    adm (\\<lambda>x. fst x = g\\<cdot>(snd x))\n 2. (\\<And>x. g\\<cdot>(f\\<cdot>x) = x) \\<Longrightarrow>\n    \\<bottom> = g\\<cdot>\\<bottom>\n 3. \\<And>x y.\n       \\<lbrakk>\\<And>x. g\\<cdot>(f\\<cdot>x) = x; x = g\\<cdot>y\\<rbrakk>\n       \\<Longrightarrow> F\\<cdot>x = g\\<cdot>((f oo F oo g)\\<cdot>y)", "apply (rule adm_eq)"], ["proof (prove)\ngoal (4 subgoals):\n 1. (\\<And>x. g\\<cdot>(f\\<cdot>x) = x) \\<Longrightarrow> cont fst\n 2. (\\<And>x. g\\<cdot>(f\\<cdot>x) = x) \\<Longrightarrow>\n    cont (\\<lambda>x. g\\<cdot>(snd x))\n 3. (\\<And>x. g\\<cdot>(f\\<cdot>x) = x) \\<Longrightarrow>\n    \\<bottom> = g\\<cdot>\\<bottom>\n 4. \\<And>x y.\n       \\<lbrakk>\\<And>x. g\\<cdot>(f\\<cdot>x) = x; x = g\\<cdot>y\\<rbrakk>\n       \\<Longrightarrow> F\\<cdot>x = g\\<cdot>((f oo F oo g)\\<cdot>y)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x. g\\<cdot>(f\\<cdot>x) = x) \\<Longrightarrow>\n    g\\<cdot>\\<bottom> = \\<bottom>", "apply (erule retraction_strict[of g f,rule_format])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>\nThe functions we use here convert a tuple of functions to a function taking a direct sum as parameters and back. We only care about discrete arguments here.\n\\<close>"], ["", "definition tup_to_sum :: \"('a discr \\<rightarrow> 'c) \\<times> ('b discr \\<rightarrow> 'c) \\<rightarrow> ('a + 'b) discr \\<rightarrow> 'c::cpo\"\n where \"tup_to_sum = (\\<Lambda> p s. (\\<lambda>(f,g).\n          case undiscr s of Inl x \\<Rightarrow> f\\<cdot>(Discr x)\n                          | Inr x \\<Rightarrow> g\\<cdot>(Discr x)) p)\""], ["", "definition sum_to_tup :: \"(('a + 'b) discr \\<rightarrow> 'c) \\<rightarrow> ('a discr \\<rightarrow> 'c) \\<times> ('b discr \\<rightarrow> 'c::cpo)\"\n where \"sum_to_tup = (\\<Lambda> f. (\\<Lambda> x. f\\<cdot>(Discr (Inl (undiscr x))),\n                             \\<Lambda> x. f\\<cdot>(Discr (Inr (undiscr x)))))\""], ["", "text \\<open>\nAs so often when working with @{theory HOLCF}, some continuity lemmas are required.\n\\<close>"], ["", "lemma cont2cont_case_sum[simp,cont2cont]:\n  assumes \"cont f\" and \"cont g\"\n  shows \"cont (\\<lambda>x. case_sum (f x) (g x) s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cont\n     (\\<lambda>x.\n         case s of Inl xa \\<Rightarrow> f x xa\n         | Inr xa \\<Rightarrow> g x xa)", "using assms"], ["proof (prove)\nusing this:\n  cont f\n  cont g\n\ngoal (1 subgoal):\n 1. cont\n     (\\<lambda>x.\n         case s of Inl xa \\<Rightarrow> f x xa\n         | Inr xa \\<Rightarrow> g x xa)", "by (cases s, auto intro:cont2cont_fun)"], ["", "lemma cont2cont_circ[simp,cont2cont]:\n \"cont (\\<lambda>f. f \\<circ> g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cont (\\<lambda>f. f \\<circ> g)", "apply (rule cont2cont_lambda)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y. cont (\\<lambda>x. (x \\<circ> g) y)", "apply (subst comp_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y. cont (\\<lambda>x. x (g y))", "apply (rule  cont2cont_fun[of \"\\<lambda>x. x\", OF \"cont_id\"])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma cont2cont_split_pair[cont2cont,simp]:\n assumes f1: \"cont f\"\n     and f2: \"\\<And> x. cont (f x)\"\n     and g1: \"cont g\"\n     and g2: \"\\<And> x. cont (g x)\"\n shows \"cont (\\<lambda>(a, b). (f a b, g a b))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cont (\\<lambda>(a, b). (f a b, g a b))", "apply (intro cont2cont)"], ["proof (prove)\ngoal (2 subgoals):\n 1. cont (\\<lambda>p. f (fst (snd p)) (snd (snd p)))\n 2. cont (\\<lambda>p. g (fst (snd p)) (snd (snd p)))", "apply (rule cont_apply[OF cont_snd _ cont_const])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>p. cont (\\<lambda>y. f (fst y) (snd y))\n 2. cont (\\<lambda>p. g (fst (snd p)) (snd (snd p)))", "apply (rule cont_apply[OF cont_snd f2])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>p y. cont (\\<lambda>ya. f (fst ya) y)\n 2. cont (\\<lambda>p. g (fst (snd p)) (snd (snd p)))", "apply (rule cont_apply[OF cont_fst cont2cont_fun[OF f1] cont_const])"], ["proof (prove)\ngoal (1 subgoal):\n 1. cont (\\<lambda>p. g (fst (snd p)) (snd (snd p)))", "apply (rule cont_apply[OF cont_snd _ cont_const])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p. cont (\\<lambda>y. g (fst y) (snd y))", "apply (rule cont_apply[OF cont_snd g2])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p y. cont (\\<lambda>ya. g (fst ya) y)", "apply (rule cont_apply[OF cont_fst cont2cont_fun[OF g1] cont_const])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>\nUsing these continuity lemmas, we can show that our function are actually continuous and thus allow us to apply them to a value.\n\\<close>"], ["", "lemma sum_to_tup_app:\n \"sum_to_tup\\<cdot>f = (\\<Lambda> x. f\\<cdot>(Discr (Inl (undiscr x))), \\<Lambda> x. f\\<cdot>(Discr (Inr (undiscr x))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_to_tup\\<cdot>f =\n    (\\<Lambda> x. f\\<cdot>(Discr (Inl (undiscr x))),\n     \\<Lambda> x. f\\<cdot>(Discr (Inr (undiscr x))))", "unfolding sum_to_tup_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Lambda> f.\n        (\\<Lambda> x. f\\<cdot>(Discr (Inl (undiscr x))),\n         \\<Lambda> x. f\\<cdot>(Discr (Inr (undiscr x)))))\\<cdot>\n    f =\n    (\\<Lambda> x. f\\<cdot>(Discr (Inl (undiscr x))),\n     \\<Lambda> x. f\\<cdot>(Discr (Inr (undiscr x))))", "by simp"], ["", "lemma tup_to_sum_app:\n  \"tup_to_sum\\<cdot>p = (\\<Lambda> s. (\\<lambda>(f,g).\n          case undiscr s of Inl x \\<Rightarrow> f\\<cdot>(Discr x)\n                          | Inr x \\<Rightarrow> g\\<cdot>(Discr x)) p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tup_to_sum\\<cdot>p =\n    (\\<Lambda> s.\n        case p of\n        (f, g) \\<Rightarrow>\n          case undiscr s of Inl x \\<Rightarrow> f\\<cdot>(Discr x)\n          | Inr x \\<Rightarrow> g\\<cdot>(Discr x))", "unfolding tup_to_sum_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Lambda> p s.\n        case p of\n        (f, g) \\<Rightarrow>\n          case undiscr s of Inl x \\<Rightarrow> f\\<cdot>(Discr x)\n          | Inr x \\<Rightarrow> g\\<cdot>(Discr x))\\<cdot>\n    p =\n    (\\<Lambda> s.\n        case p of\n        (f, g) \\<Rightarrow>\n          case undiscr s of Inl x \\<Rightarrow> f\\<cdot>(Discr x)\n          | Inr x \\<Rightarrow> g\\<cdot>(Discr x))", "by simp"], ["", "text \\<open>\nGenerally, lambda abstractions with discrete domain are continuous and can be resolved immediately.\n\\<close>"], ["", "lemma discr_app[simp]:\n  \"(\\<Lambda> s. f s)\\<cdot>(Discr x) = f (Discr x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Lambda> s. f s)\\<cdot>(Discr x) = f (Discr x)", "by simp"], ["", "text \\<open>\nOur transformation functions are inverse to each other, so we can use them to transform a fixed point.\n\\<close>"], ["", "lemma tup_to_sum_to_tup[simp]:\n  shows   \"sum_to_tup\\<cdot>(tup_to_sum\\<cdot>F) = F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_to_tup\\<cdot>(tup_to_sum\\<cdot>F) = F", "unfolding sum_to_tup_app and tup_to_sum_app"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Lambda> x.\n        (\\<Lambda> s.\n            case F of\n            (f, g) \\<Rightarrow>\n              case undiscr s of Inl x \\<Rightarrow> f\\<cdot>(Discr x)\n              | Inr x \\<Rightarrow> g\\<cdot>(Discr x))\\<cdot>\n        (Discr (Inl (undiscr x))),\n     \\<Lambda> x.\n        (\\<Lambda> s.\n            case F of\n            (f, g) \\<Rightarrow>\n              case undiscr s of Inl x \\<Rightarrow> f\\<cdot>(Discr x)\n              | Inr x \\<Rightarrow> g\\<cdot>(Discr x))\\<cdot>\n        (Discr (Inr (undiscr x)))) =\n    F", "by (cases F, auto intro:cfun_eqI)"], ["", "lemma fix_transform_pair_sum:\n  shows \"fix\\<cdot>F = sum_to_tup\\<cdot>(fix\\<cdot>(tup_to_sum oo F oo sum_to_tup))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fix\\<cdot>F =\n    sum_to_tup\\<cdot>(fix\\<cdot>(tup_to_sum oo F oo sum_to_tup))", "by (rule fix_transform[OF tup_to_sum_to_tup])"], ["", "text \\<open>\nAfter such a transformation, we want to get rid of these helper functions again. This is done by the next two simplification lemmas.\n\\<close>"], ["", "lemma tup_sum_oo[simp]:\n assumes f1: \"cont F\"\n     and f2: \"\\<And> x. cont (F x)\"\n     and g1: \"cont G\"\n     and g2: \"\\<And> x. cont (G x)\"\nshows  \"tup_to_sum oo (\\<Lambda> p. (\\<lambda>(a, b). (F a b, G a b)) p) oo sum_to_tup\n  = (\\<Lambda> f s. (case undiscr s of\n        Inl x \\<Rightarrow>\n          F (\\<Lambda> s. f\\<cdot>(Discr (Inl (undiscr s))))\n           (\\<Lambda> s. f\\<cdot>(Discr (Inr (undiscr s))))\\<cdot>\n          (Discr x)\n        | Inr x \\<Rightarrow>\n            G (\\<Lambda> s. f\\<cdot>(Discr (Inl (undiscr s))))\n             (\\<Lambda> s. f\\<cdot>(Discr (Inr (undiscr s))))\\<cdot>\n            (Discr x)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tup_to_sum oo\n    (\\<Lambda> p. case p of (a, b) \\<Rightarrow> (F a b, G a b)) oo\n    sum_to_tup =\n    (\\<Lambda> f s.\n        case undiscr s of\n        Inl x \\<Rightarrow>\n          F (\\<Lambda> s. f\\<cdot>(Discr (Inl (undiscr s))))\n           (\\<Lambda> s. f\\<cdot>(Discr (Inr (undiscr s))))\\<cdot>\n          (Discr x)\n        | Inr x \\<Rightarrow>\n            G (\\<Lambda> s. f\\<cdot>(Discr (Inl (undiscr s))))\n             (\\<Lambda> s. f\\<cdot>(Discr (Inr (undiscr s))))\\<cdot>\n            (Discr x))", "by (rule cfun_eqI, rule cfun_eqI,\n    simp add: sum_to_tup_app tup_to_sum_app\n       cont2cont_split_pair[OF f1 f2 g1 g2]\n       cont2cont_lambda\n       cont_apply[OF _ f2 cont2cont_fun[OF cont_compose[OF f1]]]\n       cont_apply[OF _ g2 cont2cont_fun[OF cont_compose[OF g1]]])"], ["", "lemma fst_sum_to_tup[simp]:\n  \"fst (sum_to_tup\\<cdot>x) = (\\<Lambda> xa. x\\<cdot>(Discr (Inl (undiscr xa))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (sum_to_tup\\<cdot>x) =\n    (\\<Lambda> xa. x\\<cdot>(Discr (Inl (undiscr xa))))", "by (simp add: sum_to_tup_app)"], ["", "end"]]}