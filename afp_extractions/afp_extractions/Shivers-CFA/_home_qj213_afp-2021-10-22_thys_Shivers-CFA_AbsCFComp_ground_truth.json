{"file_name": "/home/qj213/afp-2021-10-22/thys/Shivers-CFA/AbsCFComp.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Shivers-CFA", "problem_names": ["lemma finite_arg_space: \"finite (arg_poss p)\"", "lemma evalV_possible:\n  assumes f: \"f \\<in> \\<aA> d \\<beta> ve\"\n  and d: \"d \\<in> vals p\"\n  and ve: \"ve \\<in> smaps_over (vars p \\<times> UNIV) (proc_poss p)\"\n  and \\<beta>: \"\\<beta> \\<in> maps_over (labels p) UNIV\"\nshows \"f \\<in> proc_poss p\"", "lemma adm_subset: \"cont (\\<lambda>x. f x) \\<Longrightarrow>  adm (\\<lambda>x. f x \\<subseteq> S)\"", "lemma arg_space_complete:\n  \"state \\<in> arg_poss p \\<Longrightarrow> abs_R\\<cdot>state \\<subseteq> arg_poss p\"", "lemma arg_space_complete_ps: \"states \\<subseteq> arg_poss p \\<Longrightarrow> (\\<^ps>abs_R)\\<cdot>states \\<subseteq> arg_poss p\"", "lemma UN_iterate_less: \n  assumes start: \"x \\<in> S\"\n  and step: \"\\<And>y. y\\<subseteq>S \\<Longrightarrow> (f\\<cdot>y) \\<subseteq> S\"\n  shows \"(\\<Union>i. iterate i\\<cdot>f\\<cdot>{x}) \\<subseteq> S\"", "lemma args_finite: \"finite (\\<Union>i. iterate i\\<cdot>(\\<^ps>abs_R)\\<cdot>{initial_r p})\" (is \"finite ?S\")", "lemma Un_commute_helper:\"(a \\<union> b) \\<union> (c \\<union> d) = (a \\<union> c) \\<union> (b \\<union> d)\"", "lemma a_evalF_decomp:\n  \"\\<aF> = fst (sum_to_tup\\<cdot>(fix\\<cdot>(\\<Lambda> f x. (\\<Union>y\\<in>abs_R\\<cdot>x. f\\<cdot>y) \\<union> abs_g\\<cdot>x)))\"", "lemma a_evalF_iterative:\n  \"\\<aF>\\<cdot>(Discr x) = \\<^ps>abs_g\\<cdot>(\\<Union>i. iterate i\\<cdot>(\\<^ps>abs_R)\\<cdot>{Discr (Inl x)})\"", "lemma a_evalCPS_interative:\n\"\\<aPR> prog = \\<^ps>abs_g\\<cdot>(\\<Union>i. iterate i\\<cdot>(\\<^ps>abs_R)\\<cdot>{initial_r prog})\""], "translations": [["", "lemma finite_arg_space: \"finite (arg_poss p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (arg_poss p)", "unfolding arg_poss_def and cstate_poss_def and fstate_poss_def and proc_poss_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     (Discr `\n      ((PC ` (lambdas p \\<times> maps_over (labels p) UNIV) \\<union>\n        PP ` prims p \\<union>\n        {AStop}) \\<times>\n       NList\n        (Pow (PC ` (lambdas p \\<times> maps_over (labels p) UNIV) \\<union>\n              PP ` prims p \\<union>\n              {AStop}))\n        (call_list_lengths p) \\<times>\n       smaps_over (vars p \\<times> UNIV)\n        (PC ` (lambdas p \\<times> maps_over (labels p) UNIV) \\<union>\n         PP ` prims p \\<union>\n         {AStop}) \\<times>\n       UNIV <+>\n       calls p \\<times>\n       maps_over (labels p) UNIV \\<times>\n       smaps_over (vars p \\<times> UNIV)\n        (PC ` (lambdas p \\<times> maps_over (labels p) UNIV) \\<union>\n         PP ` prims p \\<union>\n         {AStop}) \\<times>\n       UNIV))", "by (auto intro!: finite_cartesian_product finite_imageI maps_over_finite smaps_over_finite finite_UNIV finite_Nlist)"], ["", "text \\<open>\nBut is it closed? I.e.\\ if we pass a member of \\<open>arg_poss\\<close> to \\<open>abs_R\\<close>, are the generated recursive call arguments also in \\<open>arg_poss\\<close>? This is shown in \\<open>arg_space_complete\\<close>, after proving an auxiliary result about the possible outcome of a call to \\<open>\\<aA>\\<close> and an admissibility lemma.\n\\<close>"], ["", "lemma evalV_possible:\n  assumes f: \"f \\<in> \\<aA> d \\<beta> ve\"\n  and d: \"d \\<in> vals p\"\n  and ve: \"ve \\<in> smaps_over (vars p \\<times> UNIV) (proc_poss p)\"\n  and \\<beta>: \"\\<beta> \\<in> maps_over (labels p) UNIV\"\nshows \"f \\<in> proc_poss p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<in> proc_poss p", "proof (cases \"(d,\\<beta>,ve)\" rule: evalV_a.cases)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>uu_ i \\<beta>' vea.\n       (d, \\<beta>, ve) = (C uu_ i, \\<beta>', vea) \\<Longrightarrow>\n       f \\<in> proc_poss p\n 2. \\<And>prim \\<beta>' vea.\n       (d, \\<beta>, ve) = (P prim, \\<beta>', vea) \\<Longrightarrow>\n       f \\<in> proc_poss p\n 3. \\<And>uv_ var \\<beta>' vea.\n       (d, \\<beta>, ve) = (R uv_ var, \\<beta>', vea) \\<Longrightarrow>\n       f \\<in> proc_poss p\n 4. \\<And>lam \\<beta>' vea.\n       (d, \\<beta>, ve) = (L lam, \\<beta>', vea) \\<Longrightarrow>\n       f \\<in> proc_poss p", "case (1 cl \\<beta>' ve')"], ["proof (state)\nthis:\n  (d, \\<beta>, ve) = (C cl \\<beta>', ve', ve_)\n\ngoal (4 subgoals):\n 1. \\<And>uu_ i \\<beta>' vea.\n       (d, \\<beta>, ve) = (C uu_ i, \\<beta>', vea) \\<Longrightarrow>\n       f \\<in> proc_poss p\n 2. \\<And>prim \\<beta>' vea.\n       (d, \\<beta>, ve) = (P prim, \\<beta>', vea) \\<Longrightarrow>\n       f \\<in> proc_poss p\n 3. \\<And>uv_ var \\<beta>' vea.\n       (d, \\<beta>, ve) = (R uv_ var, \\<beta>', vea) \\<Longrightarrow>\n       f \\<in> proc_poss p\n 4. \\<And>lam \\<beta>' vea.\n       (d, \\<beta>, ve) = (L lam, \\<beta>', vea) \\<Longrightarrow>\n       f \\<in> proc_poss p", "thus ?thesis"], ["proof (prove)\nusing this:\n  (d, \\<beta>, ve) = (C cl \\<beta>', ve', ve_)\n\ngoal (1 subgoal):\n 1. f \\<in> proc_poss p", "using f"], ["proof (prove)\nusing this:\n  (d, \\<beta>, ve) = (C cl \\<beta>', ve', ve_)\n  f \\<in> \\<aA> d \\<beta> ve\n\ngoal (1 subgoal):\n 1. f \\<in> proc_poss p", "by auto"], ["proof (state)\nthis:\n  f \\<in> proc_poss p\n\ngoal (3 subgoals):\n 1. \\<And>prim \\<beta>' vea.\n       (d, \\<beta>, ve) = (P prim, \\<beta>', vea) \\<Longrightarrow>\n       f \\<in> proc_poss p\n 2. \\<And>uv_ var \\<beta>' vea.\n       (d, \\<beta>, ve) = (R uv_ var, \\<beta>', vea) \\<Longrightarrow>\n       f \\<in> proc_poss p\n 3. \\<And>lam \\<beta>' vea.\n       (d, \\<beta>, ve) = (L lam, \\<beta>', vea) \\<Longrightarrow>\n       f \\<in> proc_poss p", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>prim \\<beta>' vea.\n       (d, \\<beta>, ve) = (P prim, \\<beta>', vea) \\<Longrightarrow>\n       f \\<in> proc_poss p\n 2. \\<And>uv_ var \\<beta>' vea.\n       (d, \\<beta>, ve) = (R uv_ var, \\<beta>', vea) \\<Longrightarrow>\n       f \\<in> proc_poss p\n 3. \\<And>lam \\<beta>' vea.\n       (d, \\<beta>, ve) = (L lam, \\<beta>', vea) \\<Longrightarrow>\n       f \\<in> proc_poss p", "case (2 prim \\<beta>' ve')"], ["proof (state)\nthis:\n  (d, \\<beta>, ve) = (P prim, \\<beta>', ve')\n\ngoal (3 subgoals):\n 1. \\<And>prim \\<beta>' vea.\n       (d, \\<beta>, ve) = (P prim, \\<beta>', vea) \\<Longrightarrow>\n       f \\<in> proc_poss p\n 2. \\<And>uv_ var \\<beta>' vea.\n       (d, \\<beta>, ve) = (R uv_ var, \\<beta>', vea) \\<Longrightarrow>\n       f \\<in> proc_poss p\n 3. \\<And>lam \\<beta>' vea.\n       (d, \\<beta>, ve) = (L lam, \\<beta>', vea) \\<Longrightarrow>\n       f \\<in> proc_poss p", "thus ?thesis"], ["proof (prove)\nusing this:\n  (d, \\<beta>, ve) = (P prim, \\<beta>', ve')\n\ngoal (1 subgoal):\n 1. f \\<in> proc_poss p", "using d f"], ["proof (prove)\nusing this:\n  (d, \\<beta>, ve) = (P prim, \\<beta>', ve')\n  d \\<in> vals p\n  f \\<in> \\<aA> d \\<beta> ve\n\ngoal (1 subgoal):\n 1. f \\<in> proc_poss p", "by (auto dest: vals1 simp add:proc_poss_def)"], ["proof (state)\nthis:\n  f \\<in> proc_poss p\n\ngoal (2 subgoals):\n 1. \\<And>uv_ var \\<beta>' vea.\n       (d, \\<beta>, ve) = (R uv_ var, \\<beta>', vea) \\<Longrightarrow>\n       f \\<in> proc_poss p\n 2. \\<And>lam \\<beta>' vea.\n       (d, \\<beta>, ve) = (L lam, \\<beta>', vea) \\<Longrightarrow>\n       f \\<in> proc_poss p", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>uv_ var \\<beta>' vea.\n       (d, \\<beta>, ve) = (R uv_ var, \\<beta>', vea) \\<Longrightarrow>\n       f \\<in> proc_poss p\n 2. \\<And>lam \\<beta>' vea.\n       (d, \\<beta>, ve) = (L lam, \\<beta>', vea) \\<Longrightarrow>\n       f \\<in> proc_poss p", "case (3 l var \\<beta>' ve')"], ["proof (state)\nthis:\n  (d, \\<beta>, ve) = (R l var, \\<beta>', ve')\n\ngoal (2 subgoals):\n 1. \\<And>uv_ var \\<beta>' vea.\n       (d, \\<beta>, ve) = (R uv_ var, \\<beta>', vea) \\<Longrightarrow>\n       f \\<in> proc_poss p\n 2. \\<And>lam \\<beta>' vea.\n       (d, \\<beta>, ve) = (L lam, \\<beta>', vea) \\<Longrightarrow>\n       f \\<in> proc_poss p", "thus ?thesis"], ["proof (prove)\nusing this:\n  (d, \\<beta>, ve) = (R l var, \\<beta>', ve')\n\ngoal (1 subgoal):\n 1. f \\<in> proc_poss p", "using f d smaps_over_im[OF _ ve]"], ["proof (prove)\nusing this:\n  (d, \\<beta>, ve) = (R l var, \\<beta>', ve')\n  f \\<in> \\<aA> d \\<beta> ve\n  d \\<in> vals p\n  ?f \\<in> ve ?a \\<Longrightarrow> ?f \\<in> proc_poss p\n\ngoal (1 subgoal):\n 1. f \\<in> proc_poss p", "by (auto split:option.split_asm dest: vals2)"], ["proof (state)\nthis:\n  f \\<in> proc_poss p\n\ngoal (1 subgoal):\n 1. \\<And>lam \\<beta>' vea.\n       (d, \\<beta>, ve) = (L lam, \\<beta>', vea) \\<Longrightarrow>\n       f \\<in> proc_poss p", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>lam \\<beta>' vea.\n       (d, \\<beta>, ve) = (L lam, \\<beta>', vea) \\<Longrightarrow>\n       f \\<in> proc_poss p", "case (4 l \\<beta> ve)"], ["proof (state)\nthis:\n  (d, \\<beta>, ve) = (L l, \\<beta>, ve)\n\ngoal (1 subgoal):\n 1. \\<And>lam \\<beta>' vea.\n       (d, \\<beta>, ve) = (L lam, \\<beta>', vea) \\<Longrightarrow>\n       f \\<in> proc_poss p", "thus ?thesis"], ["proof (prove)\nusing this:\n  (d, \\<beta>, ve) = (L l, \\<beta>, ve)\n\ngoal (1 subgoal):\n 1. f \\<in> proc_poss p", "using f d \\<beta>"], ["proof (prove)\nusing this:\n  (d, \\<beta>, ve) = (L l, \\<beta>, ve)\n  f \\<in> \\<aA> d \\<beta> ve\n  d \\<in> vals p\n  \\<beta> \\<in> maps_over (labels p) UNIV\n\ngoal (1 subgoal):\n 1. f \\<in> proc_poss p", "by (auto dest!: vals3 simp add:proc_poss_def)"], ["proof (state)\nthis:\n  f \\<in> proc_poss p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma adm_subset: \"cont (\\<lambda>x. f x) \\<Longrightarrow>  adm (\\<lambda>x. f x \\<subseteq> S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cont f \\<Longrightarrow> adm (\\<lambda>x. f x \\<subseteq> S)", "by (subst sqsubset_is_subset[THEN sym], intro adm_lemmas cont2cont)"], ["", "lemma arg_space_complete:\n  \"state \\<in> arg_poss p \\<Longrightarrow> abs_R\\<cdot>state \\<subseteq> arg_poss p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. state \\<in> arg_poss p \\<Longrightarrow>\n    abs_R\\<cdot>state \\<subseteq> arg_poss p", "proof(induct rule: abs_R.induct[case_names Admissibility Bot Step])"], ["proof (state)\ngoal (3 subgoals):\n 1. adm (\\<lambda>abs_R.\n            state \\<in> arg_poss p \\<longrightarrow>\n            abs_R\\<cdot>state \\<subseteq> arg_poss p)\n 2. state \\<in> arg_poss p \\<Longrightarrow>\n    \\<bottom>\\<cdot>state \\<subseteq> arg_poss p\n 3. \\<And>x.\n       \\<lbrakk>state \\<in> arg_poss p \\<Longrightarrow>\n                x\\<cdot>state \\<subseteq> arg_poss p;\n        state \\<in> arg_poss p\\<rbrakk>\n       \\<Longrightarrow> (\\<Lambda> x.\n                             case undiscr x of\n                             Inl (PC (Lambda lab vs c, \\<beta>), as, ve,\n                                  b) \\<Rightarrow>\n                               if length vs = length as\n                               then let \\<beta>' = \\<beta>(lab \\<mapsto> b);\n  ve' = ve \\<union>. \\<Union>.map2 (\\<lambda>v. smap_singleton (v, b)) vs as\n                                    in {Discr (Inr (c, \\<beta>', ve', b))}\n                               else \\<bottom>\n                             | Inl (PP (Plus c), [], bb) \\<Rightarrow>\n                                 \\<bottom>\n                             | Inl (PP (Plus c), [x], bb) \\<Rightarrow>\n                                 \\<bottom>\n                             | Inl (PP (Plus c), [x, xaa], bb) \\<Rightarrow>\n                                 \\<bottom>\n                             | Inl (PP (Plus c), [x, xaa, cnts], ve,\n                                    b) \\<Rightarrow>\n                                 let b' = \\<anb> b c;\n                                     \\<beta> = [c \\<mapsto> b]\n                                 in \\<Union>cnt\\<in>cnts.\n {Discr (Inl (cnt, [{}], ve, b'))}\n                             | Inl (PP (Plus c),\n                                    x # xaa # cnts # ac # lista,\n                                    bb) \\<Rightarrow>\n                                 \\<bottom>\n                             | Inl (PP (prim.If ct cf), [],\n                                    bb) \\<Rightarrow>\n                                 \\<bottom>\n                             | Inl (PP (prim.If ct cf), [x],\n                                    bb) \\<Rightarrow>\n                                 \\<bottom>\n                             | Inl (PP (prim.If ct cf), [x, cntts],\n                                    bb) \\<Rightarrow>\n                                 \\<bottom>\n                             | Inl (PP (prim.If ct cf), [x, cntts, cntfs],\n                                    ve, b) \\<Rightarrow>\n                                 (let b' = \\<anb> b ct;\n\\<beta> = [ct \\<mapsto> b]\n                                  in \\<Union>cnt\\<in>cntts.\n  {Discr (Inl (cnt, [], ve, b'))}) \\<union>\n                                 (let b' = \\<anb> b cf;\n\\<beta> = [cf \\<mapsto> b]\n                                  in \\<Union>cnt\\<in>cntfs.\n  {Discr (Inl (cnt, [], ve, b'))})\n                             | Inl (PP (prim.If ct cf),\n                                    x # cntts # cntfs # ac # lista,\n                                    bb) \\<Rightarrow>\n                                 \\<bottom>\n                             | Inl (AStop, [], bb) \\<Rightarrow> \\<bottom>\n                             | Inl (AStop, [x], xa, xb) \\<Rightarrow> {}\n                             | Inl (AStop, x # a # lista, bb) \\<Rightarrow>\n                                 \\<bottom>\n                             | Inr (App lab f vs, \\<beta>, ve,\n                                    b) \\<Rightarrow>\n                                 let fs = \\<aA> f \\<beta> ve;\n                                     as =\n map (\\<lambda>v. \\<aA> v \\<beta> ve) vs;\n                                     b' = \\<anb> b lab\n                                 in \\<Union>f'\\<in>fs.\n {Discr (Inl (f', as, ve, b'))}\n                             | Inr (call.Let lab ls c', \\<beta>, ve,\n                                    b) \\<Rightarrow>\n                                 let b' = \\<anb> b lab;\n                                     \\<beta>' = \\<beta>(lab \\<mapsto> b');\n                                     ve' =\n ve \\<union>. \\<Union>.map (\\<lambda>(v, l).\n                               { (v, b') := \\<aA> (L l) \\<beta>' ve}.)\n                        ls\n                                 in {Discr\n(Inr (c', \\<beta>', ve', b'))})\\<cdot>\n                         state\n                         \\<subseteq> arg_poss p", "case Admissibility"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. adm (\\<lambda>abs_R.\n            state \\<in> arg_poss p \\<longrightarrow>\n            abs_R\\<cdot>state \\<subseteq> arg_poss p)\n 2. state \\<in> arg_poss p \\<Longrightarrow>\n    \\<bottom>\\<cdot>state \\<subseteq> arg_poss p\n 3. \\<And>x.\n       \\<lbrakk>state \\<in> arg_poss p \\<Longrightarrow>\n                x\\<cdot>state \\<subseteq> arg_poss p;\n        state \\<in> arg_poss p\\<rbrakk>\n       \\<Longrightarrow> (\\<Lambda> x.\n                             case undiscr x of\n                             Inl (PC (Lambda lab vs c, \\<beta>), as, ve,\n                                  b) \\<Rightarrow>\n                               if length vs = length as\n                               then let \\<beta>' = \\<beta>(lab \\<mapsto> b);\n  ve' = ve \\<union>. \\<Union>.map2 (\\<lambda>v. smap_singleton (v, b)) vs as\n                                    in {Discr (Inr (c, \\<beta>', ve', b))}\n                               else \\<bottom>\n                             | Inl (PP (Plus c), [], bb) \\<Rightarrow>\n                                 \\<bottom>\n                             | Inl (PP (Plus c), [x], bb) \\<Rightarrow>\n                                 \\<bottom>\n                             | Inl (PP (Plus c), [x, xaa], bb) \\<Rightarrow>\n                                 \\<bottom>\n                             | Inl (PP (Plus c), [x, xaa, cnts], ve,\n                                    b) \\<Rightarrow>\n                                 let b' = \\<anb> b c;\n                                     \\<beta> = [c \\<mapsto> b]\n                                 in \\<Union>cnt\\<in>cnts.\n {Discr (Inl (cnt, [{}], ve, b'))}\n                             | Inl (PP (Plus c),\n                                    x # xaa # cnts # ac # lista,\n                                    bb) \\<Rightarrow>\n                                 \\<bottom>\n                             | Inl (PP (prim.If ct cf), [],\n                                    bb) \\<Rightarrow>\n                                 \\<bottom>\n                             | Inl (PP (prim.If ct cf), [x],\n                                    bb) \\<Rightarrow>\n                                 \\<bottom>\n                             | Inl (PP (prim.If ct cf), [x, cntts],\n                                    bb) \\<Rightarrow>\n                                 \\<bottom>\n                             | Inl (PP (prim.If ct cf), [x, cntts, cntfs],\n                                    ve, b) \\<Rightarrow>\n                                 (let b' = \\<anb> b ct;\n\\<beta> = [ct \\<mapsto> b]\n                                  in \\<Union>cnt\\<in>cntts.\n  {Discr (Inl (cnt, [], ve, b'))}) \\<union>\n                                 (let b' = \\<anb> b cf;\n\\<beta> = [cf \\<mapsto> b]\n                                  in \\<Union>cnt\\<in>cntfs.\n  {Discr (Inl (cnt, [], ve, b'))})\n                             | Inl (PP (prim.If ct cf),\n                                    x # cntts # cntfs # ac # lista,\n                                    bb) \\<Rightarrow>\n                                 \\<bottom>\n                             | Inl (AStop, [], bb) \\<Rightarrow> \\<bottom>\n                             | Inl (AStop, [x], xa, xb) \\<Rightarrow> {}\n                             | Inl (AStop, x # a # lista, bb) \\<Rightarrow>\n                                 \\<bottom>\n                             | Inr (App lab f vs, \\<beta>, ve,\n                                    b) \\<Rightarrow>\n                                 let fs = \\<aA> f \\<beta> ve;\n                                     as =\n map (\\<lambda>v. \\<aA> v \\<beta> ve) vs;\n                                     b' = \\<anb> b lab\n                                 in \\<Union>f'\\<in>fs.\n {Discr (Inl (f', as, ve, b'))}\n                             | Inr (call.Let lab ls c', \\<beta>, ve,\n                                    b) \\<Rightarrow>\n                                 let b' = \\<anb> b lab;\n                                     \\<beta>' = \\<beta>(lab \\<mapsto> b');\n                                     ve' =\n ve \\<union>. \\<Union>.map (\\<lambda>(v, l).\n                               { (v, b') := \\<aA> (L l) \\<beta>' ve}.)\n                        ls\n                                 in {Discr\n(Inr (c', \\<beta>', ve', b'))})\\<cdot>\n                         state\n                         \\<subseteq> arg_poss p", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. adm (\\<lambda>abs_R.\n            state \\<in> arg_poss p \\<longrightarrow>\n            abs_R\\<cdot>state \\<subseteq> arg_poss p)", "by (intro adm_lemmas adm_subset cont2cont)"], ["proof (state)\nthis:\n  adm (\\<lambda>abs_R.\n          state \\<in> arg_poss p \\<longrightarrow>\n          abs_R\\<cdot>state \\<subseteq> arg_poss p)\n\ngoal (2 subgoals):\n 1. state \\<in> arg_poss p \\<Longrightarrow>\n    \\<bottom>\\<cdot>state \\<subseteq> arg_poss p\n 2. \\<And>x.\n       \\<lbrakk>state \\<in> arg_poss p \\<Longrightarrow>\n                x\\<cdot>state \\<subseteq> arg_poss p;\n        state \\<in> arg_poss p\\<rbrakk>\n       \\<Longrightarrow> (\\<Lambda> x.\n                             case undiscr x of\n                             Inl (PC (Lambda lab vs c, \\<beta>), as, ve,\n                                  b) \\<Rightarrow>\n                               if length vs = length as\n                               then let \\<beta>' = \\<beta>(lab \\<mapsto> b);\n  ve' = ve \\<union>. \\<Union>.map2 (\\<lambda>v. smap_singleton (v, b)) vs as\n                                    in {Discr (Inr (c, \\<beta>', ve', b))}\n                               else \\<bottom>\n                             | Inl (PP (Plus c), [], bb) \\<Rightarrow>\n                                 \\<bottom>\n                             | Inl (PP (Plus c), [x], bb) \\<Rightarrow>\n                                 \\<bottom>\n                             | Inl (PP (Plus c), [x, xaa], bb) \\<Rightarrow>\n                                 \\<bottom>\n                             | Inl (PP (Plus c), [x, xaa, cnts], ve,\n                                    b) \\<Rightarrow>\n                                 let b' = \\<anb> b c;\n                                     \\<beta> = [c \\<mapsto> b]\n                                 in \\<Union>cnt\\<in>cnts.\n {Discr (Inl (cnt, [{}], ve, b'))}\n                             | Inl (PP (Plus c),\n                                    x # xaa # cnts # ac # lista,\n                                    bb) \\<Rightarrow>\n                                 \\<bottom>\n                             | Inl (PP (prim.If ct cf), [],\n                                    bb) \\<Rightarrow>\n                                 \\<bottom>\n                             | Inl (PP (prim.If ct cf), [x],\n                                    bb) \\<Rightarrow>\n                                 \\<bottom>\n                             | Inl (PP (prim.If ct cf), [x, cntts],\n                                    bb) \\<Rightarrow>\n                                 \\<bottom>\n                             | Inl (PP (prim.If ct cf), [x, cntts, cntfs],\n                                    ve, b) \\<Rightarrow>\n                                 (let b' = \\<anb> b ct;\n\\<beta> = [ct \\<mapsto> b]\n                                  in \\<Union>cnt\\<in>cntts.\n  {Discr (Inl (cnt, [], ve, b'))}) \\<union>\n                                 (let b' = \\<anb> b cf;\n\\<beta> = [cf \\<mapsto> b]\n                                  in \\<Union>cnt\\<in>cntfs.\n  {Discr (Inl (cnt, [], ve, b'))})\n                             | Inl (PP (prim.If ct cf),\n                                    x # cntts # cntfs # ac # lista,\n                                    bb) \\<Rightarrow>\n                                 \\<bottom>\n                             | Inl (AStop, [], bb) \\<Rightarrow> \\<bottom>\n                             | Inl (AStop, [x], xa, xb) \\<Rightarrow> {}\n                             | Inl (AStop, x # a # lista, bb) \\<Rightarrow>\n                                 \\<bottom>\n                             | Inr (App lab f vs, \\<beta>, ve,\n                                    b) \\<Rightarrow>\n                                 let fs = \\<aA> f \\<beta> ve;\n                                     as =\n map (\\<lambda>v. \\<aA> v \\<beta> ve) vs;\n                                     b' = \\<anb> b lab\n                                 in \\<Union>f'\\<in>fs.\n {Discr (Inl (f', as, ve, b'))}\n                             | Inr (call.Let lab ls c', \\<beta>, ve,\n                                    b) \\<Rightarrow>\n                                 let b' = \\<anb> b lab;\n                                     \\<beta>' = \\<beta>(lab \\<mapsto> b');\n                                     ve' =\n ve \\<union>. \\<Union>.map (\\<lambda>(v, l).\n                               { (v, b') := \\<aA> (L l) \\<beta>' ve}.)\n                        ls\n                                 in {Discr\n(Inr (c', \\<beta>', ve', b'))})\\<cdot>\n                         state\n                         \\<subseteq> arg_poss p", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. state \\<in> arg_poss p \\<Longrightarrow>\n    \\<bottom>\\<cdot>state \\<subseteq> arg_poss p\n 2. \\<And>x.\n       \\<lbrakk>state \\<in> arg_poss p \\<Longrightarrow>\n                x\\<cdot>state \\<subseteq> arg_poss p;\n        state \\<in> arg_poss p\\<rbrakk>\n       \\<Longrightarrow> (\\<Lambda> x.\n                             case undiscr x of\n                             Inl (PC (Lambda lab vs c, \\<beta>), as, ve,\n                                  b) \\<Rightarrow>\n                               if length vs = length as\n                               then let \\<beta>' = \\<beta>(lab \\<mapsto> b);\n  ve' = ve \\<union>. \\<Union>.map2 (\\<lambda>v. smap_singleton (v, b)) vs as\n                                    in {Discr (Inr (c, \\<beta>', ve', b))}\n                               else \\<bottom>\n                             | Inl (PP (Plus c), [], bb) \\<Rightarrow>\n                                 \\<bottom>\n                             | Inl (PP (Plus c), [x], bb) \\<Rightarrow>\n                                 \\<bottom>\n                             | Inl (PP (Plus c), [x, xaa], bb) \\<Rightarrow>\n                                 \\<bottom>\n                             | Inl (PP (Plus c), [x, xaa, cnts], ve,\n                                    b) \\<Rightarrow>\n                                 let b' = \\<anb> b c;\n                                     \\<beta> = [c \\<mapsto> b]\n                                 in \\<Union>cnt\\<in>cnts.\n {Discr (Inl (cnt, [{}], ve, b'))}\n                             | Inl (PP (Plus c),\n                                    x # xaa # cnts # ac # lista,\n                                    bb) \\<Rightarrow>\n                                 \\<bottom>\n                             | Inl (PP (prim.If ct cf), [],\n                                    bb) \\<Rightarrow>\n                                 \\<bottom>\n                             | Inl (PP (prim.If ct cf), [x],\n                                    bb) \\<Rightarrow>\n                                 \\<bottom>\n                             | Inl (PP (prim.If ct cf), [x, cntts],\n                                    bb) \\<Rightarrow>\n                                 \\<bottom>\n                             | Inl (PP (prim.If ct cf), [x, cntts, cntfs],\n                                    ve, b) \\<Rightarrow>\n                                 (let b' = \\<anb> b ct;\n\\<beta> = [ct \\<mapsto> b]\n                                  in \\<Union>cnt\\<in>cntts.\n  {Discr (Inl (cnt, [], ve, b'))}) \\<union>\n                                 (let b' = \\<anb> b cf;\n\\<beta> = [cf \\<mapsto> b]\n                                  in \\<Union>cnt\\<in>cntfs.\n  {Discr (Inl (cnt, [], ve, b'))})\n                             | Inl (PP (prim.If ct cf),\n                                    x # cntts # cntfs # ac # lista,\n                                    bb) \\<Rightarrow>\n                                 \\<bottom>\n                             | Inl (AStop, [], bb) \\<Rightarrow> \\<bottom>\n                             | Inl (AStop, [x], xa, xb) \\<Rightarrow> {}\n                             | Inl (AStop, x # a # lista, bb) \\<Rightarrow>\n                                 \\<bottom>\n                             | Inr (App lab f vs, \\<beta>, ve,\n                                    b) \\<Rightarrow>\n                                 let fs = \\<aA> f \\<beta> ve;\n                                     as =\n map (\\<lambda>v. \\<aA> v \\<beta> ve) vs;\n                                     b' = \\<anb> b lab\n                                 in \\<Union>f'\\<in>fs.\n {Discr (Inl (f', as, ve, b'))}\n                             | Inr (call.Let lab ls c', \\<beta>, ve,\n                                    b) \\<Rightarrow>\n                                 let b' = \\<anb> b lab;\n                                     \\<beta>' = \\<beta>(lab \\<mapsto> b');\n                                     ve' =\n ve \\<union>. \\<Union>.map (\\<lambda>(v, l).\n                               { (v, b') := \\<aA> (L l) \\<beta>' ve}.)\n                        ls\n                                 in {Discr\n(Inr (c', \\<beta>', ve', b'))})\\<cdot>\n                         state\n                         \\<subseteq> arg_poss p", "case Bot"], ["proof (state)\nthis:\n  state \\<in> arg_poss p\n\ngoal (2 subgoals):\n 1. state \\<in> arg_poss p \\<Longrightarrow>\n    \\<bottom>\\<cdot>state \\<subseteq> arg_poss p\n 2. \\<And>x.\n       \\<lbrakk>state \\<in> arg_poss p \\<Longrightarrow>\n                x\\<cdot>state \\<subseteq> arg_poss p;\n        state \\<in> arg_poss p\\<rbrakk>\n       \\<Longrightarrow> (\\<Lambda> x.\n                             case undiscr x of\n                             Inl (PC (Lambda lab vs c, \\<beta>), as, ve,\n                                  b) \\<Rightarrow>\n                               if length vs = length as\n                               then let \\<beta>' = \\<beta>(lab \\<mapsto> b);\n  ve' = ve \\<union>. \\<Union>.map2 (\\<lambda>v. smap_singleton (v, b)) vs as\n                                    in {Discr (Inr (c, \\<beta>', ve', b))}\n                               else \\<bottom>\n                             | Inl (PP (Plus c), [], bb) \\<Rightarrow>\n                                 \\<bottom>\n                             | Inl (PP (Plus c), [x], bb) \\<Rightarrow>\n                                 \\<bottom>\n                             | Inl (PP (Plus c), [x, xaa], bb) \\<Rightarrow>\n                                 \\<bottom>\n                             | Inl (PP (Plus c), [x, xaa, cnts], ve,\n                                    b) \\<Rightarrow>\n                                 let b' = \\<anb> b c;\n                                     \\<beta> = [c \\<mapsto> b]\n                                 in \\<Union>cnt\\<in>cnts.\n {Discr (Inl (cnt, [{}], ve, b'))}\n                             | Inl (PP (Plus c),\n                                    x # xaa # cnts # ac # lista,\n                                    bb) \\<Rightarrow>\n                                 \\<bottom>\n                             | Inl (PP (prim.If ct cf), [],\n                                    bb) \\<Rightarrow>\n                                 \\<bottom>\n                             | Inl (PP (prim.If ct cf), [x],\n                                    bb) \\<Rightarrow>\n                                 \\<bottom>\n                             | Inl (PP (prim.If ct cf), [x, cntts],\n                                    bb) \\<Rightarrow>\n                                 \\<bottom>\n                             | Inl (PP (prim.If ct cf), [x, cntts, cntfs],\n                                    ve, b) \\<Rightarrow>\n                                 (let b' = \\<anb> b ct;\n\\<beta> = [ct \\<mapsto> b]\n                                  in \\<Union>cnt\\<in>cntts.\n  {Discr (Inl (cnt, [], ve, b'))}) \\<union>\n                                 (let b' = \\<anb> b cf;\n\\<beta> = [cf \\<mapsto> b]\n                                  in \\<Union>cnt\\<in>cntfs.\n  {Discr (Inl (cnt, [], ve, b'))})\n                             | Inl (PP (prim.If ct cf),\n                                    x # cntts # cntfs # ac # lista,\n                                    bb) \\<Rightarrow>\n                                 \\<bottom>\n                             | Inl (AStop, [], bb) \\<Rightarrow> \\<bottom>\n                             | Inl (AStop, [x], xa, xb) \\<Rightarrow> {}\n                             | Inl (AStop, x # a # lista, bb) \\<Rightarrow>\n                                 \\<bottom>\n                             | Inr (App lab f vs, \\<beta>, ve,\n                                    b) \\<Rightarrow>\n                                 let fs = \\<aA> f \\<beta> ve;\n                                     as =\n map (\\<lambda>v. \\<aA> v \\<beta> ve) vs;\n                                     b' = \\<anb> b lab\n                                 in \\<Union>f'\\<in>fs.\n {Discr (Inl (f', as, ve, b'))}\n                             | Inr (call.Let lab ls c', \\<beta>, ve,\n                                    b) \\<Rightarrow>\n                                 let b' = \\<anb> b lab;\n                                     \\<beta>' = \\<beta>(lab \\<mapsto> b');\n                                     ve' =\n ve \\<union>. \\<Union>.map (\\<lambda>(v, l).\n                               { (v, b') := \\<aA> (L l) \\<beta>' ve}.)\n                        ls\n                                 in {Discr\n(Inr (c', \\<beta>', ve', b'))})\\<cdot>\n                         state\n                         \\<subseteq> arg_poss p", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bottom>\\<cdot>state \\<subseteq> arg_poss p", "by simp"], ["proof (state)\nthis:\n  \\<bottom>\\<cdot>state \\<subseteq> arg_poss p\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>state \\<in> arg_poss p \\<Longrightarrow>\n                x\\<cdot>state \\<subseteq> arg_poss p;\n        state \\<in> arg_poss p\\<rbrakk>\n       \\<Longrightarrow> (\\<Lambda> x.\n                             case undiscr x of\n                             Inl (PC (Lambda lab vs c, \\<beta>), as, ve,\n                                  b) \\<Rightarrow>\n                               if length vs = length as\n                               then let \\<beta>' = \\<beta>(lab \\<mapsto> b);\n  ve' = ve \\<union>. \\<Union>.map2 (\\<lambda>v. smap_singleton (v, b)) vs as\n                                    in {Discr (Inr (c, \\<beta>', ve', b))}\n                               else \\<bottom>\n                             | Inl (PP (Plus c), [], bb) \\<Rightarrow>\n                                 \\<bottom>\n                             | Inl (PP (Plus c), [x], bb) \\<Rightarrow>\n                                 \\<bottom>\n                             | Inl (PP (Plus c), [x, xaa], bb) \\<Rightarrow>\n                                 \\<bottom>\n                             | Inl (PP (Plus c), [x, xaa, cnts], ve,\n                                    b) \\<Rightarrow>\n                                 let b' = \\<anb> b c;\n                                     \\<beta> = [c \\<mapsto> b]\n                                 in \\<Union>cnt\\<in>cnts.\n {Discr (Inl (cnt, [{}], ve, b'))}\n                             | Inl (PP (Plus c),\n                                    x # xaa # cnts # ac # lista,\n                                    bb) \\<Rightarrow>\n                                 \\<bottom>\n                             | Inl (PP (prim.If ct cf), [],\n                                    bb) \\<Rightarrow>\n                                 \\<bottom>\n                             | Inl (PP (prim.If ct cf), [x],\n                                    bb) \\<Rightarrow>\n                                 \\<bottom>\n                             | Inl (PP (prim.If ct cf), [x, cntts],\n                                    bb) \\<Rightarrow>\n                                 \\<bottom>\n                             | Inl (PP (prim.If ct cf), [x, cntts, cntfs],\n                                    ve, b) \\<Rightarrow>\n                                 (let b' = \\<anb> b ct;\n\\<beta> = [ct \\<mapsto> b]\n                                  in \\<Union>cnt\\<in>cntts.\n  {Discr (Inl (cnt, [], ve, b'))}) \\<union>\n                                 (let b' = \\<anb> b cf;\n\\<beta> = [cf \\<mapsto> b]\n                                  in \\<Union>cnt\\<in>cntfs.\n  {Discr (Inl (cnt, [], ve, b'))})\n                             | Inl (PP (prim.If ct cf),\n                                    x # cntts # cntfs # ac # lista,\n                                    bb) \\<Rightarrow>\n                                 \\<bottom>\n                             | Inl (AStop, [], bb) \\<Rightarrow> \\<bottom>\n                             | Inl (AStop, [x], xa, xb) \\<Rightarrow> {}\n                             | Inl (AStop, x # a # lista, bb) \\<Rightarrow>\n                                 \\<bottom>\n                             | Inr (App lab f vs, \\<beta>, ve,\n                                    b) \\<Rightarrow>\n                                 let fs = \\<aA> f \\<beta> ve;\n                                     as =\n map (\\<lambda>v. \\<aA> v \\<beta> ve) vs;\n                                     b' = \\<anb> b lab\n                                 in \\<Union>f'\\<in>fs.\n {Discr (Inl (f', as, ve, b'))}\n                             | Inr (call.Let lab ls c', \\<beta>, ve,\n                                    b) \\<Rightarrow>\n                                 let b' = \\<anb> b lab;\n                                     \\<beta>' = \\<beta>(lab \\<mapsto> b');\n                                     ve' =\n ve \\<union>. \\<Union>.map (\\<lambda>(v, l).\n                               { (v, b') := \\<aA> (L l) \\<beta>' ve}.)\n                        ls\n                                 in {Discr\n(Inr (c', \\<beta>', ve', b'))})\\<cdot>\n                         state\n                         \\<subseteq> arg_poss p", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>state \\<in> arg_poss p \\<Longrightarrow>\n                x\\<cdot>state \\<subseteq> arg_poss p;\n        state \\<in> arg_poss p\\<rbrakk>\n       \\<Longrightarrow> (\\<Lambda> x.\n                             case undiscr x of\n                             Inl (PC (Lambda lab vs c, \\<beta>), as, ve,\n                                  b) \\<Rightarrow>\n                               if length vs = length as\n                               then let \\<beta>' = \\<beta>(lab \\<mapsto> b);\n  ve' = ve \\<union>. \\<Union>.map2 (\\<lambda>v. smap_singleton (v, b)) vs as\n                                    in {Discr (Inr (c, \\<beta>', ve', b))}\n                               else \\<bottom>\n                             | Inl (PP (Plus c), [], bb) \\<Rightarrow>\n                                 \\<bottom>\n                             | Inl (PP (Plus c), [x], bb) \\<Rightarrow>\n                                 \\<bottom>\n                             | Inl (PP (Plus c), [x, xaa], bb) \\<Rightarrow>\n                                 \\<bottom>\n                             | Inl (PP (Plus c), [x, xaa, cnts], ve,\n                                    b) \\<Rightarrow>\n                                 let b' = \\<anb> b c;\n                                     \\<beta> = [c \\<mapsto> b]\n                                 in \\<Union>cnt\\<in>cnts.\n {Discr (Inl (cnt, [{}], ve, b'))}\n                             | Inl (PP (Plus c),\n                                    x # xaa # cnts # ac # lista,\n                                    bb) \\<Rightarrow>\n                                 \\<bottom>\n                             | Inl (PP (prim.If ct cf), [],\n                                    bb) \\<Rightarrow>\n                                 \\<bottom>\n                             | Inl (PP (prim.If ct cf), [x],\n                                    bb) \\<Rightarrow>\n                                 \\<bottom>\n                             | Inl (PP (prim.If ct cf), [x, cntts],\n                                    bb) \\<Rightarrow>\n                                 \\<bottom>\n                             | Inl (PP (prim.If ct cf), [x, cntts, cntfs],\n                                    ve, b) \\<Rightarrow>\n                                 (let b' = \\<anb> b ct;\n\\<beta> = [ct \\<mapsto> b]\n                                  in \\<Union>cnt\\<in>cntts.\n  {Discr (Inl (cnt, [], ve, b'))}) \\<union>\n                                 (let b' = \\<anb> b cf;\n\\<beta> = [cf \\<mapsto> b]\n                                  in \\<Union>cnt\\<in>cntfs.\n  {Discr (Inl (cnt, [], ve, b'))})\n                             | Inl (PP (prim.If ct cf),\n                                    x # cntts # cntfs # ac # lista,\n                                    bb) \\<Rightarrow>\n                                 \\<bottom>\n                             | Inl (AStop, [], bb) \\<Rightarrow> \\<bottom>\n                             | Inl (AStop, [x], xa, xb) \\<Rightarrow> {}\n                             | Inl (AStop, x # a # lista, bb) \\<Rightarrow>\n                                 \\<bottom>\n                             | Inr (App lab f vs, \\<beta>, ve,\n                                    b) \\<Rightarrow>\n                                 let fs = \\<aA> f \\<beta> ve;\n                                     as =\n map (\\<lambda>v. \\<aA> v \\<beta> ve) vs;\n                                     b' = \\<anb> b lab\n                                 in \\<Union>f'\\<in>fs.\n {Discr (Inl (f', as, ve, b'))}\n                             | Inr (call.Let lab ls c', \\<beta>, ve,\n                                    b) \\<Rightarrow>\n                                 let b' = \\<anb> b lab;\n                                     \\<beta>' = \\<beta>(lab \\<mapsto> b');\n                                     ve' =\n ve \\<union>. \\<Union>.map (\\<lambda>(v, l).\n                               { (v, b') := \\<aA> (L l) \\<beta>' ve}.)\n                        ls\n                                 in {Discr\n(Inr (c', \\<beta>', ve', b'))})\\<cdot>\n                         state\n                         \\<subseteq> arg_poss p", "case (Step abs_R)"], ["proof (state)\nthis:\n  state \\<in> arg_poss p \\<Longrightarrow>\n  abs_R\\<cdot>state \\<subseteq> arg_poss p\n  state \\<in> arg_poss p\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>state \\<in> arg_poss p \\<Longrightarrow>\n                x\\<cdot>state \\<subseteq> arg_poss p;\n        state \\<in> arg_poss p\\<rbrakk>\n       \\<Longrightarrow> (\\<Lambda> x.\n                             case undiscr x of\n                             Inl (PC (Lambda lab vs c, \\<beta>), as, ve,\n                                  b) \\<Rightarrow>\n                               if length vs = length as\n                               then let \\<beta>' = \\<beta>(lab \\<mapsto> b);\n  ve' = ve \\<union>. \\<Union>.map2 (\\<lambda>v. smap_singleton (v, b)) vs as\n                                    in {Discr (Inr (c, \\<beta>', ve', b))}\n                               else \\<bottom>\n                             | Inl (PP (Plus c), [], bb) \\<Rightarrow>\n                                 \\<bottom>\n                             | Inl (PP (Plus c), [x], bb) \\<Rightarrow>\n                                 \\<bottom>\n                             | Inl (PP (Plus c), [x, xaa], bb) \\<Rightarrow>\n                                 \\<bottom>\n                             | Inl (PP (Plus c), [x, xaa, cnts], ve,\n                                    b) \\<Rightarrow>\n                                 let b' = \\<anb> b c;\n                                     \\<beta> = [c \\<mapsto> b]\n                                 in \\<Union>cnt\\<in>cnts.\n {Discr (Inl (cnt, [{}], ve, b'))}\n                             | Inl (PP (Plus c),\n                                    x # xaa # cnts # ac # lista,\n                                    bb) \\<Rightarrow>\n                                 \\<bottom>\n                             | Inl (PP (prim.If ct cf), [],\n                                    bb) \\<Rightarrow>\n                                 \\<bottom>\n                             | Inl (PP (prim.If ct cf), [x],\n                                    bb) \\<Rightarrow>\n                                 \\<bottom>\n                             | Inl (PP (prim.If ct cf), [x, cntts],\n                                    bb) \\<Rightarrow>\n                                 \\<bottom>\n                             | Inl (PP (prim.If ct cf), [x, cntts, cntfs],\n                                    ve, b) \\<Rightarrow>\n                                 (let b' = \\<anb> b ct;\n\\<beta> = [ct \\<mapsto> b]\n                                  in \\<Union>cnt\\<in>cntts.\n  {Discr (Inl (cnt, [], ve, b'))}) \\<union>\n                                 (let b' = \\<anb> b cf;\n\\<beta> = [cf \\<mapsto> b]\n                                  in \\<Union>cnt\\<in>cntfs.\n  {Discr (Inl (cnt, [], ve, b'))})\n                             | Inl (PP (prim.If ct cf),\n                                    x # cntts # cntfs # ac # lista,\n                                    bb) \\<Rightarrow>\n                                 \\<bottom>\n                             | Inl (AStop, [], bb) \\<Rightarrow> \\<bottom>\n                             | Inl (AStop, [x], xa, xb) \\<Rightarrow> {}\n                             | Inl (AStop, x # a # lista, bb) \\<Rightarrow>\n                                 \\<bottom>\n                             | Inr (App lab f vs, \\<beta>, ve,\n                                    b) \\<Rightarrow>\n                                 let fs = \\<aA> f \\<beta> ve;\n                                     as =\n map (\\<lambda>v. \\<aA> v \\<beta> ve) vs;\n                                     b' = \\<anb> b lab\n                                 in \\<Union>f'\\<in>fs.\n {Discr (Inl (f', as, ve, b'))}\n                             | Inr (call.Let lab ls c', \\<beta>, ve,\n                                    b) \\<Rightarrow>\n                                 let b' = \\<anb> b lab;\n                                     \\<beta>' = \\<beta>(lab \\<mapsto> b');\n                                     ve' =\n ve \\<union>. \\<Union>.map (\\<lambda>(v, l).\n                               { (v, b') := \\<aA> (L l) \\<beta>' ve}.)\n                        ls\n                                 in {Discr\n(Inr (c', \\<beta>', ve', b'))})\\<cdot>\n                         state\n                         \\<subseteq> arg_poss p", "note state = Step(2)"], ["proof (state)\nthis:\n  state \\<in> arg_poss p\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>state \\<in> arg_poss p \\<Longrightarrow>\n                x\\<cdot>state \\<subseteq> arg_poss p;\n        state \\<in> arg_poss p\\<rbrakk>\n       \\<Longrightarrow> (\\<Lambda> x.\n                             case undiscr x of\n                             Inl (PC (Lambda lab vs c, \\<beta>), as, ve,\n                                  b) \\<Rightarrow>\n                               if length vs = length as\n                               then let \\<beta>' = \\<beta>(lab \\<mapsto> b);\n  ve' = ve \\<union>. \\<Union>.map2 (\\<lambda>v. smap_singleton (v, b)) vs as\n                                    in {Discr (Inr (c, \\<beta>', ve', b))}\n                               else \\<bottom>\n                             | Inl (PP (Plus c), [], bb) \\<Rightarrow>\n                                 \\<bottom>\n                             | Inl (PP (Plus c), [x], bb) \\<Rightarrow>\n                                 \\<bottom>\n                             | Inl (PP (Plus c), [x, xaa], bb) \\<Rightarrow>\n                                 \\<bottom>\n                             | Inl (PP (Plus c), [x, xaa, cnts], ve,\n                                    b) \\<Rightarrow>\n                                 let b' = \\<anb> b c;\n                                     \\<beta> = [c \\<mapsto> b]\n                                 in \\<Union>cnt\\<in>cnts.\n {Discr (Inl (cnt, [{}], ve, b'))}\n                             | Inl (PP (Plus c),\n                                    x # xaa # cnts # ac # lista,\n                                    bb) \\<Rightarrow>\n                                 \\<bottom>\n                             | Inl (PP (prim.If ct cf), [],\n                                    bb) \\<Rightarrow>\n                                 \\<bottom>\n                             | Inl (PP (prim.If ct cf), [x],\n                                    bb) \\<Rightarrow>\n                                 \\<bottom>\n                             | Inl (PP (prim.If ct cf), [x, cntts],\n                                    bb) \\<Rightarrow>\n                                 \\<bottom>\n                             | Inl (PP (prim.If ct cf), [x, cntts, cntfs],\n                                    ve, b) \\<Rightarrow>\n                                 (let b' = \\<anb> b ct;\n\\<beta> = [ct \\<mapsto> b]\n                                  in \\<Union>cnt\\<in>cntts.\n  {Discr (Inl (cnt, [], ve, b'))}) \\<union>\n                                 (let b' = \\<anb> b cf;\n\\<beta> = [cf \\<mapsto> b]\n                                  in \\<Union>cnt\\<in>cntfs.\n  {Discr (Inl (cnt, [], ve, b'))})\n                             | Inl (PP (prim.If ct cf),\n                                    x # cntts # cntfs # ac # lista,\n                                    bb) \\<Rightarrow>\n                                 \\<bottom>\n                             | Inl (AStop, [], bb) \\<Rightarrow> \\<bottom>\n                             | Inl (AStop, [x], xa, xb) \\<Rightarrow> {}\n                             | Inl (AStop, x # a # lista, bb) \\<Rightarrow>\n                                 \\<bottom>\n                             | Inr (App lab f vs, \\<beta>, ve,\n                                    b) \\<Rightarrow>\n                                 let fs = \\<aA> f \\<beta> ve;\n                                     as =\n map (\\<lambda>v. \\<aA> v \\<beta> ve) vs;\n                                     b' = \\<anb> b lab\n                                 in \\<Union>f'\\<in>fs.\n {Discr (Inl (f', as, ve, b'))}\n                             | Inr (call.Let lab ls c', \\<beta>, ve,\n                                    b) \\<Rightarrow>\n                                 let b' = \\<anb> b lab;\n                                     \\<beta>' = \\<beta>(lab \\<mapsto> b');\n                                     ve' =\n ve \\<union>. \\<Union>.map (\\<lambda>(v, l).\n                               { (v, b') := \\<aA> (L l) \\<beta>' ve}.)\n                        ls\n                                 in {Discr\n(Inr (c', \\<beta>', ve', b'))})\\<cdot>\n                         state\n                         \\<subseteq> arg_poss p", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Lambda> x.\n        case undiscr x of\n        Inl (PC (Lambda lab vs c, \\<beta>), as, ve, b) \\<Rightarrow>\n          if length vs = length as\n          then let \\<beta>' = \\<beta>(lab \\<mapsto> b);\n                   ve' =\n                     ve \\<union>. \\<Union>.map2\n      (\\<lambda>v. smap_singleton (v, b)) vs as\n               in {Discr (Inr (c, \\<beta>', ve', b))}\n          else \\<bottom>\n        | Inl (PP (Plus c), [], bb) \\<Rightarrow> \\<bottom>\n        | Inl (PP (Plus c), [x], bb) \\<Rightarrow> \\<bottom>\n        | Inl (PP (Plus c), [x, xa], bb) \\<Rightarrow> \\<bottom>\n        | Inl (PP (Plus c), [x, xa, cnts], ve, b) \\<Rightarrow>\n            let b' = \\<anb> b c; \\<beta> = [c \\<mapsto> b]\n            in \\<Union>cnt\\<in>cnts. {Discr (Inl (cnt, [{}], ve, b'))}\n        | Inl (PP (Plus c), x # xa # cnts # ac # lista, bb) \\<Rightarrow>\n            \\<bottom>\n        | Inl (PP (prim.If ct cf), [], bb) \\<Rightarrow> \\<bottom>\n        | Inl (PP (prim.If ct cf), [x], bb) \\<Rightarrow> \\<bottom>\n        | Inl (PP (prim.If ct cf), [x, cntts], bb) \\<Rightarrow> \\<bottom>\n        | Inl (PP (prim.If ct cf), [x, cntts, cntfs], ve, b) \\<Rightarrow>\n            (let b' = \\<anb> b ct; \\<beta> = [ct \\<mapsto> b]\n             in \\<Union>cnt\\<in>cntts.\n                   {Discr (Inl (cnt, [], ve, b'))}) \\<union>\n            (let b' = \\<anb> b cf; \\<beta> = [cf \\<mapsto> b]\n             in \\<Union>cnt\\<in>cntfs. {Discr (Inl (cnt, [], ve, b'))})\n        | Inl (PP (prim.If ct cf), x # cntts # cntfs # ac # lista,\n               bb) \\<Rightarrow>\n            \\<bottom>\n        | Inl (AStop, [], bb) \\<Rightarrow> \\<bottom>\n        | Inl (AStop, [x], xa, xb) \\<Rightarrow> {}\n        | Inl (AStop, x # a # lista, bb) \\<Rightarrow> \\<bottom>\n        | Inr (App lab f vs, \\<beta>, ve, b) \\<Rightarrow>\n            let fs = \\<aA> f \\<beta> ve;\n                as = map (\\<lambda>v. \\<aA> v \\<beta> ve) vs;\n                b' = \\<anb> b lab\n            in \\<Union>f'\\<in>fs. {Discr (Inl (f', as, ve, b'))}\n        | Inr (call.Let lab ls c', \\<beta>, ve, b) \\<Rightarrow>\n            let b' = \\<anb> b lab; \\<beta>' = \\<beta>(lab \\<mapsto> b');\n                ve' =\n                  ve \\<union>. \\<Union>.map\n   (\\<lambda>(v, l). { (v, b') := \\<aA> (L l) \\<beta>' ve}.) ls\n            in {Discr (Inr (c', \\<beta>', ve', b'))})\\<cdot>\n    state\n    \\<subseteq> arg_poss p", "proof (cases state)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       state = Discr x \\<Longrightarrow>\n       (\\<Lambda> x.\n           case undiscr x of\n           Inl (PC (Lambda lab vs c, \\<beta>), as, ve, b) \\<Rightarrow>\n             if length vs = length as\n             then let \\<beta>' = \\<beta>(lab \\<mapsto> b);\n                      ve' =\n                        ve \\<union>. \\<Union>.map2\n         (\\<lambda>v. smap_singleton (v, b)) vs as\n                  in {Discr (Inr (c, \\<beta>', ve', b))}\n             else \\<bottom>\n           | Inl (PP (Plus c), [], bb) \\<Rightarrow> \\<bottom>\n           | Inl (PP (Plus c), [x], bb) \\<Rightarrow> \\<bottom>\n           | Inl (PP (Plus c), [x, xa], bb) \\<Rightarrow> \\<bottom>\n           | Inl (PP (Plus c), [x, xa, cnts], ve, b) \\<Rightarrow>\n               let b' = \\<anb> b c; \\<beta> = [c \\<mapsto> b]\n               in \\<Union>cnt\\<in>cnts. {Discr (Inl (cnt, [{}], ve, b'))}\n           | Inl (PP (Plus c), x # xa # cnts # ac # lista, bb) \\<Rightarrow>\n               \\<bottom>\n           | Inl (PP (prim.If ct cf), [], bb) \\<Rightarrow> \\<bottom>\n           | Inl (PP (prim.If ct cf), [x], bb) \\<Rightarrow> \\<bottom>\n           | Inl (PP (prim.If ct cf), [x, cntts], bb) \\<Rightarrow>\n               \\<bottom>\n           | Inl (PP (prim.If ct cf), [x, cntts, cntfs], ve,\n                  b) \\<Rightarrow>\n               (let b' = \\<anb> b ct; \\<beta> = [ct \\<mapsto> b]\n                in \\<Union>cnt\\<in>cntts.\n                      {Discr (Inl (cnt, [], ve, b'))}) \\<union>\n               (let b' = \\<anb> b cf; \\<beta> = [cf \\<mapsto> b]\n                in \\<Union>cnt\\<in>cntfs. {Discr (Inl (cnt, [], ve, b'))})\n           | Inl (PP (prim.If ct cf), x # cntts # cntfs # ac # lista,\n                  bb) \\<Rightarrow>\n               \\<bottom>\n           | Inl (AStop, [], bb) \\<Rightarrow> \\<bottom>\n           | Inl (AStop, [x], xa, xb) \\<Rightarrow> {}\n           | Inl (AStop, x # a # lista, bb) \\<Rightarrow> \\<bottom>\n           | Inr (App lab f vs, \\<beta>, ve, b) \\<Rightarrow>\n               let fs = \\<aA> f \\<beta> ve;\n                   as = map (\\<lambda>v. \\<aA> v \\<beta> ve) vs;\n                   b' = \\<anb> b lab\n               in \\<Union>f'\\<in>fs. {Discr (Inl (f', as, ve, b'))}\n           | Inr (call.Let lab ls c', \\<beta>, ve, b) \\<Rightarrow>\n               let b' = \\<anb> b lab; \\<beta>' = \\<beta>(lab \\<mapsto> b');\n                   ve' =\n                     ve \\<union>. \\<Union>.map\n      (\\<lambda>(v, l). { (v, b') := \\<aA> (L l) \\<beta>' ve}.) ls\n               in {Discr (Inr (c', \\<beta>', ve', b'))})\\<cdot>\n       state\n       \\<subseteq> arg_poss p", "case (Discr state')"], ["proof (state)\nthis:\n  state = Discr state'\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       state = Discr x \\<Longrightarrow>\n       (\\<Lambda> x.\n           case undiscr x of\n           Inl (PC (Lambda lab vs c, \\<beta>), as, ve, b) \\<Rightarrow>\n             if length vs = length as\n             then let \\<beta>' = \\<beta>(lab \\<mapsto> b);\n                      ve' =\n                        ve \\<union>. \\<Union>.map2\n         (\\<lambda>v. smap_singleton (v, b)) vs as\n                  in {Discr (Inr (c, \\<beta>', ve', b))}\n             else \\<bottom>\n           | Inl (PP (Plus c), [], bb) \\<Rightarrow> \\<bottom>\n           | Inl (PP (Plus c), [x], bb) \\<Rightarrow> \\<bottom>\n           | Inl (PP (Plus c), [x, xa], bb) \\<Rightarrow> \\<bottom>\n           | Inl (PP (Plus c), [x, xa, cnts], ve, b) \\<Rightarrow>\n               let b' = \\<anb> b c; \\<beta> = [c \\<mapsto> b]\n               in \\<Union>cnt\\<in>cnts. {Discr (Inl (cnt, [{}], ve, b'))}\n           | Inl (PP (Plus c), x # xa # cnts # ac # lista, bb) \\<Rightarrow>\n               \\<bottom>\n           | Inl (PP (prim.If ct cf), [], bb) \\<Rightarrow> \\<bottom>\n           | Inl (PP (prim.If ct cf), [x], bb) \\<Rightarrow> \\<bottom>\n           | Inl (PP (prim.If ct cf), [x, cntts], bb) \\<Rightarrow>\n               \\<bottom>\n           | Inl (PP (prim.If ct cf), [x, cntts, cntfs], ve,\n                  b) \\<Rightarrow>\n               (let b' = \\<anb> b ct; \\<beta> = [ct \\<mapsto> b]\n                in \\<Union>cnt\\<in>cntts.\n                      {Discr (Inl (cnt, [], ve, b'))}) \\<union>\n               (let b' = \\<anb> b cf; \\<beta> = [cf \\<mapsto> b]\n                in \\<Union>cnt\\<in>cntfs. {Discr (Inl (cnt, [], ve, b'))})\n           | Inl (PP (prim.If ct cf), x # cntts # cntfs # ac # lista,\n                  bb) \\<Rightarrow>\n               \\<bottom>\n           | Inl (AStop, [], bb) \\<Rightarrow> \\<bottom>\n           | Inl (AStop, [x], xa, xb) \\<Rightarrow> {}\n           | Inl (AStop, x # a # lista, bb) \\<Rightarrow> \\<bottom>\n           | Inr (App lab f vs, \\<beta>, ve, b) \\<Rightarrow>\n               let fs = \\<aA> f \\<beta> ve;\n                   as = map (\\<lambda>v. \\<aA> v \\<beta> ve) vs;\n                   b' = \\<anb> b lab\n               in \\<Union>f'\\<in>fs. {Discr (Inl (f', as, ve, b'))}\n           | Inr (call.Let lab ls c', \\<beta>, ve, b) \\<Rightarrow>\n               let b' = \\<anb> b lab; \\<beta>' = \\<beta>(lab \\<mapsto> b');\n                   ve' =\n                     ve \\<union>. \\<Union>.map\n      (\\<lambda>(v, l). { (v, b') := \\<aA> (L l) \\<beta>' ve}.) ls\n               in {Discr (Inr (c', \\<beta>', ve', b'))})\\<cdot>\n       state\n       \\<subseteq> arg_poss p", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Lambda> x.\n        case undiscr x of\n        Inl (PC (Lambda lab vs c, \\<beta>), as, ve, b) \\<Rightarrow>\n          if length vs = length as\n          then let \\<beta>' = \\<beta>(lab \\<mapsto> b);\n                   ve' =\n                     ve \\<union>. \\<Union>.map2\n      (\\<lambda>v. smap_singleton (v, b)) vs as\n               in {Discr (Inr (c, \\<beta>', ve', b))}\n          else \\<bottom>\n        | Inl (PP (Plus c), [], bb) \\<Rightarrow> \\<bottom>\n        | Inl (PP (Plus c), [x], bb) \\<Rightarrow> \\<bottom>\n        | Inl (PP (Plus c), [x, xa], bb) \\<Rightarrow> \\<bottom>\n        | Inl (PP (Plus c), [x, xa, cnts], ve, b) \\<Rightarrow>\n            let b' = \\<anb> b c; \\<beta> = [c \\<mapsto> b]\n            in \\<Union>cnt\\<in>cnts. {Discr (Inl (cnt, [{}], ve, b'))}\n        | Inl (PP (Plus c), x # xa # cnts # ac # lista, bb) \\<Rightarrow>\n            \\<bottom>\n        | Inl (PP (prim.If ct cf), [], bb) \\<Rightarrow> \\<bottom>\n        | Inl (PP (prim.If ct cf), [x], bb) \\<Rightarrow> \\<bottom>\n        | Inl (PP (prim.If ct cf), [x, cntts], bb) \\<Rightarrow> \\<bottom>\n        | Inl (PP (prim.If ct cf), [x, cntts, cntfs], ve, b) \\<Rightarrow>\n            (let b' = \\<anb> b ct; \\<beta> = [ct \\<mapsto> b]\n             in \\<Union>cnt\\<in>cntts.\n                   {Discr (Inl (cnt, [], ve, b'))}) \\<union>\n            (let b' = \\<anb> b cf; \\<beta> = [cf \\<mapsto> b]\n             in \\<Union>cnt\\<in>cntfs. {Discr (Inl (cnt, [], ve, b'))})\n        | Inl (PP (prim.If ct cf), x # cntts # cntfs # ac # lista,\n               bb) \\<Rightarrow>\n            \\<bottom>\n        | Inl (AStop, [], bb) \\<Rightarrow> \\<bottom>\n        | Inl (AStop, [x], xa, xb) \\<Rightarrow> {}\n        | Inl (AStop, x # a # lista, bb) \\<Rightarrow> \\<bottom>\n        | Inr (App lab f vs, \\<beta>, ve, b) \\<Rightarrow>\n            let fs = \\<aA> f \\<beta> ve;\n                as = map (\\<lambda>v. \\<aA> v \\<beta> ve) vs;\n                b' = \\<anb> b lab\n            in \\<Union>f'\\<in>fs. {Discr (Inl (f', as, ve, b'))}\n        | Inr (call.Let lab ls c', \\<beta>, ve, b) \\<Rightarrow>\n            let b' = \\<anb> b lab; \\<beta>' = \\<beta>(lab \\<mapsto> b');\n                ve' =\n                  ve \\<union>. \\<Union>.map\n   (\\<lambda>(v, l). { (v, b') := \\<aA> (L l) \\<beta>' ve}.) ls\n            in {Discr (Inr (c', \\<beta>', ve', b'))})\\<cdot>\n    state\n    \\<subseteq> arg_poss p", "proof (cases state')"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a.\n       state' = Inl a \\<Longrightarrow>\n       (\\<Lambda> x.\n           case undiscr x of\n           Inl (PC (Lambda lab vs c, \\<beta>), as, ve, b) \\<Rightarrow>\n             if length vs = length as\n             then let \\<beta>' = \\<beta>(lab \\<mapsto> b);\n                      ve' =\n                        ve \\<union>. \\<Union>.map2\n         (\\<lambda>v. smap_singleton (v, b)) vs as\n                  in {Discr (Inr (c, \\<beta>', ve', b))}\n             else \\<bottom>\n           | Inl (PP (Plus c), [], bb) \\<Rightarrow> \\<bottom>\n           | Inl (PP (Plus c), [x], bb) \\<Rightarrow> \\<bottom>\n           | Inl (PP (Plus c), [x, xa], bb) \\<Rightarrow> \\<bottom>\n           | Inl (PP (Plus c), [x, xa, cnts], ve, b) \\<Rightarrow>\n               let b' = \\<anb> b c; \\<beta> = [c \\<mapsto> b]\n               in \\<Union>cnt\\<in>cnts. {Discr (Inl (cnt, [{}], ve, b'))}\n           | Inl (PP (Plus c), x # xa # cnts # ac # lista, bb) \\<Rightarrow>\n               \\<bottom>\n           | Inl (PP (prim.If ct cf), [], bb) \\<Rightarrow> \\<bottom>\n           | Inl (PP (prim.If ct cf), [x], bb) \\<Rightarrow> \\<bottom>\n           | Inl (PP (prim.If ct cf), [x, cntts], bb) \\<Rightarrow>\n               \\<bottom>\n           | Inl (PP (prim.If ct cf), [x, cntts, cntfs], ve,\n                  b) \\<Rightarrow>\n               (let b' = \\<anb> b ct; \\<beta> = [ct \\<mapsto> b]\n                in \\<Union>cnt\\<in>cntts.\n                      {Discr (Inl (cnt, [], ve, b'))}) \\<union>\n               (let b' = \\<anb> b cf; \\<beta> = [cf \\<mapsto> b]\n                in \\<Union>cnt\\<in>cntfs. {Discr (Inl (cnt, [], ve, b'))})\n           | Inl (PP (prim.If ct cf), x # cntts # cntfs # ac # lista,\n                  bb) \\<Rightarrow>\n               \\<bottom>\n           | Inl (AStop, [], bb) \\<Rightarrow> \\<bottom>\n           | Inl (AStop, [x], xa, xb) \\<Rightarrow> {}\n           | Inl (AStop, x # a # lista, bb) \\<Rightarrow> \\<bottom>\n           | Inr (App lab f vs, \\<beta>, ve, b) \\<Rightarrow>\n               let fs = \\<aA> f \\<beta> ve;\n                   as = map (\\<lambda>v. \\<aA> v \\<beta> ve) vs;\n                   b' = \\<anb> b lab\n               in \\<Union>f'\\<in>fs. {Discr (Inl (f', as, ve, b'))}\n           | Inr (call.Let lab ls c', \\<beta>, ve, b) \\<Rightarrow>\n               let b' = \\<anb> b lab; \\<beta>' = \\<beta>(lab \\<mapsto> b');\n                   ve' =\n                     ve \\<union>. \\<Union>.map\n      (\\<lambda>(v, l). { (v, b') := \\<aA> (L l) \\<beta>' ve}.) ls\n               in {Discr (Inr (c', \\<beta>', ve', b'))})\\<cdot>\n       state\n       \\<subseteq> arg_poss p\n 2. \\<And>b.\n       state' = Inr b \\<Longrightarrow>\n       (\\<Lambda> x.\n           case undiscr x of\n           Inl (PC (Lambda lab vs c, \\<beta>), as, ve, b) \\<Rightarrow>\n             if length vs = length as\n             then let \\<beta>' = \\<beta>(lab \\<mapsto> b);\n                      ve' =\n                        ve \\<union>. \\<Union>.map2\n         (\\<lambda>v. smap_singleton (v, b)) vs as\n                  in {Discr (Inr (c, \\<beta>', ve', b))}\n             else \\<bottom>\n           | Inl (PP (Plus c), [], bb) \\<Rightarrow> \\<bottom>\n           | Inl (PP (Plus c), [x], bb) \\<Rightarrow> \\<bottom>\n           | Inl (PP (Plus c), [x, xa], bb) \\<Rightarrow> \\<bottom>\n           | Inl (PP (Plus c), [x, xa, cnts], ve, b) \\<Rightarrow>\n               let b' = \\<anb> b c; \\<beta> = [c \\<mapsto> b]\n               in \\<Union>cnt\\<in>cnts. {Discr (Inl (cnt, [{}], ve, b'))}\n           | Inl (PP (Plus c), x # xa # cnts # ac # lista, bb) \\<Rightarrow>\n               \\<bottom>\n           | Inl (PP (prim.If ct cf), [], bb) \\<Rightarrow> \\<bottom>\n           | Inl (PP (prim.If ct cf), [x], bb) \\<Rightarrow> \\<bottom>\n           | Inl (PP (prim.If ct cf), [x, cntts], bb) \\<Rightarrow>\n               \\<bottom>\n           | Inl (PP (prim.If ct cf), [x, cntts, cntfs], ve,\n                  b) \\<Rightarrow>\n               (let b' = \\<anb> b ct; \\<beta> = [ct \\<mapsto> b]\n                in \\<Union>cnt\\<in>cntts.\n                      {Discr (Inl (cnt, [], ve, b'))}) \\<union>\n               (let b' = \\<anb> b cf; \\<beta> = [cf \\<mapsto> b]\n                in \\<Union>cnt\\<in>cntfs. {Discr (Inl (cnt, [], ve, b'))})\n           | Inl (PP (prim.If ct cf), x # cntts # cntfs # ac # lista,\n                  bb) \\<Rightarrow>\n               \\<bottom>\n           | Inl (AStop, [], bb) \\<Rightarrow> \\<bottom>\n           | Inl (AStop, [x], xa, xb) \\<Rightarrow> {}\n           | Inl (AStop, x # a # lista, bb) \\<Rightarrow> \\<bottom>\n           | Inr (App lab f vs, \\<beta>, ve, b) \\<Rightarrow>\n               let fs = \\<aA> f \\<beta> ve;\n                   as = map (\\<lambda>v. \\<aA> v \\<beta> ve) vs;\n                   b' = \\<anb> b lab\n               in \\<Union>f'\\<in>fs. {Discr (Inl (f', as, ve, b'))}\n           | Inr (call.Let lab ls c', \\<beta>, ve, b) \\<Rightarrow>\n               let b' = \\<anb> b lab; \\<beta>' = \\<beta>(lab \\<mapsto> b');\n                   ve' =\n                     ve \\<union>. \\<Union>.map\n      (\\<lambda>(v, l). { (v, b') := \\<aA> (L l) \\<beta>' ve}.) ls\n               in {Discr (Inr (c', \\<beta>', ve', b'))})\\<cdot>\n       state\n       \\<subseteq> arg_poss p", "case (Inl fstate)"], ["proof (state)\nthis:\n  state' = Inl fstate\n\ngoal (2 subgoals):\n 1. \\<And>a.\n       state' = Inl a \\<Longrightarrow>\n       (\\<Lambda> x.\n           case undiscr x of\n           Inl (PC (Lambda lab vs c, \\<beta>), as, ve, b) \\<Rightarrow>\n             if length vs = length as\n             then let \\<beta>' = \\<beta>(lab \\<mapsto> b);\n                      ve' =\n                        ve \\<union>. \\<Union>.map2\n         (\\<lambda>v. smap_singleton (v, b)) vs as\n                  in {Discr (Inr (c, \\<beta>', ve', b))}\n             else \\<bottom>\n           | Inl (PP (Plus c), [], bb) \\<Rightarrow> \\<bottom>\n           | Inl (PP (Plus c), [x], bb) \\<Rightarrow> \\<bottom>\n           | Inl (PP (Plus c), [x, xa], bb) \\<Rightarrow> \\<bottom>\n           | Inl (PP (Plus c), [x, xa, cnts], ve, b) \\<Rightarrow>\n               let b' = \\<anb> b c; \\<beta> = [c \\<mapsto> b]\n               in \\<Union>cnt\\<in>cnts. {Discr (Inl (cnt, [{}], ve, b'))}\n           | Inl (PP (Plus c), x # xa # cnts # ac # lista, bb) \\<Rightarrow>\n               \\<bottom>\n           | Inl (PP (prim.If ct cf), [], bb) \\<Rightarrow> \\<bottom>\n           | Inl (PP (prim.If ct cf), [x], bb) \\<Rightarrow> \\<bottom>\n           | Inl (PP (prim.If ct cf), [x, cntts], bb) \\<Rightarrow>\n               \\<bottom>\n           | Inl (PP (prim.If ct cf), [x, cntts, cntfs], ve,\n                  b) \\<Rightarrow>\n               (let b' = \\<anb> b ct; \\<beta> = [ct \\<mapsto> b]\n                in \\<Union>cnt\\<in>cntts.\n                      {Discr (Inl (cnt, [], ve, b'))}) \\<union>\n               (let b' = \\<anb> b cf; \\<beta> = [cf \\<mapsto> b]\n                in \\<Union>cnt\\<in>cntfs. {Discr (Inl (cnt, [], ve, b'))})\n           | Inl (PP (prim.If ct cf), x # cntts # cntfs # ac # lista,\n                  bb) \\<Rightarrow>\n               \\<bottom>\n           | Inl (AStop, [], bb) \\<Rightarrow> \\<bottom>\n           | Inl (AStop, [x], xa, xb) \\<Rightarrow> {}\n           | Inl (AStop, x # a # lista, bb) \\<Rightarrow> \\<bottom>\n           | Inr (App lab f vs, \\<beta>, ve, b) \\<Rightarrow>\n               let fs = \\<aA> f \\<beta> ve;\n                   as = map (\\<lambda>v. \\<aA> v \\<beta> ve) vs;\n                   b' = \\<anb> b lab\n               in \\<Union>f'\\<in>fs. {Discr (Inl (f', as, ve, b'))}\n           | Inr (call.Let lab ls c', \\<beta>, ve, b) \\<Rightarrow>\n               let b' = \\<anb> b lab; \\<beta>' = \\<beta>(lab \\<mapsto> b');\n                   ve' =\n                     ve \\<union>. \\<Union>.map\n      (\\<lambda>(v, l). { (v, b') := \\<aA> (L l) \\<beta>' ve}.) ls\n               in {Discr (Inr (c', \\<beta>', ve', b'))})\\<cdot>\n       state\n       \\<subseteq> arg_poss p\n 2. \\<And>b.\n       state' = Inr b \\<Longrightarrow>\n       (\\<Lambda> x.\n           case undiscr x of\n           Inl (PC (Lambda lab vs c, \\<beta>), as, ve, b) \\<Rightarrow>\n             if length vs = length as\n             then let \\<beta>' = \\<beta>(lab \\<mapsto> b);\n                      ve' =\n                        ve \\<union>. \\<Union>.map2\n         (\\<lambda>v. smap_singleton (v, b)) vs as\n                  in {Discr (Inr (c, \\<beta>', ve', b))}\n             else \\<bottom>\n           | Inl (PP (Plus c), [], bb) \\<Rightarrow> \\<bottom>\n           | Inl (PP (Plus c), [x], bb) \\<Rightarrow> \\<bottom>\n           | Inl (PP (Plus c), [x, xa], bb) \\<Rightarrow> \\<bottom>\n           | Inl (PP (Plus c), [x, xa, cnts], ve, b) \\<Rightarrow>\n               let b' = \\<anb> b c; \\<beta> = [c \\<mapsto> b]\n               in \\<Union>cnt\\<in>cnts. {Discr (Inl (cnt, [{}], ve, b'))}\n           | Inl (PP (Plus c), x # xa # cnts # ac # lista, bb) \\<Rightarrow>\n               \\<bottom>\n           | Inl (PP (prim.If ct cf), [], bb) \\<Rightarrow> \\<bottom>\n           | Inl (PP (prim.If ct cf), [x], bb) \\<Rightarrow> \\<bottom>\n           | Inl (PP (prim.If ct cf), [x, cntts], bb) \\<Rightarrow>\n               \\<bottom>\n           | Inl (PP (prim.If ct cf), [x, cntts, cntfs], ve,\n                  b) \\<Rightarrow>\n               (let b' = \\<anb> b ct; \\<beta> = [ct \\<mapsto> b]\n                in \\<Union>cnt\\<in>cntts.\n                      {Discr (Inl (cnt, [], ve, b'))}) \\<union>\n               (let b' = \\<anb> b cf; \\<beta> = [cf \\<mapsto> b]\n                in \\<Union>cnt\\<in>cntfs. {Discr (Inl (cnt, [], ve, b'))})\n           | Inl (PP (prim.If ct cf), x # cntts # cntfs # ac # lista,\n                  bb) \\<Rightarrow>\n               \\<bottom>\n           | Inl (AStop, [], bb) \\<Rightarrow> \\<bottom>\n           | Inl (AStop, [x], xa, xb) \\<Rightarrow> {}\n           | Inl (AStop, x # a # lista, bb) \\<Rightarrow> \\<bottom>\n           | Inr (App lab f vs, \\<beta>, ve, b) \\<Rightarrow>\n               let fs = \\<aA> f \\<beta> ve;\n                   as = map (\\<lambda>v. \\<aA> v \\<beta> ve) vs;\n                   b' = \\<anb> b lab\n               in \\<Union>f'\\<in>fs. {Discr (Inl (f', as, ve, b'))}\n           | Inr (call.Let lab ls c', \\<beta>, ve, b) \\<Rightarrow>\n               let b' = \\<anb> b lab; \\<beta>' = \\<beta>(lab \\<mapsto> b');\n                   ve' =\n                     ve \\<union>. \\<Union>.map\n      (\\<lambda>(v, l). { (v, b') := \\<aA> (L l) \\<beta>' ve}.) ls\n               in {Discr (Inr (c', \\<beta>', ve', b'))})\\<cdot>\n       state\n       \\<subseteq> arg_poss p", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Lambda> x.\n        case undiscr x of\n        Inl (PC (Lambda lab vs c, \\<beta>), as, ve, b) \\<Rightarrow>\n          if length vs = length as\n          then let \\<beta>' = \\<beta>(lab \\<mapsto> b);\n                   ve' =\n                     ve \\<union>. \\<Union>.map2\n      (\\<lambda>v. smap_singleton (v, b)) vs as\n               in {Discr (Inr (c, \\<beta>', ve', b))}\n          else \\<bottom>\n        | Inl (PP (Plus c), [], bb) \\<Rightarrow> \\<bottom>\n        | Inl (PP (Plus c), [x], bb) \\<Rightarrow> \\<bottom>\n        | Inl (PP (Plus c), [x, xa], bb) \\<Rightarrow> \\<bottom>\n        | Inl (PP (Plus c), [x, xa, cnts], ve, b) \\<Rightarrow>\n            let b' = \\<anb> b c; \\<beta> = [c \\<mapsto> b]\n            in \\<Union>cnt\\<in>cnts. {Discr (Inl (cnt, [{}], ve, b'))}\n        | Inl (PP (Plus c), x # xa # cnts # ac # lista, bb) \\<Rightarrow>\n            \\<bottom>\n        | Inl (PP (prim.If ct cf), [], bb) \\<Rightarrow> \\<bottom>\n        | Inl (PP (prim.If ct cf), [x], bb) \\<Rightarrow> \\<bottom>\n        | Inl (PP (prim.If ct cf), [x, cntts], bb) \\<Rightarrow> \\<bottom>\n        | Inl (PP (prim.If ct cf), [x, cntts, cntfs], ve, b) \\<Rightarrow>\n            (let b' = \\<anb> b ct; \\<beta> = [ct \\<mapsto> b]\n             in \\<Union>cnt\\<in>cntts.\n                   {Discr (Inl (cnt, [], ve, b'))}) \\<union>\n            (let b' = \\<anb> b cf; \\<beta> = [cf \\<mapsto> b]\n             in \\<Union>cnt\\<in>cntfs. {Discr (Inl (cnt, [], ve, b'))})\n        | Inl (PP (prim.If ct cf), x # cntts # cntfs # ac # lista,\n               bb) \\<Rightarrow>\n            \\<bottom>\n        | Inl (AStop, [], bb) \\<Rightarrow> \\<bottom>\n        | Inl (AStop, [x], xa, xb) \\<Rightarrow> {}\n        | Inl (AStop, x # a # lista, bb) \\<Rightarrow> \\<bottom>\n        | Inr (App lab f vs, \\<beta>, ve, b) \\<Rightarrow>\n            let fs = \\<aA> f \\<beta> ve;\n                as = map (\\<lambda>v. \\<aA> v \\<beta> ve) vs;\n                b' = \\<anb> b lab\n            in \\<Union>f'\\<in>fs. {Discr (Inl (f', as, ve, b'))}\n        | Inr (call.Let lab ls c', \\<beta>, ve, b) \\<Rightarrow>\n            let b' = \\<anb> b lab; \\<beta>' = \\<beta>(lab \\<mapsto> b');\n                ve' =\n                  ve \\<union>. \\<Union>.map\n   (\\<lambda>(v, l). { (v, b') := \\<aA> (L l) \\<beta>' ve}.) ls\n            in {Discr (Inr (c', \\<beta>', ve', b'))})\\<cdot>\n    state\n    \\<subseteq> arg_poss p", "using Inl Discr state"], ["proof (prove)\nusing this:\n  state' = Inl fstate\n  state = Discr state'\n  state \\<in> arg_poss p\n\ngoal (1 subgoal):\n 1. (\\<Lambda> x.\n        case undiscr x of\n        Inl (PC (Lambda lab vs c, \\<beta>), as, ve, b) \\<Rightarrow>\n          if length vs = length as\n          then let \\<beta>' = \\<beta>(lab \\<mapsto> b);\n                   ve' =\n                     ve \\<union>. \\<Union>.map2\n      (\\<lambda>v. smap_singleton (v, b)) vs as\n               in {Discr (Inr (c, \\<beta>', ve', b))}\n          else \\<bottom>\n        | Inl (PP (Plus c), [], bb) \\<Rightarrow> \\<bottom>\n        | Inl (PP (Plus c), [x], bb) \\<Rightarrow> \\<bottom>\n        | Inl (PP (Plus c), [x, xa], bb) \\<Rightarrow> \\<bottom>\n        | Inl (PP (Plus c), [x, xa, cnts], ve, b) \\<Rightarrow>\n            let b' = \\<anb> b c; \\<beta> = [c \\<mapsto> b]\n            in \\<Union>cnt\\<in>cnts. {Discr (Inl (cnt, [{}], ve, b'))}\n        | Inl (PP (Plus c), x # xa # cnts # ac # lista, bb) \\<Rightarrow>\n            \\<bottom>\n        | Inl (PP (prim.If ct cf), [], bb) \\<Rightarrow> \\<bottom>\n        | Inl (PP (prim.If ct cf), [x], bb) \\<Rightarrow> \\<bottom>\n        | Inl (PP (prim.If ct cf), [x, cntts], bb) \\<Rightarrow> \\<bottom>\n        | Inl (PP (prim.If ct cf), [x, cntts, cntfs], ve, b) \\<Rightarrow>\n            (let b' = \\<anb> b ct; \\<beta> = [ct \\<mapsto> b]\n             in \\<Union>cnt\\<in>cntts.\n                   {Discr (Inl (cnt, [], ve, b'))}) \\<union>\n            (let b' = \\<anb> b cf; \\<beta> = [cf \\<mapsto> b]\n             in \\<Union>cnt\\<in>cntfs. {Discr (Inl (cnt, [], ve, b'))})\n        | Inl (PP (prim.If ct cf), x # cntts # cntfs # ac # lista,\n               bb) \\<Rightarrow>\n            \\<bottom>\n        | Inl (AStop, [], bb) \\<Rightarrow> \\<bottom>\n        | Inl (AStop, [x], xa, xb) \\<Rightarrow> {}\n        | Inl (AStop, x # a # lista, bb) \\<Rightarrow> \\<bottom>\n        | Inr (App lab f vs, \\<beta>, ve, b) \\<Rightarrow>\n            let fs = \\<aA> f \\<beta> ve;\n                as = map (\\<lambda>v. \\<aA> v \\<beta> ve) vs;\n                b' = \\<anb> b lab\n            in \\<Union>f'\\<in>fs. {Discr (Inl (f', as, ve, b'))}\n        | Inr (call.Let lab ls c', \\<beta>, ve, b) \\<Rightarrow>\n            let b' = \\<anb> b lab; \\<beta>' = \\<beta>(lab \\<mapsto> b');\n                ve' =\n                  ve \\<union>. \\<Union>.map\n   (\\<lambda>(v, l). { (v, b') := \\<aA> (L l) \\<beta>' ve}.) ls\n            in {Discr (Inr (c', \\<beta>', ve', b'))})\\<cdot>\n    state\n    \\<subseteq> arg_poss p", "proof (cases fstate rule: a_fstate_case, auto)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>b c d x2 x1aa x2a x3.\n       \\<lbrakk>Discr (Inl (PC (Lambda x1aa x2a x3, x2), b, c, d))\n                \\<in> arg_poss p;\n        fstate = (PC (Lambda x1aa x2a x3, x2), b, c, d);\n        length x2a = length b;\n        state' = Inl (PC (Lambda x1aa x2a x3, x2), b, c, d);\n        state = Discr (Inl (PC (Lambda x1aa x2a x3, x2), b, c, d))\\<rbrakk>\n       \\<Longrightarrow> Discr\n                          (Inr (x3, x2(x1aa \\<mapsto> d),\n                                c \\<union>. \\<Union>.map2\n                (\\<lambda>v. smap_singleton (v, d)) x2a b,\n                                d))\n                         \\<in> arg_poss p\n 2. \\<And>c d x1 x21 x21a x21b cnt.\n       \\<lbrakk>Discr (Inl (PP (Plus x1), [x21, x21a, x21b], c, d))\n                \\<in> arg_poss p;\n        fstate = (PP (Plus x1), [x21, x21a, x21b], c, d);\n        state' = Inl (PP (Plus x1), [x21, x21a, x21b], c, d);\n        state = Discr (Inl (PP (Plus x1), [x21, x21a, x21b], c, d));\n        cnt \\<in> x21b\\<rbrakk>\n       \\<Longrightarrow> Discr (Inl (cnt, [{}], c, \\<anb> d x1))\n                         \\<in> arg_poss p\n 3. \\<And>c d x21 x22 x21a x21aa x21b cnt.\n       \\<lbrakk>Discr\n                 (Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d))\n                \\<in> arg_poss p;\n        fstate = (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d);\n        state' = Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d);\n        state =\n        Discr (Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d));\n        cnt \\<in> x21aa\\<rbrakk>\n       \\<Longrightarrow> Discr (Inl (cnt, [], c, \\<anb> d x21))\n                         \\<in> arg_poss p\n 4. \\<And>c d x21 x22 x21a x21aa x21b cnt.\n       \\<lbrakk>Discr\n                 (Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d))\n                \\<in> arg_poss p;\n        fstate = (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d);\n        state' = Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d);\n        state =\n        Discr (Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d));\n        cnt \\<in> x21b\\<rbrakk>\n       \\<Longrightarrow> Discr (Inl (cnt, [], c, \\<anb> d x22))\n                         \\<in> arg_poss p", "txt \\<open>Case Lambda\\<close>"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>b c d x2 x1aa x2a x3.\n       \\<lbrakk>Discr (Inl (PC (Lambda x1aa x2a x3, x2), b, c, d))\n                \\<in> arg_poss p;\n        fstate = (PC (Lambda x1aa x2a x3, x2), b, c, d);\n        length x2a = length b;\n        state' = Inl (PC (Lambda x1aa x2a x3, x2), b, c, d);\n        state = Discr (Inl (PC (Lambda x1aa x2a x3, x2), b, c, d))\\<rbrakk>\n       \\<Longrightarrow> Discr\n                          (Inr (x3, x2(x1aa \\<mapsto> d),\n                                c \\<union>. \\<Union>.map2\n                (\\<lambda>v. smap_singleton (v, d)) x2a b,\n                                d))\n                         \\<in> arg_poss p\n 2. \\<And>c d x1 x21 x21a x21b cnt.\n       \\<lbrakk>Discr (Inl (PP (Plus x1), [x21, x21a, x21b], c, d))\n                \\<in> arg_poss p;\n        fstate = (PP (Plus x1), [x21, x21a, x21b], c, d);\n        state' = Inl (PP (Plus x1), [x21, x21a, x21b], c, d);\n        state = Discr (Inl (PP (Plus x1), [x21, x21a, x21b], c, d));\n        cnt \\<in> x21b\\<rbrakk>\n       \\<Longrightarrow> Discr (Inl (cnt, [{}], c, \\<anb> d x1))\n                         \\<in> arg_poss p\n 3. \\<And>c d x21 x22 x21a x21aa x21b cnt.\n       \\<lbrakk>Discr\n                 (Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d))\n                \\<in> arg_poss p;\n        fstate = (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d);\n        state' = Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d);\n        state =\n        Discr (Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d));\n        cnt \\<in> x21aa\\<rbrakk>\n       \\<Longrightarrow> Discr (Inl (cnt, [], c, \\<anb> d x21))\n                         \\<in> arg_poss p\n 4. \\<And>c d x21 x22 x21a x21aa x21b cnt.\n       \\<lbrakk>Discr\n                 (Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d))\n                \\<in> arg_poss p;\n        fstate = (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d);\n        state' = Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d);\n        state =\n        Discr (Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d));\n        cnt \\<in> x21b\\<rbrakk>\n       \\<Longrightarrow> Discr (Inl (cnt, [], c, \\<anb> d x22))\n                         \\<in> arg_poss p", "fix l vs c \\<beta> as ve b"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>b c d x2 x1aa x2a x3.\n       \\<lbrakk>Discr (Inl (PC (Lambda x1aa x2a x3, x2), b, c, d))\n                \\<in> arg_poss p;\n        fstate = (PC (Lambda x1aa x2a x3, x2), b, c, d);\n        length x2a = length b;\n        state' = Inl (PC (Lambda x1aa x2a x3, x2), b, c, d);\n        state = Discr (Inl (PC (Lambda x1aa x2a x3, x2), b, c, d))\\<rbrakk>\n       \\<Longrightarrow> Discr\n                          (Inr (x3, x2(x1aa \\<mapsto> d),\n                                c \\<union>. \\<Union>.map2\n                (\\<lambda>v. smap_singleton (v, d)) x2a b,\n                                d))\n                         \\<in> arg_poss p\n 2. \\<And>c d x1 x21 x21a x21b cnt.\n       \\<lbrakk>Discr (Inl (PP (Plus x1), [x21, x21a, x21b], c, d))\n                \\<in> arg_poss p;\n        fstate = (PP (Plus x1), [x21, x21a, x21b], c, d);\n        state' = Inl (PP (Plus x1), [x21, x21a, x21b], c, d);\n        state = Discr (Inl (PP (Plus x1), [x21, x21a, x21b], c, d));\n        cnt \\<in> x21b\\<rbrakk>\n       \\<Longrightarrow> Discr (Inl (cnt, [{}], c, \\<anb> d x1))\n                         \\<in> arg_poss p\n 3. \\<And>c d x21 x22 x21a x21aa x21b cnt.\n       \\<lbrakk>Discr\n                 (Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d))\n                \\<in> arg_poss p;\n        fstate = (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d);\n        state' = Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d);\n        state =\n        Discr (Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d));\n        cnt \\<in> x21aa\\<rbrakk>\n       \\<Longrightarrow> Discr (Inl (cnt, [], c, \\<anb> d x21))\n                         \\<in> arg_poss p\n 4. \\<And>c d x21 x22 x21a x21aa x21b cnt.\n       \\<lbrakk>Discr\n                 (Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d))\n                \\<in> arg_poss p;\n        fstate = (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d);\n        state' = Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d);\n        state =\n        Discr (Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d));\n        cnt \\<in> x21b\\<rbrakk>\n       \\<Longrightarrow> Discr (Inl (cnt, [], c, \\<anb> d x22))\n                         \\<in> arg_poss p", "assume \"Discr (Inl (PC (Lambda l vs c, \\<beta>), as, ve, b)) \\<in> arg_poss p\""], ["proof (state)\nthis:\n  Discr (Inl (PC (Lambda l vs c, \\<beta>), as, ve, b)) \\<in> arg_poss p\n\ngoal (4 subgoals):\n 1. \\<And>b c d x2 x1aa x2a x3.\n       \\<lbrakk>Discr (Inl (PC (Lambda x1aa x2a x3, x2), b, c, d))\n                \\<in> arg_poss p;\n        fstate = (PC (Lambda x1aa x2a x3, x2), b, c, d);\n        length x2a = length b;\n        state' = Inl (PC (Lambda x1aa x2a x3, x2), b, c, d);\n        state = Discr (Inl (PC (Lambda x1aa x2a x3, x2), b, c, d))\\<rbrakk>\n       \\<Longrightarrow> Discr\n                          (Inr (x3, x2(x1aa \\<mapsto> d),\n                                c \\<union>. \\<Union>.map2\n                (\\<lambda>v. smap_singleton (v, d)) x2a b,\n                                d))\n                         \\<in> arg_poss p\n 2. \\<And>c d x1 x21 x21a x21b cnt.\n       \\<lbrakk>Discr (Inl (PP (Plus x1), [x21, x21a, x21b], c, d))\n                \\<in> arg_poss p;\n        fstate = (PP (Plus x1), [x21, x21a, x21b], c, d);\n        state' = Inl (PP (Plus x1), [x21, x21a, x21b], c, d);\n        state = Discr (Inl (PP (Plus x1), [x21, x21a, x21b], c, d));\n        cnt \\<in> x21b\\<rbrakk>\n       \\<Longrightarrow> Discr (Inl (cnt, [{}], c, \\<anb> d x1))\n                         \\<in> arg_poss p\n 3. \\<And>c d x21 x22 x21a x21aa x21b cnt.\n       \\<lbrakk>Discr\n                 (Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d))\n                \\<in> arg_poss p;\n        fstate = (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d);\n        state' = Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d);\n        state =\n        Discr (Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d));\n        cnt \\<in> x21aa\\<rbrakk>\n       \\<Longrightarrow> Discr (Inl (cnt, [], c, \\<anb> d x21))\n                         \\<in> arg_poss p\n 4. \\<And>c d x21 x22 x21a x21aa x21b cnt.\n       \\<lbrakk>Discr\n                 (Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d))\n                \\<in> arg_poss p;\n        fstate = (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d);\n        state' = Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d);\n        state =\n        Discr (Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d));\n        cnt \\<in> x21b\\<rbrakk>\n       \\<Longrightarrow> Discr (Inl (cnt, [], c, \\<anb> d x22))\n                         \\<in> arg_poss p", "hence lam: \"Lambda l vs c \\<in> lambdas p\"\n       and  beta: \"\\<beta> \\<in> maps_over (labels p) UNIV \"\n       and  ve: \"ve \\<in> smaps_over (vars p \\<times> UNIV) (proc_poss p)\"\n       and  as: \"as \\<in> NList (Pow (proc_poss p)) (call_list_lengths p)\""], ["proof (prove)\nusing this:\n  Discr (Inl (PC (Lambda l vs c, \\<beta>), as, ve, b)) \\<in> arg_poss p\n\ngoal (1 subgoal):\n 1. (Lambda l vs c \\<in> lambdas p &&&\n     \\<beta> \\<in> maps_over (labels p) UNIV) &&&\n    ve \\<in> smaps_over (vars p \\<times> UNIV) (proc_poss p) &&&\n    as \\<in> NList (Pow (proc_poss p)) (call_list_lengths p)", "unfolding arg_poss_def fstate_poss_def proc_poss_def"], ["proof (prove)\nusing this:\n  Discr (Inl (PC (Lambda l vs c, \\<beta>), as, ve, b))\n  \\<in> Discr `\n        ((PC ` (lambdas p \\<times> maps_over (labels p) UNIV) \\<union>\n          PP ` prims p \\<union>\n          {AStop}) \\<times>\n         NList\n          (Pow (PC ` (lambdas p \\<times> maps_over (labels p) UNIV) \\<union>\n                PP ` prims p \\<union>\n                {AStop}))\n          (call_list_lengths p) \\<times>\n         smaps_over (vars p \\<times> UNIV)\n          (PC ` (lambdas p \\<times> maps_over (labels p) UNIV) \\<union>\n           PP ` prims p \\<union>\n           {AStop}) \\<times>\n         UNIV <+>\n         cstate_poss p)\n\ngoal (1 subgoal):\n 1. (Lambda l vs c \\<in> lambdas p &&&\n     \\<beta> \\<in> maps_over (labels p) UNIV) &&&\n    ve \\<in> smaps_over (vars p \\<times> UNIV)\n              (PC ` (lambdas p \\<times> maps_over (labels p) UNIV) \\<union>\n               PP ` prims p \\<union>\n               {AStop}) &&&\n    as \\<in> NList\n              (Pow (PC `\n                    (lambdas p \\<times> maps_over (labels p) UNIV) \\<union>\n                    PP ` prims p \\<union>\n                    {AStop}))\n              (call_list_lengths p)", "by auto"], ["proof (state)\nthis:\n  Lambda l vs c \\<in> lambdas p\n  \\<beta> \\<in> maps_over (labels p) UNIV\n  ve \\<in> smaps_over (vars p \\<times> UNIV) (proc_poss p)\n  as \\<in> NList (Pow (proc_poss p)) (call_list_lengths p)\n\ngoal (4 subgoals):\n 1. \\<And>b c d x2 x1aa x2a x3.\n       \\<lbrakk>Discr (Inl (PC (Lambda x1aa x2a x3, x2), b, c, d))\n                \\<in> arg_poss p;\n        fstate = (PC (Lambda x1aa x2a x3, x2), b, c, d);\n        length x2a = length b;\n        state' = Inl (PC (Lambda x1aa x2a x3, x2), b, c, d);\n        state = Discr (Inl (PC (Lambda x1aa x2a x3, x2), b, c, d))\\<rbrakk>\n       \\<Longrightarrow> Discr\n                          (Inr (x3, x2(x1aa \\<mapsto> d),\n                                c \\<union>. \\<Union>.map2\n                (\\<lambda>v. smap_singleton (v, d)) x2a b,\n                                d))\n                         \\<in> arg_poss p\n 2. \\<And>c d x1 x21 x21a x21b cnt.\n       \\<lbrakk>Discr (Inl (PP (Plus x1), [x21, x21a, x21b], c, d))\n                \\<in> arg_poss p;\n        fstate = (PP (Plus x1), [x21, x21a, x21b], c, d);\n        state' = Inl (PP (Plus x1), [x21, x21a, x21b], c, d);\n        state = Discr (Inl (PP (Plus x1), [x21, x21a, x21b], c, d));\n        cnt \\<in> x21b\\<rbrakk>\n       \\<Longrightarrow> Discr (Inl (cnt, [{}], c, \\<anb> d x1))\n                         \\<in> arg_poss p\n 3. \\<And>c d x21 x22 x21a x21aa x21b cnt.\n       \\<lbrakk>Discr\n                 (Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d))\n                \\<in> arg_poss p;\n        fstate = (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d);\n        state' = Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d);\n        state =\n        Discr (Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d));\n        cnt \\<in> x21aa\\<rbrakk>\n       \\<Longrightarrow> Discr (Inl (cnt, [], c, \\<anb> d x21))\n                         \\<in> arg_poss p\n 4. \\<And>c d x21 x22 x21a x21aa x21b cnt.\n       \\<lbrakk>Discr\n                 (Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d))\n                \\<in> arg_poss p;\n        fstate = (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d);\n        state' = Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d);\n        state =\n        Discr (Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d));\n        cnt \\<in> x21b\\<rbrakk>\n       \\<Longrightarrow> Discr (Inl (cnt, [], c, \\<anb> d x22))\n                         \\<in> arg_poss p", "from lam"], ["proof (chain)\npicking this:\n  Lambda l vs c \\<in> lambdas p", "have \"c \\<in> calls p\""], ["proof (prove)\nusing this:\n  Lambda l vs c \\<in> lambdas p\n\ngoal (1 subgoal):\n 1. c \\<in> calls p", "by (rule lambdas1)"], ["proof (state)\nthis:\n  c \\<in> calls p\n\ngoal (4 subgoals):\n 1. \\<And>b c d x2 x1aa x2a x3.\n       \\<lbrakk>Discr (Inl (PC (Lambda x1aa x2a x3, x2), b, c, d))\n                \\<in> arg_poss p;\n        fstate = (PC (Lambda x1aa x2a x3, x2), b, c, d);\n        length x2a = length b;\n        state' = Inl (PC (Lambda x1aa x2a x3, x2), b, c, d);\n        state = Discr (Inl (PC (Lambda x1aa x2a x3, x2), b, c, d))\\<rbrakk>\n       \\<Longrightarrow> Discr\n                          (Inr (x3, x2(x1aa \\<mapsto> d),\n                                c \\<union>. \\<Union>.map2\n                (\\<lambda>v. smap_singleton (v, d)) x2a b,\n                                d))\n                         \\<in> arg_poss p\n 2. \\<And>c d x1 x21 x21a x21b cnt.\n       \\<lbrakk>Discr (Inl (PP (Plus x1), [x21, x21a, x21b], c, d))\n                \\<in> arg_poss p;\n        fstate = (PP (Plus x1), [x21, x21a, x21b], c, d);\n        state' = Inl (PP (Plus x1), [x21, x21a, x21b], c, d);\n        state = Discr (Inl (PP (Plus x1), [x21, x21a, x21b], c, d));\n        cnt \\<in> x21b\\<rbrakk>\n       \\<Longrightarrow> Discr (Inl (cnt, [{}], c, \\<anb> d x1))\n                         \\<in> arg_poss p\n 3. \\<And>c d x21 x22 x21a x21aa x21b cnt.\n       \\<lbrakk>Discr\n                 (Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d))\n                \\<in> arg_poss p;\n        fstate = (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d);\n        state' = Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d);\n        state =\n        Discr (Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d));\n        cnt \\<in> x21aa\\<rbrakk>\n       \\<Longrightarrow> Discr (Inl (cnt, [], c, \\<anb> d x21))\n                         \\<in> arg_poss p\n 4. \\<And>c d x21 x22 x21a x21aa x21b cnt.\n       \\<lbrakk>Discr\n                 (Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d))\n                \\<in> arg_poss p;\n        fstate = (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d);\n        state' = Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d);\n        state =\n        Discr (Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d));\n        cnt \\<in> x21b\\<rbrakk>\n       \\<Longrightarrow> Discr (Inl (cnt, [], c, \\<anb> d x22))\n                         \\<in> arg_poss p", "moreover"], ["proof (state)\nthis:\n  c \\<in> calls p\n\ngoal (4 subgoals):\n 1. \\<And>b c d x2 x1aa x2a x3.\n       \\<lbrakk>Discr (Inl (PC (Lambda x1aa x2a x3, x2), b, c, d))\n                \\<in> arg_poss p;\n        fstate = (PC (Lambda x1aa x2a x3, x2), b, c, d);\n        length x2a = length b;\n        state' = Inl (PC (Lambda x1aa x2a x3, x2), b, c, d);\n        state = Discr (Inl (PC (Lambda x1aa x2a x3, x2), b, c, d))\\<rbrakk>\n       \\<Longrightarrow> Discr\n                          (Inr (x3, x2(x1aa \\<mapsto> d),\n                                c \\<union>. \\<Union>.map2\n                (\\<lambda>v. smap_singleton (v, d)) x2a b,\n                                d))\n                         \\<in> arg_poss p\n 2. \\<And>c d x1 x21 x21a x21b cnt.\n       \\<lbrakk>Discr (Inl (PP (Plus x1), [x21, x21a, x21b], c, d))\n                \\<in> arg_poss p;\n        fstate = (PP (Plus x1), [x21, x21a, x21b], c, d);\n        state' = Inl (PP (Plus x1), [x21, x21a, x21b], c, d);\n        state = Discr (Inl (PP (Plus x1), [x21, x21a, x21b], c, d));\n        cnt \\<in> x21b\\<rbrakk>\n       \\<Longrightarrow> Discr (Inl (cnt, [{}], c, \\<anb> d x1))\n                         \\<in> arg_poss p\n 3. \\<And>c d x21 x22 x21a x21aa x21b cnt.\n       \\<lbrakk>Discr\n                 (Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d))\n                \\<in> arg_poss p;\n        fstate = (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d);\n        state' = Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d);\n        state =\n        Discr (Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d));\n        cnt \\<in> x21aa\\<rbrakk>\n       \\<Longrightarrow> Discr (Inl (cnt, [], c, \\<anb> d x21))\n                         \\<in> arg_poss p\n 4. \\<And>c d x21 x22 x21a x21aa x21b cnt.\n       \\<lbrakk>Discr\n                 (Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d))\n                \\<in> arg_poss p;\n        fstate = (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d);\n        state' = Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d);\n        state =\n        Discr (Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d));\n        cnt \\<in> x21b\\<rbrakk>\n       \\<Longrightarrow> Discr (Inl (cnt, [], c, \\<anb> d x22))\n                         \\<in> arg_poss p", "from lam"], ["proof (chain)\npicking this:\n  Lambda l vs c \\<in> lambdas p", "have \"l \\<in> labels p\""], ["proof (prove)\nusing this:\n  Lambda l vs c \\<in> lambdas p\n\ngoal (1 subgoal):\n 1. l \\<in> labels p", "by (rule lambdas2)"], ["proof (state)\nthis:\n  l \\<in> labels p\n\ngoal (4 subgoals):\n 1. \\<And>b c d x2 x1aa x2a x3.\n       \\<lbrakk>Discr (Inl (PC (Lambda x1aa x2a x3, x2), b, c, d))\n                \\<in> arg_poss p;\n        fstate = (PC (Lambda x1aa x2a x3, x2), b, c, d);\n        length x2a = length b;\n        state' = Inl (PC (Lambda x1aa x2a x3, x2), b, c, d);\n        state = Discr (Inl (PC (Lambda x1aa x2a x3, x2), b, c, d))\\<rbrakk>\n       \\<Longrightarrow> Discr\n                          (Inr (x3, x2(x1aa \\<mapsto> d),\n                                c \\<union>. \\<Union>.map2\n                (\\<lambda>v. smap_singleton (v, d)) x2a b,\n                                d))\n                         \\<in> arg_poss p\n 2. \\<And>c d x1 x21 x21a x21b cnt.\n       \\<lbrakk>Discr (Inl (PP (Plus x1), [x21, x21a, x21b], c, d))\n                \\<in> arg_poss p;\n        fstate = (PP (Plus x1), [x21, x21a, x21b], c, d);\n        state' = Inl (PP (Plus x1), [x21, x21a, x21b], c, d);\n        state = Discr (Inl (PP (Plus x1), [x21, x21a, x21b], c, d));\n        cnt \\<in> x21b\\<rbrakk>\n       \\<Longrightarrow> Discr (Inl (cnt, [{}], c, \\<anb> d x1))\n                         \\<in> arg_poss p\n 3. \\<And>c d x21 x22 x21a x21aa x21b cnt.\n       \\<lbrakk>Discr\n                 (Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d))\n                \\<in> arg_poss p;\n        fstate = (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d);\n        state' = Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d);\n        state =\n        Discr (Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d));\n        cnt \\<in> x21aa\\<rbrakk>\n       \\<Longrightarrow> Discr (Inl (cnt, [], c, \\<anb> d x21))\n                         \\<in> arg_poss p\n 4. \\<And>c d x21 x22 x21a x21aa x21b cnt.\n       \\<lbrakk>Discr\n                 (Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d))\n                \\<in> arg_poss p;\n        fstate = (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d);\n        state' = Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d);\n        state =\n        Discr (Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d));\n        cnt \\<in> x21b\\<rbrakk>\n       \\<Longrightarrow> Discr (Inl (cnt, [], c, \\<anb> d x22))\n                         \\<in> arg_poss p", "with beta"], ["proof (chain)\npicking this:\n  \\<beta> \\<in> maps_over (labels p) UNIV\n  l \\<in> labels p", "have \"\\<beta>(l \\<mapsto> b) \\<in> maps_over (labels p) UNIV\""], ["proof (prove)\nusing this:\n  \\<beta> \\<in> maps_over (labels p) UNIV\n  l \\<in> labels p\n\ngoal (1 subgoal):\n 1. \\<beta>(l \\<mapsto> b) \\<in> maps_over (labels p) UNIV", "by (rule maps_over_upd, auto)"], ["proof (state)\nthis:\n  \\<beta>(l \\<mapsto> b) \\<in> maps_over (labels p) UNIV\n\ngoal (4 subgoals):\n 1. \\<And>b c d x2 x1aa x2a x3.\n       \\<lbrakk>Discr (Inl (PC (Lambda x1aa x2a x3, x2), b, c, d))\n                \\<in> arg_poss p;\n        fstate = (PC (Lambda x1aa x2a x3, x2), b, c, d);\n        length x2a = length b;\n        state' = Inl (PC (Lambda x1aa x2a x3, x2), b, c, d);\n        state = Discr (Inl (PC (Lambda x1aa x2a x3, x2), b, c, d))\\<rbrakk>\n       \\<Longrightarrow> Discr\n                          (Inr (x3, x2(x1aa \\<mapsto> d),\n                                c \\<union>. \\<Union>.map2\n                (\\<lambda>v. smap_singleton (v, d)) x2a b,\n                                d))\n                         \\<in> arg_poss p\n 2. \\<And>c d x1 x21 x21a x21b cnt.\n       \\<lbrakk>Discr (Inl (PP (Plus x1), [x21, x21a, x21b], c, d))\n                \\<in> arg_poss p;\n        fstate = (PP (Plus x1), [x21, x21a, x21b], c, d);\n        state' = Inl (PP (Plus x1), [x21, x21a, x21b], c, d);\n        state = Discr (Inl (PP (Plus x1), [x21, x21a, x21b], c, d));\n        cnt \\<in> x21b\\<rbrakk>\n       \\<Longrightarrow> Discr (Inl (cnt, [{}], c, \\<anb> d x1))\n                         \\<in> arg_poss p\n 3. \\<And>c d x21 x22 x21a x21aa x21b cnt.\n       \\<lbrakk>Discr\n                 (Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d))\n                \\<in> arg_poss p;\n        fstate = (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d);\n        state' = Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d);\n        state =\n        Discr (Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d));\n        cnt \\<in> x21aa\\<rbrakk>\n       \\<Longrightarrow> Discr (Inl (cnt, [], c, \\<anb> d x21))\n                         \\<in> arg_poss p\n 4. \\<And>c d x21 x22 x21a x21aa x21b cnt.\n       \\<lbrakk>Discr\n                 (Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d))\n                \\<in> arg_poss p;\n        fstate = (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d);\n        state' = Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d);\n        state =\n        Discr (Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d));\n        cnt \\<in> x21b\\<rbrakk>\n       \\<Longrightarrow> Discr (Inl (cnt, [], c, \\<anb> d x22))\n                         \\<in> arg_poss p", "moreover"], ["proof (state)\nthis:\n  \\<beta>(l \\<mapsto> b) \\<in> maps_over (labels p) UNIV\n\ngoal (4 subgoals):\n 1. \\<And>b c d x2 x1aa x2a x3.\n       \\<lbrakk>Discr (Inl (PC (Lambda x1aa x2a x3, x2), b, c, d))\n                \\<in> arg_poss p;\n        fstate = (PC (Lambda x1aa x2a x3, x2), b, c, d);\n        length x2a = length b;\n        state' = Inl (PC (Lambda x1aa x2a x3, x2), b, c, d);\n        state = Discr (Inl (PC (Lambda x1aa x2a x3, x2), b, c, d))\\<rbrakk>\n       \\<Longrightarrow> Discr\n                          (Inr (x3, x2(x1aa \\<mapsto> d),\n                                c \\<union>. \\<Union>.map2\n                (\\<lambda>v. smap_singleton (v, d)) x2a b,\n                                d))\n                         \\<in> arg_poss p\n 2. \\<And>c d x1 x21 x21a x21b cnt.\n       \\<lbrakk>Discr (Inl (PP (Plus x1), [x21, x21a, x21b], c, d))\n                \\<in> arg_poss p;\n        fstate = (PP (Plus x1), [x21, x21a, x21b], c, d);\n        state' = Inl (PP (Plus x1), [x21, x21a, x21b], c, d);\n        state = Discr (Inl (PP (Plus x1), [x21, x21a, x21b], c, d));\n        cnt \\<in> x21b\\<rbrakk>\n       \\<Longrightarrow> Discr (Inl (cnt, [{}], c, \\<anb> d x1))\n                         \\<in> arg_poss p\n 3. \\<And>c d x21 x22 x21a x21aa x21b cnt.\n       \\<lbrakk>Discr\n                 (Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d))\n                \\<in> arg_poss p;\n        fstate = (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d);\n        state' = Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d);\n        state =\n        Discr (Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d));\n        cnt \\<in> x21aa\\<rbrakk>\n       \\<Longrightarrow> Discr (Inl (cnt, [], c, \\<anb> d x21))\n                         \\<in> arg_poss p\n 4. \\<And>c d x21 x22 x21a x21aa x21b cnt.\n       \\<lbrakk>Discr\n                 (Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d))\n                \\<in> arg_poss p;\n        fstate = (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d);\n        state' = Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d);\n        state =\n        Discr (Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d));\n        cnt \\<in> x21b\\<rbrakk>\n       \\<Longrightarrow> Discr (Inl (cnt, [], c, \\<anb> d x22))\n                         \\<in> arg_poss p", "from lam"], ["proof (chain)\npicking this:\n  Lambda l vs c \\<in> lambdas p", "have vs: \"set vs \\<subseteq> vars p\""], ["proof (prove)\nusing this:\n  Lambda l vs c \\<in> lambdas p\n\ngoal (1 subgoal):\n 1. set vs \\<subseteq> vars p", "by (rule lambdas3)"], ["proof (state)\nthis:\n  set vs \\<subseteq> vars p\n\ngoal (4 subgoals):\n 1. \\<And>b c d x2 x1aa x2a x3.\n       \\<lbrakk>Discr (Inl (PC (Lambda x1aa x2a x3, x2), b, c, d))\n                \\<in> arg_poss p;\n        fstate = (PC (Lambda x1aa x2a x3, x2), b, c, d);\n        length x2a = length b;\n        state' = Inl (PC (Lambda x1aa x2a x3, x2), b, c, d);\n        state = Discr (Inl (PC (Lambda x1aa x2a x3, x2), b, c, d))\\<rbrakk>\n       \\<Longrightarrow> Discr\n                          (Inr (x3, x2(x1aa \\<mapsto> d),\n                                c \\<union>. \\<Union>.map2\n                (\\<lambda>v. smap_singleton (v, d)) x2a b,\n                                d))\n                         \\<in> arg_poss p\n 2. \\<And>c d x1 x21 x21a x21b cnt.\n       \\<lbrakk>Discr (Inl (PP (Plus x1), [x21, x21a, x21b], c, d))\n                \\<in> arg_poss p;\n        fstate = (PP (Plus x1), [x21, x21a, x21b], c, d);\n        state' = Inl (PP (Plus x1), [x21, x21a, x21b], c, d);\n        state = Discr (Inl (PP (Plus x1), [x21, x21a, x21b], c, d));\n        cnt \\<in> x21b\\<rbrakk>\n       \\<Longrightarrow> Discr (Inl (cnt, [{}], c, \\<anb> d x1))\n                         \\<in> arg_poss p\n 3. \\<And>c d x21 x22 x21a x21aa x21b cnt.\n       \\<lbrakk>Discr\n                 (Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d))\n                \\<in> arg_poss p;\n        fstate = (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d);\n        state' = Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d);\n        state =\n        Discr (Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d));\n        cnt \\<in> x21aa\\<rbrakk>\n       \\<Longrightarrow> Discr (Inl (cnt, [], c, \\<anb> d x21))\n                         \\<in> arg_poss p\n 4. \\<And>c d x21 x22 x21a x21aa x21b cnt.\n       \\<lbrakk>Discr\n                 (Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d))\n                \\<in> arg_poss p;\n        fstate = (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d);\n        state' = Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d);\n        state =\n        Discr (Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d));\n        cnt \\<in> x21b\\<rbrakk>\n       \\<Longrightarrow> Discr (Inl (cnt, [], c, \\<anb> d x22))\n                         \\<in> arg_poss p", "from as"], ["proof (chain)\npicking this:\n  as \\<in> NList (Pow (proc_poss p)) (call_list_lengths p)", "have \"\\<forall> x \\<in> set as. x \\<in> Pow (proc_poss p)\""], ["proof (prove)\nusing this:\n  as \\<in> NList (Pow (proc_poss p)) (call_list_lengths p)\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set as. x \\<in> Pow (proc_poss p)", "unfolding NList_def nList_def"], ["proof (prove)\nusing this:\n  as \\<in> (\\<Union>n\\<in>call_list_lengths p.\n               {l. set l \\<subseteq> Pow (proc_poss p) \\<and> length l = n})\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set as. x \\<in> Pow (proc_poss p)", "by auto"], ["proof (state)\nthis:\n  \\<forall>x\\<in>set as. x \\<in> Pow (proc_poss p)\n\ngoal (4 subgoals):\n 1. \\<And>b c d x2 x1aa x2a x3.\n       \\<lbrakk>Discr (Inl (PC (Lambda x1aa x2a x3, x2), b, c, d))\n                \\<in> arg_poss p;\n        fstate = (PC (Lambda x1aa x2a x3, x2), b, c, d);\n        length x2a = length b;\n        state' = Inl (PC (Lambda x1aa x2a x3, x2), b, c, d);\n        state = Discr (Inl (PC (Lambda x1aa x2a x3, x2), b, c, d))\\<rbrakk>\n       \\<Longrightarrow> Discr\n                          (Inr (x3, x2(x1aa \\<mapsto> d),\n                                c \\<union>. \\<Union>.map2\n                (\\<lambda>v. smap_singleton (v, d)) x2a b,\n                                d))\n                         \\<in> arg_poss p\n 2. \\<And>c d x1 x21 x21a x21b cnt.\n       \\<lbrakk>Discr (Inl (PP (Plus x1), [x21, x21a, x21b], c, d))\n                \\<in> arg_poss p;\n        fstate = (PP (Plus x1), [x21, x21a, x21b], c, d);\n        state' = Inl (PP (Plus x1), [x21, x21a, x21b], c, d);\n        state = Discr (Inl (PP (Plus x1), [x21, x21a, x21b], c, d));\n        cnt \\<in> x21b\\<rbrakk>\n       \\<Longrightarrow> Discr (Inl (cnt, [{}], c, \\<anb> d x1))\n                         \\<in> arg_poss p\n 3. \\<And>c d x21 x22 x21a x21aa x21b cnt.\n       \\<lbrakk>Discr\n                 (Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d))\n                \\<in> arg_poss p;\n        fstate = (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d);\n        state' = Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d);\n        state =\n        Discr (Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d));\n        cnt \\<in> x21aa\\<rbrakk>\n       \\<Longrightarrow> Discr (Inl (cnt, [], c, \\<anb> d x21))\n                         \\<in> arg_poss p\n 4. \\<And>c d x21 x22 x21a x21aa x21b cnt.\n       \\<lbrakk>Discr\n                 (Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d))\n                \\<in> arg_poss p;\n        fstate = (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d);\n        state' = Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d);\n        state =\n        Discr (Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d));\n        cnt \\<in> x21b\\<rbrakk>\n       \\<Longrightarrow> Discr (Inl (cnt, [], c, \\<anb> d x22))\n                         \\<in> arg_poss p", "with vs"], ["proof (chain)\npicking this:\n  set vs \\<subseteq> vars p\n  \\<forall>x\\<in>set as. x \\<in> Pow (proc_poss p)", "have \"ve \\<union>. \\<Union>.map (\\<lambda>(v, y). { (v, b) := y}.) (zip vs as)\n       \\<in> smaps_over (vars p \\<times> UNIV) (proc_poss p)\" (is \"?ve' \\<in> _\")"], ["proof (prove)\nusing this:\n  set vs \\<subseteq> vars p\n  \\<forall>x\\<in>set as. x \\<in> Pow (proc_poss p)\n\ngoal (1 subgoal):\n 1. ve \\<union>. \\<Union>.map2 (\\<lambda>v. smap_singleton (v, b)) vs as\n    \\<in> smaps_over (vars p \\<times> UNIV) (proc_poss p)", "by (auto intro!: smaps_over_un[OF ve] smaps_over_Union smaps_over_singleton)\n          (auto simp add:set_zip)"], ["proof (state)\nthis:\n  ve \\<union>. \\<Union>.map2 (\\<lambda>v. smap_singleton (v, b)) vs as\n  \\<in> smaps_over (vars p \\<times> UNIV) (proc_poss p)\n\ngoal (4 subgoals):\n 1. \\<And>b c d x2 x1aa x2a x3.\n       \\<lbrakk>Discr (Inl (PC (Lambda x1aa x2a x3, x2), b, c, d))\n                \\<in> arg_poss p;\n        fstate = (PC (Lambda x1aa x2a x3, x2), b, c, d);\n        length x2a = length b;\n        state' = Inl (PC (Lambda x1aa x2a x3, x2), b, c, d);\n        state = Discr (Inl (PC (Lambda x1aa x2a x3, x2), b, c, d))\\<rbrakk>\n       \\<Longrightarrow> Discr\n                          (Inr (x3, x2(x1aa \\<mapsto> d),\n                                c \\<union>. \\<Union>.map2\n                (\\<lambda>v. smap_singleton (v, d)) x2a b,\n                                d))\n                         \\<in> arg_poss p\n 2. \\<And>c d x1 x21 x21a x21b cnt.\n       \\<lbrakk>Discr (Inl (PP (Plus x1), [x21, x21a, x21b], c, d))\n                \\<in> arg_poss p;\n        fstate = (PP (Plus x1), [x21, x21a, x21b], c, d);\n        state' = Inl (PP (Plus x1), [x21, x21a, x21b], c, d);\n        state = Discr (Inl (PP (Plus x1), [x21, x21a, x21b], c, d));\n        cnt \\<in> x21b\\<rbrakk>\n       \\<Longrightarrow> Discr (Inl (cnt, [{}], c, \\<anb> d x1))\n                         \\<in> arg_poss p\n 3. \\<And>c d x21 x22 x21a x21aa x21b cnt.\n       \\<lbrakk>Discr\n                 (Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d))\n                \\<in> arg_poss p;\n        fstate = (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d);\n        state' = Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d);\n        state =\n        Discr (Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d));\n        cnt \\<in> x21aa\\<rbrakk>\n       \\<Longrightarrow> Discr (Inl (cnt, [], c, \\<anb> d x21))\n                         \\<in> arg_poss p\n 4. \\<And>c d x21 x22 x21a x21aa x21b cnt.\n       \\<lbrakk>Discr\n                 (Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d))\n                \\<in> arg_poss p;\n        fstate = (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d);\n        state' = Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d);\n        state =\n        Discr (Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d));\n        cnt \\<in> x21b\\<rbrakk>\n       \\<Longrightarrow> Discr (Inl (cnt, [], c, \\<anb> d x22))\n                         \\<in> arg_poss p", "ultimately"], ["proof (chain)\npicking this:\n  c \\<in> calls p\n  \\<beta>(l \\<mapsto> b) \\<in> maps_over (labels p) UNIV\n  ve \\<union>. \\<Union>.map2 (\\<lambda>v. smap_singleton (v, b)) vs as\n  \\<in> smaps_over (vars p \\<times> UNIV) (proc_poss p)", "have \"(c, \\<beta>(l \\<mapsto> b), ?ve', b) \\<in> cstate_poss p\" (is \"?cstate \\<in> _\")"], ["proof (prove)\nusing this:\n  c \\<in> calls p\n  \\<beta>(l \\<mapsto> b) \\<in> maps_over (labels p) UNIV\n  ve \\<union>. \\<Union>.map2 (\\<lambda>v. smap_singleton (v, b)) vs as\n  \\<in> smaps_over (vars p \\<times> UNIV) (proc_poss p)\n\ngoal (1 subgoal):\n 1. (c, \\<beta>(l \\<mapsto> b),\n     ve \\<union>. \\<Union>.map2 (\\<lambda>v. smap_singleton (v, b)) vs as,\n     b)\n    \\<in> cstate_poss p", "unfolding cstate_poss_def"], ["proof (prove)\nusing this:\n  c \\<in> calls p\n  \\<beta>(l \\<mapsto> b) \\<in> maps_over (labels p) UNIV\n  ve \\<union>. \\<Union>.map2 (\\<lambda>v. smap_singleton (v, b)) vs as\n  \\<in> smaps_over (vars p \\<times> UNIV) (proc_poss p)\n\ngoal (1 subgoal):\n 1. (c, \\<beta>(l \\<mapsto> b),\n     ve \\<union>. \\<Union>.map2 (\\<lambda>v. smap_singleton (v, b)) vs as,\n     b)\n    \\<in> calls p \\<times>\n          maps_over (labels p) UNIV \\<times>\n          smaps_over (vars p \\<times> UNIV) (proc_poss p) \\<times> UNIV", "by simp"], ["proof (state)\nthis:\n  (c, \\<beta>(l \\<mapsto> b),\n   ve \\<union>. \\<Union>.map2 (\\<lambda>v. smap_singleton (v, b)) vs as, b)\n  \\<in> cstate_poss p\n\ngoal (4 subgoals):\n 1. \\<And>b c d x2 x1aa x2a x3.\n       \\<lbrakk>Discr (Inl (PC (Lambda x1aa x2a x3, x2), b, c, d))\n                \\<in> arg_poss p;\n        fstate = (PC (Lambda x1aa x2a x3, x2), b, c, d);\n        length x2a = length b;\n        state' = Inl (PC (Lambda x1aa x2a x3, x2), b, c, d);\n        state = Discr (Inl (PC (Lambda x1aa x2a x3, x2), b, c, d))\\<rbrakk>\n       \\<Longrightarrow> Discr\n                          (Inr (x3, x2(x1aa \\<mapsto> d),\n                                c \\<union>. \\<Union>.map2\n                (\\<lambda>v. smap_singleton (v, d)) x2a b,\n                                d))\n                         \\<in> arg_poss p\n 2. \\<And>c d x1 x21 x21a x21b cnt.\n       \\<lbrakk>Discr (Inl (PP (Plus x1), [x21, x21a, x21b], c, d))\n                \\<in> arg_poss p;\n        fstate = (PP (Plus x1), [x21, x21a, x21b], c, d);\n        state' = Inl (PP (Plus x1), [x21, x21a, x21b], c, d);\n        state = Discr (Inl (PP (Plus x1), [x21, x21a, x21b], c, d));\n        cnt \\<in> x21b\\<rbrakk>\n       \\<Longrightarrow> Discr (Inl (cnt, [{}], c, \\<anb> d x1))\n                         \\<in> arg_poss p\n 3. \\<And>c d x21 x22 x21a x21aa x21b cnt.\n       \\<lbrakk>Discr\n                 (Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d))\n                \\<in> arg_poss p;\n        fstate = (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d);\n        state' = Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d);\n        state =\n        Discr (Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d));\n        cnt \\<in> x21aa\\<rbrakk>\n       \\<Longrightarrow> Discr (Inl (cnt, [], c, \\<anb> d x21))\n                         \\<in> arg_poss p\n 4. \\<And>c d x21 x22 x21a x21aa x21b cnt.\n       \\<lbrakk>Discr\n                 (Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d))\n                \\<in> arg_poss p;\n        fstate = (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d);\n        state' = Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d);\n        state =\n        Discr (Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d));\n        cnt \\<in> x21b\\<rbrakk>\n       \\<Longrightarrow> Discr (Inl (cnt, [], c, \\<anb> d x22))\n                         \\<in> arg_poss p", "thus \"Discr (Inr ?cstate) \\<in> arg_poss p\""], ["proof (prove)\nusing this:\n  (c, \\<beta>(l \\<mapsto> b),\n   ve \\<union>. \\<Union>.map2 (\\<lambda>v. smap_singleton (v, b)) vs as, b)\n  \\<in> cstate_poss p\n\ngoal (1 subgoal):\n 1. Discr\n     (Inr (c, \\<beta>(l \\<mapsto> b),\n           ve \\<union>. \\<Union>.map2 (\\<lambda>v. smap_singleton (v, b)) vs\n                                  as,\n           b))\n    \\<in> arg_poss p", "unfolding arg_poss_def"], ["proof (prove)\nusing this:\n  (c, \\<beta>(l \\<mapsto> b),\n   ve \\<union>. \\<Union>.map2 (\\<lambda>v. smap_singleton (v, b)) vs as, b)\n  \\<in> cstate_poss p\n\ngoal (1 subgoal):\n 1. Discr\n     (Inr (c, \\<beta>(l \\<mapsto> b),\n           ve \\<union>. \\<Union>.map2 (\\<lambda>v. smap_singleton (v, b)) vs\n                                  as,\n           b))\n    \\<in> Discr ` (fstate_poss p <+> cstate_poss p)", "by auto"], ["proof (state)\nthis:\n  Discr\n   (Inr (c, \\<beta>(l \\<mapsto> b),\n         ve \\<union>. \\<Union>.map2 (\\<lambda>v. smap_singleton (v, b)) vs\n                                as,\n         b))\n  \\<in> arg_poss p\n\ngoal (3 subgoals):\n 1. \\<And>c d x1 x21 x21a x21b cnt.\n       \\<lbrakk>Discr (Inl (PP (Plus x1), [x21, x21a, x21b], c, d))\n                \\<in> arg_poss p;\n        fstate = (PP (Plus x1), [x21, x21a, x21b], c, d);\n        state' = Inl (PP (Plus x1), [x21, x21a, x21b], c, d);\n        state = Discr (Inl (PP (Plus x1), [x21, x21a, x21b], c, d));\n        cnt \\<in> x21b\\<rbrakk>\n       \\<Longrightarrow> Discr (Inl (cnt, [{}], c, \\<anb> d x1))\n                         \\<in> arg_poss p\n 2. \\<And>c d x21 x22 x21a x21aa x21b cnt.\n       \\<lbrakk>Discr\n                 (Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d))\n                \\<in> arg_poss p;\n        fstate = (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d);\n        state' = Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d);\n        state =\n        Discr (Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d));\n        cnt \\<in> x21aa\\<rbrakk>\n       \\<Longrightarrow> Discr (Inl (cnt, [], c, \\<anb> d x21))\n                         \\<in> arg_poss p\n 3. \\<And>c d x21 x22 x21a x21aa x21b cnt.\n       \\<lbrakk>Discr\n                 (Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d))\n                \\<in> arg_poss p;\n        fstate = (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d);\n        state' = Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d);\n        state =\n        Discr (Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d));\n        cnt \\<in> x21b\\<rbrakk>\n       \\<Longrightarrow> Discr (Inl (cnt, [], c, \\<anb> d x22))\n                         \\<in> arg_poss p", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>c d x1 x21 x21a x21b cnt.\n       \\<lbrakk>Discr (Inl (PP (Plus x1), [x21, x21a, x21b], c, d))\n                \\<in> arg_poss p;\n        fstate = (PP (Plus x1), [x21, x21a, x21b], c, d);\n        state' = Inl (PP (Plus x1), [x21, x21a, x21b], c, d);\n        state = Discr (Inl (PP (Plus x1), [x21, x21a, x21b], c, d));\n        cnt \\<in> x21b\\<rbrakk>\n       \\<Longrightarrow> Discr (Inl (cnt, [{}], c, \\<anb> d x1))\n                         \\<in> arg_poss p\n 2. \\<And>c d x21 x22 x21a x21aa x21b cnt.\n       \\<lbrakk>Discr\n                 (Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d))\n                \\<in> arg_poss p;\n        fstate = (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d);\n        state' = Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d);\n        state =\n        Discr (Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d));\n        cnt \\<in> x21aa\\<rbrakk>\n       \\<Longrightarrow> Discr (Inl (cnt, [], c, \\<anb> d x21))\n                         \\<in> arg_poss p\n 3. \\<And>c d x21 x22 x21a x21aa x21b cnt.\n       \\<lbrakk>Discr\n                 (Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d))\n                \\<in> arg_poss p;\n        fstate = (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d);\n        state' = Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d);\n        state =\n        Discr (Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d));\n        cnt \\<in> x21b\\<rbrakk>\n       \\<Longrightarrow> Discr (Inl (cnt, [], c, \\<anb> d x22))\n                         \\<in> arg_poss p", "txt \\<open>Case Plus\\<close>"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>c d x1 x21 x21a x21b cnt.\n       \\<lbrakk>Discr (Inl (PP (Plus x1), [x21, x21a, x21b], c, d))\n                \\<in> arg_poss p;\n        fstate = (PP (Plus x1), [x21, x21a, x21b], c, d);\n        state' = Inl (PP (Plus x1), [x21, x21a, x21b], c, d);\n        state = Discr (Inl (PP (Plus x1), [x21, x21a, x21b], c, d));\n        cnt \\<in> x21b\\<rbrakk>\n       \\<Longrightarrow> Discr (Inl (cnt, [{}], c, \\<anb> d x1))\n                         \\<in> arg_poss p\n 2. \\<And>c d x21 x22 x21a x21aa x21b cnt.\n       \\<lbrakk>Discr\n                 (Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d))\n                \\<in> arg_poss p;\n        fstate = (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d);\n        state' = Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d);\n        state =\n        Discr (Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d));\n        cnt \\<in> x21aa\\<rbrakk>\n       \\<Longrightarrow> Discr (Inl (cnt, [], c, \\<anb> d x21))\n                         \\<in> arg_poss p\n 3. \\<And>c d x21 x22 x21a x21aa x21b cnt.\n       \\<lbrakk>Discr\n                 (Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d))\n                \\<in> arg_poss p;\n        fstate = (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d);\n        state' = Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d);\n        state =\n        Discr (Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d));\n        cnt \\<in> x21b\\<rbrakk>\n       \\<Longrightarrow> Discr (Inl (cnt, [], c, \\<anb> d x22))\n                         \\<in> arg_poss p", "fix ve b l v1 v2 cnts cnt"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>c d x1 x21 x21a x21b cnt.\n       \\<lbrakk>Discr (Inl (PP (Plus x1), [x21, x21a, x21b], c, d))\n                \\<in> arg_poss p;\n        fstate = (PP (Plus x1), [x21, x21a, x21b], c, d);\n        state' = Inl (PP (Plus x1), [x21, x21a, x21b], c, d);\n        state = Discr (Inl (PP (Plus x1), [x21, x21a, x21b], c, d));\n        cnt \\<in> x21b\\<rbrakk>\n       \\<Longrightarrow> Discr (Inl (cnt, [{}], c, \\<anb> d x1))\n                         \\<in> arg_poss p\n 2. \\<And>c d x21 x22 x21a x21aa x21b cnt.\n       \\<lbrakk>Discr\n                 (Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d))\n                \\<in> arg_poss p;\n        fstate = (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d);\n        state' = Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d);\n        state =\n        Discr (Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d));\n        cnt \\<in> x21aa\\<rbrakk>\n       \\<Longrightarrow> Discr (Inl (cnt, [], c, \\<anb> d x21))\n                         \\<in> arg_poss p\n 3. \\<And>c d x21 x22 x21a x21aa x21b cnt.\n       \\<lbrakk>Discr\n                 (Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d))\n                \\<in> arg_poss p;\n        fstate = (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d);\n        state' = Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d);\n        state =\n        Discr (Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d));\n        cnt \\<in> x21b\\<rbrakk>\n       \\<Longrightarrow> Discr (Inl (cnt, [], c, \\<anb> d x22))\n                         \\<in> arg_poss p", "assume \"Discr (Inl (PP (prim.Plus l), [v1, v2, cnts], ve, b)) \\<in> arg_poss p\"\n         and \"cnt \\<in> cnts\""], ["proof (state)\nthis:\n  Discr (Inl (PP (Plus l), [v1, v2, cnts], ve, b)) \\<in> arg_poss p\n  cnt \\<in> cnts\n\ngoal (3 subgoals):\n 1. \\<And>c d x1 x21 x21a x21b cnt.\n       \\<lbrakk>Discr (Inl (PP (Plus x1), [x21, x21a, x21b], c, d))\n                \\<in> arg_poss p;\n        fstate = (PP (Plus x1), [x21, x21a, x21b], c, d);\n        state' = Inl (PP (Plus x1), [x21, x21a, x21b], c, d);\n        state = Discr (Inl (PP (Plus x1), [x21, x21a, x21b], c, d));\n        cnt \\<in> x21b\\<rbrakk>\n       \\<Longrightarrow> Discr (Inl (cnt, [{}], c, \\<anb> d x1))\n                         \\<in> arg_poss p\n 2. \\<And>c d x21 x22 x21a x21aa x21b cnt.\n       \\<lbrakk>Discr\n                 (Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d))\n                \\<in> arg_poss p;\n        fstate = (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d);\n        state' = Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d);\n        state =\n        Discr (Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d));\n        cnt \\<in> x21aa\\<rbrakk>\n       \\<Longrightarrow> Discr (Inl (cnt, [], c, \\<anb> d x21))\n                         \\<in> arg_poss p\n 3. \\<And>c d x21 x22 x21a x21aa x21b cnt.\n       \\<lbrakk>Discr\n                 (Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d))\n                \\<in> arg_poss p;\n        fstate = (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d);\n        state' = Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d);\n        state =\n        Discr (Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d));\n        cnt \\<in> x21b\\<rbrakk>\n       \\<Longrightarrow> Discr (Inl (cnt, [], c, \\<anb> d x22))\n                         \\<in> arg_poss p", "hence \"cnt \\<in> proc_poss p\" \n         and \"ve \\<in> smaps_over (vars p \\<times> UNIV) (proc_poss p)\""], ["proof (prove)\nusing this:\n  Discr (Inl (PP (Plus l), [v1, v2, cnts], ve, b)) \\<in> arg_poss p\n  cnt \\<in> cnts\n\ngoal (1 subgoal):\n 1. cnt \\<in> proc_poss p &&&\n    ve \\<in> smaps_over (vars p \\<times> UNIV) (proc_poss p)", "unfolding arg_poss_def fstate_poss_def NList_def nList_def"], ["proof (prove)\nusing this:\n  Discr (Inl (PP (Plus l), [v1, v2, cnts], ve, b))\n  \\<in> Discr `\n        (proc_poss p \\<times>\n         (\\<Union>n\\<in>call_list_lengths p.\n             {l. set l \\<subseteq> Pow (proc_poss p) \\<and>\n                 length l = n}) \\<times>\n         smaps_over (vars p \\<times> UNIV) (proc_poss p) \\<times> UNIV <+>\n         cstate_poss p)\n  cnt \\<in> cnts\n\ngoal (1 subgoal):\n 1. cnt \\<in> proc_poss p &&&\n    ve \\<in> smaps_over (vars p \\<times> UNIV) (proc_poss p)", "by auto"], ["proof (state)\nthis:\n  cnt \\<in> proc_poss p\n  ve \\<in> smaps_over (vars p \\<times> UNIV) (proc_poss p)\n\ngoal (3 subgoals):\n 1. \\<And>c d x1 x21 x21a x21b cnt.\n       \\<lbrakk>Discr (Inl (PP (Plus x1), [x21, x21a, x21b], c, d))\n                \\<in> arg_poss p;\n        fstate = (PP (Plus x1), [x21, x21a, x21b], c, d);\n        state' = Inl (PP (Plus x1), [x21, x21a, x21b], c, d);\n        state = Discr (Inl (PP (Plus x1), [x21, x21a, x21b], c, d));\n        cnt \\<in> x21b\\<rbrakk>\n       \\<Longrightarrow> Discr (Inl (cnt, [{}], c, \\<anb> d x1))\n                         \\<in> arg_poss p\n 2. \\<And>c d x21 x22 x21a x21aa x21b cnt.\n       \\<lbrakk>Discr\n                 (Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d))\n                \\<in> arg_poss p;\n        fstate = (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d);\n        state' = Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d);\n        state =\n        Discr (Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d));\n        cnt \\<in> x21aa\\<rbrakk>\n       \\<Longrightarrow> Discr (Inl (cnt, [], c, \\<anb> d x21))\n                         \\<in> arg_poss p\n 3. \\<And>c d x21 x22 x21a x21aa x21b cnt.\n       \\<lbrakk>Discr\n                 (Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d))\n                \\<in> arg_poss p;\n        fstate = (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d);\n        state' = Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d);\n        state =\n        Discr (Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d));\n        cnt \\<in> x21b\\<rbrakk>\n       \\<Longrightarrow> Discr (Inl (cnt, [], c, \\<anb> d x22))\n                         \\<in> arg_poss p", "moreover"], ["proof (state)\nthis:\n  cnt \\<in> proc_poss p\n  ve \\<in> smaps_over (vars p \\<times> UNIV) (proc_poss p)\n\ngoal (3 subgoals):\n 1. \\<And>c d x1 x21 x21a x21b cnt.\n       \\<lbrakk>Discr (Inl (PP (Plus x1), [x21, x21a, x21b], c, d))\n                \\<in> arg_poss p;\n        fstate = (PP (Plus x1), [x21, x21a, x21b], c, d);\n        state' = Inl (PP (Plus x1), [x21, x21a, x21b], c, d);\n        state = Discr (Inl (PP (Plus x1), [x21, x21a, x21b], c, d));\n        cnt \\<in> x21b\\<rbrakk>\n       \\<Longrightarrow> Discr (Inl (cnt, [{}], c, \\<anb> d x1))\n                         \\<in> arg_poss p\n 2. \\<And>c d x21 x22 x21a x21aa x21b cnt.\n       \\<lbrakk>Discr\n                 (Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d))\n                \\<in> arg_poss p;\n        fstate = (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d);\n        state' = Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d);\n        state =\n        Discr (Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d));\n        cnt \\<in> x21aa\\<rbrakk>\n       \\<Longrightarrow> Discr (Inl (cnt, [], c, \\<anb> d x21))\n                         \\<in> arg_poss p\n 3. \\<And>c d x21 x22 x21a x21aa x21b cnt.\n       \\<lbrakk>Discr\n                 (Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d))\n                \\<in> arg_poss p;\n        fstate = (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d);\n        state' = Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d);\n        state =\n        Discr (Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d));\n        cnt \\<in> x21b\\<rbrakk>\n       \\<Longrightarrow> Discr (Inl (cnt, [], c, \\<anb> d x22))\n                         \\<in> arg_poss p", "have \"[{}] \\<in> NList (Pow (proc_poss p)) (call_list_lengths p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [{}] \\<in> NList (Pow (proc_poss p)) (call_list_lengths p)", "unfolding call_list_lengths_def NList_def nList_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. [{}]\n    \\<in> (\\<Union>n\\<in>{0, 1, 2, 3} \\<union>\n                         case_call (\\<lambda>x xa. length)\n                          (\\<lambda>nat list call. 0) `\n                         calls p.\n              {l. set l \\<subseteq> Pow (proc_poss p) \\<and> length l = n})", "by auto"], ["proof (state)\nthis:\n  [{}] \\<in> NList (Pow (proc_poss p)) (call_list_lengths p)\n\ngoal (3 subgoals):\n 1. \\<And>c d x1 x21 x21a x21b cnt.\n       \\<lbrakk>Discr (Inl (PP (Plus x1), [x21, x21a, x21b], c, d))\n                \\<in> arg_poss p;\n        fstate = (PP (Plus x1), [x21, x21a, x21b], c, d);\n        state' = Inl (PP (Plus x1), [x21, x21a, x21b], c, d);\n        state = Discr (Inl (PP (Plus x1), [x21, x21a, x21b], c, d));\n        cnt \\<in> x21b\\<rbrakk>\n       \\<Longrightarrow> Discr (Inl (cnt, [{}], c, \\<anb> d x1))\n                         \\<in> arg_poss p\n 2. \\<And>c d x21 x22 x21a x21aa x21b cnt.\n       \\<lbrakk>Discr\n                 (Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d))\n                \\<in> arg_poss p;\n        fstate = (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d);\n        state' = Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d);\n        state =\n        Discr (Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d));\n        cnt \\<in> x21aa\\<rbrakk>\n       \\<Longrightarrow> Discr (Inl (cnt, [], c, \\<anb> d x21))\n                         \\<in> arg_poss p\n 3. \\<And>c d x21 x22 x21a x21aa x21b cnt.\n       \\<lbrakk>Discr\n                 (Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d))\n                \\<in> arg_poss p;\n        fstate = (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d);\n        state' = Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d);\n        state =\n        Discr (Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d));\n        cnt \\<in> x21b\\<rbrakk>\n       \\<Longrightarrow> Discr (Inl (cnt, [], c, \\<anb> d x22))\n                         \\<in> arg_poss p", "ultimately"], ["proof (chain)\npicking this:\n  cnt \\<in> proc_poss p\n  ve \\<in> smaps_over (vars p \\<times> UNIV) (proc_poss p)\n  [{}] \\<in> NList (Pow (proc_poss p)) (call_list_lengths p)", "have \"(cnt, [{}], ve, \\<anb> b l) \\<in> fstate_poss p\""], ["proof (prove)\nusing this:\n  cnt \\<in> proc_poss p\n  ve \\<in> smaps_over (vars p \\<times> UNIV) (proc_poss p)\n  [{}] \\<in> NList (Pow (proc_poss p)) (call_list_lengths p)\n\ngoal (1 subgoal):\n 1. (cnt, [{}], ve, \\<anb> b l) \\<in> fstate_poss p", "unfolding fstate_poss_def"], ["proof (prove)\nusing this:\n  cnt \\<in> proc_poss p\n  ve \\<in> smaps_over (vars p \\<times> UNIV) (proc_poss p)\n  [{}] \\<in> NList (Pow (proc_poss p)) (call_list_lengths p)\n\ngoal (1 subgoal):\n 1. (cnt, [{}], ve, \\<anb> b l)\n    \\<in> proc_poss p \\<times>\n          NList (Pow (proc_poss p)) (call_list_lengths p) \\<times>\n          smaps_over (vars p \\<times> UNIV) (proc_poss p) \\<times> UNIV", "by auto"], ["proof (state)\nthis:\n  (cnt, [{}], ve, \\<anb> b l) \\<in> fstate_poss p\n\ngoal (3 subgoals):\n 1. \\<And>c d x1 x21 x21a x21b cnt.\n       \\<lbrakk>Discr (Inl (PP (Plus x1), [x21, x21a, x21b], c, d))\n                \\<in> arg_poss p;\n        fstate = (PP (Plus x1), [x21, x21a, x21b], c, d);\n        state' = Inl (PP (Plus x1), [x21, x21a, x21b], c, d);\n        state = Discr (Inl (PP (Plus x1), [x21, x21a, x21b], c, d));\n        cnt \\<in> x21b\\<rbrakk>\n       \\<Longrightarrow> Discr (Inl (cnt, [{}], c, \\<anb> d x1))\n                         \\<in> arg_poss p\n 2. \\<And>c d x21 x22 x21a x21aa x21b cnt.\n       \\<lbrakk>Discr\n                 (Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d))\n                \\<in> arg_poss p;\n        fstate = (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d);\n        state' = Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d);\n        state =\n        Discr (Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d));\n        cnt \\<in> x21aa\\<rbrakk>\n       \\<Longrightarrow> Discr (Inl (cnt, [], c, \\<anb> d x21))\n                         \\<in> arg_poss p\n 3. \\<And>c d x21 x22 x21a x21aa x21b cnt.\n       \\<lbrakk>Discr\n                 (Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d))\n                \\<in> arg_poss p;\n        fstate = (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d);\n        state' = Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d);\n        state =\n        Discr (Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d));\n        cnt \\<in> x21b\\<rbrakk>\n       \\<Longrightarrow> Discr (Inl (cnt, [], c, \\<anb> d x22))\n                         \\<in> arg_poss p", "thus \"Discr (Inl (cnt, [{}], ve, \\<anb> b l)) \\<in> arg_poss p\""], ["proof (prove)\nusing this:\n  (cnt, [{}], ve, \\<anb> b l) \\<in> fstate_poss p\n\ngoal (1 subgoal):\n 1. Discr (Inl (cnt, [{}], ve, \\<anb> b l)) \\<in> arg_poss p", "unfolding arg_poss_def"], ["proof (prove)\nusing this:\n  (cnt, [{}], ve, \\<anb> b l) \\<in> fstate_poss p\n\ngoal (1 subgoal):\n 1. Discr (Inl (cnt, [{}], ve, \\<anb> b l))\n    \\<in> Discr ` (fstate_poss p <+> cstate_poss p)", "by auto"], ["proof (state)\nthis:\n  Discr (Inl (cnt, [{}], ve, \\<anb> b l)) \\<in> arg_poss p\n\ngoal (2 subgoals):\n 1. \\<And>c d x21 x22 x21a x21aa x21b cnt.\n       \\<lbrakk>Discr\n                 (Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d))\n                \\<in> arg_poss p;\n        fstate = (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d);\n        state' = Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d);\n        state =\n        Discr (Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d));\n        cnt \\<in> x21aa\\<rbrakk>\n       \\<Longrightarrow> Discr (Inl (cnt, [], c, \\<anb> d x21))\n                         \\<in> arg_poss p\n 2. \\<And>c d x21 x22 x21a x21aa x21b cnt.\n       \\<lbrakk>Discr\n                 (Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d))\n                \\<in> arg_poss p;\n        fstate = (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d);\n        state' = Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d);\n        state =\n        Discr (Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d));\n        cnt \\<in> x21b\\<rbrakk>\n       \\<Longrightarrow> Discr (Inl (cnt, [], c, \\<anb> d x22))\n                         \\<in> arg_poss p", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>c d x21 x22 x21a x21aa x21b cnt.\n       \\<lbrakk>Discr\n                 (Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d))\n                \\<in> arg_poss p;\n        fstate = (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d);\n        state' = Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d);\n        state =\n        Discr (Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d));\n        cnt \\<in> x21aa\\<rbrakk>\n       \\<Longrightarrow> Discr (Inl (cnt, [], c, \\<anb> d x21))\n                         \\<in> arg_poss p\n 2. \\<And>c d x21 x22 x21a x21aa x21b cnt.\n       \\<lbrakk>Discr\n                 (Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d))\n                \\<in> arg_poss p;\n        fstate = (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d);\n        state' = Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d);\n        state =\n        Discr (Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d));\n        cnt \\<in> x21b\\<rbrakk>\n       \\<Longrightarrow> Discr (Inl (cnt, [], c, \\<anb> d x22))\n                         \\<in> arg_poss p", "txt \\<open>Case If (true case)\\<close>"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>c d x21 x22 x21a x21aa x21b cnt.\n       \\<lbrakk>Discr\n                 (Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d))\n                \\<in> arg_poss p;\n        fstate = (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d);\n        state' = Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d);\n        state =\n        Discr (Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d));\n        cnt \\<in> x21aa\\<rbrakk>\n       \\<Longrightarrow> Discr (Inl (cnt, [], c, \\<anb> d x21))\n                         \\<in> arg_poss p\n 2. \\<And>c d x21 x22 x21a x21aa x21b cnt.\n       \\<lbrakk>Discr\n                 (Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d))\n                \\<in> arg_poss p;\n        fstate = (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d);\n        state' = Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d);\n        state =\n        Discr (Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d));\n        cnt \\<in> x21b\\<rbrakk>\n       \\<Longrightarrow> Discr (Inl (cnt, [], c, \\<anb> d x22))\n                         \\<in> arg_poss p", "fix ve b l1 l2 v cntst cntsf cnt"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>c d x21 x22 x21a x21aa x21b cnt.\n       \\<lbrakk>Discr\n                 (Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d))\n                \\<in> arg_poss p;\n        fstate = (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d);\n        state' = Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d);\n        state =\n        Discr (Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d));\n        cnt \\<in> x21aa\\<rbrakk>\n       \\<Longrightarrow> Discr (Inl (cnt, [], c, \\<anb> d x21))\n                         \\<in> arg_poss p\n 2. \\<And>c d x21 x22 x21a x21aa x21b cnt.\n       \\<lbrakk>Discr\n                 (Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d))\n                \\<in> arg_poss p;\n        fstate = (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d);\n        state' = Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d);\n        state =\n        Discr (Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d));\n        cnt \\<in> x21b\\<rbrakk>\n       \\<Longrightarrow> Discr (Inl (cnt, [], c, \\<anb> d x22))\n                         \\<in> arg_poss p", "assume \"Discr (Inl (PP (prim.If l1 l2), [v, cntst, cntsf], ve, b)) \\<in> arg_poss p\"\n         and \"cnt \\<in> cntst\""], ["proof (state)\nthis:\n  Discr (Inl (PP (prim.If l1 l2), [v, cntst, cntsf], ve, b))\n  \\<in> arg_poss p\n  cnt \\<in> cntst\n\ngoal (2 subgoals):\n 1. \\<And>c d x21 x22 x21a x21aa x21b cnt.\n       \\<lbrakk>Discr\n                 (Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d))\n                \\<in> arg_poss p;\n        fstate = (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d);\n        state' = Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d);\n        state =\n        Discr (Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d));\n        cnt \\<in> x21aa\\<rbrakk>\n       \\<Longrightarrow> Discr (Inl (cnt, [], c, \\<anb> d x21))\n                         \\<in> arg_poss p\n 2. \\<And>c d x21 x22 x21a x21aa x21b cnt.\n       \\<lbrakk>Discr\n                 (Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d))\n                \\<in> arg_poss p;\n        fstate = (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d);\n        state' = Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d);\n        state =\n        Discr (Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d));\n        cnt \\<in> x21b\\<rbrakk>\n       \\<Longrightarrow> Discr (Inl (cnt, [], c, \\<anb> d x22))\n                         \\<in> arg_poss p", "hence \"cnt \\<in> proc_poss p\"\n         and \"ve \\<in> smaps_over (vars p \\<times> UNIV) (proc_poss p)\""], ["proof (prove)\nusing this:\n  Discr (Inl (PP (prim.If l1 l2), [v, cntst, cntsf], ve, b))\n  \\<in> arg_poss p\n  cnt \\<in> cntst\n\ngoal (1 subgoal):\n 1. cnt \\<in> proc_poss p &&&\n    ve \\<in> smaps_over (vars p \\<times> UNIV) (proc_poss p)", "unfolding arg_poss_def fstate_poss_def NList_def nList_def"], ["proof (prove)\nusing this:\n  Discr (Inl (PP (prim.If l1 l2), [v, cntst, cntsf], ve, b))\n  \\<in> Discr `\n        (proc_poss p \\<times>\n         (\\<Union>n\\<in>call_list_lengths p.\n             {l. set l \\<subseteq> Pow (proc_poss p) \\<and>\n                 length l = n}) \\<times>\n         smaps_over (vars p \\<times> UNIV) (proc_poss p) \\<times> UNIV <+>\n         cstate_poss p)\n  cnt \\<in> cntst\n\ngoal (1 subgoal):\n 1. cnt \\<in> proc_poss p &&&\n    ve \\<in> smaps_over (vars p \\<times> UNIV) (proc_poss p)", "by auto"], ["proof (state)\nthis:\n  cnt \\<in> proc_poss p\n  ve \\<in> smaps_over (vars p \\<times> UNIV) (proc_poss p)\n\ngoal (2 subgoals):\n 1. \\<And>c d x21 x22 x21a x21aa x21b cnt.\n       \\<lbrakk>Discr\n                 (Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d))\n                \\<in> arg_poss p;\n        fstate = (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d);\n        state' = Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d);\n        state =\n        Discr (Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d));\n        cnt \\<in> x21aa\\<rbrakk>\n       \\<Longrightarrow> Discr (Inl (cnt, [], c, \\<anb> d x21))\n                         \\<in> arg_poss p\n 2. \\<And>c d x21 x22 x21a x21aa x21b cnt.\n       \\<lbrakk>Discr\n                 (Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d))\n                \\<in> arg_poss p;\n        fstate = (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d);\n        state' = Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d);\n        state =\n        Discr (Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d));\n        cnt \\<in> x21b\\<rbrakk>\n       \\<Longrightarrow> Discr (Inl (cnt, [], c, \\<anb> d x22))\n                         \\<in> arg_poss p", "moreover"], ["proof (state)\nthis:\n  cnt \\<in> proc_poss p\n  ve \\<in> smaps_over (vars p \\<times> UNIV) (proc_poss p)\n\ngoal (2 subgoals):\n 1. \\<And>c d x21 x22 x21a x21aa x21b cnt.\n       \\<lbrakk>Discr\n                 (Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d))\n                \\<in> arg_poss p;\n        fstate = (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d);\n        state' = Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d);\n        state =\n        Discr (Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d));\n        cnt \\<in> x21aa\\<rbrakk>\n       \\<Longrightarrow> Discr (Inl (cnt, [], c, \\<anb> d x21))\n                         \\<in> arg_poss p\n 2. \\<And>c d x21 x22 x21a x21aa x21b cnt.\n       \\<lbrakk>Discr\n                 (Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d))\n                \\<in> arg_poss p;\n        fstate = (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d);\n        state' = Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d);\n        state =\n        Discr (Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d));\n        cnt \\<in> x21b\\<rbrakk>\n       \\<Longrightarrow> Discr (Inl (cnt, [], c, \\<anb> d x22))\n                         \\<in> arg_poss p", "have \"[] \\<in> NList (Pow (proc_poss p)) (call_list_lengths p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [] \\<in> NList (Pow (proc_poss p)) (call_list_lengths p)", "unfolding call_list_lengths_def NList_def nList_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. [] \\<in> (\\<Union>n\\<in>{0, 1, 2, 3} \\<union>\n                            case_call (\\<lambda>x xa. length)\n                             (\\<lambda>nat list call. 0) `\n                            calls p.\n                 {l. set l \\<subseteq> Pow (proc_poss p) \\<and>\n                     length l = n})", "by auto"], ["proof (state)\nthis:\n  [] \\<in> NList (Pow (proc_poss p)) (call_list_lengths p)\n\ngoal (2 subgoals):\n 1. \\<And>c d x21 x22 x21a x21aa x21b cnt.\n       \\<lbrakk>Discr\n                 (Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d))\n                \\<in> arg_poss p;\n        fstate = (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d);\n        state' = Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d);\n        state =\n        Discr (Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d));\n        cnt \\<in> x21aa\\<rbrakk>\n       \\<Longrightarrow> Discr (Inl (cnt, [], c, \\<anb> d x21))\n                         \\<in> arg_poss p\n 2. \\<And>c d x21 x22 x21a x21aa x21b cnt.\n       \\<lbrakk>Discr\n                 (Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d))\n                \\<in> arg_poss p;\n        fstate = (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d);\n        state' = Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d);\n        state =\n        Discr (Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d));\n        cnt \\<in> x21b\\<rbrakk>\n       \\<Longrightarrow> Discr (Inl (cnt, [], c, \\<anb> d x22))\n                         \\<in> arg_poss p", "ultimately"], ["proof (chain)\npicking this:\n  cnt \\<in> proc_poss p\n  ve \\<in> smaps_over (vars p \\<times> UNIV) (proc_poss p)\n  [] \\<in> NList (Pow (proc_poss p)) (call_list_lengths p)", "have \"(cnt, [], ve, \\<anb> b l1) \\<in> fstate_poss p\""], ["proof (prove)\nusing this:\n  cnt \\<in> proc_poss p\n  ve \\<in> smaps_over (vars p \\<times> UNIV) (proc_poss p)\n  [] \\<in> NList (Pow (proc_poss p)) (call_list_lengths p)\n\ngoal (1 subgoal):\n 1. (cnt, [], ve, \\<anb> b l1) \\<in> fstate_poss p", "unfolding fstate_poss_def"], ["proof (prove)\nusing this:\n  cnt \\<in> proc_poss p\n  ve \\<in> smaps_over (vars p \\<times> UNIV) (proc_poss p)\n  [] \\<in> NList (Pow (proc_poss p)) (call_list_lengths p)\n\ngoal (1 subgoal):\n 1. (cnt, [], ve, \\<anb> b l1)\n    \\<in> proc_poss p \\<times>\n          NList (Pow (proc_poss p)) (call_list_lengths p) \\<times>\n          smaps_over (vars p \\<times> UNIV) (proc_poss p) \\<times> UNIV", "by auto"], ["proof (state)\nthis:\n  (cnt, [], ve, \\<anb> b l1) \\<in> fstate_poss p\n\ngoal (2 subgoals):\n 1. \\<And>c d x21 x22 x21a x21aa x21b cnt.\n       \\<lbrakk>Discr\n                 (Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d))\n                \\<in> arg_poss p;\n        fstate = (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d);\n        state' = Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d);\n        state =\n        Discr (Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d));\n        cnt \\<in> x21aa\\<rbrakk>\n       \\<Longrightarrow> Discr (Inl (cnt, [], c, \\<anb> d x21))\n                         \\<in> arg_poss p\n 2. \\<And>c d x21 x22 x21a x21aa x21b cnt.\n       \\<lbrakk>Discr\n                 (Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d))\n                \\<in> arg_poss p;\n        fstate = (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d);\n        state' = Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d);\n        state =\n        Discr (Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d));\n        cnt \\<in> x21b\\<rbrakk>\n       \\<Longrightarrow> Discr (Inl (cnt, [], c, \\<anb> d x22))\n                         \\<in> arg_poss p", "thus \"Discr (Inl (cnt, [], ve, \\<anb> b l1)) \\<in> arg_poss p\""], ["proof (prove)\nusing this:\n  (cnt, [], ve, \\<anb> b l1) \\<in> fstate_poss p\n\ngoal (1 subgoal):\n 1. Discr (Inl (cnt, [], ve, \\<anb> b l1)) \\<in> arg_poss p", "unfolding arg_poss_def"], ["proof (prove)\nusing this:\n  (cnt, [], ve, \\<anb> b l1) \\<in> fstate_poss p\n\ngoal (1 subgoal):\n 1. Discr (Inl (cnt, [], ve, \\<anb> b l1))\n    \\<in> Discr ` (fstate_poss p <+> cstate_poss p)", "by auto"], ["proof (state)\nthis:\n  Discr (Inl (cnt, [], ve, \\<anb> b l1)) \\<in> arg_poss p\n\ngoal (1 subgoal):\n 1. \\<And>c d x21 x22 x21a x21aa x21b cnt.\n       \\<lbrakk>Discr\n                 (Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d))\n                \\<in> arg_poss p;\n        fstate = (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d);\n        state' = Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d);\n        state =\n        Discr (Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d));\n        cnt \\<in> x21b\\<rbrakk>\n       \\<Longrightarrow> Discr (Inl (cnt, [], c, \\<anb> d x22))\n                         \\<in> arg_poss p", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>c d x21 x22 x21a x21aa x21b cnt.\n       \\<lbrakk>Discr\n                 (Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d))\n                \\<in> arg_poss p;\n        fstate = (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d);\n        state' = Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d);\n        state =\n        Discr (Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d));\n        cnt \\<in> x21b\\<rbrakk>\n       \\<Longrightarrow> Discr (Inl (cnt, [], c, \\<anb> d x22))\n                         \\<in> arg_poss p", "txt \\<open>Case If (false case)\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>c d x21 x22 x21a x21aa x21b cnt.\n       \\<lbrakk>Discr\n                 (Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d))\n                \\<in> arg_poss p;\n        fstate = (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d);\n        state' = Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d);\n        state =\n        Discr (Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d));\n        cnt \\<in> x21b\\<rbrakk>\n       \\<Longrightarrow> Discr (Inl (cnt, [], c, \\<anb> d x22))\n                         \\<in> arg_poss p", "fix ve b l1 l2 v cntst cntsf cnt"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>c d x21 x22 x21a x21aa x21b cnt.\n       \\<lbrakk>Discr\n                 (Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d))\n                \\<in> arg_poss p;\n        fstate = (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d);\n        state' = Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d);\n        state =\n        Discr (Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d));\n        cnt \\<in> x21b\\<rbrakk>\n       \\<Longrightarrow> Discr (Inl (cnt, [], c, \\<anb> d x22))\n                         \\<in> arg_poss p", "assume \"Discr (Inl (PP (prim.If l1 l2), [v, cntst, cntsf], ve, b)) \\<in> arg_poss p\"\n         and \"cnt \\<in> cntsf\""], ["proof (state)\nthis:\n  Discr (Inl (PP (prim.If l1 l2), [v, cntst, cntsf], ve, b))\n  \\<in> arg_poss p\n  cnt \\<in> cntsf\n\ngoal (1 subgoal):\n 1. \\<And>c d x21 x22 x21a x21aa x21b cnt.\n       \\<lbrakk>Discr\n                 (Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d))\n                \\<in> arg_poss p;\n        fstate = (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d);\n        state' = Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d);\n        state =\n        Discr (Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d));\n        cnt \\<in> x21b\\<rbrakk>\n       \\<Longrightarrow> Discr (Inl (cnt, [], c, \\<anb> d x22))\n                         \\<in> arg_poss p", "hence \"cnt \\<in> proc_poss p\"\n         and \"ve \\<in> smaps_over (vars p \\<times> UNIV) (proc_poss p)\""], ["proof (prove)\nusing this:\n  Discr (Inl (PP (prim.If l1 l2), [v, cntst, cntsf], ve, b))\n  \\<in> arg_poss p\n  cnt \\<in> cntsf\n\ngoal (1 subgoal):\n 1. cnt \\<in> proc_poss p &&&\n    ve \\<in> smaps_over (vars p \\<times> UNIV) (proc_poss p)", "unfolding arg_poss_def fstate_poss_def NList_def nList_def"], ["proof (prove)\nusing this:\n  Discr (Inl (PP (prim.If l1 l2), [v, cntst, cntsf], ve, b))\n  \\<in> Discr `\n        (proc_poss p \\<times>\n         (\\<Union>n\\<in>call_list_lengths p.\n             {l. set l \\<subseteq> Pow (proc_poss p) \\<and>\n                 length l = n}) \\<times>\n         smaps_over (vars p \\<times> UNIV) (proc_poss p) \\<times> UNIV <+>\n         cstate_poss p)\n  cnt \\<in> cntsf\n\ngoal (1 subgoal):\n 1. cnt \\<in> proc_poss p &&&\n    ve \\<in> smaps_over (vars p \\<times> UNIV) (proc_poss p)", "by auto"], ["proof (state)\nthis:\n  cnt \\<in> proc_poss p\n  ve \\<in> smaps_over (vars p \\<times> UNIV) (proc_poss p)\n\ngoal (1 subgoal):\n 1. \\<And>c d x21 x22 x21a x21aa x21b cnt.\n       \\<lbrakk>Discr\n                 (Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d))\n                \\<in> arg_poss p;\n        fstate = (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d);\n        state' = Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d);\n        state =\n        Discr (Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d));\n        cnt \\<in> x21b\\<rbrakk>\n       \\<Longrightarrow> Discr (Inl (cnt, [], c, \\<anb> d x22))\n                         \\<in> arg_poss p", "moreover"], ["proof (state)\nthis:\n  cnt \\<in> proc_poss p\n  ve \\<in> smaps_over (vars p \\<times> UNIV) (proc_poss p)\n\ngoal (1 subgoal):\n 1. \\<And>c d x21 x22 x21a x21aa x21b cnt.\n       \\<lbrakk>Discr\n                 (Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d))\n                \\<in> arg_poss p;\n        fstate = (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d);\n        state' = Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d);\n        state =\n        Discr (Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d));\n        cnt \\<in> x21b\\<rbrakk>\n       \\<Longrightarrow> Discr (Inl (cnt, [], c, \\<anb> d x22))\n                         \\<in> arg_poss p", "have \"[] \\<in> NList (Pow (proc_poss p)) (call_list_lengths p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [] \\<in> NList (Pow (proc_poss p)) (call_list_lengths p)", "unfolding call_list_lengths_def NList_def nList_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. [] \\<in> (\\<Union>n\\<in>{0, 1, 2, 3} \\<union>\n                            case_call (\\<lambda>x xa. length)\n                             (\\<lambda>nat list call. 0) `\n                            calls p.\n                 {l. set l \\<subseteq> Pow (proc_poss p) \\<and>\n                     length l = n})", "by auto"], ["proof (state)\nthis:\n  [] \\<in> NList (Pow (proc_poss p)) (call_list_lengths p)\n\ngoal (1 subgoal):\n 1. \\<And>c d x21 x22 x21a x21aa x21b cnt.\n       \\<lbrakk>Discr\n                 (Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d))\n                \\<in> arg_poss p;\n        fstate = (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d);\n        state' = Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d);\n        state =\n        Discr (Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d));\n        cnt \\<in> x21b\\<rbrakk>\n       \\<Longrightarrow> Discr (Inl (cnt, [], c, \\<anb> d x22))\n                         \\<in> arg_poss p", "ultimately"], ["proof (chain)\npicking this:\n  cnt \\<in> proc_poss p\n  ve \\<in> smaps_over (vars p \\<times> UNIV) (proc_poss p)\n  [] \\<in> NList (Pow (proc_poss p)) (call_list_lengths p)", "have \"(cnt, [], ve, \\<anb> b l2) \\<in> fstate_poss p\""], ["proof (prove)\nusing this:\n  cnt \\<in> proc_poss p\n  ve \\<in> smaps_over (vars p \\<times> UNIV) (proc_poss p)\n  [] \\<in> NList (Pow (proc_poss p)) (call_list_lengths p)\n\ngoal (1 subgoal):\n 1. (cnt, [], ve, \\<anb> b l2) \\<in> fstate_poss p", "unfolding fstate_poss_def"], ["proof (prove)\nusing this:\n  cnt \\<in> proc_poss p\n  ve \\<in> smaps_over (vars p \\<times> UNIV) (proc_poss p)\n  [] \\<in> NList (Pow (proc_poss p)) (call_list_lengths p)\n\ngoal (1 subgoal):\n 1. (cnt, [], ve, \\<anb> b l2)\n    \\<in> proc_poss p \\<times>\n          NList (Pow (proc_poss p)) (call_list_lengths p) \\<times>\n          smaps_over (vars p \\<times> UNIV) (proc_poss p) \\<times> UNIV", "by auto"], ["proof (state)\nthis:\n  (cnt, [], ve, \\<anb> b l2) \\<in> fstate_poss p\n\ngoal (1 subgoal):\n 1. \\<And>c d x21 x22 x21a x21aa x21b cnt.\n       \\<lbrakk>Discr\n                 (Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d))\n                \\<in> arg_poss p;\n        fstate = (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d);\n        state' = Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d);\n        state =\n        Discr (Inl (PP (prim.If x21 x22), [x21a, x21aa, x21b], c, d));\n        cnt \\<in> x21b\\<rbrakk>\n       \\<Longrightarrow> Discr (Inl (cnt, [], c, \\<anb> d x22))\n                         \\<in> arg_poss p", "thus \"Discr (Inl (cnt, [], ve, \\<anb> b l2)) \\<in> arg_poss p\""], ["proof (prove)\nusing this:\n  (cnt, [], ve, \\<anb> b l2) \\<in> fstate_poss p\n\ngoal (1 subgoal):\n 1. Discr (Inl (cnt, [], ve, \\<anb> b l2)) \\<in> arg_poss p", "unfolding arg_poss_def"], ["proof (prove)\nusing this:\n  (cnt, [], ve, \\<anb> b l2) \\<in> fstate_poss p\n\ngoal (1 subgoal):\n 1. Discr (Inl (cnt, [], ve, \\<anb> b l2))\n    \\<in> Discr ` (fstate_poss p <+> cstate_poss p)", "by auto"], ["proof (state)\nthis:\n  Discr (Inl (cnt, [], ve, \\<anb> b l2)) \\<in> arg_poss p\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Lambda> x.\n      case undiscr x of\n      Inl (PC (Lambda lab vs c, \\<beta>), as, ve, b) \\<Rightarrow>\n        if length vs = length as\n        then let \\<beta>' = \\<beta>(lab \\<mapsto> b);\n                 ve' =\n                   ve \\<union>. \\<Union>.map2\n    (\\<lambda>v. smap_singleton (v, b)) vs as\n             in {Discr (Inr (c, \\<beta>', ve', b))}\n        else \\<bottom>\n      | Inl (PP (Plus c), [], bb) \\<Rightarrow> \\<bottom>\n      | Inl (PP (Plus c), [x], bb) \\<Rightarrow> \\<bottom>\n      | Inl (PP (Plus c), [x, xa], bb) \\<Rightarrow> \\<bottom>\n      | Inl (PP (Plus c), [x, xa, cnts], ve, b) \\<Rightarrow>\n          let b' = \\<anb> b c; \\<beta> = [c \\<mapsto> b]\n          in \\<Union>cnt\\<in>cnts. {Discr (Inl (cnt, [{}], ve, b'))}\n      | Inl (PP (Plus c), x # xa # cnts # ac # lista, bb) \\<Rightarrow>\n          \\<bottom>\n      | Inl (PP (prim.If ct cf), [], bb) \\<Rightarrow> \\<bottom>\n      | Inl (PP (prim.If ct cf), [x], bb) \\<Rightarrow> \\<bottom>\n      | Inl (PP (prim.If ct cf), [x, cntts], bb) \\<Rightarrow> \\<bottom>\n      | Inl (PP (prim.If ct cf), [x, cntts, cntfs], ve, b) \\<Rightarrow>\n          (let b' = \\<anb> b ct; \\<beta> = [ct \\<mapsto> b]\n           in \\<Union>cnt\\<in>cntts.\n                 {Discr (Inl (cnt, [], ve, b'))}) \\<union>\n          (let b' = \\<anb> b cf; \\<beta> = [cf \\<mapsto> b]\n           in \\<Union>cnt\\<in>cntfs. {Discr (Inl (cnt, [], ve, b'))})\n      | Inl (PP (prim.If ct cf), x # cntts # cntfs # ac # lista,\n             bb) \\<Rightarrow>\n          \\<bottom>\n      | Inl (AStop, [], bb) \\<Rightarrow> \\<bottom>\n      | Inl (AStop, [x], xa, xb) \\<Rightarrow> {}\n      | Inl (AStop, x # a # lista, bb) \\<Rightarrow> \\<bottom>\n      | Inr (App lab f vs, \\<beta>, ve, b) \\<Rightarrow>\n          let fs = \\<aA> f \\<beta> ve;\n              as = map (\\<lambda>v. \\<aA> v \\<beta> ve) vs;\n              b' = \\<anb> b lab\n          in \\<Union>f'\\<in>fs. {Discr (Inl (f', as, ve, b'))}\n      | Inr (call.Let lab ls c', \\<beta>, ve, b) \\<Rightarrow>\n          let b' = \\<anb> b lab; \\<beta>' = \\<beta>(lab \\<mapsto> b');\n              ve' =\n                ve \\<union>. \\<Union>.map\n (\\<lambda>(v, l). { (v, b') := \\<aA> (L l) \\<beta>' ve}.) ls\n          in {Discr (Inr (c', \\<beta>', ve', b'))})\\<cdot>\n  state\n  \\<subseteq> arg_poss p\n\ngoal (1 subgoal):\n 1. \\<And>b.\n       state' = Inr b \\<Longrightarrow>\n       (\\<Lambda> x.\n           case undiscr x of\n           Inl (PC (Lambda lab vs c, \\<beta>), as, ve, b) \\<Rightarrow>\n             if length vs = length as\n             then let \\<beta>' = \\<beta>(lab \\<mapsto> b);\n                      ve' =\n                        ve \\<union>. \\<Union>.map2\n         (\\<lambda>v. smap_singleton (v, b)) vs as\n                  in {Discr (Inr (c, \\<beta>', ve', b))}\n             else \\<bottom>\n           | Inl (PP (Plus c), [], bb) \\<Rightarrow> \\<bottom>\n           | Inl (PP (Plus c), [x], bb) \\<Rightarrow> \\<bottom>\n           | Inl (PP (Plus c), [x, xa], bb) \\<Rightarrow> \\<bottom>\n           | Inl (PP (Plus c), [x, xa, cnts], ve, b) \\<Rightarrow>\n               let b' = \\<anb> b c; \\<beta> = [c \\<mapsto> b]\n               in \\<Union>cnt\\<in>cnts. {Discr (Inl (cnt, [{}], ve, b'))}\n           | Inl (PP (Plus c), x # xa # cnts # ac # lista, bb) \\<Rightarrow>\n               \\<bottom>\n           | Inl (PP (prim.If ct cf), [], bb) \\<Rightarrow> \\<bottom>\n           | Inl (PP (prim.If ct cf), [x], bb) \\<Rightarrow> \\<bottom>\n           | Inl (PP (prim.If ct cf), [x, cntts], bb) \\<Rightarrow>\n               \\<bottom>\n           | Inl (PP (prim.If ct cf), [x, cntts, cntfs], ve,\n                  b) \\<Rightarrow>\n               (let b' = \\<anb> b ct; \\<beta> = [ct \\<mapsto> b]\n                in \\<Union>cnt\\<in>cntts.\n                      {Discr (Inl (cnt, [], ve, b'))}) \\<union>\n               (let b' = \\<anb> b cf; \\<beta> = [cf \\<mapsto> b]\n                in \\<Union>cnt\\<in>cntfs. {Discr (Inl (cnt, [], ve, b'))})\n           | Inl (PP (prim.If ct cf), x # cntts # cntfs # ac # lista,\n                  bb) \\<Rightarrow>\n               \\<bottom>\n           | Inl (AStop, [], bb) \\<Rightarrow> \\<bottom>\n           | Inl (AStop, [x], xa, xb) \\<Rightarrow> {}\n           | Inl (AStop, x # a # lista, bb) \\<Rightarrow> \\<bottom>\n           | Inr (App lab f vs, \\<beta>, ve, b) \\<Rightarrow>\n               let fs = \\<aA> f \\<beta> ve;\n                   as = map (\\<lambda>v. \\<aA> v \\<beta> ve) vs;\n                   b' = \\<anb> b lab\n               in \\<Union>f'\\<in>fs. {Discr (Inl (f', as, ve, b'))}\n           | Inr (call.Let lab ls c', \\<beta>, ve, b) \\<Rightarrow>\n               let b' = \\<anb> b lab; \\<beta>' = \\<beta>(lab \\<mapsto> b');\n                   ve' =\n                     ve \\<union>. \\<Union>.map\n      (\\<lambda>(v, l). { (v, b') := \\<aA> (L l) \\<beta>' ve}.) ls\n               in {Discr (Inr (c', \\<beta>', ve', b'))})\\<cdot>\n       state\n       \\<subseteq> arg_poss p", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>b.\n       state' = Inr b \\<Longrightarrow>\n       (\\<Lambda> x.\n           case undiscr x of\n           Inl (PC (Lambda lab vs c, \\<beta>), as, ve, b) \\<Rightarrow>\n             if length vs = length as\n             then let \\<beta>' = \\<beta>(lab \\<mapsto> b);\n                      ve' =\n                        ve \\<union>. \\<Union>.map2\n         (\\<lambda>v. smap_singleton (v, b)) vs as\n                  in {Discr (Inr (c, \\<beta>', ve', b))}\n             else \\<bottom>\n           | Inl (PP (Plus c), [], bb) \\<Rightarrow> \\<bottom>\n           | Inl (PP (Plus c), [x], bb) \\<Rightarrow> \\<bottom>\n           | Inl (PP (Plus c), [x, xa], bb) \\<Rightarrow> \\<bottom>\n           | Inl (PP (Plus c), [x, xa, cnts], ve, b) \\<Rightarrow>\n               let b' = \\<anb> b c; \\<beta> = [c \\<mapsto> b]\n               in \\<Union>cnt\\<in>cnts. {Discr (Inl (cnt, [{}], ve, b'))}\n           | Inl (PP (Plus c), x # xa # cnts # ac # lista, bb) \\<Rightarrow>\n               \\<bottom>\n           | Inl (PP (prim.If ct cf), [], bb) \\<Rightarrow> \\<bottom>\n           | Inl (PP (prim.If ct cf), [x], bb) \\<Rightarrow> \\<bottom>\n           | Inl (PP (prim.If ct cf), [x, cntts], bb) \\<Rightarrow>\n               \\<bottom>\n           | Inl (PP (prim.If ct cf), [x, cntts, cntfs], ve,\n                  b) \\<Rightarrow>\n               (let b' = \\<anb> b ct; \\<beta> = [ct \\<mapsto> b]\n                in \\<Union>cnt\\<in>cntts.\n                      {Discr (Inl (cnt, [], ve, b'))}) \\<union>\n               (let b' = \\<anb> b cf; \\<beta> = [cf \\<mapsto> b]\n                in \\<Union>cnt\\<in>cntfs. {Discr (Inl (cnt, [], ve, b'))})\n           | Inl (PP (prim.If ct cf), x # cntts # cntfs # ac # lista,\n                  bb) \\<Rightarrow>\n               \\<bottom>\n           | Inl (AStop, [], bb) \\<Rightarrow> \\<bottom>\n           | Inl (AStop, [x], xa, xb) \\<Rightarrow> {}\n           | Inl (AStop, x # a # lista, bb) \\<Rightarrow> \\<bottom>\n           | Inr (App lab f vs, \\<beta>, ve, b) \\<Rightarrow>\n               let fs = \\<aA> f \\<beta> ve;\n                   as = map (\\<lambda>v. \\<aA> v \\<beta> ve) vs;\n                   b' = \\<anb> b lab\n               in \\<Union>f'\\<in>fs. {Discr (Inl (f', as, ve, b'))}\n           | Inr (call.Let lab ls c', \\<beta>, ve, b) \\<Rightarrow>\n               let b' = \\<anb> b lab; \\<beta>' = \\<beta>(lab \\<mapsto> b');\n                   ve' =\n                     ve \\<union>. \\<Union>.map\n      (\\<lambda>(v, l). { (v, b') := \\<aA> (L l) \\<beta>' ve}.) ls\n               in {Discr (Inr (c', \\<beta>', ve', b'))})\\<cdot>\n       state\n       \\<subseteq> arg_poss p", "case (Inr cstate)"], ["proof (state)\nthis:\n  state' = Inr cstate\n\ngoal (1 subgoal):\n 1. \\<And>b.\n       state' = Inr b \\<Longrightarrow>\n       (\\<Lambda> x.\n           case undiscr x of\n           Inl (PC (Lambda lab vs c, \\<beta>), as, ve, b) \\<Rightarrow>\n             if length vs = length as\n             then let \\<beta>' = \\<beta>(lab \\<mapsto> b);\n                      ve' =\n                        ve \\<union>. \\<Union>.map2\n         (\\<lambda>v. smap_singleton (v, b)) vs as\n                  in {Discr (Inr (c, \\<beta>', ve', b))}\n             else \\<bottom>\n           | Inl (PP (Plus c), [], bb) \\<Rightarrow> \\<bottom>\n           | Inl (PP (Plus c), [x], bb) \\<Rightarrow> \\<bottom>\n           | Inl (PP (Plus c), [x, xa], bb) \\<Rightarrow> \\<bottom>\n           | Inl (PP (Plus c), [x, xa, cnts], ve, b) \\<Rightarrow>\n               let b' = \\<anb> b c; \\<beta> = [c \\<mapsto> b]\n               in \\<Union>cnt\\<in>cnts. {Discr (Inl (cnt, [{}], ve, b'))}\n           | Inl (PP (Plus c), x # xa # cnts # ac # lista, bb) \\<Rightarrow>\n               \\<bottom>\n           | Inl (PP (prim.If ct cf), [], bb) \\<Rightarrow> \\<bottom>\n           | Inl (PP (prim.If ct cf), [x], bb) \\<Rightarrow> \\<bottom>\n           | Inl (PP (prim.If ct cf), [x, cntts], bb) \\<Rightarrow>\n               \\<bottom>\n           | Inl (PP (prim.If ct cf), [x, cntts, cntfs], ve,\n                  b) \\<Rightarrow>\n               (let b' = \\<anb> b ct; \\<beta> = [ct \\<mapsto> b]\n                in \\<Union>cnt\\<in>cntts.\n                      {Discr (Inl (cnt, [], ve, b'))}) \\<union>\n               (let b' = \\<anb> b cf; \\<beta> = [cf \\<mapsto> b]\n                in \\<Union>cnt\\<in>cntfs. {Discr (Inl (cnt, [], ve, b'))})\n           | Inl (PP (prim.If ct cf), x # cntts # cntfs # ac # lista,\n                  bb) \\<Rightarrow>\n               \\<bottom>\n           | Inl (AStop, [], bb) \\<Rightarrow> \\<bottom>\n           | Inl (AStop, [x], xa, xb) \\<Rightarrow> {}\n           | Inl (AStop, x # a # lista, bb) \\<Rightarrow> \\<bottom>\n           | Inr (App lab f vs, \\<beta>, ve, b) \\<Rightarrow>\n               let fs = \\<aA> f \\<beta> ve;\n                   as = map (\\<lambda>v. \\<aA> v \\<beta> ve) vs;\n                   b' = \\<anb> b lab\n               in \\<Union>f'\\<in>fs. {Discr (Inl (f', as, ve, b'))}\n           | Inr (call.Let lab ls c', \\<beta>, ve, b) \\<Rightarrow>\n               let b' = \\<anb> b lab; \\<beta>' = \\<beta>(lab \\<mapsto> b');\n                   ve' =\n                     ve \\<union>. \\<Union>.map\n      (\\<lambda>(v, l). { (v, b') := \\<aA> (L l) \\<beta>' ve}.) ls\n               in {Discr (Inr (c', \\<beta>', ve', b'))})\\<cdot>\n       state\n       \\<subseteq> arg_poss p", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Lambda> x.\n        case undiscr x of\n        Inl (PC (Lambda lab vs c, \\<beta>), as, ve, b) \\<Rightarrow>\n          if length vs = length as\n          then let \\<beta>' = \\<beta>(lab \\<mapsto> b);\n                   ve' =\n                     ve \\<union>. \\<Union>.map2\n      (\\<lambda>v. smap_singleton (v, b)) vs as\n               in {Discr (Inr (c, \\<beta>', ve', b))}\n          else \\<bottom>\n        | Inl (PP (Plus c), [], bb) \\<Rightarrow> \\<bottom>\n        | Inl (PP (Plus c), [x], bb) \\<Rightarrow> \\<bottom>\n        | Inl (PP (Plus c), [x, xa], bb) \\<Rightarrow> \\<bottom>\n        | Inl (PP (Plus c), [x, xa, cnts], ve, b) \\<Rightarrow>\n            let b' = \\<anb> b c; \\<beta> = [c \\<mapsto> b]\n            in \\<Union>cnt\\<in>cnts. {Discr (Inl (cnt, [{}], ve, b'))}\n        | Inl (PP (Plus c), x # xa # cnts # ac # lista, bb) \\<Rightarrow>\n            \\<bottom>\n        | Inl (PP (prim.If ct cf), [], bb) \\<Rightarrow> \\<bottom>\n        | Inl (PP (prim.If ct cf), [x], bb) \\<Rightarrow> \\<bottom>\n        | Inl (PP (prim.If ct cf), [x, cntts], bb) \\<Rightarrow> \\<bottom>\n        | Inl (PP (prim.If ct cf), [x, cntts, cntfs], ve, b) \\<Rightarrow>\n            (let b' = \\<anb> b ct; \\<beta> = [ct \\<mapsto> b]\n             in \\<Union>cnt\\<in>cntts.\n                   {Discr (Inl (cnt, [], ve, b'))}) \\<union>\n            (let b' = \\<anb> b cf; \\<beta> = [cf \\<mapsto> b]\n             in \\<Union>cnt\\<in>cntfs. {Discr (Inl (cnt, [], ve, b'))})\n        | Inl (PP (prim.If ct cf), x # cntts # cntfs # ac # lista,\n               bb) \\<Rightarrow>\n            \\<bottom>\n        | Inl (AStop, [], bb) \\<Rightarrow> \\<bottom>\n        | Inl (AStop, [x], xa, xb) \\<Rightarrow> {}\n        | Inl (AStop, x # a # lista, bb) \\<Rightarrow> \\<bottom>\n        | Inr (App lab f vs, \\<beta>, ve, b) \\<Rightarrow>\n            let fs = \\<aA> f \\<beta> ve;\n                as = map (\\<lambda>v. \\<aA> v \\<beta> ve) vs;\n                b' = \\<anb> b lab\n            in \\<Union>f'\\<in>fs. {Discr (Inl (f', as, ve, b'))}\n        | Inr (call.Let lab ls c', \\<beta>, ve, b) \\<Rightarrow>\n            let b' = \\<anb> b lab; \\<beta>' = \\<beta>(lab \\<mapsto> b');\n                ve' =\n                  ve \\<union>. \\<Union>.map\n   (\\<lambda>(v, l). { (v, b') := \\<aA> (L l) \\<beta>' ve}.) ls\n            in {Discr (Inr (c', \\<beta>', ve', b'))})\\<cdot>\n    state\n    \\<subseteq> arg_poss p", "proof(cases cstate rule: prod_cases4)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b c d.\n       cstate = (a, b, c, d) \\<Longrightarrow>\n       (\\<Lambda> x.\n           case undiscr x of\n           Inl (PC (Lambda lab vs c, \\<beta>), as, ve, b) \\<Rightarrow>\n             if length vs = length as\n             then let \\<beta>' = \\<beta>(lab \\<mapsto> b);\n                      ve' =\n                        ve \\<union>. \\<Union>.map2\n         (\\<lambda>v. smap_singleton (v, b)) vs as\n                  in {Discr (Inr (c, \\<beta>', ve', b))}\n             else \\<bottom>\n           | Inl (PP (Plus c), [], bb) \\<Rightarrow> \\<bottom>\n           | Inl (PP (Plus c), [x], bb) \\<Rightarrow> \\<bottom>\n           | Inl (PP (Plus c), [x, xa], bb) \\<Rightarrow> \\<bottom>\n           | Inl (PP (Plus c), [x, xa, cnts], ve, b) \\<Rightarrow>\n               let b' = \\<anb> b c; \\<beta> = [c \\<mapsto> b]\n               in \\<Union>cnt\\<in>cnts. {Discr (Inl (cnt, [{}], ve, b'))}\n           | Inl (PP (Plus c), x # xa # cnts # ac # lista, bb) \\<Rightarrow>\n               \\<bottom>\n           | Inl (PP (prim.If ct cf), [], bb) \\<Rightarrow> \\<bottom>\n           | Inl (PP (prim.If ct cf), [x], bb) \\<Rightarrow> \\<bottom>\n           | Inl (PP (prim.If ct cf), [x, cntts], bb) \\<Rightarrow>\n               \\<bottom>\n           | Inl (PP (prim.If ct cf), [x, cntts, cntfs], ve,\n                  b) \\<Rightarrow>\n               (let b' = \\<anb> b ct; \\<beta> = [ct \\<mapsto> b]\n                in \\<Union>cnt\\<in>cntts.\n                      {Discr (Inl (cnt, [], ve, b'))}) \\<union>\n               (let b' = \\<anb> b cf; \\<beta> = [cf \\<mapsto> b]\n                in \\<Union>cnt\\<in>cntfs. {Discr (Inl (cnt, [], ve, b'))})\n           | Inl (PP (prim.If ct cf), x # cntts # cntfs # ac # lista,\n                  bb) \\<Rightarrow>\n               \\<bottom>\n           | Inl (AStop, [], bb) \\<Rightarrow> \\<bottom>\n           | Inl (AStop, [x], xa, xb) \\<Rightarrow> {}\n           | Inl (AStop, x # a # lista, bb) \\<Rightarrow> \\<bottom>\n           | Inr (App lab f vs, \\<beta>, ve, b) \\<Rightarrow>\n               let fs = \\<aA> f \\<beta> ve;\n                   as = map (\\<lambda>v. \\<aA> v \\<beta> ve) vs;\n                   b' = \\<anb> b lab\n               in \\<Union>f'\\<in>fs. {Discr (Inl (f', as, ve, b'))}\n           | Inr (call.Let lab ls c', \\<beta>, ve, b) \\<Rightarrow>\n               let b' = \\<anb> b lab; \\<beta>' = \\<beta>(lab \\<mapsto> b');\n                   ve' =\n                     ve \\<union>. \\<Union>.map\n      (\\<lambda>(v, l). { (v, b') := \\<aA> (L l) \\<beta>' ve}.) ls\n               in {Discr (Inr (c', \\<beta>', ve', b'))})\\<cdot>\n       state\n       \\<subseteq> arg_poss p", "case (fields c \\<beta> ve b)"], ["proof (state)\nthis:\n  cstate = (c, \\<beta>, ve, b)\n\ngoal (1 subgoal):\n 1. \\<And>a b c d.\n       cstate = (a, b, c, d) \\<Longrightarrow>\n       (\\<Lambda> x.\n           case undiscr x of\n           Inl (PC (Lambda lab vs c, \\<beta>), as, ve, b) \\<Rightarrow>\n             if length vs = length as\n             then let \\<beta>' = \\<beta>(lab \\<mapsto> b);\n                      ve' =\n                        ve \\<union>. \\<Union>.map2\n         (\\<lambda>v. smap_singleton (v, b)) vs as\n                  in {Discr (Inr (c, \\<beta>', ve', b))}\n             else \\<bottom>\n           | Inl (PP (Plus c), [], bb) \\<Rightarrow> \\<bottom>\n           | Inl (PP (Plus c), [x], bb) \\<Rightarrow> \\<bottom>\n           | Inl (PP (Plus c), [x, xa], bb) \\<Rightarrow> \\<bottom>\n           | Inl (PP (Plus c), [x, xa, cnts], ve, b) \\<Rightarrow>\n               let b' = \\<anb> b c; \\<beta> = [c \\<mapsto> b]\n               in \\<Union>cnt\\<in>cnts. {Discr (Inl (cnt, [{}], ve, b'))}\n           | Inl (PP (Plus c), x # xa # cnts # ac # lista, bb) \\<Rightarrow>\n               \\<bottom>\n           | Inl (PP (prim.If ct cf), [], bb) \\<Rightarrow> \\<bottom>\n           | Inl (PP (prim.If ct cf), [x], bb) \\<Rightarrow> \\<bottom>\n           | Inl (PP (prim.If ct cf), [x, cntts], bb) \\<Rightarrow>\n               \\<bottom>\n           | Inl (PP (prim.If ct cf), [x, cntts, cntfs], ve,\n                  b) \\<Rightarrow>\n               (let b' = \\<anb> b ct; \\<beta> = [ct \\<mapsto> b]\n                in \\<Union>cnt\\<in>cntts.\n                      {Discr (Inl (cnt, [], ve, b'))}) \\<union>\n               (let b' = \\<anb> b cf; \\<beta> = [cf \\<mapsto> b]\n                in \\<Union>cnt\\<in>cntfs. {Discr (Inl (cnt, [], ve, b'))})\n           | Inl (PP (prim.If ct cf), x # cntts # cntfs # ac # lista,\n                  bb) \\<Rightarrow>\n               \\<bottom>\n           | Inl (AStop, [], bb) \\<Rightarrow> \\<bottom>\n           | Inl (AStop, [x], xa, xb) \\<Rightarrow> {}\n           | Inl (AStop, x # a # lista, bb) \\<Rightarrow> \\<bottom>\n           | Inr (App lab f vs, \\<beta>, ve, b) \\<Rightarrow>\n               let fs = \\<aA> f \\<beta> ve;\n                   as = map (\\<lambda>v. \\<aA> v \\<beta> ve) vs;\n                   b' = \\<anb> b lab\n               in \\<Union>f'\\<in>fs. {Discr (Inl (f', as, ve, b'))}\n           | Inr (call.Let lab ls c', \\<beta>, ve, b) \\<Rightarrow>\n               let b' = \\<anb> b lab; \\<beta>' = \\<beta>(lab \\<mapsto> b');\n                   ve' =\n                     ve \\<union>. \\<Union>.map\n      (\\<lambda>(v, l). { (v, b') := \\<aA> (L l) \\<beta>' ve}.) ls\n               in {Discr (Inr (c', \\<beta>', ve', b'))})\\<cdot>\n       state\n       \\<subseteq> arg_poss p", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Lambda> x.\n        case undiscr x of\n        Inl (PC (Lambda lab vs c, \\<beta>), as, ve, b) \\<Rightarrow>\n          if length vs = length as\n          then let \\<beta>' = \\<beta>(lab \\<mapsto> b);\n                   ve' =\n                     ve \\<union>. \\<Union>.map2\n      (\\<lambda>v. smap_singleton (v, b)) vs as\n               in {Discr (Inr (c, \\<beta>', ve', b))}\n          else \\<bottom>\n        | Inl (PP (Plus c), [], bb) \\<Rightarrow> \\<bottom>\n        | Inl (PP (Plus c), [x], bb) \\<Rightarrow> \\<bottom>\n        | Inl (PP (Plus c), [x, xa], bb) \\<Rightarrow> \\<bottom>\n        | Inl (PP (Plus c), [x, xa, cnts], ve, b) \\<Rightarrow>\n            let b' = \\<anb> b c; \\<beta> = [c \\<mapsto> b]\n            in \\<Union>cnt\\<in>cnts. {Discr (Inl (cnt, [{}], ve, b'))}\n        | Inl (PP (Plus c), x # xa # cnts # ac # lista, bb) \\<Rightarrow>\n            \\<bottom>\n        | Inl (PP (prim.If ct cf), [], bb) \\<Rightarrow> \\<bottom>\n        | Inl (PP (prim.If ct cf), [x], bb) \\<Rightarrow> \\<bottom>\n        | Inl (PP (prim.If ct cf), [x, cntts], bb) \\<Rightarrow> \\<bottom>\n        | Inl (PP (prim.If ct cf), [x, cntts, cntfs], ve, b) \\<Rightarrow>\n            (let b' = \\<anb> b ct; \\<beta> = [ct \\<mapsto> b]\n             in \\<Union>cnt\\<in>cntts.\n                   {Discr (Inl (cnt, [], ve, b'))}) \\<union>\n            (let b' = \\<anb> b cf; \\<beta> = [cf \\<mapsto> b]\n             in \\<Union>cnt\\<in>cntfs. {Discr (Inl (cnt, [], ve, b'))})\n        | Inl (PP (prim.If ct cf), x # cntts # cntfs # ac # lista,\n               bb) \\<Rightarrow>\n            \\<bottom>\n        | Inl (AStop, [], bb) \\<Rightarrow> \\<bottom>\n        | Inl (AStop, [x], xa, xb) \\<Rightarrow> {}\n        | Inl (AStop, x # a # lista, bb) \\<Rightarrow> \\<bottom>\n        | Inr (App lab f vs, \\<beta>, ve, b) \\<Rightarrow>\n            let fs = \\<aA> f \\<beta> ve;\n                as = map (\\<lambda>v. \\<aA> v \\<beta> ve) vs;\n                b' = \\<anb> b lab\n            in \\<Union>f'\\<in>fs. {Discr (Inl (f', as, ve, b'))}\n        | Inr (call.Let lab ls c', \\<beta>, ve, b) \\<Rightarrow>\n            let b' = \\<anb> b lab; \\<beta>' = \\<beta>(lab \\<mapsto> b');\n                ve' =\n                  ve \\<union>. \\<Union>.map\n   (\\<lambda>(v, l). { (v, b') := \\<aA> (L l) \\<beta>' ve}.) ls\n            in {Discr (Inr (c', \\<beta>', ve', b'))})\\<cdot>\n    state\n    \\<subseteq> arg_poss p", "using Discr Inr fields state"], ["proof (prove)\nusing this:\n  state = Discr state'\n  state' = Inr cstate\n  cstate = (c, \\<beta>, ve, b)\n  state \\<in> arg_poss p\n\ngoal (1 subgoal):\n 1. (\\<Lambda> x.\n        case undiscr x of\n        Inl (PC (Lambda lab vs c, \\<beta>), as, ve, b) \\<Rightarrow>\n          if length vs = length as\n          then let \\<beta>' = \\<beta>(lab \\<mapsto> b);\n                   ve' =\n                     ve \\<union>. \\<Union>.map2\n      (\\<lambda>v. smap_singleton (v, b)) vs as\n               in {Discr (Inr (c, \\<beta>', ve', b))}\n          else \\<bottom>\n        | Inl (PP (Plus c), [], bb) \\<Rightarrow> \\<bottom>\n        | Inl (PP (Plus c), [x], bb) \\<Rightarrow> \\<bottom>\n        | Inl (PP (Plus c), [x, xa], bb) \\<Rightarrow> \\<bottom>\n        | Inl (PP (Plus c), [x, xa, cnts], ve, b) \\<Rightarrow>\n            let b' = \\<anb> b c; \\<beta> = [c \\<mapsto> b]\n            in \\<Union>cnt\\<in>cnts. {Discr (Inl (cnt, [{}], ve, b'))}\n        | Inl (PP (Plus c), x # xa # cnts # ac # lista, bb) \\<Rightarrow>\n            \\<bottom>\n        | Inl (PP (prim.If ct cf), [], bb) \\<Rightarrow> \\<bottom>\n        | Inl (PP (prim.If ct cf), [x], bb) \\<Rightarrow> \\<bottom>\n        | Inl (PP (prim.If ct cf), [x, cntts], bb) \\<Rightarrow> \\<bottom>\n        | Inl (PP (prim.If ct cf), [x, cntts, cntfs], ve, b) \\<Rightarrow>\n            (let b' = \\<anb> b ct; \\<beta> = [ct \\<mapsto> b]\n             in \\<Union>cnt\\<in>cntts.\n                   {Discr (Inl (cnt, [], ve, b'))}) \\<union>\n            (let b' = \\<anb> b cf; \\<beta> = [cf \\<mapsto> b]\n             in \\<Union>cnt\\<in>cntfs. {Discr (Inl (cnt, [], ve, b'))})\n        | Inl (PP (prim.If ct cf), x # cntts # cntfs # ac # lista,\n               bb) \\<Rightarrow>\n            \\<bottom>\n        | Inl (AStop, [], bb) \\<Rightarrow> \\<bottom>\n        | Inl (AStop, [x], xa, xb) \\<Rightarrow> {}\n        | Inl (AStop, x # a # lista, bb) \\<Rightarrow> \\<bottom>\n        | Inr (App lab f vs, \\<beta>, ve, b) \\<Rightarrow>\n            let fs = \\<aA> f \\<beta> ve;\n                as = map (\\<lambda>v. \\<aA> v \\<beta> ve) vs;\n                b' = \\<anb> b lab\n            in \\<Union>f'\\<in>fs. {Discr (Inl (f', as, ve, b'))}\n        | Inr (call.Let lab ls c', \\<beta>, ve, b) \\<Rightarrow>\n            let b' = \\<anb> b lab; \\<beta>' = \\<beta>(lab \\<mapsto> b');\n                ve' =\n                  ve \\<union>. \\<Union>.map\n   (\\<lambda>(v, l). { (v, b') := \\<aA> (L l) \\<beta>' ve}.) ls\n            in {Discr (Inr (c', \\<beta>', ve', b'))})\\<cdot>\n    state\n    \\<subseteq> arg_poss p", "proof(cases c, auto simp add:HOL.Let_def simp del:evalV_a.simps)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x11 x12 x13 f'.\n       \\<lbrakk>Discr (Inr (App x11 x12 x13, \\<beta>, ve, b))\n                \\<in> arg_poss p;\n        c = App x11 x12 x13;\n        state = Discr (Inr (App x11 x12 x13, \\<beta>, ve, b));\n        state' = Inr (App x11 x12 x13, \\<beta>, ve, b);\n        cstate = (App x11 x12 x13, \\<beta>, ve, b);\n        f' \\<in> \\<aA> x12 \\<beta> ve\\<rbrakk>\n       \\<Longrightarrow> Discr\n                          (Inl (f',\n                                map (\\<lambda>v. \\<aA> v \\<beta> ve) x13,\n                                ve, \\<anb> b x11))\n                         \\<in> arg_poss p\n 2. \\<And>x21 x22 x23.\n       \\<lbrakk>Discr (Inr (call.Let x21 x22 x23, \\<beta>, ve, b))\n                \\<in> arg_poss p;\n        c = call.Let x21 x22 x23;\n        state = Discr (Inr (call.Let x21 x22 x23, \\<beta>, ve, b));\n        state' = Inr (call.Let x21 x22 x23, \\<beta>, ve, b);\n        cstate = (call.Let x21 x22 x23, \\<beta>, ve, b)\\<rbrakk>\n       \\<Longrightarrow> Discr\n                          (Inr (x23, \\<beta>(x21 \\<mapsto> \\<anb> b x21),\n                                ve \\<union>. \\<Union>.map\n                 (\\<lambda>(v, l).\n                     { (v, \\<anb> b\n                            x21) := \\<aA> (L l)\n                                     (\\<beta>(x21 \\<mapsto> \\<anb> b x21))\n                                     ve}.)\n                 x22,\n                                \\<anb> b x21))\n                         \\<in> arg_poss p", "txt \\<open>Case App\\<close>"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x11 x12 x13 f'.\n       \\<lbrakk>Discr (Inr (App x11 x12 x13, \\<beta>, ve, b))\n                \\<in> arg_poss p;\n        c = App x11 x12 x13;\n        state = Discr (Inr (App x11 x12 x13, \\<beta>, ve, b));\n        state' = Inr (App x11 x12 x13, \\<beta>, ve, b);\n        cstate = (App x11 x12 x13, \\<beta>, ve, b);\n        f' \\<in> \\<aA> x12 \\<beta> ve\\<rbrakk>\n       \\<Longrightarrow> Discr\n                          (Inl (f',\n                                map (\\<lambda>v. \\<aA> v \\<beta> ve) x13,\n                                ve, \\<anb> b x11))\n                         \\<in> arg_poss p\n 2. \\<And>x21 x22 x23.\n       \\<lbrakk>Discr (Inr (call.Let x21 x22 x23, \\<beta>, ve, b))\n                \\<in> arg_poss p;\n        c = call.Let x21 x22 x23;\n        state = Discr (Inr (call.Let x21 x22 x23, \\<beta>, ve, b));\n        state' = Inr (call.Let x21 x22 x23, \\<beta>, ve, b);\n        cstate = (call.Let x21 x22 x23, \\<beta>, ve, b)\\<rbrakk>\n       \\<Longrightarrow> Discr\n                          (Inr (x23, \\<beta>(x21 \\<mapsto> \\<anb> b x21),\n                                ve \\<union>. \\<Union>.map\n                 (\\<lambda>(v, l).\n                     { (v, \\<anb> b\n                            x21) := \\<aA> (L l)\n                                     (\\<beta>(x21 \\<mapsto> \\<anb> b x21))\n                                     ve}.)\n                 x22,\n                                \\<anb> b x21))\n                         \\<in> arg_poss p", "fix l d ds f"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x11 x12 x13 f'.\n       \\<lbrakk>Discr (Inr (App x11 x12 x13, \\<beta>, ve, b))\n                \\<in> arg_poss p;\n        c = App x11 x12 x13;\n        state = Discr (Inr (App x11 x12 x13, \\<beta>, ve, b));\n        state' = Inr (App x11 x12 x13, \\<beta>, ve, b);\n        cstate = (App x11 x12 x13, \\<beta>, ve, b);\n        f' \\<in> \\<aA> x12 \\<beta> ve\\<rbrakk>\n       \\<Longrightarrow> Discr\n                          (Inl (f',\n                                map (\\<lambda>v. \\<aA> v \\<beta> ve) x13,\n                                ve, \\<anb> b x11))\n                         \\<in> arg_poss p\n 2. \\<And>x21 x22 x23.\n       \\<lbrakk>Discr (Inr (call.Let x21 x22 x23, \\<beta>, ve, b))\n                \\<in> arg_poss p;\n        c = call.Let x21 x22 x23;\n        state = Discr (Inr (call.Let x21 x22 x23, \\<beta>, ve, b));\n        state' = Inr (call.Let x21 x22 x23, \\<beta>, ve, b);\n        cstate = (call.Let x21 x22 x23, \\<beta>, ve, b)\\<rbrakk>\n       \\<Longrightarrow> Discr\n                          (Inr (x23, \\<beta>(x21 \\<mapsto> \\<anb> b x21),\n                                ve \\<union>. \\<Union>.map\n                 (\\<lambda>(v, l).\n                     { (v, \\<anb> b\n                            x21) := \\<aA> (L l)\n                                     (\\<beta>(x21 \\<mapsto> \\<anb> b x21))\n                                     ve}.)\n                 x22,\n                                \\<anb> b x21))\n                         \\<in> arg_poss p", "assume arg: \"Discr (Inr (App l d ds, \\<beta>, ve, b)) \\<in> arg_poss p\"\n       and f: \"f \\<in> \\<aA> d \\<beta> ve\""], ["proof (state)\nthis:\n  Discr (Inr (App l d ds, \\<beta>, ve, b)) \\<in> arg_poss p\n  f \\<in> \\<aA> d \\<beta> ve\n\ngoal (2 subgoals):\n 1. \\<And>x11 x12 x13 f'.\n       \\<lbrakk>Discr (Inr (App x11 x12 x13, \\<beta>, ve, b))\n                \\<in> arg_poss p;\n        c = App x11 x12 x13;\n        state = Discr (Inr (App x11 x12 x13, \\<beta>, ve, b));\n        state' = Inr (App x11 x12 x13, \\<beta>, ve, b);\n        cstate = (App x11 x12 x13, \\<beta>, ve, b);\n        f' \\<in> \\<aA> x12 \\<beta> ve\\<rbrakk>\n       \\<Longrightarrow> Discr\n                          (Inl (f',\n                                map (\\<lambda>v. \\<aA> v \\<beta> ve) x13,\n                                ve, \\<anb> b x11))\n                         \\<in> arg_poss p\n 2. \\<And>x21 x22 x23.\n       \\<lbrakk>Discr (Inr (call.Let x21 x22 x23, \\<beta>, ve, b))\n                \\<in> arg_poss p;\n        c = call.Let x21 x22 x23;\n        state = Discr (Inr (call.Let x21 x22 x23, \\<beta>, ve, b));\n        state' = Inr (call.Let x21 x22 x23, \\<beta>, ve, b);\n        cstate = (call.Let x21 x22 x23, \\<beta>, ve, b)\\<rbrakk>\n       \\<Longrightarrow> Discr\n                          (Inr (x23, \\<beta>(x21 \\<mapsto> \\<anb> b x21),\n                                ve \\<union>. \\<Union>.map\n                 (\\<lambda>(v, l).\n                     { (v, \\<anb> b\n                            x21) := \\<aA> (L l)\n                                     (\\<beta>(x21 \\<mapsto> \\<anb> b x21))\n                                     ve}.)\n                 x22,\n                                \\<anb> b x21))\n                         \\<in> arg_poss p", "hence c: \"App l d ds \\<in> calls p\"\n       and d: \"d \\<in> vals p\"\n       and ds: \"set ds \\<subseteq> vals p\"\n       and beta: \"\\<beta> \\<in> maps_over (labels p) UNIV\"\n       and ve: \"ve \\<in> smaps_over (vars p \\<times> UNIV) (proc_poss p)\""], ["proof (prove)\nusing this:\n  Discr (Inr (App l d ds, \\<beta>, ve, b)) \\<in> arg_poss p\n  f \\<in> \\<aA> d \\<beta> ve\n\ngoal (1 subgoal):\n 1. (App l d ds \\<in> calls p &&& d \\<in> vals p) &&&\n    set ds \\<subseteq> vals p &&&\n    \\<beta> \\<in> maps_over (labels p) UNIV &&&\n    ve \\<in> smaps_over (vars p \\<times> UNIV) (proc_poss p)", "by (auto simp add: arg_poss_def cstate_poss_def call_list_lengths_def dest: app1 app2)"], ["proof (state)\nthis:\n  App l d ds \\<in> calls p\n  d \\<in> vals p\n  set ds \\<subseteq> vals p\n  \\<beta> \\<in> maps_over (labels p) UNIV\n  ve \\<in> smaps_over (vars p \\<times> UNIV) (proc_poss p)\n\ngoal (2 subgoals):\n 1. \\<And>x11 x12 x13 f'.\n       \\<lbrakk>Discr (Inr (App x11 x12 x13, \\<beta>, ve, b))\n                \\<in> arg_poss p;\n        c = App x11 x12 x13;\n        state = Discr (Inr (App x11 x12 x13, \\<beta>, ve, b));\n        state' = Inr (App x11 x12 x13, \\<beta>, ve, b);\n        cstate = (App x11 x12 x13, \\<beta>, ve, b);\n        f' \\<in> \\<aA> x12 \\<beta> ve\\<rbrakk>\n       \\<Longrightarrow> Discr\n                          (Inl (f',\n                                map (\\<lambda>v. \\<aA> v \\<beta> ve) x13,\n                                ve, \\<anb> b x11))\n                         \\<in> arg_poss p\n 2. \\<And>x21 x22 x23.\n       \\<lbrakk>Discr (Inr (call.Let x21 x22 x23, \\<beta>, ve, b))\n                \\<in> arg_poss p;\n        c = call.Let x21 x22 x23;\n        state = Discr (Inr (call.Let x21 x22 x23, \\<beta>, ve, b));\n        state' = Inr (call.Let x21 x22 x23, \\<beta>, ve, b);\n        cstate = (call.Let x21 x22 x23, \\<beta>, ve, b)\\<rbrakk>\n       \\<Longrightarrow> Discr\n                          (Inr (x23, \\<beta>(x21 \\<mapsto> \\<anb> b x21),\n                                ve \\<union>. \\<Union>.map\n                 (\\<lambda>(v, l).\n                     { (v, \\<anb> b\n                            x21) := \\<aA> (L l)\n                                     (\\<beta>(x21 \\<mapsto> \\<anb> b x21))\n                                     ve}.)\n                 x22,\n                                \\<anb> b x21))\n                         \\<in> arg_poss p", "have len: \"length ds \\<in> call_list_lengths p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length ds \\<in> call_list_lengths p", "by (auto intro: rev_image_eqI[OF c] simp add: call_list_lengths_def)"], ["proof (state)\nthis:\n  length ds \\<in> call_list_lengths p\n\ngoal (2 subgoals):\n 1. \\<And>x11 x12 x13 f'.\n       \\<lbrakk>Discr (Inr (App x11 x12 x13, \\<beta>, ve, b))\n                \\<in> arg_poss p;\n        c = App x11 x12 x13;\n        state = Discr (Inr (App x11 x12 x13, \\<beta>, ve, b));\n        state' = Inr (App x11 x12 x13, \\<beta>, ve, b);\n        cstate = (App x11 x12 x13, \\<beta>, ve, b);\n        f' \\<in> \\<aA> x12 \\<beta> ve\\<rbrakk>\n       \\<Longrightarrow> Discr\n                          (Inl (f',\n                                map (\\<lambda>v. \\<aA> v \\<beta> ve) x13,\n                                ve, \\<anb> b x11))\n                         \\<in> arg_poss p\n 2. \\<And>x21 x22 x23.\n       \\<lbrakk>Discr (Inr (call.Let x21 x22 x23, \\<beta>, ve, b))\n                \\<in> arg_poss p;\n        c = call.Let x21 x22 x23;\n        state = Discr (Inr (call.Let x21 x22 x23, \\<beta>, ve, b));\n        state' = Inr (call.Let x21 x22 x23, \\<beta>, ve, b);\n        cstate = (call.Let x21 x22 x23, \\<beta>, ve, b)\\<rbrakk>\n       \\<Longrightarrow> Discr\n                          (Inr (x23, \\<beta>(x21 \\<mapsto> \\<anb> b x21),\n                                ve \\<union>. \\<Union>.map\n                 (\\<lambda>(v, l).\n                     { (v, \\<anb> b\n                            x21) := \\<aA> (L l)\n                                     (\\<beta>(x21 \\<mapsto> \\<anb> b x21))\n                                     ve}.)\n                 x22,\n                                \\<anb> b x21))\n                         \\<in> arg_poss p", "have \"f \\<in> proc_poss p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<in> proc_poss p", "using f d ve beta"], ["proof (prove)\nusing this:\n  f \\<in> \\<aA> d \\<beta> ve\n  d \\<in> vals p\n  ve \\<in> smaps_over (vars p \\<times> UNIV) (proc_poss p)\n  \\<beta> \\<in> maps_over (labels p) UNIV\n\ngoal (1 subgoal):\n 1. f \\<in> proc_poss p", "by (rule evalV_possible)"], ["proof (state)\nthis:\n  f \\<in> proc_poss p\n\ngoal (2 subgoals):\n 1. \\<And>x11 x12 x13 f'.\n       \\<lbrakk>Discr (Inr (App x11 x12 x13, \\<beta>, ve, b))\n                \\<in> arg_poss p;\n        c = App x11 x12 x13;\n        state = Discr (Inr (App x11 x12 x13, \\<beta>, ve, b));\n        state' = Inr (App x11 x12 x13, \\<beta>, ve, b);\n        cstate = (App x11 x12 x13, \\<beta>, ve, b);\n        f' \\<in> \\<aA> x12 \\<beta> ve\\<rbrakk>\n       \\<Longrightarrow> Discr\n                          (Inl (f',\n                                map (\\<lambda>v. \\<aA> v \\<beta> ve) x13,\n                                ve, \\<anb> b x11))\n                         \\<in> arg_poss p\n 2. \\<And>x21 x22 x23.\n       \\<lbrakk>Discr (Inr (call.Let x21 x22 x23, \\<beta>, ve, b))\n                \\<in> arg_poss p;\n        c = call.Let x21 x22 x23;\n        state = Discr (Inr (call.Let x21 x22 x23, \\<beta>, ve, b));\n        state' = Inr (call.Let x21 x22 x23, \\<beta>, ve, b);\n        cstate = (call.Let x21 x22 x23, \\<beta>, ve, b)\\<rbrakk>\n       \\<Longrightarrow> Discr\n                          (Inr (x23, \\<beta>(x21 \\<mapsto> \\<anb> b x21),\n                                ve \\<union>. \\<Union>.map\n                 (\\<lambda>(v, l).\n                     { (v, \\<anb> b\n                            x21) := \\<aA> (L l)\n                                     (\\<beta>(x21 \\<mapsto> \\<anb> b x21))\n                                     ve}.)\n                 x22,\n                                \\<anb> b x21))\n                         \\<in> arg_poss p", "moreover"], ["proof (state)\nthis:\n  f \\<in> proc_poss p\n\ngoal (2 subgoals):\n 1. \\<And>x11 x12 x13 f'.\n       \\<lbrakk>Discr (Inr (App x11 x12 x13, \\<beta>, ve, b))\n                \\<in> arg_poss p;\n        c = App x11 x12 x13;\n        state = Discr (Inr (App x11 x12 x13, \\<beta>, ve, b));\n        state' = Inr (App x11 x12 x13, \\<beta>, ve, b);\n        cstate = (App x11 x12 x13, \\<beta>, ve, b);\n        f' \\<in> \\<aA> x12 \\<beta> ve\\<rbrakk>\n       \\<Longrightarrow> Discr\n                          (Inl (f',\n                                map (\\<lambda>v. \\<aA> v \\<beta> ve) x13,\n                                ve, \\<anb> b x11))\n                         \\<in> arg_poss p\n 2. \\<And>x21 x22 x23.\n       \\<lbrakk>Discr (Inr (call.Let x21 x22 x23, \\<beta>, ve, b))\n                \\<in> arg_poss p;\n        c = call.Let x21 x22 x23;\n        state = Discr (Inr (call.Let x21 x22 x23, \\<beta>, ve, b));\n        state' = Inr (call.Let x21 x22 x23, \\<beta>, ve, b);\n        cstate = (call.Let x21 x22 x23, \\<beta>, ve, b)\\<rbrakk>\n       \\<Longrightarrow> Discr\n                          (Inr (x23, \\<beta>(x21 \\<mapsto> \\<anb> b x21),\n                                ve \\<union>. \\<Union>.map\n                 (\\<lambda>(v, l).\n                     { (v, \\<anb> b\n                            x21) := \\<aA> (L l)\n                                     (\\<beta>(x21 \\<mapsto> \\<anb> b x21))\n                                     ve}.)\n                 x22,\n                                \\<anb> b x21))\n                         \\<in> arg_poss p", "have \"map (\\<lambda>v. \\<aA> v \\<beta> ve) ds \\<in> NList (Pow (proc_poss p)) (call_list_lengths p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>v. \\<aA> v \\<beta> ve) ds\n    \\<in> NList (Pow (proc_poss p)) (call_list_lengths p)", "using ds len"], ["proof (prove)\nusing this:\n  set ds \\<subseteq> vals p\n  length ds \\<in> call_list_lengths p\n\ngoal (1 subgoal):\n 1. map (\\<lambda>v. \\<aA> v \\<beta> ve) ds\n    \\<in> NList (Pow (proc_poss p)) (call_list_lengths p)", "unfolding NList_def"], ["proof (prove)\nusing this:\n  set ds \\<subseteq> vals p\n  length ds \\<in> call_list_lengths p\n\ngoal (1 subgoal):\n 1. map (\\<lambda>v. \\<aA> v \\<beta> ve) ds\n    \\<in> \\<Union> (nList (Pow (proc_poss p)) ` call_list_lengths p)", "by (auto simp add:nList_def intro!: evalV_possible[OF _ _ ve beta])"], ["proof (state)\nthis:\n  map (\\<lambda>v. \\<aA> v \\<beta> ve) ds\n  \\<in> NList (Pow (proc_poss p)) (call_list_lengths p)\n\ngoal (2 subgoals):\n 1. \\<And>x11 x12 x13 f'.\n       \\<lbrakk>Discr (Inr (App x11 x12 x13, \\<beta>, ve, b))\n                \\<in> arg_poss p;\n        c = App x11 x12 x13;\n        state = Discr (Inr (App x11 x12 x13, \\<beta>, ve, b));\n        state' = Inr (App x11 x12 x13, \\<beta>, ve, b);\n        cstate = (App x11 x12 x13, \\<beta>, ve, b);\n        f' \\<in> \\<aA> x12 \\<beta> ve\\<rbrakk>\n       \\<Longrightarrow> Discr\n                          (Inl (f',\n                                map (\\<lambda>v. \\<aA> v \\<beta> ve) x13,\n                                ve, \\<anb> b x11))\n                         \\<in> arg_poss p\n 2. \\<And>x21 x22 x23.\n       \\<lbrakk>Discr (Inr (call.Let x21 x22 x23, \\<beta>, ve, b))\n                \\<in> arg_poss p;\n        c = call.Let x21 x22 x23;\n        state = Discr (Inr (call.Let x21 x22 x23, \\<beta>, ve, b));\n        state' = Inr (call.Let x21 x22 x23, \\<beta>, ve, b);\n        cstate = (call.Let x21 x22 x23, \\<beta>, ve, b)\\<rbrakk>\n       \\<Longrightarrow> Discr\n                          (Inr (x23, \\<beta>(x21 \\<mapsto> \\<anb> b x21),\n                                ve \\<union>. \\<Union>.map\n                 (\\<lambda>(v, l).\n                     { (v, \\<anb> b\n                            x21) := \\<aA> (L l)\n                                     (\\<beta>(x21 \\<mapsto> \\<anb> b x21))\n                                     ve}.)\n                 x22,\n                                \\<anb> b x21))\n                         \\<in> arg_poss p", "ultimately"], ["proof (chain)\npicking this:\n  f \\<in> proc_poss p\n  map (\\<lambda>v. \\<aA> v \\<beta> ve) ds\n  \\<in> NList (Pow (proc_poss p)) (call_list_lengths p)", "have \"(f, map (\\<lambda>v. \\<aA> v \\<beta> ve) ds, ve, \\<anb> b l) \\<in> fstate_poss p\" (is \"?fstate \\<in> _\")"], ["proof (prove)\nusing this:\n  f \\<in> proc_poss p\n  map (\\<lambda>v. \\<aA> v \\<beta> ve) ds\n  \\<in> NList (Pow (proc_poss p)) (call_list_lengths p)\n\ngoal (1 subgoal):\n 1. (f, map (\\<lambda>v. \\<aA> v \\<beta> ve) ds, ve, \\<anb> b l)\n    \\<in> fstate_poss p", "using ve"], ["proof (prove)\nusing this:\n  f \\<in> proc_poss p\n  map (\\<lambda>v. \\<aA> v \\<beta> ve) ds\n  \\<in> NList (Pow (proc_poss p)) (call_list_lengths p)\n  ve \\<in> smaps_over (vars p \\<times> UNIV) (proc_poss p)\n\ngoal (1 subgoal):\n 1. (f, map (\\<lambda>v. \\<aA> v \\<beta> ve) ds, ve, \\<anb> b l)\n    \\<in> fstate_poss p", "unfolding fstate_poss_def"], ["proof (prove)\nusing this:\n  f \\<in> proc_poss p\n  map (\\<lambda>v. \\<aA> v \\<beta> ve) ds\n  \\<in> NList (Pow (proc_poss p)) (call_list_lengths p)\n  ve \\<in> smaps_over (vars p \\<times> UNIV) (proc_poss p)\n\ngoal (1 subgoal):\n 1. (f, map (\\<lambda>v. \\<aA> v \\<beta> ve) ds, ve, \\<anb> b l)\n    \\<in> proc_poss p \\<times>\n          NList (Pow (proc_poss p)) (call_list_lengths p) \\<times>\n          smaps_over (vars p \\<times> UNIV) (proc_poss p) \\<times> UNIV", "by simp"], ["proof (state)\nthis:\n  (f, map (\\<lambda>v. \\<aA> v \\<beta> ve) ds, ve, \\<anb> b l)\n  \\<in> fstate_poss p\n\ngoal (2 subgoals):\n 1. \\<And>x11 x12 x13 f'.\n       \\<lbrakk>Discr (Inr (App x11 x12 x13, \\<beta>, ve, b))\n                \\<in> arg_poss p;\n        c = App x11 x12 x13;\n        state = Discr (Inr (App x11 x12 x13, \\<beta>, ve, b));\n        state' = Inr (App x11 x12 x13, \\<beta>, ve, b);\n        cstate = (App x11 x12 x13, \\<beta>, ve, b);\n        f' \\<in> \\<aA> x12 \\<beta> ve\\<rbrakk>\n       \\<Longrightarrow> Discr\n                          (Inl (f',\n                                map (\\<lambda>v. \\<aA> v \\<beta> ve) x13,\n                                ve, \\<anb> b x11))\n                         \\<in> arg_poss p\n 2. \\<And>x21 x22 x23.\n       \\<lbrakk>Discr (Inr (call.Let x21 x22 x23, \\<beta>, ve, b))\n                \\<in> arg_poss p;\n        c = call.Let x21 x22 x23;\n        state = Discr (Inr (call.Let x21 x22 x23, \\<beta>, ve, b));\n        state' = Inr (call.Let x21 x22 x23, \\<beta>, ve, b);\n        cstate = (call.Let x21 x22 x23, \\<beta>, ve, b)\\<rbrakk>\n       \\<Longrightarrow> Discr\n                          (Inr (x23, \\<beta>(x21 \\<mapsto> \\<anb> b x21),\n                                ve \\<union>. \\<Union>.map\n                 (\\<lambda>(v, l).\n                     { (v, \\<anb> b\n                            x21) := \\<aA> (L l)\n                                     (\\<beta>(x21 \\<mapsto> \\<anb> b x21))\n                                     ve}.)\n                 x22,\n                                \\<anb> b x21))\n                         \\<in> arg_poss p", "thus \"Discr (Inl ?fstate) \\<in> arg_poss p\""], ["proof (prove)\nusing this:\n  (f, map (\\<lambda>v. \\<aA> v \\<beta> ve) ds, ve, \\<anb> b l)\n  \\<in> fstate_poss p\n\ngoal (1 subgoal):\n 1. Discr (Inl (f, map (\\<lambda>v. \\<aA> v \\<beta> ve) ds, ve, \\<anb> b l))\n    \\<in> arg_poss p", "unfolding arg_poss_def"], ["proof (prove)\nusing this:\n  (f, map (\\<lambda>v. \\<aA> v \\<beta> ve) ds, ve, \\<anb> b l)\n  \\<in> fstate_poss p\n\ngoal (1 subgoal):\n 1. Discr (Inl (f, map (\\<lambda>v. \\<aA> v \\<beta> ve) ds, ve, \\<anb> b l))\n    \\<in> Discr ` (fstate_poss p <+> cstate_poss p)", "by auto"], ["proof (state)\nthis:\n  Discr (Inl (f, map (\\<lambda>v. \\<aA> v \\<beta> ve) ds, ve, \\<anb> b l))\n  \\<in> arg_poss p\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       \\<lbrakk>Discr (Inr (call.Let x21 x22 x23, \\<beta>, ve, b))\n                \\<in> arg_poss p;\n        c = call.Let x21 x22 x23;\n        state = Discr (Inr (call.Let x21 x22 x23, \\<beta>, ve, b));\n        state' = Inr (call.Let x21 x22 x23, \\<beta>, ve, b);\n        cstate = (call.Let x21 x22 x23, \\<beta>, ve, b)\\<rbrakk>\n       \\<Longrightarrow> Discr\n                          (Inr (x23, \\<beta>(x21 \\<mapsto> \\<anb> b x21),\n                                ve \\<union>. \\<Union>.map\n                 (\\<lambda>(v, l).\n                     { (v, \\<anb> b\n                            x21) := \\<aA> (L l)\n                                     (\\<beta>(x21 \\<mapsto> \\<anb> b x21))\n                                     ve}.)\n                 x22,\n                                \\<anb> b x21))\n                         \\<in> arg_poss p", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       \\<lbrakk>Discr (Inr (call.Let x21 x22 x23, \\<beta>, ve, b))\n                \\<in> arg_poss p;\n        c = call.Let x21 x22 x23;\n        state = Discr (Inr (call.Let x21 x22 x23, \\<beta>, ve, b));\n        state' = Inr (call.Let x21 x22 x23, \\<beta>, ve, b);\n        cstate = (call.Let x21 x22 x23, \\<beta>, ve, b)\\<rbrakk>\n       \\<Longrightarrow> Discr\n                          (Inr (x23, \\<beta>(x21 \\<mapsto> \\<anb> b x21),\n                                ve \\<union>. \\<Union>.map\n                 (\\<lambda>(v, l).\n                     { (v, \\<anb> b\n                            x21) := \\<aA> (L l)\n                                     (\\<beta>(x21 \\<mapsto> \\<anb> b x21))\n                                     ve}.)\n                 x22,\n                                \\<anb> b x21))\n                         \\<in> arg_poss p", "txt \\<open>Case Let\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       \\<lbrakk>Discr (Inr (call.Let x21 x22 x23, \\<beta>, ve, b))\n                \\<in> arg_poss p;\n        c = call.Let x21 x22 x23;\n        state = Discr (Inr (call.Let x21 x22 x23, \\<beta>, ve, b));\n        state' = Inr (call.Let x21 x22 x23, \\<beta>, ve, b);\n        cstate = (call.Let x21 x22 x23, \\<beta>, ve, b)\\<rbrakk>\n       \\<Longrightarrow> Discr\n                          (Inr (x23, \\<beta>(x21 \\<mapsto> \\<anb> b x21),\n                                ve \\<union>. \\<Union>.map\n                 (\\<lambda>(v, l).\n                     { (v, \\<anb> b\n                            x21) := \\<aA> (L l)\n                                     (\\<beta>(x21 \\<mapsto> \\<anb> b x21))\n                                     ve}.)\n                 x22,\n                                \\<anb> b x21))\n                         \\<in> arg_poss p", "fix l binds c'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       \\<lbrakk>Discr (Inr (call.Let x21 x22 x23, \\<beta>, ve, b))\n                \\<in> arg_poss p;\n        c = call.Let x21 x22 x23;\n        state = Discr (Inr (call.Let x21 x22 x23, \\<beta>, ve, b));\n        state' = Inr (call.Let x21 x22 x23, \\<beta>, ve, b);\n        cstate = (call.Let x21 x22 x23, \\<beta>, ve, b)\\<rbrakk>\n       \\<Longrightarrow> Discr\n                          (Inr (x23, \\<beta>(x21 \\<mapsto> \\<anb> b x21),\n                                ve \\<union>. \\<Union>.map\n                 (\\<lambda>(v, l).\n                     { (v, \\<anb> b\n                            x21) := \\<aA> (L l)\n                                     (\\<beta>(x21 \\<mapsto> \\<anb> b x21))\n                                     ve}.)\n                 x22,\n                                \\<anb> b x21))\n                         \\<in> arg_poss p", "assume arg: \"Discr (Inr (Let l binds c', \\<beta>, ve, b)) \\<in> arg_poss p\""], ["proof (state)\nthis:\n  Discr (Inr (call.Let l binds c', \\<beta>, ve, b)) \\<in> arg_poss p\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       \\<lbrakk>Discr (Inr (call.Let x21 x22 x23, \\<beta>, ve, b))\n                \\<in> arg_poss p;\n        c = call.Let x21 x22 x23;\n        state = Discr (Inr (call.Let x21 x22 x23, \\<beta>, ve, b));\n        state' = Inr (call.Let x21 x22 x23, \\<beta>, ve, b);\n        cstate = (call.Let x21 x22 x23, \\<beta>, ve, b)\\<rbrakk>\n       \\<Longrightarrow> Discr\n                          (Inr (x23, \\<beta>(x21 \\<mapsto> \\<anb> b x21),\n                                ve \\<union>. \\<Union>.map\n                 (\\<lambda>(v, l).\n                     { (v, \\<anb> b\n                            x21) := \\<aA> (L l)\n                                     (\\<beta>(x21 \\<mapsto> \\<anb> b x21))\n                                     ve}.)\n                 x22,\n                                \\<anb> b x21))\n                         \\<in> arg_poss p", "hence l: \"l \\<in> labels p\"\n       and c': \"c' \\<in> calls p\"\n       and vars: \"fst ` set binds \\<subseteq> vars p\"\n       and ls: \"snd ` set binds \\<subseteq> lambdas p\"\n       and beta: \"\\<beta> \\<in> maps_over (labels p) UNIV\"\n       and ve: \"ve \\<in> smaps_over (vars p \\<times> UNIV) (proc_poss p)\""], ["proof (prove)\nusing this:\n  Discr (Inr (call.Let l binds c', \\<beta>, ve, b)) \\<in> arg_poss p\n\ngoal (1 subgoal):\n 1. (l \\<in> labels p &&&\n     c' \\<in> calls p &&& fst ` set binds \\<subseteq> vars p) &&&\n    snd ` set binds \\<subseteq> lambdas p &&&\n    \\<beta> \\<in> maps_over (labels p) UNIV &&&\n    ve \\<in> smaps_over (vars p \\<times> UNIV) (proc_poss p)", "by (auto simp add: arg_poss_def cstate_poss_def call_list_lengths_def\n              dest:let1 let2 let3 let4)"], ["proof (state)\nthis:\n  l \\<in> labels p\n  c' \\<in> calls p\n  fst ` set binds \\<subseteq> vars p\n  snd ` set binds \\<subseteq> lambdas p\n  \\<beta> \\<in> maps_over (labels p) UNIV\n  ve \\<in> smaps_over (vars p \\<times> UNIV) (proc_poss p)\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       \\<lbrakk>Discr (Inr (call.Let x21 x22 x23, \\<beta>, ve, b))\n                \\<in> arg_poss p;\n        c = call.Let x21 x22 x23;\n        state = Discr (Inr (call.Let x21 x22 x23, \\<beta>, ve, b));\n        state' = Inr (call.Let x21 x22 x23, \\<beta>, ve, b);\n        cstate = (call.Let x21 x22 x23, \\<beta>, ve, b)\\<rbrakk>\n       \\<Longrightarrow> Discr\n                          (Inr (x23, \\<beta>(x21 \\<mapsto> \\<anb> b x21),\n                                ve \\<union>. \\<Union>.map\n                 (\\<lambda>(v, l).\n                     { (v, \\<anb> b\n                            x21) := \\<aA> (L l)\n                                     (\\<beta>(x21 \\<mapsto> \\<anb> b x21))\n                                     ve}.)\n                 x22,\n                                \\<anb> b x21))\n                         \\<in> arg_poss p", "have beta': \"\\<beta>(l \\<mapsto> \\<anb> b l) \\<in> maps_over (labels p) UNIV\" (is \"?\\<beta>' \\<in> _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<beta>(l \\<mapsto> \\<anb> b l) \\<in> maps_over (labels p) UNIV", "by (auto intro: maps_over_upd[OF beta l])"], ["proof (state)\nthis:\n  \\<beta>(l \\<mapsto> \\<anb> b l) \\<in> maps_over (labels p) UNIV\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       \\<lbrakk>Discr (Inr (call.Let x21 x22 x23, \\<beta>, ve, b))\n                \\<in> arg_poss p;\n        c = call.Let x21 x22 x23;\n        state = Discr (Inr (call.Let x21 x22 x23, \\<beta>, ve, b));\n        state' = Inr (call.Let x21 x22 x23, \\<beta>, ve, b);\n        cstate = (call.Let x21 x22 x23, \\<beta>, ve, b)\\<rbrakk>\n       \\<Longrightarrow> Discr\n                          (Inr (x23, \\<beta>(x21 \\<mapsto> \\<anb> b x21),\n                                ve \\<union>. \\<Union>.map\n                 (\\<lambda>(v, l).\n                     { (v, \\<anb> b\n                            x21) := \\<aA> (L l)\n                                     (\\<beta>(x21 \\<mapsto> \\<anb> b x21))\n                                     ve}.)\n                 x22,\n                                \\<anb> b x21))\n                         \\<in> arg_poss p", "moreover"], ["proof (state)\nthis:\n  \\<beta>(l \\<mapsto> \\<anb> b l) \\<in> maps_over (labels p) UNIV\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       \\<lbrakk>Discr (Inr (call.Let x21 x22 x23, \\<beta>, ve, b))\n                \\<in> arg_poss p;\n        c = call.Let x21 x22 x23;\n        state = Discr (Inr (call.Let x21 x22 x23, \\<beta>, ve, b));\n        state' = Inr (call.Let x21 x22 x23, \\<beta>, ve, b);\n        cstate = (call.Let x21 x22 x23, \\<beta>, ve, b)\\<rbrakk>\n       \\<Longrightarrow> Discr\n                          (Inr (x23, \\<beta>(x21 \\<mapsto> \\<anb> b x21),\n                                ve \\<union>. \\<Union>.map\n                 (\\<lambda>(v, l).\n                     { (v, \\<anb> b\n                            x21) := \\<aA> (L l)\n                                     (\\<beta>(x21 \\<mapsto> \\<anb> b x21))\n                                     ve}.)\n                 x22,\n                                \\<anb> b x21))\n                         \\<in> arg_poss p", "have \"ve \\<union>. \\<Union>.map (\\<lambda>(v, lam). { (v, \\<anb> b l) := \\<aA> (L lam) (\\<beta>(l \\<mapsto> \\<anb> b l)) ve }.)\n                binds\n       \\<in> smaps_over (vars p \\<times> UNIV) (proc_poss p)\" (is \"?ve' \\<in> _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. ve \\<union>. \\<Union>.map (\\<lambda>(v, lam).\n                                  { (v, \\<anb> b\n   l) := \\<aA> (L lam) (\\<beta>(l \\<mapsto> \\<anb> b l)) ve}.)\n                           binds\n    \\<in> smaps_over (vars p \\<times> UNIV) (proc_poss p)", "using vars ls beta'"], ["proof (prove)\nusing this:\n  fst ` set binds \\<subseteq> vars p\n  snd ` set binds \\<subseteq> lambdas p\n  \\<beta>(l \\<mapsto> \\<anb> b l) \\<in> maps_over (labels p) UNIV\n\ngoal (1 subgoal):\n 1. ve \\<union>. \\<Union>.map (\\<lambda>(v, lam).\n                                  { (v, \\<anb> b\n   l) := \\<aA> (L lam) (\\<beta>(l \\<mapsto> \\<anb> b l)) ve}.)\n                           binds\n    \\<in> smaps_over (vars p \\<times> UNIV) (proc_poss p)", "by (auto intro!: smaps_over_un[OF ve] smaps_over_Union)\n          (auto intro!:smaps_over_singleton simp add: proc_poss_def)"], ["proof (state)\nthis:\n  ve \\<union>. \\<Union>.map (\\<lambda>(v, lam).\n                                { (v, \\<anb> b\n l) := \\<aA> (L lam) (\\<beta>(l \\<mapsto> \\<anb> b l)) ve}.)\n                         binds\n  \\<in> smaps_over (vars p \\<times> UNIV) (proc_poss p)\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       \\<lbrakk>Discr (Inr (call.Let x21 x22 x23, \\<beta>, ve, b))\n                \\<in> arg_poss p;\n        c = call.Let x21 x22 x23;\n        state = Discr (Inr (call.Let x21 x22 x23, \\<beta>, ve, b));\n        state' = Inr (call.Let x21 x22 x23, \\<beta>, ve, b);\n        cstate = (call.Let x21 x22 x23, \\<beta>, ve, b)\\<rbrakk>\n       \\<Longrightarrow> Discr\n                          (Inr (x23, \\<beta>(x21 \\<mapsto> \\<anb> b x21),\n                                ve \\<union>. \\<Union>.map\n                 (\\<lambda>(v, l).\n                     { (v, \\<anb> b\n                            x21) := \\<aA> (L l)\n                                     (\\<beta>(x21 \\<mapsto> \\<anb> b x21))\n                                     ve}.)\n                 x22,\n                                \\<anb> b x21))\n                         \\<in> arg_poss p", "ultimately"], ["proof (chain)\npicking this:\n  \\<beta>(l \\<mapsto> \\<anb> b l) \\<in> maps_over (labels p) UNIV\n  ve \\<union>. \\<Union>.map (\\<lambda>(v, lam).\n                                { (v, \\<anb> b\n l) := \\<aA> (L lam) (\\<beta>(l \\<mapsto> \\<anb> b l)) ve}.)\n                         binds\n  \\<in> smaps_over (vars p \\<times> UNIV) (proc_poss p)", "have \"(c', ?\\<beta>', ?ve', \\<anb> b l) \\<in> cstate_poss p\" (is \"?cstate \\<in> _\")"], ["proof (prove)\nusing this:\n  \\<beta>(l \\<mapsto> \\<anb> b l) \\<in> maps_over (labels p) UNIV\n  ve \\<union>. \\<Union>.map (\\<lambda>(v, lam).\n                                { (v, \\<anb> b\n l) := \\<aA> (L lam) (\\<beta>(l \\<mapsto> \\<anb> b l)) ve}.)\n                         binds\n  \\<in> smaps_over (vars p \\<times> UNIV) (proc_poss p)\n\ngoal (1 subgoal):\n 1. (c', \\<beta>(l \\<mapsto> \\<anb> b l),\n     ve \\<union>. \\<Union>.map (\\<lambda>(v, lam).\n                                   { (v,\n\\<anb> b l) := \\<aA> (L lam) (\\<beta>(l \\<mapsto> \\<anb> b l)) ve}.)\n                            binds,\n     \\<anb> b l)\n    \\<in> cstate_poss p", "using c'"], ["proof (prove)\nusing this:\n  \\<beta>(l \\<mapsto> \\<anb> b l) \\<in> maps_over (labels p) UNIV\n  ve \\<union>. \\<Union>.map (\\<lambda>(v, lam).\n                                { (v, \\<anb> b\n l) := \\<aA> (L lam) (\\<beta>(l \\<mapsto> \\<anb> b l)) ve}.)\n                         binds\n  \\<in> smaps_over (vars p \\<times> UNIV) (proc_poss p)\n  c' \\<in> calls p\n\ngoal (1 subgoal):\n 1. (c', \\<beta>(l \\<mapsto> \\<anb> b l),\n     ve \\<union>. \\<Union>.map (\\<lambda>(v, lam).\n                                   { (v,\n\\<anb> b l) := \\<aA> (L lam) (\\<beta>(l \\<mapsto> \\<anb> b l)) ve}.)\n                            binds,\n     \\<anb> b l)\n    \\<in> cstate_poss p", "unfolding cstate_poss_def"], ["proof (prove)\nusing this:\n  \\<beta>(l \\<mapsto> \\<anb> b l) \\<in> maps_over (labels p) UNIV\n  ve \\<union>. \\<Union>.map (\\<lambda>(v, lam).\n                                { (v, \\<anb> b\n l) := \\<aA> (L lam) (\\<beta>(l \\<mapsto> \\<anb> b l)) ve}.)\n                         binds\n  \\<in> smaps_over (vars p \\<times> UNIV) (proc_poss p)\n  c' \\<in> calls p\n\ngoal (1 subgoal):\n 1. (c', \\<beta>(l \\<mapsto> \\<anb> b l),\n     ve \\<union>. \\<Union>.map (\\<lambda>(v, lam).\n                                   { (v,\n\\<anb> b l) := \\<aA> (L lam) (\\<beta>(l \\<mapsto> \\<anb> b l)) ve}.)\n                            binds,\n     \\<anb> b l)\n    \\<in> calls p \\<times>\n          maps_over (labels p) UNIV \\<times>\n          smaps_over (vars p \\<times> UNIV) (proc_poss p) \\<times> UNIV", "by simp"], ["proof (state)\nthis:\n  (c', \\<beta>(l \\<mapsto> \\<anb> b l),\n   ve \\<union>. \\<Union>.map (\\<lambda>(v, lam).\n                                 { (v, \\<anb> b\n  l) := \\<aA> (L lam) (\\<beta>(l \\<mapsto> \\<anb> b l)) ve}.)\n                          binds,\n   \\<anb> b l)\n  \\<in> cstate_poss p\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       \\<lbrakk>Discr (Inr (call.Let x21 x22 x23, \\<beta>, ve, b))\n                \\<in> arg_poss p;\n        c = call.Let x21 x22 x23;\n        state = Discr (Inr (call.Let x21 x22 x23, \\<beta>, ve, b));\n        state' = Inr (call.Let x21 x22 x23, \\<beta>, ve, b);\n        cstate = (call.Let x21 x22 x23, \\<beta>, ve, b)\\<rbrakk>\n       \\<Longrightarrow> Discr\n                          (Inr (x23, \\<beta>(x21 \\<mapsto> \\<anb> b x21),\n                                ve \\<union>. \\<Union>.map\n                 (\\<lambda>(v, l).\n                     { (v, \\<anb> b\n                            x21) := \\<aA> (L l)\n                                     (\\<beta>(x21 \\<mapsto> \\<anb> b x21))\n                                     ve}.)\n                 x22,\n                                \\<anb> b x21))\n                         \\<in> arg_poss p", "thus \"Discr (Inr ?cstate) \\<in> arg_poss p\""], ["proof (prove)\nusing this:\n  (c', \\<beta>(l \\<mapsto> \\<anb> b l),\n   ve \\<union>. \\<Union>.map (\\<lambda>(v, lam).\n                                 { (v, \\<anb> b\n  l) := \\<aA> (L lam) (\\<beta>(l \\<mapsto> \\<anb> b l)) ve}.)\n                          binds,\n   \\<anb> b l)\n  \\<in> cstate_poss p\n\ngoal (1 subgoal):\n 1. Discr\n     (Inr (c', \\<beta>(l \\<mapsto> \\<anb> b l),\n           ve \\<union>. \\<Union>.map (\\<lambda>(v, lam).\n   { (v, \\<anb> b\n          l) := \\<aA> (L lam) (\\<beta>(l \\<mapsto> \\<anb> b l)) ve}.)\n                                  binds,\n           \\<anb> b l))\n    \\<in> arg_poss p", "unfolding arg_poss_def"], ["proof (prove)\nusing this:\n  (c', \\<beta>(l \\<mapsto> \\<anb> b l),\n   ve \\<union>. \\<Union>.map (\\<lambda>(v, lam).\n                                 { (v, \\<anb> b\n  l) := \\<aA> (L lam) (\\<beta>(l \\<mapsto> \\<anb> b l)) ve}.)\n                          binds,\n   \\<anb> b l)\n  \\<in> cstate_poss p\n\ngoal (1 subgoal):\n 1. Discr\n     (Inr (c', \\<beta>(l \\<mapsto> \\<anb> b l),\n           ve \\<union>. \\<Union>.map (\\<lambda>(v, lam).\n   { (v, \\<anb> b\n          l) := \\<aA> (L lam) (\\<beta>(l \\<mapsto> \\<anb> b l)) ve}.)\n                                  binds,\n           \\<anb> b l))\n    \\<in> Discr ` (fstate_poss p <+> cstate_poss p)", "by auto"], ["proof (state)\nthis:\n  Discr\n   (Inr (c', \\<beta>(l \\<mapsto> \\<anb> b l),\n         ve \\<union>. \\<Union>.map (\\<lambda>(v, lam).\n { (v, \\<anb> b l) := \\<aA> (L lam) (\\<beta>(l \\<mapsto> \\<anb> b l)) ve}.)\n                                binds,\n         \\<anb> b l))\n  \\<in> arg_poss p\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Lambda> x.\n      case undiscr x of\n      Inl (PC (Lambda lab vs c, \\<beta>), as, ve, b) \\<Rightarrow>\n        if length vs = length as\n        then let \\<beta>' = \\<beta>(lab \\<mapsto> b);\n                 ve' =\n                   ve \\<union>. \\<Union>.map2\n    (\\<lambda>v. smap_singleton (v, b)) vs as\n             in {Discr (Inr (c, \\<beta>', ve', b))}\n        else \\<bottom>\n      | Inl (PP (Plus c), [], bb) \\<Rightarrow> \\<bottom>\n      | Inl (PP (Plus c), [x], bb) \\<Rightarrow> \\<bottom>\n      | Inl (PP (Plus c), [x, xa], bb) \\<Rightarrow> \\<bottom>\n      | Inl (PP (Plus c), [x, xa, cnts], ve, b) \\<Rightarrow>\n          let b' = \\<anb> b c; \\<beta> = [c \\<mapsto> b]\n          in \\<Union>cnt\\<in>cnts. {Discr (Inl (cnt, [{}], ve, b'))}\n      | Inl (PP (Plus c), x # xa # cnts # ac # lista, bb) \\<Rightarrow>\n          \\<bottom>\n      | Inl (PP (prim.If ct cf), [], bb) \\<Rightarrow> \\<bottom>\n      | Inl (PP (prim.If ct cf), [x], bb) \\<Rightarrow> \\<bottom>\n      | Inl (PP (prim.If ct cf), [x, cntts], bb) \\<Rightarrow> \\<bottom>\n      | Inl (PP (prim.If ct cf), [x, cntts, cntfs], ve, b) \\<Rightarrow>\n          (let b' = \\<anb> b ct; \\<beta> = [ct \\<mapsto> b]\n           in \\<Union>cnt\\<in>cntts.\n                 {Discr (Inl (cnt, [], ve, b'))}) \\<union>\n          (let b' = \\<anb> b cf; \\<beta> = [cf \\<mapsto> b]\n           in \\<Union>cnt\\<in>cntfs. {Discr (Inl (cnt, [], ve, b'))})\n      | Inl (PP (prim.If ct cf), x # cntts # cntfs # ac # lista,\n             bb) \\<Rightarrow>\n          \\<bottom>\n      | Inl (AStop, [], bb) \\<Rightarrow> \\<bottom>\n      | Inl (AStop, [x], xa, xb) \\<Rightarrow> {}\n      | Inl (AStop, x # a # lista, bb) \\<Rightarrow> \\<bottom>\n      | Inr (App lab f vs, \\<beta>, ve, b) \\<Rightarrow>\n          let fs = \\<aA> f \\<beta> ve;\n              as = map (\\<lambda>v. \\<aA> v \\<beta> ve) vs;\n              b' = \\<anb> b lab\n          in \\<Union>f'\\<in>fs. {Discr (Inl (f', as, ve, b'))}\n      | Inr (call.Let lab ls c', \\<beta>, ve, b) \\<Rightarrow>\n          let b' = \\<anb> b lab; \\<beta>' = \\<beta>(lab \\<mapsto> b');\n              ve' =\n                ve \\<union>. \\<Union>.map\n (\\<lambda>(v, l). { (v, b') := \\<aA> (L l) \\<beta>' ve}.) ls\n          in {Discr (Inr (c', \\<beta>', ve', b'))})\\<cdot>\n  state\n  \\<subseteq> arg_poss p\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Lambda> x.\n      case undiscr x of\n      Inl (PC (Lambda lab vs c, \\<beta>), as, ve, b) \\<Rightarrow>\n        if length vs = length as\n        then let \\<beta>' = \\<beta>(lab \\<mapsto> b);\n                 ve' =\n                   ve \\<union>. \\<Union>.map2\n    (\\<lambda>v. smap_singleton (v, b)) vs as\n             in {Discr (Inr (c, \\<beta>', ve', b))}\n        else \\<bottom>\n      | Inl (PP (Plus c), [], bb) \\<Rightarrow> \\<bottom>\n      | Inl (PP (Plus c), [x], bb) \\<Rightarrow> \\<bottom>\n      | Inl (PP (Plus c), [x, xa], bb) \\<Rightarrow> \\<bottom>\n      | Inl (PP (Plus c), [x, xa, cnts], ve, b) \\<Rightarrow>\n          let b' = \\<anb> b c; \\<beta> = [c \\<mapsto> b]\n          in \\<Union>cnt\\<in>cnts. {Discr (Inl (cnt, [{}], ve, b'))}\n      | Inl (PP (Plus c), x # xa # cnts # ac # lista, bb) \\<Rightarrow>\n          \\<bottom>\n      | Inl (PP (prim.If ct cf), [], bb) \\<Rightarrow> \\<bottom>\n      | Inl (PP (prim.If ct cf), [x], bb) \\<Rightarrow> \\<bottom>\n      | Inl (PP (prim.If ct cf), [x, cntts], bb) \\<Rightarrow> \\<bottom>\n      | Inl (PP (prim.If ct cf), [x, cntts, cntfs], ve, b) \\<Rightarrow>\n          (let b' = \\<anb> b ct; \\<beta> = [ct \\<mapsto> b]\n           in \\<Union>cnt\\<in>cntts.\n                 {Discr (Inl (cnt, [], ve, b'))}) \\<union>\n          (let b' = \\<anb> b cf; \\<beta> = [cf \\<mapsto> b]\n           in \\<Union>cnt\\<in>cntfs. {Discr (Inl (cnt, [], ve, b'))})\n      | Inl (PP (prim.If ct cf), x # cntts # cntfs # ac # lista,\n             bb) \\<Rightarrow>\n          \\<bottom>\n      | Inl (AStop, [], bb) \\<Rightarrow> \\<bottom>\n      | Inl (AStop, [x], xa, xb) \\<Rightarrow> {}\n      | Inl (AStop, x # a # lista, bb) \\<Rightarrow> \\<bottom>\n      | Inr (App lab f vs, \\<beta>, ve, b) \\<Rightarrow>\n          let fs = \\<aA> f \\<beta> ve;\n              as = map (\\<lambda>v. \\<aA> v \\<beta> ve) vs;\n              b' = \\<anb> b lab\n          in \\<Union>f'\\<in>fs. {Discr (Inl (f', as, ve, b'))}\n      | Inr (call.Let lab ls c', \\<beta>, ve, b) \\<Rightarrow>\n          let b' = \\<anb> b lab; \\<beta>' = \\<beta>(lab \\<mapsto> b');\n              ve' =\n                ve \\<union>. \\<Union>.map\n (\\<lambda>(v, l). { (v, b') := \\<aA> (L l) \\<beta>' ve}.) ls\n          in {Discr (Inr (c', \\<beta>', ve', b'))})\\<cdot>\n  state\n  \\<subseteq> arg_poss p\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Lambda> x.\n      case undiscr x of\n      Inl (PC (Lambda lab vs c, \\<beta>), as, ve, b) \\<Rightarrow>\n        if length vs = length as\n        then let \\<beta>' = \\<beta>(lab \\<mapsto> b);\n                 ve' =\n                   ve \\<union>. \\<Union>.map2\n    (\\<lambda>v. smap_singleton (v, b)) vs as\n             in {Discr (Inr (c, \\<beta>', ve', b))}\n        else \\<bottom>\n      | Inl (PP (Plus c), [], bb) \\<Rightarrow> \\<bottom>\n      | Inl (PP (Plus c), [x], bb) \\<Rightarrow> \\<bottom>\n      | Inl (PP (Plus c), [x, xa], bb) \\<Rightarrow> \\<bottom>\n      | Inl (PP (Plus c), [x, xa, cnts], ve, b) \\<Rightarrow>\n          let b' = \\<anb> b c; \\<beta> = [c \\<mapsto> b]\n          in \\<Union>cnt\\<in>cnts. {Discr (Inl (cnt, [{}], ve, b'))}\n      | Inl (PP (Plus c), x # xa # cnts # ac # lista, bb) \\<Rightarrow>\n          \\<bottom>\n      | Inl (PP (prim.If ct cf), [], bb) \\<Rightarrow> \\<bottom>\n      | Inl (PP (prim.If ct cf), [x], bb) \\<Rightarrow> \\<bottom>\n      | Inl (PP (prim.If ct cf), [x, cntts], bb) \\<Rightarrow> \\<bottom>\n      | Inl (PP (prim.If ct cf), [x, cntts, cntfs], ve, b) \\<Rightarrow>\n          (let b' = \\<anb> b ct; \\<beta> = [ct \\<mapsto> b]\n           in \\<Union>cnt\\<in>cntts.\n                 {Discr (Inl (cnt, [], ve, b'))}) \\<union>\n          (let b' = \\<anb> b cf; \\<beta> = [cf \\<mapsto> b]\n           in \\<Union>cnt\\<in>cntfs. {Discr (Inl (cnt, [], ve, b'))})\n      | Inl (PP (prim.If ct cf), x # cntts # cntfs # ac # lista,\n             bb) \\<Rightarrow>\n          \\<bottom>\n      | Inl (AStop, [], bb) \\<Rightarrow> \\<bottom>\n      | Inl (AStop, [x], xa, xb) \\<Rightarrow> {}\n      | Inl (AStop, x # a # lista, bb) \\<Rightarrow> \\<bottom>\n      | Inr (App lab f vs, \\<beta>, ve, b) \\<Rightarrow>\n          let fs = \\<aA> f \\<beta> ve;\n              as = map (\\<lambda>v. \\<aA> v \\<beta> ve) vs;\n              b' = \\<anb> b lab\n          in \\<Union>f'\\<in>fs. {Discr (Inl (f', as, ve, b'))}\n      | Inr (call.Let lab ls c', \\<beta>, ve, b) \\<Rightarrow>\n          let b' = \\<anb> b lab; \\<beta>' = \\<beta>(lab \\<mapsto> b');\n              ve' =\n                ve \\<union>. \\<Union>.map\n (\\<lambda>(v, l). { (v, b') := \\<aA> (L l) \\<beta>' ve}.) ls\n          in {Discr (Inr (c', \\<beta>', ve', b'))})\\<cdot>\n  state\n  \\<subseteq> arg_poss p\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Lambda> x.\n      case undiscr x of\n      Inl (PC (Lambda lab vs c, \\<beta>), as, ve, b) \\<Rightarrow>\n        if length vs = length as\n        then let \\<beta>' = \\<beta>(lab \\<mapsto> b);\n                 ve' =\n                   ve \\<union>. \\<Union>.map2\n    (\\<lambda>v. smap_singleton (v, b)) vs as\n             in {Discr (Inr (c, \\<beta>', ve', b))}\n        else \\<bottom>\n      | Inl (PP (Plus c), [], bb) \\<Rightarrow> \\<bottom>\n      | Inl (PP (Plus c), [x], bb) \\<Rightarrow> \\<bottom>\n      | Inl (PP (Plus c), [x, xa], bb) \\<Rightarrow> \\<bottom>\n      | Inl (PP (Plus c), [x, xa, cnts], ve, b) \\<Rightarrow>\n          let b' = \\<anb> b c; \\<beta> = [c \\<mapsto> b]\n          in \\<Union>cnt\\<in>cnts. {Discr (Inl (cnt, [{}], ve, b'))}\n      | Inl (PP (Plus c), x # xa # cnts # ac # lista, bb) \\<Rightarrow>\n          \\<bottom>\n      | Inl (PP (prim.If ct cf), [], bb) \\<Rightarrow> \\<bottom>\n      | Inl (PP (prim.If ct cf), [x], bb) \\<Rightarrow> \\<bottom>\n      | Inl (PP (prim.If ct cf), [x, cntts], bb) \\<Rightarrow> \\<bottom>\n      | Inl (PP (prim.If ct cf), [x, cntts, cntfs], ve, b) \\<Rightarrow>\n          (let b' = \\<anb> b ct; \\<beta> = [ct \\<mapsto> b]\n           in \\<Union>cnt\\<in>cntts.\n                 {Discr (Inl (cnt, [], ve, b'))}) \\<union>\n          (let b' = \\<anb> b cf; \\<beta> = [cf \\<mapsto> b]\n           in \\<Union>cnt\\<in>cntfs. {Discr (Inl (cnt, [], ve, b'))})\n      | Inl (PP (prim.If ct cf), x # cntts # cntfs # ac # lista,\n             bb) \\<Rightarrow>\n          \\<bottom>\n      | Inl (AStop, [], bb) \\<Rightarrow> \\<bottom>\n      | Inl (AStop, [x], xa, xb) \\<Rightarrow> {}\n      | Inl (AStop, x # a # lista, bb) \\<Rightarrow> \\<bottom>\n      | Inr (App lab f vs, \\<beta>, ve, b) \\<Rightarrow>\n          let fs = \\<aA> f \\<beta> ve;\n              as = map (\\<lambda>v. \\<aA> v \\<beta> ve) vs;\n              b' = \\<anb> b lab\n          in \\<Union>f'\\<in>fs. {Discr (Inl (f', as, ve, b'))}\n      | Inr (call.Let lab ls c', \\<beta>, ve, b) \\<Rightarrow>\n          let b' = \\<anb> b lab; \\<beta>' = \\<beta>(lab \\<mapsto> b');\n              ve' =\n                ve \\<union>. \\<Union>.map\n (\\<lambda>(v, l). { (v, b') := \\<aA> (L l) \\<beta>' ve}.) ls\n          in {Discr (Inr (c', \\<beta>', ve', b'))})\\<cdot>\n  state\n  \\<subseteq> arg_poss p\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\nThis result is now lifted to the powerset of \\<open>abs_R\\<close>.\n\\<close>"], ["", "lemma arg_space_complete_ps: \"states \\<subseteq> arg_poss p \\<Longrightarrow> (\\<^ps>abs_R)\\<cdot>states \\<subseteq> arg_poss p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. states \\<subseteq> arg_poss p \\<Longrightarrow>\n    \\<^ps> abs_R\\<cdot>states \\<subseteq> arg_poss p", "using arg_space_complete"], ["proof (prove)\nusing this:\n  ?state \\<in> arg_poss ?p \\<Longrightarrow>\n  abs_R\\<cdot>?state \\<subseteq> arg_poss ?p\n\ngoal (1 subgoal):\n 1. states \\<subseteq> arg_poss p \\<Longrightarrow>\n    \\<^ps> abs_R\\<cdot>states \\<subseteq> arg_poss p", "unfolding powerset_lift_def"], ["proof (prove)\nusing this:\n  ?state \\<in> arg_poss ?p \\<Longrightarrow>\n  abs_R\\<cdot>?state \\<subseteq> arg_poss ?p\n\ngoal (1 subgoal):\n 1. states \\<subseteq> arg_poss p \\<Longrightarrow>\n    (\\<Lambda> S. \\<Union> (Rep_cfun abs_R ` S))\\<cdot>states\n    \\<subseteq> arg_poss p", "by auto"], ["", "text \\<open>\nWe are not so much interested in the finiteness of the set of possible arguments but rather of the the set of occurring arguments, when we start with the initial argument. But as this is of course a subset of the set of possible arguments, this is not hard to show.\n\\<close>"], ["", "lemma UN_iterate_less: \n  assumes start: \"x \\<in> S\"\n  and step: \"\\<And>y. y\\<subseteq>S \\<Longrightarrow> (f\\<cdot>y) \\<subseteq> S\"\n  shows \"(\\<Union>i. iterate i\\<cdot>f\\<cdot>{x}) \\<subseteq> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>i. f\\<^bsup>i\\<^esup>\\<cdot>{x}) \\<subseteq> S", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Union>i. f\\<^bsup>i\\<^esup>\\<cdot>{x}) \\<subseteq> S", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Union>i. f\\<^bsup>i\\<^esup>\\<cdot>{x}) \\<subseteq> S", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Union>i. f\\<^bsup>i\\<^esup>\\<cdot>{x}) \\<subseteq> S", "have \"iterate i\\<cdot>f\\<cdot>{x} \\<subseteq> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f\\<^bsup>i\\<^esup>\\<cdot>{x} \\<subseteq> S", "proof(induct i)"], ["proof (state)\ngoal (2 subgoals):\n 1. f\\<^bsup>0\\<^esup>\\<cdot>{x} \\<subseteq> S\n 2. \\<And>i.\n       f\\<^bsup>i\\<^esup>\\<cdot>{x} \\<subseteq> S \\<Longrightarrow>\n       f\\<^bsup>Suc i\\<^esup>\\<cdot>{x} \\<subseteq> S", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. f\\<^bsup>0\\<^esup>\\<cdot>{x} \\<subseteq> S\n 2. \\<And>i.\n       f\\<^bsup>i\\<^esup>\\<cdot>{x} \\<subseteq> S \\<Longrightarrow>\n       f\\<^bsup>Suc i\\<^esup>\\<cdot>{x} \\<subseteq> S", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. f\\<^bsup>0\\<^esup>\\<cdot>{x} \\<subseteq> S", "using \\<open>x \\<in> S\\<close>"], ["proof (prove)\nusing this:\n  x \\<in> S\n\ngoal (1 subgoal):\n 1. f\\<^bsup>0\\<^esup>\\<cdot>{x} \\<subseteq> S", "by simp"], ["proof (state)\nthis:\n  f\\<^bsup>0\\<^esup>\\<cdot>{x} \\<subseteq> S\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       f\\<^bsup>i\\<^esup>\\<cdot>{x} \\<subseteq> S \\<Longrightarrow>\n       f\\<^bsup>Suc i\\<^esup>\\<cdot>{x} \\<subseteq> S", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       f\\<^bsup>i\\<^esup>\\<cdot>{x} \\<subseteq> S \\<Longrightarrow>\n       f\\<^bsup>Suc i\\<^esup>\\<cdot>{x} \\<subseteq> S", "case (Suc i)"], ["proof (state)\nthis:\n  f\\<^bsup>i\\<^esup>\\<cdot>{x} \\<subseteq> S\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       f\\<^bsup>i\\<^esup>\\<cdot>{x} \\<subseteq> S \\<Longrightarrow>\n       f\\<^bsup>Suc i\\<^esup>\\<cdot>{x} \\<subseteq> S", "thus ?case"], ["proof (prove)\nusing this:\n  f\\<^bsup>i\\<^esup>\\<cdot>{x} \\<subseteq> S\n\ngoal (1 subgoal):\n 1. f\\<^bsup>Suc i\\<^esup>\\<cdot>{x} \\<subseteq> S", "using step[of \"iterate i\\<cdot>f\\<cdot>{x}\"]"], ["proof (prove)\nusing this:\n  f\\<^bsup>i\\<^esup>\\<cdot>{x} \\<subseteq> S\n  f\\<^bsup>i\\<^esup>\\<cdot>{x} \\<subseteq> S \\<Longrightarrow>\n  f\\<cdot>(f\\<^bsup>i\\<^esup>\\<cdot>{x}) \\<subseteq> S\n\ngoal (1 subgoal):\n 1. f\\<^bsup>Suc i\\<^esup>\\<cdot>{x} \\<subseteq> S", "by simp"], ["proof (state)\nthis:\n  f\\<^bsup>Suc i\\<^esup>\\<cdot>{x} \\<subseteq> S\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  f\\<^bsup>i\\<^esup>\\<cdot>{x} \\<subseteq> S\n\ngoal (1 subgoal):\n 1. (\\<Union>i. f\\<^bsup>i\\<^esup>\\<cdot>{x}) \\<subseteq> S", "}"], ["proof (state)\nthis:\n  f\\<^bsup>?i2\\<^esup>\\<cdot>{x} \\<subseteq> S\n\ngoal (1 subgoal):\n 1. (\\<Union>i. f\\<^bsup>i\\<^esup>\\<cdot>{x}) \\<subseteq> S", "thus ?thesis"], ["proof (prove)\nusing this:\n  f\\<^bsup>?i2\\<^esup>\\<cdot>{x} \\<subseteq> S\n\ngoal (1 subgoal):\n 1. (\\<Union>i. f\\<^bsup>i\\<^esup>\\<cdot>{x}) \\<subseteq> S", "by auto"], ["proof (state)\nthis:\n  (\\<Union>i. f\\<^bsup>i\\<^esup>\\<cdot>{x}) \\<subseteq> S\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma args_finite: \"finite (\\<Union>i. iterate i\\<cdot>(\\<^ps>abs_R)\\<cdot>{initial_r p})\" (is \"finite ?S\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (\\<Union>i. (\\<^ps> abs_R)\\<^bsup>i\\<^esup>\\<cdot>{initial_r p})", "proof (rule finite_subset[OF _finite_arg_space])"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Union>i. (\\<^ps> abs_R)\\<^bsup>i\\<^esup>\\<cdot>{initial_r p})\n    \\<subseteq> arg_poss ?p1", "have [simp]:\"p \\<in> lambdas p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<in> lambdas p", "by (cases p, simp)"], ["proof (state)\nthis:\n  p \\<in> lambdas p\n\ngoal (1 subgoal):\n 1. (\\<Union>i. (\\<^ps> abs_R)\\<^bsup>i\\<^esup>\\<cdot>{initial_r p})\n    \\<subseteq> arg_poss ?p1", "show \"?S \\<subseteq> arg_poss p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>i. (\\<^ps> abs_R)\\<^bsup>i\\<^esup>\\<cdot>{initial_r p})\n    \\<subseteq> arg_poss p", "unfolding initial_r_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>i.\n        (\\<^ps> abs_R)\\<^bsup>i\\<^esup>\\<cdot>\n        {Discr\n          (Inl (the_elem (\\<aA> (L p) Map.empty {}.), [{AStop}], {}.,\n                \\<abinit>))})\n    \\<subseteq> arg_poss p", "by  (rule UN_iterate_less[OF _ arg_space_complete_ps])\n      (auto simp add:arg_poss_def fstate_poss_def proc_poss_def call_list_lengths_def NList_def nList_def\n         intro!: imageI)"], ["proof (state)\nthis:\n  (\\<Union>i. (\\<^ps> abs_R)\\<^bsup>i\\<^esup>\\<cdot>{initial_r p})\n  \\<subseteq> arg_poss p\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>A decomposition\\<close>"], ["", "text \\<open>\nThe functions \\<open>abs_g\\<close> and \\<open>abs_R\\<close> are derived from \\<open>\\<aF>\\<close> and \\<open>\\<aC>\\<close>. This connection has yet to expressed explicitly. \n\\<close>"], ["", "lemma Un_commute_helper:\"(a \\<union> b) \\<union> (c \\<union> d) = (a \\<union> c) \\<union> (b \\<union> d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<union> b \\<union> (c \\<union> d) =\n    a \\<union> c \\<union> (b \\<union> d)", "by auto"], ["", "lemma a_evalF_decomp:\n  \"\\<aF> = fst (sum_to_tup\\<cdot>(fix\\<cdot>(\\<Lambda> f x. (\\<Union>y\\<in>abs_R\\<cdot>x. f\\<cdot>y) \\<union> abs_g\\<cdot>x)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<aF> =\n    fst (sum_to_tup\\<cdot>\n         (\\<mu> f.\n             \\<Lambda> x.\n                \\<Union> (Rep_cfun f ` abs_R\\<cdot>x) \\<union>\n                abs_g\\<cdot>x))", "apply (subst a_evalF_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (fix_syn\n          (\\<lambda>(a_evalF, a_evalC).\n              (\\<Lambda> fstate.\n                  case undiscr fstate of\n                  (PC (Lambda lab vs c, \\<beta>), as, ve, b) \\<Rightarrow>\n                    if length vs = length as\n                    then let \\<beta>' = \\<beta>(lab \\<mapsto> b);\n                             ve' =\n                               ve \\<union>. \\<Union>.map2\n                (\\<lambda>v. smap_singleton (v, b)) vs as\n                         in a_evalC\\<cdot>(Discr (c, \\<beta>', ve', b))\n                    else \\<bottom>\n                  | (PP (Plus c), [], bb) \\<Rightarrow> \\<bottom>\n                  | (PP (Plus c), [x], bb) \\<Rightarrow> \\<bottom>\n                  | (PP (Plus c), [x, xaa], bb) \\<Rightarrow> \\<bottom>\n                  | (PP (Plus c), [x, xaa, cnts], ve, b) \\<Rightarrow>\n                      let b' = \\<anb> b c; \\<beta> = [c \\<mapsto> b]\n                      in (\\<Union>cnt\\<in>cnts.\n                             a_evalF\\<cdot>\n                             (Discr (cnt, [{}], ve, b'))) \\<union>\n                         {((c, \\<beta>), cont) |cont. cont \\<in> cnts}\n                  | (PP (Plus c), x # xaa # cnts # ac # lista,\n                     bb) \\<Rightarrow>\n                      \\<bottom>\n                  | (PP (prim.If ct cf), [], bb) \\<Rightarrow> \\<bottom>\n                  | (PP (prim.If ct cf), [x], bb) \\<Rightarrow> \\<bottom>\n                  | (PP (prim.If ct cf), [x, cntts], bb) \\<Rightarrow>\n                      \\<bottom>\n                  | (PP (prim.If ct cf), [x, cntts, cntfs], ve,\n                     b) \\<Rightarrow>\n                      (let b' = \\<anb> b ct; \\<beta> = [ct \\<mapsto> b]\n                       in (\\<Union>cnt\\<in>cntts.\n                              a_evalF\\<cdot>\n                              (Discr (cnt, [], ve, b'))) \\<union>\n                          {((ct, \\<beta>), cnt) |cnt.\n                           cnt \\<in> cntts}) \\<union>\n                      (let b' = \\<anb> b cf; \\<beta> = [cf \\<mapsto> b]\n                       in (\\<Union>cnt\\<in>cntfs.\n                              a_evalF\\<cdot>\n                              (Discr (cnt, [], ve, b'))) \\<union>\n                          {((cf, \\<beta>), cnt) |cnt. cnt \\<in> cntfs})\n                  | (PP (prim.If ct cf), x # cntts # cntfs # ac # lista,\n                     bb) \\<Rightarrow>\n                      \\<bottom>\n                  | (AStop, [], bb) \\<Rightarrow> \\<bottom>\n                  | (AStop, [x], xa, xb) \\<Rightarrow> {}\n                  | (AStop, x # a # lista, bb) \\<Rightarrow> \\<bottom>,\n               \\<Lambda> cstate.\n                  case undiscr cstate of\n                  (App lab f vs, \\<beta>, ve, b) \\<Rightarrow>\n                    let fs = \\<aA> f \\<beta> ve;\n                        as = map (\\<lambda>v. \\<aA> v \\<beta> ve) vs;\n                        b' = \\<anb> b lab\n                    in (\\<Union>f'\\<in>fs.\n                           a_evalF\\<cdot>(Discr (f', as, ve, b'))) \\<union>\n                       {((lab, \\<beta>), f') |f'. f' \\<in> fs}\n                  | (call.Let lab ls c', \\<beta>, ve, b) \\<Rightarrow>\n                      let b' = \\<anb> b lab;\n                          \\<beta>' = \\<beta>(lab \\<mapsto> b');\n                          ve' =\n                            ve \\<union>. \\<Union>.map\n             (\\<lambda>(v, l). { (v, b') := \\<aA> (L l) \\<beta>' ve}.) ls\n                      in a_evalC\\<cdot>(Discr (c', \\<beta>', ve', b'))))) =\n    fst (sum_to_tup\\<cdot>\n         (\\<mu> f.\n             \\<Lambda> x.\n                \\<Union> (Rep_cfun f ` abs_R\\<cdot>x) \\<union>\n                abs_g\\<cdot>x))", "apply (subst fix_transform_pair_sum)"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (sum_to_tup\\<cdot>\n         (fix\\<cdot>\n          (tup_to_sum oo\n           Abs_cfun\n            (\\<lambda>(a_evalF, a_evalC).\n                (\\<Lambda> fstate.\n                    case undiscr fstate of\n                    (PC (Lambda lab vs c, \\<beta>), as, ve, b) \\<Rightarrow>\n                      if length vs = length as\n                      then let \\<beta>' = \\<beta>(lab \\<mapsto> b);\n                               ve' =\n                                 ve \\<union>. \\<Union>.map2\n                  (\\<lambda>v. smap_singleton (v, b)) vs as\n                           in a_evalC\\<cdot>(Discr (c, \\<beta>', ve', b))\n                      else \\<bottom>\n                    | (PP (Plus c), [], bb) \\<Rightarrow> \\<bottom>\n                    | (PP (Plus c), [x], bb) \\<Rightarrow> \\<bottom>\n                    | (PP (Plus c), [x, xaa], bb) \\<Rightarrow> \\<bottom>\n                    | (PP (Plus c), [x, xaa, cnts], ve, b) \\<Rightarrow>\n                        let b' = \\<anb> b c; \\<beta> = [c \\<mapsto> b]\n                        in (\\<Union>cnt\\<in>cnts.\n                               a_evalF\\<cdot>\n                               (Discr (cnt, [{}], ve, b'))) \\<union>\n                           {((c, \\<beta>), cont) |cont. cont \\<in> cnts}\n                    | (PP (Plus c), x # xaa # cnts # ac # lista,\n                       bb) \\<Rightarrow>\n                        \\<bottom>\n                    | (PP (prim.If ct cf), [], bb) \\<Rightarrow> \\<bottom>\n                    | (PP (prim.If ct cf), [x], bb) \\<Rightarrow> \\<bottom>\n                    | (PP (prim.If ct cf), [x, cntts], bb) \\<Rightarrow>\n                        \\<bottom>\n                    | (PP (prim.If ct cf), [x, cntts, cntfs], ve,\n                       b) \\<Rightarrow>\n                        (let b' = \\<anb> b ct; \\<beta> = [ct \\<mapsto> b]\n                         in (\\<Union>cnt\\<in>cntts.\n                                a_evalF\\<cdot>\n                                (Discr (cnt, [], ve, b'))) \\<union>\n                            {((ct, \\<beta>), cnt) |cnt.\n                             cnt \\<in> cntts}) \\<union>\n                        (let b' = \\<anb> b cf; \\<beta> = [cf \\<mapsto> b]\n                         in (\\<Union>cnt\\<in>cntfs.\n                                a_evalF\\<cdot>\n                                (Discr (cnt, [], ve, b'))) \\<union>\n                            {((cf, \\<beta>), cnt) |cnt. cnt \\<in> cntfs})\n                    | (PP (prim.If ct cf), x # cntts # cntfs # ac # lista,\n                       bb) \\<Rightarrow>\n                        \\<bottom>\n                    | (AStop, [], bb) \\<Rightarrow> \\<bottom>\n                    | (AStop, [x], xa, xb) \\<Rightarrow> {}\n                    | (AStop, x # a # lista, bb) \\<Rightarrow> \\<bottom>,\n                 \\<Lambda> cstate.\n                    case undiscr cstate of\n                    (App lab f vs, \\<beta>, ve, b) \\<Rightarrow>\n                      let fs = \\<aA> f \\<beta> ve;\n                          as = map (\\<lambda>v. \\<aA> v \\<beta> ve) vs;\n                          b' = \\<anb> b lab\n                      in (\\<Union>f'\\<in>fs.\n                             a_evalF\\<cdot>\n                             (Discr (f', as, ve, b'))) \\<union>\n                         {((lab, \\<beta>), f') |f'. f' \\<in> fs}\n                    | (call.Let lab ls c', \\<beta>, ve, b) \\<Rightarrow>\n                        let b' = \\<anb> b lab;\n                            \\<beta>' = \\<beta>(lab \\<mapsto> b');\n                            ve' =\n                              ve \\<union>. \\<Union>.map\n               (\\<lambda>(v, l). { (v, b') := \\<aA> (L l) \\<beta>' ve}.) ls\n                        in a_evalC\\<cdot>\n                           (Discr (c', \\<beta>', ve', b')))) oo\n           sum_to_tup))) =\n    fst (sum_to_tup\\<cdot>\n         (\\<mu> f.\n             \\<Lambda> x.\n                \\<Union> (Rep_cfun f ` abs_R\\<cdot>x) \\<union>\n                abs_g\\<cdot>x))", "apply (rule arg_cong [of _ _ \"\\<lambda>x. fst (sum_to_tup\\<cdot>(fix\\<cdot>x))\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. tup_to_sum oo\n    Abs_cfun\n     (\\<lambda>(a_evalF, a_evalC).\n         (\\<Lambda> fstate.\n             case undiscr fstate of\n             (PC (Lambda lab vs c, \\<beta>), as, ve, b) \\<Rightarrow>\n               if length vs = length as\n               then let \\<beta>' = \\<beta>(lab \\<mapsto> b);\n                        ve' =\n                          ve \\<union>. \\<Union>.map2\n           (\\<lambda>v. smap_singleton (v, b)) vs as\n                    in a_evalC\\<cdot>(Discr (c, \\<beta>', ve', b))\n               else \\<bottom>\n             | (PP (Plus c), [], bb) \\<Rightarrow> \\<bottom>\n             | (PP (Plus c), [x], bb) \\<Rightarrow> \\<bottom>\n             | (PP (Plus c), [x, xaa], bb) \\<Rightarrow> \\<bottom>\n             | (PP (Plus c), [x, xaa, cnts], ve, b) \\<Rightarrow>\n                 let b' = \\<anb> b c; \\<beta> = [c \\<mapsto> b]\n                 in (\\<Union>cnt\\<in>cnts.\n                        a_evalF\\<cdot>(Discr (cnt, [{}], ve, b'))) \\<union>\n                    {((c, \\<beta>), cont) |cont. cont \\<in> cnts}\n             | (PP (Plus c), x # xaa # cnts # ac # lista, bb) \\<Rightarrow>\n                 \\<bottom>\n             | (PP (prim.If ct cf), [], bb) \\<Rightarrow> \\<bottom>\n             | (PP (prim.If ct cf), [x], bb) \\<Rightarrow> \\<bottom>\n             | (PP (prim.If ct cf), [x, cntts], bb) \\<Rightarrow> \\<bottom>\n             | (PP (prim.If ct cf), [x, cntts, cntfs], ve, b) \\<Rightarrow>\n                 (let b' = \\<anb> b ct; \\<beta> = [ct \\<mapsto> b]\n                  in (\\<Union>cnt\\<in>cntts.\n                         a_evalF\\<cdot>(Discr (cnt, [], ve, b'))) \\<union>\n                     {((ct, \\<beta>), cnt) |cnt. cnt \\<in> cntts}) \\<union>\n                 (let b' = \\<anb> b cf; \\<beta> = [cf \\<mapsto> b]\n                  in (\\<Union>cnt\\<in>cntfs.\n                         a_evalF\\<cdot>(Discr (cnt, [], ve, b'))) \\<union>\n                     {((cf, \\<beta>), cnt) |cnt. cnt \\<in> cntfs})\n             | (PP (prim.If ct cf), x # cntts # cntfs # ac # lista,\n                bb) \\<Rightarrow>\n                 \\<bottom>\n             | (AStop, [], bb) \\<Rightarrow> \\<bottom>\n             | (AStop, [x], xa, xb) \\<Rightarrow> {}\n             | (AStop, x # a # lista, bb) \\<Rightarrow> \\<bottom>,\n          \\<Lambda> cstate.\n             case undiscr cstate of\n             (App lab f vs, \\<beta>, ve, b) \\<Rightarrow>\n               let fs = \\<aA> f \\<beta> ve;\n                   as = map (\\<lambda>v. \\<aA> v \\<beta> ve) vs;\n                   b' = \\<anb> b lab\n               in (\\<Union>f'\\<in>fs.\n                      a_evalF\\<cdot>(Discr (f', as, ve, b'))) \\<union>\n                  {((lab, \\<beta>), f') |f'. f' \\<in> fs}\n             | (call.Let lab ls c', \\<beta>, ve, b) \\<Rightarrow>\n                 let b' = \\<anb> b lab;\n                     \\<beta>' = \\<beta>(lab \\<mapsto> b');\n                     ve' =\n                       ve \\<union>. \\<Union>.map\n        (\\<lambda>(v, l). { (v, b') := \\<aA> (L l) \\<beta>' ve}.) ls\n                 in a_evalC\\<cdot>(Discr (c', \\<beta>', ve', b')))) oo\n    sum_to_tup =\n    (\\<Lambda> f x.\n        \\<Union> (Rep_cfun f ` abs_R\\<cdot>x) \\<union> abs_g\\<cdot>x)", "apply (simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Lambda> f s.\n        case undiscr s of\n        Inl x \\<Rightarrow>\n          (\\<Lambda> fstate.\n              case undiscr fstate of\n              (PC (Lambda lab vs c, \\<beta>), as, ve, b) \\<Rightarrow>\n                if length vs = length as\n                then let \\<beta>' = \\<beta>(lab \\<mapsto> b);\n                         ve' =\n                           ve \\<union>. \\<Union>.map2\n            (\\<lambda>v. smap_singleton (v, b)) vs as\n                     in (\\<Lambda> s.\n                            f\\<cdot>(Discr (Inr (undiscr s))))\\<cdot>\n                        (Discr (c, \\<beta>', ve', b))\n                else \\<bottom>\n              | (PP (Plus c), [], bb) \\<Rightarrow> \\<bottom>\n              | (PP (Plus c), [x], bb) \\<Rightarrow> \\<bottom>\n              | (PP (Plus c), [x, xaa], bb) \\<Rightarrow> \\<bottom>\n              | (PP (Plus c), [x, xaa, cnts], ve, b) \\<Rightarrow>\n                  let b' = \\<anb> b c; \\<beta> = [c \\<mapsto> b]\n                  in (\\<Union>cnt\\<in>cnts.\n                         (\\<Lambda> s.\n                             f\\<cdot>(Discr (Inl (undiscr s))))\\<cdot>\n                         (Discr (cnt, [{}], ve, b'))) \\<union>\n                     {((c, \\<beta>), cont) |cont. cont \\<in> cnts}\n              | (PP (Plus c), x # xaa # cnts # ac # lista, bb) \\<Rightarrow>\n                  \\<bottom>\n              | (PP (prim.If ct cf), [], bb) \\<Rightarrow> \\<bottom>\n              | (PP (prim.If ct cf), [x], bb) \\<Rightarrow> \\<bottom>\n              | (PP (prim.If ct cf), [x, cntts], bb) \\<Rightarrow> \\<bottom>\n              | (PP (prim.If ct cf), [x, cntts, cntfs], ve, b) \\<Rightarrow>\n                  (let b' = \\<anb> b ct; \\<beta> = [ct \\<mapsto> b]\n                   in (\\<Union>cnt\\<in>cntts.\n                          (\\<Lambda> s.\n                              f\\<cdot>(Discr (Inl (undiscr s))))\\<cdot>\n                          (Discr (cnt, [], ve, b'))) \\<union>\n                      {((ct, \\<beta>), cnt) |cnt. cnt \\<in> cntts}) \\<union>\n                  (let b' = \\<anb> b cf; \\<beta> = [cf \\<mapsto> b]\n                   in (\\<Union>cnt\\<in>cntfs.\n                          (\\<Lambda> s.\n                              f\\<cdot>(Discr (Inl (undiscr s))))\\<cdot>\n                          (Discr (cnt, [], ve, b'))) \\<union>\n                      {((cf, \\<beta>), cnt) |cnt. cnt \\<in> cntfs})\n              | (PP (prim.If ct cf), x # cntts # cntfs # ac # lista,\n                 bb) \\<Rightarrow>\n                  \\<bottom>\n              | (AStop, [], bb) \\<Rightarrow> \\<bottom>\n              | (AStop, [x], xa, xb) \\<Rightarrow> {}\n              | (AStop, x # a # lista, bb) \\<Rightarrow> \\<bottom>)\\<cdot>\n          (Discr x)\n        | Inr x \\<Rightarrow>\n            (\\<Lambda> cstate.\n                case undiscr cstate of\n                (App lab fa vs, \\<beta>, ve, b) \\<Rightarrow>\n                  let fs = \\<aA> fa \\<beta> ve;\n                      as = map (\\<lambda>v. \\<aA> v \\<beta> ve) vs;\n                      b' = \\<anb> b lab\n                  in (\\<Union>f'\\<in>fs.\n                         (\\<Lambda> s.\n                             f\\<cdot>(Discr (Inl (undiscr s))))\\<cdot>\n                         (Discr (f', as, ve, b'))) \\<union>\n                     {((lab, \\<beta>), f') |f'. f' \\<in> fs}\n                | (call.Let lab ls c', \\<beta>, ve, b) \\<Rightarrow>\n                    let b' = \\<anb> b lab;\n                        \\<beta>' = \\<beta>(lab \\<mapsto> b');\n                        ve' =\n                          ve \\<union>. \\<Union>.map\n           (\\<lambda>(v, l). { (v, b') := \\<aA> (L l) \\<beta>' ve}.) ls\n                    in (\\<Lambda> s.\n                           f\\<cdot>(Discr (Inr (undiscr s))))\\<cdot>\n                       (Discr (c', \\<beta>', ve', b')))\\<cdot>\n            (Discr x)) =\n    (\\<Lambda> f x.\n        \\<Union>\n         (Rep_cfun f `\n          (case undiscr x of\n           Inl (PC (Lambda lab vs c, \\<beta>), as, ve, b) \\<Rightarrow>\n             if length vs = length as\n             then let \\<beta>' = \\<beta>(lab \\<mapsto> b);\n                      ve' =\n                        ve \\<union>. \\<Union>.map2\n         (\\<lambda>v. smap_singleton (v, b)) vs as\n                  in {Discr (Inr (c, \\<beta>', ve', b))}\n             else \\<bottom>\n           | Inl (PP (Plus c), [], bb) \\<Rightarrow> \\<bottom>\n           | Inl (PP (Plus c), [x], bb) \\<Rightarrow> \\<bottom>\n           | Inl (PP (Plus c), [x, xa], bb) \\<Rightarrow> \\<bottom>\n           | Inl (PP (Plus c), [x, xa, cnts], ve, b) \\<Rightarrow>\n               let b' = \\<anb> b c; \\<beta> = [c \\<mapsto> b]\n               in \\<Union>cnt\\<in>cnts. {Discr (Inl (cnt, [{}], ve, b'))}\n           | Inl (PP (Plus c), x # xa # cnts # ac # lista, bb) \\<Rightarrow>\n               \\<bottom>\n           | Inl (PP (prim.If ct cf), [], bb) \\<Rightarrow> \\<bottom>\n           | Inl (PP (prim.If ct cf), [x], bb) \\<Rightarrow> \\<bottom>\n           | Inl (PP (prim.If ct cf), [x, cntts], bb) \\<Rightarrow>\n               \\<bottom>\n           | Inl (PP (prim.If ct cf), [x, cntts, cntfs], ve,\n                  b) \\<Rightarrow>\n               (let b' = \\<anb> b ct; \\<beta> = [ct \\<mapsto> b]\n                in \\<Union>cnt\\<in>cntts.\n                      {Discr (Inl (cnt, [], ve, b'))}) \\<union>\n               (let b' = \\<anb> b cf; \\<beta> = [cf \\<mapsto> b]\n                in \\<Union>cnt\\<in>cntfs. {Discr (Inl (cnt, [], ve, b'))})\n           | Inl (PP (prim.If ct cf), x # cntts # cntfs # ac # lista,\n                  bb) \\<Rightarrow>\n               \\<bottom>\n           | Inl (AStop, [], bb) \\<Rightarrow> \\<bottom>\n           | Inl (AStop, [x], xa, xb) \\<Rightarrow> {}\n           | Inl (AStop, x # a # lista, bb) \\<Rightarrow> \\<bottom>\n           | Inr (App lab f vs, \\<beta>, ve, b) \\<Rightarrow>\n               let fs = \\<aA> f \\<beta> ve;\n                   as = map (\\<lambda>v. \\<aA> v \\<beta> ve) vs;\n                   b' = \\<anb> b lab\n               in \\<Union>f'\\<in>fs. {Discr (Inl (f', as, ve, b'))}\n           | Inr (call.Let lab ls c', \\<beta>, ve, b) \\<Rightarrow>\n               let b' = \\<anb> b lab; \\<beta>' = \\<beta>(lab \\<mapsto> b');\n                   ve' =\n                     ve \\<union>. \\<Union>.map\n      (\\<lambda>(v, l). { (v, b') := \\<aA> (L l) \\<beta>' ve}.) ls\n               in {Discr (Inr (c', \\<beta>', ve', b'))})) \\<union>\n        (case undiscr x of\n         Inl (PC (Lambda lab vs c, \\<beta>), as, ve, b) \\<Rightarrow> {}\n         | Inl (PP (Plus c), [], bb) \\<Rightarrow> \\<bottom>\n         | Inl (PP (Plus c), [x], bb) \\<Rightarrow> \\<bottom>\n         | Inl (PP (Plus c), [x, xa], bb) \\<Rightarrow> \\<bottom>\n         | Inl (PP (Plus c), [x, xa, cnts], ve, b) \\<Rightarrow>\n             let b' = \\<anb> b c; \\<beta> = [c \\<mapsto> b]\n             in {((c, \\<beta>), cont) |cont. cont \\<in> cnts}\n         | Inl (PP (Plus c), x # xa # cnts # ac # lista, bb) \\<Rightarrow>\n             \\<bottom>\n         | Inl (PP (prim.If ct cf), [], bb) \\<Rightarrow> \\<bottom>\n         | Inl (PP (prim.If ct cf), [x], bb) \\<Rightarrow> \\<bottom>\n         | Inl (PP (prim.If ct cf), [x, cntts], bb) \\<Rightarrow> \\<bottom>\n         | Inl (PP (prim.If ct cf), [x, cntts, cntfs], ve, b) \\<Rightarrow>\n             (let b' = \\<anb> b ct; \\<beta> = [ct \\<mapsto> b]\n              in {((ct, \\<beta>), cnt) |cnt. cnt \\<in> cntts}) \\<union>\n             (let b' = \\<anb> b cf; \\<beta> = [cf \\<mapsto> b]\n              in {((cf, \\<beta>), cnt) |cnt. cnt \\<in> cntfs})\n         | Inl (PP (prim.If ct cf), x # cntts # cntfs # ac # lista,\n                bb) \\<Rightarrow>\n             \\<bottom>\n         | Inl (AStop, [], bb) \\<Rightarrow> \\<bottom>\n         | Inl (AStop, [x], xa, xb) \\<Rightarrow> {}\n         | Inl (AStop, x # a # lista, bb) \\<Rightarrow> \\<bottom>\n         | Inr (App lab f vs, \\<beta>, ve, b) \\<Rightarrow>\n             let fs = \\<aA> f \\<beta> ve;\n                 as = map (\\<lambda>v. \\<aA> v \\<beta> ve) vs;\n                 b' = \\<anb> b lab\n             in {((lab, \\<beta>), f') |f'. f' \\<in> fs}\n         | Inr (call.Let lab ls c', \\<beta>, ve, b) \\<Rightarrow> {}))", "apply (simp only: discr_app undiscr_Discr)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Lambda> f s.\n        case undiscr s of\n        Inl (PC (Lambda lab vs c, \\<beta>), as, ve, b) \\<Rightarrow>\n          if length vs = length as\n          then let \\<beta>' = \\<beta>(lab \\<mapsto> b);\n                   ve' =\n                     ve \\<union>. \\<Union>.map2\n      (\\<lambda>v. smap_singleton (v, b)) vs as\n               in f\\<cdot>(Discr (Inr (c, \\<beta>', ve', b)))\n          else \\<bottom>\n        | Inl (PP (Plus c), [], bb) \\<Rightarrow> \\<bottom>\n        | Inl (PP (Plus c), [x], bb) \\<Rightarrow> \\<bottom>\n        | Inl (PP (Plus c), [x, xaa], bb) \\<Rightarrow> \\<bottom>\n        | Inl (PP (Plus c), [x, xaa, cnts], ve, b) \\<Rightarrow>\n            let b' = \\<anb> b c; \\<beta> = [c \\<mapsto> b]\n            in (\\<Union>cnt\\<in>cnts.\n                   f\\<cdot>(Discr (Inl (cnt, [{}], ve, b')))) \\<union>\n               {((c, \\<beta>), cont) |cont. cont \\<in> cnts}\n        | Inl (PP (Plus c), x # xaa # cnts # ac # lista, bb) \\<Rightarrow>\n            \\<bottom>\n        | Inl (PP (prim.If ct cf), [], bb) \\<Rightarrow> \\<bottom>\n        | Inl (PP (prim.If ct cf), [x], bb) \\<Rightarrow> \\<bottom>\n        | Inl (PP (prim.If ct cf), [x, cntts], bb) \\<Rightarrow> \\<bottom>\n        | Inl (PP (prim.If ct cf), [x, cntts, cntfs], ve, b) \\<Rightarrow>\n            (let b' = \\<anb> b ct; \\<beta> = [ct \\<mapsto> b]\n             in (\\<Union>cnt\\<in>cntts.\n                    f\\<cdot>(Discr (Inl (cnt, [], ve, b')))) \\<union>\n                {((ct, \\<beta>), cnt) |cnt. cnt \\<in> cntts}) \\<union>\n            (let b' = \\<anb> b cf; \\<beta> = [cf \\<mapsto> b]\n             in (\\<Union>cnt\\<in>cntfs.\n                    f\\<cdot>(Discr (Inl (cnt, [], ve, b')))) \\<union>\n                {((cf, \\<beta>), cnt) |cnt. cnt \\<in> cntfs})\n        | Inl (PP (prim.If ct cf), x # cntts # cntfs # ac # lista,\n               bb) \\<Rightarrow>\n            \\<bottom>\n        | Inl (AStop, [], bb) \\<Rightarrow> \\<bottom>\n        | Inl (AStop, [x], xa, xb) \\<Rightarrow> {}\n        | Inl (AStop, x # a # lista, bb) \\<Rightarrow> \\<bottom>\n        | Inr (App lab fa vs, \\<beta>, ve, b) \\<Rightarrow>\n            let fs = \\<aA> fa \\<beta> ve;\n                as = map (\\<lambda>v. \\<aA> v \\<beta> ve) vs;\n                b' = \\<anb> b lab\n            in (\\<Union>f'\\<in>fs.\n                   f\\<cdot>(Discr (Inl (f', as, ve, b')))) \\<union>\n               {((lab, \\<beta>), f') |f'. f' \\<in> fs}\n        | Inr (call.Let lab ls c', \\<beta>, ve, b) \\<Rightarrow>\n            let b' = \\<anb> b lab; \\<beta>' = \\<beta>(lab \\<mapsto> b');\n                ve' =\n                  ve \\<union>. \\<Union>.map\n   (\\<lambda>(v, l). { (v, b') := \\<aA> (L l) \\<beta>' ve}.) ls\n            in f\\<cdot>(Discr (Inr (c', \\<beta>', ve', b')))) =\n    (\\<Lambda> f x.\n        \\<Union>\n         (Rep_cfun f `\n          (case undiscr x of\n           Inl (PC (Lambda lab vs c, \\<beta>), as, ve, b) \\<Rightarrow>\n             if length vs = length as\n             then let \\<beta>' = \\<beta>(lab \\<mapsto> b);\n                      ve' =\n                        ve \\<union>. \\<Union>.map2\n         (\\<lambda>v. smap_singleton (v, b)) vs as\n                  in {Discr (Inr (c, \\<beta>', ve', b))}\n             else \\<bottom>\n           | Inl (PP (Plus c), [], bb) \\<Rightarrow> \\<bottom>\n           | Inl (PP (Plus c), [x], bb) \\<Rightarrow> \\<bottom>\n           | Inl (PP (Plus c), [x, xa], bb) \\<Rightarrow> \\<bottom>\n           | Inl (PP (Plus c), [x, xa, cnts], ve, b) \\<Rightarrow>\n               let b' = \\<anb> b c; \\<beta> = [c \\<mapsto> b]\n               in \\<Union>cnt\\<in>cnts. {Discr (Inl (cnt, [{}], ve, b'))}\n           | Inl (PP (Plus c), x # xa # cnts # ac # lista, bb) \\<Rightarrow>\n               \\<bottom>\n           | Inl (PP (prim.If ct cf), [], bb) \\<Rightarrow> \\<bottom>\n           | Inl (PP (prim.If ct cf), [x], bb) \\<Rightarrow> \\<bottom>\n           | Inl (PP (prim.If ct cf), [x, cntts], bb) \\<Rightarrow>\n               \\<bottom>\n           | Inl (PP (prim.If ct cf), [x, cntts, cntfs], ve,\n                  b) \\<Rightarrow>\n               (let b' = \\<anb> b ct; \\<beta> = [ct \\<mapsto> b]\n                in \\<Union>cnt\\<in>cntts.\n                      {Discr (Inl (cnt, [], ve, b'))}) \\<union>\n               (let b' = \\<anb> b cf; \\<beta> = [cf \\<mapsto> b]\n                in \\<Union>cnt\\<in>cntfs. {Discr (Inl (cnt, [], ve, b'))})\n           | Inl (PP (prim.If ct cf), x # cntts # cntfs # ac # lista,\n                  bb) \\<Rightarrow>\n               \\<bottom>\n           | Inl (AStop, [], bb) \\<Rightarrow> \\<bottom>\n           | Inl (AStop, [x], xa, xb) \\<Rightarrow> {}\n           | Inl (AStop, x # a # lista, bb) \\<Rightarrow> \\<bottom>\n           | Inr (App lab f vs, \\<beta>, ve, b) \\<Rightarrow>\n               let fs = \\<aA> f \\<beta> ve;\n                   as = map (\\<lambda>v. \\<aA> v \\<beta> ve) vs;\n                   b' = \\<anb> b lab\n               in \\<Union>f'\\<in>fs. {Discr (Inl (f', as, ve, b'))}\n           | Inr (call.Let lab ls c', \\<beta>, ve, b) \\<Rightarrow>\n               let b' = \\<anb> b lab; \\<beta>' = \\<beta>(lab \\<mapsto> b');\n                   ve' =\n                     ve \\<union>. \\<Union>.map\n      (\\<lambda>(v, l). { (v, b') := \\<aA> (L l) \\<beta>' ve}.) ls\n               in {Discr (Inr (c', \\<beta>', ve', b'))})) \\<union>\n        (case undiscr x of\n         Inl (PC (Lambda lab vs c, \\<beta>), as, ve, b) \\<Rightarrow> {}\n         | Inl (PP (Plus c), [], bb) \\<Rightarrow> \\<bottom>\n         | Inl (PP (Plus c), [x], bb) \\<Rightarrow> \\<bottom>\n         | Inl (PP (Plus c), [x, xa], bb) \\<Rightarrow> \\<bottom>\n         | Inl (PP (Plus c), [x, xa, cnts], ve, b) \\<Rightarrow>\n             let b' = \\<anb> b c; \\<beta> = [c \\<mapsto> b]\n             in {((c, \\<beta>), cont) |cont. cont \\<in> cnts}\n         | Inl (PP (Plus c), x # xa # cnts # ac # lista, bb) \\<Rightarrow>\n             \\<bottom>\n         | Inl (PP (prim.If ct cf), [], bb) \\<Rightarrow> \\<bottom>\n         | Inl (PP (prim.If ct cf), [x], bb) \\<Rightarrow> \\<bottom>\n         | Inl (PP (prim.If ct cf), [x, cntts], bb) \\<Rightarrow> \\<bottom>\n         | Inl (PP (prim.If ct cf), [x, cntts, cntfs], ve, b) \\<Rightarrow>\n             (let b' = \\<anb> b ct; \\<beta> = [ct \\<mapsto> b]\n              in {((ct, \\<beta>), cnt) |cnt. cnt \\<in> cntts}) \\<union>\n             (let b' = \\<anb> b cf; \\<beta> = [cf \\<mapsto> b]\n              in {((cf, \\<beta>), cnt) |cnt. cnt \\<in> cntfs})\n         | Inl (PP (prim.If ct cf), x # cntts # cntfs # ac # lista,\n                bb) \\<Rightarrow>\n             \\<bottom>\n         | Inl (AStop, [], bb) \\<Rightarrow> \\<bottom>\n         | Inl (AStop, [x], xa, xb) \\<Rightarrow> {}\n         | Inl (AStop, x # a # lista, bb) \\<Rightarrow> \\<bottom>\n         | Inr (App lab f vs, \\<beta>, ve, b) \\<Rightarrow>\n             let fs = \\<aA> f \\<beta> ve;\n                 as = map (\\<lambda>v. \\<aA> v \\<beta> ve) vs;\n                 b' = \\<anb> b lab\n             in {((lab, \\<beta>), f') |f'. f' \\<in> fs}\n         | Inr (call.Let lab ls c', \\<beta>, ve, b) \\<Rightarrow> {}))", "apply (rule cfun_eqI, rule cfun_eqI, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       (case undiscr xa of\n        Inl (PC (Lambda lab vs c, \\<beta>), as, ve, b) \\<Rightarrow>\n          if length vs = length as\n          then let \\<beta>' = \\<beta>(lab \\<mapsto> b);\n                   ve' =\n                     ve \\<union>. \\<Union>.map2\n      (\\<lambda>v. smap_singleton (v, b)) vs as\n               in x\\<cdot>(Discr (Inr (c, \\<beta>', ve', b)))\n          else \\<bottom>\n        | Inl (PP (Plus c), [], bb) \\<Rightarrow> \\<bottom>\n        | Inl (PP (Plus c), [xa], bb) \\<Rightarrow> \\<bottom>\n        | Inl (PP (Plus c), [xa, xaa], bb) \\<Rightarrow> \\<bottom>\n        | Inl (PP (Plus c), [xa, xaa, cnts], ve, b) \\<Rightarrow>\n            let b' = \\<anb> b c; \\<beta> = [c \\<mapsto> b]\n            in (\\<Union>cnt\\<in>cnts.\n                   x\\<cdot>(Discr (Inl (cnt, [{}], ve, b')))) \\<union>\n               {((c, \\<beta>), cont) |cont. cont \\<in> cnts}\n        | Inl (PP (Plus c), xa # xaa # cnts # ac # lista, bb) \\<Rightarrow>\n            \\<bottom>\n        | Inl (PP (prim.If ct cf), [], bb) \\<Rightarrow> \\<bottom>\n        | Inl (PP (prim.If ct cf), [xa], bb) \\<Rightarrow> \\<bottom>\n        | Inl (PP (prim.If ct cf), [xa, cntts], bb) \\<Rightarrow> \\<bottom>\n        | Inl (PP (prim.If ct cf), [xa, cntts, cntfs], ve, b) \\<Rightarrow>\n            (let b' = \\<anb> b ct; \\<beta> = [ct \\<mapsto> b]\n             in (\\<Union>cnt\\<in>cntts.\n                    x\\<cdot>(Discr (Inl (cnt, [], ve, b')))) \\<union>\n                {((ct, \\<beta>), cnt) |cnt. cnt \\<in> cntts}) \\<union>\n            (let b' = \\<anb> b cf; \\<beta> = [cf \\<mapsto> b]\n             in (\\<Union>cnt\\<in>cntfs.\n                    x\\<cdot>(Discr (Inl (cnt, [], ve, b')))) \\<union>\n                {((cf, \\<beta>), cnt) |cnt. cnt \\<in> cntfs})\n        | Inl (PP (prim.If ct cf), xa # cntts # cntfs # ac # lista,\n               bb) \\<Rightarrow>\n            \\<bottom>\n        | Inl (AStop, [], bb) \\<Rightarrow> \\<bottom>\n        | Inl (AStop, [x], xa, xb) \\<Rightarrow> {}\n        | Inl (AStop, x # a # lista, bb) \\<Rightarrow> \\<bottom>\n        | Inr (App lab f vs, \\<beta>, ve, b) \\<Rightarrow>\n            let fs = \\<aA> f \\<beta> ve;\n                as = map (\\<lambda>v. \\<aA> v \\<beta> ve) vs;\n                b' = \\<anb> b lab\n            in (\\<Union>f'\\<in>fs.\n                   x\\<cdot>(Discr (Inl (f', as, ve, b')))) \\<union>\n               {((lab, \\<beta>), f') |f'. f' \\<in> fs}\n        | Inr (call.Let lab ls c', \\<beta>, ve, b) \\<Rightarrow>\n            let b' = \\<anb> b lab; \\<beta>' = \\<beta>(lab \\<mapsto> b');\n                ve' =\n                  ve \\<union>. \\<Union>.map\n   (\\<lambda>(v, l). { (v, b') := \\<aA> (L l) \\<beta>' ve}.) ls\n            in x\\<cdot>(Discr (Inr (c', \\<beta>', ve', b')))) =\n       \\<Union>\n        (Rep_cfun x `\n         (case undiscr xa of\n          Inl (PC (Lambda lab vs c, \\<beta>), as, ve, b) \\<Rightarrow>\n            if length vs = length as\n            then let \\<beta>' = \\<beta>(lab \\<mapsto> b);\n                     ve' =\n                       ve \\<union>. \\<Union>.map2\n        (\\<lambda>v. smap_singleton (v, b)) vs as\n                 in {Discr (Inr (c, \\<beta>', ve', b))}\n            else \\<bottom>\n          | Inl (PP (Plus c), [], bb) \\<Rightarrow> \\<bottom>\n          | Inl (PP (Plus c), [x], bb) \\<Rightarrow> \\<bottom>\n          | Inl (PP (Plus c), [x, xaa], bb) \\<Rightarrow> \\<bottom>\n          | Inl (PP (Plus c), [x, xaa, cnts], ve, b) \\<Rightarrow>\n              let b' = \\<anb> b c; \\<beta> = [c \\<mapsto> b]\n              in \\<Union>cnt\\<in>cnts. {Discr (Inl (cnt, [{}], ve, b'))}\n          | Inl (PP (Plus c), x # xaa # cnts # ac # lista, bb) \\<Rightarrow>\n              \\<bottom>\n          | Inl (PP (prim.If ct cf), [], bb) \\<Rightarrow> \\<bottom>\n          | Inl (PP (prim.If ct cf), [x], bb) \\<Rightarrow> \\<bottom>\n          | Inl (PP (prim.If ct cf), [x, cntts], bb) \\<Rightarrow> \\<bottom>\n          | Inl (PP (prim.If ct cf), [x, cntts, cntfs], ve, b) \\<Rightarrow>\n              (let b' = \\<anb> b ct; \\<beta> = [ct \\<mapsto> b]\n               in \\<Union>cnt\\<in>cntts.\n                     {Discr (Inl (cnt, [], ve, b'))}) \\<union>\n              (let b' = \\<anb> b cf; \\<beta> = [cf \\<mapsto> b]\n               in \\<Union>cnt\\<in>cntfs. {Discr (Inl (cnt, [], ve, b'))})\n          | Inl (PP (prim.If ct cf), x # cntts # cntfs # ac # lista,\n                 bb) \\<Rightarrow>\n              \\<bottom>\n          | Inl (AStop, [], bb) \\<Rightarrow> \\<bottom>\n          | Inl (AStop, [x], xa, xb) \\<Rightarrow> {}\n          | Inl (AStop, x # a # lista, bb) \\<Rightarrow> \\<bottom>\n          | Inr (App lab f vs, \\<beta>, ve, b) \\<Rightarrow>\n              let fs = \\<aA> f \\<beta> ve;\n                  as = map (\\<lambda>v. \\<aA> v \\<beta> ve) vs;\n                  b' = \\<anb> b lab\n              in \\<Union>f'\\<in>fs. {Discr (Inl (f', as, ve, b'))}\n          | Inr (call.Let lab ls c', \\<beta>, ve, b) \\<Rightarrow>\n              let b' = \\<anb> b lab; \\<beta>' = \\<beta>(lab \\<mapsto> b');\n                  ve' =\n                    ve \\<union>. \\<Union>.map\n     (\\<lambda>(v, l). { (v, b') := \\<aA> (L l) \\<beta>' ve}.) ls\n              in {Discr (Inr (c', \\<beta>', ve', b'))})) \\<union>\n       (case undiscr xa of\n        Inl (PC (Lambda lab vs c, \\<beta>), as, ve, b) \\<Rightarrow> {}\n        | Inl (PP (Plus c), [], bb) \\<Rightarrow> \\<bottom>\n        | Inl (PP (Plus c), [x], bb) \\<Rightarrow> \\<bottom>\n        | Inl (PP (Plus c), [x, xaa], bb) \\<Rightarrow> \\<bottom>\n        | Inl (PP (Plus c), [x, xaa, cnts], ve, b) \\<Rightarrow>\n            let b' = \\<anb> b c; \\<beta> = [c \\<mapsto> b]\n            in {((c, \\<beta>), cont) |cont. cont \\<in> cnts}\n        | Inl (PP (Plus c), x # xaa # cnts # ac # lista, bb) \\<Rightarrow>\n            \\<bottom>\n        | Inl (PP (prim.If ct cf), [], bb) \\<Rightarrow> \\<bottom>\n        | Inl (PP (prim.If ct cf), [x], bb) \\<Rightarrow> \\<bottom>\n        | Inl (PP (prim.If ct cf), [x, cntts], bb) \\<Rightarrow> \\<bottom>\n        | Inl (PP (prim.If ct cf), [x, cntts, cntfs], ve, b) \\<Rightarrow>\n            (let b' = \\<anb> b ct; \\<beta> = [ct \\<mapsto> b]\n             in {((ct, \\<beta>), cnt) |cnt. cnt \\<in> cntts}) \\<union>\n            (let b' = \\<anb> b cf; \\<beta> = [cf \\<mapsto> b]\n             in {((cf, \\<beta>), cnt) |cnt. cnt \\<in> cntfs})\n        | Inl (PP (prim.If ct cf), x # cntts # cntfs # ac # lista,\n               bb) \\<Rightarrow>\n            \\<bottom>\n        | Inl (AStop, [], bb) \\<Rightarrow> \\<bottom>\n        | Inl (AStop, [x], xa, xb) \\<Rightarrow> {}\n        | Inl (AStop, x # a # lista, bb) \\<Rightarrow> \\<bottom>\n        | Inr (App lab f vs, \\<beta>, ve, b) \\<Rightarrow>\n            let fs = \\<aA> f \\<beta> ve;\n                as = map (\\<lambda>v. \\<aA> v \\<beta> ve) vs;\n                b' = \\<anb> b lab\n            in {((lab, \\<beta>), f') |f'. f' \\<in> fs}\n        | Inr (call.Let lab ls c', \\<beta>, ve, b) \\<Rightarrow> {})", "apply (case_tac xa, rename_tac a, case_tac a, simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xa a aa.\n       \\<lbrakk>xa = Discr (Inl aa); a = Inl aa\\<rbrakk>\n       \\<Longrightarrow> (case aa of\n                          (PC (Lambda lab vs c, \\<beta>), as, ve,\n                           b) \\<Rightarrow>\n                            if length vs = length as\n                            then let \\<beta>' = \\<beta>(lab \\<mapsto> b);\n                                     ve' =\n ve \\<union>. \\<Union>.map2 (\\<lambda>v. smap_singleton (v, b)) vs as\n                                 in x\\<cdot>\n                                    (Discr (Inr (c, \\<beta>', ve', b)))\n                            else \\<bottom>\n                          | (PP (Plus c), [], bb) \\<Rightarrow> \\<bottom>\n                          | (PP (Plus c), [xa], bb) \\<Rightarrow> \\<bottom>\n                          | (PP (Plus c), [xa, xaa], bb) \\<Rightarrow>\n                              \\<bottom>\n                          | (PP (Plus c), [xa, xaa, cnts], ve,\n                             b) \\<Rightarrow>\n                              let b' = \\<anb> b c; \\<beta> = [c \\<mapsto> b]\n                              in (\\<Union>cnt\\<in>cnts.\n                                     x\\<cdot>\n                                     (Discr\n (Inl (cnt, [{}], ve, b')))) \\<union>\n                                 {((c, \\<beta>), cont) |cont.\n                                  cont \\<in> cnts}\n                          | (PP (Plus c), xa # xaa # cnts # ac # lista,\n                             bb) \\<Rightarrow>\n                              \\<bottom>\n                          | (PP (prim.If ct cf), [], bb) \\<Rightarrow>\n                              \\<bottom>\n                          | (PP (prim.If ct cf), [xa], bb) \\<Rightarrow>\n                              \\<bottom>\n                          | (PP (prim.If ct cf), [xa, cntts],\n                             bb) \\<Rightarrow>\n                              \\<bottom>\n                          | (PP (prim.If ct cf), [xa, cntts, cntfs], ve,\n                             b) \\<Rightarrow>\n                              (let b' = \\<anb> b ct;\n                                   \\<beta> = [ct \\<mapsto> b]\n                               in (\\<Union>cnt\\<in>cntts.\nx\\<cdot>(Discr (Inl (cnt, [], ve, b')))) \\<union>\n                                  {((ct, \\<beta>), cnt) |cnt.\n                                   cnt \\<in> cntts}) \\<union>\n                              (let b' = \\<anb> b cf;\n                                   \\<beta> = [cf \\<mapsto> b]\n                               in (\\<Union>cnt\\<in>cntfs.\nx\\<cdot>(Discr (Inl (cnt, [], ve, b')))) \\<union>\n                                  {((cf, \\<beta>), cnt) |cnt.\n                                   cnt \\<in> cntfs})\n                          | (PP (prim.If ct cf),\n                             xa # cntts # cntfs # ac # lista,\n                             bb) \\<Rightarrow>\n                              \\<bottom>\n                          | (AStop, [], bb) \\<Rightarrow> \\<bottom>\n                          | (AStop, [x], xa, xb) \\<Rightarrow> {}\n                          | (AStop, x # a # lista, bb) \\<Rightarrow>\n                              \\<bottom>) =\n                         \\<Union>\n                          (Rep_cfun x `\n                           (case aa of\n                            (PC (Lambda lab vs c, \\<beta>), as, ve,\n                             b) \\<Rightarrow>\n                              if length vs = length as\n                              then let \\<beta>' = \\<beta>(lab \\<mapsto> b);\n ve' = ve \\<union>. \\<Union>.map2 (\\<lambda>v. smap_singleton (v, b)) vs as\n                                   in {Discr (Inr (c, \\<beta>', ve', b))}\n                              else \\<bottom>\n                            | (PP (Plus c), [], bb) \\<Rightarrow> \\<bottom>\n                            | (PP (Plus c), [x], bb) \\<Rightarrow> \\<bottom>\n                            | (PP (Plus c), [x, xaa], bb) \\<Rightarrow>\n                                \\<bottom>\n                            | (PP (Plus c), [x, xaa, cnts], ve,\n                               b) \\<Rightarrow>\n                                let b' = \\<anb> b c;\n                                    \\<beta> = [c \\<mapsto> b]\n                                in \\<Union>cnt\\<in>cnts.\n{Discr (Inl (cnt, [{}], ve, b'))}\n                            | (PP (Plus c), x # xaa # cnts # ac # lista,\n                               bb) \\<Rightarrow>\n                                \\<bottom>\n                            | (PP (prim.If ct cf), [], bb) \\<Rightarrow>\n                                \\<bottom>\n                            | (PP (prim.If ct cf), [x], bb) \\<Rightarrow>\n                                \\<bottom>\n                            | (PP (prim.If ct cf), [x, cntts],\n                               bb) \\<Rightarrow>\n                                \\<bottom>\n                            | (PP (prim.If ct cf), [x, cntts, cntfs], ve,\n                               b) \\<Rightarrow>\n                                (let b' = \\<anb> b ct;\n                                     \\<beta> = [ct \\<mapsto> b]\n                                 in \\<Union>cnt\\<in>cntts.\n {Discr (Inl (cnt, [], ve, b'))}) \\<union>\n                                (let b' = \\<anb> b cf;\n                                     \\<beta> = [cf \\<mapsto> b]\n                                 in \\<Union>cnt\\<in>cntfs.\n {Discr (Inl (cnt, [], ve, b'))})\n                            | (PP (prim.If ct cf),\n                               x # cntts # cntfs # ac # lista,\n                               bb) \\<Rightarrow>\n                                \\<bottom>\n                            | (AStop, [], bb) \\<Rightarrow> \\<bottom>\n                            | (AStop, [x], xa, xb) \\<Rightarrow> {}\n                            | (AStop, x # a # lista, bb) \\<Rightarrow>\n                                \\<bottom>)) \\<union>\n                         (case aa of\n                          (PC (Lambda lab vs c, \\<beta>), as, ve,\n                           b) \\<Rightarrow>\n                            {}\n                          | (PP (Plus c), [], bb) \\<Rightarrow> \\<bottom>\n                          | (PP (Plus c), [x], bb) \\<Rightarrow> \\<bottom>\n                          | (PP (Plus c), [x, xaa], bb) \\<Rightarrow>\n                              \\<bottom>\n                          | (PP (Plus c), [x, xaa, cnts], ve,\n                             b) \\<Rightarrow>\n                              let b' = \\<anb> b c; \\<beta> = [c \\<mapsto> b]\n                              in {((c, \\<beta>), cont) |cont.\n                                  cont \\<in> cnts}\n                          | (PP (Plus c), x # xaa # cnts # ac # lista,\n                             bb) \\<Rightarrow>\n                              \\<bottom>\n                          | (PP (prim.If ct cf), [], bb) \\<Rightarrow>\n                              \\<bottom>\n                          | (PP (prim.If ct cf), [x], bb) \\<Rightarrow>\n                              \\<bottom>\n                          | (PP (prim.If ct cf), [x, cntts],\n                             bb) \\<Rightarrow>\n                              \\<bottom>\n                          | (PP (prim.If ct cf), [x, cntts, cntfs], ve,\n                             b) \\<Rightarrow>\n                              (let b' = \\<anb> b ct;\n                                   \\<beta> = [ct \\<mapsto> b]\n                               in {((ct, \\<beta>), cnt) |cnt.\n                                   cnt \\<in> cntts}) \\<union>\n                              (let b' = \\<anb> b cf;\n                                   \\<beta> = [cf \\<mapsto> b]\n                               in {((cf, \\<beta>), cnt) |cnt.\n                                   cnt \\<in> cntfs})\n                          | (PP (prim.If ct cf),\n                             x # cntts # cntfs # ac # lista,\n                             bb) \\<Rightarrow>\n                              \\<bottom>\n                          | (AStop, [], bb) \\<Rightarrow> \\<bottom>\n                          | (AStop, [x], xa, xb) \\<Rightarrow> {}\n                          | (AStop, x # a # lista, bb) \\<Rightarrow>\n                              \\<bottom>)\n 2. \\<And>x xa a b.\n       \\<lbrakk>xa = Discr a; a = Inr b\\<rbrakk>\n       \\<Longrightarrow> (case undiscr xa of\n                          Inl (PC (Lambda lab vs c, \\<beta>), as, ve,\n                               b) \\<Rightarrow>\n                            if length vs = length as\n                            then let \\<beta>' = \\<beta>(lab \\<mapsto> b);\n                                     ve' =\n ve \\<union>. \\<Union>.map2 (\\<lambda>v. smap_singleton (v, b)) vs as\n                                 in x\\<cdot>\n                                    (Discr (Inr (c, \\<beta>', ve', b)))\n                            else \\<bottom>\n                          | Inl (PP (Plus c), [], bb) \\<Rightarrow>\n                              \\<bottom>\n                          | Inl (PP (Plus c), [xa], bb) \\<Rightarrow>\n                              \\<bottom>\n                          | Inl (PP (Plus c), [xa, xaa], bb) \\<Rightarrow>\n                              \\<bottom>\n                          | Inl (PP (Plus c), [xa, xaa, cnts], ve,\n                                 b) \\<Rightarrow>\n                              let b' = \\<anb> b c; \\<beta> = [c \\<mapsto> b]\n                              in (\\<Union>cnt\\<in>cnts.\n                                     x\\<cdot>\n                                     (Discr\n (Inl (cnt, [{}], ve, b')))) \\<union>\n                                 {((c, \\<beta>), cont) |cont.\n                                  cont \\<in> cnts}\n                          | Inl (PP (Plus c), xa # xaa # cnts # ac # lista,\n                                 bb) \\<Rightarrow>\n                              \\<bottom>\n                          | Inl (PP (prim.If ct cf), [], bb) \\<Rightarrow>\n                              \\<bottom>\n                          | Inl (PP (prim.If ct cf), [xa], bb) \\<Rightarrow>\n                              \\<bottom>\n                          | Inl (PP (prim.If ct cf), [xa, cntts],\n                                 bb) \\<Rightarrow>\n                              \\<bottom>\n                          | Inl (PP (prim.If ct cf), [xa, cntts, cntfs], ve,\n                                 b) \\<Rightarrow>\n                              (let b' = \\<anb> b ct;\n                                   \\<beta> = [ct \\<mapsto> b]\n                               in (\\<Union>cnt\\<in>cntts.\nx\\<cdot>(Discr (Inl (cnt, [], ve, b')))) \\<union>\n                                  {((ct, \\<beta>), cnt) |cnt.\n                                   cnt \\<in> cntts}) \\<union>\n                              (let b' = \\<anb> b cf;\n                                   \\<beta> = [cf \\<mapsto> b]\n                               in (\\<Union>cnt\\<in>cntfs.\nx\\<cdot>(Discr (Inl (cnt, [], ve, b')))) \\<union>\n                                  {((cf, \\<beta>), cnt) |cnt.\n                                   cnt \\<in> cntfs})\n                          | Inl (PP (prim.If ct cf),\n                                 xa # cntts # cntfs # ac # lista,\n                                 bb) \\<Rightarrow>\n                              \\<bottom>\n                          | Inl (AStop, [], bb) \\<Rightarrow> \\<bottom>\n                          | Inl (AStop, [x], xa, xb) \\<Rightarrow> {}\n                          | Inl (AStop, x # a # lista, bb) \\<Rightarrow>\n                              \\<bottom>\n                          | Inr (App lab f vs, \\<beta>, ve, b) \\<Rightarrow>\n                              let fs = \\<aA> f \\<beta> ve;\n                                  as = map (\\<lambda>v. \\<aA> v \\<beta> ve)\n  vs;\n                                  b' = \\<anb> b lab\n                              in (\\<Union>f'\\<in>fs.\n                                     x\\<cdot>\n                                     (Discr\n (Inl (f', as, ve, b')))) \\<union>\n                                 {((lab, \\<beta>), f') |f'. f' \\<in> fs}\n                          | Inr (call.Let lab ls c', \\<beta>, ve,\n                                 b) \\<Rightarrow>\n                              let b' = \\<anb> b lab;\n                                  \\<beta>' = \\<beta>(lab \\<mapsto> b');\n                                  ve' =\n                                    ve \\<union>. \\<Union>.map\n                     (\\<lambda>(v, l).\n                         { (v, b') := \\<aA> (L l) \\<beta>' ve}.)\n                     ls\n                              in x\\<cdot>\n                                 (Discr (Inr (c', \\<beta>', ve', b')))) =\n                         \\<Union>\n                          (Rep_cfun x `\n                           (case undiscr xa of\n                            Inl (PC (Lambda lab vs c, \\<beta>), as, ve,\n                                 b) \\<Rightarrow>\n                              if length vs = length as\n                              then let \\<beta>' = \\<beta>(lab \\<mapsto> b);\n ve' = ve \\<union>. \\<Union>.map2 (\\<lambda>v. smap_singleton (v, b)) vs as\n                                   in {Discr (Inr (c, \\<beta>', ve', b))}\n                              else \\<bottom>\n                            | Inl (PP (Plus c), [], bb) \\<Rightarrow>\n                                \\<bottom>\n                            | Inl (PP (Plus c), [x], bb) \\<Rightarrow>\n                                \\<bottom>\n                            | Inl (PP (Plus c), [x, xaa], bb) \\<Rightarrow>\n                                \\<bottom>\n                            | Inl (PP (Plus c), [x, xaa, cnts], ve,\n                                   b) \\<Rightarrow>\n                                let b' = \\<anb> b c;\n                                    \\<beta> = [c \\<mapsto> b]\n                                in \\<Union>cnt\\<in>cnts.\n{Discr (Inl (cnt, [{}], ve, b'))}\n                            | Inl (PP (Plus c), x # xaa # cnts # ac # lista,\n                                   bb) \\<Rightarrow>\n                                \\<bottom>\n                            | Inl (PP (prim.If ct cf), [], bb) \\<Rightarrow>\n                                \\<bottom>\n                            | Inl (PP (prim.If ct cf), [x],\n                                   bb) \\<Rightarrow>\n                                \\<bottom>\n                            | Inl (PP (prim.If ct cf), [x, cntts],\n                                   bb) \\<Rightarrow>\n                                \\<bottom>\n                            | Inl (PP (prim.If ct cf), [x, cntts, cntfs],\n                                   ve, b) \\<Rightarrow>\n                                (let b' = \\<anb> b ct;\n                                     \\<beta> = [ct \\<mapsto> b]\n                                 in \\<Union>cnt\\<in>cntts.\n {Discr (Inl (cnt, [], ve, b'))}) \\<union>\n                                (let b' = \\<anb> b cf;\n                                     \\<beta> = [cf \\<mapsto> b]\n                                 in \\<Union>cnt\\<in>cntfs.\n {Discr (Inl (cnt, [], ve, b'))})\n                            | Inl (PP (prim.If ct cf),\n                                   x # cntts # cntfs # ac # lista,\n                                   bb) \\<Rightarrow>\n                                \\<bottom>\n                            | Inl (AStop, [], bb) \\<Rightarrow> \\<bottom>\n                            | Inl (AStop, [x], xa, xb) \\<Rightarrow> {}\n                            | Inl (AStop, x # a # lista, bb) \\<Rightarrow>\n                                \\<bottom>\n                            | Inr (App lab f vs, \\<beta>, ve,\n                                   b) \\<Rightarrow>\n                                let fs = \\<aA> f \\<beta> ve;\n                                    as =\nmap (\\<lambda>v. \\<aA> v \\<beta> ve) vs;\n                                    b' = \\<anb> b lab\n                                in \\<Union>f'\\<in>fs.\n{Discr (Inl (f', as, ve, b'))}\n                            | Inr (call.Let lab ls c', \\<beta>, ve,\n                                   b) \\<Rightarrow>\n                                let b' = \\<anb> b lab;\n                                    \\<beta>' = \\<beta>(lab \\<mapsto> b');\n                                    ve' =\nve \\<union>. \\<Union>.map (\\<lambda>(v, l).\n                              { (v, b') := \\<aA> (L l) \\<beta>' ve}.)\n                       ls\n                                in {Discr\n                                     (Inr\n (c', \\<beta>', ve', b'))})) \\<union>\n                         (case undiscr xa of\n                          Inl (PC (Lambda lab vs c, \\<beta>), as, ve,\n                               b) \\<Rightarrow>\n                            {}\n                          | Inl (PP (Plus c), [], bb) \\<Rightarrow>\n                              \\<bottom>\n                          | Inl (PP (Plus c), [x], bb) \\<Rightarrow>\n                              \\<bottom>\n                          | Inl (PP (Plus c), [x, xaa], bb) \\<Rightarrow>\n                              \\<bottom>\n                          | Inl (PP (Plus c), [x, xaa, cnts], ve,\n                                 b) \\<Rightarrow>\n                              let b' = \\<anb> b c; \\<beta> = [c \\<mapsto> b]\n                              in {((c, \\<beta>), cont) |cont.\n                                  cont \\<in> cnts}\n                          | Inl (PP (Plus c), x # xaa # cnts # ac # lista,\n                                 bb) \\<Rightarrow>\n                              \\<bottom>\n                          | Inl (PP (prim.If ct cf), [], bb) \\<Rightarrow>\n                              \\<bottom>\n                          | Inl (PP (prim.If ct cf), [x], bb) \\<Rightarrow>\n                              \\<bottom>\n                          | Inl (PP (prim.If ct cf), [x, cntts],\n                                 bb) \\<Rightarrow>\n                              \\<bottom>\n                          | Inl (PP (prim.If ct cf), [x, cntts, cntfs], ve,\n                                 b) \\<Rightarrow>\n                              (let b' = \\<anb> b ct;\n                                   \\<beta> = [ct \\<mapsto> b]\n                               in {((ct, \\<beta>), cnt) |cnt.\n                                   cnt \\<in> cntts}) \\<union>\n                              (let b' = \\<anb> b cf;\n                                   \\<beta> = [cf \\<mapsto> b]\n                               in {((cf, \\<beta>), cnt) |cnt.\n                                   cnt \\<in> cntfs})\n                          | Inl (PP (prim.If ct cf),\n                                 x # cntts # cntfs # ac # lista,\n                                 bb) \\<Rightarrow>\n                              \\<bottom>\n                          | Inl (AStop, [], bb) \\<Rightarrow> \\<bottom>\n                          | Inl (AStop, [x], xa, xb) \\<Rightarrow> {}\n                          | Inl (AStop, x # a # lista, bb) \\<Rightarrow>\n                              \\<bottom>\n                          | Inr (App lab f vs, \\<beta>, ve, b) \\<Rightarrow>\n                              let fs = \\<aA> f \\<beta> ve;\n                                  as = map (\\<lambda>v. \\<aA> v \\<beta> ve)\n  vs;\n                                  b' = \\<anb> b lab\n                              in {((lab, \\<beta>), f') |f'. f' \\<in> fs}\n                          | Inr (call.Let lab ls c', \\<beta>, ve,\n                                 b) \\<Rightarrow>\n                              {})", "apply (case_tac aa rule:a_fstate_case, simp_all add: Un_commute_helper)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa a b.\n       \\<lbrakk>xa = Discr (Inr b); a = Inr b\\<rbrakk>\n       \\<Longrightarrow> (case b of\n                          (App lab f vs, \\<beta>, ve, b) \\<Rightarrow>\n                            let fs = \\<aA> f \\<beta> ve;\n                                as = map (\\<lambda>v. \\<aA> v \\<beta> ve)\nvs;\n                                b' = \\<anb> b lab\n                            in (\\<Union>f'\\<in>fs.\n                                   x\\<cdot>\n                                   (Discr (Inl (f', as, ve, b')))) \\<union>\n                               {((lab, \\<beta>), f') |f'. f' \\<in> fs}\n                          | (call.Let lab ls c', \\<beta>, ve,\n                             b) \\<Rightarrow>\n                              let b' = \\<anb> b lab;\n                                  \\<beta>' = \\<beta>(lab \\<mapsto> b');\n                                  ve' =\n                                    ve \\<union>. \\<Union>.map\n                     (\\<lambda>(v, l).\n                         { (v, b') := \\<aA> (L l) \\<beta>' ve}.)\n                     ls\n                              in x\\<cdot>\n                                 (Discr (Inr (c', \\<beta>', ve', b')))) =\n                         \\<Union>\n                          (Rep_cfun x `\n                           (case b of\n                            (App lab f vs, \\<beta>, ve, b) \\<Rightarrow>\n                              let fs = \\<aA> f \\<beta> ve;\n                                  as = map (\\<lambda>v. \\<aA> v \\<beta> ve)\n  vs;\n                                  b' = \\<anb> b lab\n                              in \\<Union>f'\\<in>fs.\n                                    {Discr (Inl (f', as, ve, b'))}\n                            | (call.Let lab ls c', \\<beta>, ve,\n                               b) \\<Rightarrow>\n                                let b' = \\<anb> b lab;\n                                    \\<beta>' = \\<beta>(lab \\<mapsto> b');\n                                    ve' =\nve \\<union>. \\<Union>.map (\\<lambda>(v, l).\n                              { (v, b') := \\<aA> (L l) \\<beta>' ve}.)\n                       ls\n                                in {Discr\n                                     (Inr\n (c', \\<beta>', ve', b'))})) \\<union>\n                         (case b of\n                          (App lab f vs, \\<beta>, ve, b) \\<Rightarrow>\n                            let fs = \\<aA> f \\<beta> ve;\n                                as = map (\\<lambda>v. \\<aA> v \\<beta> ve)\nvs;\n                                b' = \\<anb> b lab\n                            in {((lab, \\<beta>), f') |f'. f' \\<in> fs}\n                          | (call.Let lab ls c', \\<beta>, ve,\n                             b) \\<Rightarrow>\n                              {})", "apply (case_tac b rule:prod_cases4)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa a b aa ba c d.\n       \\<lbrakk>xa = Discr (Inr b); a = Inr b; b = (aa, ba, c, d)\\<rbrakk>\n       \\<Longrightarrow> (case b of\n                          (App lab f vs, \\<beta>, ve, b) \\<Rightarrow>\n                            let fs = \\<aA> f \\<beta> ve;\n                                as = map (\\<lambda>v. \\<aA> v \\<beta> ve)\nvs;\n                                b' = \\<anb> b lab\n                            in (\\<Union>f'\\<in>fs.\n                                   x\\<cdot>\n                                   (Discr (Inl (f', as, ve, b')))) \\<union>\n                               {((lab, \\<beta>), f') |f'. f' \\<in> fs}\n                          | (call.Let lab ls c', \\<beta>, ve,\n                             b) \\<Rightarrow>\n                              let b' = \\<anb> b lab;\n                                  \\<beta>' = \\<beta>(lab \\<mapsto> b');\n                                  ve' =\n                                    ve \\<union>. \\<Union>.map\n                     (\\<lambda>(v, l).\n                         { (v, b') := \\<aA> (L l) \\<beta>' ve}.)\n                     ls\n                              in x\\<cdot>\n                                 (Discr (Inr (c', \\<beta>', ve', b')))) =\n                         \\<Union>\n                          (Rep_cfun x `\n                           (case b of\n                            (App lab f vs, \\<beta>, ve, b) \\<Rightarrow>\n                              let fs = \\<aA> f \\<beta> ve;\n                                  as = map (\\<lambda>v. \\<aA> v \\<beta> ve)\n  vs;\n                                  b' = \\<anb> b lab\n                              in \\<Union>f'\\<in>fs.\n                                    {Discr (Inl (f', as, ve, b'))}\n                            | (call.Let lab ls c', \\<beta>, ve,\n                               b) \\<Rightarrow>\n                                let b' = \\<anb> b lab;\n                                    \\<beta>' = \\<beta>(lab \\<mapsto> b');\n                                    ve' =\nve \\<union>. \\<Union>.map (\\<lambda>(v, l).\n                              { (v, b') := \\<aA> (L l) \\<beta>' ve}.)\n                       ls\n                                in {Discr\n                                     (Inr\n (c', \\<beta>', ve', b'))})) \\<union>\n                         (case b of\n                          (App lab f vs, \\<beta>, ve, b) \\<Rightarrow>\n                            let fs = \\<aA> f \\<beta> ve;\n                                as = map (\\<lambda>v. \\<aA> v \\<beta> ve)\nvs;\n                                b' = \\<anb> b lab\n                            in {((lab, \\<beta>), f') |f'. f' \\<in> fs}\n                          | (call.Let lab ls c', \\<beta>, ve,\n                             b) \\<Rightarrow>\n                              {})", "apply (case_tac aa)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xa a b aa ba c d x11 x12 x13.\n       \\<lbrakk>xa = Discr (Inr b); a = Inr b; b = (aa, ba, c, d);\n        aa = App x11 x12 x13\\<rbrakk>\n       \\<Longrightarrow> (case b of\n                          (App lab f vs, \\<beta>, ve, b) \\<Rightarrow>\n                            let fs = \\<aA> f \\<beta> ve;\n                                as = map (\\<lambda>v. \\<aA> v \\<beta> ve)\nvs;\n                                b' = \\<anb> b lab\n                            in (\\<Union>f'\\<in>fs.\n                                   x\\<cdot>\n                                   (Discr (Inl (f', as, ve, b')))) \\<union>\n                               {((lab, \\<beta>), f') |f'. f' \\<in> fs}\n                          | (call.Let lab ls c', \\<beta>, ve,\n                             b) \\<Rightarrow>\n                              let b' = \\<anb> b lab;\n                                  \\<beta>' = \\<beta>(lab \\<mapsto> b');\n                                  ve' =\n                                    ve \\<union>. \\<Union>.map\n                     (\\<lambda>(v, l).\n                         { (v, b') := \\<aA> (L l) \\<beta>' ve}.)\n                     ls\n                              in x\\<cdot>\n                                 (Discr (Inr (c', \\<beta>', ve', b')))) =\n                         \\<Union>\n                          (Rep_cfun x `\n                           (case b of\n                            (App lab f vs, \\<beta>, ve, b) \\<Rightarrow>\n                              let fs = \\<aA> f \\<beta> ve;\n                                  as = map (\\<lambda>v. \\<aA> v \\<beta> ve)\n  vs;\n                                  b' = \\<anb> b lab\n                              in \\<Union>f'\\<in>fs.\n                                    {Discr (Inl (f', as, ve, b'))}\n                            | (call.Let lab ls c', \\<beta>, ve,\n                               b) \\<Rightarrow>\n                                let b' = \\<anb> b lab;\n                                    \\<beta>' = \\<beta>(lab \\<mapsto> b');\n                                    ve' =\nve \\<union>. \\<Union>.map (\\<lambda>(v, l).\n                              { (v, b') := \\<aA> (L l) \\<beta>' ve}.)\n                       ls\n                                in {Discr\n                                     (Inr\n (c', \\<beta>', ve', b'))})) \\<union>\n                         (case b of\n                          (App lab f vs, \\<beta>, ve, b) \\<Rightarrow>\n                            let fs = \\<aA> f \\<beta> ve;\n                                as = map (\\<lambda>v. \\<aA> v \\<beta> ve)\nvs;\n                                b' = \\<anb> b lab\n                            in {((lab, \\<beta>), f') |f'. f' \\<in> fs}\n                          | (call.Let lab ls c', \\<beta>, ve,\n                             b) \\<Rightarrow>\n                              {})\n 2. \\<And>x xa a b aa ba c d x21 x22 x23.\n       \\<lbrakk>xa = Discr (Inr b); a = Inr b; b = (aa, ba, c, d);\n        aa = call.Let x21 x22 x23\\<rbrakk>\n       \\<Longrightarrow> (case b of\n                          (App lab f vs, \\<beta>, ve, b) \\<Rightarrow>\n                            let fs = \\<aA> f \\<beta> ve;\n                                as = map (\\<lambda>v. \\<aA> v \\<beta> ve)\nvs;\n                                b' = \\<anb> b lab\n                            in (\\<Union>f'\\<in>fs.\n                                   x\\<cdot>\n                                   (Discr (Inl (f', as, ve, b')))) \\<union>\n                               {((lab, \\<beta>), f') |f'. f' \\<in> fs}\n                          | (call.Let lab ls c', \\<beta>, ve,\n                             b) \\<Rightarrow>\n                              let b' = \\<anb> b lab;\n                                  \\<beta>' = \\<beta>(lab \\<mapsto> b');\n                                  ve' =\n                                    ve \\<union>. \\<Union>.map\n                     (\\<lambda>(v, l).\n                         { (v, b') := \\<aA> (L l) \\<beta>' ve}.)\n                     ls\n                              in x\\<cdot>\n                                 (Discr (Inr (c', \\<beta>', ve', b')))) =\n                         \\<Union>\n                          (Rep_cfun x `\n                           (case b of\n                            (App lab f vs, \\<beta>, ve, b) \\<Rightarrow>\n                              let fs = \\<aA> f \\<beta> ve;\n                                  as = map (\\<lambda>v. \\<aA> v \\<beta> ve)\n  vs;\n                                  b' = \\<anb> b lab\n                              in \\<Union>f'\\<in>fs.\n                                    {Discr (Inl (f', as, ve, b'))}\n                            | (call.Let lab ls c', \\<beta>, ve,\n                               b) \\<Rightarrow>\n                                let b' = \\<anb> b lab;\n                                    \\<beta>' = \\<beta>(lab \\<mapsto> b');\n                                    ve' =\nve \\<union>. \\<Union>.map (\\<lambda>(v, l).\n                              { (v, b') := \\<aA> (L l) \\<beta>' ve}.)\n                       ls\n                                in {Discr\n                                     (Inr\n (c', \\<beta>', ve', b'))})) \\<union>\n                         (case b of\n                          (App lab f vs, \\<beta>, ve, b) \\<Rightarrow>\n                            let fs = \\<aA> f \\<beta> ve;\n                                as = map (\\<lambda>v. \\<aA> v \\<beta> ve)\nvs;\n                                b' = \\<anb> b lab\n                            in {((lab, \\<beta>), f') |f'. f' \\<in> fs}\n                          | (call.Let lab ls c', \\<beta>, ve,\n                             b) \\<Rightarrow>\n                              {})", "apply (simp_all add:HOL.Let_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \\<open>The iterative equation\\<close>"], ["", "text \\<open>\nBecause of the special form of \\<open>\\<aF>\\<close> (and thus \\<open>\\<aPR>\\<close>) derived in the previous lemma, we can apply our generic results from @{theory \"Shivers-CFA.Computability\"} and express the abstract semantics as the image of a finite set under a computable function.\n\\<close>"], ["", "lemma a_evalF_iterative:\n  \"\\<aF>\\<cdot>(Discr x) = \\<^ps>abs_g\\<cdot>(\\<Union>i. iterate i\\<cdot>(\\<^ps>abs_R)\\<cdot>{Discr (Inl x)})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<aF>\\<cdot>(Discr x) =\n    \\<^ps> abs_g\\<cdot>\n    (\\<Union>i. (\\<^ps> abs_R)\\<^bsup>i\\<^esup>\\<cdot>{Discr (Inl x)})", "by (simp del:abs_R.simps abs_g.simps add: theorem12 Un_commute a_evalF_decomp)"], ["", "lemma a_evalCPS_interative:\n\"\\<aPR> prog = \\<^ps>abs_g\\<cdot>(\\<Union>i. iterate i\\<cdot>(\\<^ps>abs_R)\\<cdot>{initial_r prog})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<aPR> prog =\n    \\<^ps> abs_g\\<cdot>\n    (\\<Union>i. (\\<^ps> abs_R)\\<^bsup>i\\<^esup>\\<cdot>{initial_r prog})", "unfolding evalCPS_a_def and initial_r_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (let ve = {}.; \\<beta> = Map.empty; f = \\<aA> (L prog) \\<beta> ve\n     in \\<aF>\\<cdot>(Discr (the_elem f, [{AStop}], ve, \\<abinit>))) =\n    \\<^ps> abs_g\\<cdot>\n    (\\<Union>i.\n        (\\<^ps> abs_R)\\<^bsup>i\\<^esup>\\<cdot>\n        {Discr\n          (Inl (the_elem (\\<aA> (L prog) Map.empty {}.), [{AStop}], {}.,\n                \\<abinit>))})", "by(subst a_evalF_iterative, simp del:abs_R.simps abs_g.simps evalV_a.simps)"], ["", "end"]]}