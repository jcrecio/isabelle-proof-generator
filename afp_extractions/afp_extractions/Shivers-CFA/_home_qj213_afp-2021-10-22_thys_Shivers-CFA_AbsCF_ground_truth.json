{"file_name": "/home/qj213/afp-2021-10-22/thys/Shivers-CFA/AbsCF.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Shivers-CFA", "problem_names": ["lemma cont2cont_case_lambda [simp, cont2cont]:\n  assumes \"\\<And>a b c. cont (\\<lambda>x. f x a b c)\"\n  shows \"cont (\\<lambda>x. case_lambda (f x) l)\"", "lemma cont2cont_case_proc [simp, cont2cont]:\n  assumes \"\\<And>y. cont (\\<lambda>x. f1 x y)\"\n     and  \"\\<And>y. cont (\\<lambda>x. f2 x y)\"\n     and  \"cont (\\<lambda>x. f3 x)\"\n  shows \"cont (\\<lambda>x. case_proc (f1 x) (f2 x) (f3 x) d)\"", "lemma cont2cont_case_call [simp, cont2cont]:\n  assumes \"\\<And>a b c. cont (\\<lambda>x. f1 x a b c)\"\n     and  \"\\<And>a b c. cont (\\<lambda>x. f2 x a b c)\"\n  shows \"cont (\\<lambda>x. case_call (f1 x) (f2 x) c)\"", "lemma cont2cont_case_prim [simp, cont2cont]:\n  assumes \"\\<And>y. cont (\\<lambda>x. f1 x y)\"\n     and  \"\\<And>y z. cont (\\<lambda>x. f2 x y z)\"\n  shows \"cont (\\<lambda>x. case_prim (f1 x) (f2 x) p)\"", "lemmas a_evalF_evalC_induct = a_evalF_a_evalC.induct[case_names Admissibility Bottom Next]", "lemmas a_fstate_case_x = a_evalF_cases.cases[\n  OF case_split, of _ \"\\<lambda>_ vs _ _ as _ _ . length vs = length as\",\n  case_names \"Closure\" \"Closure_inv\" \"Plus\" \"If\" \"Stop\"]", "lemmas a_cl_cases = prod.exhaust[OF lambda.exhaust, of _ \"\\<lambda> a _ . a\"]", "lemmas a_ds_cases = list.exhaust[\n  OF _ list.exhaust,  of _ _ \"\\<lambda>_ x. x\",\n  OF _ _ list.exhaust  ,of _ _ \"\\<lambda>_ _ _ x. x\" , \n  OF _ _ _ list.exhaust,of _ _ \"\\<lambda>_ _ _ _ _ x. x\"\n  ]", "lemmas a_ds_cases_stop = list.exhaust[OF _ list.exhaust, of _ _ \"\\<lambda>_ x. x\"]", "lemmas a_fstate_case = prod_cases4[OF proc.exhaust, of _ \"\\<lambda>x _ _ _ . x\",\n  OF a_cl_cases prim.exhaust, of _ \"\\<lambda> _ _ _ _ a . a\" _ \"\\<lambda> _ _ _ _ a. a\",\n  OF case_split a_ds_cases a_ds_cases a_ds_cases_stop,\n  of _ \"\\<lambda>_ as _ _ _ _ _ _ vs _ . length vs = length as\" _ \"\\<lambda> _ ds _ _ _ _ . ds\" \"\\<lambda> _ ds _ _ _ _ _. ds\" \"\\<lambda> _ ds _ _. ds\"]"], "translations": [["", "lemma cont2cont_case_lambda [simp, cont2cont]:\n  assumes \"\\<And>a b c. cont (\\<lambda>x. f x a b c)\"\n  shows \"cont (\\<lambda>x. case_lambda (f x) l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cont (\\<lambda>x. case l of Lambda xa xb xc \\<Rightarrow> f x xa xb xc)", "using assms"], ["proof (prove)\nusing this:\n  cont (\\<lambda>x. f x ?a ?b ?c)\n\ngoal (1 subgoal):\n 1. cont (\\<lambda>x. case l of Lambda xa xb xc \\<Rightarrow> f x xa xb xc)", "by (cases l) auto"], ["", "lemma cont2cont_case_proc [simp, cont2cont]:\n  assumes \"\\<And>y. cont (\\<lambda>x. f1 x y)\"\n     and  \"\\<And>y. cont (\\<lambda>x. f2 x y)\"\n     and  \"cont (\\<lambda>x. f3 x)\"\n  shows \"cont (\\<lambda>x. case_proc (f1 x) (f2 x) (f3 x) d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cont\n     (\\<lambda>x.\n         case d of PC xa \\<Rightarrow> f1 x xa | PP xa \\<Rightarrow> f2 x xa\n         | AStop \\<Rightarrow> f3 x)", "using assms"], ["proof (prove)\nusing this:\n  cont (\\<lambda>x. f1 x ?y)\n  cont (\\<lambda>x. f2 x ?y)\n  cont f3\n\ngoal (1 subgoal):\n 1. cont\n     (\\<lambda>x.\n         case d of PC xa \\<Rightarrow> f1 x xa | PP xa \\<Rightarrow> f2 x xa\n         | AStop \\<Rightarrow> f3 x)", "by (cases d) auto"], ["", "lemma cont2cont_case_call [simp, cont2cont]:\n  assumes \"\\<And>a b c. cont (\\<lambda>x. f1 x a b c)\"\n     and  \"\\<And>a b c. cont (\\<lambda>x. f2 x a b c)\"\n  shows \"cont (\\<lambda>x. case_call (f1 x) (f2 x) c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cont\n     (\\<lambda>x.\n         case c of App xa xb xc \\<Rightarrow> f1 x xa xb xc\n         | call.Let xa xb xc \\<Rightarrow> f2 x xa xb xc)", "using assms"], ["proof (prove)\nusing this:\n  cont (\\<lambda>x. f1 x ?a ?b ?c)\n  cont (\\<lambda>x. f2 x ?a ?b ?c)\n\ngoal (1 subgoal):\n 1. cont\n     (\\<lambda>x.\n         case c of App xa xb xc \\<Rightarrow> f1 x xa xb xc\n         | call.Let xa xb xc \\<Rightarrow> f2 x xa xb xc)", "by (cases c) auto"], ["", "lemma cont2cont_case_prim [simp, cont2cont]:\n  assumes \"\\<And>y. cont (\\<lambda>x. f1 x y)\"\n     and  \"\\<And>y z. cont (\\<lambda>x. f2 x y z)\"\n  shows \"cont (\\<lambda>x. case_prim (f1 x) (f2 x) p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cont\n     (\\<lambda>x.\n         case p of Plus xa \\<Rightarrow> f1 x xa\n         | prim.If xa xb \\<Rightarrow> f2 x xa xb)", "using assms"], ["proof (prove)\nusing this:\n  cont (\\<lambda>x. f1 x ?y)\n  cont (\\<lambda>x. f2 x ?y ?z)\n\ngoal (1 subgoal):\n 1. cont\n     (\\<lambda>x.\n         case p of Plus xa \\<Rightarrow> f1 x xa\n         | prim.If xa xb \\<Rightarrow> f2 x xa xb)", "by (cases p) auto"], ["", "text \\<open>\nWe can now define the abstract nonstandard semantics, based on the equations in Figure 4.5 and 4.6 of Shivers' dissertation. In the \\<open>AStop\\<close> case, \\<open>{}\\<close> is returned, while for wrong arguments, \\<open>\\<bottom>\\<close> is returned. Both actually represent the same value, the empty set, so this is just a aesthetic difference.\n\\<close>"], ["", "fixrec   a_evalF :: \"'c::contour \\<afstate> discr \\<rightarrow> 'c \\<aans>\" (\"\\<aF>\")\n     and a_evalC :: \"'c::contour \\<acstate> discr \\<rightarrow> 'c \\<aans>\" (\"\\<aC>\")\n  where \"\\<aF>\\<cdot>fstate = (case undiscr fstate of\n             (PC (Lambda lab vs c, \\<beta>), as, ve, b) \\<Rightarrow>\n               (if length vs = length as\n                then let \\<beta>' = \\<beta> (lab \\<mapsto> b);\n                         ve' = ve \\<union>. (\\<Union>. (map (\\<lambda>(v,a). {(v,b) := a}.) (zip vs as)))\n                     in \\<aC>\\<cdot>(Discr (c,\\<beta>',ve',b))\n                else \\<bottom>)\n            | (PP (Plus c),[_,_,cnts],ve,b) \\<Rightarrow>\n                     let b' = \\<anb> b c;\n                         \\<beta>  = [c \\<mapsto> b]\n                     in (\\<Union>cnt\\<in>cnts. \\<aF>\\<cdot>(Discr (cnt,[{}],ve,b')))\n                        \\<union>\n                        {((c, \\<beta>), cont) | cont . cont \\<in> cnts}\n            | (PP (prim.If ct cf),[_, cntts, cntfs],ve,b) \\<Rightarrow>\n                  ((   let b' = \\<anb> b ct;\n                            \\<beta> = [ct \\<mapsto> b]\n                        in (\\<Union>cnt\\<in>cntts . \\<aF>\\<cdot>(Discr (cnt,[],ve,b')))\n                           \\<union>{((ct, \\<beta>), cnt) | cnt . cnt \\<in> cntts}\n                   )\\<union>(\n                       let b' = \\<anb> b cf;\n                            \\<beta> = [cf \\<mapsto> b]\n                        in (\\<Union>cnt\\<in>cntfs . \\<aF>\\<cdot>(Discr (cnt,[],ve,b')))\n                           \\<union>{((cf, \\<beta>), cnt) | cnt . cnt \\<in> cntfs}\n                   ))\n            | (AStop,[_],_,_) \\<Rightarrow> {}\n            | _ \\<Rightarrow> \\<bottom>\n        )\"\n      | \"\\<aC>\\<cdot>cstate = (case undiscr cstate of\n             (App lab f vs,\\<beta>,ve,b) \\<Rightarrow>\n                 let fs = \\<aA> f \\<beta> ve;\n                     as = map (\\<lambda>v. \\<aA> v \\<beta> ve) vs;\n                     b' = \\<anb> b lab\n                  in (\\<Union>f' \\<in> fs. \\<aF>\\<cdot>(Discr (f',as,ve,b')))\n                     \\<union>{((lab, \\<beta>),f') | f' . f'\\<in> fs}\n            | (Let lab ls c',\\<beta>,ve,b) \\<Rightarrow>\n                 let b' = \\<anb> b lab;\n                     \\<beta>' = \\<beta> (lab \\<mapsto> b');\n                     ve' = ve \\<union>. (\\<Union>. (map (\\<lambda>(v,l). {(v,b') := (\\<aA> (L l) \\<beta>' ve)}.) ls))\n                 in \\<aC>\\<cdot>(Discr (c',\\<beta>',ve',b'))\n        )\""], ["", "text \\<open>\nAgain, we name the cases of the induction rule and build a nicer case analysis rule for arguments of type \\<open>\\<afstate>\\<close>.\n\\<close>"], ["", "lemmas a_evalF_evalC_induct = a_evalF_a_evalC.induct[case_names Admissibility Bottom Next]"], ["", "fun a_evalF_cases\n where \"a_evalF_cases (PC (Lambda lab vs c, \\<beta>)) as ve b = undefined\"\n     | \"a_evalF_cases (PP (Plus cp)) [a1, a2, cnt] ve b = undefined\"\n     | \"a_evalF_cases (PP (prim.If cp1 cp2)) [v,cntt,cntf] ve b = undefined\"\n     | \"a_evalF_cases AStop [v] ve b = undefined\""], ["", "lemmas a_fstate_case_x = a_evalF_cases.cases[\n  OF case_split, of _ \"\\<lambda>_ vs _ _ as _ _ . length vs = length as\",\n  case_names \"Closure\" \"Closure_inv\" \"Plus\" \"If\" \"Stop\"]"], ["", "lemmas a_cl_cases = prod.exhaust[OF lambda.exhaust, of _ \"\\<lambda> a _ . a\"]"], ["", "lemmas a_ds_cases = list.exhaust[\n  OF _ list.exhaust,  of _ _ \"\\<lambda>_ x. x\",\n  OF _ _ list.exhaust  ,of _ _ \"\\<lambda>_ _ _ x. x\" , \n  OF _ _ _ list.exhaust,of _ _ \"\\<lambda>_ _ _ _ _ x. x\"\n  ]"], ["", "lemmas a_ds_cases_stop = list.exhaust[OF _ list.exhaust, of _ _ \"\\<lambda>_ x. x\"]"], ["", "lemmas a_fstate_case = prod_cases4[OF proc.exhaust, of _ \"\\<lambda>x _ _ _ . x\",\n  OF a_cl_cases prim.exhaust, of _ \"\\<lambda> _ _ _ _ a . a\" _ \"\\<lambda> _ _ _ _ a. a\",\n  OF case_split a_ds_cases a_ds_cases a_ds_cases_stop,\n  of _ \"\\<lambda>_ as _ _ _ _ _ _ vs _ . length vs = length as\" _ \"\\<lambda> _ ds _ _ _ _ . ds\" \"\\<lambda> _ ds _ _ _ _ _. ds\" \"\\<lambda> _ ds _ _. ds\"]"], ["", "text \\<open>\nNot surprisingly, the abstract semantics of a whole program is defined using \\<open>\\<aF>\\<close> with suitably initialized arguments. The function \\<open>the_elem\\<close> extracts a value from a singleton set. This works because we know that \\<open>\\<aA>\\<close> returns such a set when given a lambda expression.\n\\<close>"], ["", "definition evalCPS_a :: \"prog \\<Rightarrow> ('c::contour) \\<aans>\" (\"\\<aPR>\")\n  where \"\\<aPR> l = (let ve = {}.;\n                          \\<beta> = Map.empty;\n                          f = \\<aA> (L l) \\<beta> ve\n                      in  \\<aF>\\<cdot>(Discr (the_elem f,[{AStop}],ve,\\<abinit>)))\""], ["", "end"]]}