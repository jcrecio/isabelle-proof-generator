{"file_name": "/home/qj213/afp-2021-10-22/thys/Shivers-CFA/Eval.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Shivers-CFA", "problem_names": ["lemma cont2cont_case_lambda [simp, cont2cont]:\n  assumes \"\\<And>a b c. cont (\\<lambda>x. f x a b c)\"\n  shows \"cont (\\<lambda>x. case_lambda (f x) l)\"", "lemma cont2cont_case_d [simp, cont2cont]:\n  assumes \"\\<And>y. cont (\\<lambda>x. f1 x y)\"\n     and  \"\\<And>y. cont (\\<lambda>x. f2 x y)\"\n     and  \"\\<And>y. cont (\\<lambda>x. f3 x y)\"\n    and   \"cont (\\<lambda>x. f4 x)\"\n  shows \"cont (\\<lambda>x. case_d (f1 x) (f2 x) (f3 x) (f4 x) d)\"", "lemma cont2cont_case_call [simp, cont2cont]:\n  assumes \"\\<And>a b c. cont (\\<lambda>x. f1 x a b c)\"\n     and  \"\\<And>a b c. cont (\\<lambda>x. f2 x a b c)\"\n  shows \"cont (\\<lambda>x. case_call (f1 x) (f2 x) c)\"", "lemma cont2cont_case_prim [simp, cont2cont]:\n  assumes \"\\<And>y. cont (\\<lambda>x. f1 x y)\"\n     and  \"\\<And>y z. cont (\\<lambda>x. f2 x y z)\"\n  shows \"cont (\\<lambda>x. case_prim (f1 x) (f2 x) p)\"", "lemma correct_ex1: \"\\<PR> ex1 = Def 0\"", "lemma correct_ex2: \"\\<PR> ex2 = Def 2\""], "translations": [["", "lemma cont2cont_case_lambda [simp, cont2cont]:\n  assumes \"\\<And>a b c. cont (\\<lambda>x. f x a b c)\"\n  shows \"cont (\\<lambda>x. case_lambda (f x) l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cont (\\<lambda>x. case l of Lambda xa xb xc \\<Rightarrow> f x xa xb xc)", "using assms"], ["proof (prove)\nusing this:\n  cont (\\<lambda>x. f x ?a ?b ?c)\n\ngoal (1 subgoal):\n 1. cont (\\<lambda>x. case l of Lambda xa xb xc \\<Rightarrow> f x xa xb xc)", "by (cases l) auto"], ["", "lemma cont2cont_case_d [simp, cont2cont]:\n  assumes \"\\<And>y. cont (\\<lambda>x. f1 x y)\"\n     and  \"\\<And>y. cont (\\<lambda>x. f2 x y)\"\n     and  \"\\<And>y. cont (\\<lambda>x. f3 x y)\"\n    and   \"cont (\\<lambda>x. f4 x)\"\n  shows \"cont (\\<lambda>x. case_d (f1 x) (f2 x) (f3 x) (f4 x) d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cont\n     (\\<lambda>x.\n         case d of DI xa \\<Rightarrow> f1 x xa | DC xa \\<Rightarrow> f2 x xa\n         | DP xa \\<Rightarrow> f3 x xa | Stop \\<Rightarrow> f4 x)", "using assms"], ["proof (prove)\nusing this:\n  cont (\\<lambda>x. f1 x ?y)\n  cont (\\<lambda>x. f2 x ?y)\n  cont (\\<lambda>x. f3 x ?y)\n  cont f4\n\ngoal (1 subgoal):\n 1. cont\n     (\\<lambda>x.\n         case d of DI xa \\<Rightarrow> f1 x xa | DC xa \\<Rightarrow> f2 x xa\n         | DP xa \\<Rightarrow> f3 x xa | Stop \\<Rightarrow> f4 x)", "by (cases d) auto"], ["", "lemma cont2cont_case_call [simp, cont2cont]:\n  assumes \"\\<And>a b c. cont (\\<lambda>x. f1 x a b c)\"\n     and  \"\\<And>a b c. cont (\\<lambda>x. f2 x a b c)\"\n  shows \"cont (\\<lambda>x. case_call (f1 x) (f2 x) c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cont\n     (\\<lambda>x.\n         case c of App xa xb xc \\<Rightarrow> f1 x xa xb xc\n         | call.Let xa xb xc \\<Rightarrow> f2 x xa xb xc)", "using assms"], ["proof (prove)\nusing this:\n  cont (\\<lambda>x. f1 x ?a ?b ?c)\n  cont (\\<lambda>x. f2 x ?a ?b ?c)\n\ngoal (1 subgoal):\n 1. cont\n     (\\<lambda>x.\n         case c of App xa xb xc \\<Rightarrow> f1 x xa xb xc\n         | call.Let xa xb xc \\<Rightarrow> f2 x xa xb xc)", "by (cases c) auto"], ["", "lemma cont2cont_case_prim [simp, cont2cont]:\n  assumes \"\\<And>y. cont (\\<lambda>x. f1 x y)\"\n     and  \"\\<And>y z. cont (\\<lambda>x. f2 x y z)\"\n  shows \"cont (\\<lambda>x. case_prim (f1 x) (f2 x) p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cont\n     (\\<lambda>x.\n         case p of Plus xa \\<Rightarrow> f1 x xa\n         | prim.If xa xb \\<Rightarrow> f2 x xa xb)", "using assms"], ["proof (prove)\nusing this:\n  cont (\\<lambda>x. f1 x ?y)\n  cont (\\<lambda>x. f2 x ?y ?z)\n\ngoal (1 subgoal):\n 1. cont\n     (\\<lambda>x.\n         case p of Plus xa \\<Rightarrow> f1 x xa\n         | prim.If xa xb \\<Rightarrow> f2 x xa xb)", "by (cases p) auto"], ["", "text \\<open>\nAs usual, the semantics of a functional language is given as a denotational semantics. To that end, two functions are defined here: \\<open>\\<F>\\<close> applies a procedure to a list of arguments. Here closures are unwrapped, the primitive operations are implemented and the terminal continuation \\<open>Stop\\<close> is handled. \\<open>\\<C>\\<close> evaluates a call expression, either by evaluating procedure and arguments and passing them to \\<open>\\<F>\\<close>, or by adding the bindings of a \\<open>Let\\<close> expression to the environment.\n\nNote how the contour counter is incremented before each call to \\<open>\\<F>\\<close> or when a \\<open>Let\\<close> expression is evaluated.\n\nWith mutually recursive equations, such as those given here, the existence of a function satisfying these is not obvious. Therefore, the \\<open>fixrec\\<close> command from the @{theory HOLCF} package is used. This takes a set of equations and builds a functional from that. It mechanically proofs that this functional is continuous and thus a least fixed point exists. This is then used to define \\<open>\\<F>\\<close> and \\<open>\\<C>\\<close> and proof the equations given here. To use the @{theory HOLCF} setup, the continuous function arrow \\<open>\\<rightarrow>\\<close> with application operator \\<open>\\<cdot>\\<close> is used and our types are wrapped in \\<open>discr\\<close> and \\<open>lift\\<close> to indicate which partial order is to be used.\n\\<close>"], ["", "type_synonym fstate = \"(d \\<times> d list \\<times> venv \\<times> contour)\""], ["", "type_synonym cstate = \"(call \\<times> benv \\<times> venv \\<times> contour)\""], ["", "fixrec   evalF :: \"fstate discr \\<rightarrow> ans\" (\"\\<F>\")\n     and evalC :: \"cstate discr \\<rightarrow> ans\" (\"\\<C>\")\n  where \"evalF\\<cdot>fstate = (case undiscr fstate of\n             (DC (Lambda lab vs c, \\<beta>), as, ve, b) \\<Rightarrow>\n               (if length vs = length as\n                then let \\<beta>' = \\<beta> (lab \\<mapsto> b);\n                         ve' = map_upds ve (map (\\<lambda>v.(v,b)) vs) as\n                     in \\<C>\\<cdot>(Discr (c,\\<beta>',ve',b))\n                else \\<bottom>)\n            | (DP (Plus c),[DI a1, DI a2, cnt],ve,b) \\<Rightarrow>\n                     let b' = Suc b;\n                         \\<beta>  = [c \\<mapsto> b]\n                     in \\<F>\\<cdot>(Discr (cnt,[DI (a1 + a2)],ve,b'))\n            | (DP (prim.If ct cf),[DI v, contt, contf],ve,b) \\<Rightarrow>\n                  (if v \\<noteq> 0\n                   then let b' = Suc b;\n                            \\<beta> = [ct \\<mapsto> b]\n                        in \\<F>\\<cdot>(Discr (contt,[],ve,b'))\n                   else let b' = Suc b;\n                            \\<beta> = [cf \\<mapsto> b]\n                        in \\<F>\\<cdot>(Discr (contf,[],ve,b')))\n            | (Stop,[DI i],_,_) \\<Rightarrow> Def i\n            | _ \\<Rightarrow> \\<bottom>\n        )\"\n      | \"\\<C>\\<cdot>cstate = (case undiscr cstate of\n             (App lab f vs,\\<beta>,ve,b) \\<Rightarrow>\n                 let f' = \\<A> f \\<beta> ve;\n                     as = map (\\<lambda>v. \\<A> v \\<beta> ve) vs;\n                     b' = Suc b\n                  in \\<F>\\<cdot>(Discr (f',as,ve,b'))\n            | (Let lab ls c',\\<beta>,ve,b) \\<Rightarrow>\n                 let b' = Suc b;\n                     \\<beta>' = \\<beta> (lab \\<mapsto> b');\n                    ve' = ve ++ map_of (map (\\<lambda>(v,l). ((v,b'), \\<A> (L l) \\<beta>' ve)) ls)\n                 in \\<C>\\<cdot>(Discr (c',\\<beta>',ve',b'))\n        )\""], ["", "text \\<open>\nTo evaluate a full program, it is passed to \\<open>\\<F>\\<close> with proper initializations of the other arguments. We test our semantics function against two example programs and observe that the expected value is returned. \n\\<close>"], ["", "definition evalCPS :: \"prog \\<Rightarrow> ans\" (\"\\<PR>\")\n  where \"\\<PR> l = (let ve = Map.empty;\n                          \\<beta> = Map.empty;\n                          f = \\<A> (L l) \\<beta> ve\n                      in  \\<F>\\<cdot>(Discr (f,[Stop],ve,0)))\""], ["", "lemma correct_ex1: \"\\<PR> ex1 = Def 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<PR> ex1 = Def 0", "unfolding evalCPS_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (let ve = Map.empty; \\<beta> = Map.empty; f = \\<A> (L ex1) \\<beta> ve\n     in \\<F>\\<cdot>(Discr (f, [Stop], ve, 0))) =\n    Def 0", "by simp"], ["", "lemma correct_ex2: \"\\<PR> ex2 = Def 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<PR> ex2 = Def 2", "unfolding evalCPS_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (let ve = Map.empty; \\<beta> = Map.empty; f = \\<A> (L ex2) \\<beta> ve\n     in \\<F>\\<cdot>(Discr (f, [Stop], ve, 0))) =\n    Def 2", "by simp"], ["", "(* (The third example takes long to finish, thus is it not ran by default.) \nlemma correct_ex3: \"evalCPS ex3 = Def 55\"\noops\nunfolding evalCPS_def\nby simp\n*)"], ["", "end"]]}