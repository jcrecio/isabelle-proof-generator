{"file_name": "/home/qj213/afp-2021-10-22/thys/Shivers-CFA/AbsCFCorrect.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Shivers-CFA", "problem_names": ["lemma abs_benv_empty[simp]: \"|Map.empty| = Map.empty\"", "lemma abs_benv_upd[simp]: \"|\\<beta>(c\\<mapsto>b)| = |\\<beta>| (c \\<mapsto> |b| )\"", "lemma the_elem_is_Proc:\n  assumes \"isProc cnt\"\n  shows \"the_elem |cnt| \\<in> |cnt|\"", "lemma [simp]: \"|{}| = {}\"", "lemma abs_cache_singleton [simp]: \"|{((c,\\<beta>),d)}| = {((c, |\\<beta>| ), p) |p. p \\<in> |d|}\"", "lemma abs_venv_empty[simp]: \"|Map.empty| = {}.\"", "lemma venv_approx_trans[trans]:\n  fixes ve1 ve2 ve3 :: \"'c \\<avenv>\"\n  shows \"\\<lbrakk> ve1 \\<lessapprox> ve2; ve2 \\<lessapprox> ve3 \\<rbrakk> \\<Longrightarrow> (ve1 \\<lessapprox> ve3)\"", "lemma abs_venv_union: \"|ve1 ++ ve2| \\<lessapprox> |ve1| \\<union>. |ve2|\"", "lemma abs_venv_map_of_rev: \"|map_of (rev l)| \\<lessapprox> \\<Union>. (map (\\<lambda>(v,k). |[v \\<mapsto> k]| ) l)\"", "lemma abs_venv_map_of: \"|map_of l| \\<lessapprox> \\<Union>. (map (\\<lambda>(v,k). |[v \\<mapsto> k]| ) l)\"", "lemma abs_venv_singleton: \"|[(v,b) \\<mapsto> d]| = {(v,|b| ) := |d|}.\"", "lemma ccache_approx_empty[simp]:\n  fixes x :: \"'c \\<accache>\"\n  shows \"{} \\<lessapprox> x\"", "lemmas ccache_approx_trans[trans] = subset_trans[where 'a = \"((label \\<times> 'c \\<abenv>) \\<times> 'c \\<aproc>)\", folded ccache_approx_def]", "lemmas Un_mono_approx = Un_mono[where 'a = \"((label \\<times> 'c \\<abenv>) \\<times> 'c \\<aproc>)\", folded ccache_approx_def]", "lemmas Un_upper1_approx = Un_upper1[where 'a = \"((label \\<times> 'c \\<abenv>) \\<times> 'c \\<aproc>)\", folded ccache_approx_def]", "lemmas Un_upper2_approx = Un_upper2[where 'a = \"((label \\<times> 'c \\<abenv>) \\<times> 'c \\<aproc>)\", folded ccache_approx_def]", "lemma abs_ccache_union: \"|c1 \\<union> c2| \\<lessapprox> |c1| \\<union> |c2|\"", "lemma d_approx_empty[simp]: \"{} \\<lessapprox> (d::'c \\<ad>)\"", "lemma ds_approx_empty[simp]: \"[] \\<lessapprox> []\"", "lemma lemma7:\n  assumes \"|ve::venv| \\<lessapprox> ve_a\"\n  shows \"|\\<A> f \\<beta> ve| \\<lessapprox> \\<aA> f |\\<beta>| ve_a\"", "lemma cont2cont_abs_ccache[cont2cont,simp]:\n  assumes \"cont f\"\n  shows \"cont (\\<lambda>x. abs_ccache(f x))\"", "lemma lemma89:\n fixes fstate_a :: \"'c::contour_a \\<afstate>\" and cstate_a :: \"'c::contour_a \\<acstate>\"\n shows \"|fstate| \\<lessapprox> fstate_a \\<Longrightarrow> |\\<F>\\<cdot>(Discr fstate)| \\<lessapprox> \\<aF>\\<cdot>(Discr fstate_a)\"\n   and \"|cstate| \\<lessapprox> cstate_a \\<Longrightarrow> |\\<C>\\<cdot>(Discr cstate)| \\<lessapprox> \\<aC>\\<cdot>(Discr cstate_a)\"", "lemma lemma6: \"|\\<PR> l| \\<lessapprox> \\<aPR> l\""], "translations": [["", "lemma abs_benv_empty[simp]: \"|Map.empty| = Map.empty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. |Map.empty| = Map.empty", "unfolding abs_benv_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_option AbsCFCorrect.abs \\<circ> Map.empty = Map.empty", "by simp"], ["", "lemma abs_benv_upd[simp]: \"|\\<beta>(c\\<mapsto>b)| = |\\<beta>| (c \\<mapsto> |b| )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. |\\<beta>(c \\<mapsto> b)| = |\\<beta>|(c \\<mapsto> |b|)", "unfolding abs_benv_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_option AbsCFCorrect.abs \\<circ> \\<beta>(c \\<mapsto> b) =\n    (map_option AbsCFCorrect.abs \\<circ> \\<beta>)(c \\<mapsto> |b|)", "by simp"], ["", "lemma the_elem_is_Proc:\n  assumes \"isProc cnt\"\n  shows \"the_elem |cnt| \\<in> |cnt|\""], ["proof (prove)\ngoal (1 subgoal):\n 1. the_elem |cnt| \\<in> |cnt|", "using assms"], ["proof (prove)\nusing this:\n  isProc cnt\n\ngoal (1 subgoal):\n 1. the_elem |cnt| \\<in> |cnt|", "by (cases cnt)auto"], ["", "lemma [simp]: \"|{}| = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. |{}| = {}", "unfolding abs_ccache_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>((c, \\<beta>), d)\\<in>{}.\n        {((c, |\\<beta>|), p) |p. p \\<in> |d|}) =\n    {}", "by auto"], ["", "lemma abs_cache_singleton [simp]: \"|{((c,\\<beta>),d)}| = {((c, |\\<beta>| ), p) |p. p \\<in> |d|}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. |{((c, \\<beta>), d)}| = {((c, |\\<beta>|), p) |p. p \\<in> |d|}", "unfolding abs_ccache_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>((c, \\<beta>), d)\\<in>{((c, \\<beta>), d)}.\n        {((c, |\\<beta>|), p) |p. p \\<in> |d|}) =\n    {((c, |\\<beta>|), p) |p. p \\<in> |d|}", "by simp"], ["", "lemma abs_venv_empty[simp]: \"|Map.empty| = {}.\""], ["proof (prove)\ngoal (1 subgoal):\n 1. |Map.empty| = {}.", "apply (rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. |Map.empty| x = {}. x", "by (auto simp add: abs_venv_def smap_empty_def)"], ["", "subsection \\<open>Approximation relation\\<close>"], ["", "text \\<open>\nThe family of relations defined here capture the notion of safe approximation.\n\\<close>"], ["", "consts approx :: \"'a \\<Rightarrow> 'a \\<Rightarrow> bool\" (\"_ \\<lessapprox> _\")"], ["", "definition venv_approx :: \"'c \\<avenv> \\<Rightarrow>'c \\<avenv> \\<Rightarrow> bool\"\n  where \"venv_approx = smap_less\""], ["", "adhoc_overloading\n  approx venv_approx"], ["", "definition ccache_approx :: \"'c \\<accache> \\<Rightarrow>'c \\<accache> \\<Rightarrow> bool\"\n  where \"ccache_approx = less_eq\""], ["", "adhoc_overloading\n  approx ccache_approx"], ["", "definition d_approx :: \"'c \\<ad> \\<Rightarrow>'c \\<ad> \\<Rightarrow> bool\"\n  where \"d_approx = less_eq\""], ["", "adhoc_overloading\n  approx d_approx"], ["", "definition ds_approx :: \"'c \\<ad> list \\<Rightarrow>'c \\<ad> list \\<Rightarrow> bool\"\n  where \"ds_approx = list_all2 d_approx\""], ["", "adhoc_overloading\n  approx ds_approx"], ["", "inductive fstate_approx :: \"'c \\<afstate> \\<Rightarrow>'c \\<afstate> \\<Rightarrow> bool\"\n  where \"\\<lbrakk> ve \\<lessapprox> ve' ; ds \\<lessapprox> ds' \\<rbrakk>\n         \\<Longrightarrow> fstate_approx (proc,ds,ve,b) (proc,ds',ve',b)\""], ["", "adhoc_overloading\n  approx fstate_approx"], ["", "inductive cstate_approx :: \"'c \\<acstate> \\<Rightarrow>'c \\<acstate> \\<Rightarrow> bool\"\n  where \"\\<lbrakk> ve \\<lessapprox> ve' \\<rbrakk> \\<Longrightarrow> cstate_approx (c,\\<beta>,ve,b) (c,\\<beta>,ve',b)\""], ["", "adhoc_overloading\n  approx cstate_approx"], ["", "subsection \\<open>Lemmas about the approximation relation\\<close>"], ["", "text \\<open>\nMost of the following lemmas reduce an approximation statement about larger structures, as they are occurring the semantics functions, to statements about the components.\n\\<close>"], ["", "lemma venv_approx_trans[trans]:\n  fixes ve1 ve2 ve3 :: \"'c \\<avenv>\"\n  shows \"\\<lbrakk> ve1 \\<lessapprox> ve2; ve2 \\<lessapprox> ve3 \\<rbrakk> \\<Longrightarrow> (ve1 \\<lessapprox> ve3)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ve1 \\<lessapprox> ve2; ve2 \\<lessapprox> ve3\\<rbrakk>\n    \\<Longrightarrow> ve1 \\<lessapprox> ve3", "unfolding venv_approx_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ve1 \\<subseteq>. ve2; ve2 \\<subseteq>. ve3\\<rbrakk>\n    \\<Longrightarrow> ve1 \\<subseteq>. ve3", "by (rule smap_less_trans)"], ["", "lemma abs_venv_union: \"|ve1 ++ ve2| \\<lessapprox> |ve1| \\<union>. |ve2|\""], ["proof (prove)\ngoal (1 subgoal):\n 1. |ve1 ++ ve2| \\<lessapprox> |ve1| \\<union>. |ve2|", "by (auto simp add: venv_approx_def smap_less_def abs_venv_def smap_union_def, split option.split_asm, auto)"], ["", "lemma abs_venv_map_of_rev: \"|map_of (rev l)| \\<lessapprox> \\<Union>. (map (\\<lambda>(v,k). |[v \\<mapsto> k]| ) l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. |map_of\n      (rev l)| \\<lessapprox> \\<Union>.map\n (\\<lambda>(v, k). |[v \\<mapsto> k]|) l", "proof (induct l)"], ["proof (state)\ngoal (2 subgoals):\n 1. |map_of\n      (rev [])| \\<lessapprox> \\<Union>.map\n  (\\<lambda>a. case a of (v, k) \\<Rightarrow> |[v \\<mapsto> k]|) []\n 2. \\<And>a l.\n       |map_of\n         (rev l)| \\<lessapprox> \\<Union>.map\n    (\\<lambda>a. case a of (v, k) \\<Rightarrow> |[v \\<mapsto> k]|)\n    l \\<Longrightarrow>\n       |map_of\n         (rev (a #\n               l))| \\<lessapprox> \\<Union>.map\n      (\\<lambda>a. case a of (v, k) \\<Rightarrow> |[v \\<mapsto> k]|) (a # l)", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. |map_of\n      (rev [])| \\<lessapprox> \\<Union>.map\n  (\\<lambda>a. case a of (v, k) \\<Rightarrow> |[v \\<mapsto> k]|) []\n 2. \\<And>a l.\n       |map_of\n         (rev l)| \\<lessapprox> \\<Union>.map\n    (\\<lambda>a. case a of (v, k) \\<Rightarrow> |[v \\<mapsto> k]|)\n    l \\<Longrightarrow>\n       |map_of\n         (rev (a #\n               l))| \\<lessapprox> \\<Union>.map\n      (\\<lambda>a. case a of (v, k) \\<Rightarrow> |[v \\<mapsto> k]|) (a # l)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. |map_of\n      (rev [])| \\<lessapprox> \\<Union>.map\n  (\\<lambda>a. case a of (v, k) \\<Rightarrow> |[v \\<mapsto> k]|) []", "unfolding abs_venv_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lambda>a.\n       case a of\n       (v, b_a) \\<Rightarrow>\n         \\<Union>\n          {case map_of (rev []) (v, b) of None \\<Rightarrow> {}\n           | Some x \\<Rightarrow> |x| |\n           b. |b| =\n              b_a} \\<lessapprox> \\<Union>.map\n     (\\<lambda>a.\n         case a of\n         (v, k) \\<Rightarrow>\n           \\<lambda>a.\n              case a of\n              (va, b_a) \\<Rightarrow>\n                \\<Union>\n                 {case [v \\<mapsto> k] (va, b) of None \\<Rightarrow> {}\n                  | Some x \\<Rightarrow> |x| |\n                  b. |b| = b_a})\n     []", "by (auto simp: venv_approx_def smap_less_def )"], ["proof (state)\nthis:\n  |map_of\n    (rev [])| \\<lessapprox> \\<Union>.map\n(\\<lambda>a. case a of (v, k) \\<Rightarrow> |[v \\<mapsto> k]|) []\n\ngoal (1 subgoal):\n 1. \\<And>a l.\n       |map_of\n         (rev l)| \\<lessapprox> \\<Union>.map\n    (\\<lambda>a. case a of (v, k) \\<Rightarrow> |[v \\<mapsto> k]|)\n    l \\<Longrightarrow>\n       |map_of\n         (rev (a #\n               l))| \\<lessapprox> \\<Union>.map\n      (\\<lambda>a. case a of (v, k) \\<Rightarrow> |[v \\<mapsto> k]|) (a # l)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a l.\n       |map_of\n         (rev l)| \\<lessapprox> \\<Union>.map\n    (\\<lambda>a. case a of (v, k) \\<Rightarrow> |[v \\<mapsto> k]|)\n    l \\<Longrightarrow>\n       |map_of\n         (rev (a #\n               l))| \\<lessapprox> \\<Union>.map\n      (\\<lambda>a. case a of (v, k) \\<Rightarrow> |[v \\<mapsto> k]|) (a # l)", "case (Cons a l)"], ["proof (state)\nthis:\n  |map_of\n    (rev l)| \\<lessapprox> \\<Union>.map (\\<lambda>a.\n      case a of (v, k) \\<Rightarrow> |[v \\<mapsto> k]|)\n                                     l\n\ngoal (1 subgoal):\n 1. \\<And>a l.\n       |map_of\n         (rev l)| \\<lessapprox> \\<Union>.map\n    (\\<lambda>a. case a of (v, k) \\<Rightarrow> |[v \\<mapsto> k]|)\n    l \\<Longrightarrow>\n       |map_of\n         (rev (a #\n               l))| \\<lessapprox> \\<Union>.map\n      (\\<lambda>a. case a of (v, k) \\<Rightarrow> |[v \\<mapsto> k]|) (a # l)", "obtain v k where \"a=(v,k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>v k. a = (v, k) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule prod.exhaust)"], ["proof (state)\nthis:\n  a = (v, k)\n\ngoal (1 subgoal):\n 1. \\<And>a l.\n       |map_of\n         (rev l)| \\<lessapprox> \\<Union>.map\n    (\\<lambda>a. case a of (v, k) \\<Rightarrow> |[v \\<mapsto> k]|)\n    l \\<Longrightarrow>\n       |map_of\n         (rev (a #\n               l))| \\<lessapprox> \\<Union>.map\n      (\\<lambda>a. case a of (v, k) \\<Rightarrow> |[v \\<mapsto> k]|) (a # l)", "hence \"|map_of (rev (a#l))| \\<lessapprox> ( |[v \\<mapsto> k]| \\<union>. |map_of (rev l)| ):: 'a \\<avenv>\""], ["proof (prove)\nusing this:\n  a = (v, k)\n\ngoal (1 subgoal):\n 1. |map_of\n      (rev (a #\n            l))| \\<lessapprox> |[v \\<mapsto> k]| \\<union>. |map_of (rev l)|", "by (auto intro: abs_venv_union)"], ["proof (state)\nthis:\n  |map_of\n    (rev (a #\n          l))| \\<lessapprox> |[v \\<mapsto> k]| \\<union>. |map_of (rev l)|\n\ngoal (1 subgoal):\n 1. \\<And>a l.\n       |map_of\n         (rev l)| \\<lessapprox> \\<Union>.map\n    (\\<lambda>a. case a of (v, k) \\<Rightarrow> |[v \\<mapsto> k]|)\n    l \\<Longrightarrow>\n       |map_of\n         (rev (a #\n               l))| \\<lessapprox> \\<Union>.map\n      (\\<lambda>a. case a of (v, k) \\<Rightarrow> |[v \\<mapsto> k]|) (a # l)", "also"], ["proof (state)\nthis:\n  |map_of\n    (rev (a #\n          l))| \\<lessapprox> |[v \\<mapsto> k]| \\<union>. |map_of (rev l)|\n\ngoal (1 subgoal):\n 1. \\<And>a l.\n       |map_of\n         (rev l)| \\<lessapprox> \\<Union>.map\n    (\\<lambda>a. case a of (v, k) \\<Rightarrow> |[v \\<mapsto> k]|)\n    l \\<Longrightarrow>\n       |map_of\n         (rev (a #\n               l))| \\<lessapprox> \\<Union>.map\n      (\\<lambda>a. case a of (v, k) \\<Rightarrow> |[v \\<mapsto> k]|) (a # l)", "have \"\\<dots> \\<lessapprox> |[v \\<mapsto> k]| \\<union>. (\\<Union>. (map (\\<lambda>(v,k). |[v  \\<mapsto> k]| ) l))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. |[v \\<mapsto>\n      k]| \\<union>. |map_of\n                      (rev l)| \\<lessapprox> |[v \\<mapsto>\n         k]| \\<union>. \\<Union>.map (\\<lambda>(v, k). |[v \\<mapsto> k]|) l", "by (auto intro!:smap_union_mono[OF smap_less_refl Cons[unfolded venv_approx_def]] simp:venv_approx_def)"], ["proof (state)\nthis:\n  |[v \\<mapsto>\n    k]| \\<union>. |map_of\n                    (rev l)| \\<lessapprox> |[v \\<mapsto>\n       k]| \\<union>. \\<Union>.map (\\<lambda>(v, k). |[v \\<mapsto> k]|) l\n\ngoal (1 subgoal):\n 1. \\<And>a l.\n       |map_of\n         (rev l)| \\<lessapprox> \\<Union>.map\n    (\\<lambda>a. case a of (v, k) \\<Rightarrow> |[v \\<mapsto> k]|)\n    l \\<Longrightarrow>\n       |map_of\n         (rev (a #\n               l))| \\<lessapprox> \\<Union>.map\n      (\\<lambda>a. case a of (v, k) \\<Rightarrow> |[v \\<mapsto> k]|) (a # l)", "also"], ["proof (state)\nthis:\n  |[v \\<mapsto>\n    k]| \\<union>. |map_of\n                    (rev l)| \\<lessapprox> |[v \\<mapsto>\n       k]| \\<union>. \\<Union>.map (\\<lambda>(v, k). |[v \\<mapsto> k]|) l\n\ngoal (1 subgoal):\n 1. \\<And>a l.\n       |map_of\n         (rev l)| \\<lessapprox> \\<Union>.map\n    (\\<lambda>a. case a of (v, k) \\<Rightarrow> |[v \\<mapsto> k]|)\n    l \\<Longrightarrow>\n       |map_of\n         (rev (a #\n               l))| \\<lessapprox> \\<Union>.map\n      (\\<lambda>a. case a of (v, k) \\<Rightarrow> |[v \\<mapsto> k]|) (a # l)", "have \"\\<dots> = \\<Union>. ( |[v \\<mapsto> k]| # map (\\<lambda>(v,k). |[v \\<mapsto> k]| ) l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. |[v \\<mapsto>\n      k]| \\<union>. \\<Union>.map (\\<lambda>(v, k). |[v \\<mapsto> k]|) l =\n    \\<Union>.|[v \\<mapsto> k]| # map (\\<lambda>(v, k). |[v \\<mapsto> k]|) l", "by (rule smap_Union_union)"], ["proof (state)\nthis:\n  |[v \\<mapsto>\n    k]| \\<union>. \\<Union>.map (\\<lambda>(v, k). |[v \\<mapsto> k]|) l =\n  \\<Union>.|[v \\<mapsto> k]| # map (\\<lambda>(v, k). |[v \\<mapsto> k]|) l\n\ngoal (1 subgoal):\n 1. \\<And>a l.\n       |map_of\n         (rev l)| \\<lessapprox> \\<Union>.map\n    (\\<lambda>a. case a of (v, k) \\<Rightarrow> |[v \\<mapsto> k]|)\n    l \\<Longrightarrow>\n       |map_of\n         (rev (a #\n               l))| \\<lessapprox> \\<Union>.map\n      (\\<lambda>a. case a of (v, k) \\<Rightarrow> |[v \\<mapsto> k]|) (a # l)", "also"], ["proof (state)\nthis:\n  |[v \\<mapsto>\n    k]| \\<union>. \\<Union>.map (\\<lambda>(v, k). |[v \\<mapsto> k]|) l =\n  \\<Union>.|[v \\<mapsto> k]| # map (\\<lambda>(v, k). |[v \\<mapsto> k]|) l\n\ngoal (1 subgoal):\n 1. \\<And>a l.\n       |map_of\n         (rev l)| \\<lessapprox> \\<Union>.map\n    (\\<lambda>a. case a of (v, k) \\<Rightarrow> |[v \\<mapsto> k]|)\n    l \\<Longrightarrow>\n       |map_of\n         (rev (a #\n               l))| \\<lessapprox> \\<Union>.map\n      (\\<lambda>a. case a of (v, k) \\<Rightarrow> |[v \\<mapsto> k]|) (a # l)", "have \"\\<dots> = \\<Union>. (map (\\<lambda>(v,k). |[v \\<mapsto> k]| ) (a#l))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union>.|[v \\<mapsto> k]| #\n             map (\\<lambda>(v, k). |[v \\<mapsto> k]|) l =\n    \\<Union>.map (\\<lambda>(v, k). |[v \\<mapsto> k]|) (a # l)", "using \\<open>a = (v,k)\\<close>"], ["proof (prove)\nusing this:\n  a = (v, k)\n\ngoal (1 subgoal):\n 1. \\<Union>.|[v \\<mapsto> k]| #\n             map (\\<lambda>(v, k). |[v \\<mapsto> k]|) l =\n    \\<Union>.map (\\<lambda>(v, k). |[v \\<mapsto> k]|) (a # l)", "by auto"], ["proof (state)\nthis:\n  \\<Union>.|[v \\<mapsto> k]| # map (\\<lambda>(v, k). |[v \\<mapsto> k]|) l =\n  \\<Union>.map (\\<lambda>(v, k). |[v \\<mapsto> k]|) (a # l)\n\ngoal (1 subgoal):\n 1. \\<And>a l.\n       |map_of\n         (rev l)| \\<lessapprox> \\<Union>.map\n    (\\<lambda>a. case a of (v, k) \\<Rightarrow> |[v \\<mapsto> k]|)\n    l \\<Longrightarrow>\n       |map_of\n         (rev (a #\n               l))| \\<lessapprox> \\<Union>.map\n      (\\<lambda>a. case a of (v, k) \\<Rightarrow> |[v \\<mapsto> k]|) (a # l)", "finally"], ["proof (chain)\npicking this:\n  |map_of\n    (rev (a #\n          l))| \\<lessapprox> \\<Union>.map\n (\\<lambda>(v, k). |[v \\<mapsto> k]|) (a # l)", "show ?case"], ["proof (prove)\nusing this:\n  |map_of\n    (rev (a #\n          l))| \\<lessapprox> \\<Union>.map\n (\\<lambda>(v, k). |[v \\<mapsto> k]|) (a # l)\n\ngoal (1 subgoal):\n 1. |map_of\n      (rev (a #\n            l))| \\<lessapprox> \\<Union>.map\n   (\\<lambda>a. case a of (v, k) \\<Rightarrow> |[v \\<mapsto> k]|) (a # l)", "."], ["proof (state)\nthis:\n  |map_of\n    (rev (a #\n          l))| \\<lessapprox> \\<Union>.map\n (\\<lambda>a. case a of (v, k) \\<Rightarrow> |[v \\<mapsto> k]|) (a # l)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma abs_venv_map_of: \"|map_of l| \\<lessapprox> \\<Union>. (map (\\<lambda>(v,k). |[v \\<mapsto> k]| ) l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. |map_of\n      l| \\<lessapprox> \\<Union>.map (\\<lambda>(v, k). |[v \\<mapsto> k]|) l", "using abs_venv_map_of_rev[of \"rev l\"]"], ["proof (prove)\nusing this:\n  |map_of\n    (rev (rev l))| \\<lessapprox> \\<Union>.map\n     (\\<lambda>(v, k). |[v \\<mapsto> k]|) (rev l)\n\ngoal (1 subgoal):\n 1. |map_of\n      l| \\<lessapprox> \\<Union>.map (\\<lambda>(v, k). |[v \\<mapsto> k]|) l", "by simp"], ["", "lemma abs_venv_singleton: \"|[(v,b) \\<mapsto> d]| = {(v,|b| ) := |d|}.\""], ["proof (prove)\ngoal (1 subgoal):\n 1. |[(v, b) \\<mapsto> d]| = { (v, |b|) := |d|}.", "by (rule ext, auto simp add:abs_venv_def smap_singleton_def smap_empty_def)"], ["", "lemma ccache_approx_empty[simp]:\n  fixes x :: \"'c \\<accache>\"\n  shows \"{} \\<lessapprox> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {} \\<lessapprox> x", "unfolding ccache_approx_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {} \\<subseteq> x", "by simp"], ["", "lemmas ccache_approx_trans[trans] = subset_trans[where 'a = \"((label \\<times> 'c \\<abenv>) \\<times> 'c \\<aproc>)\", folded ccache_approx_def]"], ["", "lemmas Un_mono_approx = Un_mono[where 'a = \"((label \\<times> 'c \\<abenv>) \\<times> 'c \\<aproc>)\", folded ccache_approx_def]"], ["", "lemmas Un_upper1_approx = Un_upper1[where 'a = \"((label \\<times> 'c \\<abenv>) \\<times> 'c \\<aproc>)\", folded ccache_approx_def]"], ["", "lemmas Un_upper2_approx = Un_upper2[where 'a = \"((label \\<times> 'c \\<abenv>) \\<times> 'c \\<aproc>)\", folded ccache_approx_def]"], ["", "lemma abs_ccache_union: \"|c1 \\<union> c2| \\<lessapprox> |c1| \\<union> |c2|\""], ["proof (prove)\ngoal (1 subgoal):\n 1. |c1 \\<union> c2| \\<lessapprox> |c1| \\<union> |c2|", "unfolding ccache_approx_def abs_ccache_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>((c, \\<beta>), d)\\<in>c1 \\<union> c2.\n        {((c, |\\<beta>|), p) |p. p \\<in> |d|})\n    \\<subseteq> (\\<Union>((c, \\<beta>), d)\\<in>c1.\n                    {((c, |\\<beta>|), p) |p. p \\<in> |d|}) \\<union>\n                (\\<Union>((c, \\<beta>), d)\\<in>c2.\n                    {((c, |\\<beta>|), p) |p. p \\<in> |d|})", "by auto"], ["", "lemma d_approx_empty[simp]: \"{} \\<lessapprox> (d::'c \\<ad>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {} \\<lessapprox> d", "unfolding d_approx_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {} \\<subseteq> d", "by simp"], ["", "lemma ds_approx_empty[simp]: \"[] \\<lessapprox> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [] \\<lessapprox> []", "unfolding ds_approx_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all2 approx [] []", "by simp"], ["", "subsection \\<open>Lemma 7\\<close>"], ["", "text \\<open>\nShivers' lemma 7 says that \\<open>\\<aA>\\<close> safely approximates \\<open>\\<A>\\<close>.\n\\<close>"], ["", "lemma lemma7:\n  assumes \"|ve::venv| \\<lessapprox> ve_a\"\n  shows \"|\\<A> f \\<beta> ve| \\<lessapprox> \\<aA> f |\\<beta>| ve_a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. |\\<A> f \\<beta> ve| \\<lessapprox> \\<aA> f |\\<beta>| ve_a", "proof(cases f)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x1.\n       f = L x1 \\<Longrightarrow>\n       |\\<A> f \\<beta> ve| \\<lessapprox> \\<aA> f |\\<beta>| ve_a\n 2. \\<And>x21 x22.\n       f = R x21 x22 \\<Longrightarrow>\n       |\\<A> f \\<beta> ve| \\<lessapprox> \\<aA> f |\\<beta>| ve_a\n 3. \\<And>x31 x32.\n       f = C x31 x32 \\<Longrightarrow>\n       |\\<A> f \\<beta> ve| \\<lessapprox> \\<aA> f |\\<beta>| ve_a\n 4. \\<And>x4.\n       f = P x4 \\<Longrightarrow>\n       |\\<A> f \\<beta> ve| \\<lessapprox> \\<aA> f |\\<beta>| ve_a", "case (R _ v)"], ["proof (state)\nthis:\n  f = R x21_ v\n\ngoal (4 subgoals):\n 1. \\<And>x1.\n       f = L x1 \\<Longrightarrow>\n       |\\<A> f \\<beta> ve| \\<lessapprox> \\<aA> f |\\<beta>| ve_a\n 2. \\<And>x21 x22.\n       f = R x21 x22 \\<Longrightarrow>\n       |\\<A> f \\<beta> ve| \\<lessapprox> \\<aA> f |\\<beta>| ve_a\n 3. \\<And>x31 x32.\n       f = C x31 x32 \\<Longrightarrow>\n       |\\<A> f \\<beta> ve| \\<lessapprox> \\<aA> f |\\<beta>| ve_a\n 4. \\<And>x4.\n       f = P x4 \\<Longrightarrow>\n       |\\<A> f \\<beta> ve| \\<lessapprox> \\<aA> f |\\<beta>| ve_a", "from assms"], ["proof (chain)\npicking this:\n  |ve| \\<lessapprox> ve_a", "have assm': \"\\<And>v b. case_option {} abs_d (ve (v,b)) \\<lessapprox> ve_a (v,|b| )\""], ["proof (prove)\nusing this:\n  |ve| \\<lessapprox> ve_a\n\ngoal (1 subgoal):\n 1. \\<And>v b.\n       case ve (v, b) of None \\<Rightarrow> {}\n       | Some x \\<Rightarrow> |x| \\<lessapprox> ve_a (v, |b|)", "by (auto simp add:d_approx_def abs_venv_def venv_approx_def smap_less_def elim!:allE)"], ["proof (state)\nthis:\n  case ve (?v, ?b) of None \\<Rightarrow> {}\n  | Some x \\<Rightarrow> |x| \\<lessapprox> ve_a (?v, |?b|)\n\ngoal (4 subgoals):\n 1. \\<And>x1.\n       f = L x1 \\<Longrightarrow>\n       |\\<A> f \\<beta> ve| \\<lessapprox> \\<aA> f |\\<beta>| ve_a\n 2. \\<And>x21 x22.\n       f = R x21 x22 \\<Longrightarrow>\n       |\\<A> f \\<beta> ve| \\<lessapprox> \\<aA> f |\\<beta>| ve_a\n 3. \\<And>x31 x32.\n       f = C x31 x32 \\<Longrightarrow>\n       |\\<A> f \\<beta> ve| \\<lessapprox> \\<aA> f |\\<beta>| ve_a\n 4. \\<And>x4.\n       f = P x4 \\<Longrightarrow>\n       |\\<A> f \\<beta> ve| \\<lessapprox> \\<aA> f |\\<beta>| ve_a", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. |\\<A> f \\<beta> ve| \\<lessapprox> \\<aA> f |\\<beta>| ve_a", "proof(cases \"\\<beta> (binder v)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<beta> (binder v) = None \\<Longrightarrow>\n    |\\<A> f \\<beta> ve| \\<lessapprox> \\<aA> f |\\<beta>| ve_a\n 2. \\<And>a.\n       \\<beta> (binder v) = Some a \\<Longrightarrow>\n       |\\<A> f \\<beta> ve| \\<lessapprox> \\<aA> f |\\<beta>| ve_a", "case None"], ["proof (state)\nthis:\n  \\<beta> (binder v) = None\n\ngoal (2 subgoals):\n 1. \\<beta> (binder v) = None \\<Longrightarrow>\n    |\\<A> f \\<beta> ve| \\<lessapprox> \\<aA> f |\\<beta>| ve_a\n 2. \\<And>a.\n       \\<beta> (binder v) = Some a \\<Longrightarrow>\n       |\\<A> f \\<beta> ve| \\<lessapprox> \\<aA> f |\\<beta>| ve_a", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<beta> (binder v) = None\n\ngoal (1 subgoal):\n 1. |\\<A> f \\<beta> ve| \\<lessapprox> \\<aA> f |\\<beta>| ve_a", "using R"], ["proof (prove)\nusing this:\n  \\<beta> (binder v) = None\n  f = R x21_ v\n\ngoal (1 subgoal):\n 1. |\\<A> f \\<beta> ve| \\<lessapprox> \\<aA> f |\\<beta>| ve_a", "by auto"], ["proof (state)\nthis:\n  |\\<A> f \\<beta> ve| \\<lessapprox> \\<aA> f |\\<beta>| ve_a\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<beta> (binder v) = Some a \\<Longrightarrow>\n       |\\<A> f \\<beta> ve| \\<lessapprox> \\<aA> f |\\<beta>| ve_a", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<beta> (binder v) = Some a \\<Longrightarrow>\n       |\\<A> f \\<beta> ve| \\<lessapprox> \\<aA> f |\\<beta>| ve_a", "case (Some b)"], ["proof (state)\nthis:\n  \\<beta> (binder v) = Some b\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<beta> (binder v) = Some a \\<Longrightarrow>\n       |\\<A> f \\<beta> ve| \\<lessapprox> \\<aA> f |\\<beta>| ve_a", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<beta> (binder v) = Some b\n\ngoal (1 subgoal):\n 1. |\\<A> f \\<beta> ve| \\<lessapprox> \\<aA> f |\\<beta>| ve_a", "using R assm'[of v b]"], ["proof (prove)\nusing this:\n  \\<beta> (binder v) = Some b\n  f = R x21_ v\n  case ve (v, b) of None \\<Rightarrow> {}\n  | Some x \\<Rightarrow> |x| \\<lessapprox> ve_a (v, |b|)\n\ngoal (1 subgoal):\n 1. |\\<A> f \\<beta> ve| \\<lessapprox> \\<aA> f |\\<beta>| ve_a", "by (auto simp add:abs_benv_def split:option.split)"], ["proof (state)\nthis:\n  |\\<A> f \\<beta> ve| \\<lessapprox> \\<aA> f |\\<beta>| ve_a\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  |\\<A> f \\<beta> ve| \\<lessapprox> \\<aA> f |\\<beta>| ve_a\n\ngoal (3 subgoals):\n 1. \\<And>x1.\n       f = L x1 \\<Longrightarrow>\n       |\\<A> f \\<beta> ve| \\<lessapprox> \\<aA> f |\\<beta>| ve_a\n 2. \\<And>x31 x32.\n       f = C x31 x32 \\<Longrightarrow>\n       |\\<A> f \\<beta> ve| \\<lessapprox> \\<aA> f |\\<beta>| ve_a\n 3. \\<And>x4.\n       f = P x4 \\<Longrightarrow>\n       |\\<A> f \\<beta> ve| \\<lessapprox> \\<aA> f |\\<beta>| ve_a", "qed (auto simp add:d_approx_def)"], ["", "subsection \\<open>Lemmas 8 and 9\\<close>"], ["", "text \\<open>\nThe main goal of this section is to show that \\<open>\\<aF>\\<close> safely approximates \\<open>\\<F>\\<close> and that \\<open>\\<aC>\\<close> safely approximates \\<open>\\<C>\\<close>. This has to be shown at once, as the functions are mutually recursive and requires a fixed point induction. To that end, we have to augment the set of continuity lemmas.\n\\<close>"], ["", "lemma cont2cont_abs_ccache[cont2cont,simp]:\n  assumes \"cont f\"\n  shows \"cont (\\<lambda>x. abs_ccache(f x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cont (\\<lambda>x. |f x|)", "unfolding abs_ccache_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. cont\n     (\\<lambda>x.\n         \\<Union>((c, \\<beta>), d)\\<in>f x.\n            {((c, |\\<beta>|), p) |p. p \\<in> |d|})", "using assms"], ["proof (prove)\nusing this:\n  cont f\n\ngoal (1 subgoal):\n 1. cont\n     (\\<lambda>x.\n         \\<Union>((c, \\<beta>), d)\\<in>f x.\n            {((c, |\\<beta>|), p) |p. p \\<in> |d|})", "by (rule cont2cont)(rule cont_const)"], ["", "text \\<open>\nShivers proves these lemmas using parallel fixed point induction over the two fixed points (the one from the exact semantics and the one from the abstract semantics). But it is simpler and equivalent to just do induction over the exact semantics and keep the abstract semantics functions fixed, so this is what I am doing.\n\\<close>"], ["", "lemma lemma89:\n fixes fstate_a :: \"'c::contour_a \\<afstate>\" and cstate_a :: \"'c::contour_a \\<acstate>\"\n shows \"|fstate| \\<lessapprox> fstate_a \\<Longrightarrow> |\\<F>\\<cdot>(Discr fstate)| \\<lessapprox> \\<aF>\\<cdot>(Discr fstate_a)\"\n   and \"|cstate| \\<lessapprox> cstate_a \\<Longrightarrow> |\\<C>\\<cdot>(Discr cstate)| \\<lessapprox> \\<aC>\\<cdot>(Discr cstate_a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (|fstate| \\<lessapprox> fstate_a \\<Longrightarrow>\n     |\\<F>\\<cdot>\n      (Discr fstate)| \\<lessapprox> \\<aF>\\<cdot>(Discr fstate_a)) &&&\n    (|cstate| \\<lessapprox> cstate_a \\<Longrightarrow>\n     |\\<C>\\<cdot>(Discr cstate)| \\<lessapprox> \\<aC>\\<cdot>(Discr cstate_a))", "proof(induct arbitrary: fstate fstate_a cstate cstate_a rule: evalF_evalC_induct)"], ["proof (state)\ngoal (5 subgoals):\n 1. adm (\\<lambda>(evalF, evalC).\n            (\\<forall>x xa.\n                |x| \\<lessapprox> xa \\<longrightarrow>\n                |evalF\\<cdot>\n                 (Discr x)| \\<lessapprox> \\<aF>\\<cdot>(Discr xa)) \\<and>\n            (\\<forall>x xa.\n                |x| \\<lessapprox> xa \\<longrightarrow>\n                |evalC\\<cdot>\n                 (Discr x)| \\<lessapprox> \\<aC>\\<cdot>(Discr xa)))\n 2. \\<And>fstate fstate_a.\n       |fstate| \\<lessapprox> fstate_a \\<Longrightarrow>\n       |\\<bottom>\\<cdot>\n        (Discr fstate)| \\<lessapprox> \\<aF>\\<cdot>(Discr fstate_a)\n 3. \\<And>cstate cstate_a.\n       |cstate| \\<lessapprox> cstate_a \\<Longrightarrow>\n       |\\<bottom>\\<cdot>\n        (Discr cstate)| \\<lessapprox> \\<aC>\\<cdot>(Discr cstate_a)\n 4. \\<And>a b fstate fstate_a.\n       \\<lbrakk>\\<And>fstate fstate_a.\n                   |fstate| \\<lessapprox> fstate_a \\<Longrightarrow>\n                   |a\\<cdot>\n                    (Discr\n                      fstate)| \\<lessapprox> \\<aF>\\<cdot>(Discr fstate_a);\n        \\<And>cstate cstate_a.\n           |cstate| \\<lessapprox> cstate_a \\<Longrightarrow>\n           |b\\<cdot>\n            (Discr cstate)| \\<lessapprox> \\<aC>\\<cdot>(Discr cstate_a);\n        |fstate| \\<lessapprox> fstate_a\\<rbrakk>\n       \\<Longrightarrow> |(\\<Lambda> fstate.\n                              case undiscr fstate of\n                              (DI int, ba) \\<Rightarrow> \\<bottom>\n                              | (DC (Lambda lab vs c, \\<beta>), as, ve,\n                                 ba) \\<Rightarrow>\n                                  if length vs = length as\n                                  then let \\<beta>' = \\<beta>(lab \\<mapsto>\n       ba);\n     ve' = ve(map (\\<lambda>v. (v, ba)) vs [\\<mapsto>] as)\n in b\\<cdot>(Discr (c, \\<beta>', ve', ba))\n                                  else \\<bottom>\n                              | (DP (Plus c), [], bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (Plus c), [DI a1], bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (Plus c), [DI a1, DI a2],\n                                 bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (Plus c), [DI a1, DI a2, cnt], ve,\n                                 b) \\<Rightarrow>\n                                  if isProc cnt\n                                  then let b' = nb b c;\n     \\<beta> = [c \\<mapsto> b]\n in a\\<cdot>(Discr (cnt, [DI (a1 + a2)], ve, b')) \\<union>\n    {((c, \\<beta>), cnt)}\n                                  else \\<bottom>\n                              | (DP (Plus c),\n                                 DI a1 # DI a2 # cnt # aa # lista,\n                                 bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (Plus c), DI a1 # _ # lista,\n                                 bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (Plus c), _ # list, bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (prim.If ct cf), [], bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (prim.If ct cf), [DI v],\n                                 bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (prim.If ct cf), [DI v, contt],\n                                 bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (prim.If ct cf), [DI v, contt, contf],\n                                 ve, b) \\<Rightarrow>\n                                  if isProc contt \\<and> isProc contf\n                                  then if v \\<noteq> 0\n then let b' = nb b ct; \\<beta> = [ct \\<mapsto> b]\n      in a\\<cdot>(Discr (contt, [], ve, b')) \\<union>\n         {((ct, \\<beta>), contt)}\n else let b' = nb b cf; \\<beta> = [cf \\<mapsto> b]\n      in a\\<cdot>(Discr (contf, [], ve, b')) \\<union>\n         {((cf, \\<beta>), contf)}\n                                  else \\<bottom>\n                              | (DP (prim.If ct cf),\n                                 DI v # contt # contf # ab # lista,\n                                 bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (prim.If ct cf), _ # list,\n                                 bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (Stop, [], bb) \\<Rightarrow> \\<bottom>\n                              | (Stop, [DI i], x, xa) \\<Rightarrow> {}\n                              | (Stop, DI i # a # lista, bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (Stop, _ # list, bb) \\<Rightarrow>\n                                  \\<bottom>)\\<cdot>\n                          (Discr\n                            fstate)| \\<lessapprox> \\<aF>\\<cdot>\n             (Discr fstate_a)\n 5. \\<And>a b cstate cstate_a.\n       \\<lbrakk>\\<And>fstate fstate_a.\n                   |fstate| \\<lessapprox> fstate_a \\<Longrightarrow>\n                   |a\\<cdot>\n                    (Discr\n                      fstate)| \\<lessapprox> \\<aF>\\<cdot>(Discr fstate_a);\n        \\<And>cstate cstate_a.\n           |cstate| \\<lessapprox> cstate_a \\<Longrightarrow>\n           |b\\<cdot>\n            (Discr cstate)| \\<lessapprox> \\<aC>\\<cdot>(Discr cstate_a);\n        |cstate| \\<lessapprox> cstate_a\\<rbrakk>\n       \\<Longrightarrow> |(\\<Lambda> cstate.\n                              case undiscr cstate of\n                              (App lab f vs, \\<beta>, ve, b) \\<Rightarrow>\n                                let f' = \\<A> f \\<beta> ve;\n                                    as =\nmap (\\<lambda>v. \\<A> v \\<beta> ve) vs;\n                                    b' = nb b lab\n                                in if isProc f'\n                                   then a\\<cdot>\n  (Discr (f', as, ve, b')) \\<union>\n  {((lab, \\<beta>), f')}\n                                   else \\<bottom>\n                              | (call.Let lab ls c', \\<beta>, ve,\n                                 ba) \\<Rightarrow>\n                                  let b' = nb ba lab;\n\\<beta>' = \\<beta>(lab \\<mapsto> b');\nve' =\n  ve ++ map_of (map (\\<lambda>(v, l). ((v, b'), \\<A> (L l) \\<beta>' ve)) ls)\n                                  in b\\<cdot>\n                                     (Discr (c', \\<beta>', ve', b')))\\<cdot>\n                          (Discr\n                            cstate)| \\<lessapprox> \\<aC>\\<cdot>\n             (Discr cstate_a)", "case Admissibility"], ["proof (state)\nthis:\n  \n\ngoal (5 subgoals):\n 1. adm (\\<lambda>(evalF, evalC).\n            (\\<forall>x xa.\n                |x| \\<lessapprox> xa \\<longrightarrow>\n                |evalF\\<cdot>\n                 (Discr x)| \\<lessapprox> \\<aF>\\<cdot>(Discr xa)) \\<and>\n            (\\<forall>x xa.\n                |x| \\<lessapprox> xa \\<longrightarrow>\n                |evalC\\<cdot>\n                 (Discr x)| \\<lessapprox> \\<aC>\\<cdot>(Discr xa)))\n 2. \\<And>fstate fstate_a.\n       |fstate| \\<lessapprox> fstate_a \\<Longrightarrow>\n       |\\<bottom>\\<cdot>\n        (Discr fstate)| \\<lessapprox> \\<aF>\\<cdot>(Discr fstate_a)\n 3. \\<And>cstate cstate_a.\n       |cstate| \\<lessapprox> cstate_a \\<Longrightarrow>\n       |\\<bottom>\\<cdot>\n        (Discr cstate)| \\<lessapprox> \\<aC>\\<cdot>(Discr cstate_a)\n 4. \\<And>a b fstate fstate_a.\n       \\<lbrakk>\\<And>fstate fstate_a.\n                   |fstate| \\<lessapprox> fstate_a \\<Longrightarrow>\n                   |a\\<cdot>\n                    (Discr\n                      fstate)| \\<lessapprox> \\<aF>\\<cdot>(Discr fstate_a);\n        \\<And>cstate cstate_a.\n           |cstate| \\<lessapprox> cstate_a \\<Longrightarrow>\n           |b\\<cdot>\n            (Discr cstate)| \\<lessapprox> \\<aC>\\<cdot>(Discr cstate_a);\n        |fstate| \\<lessapprox> fstate_a\\<rbrakk>\n       \\<Longrightarrow> |(\\<Lambda> fstate.\n                              case undiscr fstate of\n                              (DI int, ba) \\<Rightarrow> \\<bottom>\n                              | (DC (Lambda lab vs c, \\<beta>), as, ve,\n                                 ba) \\<Rightarrow>\n                                  if length vs = length as\n                                  then let \\<beta>' = \\<beta>(lab \\<mapsto>\n       ba);\n     ve' = ve(map (\\<lambda>v. (v, ba)) vs [\\<mapsto>] as)\n in b\\<cdot>(Discr (c, \\<beta>', ve', ba))\n                                  else \\<bottom>\n                              | (DP (Plus c), [], bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (Plus c), [DI a1], bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (Plus c), [DI a1, DI a2],\n                                 bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (Plus c), [DI a1, DI a2, cnt], ve,\n                                 b) \\<Rightarrow>\n                                  if isProc cnt\n                                  then let b' = nb b c;\n     \\<beta> = [c \\<mapsto> b]\n in a\\<cdot>(Discr (cnt, [DI (a1 + a2)], ve, b')) \\<union>\n    {((c, \\<beta>), cnt)}\n                                  else \\<bottom>\n                              | (DP (Plus c),\n                                 DI a1 # DI a2 # cnt # aa # lista,\n                                 bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (Plus c), DI a1 # _ # lista,\n                                 bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (Plus c), _ # list, bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (prim.If ct cf), [], bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (prim.If ct cf), [DI v],\n                                 bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (prim.If ct cf), [DI v, contt],\n                                 bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (prim.If ct cf), [DI v, contt, contf],\n                                 ve, b) \\<Rightarrow>\n                                  if isProc contt \\<and> isProc contf\n                                  then if v \\<noteq> 0\n then let b' = nb b ct; \\<beta> = [ct \\<mapsto> b]\n      in a\\<cdot>(Discr (contt, [], ve, b')) \\<union>\n         {((ct, \\<beta>), contt)}\n else let b' = nb b cf; \\<beta> = [cf \\<mapsto> b]\n      in a\\<cdot>(Discr (contf, [], ve, b')) \\<union>\n         {((cf, \\<beta>), contf)}\n                                  else \\<bottom>\n                              | (DP (prim.If ct cf),\n                                 DI v # contt # contf # ab # lista,\n                                 bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (prim.If ct cf), _ # list,\n                                 bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (Stop, [], bb) \\<Rightarrow> \\<bottom>\n                              | (Stop, [DI i], x, xa) \\<Rightarrow> {}\n                              | (Stop, DI i # a # lista, bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (Stop, _ # list, bb) \\<Rightarrow>\n                                  \\<bottom>)\\<cdot>\n                          (Discr\n                            fstate)| \\<lessapprox> \\<aF>\\<cdot>\n             (Discr fstate_a)\n 5. \\<And>a b cstate cstate_a.\n       \\<lbrakk>\\<And>fstate fstate_a.\n                   |fstate| \\<lessapprox> fstate_a \\<Longrightarrow>\n                   |a\\<cdot>\n                    (Discr\n                      fstate)| \\<lessapprox> \\<aF>\\<cdot>(Discr fstate_a);\n        \\<And>cstate cstate_a.\n           |cstate| \\<lessapprox> cstate_a \\<Longrightarrow>\n           |b\\<cdot>\n            (Discr cstate)| \\<lessapprox> \\<aC>\\<cdot>(Discr cstate_a);\n        |cstate| \\<lessapprox> cstate_a\\<rbrakk>\n       \\<Longrightarrow> |(\\<Lambda> cstate.\n                              case undiscr cstate of\n                              (App lab f vs, \\<beta>, ve, b) \\<Rightarrow>\n                                let f' = \\<A> f \\<beta> ve;\n                                    as =\nmap (\\<lambda>v. \\<A> v \\<beta> ve) vs;\n                                    b' = nb b lab\n                                in if isProc f'\n                                   then a\\<cdot>\n  (Discr (f', as, ve, b')) \\<union>\n  {((lab, \\<beta>), f')}\n                                   else \\<bottom>\n                              | (call.Let lab ls c', \\<beta>, ve,\n                                 ba) \\<Rightarrow>\n                                  let b' = nb ba lab;\n\\<beta>' = \\<beta>(lab \\<mapsto> b');\nve' =\n  ve ++ map_of (map (\\<lambda>(v, l). ((v, b'), \\<A> (L l) \\<beta>' ve)) ls)\n                                  in b\\<cdot>\n                                     (Discr (c', \\<beta>', ve', b')))\\<cdot>\n                          (Discr\n                            cstate)| \\<lessapprox> \\<aC>\\<cdot>\n             (Discr cstate_a)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. adm (\\<lambda>(evalF, evalC).\n            (\\<forall>x xa.\n                |x| \\<lessapprox> xa \\<longrightarrow>\n                |evalF\\<cdot>\n                 (Discr x)| \\<lessapprox> \\<aF>\\<cdot>(Discr xa)) \\<and>\n            (\\<forall>x xa.\n                |x| \\<lessapprox> xa \\<longrightarrow>\n                |evalC\\<cdot>\n                 (Discr x)| \\<lessapprox> \\<aC>\\<cdot>(Discr xa)))", "unfolding ccache_approx_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. adm (\\<lambda>(evalF, evalC).\n            (\\<forall>x xa.\n                |x| \\<lessapprox> xa \\<longrightarrow>\n                |evalF\\<cdot>(Discr x)|\n                \\<subseteq> \\<aF>\\<cdot>(Discr xa)) \\<and>\n            (\\<forall>x xa.\n                |x| \\<lessapprox> xa \\<longrightarrow>\n                |evalC\\<cdot>(Discr x)| \\<subseteq> \\<aC>\\<cdot>(Discr xa)))", "by (intro adm_lemmas adm_subset adm_prod_split adm_not_conj adm_not_mem adm_single_valued cont2cont)"], ["proof (state)\nthis:\n  adm (\\<lambda>(evalF, evalC).\n          (\\<forall>x xa.\n              |x| \\<lessapprox> xa \\<longrightarrow>\n              |evalF\\<cdot>\n               (Discr x)| \\<lessapprox> \\<aF>\\<cdot>(Discr xa)) \\<and>\n          (\\<forall>x xa.\n              |x| \\<lessapprox> xa \\<longrightarrow>\n              |evalC\\<cdot>(Discr x)| \\<lessapprox> \\<aC>\\<cdot>(Discr xa)))\n\ngoal (4 subgoals):\n 1. \\<And>fstate fstate_a.\n       |fstate| \\<lessapprox> fstate_a \\<Longrightarrow>\n       |\\<bottom>\\<cdot>\n        (Discr fstate)| \\<lessapprox> \\<aF>\\<cdot>(Discr fstate_a)\n 2. \\<And>cstate cstate_a.\n       |cstate| \\<lessapprox> cstate_a \\<Longrightarrow>\n       |\\<bottom>\\<cdot>\n        (Discr cstate)| \\<lessapprox> \\<aC>\\<cdot>(Discr cstate_a)\n 3. \\<And>a b fstate fstate_a.\n       \\<lbrakk>\\<And>fstate fstate_a.\n                   |fstate| \\<lessapprox> fstate_a \\<Longrightarrow>\n                   |a\\<cdot>\n                    (Discr\n                      fstate)| \\<lessapprox> \\<aF>\\<cdot>(Discr fstate_a);\n        \\<And>cstate cstate_a.\n           |cstate| \\<lessapprox> cstate_a \\<Longrightarrow>\n           |b\\<cdot>\n            (Discr cstate)| \\<lessapprox> \\<aC>\\<cdot>(Discr cstate_a);\n        |fstate| \\<lessapprox> fstate_a\\<rbrakk>\n       \\<Longrightarrow> |(\\<Lambda> fstate.\n                              case undiscr fstate of\n                              (DI int, ba) \\<Rightarrow> \\<bottom>\n                              | (DC (Lambda lab vs c, \\<beta>), as, ve,\n                                 ba) \\<Rightarrow>\n                                  if length vs = length as\n                                  then let \\<beta>' = \\<beta>(lab \\<mapsto>\n       ba);\n     ve' = ve(map (\\<lambda>v. (v, ba)) vs [\\<mapsto>] as)\n in b\\<cdot>(Discr (c, \\<beta>', ve', ba))\n                                  else \\<bottom>\n                              | (DP (Plus c), [], bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (Plus c), [DI a1], bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (Plus c), [DI a1, DI a2],\n                                 bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (Plus c), [DI a1, DI a2, cnt], ve,\n                                 b) \\<Rightarrow>\n                                  if isProc cnt\n                                  then let b' = nb b c;\n     \\<beta> = [c \\<mapsto> b]\n in a\\<cdot>(Discr (cnt, [DI (a1 + a2)], ve, b')) \\<union>\n    {((c, \\<beta>), cnt)}\n                                  else \\<bottom>\n                              | (DP (Plus c),\n                                 DI a1 # DI a2 # cnt # aa # lista,\n                                 bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (Plus c), DI a1 # _ # lista,\n                                 bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (Plus c), _ # list, bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (prim.If ct cf), [], bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (prim.If ct cf), [DI v],\n                                 bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (prim.If ct cf), [DI v, contt],\n                                 bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (prim.If ct cf), [DI v, contt, contf],\n                                 ve, b) \\<Rightarrow>\n                                  if isProc contt \\<and> isProc contf\n                                  then if v \\<noteq> 0\n then let b' = nb b ct; \\<beta> = [ct \\<mapsto> b]\n      in a\\<cdot>(Discr (contt, [], ve, b')) \\<union>\n         {((ct, \\<beta>), contt)}\n else let b' = nb b cf; \\<beta> = [cf \\<mapsto> b]\n      in a\\<cdot>(Discr (contf, [], ve, b')) \\<union>\n         {((cf, \\<beta>), contf)}\n                                  else \\<bottom>\n                              | (DP (prim.If ct cf),\n                                 DI v # contt # contf # ab # lista,\n                                 bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (prim.If ct cf), _ # list,\n                                 bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (Stop, [], bb) \\<Rightarrow> \\<bottom>\n                              | (Stop, [DI i], x, xa) \\<Rightarrow> {}\n                              | (Stop, DI i # a # lista, bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (Stop, _ # list, bb) \\<Rightarrow>\n                                  \\<bottom>)\\<cdot>\n                          (Discr\n                            fstate)| \\<lessapprox> \\<aF>\\<cdot>\n             (Discr fstate_a)\n 4. \\<And>a b cstate cstate_a.\n       \\<lbrakk>\\<And>fstate fstate_a.\n                   |fstate| \\<lessapprox> fstate_a \\<Longrightarrow>\n                   |a\\<cdot>\n                    (Discr\n                      fstate)| \\<lessapprox> \\<aF>\\<cdot>(Discr fstate_a);\n        \\<And>cstate cstate_a.\n           |cstate| \\<lessapprox> cstate_a \\<Longrightarrow>\n           |b\\<cdot>\n            (Discr cstate)| \\<lessapprox> \\<aC>\\<cdot>(Discr cstate_a);\n        |cstate| \\<lessapprox> cstate_a\\<rbrakk>\n       \\<Longrightarrow> |(\\<Lambda> cstate.\n                              case undiscr cstate of\n                              (App lab f vs, \\<beta>, ve, b) \\<Rightarrow>\n                                let f' = \\<A> f \\<beta> ve;\n                                    as =\nmap (\\<lambda>v. \\<A> v \\<beta> ve) vs;\n                                    b' = nb b lab\n                                in if isProc f'\n                                   then a\\<cdot>\n  (Discr (f', as, ve, b')) \\<union>\n  {((lab, \\<beta>), f')}\n                                   else \\<bottom>\n                              | (call.Let lab ls c', \\<beta>, ve,\n                                 ba) \\<Rightarrow>\n                                  let b' = nb ba lab;\n\\<beta>' = \\<beta>(lab \\<mapsto> b');\nve' =\n  ve ++ map_of (map (\\<lambda>(v, l). ((v, b'), \\<A> (L l) \\<beta>' ve)) ls)\n                                  in b\\<cdot>\n                                     (Discr (c', \\<beta>', ve', b')))\\<cdot>\n                          (Discr\n                            cstate)| \\<lessapprox> \\<aC>\\<cdot>\n             (Discr cstate_a)", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>fstate fstate_a.\n       |fstate| \\<lessapprox> fstate_a \\<Longrightarrow>\n       |\\<bottom>\\<cdot>\n        (Discr fstate)| \\<lessapprox> \\<aF>\\<cdot>(Discr fstate_a)\n 2. \\<And>cstate cstate_a.\n       |cstate| \\<lessapprox> cstate_a \\<Longrightarrow>\n       |\\<bottom>\\<cdot>\n        (Discr cstate)| \\<lessapprox> \\<aC>\\<cdot>(Discr cstate_a)\n 3. \\<And>a b fstate fstate_a.\n       \\<lbrakk>\\<And>fstate fstate_a.\n                   |fstate| \\<lessapprox> fstate_a \\<Longrightarrow>\n                   |a\\<cdot>\n                    (Discr\n                      fstate)| \\<lessapprox> \\<aF>\\<cdot>(Discr fstate_a);\n        \\<And>cstate cstate_a.\n           |cstate| \\<lessapprox> cstate_a \\<Longrightarrow>\n           |b\\<cdot>\n            (Discr cstate)| \\<lessapprox> \\<aC>\\<cdot>(Discr cstate_a);\n        |fstate| \\<lessapprox> fstate_a\\<rbrakk>\n       \\<Longrightarrow> |(\\<Lambda> fstate.\n                              case undiscr fstate of\n                              (DI int, ba) \\<Rightarrow> \\<bottom>\n                              | (DC (Lambda lab vs c, \\<beta>), as, ve,\n                                 ba) \\<Rightarrow>\n                                  if length vs = length as\n                                  then let \\<beta>' = \\<beta>(lab \\<mapsto>\n       ba);\n     ve' = ve(map (\\<lambda>v. (v, ba)) vs [\\<mapsto>] as)\n in b\\<cdot>(Discr (c, \\<beta>', ve', ba))\n                                  else \\<bottom>\n                              | (DP (Plus c), [], bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (Plus c), [DI a1], bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (Plus c), [DI a1, DI a2],\n                                 bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (Plus c), [DI a1, DI a2, cnt], ve,\n                                 b) \\<Rightarrow>\n                                  if isProc cnt\n                                  then let b' = nb b c;\n     \\<beta> = [c \\<mapsto> b]\n in a\\<cdot>(Discr (cnt, [DI (a1 + a2)], ve, b')) \\<union>\n    {((c, \\<beta>), cnt)}\n                                  else \\<bottom>\n                              | (DP (Plus c),\n                                 DI a1 # DI a2 # cnt # aa # lista,\n                                 bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (Plus c), DI a1 # _ # lista,\n                                 bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (Plus c), _ # list, bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (prim.If ct cf), [], bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (prim.If ct cf), [DI v],\n                                 bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (prim.If ct cf), [DI v, contt],\n                                 bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (prim.If ct cf), [DI v, contt, contf],\n                                 ve, b) \\<Rightarrow>\n                                  if isProc contt \\<and> isProc contf\n                                  then if v \\<noteq> 0\n then let b' = nb b ct; \\<beta> = [ct \\<mapsto> b]\n      in a\\<cdot>(Discr (contt, [], ve, b')) \\<union>\n         {((ct, \\<beta>), contt)}\n else let b' = nb b cf; \\<beta> = [cf \\<mapsto> b]\n      in a\\<cdot>(Discr (contf, [], ve, b')) \\<union>\n         {((cf, \\<beta>), contf)}\n                                  else \\<bottom>\n                              | (DP (prim.If ct cf),\n                                 DI v # contt # contf # ab # lista,\n                                 bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (prim.If ct cf), _ # list,\n                                 bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (Stop, [], bb) \\<Rightarrow> \\<bottom>\n                              | (Stop, [DI i], x, xa) \\<Rightarrow> {}\n                              | (Stop, DI i # a # lista, bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (Stop, _ # list, bb) \\<Rightarrow>\n                                  \\<bottom>)\\<cdot>\n                          (Discr\n                            fstate)| \\<lessapprox> \\<aF>\\<cdot>\n             (Discr fstate_a)\n 4. \\<And>a b cstate cstate_a.\n       \\<lbrakk>\\<And>fstate fstate_a.\n                   |fstate| \\<lessapprox> fstate_a \\<Longrightarrow>\n                   |a\\<cdot>\n                    (Discr\n                      fstate)| \\<lessapprox> \\<aF>\\<cdot>(Discr fstate_a);\n        \\<And>cstate cstate_a.\n           |cstate| \\<lessapprox> cstate_a \\<Longrightarrow>\n           |b\\<cdot>\n            (Discr cstate)| \\<lessapprox> \\<aC>\\<cdot>(Discr cstate_a);\n        |cstate| \\<lessapprox> cstate_a\\<rbrakk>\n       \\<Longrightarrow> |(\\<Lambda> cstate.\n                              case undiscr cstate of\n                              (App lab f vs, \\<beta>, ve, b) \\<Rightarrow>\n                                let f' = \\<A> f \\<beta> ve;\n                                    as =\nmap (\\<lambda>v. \\<A> v \\<beta> ve) vs;\n                                    b' = nb b lab\n                                in if isProc f'\n                                   then a\\<cdot>\n  (Discr (f', as, ve, b')) \\<union>\n  {((lab, \\<beta>), f')}\n                                   else \\<bottom>\n                              | (call.Let lab ls c', \\<beta>, ve,\n                                 ba) \\<Rightarrow>\n                                  let b' = nb ba lab;\n\\<beta>' = \\<beta>(lab \\<mapsto> b');\nve' =\n  ve ++ map_of (map (\\<lambda>(v, l). ((v, b'), \\<A> (L l) \\<beta>' ve)) ls)\n                                  in b\\<cdot>\n                                     (Discr (c', \\<beta>', ve', b')))\\<cdot>\n                          (Discr\n                            cstate)| \\<lessapprox> \\<aC>\\<cdot>\n             (Discr cstate_a)", "case Bottom"], ["proof (state)\nthis:\n  \n\ngoal (4 subgoals):\n 1. \\<And>fstate fstate_a.\n       |fstate| \\<lessapprox> fstate_a \\<Longrightarrow>\n       |\\<bottom>\\<cdot>\n        (Discr fstate)| \\<lessapprox> \\<aF>\\<cdot>(Discr fstate_a)\n 2. \\<And>cstate cstate_a.\n       |cstate| \\<lessapprox> cstate_a \\<Longrightarrow>\n       |\\<bottom>\\<cdot>\n        (Discr cstate)| \\<lessapprox> \\<aC>\\<cdot>(Discr cstate_a)\n 3. \\<And>a b fstate fstate_a.\n       \\<lbrakk>\\<And>fstate fstate_a.\n                   |fstate| \\<lessapprox> fstate_a \\<Longrightarrow>\n                   |a\\<cdot>\n                    (Discr\n                      fstate)| \\<lessapprox> \\<aF>\\<cdot>(Discr fstate_a);\n        \\<And>cstate cstate_a.\n           |cstate| \\<lessapprox> cstate_a \\<Longrightarrow>\n           |b\\<cdot>\n            (Discr cstate)| \\<lessapprox> \\<aC>\\<cdot>(Discr cstate_a);\n        |fstate| \\<lessapprox> fstate_a\\<rbrakk>\n       \\<Longrightarrow> |(\\<Lambda> fstate.\n                              case undiscr fstate of\n                              (DI int, ba) \\<Rightarrow> \\<bottom>\n                              | (DC (Lambda lab vs c, \\<beta>), as, ve,\n                                 ba) \\<Rightarrow>\n                                  if length vs = length as\n                                  then let \\<beta>' = \\<beta>(lab \\<mapsto>\n       ba);\n     ve' = ve(map (\\<lambda>v. (v, ba)) vs [\\<mapsto>] as)\n in b\\<cdot>(Discr (c, \\<beta>', ve', ba))\n                                  else \\<bottom>\n                              | (DP (Plus c), [], bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (Plus c), [DI a1], bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (Plus c), [DI a1, DI a2],\n                                 bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (Plus c), [DI a1, DI a2, cnt], ve,\n                                 b) \\<Rightarrow>\n                                  if isProc cnt\n                                  then let b' = nb b c;\n     \\<beta> = [c \\<mapsto> b]\n in a\\<cdot>(Discr (cnt, [DI (a1 + a2)], ve, b')) \\<union>\n    {((c, \\<beta>), cnt)}\n                                  else \\<bottom>\n                              | (DP (Plus c),\n                                 DI a1 # DI a2 # cnt # aa # lista,\n                                 bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (Plus c), DI a1 # _ # lista,\n                                 bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (Plus c), _ # list, bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (prim.If ct cf), [], bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (prim.If ct cf), [DI v],\n                                 bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (prim.If ct cf), [DI v, contt],\n                                 bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (prim.If ct cf), [DI v, contt, contf],\n                                 ve, b) \\<Rightarrow>\n                                  if isProc contt \\<and> isProc contf\n                                  then if v \\<noteq> 0\n then let b' = nb b ct; \\<beta> = [ct \\<mapsto> b]\n      in a\\<cdot>(Discr (contt, [], ve, b')) \\<union>\n         {((ct, \\<beta>), contt)}\n else let b' = nb b cf; \\<beta> = [cf \\<mapsto> b]\n      in a\\<cdot>(Discr (contf, [], ve, b')) \\<union>\n         {((cf, \\<beta>), contf)}\n                                  else \\<bottom>\n                              | (DP (prim.If ct cf),\n                                 DI v # contt # contf # ab # lista,\n                                 bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (prim.If ct cf), _ # list,\n                                 bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (Stop, [], bb) \\<Rightarrow> \\<bottom>\n                              | (Stop, [DI i], x, xa) \\<Rightarrow> {}\n                              | (Stop, DI i # a # lista, bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (Stop, _ # list, bb) \\<Rightarrow>\n                                  \\<bottom>)\\<cdot>\n                          (Discr\n                            fstate)| \\<lessapprox> \\<aF>\\<cdot>\n             (Discr fstate_a)\n 4. \\<And>a b cstate cstate_a.\n       \\<lbrakk>\\<And>fstate fstate_a.\n                   |fstate| \\<lessapprox> fstate_a \\<Longrightarrow>\n                   |a\\<cdot>\n                    (Discr\n                      fstate)| \\<lessapprox> \\<aF>\\<cdot>(Discr fstate_a);\n        \\<And>cstate cstate_a.\n           |cstate| \\<lessapprox> cstate_a \\<Longrightarrow>\n           |b\\<cdot>\n            (Discr cstate)| \\<lessapprox> \\<aC>\\<cdot>(Discr cstate_a);\n        |cstate| \\<lessapprox> cstate_a\\<rbrakk>\n       \\<Longrightarrow> |(\\<Lambda> cstate.\n                              case undiscr cstate of\n                              (App lab f vs, \\<beta>, ve, b) \\<Rightarrow>\n                                let f' = \\<A> f \\<beta> ve;\n                                    as =\nmap (\\<lambda>v. \\<A> v \\<beta> ve) vs;\n                                    b' = nb b lab\n                                in if isProc f'\n                                   then a\\<cdot>\n  (Discr (f', as, ve, b')) \\<union>\n  {((lab, \\<beta>), f')}\n                                   else \\<bottom>\n                              | (call.Let lab ls c', \\<beta>, ve,\n                                 ba) \\<Rightarrow>\n                                  let b' = nb ba lab;\n\\<beta>' = \\<beta>(lab \\<mapsto> b');\nve' =\n  ve ++ map_of (map (\\<lambda>(v, l). ((v, b'), \\<A> (L l) \\<beta>' ve)) ls)\n                                  in b\\<cdot>\n                                     (Discr (c', \\<beta>', ve', b')))\\<cdot>\n                          (Discr\n                            cstate)| \\<lessapprox> \\<aC>\\<cdot>\n             (Discr cstate_a)", "{"], ["proof (state)\nthis:\n  \n\ngoal (4 subgoals):\n 1. \\<And>fstate fstate_a.\n       |fstate| \\<lessapprox> fstate_a \\<Longrightarrow>\n       |\\<bottom>\\<cdot>\n        (Discr fstate)| \\<lessapprox> \\<aF>\\<cdot>(Discr fstate_a)\n 2. \\<And>cstate cstate_a.\n       |cstate| \\<lessapprox> cstate_a \\<Longrightarrow>\n       |\\<bottom>\\<cdot>\n        (Discr cstate)| \\<lessapprox> \\<aC>\\<cdot>(Discr cstate_a)\n 3. \\<And>a b fstate fstate_a.\n       \\<lbrakk>\\<And>fstate fstate_a.\n                   |fstate| \\<lessapprox> fstate_a \\<Longrightarrow>\n                   |a\\<cdot>\n                    (Discr\n                      fstate)| \\<lessapprox> \\<aF>\\<cdot>(Discr fstate_a);\n        \\<And>cstate cstate_a.\n           |cstate| \\<lessapprox> cstate_a \\<Longrightarrow>\n           |b\\<cdot>\n            (Discr cstate)| \\<lessapprox> \\<aC>\\<cdot>(Discr cstate_a);\n        |fstate| \\<lessapprox> fstate_a\\<rbrakk>\n       \\<Longrightarrow> |(\\<Lambda> fstate.\n                              case undiscr fstate of\n                              (DI int, ba) \\<Rightarrow> \\<bottom>\n                              | (DC (Lambda lab vs c, \\<beta>), as, ve,\n                                 ba) \\<Rightarrow>\n                                  if length vs = length as\n                                  then let \\<beta>' = \\<beta>(lab \\<mapsto>\n       ba);\n     ve' = ve(map (\\<lambda>v. (v, ba)) vs [\\<mapsto>] as)\n in b\\<cdot>(Discr (c, \\<beta>', ve', ba))\n                                  else \\<bottom>\n                              | (DP (Plus c), [], bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (Plus c), [DI a1], bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (Plus c), [DI a1, DI a2],\n                                 bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (Plus c), [DI a1, DI a2, cnt], ve,\n                                 b) \\<Rightarrow>\n                                  if isProc cnt\n                                  then let b' = nb b c;\n     \\<beta> = [c \\<mapsto> b]\n in a\\<cdot>(Discr (cnt, [DI (a1 + a2)], ve, b')) \\<union>\n    {((c, \\<beta>), cnt)}\n                                  else \\<bottom>\n                              | (DP (Plus c),\n                                 DI a1 # DI a2 # cnt # aa # lista,\n                                 bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (Plus c), DI a1 # _ # lista,\n                                 bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (Plus c), _ # list, bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (prim.If ct cf), [], bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (prim.If ct cf), [DI v],\n                                 bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (prim.If ct cf), [DI v, contt],\n                                 bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (prim.If ct cf), [DI v, contt, contf],\n                                 ve, b) \\<Rightarrow>\n                                  if isProc contt \\<and> isProc contf\n                                  then if v \\<noteq> 0\n then let b' = nb b ct; \\<beta> = [ct \\<mapsto> b]\n      in a\\<cdot>(Discr (contt, [], ve, b')) \\<union>\n         {((ct, \\<beta>), contt)}\n else let b' = nb b cf; \\<beta> = [cf \\<mapsto> b]\n      in a\\<cdot>(Discr (contf, [], ve, b')) \\<union>\n         {((cf, \\<beta>), contf)}\n                                  else \\<bottom>\n                              | (DP (prim.If ct cf),\n                                 DI v # contt # contf # ab # lista,\n                                 bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (prim.If ct cf), _ # list,\n                                 bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (Stop, [], bb) \\<Rightarrow> \\<bottom>\n                              | (Stop, [DI i], x, xa) \\<Rightarrow> {}\n                              | (Stop, DI i # a # lista, bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (Stop, _ # list, bb) \\<Rightarrow>\n                                  \\<bottom>)\\<cdot>\n                          (Discr\n                            fstate)| \\<lessapprox> \\<aF>\\<cdot>\n             (Discr fstate_a)\n 4. \\<And>a b cstate cstate_a.\n       \\<lbrakk>\\<And>fstate fstate_a.\n                   |fstate| \\<lessapprox> fstate_a \\<Longrightarrow>\n                   |a\\<cdot>\n                    (Discr\n                      fstate)| \\<lessapprox> \\<aF>\\<cdot>(Discr fstate_a);\n        \\<And>cstate cstate_a.\n           |cstate| \\<lessapprox> cstate_a \\<Longrightarrow>\n           |b\\<cdot>\n            (Discr cstate)| \\<lessapprox> \\<aC>\\<cdot>(Discr cstate_a);\n        |cstate| \\<lessapprox> cstate_a\\<rbrakk>\n       \\<Longrightarrow> |(\\<Lambda> cstate.\n                              case undiscr cstate of\n                              (App lab f vs, \\<beta>, ve, b) \\<Rightarrow>\n                                let f' = \\<A> f \\<beta> ve;\n                                    as =\nmap (\\<lambda>v. \\<A> v \\<beta> ve) vs;\n                                    b' = nb b lab\n                                in if isProc f'\n                                   then a\\<cdot>\n  (Discr (f', as, ve, b')) \\<union>\n  {((lab, \\<beta>), f')}\n                                   else \\<bottom>\n                              | (call.Let lab ls c', \\<beta>, ve,\n                                 ba) \\<Rightarrow>\n                                  let b' = nb ba lab;\n\\<beta>' = \\<beta>(lab \\<mapsto> b');\nve' =\n  ve ++ map_of (map (\\<lambda>(v, l). ((v, b'), \\<A> (L l) \\<beta>' ve)) ls)\n                                  in b\\<cdot>\n                                     (Discr (c', \\<beta>', ve', b')))\\<cdot>\n                          (Discr\n                            cstate)| \\<lessapprox> \\<aC>\\<cdot>\n             (Discr cstate_a)", "case 1"], ["proof (state)\nthis:\n  |fstate| \\<lessapprox> fstate_a\n\ngoal (4 subgoals):\n 1. \\<And>fstate fstate_a.\n       |fstate| \\<lessapprox> fstate_a \\<Longrightarrow>\n       |\\<bottom>\\<cdot>\n        (Discr fstate)| \\<lessapprox> \\<aF>\\<cdot>(Discr fstate_a)\n 2. \\<And>cstate cstate_a.\n       |cstate| \\<lessapprox> cstate_a \\<Longrightarrow>\n       |\\<bottom>\\<cdot>\n        (Discr cstate)| \\<lessapprox> \\<aC>\\<cdot>(Discr cstate_a)\n 3. \\<And>a b fstate fstate_a.\n       \\<lbrakk>\\<And>fstate fstate_a.\n                   |fstate| \\<lessapprox> fstate_a \\<Longrightarrow>\n                   |a\\<cdot>\n                    (Discr\n                      fstate)| \\<lessapprox> \\<aF>\\<cdot>(Discr fstate_a);\n        \\<And>cstate cstate_a.\n           |cstate| \\<lessapprox> cstate_a \\<Longrightarrow>\n           |b\\<cdot>\n            (Discr cstate)| \\<lessapprox> \\<aC>\\<cdot>(Discr cstate_a);\n        |fstate| \\<lessapprox> fstate_a\\<rbrakk>\n       \\<Longrightarrow> |(\\<Lambda> fstate.\n                              case undiscr fstate of\n                              (DI int, ba) \\<Rightarrow> \\<bottom>\n                              | (DC (Lambda lab vs c, \\<beta>), as, ve,\n                                 ba) \\<Rightarrow>\n                                  if length vs = length as\n                                  then let \\<beta>' = \\<beta>(lab \\<mapsto>\n       ba);\n     ve' = ve(map (\\<lambda>v. (v, ba)) vs [\\<mapsto>] as)\n in b\\<cdot>(Discr (c, \\<beta>', ve', ba))\n                                  else \\<bottom>\n                              | (DP (Plus c), [], bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (Plus c), [DI a1], bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (Plus c), [DI a1, DI a2],\n                                 bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (Plus c), [DI a1, DI a2, cnt], ve,\n                                 b) \\<Rightarrow>\n                                  if isProc cnt\n                                  then let b' = nb b c;\n     \\<beta> = [c \\<mapsto> b]\n in a\\<cdot>(Discr (cnt, [DI (a1 + a2)], ve, b')) \\<union>\n    {((c, \\<beta>), cnt)}\n                                  else \\<bottom>\n                              | (DP (Plus c),\n                                 DI a1 # DI a2 # cnt # aa # lista,\n                                 bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (Plus c), DI a1 # _ # lista,\n                                 bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (Plus c), _ # list, bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (prim.If ct cf), [], bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (prim.If ct cf), [DI v],\n                                 bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (prim.If ct cf), [DI v, contt],\n                                 bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (prim.If ct cf), [DI v, contt, contf],\n                                 ve, b) \\<Rightarrow>\n                                  if isProc contt \\<and> isProc contf\n                                  then if v \\<noteq> 0\n then let b' = nb b ct; \\<beta> = [ct \\<mapsto> b]\n      in a\\<cdot>(Discr (contt, [], ve, b')) \\<union>\n         {((ct, \\<beta>), contt)}\n else let b' = nb b cf; \\<beta> = [cf \\<mapsto> b]\n      in a\\<cdot>(Discr (contf, [], ve, b')) \\<union>\n         {((cf, \\<beta>), contf)}\n                                  else \\<bottom>\n                              | (DP (prim.If ct cf),\n                                 DI v # contt # contf # ab # lista,\n                                 bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (prim.If ct cf), _ # list,\n                                 bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (Stop, [], bb) \\<Rightarrow> \\<bottom>\n                              | (Stop, [DI i], x, xa) \\<Rightarrow> {}\n                              | (Stop, DI i # a # lista, bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (Stop, _ # list, bb) \\<Rightarrow>\n                                  \\<bottom>)\\<cdot>\n                          (Discr\n                            fstate)| \\<lessapprox> \\<aF>\\<cdot>\n             (Discr fstate_a)\n 4. \\<And>a b cstate cstate_a.\n       \\<lbrakk>\\<And>fstate fstate_a.\n                   |fstate| \\<lessapprox> fstate_a \\<Longrightarrow>\n                   |a\\<cdot>\n                    (Discr\n                      fstate)| \\<lessapprox> \\<aF>\\<cdot>(Discr fstate_a);\n        \\<And>cstate cstate_a.\n           |cstate| \\<lessapprox> cstate_a \\<Longrightarrow>\n           |b\\<cdot>\n            (Discr cstate)| \\<lessapprox> \\<aC>\\<cdot>(Discr cstate_a);\n        |cstate| \\<lessapprox> cstate_a\\<rbrakk>\n       \\<Longrightarrow> |(\\<Lambda> cstate.\n                              case undiscr cstate of\n                              (App lab f vs, \\<beta>, ve, b) \\<Rightarrow>\n                                let f' = \\<A> f \\<beta> ve;\n                                    as =\nmap (\\<lambda>v. \\<A> v \\<beta> ve) vs;\n                                    b' = nb b lab\n                                in if isProc f'\n                                   then a\\<cdot>\n  (Discr (f', as, ve, b')) \\<union>\n  {((lab, \\<beta>), f')}\n                                   else \\<bottom>\n                              | (call.Let lab ls c', \\<beta>, ve,\n                                 ba) \\<Rightarrow>\n                                  let b' = nb ba lab;\n\\<beta>' = \\<beta>(lab \\<mapsto> b');\nve' =\n  ve ++ map_of (map (\\<lambda>(v, l). ((v, b'), \\<A> (L l) \\<beta>' ve)) ls)\n                                  in b\\<cdot>\n                                     (Discr (c', \\<beta>', ve', b')))\\<cdot>\n                          (Discr\n                            cstate)| \\<lessapprox> \\<aC>\\<cdot>\n             (Discr cstate_a)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. |\\<bottom>\\<cdot>\n     (Discr fstate)| \\<lessapprox> \\<aF>\\<cdot>(Discr fstate_a)", "by simp"], ["proof (state)\nthis:\n  |\\<bottom>\\<cdot>\n   (Discr fstate)| \\<lessapprox> \\<aF>\\<cdot>(Discr fstate_a)\n\ngoal (3 subgoals):\n 1. \\<And>cstate cstate_a.\n       |cstate| \\<lessapprox> cstate_a \\<Longrightarrow>\n       |\\<bottom>\\<cdot>\n        (Discr cstate)| \\<lessapprox> \\<aC>\\<cdot>(Discr cstate_a)\n 2. \\<And>a b fstate fstate_a.\n       \\<lbrakk>\\<And>fstate fstate_a.\n                   |fstate| \\<lessapprox> fstate_a \\<Longrightarrow>\n                   |a\\<cdot>\n                    (Discr\n                      fstate)| \\<lessapprox> \\<aF>\\<cdot>(Discr fstate_a);\n        \\<And>cstate cstate_a.\n           |cstate| \\<lessapprox> cstate_a \\<Longrightarrow>\n           |b\\<cdot>\n            (Discr cstate)| \\<lessapprox> \\<aC>\\<cdot>(Discr cstate_a);\n        |fstate| \\<lessapprox> fstate_a\\<rbrakk>\n       \\<Longrightarrow> |(\\<Lambda> fstate.\n                              case undiscr fstate of\n                              (DI int, ba) \\<Rightarrow> \\<bottom>\n                              | (DC (Lambda lab vs c, \\<beta>), as, ve,\n                                 ba) \\<Rightarrow>\n                                  if length vs = length as\n                                  then let \\<beta>' = \\<beta>(lab \\<mapsto>\n       ba);\n     ve' = ve(map (\\<lambda>v. (v, ba)) vs [\\<mapsto>] as)\n in b\\<cdot>(Discr (c, \\<beta>', ve', ba))\n                                  else \\<bottom>\n                              | (DP (Plus c), [], bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (Plus c), [DI a1], bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (Plus c), [DI a1, DI a2],\n                                 bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (Plus c), [DI a1, DI a2, cnt], ve,\n                                 b) \\<Rightarrow>\n                                  if isProc cnt\n                                  then let b' = nb b c;\n     \\<beta> = [c \\<mapsto> b]\n in a\\<cdot>(Discr (cnt, [DI (a1 + a2)], ve, b')) \\<union>\n    {((c, \\<beta>), cnt)}\n                                  else \\<bottom>\n                              | (DP (Plus c),\n                                 DI a1 # DI a2 # cnt # aa # lista,\n                                 bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (Plus c), DI a1 # _ # lista,\n                                 bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (Plus c), _ # list, bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (prim.If ct cf), [], bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (prim.If ct cf), [DI v],\n                                 bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (prim.If ct cf), [DI v, contt],\n                                 bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (prim.If ct cf), [DI v, contt, contf],\n                                 ve, b) \\<Rightarrow>\n                                  if isProc contt \\<and> isProc contf\n                                  then if v \\<noteq> 0\n then let b' = nb b ct; \\<beta> = [ct \\<mapsto> b]\n      in a\\<cdot>(Discr (contt, [], ve, b')) \\<union>\n         {((ct, \\<beta>), contt)}\n else let b' = nb b cf; \\<beta> = [cf \\<mapsto> b]\n      in a\\<cdot>(Discr (contf, [], ve, b')) \\<union>\n         {((cf, \\<beta>), contf)}\n                                  else \\<bottom>\n                              | (DP (prim.If ct cf),\n                                 DI v # contt # contf # ab # lista,\n                                 bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (prim.If ct cf), _ # list,\n                                 bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (Stop, [], bb) \\<Rightarrow> \\<bottom>\n                              | (Stop, [DI i], x, xa) \\<Rightarrow> {}\n                              | (Stop, DI i # a # lista, bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (Stop, _ # list, bb) \\<Rightarrow>\n                                  \\<bottom>)\\<cdot>\n                          (Discr\n                            fstate)| \\<lessapprox> \\<aF>\\<cdot>\n             (Discr fstate_a)\n 3. \\<And>a b cstate cstate_a.\n       \\<lbrakk>\\<And>fstate fstate_a.\n                   |fstate| \\<lessapprox> fstate_a \\<Longrightarrow>\n                   |a\\<cdot>\n                    (Discr\n                      fstate)| \\<lessapprox> \\<aF>\\<cdot>(Discr fstate_a);\n        \\<And>cstate cstate_a.\n           |cstate| \\<lessapprox> cstate_a \\<Longrightarrow>\n           |b\\<cdot>\n            (Discr cstate)| \\<lessapprox> \\<aC>\\<cdot>(Discr cstate_a);\n        |cstate| \\<lessapprox> cstate_a\\<rbrakk>\n       \\<Longrightarrow> |(\\<Lambda> cstate.\n                              case undiscr cstate of\n                              (App lab f vs, \\<beta>, ve, b) \\<Rightarrow>\n                                let f' = \\<A> f \\<beta> ve;\n                                    as =\nmap (\\<lambda>v. \\<A> v \\<beta> ve) vs;\n                                    b' = nb b lab\n                                in if isProc f'\n                                   then a\\<cdot>\n  (Discr (f', as, ve, b')) \\<union>\n  {((lab, \\<beta>), f')}\n                                   else \\<bottom>\n                              | (call.Let lab ls c', \\<beta>, ve,\n                                 ba) \\<Rightarrow>\n                                  let b' = nb ba lab;\n\\<beta>' = \\<beta>(lab \\<mapsto> b');\nve' =\n  ve ++ map_of (map (\\<lambda>(v, l). ((v, b'), \\<A> (L l) \\<beta>' ve)) ls)\n                                  in b\\<cdot>\n                                     (Discr (c', \\<beta>', ve', b')))\\<cdot>\n                          (Discr\n                            cstate)| \\<lessapprox> \\<aC>\\<cdot>\n             (Discr cstate_a)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>cstate cstate_a.\n       |cstate| \\<lessapprox> cstate_a \\<Longrightarrow>\n       |\\<bottom>\\<cdot>\n        (Discr cstate)| \\<lessapprox> \\<aC>\\<cdot>(Discr cstate_a)\n 2. \\<And>a b fstate fstate_a.\n       \\<lbrakk>\\<And>fstate fstate_a.\n                   |fstate| \\<lessapprox> fstate_a \\<Longrightarrow>\n                   |a\\<cdot>\n                    (Discr\n                      fstate)| \\<lessapprox> \\<aF>\\<cdot>(Discr fstate_a);\n        \\<And>cstate cstate_a.\n           |cstate| \\<lessapprox> cstate_a \\<Longrightarrow>\n           |b\\<cdot>\n            (Discr cstate)| \\<lessapprox> \\<aC>\\<cdot>(Discr cstate_a);\n        |fstate| \\<lessapprox> fstate_a\\<rbrakk>\n       \\<Longrightarrow> |(\\<Lambda> fstate.\n                              case undiscr fstate of\n                              (DI int, ba) \\<Rightarrow> \\<bottom>\n                              | (DC (Lambda lab vs c, \\<beta>), as, ve,\n                                 ba) \\<Rightarrow>\n                                  if length vs = length as\n                                  then let \\<beta>' = \\<beta>(lab \\<mapsto>\n       ba);\n     ve' = ve(map (\\<lambda>v. (v, ba)) vs [\\<mapsto>] as)\n in b\\<cdot>(Discr (c, \\<beta>', ve', ba))\n                                  else \\<bottom>\n                              | (DP (Plus c), [], bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (Plus c), [DI a1], bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (Plus c), [DI a1, DI a2],\n                                 bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (Plus c), [DI a1, DI a2, cnt], ve,\n                                 b) \\<Rightarrow>\n                                  if isProc cnt\n                                  then let b' = nb b c;\n     \\<beta> = [c \\<mapsto> b]\n in a\\<cdot>(Discr (cnt, [DI (a1 + a2)], ve, b')) \\<union>\n    {((c, \\<beta>), cnt)}\n                                  else \\<bottom>\n                              | (DP (Plus c),\n                                 DI a1 # DI a2 # cnt # aa # lista,\n                                 bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (Plus c), DI a1 # _ # lista,\n                                 bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (Plus c), _ # list, bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (prim.If ct cf), [], bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (prim.If ct cf), [DI v],\n                                 bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (prim.If ct cf), [DI v, contt],\n                                 bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (prim.If ct cf), [DI v, contt, contf],\n                                 ve, b) \\<Rightarrow>\n                                  if isProc contt \\<and> isProc contf\n                                  then if v \\<noteq> 0\n then let b' = nb b ct; \\<beta> = [ct \\<mapsto> b]\n      in a\\<cdot>(Discr (contt, [], ve, b')) \\<union>\n         {((ct, \\<beta>), contt)}\n else let b' = nb b cf; \\<beta> = [cf \\<mapsto> b]\n      in a\\<cdot>(Discr (contf, [], ve, b')) \\<union>\n         {((cf, \\<beta>), contf)}\n                                  else \\<bottom>\n                              | (DP (prim.If ct cf),\n                                 DI v # contt # contf # ab # lista,\n                                 bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (prim.If ct cf), _ # list,\n                                 bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (Stop, [], bb) \\<Rightarrow> \\<bottom>\n                              | (Stop, [DI i], x, xa) \\<Rightarrow> {}\n                              | (Stop, DI i # a # lista, bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (Stop, _ # list, bb) \\<Rightarrow>\n                                  \\<bottom>)\\<cdot>\n                          (Discr\n                            fstate)| \\<lessapprox> \\<aF>\\<cdot>\n             (Discr fstate_a)\n 3. \\<And>a b cstate cstate_a.\n       \\<lbrakk>\\<And>fstate fstate_a.\n                   |fstate| \\<lessapprox> fstate_a \\<Longrightarrow>\n                   |a\\<cdot>\n                    (Discr\n                      fstate)| \\<lessapprox> \\<aF>\\<cdot>(Discr fstate_a);\n        \\<And>cstate cstate_a.\n           |cstate| \\<lessapprox> cstate_a \\<Longrightarrow>\n           |b\\<cdot>\n            (Discr cstate)| \\<lessapprox> \\<aC>\\<cdot>(Discr cstate_a);\n        |cstate| \\<lessapprox> cstate_a\\<rbrakk>\n       \\<Longrightarrow> |(\\<Lambda> cstate.\n                              case undiscr cstate of\n                              (App lab f vs, \\<beta>, ve, b) \\<Rightarrow>\n                                let f' = \\<A> f \\<beta> ve;\n                                    as =\nmap (\\<lambda>v. \\<A> v \\<beta> ve) vs;\n                                    b' = nb b lab\n                                in if isProc f'\n                                   then a\\<cdot>\n  (Discr (f', as, ve, b')) \\<union>\n  {((lab, \\<beta>), f')}\n                                   else \\<bottom>\n                              | (call.Let lab ls c', \\<beta>, ve,\n                                 ba) \\<Rightarrow>\n                                  let b' = nb ba lab;\n\\<beta>' = \\<beta>(lab \\<mapsto> b');\nve' =\n  ve ++ map_of (map (\\<lambda>(v, l). ((v, b'), \\<A> (L l) \\<beta>' ve)) ls)\n                                  in b\\<cdot>\n                                     (Discr (c', \\<beta>', ve', b')))\\<cdot>\n                          (Discr\n                            cstate)| \\<lessapprox> \\<aC>\\<cdot>\n             (Discr cstate_a)", "case 2"], ["proof (state)\nthis:\n  |cstate| \\<lessapprox> cstate_a\n\ngoal (3 subgoals):\n 1. \\<And>cstate cstate_a.\n       |cstate| \\<lessapprox> cstate_a \\<Longrightarrow>\n       |\\<bottom>\\<cdot>\n        (Discr cstate)| \\<lessapprox> \\<aC>\\<cdot>(Discr cstate_a)\n 2. \\<And>a b fstate fstate_a.\n       \\<lbrakk>\\<And>fstate fstate_a.\n                   |fstate| \\<lessapprox> fstate_a \\<Longrightarrow>\n                   |a\\<cdot>\n                    (Discr\n                      fstate)| \\<lessapprox> \\<aF>\\<cdot>(Discr fstate_a);\n        \\<And>cstate cstate_a.\n           |cstate| \\<lessapprox> cstate_a \\<Longrightarrow>\n           |b\\<cdot>\n            (Discr cstate)| \\<lessapprox> \\<aC>\\<cdot>(Discr cstate_a);\n        |fstate| \\<lessapprox> fstate_a\\<rbrakk>\n       \\<Longrightarrow> |(\\<Lambda> fstate.\n                              case undiscr fstate of\n                              (DI int, ba) \\<Rightarrow> \\<bottom>\n                              | (DC (Lambda lab vs c, \\<beta>), as, ve,\n                                 ba) \\<Rightarrow>\n                                  if length vs = length as\n                                  then let \\<beta>' = \\<beta>(lab \\<mapsto>\n       ba);\n     ve' = ve(map (\\<lambda>v. (v, ba)) vs [\\<mapsto>] as)\n in b\\<cdot>(Discr (c, \\<beta>', ve', ba))\n                                  else \\<bottom>\n                              | (DP (Plus c), [], bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (Plus c), [DI a1], bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (Plus c), [DI a1, DI a2],\n                                 bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (Plus c), [DI a1, DI a2, cnt], ve,\n                                 b) \\<Rightarrow>\n                                  if isProc cnt\n                                  then let b' = nb b c;\n     \\<beta> = [c \\<mapsto> b]\n in a\\<cdot>(Discr (cnt, [DI (a1 + a2)], ve, b')) \\<union>\n    {((c, \\<beta>), cnt)}\n                                  else \\<bottom>\n                              | (DP (Plus c),\n                                 DI a1 # DI a2 # cnt # aa # lista,\n                                 bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (Plus c), DI a1 # _ # lista,\n                                 bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (Plus c), _ # list, bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (prim.If ct cf), [], bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (prim.If ct cf), [DI v],\n                                 bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (prim.If ct cf), [DI v, contt],\n                                 bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (prim.If ct cf), [DI v, contt, contf],\n                                 ve, b) \\<Rightarrow>\n                                  if isProc contt \\<and> isProc contf\n                                  then if v \\<noteq> 0\n then let b' = nb b ct; \\<beta> = [ct \\<mapsto> b]\n      in a\\<cdot>(Discr (contt, [], ve, b')) \\<union>\n         {((ct, \\<beta>), contt)}\n else let b' = nb b cf; \\<beta> = [cf \\<mapsto> b]\n      in a\\<cdot>(Discr (contf, [], ve, b')) \\<union>\n         {((cf, \\<beta>), contf)}\n                                  else \\<bottom>\n                              | (DP (prim.If ct cf),\n                                 DI v # contt # contf # ab # lista,\n                                 bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (prim.If ct cf), _ # list,\n                                 bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (Stop, [], bb) \\<Rightarrow> \\<bottom>\n                              | (Stop, [DI i], x, xa) \\<Rightarrow> {}\n                              | (Stop, DI i # a # lista, bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (Stop, _ # list, bb) \\<Rightarrow>\n                                  \\<bottom>)\\<cdot>\n                          (Discr\n                            fstate)| \\<lessapprox> \\<aF>\\<cdot>\n             (Discr fstate_a)\n 3. \\<And>a b cstate cstate_a.\n       \\<lbrakk>\\<And>fstate fstate_a.\n                   |fstate| \\<lessapprox> fstate_a \\<Longrightarrow>\n                   |a\\<cdot>\n                    (Discr\n                      fstate)| \\<lessapprox> \\<aF>\\<cdot>(Discr fstate_a);\n        \\<And>cstate cstate_a.\n           |cstate| \\<lessapprox> cstate_a \\<Longrightarrow>\n           |b\\<cdot>\n            (Discr cstate)| \\<lessapprox> \\<aC>\\<cdot>(Discr cstate_a);\n        |cstate| \\<lessapprox> cstate_a\\<rbrakk>\n       \\<Longrightarrow> |(\\<Lambda> cstate.\n                              case undiscr cstate of\n                              (App lab f vs, \\<beta>, ve, b) \\<Rightarrow>\n                                let f' = \\<A> f \\<beta> ve;\n                                    as =\nmap (\\<lambda>v. \\<A> v \\<beta> ve) vs;\n                                    b' = nb b lab\n                                in if isProc f'\n                                   then a\\<cdot>\n  (Discr (f', as, ve, b')) \\<union>\n  {((lab, \\<beta>), f')}\n                                   else \\<bottom>\n                              | (call.Let lab ls c', \\<beta>, ve,\n                                 ba) \\<Rightarrow>\n                                  let b' = nb ba lab;\n\\<beta>' = \\<beta>(lab \\<mapsto> b');\nve' =\n  ve ++ map_of (map (\\<lambda>(v, l). ((v, b'), \\<A> (L l) \\<beta>' ve)) ls)\n                                  in b\\<cdot>\n                                     (Discr (c', \\<beta>', ve', b')))\\<cdot>\n                          (Discr\n                            cstate)| \\<lessapprox> \\<aC>\\<cdot>\n             (Discr cstate_a)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. |\\<bottom>\\<cdot>\n     (Discr cstate)| \\<lessapprox> \\<aC>\\<cdot>(Discr cstate_a)", "by simp"], ["proof (state)\nthis:\n  |\\<bottom>\\<cdot>\n   (Discr cstate)| \\<lessapprox> \\<aC>\\<cdot>(Discr cstate_a)\n\ngoal (2 subgoals):\n 1. \\<And>a b fstate fstate_a.\n       \\<lbrakk>\\<And>fstate fstate_a.\n                   |fstate| \\<lessapprox> fstate_a \\<Longrightarrow>\n                   |a\\<cdot>\n                    (Discr\n                      fstate)| \\<lessapprox> \\<aF>\\<cdot>(Discr fstate_a);\n        \\<And>cstate cstate_a.\n           |cstate| \\<lessapprox> cstate_a \\<Longrightarrow>\n           |b\\<cdot>\n            (Discr cstate)| \\<lessapprox> \\<aC>\\<cdot>(Discr cstate_a);\n        |fstate| \\<lessapprox> fstate_a\\<rbrakk>\n       \\<Longrightarrow> |(\\<Lambda> fstate.\n                              case undiscr fstate of\n                              (DI int, ba) \\<Rightarrow> \\<bottom>\n                              | (DC (Lambda lab vs c, \\<beta>), as, ve,\n                                 ba) \\<Rightarrow>\n                                  if length vs = length as\n                                  then let \\<beta>' = \\<beta>(lab \\<mapsto>\n       ba);\n     ve' = ve(map (\\<lambda>v. (v, ba)) vs [\\<mapsto>] as)\n in b\\<cdot>(Discr (c, \\<beta>', ve', ba))\n                                  else \\<bottom>\n                              | (DP (Plus c), [], bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (Plus c), [DI a1], bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (Plus c), [DI a1, DI a2],\n                                 bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (Plus c), [DI a1, DI a2, cnt], ve,\n                                 b) \\<Rightarrow>\n                                  if isProc cnt\n                                  then let b' = nb b c;\n     \\<beta> = [c \\<mapsto> b]\n in a\\<cdot>(Discr (cnt, [DI (a1 + a2)], ve, b')) \\<union>\n    {((c, \\<beta>), cnt)}\n                                  else \\<bottom>\n                              | (DP (Plus c),\n                                 DI a1 # DI a2 # cnt # aa # lista,\n                                 bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (Plus c), DI a1 # _ # lista,\n                                 bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (Plus c), _ # list, bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (prim.If ct cf), [], bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (prim.If ct cf), [DI v],\n                                 bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (prim.If ct cf), [DI v, contt],\n                                 bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (prim.If ct cf), [DI v, contt, contf],\n                                 ve, b) \\<Rightarrow>\n                                  if isProc contt \\<and> isProc contf\n                                  then if v \\<noteq> 0\n then let b' = nb b ct; \\<beta> = [ct \\<mapsto> b]\n      in a\\<cdot>(Discr (contt, [], ve, b')) \\<union>\n         {((ct, \\<beta>), contt)}\n else let b' = nb b cf; \\<beta> = [cf \\<mapsto> b]\n      in a\\<cdot>(Discr (contf, [], ve, b')) \\<union>\n         {((cf, \\<beta>), contf)}\n                                  else \\<bottom>\n                              | (DP (prim.If ct cf),\n                                 DI v # contt # contf # ab # lista,\n                                 bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (prim.If ct cf), _ # list,\n                                 bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (Stop, [], bb) \\<Rightarrow> \\<bottom>\n                              | (Stop, [DI i], x, xa) \\<Rightarrow> {}\n                              | (Stop, DI i # a # lista, bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (Stop, _ # list, bb) \\<Rightarrow>\n                                  \\<bottom>)\\<cdot>\n                          (Discr\n                            fstate)| \\<lessapprox> \\<aF>\\<cdot>\n             (Discr fstate_a)\n 2. \\<And>a b cstate cstate_a.\n       \\<lbrakk>\\<And>fstate fstate_a.\n                   |fstate| \\<lessapprox> fstate_a \\<Longrightarrow>\n                   |a\\<cdot>\n                    (Discr\n                      fstate)| \\<lessapprox> \\<aF>\\<cdot>(Discr fstate_a);\n        \\<And>cstate cstate_a.\n           |cstate| \\<lessapprox> cstate_a \\<Longrightarrow>\n           |b\\<cdot>\n            (Discr cstate)| \\<lessapprox> \\<aC>\\<cdot>(Discr cstate_a);\n        |cstate| \\<lessapprox> cstate_a\\<rbrakk>\n       \\<Longrightarrow> |(\\<Lambda> cstate.\n                              case undiscr cstate of\n                              (App lab f vs, \\<beta>, ve, b) \\<Rightarrow>\n                                let f' = \\<A> f \\<beta> ve;\n                                    as =\nmap (\\<lambda>v. \\<A> v \\<beta> ve) vs;\n                                    b' = nb b lab\n                                in if isProc f'\n                                   then a\\<cdot>\n  (Discr (f', as, ve, b')) \\<union>\n  {((lab, \\<beta>), f')}\n                                   else \\<bottom>\n                              | (call.Let lab ls c', \\<beta>, ve,\n                                 ba) \\<Rightarrow>\n                                  let b' = nb ba lab;\n\\<beta>' = \\<beta>(lab \\<mapsto> b');\nve' =\n  ve ++ map_of (map (\\<lambda>(v, l). ((v, b'), \\<A> (L l) \\<beta>' ve)) ls)\n                                  in b\\<cdot>\n                                     (Discr (c', \\<beta>', ve', b')))\\<cdot>\n                          (Discr\n                            cstate)| \\<lessapprox> \\<aC>\\<cdot>\n             (Discr cstate_a)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a b fstate fstate_a.\n       \\<lbrakk>\\<And>fstate fstate_a.\n                   |fstate| \\<lessapprox> fstate_a \\<Longrightarrow>\n                   |a\\<cdot>\n                    (Discr\n                      fstate)| \\<lessapprox> \\<aF>\\<cdot>(Discr fstate_a);\n        \\<And>cstate cstate_a.\n           |cstate| \\<lessapprox> cstate_a \\<Longrightarrow>\n           |b\\<cdot>\n            (Discr cstate)| \\<lessapprox> \\<aC>\\<cdot>(Discr cstate_a);\n        |fstate| \\<lessapprox> fstate_a\\<rbrakk>\n       \\<Longrightarrow> |(\\<Lambda> fstate.\n                              case undiscr fstate of\n                              (DI int, ba) \\<Rightarrow> \\<bottom>\n                              | (DC (Lambda lab vs c, \\<beta>), as, ve,\n                                 ba) \\<Rightarrow>\n                                  if length vs = length as\n                                  then let \\<beta>' = \\<beta>(lab \\<mapsto>\n       ba);\n     ve' = ve(map (\\<lambda>v. (v, ba)) vs [\\<mapsto>] as)\n in b\\<cdot>(Discr (c, \\<beta>', ve', ba))\n                                  else \\<bottom>\n                              | (DP (Plus c), [], bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (Plus c), [DI a1], bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (Plus c), [DI a1, DI a2],\n                                 bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (Plus c), [DI a1, DI a2, cnt], ve,\n                                 b) \\<Rightarrow>\n                                  if isProc cnt\n                                  then let b' = nb b c;\n     \\<beta> = [c \\<mapsto> b]\n in a\\<cdot>(Discr (cnt, [DI (a1 + a2)], ve, b')) \\<union>\n    {((c, \\<beta>), cnt)}\n                                  else \\<bottom>\n                              | (DP (Plus c),\n                                 DI a1 # DI a2 # cnt # aa # lista,\n                                 bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (Plus c), DI a1 # _ # lista,\n                                 bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (Plus c), _ # list, bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (prim.If ct cf), [], bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (prim.If ct cf), [DI v],\n                                 bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (prim.If ct cf), [DI v, contt],\n                                 bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (prim.If ct cf), [DI v, contt, contf],\n                                 ve, b) \\<Rightarrow>\n                                  if isProc contt \\<and> isProc contf\n                                  then if v \\<noteq> 0\n then let b' = nb b ct; \\<beta> = [ct \\<mapsto> b]\n      in a\\<cdot>(Discr (contt, [], ve, b')) \\<union>\n         {((ct, \\<beta>), contt)}\n else let b' = nb b cf; \\<beta> = [cf \\<mapsto> b]\n      in a\\<cdot>(Discr (contf, [], ve, b')) \\<union>\n         {((cf, \\<beta>), contf)}\n                                  else \\<bottom>\n                              | (DP (prim.If ct cf),\n                                 DI v # contt # contf # ab # lista,\n                                 bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (prim.If ct cf), _ # list,\n                                 bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (Stop, [], bb) \\<Rightarrow> \\<bottom>\n                              | (Stop, [DI i], x, xa) \\<Rightarrow> {}\n                              | (Stop, DI i # a # lista, bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (Stop, _ # list, bb) \\<Rightarrow>\n                                  \\<bottom>)\\<cdot>\n                          (Discr\n                            fstate)| \\<lessapprox> \\<aF>\\<cdot>\n             (Discr fstate_a)\n 2. \\<And>a b cstate cstate_a.\n       \\<lbrakk>\\<And>fstate fstate_a.\n                   |fstate| \\<lessapprox> fstate_a \\<Longrightarrow>\n                   |a\\<cdot>\n                    (Discr\n                      fstate)| \\<lessapprox> \\<aF>\\<cdot>(Discr fstate_a);\n        \\<And>cstate cstate_a.\n           |cstate| \\<lessapprox> cstate_a \\<Longrightarrow>\n           |b\\<cdot>\n            (Discr cstate)| \\<lessapprox> \\<aC>\\<cdot>(Discr cstate_a);\n        |cstate| \\<lessapprox> cstate_a\\<rbrakk>\n       \\<Longrightarrow> |(\\<Lambda> cstate.\n                              case undiscr cstate of\n                              (App lab f vs, \\<beta>, ve, b) \\<Rightarrow>\n                                let f' = \\<A> f \\<beta> ve;\n                                    as =\nmap (\\<lambda>v. \\<A> v \\<beta> ve) vs;\n                                    b' = nb b lab\n                                in if isProc f'\n                                   then a\\<cdot>\n  (Discr (f', as, ve, b')) \\<union>\n  {((lab, \\<beta>), f')}\n                                   else \\<bottom>\n                              | (call.Let lab ls c', \\<beta>, ve,\n                                 ba) \\<Rightarrow>\n                                  let b' = nb ba lab;\n\\<beta>' = \\<beta>(lab \\<mapsto> b');\nve' =\n  ve ++ map_of (map (\\<lambda>(v, l). ((v, b'), \\<A> (L l) \\<beta>' ve)) ls)\n                                  in b\\<cdot>\n                                     (Discr (c', \\<beta>', ve', b')))\\<cdot>\n                          (Discr\n                            cstate)| \\<lessapprox> \\<aC>\\<cdot>\n             (Discr cstate_a)", "}"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a b fstate fstate_a.\n       \\<lbrakk>\\<And>fstate fstate_a.\n                   |fstate| \\<lessapprox> fstate_a \\<Longrightarrow>\n                   |a\\<cdot>\n                    (Discr\n                      fstate)| \\<lessapprox> \\<aF>\\<cdot>(Discr fstate_a);\n        \\<And>cstate cstate_a.\n           |cstate| \\<lessapprox> cstate_a \\<Longrightarrow>\n           |b\\<cdot>\n            (Discr cstate)| \\<lessapprox> \\<aC>\\<cdot>(Discr cstate_a);\n        |fstate| \\<lessapprox> fstate_a\\<rbrakk>\n       \\<Longrightarrow> |(\\<Lambda> fstate.\n                              case undiscr fstate of\n                              (DI int, ba) \\<Rightarrow> \\<bottom>\n                              | (DC (Lambda lab vs c, \\<beta>), as, ve,\n                                 ba) \\<Rightarrow>\n                                  if length vs = length as\n                                  then let \\<beta>' = \\<beta>(lab \\<mapsto>\n       ba);\n     ve' = ve(map (\\<lambda>v. (v, ba)) vs [\\<mapsto>] as)\n in b\\<cdot>(Discr (c, \\<beta>', ve', ba))\n                                  else \\<bottom>\n                              | (DP (Plus c), [], bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (Plus c), [DI a1], bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (Plus c), [DI a1, DI a2],\n                                 bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (Plus c), [DI a1, DI a2, cnt], ve,\n                                 b) \\<Rightarrow>\n                                  if isProc cnt\n                                  then let b' = nb b c;\n     \\<beta> = [c \\<mapsto> b]\n in a\\<cdot>(Discr (cnt, [DI (a1 + a2)], ve, b')) \\<union>\n    {((c, \\<beta>), cnt)}\n                                  else \\<bottom>\n                              | (DP (Plus c),\n                                 DI a1 # DI a2 # cnt # aa # lista,\n                                 bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (Plus c), DI a1 # _ # lista,\n                                 bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (Plus c), _ # list, bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (prim.If ct cf), [], bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (prim.If ct cf), [DI v],\n                                 bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (prim.If ct cf), [DI v, contt],\n                                 bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (prim.If ct cf), [DI v, contt, contf],\n                                 ve, b) \\<Rightarrow>\n                                  if isProc contt \\<and> isProc contf\n                                  then if v \\<noteq> 0\n then let b' = nb b ct; \\<beta> = [ct \\<mapsto> b]\n      in a\\<cdot>(Discr (contt, [], ve, b')) \\<union>\n         {((ct, \\<beta>), contt)}\n else let b' = nb b cf; \\<beta> = [cf \\<mapsto> b]\n      in a\\<cdot>(Discr (contf, [], ve, b')) \\<union>\n         {((cf, \\<beta>), contf)}\n                                  else \\<bottom>\n                              | (DP (prim.If ct cf),\n                                 DI v # contt # contf # ab # lista,\n                                 bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (prim.If ct cf), _ # list,\n                                 bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (Stop, [], bb) \\<Rightarrow> \\<bottom>\n                              | (Stop, [DI i], x, xa) \\<Rightarrow> {}\n                              | (Stop, DI i # a # lista, bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (Stop, _ # list, bb) \\<Rightarrow>\n                                  \\<bottom>)\\<cdot>\n                          (Discr\n                            fstate)| \\<lessapprox> \\<aF>\\<cdot>\n             (Discr fstate_a)\n 2. \\<And>a b cstate cstate_a.\n       \\<lbrakk>\\<And>fstate fstate_a.\n                   |fstate| \\<lessapprox> fstate_a \\<Longrightarrow>\n                   |a\\<cdot>\n                    (Discr\n                      fstate)| \\<lessapprox> \\<aF>\\<cdot>(Discr fstate_a);\n        \\<And>cstate cstate_a.\n           |cstate| \\<lessapprox> cstate_a \\<Longrightarrow>\n           |b\\<cdot>\n            (Discr cstate)| \\<lessapprox> \\<aC>\\<cdot>(Discr cstate_a);\n        |cstate| \\<lessapprox> cstate_a\\<rbrakk>\n       \\<Longrightarrow> |(\\<Lambda> cstate.\n                              case undiscr cstate of\n                              (App lab f vs, \\<beta>, ve, b) \\<Rightarrow>\n                                let f' = \\<A> f \\<beta> ve;\n                                    as =\nmap (\\<lambda>v. \\<A> v \\<beta> ve) vs;\n                                    b' = nb b lab\n                                in if isProc f'\n                                   then a\\<cdot>\n  (Discr (f', as, ve, b')) \\<union>\n  {((lab, \\<beta>), f')}\n                                   else \\<bottom>\n                              | (call.Let lab ls c', \\<beta>, ve,\n                                 ba) \\<Rightarrow>\n                                  let b' = nb ba lab;\n\\<beta>' = \\<beta>(lab \\<mapsto> b');\nve' =\n  ve ++ map_of (map (\\<lambda>(v, l). ((v, b'), \\<A> (L l) \\<beta>' ve)) ls)\n                                  in b\\<cdot>\n                                     (Discr (c', \\<beta>', ve', b')))\\<cdot>\n                          (Discr\n                            cstate)| \\<lessapprox> \\<aC>\\<cdot>\n             (Discr cstate_a)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a b fstate fstate_a.\n       \\<lbrakk>\\<And>fstate fstate_a.\n                   |fstate| \\<lessapprox> fstate_a \\<Longrightarrow>\n                   |a\\<cdot>\n                    (Discr\n                      fstate)| \\<lessapprox> \\<aF>\\<cdot>(Discr fstate_a);\n        \\<And>cstate cstate_a.\n           |cstate| \\<lessapprox> cstate_a \\<Longrightarrow>\n           |b\\<cdot>\n            (Discr cstate)| \\<lessapprox> \\<aC>\\<cdot>(Discr cstate_a);\n        |fstate| \\<lessapprox> fstate_a\\<rbrakk>\n       \\<Longrightarrow> |(\\<Lambda> fstate.\n                              case undiscr fstate of\n                              (DI int, ba) \\<Rightarrow> \\<bottom>\n                              | (DC (Lambda lab vs c, \\<beta>), as, ve,\n                                 ba) \\<Rightarrow>\n                                  if length vs = length as\n                                  then let \\<beta>' = \\<beta>(lab \\<mapsto>\n       ba);\n     ve' = ve(map (\\<lambda>v. (v, ba)) vs [\\<mapsto>] as)\n in b\\<cdot>(Discr (c, \\<beta>', ve', ba))\n                                  else \\<bottom>\n                              | (DP (Plus c), [], bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (Plus c), [DI a1], bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (Plus c), [DI a1, DI a2],\n                                 bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (Plus c), [DI a1, DI a2, cnt], ve,\n                                 b) \\<Rightarrow>\n                                  if isProc cnt\n                                  then let b' = nb b c;\n     \\<beta> = [c \\<mapsto> b]\n in a\\<cdot>(Discr (cnt, [DI (a1 + a2)], ve, b')) \\<union>\n    {((c, \\<beta>), cnt)}\n                                  else \\<bottom>\n                              | (DP (Plus c),\n                                 DI a1 # DI a2 # cnt # aa # lista,\n                                 bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (Plus c), DI a1 # _ # lista,\n                                 bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (Plus c), _ # list, bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (prim.If ct cf), [], bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (prim.If ct cf), [DI v],\n                                 bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (prim.If ct cf), [DI v, contt],\n                                 bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (prim.If ct cf), [DI v, contt, contf],\n                                 ve, b) \\<Rightarrow>\n                                  if isProc contt \\<and> isProc contf\n                                  then if v \\<noteq> 0\n then let b' = nb b ct; \\<beta> = [ct \\<mapsto> b]\n      in a\\<cdot>(Discr (contt, [], ve, b')) \\<union>\n         {((ct, \\<beta>), contt)}\n else let b' = nb b cf; \\<beta> = [cf \\<mapsto> b]\n      in a\\<cdot>(Discr (contf, [], ve, b')) \\<union>\n         {((cf, \\<beta>), contf)}\n                                  else \\<bottom>\n                              | (DP (prim.If ct cf),\n                                 DI v # contt # contf # ab # lista,\n                                 bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (prim.If ct cf), _ # list,\n                                 bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (Stop, [], bb) \\<Rightarrow> \\<bottom>\n                              | (Stop, [DI i], x, xa) \\<Rightarrow> {}\n                              | (Stop, DI i # a # lista, bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (Stop, _ # list, bb) \\<Rightarrow>\n                                  \\<bottom>)\\<cdot>\n                          (Discr\n                            fstate)| \\<lessapprox> \\<aF>\\<cdot>\n             (Discr fstate_a)\n 2. \\<And>a b cstate cstate_a.\n       \\<lbrakk>\\<And>fstate fstate_a.\n                   |fstate| \\<lessapprox> fstate_a \\<Longrightarrow>\n                   |a\\<cdot>\n                    (Discr\n                      fstate)| \\<lessapprox> \\<aF>\\<cdot>(Discr fstate_a);\n        \\<And>cstate cstate_a.\n           |cstate| \\<lessapprox> cstate_a \\<Longrightarrow>\n           |b\\<cdot>\n            (Discr cstate)| \\<lessapprox> \\<aC>\\<cdot>(Discr cstate_a);\n        |cstate| \\<lessapprox> cstate_a\\<rbrakk>\n       \\<Longrightarrow> |(\\<Lambda> cstate.\n                              case undiscr cstate of\n                              (App lab f vs, \\<beta>, ve, b) \\<Rightarrow>\n                                let f' = \\<A> f \\<beta> ve;\n                                    as =\nmap (\\<lambda>v. \\<A> v \\<beta> ve) vs;\n                                    b' = nb b lab\n                                in if isProc f'\n                                   then a\\<cdot>\n  (Discr (f', as, ve, b')) \\<union>\n  {((lab, \\<beta>), f')}\n                                   else \\<bottom>\n                              | (call.Let lab ls c', \\<beta>, ve,\n                                 ba) \\<Rightarrow>\n                                  let b' = nb ba lab;\n\\<beta>' = \\<beta>(lab \\<mapsto> b');\nve' =\n  ve ++ map_of (map (\\<lambda>(v, l). ((v, b'), \\<A> (L l) \\<beta>' ve)) ls)\n                                  in b\\<cdot>\n                                     (Discr (c', \\<beta>', ve', b')))\\<cdot>\n                          (Discr\n                            cstate)| \\<lessapprox> \\<aC>\\<cdot>\n             (Discr cstate_a)", "case (Next evalF evalC)"], ["proof (state)\nthis:\n  |?fstate| \\<lessapprox> ?fstate_a \\<Longrightarrow>\n  |evalF\\<cdot>(Discr ?fstate)| \\<lessapprox> \\<aF>\\<cdot>(Discr ?fstate_a)\n  |?cstate| \\<lessapprox> ?cstate_a \\<Longrightarrow>\n  |evalC\\<cdot>(Discr ?cstate)| \\<lessapprox> \\<aC>\\<cdot>(Discr ?cstate_a)\n\ngoal (2 subgoals):\n 1. \\<And>a b fstate fstate_a.\n       \\<lbrakk>\\<And>fstate fstate_a.\n                   |fstate| \\<lessapprox> fstate_a \\<Longrightarrow>\n                   |a\\<cdot>\n                    (Discr\n                      fstate)| \\<lessapprox> \\<aF>\\<cdot>(Discr fstate_a);\n        \\<And>cstate cstate_a.\n           |cstate| \\<lessapprox> cstate_a \\<Longrightarrow>\n           |b\\<cdot>\n            (Discr cstate)| \\<lessapprox> \\<aC>\\<cdot>(Discr cstate_a);\n        |fstate| \\<lessapprox> fstate_a\\<rbrakk>\n       \\<Longrightarrow> |(\\<Lambda> fstate.\n                              case undiscr fstate of\n                              (DI int, ba) \\<Rightarrow> \\<bottom>\n                              | (DC (Lambda lab vs c, \\<beta>), as, ve,\n                                 ba) \\<Rightarrow>\n                                  if length vs = length as\n                                  then let \\<beta>' = \\<beta>(lab \\<mapsto>\n       ba);\n     ve' = ve(map (\\<lambda>v. (v, ba)) vs [\\<mapsto>] as)\n in b\\<cdot>(Discr (c, \\<beta>', ve', ba))\n                                  else \\<bottom>\n                              | (DP (Plus c), [], bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (Plus c), [DI a1], bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (Plus c), [DI a1, DI a2],\n                                 bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (Plus c), [DI a1, DI a2, cnt], ve,\n                                 b) \\<Rightarrow>\n                                  if isProc cnt\n                                  then let b' = nb b c;\n     \\<beta> = [c \\<mapsto> b]\n in a\\<cdot>(Discr (cnt, [DI (a1 + a2)], ve, b')) \\<union>\n    {((c, \\<beta>), cnt)}\n                                  else \\<bottom>\n                              | (DP (Plus c),\n                                 DI a1 # DI a2 # cnt # aa # lista,\n                                 bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (Plus c), DI a1 # _ # lista,\n                                 bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (Plus c), _ # list, bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (prim.If ct cf), [], bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (prim.If ct cf), [DI v],\n                                 bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (prim.If ct cf), [DI v, contt],\n                                 bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (prim.If ct cf), [DI v, contt, contf],\n                                 ve, b) \\<Rightarrow>\n                                  if isProc contt \\<and> isProc contf\n                                  then if v \\<noteq> 0\n then let b' = nb b ct; \\<beta> = [ct \\<mapsto> b]\n      in a\\<cdot>(Discr (contt, [], ve, b')) \\<union>\n         {((ct, \\<beta>), contt)}\n else let b' = nb b cf; \\<beta> = [cf \\<mapsto> b]\n      in a\\<cdot>(Discr (contf, [], ve, b')) \\<union>\n         {((cf, \\<beta>), contf)}\n                                  else \\<bottom>\n                              | (DP (prim.If ct cf),\n                                 DI v # contt # contf # ab # lista,\n                                 bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (prim.If ct cf), _ # list,\n                                 bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (Stop, [], bb) \\<Rightarrow> \\<bottom>\n                              | (Stop, [DI i], x, xa) \\<Rightarrow> {}\n                              | (Stop, DI i # a # lista, bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (Stop, _ # list, bb) \\<Rightarrow>\n                                  \\<bottom>)\\<cdot>\n                          (Discr\n                            fstate)| \\<lessapprox> \\<aF>\\<cdot>\n             (Discr fstate_a)\n 2. \\<And>a b cstate cstate_a.\n       \\<lbrakk>\\<And>fstate fstate_a.\n                   |fstate| \\<lessapprox> fstate_a \\<Longrightarrow>\n                   |a\\<cdot>\n                    (Discr\n                      fstate)| \\<lessapprox> \\<aF>\\<cdot>(Discr fstate_a);\n        \\<And>cstate cstate_a.\n           |cstate| \\<lessapprox> cstate_a \\<Longrightarrow>\n           |b\\<cdot>\n            (Discr cstate)| \\<lessapprox> \\<aC>\\<cdot>(Discr cstate_a);\n        |cstate| \\<lessapprox> cstate_a\\<rbrakk>\n       \\<Longrightarrow> |(\\<Lambda> cstate.\n                              case undiscr cstate of\n                              (App lab f vs, \\<beta>, ve, b) \\<Rightarrow>\n                                let f' = \\<A> f \\<beta> ve;\n                                    as =\nmap (\\<lambda>v. \\<A> v \\<beta> ve) vs;\n                                    b' = nb b lab\n                                in if isProc f'\n                                   then a\\<cdot>\n  (Discr (f', as, ve, b')) \\<union>\n  {((lab, \\<beta>), f')}\n                                   else \\<bottom>\n                              | (call.Let lab ls c', \\<beta>, ve,\n                                 ba) \\<Rightarrow>\n                                  let b' = nb ba lab;\n\\<beta>' = \\<beta>(lab \\<mapsto> b');\nve' =\n  ve ++ map_of (map (\\<lambda>(v, l). ((v, b'), \\<A> (L l) \\<beta>' ve)) ls)\n                                  in b\\<cdot>\n                                     (Discr (c', \\<beta>', ve', b')))\\<cdot>\n                          (Discr\n                            cstate)| \\<lessapprox> \\<aC>\\<cdot>\n             (Discr cstate_a)", "{"], ["proof (state)\nthis:\n  |?fstate| \\<lessapprox> ?fstate_a \\<Longrightarrow>\n  |evalF\\<cdot>(Discr ?fstate)| \\<lessapprox> \\<aF>\\<cdot>(Discr ?fstate_a)\n  |?cstate| \\<lessapprox> ?cstate_a \\<Longrightarrow>\n  |evalC\\<cdot>(Discr ?cstate)| \\<lessapprox> \\<aC>\\<cdot>(Discr ?cstate_a)\n\ngoal (2 subgoals):\n 1. \\<And>a b fstate fstate_a.\n       \\<lbrakk>\\<And>fstate fstate_a.\n                   |fstate| \\<lessapprox> fstate_a \\<Longrightarrow>\n                   |a\\<cdot>\n                    (Discr\n                      fstate)| \\<lessapprox> \\<aF>\\<cdot>(Discr fstate_a);\n        \\<And>cstate cstate_a.\n           |cstate| \\<lessapprox> cstate_a \\<Longrightarrow>\n           |b\\<cdot>\n            (Discr cstate)| \\<lessapprox> \\<aC>\\<cdot>(Discr cstate_a);\n        |fstate| \\<lessapprox> fstate_a\\<rbrakk>\n       \\<Longrightarrow> |(\\<Lambda> fstate.\n                              case undiscr fstate of\n                              (DI int, ba) \\<Rightarrow> \\<bottom>\n                              | (DC (Lambda lab vs c, \\<beta>), as, ve,\n                                 ba) \\<Rightarrow>\n                                  if length vs = length as\n                                  then let \\<beta>' = \\<beta>(lab \\<mapsto>\n       ba);\n     ve' = ve(map (\\<lambda>v. (v, ba)) vs [\\<mapsto>] as)\n in b\\<cdot>(Discr (c, \\<beta>', ve', ba))\n                                  else \\<bottom>\n                              | (DP (Plus c), [], bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (Plus c), [DI a1], bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (Plus c), [DI a1, DI a2],\n                                 bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (Plus c), [DI a1, DI a2, cnt], ve,\n                                 b) \\<Rightarrow>\n                                  if isProc cnt\n                                  then let b' = nb b c;\n     \\<beta> = [c \\<mapsto> b]\n in a\\<cdot>(Discr (cnt, [DI (a1 + a2)], ve, b')) \\<union>\n    {((c, \\<beta>), cnt)}\n                                  else \\<bottom>\n                              | (DP (Plus c),\n                                 DI a1 # DI a2 # cnt # aa # lista,\n                                 bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (Plus c), DI a1 # _ # lista,\n                                 bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (Plus c), _ # list, bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (prim.If ct cf), [], bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (prim.If ct cf), [DI v],\n                                 bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (prim.If ct cf), [DI v, contt],\n                                 bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (prim.If ct cf), [DI v, contt, contf],\n                                 ve, b) \\<Rightarrow>\n                                  if isProc contt \\<and> isProc contf\n                                  then if v \\<noteq> 0\n then let b' = nb b ct; \\<beta> = [ct \\<mapsto> b]\n      in a\\<cdot>(Discr (contt, [], ve, b')) \\<union>\n         {((ct, \\<beta>), contt)}\n else let b' = nb b cf; \\<beta> = [cf \\<mapsto> b]\n      in a\\<cdot>(Discr (contf, [], ve, b')) \\<union>\n         {((cf, \\<beta>), contf)}\n                                  else \\<bottom>\n                              | (DP (prim.If ct cf),\n                                 DI v # contt # contf # ab # lista,\n                                 bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (prim.If ct cf), _ # list,\n                                 bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (Stop, [], bb) \\<Rightarrow> \\<bottom>\n                              | (Stop, [DI i], x, xa) \\<Rightarrow> {}\n                              | (Stop, DI i # a # lista, bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (Stop, _ # list, bb) \\<Rightarrow>\n                                  \\<bottom>)\\<cdot>\n                          (Discr\n                            fstate)| \\<lessapprox> \\<aF>\\<cdot>\n             (Discr fstate_a)\n 2. \\<And>a b cstate cstate_a.\n       \\<lbrakk>\\<And>fstate fstate_a.\n                   |fstate| \\<lessapprox> fstate_a \\<Longrightarrow>\n                   |a\\<cdot>\n                    (Discr\n                      fstate)| \\<lessapprox> \\<aF>\\<cdot>(Discr fstate_a);\n        \\<And>cstate cstate_a.\n           |cstate| \\<lessapprox> cstate_a \\<Longrightarrow>\n           |b\\<cdot>\n            (Discr cstate)| \\<lessapprox> \\<aC>\\<cdot>(Discr cstate_a);\n        |cstate| \\<lessapprox> cstate_a\\<rbrakk>\n       \\<Longrightarrow> |(\\<Lambda> cstate.\n                              case undiscr cstate of\n                              (App lab f vs, \\<beta>, ve, b) \\<Rightarrow>\n                                let f' = \\<A> f \\<beta> ve;\n                                    as =\nmap (\\<lambda>v. \\<A> v \\<beta> ve) vs;\n                                    b' = nb b lab\n                                in if isProc f'\n                                   then a\\<cdot>\n  (Discr (f', as, ve, b')) \\<union>\n  {((lab, \\<beta>), f')}\n                                   else \\<bottom>\n                              | (call.Let lab ls c', \\<beta>, ve,\n                                 ba) \\<Rightarrow>\n                                  let b' = nb ba lab;\n\\<beta>' = \\<beta>(lab \\<mapsto> b');\nve' =\n  ve ++ map_of (map (\\<lambda>(v, l). ((v, b'), \\<A> (L l) \\<beta>' ve)) ls)\n                                  in b\\<cdot>\n                                     (Discr (c', \\<beta>', ve', b')))\\<cdot>\n                          (Discr\n                            cstate)| \\<lessapprox> \\<aC>\\<cdot>\n             (Discr cstate_a)", "case 1"], ["proof (state)\nthis:\n  |fstate| \\<lessapprox> fstate_a\n\ngoal (2 subgoals):\n 1. \\<And>a b fstate fstate_a.\n       \\<lbrakk>\\<And>fstate fstate_a.\n                   |fstate| \\<lessapprox> fstate_a \\<Longrightarrow>\n                   |a\\<cdot>\n                    (Discr\n                      fstate)| \\<lessapprox> \\<aF>\\<cdot>(Discr fstate_a);\n        \\<And>cstate cstate_a.\n           |cstate| \\<lessapprox> cstate_a \\<Longrightarrow>\n           |b\\<cdot>\n            (Discr cstate)| \\<lessapprox> \\<aC>\\<cdot>(Discr cstate_a);\n        |fstate| \\<lessapprox> fstate_a\\<rbrakk>\n       \\<Longrightarrow> |(\\<Lambda> fstate.\n                              case undiscr fstate of\n                              (DI int, ba) \\<Rightarrow> \\<bottom>\n                              | (DC (Lambda lab vs c, \\<beta>), as, ve,\n                                 ba) \\<Rightarrow>\n                                  if length vs = length as\n                                  then let \\<beta>' = \\<beta>(lab \\<mapsto>\n       ba);\n     ve' = ve(map (\\<lambda>v. (v, ba)) vs [\\<mapsto>] as)\n in b\\<cdot>(Discr (c, \\<beta>', ve', ba))\n                                  else \\<bottom>\n                              | (DP (Plus c), [], bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (Plus c), [DI a1], bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (Plus c), [DI a1, DI a2],\n                                 bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (Plus c), [DI a1, DI a2, cnt], ve,\n                                 b) \\<Rightarrow>\n                                  if isProc cnt\n                                  then let b' = nb b c;\n     \\<beta> = [c \\<mapsto> b]\n in a\\<cdot>(Discr (cnt, [DI (a1 + a2)], ve, b')) \\<union>\n    {((c, \\<beta>), cnt)}\n                                  else \\<bottom>\n                              | (DP (Plus c),\n                                 DI a1 # DI a2 # cnt # aa # lista,\n                                 bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (Plus c), DI a1 # _ # lista,\n                                 bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (Plus c), _ # list, bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (prim.If ct cf), [], bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (prim.If ct cf), [DI v],\n                                 bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (prim.If ct cf), [DI v, contt],\n                                 bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (prim.If ct cf), [DI v, contt, contf],\n                                 ve, b) \\<Rightarrow>\n                                  if isProc contt \\<and> isProc contf\n                                  then if v \\<noteq> 0\n then let b' = nb b ct; \\<beta> = [ct \\<mapsto> b]\n      in a\\<cdot>(Discr (contt, [], ve, b')) \\<union>\n         {((ct, \\<beta>), contt)}\n else let b' = nb b cf; \\<beta> = [cf \\<mapsto> b]\n      in a\\<cdot>(Discr (contf, [], ve, b')) \\<union>\n         {((cf, \\<beta>), contf)}\n                                  else \\<bottom>\n                              | (DP (prim.If ct cf),\n                                 DI v # contt # contf # ab # lista,\n                                 bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (prim.If ct cf), _ # list,\n                                 bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (Stop, [], bb) \\<Rightarrow> \\<bottom>\n                              | (Stop, [DI i], x, xa) \\<Rightarrow> {}\n                              | (Stop, DI i # a # lista, bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (Stop, _ # list, bb) \\<Rightarrow>\n                                  \\<bottom>)\\<cdot>\n                          (Discr\n                            fstate)| \\<lessapprox> \\<aF>\\<cdot>\n             (Discr fstate_a)\n 2. \\<And>a b cstate cstate_a.\n       \\<lbrakk>\\<And>fstate fstate_a.\n                   |fstate| \\<lessapprox> fstate_a \\<Longrightarrow>\n                   |a\\<cdot>\n                    (Discr\n                      fstate)| \\<lessapprox> \\<aF>\\<cdot>(Discr fstate_a);\n        \\<And>cstate cstate_a.\n           |cstate| \\<lessapprox> cstate_a \\<Longrightarrow>\n           |b\\<cdot>\n            (Discr cstate)| \\<lessapprox> \\<aC>\\<cdot>(Discr cstate_a);\n        |cstate| \\<lessapprox> cstate_a\\<rbrakk>\n       \\<Longrightarrow> |(\\<Lambda> cstate.\n                              case undiscr cstate of\n                              (App lab f vs, \\<beta>, ve, b) \\<Rightarrow>\n                                let f' = \\<A> f \\<beta> ve;\n                                    as =\nmap (\\<lambda>v. \\<A> v \\<beta> ve) vs;\n                                    b' = nb b lab\n                                in if isProc f'\n                                   then a\\<cdot>\n  (Discr (f', as, ve, b')) \\<union>\n  {((lab, \\<beta>), f')}\n                                   else \\<bottom>\n                              | (call.Let lab ls c', \\<beta>, ve,\n                                 ba) \\<Rightarrow>\n                                  let b' = nb ba lab;\n\\<beta>' = \\<beta>(lab \\<mapsto> b');\nve' =\n  ve ++ map_of (map (\\<lambda>(v, l). ((v, b'), \\<A> (L l) \\<beta>' ve)) ls)\n                                  in b\\<cdot>\n                                     (Discr (c', \\<beta>', ve', b')))\\<cdot>\n                          (Discr\n                            cstate)| \\<lessapprox> \\<aC>\\<cdot>\n             (Discr cstate_a)", "obtain d ds ve b where fstate: \"fstate = (d,ds,ve,b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>d ds ve b.\n        fstate = (d, ds, ve, b) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases fstate, auto)"], ["proof (state)\nthis:\n  fstate = (d, ds, ve, b)\n\ngoal (2 subgoals):\n 1. \\<And>a b fstate fstate_a.\n       \\<lbrakk>\\<And>fstate fstate_a.\n                   |fstate| \\<lessapprox> fstate_a \\<Longrightarrow>\n                   |a\\<cdot>\n                    (Discr\n                      fstate)| \\<lessapprox> \\<aF>\\<cdot>(Discr fstate_a);\n        \\<And>cstate cstate_a.\n           |cstate| \\<lessapprox> cstate_a \\<Longrightarrow>\n           |b\\<cdot>\n            (Discr cstate)| \\<lessapprox> \\<aC>\\<cdot>(Discr cstate_a);\n        |fstate| \\<lessapprox> fstate_a\\<rbrakk>\n       \\<Longrightarrow> |(\\<Lambda> fstate.\n                              case undiscr fstate of\n                              (DI int, ba) \\<Rightarrow> \\<bottom>\n                              | (DC (Lambda lab vs c, \\<beta>), as, ve,\n                                 ba) \\<Rightarrow>\n                                  if length vs = length as\n                                  then let \\<beta>' = \\<beta>(lab \\<mapsto>\n       ba);\n     ve' = ve(map (\\<lambda>v. (v, ba)) vs [\\<mapsto>] as)\n in b\\<cdot>(Discr (c, \\<beta>', ve', ba))\n                                  else \\<bottom>\n                              | (DP (Plus c), [], bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (Plus c), [DI a1], bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (Plus c), [DI a1, DI a2],\n                                 bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (Plus c), [DI a1, DI a2, cnt], ve,\n                                 b) \\<Rightarrow>\n                                  if isProc cnt\n                                  then let b' = nb b c;\n     \\<beta> = [c \\<mapsto> b]\n in a\\<cdot>(Discr (cnt, [DI (a1 + a2)], ve, b')) \\<union>\n    {((c, \\<beta>), cnt)}\n                                  else \\<bottom>\n                              | (DP (Plus c),\n                                 DI a1 # DI a2 # cnt # aa # lista,\n                                 bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (Plus c), DI a1 # _ # lista,\n                                 bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (Plus c), _ # list, bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (prim.If ct cf), [], bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (prim.If ct cf), [DI v],\n                                 bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (prim.If ct cf), [DI v, contt],\n                                 bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (prim.If ct cf), [DI v, contt, contf],\n                                 ve, b) \\<Rightarrow>\n                                  if isProc contt \\<and> isProc contf\n                                  then if v \\<noteq> 0\n then let b' = nb b ct; \\<beta> = [ct \\<mapsto> b]\n      in a\\<cdot>(Discr (contt, [], ve, b')) \\<union>\n         {((ct, \\<beta>), contt)}\n else let b' = nb b cf; \\<beta> = [cf \\<mapsto> b]\n      in a\\<cdot>(Discr (contf, [], ve, b')) \\<union>\n         {((cf, \\<beta>), contf)}\n                                  else \\<bottom>\n                              | (DP (prim.If ct cf),\n                                 DI v # contt # contf # ab # lista,\n                                 bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (prim.If ct cf), _ # list,\n                                 bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (Stop, [], bb) \\<Rightarrow> \\<bottom>\n                              | (Stop, [DI i], x, xa) \\<Rightarrow> {}\n                              | (Stop, DI i # a # lista, bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (Stop, _ # list, bb) \\<Rightarrow>\n                                  \\<bottom>)\\<cdot>\n                          (Discr\n                            fstate)| \\<lessapprox> \\<aF>\\<cdot>\n             (Discr fstate_a)\n 2. \\<And>a b cstate cstate_a.\n       \\<lbrakk>\\<And>fstate fstate_a.\n                   |fstate| \\<lessapprox> fstate_a \\<Longrightarrow>\n                   |a\\<cdot>\n                    (Discr\n                      fstate)| \\<lessapprox> \\<aF>\\<cdot>(Discr fstate_a);\n        \\<And>cstate cstate_a.\n           |cstate| \\<lessapprox> cstate_a \\<Longrightarrow>\n           |b\\<cdot>\n            (Discr cstate)| \\<lessapprox> \\<aC>\\<cdot>(Discr cstate_a);\n        |cstate| \\<lessapprox> cstate_a\\<rbrakk>\n       \\<Longrightarrow> |(\\<Lambda> cstate.\n                              case undiscr cstate of\n                              (App lab f vs, \\<beta>, ve, b) \\<Rightarrow>\n                                let f' = \\<A> f \\<beta> ve;\n                                    as =\nmap (\\<lambda>v. \\<A> v \\<beta> ve) vs;\n                                    b' = nb b lab\n                                in if isProc f'\n                                   then a\\<cdot>\n  (Discr (f', as, ve, b')) \\<union>\n  {((lab, \\<beta>), f')}\n                                   else \\<bottom>\n                              | (call.Let lab ls c', \\<beta>, ve,\n                                 ba) \\<Rightarrow>\n                                  let b' = nb ba lab;\n\\<beta>' = \\<beta>(lab \\<mapsto> b');\nve' =\n  ve ++ map_of (map (\\<lambda>(v, l). ((v, b'), \\<A> (L l) \\<beta>' ve)) ls)\n                                  in b\\<cdot>\n                                     (Discr (c', \\<beta>', ve', b')))\\<cdot>\n                          (Discr\n                            cstate)| \\<lessapprox> \\<aC>\\<cdot>\n             (Discr cstate_a)", "moreover"], ["proof (state)\nthis:\n  fstate = (d, ds, ve, b)\n\ngoal (2 subgoals):\n 1. \\<And>a b fstate fstate_a.\n       \\<lbrakk>\\<And>fstate fstate_a.\n                   |fstate| \\<lessapprox> fstate_a \\<Longrightarrow>\n                   |a\\<cdot>\n                    (Discr\n                      fstate)| \\<lessapprox> \\<aF>\\<cdot>(Discr fstate_a);\n        \\<And>cstate cstate_a.\n           |cstate| \\<lessapprox> cstate_a \\<Longrightarrow>\n           |b\\<cdot>\n            (Discr cstate)| \\<lessapprox> \\<aC>\\<cdot>(Discr cstate_a);\n        |fstate| \\<lessapprox> fstate_a\\<rbrakk>\n       \\<Longrightarrow> |(\\<Lambda> fstate.\n                              case undiscr fstate of\n                              (DI int, ba) \\<Rightarrow> \\<bottom>\n                              | (DC (Lambda lab vs c, \\<beta>), as, ve,\n                                 ba) \\<Rightarrow>\n                                  if length vs = length as\n                                  then let \\<beta>' = \\<beta>(lab \\<mapsto>\n       ba);\n     ve' = ve(map (\\<lambda>v. (v, ba)) vs [\\<mapsto>] as)\n in b\\<cdot>(Discr (c, \\<beta>', ve', ba))\n                                  else \\<bottom>\n                              | (DP (Plus c), [], bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (Plus c), [DI a1], bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (Plus c), [DI a1, DI a2],\n                                 bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (Plus c), [DI a1, DI a2, cnt], ve,\n                                 b) \\<Rightarrow>\n                                  if isProc cnt\n                                  then let b' = nb b c;\n     \\<beta> = [c \\<mapsto> b]\n in a\\<cdot>(Discr (cnt, [DI (a1 + a2)], ve, b')) \\<union>\n    {((c, \\<beta>), cnt)}\n                                  else \\<bottom>\n                              | (DP (Plus c),\n                                 DI a1 # DI a2 # cnt # aa # lista,\n                                 bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (Plus c), DI a1 # _ # lista,\n                                 bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (Plus c), _ # list, bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (prim.If ct cf), [], bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (prim.If ct cf), [DI v],\n                                 bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (prim.If ct cf), [DI v, contt],\n                                 bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (prim.If ct cf), [DI v, contt, contf],\n                                 ve, b) \\<Rightarrow>\n                                  if isProc contt \\<and> isProc contf\n                                  then if v \\<noteq> 0\n then let b' = nb b ct; \\<beta> = [ct \\<mapsto> b]\n      in a\\<cdot>(Discr (contt, [], ve, b')) \\<union>\n         {((ct, \\<beta>), contt)}\n else let b' = nb b cf; \\<beta> = [cf \\<mapsto> b]\n      in a\\<cdot>(Discr (contf, [], ve, b')) \\<union>\n         {((cf, \\<beta>), contf)}\n                                  else \\<bottom>\n                              | (DP (prim.If ct cf),\n                                 DI v # contt # contf # ab # lista,\n                                 bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (prim.If ct cf), _ # list,\n                                 bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (Stop, [], bb) \\<Rightarrow> \\<bottom>\n                              | (Stop, [DI i], x, xa) \\<Rightarrow> {}\n                              | (Stop, DI i # a # lista, bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (Stop, _ # list, bb) \\<Rightarrow>\n                                  \\<bottom>)\\<cdot>\n                          (Discr\n                            fstate)| \\<lessapprox> \\<aF>\\<cdot>\n             (Discr fstate_a)\n 2. \\<And>a b cstate cstate_a.\n       \\<lbrakk>\\<And>fstate fstate_a.\n                   |fstate| \\<lessapprox> fstate_a \\<Longrightarrow>\n                   |a\\<cdot>\n                    (Discr\n                      fstate)| \\<lessapprox> \\<aF>\\<cdot>(Discr fstate_a);\n        \\<And>cstate cstate_a.\n           |cstate| \\<lessapprox> cstate_a \\<Longrightarrow>\n           |b\\<cdot>\n            (Discr cstate)| \\<lessapprox> \\<aC>\\<cdot>(Discr cstate_a);\n        |cstate| \\<lessapprox> cstate_a\\<rbrakk>\n       \\<Longrightarrow> |(\\<Lambda> cstate.\n                              case undiscr cstate of\n                              (App lab f vs, \\<beta>, ve, b) \\<Rightarrow>\n                                let f' = \\<A> f \\<beta> ve;\n                                    as =\nmap (\\<lambda>v. \\<A> v \\<beta> ve) vs;\n                                    b' = nb b lab\n                                in if isProc f'\n                                   then a\\<cdot>\n  (Discr (f', as, ve, b')) \\<union>\n  {((lab, \\<beta>), f')}\n                                   else \\<bottom>\n                              | (call.Let lab ls c', \\<beta>, ve,\n                                 ba) \\<Rightarrow>\n                                  let b' = nb ba lab;\n\\<beta>' = \\<beta>(lab \\<mapsto> b');\nve' =\n  ve ++ map_of (map (\\<lambda>(v, l). ((v, b'), \\<A> (L l) \\<beta>' ve)) ls)\n                                  in b\\<cdot>\n                                     (Discr (c', \\<beta>', ve', b')))\\<cdot>\n                          (Discr\n                            cstate)| \\<lessapprox> \\<aC>\\<cdot>\n             (Discr cstate_a)", "obtain proc ds_a ve_a b_a where fstate_a: \"fstate_a = (proc,ds_a,ve_a,b_a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>proc ds_a ve_a b_a.\n        fstate_a = (proc, ds_a, ve_a, b_a) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases fstate_a, auto)"], ["proof (state)\nthis:\n  fstate_a = (proc, ds_a, ve_a, b_a)\n\ngoal (2 subgoals):\n 1. \\<And>a b fstate fstate_a.\n       \\<lbrakk>\\<And>fstate fstate_a.\n                   |fstate| \\<lessapprox> fstate_a \\<Longrightarrow>\n                   |a\\<cdot>\n                    (Discr\n                      fstate)| \\<lessapprox> \\<aF>\\<cdot>(Discr fstate_a);\n        \\<And>cstate cstate_a.\n           |cstate| \\<lessapprox> cstate_a \\<Longrightarrow>\n           |b\\<cdot>\n            (Discr cstate)| \\<lessapprox> \\<aC>\\<cdot>(Discr cstate_a);\n        |fstate| \\<lessapprox> fstate_a\\<rbrakk>\n       \\<Longrightarrow> |(\\<Lambda> fstate.\n                              case undiscr fstate of\n                              (DI int, ba) \\<Rightarrow> \\<bottom>\n                              | (DC (Lambda lab vs c, \\<beta>), as, ve,\n                                 ba) \\<Rightarrow>\n                                  if length vs = length as\n                                  then let \\<beta>' = \\<beta>(lab \\<mapsto>\n       ba);\n     ve' = ve(map (\\<lambda>v. (v, ba)) vs [\\<mapsto>] as)\n in b\\<cdot>(Discr (c, \\<beta>', ve', ba))\n                                  else \\<bottom>\n                              | (DP (Plus c), [], bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (Plus c), [DI a1], bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (Plus c), [DI a1, DI a2],\n                                 bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (Plus c), [DI a1, DI a2, cnt], ve,\n                                 b) \\<Rightarrow>\n                                  if isProc cnt\n                                  then let b' = nb b c;\n     \\<beta> = [c \\<mapsto> b]\n in a\\<cdot>(Discr (cnt, [DI (a1 + a2)], ve, b')) \\<union>\n    {((c, \\<beta>), cnt)}\n                                  else \\<bottom>\n                              | (DP (Plus c),\n                                 DI a1 # DI a2 # cnt # aa # lista,\n                                 bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (Plus c), DI a1 # _ # lista,\n                                 bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (Plus c), _ # list, bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (prim.If ct cf), [], bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (prim.If ct cf), [DI v],\n                                 bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (prim.If ct cf), [DI v, contt],\n                                 bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (prim.If ct cf), [DI v, contt, contf],\n                                 ve, b) \\<Rightarrow>\n                                  if isProc contt \\<and> isProc contf\n                                  then if v \\<noteq> 0\n then let b' = nb b ct; \\<beta> = [ct \\<mapsto> b]\n      in a\\<cdot>(Discr (contt, [], ve, b')) \\<union>\n         {((ct, \\<beta>), contt)}\n else let b' = nb b cf; \\<beta> = [cf \\<mapsto> b]\n      in a\\<cdot>(Discr (contf, [], ve, b')) \\<union>\n         {((cf, \\<beta>), contf)}\n                                  else \\<bottom>\n                              | (DP (prim.If ct cf),\n                                 DI v # contt # contf # ab # lista,\n                                 bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (prim.If ct cf), _ # list,\n                                 bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (Stop, [], bb) \\<Rightarrow> \\<bottom>\n                              | (Stop, [DI i], x, xa) \\<Rightarrow> {}\n                              | (Stop, DI i # a # lista, bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (Stop, _ # list, bb) \\<Rightarrow>\n                                  \\<bottom>)\\<cdot>\n                          (Discr\n                            fstate)| \\<lessapprox> \\<aF>\\<cdot>\n             (Discr fstate_a)\n 2. \\<And>a b cstate cstate_a.\n       \\<lbrakk>\\<And>fstate fstate_a.\n                   |fstate| \\<lessapprox> fstate_a \\<Longrightarrow>\n                   |a\\<cdot>\n                    (Discr\n                      fstate)| \\<lessapprox> \\<aF>\\<cdot>(Discr fstate_a);\n        \\<And>cstate cstate_a.\n           |cstate| \\<lessapprox> cstate_a \\<Longrightarrow>\n           |b\\<cdot>\n            (Discr cstate)| \\<lessapprox> \\<aC>\\<cdot>(Discr cstate_a);\n        |cstate| \\<lessapprox> cstate_a\\<rbrakk>\n       \\<Longrightarrow> |(\\<Lambda> cstate.\n                              case undiscr cstate of\n                              (App lab f vs, \\<beta>, ve, b) \\<Rightarrow>\n                                let f' = \\<A> f \\<beta> ve;\n                                    as =\nmap (\\<lambda>v. \\<A> v \\<beta> ve) vs;\n                                    b' = nb b lab\n                                in if isProc f'\n                                   then a\\<cdot>\n  (Discr (f', as, ve, b')) \\<union>\n  {((lab, \\<beta>), f')}\n                                   else \\<bottom>\n                              | (call.Let lab ls c', \\<beta>, ve,\n                                 ba) \\<Rightarrow>\n                                  let b' = nb ba lab;\n\\<beta>' = \\<beta>(lab \\<mapsto> b');\nve' =\n  ve ++ map_of (map (\\<lambda>(v, l). ((v, b'), \\<A> (L l) \\<beta>' ve)) ls)\n                                  in b\\<cdot>\n                                     (Discr (c', \\<beta>', ve', b')))\\<cdot>\n                          (Discr\n                            cstate)| \\<lessapprox> \\<aC>\\<cdot>\n             (Discr cstate_a)", "ultimately"], ["proof (chain)\npicking this:\n  fstate = (d, ds, ve, b)\n  fstate_a = (proc, ds_a, ve_a, b_a)", "have abs_d: \"the_elem |d| = proc\"\n   and abs_ds: \"map abs_d ds \\<lessapprox> ds_a\"\n   and abs_ve: \"|ve| \\<lessapprox> ve_a\"\n   and abs_b: \"|b| = b_a\""], ["proof (prove)\nusing this:\n  fstate = (d, ds, ve, b)\n  fstate_a = (proc, ds_a, ve_a, b_a)\n\ngoal (1 subgoal):\n 1. (the_elem |d| = proc &&& map AbsCFCorrect.abs ds \\<lessapprox> ds_a) &&&\n    |ve| \\<lessapprox> ve_a &&& |b| = b_a", "using 1"], ["proof (prove)\nusing this:\n  fstate = (d, ds, ve, b)\n  fstate_a = (proc, ds_a, ve_a, b_a)\n  |fstate| \\<lessapprox> fstate_a\n\ngoal (1 subgoal):\n 1. (the_elem |d| = proc &&& map AbsCFCorrect.abs ds \\<lessapprox> ds_a) &&&\n    |ve| \\<lessapprox> ve_a &&& |b| = b_a", "by (auto elim:fstate_approx.cases)"], ["proof (state)\nthis:\n  the_elem |d| = proc\n  map AbsCFCorrect.abs ds \\<lessapprox> ds_a\n  |ve| \\<lessapprox> ve_a\n  |b| = b_a\n\ngoal (2 subgoals):\n 1. \\<And>a b fstate fstate_a.\n       \\<lbrakk>\\<And>fstate fstate_a.\n                   |fstate| \\<lessapprox> fstate_a \\<Longrightarrow>\n                   |a\\<cdot>\n                    (Discr\n                      fstate)| \\<lessapprox> \\<aF>\\<cdot>(Discr fstate_a);\n        \\<And>cstate cstate_a.\n           |cstate| \\<lessapprox> cstate_a \\<Longrightarrow>\n           |b\\<cdot>\n            (Discr cstate)| \\<lessapprox> \\<aC>\\<cdot>(Discr cstate_a);\n        |fstate| \\<lessapprox> fstate_a\\<rbrakk>\n       \\<Longrightarrow> |(\\<Lambda> fstate.\n                              case undiscr fstate of\n                              (DI int, ba) \\<Rightarrow> \\<bottom>\n                              | (DC (Lambda lab vs c, \\<beta>), as, ve,\n                                 ba) \\<Rightarrow>\n                                  if length vs = length as\n                                  then let \\<beta>' = \\<beta>(lab \\<mapsto>\n       ba);\n     ve' = ve(map (\\<lambda>v. (v, ba)) vs [\\<mapsto>] as)\n in b\\<cdot>(Discr (c, \\<beta>', ve', ba))\n                                  else \\<bottom>\n                              | (DP (Plus c), [], bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (Plus c), [DI a1], bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (Plus c), [DI a1, DI a2],\n                                 bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (Plus c), [DI a1, DI a2, cnt], ve,\n                                 b) \\<Rightarrow>\n                                  if isProc cnt\n                                  then let b' = nb b c;\n     \\<beta> = [c \\<mapsto> b]\n in a\\<cdot>(Discr (cnt, [DI (a1 + a2)], ve, b')) \\<union>\n    {((c, \\<beta>), cnt)}\n                                  else \\<bottom>\n                              | (DP (Plus c),\n                                 DI a1 # DI a2 # cnt # aa # lista,\n                                 bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (Plus c), DI a1 # _ # lista,\n                                 bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (Plus c), _ # list, bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (prim.If ct cf), [], bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (prim.If ct cf), [DI v],\n                                 bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (prim.If ct cf), [DI v, contt],\n                                 bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (prim.If ct cf), [DI v, contt, contf],\n                                 ve, b) \\<Rightarrow>\n                                  if isProc contt \\<and> isProc contf\n                                  then if v \\<noteq> 0\n then let b' = nb b ct; \\<beta> = [ct \\<mapsto> b]\n      in a\\<cdot>(Discr (contt, [], ve, b')) \\<union>\n         {((ct, \\<beta>), contt)}\n else let b' = nb b cf; \\<beta> = [cf \\<mapsto> b]\n      in a\\<cdot>(Discr (contf, [], ve, b')) \\<union>\n         {((cf, \\<beta>), contf)}\n                                  else \\<bottom>\n                              | (DP (prim.If ct cf),\n                                 DI v # contt # contf # ab # lista,\n                                 bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (prim.If ct cf), _ # list,\n                                 bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (Stop, [], bb) \\<Rightarrow> \\<bottom>\n                              | (Stop, [DI i], x, xa) \\<Rightarrow> {}\n                              | (Stop, DI i # a # lista, bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (Stop, _ # list, bb) \\<Rightarrow>\n                                  \\<bottom>)\\<cdot>\n                          (Discr\n                            fstate)| \\<lessapprox> \\<aF>\\<cdot>\n             (Discr fstate_a)\n 2. \\<And>a b cstate cstate_a.\n       \\<lbrakk>\\<And>fstate fstate_a.\n                   |fstate| \\<lessapprox> fstate_a \\<Longrightarrow>\n                   |a\\<cdot>\n                    (Discr\n                      fstate)| \\<lessapprox> \\<aF>\\<cdot>(Discr fstate_a);\n        \\<And>cstate cstate_a.\n           |cstate| \\<lessapprox> cstate_a \\<Longrightarrow>\n           |b\\<cdot>\n            (Discr cstate)| \\<lessapprox> \\<aC>\\<cdot>(Discr cstate_a);\n        |cstate| \\<lessapprox> cstate_a\\<rbrakk>\n       \\<Longrightarrow> |(\\<Lambda> cstate.\n                              case undiscr cstate of\n                              (App lab f vs, \\<beta>, ve, b) \\<Rightarrow>\n                                let f' = \\<A> f \\<beta> ve;\n                                    as =\nmap (\\<lambda>v. \\<A> v \\<beta> ve) vs;\n                                    b' = nb b lab\n                                in if isProc f'\n                                   then a\\<cdot>\n  (Discr (f', as, ve, b')) \\<union>\n  {((lab, \\<beta>), f')}\n                                   else \\<bottom>\n                              | (call.Let lab ls c', \\<beta>, ve,\n                                 ba) \\<Rightarrow>\n                                  let b' = nb ba lab;\n\\<beta>' = \\<beta>(lab \\<mapsto> b');\nve' =\n  ve ++ map_of (map (\\<lambda>(v, l). ((v, b'), \\<A> (L l) \\<beta>' ve)) ls)\n                                  in b\\<cdot>\n                                     (Discr (c', \\<beta>', ve', b')))\\<cdot>\n                          (Discr\n                            cstate)| \\<lessapprox> \\<aC>\\<cdot>\n             (Discr cstate_a)", "from abs_ds"], ["proof (chain)\npicking this:\n  map AbsCFCorrect.abs ds \\<lessapprox> ds_a", "have dslength: \"length ds = length ds_a\""], ["proof (prove)\nusing this:\n  map AbsCFCorrect.abs ds \\<lessapprox> ds_a\n\ngoal (1 subgoal):\n 1. length ds = length ds_a", "by (auto simp add:ds_approx_def dest!:list_all2_lengthD)"], ["proof (state)\nthis:\n  length ds = length ds_a\n\ngoal (2 subgoals):\n 1. \\<And>a b fstate fstate_a.\n       \\<lbrakk>\\<And>fstate fstate_a.\n                   |fstate| \\<lessapprox> fstate_a \\<Longrightarrow>\n                   |a\\<cdot>\n                    (Discr\n                      fstate)| \\<lessapprox> \\<aF>\\<cdot>(Discr fstate_a);\n        \\<And>cstate cstate_a.\n           |cstate| \\<lessapprox> cstate_a \\<Longrightarrow>\n           |b\\<cdot>\n            (Discr cstate)| \\<lessapprox> \\<aC>\\<cdot>(Discr cstate_a);\n        |fstate| \\<lessapprox> fstate_a\\<rbrakk>\n       \\<Longrightarrow> |(\\<Lambda> fstate.\n                              case undiscr fstate of\n                              (DI int, ba) \\<Rightarrow> \\<bottom>\n                              | (DC (Lambda lab vs c, \\<beta>), as, ve,\n                                 ba) \\<Rightarrow>\n                                  if length vs = length as\n                                  then let \\<beta>' = \\<beta>(lab \\<mapsto>\n       ba);\n     ve' = ve(map (\\<lambda>v. (v, ba)) vs [\\<mapsto>] as)\n in b\\<cdot>(Discr (c, \\<beta>', ve', ba))\n                                  else \\<bottom>\n                              | (DP (Plus c), [], bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (Plus c), [DI a1], bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (Plus c), [DI a1, DI a2],\n                                 bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (Plus c), [DI a1, DI a2, cnt], ve,\n                                 b) \\<Rightarrow>\n                                  if isProc cnt\n                                  then let b' = nb b c;\n     \\<beta> = [c \\<mapsto> b]\n in a\\<cdot>(Discr (cnt, [DI (a1 + a2)], ve, b')) \\<union>\n    {((c, \\<beta>), cnt)}\n                                  else \\<bottom>\n                              | (DP (Plus c),\n                                 DI a1 # DI a2 # cnt # aa # lista,\n                                 bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (Plus c), DI a1 # _ # lista,\n                                 bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (Plus c), _ # list, bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (prim.If ct cf), [], bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (prim.If ct cf), [DI v],\n                                 bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (prim.If ct cf), [DI v, contt],\n                                 bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (prim.If ct cf), [DI v, contt, contf],\n                                 ve, b) \\<Rightarrow>\n                                  if isProc contt \\<and> isProc contf\n                                  then if v \\<noteq> 0\n then let b' = nb b ct; \\<beta> = [ct \\<mapsto> b]\n      in a\\<cdot>(Discr (contt, [], ve, b')) \\<union>\n         {((ct, \\<beta>), contt)}\n else let b' = nb b cf; \\<beta> = [cf \\<mapsto> b]\n      in a\\<cdot>(Discr (contf, [], ve, b')) \\<union>\n         {((cf, \\<beta>), contf)}\n                                  else \\<bottom>\n                              | (DP (prim.If ct cf),\n                                 DI v # contt # contf # ab # lista,\n                                 bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (DP (prim.If ct cf), _ # list,\n                                 bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (Stop, [], bb) \\<Rightarrow> \\<bottom>\n                              | (Stop, [DI i], x, xa) \\<Rightarrow> {}\n                              | (Stop, DI i # a # lista, bb) \\<Rightarrow>\n                                  \\<bottom>\n                              | (Stop, _ # list, bb) \\<Rightarrow>\n                                  \\<bottom>)\\<cdot>\n                          (Discr\n                            fstate)| \\<lessapprox> \\<aF>\\<cdot>\n             (Discr fstate_a)\n 2. \\<And>a b cstate cstate_a.\n       \\<lbrakk>\\<And>fstate fstate_a.\n                   |fstate| \\<lessapprox> fstate_a \\<Longrightarrow>\n                   |a\\<cdot>\n                    (Discr\n                      fstate)| \\<lessapprox> \\<aF>\\<cdot>(Discr fstate_a);\n        \\<And>cstate cstate_a.\n           |cstate| \\<lessapprox> cstate_a \\<Longrightarrow>\n           |b\\<cdot>\n            (Discr cstate)| \\<lessapprox> \\<aC>\\<cdot>(Discr cstate_a);\n        |cstate| \\<lessapprox> cstate_a\\<rbrakk>\n       \\<Longrightarrow> |(\\<Lambda> cstate.\n                              case undiscr cstate of\n                              (App lab f vs, \\<beta>, ve, b) \\<Rightarrow>\n                                let f' = \\<A> f \\<beta> ve;\n                                    as =\nmap (\\<lambda>v. \\<A> v \\<beta> ve) vs;\n                                    b' = nb b lab\n                                in if isProc f'\n                                   then a\\<cdot>\n  (Discr (f', as, ve, b')) \\<union>\n  {((lab, \\<beta>), f')}\n                                   else \\<bottom>\n                              | (call.Let lab ls c', \\<beta>, ve,\n                                 ba) \\<Rightarrow>\n                                  let b' = nb ba lab;\n\\<beta>' = \\<beta>(lab \\<mapsto> b');\nve' =\n  ve ++ map_of (map (\\<lambda>(v, l). ((v, b'), \\<A> (L l) \\<beta>' ve)) ls)\n                                  in b\\<cdot>\n                                     (Discr (c', \\<beta>', ve', b')))\\<cdot>\n                          (Discr\n                            cstate)| \\<lessapprox> \\<aC>\\<cdot>\n             (Discr cstate_a)", "from fstate fstate_a abs_d abs_ds abs_ve abs_ds dslength"], ["proof (chain)\npicking this:\n  fstate = (d, ds, ve, b)\n  fstate_a = (proc, ds_a, ve_a, b_a)\n  the_elem |d| = proc\n  map AbsCFCorrect.abs ds \\<lessapprox> ds_a\n  |ve| \\<lessapprox> ve_a\n  map AbsCFCorrect.abs ds \\<lessapprox> ds_a\n  length ds = length ds_a", "show ?case"], ["proof (prove)\nusing this:\n  fstate = (d, ds, ve, b)\n  fstate_a = (proc, ds_a, ve_a, b_a)\n  the_elem |d| = proc\n  map AbsCFCorrect.abs ds \\<lessapprox> ds_a\n  |ve| \\<lessapprox> ve_a\n  map AbsCFCorrect.abs ds \\<lessapprox> ds_a\n  length ds = length ds_a\n\ngoal (1 subgoal):\n 1. |(\\<Lambda> fstate.\n         case undiscr fstate of (DI int, ba) \\<Rightarrow> \\<bottom>\n         | (DC (Lambda lab vs c, \\<beta>), as, ve, b) \\<Rightarrow>\n             if length vs = length as\n             then let \\<beta>' = \\<beta>(lab \\<mapsto> b);\n                      ve' = ve(map (\\<lambda>v. (v, b)) vs [\\<mapsto>] as)\n                  in evalC\\<cdot>(Discr (c, \\<beta>', ve', b))\n             else \\<bottom>\n         | (DP (Plus c), [], bb) \\<Rightarrow> \\<bottom>\n         | (DP (Plus c), [DI a1], bb) \\<Rightarrow> \\<bottom>\n         | (DP (Plus c), [DI a1, DI a2], bb) \\<Rightarrow> \\<bottom>\n         | (DP (Plus c), [DI a1, DI a2, cnt], ve, b) \\<Rightarrow>\n             if isProc cnt\n             then let b' = nb b c; \\<beta> = [c \\<mapsto> b]\n                  in evalF\\<cdot>\n                     (Discr (cnt, [DI (a1 + a2)], ve, b')) \\<union>\n                     {((c, \\<beta>), cnt)}\n             else \\<bottom>\n         | (DP (Plus c), DI a1 # DI a2 # cnt # aa # lista, bb) \\<Rightarrow>\n             \\<bottom>\n         | (DP (Plus c), DI a1 # _ # lista, bb) \\<Rightarrow> \\<bottom>\n         | (DP (Plus c), _ # list, bb) \\<Rightarrow> \\<bottom>\n         | (DP (prim.If ct cf), [], bb) \\<Rightarrow> \\<bottom>\n         | (DP (prim.If ct cf), [DI v], bb) \\<Rightarrow> \\<bottom>\n         | (DP (prim.If ct cf), [DI v, contt], bb) \\<Rightarrow> \\<bottom>\n         | (DP (prim.If ct cf), [DI v, contt, contf], ve, b) \\<Rightarrow>\n             if isProc contt \\<and> isProc contf\n             then if v \\<noteq> 0\n                  then let b' = nb b ct; \\<beta> = [ct \\<mapsto> b]\n                       in evalF\\<cdot>(Discr (contt, [], ve, b')) \\<union>\n                          {((ct, \\<beta>), contt)}\n                  else let b' = nb b cf; \\<beta> = [cf \\<mapsto> b]\n                       in evalF\\<cdot>(Discr (contf, [], ve, b')) \\<union>\n                          {((cf, \\<beta>), contf)}\n             else \\<bottom>\n         | (DP (prim.If ct cf), DI v # contt # contf # ab # lista,\n            bb) \\<Rightarrow>\n             \\<bottom>\n         | (DP (prim.If ct cf), _ # list, bb) \\<Rightarrow> \\<bottom>\n         | (Stop, [], bb) \\<Rightarrow> \\<bottom>\n         | (Stop, [DI i], x, xa) \\<Rightarrow> {}\n         | (Stop, DI i # a # lista, bb) \\<Rightarrow> \\<bottom>\n         | (Stop, _ # list, bb) \\<Rightarrow> \\<bottom>)\\<cdot>\n     (Discr fstate)| \\<lessapprox> \\<aF>\\<cdot>(Discr fstate_a)", "proof(cases fstate rule:fstate_case, auto simp del:a_evalF.simps a_evalC.simps set_map)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x2a x1a x2aa x3.\n       \\<lbrakk>length x2aa = length ds_a;\n        fstate = (DC (Lambda x1a x2aa x3, x2a), ds, ve, b);\n        fstate_a = (PC (Lambda x1a x2aa x3, |x2a|), ds_a, ve_a, b_a);\n        |ve| \\<lessapprox> ve_a; map AbsCFCorrect.abs ds \\<lessapprox> ds_a;\n        length ds = length ds_a; d = DC (Lambda x1a x2aa x3, x2a);\n        proc = PC (Lambda x1a x2aa x3, |x2a|)\\<rbrakk>\n       \\<Longrightarrow> |evalC\\<cdot>\n                          (Discr\n                            (x3, x2a(x1a \\<mapsto> b), ve\n                             (map (\\<lambda>v. (v, b)) x2aa [\\<mapsto>] ds),\n                             b))| \\<lessapprox> \\<aF>\\<cdot>\n          (Discr (PC (Lambda x1a x2aa x3, |x2a|), ds_a, ve_a, b_a))\n 2. \\<And>x1 x1a x1aa x21b.\n       \\<lbrakk>fstate = (DP (Plus x1), [DI x1a, DI x1aa, x21b], ve, b);\n        fstate_a = (PP (Plus x1), ds_a, ve_a, b_a); |ve| \\<lessapprox> ve_a;\n        [{}, {}, |x21b|] \\<lessapprox> ds_a;\n        Suc (Suc (Suc 0)) = length ds_a; proc = PP (Plus x1);\n        d = DP (Plus x1); ds = [DI x1a, DI x1aa, x21b]; isProc x21b\\<rbrakk>\n       \\<Longrightarrow> |insert ((x1, [x1 \\<mapsto> b]), x21b)\n                           (evalF\\<cdot>\n                            (Discr\n                              (x21b, [DI (x1a + x1aa)], ve,\n                               nb b\n                                x1)))| \\<lessapprox> \\<aF>\\<cdot>\n               (Discr (PP (Plus x1), ds_a, ve_a, b_a))\n 3. \\<And>x21 x22 x1 x21aa x21aaa.\n       \\<lbrakk>fstate =\n                (DP (prim.If x21 x22), [DI x1, x21aa, x21aaa], ve, b);\n        fstate_a = (PP (prim.If x21 x22), ds_a, ve_a, b_a);\n        |ve| \\<lessapprox> ve_a; [{}, |x21aa|, |x21aaa|] \\<lessapprox> ds_a;\n        Suc (Suc (Suc 0)) = length ds_a; proc = PP (prim.If x21 x22);\n        d = DP (prim.If x21 x22); ds = [DI x1, x21aa, x21aaa];\n        x1 \\<noteq> 0; isProc x21aa; isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> |insert ((x21, [x21 \\<mapsto> b]), x21aa)\n                           (evalF\\<cdot>\n                            (Discr\n                              (x21aa, [], ve,\n                               nb b\n                                x21)))| \\<lessapprox> \\<aF>\\<cdot>\n                (Discr (PP (prim.If x21 x22), ds_a, ve_a, b_a))\n 4. \\<And>x21 x22 x21aa x21aaa.\n       \\<lbrakk>fstate =\n                (DP (prim.If x21 x22), [DI 0, x21aa, x21aaa], ve, b);\n        fstate_a = (PP (prim.If x21 x22), ds_a, ve_a, b_a);\n        |ve| \\<lessapprox> ve_a; [{}, |x21aa|, |x21aaa|] \\<lessapprox> ds_a;\n        Suc (Suc (Suc 0)) = length ds_a; proc = PP (prim.If x21 x22);\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa]; isProc x21aa;\n        isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> |insert ((x22, [x22 \\<mapsto> b]), x21aaa)\n                           (evalF\\<cdot>\n                            (Discr\n                              (x21aaa, [], ve,\n                               nb b\n                                x22)))| \\<lessapprox> \\<aF>\\<cdot>\n                (Discr (PP (prim.If x21 x22), ds_a, ve_a, b_a))", "txt \\<open>Case Lambda\\<close>"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x2a x1a x2aa x3.\n       \\<lbrakk>length x2aa = length ds_a;\n        fstate = (DC (Lambda x1a x2aa x3, x2a), ds, ve, b);\n        fstate_a = (PC (Lambda x1a x2aa x3, |x2a|), ds_a, ve_a, b_a);\n        |ve| \\<lessapprox> ve_a; map AbsCFCorrect.abs ds \\<lessapprox> ds_a;\n        length ds = length ds_a; d = DC (Lambda x1a x2aa x3, x2a);\n        proc = PC (Lambda x1a x2aa x3, |x2a|)\\<rbrakk>\n       \\<Longrightarrow> |evalC\\<cdot>\n                          (Discr\n                            (x3, x2a(x1a \\<mapsto> b), ve\n                             (map (\\<lambda>v. (v, b)) x2aa [\\<mapsto>] ds),\n                             b))| \\<lessapprox> \\<aF>\\<cdot>\n          (Discr (PC (Lambda x1a x2aa x3, |x2a|), ds_a, ve_a, b_a))\n 2. \\<And>x1 x1a x1aa x21b.\n       \\<lbrakk>fstate = (DP (Plus x1), [DI x1a, DI x1aa, x21b], ve, b);\n        fstate_a = (PP (Plus x1), ds_a, ve_a, b_a); |ve| \\<lessapprox> ve_a;\n        [{}, {}, |x21b|] \\<lessapprox> ds_a;\n        Suc (Suc (Suc 0)) = length ds_a; proc = PP (Plus x1);\n        d = DP (Plus x1); ds = [DI x1a, DI x1aa, x21b]; isProc x21b\\<rbrakk>\n       \\<Longrightarrow> |insert ((x1, [x1 \\<mapsto> b]), x21b)\n                           (evalF\\<cdot>\n                            (Discr\n                              (x21b, [DI (x1a + x1aa)], ve,\n                               nb b\n                                x1)))| \\<lessapprox> \\<aF>\\<cdot>\n               (Discr (PP (Plus x1), ds_a, ve_a, b_a))\n 3. \\<And>x21 x22 x1 x21aa x21aaa.\n       \\<lbrakk>fstate =\n                (DP (prim.If x21 x22), [DI x1, x21aa, x21aaa], ve, b);\n        fstate_a = (PP (prim.If x21 x22), ds_a, ve_a, b_a);\n        |ve| \\<lessapprox> ve_a; [{}, |x21aa|, |x21aaa|] \\<lessapprox> ds_a;\n        Suc (Suc (Suc 0)) = length ds_a; proc = PP (prim.If x21 x22);\n        d = DP (prim.If x21 x22); ds = [DI x1, x21aa, x21aaa];\n        x1 \\<noteq> 0; isProc x21aa; isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> |insert ((x21, [x21 \\<mapsto> b]), x21aa)\n                           (evalF\\<cdot>\n                            (Discr\n                              (x21aa, [], ve,\n                               nb b\n                                x21)))| \\<lessapprox> \\<aF>\\<cdot>\n                (Discr (PP (prim.If x21 x22), ds_a, ve_a, b_a))\n 4. \\<And>x21 x22 x21aa x21aaa.\n       \\<lbrakk>fstate =\n                (DP (prim.If x21 x22), [DI 0, x21aa, x21aaa], ve, b);\n        fstate_a = (PP (prim.If x21 x22), ds_a, ve_a, b_a);\n        |ve| \\<lessapprox> ve_a; [{}, |x21aa|, |x21aaa|] \\<lessapprox> ds_a;\n        Suc (Suc (Suc 0)) = length ds_a; proc = PP (prim.If x21 x22);\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa]; isProc x21aa;\n        isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> |insert ((x22, [x22 \\<mapsto> b]), x21aaa)\n                           (evalF\\<cdot>\n                            (Discr\n                              (x21aaa, [], ve,\n                               nb b\n                                x22)))| \\<lessapprox> \\<aF>\\<cdot>\n                (Discr (PP (prim.If x21 x22), ds_a, ve_a, b_a))", "fix \\<beta> and lab and vs:: \"var list\" and c"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x2a x1a x2aa x3.\n       \\<lbrakk>length x2aa = length ds_a;\n        fstate = (DC (Lambda x1a x2aa x3, x2a), ds, ve, b);\n        fstate_a = (PC (Lambda x1a x2aa x3, |x2a|), ds_a, ve_a, b_a);\n        |ve| \\<lessapprox> ve_a; map AbsCFCorrect.abs ds \\<lessapprox> ds_a;\n        length ds = length ds_a; d = DC (Lambda x1a x2aa x3, x2a);\n        proc = PC (Lambda x1a x2aa x3, |x2a|)\\<rbrakk>\n       \\<Longrightarrow> |evalC\\<cdot>\n                          (Discr\n                            (x3, x2a(x1a \\<mapsto> b), ve\n                             (map (\\<lambda>v. (v, b)) x2aa [\\<mapsto>] ds),\n                             b))| \\<lessapprox> \\<aF>\\<cdot>\n          (Discr (PC (Lambda x1a x2aa x3, |x2a|), ds_a, ve_a, b_a))\n 2. \\<And>x1 x1a x1aa x21b.\n       \\<lbrakk>fstate = (DP (Plus x1), [DI x1a, DI x1aa, x21b], ve, b);\n        fstate_a = (PP (Plus x1), ds_a, ve_a, b_a); |ve| \\<lessapprox> ve_a;\n        [{}, {}, |x21b|] \\<lessapprox> ds_a;\n        Suc (Suc (Suc 0)) = length ds_a; proc = PP (Plus x1);\n        d = DP (Plus x1); ds = [DI x1a, DI x1aa, x21b]; isProc x21b\\<rbrakk>\n       \\<Longrightarrow> |insert ((x1, [x1 \\<mapsto> b]), x21b)\n                           (evalF\\<cdot>\n                            (Discr\n                              (x21b, [DI (x1a + x1aa)], ve,\n                               nb b\n                                x1)))| \\<lessapprox> \\<aF>\\<cdot>\n               (Discr (PP (Plus x1), ds_a, ve_a, b_a))\n 3. \\<And>x21 x22 x1 x21aa x21aaa.\n       \\<lbrakk>fstate =\n                (DP (prim.If x21 x22), [DI x1, x21aa, x21aaa], ve, b);\n        fstate_a = (PP (prim.If x21 x22), ds_a, ve_a, b_a);\n        |ve| \\<lessapprox> ve_a; [{}, |x21aa|, |x21aaa|] \\<lessapprox> ds_a;\n        Suc (Suc (Suc 0)) = length ds_a; proc = PP (prim.If x21 x22);\n        d = DP (prim.If x21 x22); ds = [DI x1, x21aa, x21aaa];\n        x1 \\<noteq> 0; isProc x21aa; isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> |insert ((x21, [x21 \\<mapsto> b]), x21aa)\n                           (evalF\\<cdot>\n                            (Discr\n                              (x21aa, [], ve,\n                               nb b\n                                x21)))| \\<lessapprox> \\<aF>\\<cdot>\n                (Discr (PP (prim.If x21 x22), ds_a, ve_a, b_a))\n 4. \\<And>x21 x22 x21aa x21aaa.\n       \\<lbrakk>fstate =\n                (DP (prim.If x21 x22), [DI 0, x21aa, x21aaa], ve, b);\n        fstate_a = (PP (prim.If x21 x22), ds_a, ve_a, b_a);\n        |ve| \\<lessapprox> ve_a; [{}, |x21aa|, |x21aaa|] \\<lessapprox> ds_a;\n        Suc (Suc (Suc 0)) = length ds_a; proc = PP (prim.If x21 x22);\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa]; isProc x21aa;\n        isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> |insert ((x22, [x22 \\<mapsto> b]), x21aaa)\n                           (evalF\\<cdot>\n                            (Discr\n                              (x21aaa, [], ve,\n                               nb b\n                                x22)))| \\<lessapprox> \\<aF>\\<cdot>\n                (Discr (PP (prim.If x21 x22), ds_a, ve_a, b_a))", "assume ds_a_length: \"length vs = length ds_a\""], ["proof (state)\nthis:\n  length vs = length ds_a\n\ngoal (4 subgoals):\n 1. \\<And>x2a x1a x2aa x3.\n       \\<lbrakk>length x2aa = length ds_a;\n        fstate = (DC (Lambda x1a x2aa x3, x2a), ds, ve, b);\n        fstate_a = (PC (Lambda x1a x2aa x3, |x2a|), ds_a, ve_a, b_a);\n        |ve| \\<lessapprox> ve_a; map AbsCFCorrect.abs ds \\<lessapprox> ds_a;\n        length ds = length ds_a; d = DC (Lambda x1a x2aa x3, x2a);\n        proc = PC (Lambda x1a x2aa x3, |x2a|)\\<rbrakk>\n       \\<Longrightarrow> |evalC\\<cdot>\n                          (Discr\n                            (x3, x2a(x1a \\<mapsto> b), ve\n                             (map (\\<lambda>v. (v, b)) x2aa [\\<mapsto>] ds),\n                             b))| \\<lessapprox> \\<aF>\\<cdot>\n          (Discr (PC (Lambda x1a x2aa x3, |x2a|), ds_a, ve_a, b_a))\n 2. \\<And>x1 x1a x1aa x21b.\n       \\<lbrakk>fstate = (DP (Plus x1), [DI x1a, DI x1aa, x21b], ve, b);\n        fstate_a = (PP (Plus x1), ds_a, ve_a, b_a); |ve| \\<lessapprox> ve_a;\n        [{}, {}, |x21b|] \\<lessapprox> ds_a;\n        Suc (Suc (Suc 0)) = length ds_a; proc = PP (Plus x1);\n        d = DP (Plus x1); ds = [DI x1a, DI x1aa, x21b]; isProc x21b\\<rbrakk>\n       \\<Longrightarrow> |insert ((x1, [x1 \\<mapsto> b]), x21b)\n                           (evalF\\<cdot>\n                            (Discr\n                              (x21b, [DI (x1a + x1aa)], ve,\n                               nb b\n                                x1)))| \\<lessapprox> \\<aF>\\<cdot>\n               (Discr (PP (Plus x1), ds_a, ve_a, b_a))\n 3. \\<And>x21 x22 x1 x21aa x21aaa.\n       \\<lbrakk>fstate =\n                (DP (prim.If x21 x22), [DI x1, x21aa, x21aaa], ve, b);\n        fstate_a = (PP (prim.If x21 x22), ds_a, ve_a, b_a);\n        |ve| \\<lessapprox> ve_a; [{}, |x21aa|, |x21aaa|] \\<lessapprox> ds_a;\n        Suc (Suc (Suc 0)) = length ds_a; proc = PP (prim.If x21 x22);\n        d = DP (prim.If x21 x22); ds = [DI x1, x21aa, x21aaa];\n        x1 \\<noteq> 0; isProc x21aa; isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> |insert ((x21, [x21 \\<mapsto> b]), x21aa)\n                           (evalF\\<cdot>\n                            (Discr\n                              (x21aa, [], ve,\n                               nb b\n                                x21)))| \\<lessapprox> \\<aF>\\<cdot>\n                (Discr (PP (prim.If x21 x22), ds_a, ve_a, b_a))\n 4. \\<And>x21 x22 x21aa x21aaa.\n       \\<lbrakk>fstate =\n                (DP (prim.If x21 x22), [DI 0, x21aa, x21aaa], ve, b);\n        fstate_a = (PP (prim.If x21 x22), ds_a, ve_a, b_a);\n        |ve| \\<lessapprox> ve_a; [{}, |x21aa|, |x21aaa|] \\<lessapprox> ds_a;\n        Suc (Suc (Suc 0)) = length ds_a; proc = PP (prim.If x21 x22);\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa]; isProc x21aa;\n        isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> |insert ((x22, [x22 \\<mapsto> b]), x21aaa)\n                           (evalF\\<cdot>\n                            (Discr\n                              (x21aaa, [], ve,\n                               nb b\n                                x22)))| \\<lessapprox> \\<aF>\\<cdot>\n                (Discr (PP (prim.If x21 x22), ds_a, ve_a, b_a))", "have \"|\\<beta>(lab \\<mapsto> b)| = |\\<beta>| (lab \\<mapsto> b_a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. |\\<beta>(lab \\<mapsto> b)| = |\\<beta>|(lab \\<mapsto> b_a)", "unfolding below_fun_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. |\\<beta>(lab \\<mapsto> b)| = |\\<beta>|(lab \\<mapsto> b_a)", "using abs_b"], ["proof (prove)\nusing this:\n  |b| = b_a\n\ngoal (1 subgoal):\n 1. |\\<beta>(lab \\<mapsto> b)| = |\\<beta>|(lab \\<mapsto> b_a)", "by simp"], ["proof (state)\nthis:\n  |\\<beta>(lab \\<mapsto> b)| = |\\<beta>|(lab \\<mapsto> b_a)\n\ngoal (4 subgoals):\n 1. \\<And>x2a x1a x2aa x3.\n       \\<lbrakk>length x2aa = length ds_a;\n        fstate = (DC (Lambda x1a x2aa x3, x2a), ds, ve, b);\n        fstate_a = (PC (Lambda x1a x2aa x3, |x2a|), ds_a, ve_a, b_a);\n        |ve| \\<lessapprox> ve_a; map AbsCFCorrect.abs ds \\<lessapprox> ds_a;\n        length ds = length ds_a; d = DC (Lambda x1a x2aa x3, x2a);\n        proc = PC (Lambda x1a x2aa x3, |x2a|)\\<rbrakk>\n       \\<Longrightarrow> |evalC\\<cdot>\n                          (Discr\n                            (x3, x2a(x1a \\<mapsto> b), ve\n                             (map (\\<lambda>v. (v, b)) x2aa [\\<mapsto>] ds),\n                             b))| \\<lessapprox> \\<aF>\\<cdot>\n          (Discr (PC (Lambda x1a x2aa x3, |x2a|), ds_a, ve_a, b_a))\n 2. \\<And>x1 x1a x1aa x21b.\n       \\<lbrakk>fstate = (DP (Plus x1), [DI x1a, DI x1aa, x21b], ve, b);\n        fstate_a = (PP (Plus x1), ds_a, ve_a, b_a); |ve| \\<lessapprox> ve_a;\n        [{}, {}, |x21b|] \\<lessapprox> ds_a;\n        Suc (Suc (Suc 0)) = length ds_a; proc = PP (Plus x1);\n        d = DP (Plus x1); ds = [DI x1a, DI x1aa, x21b]; isProc x21b\\<rbrakk>\n       \\<Longrightarrow> |insert ((x1, [x1 \\<mapsto> b]), x21b)\n                           (evalF\\<cdot>\n                            (Discr\n                              (x21b, [DI (x1a + x1aa)], ve,\n                               nb b\n                                x1)))| \\<lessapprox> \\<aF>\\<cdot>\n               (Discr (PP (Plus x1), ds_a, ve_a, b_a))\n 3. \\<And>x21 x22 x1 x21aa x21aaa.\n       \\<lbrakk>fstate =\n                (DP (prim.If x21 x22), [DI x1, x21aa, x21aaa], ve, b);\n        fstate_a = (PP (prim.If x21 x22), ds_a, ve_a, b_a);\n        |ve| \\<lessapprox> ve_a; [{}, |x21aa|, |x21aaa|] \\<lessapprox> ds_a;\n        Suc (Suc (Suc 0)) = length ds_a; proc = PP (prim.If x21 x22);\n        d = DP (prim.If x21 x22); ds = [DI x1, x21aa, x21aaa];\n        x1 \\<noteq> 0; isProc x21aa; isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> |insert ((x21, [x21 \\<mapsto> b]), x21aa)\n                           (evalF\\<cdot>\n                            (Discr\n                              (x21aa, [], ve,\n                               nb b\n                                x21)))| \\<lessapprox> \\<aF>\\<cdot>\n                (Discr (PP (prim.If x21 x22), ds_a, ve_a, b_a))\n 4. \\<And>x21 x22 x21aa x21aaa.\n       \\<lbrakk>fstate =\n                (DP (prim.If x21 x22), [DI 0, x21aa, x21aaa], ve, b);\n        fstate_a = (PP (prim.If x21 x22), ds_a, ve_a, b_a);\n        |ve| \\<lessapprox> ve_a; [{}, |x21aa|, |x21aaa|] \\<lessapprox> ds_a;\n        Suc (Suc (Suc 0)) = length ds_a; proc = PP (prim.If x21 x22);\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa]; isProc x21aa;\n        isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> |insert ((x22, [x22 \\<mapsto> b]), x21aaa)\n                           (evalF\\<cdot>\n                            (Discr\n                              (x21aaa, [], ve,\n                               nb b\n                                x22)))| \\<lessapprox> \\<aF>\\<cdot>\n                (Discr (PP (prim.If x21 x22), ds_a, ve_a, b_a))", "moreover"], ["proof (state)\nthis:\n  |\\<beta>(lab \\<mapsto> b)| = |\\<beta>|(lab \\<mapsto> b_a)\n\ngoal (4 subgoals):\n 1. \\<And>x2a x1a x2aa x3.\n       \\<lbrakk>length x2aa = length ds_a;\n        fstate = (DC (Lambda x1a x2aa x3, x2a), ds, ve, b);\n        fstate_a = (PC (Lambda x1a x2aa x3, |x2a|), ds_a, ve_a, b_a);\n        |ve| \\<lessapprox> ve_a; map AbsCFCorrect.abs ds \\<lessapprox> ds_a;\n        length ds = length ds_a; d = DC (Lambda x1a x2aa x3, x2a);\n        proc = PC (Lambda x1a x2aa x3, |x2a|)\\<rbrakk>\n       \\<Longrightarrow> |evalC\\<cdot>\n                          (Discr\n                            (x3, x2a(x1a \\<mapsto> b), ve\n                             (map (\\<lambda>v. (v, b)) x2aa [\\<mapsto>] ds),\n                             b))| \\<lessapprox> \\<aF>\\<cdot>\n          (Discr (PC (Lambda x1a x2aa x3, |x2a|), ds_a, ve_a, b_a))\n 2. \\<And>x1 x1a x1aa x21b.\n       \\<lbrakk>fstate = (DP (Plus x1), [DI x1a, DI x1aa, x21b], ve, b);\n        fstate_a = (PP (Plus x1), ds_a, ve_a, b_a); |ve| \\<lessapprox> ve_a;\n        [{}, {}, |x21b|] \\<lessapprox> ds_a;\n        Suc (Suc (Suc 0)) = length ds_a; proc = PP (Plus x1);\n        d = DP (Plus x1); ds = [DI x1a, DI x1aa, x21b]; isProc x21b\\<rbrakk>\n       \\<Longrightarrow> |insert ((x1, [x1 \\<mapsto> b]), x21b)\n                           (evalF\\<cdot>\n                            (Discr\n                              (x21b, [DI (x1a + x1aa)], ve,\n                               nb b\n                                x1)))| \\<lessapprox> \\<aF>\\<cdot>\n               (Discr (PP (Plus x1), ds_a, ve_a, b_a))\n 3. \\<And>x21 x22 x1 x21aa x21aaa.\n       \\<lbrakk>fstate =\n                (DP (prim.If x21 x22), [DI x1, x21aa, x21aaa], ve, b);\n        fstate_a = (PP (prim.If x21 x22), ds_a, ve_a, b_a);\n        |ve| \\<lessapprox> ve_a; [{}, |x21aa|, |x21aaa|] \\<lessapprox> ds_a;\n        Suc (Suc (Suc 0)) = length ds_a; proc = PP (prim.If x21 x22);\n        d = DP (prim.If x21 x22); ds = [DI x1, x21aa, x21aaa];\n        x1 \\<noteq> 0; isProc x21aa; isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> |insert ((x21, [x21 \\<mapsto> b]), x21aa)\n                           (evalF\\<cdot>\n                            (Discr\n                              (x21aa, [], ve,\n                               nb b\n                                x21)))| \\<lessapprox> \\<aF>\\<cdot>\n                (Discr (PP (prim.If x21 x22), ds_a, ve_a, b_a))\n 4. \\<And>x21 x22 x21aa x21aaa.\n       \\<lbrakk>fstate =\n                (DP (prim.If x21 x22), [DI 0, x21aa, x21aaa], ve, b);\n        fstate_a = (PP (prim.If x21 x22), ds_a, ve_a, b_a);\n        |ve| \\<lessapprox> ve_a; [{}, |x21aa|, |x21aaa|] \\<lessapprox> ds_a;\n        Suc (Suc (Suc 0)) = length ds_a; proc = PP (prim.If x21 x22);\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa]; isProc x21aa;\n        isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> |insert ((x22, [x22 \\<mapsto> b]), x21aaa)\n                           (evalF\\<cdot>\n                            (Discr\n                              (x21aaa, [], ve,\n                               nb b\n                                x22)))| \\<lessapprox> \\<aF>\\<cdot>\n                (Discr (PP (prim.If x21 x22), ds_a, ve_a, b_a))", "{"], ["proof (state)\nthis:\n  |\\<beta>(lab \\<mapsto> b)| = |\\<beta>|(lab \\<mapsto> b_a)\n\ngoal (4 subgoals):\n 1. \\<And>x2a x1a x2aa x3.\n       \\<lbrakk>length x2aa = length ds_a;\n        fstate = (DC (Lambda x1a x2aa x3, x2a), ds, ve, b);\n        fstate_a = (PC (Lambda x1a x2aa x3, |x2a|), ds_a, ve_a, b_a);\n        |ve| \\<lessapprox> ve_a; map AbsCFCorrect.abs ds \\<lessapprox> ds_a;\n        length ds = length ds_a; d = DC (Lambda x1a x2aa x3, x2a);\n        proc = PC (Lambda x1a x2aa x3, |x2a|)\\<rbrakk>\n       \\<Longrightarrow> |evalC\\<cdot>\n                          (Discr\n                            (x3, x2a(x1a \\<mapsto> b), ve\n                             (map (\\<lambda>v. (v, b)) x2aa [\\<mapsto>] ds),\n                             b))| \\<lessapprox> \\<aF>\\<cdot>\n          (Discr (PC (Lambda x1a x2aa x3, |x2a|), ds_a, ve_a, b_a))\n 2. \\<And>x1 x1a x1aa x21b.\n       \\<lbrakk>fstate = (DP (Plus x1), [DI x1a, DI x1aa, x21b], ve, b);\n        fstate_a = (PP (Plus x1), ds_a, ve_a, b_a); |ve| \\<lessapprox> ve_a;\n        [{}, {}, |x21b|] \\<lessapprox> ds_a;\n        Suc (Suc (Suc 0)) = length ds_a; proc = PP (Plus x1);\n        d = DP (Plus x1); ds = [DI x1a, DI x1aa, x21b]; isProc x21b\\<rbrakk>\n       \\<Longrightarrow> |insert ((x1, [x1 \\<mapsto> b]), x21b)\n                           (evalF\\<cdot>\n                            (Discr\n                              (x21b, [DI (x1a + x1aa)], ve,\n                               nb b\n                                x1)))| \\<lessapprox> \\<aF>\\<cdot>\n               (Discr (PP (Plus x1), ds_a, ve_a, b_a))\n 3. \\<And>x21 x22 x1 x21aa x21aaa.\n       \\<lbrakk>fstate =\n                (DP (prim.If x21 x22), [DI x1, x21aa, x21aaa], ve, b);\n        fstate_a = (PP (prim.If x21 x22), ds_a, ve_a, b_a);\n        |ve| \\<lessapprox> ve_a; [{}, |x21aa|, |x21aaa|] \\<lessapprox> ds_a;\n        Suc (Suc (Suc 0)) = length ds_a; proc = PP (prim.If x21 x22);\n        d = DP (prim.If x21 x22); ds = [DI x1, x21aa, x21aaa];\n        x1 \\<noteq> 0; isProc x21aa; isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> |insert ((x21, [x21 \\<mapsto> b]), x21aa)\n                           (evalF\\<cdot>\n                            (Discr\n                              (x21aa, [], ve,\n                               nb b\n                                x21)))| \\<lessapprox> \\<aF>\\<cdot>\n                (Discr (PP (prim.If x21 x22), ds_a, ve_a, b_a))\n 4. \\<And>x21 x22 x21aa x21aaa.\n       \\<lbrakk>fstate =\n                (DP (prim.If x21 x22), [DI 0, x21aa, x21aaa], ve, b);\n        fstate_a = (PP (prim.If x21 x22), ds_a, ve_a, b_a);\n        |ve| \\<lessapprox> ve_a; [{}, |x21aa|, |x21aaa|] \\<lessapprox> ds_a;\n        Suc (Suc (Suc 0)) = length ds_a; proc = PP (prim.If x21 x22);\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa]; isProc x21aa;\n        isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> |insert ((x22, [x22 \\<mapsto> b]), x21aaa)\n                           (evalF\\<cdot>\n                            (Discr\n                              (x21aaa, [], ve,\n                               nb b\n                                x22)))| \\<lessapprox> \\<aF>\\<cdot>\n                (Discr (PP (prim.If x21 x22), ds_a, ve_a, b_a))", "have \"|ve(map (\\<lambda>v. (v, b)) vs [\\<mapsto>] ds)|\n          \\<lessapprox> |ve| \\<union>. |map_of (rev (zip (map (\\<lambda>v. (v, b)) vs) ds))|\""], ["proof (prove)\ngoal (1 subgoal):\n 1. |ve(map (\\<lambda>v. (v, b)) vs [\\<mapsto>]\n    ds)| \\<lessapprox> |ve| \\<union>. |map_of\n  (rev (zip (map (\\<lambda>v. (v, b)) vs) ds))|", "unfolding map_upds_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. |ve ++\n     map_of\n      (rev (zip (map (\\<lambda>v. (v, b)) vs)\n             ds))| \\<lessapprox> |ve| \\<union>. |map_of\n            (rev (zip (map (\\<lambda>v. (v, b)) vs) ds))|", "by (intro abs_venv_union)"], ["proof (state)\nthis:\n  |ve(map (\\<lambda>v. (v, b)) vs [\\<mapsto>]\n  ds)| \\<lessapprox> |ve| \\<union>. |map_of\n(rev (zip (map (\\<lambda>v. (v, b)) vs) ds))|\n\ngoal (4 subgoals):\n 1. \\<And>x2a x1a x2aa x3.\n       \\<lbrakk>length x2aa = length ds_a;\n        fstate = (DC (Lambda x1a x2aa x3, x2a), ds, ve, b);\n        fstate_a = (PC (Lambda x1a x2aa x3, |x2a|), ds_a, ve_a, b_a);\n        |ve| \\<lessapprox> ve_a; map AbsCFCorrect.abs ds \\<lessapprox> ds_a;\n        length ds = length ds_a; d = DC (Lambda x1a x2aa x3, x2a);\n        proc = PC (Lambda x1a x2aa x3, |x2a|)\\<rbrakk>\n       \\<Longrightarrow> |evalC\\<cdot>\n                          (Discr\n                            (x3, x2a(x1a \\<mapsto> b), ve\n                             (map (\\<lambda>v. (v, b)) x2aa [\\<mapsto>] ds),\n                             b))| \\<lessapprox> \\<aF>\\<cdot>\n          (Discr (PC (Lambda x1a x2aa x3, |x2a|), ds_a, ve_a, b_a))\n 2. \\<And>x1 x1a x1aa x21b.\n       \\<lbrakk>fstate = (DP (Plus x1), [DI x1a, DI x1aa, x21b], ve, b);\n        fstate_a = (PP (Plus x1), ds_a, ve_a, b_a); |ve| \\<lessapprox> ve_a;\n        [{}, {}, |x21b|] \\<lessapprox> ds_a;\n        Suc (Suc (Suc 0)) = length ds_a; proc = PP (Plus x1);\n        d = DP (Plus x1); ds = [DI x1a, DI x1aa, x21b]; isProc x21b\\<rbrakk>\n       \\<Longrightarrow> |insert ((x1, [x1 \\<mapsto> b]), x21b)\n                           (evalF\\<cdot>\n                            (Discr\n                              (x21b, [DI (x1a + x1aa)], ve,\n                               nb b\n                                x1)))| \\<lessapprox> \\<aF>\\<cdot>\n               (Discr (PP (Plus x1), ds_a, ve_a, b_a))\n 3. \\<And>x21 x22 x1 x21aa x21aaa.\n       \\<lbrakk>fstate =\n                (DP (prim.If x21 x22), [DI x1, x21aa, x21aaa], ve, b);\n        fstate_a = (PP (prim.If x21 x22), ds_a, ve_a, b_a);\n        |ve| \\<lessapprox> ve_a; [{}, |x21aa|, |x21aaa|] \\<lessapprox> ds_a;\n        Suc (Suc (Suc 0)) = length ds_a; proc = PP (prim.If x21 x22);\n        d = DP (prim.If x21 x22); ds = [DI x1, x21aa, x21aaa];\n        x1 \\<noteq> 0; isProc x21aa; isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> |insert ((x21, [x21 \\<mapsto> b]), x21aa)\n                           (evalF\\<cdot>\n                            (Discr\n                              (x21aa, [], ve,\n                               nb b\n                                x21)))| \\<lessapprox> \\<aF>\\<cdot>\n                (Discr (PP (prim.If x21 x22), ds_a, ve_a, b_a))\n 4. \\<And>x21 x22 x21aa x21aaa.\n       \\<lbrakk>fstate =\n                (DP (prim.If x21 x22), [DI 0, x21aa, x21aaa], ve, b);\n        fstate_a = (PP (prim.If x21 x22), ds_a, ve_a, b_a);\n        |ve| \\<lessapprox> ve_a; [{}, |x21aa|, |x21aaa|] \\<lessapprox> ds_a;\n        Suc (Suc (Suc 0)) = length ds_a; proc = PP (prim.If x21 x22);\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa]; isProc x21aa;\n        isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> |insert ((x22, [x22 \\<mapsto> b]), x21aaa)\n                           (evalF\\<cdot>\n                            (Discr\n                              (x21aaa, [], ve,\n                               nb b\n                                x22)))| \\<lessapprox> \\<aF>\\<cdot>\n                (Discr (PP (prim.If x21 x22), ds_a, ve_a, b_a))", "also"], ["proof (state)\nthis:\n  |ve(map (\\<lambda>v. (v, b)) vs [\\<mapsto>]\n  ds)| \\<lessapprox> |ve| \\<union>. |map_of\n(rev (zip (map (\\<lambda>v. (v, b)) vs) ds))|\n\ngoal (4 subgoals):\n 1. \\<And>x2a x1a x2aa x3.\n       \\<lbrakk>length x2aa = length ds_a;\n        fstate = (DC (Lambda x1a x2aa x3, x2a), ds, ve, b);\n        fstate_a = (PC (Lambda x1a x2aa x3, |x2a|), ds_a, ve_a, b_a);\n        |ve| \\<lessapprox> ve_a; map AbsCFCorrect.abs ds \\<lessapprox> ds_a;\n        length ds = length ds_a; d = DC (Lambda x1a x2aa x3, x2a);\n        proc = PC (Lambda x1a x2aa x3, |x2a|)\\<rbrakk>\n       \\<Longrightarrow> |evalC\\<cdot>\n                          (Discr\n                            (x3, x2a(x1a \\<mapsto> b), ve\n                             (map (\\<lambda>v. (v, b)) x2aa [\\<mapsto>] ds),\n                             b))| \\<lessapprox> \\<aF>\\<cdot>\n          (Discr (PC (Lambda x1a x2aa x3, |x2a|), ds_a, ve_a, b_a))\n 2. \\<And>x1 x1a x1aa x21b.\n       \\<lbrakk>fstate = (DP (Plus x1), [DI x1a, DI x1aa, x21b], ve, b);\n        fstate_a = (PP (Plus x1), ds_a, ve_a, b_a); |ve| \\<lessapprox> ve_a;\n        [{}, {}, |x21b|] \\<lessapprox> ds_a;\n        Suc (Suc (Suc 0)) = length ds_a; proc = PP (Plus x1);\n        d = DP (Plus x1); ds = [DI x1a, DI x1aa, x21b]; isProc x21b\\<rbrakk>\n       \\<Longrightarrow> |insert ((x1, [x1 \\<mapsto> b]), x21b)\n                           (evalF\\<cdot>\n                            (Discr\n                              (x21b, [DI (x1a + x1aa)], ve,\n                               nb b\n                                x1)))| \\<lessapprox> \\<aF>\\<cdot>\n               (Discr (PP (Plus x1), ds_a, ve_a, b_a))\n 3. \\<And>x21 x22 x1 x21aa x21aaa.\n       \\<lbrakk>fstate =\n                (DP (prim.If x21 x22), [DI x1, x21aa, x21aaa], ve, b);\n        fstate_a = (PP (prim.If x21 x22), ds_a, ve_a, b_a);\n        |ve| \\<lessapprox> ve_a; [{}, |x21aa|, |x21aaa|] \\<lessapprox> ds_a;\n        Suc (Suc (Suc 0)) = length ds_a; proc = PP (prim.If x21 x22);\n        d = DP (prim.If x21 x22); ds = [DI x1, x21aa, x21aaa];\n        x1 \\<noteq> 0; isProc x21aa; isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> |insert ((x21, [x21 \\<mapsto> b]), x21aa)\n                           (evalF\\<cdot>\n                            (Discr\n                              (x21aa, [], ve,\n                               nb b\n                                x21)))| \\<lessapprox> \\<aF>\\<cdot>\n                (Discr (PP (prim.If x21 x22), ds_a, ve_a, b_a))\n 4. \\<And>x21 x22 x21aa x21aaa.\n       \\<lbrakk>fstate =\n                (DP (prim.If x21 x22), [DI 0, x21aa, x21aaa], ve, b);\n        fstate_a = (PP (prim.If x21 x22), ds_a, ve_a, b_a);\n        |ve| \\<lessapprox> ve_a; [{}, |x21aa|, |x21aaa|] \\<lessapprox> ds_a;\n        Suc (Suc (Suc 0)) = length ds_a; proc = PP (prim.If x21 x22);\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa]; isProc x21aa;\n        isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> |insert ((x22, [x22 \\<mapsto> b]), x21aaa)\n                           (evalF\\<cdot>\n                            (Discr\n                              (x21aaa, [], ve,\n                               nb b\n                                x22)))| \\<lessapprox> \\<aF>\\<cdot>\n                (Discr (PP (prim.If x21 x22), ds_a, ve_a, b_a))", "have \"\\<dots> \\<lessapprox> ve_a  \\<union>. (\\<Union>. (map (\\<lambda>(v,k). |[v \\<mapsto> k]| ) (zip (map (\\<lambda>v. (v, b)) vs) ds)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. |ve| \\<union>. |map_of\n                     (rev (zip (map (\\<lambda>v. (v, b)) vs)\n                            ds))| \\<lessapprox> ve_a \\<union>. \\<Union>.map2\n                                   (\\<lambda>v k. |[v \\<mapsto> k]|)\n                                   (map (\\<lambda>v. (v, b)) vs) ds", "using abs_ve abs_venv_map_of_rev"], ["proof (prove)\nusing this:\n  |ve| \\<lessapprox> ve_a\n  |map_of\n    (rev ?l)| \\<lessapprox> \\<Union>.map\n(\\<lambda>(v, k). |[v \\<mapsto> k]|) ?l\n\ngoal (1 subgoal):\n 1. |ve| \\<union>. |map_of\n                     (rev (zip (map (\\<lambda>v. (v, b)) vs)\n                            ds))| \\<lessapprox> ve_a \\<union>. \\<Union>.map2\n                                   (\\<lambda>v k. |[v \\<mapsto> k]|)\n                                   (map (\\<lambda>v. (v, b)) vs) ds", "by (auto intro:smap_union_mono simp add:venv_approx_def)"], ["proof (state)\nthis:\n  |ve| \\<union>. |map_of\n                   (rev (zip (map (\\<lambda>v. (v, b)) vs)\n                          ds))| \\<lessapprox> ve_a \\<union>. \\<Union>.map2\n                                 (\\<lambda>v k. |[v \\<mapsto> k]|)\n                                 (map (\\<lambda>v. (v, b)) vs) ds\n\ngoal (4 subgoals):\n 1. \\<And>x2a x1a x2aa x3.\n       \\<lbrakk>length x2aa = length ds_a;\n        fstate = (DC (Lambda x1a x2aa x3, x2a), ds, ve, b);\n        fstate_a = (PC (Lambda x1a x2aa x3, |x2a|), ds_a, ve_a, b_a);\n        |ve| \\<lessapprox> ve_a; map AbsCFCorrect.abs ds \\<lessapprox> ds_a;\n        length ds = length ds_a; d = DC (Lambda x1a x2aa x3, x2a);\n        proc = PC (Lambda x1a x2aa x3, |x2a|)\\<rbrakk>\n       \\<Longrightarrow> |evalC\\<cdot>\n                          (Discr\n                            (x3, x2a(x1a \\<mapsto> b), ve\n                             (map (\\<lambda>v. (v, b)) x2aa [\\<mapsto>] ds),\n                             b))| \\<lessapprox> \\<aF>\\<cdot>\n          (Discr (PC (Lambda x1a x2aa x3, |x2a|), ds_a, ve_a, b_a))\n 2. \\<And>x1 x1a x1aa x21b.\n       \\<lbrakk>fstate = (DP (Plus x1), [DI x1a, DI x1aa, x21b], ve, b);\n        fstate_a = (PP (Plus x1), ds_a, ve_a, b_a); |ve| \\<lessapprox> ve_a;\n        [{}, {}, |x21b|] \\<lessapprox> ds_a;\n        Suc (Suc (Suc 0)) = length ds_a; proc = PP (Plus x1);\n        d = DP (Plus x1); ds = [DI x1a, DI x1aa, x21b]; isProc x21b\\<rbrakk>\n       \\<Longrightarrow> |insert ((x1, [x1 \\<mapsto> b]), x21b)\n                           (evalF\\<cdot>\n                            (Discr\n                              (x21b, [DI (x1a + x1aa)], ve,\n                               nb b\n                                x1)))| \\<lessapprox> \\<aF>\\<cdot>\n               (Discr (PP (Plus x1), ds_a, ve_a, b_a))\n 3. \\<And>x21 x22 x1 x21aa x21aaa.\n       \\<lbrakk>fstate =\n                (DP (prim.If x21 x22), [DI x1, x21aa, x21aaa], ve, b);\n        fstate_a = (PP (prim.If x21 x22), ds_a, ve_a, b_a);\n        |ve| \\<lessapprox> ve_a; [{}, |x21aa|, |x21aaa|] \\<lessapprox> ds_a;\n        Suc (Suc (Suc 0)) = length ds_a; proc = PP (prim.If x21 x22);\n        d = DP (prim.If x21 x22); ds = [DI x1, x21aa, x21aaa];\n        x1 \\<noteq> 0; isProc x21aa; isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> |insert ((x21, [x21 \\<mapsto> b]), x21aa)\n                           (evalF\\<cdot>\n                            (Discr\n                              (x21aa, [], ve,\n                               nb b\n                                x21)))| \\<lessapprox> \\<aF>\\<cdot>\n                (Discr (PP (prim.If x21 x22), ds_a, ve_a, b_a))\n 4. \\<And>x21 x22 x21aa x21aaa.\n       \\<lbrakk>fstate =\n                (DP (prim.If x21 x22), [DI 0, x21aa, x21aaa], ve, b);\n        fstate_a = (PP (prim.If x21 x22), ds_a, ve_a, b_a);\n        |ve| \\<lessapprox> ve_a; [{}, |x21aa|, |x21aaa|] \\<lessapprox> ds_a;\n        Suc (Suc (Suc 0)) = length ds_a; proc = PP (prim.If x21 x22);\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa]; isProc x21aa;\n        isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> |insert ((x22, [x22 \\<mapsto> b]), x21aaa)\n                           (evalF\\<cdot>\n                            (Discr\n                              (x21aaa, [], ve,\n                               nb b\n                                x22)))| \\<lessapprox> \\<aF>\\<cdot>\n                (Discr (PP (prim.If x21 x22), ds_a, ve_a, b_a))", "also"], ["proof (state)\nthis:\n  |ve| \\<union>. |map_of\n                   (rev (zip (map (\\<lambda>v. (v, b)) vs)\n                          ds))| \\<lessapprox> ve_a \\<union>. \\<Union>.map2\n                                 (\\<lambda>v k. |[v \\<mapsto> k]|)\n                                 (map (\\<lambda>v. (v, b)) vs) ds\n\ngoal (4 subgoals):\n 1. \\<And>x2a x1a x2aa x3.\n       \\<lbrakk>length x2aa = length ds_a;\n        fstate = (DC (Lambda x1a x2aa x3, x2a), ds, ve, b);\n        fstate_a = (PC (Lambda x1a x2aa x3, |x2a|), ds_a, ve_a, b_a);\n        |ve| \\<lessapprox> ve_a; map AbsCFCorrect.abs ds \\<lessapprox> ds_a;\n        length ds = length ds_a; d = DC (Lambda x1a x2aa x3, x2a);\n        proc = PC (Lambda x1a x2aa x3, |x2a|)\\<rbrakk>\n       \\<Longrightarrow> |evalC\\<cdot>\n                          (Discr\n                            (x3, x2a(x1a \\<mapsto> b), ve\n                             (map (\\<lambda>v. (v, b)) x2aa [\\<mapsto>] ds),\n                             b))| \\<lessapprox> \\<aF>\\<cdot>\n          (Discr (PC (Lambda x1a x2aa x3, |x2a|), ds_a, ve_a, b_a))\n 2. \\<And>x1 x1a x1aa x21b.\n       \\<lbrakk>fstate = (DP (Plus x1), [DI x1a, DI x1aa, x21b], ve, b);\n        fstate_a = (PP (Plus x1), ds_a, ve_a, b_a); |ve| \\<lessapprox> ve_a;\n        [{}, {}, |x21b|] \\<lessapprox> ds_a;\n        Suc (Suc (Suc 0)) = length ds_a; proc = PP (Plus x1);\n        d = DP (Plus x1); ds = [DI x1a, DI x1aa, x21b]; isProc x21b\\<rbrakk>\n       \\<Longrightarrow> |insert ((x1, [x1 \\<mapsto> b]), x21b)\n                           (evalF\\<cdot>\n                            (Discr\n                              (x21b, [DI (x1a + x1aa)], ve,\n                               nb b\n                                x1)))| \\<lessapprox> \\<aF>\\<cdot>\n               (Discr (PP (Plus x1), ds_a, ve_a, b_a))\n 3. \\<And>x21 x22 x1 x21aa x21aaa.\n       \\<lbrakk>fstate =\n                (DP (prim.If x21 x22), [DI x1, x21aa, x21aaa], ve, b);\n        fstate_a = (PP (prim.If x21 x22), ds_a, ve_a, b_a);\n        |ve| \\<lessapprox> ve_a; [{}, |x21aa|, |x21aaa|] \\<lessapprox> ds_a;\n        Suc (Suc (Suc 0)) = length ds_a; proc = PP (prim.If x21 x22);\n        d = DP (prim.If x21 x22); ds = [DI x1, x21aa, x21aaa];\n        x1 \\<noteq> 0; isProc x21aa; isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> |insert ((x21, [x21 \\<mapsto> b]), x21aa)\n                           (evalF\\<cdot>\n                            (Discr\n                              (x21aa, [], ve,\n                               nb b\n                                x21)))| \\<lessapprox> \\<aF>\\<cdot>\n                (Discr (PP (prim.If x21 x22), ds_a, ve_a, b_a))\n 4. \\<And>x21 x22 x21aa x21aaa.\n       \\<lbrakk>fstate =\n                (DP (prim.If x21 x22), [DI 0, x21aa, x21aaa], ve, b);\n        fstate_a = (PP (prim.If x21 x22), ds_a, ve_a, b_a);\n        |ve| \\<lessapprox> ve_a; [{}, |x21aa|, |x21aaa|] \\<lessapprox> ds_a;\n        Suc (Suc (Suc 0)) = length ds_a; proc = PP (prim.If x21 x22);\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa]; isProc x21aa;\n        isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> |insert ((x22, [x22 \\<mapsto> b]), x21aaa)\n                           (evalF\\<cdot>\n                            (Discr\n                              (x21aaa, [], ve,\n                               nb b\n                                x22)))| \\<lessapprox> \\<aF>\\<cdot>\n                (Discr (PP (prim.If x21 x22), ds_a, ve_a, b_a))", "have \"\\<dots> = ve_a \\<union>. (\\<Union>. (map (\\<lambda>(v,y). |[(v,b) \\<mapsto> y]| ) (zip vs ds)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ve_a \\<union>. \\<Union>.map2 (\\<lambda>v k. |[v \\<mapsto> k]|)\n                             (map (\\<lambda>v. (v, b)) vs) ds =\n    ve_a \\<union>. \\<Union>.map2 (\\<lambda>v y. |[(v, b) \\<mapsto> y]|) vs\n                             ds", "by (auto simp add: zip_map1 o_def split_def)"], ["proof (state)\nthis:\n  ve_a \\<union>. \\<Union>.map2 (\\<lambda>v k. |[v \\<mapsto> k]|)\n                           (map (\\<lambda>v. (v, b)) vs) ds =\n  ve_a \\<union>. \\<Union>.map2 (\\<lambda>v y. |[(v, b) \\<mapsto> y]|) vs ds\n\ngoal (4 subgoals):\n 1. \\<And>x2a x1a x2aa x3.\n       \\<lbrakk>length x2aa = length ds_a;\n        fstate = (DC (Lambda x1a x2aa x3, x2a), ds, ve, b);\n        fstate_a = (PC (Lambda x1a x2aa x3, |x2a|), ds_a, ve_a, b_a);\n        |ve| \\<lessapprox> ve_a; map AbsCFCorrect.abs ds \\<lessapprox> ds_a;\n        length ds = length ds_a; d = DC (Lambda x1a x2aa x3, x2a);\n        proc = PC (Lambda x1a x2aa x3, |x2a|)\\<rbrakk>\n       \\<Longrightarrow> |evalC\\<cdot>\n                          (Discr\n                            (x3, x2a(x1a \\<mapsto> b), ve\n                             (map (\\<lambda>v. (v, b)) x2aa [\\<mapsto>] ds),\n                             b))| \\<lessapprox> \\<aF>\\<cdot>\n          (Discr (PC (Lambda x1a x2aa x3, |x2a|), ds_a, ve_a, b_a))\n 2. \\<And>x1 x1a x1aa x21b.\n       \\<lbrakk>fstate = (DP (Plus x1), [DI x1a, DI x1aa, x21b], ve, b);\n        fstate_a = (PP (Plus x1), ds_a, ve_a, b_a); |ve| \\<lessapprox> ve_a;\n        [{}, {}, |x21b|] \\<lessapprox> ds_a;\n        Suc (Suc (Suc 0)) = length ds_a; proc = PP (Plus x1);\n        d = DP (Plus x1); ds = [DI x1a, DI x1aa, x21b]; isProc x21b\\<rbrakk>\n       \\<Longrightarrow> |insert ((x1, [x1 \\<mapsto> b]), x21b)\n                           (evalF\\<cdot>\n                            (Discr\n                              (x21b, [DI (x1a + x1aa)], ve,\n                               nb b\n                                x1)))| \\<lessapprox> \\<aF>\\<cdot>\n               (Discr (PP (Plus x1), ds_a, ve_a, b_a))\n 3. \\<And>x21 x22 x1 x21aa x21aaa.\n       \\<lbrakk>fstate =\n                (DP (prim.If x21 x22), [DI x1, x21aa, x21aaa], ve, b);\n        fstate_a = (PP (prim.If x21 x22), ds_a, ve_a, b_a);\n        |ve| \\<lessapprox> ve_a; [{}, |x21aa|, |x21aaa|] \\<lessapprox> ds_a;\n        Suc (Suc (Suc 0)) = length ds_a; proc = PP (prim.If x21 x22);\n        d = DP (prim.If x21 x22); ds = [DI x1, x21aa, x21aaa];\n        x1 \\<noteq> 0; isProc x21aa; isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> |insert ((x21, [x21 \\<mapsto> b]), x21aa)\n                           (evalF\\<cdot>\n                            (Discr\n                              (x21aa, [], ve,\n                               nb b\n                                x21)))| \\<lessapprox> \\<aF>\\<cdot>\n                (Discr (PP (prim.If x21 x22), ds_a, ve_a, b_a))\n 4. \\<And>x21 x22 x21aa x21aaa.\n       \\<lbrakk>fstate =\n                (DP (prim.If x21 x22), [DI 0, x21aa, x21aaa], ve, b);\n        fstate_a = (PP (prim.If x21 x22), ds_a, ve_a, b_a);\n        |ve| \\<lessapprox> ve_a; [{}, |x21aa|, |x21aaa|] \\<lessapprox> ds_a;\n        Suc (Suc (Suc 0)) = length ds_a; proc = PP (prim.If x21 x22);\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa]; isProc x21aa;\n        isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> |insert ((x22, [x22 \\<mapsto> b]), x21aaa)\n                           (evalF\\<cdot>\n                            (Discr\n                              (x21aaa, [], ve,\n                               nb b\n                                x22)))| \\<lessapprox> \\<aF>\\<cdot>\n                (Discr (PP (prim.If x21 x22), ds_a, ve_a, b_a))", "also"], ["proof (state)\nthis:\n  ve_a \\<union>. \\<Union>.map2 (\\<lambda>v k. |[v \\<mapsto> k]|)\n                           (map (\\<lambda>v. (v, b)) vs) ds =\n  ve_a \\<union>. \\<Union>.map2 (\\<lambda>v y. |[(v, b) \\<mapsto> y]|) vs ds\n\ngoal (4 subgoals):\n 1. \\<And>x2a x1a x2aa x3.\n       \\<lbrakk>length x2aa = length ds_a;\n        fstate = (DC (Lambda x1a x2aa x3, x2a), ds, ve, b);\n        fstate_a = (PC (Lambda x1a x2aa x3, |x2a|), ds_a, ve_a, b_a);\n        |ve| \\<lessapprox> ve_a; map AbsCFCorrect.abs ds \\<lessapprox> ds_a;\n        length ds = length ds_a; d = DC (Lambda x1a x2aa x3, x2a);\n        proc = PC (Lambda x1a x2aa x3, |x2a|)\\<rbrakk>\n       \\<Longrightarrow> |evalC\\<cdot>\n                          (Discr\n                            (x3, x2a(x1a \\<mapsto> b), ve\n                             (map (\\<lambda>v. (v, b)) x2aa [\\<mapsto>] ds),\n                             b))| \\<lessapprox> \\<aF>\\<cdot>\n          (Discr (PC (Lambda x1a x2aa x3, |x2a|), ds_a, ve_a, b_a))\n 2. \\<And>x1 x1a x1aa x21b.\n       \\<lbrakk>fstate = (DP (Plus x1), [DI x1a, DI x1aa, x21b], ve, b);\n        fstate_a = (PP (Plus x1), ds_a, ve_a, b_a); |ve| \\<lessapprox> ve_a;\n        [{}, {}, |x21b|] \\<lessapprox> ds_a;\n        Suc (Suc (Suc 0)) = length ds_a; proc = PP (Plus x1);\n        d = DP (Plus x1); ds = [DI x1a, DI x1aa, x21b]; isProc x21b\\<rbrakk>\n       \\<Longrightarrow> |insert ((x1, [x1 \\<mapsto> b]), x21b)\n                           (evalF\\<cdot>\n                            (Discr\n                              (x21b, [DI (x1a + x1aa)], ve,\n                               nb b\n                                x1)))| \\<lessapprox> \\<aF>\\<cdot>\n               (Discr (PP (Plus x1), ds_a, ve_a, b_a))\n 3. \\<And>x21 x22 x1 x21aa x21aaa.\n       \\<lbrakk>fstate =\n                (DP (prim.If x21 x22), [DI x1, x21aa, x21aaa], ve, b);\n        fstate_a = (PP (prim.If x21 x22), ds_a, ve_a, b_a);\n        |ve| \\<lessapprox> ve_a; [{}, |x21aa|, |x21aaa|] \\<lessapprox> ds_a;\n        Suc (Suc (Suc 0)) = length ds_a; proc = PP (prim.If x21 x22);\n        d = DP (prim.If x21 x22); ds = [DI x1, x21aa, x21aaa];\n        x1 \\<noteq> 0; isProc x21aa; isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> |insert ((x21, [x21 \\<mapsto> b]), x21aa)\n                           (evalF\\<cdot>\n                            (Discr\n                              (x21aa, [], ve,\n                               nb b\n                                x21)))| \\<lessapprox> \\<aF>\\<cdot>\n                (Discr (PP (prim.If x21 x22), ds_a, ve_a, b_a))\n 4. \\<And>x21 x22 x21aa x21aaa.\n       \\<lbrakk>fstate =\n                (DP (prim.If x21 x22), [DI 0, x21aa, x21aaa], ve, b);\n        fstate_a = (PP (prim.If x21 x22), ds_a, ve_a, b_a);\n        |ve| \\<lessapprox> ve_a; [{}, |x21aa|, |x21aaa|] \\<lessapprox> ds_a;\n        Suc (Suc (Suc 0)) = length ds_a; proc = PP (prim.If x21 x22);\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa]; isProc x21aa;\n        isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> |insert ((x22, [x22 \\<mapsto> b]), x21aaa)\n                           (evalF\\<cdot>\n                            (Discr\n                              (x21aaa, [], ve,\n                               nb b\n                                x22)))| \\<lessapprox> \\<aF>\\<cdot>\n                (Discr (PP (prim.If x21 x22), ds_a, ve_a, b_a))", "have \"\\<dots> \\<lessapprox> ve_a \\<union>. (\\<Union>. (map (\\<lambda>(v,y). {(v,b_a) := y}.) (zip vs ds_a)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ve_a \\<union>. \\<Union>.map2 (\\<lambda>v y. |[(v, b) \\<mapsto> y]|) vs\n                             ds \\<lessapprox> ve_a \\<union>. \\<Union>.map2\n                                 (\\<lambda>v. smap_singleton (v, b_a)) vs\n                                 ds_a", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. ve_a \\<union>. \\<Union>.map2 (\\<lambda>v y. |[(v, b) \\<mapsto> y]|) vs\n                             ds \\<lessapprox> ve_a \\<union>. \\<Union>.map2\n                                 (\\<lambda>v. smap_singleton (v, b_a)) vs\n                                 ds_a", "from abs_b abs_ds"], ["proof (chain)\npicking this:\n  |b| = b_a\n  map AbsCFCorrect.abs ds \\<lessapprox> ds_a", "have \"list_all2 venv_approx (map (\\<lambda>(v, y). |[(v, b) \\<mapsto> y]| ) (zip vs ds))\n                                  (map (\\<lambda>(v, y). {(v,b_a) := y}.) (zip vs ds_a))\""], ["proof (prove)\nusing this:\n  |b| = b_a\n  map AbsCFCorrect.abs ds \\<lessapprox> ds_a\n\ngoal (1 subgoal):\n 1. list_all2 approx (map2 (\\<lambda>v y. |[(v, b) \\<mapsto> y]|) vs ds)\n     (map2 (\\<lambda>v. smap_singleton (v, b_a)) vs ds_a)", "by (auto simp add: ds_approx_def d_approx_def venv_approx_def abs_venv_singleton list_all2_conv_all_nth intro:smap_singleton_mono list_all2I)"], ["proof (state)\nthis:\n  list_all2 approx (map2 (\\<lambda>v y. |[(v, b) \\<mapsto> y]|) vs ds)\n   (map2 (\\<lambda>v. smap_singleton (v, b_a)) vs ds_a)\n\ngoal (1 subgoal):\n 1. ve_a \\<union>. \\<Union>.map2 (\\<lambda>v y. |[(v, b) \\<mapsto> y]|) vs\n                             ds \\<lessapprox> ve_a \\<union>. \\<Union>.map2\n                                 (\\<lambda>v. smap_singleton (v, b_a)) vs\n                                 ds_a", "thus ?thesis"], ["proof (prove)\nusing this:\n  list_all2 approx (map2 (\\<lambda>v y. |[(v, b) \\<mapsto> y]|) vs ds)\n   (map2 (\\<lambda>v. smap_singleton (v, b_a)) vs ds_a)\n\ngoal (1 subgoal):\n 1. ve_a \\<union>. \\<Union>.map2 (\\<lambda>v y. |[(v, b) \\<mapsto> y]|) vs\n                             ds \\<lessapprox> ve_a \\<union>. \\<Union>.map2\n                                 (\\<lambda>v. smap_singleton (v, b_a)) vs\n                                 ds_a", "by (auto simp add:venv_approx_def intro: smap_union_mono[OF smap_less_refl smap_Union_mono])"], ["proof (state)\nthis:\n  ve_a \\<union>. \\<Union>.map2 (\\<lambda>v y. |[(v, b) \\<mapsto> y]|) vs\n                           ds \\<lessapprox> ve_a \\<union>. \\<Union>.map2\n                               (\\<lambda>v. smap_singleton (v, b_a)) vs ds_a\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ve_a \\<union>. \\<Union>.map2 (\\<lambda>v y. |[(v, b) \\<mapsto> y]|) vs\n                           ds \\<lessapprox> ve_a \\<union>. \\<Union>.map2\n                               (\\<lambda>v. smap_singleton (v, b_a)) vs ds_a\n\ngoal (4 subgoals):\n 1. \\<And>x2a x1a x2aa x3.\n       \\<lbrakk>length x2aa = length ds_a;\n        fstate = (DC (Lambda x1a x2aa x3, x2a), ds, ve, b);\n        fstate_a = (PC (Lambda x1a x2aa x3, |x2a|), ds_a, ve_a, b_a);\n        |ve| \\<lessapprox> ve_a; map AbsCFCorrect.abs ds \\<lessapprox> ds_a;\n        length ds = length ds_a; d = DC (Lambda x1a x2aa x3, x2a);\n        proc = PC (Lambda x1a x2aa x3, |x2a|)\\<rbrakk>\n       \\<Longrightarrow> |evalC\\<cdot>\n                          (Discr\n                            (x3, x2a(x1a \\<mapsto> b), ve\n                             (map (\\<lambda>v. (v, b)) x2aa [\\<mapsto>] ds),\n                             b))| \\<lessapprox> \\<aF>\\<cdot>\n          (Discr (PC (Lambda x1a x2aa x3, |x2a|), ds_a, ve_a, b_a))\n 2. \\<And>x1 x1a x1aa x21b.\n       \\<lbrakk>fstate = (DP (Plus x1), [DI x1a, DI x1aa, x21b], ve, b);\n        fstate_a = (PP (Plus x1), ds_a, ve_a, b_a); |ve| \\<lessapprox> ve_a;\n        [{}, {}, |x21b|] \\<lessapprox> ds_a;\n        Suc (Suc (Suc 0)) = length ds_a; proc = PP (Plus x1);\n        d = DP (Plus x1); ds = [DI x1a, DI x1aa, x21b]; isProc x21b\\<rbrakk>\n       \\<Longrightarrow> |insert ((x1, [x1 \\<mapsto> b]), x21b)\n                           (evalF\\<cdot>\n                            (Discr\n                              (x21b, [DI (x1a + x1aa)], ve,\n                               nb b\n                                x1)))| \\<lessapprox> \\<aF>\\<cdot>\n               (Discr (PP (Plus x1), ds_a, ve_a, b_a))\n 3. \\<And>x21 x22 x1 x21aa x21aaa.\n       \\<lbrakk>fstate =\n                (DP (prim.If x21 x22), [DI x1, x21aa, x21aaa], ve, b);\n        fstate_a = (PP (prim.If x21 x22), ds_a, ve_a, b_a);\n        |ve| \\<lessapprox> ve_a; [{}, |x21aa|, |x21aaa|] \\<lessapprox> ds_a;\n        Suc (Suc (Suc 0)) = length ds_a; proc = PP (prim.If x21 x22);\n        d = DP (prim.If x21 x22); ds = [DI x1, x21aa, x21aaa];\n        x1 \\<noteq> 0; isProc x21aa; isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> |insert ((x21, [x21 \\<mapsto> b]), x21aa)\n                           (evalF\\<cdot>\n                            (Discr\n                              (x21aa, [], ve,\n                               nb b\n                                x21)))| \\<lessapprox> \\<aF>\\<cdot>\n                (Discr (PP (prim.If x21 x22), ds_a, ve_a, b_a))\n 4. \\<And>x21 x22 x21aa x21aaa.\n       \\<lbrakk>fstate =\n                (DP (prim.If x21 x22), [DI 0, x21aa, x21aaa], ve, b);\n        fstate_a = (PP (prim.If x21 x22), ds_a, ve_a, b_a);\n        |ve| \\<lessapprox> ve_a; [{}, |x21aa|, |x21aaa|] \\<lessapprox> ds_a;\n        Suc (Suc (Suc 0)) = length ds_a; proc = PP (prim.If x21 x22);\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa]; isProc x21aa;\n        isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> |insert ((x22, [x22 \\<mapsto> b]), x21aaa)\n                           (evalF\\<cdot>\n                            (Discr\n                              (x21aaa, [], ve,\n                               nb b\n                                x22)))| \\<lessapprox> \\<aF>\\<cdot>\n                (Discr (PP (prim.If x21 x22), ds_a, ve_a, b_a))", "finally"], ["proof (chain)\npicking this:\n  |ve(map (\\<lambda>v. (v, b)) vs [\\<mapsto>]\n  ds)| \\<lessapprox> ve_a \\<union>. \\<Union>.map2\n        (\\<lambda>v. smap_singleton (v, b_a)) vs ds_a", "have \"|ve(map (\\<lambda>v. (v, b)) vs [\\<mapsto>] ds)|\n          \\<lessapprox> ve_a \\<union>. (\\<Union>. (map (\\<lambda>(v,y). {(v, b_a) := y}.) (zip vs ds_a)))\""], ["proof (prove)\nusing this:\n  |ve(map (\\<lambda>v. (v, b)) vs [\\<mapsto>]\n  ds)| \\<lessapprox> ve_a \\<union>. \\<Union>.map2\n        (\\<lambda>v. smap_singleton (v, b_a)) vs ds_a\n\ngoal (1 subgoal):\n 1. |ve(map (\\<lambda>v. (v, b)) vs [\\<mapsto>]\n    ds)| \\<lessapprox> ve_a \\<union>. \\<Union>.map2\n          (\\<lambda>v. smap_singleton (v, b_a)) vs ds_a", "."], ["proof (state)\nthis:\n  |ve(map (\\<lambda>v. (v, b)) vs [\\<mapsto>]\n  ds)| \\<lessapprox> ve_a \\<union>. \\<Union>.map2\n        (\\<lambda>v. smap_singleton (v, b_a)) vs ds_a\n\ngoal (4 subgoals):\n 1. \\<And>x2a x1a x2aa x3.\n       \\<lbrakk>length x2aa = length ds_a;\n        fstate = (DC (Lambda x1a x2aa x3, x2a), ds, ve, b);\n        fstate_a = (PC (Lambda x1a x2aa x3, |x2a|), ds_a, ve_a, b_a);\n        |ve| \\<lessapprox> ve_a; map AbsCFCorrect.abs ds \\<lessapprox> ds_a;\n        length ds = length ds_a; d = DC (Lambda x1a x2aa x3, x2a);\n        proc = PC (Lambda x1a x2aa x3, |x2a|)\\<rbrakk>\n       \\<Longrightarrow> |evalC\\<cdot>\n                          (Discr\n                            (x3, x2a(x1a \\<mapsto> b), ve\n                             (map (\\<lambda>v. (v, b)) x2aa [\\<mapsto>] ds),\n                             b))| \\<lessapprox> \\<aF>\\<cdot>\n          (Discr (PC (Lambda x1a x2aa x3, |x2a|), ds_a, ve_a, b_a))\n 2. \\<And>x1 x1a x1aa x21b.\n       \\<lbrakk>fstate = (DP (Plus x1), [DI x1a, DI x1aa, x21b], ve, b);\n        fstate_a = (PP (Plus x1), ds_a, ve_a, b_a); |ve| \\<lessapprox> ve_a;\n        [{}, {}, |x21b|] \\<lessapprox> ds_a;\n        Suc (Suc (Suc 0)) = length ds_a; proc = PP (Plus x1);\n        d = DP (Plus x1); ds = [DI x1a, DI x1aa, x21b]; isProc x21b\\<rbrakk>\n       \\<Longrightarrow> |insert ((x1, [x1 \\<mapsto> b]), x21b)\n                           (evalF\\<cdot>\n                            (Discr\n                              (x21b, [DI (x1a + x1aa)], ve,\n                               nb b\n                                x1)))| \\<lessapprox> \\<aF>\\<cdot>\n               (Discr (PP (Plus x1), ds_a, ve_a, b_a))\n 3. \\<And>x21 x22 x1 x21aa x21aaa.\n       \\<lbrakk>fstate =\n                (DP (prim.If x21 x22), [DI x1, x21aa, x21aaa], ve, b);\n        fstate_a = (PP (prim.If x21 x22), ds_a, ve_a, b_a);\n        |ve| \\<lessapprox> ve_a; [{}, |x21aa|, |x21aaa|] \\<lessapprox> ds_a;\n        Suc (Suc (Suc 0)) = length ds_a; proc = PP (prim.If x21 x22);\n        d = DP (prim.If x21 x22); ds = [DI x1, x21aa, x21aaa];\n        x1 \\<noteq> 0; isProc x21aa; isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> |insert ((x21, [x21 \\<mapsto> b]), x21aa)\n                           (evalF\\<cdot>\n                            (Discr\n                              (x21aa, [], ve,\n                               nb b\n                                x21)))| \\<lessapprox> \\<aF>\\<cdot>\n                (Discr (PP (prim.If x21 x22), ds_a, ve_a, b_a))\n 4. \\<And>x21 x22 x21aa x21aaa.\n       \\<lbrakk>fstate =\n                (DP (prim.If x21 x22), [DI 0, x21aa, x21aaa], ve, b);\n        fstate_a = (PP (prim.If x21 x22), ds_a, ve_a, b_a);\n        |ve| \\<lessapprox> ve_a; [{}, |x21aa|, |x21aaa|] \\<lessapprox> ds_a;\n        Suc (Suc (Suc 0)) = length ds_a; proc = PP (prim.If x21 x22);\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa]; isProc x21aa;\n        isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> |insert ((x22, [x22 \\<mapsto> b]), x21aaa)\n                           (evalF\\<cdot>\n                            (Discr\n                              (x21aaa, [], ve,\n                               nb b\n                                x22)))| \\<lessapprox> \\<aF>\\<cdot>\n                (Discr (PP (prim.If x21 x22), ds_a, ve_a, b_a))", "}"], ["proof (state)\nthis:\n  |ve(map (\\<lambda>v. (v, b)) vs [\\<mapsto>]\n  ds)| \\<lessapprox> ve_a \\<union>. \\<Union>.map2\n        (\\<lambda>v. smap_singleton (v, b_a)) vs ds_a\n\ngoal (4 subgoals):\n 1. \\<And>x2a x1a x2aa x3.\n       \\<lbrakk>length x2aa = length ds_a;\n        fstate = (DC (Lambda x1a x2aa x3, x2a), ds, ve, b);\n        fstate_a = (PC (Lambda x1a x2aa x3, |x2a|), ds_a, ve_a, b_a);\n        |ve| \\<lessapprox> ve_a; map AbsCFCorrect.abs ds \\<lessapprox> ds_a;\n        length ds = length ds_a; d = DC (Lambda x1a x2aa x3, x2a);\n        proc = PC (Lambda x1a x2aa x3, |x2a|)\\<rbrakk>\n       \\<Longrightarrow> |evalC\\<cdot>\n                          (Discr\n                            (x3, x2a(x1a \\<mapsto> b), ve\n                             (map (\\<lambda>v. (v, b)) x2aa [\\<mapsto>] ds),\n                             b))| \\<lessapprox> \\<aF>\\<cdot>\n          (Discr (PC (Lambda x1a x2aa x3, |x2a|), ds_a, ve_a, b_a))\n 2. \\<And>x1 x1a x1aa x21b.\n       \\<lbrakk>fstate = (DP (Plus x1), [DI x1a, DI x1aa, x21b], ve, b);\n        fstate_a = (PP (Plus x1), ds_a, ve_a, b_a); |ve| \\<lessapprox> ve_a;\n        [{}, {}, |x21b|] \\<lessapprox> ds_a;\n        Suc (Suc (Suc 0)) = length ds_a; proc = PP (Plus x1);\n        d = DP (Plus x1); ds = [DI x1a, DI x1aa, x21b]; isProc x21b\\<rbrakk>\n       \\<Longrightarrow> |insert ((x1, [x1 \\<mapsto> b]), x21b)\n                           (evalF\\<cdot>\n                            (Discr\n                              (x21b, [DI (x1a + x1aa)], ve,\n                               nb b\n                                x1)))| \\<lessapprox> \\<aF>\\<cdot>\n               (Discr (PP (Plus x1), ds_a, ve_a, b_a))\n 3. \\<And>x21 x22 x1 x21aa x21aaa.\n       \\<lbrakk>fstate =\n                (DP (prim.If x21 x22), [DI x1, x21aa, x21aaa], ve, b);\n        fstate_a = (PP (prim.If x21 x22), ds_a, ve_a, b_a);\n        |ve| \\<lessapprox> ve_a; [{}, |x21aa|, |x21aaa|] \\<lessapprox> ds_a;\n        Suc (Suc (Suc 0)) = length ds_a; proc = PP (prim.If x21 x22);\n        d = DP (prim.If x21 x22); ds = [DI x1, x21aa, x21aaa];\n        x1 \\<noteq> 0; isProc x21aa; isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> |insert ((x21, [x21 \\<mapsto> b]), x21aa)\n                           (evalF\\<cdot>\n                            (Discr\n                              (x21aa, [], ve,\n                               nb b\n                                x21)))| \\<lessapprox> \\<aF>\\<cdot>\n                (Discr (PP (prim.If x21 x22), ds_a, ve_a, b_a))\n 4. \\<And>x21 x22 x21aa x21aaa.\n       \\<lbrakk>fstate =\n                (DP (prim.If x21 x22), [DI 0, x21aa, x21aaa], ve, b);\n        fstate_a = (PP (prim.If x21 x22), ds_a, ve_a, b_a);\n        |ve| \\<lessapprox> ve_a; [{}, |x21aa|, |x21aaa|] \\<lessapprox> ds_a;\n        Suc (Suc (Suc 0)) = length ds_a; proc = PP (prim.If x21 x22);\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa]; isProc x21aa;\n        isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> |insert ((x22, [x22 \\<mapsto> b]), x21aaa)\n                           (evalF\\<cdot>\n                            (Discr\n                              (x21aaa, [], ve,\n                               nb b\n                                x22)))| \\<lessapprox> \\<aF>\\<cdot>\n                (Discr (PP (prim.If x21 x22), ds_a, ve_a, b_a))", "ultimately"], ["proof (chain)\npicking this:\n  |\\<beta>(lab \\<mapsto> b)| = |\\<beta>|(lab \\<mapsto> b_a)\n  |ve(map (\\<lambda>v. (v, b)) vs [\\<mapsto>]\n  ds)| \\<lessapprox> ve_a \\<union>. \\<Union>.map2\n        (\\<lambda>v. smap_singleton (v, b_a)) vs ds_a", "have prem: \"|(c, \\<beta>(lab \\<mapsto> b), ve(map (\\<lambda>v. (v, b)) vs [\\<mapsto>] ds), b)|\n        \\<lessapprox> (c,  |\\<beta>|(lab \\<mapsto> b_a), ve_a \\<union>. (\\<Union>.(map (\\<lambda>(v, y). {(v, b_a) := y}.) (zip vs ds_a))), b_a)\""], ["proof (prove)\nusing this:\n  |\\<beta>(lab \\<mapsto> b)| = |\\<beta>|(lab \\<mapsto> b_a)\n  |ve(map (\\<lambda>v. (v, b)) vs [\\<mapsto>]\n  ds)| \\<lessapprox> ve_a \\<union>. \\<Union>.map2\n        (\\<lambda>v. smap_singleton (v, b_a)) vs ds_a\n\ngoal (1 subgoal):\n 1. |(c, \\<beta>(lab \\<mapsto> b), ve(map (\\<lambda>v. (v, b)) vs \n      [\\<mapsto>] ds),\n      b)| \\<lessapprox> (c, |\\<beta>|(lab \\<mapsto> b_a),\n                         ve_a \\<union>. \\<Union>.map2\n            (\\<lambda>v. smap_singleton (v, b_a)) vs ds_a,\n                         b_a)", "using abs_b"], ["proof (prove)\nusing this:\n  |\\<beta>(lab \\<mapsto> b)| = |\\<beta>|(lab \\<mapsto> b_a)\n  |ve(map (\\<lambda>v. (v, b)) vs [\\<mapsto>]\n  ds)| \\<lessapprox> ve_a \\<union>. \\<Union>.map2\n        (\\<lambda>v. smap_singleton (v, b_a)) vs ds_a\n  |b| = b_a\n\ngoal (1 subgoal):\n 1. |(c, \\<beta>(lab \\<mapsto> b), ve(map (\\<lambda>v. (v, b)) vs \n      [\\<mapsto>] ds),\n      b)| \\<lessapprox> (c, |\\<beta>|(lab \\<mapsto> b_a),\n                         ve_a \\<union>. \\<Union>.map2\n            (\\<lambda>v. smap_singleton (v, b_a)) vs ds_a,\n                         b_a)", "by(auto intro:cstate_approx.intros simp add: abs_cstate.simps)"], ["proof (state)\nthis:\n  |(c, \\<beta>(lab \\<mapsto> b), ve(map (\\<lambda>v. (v, b)) vs [\\<mapsto>]\n    ds),\n    b)| \\<lessapprox> (c, |\\<beta>|(lab \\<mapsto> b_a),\n                       ve_a \\<union>. \\<Union>.map2\n          (\\<lambda>v. smap_singleton (v, b_a)) vs ds_a,\n                       b_a)\n\ngoal (4 subgoals):\n 1. \\<And>x2a x1a x2aa x3.\n       \\<lbrakk>length x2aa = length ds_a;\n        fstate = (DC (Lambda x1a x2aa x3, x2a), ds, ve, b);\n        fstate_a = (PC (Lambda x1a x2aa x3, |x2a|), ds_a, ve_a, b_a);\n        |ve| \\<lessapprox> ve_a; map AbsCFCorrect.abs ds \\<lessapprox> ds_a;\n        length ds = length ds_a; d = DC (Lambda x1a x2aa x3, x2a);\n        proc = PC (Lambda x1a x2aa x3, |x2a|)\\<rbrakk>\n       \\<Longrightarrow> |evalC\\<cdot>\n                          (Discr\n                            (x3, x2a(x1a \\<mapsto> b), ve\n                             (map (\\<lambda>v. (v, b)) x2aa [\\<mapsto>] ds),\n                             b))| \\<lessapprox> \\<aF>\\<cdot>\n          (Discr (PC (Lambda x1a x2aa x3, |x2a|), ds_a, ve_a, b_a))\n 2. \\<And>x1 x1a x1aa x21b.\n       \\<lbrakk>fstate = (DP (Plus x1), [DI x1a, DI x1aa, x21b], ve, b);\n        fstate_a = (PP (Plus x1), ds_a, ve_a, b_a); |ve| \\<lessapprox> ve_a;\n        [{}, {}, |x21b|] \\<lessapprox> ds_a;\n        Suc (Suc (Suc 0)) = length ds_a; proc = PP (Plus x1);\n        d = DP (Plus x1); ds = [DI x1a, DI x1aa, x21b]; isProc x21b\\<rbrakk>\n       \\<Longrightarrow> |insert ((x1, [x1 \\<mapsto> b]), x21b)\n                           (evalF\\<cdot>\n                            (Discr\n                              (x21b, [DI (x1a + x1aa)], ve,\n                               nb b\n                                x1)))| \\<lessapprox> \\<aF>\\<cdot>\n               (Discr (PP (Plus x1), ds_a, ve_a, b_a))\n 3. \\<And>x21 x22 x1 x21aa x21aaa.\n       \\<lbrakk>fstate =\n                (DP (prim.If x21 x22), [DI x1, x21aa, x21aaa], ve, b);\n        fstate_a = (PP (prim.If x21 x22), ds_a, ve_a, b_a);\n        |ve| \\<lessapprox> ve_a; [{}, |x21aa|, |x21aaa|] \\<lessapprox> ds_a;\n        Suc (Suc (Suc 0)) = length ds_a; proc = PP (prim.If x21 x22);\n        d = DP (prim.If x21 x22); ds = [DI x1, x21aa, x21aaa];\n        x1 \\<noteq> 0; isProc x21aa; isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> |insert ((x21, [x21 \\<mapsto> b]), x21aa)\n                           (evalF\\<cdot>\n                            (Discr\n                              (x21aa, [], ve,\n                               nb b\n                                x21)))| \\<lessapprox> \\<aF>\\<cdot>\n                (Discr (PP (prim.If x21 x22), ds_a, ve_a, b_a))\n 4. \\<And>x21 x22 x21aa x21aaa.\n       \\<lbrakk>fstate =\n                (DP (prim.If x21 x22), [DI 0, x21aa, x21aaa], ve, b);\n        fstate_a = (PP (prim.If x21 x22), ds_a, ve_a, b_a);\n        |ve| \\<lessapprox> ve_a; [{}, |x21aa|, |x21aaa|] \\<lessapprox> ds_a;\n        Suc (Suc (Suc 0)) = length ds_a; proc = PP (prim.If x21 x22);\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa]; isProc x21aa;\n        isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> |insert ((x22, [x22 \\<mapsto> b]), x21aaa)\n                           (evalF\\<cdot>\n                            (Discr\n                              (x21aaa, [], ve,\n                               nb b\n                                x22)))| \\<lessapprox> \\<aF>\\<cdot>\n                (Discr (PP (prim.If x21 x22), ds_a, ve_a, b_a))", "show \"|evalC\\<cdot>(Discr (c, \\<beta>(lab \\<mapsto> b), ve(map (\\<lambda>v. (v, b)) vs [\\<mapsto>] ds), b))|\n        \\<lessapprox> \\<aF>\\<cdot>(Discr (PC (Lambda lab vs c, |\\<beta>| ), ds_a, ve_a, b_a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. |evalC\\<cdot>\n     (Discr\n       (c, \\<beta>(lab \\<mapsto> b), ve(map (\\<lambda>v. (v, b)) vs \n        [\\<mapsto>] ds),\n        b))| \\<lessapprox> \\<aF>\\<cdot>\n                           (Discr\n                             (PC (Lambda lab vs c, |\\<beta>|), ds_a, ve_a,\n                              b_a))", "using Next.hyps(2)[OF prem] ds_a_length"], ["proof (prove)\nusing this:\n  |evalC\\<cdot>\n   (Discr\n     (c, \\<beta>(lab \\<mapsto> b), ve(map (\\<lambda>v. (v, b)) vs \n      [\\<mapsto>] ds),\n      b))| \\<lessapprox> \\<aC>\\<cdot>\n                         (Discr\n                           (c, |\\<beta>|(lab \\<mapsto> b_a),\n                            ve_a \\<union>. \\<Union>.map2\n               (\\<lambda>v. smap_singleton (v, b_a)) vs ds_a,\n                            b_a))\n  length vs = length ds_a\n\ngoal (1 subgoal):\n 1. |evalC\\<cdot>\n     (Discr\n       (c, \\<beta>(lab \\<mapsto> b), ve(map (\\<lambda>v. (v, b)) vs \n        [\\<mapsto>] ds),\n        b))| \\<lessapprox> \\<aF>\\<cdot>\n                           (Discr\n                             (PC (Lambda lab vs c, |\\<beta>|), ds_a, ve_a,\n                              b_a))", "by (subst a_evalF.simps, simp del:a_evalF.simps a_evalC.simps)"], ["proof (state)\nthis:\n  |evalC\\<cdot>\n   (Discr\n     (c, \\<beta>(lab \\<mapsto> b), ve(map (\\<lambda>v. (v, b)) vs \n      [\\<mapsto>] ds),\n      b))| \\<lessapprox> \\<aF>\\<cdot>\n                         (Discr\n                           (PC (Lambda lab vs c, |\\<beta>|), ds_a, ve_a,\n                            b_a))\n\ngoal (3 subgoals):\n 1. \\<And>x1 x1a x1aa x21b.\n       \\<lbrakk>fstate = (DP (Plus x1), [DI x1a, DI x1aa, x21b], ve, b);\n        fstate_a = (PP (Plus x1), ds_a, ve_a, b_a); |ve| \\<lessapprox> ve_a;\n        [{}, {}, |x21b|] \\<lessapprox> ds_a;\n        Suc (Suc (Suc 0)) = length ds_a; proc = PP (Plus x1);\n        d = DP (Plus x1); ds = [DI x1a, DI x1aa, x21b]; isProc x21b\\<rbrakk>\n       \\<Longrightarrow> |insert ((x1, [x1 \\<mapsto> b]), x21b)\n                           (evalF\\<cdot>\n                            (Discr\n                              (x21b, [DI (x1a + x1aa)], ve,\n                               nb b\n                                x1)))| \\<lessapprox> \\<aF>\\<cdot>\n               (Discr (PP (Plus x1), ds_a, ve_a, b_a))\n 2. \\<And>x21 x22 x1 x21aa x21aaa.\n       \\<lbrakk>fstate =\n                (DP (prim.If x21 x22), [DI x1, x21aa, x21aaa], ve, b);\n        fstate_a = (PP (prim.If x21 x22), ds_a, ve_a, b_a);\n        |ve| \\<lessapprox> ve_a; [{}, |x21aa|, |x21aaa|] \\<lessapprox> ds_a;\n        Suc (Suc (Suc 0)) = length ds_a; proc = PP (prim.If x21 x22);\n        d = DP (prim.If x21 x22); ds = [DI x1, x21aa, x21aaa];\n        x1 \\<noteq> 0; isProc x21aa; isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> |insert ((x21, [x21 \\<mapsto> b]), x21aa)\n                           (evalF\\<cdot>\n                            (Discr\n                              (x21aa, [], ve,\n                               nb b\n                                x21)))| \\<lessapprox> \\<aF>\\<cdot>\n                (Discr (PP (prim.If x21 x22), ds_a, ve_a, b_a))\n 3. \\<And>x21 x22 x21aa x21aaa.\n       \\<lbrakk>fstate =\n                (DP (prim.If x21 x22), [DI 0, x21aa, x21aaa], ve, b);\n        fstate_a = (PP (prim.If x21 x22), ds_a, ve_a, b_a);\n        |ve| \\<lessapprox> ve_a; [{}, |x21aa|, |x21aaa|] \\<lessapprox> ds_a;\n        Suc (Suc (Suc 0)) = length ds_a; proc = PP (prim.If x21 x22);\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa]; isProc x21aa;\n        isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> |insert ((x22, [x22 \\<mapsto> b]), x21aaa)\n                           (evalF\\<cdot>\n                            (Discr\n                              (x21aaa, [], ve,\n                               nb b\n                                x22)))| \\<lessapprox> \\<aF>\\<cdot>\n                (Discr (PP (prim.If x21 x22), ds_a, ve_a, b_a))", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x1 x1a x1aa x21b.\n       \\<lbrakk>fstate = (DP (Plus x1), [DI x1a, DI x1aa, x21b], ve, b);\n        fstate_a = (PP (Plus x1), ds_a, ve_a, b_a); |ve| \\<lessapprox> ve_a;\n        [{}, {}, |x21b|] \\<lessapprox> ds_a;\n        Suc (Suc (Suc 0)) = length ds_a; proc = PP (Plus x1);\n        d = DP (Plus x1); ds = [DI x1a, DI x1aa, x21b]; isProc x21b\\<rbrakk>\n       \\<Longrightarrow> |insert ((x1, [x1 \\<mapsto> b]), x21b)\n                           (evalF\\<cdot>\n                            (Discr\n                              (x21b, [DI (x1a + x1aa)], ve,\n                               nb b\n                                x1)))| \\<lessapprox> \\<aF>\\<cdot>\n               (Discr (PP (Plus x1), ds_a, ve_a, b_a))\n 2. \\<And>x21 x22 x1 x21aa x21aaa.\n       \\<lbrakk>fstate =\n                (DP (prim.If x21 x22), [DI x1, x21aa, x21aaa], ve, b);\n        fstate_a = (PP (prim.If x21 x22), ds_a, ve_a, b_a);\n        |ve| \\<lessapprox> ve_a; [{}, |x21aa|, |x21aaa|] \\<lessapprox> ds_a;\n        Suc (Suc (Suc 0)) = length ds_a; proc = PP (prim.If x21 x22);\n        d = DP (prim.If x21 x22); ds = [DI x1, x21aa, x21aaa];\n        x1 \\<noteq> 0; isProc x21aa; isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> |insert ((x21, [x21 \\<mapsto> b]), x21aa)\n                           (evalF\\<cdot>\n                            (Discr\n                              (x21aa, [], ve,\n                               nb b\n                                x21)))| \\<lessapprox> \\<aF>\\<cdot>\n                (Discr (PP (prim.If x21 x22), ds_a, ve_a, b_a))\n 3. \\<And>x21 x22 x21aa x21aaa.\n       \\<lbrakk>fstate =\n                (DP (prim.If x21 x22), [DI 0, x21aa, x21aaa], ve, b);\n        fstate_a = (PP (prim.If x21 x22), ds_a, ve_a, b_a);\n        |ve| \\<lessapprox> ve_a; [{}, |x21aa|, |x21aaa|] \\<lessapprox> ds_a;\n        Suc (Suc (Suc 0)) = length ds_a; proc = PP (prim.If x21 x22);\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa]; isProc x21aa;\n        isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> |insert ((x22, [x22 \\<mapsto> b]), x21aaa)\n                           (evalF\\<cdot>\n                            (Discr\n                              (x21aaa, [], ve,\n                               nb b\n                                x22)))| \\<lessapprox> \\<aF>\\<cdot>\n                (Discr (PP (prim.If x21 x22), ds_a, ve_a, b_a))", "txt \\<open>Case Plus\\<close>"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x1 x1a x1aa x21b.\n       \\<lbrakk>fstate = (DP (Plus x1), [DI x1a, DI x1aa, x21b], ve, b);\n        fstate_a = (PP (Plus x1), ds_a, ve_a, b_a); |ve| \\<lessapprox> ve_a;\n        [{}, {}, |x21b|] \\<lessapprox> ds_a;\n        Suc (Suc (Suc 0)) = length ds_a; proc = PP (Plus x1);\n        d = DP (Plus x1); ds = [DI x1a, DI x1aa, x21b]; isProc x21b\\<rbrakk>\n       \\<Longrightarrow> |insert ((x1, [x1 \\<mapsto> b]), x21b)\n                           (evalF\\<cdot>\n                            (Discr\n                              (x21b, [DI (x1a + x1aa)], ve,\n                               nb b\n                                x1)))| \\<lessapprox> \\<aF>\\<cdot>\n               (Discr (PP (Plus x1), ds_a, ve_a, b_a))\n 2. \\<And>x21 x22 x1 x21aa x21aaa.\n       \\<lbrakk>fstate =\n                (DP (prim.If x21 x22), [DI x1, x21aa, x21aaa], ve, b);\n        fstate_a = (PP (prim.If x21 x22), ds_a, ve_a, b_a);\n        |ve| \\<lessapprox> ve_a; [{}, |x21aa|, |x21aaa|] \\<lessapprox> ds_a;\n        Suc (Suc (Suc 0)) = length ds_a; proc = PP (prim.If x21 x22);\n        d = DP (prim.If x21 x22); ds = [DI x1, x21aa, x21aaa];\n        x1 \\<noteq> 0; isProc x21aa; isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> |insert ((x21, [x21 \\<mapsto> b]), x21aa)\n                           (evalF\\<cdot>\n                            (Discr\n                              (x21aa, [], ve,\n                               nb b\n                                x21)))| \\<lessapprox> \\<aF>\\<cdot>\n                (Discr (PP (prim.If x21 x22), ds_a, ve_a, b_a))\n 3. \\<And>x21 x22 x21aa x21aaa.\n       \\<lbrakk>fstate =\n                (DP (prim.If x21 x22), [DI 0, x21aa, x21aaa], ve, b);\n        fstate_a = (PP (prim.If x21 x22), ds_a, ve_a, b_a);\n        |ve| \\<lessapprox> ve_a; [{}, |x21aa|, |x21aaa|] \\<lessapprox> ds_a;\n        Suc (Suc (Suc 0)) = length ds_a; proc = PP (prim.If x21 x22);\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa]; isProc x21aa;\n        isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> |insert ((x22, [x22 \\<mapsto> b]), x21aaa)\n                           (evalF\\<cdot>\n                            (Discr\n                              (x21aaa, [], ve,\n                               nb b\n                                x22)))| \\<lessapprox> \\<aF>\\<cdot>\n                (Discr (PP (prim.If x21 x22), ds_a, ve_a, b_a))", "fix lab a1 a2 cnt"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x1 x1a x1aa x21b.\n       \\<lbrakk>fstate = (DP (Plus x1), [DI x1a, DI x1aa, x21b], ve, b);\n        fstate_a = (PP (Plus x1), ds_a, ve_a, b_a); |ve| \\<lessapprox> ve_a;\n        [{}, {}, |x21b|] \\<lessapprox> ds_a;\n        Suc (Suc (Suc 0)) = length ds_a; proc = PP (Plus x1);\n        d = DP (Plus x1); ds = [DI x1a, DI x1aa, x21b]; isProc x21b\\<rbrakk>\n       \\<Longrightarrow> |insert ((x1, [x1 \\<mapsto> b]), x21b)\n                           (evalF\\<cdot>\n                            (Discr\n                              (x21b, [DI (x1a + x1aa)], ve,\n                               nb b\n                                x1)))| \\<lessapprox> \\<aF>\\<cdot>\n               (Discr (PP (Plus x1), ds_a, ve_a, b_a))\n 2. \\<And>x21 x22 x1 x21aa x21aaa.\n       \\<lbrakk>fstate =\n                (DP (prim.If x21 x22), [DI x1, x21aa, x21aaa], ve, b);\n        fstate_a = (PP (prim.If x21 x22), ds_a, ve_a, b_a);\n        |ve| \\<lessapprox> ve_a; [{}, |x21aa|, |x21aaa|] \\<lessapprox> ds_a;\n        Suc (Suc (Suc 0)) = length ds_a; proc = PP (prim.If x21 x22);\n        d = DP (prim.If x21 x22); ds = [DI x1, x21aa, x21aaa];\n        x1 \\<noteq> 0; isProc x21aa; isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> |insert ((x21, [x21 \\<mapsto> b]), x21aa)\n                           (evalF\\<cdot>\n                            (Discr\n                              (x21aa, [], ve,\n                               nb b\n                                x21)))| \\<lessapprox> \\<aF>\\<cdot>\n                (Discr (PP (prim.If x21 x22), ds_a, ve_a, b_a))\n 3. \\<And>x21 x22 x21aa x21aaa.\n       \\<lbrakk>fstate =\n                (DP (prim.If x21 x22), [DI 0, x21aa, x21aaa], ve, b);\n        fstate_a = (PP (prim.If x21 x22), ds_a, ve_a, b_a);\n        |ve| \\<lessapprox> ve_a; [{}, |x21aa|, |x21aaa|] \\<lessapprox> ds_a;\n        Suc (Suc (Suc 0)) = length ds_a; proc = PP (prim.If x21 x22);\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa]; isProc x21aa;\n        isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> |insert ((x22, [x22 \\<mapsto> b]), x21aaa)\n                           (evalF\\<cdot>\n                            (Discr\n                              (x21aaa, [], ve,\n                               nb b\n                                x22)))| \\<lessapprox> \\<aF>\\<cdot>\n                (Discr (PP (prim.If x21 x22), ds_a, ve_a, b_a))", "assume \"isProc cnt\""], ["proof (state)\nthis:\n  isProc cnt\n\ngoal (3 subgoals):\n 1. \\<And>x1 x1a x1aa x21b.\n       \\<lbrakk>fstate = (DP (Plus x1), [DI x1a, DI x1aa, x21b], ve, b);\n        fstate_a = (PP (Plus x1), ds_a, ve_a, b_a); |ve| \\<lessapprox> ve_a;\n        [{}, {}, |x21b|] \\<lessapprox> ds_a;\n        Suc (Suc (Suc 0)) = length ds_a; proc = PP (Plus x1);\n        d = DP (Plus x1); ds = [DI x1a, DI x1aa, x21b]; isProc x21b\\<rbrakk>\n       \\<Longrightarrow> |insert ((x1, [x1 \\<mapsto> b]), x21b)\n                           (evalF\\<cdot>\n                            (Discr\n                              (x21b, [DI (x1a + x1aa)], ve,\n                               nb b\n                                x1)))| \\<lessapprox> \\<aF>\\<cdot>\n               (Discr (PP (Plus x1), ds_a, ve_a, b_a))\n 2. \\<And>x21 x22 x1 x21aa x21aaa.\n       \\<lbrakk>fstate =\n                (DP (prim.If x21 x22), [DI x1, x21aa, x21aaa], ve, b);\n        fstate_a = (PP (prim.If x21 x22), ds_a, ve_a, b_a);\n        |ve| \\<lessapprox> ve_a; [{}, |x21aa|, |x21aaa|] \\<lessapprox> ds_a;\n        Suc (Suc (Suc 0)) = length ds_a; proc = PP (prim.If x21 x22);\n        d = DP (prim.If x21 x22); ds = [DI x1, x21aa, x21aaa];\n        x1 \\<noteq> 0; isProc x21aa; isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> |insert ((x21, [x21 \\<mapsto> b]), x21aa)\n                           (evalF\\<cdot>\n                            (Discr\n                              (x21aa, [], ve,\n                               nb b\n                                x21)))| \\<lessapprox> \\<aF>\\<cdot>\n                (Discr (PP (prim.If x21 x22), ds_a, ve_a, b_a))\n 3. \\<And>x21 x22 x21aa x21aaa.\n       \\<lbrakk>fstate =\n                (DP (prim.If x21 x22), [DI 0, x21aa, x21aaa], ve, b);\n        fstate_a = (PP (prim.If x21 x22), ds_a, ve_a, b_a);\n        |ve| \\<lessapprox> ve_a; [{}, |x21aa|, |x21aaa|] \\<lessapprox> ds_a;\n        Suc (Suc (Suc 0)) = length ds_a; proc = PP (prim.If x21 x22);\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa]; isProc x21aa;\n        isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> |insert ((x22, [x22 \\<mapsto> b]), x21aaa)\n                           (evalF\\<cdot>\n                            (Discr\n                              (x21aaa, [], ve,\n                               nb b\n                                x22)))| \\<lessapprox> \\<aF>\\<cdot>\n                (Discr (PP (prim.If x21 x22), ds_a, ve_a, b_a))", "assume abs_ds': \"[{}, {}, |cnt| ] \\<lessapprox> ds_a\""], ["proof (state)\nthis:\n  [{}, {}, |cnt|] \\<lessapprox> ds_a\n\ngoal (3 subgoals):\n 1. \\<And>x1 x1a x1aa x21b.\n       \\<lbrakk>fstate = (DP (Plus x1), [DI x1a, DI x1aa, x21b], ve, b);\n        fstate_a = (PP (Plus x1), ds_a, ve_a, b_a); |ve| \\<lessapprox> ve_a;\n        [{}, {}, |x21b|] \\<lessapprox> ds_a;\n        Suc (Suc (Suc 0)) = length ds_a; proc = PP (Plus x1);\n        d = DP (Plus x1); ds = [DI x1a, DI x1aa, x21b]; isProc x21b\\<rbrakk>\n       \\<Longrightarrow> |insert ((x1, [x1 \\<mapsto> b]), x21b)\n                           (evalF\\<cdot>\n                            (Discr\n                              (x21b, [DI (x1a + x1aa)], ve,\n                               nb b\n                                x1)))| \\<lessapprox> \\<aF>\\<cdot>\n               (Discr (PP (Plus x1), ds_a, ve_a, b_a))\n 2. \\<And>x21 x22 x1 x21aa x21aaa.\n       \\<lbrakk>fstate =\n                (DP (prim.If x21 x22), [DI x1, x21aa, x21aaa], ve, b);\n        fstate_a = (PP (prim.If x21 x22), ds_a, ve_a, b_a);\n        |ve| \\<lessapprox> ve_a; [{}, |x21aa|, |x21aaa|] \\<lessapprox> ds_a;\n        Suc (Suc (Suc 0)) = length ds_a; proc = PP (prim.If x21 x22);\n        d = DP (prim.If x21 x22); ds = [DI x1, x21aa, x21aaa];\n        x1 \\<noteq> 0; isProc x21aa; isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> |insert ((x21, [x21 \\<mapsto> b]), x21aa)\n                           (evalF\\<cdot>\n                            (Discr\n                              (x21aa, [], ve,\n                               nb b\n                                x21)))| \\<lessapprox> \\<aF>\\<cdot>\n                (Discr (PP (prim.If x21 x22), ds_a, ve_a, b_a))\n 3. \\<And>x21 x22 x21aa x21aaa.\n       \\<lbrakk>fstate =\n                (DP (prim.If x21 x22), [DI 0, x21aa, x21aaa], ve, b);\n        fstate_a = (PP (prim.If x21 x22), ds_a, ve_a, b_a);\n        |ve| \\<lessapprox> ve_a; [{}, |x21aa|, |x21aaa|] \\<lessapprox> ds_a;\n        Suc (Suc (Suc 0)) = length ds_a; proc = PP (prim.If x21 x22);\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa]; isProc x21aa;\n        isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> |insert ((x22, [x22 \\<mapsto> b]), x21aaa)\n                           (evalF\\<cdot>\n                            (Discr\n                              (x21aaa, [], ve,\n                               nb b\n                                x22)))| \\<lessapprox> \\<aF>\\<cdot>\n                (Discr (PP (prim.If x21 x22), ds_a, ve_a, b_a))", "then"], ["proof (chain)\npicking this:\n  [{}, {}, |cnt|] \\<lessapprox> ds_a", "obtain a1_a a2_a cnt_a where ds_a: \"ds_a = [a1_a, a2_a, cnt_a]\" and abs_cnt: \"|cnt| \\<lessapprox> cnt_a\""], ["proof (prove)\nusing this:\n  [{}, {}, |cnt|] \\<lessapprox> ds_a\n\ngoal (1 subgoal):\n 1. (\\<And>a1_a a2_a cnt_a.\n        \\<lbrakk>ds_a = [a1_a, a2_a, cnt_a];\n         |cnt| \\<lessapprox> cnt_a\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding ds_approx_def"], ["proof (prove)\nusing this:\n  list_all2 approx [{}, {}, |cnt|] ds_a\n\ngoal (1 subgoal):\n 1. (\\<And>a1_a a2_a cnt_a.\n        \\<lbrakk>ds_a = [a1_a, a2_a, cnt_a];\n         |cnt| \\<lessapprox> cnt_a\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases ds_a rule:list.exhaust[OF _ list.exhaust[OF _ list.exhaust, of _ _ \"\\<lambda>_ x. x\"],  of _ _ \"\\<lambda>_ x. x\"])\n       (auto simp add:ds_approx_def)"], ["proof (state)\nthis:\n  ds_a = [a1_a, a2_a, cnt_a]\n  |cnt| \\<lessapprox> cnt_a\n\ngoal (3 subgoals):\n 1. \\<And>x1 x1a x1aa x21b.\n       \\<lbrakk>fstate = (DP (Plus x1), [DI x1a, DI x1aa, x21b], ve, b);\n        fstate_a = (PP (Plus x1), ds_a, ve_a, b_a); |ve| \\<lessapprox> ve_a;\n        [{}, {}, |x21b|] \\<lessapprox> ds_a;\n        Suc (Suc (Suc 0)) = length ds_a; proc = PP (Plus x1);\n        d = DP (Plus x1); ds = [DI x1a, DI x1aa, x21b]; isProc x21b\\<rbrakk>\n       \\<Longrightarrow> |insert ((x1, [x1 \\<mapsto> b]), x21b)\n                           (evalF\\<cdot>\n                            (Discr\n                              (x21b, [DI (x1a + x1aa)], ve,\n                               nb b\n                                x1)))| \\<lessapprox> \\<aF>\\<cdot>\n               (Discr (PP (Plus x1), ds_a, ve_a, b_a))\n 2. \\<And>x21 x22 x1 x21aa x21aaa.\n       \\<lbrakk>fstate =\n                (DP (prim.If x21 x22), [DI x1, x21aa, x21aaa], ve, b);\n        fstate_a = (PP (prim.If x21 x22), ds_a, ve_a, b_a);\n        |ve| \\<lessapprox> ve_a; [{}, |x21aa|, |x21aaa|] \\<lessapprox> ds_a;\n        Suc (Suc (Suc 0)) = length ds_a; proc = PP (prim.If x21 x22);\n        d = DP (prim.If x21 x22); ds = [DI x1, x21aa, x21aaa];\n        x1 \\<noteq> 0; isProc x21aa; isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> |insert ((x21, [x21 \\<mapsto> b]), x21aa)\n                           (evalF\\<cdot>\n                            (Discr\n                              (x21aa, [], ve,\n                               nb b\n                                x21)))| \\<lessapprox> \\<aF>\\<cdot>\n                (Discr (PP (prim.If x21 x22), ds_a, ve_a, b_a))\n 3. \\<And>x21 x22 x21aa x21aaa.\n       \\<lbrakk>fstate =\n                (DP (prim.If x21 x22), [DI 0, x21aa, x21aaa], ve, b);\n        fstate_a = (PP (prim.If x21 x22), ds_a, ve_a, b_a);\n        |ve| \\<lessapprox> ve_a; [{}, |x21aa|, |x21aaa|] \\<lessapprox> ds_a;\n        Suc (Suc (Suc 0)) = length ds_a; proc = PP (prim.If x21 x22);\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa]; isProc x21aa;\n        isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> |insert ((x22, [x22 \\<mapsto> b]), x21aaa)\n                           (evalF\\<cdot>\n                            (Discr\n                              (x21aaa, [], ve,\n                               nb b\n                                x22)))| \\<lessapprox> \\<aF>\\<cdot>\n                (Discr (PP (prim.If x21 x22), ds_a, ve_a, b_a))", "have new_elem: \"|{((lab, [lab \\<mapsto> b]), cnt)}| \\<lessapprox> {((lab, [lab \\<mapsto> b_a]), cont) |cont. cont \\<in> cnt_a}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. |{((lab, [lab \\<mapsto> b]),\n       cnt)}| \\<lessapprox> {((lab, [lab \\<mapsto> b_a]), cont) |cont.\n                             cont \\<in> cnt_a}", "using abs_cnt and abs_b"], ["proof (prove)\nusing this:\n  |cnt| \\<lessapprox> cnt_a\n  |b| = b_a\n\ngoal (1 subgoal):\n 1. |{((lab, [lab \\<mapsto> b]),\n       cnt)}| \\<lessapprox> {((lab, [lab \\<mapsto> b_a]), cont) |cont.\n                             cont \\<in> cnt_a}", "by (auto simp add:ccache_approx_def d_approx_def)"], ["proof (state)\nthis:\n  |{((lab, [lab \\<mapsto> b]),\n     cnt)}| \\<lessapprox> {((lab, [lab \\<mapsto> b_a]), cont) |cont.\n                           cont \\<in> cnt_a}\n\ngoal (3 subgoals):\n 1. \\<And>x1 x1a x1aa x21b.\n       \\<lbrakk>fstate = (DP (Plus x1), [DI x1a, DI x1aa, x21b], ve, b);\n        fstate_a = (PP (Plus x1), ds_a, ve_a, b_a); |ve| \\<lessapprox> ve_a;\n        [{}, {}, |x21b|] \\<lessapprox> ds_a;\n        Suc (Suc (Suc 0)) = length ds_a; proc = PP (Plus x1);\n        d = DP (Plus x1); ds = [DI x1a, DI x1aa, x21b]; isProc x21b\\<rbrakk>\n       \\<Longrightarrow> |insert ((x1, [x1 \\<mapsto> b]), x21b)\n                           (evalF\\<cdot>\n                            (Discr\n                              (x21b, [DI (x1a + x1aa)], ve,\n                               nb b\n                                x1)))| \\<lessapprox> \\<aF>\\<cdot>\n               (Discr (PP (Plus x1), ds_a, ve_a, b_a))\n 2. \\<And>x21 x22 x1 x21aa x21aaa.\n       \\<lbrakk>fstate =\n                (DP (prim.If x21 x22), [DI x1, x21aa, x21aaa], ve, b);\n        fstate_a = (PP (prim.If x21 x22), ds_a, ve_a, b_a);\n        |ve| \\<lessapprox> ve_a; [{}, |x21aa|, |x21aaa|] \\<lessapprox> ds_a;\n        Suc (Suc (Suc 0)) = length ds_a; proc = PP (prim.If x21 x22);\n        d = DP (prim.If x21 x22); ds = [DI x1, x21aa, x21aaa];\n        x1 \\<noteq> 0; isProc x21aa; isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> |insert ((x21, [x21 \\<mapsto> b]), x21aa)\n                           (evalF\\<cdot>\n                            (Discr\n                              (x21aa, [], ve,\n                               nb b\n                                x21)))| \\<lessapprox> \\<aF>\\<cdot>\n                (Discr (PP (prim.If x21 x22), ds_a, ve_a, b_a))\n 3. \\<And>x21 x22 x21aa x21aaa.\n       \\<lbrakk>fstate =\n                (DP (prim.If x21 x22), [DI 0, x21aa, x21aaa], ve, b);\n        fstate_a = (PP (prim.If x21 x22), ds_a, ve_a, b_a);\n        |ve| \\<lessapprox> ve_a; [{}, |x21aa|, |x21aaa|] \\<lessapprox> ds_a;\n        Suc (Suc (Suc 0)) = length ds_a; proc = PP (prim.If x21 x22);\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa]; isProc x21aa;\n        isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> |insert ((x22, [x22 \\<mapsto> b]), x21aaa)\n                           (evalF\\<cdot>\n                            (Discr\n                              (x21aaa, [], ve,\n                               nb b\n                                x22)))| \\<lessapprox> \\<aF>\\<cdot>\n                (Discr (PP (prim.If x21 x22), ds_a, ve_a, b_a))", "have prem: \"|(cnt, [DI (a1 + a2)], ve, nb b lab)| \\<lessapprox>\n              (the_elem |cnt|, [{}], ve_a, \\<anb> b_a lab)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. |(cnt, [DI (a1 + a2)], ve,\n      nb b lab)| \\<lessapprox> (the_elem |cnt|, [{}], ve_a, \\<anb> b_a lab)", "using abs_ve and abs_b"], ["proof (prove)\nusing this:\n  |ve| \\<lessapprox> ve_a\n  |b| = b_a\n\ngoal (1 subgoal):\n 1. |(cnt, [DI (a1 + a2)], ve,\n      nb b lab)| \\<lessapprox> (the_elem |cnt|, [{}], ve_a, \\<anb> b_a lab)", "by (auto intro:fstate_approx.intros simp add:ds_approx_def)"], ["proof (state)\nthis:\n  |(cnt, [DI (a1 + a2)], ve,\n    nb b lab)| \\<lessapprox> (the_elem |cnt|, [{}], ve_a, \\<anb> b_a lab)\n\ngoal (3 subgoals):\n 1. \\<And>x1 x1a x1aa x21b.\n       \\<lbrakk>fstate = (DP (Plus x1), [DI x1a, DI x1aa, x21b], ve, b);\n        fstate_a = (PP (Plus x1), ds_a, ve_a, b_a); |ve| \\<lessapprox> ve_a;\n        [{}, {}, |x21b|] \\<lessapprox> ds_a;\n        Suc (Suc (Suc 0)) = length ds_a; proc = PP (Plus x1);\n        d = DP (Plus x1); ds = [DI x1a, DI x1aa, x21b]; isProc x21b\\<rbrakk>\n       \\<Longrightarrow> |insert ((x1, [x1 \\<mapsto> b]), x21b)\n                           (evalF\\<cdot>\n                            (Discr\n                              (x21b, [DI (x1a + x1aa)], ve,\n                               nb b\n                                x1)))| \\<lessapprox> \\<aF>\\<cdot>\n               (Discr (PP (Plus x1), ds_a, ve_a, b_a))\n 2. \\<And>x21 x22 x1 x21aa x21aaa.\n       \\<lbrakk>fstate =\n                (DP (prim.If x21 x22), [DI x1, x21aa, x21aaa], ve, b);\n        fstate_a = (PP (prim.If x21 x22), ds_a, ve_a, b_a);\n        |ve| \\<lessapprox> ve_a; [{}, |x21aa|, |x21aaa|] \\<lessapprox> ds_a;\n        Suc (Suc (Suc 0)) = length ds_a; proc = PP (prim.If x21 x22);\n        d = DP (prim.If x21 x22); ds = [DI x1, x21aa, x21aaa];\n        x1 \\<noteq> 0; isProc x21aa; isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> |insert ((x21, [x21 \\<mapsto> b]), x21aa)\n                           (evalF\\<cdot>\n                            (Discr\n                              (x21aa, [], ve,\n                               nb b\n                                x21)))| \\<lessapprox> \\<aF>\\<cdot>\n                (Discr (PP (prim.If x21 x22), ds_a, ve_a, b_a))\n 3. \\<And>x21 x22 x21aa x21aaa.\n       \\<lbrakk>fstate =\n                (DP (prim.If x21 x22), [DI 0, x21aa, x21aaa], ve, b);\n        fstate_a = (PP (prim.If x21 x22), ds_a, ve_a, b_a);\n        |ve| \\<lessapprox> ve_a; [{}, |x21aa|, |x21aaa|] \\<lessapprox> ds_a;\n        Suc (Suc (Suc 0)) = length ds_a; proc = PP (prim.If x21 x22);\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa]; isProc x21aa;\n        isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> |insert ((x22, [x22 \\<mapsto> b]), x21aaa)\n                           (evalF\\<cdot>\n                            (Discr\n                              (x21aaa, [], ve,\n                               nb b\n                                x22)))| \\<lessapprox> \\<aF>\\<cdot>\n                (Discr (PP (prim.If x21 x22), ds_a, ve_a, b_a))", "have \"|(evalF\\<cdot>(Discr (cnt, [DI (a1 + a2)], ve, nb b lab)))|\n       \\<lessapprox> \\<aF>\\<cdot>(Discr (the_elem |cnt|, [{}], ve_a, \\<anb> b_a lab))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. |evalF\\<cdot>\n     (Discr\n       (cnt, [DI (a1 + a2)], ve,\n        nb b\n         lab))| \\<lessapprox> \\<aF>\\<cdot>\n                              (Discr\n                                (the_elem |cnt|, [{}], ve_a,\n                                 \\<anb> b_a lab))", "by (rule Next.hyps(1)[OF prem])"], ["proof (state)\nthis:\n  |evalF\\<cdot>\n   (Discr\n     (cnt, [DI (a1 + a2)], ve,\n      nb b\n       lab))| \\<lessapprox> \\<aF>\\<cdot>\n                            (Discr\n                              (the_elem |cnt|, [{}], ve_a, \\<anb> b_a lab))\n\ngoal (3 subgoals):\n 1. \\<And>x1 x1a x1aa x21b.\n       \\<lbrakk>fstate = (DP (Plus x1), [DI x1a, DI x1aa, x21b], ve, b);\n        fstate_a = (PP (Plus x1), ds_a, ve_a, b_a); |ve| \\<lessapprox> ve_a;\n        [{}, {}, |x21b|] \\<lessapprox> ds_a;\n        Suc (Suc (Suc 0)) = length ds_a; proc = PP (Plus x1);\n        d = DP (Plus x1); ds = [DI x1a, DI x1aa, x21b]; isProc x21b\\<rbrakk>\n       \\<Longrightarrow> |insert ((x1, [x1 \\<mapsto> b]), x21b)\n                           (evalF\\<cdot>\n                            (Discr\n                              (x21b, [DI (x1a + x1aa)], ve,\n                               nb b\n                                x1)))| \\<lessapprox> \\<aF>\\<cdot>\n               (Discr (PP (Plus x1), ds_a, ve_a, b_a))\n 2. \\<And>x21 x22 x1 x21aa x21aaa.\n       \\<lbrakk>fstate =\n                (DP (prim.If x21 x22), [DI x1, x21aa, x21aaa], ve, b);\n        fstate_a = (PP (prim.If x21 x22), ds_a, ve_a, b_a);\n        |ve| \\<lessapprox> ve_a; [{}, |x21aa|, |x21aaa|] \\<lessapprox> ds_a;\n        Suc (Suc (Suc 0)) = length ds_a; proc = PP (prim.If x21 x22);\n        d = DP (prim.If x21 x22); ds = [DI x1, x21aa, x21aaa];\n        x1 \\<noteq> 0; isProc x21aa; isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> |insert ((x21, [x21 \\<mapsto> b]), x21aa)\n                           (evalF\\<cdot>\n                            (Discr\n                              (x21aa, [], ve,\n                               nb b\n                                x21)))| \\<lessapprox> \\<aF>\\<cdot>\n                (Discr (PP (prim.If x21 x22), ds_a, ve_a, b_a))\n 3. \\<And>x21 x22 x21aa x21aaa.\n       \\<lbrakk>fstate =\n                (DP (prim.If x21 x22), [DI 0, x21aa, x21aaa], ve, b);\n        fstate_a = (PP (prim.If x21 x22), ds_a, ve_a, b_a);\n        |ve| \\<lessapprox> ve_a; [{}, |x21aa|, |x21aaa|] \\<lessapprox> ds_a;\n        Suc (Suc (Suc 0)) = length ds_a; proc = PP (prim.If x21 x22);\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa]; isProc x21aa;\n        isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> |insert ((x22, [x22 \\<mapsto> b]), x21aaa)\n                           (evalF\\<cdot>\n                            (Discr\n                              (x21aaa, [], ve,\n                               nb b\n                                x22)))| \\<lessapprox> \\<aF>\\<cdot>\n                (Discr (PP (prim.If x21 x22), ds_a, ve_a, b_a))", "also"], ["proof (state)\nthis:\n  |evalF\\<cdot>\n   (Discr\n     (cnt, [DI (a1 + a2)], ve,\n      nb b\n       lab))| \\<lessapprox> \\<aF>\\<cdot>\n                            (Discr\n                              (the_elem |cnt|, [{}], ve_a, \\<anb> b_a lab))\n\ngoal (3 subgoals):\n 1. \\<And>x1 x1a x1aa x21b.\n       \\<lbrakk>fstate = (DP (Plus x1), [DI x1a, DI x1aa, x21b], ve, b);\n        fstate_a = (PP (Plus x1), ds_a, ve_a, b_a); |ve| \\<lessapprox> ve_a;\n        [{}, {}, |x21b|] \\<lessapprox> ds_a;\n        Suc (Suc (Suc 0)) = length ds_a; proc = PP (Plus x1);\n        d = DP (Plus x1); ds = [DI x1a, DI x1aa, x21b]; isProc x21b\\<rbrakk>\n       \\<Longrightarrow> |insert ((x1, [x1 \\<mapsto> b]), x21b)\n                           (evalF\\<cdot>\n                            (Discr\n                              (x21b, [DI (x1a + x1aa)], ve,\n                               nb b\n                                x1)))| \\<lessapprox> \\<aF>\\<cdot>\n               (Discr (PP (Plus x1), ds_a, ve_a, b_a))\n 2. \\<And>x21 x22 x1 x21aa x21aaa.\n       \\<lbrakk>fstate =\n                (DP (prim.If x21 x22), [DI x1, x21aa, x21aaa], ve, b);\n        fstate_a = (PP (prim.If x21 x22), ds_a, ve_a, b_a);\n        |ve| \\<lessapprox> ve_a; [{}, |x21aa|, |x21aaa|] \\<lessapprox> ds_a;\n        Suc (Suc (Suc 0)) = length ds_a; proc = PP (prim.If x21 x22);\n        d = DP (prim.If x21 x22); ds = [DI x1, x21aa, x21aaa];\n        x1 \\<noteq> 0; isProc x21aa; isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> |insert ((x21, [x21 \\<mapsto> b]), x21aa)\n                           (evalF\\<cdot>\n                            (Discr\n                              (x21aa, [], ve,\n                               nb b\n                                x21)))| \\<lessapprox> \\<aF>\\<cdot>\n                (Discr (PP (prim.If x21 x22), ds_a, ve_a, b_a))\n 3. \\<And>x21 x22 x21aa x21aaa.\n       \\<lbrakk>fstate =\n                (DP (prim.If x21 x22), [DI 0, x21aa, x21aaa], ve, b);\n        fstate_a = (PP (prim.If x21 x22), ds_a, ve_a, b_a);\n        |ve| \\<lessapprox> ve_a; [{}, |x21aa|, |x21aaa|] \\<lessapprox> ds_a;\n        Suc (Suc (Suc 0)) = length ds_a; proc = PP (prim.If x21 x22);\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa]; isProc x21aa;\n        isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> |insert ((x22, [x22 \\<mapsto> b]), x21aaa)\n                           (evalF\\<cdot>\n                            (Discr\n                              (x21aaa, [], ve,\n                               nb b\n                                x22)))| \\<lessapprox> \\<aF>\\<cdot>\n                (Discr (PP (prim.If x21 x22), ds_a, ve_a, b_a))", "have \"\\<dots> \\<lessapprox> (\\<Union>cnt\\<in>cnt_a. \\<aF>\\<cdot>(Discr (cnt, [{}], ve_a, \\<anb> b_a lab)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<aF>\\<cdot>\n    (Discr\n      (the_elem |cnt|, [{}], ve_a,\n       \\<anb> b_a\n        lab)) \\<lessapprox> \\<Union>cnt\\<in>cnt_a.\n                               \\<aF>\\<cdot>\n                               (Discr (cnt, [{}], ve_a, \\<anb> b_a lab))", "using abs_cnt"], ["proof (prove)\nusing this:\n  |cnt| \\<lessapprox> cnt_a\n\ngoal (1 subgoal):\n 1. \\<aF>\\<cdot>\n    (Discr\n      (the_elem |cnt|, [{}], ve_a,\n       \\<anb> b_a\n        lab)) \\<lessapprox> \\<Union>cnt\\<in>cnt_a.\n                               \\<aF>\\<cdot>\n                               (Discr (cnt, [{}], ve_a, \\<anb> b_a lab))", "by (auto intro: the_elem_is_Proc[OF \\<open>isProc cnt\\<close>] simp del: a_evalF.simps simp add:ccache_approx_def d_approx_def)"], ["proof (state)\nthis:\n  \\<aF>\\<cdot>\n  (Discr\n    (the_elem |cnt|, [{}], ve_a,\n     \\<anb> b_a\n      lab)) \\<lessapprox> \\<Union>cnt\\<in>cnt_a.\n                             \\<aF>\\<cdot>\n                             (Discr (cnt, [{}], ve_a, \\<anb> b_a lab))\n\ngoal (3 subgoals):\n 1. \\<And>x1 x1a x1aa x21b.\n       \\<lbrakk>fstate = (DP (Plus x1), [DI x1a, DI x1aa, x21b], ve, b);\n        fstate_a = (PP (Plus x1), ds_a, ve_a, b_a); |ve| \\<lessapprox> ve_a;\n        [{}, {}, |x21b|] \\<lessapprox> ds_a;\n        Suc (Suc (Suc 0)) = length ds_a; proc = PP (Plus x1);\n        d = DP (Plus x1); ds = [DI x1a, DI x1aa, x21b]; isProc x21b\\<rbrakk>\n       \\<Longrightarrow> |insert ((x1, [x1 \\<mapsto> b]), x21b)\n                           (evalF\\<cdot>\n                            (Discr\n                              (x21b, [DI (x1a + x1aa)], ve,\n                               nb b\n                                x1)))| \\<lessapprox> \\<aF>\\<cdot>\n               (Discr (PP (Plus x1), ds_a, ve_a, b_a))\n 2. \\<And>x21 x22 x1 x21aa x21aaa.\n       \\<lbrakk>fstate =\n                (DP (prim.If x21 x22), [DI x1, x21aa, x21aaa], ve, b);\n        fstate_a = (PP (prim.If x21 x22), ds_a, ve_a, b_a);\n        |ve| \\<lessapprox> ve_a; [{}, |x21aa|, |x21aaa|] \\<lessapprox> ds_a;\n        Suc (Suc (Suc 0)) = length ds_a; proc = PP (prim.If x21 x22);\n        d = DP (prim.If x21 x22); ds = [DI x1, x21aa, x21aaa];\n        x1 \\<noteq> 0; isProc x21aa; isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> |insert ((x21, [x21 \\<mapsto> b]), x21aa)\n                           (evalF\\<cdot>\n                            (Discr\n                              (x21aa, [], ve,\n                               nb b\n                                x21)))| \\<lessapprox> \\<aF>\\<cdot>\n                (Discr (PP (prim.If x21 x22), ds_a, ve_a, b_a))\n 3. \\<And>x21 x22 x21aa x21aaa.\n       \\<lbrakk>fstate =\n                (DP (prim.If x21 x22), [DI 0, x21aa, x21aaa], ve, b);\n        fstate_a = (PP (prim.If x21 x22), ds_a, ve_a, b_a);\n        |ve| \\<lessapprox> ve_a; [{}, |x21aa|, |x21aaa|] \\<lessapprox> ds_a;\n        Suc (Suc (Suc 0)) = length ds_a; proc = PP (prim.If x21 x22);\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa]; isProc x21aa;\n        isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> |insert ((x22, [x22 \\<mapsto> b]), x21aaa)\n                           (evalF\\<cdot>\n                            (Discr\n                              (x21aaa, [], ve,\n                               nb b\n                                x22)))| \\<lessapprox> \\<aF>\\<cdot>\n                (Discr (PP (prim.If x21 x22), ds_a, ve_a, b_a))", "finally"], ["proof (chain)\npicking this:\n  |evalF\\<cdot>\n   (Discr\n     (cnt, [DI (a1 + a2)], ve,\n      nb b\n       lab))| \\<lessapprox> \\<Union>cnt\\<in>cnt_a.\n                               \\<aF>\\<cdot>\n                               (Discr (cnt, [{}], ve_a, \\<anb> b_a lab))", "have old_elems: \"|(evalF\\<cdot>(Discr (cnt, [DI (a1 + a2)], ve, nb b lab)))|\n       \\<lessapprox> (\\<Union>cnt\\<in>cnt_a. \\<aF>\\<cdot>(Discr (cnt, [{}], ve_a, \\<anb> b_a lab)))\""], ["proof (prove)\nusing this:\n  |evalF\\<cdot>\n   (Discr\n     (cnt, [DI (a1 + a2)], ve,\n      nb b\n       lab))| \\<lessapprox> \\<Union>cnt\\<in>cnt_a.\n                               \\<aF>\\<cdot>\n                               (Discr (cnt, [{}], ve_a, \\<anb> b_a lab))\n\ngoal (1 subgoal):\n 1. |evalF\\<cdot>\n     (Discr\n       (cnt, [DI (a1 + a2)], ve,\n        nb b\n         lab))| \\<lessapprox> \\<Union>cnt\\<in>cnt_a.\n                                 \\<aF>\\<cdot>\n                                 (Discr (cnt, [{}], ve_a, \\<anb> b_a lab))", "."], ["proof (state)\nthis:\n  |evalF\\<cdot>\n   (Discr\n     (cnt, [DI (a1 + a2)], ve,\n      nb b\n       lab))| \\<lessapprox> \\<Union>cnt\\<in>cnt_a.\n                               \\<aF>\\<cdot>\n                               (Discr (cnt, [{}], ve_a, \\<anb> b_a lab))\n\ngoal (3 subgoals):\n 1. \\<And>x1 x1a x1aa x21b.\n       \\<lbrakk>fstate = (DP (Plus x1), [DI x1a, DI x1aa, x21b], ve, b);\n        fstate_a = (PP (Plus x1), ds_a, ve_a, b_a); |ve| \\<lessapprox> ve_a;\n        [{}, {}, |x21b|] \\<lessapprox> ds_a;\n        Suc (Suc (Suc 0)) = length ds_a; proc = PP (Plus x1);\n        d = DP (Plus x1); ds = [DI x1a, DI x1aa, x21b]; isProc x21b\\<rbrakk>\n       \\<Longrightarrow> |insert ((x1, [x1 \\<mapsto> b]), x21b)\n                           (evalF\\<cdot>\n                            (Discr\n                              (x21b, [DI (x1a + x1aa)], ve,\n                               nb b\n                                x1)))| \\<lessapprox> \\<aF>\\<cdot>\n               (Discr (PP (Plus x1), ds_a, ve_a, b_a))\n 2. \\<And>x21 x22 x1 x21aa x21aaa.\n       \\<lbrakk>fstate =\n                (DP (prim.If x21 x22), [DI x1, x21aa, x21aaa], ve, b);\n        fstate_a = (PP (prim.If x21 x22), ds_a, ve_a, b_a);\n        |ve| \\<lessapprox> ve_a; [{}, |x21aa|, |x21aaa|] \\<lessapprox> ds_a;\n        Suc (Suc (Suc 0)) = length ds_a; proc = PP (prim.If x21 x22);\n        d = DP (prim.If x21 x22); ds = [DI x1, x21aa, x21aaa];\n        x1 \\<noteq> 0; isProc x21aa; isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> |insert ((x21, [x21 \\<mapsto> b]), x21aa)\n                           (evalF\\<cdot>\n                            (Discr\n                              (x21aa, [], ve,\n                               nb b\n                                x21)))| \\<lessapprox> \\<aF>\\<cdot>\n                (Discr (PP (prim.If x21 x22), ds_a, ve_a, b_a))\n 3. \\<And>x21 x22 x21aa x21aaa.\n       \\<lbrakk>fstate =\n                (DP (prim.If x21 x22), [DI 0, x21aa, x21aaa], ve, b);\n        fstate_a = (PP (prim.If x21 x22), ds_a, ve_a, b_a);\n        |ve| \\<lessapprox> ve_a; [{}, |x21aa|, |x21aaa|] \\<lessapprox> ds_a;\n        Suc (Suc (Suc 0)) = length ds_a; proc = PP (prim.If x21 x22);\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa]; isProc x21aa;\n        isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> |insert ((x22, [x22 \\<mapsto> b]), x21aaa)\n                           (evalF\\<cdot>\n                            (Discr\n                              (x21aaa, [], ve,\n                               nb b\n                                x22)))| \\<lessapprox> \\<aF>\\<cdot>\n                (Discr (PP (prim.If x21 x22), ds_a, ve_a, b_a))", "have \"|((evalF\\<cdot>(Discr (cnt, [DI (a1 + a2)], ve, nb b lab)))\n          \\<union> {((lab, [lab \\<mapsto> b]), cnt)})|\n        \\<lessapprox> |(evalF\\<cdot>(Discr (cnt, [DI (a1 + a2)], ve, nb b lab)))|\n          \\<union> |{((lab, [lab \\<mapsto> b]), cnt)}|\""], ["proof (prove)\ngoal (1 subgoal):\n 1. |evalF\\<cdot>(Discr (cnt, [DI (a1 + a2)], ve, nb b lab)) \\<union>\n     {((lab, [lab \\<mapsto> b]),\n       cnt)}| \\<lessapprox> |evalF\\<cdot>\n                             (Discr\n                               (cnt, [DI (a1 + a2)], ve,\n                                nb b lab))| \\<union>\n                            |{((lab, [lab \\<mapsto> b]), cnt)}|", "by (rule abs_ccache_union)"], ["proof (state)\nthis:\n  |evalF\\<cdot>(Discr (cnt, [DI (a1 + a2)], ve, nb b lab)) \\<union>\n   {((lab, [lab \\<mapsto> b]),\n     cnt)}| \\<lessapprox> |evalF\\<cdot>\n                           (Discr\n                             (cnt, [DI (a1 + a2)], ve, nb b lab))| \\<union>\n                          |{((lab, [lab \\<mapsto> b]), cnt)}|\n\ngoal (3 subgoals):\n 1. \\<And>x1 x1a x1aa x21b.\n       \\<lbrakk>fstate = (DP (Plus x1), [DI x1a, DI x1aa, x21b], ve, b);\n        fstate_a = (PP (Plus x1), ds_a, ve_a, b_a); |ve| \\<lessapprox> ve_a;\n        [{}, {}, |x21b|] \\<lessapprox> ds_a;\n        Suc (Suc (Suc 0)) = length ds_a; proc = PP (Plus x1);\n        d = DP (Plus x1); ds = [DI x1a, DI x1aa, x21b]; isProc x21b\\<rbrakk>\n       \\<Longrightarrow> |insert ((x1, [x1 \\<mapsto> b]), x21b)\n                           (evalF\\<cdot>\n                            (Discr\n                              (x21b, [DI (x1a + x1aa)], ve,\n                               nb b\n                                x1)))| \\<lessapprox> \\<aF>\\<cdot>\n               (Discr (PP (Plus x1), ds_a, ve_a, b_a))\n 2. \\<And>x21 x22 x1 x21aa x21aaa.\n       \\<lbrakk>fstate =\n                (DP (prim.If x21 x22), [DI x1, x21aa, x21aaa], ve, b);\n        fstate_a = (PP (prim.If x21 x22), ds_a, ve_a, b_a);\n        |ve| \\<lessapprox> ve_a; [{}, |x21aa|, |x21aaa|] \\<lessapprox> ds_a;\n        Suc (Suc (Suc 0)) = length ds_a; proc = PP (prim.If x21 x22);\n        d = DP (prim.If x21 x22); ds = [DI x1, x21aa, x21aaa];\n        x1 \\<noteq> 0; isProc x21aa; isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> |insert ((x21, [x21 \\<mapsto> b]), x21aa)\n                           (evalF\\<cdot>\n                            (Discr\n                              (x21aa, [], ve,\n                               nb b\n                                x21)))| \\<lessapprox> \\<aF>\\<cdot>\n                (Discr (PP (prim.If x21 x22), ds_a, ve_a, b_a))\n 3. \\<And>x21 x22 x21aa x21aaa.\n       \\<lbrakk>fstate =\n                (DP (prim.If x21 x22), [DI 0, x21aa, x21aaa], ve, b);\n        fstate_a = (PP (prim.If x21 x22), ds_a, ve_a, b_a);\n        |ve| \\<lessapprox> ve_a; [{}, |x21aa|, |x21aaa|] \\<lessapprox> ds_a;\n        Suc (Suc (Suc 0)) = length ds_a; proc = PP (prim.If x21 x22);\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa]; isProc x21aa;\n        isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> |insert ((x22, [x22 \\<mapsto> b]), x21aaa)\n                           (evalF\\<cdot>\n                            (Discr\n                              (x21aaa, [], ve,\n                               nb b\n                                x22)))| \\<lessapprox> \\<aF>\\<cdot>\n                (Discr (PP (prim.If x21 x22), ds_a, ve_a, b_a))", "also"], ["proof (state)\nthis:\n  |evalF\\<cdot>(Discr (cnt, [DI (a1 + a2)], ve, nb b lab)) \\<union>\n   {((lab, [lab \\<mapsto> b]),\n     cnt)}| \\<lessapprox> |evalF\\<cdot>\n                           (Discr\n                             (cnt, [DI (a1 + a2)], ve, nb b lab))| \\<union>\n                          |{((lab, [lab \\<mapsto> b]), cnt)}|\n\ngoal (3 subgoals):\n 1. \\<And>x1 x1a x1aa x21b.\n       \\<lbrakk>fstate = (DP (Plus x1), [DI x1a, DI x1aa, x21b], ve, b);\n        fstate_a = (PP (Plus x1), ds_a, ve_a, b_a); |ve| \\<lessapprox> ve_a;\n        [{}, {}, |x21b|] \\<lessapprox> ds_a;\n        Suc (Suc (Suc 0)) = length ds_a; proc = PP (Plus x1);\n        d = DP (Plus x1); ds = [DI x1a, DI x1aa, x21b]; isProc x21b\\<rbrakk>\n       \\<Longrightarrow> |insert ((x1, [x1 \\<mapsto> b]), x21b)\n                           (evalF\\<cdot>\n                            (Discr\n                              (x21b, [DI (x1a + x1aa)], ve,\n                               nb b\n                                x1)))| \\<lessapprox> \\<aF>\\<cdot>\n               (Discr (PP (Plus x1), ds_a, ve_a, b_a))\n 2. \\<And>x21 x22 x1 x21aa x21aaa.\n       \\<lbrakk>fstate =\n                (DP (prim.If x21 x22), [DI x1, x21aa, x21aaa], ve, b);\n        fstate_a = (PP (prim.If x21 x22), ds_a, ve_a, b_a);\n        |ve| \\<lessapprox> ve_a; [{}, |x21aa|, |x21aaa|] \\<lessapprox> ds_a;\n        Suc (Suc (Suc 0)) = length ds_a; proc = PP (prim.If x21 x22);\n        d = DP (prim.If x21 x22); ds = [DI x1, x21aa, x21aaa];\n        x1 \\<noteq> 0; isProc x21aa; isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> |insert ((x21, [x21 \\<mapsto> b]), x21aa)\n                           (evalF\\<cdot>\n                            (Discr\n                              (x21aa, [], ve,\n                               nb b\n                                x21)))| \\<lessapprox> \\<aF>\\<cdot>\n                (Discr (PP (prim.If x21 x22), ds_a, ve_a, b_a))\n 3. \\<And>x21 x22 x21aa x21aaa.\n       \\<lbrakk>fstate =\n                (DP (prim.If x21 x22), [DI 0, x21aa, x21aaa], ve, b);\n        fstate_a = (PP (prim.If x21 x22), ds_a, ve_a, b_a);\n        |ve| \\<lessapprox> ve_a; [{}, |x21aa|, |x21aaa|] \\<lessapprox> ds_a;\n        Suc (Suc (Suc 0)) = length ds_a; proc = PP (prim.If x21 x22);\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa]; isProc x21aa;\n        isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> |insert ((x22, [x22 \\<mapsto> b]), x21aaa)\n                           (evalF\\<cdot>\n                            (Discr\n                              (x21aaa, [], ve,\n                               nb b\n                                x22)))| \\<lessapprox> \\<aF>\\<cdot>\n                (Discr (PP (prim.If x21 x22), ds_a, ve_a, b_a))", "have \"\\<dots> \\<lessapprox>\n        (\\<Union>cnt\\<in>cnt_a. \\<aF>\\<cdot>(Discr (cnt, [{}], ve_a, \\<anb> b_a lab)))\n        \\<union> {((lab, [lab \\<mapsto> b_a]), cont) |cont. cont \\<in> cnt_a}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. |evalF\\<cdot>(Discr (cnt, [DI (a1 + a2)], ve, nb b lab))| \\<union>\n    |{((lab, [lab \\<mapsto> b]),\n       cnt)}| \\<lessapprox> (\\<Union>cnt\\<in>cnt_a.\n                                \\<aF>\\<cdot>\n                                (Discr\n                                  (cnt, [{}], ve_a,\n                                   \\<anb> b_a lab))) \\<union>\n                            {((lab, [lab \\<mapsto> b_a]), cont) |cont.\n                             cont \\<in> cnt_a}", "by (rule Un_mono_approx[OF old_elems new_elem])"], ["proof (state)\nthis:\n  |evalF\\<cdot>(Discr (cnt, [DI (a1 + a2)], ve, nb b lab))| \\<union>\n  |{((lab, [lab \\<mapsto> b]),\n     cnt)}| \\<lessapprox> (\\<Union>cnt\\<in>cnt_a.\n                              \\<aF>\\<cdot>\n                              (Discr\n                                (cnt, [{}], ve_a, \\<anb> b_a lab))) \\<union>\n                          {((lab, [lab \\<mapsto> b_a]), cont) |cont.\n                           cont \\<in> cnt_a}\n\ngoal (3 subgoals):\n 1. \\<And>x1 x1a x1aa x21b.\n       \\<lbrakk>fstate = (DP (Plus x1), [DI x1a, DI x1aa, x21b], ve, b);\n        fstate_a = (PP (Plus x1), ds_a, ve_a, b_a); |ve| \\<lessapprox> ve_a;\n        [{}, {}, |x21b|] \\<lessapprox> ds_a;\n        Suc (Suc (Suc 0)) = length ds_a; proc = PP (Plus x1);\n        d = DP (Plus x1); ds = [DI x1a, DI x1aa, x21b]; isProc x21b\\<rbrakk>\n       \\<Longrightarrow> |insert ((x1, [x1 \\<mapsto> b]), x21b)\n                           (evalF\\<cdot>\n                            (Discr\n                              (x21b, [DI (x1a + x1aa)], ve,\n                               nb b\n                                x1)))| \\<lessapprox> \\<aF>\\<cdot>\n               (Discr (PP (Plus x1), ds_a, ve_a, b_a))\n 2. \\<And>x21 x22 x1 x21aa x21aaa.\n       \\<lbrakk>fstate =\n                (DP (prim.If x21 x22), [DI x1, x21aa, x21aaa], ve, b);\n        fstate_a = (PP (prim.If x21 x22), ds_a, ve_a, b_a);\n        |ve| \\<lessapprox> ve_a; [{}, |x21aa|, |x21aaa|] \\<lessapprox> ds_a;\n        Suc (Suc (Suc 0)) = length ds_a; proc = PP (prim.If x21 x22);\n        d = DP (prim.If x21 x22); ds = [DI x1, x21aa, x21aaa];\n        x1 \\<noteq> 0; isProc x21aa; isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> |insert ((x21, [x21 \\<mapsto> b]), x21aa)\n                           (evalF\\<cdot>\n                            (Discr\n                              (x21aa, [], ve,\n                               nb b\n                                x21)))| \\<lessapprox> \\<aF>\\<cdot>\n                (Discr (PP (prim.If x21 x22), ds_a, ve_a, b_a))\n 3. \\<And>x21 x22 x21aa x21aaa.\n       \\<lbrakk>fstate =\n                (DP (prim.If x21 x22), [DI 0, x21aa, x21aaa], ve, b);\n        fstate_a = (PP (prim.If x21 x22), ds_a, ve_a, b_a);\n        |ve| \\<lessapprox> ve_a; [{}, |x21aa|, |x21aaa|] \\<lessapprox> ds_a;\n        Suc (Suc (Suc 0)) = length ds_a; proc = PP (prim.If x21 x22);\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa]; isProc x21aa;\n        isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> |insert ((x22, [x22 \\<mapsto> b]), x21aaa)\n                           (evalF\\<cdot>\n                            (Discr\n                              (x21aaa, [], ve,\n                               nb b\n                                x22)))| \\<lessapprox> \\<aF>\\<cdot>\n                (Discr (PP (prim.If x21 x22), ds_a, ve_a, b_a))", "finally"], ["proof (chain)\npicking this:\n  |evalF\\<cdot>(Discr (cnt, [DI (a1 + a2)], ve, nb b lab)) \\<union>\n   {((lab, [lab \\<mapsto> b]),\n     cnt)}| \\<lessapprox> (\\<Union>cnt\\<in>cnt_a.\n                              \\<aF>\\<cdot>\n                              (Discr\n                                (cnt, [{}], ve_a, \\<anb> b_a lab))) \\<union>\n                          {((lab, [lab \\<mapsto> b_a]), cont) |cont.\n                           cont \\<in> cnt_a}", "show \"|insert ((lab, [lab \\<mapsto> b]), cnt)\n                (evalF\\<cdot>(Discr (cnt, [DI (a1 + a2)], ve, nb b lab)))|\n        \\<lessapprox> \\<aF>\\<cdot>(Discr (PP (prim.Plus lab), ds_a, ve_a, b_a))\""], ["proof (prove)\nusing this:\n  |evalF\\<cdot>(Discr (cnt, [DI (a1 + a2)], ve, nb b lab)) \\<union>\n   {((lab, [lab \\<mapsto> b]),\n     cnt)}| \\<lessapprox> (\\<Union>cnt\\<in>cnt_a.\n                              \\<aF>\\<cdot>\n                              (Discr\n                                (cnt, [{}], ve_a, \\<anb> b_a lab))) \\<union>\n                          {((lab, [lab \\<mapsto> b_a]), cont) |cont.\n                           cont \\<in> cnt_a}\n\ngoal (1 subgoal):\n 1. |insert ((lab, [lab \\<mapsto> b]), cnt)\n      (evalF\\<cdot>\n       (Discr\n         (cnt, [DI (a1 + a2)], ve,\n          nb b\n           lab)))| \\<lessapprox> \\<aF>\\<cdot>\n                                 (Discr (PP (Plus lab), ds_a, ve_a, b_a))", "using ds_a"], ["proof (prove)\nusing this:\n  |evalF\\<cdot>(Discr (cnt, [DI (a1 + a2)], ve, nb b lab)) \\<union>\n   {((lab, [lab \\<mapsto> b]),\n     cnt)}| \\<lessapprox> (\\<Union>cnt\\<in>cnt_a.\n                              \\<aF>\\<cdot>\n                              (Discr\n                                (cnt, [{}], ve_a, \\<anb> b_a lab))) \\<union>\n                          {((lab, [lab \\<mapsto> b_a]), cont) |cont.\n                           cont \\<in> cnt_a}\n  ds_a = [a1_a, a2_a, cnt_a]\n\ngoal (1 subgoal):\n 1. |insert ((lab, [lab \\<mapsto> b]), cnt)\n      (evalF\\<cdot>\n       (Discr\n         (cnt, [DI (a1 + a2)], ve,\n          nb b\n           lab)))| \\<lessapprox> \\<aF>\\<cdot>\n                                 (Discr (PP (Plus lab), ds_a, ve_a, b_a))", "by (subst a_evalF.simps)(auto simp del:a_evalF.simps)"], ["proof (state)\nthis:\n  |insert ((lab, [lab \\<mapsto> b]), cnt)\n    (evalF\\<cdot>\n     (Discr\n       (cnt, [DI (a1 + a2)], ve,\n        nb b\n         lab)))| \\<lessapprox> \\<aF>\\<cdot>\n                               (Discr (PP (Plus lab), ds_a, ve_a, b_a))\n\ngoal (2 subgoals):\n 1. \\<And>x21 x22 x1 x21aa x21aaa.\n       \\<lbrakk>fstate =\n                (DP (prim.If x21 x22), [DI x1, x21aa, x21aaa], ve, b);\n        fstate_a = (PP (prim.If x21 x22), ds_a, ve_a, b_a);\n        |ve| \\<lessapprox> ve_a; [{}, |x21aa|, |x21aaa|] \\<lessapprox> ds_a;\n        Suc (Suc (Suc 0)) = length ds_a; proc = PP (prim.If x21 x22);\n        d = DP (prim.If x21 x22); ds = [DI x1, x21aa, x21aaa];\n        x1 \\<noteq> 0; isProc x21aa; isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> |insert ((x21, [x21 \\<mapsto> b]), x21aa)\n                           (evalF\\<cdot>\n                            (Discr\n                              (x21aa, [], ve,\n                               nb b\n                                x21)))| \\<lessapprox> \\<aF>\\<cdot>\n                (Discr (PP (prim.If x21 x22), ds_a, ve_a, b_a))\n 2. \\<And>x21 x22 x21aa x21aaa.\n       \\<lbrakk>fstate =\n                (DP (prim.If x21 x22), [DI 0, x21aa, x21aaa], ve, b);\n        fstate_a = (PP (prim.If x21 x22), ds_a, ve_a, b_a);\n        |ve| \\<lessapprox> ve_a; [{}, |x21aa|, |x21aaa|] \\<lessapprox> ds_a;\n        Suc (Suc (Suc 0)) = length ds_a; proc = PP (prim.If x21 x22);\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa]; isProc x21aa;\n        isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> |insert ((x22, [x22 \\<mapsto> b]), x21aaa)\n                           (evalF\\<cdot>\n                            (Discr\n                              (x21aaa, [], ve,\n                               nb b\n                                x22)))| \\<lessapprox> \\<aF>\\<cdot>\n                (Discr (PP (prim.If x21 x22), ds_a, ve_a, b_a))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x21 x22 x1 x21aa x21aaa.\n       \\<lbrakk>fstate =\n                (DP (prim.If x21 x22), [DI x1, x21aa, x21aaa], ve, b);\n        fstate_a = (PP (prim.If x21 x22), ds_a, ve_a, b_a);\n        |ve| \\<lessapprox> ve_a; [{}, |x21aa|, |x21aaa|] \\<lessapprox> ds_a;\n        Suc (Suc (Suc 0)) = length ds_a; proc = PP (prim.If x21 x22);\n        d = DP (prim.If x21 x22); ds = [DI x1, x21aa, x21aaa];\n        x1 \\<noteq> 0; isProc x21aa; isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> |insert ((x21, [x21 \\<mapsto> b]), x21aa)\n                           (evalF\\<cdot>\n                            (Discr\n                              (x21aa, [], ve,\n                               nb b\n                                x21)))| \\<lessapprox> \\<aF>\\<cdot>\n                (Discr (PP (prim.If x21 x22), ds_a, ve_a, b_a))\n 2. \\<And>x21 x22 x21aa x21aaa.\n       \\<lbrakk>fstate =\n                (DP (prim.If x21 x22), [DI 0, x21aa, x21aaa], ve, b);\n        fstate_a = (PP (prim.If x21 x22), ds_a, ve_a, b_a);\n        |ve| \\<lessapprox> ve_a; [{}, |x21aa|, |x21aaa|] \\<lessapprox> ds_a;\n        Suc (Suc (Suc 0)) = length ds_a; proc = PP (prim.If x21 x22);\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa]; isProc x21aa;\n        isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> |insert ((x22, [x22 \\<mapsto> b]), x21aaa)\n                           (evalF\\<cdot>\n                            (Discr\n                              (x21aaa, [], ve,\n                               nb b\n                                x22)))| \\<lessapprox> \\<aF>\\<cdot>\n                (Discr (PP (prim.If x21 x22), ds_a, ve_a, b_a))", "txt \\<open>Case If (true branch)\\<close>"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x21 x22 x1 x21aa x21aaa.\n       \\<lbrakk>fstate =\n                (DP (prim.If x21 x22), [DI x1, x21aa, x21aaa], ve, b);\n        fstate_a = (PP (prim.If x21 x22), ds_a, ve_a, b_a);\n        |ve| \\<lessapprox> ve_a; [{}, |x21aa|, |x21aaa|] \\<lessapprox> ds_a;\n        Suc (Suc (Suc 0)) = length ds_a; proc = PP (prim.If x21 x22);\n        d = DP (prim.If x21 x22); ds = [DI x1, x21aa, x21aaa];\n        x1 \\<noteq> 0; isProc x21aa; isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> |insert ((x21, [x21 \\<mapsto> b]), x21aa)\n                           (evalF\\<cdot>\n                            (Discr\n                              (x21aa, [], ve,\n                               nb b\n                                x21)))| \\<lessapprox> \\<aF>\\<cdot>\n                (Discr (PP (prim.If x21 x22), ds_a, ve_a, b_a))\n 2. \\<And>x21 x22 x21aa x21aaa.\n       \\<lbrakk>fstate =\n                (DP (prim.If x21 x22), [DI 0, x21aa, x21aaa], ve, b);\n        fstate_a = (PP (prim.If x21 x22), ds_a, ve_a, b_a);\n        |ve| \\<lessapprox> ve_a; [{}, |x21aa|, |x21aaa|] \\<lessapprox> ds_a;\n        Suc (Suc (Suc 0)) = length ds_a; proc = PP (prim.If x21 x22);\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa]; isProc x21aa;\n        isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> |insert ((x22, [x22 \\<mapsto> b]), x21aaa)\n                           (evalF\\<cdot>\n                            (Discr\n                              (x21aaa, [], ve,\n                               nb b\n                                x22)))| \\<lessapprox> \\<aF>\\<cdot>\n                (Discr (PP (prim.If x21 x22), ds_a, ve_a, b_a))", "fix ct cf v cntt cntf"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x21 x22 x1 x21aa x21aaa.\n       \\<lbrakk>fstate =\n                (DP (prim.If x21 x22), [DI x1, x21aa, x21aaa], ve, b);\n        fstate_a = (PP (prim.If x21 x22), ds_a, ve_a, b_a);\n        |ve| \\<lessapprox> ve_a; [{}, |x21aa|, |x21aaa|] \\<lessapprox> ds_a;\n        Suc (Suc (Suc 0)) = length ds_a; proc = PP (prim.If x21 x22);\n        d = DP (prim.If x21 x22); ds = [DI x1, x21aa, x21aaa];\n        x1 \\<noteq> 0; isProc x21aa; isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> |insert ((x21, [x21 \\<mapsto> b]), x21aa)\n                           (evalF\\<cdot>\n                            (Discr\n                              (x21aa, [], ve,\n                               nb b\n                                x21)))| \\<lessapprox> \\<aF>\\<cdot>\n                (Discr (PP (prim.If x21 x22), ds_a, ve_a, b_a))\n 2. \\<And>x21 x22 x21aa x21aaa.\n       \\<lbrakk>fstate =\n                (DP (prim.If x21 x22), [DI 0, x21aa, x21aaa], ve, b);\n        fstate_a = (PP (prim.If x21 x22), ds_a, ve_a, b_a);\n        |ve| \\<lessapprox> ve_a; [{}, |x21aa|, |x21aaa|] \\<lessapprox> ds_a;\n        Suc (Suc (Suc 0)) = length ds_a; proc = PP (prim.If x21 x22);\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa]; isProc x21aa;\n        isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> |insert ((x22, [x22 \\<mapsto> b]), x21aaa)\n                           (evalF\\<cdot>\n                            (Discr\n                              (x21aaa, [], ve,\n                               nb b\n                                x22)))| \\<lessapprox> \\<aF>\\<cdot>\n                (Discr (PP (prim.If x21 x22), ds_a, ve_a, b_a))", "assume \"isProc cntt\""], ["proof (state)\nthis:\n  isProc cntt\n\ngoal (2 subgoals):\n 1. \\<And>x21 x22 x1 x21aa x21aaa.\n       \\<lbrakk>fstate =\n                (DP (prim.If x21 x22), [DI x1, x21aa, x21aaa], ve, b);\n        fstate_a = (PP (prim.If x21 x22), ds_a, ve_a, b_a);\n        |ve| \\<lessapprox> ve_a; [{}, |x21aa|, |x21aaa|] \\<lessapprox> ds_a;\n        Suc (Suc (Suc 0)) = length ds_a; proc = PP (prim.If x21 x22);\n        d = DP (prim.If x21 x22); ds = [DI x1, x21aa, x21aaa];\n        x1 \\<noteq> 0; isProc x21aa; isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> |insert ((x21, [x21 \\<mapsto> b]), x21aa)\n                           (evalF\\<cdot>\n                            (Discr\n                              (x21aa, [], ve,\n                               nb b\n                                x21)))| \\<lessapprox> \\<aF>\\<cdot>\n                (Discr (PP (prim.If x21 x22), ds_a, ve_a, b_a))\n 2. \\<And>x21 x22 x21aa x21aaa.\n       \\<lbrakk>fstate =\n                (DP (prim.If x21 x22), [DI 0, x21aa, x21aaa], ve, b);\n        fstate_a = (PP (prim.If x21 x22), ds_a, ve_a, b_a);\n        |ve| \\<lessapprox> ve_a; [{}, |x21aa|, |x21aaa|] \\<lessapprox> ds_a;\n        Suc (Suc (Suc 0)) = length ds_a; proc = PP (prim.If x21 x22);\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa]; isProc x21aa;\n        isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> |insert ((x22, [x22 \\<mapsto> b]), x21aaa)\n                           (evalF\\<cdot>\n                            (Discr\n                              (x21aaa, [], ve,\n                               nb b\n                                x22)))| \\<lessapprox> \\<aF>\\<cdot>\n                (Discr (PP (prim.If x21 x22), ds_a, ve_a, b_a))", "assume \"isProc cntf\""], ["proof (state)\nthis:\n  isProc cntf\n\ngoal (2 subgoals):\n 1. \\<And>x21 x22 x1 x21aa x21aaa.\n       \\<lbrakk>fstate =\n                (DP (prim.If x21 x22), [DI x1, x21aa, x21aaa], ve, b);\n        fstate_a = (PP (prim.If x21 x22), ds_a, ve_a, b_a);\n        |ve| \\<lessapprox> ve_a; [{}, |x21aa|, |x21aaa|] \\<lessapprox> ds_a;\n        Suc (Suc (Suc 0)) = length ds_a; proc = PP (prim.If x21 x22);\n        d = DP (prim.If x21 x22); ds = [DI x1, x21aa, x21aaa];\n        x1 \\<noteq> 0; isProc x21aa; isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> |insert ((x21, [x21 \\<mapsto> b]), x21aa)\n                           (evalF\\<cdot>\n                            (Discr\n                              (x21aa, [], ve,\n                               nb b\n                                x21)))| \\<lessapprox> \\<aF>\\<cdot>\n                (Discr (PP (prim.If x21 x22), ds_a, ve_a, b_a))\n 2. \\<And>x21 x22 x21aa x21aaa.\n       \\<lbrakk>fstate =\n                (DP (prim.If x21 x22), [DI 0, x21aa, x21aaa], ve, b);\n        fstate_a = (PP (prim.If x21 x22), ds_a, ve_a, b_a);\n        |ve| \\<lessapprox> ve_a; [{}, |x21aa|, |x21aaa|] \\<lessapprox> ds_a;\n        Suc (Suc (Suc 0)) = length ds_a; proc = PP (prim.If x21 x22);\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa]; isProc x21aa;\n        isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> |insert ((x22, [x22 \\<mapsto> b]), x21aaa)\n                           (evalF\\<cdot>\n                            (Discr\n                              (x21aaa, [], ve,\n                               nb b\n                                x22)))| \\<lessapprox> \\<aF>\\<cdot>\n                (Discr (PP (prim.If x21 x22), ds_a, ve_a, b_a))", "assume abs_ds': \"[{}, |cntt|, |cntf| ] \\<lessapprox> ds_a\""], ["proof (state)\nthis:\n  [{}, |cntt|, |cntf|] \\<lessapprox> ds_a\n\ngoal (2 subgoals):\n 1. \\<And>x21 x22 x1 x21aa x21aaa.\n       \\<lbrakk>fstate =\n                (DP (prim.If x21 x22), [DI x1, x21aa, x21aaa], ve, b);\n        fstate_a = (PP (prim.If x21 x22), ds_a, ve_a, b_a);\n        |ve| \\<lessapprox> ve_a; [{}, |x21aa|, |x21aaa|] \\<lessapprox> ds_a;\n        Suc (Suc (Suc 0)) = length ds_a; proc = PP (prim.If x21 x22);\n        d = DP (prim.If x21 x22); ds = [DI x1, x21aa, x21aaa];\n        x1 \\<noteq> 0; isProc x21aa; isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> |insert ((x21, [x21 \\<mapsto> b]), x21aa)\n                           (evalF\\<cdot>\n                            (Discr\n                              (x21aa, [], ve,\n                               nb b\n                                x21)))| \\<lessapprox> \\<aF>\\<cdot>\n                (Discr (PP (prim.If x21 x22), ds_a, ve_a, b_a))\n 2. \\<And>x21 x22 x21aa x21aaa.\n       \\<lbrakk>fstate =\n                (DP (prim.If x21 x22), [DI 0, x21aa, x21aaa], ve, b);\n        fstate_a = (PP (prim.If x21 x22), ds_a, ve_a, b_a);\n        |ve| \\<lessapprox> ve_a; [{}, |x21aa|, |x21aaa|] \\<lessapprox> ds_a;\n        Suc (Suc (Suc 0)) = length ds_a; proc = PP (prim.If x21 x22);\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa]; isProc x21aa;\n        isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> |insert ((x22, [x22 \\<mapsto> b]), x21aaa)\n                           (evalF\\<cdot>\n                            (Discr\n                              (x21aaa, [], ve,\n                               nb b\n                                x22)))| \\<lessapprox> \\<aF>\\<cdot>\n                (Discr (PP (prim.If x21 x22), ds_a, ve_a, b_a))", "then"], ["proof (chain)\npicking this:\n  [{}, |cntt|, |cntf|] \\<lessapprox> ds_a", "obtain v_a cntt_a cntf_a where ds_a: \"ds_a = [v_a, cntt_a, cntf_a]\"\n                              and abs_cntt: \"|cntt| \\<lessapprox> cntt_a\"\n                              and abs_cntf: \"|cntf| \\<lessapprox> cntf_a\""], ["proof (prove)\nusing this:\n  [{}, |cntt|, |cntf|] \\<lessapprox> ds_a\n\ngoal (1 subgoal):\n 1. (\\<And>v_a cntt_a cntf_a.\n        \\<lbrakk>ds_a = [v_a, cntt_a, cntf_a]; |cntt| \\<lessapprox> cntt_a;\n         |cntf| \\<lessapprox> cntf_a\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases ds_a rule:list.exhaust[OF _ list.exhaust[OF _ list.exhaust, of _ _ \"\\<lambda>_ x. x\"],  of _ _ \"\\<lambda>_ x. x\"])\n       (auto simp add:ds_approx_def)"], ["proof (state)\nthis:\n  ds_a = [v_a, cntt_a, cntf_a]\n  |cntt| \\<lessapprox> cntt_a\n  |cntf| \\<lessapprox> cntf_a\n\ngoal (2 subgoals):\n 1. \\<And>x21 x22 x1 x21aa x21aaa.\n       \\<lbrakk>fstate =\n                (DP (prim.If x21 x22), [DI x1, x21aa, x21aaa], ve, b);\n        fstate_a = (PP (prim.If x21 x22), ds_a, ve_a, b_a);\n        |ve| \\<lessapprox> ve_a; [{}, |x21aa|, |x21aaa|] \\<lessapprox> ds_a;\n        Suc (Suc (Suc 0)) = length ds_a; proc = PP (prim.If x21 x22);\n        d = DP (prim.If x21 x22); ds = [DI x1, x21aa, x21aaa];\n        x1 \\<noteq> 0; isProc x21aa; isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> |insert ((x21, [x21 \\<mapsto> b]), x21aa)\n                           (evalF\\<cdot>\n                            (Discr\n                              (x21aa, [], ve,\n                               nb b\n                                x21)))| \\<lessapprox> \\<aF>\\<cdot>\n                (Discr (PP (prim.If x21 x22), ds_a, ve_a, b_a))\n 2. \\<And>x21 x22 x21aa x21aaa.\n       \\<lbrakk>fstate =\n                (DP (prim.If x21 x22), [DI 0, x21aa, x21aaa], ve, b);\n        fstate_a = (PP (prim.If x21 x22), ds_a, ve_a, b_a);\n        |ve| \\<lessapprox> ve_a; [{}, |x21aa|, |x21aaa|] \\<lessapprox> ds_a;\n        Suc (Suc (Suc 0)) = length ds_a; proc = PP (prim.If x21 x22);\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa]; isProc x21aa;\n        isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> |insert ((x22, [x22 \\<mapsto> b]), x21aaa)\n                           (evalF\\<cdot>\n                            (Discr\n                              (x21aaa, [], ve,\n                               nb b\n                                x22)))| \\<lessapprox> \\<aF>\\<cdot>\n                (Discr (PP (prim.If x21 x22), ds_a, ve_a, b_a))", "let ?c = \"ct::label\" and ?cnt = cntt and ?cnt_a = cntt_a"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x21 x22 x1 x21aa x21aaa.\n       \\<lbrakk>fstate =\n                (DP (prim.If x21 x22), [DI x1, x21aa, x21aaa], ve, b);\n        fstate_a = (PP (prim.If x21 x22), ds_a, ve_a, b_a);\n        |ve| \\<lessapprox> ve_a; [{}, |x21aa|, |x21aaa|] \\<lessapprox> ds_a;\n        Suc (Suc (Suc 0)) = length ds_a; proc = PP (prim.If x21 x22);\n        d = DP (prim.If x21 x22); ds = [DI x1, x21aa, x21aaa];\n        x1 \\<noteq> 0; isProc x21aa; isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> |insert ((x21, [x21 \\<mapsto> b]), x21aa)\n                           (evalF\\<cdot>\n                            (Discr\n                              (x21aa, [], ve,\n                               nb b\n                                x21)))| \\<lessapprox> \\<aF>\\<cdot>\n                (Discr (PP (prim.If x21 x22), ds_a, ve_a, b_a))\n 2. \\<And>x21 x22 x21aa x21aaa.\n       \\<lbrakk>fstate =\n                (DP (prim.If x21 x22), [DI 0, x21aa, x21aaa], ve, b);\n        fstate_a = (PP (prim.If x21 x22), ds_a, ve_a, b_a);\n        |ve| \\<lessapprox> ve_a; [{}, |x21aa|, |x21aaa|] \\<lessapprox> ds_a;\n        Suc (Suc (Suc 0)) = length ds_a; proc = PP (prim.If x21 x22);\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa]; isProc x21aa;\n        isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> |insert ((x22, [x22 \\<mapsto> b]), x21aaa)\n                           (evalF\\<cdot>\n                            (Discr\n                              (x21aaa, [], ve,\n                               nb b\n                                x22)))| \\<lessapprox> \\<aF>\\<cdot>\n                (Discr (PP (prim.If x21 x22), ds_a, ve_a, b_a))", "have new_elem: \"|{((?c, [?c \\<mapsto> b]), ?cnt)}| \\<lessapprox> {((?c, [?c \\<mapsto> b_a]), cont) |cont. cont \\<in> ?cnt_a}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. |{((ct, [ct \\<mapsto> b]),\n       cntt)}| \\<lessapprox> {((ct, [ct \\<mapsto> b_a]), cont) |cont.\n                              cont \\<in> cntt_a}", "using abs_cntt and abs_cntf and abs_b"], ["proof (prove)\nusing this:\n  |cntt| \\<lessapprox> cntt_a\n  |cntf| \\<lessapprox> cntf_a\n  |b| = b_a\n\ngoal (1 subgoal):\n 1. |{((ct, [ct \\<mapsto> b]),\n       cntt)}| \\<lessapprox> {((ct, [ct \\<mapsto> b_a]), cont) |cont.\n                              cont \\<in> cntt_a}", "by (auto simp add:ccache_approx_def d_approx_def)"], ["proof (state)\nthis:\n  |{((ct, [ct \\<mapsto> b]),\n     cntt)}| \\<lessapprox> {((ct, [ct \\<mapsto> b_a]), cont) |cont.\n                            cont \\<in> cntt_a}\n\ngoal (2 subgoals):\n 1. \\<And>x21 x22 x1 x21aa x21aaa.\n       \\<lbrakk>fstate =\n                (DP (prim.If x21 x22), [DI x1, x21aa, x21aaa], ve, b);\n        fstate_a = (PP (prim.If x21 x22), ds_a, ve_a, b_a);\n        |ve| \\<lessapprox> ve_a; [{}, |x21aa|, |x21aaa|] \\<lessapprox> ds_a;\n        Suc (Suc (Suc 0)) = length ds_a; proc = PP (prim.If x21 x22);\n        d = DP (prim.If x21 x22); ds = [DI x1, x21aa, x21aaa];\n        x1 \\<noteq> 0; isProc x21aa; isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> |insert ((x21, [x21 \\<mapsto> b]), x21aa)\n                           (evalF\\<cdot>\n                            (Discr\n                              (x21aa, [], ve,\n                               nb b\n                                x21)))| \\<lessapprox> \\<aF>\\<cdot>\n                (Discr (PP (prim.If x21 x22), ds_a, ve_a, b_a))\n 2. \\<And>x21 x22 x21aa x21aaa.\n       \\<lbrakk>fstate =\n                (DP (prim.If x21 x22), [DI 0, x21aa, x21aaa], ve, b);\n        fstate_a = (PP (prim.If x21 x22), ds_a, ve_a, b_a);\n        |ve| \\<lessapprox> ve_a; [{}, |x21aa|, |x21aaa|] \\<lessapprox> ds_a;\n        Suc (Suc (Suc 0)) = length ds_a; proc = PP (prim.If x21 x22);\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa]; isProc x21aa;\n        isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> |insert ((x22, [x22 \\<mapsto> b]), x21aaa)\n                           (evalF\\<cdot>\n                            (Discr\n                              (x21aaa, [], ve,\n                               nb b\n                                x22)))| \\<lessapprox> \\<aF>\\<cdot>\n                (Discr (PP (prim.If x21 x22), ds_a, ve_a, b_a))", "have prem: \"|(?cnt, [], ve, nb b ?c)| \\<lessapprox>\n              (the_elem |?cnt|, [], ve_a, \\<anb> b_a ?c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. |(cntt, [], ve,\n      nb b ct)| \\<lessapprox> (the_elem |cntt|, [], ve_a, \\<anb> b_a ct)", "using abs_ve and abs_b"], ["proof (prove)\nusing this:\n  |ve| \\<lessapprox> ve_a\n  |b| = b_a\n\ngoal (1 subgoal):\n 1. |(cntt, [], ve,\n      nb b ct)| \\<lessapprox> (the_elem |cntt|, [], ve_a, \\<anb> b_a ct)", "by (auto intro:fstate_approx.intros)"], ["proof (state)\nthis:\n  |(cntt, [], ve,\n    nb b ct)| \\<lessapprox> (the_elem |cntt|, [], ve_a, \\<anb> b_a ct)\n\ngoal (2 subgoals):\n 1. \\<And>x21 x22 x1 x21aa x21aaa.\n       \\<lbrakk>fstate =\n                (DP (prim.If x21 x22), [DI x1, x21aa, x21aaa], ve, b);\n        fstate_a = (PP (prim.If x21 x22), ds_a, ve_a, b_a);\n        |ve| \\<lessapprox> ve_a; [{}, |x21aa|, |x21aaa|] \\<lessapprox> ds_a;\n        Suc (Suc (Suc 0)) = length ds_a; proc = PP (prim.If x21 x22);\n        d = DP (prim.If x21 x22); ds = [DI x1, x21aa, x21aaa];\n        x1 \\<noteq> 0; isProc x21aa; isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> |insert ((x21, [x21 \\<mapsto> b]), x21aa)\n                           (evalF\\<cdot>\n                            (Discr\n                              (x21aa, [], ve,\n                               nb b\n                                x21)))| \\<lessapprox> \\<aF>\\<cdot>\n                (Discr (PP (prim.If x21 x22), ds_a, ve_a, b_a))\n 2. \\<And>x21 x22 x21aa x21aaa.\n       \\<lbrakk>fstate =\n                (DP (prim.If x21 x22), [DI 0, x21aa, x21aaa], ve, b);\n        fstate_a = (PP (prim.If x21 x22), ds_a, ve_a, b_a);\n        |ve| \\<lessapprox> ve_a; [{}, |x21aa|, |x21aaa|] \\<lessapprox> ds_a;\n        Suc (Suc (Suc 0)) = length ds_a; proc = PP (prim.If x21 x22);\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa]; isProc x21aa;\n        isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> |insert ((x22, [x22 \\<mapsto> b]), x21aaa)\n                           (evalF\\<cdot>\n                            (Discr\n                              (x21aaa, [], ve,\n                               nb b\n                                x22)))| \\<lessapprox> \\<aF>\\<cdot>\n                (Discr (PP (prim.If x21 x22), ds_a, ve_a, b_a))", "have \"|evalF\\<cdot>(Discr (?cnt, [], ve, nb b ?c))|\n       \\<lessapprox> \\<aF>\\<cdot>(Discr (the_elem |?cnt|, [], ve_a, \\<anb> b_a ?c))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. |evalF\\<cdot>\n     (Discr\n       (cntt, [], ve,\n        nb b\n         ct))| \\<lessapprox> \\<aF>\\<cdot>\n                             (Discr\n                               (the_elem |cntt|, [], ve_a, \\<anb> b_a ct))", "by (rule Next.hyps(1)[OF prem])"], ["proof (state)\nthis:\n  |evalF\\<cdot>\n   (Discr\n     (cntt, [], ve,\n      nb b\n       ct))| \\<lessapprox> \\<aF>\\<cdot>\n                           (Discr\n                             (the_elem |cntt|, [], ve_a, \\<anb> b_a ct))\n\ngoal (2 subgoals):\n 1. \\<And>x21 x22 x1 x21aa x21aaa.\n       \\<lbrakk>fstate =\n                (DP (prim.If x21 x22), [DI x1, x21aa, x21aaa], ve, b);\n        fstate_a = (PP (prim.If x21 x22), ds_a, ve_a, b_a);\n        |ve| \\<lessapprox> ve_a; [{}, |x21aa|, |x21aaa|] \\<lessapprox> ds_a;\n        Suc (Suc (Suc 0)) = length ds_a; proc = PP (prim.If x21 x22);\n        d = DP (prim.If x21 x22); ds = [DI x1, x21aa, x21aaa];\n        x1 \\<noteq> 0; isProc x21aa; isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> |insert ((x21, [x21 \\<mapsto> b]), x21aa)\n                           (evalF\\<cdot>\n                            (Discr\n                              (x21aa, [], ve,\n                               nb b\n                                x21)))| \\<lessapprox> \\<aF>\\<cdot>\n                (Discr (PP (prim.If x21 x22), ds_a, ve_a, b_a))\n 2. \\<And>x21 x22 x21aa x21aaa.\n       \\<lbrakk>fstate =\n                (DP (prim.If x21 x22), [DI 0, x21aa, x21aaa], ve, b);\n        fstate_a = (PP (prim.If x21 x22), ds_a, ve_a, b_a);\n        |ve| \\<lessapprox> ve_a; [{}, |x21aa|, |x21aaa|] \\<lessapprox> ds_a;\n        Suc (Suc (Suc 0)) = length ds_a; proc = PP (prim.If x21 x22);\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa]; isProc x21aa;\n        isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> |insert ((x22, [x22 \\<mapsto> b]), x21aaa)\n                           (evalF\\<cdot>\n                            (Discr\n                              (x21aaa, [], ve,\n                               nb b\n                                x22)))| \\<lessapprox> \\<aF>\\<cdot>\n                (Discr (PP (prim.If x21 x22), ds_a, ve_a, b_a))", "also"], ["proof (state)\nthis:\n  |evalF\\<cdot>\n   (Discr\n     (cntt, [], ve,\n      nb b\n       ct))| \\<lessapprox> \\<aF>\\<cdot>\n                           (Discr\n                             (the_elem |cntt|, [], ve_a, \\<anb> b_a ct))\n\ngoal (2 subgoals):\n 1. \\<And>x21 x22 x1 x21aa x21aaa.\n       \\<lbrakk>fstate =\n                (DP (prim.If x21 x22), [DI x1, x21aa, x21aaa], ve, b);\n        fstate_a = (PP (prim.If x21 x22), ds_a, ve_a, b_a);\n        |ve| \\<lessapprox> ve_a; [{}, |x21aa|, |x21aaa|] \\<lessapprox> ds_a;\n        Suc (Suc (Suc 0)) = length ds_a; proc = PP (prim.If x21 x22);\n        d = DP (prim.If x21 x22); ds = [DI x1, x21aa, x21aaa];\n        x1 \\<noteq> 0; isProc x21aa; isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> |insert ((x21, [x21 \\<mapsto> b]), x21aa)\n                           (evalF\\<cdot>\n                            (Discr\n                              (x21aa, [], ve,\n                               nb b\n                                x21)))| \\<lessapprox> \\<aF>\\<cdot>\n                (Discr (PP (prim.If x21 x22), ds_a, ve_a, b_a))\n 2. \\<And>x21 x22 x21aa x21aaa.\n       \\<lbrakk>fstate =\n                (DP (prim.If x21 x22), [DI 0, x21aa, x21aaa], ve, b);\n        fstate_a = (PP (prim.If x21 x22), ds_a, ve_a, b_a);\n        |ve| \\<lessapprox> ve_a; [{}, |x21aa|, |x21aaa|] \\<lessapprox> ds_a;\n        Suc (Suc (Suc 0)) = length ds_a; proc = PP (prim.If x21 x22);\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa]; isProc x21aa;\n        isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> |insert ((x22, [x22 \\<mapsto> b]), x21aaa)\n                           (evalF\\<cdot>\n                            (Discr\n                              (x21aaa, [], ve,\n                               nb b\n                                x22)))| \\<lessapprox> \\<aF>\\<cdot>\n                (Discr (PP (prim.If x21 x22), ds_a, ve_a, b_a))", "have \"\\<dots> \\<lessapprox> (\\<Union>cnt\\<in>?cnt_a. \\<aF>\\<cdot>(Discr (cnt, [], ve_a, \\<anb> b_a ?c)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<aF>\\<cdot>\n    (Discr\n      (the_elem |cntt|, [], ve_a,\n       \\<anb> b_a\n        ct)) \\<lessapprox> \\<Union>cnt\\<in>cntt_a.\n                              \\<aF>\\<cdot>\n                              (Discr (cnt, [], ve_a, \\<anb> b_a ct))", "using abs_cntt and abs_cntf"], ["proof (prove)\nusing this:\n  |cntt| \\<lessapprox> cntt_a\n  |cntf| \\<lessapprox> cntf_a\n\ngoal (1 subgoal):\n 1. \\<aF>\\<cdot>\n    (Discr\n      (the_elem |cntt|, [], ve_a,\n       \\<anb> b_a\n        ct)) \\<lessapprox> \\<Union>cnt\\<in>cntt_a.\n                              \\<aF>\\<cdot>\n                              (Discr (cnt, [], ve_a, \\<anb> b_a ct))", "by (auto intro: the_elem_is_Proc[OF \\<open>isProc ?cnt\\<close>] simp del: a_evalF.simps simp add:ccache_approx_def d_approx_def)"], ["proof (state)\nthis:\n  \\<aF>\\<cdot>\n  (Discr\n    (the_elem |cntt|, [], ve_a,\n     \\<anb> b_a\n      ct)) \\<lessapprox> \\<Union>cnt\\<in>cntt_a.\n                            \\<aF>\\<cdot>\n                            (Discr (cnt, [], ve_a, \\<anb> b_a ct))\n\ngoal (2 subgoals):\n 1. \\<And>x21 x22 x1 x21aa x21aaa.\n       \\<lbrakk>fstate =\n                (DP (prim.If x21 x22), [DI x1, x21aa, x21aaa], ve, b);\n        fstate_a = (PP (prim.If x21 x22), ds_a, ve_a, b_a);\n        |ve| \\<lessapprox> ve_a; [{}, |x21aa|, |x21aaa|] \\<lessapprox> ds_a;\n        Suc (Suc (Suc 0)) = length ds_a; proc = PP (prim.If x21 x22);\n        d = DP (prim.If x21 x22); ds = [DI x1, x21aa, x21aaa];\n        x1 \\<noteq> 0; isProc x21aa; isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> |insert ((x21, [x21 \\<mapsto> b]), x21aa)\n                           (evalF\\<cdot>\n                            (Discr\n                              (x21aa, [], ve,\n                               nb b\n                                x21)))| \\<lessapprox> \\<aF>\\<cdot>\n                (Discr (PP (prim.If x21 x22), ds_a, ve_a, b_a))\n 2. \\<And>x21 x22 x21aa x21aaa.\n       \\<lbrakk>fstate =\n                (DP (prim.If x21 x22), [DI 0, x21aa, x21aaa], ve, b);\n        fstate_a = (PP (prim.If x21 x22), ds_a, ve_a, b_a);\n        |ve| \\<lessapprox> ve_a; [{}, |x21aa|, |x21aaa|] \\<lessapprox> ds_a;\n        Suc (Suc (Suc 0)) = length ds_a; proc = PP (prim.If x21 x22);\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa]; isProc x21aa;\n        isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> |insert ((x22, [x22 \\<mapsto> b]), x21aaa)\n                           (evalF\\<cdot>\n                            (Discr\n                              (x21aaa, [], ve,\n                               nb b\n                                x22)))| \\<lessapprox> \\<aF>\\<cdot>\n                (Discr (PP (prim.If x21 x22), ds_a, ve_a, b_a))", "finally"], ["proof (chain)\npicking this:\n  |evalF\\<cdot>\n   (Discr\n     (cntt, [], ve,\n      nb b\n       ct))| \\<lessapprox> \\<Union>cnt\\<in>cntt_a.\n                              \\<aF>\\<cdot>\n                              (Discr (cnt, [], ve_a, \\<anb> b_a ct))", "have old_elems: \"|evalF\\<cdot>(Discr (?cnt, [], ve, nb b ?c))|\n       \\<lessapprox> (\\<Union>cnt\\<in>?cnt_a. \\<aF>\\<cdot>(Discr (cnt, [], ve_a, \\<anb> b_a ?c)))\""], ["proof (prove)\nusing this:\n  |evalF\\<cdot>\n   (Discr\n     (cntt, [], ve,\n      nb b\n       ct))| \\<lessapprox> \\<Union>cnt\\<in>cntt_a.\n                              \\<aF>\\<cdot>\n                              (Discr (cnt, [], ve_a, \\<anb> b_a ct))\n\ngoal (1 subgoal):\n 1. |evalF\\<cdot>\n     (Discr\n       (cntt, [], ve,\n        nb b\n         ct))| \\<lessapprox> \\<Union>cnt\\<in>cntt_a.\n                                \\<aF>\\<cdot>\n                                (Discr (cnt, [], ve_a, \\<anb> b_a ct))", "."], ["proof (state)\nthis:\n  |evalF\\<cdot>\n   (Discr\n     (cntt, [], ve,\n      nb b\n       ct))| \\<lessapprox> \\<Union>cnt\\<in>cntt_a.\n                              \\<aF>\\<cdot>\n                              (Discr (cnt, [], ve_a, \\<anb> b_a ct))\n\ngoal (2 subgoals):\n 1. \\<And>x21 x22 x1 x21aa x21aaa.\n       \\<lbrakk>fstate =\n                (DP (prim.If x21 x22), [DI x1, x21aa, x21aaa], ve, b);\n        fstate_a = (PP (prim.If x21 x22), ds_a, ve_a, b_a);\n        |ve| \\<lessapprox> ve_a; [{}, |x21aa|, |x21aaa|] \\<lessapprox> ds_a;\n        Suc (Suc (Suc 0)) = length ds_a; proc = PP (prim.If x21 x22);\n        d = DP (prim.If x21 x22); ds = [DI x1, x21aa, x21aaa];\n        x1 \\<noteq> 0; isProc x21aa; isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> |insert ((x21, [x21 \\<mapsto> b]), x21aa)\n                           (evalF\\<cdot>\n                            (Discr\n                              (x21aa, [], ve,\n                               nb b\n                                x21)))| \\<lessapprox> \\<aF>\\<cdot>\n                (Discr (PP (prim.If x21 x22), ds_a, ve_a, b_a))\n 2. \\<And>x21 x22 x21aa x21aaa.\n       \\<lbrakk>fstate =\n                (DP (prim.If x21 x22), [DI 0, x21aa, x21aaa], ve, b);\n        fstate_a = (PP (prim.If x21 x22), ds_a, ve_a, b_a);\n        |ve| \\<lessapprox> ve_a; [{}, |x21aa|, |x21aaa|] \\<lessapprox> ds_a;\n        Suc (Suc (Suc 0)) = length ds_a; proc = PP (prim.If x21 x22);\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa]; isProc x21aa;\n        isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> |insert ((x22, [x22 \\<mapsto> b]), x21aaa)\n                           (evalF\\<cdot>\n                            (Discr\n                              (x21aaa, [], ve,\n                               nb b\n                                x22)))| \\<lessapprox> \\<aF>\\<cdot>\n                (Discr (PP (prim.If x21 x22), ds_a, ve_a, b_a))", "have \"|evalF\\<cdot>(Discr (?cnt, [], ve, nb b ?c))\n          \\<union> {((?c, [?c \\<mapsto> b]), ?cnt)}|\n        \\<lessapprox> |evalF\\<cdot>(Discr (?cnt, [], ve, nb b ?c))|\n          \\<union> |{((?c, [?c \\<mapsto> b]), ?cnt)}|\""], ["proof (prove)\ngoal (1 subgoal):\n 1. |evalF\\<cdot>(Discr (cntt, [], ve, nb b ct)) \\<union>\n     {((ct, [ct \\<mapsto> b]),\n       cntt)}| \\<lessapprox> |evalF\\<cdot>\n                              (Discr (cntt, [], ve, nb b ct))| \\<union>\n                             |{((ct, [ct \\<mapsto> b]), cntt)}|", "by (rule abs_ccache_union)"], ["proof (state)\nthis:\n  |evalF\\<cdot>(Discr (cntt, [], ve, nb b ct)) \\<union>\n   {((ct, [ct \\<mapsto> b]),\n     cntt)}| \\<lessapprox> |evalF\\<cdot>\n                            (Discr (cntt, [], ve, nb b ct))| \\<union>\n                           |{((ct, [ct \\<mapsto> b]), cntt)}|\n\ngoal (2 subgoals):\n 1. \\<And>x21 x22 x1 x21aa x21aaa.\n       \\<lbrakk>fstate =\n                (DP (prim.If x21 x22), [DI x1, x21aa, x21aaa], ve, b);\n        fstate_a = (PP (prim.If x21 x22), ds_a, ve_a, b_a);\n        |ve| \\<lessapprox> ve_a; [{}, |x21aa|, |x21aaa|] \\<lessapprox> ds_a;\n        Suc (Suc (Suc 0)) = length ds_a; proc = PP (prim.If x21 x22);\n        d = DP (prim.If x21 x22); ds = [DI x1, x21aa, x21aaa];\n        x1 \\<noteq> 0; isProc x21aa; isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> |insert ((x21, [x21 \\<mapsto> b]), x21aa)\n                           (evalF\\<cdot>\n                            (Discr\n                              (x21aa, [], ve,\n                               nb b\n                                x21)))| \\<lessapprox> \\<aF>\\<cdot>\n                (Discr (PP (prim.If x21 x22), ds_a, ve_a, b_a))\n 2. \\<And>x21 x22 x21aa x21aaa.\n       \\<lbrakk>fstate =\n                (DP (prim.If x21 x22), [DI 0, x21aa, x21aaa], ve, b);\n        fstate_a = (PP (prim.If x21 x22), ds_a, ve_a, b_a);\n        |ve| \\<lessapprox> ve_a; [{}, |x21aa|, |x21aaa|] \\<lessapprox> ds_a;\n        Suc (Suc (Suc 0)) = length ds_a; proc = PP (prim.If x21 x22);\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa]; isProc x21aa;\n        isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> |insert ((x22, [x22 \\<mapsto> b]), x21aaa)\n                           (evalF\\<cdot>\n                            (Discr\n                              (x21aaa, [], ve,\n                               nb b\n                                x22)))| \\<lessapprox> \\<aF>\\<cdot>\n                (Discr (PP (prim.If x21 x22), ds_a, ve_a, b_a))", "also"], ["proof (state)\nthis:\n  |evalF\\<cdot>(Discr (cntt, [], ve, nb b ct)) \\<union>\n   {((ct, [ct \\<mapsto> b]),\n     cntt)}| \\<lessapprox> |evalF\\<cdot>\n                            (Discr (cntt, [], ve, nb b ct))| \\<union>\n                           |{((ct, [ct \\<mapsto> b]), cntt)}|\n\ngoal (2 subgoals):\n 1. \\<And>x21 x22 x1 x21aa x21aaa.\n       \\<lbrakk>fstate =\n                (DP (prim.If x21 x22), [DI x1, x21aa, x21aaa], ve, b);\n        fstate_a = (PP (prim.If x21 x22), ds_a, ve_a, b_a);\n        |ve| \\<lessapprox> ve_a; [{}, |x21aa|, |x21aaa|] \\<lessapprox> ds_a;\n        Suc (Suc (Suc 0)) = length ds_a; proc = PP (prim.If x21 x22);\n        d = DP (prim.If x21 x22); ds = [DI x1, x21aa, x21aaa];\n        x1 \\<noteq> 0; isProc x21aa; isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> |insert ((x21, [x21 \\<mapsto> b]), x21aa)\n                           (evalF\\<cdot>\n                            (Discr\n                              (x21aa, [], ve,\n                               nb b\n                                x21)))| \\<lessapprox> \\<aF>\\<cdot>\n                (Discr (PP (prim.If x21 x22), ds_a, ve_a, b_a))\n 2. \\<And>x21 x22 x21aa x21aaa.\n       \\<lbrakk>fstate =\n                (DP (prim.If x21 x22), [DI 0, x21aa, x21aaa], ve, b);\n        fstate_a = (PP (prim.If x21 x22), ds_a, ve_a, b_a);\n        |ve| \\<lessapprox> ve_a; [{}, |x21aa|, |x21aaa|] \\<lessapprox> ds_a;\n        Suc (Suc (Suc 0)) = length ds_a; proc = PP (prim.If x21 x22);\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa]; isProc x21aa;\n        isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> |insert ((x22, [x22 \\<mapsto> b]), x21aaa)\n                           (evalF\\<cdot>\n                            (Discr\n                              (x21aaa, [], ve,\n                               nb b\n                                x22)))| \\<lessapprox> \\<aF>\\<cdot>\n                (Discr (PP (prim.If x21 x22), ds_a, ve_a, b_a))", "have \"\\<dots> \\<lessapprox>\n        (\\<Union>cnt\\<in>?cnt_a. \\<aF>\\<cdot>(Discr (cnt, [], ve_a, \\<anb> b_a ?c)))\n        \\<union> {((?c, [?c \\<mapsto> b_a]), cont) |cont. cont \\<in> ?cnt_a}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. |evalF\\<cdot>(Discr (cntt, [], ve, nb b ct))| \\<union>\n    |{((ct, [ct \\<mapsto> b]),\n       cntt)}| \\<lessapprox> (\\<Union>cnt\\<in>cntt_a.\n                                 \\<aF>\\<cdot>\n                                 (Discr\n                                   (cnt, [], ve_a, \\<anb> b_a ct))) \\<union>\n                             {((ct, [ct \\<mapsto> b_a]), cont) |cont.\n                              cont \\<in> cntt_a}", "by (rule Un_mono_approx[OF old_elems new_elem])"], ["proof (state)\nthis:\n  |evalF\\<cdot>(Discr (cntt, [], ve, nb b ct))| \\<union>\n  |{((ct, [ct \\<mapsto> b]),\n     cntt)}| \\<lessapprox> (\\<Union>cnt\\<in>cntt_a.\n                               \\<aF>\\<cdot>\n                               (Discr\n                                 (cnt, [], ve_a, \\<anb> b_a ct))) \\<union>\n                           {((ct, [ct \\<mapsto> b_a]), cont) |cont.\n                            cont \\<in> cntt_a}\n\ngoal (2 subgoals):\n 1. \\<And>x21 x22 x1 x21aa x21aaa.\n       \\<lbrakk>fstate =\n                (DP (prim.If x21 x22), [DI x1, x21aa, x21aaa], ve, b);\n        fstate_a = (PP (prim.If x21 x22), ds_a, ve_a, b_a);\n        |ve| \\<lessapprox> ve_a; [{}, |x21aa|, |x21aaa|] \\<lessapprox> ds_a;\n        Suc (Suc (Suc 0)) = length ds_a; proc = PP (prim.If x21 x22);\n        d = DP (prim.If x21 x22); ds = [DI x1, x21aa, x21aaa];\n        x1 \\<noteq> 0; isProc x21aa; isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> |insert ((x21, [x21 \\<mapsto> b]), x21aa)\n                           (evalF\\<cdot>\n                            (Discr\n                              (x21aa, [], ve,\n                               nb b\n                                x21)))| \\<lessapprox> \\<aF>\\<cdot>\n                (Discr (PP (prim.If x21 x22), ds_a, ve_a, b_a))\n 2. \\<And>x21 x22 x21aa x21aaa.\n       \\<lbrakk>fstate =\n                (DP (prim.If x21 x22), [DI 0, x21aa, x21aaa], ve, b);\n        fstate_a = (PP (prim.If x21 x22), ds_a, ve_a, b_a);\n        |ve| \\<lessapprox> ve_a; [{}, |x21aa|, |x21aaa|] \\<lessapprox> ds_a;\n        Suc (Suc (Suc 0)) = length ds_a; proc = PP (prim.If x21 x22);\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa]; isProc x21aa;\n        isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> |insert ((x22, [x22 \\<mapsto> b]), x21aaa)\n                           (evalF\\<cdot>\n                            (Discr\n                              (x21aaa, [], ve,\n                               nb b\n                                x22)))| \\<lessapprox> \\<aF>\\<cdot>\n                (Discr (PP (prim.If x21 x22), ds_a, ve_a, b_a))", "also"], ["proof (state)\nthis:\n  |evalF\\<cdot>(Discr (cntt, [], ve, nb b ct))| \\<union>\n  |{((ct, [ct \\<mapsto> b]),\n     cntt)}| \\<lessapprox> (\\<Union>cnt\\<in>cntt_a.\n                               \\<aF>\\<cdot>\n                               (Discr\n                                 (cnt, [], ve_a, \\<anb> b_a ct))) \\<union>\n                           {((ct, [ct \\<mapsto> b_a]), cont) |cont.\n                            cont \\<in> cntt_a}\n\ngoal (2 subgoals):\n 1. \\<And>x21 x22 x1 x21aa x21aaa.\n       \\<lbrakk>fstate =\n                (DP (prim.If x21 x22), [DI x1, x21aa, x21aaa], ve, b);\n        fstate_a = (PP (prim.If x21 x22), ds_a, ve_a, b_a);\n        |ve| \\<lessapprox> ve_a; [{}, |x21aa|, |x21aaa|] \\<lessapprox> ds_a;\n        Suc (Suc (Suc 0)) = length ds_a; proc = PP (prim.If x21 x22);\n        d = DP (prim.If x21 x22); ds = [DI x1, x21aa, x21aaa];\n        x1 \\<noteq> 0; isProc x21aa; isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> |insert ((x21, [x21 \\<mapsto> b]), x21aa)\n                           (evalF\\<cdot>\n                            (Discr\n                              (x21aa, [], ve,\n                               nb b\n                                x21)))| \\<lessapprox> \\<aF>\\<cdot>\n                (Discr (PP (prim.If x21 x22), ds_a, ve_a, b_a))\n 2. \\<And>x21 x22 x21aa x21aaa.\n       \\<lbrakk>fstate =\n                (DP (prim.If x21 x22), [DI 0, x21aa, x21aaa], ve, b);\n        fstate_a = (PP (prim.If x21 x22), ds_a, ve_a, b_a);\n        |ve| \\<lessapprox> ve_a; [{}, |x21aa|, |x21aaa|] \\<lessapprox> ds_a;\n        Suc (Suc (Suc 0)) = length ds_a; proc = PP (prim.If x21 x22);\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa]; isProc x21aa;\n        isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> |insert ((x22, [x22 \\<mapsto> b]), x21aaa)\n                           (evalF\\<cdot>\n                            (Discr\n                              (x21aaa, [], ve,\n                               nb b\n                                x22)))| \\<lessapprox> \\<aF>\\<cdot>\n                (Discr (PP (prim.If x21 x22), ds_a, ve_a, b_a))", "have \"\\<dots> \\<lessapprox>\n        ((\\<Union>cnt\\<in>cntt_a. \\<aF>\\<cdot>(Discr (cnt, [], ve_a, \\<anb> b_a ct)))\n          \\<union> {((ct, [ct \\<mapsto> b_a]), cont) |cont. cont \\<in> cntt_a})\n      \\<union> ((\\<Union>cnt\\<in>cntf_a. \\<aF>\\<cdot>(Discr (cnt, [], ve_a, \\<anb> b_a cf)))\n          \\<union> {((cf, [cf \\<mapsto> b_a]), cont) |cont. cont \\<in> cntf_a})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>cnt\\<in>cntt_a.\n        \\<aF>\\<cdot>(Discr (cnt, [], ve_a, \\<anb> b_a ct))) \\<union>\n    {((ct, [ct \\<mapsto> b_a]), cont) |cont.\n     cont\n     \\<in> cntt_a} \\<lessapprox> (\\<Union>cnt\\<in>cntt_a.\n                                     \\<aF>\\<cdot>\n                                     (Discr\n (cnt, [], ve_a, \\<anb> b_a ct))) \\<union>\n                                 {((ct, [ct \\<mapsto> b_a]), cont) |cont.\n                                  cont \\<in> cntt_a} \\<union>\n                                 ((\\<Union>cnt\\<in>cntf_a.\n\\<aF>\\<cdot>(Discr (cnt, [], ve_a, \\<anb> b_a cf))) \\<union>\n                                  {((cf, [cf \\<mapsto> b_a]), cont) |cont.\n                                   cont \\<in> cntf_a})", "by (rule Un_upper1_approx|rule Un_upper2_approx)"], ["proof (state)\nthis:\n  (\\<Union>cnt\\<in>cntt_a.\n      \\<aF>\\<cdot>(Discr (cnt, [], ve_a, \\<anb> b_a ct))) \\<union>\n  {((ct, [ct \\<mapsto> b_a]), cont) |cont.\n   cont\n   \\<in> cntt_a} \\<lessapprox> (\\<Union>cnt\\<in>cntt_a.\n                                   \\<aF>\\<cdot>\n                                   (Discr\n                                     (cnt, [], ve_a,\n\\<anb> b_a ct))) \\<union>\n                               {((ct, [ct \\<mapsto> b_a]), cont) |cont.\n                                cont \\<in> cntt_a} \\<union>\n                               ((\\<Union>cnt\\<in>cntf_a.\n                                    \\<aF>\\<cdot>\n                                    (Discr\n(cnt, [], ve_a, \\<anb> b_a cf))) \\<union>\n                                {((cf, [cf \\<mapsto> b_a]), cont) |cont.\n                                 cont \\<in> cntf_a})\n\ngoal (2 subgoals):\n 1. \\<And>x21 x22 x1 x21aa x21aaa.\n       \\<lbrakk>fstate =\n                (DP (prim.If x21 x22), [DI x1, x21aa, x21aaa], ve, b);\n        fstate_a = (PP (prim.If x21 x22), ds_a, ve_a, b_a);\n        |ve| \\<lessapprox> ve_a; [{}, |x21aa|, |x21aaa|] \\<lessapprox> ds_a;\n        Suc (Suc (Suc 0)) = length ds_a; proc = PP (prim.If x21 x22);\n        d = DP (prim.If x21 x22); ds = [DI x1, x21aa, x21aaa];\n        x1 \\<noteq> 0; isProc x21aa; isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> |insert ((x21, [x21 \\<mapsto> b]), x21aa)\n                           (evalF\\<cdot>\n                            (Discr\n                              (x21aa, [], ve,\n                               nb b\n                                x21)))| \\<lessapprox> \\<aF>\\<cdot>\n                (Discr (PP (prim.If x21 x22), ds_a, ve_a, b_a))\n 2. \\<And>x21 x22 x21aa x21aaa.\n       \\<lbrakk>fstate =\n                (DP (prim.If x21 x22), [DI 0, x21aa, x21aaa], ve, b);\n        fstate_a = (PP (prim.If x21 x22), ds_a, ve_a, b_a);\n        |ve| \\<lessapprox> ve_a; [{}, |x21aa|, |x21aaa|] \\<lessapprox> ds_a;\n        Suc (Suc (Suc 0)) = length ds_a; proc = PP (prim.If x21 x22);\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa]; isProc x21aa;\n        isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> |insert ((x22, [x22 \\<mapsto> b]), x21aaa)\n                           (evalF\\<cdot>\n                            (Discr\n                              (x21aaa, [], ve,\n                               nb b\n                                x22)))| \\<lessapprox> \\<aF>\\<cdot>\n                (Discr (PP (prim.If x21 x22), ds_a, ve_a, b_a))", "finally"], ["proof (chain)\npicking this:\n  |evalF\\<cdot>(Discr (cntt, [], ve, nb b ct)) \\<union>\n   {((ct, [ct \\<mapsto> b]),\n     cntt)}| \\<lessapprox> (\\<Union>cnt\\<in>cntt_a.\n                               \\<aF>\\<cdot>\n                               (Discr\n                                 (cnt, [], ve_a, \\<anb> b_a ct))) \\<union>\n                           {((ct, [ct \\<mapsto> b_a]), cont) |cont.\n                            cont \\<in> cntt_a} \\<union>\n                           ((\\<Union>cnt\\<in>cntf_a.\n                                \\<aF>\\<cdot>\n                                (Discr\n                                  (cnt, [], ve_a, \\<anb> b_a cf))) \\<union>\n                            {((cf, [cf \\<mapsto> b_a]), cont) |cont.\n                             cont \\<in> cntf_a})", "show \"|insert ((?c, [?c \\<mapsto> b]), ?cnt)\n                (evalF\\<cdot>(Discr (?cnt, [], ve, nb b ?c)))| \\<lessapprox>\n          \\<aF>\\<cdot>(Discr (PP (prim.If ct cf), ds_a, ve_a, b_a))\""], ["proof (prove)\nusing this:\n  |evalF\\<cdot>(Discr (cntt, [], ve, nb b ct)) \\<union>\n   {((ct, [ct \\<mapsto> b]),\n     cntt)}| \\<lessapprox> (\\<Union>cnt\\<in>cntt_a.\n                               \\<aF>\\<cdot>\n                               (Discr\n                                 (cnt, [], ve_a, \\<anb> b_a ct))) \\<union>\n                           {((ct, [ct \\<mapsto> b_a]), cont) |cont.\n                            cont \\<in> cntt_a} \\<union>\n                           ((\\<Union>cnt\\<in>cntf_a.\n                                \\<aF>\\<cdot>\n                                (Discr\n                                  (cnt, [], ve_a, \\<anb> b_a cf))) \\<union>\n                            {((cf, [cf \\<mapsto> b_a]), cont) |cont.\n                             cont \\<in> cntf_a})\n\ngoal (1 subgoal):\n 1. |insert ((ct, [ct \\<mapsto> b]), cntt)\n      (evalF\\<cdot>\n       (Discr\n         (cntt, [], ve,\n          nb b\n           ct)))| \\<lessapprox> \\<aF>\\<cdot>\n                                (Discr\n                                  (PP (prim.If ct cf), ds_a, ve_a, b_a))", "using ds_a"], ["proof (prove)\nusing this:\n  |evalF\\<cdot>(Discr (cntt, [], ve, nb b ct)) \\<union>\n   {((ct, [ct \\<mapsto> b]),\n     cntt)}| \\<lessapprox> (\\<Union>cnt\\<in>cntt_a.\n                               \\<aF>\\<cdot>\n                               (Discr\n                                 (cnt, [], ve_a, \\<anb> b_a ct))) \\<union>\n                           {((ct, [ct \\<mapsto> b_a]), cont) |cont.\n                            cont \\<in> cntt_a} \\<union>\n                           ((\\<Union>cnt\\<in>cntf_a.\n                                \\<aF>\\<cdot>\n                                (Discr\n                                  (cnt, [], ve_a, \\<anb> b_a cf))) \\<union>\n                            {((cf, [cf \\<mapsto> b_a]), cont) |cont.\n                             cont \\<in> cntf_a})\n  ds_a = [v_a, cntt_a, cntf_a]\n\ngoal (1 subgoal):\n 1. |insert ((ct, [ct \\<mapsto> b]), cntt)\n      (evalF\\<cdot>\n       (Discr\n         (cntt, [], ve,\n          nb b\n           ct)))| \\<lessapprox> \\<aF>\\<cdot>\n                                (Discr\n                                  (PP (prim.If ct cf), ds_a, ve_a, b_a))", "by (subst a_evalF.simps)(auto simp del:a_evalF.simps)"], ["proof (state)\nthis:\n  |insert ((ct, [ct \\<mapsto> b]), cntt)\n    (evalF\\<cdot>\n     (Discr\n       (cntt, [], ve,\n        nb b\n         ct)))| \\<lessapprox> \\<aF>\\<cdot>\n                              (Discr (PP (prim.If ct cf), ds_a, ve_a, b_a))\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x21aa x21aaa.\n       \\<lbrakk>fstate =\n                (DP (prim.If x21 x22), [DI 0, x21aa, x21aaa], ve, b);\n        fstate_a = (PP (prim.If x21 x22), ds_a, ve_a, b_a);\n        |ve| \\<lessapprox> ve_a; [{}, |x21aa|, |x21aaa|] \\<lessapprox> ds_a;\n        Suc (Suc (Suc 0)) = length ds_a; proc = PP (prim.If x21 x22);\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa]; isProc x21aa;\n        isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> |insert ((x22, [x22 \\<mapsto> b]), x21aaa)\n                           (evalF\\<cdot>\n                            (Discr\n                              (x21aaa, [], ve,\n                               nb b\n                                x22)))| \\<lessapprox> \\<aF>\\<cdot>\n                (Discr (PP (prim.If x21 x22), ds_a, ve_a, b_a))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x21aa x21aaa.\n       \\<lbrakk>fstate =\n                (DP (prim.If x21 x22), [DI 0, x21aa, x21aaa], ve, b);\n        fstate_a = (PP (prim.If x21 x22), ds_a, ve_a, b_a);\n        |ve| \\<lessapprox> ve_a; [{}, |x21aa|, |x21aaa|] \\<lessapprox> ds_a;\n        Suc (Suc (Suc 0)) = length ds_a; proc = PP (prim.If x21 x22);\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa]; isProc x21aa;\n        isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> |insert ((x22, [x22 \\<mapsto> b]), x21aaa)\n                           (evalF\\<cdot>\n                            (Discr\n                              (x21aaa, [], ve,\n                               nb b\n                                x22)))| \\<lessapprox> \\<aF>\\<cdot>\n                (Discr (PP (prim.If x21 x22), ds_a, ve_a, b_a))", "txt \\<open>Case If (false branch). We use schematic variable to keep this similar to the true branch.\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x21aa x21aaa.\n       \\<lbrakk>fstate =\n                (DP (prim.If x21 x22), [DI 0, x21aa, x21aaa], ve, b);\n        fstate_a = (PP (prim.If x21 x22), ds_a, ve_a, b_a);\n        |ve| \\<lessapprox> ve_a; [{}, |x21aa|, |x21aaa|] \\<lessapprox> ds_a;\n        Suc (Suc (Suc 0)) = length ds_a; proc = PP (prim.If x21 x22);\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa]; isProc x21aa;\n        isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> |insert ((x22, [x22 \\<mapsto> b]), x21aaa)\n                           (evalF\\<cdot>\n                            (Discr\n                              (x21aaa, [], ve,\n                               nb b\n                                x22)))| \\<lessapprox> \\<aF>\\<cdot>\n                (Discr (PP (prim.If x21 x22), ds_a, ve_a, b_a))", "fix ct cf v cntt cntf"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x21aa x21aaa.\n       \\<lbrakk>fstate =\n                (DP (prim.If x21 x22), [DI 0, x21aa, x21aaa], ve, b);\n        fstate_a = (PP (prim.If x21 x22), ds_a, ve_a, b_a);\n        |ve| \\<lessapprox> ve_a; [{}, |x21aa|, |x21aaa|] \\<lessapprox> ds_a;\n        Suc (Suc (Suc 0)) = length ds_a; proc = PP (prim.If x21 x22);\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa]; isProc x21aa;\n        isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> |insert ((x22, [x22 \\<mapsto> b]), x21aaa)\n                           (evalF\\<cdot>\n                            (Discr\n                              (x21aaa, [], ve,\n                               nb b\n                                x22)))| \\<lessapprox> \\<aF>\\<cdot>\n                (Discr (PP (prim.If x21 x22), ds_a, ve_a, b_a))", "assume \"isProc cntt\""], ["proof (state)\nthis:\n  isProc cntt\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x21aa x21aaa.\n       \\<lbrakk>fstate =\n                (DP (prim.If x21 x22), [DI 0, x21aa, x21aaa], ve, b);\n        fstate_a = (PP (prim.If x21 x22), ds_a, ve_a, b_a);\n        |ve| \\<lessapprox> ve_a; [{}, |x21aa|, |x21aaa|] \\<lessapprox> ds_a;\n        Suc (Suc (Suc 0)) = length ds_a; proc = PP (prim.If x21 x22);\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa]; isProc x21aa;\n        isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> |insert ((x22, [x22 \\<mapsto> b]), x21aaa)\n                           (evalF\\<cdot>\n                            (Discr\n                              (x21aaa, [], ve,\n                               nb b\n                                x22)))| \\<lessapprox> \\<aF>\\<cdot>\n                (Discr (PP (prim.If x21 x22), ds_a, ve_a, b_a))", "assume \"isProc cntf\""], ["proof (state)\nthis:\n  isProc cntf\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x21aa x21aaa.\n       \\<lbrakk>fstate =\n                (DP (prim.If x21 x22), [DI 0, x21aa, x21aaa], ve, b);\n        fstate_a = (PP (prim.If x21 x22), ds_a, ve_a, b_a);\n        |ve| \\<lessapprox> ve_a; [{}, |x21aa|, |x21aaa|] \\<lessapprox> ds_a;\n        Suc (Suc (Suc 0)) = length ds_a; proc = PP (prim.If x21 x22);\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa]; isProc x21aa;\n        isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> |insert ((x22, [x22 \\<mapsto> b]), x21aaa)\n                           (evalF\\<cdot>\n                            (Discr\n                              (x21aaa, [], ve,\n                               nb b\n                                x22)))| \\<lessapprox> \\<aF>\\<cdot>\n                (Discr (PP (prim.If x21 x22), ds_a, ve_a, b_a))", "assume abs_ds': \"[{}, |cntt|, |cntf| ] \\<lessapprox> ds_a\""], ["proof (state)\nthis:\n  [{}, |cntt|, |cntf|] \\<lessapprox> ds_a\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x21aa x21aaa.\n       \\<lbrakk>fstate =\n                (DP (prim.If x21 x22), [DI 0, x21aa, x21aaa], ve, b);\n        fstate_a = (PP (prim.If x21 x22), ds_a, ve_a, b_a);\n        |ve| \\<lessapprox> ve_a; [{}, |x21aa|, |x21aaa|] \\<lessapprox> ds_a;\n        Suc (Suc (Suc 0)) = length ds_a; proc = PP (prim.If x21 x22);\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa]; isProc x21aa;\n        isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> |insert ((x22, [x22 \\<mapsto> b]), x21aaa)\n                           (evalF\\<cdot>\n                            (Discr\n                              (x21aaa, [], ve,\n                               nb b\n                                x22)))| \\<lessapprox> \\<aF>\\<cdot>\n                (Discr (PP (prim.If x21 x22), ds_a, ve_a, b_a))", "then"], ["proof (chain)\npicking this:\n  [{}, |cntt|, |cntf|] \\<lessapprox> ds_a", "obtain v_a cntt_a cntf_a where ds_a: \"ds_a = [v_a, cntt_a, cntf_a]\"\n                              and abs_cntt: \"|cntt| \\<lessapprox> cntt_a\"\n                              and abs_cntf: \"|cntf| \\<lessapprox> cntf_a\""], ["proof (prove)\nusing this:\n  [{}, |cntt|, |cntf|] \\<lessapprox> ds_a\n\ngoal (1 subgoal):\n 1. (\\<And>v_a cntt_a cntf_a.\n        \\<lbrakk>ds_a = [v_a, cntt_a, cntf_a]; |cntt| \\<lessapprox> cntt_a;\n         |cntf| \\<lessapprox> cntf_a\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases ds_a rule:list.exhaust[OF _ list.exhaust[OF _ list.exhaust, of _ _ \"\\<lambda>_ x. x\"],  of _ _ \"\\<lambda>_ x. x\"])\n       (auto simp add:ds_approx_def)"], ["proof (state)\nthis:\n  ds_a = [v_a, cntt_a, cntf_a]\n  |cntt| \\<lessapprox> cntt_a\n  |cntf| \\<lessapprox> cntf_a\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x21aa x21aaa.\n       \\<lbrakk>fstate =\n                (DP (prim.If x21 x22), [DI 0, x21aa, x21aaa], ve, b);\n        fstate_a = (PP (prim.If x21 x22), ds_a, ve_a, b_a);\n        |ve| \\<lessapprox> ve_a; [{}, |x21aa|, |x21aaa|] \\<lessapprox> ds_a;\n        Suc (Suc (Suc 0)) = length ds_a; proc = PP (prim.If x21 x22);\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa]; isProc x21aa;\n        isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> |insert ((x22, [x22 \\<mapsto> b]), x21aaa)\n                           (evalF\\<cdot>\n                            (Discr\n                              (x21aaa, [], ve,\n                               nb b\n                                x22)))| \\<lessapprox> \\<aF>\\<cdot>\n                (Discr (PP (prim.If x21 x22), ds_a, ve_a, b_a))", "let ?c = \"cf::label\" and ?cnt = cntf and ?cnt_a = cntf_a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x21aa x21aaa.\n       \\<lbrakk>fstate =\n                (DP (prim.If x21 x22), [DI 0, x21aa, x21aaa], ve, b);\n        fstate_a = (PP (prim.If x21 x22), ds_a, ve_a, b_a);\n        |ve| \\<lessapprox> ve_a; [{}, |x21aa|, |x21aaa|] \\<lessapprox> ds_a;\n        Suc (Suc (Suc 0)) = length ds_a; proc = PP (prim.If x21 x22);\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa]; isProc x21aa;\n        isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> |insert ((x22, [x22 \\<mapsto> b]), x21aaa)\n                           (evalF\\<cdot>\n                            (Discr\n                              (x21aaa, [], ve,\n                               nb b\n                                x22)))| \\<lessapprox> \\<aF>\\<cdot>\n                (Discr (PP (prim.If x21 x22), ds_a, ve_a, b_a))", "have new_elem: \"|{((?c, [?c \\<mapsto> b]), ?cnt)}| \\<lessapprox> {((?c, [?c \\<mapsto> b_a]), cont) |cont. cont \\<in> ?cnt_a}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. |{((cf, [cf \\<mapsto> b]),\n       cntf)}| \\<lessapprox> {((cf, [cf \\<mapsto> b_a]), cont) |cont.\n                              cont \\<in> cntf_a}", "using abs_cntt and abs_cntf and abs_b"], ["proof (prove)\nusing this:\n  |cntt| \\<lessapprox> cntt_a\n  |cntf| \\<lessapprox> cntf_a\n  |b| = b_a\n\ngoal (1 subgoal):\n 1. |{((cf, [cf \\<mapsto> b]),\n       cntf)}| \\<lessapprox> {((cf, [cf \\<mapsto> b_a]), cont) |cont.\n                              cont \\<in> cntf_a}", "by (auto simp add:ccache_approx_def d_approx_def)"], ["proof (state)\nthis:\n  |{((cf, [cf \\<mapsto> b]),\n     cntf)}| \\<lessapprox> {((cf, [cf \\<mapsto> b_a]), cont) |cont.\n                            cont \\<in> cntf_a}\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x21aa x21aaa.\n       \\<lbrakk>fstate =\n                (DP (prim.If x21 x22), [DI 0, x21aa, x21aaa], ve, b);\n        fstate_a = (PP (prim.If x21 x22), ds_a, ve_a, b_a);\n        |ve| \\<lessapprox> ve_a; [{}, |x21aa|, |x21aaa|] \\<lessapprox> ds_a;\n        Suc (Suc (Suc 0)) = length ds_a; proc = PP (prim.If x21 x22);\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa]; isProc x21aa;\n        isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> |insert ((x22, [x22 \\<mapsto> b]), x21aaa)\n                           (evalF\\<cdot>\n                            (Discr\n                              (x21aaa, [], ve,\n                               nb b\n                                x22)))| \\<lessapprox> \\<aF>\\<cdot>\n                (Discr (PP (prim.If x21 x22), ds_a, ve_a, b_a))", "have prem: \"|(?cnt, [], ve, nb b ?c)| \\<lessapprox>\n              (the_elem |?cnt|, [], ve_a, \\<anb> b_a ?c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. |(cntf, [], ve,\n      nb b cf)| \\<lessapprox> (the_elem |cntf|, [], ve_a, \\<anb> b_a cf)", "using abs_ve and abs_b"], ["proof (prove)\nusing this:\n  |ve| \\<lessapprox> ve_a\n  |b| = b_a\n\ngoal (1 subgoal):\n 1. |(cntf, [], ve,\n      nb b cf)| \\<lessapprox> (the_elem |cntf|, [], ve_a, \\<anb> b_a cf)", "by (auto intro:fstate_approx.intros)"], ["proof (state)\nthis:\n  |(cntf, [], ve,\n    nb b cf)| \\<lessapprox> (the_elem |cntf|, [], ve_a, \\<anb> b_a cf)\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x21aa x21aaa.\n       \\<lbrakk>fstate =\n                (DP (prim.If x21 x22), [DI 0, x21aa, x21aaa], ve, b);\n        fstate_a = (PP (prim.If x21 x22), ds_a, ve_a, b_a);\n        |ve| \\<lessapprox> ve_a; [{}, |x21aa|, |x21aaa|] \\<lessapprox> ds_a;\n        Suc (Suc (Suc 0)) = length ds_a; proc = PP (prim.If x21 x22);\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa]; isProc x21aa;\n        isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> |insert ((x22, [x22 \\<mapsto> b]), x21aaa)\n                           (evalF\\<cdot>\n                            (Discr\n                              (x21aaa, [], ve,\n                               nb b\n                                x22)))| \\<lessapprox> \\<aF>\\<cdot>\n                (Discr (PP (prim.If x21 x22), ds_a, ve_a, b_a))", "have \"|evalF\\<cdot>(Discr (?cnt, [], ve, nb b ?c))|\n       \\<lessapprox> \\<aF>\\<cdot>(Discr (the_elem |?cnt|, [], ve_a, \\<anb> b_a ?c))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. |evalF\\<cdot>\n     (Discr\n       (cntf, [], ve,\n        nb b\n         cf))| \\<lessapprox> \\<aF>\\<cdot>\n                             (Discr\n                               (the_elem |cntf|, [], ve_a, \\<anb> b_a cf))", "by (rule Next.hyps(1)[OF prem])"], ["proof (state)\nthis:\n  |evalF\\<cdot>\n   (Discr\n     (cntf, [], ve,\n      nb b\n       cf))| \\<lessapprox> \\<aF>\\<cdot>\n                           (Discr\n                             (the_elem |cntf|, [], ve_a, \\<anb> b_a cf))\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x21aa x21aaa.\n       \\<lbrakk>fstate =\n                (DP (prim.If x21 x22), [DI 0, x21aa, x21aaa], ve, b);\n        fstate_a = (PP (prim.If x21 x22), ds_a, ve_a, b_a);\n        |ve| \\<lessapprox> ve_a; [{}, |x21aa|, |x21aaa|] \\<lessapprox> ds_a;\n        Suc (Suc (Suc 0)) = length ds_a; proc = PP (prim.If x21 x22);\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa]; isProc x21aa;\n        isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> |insert ((x22, [x22 \\<mapsto> b]), x21aaa)\n                           (evalF\\<cdot>\n                            (Discr\n                              (x21aaa, [], ve,\n                               nb b\n                                x22)))| \\<lessapprox> \\<aF>\\<cdot>\n                (Discr (PP (prim.If x21 x22), ds_a, ve_a, b_a))", "also"], ["proof (state)\nthis:\n  |evalF\\<cdot>\n   (Discr\n     (cntf, [], ve,\n      nb b\n       cf))| \\<lessapprox> \\<aF>\\<cdot>\n                           (Discr\n                             (the_elem |cntf|, [], ve_a, \\<anb> b_a cf))\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x21aa x21aaa.\n       \\<lbrakk>fstate =\n                (DP (prim.If x21 x22), [DI 0, x21aa, x21aaa], ve, b);\n        fstate_a = (PP (prim.If x21 x22), ds_a, ve_a, b_a);\n        |ve| \\<lessapprox> ve_a; [{}, |x21aa|, |x21aaa|] \\<lessapprox> ds_a;\n        Suc (Suc (Suc 0)) = length ds_a; proc = PP (prim.If x21 x22);\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa]; isProc x21aa;\n        isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> |insert ((x22, [x22 \\<mapsto> b]), x21aaa)\n                           (evalF\\<cdot>\n                            (Discr\n                              (x21aaa, [], ve,\n                               nb b\n                                x22)))| \\<lessapprox> \\<aF>\\<cdot>\n                (Discr (PP (prim.If x21 x22), ds_a, ve_a, b_a))", "have \"\\<dots> \\<lessapprox> (\\<Union>cnt\\<in>?cnt_a. \\<aF>\\<cdot>(Discr (cnt, [], ve_a, \\<anb> b_a ?c)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<aF>\\<cdot>\n    (Discr\n      (the_elem |cntf|, [], ve_a,\n       \\<anb> b_a\n        cf)) \\<lessapprox> \\<Union>cnt\\<in>cntf_a.\n                              \\<aF>\\<cdot>\n                              (Discr (cnt, [], ve_a, \\<anb> b_a cf))", "using abs_cntt and abs_cntf"], ["proof (prove)\nusing this:\n  |cntt| \\<lessapprox> cntt_a\n  |cntf| \\<lessapprox> cntf_a\n\ngoal (1 subgoal):\n 1. \\<aF>\\<cdot>\n    (Discr\n      (the_elem |cntf|, [], ve_a,\n       \\<anb> b_a\n        cf)) \\<lessapprox> \\<Union>cnt\\<in>cntf_a.\n                              \\<aF>\\<cdot>\n                              (Discr (cnt, [], ve_a, \\<anb> b_a cf))", "by (auto intro: the_elem_is_Proc[OF \\<open>isProc ?cnt\\<close>] simp del: a_evalF.simps simp add:ccache_approx_def d_approx_def)"], ["proof (state)\nthis:\n  \\<aF>\\<cdot>\n  (Discr\n    (the_elem |cntf|, [], ve_a,\n     \\<anb> b_a\n      cf)) \\<lessapprox> \\<Union>cnt\\<in>cntf_a.\n                            \\<aF>\\<cdot>\n                            (Discr (cnt, [], ve_a, \\<anb> b_a cf))\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x21aa x21aaa.\n       \\<lbrakk>fstate =\n                (DP (prim.If x21 x22), [DI 0, x21aa, x21aaa], ve, b);\n        fstate_a = (PP (prim.If x21 x22), ds_a, ve_a, b_a);\n        |ve| \\<lessapprox> ve_a; [{}, |x21aa|, |x21aaa|] \\<lessapprox> ds_a;\n        Suc (Suc (Suc 0)) = length ds_a; proc = PP (prim.If x21 x22);\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa]; isProc x21aa;\n        isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> |insert ((x22, [x22 \\<mapsto> b]), x21aaa)\n                           (evalF\\<cdot>\n                            (Discr\n                              (x21aaa, [], ve,\n                               nb b\n                                x22)))| \\<lessapprox> \\<aF>\\<cdot>\n                (Discr (PP (prim.If x21 x22), ds_a, ve_a, b_a))", "finally"], ["proof (chain)\npicking this:\n  |evalF\\<cdot>\n   (Discr\n     (cntf, [], ve,\n      nb b\n       cf))| \\<lessapprox> \\<Union>cnt\\<in>cntf_a.\n                              \\<aF>\\<cdot>\n                              (Discr (cnt, [], ve_a, \\<anb> b_a cf))", "have old_elems: \"|evalF\\<cdot>(Discr (?cnt, [], ve, nb b ?c))|\n       \\<lessapprox> (\\<Union>cnt\\<in>?cnt_a. \\<aF>\\<cdot>(Discr (cnt, [], ve_a, \\<anb> b_a ?c)))\""], ["proof (prove)\nusing this:\n  |evalF\\<cdot>\n   (Discr\n     (cntf, [], ve,\n      nb b\n       cf))| \\<lessapprox> \\<Union>cnt\\<in>cntf_a.\n                              \\<aF>\\<cdot>\n                              (Discr (cnt, [], ve_a, \\<anb> b_a cf))\n\ngoal (1 subgoal):\n 1. |evalF\\<cdot>\n     (Discr\n       (cntf, [], ve,\n        nb b\n         cf))| \\<lessapprox> \\<Union>cnt\\<in>cntf_a.\n                                \\<aF>\\<cdot>\n                                (Discr (cnt, [], ve_a, \\<anb> b_a cf))", "."], ["proof (state)\nthis:\n  |evalF\\<cdot>\n   (Discr\n     (cntf, [], ve,\n      nb b\n       cf))| \\<lessapprox> \\<Union>cnt\\<in>cntf_a.\n                              \\<aF>\\<cdot>\n                              (Discr (cnt, [], ve_a, \\<anb> b_a cf))\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x21aa x21aaa.\n       \\<lbrakk>fstate =\n                (DP (prim.If x21 x22), [DI 0, x21aa, x21aaa], ve, b);\n        fstate_a = (PP (prim.If x21 x22), ds_a, ve_a, b_a);\n        |ve| \\<lessapprox> ve_a; [{}, |x21aa|, |x21aaa|] \\<lessapprox> ds_a;\n        Suc (Suc (Suc 0)) = length ds_a; proc = PP (prim.If x21 x22);\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa]; isProc x21aa;\n        isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> |insert ((x22, [x22 \\<mapsto> b]), x21aaa)\n                           (evalF\\<cdot>\n                            (Discr\n                              (x21aaa, [], ve,\n                               nb b\n                                x22)))| \\<lessapprox> \\<aF>\\<cdot>\n                (Discr (PP (prim.If x21 x22), ds_a, ve_a, b_a))", "have \"|evalF\\<cdot>(Discr (?cnt, [], ve, nb b ?c))\n          \\<union> {((?c, [?c \\<mapsto> b]), ?cnt)}|\n        \\<lessapprox> |evalF\\<cdot>(Discr (?cnt, [], ve, nb b ?c))|\n          \\<union> |{((?c, [?c \\<mapsto> b]), ?cnt)}|\""], ["proof (prove)\ngoal (1 subgoal):\n 1. |evalF\\<cdot>(Discr (cntf, [], ve, nb b cf)) \\<union>\n     {((cf, [cf \\<mapsto> b]),\n       cntf)}| \\<lessapprox> |evalF\\<cdot>\n                              (Discr (cntf, [], ve, nb b cf))| \\<union>\n                             |{((cf, [cf \\<mapsto> b]), cntf)}|", "by (rule abs_ccache_union)"], ["proof (state)\nthis:\n  |evalF\\<cdot>(Discr (cntf, [], ve, nb b cf)) \\<union>\n   {((cf, [cf \\<mapsto> b]),\n     cntf)}| \\<lessapprox> |evalF\\<cdot>\n                            (Discr (cntf, [], ve, nb b cf))| \\<union>\n                           |{((cf, [cf \\<mapsto> b]), cntf)}|\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x21aa x21aaa.\n       \\<lbrakk>fstate =\n                (DP (prim.If x21 x22), [DI 0, x21aa, x21aaa], ve, b);\n        fstate_a = (PP (prim.If x21 x22), ds_a, ve_a, b_a);\n        |ve| \\<lessapprox> ve_a; [{}, |x21aa|, |x21aaa|] \\<lessapprox> ds_a;\n        Suc (Suc (Suc 0)) = length ds_a; proc = PP (prim.If x21 x22);\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa]; isProc x21aa;\n        isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> |insert ((x22, [x22 \\<mapsto> b]), x21aaa)\n                           (evalF\\<cdot>\n                            (Discr\n                              (x21aaa, [], ve,\n                               nb b\n                                x22)))| \\<lessapprox> \\<aF>\\<cdot>\n                (Discr (PP (prim.If x21 x22), ds_a, ve_a, b_a))", "also"], ["proof (state)\nthis:\n  |evalF\\<cdot>(Discr (cntf, [], ve, nb b cf)) \\<union>\n   {((cf, [cf \\<mapsto> b]),\n     cntf)}| \\<lessapprox> |evalF\\<cdot>\n                            (Discr (cntf, [], ve, nb b cf))| \\<union>\n                           |{((cf, [cf \\<mapsto> b]), cntf)}|\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x21aa x21aaa.\n       \\<lbrakk>fstate =\n                (DP (prim.If x21 x22), [DI 0, x21aa, x21aaa], ve, b);\n        fstate_a = (PP (prim.If x21 x22), ds_a, ve_a, b_a);\n        |ve| \\<lessapprox> ve_a; [{}, |x21aa|, |x21aaa|] \\<lessapprox> ds_a;\n        Suc (Suc (Suc 0)) = length ds_a; proc = PP (prim.If x21 x22);\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa]; isProc x21aa;\n        isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> |insert ((x22, [x22 \\<mapsto> b]), x21aaa)\n                           (evalF\\<cdot>\n                            (Discr\n                              (x21aaa, [], ve,\n                               nb b\n                                x22)))| \\<lessapprox> \\<aF>\\<cdot>\n                (Discr (PP (prim.If x21 x22), ds_a, ve_a, b_a))", "have \"\\<dots> \\<lessapprox>\n        (\\<Union>cnt\\<in>?cnt_a. \\<aF>\\<cdot>(Discr (cnt, [], ve_a, \\<anb> b_a ?c)))\n        \\<union> {((?c, [?c \\<mapsto> b_a]), cont) |cont. cont \\<in> ?cnt_a}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. |evalF\\<cdot>(Discr (cntf, [], ve, nb b cf))| \\<union>\n    |{((cf, [cf \\<mapsto> b]),\n       cntf)}| \\<lessapprox> (\\<Union>cnt\\<in>cntf_a.\n                                 \\<aF>\\<cdot>\n                                 (Discr\n                                   (cnt, [], ve_a, \\<anb> b_a cf))) \\<union>\n                             {((cf, [cf \\<mapsto> b_a]), cont) |cont.\n                              cont \\<in> cntf_a}", "by (rule Un_mono_approx[OF old_elems new_elem])"], ["proof (state)\nthis:\n  |evalF\\<cdot>(Discr (cntf, [], ve, nb b cf))| \\<union>\n  |{((cf, [cf \\<mapsto> b]),\n     cntf)}| \\<lessapprox> (\\<Union>cnt\\<in>cntf_a.\n                               \\<aF>\\<cdot>\n                               (Discr\n                                 (cnt, [], ve_a, \\<anb> b_a cf))) \\<union>\n                           {((cf, [cf \\<mapsto> b_a]), cont) |cont.\n                            cont \\<in> cntf_a}\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x21aa x21aaa.\n       \\<lbrakk>fstate =\n                (DP (prim.If x21 x22), [DI 0, x21aa, x21aaa], ve, b);\n        fstate_a = (PP (prim.If x21 x22), ds_a, ve_a, b_a);\n        |ve| \\<lessapprox> ve_a; [{}, |x21aa|, |x21aaa|] \\<lessapprox> ds_a;\n        Suc (Suc (Suc 0)) = length ds_a; proc = PP (prim.If x21 x22);\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa]; isProc x21aa;\n        isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> |insert ((x22, [x22 \\<mapsto> b]), x21aaa)\n                           (evalF\\<cdot>\n                            (Discr\n                              (x21aaa, [], ve,\n                               nb b\n                                x22)))| \\<lessapprox> \\<aF>\\<cdot>\n                (Discr (PP (prim.If x21 x22), ds_a, ve_a, b_a))", "also"], ["proof (state)\nthis:\n  |evalF\\<cdot>(Discr (cntf, [], ve, nb b cf))| \\<union>\n  |{((cf, [cf \\<mapsto> b]),\n     cntf)}| \\<lessapprox> (\\<Union>cnt\\<in>cntf_a.\n                               \\<aF>\\<cdot>\n                               (Discr\n                                 (cnt, [], ve_a, \\<anb> b_a cf))) \\<union>\n                           {((cf, [cf \\<mapsto> b_a]), cont) |cont.\n                            cont \\<in> cntf_a}\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x21aa x21aaa.\n       \\<lbrakk>fstate =\n                (DP (prim.If x21 x22), [DI 0, x21aa, x21aaa], ve, b);\n        fstate_a = (PP (prim.If x21 x22), ds_a, ve_a, b_a);\n        |ve| \\<lessapprox> ve_a; [{}, |x21aa|, |x21aaa|] \\<lessapprox> ds_a;\n        Suc (Suc (Suc 0)) = length ds_a; proc = PP (prim.If x21 x22);\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa]; isProc x21aa;\n        isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> |insert ((x22, [x22 \\<mapsto> b]), x21aaa)\n                           (evalF\\<cdot>\n                            (Discr\n                              (x21aaa, [], ve,\n                               nb b\n                                x22)))| \\<lessapprox> \\<aF>\\<cdot>\n                (Discr (PP (prim.If x21 x22), ds_a, ve_a, b_a))", "have \"\\<dots> \\<lessapprox>\n        ((\\<Union>cnt\\<in>cntt_a. \\<aF>\\<cdot>(Discr (cnt, [], ve_a, \\<anb> b_a ct)))\n          \\<union> {((ct, [ct \\<mapsto> b_a]), cont) |cont. cont \\<in> cntt_a})\n      \\<union> ((\\<Union>cnt\\<in>cntf_a. \\<aF>\\<cdot>(Discr (cnt, [], ve_a, \\<anb> b_a cf)))\n          \\<union> {((cf, [cf \\<mapsto> b_a]), cont) |cont. cont \\<in> cntf_a})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>cnt\\<in>cntf_a.\n        \\<aF>\\<cdot>(Discr (cnt, [], ve_a, \\<anb> b_a cf))) \\<union>\n    {((cf, [cf \\<mapsto> b_a]), cont) |cont.\n     cont\n     \\<in> cntf_a} \\<lessapprox> (\\<Union>cnt\\<in>cntt_a.\n                                     \\<aF>\\<cdot>\n                                     (Discr\n (cnt, [], ve_a, \\<anb> b_a ct))) \\<union>\n                                 {((ct, [ct \\<mapsto> b_a]), cont) |cont.\n                                  cont \\<in> cntt_a} \\<union>\n                                 ((\\<Union>cnt\\<in>cntf_a.\n\\<aF>\\<cdot>(Discr (cnt, [], ve_a, \\<anb> b_a cf))) \\<union>\n                                  {((cf, [cf \\<mapsto> b_a]), cont) |cont.\n                                   cont \\<in> cntf_a})", "by (rule Un_upper1_approx|rule Un_upper2_approx)"], ["proof (state)\nthis:\n  (\\<Union>cnt\\<in>cntf_a.\n      \\<aF>\\<cdot>(Discr (cnt, [], ve_a, \\<anb> b_a cf))) \\<union>\n  {((cf, [cf \\<mapsto> b_a]), cont) |cont.\n   cont\n   \\<in> cntf_a} \\<lessapprox> (\\<Union>cnt\\<in>cntt_a.\n                                   \\<aF>\\<cdot>\n                                   (Discr\n                                     (cnt, [], ve_a,\n\\<anb> b_a ct))) \\<union>\n                               {((ct, [ct \\<mapsto> b_a]), cont) |cont.\n                                cont \\<in> cntt_a} \\<union>\n                               ((\\<Union>cnt\\<in>cntf_a.\n                                    \\<aF>\\<cdot>\n                                    (Discr\n(cnt, [], ve_a, \\<anb> b_a cf))) \\<union>\n                                {((cf, [cf \\<mapsto> b_a]), cont) |cont.\n                                 cont \\<in> cntf_a})\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x21aa x21aaa.\n       \\<lbrakk>fstate =\n                (DP (prim.If x21 x22), [DI 0, x21aa, x21aaa], ve, b);\n        fstate_a = (PP (prim.If x21 x22), ds_a, ve_a, b_a);\n        |ve| \\<lessapprox> ve_a; [{}, |x21aa|, |x21aaa|] \\<lessapprox> ds_a;\n        Suc (Suc (Suc 0)) = length ds_a; proc = PP (prim.If x21 x22);\n        d = DP (prim.If x21 x22); ds = [DI 0, x21aa, x21aaa]; isProc x21aa;\n        isProc x21aaa\\<rbrakk>\n       \\<Longrightarrow> |insert ((x22, [x22 \\<mapsto> b]), x21aaa)\n                           (evalF\\<cdot>\n                            (Discr\n                              (x21aaa, [], ve,\n                               nb b\n                                x22)))| \\<lessapprox> \\<aF>\\<cdot>\n                (Discr (PP (prim.If x21 x22), ds_a, ve_a, b_a))", "finally"], ["proof (chain)\npicking this:\n  |evalF\\<cdot>(Discr (cntf, [], ve, nb b cf)) \\<union>\n   {((cf, [cf \\<mapsto> b]),\n     cntf)}| \\<lessapprox> (\\<Union>cnt\\<in>cntt_a.\n                               \\<aF>\\<cdot>\n                               (Discr\n                                 (cnt, [], ve_a, \\<anb> b_a ct))) \\<union>\n                           {((ct, [ct \\<mapsto> b_a]), cont) |cont.\n                            cont \\<in> cntt_a} \\<union>\n                           ((\\<Union>cnt\\<in>cntf_a.\n                                \\<aF>\\<cdot>\n                                (Discr\n                                  (cnt, [], ve_a, \\<anb> b_a cf))) \\<union>\n                            {((cf, [cf \\<mapsto> b_a]), cont) |cont.\n                             cont \\<in> cntf_a})", "show \"|insert ((?c, [?c \\<mapsto> b]), ?cnt)\n                (evalF\\<cdot>(Discr (?cnt, [], ve, nb b ?c)))| \\<lessapprox>\n          \\<aF>\\<cdot>(Discr (PP (prim.If ct cf), ds_a, ve_a, b_a))\""], ["proof (prove)\nusing this:\n  |evalF\\<cdot>(Discr (cntf, [], ve, nb b cf)) \\<union>\n   {((cf, [cf \\<mapsto> b]),\n     cntf)}| \\<lessapprox> (\\<Union>cnt\\<in>cntt_a.\n                               \\<aF>\\<cdot>\n                               (Discr\n                                 (cnt, [], ve_a, \\<anb> b_a ct))) \\<union>\n                           {((ct, [ct \\<mapsto> b_a]), cont) |cont.\n                            cont \\<in> cntt_a} \\<union>\n                           ((\\<Union>cnt\\<in>cntf_a.\n                                \\<aF>\\<cdot>\n                                (Discr\n                                  (cnt, [], ve_a, \\<anb> b_a cf))) \\<union>\n                            {((cf, [cf \\<mapsto> b_a]), cont) |cont.\n                             cont \\<in> cntf_a})\n\ngoal (1 subgoal):\n 1. |insert ((cf, [cf \\<mapsto> b]), cntf)\n      (evalF\\<cdot>\n       (Discr\n         (cntf, [], ve,\n          nb b\n           cf)))| \\<lessapprox> \\<aF>\\<cdot>\n                                (Discr\n                                  (PP (prim.If ct cf), ds_a, ve_a, b_a))", "using ds_a"], ["proof (prove)\nusing this:\n  |evalF\\<cdot>(Discr (cntf, [], ve, nb b cf)) \\<union>\n   {((cf, [cf \\<mapsto> b]),\n     cntf)}| \\<lessapprox> (\\<Union>cnt\\<in>cntt_a.\n                               \\<aF>\\<cdot>\n                               (Discr\n                                 (cnt, [], ve_a, \\<anb> b_a ct))) \\<union>\n                           {((ct, [ct \\<mapsto> b_a]), cont) |cont.\n                            cont \\<in> cntt_a} \\<union>\n                           ((\\<Union>cnt\\<in>cntf_a.\n                                \\<aF>\\<cdot>\n                                (Discr\n                                  (cnt, [], ve_a, \\<anb> b_a cf))) \\<union>\n                            {((cf, [cf \\<mapsto> b_a]), cont) |cont.\n                             cont \\<in> cntf_a})\n  ds_a = [v_a, cntt_a, cntf_a]\n\ngoal (1 subgoal):\n 1. |insert ((cf, [cf \\<mapsto> b]), cntf)\n      (evalF\\<cdot>\n       (Discr\n         (cntf, [], ve,\n          nb b\n           cf)))| \\<lessapprox> \\<aF>\\<cdot>\n                                (Discr\n                                  (PP (prim.If ct cf), ds_a, ve_a, b_a))", "by (subst a_evalF.simps)(auto simp del:a_evalF.simps)"], ["proof (state)\nthis:\n  |insert ((cf, [cf \\<mapsto> b]), cntf)\n    (evalF\\<cdot>\n     (Discr\n       (cntf, [], ve,\n        nb b\n         cf)))| \\<lessapprox> \\<aF>\\<cdot>\n                              (Discr (PP (prim.If ct cf), ds_a, ve_a, b_a))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  |(\\<Lambda> fstate.\n       case undiscr fstate of (DI int, ba) \\<Rightarrow> \\<bottom>\n       | (DC (Lambda lab vs c, \\<beta>), as, ve, b) \\<Rightarrow>\n           if length vs = length as\n           then let \\<beta>' = \\<beta>(lab \\<mapsto> b);\n                    ve' = ve(map (\\<lambda>v. (v, b)) vs [\\<mapsto>] as)\n                in evalC\\<cdot>(Discr (c, \\<beta>', ve', b))\n           else \\<bottom>\n       | (DP (Plus c), [], bb) \\<Rightarrow> \\<bottom>\n       | (DP (Plus c), [DI a1], bb) \\<Rightarrow> \\<bottom>\n       | (DP (Plus c), [DI a1, DI a2], bb) \\<Rightarrow> \\<bottom>\n       | (DP (Plus c), [DI a1, DI a2, cnt], ve, b) \\<Rightarrow>\n           if isProc cnt\n           then let b' = nb b c; \\<beta> = [c \\<mapsto> b]\n                in evalF\\<cdot>\n                   (Discr (cnt, [DI (a1 + a2)], ve, b')) \\<union>\n                   {((c, \\<beta>), cnt)}\n           else \\<bottom>\n       | (DP (Plus c), DI a1 # DI a2 # cnt # aa # lista, bb) \\<Rightarrow>\n           \\<bottom>\n       | (DP (Plus c), DI a1 # _ # lista, bb) \\<Rightarrow> \\<bottom>\n       | (DP (Plus c), _ # list, bb) \\<Rightarrow> \\<bottom>\n       | (DP (prim.If ct cf), [], bb) \\<Rightarrow> \\<bottom>\n       | (DP (prim.If ct cf), [DI v], bb) \\<Rightarrow> \\<bottom>\n       | (DP (prim.If ct cf), [DI v, contt], bb) \\<Rightarrow> \\<bottom>\n       | (DP (prim.If ct cf), [DI v, contt, contf], ve, b) \\<Rightarrow>\n           if isProc contt \\<and> isProc contf\n           then if v \\<noteq> 0\n                then let b' = nb b ct; \\<beta> = [ct \\<mapsto> b]\n                     in evalF\\<cdot>(Discr (contt, [], ve, b')) \\<union>\n                        {((ct, \\<beta>), contt)}\n                else let b' = nb b cf; \\<beta> = [cf \\<mapsto> b]\n                     in evalF\\<cdot>(Discr (contf, [], ve, b')) \\<union>\n                        {((cf, \\<beta>), contf)}\n           else \\<bottom>\n       | (DP (prim.If ct cf), DI v # contt # contf # ab # lista,\n          bb) \\<Rightarrow>\n           \\<bottom>\n       | (DP (prim.If ct cf), _ # list, bb) \\<Rightarrow> \\<bottom>\n       | (Stop, [], bb) \\<Rightarrow> \\<bottom>\n       | (Stop, [DI i], x, xa) \\<Rightarrow> {}\n       | (Stop, DI i # a # lista, bb) \\<Rightarrow> \\<bottom>\n       | (Stop, _ # list, bb) \\<Rightarrow> \\<bottom>)\\<cdot>\n   (Discr fstate)| \\<lessapprox> \\<aF>\\<cdot>(Discr fstate_a)\n\ngoal (1 subgoal):\n 1. \\<And>a b cstate cstate_a.\n       \\<lbrakk>\\<And>fstate fstate_a.\n                   |fstate| \\<lessapprox> fstate_a \\<Longrightarrow>\n                   |a\\<cdot>\n                    (Discr\n                      fstate)| \\<lessapprox> \\<aF>\\<cdot>(Discr fstate_a);\n        \\<And>cstate cstate_a.\n           |cstate| \\<lessapprox> cstate_a \\<Longrightarrow>\n           |b\\<cdot>\n            (Discr cstate)| \\<lessapprox> \\<aC>\\<cdot>(Discr cstate_a);\n        |cstate| \\<lessapprox> cstate_a\\<rbrakk>\n       \\<Longrightarrow> |(\\<Lambda> cstate.\n                              case undiscr cstate of\n                              (App lab f vs, \\<beta>, ve, b) \\<Rightarrow>\n                                let f' = \\<A> f \\<beta> ve;\n                                    as =\nmap (\\<lambda>v. \\<A> v \\<beta> ve) vs;\n                                    b' = nb b lab\n                                in if isProc f'\n                                   then a\\<cdot>\n  (Discr (f', as, ve, b')) \\<union>\n  {((lab, \\<beta>), f')}\n                                   else \\<bottom>\n                              | (call.Let lab ls c', \\<beta>, ve,\n                                 ba) \\<Rightarrow>\n                                  let b' = nb ba lab;\n\\<beta>' = \\<beta>(lab \\<mapsto> b');\nve' =\n  ve ++ map_of (map (\\<lambda>(v, l). ((v, b'), \\<A> (L l) \\<beta>' ve)) ls)\n                                  in b\\<cdot>\n                                     (Discr (c', \\<beta>', ve', b')))\\<cdot>\n                          (Discr\n                            cstate)| \\<lessapprox> \\<aC>\\<cdot>\n             (Discr cstate_a)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b cstate cstate_a.\n       \\<lbrakk>\\<And>fstate fstate_a.\n                   |fstate| \\<lessapprox> fstate_a \\<Longrightarrow>\n                   |a\\<cdot>\n                    (Discr\n                      fstate)| \\<lessapprox> \\<aF>\\<cdot>(Discr fstate_a);\n        \\<And>cstate cstate_a.\n           |cstate| \\<lessapprox> cstate_a \\<Longrightarrow>\n           |b\\<cdot>\n            (Discr cstate)| \\<lessapprox> \\<aC>\\<cdot>(Discr cstate_a);\n        |cstate| \\<lessapprox> cstate_a\\<rbrakk>\n       \\<Longrightarrow> |(\\<Lambda> cstate.\n                              case undiscr cstate of\n                              (App lab f vs, \\<beta>, ve, b) \\<Rightarrow>\n                                let f' = \\<A> f \\<beta> ve;\n                                    as =\nmap (\\<lambda>v. \\<A> v \\<beta> ve) vs;\n                                    b' = nb b lab\n                                in if isProc f'\n                                   then a\\<cdot>\n  (Discr (f', as, ve, b')) \\<union>\n  {((lab, \\<beta>), f')}\n                                   else \\<bottom>\n                              | (call.Let lab ls c', \\<beta>, ve,\n                                 ba) \\<Rightarrow>\n                                  let b' = nb ba lab;\n\\<beta>' = \\<beta>(lab \\<mapsto> b');\nve' =\n  ve ++ map_of (map (\\<lambda>(v, l). ((v, b'), \\<A> (L l) \\<beta>' ve)) ls)\n                                  in b\\<cdot>\n                                     (Discr (c', \\<beta>', ve', b')))\\<cdot>\n                          (Discr\n                            cstate)| \\<lessapprox> \\<aC>\\<cdot>\n             (Discr cstate_a)", "case 2"], ["proof (state)\nthis:\n  |cstate| \\<lessapprox> cstate_a\n\ngoal (1 subgoal):\n 1. \\<And>a b cstate cstate_a.\n       \\<lbrakk>\\<And>fstate fstate_a.\n                   |fstate| \\<lessapprox> fstate_a \\<Longrightarrow>\n                   |a\\<cdot>\n                    (Discr\n                      fstate)| \\<lessapprox> \\<aF>\\<cdot>(Discr fstate_a);\n        \\<And>cstate cstate_a.\n           |cstate| \\<lessapprox> cstate_a \\<Longrightarrow>\n           |b\\<cdot>\n            (Discr cstate)| \\<lessapprox> \\<aC>\\<cdot>(Discr cstate_a);\n        |cstate| \\<lessapprox> cstate_a\\<rbrakk>\n       \\<Longrightarrow> |(\\<Lambda> cstate.\n                              case undiscr cstate of\n                              (App lab f vs, \\<beta>, ve, b) \\<Rightarrow>\n                                let f' = \\<A> f \\<beta> ve;\n                                    as =\nmap (\\<lambda>v. \\<A> v \\<beta> ve) vs;\n                                    b' = nb b lab\n                                in if isProc f'\n                                   then a\\<cdot>\n  (Discr (f', as, ve, b')) \\<union>\n  {((lab, \\<beta>), f')}\n                                   else \\<bottom>\n                              | (call.Let lab ls c', \\<beta>, ve,\n                                 ba) \\<Rightarrow>\n                                  let b' = nb ba lab;\n\\<beta>' = \\<beta>(lab \\<mapsto> b');\nve' =\n  ve ++ map_of (map (\\<lambda>(v, l). ((v, b'), \\<A> (L l) \\<beta>' ve)) ls)\n                                  in b\\<cdot>\n                                     (Discr (c', \\<beta>', ve', b')))\\<cdot>\n                          (Discr\n                            cstate)| \\<lessapprox> \\<aC>\\<cdot>\n             (Discr cstate_a)", "obtain c \\<beta> ve b where cstate: \"cstate = (c,\\<beta>,ve,b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>c \\<beta> ve b.\n        cstate = (c, \\<beta>, ve, b) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases cstate, auto)"], ["proof (state)\nthis:\n  cstate = (c, \\<beta>, ve, b)\n\ngoal (1 subgoal):\n 1. \\<And>a b cstate cstate_a.\n       \\<lbrakk>\\<And>fstate fstate_a.\n                   |fstate| \\<lessapprox> fstate_a \\<Longrightarrow>\n                   |a\\<cdot>\n                    (Discr\n                      fstate)| \\<lessapprox> \\<aF>\\<cdot>(Discr fstate_a);\n        \\<And>cstate cstate_a.\n           |cstate| \\<lessapprox> cstate_a \\<Longrightarrow>\n           |b\\<cdot>\n            (Discr cstate)| \\<lessapprox> \\<aC>\\<cdot>(Discr cstate_a);\n        |cstate| \\<lessapprox> cstate_a\\<rbrakk>\n       \\<Longrightarrow> |(\\<Lambda> cstate.\n                              case undiscr cstate of\n                              (App lab f vs, \\<beta>, ve, b) \\<Rightarrow>\n                                let f' = \\<A> f \\<beta> ve;\n                                    as =\nmap (\\<lambda>v. \\<A> v \\<beta> ve) vs;\n                                    b' = nb b lab\n                                in if isProc f'\n                                   then a\\<cdot>\n  (Discr (f', as, ve, b')) \\<union>\n  {((lab, \\<beta>), f')}\n                                   else \\<bottom>\n                              | (call.Let lab ls c', \\<beta>, ve,\n                                 ba) \\<Rightarrow>\n                                  let b' = nb ba lab;\n\\<beta>' = \\<beta>(lab \\<mapsto> b');\nve' =\n  ve ++ map_of (map (\\<lambda>(v, l). ((v, b'), \\<A> (L l) \\<beta>' ve)) ls)\n                                  in b\\<cdot>\n                                     (Discr (c', \\<beta>', ve', b')))\\<cdot>\n                          (Discr\n                            cstate)| \\<lessapprox> \\<aC>\\<cdot>\n             (Discr cstate_a)", "moreover"], ["proof (state)\nthis:\n  cstate = (c, \\<beta>, ve, b)\n\ngoal (1 subgoal):\n 1. \\<And>a b cstate cstate_a.\n       \\<lbrakk>\\<And>fstate fstate_a.\n                   |fstate| \\<lessapprox> fstate_a \\<Longrightarrow>\n                   |a\\<cdot>\n                    (Discr\n                      fstate)| \\<lessapprox> \\<aF>\\<cdot>(Discr fstate_a);\n        \\<And>cstate cstate_a.\n           |cstate| \\<lessapprox> cstate_a \\<Longrightarrow>\n           |b\\<cdot>\n            (Discr cstate)| \\<lessapprox> \\<aC>\\<cdot>(Discr cstate_a);\n        |cstate| \\<lessapprox> cstate_a\\<rbrakk>\n       \\<Longrightarrow> |(\\<Lambda> cstate.\n                              case undiscr cstate of\n                              (App lab f vs, \\<beta>, ve, b) \\<Rightarrow>\n                                let f' = \\<A> f \\<beta> ve;\n                                    as =\nmap (\\<lambda>v. \\<A> v \\<beta> ve) vs;\n                                    b' = nb b lab\n                                in if isProc f'\n                                   then a\\<cdot>\n  (Discr (f', as, ve, b')) \\<union>\n  {((lab, \\<beta>), f')}\n                                   else \\<bottom>\n                              | (call.Let lab ls c', \\<beta>, ve,\n                                 ba) \\<Rightarrow>\n                                  let b' = nb ba lab;\n\\<beta>' = \\<beta>(lab \\<mapsto> b');\nve' =\n  ve ++ map_of (map (\\<lambda>(v, l). ((v, b'), \\<A> (L l) \\<beta>' ve)) ls)\n                                  in b\\<cdot>\n                                     (Discr (c', \\<beta>', ve', b')))\\<cdot>\n                          (Discr\n                            cstate)| \\<lessapprox> \\<aC>\\<cdot>\n             (Discr cstate_a)", "obtain c_a \\<beta>_a ds_a ve_a b_a where cstate_a: \"cstate_a = (c_a,\\<beta>_a,ve_a,b_a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>c_a \\<beta>_a ve_a b_a.\n        cstate_a = (c_a, \\<beta>_a, ve_a, b_a) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases cstate_a, auto)"], ["proof (state)\nthis:\n  cstate_a = (c_a, \\<beta>_a, ve_a, b_a)\n\ngoal (1 subgoal):\n 1. \\<And>a b cstate cstate_a.\n       \\<lbrakk>\\<And>fstate fstate_a.\n                   |fstate| \\<lessapprox> fstate_a \\<Longrightarrow>\n                   |a\\<cdot>\n                    (Discr\n                      fstate)| \\<lessapprox> \\<aF>\\<cdot>(Discr fstate_a);\n        \\<And>cstate cstate_a.\n           |cstate| \\<lessapprox> cstate_a \\<Longrightarrow>\n           |b\\<cdot>\n            (Discr cstate)| \\<lessapprox> \\<aC>\\<cdot>(Discr cstate_a);\n        |cstate| \\<lessapprox> cstate_a\\<rbrakk>\n       \\<Longrightarrow> |(\\<Lambda> cstate.\n                              case undiscr cstate of\n                              (App lab f vs, \\<beta>, ve, b) \\<Rightarrow>\n                                let f' = \\<A> f \\<beta> ve;\n                                    as =\nmap (\\<lambda>v. \\<A> v \\<beta> ve) vs;\n                                    b' = nb b lab\n                                in if isProc f'\n                                   then a\\<cdot>\n  (Discr (f', as, ve, b')) \\<union>\n  {((lab, \\<beta>), f')}\n                                   else \\<bottom>\n                              | (call.Let lab ls c', \\<beta>, ve,\n                                 ba) \\<Rightarrow>\n                                  let b' = nb ba lab;\n\\<beta>' = \\<beta>(lab \\<mapsto> b');\nve' =\n  ve ++ map_of (map (\\<lambda>(v, l). ((v, b'), \\<A> (L l) \\<beta>' ve)) ls)\n                                  in b\\<cdot>\n                                     (Discr (c', \\<beta>', ve', b')))\\<cdot>\n                          (Discr\n                            cstate)| \\<lessapprox> \\<aC>\\<cdot>\n             (Discr cstate_a)", "ultimately"], ["proof (chain)\npicking this:\n  cstate = (c, \\<beta>, ve, b)\n  cstate_a = (c_a, \\<beta>_a, ve_a, b_a)", "have abs_c: \"c = c_a\"\n   and abs_\\<beta>: \"|\\<beta>| = \\<beta>_a\"\n   and abs_ve: \"|ve| \\<lessapprox> ve_a\"\n   and abs_b: \"|b| = b_a\""], ["proof (prove)\nusing this:\n  cstate = (c, \\<beta>, ve, b)\n  cstate_a = (c_a, \\<beta>_a, ve_a, b_a)\n\ngoal (1 subgoal):\n 1. (c = c_a &&& |\\<beta>| = \\<beta>_a) &&&\n    |ve| \\<lessapprox> ve_a &&& |b| = b_a", "using 2"], ["proof (prove)\nusing this:\n  cstate = (c, \\<beta>, ve, b)\n  cstate_a = (c_a, \\<beta>_a, ve_a, b_a)\n  |cstate| \\<lessapprox> cstate_a\n\ngoal (1 subgoal):\n 1. (c = c_a &&& |\\<beta>| = \\<beta>_a) &&&\n    |ve| \\<lessapprox> ve_a &&& |b| = b_a", "by (auto elim:cstate_approx.cases)"], ["proof (state)\nthis:\n  c = c_a\n  |\\<beta>| = \\<beta>_a\n  |ve| \\<lessapprox> ve_a\n  |b| = b_a\n\ngoal (1 subgoal):\n 1. \\<And>a b cstate cstate_a.\n       \\<lbrakk>\\<And>fstate fstate_a.\n                   |fstate| \\<lessapprox> fstate_a \\<Longrightarrow>\n                   |a\\<cdot>\n                    (Discr\n                      fstate)| \\<lessapprox> \\<aF>\\<cdot>(Discr fstate_a);\n        \\<And>cstate cstate_a.\n           |cstate| \\<lessapprox> cstate_a \\<Longrightarrow>\n           |b\\<cdot>\n            (Discr cstate)| \\<lessapprox> \\<aC>\\<cdot>(Discr cstate_a);\n        |cstate| \\<lessapprox> cstate_a\\<rbrakk>\n       \\<Longrightarrow> |(\\<Lambda> cstate.\n                              case undiscr cstate of\n                              (App lab f vs, \\<beta>, ve, b) \\<Rightarrow>\n                                let f' = \\<A> f \\<beta> ve;\n                                    as =\nmap (\\<lambda>v. \\<A> v \\<beta> ve) vs;\n                                    b' = nb b lab\n                                in if isProc f'\n                                   then a\\<cdot>\n  (Discr (f', as, ve, b')) \\<union>\n  {((lab, \\<beta>), f')}\n                                   else \\<bottom>\n                              | (call.Let lab ls c', \\<beta>, ve,\n                                 ba) \\<Rightarrow>\n                                  let b' = nb ba lab;\n\\<beta>' = \\<beta>(lab \\<mapsto> b');\nve' =\n  ve ++ map_of (map (\\<lambda>(v, l). ((v, b'), \\<A> (L l) \\<beta>' ve)) ls)\n                                  in b\\<cdot>\n                                     (Discr (c', \\<beta>', ve', b')))\\<cdot>\n                          (Discr\n                            cstate)| \\<lessapprox> \\<aC>\\<cdot>\n             (Discr cstate_a)", "from cstate cstate_a abs_c abs_\\<beta> abs_b"], ["proof (chain)\npicking this:\n  cstate = (c, \\<beta>, ve, b)\n  cstate_a = (c_a, \\<beta>_a, ve_a, b_a)\n  c = c_a\n  |\\<beta>| = \\<beta>_a\n  |b| = b_a", "show ?case"], ["proof (prove)\nusing this:\n  cstate = (c, \\<beta>, ve, b)\n  cstate_a = (c_a, \\<beta>_a, ve_a, b_a)\n  c = c_a\n  |\\<beta>| = \\<beta>_a\n  |b| = b_a\n\ngoal (1 subgoal):\n 1. |(\\<Lambda> cstate.\n         case undiscr cstate of\n         (App lab f vs, \\<beta>, ve, b) \\<Rightarrow>\n           let f' = \\<A> f \\<beta> ve;\n               as = map (\\<lambda>v. \\<A> v \\<beta> ve) vs; b' = nb b lab\n           in if isProc f'\n              then evalF\\<cdot>(Discr (f', as, ve, b')) \\<union>\n                   {((lab, \\<beta>), f')}\n              else \\<bottom>\n         | (call.Let lab ls c', \\<beta>, ve, b) \\<Rightarrow>\n             let b' = nb b lab; \\<beta>' = \\<beta>(lab \\<mapsto> b');\n                 ve' =\n                   ve ++\n                   map_of\n                    (map (\\<lambda>(v, l).\n                             ((v, b'), \\<A> (L l) \\<beta>' ve))\n                      ls)\n             in evalC\\<cdot>(Discr (c', \\<beta>', ve', b')))\\<cdot>\n     (Discr cstate)| \\<lessapprox> \\<aC>\\<cdot>(Discr cstate_a)", "proof(cases c, auto simp add:HOL.Let_def simp del:a_evalF.simps a_evalC.simps set_map evalV.simps)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x11 x12 x13.\n       \\<lbrakk>cstate = (App x11 x12 x13, \\<beta>, ve, b);\n        cstate_a = (App x11 x12 x13, |\\<beta>|, ve_a, |b|);\n        c = App x11 x12 x13; c_a = App x11 x12 x13; \\<beta>_a = |\\<beta>|;\n        b_a = |b|; isProc (\\<A> x12 \\<beta> ve)\\<rbrakk>\n       \\<Longrightarrow> |insert ((x11, \\<beta>), \\<A> x12 \\<beta> ve)\n                           (evalF\\<cdot>\n                            (Discr\n                              (\\<A> x12 \\<beta> ve,\n                               map (\\<lambda>v. \\<A> v \\<beta> ve) x13, ve,\n                               nb b\n                                x11)))| \\<lessapprox> \\<aC>\\<cdot>\n                (Discr (App x11 x12 x13, |\\<beta>|, ve_a, |b|))\n 2. \\<And>x21 x22 x23.\n       \\<lbrakk>cstate = (call.Let x21 x22 x23, \\<beta>, ve, b);\n        cstate_a = (call.Let x21 x22 x23, |\\<beta>|, ve_a, |b|);\n        c = call.Let x21 x22 x23; c_a = call.Let x21 x22 x23;\n        \\<beta>_a = |\\<beta>|; b_a = |b|\\<rbrakk>\n       \\<Longrightarrow> |evalC\\<cdot>\n                          (Discr\n                            (x23, \\<beta>(x21 \\<mapsto> nb b x21),\n                             ve ++\n                             map_of\n                              (map (\\<lambda>(v, l).\n ((v, nb b x21), \\<A> (L l) (\\<beta>(x21 \\<mapsto> nb b x21)) ve))\n                                x22),\n                             nb b\n                              x21))| \\<lessapprox> \\<aC>\\<cdot>\n             (Discr (call.Let x21 x22 x23, |\\<beta>|, ve_a, |b|))", "txt \\<open>Case App\\<close>"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x11 x12 x13.\n       \\<lbrakk>cstate = (App x11 x12 x13, \\<beta>, ve, b);\n        cstate_a = (App x11 x12 x13, |\\<beta>|, ve_a, |b|);\n        c = App x11 x12 x13; c_a = App x11 x12 x13; \\<beta>_a = |\\<beta>|;\n        b_a = |b|; isProc (\\<A> x12 \\<beta> ve)\\<rbrakk>\n       \\<Longrightarrow> |insert ((x11, \\<beta>), \\<A> x12 \\<beta> ve)\n                           (evalF\\<cdot>\n                            (Discr\n                              (\\<A> x12 \\<beta> ve,\n                               map (\\<lambda>v. \\<A> v \\<beta> ve) x13, ve,\n                               nb b\n                                x11)))| \\<lessapprox> \\<aC>\\<cdot>\n                (Discr (App x11 x12 x13, |\\<beta>|, ve_a, |b|))\n 2. \\<And>x21 x22 x23.\n       \\<lbrakk>cstate = (call.Let x21 x22 x23, \\<beta>, ve, b);\n        cstate_a = (call.Let x21 x22 x23, |\\<beta>|, ve_a, |b|);\n        c = call.Let x21 x22 x23; c_a = call.Let x21 x22 x23;\n        \\<beta>_a = |\\<beta>|; b_a = |b|\\<rbrakk>\n       \\<Longrightarrow> |evalC\\<cdot>\n                          (Discr\n                            (x23, \\<beta>(x21 \\<mapsto> nb b x21),\n                             ve ++\n                             map_of\n                              (map (\\<lambda>(v, l).\n ((v, nb b x21), \\<A> (L l) (\\<beta>(x21 \\<mapsto> nb b x21)) ve))\n                                x22),\n                             nb b\n                              x21))| \\<lessapprox> \\<aC>\\<cdot>\n             (Discr (call.Let x21 x22 x23, |\\<beta>|, ve_a, |b|))", "fix lab f vs"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x11 x12 x13.\n       \\<lbrakk>cstate = (App x11 x12 x13, \\<beta>, ve, b);\n        cstate_a = (App x11 x12 x13, |\\<beta>|, ve_a, |b|);\n        c = App x11 x12 x13; c_a = App x11 x12 x13; \\<beta>_a = |\\<beta>|;\n        b_a = |b|; isProc (\\<A> x12 \\<beta> ve)\\<rbrakk>\n       \\<Longrightarrow> |insert ((x11, \\<beta>), \\<A> x12 \\<beta> ve)\n                           (evalF\\<cdot>\n                            (Discr\n                              (\\<A> x12 \\<beta> ve,\n                               map (\\<lambda>v. \\<A> v \\<beta> ve) x13, ve,\n                               nb b\n                                x11)))| \\<lessapprox> \\<aC>\\<cdot>\n                (Discr (App x11 x12 x13, |\\<beta>|, ve_a, |b|))\n 2. \\<And>x21 x22 x23.\n       \\<lbrakk>cstate = (call.Let x21 x22 x23, \\<beta>, ve, b);\n        cstate_a = (call.Let x21 x22 x23, |\\<beta>|, ve_a, |b|);\n        c = call.Let x21 x22 x23; c_a = call.Let x21 x22 x23;\n        \\<beta>_a = |\\<beta>|; b_a = |b|\\<rbrakk>\n       \\<Longrightarrow> |evalC\\<cdot>\n                          (Discr\n                            (x23, \\<beta>(x21 \\<mapsto> nb b x21),\n                             ve ++\n                             map_of\n                              (map (\\<lambda>(v, l).\n ((v, nb b x21), \\<A> (L l) (\\<beta>(x21 \\<mapsto> nb b x21)) ve))\n                                x22),\n                             nb b\n                              x21))| \\<lessapprox> \\<aC>\\<cdot>\n             (Discr (call.Let x21 x22 x23, |\\<beta>|, ve_a, |b|))", "let ?d = \"\\<A> f \\<beta> ve\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x11 x12 x13.\n       \\<lbrakk>cstate = (App x11 x12 x13, \\<beta>, ve, b);\n        cstate_a = (App x11 x12 x13, |\\<beta>|, ve_a, |b|);\n        c = App x11 x12 x13; c_a = App x11 x12 x13; \\<beta>_a = |\\<beta>|;\n        b_a = |b|; isProc (\\<A> x12 \\<beta> ve)\\<rbrakk>\n       \\<Longrightarrow> |insert ((x11, \\<beta>), \\<A> x12 \\<beta> ve)\n                           (evalF\\<cdot>\n                            (Discr\n                              (\\<A> x12 \\<beta> ve,\n                               map (\\<lambda>v. \\<A> v \\<beta> ve) x13, ve,\n                               nb b\n                                x11)))| \\<lessapprox> \\<aC>\\<cdot>\n                (Discr (App x11 x12 x13, |\\<beta>|, ve_a, |b|))\n 2. \\<And>x21 x22 x23.\n       \\<lbrakk>cstate = (call.Let x21 x22 x23, \\<beta>, ve, b);\n        cstate_a = (call.Let x21 x22 x23, |\\<beta>|, ve_a, |b|);\n        c = call.Let x21 x22 x23; c_a = call.Let x21 x22 x23;\n        \\<beta>_a = |\\<beta>|; b_a = |b|\\<rbrakk>\n       \\<Longrightarrow> |evalC\\<cdot>\n                          (Discr\n                            (x23, \\<beta>(x21 \\<mapsto> nb b x21),\n                             ve ++\n                             map_of\n                              (map (\\<lambda>(v, l).\n ((v, nb b x21), \\<A> (L l) (\\<beta>(x21 \\<mapsto> nb b x21)) ve))\n                                x22),\n                             nb b\n                              x21))| \\<lessapprox> \\<aC>\\<cdot>\n             (Discr (call.Let x21 x22 x23, |\\<beta>|, ve_a, |b|))", "assume \"isProc ?d\""], ["proof (state)\nthis:\n  isProc (\\<A> f \\<beta> ve)\n\ngoal (2 subgoals):\n 1. \\<And>x11 x12 x13.\n       \\<lbrakk>cstate = (App x11 x12 x13, \\<beta>, ve, b);\n        cstate_a = (App x11 x12 x13, |\\<beta>|, ve_a, |b|);\n        c = App x11 x12 x13; c_a = App x11 x12 x13; \\<beta>_a = |\\<beta>|;\n        b_a = |b|; isProc (\\<A> x12 \\<beta> ve)\\<rbrakk>\n       \\<Longrightarrow> |insert ((x11, \\<beta>), \\<A> x12 \\<beta> ve)\n                           (evalF\\<cdot>\n                            (Discr\n                              (\\<A> x12 \\<beta> ve,\n                               map (\\<lambda>v. \\<A> v \\<beta> ve) x13, ve,\n                               nb b\n                                x11)))| \\<lessapprox> \\<aC>\\<cdot>\n                (Discr (App x11 x12 x13, |\\<beta>|, ve_a, |b|))\n 2. \\<And>x21 x22 x23.\n       \\<lbrakk>cstate = (call.Let x21 x22 x23, \\<beta>, ve, b);\n        cstate_a = (call.Let x21 x22 x23, |\\<beta>|, ve_a, |b|);\n        c = call.Let x21 x22 x23; c_a = call.Let x21 x22 x23;\n        \\<beta>_a = |\\<beta>|; b_a = |b|\\<rbrakk>\n       \\<Longrightarrow> |evalC\\<cdot>\n                          (Discr\n                            (x23, \\<beta>(x21 \\<mapsto> nb b x21),\n                             ve ++\n                             map_of\n                              (map (\\<lambda>(v, l).\n ((v, nb b x21), \\<A> (L l) (\\<beta>(x21 \\<mapsto> nb b x21)) ve))\n                                x22),\n                             nb b\n                              x21))| \\<lessapprox> \\<aC>\\<cdot>\n             (Discr (call.Let x21 x22 x23, |\\<beta>|, ve_a, |b|))", "have \"map (abs_d \\<circ> (\\<lambda>v. \\<A> v \\<beta> ve)) vs \\<lessapprox> map (\\<lambda>v. \\<aA> v \\<beta>_a ve_a) vs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (AbsCFCorrect.abs \\<circ> (\\<lambda>v. \\<A> v \\<beta> ve))\n     vs \\<lessapprox> map (\\<lambda>v. \\<aA> v \\<beta>_a ve_a) vs", "using abs_\\<beta> and lemma7[OF abs_ve, of _ \\<beta>]"], ["proof (prove)\nusing this:\n  |\\<beta>| = \\<beta>_a\n  |\\<A> ?f \\<beta> ve| \\<lessapprox> \\<aA> ?f |\\<beta>| ve_a\n\ngoal (1 subgoal):\n 1. map (AbsCFCorrect.abs \\<circ> (\\<lambda>v. \\<A> v \\<beta> ve))\n     vs \\<lessapprox> map (\\<lambda>v. \\<aA> v \\<beta>_a ve_a) vs", "by (auto intro!: list_all2I simp add:set_zip ds_approx_def)"], ["proof (state)\nthis:\n  map (AbsCFCorrect.abs \\<circ> (\\<lambda>v. \\<A> v \\<beta> ve))\n   vs \\<lessapprox> map (\\<lambda>v. \\<aA> v \\<beta>_a ve_a) vs\n\ngoal (2 subgoals):\n 1. \\<And>x11 x12 x13.\n       \\<lbrakk>cstate = (App x11 x12 x13, \\<beta>, ve, b);\n        cstate_a = (App x11 x12 x13, |\\<beta>|, ve_a, |b|);\n        c = App x11 x12 x13; c_a = App x11 x12 x13; \\<beta>_a = |\\<beta>|;\n        b_a = |b|; isProc (\\<A> x12 \\<beta> ve)\\<rbrakk>\n       \\<Longrightarrow> |insert ((x11, \\<beta>), \\<A> x12 \\<beta> ve)\n                           (evalF\\<cdot>\n                            (Discr\n                              (\\<A> x12 \\<beta> ve,\n                               map (\\<lambda>v. \\<A> v \\<beta> ve) x13, ve,\n                               nb b\n                                x11)))| \\<lessapprox> \\<aC>\\<cdot>\n                (Discr (App x11 x12 x13, |\\<beta>|, ve_a, |b|))\n 2. \\<And>x21 x22 x23.\n       \\<lbrakk>cstate = (call.Let x21 x22 x23, \\<beta>, ve, b);\n        cstate_a = (call.Let x21 x22 x23, |\\<beta>|, ve_a, |b|);\n        c = call.Let x21 x22 x23; c_a = call.Let x21 x22 x23;\n        \\<beta>_a = |\\<beta>|; b_a = |b|\\<rbrakk>\n       \\<Longrightarrow> |evalC\\<cdot>\n                          (Discr\n                            (x23, \\<beta>(x21 \\<mapsto> nb b x21),\n                             ve ++\n                             map_of\n                              (map (\\<lambda>(v, l).\n ((v, nb b x21), \\<A> (L l) (\\<beta>(x21 \\<mapsto> nb b x21)) ve))\n                                x22),\n                             nb b\n                              x21))| \\<lessapprox> \\<aC>\\<cdot>\n             (Discr (call.Let x21 x22 x23, |\\<beta>|, ve_a, |b|))", "hence \"|evalF\\<cdot>(Discr (?d, map (\\<lambda>v. \\<A> v \\<beta> ve) vs, ve, nb b lab))|\n     \\<lessapprox> \\<aF>\\<cdot>(Discr(the_elem |?d|, map (\\<lambda>v. \\<aA> v \\<beta>_a ve_a) vs, ve_a, \\<anb> |b| lab))\""], ["proof (prove)\nusing this:\n  map (AbsCFCorrect.abs \\<circ> (\\<lambda>v. \\<A> v \\<beta> ve))\n   vs \\<lessapprox> map (\\<lambda>v. \\<aA> v \\<beta>_a ve_a) vs\n\ngoal (1 subgoal):\n 1. |evalF\\<cdot>\n     (Discr\n       (\\<A> f \\<beta> ve, map (\\<lambda>v. \\<A> v \\<beta> ve) vs, ve,\n        nb b\n         lab))| \\<lessapprox> \\<aF>\\<cdot>\n                              (Discr\n                                (the_elem |\\<A> f \\<beta> ve|,\n                                 map (\\<lambda>v. \\<aA> v \\<beta>_a ve_a)\n                                  vs,\n                                 ve_a, \\<anb> |b| lab))", "using abs_ve and abs_cnt_nb and abs_b"], ["proof (prove)\nusing this:\n  map (AbsCFCorrect.abs \\<circ> (\\<lambda>v. \\<A> v \\<beta> ve))\n   vs \\<lessapprox> map (\\<lambda>v. \\<aA> v \\<beta>_a ve_a) vs\n  |ve| \\<lessapprox> ve_a\n  |nb ?b ?lab| = \\<anb> |?b| ?lab\n  |b| = b_a\n\ngoal (1 subgoal):\n 1. |evalF\\<cdot>\n     (Discr\n       (\\<A> f \\<beta> ve, map (\\<lambda>v. \\<A> v \\<beta> ve) vs, ve,\n        nb b\n         lab))| \\<lessapprox> \\<aF>\\<cdot>\n                              (Discr\n                                (the_elem |\\<A> f \\<beta> ve|,\n                                 map (\\<lambda>v. \\<aA> v \\<beta>_a ve_a)\n                                  vs,\n                                 ve_a, \\<anb> |b| lab))", "by -(rule Next.hyps(1),auto intro:fstate_approx.intros)"], ["proof (state)\nthis:\n  |evalF\\<cdot>\n   (Discr\n     (\\<A> f \\<beta> ve, map (\\<lambda>v. \\<A> v \\<beta> ve) vs, ve,\n      nb b\n       lab))| \\<lessapprox> \\<aF>\\<cdot>\n                            (Discr\n                              (the_elem |\\<A> f \\<beta> ve|,\n                               map (\\<lambda>v. \\<aA> v \\<beta>_a ve_a) vs,\n                               ve_a, \\<anb> |b| lab))\n\ngoal (2 subgoals):\n 1. \\<And>x11 x12 x13.\n       \\<lbrakk>cstate = (App x11 x12 x13, \\<beta>, ve, b);\n        cstate_a = (App x11 x12 x13, |\\<beta>|, ve_a, |b|);\n        c = App x11 x12 x13; c_a = App x11 x12 x13; \\<beta>_a = |\\<beta>|;\n        b_a = |b|; isProc (\\<A> x12 \\<beta> ve)\\<rbrakk>\n       \\<Longrightarrow> |insert ((x11, \\<beta>), \\<A> x12 \\<beta> ve)\n                           (evalF\\<cdot>\n                            (Discr\n                              (\\<A> x12 \\<beta> ve,\n                               map (\\<lambda>v. \\<A> v \\<beta> ve) x13, ve,\n                               nb b\n                                x11)))| \\<lessapprox> \\<aC>\\<cdot>\n                (Discr (App x11 x12 x13, |\\<beta>|, ve_a, |b|))\n 2. \\<And>x21 x22 x23.\n       \\<lbrakk>cstate = (call.Let x21 x22 x23, \\<beta>, ve, b);\n        cstate_a = (call.Let x21 x22 x23, |\\<beta>|, ve_a, |b|);\n        c = call.Let x21 x22 x23; c_a = call.Let x21 x22 x23;\n        \\<beta>_a = |\\<beta>|; b_a = |b|\\<rbrakk>\n       \\<Longrightarrow> |evalC\\<cdot>\n                          (Discr\n                            (x23, \\<beta>(x21 \\<mapsto> nb b x21),\n                             ve ++\n                             map_of\n                              (map (\\<lambda>(v, l).\n ((v, nb b x21), \\<A> (L l) (\\<beta>(x21 \\<mapsto> nb b x21)) ve))\n                                x22),\n                             nb b\n                              x21))| \\<lessapprox> \\<aC>\\<cdot>\n             (Discr (call.Let x21 x22 x23, |\\<beta>|, ve_a, |b|))", "also"], ["proof (state)\nthis:\n  |evalF\\<cdot>\n   (Discr\n     (\\<A> f \\<beta> ve, map (\\<lambda>v. \\<A> v \\<beta> ve) vs, ve,\n      nb b\n       lab))| \\<lessapprox> \\<aF>\\<cdot>\n                            (Discr\n                              (the_elem |\\<A> f \\<beta> ve|,\n                               map (\\<lambda>v. \\<aA> v \\<beta>_a ve_a) vs,\n                               ve_a, \\<anb> |b| lab))\n\ngoal (2 subgoals):\n 1. \\<And>x11 x12 x13.\n       \\<lbrakk>cstate = (App x11 x12 x13, \\<beta>, ve, b);\n        cstate_a = (App x11 x12 x13, |\\<beta>|, ve_a, |b|);\n        c = App x11 x12 x13; c_a = App x11 x12 x13; \\<beta>_a = |\\<beta>|;\n        b_a = |b|; isProc (\\<A> x12 \\<beta> ve)\\<rbrakk>\n       \\<Longrightarrow> |insert ((x11, \\<beta>), \\<A> x12 \\<beta> ve)\n                           (evalF\\<cdot>\n                            (Discr\n                              (\\<A> x12 \\<beta> ve,\n                               map (\\<lambda>v. \\<A> v \\<beta> ve) x13, ve,\n                               nb b\n                                x11)))| \\<lessapprox> \\<aC>\\<cdot>\n                (Discr (App x11 x12 x13, |\\<beta>|, ve_a, |b|))\n 2. \\<And>x21 x22 x23.\n       \\<lbrakk>cstate = (call.Let x21 x22 x23, \\<beta>, ve, b);\n        cstate_a = (call.Let x21 x22 x23, |\\<beta>|, ve_a, |b|);\n        c = call.Let x21 x22 x23; c_a = call.Let x21 x22 x23;\n        \\<beta>_a = |\\<beta>|; b_a = |b|\\<rbrakk>\n       \\<Longrightarrow> |evalC\\<cdot>\n                          (Discr\n                            (x23, \\<beta>(x21 \\<mapsto> nb b x21),\n                             ve ++\n                             map_of\n                              (map (\\<lambda>(v, l).\n ((v, nb b x21), \\<A> (L l) (\\<beta>(x21 \\<mapsto> nb b x21)) ve))\n                                x22),\n                             nb b\n                              x21))| \\<lessapprox> \\<aC>\\<cdot>\n             (Discr (call.Let x21 x22 x23, |\\<beta>|, ve_a, |b|))", "have \"\\<dots> \\<lessapprox> (\\<Union>f'\\<in>\\<aA> f \\<beta>_a ve_a.\n              \\<aF>\\<cdot>(Discr(f', map (\\<lambda>v. \\<aA> v \\<beta>_a ve_a) vs, ve_a, \\<anb> |b| lab)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<aF>\\<cdot>\n    (Discr\n      (the_elem |\\<A> f \\<beta> ve|,\n       map (\\<lambda>v. \\<aA> v \\<beta>_a ve_a) vs, ve_a,\n       \\<anb> |b|\n        lab)) \\<lessapprox> \\<Union>f'\\<in>\\<aA> f \\<beta>_a ve_a.\n                               \\<aF>\\<cdot>\n                               (Discr\n                                 (f',\n                                  map (\\<lambda>v. \\<aA> v \\<beta>_a ve_a)\n                                   vs,\n                                  ve_a, \\<anb> |b| lab))", "using lemma7[OF abs_ve] the_elem_is_Proc[OF \\<open>isProc ?d\\<close>] abs_\\<beta>"], ["proof (prove)\nusing this:\n  |\\<A> ?f ?\\<beta> ve| \\<lessapprox> \\<aA> ?f |?\\<beta>| ve_a\n  the_elem |\\<A> f \\<beta> ve| \\<in> |\\<A> f \\<beta> ve|\n  |\\<beta>| = \\<beta>_a\n\ngoal (1 subgoal):\n 1. \\<aF>\\<cdot>\n    (Discr\n      (the_elem |\\<A> f \\<beta> ve|,\n       map (\\<lambda>v. \\<aA> v \\<beta>_a ve_a) vs, ve_a,\n       \\<anb> |b|\n        lab)) \\<lessapprox> \\<Union>f'\\<in>\\<aA> f \\<beta>_a ve_a.\n                               \\<aF>\\<cdot>\n                               (Discr\n                                 (f',\n                                  map (\\<lambda>v. \\<aA> v \\<beta>_a ve_a)\n                                   vs,\n                                  ve_a, \\<anb> |b| lab))", "by (auto simp del: a_evalF.simps simp add:d_approx_def ccache_approx_def)"], ["proof (state)\nthis:\n  \\<aF>\\<cdot>\n  (Discr\n    (the_elem |\\<A> f \\<beta> ve|,\n     map (\\<lambda>v. \\<aA> v \\<beta>_a ve_a) vs, ve_a,\n     \\<anb> |b|\n      lab)) \\<lessapprox> \\<Union>f'\\<in>\\<aA> f \\<beta>_a ve_a.\n                             \\<aF>\\<cdot>\n                             (Discr\n                               (f',\n                                map (\\<lambda>v. \\<aA> v \\<beta>_a ve_a) vs,\n                                ve_a, \\<anb> |b| lab))\n\ngoal (2 subgoals):\n 1. \\<And>x11 x12 x13.\n       \\<lbrakk>cstate = (App x11 x12 x13, \\<beta>, ve, b);\n        cstate_a = (App x11 x12 x13, |\\<beta>|, ve_a, |b|);\n        c = App x11 x12 x13; c_a = App x11 x12 x13; \\<beta>_a = |\\<beta>|;\n        b_a = |b|; isProc (\\<A> x12 \\<beta> ve)\\<rbrakk>\n       \\<Longrightarrow> |insert ((x11, \\<beta>), \\<A> x12 \\<beta> ve)\n                           (evalF\\<cdot>\n                            (Discr\n                              (\\<A> x12 \\<beta> ve,\n                               map (\\<lambda>v. \\<A> v \\<beta> ve) x13, ve,\n                               nb b\n                                x11)))| \\<lessapprox> \\<aC>\\<cdot>\n                (Discr (App x11 x12 x13, |\\<beta>|, ve_a, |b|))\n 2. \\<And>x21 x22 x23.\n       \\<lbrakk>cstate = (call.Let x21 x22 x23, \\<beta>, ve, b);\n        cstate_a = (call.Let x21 x22 x23, |\\<beta>|, ve_a, |b|);\n        c = call.Let x21 x22 x23; c_a = call.Let x21 x22 x23;\n        \\<beta>_a = |\\<beta>|; b_a = |b|\\<rbrakk>\n       \\<Longrightarrow> |evalC\\<cdot>\n                          (Discr\n                            (x23, \\<beta>(x21 \\<mapsto> nb b x21),\n                             ve ++\n                             map_of\n                              (map (\\<lambda>(v, l).\n ((v, nb b x21), \\<A> (L l) (\\<beta>(x21 \\<mapsto> nb b x21)) ve))\n                                x22),\n                             nb b\n                              x21))| \\<lessapprox> \\<aC>\\<cdot>\n             (Discr (call.Let x21 x22 x23, |\\<beta>|, ve_a, |b|))", "finally"], ["proof (chain)\npicking this:\n  |evalF\\<cdot>\n   (Discr\n     (\\<A> f \\<beta> ve, map (\\<lambda>v. \\<A> v \\<beta> ve) vs, ve,\n      nb b\n       lab))| \\<lessapprox> \\<Union>f'\\<in>\\<aA> f \\<beta>_a ve_a.\n                               \\<aF>\\<cdot>\n                               (Discr\n                                 (f',\n                                  map (\\<lambda>v. \\<aA> v \\<beta>_a ve_a)\n                                   vs,\n                                  ve_a, \\<anb> |b| lab))", "have old_elems: \"\n     |evalF\\<cdot>(Discr (\\<A> f \\<beta> ve, map (\\<lambda>v. \\<A> v \\<beta> ve) vs, ve, nb b lab))|\n     \\<lessapprox> (\\<Union>f'\\<in> \\<aA> f \\<beta>_a ve_a.\n              \\<aF>\\<cdot>(Discr(f', map (\\<lambda>v. \\<aA> v \\<beta>_a ve_a) vs, ve_a, \\<anb> |b| lab)))\""], ["proof (prove)\nusing this:\n  |evalF\\<cdot>\n   (Discr\n     (\\<A> f \\<beta> ve, map (\\<lambda>v. \\<A> v \\<beta> ve) vs, ve,\n      nb b\n       lab))| \\<lessapprox> \\<Union>f'\\<in>\\<aA> f \\<beta>_a ve_a.\n                               \\<aF>\\<cdot>\n                               (Discr\n                                 (f',\n                                  map (\\<lambda>v. \\<aA> v \\<beta>_a ve_a)\n                                   vs,\n                                  ve_a, \\<anb> |b| lab))\n\ngoal (1 subgoal):\n 1. |evalF\\<cdot>\n     (Discr\n       (\\<A> f \\<beta> ve, map (\\<lambda>v. \\<A> v \\<beta> ve) vs, ve,\n        nb b\n         lab))| \\<lessapprox> \\<Union>f'\\<in>\\<aA> f \\<beta>_a ve_a.\n                                 \\<aF>\\<cdot>\n                                 (Discr\n                                   (f',\n                                    map (\\<lambda>v. \\<aA> v \\<beta>_a ve_a)\n                                     vs,\n                                    ve_a, \\<anb> |b| lab))", "by auto"], ["proof (state)\nthis:\n  |evalF\\<cdot>\n   (Discr\n     (\\<A> f \\<beta> ve, map (\\<lambda>v. \\<A> v \\<beta> ve) vs, ve,\n      nb b\n       lab))| \\<lessapprox> \\<Union>f'\\<in>\\<aA> f \\<beta>_a ve_a.\n                               \\<aF>\\<cdot>\n                               (Discr\n                                 (f',\n                                  map (\\<lambda>v. \\<aA> v \\<beta>_a ve_a)\n                                   vs,\n                                  ve_a, \\<anb> |b| lab))\n\ngoal (2 subgoals):\n 1. \\<And>x11 x12 x13.\n       \\<lbrakk>cstate = (App x11 x12 x13, \\<beta>, ve, b);\n        cstate_a = (App x11 x12 x13, |\\<beta>|, ve_a, |b|);\n        c = App x11 x12 x13; c_a = App x11 x12 x13; \\<beta>_a = |\\<beta>|;\n        b_a = |b|; isProc (\\<A> x12 \\<beta> ve)\\<rbrakk>\n       \\<Longrightarrow> |insert ((x11, \\<beta>), \\<A> x12 \\<beta> ve)\n                           (evalF\\<cdot>\n                            (Discr\n                              (\\<A> x12 \\<beta> ve,\n                               map (\\<lambda>v. \\<A> v \\<beta> ve) x13, ve,\n                               nb b\n                                x11)))| \\<lessapprox> \\<aC>\\<cdot>\n                (Discr (App x11 x12 x13, |\\<beta>|, ve_a, |b|))\n 2. \\<And>x21 x22 x23.\n       \\<lbrakk>cstate = (call.Let x21 x22 x23, \\<beta>, ve, b);\n        cstate_a = (call.Let x21 x22 x23, |\\<beta>|, ve_a, |b|);\n        c = call.Let x21 x22 x23; c_a = call.Let x21 x22 x23;\n        \\<beta>_a = |\\<beta>|; b_a = |b|\\<rbrakk>\n       \\<Longrightarrow> |evalC\\<cdot>\n                          (Discr\n                            (x23, \\<beta>(x21 \\<mapsto> nb b x21),\n                             ve ++\n                             map_of\n                              (map (\\<lambda>(v, l).\n ((v, nb b x21), \\<A> (L l) (\\<beta>(x21 \\<mapsto> nb b x21)) ve))\n                                x22),\n                             nb b\n                              x21))| \\<lessapprox> \\<aC>\\<cdot>\n             (Discr (call.Let x21 x22 x23, |\\<beta>|, ve_a, |b|))", "have new_elem: \"|{((lab, \\<beta>), \\<A> f \\<beta> ve)}|\n                  \\<lessapprox> {((lab, \\<beta>_a), f') |f'. f' \\<in> \\<aA> f \\<beta>_a ve_a}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. |{((lab, \\<beta>),\n       \\<A> f \\<beta>\n        ve)}| \\<lessapprox> {((lab, \\<beta>_a), f') |f'.\n                             f' \\<in> \\<aA> f \\<beta>_a ve_a}", "using abs_\\<beta> and lemma7[OF abs_ve]"], ["proof (prove)\nusing this:\n  |\\<beta>| = \\<beta>_a\n  |\\<A> ?f ?\\<beta> ve| \\<lessapprox> \\<aA> ?f |?\\<beta>| ve_a\n\ngoal (1 subgoal):\n 1. |{((lab, \\<beta>),\n       \\<A> f \\<beta>\n        ve)}| \\<lessapprox> {((lab, \\<beta>_a), f') |f'.\n                             f' \\<in> \\<aA> f \\<beta>_a ve_a}", "by(auto simp add:ccache_approx_def d_approx_def)"], ["proof (state)\nthis:\n  |{((lab, \\<beta>),\n     \\<A> f \\<beta>\n      ve)}| \\<lessapprox> {((lab, \\<beta>_a), f') |f'.\n                           f' \\<in> \\<aA> f \\<beta>_a ve_a}\n\ngoal (2 subgoals):\n 1. \\<And>x11 x12 x13.\n       \\<lbrakk>cstate = (App x11 x12 x13, \\<beta>, ve, b);\n        cstate_a = (App x11 x12 x13, |\\<beta>|, ve_a, |b|);\n        c = App x11 x12 x13; c_a = App x11 x12 x13; \\<beta>_a = |\\<beta>|;\n        b_a = |b|; isProc (\\<A> x12 \\<beta> ve)\\<rbrakk>\n       \\<Longrightarrow> |insert ((x11, \\<beta>), \\<A> x12 \\<beta> ve)\n                           (evalF\\<cdot>\n                            (Discr\n                              (\\<A> x12 \\<beta> ve,\n                               map (\\<lambda>v. \\<A> v \\<beta> ve) x13, ve,\n                               nb b\n                                x11)))| \\<lessapprox> \\<aC>\\<cdot>\n                (Discr (App x11 x12 x13, |\\<beta>|, ve_a, |b|))\n 2. \\<And>x21 x22 x23.\n       \\<lbrakk>cstate = (call.Let x21 x22 x23, \\<beta>, ve, b);\n        cstate_a = (call.Let x21 x22 x23, |\\<beta>|, ve_a, |b|);\n        c = call.Let x21 x22 x23; c_a = call.Let x21 x22 x23;\n        \\<beta>_a = |\\<beta>|; b_a = |b|\\<rbrakk>\n       \\<Longrightarrow> |evalC\\<cdot>\n                          (Discr\n                            (x23, \\<beta>(x21 \\<mapsto> nb b x21),\n                             ve ++\n                             map_of\n                              (map (\\<lambda>(v, l).\n ((v, nb b x21), \\<A> (L l) (\\<beta>(x21 \\<mapsto> nb b x21)) ve))\n                                x22),\n                             nb b\n                              x21))| \\<lessapprox> \\<aC>\\<cdot>\n             (Discr (call.Let x21 x22 x23, |\\<beta>|, ve_a, |b|))", "have \"|evalF\\<cdot>(Discr (\\<A> f \\<beta> ve, map (\\<lambda>v. \\<A> v \\<beta> ve) vs, ve, nb b lab))\n        \\<union> {((lab, \\<beta>), \\<A> f \\<beta> ve)}|\n        \\<lessapprox> |evalF\\<cdot>(Discr (\\<A> f \\<beta> ve, map (\\<lambda>v. \\<A> v \\<beta> ve) vs, ve, nb b lab))|\n        \\<union> |{((lab, \\<beta>), \\<A> f \\<beta> ve)}|\""], ["proof (prove)\ngoal (1 subgoal):\n 1. |evalF\\<cdot>\n     (Discr\n       (\\<A> f \\<beta> ve, map (\\<lambda>v. \\<A> v \\<beta> ve) vs, ve,\n        nb b lab)) \\<union>\n     {((lab, \\<beta>),\n       \\<A> f \\<beta>\n        ve)}| \\<lessapprox> |evalF\\<cdot>\n                             (Discr\n                               (\\<A> f \\<beta> ve,\n                                map (\\<lambda>v. \\<A> v \\<beta> ve) vs, ve,\n                                nb b lab))| \\<union>\n                            |{((lab, \\<beta>), \\<A> f \\<beta> ve)}|", "by (rule abs_ccache_union)"], ["proof (state)\nthis:\n  |evalF\\<cdot>\n   (Discr\n     (\\<A> f \\<beta> ve, map (\\<lambda>v. \\<A> v \\<beta> ve) vs, ve,\n      nb b lab)) \\<union>\n   {((lab, \\<beta>),\n     \\<A> f \\<beta>\n      ve)}| \\<lessapprox> |evalF\\<cdot>\n                           (Discr\n                             (\\<A> f \\<beta> ve,\n                              map (\\<lambda>v. \\<A> v \\<beta> ve) vs, ve,\n                              nb b lab))| \\<union>\n                          |{((lab, \\<beta>), \\<A> f \\<beta> ve)}|\n\ngoal (2 subgoals):\n 1. \\<And>x11 x12 x13.\n       \\<lbrakk>cstate = (App x11 x12 x13, \\<beta>, ve, b);\n        cstate_a = (App x11 x12 x13, |\\<beta>|, ve_a, |b|);\n        c = App x11 x12 x13; c_a = App x11 x12 x13; \\<beta>_a = |\\<beta>|;\n        b_a = |b|; isProc (\\<A> x12 \\<beta> ve)\\<rbrakk>\n       \\<Longrightarrow> |insert ((x11, \\<beta>), \\<A> x12 \\<beta> ve)\n                           (evalF\\<cdot>\n                            (Discr\n                              (\\<A> x12 \\<beta> ve,\n                               map (\\<lambda>v. \\<A> v \\<beta> ve) x13, ve,\n                               nb b\n                                x11)))| \\<lessapprox> \\<aC>\\<cdot>\n                (Discr (App x11 x12 x13, |\\<beta>|, ve_a, |b|))\n 2. \\<And>x21 x22 x23.\n       \\<lbrakk>cstate = (call.Let x21 x22 x23, \\<beta>, ve, b);\n        cstate_a = (call.Let x21 x22 x23, |\\<beta>|, ve_a, |b|);\n        c = call.Let x21 x22 x23; c_a = call.Let x21 x22 x23;\n        \\<beta>_a = |\\<beta>|; b_a = |b|\\<rbrakk>\n       \\<Longrightarrow> |evalC\\<cdot>\n                          (Discr\n                            (x23, \\<beta>(x21 \\<mapsto> nb b x21),\n                             ve ++\n                             map_of\n                              (map (\\<lambda>(v, l).\n ((v, nb b x21), \\<A> (L l) (\\<beta>(x21 \\<mapsto> nb b x21)) ve))\n                                x22),\n                             nb b\n                              x21))| \\<lessapprox> \\<aC>\\<cdot>\n             (Discr (call.Let x21 x22 x23, |\\<beta>|, ve_a, |b|))", "also"], ["proof (state)\nthis:\n  |evalF\\<cdot>\n   (Discr\n     (\\<A> f \\<beta> ve, map (\\<lambda>v. \\<A> v \\<beta> ve) vs, ve,\n      nb b lab)) \\<union>\n   {((lab, \\<beta>),\n     \\<A> f \\<beta>\n      ve)}| \\<lessapprox> |evalF\\<cdot>\n                           (Discr\n                             (\\<A> f \\<beta> ve,\n                              map (\\<lambda>v. \\<A> v \\<beta> ve) vs, ve,\n                              nb b lab))| \\<union>\n                          |{((lab, \\<beta>), \\<A> f \\<beta> ve)}|\n\ngoal (2 subgoals):\n 1. \\<And>x11 x12 x13.\n       \\<lbrakk>cstate = (App x11 x12 x13, \\<beta>, ve, b);\n        cstate_a = (App x11 x12 x13, |\\<beta>|, ve_a, |b|);\n        c = App x11 x12 x13; c_a = App x11 x12 x13; \\<beta>_a = |\\<beta>|;\n        b_a = |b|; isProc (\\<A> x12 \\<beta> ve)\\<rbrakk>\n       \\<Longrightarrow> |insert ((x11, \\<beta>), \\<A> x12 \\<beta> ve)\n                           (evalF\\<cdot>\n                            (Discr\n                              (\\<A> x12 \\<beta> ve,\n                               map (\\<lambda>v. \\<A> v \\<beta> ve) x13, ve,\n                               nb b\n                                x11)))| \\<lessapprox> \\<aC>\\<cdot>\n                (Discr (App x11 x12 x13, |\\<beta>|, ve_a, |b|))\n 2. \\<And>x21 x22 x23.\n       \\<lbrakk>cstate = (call.Let x21 x22 x23, \\<beta>, ve, b);\n        cstate_a = (call.Let x21 x22 x23, |\\<beta>|, ve_a, |b|);\n        c = call.Let x21 x22 x23; c_a = call.Let x21 x22 x23;\n        \\<beta>_a = |\\<beta>|; b_a = |b|\\<rbrakk>\n       \\<Longrightarrow> |evalC\\<cdot>\n                          (Discr\n                            (x23, \\<beta>(x21 \\<mapsto> nb b x21),\n                             ve ++\n                             map_of\n                              (map (\\<lambda>(v, l).\n ((v, nb b x21), \\<A> (L l) (\\<beta>(x21 \\<mapsto> nb b x21)) ve))\n                                x22),\n                             nb b\n                              x21))| \\<lessapprox> \\<aC>\\<cdot>\n             (Discr (call.Let x21 x22 x23, |\\<beta>|, ve_a, |b|))", "have \"\\<dots>\n        \\<lessapprox> (\\<Union>f'\\<in>\\<aA> f \\<beta>_a ve_a.\n              \\<aF>\\<cdot>(Discr(f', map (\\<lambda>v. \\<aA> v \\<beta>_a ve_a) vs, ve_a, \\<anb> |b| lab)))\n        \\<union> {((lab, \\<beta>_a), f') |f'. f' \\<in> \\<aA> f \\<beta>_a ve_a}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. |evalF\\<cdot>\n     (Discr\n       (\\<A> f \\<beta> ve, map (\\<lambda>v. \\<A> v \\<beta> ve) vs, ve,\n        nb b lab))| \\<union>\n    |{((lab, \\<beta>),\n       \\<A> f \\<beta>\n        ve)}| \\<lessapprox> (\\<Union>f'\\<in>\\<aA> f \\<beta>_a ve_a.\n                                \\<aF>\\<cdot>\n                                (Discr\n                                  (f',\n                                   map (\\<lambda>v. \\<aA> v \\<beta>_a ve_a)\n                                    vs,\n                                   ve_a, \\<anb> |b| lab))) \\<union>\n                            {((lab, \\<beta>_a), f') |f'.\n                             f' \\<in> \\<aA> f \\<beta>_a ve_a}", "by (rule Un_mono_approx[OF old_elems new_elem])"], ["proof (state)\nthis:\n  |evalF\\<cdot>\n   (Discr\n     (\\<A> f \\<beta> ve, map (\\<lambda>v. \\<A> v \\<beta> ve) vs, ve,\n      nb b lab))| \\<union>\n  |{((lab, \\<beta>),\n     \\<A> f \\<beta>\n      ve)}| \\<lessapprox> (\\<Union>f'\\<in>\\<aA> f \\<beta>_a ve_a.\n                              \\<aF>\\<cdot>\n                              (Discr\n                                (f',\n                                 map (\\<lambda>v. \\<aA> v \\<beta>_a ve_a)\n                                  vs,\n                                 ve_a, \\<anb> |b| lab))) \\<union>\n                          {((lab, \\<beta>_a), f') |f'.\n                           f' \\<in> \\<aA> f \\<beta>_a ve_a}\n\ngoal (2 subgoals):\n 1. \\<And>x11 x12 x13.\n       \\<lbrakk>cstate = (App x11 x12 x13, \\<beta>, ve, b);\n        cstate_a = (App x11 x12 x13, |\\<beta>|, ve_a, |b|);\n        c = App x11 x12 x13; c_a = App x11 x12 x13; \\<beta>_a = |\\<beta>|;\n        b_a = |b|; isProc (\\<A> x12 \\<beta> ve)\\<rbrakk>\n       \\<Longrightarrow> |insert ((x11, \\<beta>), \\<A> x12 \\<beta> ve)\n                           (evalF\\<cdot>\n                            (Discr\n                              (\\<A> x12 \\<beta> ve,\n                               map (\\<lambda>v. \\<A> v \\<beta> ve) x13, ve,\n                               nb b\n                                x11)))| \\<lessapprox> \\<aC>\\<cdot>\n                (Discr (App x11 x12 x13, |\\<beta>|, ve_a, |b|))\n 2. \\<And>x21 x22 x23.\n       \\<lbrakk>cstate = (call.Let x21 x22 x23, \\<beta>, ve, b);\n        cstate_a = (call.Let x21 x22 x23, |\\<beta>|, ve_a, |b|);\n        c = call.Let x21 x22 x23; c_a = call.Let x21 x22 x23;\n        \\<beta>_a = |\\<beta>|; b_a = |b|\\<rbrakk>\n       \\<Longrightarrow> |evalC\\<cdot>\n                          (Discr\n                            (x23, \\<beta>(x21 \\<mapsto> nb b x21),\n                             ve ++\n                             map_of\n                              (map (\\<lambda>(v, l).\n ((v, nb b x21), \\<A> (L l) (\\<beta>(x21 \\<mapsto> nb b x21)) ve))\n                                x22),\n                             nb b\n                              x21))| \\<lessapprox> \\<aC>\\<cdot>\n             (Discr (call.Let x21 x22 x23, |\\<beta>|, ve_a, |b|))", "finally"], ["proof (chain)\npicking this:\n  |evalF\\<cdot>\n   (Discr\n     (\\<A> f \\<beta> ve, map (\\<lambda>v. \\<A> v \\<beta> ve) vs, ve,\n      nb b lab)) \\<union>\n   {((lab, \\<beta>),\n     \\<A> f \\<beta>\n      ve)}| \\<lessapprox> (\\<Union>f'\\<in>\\<aA> f \\<beta>_a ve_a.\n                              \\<aF>\\<cdot>\n                              (Discr\n                                (f',\n                                 map (\\<lambda>v. \\<aA> v \\<beta>_a ve_a)\n                                  vs,\n                                 ve_a, \\<anb> |b| lab))) \\<union>\n                          {((lab, \\<beta>_a), f') |f'.\n                           f' \\<in> \\<aA> f \\<beta>_a ve_a}", "show \"|insert ((lab, \\<beta>), \\<A> f \\<beta> ve)\n                (evalF\\<cdot>(Discr (\\<A> f \\<beta> ve, map (\\<lambda>v. \\<A> v \\<beta> ve) vs, ve, nb b lab)))|\n        \\<lessapprox> \\<aC>\\<cdot>(Discr (App lab f vs, |\\<beta>|, ve_a, |b| ))\""], ["proof (prove)\nusing this:\n  |evalF\\<cdot>\n   (Discr\n     (\\<A> f \\<beta> ve, map (\\<lambda>v. \\<A> v \\<beta> ve) vs, ve,\n      nb b lab)) \\<union>\n   {((lab, \\<beta>),\n     \\<A> f \\<beta>\n      ve)}| \\<lessapprox> (\\<Union>f'\\<in>\\<aA> f \\<beta>_a ve_a.\n                              \\<aF>\\<cdot>\n                              (Discr\n                                (f',\n                                 map (\\<lambda>v. \\<aA> v \\<beta>_a ve_a)\n                                  vs,\n                                 ve_a, \\<anb> |b| lab))) \\<union>\n                          {((lab, \\<beta>_a), f') |f'.\n                           f' \\<in> \\<aA> f \\<beta>_a ve_a}\n\ngoal (1 subgoal):\n 1. |insert ((lab, \\<beta>), \\<A> f \\<beta> ve)\n      (evalF\\<cdot>\n       (Discr\n         (\\<A> f \\<beta> ve, map (\\<lambda>v. \\<A> v \\<beta> ve) vs, ve,\n          nb b\n           lab)))| \\<lessapprox> \\<aC>\\<cdot>\n                                 (Discr\n                                   (App lab f vs, |\\<beta>|, ve_a, |b|))", "using abs_\\<beta>"], ["proof (prove)\nusing this:\n  |evalF\\<cdot>\n   (Discr\n     (\\<A> f \\<beta> ve, map (\\<lambda>v. \\<A> v \\<beta> ve) vs, ve,\n      nb b lab)) \\<union>\n   {((lab, \\<beta>),\n     \\<A> f \\<beta>\n      ve)}| \\<lessapprox> (\\<Union>f'\\<in>\\<aA> f \\<beta>_a ve_a.\n                              \\<aF>\\<cdot>\n                              (Discr\n                                (f',\n                                 map (\\<lambda>v. \\<aA> v \\<beta>_a ve_a)\n                                  vs,\n                                 ve_a, \\<anb> |b| lab))) \\<union>\n                          {((lab, \\<beta>_a), f') |f'.\n                           f' \\<in> \\<aA> f \\<beta>_a ve_a}\n  |\\<beta>| = \\<beta>_a\n\ngoal (1 subgoal):\n 1. |insert ((lab, \\<beta>), \\<A> f \\<beta> ve)\n      (evalF\\<cdot>\n       (Discr\n         (\\<A> f \\<beta> ve, map (\\<lambda>v. \\<A> v \\<beta> ve) vs, ve,\n          nb b\n           lab)))| \\<lessapprox> \\<aC>\\<cdot>\n                                 (Discr\n                                   (App lab f vs, |\\<beta>|, ve_a, |b|))", "by (subst a_evalC.simps)(auto simp add: HOL.Let_def simp del:a_evalF.simps)"], ["proof (state)\nthis:\n  |insert ((lab, \\<beta>), \\<A> f \\<beta> ve)\n    (evalF\\<cdot>\n     (Discr\n       (\\<A> f \\<beta> ve, map (\\<lambda>v. \\<A> v \\<beta> ve) vs, ve,\n        nb b\n         lab)))| \\<lessapprox> \\<aC>\\<cdot>\n                               (Discr (App lab f vs, |\\<beta>|, ve_a, |b|))\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       \\<lbrakk>cstate = (call.Let x21 x22 x23, \\<beta>, ve, b);\n        cstate_a = (call.Let x21 x22 x23, |\\<beta>|, ve_a, |b|);\n        c = call.Let x21 x22 x23; c_a = call.Let x21 x22 x23;\n        \\<beta>_a = |\\<beta>|; b_a = |b|\\<rbrakk>\n       \\<Longrightarrow> |evalC\\<cdot>\n                          (Discr\n                            (x23, \\<beta>(x21 \\<mapsto> nb b x21),\n                             ve ++\n                             map_of\n                              (map (\\<lambda>(v, l).\n ((v, nb b x21), \\<A> (L l) (\\<beta>(x21 \\<mapsto> nb b x21)) ve))\n                                x22),\n                             nb b\n                              x21))| \\<lessapprox> \\<aC>\\<cdot>\n             (Discr (call.Let x21 x22 x23, |\\<beta>|, ve_a, |b|))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       \\<lbrakk>cstate = (call.Let x21 x22 x23, \\<beta>, ve, b);\n        cstate_a = (call.Let x21 x22 x23, |\\<beta>|, ve_a, |b|);\n        c = call.Let x21 x22 x23; c_a = call.Let x21 x22 x23;\n        \\<beta>_a = |\\<beta>|; b_a = |b|\\<rbrakk>\n       \\<Longrightarrow> |evalC\\<cdot>\n                          (Discr\n                            (x23, \\<beta>(x21 \\<mapsto> nb b x21),\n                             ve ++\n                             map_of\n                              (map (\\<lambda>(v, l).\n ((v, nb b x21), \\<A> (L l) (\\<beta>(x21 \\<mapsto> nb b x21)) ve))\n                                x22),\n                             nb b\n                              x21))| \\<lessapprox> \\<aC>\\<cdot>\n             (Discr (call.Let x21 x22 x23, |\\<beta>|, ve_a, |b|))", "txt \\<open>Case Let\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       \\<lbrakk>cstate = (call.Let x21 x22 x23, \\<beta>, ve, b);\n        cstate_a = (call.Let x21 x22 x23, |\\<beta>|, ve_a, |b|);\n        c = call.Let x21 x22 x23; c_a = call.Let x21 x22 x23;\n        \\<beta>_a = |\\<beta>|; b_a = |b|\\<rbrakk>\n       \\<Longrightarrow> |evalC\\<cdot>\n                          (Discr\n                            (x23, \\<beta>(x21 \\<mapsto> nb b x21),\n                             ve ++\n                             map_of\n                              (map (\\<lambda>(v, l).\n ((v, nb b x21), \\<A> (L l) (\\<beta>(x21 \\<mapsto> nb b x21)) ve))\n                                x22),\n                             nb b\n                              x21))| \\<lessapprox> \\<aC>\\<cdot>\n             (Discr (call.Let x21 x22 x23, |\\<beta>|, ve_a, |b|))", "fix lab binds c'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       \\<lbrakk>cstate = (call.Let x21 x22 x23, \\<beta>, ve, b);\n        cstate_a = (call.Let x21 x22 x23, |\\<beta>|, ve_a, |b|);\n        c = call.Let x21 x22 x23; c_a = call.Let x21 x22 x23;\n        \\<beta>_a = |\\<beta>|; b_a = |b|\\<rbrakk>\n       \\<Longrightarrow> |evalC\\<cdot>\n                          (Discr\n                            (x23, \\<beta>(x21 \\<mapsto> nb b x21),\n                             ve ++\n                             map_of\n                              (map (\\<lambda>(v, l).\n ((v, nb b x21), \\<A> (L l) (\\<beta>(x21 \\<mapsto> nb b x21)) ve))\n                                x22),\n                             nb b\n                              x21))| \\<lessapprox> \\<aC>\\<cdot>\n             (Discr (call.Let x21 x22 x23, |\\<beta>|, ve_a, |b|))", "have \"|\\<beta>(lab \\<mapsto> nb b lab)| =\n        \\<beta>_a(lab \\<mapsto> \\<anb> |b| lab)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. |\\<beta>(lab \\<mapsto> nb b lab)| = \\<beta>_a(lab \\<mapsto>\n    \\<anb> |b| lab)", "using abs_\\<beta> and abs_b"], ["proof (prove)\nusing this:\n  |\\<beta>| = \\<beta>_a\n  |b| = b_a\n\ngoal (1 subgoal):\n 1. |\\<beta>(lab \\<mapsto> nb b lab)| = \\<beta>_a(lab \\<mapsto>\n    \\<anb> |b| lab)", "by simp"], ["proof (state)\nthis:\n  |\\<beta>(lab \\<mapsto> nb b lab)| = \\<beta>_a(lab \\<mapsto>\n  \\<anb> |b| lab)\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       \\<lbrakk>cstate = (call.Let x21 x22 x23, \\<beta>, ve, b);\n        cstate_a = (call.Let x21 x22 x23, |\\<beta>|, ve_a, |b|);\n        c = call.Let x21 x22 x23; c_a = call.Let x21 x22 x23;\n        \\<beta>_a = |\\<beta>|; b_a = |b|\\<rbrakk>\n       \\<Longrightarrow> |evalC\\<cdot>\n                          (Discr\n                            (x23, \\<beta>(x21 \\<mapsto> nb b x21),\n                             ve ++\n                             map_of\n                              (map (\\<lambda>(v, l).\n ((v, nb b x21), \\<A> (L l) (\\<beta>(x21 \\<mapsto> nb b x21)) ve))\n                                x22),\n                             nb b\n                              x21))| \\<lessapprox> \\<aC>\\<cdot>\n             (Discr (call.Let x21 x22 x23, |\\<beta>|, ve_a, |b|))", "moreover"], ["proof (state)\nthis:\n  |\\<beta>(lab \\<mapsto> nb b lab)| = \\<beta>_a(lab \\<mapsto>\n  \\<anb> |b| lab)\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       \\<lbrakk>cstate = (call.Let x21 x22 x23, \\<beta>, ve, b);\n        cstate_a = (call.Let x21 x22 x23, |\\<beta>|, ve_a, |b|);\n        c = call.Let x21 x22 x23; c_a = call.Let x21 x22 x23;\n        \\<beta>_a = |\\<beta>|; b_a = |b|\\<rbrakk>\n       \\<Longrightarrow> |evalC\\<cdot>\n                          (Discr\n                            (x23, \\<beta>(x21 \\<mapsto> nb b x21),\n                             ve ++\n                             map_of\n                              (map (\\<lambda>(v, l).\n ((v, nb b x21), \\<A> (L l) (\\<beta>(x21 \\<mapsto> nb b x21)) ve))\n                                x22),\n                             nb b\n                              x21))| \\<lessapprox> \\<aC>\\<cdot>\n             (Discr (call.Let x21 x22 x23, |\\<beta>|, ve_a, |b|))", "have \"|map_of (map (\\<lambda>(v, l). ((v, nb b lab),\n                                 DC (l, \\<beta>(lab \\<mapsto> nb b lab))))\n                     binds)|\n    \\<lessapprox> \\<Union>. (map (\\<lambda>(v, l).\n              {(v, \\<anb> |b| lab) :=  {PC (l, \\<beta>_a(lab \\<mapsto> \\<anb> |b| lab))}}.)\n              binds)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. |map_of\n      (map (\\<lambda>(v, l).\n               ((v, nb b lab), DC (l, \\<beta>(lab \\<mapsto> nb b lab))))\n        binds)| \\<lessapprox> \\<Union>.map\n  (\\<lambda>(v, l).\n      { (v, \\<anb> |b|\n             lab) := {PC (l, \\<beta>_a(lab \\<mapsto> \\<anb> |b| lab))}}.)\n  binds", "using abs_b and abs_\\<beta>"], ["proof (prove)\nusing this:\n  |b| = b_a\n  |\\<beta>| = \\<beta>_a\n\ngoal (1 subgoal):\n 1. |map_of\n      (map (\\<lambda>(v, l).\n               ((v, nb b lab), DC (l, \\<beta>(lab \\<mapsto> nb b lab))))\n        binds)| \\<lessapprox> \\<Union>.map\n  (\\<lambda>(v, l).\n      { (v, \\<anb> |b|\n             lab) := {PC (l, \\<beta>_a(lab \\<mapsto> \\<anb> |b| lab))}}.)\n  binds", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>|b| = b_a; |\\<beta>| = \\<beta>_a\\<rbrakk>\n    \\<Longrightarrow> |map_of\n                        (map (\\<lambda>(v, l).\n                                 ((v, nb b lab),\n                                  DC (l, \\<beta>(lab \\<mapsto> nb b lab))))\n                          binds)| \\<lessapprox> \\<Union>.map\n                    (\\<lambda>(v, l).\n                        { (v, \\<anb> |b|\n                               lab) := {PC\n   (l, \\<beta>_a(lab \\<mapsto> \\<anb> |b| lab))}}.)\n                    binds", "apply (rule venv_approx_trans[OF abs_venv_map_of])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>|b| = b_a; |\\<beta>| = \\<beta>_a\\<rbrakk>\n    \\<Longrightarrow> \\<Union>.map (\\<lambda>(v, k). |[v \\<mapsto> k]|)\n                                (map (\\<lambda>(v, l).\n   ((v, nb b lab), DC (l, \\<beta>(lab \\<mapsto> nb b lab))))\n                                  binds) \\<lessapprox> \\<Union>.map\n                           (\\<lambda>(v, l).\n                               { (v, \\<anb> |b|\nlab) := {PC (l, \\<beta>_a(lab \\<mapsto> \\<anb> |b| lab))}}.)\n                           binds", "apply (auto intro:smap_union_mono list_all2I\n              simp add:venv_approx_def o_def set_zip abs_venv_singleton split_def smap_less_refl)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  |map_of\n    (map (\\<lambda>(v, l).\n             ((v, nb b lab), DC (l, \\<beta>(lab \\<mapsto> nb b lab))))\n      binds)| \\<lessapprox> \\<Union>.map\n(\\<lambda>(v, l).\n    { (v, \\<anb> |b|\n           lab) := {PC (l, \\<beta>_a(lab \\<mapsto> \\<anb> |b| lab))}}.)\nbinds\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       \\<lbrakk>cstate = (call.Let x21 x22 x23, \\<beta>, ve, b);\n        cstate_a = (call.Let x21 x22 x23, |\\<beta>|, ve_a, |b|);\n        c = call.Let x21 x22 x23; c_a = call.Let x21 x22 x23;\n        \\<beta>_a = |\\<beta>|; b_a = |b|\\<rbrakk>\n       \\<Longrightarrow> |evalC\\<cdot>\n                          (Discr\n                            (x23, \\<beta>(x21 \\<mapsto> nb b x21),\n                             ve ++\n                             map_of\n                              (map (\\<lambda>(v, l).\n ((v, nb b x21), \\<A> (L l) (\\<beta>(x21 \\<mapsto> nb b x21)) ve))\n                                x22),\n                             nb b\n                              x21))| \\<lessapprox> \\<aC>\\<cdot>\n             (Discr (call.Let x21 x22 x23, |\\<beta>|, ve_a, |b|))", "hence \"|ve ++ map_of\n            (map (\\<lambda>(v, l).\n                   ((v, nb b lab),\n                    DC (l, \\<beta>(lab \\<mapsto> nb b lab))))\n                  binds)| \\<lessapprox>\n        ve_a \\<union>.\n        (\\<Union>.\n          (map (\\<lambda>(v, l).\n            {(v, \\<anb> |b| lab) :=  {PC (l, \\<beta>_a(lab \\<mapsto> \\<anb> |b| lab))}}.)\n            binds))\""], ["proof (prove)\nusing this:\n  |map_of\n    (map (\\<lambda>(v, l).\n             ((v, nb b lab), DC (l, \\<beta>(lab \\<mapsto> nb b lab))))\n      binds)| \\<lessapprox> \\<Union>.map\n(\\<lambda>(v, l).\n    { (v, \\<anb> |b|\n           lab) := {PC (l, \\<beta>_a(lab \\<mapsto> \\<anb> |b| lab))}}.)\nbinds\n\ngoal (1 subgoal):\n 1. |ve ++\n     map_of\n      (map (\\<lambda>(v, l).\n               ((v, nb b lab), DC (l, \\<beta>(lab \\<mapsto> nb b lab))))\n        binds)| \\<lessapprox> ve_a \\<union>. \\<Union>.map\n                 (\\<lambda>(v, l).\n                     { (v, \\<anb> |b|\n                            lab) := {PC\n(l, \\<beta>_a(lab \\<mapsto> \\<anb> |b| lab))}}.)\n                 binds", "by (rule venv_approx_trans[OF abs_venv_union\n      smap_union_mono[OF abs_ve[unfolded venv_approx_def], folded venv_approx_def]])"], ["proof (state)\nthis:\n  |ve ++\n   map_of\n    (map (\\<lambda>(v, l).\n             ((v, nb b lab), DC (l, \\<beta>(lab \\<mapsto> nb b lab))))\n      binds)| \\<lessapprox> ve_a \\<union>. \\<Union>.map\n               (\\<lambda>(v, l).\n                   { (v, \\<anb> |b|\n                          lab) := {PC (l, \\<beta>_a(lab \\<mapsto>\n \\<anb> |b| lab))}}.)\n               binds\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       \\<lbrakk>cstate = (call.Let x21 x22 x23, \\<beta>, ve, b);\n        cstate_a = (call.Let x21 x22 x23, |\\<beta>|, ve_a, |b|);\n        c = call.Let x21 x22 x23; c_a = call.Let x21 x22 x23;\n        \\<beta>_a = |\\<beta>|; b_a = |b|\\<rbrakk>\n       \\<Longrightarrow> |evalC\\<cdot>\n                          (Discr\n                            (x23, \\<beta>(x21 \\<mapsto> nb b x21),\n                             ve ++\n                             map_of\n                              (map (\\<lambda>(v, l).\n ((v, nb b x21), \\<A> (L l) (\\<beta>(x21 \\<mapsto> nb b x21)) ve))\n                                x22),\n                             nb b\n                              x21))| \\<lessapprox> \\<aC>\\<cdot>\n             (Discr (call.Let x21 x22 x23, |\\<beta>|, ve_a, |b|))", "ultimately"], ["proof (chain)\npicking this:\n  |\\<beta>(lab \\<mapsto> nb b lab)| = \\<beta>_a(lab \\<mapsto>\n  \\<anb> |b| lab)\n  |ve ++\n   map_of\n    (map (\\<lambda>(v, l).\n             ((v, nb b lab), DC (l, \\<beta>(lab \\<mapsto> nb b lab))))\n      binds)| \\<lessapprox> ve_a \\<union>. \\<Union>.map\n               (\\<lambda>(v, l).\n                   { (v, \\<anb> |b|\n                          lab) := {PC (l, \\<beta>_a(lab \\<mapsto>\n \\<anb> |b| lab))}}.)\n               binds", "have \"|evalC\\<cdot>(Discr(c', \\<beta>(lab \\<mapsto> nb b lab),\n            ve ++ map_of\n                  (map (\\<lambda>(v, l). ((v, nb b lab), DC (l, \\<beta>(lab \\<mapsto> nb b lab)))) binds),\n            nb b lab))|\n    \\<lessapprox> \\<aC>\\<cdot>(Discr (c', \\<beta>_a(lab \\<mapsto> \\<anb> |b| lab),\n            ve_a \\<union>.\n             (\\<Union>. (map (\\<lambda>(v, l).\n                   {(v, \\<anb> |b| lab) :=  {PC (l, \\<beta>_a(lab \\<mapsto> \\<anb> |b| lab))}}.)\n                   binds)),\n         \\<anb> |b| lab))\""], ["proof (prove)\nusing this:\n  |\\<beta>(lab \\<mapsto> nb b lab)| = \\<beta>_a(lab \\<mapsto>\n  \\<anb> |b| lab)\n  |ve ++\n   map_of\n    (map (\\<lambda>(v, l).\n             ((v, nb b lab), DC (l, \\<beta>(lab \\<mapsto> nb b lab))))\n      binds)| \\<lessapprox> ve_a \\<union>. \\<Union>.map\n               (\\<lambda>(v, l).\n                   { (v, \\<anb> |b|\n                          lab) := {PC (l, \\<beta>_a(lab \\<mapsto>\n \\<anb> |b| lab))}}.)\n               binds\n\ngoal (1 subgoal):\n 1. |evalC\\<cdot>\n     (Discr\n       (c', \\<beta>(lab \\<mapsto> nb b lab),\n        ve ++\n        map_of\n         (map (\\<lambda>(v, l).\n                  ((v, nb b lab), DC (l, \\<beta>(lab \\<mapsto> nb b lab))))\n           binds),\n        nb b\n         lab))| \\<lessapprox> \\<aC>\\<cdot>\n                              (Discr\n                                (c', \\<beta>_a(lab \\<mapsto>\n                                 \\<anb> |b| lab),\n                                 ve_a \\<union>. \\<Union>.map\n                    (\\<lambda>(v, l).\n                        { (v, \\<anb> |b|\n                               lab) := {PC\n   (l, \\<beta>_a(lab \\<mapsto> \\<anb> |b| lab))}}.)\n                    binds,\n                                 \\<anb> |b| lab))", "using abs_cnt_nb and abs_b"], ["proof (prove)\nusing this:\n  |\\<beta>(lab \\<mapsto> nb b lab)| = \\<beta>_a(lab \\<mapsto>\n  \\<anb> |b| lab)\n  |ve ++\n   map_of\n    (map (\\<lambda>(v, l).\n             ((v, nb b lab), DC (l, \\<beta>(lab \\<mapsto> nb b lab))))\n      binds)| \\<lessapprox> ve_a \\<union>. \\<Union>.map\n               (\\<lambda>(v, l).\n                   { (v, \\<anb> |b|\n                          lab) := {PC (l, \\<beta>_a(lab \\<mapsto>\n \\<anb> |b| lab))}}.)\n               binds\n  |nb ?b ?lab| = \\<anb> |?b| ?lab\n  |b| = b_a\n\ngoal (1 subgoal):\n 1. |evalC\\<cdot>\n     (Discr\n       (c', \\<beta>(lab \\<mapsto> nb b lab),\n        ve ++\n        map_of\n         (map (\\<lambda>(v, l).\n                  ((v, nb b lab), DC (l, \\<beta>(lab \\<mapsto> nb b lab))))\n           binds),\n        nb b\n         lab))| \\<lessapprox> \\<aC>\\<cdot>\n                              (Discr\n                                (c', \\<beta>_a(lab \\<mapsto>\n                                 \\<anb> |b| lab),\n                                 ve_a \\<union>. \\<Union>.map\n                    (\\<lambda>(v, l).\n                        { (v, \\<anb> |b|\n                               lab) := {PC\n   (l, \\<beta>_a(lab \\<mapsto> \\<anb> |b| lab))}}.)\n                    binds,\n                                 \\<anb> |b| lab))", "by -(rule Next.hyps(2),auto intro: cstate_approx.intros)"], ["proof (state)\nthis:\n  |evalC\\<cdot>\n   (Discr\n     (c', \\<beta>(lab \\<mapsto> nb b lab),\n      ve ++\n      map_of\n       (map (\\<lambda>(v, l).\n                ((v, nb b lab), DC (l, \\<beta>(lab \\<mapsto> nb b lab))))\n         binds),\n      nb b\n       lab))| \\<lessapprox> \\<aC>\\<cdot>\n                            (Discr\n                              (c', \\<beta>_a(lab \\<mapsto> \\<anb> |b| lab),\n                               ve_a \\<union>. \\<Union>.map\n                  (\\<lambda>(v, l).\n                      { (v, \\<anb> |b|\n                             lab) := {PC\n (l, \\<beta>_a(lab \\<mapsto> \\<anb> |b| lab))}}.)\n                  binds,\n                               \\<anb> |b| lab))\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       \\<lbrakk>cstate = (call.Let x21 x22 x23, \\<beta>, ve, b);\n        cstate_a = (call.Let x21 x22 x23, |\\<beta>|, ve_a, |b|);\n        c = call.Let x21 x22 x23; c_a = call.Let x21 x22 x23;\n        \\<beta>_a = |\\<beta>|; b_a = |b|\\<rbrakk>\n       \\<Longrightarrow> |evalC\\<cdot>\n                          (Discr\n                            (x23, \\<beta>(x21 \\<mapsto> nb b x21),\n                             ve ++\n                             map_of\n                              (map (\\<lambda>(v, l).\n ((v, nb b x21), \\<A> (L l) (\\<beta>(x21 \\<mapsto> nb b x21)) ve))\n                                x22),\n                             nb b\n                              x21))| \\<lessapprox> \\<aC>\\<cdot>\n             (Discr (call.Let x21 x22 x23, |\\<beta>|, ve_a, |b|))", "thus \"|evalC\\<cdot>(Discr (c', \\<beta>(lab \\<mapsto> nb b lab),\n                      ve ++ map_of (map (\\<lambda>(v, l).((v, nb b lab),\\<A> (L l) (\\<beta>(lab \\<mapsto> nb b lab)) ve)) binds),\n                      nb b lab))| \\<lessapprox>\n          \\<aC>\\<cdot>(Discr (call.Let lab binds c', |\\<beta>|, ve_a, |b| ))\""], ["proof (prove)\nusing this:\n  |evalC\\<cdot>\n   (Discr\n     (c', \\<beta>(lab \\<mapsto> nb b lab),\n      ve ++\n      map_of\n       (map (\\<lambda>(v, l).\n                ((v, nb b lab), DC (l, \\<beta>(lab \\<mapsto> nb b lab))))\n         binds),\n      nb b\n       lab))| \\<lessapprox> \\<aC>\\<cdot>\n                            (Discr\n                              (c', \\<beta>_a(lab \\<mapsto> \\<anb> |b| lab),\n                               ve_a \\<union>. \\<Union>.map\n                  (\\<lambda>(v, l).\n                      { (v, \\<anb> |b|\n                             lab) := {PC\n (l, \\<beta>_a(lab \\<mapsto> \\<anb> |b| lab))}}.)\n                  binds,\n                               \\<anb> |b| lab))\n\ngoal (1 subgoal):\n 1. |evalC\\<cdot>\n     (Discr\n       (c', \\<beta>(lab \\<mapsto> nb b lab),\n        ve ++\n        map_of\n         (map (\\<lambda>(v, l).\n                  ((v, nb b lab),\n                   \\<A> (L l) (\\<beta>(lab \\<mapsto> nb b lab)) ve))\n           binds),\n        nb b\n         lab))| \\<lessapprox> \\<aC>\\<cdot>\n                              (Discr\n                                (call.Let lab binds c', |\\<beta>|, ve_a,\n                                 |b|))", "using abs_\\<beta>"], ["proof (prove)\nusing this:\n  |evalC\\<cdot>\n   (Discr\n     (c', \\<beta>(lab \\<mapsto> nb b lab),\n      ve ++\n      map_of\n       (map (\\<lambda>(v, l).\n                ((v, nb b lab), DC (l, \\<beta>(lab \\<mapsto> nb b lab))))\n         binds),\n      nb b\n       lab))| \\<lessapprox> \\<aC>\\<cdot>\n                            (Discr\n                              (c', \\<beta>_a(lab \\<mapsto> \\<anb> |b| lab),\n                               ve_a \\<union>. \\<Union>.map\n                  (\\<lambda>(v, l).\n                      { (v, \\<anb> |b|\n                             lab) := {PC\n (l, \\<beta>_a(lab \\<mapsto> \\<anb> |b| lab))}}.)\n                  binds,\n                               \\<anb> |b| lab))\n  |\\<beta>| = \\<beta>_a\n\ngoal (1 subgoal):\n 1. |evalC\\<cdot>\n     (Discr\n       (c', \\<beta>(lab \\<mapsto> nb b lab),\n        ve ++\n        map_of\n         (map (\\<lambda>(v, l).\n                  ((v, nb b lab),\n                   \\<A> (L l) (\\<beta>(lab \\<mapsto> nb b lab)) ve))\n           binds),\n        nb b\n         lab))| \\<lessapprox> \\<aC>\\<cdot>\n                              (Discr\n                                (call.Let lab binds c', |\\<beta>|, ve_a,\n                                 |b|))", "by (subst a_evalC.simps)(auto simp add: HOL.Let_def simp del:a_evalC.simps)"], ["proof (state)\nthis:\n  |evalC\\<cdot>\n   (Discr\n     (c', \\<beta>(lab \\<mapsto> nb b lab),\n      ve ++\n      map_of\n       (map (\\<lambda>(v, l).\n                ((v, nb b lab),\n                 \\<A> (L l) (\\<beta>(lab \\<mapsto> nb b lab)) ve))\n         binds),\n      nb b\n       lab))| \\<lessapprox> \\<aC>\\<cdot>\n                            (Discr\n                              (call.Let lab binds c', |\\<beta>|, ve_a, |b|))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  |(\\<Lambda> cstate.\n       case undiscr cstate of\n       (App lab f vs, \\<beta>, ve, b) \\<Rightarrow>\n         let f' = \\<A> f \\<beta> ve;\n             as = map (\\<lambda>v. \\<A> v \\<beta> ve) vs; b' = nb b lab\n         in if isProc f'\n            then evalF\\<cdot>(Discr (f', as, ve, b')) \\<union>\n                 {((lab, \\<beta>), f')}\n            else \\<bottom>\n       | (call.Let lab ls c', \\<beta>, ve, b) \\<Rightarrow>\n           let b' = nb b lab; \\<beta>' = \\<beta>(lab \\<mapsto> b');\n               ve' =\n                 ve ++\n                 map_of\n                  (map (\\<lambda>(v, l). ((v, b'), \\<A> (L l) \\<beta>' ve))\n                    ls)\n           in evalC\\<cdot>(Discr (c', \\<beta>', ve', b')))\\<cdot>\n   (Discr cstate)| \\<lessapprox> \\<aC>\\<cdot>(Discr cstate_a)\n\ngoal:\nNo subgoals!", "}"], ["proof (state)\nthis:\n  |?cstatea2| \\<lessapprox> ?cstate_aa2 \\<Longrightarrow>\n  |(\\<Lambda> cstate.\n       case undiscr cstate of\n       (App lab f vs, \\<beta>, ve, b) \\<Rightarrow>\n         let f' = \\<A> f \\<beta> ve;\n             as = map (\\<lambda>v. \\<A> v \\<beta> ve) vs; b' = nb b lab\n         in if isProc f'\n            then evalF\\<cdot>(Discr (f', as, ve, b')) \\<union>\n                 {((lab, \\<beta>), f')}\n            else \\<bottom>\n       | (call.Let lab ls c', \\<beta>, ve, b) \\<Rightarrow>\n           let b' = nb b lab; \\<beta>' = \\<beta>(lab \\<mapsto> b');\n               ve' =\n                 ve ++\n                 map_of\n                  (map (\\<lambda>(v, l). ((v, b'), \\<A> (L l) \\<beta>' ve))\n                    ls)\n           in evalC\\<cdot>(Discr (c', \\<beta>', ve', b')))\\<cdot>\n   (Discr ?cstatea2)| \\<lessapprox> \\<aC>\\<cdot>(Discr ?cstate_aa2)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\nAnd finally, we lift this result to \\<open>\\<aPR>\\<close> and \\<open>\\<PR>\\<close>.\n\\<close>"], ["", "lemma lemma6: \"|\\<PR> l| \\<lessapprox> \\<aPR> l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. |\\<PR> l| \\<lessapprox> \\<aPR> l", "unfolding evalCPS_def evalCPS_a_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. |let ve = Map.empty; \\<beta> = Map.empty; f = \\<A> (L l) \\<beta> ve\n     in \\<F>\\<cdot>\n        (Discr\n          (f, [Stop], ve,\n           \\<binit>))| \\<lessapprox> let ve = {}.; \\<beta> = Map.empty;\n   f = \\<aA> (L l) \\<beta> ve\n                                     in \\<aF>\\<cdot>\n  (Discr (the_elem f, [{AStop}], ve, \\<abinit>))", "by (auto intro!:lemma89 fstate_approx.intros simp del:evalF.simps a_evalF.simps\n      simp add: ds_approx_def d_approx_def venv_approx_def)"], ["", "end"]]}