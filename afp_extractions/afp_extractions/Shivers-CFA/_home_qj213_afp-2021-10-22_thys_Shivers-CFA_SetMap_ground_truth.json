{"file_name": "/home/qj213/afp-2021-10-22/thys/Shivers-CFA/SetMap.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Shivers-CFA", "problem_names": ["lemma sranI: \"b \\<in> m a \\<Longrightarrow> b \\<in> sran m\"", "lemma sdom_not_mem[elim]: \"a \\<notin> sdom m \\<Longrightarrow> m a = {}\"", "lemma sdom_empty[simp]: \"sdom {}. = {}\"", "lemma sdom_singleton[simp]: \"sdom {k := vs}. \\<subseteq> {k}\"", "lemma sran_singleton[simp]: \"sran {k := vs}. = vs\"", "lemma sran_empty[simp]: \"sran {}. = {}\"", "lemma sdom_union[simp]: \"sdom (m \\<union>. n) = sdom m \\<union> sdom n\"", "lemma sran_union[simp]: \"sran (m \\<union>. n) = sran m \\<union> sran n\"", "lemma smap_empty[simp]: \"{}. \\<subseteq>. {}.\"", "lemma smap_less_refl: \"m \\<subseteq>. m\"", "lemma smap_less_trans[trans]: \"\\<lbrakk> m1 \\<subseteq>. m2; m2 \\<subseteq>. m3 \\<rbrakk> \\<Longrightarrow> m1 \\<subseteq>. m3\"", "lemma smap_union_mono: \"\\<lbrakk> ve1 \\<subseteq>. ve1'; ve2 \\<subseteq>. ve2' \\<rbrakk> \\<Longrightarrow> ve1 \\<union>. ve2 \\<subseteq>. ve1' \\<union>. ve2'\"", "lemma smap_Union_union: \"m1 \\<union>. \\<Union>.ms = \\<Union>.(m1#ms)\"", "lemma smap_Union_mono:\n  assumes \"list_all2 smap_less ms1 ms2\"\n  shows \"\\<Union>. ms1 \\<subseteq>. \\<Union>. ms2\"", "lemma smap_singleton_mono: \"v \\<subseteq> v' \\<Longrightarrow> {k := v}. \\<subseteq>. {k := v'}.\"", "lemma smap_union_comm: \"m1 \\<union>. m2 = m2 \\<union>. m1\"", "lemma smap_union_empty1[simp]: \"{}. \\<union>. m = m\"", "lemma smap_union_empty2[simp]: \"m \\<union>. {}. = m\"", "lemma smap_union_assoc [simp]: \"(m1 \\<union>. m2) \\<union>. m3 = m1 \\<union>. (m2 \\<union>. m3)\"", "lemma smap_Union_append[simp]: \"\\<Union>. (m1@m2) = (\\<Union>. m1) \\<union>. (\\<Union>. m2)\"", "lemma smap_Union_rev[simp]: \"\\<Union>. (rev l) = \\<Union>. l\"", "lemma smap_Union_map_rev[simp]: \"\\<Union>. (map f (rev l)) = \\<Union>. (map f l)\""], "translations": [["", "lemma sranI: \"b \\<in> m a \\<Longrightarrow> b \\<in> sran m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b \\<in> m a \\<Longrightarrow> b \\<in> sran m", "by(auto simp: sran_def)"], ["", "lemma sdom_not_mem[elim]: \"a \\<notin> sdom m \\<Longrightarrow> m a = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<notin> sdom m \\<Longrightarrow> m a = {}", "by (auto simp: sdom_def)"], ["", "definition smap_empty (\"{}.\")\n where \"{}. k = {}\""], ["", "definition smap_union :: \"('a::type \\<Rightarrow> 'b::type set)  \\<Rightarrow> ('a \\<Rightarrow> 'b set) \\<Rightarrow> ('a \\<Rightarrow> 'b set)\" (\"_ \\<union>. _\")\n where \"smap1 \\<union>. smap2 k =  smap1 k \\<union> smap2 k\""], ["", "primrec smap_Union :: \"('a::type \\<Rightarrow> 'b::type set) list \\<Rightarrow> 'a \\<Rightarrow> 'b set\" (\"\\<Union>._\")\n  where [simp]:\"\\<Union>. [] = {}.\"\n      | \"\\<Union>. (m#ms) = m  \\<union>. \\<Union>. ms\""], ["", "definition smap_singleton :: \"'a::type \\<Rightarrow> 'b::type set \\<Rightarrow> 'a \\<Rightarrow> 'b set\" (\"{ _ := _}.\")\n  where \"{k := vs}. = {}. (k := vs)\""], ["", "definition smap_less :: \"('a \\<Rightarrow> 'b set) \\<Rightarrow> ('a \\<Rightarrow> 'b set) \\<Rightarrow> bool\" (\"_/ \\<subseteq>. _\" [50, 51] 50)\n  where \"smap_less m1 m2 = (\\<forall>k. m1 k \\<subseteq> m2 k)\""], ["", "lemma sdom_empty[simp]: \"sdom {}. = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sdom {}. = {}", "unfolding sdom_def smap_empty_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {a. {} \\<noteq> {}} = {}", "by auto"], ["", "lemma sdom_singleton[simp]: \"sdom {k := vs}. \\<subseteq> {k}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sdom { k := vs}. \\<subseteq> {k}", "by (auto simp add: sdom_def smap_singleton_def smap_empty_def)"], ["", "lemma sran_singleton[simp]: \"sran {k := vs}. = vs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sran { k := vs}. = vs", "by (auto simp add: sran_def smap_singleton_def smap_empty_def)"], ["", "lemma sran_empty[simp]: \"sran {}. = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sran {}. = {}", "unfolding sran_def smap_empty_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {b. \\<exists>a. b \\<in> {}} = {}", "by auto"], ["", "lemma sdom_union[simp]: \"sdom (m \\<union>. n) = sdom m \\<union> sdom n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sdom m \\<union>. n = sdom m \\<union> sdom n", "by(auto simp add:smap_union_def sdom_def)"], ["", "lemma sran_union[simp]: \"sran (m \\<union>. n) = sran m \\<union> sran n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sran m \\<union>. n = sran m \\<union> sran n", "by(auto simp add:smap_union_def sran_def)"], ["", "lemma smap_empty[simp]: \"{}. \\<subseteq>. {}.\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {}. \\<subseteq>. {}.", "unfolding smap_less_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>k. {}. k \\<subseteq> {}. k", "by auto"], ["", "lemma smap_less_refl: \"m \\<subseteq>. m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<subseteq>. m", "unfolding smap_less_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>k. m k \\<subseteq> m k", "by simp"], ["", "lemma smap_less_trans[trans]: \"\\<lbrakk> m1 \\<subseteq>. m2; m2 \\<subseteq>. m3 \\<rbrakk> \\<Longrightarrow> m1 \\<subseteq>. m3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>m1 \\<subseteq>. m2; m2 \\<subseteq>. m3\\<rbrakk>\n    \\<Longrightarrow> m1 \\<subseteq>. m3", "unfolding smap_less_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>k. m1 k \\<subseteq> m2 k;\n     \\<forall>k. m2 k \\<subseteq> m3 k\\<rbrakk>\n    \\<Longrightarrow> \\<forall>k. m1 k \\<subseteq> m3 k", "by auto"], ["", "lemma smap_union_mono: \"\\<lbrakk> ve1 \\<subseteq>. ve1'; ve2 \\<subseteq>. ve2' \\<rbrakk> \\<Longrightarrow> ve1 \\<union>. ve2 \\<subseteq>. ve1' \\<union>. ve2'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ve1 \\<subseteq>. ve1'; ve2 \\<subseteq>. ve2'\\<rbrakk>\n    \\<Longrightarrow> ve1 \\<union>. ve2 \\<subseteq>. ve1' \\<union>. ve2'", "by (auto simp add:smap_less_def smap_union_def)"], ["", "lemma smap_Union_union: \"m1 \\<union>. \\<Union>.ms = \\<Union>.(m1#ms)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m1 \\<union>. \\<Union>.ms = \\<Union>.m1 # ms", "by (rule ext, auto simp add: smap_union_def smap_Union_def)"], ["", "lemma smap_Union_mono:\n  assumes \"list_all2 smap_less ms1 ms2\"\n  shows \"\\<Union>. ms1 \\<subseteq>. \\<Union>. ms2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union>.ms1 \\<subseteq>. \\<Union>.ms2", "using assms"], ["proof (prove)\nusing this:\n  list_all2 smap_less ms1 ms2\n\ngoal (1 subgoal):\n 1. \\<Union>.ms1 \\<subseteq>. \\<Union>.ms2", "by(induct rule:list_induct2[OF list_all2_lengthD[OF assms]])\n    (auto intro:smap_union_mono)"], ["", "lemma smap_singleton_mono: \"v \\<subseteq> v' \\<Longrightarrow> {k := v}. \\<subseteq>. {k := v'}.\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<subseteq> v' \\<Longrightarrow> { k := v}. \\<subseteq>. { k := v'}.", "by (auto simp add: smap_singleton_def smap_less_def)"], ["", "lemma smap_union_comm: \"m1 \\<union>. m2 = m2 \\<union>. m1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m1 \\<union>. m2 = m2 \\<union>. m1", "by (rule ext,auto simp add:smap_union_def)"], ["", "lemma smap_union_empty1[simp]: \"{}. \\<union>. m = m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {}. \\<union>. m = m", "by(rule ext, auto simp add:smap_union_def smap_empty_def)"], ["", "lemma smap_union_empty2[simp]: \"m \\<union>. {}. = m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<union>. {}. = m", "by(rule ext, auto simp add:smap_union_def smap_empty_def)"], ["", "lemma smap_union_assoc [simp]: \"(m1 \\<union>. m2) \\<union>. m3 = m1 \\<union>. (m2 \\<union>. m3)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m1 \\<union>. m2 \\<union>. m3 = m1 \\<union>. m2 \\<union>. m3", "by (rule ext, auto simp add:smap_union_def)"], ["", "lemma smap_Union_append[simp]: \"\\<Union>. (m1@m2) = (\\<Union>. m1) \\<union>. (\\<Union>. m2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union>.m1 @ m2 = \\<Union>.m1 \\<union>. \\<Union>.m2", "by (induct m1) auto"], ["", "lemma smap_Union_rev[simp]: \"\\<Union>. (rev l) = \\<Union>. l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union>.rev l = \\<Union>.l", "by(induct l)(auto simp add:smap_union_comm)"], ["", "lemma smap_Union_map_rev[simp]: \"\\<Union>. (map f (rev l)) = \\<Union>. (map f l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union>.map f (rev l) = \\<Union>.map f l", "by(subst rev_map[THEN sym], subst smap_Union_rev, rule refl)"], ["", "end"]]}