{"file_name": "/home/qj213/afp-2021-10-22/thys/Shivers-CFA/ExCF.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Shivers-CFA", "problem_names": ["lemma nb_le_less[iff]: \"nb b c \\<le> b' \\<longleftrightarrow> b < b'\"", "lemma nb_less[iff]: \"b' < nb b c \\<longleftrightarrow> b' \\<le> b\"", "lemma cont2cont_case_lambda [simp, cont2cont]:\n  assumes \"\\<And>a b c. cont (\\<lambda>x. f x a b c)\"\n  shows \"cont (\\<lambda>x. case_lambda (f x) l)\"", "lemma cont2cont_case_d [simp, cont2cont]:\n  assumes \"\\<And>y. cont (\\<lambda>x. f1 x y)\"\n     and  \"\\<And>y. cont (\\<lambda>x. f2 x y)\"\n     and  \"\\<And>y. cont (\\<lambda>x. f3 x y)\"\n    and   \"cont (\\<lambda>x. f4 x)\"\n  shows \"cont (\\<lambda>x. case_d (f1 x) (f2 x) (f3 x) (f4 x) d)\"", "lemma cont2cont_case_call [simp, cont2cont]:\n  assumes \"\\<And>a b c. cont (\\<lambda>x. f1 x a b c)\"\n     and  \"\\<And>a b c. cont (\\<lambda>x. f2 x a b c)\"\n  shows \"cont (\\<lambda>x. case_call (f1 x) (f2 x) c)\"", "lemma cont2cont_case_prim [simp, cont2cont]:\n  assumes \"\\<And>y. cont (\\<lambda>x. f1 x y)\"\n     and  \"\\<And>y z. cont (\\<lambda>x. f2 x y z)\"\n  shows \"cont (\\<lambda>x. case_prim (f1 x) (f2 x) p)\"", "lemmas evalF_evalC_induct = evalF_evalC.induct[case_names Admissibility Bottom Next]", "lemmas cl_cases = prod.exhaust[OF lambda.exhaust, of _ \"\\<lambda> a _ . a\"]", "lemmas ds_cases_plus = list.exhaust[\n  OF _ d.exhaust, of _ _ \"\\<lambda>a _. a\",\n  OF _ list.exhaust, of _ _ \"\\<lambda>_ x _. x\",\n  OF _ _ d.exhaust, of _ _ \"\\<lambda>_ _ _ a _. a\",\n  OF _ _ list.exhaust,of _ _ \"\\<lambda>_ _ _ _ x _. x\",\n  OF _ _ _ list.exhaust,of _ _ \"\\<lambda>_ _ _ _ _ _ _ x. x\"\n  ]", "lemmas ds_cases_if = list.exhaust[OF _ d.exhaust, of _ _ \"\\<lambda>a _. a\",\n  OF _ list.exhaust[OF _ list.exhaust[OF _ list.exhaust, of _ _ \"\\<lambda>_ x. x\"], of _ _ \"\\<lambda>_ x. x\"], of _ _ \"\\<lambda>_ x _. x\"]", "lemmas ds_cases_stop = list.exhaust[OF _ d.exhaust, of _ _ \"\\<lambda>a _. a\",\n  OF _ list.exhaust, of _ _ \"\\<lambda>_ x _. x\"]", "lemmas fstate_case = prod_cases4[OF d.exhaust, of _ \"\\<lambda>x _ _ _ . x\",\n  OF _ cl_cases prim.exhaust, of _ _ \"\\<lambda> _ _ _ _ a . a\" \"\\<lambda> _ _ _ _ a. a\",\n  OF _ case_split ds_cases_plus ds_cases_if ds_cases_stop,\n  of _ _ \"\\<lambda>_ as _ _ _ _ _ _ vs _ . length vs = length as\" \"\\<lambda> _ ds _ _ _ _ . ds\" \"\\<lambda> _ ds _ _ _ _ _. ds\" \"\\<lambda> _ ds _ _. ds\",\n  case_names \"x\" \"Closure\" \"x\" \"x\"  \"x\" \"x\" \"Plus\" \"x\" \"x\" \"x\" \"x\" \"x\" \"x\" \"x\" \"x\"   \"x\" \"x\" \"If_True\" \"If_False\" \"x\" \"x\" \"x\" \"x\" \"x\" \"Stop\"  \"x\" \"x\" \"x\" \"x\" \"x\"]", "lemma correct_ex1: \"\\<PR> ex1 = {((2,[1 \\<mapsto> \\<binit>]), Stop)}\"", "lemma correct_ex2: \"\\<PR> ex2 = {((2, [1 \\<mapsto> \\<binit>]), DP (Plus 3)),\n                                   ((3, [3 \\<mapsto> nb \\<binit> 2]),  Stop)}\""], "translations": [["", "lemma nb_le_less[iff]: \"nb b c \\<le> b' \\<longleftrightarrow> b < b'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (nb b c \\<le> b') = (b < b')", "unfolding nb_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (Abs_contour (c # Rep_contour b) \\<le> b') = (b < b')", "by (auto simp add:le_contour_def less_contour_def Rep_contour_inverse Abs_contour_inverse contour_def)"], ["", "lemma nb_less[iff]: \"b' < nb b c \\<longleftrightarrow> b' \\<le> b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (b' < nb b c) = (b' \\<le> b)", "unfolding nb_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (b' < Abs_contour (c # Rep_contour b)) = (b' \\<le> b)", "by (auto simp add:le_contour_def less_contour_def Rep_contour_inverse Abs_contour_inverse contour_def)"], ["", "declare less_imp_le[where 'a = contour, intro]"], ["", "text \\<open>\nThe other types used in our semantics functions have not changed.\n\\<close>"], ["", "type_synonym benv = \"label \\<rightharpoonup> contour\""], ["", "type_synonym closure = \"lambda \\<times> benv\""], ["", "datatype d = DI int\n           | DC closure\n           | DP prim\n           | Stop"], ["", "type_synonym venv = \"var \\<times> contour \\<rightharpoonup> d\""], ["", "text \\<open>\nAs we do not use the type system to distinguish procedural from non-procedural values, we define a predicate for that.\n\\<close>"], ["", "primrec isProc \n  where \"isProc (DI _) = False\"\n      | \"isProc (DC _) = True\"\n      | \"isProc (DP _) = True\"\n      | \"isProc Stop   = True\""], ["", "text \\<open>\nTo please @{theory HOLCF}, we declare the discrete partial order for our types:\n\\<close>"], ["", "instantiation contour :: discrete_cpo\nbegin"], ["", "definition [simp]: \"(x::contour) \\<sqsubseteq> y \\<longleftrightarrow> x = y\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(contour, discrete_cpo_class)", "by standard simp"], ["", "end"], ["", "instantiation d :: discrete_cpo begin"], ["", "definition  [simp]: \"(x::d) \\<sqsubseteq> y \\<longleftrightarrow> x = y\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(d, discrete_cpo_class)", "by standard simp"], ["", "end"], ["", "instantiation call :: discrete_cpo begin"], ["", "definition  [simp]: \"(x::call) \\<sqsubseteq> y \\<longleftrightarrow> x = y\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(call, discrete_cpo_class)", "by standard simp"], ["", "end"], ["", "text \\<open>\nThe evaluation function for values has only changed slightly: To avoid worrying about incorrect programs, we return zero when a variable lookup fails. If the labels in the program given are correct, this will not happen. Shivers makes this explicit in Section 4.1.3 by restricting the function domains to the valid programs. This is omitted here.\n\\<close>"], ["", "fun evalV :: \"val \\<Rightarrow> benv \\<Rightarrow> venv \\<Rightarrow> d\" (\"\\<A>\")\n  where \"\\<A> (C _ i) \\<beta> ve = DI i\"\n  |     \"\\<A> (P prim) \\<beta> ve = DP prim\"\n  |     \"\\<A> (R _ var) \\<beta> ve =\n           (case \\<beta> (binder var) of\n              Some l \\<Rightarrow> (case ve (var,l) of Some d \\<Rightarrow> d | None \\<Rightarrow> DI 0)\n             | None \\<Rightarrow> DI 0)\"\n  |     \"\\<A> (L lam) \\<beta> ve = DC (lam, \\<beta>)\""], ["", "text \\<open>\nTo be able to do case analysis on the custom datatypes \\<open>lambda\\<close>, \\<open>d\\<close>, \\<open>call\\<close> and \\<open>prim\\<close> inside a function defined with \\<open>fixrec\\<close>, we need continuity results for them. These are all of the same shape and proven by case analysis on the discriminator.\n\\<close>"], ["", "lemma cont2cont_case_lambda [simp, cont2cont]:\n  assumes \"\\<And>a b c. cont (\\<lambda>x. f x a b c)\"\n  shows \"cont (\\<lambda>x. case_lambda (f x) l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cont (\\<lambda>x. case l of Lambda xa xb xc \\<Rightarrow> f x xa xb xc)", "using assms"], ["proof (prove)\nusing this:\n  cont (\\<lambda>x. f x ?a ?b ?c)\n\ngoal (1 subgoal):\n 1. cont (\\<lambda>x. case l of Lambda xa xb xc \\<Rightarrow> f x xa xb xc)", "by (cases l) auto"], ["", "lemma cont2cont_case_d [simp, cont2cont]:\n  assumes \"\\<And>y. cont (\\<lambda>x. f1 x y)\"\n     and  \"\\<And>y. cont (\\<lambda>x. f2 x y)\"\n     and  \"\\<And>y. cont (\\<lambda>x. f3 x y)\"\n    and   \"cont (\\<lambda>x. f4 x)\"\n  shows \"cont (\\<lambda>x. case_d (f1 x) (f2 x) (f3 x) (f4 x) d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cont\n     (\\<lambda>x.\n         case d of DI xa \\<Rightarrow> f1 x xa | DC xa \\<Rightarrow> f2 x xa\n         | DP xa \\<Rightarrow> f3 x xa | Stop \\<Rightarrow> f4 x)", "using assms"], ["proof (prove)\nusing this:\n  cont (\\<lambda>x. f1 x ?y)\n  cont (\\<lambda>x. f2 x ?y)\n  cont (\\<lambda>x. f3 x ?y)\n  cont f4\n\ngoal (1 subgoal):\n 1. cont\n     (\\<lambda>x.\n         case d of DI xa \\<Rightarrow> f1 x xa | DC xa \\<Rightarrow> f2 x xa\n         | DP xa \\<Rightarrow> f3 x xa | Stop \\<Rightarrow> f4 x)", "by (cases d) auto"], ["", "lemma cont2cont_case_call [simp, cont2cont]:\n  assumes \"\\<And>a b c. cont (\\<lambda>x. f1 x a b c)\"\n     and  \"\\<And>a b c. cont (\\<lambda>x. f2 x a b c)\"\n  shows \"cont (\\<lambda>x. case_call (f1 x) (f2 x) c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cont\n     (\\<lambda>x.\n         case c of App xa xb xc \\<Rightarrow> f1 x xa xb xc\n         | call.Let xa xb xc \\<Rightarrow> f2 x xa xb xc)", "using assms"], ["proof (prove)\nusing this:\n  cont (\\<lambda>x. f1 x ?a ?b ?c)\n  cont (\\<lambda>x. f2 x ?a ?b ?c)\n\ngoal (1 subgoal):\n 1. cont\n     (\\<lambda>x.\n         case c of App xa xb xc \\<Rightarrow> f1 x xa xb xc\n         | call.Let xa xb xc \\<Rightarrow> f2 x xa xb xc)", "by (cases c) auto"], ["", "lemma cont2cont_case_prim [simp, cont2cont]:\n  assumes \"\\<And>y. cont (\\<lambda>x. f1 x y)\"\n     and  \"\\<And>y z. cont (\\<lambda>x. f2 x y z)\"\n  shows \"cont (\\<lambda>x. case_prim (f1 x) (f2 x) p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cont\n     (\\<lambda>x.\n         case p of Plus xa \\<Rightarrow> f1 x xa\n         | prim.If xa xb \\<Rightarrow> f2 x xa xb)", "using assms"], ["proof (prove)\nusing this:\n  cont (\\<lambda>x. f1 x ?y)\n  cont (\\<lambda>x. f2 x ?y ?z)\n\ngoal (1 subgoal):\n 1. cont\n     (\\<lambda>x.\n         case p of Plus xa \\<Rightarrow> f1 x xa\n         | prim.If xa xb \\<Rightarrow> f2 x xa xb)", "by (cases p) auto"], ["", "text \\<open>\nNow, our answer domain is not any more the integers, but rather call caches. These are represented as sets containing tuples of call sites (given by their label) and binding environments to the called value. The argument types are unaltered.\n\nIn the functions \\<open>\\<F>\\<close> and \\<open>\\<C>\\<close>, upon every call, a new element is added to the resulting set. The \\<open>STOP\\<close> continuation now ignores its argument and retuns the empty set instead. This corresponds to Figure 4.2 and 4.3 in Shivers' dissertation.\n\\<close>"], ["", "type_synonym ccache = \"((label \\<times> benv) \\<times> d) set\""], ["", "type_synonym ans = ccache"], ["", "type_synonym fstate = \"(d \\<times> d list \\<times> venv \\<times> contour)\""], ["", "type_synonym cstate = \"(call \\<times> benv \\<times> venv \\<times> contour)\""], ["", "fixrec   evalF :: \"fstate discr \\<rightarrow> ans\" (\"\\<F>\")\n     and evalC :: \"cstate discr \\<rightarrow> ans\" (\"\\<C>\")\n  where \"\\<F>\\<cdot>fstate = (case undiscr fstate of\n             (DC (Lambda lab vs c, \\<beta>), as, ve, b) \\<Rightarrow>\n               (if length vs = length as\n                then let \\<beta>' = \\<beta> (lab \\<mapsto> b);\n                         ve' = map_upds ve (map (\\<lambda>v.(v,b)) vs) as\n                     in \\<C>\\<cdot>(Discr (c,\\<beta>',ve',b))\n                else \\<bottom>)\n            | (DP (Plus c),[DI a1, DI a2, cnt],ve,b) \\<Rightarrow>\n                (if isProc cnt\n                 then let b' = nb b c;\n                          \\<beta>  = [c \\<mapsto> b]\n                      in \\<F>\\<cdot>(Discr (cnt,[DI (a1 + a2)],ve,b'))\n                        \\<union> {((c, \\<beta>),cnt)}\n                 else \\<bottom>)\n            | (DP (prim.If ct cf),[DI v, contt, contf],ve,b) \\<Rightarrow>\n                (if isProc contt \\<and> isProc contf\n                 then\n                  (if v \\<noteq> 0\n                   then let b' = nb b ct;\n                            \\<beta> = [ct \\<mapsto> b]\n                        in (\\<F>\\<cdot>(Discr (contt,[],ve,b'))\n                            \\<union> {((ct, \\<beta>),contt)})\n                   else let b' = nb b cf;\n                            \\<beta> = [cf \\<mapsto> b]\n                        in (\\<F>\\<cdot>(Discr (contf,[],ve,b')))\n                            \\<union> {((cf, \\<beta>),contf)})\n                 else \\<bottom>)\n            | (Stop,[DI i],_,_) \\<Rightarrow> {}\n            | _ \\<Rightarrow> \\<bottom>\n        )\"\n      | \"\\<C>\\<cdot>cstate = (case undiscr cstate of\n             (App lab f vs,\\<beta>,ve,b) \\<Rightarrow>\n                 let f' = \\<A> f \\<beta> ve;\n                     as = map (\\<lambda>v. \\<A> v \\<beta> ve) vs;\n                     b' = nb b lab\n                  in if isProc f'\n                     then \\<F>\\<cdot>(Discr (f',as,ve,b')) \\<union> {((lab, \\<beta>),f')}\n                     else \\<bottom>\n            | (Let lab ls c',\\<beta>,ve,b) \\<Rightarrow>\n                 let b' = nb b lab;\n                     \\<beta>' = \\<beta> (lab \\<mapsto> b');\n                    ve' = ve ++ map_of (map (\\<lambda>(v,l). ((v,b'), \\<A> (L l) \\<beta>' ve)) ls)\n                 in \\<C>\\<cdot>(Discr (c',\\<beta>',ve',b'))\n        )\""], ["", "text \\<open>\nIn preparation of later proofs, we give the cases of the generated induction rule names and also create a large rule to deconstruct the an value of type \\<open>fstate\\<close> into the various cases that were used in the definition of \\<open>\\<F>\\<close>.\n\\<close>"], ["", "lemmas evalF_evalC_induct = evalF_evalC.induct[case_names Admissibility Bottom Next]"], ["", "lemmas cl_cases = prod.exhaust[OF lambda.exhaust, of _ \"\\<lambda> a _ . a\"]"], ["", "lemmas ds_cases_plus = list.exhaust[\n  OF _ d.exhaust, of _ _ \"\\<lambda>a _. a\",\n  OF _ list.exhaust, of _ _ \"\\<lambda>_ x _. x\",\n  OF _ _ d.exhaust, of _ _ \"\\<lambda>_ _ _ a _. a\",\n  OF _ _ list.exhaust,of _ _ \"\\<lambda>_ _ _ _ x _. x\",\n  OF _ _ _ list.exhaust,of _ _ \"\\<lambda>_ _ _ _ _ _ _ x. x\"\n  ]"], ["", "lemmas ds_cases_if = list.exhaust[OF _ d.exhaust, of _ _ \"\\<lambda>a _. a\",\n  OF _ list.exhaust[OF _ list.exhaust[OF _ list.exhaust, of _ _ \"\\<lambda>_ x. x\"], of _ _ \"\\<lambda>_ x. x\"], of _ _ \"\\<lambda>_ x _. x\"]"], ["", "lemmas ds_cases_stop = list.exhaust[OF _ d.exhaust, of _ _ \"\\<lambda>a _. a\",\n  OF _ list.exhaust, of _ _ \"\\<lambda>_ x _. x\"]"], ["", "lemmas fstate_case = prod_cases4[OF d.exhaust, of _ \"\\<lambda>x _ _ _ . x\",\n  OF _ cl_cases prim.exhaust, of _ _ \"\\<lambda> _ _ _ _ a . a\" \"\\<lambda> _ _ _ _ a. a\",\n  OF _ case_split ds_cases_plus ds_cases_if ds_cases_stop,\n  of _ _ \"\\<lambda>_ as _ _ _ _ _ _ vs _ . length vs = length as\" \"\\<lambda> _ ds _ _ _ _ . ds\" \"\\<lambda> _ ds _ _ _ _ _. ds\" \"\\<lambda> _ ds _ _. ds\",\n  case_names \"x\" \"Closure\" \"x\" \"x\"  \"x\" \"x\" \"Plus\" \"x\" \"x\" \"x\" \"x\" \"x\" \"x\" \"x\" \"x\"   \"x\" \"x\" \"If_True\" \"If_False\" \"x\" \"x\" \"x\" \"x\" \"x\" \"Stop\"  \"x\" \"x\" \"x\" \"x\" \"x\"]"], ["", "text \\<open>\nThe exact semantics of a program again uses \\<open>\\<F>\\<close> with properly initialized arguments. For the first two examples, we see that the function works as expected.\n\\<close>"], ["", "definition evalCPS :: \"prog \\<Rightarrow> ans\" (\"\\<PR>\")\n  where \"\\<PR> l = (let ve = Map.empty;\n                          \\<beta> = Map.empty;\n                          f = \\<A> (L l) \\<beta> ve\n                      in  \\<F>\\<cdot>(Discr (f,[Stop],ve,\\<binit>)))\""], ["", "lemma correct_ex1: \"\\<PR> ex1 = {((2,[1 \\<mapsto> \\<binit>]), Stop)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<PR> ex1 = {((2, [1 \\<mapsto> \\<binit>]), Stop)}", "unfolding evalCPS_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (let ve = Map.empty; \\<beta> = Map.empty; f = \\<A> (L ex1) \\<beta> ve\n     in \\<F>\\<cdot>(Discr (f, [Stop], ve, \\<binit>))) =\n    {((2, [1 \\<mapsto> \\<binit>]), Stop)}", "by simp"], ["", "lemma correct_ex2: \"\\<PR> ex2 = {((2, [1 \\<mapsto> \\<binit>]), DP (Plus 3)),\n                                   ((3, [3 \\<mapsto> nb \\<binit> 2]),  Stop)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<PR> ex2 =\n    {((2, [1 \\<mapsto> \\<binit>]), DP (Plus 3)),\n     ((3, [3 \\<mapsto> nb \\<binit> 2]), Stop)}", "unfolding evalCPS_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (let ve = Map.empty; \\<beta> = Map.empty; f = \\<A> (L ex2) \\<beta> ve\n     in \\<F>\\<cdot>(Discr (f, [Stop], ve, \\<binit>))) =\n    {((2, [1 \\<mapsto> \\<binit>]), DP (Plus 3)),\n     ((3, [3 \\<mapsto> nb \\<binit> 2]), Stop)}", "by simp"], ["", "end"]]}