{"file_name": "/home/qj213/afp-2021-10-22/thys/FFT/FFT.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/FFT", "problem_names": ["lemma Ivl4:\n  \"{0..<4::nat} = {0, 1, 2, 3}\"", "lemma Sum4:\n  \"(\\<Sum>i=0..<4::nat. x i) = x 0 + x 1 + x 2 + x 3\"", "lemma sum_add_nat_ivl_singleton:\n  assumes less: \"m < (n::nat)\"\n  shows \"f m + sum f {m<..<n} = sum f {m..<n}\"", "lemma sum_add_split_nat_ivl_singleton:\n  assumes less: \"m < (n::nat)\"\n    and g: \"!!i. [| m < i; i < n |] ==> g i = f i\"\n  shows \"f m + sum g {m<..<n} = sum f {m..<n}\"", "lemma sum_add_split_nat_ivl:\n  assumes le: \"m <= (k::nat)\" \"k <= n\"\n    and g: \"!!i. [| m <= i; i < k |] ==> g i = f i\"\n    and h: \"!!i. [| k <= i; i < n |] ==> h i = f i\"\n  shows \"sum g {m..<k} + sum h {k..<n} = sum f {m..<n}\"", "lemma ivl_splice_Un:\n  \"{0..<2*n::nat} = ((*) 2 ` {0..<n}) \\<union> ((%i. Suc (2*i)) ` {0..<n})\"", "lemma ivl_splice_Int:\n  \"((*) 2 ` {0..<n}) \\<inter> ((%i. Suc (2*i)) ` {0..<n}) = {}\"", "lemma double_inj_on:\n  \"inj_on (%i. 2*i::nat) A\"", "lemma Suc_double_inj_on:\n  \"inj_on (%i. Suc (2*i)) A\"", "lemma sum_splice:\n  \"(\\<Sum>i::nat = 0..<2*n. f i) = (\\<Sum>i = 0..<n. f (2*i)) + (\\<Sum>i = 0..<n. f (2*i+1))\"", "lemma sin_periodic_pi_diff: \"sin (x - pi) = - sin x\"", "lemma sin_cos_between_zero_two_pi:\n  assumes 0: \"0 < x\" and pi: \"x < 2 * pi\"\n  shows \"sin x \\<noteq> 0 \\<or> cos x \\<noteq> 1\"", "lemma root_nonzero: \"root n \\<noteq> 0\"", "lemma root_unity: \"root n ^ n = 1\"", "lemma root_cancel: \"0 < d ==> root (d * n) ^ (d * k) = root n ^ k\"", "lemma root_summation:\n  assumes k: \"0 < k\" \"k < n\"\n  shows \"(\\<Sum>i=0..<n. (root n ^ k) ^ i) = 0\"", "lemma root_summation_inv:\n  assumes k: \"0 < k\" \"k < n\"\n  shows \"(\\<Sum>i=0..<n. ((1 / root n) ^ k) ^ i) = 0\"", "lemma root0 [simp]:\n  \"root 0 = 1\"", "lemma root1 [simp]:\n  \"root 1 = 1\"", "lemma root2 [simp]:\n  \"root 2 = -1\"", "lemma root4 [simp]:\n  \"root 4 = \\<i>\"", "lemma root_cancel1:\n  \"root (2 * m) ^ (i * (2 * j)) = root m ^ (i * j)\"", "lemma root_cancel2:\n  \"0 < n ==> root (2 * n) ^ n = - 1\"", "lemma DFT_lower:\n  \"DFT (2 * m) a i =\n  DFT m (%i. a (2 * i)) i +\n  (root (2 * m)) ^ i * DFT m (%i. a (2 * i + 1)) i\"", "lemma DFT_upper:\n  assumes mbound: \"0 < m\" and ibound: \"m <= i\"\n  shows \"DFT (2 * m) a i =\n    DFT m (%i. a (2 * i)) (i - m) -\n    root (2 * m) ^ (i - m) * DFT m (%i. a (2 * i + 1)) (i - m)\"", "lemma IDFT_lower:\n  \"IDFT (2 * m) a i =\n  IDFT m (%i. a (2 * i)) i +\n  (1 / root (2 * m)) ^ i * IDFT m (%i. a (2 * i + 1)) i\"", "lemma IDFT_upper:\n  assumes mbound: \"0 < m\" and ibound: \"m <= i\"\n  shows \"IDFT (2 * m) a i =\n    IDFT m (%i. a (2 * i)) (i - m) -\n    (1 / root (2 * m)) ^ (i - m) *\n    IDFT m (%i. a (2 * i + 1)) (i - m)\"", "lemma power_diff_inverse:\n  assumes nz: \"(a::'a::field) ~= 0\"\n  shows \"m <= n ==> (inverse a) ^ (n-m) = (a^m) / (a^n)\"", "lemma power_diff_rev_if:\n  assumes nz: \"(a::'a::field) ~= 0\"\n  shows \"(a^m) / (a^n) = (if n <= m then a ^ (m-n) else (1/a) ^ (n-m))\"", "lemma power_divides_special:\n  \"(a::'a::field) ~= 0 ==>\n  a ^ (i * j) / a ^ (k * i) = (a ^ j / a ^ k) ^ i\"", "theorem DFT_inverse:\n  assumes i_less: \"i < n\"\n  shows  \"IDFT n (DFT n a) i = of_nat n * a i\"", "theorem DFT_FFT:\n  \"!!a i. i < 2 ^ k ==> DFT (2 ^ k) a i = FFT k a i\"", "theorem IDFT_IFFT:\n  \"!!a i. i < 2 ^ k ==> IDFT (2 ^ k) a i = IFFT k a i\""], "translations": [["", "lemma Ivl4:\n  \"{0..<4::nat} = {0, 1, 2, 3}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {0..<4} = {0, 1, 2, 3}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. {0..<4} = {0, 1, 2, 3}", "have \"{0..<4::nat} = {0..<Suc (Suc (Suc (Suc 0)))}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {0..<4} = {0..<Suc (Suc (Suc (Suc 0)))}", "by (simp add: eval_nat_numeral)"], ["proof (state)\nthis:\n  {0..<4} = {0..<Suc (Suc (Suc (Suc 0)))}\n\ngoal (1 subgoal):\n 1. {0..<4} = {0, 1, 2, 3}", "also"], ["proof (state)\nthis:\n  {0..<4} = {0..<Suc (Suc (Suc (Suc 0)))}\n\ngoal (1 subgoal):\n 1. {0..<4} = {0, 1, 2, 3}", "have \"... = {0, 1, 2, 3}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {0..<Suc (Suc (Suc (Suc 0)))} = {0, 1, 2, 3}", "by (simp add: atLeastLessThanSuc eval_nat_numeral insert_commute)"], ["proof (state)\nthis:\n  {0..<Suc (Suc (Suc (Suc 0)))} = {0, 1, 2, 3}\n\ngoal (1 subgoal):\n 1. {0..<4} = {0, 1, 2, 3}", "finally"], ["proof (chain)\npicking this:\n  {0..<4} = {0, 1, 2, 3}", "show ?thesis"], ["proof (prove)\nusing this:\n  {0..<4} = {0, 1, 2, 3}\n\ngoal (1 subgoal):\n 1. {0..<4} = {0, 1, 2, 3}", "."], ["proof (state)\nthis:\n  {0..<4} = {0, 1, 2, 3}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Sum4:\n  \"(\\<Sum>i=0..<4::nat. x i) = x 0 + x 1 + x 2 + x 3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum x {0..<4} = x 0 + x 1 + x 2 + x 3", "by (simp add: Ivl4 eval_nat_numeral)"], ["", "text \\<open>A number of specialised lemmas for the summation operator,\n  where the index set is the natural numbers\\<close>"], ["", "lemma sum_add_nat_ivl_singleton:\n  assumes less: \"m < (n::nat)\"\n  shows \"f m + sum f {m<..<n} = sum f {m..<n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f m + sum f {m<..<n} = sum f {m..<n}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. f m + sum f {m<..<n} = sum f {m..<n}", "have \"f m + sum f {m<..<n} = sum f ({m} \\<union> {m<..<n})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f m + sum f {m<..<n} = sum f ({m} \\<union> {m<..<n})", "by (simp add: sum.union_disjoint ivl_disj_int)"], ["proof (state)\nthis:\n  f m + sum f {m<..<n} = sum f ({m} \\<union> {m<..<n})\n\ngoal (1 subgoal):\n 1. f m + sum f {m<..<n} = sum f {m..<n}", "also"], ["proof (state)\nthis:\n  f m + sum f {m<..<n} = sum f ({m} \\<union> {m<..<n})\n\ngoal (1 subgoal):\n 1. f m + sum f {m<..<n} = sum f {m..<n}", "from less"], ["proof (chain)\npicking this:\n  m < n", "have \"... = sum f {m..<n}\""], ["proof (prove)\nusing this:\n  m < n\n\ngoal (1 subgoal):\n 1. sum f ({m} \\<union> {m<..<n}) = sum f {m..<n}", "by (simp only: ivl_disj_un)"], ["proof (state)\nthis:\n  sum f ({m} \\<union> {m<..<n}) = sum f {m..<n}\n\ngoal (1 subgoal):\n 1. f m + sum f {m<..<n} = sum f {m..<n}", "finally"], ["proof (chain)\npicking this:\n  f m + sum f {m<..<n} = sum f {m..<n}", "show ?thesis"], ["proof (prove)\nusing this:\n  f m + sum f {m<..<n} = sum f {m..<n}\n\ngoal (1 subgoal):\n 1. f m + sum f {m<..<n} = sum f {m..<n}", "."], ["proof (state)\nthis:\n  f m + sum f {m<..<n} = sum f {m..<n}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sum_add_split_nat_ivl_singleton:\n  assumes less: \"m < (n::nat)\"\n    and g: \"!!i. [| m < i; i < n |] ==> g i = f i\"\n  shows \"f m + sum g {m<..<n} = sum f {m..<n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f m + sum g {m<..<n} = sum f {m..<n}", "using less g"], ["proof (prove)\nusing this:\n  m < n\n  \\<lbrakk>m < ?i; ?i < n\\<rbrakk> \\<Longrightarrow> g ?i = f ?i\n\ngoal (1 subgoal):\n 1. f m + sum g {m<..<n} = sum f {m..<n}", "by(simp add: sum_add_nat_ivl_singleton cong: sum.cong_simp)"], ["", "lemma sum_add_split_nat_ivl:\n  assumes le: \"m <= (k::nat)\" \"k <= n\"\n    and g: \"!!i. [| m <= i; i < k |] ==> g i = f i\"\n    and h: \"!!i. [| k <= i; i < n |] ==> h i = f i\"\n  shows \"sum g {m..<k} + sum h {k..<n} = sum f {m..<n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum g {m..<k} + sum h {k..<n} = sum f {m..<n}", "using le g h"], ["proof (prove)\nusing this:\n  m \\<le> k\n  k \\<le> n\n  \\<lbrakk>m \\<le> ?i; ?i < k\\<rbrakk> \\<Longrightarrow> g ?i = f ?i\n  \\<lbrakk>k \\<le> ?i; ?i < n\\<rbrakk> \\<Longrightarrow> h ?i = f ?i\n\ngoal (1 subgoal):\n 1. sum g {m..<k} + sum h {k..<n} = sum f {m..<n}", "by (simp add: sum.atLeastLessThan_concat cong: sum.cong_simp)"], ["", "lemma ivl_splice_Un:\n  \"{0..<2*n::nat} = ((*) 2 ` {0..<n}) \\<union> ((%i. Suc (2*i)) ` {0..<n})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {0..<2 * n} =\n    (*) 2 ` {0..<n} \\<union> (\\<lambda>i. Suc (2 * i)) ` {0..<n}", "apply (unfold image_def Bex_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. {0..<2 * n} =\n    {y. \\<exists>x. x \\<in> {0..<n} \\<and> y = 2 * x} \\<union>\n    {y. \\<exists>x. x \\<in> {0..<n} \\<and> y = Suc (2 * x)}", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x < 2 * n; \\<forall>xa<n. x \\<noteq> Suc (2 * xa)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa<n. x = 2 * xa", "apply arith"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma ivl_splice_Int:\n  \"((*) 2 ` {0..<n}) \\<inter> ((%i. Suc (2*i)) ` {0..<n}) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (*) 2 ` {0..<n} \\<inter> (\\<lambda>i. Suc (2 * i)) ` {0..<n} = {}", "by auto arith"], ["", "lemma double_inj_on:\n  \"inj_on (%i. 2*i::nat) A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on ((*) 2) A", "by (simp add: inj_onI)"], ["", "lemma Suc_double_inj_on:\n  \"inj_on (%i. Suc (2*i)) A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (\\<lambda>i. Suc (2 * i)) A", "by (rule inj_onI) simp"], ["", "lemma sum_splice:\n  \"(\\<Sum>i::nat = 0..<2*n. f i) = (\\<Sum>i = 0..<n. f (2*i)) + (\\<Sum>i = 0..<n. f (2*i+1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum f {0..<2 * n} =\n    (\\<Sum>i = 0..<n. f (2 * i)) + (\\<Sum>i = 0..<n. f (2 * i + 1))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. sum f {0..<2 * n} =\n    (\\<Sum>i = 0..<n. f (2 * i)) + (\\<Sum>i = 0..<n. f (2 * i + 1))", "have \"(\\<Sum>i::nat = 0..<2*n. f i) =\n    sum f ((*) 2 ` {0..<n}) + sum f ((%i. 2*i+1) ` {0..<n})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum f {0..<2 * n} =\n    sum f ((*) 2 ` {0..<n}) + sum f ((\\<lambda>i. 2 * i + 1) ` {0..<n})", "by (simp add: ivl_splice_Un ivl_splice_Int sum.union_disjoint)"], ["proof (state)\nthis:\n  sum f {0..<2 * n} =\n  sum f ((*) 2 ` {0..<n}) + sum f ((\\<lambda>i. 2 * i + 1) ` {0..<n})\n\ngoal (1 subgoal):\n 1. sum f {0..<2 * n} =\n    (\\<Sum>i = 0..<n. f (2 * i)) + (\\<Sum>i = 0..<n. f (2 * i + 1))", "also"], ["proof (state)\nthis:\n  sum f {0..<2 * n} =\n  sum f ((*) 2 ` {0..<n}) + sum f ((\\<lambda>i. 2 * i + 1) ` {0..<n})\n\ngoal (1 subgoal):\n 1. sum f {0..<2 * n} =\n    (\\<Sum>i = 0..<n. f (2 * i)) + (\\<Sum>i = 0..<n. f (2 * i + 1))", "have \"... = (\\<Sum>i = 0..<n. f (2*i)) + (\\<Sum>i = 0..<n. f (2*i+1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum f ((*) 2 ` {0..<n}) + sum f ((\\<lambda>i. 2 * i + 1) ` {0..<n}) =\n    (\\<Sum>i = 0..<n. f (2 * i)) + (\\<Sum>i = 0..<n. f (2 * i + 1))", "by (simp add: sum.reindex [OF double_inj_on]\n      sum.reindex [OF Suc_double_inj_on])"], ["proof (state)\nthis:\n  sum f ((*) 2 ` {0..<n}) + sum f ((\\<lambda>i. 2 * i + 1) ` {0..<n}) =\n  (\\<Sum>i = 0..<n. f (2 * i)) + (\\<Sum>i = 0..<n. f (2 * i + 1))\n\ngoal (1 subgoal):\n 1. sum f {0..<2 * n} =\n    (\\<Sum>i = 0..<n. f (2 * i)) + (\\<Sum>i = 0..<n. f (2 * i + 1))", "finally"], ["proof (chain)\npicking this:\n  sum f {0..<2 * n} =\n  (\\<Sum>i = 0..<n. f (2 * i)) + (\\<Sum>i = 0..<n. f (2 * i + 1))", "show ?thesis"], ["proof (prove)\nusing this:\n  sum f {0..<2 * n} =\n  (\\<Sum>i = 0..<n. f (2 * i)) + (\\<Sum>i = 0..<n. f (2 * i + 1))\n\ngoal (1 subgoal):\n 1. sum f {0..<2 * n} =\n    (\\<Sum>i = 0..<n. f (2 * i)) + (\\<Sum>i = 0..<n. f (2 * i + 1))", "."], ["proof (state)\nthis:\n  sum f {0..<2 * n} =\n  (\\<Sum>i = 0..<n. f (2 * i)) + (\\<Sum>i = 0..<n. f (2 * i + 1))\n\ngoal:\nNo subgoals!", "qed"], ["", "section \\<open>Complex Roots of Unity\\<close>"], ["", "text \\<open>The function @{term cis} from the complex library returns the\n  point on the unity circle corresponding to the argument angle.  It\n  is the base for our definition of \\<open>root\\<close>.  The main property,\n  De Moirve's formula is already there in the library.\\<close>"], ["", "definition root :: \"nat => complex\" where\n  \"root n == cis (2*pi/(real (n::nat)))\""], ["", "lemma sin_periodic_pi_diff: \"sin (x - pi) = - sin x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sin (x - pi) = - sin x", "by (fact sin_minus_pi)"], ["", "lemma sin_cos_between_zero_two_pi:\n  assumes 0: \"0 < x\" and pi: \"x < 2 * pi\"\n  shows \"sin x \\<noteq> 0 \\<or> cos x \\<noteq> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sin x \\<noteq> 0 \\<or> cos x \\<noteq> 1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. sin x \\<noteq> 0 \\<or> cos x \\<noteq> 1", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. sin x \\<noteq> 0 \\<or> cos x \\<noteq> 1", "assume \"0 < x\" and \"x < pi\""], ["proof (state)\nthis:\n  0 < x\n  x < pi\n\ngoal (1 subgoal):\n 1. sin x \\<noteq> 0 \\<or> cos x \\<noteq> 1", "then"], ["proof (chain)\npicking this:\n  0 < x\n  x < pi", "have \"sin x \\<noteq> 0\""], ["proof (prove)\nusing this:\n  0 < x\n  x < pi\n\ngoal (1 subgoal):\n 1. sin x \\<noteq> 0", "by (auto dest: sin_gt_zero)"], ["proof (state)\nthis:\n  sin x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. sin x \\<noteq> 0 \\<or> cos x \\<noteq> 1", "}"], ["proof (state)\nthis:\n  \\<lbrakk>0 < x; x < pi\\<rbrakk> \\<Longrightarrow> sin x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. sin x \\<noteq> 0 \\<or> cos x \\<noteq> 1", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>0 < x; x < pi\\<rbrakk> \\<Longrightarrow> sin x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. sin x \\<noteq> 0 \\<or> cos x \\<noteq> 1", "{"], ["proof (state)\nthis:\n  \\<lbrakk>0 < x; x < pi\\<rbrakk> \\<Longrightarrow> sin x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. sin x \\<noteq> 0 \\<or> cos x \\<noteq> 1", "assume \"x = pi\""], ["proof (state)\nthis:\n  x = pi\n\ngoal (1 subgoal):\n 1. sin x \\<noteq> 0 \\<or> cos x \\<noteq> 1", "then"], ["proof (chain)\npicking this:\n  x = pi", "have \"cos x \\<noteq> 1\""], ["proof (prove)\nusing this:\n  x = pi\n\ngoal (1 subgoal):\n 1. cos x \\<noteq> 1", "by simp"], ["proof (state)\nthis:\n  cos x \\<noteq> 1\n\ngoal (1 subgoal):\n 1. sin x \\<noteq> 0 \\<or> cos x \\<noteq> 1", "}"], ["proof (state)\nthis:\n  x = pi \\<Longrightarrow> cos x \\<noteq> 1\n\ngoal (1 subgoal):\n 1. sin x \\<noteq> 0 \\<or> cos x \\<noteq> 1", "moreover"], ["proof (state)\nthis:\n  x = pi \\<Longrightarrow> cos x \\<noteq> 1\n\ngoal (1 subgoal):\n 1. sin x \\<noteq> 0 \\<or> cos x \\<noteq> 1", "{"], ["proof (state)\nthis:\n  x = pi \\<Longrightarrow> cos x \\<noteq> 1\n\ngoal (1 subgoal):\n 1. sin x \\<noteq> 0 \\<or> cos x \\<noteq> 1", "assume pi1: \"pi < x\" and pi2: \"x < 2 * pi\""], ["proof (state)\nthis:\n  pi < x\n  x < 2 * pi\n\ngoal (1 subgoal):\n 1. sin x \\<noteq> 0 \\<or> cos x \\<noteq> 1", "then"], ["proof (chain)\npicking this:\n  pi < x\n  x < 2 * pi", "have \"0 < x - pi\" and \"x - pi < pi\""], ["proof (prove)\nusing this:\n  pi < x\n  x < 2 * pi\n\ngoal (1 subgoal):\n 1. 0 < x - pi &&& x - pi < pi", "by arith+"], ["proof (state)\nthis:\n  0 < x - pi\n  x - pi < pi\n\ngoal (1 subgoal):\n 1. sin x \\<noteq> 0 \\<or> cos x \\<noteq> 1", "then"], ["proof (chain)\npicking this:\n  0 < x - pi\n  x - pi < pi", "have \"sin (x - pi) \\<noteq> 0\""], ["proof (prove)\nusing this:\n  0 < x - pi\n  x - pi < pi\n\ngoal (1 subgoal):\n 1. sin (x - pi) \\<noteq> 0", "using sin_gt_zero"], ["proof (prove)\nusing this:\n  0 < x - pi\n  x - pi < pi\n  \\<lbrakk>0 < ?x; ?x < pi\\<rbrakk> \\<Longrightarrow> 0 < sin ?x\n\ngoal (1 subgoal):\n 1. sin (x - pi) \\<noteq> 0", "by fastforce"], ["proof (state)\nthis:\n  sin (x - pi) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. sin x \\<noteq> 0 \\<or> cos x \\<noteq> 1", "with pi1 pi2"], ["proof (chain)\npicking this:\n  pi < x\n  x < 2 * pi\n  sin (x - pi) \\<noteq> 0", "have \"sin x \\<noteq> 0\""], ["proof (prove)\nusing this:\n  pi < x\n  x < 2 * pi\n  sin (x - pi) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. sin x \\<noteq> 0", "by simp"], ["proof (state)\nthis:\n  sin x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. sin x \\<noteq> 0 \\<or> cos x \\<noteq> 1", "}"], ["proof (state)\nthis:\n  \\<lbrakk>pi < x; x < 2 * pi\\<rbrakk> \\<Longrightarrow> sin x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. sin x \\<noteq> 0 \\<or> cos x \\<noteq> 1", "ultimately"], ["proof (chain)\npicking this:\n  \\<lbrakk>0 < x; x < pi\\<rbrakk> \\<Longrightarrow> sin x \\<noteq> 0\n  x = pi \\<Longrightarrow> cos x \\<noteq> 1\n  \\<lbrakk>pi < x; x < 2 * pi\\<rbrakk> \\<Longrightarrow> sin x \\<noteq> 0", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 < x; x < pi\\<rbrakk> \\<Longrightarrow> sin x \\<noteq> 0\n  x = pi \\<Longrightarrow> cos x \\<noteq> 1\n  \\<lbrakk>pi < x; x < 2 * pi\\<rbrakk> \\<Longrightarrow> sin x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. sin x \\<noteq> 0 \\<or> cos x \\<noteq> 1", "using 0 pi"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 < x; x < pi\\<rbrakk> \\<Longrightarrow> sin x \\<noteq> 0\n  x = pi \\<Longrightarrow> cos x \\<noteq> 1\n  \\<lbrakk>pi < x; x < 2 * pi\\<rbrakk> \\<Longrightarrow> sin x \\<noteq> 0\n  0 < x\n  x < 2 * pi\n\ngoal (1 subgoal):\n 1. sin x \\<noteq> 0 \\<or> cos x \\<noteq> 1", "by arith"], ["proof (state)\nthis:\n  sin x \\<noteq> 0 \\<or> cos x \\<noteq> 1\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Basic Lemmas\\<close>"], ["", "lemma root_nonzero: \"root n \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. FFT.root n \\<noteq> 0", "by (auto simp add: complex_eq_iff root_def dest: sin_zero_abs_cos_one)"], ["", "lemma root_unity: \"root n ^ n = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. FFT.root n ^ n = 1", "by (simp add: complex_eq_iff root_def DeMoivre)"], ["", "lemma root_cancel: \"0 < d ==> root (d * n) ^ (d * k) = root n ^ k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < d \\<Longrightarrow> FFT.root (d * n) ^ (d * k) = FFT.root n ^ k", "apply (unfold root_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < d \\<Longrightarrow>\n    cis (2 * pi / real (d * n)) ^ (d * k) = cis (2 * pi / real n) ^ k", "apply (simp add: DeMoivre)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma root_summation:\n  assumes k: \"0 < k\" \"k < n\"\n  shows \"(\\<Sum>i=0..<n. (root n ^ k) ^ i) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum ((^) (FFT.root n ^ k)) {0..<n} = 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. sum ((^) (FFT.root n ^ k)) {0..<n} = 0", "from k"], ["proof (chain)\npicking this:\n  0 < k\n  k < n", "have real0: \"0 < real k * (2 * pi) / real n\""], ["proof (prove)\nusing this:\n  0 < k\n  k < n\n\ngoal (1 subgoal):\n 1. 0 < real k * (2 * pi) / real n", "by (simp add: zero_less_divide_iff\n      mult_strict_right_mono [where a = 0, simplified])"], ["proof (state)\nthis:\n  0 < real k * (2 * pi) / real n\n\ngoal (1 subgoal):\n 1. sum ((^) (FFT.root n ^ k)) {0..<n} = 0", "from k mult_strict_right_mono [where a = \"real k\" and\n    b = \"real n\" and c = \"2 * pi / real n\", simplified]"], ["proof (chain)\npicking this:\n  0 < k\n  k < n\n  k < n \\<Longrightarrow> real k * (2 * pi) / real n < 2 * pi", "have realk: \"real k * (2 * pi) / real n < 2 * pi\""], ["proof (prove)\nusing this:\n  0 < k\n  k < n\n  k < n \\<Longrightarrow> real k * (2 * pi) / real n < 2 * pi\n\ngoal (1 subgoal):\n 1. real k * (2 * pi) / real n < 2 * pi", "by (simp add: zero_less_divide_iff)"], ["proof (state)\nthis:\n  real k * (2 * pi) / real n < 2 * pi\n\ngoal (1 subgoal):\n 1. sum ((^) (FFT.root n ^ k)) {0..<n} = 0", "txt \\<open>Main part of the proof\\<close>"], ["proof (state)\nthis:\n  real k * (2 * pi) / real n < 2 * pi\n\ngoal (1 subgoal):\n 1. sum ((^) (FFT.root n ^ k)) {0..<n} = 0", "have \"(\\<Sum>i=0..<n. (root n ^ k) ^ i) =\n    ((root n ^ k) ^ n - 1) / (root n ^ k - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum ((^) (FFT.root n ^ k)) {0..<n} =\n    ((FFT.root n ^ k) ^ n - 1) / (FFT.root n ^ k - 1)", "unfolding atLeast0LessThan"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum ((^) (FFT.root n ^ k)) {..<n} =\n    ((FFT.root n ^ k) ^ n - 1) / (FFT.root n ^ k - 1)", "apply (rule geometric_sum)"], ["proof (prove)\ngoal (1 subgoal):\n 1. FFT.root n ^ k \\<noteq> 1", "apply (unfold root_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. cis (2 * pi / real n) ^ k \\<noteq> 1", "apply (simp add: DeMoivre)"], ["proof (prove)\ngoal (1 subgoal):\n 1. cis (real k * (2 * pi) / real n) \\<noteq> 1", "using real0 realk sin_cos_between_zero_two_pi"], ["proof (prove)\nusing this:\n  0 < real k * (2 * pi) / real n\n  real k * (2 * pi) / real n < 2 * pi\n  \\<lbrakk>0 < ?x; ?x < 2 * pi\\<rbrakk>\n  \\<Longrightarrow> sin ?x \\<noteq> 0 \\<or> cos ?x \\<noteq> 1\n\ngoal (1 subgoal):\n 1. cis (real k * (2 * pi) / real n) \\<noteq> 1", "apply (auto simp add: complex_eq_iff)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  sum ((^) (FFT.root n ^ k)) {0..<n} =\n  ((FFT.root n ^ k) ^ n - 1) / (FFT.root n ^ k - 1)\n\ngoal (1 subgoal):\n 1. sum ((^) (FFT.root n ^ k)) {0..<n} = 0", "also"], ["proof (state)\nthis:\n  sum ((^) (FFT.root n ^ k)) {0..<n} =\n  ((FFT.root n ^ k) ^ n - 1) / (FFT.root n ^ k - 1)\n\ngoal (1 subgoal):\n 1. sum ((^) (FFT.root n ^ k)) {0..<n} = 0", "have \"... = ((root n ^ n) ^ k - 1) / (root n ^ k - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((FFT.root n ^ k) ^ n - 1) / (FFT.root n ^ k - 1) =\n    ((FFT.root n ^ n) ^ k - 1) / (FFT.root n ^ k - 1)", "by (simp add: power_mult [THEN sym] ac_simps)"], ["proof (state)\nthis:\n  ((FFT.root n ^ k) ^ n - 1) / (FFT.root n ^ k - 1) =\n  ((FFT.root n ^ n) ^ k - 1) / (FFT.root n ^ k - 1)\n\ngoal (1 subgoal):\n 1. sum ((^) (FFT.root n ^ k)) {0..<n} = 0", "also"], ["proof (state)\nthis:\n  ((FFT.root n ^ k) ^ n - 1) / (FFT.root n ^ k - 1) =\n  ((FFT.root n ^ n) ^ k - 1) / (FFT.root n ^ k - 1)\n\ngoal (1 subgoal):\n 1. sum ((^) (FFT.root n ^ k)) {0..<n} = 0", "have \"... = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((FFT.root n ^ n) ^ k - 1) / (FFT.root n ^ k - 1) = 0", "by (simp add: root_unity)"], ["proof (state)\nthis:\n  ((FFT.root n ^ n) ^ k - 1) / (FFT.root n ^ k - 1) = 0\n\ngoal (1 subgoal):\n 1. sum ((^) (FFT.root n ^ k)) {0..<n} = 0", "finally"], ["proof (chain)\npicking this:\n  sum ((^) (FFT.root n ^ k)) {0..<n} = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  sum ((^) (FFT.root n ^ k)) {0..<n} = 0\n\ngoal (1 subgoal):\n 1. sum ((^) (FFT.root n ^ k)) {0..<n} = 0", "."], ["proof (state)\nthis:\n  sum ((^) (FFT.root n ^ k)) {0..<n} = 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma root_summation_inv:\n  assumes k: \"0 < k\" \"k < n\"\n  shows \"(\\<Sum>i=0..<n. ((1 / root n) ^ k) ^ i) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum ((^) ((1 / FFT.root n) ^ k)) {0..<n} = 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. sum ((^) ((1 / FFT.root n) ^ k)) {0..<n} = 0", "from k"], ["proof (chain)\npicking this:\n  0 < k\n  k < n", "have real0: \"0 < real k * (2 * pi) / real n\""], ["proof (prove)\nusing this:\n  0 < k\n  k < n\n\ngoal (1 subgoal):\n 1. 0 < real k * (2 * pi) / real n", "by (simp add: zero_less_divide_iff\n      mult_strict_right_mono [where a = 0, simplified])"], ["proof (state)\nthis:\n  0 < real k * (2 * pi) / real n\n\ngoal (1 subgoal):\n 1. sum ((^) ((1 / FFT.root n) ^ k)) {0..<n} = 0", "from k mult_strict_right_mono [where a = \"real k\" and\n    b = \"real n\" and c = \"2 * pi / real n\", simplified]"], ["proof (chain)\npicking this:\n  0 < k\n  k < n\n  k < n \\<Longrightarrow> real k * (2 * pi) / real n < 2 * pi", "have realk: \"real k * (2 * pi) / real n < 2 * pi\""], ["proof (prove)\nusing this:\n  0 < k\n  k < n\n  k < n \\<Longrightarrow> real k * (2 * pi) / real n < 2 * pi\n\ngoal (1 subgoal):\n 1. real k * (2 * pi) / real n < 2 * pi", "by (simp add: zero_less_divide_iff)"], ["proof (state)\nthis:\n  real k * (2 * pi) / real n < 2 * pi\n\ngoal (1 subgoal):\n 1. sum ((^) ((1 / FFT.root n) ^ k)) {0..<n} = 0", "txt \\<open>Main part of the proof\\<close>"], ["proof (state)\nthis:\n  real k * (2 * pi) / real n < 2 * pi\n\ngoal (1 subgoal):\n 1. sum ((^) ((1 / FFT.root n) ^ k)) {0..<n} = 0", "have \"(\\<Sum>i=0..<n. ((1 / root n) ^ k) ^ i) =\n    (((1 / root n) ^ k) ^ n - 1) / ((1 / root n) ^ k - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum ((^) ((1 / FFT.root n) ^ k)) {0..<n} =\n    (((1 / FFT.root n) ^ k) ^ n - 1) / ((1 / FFT.root n) ^ k - 1)", "unfolding atLeast0LessThan"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum ((^) ((1 / FFT.root n) ^ k)) {..<n} =\n    (((1 / FFT.root n) ^ k) ^ n - 1) / ((1 / FFT.root n) ^ k - 1)", "apply (rule geometric_sum)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (1 / FFT.root n) ^ k \\<noteq> 1", "apply (simp add: nonzero_inverse_eq_divide [THEN sym] root_nonzero)"], ["proof (prove)\ngoal (1 subgoal):\n 1. inverse (FFT.root n) ^ k \\<noteq> 1", "apply (unfold root_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. inverse (cis (2 * pi / real n)) ^ k \\<noteq> 1", "apply (simp add: DeMoivre)"], ["proof (prove)\ngoal (1 subgoal):\n 1. cis (- (real k * (2 * pi) / real n)) \\<noteq> 1", "using real0 realk sin_cos_between_zero_two_pi"], ["proof (prove)\nusing this:\n  0 < real k * (2 * pi) / real n\n  real k * (2 * pi) / real n < 2 * pi\n  \\<lbrakk>0 < ?x; ?x < 2 * pi\\<rbrakk>\n  \\<Longrightarrow> sin ?x \\<noteq> 0 \\<or> cos ?x \\<noteq> 1\n\ngoal (1 subgoal):\n 1. cis (- (real k * (2 * pi) / real n)) \\<noteq> 1", "apply (auto simp add: complex_eq_iff)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  sum ((^) ((1 / FFT.root n) ^ k)) {0..<n} =\n  (((1 / FFT.root n) ^ k) ^ n - 1) / ((1 / FFT.root n) ^ k - 1)\n\ngoal (1 subgoal):\n 1. sum ((^) ((1 / FFT.root n) ^ k)) {0..<n} = 0", "also"], ["proof (state)\nthis:\n  sum ((^) ((1 / FFT.root n) ^ k)) {0..<n} =\n  (((1 / FFT.root n) ^ k) ^ n - 1) / ((1 / FFT.root n) ^ k - 1)\n\ngoal (1 subgoal):\n 1. sum ((^) ((1 / FFT.root n) ^ k)) {0..<n} = 0", "have \"... = (((1 / root n) ^ n) ^ k - 1) / ((1 / root n) ^ k - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (((1 / FFT.root n) ^ k) ^ n - 1) / ((1 / FFT.root n) ^ k - 1) =\n    (((1 / FFT.root n) ^ n) ^ k - 1) / ((1 / FFT.root n) ^ k - 1)", "by (simp add: power_mult [THEN sym] ac_simps)"], ["proof (state)\nthis:\n  (((1 / FFT.root n) ^ k) ^ n - 1) / ((1 / FFT.root n) ^ k - 1) =\n  (((1 / FFT.root n) ^ n) ^ k - 1) / ((1 / FFT.root n) ^ k - 1)\n\ngoal (1 subgoal):\n 1. sum ((^) ((1 / FFT.root n) ^ k)) {0..<n} = 0", "also"], ["proof (state)\nthis:\n  (((1 / FFT.root n) ^ k) ^ n - 1) / ((1 / FFT.root n) ^ k - 1) =\n  (((1 / FFT.root n) ^ n) ^ k - 1) / ((1 / FFT.root n) ^ k - 1)\n\ngoal (1 subgoal):\n 1. sum ((^) ((1 / FFT.root n) ^ k)) {0..<n} = 0", "have \"... = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (((1 / FFT.root n) ^ n) ^ k - 1) / ((1 / FFT.root n) ^ k - 1) = 0", "by (simp add: power_divide root_unity)"], ["proof (state)\nthis:\n  (((1 / FFT.root n) ^ n) ^ k - 1) / ((1 / FFT.root n) ^ k - 1) = 0\n\ngoal (1 subgoal):\n 1. sum ((^) ((1 / FFT.root n) ^ k)) {0..<n} = 0", "finally"], ["proof (chain)\npicking this:\n  sum ((^) ((1 / FFT.root n) ^ k)) {0..<n} = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  sum ((^) ((1 / FFT.root n) ^ k)) {0..<n} = 0\n\ngoal (1 subgoal):\n 1. sum ((^) ((1 / FFT.root n) ^ k)) {0..<n} = 0", "."], ["proof (state)\nthis:\n  sum ((^) ((1 / FFT.root n) ^ k)) {0..<n} = 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma root0 [simp]:\n  \"root 0 = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. FFT.root 0 = 1", "by (simp add: complex_eq_iff root_def)"], ["", "lemma root1 [simp]:\n  \"root 1 = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. FFT.root 1 = 1", "by (simp add: complex_eq_iff root_def)"], ["", "lemma root2 [simp]:\n  \"root 2 = -1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. FFT.root 2 = - 1", "by (simp add: complex_eq_iff root_def)"], ["", "lemma root4 [simp]:\n  \"root 4 = \\<i>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. FFT.root 4 = \\<i>", "by (simp add: complex_eq_iff root_def)"], ["", "subsection \\<open>Derived Lemmas\\<close>"], ["", "lemma root_cancel1:\n  \"root (2 * m) ^ (i * (2 * j)) = root m ^ (i * j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. FFT.root (2 * m) ^ (i * (2 * j)) = FFT.root m ^ (i * j)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. FFT.root (2 * m) ^ (i * (2 * j)) = FFT.root m ^ (i * j)", "have \"root (2 * m) ^ (i * (2 * j)) = root (2 * m) ^ (2 * (i * j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. FFT.root (2 * m) ^ (i * (2 * j)) = FFT.root (2 * m) ^ (2 * (i * j))", "by (simp add: ac_simps)"], ["proof (state)\nthis:\n  FFT.root (2 * m) ^ (i * (2 * j)) = FFT.root (2 * m) ^ (2 * (i * j))\n\ngoal (1 subgoal):\n 1. FFT.root (2 * m) ^ (i * (2 * j)) = FFT.root m ^ (i * j)", "also"], ["proof (state)\nthis:\n  FFT.root (2 * m) ^ (i * (2 * j)) = FFT.root (2 * m) ^ (2 * (i * j))\n\ngoal (1 subgoal):\n 1. FFT.root (2 * m) ^ (i * (2 * j)) = FFT.root m ^ (i * j)", "have \"... = root m ^ (i * j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. FFT.root (2 * m) ^ (2 * (i * j)) = FFT.root m ^ (i * j)", "by (simp add: root_cancel)"], ["proof (state)\nthis:\n  FFT.root (2 * m) ^ (2 * (i * j)) = FFT.root m ^ (i * j)\n\ngoal (1 subgoal):\n 1. FFT.root (2 * m) ^ (i * (2 * j)) = FFT.root m ^ (i * j)", "finally"], ["proof (chain)\npicking this:\n  FFT.root (2 * m) ^ (i * (2 * j)) = FFT.root m ^ (i * j)", "show ?thesis"], ["proof (prove)\nusing this:\n  FFT.root (2 * m) ^ (i * (2 * j)) = FFT.root m ^ (i * j)\n\ngoal (1 subgoal):\n 1. FFT.root (2 * m) ^ (i * (2 * j)) = FFT.root m ^ (i * j)", "."], ["proof (state)\nthis:\n  FFT.root (2 * m) ^ (i * (2 * j)) = FFT.root m ^ (i * j)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma root_cancel2:\n  \"0 < n ==> root (2 * n) ^ n = - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < n \\<Longrightarrow> FFT.root (2 * n) ^ n = - 1", "txt \\<open>Note the space between \\<open>-\\<close> and \\<open>1\\<close>.\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < n \\<Longrightarrow> FFT.root (2 * n) ^ n = - 1", "using root_cancel [where n = 2 and k = 1]"], ["proof (prove)\nusing this:\n  0 < ?d \\<Longrightarrow> FFT.root (?d * 2) ^ (?d * 1) = FFT.root 2 ^ 1\n\ngoal (1 subgoal):\n 1. 0 < n \\<Longrightarrow> FFT.root (2 * n) ^ n = - 1", "by (simp add: complex_eq_iff ac_simps)"], ["", "section \\<open>Discrete Fourier Transformation\\<close>"], ["", "text \\<open>\n  We define operations  \\<open>DFT\\<close> and \\<open>IDFT\\<close> for the discrete\n  Fourier Transform and its inverse.  Vectors are simply functions of\n  type \\<open>nat => complex\\<close>.\\<close>"], ["", "text \\<open>\n  \\<open>DFT n a\\<close> is the transform of vector \\<open>a\\<close>\n  of length \\<open>n\\<close>, \\<open>IDFT\\<close> its inverse.\\<close>"], ["", "definition DFT :: \"nat => (nat => complex) => (nat => complex)\" where\n  \"DFT n a == (%i. \\<Sum>j=0..<n. (root n) ^ (i * j) * (a j))\""], ["", "definition IDFT :: \"nat => (nat => complex) => (nat => complex)\" where\n  \"IDFT n a == (%i. (\\<Sum>k=0..<n. (a k) / (root n) ^ (i * k)))\""], ["", "schematic_goal \"map (DFT 4 a) [0, 1, 2, 3] = ?x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (DFT 4 a) [0, 1, 2, 3] = ?x", "by(simp add: DFT_def Sum4)"], ["", "text \\<open>Lemmas for the correctness proof.\\<close>"], ["", "lemma DFT_lower:\n  \"DFT (2 * m) a i =\n  DFT m (%i. a (2 * i)) i +\n  (root (2 * m)) ^ i * DFT m (%i. a (2 * i + 1)) i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DFT (2 * m) a i =\n    DFT m (\\<lambda>i. a (2 * i)) i +\n    FFT.root (2 * m) ^ i * DFT m (\\<lambda>i. a (2 * i + 1)) i", "proof (unfold DFT_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>j = 0..<2 * m. FFT.root (2 * m) ^ (i * j) * a j) =\n    (\\<Sum>j = 0..<m. FFT.root m ^ (i * j) * a (2 * j)) +\n    FFT.root (2 * m) ^ i *\n    (\\<Sum>j = 0..<m. FFT.root m ^ (i * j) * a (2 * j + 1))", "have \"(\\<Sum>j = 0..<2 * m. root (2 * m) ^ (i * j) * a j) =\n    (\\<Sum>j = 0..<m. root (2 * m) ^ (i * (2 * j)) * a (2 * j)) +\n    (\\<Sum>j = 0..<m. root (2 * m) ^ (i * (2 * j + 1)) * a (2 * j + 1))\"\n    (is \"?s = _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j = 0..<2 * m. FFT.root (2 * m) ^ (i * j) * a j) =\n    (\\<Sum>j = 0..<m. FFT.root (2 * m) ^ (i * (2 * j)) * a (2 * j)) +\n    (\\<Sum>j = 0..<m. FFT.root (2 * m) ^ (i * (2 * j + 1)) * a (2 * j + 1))", "by (simp add: sum_splice)"], ["proof (state)\nthis:\n  (\\<Sum>j = 0..<2 * m. FFT.root (2 * m) ^ (i * j) * a j) =\n  (\\<Sum>j = 0..<m. FFT.root (2 * m) ^ (i * (2 * j)) * a (2 * j)) +\n  (\\<Sum>j = 0..<m. FFT.root (2 * m) ^ (i * (2 * j + 1)) * a (2 * j + 1))\n\ngoal (1 subgoal):\n 1. (\\<Sum>j = 0..<2 * m. FFT.root (2 * m) ^ (i * j) * a j) =\n    (\\<Sum>j = 0..<m. FFT.root m ^ (i * j) * a (2 * j)) +\n    FFT.root (2 * m) ^ i *\n    (\\<Sum>j = 0..<m. FFT.root m ^ (i * j) * a (2 * j + 1))", "also"], ["proof (state)\nthis:\n  (\\<Sum>j = 0..<2 * m. FFT.root (2 * m) ^ (i * j) * a j) =\n  (\\<Sum>j = 0..<m. FFT.root (2 * m) ^ (i * (2 * j)) * a (2 * j)) +\n  (\\<Sum>j = 0..<m. FFT.root (2 * m) ^ (i * (2 * j + 1)) * a (2 * j + 1))\n\ngoal (1 subgoal):\n 1. (\\<Sum>j = 0..<2 * m. FFT.root (2 * m) ^ (i * j) * a j) =\n    (\\<Sum>j = 0..<m. FFT.root m ^ (i * j) * a (2 * j)) +\n    FFT.root (2 * m) ^ i *\n    (\\<Sum>j = 0..<m. FFT.root m ^ (i * j) * a (2 * j + 1))", "have \"... = (\\<Sum>j = 0..<m. root m ^ (i * j) * a (2 * j)) +\n    root (2 * m) ^ i *\n    (\\<Sum>j = 0..<m. root m ^ (i * j) * a (2 * j + 1))\"\n    (is \"_ = ?t\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j = 0..<m. FFT.root (2 * m) ^ (i * (2 * j)) * a (2 * j)) +\n    (\\<Sum>j = 0..<m.\n        FFT.root (2 * m) ^ (i * (2 * j + 1)) * a (2 * j + 1)) =\n    (\\<Sum>j = 0..<m. FFT.root m ^ (i * j) * a (2 * j)) +\n    FFT.root (2 * m) ^ i *\n    (\\<Sum>j = 0..<m. FFT.root m ^ (i * j) * a (2 * j + 1))", "txt \\<open>First pair of sums\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j = 0..<m. FFT.root (2 * m) ^ (i * (2 * j)) * a (2 * j)) +\n    (\\<Sum>j = 0..<m.\n        FFT.root (2 * m) ^ (i * (2 * j + 1)) * a (2 * j + 1)) =\n    (\\<Sum>j = 0..<m. FFT.root m ^ (i * j) * a (2 * j)) +\n    FFT.root (2 * m) ^ i *\n    (\\<Sum>j = 0..<m. FFT.root m ^ (i * j) * a (2 * j + 1))", "apply (simp add: root_cancel1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j = 0..<m.\n        FFT.root (2 * m) ^ (i + i * (2 * j)) * a (Suc (2 * j))) =\n    FFT.root (2 * m) ^ i *\n    (\\<Sum>j = 0..<m. FFT.root m ^ (i * j) * a (Suc (2 * j)))", "txt \\<open>Second pair of sums\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j = 0..<m.\n        FFT.root (2 * m) ^ (i + i * (2 * j)) * a (Suc (2 * j))) =\n    FFT.root (2 * m) ^ i *\n    (\\<Sum>j = 0..<m. FFT.root m ^ (i * j) * a (Suc (2 * j)))", "apply (simp add: sum_distrib_left)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j = 0..<m.\n        FFT.root (2 * m) ^ (i + i * (2 * j)) * a (Suc (2 * j))) =\n    (\\<Sum>n = 0..<m.\n        FFT.root (2 * m) ^ i * (FFT.root m ^ (i * n) * a (Suc (2 * n))))", "apply (simp add: power_add)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j = 0..<m.\n        FFT.root (2 * m) ^ i * FFT.root (2 * m) ^ (i * (2 * j)) *\n        a (Suc (2 * j))) =\n    (\\<Sum>n = 0..<m.\n        FFT.root (2 * m) ^ i * (FFT.root m ^ (i * n) * a (Suc (2 * n))))", "apply (simp add: root_cancel1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j = 0..<m.\n        FFT.root (2 * m) ^ i * FFT.root m ^ (i * j) * a (Suc (2 * j))) =\n    (\\<Sum>n = 0..<m.\n        FFT.root (2 * m) ^ i * (FFT.root m ^ (i * n) * a (Suc (2 * n))))", "apply (simp add: ac_simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (\\<Sum>j = 0..<m. FFT.root (2 * m) ^ (i * (2 * j)) * a (2 * j)) +\n  (\\<Sum>j = 0..<m. FFT.root (2 * m) ^ (i * (2 * j + 1)) * a (2 * j + 1)) =\n  (\\<Sum>j = 0..<m. FFT.root m ^ (i * j) * a (2 * j)) +\n  FFT.root (2 * m) ^ i *\n  (\\<Sum>j = 0..<m. FFT.root m ^ (i * j) * a (2 * j + 1))\n\ngoal (1 subgoal):\n 1. (\\<Sum>j = 0..<2 * m. FFT.root (2 * m) ^ (i * j) * a j) =\n    (\\<Sum>j = 0..<m. FFT.root m ^ (i * j) * a (2 * j)) +\n    FFT.root (2 * m) ^ i *\n    (\\<Sum>j = 0..<m. FFT.root m ^ (i * j) * a (2 * j + 1))", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>j = 0..<2 * m. FFT.root (2 * m) ^ (i * j) * a j) =\n  (\\<Sum>j = 0..<m. FFT.root m ^ (i * j) * a (2 * j)) +\n  FFT.root (2 * m) ^ i *\n  (\\<Sum>j = 0..<m. FFT.root m ^ (i * j) * a (2 * j + 1))", "show \"?s = ?t\""], ["proof (prove)\nusing this:\n  (\\<Sum>j = 0..<2 * m. FFT.root (2 * m) ^ (i * j) * a j) =\n  (\\<Sum>j = 0..<m. FFT.root m ^ (i * j) * a (2 * j)) +\n  FFT.root (2 * m) ^ i *\n  (\\<Sum>j = 0..<m. FFT.root m ^ (i * j) * a (2 * j + 1))\n\ngoal (1 subgoal):\n 1. (\\<Sum>j = 0..<2 * m. FFT.root (2 * m) ^ (i * j) * a j) =\n    (\\<Sum>j = 0..<m. FFT.root m ^ (i * j) * a (2 * j)) +\n    FFT.root (2 * m) ^ i *\n    (\\<Sum>j = 0..<m. FFT.root m ^ (i * j) * a (2 * j + 1))", "."], ["proof (state)\nthis:\n  (\\<Sum>j = 0..<2 * m. FFT.root (2 * m) ^ (i * j) * a j) =\n  (\\<Sum>j = 0..<m. FFT.root m ^ (i * j) * a (2 * j)) +\n  FFT.root (2 * m) ^ i *\n  (\\<Sum>j = 0..<m. FFT.root m ^ (i * j) * a (2 * j + 1))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma DFT_upper:\n  assumes mbound: \"0 < m\" and ibound: \"m <= i\"\n  shows \"DFT (2 * m) a i =\n    DFT m (%i. a (2 * i)) (i - m) -\n    root (2 * m) ^ (i - m) * DFT m (%i. a (2 * i + 1)) (i - m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DFT (2 * m) a i =\n    DFT m (\\<lambda>i. a (2 * i)) (i - m) -\n    FFT.root (2 * m) ^ (i - m) * DFT m (\\<lambda>i. a (2 * i + 1)) (i - m)", "proof (unfold DFT_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>j = 0..<2 * m. FFT.root (2 * m) ^ (i * j) * a j) =\n    (\\<Sum>j = 0..<m. FFT.root m ^ ((i - m) * j) * a (2 * j)) -\n    FFT.root (2 * m) ^ (i - m) *\n    (\\<Sum>j = 0..<m. FFT.root m ^ ((i - m) * j) * a (2 * j + 1))", "have \"(\\<Sum>j = 0..<2 * m. root (2 * m) ^ (i * j) * a j) =\n    (\\<Sum>j = 0..<m. root (2 * m) ^ (i * (2 * j)) * a (2 * j)) +\n    (\\<Sum>j = 0..<m. root (2 * m) ^ (i * (2 * j + 1)) * a (2 * j + 1))\"\n    (is \"?s = _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j = 0..<2 * m. FFT.root (2 * m) ^ (i * j) * a j) =\n    (\\<Sum>j = 0..<m. FFT.root (2 * m) ^ (i * (2 * j)) * a (2 * j)) +\n    (\\<Sum>j = 0..<m. FFT.root (2 * m) ^ (i * (2 * j + 1)) * a (2 * j + 1))", "by (simp add: sum_splice)"], ["proof (state)\nthis:\n  (\\<Sum>j = 0..<2 * m. FFT.root (2 * m) ^ (i * j) * a j) =\n  (\\<Sum>j = 0..<m. FFT.root (2 * m) ^ (i * (2 * j)) * a (2 * j)) +\n  (\\<Sum>j = 0..<m. FFT.root (2 * m) ^ (i * (2 * j + 1)) * a (2 * j + 1))\n\ngoal (1 subgoal):\n 1. (\\<Sum>j = 0..<2 * m. FFT.root (2 * m) ^ (i * j) * a j) =\n    (\\<Sum>j = 0..<m. FFT.root m ^ ((i - m) * j) * a (2 * j)) -\n    FFT.root (2 * m) ^ (i - m) *\n    (\\<Sum>j = 0..<m. FFT.root m ^ ((i - m) * j) * a (2 * j + 1))", "also"], ["proof (state)\nthis:\n  (\\<Sum>j = 0..<2 * m. FFT.root (2 * m) ^ (i * j) * a j) =\n  (\\<Sum>j = 0..<m. FFT.root (2 * m) ^ (i * (2 * j)) * a (2 * j)) +\n  (\\<Sum>j = 0..<m. FFT.root (2 * m) ^ (i * (2 * j + 1)) * a (2 * j + 1))\n\ngoal (1 subgoal):\n 1. (\\<Sum>j = 0..<2 * m. FFT.root (2 * m) ^ (i * j) * a j) =\n    (\\<Sum>j = 0..<m. FFT.root m ^ ((i - m) * j) * a (2 * j)) -\n    FFT.root (2 * m) ^ (i - m) *\n    (\\<Sum>j = 0..<m. FFT.root m ^ ((i - m) * j) * a (2 * j + 1))", "have \"... =\n    (\\<Sum>j = 0..<m. root m ^ ((i - m) * j) * a (2 * j)) -\n    root (2 * m) ^ (i - m) *\n    (\\<Sum>j = 0..<m. root m ^ ((i - m) * j) * a (2 * j + 1))\"\n    (is \"_ = ?t\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j = 0..<m. FFT.root (2 * m) ^ (i * (2 * j)) * a (2 * j)) +\n    (\\<Sum>j = 0..<m.\n        FFT.root (2 * m) ^ (i * (2 * j + 1)) * a (2 * j + 1)) =\n    (\\<Sum>j = 0..<m. FFT.root m ^ ((i - m) * j) * a (2 * j)) -\n    FFT.root (2 * m) ^ (i - m) *\n    (\\<Sum>j = 0..<m. FFT.root m ^ ((i - m) * j) * a (2 * j + 1))", "txt \\<open>First pair of sums\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j = 0..<m. FFT.root (2 * m) ^ (i * (2 * j)) * a (2 * j)) +\n    (\\<Sum>j = 0..<m.\n        FFT.root (2 * m) ^ (i * (2 * j + 1)) * a (2 * j + 1)) =\n    (\\<Sum>j = 0..<m. FFT.root m ^ ((i - m) * j) * a (2 * j)) -\n    FFT.root (2 * m) ^ (i - m) *\n    (\\<Sum>j = 0..<m. FFT.root m ^ ((i - m) * j) * a (2 * j + 1))", "apply (simp add: root_cancel1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j = 0..<m. FFT.root m ^ (i * j) * a (2 * j)) +\n    (\\<Sum>j = 0..<m.\n        FFT.root (2 * m) ^ (i + i * (2 * j)) * a (Suc (2 * j))) =\n    (\\<Sum>j = 0..<m. FFT.root m ^ ((i - m) * j) * a (2 * j)) -\n    FFT.root (2 * m) ^ (i - m) *\n    (\\<Sum>j = 0..<m. FFT.root m ^ ((i - m) * j) * a (Suc (2 * j)))", "apply (simp add: root_unity ibound root_nonzero power_diff power_mult)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j = 0..<m.\n        FFT.root (2 * m) ^ (i + i * (2 * j)) * a (Suc (2 * j))) =\n    - (FFT.root (2 * m) ^ i *\n       (\\<Sum>j = 0..<m. (FFT.root m ^ i) ^ j * a (Suc (2 * j))) /\n       FFT.root (2 * m) ^ m)", "txt \\<open>Second pair of sums\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j = 0..<m.\n        FFT.root (2 * m) ^ (i + i * (2 * j)) * a (Suc (2 * j))) =\n    - (FFT.root (2 * m) ^ i *\n       (\\<Sum>j = 0..<m. (FFT.root m ^ i) ^ j * a (Suc (2 * j))) /\n       FFT.root (2 * m) ^ m)", "apply (simp add: mbound root_cancel2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j = 0..<m.\n        FFT.root (2 * m) ^ (i + i * (2 * j)) * a (Suc (2 * j))) =\n    FFT.root (2 * m) ^ i *\n    (\\<Sum>j = 0..<m. (FFT.root m ^ i) ^ j * a (Suc (2 * j)))", "apply (simp add: sum_distrib_left)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j = 0..<m.\n        FFT.root (2 * m) ^ (i + i * (2 * j)) * a (Suc (2 * j))) =\n    (\\<Sum>n = 0..<m.\n        FFT.root (2 * m) ^ i * ((FFT.root m ^ i) ^ n * a (Suc (2 * n))))", "apply (simp add: power_add)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j = 0..<m.\n        FFT.root (2 * m) ^ i * FFT.root (2 * m) ^ (i * (2 * j)) *\n        a (Suc (2 * j))) =\n    (\\<Sum>n = 0..<m.\n        FFT.root (2 * m) ^ i * ((FFT.root m ^ i) ^ n * a (Suc (2 * n))))", "apply (simp add: root_cancel1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j = 0..<m.\n        FFT.root (2 * m) ^ i * FFT.root m ^ (i * j) * a (Suc (2 * j))) =\n    (\\<Sum>n = 0..<m.\n        FFT.root (2 * m) ^ i * ((FFT.root m ^ i) ^ n * a (Suc (2 * n))))", "apply (simp add: power_mult)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j = 0..<m.\n        FFT.root (2 * m) ^ i * (FFT.root m ^ i) ^ j * a (Suc (2 * j))) =\n    (\\<Sum>n = 0..<m.\n        FFT.root (2 * m) ^ i * ((FFT.root m ^ i) ^ n * a (Suc (2 * n))))", "apply (simp add: ac_simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (\\<Sum>j = 0..<m. FFT.root (2 * m) ^ (i * (2 * j)) * a (2 * j)) +\n  (\\<Sum>j = 0..<m. FFT.root (2 * m) ^ (i * (2 * j + 1)) * a (2 * j + 1)) =\n  (\\<Sum>j = 0..<m. FFT.root m ^ ((i - m) * j) * a (2 * j)) -\n  FFT.root (2 * m) ^ (i - m) *\n  (\\<Sum>j = 0..<m. FFT.root m ^ ((i - m) * j) * a (2 * j + 1))\n\ngoal (1 subgoal):\n 1. (\\<Sum>j = 0..<2 * m. FFT.root (2 * m) ^ (i * j) * a j) =\n    (\\<Sum>j = 0..<m. FFT.root m ^ ((i - m) * j) * a (2 * j)) -\n    FFT.root (2 * m) ^ (i - m) *\n    (\\<Sum>j = 0..<m. FFT.root m ^ ((i - m) * j) * a (2 * j + 1))", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>j = 0..<2 * m. FFT.root (2 * m) ^ (i * j) * a j) =\n  (\\<Sum>j = 0..<m. FFT.root m ^ ((i - m) * j) * a (2 * j)) -\n  FFT.root (2 * m) ^ (i - m) *\n  (\\<Sum>j = 0..<m. FFT.root m ^ ((i - m) * j) * a (2 * j + 1))", "show \"?s = ?t\""], ["proof (prove)\nusing this:\n  (\\<Sum>j = 0..<2 * m. FFT.root (2 * m) ^ (i * j) * a j) =\n  (\\<Sum>j = 0..<m. FFT.root m ^ ((i - m) * j) * a (2 * j)) -\n  FFT.root (2 * m) ^ (i - m) *\n  (\\<Sum>j = 0..<m. FFT.root m ^ ((i - m) * j) * a (2 * j + 1))\n\ngoal (1 subgoal):\n 1. (\\<Sum>j = 0..<2 * m. FFT.root (2 * m) ^ (i * j) * a j) =\n    (\\<Sum>j = 0..<m. FFT.root m ^ ((i - m) * j) * a (2 * j)) -\n    FFT.root (2 * m) ^ (i - m) *\n    (\\<Sum>j = 0..<m. FFT.root m ^ ((i - m) * j) * a (2 * j + 1))", "."], ["proof (state)\nthis:\n  (\\<Sum>j = 0..<2 * m. FFT.root (2 * m) ^ (i * j) * a j) =\n  (\\<Sum>j = 0..<m. FFT.root m ^ ((i - m) * j) * a (2 * j)) -\n  FFT.root (2 * m) ^ (i - m) *\n  (\\<Sum>j = 0..<m. FFT.root m ^ ((i - m) * j) * a (2 * j + 1))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma IDFT_lower:\n  \"IDFT (2 * m) a i =\n  IDFT m (%i. a (2 * i)) i +\n  (1 / root (2 * m)) ^ i * IDFT m (%i. a (2 * i + 1)) i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. IDFT (2 * m) a i =\n    IDFT m (\\<lambda>i. a (2 * i)) i +\n    (1 / FFT.root (2 * m)) ^ i * IDFT m (\\<lambda>i. a (2 * i + 1)) i", "proof (unfold IDFT_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>k = 0..<2 * m. a k / FFT.root (2 * m) ^ (i * k)) =\n    (\\<Sum>k = 0..<m. a (2 * k) / FFT.root m ^ (i * k)) +\n    (1 / FFT.root (2 * m)) ^ i *\n    (\\<Sum>k = 0..<m. a (2 * k + 1) / FFT.root m ^ (i * k))", "have \"(\\<Sum>j = 0..<2 * m. a j / root (2 * m) ^ (i * j)) =\n    (\\<Sum>j = 0..<m. a (2 * j) / root (2 * m) ^ (i * (2 * j))) +\n    (\\<Sum>j = 0..<m. a (2 * j + 1) / root (2 * m) ^ (i * (2 * j + 1)))\"\n    (is \"?s = _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j = 0..<2 * m. a j / FFT.root (2 * m) ^ (i * j)) =\n    (\\<Sum>j = 0..<m. a (2 * j) / FFT.root (2 * m) ^ (i * (2 * j))) +\n    (\\<Sum>j = 0..<m. a (2 * j + 1) / FFT.root (2 * m) ^ (i * (2 * j + 1)))", "by (simp add: sum_splice)"], ["proof (state)\nthis:\n  (\\<Sum>j = 0..<2 * m. a j / FFT.root (2 * m) ^ (i * j)) =\n  (\\<Sum>j = 0..<m. a (2 * j) / FFT.root (2 * m) ^ (i * (2 * j))) +\n  (\\<Sum>j = 0..<m. a (2 * j + 1) / FFT.root (2 * m) ^ (i * (2 * j + 1)))\n\ngoal (1 subgoal):\n 1. (\\<Sum>k = 0..<2 * m. a k / FFT.root (2 * m) ^ (i * k)) =\n    (\\<Sum>k = 0..<m. a (2 * k) / FFT.root m ^ (i * k)) +\n    (1 / FFT.root (2 * m)) ^ i *\n    (\\<Sum>k = 0..<m. a (2 * k + 1) / FFT.root m ^ (i * k))", "also"], ["proof (state)\nthis:\n  (\\<Sum>j = 0..<2 * m. a j / FFT.root (2 * m) ^ (i * j)) =\n  (\\<Sum>j = 0..<m. a (2 * j) / FFT.root (2 * m) ^ (i * (2 * j))) +\n  (\\<Sum>j = 0..<m. a (2 * j + 1) / FFT.root (2 * m) ^ (i * (2 * j + 1)))\n\ngoal (1 subgoal):\n 1. (\\<Sum>k = 0..<2 * m. a k / FFT.root (2 * m) ^ (i * k)) =\n    (\\<Sum>k = 0..<m. a (2 * k) / FFT.root m ^ (i * k)) +\n    (1 / FFT.root (2 * m)) ^ i *\n    (\\<Sum>k = 0..<m. a (2 * k + 1) / FFT.root m ^ (i * k))", "have \"... = (\\<Sum>j = 0..<m. a (2 * j) / root m ^ (i * j)) +\n    (1 / root (2 * m)) ^ i *\n    (\\<Sum>j = 0..<m. a (2 * j + 1) / root m ^ (i * j))\"\n    (is \"_ = ?t\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j = 0..<m. a (2 * j) / FFT.root (2 * m) ^ (i * (2 * j))) +\n    (\\<Sum>j = 0..<m.\n        a (2 * j + 1) / FFT.root (2 * m) ^ (i * (2 * j + 1))) =\n    (\\<Sum>j = 0..<m. a (2 * j) / FFT.root m ^ (i * j)) +\n    (1 / FFT.root (2 * m)) ^ i *\n    (\\<Sum>j = 0..<m. a (2 * j + 1) / FFT.root m ^ (i * j))", "txt \\<open>First pair of sums\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j = 0..<m. a (2 * j) / FFT.root (2 * m) ^ (i * (2 * j))) +\n    (\\<Sum>j = 0..<m.\n        a (2 * j + 1) / FFT.root (2 * m) ^ (i * (2 * j + 1))) =\n    (\\<Sum>j = 0..<m. a (2 * j) / FFT.root m ^ (i * j)) +\n    (1 / FFT.root (2 * m)) ^ i *\n    (\\<Sum>j = 0..<m. a (2 * j + 1) / FFT.root m ^ (i * j))", "apply (simp add: root_cancel1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j = 0..<m.\n        a (Suc (2 * j)) / FFT.root (2 * m) ^ (i + i * (2 * j))) =\n    (1 / FFT.root (2 * m)) ^ i *\n    (\\<Sum>j = 0..<m. a (Suc (2 * j)) / FFT.root m ^ (i * j))", "txt \\<open>Second pair of sums\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j = 0..<m.\n        a (Suc (2 * j)) / FFT.root (2 * m) ^ (i + i * (2 * j))) =\n    (1 / FFT.root (2 * m)) ^ i *\n    (\\<Sum>j = 0..<m. a (Suc (2 * j)) / FFT.root m ^ (i * j))", "apply (simp add: sum_distrib_left)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j = 0..<m.\n        a (Suc (2 * j)) / FFT.root (2 * m) ^ (i + i * (2 * j))) =\n    (\\<Sum>n = 0..<m.\n        (1 / FFT.root (2 * m)) ^ i * a (Suc (2 * n)) / FFT.root m ^ (i * n))", "apply (simp add: power_add)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j = 0..<m.\n        a (Suc (2 * j)) /\n        (FFT.root (2 * m) ^ i * FFT.root (2 * m) ^ (i * (2 * j)))) =\n    (\\<Sum>n = 0..<m.\n        (1 / FFT.root (2 * m)) ^ i * a (Suc (2 * n)) / FFT.root m ^ (i * n))", "apply (simp add: power_divide root_nonzero)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j = 0..<m.\n        a (Suc (2 * j)) /\n        (FFT.root (2 * m) ^ i * FFT.root (2 * m) ^ (i * (2 * j)))) =\n    (\\<Sum>n = 0..<m.\n        a (Suc (2 * n)) / (FFT.root (2 * m) ^ i * FFT.root m ^ (i * n)))", "apply (simp add: root_cancel1)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (\\<Sum>j = 0..<m. a (2 * j) / FFT.root (2 * m) ^ (i * (2 * j))) +\n  (\\<Sum>j = 0..<m. a (2 * j + 1) / FFT.root (2 * m) ^ (i * (2 * j + 1))) =\n  (\\<Sum>j = 0..<m. a (2 * j) / FFT.root m ^ (i * j)) +\n  (1 / FFT.root (2 * m)) ^ i *\n  (\\<Sum>j = 0..<m. a (2 * j + 1) / FFT.root m ^ (i * j))\n\ngoal (1 subgoal):\n 1. (\\<Sum>k = 0..<2 * m. a k / FFT.root (2 * m) ^ (i * k)) =\n    (\\<Sum>k = 0..<m. a (2 * k) / FFT.root m ^ (i * k)) +\n    (1 / FFT.root (2 * m)) ^ i *\n    (\\<Sum>k = 0..<m. a (2 * k + 1) / FFT.root m ^ (i * k))", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>j = 0..<2 * m. a j / FFT.root (2 * m) ^ (i * j)) =\n  (\\<Sum>j = 0..<m. a (2 * j) / FFT.root m ^ (i * j)) +\n  (1 / FFT.root (2 * m)) ^ i *\n  (\\<Sum>j = 0..<m. a (2 * j + 1) / FFT.root m ^ (i * j))", "show \"?s = ?t\""], ["proof (prove)\nusing this:\n  (\\<Sum>j = 0..<2 * m. a j / FFT.root (2 * m) ^ (i * j)) =\n  (\\<Sum>j = 0..<m. a (2 * j) / FFT.root m ^ (i * j)) +\n  (1 / FFT.root (2 * m)) ^ i *\n  (\\<Sum>j = 0..<m. a (2 * j + 1) / FFT.root m ^ (i * j))\n\ngoal (1 subgoal):\n 1. (\\<Sum>j = 0..<2 * m. a j / FFT.root (2 * m) ^ (i * j)) =\n    (\\<Sum>j = 0..<m. a (2 * j) / FFT.root m ^ (i * j)) +\n    (1 / FFT.root (2 * m)) ^ i *\n    (\\<Sum>j = 0..<m. a (2 * j + 1) / FFT.root m ^ (i * j))", "."], ["proof (state)\nthis:\n  (\\<Sum>j = 0..<2 * m. a j / FFT.root (2 * m) ^ (i * j)) =\n  (\\<Sum>j = 0..<m. a (2 * j) / FFT.root m ^ (i * j)) +\n  (1 / FFT.root (2 * m)) ^ i *\n  (\\<Sum>j = 0..<m. a (2 * j + 1) / FFT.root m ^ (i * j))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma IDFT_upper:\n  assumes mbound: \"0 < m\" and ibound: \"m <= i\"\n  shows \"IDFT (2 * m) a i =\n    IDFT m (%i. a (2 * i)) (i - m) -\n    (1 / root (2 * m)) ^ (i - m) *\n    IDFT m (%i. a (2 * i + 1)) (i - m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. IDFT (2 * m) a i =\n    IDFT m (\\<lambda>i. a (2 * i)) (i - m) -\n    (1 / FFT.root (2 * m)) ^ (i - m) *\n    IDFT m (\\<lambda>i. a (2 * i + 1)) (i - m)", "proof (unfold IDFT_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>k = 0..<2 * m. a k / FFT.root (2 * m) ^ (i * k)) =\n    (\\<Sum>k = 0..<m. a (2 * k) / FFT.root m ^ ((i - m) * k)) -\n    (1 / FFT.root (2 * m)) ^ (i - m) *\n    (\\<Sum>k = 0..<m. a (2 * k + 1) / FFT.root m ^ ((i - m) * k))", "have \"(\\<Sum>j = 0..<2 * m. a j / root (2 * m) ^ (i * j)) =\n    (\\<Sum>j = 0..<m. a (2 * j) / root (2 * m) ^ (i * (2 * j))) +\n    (\\<Sum>j = 0..<m. a (2 * j + 1) / root (2 * m) ^ (i * (2 * j + 1)))\"\n    (is \"?s = _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j = 0..<2 * m. a j / FFT.root (2 * m) ^ (i * j)) =\n    (\\<Sum>j = 0..<m. a (2 * j) / FFT.root (2 * m) ^ (i * (2 * j))) +\n    (\\<Sum>j = 0..<m. a (2 * j + 1) / FFT.root (2 * m) ^ (i * (2 * j + 1)))", "by (simp add: sum_splice)"], ["proof (state)\nthis:\n  (\\<Sum>j = 0..<2 * m. a j / FFT.root (2 * m) ^ (i * j)) =\n  (\\<Sum>j = 0..<m. a (2 * j) / FFT.root (2 * m) ^ (i * (2 * j))) +\n  (\\<Sum>j = 0..<m. a (2 * j + 1) / FFT.root (2 * m) ^ (i * (2 * j + 1)))\n\ngoal (1 subgoal):\n 1. (\\<Sum>k = 0..<2 * m. a k / FFT.root (2 * m) ^ (i * k)) =\n    (\\<Sum>k = 0..<m. a (2 * k) / FFT.root m ^ ((i - m) * k)) -\n    (1 / FFT.root (2 * m)) ^ (i - m) *\n    (\\<Sum>k = 0..<m. a (2 * k + 1) / FFT.root m ^ ((i - m) * k))", "also"], ["proof (state)\nthis:\n  (\\<Sum>j = 0..<2 * m. a j / FFT.root (2 * m) ^ (i * j)) =\n  (\\<Sum>j = 0..<m. a (2 * j) / FFT.root (2 * m) ^ (i * (2 * j))) +\n  (\\<Sum>j = 0..<m. a (2 * j + 1) / FFT.root (2 * m) ^ (i * (2 * j + 1)))\n\ngoal (1 subgoal):\n 1. (\\<Sum>k = 0..<2 * m. a k / FFT.root (2 * m) ^ (i * k)) =\n    (\\<Sum>k = 0..<m. a (2 * k) / FFT.root m ^ ((i - m) * k)) -\n    (1 / FFT.root (2 * m)) ^ (i - m) *\n    (\\<Sum>k = 0..<m. a (2 * k + 1) / FFT.root m ^ ((i - m) * k))", "have \"... =\n    (\\<Sum>j = 0..<m. a (2 * j) / root m ^ ((i - m) * j)) -\n    (1 / root (2 * m)) ^ (i - m) *\n    (\\<Sum>j = 0..<m. a (2 * j + 1) / root m ^ ((i - m) * j))\"\n    (is \"_ = ?t\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j = 0..<m. a (2 * j) / FFT.root (2 * m) ^ (i * (2 * j))) +\n    (\\<Sum>j = 0..<m.\n        a (2 * j + 1) / FFT.root (2 * m) ^ (i * (2 * j + 1))) =\n    (\\<Sum>j = 0..<m. a (2 * j) / FFT.root m ^ ((i - m) * j)) -\n    (1 / FFT.root (2 * m)) ^ (i - m) *\n    (\\<Sum>j = 0..<m. a (2 * j + 1) / FFT.root m ^ ((i - m) * j))", "txt \\<open>First pair of sums\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j = 0..<m. a (2 * j) / FFT.root (2 * m) ^ (i * (2 * j))) +\n    (\\<Sum>j = 0..<m.\n        a (2 * j + 1) / FFT.root (2 * m) ^ (i * (2 * j + 1))) =\n    (\\<Sum>j = 0..<m. a (2 * j) / FFT.root m ^ ((i - m) * j)) -\n    (1 / FFT.root (2 * m)) ^ (i - m) *\n    (\\<Sum>j = 0..<m. a (2 * j + 1) / FFT.root m ^ ((i - m) * j))", "apply (simp add: root_cancel1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j = 0..<m. a (2 * j) / FFT.root m ^ (i * j)) +\n    (\\<Sum>j = 0..<m.\n        a (Suc (2 * j)) / FFT.root (2 * m) ^ (i + i * (2 * j))) =\n    (\\<Sum>j = 0..<m. a (2 * j) / FFT.root m ^ ((i - m) * j)) -\n    (1 / FFT.root (2 * m)) ^ (i - m) *\n    (\\<Sum>j = 0..<m. a (Suc (2 * j)) / FFT.root m ^ ((i - m) * j))", "apply (simp add: root_unity ibound root_nonzero power_diff power_mult)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j = 0..<m.\n        a (Suc (2 * j)) / FFT.root (2 * m) ^ (i + i * (2 * j))) =\n    - ((1 / FFT.root (2 * m)) ^ i *\n       (\\<Sum>j = 0..<m. a (Suc (2 * j)) / (FFT.root m ^ i) ^ j) /\n       (1 / FFT.root (2 * m)) ^ m)", "txt \\<open>Second pair of sums\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j = 0..<m.\n        a (Suc (2 * j)) / FFT.root (2 * m) ^ (i + i * (2 * j))) =\n    - ((1 / FFT.root (2 * m)) ^ i *\n       (\\<Sum>j = 0..<m. a (Suc (2 * j)) / (FFT.root m ^ i) ^ j) /\n       (1 / FFT.root (2 * m)) ^ m)", "apply (simp add: power_divide root_nonzero)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j = 0..<m.\n        a (Suc (2 * j)) / FFT.root (2 * m) ^ (i + i * (2 * j))) =\n    - ((\\<Sum>j = 0..<m. a (Suc (2 * j)) / (FFT.root m ^ i) ^ j) *\n       FFT.root (2 * m) ^ m /\n       FFT.root (2 * m) ^ i)", "apply (simp add: mbound root_cancel2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j = 0..<m.\n        a (Suc (2 * j)) / FFT.root (2 * m) ^ (i + i * (2 * j))) =\n    (\\<Sum>j = 0..<m. a (Suc (2 * j)) / (FFT.root m ^ i) ^ j) /\n    FFT.root (2 * m) ^ i", "apply (simp add: sum_divide_distrib)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j = 0..<m.\n        a (Suc (2 * j)) / FFT.root (2 * m) ^ (i + i * (2 * j))) =\n    (\\<Sum>n = 0..<m.\n        a (Suc (2 * n)) / ((FFT.root m ^ i) ^ n * FFT.root (2 * m) ^ i))", "apply (simp add: power_add)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j = 0..<m.\n        a (Suc (2 * j)) /\n        (FFT.root (2 * m) ^ i * FFT.root (2 * m) ^ (i * (2 * j)))) =\n    (\\<Sum>n = 0..<m.\n        a (Suc (2 * n)) / ((FFT.root m ^ i) ^ n * FFT.root (2 * m) ^ i))", "apply (simp add: root_cancel1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j = 0..<m.\n        a (Suc (2 * j)) / (FFT.root (2 * m) ^ i * FFT.root m ^ (i * j))) =\n    (\\<Sum>n = 0..<m.\n        a (Suc (2 * n)) / ((FFT.root m ^ i) ^ n * FFT.root (2 * m) ^ i))", "apply (simp add: power_mult)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j = 0..<m.\n        a (Suc (2 * j)) / (FFT.root (2 * m) ^ i * (FFT.root m ^ i) ^ j)) =\n    (\\<Sum>n = 0..<m.\n        a (Suc (2 * n)) / ((FFT.root m ^ i) ^ n * FFT.root (2 * m) ^ i))", "apply (simp add: ac_simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (\\<Sum>j = 0..<m. a (2 * j) / FFT.root (2 * m) ^ (i * (2 * j))) +\n  (\\<Sum>j = 0..<m. a (2 * j + 1) / FFT.root (2 * m) ^ (i * (2 * j + 1))) =\n  (\\<Sum>j = 0..<m. a (2 * j) / FFT.root m ^ ((i - m) * j)) -\n  (1 / FFT.root (2 * m)) ^ (i - m) *\n  (\\<Sum>j = 0..<m. a (2 * j + 1) / FFT.root m ^ ((i - m) * j))\n\ngoal (1 subgoal):\n 1. (\\<Sum>k = 0..<2 * m. a k / FFT.root (2 * m) ^ (i * k)) =\n    (\\<Sum>k = 0..<m. a (2 * k) / FFT.root m ^ ((i - m) * k)) -\n    (1 / FFT.root (2 * m)) ^ (i - m) *\n    (\\<Sum>k = 0..<m. a (2 * k + 1) / FFT.root m ^ ((i - m) * k))", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>j = 0..<2 * m. a j / FFT.root (2 * m) ^ (i * j)) =\n  (\\<Sum>j = 0..<m. a (2 * j) / FFT.root m ^ ((i - m) * j)) -\n  (1 / FFT.root (2 * m)) ^ (i - m) *\n  (\\<Sum>j = 0..<m. a (2 * j + 1) / FFT.root m ^ ((i - m) * j))", "show \"?s = ?t\""], ["proof (prove)\nusing this:\n  (\\<Sum>j = 0..<2 * m. a j / FFT.root (2 * m) ^ (i * j)) =\n  (\\<Sum>j = 0..<m. a (2 * j) / FFT.root m ^ ((i - m) * j)) -\n  (1 / FFT.root (2 * m)) ^ (i - m) *\n  (\\<Sum>j = 0..<m. a (2 * j + 1) / FFT.root m ^ ((i - m) * j))\n\ngoal (1 subgoal):\n 1. (\\<Sum>j = 0..<2 * m. a j / FFT.root (2 * m) ^ (i * j)) =\n    (\\<Sum>j = 0..<m. a (2 * j) / FFT.root m ^ ((i - m) * j)) -\n    (1 / FFT.root (2 * m)) ^ (i - m) *\n    (\\<Sum>j = 0..<m. a (2 * j + 1) / FFT.root m ^ ((i - m) * j))", "."], ["proof (state)\nthis:\n  (\\<Sum>j = 0..<2 * m. a j / FFT.root (2 * m) ^ (i * j)) =\n  (\\<Sum>j = 0..<m. a (2 * j) / FFT.root m ^ ((i - m) * j)) -\n  (1 / FFT.root (2 * m)) ^ (i - m) *\n  (\\<Sum>j = 0..<m. a (2 * j + 1) / FFT.root m ^ ((i - m) * j))\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\\<open>DFT\\<close> und \\<open>IDFT\\<close> are inverses.\\<close>"], ["", "declare divide_divide_eq_right [simp del]\n  divide_divide_eq_left [simp del]"], ["", "lemma power_diff_inverse:\n  assumes nz: \"(a::'a::field) ~= 0\"\n  shows \"m <= n ==> (inverse a) ^ (n-m) = (a^m) / (a^n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<le> n \\<Longrightarrow> inverse a ^ (n - m) = a ^ m / a ^ n", "apply (induct n m rule: diff_induct)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x. 0 \\<le> x \\<Longrightarrow> inverse a ^ (x - 0) = a ^ 0 / a ^ x\n 2. \\<And>y.\n       Suc y \\<le> 0 \\<Longrightarrow>\n       inverse a ^ (0 - Suc y) = a ^ Suc y / a ^ 0\n 3. \\<And>x y.\n       \\<lbrakk>y \\<le> x \\<Longrightarrow>\n                inverse a ^ (x - y) = a ^ y / a ^ x;\n        Suc y \\<le> Suc x\\<rbrakk>\n       \\<Longrightarrow> inverse a ^ (Suc x - Suc y) = a ^ Suc y / a ^ Suc x", "apply (simp add: power_inverse\n      nonzero_inverse_eq_divide [THEN sym] nz)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>y.\n       Suc y \\<le> 0 \\<Longrightarrow>\n       inverse a ^ (0 - Suc y) = a ^ Suc y / a ^ 0\n 2. \\<And>x y.\n       \\<lbrakk>y \\<le> x \\<Longrightarrow>\n                inverse a ^ (x - y) = a ^ y / a ^ x;\n        Suc y \\<le> Suc x\\<rbrakk>\n       \\<Longrightarrow> inverse a ^ (Suc x - Suc y) = a ^ Suc y / a ^ Suc x", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>y \\<le> x \\<Longrightarrow>\n                inverse a ^ (x - y) = a ^ y / a ^ x;\n        Suc y \\<le> Suc x\\<rbrakk>\n       \\<Longrightarrow> inverse a ^ (Suc x - Suc y) = a ^ Suc y / a ^ Suc x", "apply (simp add: nz)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma power_diff_rev_if:\n  assumes nz: \"(a::'a::field) ~= 0\"\n  shows \"(a^m) / (a^n) = (if n <= m then a ^ (m-n) else (1/a) ^ (n-m))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a ^ m / a ^ n =\n    (if n \\<le> m then a ^ (m - n) else ((1::'a) / a) ^ (n - m))", "proof (cases \"n <= m\")"], ["proof (state)\ngoal (2 subgoals):\n 1. n \\<le> m \\<Longrightarrow>\n    a ^ m / a ^ n =\n    (if n \\<le> m then a ^ (m - n) else ((1::'a) / a) ^ (n - m))\n 2. \\<not> n \\<le> m \\<Longrightarrow>\n    a ^ m / a ^ n =\n    (if n \\<le> m then a ^ (m - n) else ((1::'a) / a) ^ (n - m))", "case True"], ["proof (state)\nthis:\n  n \\<le> m\n\ngoal (2 subgoals):\n 1. n \\<le> m \\<Longrightarrow>\n    a ^ m / a ^ n =\n    (if n \\<le> m then a ^ (m - n) else ((1::'a) / a) ^ (n - m))\n 2. \\<not> n \\<le> m \\<Longrightarrow>\n    a ^ m / a ^ n =\n    (if n \\<le> m then a ^ (m - n) else ((1::'a) / a) ^ (n - m))", "with nz"], ["proof (chain)\npicking this:\n  a \\<noteq> (0::'a)\n  n \\<le> m", "show ?thesis"], ["proof (prove)\nusing this:\n  a \\<noteq> (0::'a)\n  n \\<le> m\n\ngoal (1 subgoal):\n 1. a ^ m / a ^ n =\n    (if n \\<le> m then a ^ (m - n) else ((1::'a) / a) ^ (n - m))", "by (simp add: power_diff)"], ["proof (state)\nthis:\n  a ^ m / a ^ n =\n  (if n \\<le> m then a ^ (m - n) else ((1::'a) / a) ^ (n - m))\n\ngoal (1 subgoal):\n 1. \\<not> n \\<le> m \\<Longrightarrow>\n    a ^ m / a ^ n =\n    (if n \\<le> m then a ^ (m - n) else ((1::'a) / a) ^ (n - m))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> n \\<le> m \\<Longrightarrow>\n    a ^ m / a ^ n =\n    (if n \\<le> m then a ^ (m - n) else ((1::'a) / a) ^ (n - m))", "case False"], ["proof (state)\nthis:\n  \\<not> n \\<le> m\n\ngoal (1 subgoal):\n 1. \\<not> n \\<le> m \\<Longrightarrow>\n    a ^ m / a ^ n =\n    (if n \\<le> m then a ^ (m - n) else ((1::'a) / a) ^ (n - m))", "with nz"], ["proof (chain)\npicking this:\n  a \\<noteq> (0::'a)\n  \\<not> n \\<le> m", "show ?thesis"], ["proof (prove)\nusing this:\n  a \\<noteq> (0::'a)\n  \\<not> n \\<le> m\n\ngoal (1 subgoal):\n 1. a ^ m / a ^ n =\n    (if n \\<le> m then a ^ (m - n) else ((1::'a) / a) ^ (n - m))", "by (simp add: power_diff_inverse nonzero_inverse_eq_divide [THEN sym])"], ["proof (state)\nthis:\n  a ^ m / a ^ n =\n  (if n \\<le> m then a ^ (m - n) else ((1::'a) / a) ^ (n - m))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma power_divides_special:\n  \"(a::'a::field) ~= 0 ==>\n  a ^ (i * j) / a ^ (k * i) = (a ^ j / a ^ k) ^ i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<noteq> (0::'a) \\<Longrightarrow>\n    a ^ (i * j) / a ^ (k * i) = (a ^ j / a ^ k) ^ i", "by (simp add: power_divide power_mult [THEN sym] ac_simps)"], ["", "theorem DFT_inverse:\n  assumes i_less: \"i < n\"\n  shows  \"IDFT n (DFT n a) i = of_nat n * a i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. IDFT n (DFT n a) i = of_nat n * a i", "using [[linarith_split_limit = 0]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. IDFT n (DFT n a) i = of_nat n * a i", "apply (unfold DFT_def IDFT_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k = 0..<n.\n        (\\<Sum>j = 0..<n. FFT.root n ^ (k * j) * a j) /\n        FFT.root n ^ (i * k)) =\n    of_nat n * a i", "apply (simp add: sum_divide_distrib)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k = 0..<n.\n        \\<Sum>na = 0..<n.\n           FFT.root n ^ (k * na) * a na / FFT.root n ^ (i * k)) =\n    of_nat n * a i", "apply (subst sum.swap)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j = 0..<n.\n        \\<Sum>ia = 0..<n.\n           FFT.root n ^ (ia * j) * a j / FFT.root n ^ (i * ia)) =\n    of_nat n * a i", "apply (simp only: times_divide_eq_left [THEN sym])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j = 0..<n.\n        \\<Sum>ia = 0..<n.\n           FFT.root n ^ (ia * j) / FFT.root n ^ (i * ia) * a j) =\n    of_nat n * a i", "apply (simp only: power_divides_special [OF root_nonzero])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j = 0..<n.\n        \\<Sum>ia = 0..<n. (FFT.root n ^ j / FFT.root n ^ i) ^ ia * a j) =\n    of_nat n * a i", "apply (simp add: power_diff_rev_if root_nonzero)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j = 0..<n.\n        \\<Sum>ia = 0..<n.\n           (if i \\<le> j then FFT.root n ^ (j - i)\n            else (1 / FFT.root n) ^ (i - j)) ^\n           ia *\n           a j) =\n    of_nat n * a i", "apply (simp add: sum_divide_distrib [THEN sym]\n    sum_distrib_right [THEN sym])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j = 0..<n.\n        sum ((^) (if i \\<le> j then FFT.root n ^ (j - i)\n                  else (1 / FFT.root n) ^ (i - j)))\n         {0..<n} *\n        a j) =\n    of_nat n * a i", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>j = 0..<n.\n        sum ((^) (if i \\<le> j then FFT.root n ^ (j - i)\n                  else (1 / FFT.root n) ^ (i - j)))\n         {0..<n} *\n        a j) =\n    of_nat n * a i", "from i_less"], ["proof (chain)\npicking this:\n  i < n", "have i_diff: \"!!k. i - k < n\""], ["proof (prove)\nusing this:\n  i < n\n\ngoal (1 subgoal):\n 1. \\<And>k. i - k < n", "by arith"], ["proof (state)\nthis:\n  i - ?k < n\n\ngoal (1 subgoal):\n 1. (\\<Sum>j = 0..<n.\n        sum ((^) (if i \\<le> j then FFT.root n ^ (j - i)\n                  else (1 / FFT.root n) ^ (i - j)))\n         {0..<n} *\n        a j) =\n    of_nat n * a i", "have diff_i: \"!!k. k < n ==> k - i < n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>k. k < n \\<Longrightarrow> k - i < n", "by arith"], ["proof (state)\nthis:\n  ?k < n \\<Longrightarrow> ?k - i < n\n\ngoal (1 subgoal):\n 1. (\\<Sum>j = 0..<n.\n        sum ((^) (if i \\<le> j then FFT.root n ^ (j - i)\n                  else (1 / FFT.root n) ^ (i - j)))\n         {0..<n} *\n        a j) =\n    of_nat n * a i", "let ?sum = \"%i j n. sum ((^) (if i <= j then root n ^ (j - i)\n                  else (1 / root n) ^ (i - j))) {0..<n} * a j\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>j = 0..<n.\n        sum ((^) (if i \\<le> j then FFT.root n ^ (j - i)\n                  else (1 / FFT.root n) ^ (i - j)))\n         {0..<n} *\n        a j) =\n    of_nat n * a i", "let ?sum1 = \"%i j n. sum ((^) (root n ^ (j - i))) {0..<n} * a j\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>j = 0..<n.\n        sum ((^) (if i \\<le> j then FFT.root n ^ (j - i)\n                  else (1 / FFT.root n) ^ (i - j)))\n         {0..<n} *\n        a j) =\n    of_nat n * a i", "let ?sum2 = \"%i j n. sum ((^) ((1 / root n) ^ (i - j))) {0..<n} * a j\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>j = 0..<n.\n        sum ((^) (if i \\<le> j then FFT.root n ^ (j - i)\n                  else (1 / FFT.root n) ^ (i - j)))\n         {0..<n} *\n        a j) =\n    of_nat n * a i", "from i_less"], ["proof (chain)\npicking this:\n  i < n", "have \"(\\<Sum>j = 0..<n. ?sum i j n) =\n      (\\<Sum>j = 0..<i. ?sum2 i j n) + (\\<Sum>j = i..<n. ?sum1 i j n)\"\n      (is \"?s = _\")"], ["proof (prove)\nusing this:\n  i < n\n\ngoal (1 subgoal):\n 1. (\\<Sum>j = 0..<n.\n        sum ((^) (if i \\<le> j then FFT.root n ^ (j - i)\n                  else (1 / FFT.root n) ^ (i - j)))\n         {0..<n} *\n        a j) =\n    (\\<Sum>j = 0..<i.\n        sum ((^) ((1 / FFT.root n) ^ (i - j))) {0..<n} * a j) +\n    (\\<Sum>j = i..<n. sum ((^) (FFT.root n ^ (j - i))) {0..<n} * a j)", "by (simp add: root_summation_inv nat_dvd_not_less\n        sum_add_split_nat_ivl [where f = \"%j. ?sum i j n\"])"], ["proof (state)\nthis:\n  (\\<Sum>j = 0..<n.\n      sum ((^) (if i \\<le> j then FFT.root n ^ (j - i)\n                else (1 / FFT.root n) ^ (i - j)))\n       {0..<n} *\n      a j) =\n  (\\<Sum>j = 0..<i. sum ((^) ((1 / FFT.root n) ^ (i - j))) {0..<n} * a j) +\n  (\\<Sum>j = i..<n. sum ((^) (FFT.root n ^ (j - i))) {0..<n} * a j)\n\ngoal (1 subgoal):\n 1. (\\<Sum>j = 0..<n.\n        sum ((^) (if i \\<le> j then FFT.root n ^ (j - i)\n                  else (1 / FFT.root n) ^ (i - j)))\n         {0..<n} *\n        a j) =\n    of_nat n * a i", "also"], ["proof (state)\nthis:\n  (\\<Sum>j = 0..<n.\n      sum ((^) (if i \\<le> j then FFT.root n ^ (j - i)\n                else (1 / FFT.root n) ^ (i - j)))\n       {0..<n} *\n      a j) =\n  (\\<Sum>j = 0..<i. sum ((^) ((1 / FFT.root n) ^ (i - j))) {0..<n} * a j) +\n  (\\<Sum>j = i..<n. sum ((^) (FFT.root n ^ (j - i))) {0..<n} * a j)\n\ngoal (1 subgoal):\n 1. (\\<Sum>j = 0..<n.\n        sum ((^) (if i \\<le> j then FFT.root n ^ (j - i)\n                  else (1 / FFT.root n) ^ (i - j)))\n         {0..<n} *\n        a j) =\n    of_nat n * a i", "from i_less i_diff"], ["proof (chain)\npicking this:\n  i < n\n  i - ?k < n", "have \"... = (\\<Sum>j = i..<n. ?sum1 i j n)\""], ["proof (prove)\nusing this:\n  i < n\n  i - ?k < n\n\ngoal (1 subgoal):\n 1. (\\<Sum>j = 0..<i.\n        sum ((^) ((1 / FFT.root n) ^ (i - j))) {0..<n} * a j) +\n    (\\<Sum>j = i..<n. sum ((^) (FFT.root n ^ (j - i))) {0..<n} * a j) =\n    (\\<Sum>j = i..<n. sum ((^) (FFT.root n ^ (j - i))) {0..<n} * a j)", "by (simp add: root_summation_inv nat_dvd_not_less)"], ["proof (state)\nthis:\n  (\\<Sum>j = 0..<i. sum ((^) ((1 / FFT.root n) ^ (i - j))) {0..<n} * a j) +\n  (\\<Sum>j = i..<n. sum ((^) (FFT.root n ^ (j - i))) {0..<n} * a j) =\n  (\\<Sum>j = i..<n. sum ((^) (FFT.root n ^ (j - i))) {0..<n} * a j)\n\ngoal (1 subgoal):\n 1. (\\<Sum>j = 0..<n.\n        sum ((^) (if i \\<le> j then FFT.root n ^ (j - i)\n                  else (1 / FFT.root n) ^ (i - j)))\n         {0..<n} *\n        a j) =\n    of_nat n * a i", "also"], ["proof (state)\nthis:\n  (\\<Sum>j = 0..<i. sum ((^) ((1 / FFT.root n) ^ (i - j))) {0..<n} * a j) +\n  (\\<Sum>j = i..<n. sum ((^) (FFT.root n ^ (j - i))) {0..<n} * a j) =\n  (\\<Sum>j = i..<n. sum ((^) (FFT.root n ^ (j - i))) {0..<n} * a j)\n\ngoal (1 subgoal):\n 1. (\\<Sum>j = 0..<n.\n        sum ((^) (if i \\<le> j then FFT.root n ^ (j - i)\n                  else (1 / FFT.root n) ^ (i - j)))\n         {0..<n} *\n        a j) =\n    of_nat n * a i", "from i_less"], ["proof (chain)\npicking this:\n  i < n", "have \"... =\n      (\\<Sum>j\\<in>{i} \\<union> {i<..<n}. ?sum1 i j n)\""], ["proof (prove)\nusing this:\n  i < n\n\ngoal (1 subgoal):\n 1. (\\<Sum>j = i..<n. sum ((^) (FFT.root n ^ (j - i))) {0..<n} * a j) =\n    (\\<Sum>j\\<in>{i} \\<union> {i<..<n}.\n       sum ((^) (FFT.root n ^ (j - i))) {0..<n} * a j)", "by (simp only: ivl_disj_un)"], ["proof (state)\nthis:\n  (\\<Sum>j = i..<n. sum ((^) (FFT.root n ^ (j - i))) {0..<n} * a j) =\n  (\\<Sum>j\\<in>{i} \\<union> {i<..<n}.\n     sum ((^) (FFT.root n ^ (j - i))) {0..<n} * a j)\n\ngoal (1 subgoal):\n 1. (\\<Sum>j = 0..<n.\n        sum ((^) (if i \\<le> j then FFT.root n ^ (j - i)\n                  else (1 / FFT.root n) ^ (i - j)))\n         {0..<n} *\n        a j) =\n    of_nat n * a i", "also"], ["proof (state)\nthis:\n  (\\<Sum>j = i..<n. sum ((^) (FFT.root n ^ (j - i))) {0..<n} * a j) =\n  (\\<Sum>j\\<in>{i} \\<union> {i<..<n}.\n     sum ((^) (FFT.root n ^ (j - i))) {0..<n} * a j)\n\ngoal (1 subgoal):\n 1. (\\<Sum>j = 0..<n.\n        sum ((^) (if i \\<le> j then FFT.root n ^ (j - i)\n                  else (1 / FFT.root n) ^ (i - j)))\n         {0..<n} *\n        a j) =\n    of_nat n * a i", "have \"... =\n      (?sum1 i i n + (\\<Sum>j\\<in>{i<..<n}. ?sum1 i j n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<in>{i} \\<union> {i<..<n}.\n       sum ((^) (FFT.root n ^ (j - i))) {0..<n} * a j) =\n    sum ((^) (FFT.root n ^ (i - i))) {0..<n} * a i +\n    (\\<Sum>j\\<in>{i<..<n}. sum ((^) (FFT.root n ^ (j - i))) {0..<n} * a j)", "by (simp add: sum.union_disjoint ivl_disj_int)"], ["proof (state)\nthis:\n  (\\<Sum>j\\<in>{i} \\<union> {i<..<n}.\n     sum ((^) (FFT.root n ^ (j - i))) {0..<n} * a j) =\n  sum ((^) (FFT.root n ^ (i - i))) {0..<n} * a i +\n  (\\<Sum>j\\<in>{i<..<n}. sum ((^) (FFT.root n ^ (j - i))) {0..<n} * a j)\n\ngoal (1 subgoal):\n 1. (\\<Sum>j = 0..<n.\n        sum ((^) (if i \\<le> j then FFT.root n ^ (j - i)\n                  else (1 / FFT.root n) ^ (i - j)))\n         {0..<n} *\n        a j) =\n    of_nat n * a i", "also"], ["proof (state)\nthis:\n  (\\<Sum>j\\<in>{i} \\<union> {i<..<n}.\n     sum ((^) (FFT.root n ^ (j - i))) {0..<n} * a j) =\n  sum ((^) (FFT.root n ^ (i - i))) {0..<n} * a i +\n  (\\<Sum>j\\<in>{i<..<n}. sum ((^) (FFT.root n ^ (j - i))) {0..<n} * a j)\n\ngoal (1 subgoal):\n 1. (\\<Sum>j = 0..<n.\n        sum ((^) (if i \\<le> j then FFT.root n ^ (j - i)\n                  else (1 / FFT.root n) ^ (i - j)))\n         {0..<n} *\n        a j) =\n    of_nat n * a i", "from i_less diff_i"], ["proof (chain)\npicking this:\n  i < n\n  ?k < n \\<Longrightarrow> ?k - i < n", "have \"... = ?sum1 i i n\""], ["proof (prove)\nusing this:\n  i < n\n  ?k < n \\<Longrightarrow> ?k - i < n\n\ngoal (1 subgoal):\n 1. sum ((^) (FFT.root n ^ (i - i))) {0..<n} * a i +\n    (\\<Sum>j\\<in>{i<..<n}. sum ((^) (FFT.root n ^ (j - i))) {0..<n} * a j) =\n    sum ((^) (FFT.root n ^ (i - i))) {0..<n} * a i", "by (simp add: root_summation nat_dvd_not_less)"], ["proof (state)\nthis:\n  sum ((^) (FFT.root n ^ (i - i))) {0..<n} * a i +\n  (\\<Sum>j\\<in>{i<..<n}. sum ((^) (FFT.root n ^ (j - i))) {0..<n} * a j) =\n  sum ((^) (FFT.root n ^ (i - i))) {0..<n} * a i\n\ngoal (1 subgoal):\n 1. (\\<Sum>j = 0..<n.\n        sum ((^) (if i \\<le> j then FFT.root n ^ (j - i)\n                  else (1 / FFT.root n) ^ (i - j)))\n         {0..<n} *\n        a j) =\n    of_nat n * a i", "also"], ["proof (state)\nthis:\n  sum ((^) (FFT.root n ^ (i - i))) {0..<n} * a i +\n  (\\<Sum>j\\<in>{i<..<n}. sum ((^) (FFT.root n ^ (j - i))) {0..<n} * a j) =\n  sum ((^) (FFT.root n ^ (i - i))) {0..<n} * a i\n\ngoal (1 subgoal):\n 1. (\\<Sum>j = 0..<n.\n        sum ((^) (if i \\<le> j then FFT.root n ^ (j - i)\n                  else (1 / FFT.root n) ^ (i - j)))\n         {0..<n} *\n        a j) =\n    of_nat n * a i", "from i_less"], ["proof (chain)\npicking this:\n  i < n", "have \"... = of_nat n * a i\" (is \"_ = ?t\")"], ["proof (prove)\nusing this:\n  i < n\n\ngoal (1 subgoal):\n 1. sum ((^) (FFT.root n ^ (i - i))) {0..<n} * a i = of_nat n * a i", "by simp"], ["proof (state)\nthis:\n  sum ((^) (FFT.root n ^ (i - i))) {0..<n} * a i = of_nat n * a i\n\ngoal (1 subgoal):\n 1. (\\<Sum>j = 0..<n.\n        sum ((^) (if i \\<le> j then FFT.root n ^ (j - i)\n                  else (1 / FFT.root n) ^ (i - j)))\n         {0..<n} *\n        a j) =\n    of_nat n * a i", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>j = 0..<n.\n      sum ((^) (if i \\<le> j then FFT.root n ^ (j - i)\n                else (1 / FFT.root n) ^ (i - j)))\n       {0..<n} *\n      a j) =\n  of_nat n * a i", "show \"?s = ?t\""], ["proof (prove)\nusing this:\n  (\\<Sum>j = 0..<n.\n      sum ((^) (if i \\<le> j then FFT.root n ^ (j - i)\n                else (1 / FFT.root n) ^ (i - j)))\n       {0..<n} *\n      a j) =\n  of_nat n * a i\n\ngoal (1 subgoal):\n 1. (\\<Sum>j = 0..<n.\n        sum ((^) (if i \\<le> j then FFT.root n ^ (j - i)\n                  else (1 / FFT.root n) ^ (i - j)))\n         {0..<n} *\n        a j) =\n    of_nat n * a i", "."], ["proof (state)\nthis:\n  (\\<Sum>j = 0..<n.\n      sum ((^) (if i \\<le> j then FFT.root n ^ (j - i)\n                else (1 / FFT.root n) ^ (i - j)))\n       {0..<n} *\n      a j) =\n  of_nat n * a i\n\ngoal:\nNo subgoals!", "qed"], ["", "section \\<open>Discrete, Fast Fourier Transformation\\<close>"], ["", "text \\<open>\\<open>FFT k a\\<close> is the transform of vector \\<open>a\\<close>\n  of length \\<open>2 ^ k\\<close>, \\<open>IFFT\\<close> its inverse.\\<close>"], ["", "primrec FFT :: \"nat => (nat => complex) => (nat => complex)\" where\n  \"FFT 0 a = a\"\n| \"FFT (Suc k) a =\n     (let (x, y) = (FFT k (%i. a (2*i)), FFT k (%i. a (2*i+1)))\n      in (%i. if i < 2^k\n            then x i + (root (2 ^ (Suc k))) ^ i * y i\n            else x (i- 2^k) - (root (2 ^ (Suc k))) ^ (i- 2^k) * y (i- 2^k)))\""], ["", "primrec IFFT :: \"nat => (nat => complex) => (nat => complex)\" where\n  \"IFFT 0 a = a\"\n| \"IFFT (Suc k) a =\n     (let (x, y) = (IFFT k (%i. a (2*i)), IFFT k (%i. a (2*i+1)))\n      in (%i. if i < 2^k\n            then x i + (1 / root (2 ^ (Suc k))) ^ i * y i\n            else x (i - 2^k) -\n              (1 / root (2 ^ (Suc k))) ^ (i - 2^k) * y (i - 2^k)))\""], ["", "text \\<open>Finally, for vectors of length \\<open>2 ^ k\\<close>,\n  \\<open>DFT\\<close> and \\<open>FFT\\<close>, and \\<open>IDFT\\<close> and\n  \\<open>IFFT\\<close> are equivalent.\\<close>"], ["", "theorem DFT_FFT:\n  \"!!a i. i < 2 ^ k ==> DFT (2 ^ k) a i = FFT k a i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a i. i < 2 ^ k \\<Longrightarrow> DFT (2 ^ k) a i = FFT k a i", "proof (induct k)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a i. i < 2 ^ 0 \\<Longrightarrow> DFT (2 ^ 0) a i = FFT 0 a i\n 2. \\<And>k a i.\n       \\<lbrakk>\\<And>a i.\n                   i < 2 ^ k \\<Longrightarrow> DFT (2 ^ k) a i = FFT k a i;\n        i < 2 ^ Suc k\\<rbrakk>\n       \\<Longrightarrow> DFT (2 ^ Suc k) a i = FFT (Suc k) a i", "case 0"], ["proof (state)\nthis:\n  i < 2 ^ 0\n\ngoal (2 subgoals):\n 1. \\<And>a i. i < 2 ^ 0 \\<Longrightarrow> DFT (2 ^ 0) a i = FFT 0 a i\n 2. \\<And>k a i.\n       \\<lbrakk>\\<And>a i.\n                   i < 2 ^ k \\<Longrightarrow> DFT (2 ^ k) a i = FFT k a i;\n        i < 2 ^ Suc k\\<rbrakk>\n       \\<Longrightarrow> DFT (2 ^ Suc k) a i = FFT (Suc k) a i", "then"], ["proof (chain)\npicking this:\n  i < 2 ^ 0", "show ?case"], ["proof (prove)\nusing this:\n  i < 2 ^ 0\n\ngoal (1 subgoal):\n 1. DFT (2 ^ 0) a i = FFT 0 a i", "by (simp add: DFT_def)"], ["proof (state)\nthis:\n  DFT (2 ^ 0) a i = FFT 0 a i\n\ngoal (1 subgoal):\n 1. \\<And>k a i.\n       \\<lbrakk>\\<And>a i.\n                   i < 2 ^ k \\<Longrightarrow> DFT (2 ^ k) a i = FFT k a i;\n        i < 2 ^ Suc k\\<rbrakk>\n       \\<Longrightarrow> DFT (2 ^ Suc k) a i = FFT (Suc k) a i", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k a i.\n       \\<lbrakk>\\<And>a i.\n                   i < 2 ^ k \\<Longrightarrow> DFT (2 ^ k) a i = FFT k a i;\n        i < 2 ^ Suc k\\<rbrakk>\n       \\<Longrightarrow> DFT (2 ^ Suc k) a i = FFT (Suc k) a i", "case (Suc k)"], ["proof (state)\nthis:\n  ?i < 2 ^ k \\<Longrightarrow> DFT (2 ^ k) ?a ?i = FFT k ?a ?i\n  i < 2 ^ Suc k\n\ngoal (1 subgoal):\n 1. \\<And>k a i.\n       \\<lbrakk>\\<And>a i.\n                   i < 2 ^ k \\<Longrightarrow> DFT (2 ^ k) a i = FFT k a i;\n        i < 2 ^ Suc k\\<rbrakk>\n       \\<Longrightarrow> DFT (2 ^ Suc k) a i = FFT (Suc k) a i", "assume i: \"i < 2 ^ Suc k\""], ["proof (state)\nthis:\n  i < 2 ^ Suc k\n\ngoal (1 subgoal):\n 1. \\<And>k a i.\n       \\<lbrakk>\\<And>a i.\n                   i < 2 ^ k \\<Longrightarrow> DFT (2 ^ k) a i = FFT k a i;\n        i < 2 ^ Suc k\\<rbrakk>\n       \\<Longrightarrow> DFT (2 ^ Suc k) a i = FFT (Suc k) a i", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. DFT (2 ^ Suc k) a i = FFT (Suc k) a i", "proof (cases \"i < 2 ^ k\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i < 2 ^ k \\<Longrightarrow> DFT (2 ^ Suc k) a i = FFT (Suc k) a i\n 2. \\<not> i < 2 ^ k \\<Longrightarrow> DFT (2 ^ Suc k) a i = FFT (Suc k) a i", "case True"], ["proof (state)\nthis:\n  i < 2 ^ k\n\ngoal (2 subgoals):\n 1. i < 2 ^ k \\<Longrightarrow> DFT (2 ^ Suc k) a i = FFT (Suc k) a i\n 2. \\<not> i < 2 ^ k \\<Longrightarrow> DFT (2 ^ Suc k) a i = FFT (Suc k) a i", "then"], ["proof (chain)\npicking this:\n  i < 2 ^ k", "show ?thesis"], ["proof (prove)\nusing this:\n  i < 2 ^ k\n\ngoal (1 subgoal):\n 1. DFT (2 ^ Suc k) a i = FFT (Suc k) a i", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. i < 2 ^ k \\<Longrightarrow>\n    DFT (2 * 2 ^ k) a i =\n    FFT k (\\<lambda>i. a (2 * i)) i +\n    FFT.root (2 * 2 ^ k) ^ i * FFT k (\\<lambda>i. a (Suc (2 * i))) i", "apply (simp add: DFT_lower)"], ["proof (prove)\ngoal (1 subgoal):\n 1. i < 2 ^ k \\<Longrightarrow>\n    DFT (2 ^ k) (\\<lambda>i. a (2 * i)) i +\n    FFT.root (2 * 2 ^ k) ^ i * DFT (2 ^ k) (\\<lambda>i. a (Suc (2 * i))) i =\n    FFT k (\\<lambda>i. a (2 * i)) i +\n    FFT.root (2 * 2 ^ k) ^ i * FFT k (\\<lambda>i. a (Suc (2 * i))) i", "apply (simp add: Suc)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  DFT (2 ^ Suc k) a i = FFT (Suc k) a i\n\ngoal (1 subgoal):\n 1. \\<not> i < 2 ^ k \\<Longrightarrow> DFT (2 ^ Suc k) a i = FFT (Suc k) a i", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> i < 2 ^ k \\<Longrightarrow> DFT (2 ^ Suc k) a i = FFT (Suc k) a i", "case False"], ["proof (state)\nthis:\n  \\<not> i < 2 ^ k\n\ngoal (1 subgoal):\n 1. \\<not> i < 2 ^ k \\<Longrightarrow> DFT (2 ^ Suc k) a i = FFT (Suc k) a i", "from i"], ["proof (chain)\npicking this:\n  i < 2 ^ Suc k", "have \"i - 2 ^ k < 2 ^ k\""], ["proof (prove)\nusing this:\n  i < 2 ^ Suc k\n\ngoal (1 subgoal):\n 1. i - 2 ^ k < 2 ^ k", "by simp"], ["proof (state)\nthis:\n  i - 2 ^ k < 2 ^ k\n\ngoal (1 subgoal):\n 1. \\<not> i < 2 ^ k \\<Longrightarrow> DFT (2 ^ Suc k) a i = FFT (Suc k) a i", "with False i"], ["proof (chain)\npicking this:\n  \\<not> i < 2 ^ k\n  i < 2 ^ Suc k\n  i - 2 ^ k < 2 ^ k", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> i < 2 ^ k\n  i < 2 ^ Suc k\n  i - 2 ^ k < 2 ^ k\n\ngoal (1 subgoal):\n 1. DFT (2 ^ Suc k) a i = FFT (Suc k) a i", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> i < 2 ^ k; i < 2 * 2 ^ k; i - 2 ^ k < 2 ^ k\\<rbrakk>\n    \\<Longrightarrow> DFT (2 * 2 ^ k) a i =\n                      FFT k (\\<lambda>i. a (2 * i)) (i - 2 ^ k) -\n                      FFT.root (2 * 2 ^ k) ^ (i - 2 ^ k) *\n                      FFT k (\\<lambda>i. a (Suc (2 * i))) (i - 2 ^ k)", "apply (simp add: DFT_upper)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> i < 2 ^ k; i < 2 * 2 ^ k; i - 2 ^ k < 2 ^ k\\<rbrakk>\n    \\<Longrightarrow> DFT (2 ^ k) (\\<lambda>i. a (2 * i)) (i - 2 ^ k) -\n                      FFT.root (2 * 2 ^ k) ^ (i - 2 ^ k) *\n                      DFT (2 ^ k) (\\<lambda>i. a (Suc (2 * i)))\n                       (i - 2 ^ k) =\n                      FFT k (\\<lambda>i. a (2 * i)) (i - 2 ^ k) -\n                      FFT.root (2 * 2 ^ k) ^ (i - 2 ^ k) *\n                      FFT k (\\<lambda>i. a (Suc (2 * i))) (i - 2 ^ k)", "apply (simp add: Suc)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  DFT (2 ^ Suc k) a i = FFT (Suc k) a i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  DFT (2 ^ Suc k) a i = FFT (Suc k) a i\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem IDFT_IFFT:\n  \"!!a i. i < 2 ^ k ==> IDFT (2 ^ k) a i = IFFT k a i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a i. i < 2 ^ k \\<Longrightarrow> IDFT (2 ^ k) a i = IFFT k a i", "proof (induct k)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a i. i < 2 ^ 0 \\<Longrightarrow> IDFT (2 ^ 0) a i = IFFT 0 a i\n 2. \\<And>k a i.\n       \\<lbrakk>\\<And>a i.\n                   i < 2 ^ k \\<Longrightarrow>\n                   IDFT (2 ^ k) a i = IFFT k a i;\n        i < 2 ^ Suc k\\<rbrakk>\n       \\<Longrightarrow> IDFT (2 ^ Suc k) a i = IFFT (Suc k) a i", "case 0"], ["proof (state)\nthis:\n  i < 2 ^ 0\n\ngoal (2 subgoals):\n 1. \\<And>a i. i < 2 ^ 0 \\<Longrightarrow> IDFT (2 ^ 0) a i = IFFT 0 a i\n 2. \\<And>k a i.\n       \\<lbrakk>\\<And>a i.\n                   i < 2 ^ k \\<Longrightarrow>\n                   IDFT (2 ^ k) a i = IFFT k a i;\n        i < 2 ^ Suc k\\<rbrakk>\n       \\<Longrightarrow> IDFT (2 ^ Suc k) a i = IFFT (Suc k) a i", "then"], ["proof (chain)\npicking this:\n  i < 2 ^ 0", "show ?case"], ["proof (prove)\nusing this:\n  i < 2 ^ 0\n\ngoal (1 subgoal):\n 1. IDFT (2 ^ 0) a i = IFFT 0 a i", "by (simp add: IDFT_def)"], ["proof (state)\nthis:\n  IDFT (2 ^ 0) a i = IFFT 0 a i\n\ngoal (1 subgoal):\n 1. \\<And>k a i.\n       \\<lbrakk>\\<And>a i.\n                   i < 2 ^ k \\<Longrightarrow>\n                   IDFT (2 ^ k) a i = IFFT k a i;\n        i < 2 ^ Suc k\\<rbrakk>\n       \\<Longrightarrow> IDFT (2 ^ Suc k) a i = IFFT (Suc k) a i", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k a i.\n       \\<lbrakk>\\<And>a i.\n                   i < 2 ^ k \\<Longrightarrow>\n                   IDFT (2 ^ k) a i = IFFT k a i;\n        i < 2 ^ Suc k\\<rbrakk>\n       \\<Longrightarrow> IDFT (2 ^ Suc k) a i = IFFT (Suc k) a i", "case (Suc k)"], ["proof (state)\nthis:\n  ?i < 2 ^ k \\<Longrightarrow> IDFT (2 ^ k) ?a ?i = IFFT k ?a ?i\n  i < 2 ^ Suc k\n\ngoal (1 subgoal):\n 1. \\<And>k a i.\n       \\<lbrakk>\\<And>a i.\n                   i < 2 ^ k \\<Longrightarrow>\n                   IDFT (2 ^ k) a i = IFFT k a i;\n        i < 2 ^ Suc k\\<rbrakk>\n       \\<Longrightarrow> IDFT (2 ^ Suc k) a i = IFFT (Suc k) a i", "assume i: \"i < 2 ^ Suc k\""], ["proof (state)\nthis:\n  i < 2 ^ Suc k\n\ngoal (1 subgoal):\n 1. \\<And>k a i.\n       \\<lbrakk>\\<And>a i.\n                   i < 2 ^ k \\<Longrightarrow>\n                   IDFT (2 ^ k) a i = IFFT k a i;\n        i < 2 ^ Suc k\\<rbrakk>\n       \\<Longrightarrow> IDFT (2 ^ Suc k) a i = IFFT (Suc k) a i", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. IDFT (2 ^ Suc k) a i = IFFT (Suc k) a i", "proof (cases \"i < 2 ^ k\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i < 2 ^ k \\<Longrightarrow> IDFT (2 ^ Suc k) a i = IFFT (Suc k) a i\n 2. \\<not> i < 2 ^ k \\<Longrightarrow>\n    IDFT (2 ^ Suc k) a i = IFFT (Suc k) a i", "case True"], ["proof (state)\nthis:\n  i < 2 ^ k\n\ngoal (2 subgoals):\n 1. i < 2 ^ k \\<Longrightarrow> IDFT (2 ^ Suc k) a i = IFFT (Suc k) a i\n 2. \\<not> i < 2 ^ k \\<Longrightarrow>\n    IDFT (2 ^ Suc k) a i = IFFT (Suc k) a i", "then"], ["proof (chain)\npicking this:\n  i < 2 ^ k", "show ?thesis"], ["proof (prove)\nusing this:\n  i < 2 ^ k\n\ngoal (1 subgoal):\n 1. IDFT (2 ^ Suc k) a i = IFFT (Suc k) a i", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. i < 2 ^ k \\<Longrightarrow>\n    IDFT (2 * 2 ^ k) a i =\n    IFFT k (\\<lambda>i. a (2 * i)) i +\n    (1 / FFT.root (2 * 2 ^ k)) ^ i * IFFT k (\\<lambda>i. a (Suc (2 * i))) i", "apply (simp add: IDFT_lower)"], ["proof (prove)\ngoal (1 subgoal):\n 1. i < 2 ^ k \\<Longrightarrow>\n    IDFT (2 ^ k) (\\<lambda>i. a (2 * i)) i +\n    (1 / FFT.root (2 * 2 ^ k)) ^ i *\n    IDFT (2 ^ k) (\\<lambda>i. a (Suc (2 * i))) i =\n    IFFT k (\\<lambda>i. a (2 * i)) i +\n    (1 / FFT.root (2 * 2 ^ k)) ^ i * IFFT k (\\<lambda>i. a (Suc (2 * i))) i", "apply (simp add: Suc)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  IDFT (2 ^ Suc k) a i = IFFT (Suc k) a i\n\ngoal (1 subgoal):\n 1. \\<not> i < 2 ^ k \\<Longrightarrow>\n    IDFT (2 ^ Suc k) a i = IFFT (Suc k) a i", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> i < 2 ^ k \\<Longrightarrow>\n    IDFT (2 ^ Suc k) a i = IFFT (Suc k) a i", "case False"], ["proof (state)\nthis:\n  \\<not> i < 2 ^ k\n\ngoal (1 subgoal):\n 1. \\<not> i < 2 ^ k \\<Longrightarrow>\n    IDFT (2 ^ Suc k) a i = IFFT (Suc k) a i", "from i"], ["proof (chain)\npicking this:\n  i < 2 ^ Suc k", "have \"i - 2 ^ k < 2 ^ k\""], ["proof (prove)\nusing this:\n  i < 2 ^ Suc k\n\ngoal (1 subgoal):\n 1. i - 2 ^ k < 2 ^ k", "by simp"], ["proof (state)\nthis:\n  i - 2 ^ k < 2 ^ k\n\ngoal (1 subgoal):\n 1. \\<not> i < 2 ^ k \\<Longrightarrow>\n    IDFT (2 ^ Suc k) a i = IFFT (Suc k) a i", "with False i"], ["proof (chain)\npicking this:\n  \\<not> i < 2 ^ k\n  i < 2 ^ Suc k\n  i - 2 ^ k < 2 ^ k", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> i < 2 ^ k\n  i < 2 ^ Suc k\n  i - 2 ^ k < 2 ^ k\n\ngoal (1 subgoal):\n 1. IDFT (2 ^ Suc k) a i = IFFT (Suc k) a i", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> i < 2 ^ k; i < 2 * 2 ^ k; i - 2 ^ k < 2 ^ k\\<rbrakk>\n    \\<Longrightarrow> IDFT (2 * 2 ^ k) a i =\n                      IFFT k (\\<lambda>i. a (2 * i)) (i - 2 ^ k) -\n                      (1 / FFT.root (2 * 2 ^ k)) ^ (i - 2 ^ k) *\n                      IFFT k (\\<lambda>i. a (Suc (2 * i))) (i - 2 ^ k)", "apply (simp add: IDFT_upper)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> i < 2 ^ k; i < 2 * 2 ^ k; i - 2 ^ k < 2 ^ k\\<rbrakk>\n    \\<Longrightarrow> IDFT (2 ^ k) (\\<lambda>i. a (2 * i)) (i - 2 ^ k) -\n                      (1 / FFT.root (2 * 2 ^ k)) ^ (i - 2 ^ k) *\n                      IDFT (2 ^ k) (\\<lambda>i. a (Suc (2 * i)))\n                       (i - 2 ^ k) =\n                      IFFT k (\\<lambda>i. a (2 * i)) (i - 2 ^ k) -\n                      (1 / FFT.root (2 * 2 ^ k)) ^ (i - 2 ^ k) *\n                      IFFT k (\\<lambda>i. a (Suc (2 * i))) (i - 2 ^ k)", "apply (simp add: Suc)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  IDFT (2 ^ Suc k) a i = IFFT (Suc k) a i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  IDFT (2 ^ Suc k) a i = IFFT (Suc k) a i\n\ngoal:\nNo subgoals!", "qed"], ["", "schematic_goal \"map (FFT (Suc (Suc 0)) a) [0, 1, 2, 3] = ?x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (FFT (Suc (Suc 0)) a) [0, 1, 2, 3] = ?x", "by simp"], ["", "end"]]}