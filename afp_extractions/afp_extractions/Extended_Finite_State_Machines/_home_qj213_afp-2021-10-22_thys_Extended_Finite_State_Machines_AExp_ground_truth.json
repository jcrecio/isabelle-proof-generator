{"file_name": "/home/qj213/afp-2021-10-22/thys/Extended_Finite_State_Machines/AExp.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Extended_Finite_State_Machines", "problem_names": ["lemma aexp_induct_separate_V_cases  [case_names L I R Plus Minus Times]:\n  \"(\\<And>x. P (L x)) \\<Longrightarrow>\n   (\\<And>x. P (V (I x))) \\<Longrightarrow>\n   (\\<And>x. P (V (R x))) \\<Longrightarrow>\n   (\\<And>x1a x2a. P x1a \\<Longrightarrow> P x2a \\<Longrightarrow> P (Plus x1a x2a)) \\<Longrightarrow>\n   (\\<And>x1a x2a. P x1a \\<Longrightarrow> P x2a \\<Longrightarrow> P (Minus x1a x2a)) \\<Longrightarrow>\n   (\\<And>x1a x2a. P x1a \\<Longrightarrow> P x2a \\<Longrightarrow> P (Times x1a x2a)) \\<Longrightarrow>\n   P a\"", "lemma aval_plus_symmetry: \"aval (Plus x y) s = aval (Plus y x) s\"", "lemma empty_None: \"<> = (K$ None)\"", "lemma apply_empty_None [simp]: \"<> $ x2 = None\"", "lemma input2state_append:\n  \"input2state (i @ [a]) = (input2state i)(length i $:= Some a)\"", "lemma input2state_out_of_bounds:\n  \"i \\<ge> length ia \\<Longrightarrow> input2state ia $ i = None\"", "lemma input2state_within_bounds:\n  \"input2state i $ x = Some a \\<Longrightarrow> x < length i\"", "lemma input2state_empty: \"input2state [] $ x1 = None\"", "lemma input2state_nth:\n  \"i < length ia \\<Longrightarrow> input2state ia $ i = Some (ia ! i)\"", "lemma input2state_some:\n  \"i < length ia \\<Longrightarrow>\n   ia ! i = x \\<Longrightarrow>\n   input2state ia $ i = Some x\"", "lemma input2state_take: \"x1 < A \\<Longrightarrow>\n   A \\<le> length i \\<Longrightarrow>\n   x = vname.I x1 \\<Longrightarrow>\n   input2state i $ x1 = input2state (take A i) $ x1\"", "lemma input2state_not_None:\n  \"(input2state i $ x \\<noteq> None) \\<Longrightarrow> (x < length i)\"", "lemma input2state_Some:\n  \"(\\<exists>v. input2state i $ x = Some v) = (x < length i)\"", "lemma input2state_cons: \"x1 > 0 \\<Longrightarrow>\n   x1 < length ia \\<Longrightarrow>\n   input2state (a # ia) $ x1 = input2state ia $ (x1-1)\"", "lemma input2state_cons_shift:\n  \"input2state i $ x1 = Some a \\<Longrightarrow> input2state (b # i) $ (Suc x1) = Some a\"", "lemma input2state_exists: \"\\<exists>i. input2state i $ x1 = Some a\"", "lemma length_repeat: \"length (repeat n a) = n\"", "lemma length_append_repeat: \"length (i@(repeat a y)) \\<ge> length i\"", "lemma length_input2state_repeat:\n  \"input2state i $ x = Some a \\<Longrightarrow> y < length (i @ repeat y a)\"", "lemma input2state_double_exists:\n  \"\\<exists>i. input2state i $ x = Some a \\<and> input2state i $ y = Some a\"", "lemma input2state_double_exists_2:\n  \"x \\<noteq> y \\<Longrightarrow> \\<exists>i. input2state i $ x = Some a \\<and> input2state i $ y = Some a'\"", "lemmas datastate = join_ir_def input2state_def", "lemma join_ir_empty [simp]: \"join_ir [] <> = (\\<lambda>x. None)\"", "lemma join_ir_R [simp]: \"(join_ir i r) (R n) = r $ n\"", "lemma join_ir_double_exists:\n  \"\\<exists>i r. join_ir i r v = Some a \\<and> join_ir i r v' = Some a\"", "lemma join_ir_double_exists_2:\n  \"v \\<noteq> v' \\<Longrightarrow> \\<exists>i r. join_ir i r v = Some a \\<and> join_ir i r v' = Some a'\"", "lemma exists_join_ir_ext: \"\\<exists>i r. join_ir i r v = s v\"", "lemma join_ir_nth [simp]:\n  \"i < length is \\<Longrightarrow> join_ir is r (I i) = Some (is ! i)\"", "lemma enumerate_aexp_inputs_list: \"\\<exists>l. enumerate_aexp_inputs a = set l\"", "lemma finite_enumerate_regs: \"finite (enumerate_regs a)\"", "lemma no_variables_aval: \"enumerate_aexp_inputs a = {} \\<Longrightarrow>\n   enumerate_regs a = {} \\<Longrightarrow>\n   aval a s = aval a s'\"", "lemma enumerate_aexp_inputs_not_empty:\n  \"(enumerate_aexp_inputs a \\<noteq> {}) = (\\<exists>b c. enumerate_aexp_inputs a = set (b#c))\"", "lemma aval_ir_take: \"A \\<le> length i \\<Longrightarrow>\n  enumerate_regs a = {} \\<Longrightarrow>\n  enumerate_aexp_inputs a \\<noteq> {} \\<Longrightarrow>\n  Max (enumerate_aexp_inputs a) < A \\<Longrightarrow>\n  aval a (join_ir (take A i) r) = aval a (join_ir i ra)\"", "lemma max_reg_V_I: \"max_reg (V (I n)) = None\"", "lemma max_reg_V_R: \"max_reg (V (R n)) = Some n\"", "lemmas max_reg_V = max_reg_V_I max_reg_V_R", "lemma max_reg_Plus: \"max_reg (Plus a1 a2) = max (max_reg a1) (max_reg a2)\"", "lemma max_reg_Minus: \"max_reg (Minus a1 a2) = max (max_reg a1) (max_reg a2)\"", "lemma max_reg_Times: \"max_reg (Times a1 a2) = max (max_reg a1) (max_reg a2)\"", "lemma no_reg_aval_swap_regs:\n  \"max_reg a = None \\<Longrightarrow> aval a (join_ir i r) = aval a (join_ir i r')\"", "lemma aval_reg_some_superset:\n\"\\<forall>a. (r $ a  \\<noteq> None) \\<longrightarrow> r $ a = r' $ a \\<Longrightarrow>\n aval a (join_ir i r) = Some v \\<Longrightarrow>\n aval a (join_ir i r') = Some v\"", "lemma aval_reg_none_superset:\n\"\\<forall>a. (r $ a  \\<noteq> None) \\<longrightarrow> r $ a = r' $ a \\<Longrightarrow>\n aval a (join_ir i r') = None \\<Longrightarrow>\n aval a (join_ir i r) = None\"", "lemma enumerate_regs_empty_reg_unconstrained:\n  \"enumerate_regs a = {} \\<Longrightarrow> \\<forall>r. \\<not> aexp_constrains a (V (R r))\"", "lemma enumerate_aexp_inputs_empty_input_unconstrained:\n  \"enumerate_aexp_inputs a = {} \\<Longrightarrow> \\<forall>r. \\<not> aexp_constrains a (V (I r))\"", "lemma input_unconstrained_aval_input_swap:\n  \"\\<forall>i. \\<not> aexp_constrains a (V (I i)) \\<Longrightarrow>\n   aval a (join_ir i r) = aval a (join_ir i' r)\"", "lemma input_unconstrained_aval_register_swap:\n  \"\\<forall>i. \\<not> aexp_constrains a (V (R i)) \\<Longrightarrow>\n   aval a (join_ir i r) = aval a (join_ir i r')\"", "lemma unconstrained_variable_swap_aval:\n  \"\\<forall>i. \\<not> aexp_constrains a (V (I i)) \\<Longrightarrow>\n   \\<forall>r. \\<not> aexp_constrains a (V (R r)) \\<Longrightarrow>\n   aval a s = aval a s'\"", "lemma max_input_I: \"max_input (V (vname.I i)) = Some i\"", "lemma max_input_Plus:\n  \"max_input (Plus a1 a2) = max (max_input a1) (max_input a2)\"", "lemma max_input_Minus:\n  \"max_input (Minus a1 a2) = max (max_input a1) (max_input a2)\"", "lemma max_input_Times:\n  \"max_input (Times a1 a2) = max (max_input a1) (max_input a2)\"", "lemma aval_take:\n  \"max_input x < Some a \\<Longrightarrow>\n   aval x (join_ir i r) = aval x (join_ir (take a i) r)\"", "lemma aval_no_reg_swap_regs: \"max_input x < Some a \\<Longrightarrow>\n   max_reg x = None \\<Longrightarrow>\n   aval x (join_ir i ra) = aval x (join_ir (take a i) r)\""], "translations": [["", "lemma aexp_induct_separate_V_cases  [case_names L I R Plus Minus Times]:\n  \"(\\<And>x. P (L x)) \\<Longrightarrow>\n   (\\<And>x. P (V (I x))) \\<Longrightarrow>\n   (\\<And>x. P (V (R x))) \\<Longrightarrow>\n   (\\<And>x1a x2a. P x1a \\<Longrightarrow> P x2a \\<Longrightarrow> P (Plus x1a x2a)) \\<Longrightarrow>\n   (\\<And>x1a x2a. P x1a \\<Longrightarrow> P x2a \\<Longrightarrow> P (Minus x1a x2a)) \\<Longrightarrow>\n   (\\<And>x1a x2a. P x1a \\<Longrightarrow> P x2a \\<Longrightarrow> P (Times x1a x2a)) \\<Longrightarrow>\n   P a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x. P (L x); \\<And>x. P (V (I x)); \\<And>x. P (V (R x));\n     \\<And>x1a x2a.\n        \\<lbrakk>P x1a; P x2a\\<rbrakk> \\<Longrightarrow> P (Plus x1a x2a);\n     \\<And>x1a x2a.\n        \\<lbrakk>P x1a; P x2a\\<rbrakk> \\<Longrightarrow> P (Minus x1a x2a);\n     \\<And>x1a x2a.\n        \\<lbrakk>P x1a; P x2a\\<rbrakk>\n        \\<Longrightarrow> P (Times x1a x2a)\\<rbrakk>\n    \\<Longrightarrow> P a", "by (metis aexp.induct vname.exhaust)"], ["", "fun aval :: \"'a aexp \\<Rightarrow> 'a datastate \\<Rightarrow> value option\" where\n  \"aval (L x) s = Some x\" |\n  \"aval (V x) s = s x\" |\n  \"aval (Plus a1 a2) s = value_plus (aval a1 s)(aval a2 s)\" |\n  \"aval (Minus a1 a2) s = value_minus (aval a1 s) (aval a2 s)\" |\n  \"aval (Times a1 a2) s = value_times (aval a1 s) (aval a2 s)\""], ["", "lemma aval_plus_symmetry: \"aval (Plus x y) s = aval (Plus y x) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. aval (Plus x y) s = aval (Plus y x) s", "by (simp add: value_plus_symmetry)"], ["", "text \\<open>A little syntax magic to write larger states compactly:\\<close>"], ["", "definition null_state (\"<>\") where\n  \"null_state \\<equiv> (K$ bot)\""], ["", "no_notation finfun_update (\"_'(_ $:= _')\" [1000, 0, 0] 1000)"], ["", "nonterminal fupdbinds and fupdbind"], ["", "syntax\n  \"_fupdbind\" :: \"'a \\<Rightarrow> 'a \\<Rightarrow> fupdbind\"             (\"(2_ $:=/ _)\")\n  \"\"         :: \"fupdbind \\<Rightarrow> fupdbinds\"             (\"_\")\n  \"_fupdbinds\":: \"fupdbind \\<Rightarrow> fupdbinds \\<Rightarrow> fupdbinds\" (\"_,/ _\")\n  \"_fUpdate\"  :: \"'a \\<Rightarrow> fupdbinds \\<Rightarrow> 'a\"            (\"_/'((_)')\" [1000, 0] 900)\n  \"_State\" :: \"fupdbinds => 'a\" (\"<_>\")"], ["", "translations\n  \"_fUpdate f (_fupdbinds b bs)\" \\<rightleftharpoons> \"_fUpdate (_fUpdate f b) bs\"\n  \"f(x$:=y)\" \\<rightleftharpoons> \"CONST finfun_update f x y\"\n  \"_State ms\" == \"_fUpdate <> ms\"\n  \"_State (_updbinds b bs)\" <= \"_fUpdate (_State b) bs\""], ["", "lemma empty_None: \"<> = (K$ None)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <> = (K$ None)", "by (simp add: null_state_def bot_option_def)"], ["", "lemma apply_empty_None [simp]: \"<> $ x2 = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <> $ x2 = None", "by (simp add: null_state_def bot_option_def)"], ["", "definition input2state :: \"value list \\<Rightarrow> registers\" where\n  \"input2state n = fold (\\<lambda>(k, v) f. f(k $:= Some v)) (enumerate 0 n) (K$ None)\""], ["", "primrec input2state_prim :: \"value list \\<Rightarrow> nat \\<Rightarrow> registers\" where\n  \"input2state_prim [] _ = (K$ None)\" |\n  \"input2state_prim (v#t) k = (input2state_prim t (k+1))(k $:= Some v)\""], ["", "lemma input2state_append:\n  \"input2state (i @ [a]) = (input2state i)(length i $:= Some a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. input2state (i @ [a]) = (input2state i)(length i $:= Some a)", "apply (simp add: eq_finfun_All_ext finfun_All_def finfun_All_except_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>aa.\n       input2state (i @ [a]) $ aa =\n       ((input2state i)(length i $:= Some a)) $ aa", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa.\n       input2state (i @ [a]) $ aa =\n       ((input2state i)(length i $:= Some a)) $ aa", "by (simp add: input2state_def enumerate_eq_zip)"], ["", "lemma input2state_out_of_bounds:\n  \"i \\<ge> length ia \\<Longrightarrow> input2state ia $ i = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length ia \\<le> i \\<Longrightarrow> input2state ia $ i = None", "proof(induct ia rule: rev_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. length [] \\<le> i \\<Longrightarrow> input2state [] $ i = None\n 2. \\<And>x xs.\n       \\<lbrakk>length xs \\<le> i \\<Longrightarrow>\n                input2state xs $ i = None;\n        length (xs @ [x]) \\<le> i\\<rbrakk>\n       \\<Longrightarrow> input2state (xs @ [x]) $ i = None", "case Nil"], ["proof (state)\nthis:\n  length [] \\<le> i\n\ngoal (2 subgoals):\n 1. length [] \\<le> i \\<Longrightarrow> input2state [] $ i = None\n 2. \\<And>x xs.\n       \\<lbrakk>length xs \\<le> i \\<Longrightarrow>\n                input2state xs $ i = None;\n        length (xs @ [x]) \\<le> i\\<rbrakk>\n       \\<Longrightarrow> input2state (xs @ [x]) $ i = None", "then"], ["proof (chain)\npicking this:\n  length [] \\<le> i", "show ?case"], ["proof (prove)\nusing this:\n  length [] \\<le> i\n\ngoal (1 subgoal):\n 1. input2state [] $ i = None", "by (simp add: input2state_def)"], ["proof (state)\nthis:\n  input2state [] $ i = None\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>length xs \\<le> i \\<Longrightarrow>\n                input2state xs $ i = None;\n        length (xs @ [x]) \\<le> i\\<rbrakk>\n       \\<Longrightarrow> input2state (xs @ [x]) $ i = None", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>length xs \\<le> i \\<Longrightarrow>\n                input2state xs $ i = None;\n        length (xs @ [x]) \\<le> i\\<rbrakk>\n       \\<Longrightarrow> input2state (xs @ [x]) $ i = None", "case (snoc a as)"], ["proof (state)\nthis:\n  length as \\<le> i \\<Longrightarrow> input2state as $ i = None\n  length (as @ [a]) \\<le> i\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>length xs \\<le> i \\<Longrightarrow>\n                input2state xs $ i = None;\n        length (xs @ [x]) \\<le> i\\<rbrakk>\n       \\<Longrightarrow> input2state (xs @ [x]) $ i = None", "then"], ["proof (chain)\npicking this:\n  length as \\<le> i \\<Longrightarrow> input2state as $ i = None\n  length (as @ [a]) \\<le> i", "show ?case"], ["proof (prove)\nusing this:\n  length as \\<le> i \\<Longrightarrow> input2state as $ i = None\n  length (as @ [a]) \\<le> i\n\ngoal (1 subgoal):\n 1. input2state (as @ [a]) $ i = None", "by (simp add: input2state_def enumerate_eq_zip)"], ["proof (state)\nthis:\n  input2state (as @ [a]) $ i = None\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma input2state_within_bounds:\n  \"input2state i $ x = Some a \\<Longrightarrow> x < length i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. input2state i $ x = Some a \\<Longrightarrow> x < length i", "by (metis input2state_out_of_bounds not_le_imp_less option.distinct(1))"], ["", "lemma input2state_empty: \"input2state [] $ x1 = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. input2state [] $ x1 = None", "by (simp add: input2state_out_of_bounds)"], ["", "lemma input2state_nth:\n  \"i < length ia \\<Longrightarrow> input2state ia $ i = Some (ia ! i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < length ia \\<Longrightarrow> input2state ia $ i = Some (ia ! i)", "proof(induct ia rule: rev_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. i < length [] \\<Longrightarrow> input2state [] $ i = Some ([] ! i)\n 2. \\<And>x xs.\n       \\<lbrakk>i < length xs \\<Longrightarrow>\n                input2state xs $ i = Some (xs ! i);\n        i < length (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> input2state (xs @ [x]) $ i = Some ((xs @ [x]) ! i)", "case Nil"], ["proof (state)\nthis:\n  i < length []\n\ngoal (2 subgoals):\n 1. i < length [] \\<Longrightarrow> input2state [] $ i = Some ([] ! i)\n 2. \\<And>x xs.\n       \\<lbrakk>i < length xs \\<Longrightarrow>\n                input2state xs $ i = Some (xs ! i);\n        i < length (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> input2state (xs @ [x]) $ i = Some ((xs @ [x]) ! i)", "then"], ["proof (chain)\npicking this:\n  i < length []", "show ?case"], ["proof (prove)\nusing this:\n  i < length []\n\ngoal (1 subgoal):\n 1. input2state [] $ i = Some ([] ! i)", "by simp"], ["proof (state)\nthis:\n  input2state [] $ i = Some ([] ! i)\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>i < length xs \\<Longrightarrow>\n                input2state xs $ i = Some (xs ! i);\n        i < length (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> input2state (xs @ [x]) $ i = Some ((xs @ [x]) ! i)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>i < length xs \\<Longrightarrow>\n                input2state xs $ i = Some (xs ! i);\n        i < length (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> input2state (xs @ [x]) $ i = Some ((xs @ [x]) ! i)", "case (snoc a ia)"], ["proof (state)\nthis:\n  i < length ia \\<Longrightarrow> input2state ia $ i = Some (ia ! i)\n  i < length (ia @ [a])\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>i < length xs \\<Longrightarrow>\n                input2state xs $ i = Some (xs ! i);\n        i < length (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> input2state (xs @ [x]) $ i = Some ((xs @ [x]) ! i)", "then"], ["proof (chain)\npicking this:\n  i < length ia \\<Longrightarrow> input2state ia $ i = Some (ia ! i)\n  i < length (ia @ [a])", "show ?case"], ["proof (prove)\nusing this:\n  i < length ia \\<Longrightarrow> input2state ia $ i = Some (ia ! i)\n  i < length (ia @ [a])\n\ngoal (1 subgoal):\n 1. input2state (ia @ [a]) $ i = Some ((ia @ [a]) ! i)", "apply (simp add: input2state_def enumerate_eq_zip)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < length ia \\<Longrightarrow>\n             fold (\\<lambda>(k, v) f. f(k $:= Some v))\n              (zip [0..<length ia] ia) (K$ None) $\n             i =\n             Some (ia ! i);\n     i < Suc (length ia)\\<rbrakk>\n    \\<Longrightarrow> ((fold (\\<lambda>(k, v) f. f(k $:= Some v))\n                         (zip [0..<length ia] ia) (K$ None))\n                       (length ia $:= Some a)) $\n                      i =\n                      Some ((ia @ [a]) ! i)", "by (simp add: finfun_upd_apply nth_append)"], ["proof (state)\nthis:\n  input2state (ia @ [a]) $ i = Some ((ia @ [a]) ! i)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma input2state_some:\n  \"i < length ia \\<Longrightarrow>\n   ia ! i = x \\<Longrightarrow>\n   input2state ia $ i = Some x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < length ia; ia ! i = x\\<rbrakk>\n    \\<Longrightarrow> input2state ia $ i = Some x", "by (simp add: input2state_nth)"], ["", "lemma input2state_take: \"x1 < A \\<Longrightarrow>\n   A \\<le> length i \\<Longrightarrow>\n   x = vname.I x1 \\<Longrightarrow>\n   input2state i $ x1 = input2state (take A i) $ x1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x1 < A; A \\<le> length i; x = I x1\\<rbrakk>\n    \\<Longrightarrow> input2state i $ x1 = input2state (take A i) $ x1", "proof(induct i)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>x1 < A; A \\<le> length []; x = I x1\\<rbrakk>\n    \\<Longrightarrow> input2state [] $ x1 = input2state (take A []) $ x1\n 2. \\<And>a i.\n       \\<lbrakk>\\<lbrakk>x1 < A; A \\<le> length i; x = I x1\\<rbrakk>\n                \\<Longrightarrow> input2state i $ x1 =\n                                  input2state (take A i) $ x1;\n        x1 < A; A \\<le> length (a # i); x = I x1\\<rbrakk>\n       \\<Longrightarrow> input2state (a # i) $ x1 =\n                         input2state (take A (a # i)) $ x1", "case Nil"], ["proof (state)\nthis:\n  x1 < A\n  A \\<le> length []\n  x = I x1\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x1 < A; A \\<le> length []; x = I x1\\<rbrakk>\n    \\<Longrightarrow> input2state [] $ x1 = input2state (take A []) $ x1\n 2. \\<And>a i.\n       \\<lbrakk>\\<lbrakk>x1 < A; A \\<le> length i; x = I x1\\<rbrakk>\n                \\<Longrightarrow> input2state i $ x1 =\n                                  input2state (take A i) $ x1;\n        x1 < A; A \\<le> length (a # i); x = I x1\\<rbrakk>\n       \\<Longrightarrow> input2state (a # i) $ x1 =\n                         input2state (take A (a # i)) $ x1", "then"], ["proof (chain)\npicking this:\n  x1 < A\n  A \\<le> length []\n  x = I x1", "show ?case"], ["proof (prove)\nusing this:\n  x1 < A\n  A \\<le> length []\n  x = I x1\n\ngoal (1 subgoal):\n 1. input2state [] $ x1 = input2state (take A []) $ x1", "by simp"], ["proof (state)\nthis:\n  input2state [] $ x1 = input2state (take A []) $ x1\n\ngoal (1 subgoal):\n 1. \\<And>a i.\n       \\<lbrakk>\\<lbrakk>x1 < A; A \\<le> length i; x = I x1\\<rbrakk>\n                \\<Longrightarrow> input2state i $ x1 =\n                                  input2state (take A i) $ x1;\n        x1 < A; A \\<le> length (a # i); x = I x1\\<rbrakk>\n       \\<Longrightarrow> input2state (a # i) $ x1 =\n                         input2state (take A (a # i)) $ x1", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a i.\n       \\<lbrakk>\\<lbrakk>x1 < A; A \\<le> length i; x = I x1\\<rbrakk>\n                \\<Longrightarrow> input2state i $ x1 =\n                                  input2state (take A i) $ x1;\n        x1 < A; A \\<le> length (a # i); x = I x1\\<rbrakk>\n       \\<Longrightarrow> input2state (a # i) $ x1 =\n                         input2state (take A (a # i)) $ x1", "case (Cons a i)"], ["proof (state)\nthis:\n  \\<lbrakk>x1 < A; A \\<le> length i; x = I x1\\<rbrakk>\n  \\<Longrightarrow> input2state i $ x1 = input2state (take A i) $ x1\n  x1 < A\n  A \\<le> length (a # i)\n  x = I x1\n\ngoal (1 subgoal):\n 1. \\<And>a i.\n       \\<lbrakk>\\<lbrakk>x1 < A; A \\<le> length i; x = I x1\\<rbrakk>\n                \\<Longrightarrow> input2state i $ x1 =\n                                  input2state (take A i) $ x1;\n        x1 < A; A \\<le> length (a # i); x = I x1\\<rbrakk>\n       \\<Longrightarrow> input2state (a # i) $ x1 =\n                         input2state (take A (a # i)) $ x1", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>x1 < A; A \\<le> length i; x = I x1\\<rbrakk>\n  \\<Longrightarrow> input2state i $ x1 = input2state (take A i) $ x1\n  x1 < A\n  A \\<le> length (a # i)\n  x = I x1", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>x1 < A; A \\<le> length i; x = I x1\\<rbrakk>\n  \\<Longrightarrow> input2state i $ x1 = input2state (take A i) $ x1\n  x1 < A\n  A \\<le> length (a # i)\n  x = I x1\n\ngoal (1 subgoal):\n 1. input2state (a # i) $ x1 = input2state (take A (a # i)) $ x1", "by (simp add: input2state_nth)"], ["proof (state)\nthis:\n  input2state (a # i) $ x1 = input2state (take A (a # i)) $ x1\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma input2state_not_None:\n  \"(input2state i $ x \\<noteq> None) \\<Longrightarrow> (x < length i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. input2state i $ x \\<noteq> None \\<Longrightarrow> x < length i", "using input2state_within_bounds"], ["proof (prove)\nusing this:\n  input2state ?i $ ?x = Some ?a \\<Longrightarrow> ?x < length ?i\n\ngoal (1 subgoal):\n 1. input2state i $ x \\<noteq> None \\<Longrightarrow> x < length i", "by blast"], ["", "lemma input2state_Some:\n  \"(\\<exists>v. input2state i $ x = Some v) = (x < length i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>v. input2state i $ x = Some v) = (x < length i)", "apply standard"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<exists>v. input2state i $ x = Some v \\<Longrightarrow> x < length i\n 2. x < length i \\<Longrightarrow> \\<exists>v. input2state i $ x = Some v", "using input2state_within_bounds"], ["proof (prove)\nusing this:\n  input2state ?i $ ?x = Some ?a \\<Longrightarrow> ?x < length ?i\n\ngoal (2 subgoals):\n 1. \\<exists>v. input2state i $ x = Some v \\<Longrightarrow> x < length i\n 2. x < length i \\<Longrightarrow> \\<exists>v. input2state i $ x = Some v", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. x < length i \\<Longrightarrow> \\<exists>v. input2state i $ x = Some v", "by (simp add: input2state_nth)"], ["", "lemma input2state_cons: \"x1 > 0 \\<Longrightarrow>\n   x1 < length ia \\<Longrightarrow>\n   input2state (a # ia) $ x1 = input2state ia $ (x1-1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < x1; x1 < length ia\\<rbrakk>\n    \\<Longrightarrow> input2state (a # ia) $ x1 = input2state ia $ (x1 - 1)", "by (simp add: input2state_nth)"], ["", "lemma input2state_cons_shift:\n  \"input2state i $ x1 = Some a \\<Longrightarrow> input2state (b # i) $ (Suc x1) = Some a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. input2state i $ x1 = Some a \\<Longrightarrow>\n    input2state (b # i) $ (Suc x1) = Some a", "proof(induct i rule: rev_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. input2state [] $ x1 = Some a \\<Longrightarrow>\n    input2state [b] $ (Suc x1) = Some a\n 2. \\<And>x xs.\n       \\<lbrakk>input2state xs $ x1 = Some a \\<Longrightarrow>\n                input2state (b # xs) $ (Suc x1) = Some a;\n        input2state (xs @ [x]) $ x1 = Some a\\<rbrakk>\n       \\<Longrightarrow> input2state (b # xs @ [x]) $ (Suc x1) = Some a", "case Nil"], ["proof (state)\nthis:\n  input2state [] $ x1 = Some a\n\ngoal (2 subgoals):\n 1. input2state [] $ x1 = Some a \\<Longrightarrow>\n    input2state [b] $ (Suc x1) = Some a\n 2. \\<And>x xs.\n       \\<lbrakk>input2state xs $ x1 = Some a \\<Longrightarrow>\n                input2state (b # xs) $ (Suc x1) = Some a;\n        input2state (xs @ [x]) $ x1 = Some a\\<rbrakk>\n       \\<Longrightarrow> input2state (b # xs @ [x]) $ (Suc x1) = Some a", "then"], ["proof (chain)\npicking this:\n  input2state [] $ x1 = Some a", "show ?case"], ["proof (prove)\nusing this:\n  input2state [] $ x1 = Some a\n\ngoal (1 subgoal):\n 1. input2state [b] $ (Suc x1) = Some a", "by (simp add: input2state_def)"], ["proof (state)\nthis:\n  input2state [b] $ (Suc x1) = Some a\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>input2state xs $ x1 = Some a \\<Longrightarrow>\n                input2state (b # xs) $ (Suc x1) = Some a;\n        input2state (xs @ [x]) $ x1 = Some a\\<rbrakk>\n       \\<Longrightarrow> input2state (b # xs @ [x]) $ (Suc x1) = Some a", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>input2state xs $ x1 = Some a \\<Longrightarrow>\n                input2state (b # xs) $ (Suc x1) = Some a;\n        input2state (xs @ [x]) $ x1 = Some a\\<rbrakk>\n       \\<Longrightarrow> input2state (b # xs @ [x]) $ (Suc x1) = Some a", "case (snoc x xs)"], ["proof (state)\nthis:\n  input2state xs $ x1 = Some a \\<Longrightarrow>\n  input2state (b # xs) $ (Suc x1) = Some a\n  input2state (xs @ [x]) $ x1 = Some a\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>input2state xs $ x1 = Some a \\<Longrightarrow>\n                input2state (b # xs) $ (Suc x1) = Some a;\n        input2state (xs @ [x]) $ x1 = Some a\\<rbrakk>\n       \\<Longrightarrow> input2state (b # xs @ [x]) $ (Suc x1) = Some a", "then"], ["proof (chain)\npicking this:\n  input2state xs $ x1 = Some a \\<Longrightarrow>\n  input2state (b # xs) $ (Suc x1) = Some a\n  input2state (xs @ [x]) $ x1 = Some a", "show ?case"], ["proof (prove)\nusing this:\n  input2state xs $ x1 = Some a \\<Longrightarrow>\n  input2state (b # xs) $ (Suc x1) = Some a\n  input2state (xs @ [x]) $ x1 = Some a\n\ngoal (1 subgoal):\n 1. input2state (b # xs @ [x]) $ (Suc x1) = Some a", "using input2state_within_bounds[of xs x1 a]"], ["proof (prove)\nusing this:\n  input2state xs $ x1 = Some a \\<Longrightarrow>\n  input2state (b # xs) $ (Suc x1) = Some a\n  input2state (xs @ [x]) $ x1 = Some a\n  input2state xs $ x1 = Some a \\<Longrightarrow> x1 < length xs\n\ngoal (1 subgoal):\n 1. input2state (b # xs @ [x]) $ (Suc x1) = Some a", "using input2state_cons[of \"Suc x1\" \"xs @ [x]\" b]"], ["proof (prove)\nusing this:\n  input2state xs $ x1 = Some a \\<Longrightarrow>\n  input2state (b # xs) $ (Suc x1) = Some a\n  input2state (xs @ [x]) $ x1 = Some a\n  input2state xs $ x1 = Some a \\<Longrightarrow> x1 < length xs\n  \\<lbrakk>0 < Suc x1; Suc x1 < length (xs @ [x])\\<rbrakk>\n  \\<Longrightarrow> input2state (b # xs @ [x]) $ (Suc x1) =\n                    input2state (xs @ [x]) $ (Suc x1 - 1)\n\ngoal (1 subgoal):\n 1. input2state (b # xs @ [x]) $ (Suc x1) = Some a", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>input2state xs $ x1 = Some a \\<Longrightarrow>\n             input2state (b # xs) $ (Suc x1) = Some a;\n     input2state (xs @ [x]) $ x1 = Some a;\n     input2state xs $ x1 = Some a \\<Longrightarrow> x1 < length xs;\n     x1 < length xs \\<Longrightarrow>\n     input2state (b # xs @ [x]) $ (Suc x1) = Some a\\<rbrakk>\n    \\<Longrightarrow> input2state (b # xs @ [x]) $ (Suc x1) = Some a", "apply (case_tac \"x1 < length xs\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>input2state xs $ x1 = Some a \\<Longrightarrow>\n             input2state (b # xs) $ (Suc x1) = Some a;\n     input2state (xs @ [x]) $ x1 = Some a;\n     input2state xs $ x1 = Some a \\<Longrightarrow> x1 < length xs;\n     x1 < length xs \\<Longrightarrow>\n     input2state (b # xs @ [x]) $ (Suc x1) = Some a;\n     x1 < length xs\\<rbrakk>\n    \\<Longrightarrow> input2state (b # xs @ [x]) $ (Suc x1) = Some a\n 2. \\<lbrakk>input2state xs $ x1 = Some a \\<Longrightarrow>\n             input2state (b # xs) $ (Suc x1) = Some a;\n     input2state (xs @ [x]) $ x1 = Some a;\n     input2state xs $ x1 = Some a \\<Longrightarrow> x1 < length xs;\n     x1 < length xs \\<Longrightarrow>\n     input2state (b # xs @ [x]) $ (Suc x1) = Some a;\n     \\<not> x1 < length xs\\<rbrakk>\n    \\<Longrightarrow> input2state (b # xs @ [x]) $ (Suc x1) = Some a", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>input2state xs $ x1 = Some a \\<Longrightarrow>\n             input2state (b # xs) $ (Suc x1) = Some a;\n     input2state (xs @ [x]) $ x1 = Some a;\n     input2state xs $ x1 = Some a \\<Longrightarrow> x1 < length xs;\n     x1 < length xs \\<Longrightarrow>\n     input2state (b # xs @ [x]) $ (Suc x1) = Some a;\n     \\<not> x1 < length xs\\<rbrakk>\n    \\<Longrightarrow> input2state (b # xs @ [x]) $ (Suc x1) = Some a", "by (metis finfun_upd_apply input2state_append input2state_nth length_Cons length_append_singleton lessI list.sel(3) nth_tl)"], ["proof (state)\nthis:\n  input2state (b # xs @ [x]) $ (Suc x1) = Some a\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma input2state_exists: \"\\<exists>i. input2state i $ x1 = Some a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>i. input2state i $ x1 = Some a", "proof(induct x1)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>i. input2state i $ 0 = Some a\n 2. \\<And>x1.\n       \\<exists>i. input2state i $ x1 = Some a \\<Longrightarrow>\n       \\<exists>i. input2state i $ (Suc x1) = Some a", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<exists>i. input2state i $ 0 = Some a\n 2. \\<And>x1.\n       \\<exists>i. input2state i $ x1 = Some a \\<Longrightarrow>\n       \\<exists>i. input2state i $ (Suc x1) = Some a", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>i. input2state i $ 0 = Some a", "apply (rule_tac x=\"[a]\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. input2state [a] $ 0 = Some a", "by (simp add: input2state_def)"], ["proof (state)\nthis:\n  \\<exists>i. input2state i $ 0 = Some a\n\ngoal (1 subgoal):\n 1. \\<And>x1.\n       \\<exists>i. input2state i $ x1 = Some a \\<Longrightarrow>\n       \\<exists>i. input2state i $ (Suc x1) = Some a", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1.\n       \\<exists>i. input2state i $ x1 = Some a \\<Longrightarrow>\n       \\<exists>i. input2state i $ (Suc x1) = Some a", "case (Suc x1)"], ["proof (state)\nthis:\n  \\<exists>i. input2state i $ x1 = Some a\n\ngoal (1 subgoal):\n 1. \\<And>x1.\n       \\<exists>i. input2state i $ x1 = Some a \\<Longrightarrow>\n       \\<exists>i. input2state i $ (Suc x1) = Some a", "then"], ["proof (chain)\npicking this:\n  \\<exists>i. input2state i $ x1 = Some a", "show ?case"], ["proof (prove)\nusing this:\n  \\<exists>i. input2state i $ x1 = Some a\n\ngoal (1 subgoal):\n 1. \\<exists>i. input2state i $ (Suc x1) = Some a", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       input2state i $ x1 = Some a \\<Longrightarrow>\n       \\<exists>i. input2state i $ (Suc x1) = Some a", "apply (rule_tac x=\"a#i\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       input2state i $ x1 = Some a \\<Longrightarrow>\n       input2state (a # i) $ (Suc x1) = Some a", "by (simp add: input2state_cons_shift)"], ["proof (state)\nthis:\n  \\<exists>i. input2state i $ (Suc x1) = Some a\n\ngoal:\nNo subgoals!", "qed"], ["", "primrec repeat :: \"nat \\<Rightarrow> 'a \\<Rightarrow> 'a list\" where\n  \"repeat 0 _ = []\" |\n  \"repeat (Suc m) a = a#(repeat m a)\""], ["", "lemma length_repeat: \"length (repeat n a) = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (repeat n a) = n", "proof(induct n)"], ["proof (state)\ngoal (2 subgoals):\n 1. length (repeat 0 a) = 0\n 2. \\<And>n.\n       length (repeat n a) = n \\<Longrightarrow>\n       length (repeat (Suc n) a) = Suc n", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. length (repeat 0 a) = 0\n 2. \\<And>n.\n       length (repeat n a) = n \\<Longrightarrow>\n       length (repeat (Suc n) a) = Suc n", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (repeat 0 a) = 0", "by simp"], ["proof (state)\nthis:\n  length (repeat 0 a) = 0\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       length (repeat n a) = n \\<Longrightarrow>\n       length (repeat (Suc n) a) = Suc n", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       length (repeat n a) = n \\<Longrightarrow>\n       length (repeat (Suc n) a) = Suc n", "case (Suc a)"], ["proof (state)\nthis:\n  length (repeat a a) = a\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       length (repeat n a) = n \\<Longrightarrow>\n       length (repeat (Suc n) a) = Suc n", "then"], ["proof (chain)\npicking this:\n  length (repeat a a) = a", "show ?case"], ["proof (prove)\nusing this:\n  length (repeat a a) = a\n\ngoal (1 subgoal):\n 1. length (repeat (Suc a) a) = Suc a", "by simp"], ["proof (state)\nthis:\n  length (repeat (Suc a) a) = Suc a\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma length_append_repeat: \"length (i@(repeat a y)) \\<ge> length i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length i \\<le> length (i @ repeat a y)", "by simp"], ["", "lemma length_input2state_repeat:\n  \"input2state i $ x = Some a \\<Longrightarrow> y < length (i @ repeat y a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. input2state i $ x = Some a \\<Longrightarrow> y < length (i @ repeat y a)", "by (metis append.simps(1) append_eq_append_conv input2state_within_bounds length_append length_repeat list.size(3) neqE not_add_less2 zero_order(3))"], ["", "lemma input2state_double_exists:\n  \"\\<exists>i. input2state i $ x = Some a \\<and> input2state i $ y = Some a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>i. input2state i $ x = Some a \\<and> input2state i $ y = Some a", "apply (insert input2state_exists[of x a])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>i. input2state i $ x = Some a \\<Longrightarrow>\n    \\<exists>i. input2state i $ x = Some a \\<and> input2state i $ y = Some a", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       input2state i $ x = Some a \\<Longrightarrow>\n       \\<exists>i.\n          input2state i $ x = Some a \\<and> input2state i $ y = Some a", "apply (case_tac \"x \\<ge> y\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>input2state i $ x = Some a; y \\<le> x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            input2state i $ x = Some a \\<and>\n                            input2state i $ y = Some a\n 2. \\<And>i.\n       \\<lbrakk>input2state i $ x = Some a; \\<not> y \\<le> x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            input2state i $ x = Some a \\<and>\n                            input2state i $ y = Some a", "apply (rule_tac x=\"list_update i y a\" in exI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>input2state i $ x = Some a; y \\<le> x\\<rbrakk>\n       \\<Longrightarrow> input2state (i[y := a]) $ x = Some a \\<and>\n                         input2state (i[y := a]) $ y = Some a\n 2. \\<And>i.\n       \\<lbrakk>input2state i $ x = Some a; \\<not> y \\<le> x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            input2state i $ x = Some a \\<and>\n                            input2state i $ y = Some a", "apply (metis (no_types, lifting) input2state_within_bounds input2state_nth input2state_out_of_bounds le_trans length_list_update not_le_imp_less nth_list_update_eq nth_list_update_neq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>input2state i $ x = Some a; \\<not> y \\<le> x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            input2state i $ x = Some a \\<and>\n                            input2state i $ y = Some a", "apply (rule_tac x=\"list_update (i@(repeat y a)) y a\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>input2state i $ x = Some a; \\<not> y \\<le> x\\<rbrakk>\n       \\<Longrightarrow> input2state ((i @ repeat y a)[y := a]) $ x =\n                         Some a \\<and>\n                         input2state ((i @ repeat y a)[y := a]) $ y = Some a", "apply (simp add: not_le)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>input2state i $ x = Some a; x < y\\<rbrakk>\n       \\<Longrightarrow> input2state ((i @ repeat y a)[y := a]) $ x =\n                         Some a \\<and>\n                         input2state ((i @ repeat y a)[y := a]) $ y = Some a", "by (metis length_input2state_repeat input2state_nth input2state_out_of_bounds le_trans length_append_repeat length_list_update not_le_imp_less nth_append nth_list_update_eq nth_list_update_neq option.distinct(1))"], ["", "lemma input2state_double_exists_2:\n  \"x \\<noteq> y \\<Longrightarrow> \\<exists>i. input2state i $ x = Some a \\<and> input2state i $ y = Some a'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow>\n    \\<exists>i.\n       input2state i $ x = Some a \\<and> input2state i $ y = Some a'", "apply (insert input2state_exists[of x a])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> y; \\<exists>i. input2state i $ x = Some a\\<rbrakk>\n    \\<Longrightarrow> \\<exists>i.\n                         input2state i $ x = Some a \\<and>\n                         input2state i $ y = Some a'", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>x \\<noteq> y; input2state i $ x = Some a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            input2state i $ x = Some a \\<and>\n                            input2state i $ y = Some a'", "apply (case_tac \"x \\<ge> y\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>x \\<noteq> y; input2state i $ x = Some a; y \\<le> x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            input2state i $ x = Some a \\<and>\n                            input2state i $ y = Some a'\n 2. \\<And>i.\n       \\<lbrakk>x \\<noteq> y; input2state i $ x = Some a;\n        \\<not> y \\<le> x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            input2state i $ x = Some a \\<and>\n                            input2state i $ y = Some a'", "apply (rule_tac x=\"list_update i y a'\" in exI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>x \\<noteq> y; input2state i $ x = Some a; y \\<le> x\\<rbrakk>\n       \\<Longrightarrow> input2state (i[y := a']) $ x = Some a \\<and>\n                         input2state (i[y := a']) $ y = Some a'\n 2. \\<And>i.\n       \\<lbrakk>x \\<noteq> y; input2state i $ x = Some a;\n        \\<not> y \\<le> x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            input2state i $ x = Some a \\<and>\n                            input2state i $ y = Some a'", "apply (metis (no_types, lifting) input2state_within_bounds input2state_nth input2state_out_of_bounds le_trans length_list_update not_le_imp_less nth_list_update_eq nth_list_update_neq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>x \\<noteq> y; input2state i $ x = Some a;\n        \\<not> y \\<le> x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            input2state i $ x = Some a \\<and>\n                            input2state i $ y = Some a'", "apply (rule_tac x=\"list_update (i@(repeat y a')) y a'\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>x \\<noteq> y; input2state i $ x = Some a;\n        \\<not> y \\<le> x\\<rbrakk>\n       \\<Longrightarrow> input2state ((i @ repeat y a')[y := a']) $ x =\n                         Some a \\<and>\n                         input2state ((i @ repeat y a')[y := a']) $ y =\n                         Some a'", "apply (simp add: not_le)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>input2state i $ x = Some a; x < y\\<rbrakk>\n       \\<Longrightarrow> input2state ((i @ repeat y a')[y := a']) $ x =\n                         Some a \\<and>\n                         input2state ((i @ repeat y a')[y := a']) $ y =\n                         Some a'", "apply standard"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>input2state i $ x = Some a; x < y\\<rbrakk>\n       \\<Longrightarrow> input2state ((i @ repeat y a')[y := a']) $ x =\n                         Some a\n 2. \\<And>i.\n       \\<lbrakk>input2state i $ x = Some a; x < y\\<rbrakk>\n       \\<Longrightarrow> input2state ((i @ repeat y a')[y := a']) $ y =\n                         Some a'", "apply (metis input2state_nth input2state_within_bounds le_trans length_append_repeat length_list_update linorder_not_le nth_append nth_list_update_neq order_refl)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>input2state i $ x = Some a; x < y\\<rbrakk>\n       \\<Longrightarrow> input2state ((i @ repeat y a')[y := a']) $ y =\n                         Some a'", "by (metis input2state_nth length_append length_input2state_repeat length_list_update length_repeat nth_list_update_eq)"], ["", "definition join_ir :: \"value list \\<Rightarrow> registers \\<Rightarrow> vname datastate\" where\n  \"join_ir i r \\<equiv> (\\<lambda>x. case x of\n    R n \\<Rightarrow> r $ n |\n    I n \\<Rightarrow> (input2state i) $ n\n  )\""], ["", "lemmas datastate = join_ir_def input2state_def"], ["", "lemma join_ir_empty [simp]: \"join_ir [] <> = (\\<lambda>x. None)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. join_ir [] <> = Map.empty", "apply (rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. join_ir [] <> x = None", "apply (simp add: join_ir_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (case x of I n \\<Rightarrow> input2state [] $ n\n        | R n \\<Rightarrow> <> $ n) =\n       None", "apply (case_tac x)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x x1.\n       x = I x1 \\<Longrightarrow>\n       (case x of I n \\<Rightarrow> input2state [] $ n\n        | R n \\<Rightarrow> <> $ n) =\n       None\n 2. \\<And>x x2.\n       x = R x2 \\<Longrightarrow>\n       (case x of I n \\<Rightarrow> input2state [] $ n\n        | R n \\<Rightarrow> <> $ n) =\n       None", "apply (simp add: input2state_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x x2.\n       x = R x2 \\<Longrightarrow>\n       (case x of I n \\<Rightarrow> input2state [] $ n\n        | R n \\<Rightarrow> <> $ n) =\n       None", "by (simp add: empty_None)"], ["", "lemma join_ir_R [simp]: \"(join_ir i r) (R n) = r $ n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. join_ir i r (R n) = r $ n", "by (simp add: join_ir_def)"], ["", "lemma join_ir_double_exists:\n  \"\\<exists>i r. join_ir i r v = Some a \\<and> join_ir i r v' = Some a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>i r. join_ir i r v = Some a \\<and> join_ir i r v' = Some a", "proof(cases v)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       v = I x1 \\<Longrightarrow>\n       \\<exists>i r. join_ir i r v = Some a \\<and> join_ir i r v' = Some a\n 2. \\<And>x2.\n       v = R x2 \\<Longrightarrow>\n       \\<exists>i r. join_ir i r v = Some a \\<and> join_ir i r v' = Some a", "case (I x1)"], ["proof (state)\nthis:\n  v = I x1\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       v = I x1 \\<Longrightarrow>\n       \\<exists>i r. join_ir i r v = Some a \\<and> join_ir i r v' = Some a\n 2. \\<And>x2.\n       v = R x2 \\<Longrightarrow>\n       \\<exists>i r. join_ir i r v = Some a \\<and> join_ir i r v' = Some a", "then"], ["proof (chain)\npicking this:\n  v = I x1", "show ?thesis"], ["proof (prove)\nusing this:\n  v = I x1\n\ngoal (1 subgoal):\n 1. \\<exists>i r. join_ir i r v = Some a \\<and> join_ir i r v' = Some a", "apply (simp add: join_ir_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. v = I x1 \\<Longrightarrow>\n    \\<exists>i.\n       input2state i $ x1 = Some a \\<and>\n       (\\<exists>r.\n           (case v' of I x \\<Rightarrow> input2state i $ x\n            | R x \\<Rightarrow> r $ x) =\n           Some a)", "apply (cases v')"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1a.\n       \\<lbrakk>v = I x1; v' = I x1a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            input2state i $ x1 = Some a \\<and>\n                            (\\<exists>r.\n                                (case v' of\n                                 I x \\<Rightarrow> input2state i $ x\n                                 | R x \\<Rightarrow> r $ x) =\n                                Some a)\n 2. \\<And>x2.\n       \\<lbrakk>v = I x1; v' = R x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            input2state i $ x1 = Some a \\<and>\n                            (\\<exists>r.\n                                (case v' of\n                                 I x \\<Rightarrow> input2state i $ x\n                                 | R x \\<Rightarrow> r $ x) =\n                                Some a)", "apply (simp add: input2state_double_exists input2state_exists)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<lbrakk>v = I x1; v' = R x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            input2state i $ x1 = Some a \\<and>\n                            (\\<exists>r.\n                                (case v' of\n                                 I x \\<Rightarrow> input2state i $ x\n                                 | R x \\<Rightarrow> r $ x) =\n                                Some a)", "using input2state_exists"], ["proof (prove)\nusing this:\n  \\<exists>i. input2state i $ ?x1.0 = Some ?a\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<lbrakk>v = I x1; v' = R x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            input2state i $ x1 = Some a \\<and>\n                            (\\<exists>r.\n                                (case v' of\n                                 I x \\<Rightarrow> input2state i $ x\n                                 | R x \\<Rightarrow> r $ x) =\n                                Some a)", "by auto"], ["proof (state)\nthis:\n  \\<exists>i r. join_ir i r v = Some a \\<and> join_ir i r v' = Some a\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       v = R x2 \\<Longrightarrow>\n       \\<exists>i r. join_ir i r v = Some a \\<and> join_ir i r v' = Some a", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x2.\n       v = R x2 \\<Longrightarrow>\n       \\<exists>i r. join_ir i r v = Some a \\<and> join_ir i r v' = Some a", "case (R x2)"], ["proof (state)\nthis:\n  v = R x2\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       v = R x2 \\<Longrightarrow>\n       \\<exists>i r. join_ir i r v = Some a \\<and> join_ir i r v' = Some a", "then"], ["proof (chain)\npicking this:\n  v = R x2", "show ?thesis"], ["proof (prove)\nusing this:\n  v = R x2\n\ngoal (1 subgoal):\n 1. \\<exists>i r. join_ir i r v = Some a \\<and> join_ir i r v' = Some a", "apply (simp add: join_ir_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. v = R x2 \\<Longrightarrow>\n    \\<exists>i r.\n       r $ x2 = Some a \\<and>\n       (case v' of I n \\<Rightarrow> input2state i $ n\n        | R n \\<Rightarrow> r $ n) =\n       Some a", "apply (cases v')"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>v = R x2; v' = I x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i r.\n                            r $ x2 = Some a \\<and>\n                            (case v' of I n \\<Rightarrow> input2state i $ n\n                             | R n \\<Rightarrow> r $ n) =\n                            Some a\n 2. \\<And>x2a.\n       \\<lbrakk>v = R x2; v' = R x2a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i r.\n                            r $ x2 = Some a \\<and>\n                            (case v' of I n \\<Rightarrow> input2state i $ n\n                             | R n \\<Rightarrow> r $ n) =\n                            Some a", "using input2state_exists"], ["proof (prove)\nusing this:\n  \\<exists>i. input2state i $ ?x1.0 = Some ?a\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>v = R x2; v' = I x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i r.\n                            r $ x2 = Some a \\<and>\n                            (case v' of I n \\<Rightarrow> input2state i $ n\n                             | R n \\<Rightarrow> r $ n) =\n                            Some a\n 2. \\<And>x2a.\n       \\<lbrakk>v = R x2; v' = R x2a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i r.\n                            r $ x2 = Some a \\<and>\n                            (case v' of I n \\<Rightarrow> input2state i $ n\n                             | R n \\<Rightarrow> r $ n) =\n                            Some a", "apply force"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x2a.\n       \\<lbrakk>v = R x2; v' = R x2a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i r.\n                            r $ x2 = Some a \\<and>\n                            (case v' of I n \\<Rightarrow> input2state i $ n\n                             | R n \\<Rightarrow> r $ n) =\n                            Some a", "using input2state_double_exists"], ["proof (prove)\nusing this:\n  \\<exists>i.\n     input2state i $ ?x = Some ?a \\<and> input2state i $ ?y = Some ?a\n\ngoal (1 subgoal):\n 1. \\<And>x2a.\n       \\<lbrakk>v = R x2; v' = R x2a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i r.\n                            r $ x2 = Some a \\<and>\n                            (case v' of I n \\<Rightarrow> input2state i $ n\n                             | R n \\<Rightarrow> r $ n) =\n                            Some a", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>i r. join_ir i r v = Some a \\<and> join_ir i r v' = Some a\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma join_ir_double_exists_2:\n  \"v \\<noteq> v' \\<Longrightarrow> \\<exists>i r. join_ir i r v = Some a \\<and> join_ir i r v' = Some a'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<noteq> v' \\<Longrightarrow>\n    \\<exists>i r. join_ir i r v = Some a \\<and> join_ir i r v' = Some a'", "proof(cases v)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>v \\<noteq> v'; v = I x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i r.\n                            join_ir i r v = Some a \\<and>\n                            join_ir i r v' = Some a'\n 2. \\<And>x2.\n       \\<lbrakk>v \\<noteq> v'; v = R x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i r.\n                            join_ir i r v = Some a \\<and>\n                            join_ir i r v' = Some a'", "case (I x1)"], ["proof (state)\nthis:\n  v = I x1\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>v \\<noteq> v'; v = I x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i r.\n                            join_ir i r v = Some a \\<and>\n                            join_ir i r v' = Some a'\n 2. \\<And>x2.\n       \\<lbrakk>v \\<noteq> v'; v = R x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i r.\n                            join_ir i r v = Some a \\<and>\n                            join_ir i r v' = Some a'", "assume \"v \\<noteq> v'\""], ["proof (state)\nthis:\n  v \\<noteq> v'\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>v \\<noteq> v'; v = I x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i r.\n                            join_ir i r v = Some a \\<and>\n                            join_ir i r v' = Some a'\n 2. \\<And>x2.\n       \\<lbrakk>v \\<noteq> v'; v = R x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i r.\n                            join_ir i r v = Some a \\<and>\n                            join_ir i r v' = Some a'", "then"], ["proof (chain)\npicking this:\n  v \\<noteq> v'", "show ?thesis"], ["proof (prove)\nusing this:\n  v \\<noteq> v'\n\ngoal (1 subgoal):\n 1. \\<exists>i r. join_ir i r v = Some a \\<and> join_ir i r v' = Some a'", "using I input2state_exists"], ["proof (prove)\nusing this:\n  v \\<noteq> v'\n  v = I x1\n  \\<exists>i. input2state i $ ?x1.0 = Some ?a\n\ngoal (1 subgoal):\n 1. \\<exists>i r. join_ir i r v = Some a \\<and> join_ir i r v' = Some a'", "by (cases v', auto simp add: join_ir_def input2state_double_exists_2)"], ["proof (state)\nthis:\n  \\<exists>i r. join_ir i r v = Some a \\<and> join_ir i r v' = Some a'\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<lbrakk>v \\<noteq> v'; v = R x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i r.\n                            join_ir i r v = Some a \\<and>\n                            join_ir i r v' = Some a'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<lbrakk>v \\<noteq> v'; v = R x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i r.\n                            join_ir i r v = Some a \\<and>\n                            join_ir i r v' = Some a'", "case (R x2)"], ["proof (state)\nthis:\n  v = R x2\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<lbrakk>v \\<noteq> v'; v = R x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i r.\n                            join_ir i r v = Some a \\<and>\n                            join_ir i r v' = Some a'", "assume \"v \\<noteq> v'\""], ["proof (state)\nthis:\n  v \\<noteq> v'\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<lbrakk>v \\<noteq> v'; v = R x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i r.\n                            join_ir i r v = Some a \\<and>\n                            join_ir i r v' = Some a'", "then"], ["proof (chain)\npicking this:\n  v \\<noteq> v'", "show ?thesis"], ["proof (prove)\nusing this:\n  v \\<noteq> v'\n\ngoal (1 subgoal):\n 1. \\<exists>i r. join_ir i r v = Some a \\<and> join_ir i r v' = Some a'", "apply (simp add: join_ir_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<noteq> v' \\<Longrightarrow>\n    \\<exists>i r.\n       (case v of I n \\<Rightarrow> input2state i $ n\n        | R n \\<Rightarrow> r $ n) =\n       Some a \\<and>\n       (case v' of I n \\<Rightarrow> input2state i $ n\n        | R n \\<Rightarrow> r $ n) =\n       Some a'", "apply (cases v')"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>v \\<noteq> v'; v' = I x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i r.\n                            (case v of I n \\<Rightarrow> input2state i $ n\n                             | R n \\<Rightarrow> r $ n) =\n                            Some a \\<and>\n                            (case v' of I n \\<Rightarrow> input2state i $ n\n                             | R n \\<Rightarrow> r $ n) =\n                            Some a'\n 2. \\<And>x2.\n       \\<lbrakk>v \\<noteq> v'; v' = R x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i r.\n                            (case v of I n \\<Rightarrow> input2state i $ n\n                             | R n \\<Rightarrow> r $ n) =\n                            Some a \\<and>\n                            (case v' of I n \\<Rightarrow> input2state i $ n\n                             | R n \\<Rightarrow> r $ n) =\n                            Some a'", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>v \\<noteq> I x1; v' = I x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            (\\<exists>r.\n                                (case v of\n                                 I x \\<Rightarrow> input2state i $ x\n                                 | R x \\<Rightarrow> r $ x) =\n                                Some a) \\<and>\n                            input2state i $ x1 = Some a'\n 2. \\<And>x2.\n       \\<lbrakk>v \\<noteq> v'; v' = R x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i r.\n                            (case v of I n \\<Rightarrow> input2state i $ n\n                             | R n \\<Rightarrow> r $ n) =\n                            Some a \\<and>\n                            (case v' of I n \\<Rightarrow> input2state i $ n\n                             | R n \\<Rightarrow> r $ n) =\n                            Some a'", "using R input2state_exists"], ["proof (prove)\nusing this:\n  v = R x2\n  \\<exists>i. input2state i $ ?x1.0 = Some ?a\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>v \\<noteq> I x1; v' = I x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            (\\<exists>r.\n                                (case v of\n                                 I x \\<Rightarrow> input2state i $ x\n                                 | R x \\<Rightarrow> r $ x) =\n                                Some a) \\<and>\n                            input2state i $ x1 = Some a'\n 2. \\<And>x2.\n       \\<lbrakk>v \\<noteq> v'; v' = R x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i r.\n                            (case v of I n \\<Rightarrow> input2state i $ n\n                             | R n \\<Rightarrow> r $ n) =\n                            Some a \\<and>\n                            (case v' of I n \\<Rightarrow> input2state i $ n\n                             | R n \\<Rightarrow> r $ n) =\n                            Some a'", "apply auto[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<lbrakk>v \\<noteq> v'; v' = R x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i r.\n                            (case v of I n \\<Rightarrow> input2state i $ n\n                             | R n \\<Rightarrow> r $ n) =\n                            Some a \\<and>\n                            (case v' of I n \\<Rightarrow> input2state i $ n\n                             | R n \\<Rightarrow> r $ n) =\n                            Some a'", "apply (simp add: R)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x2a.\n       \\<lbrakk>x2 \\<noteq> x2a; v' = R x2a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r.\n                            r $ x2 = Some a \\<and> r $ x2a = Some a'", "apply (rule_tac x=\"<x2 $:= Some a,x2a $:= Some a'>\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x2a.\n       \\<lbrakk>x2 \\<noteq> x2a; v' = R x2a\\<rbrakk>\n       \\<Longrightarrow> <x2 $:= Some a, x2a $:= Some a'> $ x2 =\n                         Some a \\<and>\n                         <x2 $:= Some a, x2a $:= Some a'> $ x2a = Some a'", "by simp"], ["proof (state)\nthis:\n  \\<exists>i r. join_ir i r v = Some a \\<and> join_ir i r v' = Some a'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma exists_join_ir_ext: \"\\<exists>i r. join_ir i r v = s v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>i r. join_ir i r v = s v", "apply (simp add: join_ir_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>i r.\n       (case v of I n \\<Rightarrow> input2state i $ n\n        | R n \\<Rightarrow> r $ n) =\n       s v", "apply (case_tac \"s v\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. s v = None \\<Longrightarrow>\n    \\<exists>i r.\n       (case v of I n \\<Rightarrow> input2state i $ n\n        | R n \\<Rightarrow> r $ n) =\n       s v\n 2. \\<And>a.\n       s v = Some a \\<Longrightarrow>\n       \\<exists>i r.\n          (case v of I n \\<Rightarrow> input2state i $ n\n           | R n \\<Rightarrow> r $ n) =\n          s v", "apply (cases v)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>s v = None; v = I x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i r.\n                            (case v of I n \\<Rightarrow> input2state i $ n\n                             | R n \\<Rightarrow> r $ n) =\n                            s v\n 2. \\<And>x2.\n       \\<lbrakk>s v = None; v = R x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i r.\n                            (case v of I n \\<Rightarrow> input2state i $ n\n                             | R n \\<Rightarrow> r $ n) =\n                            s v\n 3. \\<And>a.\n       s v = Some a \\<Longrightarrow>\n       \\<exists>i r.\n          (case v of I n \\<Rightarrow> input2state i $ n\n           | R n \\<Rightarrow> r $ n) =\n          s v", "apply (rule_tac x=\"[]\" in exI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>s v = None; v = I x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r.\n                            (case v of I n \\<Rightarrow> input2state [] $ n\n                             | R n \\<Rightarrow> r $ n) =\n                            s v\n 2. \\<And>x2.\n       \\<lbrakk>s v = None; v = R x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i r.\n                            (case v of I n \\<Rightarrow> input2state i $ n\n                             | R n \\<Rightarrow> r $ n) =\n                            s v\n 3. \\<And>a.\n       s v = Some a \\<Longrightarrow>\n       \\<exists>i r.\n          (case v of I n \\<Rightarrow> input2state i $ n\n           | R n \\<Rightarrow> r $ n) =\n          s v", "apply (simp add: input2state_out_of_bounds)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>s v = None; v = R x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i r.\n                            (case v of I n \\<Rightarrow> input2state i $ n\n                             | R n \\<Rightarrow> r $ n) =\n                            s v\n 2. \\<And>a.\n       s v = Some a \\<Longrightarrow>\n       \\<exists>i r.\n          (case v of I n \\<Rightarrow> input2state i $ n\n           | R n \\<Rightarrow> r $ n) =\n          s v", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>s (R x2) = None; v = R x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r. r $ x2 = None\n 2. \\<And>a.\n       s v = Some a \\<Longrightarrow>\n       \\<exists>i r.\n          (case v of I n \\<Rightarrow> input2state i $ n\n           | R n \\<Rightarrow> r $ n) =\n          s v", "apply (rule_tac x=\"<>\" in exI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>s (R x2) = None; v = R x2\\<rbrakk>\n       \\<Longrightarrow> <> $ x2 = None\n 2. \\<And>a.\n       s v = Some a \\<Longrightarrow>\n       \\<exists>i r.\n          (case v of I n \\<Rightarrow> input2state i $ n\n           | R n \\<Rightarrow> r $ n) =\n          s v", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       s v = Some a \\<Longrightarrow>\n       \\<exists>i r.\n          (case v of I n \\<Rightarrow> input2state i $ n\n           | R n \\<Rightarrow> r $ n) =\n          s v", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       s v = Some a \\<Longrightarrow>\n       \\<exists>i r.\n          (case v of I n \\<Rightarrow> input2state i $ n\n           | R n \\<Rightarrow> r $ n) =\n          Some a", "apply (cases v)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a x1.\n       \\<lbrakk>s v = Some a; v = I x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i r.\n                            (case v of I n \\<Rightarrow> input2state i $ n\n                             | R n \\<Rightarrow> r $ n) =\n                            Some a\n 2. \\<And>a x2.\n       \\<lbrakk>s v = Some a; v = R x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i r.\n                            (case v of I n \\<Rightarrow> input2state i $ n\n                             | R n \\<Rightarrow> r $ n) =\n                            Some a", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a x1.\n       \\<lbrakk>s (I x1) = Some a; v = I x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i. input2state i $ x1 = Some a\n 2. \\<And>a x2.\n       \\<lbrakk>s v = Some a; v = R x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i r.\n                            (case v of I n \\<Rightarrow> input2state i $ n\n                             | R n \\<Rightarrow> r $ n) =\n                            Some a", "apply (simp add: input2state_exists)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a x2.\n       \\<lbrakk>s v = Some a; v = R x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i r.\n                            (case v of I n \\<Rightarrow> input2state i $ n\n                             | R n \\<Rightarrow> r $ n) =\n                            Some a", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a x2.\n       \\<lbrakk>s (R x2) = Some a; v = R x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r. r $ x2 = Some a", "apply (rule_tac x=\"<x2 $:= Some a>\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a x2.\n       \\<lbrakk>s (R x2) = Some a; v = R x2\\<rbrakk>\n       \\<Longrightarrow> <x2 $:= Some a> $ x2 = Some a", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma join_ir_nth [simp]:\n  \"i < length is \\<Longrightarrow> join_ir is r (I i) = Some (is ! i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < length is \\<Longrightarrow> join_ir is r (I i) = Some (is ! i)", "by (simp add: join_ir_def input2state_nth)"], ["", "fun aexp_constrains :: \"'a aexp \\<Rightarrow> 'a aexp \\<Rightarrow> bool\" where\n  \"aexp_constrains (L l) a = (L l = a)\" |\n  \"aexp_constrains (V v) v' = (V v = v')\" |\n  \"aexp_constrains (Plus a1 a2) v = ((Plus a1 a2) = v \\<or> (Plus a1 a2) = v \\<or> (aexp_constrains a1 v \\<or> aexp_constrains a2 v))\" |\n  \"aexp_constrains (Minus a1 a2) v = ((Minus a1 a2) = v \\<or> (aexp_constrains a1 v \\<or> aexp_constrains a2 v))\" |\n  \"aexp_constrains (Times a1 a2) v = ((Times a1 a2) = v \\<or> (aexp_constrains a1 v \\<or> aexp_constrains a2 v))\""], ["", "fun aexp_same_structure :: \"'a aexp \\<Rightarrow> 'a aexp \\<Rightarrow> bool\" where\n  \"aexp_same_structure (L v) (L v') = True\" |\n  \"aexp_same_structure (V v) (V v') = True\" |\n  \"aexp_same_structure (Plus a1 a2) (Plus a1' a2') = (aexp_same_structure a1 a1' \\<and> aexp_same_structure a2 a2')\" |\n  \"aexp_same_structure (Minus a1 a2) (Minus a1' a2') = (aexp_same_structure a1 a1' \\<and> aexp_same_structure a2 a2')\" |\n  \"aexp_same_structure _ _ = False\""], ["", "fun enumerate_aexp_inputs :: \"vname aexp \\<Rightarrow> nat set\" where\n  \"enumerate_aexp_inputs (L _) = {}\" |\n  \"enumerate_aexp_inputs (V (I n)) = {n}\" |\n  \"enumerate_aexp_inputs (V (R n)) = {}\" |\n  \"enumerate_aexp_inputs (Plus v va) = enumerate_aexp_inputs v \\<union> enumerate_aexp_inputs va\" |\n  \"enumerate_aexp_inputs (Minus v va) = enumerate_aexp_inputs v \\<union> enumerate_aexp_inputs va\" |\n  \"enumerate_aexp_inputs (Times v va) = enumerate_aexp_inputs v \\<union> enumerate_aexp_inputs va\""], ["", "lemma enumerate_aexp_inputs_list: \"\\<exists>l. enumerate_aexp_inputs a = set l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>l. enumerate_aexp_inputs a = set l", "proof(induct a)"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>x. \\<exists>l. enumerate_aexp_inputs (L x) = set l\n 2. \\<And>x. \\<exists>l. enumerate_aexp_inputs (V x) = set l\n 3. \\<And>a1 a2.\n       \\<lbrakk>\\<exists>l. enumerate_aexp_inputs a1 = set l;\n        \\<exists>l. enumerate_aexp_inputs a2 = set l\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l.\n                            enumerate_aexp_inputs (Plus a1 a2) = set l\n 4. \\<And>a1 a2.\n       \\<lbrakk>\\<exists>l. enumerate_aexp_inputs a1 = set l;\n        \\<exists>l. enumerate_aexp_inputs a2 = set l\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l.\n                            enumerate_aexp_inputs (Minus a1 a2) = set l\n 5. \\<And>a1 a2.\n       \\<lbrakk>\\<exists>l. enumerate_aexp_inputs a1 = set l;\n        \\<exists>l. enumerate_aexp_inputs a2 = set l\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l.\n                            enumerate_aexp_inputs (Times a1 a2) = set l", "case (L x)"], ["proof (state)\nthis:\n  \n\ngoal (5 subgoals):\n 1. \\<And>x. \\<exists>l. enumerate_aexp_inputs (L x) = set l\n 2. \\<And>x. \\<exists>l. enumerate_aexp_inputs (V x) = set l\n 3. \\<And>a1 a2.\n       \\<lbrakk>\\<exists>l. enumerate_aexp_inputs a1 = set l;\n        \\<exists>l. enumerate_aexp_inputs a2 = set l\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l.\n                            enumerate_aexp_inputs (Plus a1 a2) = set l\n 4. \\<And>a1 a2.\n       \\<lbrakk>\\<exists>l. enumerate_aexp_inputs a1 = set l;\n        \\<exists>l. enumerate_aexp_inputs a2 = set l\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l.\n                            enumerate_aexp_inputs (Minus a1 a2) = set l\n 5. \\<And>a1 a2.\n       \\<lbrakk>\\<exists>l. enumerate_aexp_inputs a1 = set l;\n        \\<exists>l. enumerate_aexp_inputs a2 = set l\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l.\n                            enumerate_aexp_inputs (Times a1 a2) = set l", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>l. enumerate_aexp_inputs (L x) = set l", "by simp"], ["proof (state)\nthis:\n  \\<exists>l. enumerate_aexp_inputs (L x) = set l\n\ngoal (4 subgoals):\n 1. \\<And>x. \\<exists>l. enumerate_aexp_inputs (V x) = set l\n 2. \\<And>a1 a2.\n       \\<lbrakk>\\<exists>l. enumerate_aexp_inputs a1 = set l;\n        \\<exists>l. enumerate_aexp_inputs a2 = set l\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l.\n                            enumerate_aexp_inputs (Plus a1 a2) = set l\n 3. \\<And>a1 a2.\n       \\<lbrakk>\\<exists>l. enumerate_aexp_inputs a1 = set l;\n        \\<exists>l. enumerate_aexp_inputs a2 = set l\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l.\n                            enumerate_aexp_inputs (Minus a1 a2) = set l\n 4. \\<And>a1 a2.\n       \\<lbrakk>\\<exists>l. enumerate_aexp_inputs a1 = set l;\n        \\<exists>l. enumerate_aexp_inputs a2 = set l\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l.\n                            enumerate_aexp_inputs (Times a1 a2) = set l", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x. \\<exists>l. enumerate_aexp_inputs (V x) = set l\n 2. \\<And>a1 a2.\n       \\<lbrakk>\\<exists>l. enumerate_aexp_inputs a1 = set l;\n        \\<exists>l. enumerate_aexp_inputs a2 = set l\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l.\n                            enumerate_aexp_inputs (Plus a1 a2) = set l\n 3. \\<And>a1 a2.\n       \\<lbrakk>\\<exists>l. enumerate_aexp_inputs a1 = set l;\n        \\<exists>l. enumerate_aexp_inputs a2 = set l\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l.\n                            enumerate_aexp_inputs (Minus a1 a2) = set l\n 4. \\<And>a1 a2.\n       \\<lbrakk>\\<exists>l. enumerate_aexp_inputs a1 = set l;\n        \\<exists>l. enumerate_aexp_inputs a2 = set l\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l.\n                            enumerate_aexp_inputs (Times a1 a2) = set l", "case (V x)"], ["proof (state)\nthis:\n  \n\ngoal (4 subgoals):\n 1. \\<And>x. \\<exists>l. enumerate_aexp_inputs (V x) = set l\n 2. \\<And>a1 a2.\n       \\<lbrakk>\\<exists>l. enumerate_aexp_inputs a1 = set l;\n        \\<exists>l. enumerate_aexp_inputs a2 = set l\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l.\n                            enumerate_aexp_inputs (Plus a1 a2) = set l\n 3. \\<And>a1 a2.\n       \\<lbrakk>\\<exists>l. enumerate_aexp_inputs a1 = set l;\n        \\<exists>l. enumerate_aexp_inputs a2 = set l\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l.\n                            enumerate_aexp_inputs (Minus a1 a2) = set l\n 4. \\<And>a1 a2.\n       \\<lbrakk>\\<exists>l. enumerate_aexp_inputs a1 = set l;\n        \\<exists>l. enumerate_aexp_inputs a2 = set l\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l.\n                            enumerate_aexp_inputs (Times a1 a2) = set l", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>l. enumerate_aexp_inputs (V x) = set l", "apply (cases x)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       x = I x1 \\<Longrightarrow>\n       \\<exists>l. enumerate_aexp_inputs (V x) = set l\n 2. \\<And>x2.\n       x = R x2 \\<Longrightarrow>\n       \\<exists>l. enumerate_aexp_inputs (V x) = set l", "apply (metis empty_set enumerate_aexp_inputs.simps(2) list.simps(15))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x2.\n       x = R x2 \\<Longrightarrow>\n       \\<exists>l. enumerate_aexp_inputs (V x) = set l", "by simp"], ["proof (state)\nthis:\n  \\<exists>l. enumerate_aexp_inputs (V x) = set l\n\ngoal (3 subgoals):\n 1. \\<And>a1 a2.\n       \\<lbrakk>\\<exists>l. enumerate_aexp_inputs a1 = set l;\n        \\<exists>l. enumerate_aexp_inputs a2 = set l\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l.\n                            enumerate_aexp_inputs (Plus a1 a2) = set l\n 2. \\<And>a1 a2.\n       \\<lbrakk>\\<exists>l. enumerate_aexp_inputs a1 = set l;\n        \\<exists>l. enumerate_aexp_inputs a2 = set l\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l.\n                            enumerate_aexp_inputs (Minus a1 a2) = set l\n 3. \\<And>a1 a2.\n       \\<lbrakk>\\<exists>l. enumerate_aexp_inputs a1 = set l;\n        \\<exists>l. enumerate_aexp_inputs a2 = set l\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l.\n                            enumerate_aexp_inputs (Times a1 a2) = set l", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>a1 a2.\n       \\<lbrakk>\\<exists>l. enumerate_aexp_inputs a1 = set l;\n        \\<exists>l. enumerate_aexp_inputs a2 = set l\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l.\n                            enumerate_aexp_inputs (Plus a1 a2) = set l\n 2. \\<And>a1 a2.\n       \\<lbrakk>\\<exists>l. enumerate_aexp_inputs a1 = set l;\n        \\<exists>l. enumerate_aexp_inputs a2 = set l\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l.\n                            enumerate_aexp_inputs (Minus a1 a2) = set l\n 3. \\<And>a1 a2.\n       \\<lbrakk>\\<exists>l. enumerate_aexp_inputs a1 = set l;\n        \\<exists>l. enumerate_aexp_inputs a2 = set l\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l.\n                            enumerate_aexp_inputs (Times a1 a2) = set l", "case (Plus a1 a2)"], ["proof (state)\nthis:\n  \\<exists>l. enumerate_aexp_inputs a1 = set l\n  \\<exists>l. enumerate_aexp_inputs a2 = set l\n\ngoal (3 subgoals):\n 1. \\<And>a1 a2.\n       \\<lbrakk>\\<exists>l. enumerate_aexp_inputs a1 = set l;\n        \\<exists>l. enumerate_aexp_inputs a2 = set l\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l.\n                            enumerate_aexp_inputs (Plus a1 a2) = set l\n 2. \\<And>a1 a2.\n       \\<lbrakk>\\<exists>l. enumerate_aexp_inputs a1 = set l;\n        \\<exists>l. enumerate_aexp_inputs a2 = set l\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l.\n                            enumerate_aexp_inputs (Minus a1 a2) = set l\n 3. \\<And>a1 a2.\n       \\<lbrakk>\\<exists>l. enumerate_aexp_inputs a1 = set l;\n        \\<exists>l. enumerate_aexp_inputs a2 = set l\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l.\n                            enumerate_aexp_inputs (Times a1 a2) = set l", "then"], ["proof (chain)\npicking this:\n  \\<exists>l. enumerate_aexp_inputs a1 = set l\n  \\<exists>l. enumerate_aexp_inputs a2 = set l", "show ?case"], ["proof (prove)\nusing this:\n  \\<exists>l. enumerate_aexp_inputs a1 = set l\n  \\<exists>l. enumerate_aexp_inputs a2 = set l\n\ngoal (1 subgoal):\n 1. \\<exists>l. enumerate_aexp_inputs (Plus a1 a2) = set l", "by (metis enumerate_aexp_inputs.simps(4) set_append)"], ["proof (state)\nthis:\n  \\<exists>l. enumerate_aexp_inputs (Plus a1 a2) = set l\n\ngoal (2 subgoals):\n 1. \\<And>a1 a2.\n       \\<lbrakk>\\<exists>l. enumerate_aexp_inputs a1 = set l;\n        \\<exists>l. enumerate_aexp_inputs a2 = set l\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l.\n                            enumerate_aexp_inputs (Minus a1 a2) = set l\n 2. \\<And>a1 a2.\n       \\<lbrakk>\\<exists>l. enumerate_aexp_inputs a1 = set l;\n        \\<exists>l. enumerate_aexp_inputs a2 = set l\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l.\n                            enumerate_aexp_inputs (Times a1 a2) = set l", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a1 a2.\n       \\<lbrakk>\\<exists>l. enumerate_aexp_inputs a1 = set l;\n        \\<exists>l. enumerate_aexp_inputs a2 = set l\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l.\n                            enumerate_aexp_inputs (Minus a1 a2) = set l\n 2. \\<And>a1 a2.\n       \\<lbrakk>\\<exists>l. enumerate_aexp_inputs a1 = set l;\n        \\<exists>l. enumerate_aexp_inputs a2 = set l\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l.\n                            enumerate_aexp_inputs (Times a1 a2) = set l", "case (Minus a1 a2)"], ["proof (state)\nthis:\n  \\<exists>l. enumerate_aexp_inputs a1 = set l\n  \\<exists>l. enumerate_aexp_inputs a2 = set l\n\ngoal (2 subgoals):\n 1. \\<And>a1 a2.\n       \\<lbrakk>\\<exists>l. enumerate_aexp_inputs a1 = set l;\n        \\<exists>l. enumerate_aexp_inputs a2 = set l\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l.\n                            enumerate_aexp_inputs (Minus a1 a2) = set l\n 2. \\<And>a1 a2.\n       \\<lbrakk>\\<exists>l. enumerate_aexp_inputs a1 = set l;\n        \\<exists>l. enumerate_aexp_inputs a2 = set l\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l.\n                            enumerate_aexp_inputs (Times a1 a2) = set l", "then"], ["proof (chain)\npicking this:\n  \\<exists>l. enumerate_aexp_inputs a1 = set l\n  \\<exists>l. enumerate_aexp_inputs a2 = set l", "show ?case"], ["proof (prove)\nusing this:\n  \\<exists>l. enumerate_aexp_inputs a1 = set l\n  \\<exists>l. enumerate_aexp_inputs a2 = set l\n\ngoal (1 subgoal):\n 1. \\<exists>l. enumerate_aexp_inputs (Minus a1 a2) = set l", "by (metis enumerate_aexp_inputs.simps(5) set_append)"], ["proof (state)\nthis:\n  \\<exists>l. enumerate_aexp_inputs (Minus a1 a2) = set l\n\ngoal (1 subgoal):\n 1. \\<And>a1 a2.\n       \\<lbrakk>\\<exists>l. enumerate_aexp_inputs a1 = set l;\n        \\<exists>l. enumerate_aexp_inputs a2 = set l\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l.\n                            enumerate_aexp_inputs (Times a1 a2) = set l", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a1 a2.\n       \\<lbrakk>\\<exists>l. enumerate_aexp_inputs a1 = set l;\n        \\<exists>l. enumerate_aexp_inputs a2 = set l\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l.\n                            enumerate_aexp_inputs (Times a1 a2) = set l", "case (Times a1 a2)"], ["proof (state)\nthis:\n  \\<exists>l. enumerate_aexp_inputs a1 = set l\n  \\<exists>l. enumerate_aexp_inputs a2 = set l\n\ngoal (1 subgoal):\n 1. \\<And>a1 a2.\n       \\<lbrakk>\\<exists>l. enumerate_aexp_inputs a1 = set l;\n        \\<exists>l. enumerate_aexp_inputs a2 = set l\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l.\n                            enumerate_aexp_inputs (Times a1 a2) = set l", "then"], ["proof (chain)\npicking this:\n  \\<exists>l. enumerate_aexp_inputs a1 = set l\n  \\<exists>l. enumerate_aexp_inputs a2 = set l", "show ?case"], ["proof (prove)\nusing this:\n  \\<exists>l. enumerate_aexp_inputs a1 = set l\n  \\<exists>l. enumerate_aexp_inputs a2 = set l\n\ngoal (1 subgoal):\n 1. \\<exists>l. enumerate_aexp_inputs (Times a1 a2) = set l", "by (metis enumerate_aexp_inputs.simps(6) set_append)"], ["proof (state)\nthis:\n  \\<exists>l. enumerate_aexp_inputs (Times a1 a2) = set l\n\ngoal:\nNo subgoals!", "qed"], ["", "fun enumerate_regs :: \"vname aexp \\<Rightarrow> nat set\" where\n  \"enumerate_regs (L _) = {}\" |\n  \"enumerate_regs (V (R n)) = {n}\" |\n  \"enumerate_regs (V (I _)) = {}\" |\n  \"enumerate_regs (Plus v va) = enumerate_regs v \\<union> enumerate_regs va\" |\n  \"enumerate_regs (Minus v va) = enumerate_regs v \\<union> enumerate_regs va\" |\n  \"enumerate_regs (Times v va) = enumerate_regs v \\<union> enumerate_regs va\""], ["", "lemma finite_enumerate_regs: \"finite (enumerate_regs a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (enumerate_regs a)", "by(induct a rule: aexp_induct_separate_V_cases, auto)"], ["", "lemma no_variables_aval: \"enumerate_aexp_inputs a = {} \\<Longrightarrow>\n   enumerate_regs a = {} \\<Longrightarrow>\n   aval a s = aval a s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>enumerate_aexp_inputs a = {}; enumerate_regs a = {}\\<rbrakk>\n    \\<Longrightarrow> aval a s = aval a s'", "by (induct a rule: aexp_induct_separate_V_cases, auto)"], ["", "lemma enumerate_aexp_inputs_not_empty:\n  \"(enumerate_aexp_inputs a \\<noteq> {}) = (\\<exists>b c. enumerate_aexp_inputs a = set (b#c))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (enumerate_aexp_inputs a \\<noteq> {}) =\n    (\\<exists>b c. enumerate_aexp_inputs a = set (b # c))", "using enumerate_aexp_inputs_list"], ["proof (prove)\nusing this:\n  \\<exists>l. enumerate_aexp_inputs ?a = set l\n\ngoal (1 subgoal):\n 1. (enumerate_aexp_inputs a \\<noteq> {}) =\n    (\\<exists>b c. enumerate_aexp_inputs a = set (b # c))", "by fastforce"], ["", "lemma aval_ir_take: \"A \\<le> length i \\<Longrightarrow>\n  enumerate_regs a = {} \\<Longrightarrow>\n  enumerate_aexp_inputs a \\<noteq> {} \\<Longrightarrow>\n  Max (enumerate_aexp_inputs a) < A \\<Longrightarrow>\n  aval a (join_ir (take A i) r) = aval a (join_ir i ra)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<le> length i; enumerate_regs a = {};\n     enumerate_aexp_inputs a \\<noteq> {};\n     Max (enumerate_aexp_inputs a) < A\\<rbrakk>\n    \\<Longrightarrow> aval a (join_ir (take A i) r) = aval a (join_ir i ra)", "proof(induct a)"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>A \\<le> length i; enumerate_regs (L x) = {};\n        enumerate_aexp_inputs (L x) \\<noteq> {};\n        Max (enumerate_aexp_inputs (L x)) < A\\<rbrakk>\n       \\<Longrightarrow> aval (L x) (join_ir (take A i) r) =\n                         aval (L x) (join_ir i ra)\n 2. \\<And>x.\n       \\<lbrakk>A \\<le> length i; enumerate_regs (V x) = {};\n        enumerate_aexp_inputs (V x) \\<noteq> {};\n        Max (enumerate_aexp_inputs (V x)) < A\\<rbrakk>\n       \\<Longrightarrow> aval (V x) (join_ir (take A i) r) =\n                         aval (V x) (join_ir i ra)\n 3. \\<And>a1 a2.\n       \\<lbrakk>\\<lbrakk>A \\<le> length i; enumerate_regs a1 = {};\n                 enumerate_aexp_inputs a1 \\<noteq> {};\n                 Max (enumerate_aexp_inputs a1) < A\\<rbrakk>\n                \\<Longrightarrow> aval a1 (join_ir (take A i) r) =\n                                  aval a1 (join_ir i ra);\n        \\<lbrakk>A \\<le> length i; enumerate_regs a2 = {};\n         enumerate_aexp_inputs a2 \\<noteq> {};\n         Max (enumerate_aexp_inputs a2) < A\\<rbrakk>\n        \\<Longrightarrow> aval a2 (join_ir (take A i) r) =\n                          aval a2 (join_ir i ra);\n        A \\<le> length i; enumerate_regs (Plus a1 a2) = {};\n        enumerate_aexp_inputs (Plus a1 a2) \\<noteq> {};\n        Max (enumerate_aexp_inputs (Plus a1 a2)) < A\\<rbrakk>\n       \\<Longrightarrow> aval (Plus a1 a2) (join_ir (take A i) r) =\n                         aval (Plus a1 a2) (join_ir i ra)\n 4. \\<And>a1 a2.\n       \\<lbrakk>\\<lbrakk>A \\<le> length i; enumerate_regs a1 = {};\n                 enumerate_aexp_inputs a1 \\<noteq> {};\n                 Max (enumerate_aexp_inputs a1) < A\\<rbrakk>\n                \\<Longrightarrow> aval a1 (join_ir (take A i) r) =\n                                  aval a1 (join_ir i ra);\n        \\<lbrakk>A \\<le> length i; enumerate_regs a2 = {};\n         enumerate_aexp_inputs a2 \\<noteq> {};\n         Max (enumerate_aexp_inputs a2) < A\\<rbrakk>\n        \\<Longrightarrow> aval a2 (join_ir (take A i) r) =\n                          aval a2 (join_ir i ra);\n        A \\<le> length i; enumerate_regs (Minus a1 a2) = {};\n        enumerate_aexp_inputs (Minus a1 a2) \\<noteq> {};\n        Max (enumerate_aexp_inputs (Minus a1 a2)) < A\\<rbrakk>\n       \\<Longrightarrow> aval (Minus a1 a2) (join_ir (take A i) r) =\n                         aval (Minus a1 a2) (join_ir i ra)\n 5. \\<And>a1 a2.\n       \\<lbrakk>\\<lbrakk>A \\<le> length i; enumerate_regs a1 = {};\n                 enumerate_aexp_inputs a1 \\<noteq> {};\n                 Max (enumerate_aexp_inputs a1) < A\\<rbrakk>\n                \\<Longrightarrow> aval a1 (join_ir (take A i) r) =\n                                  aval a1 (join_ir i ra);\n        \\<lbrakk>A \\<le> length i; enumerate_regs a2 = {};\n         enumerate_aexp_inputs a2 \\<noteq> {};\n         Max (enumerate_aexp_inputs a2) < A\\<rbrakk>\n        \\<Longrightarrow> aval a2 (join_ir (take A i) r) =\n                          aval a2 (join_ir i ra);\n        A \\<le> length i; enumerate_regs (Times a1 a2) = {};\n        enumerate_aexp_inputs (Times a1 a2) \\<noteq> {};\n        Max (enumerate_aexp_inputs (Times a1 a2)) < A\\<rbrakk>\n       \\<Longrightarrow> aval (Times a1 a2) (join_ir (take A i) r) =\n                         aval (Times a1 a2) (join_ir i ra)", "case (L x)"], ["proof (state)\nthis:\n  A \\<le> length i\n  enumerate_regs (L x) = {}\n  enumerate_aexp_inputs (L x) \\<noteq> {}\n  Max (enumerate_aexp_inputs (L x)) < A\n\ngoal (5 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>A \\<le> length i; enumerate_regs (L x) = {};\n        enumerate_aexp_inputs (L x) \\<noteq> {};\n        Max (enumerate_aexp_inputs (L x)) < A\\<rbrakk>\n       \\<Longrightarrow> aval (L x) (join_ir (take A i) r) =\n                         aval (L x) (join_ir i ra)\n 2. \\<And>x.\n       \\<lbrakk>A \\<le> length i; enumerate_regs (V x) = {};\n        enumerate_aexp_inputs (V x) \\<noteq> {};\n        Max (enumerate_aexp_inputs (V x)) < A\\<rbrakk>\n       \\<Longrightarrow> aval (V x) (join_ir (take A i) r) =\n                         aval (V x) (join_ir i ra)\n 3. \\<And>a1 a2.\n       \\<lbrakk>\\<lbrakk>A \\<le> length i; enumerate_regs a1 = {};\n                 enumerate_aexp_inputs a1 \\<noteq> {};\n                 Max (enumerate_aexp_inputs a1) < A\\<rbrakk>\n                \\<Longrightarrow> aval a1 (join_ir (take A i) r) =\n                                  aval a1 (join_ir i ra);\n        \\<lbrakk>A \\<le> length i; enumerate_regs a2 = {};\n         enumerate_aexp_inputs a2 \\<noteq> {};\n         Max (enumerate_aexp_inputs a2) < A\\<rbrakk>\n        \\<Longrightarrow> aval a2 (join_ir (take A i) r) =\n                          aval a2 (join_ir i ra);\n        A \\<le> length i; enumerate_regs (Plus a1 a2) = {};\n        enumerate_aexp_inputs (Plus a1 a2) \\<noteq> {};\n        Max (enumerate_aexp_inputs (Plus a1 a2)) < A\\<rbrakk>\n       \\<Longrightarrow> aval (Plus a1 a2) (join_ir (take A i) r) =\n                         aval (Plus a1 a2) (join_ir i ra)\n 4. \\<And>a1 a2.\n       \\<lbrakk>\\<lbrakk>A \\<le> length i; enumerate_regs a1 = {};\n                 enumerate_aexp_inputs a1 \\<noteq> {};\n                 Max (enumerate_aexp_inputs a1) < A\\<rbrakk>\n                \\<Longrightarrow> aval a1 (join_ir (take A i) r) =\n                                  aval a1 (join_ir i ra);\n        \\<lbrakk>A \\<le> length i; enumerate_regs a2 = {};\n         enumerate_aexp_inputs a2 \\<noteq> {};\n         Max (enumerate_aexp_inputs a2) < A\\<rbrakk>\n        \\<Longrightarrow> aval a2 (join_ir (take A i) r) =\n                          aval a2 (join_ir i ra);\n        A \\<le> length i; enumerate_regs (Minus a1 a2) = {};\n        enumerate_aexp_inputs (Minus a1 a2) \\<noteq> {};\n        Max (enumerate_aexp_inputs (Minus a1 a2)) < A\\<rbrakk>\n       \\<Longrightarrow> aval (Minus a1 a2) (join_ir (take A i) r) =\n                         aval (Minus a1 a2) (join_ir i ra)\n 5. \\<And>a1 a2.\n       \\<lbrakk>\\<lbrakk>A \\<le> length i; enumerate_regs a1 = {};\n                 enumerate_aexp_inputs a1 \\<noteq> {};\n                 Max (enumerate_aexp_inputs a1) < A\\<rbrakk>\n                \\<Longrightarrow> aval a1 (join_ir (take A i) r) =\n                                  aval a1 (join_ir i ra);\n        \\<lbrakk>A \\<le> length i; enumerate_regs a2 = {};\n         enumerate_aexp_inputs a2 \\<noteq> {};\n         Max (enumerate_aexp_inputs a2) < A\\<rbrakk>\n        \\<Longrightarrow> aval a2 (join_ir (take A i) r) =\n                          aval a2 (join_ir i ra);\n        A \\<le> length i; enumerate_regs (Times a1 a2) = {};\n        enumerate_aexp_inputs (Times a1 a2) \\<noteq> {};\n        Max (enumerate_aexp_inputs (Times a1 a2)) < A\\<rbrakk>\n       \\<Longrightarrow> aval (Times a1 a2) (join_ir (take A i) r) =\n                         aval (Times a1 a2) (join_ir i ra)", "then"], ["proof (chain)\npicking this:\n  A \\<le> length i\n  enumerate_regs (L x) = {}\n  enumerate_aexp_inputs (L x) \\<noteq> {}\n  Max (enumerate_aexp_inputs (L x)) < A", "show ?case"], ["proof (prove)\nusing this:\n  A \\<le> length i\n  enumerate_regs (L x) = {}\n  enumerate_aexp_inputs (L x) \\<noteq> {}\n  Max (enumerate_aexp_inputs (L x)) < A\n\ngoal (1 subgoal):\n 1. aval (L x) (join_ir (take A i) r) = aval (L x) (join_ir i ra)", "by simp"], ["proof (state)\nthis:\n  aval (L x) (join_ir (take A i) r) = aval (L x) (join_ir i ra)\n\ngoal (4 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>A \\<le> length i; enumerate_regs (V x) = {};\n        enumerate_aexp_inputs (V x) \\<noteq> {};\n        Max (enumerate_aexp_inputs (V x)) < A\\<rbrakk>\n       \\<Longrightarrow> aval (V x) (join_ir (take A i) r) =\n                         aval (V x) (join_ir i ra)\n 2. \\<And>a1 a2.\n       \\<lbrakk>\\<lbrakk>A \\<le> length i; enumerate_regs a1 = {};\n                 enumerate_aexp_inputs a1 \\<noteq> {};\n                 Max (enumerate_aexp_inputs a1) < A\\<rbrakk>\n                \\<Longrightarrow> aval a1 (join_ir (take A i) r) =\n                                  aval a1 (join_ir i ra);\n        \\<lbrakk>A \\<le> length i; enumerate_regs a2 = {};\n         enumerate_aexp_inputs a2 \\<noteq> {};\n         Max (enumerate_aexp_inputs a2) < A\\<rbrakk>\n        \\<Longrightarrow> aval a2 (join_ir (take A i) r) =\n                          aval a2 (join_ir i ra);\n        A \\<le> length i; enumerate_regs (Plus a1 a2) = {};\n        enumerate_aexp_inputs (Plus a1 a2) \\<noteq> {};\n        Max (enumerate_aexp_inputs (Plus a1 a2)) < A\\<rbrakk>\n       \\<Longrightarrow> aval (Plus a1 a2) (join_ir (take A i) r) =\n                         aval (Plus a1 a2) (join_ir i ra)\n 3. \\<And>a1 a2.\n       \\<lbrakk>\\<lbrakk>A \\<le> length i; enumerate_regs a1 = {};\n                 enumerate_aexp_inputs a1 \\<noteq> {};\n                 Max (enumerate_aexp_inputs a1) < A\\<rbrakk>\n                \\<Longrightarrow> aval a1 (join_ir (take A i) r) =\n                                  aval a1 (join_ir i ra);\n        \\<lbrakk>A \\<le> length i; enumerate_regs a2 = {};\n         enumerate_aexp_inputs a2 \\<noteq> {};\n         Max (enumerate_aexp_inputs a2) < A\\<rbrakk>\n        \\<Longrightarrow> aval a2 (join_ir (take A i) r) =\n                          aval a2 (join_ir i ra);\n        A \\<le> length i; enumerate_regs (Minus a1 a2) = {};\n        enumerate_aexp_inputs (Minus a1 a2) \\<noteq> {};\n        Max (enumerate_aexp_inputs (Minus a1 a2)) < A\\<rbrakk>\n       \\<Longrightarrow> aval (Minus a1 a2) (join_ir (take A i) r) =\n                         aval (Minus a1 a2) (join_ir i ra)\n 4. \\<And>a1 a2.\n       \\<lbrakk>\\<lbrakk>A \\<le> length i; enumerate_regs a1 = {};\n                 enumerate_aexp_inputs a1 \\<noteq> {};\n                 Max (enumerate_aexp_inputs a1) < A\\<rbrakk>\n                \\<Longrightarrow> aval a1 (join_ir (take A i) r) =\n                                  aval a1 (join_ir i ra);\n        \\<lbrakk>A \\<le> length i; enumerate_regs a2 = {};\n         enumerate_aexp_inputs a2 \\<noteq> {};\n         Max (enumerate_aexp_inputs a2) < A\\<rbrakk>\n        \\<Longrightarrow> aval a2 (join_ir (take A i) r) =\n                          aval a2 (join_ir i ra);\n        A \\<le> length i; enumerate_regs (Times a1 a2) = {};\n        enumerate_aexp_inputs (Times a1 a2) \\<noteq> {};\n        Max (enumerate_aexp_inputs (Times a1 a2)) < A\\<rbrakk>\n       \\<Longrightarrow> aval (Times a1 a2) (join_ir (take A i) r) =\n                         aval (Times a1 a2) (join_ir i ra)", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>A \\<le> length i; enumerate_regs (V x) = {};\n        enumerate_aexp_inputs (V x) \\<noteq> {};\n        Max (enumerate_aexp_inputs (V x)) < A\\<rbrakk>\n       \\<Longrightarrow> aval (V x) (join_ir (take A i) r) =\n                         aval (V x) (join_ir i ra)\n 2. \\<And>a1 a2.\n       \\<lbrakk>\\<lbrakk>A \\<le> length i; enumerate_regs a1 = {};\n                 enumerate_aexp_inputs a1 \\<noteq> {};\n                 Max (enumerate_aexp_inputs a1) < A\\<rbrakk>\n                \\<Longrightarrow> aval a1 (join_ir (take A i) r) =\n                                  aval a1 (join_ir i ra);\n        \\<lbrakk>A \\<le> length i; enumerate_regs a2 = {};\n         enumerate_aexp_inputs a2 \\<noteq> {};\n         Max (enumerate_aexp_inputs a2) < A\\<rbrakk>\n        \\<Longrightarrow> aval a2 (join_ir (take A i) r) =\n                          aval a2 (join_ir i ra);\n        A \\<le> length i; enumerate_regs (Plus a1 a2) = {};\n        enumerate_aexp_inputs (Plus a1 a2) \\<noteq> {};\n        Max (enumerate_aexp_inputs (Plus a1 a2)) < A\\<rbrakk>\n       \\<Longrightarrow> aval (Plus a1 a2) (join_ir (take A i) r) =\n                         aval (Plus a1 a2) (join_ir i ra)\n 3. \\<And>a1 a2.\n       \\<lbrakk>\\<lbrakk>A \\<le> length i; enumerate_regs a1 = {};\n                 enumerate_aexp_inputs a1 \\<noteq> {};\n                 Max (enumerate_aexp_inputs a1) < A\\<rbrakk>\n                \\<Longrightarrow> aval a1 (join_ir (take A i) r) =\n                                  aval a1 (join_ir i ra);\n        \\<lbrakk>A \\<le> length i; enumerate_regs a2 = {};\n         enumerate_aexp_inputs a2 \\<noteq> {};\n         Max (enumerate_aexp_inputs a2) < A\\<rbrakk>\n        \\<Longrightarrow> aval a2 (join_ir (take A i) r) =\n                          aval a2 (join_ir i ra);\n        A \\<le> length i; enumerate_regs (Minus a1 a2) = {};\n        enumerate_aexp_inputs (Minus a1 a2) \\<noteq> {};\n        Max (enumerate_aexp_inputs (Minus a1 a2)) < A\\<rbrakk>\n       \\<Longrightarrow> aval (Minus a1 a2) (join_ir (take A i) r) =\n                         aval (Minus a1 a2) (join_ir i ra)\n 4. \\<And>a1 a2.\n       \\<lbrakk>\\<lbrakk>A \\<le> length i; enumerate_regs a1 = {};\n                 enumerate_aexp_inputs a1 \\<noteq> {};\n                 Max (enumerate_aexp_inputs a1) < A\\<rbrakk>\n                \\<Longrightarrow> aval a1 (join_ir (take A i) r) =\n                                  aval a1 (join_ir i ra);\n        \\<lbrakk>A \\<le> length i; enumerate_regs a2 = {};\n         enumerate_aexp_inputs a2 \\<noteq> {};\n         Max (enumerate_aexp_inputs a2) < A\\<rbrakk>\n        \\<Longrightarrow> aval a2 (join_ir (take A i) r) =\n                          aval a2 (join_ir i ra);\n        A \\<le> length i; enumerate_regs (Times a1 a2) = {};\n        enumerate_aexp_inputs (Times a1 a2) \\<noteq> {};\n        Max (enumerate_aexp_inputs (Times a1 a2)) < A\\<rbrakk>\n       \\<Longrightarrow> aval (Times a1 a2) (join_ir (take A i) r) =\n                         aval (Times a1 a2) (join_ir i ra)", "case (V x)"], ["proof (state)\nthis:\n  A \\<le> length i\n  enumerate_regs (V x) = {}\n  enumerate_aexp_inputs (V x) \\<noteq> {}\n  Max (enumerate_aexp_inputs (V x)) < A\n\ngoal (4 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>A \\<le> length i; enumerate_regs (V x) = {};\n        enumerate_aexp_inputs (V x) \\<noteq> {};\n        Max (enumerate_aexp_inputs (V x)) < A\\<rbrakk>\n       \\<Longrightarrow> aval (V x) (join_ir (take A i) r) =\n                         aval (V x) (join_ir i ra)\n 2. \\<And>a1 a2.\n       \\<lbrakk>\\<lbrakk>A \\<le> length i; enumerate_regs a1 = {};\n                 enumerate_aexp_inputs a1 \\<noteq> {};\n                 Max (enumerate_aexp_inputs a1) < A\\<rbrakk>\n                \\<Longrightarrow> aval a1 (join_ir (take A i) r) =\n                                  aval a1 (join_ir i ra);\n        \\<lbrakk>A \\<le> length i; enumerate_regs a2 = {};\n         enumerate_aexp_inputs a2 \\<noteq> {};\n         Max (enumerate_aexp_inputs a2) < A\\<rbrakk>\n        \\<Longrightarrow> aval a2 (join_ir (take A i) r) =\n                          aval a2 (join_ir i ra);\n        A \\<le> length i; enumerate_regs (Plus a1 a2) = {};\n        enumerate_aexp_inputs (Plus a1 a2) \\<noteq> {};\n        Max (enumerate_aexp_inputs (Plus a1 a2)) < A\\<rbrakk>\n       \\<Longrightarrow> aval (Plus a1 a2) (join_ir (take A i) r) =\n                         aval (Plus a1 a2) (join_ir i ra)\n 3. \\<And>a1 a2.\n       \\<lbrakk>\\<lbrakk>A \\<le> length i; enumerate_regs a1 = {};\n                 enumerate_aexp_inputs a1 \\<noteq> {};\n                 Max (enumerate_aexp_inputs a1) < A\\<rbrakk>\n                \\<Longrightarrow> aval a1 (join_ir (take A i) r) =\n                                  aval a1 (join_ir i ra);\n        \\<lbrakk>A \\<le> length i; enumerate_regs a2 = {};\n         enumerate_aexp_inputs a2 \\<noteq> {};\n         Max (enumerate_aexp_inputs a2) < A\\<rbrakk>\n        \\<Longrightarrow> aval a2 (join_ir (take A i) r) =\n                          aval a2 (join_ir i ra);\n        A \\<le> length i; enumerate_regs (Minus a1 a2) = {};\n        enumerate_aexp_inputs (Minus a1 a2) \\<noteq> {};\n        Max (enumerate_aexp_inputs (Minus a1 a2)) < A\\<rbrakk>\n       \\<Longrightarrow> aval (Minus a1 a2) (join_ir (take A i) r) =\n                         aval (Minus a1 a2) (join_ir i ra)\n 4. \\<And>a1 a2.\n       \\<lbrakk>\\<lbrakk>A \\<le> length i; enumerate_regs a1 = {};\n                 enumerate_aexp_inputs a1 \\<noteq> {};\n                 Max (enumerate_aexp_inputs a1) < A\\<rbrakk>\n                \\<Longrightarrow> aval a1 (join_ir (take A i) r) =\n                                  aval a1 (join_ir i ra);\n        \\<lbrakk>A \\<le> length i; enumerate_regs a2 = {};\n         enumerate_aexp_inputs a2 \\<noteq> {};\n         Max (enumerate_aexp_inputs a2) < A\\<rbrakk>\n        \\<Longrightarrow> aval a2 (join_ir (take A i) r) =\n                          aval a2 (join_ir i ra);\n        A \\<le> length i; enumerate_regs (Times a1 a2) = {};\n        enumerate_aexp_inputs (Times a1 a2) \\<noteq> {};\n        Max (enumerate_aexp_inputs (Times a1 a2)) < A\\<rbrakk>\n       \\<Longrightarrow> aval (Times a1 a2) (join_ir (take A i) r) =\n                         aval (Times a1 a2) (join_ir i ra)", "then"], ["proof (chain)\npicking this:\n  A \\<le> length i\n  enumerate_regs (V x) = {}\n  enumerate_aexp_inputs (V x) \\<noteq> {}\n  Max (enumerate_aexp_inputs (V x)) < A", "show ?case"], ["proof (prove)\nusing this:\n  A \\<le> length i\n  enumerate_regs (V x) = {}\n  enumerate_aexp_inputs (V x) \\<noteq> {}\n  Max (enumerate_aexp_inputs (V x)) < A\n\ngoal (1 subgoal):\n 1. aval (V x) (join_ir (take A i) r) = aval (V x) (join_ir i ra)", "apply (cases x)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>A \\<le> length i; enumerate_regs (V x) = {};\n        enumerate_aexp_inputs (V x) \\<noteq> {};\n        Max (enumerate_aexp_inputs (V x)) < A; x = I x1\\<rbrakk>\n       \\<Longrightarrow> aval (V x) (join_ir (take A i) r) =\n                         aval (V x) (join_ir i ra)\n 2. \\<And>x2.\n       \\<lbrakk>A \\<le> length i; enumerate_regs (V x) = {};\n        enumerate_aexp_inputs (V x) \\<noteq> {};\n        Max (enumerate_aexp_inputs (V x)) < A; x = R x2\\<rbrakk>\n       \\<Longrightarrow> aval (V x) (join_ir (take A i) r) =\n                         aval (V x) (join_ir i ra)", "apply (simp add: join_ir_def input2state_nth)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<lbrakk>A \\<le> length i; enumerate_regs (V x) = {};\n        enumerate_aexp_inputs (V x) \\<noteq> {};\n        Max (enumerate_aexp_inputs (V x)) < A; x = R x2\\<rbrakk>\n       \\<Longrightarrow> aval (V x) (join_ir (take A i) r) =\n                         aval (V x) (join_ir i ra)", "by simp"], ["proof (state)\nthis:\n  aval (V x) (join_ir (take A i) r) = aval (V x) (join_ir i ra)\n\ngoal (3 subgoals):\n 1. \\<And>a1 a2.\n       \\<lbrakk>\\<lbrakk>A \\<le> length i; enumerate_regs a1 = {};\n                 enumerate_aexp_inputs a1 \\<noteq> {};\n                 Max (enumerate_aexp_inputs a1) < A\\<rbrakk>\n                \\<Longrightarrow> aval a1 (join_ir (take A i) r) =\n                                  aval a1 (join_ir i ra);\n        \\<lbrakk>A \\<le> length i; enumerate_regs a2 = {};\n         enumerate_aexp_inputs a2 \\<noteq> {};\n         Max (enumerate_aexp_inputs a2) < A\\<rbrakk>\n        \\<Longrightarrow> aval a2 (join_ir (take A i) r) =\n                          aval a2 (join_ir i ra);\n        A \\<le> length i; enumerate_regs (Plus a1 a2) = {};\n        enumerate_aexp_inputs (Plus a1 a2) \\<noteq> {};\n        Max (enumerate_aexp_inputs (Plus a1 a2)) < A\\<rbrakk>\n       \\<Longrightarrow> aval (Plus a1 a2) (join_ir (take A i) r) =\n                         aval (Plus a1 a2) (join_ir i ra)\n 2. \\<And>a1 a2.\n       \\<lbrakk>\\<lbrakk>A \\<le> length i; enumerate_regs a1 = {};\n                 enumerate_aexp_inputs a1 \\<noteq> {};\n                 Max (enumerate_aexp_inputs a1) < A\\<rbrakk>\n                \\<Longrightarrow> aval a1 (join_ir (take A i) r) =\n                                  aval a1 (join_ir i ra);\n        \\<lbrakk>A \\<le> length i; enumerate_regs a2 = {};\n         enumerate_aexp_inputs a2 \\<noteq> {};\n         Max (enumerate_aexp_inputs a2) < A\\<rbrakk>\n        \\<Longrightarrow> aval a2 (join_ir (take A i) r) =\n                          aval a2 (join_ir i ra);\n        A \\<le> length i; enumerate_regs (Minus a1 a2) = {};\n        enumerate_aexp_inputs (Minus a1 a2) \\<noteq> {};\n        Max (enumerate_aexp_inputs (Minus a1 a2)) < A\\<rbrakk>\n       \\<Longrightarrow> aval (Minus a1 a2) (join_ir (take A i) r) =\n                         aval (Minus a1 a2) (join_ir i ra)\n 3. \\<And>a1 a2.\n       \\<lbrakk>\\<lbrakk>A \\<le> length i; enumerate_regs a1 = {};\n                 enumerate_aexp_inputs a1 \\<noteq> {};\n                 Max (enumerate_aexp_inputs a1) < A\\<rbrakk>\n                \\<Longrightarrow> aval a1 (join_ir (take A i) r) =\n                                  aval a1 (join_ir i ra);\n        \\<lbrakk>A \\<le> length i; enumerate_regs a2 = {};\n         enumerate_aexp_inputs a2 \\<noteq> {};\n         Max (enumerate_aexp_inputs a2) < A\\<rbrakk>\n        \\<Longrightarrow> aval a2 (join_ir (take A i) r) =\n                          aval a2 (join_ir i ra);\n        A \\<le> length i; enumerate_regs (Times a1 a2) = {};\n        enumerate_aexp_inputs (Times a1 a2) \\<noteq> {};\n        Max (enumerate_aexp_inputs (Times a1 a2)) < A\\<rbrakk>\n       \\<Longrightarrow> aval (Times a1 a2) (join_ir (take A i) r) =\n                         aval (Times a1 a2) (join_ir i ra)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>a1 a2.\n       \\<lbrakk>\\<lbrakk>A \\<le> length i; enumerate_regs a1 = {};\n                 enumerate_aexp_inputs a1 \\<noteq> {};\n                 Max (enumerate_aexp_inputs a1) < A\\<rbrakk>\n                \\<Longrightarrow> aval a1 (join_ir (take A i) r) =\n                                  aval a1 (join_ir i ra);\n        \\<lbrakk>A \\<le> length i; enumerate_regs a2 = {};\n         enumerate_aexp_inputs a2 \\<noteq> {};\n         Max (enumerate_aexp_inputs a2) < A\\<rbrakk>\n        \\<Longrightarrow> aval a2 (join_ir (take A i) r) =\n                          aval a2 (join_ir i ra);\n        A \\<le> length i; enumerate_regs (Plus a1 a2) = {};\n        enumerate_aexp_inputs (Plus a1 a2) \\<noteq> {};\n        Max (enumerate_aexp_inputs (Plus a1 a2)) < A\\<rbrakk>\n       \\<Longrightarrow> aval (Plus a1 a2) (join_ir (take A i) r) =\n                         aval (Plus a1 a2) (join_ir i ra)\n 2. \\<And>a1 a2.\n       \\<lbrakk>\\<lbrakk>A \\<le> length i; enumerate_regs a1 = {};\n                 enumerate_aexp_inputs a1 \\<noteq> {};\n                 Max (enumerate_aexp_inputs a1) < A\\<rbrakk>\n                \\<Longrightarrow> aval a1 (join_ir (take A i) r) =\n                                  aval a1 (join_ir i ra);\n        \\<lbrakk>A \\<le> length i; enumerate_regs a2 = {};\n         enumerate_aexp_inputs a2 \\<noteq> {};\n         Max (enumerate_aexp_inputs a2) < A\\<rbrakk>\n        \\<Longrightarrow> aval a2 (join_ir (take A i) r) =\n                          aval a2 (join_ir i ra);\n        A \\<le> length i; enumerate_regs (Minus a1 a2) = {};\n        enumerate_aexp_inputs (Minus a1 a2) \\<noteq> {};\n        Max (enumerate_aexp_inputs (Minus a1 a2)) < A\\<rbrakk>\n       \\<Longrightarrow> aval (Minus a1 a2) (join_ir (take A i) r) =\n                         aval (Minus a1 a2) (join_ir i ra)\n 3. \\<And>a1 a2.\n       \\<lbrakk>\\<lbrakk>A \\<le> length i; enumerate_regs a1 = {};\n                 enumerate_aexp_inputs a1 \\<noteq> {};\n                 Max (enumerate_aexp_inputs a1) < A\\<rbrakk>\n                \\<Longrightarrow> aval a1 (join_ir (take A i) r) =\n                                  aval a1 (join_ir i ra);\n        \\<lbrakk>A \\<le> length i; enumerate_regs a2 = {};\n         enumerate_aexp_inputs a2 \\<noteq> {};\n         Max (enumerate_aexp_inputs a2) < A\\<rbrakk>\n        \\<Longrightarrow> aval a2 (join_ir (take A i) r) =\n                          aval a2 (join_ir i ra);\n        A \\<le> length i; enumerate_regs (Times a1 a2) = {};\n        enumerate_aexp_inputs (Times a1 a2) \\<noteq> {};\n        Max (enumerate_aexp_inputs (Times a1 a2)) < A\\<rbrakk>\n       \\<Longrightarrow> aval (Times a1 a2) (join_ir (take A i) r) =\n                         aval (Times a1 a2) (join_ir i ra)", "case (Plus a1 a2)"], ["proof (state)\nthis:\n  \\<lbrakk>A \\<le> length i; enumerate_regs a1 = {};\n   enumerate_aexp_inputs a1 \\<noteq> {};\n   Max (enumerate_aexp_inputs a1) < A\\<rbrakk>\n  \\<Longrightarrow> aval a1 (join_ir (take A i) r) = aval a1 (join_ir i ra)\n  \\<lbrakk>A \\<le> length i; enumerate_regs a2 = {};\n   enumerate_aexp_inputs a2 \\<noteq> {};\n   Max (enumerate_aexp_inputs a2) < A\\<rbrakk>\n  \\<Longrightarrow> aval a2 (join_ir (take A i) r) = aval a2 (join_ir i ra)\n  A \\<le> length i\n  enumerate_regs (Plus a1 a2) = {}\n  enumerate_aexp_inputs (Plus a1 a2) \\<noteq> {}\n  Max (enumerate_aexp_inputs (Plus a1 a2)) < A\n\ngoal (3 subgoals):\n 1. \\<And>a1 a2.\n       \\<lbrakk>\\<lbrakk>A \\<le> length i; enumerate_regs a1 = {};\n                 enumerate_aexp_inputs a1 \\<noteq> {};\n                 Max (enumerate_aexp_inputs a1) < A\\<rbrakk>\n                \\<Longrightarrow> aval a1 (join_ir (take A i) r) =\n                                  aval a1 (join_ir i ra);\n        \\<lbrakk>A \\<le> length i; enumerate_regs a2 = {};\n         enumerate_aexp_inputs a2 \\<noteq> {};\n         Max (enumerate_aexp_inputs a2) < A\\<rbrakk>\n        \\<Longrightarrow> aval a2 (join_ir (take A i) r) =\n                          aval a2 (join_ir i ra);\n        A \\<le> length i; enumerate_regs (Plus a1 a2) = {};\n        enumerate_aexp_inputs (Plus a1 a2) \\<noteq> {};\n        Max (enumerate_aexp_inputs (Plus a1 a2)) < A\\<rbrakk>\n       \\<Longrightarrow> aval (Plus a1 a2) (join_ir (take A i) r) =\n                         aval (Plus a1 a2) (join_ir i ra)\n 2. \\<And>a1 a2.\n       \\<lbrakk>\\<lbrakk>A \\<le> length i; enumerate_regs a1 = {};\n                 enumerate_aexp_inputs a1 \\<noteq> {};\n                 Max (enumerate_aexp_inputs a1) < A\\<rbrakk>\n                \\<Longrightarrow> aval a1 (join_ir (take A i) r) =\n                                  aval a1 (join_ir i ra);\n        \\<lbrakk>A \\<le> length i; enumerate_regs a2 = {};\n         enumerate_aexp_inputs a2 \\<noteq> {};\n         Max (enumerate_aexp_inputs a2) < A\\<rbrakk>\n        \\<Longrightarrow> aval a2 (join_ir (take A i) r) =\n                          aval a2 (join_ir i ra);\n        A \\<le> length i; enumerate_regs (Minus a1 a2) = {};\n        enumerate_aexp_inputs (Minus a1 a2) \\<noteq> {};\n        Max (enumerate_aexp_inputs (Minus a1 a2)) < A\\<rbrakk>\n       \\<Longrightarrow> aval (Minus a1 a2) (join_ir (take A i) r) =\n                         aval (Minus a1 a2) (join_ir i ra)\n 3. \\<And>a1 a2.\n       \\<lbrakk>\\<lbrakk>A \\<le> length i; enumerate_regs a1 = {};\n                 enumerate_aexp_inputs a1 \\<noteq> {};\n                 Max (enumerate_aexp_inputs a1) < A\\<rbrakk>\n                \\<Longrightarrow> aval a1 (join_ir (take A i) r) =\n                                  aval a1 (join_ir i ra);\n        \\<lbrakk>A \\<le> length i; enumerate_regs a2 = {};\n         enumerate_aexp_inputs a2 \\<noteq> {};\n         Max (enumerate_aexp_inputs a2) < A\\<rbrakk>\n        \\<Longrightarrow> aval a2 (join_ir (take A i) r) =\n                          aval a2 (join_ir i ra);\n        A \\<le> length i; enumerate_regs (Times a1 a2) = {};\n        enumerate_aexp_inputs (Times a1 a2) \\<noteq> {};\n        Max (enumerate_aexp_inputs (Times a1 a2)) < A\\<rbrakk>\n       \\<Longrightarrow> aval (Times a1 a2) (join_ir (take A i) r) =\n                         aval (Times a1 a2) (join_ir i ra)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>A \\<le> length i; enumerate_regs a1 = {};\n   enumerate_aexp_inputs a1 \\<noteq> {};\n   Max (enumerate_aexp_inputs a1) < A\\<rbrakk>\n  \\<Longrightarrow> aval a1 (join_ir (take A i) r) = aval a1 (join_ir i ra)\n  \\<lbrakk>A \\<le> length i; enumerate_regs a2 = {};\n   enumerate_aexp_inputs a2 \\<noteq> {};\n   Max (enumerate_aexp_inputs a2) < A\\<rbrakk>\n  \\<Longrightarrow> aval a2 (join_ir (take A i) r) = aval a2 (join_ir i ra)\n  A \\<le> length i\n  enumerate_regs (Plus a1 a2) = {}\n  enumerate_aexp_inputs (Plus a1 a2) \\<noteq> {}\n  Max (enumerate_aexp_inputs (Plus a1 a2)) < A", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>A \\<le> length i; enumerate_regs a1 = {};\n   enumerate_aexp_inputs a1 \\<noteq> {};\n   Max (enumerate_aexp_inputs a1) < A\\<rbrakk>\n  \\<Longrightarrow> aval a1 (join_ir (take A i) r) = aval a1 (join_ir i ra)\n  \\<lbrakk>A \\<le> length i; enumerate_regs a2 = {};\n   enumerate_aexp_inputs a2 \\<noteq> {};\n   Max (enumerate_aexp_inputs a2) < A\\<rbrakk>\n  \\<Longrightarrow> aval a2 (join_ir (take A i) r) = aval a2 (join_ir i ra)\n  A \\<le> length i\n  enumerate_regs (Plus a1 a2) = {}\n  enumerate_aexp_inputs (Plus a1 a2) \\<noteq> {}\n  Max (enumerate_aexp_inputs (Plus a1 a2)) < A\n\ngoal (1 subgoal):\n 1. aval (Plus a1 a2) (join_ir (take A i) r) =\n    aval (Plus a1 a2) (join_ir i ra)", "apply (simp only: enumerate_aexp_inputs_not_empty[of \"Plus a1 a2\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>True; enumerate_regs a1 = {};\n              enumerate_aexp_inputs a1 \\<noteq> {};\n              Max (enumerate_aexp_inputs a1) < A\\<rbrakk>\n             \\<Longrightarrow> aval a1 (join_ir (take A i) r) =\n                               aval a1 (join_ir i ra);\n     \\<lbrakk>True; enumerate_regs a2 = {};\n      enumerate_aexp_inputs a2 \\<noteq> {};\n      Max (enumerate_aexp_inputs a2) < A\\<rbrakk>\n     \\<Longrightarrow> aval a2 (join_ir (take A i) r) =\n                       aval a2 (join_ir i ra);\n     A \\<le> length i; enumerate_regs (Plus a1 a2) = {};\n     \\<exists>b c. enumerate_aexp_inputs (Plus a1 a2) = set (b # c);\n     Max (enumerate_aexp_inputs (Plus a1 a2)) < A\\<rbrakk>\n    \\<Longrightarrow> aval (Plus a1 a2) (join_ir (take A i) r) =\n                      aval (Plus a1 a2) (join_ir i ra)", "apply (erule exE)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b c.\n       \\<lbrakk>\\<lbrakk>True; enumerate_regs a1 = {};\n                 enumerate_aexp_inputs a1 \\<noteq> {};\n                 Max (enumerate_aexp_inputs a1) < A\\<rbrakk>\n                \\<Longrightarrow> aval a1 (join_ir (take A i) r) =\n                                  aval a1 (join_ir i ra);\n        \\<lbrakk>True; enumerate_regs a2 = {};\n         enumerate_aexp_inputs a2 \\<noteq> {};\n         Max (enumerate_aexp_inputs a2) < A\\<rbrakk>\n        \\<Longrightarrow> aval a2 (join_ir (take A i) r) =\n                          aval a2 (join_ir i ra);\n        A \\<le> length i; enumerate_regs (Plus a1 a2) = {};\n        Max (enumerate_aexp_inputs (Plus a1 a2)) < A;\n        enumerate_aexp_inputs (Plus a1 a2) = set (b # c)\\<rbrakk>\n       \\<Longrightarrow> aval (Plus a1 a2) (join_ir (take A i) r) =\n                         aval (Plus a1 a2) (join_ir i ra)", "apply (simp only: neq_Nil_conv List.linorder_class.Max.set_eq_fold)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b c.\n       \\<lbrakk>\\<lbrakk>True; enumerate_regs a1 = {};\n                 enumerate_aexp_inputs a1 \\<noteq> {};\n                 Max (enumerate_aexp_inputs a1) < A\\<rbrakk>\n                \\<Longrightarrow> aval a1 (join_ir (take A i) r) =\n                                  aval a1 (join_ir i ra);\n        \\<lbrakk>True; enumerate_regs a2 = {};\n         enumerate_aexp_inputs a2 \\<noteq> {};\n         Max (enumerate_aexp_inputs a2) < A\\<rbrakk>\n        \\<Longrightarrow> aval a2 (join_ir (take A i) r) =\n                          aval a2 (join_ir i ra);\n        A \\<le> length i; enumerate_regs (Plus a1 a2) = {};\n        fold max c b < A;\n        enumerate_aexp_inputs (Plus a1 a2) = set (b # c)\\<rbrakk>\n       \\<Longrightarrow> aval (Plus a1 a2) (join_ir (take A i) r) =\n                         aval (Plus a1 a2) (join_ir i ra)", "apply (case_tac \"fold max c b \\<le> length i\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>b c.\n       \\<lbrakk>\\<lbrakk>True; enumerate_regs a1 = {};\n                 enumerate_aexp_inputs a1 \\<noteq> {};\n                 Max (enumerate_aexp_inputs a1) < A\\<rbrakk>\n                \\<Longrightarrow> aval a1 (join_ir (take A i) r) =\n                                  aval a1 (join_ir i ra);\n        \\<lbrakk>True; enumerate_regs a2 = {};\n         enumerate_aexp_inputs a2 \\<noteq> {};\n         Max (enumerate_aexp_inputs a2) < A\\<rbrakk>\n        \\<Longrightarrow> aval a2 (join_ir (take A i) r) =\n                          aval a2 (join_ir i ra);\n        A \\<le> length i; enumerate_regs (Plus a1 a2) = {};\n        fold max c b < A; enumerate_aexp_inputs (Plus a1 a2) = set (b # c);\n        fold max c b \\<le> length i\\<rbrakk>\n       \\<Longrightarrow> aval (Plus a1 a2) (join_ir (take A i) r) =\n                         aval (Plus a1 a2) (join_ir i ra)\n 2. \\<And>b c.\n       \\<lbrakk>\\<lbrakk>True; enumerate_regs a1 = {};\n                 enumerate_aexp_inputs a1 \\<noteq> {};\n                 Max (enumerate_aexp_inputs a1) < A\\<rbrakk>\n                \\<Longrightarrow> aval a1 (join_ir (take A i) r) =\n                                  aval a1 (join_ir i ra);\n        \\<lbrakk>True; enumerate_regs a2 = {};\n         enumerate_aexp_inputs a2 \\<noteq> {};\n         Max (enumerate_aexp_inputs a2) < A\\<rbrakk>\n        \\<Longrightarrow> aval a2 (join_ir (take A i) r) =\n                          aval a2 (join_ir i ra);\n        A \\<le> length i; enumerate_regs (Plus a1 a2) = {};\n        fold max c b < A; enumerate_aexp_inputs (Plus a1 a2) = set (b # c);\n        \\<not> fold max c b \\<le> length i\\<rbrakk>\n       \\<Longrightarrow> aval (Plus a1 a2) (join_ir (take A i) r) =\n                         aval (Plus a1 a2) (join_ir i ra)", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>b c.\n       \\<lbrakk>\\<lbrakk>enumerate_aexp_inputs a1 \\<noteq> {};\n                 Max (enumerate_aexp_inputs a1) < A\\<rbrakk>\n                \\<Longrightarrow> aval a1 (join_ir (take A i) r) =\n                                  aval a1 (join_ir i ra);\n        \\<lbrakk>enumerate_aexp_inputs a2 \\<noteq> {};\n         Max (enumerate_aexp_inputs a2) < A\\<rbrakk>\n        \\<Longrightarrow> aval a2 (join_ir (take A i) r) =\n                          aval a2 (join_ir i ra);\n        A \\<le> length i;\n        enumerate_regs a1 = {} \\<and> enumerate_regs a2 = {};\n        fold max c b < A;\n        enumerate_aexp_inputs a1 \\<union> enumerate_aexp_inputs a2 =\n        insert b (set c)\\<rbrakk>\n       \\<Longrightarrow> value_plus (aval a1 (join_ir (take A i) r))\n                          (aval a2 (join_ir (take A i) r)) =\n                         value_plus (aval a1 (join_ir i ra))\n                          (aval a2 (join_ir i ra))\n 2. \\<And>b c.\n       \\<lbrakk>\\<lbrakk>True; enumerate_regs a1 = {};\n                 enumerate_aexp_inputs a1 \\<noteq> {};\n                 Max (enumerate_aexp_inputs a1) < A\\<rbrakk>\n                \\<Longrightarrow> aval a1 (join_ir (take A i) r) =\n                                  aval a1 (join_ir i ra);\n        \\<lbrakk>True; enumerate_regs a2 = {};\n         enumerate_aexp_inputs a2 \\<noteq> {};\n         Max (enumerate_aexp_inputs a2) < A\\<rbrakk>\n        \\<Longrightarrow> aval a2 (join_ir (take A i) r) =\n                          aval a2 (join_ir i ra);\n        A \\<le> length i; enumerate_regs (Plus a1 a2) = {};\n        fold max c b < A; enumerate_aexp_inputs (Plus a1 a2) = set (b # c);\n        \\<not> fold max c b \\<le> length i\\<rbrakk>\n       \\<Longrightarrow> aval (Plus a1 a2) (join_ir (take A i) r) =\n                         aval (Plus a1 a2) (join_ir i ra)", "apply (metis List.finite_set Max.union Plus.prems(4) enumerate_aexp_inputs.simps(4) enumerate_aexp_inputs_not_empty max_less_iff_conj no_variables_aval sup_bot.left_neutral sup_bot.right_neutral)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b c.\n       \\<lbrakk>\\<lbrakk>True; enumerate_regs a1 = {};\n                 enumerate_aexp_inputs a1 \\<noteq> {};\n                 Max (enumerate_aexp_inputs a1) < A\\<rbrakk>\n                \\<Longrightarrow> aval a1 (join_ir (take A i) r) =\n                                  aval a1 (join_ir i ra);\n        \\<lbrakk>True; enumerate_regs a2 = {};\n         enumerate_aexp_inputs a2 \\<noteq> {};\n         Max (enumerate_aexp_inputs a2) < A\\<rbrakk>\n        \\<Longrightarrow> aval a2 (join_ir (take A i) r) =\n                          aval a2 (join_ir i ra);\n        A \\<le> length i; enumerate_regs (Plus a1 a2) = {};\n        fold max c b < A; enumerate_aexp_inputs (Plus a1 a2) = set (b # c);\n        \\<not> fold max c b \\<le> length i\\<rbrakk>\n       \\<Longrightarrow> aval (Plus a1 a2) (join_ir (take A i) r) =\n                         aval (Plus a1 a2) (join_ir i ra)", "by simp"], ["proof (state)\nthis:\n  aval (Plus a1 a2) (join_ir (take A i) r) =\n  aval (Plus a1 a2) (join_ir i ra)\n\ngoal (2 subgoals):\n 1. \\<And>a1 a2.\n       \\<lbrakk>\\<lbrakk>A \\<le> length i; enumerate_regs a1 = {};\n                 enumerate_aexp_inputs a1 \\<noteq> {};\n                 Max (enumerate_aexp_inputs a1) < A\\<rbrakk>\n                \\<Longrightarrow> aval a1 (join_ir (take A i) r) =\n                                  aval a1 (join_ir i ra);\n        \\<lbrakk>A \\<le> length i; enumerate_regs a2 = {};\n         enumerate_aexp_inputs a2 \\<noteq> {};\n         Max (enumerate_aexp_inputs a2) < A\\<rbrakk>\n        \\<Longrightarrow> aval a2 (join_ir (take A i) r) =\n                          aval a2 (join_ir i ra);\n        A \\<le> length i; enumerate_regs (Minus a1 a2) = {};\n        enumerate_aexp_inputs (Minus a1 a2) \\<noteq> {};\n        Max (enumerate_aexp_inputs (Minus a1 a2)) < A\\<rbrakk>\n       \\<Longrightarrow> aval (Minus a1 a2) (join_ir (take A i) r) =\n                         aval (Minus a1 a2) (join_ir i ra)\n 2. \\<And>a1 a2.\n       \\<lbrakk>\\<lbrakk>A \\<le> length i; enumerate_regs a1 = {};\n                 enumerate_aexp_inputs a1 \\<noteq> {};\n                 Max (enumerate_aexp_inputs a1) < A\\<rbrakk>\n                \\<Longrightarrow> aval a1 (join_ir (take A i) r) =\n                                  aval a1 (join_ir i ra);\n        \\<lbrakk>A \\<le> length i; enumerate_regs a2 = {};\n         enumerate_aexp_inputs a2 \\<noteq> {};\n         Max (enumerate_aexp_inputs a2) < A\\<rbrakk>\n        \\<Longrightarrow> aval a2 (join_ir (take A i) r) =\n                          aval a2 (join_ir i ra);\n        A \\<le> length i; enumerate_regs (Times a1 a2) = {};\n        enumerate_aexp_inputs (Times a1 a2) \\<noteq> {};\n        Max (enumerate_aexp_inputs (Times a1 a2)) < A\\<rbrakk>\n       \\<Longrightarrow> aval (Times a1 a2) (join_ir (take A i) r) =\n                         aval (Times a1 a2) (join_ir i ra)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a1 a2.\n       \\<lbrakk>\\<lbrakk>A \\<le> length i; enumerate_regs a1 = {};\n                 enumerate_aexp_inputs a1 \\<noteq> {};\n                 Max (enumerate_aexp_inputs a1) < A\\<rbrakk>\n                \\<Longrightarrow> aval a1 (join_ir (take A i) r) =\n                                  aval a1 (join_ir i ra);\n        \\<lbrakk>A \\<le> length i; enumerate_regs a2 = {};\n         enumerate_aexp_inputs a2 \\<noteq> {};\n         Max (enumerate_aexp_inputs a2) < A\\<rbrakk>\n        \\<Longrightarrow> aval a2 (join_ir (take A i) r) =\n                          aval a2 (join_ir i ra);\n        A \\<le> length i; enumerate_regs (Minus a1 a2) = {};\n        enumerate_aexp_inputs (Minus a1 a2) \\<noteq> {};\n        Max (enumerate_aexp_inputs (Minus a1 a2)) < A\\<rbrakk>\n       \\<Longrightarrow> aval (Minus a1 a2) (join_ir (take A i) r) =\n                         aval (Minus a1 a2) (join_ir i ra)\n 2. \\<And>a1 a2.\n       \\<lbrakk>\\<lbrakk>A \\<le> length i; enumerate_regs a1 = {};\n                 enumerate_aexp_inputs a1 \\<noteq> {};\n                 Max (enumerate_aexp_inputs a1) < A\\<rbrakk>\n                \\<Longrightarrow> aval a1 (join_ir (take A i) r) =\n                                  aval a1 (join_ir i ra);\n        \\<lbrakk>A \\<le> length i; enumerate_regs a2 = {};\n         enumerate_aexp_inputs a2 \\<noteq> {};\n         Max (enumerate_aexp_inputs a2) < A\\<rbrakk>\n        \\<Longrightarrow> aval a2 (join_ir (take A i) r) =\n                          aval a2 (join_ir i ra);\n        A \\<le> length i; enumerate_regs (Times a1 a2) = {};\n        enumerate_aexp_inputs (Times a1 a2) \\<noteq> {};\n        Max (enumerate_aexp_inputs (Times a1 a2)) < A\\<rbrakk>\n       \\<Longrightarrow> aval (Times a1 a2) (join_ir (take A i) r) =\n                         aval (Times a1 a2) (join_ir i ra)", "case (Minus a1 a2)"], ["proof (state)\nthis:\n  \\<lbrakk>A \\<le> length i; enumerate_regs a1 = {};\n   enumerate_aexp_inputs a1 \\<noteq> {};\n   Max (enumerate_aexp_inputs a1) < A\\<rbrakk>\n  \\<Longrightarrow> aval a1 (join_ir (take A i) r) = aval a1 (join_ir i ra)\n  \\<lbrakk>A \\<le> length i; enumerate_regs a2 = {};\n   enumerate_aexp_inputs a2 \\<noteq> {};\n   Max (enumerate_aexp_inputs a2) < A\\<rbrakk>\n  \\<Longrightarrow> aval a2 (join_ir (take A i) r) = aval a2 (join_ir i ra)\n  A \\<le> length i\n  enumerate_regs (Minus a1 a2) = {}\n  enumerate_aexp_inputs (Minus a1 a2) \\<noteq> {}\n  Max (enumerate_aexp_inputs (Minus a1 a2)) < A\n\ngoal (2 subgoals):\n 1. \\<And>a1 a2.\n       \\<lbrakk>\\<lbrakk>A \\<le> length i; enumerate_regs a1 = {};\n                 enumerate_aexp_inputs a1 \\<noteq> {};\n                 Max (enumerate_aexp_inputs a1) < A\\<rbrakk>\n                \\<Longrightarrow> aval a1 (join_ir (take A i) r) =\n                                  aval a1 (join_ir i ra);\n        \\<lbrakk>A \\<le> length i; enumerate_regs a2 = {};\n         enumerate_aexp_inputs a2 \\<noteq> {};\n         Max (enumerate_aexp_inputs a2) < A\\<rbrakk>\n        \\<Longrightarrow> aval a2 (join_ir (take A i) r) =\n                          aval a2 (join_ir i ra);\n        A \\<le> length i; enumerate_regs (Minus a1 a2) = {};\n        enumerate_aexp_inputs (Minus a1 a2) \\<noteq> {};\n        Max (enumerate_aexp_inputs (Minus a1 a2)) < A\\<rbrakk>\n       \\<Longrightarrow> aval (Minus a1 a2) (join_ir (take A i) r) =\n                         aval (Minus a1 a2) (join_ir i ra)\n 2. \\<And>a1 a2.\n       \\<lbrakk>\\<lbrakk>A \\<le> length i; enumerate_regs a1 = {};\n                 enumerate_aexp_inputs a1 \\<noteq> {};\n                 Max (enumerate_aexp_inputs a1) < A\\<rbrakk>\n                \\<Longrightarrow> aval a1 (join_ir (take A i) r) =\n                                  aval a1 (join_ir i ra);\n        \\<lbrakk>A \\<le> length i; enumerate_regs a2 = {};\n         enumerate_aexp_inputs a2 \\<noteq> {};\n         Max (enumerate_aexp_inputs a2) < A\\<rbrakk>\n        \\<Longrightarrow> aval a2 (join_ir (take A i) r) =\n                          aval a2 (join_ir i ra);\n        A \\<le> length i; enumerate_regs (Times a1 a2) = {};\n        enumerate_aexp_inputs (Times a1 a2) \\<noteq> {};\n        Max (enumerate_aexp_inputs (Times a1 a2)) < A\\<rbrakk>\n       \\<Longrightarrow> aval (Times a1 a2) (join_ir (take A i) r) =\n                         aval (Times a1 a2) (join_ir i ra)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>A \\<le> length i; enumerate_regs a1 = {};\n   enumerate_aexp_inputs a1 \\<noteq> {};\n   Max (enumerate_aexp_inputs a1) < A\\<rbrakk>\n  \\<Longrightarrow> aval a1 (join_ir (take A i) r) = aval a1 (join_ir i ra)\n  \\<lbrakk>A \\<le> length i; enumerate_regs a2 = {};\n   enumerate_aexp_inputs a2 \\<noteq> {};\n   Max (enumerate_aexp_inputs a2) < A\\<rbrakk>\n  \\<Longrightarrow> aval a2 (join_ir (take A i) r) = aval a2 (join_ir i ra)\n  A \\<le> length i\n  enumerate_regs (Minus a1 a2) = {}\n  enumerate_aexp_inputs (Minus a1 a2) \\<noteq> {}\n  Max (enumerate_aexp_inputs (Minus a1 a2)) < A", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>A \\<le> length i; enumerate_regs a1 = {};\n   enumerate_aexp_inputs a1 \\<noteq> {};\n   Max (enumerate_aexp_inputs a1) < A\\<rbrakk>\n  \\<Longrightarrow> aval a1 (join_ir (take A i) r) = aval a1 (join_ir i ra)\n  \\<lbrakk>A \\<le> length i; enumerate_regs a2 = {};\n   enumerate_aexp_inputs a2 \\<noteq> {};\n   Max (enumerate_aexp_inputs a2) < A\\<rbrakk>\n  \\<Longrightarrow> aval a2 (join_ir (take A i) r) = aval a2 (join_ir i ra)\n  A \\<le> length i\n  enumerate_regs (Minus a1 a2) = {}\n  enumerate_aexp_inputs (Minus a1 a2) \\<noteq> {}\n  Max (enumerate_aexp_inputs (Minus a1 a2)) < A\n\ngoal (1 subgoal):\n 1. aval (Minus a1 a2) (join_ir (take A i) r) =\n    aval (Minus a1 a2) (join_ir i ra)", "apply (simp only: enumerate_aexp_inputs_not_empty[of \"Minus a1 a2\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>True; enumerate_regs a1 = {};\n              enumerate_aexp_inputs a1 \\<noteq> {};\n              Max (enumerate_aexp_inputs a1) < A\\<rbrakk>\n             \\<Longrightarrow> aval a1 (join_ir (take A i) r) =\n                               aval a1 (join_ir i ra);\n     \\<lbrakk>True; enumerate_regs a2 = {};\n      enumerate_aexp_inputs a2 \\<noteq> {};\n      Max (enumerate_aexp_inputs a2) < A\\<rbrakk>\n     \\<Longrightarrow> aval a2 (join_ir (take A i) r) =\n                       aval a2 (join_ir i ra);\n     A \\<le> length i; enumerate_regs (Minus a1 a2) = {};\n     \\<exists>b c. enumerate_aexp_inputs (Minus a1 a2) = set (b # c);\n     Max (enumerate_aexp_inputs (Minus a1 a2)) < A\\<rbrakk>\n    \\<Longrightarrow> aval (Minus a1 a2) (join_ir (take A i) r) =\n                      aval (Minus a1 a2) (join_ir i ra)", "apply (erule exE)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b c.\n       \\<lbrakk>\\<lbrakk>True; enumerate_regs a1 = {};\n                 enumerate_aexp_inputs a1 \\<noteq> {};\n                 Max (enumerate_aexp_inputs a1) < A\\<rbrakk>\n                \\<Longrightarrow> aval a1 (join_ir (take A i) r) =\n                                  aval a1 (join_ir i ra);\n        \\<lbrakk>True; enumerate_regs a2 = {};\n         enumerate_aexp_inputs a2 \\<noteq> {};\n         Max (enumerate_aexp_inputs a2) < A\\<rbrakk>\n        \\<Longrightarrow> aval a2 (join_ir (take A i) r) =\n                          aval a2 (join_ir i ra);\n        A \\<le> length i; enumerate_regs (Minus a1 a2) = {};\n        Max (enumerate_aexp_inputs (Minus a1 a2)) < A;\n        enumerate_aexp_inputs (Minus a1 a2) = set (b # c)\\<rbrakk>\n       \\<Longrightarrow> aval (Minus a1 a2) (join_ir (take A i) r) =\n                         aval (Minus a1 a2) (join_ir i ra)", "apply (simp only: neq_Nil_conv List.linorder_class.Max.set_eq_fold)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b c.\n       \\<lbrakk>\\<lbrakk>True; enumerate_regs a1 = {};\n                 enumerate_aexp_inputs a1 \\<noteq> {};\n                 Max (enumerate_aexp_inputs a1) < A\\<rbrakk>\n                \\<Longrightarrow> aval a1 (join_ir (take A i) r) =\n                                  aval a1 (join_ir i ra);\n        \\<lbrakk>True; enumerate_regs a2 = {};\n         enumerate_aexp_inputs a2 \\<noteq> {};\n         Max (enumerate_aexp_inputs a2) < A\\<rbrakk>\n        \\<Longrightarrow> aval a2 (join_ir (take A i) r) =\n                          aval a2 (join_ir i ra);\n        A \\<le> length i; enumerate_regs (Minus a1 a2) = {};\n        fold max c b < A;\n        enumerate_aexp_inputs (Minus a1 a2) = set (b # c)\\<rbrakk>\n       \\<Longrightarrow> aval (Minus a1 a2) (join_ir (take A i) r) =\n                         aval (Minus a1 a2) (join_ir i ra)", "apply (case_tac \"fold max c b \\<le> length i\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>b c.\n       \\<lbrakk>\\<lbrakk>True; enumerate_regs a1 = {};\n                 enumerate_aexp_inputs a1 \\<noteq> {};\n                 Max (enumerate_aexp_inputs a1) < A\\<rbrakk>\n                \\<Longrightarrow> aval a1 (join_ir (take A i) r) =\n                                  aval a1 (join_ir i ra);\n        \\<lbrakk>True; enumerate_regs a2 = {};\n         enumerate_aexp_inputs a2 \\<noteq> {};\n         Max (enumerate_aexp_inputs a2) < A\\<rbrakk>\n        \\<Longrightarrow> aval a2 (join_ir (take A i) r) =\n                          aval a2 (join_ir i ra);\n        A \\<le> length i; enumerate_regs (Minus a1 a2) = {};\n        fold max c b < A; enumerate_aexp_inputs (Minus a1 a2) = set (b # c);\n        fold max c b \\<le> length i\\<rbrakk>\n       \\<Longrightarrow> aval (Minus a1 a2) (join_ir (take A i) r) =\n                         aval (Minus a1 a2) (join_ir i ra)\n 2. \\<And>b c.\n       \\<lbrakk>\\<lbrakk>True; enumerate_regs a1 = {};\n                 enumerate_aexp_inputs a1 \\<noteq> {};\n                 Max (enumerate_aexp_inputs a1) < A\\<rbrakk>\n                \\<Longrightarrow> aval a1 (join_ir (take A i) r) =\n                                  aval a1 (join_ir i ra);\n        \\<lbrakk>True; enumerate_regs a2 = {};\n         enumerate_aexp_inputs a2 \\<noteq> {};\n         Max (enumerate_aexp_inputs a2) < A\\<rbrakk>\n        \\<Longrightarrow> aval a2 (join_ir (take A i) r) =\n                          aval a2 (join_ir i ra);\n        A \\<le> length i; enumerate_regs (Minus a1 a2) = {};\n        fold max c b < A; enumerate_aexp_inputs (Minus a1 a2) = set (b # c);\n        \\<not> fold max c b \\<le> length i\\<rbrakk>\n       \\<Longrightarrow> aval (Minus a1 a2) (join_ir (take A i) r) =\n                         aval (Minus a1 a2) (join_ir i ra)", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>b c.\n       \\<lbrakk>\\<lbrakk>enumerate_aexp_inputs a1 \\<noteq> {};\n                 Max (enumerate_aexp_inputs a1) < A\\<rbrakk>\n                \\<Longrightarrow> aval a1 (join_ir (take A i) r) =\n                                  aval a1 (join_ir i ra);\n        \\<lbrakk>enumerate_aexp_inputs a2 \\<noteq> {};\n         Max (enumerate_aexp_inputs a2) < A\\<rbrakk>\n        \\<Longrightarrow> aval a2 (join_ir (take A i) r) =\n                          aval a2 (join_ir i ra);\n        A \\<le> length i;\n        enumerate_regs a1 = {} \\<and> enumerate_regs a2 = {};\n        fold max c b < A;\n        enumerate_aexp_inputs a1 \\<union> enumerate_aexp_inputs a2 =\n        insert b (set c)\\<rbrakk>\n       \\<Longrightarrow> value_minus (aval a1 (join_ir (take A i) r))\n                          (aval a2 (join_ir (take A i) r)) =\n                         value_minus (aval a1 (join_ir i ra))\n                          (aval a2 (join_ir i ra))\n 2. \\<And>b c.\n       \\<lbrakk>\\<lbrakk>True; enumerate_regs a1 = {};\n                 enumerate_aexp_inputs a1 \\<noteq> {};\n                 Max (enumerate_aexp_inputs a1) < A\\<rbrakk>\n                \\<Longrightarrow> aval a1 (join_ir (take A i) r) =\n                                  aval a1 (join_ir i ra);\n        \\<lbrakk>True; enumerate_regs a2 = {};\n         enumerate_aexp_inputs a2 \\<noteq> {};\n         Max (enumerate_aexp_inputs a2) < A\\<rbrakk>\n        \\<Longrightarrow> aval a2 (join_ir (take A i) r) =\n                          aval a2 (join_ir i ra);\n        A \\<le> length i; enumerate_regs (Minus a1 a2) = {};\n        fold max c b < A; enumerate_aexp_inputs (Minus a1 a2) = set (b # c);\n        \\<not> fold max c b \\<le> length i\\<rbrakk>\n       \\<Longrightarrow> aval (Minus a1 a2) (join_ir (take A i) r) =\n                         aval (Minus a1 a2) (join_ir i ra)", "apply (metis List.finite_set Max.union Minus.prems(4) enumerate_aexp_inputs.simps(5) enumerate_aexp_inputs_not_empty max_less_iff_conj no_variables_aval sup_bot.left_neutral sup_bot.right_neutral)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b c.\n       \\<lbrakk>\\<lbrakk>True; enumerate_regs a1 = {};\n                 enumerate_aexp_inputs a1 \\<noteq> {};\n                 Max (enumerate_aexp_inputs a1) < A\\<rbrakk>\n                \\<Longrightarrow> aval a1 (join_ir (take A i) r) =\n                                  aval a1 (join_ir i ra);\n        \\<lbrakk>True; enumerate_regs a2 = {};\n         enumerate_aexp_inputs a2 \\<noteq> {};\n         Max (enumerate_aexp_inputs a2) < A\\<rbrakk>\n        \\<Longrightarrow> aval a2 (join_ir (take A i) r) =\n                          aval a2 (join_ir i ra);\n        A \\<le> length i; enumerate_regs (Minus a1 a2) = {};\n        fold max c b < A; enumerate_aexp_inputs (Minus a1 a2) = set (b # c);\n        \\<not> fold max c b \\<le> length i\\<rbrakk>\n       \\<Longrightarrow> aval (Minus a1 a2) (join_ir (take A i) r) =\n                         aval (Minus a1 a2) (join_ir i ra)", "by simp"], ["proof (state)\nthis:\n  aval (Minus a1 a2) (join_ir (take A i) r) =\n  aval (Minus a1 a2) (join_ir i ra)\n\ngoal (1 subgoal):\n 1. \\<And>a1 a2.\n       \\<lbrakk>\\<lbrakk>A \\<le> length i; enumerate_regs a1 = {};\n                 enumerate_aexp_inputs a1 \\<noteq> {};\n                 Max (enumerate_aexp_inputs a1) < A\\<rbrakk>\n                \\<Longrightarrow> aval a1 (join_ir (take A i) r) =\n                                  aval a1 (join_ir i ra);\n        \\<lbrakk>A \\<le> length i; enumerate_regs a2 = {};\n         enumerate_aexp_inputs a2 \\<noteq> {};\n         Max (enumerate_aexp_inputs a2) < A\\<rbrakk>\n        \\<Longrightarrow> aval a2 (join_ir (take A i) r) =\n                          aval a2 (join_ir i ra);\n        A \\<le> length i; enumerate_regs (Times a1 a2) = {};\n        enumerate_aexp_inputs (Times a1 a2) \\<noteq> {};\n        Max (enumerate_aexp_inputs (Times a1 a2)) < A\\<rbrakk>\n       \\<Longrightarrow> aval (Times a1 a2) (join_ir (take A i) r) =\n                         aval (Times a1 a2) (join_ir i ra)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a1 a2.\n       \\<lbrakk>\\<lbrakk>A \\<le> length i; enumerate_regs a1 = {};\n                 enumerate_aexp_inputs a1 \\<noteq> {};\n                 Max (enumerate_aexp_inputs a1) < A\\<rbrakk>\n                \\<Longrightarrow> aval a1 (join_ir (take A i) r) =\n                                  aval a1 (join_ir i ra);\n        \\<lbrakk>A \\<le> length i; enumerate_regs a2 = {};\n         enumerate_aexp_inputs a2 \\<noteq> {};\n         Max (enumerate_aexp_inputs a2) < A\\<rbrakk>\n        \\<Longrightarrow> aval a2 (join_ir (take A i) r) =\n                          aval a2 (join_ir i ra);\n        A \\<le> length i; enumerate_regs (Times a1 a2) = {};\n        enumerate_aexp_inputs (Times a1 a2) \\<noteq> {};\n        Max (enumerate_aexp_inputs (Times a1 a2)) < A\\<rbrakk>\n       \\<Longrightarrow> aval (Times a1 a2) (join_ir (take A i) r) =\n                         aval (Times a1 a2) (join_ir i ra)", "case (Times a1 a2)"], ["proof (state)\nthis:\n  \\<lbrakk>A \\<le> length i; enumerate_regs a1 = {};\n   enumerate_aexp_inputs a1 \\<noteq> {};\n   Max (enumerate_aexp_inputs a1) < A\\<rbrakk>\n  \\<Longrightarrow> aval a1 (join_ir (take A i) r) = aval a1 (join_ir i ra)\n  \\<lbrakk>A \\<le> length i; enumerate_regs a2 = {};\n   enumerate_aexp_inputs a2 \\<noteq> {};\n   Max (enumerate_aexp_inputs a2) < A\\<rbrakk>\n  \\<Longrightarrow> aval a2 (join_ir (take A i) r) = aval a2 (join_ir i ra)\n  A \\<le> length i\n  enumerate_regs (Times a1 a2) = {}\n  enumerate_aexp_inputs (Times a1 a2) \\<noteq> {}\n  Max (enumerate_aexp_inputs (Times a1 a2)) < A\n\ngoal (1 subgoal):\n 1. \\<And>a1 a2.\n       \\<lbrakk>\\<lbrakk>A \\<le> length i; enumerate_regs a1 = {};\n                 enumerate_aexp_inputs a1 \\<noteq> {};\n                 Max (enumerate_aexp_inputs a1) < A\\<rbrakk>\n                \\<Longrightarrow> aval a1 (join_ir (take A i) r) =\n                                  aval a1 (join_ir i ra);\n        \\<lbrakk>A \\<le> length i; enumerate_regs a2 = {};\n         enumerate_aexp_inputs a2 \\<noteq> {};\n         Max (enumerate_aexp_inputs a2) < A\\<rbrakk>\n        \\<Longrightarrow> aval a2 (join_ir (take A i) r) =\n                          aval a2 (join_ir i ra);\n        A \\<le> length i; enumerate_regs (Times a1 a2) = {};\n        enumerate_aexp_inputs (Times a1 a2) \\<noteq> {};\n        Max (enumerate_aexp_inputs (Times a1 a2)) < A\\<rbrakk>\n       \\<Longrightarrow> aval (Times a1 a2) (join_ir (take A i) r) =\n                         aval (Times a1 a2) (join_ir i ra)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>A \\<le> length i; enumerate_regs a1 = {};\n   enumerate_aexp_inputs a1 \\<noteq> {};\n   Max (enumerate_aexp_inputs a1) < A\\<rbrakk>\n  \\<Longrightarrow> aval a1 (join_ir (take A i) r) = aval a1 (join_ir i ra)\n  \\<lbrakk>A \\<le> length i; enumerate_regs a2 = {};\n   enumerate_aexp_inputs a2 \\<noteq> {};\n   Max (enumerate_aexp_inputs a2) < A\\<rbrakk>\n  \\<Longrightarrow> aval a2 (join_ir (take A i) r) = aval a2 (join_ir i ra)\n  A \\<le> length i\n  enumerate_regs (Times a1 a2) = {}\n  enumerate_aexp_inputs (Times a1 a2) \\<noteq> {}\n  Max (enumerate_aexp_inputs (Times a1 a2)) < A", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>A \\<le> length i; enumerate_regs a1 = {};\n   enumerate_aexp_inputs a1 \\<noteq> {};\n   Max (enumerate_aexp_inputs a1) < A\\<rbrakk>\n  \\<Longrightarrow> aval a1 (join_ir (take A i) r) = aval a1 (join_ir i ra)\n  \\<lbrakk>A \\<le> length i; enumerate_regs a2 = {};\n   enumerate_aexp_inputs a2 \\<noteq> {};\n   Max (enumerate_aexp_inputs a2) < A\\<rbrakk>\n  \\<Longrightarrow> aval a2 (join_ir (take A i) r) = aval a2 (join_ir i ra)\n  A \\<le> length i\n  enumerate_regs (Times a1 a2) = {}\n  enumerate_aexp_inputs (Times a1 a2) \\<noteq> {}\n  Max (enumerate_aexp_inputs (Times a1 a2)) < A\n\ngoal (1 subgoal):\n 1. aval (Times a1 a2) (join_ir (take A i) r) =\n    aval (Times a1 a2) (join_ir i ra)", "apply (simp only: enumerate_aexp_inputs_not_empty[of \"Times a1 a2\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>True; enumerate_regs a1 = {};\n              enumerate_aexp_inputs a1 \\<noteq> {};\n              Max (enumerate_aexp_inputs a1) < A\\<rbrakk>\n             \\<Longrightarrow> aval a1 (join_ir (take A i) r) =\n                               aval a1 (join_ir i ra);\n     \\<lbrakk>True; enumerate_regs a2 = {};\n      enumerate_aexp_inputs a2 \\<noteq> {};\n      Max (enumerate_aexp_inputs a2) < A\\<rbrakk>\n     \\<Longrightarrow> aval a2 (join_ir (take A i) r) =\n                       aval a2 (join_ir i ra);\n     A \\<le> length i; enumerate_regs (Times a1 a2) = {};\n     \\<exists>b c. enumerate_aexp_inputs (Times a1 a2) = set (b # c);\n     Max (enumerate_aexp_inputs (Times a1 a2)) < A\\<rbrakk>\n    \\<Longrightarrow> aval (Times a1 a2) (join_ir (take A i) r) =\n                      aval (Times a1 a2) (join_ir i ra)", "apply (erule exE)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b c.\n       \\<lbrakk>\\<lbrakk>True; enumerate_regs a1 = {};\n                 enumerate_aexp_inputs a1 \\<noteq> {};\n                 Max (enumerate_aexp_inputs a1) < A\\<rbrakk>\n                \\<Longrightarrow> aval a1 (join_ir (take A i) r) =\n                                  aval a1 (join_ir i ra);\n        \\<lbrakk>True; enumerate_regs a2 = {};\n         enumerate_aexp_inputs a2 \\<noteq> {};\n         Max (enumerate_aexp_inputs a2) < A\\<rbrakk>\n        \\<Longrightarrow> aval a2 (join_ir (take A i) r) =\n                          aval a2 (join_ir i ra);\n        A \\<le> length i; enumerate_regs (Times a1 a2) = {};\n        Max (enumerate_aexp_inputs (Times a1 a2)) < A;\n        enumerate_aexp_inputs (Times a1 a2) = set (b # c)\\<rbrakk>\n       \\<Longrightarrow> aval (Times a1 a2) (join_ir (take A i) r) =\n                         aval (Times a1 a2) (join_ir i ra)", "apply (simp only: neq_Nil_conv List.linorder_class.Max.set_eq_fold)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b c.\n       \\<lbrakk>\\<lbrakk>True; enumerate_regs a1 = {};\n                 enumerate_aexp_inputs a1 \\<noteq> {};\n                 Max (enumerate_aexp_inputs a1) < A\\<rbrakk>\n                \\<Longrightarrow> aval a1 (join_ir (take A i) r) =\n                                  aval a1 (join_ir i ra);\n        \\<lbrakk>True; enumerate_regs a2 = {};\n         enumerate_aexp_inputs a2 \\<noteq> {};\n         Max (enumerate_aexp_inputs a2) < A\\<rbrakk>\n        \\<Longrightarrow> aval a2 (join_ir (take A i) r) =\n                          aval a2 (join_ir i ra);\n        A \\<le> length i; enumerate_regs (Times a1 a2) = {};\n        fold max c b < A;\n        enumerate_aexp_inputs (Times a1 a2) = set (b # c)\\<rbrakk>\n       \\<Longrightarrow> aval (Times a1 a2) (join_ir (take A i) r) =\n                         aval (Times a1 a2) (join_ir i ra)", "apply (case_tac \"fold max c b \\<le> length i\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>b c.\n       \\<lbrakk>\\<lbrakk>True; enumerate_regs a1 = {};\n                 enumerate_aexp_inputs a1 \\<noteq> {};\n                 Max (enumerate_aexp_inputs a1) < A\\<rbrakk>\n                \\<Longrightarrow> aval a1 (join_ir (take A i) r) =\n                                  aval a1 (join_ir i ra);\n        \\<lbrakk>True; enumerate_regs a2 = {};\n         enumerate_aexp_inputs a2 \\<noteq> {};\n         Max (enumerate_aexp_inputs a2) < A\\<rbrakk>\n        \\<Longrightarrow> aval a2 (join_ir (take A i) r) =\n                          aval a2 (join_ir i ra);\n        A \\<le> length i; enumerate_regs (Times a1 a2) = {};\n        fold max c b < A; enumerate_aexp_inputs (Times a1 a2) = set (b # c);\n        fold max c b \\<le> length i\\<rbrakk>\n       \\<Longrightarrow> aval (Times a1 a2) (join_ir (take A i) r) =\n                         aval (Times a1 a2) (join_ir i ra)\n 2. \\<And>b c.\n       \\<lbrakk>\\<lbrakk>True; enumerate_regs a1 = {};\n                 enumerate_aexp_inputs a1 \\<noteq> {};\n                 Max (enumerate_aexp_inputs a1) < A\\<rbrakk>\n                \\<Longrightarrow> aval a1 (join_ir (take A i) r) =\n                                  aval a1 (join_ir i ra);\n        \\<lbrakk>True; enumerate_regs a2 = {};\n         enumerate_aexp_inputs a2 \\<noteq> {};\n         Max (enumerate_aexp_inputs a2) < A\\<rbrakk>\n        \\<Longrightarrow> aval a2 (join_ir (take A i) r) =\n                          aval a2 (join_ir i ra);\n        A \\<le> length i; enumerate_regs (Times a1 a2) = {};\n        fold max c b < A; enumerate_aexp_inputs (Times a1 a2) = set (b # c);\n        \\<not> fold max c b \\<le> length i\\<rbrakk>\n       \\<Longrightarrow> aval (Times a1 a2) (join_ir (take A i) r) =\n                         aval (Times a1 a2) (join_ir i ra)", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>b c.\n       \\<lbrakk>\\<lbrakk>enumerate_aexp_inputs a1 \\<noteq> {};\n                 Max (enumerate_aexp_inputs a1) < A\\<rbrakk>\n                \\<Longrightarrow> aval a1 (join_ir (take A i) r) =\n                                  aval a1 (join_ir i ra);\n        \\<lbrakk>enumerate_aexp_inputs a2 \\<noteq> {};\n         Max (enumerate_aexp_inputs a2) < A\\<rbrakk>\n        \\<Longrightarrow> aval a2 (join_ir (take A i) r) =\n                          aval a2 (join_ir i ra);\n        A \\<le> length i;\n        enumerate_regs a1 = {} \\<and> enumerate_regs a2 = {};\n        fold max c b < A;\n        enumerate_aexp_inputs a1 \\<union> enumerate_aexp_inputs a2 =\n        insert b (set c)\\<rbrakk>\n       \\<Longrightarrow> value_times (aval a1 (join_ir (take A i) r))\n                          (aval a2 (join_ir (take A i) r)) =\n                         value_times (aval a1 (join_ir i ra))\n                          (aval a2 (join_ir i ra))\n 2. \\<And>b c.\n       \\<lbrakk>\\<lbrakk>True; enumerate_regs a1 = {};\n                 enumerate_aexp_inputs a1 \\<noteq> {};\n                 Max (enumerate_aexp_inputs a1) < A\\<rbrakk>\n                \\<Longrightarrow> aval a1 (join_ir (take A i) r) =\n                                  aval a1 (join_ir i ra);\n        \\<lbrakk>True; enumerate_regs a2 = {};\n         enumerate_aexp_inputs a2 \\<noteq> {};\n         Max (enumerate_aexp_inputs a2) < A\\<rbrakk>\n        \\<Longrightarrow> aval a2 (join_ir (take A i) r) =\n                          aval a2 (join_ir i ra);\n        A \\<le> length i; enumerate_regs (Times a1 a2) = {};\n        fold max c b < A; enumerate_aexp_inputs (Times a1 a2) = set (b # c);\n        \\<not> fold max c b \\<le> length i\\<rbrakk>\n       \\<Longrightarrow> aval (Times a1 a2) (join_ir (take A i) r) =\n                         aval (Times a1 a2) (join_ir i ra)", "apply (metis List.finite_set Max.union Times.prems(4) enumerate_aexp_inputs.simps(6) enumerate_aexp_inputs_not_empty max_less_iff_conj no_variables_aval sup_bot.left_neutral sup_bot.right_neutral)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b c.\n       \\<lbrakk>\\<lbrakk>True; enumerate_regs a1 = {};\n                 enumerate_aexp_inputs a1 \\<noteq> {};\n                 Max (enumerate_aexp_inputs a1) < A\\<rbrakk>\n                \\<Longrightarrow> aval a1 (join_ir (take A i) r) =\n                                  aval a1 (join_ir i ra);\n        \\<lbrakk>True; enumerate_regs a2 = {};\n         enumerate_aexp_inputs a2 \\<noteq> {};\n         Max (enumerate_aexp_inputs a2) < A\\<rbrakk>\n        \\<Longrightarrow> aval a2 (join_ir (take A i) r) =\n                          aval a2 (join_ir i ra);\n        A \\<le> length i; enumerate_regs (Times a1 a2) = {};\n        fold max c b < A; enumerate_aexp_inputs (Times a1 a2) = set (b # c);\n        \\<not> fold max c b \\<le> length i\\<rbrakk>\n       \\<Longrightarrow> aval (Times a1 a2) (join_ir (take A i) r) =\n                         aval (Times a1 a2) (join_ir i ra)", "by simp"], ["proof (state)\nthis:\n  aval (Times a1 a2) (join_ir (take A i) r) =\n  aval (Times a1 a2) (join_ir i ra)\n\ngoal:\nNo subgoals!", "qed"], ["", "definition max_input :: \"vname aexp \\<Rightarrow> nat option\" where\n  \"max_input g = (let inputs = (enumerate_aexp_inputs g) in if inputs = {} then None else Some (Max inputs))\""], ["", "definition max_reg :: \"vname aexp \\<Rightarrow> nat option\" where\n  \"max_reg g = (let regs = (enumerate_regs g) in if regs = {} then None else Some (Max regs))\""], ["", "lemma max_reg_V_I: \"max_reg (V (I n)) = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. max_reg (V (I n)) = None", "by (simp add: max_reg_def)"], ["", "lemma max_reg_V_R: \"max_reg (V (R n)) = Some n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. max_reg (V (R n)) = Some n", "by (simp add: max_reg_def)"], ["", "lemmas max_reg_V = max_reg_V_I max_reg_V_R"], ["", "lemma max_reg_Plus: \"max_reg (Plus a1 a2) = max (max_reg a1) (max_reg a2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. max_reg (Plus a1 a2) = max (max_reg a1) (max_reg a2)", "apply (simp add: max_reg_def Let_def max_absorb2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. enumerate_regs a1 \\<noteq> {} \\<longrightarrow>\n    (enumerate_regs a2 = {} \\<longrightarrow>\n     Some (Max (enumerate_regs a1)) =\n     max (Some (Max (enumerate_regs a1))) None) \\<and>\n    (enumerate_regs a2 \\<noteq> {} \\<longrightarrow>\n     Some (Max (enumerate_regs a1 \\<union> enumerate_regs a2)) =\n     max (Some (Max (enumerate_regs a1))) (Some (Max (enumerate_regs a2))))", "by (metis Max.union bot_option_def finite_enumerate_regs max_bot2 sup_Some sup_max)"], ["", "lemma max_reg_Minus: \"max_reg (Minus a1 a2) = max (max_reg a1) (max_reg a2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. max_reg (Minus a1 a2) = max (max_reg a1) (max_reg a2)", "apply (simp add: max_reg_def Let_def max_absorb2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. enumerate_regs a1 \\<noteq> {} \\<longrightarrow>\n    (enumerate_regs a2 = {} \\<longrightarrow>\n     Some (Max (enumerate_regs a1)) =\n     max (Some (Max (enumerate_regs a1))) None) \\<and>\n    (enumerate_regs a2 \\<noteq> {} \\<longrightarrow>\n     Some (Max (enumerate_regs a1 \\<union> enumerate_regs a2)) =\n     max (Some (Max (enumerate_regs a1))) (Some (Max (enumerate_regs a2))))", "by (metis Max.union bot_option_def finite_enumerate_regs max_bot2 sup_Some sup_max)"], ["", "lemma max_reg_Times: \"max_reg (Times a1 a2) = max (max_reg a1) (max_reg a2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. max_reg (Times a1 a2) = max (max_reg a1) (max_reg a2)", "apply (simp add: max_reg_def Let_def max_absorb2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. enumerate_regs a1 \\<noteq> {} \\<longrightarrow>\n    (enumerate_regs a2 = {} \\<longrightarrow>\n     Some (Max (enumerate_regs a1)) =\n     max (Some (Max (enumerate_regs a1))) None) \\<and>\n    (enumerate_regs a2 \\<noteq> {} \\<longrightarrow>\n     Some (Max (enumerate_regs a1 \\<union> enumerate_regs a2)) =\n     max (Some (Max (enumerate_regs a1))) (Some (Max (enumerate_regs a2))))", "by (metis Max.union bot_option_def finite_enumerate_regs max_bot2 sup_Some sup_max)"], ["", "lemma no_reg_aval_swap_regs:\n  \"max_reg a = None \\<Longrightarrow> aval a (join_ir i r) = aval a (join_ir i r')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. max_reg a = None \\<Longrightarrow>\n    aval a (join_ir i r) = aval a (join_ir i r')", "proof(induct a)"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>x.\n       max_reg (L x) = None \\<Longrightarrow>\n       aval (L x) (join_ir i r) = aval (L x) (join_ir i r')\n 2. \\<And>x.\n       max_reg (V x) = None \\<Longrightarrow>\n       aval (V x) (join_ir i r) = aval (V x) (join_ir i r')\n 3. \\<And>a1 a2.\n       \\<lbrakk>max_reg a1 = None \\<Longrightarrow>\n                aval a1 (join_ir i r) = aval a1 (join_ir i r');\n        max_reg a2 = None \\<Longrightarrow>\n        aval a2 (join_ir i r) = aval a2 (join_ir i r');\n        max_reg (Plus a1 a2) = None\\<rbrakk>\n       \\<Longrightarrow> aval (Plus a1 a2) (join_ir i r) =\n                         aval (Plus a1 a2) (join_ir i r')\n 4. \\<And>a1 a2.\n       \\<lbrakk>max_reg a1 = None \\<Longrightarrow>\n                aval a1 (join_ir i r) = aval a1 (join_ir i r');\n        max_reg a2 = None \\<Longrightarrow>\n        aval a2 (join_ir i r) = aval a2 (join_ir i r');\n        max_reg (Minus a1 a2) = None\\<rbrakk>\n       \\<Longrightarrow> aval (Minus a1 a2) (join_ir i r) =\n                         aval (Minus a1 a2) (join_ir i r')\n 5. \\<And>a1 a2.\n       \\<lbrakk>max_reg a1 = None \\<Longrightarrow>\n                aval a1 (join_ir i r) = aval a1 (join_ir i r');\n        max_reg a2 = None \\<Longrightarrow>\n        aval a2 (join_ir i r) = aval a2 (join_ir i r');\n        max_reg (Times a1 a2) = None\\<rbrakk>\n       \\<Longrightarrow> aval (Times a1 a2) (join_ir i r) =\n                         aval (Times a1 a2) (join_ir i r')", "case (V x)"], ["proof (state)\nthis:\n  max_reg (V x) = None\n\ngoal (5 subgoals):\n 1. \\<And>x.\n       max_reg (L x) = None \\<Longrightarrow>\n       aval (L x) (join_ir i r) = aval (L x) (join_ir i r')\n 2. \\<And>x.\n       max_reg (V x) = None \\<Longrightarrow>\n       aval (V x) (join_ir i r) = aval (V x) (join_ir i r')\n 3. \\<And>a1 a2.\n       \\<lbrakk>max_reg a1 = None \\<Longrightarrow>\n                aval a1 (join_ir i r) = aval a1 (join_ir i r');\n        max_reg a2 = None \\<Longrightarrow>\n        aval a2 (join_ir i r) = aval a2 (join_ir i r');\n        max_reg (Plus a1 a2) = None\\<rbrakk>\n       \\<Longrightarrow> aval (Plus a1 a2) (join_ir i r) =\n                         aval (Plus a1 a2) (join_ir i r')\n 4. \\<And>a1 a2.\n       \\<lbrakk>max_reg a1 = None \\<Longrightarrow>\n                aval a1 (join_ir i r) = aval a1 (join_ir i r');\n        max_reg a2 = None \\<Longrightarrow>\n        aval a2 (join_ir i r) = aval a2 (join_ir i r');\n        max_reg (Minus a1 a2) = None\\<rbrakk>\n       \\<Longrightarrow> aval (Minus a1 a2) (join_ir i r) =\n                         aval (Minus a1 a2) (join_ir i r')\n 5. \\<And>a1 a2.\n       \\<lbrakk>max_reg a1 = None \\<Longrightarrow>\n                aval a1 (join_ir i r) = aval a1 (join_ir i r');\n        max_reg a2 = None \\<Longrightarrow>\n        aval a2 (join_ir i r) = aval a2 (join_ir i r');\n        max_reg (Times a1 a2) = None\\<rbrakk>\n       \\<Longrightarrow> aval (Times a1 a2) (join_ir i r) =\n                         aval (Times a1 a2) (join_ir i r')", "then"], ["proof (chain)\npicking this:\n  max_reg (V x) = None", "show ?case"], ["proof (prove)\nusing this:\n  max_reg (V x) = None\n\ngoal (1 subgoal):\n 1. aval (V x) (join_ir i r) = aval (V x) (join_ir i r')", "apply (cases x)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>max_reg (V x) = None; x = I x1\\<rbrakk>\n       \\<Longrightarrow> aval (V x) (join_ir i r) =\n                         aval (V x) (join_ir i r')\n 2. \\<And>x2.\n       \\<lbrakk>max_reg (V x) = None; x = R x2\\<rbrakk>\n       \\<Longrightarrow> aval (V x) (join_ir i r) =\n                         aval (V x) (join_ir i r')", "apply (simp add: join_ir_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<lbrakk>max_reg (V x) = None; x = R x2\\<rbrakk>\n       \\<Longrightarrow> aval (V x) (join_ir i r) =\n                         aval (V x) (join_ir i r')", "by (simp add: join_ir_def max_reg_def)"], ["proof (state)\nthis:\n  aval (V x) (join_ir i r) = aval (V x) (join_ir i r')\n\ngoal (4 subgoals):\n 1. \\<And>x.\n       max_reg (L x) = None \\<Longrightarrow>\n       aval (L x) (join_ir i r) = aval (L x) (join_ir i r')\n 2. \\<And>a1 a2.\n       \\<lbrakk>max_reg a1 = None \\<Longrightarrow>\n                aval a1 (join_ir i r) = aval a1 (join_ir i r');\n        max_reg a2 = None \\<Longrightarrow>\n        aval a2 (join_ir i r) = aval a2 (join_ir i r');\n        max_reg (Plus a1 a2) = None\\<rbrakk>\n       \\<Longrightarrow> aval (Plus a1 a2) (join_ir i r) =\n                         aval (Plus a1 a2) (join_ir i r')\n 3. \\<And>a1 a2.\n       \\<lbrakk>max_reg a1 = None \\<Longrightarrow>\n                aval a1 (join_ir i r) = aval a1 (join_ir i r');\n        max_reg a2 = None \\<Longrightarrow>\n        aval a2 (join_ir i r) = aval a2 (join_ir i r');\n        max_reg (Minus a1 a2) = None\\<rbrakk>\n       \\<Longrightarrow> aval (Minus a1 a2) (join_ir i r) =\n                         aval (Minus a1 a2) (join_ir i r')\n 4. \\<And>a1 a2.\n       \\<lbrakk>max_reg a1 = None \\<Longrightarrow>\n                aval a1 (join_ir i r) = aval a1 (join_ir i r');\n        max_reg a2 = None \\<Longrightarrow>\n        aval a2 (join_ir i r) = aval a2 (join_ir i r');\n        max_reg (Times a1 a2) = None\\<rbrakk>\n       \\<Longrightarrow> aval (Times a1 a2) (join_ir i r) =\n                         aval (Times a1 a2) (join_ir i r')", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x.\n       max_reg (L x) = None \\<Longrightarrow>\n       aval (L x) (join_ir i r) = aval (L x) (join_ir i r')\n 2. \\<And>a1 a2.\n       \\<lbrakk>max_reg a1 = None \\<Longrightarrow>\n                aval a1 (join_ir i r) = aval a1 (join_ir i r');\n        max_reg a2 = None \\<Longrightarrow>\n        aval a2 (join_ir i r) = aval a2 (join_ir i r');\n        max_reg (Plus a1 a2) = None\\<rbrakk>\n       \\<Longrightarrow> aval (Plus a1 a2) (join_ir i r) =\n                         aval (Plus a1 a2) (join_ir i r')\n 3. \\<And>a1 a2.\n       \\<lbrakk>max_reg a1 = None \\<Longrightarrow>\n                aval a1 (join_ir i r) = aval a1 (join_ir i r');\n        max_reg a2 = None \\<Longrightarrow>\n        aval a2 (join_ir i r) = aval a2 (join_ir i r');\n        max_reg (Minus a1 a2) = None\\<rbrakk>\n       \\<Longrightarrow> aval (Minus a1 a2) (join_ir i r) =\n                         aval (Minus a1 a2) (join_ir i r')\n 4. \\<And>a1 a2.\n       \\<lbrakk>max_reg a1 = None \\<Longrightarrow>\n                aval a1 (join_ir i r) = aval a1 (join_ir i r');\n        max_reg a2 = None \\<Longrightarrow>\n        aval a2 (join_ir i r) = aval a2 (join_ir i r');\n        max_reg (Times a1 a2) = None\\<rbrakk>\n       \\<Longrightarrow> aval (Times a1 a2) (join_ir i r) =\n                         aval (Times a1 a2) (join_ir i r')", "case (Plus a1 a2)"], ["proof (state)\nthis:\n  max_reg a1 = None \\<Longrightarrow>\n  aval a1 (join_ir i r) = aval a1 (join_ir i r')\n  max_reg a2 = None \\<Longrightarrow>\n  aval a2 (join_ir i r) = aval a2 (join_ir i r')\n  max_reg (Plus a1 a2) = None\n\ngoal (4 subgoals):\n 1. \\<And>x.\n       max_reg (L x) = None \\<Longrightarrow>\n       aval (L x) (join_ir i r) = aval (L x) (join_ir i r')\n 2. \\<And>a1 a2.\n       \\<lbrakk>max_reg a1 = None \\<Longrightarrow>\n                aval a1 (join_ir i r) = aval a1 (join_ir i r');\n        max_reg a2 = None \\<Longrightarrow>\n        aval a2 (join_ir i r) = aval a2 (join_ir i r');\n        max_reg (Plus a1 a2) = None\\<rbrakk>\n       \\<Longrightarrow> aval (Plus a1 a2) (join_ir i r) =\n                         aval (Plus a1 a2) (join_ir i r')\n 3. \\<And>a1 a2.\n       \\<lbrakk>max_reg a1 = None \\<Longrightarrow>\n                aval a1 (join_ir i r) = aval a1 (join_ir i r');\n        max_reg a2 = None \\<Longrightarrow>\n        aval a2 (join_ir i r) = aval a2 (join_ir i r');\n        max_reg (Minus a1 a2) = None\\<rbrakk>\n       \\<Longrightarrow> aval (Minus a1 a2) (join_ir i r) =\n                         aval (Minus a1 a2) (join_ir i r')\n 4. \\<And>a1 a2.\n       \\<lbrakk>max_reg a1 = None \\<Longrightarrow>\n                aval a1 (join_ir i r) = aval a1 (join_ir i r');\n        max_reg a2 = None \\<Longrightarrow>\n        aval a2 (join_ir i r) = aval a2 (join_ir i r');\n        max_reg (Times a1 a2) = None\\<rbrakk>\n       \\<Longrightarrow> aval (Times a1 a2) (join_ir i r) =\n                         aval (Times a1 a2) (join_ir i r')", "then"], ["proof (chain)\npicking this:\n  max_reg a1 = None \\<Longrightarrow>\n  aval a1 (join_ir i r) = aval a1 (join_ir i r')\n  max_reg a2 = None \\<Longrightarrow>\n  aval a2 (join_ir i r) = aval a2 (join_ir i r')\n  max_reg (Plus a1 a2) = None", "show ?case"], ["proof (prove)\nusing this:\n  max_reg a1 = None \\<Longrightarrow>\n  aval a1 (join_ir i r) = aval a1 (join_ir i r')\n  max_reg a2 = None \\<Longrightarrow>\n  aval a2 (join_ir i r) = aval a2 (join_ir i r')\n  max_reg (Plus a1 a2) = None\n\ngoal (1 subgoal):\n 1. aval (Plus a1 a2) (join_ir i r) = aval (Plus a1 a2) (join_ir i r')", "by (metis (no_types, lifting) aval.simps(3) max.absorb2 max.cobounded2 max_reg_Plus sup_None_2 sup_max)"], ["proof (state)\nthis:\n  aval (Plus a1 a2) (join_ir i r) = aval (Plus a1 a2) (join_ir i r')\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       max_reg (L x) = None \\<Longrightarrow>\n       aval (L x) (join_ir i r) = aval (L x) (join_ir i r')\n 2. \\<And>a1 a2.\n       \\<lbrakk>max_reg a1 = None \\<Longrightarrow>\n                aval a1 (join_ir i r) = aval a1 (join_ir i r');\n        max_reg a2 = None \\<Longrightarrow>\n        aval a2 (join_ir i r) = aval a2 (join_ir i r');\n        max_reg (Minus a1 a2) = None\\<rbrakk>\n       \\<Longrightarrow> aval (Minus a1 a2) (join_ir i r) =\n                         aval (Minus a1 a2) (join_ir i r')\n 3. \\<And>a1 a2.\n       \\<lbrakk>max_reg a1 = None \\<Longrightarrow>\n                aval a1 (join_ir i r) = aval a1 (join_ir i r');\n        max_reg a2 = None \\<Longrightarrow>\n        aval a2 (join_ir i r) = aval a2 (join_ir i r');\n        max_reg (Times a1 a2) = None\\<rbrakk>\n       \\<Longrightarrow> aval (Times a1 a2) (join_ir i r) =\n                         aval (Times a1 a2) (join_ir i r')", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x.\n       max_reg (L x) = None \\<Longrightarrow>\n       aval (L x) (join_ir i r) = aval (L x) (join_ir i r')\n 2. \\<And>a1 a2.\n       \\<lbrakk>max_reg a1 = None \\<Longrightarrow>\n                aval a1 (join_ir i r) = aval a1 (join_ir i r');\n        max_reg a2 = None \\<Longrightarrow>\n        aval a2 (join_ir i r) = aval a2 (join_ir i r');\n        max_reg (Minus a1 a2) = None\\<rbrakk>\n       \\<Longrightarrow> aval (Minus a1 a2) (join_ir i r) =\n                         aval (Minus a1 a2) (join_ir i r')\n 3. \\<And>a1 a2.\n       \\<lbrakk>max_reg a1 = None \\<Longrightarrow>\n                aval a1 (join_ir i r) = aval a1 (join_ir i r');\n        max_reg a2 = None \\<Longrightarrow>\n        aval a2 (join_ir i r) = aval a2 (join_ir i r');\n        max_reg (Times a1 a2) = None\\<rbrakk>\n       \\<Longrightarrow> aval (Times a1 a2) (join_ir i r) =\n                         aval (Times a1 a2) (join_ir i r')", "case (Minus a1 a2)"], ["proof (state)\nthis:\n  max_reg a1 = None \\<Longrightarrow>\n  aval a1 (join_ir i r) = aval a1 (join_ir i r')\n  max_reg a2 = None \\<Longrightarrow>\n  aval a2 (join_ir i r) = aval a2 (join_ir i r')\n  max_reg (Minus a1 a2) = None\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       max_reg (L x) = None \\<Longrightarrow>\n       aval (L x) (join_ir i r) = aval (L x) (join_ir i r')\n 2. \\<And>a1 a2.\n       \\<lbrakk>max_reg a1 = None \\<Longrightarrow>\n                aval a1 (join_ir i r) = aval a1 (join_ir i r');\n        max_reg a2 = None \\<Longrightarrow>\n        aval a2 (join_ir i r) = aval a2 (join_ir i r');\n        max_reg (Minus a1 a2) = None\\<rbrakk>\n       \\<Longrightarrow> aval (Minus a1 a2) (join_ir i r) =\n                         aval (Minus a1 a2) (join_ir i r')\n 3. \\<And>a1 a2.\n       \\<lbrakk>max_reg a1 = None \\<Longrightarrow>\n                aval a1 (join_ir i r) = aval a1 (join_ir i r');\n        max_reg a2 = None \\<Longrightarrow>\n        aval a2 (join_ir i r) = aval a2 (join_ir i r');\n        max_reg (Times a1 a2) = None\\<rbrakk>\n       \\<Longrightarrow> aval (Times a1 a2) (join_ir i r) =\n                         aval (Times a1 a2) (join_ir i r')", "then"], ["proof (chain)\npicking this:\n  max_reg a1 = None \\<Longrightarrow>\n  aval a1 (join_ir i r) = aval a1 (join_ir i r')\n  max_reg a2 = None \\<Longrightarrow>\n  aval a2 (join_ir i r) = aval a2 (join_ir i r')\n  max_reg (Minus a1 a2) = None", "show ?case"], ["proof (prove)\nusing this:\n  max_reg a1 = None \\<Longrightarrow>\n  aval a1 (join_ir i r) = aval a1 (join_ir i r')\n  max_reg a2 = None \\<Longrightarrow>\n  aval a2 (join_ir i r) = aval a2 (join_ir i r')\n  max_reg (Minus a1 a2) = None\n\ngoal (1 subgoal):\n 1. aval (Minus a1 a2) (join_ir i r) = aval (Minus a1 a2) (join_ir i r')", "by (metis (no_types, lifting) aval.simps(4) max.cobounded2 max_def_raw max_reg_Minus sup_None_2 sup_max)"], ["proof (state)\nthis:\n  aval (Minus a1 a2) (join_ir i r) = aval (Minus a1 a2) (join_ir i r')\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       max_reg (L x) = None \\<Longrightarrow>\n       aval (L x) (join_ir i r) = aval (L x) (join_ir i r')\n 2. \\<And>a1 a2.\n       \\<lbrakk>max_reg a1 = None \\<Longrightarrow>\n                aval a1 (join_ir i r) = aval a1 (join_ir i r');\n        max_reg a2 = None \\<Longrightarrow>\n        aval a2 (join_ir i r) = aval a2 (join_ir i r');\n        max_reg (Times a1 a2) = None\\<rbrakk>\n       \\<Longrightarrow> aval (Times a1 a2) (join_ir i r) =\n                         aval (Times a1 a2) (join_ir i r')", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       max_reg (L x) = None \\<Longrightarrow>\n       aval (L x) (join_ir i r) = aval (L x) (join_ir i r')\n 2. \\<And>a1 a2.\n       \\<lbrakk>max_reg a1 = None \\<Longrightarrow>\n                aval a1 (join_ir i r) = aval a1 (join_ir i r');\n        max_reg a2 = None \\<Longrightarrow>\n        aval a2 (join_ir i r) = aval a2 (join_ir i r');\n        max_reg (Times a1 a2) = None\\<rbrakk>\n       \\<Longrightarrow> aval (Times a1 a2) (join_ir i r) =\n                         aval (Times a1 a2) (join_ir i r')", "case (Times a1 a2)"], ["proof (state)\nthis:\n  max_reg a1 = None \\<Longrightarrow>\n  aval a1 (join_ir i r) = aval a1 (join_ir i r')\n  max_reg a2 = None \\<Longrightarrow>\n  aval a2 (join_ir i r) = aval a2 (join_ir i r')\n  max_reg (Times a1 a2) = None\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       max_reg (L x) = None \\<Longrightarrow>\n       aval (L x) (join_ir i r) = aval (L x) (join_ir i r')\n 2. \\<And>a1 a2.\n       \\<lbrakk>max_reg a1 = None \\<Longrightarrow>\n                aval a1 (join_ir i r) = aval a1 (join_ir i r');\n        max_reg a2 = None \\<Longrightarrow>\n        aval a2 (join_ir i r) = aval a2 (join_ir i r');\n        max_reg (Times a1 a2) = None\\<rbrakk>\n       \\<Longrightarrow> aval (Times a1 a2) (join_ir i r) =\n                         aval (Times a1 a2) (join_ir i r')", "then"], ["proof (chain)\npicking this:\n  max_reg a1 = None \\<Longrightarrow>\n  aval a1 (join_ir i r) = aval a1 (join_ir i r')\n  max_reg a2 = None \\<Longrightarrow>\n  aval a2 (join_ir i r) = aval a2 (join_ir i r')\n  max_reg (Times a1 a2) = None", "show ?case"], ["proof (prove)\nusing this:\n  max_reg a1 = None \\<Longrightarrow>\n  aval a1 (join_ir i r) = aval a1 (join_ir i r')\n  max_reg a2 = None \\<Longrightarrow>\n  aval a2 (join_ir i r) = aval a2 (join_ir i r')\n  max_reg (Times a1 a2) = None\n\ngoal (1 subgoal):\n 1. aval (Times a1 a2) (join_ir i r) = aval (Times a1 a2) (join_ir i r')", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>max_reg a1 = None \\<Longrightarrow>\n             aval a1 (join_ir i r) = aval a1 (join_ir i r');\n     max_reg a2 = None \\<Longrightarrow>\n     aval a2 (join_ir i r) = aval a2 (join_ir i r');\n     max_reg (Times a1 a2) = None\\<rbrakk>\n    \\<Longrightarrow> aval (Times a1 a2) (join_ir i r) =\n                      aval (Times a1 a2) (join_ir i r')", "have \"bot = max_reg a2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bot = max_reg a2", "by (metis (no_types) Times.prems bot_option_def max.left_commute max_bot2 max_def_raw max_reg_Times)"], ["proof (state)\nthis:\n  bot = max_reg a2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>max_reg a1 = None \\<Longrightarrow>\n             aval a1 (join_ir i r) = aval a1 (join_ir i r');\n     max_reg a2 = None \\<Longrightarrow>\n     aval a2 (join_ir i r) = aval a2 (join_ir i r');\n     max_reg (Times a1 a2) = None\\<rbrakk>\n    \\<Longrightarrow> aval (Times a1 a2) (join_ir i r) =\n                      aval (Times a1 a2) (join_ir i r')", "then"], ["proof (chain)\npicking this:\n  bot = max_reg a2", "show ?thesis"], ["proof (prove)\nusing this:\n  bot = max_reg a2\n\ngoal (1 subgoal):\n 1. aval (Times a1 a2) (join_ir i r) = aval (Times a1 a2) (join_ir i r')", "by (metis Times.hyps(1) Times.hyps(2) Times.prems aval.simps(5) bot_option_def max_bot2 max_reg_Times)"], ["proof (state)\nthis:\n  aval (Times a1 a2) (join_ir i r) = aval (Times a1 a2) (join_ir i r')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  aval (Times a1 a2) (join_ir i r) = aval (Times a1 a2) (join_ir i r')\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       max_reg (L x) = None \\<Longrightarrow>\n       aval (L x) (join_ir i r) = aval (L x) (join_ir i r')", "qed auto"], ["", "lemma aval_reg_some_superset:\n\"\\<forall>a. (r $ a  \\<noteq> None) \\<longrightarrow> r $ a = r' $ a \\<Longrightarrow>\n aval a (join_ir i r) = Some v \\<Longrightarrow>\n aval a (join_ir i r') = Some v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>a.\n                r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n     aval a (join_ir i r) = Some v\\<rbrakk>\n    \\<Longrightarrow> aval a (join_ir i r') = Some v", "proof(induct a arbitrary: v rule: aexp_induct_separate_V_cases)"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>x v.\n       \\<lbrakk>\\<forall>a.\n                   r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n        aval (L x) (join_ir i r) = Some v\\<rbrakk>\n       \\<Longrightarrow> aval (L x) (join_ir i r') = Some v\n 2. \\<And>x v.\n       \\<lbrakk>\\<forall>a.\n                   r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n        aval (V (I x)) (join_ir i r) = Some v\\<rbrakk>\n       \\<Longrightarrow> aval (V (I x)) (join_ir i r') = Some v\n 3. \\<And>x v.\n       \\<lbrakk>\\<forall>a.\n                   r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n        aval (V (R x)) (join_ir i r) = Some v\\<rbrakk>\n       \\<Longrightarrow> aval (V (R x)) (join_ir i r') = Some v\n 4. \\<And>x1a x2a v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>\\<forall>a.\n                               r $ a \\<noteq> None \\<longrightarrow>\n                               r $ a = r' $ a;\n                    aval x1a (join_ir i r) = Some v\\<rbrakk>\n                   \\<Longrightarrow> aval x1a (join_ir i r') = Some v;\n        \\<And>v.\n           \\<lbrakk>\\<forall>a.\n                       r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n            aval x2a (join_ir i r) = Some v\\<rbrakk>\n           \\<Longrightarrow> aval x2a (join_ir i r') = Some v;\n        \\<forall>a. r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n        aval (Plus x1a x2a) (join_ir i r) = Some v\\<rbrakk>\n       \\<Longrightarrow> aval (Plus x1a x2a) (join_ir i r') = Some v\n 5. \\<And>x1a x2a v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>\\<forall>a.\n                               r $ a \\<noteq> None \\<longrightarrow>\n                               r $ a = r' $ a;\n                    aval x1a (join_ir i r) = Some v\\<rbrakk>\n                   \\<Longrightarrow> aval x1a (join_ir i r') = Some v;\n        \\<And>v.\n           \\<lbrakk>\\<forall>a.\n                       r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n            aval x2a (join_ir i r) = Some v\\<rbrakk>\n           \\<Longrightarrow> aval x2a (join_ir i r') = Some v;\n        \\<forall>a. r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n        aval (Minus x1a x2a) (join_ir i r) = Some v\\<rbrakk>\n       \\<Longrightarrow> aval (Minus x1a x2a) (join_ir i r') = Some v\n 6. \\<And>x1a x2a v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>\\<forall>a.\n                               r $ a \\<noteq> None \\<longrightarrow>\n                               r $ a = r' $ a;\n                    aval x1a (join_ir i r) = Some v\\<rbrakk>\n                   \\<Longrightarrow> aval x1a (join_ir i r') = Some v;\n        \\<And>v.\n           \\<lbrakk>\\<forall>a.\n                       r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n            aval x2a (join_ir i r) = Some v\\<rbrakk>\n           \\<Longrightarrow> aval x2a (join_ir i r') = Some v;\n        \\<forall>a. r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n        aval (Times x1a x2a) (join_ir i r) = Some v\\<rbrakk>\n       \\<Longrightarrow> aval (Times x1a x2a) (join_ir i r') = Some v", "case (I x)"], ["proof (state)\nthis:\n  \\<forall>a. r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a\n  aval (V (I x)) (join_ir i r) = Some v\n\ngoal (6 subgoals):\n 1. \\<And>x v.\n       \\<lbrakk>\\<forall>a.\n                   r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n        aval (L x) (join_ir i r) = Some v\\<rbrakk>\n       \\<Longrightarrow> aval (L x) (join_ir i r') = Some v\n 2. \\<And>x v.\n       \\<lbrakk>\\<forall>a.\n                   r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n        aval (V (I x)) (join_ir i r) = Some v\\<rbrakk>\n       \\<Longrightarrow> aval (V (I x)) (join_ir i r') = Some v\n 3. \\<And>x v.\n       \\<lbrakk>\\<forall>a.\n                   r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n        aval (V (R x)) (join_ir i r) = Some v\\<rbrakk>\n       \\<Longrightarrow> aval (V (R x)) (join_ir i r') = Some v\n 4. \\<And>x1a x2a v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>\\<forall>a.\n                               r $ a \\<noteq> None \\<longrightarrow>\n                               r $ a = r' $ a;\n                    aval x1a (join_ir i r) = Some v\\<rbrakk>\n                   \\<Longrightarrow> aval x1a (join_ir i r') = Some v;\n        \\<And>v.\n           \\<lbrakk>\\<forall>a.\n                       r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n            aval x2a (join_ir i r) = Some v\\<rbrakk>\n           \\<Longrightarrow> aval x2a (join_ir i r') = Some v;\n        \\<forall>a. r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n        aval (Plus x1a x2a) (join_ir i r) = Some v\\<rbrakk>\n       \\<Longrightarrow> aval (Plus x1a x2a) (join_ir i r') = Some v\n 5. \\<And>x1a x2a v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>\\<forall>a.\n                               r $ a \\<noteq> None \\<longrightarrow>\n                               r $ a = r' $ a;\n                    aval x1a (join_ir i r) = Some v\\<rbrakk>\n                   \\<Longrightarrow> aval x1a (join_ir i r') = Some v;\n        \\<And>v.\n           \\<lbrakk>\\<forall>a.\n                       r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n            aval x2a (join_ir i r) = Some v\\<rbrakk>\n           \\<Longrightarrow> aval x2a (join_ir i r') = Some v;\n        \\<forall>a. r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n        aval (Minus x1a x2a) (join_ir i r) = Some v\\<rbrakk>\n       \\<Longrightarrow> aval (Minus x1a x2a) (join_ir i r') = Some v\n 6. \\<And>x1a x2a v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>\\<forall>a.\n                               r $ a \\<noteq> None \\<longrightarrow>\n                               r $ a = r' $ a;\n                    aval x1a (join_ir i r) = Some v\\<rbrakk>\n                   \\<Longrightarrow> aval x1a (join_ir i r') = Some v;\n        \\<And>v.\n           \\<lbrakk>\\<forall>a.\n                       r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n            aval x2a (join_ir i r) = Some v\\<rbrakk>\n           \\<Longrightarrow> aval x2a (join_ir i r') = Some v;\n        \\<forall>a. r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n        aval (Times x1a x2a) (join_ir i r) = Some v\\<rbrakk>\n       \\<Longrightarrow> aval (Times x1a x2a) (join_ir i r') = Some v", "then"], ["proof (chain)\npicking this:\n  \\<forall>a. r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a\n  aval (V (I x)) (join_ir i r) = Some v", "show ?case"], ["proof (prove)\nusing this:\n  \\<forall>a. r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a\n  aval (V (I x)) (join_ir i r) = Some v\n\ngoal (1 subgoal):\n 1. aval (V (I x)) (join_ir i r') = Some v", "by (simp add: join_ir_def)"], ["proof (state)\nthis:\n  aval (V (I x)) (join_ir i r') = Some v\n\ngoal (5 subgoals):\n 1. \\<And>x v.\n       \\<lbrakk>\\<forall>a.\n                   r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n        aval (L x) (join_ir i r) = Some v\\<rbrakk>\n       \\<Longrightarrow> aval (L x) (join_ir i r') = Some v\n 2. \\<And>x v.\n       \\<lbrakk>\\<forall>a.\n                   r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n        aval (V (R x)) (join_ir i r) = Some v\\<rbrakk>\n       \\<Longrightarrow> aval (V (R x)) (join_ir i r') = Some v\n 3. \\<And>x1a x2a v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>\\<forall>a.\n                               r $ a \\<noteq> None \\<longrightarrow>\n                               r $ a = r' $ a;\n                    aval x1a (join_ir i r) = Some v\\<rbrakk>\n                   \\<Longrightarrow> aval x1a (join_ir i r') = Some v;\n        \\<And>v.\n           \\<lbrakk>\\<forall>a.\n                       r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n            aval x2a (join_ir i r) = Some v\\<rbrakk>\n           \\<Longrightarrow> aval x2a (join_ir i r') = Some v;\n        \\<forall>a. r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n        aval (Plus x1a x2a) (join_ir i r) = Some v\\<rbrakk>\n       \\<Longrightarrow> aval (Plus x1a x2a) (join_ir i r') = Some v\n 4. \\<And>x1a x2a v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>\\<forall>a.\n                               r $ a \\<noteq> None \\<longrightarrow>\n                               r $ a = r' $ a;\n                    aval x1a (join_ir i r) = Some v\\<rbrakk>\n                   \\<Longrightarrow> aval x1a (join_ir i r') = Some v;\n        \\<And>v.\n           \\<lbrakk>\\<forall>a.\n                       r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n            aval x2a (join_ir i r) = Some v\\<rbrakk>\n           \\<Longrightarrow> aval x2a (join_ir i r') = Some v;\n        \\<forall>a. r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n        aval (Minus x1a x2a) (join_ir i r) = Some v\\<rbrakk>\n       \\<Longrightarrow> aval (Minus x1a x2a) (join_ir i r') = Some v\n 5. \\<And>x1a x2a v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>\\<forall>a.\n                               r $ a \\<noteq> None \\<longrightarrow>\n                               r $ a = r' $ a;\n                    aval x1a (join_ir i r) = Some v\\<rbrakk>\n                   \\<Longrightarrow> aval x1a (join_ir i r') = Some v;\n        \\<And>v.\n           \\<lbrakk>\\<forall>a.\n                       r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n            aval x2a (join_ir i r) = Some v\\<rbrakk>\n           \\<Longrightarrow> aval x2a (join_ir i r') = Some v;\n        \\<forall>a. r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n        aval (Times x1a x2a) (join_ir i r) = Some v\\<rbrakk>\n       \\<Longrightarrow> aval (Times x1a x2a) (join_ir i r') = Some v", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>x v.\n       \\<lbrakk>\\<forall>a.\n                   r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n        aval (L x) (join_ir i r) = Some v\\<rbrakk>\n       \\<Longrightarrow> aval (L x) (join_ir i r') = Some v\n 2. \\<And>x v.\n       \\<lbrakk>\\<forall>a.\n                   r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n        aval (V (R x)) (join_ir i r) = Some v\\<rbrakk>\n       \\<Longrightarrow> aval (V (R x)) (join_ir i r') = Some v\n 3. \\<And>x1a x2a v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>\\<forall>a.\n                               r $ a \\<noteq> None \\<longrightarrow>\n                               r $ a = r' $ a;\n                    aval x1a (join_ir i r) = Some v\\<rbrakk>\n                   \\<Longrightarrow> aval x1a (join_ir i r') = Some v;\n        \\<And>v.\n           \\<lbrakk>\\<forall>a.\n                       r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n            aval x2a (join_ir i r) = Some v\\<rbrakk>\n           \\<Longrightarrow> aval x2a (join_ir i r') = Some v;\n        \\<forall>a. r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n        aval (Plus x1a x2a) (join_ir i r) = Some v\\<rbrakk>\n       \\<Longrightarrow> aval (Plus x1a x2a) (join_ir i r') = Some v\n 4. \\<And>x1a x2a v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>\\<forall>a.\n                               r $ a \\<noteq> None \\<longrightarrow>\n                               r $ a = r' $ a;\n                    aval x1a (join_ir i r) = Some v\\<rbrakk>\n                   \\<Longrightarrow> aval x1a (join_ir i r') = Some v;\n        \\<And>v.\n           \\<lbrakk>\\<forall>a.\n                       r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n            aval x2a (join_ir i r) = Some v\\<rbrakk>\n           \\<Longrightarrow> aval x2a (join_ir i r') = Some v;\n        \\<forall>a. r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n        aval (Minus x1a x2a) (join_ir i r) = Some v\\<rbrakk>\n       \\<Longrightarrow> aval (Minus x1a x2a) (join_ir i r') = Some v\n 5. \\<And>x1a x2a v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>\\<forall>a.\n                               r $ a \\<noteq> None \\<longrightarrow>\n                               r $ a = r' $ a;\n                    aval x1a (join_ir i r) = Some v\\<rbrakk>\n                   \\<Longrightarrow> aval x1a (join_ir i r') = Some v;\n        \\<And>v.\n           \\<lbrakk>\\<forall>a.\n                       r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n            aval x2a (join_ir i r) = Some v\\<rbrakk>\n           \\<Longrightarrow> aval x2a (join_ir i r') = Some v;\n        \\<forall>a. r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n        aval (Times x1a x2a) (join_ir i r) = Some v\\<rbrakk>\n       \\<Longrightarrow> aval (Times x1a x2a) (join_ir i r') = Some v", "case (Plus x1a x2a)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<forall>a. r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n   aval x1a (join_ir i r) = Some ?v\\<rbrakk>\n  \\<Longrightarrow> aval x1a (join_ir i r') = Some ?v\n  \\<lbrakk>\\<forall>a. r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n   aval x2a (join_ir i r) = Some ?v\\<rbrakk>\n  \\<Longrightarrow> aval x2a (join_ir i r') = Some ?v\n  \\<forall>a. r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a\n  aval (Plus x1a x2a) (join_ir i r) = Some v\n\ngoal (5 subgoals):\n 1. \\<And>x v.\n       \\<lbrakk>\\<forall>a.\n                   r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n        aval (L x) (join_ir i r) = Some v\\<rbrakk>\n       \\<Longrightarrow> aval (L x) (join_ir i r') = Some v\n 2. \\<And>x v.\n       \\<lbrakk>\\<forall>a.\n                   r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n        aval (V (R x)) (join_ir i r) = Some v\\<rbrakk>\n       \\<Longrightarrow> aval (V (R x)) (join_ir i r') = Some v\n 3. \\<And>x1a x2a v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>\\<forall>a.\n                               r $ a \\<noteq> None \\<longrightarrow>\n                               r $ a = r' $ a;\n                    aval x1a (join_ir i r) = Some v\\<rbrakk>\n                   \\<Longrightarrow> aval x1a (join_ir i r') = Some v;\n        \\<And>v.\n           \\<lbrakk>\\<forall>a.\n                       r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n            aval x2a (join_ir i r) = Some v\\<rbrakk>\n           \\<Longrightarrow> aval x2a (join_ir i r') = Some v;\n        \\<forall>a. r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n        aval (Plus x1a x2a) (join_ir i r) = Some v\\<rbrakk>\n       \\<Longrightarrow> aval (Plus x1a x2a) (join_ir i r') = Some v\n 4. \\<And>x1a x2a v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>\\<forall>a.\n                               r $ a \\<noteq> None \\<longrightarrow>\n                               r $ a = r' $ a;\n                    aval x1a (join_ir i r) = Some v\\<rbrakk>\n                   \\<Longrightarrow> aval x1a (join_ir i r') = Some v;\n        \\<And>v.\n           \\<lbrakk>\\<forall>a.\n                       r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n            aval x2a (join_ir i r) = Some v\\<rbrakk>\n           \\<Longrightarrow> aval x2a (join_ir i r') = Some v;\n        \\<forall>a. r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n        aval (Minus x1a x2a) (join_ir i r) = Some v\\<rbrakk>\n       \\<Longrightarrow> aval (Minus x1a x2a) (join_ir i r') = Some v\n 5. \\<And>x1a x2a v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>\\<forall>a.\n                               r $ a \\<noteq> None \\<longrightarrow>\n                               r $ a = r' $ a;\n                    aval x1a (join_ir i r) = Some v\\<rbrakk>\n                   \\<Longrightarrow> aval x1a (join_ir i r') = Some v;\n        \\<And>v.\n           \\<lbrakk>\\<forall>a.\n                       r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n            aval x2a (join_ir i r) = Some v\\<rbrakk>\n           \\<Longrightarrow> aval x2a (join_ir i r') = Some v;\n        \\<forall>a. r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n        aval (Times x1a x2a) (join_ir i r) = Some v\\<rbrakk>\n       \\<Longrightarrow> aval (Times x1a x2a) (join_ir i r') = Some v", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<forall>a. r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n   aval x1a (join_ir i r) = Some ?v\\<rbrakk>\n  \\<Longrightarrow> aval x1a (join_ir i r') = Some ?v\n  \\<lbrakk>\\<forall>a. r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n   aval x2a (join_ir i r) = Some ?v\\<rbrakk>\n  \\<Longrightarrow> aval x2a (join_ir i r') = Some ?v\n  \\<forall>a. r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a\n  aval (Plus x1a x2a) (join_ir i r) = Some v", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<forall>a. r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n   aval x1a (join_ir i r) = Some ?v\\<rbrakk>\n  \\<Longrightarrow> aval x1a (join_ir i r') = Some ?v\n  \\<lbrakk>\\<forall>a. r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n   aval x2a (join_ir i r) = Some ?v\\<rbrakk>\n  \\<Longrightarrow> aval x2a (join_ir i r') = Some ?v\n  \\<forall>a. r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a\n  aval (Plus x1a x2a) (join_ir i r) = Some v\n\ngoal (1 subgoal):\n 1. aval (Plus x1a x2a) (join_ir i r') = Some v", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>v.\n                aval x1a (join_ir i r) = Some v \\<Longrightarrow>\n                aval x1a (join_ir i r') = Some v;\n     \\<And>v.\n        aval x2a (join_ir i r) = Some v \\<Longrightarrow>\n        aval x2a (join_ir i r') = Some v;\n     \\<forall>a.\n        (\\<exists>y. r $ a = Some y) \\<longrightarrow> r $ a = r' $ a;\n     value_plus (aval x1a (join_ir i r)) (aval x2a (join_ir i r)) =\n     Some v\\<rbrakk>\n    \\<Longrightarrow> value_plus (aval x1a (join_ir i r'))\n                       (aval x2a (join_ir i r')) =\n                      Some v", "by (metis maybe_arith_int_not_None option.simps(3) value_plus_def)"], ["proof (state)\nthis:\n  aval (Plus x1a x2a) (join_ir i r') = Some v\n\ngoal (4 subgoals):\n 1. \\<And>x v.\n       \\<lbrakk>\\<forall>a.\n                   r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n        aval (L x) (join_ir i r) = Some v\\<rbrakk>\n       \\<Longrightarrow> aval (L x) (join_ir i r') = Some v\n 2. \\<And>x v.\n       \\<lbrakk>\\<forall>a.\n                   r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n        aval (V (R x)) (join_ir i r) = Some v\\<rbrakk>\n       \\<Longrightarrow> aval (V (R x)) (join_ir i r') = Some v\n 3. \\<And>x1a x2a v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>\\<forall>a.\n                               r $ a \\<noteq> None \\<longrightarrow>\n                               r $ a = r' $ a;\n                    aval x1a (join_ir i r) = Some v\\<rbrakk>\n                   \\<Longrightarrow> aval x1a (join_ir i r') = Some v;\n        \\<And>v.\n           \\<lbrakk>\\<forall>a.\n                       r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n            aval x2a (join_ir i r) = Some v\\<rbrakk>\n           \\<Longrightarrow> aval x2a (join_ir i r') = Some v;\n        \\<forall>a. r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n        aval (Minus x1a x2a) (join_ir i r) = Some v\\<rbrakk>\n       \\<Longrightarrow> aval (Minus x1a x2a) (join_ir i r') = Some v\n 4. \\<And>x1a x2a v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>\\<forall>a.\n                               r $ a \\<noteq> None \\<longrightarrow>\n                               r $ a = r' $ a;\n                    aval x1a (join_ir i r) = Some v\\<rbrakk>\n                   \\<Longrightarrow> aval x1a (join_ir i r') = Some v;\n        \\<And>v.\n           \\<lbrakk>\\<forall>a.\n                       r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n            aval x2a (join_ir i r) = Some v\\<rbrakk>\n           \\<Longrightarrow> aval x2a (join_ir i r') = Some v;\n        \\<forall>a. r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n        aval (Times x1a x2a) (join_ir i r) = Some v\\<rbrakk>\n       \\<Longrightarrow> aval (Times x1a x2a) (join_ir i r') = Some v", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x v.\n       \\<lbrakk>\\<forall>a.\n                   r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n        aval (L x) (join_ir i r) = Some v\\<rbrakk>\n       \\<Longrightarrow> aval (L x) (join_ir i r') = Some v\n 2. \\<And>x v.\n       \\<lbrakk>\\<forall>a.\n                   r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n        aval (V (R x)) (join_ir i r) = Some v\\<rbrakk>\n       \\<Longrightarrow> aval (V (R x)) (join_ir i r') = Some v\n 3. \\<And>x1a x2a v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>\\<forall>a.\n                               r $ a \\<noteq> None \\<longrightarrow>\n                               r $ a = r' $ a;\n                    aval x1a (join_ir i r) = Some v\\<rbrakk>\n                   \\<Longrightarrow> aval x1a (join_ir i r') = Some v;\n        \\<And>v.\n           \\<lbrakk>\\<forall>a.\n                       r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n            aval x2a (join_ir i r) = Some v\\<rbrakk>\n           \\<Longrightarrow> aval x2a (join_ir i r') = Some v;\n        \\<forall>a. r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n        aval (Minus x1a x2a) (join_ir i r) = Some v\\<rbrakk>\n       \\<Longrightarrow> aval (Minus x1a x2a) (join_ir i r') = Some v\n 4. \\<And>x1a x2a v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>\\<forall>a.\n                               r $ a \\<noteq> None \\<longrightarrow>\n                               r $ a = r' $ a;\n                    aval x1a (join_ir i r) = Some v\\<rbrakk>\n                   \\<Longrightarrow> aval x1a (join_ir i r') = Some v;\n        \\<And>v.\n           \\<lbrakk>\\<forall>a.\n                       r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n            aval x2a (join_ir i r) = Some v\\<rbrakk>\n           \\<Longrightarrow> aval x2a (join_ir i r') = Some v;\n        \\<forall>a. r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n        aval (Times x1a x2a) (join_ir i r) = Some v\\<rbrakk>\n       \\<Longrightarrow> aval (Times x1a x2a) (join_ir i r') = Some v", "case (Minus x1a x2a)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<forall>a. r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n   aval x1a (join_ir i r) = Some ?v\\<rbrakk>\n  \\<Longrightarrow> aval x1a (join_ir i r') = Some ?v\n  \\<lbrakk>\\<forall>a. r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n   aval x2a (join_ir i r) = Some ?v\\<rbrakk>\n  \\<Longrightarrow> aval x2a (join_ir i r') = Some ?v\n  \\<forall>a. r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a\n  aval (Minus x1a x2a) (join_ir i r) = Some v\n\ngoal (4 subgoals):\n 1. \\<And>x v.\n       \\<lbrakk>\\<forall>a.\n                   r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n        aval (L x) (join_ir i r) = Some v\\<rbrakk>\n       \\<Longrightarrow> aval (L x) (join_ir i r') = Some v\n 2. \\<And>x v.\n       \\<lbrakk>\\<forall>a.\n                   r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n        aval (V (R x)) (join_ir i r) = Some v\\<rbrakk>\n       \\<Longrightarrow> aval (V (R x)) (join_ir i r') = Some v\n 3. \\<And>x1a x2a v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>\\<forall>a.\n                               r $ a \\<noteq> None \\<longrightarrow>\n                               r $ a = r' $ a;\n                    aval x1a (join_ir i r) = Some v\\<rbrakk>\n                   \\<Longrightarrow> aval x1a (join_ir i r') = Some v;\n        \\<And>v.\n           \\<lbrakk>\\<forall>a.\n                       r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n            aval x2a (join_ir i r) = Some v\\<rbrakk>\n           \\<Longrightarrow> aval x2a (join_ir i r') = Some v;\n        \\<forall>a. r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n        aval (Minus x1a x2a) (join_ir i r) = Some v\\<rbrakk>\n       \\<Longrightarrow> aval (Minus x1a x2a) (join_ir i r') = Some v\n 4. \\<And>x1a x2a v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>\\<forall>a.\n                               r $ a \\<noteq> None \\<longrightarrow>\n                               r $ a = r' $ a;\n                    aval x1a (join_ir i r) = Some v\\<rbrakk>\n                   \\<Longrightarrow> aval x1a (join_ir i r') = Some v;\n        \\<And>v.\n           \\<lbrakk>\\<forall>a.\n                       r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n            aval x2a (join_ir i r) = Some v\\<rbrakk>\n           \\<Longrightarrow> aval x2a (join_ir i r') = Some v;\n        \\<forall>a. r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n        aval (Times x1a x2a) (join_ir i r) = Some v\\<rbrakk>\n       \\<Longrightarrow> aval (Times x1a x2a) (join_ir i r') = Some v", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<forall>a. r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n   aval x1a (join_ir i r) = Some ?v\\<rbrakk>\n  \\<Longrightarrow> aval x1a (join_ir i r') = Some ?v\n  \\<lbrakk>\\<forall>a. r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n   aval x2a (join_ir i r) = Some ?v\\<rbrakk>\n  \\<Longrightarrow> aval x2a (join_ir i r') = Some ?v\n  \\<forall>a. r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a\n  aval (Minus x1a x2a) (join_ir i r) = Some v", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<forall>a. r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n   aval x1a (join_ir i r) = Some ?v\\<rbrakk>\n  \\<Longrightarrow> aval x1a (join_ir i r') = Some ?v\n  \\<lbrakk>\\<forall>a. r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n   aval x2a (join_ir i r) = Some ?v\\<rbrakk>\n  \\<Longrightarrow> aval x2a (join_ir i r') = Some ?v\n  \\<forall>a. r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a\n  aval (Minus x1a x2a) (join_ir i r) = Some v\n\ngoal (1 subgoal):\n 1. aval (Minus x1a x2a) (join_ir i r') = Some v", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>v.\n                aval x1a (join_ir i r) = Some v \\<Longrightarrow>\n                aval x1a (join_ir i r') = Some v;\n     \\<And>v.\n        aval x2a (join_ir i r) = Some v \\<Longrightarrow>\n        aval x2a (join_ir i r') = Some v;\n     \\<forall>a.\n        (\\<exists>y. r $ a = Some y) \\<longrightarrow> r $ a = r' $ a;\n     value_minus (aval x1a (join_ir i r)) (aval x2a (join_ir i r)) =\n     Some v\\<rbrakk>\n    \\<Longrightarrow> value_minus (aval x1a (join_ir i r'))\n                       (aval x2a (join_ir i r')) =\n                      Some v", "by (metis maybe_arith_int_not_None option.simps(3) value_minus_def)"], ["proof (state)\nthis:\n  aval (Minus x1a x2a) (join_ir i r') = Some v\n\ngoal (3 subgoals):\n 1. \\<And>x v.\n       \\<lbrakk>\\<forall>a.\n                   r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n        aval (L x) (join_ir i r) = Some v\\<rbrakk>\n       \\<Longrightarrow> aval (L x) (join_ir i r') = Some v\n 2. \\<And>x v.\n       \\<lbrakk>\\<forall>a.\n                   r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n        aval (V (R x)) (join_ir i r) = Some v\\<rbrakk>\n       \\<Longrightarrow> aval (V (R x)) (join_ir i r') = Some v\n 3. \\<And>x1a x2a v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>\\<forall>a.\n                               r $ a \\<noteq> None \\<longrightarrow>\n                               r $ a = r' $ a;\n                    aval x1a (join_ir i r) = Some v\\<rbrakk>\n                   \\<Longrightarrow> aval x1a (join_ir i r') = Some v;\n        \\<And>v.\n           \\<lbrakk>\\<forall>a.\n                       r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n            aval x2a (join_ir i r) = Some v\\<rbrakk>\n           \\<Longrightarrow> aval x2a (join_ir i r') = Some v;\n        \\<forall>a. r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n        aval (Times x1a x2a) (join_ir i r) = Some v\\<rbrakk>\n       \\<Longrightarrow> aval (Times x1a x2a) (join_ir i r') = Some v", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x v.\n       \\<lbrakk>\\<forall>a.\n                   r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n        aval (L x) (join_ir i r) = Some v\\<rbrakk>\n       \\<Longrightarrow> aval (L x) (join_ir i r') = Some v\n 2. \\<And>x v.\n       \\<lbrakk>\\<forall>a.\n                   r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n        aval (V (R x)) (join_ir i r) = Some v\\<rbrakk>\n       \\<Longrightarrow> aval (V (R x)) (join_ir i r') = Some v\n 3. \\<And>x1a x2a v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>\\<forall>a.\n                               r $ a \\<noteq> None \\<longrightarrow>\n                               r $ a = r' $ a;\n                    aval x1a (join_ir i r) = Some v\\<rbrakk>\n                   \\<Longrightarrow> aval x1a (join_ir i r') = Some v;\n        \\<And>v.\n           \\<lbrakk>\\<forall>a.\n                       r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n            aval x2a (join_ir i r) = Some v\\<rbrakk>\n           \\<Longrightarrow> aval x2a (join_ir i r') = Some v;\n        \\<forall>a. r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n        aval (Times x1a x2a) (join_ir i r) = Some v\\<rbrakk>\n       \\<Longrightarrow> aval (Times x1a x2a) (join_ir i r') = Some v", "case (Times x1a x2a)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<forall>a. r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n   aval x1a (join_ir i r) = Some ?v\\<rbrakk>\n  \\<Longrightarrow> aval x1a (join_ir i r') = Some ?v\n  \\<lbrakk>\\<forall>a. r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n   aval x2a (join_ir i r) = Some ?v\\<rbrakk>\n  \\<Longrightarrow> aval x2a (join_ir i r') = Some ?v\n  \\<forall>a. r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a\n  aval (Times x1a x2a) (join_ir i r) = Some v\n\ngoal (3 subgoals):\n 1. \\<And>x v.\n       \\<lbrakk>\\<forall>a.\n                   r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n        aval (L x) (join_ir i r) = Some v\\<rbrakk>\n       \\<Longrightarrow> aval (L x) (join_ir i r') = Some v\n 2. \\<And>x v.\n       \\<lbrakk>\\<forall>a.\n                   r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n        aval (V (R x)) (join_ir i r) = Some v\\<rbrakk>\n       \\<Longrightarrow> aval (V (R x)) (join_ir i r') = Some v\n 3. \\<And>x1a x2a v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>\\<forall>a.\n                               r $ a \\<noteq> None \\<longrightarrow>\n                               r $ a = r' $ a;\n                    aval x1a (join_ir i r) = Some v\\<rbrakk>\n                   \\<Longrightarrow> aval x1a (join_ir i r') = Some v;\n        \\<And>v.\n           \\<lbrakk>\\<forall>a.\n                       r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n            aval x2a (join_ir i r) = Some v\\<rbrakk>\n           \\<Longrightarrow> aval x2a (join_ir i r') = Some v;\n        \\<forall>a. r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n        aval (Times x1a x2a) (join_ir i r) = Some v\\<rbrakk>\n       \\<Longrightarrow> aval (Times x1a x2a) (join_ir i r') = Some v", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<forall>a. r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n   aval x1a (join_ir i r) = Some ?v\\<rbrakk>\n  \\<Longrightarrow> aval x1a (join_ir i r') = Some ?v\n  \\<lbrakk>\\<forall>a. r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n   aval x2a (join_ir i r) = Some ?v\\<rbrakk>\n  \\<Longrightarrow> aval x2a (join_ir i r') = Some ?v\n  \\<forall>a. r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a\n  aval (Times x1a x2a) (join_ir i r) = Some v", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<forall>a. r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n   aval x1a (join_ir i r) = Some ?v\\<rbrakk>\n  \\<Longrightarrow> aval x1a (join_ir i r') = Some ?v\n  \\<lbrakk>\\<forall>a. r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n   aval x2a (join_ir i r) = Some ?v\\<rbrakk>\n  \\<Longrightarrow> aval x2a (join_ir i r') = Some ?v\n  \\<forall>a. r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a\n  aval (Times x1a x2a) (join_ir i r) = Some v\n\ngoal (1 subgoal):\n 1. aval (Times x1a x2a) (join_ir i r') = Some v", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>v.\n                aval x1a (join_ir i r) = Some v \\<Longrightarrow>\n                aval x1a (join_ir i r') = Some v;\n     \\<And>v.\n        aval x2a (join_ir i r) = Some v \\<Longrightarrow>\n        aval x2a (join_ir i r') = Some v;\n     \\<forall>a.\n        (\\<exists>y. r $ a = Some y) \\<longrightarrow> r $ a = r' $ a;\n     value_times (aval x1a (join_ir i r)) (aval x2a (join_ir i r)) =\n     Some v\\<rbrakk>\n    \\<Longrightarrow> value_times (aval x1a (join_ir i r'))\n                       (aval x2a (join_ir i r')) =\n                      Some v", "by (metis maybe_arith_int_not_None option.simps(3) value_times_def)"], ["proof (state)\nthis:\n  aval (Times x1a x2a) (join_ir i r') = Some v\n\ngoal (2 subgoals):\n 1. \\<And>x v.\n       \\<lbrakk>\\<forall>a.\n                   r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n        aval (L x) (join_ir i r) = Some v\\<rbrakk>\n       \\<Longrightarrow> aval (L x) (join_ir i r') = Some v\n 2. \\<And>x v.\n       \\<lbrakk>\\<forall>a.\n                   r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n        aval (V (R x)) (join_ir i r) = Some v\\<rbrakk>\n       \\<Longrightarrow> aval (V (R x)) (join_ir i r') = Some v", "qed auto"], ["", "lemma aval_reg_none_superset:\n\"\\<forall>a. (r $ a  \\<noteq> None) \\<longrightarrow> r $ a = r' $ a \\<Longrightarrow>\n aval a (join_ir i r') = None \\<Longrightarrow>\n aval a (join_ir i r) = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>a.\n                r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n     aval a (join_ir i r') = None\\<rbrakk>\n    \\<Longrightarrow> aval a (join_ir i r) = None", "proof(induct a)"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>a.\n                   r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n        aval (L x) (join_ir i r') = None\\<rbrakk>\n       \\<Longrightarrow> aval (L x) (join_ir i r) = None\n 2. \\<And>x.\n       \\<lbrakk>\\<forall>a.\n                   r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n        aval (V x) (join_ir i r') = None\\<rbrakk>\n       \\<Longrightarrow> aval (V x) (join_ir i r) = None\n 3. \\<And>a1 a2.\n       \\<lbrakk>\\<lbrakk>\\<forall>a.\n                            r $ a \\<noteq> None \\<longrightarrow>\n                            r $ a = r' $ a;\n                 aval a1 (join_ir i r') = None\\<rbrakk>\n                \\<Longrightarrow> aval a1 (join_ir i r) = None;\n        \\<lbrakk>\\<forall>a.\n                    r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n         aval a2 (join_ir i r') = None\\<rbrakk>\n        \\<Longrightarrow> aval a2 (join_ir i r) = None;\n        \\<forall>a. r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n        aval (Plus a1 a2) (join_ir i r') = None\\<rbrakk>\n       \\<Longrightarrow> aval (Plus a1 a2) (join_ir i r) = None\n 4. \\<And>a1 a2.\n       \\<lbrakk>\\<lbrakk>\\<forall>a.\n                            r $ a \\<noteq> None \\<longrightarrow>\n                            r $ a = r' $ a;\n                 aval a1 (join_ir i r') = None\\<rbrakk>\n                \\<Longrightarrow> aval a1 (join_ir i r) = None;\n        \\<lbrakk>\\<forall>a.\n                    r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n         aval a2 (join_ir i r') = None\\<rbrakk>\n        \\<Longrightarrow> aval a2 (join_ir i r) = None;\n        \\<forall>a. r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n        aval (Minus a1 a2) (join_ir i r') = None\\<rbrakk>\n       \\<Longrightarrow> aval (Minus a1 a2) (join_ir i r) = None\n 5. \\<And>a1 a2.\n       \\<lbrakk>\\<lbrakk>\\<forall>a.\n                            r $ a \\<noteq> None \\<longrightarrow>\n                            r $ a = r' $ a;\n                 aval a1 (join_ir i r') = None\\<rbrakk>\n                \\<Longrightarrow> aval a1 (join_ir i r) = None;\n        \\<lbrakk>\\<forall>a.\n                    r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n         aval a2 (join_ir i r') = None\\<rbrakk>\n        \\<Longrightarrow> aval a2 (join_ir i r) = None;\n        \\<forall>a. r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n        aval (Times a1 a2) (join_ir i r') = None\\<rbrakk>\n       \\<Longrightarrow> aval (Times a1 a2) (join_ir i r) = None", "case (V x)"], ["proof (state)\nthis:\n  \\<forall>a. r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a\n  aval (V x) (join_ir i r') = None\n\ngoal (5 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>a.\n                   r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n        aval (L x) (join_ir i r') = None\\<rbrakk>\n       \\<Longrightarrow> aval (L x) (join_ir i r) = None\n 2. \\<And>x.\n       \\<lbrakk>\\<forall>a.\n                   r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n        aval (V x) (join_ir i r') = None\\<rbrakk>\n       \\<Longrightarrow> aval (V x) (join_ir i r) = None\n 3. \\<And>a1 a2.\n       \\<lbrakk>\\<lbrakk>\\<forall>a.\n                            r $ a \\<noteq> None \\<longrightarrow>\n                            r $ a = r' $ a;\n                 aval a1 (join_ir i r') = None\\<rbrakk>\n                \\<Longrightarrow> aval a1 (join_ir i r) = None;\n        \\<lbrakk>\\<forall>a.\n                    r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n         aval a2 (join_ir i r') = None\\<rbrakk>\n        \\<Longrightarrow> aval a2 (join_ir i r) = None;\n        \\<forall>a. r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n        aval (Plus a1 a2) (join_ir i r') = None\\<rbrakk>\n       \\<Longrightarrow> aval (Plus a1 a2) (join_ir i r) = None\n 4. \\<And>a1 a2.\n       \\<lbrakk>\\<lbrakk>\\<forall>a.\n                            r $ a \\<noteq> None \\<longrightarrow>\n                            r $ a = r' $ a;\n                 aval a1 (join_ir i r') = None\\<rbrakk>\n                \\<Longrightarrow> aval a1 (join_ir i r) = None;\n        \\<lbrakk>\\<forall>a.\n                    r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n         aval a2 (join_ir i r') = None\\<rbrakk>\n        \\<Longrightarrow> aval a2 (join_ir i r) = None;\n        \\<forall>a. r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n        aval (Minus a1 a2) (join_ir i r') = None\\<rbrakk>\n       \\<Longrightarrow> aval (Minus a1 a2) (join_ir i r) = None\n 5. \\<And>a1 a2.\n       \\<lbrakk>\\<lbrakk>\\<forall>a.\n                            r $ a \\<noteq> None \\<longrightarrow>\n                            r $ a = r' $ a;\n                 aval a1 (join_ir i r') = None\\<rbrakk>\n                \\<Longrightarrow> aval a1 (join_ir i r) = None;\n        \\<lbrakk>\\<forall>a.\n                    r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n         aval a2 (join_ir i r') = None\\<rbrakk>\n        \\<Longrightarrow> aval a2 (join_ir i r) = None;\n        \\<forall>a. r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n        aval (Times a1 a2) (join_ir i r') = None\\<rbrakk>\n       \\<Longrightarrow> aval (Times a1 a2) (join_ir i r) = None", "then"], ["proof (chain)\npicking this:\n  \\<forall>a. r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a\n  aval (V x) (join_ir i r') = None", "show ?case"], ["proof (prove)\nusing this:\n  \\<forall>a. r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a\n  aval (V x) (join_ir i r') = None\n\ngoal (1 subgoal):\n 1. aval (V x) (join_ir i r) = None", "apply (cases x)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>\\<forall>a.\n                   r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n        aval (V x) (join_ir i r') = None; x = I x1\\<rbrakk>\n       \\<Longrightarrow> aval (V x) (join_ir i r) = None\n 2. \\<And>x2.\n       \\<lbrakk>\\<forall>a.\n                   r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n        aval (V x) (join_ir i r') = None; x = R x2\\<rbrakk>\n       \\<Longrightarrow> aval (V x) (join_ir i r) = None", "apply (simp add: join_ir_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<lbrakk>\\<forall>a.\n                   r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n        aval (V x) (join_ir i r') = None; x = R x2\\<rbrakk>\n       \\<Longrightarrow> aval (V x) (join_ir i r) = None", "by auto"], ["proof (state)\nthis:\n  aval (V x) (join_ir i r) = None\n\ngoal (4 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>a.\n                   r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n        aval (L x) (join_ir i r') = None\\<rbrakk>\n       \\<Longrightarrow> aval (L x) (join_ir i r) = None\n 2. \\<And>a1 a2.\n       \\<lbrakk>\\<lbrakk>\\<forall>a.\n                            r $ a \\<noteq> None \\<longrightarrow>\n                            r $ a = r' $ a;\n                 aval a1 (join_ir i r') = None\\<rbrakk>\n                \\<Longrightarrow> aval a1 (join_ir i r) = None;\n        \\<lbrakk>\\<forall>a.\n                    r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n         aval a2 (join_ir i r') = None\\<rbrakk>\n        \\<Longrightarrow> aval a2 (join_ir i r) = None;\n        \\<forall>a. r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n        aval (Plus a1 a2) (join_ir i r') = None\\<rbrakk>\n       \\<Longrightarrow> aval (Plus a1 a2) (join_ir i r) = None\n 3. \\<And>a1 a2.\n       \\<lbrakk>\\<lbrakk>\\<forall>a.\n                            r $ a \\<noteq> None \\<longrightarrow>\n                            r $ a = r' $ a;\n                 aval a1 (join_ir i r') = None\\<rbrakk>\n                \\<Longrightarrow> aval a1 (join_ir i r) = None;\n        \\<lbrakk>\\<forall>a.\n                    r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n         aval a2 (join_ir i r') = None\\<rbrakk>\n        \\<Longrightarrow> aval a2 (join_ir i r) = None;\n        \\<forall>a. r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n        aval (Minus a1 a2) (join_ir i r') = None\\<rbrakk>\n       \\<Longrightarrow> aval (Minus a1 a2) (join_ir i r) = None\n 4. \\<And>a1 a2.\n       \\<lbrakk>\\<lbrakk>\\<forall>a.\n                            r $ a \\<noteq> None \\<longrightarrow>\n                            r $ a = r' $ a;\n                 aval a1 (join_ir i r') = None\\<rbrakk>\n                \\<Longrightarrow> aval a1 (join_ir i r) = None;\n        \\<lbrakk>\\<forall>a.\n                    r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n         aval a2 (join_ir i r') = None\\<rbrakk>\n        \\<Longrightarrow> aval a2 (join_ir i r) = None;\n        \\<forall>a. r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n        aval (Times a1 a2) (join_ir i r') = None\\<rbrakk>\n       \\<Longrightarrow> aval (Times a1 a2) (join_ir i r) = None", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>a.\n                   r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n        aval (L x) (join_ir i r') = None\\<rbrakk>\n       \\<Longrightarrow> aval (L x) (join_ir i r) = None\n 2. \\<And>a1 a2.\n       \\<lbrakk>\\<lbrakk>\\<forall>a.\n                            r $ a \\<noteq> None \\<longrightarrow>\n                            r $ a = r' $ a;\n                 aval a1 (join_ir i r') = None\\<rbrakk>\n                \\<Longrightarrow> aval a1 (join_ir i r) = None;\n        \\<lbrakk>\\<forall>a.\n                    r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n         aval a2 (join_ir i r') = None\\<rbrakk>\n        \\<Longrightarrow> aval a2 (join_ir i r) = None;\n        \\<forall>a. r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n        aval (Plus a1 a2) (join_ir i r') = None\\<rbrakk>\n       \\<Longrightarrow> aval (Plus a1 a2) (join_ir i r) = None\n 3. \\<And>a1 a2.\n       \\<lbrakk>\\<lbrakk>\\<forall>a.\n                            r $ a \\<noteq> None \\<longrightarrow>\n                            r $ a = r' $ a;\n                 aval a1 (join_ir i r') = None\\<rbrakk>\n                \\<Longrightarrow> aval a1 (join_ir i r) = None;\n        \\<lbrakk>\\<forall>a.\n                    r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n         aval a2 (join_ir i r') = None\\<rbrakk>\n        \\<Longrightarrow> aval a2 (join_ir i r) = None;\n        \\<forall>a. r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n        aval (Minus a1 a2) (join_ir i r') = None\\<rbrakk>\n       \\<Longrightarrow> aval (Minus a1 a2) (join_ir i r) = None\n 4. \\<And>a1 a2.\n       \\<lbrakk>\\<lbrakk>\\<forall>a.\n                            r $ a \\<noteq> None \\<longrightarrow>\n                            r $ a = r' $ a;\n                 aval a1 (join_ir i r') = None\\<rbrakk>\n                \\<Longrightarrow> aval a1 (join_ir i r) = None;\n        \\<lbrakk>\\<forall>a.\n                    r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n         aval a2 (join_ir i r') = None\\<rbrakk>\n        \\<Longrightarrow> aval a2 (join_ir i r) = None;\n        \\<forall>a. r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n        aval (Times a1 a2) (join_ir i r') = None\\<rbrakk>\n       \\<Longrightarrow> aval (Times a1 a2) (join_ir i r) = None", "case (Plus a1 a2)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<forall>a. r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n   aval a1 (join_ir i r') = None\\<rbrakk>\n  \\<Longrightarrow> aval a1 (join_ir i r) = None\n  \\<lbrakk>\\<forall>a. r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n   aval a2 (join_ir i r') = None\\<rbrakk>\n  \\<Longrightarrow> aval a2 (join_ir i r) = None\n  \\<forall>a. r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a\n  aval (Plus a1 a2) (join_ir i r') = None\n\ngoal (4 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>a.\n                   r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n        aval (L x) (join_ir i r') = None\\<rbrakk>\n       \\<Longrightarrow> aval (L x) (join_ir i r) = None\n 2. \\<And>a1 a2.\n       \\<lbrakk>\\<lbrakk>\\<forall>a.\n                            r $ a \\<noteq> None \\<longrightarrow>\n                            r $ a = r' $ a;\n                 aval a1 (join_ir i r') = None\\<rbrakk>\n                \\<Longrightarrow> aval a1 (join_ir i r) = None;\n        \\<lbrakk>\\<forall>a.\n                    r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n         aval a2 (join_ir i r') = None\\<rbrakk>\n        \\<Longrightarrow> aval a2 (join_ir i r) = None;\n        \\<forall>a. r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n        aval (Plus a1 a2) (join_ir i r') = None\\<rbrakk>\n       \\<Longrightarrow> aval (Plus a1 a2) (join_ir i r) = None\n 3. \\<And>a1 a2.\n       \\<lbrakk>\\<lbrakk>\\<forall>a.\n                            r $ a \\<noteq> None \\<longrightarrow>\n                            r $ a = r' $ a;\n                 aval a1 (join_ir i r') = None\\<rbrakk>\n                \\<Longrightarrow> aval a1 (join_ir i r) = None;\n        \\<lbrakk>\\<forall>a.\n                    r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n         aval a2 (join_ir i r') = None\\<rbrakk>\n        \\<Longrightarrow> aval a2 (join_ir i r) = None;\n        \\<forall>a. r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n        aval (Minus a1 a2) (join_ir i r') = None\\<rbrakk>\n       \\<Longrightarrow> aval (Minus a1 a2) (join_ir i r) = None\n 4. \\<And>a1 a2.\n       \\<lbrakk>\\<lbrakk>\\<forall>a.\n                            r $ a \\<noteq> None \\<longrightarrow>\n                            r $ a = r' $ a;\n                 aval a1 (join_ir i r') = None\\<rbrakk>\n                \\<Longrightarrow> aval a1 (join_ir i r) = None;\n        \\<lbrakk>\\<forall>a.\n                    r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n         aval a2 (join_ir i r') = None\\<rbrakk>\n        \\<Longrightarrow> aval a2 (join_ir i r) = None;\n        \\<forall>a. r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n        aval (Times a1 a2) (join_ir i r') = None\\<rbrakk>\n       \\<Longrightarrow> aval (Times a1 a2) (join_ir i r) = None", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<forall>a. r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n   aval a1 (join_ir i r') = None\\<rbrakk>\n  \\<Longrightarrow> aval a1 (join_ir i r) = None\n  \\<lbrakk>\\<forall>a. r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n   aval a2 (join_ir i r') = None\\<rbrakk>\n  \\<Longrightarrow> aval a2 (join_ir i r) = None\n  \\<forall>a. r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a\n  aval (Plus a1 a2) (join_ir i r') = None", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<forall>a. r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n   aval a1 (join_ir i r') = None\\<rbrakk>\n  \\<Longrightarrow> aval a1 (join_ir i r) = None\n  \\<lbrakk>\\<forall>a. r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n   aval a2 (join_ir i r') = None\\<rbrakk>\n  \\<Longrightarrow> aval a2 (join_ir i r) = None\n  \\<forall>a. r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a\n  aval (Plus a1 a2) (join_ir i r') = None\n\ngoal (1 subgoal):\n 1. aval (Plus a1 a2) (join_ir i r) = None", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>aval a1 (join_ir i r') = None \\<Longrightarrow>\n             aval a1 (join_ir i r) = None;\n     aval a2 (join_ir i r') = None \\<Longrightarrow>\n     aval a2 (join_ir i r) = None;\n     \\<forall>a.\n        (\\<exists>y. r $ a = Some y) \\<longrightarrow> r $ a = r' $ a;\n     value_plus (aval a1 (join_ir i r')) (aval a2 (join_ir i r')) =\n     None\\<rbrakk>\n    \\<Longrightarrow> value_plus (aval a1 (join_ir i r))\n                       (aval a2 (join_ir i r)) =\n                      None", "by (metis (no_types, lifting) maybe_arith_int_None Plus.prems(1) aval_reg_some_superset value_plus_def)"], ["proof (state)\nthis:\n  aval (Plus a1 a2) (join_ir i r) = None\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>a.\n                   r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n        aval (L x) (join_ir i r') = None\\<rbrakk>\n       \\<Longrightarrow> aval (L x) (join_ir i r) = None\n 2. \\<And>a1 a2.\n       \\<lbrakk>\\<lbrakk>\\<forall>a.\n                            r $ a \\<noteq> None \\<longrightarrow>\n                            r $ a = r' $ a;\n                 aval a1 (join_ir i r') = None\\<rbrakk>\n                \\<Longrightarrow> aval a1 (join_ir i r) = None;\n        \\<lbrakk>\\<forall>a.\n                    r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n         aval a2 (join_ir i r') = None\\<rbrakk>\n        \\<Longrightarrow> aval a2 (join_ir i r) = None;\n        \\<forall>a. r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n        aval (Minus a1 a2) (join_ir i r') = None\\<rbrakk>\n       \\<Longrightarrow> aval (Minus a1 a2) (join_ir i r) = None\n 3. \\<And>a1 a2.\n       \\<lbrakk>\\<lbrakk>\\<forall>a.\n                            r $ a \\<noteq> None \\<longrightarrow>\n                            r $ a = r' $ a;\n                 aval a1 (join_ir i r') = None\\<rbrakk>\n                \\<Longrightarrow> aval a1 (join_ir i r) = None;\n        \\<lbrakk>\\<forall>a.\n                    r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n         aval a2 (join_ir i r') = None\\<rbrakk>\n        \\<Longrightarrow> aval a2 (join_ir i r) = None;\n        \\<forall>a. r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n        aval (Times a1 a2) (join_ir i r') = None\\<rbrakk>\n       \\<Longrightarrow> aval (Times a1 a2) (join_ir i r) = None", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>a.\n                   r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n        aval (L x) (join_ir i r') = None\\<rbrakk>\n       \\<Longrightarrow> aval (L x) (join_ir i r) = None\n 2. \\<And>a1 a2.\n       \\<lbrakk>\\<lbrakk>\\<forall>a.\n                            r $ a \\<noteq> None \\<longrightarrow>\n                            r $ a = r' $ a;\n                 aval a1 (join_ir i r') = None\\<rbrakk>\n                \\<Longrightarrow> aval a1 (join_ir i r) = None;\n        \\<lbrakk>\\<forall>a.\n                    r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n         aval a2 (join_ir i r') = None\\<rbrakk>\n        \\<Longrightarrow> aval a2 (join_ir i r) = None;\n        \\<forall>a. r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n        aval (Minus a1 a2) (join_ir i r') = None\\<rbrakk>\n       \\<Longrightarrow> aval (Minus a1 a2) (join_ir i r) = None\n 3. \\<And>a1 a2.\n       \\<lbrakk>\\<lbrakk>\\<forall>a.\n                            r $ a \\<noteq> None \\<longrightarrow>\n                            r $ a = r' $ a;\n                 aval a1 (join_ir i r') = None\\<rbrakk>\n                \\<Longrightarrow> aval a1 (join_ir i r) = None;\n        \\<lbrakk>\\<forall>a.\n                    r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n         aval a2 (join_ir i r') = None\\<rbrakk>\n        \\<Longrightarrow> aval a2 (join_ir i r) = None;\n        \\<forall>a. r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n        aval (Times a1 a2) (join_ir i r') = None\\<rbrakk>\n       \\<Longrightarrow> aval (Times a1 a2) (join_ir i r) = None", "case (Minus a1 a2)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<forall>a. r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n   aval a1 (join_ir i r') = None\\<rbrakk>\n  \\<Longrightarrow> aval a1 (join_ir i r) = None\n  \\<lbrakk>\\<forall>a. r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n   aval a2 (join_ir i r') = None\\<rbrakk>\n  \\<Longrightarrow> aval a2 (join_ir i r) = None\n  \\<forall>a. r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a\n  aval (Minus a1 a2) (join_ir i r') = None\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>a.\n                   r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n        aval (L x) (join_ir i r') = None\\<rbrakk>\n       \\<Longrightarrow> aval (L x) (join_ir i r) = None\n 2. \\<And>a1 a2.\n       \\<lbrakk>\\<lbrakk>\\<forall>a.\n                            r $ a \\<noteq> None \\<longrightarrow>\n                            r $ a = r' $ a;\n                 aval a1 (join_ir i r') = None\\<rbrakk>\n                \\<Longrightarrow> aval a1 (join_ir i r) = None;\n        \\<lbrakk>\\<forall>a.\n                    r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n         aval a2 (join_ir i r') = None\\<rbrakk>\n        \\<Longrightarrow> aval a2 (join_ir i r) = None;\n        \\<forall>a. r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n        aval (Minus a1 a2) (join_ir i r') = None\\<rbrakk>\n       \\<Longrightarrow> aval (Minus a1 a2) (join_ir i r) = None\n 3. \\<And>a1 a2.\n       \\<lbrakk>\\<lbrakk>\\<forall>a.\n                            r $ a \\<noteq> None \\<longrightarrow>\n                            r $ a = r' $ a;\n                 aval a1 (join_ir i r') = None\\<rbrakk>\n                \\<Longrightarrow> aval a1 (join_ir i r) = None;\n        \\<lbrakk>\\<forall>a.\n                    r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n         aval a2 (join_ir i r') = None\\<rbrakk>\n        \\<Longrightarrow> aval a2 (join_ir i r) = None;\n        \\<forall>a. r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n        aval (Times a1 a2) (join_ir i r') = None\\<rbrakk>\n       \\<Longrightarrow> aval (Times a1 a2) (join_ir i r) = None", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<forall>a. r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n   aval a1 (join_ir i r') = None\\<rbrakk>\n  \\<Longrightarrow> aval a1 (join_ir i r) = None\n  \\<lbrakk>\\<forall>a. r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n   aval a2 (join_ir i r') = None\\<rbrakk>\n  \\<Longrightarrow> aval a2 (join_ir i r) = None\n  \\<forall>a. r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a\n  aval (Minus a1 a2) (join_ir i r') = None", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<forall>a. r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n   aval a1 (join_ir i r') = None\\<rbrakk>\n  \\<Longrightarrow> aval a1 (join_ir i r) = None\n  \\<lbrakk>\\<forall>a. r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n   aval a2 (join_ir i r') = None\\<rbrakk>\n  \\<Longrightarrow> aval a2 (join_ir i r) = None\n  \\<forall>a. r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a\n  aval (Minus a1 a2) (join_ir i r') = None\n\ngoal (1 subgoal):\n 1. aval (Minus a1 a2) (join_ir i r) = None", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>aval a1 (join_ir i r') = None \\<Longrightarrow>\n             aval a1 (join_ir i r) = None;\n     aval a2 (join_ir i r') = None \\<Longrightarrow>\n     aval a2 (join_ir i r) = None;\n     \\<forall>a.\n        (\\<exists>y. r $ a = Some y) \\<longrightarrow> r $ a = r' $ a;\n     value_minus (aval a1 (join_ir i r')) (aval a2 (join_ir i r')) =\n     None\\<rbrakk>\n    \\<Longrightarrow> value_minus (aval a1 (join_ir i r))\n                       (aval a2 (join_ir i r)) =\n                      None", "by (metis (no_types, lifting) maybe_arith_int_None Minus.prems(1) aval_reg_some_superset value_minus_def)"], ["proof (state)\nthis:\n  aval (Minus a1 a2) (join_ir i r) = None\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>a.\n                   r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n        aval (L x) (join_ir i r') = None\\<rbrakk>\n       \\<Longrightarrow> aval (L x) (join_ir i r) = None\n 2. \\<And>a1 a2.\n       \\<lbrakk>\\<lbrakk>\\<forall>a.\n                            r $ a \\<noteq> None \\<longrightarrow>\n                            r $ a = r' $ a;\n                 aval a1 (join_ir i r') = None\\<rbrakk>\n                \\<Longrightarrow> aval a1 (join_ir i r) = None;\n        \\<lbrakk>\\<forall>a.\n                    r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n         aval a2 (join_ir i r') = None\\<rbrakk>\n        \\<Longrightarrow> aval a2 (join_ir i r) = None;\n        \\<forall>a. r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n        aval (Times a1 a2) (join_ir i r') = None\\<rbrakk>\n       \\<Longrightarrow> aval (Times a1 a2) (join_ir i r) = None", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>a.\n                   r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n        aval (L x) (join_ir i r') = None\\<rbrakk>\n       \\<Longrightarrow> aval (L x) (join_ir i r) = None\n 2. \\<And>a1 a2.\n       \\<lbrakk>\\<lbrakk>\\<forall>a.\n                            r $ a \\<noteq> None \\<longrightarrow>\n                            r $ a = r' $ a;\n                 aval a1 (join_ir i r') = None\\<rbrakk>\n                \\<Longrightarrow> aval a1 (join_ir i r) = None;\n        \\<lbrakk>\\<forall>a.\n                    r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n         aval a2 (join_ir i r') = None\\<rbrakk>\n        \\<Longrightarrow> aval a2 (join_ir i r) = None;\n        \\<forall>a. r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n        aval (Times a1 a2) (join_ir i r') = None\\<rbrakk>\n       \\<Longrightarrow> aval (Times a1 a2) (join_ir i r) = None", "case (Times a1 a2)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<forall>a. r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n   aval a1 (join_ir i r') = None\\<rbrakk>\n  \\<Longrightarrow> aval a1 (join_ir i r) = None\n  \\<lbrakk>\\<forall>a. r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n   aval a2 (join_ir i r') = None\\<rbrakk>\n  \\<Longrightarrow> aval a2 (join_ir i r) = None\n  \\<forall>a. r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a\n  aval (Times a1 a2) (join_ir i r') = None\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>a.\n                   r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n        aval (L x) (join_ir i r') = None\\<rbrakk>\n       \\<Longrightarrow> aval (L x) (join_ir i r) = None\n 2. \\<And>a1 a2.\n       \\<lbrakk>\\<lbrakk>\\<forall>a.\n                            r $ a \\<noteq> None \\<longrightarrow>\n                            r $ a = r' $ a;\n                 aval a1 (join_ir i r') = None\\<rbrakk>\n                \\<Longrightarrow> aval a1 (join_ir i r) = None;\n        \\<lbrakk>\\<forall>a.\n                    r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n         aval a2 (join_ir i r') = None\\<rbrakk>\n        \\<Longrightarrow> aval a2 (join_ir i r) = None;\n        \\<forall>a. r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n        aval (Times a1 a2) (join_ir i r') = None\\<rbrakk>\n       \\<Longrightarrow> aval (Times a1 a2) (join_ir i r) = None", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<forall>a. r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n   aval a1 (join_ir i r') = None\\<rbrakk>\n  \\<Longrightarrow> aval a1 (join_ir i r) = None\n  \\<lbrakk>\\<forall>a. r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n   aval a2 (join_ir i r') = None\\<rbrakk>\n  \\<Longrightarrow> aval a2 (join_ir i r) = None\n  \\<forall>a. r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a\n  aval (Times a1 a2) (join_ir i r') = None", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<forall>a. r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n   aval a1 (join_ir i r') = None\\<rbrakk>\n  \\<Longrightarrow> aval a1 (join_ir i r) = None\n  \\<lbrakk>\\<forall>a. r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n   aval a2 (join_ir i r') = None\\<rbrakk>\n  \\<Longrightarrow> aval a2 (join_ir i r) = None\n  \\<forall>a. r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a\n  aval (Times a1 a2) (join_ir i r') = None\n\ngoal (1 subgoal):\n 1. aval (Times a1 a2) (join_ir i r) = None", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>aval a1 (join_ir i r') = None \\<Longrightarrow>\n             aval a1 (join_ir i r) = None;\n     aval a2 (join_ir i r') = None \\<Longrightarrow>\n     aval a2 (join_ir i r) = None;\n     \\<forall>a.\n        (\\<exists>y. r $ a = Some y) \\<longrightarrow> r $ a = r' $ a;\n     value_times (aval a1 (join_ir i r')) (aval a2 (join_ir i r')) =\n     None\\<rbrakk>\n    \\<Longrightarrow> value_times (aval a1 (join_ir i r))\n                       (aval a2 (join_ir i r)) =\n                      None", "by (metis (no_types, lifting) maybe_arith_int_None Times.prems(1) aval_reg_some_superset value_times_def)"], ["proof (state)\nthis:\n  aval (Times a1 a2) (join_ir i r) = None\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>a.\n                   r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n        aval (L x) (join_ir i r') = None\\<rbrakk>\n       \\<Longrightarrow> aval (L x) (join_ir i r) = None", "qed auto"], ["", "lemma enumerate_regs_empty_reg_unconstrained:\n  \"enumerate_regs a = {} \\<Longrightarrow> \\<forall>r. \\<not> aexp_constrains a (V (R r))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enumerate_regs a = {} \\<Longrightarrow>\n    \\<forall>r. \\<not> aexp_constrains a (V (R r))", "by (induct a rule: aexp_induct_separate_V_cases, auto)"], ["", "lemma enumerate_aexp_inputs_empty_input_unconstrained:\n  \"enumerate_aexp_inputs a = {} \\<Longrightarrow> \\<forall>r. \\<not> aexp_constrains a (V (I r))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enumerate_aexp_inputs a = {} \\<Longrightarrow>\n    \\<forall>r. \\<not> aexp_constrains a (V (I r))", "by (induct a rule: aexp_induct_separate_V_cases, auto)"], ["", "lemma input_unconstrained_aval_input_swap:\n  \"\\<forall>i. \\<not> aexp_constrains a (V (I i)) \\<Longrightarrow>\n   aval a (join_ir i r) = aval a (join_ir i' r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i. \\<not> aexp_constrains a (V (I i)) \\<Longrightarrow>\n    aval a (join_ir i r) = aval a (join_ir i' r)", "using join_ir_def"], ["proof (prove)\nusing this:\n  join_ir ?i ?r \\<equiv>\n  \\<lambda>x.\n     case x of I n \\<Rightarrow> input2state ?i $ n\n     | R n \\<Rightarrow> ?r $ n\n\ngoal (1 subgoal):\n 1. \\<forall>i. \\<not> aexp_constrains a (V (I i)) \\<Longrightarrow>\n    aval a (join_ir i r) = aval a (join_ir i' r)", "by (induct a rule: aexp_induct_separate_V_cases, auto)"], ["", "lemma input_unconstrained_aval_register_swap:\n  \"\\<forall>i. \\<not> aexp_constrains a (V (R i)) \\<Longrightarrow>\n   aval a (join_ir i r) = aval a (join_ir i r')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i. \\<not> aexp_constrains a (V (R i)) \\<Longrightarrow>\n    aval a (join_ir i r) = aval a (join_ir i r')", "using join_ir_def"], ["proof (prove)\nusing this:\n  join_ir ?i ?r \\<equiv>\n  \\<lambda>x.\n     case x of I n \\<Rightarrow> input2state ?i $ n\n     | R n \\<Rightarrow> ?r $ n\n\ngoal (1 subgoal):\n 1. \\<forall>i. \\<not> aexp_constrains a (V (R i)) \\<Longrightarrow>\n    aval a (join_ir i r) = aval a (join_ir i r')", "by (induct a rule: aexp_induct_separate_V_cases, auto)"], ["", "lemma unconstrained_variable_swap_aval:\n  \"\\<forall>i. \\<not> aexp_constrains a (V (I i)) \\<Longrightarrow>\n   \\<forall>r. \\<not> aexp_constrains a (V (R r)) \\<Longrightarrow>\n   aval a s = aval a s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>i. \\<not> aexp_constrains a (V (I i));\n     \\<forall>r. \\<not> aexp_constrains a (V (R r))\\<rbrakk>\n    \\<Longrightarrow> aval a s = aval a s'", "by (induct a rule: aexp_induct_separate_V_cases, auto)"], ["", "lemma max_input_I: \"max_input (V (vname.I i)) = Some i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. max_input (V (I i)) = Some i", "by (simp add: max_input_def)"], ["", "lemma max_input_Plus:\n  \"max_input (Plus a1 a2) = max (max_input a1) (max_input a2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. max_input (Plus a1 a2) = max (max_input a1) (max_input a2)", "apply (simp add: max_input_def Let_def max.commute max_absorb2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. enumerate_aexp_inputs a1 \\<noteq> {} \\<longrightarrow>\n    enumerate_aexp_inputs a2 \\<noteq> {} \\<longrightarrow>\n    Some\n     (Max (enumerate_aexp_inputs a1 \\<union> enumerate_aexp_inputs a2)) =\n    max (Some (Max (enumerate_aexp_inputs a1)))\n     (Some (Max (enumerate_aexp_inputs a2)))", "by (metis List.finite_set Max.union enumerate_aexp_inputs_list sup_Some sup_max)"], ["", "lemma max_input_Minus:\n  \"max_input (Minus a1 a2) = max (max_input a1) (max_input a2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. max_input (Minus a1 a2) = max (max_input a1) (max_input a2)", "apply (simp add: max_input_def Let_def max.commute max_absorb2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. enumerate_aexp_inputs a1 \\<noteq> {} \\<longrightarrow>\n    enumerate_aexp_inputs a2 \\<noteq> {} \\<longrightarrow>\n    Some\n     (Max (enumerate_aexp_inputs a1 \\<union> enumerate_aexp_inputs a2)) =\n    max (Some (Max (enumerate_aexp_inputs a1)))\n     (Some (Max (enumerate_aexp_inputs a2)))", "by (metis List.finite_set Max.union enumerate_aexp_inputs_list sup_Some sup_max)"], ["", "lemma max_input_Times:\n  \"max_input (Times a1 a2) = max (max_input a1) (max_input a2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. max_input (Times a1 a2) = max (max_input a1) (max_input a2)", "apply (simp add: max_input_def Let_def max.commute max_absorb2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. enumerate_aexp_inputs a1 \\<noteq> {} \\<longrightarrow>\n    enumerate_aexp_inputs a2 \\<noteq> {} \\<longrightarrow>\n    Some\n     (Max (enumerate_aexp_inputs a1 \\<union> enumerate_aexp_inputs a2)) =\n    max (Some (Max (enumerate_aexp_inputs a1)))\n     (Some (Max (enumerate_aexp_inputs a2)))", "by (metis List.finite_set Max.union enumerate_aexp_inputs_list sup_Some sup_max)"], ["", "lemma aval_take:\n  \"max_input x < Some a \\<Longrightarrow>\n   aval x (join_ir i r) = aval x (join_ir (take a i) r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. max_input x < Some a \\<Longrightarrow>\n    aval x (join_ir i r) = aval x (join_ir (take a i) r)", "proof(induct x rule: aexp_induct_separate_V_cases)"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>x.\n       max_input (L x) < Some a \\<Longrightarrow>\n       aval (L x) (join_ir i r) = aval (L x) (join_ir (take a i) r)\n 2. \\<And>x.\n       max_input (V (I x)) < Some a \\<Longrightarrow>\n       aval (V (I x)) (join_ir i r) = aval (V (I x)) (join_ir (take a i) r)\n 3. \\<And>x.\n       max_input (V (R x)) < Some a \\<Longrightarrow>\n       aval (V (R x)) (join_ir i r) = aval (V (R x)) (join_ir (take a i) r)\n 4. \\<And>x1a x2a.\n       \\<lbrakk>max_input x1a < Some a \\<Longrightarrow>\n                aval x1a (join_ir i r) = aval x1a (join_ir (take a i) r);\n        max_input x2a < Some a \\<Longrightarrow>\n        aval x2a (join_ir i r) = aval x2a (join_ir (take a i) r);\n        max_input (Plus x1a x2a) < Some a\\<rbrakk>\n       \\<Longrightarrow> aval (Plus x1a x2a) (join_ir i r) =\n                         aval (Plus x1a x2a) (join_ir (take a i) r)\n 5. \\<And>x1a x2a.\n       \\<lbrakk>max_input x1a < Some a \\<Longrightarrow>\n                aval x1a (join_ir i r) = aval x1a (join_ir (take a i) r);\n        max_input x2a < Some a \\<Longrightarrow>\n        aval x2a (join_ir i r) = aval x2a (join_ir (take a i) r);\n        max_input (Minus x1a x2a) < Some a\\<rbrakk>\n       \\<Longrightarrow> aval (Minus x1a x2a) (join_ir i r) =\n                         aval (Minus x1a x2a) (join_ir (take a i) r)\n 6. \\<And>x1a x2a.\n       \\<lbrakk>max_input x1a < Some a \\<Longrightarrow>\n                aval x1a (join_ir i r) = aval x1a (join_ir (take a i) r);\n        max_input x2a < Some a \\<Longrightarrow>\n        aval x2a (join_ir i r) = aval x2a (join_ir (take a i) r);\n        max_input (Times x1a x2a) < Some a\\<rbrakk>\n       \\<Longrightarrow> aval (Times x1a x2a) (join_ir i r) =\n                         aval (Times x1a x2a) (join_ir (take a i) r)", "case (I x)"], ["proof (state)\nthis:\n  max_input (V (I x)) < Some a\n\ngoal (6 subgoals):\n 1. \\<And>x.\n       max_input (L x) < Some a \\<Longrightarrow>\n       aval (L x) (join_ir i r) = aval (L x) (join_ir (take a i) r)\n 2. \\<And>x.\n       max_input (V (I x)) < Some a \\<Longrightarrow>\n       aval (V (I x)) (join_ir i r) = aval (V (I x)) (join_ir (take a i) r)\n 3. \\<And>x.\n       max_input (V (R x)) < Some a \\<Longrightarrow>\n       aval (V (R x)) (join_ir i r) = aval (V (R x)) (join_ir (take a i) r)\n 4. \\<And>x1a x2a.\n       \\<lbrakk>max_input x1a < Some a \\<Longrightarrow>\n                aval x1a (join_ir i r) = aval x1a (join_ir (take a i) r);\n        max_input x2a < Some a \\<Longrightarrow>\n        aval x2a (join_ir i r) = aval x2a (join_ir (take a i) r);\n        max_input (Plus x1a x2a) < Some a\\<rbrakk>\n       \\<Longrightarrow> aval (Plus x1a x2a) (join_ir i r) =\n                         aval (Plus x1a x2a) (join_ir (take a i) r)\n 5. \\<And>x1a x2a.\n       \\<lbrakk>max_input x1a < Some a \\<Longrightarrow>\n                aval x1a (join_ir i r) = aval x1a (join_ir (take a i) r);\n        max_input x2a < Some a \\<Longrightarrow>\n        aval x2a (join_ir i r) = aval x2a (join_ir (take a i) r);\n        max_input (Minus x1a x2a) < Some a\\<rbrakk>\n       \\<Longrightarrow> aval (Minus x1a x2a) (join_ir i r) =\n                         aval (Minus x1a x2a) (join_ir (take a i) r)\n 6. \\<And>x1a x2a.\n       \\<lbrakk>max_input x1a < Some a \\<Longrightarrow>\n                aval x1a (join_ir i r) = aval x1a (join_ir (take a i) r);\n        max_input x2a < Some a \\<Longrightarrow>\n        aval x2a (join_ir i r) = aval x2a (join_ir (take a i) r);\n        max_input (Times x1a x2a) < Some a\\<rbrakk>\n       \\<Longrightarrow> aval (Times x1a x2a) (join_ir i r) =\n                         aval (Times x1a x2a) (join_ir (take a i) r)", "then"], ["proof (chain)\npicking this:\n  max_input (V (I x)) < Some a", "show ?case"], ["proof (prove)\nusing this:\n  max_input (V (I x)) < Some a\n\ngoal (1 subgoal):\n 1. aval (V (I x)) (join_ir i r) = aval (V (I x)) (join_ir (take a i) r)", "by (metis aval.simps(2) input2state_take join_ir_def le_cases less_option_Some max_input_I take_all vname.simps(5))"], ["proof (state)\nthis:\n  aval (V (I x)) (join_ir i r) = aval (V (I x)) (join_ir (take a i) r)\n\ngoal (5 subgoals):\n 1. \\<And>x.\n       max_input (L x) < Some a \\<Longrightarrow>\n       aval (L x) (join_ir i r) = aval (L x) (join_ir (take a i) r)\n 2. \\<And>x.\n       max_input (V (R x)) < Some a \\<Longrightarrow>\n       aval (V (R x)) (join_ir i r) = aval (V (R x)) (join_ir (take a i) r)\n 3. \\<And>x1a x2a.\n       \\<lbrakk>max_input x1a < Some a \\<Longrightarrow>\n                aval x1a (join_ir i r) = aval x1a (join_ir (take a i) r);\n        max_input x2a < Some a \\<Longrightarrow>\n        aval x2a (join_ir i r) = aval x2a (join_ir (take a i) r);\n        max_input (Plus x1a x2a) < Some a\\<rbrakk>\n       \\<Longrightarrow> aval (Plus x1a x2a) (join_ir i r) =\n                         aval (Plus x1a x2a) (join_ir (take a i) r)\n 4. \\<And>x1a x2a.\n       \\<lbrakk>max_input x1a < Some a \\<Longrightarrow>\n                aval x1a (join_ir i r) = aval x1a (join_ir (take a i) r);\n        max_input x2a < Some a \\<Longrightarrow>\n        aval x2a (join_ir i r) = aval x2a (join_ir (take a i) r);\n        max_input (Minus x1a x2a) < Some a\\<rbrakk>\n       \\<Longrightarrow> aval (Minus x1a x2a) (join_ir i r) =\n                         aval (Minus x1a x2a) (join_ir (take a i) r)\n 5. \\<And>x1a x2a.\n       \\<lbrakk>max_input x1a < Some a \\<Longrightarrow>\n                aval x1a (join_ir i r) = aval x1a (join_ir (take a i) r);\n        max_input x2a < Some a \\<Longrightarrow>\n        aval x2a (join_ir i r) = aval x2a (join_ir (take a i) r);\n        max_input (Times x1a x2a) < Some a\\<rbrakk>\n       \\<Longrightarrow> aval (Times x1a x2a) (join_ir i r) =\n                         aval (Times x1a x2a) (join_ir (take a i) r)", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>x.\n       max_input (L x) < Some a \\<Longrightarrow>\n       aval (L x) (join_ir i r) = aval (L x) (join_ir (take a i) r)\n 2. \\<And>x.\n       max_input (V (R x)) < Some a \\<Longrightarrow>\n       aval (V (R x)) (join_ir i r) = aval (V (R x)) (join_ir (take a i) r)\n 3. \\<And>x1a x2a.\n       \\<lbrakk>max_input x1a < Some a \\<Longrightarrow>\n                aval x1a (join_ir i r) = aval x1a (join_ir (take a i) r);\n        max_input x2a < Some a \\<Longrightarrow>\n        aval x2a (join_ir i r) = aval x2a (join_ir (take a i) r);\n        max_input (Plus x1a x2a) < Some a\\<rbrakk>\n       \\<Longrightarrow> aval (Plus x1a x2a) (join_ir i r) =\n                         aval (Plus x1a x2a) (join_ir (take a i) r)\n 4. \\<And>x1a x2a.\n       \\<lbrakk>max_input x1a < Some a \\<Longrightarrow>\n                aval x1a (join_ir i r) = aval x1a (join_ir (take a i) r);\n        max_input x2a < Some a \\<Longrightarrow>\n        aval x2a (join_ir i r) = aval x2a (join_ir (take a i) r);\n        max_input (Minus x1a x2a) < Some a\\<rbrakk>\n       \\<Longrightarrow> aval (Minus x1a x2a) (join_ir i r) =\n                         aval (Minus x1a x2a) (join_ir (take a i) r)\n 5. \\<And>x1a x2a.\n       \\<lbrakk>max_input x1a < Some a \\<Longrightarrow>\n                aval x1a (join_ir i r) = aval x1a (join_ir (take a i) r);\n        max_input x2a < Some a \\<Longrightarrow>\n        aval x2a (join_ir i r) = aval x2a (join_ir (take a i) r);\n        max_input (Times x1a x2a) < Some a\\<rbrakk>\n       \\<Longrightarrow> aval (Times x1a x2a) (join_ir i r) =\n                         aval (Times x1a x2a) (join_ir (take a i) r)", "case (R x)"], ["proof (state)\nthis:\n  max_input (V (R x)) < Some a\n\ngoal (5 subgoals):\n 1. \\<And>x.\n       max_input (L x) < Some a \\<Longrightarrow>\n       aval (L x) (join_ir i r) = aval (L x) (join_ir (take a i) r)\n 2. \\<And>x.\n       max_input (V (R x)) < Some a \\<Longrightarrow>\n       aval (V (R x)) (join_ir i r) = aval (V (R x)) (join_ir (take a i) r)\n 3. \\<And>x1a x2a.\n       \\<lbrakk>max_input x1a < Some a \\<Longrightarrow>\n                aval x1a (join_ir i r) = aval x1a (join_ir (take a i) r);\n        max_input x2a < Some a \\<Longrightarrow>\n        aval x2a (join_ir i r) = aval x2a (join_ir (take a i) r);\n        max_input (Plus x1a x2a) < Some a\\<rbrakk>\n       \\<Longrightarrow> aval (Plus x1a x2a) (join_ir i r) =\n                         aval (Plus x1a x2a) (join_ir (take a i) r)\n 4. \\<And>x1a x2a.\n       \\<lbrakk>max_input x1a < Some a \\<Longrightarrow>\n                aval x1a (join_ir i r) = aval x1a (join_ir (take a i) r);\n        max_input x2a < Some a \\<Longrightarrow>\n        aval x2a (join_ir i r) = aval x2a (join_ir (take a i) r);\n        max_input (Minus x1a x2a) < Some a\\<rbrakk>\n       \\<Longrightarrow> aval (Minus x1a x2a) (join_ir i r) =\n                         aval (Minus x1a x2a) (join_ir (take a i) r)\n 5. \\<And>x1a x2a.\n       \\<lbrakk>max_input x1a < Some a \\<Longrightarrow>\n                aval x1a (join_ir i r) = aval x1a (join_ir (take a i) r);\n        max_input x2a < Some a \\<Longrightarrow>\n        aval x2a (join_ir i r) = aval x2a (join_ir (take a i) r);\n        max_input (Times x1a x2a) < Some a\\<rbrakk>\n       \\<Longrightarrow> aval (Times x1a x2a) (join_ir i r) =\n                         aval (Times x1a x2a) (join_ir (take a i) r)", "then"], ["proof (chain)\npicking this:\n  max_input (V (R x)) < Some a", "show ?case"], ["proof (prove)\nusing this:\n  max_input (V (R x)) < Some a\n\ngoal (1 subgoal):\n 1. aval (V (R x)) (join_ir i r) = aval (V (R x)) (join_ir (take a i) r)", "by (simp add: join_ir_def)"], ["proof (state)\nthis:\n  aval (V (R x)) (join_ir i r) = aval (V (R x)) (join_ir (take a i) r)\n\ngoal (4 subgoals):\n 1. \\<And>x.\n       max_input (L x) < Some a \\<Longrightarrow>\n       aval (L x) (join_ir i r) = aval (L x) (join_ir (take a i) r)\n 2. \\<And>x1a x2a.\n       \\<lbrakk>max_input x1a < Some a \\<Longrightarrow>\n                aval x1a (join_ir i r) = aval x1a (join_ir (take a i) r);\n        max_input x2a < Some a \\<Longrightarrow>\n        aval x2a (join_ir i r) = aval x2a (join_ir (take a i) r);\n        max_input (Plus x1a x2a) < Some a\\<rbrakk>\n       \\<Longrightarrow> aval (Plus x1a x2a) (join_ir i r) =\n                         aval (Plus x1a x2a) (join_ir (take a i) r)\n 3. \\<And>x1a x2a.\n       \\<lbrakk>max_input x1a < Some a \\<Longrightarrow>\n                aval x1a (join_ir i r) = aval x1a (join_ir (take a i) r);\n        max_input x2a < Some a \\<Longrightarrow>\n        aval x2a (join_ir i r) = aval x2a (join_ir (take a i) r);\n        max_input (Minus x1a x2a) < Some a\\<rbrakk>\n       \\<Longrightarrow> aval (Minus x1a x2a) (join_ir i r) =\n                         aval (Minus x1a x2a) (join_ir (take a i) r)\n 4. \\<And>x1a x2a.\n       \\<lbrakk>max_input x1a < Some a \\<Longrightarrow>\n                aval x1a (join_ir i r) = aval x1a (join_ir (take a i) r);\n        max_input x2a < Some a \\<Longrightarrow>\n        aval x2a (join_ir i r) = aval x2a (join_ir (take a i) r);\n        max_input (Times x1a x2a) < Some a\\<rbrakk>\n       \\<Longrightarrow> aval (Times x1a x2a) (join_ir i r) =\n                         aval (Times x1a x2a) (join_ir (take a i) r)", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x.\n       max_input (L x) < Some a \\<Longrightarrow>\n       aval (L x) (join_ir i r) = aval (L x) (join_ir (take a i) r)\n 2. \\<And>x1a x2a.\n       \\<lbrakk>max_input x1a < Some a \\<Longrightarrow>\n                aval x1a (join_ir i r) = aval x1a (join_ir (take a i) r);\n        max_input x2a < Some a \\<Longrightarrow>\n        aval x2a (join_ir i r) = aval x2a (join_ir (take a i) r);\n        max_input (Plus x1a x2a) < Some a\\<rbrakk>\n       \\<Longrightarrow> aval (Plus x1a x2a) (join_ir i r) =\n                         aval (Plus x1a x2a) (join_ir (take a i) r)\n 3. \\<And>x1a x2a.\n       \\<lbrakk>max_input x1a < Some a \\<Longrightarrow>\n                aval x1a (join_ir i r) = aval x1a (join_ir (take a i) r);\n        max_input x2a < Some a \\<Longrightarrow>\n        aval x2a (join_ir i r) = aval x2a (join_ir (take a i) r);\n        max_input (Minus x1a x2a) < Some a\\<rbrakk>\n       \\<Longrightarrow> aval (Minus x1a x2a) (join_ir i r) =\n                         aval (Minus x1a x2a) (join_ir (take a i) r)\n 4. \\<And>x1a x2a.\n       \\<lbrakk>max_input x1a < Some a \\<Longrightarrow>\n                aval x1a (join_ir i r) = aval x1a (join_ir (take a i) r);\n        max_input x2a < Some a \\<Longrightarrow>\n        aval x2a (join_ir i r) = aval x2a (join_ir (take a i) r);\n        max_input (Times x1a x2a) < Some a\\<rbrakk>\n       \\<Longrightarrow> aval (Times x1a x2a) (join_ir i r) =\n                         aval (Times x1a x2a) (join_ir (take a i) r)", "case (Plus x1a x2a)"], ["proof (state)\nthis:\n  max_input x1a < Some a \\<Longrightarrow>\n  aval x1a (join_ir i r) = aval x1a (join_ir (take a i) r)\n  max_input x2a < Some a \\<Longrightarrow>\n  aval x2a (join_ir i r) = aval x2a (join_ir (take a i) r)\n  max_input (Plus x1a x2a) < Some a\n\ngoal (4 subgoals):\n 1. \\<And>x.\n       max_input (L x) < Some a \\<Longrightarrow>\n       aval (L x) (join_ir i r) = aval (L x) (join_ir (take a i) r)\n 2. \\<And>x1a x2a.\n       \\<lbrakk>max_input x1a < Some a \\<Longrightarrow>\n                aval x1a (join_ir i r) = aval x1a (join_ir (take a i) r);\n        max_input x2a < Some a \\<Longrightarrow>\n        aval x2a (join_ir i r) = aval x2a (join_ir (take a i) r);\n        max_input (Plus x1a x2a) < Some a\\<rbrakk>\n       \\<Longrightarrow> aval (Plus x1a x2a) (join_ir i r) =\n                         aval (Plus x1a x2a) (join_ir (take a i) r)\n 3. \\<And>x1a x2a.\n       \\<lbrakk>max_input x1a < Some a \\<Longrightarrow>\n                aval x1a (join_ir i r) = aval x1a (join_ir (take a i) r);\n        max_input x2a < Some a \\<Longrightarrow>\n        aval x2a (join_ir i r) = aval x2a (join_ir (take a i) r);\n        max_input (Minus x1a x2a) < Some a\\<rbrakk>\n       \\<Longrightarrow> aval (Minus x1a x2a) (join_ir i r) =\n                         aval (Minus x1a x2a) (join_ir (take a i) r)\n 4. \\<And>x1a x2a.\n       \\<lbrakk>max_input x1a < Some a \\<Longrightarrow>\n                aval x1a (join_ir i r) = aval x1a (join_ir (take a i) r);\n        max_input x2a < Some a \\<Longrightarrow>\n        aval x2a (join_ir i r) = aval x2a (join_ir (take a i) r);\n        max_input (Times x1a x2a) < Some a\\<rbrakk>\n       \\<Longrightarrow> aval (Times x1a x2a) (join_ir i r) =\n                         aval (Times x1a x2a) (join_ir (take a i) r)", "then"], ["proof (chain)\npicking this:\n  max_input x1a < Some a \\<Longrightarrow>\n  aval x1a (join_ir i r) = aval x1a (join_ir (take a i) r)\n  max_input x2a < Some a \\<Longrightarrow>\n  aval x2a (join_ir i r) = aval x2a (join_ir (take a i) r)\n  max_input (Plus x1a x2a) < Some a", "show ?case"], ["proof (prove)\nusing this:\n  max_input x1a < Some a \\<Longrightarrow>\n  aval x1a (join_ir i r) = aval x1a (join_ir (take a i) r)\n  max_input x2a < Some a \\<Longrightarrow>\n  aval x2a (join_ir i r) = aval x2a (join_ir (take a i) r)\n  max_input (Plus x1a x2a) < Some a\n\ngoal (1 subgoal):\n 1. aval (Plus x1a x2a) (join_ir i r) =\n    aval (Plus x1a x2a) (join_ir (take a i) r)", "by (simp add: max_input_Plus)"], ["proof (state)\nthis:\n  aval (Plus x1a x2a) (join_ir i r) =\n  aval (Plus x1a x2a) (join_ir (take a i) r)\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       max_input (L x) < Some a \\<Longrightarrow>\n       aval (L x) (join_ir i r) = aval (L x) (join_ir (take a i) r)\n 2. \\<And>x1a x2a.\n       \\<lbrakk>max_input x1a < Some a \\<Longrightarrow>\n                aval x1a (join_ir i r) = aval x1a (join_ir (take a i) r);\n        max_input x2a < Some a \\<Longrightarrow>\n        aval x2a (join_ir i r) = aval x2a (join_ir (take a i) r);\n        max_input (Minus x1a x2a) < Some a\\<rbrakk>\n       \\<Longrightarrow> aval (Minus x1a x2a) (join_ir i r) =\n                         aval (Minus x1a x2a) (join_ir (take a i) r)\n 3. \\<And>x1a x2a.\n       \\<lbrakk>max_input x1a < Some a \\<Longrightarrow>\n                aval x1a (join_ir i r) = aval x1a (join_ir (take a i) r);\n        max_input x2a < Some a \\<Longrightarrow>\n        aval x2a (join_ir i r) = aval x2a (join_ir (take a i) r);\n        max_input (Times x1a x2a) < Some a\\<rbrakk>\n       \\<Longrightarrow> aval (Times x1a x2a) (join_ir i r) =\n                         aval (Times x1a x2a) (join_ir (take a i) r)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x.\n       max_input (L x) < Some a \\<Longrightarrow>\n       aval (L x) (join_ir i r) = aval (L x) (join_ir (take a i) r)\n 2. \\<And>x1a x2a.\n       \\<lbrakk>max_input x1a < Some a \\<Longrightarrow>\n                aval x1a (join_ir i r) = aval x1a (join_ir (take a i) r);\n        max_input x2a < Some a \\<Longrightarrow>\n        aval x2a (join_ir i r) = aval x2a (join_ir (take a i) r);\n        max_input (Minus x1a x2a) < Some a\\<rbrakk>\n       \\<Longrightarrow> aval (Minus x1a x2a) (join_ir i r) =\n                         aval (Minus x1a x2a) (join_ir (take a i) r)\n 3. \\<And>x1a x2a.\n       \\<lbrakk>max_input x1a < Some a \\<Longrightarrow>\n                aval x1a (join_ir i r) = aval x1a (join_ir (take a i) r);\n        max_input x2a < Some a \\<Longrightarrow>\n        aval x2a (join_ir i r) = aval x2a (join_ir (take a i) r);\n        max_input (Times x1a x2a) < Some a\\<rbrakk>\n       \\<Longrightarrow> aval (Times x1a x2a) (join_ir i r) =\n                         aval (Times x1a x2a) (join_ir (take a i) r)", "case (Minus x1a x2a)"], ["proof (state)\nthis:\n  max_input x1a < Some a \\<Longrightarrow>\n  aval x1a (join_ir i r) = aval x1a (join_ir (take a i) r)\n  max_input x2a < Some a \\<Longrightarrow>\n  aval x2a (join_ir i r) = aval x2a (join_ir (take a i) r)\n  max_input (Minus x1a x2a) < Some a\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       max_input (L x) < Some a \\<Longrightarrow>\n       aval (L x) (join_ir i r) = aval (L x) (join_ir (take a i) r)\n 2. \\<And>x1a x2a.\n       \\<lbrakk>max_input x1a < Some a \\<Longrightarrow>\n                aval x1a (join_ir i r) = aval x1a (join_ir (take a i) r);\n        max_input x2a < Some a \\<Longrightarrow>\n        aval x2a (join_ir i r) = aval x2a (join_ir (take a i) r);\n        max_input (Minus x1a x2a) < Some a\\<rbrakk>\n       \\<Longrightarrow> aval (Minus x1a x2a) (join_ir i r) =\n                         aval (Minus x1a x2a) (join_ir (take a i) r)\n 3. \\<And>x1a x2a.\n       \\<lbrakk>max_input x1a < Some a \\<Longrightarrow>\n                aval x1a (join_ir i r) = aval x1a (join_ir (take a i) r);\n        max_input x2a < Some a \\<Longrightarrow>\n        aval x2a (join_ir i r) = aval x2a (join_ir (take a i) r);\n        max_input (Times x1a x2a) < Some a\\<rbrakk>\n       \\<Longrightarrow> aval (Times x1a x2a) (join_ir i r) =\n                         aval (Times x1a x2a) (join_ir (take a i) r)", "then"], ["proof (chain)\npicking this:\n  max_input x1a < Some a \\<Longrightarrow>\n  aval x1a (join_ir i r) = aval x1a (join_ir (take a i) r)\n  max_input x2a < Some a \\<Longrightarrow>\n  aval x2a (join_ir i r) = aval x2a (join_ir (take a i) r)\n  max_input (Minus x1a x2a) < Some a", "show ?case"], ["proof (prove)\nusing this:\n  max_input x1a < Some a \\<Longrightarrow>\n  aval x1a (join_ir i r) = aval x1a (join_ir (take a i) r)\n  max_input x2a < Some a \\<Longrightarrow>\n  aval x2a (join_ir i r) = aval x2a (join_ir (take a i) r)\n  max_input (Minus x1a x2a) < Some a\n\ngoal (1 subgoal):\n 1. aval (Minus x1a x2a) (join_ir i r) =\n    aval (Minus x1a x2a) (join_ir (take a i) r)", "by (simp add: max_input_Minus)"], ["proof (state)\nthis:\n  aval (Minus x1a x2a) (join_ir i r) =\n  aval (Minus x1a x2a) (join_ir (take a i) r)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       max_input (L x) < Some a \\<Longrightarrow>\n       aval (L x) (join_ir i r) = aval (L x) (join_ir (take a i) r)\n 2. \\<And>x1a x2a.\n       \\<lbrakk>max_input x1a < Some a \\<Longrightarrow>\n                aval x1a (join_ir i r) = aval x1a (join_ir (take a i) r);\n        max_input x2a < Some a \\<Longrightarrow>\n        aval x2a (join_ir i r) = aval x2a (join_ir (take a i) r);\n        max_input (Times x1a x2a) < Some a\\<rbrakk>\n       \\<Longrightarrow> aval (Times x1a x2a) (join_ir i r) =\n                         aval (Times x1a x2a) (join_ir (take a i) r)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       max_input (L x) < Some a \\<Longrightarrow>\n       aval (L x) (join_ir i r) = aval (L x) (join_ir (take a i) r)\n 2. \\<And>x1a x2a.\n       \\<lbrakk>max_input x1a < Some a \\<Longrightarrow>\n                aval x1a (join_ir i r) = aval x1a (join_ir (take a i) r);\n        max_input x2a < Some a \\<Longrightarrow>\n        aval x2a (join_ir i r) = aval x2a (join_ir (take a i) r);\n        max_input (Times x1a x2a) < Some a\\<rbrakk>\n       \\<Longrightarrow> aval (Times x1a x2a) (join_ir i r) =\n                         aval (Times x1a x2a) (join_ir (take a i) r)", "case (Times x1a x2a)"], ["proof (state)\nthis:\n  max_input x1a < Some a \\<Longrightarrow>\n  aval x1a (join_ir i r) = aval x1a (join_ir (take a i) r)\n  max_input x2a < Some a \\<Longrightarrow>\n  aval x2a (join_ir i r) = aval x2a (join_ir (take a i) r)\n  max_input (Times x1a x2a) < Some a\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       max_input (L x) < Some a \\<Longrightarrow>\n       aval (L x) (join_ir i r) = aval (L x) (join_ir (take a i) r)\n 2. \\<And>x1a x2a.\n       \\<lbrakk>max_input x1a < Some a \\<Longrightarrow>\n                aval x1a (join_ir i r) = aval x1a (join_ir (take a i) r);\n        max_input x2a < Some a \\<Longrightarrow>\n        aval x2a (join_ir i r) = aval x2a (join_ir (take a i) r);\n        max_input (Times x1a x2a) < Some a\\<rbrakk>\n       \\<Longrightarrow> aval (Times x1a x2a) (join_ir i r) =\n                         aval (Times x1a x2a) (join_ir (take a i) r)", "then"], ["proof (chain)\npicking this:\n  max_input x1a < Some a \\<Longrightarrow>\n  aval x1a (join_ir i r) = aval x1a (join_ir (take a i) r)\n  max_input x2a < Some a \\<Longrightarrow>\n  aval x2a (join_ir i r) = aval x2a (join_ir (take a i) r)\n  max_input (Times x1a x2a) < Some a", "show ?case"], ["proof (prove)\nusing this:\n  max_input x1a < Some a \\<Longrightarrow>\n  aval x1a (join_ir i r) = aval x1a (join_ir (take a i) r)\n  max_input x2a < Some a \\<Longrightarrow>\n  aval x2a (join_ir i r) = aval x2a (join_ir (take a i) r)\n  max_input (Times x1a x2a) < Some a\n\ngoal (1 subgoal):\n 1. aval (Times x1a x2a) (join_ir i r) =\n    aval (Times x1a x2a) (join_ir (take a i) r)", "by (simp add: max_input_Times)"], ["proof (state)\nthis:\n  aval (Times x1a x2a) (join_ir i r) =\n  aval (Times x1a x2a) (join_ir (take a i) r)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       max_input (L x) < Some a \\<Longrightarrow>\n       aval (L x) (join_ir i r) = aval (L x) (join_ir (take a i) r)", "qed auto"], ["", "lemma aval_no_reg_swap_regs: \"max_input x < Some a \\<Longrightarrow>\n   max_reg x = None \\<Longrightarrow>\n   aval x (join_ir i ra) = aval x (join_ir (take a i) r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>max_input x < Some a; max_reg x = None\\<rbrakk>\n    \\<Longrightarrow> aval x (join_ir i ra) = aval x (join_ir (take a i) r)", "proof(induct x)"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>max_input (L x) < Some a; max_reg (L x) = None\\<rbrakk>\n       \\<Longrightarrow> aval (L x) (join_ir i ra) =\n                         aval (L x) (join_ir (take a i) r)\n 2. \\<And>x.\n       \\<lbrakk>max_input (V x) < Some a; max_reg (V x) = None\\<rbrakk>\n       \\<Longrightarrow> aval (V x) (join_ir i ra) =\n                         aval (V x) (join_ir (take a i) r)\n 3. \\<And>x1 x2.\n       \\<lbrakk>\\<lbrakk>max_input x1 < Some a; max_reg x1 = None\\<rbrakk>\n                \\<Longrightarrow> aval x1 (join_ir i ra) =\n                                  aval x1 (join_ir (take a i) r);\n        \\<lbrakk>max_input x2 < Some a; max_reg x2 = None\\<rbrakk>\n        \\<Longrightarrow> aval x2 (join_ir i ra) =\n                          aval x2 (join_ir (take a i) r);\n        max_input (Plus x1 x2) < Some a;\n        max_reg (Plus x1 x2) = None\\<rbrakk>\n       \\<Longrightarrow> aval (Plus x1 x2) (join_ir i ra) =\n                         aval (Plus x1 x2) (join_ir (take a i) r)\n 4. \\<And>x1 x2.\n       \\<lbrakk>\\<lbrakk>max_input x1 < Some a; max_reg x1 = None\\<rbrakk>\n                \\<Longrightarrow> aval x1 (join_ir i ra) =\n                                  aval x1 (join_ir (take a i) r);\n        \\<lbrakk>max_input x2 < Some a; max_reg x2 = None\\<rbrakk>\n        \\<Longrightarrow> aval x2 (join_ir i ra) =\n                          aval x2 (join_ir (take a i) r);\n        max_input (Minus x1 x2) < Some a;\n        max_reg (Minus x1 x2) = None\\<rbrakk>\n       \\<Longrightarrow> aval (Minus x1 x2) (join_ir i ra) =\n                         aval (Minus x1 x2) (join_ir (take a i) r)\n 5. \\<And>x1 x2.\n       \\<lbrakk>\\<lbrakk>max_input x1 < Some a; max_reg x1 = None\\<rbrakk>\n                \\<Longrightarrow> aval x1 (join_ir i ra) =\n                                  aval x1 (join_ir (take a i) r);\n        \\<lbrakk>max_input x2 < Some a; max_reg x2 = None\\<rbrakk>\n        \\<Longrightarrow> aval x2 (join_ir i ra) =\n                          aval x2 (join_ir (take a i) r);\n        max_input (Times x1 x2) < Some a;\n        max_reg (Times x1 x2) = None\\<rbrakk>\n       \\<Longrightarrow> aval (Times x1 x2) (join_ir i ra) =\n                         aval (Times x1 x2) (join_ir (take a i) r)", "case (V x)"], ["proof (state)\nthis:\n  max_input (V x) < Some a\n  max_reg (V x) = None\n\ngoal (5 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>max_input (L x) < Some a; max_reg (L x) = None\\<rbrakk>\n       \\<Longrightarrow> aval (L x) (join_ir i ra) =\n                         aval (L x) (join_ir (take a i) r)\n 2. \\<And>x.\n       \\<lbrakk>max_input (V x) < Some a; max_reg (V x) = None\\<rbrakk>\n       \\<Longrightarrow> aval (V x) (join_ir i ra) =\n                         aval (V x) (join_ir (take a i) r)\n 3. \\<And>x1 x2.\n       \\<lbrakk>\\<lbrakk>max_input x1 < Some a; max_reg x1 = None\\<rbrakk>\n                \\<Longrightarrow> aval x1 (join_ir i ra) =\n                                  aval x1 (join_ir (take a i) r);\n        \\<lbrakk>max_input x2 < Some a; max_reg x2 = None\\<rbrakk>\n        \\<Longrightarrow> aval x2 (join_ir i ra) =\n                          aval x2 (join_ir (take a i) r);\n        max_input (Plus x1 x2) < Some a;\n        max_reg (Plus x1 x2) = None\\<rbrakk>\n       \\<Longrightarrow> aval (Plus x1 x2) (join_ir i ra) =\n                         aval (Plus x1 x2) (join_ir (take a i) r)\n 4. \\<And>x1 x2.\n       \\<lbrakk>\\<lbrakk>max_input x1 < Some a; max_reg x1 = None\\<rbrakk>\n                \\<Longrightarrow> aval x1 (join_ir i ra) =\n                                  aval x1 (join_ir (take a i) r);\n        \\<lbrakk>max_input x2 < Some a; max_reg x2 = None\\<rbrakk>\n        \\<Longrightarrow> aval x2 (join_ir i ra) =\n                          aval x2 (join_ir (take a i) r);\n        max_input (Minus x1 x2) < Some a;\n        max_reg (Minus x1 x2) = None\\<rbrakk>\n       \\<Longrightarrow> aval (Minus x1 x2) (join_ir i ra) =\n                         aval (Minus x1 x2) (join_ir (take a i) r)\n 5. \\<And>x1 x2.\n       \\<lbrakk>\\<lbrakk>max_input x1 < Some a; max_reg x1 = None\\<rbrakk>\n                \\<Longrightarrow> aval x1 (join_ir i ra) =\n                                  aval x1 (join_ir (take a i) r);\n        \\<lbrakk>max_input x2 < Some a; max_reg x2 = None\\<rbrakk>\n        \\<Longrightarrow> aval x2 (join_ir i ra) =\n                          aval x2 (join_ir (take a i) r);\n        max_input (Times x1 x2) < Some a;\n        max_reg (Times x1 x2) = None\\<rbrakk>\n       \\<Longrightarrow> aval (Times x1 x2) (join_ir i ra) =\n                         aval (Times x1 x2) (join_ir (take a i) r)", "then"], ["proof (chain)\npicking this:\n  max_input (V x) < Some a\n  max_reg (V x) = None", "show ?case"], ["proof (prove)\nusing this:\n  max_input (V x) < Some a\n  max_reg (V x) = None\n\ngoal (1 subgoal):\n 1. aval (V x) (join_ir i ra) = aval (V x) (join_ir (take a i) r)", "apply (cases x)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>max_input (V x) < Some a; max_reg (V x) = None;\n        x = I x1\\<rbrakk>\n       \\<Longrightarrow> aval (V x) (join_ir i ra) =\n                         aval (V x) (join_ir (take a i) r)\n 2. \\<And>x2.\n       \\<lbrakk>max_input (V x) < Some a; max_reg (V x) = None;\n        x = R x2\\<rbrakk>\n       \\<Longrightarrow> aval (V x) (join_ir i ra) =\n                         aval (V x) (join_ir (take a i) r)", "apply (metis aval_take enumerate_regs.simps(3) enumerate_regs_empty_reg_unconstrained input_unconstrained_aval_register_swap)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<lbrakk>max_input (V x) < Some a; max_reg (V x) = None;\n        x = R x2\\<rbrakk>\n       \\<Longrightarrow> aval (V x) (join_ir i ra) =\n                         aval (V x) (join_ir (take a i) r)", "by (simp add: max_reg_def)"], ["proof (state)\nthis:\n  aval (V x) (join_ir i ra) = aval (V x) (join_ir (take a i) r)\n\ngoal (4 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>max_input (L x) < Some a; max_reg (L x) = None\\<rbrakk>\n       \\<Longrightarrow> aval (L x) (join_ir i ra) =\n                         aval (L x) (join_ir (take a i) r)\n 2. \\<And>x1 x2.\n       \\<lbrakk>\\<lbrakk>max_input x1 < Some a; max_reg x1 = None\\<rbrakk>\n                \\<Longrightarrow> aval x1 (join_ir i ra) =\n                                  aval x1 (join_ir (take a i) r);\n        \\<lbrakk>max_input x2 < Some a; max_reg x2 = None\\<rbrakk>\n        \\<Longrightarrow> aval x2 (join_ir i ra) =\n                          aval x2 (join_ir (take a i) r);\n        max_input (Plus x1 x2) < Some a;\n        max_reg (Plus x1 x2) = None\\<rbrakk>\n       \\<Longrightarrow> aval (Plus x1 x2) (join_ir i ra) =\n                         aval (Plus x1 x2) (join_ir (take a i) r)\n 3. \\<And>x1 x2.\n       \\<lbrakk>\\<lbrakk>max_input x1 < Some a; max_reg x1 = None\\<rbrakk>\n                \\<Longrightarrow> aval x1 (join_ir i ra) =\n                                  aval x1 (join_ir (take a i) r);\n        \\<lbrakk>max_input x2 < Some a; max_reg x2 = None\\<rbrakk>\n        \\<Longrightarrow> aval x2 (join_ir i ra) =\n                          aval x2 (join_ir (take a i) r);\n        max_input (Minus x1 x2) < Some a;\n        max_reg (Minus x1 x2) = None\\<rbrakk>\n       \\<Longrightarrow> aval (Minus x1 x2) (join_ir i ra) =\n                         aval (Minus x1 x2) (join_ir (take a i) r)\n 4. \\<And>x1 x2.\n       \\<lbrakk>\\<lbrakk>max_input x1 < Some a; max_reg x1 = None\\<rbrakk>\n                \\<Longrightarrow> aval x1 (join_ir i ra) =\n                                  aval x1 (join_ir (take a i) r);\n        \\<lbrakk>max_input x2 < Some a; max_reg x2 = None\\<rbrakk>\n        \\<Longrightarrow> aval x2 (join_ir i ra) =\n                          aval x2 (join_ir (take a i) r);\n        max_input (Times x1 x2) < Some a;\n        max_reg (Times x1 x2) = None\\<rbrakk>\n       \\<Longrightarrow> aval (Times x1 x2) (join_ir i ra) =\n                         aval (Times x1 x2) (join_ir (take a i) r)", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>max_input (L x) < Some a; max_reg (L x) = None\\<rbrakk>\n       \\<Longrightarrow> aval (L x) (join_ir i ra) =\n                         aval (L x) (join_ir (take a i) r)\n 2. \\<And>x1 x2.\n       \\<lbrakk>\\<lbrakk>max_input x1 < Some a; max_reg x1 = None\\<rbrakk>\n                \\<Longrightarrow> aval x1 (join_ir i ra) =\n                                  aval x1 (join_ir (take a i) r);\n        \\<lbrakk>max_input x2 < Some a; max_reg x2 = None\\<rbrakk>\n        \\<Longrightarrow> aval x2 (join_ir i ra) =\n                          aval x2 (join_ir (take a i) r);\n        max_input (Plus x1 x2) < Some a;\n        max_reg (Plus x1 x2) = None\\<rbrakk>\n       \\<Longrightarrow> aval (Plus x1 x2) (join_ir i ra) =\n                         aval (Plus x1 x2) (join_ir (take a i) r)\n 3. \\<And>x1 x2.\n       \\<lbrakk>\\<lbrakk>max_input x1 < Some a; max_reg x1 = None\\<rbrakk>\n                \\<Longrightarrow> aval x1 (join_ir i ra) =\n                                  aval x1 (join_ir (take a i) r);\n        \\<lbrakk>max_input x2 < Some a; max_reg x2 = None\\<rbrakk>\n        \\<Longrightarrow> aval x2 (join_ir i ra) =\n                          aval x2 (join_ir (take a i) r);\n        max_input (Minus x1 x2) < Some a;\n        max_reg (Minus x1 x2) = None\\<rbrakk>\n       \\<Longrightarrow> aval (Minus x1 x2) (join_ir i ra) =\n                         aval (Minus x1 x2) (join_ir (take a i) r)\n 4. \\<And>x1 x2.\n       \\<lbrakk>\\<lbrakk>max_input x1 < Some a; max_reg x1 = None\\<rbrakk>\n                \\<Longrightarrow> aval x1 (join_ir i ra) =\n                                  aval x1 (join_ir (take a i) r);\n        \\<lbrakk>max_input x2 < Some a; max_reg x2 = None\\<rbrakk>\n        \\<Longrightarrow> aval x2 (join_ir i ra) =\n                          aval x2 (join_ir (take a i) r);\n        max_input (Times x1 x2) < Some a;\n        max_reg (Times x1 x2) = None\\<rbrakk>\n       \\<Longrightarrow> aval (Times x1 x2) (join_ir i ra) =\n                         aval (Times x1 x2) (join_ir (take a i) r)", "case (Plus x1 x2)"], ["proof (state)\nthis:\n  \\<lbrakk>max_input x1 < Some a; max_reg x1 = None\\<rbrakk>\n  \\<Longrightarrow> aval x1 (join_ir i ra) = aval x1 (join_ir (take a i) r)\n  \\<lbrakk>max_input x2 < Some a; max_reg x2 = None\\<rbrakk>\n  \\<Longrightarrow> aval x2 (join_ir i ra) = aval x2 (join_ir (take a i) r)\n  max_input (Plus x1 x2) < Some a\n  max_reg (Plus x1 x2) = None\n\ngoal (4 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>max_input (L x) < Some a; max_reg (L x) = None\\<rbrakk>\n       \\<Longrightarrow> aval (L x) (join_ir i ra) =\n                         aval (L x) (join_ir (take a i) r)\n 2. \\<And>x1 x2.\n       \\<lbrakk>\\<lbrakk>max_input x1 < Some a; max_reg x1 = None\\<rbrakk>\n                \\<Longrightarrow> aval x1 (join_ir i ra) =\n                                  aval x1 (join_ir (take a i) r);\n        \\<lbrakk>max_input x2 < Some a; max_reg x2 = None\\<rbrakk>\n        \\<Longrightarrow> aval x2 (join_ir i ra) =\n                          aval x2 (join_ir (take a i) r);\n        max_input (Plus x1 x2) < Some a;\n        max_reg (Plus x1 x2) = None\\<rbrakk>\n       \\<Longrightarrow> aval (Plus x1 x2) (join_ir i ra) =\n                         aval (Plus x1 x2) (join_ir (take a i) r)\n 3. \\<And>x1 x2.\n       \\<lbrakk>\\<lbrakk>max_input x1 < Some a; max_reg x1 = None\\<rbrakk>\n                \\<Longrightarrow> aval x1 (join_ir i ra) =\n                                  aval x1 (join_ir (take a i) r);\n        \\<lbrakk>max_input x2 < Some a; max_reg x2 = None\\<rbrakk>\n        \\<Longrightarrow> aval x2 (join_ir i ra) =\n                          aval x2 (join_ir (take a i) r);\n        max_input (Minus x1 x2) < Some a;\n        max_reg (Minus x1 x2) = None\\<rbrakk>\n       \\<Longrightarrow> aval (Minus x1 x2) (join_ir i ra) =\n                         aval (Minus x1 x2) (join_ir (take a i) r)\n 4. \\<And>x1 x2.\n       \\<lbrakk>\\<lbrakk>max_input x1 < Some a; max_reg x1 = None\\<rbrakk>\n                \\<Longrightarrow> aval x1 (join_ir i ra) =\n                                  aval x1 (join_ir (take a i) r);\n        \\<lbrakk>max_input x2 < Some a; max_reg x2 = None\\<rbrakk>\n        \\<Longrightarrow> aval x2 (join_ir i ra) =\n                          aval x2 (join_ir (take a i) r);\n        max_input (Times x1 x2) < Some a;\n        max_reg (Times x1 x2) = None\\<rbrakk>\n       \\<Longrightarrow> aval (Times x1 x2) (join_ir i ra) =\n                         aval (Times x1 x2) (join_ir (take a i) r)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>max_input x1 < Some a; max_reg x1 = None\\<rbrakk>\n  \\<Longrightarrow> aval x1 (join_ir i ra) = aval x1 (join_ir (take a i) r)\n  \\<lbrakk>max_input x2 < Some a; max_reg x2 = None\\<rbrakk>\n  \\<Longrightarrow> aval x2 (join_ir i ra) = aval x2 (join_ir (take a i) r)\n  max_input (Plus x1 x2) < Some a\n  max_reg (Plus x1 x2) = None", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>max_input x1 < Some a; max_reg x1 = None\\<rbrakk>\n  \\<Longrightarrow> aval x1 (join_ir i ra) = aval x1 (join_ir (take a i) r)\n  \\<lbrakk>max_input x2 < Some a; max_reg x2 = None\\<rbrakk>\n  \\<Longrightarrow> aval x2 (join_ir i ra) = aval x2 (join_ir (take a i) r)\n  max_input (Plus x1 x2) < Some a\n  max_reg (Plus x1 x2) = None\n\ngoal (1 subgoal):\n 1. aval (Plus x1 x2) (join_ir i ra) =\n    aval (Plus x1 x2) (join_ir (take a i) r)", "by (metis aval_take no_reg_aval_swap_regs)"], ["proof (state)\nthis:\n  aval (Plus x1 x2) (join_ir i ra) =\n  aval (Plus x1 x2) (join_ir (take a i) r)\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>max_input (L x) < Some a; max_reg (L x) = None\\<rbrakk>\n       \\<Longrightarrow> aval (L x) (join_ir i ra) =\n                         aval (L x) (join_ir (take a i) r)\n 2. \\<And>x1 x2.\n       \\<lbrakk>\\<lbrakk>max_input x1 < Some a; max_reg x1 = None\\<rbrakk>\n                \\<Longrightarrow> aval x1 (join_ir i ra) =\n                                  aval x1 (join_ir (take a i) r);\n        \\<lbrakk>max_input x2 < Some a; max_reg x2 = None\\<rbrakk>\n        \\<Longrightarrow> aval x2 (join_ir i ra) =\n                          aval x2 (join_ir (take a i) r);\n        max_input (Minus x1 x2) < Some a;\n        max_reg (Minus x1 x2) = None\\<rbrakk>\n       \\<Longrightarrow> aval (Minus x1 x2) (join_ir i ra) =\n                         aval (Minus x1 x2) (join_ir (take a i) r)\n 3. \\<And>x1 x2.\n       \\<lbrakk>\\<lbrakk>max_input x1 < Some a; max_reg x1 = None\\<rbrakk>\n                \\<Longrightarrow> aval x1 (join_ir i ra) =\n                                  aval x1 (join_ir (take a i) r);\n        \\<lbrakk>max_input x2 < Some a; max_reg x2 = None\\<rbrakk>\n        \\<Longrightarrow> aval x2 (join_ir i ra) =\n                          aval x2 (join_ir (take a i) r);\n        max_input (Times x1 x2) < Some a;\n        max_reg (Times x1 x2) = None\\<rbrakk>\n       \\<Longrightarrow> aval (Times x1 x2) (join_ir i ra) =\n                         aval (Times x1 x2) (join_ir (take a i) r)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>max_input (L x) < Some a; max_reg (L x) = None\\<rbrakk>\n       \\<Longrightarrow> aval (L x) (join_ir i ra) =\n                         aval (L x) (join_ir (take a i) r)\n 2. \\<And>x1 x2.\n       \\<lbrakk>\\<lbrakk>max_input x1 < Some a; max_reg x1 = None\\<rbrakk>\n                \\<Longrightarrow> aval x1 (join_ir i ra) =\n                                  aval x1 (join_ir (take a i) r);\n        \\<lbrakk>max_input x2 < Some a; max_reg x2 = None\\<rbrakk>\n        \\<Longrightarrow> aval x2 (join_ir i ra) =\n                          aval x2 (join_ir (take a i) r);\n        max_input (Minus x1 x2) < Some a;\n        max_reg (Minus x1 x2) = None\\<rbrakk>\n       \\<Longrightarrow> aval (Minus x1 x2) (join_ir i ra) =\n                         aval (Minus x1 x2) (join_ir (take a i) r)\n 3. \\<And>x1 x2.\n       \\<lbrakk>\\<lbrakk>max_input x1 < Some a; max_reg x1 = None\\<rbrakk>\n                \\<Longrightarrow> aval x1 (join_ir i ra) =\n                                  aval x1 (join_ir (take a i) r);\n        \\<lbrakk>max_input x2 < Some a; max_reg x2 = None\\<rbrakk>\n        \\<Longrightarrow> aval x2 (join_ir i ra) =\n                          aval x2 (join_ir (take a i) r);\n        max_input (Times x1 x2) < Some a;\n        max_reg (Times x1 x2) = None\\<rbrakk>\n       \\<Longrightarrow> aval (Times x1 x2) (join_ir i ra) =\n                         aval (Times x1 x2) (join_ir (take a i) r)", "case (Minus x1 x2)"], ["proof (state)\nthis:\n  \\<lbrakk>max_input x1 < Some a; max_reg x1 = None\\<rbrakk>\n  \\<Longrightarrow> aval x1 (join_ir i ra) = aval x1 (join_ir (take a i) r)\n  \\<lbrakk>max_input x2 < Some a; max_reg x2 = None\\<rbrakk>\n  \\<Longrightarrow> aval x2 (join_ir i ra) = aval x2 (join_ir (take a i) r)\n  max_input (Minus x1 x2) < Some a\n  max_reg (Minus x1 x2) = None\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>max_input (L x) < Some a; max_reg (L x) = None\\<rbrakk>\n       \\<Longrightarrow> aval (L x) (join_ir i ra) =\n                         aval (L x) (join_ir (take a i) r)\n 2. \\<And>x1 x2.\n       \\<lbrakk>\\<lbrakk>max_input x1 < Some a; max_reg x1 = None\\<rbrakk>\n                \\<Longrightarrow> aval x1 (join_ir i ra) =\n                                  aval x1 (join_ir (take a i) r);\n        \\<lbrakk>max_input x2 < Some a; max_reg x2 = None\\<rbrakk>\n        \\<Longrightarrow> aval x2 (join_ir i ra) =\n                          aval x2 (join_ir (take a i) r);\n        max_input (Minus x1 x2) < Some a;\n        max_reg (Minus x1 x2) = None\\<rbrakk>\n       \\<Longrightarrow> aval (Minus x1 x2) (join_ir i ra) =\n                         aval (Minus x1 x2) (join_ir (take a i) r)\n 3. \\<And>x1 x2.\n       \\<lbrakk>\\<lbrakk>max_input x1 < Some a; max_reg x1 = None\\<rbrakk>\n                \\<Longrightarrow> aval x1 (join_ir i ra) =\n                                  aval x1 (join_ir (take a i) r);\n        \\<lbrakk>max_input x2 < Some a; max_reg x2 = None\\<rbrakk>\n        \\<Longrightarrow> aval x2 (join_ir i ra) =\n                          aval x2 (join_ir (take a i) r);\n        max_input (Times x1 x2) < Some a;\n        max_reg (Times x1 x2) = None\\<rbrakk>\n       \\<Longrightarrow> aval (Times x1 x2) (join_ir i ra) =\n                         aval (Times x1 x2) (join_ir (take a i) r)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>max_input x1 < Some a; max_reg x1 = None\\<rbrakk>\n  \\<Longrightarrow> aval x1 (join_ir i ra) = aval x1 (join_ir (take a i) r)\n  \\<lbrakk>max_input x2 < Some a; max_reg x2 = None\\<rbrakk>\n  \\<Longrightarrow> aval x2 (join_ir i ra) = aval x2 (join_ir (take a i) r)\n  max_input (Minus x1 x2) < Some a\n  max_reg (Minus x1 x2) = None", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>max_input x1 < Some a; max_reg x1 = None\\<rbrakk>\n  \\<Longrightarrow> aval x1 (join_ir i ra) = aval x1 (join_ir (take a i) r)\n  \\<lbrakk>max_input x2 < Some a; max_reg x2 = None\\<rbrakk>\n  \\<Longrightarrow> aval x2 (join_ir i ra) = aval x2 (join_ir (take a i) r)\n  max_input (Minus x1 x2) < Some a\n  max_reg (Minus x1 x2) = None\n\ngoal (1 subgoal):\n 1. aval (Minus x1 x2) (join_ir i ra) =\n    aval (Minus x1 x2) (join_ir (take a i) r)", "by (metis aval_take no_reg_aval_swap_regs)"], ["proof (state)\nthis:\n  aval (Minus x1 x2) (join_ir i ra) =\n  aval (Minus x1 x2) (join_ir (take a i) r)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>max_input (L x) < Some a; max_reg (L x) = None\\<rbrakk>\n       \\<Longrightarrow> aval (L x) (join_ir i ra) =\n                         aval (L x) (join_ir (take a i) r)\n 2. \\<And>x1 x2.\n       \\<lbrakk>\\<lbrakk>max_input x1 < Some a; max_reg x1 = None\\<rbrakk>\n                \\<Longrightarrow> aval x1 (join_ir i ra) =\n                                  aval x1 (join_ir (take a i) r);\n        \\<lbrakk>max_input x2 < Some a; max_reg x2 = None\\<rbrakk>\n        \\<Longrightarrow> aval x2 (join_ir i ra) =\n                          aval x2 (join_ir (take a i) r);\n        max_input (Times x1 x2) < Some a;\n        max_reg (Times x1 x2) = None\\<rbrakk>\n       \\<Longrightarrow> aval (Times x1 x2) (join_ir i ra) =\n                         aval (Times x1 x2) (join_ir (take a i) r)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>max_input (L x) < Some a; max_reg (L x) = None\\<rbrakk>\n       \\<Longrightarrow> aval (L x) (join_ir i ra) =\n                         aval (L x) (join_ir (take a i) r)\n 2. \\<And>x1 x2.\n       \\<lbrakk>\\<lbrakk>max_input x1 < Some a; max_reg x1 = None\\<rbrakk>\n                \\<Longrightarrow> aval x1 (join_ir i ra) =\n                                  aval x1 (join_ir (take a i) r);\n        \\<lbrakk>max_input x2 < Some a; max_reg x2 = None\\<rbrakk>\n        \\<Longrightarrow> aval x2 (join_ir i ra) =\n                          aval x2 (join_ir (take a i) r);\n        max_input (Times x1 x2) < Some a;\n        max_reg (Times x1 x2) = None\\<rbrakk>\n       \\<Longrightarrow> aval (Times x1 x2) (join_ir i ra) =\n                         aval (Times x1 x2) (join_ir (take a i) r)", "case (Times x1 x2)"], ["proof (state)\nthis:\n  \\<lbrakk>max_input x1 < Some a; max_reg x1 = None\\<rbrakk>\n  \\<Longrightarrow> aval x1 (join_ir i ra) = aval x1 (join_ir (take a i) r)\n  \\<lbrakk>max_input x2 < Some a; max_reg x2 = None\\<rbrakk>\n  \\<Longrightarrow> aval x2 (join_ir i ra) = aval x2 (join_ir (take a i) r)\n  max_input (Times x1 x2) < Some a\n  max_reg (Times x1 x2) = None\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>max_input (L x) < Some a; max_reg (L x) = None\\<rbrakk>\n       \\<Longrightarrow> aval (L x) (join_ir i ra) =\n                         aval (L x) (join_ir (take a i) r)\n 2. \\<And>x1 x2.\n       \\<lbrakk>\\<lbrakk>max_input x1 < Some a; max_reg x1 = None\\<rbrakk>\n                \\<Longrightarrow> aval x1 (join_ir i ra) =\n                                  aval x1 (join_ir (take a i) r);\n        \\<lbrakk>max_input x2 < Some a; max_reg x2 = None\\<rbrakk>\n        \\<Longrightarrow> aval x2 (join_ir i ra) =\n                          aval x2 (join_ir (take a i) r);\n        max_input (Times x1 x2) < Some a;\n        max_reg (Times x1 x2) = None\\<rbrakk>\n       \\<Longrightarrow> aval (Times x1 x2) (join_ir i ra) =\n                         aval (Times x1 x2) (join_ir (take a i) r)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>max_input x1 < Some a; max_reg x1 = None\\<rbrakk>\n  \\<Longrightarrow> aval x1 (join_ir i ra) = aval x1 (join_ir (take a i) r)\n  \\<lbrakk>max_input x2 < Some a; max_reg x2 = None\\<rbrakk>\n  \\<Longrightarrow> aval x2 (join_ir i ra) = aval x2 (join_ir (take a i) r)\n  max_input (Times x1 x2) < Some a\n  max_reg (Times x1 x2) = None", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>max_input x1 < Some a; max_reg x1 = None\\<rbrakk>\n  \\<Longrightarrow> aval x1 (join_ir i ra) = aval x1 (join_ir (take a i) r)\n  \\<lbrakk>max_input x2 < Some a; max_reg x2 = None\\<rbrakk>\n  \\<Longrightarrow> aval x2 (join_ir i ra) = aval x2 (join_ir (take a i) r)\n  max_input (Times x1 x2) < Some a\n  max_reg (Times x1 x2) = None\n\ngoal (1 subgoal):\n 1. aval (Times x1 x2) (join_ir i ra) =\n    aval (Times x1 x2) (join_ir (take a i) r)", "by (metis aval_take no_reg_aval_swap_regs)"], ["proof (state)\nthis:\n  aval (Times x1 x2) (join_ir i ra) =\n  aval (Times x1 x2) (join_ir (take a i) r)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>max_input (L x) < Some a; max_reg (L x) = None\\<rbrakk>\n       \\<Longrightarrow> aval (L x) (join_ir i ra) =\n                         aval (L x) (join_ir (take a i) r)", "qed auto"], ["", "fun enumerate_aexp_strings :: \"'a aexp \\<Rightarrow> String.literal set\" where\n  \"enumerate_aexp_strings (L (Str s)) = {s}\" |\n  \"enumerate_aexp_strings (L (Num s)) = {}\" |\n  \"enumerate_aexp_strings (V _) = {}\" |\n  \"enumerate_aexp_strings (Plus a1 a2) = enumerate_aexp_strings a1 \\<union> enumerate_aexp_strings a2\" |\n  \"enumerate_aexp_strings (Minus a1 a2) = enumerate_aexp_strings a1 \\<union> enumerate_aexp_strings a2\" |\n  \"enumerate_aexp_strings (Times a1 a2) = enumerate_aexp_strings a1 \\<union> enumerate_aexp_strings a2\""], ["", "fun enumerate_aexp_ints :: \"'a aexp \\<Rightarrow> int set\" where\n  \"enumerate_aexp_ints (L (Str s)) = {}\" |\n  \"enumerate_aexp_ints (L (Num s)) = {s}\" |\n  \"enumerate_aexp_ints (V _) = {}\" |\n  \"enumerate_aexp_ints (Plus a1 a2) = enumerate_aexp_ints a1 \\<union> enumerate_aexp_ints a2\" |\n  \"enumerate_aexp_ints (Minus a1 a2) = enumerate_aexp_ints a1 \\<union> enumerate_aexp_ints a2\" |\n  \"enumerate_aexp_ints (Times a1 a2) = enumerate_aexp_ints a1 \\<union> enumerate_aexp_ints a2\""], ["", "definition enumerate_vars :: \"vname aexp \\<Rightarrow> vname set\" where\n  \"enumerate_vars a = (image I (enumerate_aexp_inputs a)) \\<union> (image R (enumerate_regs a))\""], ["", "fun rename_regs :: \"(nat \\<Rightarrow> nat) \\<Rightarrow> vname aexp \\<Rightarrow> vname aexp\" where\n  \"rename_regs _ (L l) = (L l)\" |\n  \"rename_regs f (V (R r)) = (V (R (f r)))\" |\n  \"rename_regs _ (V v) = (V v)\" |\n  \"rename_regs f (Plus a b) = Plus (rename_regs f a) (rename_regs f b)\" |\n  \"rename_regs f (Minus a b) = Minus (rename_regs f a) (rename_regs f b)\" |\n  \"rename_regs f (Times a b) = Times (rename_regs f a) (rename_regs f b)\""], ["", "definition eq_upto_rename :: \"vname aexp \\<Rightarrow> vname aexp \\<Rightarrow> bool\" where\n  \"eq_upto_rename a1 a2 = (\\<exists>f. bij f \\<and> rename_regs f a1 = a2)\""], ["", "end"]]}