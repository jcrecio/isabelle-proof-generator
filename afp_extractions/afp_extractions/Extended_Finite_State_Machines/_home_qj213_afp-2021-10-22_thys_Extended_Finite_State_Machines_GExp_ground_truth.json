{"file_name": "/home/qj213/afp-2021-10-22/thys/Extended_Finite_State_Machines/GExp.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Extended_Finite_State_Machines", "problem_names": ["lemma gval_Lt [simp]:\n  \"gval (Lt a1 a2) s = value_gt (aval a2 s) (aval a1 s)\"", "lemma gval_Le [simp]:\n  \"gval (Le a1 a2) s = \\<not>? (value_gt (aval a1 s) (aval a2 s))\"", "lemma gval_Ge [simp]:\n  \"gval (Ge a1 a2) s = \\<not>? (value_gt (aval a2 s) (aval a1 s))\"", "lemma gval_Ne [simp]:\n  \"gval (Ne a1 a2) s = \\<not>? (value_eq (aval a1 s) (aval a2 s))\"", "lemmas connectives = gAnd_def gOr_def gNot_def Lt_def Le_def Ge_def Ne_def", "lemma gval_gOr [simp]: \"gval (gOr x y) r = (gval x r) \\<or>? (gval y r)\"", "lemma gval_gNot [simp]: \"gval (gNot x) s = \\<not>? (gval x s)\"", "lemma gval_gAnd [simp]:\n  \"gval (gAnd g1 g2) s = (gval g1 s) \\<and>? (gval g2 s)\"", "lemma gAnd_commute: \"gval (gAnd a b) s = gval (gAnd b a) s\"", "lemma gOr_commute: \"gval (gOr a b) s = gval (gOr b a) s\"", "lemma gval_gAnd_True:\n  \"(gval (gAnd g1 g2) s = true) = ((gval g1 s = true) \\<and> gval g2 s = true)\"", "lemma nor_equiv: \"gval (gNot (gOr a b)) s = gval (Nor a b) s\"", "lemma unsatisfiable_false: \"\\<not> satisfiable (Bc False)\"", "lemma satisfiable_true: \"satisfiable (Bc True)\"", "lemma valid_true: \"valid (Bc True)\"", "lemma gval_foldr_true:\n  \"(gval (foldr gAnd G (Bc True)) s = true) = (\\<forall>g \\<in> set G. gval g s = true)\"", "lemma enumerate_gexp_inputs_list: \"\\<exists>l. enumerate_gexp_inputs g = set l\"", "lemma max_input_list_cons:\n  \"max_input_list (a # G) = max (max_input a) (max_input_list G)\"", "lemma finite_enumerate_regs: \"finite (enumerate_regs g)\"", "lemma max_reg_gNot: \"max_reg (gNot x) = max_reg x\"", "lemma max_reg_Eq: \"max_reg (Eq a b) = max (AExp.max_reg a) (AExp.max_reg b)\"", "lemma max_reg_Gt: \"max_reg (Gt a b) = max (AExp.max_reg a) (AExp.max_reg b)\"", "lemma max_reg_Nor: \"max_reg (Nor a b) = max (max_reg a) (max_reg b)\"", "lemma gval_In_cons:\n  \"gval (In v (a # as)) s = (gval (Eq (V v) (L a)) s \\<or>? gval (In v as) s)\"", "lemma possible_to_be_in: \"s \\<noteq> [] \\<Longrightarrow> satisfiable (In v s)\"", "lemma max_reg_list_cons:\n  \"max_reg_list (a # G) = max (max_reg a) (max_reg_list G)\"", "lemma max_reg_list_append_singleton:\n  \"max_reg_list (as@[bs]) = max (max_reg_list as) (max_reg_list [bs])\"", "lemma max_reg_list_append:\n  \"max_reg_list (as@bs) = max (max_reg_list as) (max_reg_list bs)\"", "lemma apply_guards_singleton[simp]: \"(apply_guards [g] s) = (gval g s = true)\"", "lemma apply_guards_empty [simp]: \"apply_guards [] s\"", "lemma apply_guards_cons:\n  \"apply_guards (a # G) c = (gval a c = true \\<and> apply_guards G c)\"", "lemma apply_guards_double_cons:\n  \"apply_guards (y # x # G) s = (gval (gAnd y x) s = true \\<and> apply_guards G s)\"", "lemma apply_guards_append:\n  \"apply_guards (a@a') s = (apply_guards a s \\<and> apply_guards a' s)\"", "lemma apply_guards_foldr:\n  \"apply_guards G s = (gval (foldr gAnd G (Bc True)) s = true)\"", "lemma rev_apply_guards: \"apply_guards (rev G) s = apply_guards G s\"", "lemma apply_guards_fold:\n  \"apply_guards G s = (gval (fold gAnd G (Bc True)) s = true)\"", "lemma fold_apply_guards:\n  \"(gval (fold gAnd G (Bc True)) s = true) = apply_guards G s\"", "lemma foldr_apply_guards:\n  \"(gval (foldr gAnd G (Bc True)) s = true) = apply_guards G s\"", "lemma apply_guards_subset:\n  \"set g' \\<subseteq> set g \\<Longrightarrow> apply_guards g c \\<longrightarrow> apply_guards g' c\"", "lemma apply_guards_subset_append:\n  \"set G \\<subseteq> set G' \\<Longrightarrow> apply_guards (G @ G') s = apply_guards (G') s\"", "lemma apply_guards_rearrange:\n  \"x \\<in> set G \\<Longrightarrow> apply_guards G s = apply_guards (x#G) s\"", "lemma apply_guards_condense: \"\\<exists>g. apply_guards G s = (gval g s = true)\"", "lemma apply_guards_false_condense: \"\\<exists>g. (\\<not>apply_guards G s) = (gval g s = false)\"", "lemma max_input_Bc: \"max_input (Bc x) = None\"", "lemma max_input_Eq:\n  \"max_input (Eq a1 a2) = max (AExp.max_input a1) (AExp.max_input a2)\"", "lemma max_input_Gt:\n  \"max_input (Gt a1 a2) = max (AExp.max_input a1) (AExp.max_input a2)\"", "lemma gexp_max_input_Nor:\n  \"max_input (Nor g1 g2) = max (max_input g1) (max_input g2)\"", "lemma gexp_max_input_In: \"max_input (In v l) = AExp.max_input (V v)\"", "lemma gval_foldr_gOr_invalid:\n  \"(gval (fold gOr l g) s = invalid) = (\\<exists>g' \\<in> (set (g#l)). gval g' s = invalid)\"", "lemma gval_foldr_gOr_true:\n  \"(gval (fold gOr l g) s = true) = ((\\<exists>g' \\<in> (set (g#l)). gval g' s = true) \\<and> (\\<forall>g' \\<in> (set (g#l)). gval g' s \\<noteq> invalid))\"", "lemma gval_foldr_gOr_false:\n  \"(gval (fold gOr l g) s = false) = (\\<forall>g' \\<in> (set (g#l)). gval g' s = false)\"", "lemma gval_fold_gOr_rev: \"gval (fold gOr (rev l) g) s = gval (fold gOr l g) s\"", "lemma gval_fold_gOr_foldr: \"gval (fold gOr l g) s = gval (foldr gOr l g) s\"", "lemma gval_fold_gOr:\n  \"gval (fold gOr (a # l) g) s = (gval a s \\<or>? gval (fold gOr l g) s)\"", "lemma gval_In_fold:\n  \"gval (In v l) s = (if s v = None then invalid else gval (fold gOr (map (\\<lambda>x. Eq (V v) (L x)) l) (Bc False)) s)\"", "lemma gval_fold_In: \"l \\<noteq> [] \\<Longrightarrow> gval (In v l) s = gval (fold_In v l) s\"", "lemma fold_maybe_or_invalid_base: \"fold (\\<or>?) l invalid = invalid\"", "lemma fold_maybe_or_true_base_never_false:\n  \"fold (\\<or>?) l true \\<noteq> false\"", "lemma fold_true_fold_false_not_invalid:\n  \"fold (\\<or>?) l true = true \\<Longrightarrow>\n   fold (\\<or>?) (rev l) false \\<noteq> invalid\"", "lemma fold_true_invalid_fold_rev_false_invalid:\n  \"fold (\\<or>?) l true = invalid \\<Longrightarrow>\n   fold (\\<or>?) (rev l) false = invalid\"", "lemma fold_maybe_or_rev:\n  \"fold (\\<or>?) l b = fold (\\<or>?) (rev l) b\"", "lemma fold_maybe_or_cons:\n  \"fold (\\<or>?) (a#l) b = a \\<or>? (fold (\\<or>?) l b)\"", "lemma gval_fold_gOr_map:\n  \"gval (fold gOr l (Bc False)) s = fold (\\<or>?) (map (\\<lambda>g. gval g s) l) (false)\"", "lemma gval_unfold_first:\n  \"gval (fold gOr (map (\\<lambda>x. Eq (V v) (L x)) ls) (Eq (V v) (L l))) s =\n       gval (fold gOr (map (\\<lambda>x. Eq (V v) (L x)) (l#ls)) (Bc False)) s\"", "lemma fold_Eq_true:\n  \"\\<forall>v. fold (\\<or>?) (map (\\<lambda>x. if v = x then true else false) vs) true = true\"", "lemma x_in_set_fold_eq:\n  \"x \\<in> set ll \\<Longrightarrow>\n   fold (\\<or>?) (map (\\<lambda>xa. if x = xa then true else false) ll) false = true\"", "lemma x_not_in_set_fold_eq:\n  \"s v \\<notin> Some ` set ll \\<Longrightarrow>\n   false = fold (\\<or>?) (map (\\<lambda>x. if s v = Some x then true else false) ll) false\"", "lemma gval_take: \"max_input g < Some a \\<Longrightarrow>\n   gval g (join_ir i r) = gval g (join_ir (take a i) r)\"", "lemma gval_fold_gAnd_append_singleton:\n  \"gval (fold gAnd (a @ [G]) (Bc True)) s = gval (fold gAnd a (Bc True)) s \\<and>? gval G s\"", "lemma gval_fold_rev_true:\n  \"gval (fold gAnd (rev G) (Bc True)) s = true \\<Longrightarrow>\n   gval (fold gAnd G (Bc True)) s = true\"", "lemma gval_fold_not_invalid_all_valid_contra:\n  \"\\<exists>g \\<in> set G. gval g s = invalid \\<Longrightarrow>\n   gval (fold gAnd G (Bc True)) s = invalid\"", "lemma gval_fold_not_invalid_all_valid:\n  \"gval (fold gAnd G (Bc True)) s \\<noteq> invalid \\<Longrightarrow>\n   \\<forall>g \\<in> set G. gval g s \\<noteq> invalid\"", "lemma all_gval_not_false:\n  \"(\\<forall>g \\<in> set G. gval g s \\<noteq> false) = (\\<forall>g \\<in> set G. gval g s = true) \\<or> (\\<exists>g \\<in> set G. gval g s = invalid)\"", "lemma must_have_one_false_contra:\n  \"\\<forall>g \\<in> set G. gval g s \\<noteq> false \\<Longrightarrow>\n   gval (fold gAnd G (Bc True)) s \\<noteq> false\"", "lemma must_have_one_false:\n  \"gval (fold gAnd G (Bc True)) s = false \\<Longrightarrow>\n   \\<exists>g \\<in> set G. gval g s = false\"", "lemma all_valid_fold:\n  \"\\<forall>g \\<in> set G. gval g s \\<noteq> invalid \\<Longrightarrow>\n   gval (fold gAnd G (Bc True)) s \\<noteq> invalid\"", "lemma one_false_all_valid_false:\n  \"\\<exists>g\\<in>set G. gval g s = false \\<Longrightarrow>\n   \\<forall>g\\<in>set G. gval g s \\<noteq> invalid \\<Longrightarrow>\n   gval (fold gAnd G (Bc True)) s = false\"", "lemma gval_fold_rev_false:\n  \"gval (fold gAnd (rev G) (Bc True)) s = false \\<Longrightarrow>\n   gval (fold gAnd G (Bc True)) s = false\"", "lemma fold_invalid_means_one_invalid:\n  \"gval (fold gAnd G (Bc True)) s = invalid \\<Longrightarrow>\n   \\<exists>g \\<in> set G. gval g s = invalid\"", "lemma gval_fold_rev_invalid:\n  \"gval (fold gAnd (rev G) (Bc True)) s = invalid \\<Longrightarrow>\n   gval (fold gAnd G (Bc True)) s = invalid\"", "lemma gval_fold_rev_equiv_fold:\n  \"gval (fold gAnd (rev G) (Bc True)) s =  gval (fold gAnd G (Bc True)) s\"", "lemma gval_fold_equiv_fold_rev:\n  \"gval (fold gAnd G (Bc True)) s = gval (fold gAnd (rev G) (Bc True)) s\"", "lemma gval_fold_equiv_gval_foldr:\n  \"gval (fold gAnd G (Bc True)) s = gval (foldr gAnd G (Bc True)) s\"", "lemma gval_foldr_equiv_gval_fold:\n  \"gval (foldr gAnd G (Bc True)) s = gval (fold gAnd G (Bc True)) s\"", "lemma gval_fold_cons:\n  \"gval (fold gAnd (g # gs) (Bc True)) s = gval g s \\<and>? gval (fold gAnd gs (Bc True)) s\"", "lemma gval_fold_take: \"max_input_list G < Some a \\<Longrightarrow>\n   a \\<le> length i \\<Longrightarrow>\n   max_input_list G \\<le> Some (length i) \\<Longrightarrow>\n   gval (fold gAnd G (Bc True)) (join_ir i r) = gval (fold gAnd G (Bc True)) (join_ir (take a i) r)\"", "lemma length_padding: \"length (padding n) = n\"", "lemma length_take_or_pad: \"length (take_or_pad a n) = n\"", "lemma restricted_once_cons:\n  \"restricted_once v (g#gs) = ((gexp_constrains g (V v) \\<and> not_restricted v gs) \\<or> ((\\<not> gexp_constrains g (V v)) \\<and> restricted_once v gs))\"", "lemma not_restricted_cons:\n  \"not_restricted v (g#gs) = ((\\<not> gexp_constrains g (V v)) \\<and> not_restricted v gs)\"", "lemma gval_reg_some_superset:\n\"\\<forall>a. (r $ a  \\<noteq> None) \\<longrightarrow> r $ a = r' $ a \\<Longrightarrow>\n  x \\<noteq> invalid \\<Longrightarrow>\n gval a (join_ir i r) = x \\<Longrightarrow>\n gval a (join_ir i r') = x\"", "lemma apply_guards_reg_some_superset:\n  \"\\<forall>a. (r $ a  \\<noteq> None) \\<longrightarrow> r $ a = r' $ a \\<Longrightarrow>\n   apply_guards G (join_ir i r) \\<Longrightarrow>\n   apply_guards G (join_ir i r')\""], "translations": [["", "lemma gval_Lt [simp]:\n  \"gval (Lt a1 a2) s = value_gt (aval a2 s) (aval a1 s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gval (Lt a1 a2) s = value_gt (aval a2 s) (aval a1 s)", "by (simp add: Lt_def)"], ["", "lemma gval_Le [simp]:\n  \"gval (Le a1 a2) s = \\<not>? (value_gt (aval a1 s) (aval a2 s))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gval (Le a1 a2) s = \\<not>? value_gt (aval a1 s) (aval a2 s)", "by (simp add: Le_def value_gt_def gNot_def maybe_or_idempotent)"], ["", "lemma gval_Ge [simp]:\n  \"gval (Ge a1 a2) s = \\<not>? (value_gt (aval a2 s) (aval a1 s))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gval (Ge a1 a2) s = \\<not>? value_gt (aval a2 s) (aval a1 s)", "by (simp add: Ge_def value_gt_def gNot_def maybe_or_idempotent)"], ["", "lemma gval_Ne [simp]:\n  \"gval (Ne a1 a2) s = \\<not>? (value_eq (aval a1 s) (aval a2 s))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gval (Ne a1 a2) s = \\<not>? value_eq (aval a1 s) (aval a2 s)", "by (simp add: Ne_def value_gt_def gNot_def maybe_or_idempotent)"], ["", "lemmas connectives = gAnd_def gOr_def gNot_def Lt_def Le_def Ge_def Ne_def"], ["", "lemma gval_gOr [simp]: \"gval (gOr x y) r = (gval x r) \\<or>? (gval y r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gval (gOr x y) r = gval x r \\<or>? gval y r", "by (simp add: maybe_double_negation maybe_or_idempotent gOr_def)"], ["", "lemma gval_gNot [simp]: \"gval (gNot x) s = \\<not>? (gval x s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gval (gNot x) s = \\<not>? gval x s", "by (simp add: maybe_or_idempotent gNot_def)"], ["", "lemma gval_gAnd [simp]:\n  \"gval (gAnd g1 g2) s = (gval g1 s) \\<and>? (gval g2 s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gval (gAnd g1 g2) s = gval g1 s \\<and>? gval g2 s", "by (simp add: de_morgans_1 maybe_double_negation maybe_or_idempotent gAnd_def)"], ["", "lemma gAnd_commute: \"gval (gAnd a b) s = gval (gAnd b a) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gval (gAnd a b) s = gval (gAnd b a) s", "by (simp add: times_trilean_commutative)"], ["", "lemma gOr_commute: \"gval (gOr a b) s = gval (gOr b a) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gval (gOr a b) s = gval (gOr b a) s", "by (simp add: plus_trilean_commutative gOr_def)"], ["", "lemma gval_gAnd_True:\n  \"(gval (gAnd g1 g2) s = true) = ((gval g1 s = true) \\<and> gval g2 s = true)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (gval (gAnd g1 g2) s = true) =\n    (gval g1 s = true \\<and> gval g2 s = true)", "by (simp add: maybe_and_true)"], ["", "lemma nor_equiv: \"gval (gNot (gOr a b)) s = gval (Nor a b) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gval (gNot (gOr a b)) s = gval (Nor a b) s", "by simp"], ["", "definition satisfiable :: \"vname gexp \\<Rightarrow> bool\" where\n  \"satisfiable g \\<equiv> (\\<exists>i r. gval g (join_ir i r) = true)\""], ["", "definition \"satisfiable_list l = satisfiable (fold gAnd l (Bc True))\""], ["", "lemma unsatisfiable_false: \"\\<not> satisfiable (Bc False)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> satisfiable (Bc False)", "by (simp add: satisfiable_def)"], ["", "lemma satisfiable_true: \"satisfiable (Bc True)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. satisfiable (Bc True)", "by (simp add: satisfiable_def)"], ["", "definition valid :: \"vname gexp \\<Rightarrow> bool\" where\n  \"valid g \\<equiv> (\\<forall>s. gval g s = true)\""], ["", "lemma valid_true: \"valid (Bc True)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid (Bc True)", "by (simp add: valid_def)"], ["", "fun gexp_constrains :: \"'a gexp \\<Rightarrow> 'a aexp \\<Rightarrow> bool\" where\n  \"gexp_constrains (Bc _) _ = False\" |\n  \"gexp_constrains (Eq a1 a2) a = (aexp_constrains a1 a \\<or> aexp_constrains a2 a)\" |\n  \"gexp_constrains (Gt a1 a2) a = (aexp_constrains a1 a \\<or> aexp_constrains a2 a)\" |\n  \"gexp_constrains (Nor g1 g2) a = (gexp_constrains g1 a \\<or> gexp_constrains g2 a)\" |\n  \"gexp_constrains (In v l) a = aexp_constrains (V v) a\""], ["", "fun contains_bool :: \"'a gexp \\<Rightarrow> bool\" where\n  \"contains_bool (Bc _) = True\" |\n  \"contains_bool (Nor g1 g2) = (contains_bool g1 \\<or> contains_bool g2)\" |\n  \"contains_bool _ = False\""], ["", "fun gexp_same_structure :: \"'a gexp \\<Rightarrow> 'a gexp \\<Rightarrow> bool\" where\n  \"gexp_same_structure (Bc b) (Bc b') = (b = b')\" |\n  \"gexp_same_structure (Eq a1 a2) (Eq a1' a2') = (aexp_same_structure a1 a1' \\<and> aexp_same_structure a2 a2')\" |\n  \"gexp_same_structure (Gt a1 a2) (Gt a1' a2') = (aexp_same_structure a1 a1' \\<and> aexp_same_structure a2 a2')\" |\n  \"gexp_same_structure (Nor g1 g2) (Nor g1' g2') = (gexp_same_structure g1 g1' \\<and> gexp_same_structure g2 g2')\" |\n  \"gexp_same_structure (In v l) (In v' l') = (v = v' \\<and> l = l')\" |\n  \"gexp_same_structure _ _ = False\""], ["", "lemma gval_foldr_true:\n  \"(gval (foldr gAnd G (Bc True)) s = true) = (\\<forall>g \\<in> set G. gval g s = true)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (gval (foldr gAnd G (Bc True)) s = true) =\n    (\\<forall>g\\<in>set G. gval g s = true)", "proof(induct G)"], ["proof (state)\ngoal (2 subgoals):\n 1. (gval (foldr gAnd [] (Bc True)) s = true) =\n    (\\<forall>g\\<in>set []. gval g s = true)\n 2. \\<And>a G.\n       (gval (foldr gAnd G (Bc True)) s = true) =\n       (\\<forall>g\\<in>set G. gval g s = true) \\<Longrightarrow>\n       (gval (foldr gAnd (a # G) (Bc True)) s = true) =\n       (\\<forall>g\\<in>set (a # G). gval g s = true)", "case (Cons a G)"], ["proof (state)\nthis:\n  (gval (foldr gAnd G (Bc True)) s = true) =\n  (\\<forall>g\\<in>set G. gval g s = true)\n\ngoal (2 subgoals):\n 1. (gval (foldr gAnd [] (Bc True)) s = true) =\n    (\\<forall>g\\<in>set []. gval g s = true)\n 2. \\<And>a G.\n       (gval (foldr gAnd G (Bc True)) s = true) =\n       (\\<forall>g\\<in>set G. gval g s = true) \\<Longrightarrow>\n       (gval (foldr gAnd (a # G) (Bc True)) s = true) =\n       (\\<forall>g\\<in>set (a # G). gval g s = true)", "then"], ["proof (chain)\npicking this:\n  (gval (foldr gAnd G (Bc True)) s = true) =\n  (\\<forall>g\\<in>set G. gval g s = true)", "show ?case"], ["proof (prove)\nusing this:\n  (gval (foldr gAnd G (Bc True)) s = true) =\n  (\\<forall>g\\<in>set G. gval g s = true)\n\ngoal (1 subgoal):\n 1. (gval (foldr gAnd (a # G) (Bc True)) s = true) =\n    (\\<forall>g\\<in>set (a # G). gval g s = true)", "apply (simp only: foldr.simps comp_def gval_gAnd maybe_and_true)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (gval (foldr gAnd G (Bc True)) s = true) =\n    (\\<forall>g\\<in>set G. gval g s = true) \\<Longrightarrow>\n    (gval a s = true \\<and> (\\<forall>g\\<in>set G. gval g s = true)) =\n    (\\<forall>g\\<in>set (a # G). gval g s = true)", "by simp"], ["proof (state)\nthis:\n  (gval (foldr gAnd (a # G) (Bc True)) s = true) =\n  (\\<forall>g\\<in>set (a # G). gval g s = true)\n\ngoal (1 subgoal):\n 1. (gval (foldr gAnd [] (Bc True)) s = true) =\n    (\\<forall>g\\<in>set []. gval g s = true)", "qed auto"], ["", "fun enumerate_gexp_inputs :: \"vname gexp \\<Rightarrow> nat set\" where\n  \"enumerate_gexp_inputs (Bc _) = {}\" |\n  \"enumerate_gexp_inputs (Eq v va) = enumerate_aexp_inputs v \\<union> enumerate_aexp_inputs va\" |\n  \"enumerate_gexp_inputs (Gt v va) = enumerate_aexp_inputs v \\<union> enumerate_aexp_inputs va\" |\n  \"enumerate_gexp_inputs (In v va) = enumerate_aexp_inputs (V v)\" |\n  \"enumerate_gexp_inputs (Nor v va) = enumerate_gexp_inputs v \\<union> enumerate_gexp_inputs va\""], ["", "lemma enumerate_gexp_inputs_list: \"\\<exists>l. enumerate_gexp_inputs g = set l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>l. enumerate_gexp_inputs g = set l", "proof(induct g)"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>x. \\<exists>l. enumerate_gexp_inputs (Bc x) = set l\n 2. \\<And>x1a x2. \\<exists>l. enumerate_gexp_inputs (Eq x1a x2) = set l\n 3. \\<And>x1a x2. \\<exists>l. enumerate_gexp_inputs (Gt x1a x2) = set l\n 4. \\<And>x1a x2. \\<exists>l. enumerate_gexp_inputs (In x1a x2) = set l\n 5. \\<And>g1 g2.\n       \\<lbrakk>\\<exists>l. enumerate_gexp_inputs g1 = set l;\n        \\<exists>l. enumerate_gexp_inputs g2 = set l\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l.\n                            enumerate_gexp_inputs (Nor g1 g2) = set l", "case (Eq x1a x2)"], ["proof (state)\nthis:\n  \n\ngoal (5 subgoals):\n 1. \\<And>x. \\<exists>l. enumerate_gexp_inputs (Bc x) = set l\n 2. \\<And>x1a x2. \\<exists>l. enumerate_gexp_inputs (Eq x1a x2) = set l\n 3. \\<And>x1a x2. \\<exists>l. enumerate_gexp_inputs (Gt x1a x2) = set l\n 4. \\<And>x1a x2. \\<exists>l. enumerate_gexp_inputs (In x1a x2) = set l\n 5. \\<And>g1 g2.\n       \\<lbrakk>\\<exists>l. enumerate_gexp_inputs g1 = set l;\n        \\<exists>l. enumerate_gexp_inputs g2 = set l\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l.\n                            enumerate_gexp_inputs (Nor g1 g2) = set l", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>l. enumerate_gexp_inputs (Eq x1a x2) = set l", "by (metis enumerate_aexp_inputs_list enumerate_gexp_inputs.simps(2) set_append)"], ["proof (state)\nthis:\n  \\<exists>l. enumerate_gexp_inputs (Eq x1a x2) = set l\n\ngoal (4 subgoals):\n 1. \\<And>x. \\<exists>l. enumerate_gexp_inputs (Bc x) = set l\n 2. \\<And>x1a x2. \\<exists>l. enumerate_gexp_inputs (Gt x1a x2) = set l\n 3. \\<And>x1a x2. \\<exists>l. enumerate_gexp_inputs (In x1a x2) = set l\n 4. \\<And>g1 g2.\n       \\<lbrakk>\\<exists>l. enumerate_gexp_inputs g1 = set l;\n        \\<exists>l. enumerate_gexp_inputs g2 = set l\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l.\n                            enumerate_gexp_inputs (Nor g1 g2) = set l", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x. \\<exists>l. enumerate_gexp_inputs (Bc x) = set l\n 2. \\<And>x1a x2. \\<exists>l. enumerate_gexp_inputs (Gt x1a x2) = set l\n 3. \\<And>x1a x2. \\<exists>l. enumerate_gexp_inputs (In x1a x2) = set l\n 4. \\<And>g1 g2.\n       \\<lbrakk>\\<exists>l. enumerate_gexp_inputs g1 = set l;\n        \\<exists>l. enumerate_gexp_inputs g2 = set l\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l.\n                            enumerate_gexp_inputs (Nor g1 g2) = set l", "case (Gt x1a x2)"], ["proof (state)\nthis:\n  \n\ngoal (4 subgoals):\n 1. \\<And>x. \\<exists>l. enumerate_gexp_inputs (Bc x) = set l\n 2. \\<And>x1a x2. \\<exists>l. enumerate_gexp_inputs (Gt x1a x2) = set l\n 3. \\<And>x1a x2. \\<exists>l. enumerate_gexp_inputs (In x1a x2) = set l\n 4. \\<And>g1 g2.\n       \\<lbrakk>\\<exists>l. enumerate_gexp_inputs g1 = set l;\n        \\<exists>l. enumerate_gexp_inputs g2 = set l\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l.\n                            enumerate_gexp_inputs (Nor g1 g2) = set l", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>l. enumerate_gexp_inputs (Gt x1a x2) = set l", "by (metis enumerate_aexp_inputs_list enumerate_gexp_inputs.simps(3) set_append)"], ["proof (state)\nthis:\n  \\<exists>l. enumerate_gexp_inputs (Gt x1a x2) = set l\n\ngoal (3 subgoals):\n 1. \\<And>x. \\<exists>l. enumerate_gexp_inputs (Bc x) = set l\n 2. \\<And>x1a x2. \\<exists>l. enumerate_gexp_inputs (In x1a x2) = set l\n 3. \\<And>g1 g2.\n       \\<lbrakk>\\<exists>l. enumerate_gexp_inputs g1 = set l;\n        \\<exists>l. enumerate_gexp_inputs g2 = set l\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l.\n                            enumerate_gexp_inputs (Nor g1 g2) = set l", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x. \\<exists>l. enumerate_gexp_inputs (Bc x) = set l\n 2. \\<And>x1a x2. \\<exists>l. enumerate_gexp_inputs (In x1a x2) = set l\n 3. \\<And>g1 g2.\n       \\<lbrakk>\\<exists>l. enumerate_gexp_inputs g1 = set l;\n        \\<exists>l. enumerate_gexp_inputs g2 = set l\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l.\n                            enumerate_gexp_inputs (Nor g1 g2) = set l", "case (In x1a x2)"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. \\<And>x. \\<exists>l. enumerate_gexp_inputs (Bc x) = set l\n 2. \\<And>x1a x2. \\<exists>l. enumerate_gexp_inputs (In x1a x2) = set l\n 3. \\<And>g1 g2.\n       \\<lbrakk>\\<exists>l. enumerate_gexp_inputs g1 = set l;\n        \\<exists>l. enumerate_gexp_inputs g2 = set l\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l.\n                            enumerate_gexp_inputs (Nor g1 g2) = set l", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>l. enumerate_gexp_inputs (In x1a x2) = set l", "by (simp add: enumerate_aexp_inputs_list)"], ["proof (state)\nthis:\n  \\<exists>l. enumerate_gexp_inputs (In x1a x2) = set l\n\ngoal (2 subgoals):\n 1. \\<And>x. \\<exists>l. enumerate_gexp_inputs (Bc x) = set l\n 2. \\<And>g1 g2.\n       \\<lbrakk>\\<exists>l. enumerate_gexp_inputs g1 = set l;\n        \\<exists>l. enumerate_gexp_inputs g2 = set l\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l.\n                            enumerate_gexp_inputs (Nor g1 g2) = set l", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x. \\<exists>l. enumerate_gexp_inputs (Bc x) = set l\n 2. \\<And>g1 g2.\n       \\<lbrakk>\\<exists>l. enumerate_gexp_inputs g1 = set l;\n        \\<exists>l. enumerate_gexp_inputs g2 = set l\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l.\n                            enumerate_gexp_inputs (Nor g1 g2) = set l", "case (Nor g1 g2)"], ["proof (state)\nthis:\n  \\<exists>l. enumerate_gexp_inputs g1 = set l\n  \\<exists>l. enumerate_gexp_inputs g2 = set l\n\ngoal (2 subgoals):\n 1. \\<And>x. \\<exists>l. enumerate_gexp_inputs (Bc x) = set l\n 2. \\<And>g1 g2.\n       \\<lbrakk>\\<exists>l. enumerate_gexp_inputs g1 = set l;\n        \\<exists>l. enumerate_gexp_inputs g2 = set l\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l.\n                            enumerate_gexp_inputs (Nor g1 g2) = set l", "then"], ["proof (chain)\npicking this:\n  \\<exists>l. enumerate_gexp_inputs g1 = set l\n  \\<exists>l. enumerate_gexp_inputs g2 = set l", "show ?case"], ["proof (prove)\nusing this:\n  \\<exists>l. enumerate_gexp_inputs g1 = set l\n  \\<exists>l. enumerate_gexp_inputs g2 = set l\n\ngoal (1 subgoal):\n 1. \\<exists>l. enumerate_gexp_inputs (Nor g1 g2) = set l", "by (metis enumerate_gexp_inputs.simps(5) set_append)"], ["proof (state)\nthis:\n  \\<exists>l. enumerate_gexp_inputs (Nor g1 g2) = set l\n\ngoal (1 subgoal):\n 1. \\<And>x. \\<exists>l. enumerate_gexp_inputs (Bc x) = set l", "qed auto"], ["", "definition max_input :: \"vname gexp \\<Rightarrow> nat option\" where\n  \"max_input g = (let inputs = (enumerate_gexp_inputs g) in if inputs = {} then None else Some (Max inputs))\""], ["", "definition max_input_list :: \"vname gexp list \\<Rightarrow> nat option\" where\n  \"max_input_list g = fold max (map (\\<lambda>g. max_input g) g) None\""], ["", "lemma max_input_list_cons:\n  \"max_input_list (a # G) = max (max_input a) (max_input_list G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. max_input_list (a # G) = max (GExp.max_input a) (max_input_list G)", "apply (simp add: max_input_list_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. fold max (map GExp.max_input G) (max (GExp.max_input a) None) =\n    max (GExp.max_input a) (fold max (map GExp.max_input G) None)", "apply (cases \"max_input a\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. GExp.max_input a = None \\<Longrightarrow>\n    fold max (map GExp.max_input G) (max (GExp.max_input a) None) =\n    max (GExp.max_input a) (fold max (map GExp.max_input G) None)\n 2. \\<And>aa.\n       GExp.max_input a = Some aa \\<Longrightarrow>\n       fold max (map GExp.max_input G) (max (GExp.max_input a) None) =\n       max (GExp.max_input a) (fold max (map GExp.max_input G) None)", "apply (simp add: max_def_raw)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa.\n       GExp.max_input a = Some aa \\<Longrightarrow>\n       fold max (map GExp.max_input G) (max (GExp.max_input a) None) =\n       max (GExp.max_input a) (fold max (map GExp.max_input G) None)", "by (metis (no_types, lifting) List.finite_set Max.insert Max.set_eq_fold fold_simps(1) list.set(2) max.assoc set_empty)"], ["", "fun enumerate_regs :: \"vname gexp \\<Rightarrow> nat set\" where\n  \"enumerate_regs (Bc _) = {}\" |\n  \"enumerate_regs (Eq v va) = AExp.enumerate_regs v \\<union> AExp.enumerate_regs va\" |\n  \"enumerate_regs (Gt v va) = AExp.enumerate_regs v \\<union> AExp.enumerate_regs va\" |\n  \"enumerate_regs (In v va) = AExp.enumerate_regs (V v)\" |\n  \"enumerate_regs (Nor v va) = enumerate_regs v \\<union> enumerate_regs va\""], ["", "lemma finite_enumerate_regs: \"finite (enumerate_regs g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (GExp.enumerate_regs g)", "using AExp.finite_enumerate_regs"], ["proof (prove)\nusing this:\n  finite (AExp.enumerate_regs ?a)\n\ngoal (1 subgoal):\n 1. finite (GExp.enumerate_regs g)", "by (induct g, auto)"], ["", "definition max_reg :: \"vname gexp \\<Rightarrow> nat option\" where\n  \"max_reg g = (let regs = (enumerate_regs g) in if regs = {} then None else Some (Max regs))\""], ["", "lemma max_reg_gNot: \"max_reg (gNot x) = max_reg x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. GExp.max_reg (gNot x) = GExp.max_reg x", "by (simp add: max_reg_def gNot_def)"], ["", "lemma max_reg_Eq: \"max_reg (Eq a b) = max (AExp.max_reg a) (AExp.max_reg b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. GExp.max_reg (Eq a b) = max (AExp.max_reg a) (AExp.max_reg b)", "apply (simp add: max_reg_def AExp.max_reg_def Let_def max_absorb2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. AExp.enumerate_regs a \\<noteq> {} \\<longrightarrow>\n    (AExp.enumerate_regs b = {} \\<longrightarrow>\n     Some (Max (AExp.enumerate_regs a)) =\n     max (Some (Max (AExp.enumerate_regs a))) None) \\<and>\n    (AExp.enumerate_regs b \\<noteq> {} \\<longrightarrow>\n     Some (Max (AExp.enumerate_regs a \\<union> AExp.enumerate_regs b)) =\n     max (Some (Max (AExp.enumerate_regs a)))\n      (Some (Max (AExp.enumerate_regs b))))", "by (metis AExp.finite_enumerate_regs Max.union bot_option_def max_bot2 sup_Some sup_max)"], ["", "lemma max_reg_Gt: \"max_reg (Gt a b) = max (AExp.max_reg a) (AExp.max_reg b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. GExp.max_reg (Gt a b) = max (AExp.max_reg a) (AExp.max_reg b)", "apply (simp add: max_reg_def AExp.max_reg_def Let_def max_absorb2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. AExp.enumerate_regs a \\<noteq> {} \\<longrightarrow>\n    (AExp.enumerate_regs b = {} \\<longrightarrow>\n     Some (Max (AExp.enumerate_regs a)) =\n     max (Some (Max (AExp.enumerate_regs a))) None) \\<and>\n    (AExp.enumerate_regs b \\<noteq> {} \\<longrightarrow>\n     Some (Max (AExp.enumerate_regs a \\<union> AExp.enumerate_regs b)) =\n     max (Some (Max (AExp.enumerate_regs a)))\n      (Some (Max (AExp.enumerate_regs b))))", "by (metis AExp.finite_enumerate_regs Max.union bot_option_def max_bot2 sup_Some sup_max)"], ["", "lemma max_reg_Nor: \"max_reg (Nor a b) = max (max_reg a) (max_reg b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. GExp.max_reg (Nor a b) = max (GExp.max_reg a) (GExp.max_reg b)", "apply (simp add: max_reg_def AExp.max_reg_def Let_def max_absorb2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. GExp.enumerate_regs a \\<noteq> {} \\<longrightarrow>\n    (GExp.enumerate_regs b = {} \\<longrightarrow>\n     Some (Max (GExp.enumerate_regs a)) =\n     max (Some (Max (GExp.enumerate_regs a))) None) \\<and>\n    (GExp.enumerate_regs b \\<noteq> {} \\<longrightarrow>\n     Some (Max (GExp.enumerate_regs a \\<union> GExp.enumerate_regs b)) =\n     max (Some (Max (GExp.enumerate_regs a)))\n      (Some (Max (GExp.enumerate_regs b))))", "by (metis GExp.finite_enumerate_regs Max.union bot_option_def max_bot2 sup_Some sup_max)"], ["", "lemma gval_In_cons:\n  \"gval (In v (a # as)) s = (gval (Eq (V v) (L a)) s \\<or>? gval (In v as) s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gval (In v (a # as)) s = gval (Eq (V v) (L a)) s \\<or>? gval (In v as) s", "by (cases \"s v\", auto)"], ["", "lemma possible_to_be_in: \"s \\<noteq> [] \\<Longrightarrow> satisfiable (In v s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<noteq> [] \\<Longrightarrow> satisfiable (In v s)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. s \\<noteq> [] \\<Longrightarrow> satisfiable (In v s)", "assume \"s \\<noteq> []\""], ["proof (state)\nthis:\n  s \\<noteq> []\n\ngoal (1 subgoal):\n 1. s \\<noteq> [] \\<Longrightarrow> satisfiable (In v s)", "have aux: \"\\<exists>v' i r. join_ir i r v = Some v' \\<and> v' \\<in> set s \\<Longrightarrow>\n             \\<exists>i r. (case join_ir i r v of None \\<Rightarrow> false | Some v \\<Rightarrow> if v \\<in> set s then true else false) = true\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>v' i r.\n       join_ir i r v = Some v' \\<and> v' \\<in> set s \\<Longrightarrow>\n    \\<exists>i r.\n       (case join_ir i r v of None \\<Rightarrow> false\n        | Some v \\<Rightarrow> if v \\<in> set s then true else false) =\n       true", "by (metis (mono_tags, lifting) option.simps(5))"], ["proof (state)\nthis:\n  \\<exists>v' i r.\n     join_ir i r v = Some v' \\<and> v' \\<in> set s \\<Longrightarrow>\n  \\<exists>i r.\n     (case join_ir i r v of None \\<Rightarrow> false\n      | Some v \\<Rightarrow> if v \\<in> set s then true else false) =\n     true\n\ngoal (1 subgoal):\n 1. s \\<noteq> [] \\<Longrightarrow> satisfiable (In v s)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. satisfiable (In v s)", "apply (simp add: satisfiable_def gval_In_cons)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>i r.\n       (case join_ir i r v of None \\<Rightarrow> invalid\n        | Some vv \\<Rightarrow> if vv \\<in> set s then true else false) =\n       true", "apply (cases s)"], ["proof (prove)\ngoal (2 subgoals):\n 1. s = [] \\<Longrightarrow>\n    \\<exists>i r.\n       (case join_ir i r v of None \\<Rightarrow> invalid\n        | Some vv \\<Rightarrow> if vv \\<in> set s then true else false) =\n       true\n 2. \\<And>a list.\n       s = a # list \\<Longrightarrow>\n       \\<exists>i r.\n          (case join_ir i r v of None \\<Rightarrow> invalid\n           | Some vv \\<Rightarrow> if vv \\<in> set s then true else false) =\n          true", "apply (simp add: \\<open>s \\<noteq> []\\<close>)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       s = a # list \\<Longrightarrow>\n       \\<exists>i r.\n          (case join_ir i r v of None \\<Rightarrow> invalid\n           | Some vv \\<Rightarrow> if vv \\<in> set s then true else false) =\n          true", "apply (cases v)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a list x1.\n       \\<lbrakk>s = a # list; v = I x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i r.\n                            (case join_ir i r v of\n                             None \\<Rightarrow> invalid\n                             | Some vv \\<Rightarrow>\n                                 if vv \\<in> set s then true else false) =\n                            true\n 2. \\<And>a list x2.\n       \\<lbrakk>s = a # list; v = R x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i r.\n                            (case join_ir i r v of\n                             None \\<Rightarrow> invalid\n                             | Some vv \\<Rightarrow>\n                                 if vv \\<in> set s then true else false) =\n                            true", "apply (case_tac \"\\<exists>(i::value list). length i > x1 \\<and> i ! x1 = a\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a list x1.\n       \\<lbrakk>s = a # list; v = I x1;\n        \\<exists>i. x1 < length i \\<and> i ! x1 = a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i r.\n                            (case join_ir i r v of\n                             None \\<Rightarrow> invalid\n                             | Some vv \\<Rightarrow>\n                                 if vv \\<in> set s then true else false) =\n                            true\n 2. \\<And>a list x1.\n       \\<lbrakk>s = a # list; v = I x1;\n        \\<nexists>i. x1 < length i \\<and> i ! x1 = a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i r.\n                            (case join_ir i r v of\n                             None \\<Rightarrow> invalid\n                             | Some vv \\<Rightarrow>\n                                 if vv \\<in> set s then true else false) =\n                            true\n 3. \\<And>a list x2.\n       \\<lbrakk>s = a # list; v = R x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i r.\n                            (case join_ir i r v of\n                             None \\<Rightarrow> invalid\n                             | Some vv \\<Rightarrow>\n                                 if vv \\<in> set s then true else false) =\n                            true", "apply clarsimp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>list x1 i.\n       \\<lbrakk>v = I x1; s = i ! x1 # list; x1 < length i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ia r.\n                            (case join_ir ia r (I x1) of\n                             None \\<Rightarrow> invalid\n                             | Some vv \\<Rightarrow>\n                                 if vv \\<in> set (i ! x1 # list) then true\n                                 else false) =\n                            true\n 2. \\<And>a list x1.\n       \\<lbrakk>s = a # list; v = I x1;\n        \\<nexists>i. x1 < length i \\<and> i ! x1 = a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i r.\n                            (case join_ir i r v of\n                             None \\<Rightarrow> invalid\n                             | Some vv \\<Rightarrow>\n                                 if vv \\<in> set s then true else false) =\n                            true\n 3. \\<And>a list x2.\n       \\<lbrakk>s = a # list; v = R x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i r.\n                            (case join_ir i r v of\n                             None \\<Rightarrow> invalid\n                             | Some vv \\<Rightarrow>\n                                 if vv \\<in> set s then true else false) =\n                            true", "subgoal for _ _ i"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>v = I x1_; s = i ! x1_ # list_; x1_ < length i\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ia r.\n                         (case join_ir ia r (I x1_) of\n                          None \\<Rightarrow> invalid\n                          | Some vv \\<Rightarrow>\n                              if vv \\<in> set (i ! x1_ # list_) then true\n                              else false) =\n                         true", "by (rule exI[of _ i], intro exI, simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a list x1.\n       \\<lbrakk>s = a # list; v = I x1;\n        \\<nexists>i. x1 < length i \\<and> i ! x1 = a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i r.\n                            (case join_ir i r v of\n                             None \\<Rightarrow> invalid\n                             | Some vv \\<Rightarrow>\n                                 if vv \\<in> set s then true else false) =\n                            true\n 2. \\<And>a list x2.\n       \\<lbrakk>s = a # list; v = R x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i r.\n                            (case join_ir i r v of\n                             None \\<Rightarrow> invalid\n                             | Some vv \\<Rightarrow>\n                                 if vv \\<in> set s then true else false) =\n                            true", "apply (metis gt_ex length_list_update length_repeat nth_list_update_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a list x2.\n       \\<lbrakk>s = a # list; v = R x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i r.\n                            (case join_ir i r v of\n                             None \\<Rightarrow> invalid\n                             | Some vv \\<Rightarrow>\n                                 if vv \\<in> set s then true else false) =\n                            true", "apply (rule_tac exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a list x2.\n       \\<lbrakk>s = a # list; v = R x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r.\n                            (case join_ir (?i13 a list x2) r v of\n                             None \\<Rightarrow> invalid\n                             | Some vv \\<Rightarrow>\n                                 if vv \\<in> set s then true else false) =\n                            true", "apply (case_tac \"\\<exists>r. r $ x2 = Some a\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a list x2.\n       \\<lbrakk>s = a # list; v = R x2; \\<exists>r. r $ x2 = Some a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r.\n                            (case join_ir (?i13 a list x2) r v of\n                             None \\<Rightarrow> invalid\n                             | Some vv \\<Rightarrow>\n                                 if vv \\<in> set s then true else false) =\n                            true\n 2. \\<And>a list x2.\n       \\<lbrakk>s = a # list; v = R x2;\n        \\<nexists>r. r $ x2 = Some a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r.\n                            (case join_ir (?i13 a list x2) r v of\n                             None \\<Rightarrow> invalid\n                             | Some vv \\<Rightarrow>\n                                 if vv \\<in> set s then true else false) =\n                            true", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a list x2 r.\n       \\<lbrakk>v = R x2; s = a # list; r $ x2 = Some a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r.\n                            (case r $ x2 of None \\<Rightarrow> invalid\n                             | Some vv \\<Rightarrow>\n                                 if vv \\<in> set (a # list) then true\n                                 else false) =\n                            true\n 2. \\<And>a list x2.\n       \\<lbrakk>s = a # list; v = R x2;\n        \\<nexists>r. r $ x2 = Some a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r.\n                            (case join_ir (?i13 a list x2) r v of\n                             None \\<Rightarrow> invalid\n                             | Some vv \\<Rightarrow>\n                                 if vv \\<in> set s then true else false) =\n                            true", "subgoal for _ _ _ r"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>v = R x2_; s = a_ # list_; r $ x2_ = Some a_\\<rbrakk>\n    \\<Longrightarrow> \\<exists>r.\n                         (case r $ x2_ of None \\<Rightarrow> invalid\n                          | Some vv \\<Rightarrow>\n                              if vv \\<in> set (a_ # list_) then true\n                              else false) =\n                         true", "by (rule exI[of _ r], simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a list x2.\n       \\<lbrakk>s = a # list; v = R x2;\n        \\<nexists>r. r $ x2 = Some a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r.\n                            (case join_ir (?i13 a list x2) r v of\n                             None \\<Rightarrow> invalid\n                             | Some vv \\<Rightarrow>\n                                 if vv \\<in> set s then true else false) =\n                            true", "by (metis join_ir_R join_ir_double_exists)"], ["proof (state)\nthis:\n  satisfiable (In v s)\n\ngoal:\nNo subgoals!", "qed"], ["", "definition max_reg_list :: \"vname gexp list \\<Rightarrow> nat option\" where\n  \"max_reg_list g = (fold max (map (\\<lambda>g. max_reg g) g) None)\""], ["", "lemma max_reg_list_cons:\n  \"max_reg_list (a # G) = max (max_reg a) (max_reg_list G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. max_reg_list (a # G) = max (GExp.max_reg a) (max_reg_list G)", "apply (simp add: max_reg_list_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. fold max (map GExp.max_reg G) (max (GExp.max_reg a) None) =\n    max (GExp.max_reg a) (fold max (map GExp.max_reg G) None)", "by (metis (no_types, lifting) List.finite_set Max.insert Max.set_eq_fold fold.simps(1) id_apply list.simps(15) max.assoc set_empty)"], ["", "lemma max_reg_list_append_singleton:\n  \"max_reg_list (as@[bs]) = max (max_reg_list as) (max_reg_list [bs])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. max_reg_list (as @ [bs]) = max (max_reg_list as) (max_reg_list [bs])", "apply (simp add: max_reg_list_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. max (GExp.max_reg bs) (fold max (map GExp.max_reg as) None) =\n    max (fold max (map GExp.max_reg as) None) (max (GExp.max_reg bs) None)", "by (metis max.commute sup_None_2 sup_max)"], ["", "lemma max_reg_list_append:\n  \"max_reg_list (as@bs) = max (max_reg_list as) (max_reg_list bs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. max_reg_list (as @ bs) = max (max_reg_list as) (max_reg_list bs)", "proof(induct bs rule: rev_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. max_reg_list (as @ []) = max (max_reg_list as) (max_reg_list [])\n 2. \\<And>x xs.\n       max_reg_list (as @ xs) =\n       max (max_reg_list as) (max_reg_list xs) \\<Longrightarrow>\n       max_reg_list (as @ xs @ [x]) =\n       max (max_reg_list as) (max_reg_list (xs @ [x]))", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. max_reg_list (as @ []) = max (max_reg_list as) (max_reg_list [])\n 2. \\<And>x xs.\n       max_reg_list (as @ xs) =\n       max (max_reg_list as) (max_reg_list xs) \\<Longrightarrow>\n       max_reg_list (as @ xs @ [x]) =\n       max (max_reg_list as) (max_reg_list (xs @ [x]))", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. max_reg_list (as @ []) = max (max_reg_list as) (max_reg_list [])", "by (metis append_Nil2 fold_simps(1) list.simps(8) max_reg_list_def sup_None_2 sup_max)"], ["proof (state)\nthis:\n  max_reg_list (as @ []) = max (max_reg_list as) (max_reg_list [])\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       max_reg_list (as @ xs) =\n       max (max_reg_list as) (max_reg_list xs) \\<Longrightarrow>\n       max_reg_list (as @ xs @ [x]) =\n       max (max_reg_list as) (max_reg_list (xs @ [x]))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       max_reg_list (as @ xs) =\n       max (max_reg_list as) (max_reg_list xs) \\<Longrightarrow>\n       max_reg_list (as @ xs @ [x]) =\n       max (max_reg_list as) (max_reg_list (xs @ [x]))", "case (snoc x xs)"], ["proof (state)\nthis:\n  max_reg_list (as @ xs) = max (max_reg_list as) (max_reg_list xs)\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       max_reg_list (as @ xs) =\n       max (max_reg_list as) (max_reg_list xs) \\<Longrightarrow>\n       max_reg_list (as @ xs @ [x]) =\n       max (max_reg_list as) (max_reg_list (xs @ [x]))", "then"], ["proof (chain)\npicking this:\n  max_reg_list (as @ xs) = max (max_reg_list as) (max_reg_list xs)", "show ?case"], ["proof (prove)\nusing this:\n  max_reg_list (as @ xs) = max (max_reg_list as) (max_reg_list xs)\n\ngoal (1 subgoal):\n 1. max_reg_list (as @ xs @ [x]) =\n    max (max_reg_list as) (max_reg_list (xs @ [x]))", "by (metis append_assoc max.assoc max_reg_list_append_singleton)"], ["proof (state)\nthis:\n  max_reg_list (as @ xs @ [x]) =\n  max (max_reg_list as) (max_reg_list (xs @ [x]))\n\ngoal:\nNo subgoals!", "qed"], ["", "definition apply_guards :: \"vname gexp list \\<Rightarrow> vname datastate \\<Rightarrow> bool\" where\n  \"apply_guards G s = (\\<forall>g \\<in> set (map (\\<lambda>g. gval g s) G). g = true)\""], ["", "lemma apply_guards_singleton[simp]: \"(apply_guards [g] s) = (gval g s = true)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. apply_guards [g] s = (gval g s = true)", "by (simp add: apply_guards_def)"], ["", "lemma apply_guards_empty [simp]: \"apply_guards [] s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. apply_guards [] s", "by (simp add: apply_guards_def)"], ["", "lemma apply_guards_cons:\n  \"apply_guards (a # G) c = (gval a c = true \\<and> apply_guards G c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. apply_guards (a # G) c = (gval a c = true \\<and> apply_guards G c)", "by (simp add: apply_guards_def)"], ["", "lemma apply_guards_double_cons:\n  \"apply_guards (y # x # G) s = (gval (gAnd y x) s = true \\<and> apply_guards G s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. apply_guards (y # x # G) s =\n    (gval (gAnd y x) s = true \\<and> apply_guards G s)", "using apply_guards_cons gval_gAnd_True"], ["proof (prove)\nusing this:\n  apply_guards (?a # ?G) ?c = (gval ?a ?c = true \\<and> apply_guards ?G ?c)\n  (gval (gAnd ?g1.0 ?g2.0) ?s = true) =\n  (gval ?g1.0 ?s = true \\<and> gval ?g2.0 ?s = true)\n\ngoal (1 subgoal):\n 1. apply_guards (y # x # G) s =\n    (gval (gAnd y x) s = true \\<and> apply_guards G s)", "by blast"], ["", "lemma apply_guards_append:\n  \"apply_guards (a@a') s = (apply_guards a s \\<and> apply_guards a' s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. apply_guards (a @ a') s = (apply_guards a s \\<and> apply_guards a' s)", "using apply_guards_def"], ["proof (prove)\nusing this:\n  apply_guards ?G ?s =\n  (\\<forall>g\\<in>set (map (\\<lambda>g. gval g ?s) ?G). g = true)\n\ngoal (1 subgoal):\n 1. apply_guards (a @ a') s = (apply_guards a s \\<and> apply_guards a' s)", "by auto"], ["", "lemma apply_guards_foldr:\n  \"apply_guards G s = (gval (foldr gAnd G (Bc True)) s = true)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. apply_guards G s = (gval (foldr gAnd G (Bc True)) s = true)", "proof(induct G)"], ["proof (state)\ngoal (2 subgoals):\n 1. apply_guards [] s = (gval (foldr gAnd [] (Bc True)) s = true)\n 2. \\<And>a G.\n       apply_guards G s =\n       (gval (foldr gAnd G (Bc True)) s = true) \\<Longrightarrow>\n       apply_guards (a # G) s =\n       (gval (foldr gAnd (a # G) (Bc True)) s = true)", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. apply_guards [] s = (gval (foldr gAnd [] (Bc True)) s = true)\n 2. \\<And>a G.\n       apply_guards G s =\n       (gval (foldr gAnd G (Bc True)) s = true) \\<Longrightarrow>\n       apply_guards (a # G) s =\n       (gval (foldr gAnd (a # G) (Bc True)) s = true)", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. apply_guards [] s = (gval (foldr gAnd [] (Bc True)) s = true)", "by (simp add: apply_guards_def)"], ["proof (state)\nthis:\n  apply_guards [] s = (gval (foldr gAnd [] (Bc True)) s = true)\n\ngoal (1 subgoal):\n 1. \\<And>a G.\n       apply_guards G s =\n       (gval (foldr gAnd G (Bc True)) s = true) \\<Longrightarrow>\n       apply_guards (a # G) s =\n       (gval (foldr gAnd (a # G) (Bc True)) s = true)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a G.\n       apply_guards G s =\n       (gval (foldr gAnd G (Bc True)) s = true) \\<Longrightarrow>\n       apply_guards (a # G) s =\n       (gval (foldr gAnd (a # G) (Bc True)) s = true)", "case (Cons a G)"], ["proof (state)\nthis:\n  apply_guards G s = (gval (foldr gAnd G (Bc True)) s = true)\n\ngoal (1 subgoal):\n 1. \\<And>a G.\n       apply_guards G s =\n       (gval (foldr gAnd G (Bc True)) s = true) \\<Longrightarrow>\n       apply_guards (a # G) s =\n       (gval (foldr gAnd (a # G) (Bc True)) s = true)", "then"], ["proof (chain)\npicking this:\n  apply_guards G s = (gval (foldr gAnd G (Bc True)) s = true)", "show ?case"], ["proof (prove)\nusing this:\n  apply_guards G s = (gval (foldr gAnd G (Bc True)) s = true)\n\ngoal (1 subgoal):\n 1. apply_guards (a # G) s = (gval (foldr gAnd (a # G) (Bc True)) s = true)", "by (metis apply_guards_cons foldr.simps(2) gval_gAnd_True o_apply)"], ["proof (state)\nthis:\n  apply_guards (a # G) s = (gval (foldr gAnd (a # G) (Bc True)) s = true)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rev_apply_guards: \"apply_guards (rev G) s = apply_guards G s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. apply_guards (rev G) s = apply_guards G s", "by (simp add: apply_guards_def)"], ["", "lemma apply_guards_fold:\n  \"apply_guards G s = (gval (fold gAnd G (Bc True)) s = true)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. apply_guards G s = (gval (fold gAnd G (Bc True)) s = true)", "using rev_apply_guards[symmetric]"], ["proof (prove)\nusing this:\n  apply_guards ?G ?s = apply_guards (rev ?G) ?s\n\ngoal (1 subgoal):\n 1. apply_guards G s = (gval (fold gAnd G (Bc True)) s = true)", "by (simp add: foldr_conv_fold apply_guards_foldr)"], ["", "lemma fold_apply_guards:\n  \"(gval (fold gAnd G (Bc True)) s = true) = apply_guards G s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (gval (fold gAnd G (Bc True)) s = true) = apply_guards G s", "by (simp add: apply_guards_fold)"], ["", "lemma foldr_apply_guards:\n  \"(gval (foldr gAnd G (Bc True)) s = true) = apply_guards G s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (gval (foldr gAnd G (Bc True)) s = true) = apply_guards G s", "by (simp add: apply_guards_foldr)"], ["", "lemma apply_guards_subset:\n  \"set g' \\<subseteq> set g \\<Longrightarrow> apply_guards g c \\<longrightarrow> apply_guards g' c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set g' \\<subseteq> set g \\<Longrightarrow>\n    apply_guards g c \\<longrightarrow> apply_guards g' c", "proof(induct g)"], ["proof (state)\ngoal (2 subgoals):\n 1. set g' \\<subseteq> set [] \\<Longrightarrow>\n    apply_guards [] c \\<longrightarrow> apply_guards g' c\n 2. \\<And>a g.\n       \\<lbrakk>set g' \\<subseteq> set g \\<Longrightarrow>\n                apply_guards g c \\<longrightarrow> apply_guards g' c;\n        set g' \\<subseteq> set (a # g)\\<rbrakk>\n       \\<Longrightarrow> apply_guards (a # g) c \\<longrightarrow>\n                         apply_guards g' c", "case (Cons a g)"], ["proof (state)\nthis:\n  set g' \\<subseteq> set g \\<Longrightarrow>\n  apply_guards g c \\<longrightarrow> apply_guards g' c\n  set g' \\<subseteq> set (a # g)\n\ngoal (2 subgoals):\n 1. set g' \\<subseteq> set [] \\<Longrightarrow>\n    apply_guards [] c \\<longrightarrow> apply_guards g' c\n 2. \\<And>a g.\n       \\<lbrakk>set g' \\<subseteq> set g \\<Longrightarrow>\n                apply_guards g c \\<longrightarrow> apply_guards g' c;\n        set g' \\<subseteq> set (a # g)\\<rbrakk>\n       \\<Longrightarrow> apply_guards (a # g) c \\<longrightarrow>\n                         apply_guards g' c", "then"], ["proof (chain)\npicking this:\n  set g' \\<subseteq> set g \\<Longrightarrow>\n  apply_guards g c \\<longrightarrow> apply_guards g' c\n  set g' \\<subseteq> set (a # g)", "show ?case"], ["proof (prove)\nusing this:\n  set g' \\<subseteq> set g \\<Longrightarrow>\n  apply_guards g c \\<longrightarrow> apply_guards g' c\n  set g' \\<subseteq> set (a # g)\n\ngoal (1 subgoal):\n 1. apply_guards (a # g) c \\<longrightarrow> apply_guards g' c", "using apply_guards_def"], ["proof (prove)\nusing this:\n  set g' \\<subseteq> set g \\<Longrightarrow>\n  apply_guards g c \\<longrightarrow> apply_guards g' c\n  set g' \\<subseteq> set (a # g)\n  apply_guards ?G ?s =\n  (\\<forall>g\\<in>set (map (\\<lambda>g. gval g ?s) ?G). g = true)\n\ngoal (1 subgoal):\n 1. apply_guards (a # g) c \\<longrightarrow> apply_guards g' c", "by auto"], ["proof (state)\nthis:\n  apply_guards (a # g) c \\<longrightarrow> apply_guards g' c\n\ngoal (1 subgoal):\n 1. set g' \\<subseteq> set [] \\<Longrightarrow>\n    apply_guards [] c \\<longrightarrow> apply_guards g' c", "qed auto"], ["", "lemma apply_guards_subset_append:\n  \"set G \\<subseteq> set G' \\<Longrightarrow> apply_guards (G @ G') s = apply_guards (G') s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set G \\<subseteq> set G' \\<Longrightarrow>\n    apply_guards (G @ G') s = apply_guards G' s", "using apply_guards_append apply_guards_subset"], ["proof (prove)\nusing this:\n  apply_guards (?a @ ?a') ?s =\n  (apply_guards ?a ?s \\<and> apply_guards ?a' ?s)\n  set ?g' \\<subseteq> set ?g \\<Longrightarrow>\n  apply_guards ?g ?c \\<longrightarrow> apply_guards ?g' ?c\n\ngoal (1 subgoal):\n 1. set G \\<subseteq> set G' \\<Longrightarrow>\n    apply_guards (G @ G') s = apply_guards G' s", "by blast"], ["", "lemma apply_guards_rearrange:\n  \"x \\<in> set G \\<Longrightarrow> apply_guards G s = apply_guards (x#G) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> set G \\<Longrightarrow>\n    apply_guards G s = apply_guards (x # G) s", "using apply_guards_def"], ["proof (prove)\nusing this:\n  apply_guards ?G ?s =\n  (\\<forall>g\\<in>set (map (\\<lambda>g. gval g ?s) ?G). g = true)\n\ngoal (1 subgoal):\n 1. x \\<in> set G \\<Longrightarrow>\n    apply_guards G s = apply_guards (x # G) s", "by auto"], ["", "lemma apply_guards_condense: \"\\<exists>g. apply_guards G s = (gval g s = true)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>g. apply_guards G s = (gval g s = true)", "using apply_guards_fold"], ["proof (prove)\nusing this:\n  apply_guards ?G ?s = (gval (fold gAnd ?G (Bc True)) ?s = true)\n\ngoal (1 subgoal):\n 1. \\<exists>g. apply_guards G s = (gval g s = true)", "by blast"], ["", "lemma apply_guards_false_condense: \"\\<exists>g. (\\<not>apply_guards G s) = (gval g s = false)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>g. (\\<not> apply_guards G s) = (gval g s = false)", "using foldr_apply_guards gval.simps(2) not_true"], ["proof (prove)\nusing this:\n  (gval (foldr gAnd ?G (Bc True)) ?s = true) = apply_guards ?G ?s\n  gval (Bc False) ?uv = false\n  (?x \\<noteq> true) = (?x = false \\<or> ?x = invalid)\n\ngoal (1 subgoal):\n 1. \\<exists>g. (\\<not> apply_guards G s) = (gval g s = false)", "by blast"], ["", "lemma max_input_Bc: \"max_input (Bc x) = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. GExp.max_input (Bc x) = None", "by (simp add: max_input_def)"], ["", "lemma max_input_Eq:\n  \"max_input (Eq a1 a2) = max (AExp.max_input a1) (AExp.max_input a2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. GExp.max_input (Eq a1 a2) = max (AExp.max_input a1) (AExp.max_input a2)", "apply (simp add: AExp.max_input_def max_input_def Let_def max_absorb2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. enumerate_aexp_inputs a1 \\<noteq> {} \\<longrightarrow>\n    (enumerate_aexp_inputs a2 = {} \\<longrightarrow>\n     Some (Max (enumerate_aexp_inputs a1)) =\n     max (Some (Max (enumerate_aexp_inputs a1))) None) \\<and>\n    (enumerate_aexp_inputs a2 \\<noteq> {} \\<longrightarrow>\n     Some\n      (Max (enumerate_aexp_inputs a1 \\<union> enumerate_aexp_inputs a2)) =\n     max (Some (Max (enumerate_aexp_inputs a1)))\n      (Some (Max (enumerate_aexp_inputs a2))))", "by (metis List.finite_set Max.union bot_option_def enumerate_aexp_inputs_not_empty max_bot2 sup_Some sup_max)"], ["", "lemma max_input_Gt:\n  \"max_input (Gt a1 a2) = max (AExp.max_input a1) (AExp.max_input a2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. GExp.max_input (Gt a1 a2) = max (AExp.max_input a1) (AExp.max_input a2)", "apply (simp add: AExp.max_input_def max_input_def Let_def max_absorb2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. enumerate_aexp_inputs a1 \\<noteq> {} \\<longrightarrow>\n    (enumerate_aexp_inputs a2 = {} \\<longrightarrow>\n     Some (Max (enumerate_aexp_inputs a1)) =\n     max (Some (Max (enumerate_aexp_inputs a1))) None) \\<and>\n    (enumerate_aexp_inputs a2 \\<noteq> {} \\<longrightarrow>\n     Some\n      (Max (enumerate_aexp_inputs a1 \\<union> enumerate_aexp_inputs a2)) =\n     max (Some (Max (enumerate_aexp_inputs a1)))\n      (Some (Max (enumerate_aexp_inputs a2))))", "by (metis List.finite_set Max.union bot_option_def enumerate_aexp_inputs_not_empty max_bot2 sup_Some sup_max)"], ["", "lemma gexp_max_input_Nor:\n  \"max_input (Nor g1 g2) = max (max_input g1) (max_input g2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. GExp.max_input (Nor g1 g2) = max (GExp.max_input g1) (GExp.max_input g2)", "apply (simp add: AExp.max_input_def max_input_def Let_def max_absorb2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. enumerate_gexp_inputs g1 \\<noteq> {} \\<longrightarrow>\n    (enumerate_gexp_inputs g2 = {} \\<longrightarrow>\n     Some (Max (enumerate_gexp_inputs g1)) =\n     max (Some (Max (enumerate_gexp_inputs g1))) None) \\<and>\n    (enumerate_gexp_inputs g2 \\<noteq> {} \\<longrightarrow>\n     Some\n      (Max (enumerate_gexp_inputs g1 \\<union> enumerate_gexp_inputs g2)) =\n     max (Some (Max (enumerate_gexp_inputs g1)))\n      (Some (Max (enumerate_gexp_inputs g2))))", "by (metis List.finite_set Max.union enumerate_gexp_inputs_list less_eq_option_Some_None max_def sup_Some sup_max)"], ["", "lemma gexp_max_input_In: \"max_input (In v l) = AExp.max_input (V v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. GExp.max_input (In v l) = AExp.max_input (V v)", "by (simp add: AExp.max_input_def GExp.max_input_def)"], ["", "lemma gval_foldr_gOr_invalid:\n  \"(gval (fold gOr l g) s = invalid) = (\\<exists>g' \\<in> (set (g#l)). gval g' s = invalid)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (gval (fold gOr l g) s = invalid) =\n    (\\<exists>g'\\<in>set (g # l). gval g' s = invalid)", "proof(induct l rule: rev_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. (gval (fold gOr [] g) s = invalid) =\n    (\\<exists>g'\\<in>set [g]. gval g' s = invalid)\n 2. \\<And>x xs.\n       (gval (fold gOr xs g) s = invalid) =\n       (\\<exists>g'\\<in>set (g # xs). gval g' s = invalid) \\<Longrightarrow>\n       (gval (fold gOr (xs @ [x]) g) s = invalid) =\n       (\\<exists>g'\\<in>set (g # xs @ [x]). gval g' s = invalid)", "case (snoc x xs)"], ["proof (state)\nthis:\n  (gval (fold gOr xs g) s = invalid) =\n  (\\<exists>g'\\<in>set (g # xs). gval g' s = invalid)\n\ngoal (2 subgoals):\n 1. (gval (fold gOr [] g) s = invalid) =\n    (\\<exists>g'\\<in>set [g]. gval g' s = invalid)\n 2. \\<And>x xs.\n       (gval (fold gOr xs g) s = invalid) =\n       (\\<exists>g'\\<in>set (g # xs). gval g' s = invalid) \\<Longrightarrow>\n       (gval (fold gOr (xs @ [x]) g) s = invalid) =\n       (\\<exists>g'\\<in>set (g # xs @ [x]). gval g' s = invalid)", "then"], ["proof (chain)\npicking this:\n  (gval (fold gOr xs g) s = invalid) =\n  (\\<exists>g'\\<in>set (g # xs). gval g' s = invalid)", "show ?case"], ["proof (prove)\nusing this:\n  (gval (fold gOr xs g) s = invalid) =\n  (\\<exists>g'\\<in>set (g # xs). gval g' s = invalid)\n\ngoal (1 subgoal):\n 1. (gval (fold gOr (xs @ [x]) g) s = invalid) =\n    (\\<exists>g'\\<in>set (g # xs @ [x]). gval g' s = invalid)", "by (simp, metis gval_gOr maybe_or_invalid)"], ["proof (state)\nthis:\n  (gval (fold gOr (xs @ [x]) g) s = invalid) =\n  (\\<exists>g'\\<in>set (g # xs @ [x]). gval g' s = invalid)\n\ngoal (1 subgoal):\n 1. (gval (fold gOr [] g) s = invalid) =\n    (\\<exists>g'\\<in>set [g]. gval g' s = invalid)", "qed auto"], ["", "lemma gval_foldr_gOr_true:\n  \"(gval (fold gOr l g) s = true) = ((\\<exists>g' \\<in> (set (g#l)). gval g' s = true) \\<and> (\\<forall>g' \\<in> (set (g#l)). gval g' s \\<noteq> invalid))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (gval (fold gOr l g) s = true) =\n    ((\\<exists>g'\\<in>set (g # l). gval g' s = true) \\<and>\n     (\\<forall>g'\\<in>set (g # l). gval g' s \\<noteq> invalid))", "proof(induct l rule: rev_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. (gval (fold gOr [] g) s = true) =\n    ((\\<exists>g'\\<in>set [g]. gval g' s = true) \\<and>\n     (\\<forall>g'\\<in>set [g]. gval g' s \\<noteq> invalid))\n 2. \\<And>x xs.\n       (gval (fold gOr xs g) s = true) =\n       ((\\<exists>g'\\<in>set (g # xs). gval g' s = true) \\<and>\n        (\\<forall>g'\\<in>set (g # xs).\n            gval g' s \\<noteq> invalid)) \\<Longrightarrow>\n       (gval (fold gOr (xs @ [x]) g) s = true) =\n       ((\\<exists>g'\\<in>set (g # xs @ [x]). gval g' s = true) \\<and>\n        (\\<forall>g'\\<in>set (g # xs @ [x]). gval g' s \\<noteq> invalid))", "case (snoc x xs)"], ["proof (state)\nthis:\n  (gval (fold gOr xs g) s = true) =\n  ((\\<exists>g'\\<in>set (g # xs). gval g' s = true) \\<and>\n   (\\<forall>g'\\<in>set (g # xs). gval g' s \\<noteq> invalid))\n\ngoal (2 subgoals):\n 1. (gval (fold gOr [] g) s = true) =\n    ((\\<exists>g'\\<in>set [g]. gval g' s = true) \\<and>\n     (\\<forall>g'\\<in>set [g]. gval g' s \\<noteq> invalid))\n 2. \\<And>x xs.\n       (gval (fold gOr xs g) s = true) =\n       ((\\<exists>g'\\<in>set (g # xs). gval g' s = true) \\<and>\n        (\\<forall>g'\\<in>set (g # xs).\n            gval g' s \\<noteq> invalid)) \\<Longrightarrow>\n       (gval (fold gOr (xs @ [x]) g) s = true) =\n       ((\\<exists>g'\\<in>set (g # xs @ [x]). gval g' s = true) \\<and>\n        (\\<forall>g'\\<in>set (g # xs @ [x]). gval g' s \\<noteq> invalid))", "then"], ["proof (chain)\npicking this:\n  (gval (fold gOr xs g) s = true) =\n  ((\\<exists>g'\\<in>set (g # xs). gval g' s = true) \\<and>\n   (\\<forall>g'\\<in>set (g # xs). gval g' s \\<noteq> invalid))", "show ?case"], ["proof (prove)\nusing this:\n  (gval (fold gOr xs g) s = true) =\n  ((\\<exists>g'\\<in>set (g # xs). gval g' s = true) \\<and>\n   (\\<forall>g'\\<in>set (g # xs). gval g' s \\<noteq> invalid))\n\ngoal (1 subgoal):\n 1. (gval (fold gOr (xs @ [x]) g) s = true) =\n    ((\\<exists>g'\\<in>set (g # xs @ [x]). gval g' s = true) \\<and>\n     (\\<forall>g'\\<in>set (g # xs @ [x]). gval g' s \\<noteq> invalid))", "apply (simp add: maybe_or_true)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (gval (fold gOr xs g) s = true) =\n    ((gval g s = true \\<or>\n      (\\<exists>g'\\<in>set xs. gval g' s = true)) \\<and>\n     gval g s \\<noteq> invalid \\<and>\n     (\\<forall>g'\\<in>set xs. gval g' s \\<noteq> invalid)) \\<Longrightarrow>\n    ((gval x s = true \\<or>\n      (gval g s = true \\<or>\n       (\\<exists>g'\\<in>set xs. gval g' s = true)) \\<and>\n      gval g s \\<noteq> invalid \\<and>\n      (\\<forall>g'\\<in>set xs. gval g' s \\<noteq> invalid)) \\<and>\n     gval x s \\<noteq> invalid \\<and>\n     gval (fold gOr xs g) s \\<noteq> invalid) =\n    ((gval g s = true \\<or>\n      gval x s = true \\<or>\n      (\\<exists>g'\\<in>set xs. gval g' s = true)) \\<and>\n     gval g s \\<noteq> invalid \\<and>\n     gval x s \\<noteq> invalid \\<and>\n     (\\<forall>g'\\<in>set xs. gval g' s \\<noteq> invalid))", "using gval_foldr_gOr_invalid"], ["proof (prove)\nusing this:\n  (gval (fold gOr ?l ?g) ?s = invalid) =\n  (\\<exists>g'\\<in>set (?g # ?l). gval g' ?s = invalid)\n\ngoal (1 subgoal):\n 1. (gval (fold gOr xs g) s = true) =\n    ((gval g s = true \\<or>\n      (\\<exists>g'\\<in>set xs. gval g' s = true)) \\<and>\n     gval g s \\<noteq> invalid \\<and>\n     (\\<forall>g'\\<in>set xs. gval g' s \\<noteq> invalid)) \\<Longrightarrow>\n    ((gval x s = true \\<or>\n      (gval g s = true \\<or>\n       (\\<exists>g'\\<in>set xs. gval g' s = true)) \\<and>\n      gval g s \\<noteq> invalid \\<and>\n      (\\<forall>g'\\<in>set xs. gval g' s \\<noteq> invalid)) \\<and>\n     gval x s \\<noteq> invalid \\<and>\n     gval (fold gOr xs g) s \\<noteq> invalid) =\n    ((gval g s = true \\<or>\n      gval x s = true \\<or>\n      (\\<exists>g'\\<in>set xs. gval g' s = true)) \\<and>\n     gval g s \\<noteq> invalid \\<and>\n     gval x s \\<noteq> invalid \\<and>\n     (\\<forall>g'\\<in>set xs. gval g' s \\<noteq> invalid))", "by auto"], ["proof (state)\nthis:\n  (gval (fold gOr (xs @ [x]) g) s = true) =\n  ((\\<exists>g'\\<in>set (g # xs @ [x]). gval g' s = true) \\<and>\n   (\\<forall>g'\\<in>set (g # xs @ [x]). gval g' s \\<noteq> invalid))\n\ngoal (1 subgoal):\n 1. (gval (fold gOr [] g) s = true) =\n    ((\\<exists>g'\\<in>set [g]. gval g' s = true) \\<and>\n     (\\<forall>g'\\<in>set [g]. gval g' s \\<noteq> invalid))", "qed auto"], ["", "lemma gval_foldr_gOr_false:\n  \"(gval (fold gOr l g) s = false) = (\\<forall>g' \\<in> (set (g#l)). gval g' s = false)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (gval (fold gOr l g) s = false) =\n    (\\<forall>g'\\<in>set (g # l). gval g' s = false)", "proof(induct l rule: rev_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. (gval (fold gOr [] g) s = false) =\n    (\\<forall>g'\\<in>set [g]. gval g' s = false)\n 2. \\<And>x xs.\n       (gval (fold gOr xs g) s = false) =\n       (\\<forall>g'\\<in>set (g # xs). gval g' s = false) \\<Longrightarrow>\n       (gval (fold gOr (xs @ [x]) g) s = false) =\n       (\\<forall>g'\\<in>set (g # xs @ [x]). gval g' s = false)", "case (snoc x xs)"], ["proof (state)\nthis:\n  (gval (fold gOr xs g) s = false) =\n  (\\<forall>g'\\<in>set (g # xs). gval g' s = false)\n\ngoal (2 subgoals):\n 1. (gval (fold gOr [] g) s = false) =\n    (\\<forall>g'\\<in>set [g]. gval g' s = false)\n 2. \\<And>x xs.\n       (gval (fold gOr xs g) s = false) =\n       (\\<forall>g'\\<in>set (g # xs). gval g' s = false) \\<Longrightarrow>\n       (gval (fold gOr (xs @ [x]) g) s = false) =\n       (\\<forall>g'\\<in>set (g # xs @ [x]). gval g' s = false)", "then"], ["proof (chain)\npicking this:\n  (gval (fold gOr xs g) s = false) =\n  (\\<forall>g'\\<in>set (g # xs). gval g' s = false)", "show ?case"], ["proof (prove)\nusing this:\n  (gval (fold gOr xs g) s = false) =\n  (\\<forall>g'\\<in>set (g # xs). gval g' s = false)\n\ngoal (1 subgoal):\n 1. (gval (fold gOr (xs @ [x]) g) s = false) =\n    (\\<forall>g'\\<in>set (g # xs @ [x]). gval g' s = false)", "by (auto simp add: maybe_or_false)"], ["proof (state)\nthis:\n  (gval (fold gOr (xs @ [x]) g) s = false) =\n  (\\<forall>g'\\<in>set (g # xs @ [x]). gval g' s = false)\n\ngoal (1 subgoal):\n 1. (gval (fold gOr [] g) s = false) =\n    (\\<forall>g'\\<in>set [g]. gval g' s = false)", "qed auto"], ["", "lemma gval_fold_gOr_rev: \"gval (fold gOr (rev l) g) s = gval (fold gOr l g) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gval (fold gOr (rev l) g) s = gval (fold gOr l g) s", "apply (cases \"gval (fold gOr l g) s\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. gval (fold gOr l g) s = true \\<Longrightarrow>\n    gval (fold gOr (rev l) g) s = gval (fold gOr l g) s\n 2. gval (fold gOr l g) s = false \\<Longrightarrow>\n    gval (fold gOr (rev l) g) s = gval (fold gOr l g) s\n 3. gval (fold gOr l g) s = invalid \\<Longrightarrow>\n    gval (fold gOr (rev l) g) s = gval (fold gOr l g) s", "apply (simp, simp add: gval_foldr_gOr_true)"], ["proof (prove)\ngoal (2 subgoals):\n 1. gval (fold gOr l g) s = false \\<Longrightarrow>\n    gval (fold gOr (rev l) g) s = gval (fold gOr l g) s\n 2. gval (fold gOr l g) s = invalid \\<Longrightarrow>\n    gval (fold gOr (rev l) g) s = gval (fold gOr l g) s", "apply (simp, simp add: gval_foldr_gOr_false)"], ["proof (prove)\ngoal (1 subgoal):\n 1. gval (fold gOr l g) s = invalid \\<Longrightarrow>\n    gval (fold gOr (rev l) g) s = gval (fold gOr l g) s", "by (simp, simp add: gval_foldr_gOr_invalid)"], ["", "lemma gval_fold_gOr_foldr: \"gval (fold gOr l g) s = gval (foldr gOr l g) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gval (fold gOr l g) s = gval (foldr gOr l g) s", "by (simp add: foldr_conv_fold gval_fold_gOr_rev)"], ["", "lemma gval_fold_gOr:\n  \"gval (fold gOr (a # l) g) s = (gval a s \\<or>? gval (fold gOr l g) s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gval (fold gOr (a # l) g) s = gval a s \\<or>? gval (fold gOr l g) s", "by (simp only: gval_fold_gOr_foldr foldr.simps comp_def gval_gOr)"], ["", "lemma gval_In_fold:\n  \"gval (In v l) s = (if s v = None then invalid else gval (fold gOr (map (\\<lambda>x. Eq (V v) (L x)) l) (Bc False)) s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gval (In v l) s =\n    (if s v = None then invalid\n     else gval (fold gOr (map (\\<lambda>x. Eq (V v) (L x)) l) (Bc False)) s)", "proof(induct l)"], ["proof (state)\ngoal (2 subgoals):\n 1. gval (In v []) s =\n    (if s v = None then invalid\n     else gval (fold gOr (map (\\<lambda>x. Eq (V v) (L x)) []) (Bc False))\n           s)\n 2. \\<And>a l.\n       gval (In v l) s =\n       (if s v = None then invalid\n        else gval (fold gOr (map (\\<lambda>x. Eq (V v) (L x)) l) (Bc False))\n              s) \\<Longrightarrow>\n       gval (In v (a # l)) s =\n       (if s v = None then invalid\n        else gval\n              (fold gOr (map (\\<lambda>x. Eq (V v) (L x)) (a # l))\n                (Bc False))\n              s)", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. gval (In v []) s =\n    (if s v = None then invalid\n     else gval (fold gOr (map (\\<lambda>x. Eq (V v) (L x)) []) (Bc False))\n           s)\n 2. \\<And>a l.\n       gval (In v l) s =\n       (if s v = None then invalid\n        else gval (fold gOr (map (\\<lambda>x. Eq (V v) (L x)) l) (Bc False))\n              s) \\<Longrightarrow>\n       gval (In v (a # l)) s =\n       (if s v = None then invalid\n        else gval\n              (fold gOr (map (\\<lambda>x. Eq (V v) (L x)) (a # l))\n                (Bc False))\n              s)", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. gval (In v []) s =\n    (if s v = None then invalid\n     else gval (fold gOr (map (\\<lambda>x. Eq (V v) (L x)) []) (Bc False))\n           s)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>y. s v = Some y) \\<longrightarrow>\n    (case s v of None \\<Rightarrow> invalid\n     | Some vv \\<Rightarrow> if vv \\<in> set [] then true else false) =\n    false", "apply (cases \"s v\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. s v = None \\<Longrightarrow>\n    (\\<exists>y. s v = Some y) \\<longrightarrow>\n    (case s v of None \\<Rightarrow> invalid\n     | Some vv \\<Rightarrow> if vv \\<in> set [] then true else false) =\n    false\n 2. \\<And>a.\n       s v = Some a \\<Longrightarrow>\n       (\\<exists>y. s v = Some y) \\<longrightarrow>\n       (case s v of None \\<Rightarrow> invalid\n        | Some vv \\<Rightarrow> if vv \\<in> set [] then true else false) =\n       false", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       s v = Some a \\<Longrightarrow>\n       (\\<exists>y. s v = Some y) \\<longrightarrow>\n       (case s v of None \\<Rightarrow> invalid\n        | Some vv \\<Rightarrow> if vv \\<in> set [] then true else false) =\n       false", "by auto"], ["proof (state)\nthis:\n  gval (In v []) s =\n  (if s v = None then invalid\n   else gval (fold gOr (map (\\<lambda>x. Eq (V v) (L x)) []) (Bc False)) s)\n\ngoal (1 subgoal):\n 1. \\<And>a l.\n       gval (In v l) s =\n       (if s v = None then invalid\n        else gval (fold gOr (map (\\<lambda>x. Eq (V v) (L x)) l) (Bc False))\n              s) \\<Longrightarrow>\n       gval (In v (a # l)) s =\n       (if s v = None then invalid\n        else gval\n              (fold gOr (map (\\<lambda>x. Eq (V v) (L x)) (a # l))\n                (Bc False))\n              s)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a l.\n       gval (In v l) s =\n       (if s v = None then invalid\n        else gval (fold gOr (map (\\<lambda>x. Eq (V v) (L x)) l) (Bc False))\n              s) \\<Longrightarrow>\n       gval (In v (a # l)) s =\n       (if s v = None then invalid\n        else gval\n              (fold gOr (map (\\<lambda>x. Eq (V v) (L x)) (a # l))\n                (Bc False))\n              s)", "case (Cons a l)"], ["proof (state)\nthis:\n  gval (In v l) s =\n  (if s v = None then invalid\n   else gval (fold gOr (map (\\<lambda>x. Eq (V v) (L x)) l) (Bc False)) s)\n\ngoal (1 subgoal):\n 1. \\<And>a l.\n       gval (In v l) s =\n       (if s v = None then invalid\n        else gval (fold gOr (map (\\<lambda>x. Eq (V v) (L x)) l) (Bc False))\n              s) \\<Longrightarrow>\n       gval (In v (a # l)) s =\n       (if s v = None then invalid\n        else gval\n              (fold gOr (map (\\<lambda>x. Eq (V v) (L x)) (a # l))\n                (Bc False))\n              s)", "then"], ["proof (chain)\npicking this:\n  gval (In v l) s =\n  (if s v = None then invalid\n   else gval (fold gOr (map (\\<lambda>x. Eq (V v) (L x)) l) (Bc False)) s)", "show ?case"], ["proof (prove)\nusing this:\n  gval (In v l) s =\n  (if s v = None then invalid\n   else gval (fold gOr (map (\\<lambda>x. Eq (V v) (L x)) l) (Bc False)) s)\n\ngoal (1 subgoal):\n 1. gval (In v (a # l)) s =\n    (if s v = None then invalid\n     else gval\n           (fold gOr (map (\\<lambda>x. Eq (V v) (L x)) (a # l)) (Bc False))\n           s)", "apply (simp only: gval_In_cons)"], ["proof (prove)\ngoal (1 subgoal):\n 1. gval (In v l) s =\n    (if s v = None then invalid\n     else gval (fold gOr (map (\\<lambda>x. Eq (V v) (L x)) l) (Bc False))\n           s) \\<Longrightarrow>\n    gval (Eq (V v) (L a)) s \\<or>?\n    (if s v = None then invalid\n     else gval (fold gOr (map (\\<lambda>x. Eq (V v) (L x)) l) (Bc False))\n           s) =\n    (if s v = None then invalid\n     else gval\n           (fold gOr (map (\\<lambda>x. Eq (V v) (L x)) (a # l)) (Bc False))\n           s)", "apply (cases \"s v\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>gval (In v l) s =\n             (if s v = None then invalid\n              else gval\n                    (fold gOr (map (\\<lambda>x. Eq (V v) (L x)) l)\n                      (Bc False))\n                    s);\n     s v = None\\<rbrakk>\n    \\<Longrightarrow> gval (Eq (V v) (L a)) s \\<or>?\n                      (if s v = None then invalid\n                       else gval\n                             (fold gOr (map (\\<lambda>x. Eq (V v) (L x)) l)\n                               (Bc False))\n                             s) =\n                      (if s v = None then invalid\n                       else gval\n                             (fold gOr\n                               (map (\\<lambda>x. Eq (V v) (L x)) (a # l))\n                               (Bc False))\n                             s)\n 2. \\<And>aa.\n       \\<lbrakk>gval (In v l) s =\n                (if s v = None then invalid\n                 else gval\n                       (fold gOr (map (\\<lambda>x. Eq (V v) (L x)) l)\n                         (Bc False))\n                       s);\n        s v = Some aa\\<rbrakk>\n       \\<Longrightarrow> gval (Eq (V v) (L a)) s \\<or>?\n                         (if s v = None then invalid\n                          else gval\n                                (fold gOr\n                                  (map (\\<lambda>x. Eq (V v) (L x)) l)\n                                  (Bc False))\n                                s) =\n                         (if s v = None then invalid\n                          else gval\n                                (fold gOr\n                                  (map (\\<lambda>x. Eq (V v) (L x)) (a # l))\n                                  (Bc False))\n                                s)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa.\n       \\<lbrakk>gval (In v l) s =\n                (if s v = None then invalid\n                 else gval\n                       (fold gOr (map (\\<lambda>x. Eq (V v) (L x)) l)\n                         (Bc False))\n                       s);\n        s v = Some aa\\<rbrakk>\n       \\<Longrightarrow> gval (Eq (V v) (L a)) s \\<or>?\n                         (if s v = None then invalid\n                          else gval\n                                (fold gOr\n                                  (map (\\<lambda>x. Eq (V v) (L x)) l)\n                                  (Bc False))\n                                s) =\n                         (if s v = None then invalid\n                          else gval\n                                (fold gOr\n                                  (map (\\<lambda>x. Eq (V v) (L x)) (a # l))\n                                  (Bc False))\n                                s)", "by (simp add: gval_fold_gOr del: fold.simps)"], ["proof (state)\nthis:\n  gval (In v (a # l)) s =\n  (if s v = None then invalid\n   else gval\n         (fold gOr (map (\\<lambda>x. Eq (V v) (L x)) (a # l)) (Bc False)) s)\n\ngoal:\nNo subgoals!", "qed"], ["", "fun fold_In :: \"'a \\<Rightarrow> value list \\<Rightarrow> 'a gexp\" where\n  \"fold_In _ [] = Bc False\" |\n  \"fold_In v (l#t) = gOr (Eq (V v) (L l)) (fold_In v t)\""], ["", "lemma gval_fold_In: \"l \\<noteq> [] \\<Longrightarrow> gval (In v l) s = gval (fold_In v l) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l \\<noteq> [] \\<Longrightarrow> gval (In v l) s = gval (fold_In v l) s", "proof(induct l)"], ["proof (state)\ngoal (2 subgoals):\n 1. [] \\<noteq> [] \\<Longrightarrow>\n    gval (In v []) s = gval (fold_In v []) s\n 2. \\<And>a l.\n       \\<lbrakk>l \\<noteq> [] \\<Longrightarrow>\n                gval (In v l) s = gval (fold_In v l) s;\n        a # l \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> gval (In v (a # l)) s = gval (fold_In v (a # l)) s", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. [] \\<noteq> [] \\<Longrightarrow>\n    gval (In v []) s = gval (fold_In v []) s\n 2. \\<And>a l.\n       \\<lbrakk>l \\<noteq> [] \\<Longrightarrow>\n                gval (In v l) s = gval (fold_In v l) s;\n        a # l \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> gval (In v (a # l)) s = gval (fold_In v (a # l)) s", "case (Cons a l)"], ["proof (state)\nthis:\n  l \\<noteq> [] \\<Longrightarrow> gval (In v l) s = gval (fold_In v l) s\n  a # l \\<noteq> []\n\ngoal (2 subgoals):\n 1. [] \\<noteq> [] \\<Longrightarrow>\n    gval (In v []) s = gval (fold_In v []) s\n 2. \\<And>a l.\n       \\<lbrakk>l \\<noteq> [] \\<Longrightarrow>\n                gval (In v l) s = gval (fold_In v l) s;\n        a # l \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> gval (In v (a # l)) s = gval (fold_In v (a # l)) s", "then"], ["proof (chain)\npicking this:\n  l \\<noteq> [] \\<Longrightarrow> gval (In v l) s = gval (fold_In v l) s\n  a # l \\<noteq> []", "show ?case"], ["proof (prove)\nusing this:\n  l \\<noteq> [] \\<Longrightarrow> gval (In v l) s = gval (fold_In v l) s\n  a # l \\<noteq> []\n\ngoal (1 subgoal):\n 1. gval (In v (a # l)) s = gval (fold_In v (a # l)) s", "apply (case_tac \"s v\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>l \\<noteq> [] \\<Longrightarrow>\n             gval (In v l) s = gval (fold_In v l) s;\n     a # l \\<noteq> []; s v = None\\<rbrakk>\n    \\<Longrightarrow> gval (In v (a # l)) s = gval (fold_In v (a # l)) s\n 2. \\<And>aa.\n       \\<lbrakk>l \\<noteq> [] \\<Longrightarrow>\n                gval (In v l) s = gval (fold_In v l) s;\n        a # l \\<noteq> []; s v = Some aa\\<rbrakk>\n       \\<Longrightarrow> gval (In v (a # l)) s = gval (fold_In v (a # l)) s", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa.\n       \\<lbrakk>l \\<noteq> [] \\<Longrightarrow>\n                gval (In v l) s = gval (fold_In v l) s;\n        a # l \\<noteq> []; s v = Some aa\\<rbrakk>\n       \\<Longrightarrow> gval (In v (a # l)) s = gval (fold_In v (a # l)) s", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa.\n       \\<lbrakk>l \\<noteq> [] \\<Longrightarrow>\n                (if aa \\<in> set l then true else false) =\n                gval (fold_In v l) s;\n        s v = Some aa\\<rbrakk>\n       \\<Longrightarrow> (aa = a \\<longrightarrow>\n                          true = true \\<or>? gval (fold_In v l) s \\<and>\n                          (a \\<in> set l \\<longrightarrow>\n                           true = true \\<or>? gval (fold_In v l) s)) \\<and>\n                         (aa \\<noteq> a \\<longrightarrow>\n                          (aa \\<in> set l \\<longrightarrow>\n                           true = false \\<or>? gval (fold_In v l) s) \\<and>\n                          (aa \\<notin> set l \\<longrightarrow>\n                           false = false \\<or>? gval (fold_In v l) s))", "apply safe"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>aa.\n       \\<lbrakk>l \\<noteq> [] \\<Longrightarrow>\n                (if a \\<in> set l then true else false) =\n                gval (fold_In v l) s;\n        s v = Some a\\<rbrakk>\n       \\<Longrightarrow> true = true \\<or>? gval (fold_In v l) s\n 2. \\<And>aa.\n       \\<lbrakk>l \\<noteq> [] \\<Longrightarrow>\n                (if a \\<in> set l then true else false) =\n                gval (fold_In v l) s;\n        s v = Some a; a \\<in> set l\\<rbrakk>\n       \\<Longrightarrow> true = true \\<or>? gval (fold_In v l) s\n 3. \\<And>aa.\n       \\<lbrakk>l \\<noteq> [] \\<Longrightarrow>\n                (if aa \\<in> set l then true else false) =\n                gval (fold_In v l) s;\n        s v = Some aa; aa \\<noteq> a; aa \\<in> set l\\<rbrakk>\n       \\<Longrightarrow> true = false \\<or>? gval (fold_In v l) s\n 4. \\<And>aa.\n       \\<lbrakk>l \\<noteq> [] \\<Longrightarrow>\n                (if aa \\<in> set l then true else false) =\n                gval (fold_In v l) s;\n        s v = Some aa; aa \\<noteq> a; aa \\<notin> set l\\<rbrakk>\n       \\<Longrightarrow> false = false \\<or>? gval (fold_In v l) s", "apply simp"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>l \\<noteq> [] \\<Longrightarrow>\n             (if a \\<in> set l then true else false) = gval (fold_In v l) s;\n     s v = Some a\\<rbrakk>\n    \\<Longrightarrow> true = true \\<or>? gval (fold_In v l) s\n 2. \\<And>aa.\n       \\<lbrakk>l \\<noteq> [] \\<Longrightarrow>\n                (if a \\<in> set l then true else false) =\n                gval (fold_In v l) s;\n        s v = Some a; a \\<in> set l\\<rbrakk>\n       \\<Longrightarrow> true = true \\<or>? gval (fold_In v l) s\n 3. \\<And>aa.\n       \\<lbrakk>l \\<noteq> [] \\<Longrightarrow>\n                (if aa \\<in> set l then true else false) =\n                gval (fold_In v l) s;\n        s v = Some aa; aa \\<noteq> a; aa \\<in> set l\\<rbrakk>\n       \\<Longrightarrow> true = false \\<or>? gval (fold_In v l) s\n 4. \\<And>aa.\n       \\<lbrakk>l \\<noteq> [] \\<Longrightarrow>\n                (if aa \\<in> set l then true else false) =\n                gval (fold_In v l) s;\n        s v = Some aa; aa \\<noteq> a; aa \\<notin> set l\\<rbrakk>\n       \\<Longrightarrow> false = false \\<or>? gval (fold_In v l) s", "apply (metis fold_In.simps(1) gval.simps(2) plus_trilean.simps(4) plus_trilean.simps(5))"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>aa.\n       \\<lbrakk>l \\<noteq> [] \\<Longrightarrow>\n                (if a \\<in> set l then true else false) =\n                gval (fold_In v l) s;\n        s v = Some a; a \\<in> set l\\<rbrakk>\n       \\<Longrightarrow> true = true \\<or>? gval (fold_In v l) s\n 2. \\<And>aa.\n       \\<lbrakk>l \\<noteq> [] \\<Longrightarrow>\n                (if aa \\<in> set l then true else false) =\n                gval (fold_In v l) s;\n        s v = Some aa; aa \\<noteq> a; aa \\<in> set l\\<rbrakk>\n       \\<Longrightarrow> true = false \\<or>? gval (fold_In v l) s\n 3. \\<And>aa.\n       \\<lbrakk>l \\<noteq> [] \\<Longrightarrow>\n                (if aa \\<in> set l then true else false) =\n                gval (fold_In v l) s;\n        s v = Some aa; aa \\<noteq> a; aa \\<notin> set l\\<rbrakk>\n       \\<Longrightarrow> false = false \\<or>? gval (fold_In v l) s", "apply fastforce"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa.\n       \\<lbrakk>l \\<noteq> [] \\<Longrightarrow>\n                (if aa \\<in> set l then true else false) =\n                gval (fold_In v l) s;\n        s v = Some aa; aa \\<noteq> a; aa \\<in> set l\\<rbrakk>\n       \\<Longrightarrow> true = false \\<or>? gval (fold_In v l) s\n 2. \\<And>aa.\n       \\<lbrakk>l \\<noteq> [] \\<Longrightarrow>\n                (if aa \\<in> set l then true else false) =\n                gval (fold_In v l) s;\n        s v = Some aa; aa \\<noteq> a; aa \\<notin> set l\\<rbrakk>\n       \\<Longrightarrow> false = false \\<or>? gval (fold_In v l) s", "apply fastforce"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa.\n       \\<lbrakk>l \\<noteq> [] \\<Longrightarrow>\n                (if aa \\<in> set l then true else false) =\n                gval (fold_In v l) s;\n        s v = Some aa; aa \\<noteq> a; aa \\<notin> set l\\<rbrakk>\n       \\<Longrightarrow> false = false \\<or>? gval (fold_In v l) s", "by fastforce"], ["proof (state)\nthis:\n  gval (In v (a # l)) s = gval (fold_In v (a # l)) s\n\ngoal (1 subgoal):\n 1. [] \\<noteq> [] \\<Longrightarrow>\n    gval (In v []) s = gval (fold_In v []) s", "qed auto"], ["", "lemma fold_maybe_or_invalid_base: \"fold (\\<or>?) l invalid = invalid\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fold (\\<or>?) l invalid = invalid", "proof(induct l)"], ["proof (state)\ngoal (2 subgoals):\n 1. fold (\\<or>?) [] invalid = invalid\n 2. \\<And>a l.\n       fold (\\<or>?) l invalid = invalid \\<Longrightarrow>\n       fold (\\<or>?) (a # l) invalid = invalid", "case (Cons a l)"], ["proof (state)\nthis:\n  fold (\\<or>?) l invalid = invalid\n\ngoal (2 subgoals):\n 1. fold (\\<or>?) [] invalid = invalid\n 2. \\<And>a l.\n       fold (\\<or>?) l invalid = invalid \\<Longrightarrow>\n       fold (\\<or>?) (a # l) invalid = invalid", "then"], ["proof (chain)\npicking this:\n  fold (\\<or>?) l invalid = invalid", "show ?case"], ["proof (prove)\nusing this:\n  fold (\\<or>?) l invalid = invalid\n\ngoal (1 subgoal):\n 1. fold (\\<or>?) (a # l) invalid = invalid", "by (metis fold_simps(2) maybe_or_valid)"], ["proof (state)\nthis:\n  fold (\\<or>?) (a # l) invalid = invalid\n\ngoal (1 subgoal):\n 1. fold (\\<or>?) [] invalid = invalid", "qed auto"], ["", "lemma fold_maybe_or_true_base_never_false:\n  \"fold (\\<or>?) l true \\<noteq> false\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fold (\\<or>?) l true \\<noteq> false", "proof(induct l)"], ["proof (state)\ngoal (2 subgoals):\n 1. fold (\\<or>?) [] true \\<noteq> false\n 2. \\<And>a l.\n       fold (\\<or>?) l true \\<noteq> false \\<Longrightarrow>\n       fold (\\<or>?) (a # l) true \\<noteq> false", "case (Cons a l)"], ["proof (state)\nthis:\n  fold (\\<or>?) l true \\<noteq> false\n\ngoal (2 subgoals):\n 1. fold (\\<or>?) [] true \\<noteq> false\n 2. \\<And>a l.\n       fold (\\<or>?) l true \\<noteq> false \\<Longrightarrow>\n       fold (\\<or>?) (a # l) true \\<noteq> false", "then"], ["proof (chain)\npicking this:\n  fold (\\<or>?) l true \\<noteq> false", "show ?case"], ["proof (prove)\nusing this:\n  fold (\\<or>?) l true \\<noteq> false\n\ngoal (1 subgoal):\n 1. fold (\\<or>?) (a # l) true \\<noteq> false", "by (metis fold_maybe_or_invalid_base fold_simps(2) maybe_not.cases maybe_or_valid plus_trilean.simps(4) plus_trilean.simps(6))"], ["proof (state)\nthis:\n  fold (\\<or>?) (a # l) true \\<noteq> false\n\ngoal (1 subgoal):\n 1. fold (\\<or>?) [] true \\<noteq> false", "qed auto"], ["", "lemma fold_true_fold_false_not_invalid:\n  \"fold (\\<or>?) l true = true \\<Longrightarrow>\n   fold (\\<or>?) (rev l) false \\<noteq> invalid\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fold (\\<or>?) l true = true \\<Longrightarrow>\n    fold (\\<or>?) (rev l) false \\<noteq> invalid", "proof(induct l)"], ["proof (state)\ngoal (2 subgoals):\n 1. fold (\\<or>?) [] true = true \\<Longrightarrow>\n    fold (\\<or>?) (rev []) false \\<noteq> invalid\n 2. \\<And>a l.\n       \\<lbrakk>fold (\\<or>?) l true = true \\<Longrightarrow>\n                fold (\\<or>?) (rev l) false \\<noteq> invalid;\n        fold (\\<or>?) (a # l) true = true\\<rbrakk>\n       \\<Longrightarrow> fold (\\<or>?) (rev (a # l)) false \\<noteq> invalid", "case (Cons a l)"], ["proof (state)\nthis:\n  fold (\\<or>?) l true = true \\<Longrightarrow>\n  fold (\\<or>?) (rev l) false \\<noteq> invalid\n  fold (\\<or>?) (a # l) true = true\n\ngoal (2 subgoals):\n 1. fold (\\<or>?) [] true = true \\<Longrightarrow>\n    fold (\\<or>?) (rev []) false \\<noteq> invalid\n 2. \\<And>a l.\n       \\<lbrakk>fold (\\<or>?) l true = true \\<Longrightarrow>\n                fold (\\<or>?) (rev l) false \\<noteq> invalid;\n        fold (\\<or>?) (a # l) true = true\\<rbrakk>\n       \\<Longrightarrow> fold (\\<or>?) (rev (a # l)) false \\<noteq> invalid", "then"], ["proof (chain)\npicking this:\n  fold (\\<or>?) l true = true \\<Longrightarrow>\n  fold (\\<or>?) (rev l) false \\<noteq> invalid\n  fold (\\<or>?) (a # l) true = true", "show ?case"], ["proof (prove)\nusing this:\n  fold (\\<or>?) l true = true \\<Longrightarrow>\n  fold (\\<or>?) (rev l) false \\<noteq> invalid\n  fold (\\<or>?) (a # l) true = true\n\ngoal (1 subgoal):\n 1. fold (\\<or>?) (rev (a # l)) false \\<noteq> invalid", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>fold (\\<or>?) l true = true \\<Longrightarrow>\n             fold (\\<or>?) (rev l) false \\<noteq> invalid;\n     fold (\\<or>?) l (a \\<or>? true) = true\\<rbrakk>\n    \\<Longrightarrow> a \\<or>? fold (\\<or>?) (rev l) false \\<noteq> invalid", "by (metis fold_maybe_or_invalid_base maybe_or_invalid maybe_or_true)"], ["proof (state)\nthis:\n  fold (\\<or>?) (rev (a # l)) false \\<noteq> invalid\n\ngoal (1 subgoal):\n 1. fold (\\<or>?) [] true = true \\<Longrightarrow>\n    fold (\\<or>?) (rev []) false \\<noteq> invalid", "qed auto"], ["", "lemma fold_true_invalid_fold_rev_false_invalid:\n  \"fold (\\<or>?) l true = invalid \\<Longrightarrow>\n   fold (\\<or>?) (rev l) false = invalid\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fold (\\<or>?) l true = invalid \\<Longrightarrow>\n    fold (\\<or>?) (rev l) false = invalid", "proof(induct l)"], ["proof (state)\ngoal (2 subgoals):\n 1. fold (\\<or>?) [] true = invalid \\<Longrightarrow>\n    fold (\\<or>?) (rev []) false = invalid\n 2. \\<And>a l.\n       \\<lbrakk>fold (\\<or>?) l true = invalid \\<Longrightarrow>\n                fold (\\<or>?) (rev l) false = invalid;\n        fold (\\<or>?) (a # l) true = invalid\\<rbrakk>\n       \\<Longrightarrow> fold (\\<or>?) (rev (a # l)) false = invalid", "case (Cons a l)"], ["proof (state)\nthis:\n  fold (\\<or>?) l true = invalid \\<Longrightarrow>\n  fold (\\<or>?) (rev l) false = invalid\n  fold (\\<or>?) (a # l) true = invalid\n\ngoal (2 subgoals):\n 1. fold (\\<or>?) [] true = invalid \\<Longrightarrow>\n    fold (\\<or>?) (rev []) false = invalid\n 2. \\<And>a l.\n       \\<lbrakk>fold (\\<or>?) l true = invalid \\<Longrightarrow>\n                fold (\\<or>?) (rev l) false = invalid;\n        fold (\\<or>?) (a # l) true = invalid\\<rbrakk>\n       \\<Longrightarrow> fold (\\<or>?) (rev (a # l)) false = invalid", "then"], ["proof (chain)\npicking this:\n  fold (\\<or>?) l true = invalid \\<Longrightarrow>\n  fold (\\<or>?) (rev l) false = invalid\n  fold (\\<or>?) (a # l) true = invalid", "show ?case"], ["proof (prove)\nusing this:\n  fold (\\<or>?) l true = invalid \\<Longrightarrow>\n  fold (\\<or>?) (rev l) false = invalid\n  fold (\\<or>?) (a # l) true = invalid\n\ngoal (1 subgoal):\n 1. fold (\\<or>?) (rev (a # l)) false = invalid", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>fold (\\<or>?) l true = invalid \\<Longrightarrow>\n             fold (\\<or>?) (rev l) false = invalid;\n     fold (\\<or>?) l (a \\<or>? true) = invalid\\<rbrakk>\n    \\<Longrightarrow> a \\<or>? fold (\\<or>?) (rev l) false = invalid", "by (metis maybe_or_true maybe_or_valid)"], ["proof (state)\nthis:\n  fold (\\<or>?) (rev (a # l)) false = invalid\n\ngoal (1 subgoal):\n 1. fold (\\<or>?) [] true = invalid \\<Longrightarrow>\n    fold (\\<or>?) (rev []) false = invalid", "qed auto"], ["", "lemma fold_maybe_or_rev:\n  \"fold (\\<or>?) l b = fold (\\<or>?) (rev l) b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fold (\\<or>?) l b = fold (\\<or>?) (rev l) b", "proof(induct l)"], ["proof (state)\ngoal (2 subgoals):\n 1. fold (\\<or>?) [] b = fold (\\<or>?) (rev []) b\n 2. \\<And>a l.\n       fold (\\<or>?) l b = fold (\\<or>?) (rev l) b \\<Longrightarrow>\n       fold (\\<or>?) (a # l) b = fold (\\<or>?) (rev (a # l)) b", "case (Cons a l)"], ["proof (state)\nthis:\n  fold (\\<or>?) l b = fold (\\<or>?) (rev l) b\n\ngoal (2 subgoals):\n 1. fold (\\<or>?) [] b = fold (\\<or>?) (rev []) b\n 2. \\<And>a l.\n       fold (\\<or>?) l b = fold (\\<or>?) (rev l) b \\<Longrightarrow>\n       fold (\\<or>?) (a # l) b = fold (\\<or>?) (rev (a # l)) b", "then"], ["proof (chain)\npicking this:\n  fold (\\<or>?) l b = fold (\\<or>?) (rev l) b", "show ?case"], ["proof (prove)\nusing this:\n  fold (\\<or>?) l b = fold (\\<or>?) (rev l) b\n\ngoal (1 subgoal):\n 1. fold (\\<or>?) (a # l) b = fold (\\<or>?) (rev (a # l)) b", "proof(induction a b rule: plus_trilean.induct)"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>uu_.\n       fold (\\<or>?) l uu_ = fold (\\<or>?) (rev l) uu_ \\<Longrightarrow>\n       fold (\\<or>?) (invalid # l) uu_ =\n       fold (\\<or>?) (rev (invalid # l)) uu_\n 2. fold (\\<or>?) l invalid =\n    fold (\\<or>?) (rev l) invalid \\<Longrightarrow>\n    fold (\\<or>?) (true # l) invalid =\n    fold (\\<or>?) (rev (true # l)) invalid\n 3. fold (\\<or>?) l invalid =\n    fold (\\<or>?) (rev l) invalid \\<Longrightarrow>\n    fold (\\<or>?) (false # l) invalid =\n    fold (\\<or>?) (rev (false # l)) invalid\n 4. fold (\\<or>?) l true = fold (\\<or>?) (rev l) true \\<Longrightarrow>\n    fold (\\<or>?) (true # l) true = fold (\\<or>?) (rev (true # l)) true\n 5. fold (\\<or>?) l false = fold (\\<or>?) (rev l) false \\<Longrightarrow>\n    fold (\\<or>?) (true # l) false = fold (\\<or>?) (rev (true # l)) false\n 6. fold (\\<or>?) l true = fold (\\<or>?) (rev l) true \\<Longrightarrow>\n    fold (\\<or>?) (false # l) true = fold (\\<or>?) (rev (false # l)) true\n 7. fold (\\<or>?) l false = fold (\\<or>?) (rev l) false \\<Longrightarrow>\n    fold (\\<or>?) (false # l) false = fold (\\<or>?) (rev (false # l)) false", "case (1 uu)"], ["proof (state)\nthis:\n  fold (\\<or>?) l uu = fold (\\<or>?) (rev l) uu\n\ngoal (7 subgoals):\n 1. \\<And>uu_.\n       fold (\\<or>?) l uu_ = fold (\\<or>?) (rev l) uu_ \\<Longrightarrow>\n       fold (\\<or>?) (invalid # l) uu_ =\n       fold (\\<or>?) (rev (invalid # l)) uu_\n 2. fold (\\<or>?) l invalid =\n    fold (\\<or>?) (rev l) invalid \\<Longrightarrow>\n    fold (\\<or>?) (true # l) invalid =\n    fold (\\<or>?) (rev (true # l)) invalid\n 3. fold (\\<or>?) l invalid =\n    fold (\\<or>?) (rev l) invalid \\<Longrightarrow>\n    fold (\\<or>?) (false # l) invalid =\n    fold (\\<or>?) (rev (false # l)) invalid\n 4. fold (\\<or>?) l true = fold (\\<or>?) (rev l) true \\<Longrightarrow>\n    fold (\\<or>?) (true # l) true = fold (\\<or>?) (rev (true # l)) true\n 5. fold (\\<or>?) l false = fold (\\<or>?) (rev l) false \\<Longrightarrow>\n    fold (\\<or>?) (true # l) false = fold (\\<or>?) (rev (true # l)) false\n 6. fold (\\<or>?) l true = fold (\\<or>?) (rev l) true \\<Longrightarrow>\n    fold (\\<or>?) (false # l) true = fold (\\<or>?) (rev (false # l)) true\n 7. fold (\\<or>?) l false = fold (\\<or>?) (rev l) false \\<Longrightarrow>\n    fold (\\<or>?) (false # l) false = fold (\\<or>?) (rev (false # l)) false", "then"], ["proof (chain)\npicking this:\n  fold (\\<or>?) l uu = fold (\\<or>?) (rev l) uu", "show ?case"], ["proof (prove)\nusing this:\n  fold (\\<or>?) l uu = fold (\\<or>?) (rev l) uu\n\ngoal (1 subgoal):\n 1. fold (\\<or>?) (invalid # l) uu = fold (\\<or>?) (rev (invalid # l)) uu", "by (simp add: fold_maybe_or_invalid_base)"], ["proof (state)\nthis:\n  fold (\\<or>?) (invalid # l) uu = fold (\\<or>?) (rev (invalid # l)) uu\n\ngoal (6 subgoals):\n 1. fold (\\<or>?) l invalid =\n    fold (\\<or>?) (rev l) invalid \\<Longrightarrow>\n    fold (\\<or>?) (true # l) invalid =\n    fold (\\<or>?) (rev (true # l)) invalid\n 2. fold (\\<or>?) l invalid =\n    fold (\\<or>?) (rev l) invalid \\<Longrightarrow>\n    fold (\\<or>?) (false # l) invalid =\n    fold (\\<or>?) (rev (false # l)) invalid\n 3. fold (\\<or>?) l true = fold (\\<or>?) (rev l) true \\<Longrightarrow>\n    fold (\\<or>?) (true # l) true = fold (\\<or>?) (rev (true # l)) true\n 4. fold (\\<or>?) l false = fold (\\<or>?) (rev l) false \\<Longrightarrow>\n    fold (\\<or>?) (true # l) false = fold (\\<or>?) (rev (true # l)) false\n 5. fold (\\<or>?) l true = fold (\\<or>?) (rev l) true \\<Longrightarrow>\n    fold (\\<or>?) (false # l) true = fold (\\<or>?) (rev (false # l)) true\n 6. fold (\\<or>?) l false = fold (\\<or>?) (rev l) false \\<Longrightarrow>\n    fold (\\<or>?) (false # l) false = fold (\\<or>?) (rev (false # l)) false", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. fold (\\<or>?) l invalid =\n    fold (\\<or>?) (rev l) invalid \\<Longrightarrow>\n    fold (\\<or>?) (true # l) invalid =\n    fold (\\<or>?) (rev (true # l)) invalid\n 2. fold (\\<or>?) l invalid =\n    fold (\\<or>?) (rev l) invalid \\<Longrightarrow>\n    fold (\\<or>?) (false # l) invalid =\n    fold (\\<or>?) (rev (false # l)) invalid\n 3. fold (\\<or>?) l true = fold (\\<or>?) (rev l) true \\<Longrightarrow>\n    fold (\\<or>?) (true # l) true = fold (\\<or>?) (rev (true # l)) true\n 4. fold (\\<or>?) l false = fold (\\<or>?) (rev l) false \\<Longrightarrow>\n    fold (\\<or>?) (true # l) false = fold (\\<or>?) (rev (true # l)) false\n 5. fold (\\<or>?) l true = fold (\\<or>?) (rev l) true \\<Longrightarrow>\n    fold (\\<or>?) (false # l) true = fold (\\<or>?) (rev (false # l)) true\n 6. fold (\\<or>?) l false = fold (\\<or>?) (rev l) false \\<Longrightarrow>\n    fold (\\<or>?) (false # l) false = fold (\\<or>?) (rev (false # l)) false", "case \"2_1\""], ["proof (state)\nthis:\n  fold (\\<or>?) l invalid = fold (\\<or>?) (rev l) invalid\n\ngoal (6 subgoals):\n 1. fold (\\<or>?) l invalid =\n    fold (\\<or>?) (rev l) invalid \\<Longrightarrow>\n    fold (\\<or>?) (true # l) invalid =\n    fold (\\<or>?) (rev (true # l)) invalid\n 2. fold (\\<or>?) l invalid =\n    fold (\\<or>?) (rev l) invalid \\<Longrightarrow>\n    fold (\\<or>?) (false # l) invalid =\n    fold (\\<or>?) (rev (false # l)) invalid\n 3. fold (\\<or>?) l true = fold (\\<or>?) (rev l) true \\<Longrightarrow>\n    fold (\\<or>?) (true # l) true = fold (\\<or>?) (rev (true # l)) true\n 4. fold (\\<or>?) l false = fold (\\<or>?) (rev l) false \\<Longrightarrow>\n    fold (\\<or>?) (true # l) false = fold (\\<or>?) (rev (true # l)) false\n 5. fold (\\<or>?) l true = fold (\\<or>?) (rev l) true \\<Longrightarrow>\n    fold (\\<or>?) (false # l) true = fold (\\<or>?) (rev (false # l)) true\n 6. fold (\\<or>?) l false = fold (\\<or>?) (rev l) false \\<Longrightarrow>\n    fold (\\<or>?) (false # l) false = fold (\\<or>?) (rev (false # l)) false", "then"], ["proof (chain)\npicking this:\n  fold (\\<or>?) l invalid = fold (\\<or>?) (rev l) invalid", "show ?case"], ["proof (prove)\nusing this:\n  fold (\\<or>?) l invalid = fold (\\<or>?) (rev l) invalid\n\ngoal (1 subgoal):\n 1. fold (\\<or>?) (true # l) invalid =\n    fold (\\<or>?) (rev (true # l)) invalid", "by (simp add: fold_maybe_or_invalid_base)"], ["proof (state)\nthis:\n  fold (\\<or>?) (true # l) invalid = fold (\\<or>?) (rev (true # l)) invalid\n\ngoal (5 subgoals):\n 1. fold (\\<or>?) l invalid =\n    fold (\\<or>?) (rev l) invalid \\<Longrightarrow>\n    fold (\\<or>?) (false # l) invalid =\n    fold (\\<or>?) (rev (false # l)) invalid\n 2. fold (\\<or>?) l true = fold (\\<or>?) (rev l) true \\<Longrightarrow>\n    fold (\\<or>?) (true # l) true = fold (\\<or>?) (rev (true # l)) true\n 3. fold (\\<or>?) l false = fold (\\<or>?) (rev l) false \\<Longrightarrow>\n    fold (\\<or>?) (true # l) false = fold (\\<or>?) (rev (true # l)) false\n 4. fold (\\<or>?) l true = fold (\\<or>?) (rev l) true \\<Longrightarrow>\n    fold (\\<or>?) (false # l) true = fold (\\<or>?) (rev (false # l)) true\n 5. fold (\\<or>?) l false = fold (\\<or>?) (rev l) false \\<Longrightarrow>\n    fold (\\<or>?) (false # l) false = fold (\\<or>?) (rev (false # l)) false", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. fold (\\<or>?) l invalid =\n    fold (\\<or>?) (rev l) invalid \\<Longrightarrow>\n    fold (\\<or>?) (false # l) invalid =\n    fold (\\<or>?) (rev (false # l)) invalid\n 2. fold (\\<or>?) l true = fold (\\<or>?) (rev l) true \\<Longrightarrow>\n    fold (\\<or>?) (true # l) true = fold (\\<or>?) (rev (true # l)) true\n 3. fold (\\<or>?) l false = fold (\\<or>?) (rev l) false \\<Longrightarrow>\n    fold (\\<or>?) (true # l) false = fold (\\<or>?) (rev (true # l)) false\n 4. fold (\\<or>?) l true = fold (\\<or>?) (rev l) true \\<Longrightarrow>\n    fold (\\<or>?) (false # l) true = fold (\\<or>?) (rev (false # l)) true\n 5. fold (\\<or>?) l false = fold (\\<or>?) (rev l) false \\<Longrightarrow>\n    fold (\\<or>?) (false # l) false = fold (\\<or>?) (rev (false # l)) false", "case \"2_2\""], ["proof (state)\nthis:\n  fold (\\<or>?) l invalid = fold (\\<or>?) (rev l) invalid\n\ngoal (5 subgoals):\n 1. fold (\\<or>?) l invalid =\n    fold (\\<or>?) (rev l) invalid \\<Longrightarrow>\n    fold (\\<or>?) (false # l) invalid =\n    fold (\\<or>?) (rev (false # l)) invalid\n 2. fold (\\<or>?) l true = fold (\\<or>?) (rev l) true \\<Longrightarrow>\n    fold (\\<or>?) (true # l) true = fold (\\<or>?) (rev (true # l)) true\n 3. fold (\\<or>?) l false = fold (\\<or>?) (rev l) false \\<Longrightarrow>\n    fold (\\<or>?) (true # l) false = fold (\\<or>?) (rev (true # l)) false\n 4. fold (\\<or>?) l true = fold (\\<or>?) (rev l) true \\<Longrightarrow>\n    fold (\\<or>?) (false # l) true = fold (\\<or>?) (rev (false # l)) true\n 5. fold (\\<or>?) l false = fold (\\<or>?) (rev l) false \\<Longrightarrow>\n    fold (\\<or>?) (false # l) false = fold (\\<or>?) (rev (false # l)) false", "then"], ["proof (chain)\npicking this:\n  fold (\\<or>?) l invalid = fold (\\<or>?) (rev l) invalid", "show ?case"], ["proof (prove)\nusing this:\n  fold (\\<or>?) l invalid = fold (\\<or>?) (rev l) invalid\n\ngoal (1 subgoal):\n 1. fold (\\<or>?) (false # l) invalid =\n    fold (\\<or>?) (rev (false # l)) invalid", "by (simp add: fold_maybe_or_invalid_base)"], ["proof (state)\nthis:\n  fold (\\<or>?) (false # l) invalid =\n  fold (\\<or>?) (rev (false # l)) invalid\n\ngoal (4 subgoals):\n 1. fold (\\<or>?) l true = fold (\\<or>?) (rev l) true \\<Longrightarrow>\n    fold (\\<or>?) (true # l) true = fold (\\<or>?) (rev (true # l)) true\n 2. fold (\\<or>?) l false = fold (\\<or>?) (rev l) false \\<Longrightarrow>\n    fold (\\<or>?) (true # l) false = fold (\\<or>?) (rev (true # l)) false\n 3. fold (\\<or>?) l true = fold (\\<or>?) (rev l) true \\<Longrightarrow>\n    fold (\\<or>?) (false # l) true = fold (\\<or>?) (rev (false # l)) true\n 4. fold (\\<or>?) l false = fold (\\<or>?) (rev l) false \\<Longrightarrow>\n    fold (\\<or>?) (false # l) false = fold (\\<or>?) (rev (false # l)) false", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. fold (\\<or>?) l true = fold (\\<or>?) (rev l) true \\<Longrightarrow>\n    fold (\\<or>?) (true # l) true = fold (\\<or>?) (rev (true # l)) true\n 2. fold (\\<or>?) l false = fold (\\<or>?) (rev l) false \\<Longrightarrow>\n    fold (\\<or>?) (true # l) false = fold (\\<or>?) (rev (true # l)) false\n 3. fold (\\<or>?) l true = fold (\\<or>?) (rev l) true \\<Longrightarrow>\n    fold (\\<or>?) (false # l) true = fold (\\<or>?) (rev (false # l)) true\n 4. fold (\\<or>?) l false = fold (\\<or>?) (rev l) false \\<Longrightarrow>\n    fold (\\<or>?) (false # l) false = fold (\\<or>?) (rev (false # l)) false", "case \"3_1\""], ["proof (state)\nthis:\n  fold (\\<or>?) l true = fold (\\<or>?) (rev l) true\n\ngoal (4 subgoals):\n 1. fold (\\<or>?) l true = fold (\\<or>?) (rev l) true \\<Longrightarrow>\n    fold (\\<or>?) (true # l) true = fold (\\<or>?) (rev (true # l)) true\n 2. fold (\\<or>?) l false = fold (\\<or>?) (rev l) false \\<Longrightarrow>\n    fold (\\<or>?) (true # l) false = fold (\\<or>?) (rev (true # l)) false\n 3. fold (\\<or>?) l true = fold (\\<or>?) (rev l) true \\<Longrightarrow>\n    fold (\\<or>?) (false # l) true = fold (\\<or>?) (rev (false # l)) true\n 4. fold (\\<or>?) l false = fold (\\<or>?) (rev l) false \\<Longrightarrow>\n    fold (\\<or>?) (false # l) false = fold (\\<or>?) (rev (false # l)) false", "then"], ["proof (chain)\npicking this:\n  fold (\\<or>?) l true = fold (\\<or>?) (rev l) true", "show ?case"], ["proof (prove)\nusing this:\n  fold (\\<or>?) l true = fold (\\<or>?) (rev l) true\n\ngoal (1 subgoal):\n 1. fold (\\<or>?) (true # l) true = fold (\\<or>?) (rev (true # l)) true", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. fold (\\<or>?) l true = fold (\\<or>?) (rev l) true \\<Longrightarrow>\n    fold (\\<or>?) (rev l) true = true \\<or>? fold (\\<or>?) (rev l) true", "by (metis add.assoc fold_maybe_or_true_base_never_false maybe_not.cases maybe_or_idempotent maybe_or_true)"], ["proof (state)\nthis:\n  fold (\\<or>?) (true # l) true = fold (\\<or>?) (rev (true # l)) true\n\ngoal (3 subgoals):\n 1. fold (\\<or>?) l false = fold (\\<or>?) (rev l) false \\<Longrightarrow>\n    fold (\\<or>?) (true # l) false = fold (\\<or>?) (rev (true # l)) false\n 2. fold (\\<or>?) l true = fold (\\<or>?) (rev l) true \\<Longrightarrow>\n    fold (\\<or>?) (false # l) true = fold (\\<or>?) (rev (false # l)) true\n 3. fold (\\<or>?) l false = fold (\\<or>?) (rev l) false \\<Longrightarrow>\n    fold (\\<or>?) (false # l) false = fold (\\<or>?) (rev (false # l)) false", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. fold (\\<or>?) l false = fold (\\<or>?) (rev l) false \\<Longrightarrow>\n    fold (\\<or>?) (true # l) false = fold (\\<or>?) (rev (true # l)) false\n 2. fold (\\<or>?) l true = fold (\\<or>?) (rev l) true \\<Longrightarrow>\n    fold (\\<or>?) (false # l) true = fold (\\<or>?) (rev (false # l)) true\n 3. fold (\\<or>?) l false = fold (\\<or>?) (rev l) false \\<Longrightarrow>\n    fold (\\<or>?) (false # l) false = fold (\\<or>?) (rev (false # l)) false", "case \"3_2\""], ["proof (state)\nthis:\n  fold (\\<or>?) l false = fold (\\<or>?) (rev l) false\n\ngoal (3 subgoals):\n 1. fold (\\<or>?) l false = fold (\\<or>?) (rev l) false \\<Longrightarrow>\n    fold (\\<or>?) (true # l) false = fold (\\<or>?) (rev (true # l)) false\n 2. fold (\\<or>?) l true = fold (\\<or>?) (rev l) true \\<Longrightarrow>\n    fold (\\<or>?) (false # l) true = fold (\\<or>?) (rev (false # l)) true\n 3. fold (\\<or>?) l false = fold (\\<or>?) (rev l) false \\<Longrightarrow>\n    fold (\\<or>?) (false # l) false = fold (\\<or>?) (rev (false # l)) false", "then"], ["proof (chain)\npicking this:\n  fold (\\<or>?) l false = fold (\\<or>?) (rev l) false", "show ?case"], ["proof (prove)\nusing this:\n  fold (\\<or>?) l false = fold (\\<or>?) (rev l) false\n\ngoal (1 subgoal):\n 1. fold (\\<or>?) (true # l) false = fold (\\<or>?) (rev (true # l)) false", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. fold (\\<or>?) l false = fold (\\<or>?) (rev l) false \\<Longrightarrow>\n    fold (\\<or>?) l true = true \\<or>? fold (\\<or>?) (rev l) false", "apply (case_tac \"fold (\\<or>?) l true\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>fold (\\<or>?) l false = fold (\\<or>?) (rev l) false;\n     fold (\\<or>?) l true = true\\<rbrakk>\n    \\<Longrightarrow> fold (\\<or>?) l true =\n                      true \\<or>? fold (\\<or>?) (rev l) false\n 2. \\<lbrakk>fold (\\<or>?) l false = fold (\\<or>?) (rev l) false;\n     fold (\\<or>?) l true = false\\<rbrakk>\n    \\<Longrightarrow> fold (\\<or>?) l true =\n                      true \\<or>? fold (\\<or>?) (rev l) false\n 3. \\<lbrakk>fold (\\<or>?) l false = fold (\\<or>?) (rev l) false;\n     fold (\\<or>?) l true = invalid\\<rbrakk>\n    \\<Longrightarrow> fold (\\<or>?) l true =\n                      true \\<or>? fold (\\<or>?) (rev l) false", "apply (simp add: eq_commute[of true])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>fold (\\<or>?) l false = fold (\\<or>?) (rev l) false;\n     fold (\\<or>?) l true = true\\<rbrakk>\n    \\<Longrightarrow> true \\<or>? fold (\\<or>?) (rev l) false = true\n 2. \\<lbrakk>fold (\\<or>?) l false = fold (\\<or>?) (rev l) false;\n     fold (\\<or>?) l true = false\\<rbrakk>\n    \\<Longrightarrow> fold (\\<or>?) l true =\n                      true \\<or>? fold (\\<or>?) (rev l) false\n 3. \\<lbrakk>fold (\\<or>?) l false = fold (\\<or>?) (rev l) false;\n     fold (\\<or>?) l true = invalid\\<rbrakk>\n    \\<Longrightarrow> fold (\\<or>?) l true =\n                      true \\<or>? fold (\\<or>?) (rev l) false", "apply (case_tac \"fold (\\<or>?) (rev l) false\")"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>fold (\\<or>?) l false = fold (\\<or>?) (rev l) false;\n     fold (\\<or>?) l true = true;\n     fold (\\<or>?) (rev l) false = true\\<rbrakk>\n    \\<Longrightarrow> true \\<or>? fold (\\<or>?) (rev l) false = true\n 2. \\<lbrakk>fold (\\<or>?) l false = fold (\\<or>?) (rev l) false;\n     fold (\\<or>?) l true = true;\n     fold (\\<or>?) (rev l) false = false\\<rbrakk>\n    \\<Longrightarrow> true \\<or>? fold (\\<or>?) (rev l) false = true\n 3. \\<lbrakk>fold (\\<or>?) l false = fold (\\<or>?) (rev l) false;\n     fold (\\<or>?) l true = true;\n     fold (\\<or>?) (rev l) false = invalid\\<rbrakk>\n    \\<Longrightarrow> true \\<or>? fold (\\<or>?) (rev l) false = true\n 4. \\<lbrakk>fold (\\<or>?) l false = fold (\\<or>?) (rev l) false;\n     fold (\\<or>?) l true = false\\<rbrakk>\n    \\<Longrightarrow> fold (\\<or>?) l true =\n                      true \\<or>? fold (\\<or>?) (rev l) false\n 5. \\<lbrakk>fold (\\<or>?) l false = fold (\\<or>?) (rev l) false;\n     fold (\\<or>?) l true = invalid\\<rbrakk>\n    \\<Longrightarrow> fold (\\<or>?) l true =\n                      true \\<or>? fold (\\<or>?) (rev l) false", "apply simp"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>fold (\\<or>?) l false = fold (\\<or>?) (rev l) false;\n     fold (\\<or>?) l true = true;\n     fold (\\<or>?) (rev l) false = false\\<rbrakk>\n    \\<Longrightarrow> true \\<or>? fold (\\<or>?) (rev l) false = true\n 2. \\<lbrakk>fold (\\<or>?) l false = fold (\\<or>?) (rev l) false;\n     fold (\\<or>?) l true = true;\n     fold (\\<or>?) (rev l) false = invalid\\<rbrakk>\n    \\<Longrightarrow> true \\<or>? fold (\\<or>?) (rev l) false = true\n 3. \\<lbrakk>fold (\\<or>?) l false = fold (\\<or>?) (rev l) false;\n     fold (\\<or>?) l true = false\\<rbrakk>\n    \\<Longrightarrow> fold (\\<or>?) l true =\n                      true \\<or>? fold (\\<or>?) (rev l) false\n 4. \\<lbrakk>fold (\\<or>?) l false = fold (\\<or>?) (rev l) false;\n     fold (\\<or>?) l true = invalid\\<rbrakk>\n    \\<Longrightarrow> fold (\\<or>?) l true =\n                      true \\<or>? fold (\\<or>?) (rev l) false", "apply simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>fold (\\<or>?) l false = fold (\\<or>?) (rev l) false;\n     fold (\\<or>?) l true = true;\n     fold (\\<or>?) (rev l) false = invalid\\<rbrakk>\n    \\<Longrightarrow> true \\<or>? fold (\\<or>?) (rev l) false = true\n 2. \\<lbrakk>fold (\\<or>?) l false = fold (\\<or>?) (rev l) false;\n     fold (\\<or>?) l true = false\\<rbrakk>\n    \\<Longrightarrow> fold (\\<or>?) l true =\n                      true \\<or>? fold (\\<or>?) (rev l) false\n 3. \\<lbrakk>fold (\\<or>?) l false = fold (\\<or>?) (rev l) false;\n     fold (\\<or>?) l true = invalid\\<rbrakk>\n    \\<Longrightarrow> fold (\\<or>?) l true =\n                      true \\<or>? fold (\\<or>?) (rev l) false", "apply (simp add: fold_true_fold_false_not_invalid)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>fold (\\<or>?) l false = fold (\\<or>?) (rev l) false;\n     fold (\\<or>?) l true = false\\<rbrakk>\n    \\<Longrightarrow> fold (\\<or>?) l true =\n                      true \\<or>? fold (\\<or>?) (rev l) false\n 2. \\<lbrakk>fold (\\<or>?) l false = fold (\\<or>?) (rev l) false;\n     fold (\\<or>?) l true = invalid\\<rbrakk>\n    \\<Longrightarrow> fold (\\<or>?) l true =\n                      true \\<or>? fold (\\<or>?) (rev l) false", "apply (simp add: fold_maybe_or_true_base_never_false)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>fold (\\<or>?) l false = fold (\\<or>?) (rev l) false;\n     fold (\\<or>?) l true = invalid\\<rbrakk>\n    \\<Longrightarrow> fold (\\<or>?) l true =\n                      true \\<or>? fold (\\<or>?) (rev l) false", "by (simp add: fold_true_invalid_fold_rev_false_invalid)"], ["proof (state)\nthis:\n  fold (\\<or>?) (true # l) false = fold (\\<or>?) (rev (true # l)) false\n\ngoal (2 subgoals):\n 1. fold (\\<or>?) l true = fold (\\<or>?) (rev l) true \\<Longrightarrow>\n    fold (\\<or>?) (false # l) true = fold (\\<or>?) (rev (false # l)) true\n 2. fold (\\<or>?) l false = fold (\\<or>?) (rev l) false \\<Longrightarrow>\n    fold (\\<or>?) (false # l) false = fold (\\<or>?) (rev (false # l)) false", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. fold (\\<or>?) l true = fold (\\<or>?) (rev l) true \\<Longrightarrow>\n    fold (\\<or>?) (false # l) true = fold (\\<or>?) (rev (false # l)) true\n 2. fold (\\<or>?) l false = fold (\\<or>?) (rev l) false \\<Longrightarrow>\n    fold (\\<or>?) (false # l) false = fold (\\<or>?) (rev (false # l)) false", "case 4"], ["proof (state)\nthis:\n  fold (\\<or>?) l true = fold (\\<or>?) (rev l) true\n\ngoal (2 subgoals):\n 1. fold (\\<or>?) l true = fold (\\<or>?) (rev l) true \\<Longrightarrow>\n    fold (\\<or>?) (false # l) true = fold (\\<or>?) (rev (false # l)) true\n 2. fold (\\<or>?) l false = fold (\\<or>?) (rev l) false \\<Longrightarrow>\n    fold (\\<or>?) (false # l) false = fold (\\<or>?) (rev (false # l)) false", "then"], ["proof (chain)\npicking this:\n  fold (\\<or>?) l true = fold (\\<or>?) (rev l) true", "show ?case"], ["proof (prove)\nusing this:\n  fold (\\<or>?) l true = fold (\\<or>?) (rev l) true\n\ngoal (1 subgoal):\n 1. fold (\\<or>?) (false # l) true = fold (\\<or>?) (rev (false # l)) true", "by (simp add: maybe_or_zero)"], ["proof (state)\nthis:\n  fold (\\<or>?) (false # l) true = fold (\\<or>?) (rev (false # l)) true\n\ngoal (1 subgoal):\n 1. fold (\\<or>?) l false = fold (\\<or>?) (rev l) false \\<Longrightarrow>\n    fold (\\<or>?) (false # l) false = fold (\\<or>?) (rev (false # l)) false", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. fold (\\<or>?) l false = fold (\\<or>?) (rev l) false \\<Longrightarrow>\n    fold (\\<or>?) (false # l) false = fold (\\<or>?) (rev (false # l)) false", "case 5"], ["proof (state)\nthis:\n  fold (\\<or>?) l false = fold (\\<or>?) (rev l) false\n\ngoal (1 subgoal):\n 1. fold (\\<or>?) l false = fold (\\<or>?) (rev l) false \\<Longrightarrow>\n    fold (\\<or>?) (false # l) false = fold (\\<or>?) (rev (false # l)) false", "then"], ["proof (chain)\npicking this:\n  fold (\\<or>?) l false = fold (\\<or>?) (rev l) false", "show ?case"], ["proof (prove)\nusing this:\n  fold (\\<or>?) l false = fold (\\<or>?) (rev l) false\n\ngoal (1 subgoal):\n 1. fold (\\<or>?) (false # l) false = fold (\\<or>?) (rev (false # l)) false", "by (simp add: maybe_or_zero)"], ["proof (state)\nthis:\n  fold (\\<or>?) (false # l) false = fold (\\<or>?) (rev (false # l)) false\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  fold (\\<or>?) (a # l) b = fold (\\<or>?) (rev (a # l)) b\n\ngoal (1 subgoal):\n 1. fold (\\<or>?) [] b = fold (\\<or>?) (rev []) b", "qed auto"], ["", "lemma fold_maybe_or_cons:\n  \"fold (\\<or>?) (a#l) b = a \\<or>? (fold (\\<or>?) l b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fold (\\<or>?) (a # l) b = a \\<or>? fold (\\<or>?) l b", "by (metis fold_maybe_or_rev foldr.simps(2) foldr_conv_fold o_apply)"], ["", "lemma gval_fold_gOr_map:\n  \"gval (fold gOr l (Bc False)) s = fold (\\<or>?) (map (\\<lambda>g. gval g s) l) (false)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gval (fold gOr l (Bc False)) s =\n    fold (\\<or>?) (map (\\<lambda>g. gval g s) l) false", "proof(induct l)"], ["proof (state)\ngoal (2 subgoals):\n 1. gval (fold gOr [] (Bc False)) s =\n    fold (\\<or>?) (map (\\<lambda>g. gval g s) []) false\n 2. \\<And>a l.\n       gval (fold gOr l (Bc False)) s =\n       fold (\\<or>?) (map (\\<lambda>g. gval g s) l) false \\<Longrightarrow>\n       gval (fold gOr (a # l) (Bc False)) s =\n       fold (\\<or>?) (map (\\<lambda>g. gval g s) (a # l)) false", "case (Cons a l)"], ["proof (state)\nthis:\n  gval (fold gOr l (Bc False)) s =\n  fold (\\<or>?) (map (\\<lambda>g. gval g s) l) false\n\ngoal (2 subgoals):\n 1. gval (fold gOr [] (Bc False)) s =\n    fold (\\<or>?) (map (\\<lambda>g. gval g s) []) false\n 2. \\<And>a l.\n       gval (fold gOr l (Bc False)) s =\n       fold (\\<or>?) (map (\\<lambda>g. gval g s) l) false \\<Longrightarrow>\n       gval (fold gOr (a # l) (Bc False)) s =\n       fold (\\<or>?) (map (\\<lambda>g. gval g s) (a # l)) false", "then"], ["proof (chain)\npicking this:\n  gval (fold gOr l (Bc False)) s =\n  fold (\\<or>?) (map (\\<lambda>g. gval g s) l) false", "show ?case"], ["proof (prove)\nusing this:\n  gval (fold gOr l (Bc False)) s =\n  fold (\\<or>?) (map (\\<lambda>g. gval g s) l) false\n\ngoal (1 subgoal):\n 1. gval (fold gOr (a # l) (Bc False)) s =\n    fold (\\<or>?) (map (\\<lambda>g. gval g s) (a # l)) false", "by (metis fold_maybe_or_cons gval_fold_gOr list.simps(9))"], ["proof (state)\nthis:\n  gval (fold gOr (a # l) (Bc False)) s =\n  fold (\\<or>?) (map (\\<lambda>g. gval g s) (a # l)) false\n\ngoal (1 subgoal):\n 1. gval (fold gOr [] (Bc False)) s =\n    fold (\\<or>?) (map (\\<lambda>g. gval g s) []) false", "qed auto"], ["", "lemma gval_unfold_first:\n  \"gval (fold gOr (map (\\<lambda>x. Eq (V v) (L x)) ls) (Eq (V v) (L l))) s =\n       gval (fold gOr (map (\\<lambda>x. Eq (V v) (L x)) (l#ls)) (Bc False)) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gval (fold gOr (map (\\<lambda>x. Eq (V v) (L x)) ls) (Eq (V v) (L l)))\n     s =\n    gval (fold gOr (map (\\<lambda>x. Eq (V v) (L x)) (l # ls)) (Bc False)) s", "proof(induct ls)"], ["proof (state)\ngoal (2 subgoals):\n 1. gval (fold gOr (map (\\<lambda>x. Eq (V v) (L x)) []) (Eq (V v) (L l)))\n     s =\n    gval (fold gOr (map (\\<lambda>x. Eq (V v) (L x)) [l]) (Bc False)) s\n 2. \\<And>a ls.\n       gval\n        (fold gOr (map (\\<lambda>x. Eq (V v) (L x)) ls) (Eq (V v) (L l)))\n        s =\n       gval\n        (fold gOr (map (\\<lambda>x. Eq (V v) (L x)) (l # ls)) (Bc False))\n        s \\<Longrightarrow>\n       gval\n        (fold gOr (map (\\<lambda>x. Eq (V v) (L x)) (a # ls))\n          (Eq (V v) (L l)))\n        s =\n       gval\n        (fold gOr (map (\\<lambda>x. Eq (V v) (L x)) (l # a # ls))\n          (Bc False))\n        s", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. gval (fold gOr (map (\\<lambda>x. Eq (V v) (L x)) []) (Eq (V v) (L l)))\n     s =\n    gval (fold gOr (map (\\<lambda>x. Eq (V v) (L x)) [l]) (Bc False)) s\n 2. \\<And>a ls.\n       gval\n        (fold gOr (map (\\<lambda>x. Eq (V v) (L x)) ls) (Eq (V v) (L l)))\n        s =\n       gval\n        (fold gOr (map (\\<lambda>x. Eq (V v) (L x)) (l # ls)) (Bc False))\n        s \\<Longrightarrow>\n       gval\n        (fold gOr (map (\\<lambda>x. Eq (V v) (L x)) (a # ls))\n          (Eq (V v) (L l)))\n        s =\n       gval\n        (fold gOr (map (\\<lambda>x. Eq (V v) (L x)) (l # a # ls))\n          (Bc False))\n        s", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. gval (fold gOr (map (\\<lambda>x. Eq (V v) (L x)) []) (Eq (V v) (L l)))\n     s =\n    gval (fold gOr (map (\\<lambda>x. Eq (V v) (L x)) [l]) (Bc False)) s", "apply (cases \"s v\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. s v = None \\<Longrightarrow>\n    gval (fold gOr (map (\\<lambda>x. Eq (V v) (L x)) []) (Eq (V v) (L l)))\n     s =\n    gval (fold gOr (map (\\<lambda>x. Eq (V v) (L x)) [l]) (Bc False)) s\n 2. \\<And>a.\n       s v = Some a \\<Longrightarrow>\n       gval\n        (fold gOr (map (\\<lambda>x. Eq (V v) (L x)) []) (Eq (V v) (L l)))\n        s =\n       gval (fold gOr (map (\\<lambda>x. Eq (V v) (L x)) [l]) (Bc False)) s", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       s v = Some a \\<Longrightarrow>\n       gval\n        (fold gOr (map (\\<lambda>x. Eq (V v) (L x)) []) (Eq (V v) (L l)))\n        s =\n       gval (fold gOr (map (\\<lambda>x. Eq (V v) (L x)) [l]) (Bc False)) s", "by (simp add: gOr_def)"], ["proof (state)\nthis:\n  gval (fold gOr (map (\\<lambda>x. Eq (V v) (L x)) []) (Eq (V v) (L l))) s =\n  gval (fold gOr (map (\\<lambda>x. Eq (V v) (L x)) [l]) (Bc False)) s\n\ngoal (1 subgoal):\n 1. \\<And>a ls.\n       gval\n        (fold gOr (map (\\<lambda>x. Eq (V v) (L x)) ls) (Eq (V v) (L l)))\n        s =\n       gval\n        (fold gOr (map (\\<lambda>x. Eq (V v) (L x)) (l # ls)) (Bc False))\n        s \\<Longrightarrow>\n       gval\n        (fold gOr (map (\\<lambda>x. Eq (V v) (L x)) (a # ls))\n          (Eq (V v) (L l)))\n        s =\n       gval\n        (fold gOr (map (\\<lambda>x. Eq (V v) (L x)) (l # a # ls))\n          (Bc False))\n        s", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a ls.\n       gval\n        (fold gOr (map (\\<lambda>x. Eq (V v) (L x)) ls) (Eq (V v) (L l)))\n        s =\n       gval\n        (fold gOr (map (\\<lambda>x. Eq (V v) (L x)) (l # ls)) (Bc False))\n        s \\<Longrightarrow>\n       gval\n        (fold gOr (map (\\<lambda>x. Eq (V v) (L x)) (a # ls))\n          (Eq (V v) (L l)))\n        s =\n       gval\n        (fold gOr (map (\\<lambda>x. Eq (V v) (L x)) (l # a # ls))\n          (Bc False))\n        s", "case (Cons a ls)"], ["proof (state)\nthis:\n  gval (fold gOr (map (\\<lambda>x. Eq (V v) (L x)) ls) (Eq (V v) (L l))) s =\n  gval (fold gOr (map (\\<lambda>x. Eq (V v) (L x)) (l # ls)) (Bc False)) s\n\ngoal (1 subgoal):\n 1. \\<And>a ls.\n       gval\n        (fold gOr (map (\\<lambda>x. Eq (V v) (L x)) ls) (Eq (V v) (L l)))\n        s =\n       gval\n        (fold gOr (map (\\<lambda>x. Eq (V v) (L x)) (l # ls)) (Bc False))\n        s \\<Longrightarrow>\n       gval\n        (fold gOr (map (\\<lambda>x. Eq (V v) (L x)) (a # ls))\n          (Eq (V v) (L l)))\n        s =\n       gval\n        (fold gOr (map (\\<lambda>x. Eq (V v) (L x)) (l # a # ls))\n          (Bc False))\n        s", "then"], ["proof (chain)\npicking this:\n  gval (fold gOr (map (\\<lambda>x. Eq (V v) (L x)) ls) (Eq (V v) (L l))) s =\n  gval (fold gOr (map (\\<lambda>x. Eq (V v) (L x)) (l # ls)) (Bc False)) s", "show ?case"], ["proof (prove)\nusing this:\n  gval (fold gOr (map (\\<lambda>x. Eq (V v) (L x)) ls) (Eq (V v) (L l))) s =\n  gval (fold gOr (map (\\<lambda>x. Eq (V v) (L x)) (l # ls)) (Bc False)) s\n\ngoal (1 subgoal):\n 1. gval\n     (fold gOr (map (\\<lambda>x. Eq (V v) (L x)) (a # ls)) (Eq (V v) (L l)))\n     s =\n    gval\n     (fold gOr (map (\\<lambda>x. Eq (V v) (L x)) (l # a # ls)) (Bc False)) s", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. gval (fold gOr (map (\\<lambda>x. Eq (V v) (L x)) ls) (Eq (V v) (L l)))\n     s =\n    gval (fold gOr (map (\\<lambda>x. Eq (V v) (L x)) (l # ls)) (Bc False))\n     s \\<Longrightarrow>\n    gval\n     (fold gOr (map (\\<lambda>x. Eq (V v) (L x)) (a # ls)) (Eq (V v) (L l)))\n     s =\n    gval\n     (fold gOr (map (\\<lambda>x. Eq (V v) (L x)) (l # a # ls)) (Bc False)) s", "have \"gval (fold gOr (map (\\<lambda>va. Eq (V v) (L va)) ls) (gOr (Eq (V v) (L l)) (Bc False))) s = gval (fold gOr (map (\\<lambda>va. Eq (V v) (L va)) (l # ls)) (Bc False)) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gval\n     (fold gOr (map (\\<lambda>va. Eq (V v) (L va)) ls)\n       (gOr (Eq (V v) (L l)) (Bc False)))\n     s =\n    gval (fold gOr (map (\\<lambda>va. Eq (V v) (L va)) (l # ls)) (Bc False))\n     s", "by simp"], ["proof (state)\nthis:\n  gval\n   (fold gOr (map (\\<lambda>va. Eq (V v) (L va)) ls)\n     (gOr (Eq (V v) (L l)) (Bc False)))\n   s =\n  gval (fold gOr (map (\\<lambda>va. Eq (V v) (L va)) (l # ls)) (Bc False)) s\n\ngoal (1 subgoal):\n 1. gval (fold gOr (map (\\<lambda>x. Eq (V v) (L x)) ls) (Eq (V v) (L l)))\n     s =\n    gval (fold gOr (map (\\<lambda>x. Eq (V v) (L x)) (l # ls)) (Bc False))\n     s \\<Longrightarrow>\n    gval\n     (fold gOr (map (\\<lambda>x. Eq (V v) (L x)) (a # ls)) (Eq (V v) (L l)))\n     s =\n    gval\n     (fold gOr (map (\\<lambda>x. Eq (V v) (L x)) (l # a # ls)) (Bc False)) s", "then"], ["proof (chain)\npicking this:\n  gval\n   (fold gOr (map (\\<lambda>va. Eq (V v) (L va)) ls)\n     (gOr (Eq (V v) (L l)) (Bc False)))\n   s =\n  gval (fold gOr (map (\\<lambda>va. Eq (V v) (L va)) (l # ls)) (Bc False)) s", "have \"gval (fold gOr (map (\\<lambda>va. Eq (V v) (L va)) (a # ls)) (Eq (V v) (L l))) s = gval (fold gOr (Eq (V v) (L a) # map (\\<lambda>va. Eq (V v) (L va)) ls) (gOr (Eq (V v) (L l)) (Bc False))) s\""], ["proof (prove)\nusing this:\n  gval\n   (fold gOr (map (\\<lambda>va. Eq (V v) (L va)) ls)\n     (gOr (Eq (V v) (L l)) (Bc False)))\n   s =\n  gval (fold gOr (map (\\<lambda>va. Eq (V v) (L va)) (l # ls)) (Bc False)) s\n\ngoal (1 subgoal):\n 1. gval\n     (fold gOr (map (\\<lambda>va. Eq (V v) (L va)) (a # ls))\n       (Eq (V v) (L l)))\n     s =\n    gval\n     (fold gOr (Eq (V v) (L a) # map (\\<lambda>va. Eq (V v) (L va)) ls)\n       (gOr (Eq (V v) (L l)) (Bc False)))\n     s", "by (metis (no_types) Cons.hyps gval_fold_gOr list.simps(9))"], ["proof (state)\nthis:\n  gval\n   (fold gOr (map (\\<lambda>va. Eq (V v) (L va)) (a # ls)) (Eq (V v) (L l)))\n   s =\n  gval\n   (fold gOr (Eq (V v) (L a) # map (\\<lambda>va. Eq (V v) (L va)) ls)\n     (gOr (Eq (V v) (L l)) (Bc False)))\n   s\n\ngoal (1 subgoal):\n 1. gval (fold gOr (map (\\<lambda>x. Eq (V v) (L x)) ls) (Eq (V v) (L l)))\n     s =\n    gval (fold gOr (map (\\<lambda>x. Eq (V v) (L x)) (l # ls)) (Bc False))\n     s \\<Longrightarrow>\n    gval\n     (fold gOr (map (\\<lambda>x. Eq (V v) (L x)) (a # ls)) (Eq (V v) (L l)))\n     s =\n    gval\n     (fold gOr (map (\\<lambda>x. Eq (V v) (L x)) (l # a # ls)) (Bc False)) s", "then"], ["proof (chain)\npicking this:\n  gval\n   (fold gOr (map (\\<lambda>va. Eq (V v) (L va)) (a # ls)) (Eq (V v) (L l)))\n   s =\n  gval\n   (fold gOr (Eq (V v) (L a) # map (\\<lambda>va. Eq (V v) (L va)) ls)\n     (gOr (Eq (V v) (L l)) (Bc False)))\n   s", "show ?thesis"], ["proof (prove)\nusing this:\n  gval\n   (fold gOr (map (\\<lambda>va. Eq (V v) (L va)) (a # ls)) (Eq (V v) (L l)))\n   s =\n  gval\n   (fold gOr (Eq (V v) (L a) # map (\\<lambda>va. Eq (V v) (L va)) ls)\n     (gOr (Eq (V v) (L l)) (Bc False)))\n   s\n\ngoal (1 subgoal):\n 1. gval\n     (fold gOr (map (\\<lambda>x. Eq (V v) (L x)) (a # ls)) (Eq (V v) (L l)))\n     s =\n    gval\n     (fold gOr (map (\\<lambda>x. Eq (V v) (L x)) (l # a # ls)) (Bc False)) s", "by force"], ["proof (state)\nthis:\n  gval\n   (fold gOr (map (\\<lambda>x. Eq (V v) (L x)) (a # ls)) (Eq (V v) (L l)))\n   s =\n  gval (fold gOr (map (\\<lambda>x. Eq (V v) (L x)) (l # a # ls)) (Bc False))\n   s\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  gval\n   (fold gOr (map (\\<lambda>x. Eq (V v) (L x)) (a # ls)) (Eq (V v) (L l)))\n   s =\n  gval (fold gOr (map (\\<lambda>x. Eq (V v) (L x)) (l # a # ls)) (Bc False))\n   s\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma fold_Eq_true:\n  \"\\<forall>v. fold (\\<or>?) (map (\\<lambda>x. if v = x then true else false) vs) true = true\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>v.\n       fold (\\<or>?) (map (\\<lambda>x. if v = x then true else false) vs)\n        true =\n       true", "by(induct vs, auto)"], ["", "lemma x_in_set_fold_eq:\n  \"x \\<in> set ll \\<Longrightarrow>\n   fold (\\<or>?) (map (\\<lambda>xa. if x = xa then true else false) ll) false = true\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> set ll \\<Longrightarrow>\n    fold (\\<or>?) (map (\\<lambda>xa. if x = xa then true else false) ll)\n     false =\n    true", "proof(induct ll)"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<in> set [] \\<Longrightarrow>\n    fold (\\<or>?) (map (\\<lambda>xa. if x = xa then true else false) [])\n     false =\n    true\n 2. \\<And>a ll.\n       \\<lbrakk>x \\<in> set ll \\<Longrightarrow>\n                fold (\\<or>?)\n                 (map (\\<lambda>xa. if x = xa then true else false) ll)\n                 false =\n                true;\n        x \\<in> set (a # ll)\\<rbrakk>\n       \\<Longrightarrow> fold (\\<or>?)\n                          (map (\\<lambda>xa. if x = xa then true else false)\n                            (a # ll))\n                          false =\n                         true", "case (Cons a ll)"], ["proof (state)\nthis:\n  x \\<in> set ll \\<Longrightarrow>\n  fold (\\<or>?) (map (\\<lambda>xa. if x = xa then true else false) ll)\n   false =\n  true\n  x \\<in> set (a # ll)\n\ngoal (2 subgoals):\n 1. x \\<in> set [] \\<Longrightarrow>\n    fold (\\<or>?) (map (\\<lambda>xa. if x = xa then true else false) [])\n     false =\n    true\n 2. \\<And>a ll.\n       \\<lbrakk>x \\<in> set ll \\<Longrightarrow>\n                fold (\\<or>?)\n                 (map (\\<lambda>xa. if x = xa then true else false) ll)\n                 false =\n                true;\n        x \\<in> set (a # ll)\\<rbrakk>\n       \\<Longrightarrow> fold (\\<or>?)\n                          (map (\\<lambda>xa. if x = xa then true else false)\n                            (a # ll))\n                          false =\n                         true", "then"], ["proof (chain)\npicking this:\n  x \\<in> set ll \\<Longrightarrow>\n  fold (\\<or>?) (map (\\<lambda>xa. if x = xa then true else false) ll)\n   false =\n  true\n  x \\<in> set (a # ll)", "show ?case"], ["proof (prove)\nusing this:\n  x \\<in> set ll \\<Longrightarrow>\n  fold (\\<or>?) (map (\\<lambda>xa. if x = xa then true else false) ll)\n   false =\n  true\n  x \\<in> set (a # ll)\n\ngoal (1 subgoal):\n 1. fold (\\<or>?)\n     (map (\\<lambda>xa. if x = xa then true else false) (a # ll)) false =\n    true", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> set ll \\<Longrightarrow>\n             fold (\\<or>?)\n              (map (\\<lambda>xa. if x = xa then true else false) ll) false =\n             true;\n     x = a \\<or> x \\<in> set ll\\<rbrakk>\n    \\<Longrightarrow> (x = a \\<longrightarrow>\n                       fold (\\<or>?)\n                        (map (\\<lambda>xa. if a = xa then true else false)\n                          ll)\n                        true =\n                       true) \\<and>\n                      (x \\<noteq> a \\<longrightarrow>\n                       fold (\\<or>?)\n                        (map (\\<lambda>xa. if x = xa then true else false)\n                          ll)\n                        false =\n                       true)", "apply standard"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<in> set ll \\<Longrightarrow>\n             fold (\\<or>?)\n              (map (\\<lambda>xa. if x = xa then true else false) ll) false =\n             true;\n     x = a \\<or> x \\<in> set ll\\<rbrakk>\n    \\<Longrightarrow> x = a \\<longrightarrow>\n                      fold (\\<or>?)\n                       (map (\\<lambda>xa. if a = xa then true else false)\n                         ll)\n                       true =\n                      true\n 2. \\<lbrakk>x \\<in> set ll \\<Longrightarrow>\n             fold (\\<or>?)\n              (map (\\<lambda>xa. if x = xa then true else false) ll) false =\n             true;\n     x = a \\<or> x \\<in> set ll\\<rbrakk>\n    \\<Longrightarrow> x \\<noteq> a \\<longrightarrow>\n                      fold (\\<or>?)\n                       (map (\\<lambda>xa. if x = xa then true else false)\n                         ll)\n                       false =\n                      true", "apply (simp add: fold_Eq_true)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> set ll \\<Longrightarrow>\n             fold (\\<or>?)\n              (map (\\<lambda>xa. if x = xa then true else false) ll) false =\n             true;\n     x = a \\<or> x \\<in> set ll\\<rbrakk>\n    \\<Longrightarrow> x \\<noteq> a \\<longrightarrow>\n                      fold (\\<or>?)\n                       (map (\\<lambda>xa. if x = xa then true else false)\n                         ll)\n                       false =\n                      true", "by auto"], ["proof (state)\nthis:\n  fold (\\<or>?) (map (\\<lambda>xa. if x = xa then true else false) (a # ll))\n   false =\n  true\n\ngoal (1 subgoal):\n 1. x \\<in> set [] \\<Longrightarrow>\n    fold (\\<or>?) (map (\\<lambda>xa. if x = xa then true else false) [])\n     false =\n    true", "qed auto"], ["", "lemma x_not_in_set_fold_eq:\n  \"s v \\<notin> Some ` set ll \\<Longrightarrow>\n   false = fold (\\<or>?) (map (\\<lambda>x. if s v = Some x then true else false) ll) false\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s v \\<notin> Some ` set ll \\<Longrightarrow>\n    false =\n    fold (\\<or>?)\n     (map (\\<lambda>x. if s v = Some x then true else false) ll) false", "by(induct ll, auto)"], ["", "lemma gval_take: \"max_input g < Some a \\<Longrightarrow>\n   gval g (join_ir i r) = gval g (join_ir (take a i) r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. GExp.max_input g < Some a \\<Longrightarrow>\n    gval g (join_ir i r) = gval g (join_ir (take a i) r)", "proof(induct g)"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>x.\n       GExp.max_input (Bc x) < Some a \\<Longrightarrow>\n       gval (Bc x) (join_ir i r) = gval (Bc x) (join_ir (take a i) r)\n 2. \\<And>x1a x2.\n       GExp.max_input (Eq x1a x2) < Some a \\<Longrightarrow>\n       gval (Eq x1a x2) (join_ir i r) =\n       gval (Eq x1a x2) (join_ir (take a i) r)\n 3. \\<And>x1a x2.\n       GExp.max_input (Gt x1a x2) < Some a \\<Longrightarrow>\n       gval (Gt x1a x2) (join_ir i r) =\n       gval (Gt x1a x2) (join_ir (take a i) r)\n 4. \\<And>x1a x2.\n       GExp.max_input (In x1a x2) < Some a \\<Longrightarrow>\n       gval (In x1a x2) (join_ir i r) =\n       gval (In x1a x2) (join_ir (take a i) r)\n 5. \\<And>g1 g2.\n       \\<lbrakk>GExp.max_input g1 < Some a \\<Longrightarrow>\n                gval g1 (join_ir i r) = gval g1 (join_ir (take a i) r);\n        GExp.max_input g2 < Some a \\<Longrightarrow>\n        gval g2 (join_ir i r) = gval g2 (join_ir (take a i) r);\n        GExp.max_input (Nor g1 g2) < Some a\\<rbrakk>\n       \\<Longrightarrow> gval (Nor g1 g2) (join_ir i r) =\n                         gval (Nor g1 g2) (join_ir (take a i) r)", "case (Bc x)"], ["proof (state)\nthis:\n  GExp.max_input (Bc x) < Some a\n\ngoal (5 subgoals):\n 1. \\<And>x.\n       GExp.max_input (Bc x) < Some a \\<Longrightarrow>\n       gval (Bc x) (join_ir i r) = gval (Bc x) (join_ir (take a i) r)\n 2. \\<And>x1a x2.\n       GExp.max_input (Eq x1a x2) < Some a \\<Longrightarrow>\n       gval (Eq x1a x2) (join_ir i r) =\n       gval (Eq x1a x2) (join_ir (take a i) r)\n 3. \\<And>x1a x2.\n       GExp.max_input (Gt x1a x2) < Some a \\<Longrightarrow>\n       gval (Gt x1a x2) (join_ir i r) =\n       gval (Gt x1a x2) (join_ir (take a i) r)\n 4. \\<And>x1a x2.\n       GExp.max_input (In x1a x2) < Some a \\<Longrightarrow>\n       gval (In x1a x2) (join_ir i r) =\n       gval (In x1a x2) (join_ir (take a i) r)\n 5. \\<And>g1 g2.\n       \\<lbrakk>GExp.max_input g1 < Some a \\<Longrightarrow>\n                gval g1 (join_ir i r) = gval g1 (join_ir (take a i) r);\n        GExp.max_input g2 < Some a \\<Longrightarrow>\n        gval g2 (join_ir i r) = gval g2 (join_ir (take a i) r);\n        GExp.max_input (Nor g1 g2) < Some a\\<rbrakk>\n       \\<Longrightarrow> gval (Nor g1 g2) (join_ir i r) =\n                         gval (Nor g1 g2) (join_ir (take a i) r)", "then"], ["proof (chain)\npicking this:\n  GExp.max_input (Bc x) < Some a", "show ?case"], ["proof (prove)\nusing this:\n  GExp.max_input (Bc x) < Some a\n\ngoal (1 subgoal):\n 1. gval (Bc x) (join_ir i r) = gval (Bc x) (join_ir (take a i) r)", "by (metis (full_types) gval.simps(1) gval.simps(2))"], ["proof (state)\nthis:\n  gval (Bc x) (join_ir i r) = gval (Bc x) (join_ir (take a i) r)\n\ngoal (4 subgoals):\n 1. \\<And>x1a x2.\n       GExp.max_input (Eq x1a x2) < Some a \\<Longrightarrow>\n       gval (Eq x1a x2) (join_ir i r) =\n       gval (Eq x1a x2) (join_ir (take a i) r)\n 2. \\<And>x1a x2.\n       GExp.max_input (Gt x1a x2) < Some a \\<Longrightarrow>\n       gval (Gt x1a x2) (join_ir i r) =\n       gval (Gt x1a x2) (join_ir (take a i) r)\n 3. \\<And>x1a x2.\n       GExp.max_input (In x1a x2) < Some a \\<Longrightarrow>\n       gval (In x1a x2) (join_ir i r) =\n       gval (In x1a x2) (join_ir (take a i) r)\n 4. \\<And>g1 g2.\n       \\<lbrakk>GExp.max_input g1 < Some a \\<Longrightarrow>\n                gval g1 (join_ir i r) = gval g1 (join_ir (take a i) r);\n        GExp.max_input g2 < Some a \\<Longrightarrow>\n        gval g2 (join_ir i r) = gval g2 (join_ir (take a i) r);\n        GExp.max_input (Nor g1 g2) < Some a\\<rbrakk>\n       \\<Longrightarrow> gval (Nor g1 g2) (join_ir i r) =\n                         gval (Nor g1 g2) (join_ir (take a i) r)", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x1a x2.\n       GExp.max_input (Eq x1a x2) < Some a \\<Longrightarrow>\n       gval (Eq x1a x2) (join_ir i r) =\n       gval (Eq x1a x2) (join_ir (take a i) r)\n 2. \\<And>x1a x2.\n       GExp.max_input (Gt x1a x2) < Some a \\<Longrightarrow>\n       gval (Gt x1a x2) (join_ir i r) =\n       gval (Gt x1a x2) (join_ir (take a i) r)\n 3. \\<And>x1a x2.\n       GExp.max_input (In x1a x2) < Some a \\<Longrightarrow>\n       gval (In x1a x2) (join_ir i r) =\n       gval (In x1a x2) (join_ir (take a i) r)\n 4. \\<And>g1 g2.\n       \\<lbrakk>GExp.max_input g1 < Some a \\<Longrightarrow>\n                gval g1 (join_ir i r) = gval g1 (join_ir (take a i) r);\n        GExp.max_input g2 < Some a \\<Longrightarrow>\n        gval g2 (join_ir i r) = gval g2 (join_ir (take a i) r);\n        GExp.max_input (Nor g1 g2) < Some a\\<rbrakk>\n       \\<Longrightarrow> gval (Nor g1 g2) (join_ir i r) =\n                         gval (Nor g1 g2) (join_ir (take a i) r)", "case (Eq x1a x2)"], ["proof (state)\nthis:\n  GExp.max_input (Eq x1a x2) < Some a\n\ngoal (4 subgoals):\n 1. \\<And>x1a x2.\n       GExp.max_input (Eq x1a x2) < Some a \\<Longrightarrow>\n       gval (Eq x1a x2) (join_ir i r) =\n       gval (Eq x1a x2) (join_ir (take a i) r)\n 2. \\<And>x1a x2.\n       GExp.max_input (Gt x1a x2) < Some a \\<Longrightarrow>\n       gval (Gt x1a x2) (join_ir i r) =\n       gval (Gt x1a x2) (join_ir (take a i) r)\n 3. \\<And>x1a x2.\n       GExp.max_input (In x1a x2) < Some a \\<Longrightarrow>\n       gval (In x1a x2) (join_ir i r) =\n       gval (In x1a x2) (join_ir (take a i) r)\n 4. \\<And>g1 g2.\n       \\<lbrakk>GExp.max_input g1 < Some a \\<Longrightarrow>\n                gval g1 (join_ir i r) = gval g1 (join_ir (take a i) r);\n        GExp.max_input g2 < Some a \\<Longrightarrow>\n        gval g2 (join_ir i r) = gval g2 (join_ir (take a i) r);\n        GExp.max_input (Nor g1 g2) < Some a\\<rbrakk>\n       \\<Longrightarrow> gval (Nor g1 g2) (join_ir i r) =\n                         gval (Nor g1 g2) (join_ir (take a i) r)", "then"], ["proof (chain)\npicking this:\n  GExp.max_input (Eq x1a x2) < Some a", "show ?case"], ["proof (prove)\nusing this:\n  GExp.max_input (Eq x1a x2) < Some a\n\ngoal (1 subgoal):\n 1. gval (Eq x1a x2) (join_ir i r) = gval (Eq x1a x2) (join_ir (take a i) r)", "by (metis aval_take gval.simps(4) max_input_Eq max_less_iff_conj)"], ["proof (state)\nthis:\n  gval (Eq x1a x2) (join_ir i r) = gval (Eq x1a x2) (join_ir (take a i) r)\n\ngoal (3 subgoals):\n 1. \\<And>x1a x2.\n       GExp.max_input (Gt x1a x2) < Some a \\<Longrightarrow>\n       gval (Gt x1a x2) (join_ir i r) =\n       gval (Gt x1a x2) (join_ir (take a i) r)\n 2. \\<And>x1a x2.\n       GExp.max_input (In x1a x2) < Some a \\<Longrightarrow>\n       gval (In x1a x2) (join_ir i r) =\n       gval (In x1a x2) (join_ir (take a i) r)\n 3. \\<And>g1 g2.\n       \\<lbrakk>GExp.max_input g1 < Some a \\<Longrightarrow>\n                gval g1 (join_ir i r) = gval g1 (join_ir (take a i) r);\n        GExp.max_input g2 < Some a \\<Longrightarrow>\n        gval g2 (join_ir i r) = gval g2 (join_ir (take a i) r);\n        GExp.max_input (Nor g1 g2) < Some a\\<rbrakk>\n       \\<Longrightarrow> gval (Nor g1 g2) (join_ir i r) =\n                         gval (Nor g1 g2) (join_ir (take a i) r)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x1a x2.\n       GExp.max_input (Gt x1a x2) < Some a \\<Longrightarrow>\n       gval (Gt x1a x2) (join_ir i r) =\n       gval (Gt x1a x2) (join_ir (take a i) r)\n 2. \\<And>x1a x2.\n       GExp.max_input (In x1a x2) < Some a \\<Longrightarrow>\n       gval (In x1a x2) (join_ir i r) =\n       gval (In x1a x2) (join_ir (take a i) r)\n 3. \\<And>g1 g2.\n       \\<lbrakk>GExp.max_input g1 < Some a \\<Longrightarrow>\n                gval g1 (join_ir i r) = gval g1 (join_ir (take a i) r);\n        GExp.max_input g2 < Some a \\<Longrightarrow>\n        gval g2 (join_ir i r) = gval g2 (join_ir (take a i) r);\n        GExp.max_input (Nor g1 g2) < Some a\\<rbrakk>\n       \\<Longrightarrow> gval (Nor g1 g2) (join_ir i r) =\n                         gval (Nor g1 g2) (join_ir (take a i) r)", "case (Gt x1a x2)"], ["proof (state)\nthis:\n  GExp.max_input (Gt x1a x2) < Some a\n\ngoal (3 subgoals):\n 1. \\<And>x1a x2.\n       GExp.max_input (Gt x1a x2) < Some a \\<Longrightarrow>\n       gval (Gt x1a x2) (join_ir i r) =\n       gval (Gt x1a x2) (join_ir (take a i) r)\n 2. \\<And>x1a x2.\n       GExp.max_input (In x1a x2) < Some a \\<Longrightarrow>\n       gval (In x1a x2) (join_ir i r) =\n       gval (In x1a x2) (join_ir (take a i) r)\n 3. \\<And>g1 g2.\n       \\<lbrakk>GExp.max_input g1 < Some a \\<Longrightarrow>\n                gval g1 (join_ir i r) = gval g1 (join_ir (take a i) r);\n        GExp.max_input g2 < Some a \\<Longrightarrow>\n        gval g2 (join_ir i r) = gval g2 (join_ir (take a i) r);\n        GExp.max_input (Nor g1 g2) < Some a\\<rbrakk>\n       \\<Longrightarrow> gval (Nor g1 g2) (join_ir i r) =\n                         gval (Nor g1 g2) (join_ir (take a i) r)", "then"], ["proof (chain)\npicking this:\n  GExp.max_input (Gt x1a x2) < Some a", "show ?case"], ["proof (prove)\nusing this:\n  GExp.max_input (Gt x1a x2) < Some a\n\ngoal (1 subgoal):\n 1. gval (Gt x1a x2) (join_ir i r) = gval (Gt x1a x2) (join_ir (take a i) r)", "by (metis aval_take gval.simps(3) max_input_Gt max_less_iff_conj)"], ["proof (state)\nthis:\n  gval (Gt x1a x2) (join_ir i r) = gval (Gt x1a x2) (join_ir (take a i) r)\n\ngoal (2 subgoals):\n 1. \\<And>x1a x2.\n       GExp.max_input (In x1a x2) < Some a \\<Longrightarrow>\n       gval (In x1a x2) (join_ir i r) =\n       gval (In x1a x2) (join_ir (take a i) r)\n 2. \\<And>g1 g2.\n       \\<lbrakk>GExp.max_input g1 < Some a \\<Longrightarrow>\n                gval g1 (join_ir i r) = gval g1 (join_ir (take a i) r);\n        GExp.max_input g2 < Some a \\<Longrightarrow>\n        gval g2 (join_ir i r) = gval g2 (join_ir (take a i) r);\n        GExp.max_input (Nor g1 g2) < Some a\\<rbrakk>\n       \\<Longrightarrow> gval (Nor g1 g2) (join_ir i r) =\n                         gval (Nor g1 g2) (join_ir (take a i) r)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1a x2.\n       GExp.max_input (In x1a x2) < Some a \\<Longrightarrow>\n       gval (In x1a x2) (join_ir i r) =\n       gval (In x1a x2) (join_ir (take a i) r)\n 2. \\<And>g1 g2.\n       \\<lbrakk>GExp.max_input g1 < Some a \\<Longrightarrow>\n                gval g1 (join_ir i r) = gval g1 (join_ir (take a i) r);\n        GExp.max_input g2 < Some a \\<Longrightarrow>\n        gval g2 (join_ir i r) = gval g2 (join_ir (take a i) r);\n        GExp.max_input (Nor g1 g2) < Some a\\<rbrakk>\n       \\<Longrightarrow> gval (Nor g1 g2) (join_ir i r) =\n                         gval (Nor g1 g2) (join_ir (take a i) r)", "case (Nor g1 g2)"], ["proof (state)\nthis:\n  GExp.max_input g1 < Some a \\<Longrightarrow>\n  gval g1 (join_ir i r) = gval g1 (join_ir (take a i) r)\n  GExp.max_input g2 < Some a \\<Longrightarrow>\n  gval g2 (join_ir i r) = gval g2 (join_ir (take a i) r)\n  GExp.max_input (Nor g1 g2) < Some a\n\ngoal (2 subgoals):\n 1. \\<And>x1a x2.\n       GExp.max_input (In x1a x2) < Some a \\<Longrightarrow>\n       gval (In x1a x2) (join_ir i r) =\n       gval (In x1a x2) (join_ir (take a i) r)\n 2. \\<And>g1 g2.\n       \\<lbrakk>GExp.max_input g1 < Some a \\<Longrightarrow>\n                gval g1 (join_ir i r) = gval g1 (join_ir (take a i) r);\n        GExp.max_input g2 < Some a \\<Longrightarrow>\n        gval g2 (join_ir i r) = gval g2 (join_ir (take a i) r);\n        GExp.max_input (Nor g1 g2) < Some a\\<rbrakk>\n       \\<Longrightarrow> gval (Nor g1 g2) (join_ir i r) =\n                         gval (Nor g1 g2) (join_ir (take a i) r)", "then"], ["proof (chain)\npicking this:\n  GExp.max_input g1 < Some a \\<Longrightarrow>\n  gval g1 (join_ir i r) = gval g1 (join_ir (take a i) r)\n  GExp.max_input g2 < Some a \\<Longrightarrow>\n  gval g2 (join_ir i r) = gval g2 (join_ir (take a i) r)\n  GExp.max_input (Nor g1 g2) < Some a", "show ?case"], ["proof (prove)\nusing this:\n  GExp.max_input g1 < Some a \\<Longrightarrow>\n  gval g1 (join_ir i r) = gval g1 (join_ir (take a i) r)\n  GExp.max_input g2 < Some a \\<Longrightarrow>\n  gval g2 (join_ir i r) = gval g2 (join_ir (take a i) r)\n  GExp.max_input (Nor g1 g2) < Some a\n\ngoal (1 subgoal):\n 1. gval (Nor g1 g2) (join_ir i r) = gval (Nor g1 g2) (join_ir (take a i) r)", "by (simp add: maybe_not_eq gexp_max_input_Nor)"], ["proof (state)\nthis:\n  gval (Nor g1 g2) (join_ir i r) = gval (Nor g1 g2) (join_ir (take a i) r)\n\ngoal (1 subgoal):\n 1. \\<And>x1a x2.\n       GExp.max_input (In x1a x2) < Some a \\<Longrightarrow>\n       gval (In x1a x2) (join_ir i r) =\n       gval (In x1a x2) (join_ir (take a i) r)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1a x2.\n       GExp.max_input (In x1a x2) < Some a \\<Longrightarrow>\n       gval (In x1a x2) (join_ir i r) =\n       gval (In x1a x2) (join_ir (take a i) r)", "case (In v l)"], ["proof (state)\nthis:\n  GExp.max_input (In v l) < Some a\n\ngoal (1 subgoal):\n 1. \\<And>x1a x2.\n       GExp.max_input (In x1a x2) < Some a \\<Longrightarrow>\n       gval (In x1a x2) (join_ir i r) =\n       gval (In x1a x2) (join_ir (take a i) r)", "then"], ["proof (chain)\npicking this:\n  GExp.max_input (In v l) < Some a", "show ?case"], ["proof (prove)\nusing this:\n  GExp.max_input (In v l) < Some a\n\ngoal (1 subgoal):\n 1. gval (In v l) (join_ir i r) = gval (In v l) (join_ir (take a i) r)", "apply (simp add: gexp_max_input_In)"], ["proof (prove)\ngoal (1 subgoal):\n 1. AExp.max_input (V v) < Some a \\<Longrightarrow>\n    (case join_ir i r v of None \\<Rightarrow> invalid\n     | Some vv \\<Rightarrow> if vv \\<in> set l then true else false) =\n    (case join_ir (take a i) r v of None \\<Rightarrow> invalid\n     | Some vv \\<Rightarrow> if vv \\<in> set l then true else false)", "using aval_take"], ["proof (prove)\nusing this:\n  AExp.max_input ?x < Some ?a \\<Longrightarrow>\n  aval ?x (join_ir ?i ?r) = aval ?x (join_ir (take ?a ?i) ?r)\n\ngoal (1 subgoal):\n 1. AExp.max_input (V v) < Some a \\<Longrightarrow>\n    (case join_ir i r v of None \\<Rightarrow> invalid\n     | Some vv \\<Rightarrow> if vv \\<in> set l then true else false) =\n    (case join_ir (take a i) r v of None \\<Rightarrow> invalid\n     | Some vv \\<Rightarrow> if vv \\<in> set l then true else false)", "by fastforce"], ["proof (state)\nthis:\n  gval (In v l) (join_ir i r) = gval (In v l) (join_ir (take a i) r)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma gval_fold_gAnd_append_singleton:\n  \"gval (fold gAnd (a @ [G]) (Bc True)) s = gval (fold gAnd a (Bc True)) s \\<and>? gval G s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gval (fold gAnd (a @ [G]) (Bc True)) s =\n    gval (fold gAnd a (Bc True)) s \\<and>? gval G s", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. gval G s \\<and>? gval (fold gAnd a (Bc True)) s =\n    gval (fold gAnd a (Bc True)) s \\<and>? gval G s", "using times_trilean_commutative"], ["proof (prove)\nusing this:\n  ?a \\<and>? ?b = ?b \\<and>? ?a\n\ngoal (1 subgoal):\n 1. gval G s \\<and>? gval (fold gAnd a (Bc True)) s =\n    gval (fold gAnd a (Bc True)) s \\<and>? gval G s", "by blast"], ["", "lemma gval_fold_rev_true:\n  \"gval (fold gAnd (rev G) (Bc True)) s = true \\<Longrightarrow>\n   gval (fold gAnd G (Bc True)) s = true\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gval (fold gAnd (rev G) (Bc True)) s = true \\<Longrightarrow>\n    gval (fold gAnd G (Bc True)) s = true", "by (metis foldr_conv_fold gval_foldr_true rev_rev_ident set_rev)"], ["", "lemma gval_fold_not_invalid_all_valid_contra:\n  \"\\<exists>g \\<in> set G. gval g s = invalid \\<Longrightarrow>\n   gval (fold gAnd G (Bc True)) s = invalid\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>g\\<in>set G. gval g s = invalid \\<Longrightarrow>\n    gval (fold gAnd G (Bc True)) s = invalid", "proof(induct G rule: rev_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>g\\<in>set []. gval g s = invalid \\<Longrightarrow>\n    gval (fold gAnd [] (Bc True)) s = invalid\n 2. \\<And>x xs.\n       \\<lbrakk>\\<exists>g\\<in>set xs. gval g s = invalid \\<Longrightarrow>\n                gval (fold gAnd xs (Bc True)) s = invalid;\n        \\<exists>g\\<in>set (xs @ [x]). gval g s = invalid\\<rbrakk>\n       \\<Longrightarrow> gval (fold gAnd (xs @ [x]) (Bc True)) s = invalid", "case (snoc a G)"], ["proof (state)\nthis:\n  \\<exists>g\\<in>set G. gval g s = invalid \\<Longrightarrow>\n  gval (fold gAnd G (Bc True)) s = invalid\n  \\<exists>g\\<in>set (G @ [a]). gval g s = invalid\n\ngoal (2 subgoals):\n 1. \\<exists>g\\<in>set []. gval g s = invalid \\<Longrightarrow>\n    gval (fold gAnd [] (Bc True)) s = invalid\n 2. \\<And>x xs.\n       \\<lbrakk>\\<exists>g\\<in>set xs. gval g s = invalid \\<Longrightarrow>\n                gval (fold gAnd xs (Bc True)) s = invalid;\n        \\<exists>g\\<in>set (xs @ [x]). gval g s = invalid\\<rbrakk>\n       \\<Longrightarrow> gval (fold gAnd (xs @ [x]) (Bc True)) s = invalid", "then"], ["proof (chain)\npicking this:\n  \\<exists>g\\<in>set G. gval g s = invalid \\<Longrightarrow>\n  gval (fold gAnd G (Bc True)) s = invalid\n  \\<exists>g\\<in>set (G @ [a]). gval g s = invalid", "show ?case"], ["proof (prove)\nusing this:\n  \\<exists>g\\<in>set G. gval g s = invalid \\<Longrightarrow>\n  gval (fold gAnd G (Bc True)) s = invalid\n  \\<exists>g\\<in>set (G @ [a]). gval g s = invalid\n\ngoal (1 subgoal):\n 1. gval (fold gAnd (G @ [a]) (Bc True)) s = invalid", "apply (simp only: gval_fold_gAnd_append_singleton)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<exists>g\\<in>set G. gval g s = invalid \\<Longrightarrow>\n             gval (fold gAnd G (Bc True)) s = invalid;\n     \\<exists>g\\<in>set (G @ [a]). gval g s = invalid\\<rbrakk>\n    \\<Longrightarrow> gval (fold gAnd G (Bc True)) s \\<and>? gval a s =\n                      invalid", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<exists>g\\<in>set G. gval g s = invalid \\<Longrightarrow>\n             gval (fold gAnd G (Bc True)) s = invalid;\n     gval a s = invalid \\<or>\n     (\\<exists>g\\<in>set G. gval g s = invalid)\\<rbrakk>\n    \\<Longrightarrow> gval (fold gAnd G (Bc True)) s \\<and>? gval a s =\n                      invalid", "using maybe_and_valid"], ["proof (prove)\nusing this:\n  ?x \\<and>? ?y \\<noteq> invalid \\<Longrightarrow>\n  ?x \\<noteq> invalid \\<and> ?y \\<noteq> invalid\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<exists>g\\<in>set G. gval g s = invalid \\<Longrightarrow>\n             gval (fold gAnd G (Bc True)) s = invalid;\n     gval a s = invalid \\<or>\n     (\\<exists>g\\<in>set G. gval g s = invalid)\\<rbrakk>\n    \\<Longrightarrow> gval (fold gAnd G (Bc True)) s \\<and>? gval a s =\n                      invalid", "by blast"], ["proof (state)\nthis:\n  gval (fold gAnd (G @ [a]) (Bc True)) s = invalid\n\ngoal (1 subgoal):\n 1. \\<exists>g\\<in>set []. gval g s = invalid \\<Longrightarrow>\n    gval (fold gAnd [] (Bc True)) s = invalid", "qed auto"], ["", "lemma gval_fold_not_invalid_all_valid:\n  \"gval (fold gAnd G (Bc True)) s \\<noteq> invalid \\<Longrightarrow>\n   \\<forall>g \\<in> set G. gval g s \\<noteq> invalid\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gval (fold gAnd G (Bc True)) s \\<noteq> invalid \\<Longrightarrow>\n    \\<forall>g\\<in>set G. gval g s \\<noteq> invalid", "using gval_fold_not_invalid_all_valid_contra"], ["proof (prove)\nusing this:\n  \\<exists>g\\<in>set ?G. gval g ?s = invalid \\<Longrightarrow>\n  gval (fold gAnd ?G (Bc True)) ?s = invalid\n\ngoal (1 subgoal):\n 1. gval (fold gAnd G (Bc True)) s \\<noteq> invalid \\<Longrightarrow>\n    \\<forall>g\\<in>set G. gval g s \\<noteq> invalid", "by blast"], ["", "lemma all_gval_not_false:\n  \"(\\<forall>g \\<in> set G. gval g s \\<noteq> false) = (\\<forall>g \\<in> set G. gval g s = true) \\<or> (\\<exists>g \\<in> set G. gval g s = invalid)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>g\\<in>set G. gval g s \\<noteq> false) =\n    (\\<forall>g\\<in>set G. gval g s = true) \\<or>\n    (\\<exists>g\\<in>set G. gval g s = invalid)", "using trilean.exhaust"], ["proof (prove)\nusing this:\n  \\<lbrakk>?y = true \\<Longrightarrow> ?P; ?y = false \\<Longrightarrow> ?P;\n   ?y = invalid \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. (\\<forall>g\\<in>set G. gval g s \\<noteq> false) =\n    (\\<forall>g\\<in>set G. gval g s = true) \\<or>\n    (\\<exists>g\\<in>set G. gval g s = invalid)", "by auto"], ["", "lemma must_have_one_false_contra:\n  \"\\<forall>g \\<in> set G. gval g s \\<noteq> false \\<Longrightarrow>\n   gval (fold gAnd G (Bc True)) s \\<noteq> false\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>g\\<in>set G. gval g s \\<noteq> false \\<Longrightarrow>\n    gval (fold gAnd G (Bc True)) s \\<noteq> false", "using all_gval_not_false[of G s]"], ["proof (prove)\nusing this:\n  (\\<forall>g\\<in>set G. gval g s \\<noteq> false) =\n  (\\<forall>g\\<in>set G. gval g s = true) \\<or>\n  (\\<exists>g\\<in>set G. gval g s = invalid)\n\ngoal (1 subgoal):\n 1. \\<forall>g\\<in>set G. gval g s \\<noteq> false \\<Longrightarrow>\n    gval (fold gAnd G (Bc True)) s \\<noteq> false", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>g\\<in>set G. gval g s \\<noteq> false;\n     (\\<forall>g\\<in>set G. gval g s = true) \\<or>\n     (\\<exists>g\\<in>set G. gval g s = invalid)\\<rbrakk>\n    \\<Longrightarrow> gval (fold gAnd G (Bc True)) s \\<noteq> false", "apply (case_tac \"(\\<forall>g\\<in>set G. gval g s = true)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>g\\<in>set G. gval g s \\<noteq> false;\n     (\\<forall>g\\<in>set G. gval g s = true) \\<or>\n     (\\<exists>g\\<in>set G. gval g s = invalid);\n     \\<forall>g\\<in>set G. gval g s = true\\<rbrakk>\n    \\<Longrightarrow> gval (fold gAnd G (Bc True)) s \\<noteq> false\n 2. \\<lbrakk>\\<forall>g\\<in>set G. gval g s \\<noteq> false;\n     (\\<forall>g\\<in>set G. gval g s = true) \\<or>\n     (\\<exists>g\\<in>set G. gval g s = invalid);\n     \\<not> (\\<forall>g\\<in>set G. gval g s = true)\\<rbrakk>\n    \\<Longrightarrow> gval (fold gAnd G (Bc True)) s \\<noteq> false", "apply (metis (full_types) foldr_conv_fold gval_fold_rev_true gval_foldr_true not_true)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>g\\<in>set G. gval g s \\<noteq> false;\n     (\\<forall>g\\<in>set G. gval g s = true) \\<or>\n     (\\<exists>g\\<in>set G. gval g s = invalid);\n     \\<not> (\\<forall>g\\<in>set G. gval g s = true)\\<rbrakk>\n    \\<Longrightarrow> gval (fold gAnd G (Bc True)) s \\<noteq> false", "by (simp add: gval_fold_not_invalid_all_valid_contra)"], ["", "lemma must_have_one_false:\n  \"gval (fold gAnd G (Bc True)) s = false \\<Longrightarrow>\n   \\<exists>g \\<in> set G. gval g s = false\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gval (fold gAnd G (Bc True)) s = false \\<Longrightarrow>\n    \\<exists>g\\<in>set G. gval g s = false", "using must_have_one_false_contra"], ["proof (prove)\nusing this:\n  \\<forall>g\\<in>set ?G. gval g ?s \\<noteq> false \\<Longrightarrow>\n  gval (fold gAnd ?G (Bc True)) ?s \\<noteq> false\n\ngoal (1 subgoal):\n 1. gval (fold gAnd G (Bc True)) s = false \\<Longrightarrow>\n    \\<exists>g\\<in>set G. gval g s = false", "by blast"], ["", "lemma all_valid_fold:\n  \"\\<forall>g \\<in> set G. gval g s \\<noteq> invalid \\<Longrightarrow>\n   gval (fold gAnd G (Bc True)) s \\<noteq> invalid\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>g\\<in>set G. gval g s \\<noteq> invalid \\<Longrightarrow>\n    gval (fold gAnd G (Bc True)) s \\<noteq> invalid", "apply (induct G rule: rev_induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>g\\<in>set []. gval g s \\<noteq> invalid \\<Longrightarrow>\n    gval (fold gAnd [] (Bc True)) s \\<noteq> invalid\n 2. \\<And>x xs.\n       \\<lbrakk>\\<forall>g\\<in>set xs.\n                   gval g s \\<noteq> invalid \\<Longrightarrow>\n                gval (fold gAnd xs (Bc True)) s \\<noteq> invalid;\n        \\<forall>g\\<in>set (xs @ [x]). gval g s \\<noteq> invalid\\<rbrakk>\n       \\<Longrightarrow> gval (fold gAnd (xs @ [x]) (Bc True)) s \\<noteq>\n                         invalid", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<forall>g\\<in>set xs.\n                   gval g s \\<noteq> invalid \\<Longrightarrow>\n                gval (fold gAnd xs (Bc True)) s \\<noteq> invalid;\n        \\<forall>g\\<in>set (xs @ [x]). gval g s \\<noteq> invalid\\<rbrakk>\n       \\<Longrightarrow> gval (fold gAnd (xs @ [x]) (Bc True)) s \\<noteq>\n                         invalid", "by (simp add: maybe_and_invalid)"], ["", "lemma one_false_all_valid_false:\n  \"\\<exists>g\\<in>set G. gval g s = false \\<Longrightarrow>\n   \\<forall>g\\<in>set G. gval g s \\<noteq> invalid \\<Longrightarrow>\n   gval (fold gAnd G (Bc True)) s = false\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<exists>g\\<in>set G. gval g s = false;\n     \\<forall>g\\<in>set G. gval g s \\<noteq> invalid\\<rbrakk>\n    \\<Longrightarrow> gval (fold gAnd G (Bc True)) s = false", "by (metis (full_types) all_valid_fold foldr_conv_fold gval_foldr_true not_true rev_rev_ident set_rev)"], ["", "lemma gval_fold_rev_false:\n  \"gval (fold gAnd (rev G) (Bc True)) s = false \\<Longrightarrow>\n   gval (fold gAnd G (Bc True)) s = false\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gval (fold gAnd (rev G) (Bc True)) s = false \\<Longrightarrow>\n    gval (fold gAnd G (Bc True)) s = false", "using must_have_one_false[of \"rev G\" s]\n        gval_fold_not_invalid_all_valid[of \"rev G\" s]"], ["proof (prove)\nusing this:\n  gval (fold gAnd (rev G) (Bc True)) s = false \\<Longrightarrow>\n  \\<exists>g\\<in>set (rev G). gval g s = false\n  gval (fold gAnd (rev G) (Bc True)) s \\<noteq> invalid \\<Longrightarrow>\n  \\<forall>g\\<in>set (rev G). gval g s \\<noteq> invalid\n\ngoal (1 subgoal):\n 1. gval (fold gAnd (rev G) (Bc True)) s = false \\<Longrightarrow>\n    gval (fold gAnd G (Bc True)) s = false", "by (simp add: one_false_all_valid_false)"], ["", "lemma fold_invalid_means_one_invalid:\n  \"gval (fold gAnd G (Bc True)) s = invalid \\<Longrightarrow>\n   \\<exists>g \\<in> set G. gval g s = invalid\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gval (fold gAnd G (Bc True)) s = invalid \\<Longrightarrow>\n    \\<exists>g\\<in>set G. gval g s = invalid", "using all_valid_fold"], ["proof (prove)\nusing this:\n  \\<forall>g\\<in>set ?G. gval g ?s \\<noteq> invalid \\<Longrightarrow>\n  gval (fold gAnd ?G (Bc True)) ?s \\<noteq> invalid\n\ngoal (1 subgoal):\n 1. gval (fold gAnd G (Bc True)) s = invalid \\<Longrightarrow>\n    \\<exists>g\\<in>set G. gval g s = invalid", "by blast"], ["", "lemma gval_fold_rev_invalid:\n  \"gval (fold gAnd (rev G) (Bc True)) s = invalid \\<Longrightarrow>\n   gval (fold gAnd G (Bc True)) s = invalid\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gval (fold gAnd (rev G) (Bc True)) s = invalid \\<Longrightarrow>\n    gval (fold gAnd G (Bc True)) s = invalid", "using fold_invalid_means_one_invalid[of \"rev G\" s]"], ["proof (prove)\nusing this:\n  gval (fold gAnd (rev G) (Bc True)) s = invalid \\<Longrightarrow>\n  \\<exists>g\\<in>set (rev G). gval g s = invalid\n\ngoal (1 subgoal):\n 1. gval (fold gAnd (rev G) (Bc True)) s = invalid \\<Longrightarrow>\n    gval (fold gAnd G (Bc True)) s = invalid", "by (simp add: gval_fold_not_invalid_all_valid_contra)"], ["", "lemma gval_fold_rev_equiv_fold:\n  \"gval (fold gAnd (rev G) (Bc True)) s =  gval (fold gAnd G (Bc True)) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gval (fold gAnd (rev G) (Bc True)) s = gval (fold gAnd G (Bc True)) s", "apply (cases \"gval (fold gAnd (rev G) (Bc True)) s\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. gval (fold gAnd (rev G) (Bc True)) s = true \\<Longrightarrow>\n    gval (fold gAnd (rev G) (Bc True)) s = gval (fold gAnd G (Bc True)) s\n 2. gval (fold gAnd (rev G) (Bc True)) s = false \\<Longrightarrow>\n    gval (fold gAnd (rev G) (Bc True)) s = gval (fold gAnd G (Bc True)) s\n 3. gval (fold gAnd (rev G) (Bc True)) s = invalid \\<Longrightarrow>\n    gval (fold gAnd (rev G) (Bc True)) s = gval (fold gAnd G (Bc True)) s", "apply (simp add: gval_fold_rev_true)"], ["proof (prove)\ngoal (2 subgoals):\n 1. gval (fold gAnd (rev G) (Bc True)) s = false \\<Longrightarrow>\n    gval (fold gAnd (rev G) (Bc True)) s = gval (fold gAnd G (Bc True)) s\n 2. gval (fold gAnd (rev G) (Bc True)) s = invalid \\<Longrightarrow>\n    gval (fold gAnd (rev G) (Bc True)) s = gval (fold gAnd G (Bc True)) s", "apply (simp add: gval_fold_rev_false)"], ["proof (prove)\ngoal (1 subgoal):\n 1. gval (fold gAnd (rev G) (Bc True)) s = invalid \\<Longrightarrow>\n    gval (fold gAnd (rev G) (Bc True)) s = gval (fold gAnd G (Bc True)) s", "by (simp add: gval_fold_rev_invalid)"], ["", "lemma gval_fold_equiv_fold_rev:\n  \"gval (fold gAnd G (Bc True)) s = gval (fold gAnd (rev G) (Bc True)) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gval (fold gAnd G (Bc True)) s = gval (fold gAnd (rev G) (Bc True)) s", "by (simp add: gval_fold_rev_equiv_fold)"], ["", "lemma gval_fold_equiv_gval_foldr:\n  \"gval (fold gAnd G (Bc True)) s = gval (foldr gAnd G (Bc True)) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gval (fold gAnd G (Bc True)) s = gval (foldr gAnd G (Bc True)) s", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. gval (fold gAnd G (Bc True)) s = gval (foldr gAnd G (Bc True)) s", "have \"gval (fold gAnd G (Bc True)) s = gval (fold gAnd (rev G) (Bc True)) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gval (fold gAnd G (Bc True)) s = gval (fold gAnd (rev G) (Bc True)) s", "using gval_fold_equiv_fold_rev"], ["proof (prove)\nusing this:\n  gval (fold gAnd ?G (Bc True)) ?s = gval (fold gAnd (rev ?G) (Bc True)) ?s\n\ngoal (1 subgoal):\n 1. gval (fold gAnd G (Bc True)) s = gval (fold gAnd (rev G) (Bc True)) s", "by force"], ["proof (state)\nthis:\n  gval (fold gAnd G (Bc True)) s = gval (fold gAnd (rev G) (Bc True)) s\n\ngoal (1 subgoal):\n 1. gval (fold gAnd G (Bc True)) s = gval (foldr gAnd G (Bc True)) s", "then"], ["proof (chain)\npicking this:\n  gval (fold gAnd G (Bc True)) s = gval (fold gAnd (rev G) (Bc True)) s", "show ?thesis"], ["proof (prove)\nusing this:\n  gval (fold gAnd G (Bc True)) s = gval (fold gAnd (rev G) (Bc True)) s\n\ngoal (1 subgoal):\n 1. gval (fold gAnd G (Bc True)) s = gval (foldr gAnd G (Bc True)) s", "by (simp add: foldr_conv_fold)"], ["proof (state)\nthis:\n  gval (fold gAnd G (Bc True)) s = gval (foldr gAnd G (Bc True)) s\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma gval_foldr_equiv_gval_fold:\n  \"gval (foldr gAnd G (Bc True)) s = gval (fold gAnd G (Bc True)) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gval (foldr gAnd G (Bc True)) s = gval (fold gAnd G (Bc True)) s", "by (simp add: gval_fold_equiv_gval_foldr)"], ["", "lemma gval_fold_cons:\n  \"gval (fold gAnd (g # gs) (Bc True)) s = gval g s \\<and>? gval (fold gAnd gs (Bc True)) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gval (fold gAnd (g # gs) (Bc True)) s =\n    gval g s \\<and>? gval (fold gAnd gs (Bc True)) s", "apply (simp only: apply_guards_fold gval_fold_equiv_gval_foldr)"], ["proof (prove)\ngoal (1 subgoal):\n 1. gval (foldr gAnd (g # gs) (Bc True)) s =\n    gval g s \\<and>? gval (foldr gAnd gs (Bc True)) s", "by (simp only: foldr.simps comp_def gval_gAnd)"], ["", "lemma gval_fold_take: \"max_input_list G < Some a \\<Longrightarrow>\n   a \\<le> length i \\<Longrightarrow>\n   max_input_list G \\<le> Some (length i) \\<Longrightarrow>\n   gval (fold gAnd G (Bc True)) (join_ir i r) = gval (fold gAnd G (Bc True)) (join_ir (take a i) r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>max_input_list G < Some a; a \\<le> length i;\n     max_input_list G \\<le> Some (length i)\\<rbrakk>\n    \\<Longrightarrow> gval (fold gAnd G (Bc True)) (join_ir i r) =\n                      gval (fold gAnd G (Bc True)) (join_ir (take a i) r)", "proof(induct G)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>max_input_list [] < Some a; a \\<le> length i;\n     max_input_list [] \\<le> Some (length i)\\<rbrakk>\n    \\<Longrightarrow> gval (fold gAnd [] (Bc True)) (join_ir i r) =\n                      gval (fold gAnd [] (Bc True)) (join_ir (take a i) r)\n 2. \\<And>aa G.\n       \\<lbrakk>\\<lbrakk>max_input_list G < Some a; a \\<le> length i;\n                 max_input_list G \\<le> Some (length i)\\<rbrakk>\n                \\<Longrightarrow> gval (fold gAnd G (Bc True))\n                                   (join_ir i r) =\n                                  gval (fold gAnd G (Bc True))\n                                   (join_ir (take a i) r);\n        max_input_list (aa # G) < Some a; a \\<le> length i;\n        max_input_list (aa # G) \\<le> Some (length i)\\<rbrakk>\n       \\<Longrightarrow> gval (fold gAnd (aa # G) (Bc True)) (join_ir i r) =\n                         gval (fold gAnd (aa # G) (Bc True))\n                          (join_ir (take a i) r)", "case (Cons g gs)"], ["proof (state)\nthis:\n  \\<lbrakk>max_input_list gs < Some a; a \\<le> length i;\n   max_input_list gs \\<le> Some (length i)\\<rbrakk>\n  \\<Longrightarrow> gval (fold gAnd gs (Bc True)) (join_ir i r) =\n                    gval (fold gAnd gs (Bc True)) (join_ir (take a i) r)\n  max_input_list (g # gs) < Some a\n  a \\<le> length i\n  max_input_list (g # gs) \\<le> Some (length i)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>max_input_list [] < Some a; a \\<le> length i;\n     max_input_list [] \\<le> Some (length i)\\<rbrakk>\n    \\<Longrightarrow> gval (fold gAnd [] (Bc True)) (join_ir i r) =\n                      gval (fold gAnd [] (Bc True)) (join_ir (take a i) r)\n 2. \\<And>aa G.\n       \\<lbrakk>\\<lbrakk>max_input_list G < Some a; a \\<le> length i;\n                 max_input_list G \\<le> Some (length i)\\<rbrakk>\n                \\<Longrightarrow> gval (fold gAnd G (Bc True))\n                                   (join_ir i r) =\n                                  gval (fold gAnd G (Bc True))\n                                   (join_ir (take a i) r);\n        max_input_list (aa # G) < Some a; a \\<le> length i;\n        max_input_list (aa # G) \\<le> Some (length i)\\<rbrakk>\n       \\<Longrightarrow> gval (fold gAnd (aa # G) (Bc True)) (join_ir i r) =\n                         gval (fold gAnd (aa # G) (Bc True))\n                          (join_ir (take a i) r)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>max_input_list gs < Some a; a \\<le> length i;\n   max_input_list gs \\<le> Some (length i)\\<rbrakk>\n  \\<Longrightarrow> gval (fold gAnd gs (Bc True)) (join_ir i r) =\n                    gval (fold gAnd gs (Bc True)) (join_ir (take a i) r)\n  max_input_list (g # gs) < Some a\n  a \\<le> length i\n  max_input_list (g # gs) \\<le> Some (length i)", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>max_input_list gs < Some a; a \\<le> length i;\n   max_input_list gs \\<le> Some (length i)\\<rbrakk>\n  \\<Longrightarrow> gval (fold gAnd gs (Bc True)) (join_ir i r) =\n                    gval (fold gAnd gs (Bc True)) (join_ir (take a i) r)\n  max_input_list (g # gs) < Some a\n  a \\<le> length i\n  max_input_list (g # gs) \\<le> Some (length i)\n\ngoal (1 subgoal):\n 1. gval (fold gAnd (g # gs) (Bc True)) (join_ir i r) =\n    gval (fold gAnd (g # gs) (Bc True)) (join_ir (take a i) r)", "apply (simp only: gval_fold_cons)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>max_input_list gs < Some a; True;\n              max_input_list gs \\<le> Some (length i)\\<rbrakk>\n             \\<Longrightarrow> gval (fold gAnd gs (Bc True)) (join_ir i r) =\n                               gval (fold gAnd gs (Bc True))\n                                (join_ir (take a i) r);\n     max_input_list (g # gs) < Some a; a \\<le> length i;\n     max_input_list (g # gs) \\<le> Some (length i)\\<rbrakk>\n    \\<Longrightarrow> gval g (join_ir i r) \\<and>?\n                      gval (fold gAnd gs (Bc True)) (join_ir i r) =\n                      gval g (join_ir (take a i) r) \\<and>?\n                      gval (fold gAnd gs (Bc True)) (join_ir (take a i) r)", "apply (simp add: max_input_list_cons)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>gval (fold gAnd gs (Bc True)) (join_ir i r) =\n             gval (fold gAnd gs (Bc True)) (join_ir (take a i) r);\n     GExp.max_input g < Some a \\<and> max_input_list gs < Some a;\n     a \\<le> length i;\n     GExp.max_input g \\<le> Some (length i) \\<and>\n     max_input_list gs \\<le> Some (length i)\\<rbrakk>\n    \\<Longrightarrow> gval g (join_ir i r) \\<and>?\n                      gval (fold gAnd gs (Bc True)) (join_ir (take a i) r) =\n                      gval g (join_ir (take a i) r) \\<and>?\n                      gval (fold gAnd gs (Bc True)) (join_ir (take a i) r)", "using gval_take[of g a i r]"], ["proof (prove)\nusing this:\n  GExp.max_input g < Some a \\<Longrightarrow>\n  gval g (join_ir i r) = gval g (join_ir (take a i) r)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>gval (fold gAnd gs (Bc True)) (join_ir i r) =\n             gval (fold gAnd gs (Bc True)) (join_ir (take a i) r);\n     GExp.max_input g < Some a \\<and> max_input_list gs < Some a;\n     a \\<le> length i;\n     GExp.max_input g \\<le> Some (length i) \\<and>\n     max_input_list gs \\<le> Some (length i)\\<rbrakk>\n    \\<Longrightarrow> gval g (join_ir i r) \\<and>?\n                      gval (fold gAnd gs (Bc True)) (join_ir (take a i) r) =\n                      gval g (join_ir (take a i) r) \\<and>?\n                      gval (fold gAnd gs (Bc True)) (join_ir (take a i) r)", "by simp"], ["proof (state)\nthis:\n  gval (fold gAnd (g # gs) (Bc True)) (join_ir i r) =\n  gval (fold gAnd (g # gs) (Bc True)) (join_ir (take a i) r)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>max_input_list [] < Some a; a \\<le> length i;\n     max_input_list [] \\<le> Some (length i)\\<rbrakk>\n    \\<Longrightarrow> gval (fold gAnd [] (Bc True)) (join_ir i r) =\n                      gval (fold gAnd [] (Bc True)) (join_ir (take a i) r)", "qed auto"], ["", "primrec padding :: \"nat \\<Rightarrow> 'a list\" where\n  \"padding 0 = []\" |\n  \"padding (Suc m) = (Eps (\\<lambda>x. True))#(padding m)\""], ["", "definition take_or_pad :: \"'a list \\<Rightarrow> nat \\<Rightarrow> 'a list\" where\n  \"take_or_pad a n = (if length a \\<ge> n then take n a else a@(padding (n-length a)))\""], ["", "lemma length_padding: \"length (padding n) = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (padding n) = n", "by (induct n, auto)"], ["", "lemma length_take_or_pad: \"length (take_or_pad a n) = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (take_or_pad a n) = n", "proof(induct n)"], ["proof (state)\ngoal (2 subgoals):\n 1. length (take_or_pad a 0) = 0\n 2. \\<And>n.\n       length (take_or_pad a n) = n \\<Longrightarrow>\n       length (take_or_pad a (Suc n)) = Suc n", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. length (take_or_pad a 0) = 0\n 2. \\<And>n.\n       length (take_or_pad a n) = n \\<Longrightarrow>\n       length (take_or_pad a (Suc n)) = Suc n", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (take_or_pad a 0) = 0", "by (simp add: take_or_pad_def)"], ["proof (state)\nthis:\n  length (take_or_pad a 0) = 0\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       length (take_or_pad a n) = n \\<Longrightarrow>\n       length (take_or_pad a (Suc n)) = Suc n", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       length (take_or_pad a n) = n \\<Longrightarrow>\n       length (take_or_pad a (Suc n)) = Suc n", "case (Suc n)"], ["proof (state)\nthis:\n  length (take_or_pad a n) = n\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       length (take_or_pad a n) = n \\<Longrightarrow>\n       length (take_or_pad a (Suc n)) = Suc n", "then"], ["proof (chain)\npicking this:\n  length (take_or_pad a n) = n", "show ?case"], ["proof (prove)\nusing this:\n  length (take_or_pad a n) = n\n\ngoal (1 subgoal):\n 1. length (take_or_pad a (Suc n)) = Suc n", "apply (simp add: take_or_pad_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. length\n     (if n \\<le> length a then take n a else a @ padding (n - length a)) =\n    n \\<Longrightarrow>\n    (Suc n \\<le> length a \\<longrightarrow>\n     min (length a) (Suc n) = Suc n) \\<and>\n    (\\<not> Suc n \\<le> length a \\<longrightarrow>\n     length a + length (padding (Suc n - length a)) = Suc n)", "apply standard"], ["proof (prove)\ngoal (2 subgoals):\n 1. length\n     (if n \\<le> length a then take n a else a @ padding (n - length a)) =\n    n \\<Longrightarrow>\n    Suc n \\<le> length a \\<longrightarrow> min (length a) (Suc n) = Suc n\n 2. length\n     (if n \\<le> length a then take n a else a @ padding (n - length a)) =\n    n \\<Longrightarrow>\n    \\<not> Suc n \\<le> length a \\<longrightarrow>\n    length a + length (padding (Suc n - length a)) = Suc n", "apply auto[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. length\n     (if n \\<le> length a then take n a else a @ padding (n - length a)) =\n    n \\<Longrightarrow>\n    \\<not> Suc n \\<le> length a \\<longrightarrow>\n    length a + length (padding (Suc n - length a)) = Suc n", "by (simp add: length_padding)"], ["proof (state)\nthis:\n  length (take_or_pad a (Suc n)) = Suc n\n\ngoal:\nNo subgoals!", "qed"], ["", "fun enumerate_gexp_strings :: \"'a gexp \\<Rightarrow> String.literal set\" where\n  \"enumerate_gexp_strings (Bc _) = {}\" |\n  \"enumerate_gexp_strings (Eq a1 a2) = enumerate_aexp_strings a1 \\<union> enumerate_aexp_strings a2\" |\n  \"enumerate_gexp_strings (Gt a1 a2) = enumerate_aexp_strings a1 \\<union> enumerate_aexp_strings a2\" |\n  \"enumerate_gexp_strings (In v l) = fold (\\<lambda>x acc. case x of Num n \\<Rightarrow> acc | Str s \\<Rightarrow> insert s acc) l {}\" |\n  \"enumerate_gexp_strings (Nor g1 g2) = enumerate_gexp_strings g1 \\<union> enumerate_gexp_strings g2\""], ["", "fun enumerate_gexp_ints :: \"'a gexp \\<Rightarrow> int set\" where\n  \"enumerate_gexp_ints (Bc _) = {}\" |\n  \"enumerate_gexp_ints (Eq a1 a2) = enumerate_aexp_ints a1 \\<union> enumerate_aexp_ints a2\" |\n  \"enumerate_gexp_ints (Gt a1 a2) = enumerate_aexp_ints a1 \\<union> enumerate_aexp_ints a2\" |\n  \"enumerate_gexp_ints (In v l) = fold (\\<lambda>x acc. case x of Str s \\<Rightarrow> acc | Num n \\<Rightarrow> insert n acc) l {}\" |\n  \"enumerate_gexp_ints (Nor g1 g2) = enumerate_gexp_ints g1 \\<union> enumerate_gexp_ints g2\""], ["", "definition restricted_once :: \"'a \\<Rightarrow> 'a gexp list \\<Rightarrow> bool\" where\n  \"restricted_once v G = (length (filter (\\<lambda>g. gexp_constrains g (V v)) G) = 1)\""], ["", "definition not_restricted :: \"'a \\<Rightarrow> 'a gexp list \\<Rightarrow> bool\" where\n  \"not_restricted v G = (length (filter (\\<lambda>g. gexp_constrains g (V v)) G) = 0)\""], ["", "lemma restricted_once_cons:\n  \"restricted_once v (g#gs) = ((gexp_constrains g (V v) \\<and> not_restricted v gs) \\<or> ((\\<not> gexp_constrains g (V v)) \\<and> restricted_once v gs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. restricted_once v (g # gs) =\n    (gexp_constrains g (V v) \\<and> not_restricted v gs \\<or>\n     \\<not> gexp_constrains g (V v) \\<and> restricted_once v gs)", "by (simp add: restricted_once_def not_restricted_def)"], ["", "lemma not_restricted_cons:\n  \"not_restricted v (g#gs) = ((\\<not> gexp_constrains g (V v)) \\<and> not_restricted v gs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. not_restricted v (g # gs) =\n    (\\<not> gexp_constrains g (V v) \\<and> not_restricted v gs)", "by (simp add: not_restricted_def)"], ["", "definition enumerate_vars :: \"vname gexp \\<Rightarrow> vname list\" where\n  \"enumerate_vars g = sorted_list_of_set ((image R (enumerate_regs g)) \\<union> (image I (enumerate_gexp_inputs g)))\""], ["", "fun rename_regs :: \"(nat \\<Rightarrow> nat) \\<Rightarrow> vname gexp \\<Rightarrow> vname gexp\" where\n  \"rename_regs _ (Bc b) = Bc b\" |\n  \"rename_regs f (Eq a1 a2) = Eq (AExp.rename_regs f a1) (AExp.rename_regs f a2)\" |\n  \"rename_regs f (Gt a1 a2) = Gt (AExp.rename_regs f a1) (AExp.rename_regs f a2)\" |\n  \"rename_regs f (In (R r) vs) = In (R (f r)) vs\" |\n  \"rename_regs f (In v vs) = In v vs\" |\n  \"rename_regs f (Nor g1 g2) = Nor (rename_regs f g1) (rename_regs f g2)\""], ["", "definition eq_upto_rename :: \"vname gexp \\<Rightarrow> vname gexp \\<Rightarrow> bool\" where\n  \"eq_upto_rename g1 g2 = (\\<exists>f. bij f \\<and> rename_regs f g1 = g2)\""], ["", "lemma gval_reg_some_superset:\n\"\\<forall>a. (r $ a  \\<noteq> None) \\<longrightarrow> r $ a = r' $ a \\<Longrightarrow>\n  x \\<noteq> invalid \\<Longrightarrow>\n gval a (join_ir i r) = x \\<Longrightarrow>\n gval a (join_ir i r') = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>a.\n                r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n     x \\<noteq> invalid; gval a (join_ir i r) = x\\<rbrakk>\n    \\<Longrightarrow> gval a (join_ir i r') = x", "proof(induct a arbitrary: x)"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>x xa.\n       \\<lbrakk>\\<forall>a.\n                   r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n        xa \\<noteq> invalid; gval (Bc x) (join_ir i r) = xa\\<rbrakk>\n       \\<Longrightarrow> gval (Bc x) (join_ir i r') = xa\n 2. \\<And>x1a x2 x.\n       \\<lbrakk>\\<forall>a.\n                   r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n        x \\<noteq> invalid; gval (Eq x1a x2) (join_ir i r) = x\\<rbrakk>\n       \\<Longrightarrow> gval (Eq x1a x2) (join_ir i r') = x\n 3. \\<And>x1a x2 x.\n       \\<lbrakk>\\<forall>a.\n                   r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n        x \\<noteq> invalid; gval (Gt x1a x2) (join_ir i r) = x\\<rbrakk>\n       \\<Longrightarrow> gval (Gt x1a x2) (join_ir i r') = x\n 4. \\<And>x1a x2 x.\n       \\<lbrakk>\\<forall>a.\n                   r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n        x \\<noteq> invalid; gval (In x1a x2) (join_ir i r) = x\\<rbrakk>\n       \\<Longrightarrow> gval (In x1a x2) (join_ir i r') = x\n 5. \\<And>a1 a2 x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>\\<forall>a.\n                               r $ a \\<noteq> None \\<longrightarrow>\n                               r $ a = r' $ a;\n                    x \\<noteq> invalid; gval a1 (join_ir i r) = x\\<rbrakk>\n                   \\<Longrightarrow> gval a1 (join_ir i r') = x;\n        \\<And>x.\n           \\<lbrakk>\\<forall>a.\n                       r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n            x \\<noteq> invalid; gval a2 (join_ir i r) = x\\<rbrakk>\n           \\<Longrightarrow> gval a2 (join_ir i r') = x;\n        \\<forall>a. r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n        x \\<noteq> invalid; gval (Nor a1 a2) (join_ir i r) = x\\<rbrakk>\n       \\<Longrightarrow> gval (Nor a1 a2) (join_ir i r') = x", "case (Bc b)"], ["proof (state)\nthis:\n  \\<forall>a. r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a\n  x \\<noteq> invalid\n  gval (Bc b) (join_ir i r) = x\n\ngoal (5 subgoals):\n 1. \\<And>x xa.\n       \\<lbrakk>\\<forall>a.\n                   r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n        xa \\<noteq> invalid; gval (Bc x) (join_ir i r) = xa\\<rbrakk>\n       \\<Longrightarrow> gval (Bc x) (join_ir i r') = xa\n 2. \\<And>x1a x2 x.\n       \\<lbrakk>\\<forall>a.\n                   r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n        x \\<noteq> invalid; gval (Eq x1a x2) (join_ir i r) = x\\<rbrakk>\n       \\<Longrightarrow> gval (Eq x1a x2) (join_ir i r') = x\n 3. \\<And>x1a x2 x.\n       \\<lbrakk>\\<forall>a.\n                   r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n        x \\<noteq> invalid; gval (Gt x1a x2) (join_ir i r) = x\\<rbrakk>\n       \\<Longrightarrow> gval (Gt x1a x2) (join_ir i r') = x\n 4. \\<And>x1a x2 x.\n       \\<lbrakk>\\<forall>a.\n                   r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n        x \\<noteq> invalid; gval (In x1a x2) (join_ir i r) = x\\<rbrakk>\n       \\<Longrightarrow> gval (In x1a x2) (join_ir i r') = x\n 5. \\<And>a1 a2 x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>\\<forall>a.\n                               r $ a \\<noteq> None \\<longrightarrow>\n                               r $ a = r' $ a;\n                    x \\<noteq> invalid; gval a1 (join_ir i r) = x\\<rbrakk>\n                   \\<Longrightarrow> gval a1 (join_ir i r') = x;\n        \\<And>x.\n           \\<lbrakk>\\<forall>a.\n                       r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n            x \\<noteq> invalid; gval a2 (join_ir i r) = x\\<rbrakk>\n           \\<Longrightarrow> gval a2 (join_ir i r') = x;\n        \\<forall>a. r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n        x \\<noteq> invalid; gval (Nor a1 a2) (join_ir i r) = x\\<rbrakk>\n       \\<Longrightarrow> gval (Nor a1 a2) (join_ir i r') = x", "then"], ["proof (chain)\npicking this:\n  \\<forall>a. r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a\n  x \\<noteq> invalid\n  gval (Bc b) (join_ir i r) = x", "show ?case"], ["proof (prove)\nusing this:\n  \\<forall>a. r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a\n  x \\<noteq> invalid\n  gval (Bc b) (join_ir i r) = x\n\ngoal (1 subgoal):\n 1. gval (Bc b) (join_ir i r') = x", "by (cases b, auto)"], ["proof (state)\nthis:\n  gval (Bc b) (join_ir i r') = x\n\ngoal (4 subgoals):\n 1. \\<And>x1a x2 x.\n       \\<lbrakk>\\<forall>a.\n                   r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n        x \\<noteq> invalid; gval (Eq x1a x2) (join_ir i r) = x\\<rbrakk>\n       \\<Longrightarrow> gval (Eq x1a x2) (join_ir i r') = x\n 2. \\<And>x1a x2 x.\n       \\<lbrakk>\\<forall>a.\n                   r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n        x \\<noteq> invalid; gval (Gt x1a x2) (join_ir i r) = x\\<rbrakk>\n       \\<Longrightarrow> gval (Gt x1a x2) (join_ir i r') = x\n 3. \\<And>x1a x2 x.\n       \\<lbrakk>\\<forall>a.\n                   r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n        x \\<noteq> invalid; gval (In x1a x2) (join_ir i r) = x\\<rbrakk>\n       \\<Longrightarrow> gval (In x1a x2) (join_ir i r') = x\n 4. \\<And>a1 a2 x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>\\<forall>a.\n                               r $ a \\<noteq> None \\<longrightarrow>\n                               r $ a = r' $ a;\n                    x \\<noteq> invalid; gval a1 (join_ir i r) = x\\<rbrakk>\n                   \\<Longrightarrow> gval a1 (join_ir i r') = x;\n        \\<And>x.\n           \\<lbrakk>\\<forall>a.\n                       r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n            x \\<noteq> invalid; gval a2 (join_ir i r) = x\\<rbrakk>\n           \\<Longrightarrow> gval a2 (join_ir i r') = x;\n        \\<forall>a. r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n        x \\<noteq> invalid; gval (Nor a1 a2) (join_ir i r) = x\\<rbrakk>\n       \\<Longrightarrow> gval (Nor a1 a2) (join_ir i r') = x", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x1a x2 x.\n       \\<lbrakk>\\<forall>a.\n                   r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n        x \\<noteq> invalid; gval (Eq x1a x2) (join_ir i r) = x\\<rbrakk>\n       \\<Longrightarrow> gval (Eq x1a x2) (join_ir i r') = x\n 2. \\<And>x1a x2 x.\n       \\<lbrakk>\\<forall>a.\n                   r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n        x \\<noteq> invalid; gval (Gt x1a x2) (join_ir i r) = x\\<rbrakk>\n       \\<Longrightarrow> gval (Gt x1a x2) (join_ir i r') = x\n 3. \\<And>x1a x2 x.\n       \\<lbrakk>\\<forall>a.\n                   r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n        x \\<noteq> invalid; gval (In x1a x2) (join_ir i r) = x\\<rbrakk>\n       \\<Longrightarrow> gval (In x1a x2) (join_ir i r') = x\n 4. \\<And>a1 a2 x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>\\<forall>a.\n                               r $ a \\<noteq> None \\<longrightarrow>\n                               r $ a = r' $ a;\n                    x \\<noteq> invalid; gval a1 (join_ir i r) = x\\<rbrakk>\n                   \\<Longrightarrow> gval a1 (join_ir i r') = x;\n        \\<And>x.\n           \\<lbrakk>\\<forall>a.\n                       r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n            x \\<noteq> invalid; gval a2 (join_ir i r) = x\\<rbrakk>\n           \\<Longrightarrow> gval a2 (join_ir i r') = x;\n        \\<forall>a. r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n        x \\<noteq> invalid; gval (Nor a1 a2) (join_ir i r) = x\\<rbrakk>\n       \\<Longrightarrow> gval (Nor a1 a2) (join_ir i r') = x", "case (Eq x1a x2)"], ["proof (state)\nthis:\n  \\<forall>a. r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a\n  x \\<noteq> invalid\n  gval (Eq x1a x2) (join_ir i r) = x\n\ngoal (4 subgoals):\n 1. \\<And>x1a x2 x.\n       \\<lbrakk>\\<forall>a.\n                   r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n        x \\<noteq> invalid; gval (Eq x1a x2) (join_ir i r) = x\\<rbrakk>\n       \\<Longrightarrow> gval (Eq x1a x2) (join_ir i r') = x\n 2. \\<And>x1a x2 x.\n       \\<lbrakk>\\<forall>a.\n                   r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n        x \\<noteq> invalid; gval (Gt x1a x2) (join_ir i r) = x\\<rbrakk>\n       \\<Longrightarrow> gval (Gt x1a x2) (join_ir i r') = x\n 3. \\<And>x1a x2 x.\n       \\<lbrakk>\\<forall>a.\n                   r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n        x \\<noteq> invalid; gval (In x1a x2) (join_ir i r) = x\\<rbrakk>\n       \\<Longrightarrow> gval (In x1a x2) (join_ir i r') = x\n 4. \\<And>a1 a2 x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>\\<forall>a.\n                               r $ a \\<noteq> None \\<longrightarrow>\n                               r $ a = r' $ a;\n                    x \\<noteq> invalid; gval a1 (join_ir i r) = x\\<rbrakk>\n                   \\<Longrightarrow> gval a1 (join_ir i r') = x;\n        \\<And>x.\n           \\<lbrakk>\\<forall>a.\n                       r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n            x \\<noteq> invalid; gval a2 (join_ir i r) = x\\<rbrakk>\n           \\<Longrightarrow> gval a2 (join_ir i r') = x;\n        \\<forall>a. r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n        x \\<noteq> invalid; gval (Nor a1 a2) (join_ir i r) = x\\<rbrakk>\n       \\<Longrightarrow> gval (Nor a1 a2) (join_ir i r') = x", "then"], ["proof (chain)\npicking this:\n  \\<forall>a. r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a\n  x \\<noteq> invalid\n  gval (Eq x1a x2) (join_ir i r) = x", "show ?case"], ["proof (prove)\nusing this:\n  \\<forall>a. r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a\n  x \\<noteq> invalid\n  gval (Eq x1a x2) (join_ir i r) = x\n\ngoal (1 subgoal):\n 1. gval (Eq x1a x2) (join_ir i r') = x", "apply (cases x)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<forall>a.\n                r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n     x \\<noteq> invalid; gval (Eq x1a x2) (join_ir i r) = x;\n     x = true\\<rbrakk>\n    \\<Longrightarrow> gval (Eq x1a x2) (join_ir i r') = x\n 2. \\<lbrakk>\\<forall>a.\n                r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n     x \\<noteq> invalid; gval (Eq x1a x2) (join_ir i r) = x;\n     x = false\\<rbrakk>\n    \\<Longrightarrow> gval (Eq x1a x2) (join_ir i r') = x\n 3. \\<lbrakk>\\<forall>a.\n                r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n     x \\<noteq> invalid; gval (Eq x1a x2) (join_ir i r) = x;\n     x = invalid\\<rbrakk>\n    \\<Longrightarrow> gval (Eq x1a x2) (join_ir i r') = x", "apply simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<forall>a.\n                (\\<exists>y. r $ a = Some y) \\<longrightarrow>\n                r $ a = r' $ a;\n     value_eq (aval x1a (join_ir i r)) (aval x2 (join_ir i r)) = true;\n     x = true\\<rbrakk>\n    \\<Longrightarrow> value_eq (aval x1a (join_ir i r'))\n                       (aval x2 (join_ir i r')) =\n                      true\n 2. \\<lbrakk>\\<forall>a.\n                r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n     x \\<noteq> invalid; gval (Eq x1a x2) (join_ir i r) = x;\n     x = false\\<rbrakk>\n    \\<Longrightarrow> gval (Eq x1a x2) (join_ir i r') = x\n 3. \\<lbrakk>\\<forall>a.\n                r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n     x \\<noteq> invalid; gval (Eq x1a x2) (join_ir i r) = x;\n     x = invalid\\<rbrakk>\n    \\<Longrightarrow> gval (Eq x1a x2) (join_ir i r') = x", "using value_eq_true[of \"aval x1a (join_ir i r)\" \"aval x2 (join_ir i r)\"]"], ["proof (prove)\nusing this:\n  (value_eq (aval x1a (join_ir i r)) (aval x2 (join_ir i r)) = true) =\n  (\\<exists>x y.\n      aval x1a (join_ir i r) = Some x \\<and>\n      aval x2 (join_ir i r) = Some y \\<and> x = y)\n\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<forall>a.\n                (\\<exists>y. r $ a = Some y) \\<longrightarrow>\n                r $ a = r' $ a;\n     value_eq (aval x1a (join_ir i r)) (aval x2 (join_ir i r)) = true;\n     x = true\\<rbrakk>\n    \\<Longrightarrow> value_eq (aval x1a (join_ir i r'))\n                       (aval x2 (join_ir i r')) =\n                      true\n 2. \\<lbrakk>\\<forall>a.\n                r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n     x \\<noteq> invalid; gval (Eq x1a x2) (join_ir i r) = x;\n     x = false\\<rbrakk>\n    \\<Longrightarrow> gval (Eq x1a x2) (join_ir i r') = x\n 3. \\<lbrakk>\\<forall>a.\n                r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n     x \\<noteq> invalid; gval (Eq x1a x2) (join_ir i r) = x;\n     x = invalid\\<rbrakk>\n    \\<Longrightarrow> gval (Eq x1a x2) (join_ir i r') = x", "apply clarsimp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>a.\n                   (\\<exists>y. r $ a = Some y) \\<longrightarrow>\n                   r $ a = r' $ a;\n        x = true; aval x1a (join_ir i r) = Some x;\n        aval x2 (join_ir i r) = Some x\\<rbrakk>\n       \\<Longrightarrow> value_eq (aval x1a (join_ir i r'))\n                          (aval x2 (join_ir i r')) =\n                         true\n 2. \\<lbrakk>\\<forall>a.\n                r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n     x \\<noteq> invalid; gval (Eq x1a x2) (join_ir i r) = x;\n     x = false\\<rbrakk>\n    \\<Longrightarrow> gval (Eq x1a x2) (join_ir i r') = x\n 3. \\<lbrakk>\\<forall>a.\n                r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n     x \\<noteq> invalid; gval (Eq x1a x2) (join_ir i r) = x;\n     x = invalid\\<rbrakk>\n    \\<Longrightarrow> gval (Eq x1a x2) (join_ir i r') = x", "apply (simp add: aval_reg_some_superset)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>a.\n                r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n     x \\<noteq> invalid; gval (Eq x1a x2) (join_ir i r) = x;\n     x = false\\<rbrakk>\n    \\<Longrightarrow> gval (Eq x1a x2) (join_ir i r') = x\n 2. \\<lbrakk>\\<forall>a.\n                r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n     x \\<noteq> invalid; gval (Eq x1a x2) (join_ir i r) = x;\n     x = invalid\\<rbrakk>\n    \\<Longrightarrow> gval (Eq x1a x2) (join_ir i r') = x", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>a.\n                (\\<exists>y. r $ a = Some y) \\<longrightarrow>\n                r $ a = r' $ a;\n     value_eq (aval x1a (join_ir i r)) (aval x2 (join_ir i r)) = false;\n     x = false\\<rbrakk>\n    \\<Longrightarrow> value_eq (aval x1a (join_ir i r'))\n                       (aval x2 (join_ir i r')) =\n                      false\n 2. \\<lbrakk>\\<forall>a.\n                r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n     x \\<noteq> invalid; gval (Eq x1a x2) (join_ir i r) = x;\n     x = invalid\\<rbrakk>\n    \\<Longrightarrow> gval (Eq x1a x2) (join_ir i r') = x", "using value_eq_false[of \"aval x1a (join_ir i r)\" \"aval x2 (join_ir i r)\"]"], ["proof (prove)\nusing this:\n  (value_eq (aval x1a (join_ir i r)) (aval x2 (join_ir i r)) = false) =\n  (\\<exists>x y.\n      aval x1a (join_ir i r) = Some x \\<and>\n      aval x2 (join_ir i r) = Some y \\<and> x \\<noteq> y)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>a.\n                (\\<exists>y. r $ a = Some y) \\<longrightarrow>\n                r $ a = r' $ a;\n     value_eq (aval x1a (join_ir i r)) (aval x2 (join_ir i r)) = false;\n     x = false\\<rbrakk>\n    \\<Longrightarrow> value_eq (aval x1a (join_ir i r'))\n                       (aval x2 (join_ir i r')) =\n                      false\n 2. \\<lbrakk>\\<forall>a.\n                r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n     x \\<noteq> invalid; gval (Eq x1a x2) (join_ir i r) = x;\n     x = invalid\\<rbrakk>\n    \\<Longrightarrow> gval (Eq x1a x2) (join_ir i r') = x", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>\\<forall>a.\n                   (\\<exists>y. r $ a = Some y) \\<longrightarrow>\n                   r $ a = r' $ a;\n        x = false; aval x1a (join_ir i r) = Some x;\n        aval x2 (join_ir i r) = Some y; x \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> value_eq (aval x1a (join_ir i r'))\n                          (aval x2 (join_ir i r')) =\n                         false\n 2. \\<lbrakk>\\<forall>a.\n                r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n     x \\<noteq> invalid; gval (Eq x1a x2) (join_ir i r) = x;\n     x = invalid\\<rbrakk>\n    \\<Longrightarrow> gval (Eq x1a x2) (join_ir i r') = x", "apply (simp add: aval_reg_some_superset)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>a.\n                r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n     x \\<noteq> invalid; gval (Eq x1a x2) (join_ir i r) = x;\n     x = invalid\\<rbrakk>\n    \\<Longrightarrow> gval (Eq x1a x2) (join_ir i r') = x", "by simp"], ["proof (state)\nthis:\n  gval (Eq x1a x2) (join_ir i r') = x\n\ngoal (3 subgoals):\n 1. \\<And>x1a x2 x.\n       \\<lbrakk>\\<forall>a.\n                   r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n        x \\<noteq> invalid; gval (Gt x1a x2) (join_ir i r) = x\\<rbrakk>\n       \\<Longrightarrow> gval (Gt x1a x2) (join_ir i r') = x\n 2. \\<And>x1a x2 x.\n       \\<lbrakk>\\<forall>a.\n                   r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n        x \\<noteq> invalid; gval (In x1a x2) (join_ir i r) = x\\<rbrakk>\n       \\<Longrightarrow> gval (In x1a x2) (join_ir i r') = x\n 3. \\<And>a1 a2 x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>\\<forall>a.\n                               r $ a \\<noteq> None \\<longrightarrow>\n                               r $ a = r' $ a;\n                    x \\<noteq> invalid; gval a1 (join_ir i r) = x\\<rbrakk>\n                   \\<Longrightarrow> gval a1 (join_ir i r') = x;\n        \\<And>x.\n           \\<lbrakk>\\<forall>a.\n                       r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n            x \\<noteq> invalid; gval a2 (join_ir i r) = x\\<rbrakk>\n           \\<Longrightarrow> gval a2 (join_ir i r') = x;\n        \\<forall>a. r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n        x \\<noteq> invalid; gval (Nor a1 a2) (join_ir i r) = x\\<rbrakk>\n       \\<Longrightarrow> gval (Nor a1 a2) (join_ir i r') = x", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x1a x2 x.\n       \\<lbrakk>\\<forall>a.\n                   r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n        x \\<noteq> invalid; gval (Gt x1a x2) (join_ir i r) = x\\<rbrakk>\n       \\<Longrightarrow> gval (Gt x1a x2) (join_ir i r') = x\n 2. \\<And>x1a x2 x.\n       \\<lbrakk>\\<forall>a.\n                   r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n        x \\<noteq> invalid; gval (In x1a x2) (join_ir i r) = x\\<rbrakk>\n       \\<Longrightarrow> gval (In x1a x2) (join_ir i r') = x\n 3. \\<And>a1 a2 x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>\\<forall>a.\n                               r $ a \\<noteq> None \\<longrightarrow>\n                               r $ a = r' $ a;\n                    x \\<noteq> invalid; gval a1 (join_ir i r) = x\\<rbrakk>\n                   \\<Longrightarrow> gval a1 (join_ir i r') = x;\n        \\<And>x.\n           \\<lbrakk>\\<forall>a.\n                       r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n            x \\<noteq> invalid; gval a2 (join_ir i r) = x\\<rbrakk>\n           \\<Longrightarrow> gval a2 (join_ir i r') = x;\n        \\<forall>a. r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n        x \\<noteq> invalid; gval (Nor a1 a2) (join_ir i r) = x\\<rbrakk>\n       \\<Longrightarrow> gval (Nor a1 a2) (join_ir i r') = x", "case (Gt x1a x2)"], ["proof (state)\nthis:\n  \\<forall>a. r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a\n  x \\<noteq> invalid\n  gval (Gt x1a x2) (join_ir i r) = x\n\ngoal (3 subgoals):\n 1. \\<And>x1a x2 x.\n       \\<lbrakk>\\<forall>a.\n                   r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n        x \\<noteq> invalid; gval (Gt x1a x2) (join_ir i r) = x\\<rbrakk>\n       \\<Longrightarrow> gval (Gt x1a x2) (join_ir i r') = x\n 2. \\<And>x1a x2 x.\n       \\<lbrakk>\\<forall>a.\n                   r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n        x \\<noteq> invalid; gval (In x1a x2) (join_ir i r) = x\\<rbrakk>\n       \\<Longrightarrow> gval (In x1a x2) (join_ir i r') = x\n 3. \\<And>a1 a2 x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>\\<forall>a.\n                               r $ a \\<noteq> None \\<longrightarrow>\n                               r $ a = r' $ a;\n                    x \\<noteq> invalid; gval a1 (join_ir i r) = x\\<rbrakk>\n                   \\<Longrightarrow> gval a1 (join_ir i r') = x;\n        \\<And>x.\n           \\<lbrakk>\\<forall>a.\n                       r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n            x \\<noteq> invalid; gval a2 (join_ir i r) = x\\<rbrakk>\n           \\<Longrightarrow> gval a2 (join_ir i r') = x;\n        \\<forall>a. r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n        x \\<noteq> invalid; gval (Nor a1 a2) (join_ir i r) = x\\<rbrakk>\n       \\<Longrightarrow> gval (Nor a1 a2) (join_ir i r') = x", "then"], ["proof (chain)\npicking this:\n  \\<forall>a. r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a\n  x \\<noteq> invalid\n  gval (Gt x1a x2) (join_ir i r) = x", "show ?case"], ["proof (prove)\nusing this:\n  \\<forall>a. r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a\n  x \\<noteq> invalid\n  gval (Gt x1a x2) (join_ir i r) = x\n\ngoal (1 subgoal):\n 1. gval (Gt x1a x2) (join_ir i r') = x", "apply (cases x)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<forall>a.\n                r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n     x \\<noteq> invalid; gval (Gt x1a x2) (join_ir i r) = x;\n     x = true\\<rbrakk>\n    \\<Longrightarrow> gval (Gt x1a x2) (join_ir i r') = x\n 2. \\<lbrakk>\\<forall>a.\n                r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n     x \\<noteq> invalid; gval (Gt x1a x2) (join_ir i r) = x;\n     x = false\\<rbrakk>\n    \\<Longrightarrow> gval (Gt x1a x2) (join_ir i r') = x\n 3. \\<lbrakk>\\<forall>a.\n                r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n     x \\<noteq> invalid; gval (Gt x1a x2) (join_ir i r) = x;\n     x = invalid\\<rbrakk>\n    \\<Longrightarrow> gval (Gt x1a x2) (join_ir i r') = x", "apply simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<forall>a.\n                (\\<exists>y. r $ a = Some y) \\<longrightarrow>\n                r $ a = r' $ a;\n     value_gt (aval x1a (join_ir i r)) (aval x2 (join_ir i r)) = true;\n     x = true\\<rbrakk>\n    \\<Longrightarrow> value_gt (aval x1a (join_ir i r'))\n                       (aval x2 (join_ir i r')) =\n                      true\n 2. \\<lbrakk>\\<forall>a.\n                r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n     x \\<noteq> invalid; gval (Gt x1a x2) (join_ir i r) = x;\n     x = false\\<rbrakk>\n    \\<Longrightarrow> gval (Gt x1a x2) (join_ir i r') = x\n 3. \\<lbrakk>\\<forall>a.\n                r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n     x \\<noteq> invalid; gval (Gt x1a x2) (join_ir i r) = x;\n     x = invalid\\<rbrakk>\n    \\<Longrightarrow> gval (Gt x1a x2) (join_ir i r') = x", "using value_gt_true_Some[of \"aval x1a (join_ir i r)\" \"aval x2 (join_ir i r)\"]"], ["proof (prove)\nusing this:\n  value_gt (aval x1a (join_ir i r)) (aval x2 (join_ir i r)) =\n  true \\<Longrightarrow>\n  (\\<exists>x. aval x1a (join_ir i r) = Some x) \\<and>\n  (\\<exists>y. aval x2 (join_ir i r) = Some y)\n\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<forall>a.\n                (\\<exists>y. r $ a = Some y) \\<longrightarrow>\n                r $ a = r' $ a;\n     value_gt (aval x1a (join_ir i r)) (aval x2 (join_ir i r)) = true;\n     x = true\\<rbrakk>\n    \\<Longrightarrow> value_gt (aval x1a (join_ir i r'))\n                       (aval x2 (join_ir i r')) =\n                      true\n 2. \\<lbrakk>\\<forall>a.\n                r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n     x \\<noteq> invalid; gval (Gt x1a x2) (join_ir i r) = x;\n     x = false\\<rbrakk>\n    \\<Longrightarrow> gval (Gt x1a x2) (join_ir i r') = x\n 3. \\<lbrakk>\\<forall>a.\n                r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n     x \\<noteq> invalid; gval (Gt x1a x2) (join_ir i r) = x;\n     x = invalid\\<rbrakk>\n    \\<Longrightarrow> gval (Gt x1a x2) (join_ir i r') = x", "apply clarsimp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>\\<forall>a.\n                   (\\<exists>y. r $ a = Some y) \\<longrightarrow>\n                   r $ a = r' $ a;\n        value_gt (Some x) (Some y) = true; x = true;\n        aval x1a (join_ir i r) = Some x;\n        aval x2 (join_ir i r) = Some y\\<rbrakk>\n       \\<Longrightarrow> value_gt (aval x1a (join_ir i r'))\n                          (aval x2 (join_ir i r')) =\n                         true\n 2. \\<lbrakk>\\<forall>a.\n                r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n     x \\<noteq> invalid; gval (Gt x1a x2) (join_ir i r) = x;\n     x = false\\<rbrakk>\n    \\<Longrightarrow> gval (Gt x1a x2) (join_ir i r') = x\n 3. \\<lbrakk>\\<forall>a.\n                r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n     x \\<noteq> invalid; gval (Gt x1a x2) (join_ir i r) = x;\n     x = invalid\\<rbrakk>\n    \\<Longrightarrow> gval (Gt x1a x2) (join_ir i r') = x", "apply (simp add: aval_reg_some_superset)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>a.\n                r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n     x \\<noteq> invalid; gval (Gt x1a x2) (join_ir i r) = x;\n     x = false\\<rbrakk>\n    \\<Longrightarrow> gval (Gt x1a x2) (join_ir i r') = x\n 2. \\<lbrakk>\\<forall>a.\n                r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n     x \\<noteq> invalid; gval (Gt x1a x2) (join_ir i r) = x;\n     x = invalid\\<rbrakk>\n    \\<Longrightarrow> gval (Gt x1a x2) (join_ir i r') = x", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>a.\n                (\\<exists>y. r $ a = Some y) \\<longrightarrow>\n                r $ a = r' $ a;\n     value_gt (aval x1a (join_ir i r)) (aval x2 (join_ir i r)) = false;\n     x = false\\<rbrakk>\n    \\<Longrightarrow> value_gt (aval x1a (join_ir i r'))\n                       (aval x2 (join_ir i r')) =\n                      false\n 2. \\<lbrakk>\\<forall>a.\n                r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n     x \\<noteq> invalid; gval (Gt x1a x2) (join_ir i r) = x;\n     x = invalid\\<rbrakk>\n    \\<Longrightarrow> gval (Gt x1a x2) (join_ir i r') = x", "using value_gt_false_Some[of \"aval x1a (join_ir i r)\" \"aval x2 (join_ir i r)\"]"], ["proof (prove)\nusing this:\n  value_gt (aval x1a (join_ir i r)) (aval x2 (join_ir i r)) =\n  false \\<Longrightarrow>\n  (\\<exists>x. aval x1a (join_ir i r) = Some x) \\<and>\n  (\\<exists>y. aval x2 (join_ir i r) = Some y)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>a.\n                (\\<exists>y. r $ a = Some y) \\<longrightarrow>\n                r $ a = r' $ a;\n     value_gt (aval x1a (join_ir i r)) (aval x2 (join_ir i r)) = false;\n     x = false\\<rbrakk>\n    \\<Longrightarrow> value_gt (aval x1a (join_ir i r'))\n                       (aval x2 (join_ir i r')) =\n                      false\n 2. \\<lbrakk>\\<forall>a.\n                r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n     x \\<noteq> invalid; gval (Gt x1a x2) (join_ir i r) = x;\n     x = invalid\\<rbrakk>\n    \\<Longrightarrow> gval (Gt x1a x2) (join_ir i r') = x", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>\\<forall>a.\n                   (\\<exists>y. r $ a = Some y) \\<longrightarrow>\n                   r $ a = r' $ a;\n        value_gt (Some x) (Some y) = false; x = false;\n        aval x1a (join_ir i r) = Some x;\n        aval x2 (join_ir i r) = Some y\\<rbrakk>\n       \\<Longrightarrow> value_gt (aval x1a (join_ir i r'))\n                          (aval x2 (join_ir i r')) =\n                         false\n 2. \\<lbrakk>\\<forall>a.\n                r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n     x \\<noteq> invalid; gval (Gt x1a x2) (join_ir i r) = x;\n     x = invalid\\<rbrakk>\n    \\<Longrightarrow> gval (Gt x1a x2) (join_ir i r') = x", "apply (simp add: aval_reg_some_superset)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>a.\n                r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n     x \\<noteq> invalid; gval (Gt x1a x2) (join_ir i r) = x;\n     x = invalid\\<rbrakk>\n    \\<Longrightarrow> gval (Gt x1a x2) (join_ir i r') = x", "by simp"], ["proof (state)\nthis:\n  gval (Gt x1a x2) (join_ir i r') = x\n\ngoal (2 subgoals):\n 1. \\<And>x1a x2 x.\n       \\<lbrakk>\\<forall>a.\n                   r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n        x \\<noteq> invalid; gval (In x1a x2) (join_ir i r) = x\\<rbrakk>\n       \\<Longrightarrow> gval (In x1a x2) (join_ir i r') = x\n 2. \\<And>a1 a2 x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>\\<forall>a.\n                               r $ a \\<noteq> None \\<longrightarrow>\n                               r $ a = r' $ a;\n                    x \\<noteq> invalid; gval a1 (join_ir i r) = x\\<rbrakk>\n                   \\<Longrightarrow> gval a1 (join_ir i r') = x;\n        \\<And>x.\n           \\<lbrakk>\\<forall>a.\n                       r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n            x \\<noteq> invalid; gval a2 (join_ir i r) = x\\<rbrakk>\n           \\<Longrightarrow> gval a2 (join_ir i r') = x;\n        \\<forall>a. r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n        x \\<noteq> invalid; gval (Nor a1 a2) (join_ir i r) = x\\<rbrakk>\n       \\<Longrightarrow> gval (Nor a1 a2) (join_ir i r') = x", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1a x2 x.\n       \\<lbrakk>\\<forall>a.\n                   r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n        x \\<noteq> invalid; gval (In x1a x2) (join_ir i r) = x\\<rbrakk>\n       \\<Longrightarrow> gval (In x1a x2) (join_ir i r') = x\n 2. \\<And>a1 a2 x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>\\<forall>a.\n                               r $ a \\<noteq> None \\<longrightarrow>\n                               r $ a = r' $ a;\n                    x \\<noteq> invalid; gval a1 (join_ir i r) = x\\<rbrakk>\n                   \\<Longrightarrow> gval a1 (join_ir i r') = x;\n        \\<And>x.\n           \\<lbrakk>\\<forall>a.\n                       r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n            x \\<noteq> invalid; gval a2 (join_ir i r) = x\\<rbrakk>\n           \\<Longrightarrow> gval a2 (join_ir i r') = x;\n        \\<forall>a. r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n        x \\<noteq> invalid; gval (Nor a1 a2) (join_ir i r) = x\\<rbrakk>\n       \\<Longrightarrow> gval (Nor a1 a2) (join_ir i r') = x", "case (In x1a x2)"], ["proof (state)\nthis:\n  \\<forall>a. r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a\n  x \\<noteq> invalid\n  gval (In x1a x2) (join_ir i r) = x\n\ngoal (2 subgoals):\n 1. \\<And>x1a x2 x.\n       \\<lbrakk>\\<forall>a.\n                   r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n        x \\<noteq> invalid; gval (In x1a x2) (join_ir i r) = x\\<rbrakk>\n       \\<Longrightarrow> gval (In x1a x2) (join_ir i r') = x\n 2. \\<And>a1 a2 x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>\\<forall>a.\n                               r $ a \\<noteq> None \\<longrightarrow>\n                               r $ a = r' $ a;\n                    x \\<noteq> invalid; gval a1 (join_ir i r) = x\\<rbrakk>\n                   \\<Longrightarrow> gval a1 (join_ir i r') = x;\n        \\<And>x.\n           \\<lbrakk>\\<forall>a.\n                       r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n            x \\<noteq> invalid; gval a2 (join_ir i r) = x\\<rbrakk>\n           \\<Longrightarrow> gval a2 (join_ir i r') = x;\n        \\<forall>a. r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n        x \\<noteq> invalid; gval (Nor a1 a2) (join_ir i r) = x\\<rbrakk>\n       \\<Longrightarrow> gval (Nor a1 a2) (join_ir i r') = x", "then"], ["proof (chain)\npicking this:\n  \\<forall>a. r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a\n  x \\<noteq> invalid\n  gval (In x1a x2) (join_ir i r) = x", "show ?case"], ["proof (prove)\nusing this:\n  \\<forall>a. r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a\n  x \\<noteq> invalid\n  gval (In x1a x2) (join_ir i r) = x\n\ngoal (1 subgoal):\n 1. gval (In x1a x2) (join_ir i r') = x", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>a.\n                (\\<exists>y. r $ a = Some y) \\<longrightarrow>\n                r $ a = r' $ a;\n     x \\<noteq> invalid;\n     (case join_ir i r x1a of None \\<Rightarrow> invalid\n      | Some vv \\<Rightarrow> if vv \\<in> set x2 then true else false) =\n     x\\<rbrakk>\n    \\<Longrightarrow> (case join_ir i r' x1a of None \\<Rightarrow> invalid\n                       | Some vv \\<Rightarrow>\n                           if vv \\<in> set x2 then true else false) =\n                      x", "apply (case_tac \"join_ir i r x1a\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>a.\n                (\\<exists>y. r $ a = Some y) \\<longrightarrow>\n                r $ a = r' $ a;\n     x \\<noteq> invalid;\n     (case join_ir i r x1a of None \\<Rightarrow> invalid\n      | Some vv \\<Rightarrow> if vv \\<in> set x2 then true else false) =\n     x;\n     join_ir i r x1a = None\\<rbrakk>\n    \\<Longrightarrow> (case join_ir i r' x1a of None \\<Rightarrow> invalid\n                       | Some vv \\<Rightarrow>\n                           if vv \\<in> set x2 then true else false) =\n                      x\n 2. \\<And>a.\n       \\<lbrakk>\\<forall>a.\n                   (\\<exists>y. r $ a = Some y) \\<longrightarrow>\n                   r $ a = r' $ a;\n        x \\<noteq> invalid;\n        (case join_ir i r x1a of None \\<Rightarrow> invalid\n         | Some vv \\<Rightarrow> if vv \\<in> set x2 then true else false) =\n        x;\n        join_ir i r x1a = Some a\\<rbrakk>\n       \\<Longrightarrow> (case join_ir i r' x1a of\n                          None \\<Rightarrow> invalid\n                          | Some vv \\<Rightarrow>\n                              if vv \\<in> set x2 then true else false) =\n                         x", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>\\<forall>a.\n                   (\\<exists>y. r $ a = Some y) \\<longrightarrow>\n                   r $ a = r' $ a;\n        x \\<noteq> invalid;\n        (case join_ir i r x1a of None \\<Rightarrow> invalid\n         | Some vv \\<Rightarrow> if vv \\<in> set x2 then true else false) =\n        x;\n        join_ir i r x1a = Some a\\<rbrakk>\n       \\<Longrightarrow> (case join_ir i r' x1a of\n                          None \\<Rightarrow> invalid\n                          | Some vv \\<Rightarrow>\n                              if vv \\<in> set x2 then true else false) =\n                         x", "apply (case_tac \"join_ir i r' x1a\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>\\<forall>a.\n                   (\\<exists>y. r $ a = Some y) \\<longrightarrow>\n                   r $ a = r' $ a;\n        x \\<noteq> invalid;\n        (case join_ir i r x1a of None \\<Rightarrow> invalid\n         | Some vv \\<Rightarrow> if vv \\<in> set x2 then true else false) =\n        x;\n        join_ir i r x1a = Some a; join_ir i r' x1a = None\\<rbrakk>\n       \\<Longrightarrow> (case join_ir i r' x1a of\n                          None \\<Rightarrow> invalid\n                          | Some vv \\<Rightarrow>\n                              if vv \\<in> set x2 then true else false) =\n                         x\n 2. \\<And>a aa.\n       \\<lbrakk>\\<forall>a.\n                   (\\<exists>y. r $ a = Some y) \\<longrightarrow>\n                   r $ a = r' $ a;\n        x \\<noteq> invalid;\n        (case join_ir i r x1a of None \\<Rightarrow> invalid\n         | Some vv \\<Rightarrow> if vv \\<in> set x2 then true else false) =\n        x;\n        join_ir i r x1a = Some a; join_ir i r' x1a = Some aa\\<rbrakk>\n       \\<Longrightarrow> (case join_ir i r' x1a of\n                          None \\<Rightarrow> invalid\n                          | Some vv \\<Rightarrow>\n                              if vv \\<in> set x2 then true else false) =\n                         x", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>\\<forall>a.\n                   (\\<exists>y. r $ a = Some y) \\<longrightarrow>\n                   r $ a = r' $ a;\n        x \\<noteq> invalid; (if a \\<in> set x2 then true else false) = x;\n        join_ir i r x1a = Some a; join_ir i r' x1a = None\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>a aa.\n       \\<lbrakk>\\<forall>a.\n                   (\\<exists>y. r $ a = Some y) \\<longrightarrow>\n                   r $ a = r' $ a;\n        x \\<noteq> invalid;\n        (case join_ir i r x1a of None \\<Rightarrow> invalid\n         | Some vv \\<Rightarrow> if vv \\<in> set x2 then true else false) =\n        x;\n        join_ir i r x1a = Some a; join_ir i r' x1a = Some aa\\<rbrakk>\n       \\<Longrightarrow> (case join_ir i r' x1a of\n                          None \\<Rightarrow> invalid\n                          | Some vv \\<Rightarrow>\n                              if vv \\<in> set x2 then true else false) =\n                         x", "apply (metis aval_reg_some_superset In.prems(1) aval.simps(2) option.distinct(1))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa.\n       \\<lbrakk>\\<forall>a.\n                   (\\<exists>y. r $ a = Some y) \\<longrightarrow>\n                   r $ a = r' $ a;\n        x \\<noteq> invalid;\n        (case join_ir i r x1a of None \\<Rightarrow> invalid\n         | Some vv \\<Rightarrow> if vv \\<in> set x2 then true else false) =\n        x;\n        join_ir i r x1a = Some a; join_ir i r' x1a = Some aa\\<rbrakk>\n       \\<Longrightarrow> (case join_ir i r' x1a of\n                          None \\<Rightarrow> invalid\n                          | Some vv \\<Rightarrow>\n                              if vv \\<in> set x2 then true else false) =\n                         x", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa.\n       \\<lbrakk>\\<forall>a.\n                   (\\<exists>y. r $ a = Some y) \\<longrightarrow>\n                   r $ a = r' $ a;\n        x \\<noteq> invalid; (if a \\<in> set x2 then true else false) = x;\n        join_ir i r x1a = Some a; join_ir i r' x1a = Some aa\\<rbrakk>\n       \\<Longrightarrow> (aa \\<in> set x2 \\<longrightarrow> true = x) \\<and>\n                         (aa \\<notin> set x2 \\<longrightarrow> false = x)", "by (metis (full_types) aval_reg_some_superset In.prems(1) aval.simps(2) option.inject)"], ["proof (state)\nthis:\n  gval (In x1a x2) (join_ir i r') = x\n\ngoal (1 subgoal):\n 1. \\<And>a1 a2 x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>\\<forall>a.\n                               r $ a \\<noteq> None \\<longrightarrow>\n                               r $ a = r' $ a;\n                    x \\<noteq> invalid; gval a1 (join_ir i r) = x\\<rbrakk>\n                   \\<Longrightarrow> gval a1 (join_ir i r') = x;\n        \\<And>x.\n           \\<lbrakk>\\<forall>a.\n                       r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n            x \\<noteq> invalid; gval a2 (join_ir i r) = x\\<rbrakk>\n           \\<Longrightarrow> gval a2 (join_ir i r') = x;\n        \\<forall>a. r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n        x \\<noteq> invalid; gval (Nor a1 a2) (join_ir i r) = x\\<rbrakk>\n       \\<Longrightarrow> gval (Nor a1 a2) (join_ir i r') = x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a1 a2 x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>\\<forall>a.\n                               r $ a \\<noteq> None \\<longrightarrow>\n                               r $ a = r' $ a;\n                    x \\<noteq> invalid; gval a1 (join_ir i r) = x\\<rbrakk>\n                   \\<Longrightarrow> gval a1 (join_ir i r') = x;\n        \\<And>x.\n           \\<lbrakk>\\<forall>a.\n                       r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n            x \\<noteq> invalid; gval a2 (join_ir i r) = x\\<rbrakk>\n           \\<Longrightarrow> gval a2 (join_ir i r') = x;\n        \\<forall>a. r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n        x \\<noteq> invalid; gval (Nor a1 a2) (join_ir i r) = x\\<rbrakk>\n       \\<Longrightarrow> gval (Nor a1 a2) (join_ir i r') = x", "case (Nor a1 a2)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<forall>a. r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n   ?x \\<noteq> invalid; gval a1 (join_ir i r) = ?x\\<rbrakk>\n  \\<Longrightarrow> gval a1 (join_ir i r') = ?x\n  \\<lbrakk>\\<forall>a. r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n   ?x \\<noteq> invalid; gval a2 (join_ir i r) = ?x\\<rbrakk>\n  \\<Longrightarrow> gval a2 (join_ir i r') = ?x\n  \\<forall>a. r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a\n  x \\<noteq> invalid\n  gval (Nor a1 a2) (join_ir i r) = x\n\ngoal (1 subgoal):\n 1. \\<And>a1 a2 x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>\\<forall>a.\n                               r $ a \\<noteq> None \\<longrightarrow>\n                               r $ a = r' $ a;\n                    x \\<noteq> invalid; gval a1 (join_ir i r) = x\\<rbrakk>\n                   \\<Longrightarrow> gval a1 (join_ir i r') = x;\n        \\<And>x.\n           \\<lbrakk>\\<forall>a.\n                       r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n            x \\<noteq> invalid; gval a2 (join_ir i r) = x\\<rbrakk>\n           \\<Longrightarrow> gval a2 (join_ir i r') = x;\n        \\<forall>a. r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n        x \\<noteq> invalid; gval (Nor a1 a2) (join_ir i r) = x\\<rbrakk>\n       \\<Longrightarrow> gval (Nor a1 a2) (join_ir i r') = x", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<forall>a. r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n   ?x \\<noteq> invalid; gval a1 (join_ir i r) = ?x\\<rbrakk>\n  \\<Longrightarrow> gval a1 (join_ir i r') = ?x\n  \\<lbrakk>\\<forall>a. r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n   ?x \\<noteq> invalid; gval a2 (join_ir i r) = ?x\\<rbrakk>\n  \\<Longrightarrow> gval a2 (join_ir i r') = ?x\n  \\<forall>a. r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a\n  x \\<noteq> invalid\n  gval (Nor a1 a2) (join_ir i r) = x", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<forall>a. r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n   ?x \\<noteq> invalid; gval a1 (join_ir i r) = ?x\\<rbrakk>\n  \\<Longrightarrow> gval a1 (join_ir i r') = ?x\n  \\<lbrakk>\\<forall>a. r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n   ?x \\<noteq> invalid; gval a2 (join_ir i r) = ?x\\<rbrakk>\n  \\<Longrightarrow> gval a2 (join_ir i r') = ?x\n  \\<forall>a. r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a\n  x \\<noteq> invalid\n  gval (Nor a1 a2) (join_ir i r) = x\n\ngoal (1 subgoal):\n 1. gval (Nor a1 a2) (join_ir i r') = x", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x.\n                \\<lbrakk>x \\<noteq> invalid;\n                 gval a1 (join_ir i r) = x\\<rbrakk>\n                \\<Longrightarrow> gval a1 (join_ir i r') = x;\n     \\<And>x.\n        \\<lbrakk>x \\<noteq> invalid; gval a2 (join_ir i r) = x\\<rbrakk>\n        \\<Longrightarrow> gval a2 (join_ir i r') = x;\n     \\<forall>a.\n        (\\<exists>y. r $ a = Some y) \\<longrightarrow> r $ a = r' $ a;\n     x \\<noteq> invalid;\n     \\<not>? gval a1 (join_ir i r) \\<or>? gval a2 (join_ir i r) = x\\<rbrakk>\n    \\<Longrightarrow> \\<not>? gval a1 (join_ir i r') \\<or>?\n                              gval a2 (join_ir i r') =\n                      x", "apply (cases x)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<And>x.\n                \\<lbrakk>x \\<noteq> invalid;\n                 gval a1 (join_ir i r) = x\\<rbrakk>\n                \\<Longrightarrow> gval a1 (join_ir i r') = x;\n     \\<And>x.\n        \\<lbrakk>x \\<noteq> invalid; gval a2 (join_ir i r) = x\\<rbrakk>\n        \\<Longrightarrow> gval a2 (join_ir i r') = x;\n     \\<forall>a.\n        (\\<exists>y. r $ a = Some y) \\<longrightarrow> r $ a = r' $ a;\n     x \\<noteq> invalid;\n     \\<not>? gval a1 (join_ir i r) \\<or>? gval a2 (join_ir i r) = x;\n     x = true\\<rbrakk>\n    \\<Longrightarrow> \\<not>? gval a1 (join_ir i r') \\<or>?\n                              gval a2 (join_ir i r') =\n                      x\n 2. \\<lbrakk>\\<And>x.\n                \\<lbrakk>x \\<noteq> invalid;\n                 gval a1 (join_ir i r) = x\\<rbrakk>\n                \\<Longrightarrow> gval a1 (join_ir i r') = x;\n     \\<And>x.\n        \\<lbrakk>x \\<noteq> invalid; gval a2 (join_ir i r) = x\\<rbrakk>\n        \\<Longrightarrow> gval a2 (join_ir i r') = x;\n     \\<forall>a.\n        (\\<exists>y. r $ a = Some y) \\<longrightarrow> r $ a = r' $ a;\n     x \\<noteq> invalid;\n     \\<not>? gval a1 (join_ir i r) \\<or>? gval a2 (join_ir i r) = x;\n     x = false\\<rbrakk>\n    \\<Longrightarrow> \\<not>? gval a1 (join_ir i r') \\<or>?\n                              gval a2 (join_ir i r') =\n                      x\n 3. \\<lbrakk>\\<And>x.\n                \\<lbrakk>x \\<noteq> invalid;\n                 gval a1 (join_ir i r) = x\\<rbrakk>\n                \\<Longrightarrow> gval a1 (join_ir i r') = x;\n     \\<And>x.\n        \\<lbrakk>x \\<noteq> invalid; gval a2 (join_ir i r) = x\\<rbrakk>\n        \\<Longrightarrow> gval a2 (join_ir i r') = x;\n     \\<forall>a.\n        (\\<exists>y. r $ a = Some y) \\<longrightarrow> r $ a = r' $ a;\n     x \\<noteq> invalid;\n     \\<not>? gval a1 (join_ir i r) \\<or>? gval a2 (join_ir i r) = x;\n     x = invalid\\<rbrakk>\n    \\<Longrightarrow> \\<not>? gval a1 (join_ir i r') \\<or>?\n                              gval a2 (join_ir i r') =\n                      x", "apply (simp add: maybe_negate_true maybe_or_false)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>x.\n                \\<lbrakk>x \\<noteq> invalid;\n                 gval a1 (join_ir i r) = x\\<rbrakk>\n                \\<Longrightarrow> gval a1 (join_ir i r') = x;\n     \\<And>x.\n        \\<lbrakk>x \\<noteq> invalid; gval a2 (join_ir i r) = x\\<rbrakk>\n        \\<Longrightarrow> gval a2 (join_ir i r') = x;\n     \\<forall>a.\n        (\\<exists>y. r $ a = Some y) \\<longrightarrow> r $ a = r' $ a;\n     x \\<noteq> invalid;\n     \\<not>? gval a1 (join_ir i r) \\<or>? gval a2 (join_ir i r) = x;\n     x = false\\<rbrakk>\n    \\<Longrightarrow> \\<not>? gval a1 (join_ir i r') \\<or>?\n                              gval a2 (join_ir i r') =\n                      x\n 2. \\<lbrakk>\\<And>x.\n                \\<lbrakk>x \\<noteq> invalid;\n                 gval a1 (join_ir i r) = x\\<rbrakk>\n                \\<Longrightarrow> gval a1 (join_ir i r') = x;\n     \\<And>x.\n        \\<lbrakk>x \\<noteq> invalid; gval a2 (join_ir i r) = x\\<rbrakk>\n        \\<Longrightarrow> gval a2 (join_ir i r') = x;\n     \\<forall>a.\n        (\\<exists>y. r $ a = Some y) \\<longrightarrow> r $ a = r' $ a;\n     x \\<noteq> invalid;\n     \\<not>? gval a1 (join_ir i r) \\<or>? gval a2 (join_ir i r) = x;\n     x = invalid\\<rbrakk>\n    \\<Longrightarrow> \\<not>? gval a1 (join_ir i r') \\<or>?\n                              gval a2 (join_ir i r') =\n                      x", "apply (simp add: maybe_negate_false maybe_or_true)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>x.\n                \\<lbrakk>x \\<noteq> invalid;\n                 gval a1 (join_ir i r) = x\\<rbrakk>\n                \\<Longrightarrow> gval a1 (join_ir i r') = x;\n     \\<And>x.\n        \\<lbrakk>x \\<noteq> invalid; gval a2 (join_ir i r) = x\\<rbrakk>\n        \\<Longrightarrow> gval a2 (join_ir i r') = x;\n     \\<forall>a.\n        (\\<exists>y. r $ a = Some y) \\<longrightarrow> r $ a = r' $ a;\n     (gval a1 (join_ir i r) = true \\<or>\n      gval a2 (join_ir i r) = true) \\<and>\n     gval a1 (join_ir i r) \\<noteq> invalid \\<and>\n     gval a2 (join_ir i r) \\<noteq> invalid;\n     x = false\\<rbrakk>\n    \\<Longrightarrow> (gval a1 (join_ir i r') = true \\<or>\n                       gval a2 (join_ir i r') = true) \\<and>\n                      gval a1 (join_ir i r') \\<noteq> invalid \\<and>\n                      gval a2 (join_ir i r') \\<noteq> invalid\n 2. \\<lbrakk>\\<And>x.\n                \\<lbrakk>x \\<noteq> invalid;\n                 gval a1 (join_ir i r) = x\\<rbrakk>\n                \\<Longrightarrow> gval a1 (join_ir i r') = x;\n     \\<And>x.\n        \\<lbrakk>x \\<noteq> invalid; gval a2 (join_ir i r) = x\\<rbrakk>\n        \\<Longrightarrow> gval a2 (join_ir i r') = x;\n     \\<forall>a.\n        (\\<exists>y. r $ a = Some y) \\<longrightarrow> r $ a = r' $ a;\n     x \\<noteq> invalid;\n     \\<not>? gval a1 (join_ir i r) \\<or>? gval a2 (join_ir i r) = x;\n     x = invalid\\<rbrakk>\n    \\<Longrightarrow> \\<not>? gval a1 (join_ir i r') \\<or>?\n                              gval a2 (join_ir i r') =\n                      x", "apply presburger"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x.\n                \\<lbrakk>x \\<noteq> invalid;\n                 gval a1 (join_ir i r) = x\\<rbrakk>\n                \\<Longrightarrow> gval a1 (join_ir i r') = x;\n     \\<And>x.\n        \\<lbrakk>x \\<noteq> invalid; gval a2 (join_ir i r) = x\\<rbrakk>\n        \\<Longrightarrow> gval a2 (join_ir i r') = x;\n     \\<forall>a.\n        (\\<exists>y. r $ a = Some y) \\<longrightarrow> r $ a = r' $ a;\n     x \\<noteq> invalid;\n     \\<not>? gval a1 (join_ir i r) \\<or>? gval a2 (join_ir i r) = x;\n     x = invalid\\<rbrakk>\n    \\<Longrightarrow> \\<not>? gval a1 (join_ir i r') \\<or>?\n                              gval a2 (join_ir i r') =\n                      x", "by simp"], ["proof (state)\nthis:\n  gval (Nor a1 a2) (join_ir i r') = x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma apply_guards_reg_some_superset:\n  \"\\<forall>a. (r $ a  \\<noteq> None) \\<longrightarrow> r $ a = r' $ a \\<Longrightarrow>\n   apply_guards G (join_ir i r) \\<Longrightarrow>\n   apply_guards G (join_ir i r')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>a.\n                r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n     apply_guards G (join_ir i r)\\<rbrakk>\n    \\<Longrightarrow> apply_guards G (join_ir i r')", "apply (induct G)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>a.\n                r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n     apply_guards [] (join_ir i r)\\<rbrakk>\n    \\<Longrightarrow> apply_guards [] (join_ir i r')\n 2. \\<And>a G.\n       \\<lbrakk>\\<lbrakk>\\<forall>a.\n                            r $ a \\<noteq> None \\<longrightarrow>\n                            r $ a = r' $ a;\n                 apply_guards G (join_ir i r)\\<rbrakk>\n                \\<Longrightarrow> apply_guards G (join_ir i r');\n        \\<forall>a. r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n        apply_guards (a # G) (join_ir i r)\\<rbrakk>\n       \\<Longrightarrow> apply_guards (a # G) (join_ir i r')", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a G.\n       \\<lbrakk>\\<lbrakk>\\<forall>a.\n                            r $ a \\<noteq> None \\<longrightarrow>\n                            r $ a = r' $ a;\n                 apply_guards G (join_ir i r)\\<rbrakk>\n                \\<Longrightarrow> apply_guards G (join_ir i r');\n        \\<forall>a. r $ a \\<noteq> None \\<longrightarrow> r $ a = r' $ a;\n        apply_guards (a # G) (join_ir i r)\\<rbrakk>\n       \\<Longrightarrow> apply_guards (a # G) (join_ir i r')", "apply (simp add: apply_guards_cons)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a G.\n       \\<lbrakk>apply_guards G (join_ir i r');\n        \\<forall>a.\n           (\\<exists>y. r $ a = Some y) \\<longrightarrow> r $ a = r' $ a;\n        gval a (join_ir i r) = true \\<and>\n        apply_guards G (join_ir i r)\\<rbrakk>\n       \\<Longrightarrow> gval a (join_ir i r') = true", "using gval_reg_some_superset"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<forall>a.\n              ?r $ a \\<noteq> None \\<longrightarrow> ?r $ a = ?r' $ a;\n   ?x \\<noteq> invalid; gval ?a (join_ir ?i ?r) = ?x\\<rbrakk>\n  \\<Longrightarrow> gval ?a (join_ir ?i ?r') = ?x\n\ngoal (1 subgoal):\n 1. \\<And>a G.\n       \\<lbrakk>apply_guards G (join_ir i r');\n        \\<forall>a.\n           (\\<exists>y. r $ a = Some y) \\<longrightarrow> r $ a = r' $ a;\n        gval a (join_ir i r) = true \\<and>\n        apply_guards G (join_ir i r)\\<rbrakk>\n       \\<Longrightarrow> gval a (join_ir i r') = true", "by simp"], ["", "end"]]}