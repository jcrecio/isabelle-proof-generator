{"file_name": "/home/qj213/afp-2021-10-22/thys/Extended_Finite_State_Machines/examples/Drinks_Machine.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Extended_Finite_State_Machines", "problem_names": ["lemmas transitions = select_def coin_def vend_def vend_fail_def", "lemma apply_updates_vend: \"apply_updates (Updates vend) (join_ir [] r) r = r\"", "lemma drinks_states: \"S drinks = {|0, 1, 2|}\"", "lemma possible_steps_0:\n  \"length i = 1 \\<Longrightarrow>\n   possible_steps drinks 0 r (STR ''select'') i = {|(1, select)|}\"", "lemma first_step_select:\n  \"(s', t) |\\<in>| possible_steps drinks 0 r aa b \\<Longrightarrow> s' = 1 \\<and> t = select\"", "lemma drinks_vend_insufficient:\n  \"r $ 2 = Some (Num x1) \\<Longrightarrow>\n   x1 < 100 \\<Longrightarrow>\n   possible_steps drinks 1 r (STR ''vend'') [] = {|(1, vend_fail)|}\"", "lemma drinks_vend_invalid:\n  \"\\<nexists>n. r $ 2 = Some (Num n) \\<Longrightarrow>\n   possible_steps drinks 1 r (STR ''vend'') [] = {||}\"", "lemma possible_steps_1_coin:\n  \"length i = 1 \\<Longrightarrow> possible_steps drinks 1 r (STR ''coin'') i = {|(1, coin)|}\"", "lemma possible_steps_2_vend:\n  \"\\<exists>n. r $ 2 = Some (Num n) \\<and> n \\<ge> 100 \\<Longrightarrow>\n   possible_steps drinks 1 r (STR ''vend'') [] = {|(2, vend)|}\"", "lemma recognises_from_2:\n  \"recognises_execution drinks 1 <1 $:= d, 2 $:= Some (Num 100)> [(STR ''vend'', [])]\"", "lemma recognises_from_1a:\n  \"recognises_execution drinks 1 <1 $:= d, 2 $:= Some (Num 50)> [(STR ''coin'', [Num 50]), (STR ''vend'', [])]\"", "lemma recognises_from_1: \"recognises_execution drinks 1 <2 $:= Some (Num 0), 1 $:= Some d>\n     [(STR ''coin'', [Num 50]), (STR ''coin'', [Num 50]), (STR ''vend'', [])]\"", "lemma purchase_coke:\n  \"observe_execution drinks 0 <> [(STR ''select'', [Str ''coke'']), (STR ''coin'', [Num 50]), (STR ''coin'', [Num 50]), (STR ''vend'', [])] =\n                       [[], [Some (Num 50)], [Some (Num 100)], [Some (Str ''coke'')]]\"", "lemma rejects_input:\n  \"l \\<noteq> STR ''coin'' \\<Longrightarrow>\n   l \\<noteq> STR ''vend'' \\<Longrightarrow>\n   \\<not> recognises_execution drinks 1 d' [(l, i)]\"", "lemma rejects_recognises_prefix: \"l \\<noteq> STR ''coin'' \\<Longrightarrow>\n   l \\<noteq> STR ''vend'' \\<Longrightarrow>\n   \\<not> (recognises drinks [(STR ''select'', [Str ''coke'']), (l, i)])\"", "lemma rejects_termination:\n  \"observe_execution drinks 0 <> [(STR ''select'', [Str ''coke'']), (STR ''rejects'', [Num 50]), (STR ''coin'', [Num 50])] = [[]]\"", "lemma r2_0_vend:\n  \"can_take_transition vend i r \\<Longrightarrow>\n   \\<exists>n. r $ 2 = Some (Num n) \\<and> n \\<ge> 100\"", "lemma drinks_vend_sufficient: \"r $ 2 = Some (Num x1) \\<Longrightarrow>\n                x1 \\<ge> 100 \\<Longrightarrow>\n                possible_steps drinks 1 r (STR ''vend'') [] = {|(2, vend)|}\"", "lemma drinks_end: \"possible_steps drinks 2 r a b = {||}\"", "lemma drinks_vend_r2_String:\n  \"r $ 2 = Some (value.Str x2) \\<Longrightarrow>\n   possible_steps drinks 1 r (STR ''vend'') [] = {||}\"", "lemma drinks_vend_r2_rejects:\n  \"\\<nexists>n. r $ 2 = Some (Num n) \\<Longrightarrow> step drinks 1 r (STR ''vend'') [] = None\"", "lemma drinks_0_rejects:\n  \"\\<not> (fst a = STR ''select'' \\<and> length (snd a) = 1) \\<Longrightarrow>\n    (possible_steps drinks 0 r (fst a) (snd a)) = {||}\"", "lemma drinks_vend_empty: \"(possible_steps drinks 0 <> (STR ''vend'') []) = {||}\"", "lemma drinks_1_rejects:\n  \"fst a = STR ''coin'' \\<longrightarrow> length (snd a) \\<noteq> 1 \\<Longrightarrow>\n          a \\<noteq> (STR ''vend'', []) \\<Longrightarrow>\n          possible_steps drinks 1 r (fst a) (snd a) = {||}\"", "lemma drinks_rejects_future: \"\\<not> recognises_execution drinks 2 d ((l, i)#t)\"", "lemma drinks_1_rejects_trace:\n  assumes not_vend: \"e \\<noteq> (STR ''vend'', [])\"\n      and not_coin: \"\\<nexists>i. e = (STR ''coin'', [i])\"\n  shows \"\\<not> recognises_execution drinks 1 r (e # es)\"", "lemma rejects_state_step: \"s > 1 \\<Longrightarrow> step drinks s r l i = None\"", "lemma invalid_other_states:\n  \"s > 1 \\<Longrightarrow> \\<not> recognises_execution drinks s r ((aa, b) # t)\"", "lemma vend_ge_100:\n  \"possible_steps drinks 1 r l i = {|(2, vend)|} \\<Longrightarrow>\n   \\<not>? value_gt (Some (Num 100)) (r $ 2) = trilean.true\"", "lemma drinks_no_possible_steps_1:\n  assumes not_coin: \"\\<not> (a = STR ''coin'' \\<and> length b = 1)\"\n      and not_vend: \"\\<not> (a = STR ''vend'' \\<and> b = [])\"\n    shows \"possible_steps drinks 1 r a b = {||}\"", "lemma possible_steps_0_not_select: \"a \\<noteq> STR ''select'' \\<Longrightarrow>\n       possible_steps drinks 0 <> a b = {||}\"", "lemma possible_steps_select_wrong_arity: \"a = STR ''select'' \\<Longrightarrow>\n       length b \\<noteq> 1 \\<Longrightarrow>\n       possible_steps drinks 0 <> a b = {||}\"", "lemma possible_steps_0_invalid:\n  \"\\<not> (l = STR ''select'' \\<and> length i = 1) \\<Longrightarrow>\n   possible_steps drinks 0 <> l i = {||}\""], "translations": [["", "lemmas transitions = select_def coin_def vend_def vend_fail_def"], ["", "lemma apply_updates_vend: \"apply_updates (Updates vend) (join_ir [] r) r = r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. evaluate_updates vend [] r = r", "by (simp add: vend_def apply_updates_def)"], ["", "lemma drinks_states: \"S drinks = {|0, 1, 2|}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S drinks = {|0, 1, 2|}", "apply (simp add: S_def drinks_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. {|1, 2, 0, 1|} = {|0, 1, 2|}", "by auto"], ["", "lemma possible_steps_0:\n  \"length i = 1 \\<Longrightarrow>\n   possible_steps drinks 0 r (STR ''select'') i = {|(1, select)|}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length i = 1 \\<Longrightarrow>\n    possible_steps drinks 0 r STR ''select'' i = {|(1, select)|}", "apply (simp add: possible_steps_singleton drinks_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. length i = 1 \\<Longrightarrow>\n    {((origin, dest), t).\n     (origin = 0 \\<and> dest = 1 \\<and> t = select \\<or>\n      origin = 1 \\<and> dest = 1 \\<and> t = coin \\<or>\n      origin = 1 \\<and> dest = 1 \\<and> t = vend_fail \\<or>\n      origin = 1 \\<and> dest = 2 \\<and> t = vend) \\<and>\n     origin = 0 \\<and>\n     Label t = STR ''select'' \\<and>\n     Arity t = 1 \\<and> apply_guards (Guards t) (join_ir i r)} =\n    {((0, 1), select)}", "apply safe"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>a b ba.\n       \\<lbrakk>length i = 1; ((0, 1), coin) \\<notin> {};\n        Label coin = STR ''select''; Arity coin = 1;\n        apply_guards (Guards coin) (join_ir i r); 0 = 1\\<rbrakk>\n       \\<Longrightarrow> coin = select\n 2. \\<And>a b ba.\n       \\<lbrakk>length i = 1; ((0, 1), vend_fail) \\<notin> {};\n        Label vend_fail = STR ''select''; Arity vend_fail = 1;\n        apply_guards (Guards vend_fail) (join_ir i r); 0 = 1\\<rbrakk>\n       \\<Longrightarrow> vend_fail = select\n 3. \\<And>a b ba.\n       \\<lbrakk>length i = 1; ((0, 2), vend) \\<notin> {};\n        Label vend = STR ''select''; Arity vend = 1;\n        apply_guards (Guards vend) (join_ir i r); 0 = 1\\<rbrakk>\n       \\<Longrightarrow> 2 = 1\n 4. \\<And>a b ba.\n       \\<lbrakk>length i = 1; ((0, 2), vend) \\<notin> {};\n        Label vend = STR ''select''; Arity vend = 1;\n        apply_guards (Guards vend) (join_ir i r); 0 = 1\\<rbrakk>\n       \\<Longrightarrow> vend = select\n 5. \\<And>a b ba.\n       length i = 1 \\<Longrightarrow> Label select = STR ''select''\n 6. \\<And>a b ba. length i = 1 \\<Longrightarrow> Arity select = 1\n 7. \\<And>a b ba.\n       length i = 1 \\<Longrightarrow>\n       apply_guards (Guards select) (join_ir i r)", "by (simp_all add: transitions apply_guards_def)"], ["", "lemma first_step_select:\n  \"(s', t) |\\<in>| possible_steps drinks 0 r aa b \\<Longrightarrow> s' = 1 \\<and> t = select\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (s', t) |\\<in>| possible_steps drinks 0 r aa b \\<Longrightarrow>\n    s' = 1 \\<and> t = select", "apply (simp add: possible_steps_def fimage_def ffilter_def fmember_def Abs_fset_inverse Set.filter_def drinks_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (s', t)\n    \\<in> case_prod (\\<lambda>(origin, y). Pair y) `\n          {a. (a = ((0, 1), select) \\<or>\n               a = ((1, 1), coin) \\<or>\n               a = ((1, 1), vend_fail) \\<or> a = ((1, 2), vend)) \\<and>\n              (case a of\n               (x, xa) \\<Rightarrow>\n                 (case x of\n                  (origin, dest) \\<Rightarrow>\n                    \\<lambda>t.\n                       origin = 0 \\<and>\n                       Label t = aa \\<and>\n                       length b = Arity t \\<and>\n                       apply_guards (Guards t) (join_ir b r))\n                  xa)} \\<Longrightarrow>\n    s' = 1 \\<and> t = select", "apply safe"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a ba baa.\n       \\<lbrakk>aa = Label coin; length b = Arity coin;\n        apply_guards (Guards coin) (join_ir b r); t = coin; 0 = 1;\n        s' = 1\\<rbrakk>\n       \\<Longrightarrow> coin = select\n 2. \\<And>a ba baa.\n       \\<lbrakk>aa = Label vend_fail; length b = Arity vend_fail;\n        apply_guards (Guards vend_fail) (join_ir b r); t = vend_fail; 0 = 1;\n        s' = 1\\<rbrakk>\n       \\<Longrightarrow> vend_fail = select\n 3. \\<And>a ba baa.\n       \\<lbrakk>aa = Label vend; length b = Arity vend;\n        apply_guards (Guards vend) (join_ir b r); t = vend; 0 = 1;\n        s' = 2\\<rbrakk>\n       \\<Longrightarrow> 2 = 1\n 4. \\<And>a ba baa.\n       \\<lbrakk>aa = Label vend; length b = Arity vend;\n        apply_guards (Guards vend) (join_ir b r); t = vend; 0 = 1;\n        s' = 2\\<rbrakk>\n       \\<Longrightarrow> vend = select", "by (simp_all add: transitions)"], ["", "lemma drinks_vend_insufficient:\n  \"r $ 2 = Some (Num x1) \\<Longrightarrow>\n   x1 < 100 \\<Longrightarrow>\n   possible_steps drinks 1 r (STR ''vend'') [] = {|(1, vend_fail)|}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>r $ 2 = Some (Num x1); x1 < 100\\<rbrakk>\n    \\<Longrightarrow> possible_steps drinks 1 r STR ''vend'' [] =\n                      {|(1, vend_fail)|}", "apply (simp add: possible_steps_singleton drinks_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>r $ 2 = Some (Num x1); x1 < 100\\<rbrakk>\n    \\<Longrightarrow> {((origin, dest), t).\n                       (origin = 0 \\<and> dest = 1 \\<and> t = select \\<or>\n                        origin = 1 \\<and> dest = 1 \\<and> t = coin \\<or>\n                        origin = 1 \\<and>\n                        dest = 1 \\<and> t = vend_fail \\<or>\n                        origin = 1 \\<and> dest = 2 \\<and> t = vend) \\<and>\n                       origin = 1 \\<and>\n                       Label t = STR ''vend'' \\<and>\n                       Arity t = 0 \\<and>\n                       apply_guards (Guards t) (join_ir [] r)} =\n                      {((1, 1), vend_fail)}", "apply safe"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>a b ba.\n       \\<lbrakk>r $ 2 = Some (Num x1); x1 < 100;\n        ((1, 1), select) \\<notin> {}; Label select = STR ''vend'';\n        Arity select = 0; apply_guards (Guards select) (join_ir [] r);\n        1 = 0\\<rbrakk>\n       \\<Longrightarrow> select = vend_fail\n 2. \\<And>a b ba.\n       \\<lbrakk>r $ 2 = Some (Num x1); x1 < 100; ((1, 1), coin) \\<notin> {};\n        Label coin = STR ''vend''; Arity coin = 0;\n        apply_guards (Guards coin) (join_ir [] r)\\<rbrakk>\n       \\<Longrightarrow> coin = vend_fail\n 3. \\<And>a b ba.\n       \\<lbrakk>r $ 2 = Some (Num x1); x1 < 100; ((1, 2), vend) \\<notin> {};\n        Label vend = STR ''vend''; Arity vend = 0;\n        apply_guards (Guards vend) (join_ir [] r)\\<rbrakk>\n       \\<Longrightarrow> 2 = 1\n 4. \\<And>a b ba.\n       \\<lbrakk>r $ 2 = Some (Num x1); x1 < 100; ((1, 2), vend) \\<notin> {};\n        Label vend = STR ''vend''; Arity vend = 0;\n        apply_guards (Guards vend) (join_ir [] r)\\<rbrakk>\n       \\<Longrightarrow> vend = vend_fail\n 5. \\<And>a b ba.\n       \\<lbrakk>r $ 2 = Some (Num x1); x1 < 100\\<rbrakk>\n       \\<Longrightarrow> Label vend_fail = STR ''vend''\n 6. \\<And>a b ba.\n       \\<lbrakk>r $ 2 = Some (Num x1); x1 < 100\\<rbrakk>\n       \\<Longrightarrow> Arity vend_fail = 0\n 7. \\<And>a b ba.\n       \\<lbrakk>r $ 2 = Some (Num x1); x1 < 100\\<rbrakk>\n       \\<Longrightarrow> apply_guards (Guards vend_fail) (join_ir [] r)", "by (simp_all add: transitions apply_guards_def value_gt_def join_ir_def connectives)"], ["", "lemma drinks_vend_invalid:\n  \"\\<nexists>n. r $ 2 = Some (Num n) \\<Longrightarrow>\n   possible_steps drinks 1 r (STR ''vend'') [] = {||}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nexists>n. r $ 2 = Some (Num n) \\<Longrightarrow>\n    possible_steps drinks 1 r STR ''vend'' [] = {||}", "apply (simp add: possible_steps_empty drinks_def can_take_transition_def can_take_def transitions)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n. r $ 2 \\<noteq> Some (Num n) \\<Longrightarrow>\n    value_gt (Some (Num 100)) (r $ 2) \\<noteq> true \\<and>\n    \\<not>? value_gt (Some (Num 100)) (r $ 2) \\<noteq> true", "by (simp add: MaybeBoolInt_not_num_1 value_gt_def)"], ["", "lemma possible_steps_1_coin:\n  \"length i = 1 \\<Longrightarrow> possible_steps drinks 1 r (STR ''coin'') i = {|(1, coin)|}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length i = 1 \\<Longrightarrow>\n    possible_steps drinks 1 r STR ''coin'' i = {|(1, coin)|}", "apply (simp add: possible_steps_singleton drinks_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. length i = 1 \\<Longrightarrow>\n    {((origin, dest), t).\n     (origin = 0 \\<and> dest = 1 \\<and> t = select \\<or>\n      origin = 1 \\<and> dest = 1 \\<and> t = coin \\<or>\n      origin = 1 \\<and> dest = 1 \\<and> t = vend_fail \\<or>\n      origin = 1 \\<and> dest = 2 \\<and> t = vend) \\<and>\n     origin = 1 \\<and>\n     Label t = STR ''coin'' \\<and>\n     Arity t = 1 \\<and> apply_guards (Guards t) (join_ir i r)} =\n    {((1, 1), coin)}", "apply safe"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>a b ba.\n       \\<lbrakk>length i = 1; ((1, 1), select) \\<notin> {};\n        Label select = STR ''coin''; Arity select = 1;\n        apply_guards (Guards select) (join_ir i r); 1 = 0\\<rbrakk>\n       \\<Longrightarrow> select = coin\n 2. \\<And>a b ba.\n       \\<lbrakk>length i = 1; ((1, 1), vend_fail) \\<notin> {};\n        Label vend_fail = STR ''coin''; Arity vend_fail = 1;\n        apply_guards (Guards vend_fail) (join_ir i r)\\<rbrakk>\n       \\<Longrightarrow> vend_fail = coin\n 3. \\<And>a b ba.\n       \\<lbrakk>length i = 1; ((1, 2), vend) \\<notin> {};\n        Label vend = STR ''coin''; Arity vend = 1;\n        apply_guards (Guards vend) (join_ir i r)\\<rbrakk>\n       \\<Longrightarrow> 2 = 1\n 4. \\<And>a b ba.\n       \\<lbrakk>length i = 1; ((1, 2), vend) \\<notin> {};\n        Label vend = STR ''coin''; Arity vend = 1;\n        apply_guards (Guards vend) (join_ir i r)\\<rbrakk>\n       \\<Longrightarrow> vend = coin\n 5. \\<And>a b ba. length i = 1 \\<Longrightarrow> Label coin = STR ''coin''\n 6. \\<And>a b ba. length i = 1 \\<Longrightarrow> Arity coin = 1\n 7. \\<And>a b ba.\n       length i = 1 \\<Longrightarrow>\n       apply_guards (Guards coin) (join_ir i r)", "by (simp_all add: transitions)"], ["", "lemma possible_steps_2_vend:\n  \"\\<exists>n. r $ 2 = Some (Num n) \\<and> n \\<ge> 100 \\<Longrightarrow>\n   possible_steps drinks 1 r (STR ''vend'') [] = {|(2, vend)|}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>n. r $ 2 = Some (Num n) \\<and> 100 \\<le> n \\<Longrightarrow>\n    possible_steps drinks 1 r STR ''vend'' [] = {|(2, vend)|}", "apply (simp add: possible_steps_singleton drinks_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>n. r $ 2 = Some (Num n) \\<and> 100 \\<le> n \\<Longrightarrow>\n    {((origin, dest), t).\n     (origin = 0 \\<and> dest = 1 \\<and> t = select \\<or>\n      origin = 1 \\<and> dest = 1 \\<and> t = coin \\<or>\n      origin = 1 \\<and> dest = 1 \\<and> t = vend_fail \\<or>\n      origin = 1 \\<and> dest = 2 \\<and> t = vend) \\<and>\n     origin = 1 \\<and>\n     Label t = STR ''vend'' \\<and>\n     Arity t = 0 \\<and> apply_guards (Guards t) (join_ir [] r)} =\n    {((1, 2), vend)}", "apply safe"], ["proof (prove)\ngoal (9 subgoals):\n 1. \\<And>n a b ba.\n       \\<lbrakk>r $ 2 = Some (Num n); 100 \\<le> n;\n        ((1, 1), select) \\<notin> {}; Label select = STR ''vend'';\n        Arity select = 0; apply_guards (Guards select) (join_ir [] r);\n        1 = 0\\<rbrakk>\n       \\<Longrightarrow> 1 = 2\n 2. \\<And>n a b ba.\n       \\<lbrakk>r $ 2 = Some (Num n); 100 \\<le> n;\n        ((1, 1), select) \\<notin> {}; Label select = STR ''vend'';\n        Arity select = 0; apply_guards (Guards select) (join_ir [] r);\n        1 = 0\\<rbrakk>\n       \\<Longrightarrow> select = vend\n 3. \\<And>n a b ba.\n       \\<lbrakk>r $ 2 = Some (Num n); 100 \\<le> n;\n        ((1, 1), coin) \\<notin> {}; Label coin = STR ''vend'';\n        Arity coin = 0; apply_guards (Guards coin) (join_ir [] r)\\<rbrakk>\n       \\<Longrightarrow> 1 = 2\n 4. \\<And>n a b ba.\n       \\<lbrakk>r $ 2 = Some (Num n); 100 \\<le> n;\n        ((1, 1), coin) \\<notin> {}; Label coin = STR ''vend'';\n        Arity coin = 0; apply_guards (Guards coin) (join_ir [] r)\\<rbrakk>\n       \\<Longrightarrow> coin = vend\n 5. \\<And>n a b ba.\n       \\<lbrakk>r $ 2 = Some (Num n); 100 \\<le> n;\n        ((1, 1), vend_fail) \\<notin> {}; Label vend_fail = STR ''vend'';\n        Arity vend_fail = 0;\n        apply_guards (Guards vend_fail) (join_ir [] r)\\<rbrakk>\n       \\<Longrightarrow> 1 = 2\n 6. \\<And>n a b ba.\n       \\<lbrakk>r $ 2 = Some (Num n); 100 \\<le> n;\n        ((1, 1), vend_fail) \\<notin> {}; Label vend_fail = STR ''vend'';\n        Arity vend_fail = 0;\n        apply_guards (Guards vend_fail) (join_ir [] r)\\<rbrakk>\n       \\<Longrightarrow> vend_fail = vend\n 7. \\<And>n a b ba.\n       \\<lbrakk>r $ 2 = Some (Num n); 100 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> Label vend = STR ''vend''\n 8. \\<And>n a b ba.\n       \\<lbrakk>r $ 2 = Some (Num n); 100 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> Arity vend = 0\n 9. \\<And>n a b ba.\n       \\<lbrakk>r $ 2 = Some (Num n); 100 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> apply_guards (Guards vend) (join_ir [] r)", "by (simp_all add: transitions apply_guards_def value_gt_def join_ir_def connectives)"], ["", "lemma recognises_from_2:\n  \"recognises_execution drinks 1 <1 $:= d, 2 $:= Some (Num 100)> [(STR ''vend'', [])]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. recognises_execution drinks 1 <1 $:= d, 2 $:= Some (Num 100)>\n     [(STR ''vend'', [])]", "apply (rule recognises_execution.step)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>(s', T)\n             |\\<in>|possible_steps drinks 1 <1 $:= d, 2 $:= Some (Num 100)>\n                     STR ''vend'' [].\n       recognises_execution drinks s'\n        (evaluate_updates T [] <1 $:= d, 2 $:= Some (Num 100)>) []", "apply (rule_tac x=\"(2, vend)\" in fBexI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. case (2, vend) of\n    (s', T) \\<Rightarrow>\n      recognises_execution drinks s'\n       (evaluate_updates T [] <1 $:= d, 2 $:= Some (Num 100)>) []\n 2. (2, vend) |\\<in>|\n    possible_steps drinks 1 <1 $:= d, 2 $:= Some (Num 100)> STR ''vend'' []", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. (2, vend) |\\<in>|\n    possible_steps drinks 1 <1 $:= d, 2 $:= Some (Num 100)> STR ''vend'' []", "by (simp add: possible_steps_2_vend)"], ["", "lemma recognises_from_1a:\n  \"recognises_execution drinks 1 <1 $:= d, 2 $:= Some (Num 50)> [(STR ''coin'', [Num 50]), (STR ''vend'', [])]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. recognises_execution drinks 1 <1 $:= d, 2 $:= Some (Num 50)>\n     [(STR ''coin'', [Num 50]), (STR ''vend'', [])]", "apply (rule recognises_execution.step)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>(s', T)\n             |\\<in>|possible_steps drinks 1 <1 $:= d, 2 $:= Some (Num 50)>\n                     STR ''coin'' [Num 50].\n       recognises_execution drinks s'\n        (evaluate_updates T [Num 50] <1 $:= d, 2 $:= Some (Num 50)>)\n        [(STR ''vend'', [])]", "apply (rule_tac x=\"(1, coin)\" in fBexI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. case (1, coin) of\n    (s', T) \\<Rightarrow>\n      recognises_execution drinks s'\n       (evaluate_updates T [Num 50] <1 $:= d, 2 $:= Some (Num 50)>)\n       [(STR ''vend'', [])]\n 2. (1, coin) |\\<in>|\n    possible_steps drinks 1 <1 $:= d, 2 $:= Some (Num 50)> STR ''coin''\n     [Num 50]", "apply (simp add: apply_updates_def coin_def finfun_update_twist value_plus_def recognises_from_2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (1, coin) |\\<in>|\n    possible_steps drinks 1 <1 $:= d, 2 $:= Some (Num 50)> STR ''coin''\n     [Num 50]", "by (simp add: possible_steps_1_coin)"], ["", "lemma recognises_from_1: \"recognises_execution drinks 1 <2 $:= Some (Num 0), 1 $:= Some d>\n     [(STR ''coin'', [Num 50]), (STR ''coin'', [Num 50]), (STR ''vend'', [])]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. recognises_execution drinks 1 <2 $:= Some (Num 0), 1 $:= Some d>\n     [(STR ''coin'', [Num 50]), (STR ''coin'', [Num 50]),\n      (STR ''vend'', [])]", "apply (rule recognises_execution.step)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>(s', T)\n             |\\<in>|possible_steps drinks 1 <2 $:= Some (Num 0),\n                     1 $:= Some d> STR ''coin'' [Num 50].\n       recognises_execution drinks s'\n        (evaluate_updates T [Num 50] <2 $:= Some (Num 0), 1 $:= Some d>)\n        [(STR ''coin'', [Num 50]), (STR ''vend'', [])]", "apply (rule_tac x=\"(1, coin)\" in fBexI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. case (1, coin) of\n    (s', T) \\<Rightarrow>\n      recognises_execution drinks s'\n       (evaluate_updates T [Num 50] <2 $:= Some (Num 0), 1 $:= Some d>)\n       [(STR ''coin'', [Num 50]), (STR ''vend'', [])]\n 2. (1, coin) |\\<in>|\n    possible_steps drinks 1 <2 $:= Some (Num 0), 1 $:= Some d> STR ''coin''\n     [Num 50]", "apply (simp add: apply_updates_def coin_def value_plus_def finfun_update_twist recognises_from_1a)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (1, coin) |\\<in>|\n    possible_steps drinks 1 <2 $:= Some (Num 0), 1 $:= Some d> STR ''coin''\n     [Num 50]", "by (simp add: possible_steps_1_coin)"], ["", "lemma purchase_coke:\n  \"observe_execution drinks 0 <> [(STR ''select'', [Str ''coke'']), (STR ''coin'', [Num 50]), (STR ''coin'', [Num 50]), (STR ''vend'', [])] =\n                       [[], [Some (Num 50)], [Some (Num 100)], [Some (Str ''coke'')]]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. observe_execution drinks 0 <>\n     [(STR ''select'', [EFSM.Str ''coke'']), (STR ''coin'', [Num 50]),\n      (STR ''coin'', [Num 50]), (STR ''vend'', [])] =\n    [[], [Some (Num 50)], [Some (Num 100)], [Some (EFSM.Str ''coke'')]]", "by (simp add: possible_steps_0 possible_steps_1_coin possible_steps_2_vend transitions\n                   apply_outputs_def apply_updates_def value_plus_def)"], ["", "lemma rejects_input:\n  \"l \\<noteq> STR ''coin'' \\<Longrightarrow>\n   l \\<noteq> STR ''vend'' \\<Longrightarrow>\n   \\<not> recognises_execution drinks 1 d' [(l, i)]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>l \\<noteq> STR ''coin''; l \\<noteq> STR ''vend''\\<rbrakk>\n    \\<Longrightarrow> \\<not> recognises_execution drinks 1 d' [(l, i)]", "apply (rule no_possible_steps_rejects)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>l \\<noteq> STR ''coin''; l \\<noteq> STR ''vend''\\<rbrakk>\n    \\<Longrightarrow> possible_steps drinks 1 d' l i = {||}", "by (simp add: possible_steps_empty drinks_def can_take_transition_def can_take_def transitions)"], ["", "lemma rejects_recognises_prefix: \"l \\<noteq> STR ''coin'' \\<Longrightarrow>\n   l \\<noteq> STR ''vend'' \\<Longrightarrow>\n   \\<not> (recognises drinks [(STR ''select'', [Str ''coke'']), (l, i)])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>l \\<noteq> STR ''coin''; l \\<noteq> STR ''vend''\\<rbrakk>\n    \\<Longrightarrow> \\<not> recognises drinks\n                              [(STR ''select'', [EFSM.Str ''coke'']),\n                               (l, i)]", "apply (rule trace_reject_later)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>l \\<noteq> STR ''coin''; l \\<noteq> STR ''vend''\\<rbrakk>\n    \\<Longrightarrow> \\<forall>(s', T)\n                               |\\<in>|possible_steps drinks 0 <>\n STR ''select'' [EFSM.Str ''coke''].\n                         \\<not> recognises_execution drinks s'\n                                 (evaluate_updates T [EFSM.Str ''coke''] <>)\n                                 [(l, i)]", "apply (simp add: possible_steps_0 select_def join_ir_def input2state_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>l \\<noteq> STR ''coin''; l \\<noteq> STR ''vend''\\<rbrakk>\n    \\<Longrightarrow> \\<not> recognises_execution drinks 1\n                              (apply_updates [(1, V (I 0)), (2, L (Num 0))]\n                                (case_vname\n                                  (($) ((K$ None)\n  (0 $:= Some (EFSM.Str ''coke''))))\n                                  (($) <>))\n                                <>)\n                              [(l, i)]", "using rejects_input"], ["proof (prove)\nusing this:\n  \\<lbrakk>?l \\<noteq> STR ''coin''; ?l \\<noteq> STR ''vend''\\<rbrakk>\n  \\<Longrightarrow> \\<not> recognises_execution drinks 1 ?d' [(?l, ?i)]\n\ngoal (1 subgoal):\n 1. \\<lbrakk>l \\<noteq> STR ''coin''; l \\<noteq> STR ''vend''\\<rbrakk>\n    \\<Longrightarrow> \\<not> recognises_execution drinks 1\n                              (apply_updates [(1, V (I 0)), (2, L (Num 0))]\n                                (case_vname\n                                  (($) ((K$ None)\n  (0 $:= Some (EFSM.Str ''coke''))))\n                                  (($) <>))\n                                <>)\n                              [(l, i)]", "by blast"], ["", "lemma rejects_termination:\n  \"observe_execution drinks 0 <> [(STR ''select'', [Str ''coke'']), (STR ''rejects'', [Num 50]), (STR ''coin'', [Num 50])] = [[]]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. observe_execution drinks 0 <>\n     [(STR ''select'', [EFSM.Str ''coke'']), (STR ''rejects'', [Num 50]),\n      (STR ''coin'', [Num 50])] =\n    [[]]", "apply (rule observe_execution_step)"], ["proof (prove)\ngoal (2 subgoals):\n 1. step drinks 0 <> (fst (STR ''select'', [EFSM.Str ''coke'']))\n     (snd (STR ''select'', [EFSM.Str ''coke''])) =\n    Some (?t, ?s', [], ?r')\n 2. observe_execution drinks ?s' ?r'\n     [(STR ''rejects'', [Num 50]), (STR ''coin'', [Num 50])] =\n    []", "apply (simp add: step_def possible_steps_0 select_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. observe_execution drinks 1\n     (apply_updates [(1, V (I 0)), (2, L (Num 0))]\n       (join_ir [EFSM.Str ''coke''] <>) <>)\n     [(STR ''rejects'', [Num 50]), (STR ''coin'', [Num 50])] =\n    []", "apply (rule observe_execution_no_possible_step)"], ["proof (prove)\ngoal (1 subgoal):\n 1. possible_steps drinks 1\n     (apply_updates [(1, V (I 0)), (2, L (Num 0))]\n       (join_ir [EFSM.Str ''coke''] <>) <>)\n     (fst (STR ''rejects'', [Num 50])) (snd (STR ''rejects'', [Num 50])) =\n    {||}", "by (simp add: possible_steps_empty drinks_def can_take_transition_def can_take_def transitions)"], ["", "(* Part of Example 2 in Foster et. al. *)"], ["", "lemma r2_0_vend:\n  \"can_take_transition vend i r \\<Longrightarrow>\n   \\<exists>n. r $ 2 = Some (Num n) \\<and> n \\<ge> 100\""], ["proof (prove)\ngoal (1 subgoal):\n 1. can_take_transition vend i r \\<Longrightarrow>\n    \\<exists>n. r $ 2 = Some (Num n) \\<and> 100 \\<le> n", "(* You can't take vendimmediately after taking select *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. can_take_transition vend i r \\<Longrightarrow>\n    \\<exists>n. r $ 2 = Some (Num n) \\<and> 100 \\<le> n", "apply (simp add: can_take_transition_def can_take_def vend_def apply_guards_def maybe_negate_true maybe_or_false connectives value_gt_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. i = [] \\<and>\n    MaybeBoolInt (\\<lambda>x y. y < x) (Some (Num 100)) (r $ 2) =\n    false \\<Longrightarrow>\n    \\<exists>n. r $ 2 = Some (Num n) \\<and> 100 \\<le> n", "using MaybeBoolInt.elims"], ["proof (prove)\nusing this:\n  \\<lbrakk>MaybeBoolInt ?x ?xa ?xb = ?y;\n   \\<And>f a b.\n      \\<lbrakk>?x = f; ?xa = Some (Num a); ?xb = Some (Num b);\n       ?y = (if f a b then true else false)\\<rbrakk>\n      \\<Longrightarrow> ?P;\n   \\<And>uu_ uw_.\n      \\<lbrakk>?x = uu_; ?xa = None; ?xb = uw_; ?y = invalid\\<rbrakk>\n      \\<Longrightarrow> ?P;\n   \\<And>uu_ va uw_.\n      \\<lbrakk>?x = uu_; ?xa = Some (value.Str va); ?xb = uw_;\n       ?y = invalid\\<rbrakk>\n      \\<Longrightarrow> ?P;\n   \\<And>uu_ uv_.\n      \\<lbrakk>?x = uu_; ?xa = uv_; ?xb = None; ?y = invalid\\<rbrakk>\n      \\<Longrightarrow> ?P;\n   \\<And>uu_ uv_ va.\n      \\<lbrakk>?x = uu_; ?xa = uv_; ?xb = Some (value.Str va);\n       ?y = invalid\\<rbrakk>\n      \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. i = [] \\<and>\n    MaybeBoolInt (\\<lambda>x y. y < x) (Some (Num 100)) (r $ 2) =\n    false \\<Longrightarrow>\n    \\<exists>n. r $ 2 = Some (Num n) \\<and> 100 \\<le> n", "by force"], ["", "lemma drinks_vend_sufficient: \"r $ 2 = Some (Num x1) \\<Longrightarrow>\n                x1 \\<ge> 100 \\<Longrightarrow>\n                possible_steps drinks 1 r (STR ''vend'') [] = {|(2, vend)|}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>r $ 2 = Some (Num x1); 100 \\<le> x1\\<rbrakk>\n    \\<Longrightarrow> possible_steps drinks 1 r STR ''vend'' [] =\n                      {|(2, vend)|}", "using possible_steps_2_vend"], ["proof (prove)\nusing this:\n  \\<exists>n. ?r $ 2 = Some (Num n) \\<and> 100 \\<le> n \\<Longrightarrow>\n  possible_steps drinks 1 ?r STR ''vend'' [] = {|(2, vend)|}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>r $ 2 = Some (Num x1); 100 \\<le> x1\\<rbrakk>\n    \\<Longrightarrow> possible_steps drinks 1 r STR ''vend'' [] =\n                      {|(2, vend)|}", "by blast"], ["", "lemma drinks_end: \"possible_steps drinks 2 r a b = {||}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. possible_steps drinks 2 r a b = {||}", "apply (simp add: possible_steps_def drinks_def transitions)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ffilter\n     (\\<lambda>((origin, dest), t).\n         origin = 2 \\<and>\n         Label t = a \\<and>\n         length b = Arity t \\<and> apply_guards (Guards t) (join_ir b r))\n     {|((0, 1),\n        \\<lparr>Label = STR ''select'', Arity = 1, Guards = [],\n           Outputs = [], Updates = [(1, V (I 0)), (2, L (Num 0))]\\<rparr>),\n       ((1, 1),\n        \\<lparr>Label = STR ''coin'', Arity = 1, Guards = [],\n           Outputs = [Plus (V (R 2)) (V (I 0))],\n           Updates = [(1, V (R 1)), (2, Plus (V (R 2)) (V (I 0)))]\\<rparr>),\n       ((1, 1),\n        \\<lparr>Label = STR ''vend'', Arity = 0,\n           Guards = [Lt (V (R 2)) (L (Num 100))], Outputs = [],\n           Updates = [(1, V (R 1)), (2, V (R 2))]\\<rparr>),\n       ((1, 2),\n        \\<lparr>Label = STR ''vend'', Arity = 0,\n           Guards = [Ge (V (R 2)) (L (Num 100))], Outputs = [V (R 1)],\n           Updates = [(1, V (R 1)), (2, V (R 2))]\\<rparr>)|} =\n    {||}", "by force"], ["", "lemma drinks_vend_r2_String:\n  \"r $ 2 = Some (value.Str x2) \\<Longrightarrow>\n   possible_steps drinks 1 r (STR ''vend'') [] = {||}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r $ 2 = Some (value.Str x2) \\<Longrightarrow>\n    possible_steps drinks 1 r STR ''vend'' [] = {||}", "apply (simp add: possible_steps_empty drinks_def can_take_transition_def can_take_def transitions)"], ["proof (prove)\ngoal (1 subgoal):\n 1. r $ 2 = Some (value.Str x2) \\<Longrightarrow>\n    value_gt (Some (Num 100)) (Some (value.Str x2)) \\<noteq> true \\<and>\n    \\<not>? value_gt (Some (Num 100)) (Some (value.Str x2)) \\<noteq> true", "by (simp add: value_gt_def)"], ["", "lemma drinks_vend_r2_rejects:\n  \"\\<nexists>n. r $ 2 = Some (Num n) \\<Longrightarrow> step drinks 1 r (STR ''vend'') [] = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nexists>n. r $ 2 = Some (Num n) \\<Longrightarrow>\n    step drinks 1 r STR ''vend'' [] = None", "apply (rule no_possible_steps_1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nexists>n. r $ 2 = Some (Num n) \\<Longrightarrow>\n    possible_steps drinks 1 r STR ''vend'' [] = {||}", "apply (simp add: possible_steps_empty drinks_def can_take_transition_def can_take_def transitions)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n. r $ 2 \\<noteq> Some (Num n) \\<Longrightarrow>\n    value_gt (Some (Num 100)) (r $ 2) \\<noteq> true \\<and>\n    \\<not>? value_gt (Some (Num 100)) (r $ 2) \\<noteq> true", "by (simp add: MaybeBoolInt_not_num_1 value_gt_def)"], ["", "lemma drinks_0_rejects:\n  \"\\<not> (fst a = STR ''select'' \\<and> length (snd a) = 1) \\<Longrightarrow>\n    (possible_steps drinks 0 r (fst a) (snd a)) = {||}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (fst a = STR ''select'' \\<and>\n            length (snd a) = 1) \\<Longrightarrow>\n    possible_steps drinks 0 r (fst a) (snd a) = {||}", "apply (simp add: drinks_def possible_steps_def transitions)"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst a = STR ''select'' \\<longrightarrow>\n    length (snd a) \\<noteq> 1 \\<Longrightarrow>\n    ffilter\n     (\\<lambda>((origin, dest), t).\n         origin = 0 \\<and>\n         Label t = fst a \\<and>\n         length (snd a) = Arity t \\<and>\n         apply_guards (Guards t) (join_ir (snd a) r))\n     {|((0, 1),\n        \\<lparr>Label = STR ''select'', Arity = 1, Guards = [],\n           Outputs = [], Updates = [(1, V (I 0)), (2, L (Num 0))]\\<rparr>),\n       ((1, 1),\n        \\<lparr>Label = STR ''coin'', Arity = 1, Guards = [],\n           Outputs = [Plus (V (R 2)) (V (I 0))],\n           Updates = [(1, V (R 1)), (2, Plus (V (R 2)) (V (I 0)))]\\<rparr>),\n       ((1, 1),\n        \\<lparr>Label = STR ''vend'', Arity = 0,\n           Guards = [Lt (V (R 2)) (L (Num 100))], Outputs = [],\n           Updates = [(1, V (R 1)), (2, V (R 2))]\\<rparr>),\n       ((1, 2),\n        \\<lparr>Label = STR ''vend'', Arity = 0,\n           Guards = [Ge (V (R 2)) (L (Num 100))], Outputs = [V (R 1)],\n           Updates = [(1, V (R 1)), (2, V (R 2))]\\<rparr>)|} =\n    {||}", "by force"], ["", "lemma drinks_vend_empty: \"(possible_steps drinks 0 <> (STR ''vend'') []) = {||}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. possible_steps drinks 0 <> STR ''vend'' [] = {||}", "using drinks_0_rejects"], ["proof (prove)\nusing this:\n  \\<not> (fst ?a = STR ''select'' \\<and>\n          length (snd ?a) = 1) \\<Longrightarrow>\n  possible_steps drinks 0 ?r (fst ?a) (snd ?a) = {||}\n\ngoal (1 subgoal):\n 1. possible_steps drinks 0 <> STR ''vend'' [] = {||}", "by auto"], ["", "lemma drinks_1_rejects:\n  \"fst a = STR ''coin'' \\<longrightarrow> length (snd a) \\<noteq> 1 \\<Longrightarrow>\n          a \\<noteq> (STR ''vend'', []) \\<Longrightarrow>\n          possible_steps drinks 1 r (fst a) (snd a) = {||}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>fst a = STR ''coin'' \\<longrightarrow>\n             length (snd a) \\<noteq> 1;\n     a \\<noteq> (STR ''vend'', [])\\<rbrakk>\n    \\<Longrightarrow> possible_steps drinks 1 r (fst a) (snd a) = {||}", "apply (simp add: possible_steps_empty drinks_def can_take_transition_def can_take_def transitions)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>fst a = STR ''coin'' \\<longrightarrow>\n             length (snd a) \\<noteq> 1;\n     a \\<noteq> (STR ''vend'', [])\\<rbrakk>\n    \\<Longrightarrow> (length (snd a) = 1 \\<longrightarrow>\n                       STR ''coin'' \\<noteq> fst a) \\<and>\n                      (snd a = [] \\<longrightarrow>\n                       STR ''vend'' = fst a \\<longrightarrow>\n                       value_gt (Some (Num 100)) (r $ 2) \\<noteq>\n                       true) \\<and>\n                      (snd a = [] \\<longrightarrow>\n                       STR ''vend'' = fst a \\<longrightarrow>\n                       \\<not>? value_gt (Some (Num 100)) (r $ 2) \\<noteq>\n                       true)", "by (metis prod.collapse)"], ["", "lemma drinks_rejects_future: \"\\<not> recognises_execution drinks 2 d ((l, i)#t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> recognises_execution drinks 2 d ((l, i) # t)", "apply (rule no_possible_steps_rejects)"], ["proof (prove)\ngoal (1 subgoal):\n 1. possible_steps drinks 2 d l i = {||}", "by (simp add: possible_steps_empty drinks_def)"], ["", "lemma drinks_1_rejects_trace:\n  assumes not_vend: \"e \\<noteq> (STR ''vend'', [])\"\n      and not_coin: \"\\<nexists>i. e = (STR ''coin'', [i])\"\n  shows \"\\<not> recognises_execution drinks 1 r (e # es)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> recognises_execution drinks 1 r (e # es)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> recognises_execution drinks 1 r (e # es)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> recognises_execution drinks 1 r (e # es)", "apply (cases e, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       e = (a, b) \\<Longrightarrow>\n       \\<not> recognises_execution drinks 1 r ((a, b) # es)", "subgoal for a b"], ["proof (prove)\ngoal (1 subgoal):\n 1. e = (a, b) \\<Longrightarrow>\n    \\<not> recognises_execution drinks 1 r ((a, b) # es)", "apply (rule no_possible_steps_rejects)"], ["proof (prove)\ngoal (1 subgoal):\n 1. e = (a, b) \\<Longrightarrow> possible_steps drinks 1 r a b = {||}", "apply (simp add: possible_steps_empty drinks_def can_take_transition_def can_take_def transitions)"], ["proof (prove)\ngoal (1 subgoal):\n 1. e = (a, b) \\<Longrightarrow>\n    (length b = 1 \\<longrightarrow> STR ''coin'' \\<noteq> a) \\<and>\n    (b = [] \\<longrightarrow>\n     STR ''vend'' = a \\<longrightarrow>\n     value_gt (Some (Num 100)) (r $ 2) \\<noteq> true) \\<and>\n    (b = [] \\<longrightarrow>\n     STR ''vend'' = a \\<longrightarrow>\n     \\<not>? value_gt (Some (Num 100)) (r $ 2) \\<noteq> true)", "apply (case_tac b)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>e = (a, b); b = []\\<rbrakk>\n    \\<Longrightarrow> (length b = 1 \\<longrightarrow>\n                       STR ''coin'' \\<noteq> a) \\<and>\n                      (b = [] \\<longrightarrow>\n                       STR ''vend'' = a \\<longrightarrow>\n                       value_gt (Some (Num 100)) (r $ 2) \\<noteq>\n                       true) \\<and>\n                      (b = [] \\<longrightarrow>\n                       STR ''vend'' = a \\<longrightarrow>\n                       \\<not>? value_gt (Some (Num 100)) (r $ 2) \\<noteq>\n                       true)\n 2. \\<And>aa list.\n       \\<lbrakk>e = (a, b); b = aa # list\\<rbrakk>\n       \\<Longrightarrow> (length b = 1 \\<longrightarrow>\n                          STR ''coin'' \\<noteq> a) \\<and>\n                         (b = [] \\<longrightarrow>\n                          STR ''vend'' = a \\<longrightarrow>\n                          value_gt (Some (Num 100)) (r $ 2) \\<noteq>\n                          true) \\<and>\n                         (b = [] \\<longrightarrow>\n                          STR ''vend'' = a \\<longrightarrow>\n                          \\<not>? value_gt (Some (Num 100)) (r $ 2) \\<noteq>\n                          true)", "using not_vend"], ["proof (prove)\nusing this:\n  e \\<noteq> (STR ''vend'', [])\n\ngoal (2 subgoals):\n 1. \\<lbrakk>e = (a, b); b = []\\<rbrakk>\n    \\<Longrightarrow> (length b = 1 \\<longrightarrow>\n                       STR ''coin'' \\<noteq> a) \\<and>\n                      (b = [] \\<longrightarrow>\n                       STR ''vend'' = a \\<longrightarrow>\n                       value_gt (Some (Num 100)) (r $ 2) \\<noteq>\n                       true) \\<and>\n                      (b = [] \\<longrightarrow>\n                       STR ''vend'' = a \\<longrightarrow>\n                       \\<not>? value_gt (Some (Num 100)) (r $ 2) \\<noteq>\n                       true)\n 2. \\<And>aa list.\n       \\<lbrakk>e = (a, b); b = aa # list\\<rbrakk>\n       \\<Longrightarrow> (length b = 1 \\<longrightarrow>\n                          STR ''coin'' \\<noteq> a) \\<and>\n                         (b = [] \\<longrightarrow>\n                          STR ''vend'' = a \\<longrightarrow>\n                          value_gt (Some (Num 100)) (r $ 2) \\<noteq>\n                          true) \\<and>\n                         (b = [] \\<longrightarrow>\n                          STR ''vend'' = a \\<longrightarrow>\n                          \\<not>? value_gt (Some (Num 100)) (r $ 2) \\<noteq>\n                          true)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       \\<lbrakk>e = (a, b); b = aa # list\\<rbrakk>\n       \\<Longrightarrow> (length b = 1 \\<longrightarrow>\n                          STR ''coin'' \\<noteq> a) \\<and>\n                         (b = [] \\<longrightarrow>\n                          STR ''vend'' = a \\<longrightarrow>\n                          value_gt (Some (Num 100)) (r $ 2) \\<noteq>\n                          true) \\<and>\n                         (b = [] \\<longrightarrow>\n                          STR ''vend'' = a \\<longrightarrow>\n                          \\<not>? value_gt (Some (Num 100)) (r $ 2) \\<noteq>\n                          true)", "using not_coin"], ["proof (prove)\nusing this:\n  \\<nexists>i. e = (STR ''coin'', [i])\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       \\<lbrakk>e = (a, b); b = aa # list\\<rbrakk>\n       \\<Longrightarrow> (length b = 1 \\<longrightarrow>\n                          STR ''coin'' \\<noteq> a) \\<and>\n                         (b = [] \\<longrightarrow>\n                          STR ''vend'' = a \\<longrightarrow>\n                          value_gt (Some (Num 100)) (r $ 2) \\<noteq>\n                          true) \\<and>\n                         (b = [] \\<longrightarrow>\n                          STR ''vend'' = a \\<longrightarrow>\n                          \\<not>? value_gt (Some (Num 100)) (r $ 2) \\<noteq>\n                          true)", "by auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<not> recognises_execution drinks 1 r (e # es)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rejects_state_step: \"s > 1 \\<Longrightarrow> step drinks s r l i = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 < s \\<Longrightarrow> step drinks s r l i = None", "apply (rule no_possible_steps_1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 < s \\<Longrightarrow> possible_steps drinks s r l i = {||}", "by (simp add: possible_steps_empty drinks_def)"], ["", "lemma invalid_other_states:\n  \"s > 1 \\<Longrightarrow> \\<not> recognises_execution drinks s r ((aa, b) # t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 < s \\<Longrightarrow>\n    \\<not> recognises_execution drinks s r ((aa, b) # t)", "apply (rule no_possible_steps_rejects)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 < s \\<Longrightarrow> possible_steps drinks s r aa b = {||}", "by (simp add: possible_steps_empty drinks_def)"], ["", "lemma vend_ge_100:\n  \"possible_steps drinks 1 r l i = {|(2, vend)|} \\<Longrightarrow>\n   \\<not>? value_gt (Some (Num 100)) (r $ 2) = trilean.true\""], ["proof (prove)\ngoal (1 subgoal):\n 1. possible_steps drinks 1 r l i = {|(2, vend)|} \\<Longrightarrow>\n    \\<not>? value_gt (Some (Num 100)) (r $ 2) = true", "apply (insert possible_steps_apply_guards[of drinks 1 r l i 2 vend])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>possible_steps drinks 1 r l i = {|(2, vend)|};\n     possible_steps drinks 1 r l i = {|(2, vend)|} \\<Longrightarrow>\n     apply_guards (Guards vend) (join_ir i r)\\<rbrakk>\n    \\<Longrightarrow> \\<not>? value_gt (Some (Num 100)) (r $ 2) = true", "by (simp add: possible_steps_def apply_guards_def vend_def)"], ["", "lemma drinks_no_possible_steps_1:\n  assumes not_coin: \"\\<not> (a = STR ''coin'' \\<and> length b = 1)\"\n      and not_vend: \"\\<not> (a = STR ''vend'' \\<and> b = [])\"\n    shows \"possible_steps drinks 1 r a b = {||}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. possible_steps drinks 1 r a b = {||}", "using drinks_1_rejects not_coin not_vend"], ["proof (prove)\nusing this:\n  \\<lbrakk>fst ?a = STR ''coin'' \\<longrightarrow>\n           length (snd ?a) \\<noteq> 1;\n   ?a \\<noteq> (STR ''vend'', [])\\<rbrakk>\n  \\<Longrightarrow> possible_steps drinks 1 ?r (fst ?a) (snd ?a) = {||}\n  \\<not> (a = STR ''coin'' \\<and> length b = 1)\n  \\<not> (a = STR ''vend'' \\<and> b = [])\n\ngoal (1 subgoal):\n 1. possible_steps drinks 1 r a b = {||}", "by auto"], ["", "lemma possible_steps_0_not_select: \"a \\<noteq> STR ''select'' \\<Longrightarrow>\n       possible_steps drinks 0 <> a b = {||}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<noteq> STR ''select'' \\<Longrightarrow>\n    possible_steps drinks 0 <> a b = {||}", "apply (simp add: possible_steps_def ffilter_def fset_both_sides Abs_fset_inverse Set.filter_def drinks_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<noteq> STR ''select'' \\<Longrightarrow>\n    \\<forall>aa ba bb.\n       length b = Arity bb \\<longrightarrow>\n       Label bb = a \\<longrightarrow>\n       (aa = 0 \\<and> ba = 1 \\<longrightarrow> bb \\<noteq> select) \\<and>\n       (aa = 1 \\<and> ba = 1 \\<longrightarrow> bb \\<noteq> coin) \\<and>\n       (aa = 1 \\<and> ba = 1 \\<longrightarrow> bb \\<noteq> vend_fail) \\<and>\n       (aa = 1 \\<and> ba = 2 \\<longrightarrow> bb \\<noteq> vend) \\<or>\n       0 < aa \\<or> \\<not> apply_guards (Guards bb) (join_ir b <>)", "apply safe"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>aa ba baa.\n       \\<lbrakk>Label select \\<noteq> STR ''select'';\n        length b = Arity select; a = Label select;\n        apply_guards (Guards select) (join_ir b <>); \\<not> False\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>aa ba baa.\n       \\<lbrakk>Label coin \\<noteq> STR ''select''; length b = Arity coin;\n        a = Label coin; apply_guards (Guards coin) (join_ir b <>);\n        \\<not> False; 0 = 1\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>aa ba baa.\n       \\<lbrakk>Label vend_fail \\<noteq> STR ''select'';\n        length b = Arity vend_fail; a = Label vend_fail;\n        apply_guards (Guards vend_fail) (join_ir b <>); \\<not> False;\n        0 = 1\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>aa ba baa.\n       \\<lbrakk>Label vend \\<noteq> STR ''select''; length b = Arity vend;\n        a = Label vend; apply_guards (Guards vend) (join_ir b <>);\n        \\<not> False; 0 = 1\\<rbrakk>\n       \\<Longrightarrow> False", "by (simp_all add: select_def)"], ["", "lemma possible_steps_select_wrong_arity: \"a = STR ''select'' \\<Longrightarrow>\n       length b \\<noteq> 1 \\<Longrightarrow>\n       possible_steps drinks 0 <> a b = {||}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a = STR ''select''; length b \\<noteq> 1\\<rbrakk>\n    \\<Longrightarrow> possible_steps drinks 0 <> a b = {||}", "apply (simp add: possible_steps_def ffilter_def fset_both_sides Abs_fset_inverse Set.filter_def drinks_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a = STR ''select''; length b \\<noteq> 1\\<rbrakk>\n    \\<Longrightarrow> \\<forall>a ba bb.\n                         length b = Arity bb \\<longrightarrow>\n                         Label bb = STR ''select'' \\<longrightarrow>\n                         (a = 0 \\<and> ba = 1 \\<longrightarrow>\n                          bb \\<noteq> select) \\<and>\n                         (a = 1 \\<and> ba = 1 \\<longrightarrow>\n                          bb \\<noteq> coin) \\<and>\n                         (a = 1 \\<and> ba = 1 \\<longrightarrow>\n                          bb \\<noteq> vend_fail) \\<and>\n                         (a = 1 \\<and> ba = 2 \\<longrightarrow>\n                          bb \\<noteq> vend) \\<or>\n                         0 < a \\<or>\n                         \\<not> apply_guards (Guards bb) (join_ir b <>)", "apply safe"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>aa ba baa.\n       \\<lbrakk>a = STR ''select''; length b \\<noteq> 1;\n        length b = Arity select; Label select = STR ''select'';\n        apply_guards (Guards select) (join_ir b <>); \\<not> False\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>aa ba baa.\n       \\<lbrakk>a = STR ''select''; length b \\<noteq> 1;\n        length b = Arity coin; Label coin = STR ''select'';\n        apply_guards (Guards coin) (join_ir b <>); \\<not> False;\n        0 = 1\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>aa ba baa.\n       \\<lbrakk>a = STR ''select''; length b \\<noteq> 1;\n        length b = Arity vend_fail; Label vend_fail = STR ''select'';\n        apply_guards (Guards vend_fail) (join_ir b <>); \\<not> False;\n        0 = 1\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>aa ba baa.\n       \\<lbrakk>a = STR ''select''; length b \\<noteq> 1;\n        length b = Arity vend; Label vend = STR ''select'';\n        apply_guards (Guards vend) (join_ir b <>); \\<not> False;\n        0 = 1\\<rbrakk>\n       \\<Longrightarrow> False", "by (simp_all add: select_def)"], ["", "lemma possible_steps_0_invalid:\n  \"\\<not> (l = STR ''select'' \\<and> length i = 1) \\<Longrightarrow>\n   possible_steps drinks 0 <> l i = {||}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (l = STR ''select'' \\<and> length i = 1) \\<Longrightarrow>\n    possible_steps drinks 0 <> l i = {||}", "using possible_steps_0_not_select possible_steps_select_wrong_arity"], ["proof (prove)\nusing this:\n  ?a \\<noteq> STR ''select'' \\<Longrightarrow>\n  possible_steps drinks 0 <> ?a ?b = {||}\n  \\<lbrakk>?a = STR ''select''; length ?b \\<noteq> 1\\<rbrakk>\n  \\<Longrightarrow> possible_steps drinks 0 <> ?a ?b = {||}\n\ngoal (1 subgoal):\n 1. \\<not> (l = STR ''select'' \\<and> length i = 1) \\<Longrightarrow>\n    possible_steps drinks 0 <> l i = {||}", "by fastforce"], ["", "end"]]}