{"file_name": "/home/qj213/afp-2021-10-22/thys/Extended_Finite_State_Machines/examples/Drinks_Machine_2.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Extended_Finite_State_Machines", "problem_names": ["lemmas transitions = Drinks_Machine.transitions vend_nothing_def", "lemma possible_steps_0:\n  \"length i = 1 \\<Longrightarrow>\n   possible_steps drinks2 0 r ((STR ''select'')) i = {|(1, select)|}\"", "lemma possible_steps_1:\n  \"length i = 1 \\<Longrightarrow>\n   possible_steps drinks2 1 r ((STR ''coin'')) i = {|(2, coin)|}\"", "lemma possible_steps_2_coin:\n  \"length i = 1 \\<Longrightarrow>\n   possible_steps drinks2 2 r ((STR ''coin'')) i = {|(2, coin)|}\"", "lemma possible_steps_2_vend:\n  \"r $ 2 = Some (Num n) \\<Longrightarrow>\n   n \\<ge> 100 \\<Longrightarrow>\n   possible_steps drinks2 2 r ((STR ''vend'')) [] = {|(3, vend)|}\"", "lemma recognises_first_select:\n  \"recognises_execution drinks 0 r ((aa, b) # as) \\<Longrightarrow> aa = STR ''select'' \\<and> length b = 1\"", "lemma drinks2_vend_insufficient:\n  \"possible_steps drinks2 1 r ((STR ''vend'')) [] = {|(1, vend_nothing)|}\"", "lemma drinks2_vend_insufficient2:\n  \"r $ 2 = Some (Num x1) \\<Longrightarrow>\n   x1 < 100 \\<Longrightarrow>\n   possible_steps drinks2 2 r ((STR ''vend'')) [] = {|(2, vend_fail)|}\"", "lemma drinks2_vend_sufficient: \"r $ 2 = Some (Num x1) \\<Longrightarrow>\n                \\<not> x1 < 100 \\<Longrightarrow>\n                possible_steps drinks2 2 r ((STR ''vend'')) [] = {|(3, vend)|}\"", "lemma recognises_1_2: \"recognises_execution drinks 1 r t \\<longrightarrow> recognises_execution drinks2 2 r t\"", "lemma drinks_reject_0_2:\n  \"\\<nexists>i. a = (STR ''select'', [i]) \\<Longrightarrow>\n   possible_steps drinks 0 r (fst a) (snd a) = {||}\"", "lemma purchase_coke:\n  \"observe_execution drinks2 0 <> [((STR ''select''), [Str ''coke'']), ((STR ''coin''), [Num 50]), ((STR ''coin''), [Num 50]), ((STR ''vend''), [])] =\n                       [[], [Some (Num 50)], [Some (Num 100)], [Some (Str ''coke'')]]\"", "lemma drinks2_0_invalid:\n  \"\\<not> (aa = (STR ''select'') \\<and> length (b) = 1) \\<Longrightarrow>\n    (possible_steps drinks2 0 <> aa b) = {||}\"", "lemma drinks2_vend_r2_none:\n  \"r $ 2 = None \\<Longrightarrow> possible_steps drinks2 2 r ((STR ''vend'')) [] = {||}\"", "lemma drinks2_end: \"possible_steps drinks2 3 r a b = {||}\"", "lemma drinks2_vend_r2_String: \"r $ 2 = Some (value.Str x2) \\<Longrightarrow>\n                possible_steps drinks2 2 r ((STR ''vend'')) [] = {||}\"", "lemma drinks2_2_invalid:\n  \"fst a = (STR ''coin'') \\<longrightarrow> length (snd a) \\<noteq> 1 \\<Longrightarrow>\n          a \\<noteq> ((STR ''vend''), []) \\<Longrightarrow>\n          possible_steps drinks2 2 r (fst a) (snd a) = {||}\"", "lemma drinks2_1_invalid:\n  \"\\<not>(a = (STR ''coin'') \\<and> length b = 1) \\<Longrightarrow>\n      \\<not>(a = (STR ''vend'') \\<and> b = []) \\<Longrightarrow>\n    possible_steps drinks2 1 r a b = {||}\"", "lemma drinks2_vend_invalid:\n  \"\\<nexists>n. r $ 2 = Some (Num n) \\<Longrightarrow>\n   possible_steps drinks2 2 r (STR ''vend'') [] = {||}\"", "lemma equiv_1_2: \"executionally_equivalent drinks 1 r drinks2 2 r x\"", "lemma equiv_1_1: \"r$2 = Some (Num 0) \\<Longrightarrow> executionally_equivalent drinks 1 r drinks2 1 r x\"", "lemma executional_equivalence: \"executionally_equivalent drinks 0 <> drinks2 0 <> t\"", "lemma observational_equivalence: \"trace_equivalent drinks drinks2\""], "translations": [["", "lemmas transitions = Drinks_Machine.transitions vend_nothing_def"], ["", "definition drinks2 :: transition_matrix where\n\"drinks2 = {|\n              ((0,1), select),\n              ((1,1), vend_nothing),\n              ((1,2), coin),\n              ((2,2), coin),\n              ((2,2), vend_fail),\n              ((2,3), vend)\n         |}\""], ["", "lemma possible_steps_0:\n  \"length i = 1 \\<Longrightarrow>\n   possible_steps drinks2 0 r ((STR ''select'')) i = {|(1, select)|}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length i = 1 \\<Longrightarrow>\n    possible_steps drinks2 0 r STR ''select'' i = {|(1, select)|}", "apply (simp add: possible_steps_def drinks2_def transitions)"], ["proof (prove)\ngoal (1 subgoal):\n 1. length i = 1 \\<Longrightarrow>\n    (\\<lambda>((origin, dest), t). (dest, t)) |`|\n    ffilter\n     (\\<lambda>((origin, dest), t).\n         origin = 0 \\<and>\n         Label t = STR ''select'' \\<and>\n         Arity t = 1 \\<and> apply_guards (Guards t) (join_ir i r))\n     {|((0, 1),\n        \\<lparr>Label = STR ''select'', Arity = 1, Guards = [],\n           Outputs = [], Updates = [(1, V (I 0)), (2, L (Num 0))]\\<rparr>),\n       ((1, 1),\n        \\<lparr>Label = STR ''vend'', Arity = 0, Guards = [], Outputs = [],\n           Updates = [(1, V (R 1)), (2, V (R 2))]\\<rparr>),\n       ((1, 2),\n        \\<lparr>Label = STR ''coin'', Arity = 1, Guards = [],\n           Outputs = [Plus (V (R 2)) (V (I 0))],\n           Updates = [(1, V (R 1)), (2, Plus (V (R 2)) (V (I 0)))]\\<rparr>),\n       ((2, 2),\n        \\<lparr>Label = STR ''coin'', Arity = 1, Guards = [],\n           Outputs = [Plus (V (R 2)) (V (I 0))],\n           Updates = [(1, V (R 1)), (2, Plus (V (R 2)) (V (I 0)))]\\<rparr>),\n       ((2, 2),\n        \\<lparr>Label = STR ''vend'', Arity = 0,\n           Guards = [Lt (V (R 2)) (L (Num 100))], Outputs = [],\n           Updates = [(1, V (R 1)), (2, V (R 2))]\\<rparr>),\n       ((2, 3),\n        \\<lparr>Label = STR ''vend'', Arity = 0,\n           Guards = [Ge (V (R 2)) (L (Num 100))], Outputs = [V (R 1)],\n           Updates = [(1, V (R 1)), (2, V (R 2))]\\<rparr>)|} =\n    {|(1, \\<lparr>Label = STR ''select'', Arity = 1, Guards = [],\n             Outputs = [],\n             Updates = [(1, V (I 0)), (2, L (Num 0))]\\<rparr>)|}", "by force"], ["", "lemma possible_steps_1:\n  \"length i = 1 \\<Longrightarrow>\n   possible_steps drinks2 1 r ((STR ''coin'')) i = {|(2, coin)|}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length i = 1 \\<Longrightarrow>\n    possible_steps drinks2 1 r STR ''coin'' i = {|(2, coin)|}", "apply (simp add: possible_steps_def drinks2_def transitions)"], ["proof (prove)\ngoal (1 subgoal):\n 1. length i = 1 \\<Longrightarrow>\n    (\\<lambda>((origin, dest), t). (dest, t)) |`|\n    ffilter\n     (\\<lambda>((origin, dest), t).\n         origin = 1 \\<and>\n         Label t = STR ''coin'' \\<and>\n         Arity t = 1 \\<and> apply_guards (Guards t) (join_ir i r))\n     {|((0, 1),\n        \\<lparr>Label = STR ''select'', Arity = 1, Guards = [],\n           Outputs = [], Updates = [(1, V (I 0)), (2, L (Num 0))]\\<rparr>),\n       ((1, 1),\n        \\<lparr>Label = STR ''vend'', Arity = 0, Guards = [], Outputs = [],\n           Updates = [(1, V (R 1)), (2, V (R 2))]\\<rparr>),\n       ((1, 2),\n        \\<lparr>Label = STR ''coin'', Arity = 1, Guards = [],\n           Outputs = [Plus (V (R 2)) (V (I 0))],\n           Updates = [(1, V (R 1)), (2, Plus (V (R 2)) (V (I 0)))]\\<rparr>),\n       ((2, 2),\n        \\<lparr>Label = STR ''coin'', Arity = 1, Guards = [],\n           Outputs = [Plus (V (R 2)) (V (I 0))],\n           Updates = [(1, V (R 1)), (2, Plus (V (R 2)) (V (I 0)))]\\<rparr>),\n       ((2, 2),\n        \\<lparr>Label = STR ''vend'', Arity = 0,\n           Guards = [Lt (V (R 2)) (L (Num 100))], Outputs = [],\n           Updates = [(1, V (R 1)), (2, V (R 2))]\\<rparr>),\n       ((2, 3),\n        \\<lparr>Label = STR ''vend'', Arity = 0,\n           Guards = [Ge (V (R 2)) (L (Num 100))], Outputs = [V (R 1)],\n           Updates = [(1, V (R 1)), (2, V (R 2))]\\<rparr>)|} =\n    {|(2, \\<lparr>Label = STR ''coin'', Arity = 1, Guards = [],\n             Outputs = [Plus (V (R 2)) (V (I 0))],\n             Updates =\n               [(1, V (R 1)), (2, Plus (V (R 2)) (V (I 0)))]\\<rparr>)|}", "by force"], ["", "lemma possible_steps_2_coin:\n  \"length i = 1 \\<Longrightarrow>\n   possible_steps drinks2 2 r ((STR ''coin'')) i = {|(2, coin)|}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length i = 1 \\<Longrightarrow>\n    possible_steps drinks2 2 r STR ''coin'' i = {|(2, coin)|}", "apply (simp add: possible_steps_def drinks2_def transitions)"], ["proof (prove)\ngoal (1 subgoal):\n 1. length i = 1 \\<Longrightarrow>\n    (\\<lambda>((origin, dest), t). (dest, t)) |`|\n    ffilter\n     (\\<lambda>((origin, dest), t).\n         origin = 2 \\<and>\n         Label t = STR ''coin'' \\<and>\n         Arity t = 1 \\<and> apply_guards (Guards t) (join_ir i r))\n     {|((0, 1),\n        \\<lparr>Label = STR ''select'', Arity = 1, Guards = [],\n           Outputs = [], Updates = [(1, V (I 0)), (2, L (Num 0))]\\<rparr>),\n       ((1, 1),\n        \\<lparr>Label = STR ''vend'', Arity = 0, Guards = [], Outputs = [],\n           Updates = [(1, V (R 1)), (2, V (R 2))]\\<rparr>),\n       ((1, 2),\n        \\<lparr>Label = STR ''coin'', Arity = 1, Guards = [],\n           Outputs = [Plus (V (R 2)) (V (I 0))],\n           Updates = [(1, V (R 1)), (2, Plus (V (R 2)) (V (I 0)))]\\<rparr>),\n       ((2, 2),\n        \\<lparr>Label = STR ''coin'', Arity = 1, Guards = [],\n           Outputs = [Plus (V (R 2)) (V (I 0))],\n           Updates = [(1, V (R 1)), (2, Plus (V (R 2)) (V (I 0)))]\\<rparr>),\n       ((2, 2),\n        \\<lparr>Label = STR ''vend'', Arity = 0,\n           Guards = [Lt (V (R 2)) (L (Num 100))], Outputs = [],\n           Updates = [(1, V (R 1)), (2, V (R 2))]\\<rparr>),\n       ((2, 3),\n        \\<lparr>Label = STR ''vend'', Arity = 0,\n           Guards = [Ge (V (R 2)) (L (Num 100))], Outputs = [V (R 1)],\n           Updates = [(1, V (R 1)), (2, V (R 2))]\\<rparr>)|} =\n    {|(2, \\<lparr>Label = STR ''coin'', Arity = 1, Guards = [],\n             Outputs = [Plus (V (R 2)) (V (I 0))],\n             Updates =\n               [(1, V (R 1)), (2, Plus (V (R 2)) (V (I 0)))]\\<rparr>)|}", "by force"], ["", "lemma possible_steps_2_vend:\n  \"r $ 2 = Some (Num n) \\<Longrightarrow>\n   n \\<ge> 100 \\<Longrightarrow>\n   possible_steps drinks2 2 r ((STR ''vend'')) [] = {|(3, vend)|}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>r $ 2 = Some (Num n); 100 \\<le> n\\<rbrakk>\n    \\<Longrightarrow> possible_steps drinks2 2 r STR ''vend'' [] =\n                      {|(3, vend)|}", "apply (simp add: possible_steps_singleton drinks2_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>r $ 2 = Some (Num n); 100 \\<le> n\\<rbrakk>\n    \\<Longrightarrow> {((origin, dest), t).\n                       (origin = 0 \\<and> dest = 1 \\<and> t = select \\<or>\n                        origin = 1 \\<and>\n                        dest = 1 \\<and> t = vend_nothing \\<or>\n                        origin = 1 \\<and> dest = 2 \\<and> t = coin \\<or>\n                        origin = 2 \\<and> dest = 2 \\<and> t = coin \\<or>\n                        origin = 2 \\<and>\n                        dest = 2 \\<and> t = vend_fail \\<or>\n                        origin = 2 \\<and> dest = 3 \\<and> t = vend) \\<and>\n                       origin = 2 \\<and>\n                       Label t = STR ''vend'' \\<and>\n                       Arity t = 0 \\<and>\n                       apply_guards (Guards t) (join_ir [] r)} =\n                      {((2, 3), vend)}", "apply safe"], ["proof (prove)\ngoal (13 subgoals):\n 1. \\<And>a b ba.\n       \\<lbrakk>r $ 2 = Some (Num n); 100 \\<le> n;\n        ((2, 1), select) \\<notin> {}; Label select = STR ''vend'';\n        Arity select = 0; apply_guards (Guards select) (join_ir [] r);\n        2 = 0\\<rbrakk>\n       \\<Longrightarrow> 1 = 3\n 2. \\<And>a b ba.\n       \\<lbrakk>r $ 2 = Some (Num n); 100 \\<le> n;\n        ((2, 1), select) \\<notin> {}; Label select = STR ''vend'';\n        Arity select = 0; apply_guards (Guards select) (join_ir [] r);\n        2 = 0\\<rbrakk>\n       \\<Longrightarrow> select = vend\n 3. \\<And>a b ba.\n       \\<lbrakk>r $ 2 = Some (Num n); 100 \\<le> n;\n        ((2, 1), vend_nothing) \\<notin> {};\n        Label vend_nothing = STR ''vend''; Arity vend_nothing = 0;\n        apply_guards (Guards vend_nothing) (join_ir [] r); 2 = 1\\<rbrakk>\n       \\<Longrightarrow> 1 = 3\n 4. \\<And>a b ba.\n       \\<lbrakk>r $ 2 = Some (Num n); 100 \\<le> n;\n        ((2, 1), vend_nothing) \\<notin> {};\n        Label vend_nothing = STR ''vend''; Arity vend_nothing = 0;\n        apply_guards (Guards vend_nothing) (join_ir [] r); 2 = 1\\<rbrakk>\n       \\<Longrightarrow> vend_nothing = vend\n 5. \\<And>a b ba.\n       \\<lbrakk>r $ 2 = Some (Num n); 100 \\<le> n;\n        ((2, 2), coin) \\<notin> {}; Label coin = STR ''vend'';\n        Arity coin = 0; apply_guards (Guards coin) (join_ir [] r);\n        2 = 1\\<rbrakk>\n       \\<Longrightarrow> 2 = 3\n 6. \\<And>a b ba.\n       \\<lbrakk>r $ 2 = Some (Num n); 100 \\<le> n;\n        ((2, 2), coin) \\<notin> {}; Label coin = STR ''vend'';\n        Arity coin = 0; apply_guards (Guards coin) (join_ir [] r);\n        2 = 1\\<rbrakk>\n       \\<Longrightarrow> coin = vend\n 7. \\<And>a b ba.\n       \\<lbrakk>r $ 2 = Some (Num n); 100 \\<le> n;\n        ((2, 2), coin) \\<notin> {}; Label coin = STR ''vend'';\n        Arity coin = 0; apply_guards (Guards coin) (join_ir [] r)\\<rbrakk>\n       \\<Longrightarrow> 2 = 3\n 8. \\<And>a b ba.\n       \\<lbrakk>r $ 2 = Some (Num n); 100 \\<le> n;\n        ((2, 2), coin) \\<notin> {}; Label coin = STR ''vend'';\n        Arity coin = 0; apply_guards (Guards coin) (join_ir [] r)\\<rbrakk>\n       \\<Longrightarrow> coin = vend\n 9. \\<And>a b ba.\n       \\<lbrakk>r $ 2 = Some (Num n); 100 \\<le> n;\n        ((2, 2), vend_fail) \\<notin> {}; Label vend_fail = STR ''vend'';\n        Arity vend_fail = 0;\n        apply_guards (Guards vend_fail) (join_ir [] r)\\<rbrakk>\n       \\<Longrightarrow> 2 = 3\n 10. \\<And>a b ba.\n        \\<lbrakk>r $ 2 = Some (Num n); 100 \\<le> n;\n         ((2, 2), vend_fail) \\<notin> {}; Label vend_fail = STR ''vend'';\n         Arity vend_fail = 0;\n         apply_guards (Guards vend_fail) (join_ir [] r)\\<rbrakk>\n        \\<Longrightarrow> vend_fail = vend\nA total of 13 subgoals...", "by (simp_all add: transitions apply_guards_def value_gt_def join_ir_def connectives)"], ["", "lemma recognises_first_select:\n  \"recognises_execution drinks 0 r ((aa, b) # as) \\<Longrightarrow> aa = STR ''select'' \\<and> length b = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. recognises_execution drinks 0 r ((aa, b) # as) \\<Longrightarrow>\n    aa = STR ''select'' \\<and> length b = 1", "using recognises_must_be_possible_step[of drinks 0 r \"(aa, b)\" as]"], ["proof (prove)\nusing this:\n  recognises_execution drinks 0 r ((aa, b) # as) \\<Longrightarrow>\n  \\<exists>aaa ba.\n     (aaa, ba) |\\<in>| possible_steps drinks 0 r (fst (aa, b)) (snd (aa, b))\n\ngoal (1 subgoal):\n 1. recognises_execution drinks 0 r ((aa, b) # as) \\<Longrightarrow>\n    aa = STR ''select'' \\<and> length b = 1", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>recognises_execution drinks 0 r ((aa, b) # as);\n     \\<exists>aaa ba.\n        (aaa, ba) |\\<in>| possible_steps drinks 0 r aa b\\<rbrakk>\n    \\<Longrightarrow> aa = STR ''select'' \\<and> length b = 1", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aaa ba.\n       \\<lbrakk>recognises_execution drinks 0 r ((aa, b) # as);\n        (aaa, ba) |\\<in>| possible_steps drinks 0 r aa b\\<rbrakk>\n       \\<Longrightarrow> aa = STR ''select'' \\<and> length b = 1", "by (metis first_step_select recognises_possible_steps_not_empty drinks_0_rejects fst_conv snd_conv)"], ["", "lemma drinks2_vend_insufficient:\n  \"possible_steps drinks2 1 r ((STR ''vend'')) [] = {|(1, vend_nothing)|}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. possible_steps drinks2 1 r STR ''vend'' [] = {|(1, vend_nothing)|}", "apply (simp add: possible_steps_def drinks2_def transitions)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>((origin, dest), t). (dest, t)) |`|\n    ffilter\n     (\\<lambda>((origin, dest), t).\n         origin = 1 \\<and>\n         Label t = STR ''vend'' \\<and>\n         Arity t = 0 \\<and> apply_guards (Guards t) (join_ir [] r))\n     {|((0, 1),\n        \\<lparr>Label = STR ''select'', Arity = 1, Guards = [],\n           Outputs = [], Updates = [(1, V (I 0)), (2, L (Num 0))]\\<rparr>),\n       ((1, 1),\n        \\<lparr>Label = STR ''vend'', Arity = 0, Guards = [], Outputs = [],\n           Updates = [(1, V (R 1)), (2, V (R 2))]\\<rparr>),\n       ((1, 2),\n        \\<lparr>Label = STR ''coin'', Arity = 1, Guards = [],\n           Outputs = [Plus (V (R 2)) (V (I 0))],\n           Updates = [(1, V (R 1)), (2, Plus (V (R 2)) (V (I 0)))]\\<rparr>),\n       ((2, 2),\n        \\<lparr>Label = STR ''coin'', Arity = 1, Guards = [],\n           Outputs = [Plus (V (R 2)) (V (I 0))],\n           Updates = [(1, V (R 1)), (2, Plus (V (R 2)) (V (I 0)))]\\<rparr>),\n       ((2, 2),\n        \\<lparr>Label = STR ''vend'', Arity = 0,\n           Guards = [Lt (V (R 2)) (L (Num 100))], Outputs = [],\n           Updates = [(1, V (R 1)), (2, V (R 2))]\\<rparr>),\n       ((2, 3),\n        \\<lparr>Label = STR ''vend'', Arity = 0,\n           Guards = [Ge (V (R 2)) (L (Num 100))], Outputs = [V (R 1)],\n           Updates = [(1, V (R 1)), (2, V (R 2))]\\<rparr>)|} =\n    {|(1, \\<lparr>Label = STR ''vend'', Arity = 0, Guards = [],\n             Outputs = [], Updates = [(1, V (R 1)), (2, V (R 2))]\\<rparr>)|}", "by force"], ["", "lemma drinks2_vend_insufficient2:\n  \"r $ 2 = Some (Num x1) \\<Longrightarrow>\n   x1 < 100 \\<Longrightarrow>\n   possible_steps drinks2 2 r ((STR ''vend'')) [] = {|(2, vend_fail)|}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>r $ 2 = Some (Num x1); x1 < 100\\<rbrakk>\n    \\<Longrightarrow> possible_steps drinks2 2 r STR ''vend'' [] =\n                      {|(2, vend_fail)|}", "apply (simp add: possible_steps_singleton drinks2_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>r $ 2 = Some (Num x1); x1 < 100\\<rbrakk>\n    \\<Longrightarrow> {((origin, dest), t).\n                       (origin = 0 \\<and> dest = 1 \\<and> t = select \\<or>\n                        origin = 1 \\<and>\n                        dest = 1 \\<and> t = vend_nothing \\<or>\n                        origin = 1 \\<and> dest = 2 \\<and> t = coin \\<or>\n                        origin = 2 \\<and> dest = 2 \\<and> t = coin \\<or>\n                        origin = 2 \\<and>\n                        dest = 2 \\<and> t = vend_fail \\<or>\n                        origin = 2 \\<and> dest = 3 \\<and> t = vend) \\<and>\n                       origin = 2 \\<and>\n                       Label t = STR ''vend'' \\<and>\n                       Arity t = 0 \\<and>\n                       apply_guards (Guards t) (join_ir [] r)} =\n                      {((2, 2), vend_fail)}", "apply safe"], ["proof (prove)\ngoal (11 subgoals):\n 1. \\<And>a b ba.\n       \\<lbrakk>r $ 2 = Some (Num x1); x1 < 100;\n        ((2, 1), select) \\<notin> {}; Label select = STR ''vend'';\n        Arity select = 0; apply_guards (Guards select) (join_ir [] r);\n        2 = 0\\<rbrakk>\n       \\<Longrightarrow> 1 = 2\n 2. \\<And>a b ba.\n       \\<lbrakk>r $ 2 = Some (Num x1); x1 < 100;\n        ((2, 1), select) \\<notin> {}; Label select = STR ''vend'';\n        Arity select = 0; apply_guards (Guards select) (join_ir [] r);\n        2 = 0\\<rbrakk>\n       \\<Longrightarrow> select = vend_fail\n 3. \\<And>a b ba.\n       \\<lbrakk>r $ 2 = Some (Num x1); x1 < 100;\n        ((2, 1), vend_nothing) \\<notin> {};\n        Label vend_nothing = STR ''vend''; Arity vend_nothing = 0;\n        apply_guards (Guards vend_nothing) (join_ir [] r); 2 = 1\\<rbrakk>\n       \\<Longrightarrow> 1 = 2\n 4. \\<And>a b ba.\n       \\<lbrakk>r $ 2 = Some (Num x1); x1 < 100;\n        ((2, 1), vend_nothing) \\<notin> {};\n        Label vend_nothing = STR ''vend''; Arity vend_nothing = 0;\n        apply_guards (Guards vend_nothing) (join_ir [] r); 2 = 1\\<rbrakk>\n       \\<Longrightarrow> vend_nothing = vend_fail\n 5. \\<And>a b ba.\n       \\<lbrakk>r $ 2 = Some (Num x1); x1 < 100; ((2, 2), coin) \\<notin> {};\n        Label coin = STR ''vend''; Arity coin = 0;\n        apply_guards (Guards coin) (join_ir [] r); 2 = 1\\<rbrakk>\n       \\<Longrightarrow> coin = vend_fail\n 6. \\<And>a b ba.\n       \\<lbrakk>r $ 2 = Some (Num x1); x1 < 100; ((2, 2), coin) \\<notin> {};\n        Label coin = STR ''vend''; Arity coin = 0;\n        apply_guards (Guards coin) (join_ir [] r)\\<rbrakk>\n       \\<Longrightarrow> coin = vend_fail\n 7. \\<And>a b ba.\n       \\<lbrakk>r $ 2 = Some (Num x1); x1 < 100; ((2, 3), vend) \\<notin> {};\n        Label vend = STR ''vend''; Arity vend = 0;\n        apply_guards (Guards vend) (join_ir [] r)\\<rbrakk>\n       \\<Longrightarrow> 3 = 2\n 8. \\<And>a b ba.\n       \\<lbrakk>r $ 2 = Some (Num x1); x1 < 100; ((2, 3), vend) \\<notin> {};\n        Label vend = STR ''vend''; Arity vend = 0;\n        apply_guards (Guards vend) (join_ir [] r)\\<rbrakk>\n       \\<Longrightarrow> vend = vend_fail\n 9. \\<And>a b ba.\n       \\<lbrakk>r $ 2 = Some (Num x1); x1 < 100\\<rbrakk>\n       \\<Longrightarrow> Label vend_fail = STR ''vend''\n 10. \\<And>a b ba.\n        \\<lbrakk>r $ 2 = Some (Num x1); x1 < 100\\<rbrakk>\n        \\<Longrightarrow> Arity vend_fail = 0\nA total of 11 subgoals...", "by (simp_all add: transitions apply_guards_def value_gt_def join_ir_def connectives)"], ["", "lemma drinks2_vend_sufficient: \"r $ 2 = Some (Num x1) \\<Longrightarrow>\n                \\<not> x1 < 100 \\<Longrightarrow>\n                possible_steps drinks2 2 r ((STR ''vend'')) [] = {|(3, vend)|}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>r $ 2 = Some (Num x1); \\<not> x1 < 100\\<rbrakk>\n    \\<Longrightarrow> possible_steps drinks2 2 r STR ''vend'' [] =\n                      {|(3, vend)|}", "apply (simp add: possible_steps_singleton drinks2_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>r $ 2 = Some (Num x1); \\<not> x1 < 100\\<rbrakk>\n    \\<Longrightarrow> {((origin, dest), t).\n                       (origin = 0 \\<and> dest = 1 \\<and> t = select \\<or>\n                        origin = 1 \\<and>\n                        dest = 1 \\<and> t = vend_nothing \\<or>\n                        origin = 1 \\<and> dest = 2 \\<and> t = coin \\<or>\n                        origin = 2 \\<and> dest = 2 \\<and> t = coin \\<or>\n                        origin = 2 \\<and>\n                        dest = 2 \\<and> t = vend_fail \\<or>\n                        origin = 2 \\<and> dest = 3 \\<and> t = vend) \\<and>\n                       origin = 2 \\<and>\n                       Label t = STR ''vend'' \\<and>\n                       Arity t = 0 \\<and>\n                       apply_guards (Guards t) (join_ir [] r)} =\n                      {((2, 3), vend)}", "apply safe"], ["proof (prove)\ngoal (13 subgoals):\n 1. \\<And>a b ba.\n       \\<lbrakk>r $ 2 = Some (Num x1); \\<not> x1 < 100;\n        ((2, 1), select) \\<notin> {}; Label select = STR ''vend'';\n        Arity select = 0; apply_guards (Guards select) (join_ir [] r);\n        2 = 0\\<rbrakk>\n       \\<Longrightarrow> 1 = 3\n 2. \\<And>a b ba.\n       \\<lbrakk>r $ 2 = Some (Num x1); \\<not> x1 < 100;\n        ((2, 1), select) \\<notin> {}; Label select = STR ''vend'';\n        Arity select = 0; apply_guards (Guards select) (join_ir [] r);\n        2 = 0\\<rbrakk>\n       \\<Longrightarrow> select = vend\n 3. \\<And>a b ba.\n       \\<lbrakk>r $ 2 = Some (Num x1); \\<not> x1 < 100;\n        ((2, 1), vend_nothing) \\<notin> {};\n        Label vend_nothing = STR ''vend''; Arity vend_nothing = 0;\n        apply_guards (Guards vend_nothing) (join_ir [] r); 2 = 1\\<rbrakk>\n       \\<Longrightarrow> 1 = 3\n 4. \\<And>a b ba.\n       \\<lbrakk>r $ 2 = Some (Num x1); \\<not> x1 < 100;\n        ((2, 1), vend_nothing) \\<notin> {};\n        Label vend_nothing = STR ''vend''; Arity vend_nothing = 0;\n        apply_guards (Guards vend_nothing) (join_ir [] r); 2 = 1\\<rbrakk>\n       \\<Longrightarrow> vend_nothing = vend\n 5. \\<And>a b ba.\n       \\<lbrakk>r $ 2 = Some (Num x1); \\<not> x1 < 100;\n        ((2, 2), coin) \\<notin> {}; Label coin = STR ''vend'';\n        Arity coin = 0; apply_guards (Guards coin) (join_ir [] r);\n        2 = 1\\<rbrakk>\n       \\<Longrightarrow> 2 = 3\n 6. \\<And>a b ba.\n       \\<lbrakk>r $ 2 = Some (Num x1); \\<not> x1 < 100;\n        ((2, 2), coin) \\<notin> {}; Label coin = STR ''vend'';\n        Arity coin = 0; apply_guards (Guards coin) (join_ir [] r);\n        2 = 1\\<rbrakk>\n       \\<Longrightarrow> coin = vend\n 7. \\<And>a b ba.\n       \\<lbrakk>r $ 2 = Some (Num x1); \\<not> x1 < 100;\n        ((2, 2), coin) \\<notin> {}; Label coin = STR ''vend'';\n        Arity coin = 0; apply_guards (Guards coin) (join_ir [] r)\\<rbrakk>\n       \\<Longrightarrow> 2 = 3\n 8. \\<And>a b ba.\n       \\<lbrakk>r $ 2 = Some (Num x1); \\<not> x1 < 100;\n        ((2, 2), coin) \\<notin> {}; Label coin = STR ''vend'';\n        Arity coin = 0; apply_guards (Guards coin) (join_ir [] r)\\<rbrakk>\n       \\<Longrightarrow> coin = vend\n 9. \\<And>a b ba.\n       \\<lbrakk>r $ 2 = Some (Num x1); \\<not> x1 < 100;\n        ((2, 2), vend_fail) \\<notin> {}; Label vend_fail = STR ''vend'';\n        Arity vend_fail = 0;\n        apply_guards (Guards vend_fail) (join_ir [] r)\\<rbrakk>\n       \\<Longrightarrow> 2 = 3\n 10. \\<And>a b ba.\n        \\<lbrakk>r $ 2 = Some (Num x1); \\<not> x1 < 100;\n         ((2, 2), vend_fail) \\<notin> {}; Label vend_fail = STR ''vend'';\n         Arity vend_fail = 0;\n         apply_guards (Guards vend_fail) (join_ir [] r)\\<rbrakk>\n        \\<Longrightarrow> vend_fail = vend\nA total of 13 subgoals...", "by (simp_all add: transitions apply_guards_def value_gt_def join_ir_def connectives)"], ["", "lemma recognises_1_2: \"recognises_execution drinks 1 r t \\<longrightarrow> recognises_execution drinks2 2 r t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. recognises_execution drinks 1 r t \\<longrightarrow>\n    recognises_execution drinks2 2 r t", "proof(induct t arbitrary: r)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>r.\n       recognises_execution drinks 1 r [] \\<longrightarrow>\n       recognises_execution drinks2 2 r []\n 2. \\<And>a t r.\n       (\\<And>r.\n           recognises_execution drinks 1 r t \\<longrightarrow>\n           recognises_execution drinks2 2 r t) \\<Longrightarrow>\n       recognises_execution drinks 1 r (a # t) \\<longrightarrow>\n       recognises_execution drinks2 2 r (a # t)", "case (Cons a as)"], ["proof (state)\nthis:\n  recognises_execution drinks 1 ?r as \\<longrightarrow>\n  recognises_execution drinks2 2 ?r as\n\ngoal (2 subgoals):\n 1. \\<And>r.\n       recognises_execution drinks 1 r [] \\<longrightarrow>\n       recognises_execution drinks2 2 r []\n 2. \\<And>a t r.\n       (\\<And>r.\n           recognises_execution drinks 1 r t \\<longrightarrow>\n           recognises_execution drinks2 2 r t) \\<Longrightarrow>\n       recognises_execution drinks 1 r (a # t) \\<longrightarrow>\n       recognises_execution drinks2 2 r (a # t)", "then"], ["proof (chain)\npicking this:\n  recognises_execution drinks 1 ?r as \\<longrightarrow>\n  recognises_execution drinks2 2 ?r as", "show ?case"], ["proof (prove)\nusing this:\n  recognises_execution drinks 1 ?r as \\<longrightarrow>\n  recognises_execution drinks2 2 ?r as\n\ngoal (1 subgoal):\n 1. recognises_execution drinks 1 r (a # as) \\<longrightarrow>\n    recognises_execution drinks2 2 r (a # as)", "apply (cases a)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b.\n       \\<lbrakk>\\<And>r.\n                   recognises_execution drinks 1 r as \\<longrightarrow>\n                   recognises_execution drinks2 2 r as;\n        a = (aa, b)\\<rbrakk>\n       \\<Longrightarrow> recognises_execution drinks 1 r\n                          (a # as) \\<longrightarrow>\n                         recognises_execution drinks2 2 r (a # as)", "apply (simp add: recognises_step_equiv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b.\n       \\<lbrakk>\\<And>r.\n                   recognises_execution drinks 1 r as \\<longrightarrow>\n                   recognises_execution drinks2 2 r as;\n        a = (aa, b)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>(s', T)\n                                   |\\<in>|possible_steps drinks 1 r aa b.\n                             recognises_execution drinks s'\n                              (evaluate_updates T b r) as) \\<longrightarrow>\n                         (\\<exists>(s', T)\n                                   |\\<in>|possible_steps drinks2 2 r aa b.\n                             recognises_execution drinks2 s'\n                              (evaluate_updates T b r) as)", "apply (case_tac \"a=(STR ''vend'', [])\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa b.\n       \\<lbrakk>\\<And>r.\n                   recognises_execution drinks 1 r as \\<longrightarrow>\n                   recognises_execution drinks2 2 r as;\n        a = (aa, b); a = (STR ''vend'', [])\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>(s', T)\n                                   |\\<in>|possible_steps drinks 1 r aa b.\n                             recognises_execution drinks s'\n                              (evaluate_updates T b r) as) \\<longrightarrow>\n                         (\\<exists>(s', T)\n                                   |\\<in>|possible_steps drinks2 2 r aa b.\n                             recognises_execution drinks2 s'\n                              (evaluate_updates T b r) as)\n 2. \\<And>aa b.\n       \\<lbrakk>\\<And>r.\n                   recognises_execution drinks 1 r as \\<longrightarrow>\n                   recognises_execution drinks2 2 r as;\n        a = (aa, b); a \\<noteq> (STR ''vend'', [])\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>(s', T)\n                                   |\\<in>|possible_steps drinks 1 r aa b.\n                             recognises_execution drinks s'\n                              (evaluate_updates T b r) as) \\<longrightarrow>\n                         (\\<exists>(s', T)\n                                   |\\<in>|possible_steps drinks2 2 r aa b.\n                             recognises_execution drinks2 s'\n                              (evaluate_updates T b r) as)", "apply (case_tac \"\\<exists>n. r$2 = Some (Num n)\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>aa b.\n       \\<lbrakk>\\<And>r.\n                   recognises_execution drinks 1 r as \\<longrightarrow>\n                   recognises_execution drinks2 2 r as;\n        a = (aa, b); a = (STR ''vend'', []);\n        \\<exists>n. r $ 2 = Some (Num n)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>(s', T)\n                                   |\\<in>|possible_steps drinks 1 r aa b.\n                             recognises_execution drinks s'\n                              (evaluate_updates T b r) as) \\<longrightarrow>\n                         (\\<exists>(s', T)\n                                   |\\<in>|possible_steps drinks2 2 r aa b.\n                             recognises_execution drinks2 s'\n                              (evaluate_updates T b r) as)\n 2. \\<And>aa b.\n       \\<lbrakk>\\<And>r.\n                   recognises_execution drinks 1 r as \\<longrightarrow>\n                   recognises_execution drinks2 2 r as;\n        a = (aa, b); a = (STR ''vend'', []);\n        \\<nexists>n. r $ 2 = Some (Num n)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>(s', T)\n                                   |\\<in>|possible_steps drinks 1 r aa b.\n                             recognises_execution drinks s'\n                              (evaluate_updates T b r) as) \\<longrightarrow>\n                         (\\<exists>(s', T)\n                                   |\\<in>|possible_steps drinks2 2 r aa b.\n                             recognises_execution drinks2 s'\n                              (evaluate_updates T b r) as)\n 3. \\<And>aa b.\n       \\<lbrakk>\\<And>r.\n                   recognises_execution drinks 1 r as \\<longrightarrow>\n                   recognises_execution drinks2 2 r as;\n        a = (aa, b); a \\<noteq> (STR ''vend'', [])\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>(s', T)\n                                   |\\<in>|possible_steps drinks 1 r aa b.\n                             recognises_execution drinks s'\n                              (evaluate_updates T b r) as) \\<longrightarrow>\n                         (\\<exists>(s', T)\n                                   |\\<in>|possible_steps drinks2 2 r aa b.\n                             recognises_execution drinks2 s'\n                              (evaluate_updates T b r) as)", "apply clarify"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>aa b n ab ba.\n       \\<lbrakk>\\<And>r.\n                   recognises_execution drinks 1 r as \\<longrightarrow>\n                   recognises_execution drinks2 2 r as;\n        a = (STR ''vend'', []); r $ 2 = Some (Num n);\n        (ab, ba) |\\<in>| possible_steps drinks 1 r STR ''vend'' [];\n        recognises_execution drinks ab (evaluate_updates ba [] r)\n         as\\<rbrakk>\n       \\<Longrightarrow> \\<exists>(s', T)\n                                  |\\<in>|possible_steps drinks2 2 r\n    STR ''vend'' [].\n                            recognises_execution drinks2 s'\n                             (evaluate_updates T [] r) as\n 2. \\<And>aa b.\n       \\<lbrakk>\\<And>r.\n                   recognises_execution drinks 1 r as \\<longrightarrow>\n                   recognises_execution drinks2 2 r as;\n        a = (aa, b); a = (STR ''vend'', []);\n        \\<nexists>n. r $ 2 = Some (Num n)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>(s', T)\n                                   |\\<in>|possible_steps drinks 1 r aa b.\n                             recognises_execution drinks s'\n                              (evaluate_updates T b r) as) \\<longrightarrow>\n                         (\\<exists>(s', T)\n                                   |\\<in>|possible_steps drinks2 2 r aa b.\n                             recognises_execution drinks2 s'\n                              (evaluate_updates T b r) as)\n 3. \\<And>aa b.\n       \\<lbrakk>\\<And>r.\n                   recognises_execution drinks 1 r as \\<longrightarrow>\n                   recognises_execution drinks2 2 r as;\n        a = (aa, b); a \\<noteq> (STR ''vend'', [])\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>(s', T)\n                                   |\\<in>|possible_steps drinks 1 r aa b.\n                             recognises_execution drinks s'\n                              (evaluate_updates T b r) as) \\<longrightarrow>\n                         (\\<exists>(s', T)\n                                   |\\<in>|possible_steps drinks2 2 r aa b.\n                             recognises_execution drinks2 s'\n                              (evaluate_updates T b r) as)", "apply (case_tac \"n < 100\")"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>aa b n aaa ba.\n       \\<lbrakk>\\<And>r.\n                   recognises_execution drinks 1 r as \\<longrightarrow>\n                   recognises_execution drinks2 2 r as;\n        a = (STR ''vend'', []); r $ 2 = Some (Num n);\n        (aaa, ba) |\\<in>| possible_steps drinks 1 r STR ''vend'' [];\n        recognises_execution drinks aaa (evaluate_updates ba [] r) as;\n        n < 100\\<rbrakk>\n       \\<Longrightarrow> \\<exists>(s', T)\n                                  |\\<in>|possible_steps drinks2 2 r\n    STR ''vend'' [].\n                            recognises_execution drinks2 s'\n                             (evaluate_updates T [] r) as\n 2. \\<And>aa b n aaa ba.\n       \\<lbrakk>\\<And>r.\n                   recognises_execution drinks 1 r as \\<longrightarrow>\n                   recognises_execution drinks2 2 r as;\n        a = (STR ''vend'', []); r $ 2 = Some (Num n);\n        (aaa, ba) |\\<in>| possible_steps drinks 1 r STR ''vend'' [];\n        recognises_execution drinks aaa (evaluate_updates ba [] r) as;\n        \\<not> n < 100\\<rbrakk>\n       \\<Longrightarrow> \\<exists>(s', T)\n                                  |\\<in>|possible_steps drinks2 2 r\n    STR ''vend'' [].\n                            recognises_execution drinks2 s'\n                             (evaluate_updates T [] r) as\n 3. \\<And>aa b.\n       \\<lbrakk>\\<And>r.\n                   recognises_execution drinks 1 r as \\<longrightarrow>\n                   recognises_execution drinks2 2 r as;\n        a = (aa, b); a = (STR ''vend'', []);\n        \\<nexists>n. r $ 2 = Some (Num n)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>(s', T)\n                                   |\\<in>|possible_steps drinks 1 r aa b.\n                             recognises_execution drinks s'\n                              (evaluate_updates T b r) as) \\<longrightarrow>\n                         (\\<exists>(s', T)\n                                   |\\<in>|possible_steps drinks2 2 r aa b.\n                             recognises_execution drinks2 s'\n                              (evaluate_updates T b r) as)\n 4. \\<And>aa b.\n       \\<lbrakk>\\<And>r.\n                   recognises_execution drinks 1 r as \\<longrightarrow>\n                   recognises_execution drinks2 2 r as;\n        a = (aa, b); a \\<noteq> (STR ''vend'', [])\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>(s', T)\n                                   |\\<in>|possible_steps drinks 1 r aa b.\n                             recognises_execution drinks s'\n                              (evaluate_updates T b r) as) \\<longrightarrow>\n                         (\\<exists>(s', T)\n                                   |\\<in>|possible_steps drinks2 2 r aa b.\n                             recognises_execution drinks2 s'\n                              (evaluate_updates T b r) as)", "apply (simp add: drinks_vend_insufficient drinks2_vend_insufficient2)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>aa b n aaa ba.\n       \\<lbrakk>\\<And>r.\n                   recognises_execution drinks 1 r as \\<longrightarrow>\n                   recognises_execution drinks2 2 r as;\n        a = (STR ''vend'', []); r $ 2 = Some (Num n);\n        (aaa, ba) |\\<in>| possible_steps drinks 1 r STR ''vend'' [];\n        recognises_execution drinks aaa (evaluate_updates ba [] r) as;\n        \\<not> n < 100\\<rbrakk>\n       \\<Longrightarrow> \\<exists>(s', T)\n                                  |\\<in>|possible_steps drinks2 2 r\n    STR ''vend'' [].\n                            recognises_execution drinks2 s'\n                             (evaluate_updates T [] r) as\n 2. \\<And>aa b.\n       \\<lbrakk>\\<And>r.\n                   recognises_execution drinks 1 r as \\<longrightarrow>\n                   recognises_execution drinks2 2 r as;\n        a = (aa, b); a = (STR ''vend'', []);\n        \\<nexists>n. r $ 2 = Some (Num n)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>(s', T)\n                                   |\\<in>|possible_steps drinks 1 r aa b.\n                             recognises_execution drinks s'\n                              (evaluate_updates T b r) as) \\<longrightarrow>\n                         (\\<exists>(s', T)\n                                   |\\<in>|possible_steps drinks2 2 r aa b.\n                             recognises_execution drinks2 s'\n                              (evaluate_updates T b r) as)\n 3. \\<And>aa b.\n       \\<lbrakk>\\<And>r.\n                   recognises_execution drinks 1 r as \\<longrightarrow>\n                   recognises_execution drinks2 2 r as;\n        a = (aa, b); a \\<noteq> (STR ''vend'', [])\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>(s', T)\n                                   |\\<in>|possible_steps drinks 1 r aa b.\n                             recognises_execution drinks s'\n                              (evaluate_updates T b r) as) \\<longrightarrow>\n                         (\\<exists>(s', T)\n                                   |\\<in>|possible_steps drinks2 2 r aa b.\n                             recognises_execution drinks2 s'\n                              (evaluate_updates T b r) as)", "apply (simp add: drinks_vend_sufficient drinks2_vend_sufficient)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>n aa.\n       \\<lbrakk>\\<And>r.\n                   recognises_execution drinks 1 r as \\<longrightarrow>\n                   recognises_execution drinks2 2 r as;\n        a = (STR ''vend'', []); r $ 2 = Some (Num n); aa = 2;\n        recognises_execution drinks 2 (evaluate_updates vend [] r) as;\n        \\<not> n < 100\\<rbrakk>\n       \\<Longrightarrow> recognises_execution drinks2 3\n                          (evaluate_updates vend [] r) as\n 2. \\<And>aa b.\n       \\<lbrakk>\\<And>r.\n                   recognises_execution drinks 1 r as \\<longrightarrow>\n                   recognises_execution drinks2 2 r as;\n        a = (aa, b); a = (STR ''vend'', []);\n        \\<nexists>n. r $ 2 = Some (Num n)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>(s', T)\n                                   |\\<in>|possible_steps drinks 1 r aa b.\n                             recognises_execution drinks s'\n                              (evaluate_updates T b r) as) \\<longrightarrow>\n                         (\\<exists>(s', T)\n                                   |\\<in>|possible_steps drinks2 2 r aa b.\n                             recognises_execution drinks2 s'\n                              (evaluate_updates T b r) as)\n 3. \\<And>aa b.\n       \\<lbrakk>\\<And>r.\n                   recognises_execution drinks 1 r as \\<longrightarrow>\n                   recognises_execution drinks2 2 r as;\n        a = (aa, b); a \\<noteq> (STR ''vend'', [])\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>(s', T)\n                                   |\\<in>|possible_steps drinks 1 r aa b.\n                             recognises_execution drinks s'\n                              (evaluate_updates T b r) as) \\<longrightarrow>\n                         (\\<exists>(s', T)\n                                   |\\<in>|possible_steps drinks2 2 r aa b.\n                             recognises_execution drinks2 s'\n                              (evaluate_updates T b r) as)", "apply (metis recognises_prim recognises_prim.elims(3) drinks_rejects_future)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa b.\n       \\<lbrakk>\\<And>r.\n                   recognises_execution drinks 1 r as \\<longrightarrow>\n                   recognises_execution drinks2 2 r as;\n        a = (aa, b); a = (STR ''vend'', []);\n        \\<nexists>n. r $ 2 = Some (Num n)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>(s', T)\n                                   |\\<in>|possible_steps drinks 1 r aa b.\n                             recognises_execution drinks s'\n                              (evaluate_updates T b r) as) \\<longrightarrow>\n                         (\\<exists>(s', T)\n                                   |\\<in>|possible_steps drinks2 2 r aa b.\n                             recognises_execution drinks2 s'\n                              (evaluate_updates T b r) as)\n 2. \\<And>aa b.\n       \\<lbrakk>\\<And>r.\n                   recognises_execution drinks 1 r as \\<longrightarrow>\n                   recognises_execution drinks2 2 r as;\n        a = (aa, b); a \\<noteq> (STR ''vend'', [])\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>(s', T)\n                                   |\\<in>|possible_steps drinks 1 r aa b.\n                             recognises_execution drinks s'\n                              (evaluate_updates T b r) as) \\<longrightarrow>\n                         (\\<exists>(s', T)\n                                   |\\<in>|possible_steps drinks2 2 r aa b.\n                             recognises_execution drinks2 s'\n                              (evaluate_updates T b r) as)", "using drinks_vend_invalid"], ["proof (prove)\nusing this:\n  \\<nexists>n. ?r $ 2 = Some (Num n) \\<Longrightarrow>\n  possible_steps drinks 1 ?r STR ''vend'' [] = {||}\n\ngoal (2 subgoals):\n 1. \\<And>aa b.\n       \\<lbrakk>\\<And>r.\n                   recognises_execution drinks 1 r as \\<longrightarrow>\n                   recognises_execution drinks2 2 r as;\n        a = (aa, b); a = (STR ''vend'', []);\n        \\<nexists>n. r $ 2 = Some (Num n)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>(s', T)\n                                   |\\<in>|possible_steps drinks 1 r aa b.\n                             recognises_execution drinks s'\n                              (evaluate_updates T b r) as) \\<longrightarrow>\n                         (\\<exists>(s', T)\n                                   |\\<in>|possible_steps drinks2 2 r aa b.\n                             recognises_execution drinks2 s'\n                              (evaluate_updates T b r) as)\n 2. \\<And>aa b.\n       \\<lbrakk>\\<And>r.\n                   recognises_execution drinks 1 r as \\<longrightarrow>\n                   recognises_execution drinks2 2 r as;\n        a = (aa, b); a \\<noteq> (STR ''vend'', [])\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>(s', T)\n                                   |\\<in>|possible_steps drinks 1 r aa b.\n                             recognises_execution drinks s'\n                              (evaluate_updates T b r) as) \\<longrightarrow>\n                         (\\<exists>(s', T)\n                                   |\\<in>|possible_steps drinks2 2 r aa b.\n                             recognises_execution drinks2 s'\n                              (evaluate_updates T b r) as)", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b.\n       \\<lbrakk>\\<And>r.\n                   recognises_execution drinks 1 r as \\<longrightarrow>\n                   recognises_execution drinks2 2 r as;\n        a = (aa, b); a \\<noteq> (STR ''vend'', [])\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>(s', T)\n                                   |\\<in>|possible_steps drinks 1 r aa b.\n                             recognises_execution drinks s'\n                              (evaluate_updates T b r) as) \\<longrightarrow>\n                         (\\<exists>(s', T)\n                                   |\\<in>|possible_steps drinks2 2 r aa b.\n                             recognises_execution drinks2 s'\n                              (evaluate_updates T b r) as)", "apply (case_tac \"\\<exists>i. a=(STR ''coin'', [i])\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa b.\n       \\<lbrakk>\\<And>r.\n                   recognises_execution drinks 1 r as \\<longrightarrow>\n                   recognises_execution drinks2 2 r as;\n        a = (aa, b); a \\<noteq> (STR ''vend'', []);\n        \\<exists>i. a = (STR ''coin'', [i])\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>(s', T)\n                                   |\\<in>|possible_steps drinks 1 r aa b.\n                             recognises_execution drinks s'\n                              (evaluate_updates T b r) as) \\<longrightarrow>\n                         (\\<exists>(s', T)\n                                   |\\<in>|possible_steps drinks2 2 r aa b.\n                             recognises_execution drinks2 s'\n                              (evaluate_updates T b r) as)\n 2. \\<And>aa b.\n       \\<lbrakk>\\<And>r.\n                   recognises_execution drinks 1 r as \\<longrightarrow>\n                   recognises_execution drinks2 2 r as;\n        a = (aa, b); a \\<noteq> (STR ''vend'', []);\n        \\<nexists>i. a = (STR ''coin'', [i])\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>(s', T)\n                                   |\\<in>|possible_steps drinks 1 r aa b.\n                             recognises_execution drinks s'\n                              (evaluate_updates T b r) as) \\<longrightarrow>\n                         (\\<exists>(s', T)\n                                   |\\<in>|possible_steps drinks2 2 r aa b.\n                             recognises_execution drinks2 s'\n                              (evaluate_updates T b r) as)", "apply clarify"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa b i ab ba.\n       \\<lbrakk>\\<And>r.\n                   recognises_execution drinks 1 r as \\<longrightarrow>\n                   recognises_execution drinks2 2 r as;\n        a = (STR ''coin'', [i]);\n        \\<not> (STR ''coin'' = STR ''vend'' \\<and> [i] = []);\n        (ab, ba) |\\<in>| possible_steps drinks 1 r STR ''coin'' [i];\n        recognises_execution drinks ab (evaluate_updates ba [i] r)\n         as\\<rbrakk>\n       \\<Longrightarrow> \\<exists>(s', T)\n                                  |\\<in>|possible_steps drinks2 2 r\n    STR ''coin'' [i].\n                            recognises_execution drinks2 s'\n                             (evaluate_updates T [i] r) as\n 2. \\<And>aa b.\n       \\<lbrakk>\\<And>r.\n                   recognises_execution drinks 1 r as \\<longrightarrow>\n                   recognises_execution drinks2 2 r as;\n        a = (aa, b); a \\<noteq> (STR ''vend'', []);\n        \\<nexists>i. a = (STR ''coin'', [i])\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>(s', T)\n                                   |\\<in>|possible_steps drinks 1 r aa b.\n                             recognises_execution drinks s'\n                              (evaluate_updates T b r) as) \\<longrightarrow>\n                         (\\<exists>(s', T)\n                                   |\\<in>|possible_steps drinks2 2 r aa b.\n                             recognises_execution drinks2 s'\n                              (evaluate_updates T b r) as)", "apply (simp add: possible_steps_1_coin possible_steps_2_coin)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b.\n       \\<lbrakk>\\<And>r.\n                   recognises_execution drinks 1 r as \\<longrightarrow>\n                   recognises_execution drinks2 2 r as;\n        a = (aa, b); a \\<noteq> (STR ''vend'', []);\n        \\<nexists>i. a = (STR ''coin'', [i])\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>(s', T)\n                                   |\\<in>|possible_steps drinks 1 r aa b.\n                             recognises_execution drinks s'\n                              (evaluate_updates T b r) as) \\<longrightarrow>\n                         (\\<exists>(s', T)\n                                   |\\<in>|possible_steps drinks2 2 r aa b.\n                             recognises_execution drinks2 s'\n                              (evaluate_updates T b r) as)", "by (metis recognises_execution.simps drinks_1_rejects_trace)"], ["proof (state)\nthis:\n  recognises_execution drinks 1 r (a # as) \\<longrightarrow>\n  recognises_execution drinks2 2 r (a # as)\n\ngoal (1 subgoal):\n 1. \\<And>r.\n       recognises_execution drinks 1 r [] \\<longrightarrow>\n       recognises_execution drinks2 2 r []", "qed auto"], ["", "lemma drinks_reject_0_2:\n  \"\\<nexists>i. a = (STR ''select'', [i]) \\<Longrightarrow>\n   possible_steps drinks 0 r (fst a) (snd a) = {||}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nexists>i. a = (STR ''select'', [i]) \\<Longrightarrow>\n    possible_steps drinks 0 r (fst a) (snd a) = {||}", "apply (rule drinks_0_rejects)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nexists>i. a = (STR ''select'', [i]) \\<Longrightarrow>\n    \\<not> (fst a = STR ''select'' \\<and> length (snd a) = 1)", "by (cases a, case_tac \"snd a\", auto)"], ["", "lemma purchase_coke:\n  \"observe_execution drinks2 0 <> [((STR ''select''), [Str ''coke'']), ((STR ''coin''), [Num 50]), ((STR ''coin''), [Num 50]), ((STR ''vend''), [])] =\n                       [[], [Some (Num 50)], [Some (Num 100)], [Some (Str ''coke'')]]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. observe_execution drinks2 0 <>\n     [(STR ''select'', [EFSM.Str ''coke'']), (STR ''coin'', [Num 50]),\n      (STR ''coin'', [Num 50]), (STR ''vend'', [])] =\n    [[], [Some (Num 50)], [Some (Num 100)], [Some (EFSM.Str ''coke'')]]", "by (simp add: possible_steps_0 select_def apply_updates_def\n                   possible_steps_1 coin_def apply_outputs finfun_update_twist\n                   possible_steps_2_coin possible_steps_2_vend vend_def)"], ["", "lemma drinks2_0_invalid:\n  \"\\<not> (aa = (STR ''select'') \\<and> length (b) = 1) \\<Longrightarrow>\n    (possible_steps drinks2 0 <> aa b) = {||}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (aa = STR ''select'' \\<and> length b = 1) \\<Longrightarrow>\n    possible_steps drinks2 0 <> aa b = {||}", "apply (simp add: drinks2_def possible_steps_def transitions)"], ["proof (prove)\ngoal (1 subgoal):\n 1. aa = STR ''select'' \\<longrightarrow>\n    length b \\<noteq> 1 \\<Longrightarrow>\n    ffilter\n     (\\<lambda>((origin, dest), t).\n         origin = 0 \\<and>\n         Label t = aa \\<and>\n         length b = Arity t \\<and> apply_guards (Guards t) (join_ir b <>))\n     {|((0, 1),\n        \\<lparr>Label = STR ''select'', Arity = 1, Guards = [],\n           Outputs = [], Updates = [(1, V (I 0)), (2, L (Num 0))]\\<rparr>),\n       ((1, 1),\n        \\<lparr>Label = STR ''vend'', Arity = 0, Guards = [], Outputs = [],\n           Updates = [(1, V (R 1)), (2, V (R 2))]\\<rparr>),\n       ((1, 2),\n        \\<lparr>Label = STR ''coin'', Arity = 1, Guards = [],\n           Outputs = [Plus (V (R 2)) (V (I 0))],\n           Updates = [(1, V (R 1)), (2, Plus (V (R 2)) (V (I 0)))]\\<rparr>),\n       ((2, 2),\n        \\<lparr>Label = STR ''coin'', Arity = 1, Guards = [],\n           Outputs = [Plus (V (R 2)) (V (I 0))],\n           Updates = [(1, V (R 1)), (2, Plus (V (R 2)) (V (I 0)))]\\<rparr>),\n       ((2, 2),\n        \\<lparr>Label = STR ''vend'', Arity = 0,\n           Guards = [Lt (V (R 2)) (L (Num 100))], Outputs = [],\n           Updates = [(1, V (R 1)), (2, V (R 2))]\\<rparr>),\n       ((2, 3),\n        \\<lparr>Label = STR ''vend'', Arity = 0,\n           Guards = [Ge (V (R 2)) (L (Num 100))], Outputs = [V (R 1)],\n           Updates = [(1, V (R 1)), (2, V (R 2))]\\<rparr>)|} =\n    {||}", "by force"], ["", "lemma drinks2_vend_r2_none:\n  \"r $ 2 = None \\<Longrightarrow> possible_steps drinks2 2 r ((STR ''vend'')) [] = {||}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r $ 2 = None \\<Longrightarrow>\n    possible_steps drinks2 2 r STR ''vend'' [] = {||}", "apply (simp add: possible_steps_empty drinks2_def can_take_transition_def can_take_def transitions)"], ["proof (prove)\ngoal (1 subgoal):\n 1. r $ 2 = None \\<Longrightarrow>\n    value_gt (Some (Num 100)) None \\<noteq> true \\<and>\n    \\<not>? value_gt (Some (Num 100)) None \\<noteq> true", "by (simp add: value_gt_def)"], ["", "lemma drinks2_end: \"possible_steps drinks2 3 r a b = {||}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. possible_steps drinks2 3 r a b = {||}", "apply (simp add: possible_steps_def drinks2_def transitions)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ffilter\n     (\\<lambda>((origin, dest), t).\n         origin = 3 \\<and>\n         Label t = a \\<and>\n         length b = Arity t \\<and> apply_guards (Guards t) (join_ir b r))\n     {|((0, 1),\n        \\<lparr>Label = STR ''select'', Arity = 1, Guards = [],\n           Outputs = [], Updates = [(1, V (I 0)), (2, L (Num 0))]\\<rparr>),\n       ((1, 1),\n        \\<lparr>Label = STR ''vend'', Arity = 0, Guards = [], Outputs = [],\n           Updates = [(1, V (R 1)), (2, V (R 2))]\\<rparr>),\n       ((1, 2),\n        \\<lparr>Label = STR ''coin'', Arity = 1, Guards = [],\n           Outputs = [Plus (V (R 2)) (V (I 0))],\n           Updates = [(1, V (R 1)), (2, Plus (V (R 2)) (V (I 0)))]\\<rparr>),\n       ((2, 2),\n        \\<lparr>Label = STR ''coin'', Arity = 1, Guards = [],\n           Outputs = [Plus (V (R 2)) (V (I 0))],\n           Updates = [(1, V (R 1)), (2, Plus (V (R 2)) (V (I 0)))]\\<rparr>),\n       ((2, 2),\n        \\<lparr>Label = STR ''vend'', Arity = 0,\n           Guards = [Lt (V (R 2)) (L (Num 100))], Outputs = [],\n           Updates = [(1, V (R 1)), (2, V (R 2))]\\<rparr>),\n       ((2, 3),\n        \\<lparr>Label = STR ''vend'', Arity = 0,\n           Guards = [Ge (V (R 2)) (L (Num 100))], Outputs = [V (R 1)],\n           Updates = [(1, V (R 1)), (2, V (R 2))]\\<rparr>)|} =\n    {||}", "by force"], ["", "lemma drinks2_vend_r2_String: \"r $ 2 = Some (value.Str x2) \\<Longrightarrow>\n                possible_steps drinks2 2 r ((STR ''vend'')) [] = {||}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r $ 2 = Some (value.Str x2) \\<Longrightarrow>\n    possible_steps drinks2 2 r STR ''vend'' [] = {||}", "apply (simp add: possible_steps_empty drinks2_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. r $ 2 = Some (value.Str x2) \\<Longrightarrow>\n    (Label coin = STR ''vend'' \\<longrightarrow>\n     \\<not> can_take_transition coin [] r) \\<and>\n    (Label vend_fail = STR ''vend'' \\<longrightarrow>\n     \\<not> can_take_transition vend_fail [] r) \\<and>\n    (Label vend = STR ''vend'' \\<longrightarrow>\n     \\<not> can_take_transition vend [] r)", "apply safe"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>r $ 2 = Some (value.Str x2); Label coin = STR ''vend'';\n     can_take_transition coin [] r\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>r $ 2 = Some (value.Str x2); Label vend_fail = STR ''vend'';\n     can_take_transition vend_fail [] r\\<rbrakk>\n    \\<Longrightarrow> False\n 3. \\<lbrakk>r $ 2 = Some (value.Str x2); Label vend = STR ''vend'';\n     can_take_transition vend [] r\\<rbrakk>\n    \\<Longrightarrow> False", "by (simp_all add: transitions can_take_transition_def can_take_def value_gt_def)"], ["", "lemma drinks2_2_invalid:\n  \"fst a = (STR ''coin'') \\<longrightarrow> length (snd a) \\<noteq> 1 \\<Longrightarrow>\n          a \\<noteq> ((STR ''vend''), []) \\<Longrightarrow>\n          possible_steps drinks2 2 r (fst a) (snd a) = {||}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>fst a = STR ''coin'' \\<longrightarrow>\n             length (snd a) \\<noteq> 1;\n     a \\<noteq> (STR ''vend'', [])\\<rbrakk>\n    \\<Longrightarrow> possible_steps drinks2 2 r (fst a) (snd a) = {||}", "apply (simp add: possible_steps_empty drinks2_def transitions can_take_transition_def can_take_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>fst a = STR ''coin'' \\<longrightarrow>\n             length (snd a) \\<noteq> 1;\n     a \\<noteq> (STR ''vend'', [])\\<rbrakk>\n    \\<Longrightarrow> (length (snd a) = 1 \\<longrightarrow>\n                       STR ''coin'' \\<noteq> fst a) \\<and>\n                      (snd a = [] \\<longrightarrow>\n                       STR ''vend'' = fst a \\<longrightarrow>\n                       value_gt (Some (Num 100)) (r $ 2) \\<noteq>\n                       true) \\<and>\n                      (snd a = [] \\<longrightarrow>\n                       STR ''vend'' = fst a \\<longrightarrow>\n                       \\<not>? value_gt (Some (Num 100)) (r $ 2) \\<noteq>\n                       true)", "by (metis prod.collapse)"], ["", "lemma drinks2_1_invalid:\n  \"\\<not>(a = (STR ''coin'') \\<and> length b = 1) \\<Longrightarrow>\n      \\<not>(a = (STR ''vend'') \\<and> b = []) \\<Longrightarrow>\n    possible_steps drinks2 1 r a b = {||}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> (a = STR ''coin'' \\<and> length b = 1);\n     \\<not> (a = STR ''vend'' \\<and> b = [])\\<rbrakk>\n    \\<Longrightarrow> possible_steps drinks2 1 r a b = {||}", "apply (simp add: possible_steps_empty drinks2_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a = STR ''coin'' \\<longrightarrow> length b \\<noteq> 1;\n     a = STR ''vend'' \\<longrightarrow> b \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> (Label vend_nothing = a \\<longrightarrow>\n                       \\<not> can_take_transition vend_nothing b r) \\<and>\n                      (Label coin = a \\<longrightarrow>\n                       \\<not> can_take_transition coin b r)", "apply safe"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<lbrakk>Label vend_nothing \\<noteq> STR ''coin'';\n     Label vend_nothing \\<noteq> STR ''vend''; a = Label vend_nothing;\n     can_take_transition vend_nothing b r\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>Label coin \\<noteq> STR ''coin'';\n     Label coin \\<noteq> STR ''vend''; a = Label coin;\n     can_take_transition coin b r\\<rbrakk>\n    \\<Longrightarrow> False\n 3. \\<lbrakk>Label vend_nothing \\<noteq> STR ''coin''; b \\<noteq> [];\n     a = Label vend_nothing; can_take_transition vend_nothing b r\\<rbrakk>\n    \\<Longrightarrow> False\n 4. \\<lbrakk>Label coin \\<noteq> STR ''coin''; b \\<noteq> [];\n     a = Label coin; can_take_transition coin b r\\<rbrakk>\n    \\<Longrightarrow> False\n 5. \\<lbrakk>length b \\<noteq> 1; Label vend_nothing \\<noteq> STR ''vend'';\n     a = Label vend_nothing; can_take_transition vend_nothing b r\\<rbrakk>\n    \\<Longrightarrow> False\n 6. \\<lbrakk>length b \\<noteq> 1; Label coin \\<noteq> STR ''vend'';\n     a = Label coin; can_take_transition coin b r\\<rbrakk>\n    \\<Longrightarrow> False\n 7. \\<lbrakk>length b \\<noteq> 1; b \\<noteq> []; a = Label vend_nothing;\n     can_take_transition vend_nothing b r\\<rbrakk>\n    \\<Longrightarrow> False\n 8. \\<lbrakk>length b \\<noteq> 1; b \\<noteq> []; a = Label coin;\n     can_take_transition coin b r\\<rbrakk>\n    \\<Longrightarrow> False", "by (simp_all add: transitions can_take_transition_def can_take_def value_gt_def)"], ["", "lemma drinks2_vend_invalid:\n  \"\\<nexists>n. r $ 2 = Some (Num n) \\<Longrightarrow>\n   possible_steps drinks2 2 r (STR ''vend'') [] = {||}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nexists>n. r $ 2 = Some (Num n) \\<Longrightarrow>\n    possible_steps drinks2 2 r STR ''vend'' [] = {||}", "apply (simp add: possible_steps_empty drinks2_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n. r $ 2 \\<noteq> Some (Num n) \\<Longrightarrow>\n    (Label coin = STR ''vend'' \\<longrightarrow>\n     \\<not> can_take_transition coin [] r) \\<and>\n    (Label vend_fail = STR ''vend'' \\<longrightarrow>\n     \\<not> can_take_transition vend_fail [] r) \\<and>\n    (Label vend = STR ''vend'' \\<longrightarrow>\n     \\<not> can_take_transition vend [] r)", "apply safe"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<forall>n. r $ 2 \\<noteq> Some (Num n);\n     Label coin = STR ''vend''; can_take_transition coin [] r\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>\\<forall>n. r $ 2 \\<noteq> Some (Num n);\n     Label vend_fail = STR ''vend'';\n     can_take_transition vend_fail [] r\\<rbrakk>\n    \\<Longrightarrow> False\n 3. \\<lbrakk>\\<forall>n. r $ 2 \\<noteq> Some (Num n);\n     Label vend = STR ''vend''; can_take_transition vend [] r\\<rbrakk>\n    \\<Longrightarrow> False", "by (simp_all add: transitions can_take_transition_def can_take_def value_gt_def MaybeBoolInt_not_num_1)"], ["", "lemma equiv_1_2: \"executionally_equivalent drinks 1 r drinks2 2 r x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. executionally_equivalent drinks 1 r drinks2 2 r x", "proof(induct x arbitrary: r)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>r. executionally_equivalent drinks 1 r drinks2 2 r []\n 2. \\<And>a x r.\n       (\\<And>r.\n           executionally_equivalent drinks 1 r drinks2 2 r\n            x) \\<Longrightarrow>\n       executionally_equivalent drinks 1 r drinks2 2 r (a # x)", "case (Cons a t)"], ["proof (state)\nthis:\n  executionally_equivalent drinks 1 ?r drinks2 2 ?r t\n\ngoal (2 subgoals):\n 1. \\<And>r. executionally_equivalent drinks 1 r drinks2 2 r []\n 2. \\<And>a x r.\n       (\\<And>r.\n           executionally_equivalent drinks 1 r drinks2 2 r\n            x) \\<Longrightarrow>\n       executionally_equivalent drinks 1 r drinks2 2 r (a # x)", "then"], ["proof (chain)\npicking this:\n  executionally_equivalent drinks 1 ?r drinks2 2 ?r t", "show ?case"], ["proof (prove)\nusing this:\n  executionally_equivalent drinks 1 ?r drinks2 2 ?r t\n\ngoal (1 subgoal):\n 1. executionally_equivalent drinks 1 r drinks2 2 r (a # t)", "apply (cases a, clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b.\n       \\<lbrakk>a = (aa, b);\n        \\<And>r. executionally_equivalent drinks 1 r drinks2 2 r t\\<rbrakk>\n       \\<Longrightarrow> executionally_equivalent drinks 1 r drinks2 2 r\n                          ((aa, b) # t)", "apply (simp add: executionally_equivalent_step)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b.\n       \\<lbrakk>a = (aa, b);\n        \\<And>r. executionally_equivalent drinks 1 r drinks2 2 r t\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>(s1', t1)\n                                   |\\<in>|possible_steps drinks 1 r aa b.\n                             \\<exists>(s2', t2)\n|\\<in>|possible_steps drinks2 2 r aa b.\n                                evaluate_outputs t1 b r =\n                                evaluate_outputs t2 b r \\<and>\n                                executionally_equivalent drinks s1'\n                                 (evaluate_updates t1 b r) drinks2 s2'\n                                 (evaluate_updates t2 b r) t) \\<and>\n                         (\\<forall>(s2', t2)\n                                   |\\<in>|possible_steps drinks2 2 r aa b.\n                             \\<exists>(s1', t1)\n|\\<in>|possible_steps drinks 1 r aa b.\n                                evaluate_outputs t1 b r =\n                                evaluate_outputs t2 b r \\<and>\n                                executionally_equivalent drinks s1'\n                                 (evaluate_updates t1 b r) drinks2 s2'\n                                 (evaluate_updates t2 b r) t)", "apply (case_tac \"fst a = STR ''coin'' \\<and> length (snd a) = 1\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa b.\n       \\<lbrakk>a = (aa, b);\n        \\<And>r. executionally_equivalent drinks 1 r drinks2 2 r t;\n        fst a = STR ''coin'' \\<and> length (snd a) = 1\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>(s1', t1)\n                                   |\\<in>|possible_steps drinks 1 r aa b.\n                             \\<exists>(s2', t2)\n|\\<in>|possible_steps drinks2 2 r aa b.\n                                evaluate_outputs t1 b r =\n                                evaluate_outputs t2 b r \\<and>\n                                executionally_equivalent drinks s1'\n                                 (evaluate_updates t1 b r) drinks2 s2'\n                                 (evaluate_updates t2 b r) t) \\<and>\n                         (\\<forall>(s2', t2)\n                                   |\\<in>|possible_steps drinks2 2 r aa b.\n                             \\<exists>(s1', t1)\n|\\<in>|possible_steps drinks 1 r aa b.\n                                evaluate_outputs t1 b r =\n                                evaluate_outputs t2 b r \\<and>\n                                executionally_equivalent drinks s1'\n                                 (evaluate_updates t1 b r) drinks2 s2'\n                                 (evaluate_updates t2 b r) t)\n 2. \\<And>aa b.\n       \\<lbrakk>a = (aa, b);\n        \\<And>r. executionally_equivalent drinks 1 r drinks2 2 r t;\n        \\<not> (fst a = STR ''coin'' \\<and> length (snd a) = 1)\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>(s1', t1)\n                                   |\\<in>|possible_steps drinks 1 r aa b.\n                             \\<exists>(s2', t2)\n|\\<in>|possible_steps drinks2 2 r aa b.\n                                evaluate_outputs t1 b r =\n                                evaluate_outputs t2 b r \\<and>\n                                executionally_equivalent drinks s1'\n                                 (evaluate_updates t1 b r) drinks2 s2'\n                                 (evaluate_updates t2 b r) t) \\<and>\n                         (\\<forall>(s2', t2)\n                                   |\\<in>|possible_steps drinks2 2 r aa b.\n                             \\<exists>(s1', t1)\n|\\<in>|possible_steps drinks 1 r aa b.\n                                evaluate_outputs t1 b r =\n                                evaluate_outputs t2 b r \\<and>\n                                executionally_equivalent drinks s1'\n                                 (evaluate_updates t1 b r) drinks2 s2'\n                                 (evaluate_updates t2 b r) t)", "apply (simp add: Drinks_Machine.possible_steps_1_coin possible_steps_2_coin)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b.\n       \\<lbrakk>a = (aa, b);\n        \\<And>r. executionally_equivalent drinks 1 r drinks2 2 r t;\n        \\<not> (fst a = STR ''coin'' \\<and> length (snd a) = 1)\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>(s1', t1)\n                                   |\\<in>|possible_steps drinks 1 r aa b.\n                             \\<exists>(s2', t2)\n|\\<in>|possible_steps drinks2 2 r aa b.\n                                evaluate_outputs t1 b r =\n                                evaluate_outputs t2 b r \\<and>\n                                executionally_equivalent drinks s1'\n                                 (evaluate_updates t1 b r) drinks2 s2'\n                                 (evaluate_updates t2 b r) t) \\<and>\n                         (\\<forall>(s2', t2)\n                                   |\\<in>|possible_steps drinks2 2 r aa b.\n                             \\<exists>(s1', t1)\n|\\<in>|possible_steps drinks 1 r aa b.\n                                evaluate_outputs t1 b r =\n                                evaluate_outputs t2 b r \\<and>\n                                executionally_equivalent drinks s1'\n                                 (evaluate_updates t1 b r) drinks2 s2'\n                                 (evaluate_updates t2 b r) t)", "apply (case_tac \"a = (STR ''vend'', [])\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa b.\n       \\<lbrakk>a = (aa, b);\n        \\<And>r. executionally_equivalent drinks 1 r drinks2 2 r t;\n        \\<not> (fst a = STR ''coin'' \\<and> length (snd a) = 1);\n        a = (STR ''vend'', [])\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>(s1', t1)\n                                   |\\<in>|possible_steps drinks 1 r aa b.\n                             \\<exists>(s2', t2)\n|\\<in>|possible_steps drinks2 2 r aa b.\n                                evaluate_outputs t1 b r =\n                                evaluate_outputs t2 b r \\<and>\n                                executionally_equivalent drinks s1'\n                                 (evaluate_updates t1 b r) drinks2 s2'\n                                 (evaluate_updates t2 b r) t) \\<and>\n                         (\\<forall>(s2', t2)\n                                   |\\<in>|possible_steps drinks2 2 r aa b.\n                             \\<exists>(s1', t1)\n|\\<in>|possible_steps drinks 1 r aa b.\n                                evaluate_outputs t1 b r =\n                                evaluate_outputs t2 b r \\<and>\n                                executionally_equivalent drinks s1'\n                                 (evaluate_updates t1 b r) drinks2 s2'\n                                 (evaluate_updates t2 b r) t)\n 2. \\<And>aa b.\n       \\<lbrakk>a = (aa, b);\n        \\<And>r. executionally_equivalent drinks 1 r drinks2 2 r t;\n        \\<not> (fst a = STR ''coin'' \\<and> length (snd a) = 1);\n        a \\<noteq> (STR ''vend'', [])\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>(s1', t1)\n                                   |\\<in>|possible_steps drinks 1 r aa b.\n                             \\<exists>(s2', t2)\n|\\<in>|possible_steps drinks2 2 r aa b.\n                                evaluate_outputs t1 b r =\n                                evaluate_outputs t2 b r \\<and>\n                                executionally_equivalent drinks s1'\n                                 (evaluate_updates t1 b r) drinks2 s2'\n                                 (evaluate_updates t2 b r) t) \\<and>\n                         (\\<forall>(s2', t2)\n                                   |\\<in>|possible_steps drinks2 2 r aa b.\n                             \\<exists>(s1', t1)\n|\\<in>|possible_steps drinks 1 r aa b.\n                                evaluate_outputs t1 b r =\n                                evaluate_outputs t2 b r \\<and>\n                                executionally_equivalent drinks s1'\n                                 (evaluate_updates t1 b r) drinks2 s2'\n                                 (evaluate_updates t2 b r) t)", "defer"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa b.\n       \\<lbrakk>a = (aa, b);\n        \\<And>r. executionally_equivalent drinks 1 r drinks2 2 r t;\n        \\<not> (fst a = STR ''coin'' \\<and> length (snd a) = 1);\n        a \\<noteq> (STR ''vend'', [])\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>(s1', t1)\n                                   |\\<in>|possible_steps drinks 1 r aa b.\n                             \\<exists>(s2', t2)\n|\\<in>|possible_steps drinks2 2 r aa b.\n                                evaluate_outputs t1 b r =\n                                evaluate_outputs t2 b r \\<and>\n                                executionally_equivalent drinks s1'\n                                 (evaluate_updates t1 b r) drinks2 s2'\n                                 (evaluate_updates t2 b r) t) \\<and>\n                         (\\<forall>(s2', t2)\n                                   |\\<in>|possible_steps drinks2 2 r aa b.\n                             \\<exists>(s1', t1)\n|\\<in>|possible_steps drinks 1 r aa b.\n                                evaluate_outputs t1 b r =\n                                evaluate_outputs t2 b r \\<and>\n                                executionally_equivalent drinks s1'\n                                 (evaluate_updates t1 b r) drinks2 s2'\n                                 (evaluate_updates t2 b r) t)\n 2. \\<And>aa b.\n       \\<lbrakk>a = (aa, b);\n        \\<And>r. executionally_equivalent drinks 1 r drinks2 2 r t;\n        \\<not> (fst a = STR ''coin'' \\<and> length (snd a) = 1);\n        a = (STR ''vend'', [])\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>(s1', t1)\n                                   |\\<in>|possible_steps drinks 1 r aa b.\n                             \\<exists>(s2', t2)\n|\\<in>|possible_steps drinks2 2 r aa b.\n                                evaluate_outputs t1 b r =\n                                evaluate_outputs t2 b r \\<and>\n                                executionally_equivalent drinks s1'\n                                 (evaluate_updates t1 b r) drinks2 s2'\n                                 (evaluate_updates t2 b r) t) \\<and>\n                         (\\<forall>(s2', t2)\n                                   |\\<in>|possible_steps drinks2 2 r aa b.\n                             \\<exists>(s1', t1)\n|\\<in>|possible_steps drinks 1 r aa b.\n                                evaluate_outputs t1 b r =\n                                evaluate_outputs t2 b r \\<and>\n                                executionally_equivalent drinks s1'\n                                 (evaluate_updates t1 b r) drinks2 s2'\n                                 (evaluate_updates t2 b r) t)", "using drinks2_2_invalid drinks_no_possible_steps_1"], ["proof (prove)\nusing this:\n  \\<lbrakk>fst ?a = STR ''coin'' \\<longrightarrow>\n           length (snd ?a) \\<noteq> 1;\n   ?a \\<noteq> (STR ''vend'', [])\\<rbrakk>\n  \\<Longrightarrow> possible_steps drinks2 2 ?r (fst ?a) (snd ?a) = {||}\n  \\<lbrakk>\\<not> (?a = STR ''coin'' \\<and> length ?b = 1);\n   \\<not> (?a = STR ''vend'' \\<and> ?b = [])\\<rbrakk>\n  \\<Longrightarrow> possible_steps drinks 1 ?r ?a ?b = {||}\n\ngoal (2 subgoals):\n 1. \\<And>aa b.\n       \\<lbrakk>a = (aa, b);\n        \\<And>r. executionally_equivalent drinks 1 r drinks2 2 r t;\n        \\<not> (fst a = STR ''coin'' \\<and> length (snd a) = 1);\n        a \\<noteq> (STR ''vend'', [])\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>(s1', t1)\n                                   |\\<in>|possible_steps drinks 1 r aa b.\n                             \\<exists>(s2', t2)\n|\\<in>|possible_steps drinks2 2 r aa b.\n                                evaluate_outputs t1 b r =\n                                evaluate_outputs t2 b r \\<and>\n                                executionally_equivalent drinks s1'\n                                 (evaluate_updates t1 b r) drinks2 s2'\n                                 (evaluate_updates t2 b r) t) \\<and>\n                         (\\<forall>(s2', t2)\n                                   |\\<in>|possible_steps drinks2 2 r aa b.\n                             \\<exists>(s1', t1)\n|\\<in>|possible_steps drinks 1 r aa b.\n                                evaluate_outputs t1 b r =\n                                evaluate_outputs t2 b r \\<and>\n                                executionally_equivalent drinks s1'\n                                 (evaluate_updates t1 b r) drinks2 s2'\n                                 (evaluate_updates t2 b r) t)\n 2. \\<And>aa b.\n       \\<lbrakk>a = (aa, b);\n        \\<And>r. executionally_equivalent drinks 1 r drinks2 2 r t;\n        \\<not> (fst a = STR ''coin'' \\<and> length (snd a) = 1);\n        a = (STR ''vend'', [])\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>(s1', t1)\n                                   |\\<in>|possible_steps drinks 1 r aa b.\n                             \\<exists>(s2', t2)\n|\\<in>|possible_steps drinks2 2 r aa b.\n                                evaluate_outputs t1 b r =\n                                evaluate_outputs t2 b r \\<and>\n                                executionally_equivalent drinks s1'\n                                 (evaluate_updates t1 b r) drinks2 s2'\n                                 (evaluate_updates t2 b r) t) \\<and>\n                         (\\<forall>(s2', t2)\n                                   |\\<in>|possible_steps drinks2 2 r aa b.\n                             \\<exists>(s1', t1)\n|\\<in>|possible_steps drinks 1 r aa b.\n                                evaluate_outputs t1 b r =\n                                evaluate_outputs t2 b r \\<and>\n                                executionally_equivalent drinks s1'\n                                 (evaluate_updates t1 b r) drinks2 s2'\n                                 (evaluate_updates t2 b r) t)", "apply auto[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b.\n       \\<lbrakk>a = (aa, b);\n        \\<And>r. executionally_equivalent drinks 1 r drinks2 2 r t;\n        \\<not> (fst a = STR ''coin'' \\<and> length (snd a) = 1);\n        a = (STR ''vend'', [])\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>(s1', t1)\n                                   |\\<in>|possible_steps drinks 1 r aa b.\n                             \\<exists>(s2', t2)\n|\\<in>|possible_steps drinks2 2 r aa b.\n                                evaluate_outputs t1 b r =\n                                evaluate_outputs t2 b r \\<and>\n                                executionally_equivalent drinks s1'\n                                 (evaluate_updates t1 b r) drinks2 s2'\n                                 (evaluate_updates t2 b r) t) \\<and>\n                         (\\<forall>(s2', t2)\n                                   |\\<in>|possible_steps drinks2 2 r aa b.\n                             \\<exists>(s1', t1)\n|\\<in>|possible_steps drinks 1 r aa b.\n                                evaluate_outputs t1 b r =\n                                evaluate_outputs t2 b r \\<and>\n                                executionally_equivalent drinks s1'\n                                 (evaluate_updates t1 b r) drinks2 s2'\n                                 (evaluate_updates t2 b r) t)", "apply (case_tac \"\\<exists>n. r $ 2 = Some (Num n)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa b.\n       \\<lbrakk>a = (aa, b);\n        \\<And>r. executionally_equivalent drinks 1 r drinks2 2 r t;\n        \\<not> (fst a = STR ''coin'' \\<and> length (snd a) = 1);\n        a = (STR ''vend'', []); \\<exists>n. r $ 2 = Some (Num n)\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>(s1', t1)\n                                   |\\<in>|possible_steps drinks 1 r aa b.\n                             \\<exists>(s2', t2)\n|\\<in>|possible_steps drinks2 2 r aa b.\n                                evaluate_outputs t1 b r =\n                                evaluate_outputs t2 b r \\<and>\n                                executionally_equivalent drinks s1'\n                                 (evaluate_updates t1 b r) drinks2 s2'\n                                 (evaluate_updates t2 b r) t) \\<and>\n                         (\\<forall>(s2', t2)\n                                   |\\<in>|possible_steps drinks2 2 r aa b.\n                             \\<exists>(s1', t1)\n|\\<in>|possible_steps drinks 1 r aa b.\n                                evaluate_outputs t1 b r =\n                                evaluate_outputs t2 b r \\<and>\n                                executionally_equivalent drinks s1'\n                                 (evaluate_updates t1 b r) drinks2 s2'\n                                 (evaluate_updates t2 b r) t)\n 2. \\<And>aa b.\n       \\<lbrakk>a = (aa, b);\n        \\<And>r. executionally_equivalent drinks 1 r drinks2 2 r t;\n        \\<not> (fst a = STR ''coin'' \\<and> length (snd a) = 1);\n        a = (STR ''vend'', []); \\<nexists>n. r $ 2 = Some (Num n)\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>(s1', t1)\n                                   |\\<in>|possible_steps drinks 1 r aa b.\n                             \\<exists>(s2', t2)\n|\\<in>|possible_steps drinks2 2 r aa b.\n                                evaluate_outputs t1 b r =\n                                evaluate_outputs t2 b r \\<and>\n                                executionally_equivalent drinks s1'\n                                 (evaluate_updates t1 b r) drinks2 s2'\n                                 (evaluate_updates t2 b r) t) \\<and>\n                         (\\<forall>(s2', t2)\n                                   |\\<in>|possible_steps drinks2 2 r aa b.\n                             \\<exists>(s1', t1)\n|\\<in>|possible_steps drinks 1 r aa b.\n                                evaluate_outputs t1 b r =\n                                evaluate_outputs t2 b r \\<and>\n                                executionally_equivalent drinks s1'\n                                 (evaluate_updates t1 b r) drinks2 s2'\n                                 (evaluate_updates t2 b r) t)", "defer"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa b.\n       \\<lbrakk>a = (aa, b);\n        \\<And>r. executionally_equivalent drinks 1 r drinks2 2 r t;\n        \\<not> (fst a = STR ''coin'' \\<and> length (snd a) = 1);\n        a = (STR ''vend'', []); \\<nexists>n. r $ 2 = Some (Num n)\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>(s1', t1)\n                                   |\\<in>|possible_steps drinks 1 r aa b.\n                             \\<exists>(s2', t2)\n|\\<in>|possible_steps drinks2 2 r aa b.\n                                evaluate_outputs t1 b r =\n                                evaluate_outputs t2 b r \\<and>\n                                executionally_equivalent drinks s1'\n                                 (evaluate_updates t1 b r) drinks2 s2'\n                                 (evaluate_updates t2 b r) t) \\<and>\n                         (\\<forall>(s2', t2)\n                                   |\\<in>|possible_steps drinks2 2 r aa b.\n                             \\<exists>(s1', t1)\n|\\<in>|possible_steps drinks 1 r aa b.\n                                evaluate_outputs t1 b r =\n                                evaluate_outputs t2 b r \\<and>\n                                executionally_equivalent drinks s1'\n                                 (evaluate_updates t1 b r) drinks2 s2'\n                                 (evaluate_updates t2 b r) t)\n 2. \\<And>aa b.\n       \\<lbrakk>a = (aa, b);\n        \\<And>r. executionally_equivalent drinks 1 r drinks2 2 r t;\n        \\<not> (fst a = STR ''coin'' \\<and> length (snd a) = 1);\n        a = (STR ''vend'', []); \\<exists>n. r $ 2 = Some (Num n)\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>(s1', t1)\n                                   |\\<in>|possible_steps drinks 1 r aa b.\n                             \\<exists>(s2', t2)\n|\\<in>|possible_steps drinks2 2 r aa b.\n                                evaluate_outputs t1 b r =\n                                evaluate_outputs t2 b r \\<and>\n                                executionally_equivalent drinks s1'\n                                 (evaluate_updates t1 b r) drinks2 s2'\n                                 (evaluate_updates t2 b r) t) \\<and>\n                         (\\<forall>(s2', t2)\n                                   |\\<in>|possible_steps drinks2 2 r aa b.\n                             \\<exists>(s1', t1)\n|\\<in>|possible_steps drinks 1 r aa b.\n                                evaluate_outputs t1 b r =\n                                evaluate_outputs t2 b r \\<and>\n                                executionally_equivalent drinks s1'\n                                 (evaluate_updates t1 b r) drinks2 s2'\n                                 (evaluate_updates t2 b r) t)", "using drinks_vend_invalid drinks2_vend_invalid"], ["proof (prove)\nusing this:\n  \\<nexists>n. ?r $ 2 = Some (Num n) \\<Longrightarrow>\n  possible_steps drinks 1 ?r STR ''vend'' [] = {||}\n  \\<nexists>n. ?r $ 2 = Some (Num n) \\<Longrightarrow>\n  possible_steps drinks2 2 ?r STR ''vend'' [] = {||}\n\ngoal (2 subgoals):\n 1. \\<And>aa b.\n       \\<lbrakk>a = (aa, b);\n        \\<And>r. executionally_equivalent drinks 1 r drinks2 2 r t;\n        \\<not> (fst a = STR ''coin'' \\<and> length (snd a) = 1);\n        a = (STR ''vend'', []); \\<nexists>n. r $ 2 = Some (Num n)\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>(s1', t1)\n                                   |\\<in>|possible_steps drinks 1 r aa b.\n                             \\<exists>(s2', t2)\n|\\<in>|possible_steps drinks2 2 r aa b.\n                                evaluate_outputs t1 b r =\n                                evaluate_outputs t2 b r \\<and>\n                                executionally_equivalent drinks s1'\n                                 (evaluate_updates t1 b r) drinks2 s2'\n                                 (evaluate_updates t2 b r) t) \\<and>\n                         (\\<forall>(s2', t2)\n                                   |\\<in>|possible_steps drinks2 2 r aa b.\n                             \\<exists>(s1', t1)\n|\\<in>|possible_steps drinks 1 r aa b.\n                                evaluate_outputs t1 b r =\n                                evaluate_outputs t2 b r \\<and>\n                                executionally_equivalent drinks s1'\n                                 (evaluate_updates t1 b r) drinks2 s2'\n                                 (evaluate_updates t2 b r) t)\n 2. \\<And>aa b.\n       \\<lbrakk>a = (aa, b);\n        \\<And>r. executionally_equivalent drinks 1 r drinks2 2 r t;\n        \\<not> (fst a = STR ''coin'' \\<and> length (snd a) = 1);\n        a = (STR ''vend'', []); \\<exists>n. r $ 2 = Some (Num n)\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>(s1', t1)\n                                   |\\<in>|possible_steps drinks 1 r aa b.\n                             \\<exists>(s2', t2)\n|\\<in>|possible_steps drinks2 2 r aa b.\n                                evaluate_outputs t1 b r =\n                                evaluate_outputs t2 b r \\<and>\n                                executionally_equivalent drinks s1'\n                                 (evaluate_updates t1 b r) drinks2 s2'\n                                 (evaluate_updates t2 b r) t) \\<and>\n                         (\\<forall>(s2', t2)\n                                   |\\<in>|possible_steps drinks2 2 r aa b.\n                             \\<exists>(s1', t1)\n|\\<in>|possible_steps drinks 1 r aa b.\n                                evaluate_outputs t1 b r =\n                                evaluate_outputs t2 b r \\<and>\n                                executionally_equivalent drinks s1'\n                                 (evaluate_updates t1 b r) drinks2 s2'\n                                 (evaluate_updates t2 b r) t)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b.\n       \\<lbrakk>a = (aa, b);\n        \\<And>r. executionally_equivalent drinks 1 r drinks2 2 r t;\n        \\<not> (fst a = STR ''coin'' \\<and> length (snd a) = 1);\n        a = (STR ''vend'', []); \\<exists>n. r $ 2 = Some (Num n)\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>(s1', t1)\n                                   |\\<in>|possible_steps drinks 1 r aa b.\n                             \\<exists>(s2', t2)\n|\\<in>|possible_steps drinks2 2 r aa b.\n                                evaluate_outputs t1 b r =\n                                evaluate_outputs t2 b r \\<and>\n                                executionally_equivalent drinks s1'\n                                 (evaluate_updates t1 b r) drinks2 s2'\n                                 (evaluate_updates t2 b r) t) \\<and>\n                         (\\<forall>(s2', t2)\n                                   |\\<in>|possible_steps drinks2 2 r aa b.\n                             \\<exists>(s1', t1)\n|\\<in>|possible_steps drinks 1 r aa b.\n                                evaluate_outputs t1 b r =\n                                evaluate_outputs t2 b r \\<and>\n                                executionally_equivalent drinks s1'\n                                 (evaluate_updates t1 b r) drinks2 s2'\n                                 (evaluate_updates t2 b r) t)", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b n.\n       \\<lbrakk>\\<And>r. executionally_equivalent drinks 1 r drinks2 2 r t;\n        \\<not> (fst (STR ''vend'', []) = STR ''coin'' \\<and>\n                length (snd (STR ''vend'', [])) = 1);\n        a = (STR ''vend'', []); r $ 2 = Some (Num n)\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>(s1', t1)\n                                   |\\<in>|possible_steps drinks 1 r\n     STR ''vend'' [].\n                             \\<exists>(s2', t2)\n|\\<in>|possible_steps drinks2 2 r STR ''vend'' [].\n                                evaluate_outputs t1 [] r =\n                                evaluate_outputs t2 [] r \\<and>\n                                executionally_equivalent drinks s1'\n                                 (evaluate_updates t1 [] r) drinks2 s2'\n                                 (evaluate_updates t2 [] r) t) \\<and>\n                         (\\<forall>(s2', t2)\n                                   |\\<in>|possible_steps drinks2 2 r\n     STR ''vend'' [].\n                             \\<exists>(s1', t1)\n|\\<in>|possible_steps drinks 1 r STR ''vend'' [].\n                                evaluate_outputs t1 [] r =\n                                evaluate_outputs t2 [] r \\<and>\n                                executionally_equivalent drinks s1'\n                                 (evaluate_updates t1 [] r) drinks2 s2'\n                                 (evaluate_updates t2 [] r) t)", "subgoal for aa b n"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>r. executionally_equivalent drinks 1 r drinks2 2 r t;\n     \\<not> (fst (STR ''vend'', []) = STR ''coin'' \\<and>\n             length (snd (STR ''vend'', [])) = 1);\n     a = (STR ''vend'', []); r $ 2 = Some (Num n)\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>(s1', t1)\n                                |\\<in>|possible_steps drinks 1 r\n  STR ''vend'' [].\n                          \\<exists>(s2', t2)\n                                   |\\<in>|possible_steps drinks2 2 r\n     STR ''vend'' [].\n                             evaluate_outputs t1 [] r =\n                             evaluate_outputs t2 [] r \\<and>\n                             executionally_equivalent drinks s1'\n                              (evaluate_updates t1 [] r) drinks2 s2'\n                              (evaluate_updates t2 [] r) t) \\<and>\n                      (\\<forall>(s2', t2)\n                                |\\<in>|possible_steps drinks2 2 r\n  STR ''vend'' [].\n                          \\<exists>(s1', t1)\n                                   |\\<in>|possible_steps drinks 1 r\n     STR ''vend'' [].\n                             evaluate_outputs t1 [] r =\n                             evaluate_outputs t2 [] r \\<and>\n                             executionally_equivalent drinks s1'\n                              (evaluate_updates t1 [] r) drinks2 s2'\n                              (evaluate_updates t2 [] r) t)", "apply (case_tac \"n < 100\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>r. executionally_equivalent drinks 1 r drinks2 2 r t;\n     \\<not> (fst (STR ''vend'', []) = STR ''coin'' \\<and>\n             length (snd (STR ''vend'', [])) = 1);\n     a = (STR ''vend'', []); r $ 2 = Some (Num n); n < 100\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>(s1', t1)\n                                |\\<in>|possible_steps drinks 1 r\n  STR ''vend'' [].\n                          \\<exists>(s2', t2)\n                                   |\\<in>|possible_steps drinks2 2 r\n     STR ''vend'' [].\n                             evaluate_outputs t1 [] r =\n                             evaluate_outputs t2 [] r \\<and>\n                             executionally_equivalent drinks s1'\n                              (evaluate_updates t1 [] r) drinks2 s2'\n                              (evaluate_updates t2 [] r) t) \\<and>\n                      (\\<forall>(s2', t2)\n                                |\\<in>|possible_steps drinks2 2 r\n  STR ''vend'' [].\n                          \\<exists>(s1', t1)\n                                   |\\<in>|possible_steps drinks 1 r\n     STR ''vend'' [].\n                             evaluate_outputs t1 [] r =\n                             evaluate_outputs t2 [] r \\<and>\n                             executionally_equivalent drinks s1'\n                              (evaluate_updates t1 [] r) drinks2 s2'\n                              (evaluate_updates t2 [] r) t)\n 2. \\<lbrakk>\\<And>r. executionally_equivalent drinks 1 r drinks2 2 r t;\n     \\<not> (fst (STR ''vend'', []) = STR ''coin'' \\<and>\n             length (snd (STR ''vend'', [])) = 1);\n     a = (STR ''vend'', []); r $ 2 = Some (Num n); \\<not> n < 100\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>(s1', t1)\n                                |\\<in>|possible_steps drinks 1 r\n  STR ''vend'' [].\n                          \\<exists>(s2', t2)\n                                   |\\<in>|possible_steps drinks2 2 r\n     STR ''vend'' [].\n                             evaluate_outputs t1 [] r =\n                             evaluate_outputs t2 [] r \\<and>\n                             executionally_equivalent drinks s1'\n                              (evaluate_updates t1 [] r) drinks2 s2'\n                              (evaluate_updates t2 [] r) t) \\<and>\n                      (\\<forall>(s2', t2)\n                                |\\<in>|possible_steps drinks2 2 r\n  STR ''vend'' [].\n                          \\<exists>(s1', t1)\n                                   |\\<in>|possible_steps drinks 1 r\n     STR ''vend'' [].\n                             evaluate_outputs t1 [] r =\n                             evaluate_outputs t2 [] r \\<and>\n                             executionally_equivalent drinks s1'\n                              (evaluate_updates t1 [] r) drinks2 s2'\n                              (evaluate_updates t2 [] r) t)", "apply (simp add: Drinks_Machine.drinks_vend_insufficient drinks2_vend_insufficient2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>r. executionally_equivalent drinks 1 r drinks2 2 r t;\n     \\<not> (fst (STR ''vend'', []) = STR ''coin'' \\<and>\n             length (snd (STR ''vend'', [])) = 1);\n     a = (STR ''vend'', []); r $ 2 = Some (Num n); \\<not> n < 100\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>(s1', t1)\n                                |\\<in>|possible_steps drinks 1 r\n  STR ''vend'' [].\n                          \\<exists>(s2', t2)\n                                   |\\<in>|possible_steps drinks2 2 r\n     STR ''vend'' [].\n                             evaluate_outputs t1 [] r =\n                             evaluate_outputs t2 [] r \\<and>\n                             executionally_equivalent drinks s1'\n                              (evaluate_updates t1 [] r) drinks2 s2'\n                              (evaluate_updates t2 [] r) t) \\<and>\n                      (\\<forall>(s2', t2)\n                                |\\<in>|possible_steps drinks2 2 r\n  STR ''vend'' [].\n                          \\<exists>(s1', t1)\n                                   |\\<in>|possible_steps drinks 1 r\n     STR ''vend'' [].\n                             evaluate_outputs t1 [] r =\n                             evaluate_outputs t2 [] r \\<and>\n                             executionally_equivalent drinks s1'\n                              (evaluate_updates t1 [] r) drinks2 s2'\n                              (evaluate_updates t2 [] r) t)", "apply (simp add: Drinks_Machine.drinks_vend_sufficient drinks2_vend_sufficient)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>r. executionally_equivalent drinks 1 r drinks2 2 r t;\n     a = (STR ''vend'', []); r $ 2 = Some (Num n); \\<not> n < 100\\<rbrakk>\n    \\<Longrightarrow> executionally_equivalent drinks 2\n                       (evaluate_updates vend [] r) drinks2 3\n                       (evaluate_updates vend [] r) t", "apply (induct t)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>r. executionally_equivalent drinks 1 r drinks2 2 r [];\n     a = (STR ''vend'', []); r $ 2 = Some (Num n); \\<not> n < 100\\<rbrakk>\n    \\<Longrightarrow> executionally_equivalent drinks 2\n                       (evaluate_updates vend [] r) drinks2 3\n                       (evaluate_updates vend [] r) []\n 2. \\<And>aa t.\n       \\<lbrakk>\\<lbrakk>\\<And>r.\n                            executionally_equivalent drinks 1 r drinks2 2 r\n                             t;\n                 a = (STR ''vend'', []); r $ 2 = Some (Num n);\n                 \\<not> n < 100\\<rbrakk>\n                \\<Longrightarrow> executionally_equivalent drinks 2\n                                   (evaluate_updates vend [] r) drinks2 3\n                                   (evaluate_updates vend [] r) t;\n        \\<And>r. executionally_equivalent drinks 1 r drinks2 2 r (aa # t);\n        a = (STR ''vend'', []); r $ 2 = Some (Num n);\n        \\<not> n < 100\\<rbrakk>\n       \\<Longrightarrow> executionally_equivalent drinks 2\n                          (evaluate_updates vend [] r) drinks2 3\n                          (evaluate_updates vend [] r) (aa # t)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa t.\n       \\<lbrakk>\\<lbrakk>\\<And>r.\n                            executionally_equivalent drinks 1 r drinks2 2 r\n                             t;\n                 a = (STR ''vend'', []); r $ 2 = Some (Num n);\n                 \\<not> n < 100\\<rbrakk>\n                \\<Longrightarrow> executionally_equivalent drinks 2\n                                   (evaluate_updates vend [] r) drinks2 3\n                                   (evaluate_updates vend [] r) t;\n        \\<And>r. executionally_equivalent drinks 1 r drinks2 2 r (aa # t);\n        a = (STR ''vend'', []); r $ 2 = Some (Num n);\n        \\<not> n < 100\\<rbrakk>\n       \\<Longrightarrow> executionally_equivalent drinks 2\n                          (evaluate_updates vend [] r) drinks2 3\n                          (evaluate_updates vend [] r) (aa # t)", "subgoal for aa t"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>\\<And>r.\n                         executionally_equivalent drinks 1 r drinks2 2 r t;\n              a = (STR ''vend'', []); r $ 2 = Some (Num n);\n              \\<not> n < 100\\<rbrakk>\n             \\<Longrightarrow> executionally_equivalent drinks 2\n                                (evaluate_updates vend [] r) drinks2 3\n                                (evaluate_updates vend [] r) t;\n     \\<And>r. executionally_equivalent drinks 1 r drinks2 2 r (aa # t);\n     a = (STR ''vend'', []); r $ 2 = Some (Num n); \\<not> n < 100\\<rbrakk>\n    \\<Longrightarrow> executionally_equivalent drinks 2\n                       (evaluate_updates vend [] r) drinks2 3\n                       (evaluate_updates vend [] r) (aa # t)", "apply (case_tac aa, clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b.\n       \\<lbrakk>(\\<And>r.\n                    executionally_equivalent drinks 1 r drinks2 2 r\n                     t) \\<Longrightarrow>\n                executionally_equivalent drinks 2\n                 (evaluate_updates vend [] r) drinks2 3\n                 (evaluate_updates vend [] r) t;\n        \\<And>r.\n           executionally_equivalent drinks 1 r drinks2 2 r ((aa, b) # t);\n        a = (STR ''vend'', []); r $ 2 = Some (Num n); \\<not> n < 100;\n        aa = (aa, b)\\<rbrakk>\n       \\<Longrightarrow> executionally_equivalent drinks 2\n                          (evaluate_updates vend [] r) drinks2 3\n                          (evaluate_updates vend [] r) ((aa, b) # t)", "by (simp add: executionally_equivalent_step drinks_end drinks2_end)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  executionally_equivalent drinks 1 r drinks2 2 r (a # t)\n\ngoal (1 subgoal):\n 1. \\<And>r. executionally_equivalent drinks 1 r drinks2 2 r []", "qed auto"], ["", "lemma equiv_1_1: \"r$2 = Some (Num 0) \\<Longrightarrow> executionally_equivalent drinks 1 r drinks2 1 r x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r $ 2 = Some (Num 0) \\<Longrightarrow>\n    executionally_equivalent drinks 1 r drinks2 1 r x", "proof(induct x)"], ["proof (state)\ngoal (2 subgoals):\n 1. r $ 2 = Some (Num 0) \\<Longrightarrow>\n    executionally_equivalent drinks 1 r drinks2 1 r []\n 2. \\<And>a x.\n       \\<lbrakk>r $ 2 = Some (Num 0) \\<Longrightarrow>\n                executionally_equivalent drinks 1 r drinks2 1 r x;\n        r $ 2 = Some (Num 0)\\<rbrakk>\n       \\<Longrightarrow> executionally_equivalent drinks 1 r drinks2 1 r\n                          (a # x)", "case (Cons a t)"], ["proof (state)\nthis:\n  r $ 2 = Some (Num 0) \\<Longrightarrow>\n  executionally_equivalent drinks 1 r drinks2 1 r t\n  r $ 2 = Some (Num 0)\n\ngoal (2 subgoals):\n 1. r $ 2 = Some (Num 0) \\<Longrightarrow>\n    executionally_equivalent drinks 1 r drinks2 1 r []\n 2. \\<And>a x.\n       \\<lbrakk>r $ 2 = Some (Num 0) \\<Longrightarrow>\n                executionally_equivalent drinks 1 r drinks2 1 r x;\n        r $ 2 = Some (Num 0)\\<rbrakk>\n       \\<Longrightarrow> executionally_equivalent drinks 1 r drinks2 1 r\n                          (a # x)", "then"], ["proof (chain)\npicking this:\n  r $ 2 = Some (Num 0) \\<Longrightarrow>\n  executionally_equivalent drinks 1 r drinks2 1 r t\n  r $ 2 = Some (Num 0)", "show ?case"], ["proof (prove)\nusing this:\n  r $ 2 = Some (Num 0) \\<Longrightarrow>\n  executionally_equivalent drinks 1 r drinks2 1 r t\n  r $ 2 = Some (Num 0)\n\ngoal (1 subgoal):\n 1. executionally_equivalent drinks 1 r drinks2 1 r (a # t)", "apply (cases a, clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b.\n       \\<lbrakk>a = (aa, b);\n        executionally_equivalent drinks 1 r drinks2 1 r t;\n        r $ 2 = Some (Num 0)\\<rbrakk>\n       \\<Longrightarrow> executionally_equivalent drinks 1 r drinks2 1 r\n                          ((aa, b) # t)", "subgoal for aa b"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a = (aa, b); executionally_equivalent drinks 1 r drinks2 1 r t;\n     r $ 2 = Some (Num 0)\\<rbrakk>\n    \\<Longrightarrow> executionally_equivalent drinks 1 r drinks2 1 r\n                       ((aa, b) # t)", "apply (simp add: executionally_equivalent_step)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a = (aa, b); executionally_equivalent drinks 1 r drinks2 1 r t;\n     r $ 2 = Some (Num 0)\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>(s1', t1)\n                                |\\<in>|possible_steps drinks 1 r aa b.\n                          \\<exists>(s2', t2)\n                                   |\\<in>|possible_steps drinks2 1 r aa b.\n                             evaluate_outputs t1 b r =\n                             evaluate_outputs t2 b r \\<and>\n                             executionally_equivalent drinks s1'\n                              (evaluate_updates t1 b r) drinks2 s2'\n                              (evaluate_updates t2 b r) t) \\<and>\n                      (\\<forall>(s2', t2)\n                                |\\<in>|possible_steps drinks2 1 r aa b.\n                          \\<exists>(s1', t1)\n                                   |\\<in>|possible_steps drinks 1 r aa b.\n                             evaluate_outputs t1 b r =\n                             evaluate_outputs t2 b r \\<and>\n                             executionally_equivalent drinks s1'\n                              (evaluate_updates t1 b r) drinks2 s2'\n                              (evaluate_updates t2 b r) t)", "apply (case_tac \"aa = STR ''coin'' \\<and> length b = 1\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>a = (aa, b); executionally_equivalent drinks 1 r drinks2 1 r t;\n     r $ 2 = Some (Num 0); aa = STR ''coin'' \\<and> length b = 1\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>(s1', t1)\n                                |\\<in>|possible_steps drinks 1 r aa b.\n                          \\<exists>(s2', t2)\n                                   |\\<in>|possible_steps drinks2 1 r aa b.\n                             evaluate_outputs t1 b r =\n                             evaluate_outputs t2 b r \\<and>\n                             executionally_equivalent drinks s1'\n                              (evaluate_updates t1 b r) drinks2 s2'\n                              (evaluate_updates t2 b r) t) \\<and>\n                      (\\<forall>(s2', t2)\n                                |\\<in>|possible_steps drinks2 1 r aa b.\n                          \\<exists>(s1', t1)\n                                   |\\<in>|possible_steps drinks 1 r aa b.\n                             evaluate_outputs t1 b r =\n                             evaluate_outputs t2 b r \\<and>\n                             executionally_equivalent drinks s1'\n                              (evaluate_updates t1 b r) drinks2 s2'\n                              (evaluate_updates t2 b r) t)\n 2. \\<lbrakk>a = (aa, b); executionally_equivalent drinks 1 r drinks2 1 r t;\n     r $ 2 = Some (Num 0);\n     \\<not> (aa = STR ''coin'' \\<and> length b = 1)\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>(s1', t1)\n                                |\\<in>|possible_steps drinks 1 r aa b.\n                          \\<exists>(s2', t2)\n                                   |\\<in>|possible_steps drinks2 1 r aa b.\n                             evaluate_outputs t1 b r =\n                             evaluate_outputs t2 b r \\<and>\n                             executionally_equivalent drinks s1'\n                              (evaluate_updates t1 b r) drinks2 s2'\n                              (evaluate_updates t2 b r) t) \\<and>\n                      (\\<forall>(s2', t2)\n                                |\\<in>|possible_steps drinks2 1 r aa b.\n                          \\<exists>(s1', t1)\n                                   |\\<in>|possible_steps drinks 1 r aa b.\n                             evaluate_outputs t1 b r =\n                             evaluate_outputs t2 b r \\<and>\n                             executionally_equivalent drinks s1'\n                              (evaluate_updates t1 b r) drinks2 s2'\n                              (evaluate_updates t2 b r) t)", "apply (simp add: possible_steps_1_coin possible_steps_1 equiv_1_2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a = (aa, b); executionally_equivalent drinks 1 r drinks2 1 r t;\n     r $ 2 = Some (Num 0);\n     \\<not> (aa = STR ''coin'' \\<and> length b = 1)\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>(s1', t1)\n                                |\\<in>|possible_steps drinks 1 r aa b.\n                          \\<exists>(s2', t2)\n                                   |\\<in>|possible_steps drinks2 1 r aa b.\n                             evaluate_outputs t1 b r =\n                             evaluate_outputs t2 b r \\<and>\n                             executionally_equivalent drinks s1'\n                              (evaluate_updates t1 b r) drinks2 s2'\n                              (evaluate_updates t2 b r) t) \\<and>\n                      (\\<forall>(s2', t2)\n                                |\\<in>|possible_steps drinks2 1 r aa b.\n                          \\<exists>(s1', t1)\n                                   |\\<in>|possible_steps drinks 1 r aa b.\n                             evaluate_outputs t1 b r =\n                             evaluate_outputs t2 b r \\<and>\n                             executionally_equivalent drinks s1'\n                              (evaluate_updates t1 b r) drinks2 s2'\n                              (evaluate_updates t2 b r) t)", "apply (case_tac \"a = (STR ''vend'', [])\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>a = (aa, b); executionally_equivalent drinks 1 r drinks2 1 r t;\n     r $ 2 = Some (Num 0); \\<not> (aa = STR ''coin'' \\<and> length b = 1);\n     a = (STR ''vend'', [])\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>(s1', t1)\n                                |\\<in>|possible_steps drinks 1 r aa b.\n                          \\<exists>(s2', t2)\n                                   |\\<in>|possible_steps drinks2 1 r aa b.\n                             evaluate_outputs t1 b r =\n                             evaluate_outputs t2 b r \\<and>\n                             executionally_equivalent drinks s1'\n                              (evaluate_updates t1 b r) drinks2 s2'\n                              (evaluate_updates t2 b r) t) \\<and>\n                      (\\<forall>(s2', t2)\n                                |\\<in>|possible_steps drinks2 1 r aa b.\n                          \\<exists>(s1', t1)\n                                   |\\<in>|possible_steps drinks 1 r aa b.\n                             evaluate_outputs t1 b r =\n                             evaluate_outputs t2 b r \\<and>\n                             executionally_equivalent drinks s1'\n                              (evaluate_updates t1 b r) drinks2 s2'\n                              (evaluate_updates t2 b r) t)\n 2. \\<lbrakk>a = (aa, b); executionally_equivalent drinks 1 r drinks2 1 r t;\n     r $ 2 = Some (Num 0); \\<not> (aa = STR ''coin'' \\<and> length b = 1);\n     a \\<noteq> (STR ''vend'', [])\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>(s1', t1)\n                                |\\<in>|possible_steps drinks 1 r aa b.\n                          \\<exists>(s2', t2)\n                                   |\\<in>|possible_steps drinks2 1 r aa b.\n                             evaluate_outputs t1 b r =\n                             evaluate_outputs t2 b r \\<and>\n                             executionally_equivalent drinks s1'\n                              (evaluate_updates t1 b r) drinks2 s2'\n                              (evaluate_updates t2 b r) t) \\<and>\n                      (\\<forall>(s2', t2)\n                                |\\<in>|possible_steps drinks2 1 r aa b.\n                          \\<exists>(s1', t1)\n                                   |\\<in>|possible_steps drinks 1 r aa b.\n                             evaluate_outputs t1 b r =\n                             evaluate_outputs t2 b r \\<and>\n                             executionally_equivalent drinks s1'\n                              (evaluate_updates t1 b r) drinks2 s2'\n                              (evaluate_updates t2 b r) t)", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>executionally_equivalent drinks 1 r drinks2 1 r t;\n     r $ 2 = Some (Num 0); a = (STR ''vend'', []); aa = STR ''vend'';\n     b = []\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>(s1', t1)\n                                |\\<in>|possible_steps drinks 1 r\n  STR ''vend'' [].\n                          \\<exists>(s2', t2)\n                                   |\\<in>|possible_steps drinks2 1 r\n     STR ''vend'' [].\n                             evaluate_outputs t1 [] r =\n                             evaluate_outputs t2 [] r \\<and>\n                             executionally_equivalent drinks s1'\n                              (evaluate_updates t1 [] r) drinks2 s2'\n                              (evaluate_updates t2 [] r) t) \\<and>\n                      (\\<forall>(s2', t2)\n                                |\\<in>|possible_steps drinks2 1 r\n  STR ''vend'' [].\n                          \\<exists>(s1', t1)\n                                   |\\<in>|possible_steps drinks 1 r\n     STR ''vend'' [].\n                             evaluate_outputs t1 [] r =\n                             evaluate_outputs t2 [] r \\<and>\n                             executionally_equivalent drinks s1'\n                              (evaluate_updates t1 [] r) drinks2 s2'\n                              (evaluate_updates t2 [] r) t)\n 2. \\<lbrakk>a = (aa, b); executionally_equivalent drinks 1 r drinks2 1 r t;\n     r $ 2 = Some (Num 0); \\<not> (aa = STR ''coin'' \\<and> length b = 1);\n     a \\<noteq> (STR ''vend'', [])\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>(s1', t1)\n                                |\\<in>|possible_steps drinks 1 r aa b.\n                          \\<exists>(s2', t2)\n                                   |\\<in>|possible_steps drinks2 1 r aa b.\n                             evaluate_outputs t1 b r =\n                             evaluate_outputs t2 b r \\<and>\n                             executionally_equivalent drinks s1'\n                              (evaluate_updates t1 b r) drinks2 s2'\n                              (evaluate_updates t2 b r) t) \\<and>\n                      (\\<forall>(s2', t2)\n                                |\\<in>|possible_steps drinks2 1 r aa b.\n                          \\<exists>(s1', t1)\n                                   |\\<in>|possible_steps drinks 1 r aa b.\n                             evaluate_outputs t1 b r =\n                             evaluate_outputs t2 b r \\<and>\n                             executionally_equivalent drinks s1'\n                              (evaluate_updates t1 b r) drinks2 s2'\n                              (evaluate_updates t2 b r) t)", "apply (simp add: drinks_vend_insufficient drinks2_vend_insufficient)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>executionally_equivalent drinks 1 r drinks2 1 r t;\n     r $ 2 = Some (Num 0); a = (STR ''vend'', []); aa = STR ''vend'';\n     b = []\\<rbrakk>\n    \\<Longrightarrow> evaluate_outputs vend_fail [] r =\n                      evaluate_outputs vend_nothing [] r \\<and>\n                      executionally_equivalent drinks 1\n                       (evaluate_updates vend_fail [] r) drinks2 1\n                       (evaluate_updates vend_nothing [] r) t\n 2. \\<lbrakk>a = (aa, b); executionally_equivalent drinks 1 r drinks2 1 r t;\n     r $ 2 = Some (Num 0); \\<not> (aa = STR ''coin'' \\<and> length b = 1);\n     a \\<noteq> (STR ''vend'', [])\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>(s1', t1)\n                                |\\<in>|possible_steps drinks 1 r aa b.\n                          \\<exists>(s2', t2)\n                                   |\\<in>|possible_steps drinks2 1 r aa b.\n                             evaluate_outputs t1 b r =\n                             evaluate_outputs t2 b r \\<and>\n                             executionally_equivalent drinks s1'\n                              (evaluate_updates t1 b r) drinks2 s2'\n                              (evaluate_updates t2 b r) t) \\<and>\n                      (\\<forall>(s2', t2)\n                                |\\<in>|possible_steps drinks2 1 r aa b.\n                          \\<exists>(s1', t1)\n                                   |\\<in>|possible_steps drinks 1 r aa b.\n                             evaluate_outputs t1 b r =\n                             evaluate_outputs t2 b r \\<and>\n                             executionally_equivalent drinks s1'\n                              (evaluate_updates t1 b r) drinks2 s2'\n                              (evaluate_updates t2 b r) t)", "apply (simp add: vend_fail_def vend_nothing_def apply_updates_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>executionally_equivalent drinks 1 r drinks2 1 r t;\n     r $ 2 = Some (Num 0); a = (STR ''vend'', []); aa = STR ''vend'';\n     b = []\\<rbrakk>\n    \\<Longrightarrow> executionally_equivalent drinks 1\n                       (r(2 $:= Some (Num 0))) drinks2 1\n                       (r(2 $:= Some (Num 0))) t\n 2. \\<lbrakk>a = (aa, b); executionally_equivalent drinks 1 r drinks2 1 r t;\n     r $ 2 = Some (Num 0); \\<not> (aa = STR ''coin'' \\<and> length b = 1);\n     a \\<noteq> (STR ''vend'', [])\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>(s1', t1)\n                                |\\<in>|possible_steps drinks 1 r aa b.\n                          \\<exists>(s2', t2)\n                                   |\\<in>|possible_steps drinks2 1 r aa b.\n                             evaluate_outputs t1 b r =\n                             evaluate_outputs t2 b r \\<and>\n                             executionally_equivalent drinks s1'\n                              (evaluate_updates t1 b r) drinks2 s2'\n                              (evaluate_updates t2 b r) t) \\<and>\n                      (\\<forall>(s2', t2)\n                                |\\<in>|possible_steps drinks2 1 r aa b.\n                          \\<exists>(s1', t1)\n                                   |\\<in>|possible_steps drinks 1 r aa b.\n                             evaluate_outputs t1 b r =\n                             evaluate_outputs t2 b r \\<and>\n                             executionally_equivalent drinks s1'\n                              (evaluate_updates t1 b r) drinks2 s2'\n                              (evaluate_updates t2 b r) t)", "apply (metis finfun_upd_triv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a = (aa, b); executionally_equivalent drinks 1 r drinks2 1 r t;\n     r $ 2 = Some (Num 0); \\<not> (aa = STR ''coin'' \\<and> length b = 1);\n     a \\<noteq> (STR ''vend'', [])\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>(s1', t1)\n                                |\\<in>|possible_steps drinks 1 r aa b.\n                          \\<exists>(s2', t2)\n                                   |\\<in>|possible_steps drinks2 1 r aa b.\n                             evaluate_outputs t1 b r =\n                             evaluate_outputs t2 b r \\<and>\n                             executionally_equivalent drinks s1'\n                              (evaluate_updates t1 b r) drinks2 s2'\n                              (evaluate_updates t2 b r) t) \\<and>\n                      (\\<forall>(s2', t2)\n                                |\\<in>|possible_steps drinks2 1 r aa b.\n                          \\<exists>(s1', t1)\n                                   |\\<in>|possible_steps drinks 1 r aa b.\n                             evaluate_outputs t1 b r =\n                             evaluate_outputs t2 b r \\<and>\n                             executionally_equivalent drinks s1'\n                              (evaluate_updates t1 b r) drinks2 s2'\n                              (evaluate_updates t2 b r) t)", "by (simp add: drinks2_1_invalid drinks_no_possible_steps_1)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  executionally_equivalent drinks 1 r drinks2 1 r (a # t)\n\ngoal (1 subgoal):\n 1. r $ 2 = Some (Num 0) \\<Longrightarrow>\n    executionally_equivalent drinks 1 r drinks2 1 r []", "qed auto"], ["", "(* Corresponds to Example 3 in Foster et. al. *)"], ["", "lemma executional_equivalence: \"executionally_equivalent drinks 0 <> drinks2 0 <> t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. executionally_equivalent drinks 0 <> drinks2 0 <> t", "proof(induct t)"], ["proof (state)\ngoal (2 subgoals):\n 1. executionally_equivalent drinks 0 <> drinks2 0 <> []\n 2. \\<And>a t.\n       executionally_equivalent drinks 0 <> drinks2 0 <> t \\<Longrightarrow>\n       executionally_equivalent drinks 0 <> drinks2 0 <> (a # t)", "case (Cons a t)"], ["proof (state)\nthis:\n  executionally_equivalent drinks 0 <> drinks2 0 <> t\n\ngoal (2 subgoals):\n 1. executionally_equivalent drinks 0 <> drinks2 0 <> []\n 2. \\<And>a t.\n       executionally_equivalent drinks 0 <> drinks2 0 <> t \\<Longrightarrow>\n       executionally_equivalent drinks 0 <> drinks2 0 <> (a # t)", "then"], ["proof (chain)\npicking this:\n  executionally_equivalent drinks 0 <> drinks2 0 <> t", "show ?case"], ["proof (prove)\nusing this:\n  executionally_equivalent drinks 0 <> drinks2 0 <> t\n\ngoal (1 subgoal):\n 1. executionally_equivalent drinks 0 <> drinks2 0 <> (a # t)", "apply (cases a, clarify)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b.\n       \\<lbrakk>executionally_equivalent drinks 0 <> drinks2 0 <> t;\n        executionally_equivalent drinks 0 <> drinks2 0 <> t;\n        a = (aa, b)\\<rbrakk>\n       \\<Longrightarrow> executionally_equivalent drinks 0 <> drinks2 0 <>\n                          ((aa, b) # t)", "subgoal for aa b"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>executionally_equivalent drinks 0 <> drinks2 0 <> t;\n     executionally_equivalent drinks 0 <> drinks2 0 <> t;\n     a = (aa, b)\\<rbrakk>\n    \\<Longrightarrow> executionally_equivalent drinks 0 <> drinks2 0 <>\n                       ((aa, b) # t)", "apply (simp add: executionally_equivalent_step)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>executionally_equivalent drinks 0 <> drinks2 0 <> t;\n     a = (aa, b)\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>(s1', t1)\n                                |\\<in>|possible_steps drinks 0 <> aa b.\n                          \\<exists>(s2', t2)\n                                   |\\<in>|possible_steps drinks2 0 <> aa b.\n                             evaluate_outputs t1 b <> =\n                             evaluate_outputs t2 b <> \\<and>\n                             executionally_equivalent drinks s1'\n                              (evaluate_updates t1 b <>) drinks2 s2'\n                              (evaluate_updates t2 b <>) t) \\<and>\n                      (\\<forall>(s2', t2)\n                                |\\<in>|possible_steps drinks2 0 <> aa b.\n                          \\<exists>(s1', t1)\n                                   |\\<in>|possible_steps drinks 0 <> aa b.\n                             evaluate_outputs t1 b <> =\n                             evaluate_outputs t2 b <> \\<and>\n                             executionally_equivalent drinks s1'\n                              (evaluate_updates t1 b <>) drinks2 s2'\n                              (evaluate_updates t2 b <>) t)", "apply (case_tac \"aa = STR ''select'' \\<and> length b = 1\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>executionally_equivalent drinks 0 <> drinks2 0 <> t;\n     a = (aa, b); aa = STR ''select'' \\<and> length b = 1\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>(s1', t1)\n                                |\\<in>|possible_steps drinks 0 <> aa b.\n                          \\<exists>(s2', t2)\n                                   |\\<in>|possible_steps drinks2 0 <> aa b.\n                             evaluate_outputs t1 b <> =\n                             evaluate_outputs t2 b <> \\<and>\n                             executionally_equivalent drinks s1'\n                              (evaluate_updates t1 b <>) drinks2 s2'\n                              (evaluate_updates t2 b <>) t) \\<and>\n                      (\\<forall>(s2', t2)\n                                |\\<in>|possible_steps drinks2 0 <> aa b.\n                          \\<exists>(s1', t1)\n                                   |\\<in>|possible_steps drinks 0 <> aa b.\n                             evaluate_outputs t1 b <> =\n                             evaluate_outputs t2 b <> \\<and>\n                             executionally_equivalent drinks s1'\n                              (evaluate_updates t1 b <>) drinks2 s2'\n                              (evaluate_updates t2 b <>) t)\n 2. \\<lbrakk>executionally_equivalent drinks 0 <> drinks2 0 <> t;\n     a = (aa, b); \\<not> (aa = STR ''select'' \\<and> length b = 1)\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>(s1', t1)\n                                |\\<in>|possible_steps drinks 0 <> aa b.\n                          \\<exists>(s2', t2)\n                                   |\\<in>|possible_steps drinks2 0 <> aa b.\n                             evaluate_outputs t1 b <> =\n                             evaluate_outputs t2 b <> \\<and>\n                             executionally_equivalent drinks s1'\n                              (evaluate_updates t1 b <>) drinks2 s2'\n                              (evaluate_updates t2 b <>) t) \\<and>\n                      (\\<forall>(s2', t2)\n                                |\\<in>|possible_steps drinks2 0 <> aa b.\n                          \\<exists>(s1', t1)\n                                   |\\<in>|possible_steps drinks 0 <> aa b.\n                             evaluate_outputs t1 b <> =\n                             evaluate_outputs t2 b <> \\<and>\n                             executionally_equivalent drinks s1'\n                              (evaluate_updates t1 b <>) drinks2 s2'\n                              (evaluate_updates t2 b <>) t)", "apply (simp add: Drinks_Machine.possible_steps_0 possible_steps_0)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>executionally_equivalent drinks 0 <> drinks2 0 <> t;\n     a = (STR ''select'', b);\n     aa = STR ''select'' \\<and> length b = 1\\<rbrakk>\n    \\<Longrightarrow> executionally_equivalent drinks 1\n                       (evaluate_updates select b <>) drinks2 1\n                       (evaluate_updates select b <>) t\n 2. \\<lbrakk>executionally_equivalent drinks 0 <> drinks2 0 <> t;\n     a = (aa, b); \\<not> (aa = STR ''select'' \\<and> length b = 1)\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>(s1', t1)\n                                |\\<in>|possible_steps drinks 0 <> aa b.\n                          \\<exists>(s2', t2)\n                                   |\\<in>|possible_steps drinks2 0 <> aa b.\n                             evaluate_outputs t1 b <> =\n                             evaluate_outputs t2 b <> \\<and>\n                             executionally_equivalent drinks s1'\n                              (evaluate_updates t1 b <>) drinks2 s2'\n                              (evaluate_updates t2 b <>) t) \\<and>\n                      (\\<forall>(s2', t2)\n                                |\\<in>|possible_steps drinks2 0 <> aa b.\n                          \\<exists>(s1', t1)\n                                   |\\<in>|possible_steps drinks 0 <> aa b.\n                             evaluate_outputs t1 b <> =\n                             evaluate_outputs t2 b <> \\<and>\n                             executionally_equivalent drinks s1'\n                              (evaluate_updates t1 b <>) drinks2 s2'\n                              (evaluate_updates t2 b <>) t)", "apply (simp add: apply_updates_def select_def equiv_1_1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>executionally_equivalent drinks 0 <> drinks2 0 <> t;\n     a = (aa, b); \\<not> (aa = STR ''select'' \\<and> length b = 1)\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>(s1', t1)\n                                |\\<in>|possible_steps drinks 0 <> aa b.\n                          \\<exists>(s2', t2)\n                                   |\\<in>|possible_steps drinks2 0 <> aa b.\n                             evaluate_outputs t1 b <> =\n                             evaluate_outputs t2 b <> \\<and>\n                             executionally_equivalent drinks s1'\n                              (evaluate_updates t1 b <>) drinks2 s2'\n                              (evaluate_updates t2 b <>) t) \\<and>\n                      (\\<forall>(s2', t2)\n                                |\\<in>|possible_steps drinks2 0 <> aa b.\n                          \\<exists>(s1', t1)\n                                   |\\<in>|possible_steps drinks 0 <> aa b.\n                             evaluate_outputs t1 b <> =\n                             evaluate_outputs t2 b <> \\<and>\n                             executionally_equivalent drinks s1'\n                              (evaluate_updates t1 b <>) drinks2 s2'\n                              (evaluate_updates t2 b <>) t)", "by (simp add: drinks2_0_invalid possible_steps_0_invalid)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  executionally_equivalent drinks 0 <> drinks2 0 <> (a # t)\n\ngoal (1 subgoal):\n 1. executionally_equivalent drinks 0 <> drinks2 0 <> []", "qed auto"], ["", "lemma observational_equivalence: \"trace_equivalent drinks drinks2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace_equivalent drinks drinks2", "by (simp add: executional_equivalence executionally_equivalent_trace_equivalent)"], ["", "end"]]}