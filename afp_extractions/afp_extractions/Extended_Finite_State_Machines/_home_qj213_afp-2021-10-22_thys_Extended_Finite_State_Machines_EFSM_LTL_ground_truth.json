{"file_name": "/home/qj213/afp-2021-10-22/thys/Extended_Finite_State_Machines/EFSM_LTL.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Extended_Finite_State_Machines", "problem_names": ["lemma ltl_step_singleton:\n\"\\<exists>t. possible_steps e n r (fst v) (snd v) = {|(aa, t)|} \\<and> evaluate_outputs t (snd v) r  = b \\<and> evaluate_updates t (snd v) r = c\\<Longrightarrow>\nltl_step e (Some n) r v = (Some aa, b, c)\"", "lemma ltl_step_none: \"possible_steps e s r a b = {||} \\<Longrightarrow> ltl_step e (Some s) r (a, b) = (None, [], r)\"", "lemma ltl_step_none_2: \"possible_steps e s r (fst ie) (snd ie) = {||} \\<Longrightarrow> ltl_step e (Some s) r ie = (None, [], r)\"", "lemma ltl_step_alt: \"ltl_step e (Some s) r t = (\n  let possibilities = possible_steps e s r (fst t) (snd t) in\n  if possibilities = {||} then\n    (None, [], r)\n  else\n  let (s', t') = Eps (\\<lambda>x. x |\\<in>| possibilities) in\n  (Some s', (apply_outputs (Outputs t') (join_ir (snd t) r)), (apply_updates (Updates t') (join_ir (snd t) r) r))\n)\"", "lemma ltl_step_some:\n  assumes \"possible_steps e s r l i = {|(s', t)|}\"\n      and \"evaluate_outputs t i r = p\"\n      and \"evaluate_updates t i r = r'\"\n    shows \"ltl_step e (Some s) r (l, i) = (Some s', p, r')\"", "lemma ltl_step_cases:\n  assumes invalid: \"P (None, [], r)\"\n      and valid: \"\\<forall>(s', t) |\\<in>| (possible_steps e s r l i). P (Some s', (evaluate_outputs t i r), (evaluate_updates t i r))\"\n    shows \"P (ltl_step e (Some s) r (l, i))\"", "lemma state_eq_holds: \"state_eq s = holds (\\<lambda>x. statename x = s)\"", "lemma state_eq_None_not_Some: \"state_eq None s \\<Longrightarrow> \\<not> state_eq (Some n) s\"", "lemma watch_label: \"label_eq l (watch e t) = (fst (shd t) = String.implode l)\"", "lemma join_iro_R [simp]: \"join_iro i r p (Rg n) = r $ n\"", "lemma alw_ev: \"alw f = not (ev (\\<lambda>s. \\<not>f s))\"", "lemma alw_state_eq_smap:\n  \"alw (state_eq s) ss = alw (\\<lambda>ss. shd ss = s) (smap statename ss)\"", "lemma shd_state_is_none: \"(state_eq None) (make_full_observation e None r p t)\"", "lemma unfold_observe_none: \"make_full_observation e None d p t = (\\<lparr>statename = None, datastate = d, action=(shd t), output = p\\<rparr>##(make_full_observation e None d [] (stl t)))\"", "lemma once_none_always_none_aux:\n  assumes \"\\<exists> p r i. j = (make_full_observation e None r p) i\"\n  shows \"alw (state_eq None) j\"", "lemma once_none_always_none: \"alw (state_eq None) (make_full_observation e None r p t)\"", "lemma once_none_nxt_always_none: \"alw (nxt (state_eq None)) (make_full_observation e None r p t)\"", "lemma snth_sconst: \"(\\<forall>i. s !! i = h) = (s = sconst h)\"", "lemma alw_sconst: \"(alw (\\<lambda>xs. shd xs = h) t) = (t = sconst h)\"", "lemma smap_statename_None: \"smap statename (make_full_observation e None r p i) = sconst None\"", "lemma alw_not_some: \"alw (\\<lambda>xs. statename (shd xs) \\<noteq> Some s) (make_full_observation e None r p t)\"", "lemma state_none: \"((state_eq None) impl nxt (state_eq None)) (make_full_observation e s r p t)\"", "lemma state_none_2:\n  \"(state_eq None) (make_full_observation e s r p t) \\<Longrightarrow>\n   (state_eq None) (make_full_observation e s r p (stl t))\"", "lemma no_output_none_aux:\n  assumes \"\\<exists> p r i. j = (make_full_observation e None r []) i\"\n  shows \"alw (output_eq []) j\"", "lemma no_output_none: \"nxt (alw (output_eq [])) (make_full_observation e None r p t)\"", "lemma nxt_alw: \"nxt (alw P) s \\<Longrightarrow> alw (nxt P) s\"", "lemma no_output_none_nxt: \"alw (nxt (output_eq [])) (make_full_observation e None r p t)\"", "lemma no_output_none_if_empty: \"alw (output_eq []) (make_full_observation e None r [] t)\"", "lemma no_updates_none_aux:\n  assumes \"\\<exists> p i. j = (make_full_observation e None r p) i\"\n  shows \"alw (\\<lambda>x. datastate (shd x) = r) j\"", "lemma no_updates_none: \"alw (\\<lambda>x. datastate (shd x) = r) (make_full_observation e None r p t)\"", "lemma action_components: \"(label_eq l aand input_eq i) s = (action (shd s) = (String.implode l, i))\""], "translations": [["", "lemma ltl_step_singleton:\n\"\\<exists>t. possible_steps e n r (fst v) (snd v) = {|(aa, t)|} \\<and> evaluate_outputs t (snd v) r  = b \\<and> evaluate_updates t (snd v) r = c\\<Longrightarrow>\nltl_step e (Some n) r v = (Some aa, b, c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>t.\n       possible_steps e n r (fst v) (snd v) = {|(aa, t)|} \\<and>\n       evaluate_outputs t (snd v) r = b \\<and>\n       evaluate_updates t (snd v) r = c \\<Longrightarrow>\n    ltl_step e (Some n) r v = (Some aa, b, c)", "apply (cases v)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a ba.\n       \\<lbrakk>\\<exists>t.\n                   possible_steps e n r (fst v) (snd v) = {|(aa, t)|} \\<and>\n                   evaluate_outputs t (snd v) r = b \\<and>\n                   evaluate_updates t (snd v) r = c;\n        v = (a, ba)\\<rbrakk>\n       \\<Longrightarrow> ltl_step e (Some n) r v = (Some aa, b, c)", "by auto"], ["", "lemma ltl_step_none: \"possible_steps e s r a b = {||} \\<Longrightarrow> ltl_step e (Some s) r (a, b) = (None, [], r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. possible_steps e s r a b = {||} \\<Longrightarrow>\n    ltl_step e (Some s) r (a, b) = (None, [], r)", "by simp"], ["", "lemma ltl_step_none_2: \"possible_steps e s r (fst ie) (snd ie) = {||} \\<Longrightarrow> ltl_step e (Some s) r ie = (None, [], r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. possible_steps e s r (fst ie) (snd ie) = {||} \\<Longrightarrow>\n    ltl_step e (Some s) r ie = (None, [], r)", "by (metis ltl_step_none prod.exhaust_sel)"], ["", "lemma ltl_step_alt: \"ltl_step e (Some s) r t = (\n  let possibilities = possible_steps e s r (fst t) (snd t) in\n  if possibilities = {||} then\n    (None, [], r)\n  else\n  let (s', t') = Eps (\\<lambda>x. x |\\<in>| possibilities) in\n  (Some s', (apply_outputs (Outputs t') (join_ir (snd t) r)), (apply_updates (Updates t') (join_ir (snd t) r) r))\n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ltl_step e (Some s) r t =\n    (let possibilities = possible_steps e s r (fst t) (snd t)\n     in if possibilities = {||} then (None, [], r)\n        else let (s', t') = SOME x. x |\\<in>| possibilities\n             in (Some s', evaluate_outputs t' (snd t) r,\n                 evaluate_updates t' (snd t) r))", "by (case_tac t, simp add: Let_def)"], ["", "lemma ltl_step_some:\n  assumes \"possible_steps e s r l i = {|(s', t)|}\"\n      and \"evaluate_outputs t i r = p\"\n      and \"evaluate_updates t i r = r'\"\n    shows \"ltl_step e (Some s) r (l, i) = (Some s', p, r')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ltl_step e (Some s) r (l, i) = (Some s', p, r')", "by (simp add: assms)"], ["", "lemma ltl_step_cases:\n  assumes invalid: \"P (None, [], r)\"\n      and valid: \"\\<forall>(s', t) |\\<in>| (possible_steps e s r l i). P (Some s', (evaluate_outputs t i r), (evaluate_updates t i r))\"\n    shows \"P (ltl_step e (Some s) r (l, i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P (ltl_step e (Some s) r (l, i))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. P (let possibilities = possible_steps e s r l i\n       in if possibilities = {||} then (None, [], r)\n          else let (s', t) = SOME x. x |\\<in>| possibilities\n               in (Some s', evaluate_outputs t i r, evaluate_updates t i r))", "apply (case_tac \"possible_steps e s r l i\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. possible_steps e s r l i = {||} \\<Longrightarrow>\n    P (let possibilities = possible_steps e s r l i\n       in if possibilities = {||} then (None, [], r)\n          else let (s', t) = SOME x. x |\\<in>| possibilities\n               in (Some s', evaluate_outputs t i r, evaluate_updates t i r))\n 2. \\<And>x S'.\n       possible_steps e s r l i = finsert x S' \\<Longrightarrow>\n       P (let possibilities = possible_steps e s r l i\n          in if possibilities = {||} then (None, [], r)\n             else let (s', t) = SOME x. x |\\<in>| possibilities\n                  in (Some s', evaluate_outputs t i r,\n                      evaluate_updates t i r))", "apply (simp add: invalid)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x S'.\n       possible_steps e s r l i = finsert x S' \\<Longrightarrow>\n       P (let possibilities = possible_steps e s r l i\n          in if possibilities = {||} then (None, [], r)\n             else let (s', t) = SOME x. x |\\<in>| possibilities\n                  in (Some s', evaluate_outputs t i r,\n                      evaluate_updates t i r))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x S'.\n       possible_steps e s r l i = finsert x S' \\<Longrightarrow>\n       P (case SOME xa. xa = x \\<or> xa |\\<in>| S' of\n          (s', t) \\<Rightarrow>\n            (Some s', evaluate_outputs t i r, evaluate_updates t i r))", "subgoal for x S'"], ["proof (prove)\ngoal (1 subgoal):\n 1. possible_steps e s r l i = finsert x S' \\<Longrightarrow>\n    P (case SOME xa. xa = x \\<or> xa |\\<in>| S' of\n       (s', t) \\<Rightarrow>\n         (Some s', evaluate_outputs t i r, evaluate_updates t i r))", "apply (case_tac \"SOME xa. xa = x \\<or> xa |\\<in>| S'\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>possible_steps e s r l i = finsert x S';\n        (SOME xa. xa = x \\<or> xa |\\<in>| S') = (a, b)\\<rbrakk>\n       \\<Longrightarrow> P (case SOME xa. xa = x \\<or> xa |\\<in>| S' of\n                            (s', t) \\<Rightarrow>\n                              (Some s', evaluate_outputs t i r,\n                               evaluate_updates t i r))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>possible_steps e s r l i = finsert x S';\n        (SOME xa. xa = x \\<or> xa |\\<in>| S') = (a, b)\\<rbrakk>\n       \\<Longrightarrow> P (Some a, evaluate_outputs b i r,\n                            evaluate_updates b i r)", "apply (insert assms(2))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>possible_steps e s r l i = finsert x S';\n        (SOME xa. xa = x \\<or> xa |\\<in>| S') = (a, b);\n        \\<forall>(s', t)|\\<in>|possible_steps e s r l i.\n           P (Some s', evaluate_outputs t i r,\n              evaluate_updates t i r)\\<rbrakk>\n       \\<Longrightarrow> P (Some a, evaluate_outputs b i r,\n                            evaluate_updates b i r)", "apply (simp add: fBall_def Ball_def fmember_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>possible_steps e s r l i = finsert x S';\n        (SOME xa. xa = x \\<or> xa \\<in> fset S') = (a, b);\n        \\<forall>a b.\n           ((a, b) = x \\<longrightarrow>\n            (case x of\n             (s', t) \\<Rightarrow>\n               P (Some s', evaluate_outputs t i r,\n                  evaluate_updates t i r))) \\<and>\n           ((a, b) \\<in> fset S' \\<longrightarrow>\n            P (Some a, evaluate_outputs b i r,\n               evaluate_updates b i r))\\<rbrakk>\n       \\<Longrightarrow> P (Some a, evaluate_outputs b i r,\n                            evaluate_updates b i r)", "by (metis (mono_tags, lifting) fst_conv prod.case_eq_if snd_conv someI_ex)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text\\<open>The \\texttt{make\\_full\\_observation} function behaves similarly to \\texttt{observe\\_execution}\nfrom the \\texttt{EFSM} theory. The main difference in behaviour is what is recorded. While the\nobserve execution function simply observes an execution of the EFSM to produce the corresponding\noutput for each action, the intention here is to record every detail of execution, including the\nvalues of internal variables.\n\nThinking of each action as a step forward in time, there are five components which characterise\na given point in the execution of an EFSM. At each point, the model has a current control state and\ndata state. Each action has a label and some input parameters, and its execution may produce\nsome observableoutput. It is therefore sufficient to provide a stream of 5-tuples containing the\ncurrent control state, data state, the label and inputs of the action, and computed output. The\nmake full observation function can then be defined as in Figure 9.1, with an additional\nfunction watch defined on top of this which starts the make full observation off in the\ninitial control state with the empty data state.\n\nCareful inspection of the definition reveals another way that \\texttt{make\\_full\\_observation}\ndiffers from \\texttt{observe\\_execution}. Rather than taking a cfstate, it takes a cfstate option.\nThe reason for this is that we need to make our EFSM models complete. That is, we need them to be\nable to respond to every action from every state like a DFA. If a model does not recognise a given\naction in a given state, we cannot simply stop processing because we are working with necessarily\ninfinite traces. Since these traces are generated by observing action sequences, the make full\nobservation function must keep processing whether there is a viable transition or not.\n\nTo support this, the make full observation adds an implicit ``sink state'' to every EFSM it\nprocesses by lifting control flow state indices from \\texttt{nat} to \\texttt{nat option} such that\nstate $n$ is seen as state \\texttt{Some} $n$. The control flow state \\texttt{None} represents a sink\nstate. If a model is unable to recognise a particular action from its current state, it moves into\nthe \\texttt{None} state. From here, the behaviour is constant for the rest of the time --- the\ncontrol flow state remains None; the data state does not change, and no output is produced.\\<close>"], ["", "text_raw\\<open>\\snip{makeFullObservation}{1}{2}{%\\<close>"], ["", "primcorec make_full_observation :: \"transition_matrix \\<Rightarrow> cfstate option \\<Rightarrow> registers \\<Rightarrow> outputs \\<Rightarrow> action stream \\<Rightarrow> whitebox_trace\" where\n  \"make_full_observation e s d p i = (\n    let (s', o', d') = ltl_step e s d (shd i) in\n    \\<lparr>statename = s, datastate = d, action=(shd i), output = p\\<rparr>##(make_full_observation e s' d' o' (stl i))\n  )\""], ["", "text_raw\\<open>}%endsnip\\<close>"], ["", "text_raw\\<open>\\snip{watch}{1}{2}{%\\<close>"], ["", "abbreviation watch :: \"transition_matrix \\<Rightarrow> action stream \\<Rightarrow> whitebox_trace\" where\n  \"watch e i \\<equiv> (make_full_observation e (Some 0) <> [] i)\""], ["", "text_raw\\<open>}%endsnip\\<close>"], ["", "subsection\\<open>Expressing Properties\\<close>"], ["", "text\\<open>In order to simplify the expression and understanding of properties, this theory defines a\nnumber of named functions which can be used to express certain properties of EFSMs.\\<close>"], ["", "subsubsection\\<open>State Equality\\<close>"], ["", "text\\<open>The \\textsc{state\\_eq} takes a cfstate option representing a control flow state index and\nreturns true if this is the control flow state at the head of the full observation.\\<close>"], ["", "abbreviation state_eq :: \"cfstate option \\<Rightarrow> whitebox_trace \\<Rightarrow> bool\" where\n  \"state_eq v s \\<equiv> statename (shd s) = v\""], ["", "lemma state_eq_holds: \"state_eq s = holds (\\<lambda>x. statename x = s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. state_eq s = holds (\\<lambda>x. statename x = s)", "apply (rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>sa. state_eq s sa = holds (\\<lambda>x. statename x = s) sa", "by (simp add: holds_def)"], ["", "lemma state_eq_None_not_Some: \"state_eq None s \\<Longrightarrow> \\<not> state_eq (Some n) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. state_eq None s \\<Longrightarrow> statename (shd s) \\<noteq> Some n", "by simp"], ["", "subsubsection\\<open>Label Equality\\<close>"], ["", "text\\<open>The \\textsc{label\\_eq} function takes a string and returns true if this is equal to the label\nat the head of the full observation.\\<close>"], ["", "abbreviation \"label_eq v s \\<equiv> fst (action (shd s)) = (String.implode v)\""], ["", "lemma watch_label: \"label_eq l (watch e t) = (fst (shd t) = String.implode l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. label_eq l (watch e t) = (fst (shd t) = String.implode l)", "by (simp add: )"], ["", "subsubsection\\<open>Input Equality\\<close>"], ["", "text\\<open>The \\textsc{input\\_eq} function takes a value list and returns true if this is equal to the\ninput at the head of the full observation.\\<close>"], ["", "abbreviation \"input_eq v s \\<equiv> inputs (shd s) = v\""], ["", "subsubsection\\<open>Action Equality\\<close>"], ["", "text\\<open>The \\textsc{action\\_eq} function takes a (label, value list) pair and returns true if this is\nequal to the action at the head of the full observation. This effectively combines\n\\texttt{label\\_eq} and \\texttt{input\\_eq} into one function.\\<close>"], ["", "abbreviation \"action_eq e \\<equiv> label_eq (fst e) aand input_eq (snd e)\""], ["", "subsubsection\\<open>Output Equality\\<close>"], ["", "text\\<open>The \\textsc{output\\_eq} function takes a takes a value option list and returns true if this is\nequal to the output at the head of the full observation.\\<close>"], ["", "abbreviation \"output_eq v s \\<equiv> output (shd s) = v\""], ["", "text_raw\\<open>\\snip{ltlVName}{1}{2}{%\\<close>"], ["", "datatype ltl_vname = Ip nat | Op nat | Rg nat"], ["", "text_raw\\<open>}%endsnip\\<close>"], ["", "subsubsection\\<open>Checking Arbitrary Expressions\\<close>"], ["", "text\\<open>The \\textsc{check\\_exp} function takes a guard expression and returns true if the guard\nexpression evaluates to true in the given state.\\<close>"], ["", "type_synonym ltl_gexp = \"ltl_vname gexp\""], ["", "definition join_iro :: \"value list \\<Rightarrow> registers \\<Rightarrow> outputs \\<Rightarrow> ltl_vname datastate\" where\n  \"join_iro i r p = (\\<lambda>x. case x of\n    Rg n \\<Rightarrow> r $ n |\n    Ip n \\<Rightarrow> Some (i ! n) |\n    Op n \\<Rightarrow> p ! n\n  )\""], ["", "lemma join_iro_R [simp]: \"join_iro i r p (Rg n) = r $ n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. join_iro i r p (Rg n) = r $ n", "by (simp add: join_iro_def)"], ["", "abbreviation \"check_exp g s \\<equiv> (gval g (join_iro (snd (action (shd s))) (datastate (shd s)) (output (shd s))) = trilean.true)\""], ["", "lemma alw_ev: \"alw f = not (ev (\\<lambda>s. \\<not>f s))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. alw f = (\\<lambda>xs. \\<not> ev (\\<lambda>s. \\<not> f s) xs)", "by simp"], ["", "lemma alw_state_eq_smap:\n  \"alw (state_eq s) ss = alw (\\<lambda>ss. shd ss = s) (smap statename ss)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. alw (state_eq s) ss = alw (\\<lambda>ss. shd ss = s) (smap statename ss)", "apply standard"], ["proof (prove)\ngoal (2 subgoals):\n 1. alw (state_eq s) ss \\<Longrightarrow>\n    alw (\\<lambda>ss. shd ss = s) (smap statename ss)\n 2. alw (\\<lambda>ss. shd ss = s) (smap statename ss) \\<Longrightarrow>\n    alw (state_eq s) ss", "apply (simp add: alw_iff_sdrop )"], ["proof (prove)\ngoal (1 subgoal):\n 1. alw (\\<lambda>ss. shd ss = s) (smap statename ss) \\<Longrightarrow>\n    alw (state_eq s) ss", "by (simp add: alw_mono alw_smap )"], ["", "subsection\\<open>Sink State\\<close>"], ["", "text\\<open>Once the sink state is entered, it cannot be left and there are no outputs or updates\nhenceforth.\\<close>"], ["", "lemma shd_state_is_none: \"(state_eq None) (make_full_observation e None r p t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. state_eq None (make_full_observation e None r p t)", "by (simp add: )"], ["", "lemma unfold_observe_none: \"make_full_observation e None d p t = (\\<lparr>statename = None, datastate = d, action=(shd t), output = p\\<rparr>##(make_full_observation e None d [] (stl t)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. make_full_observation e None d p t =\n    \\<lparr>statename = None, datastate = d, action = shd t,\n       output = p\\<rparr> ##\n    make_full_observation e None d [] (stl t)", "by (simp add: stream.expand)"], ["", "lemma once_none_always_none_aux:\n  assumes \"\\<exists> p r i. j = (make_full_observation e None r p) i\"\n  shows \"alw (state_eq None) j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. alw (state_eq None) j", "using assms"], ["proof (prove)\nusing this:\n  \\<exists>p r i. j = make_full_observation e None r p i\n\ngoal (1 subgoal):\n 1. alw (state_eq None) j", "apply coinduct"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<exists>p r i.\n          x = make_full_observation e None r p i \\<Longrightarrow>\n       \\<exists>xs.\n          x = xs \\<and>\n          state_eq None xs \\<and>\n          ((\\<exists>p r i.\n               stl xs = make_full_observation e None r p i) \\<or>\n           alw (state_eq None) (stl xs))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<exists>p r i.\n          x = make_full_observation e None r p i \\<Longrightarrow>\n       state_eq None x \\<and>\n       ((\\<exists>p r i. stl x = make_full_observation e None r p i) \\<or>\n        alw (state_eq None) (stl x))", "by fastforce"], ["", "lemma once_none_always_none: \"alw (state_eq None) (make_full_observation e None r p t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. alw (state_eq None) (make_full_observation e None r p t)", "using once_none_always_none_aux"], ["proof (prove)\nusing this:\n  \\<exists>p r i. ?j = make_full_observation ?e None r p i \\<Longrightarrow>\n  alw (state_eq None) ?j\n\ngoal (1 subgoal):\n 1. alw (state_eq None) (make_full_observation e None r p t)", "by blast"], ["", "lemma once_none_nxt_always_none: \"alw (nxt (state_eq None)) (make_full_observation e None r p t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. alw (nxt (state_eq None)) (make_full_observation e None r p t)", "using once_none_always_none"], ["proof (prove)\nusing this:\n  alw (state_eq None) (make_full_observation ?e None ?r ?p ?t)\n\ngoal (1 subgoal):\n 1. alw (nxt (state_eq None)) (make_full_observation e None r p t)", "by (simp add: alw_iff_sdrop del: sdrop.simps)"], ["", "lemma snth_sconst: \"(\\<forall>i. s !! i = h) = (s = sconst h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>i. s !! i = h) = (s = sconst h)", "by (metis funpow_code_def id_funpow sdrop_simps(1) sdrop_siterate siterate.simps(1) smap_alt smap_sconst snth.simps(1) stream.map_id)"], ["", "lemma alw_sconst: \"(alw (\\<lambda>xs. shd xs = h) t) = (t = sconst h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. alw (\\<lambda>xs. shd xs = h) t = (t = sconst h)", "by (simp add: snth_sconst[symmetric] alw_iff_sdrop)"], ["", "lemma smap_statename_None: \"smap statename (make_full_observation e None r p i) = sconst None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. smap statename (make_full_observation e None r p i) = sconst None", "by (meson EFSM_LTL.alw_sconst alw_state_eq_smap once_none_always_none)"], ["", "lemma alw_not_some: \"alw (\\<lambda>xs. statename (shd xs) \\<noteq> Some s) (make_full_observation e None r p t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. alw (\\<lambda>xs. statename (shd xs) \\<noteq> Some s)\n     (make_full_observation e None r p t)", "by (metis (mono_tags, lifting) alw_mono once_none_always_none option.distinct(1) )"], ["", "lemma state_none: \"((state_eq None) impl nxt (state_eq None)) (make_full_observation e s r p t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. state_eq None (make_full_observation e s r p t) \\<longrightarrow>\n    nxt (state_eq None) (make_full_observation e s r p t)", "by (simp add: )"], ["", "lemma state_none_2:\n  \"(state_eq None) (make_full_observation e s r p t) \\<Longrightarrow>\n   (state_eq None) (make_full_observation e s r p (stl t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. state_eq None (make_full_observation e s r p t) \\<Longrightarrow>\n    state_eq None (make_full_observation e s r p (stl t))", "by (simp add: )"], ["", "lemma no_output_none_aux:\n  assumes \"\\<exists> p r i. j = (make_full_observation e None r []) i\"\n  shows \"alw (output_eq []) j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. alw (output_eq []) j", "using assms"], ["proof (prove)\nusing this:\n  \\<exists>p r i. j = make_full_observation e None r [] i\n\ngoal (1 subgoal):\n 1. alw (output_eq []) j", "apply coinduct"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<exists>p r i.\n          x = make_full_observation e None r [] i \\<Longrightarrow>\n       \\<exists>xs.\n          x = xs \\<and>\n          output_eq [] xs \\<and>\n          ((\\<exists>p r i.\n               stl xs = make_full_observation e None r [] i) \\<or>\n           alw (output_eq []) (stl xs))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<exists>r i.\n          x = make_full_observation e None r [] i \\<Longrightarrow>\n       output_eq [] x \\<and>\n       ((\\<exists>r i. stl x = make_full_observation e None r [] i) \\<or>\n        alw (output_eq []) (stl x))", "by fastforce"], ["", "lemma no_output_none: \"nxt (alw (output_eq [])) (make_full_observation e None r p t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nxt (alw (output_eq [])) (make_full_observation e None r p t)", "using no_output_none_aux"], ["proof (prove)\nusing this:\n  \\<exists>p r i.\n     ?j = make_full_observation ?e None r [] i \\<Longrightarrow>\n  alw (output_eq []) ?j\n\ngoal (1 subgoal):\n 1. nxt (alw (output_eq [])) (make_full_observation e None r p t)", "by auto"], ["", "lemma nxt_alw: \"nxt (alw P) s \\<Longrightarrow> alw (nxt P) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nxt (alw P) s \\<Longrightarrow> alw (nxt P) s", "by (simp add: alw_iff_sdrop)"], ["", "lemma no_output_none_nxt: \"alw (nxt (output_eq [])) (make_full_observation e None r p t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. alw (nxt (output_eq [])) (make_full_observation e None r p t)", "using nxt_alw no_output_none"], ["proof (prove)\nusing this:\n  nxt (alw ?P) ?s \\<Longrightarrow> alw (nxt ?P) ?s\n  nxt (alw (output_eq [])) (make_full_observation ?e None ?r ?p ?t)\n\ngoal (1 subgoal):\n 1. alw (nxt (output_eq [])) (make_full_observation e None r p t)", "by blast"], ["", "lemma no_output_none_if_empty: \"alw (output_eq []) (make_full_observation e None r [] t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. alw (output_eq []) (make_full_observation e None r [] t)", "by (metis (mono_tags, lifting) alw_nxt make_full_observation.simps(1) no_output_none state.select_convs(4))"], ["", "lemma no_updates_none_aux:\n  assumes \"\\<exists> p i. j = (make_full_observation e None r p) i\"\n  shows \"alw (\\<lambda>x. datastate (shd x) = r) j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. alw (\\<lambda>x. datastate (shd x) = r) j", "using assms"], ["proof (prove)\nusing this:\n  \\<exists>p i. j = make_full_observation e None r p i\n\ngoal (1 subgoal):\n 1. alw (\\<lambda>x. datastate (shd x) = r) j", "apply coinduct"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<exists>p i.\n          x = make_full_observation e None r p i \\<Longrightarrow>\n       \\<exists>xs.\n          x = xs \\<and>\n          datastate (shd xs) = r \\<and>\n          ((\\<exists>p i. stl xs = make_full_observation e None r p i) \\<or>\n           alw (\\<lambda>x. datastate (shd x) = r) (stl xs))", "by fastforce"], ["", "lemma no_updates_none: \"alw (\\<lambda>x. datastate (shd x) = r) (make_full_observation e None r p t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. alw (\\<lambda>x. datastate (shd x) = r)\n     (make_full_observation e None r p t)", "using no_updates_none_aux"], ["proof (prove)\nusing this:\n  \\<exists>p i. ?j = make_full_observation ?e None ?r p i \\<Longrightarrow>\n  alw (\\<lambda>x. datastate (shd x) = ?r) ?j\n\ngoal (1 subgoal):\n 1. alw (\\<lambda>x. datastate (shd x) = r)\n     (make_full_observation e None r p t)", "by blast"], ["", "lemma action_components: \"(label_eq l aand input_eq i) s = (action (shd s) = (String.implode l, i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (label_eq l s \\<and> input_eq i s) =\n    (action (shd s) = (String.implode l, i))", "by (metis fst_conv prod.collapse snd_conv)"], ["", "end"]]}