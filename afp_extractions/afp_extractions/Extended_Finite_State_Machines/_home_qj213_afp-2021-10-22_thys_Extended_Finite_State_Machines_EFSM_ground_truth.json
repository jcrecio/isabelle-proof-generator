{"file_name": "/home/qj213/afp-2021-10-22/thys/Extended_Finite_State_Machines/EFSM.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Extended_Finite_State_Machines", "problem_names": ["lemma str_not_num: \"Str s \\<noteq> Num x1\"", "lemma S_ffUnion: \"S e = ffUnion (fimage (\\<lambda>((s, s'), _). {|s, s'|}) e)\"", "lemma possible_steps_finsert:\n\"possible_steps (finsert ((s, s'), t) e) ss r l i = (\n  if s = ss \\<and> (Label t) = l \\<and> (length i) = (Arity t) \\<and> apply_guards (Guards t) (join_ir i r) then\n    finsert (s', t) (possible_steps e s r l i)\n  else\n    possible_steps e ss r l i\n)\"", "lemma split_origin:\n\"ffilter (\\<lambda>((origin, dest), t). origin = s \\<and> Label t = l \\<and> can_take_transition t i r) e =\nffilter (\\<lambda>((origin, dest), t). Label t = l \\<and> can_take_transition t i r) (ffilter (\\<lambda>((origin, dest), t). origin = s) e)\"", "lemma split_label:\n\"ffilter (\\<lambda>((origin, dest), t). origin = s \\<and> Label t = l \\<and> can_take_transition t i r) e =\nffilter (\\<lambda>((origin, dest), t). origin = s \\<and> can_take_transition t i r) (ffilter (\\<lambda>((origin, dest), t). Label t = l) e)\"", "lemma possible_steps_empty_guards_false:\n  \"\\<forall>((s1, s2), t) |\\<in>| ffilter (\\<lambda>((origin, dest), t). Label t = l) e. \\<not>can_take_transition t i r \\<Longrightarrow>\n  possible_steps e s r l i = {||}\"", "lemma fmember_possible_steps: \"(s', t) |\\<in>| possible_steps e s r l i = (((s, s'), t) \\<in> {((origin, dest), t) \\<in> fset e. origin = s \\<and> Label t = l \\<and> length i = Arity t \\<and> apply_guards (Guards t) (join_ir i r)})\"", "lemma possible_steps_alt_aux:\n  \"possible_steps e s r l i = {|(d, t)|} \\<Longrightarrow>\n       ffilter (\\<lambda>((origin, dest), t). origin = s \\<and> Label t = l \\<and> length i = Arity t \\<and> apply_guards (Guards t) (join_ir i r)) e = {|((s, d), t)|}\"", "lemma possible_steps_alt: \"(possible_steps e s r l i = {|(d, t)|}) = (ffilter\n     (\\<lambda>((origin, dest), t). origin = s \\<and> Label t = l \\<and> length i = Arity t \\<and> apply_guards (Guards t) (join_ir i r))\n     e = {|((s, d), t)|})\"", "lemma possible_steps_alt3: \"(possible_steps e s r l i = {|(d, t)|}) = (ffilter\n     (\\<lambda>((origin, dest), t). origin = s \\<and> Label t = l \\<and> can_take_transition t i r)\n     e = {|((s, d), t)|})\"", "lemma possible_steps_alt_atom: \"(possible_steps e s r l i = {|dt|}) = (ffilter\n     (\\<lambda>((origin, dest), t). origin = s \\<and> Label t = l \\<and> can_take_transition t i r)\n     e = {|((s, fst dt), snd dt)|})\"", "lemma possible_steps_alt2: \"(possible_steps e s r l i = {|(d, t)|}) = (\n     (ffilter (\\<lambda>((origin, dest), t). Label t = l \\<and> length i = Arity t \\<and> apply_guards (Guards t) (join_ir i r)) (ffilter (\\<lambda>((origin, dest), t). origin = s) e) = {|((s, d), t)|}))\"", "lemma possible_steps_single_out:\n\"ffilter (\\<lambda>((origin, dest), t). origin = s) e = {|((s, d), t)|} \\<Longrightarrow>\nLabel t = l \\<and> length i = Arity t \\<and> apply_guards (Guards t) (join_ir i r) \\<Longrightarrow>\npossible_steps e s r l i = {|(d, t)|}\"", "lemma possible_steps_singleton: \"(possible_steps e s r l i = {|(d, t)|}) =\n    ({((origin, dest), t) \\<in> fset e. origin = s \\<and> Label t = l \\<and> length i = Arity t \\<and> apply_guards (Guards t) (join_ir i r)} = {((s, d), t)})\"", "lemma possible_steps_apply_guards:\n  \"possible_steps e s r l i = {|(s', t)|} \\<Longrightarrow>\n   apply_guards (Guards t) (join_ir i r)\"", "lemma possible_steps_empty:\n  \"(possible_steps e s r l i = {||}) = (\\<forall>((origin, dest), t) \\<in> fset e. origin \\<noteq> s \\<or> Label t \\<noteq> l \\<or> \\<not> can_take_transition t i r)\"", "lemma singleton_dest:\n  assumes \"fis_singleton (possible_steps e s r aa b)\"\n      and \"fthe_elem (possible_steps e s r aa b) = (baa, aba)\"\n    shows \"((s, baa), aba) |\\<in>| e\"", "lemma no_outgoing_transitions:\n\"ffilter (\\<lambda>((s', _), _). s = s') e = {||} \\<Longrightarrow>\npossible_steps e s r l i = {||}\"", "lemma ffilter_split: \"ffilter (\\<lambda>((origin, dest), t). origin = s \\<and> Label t = l \\<and> length i = Arity t \\<and> apply_guards (Guards t) (join_ir i r)) e =\n                      ffilter (\\<lambda>((origin, dest), t). Label t = l \\<and> length i = Arity t \\<and> apply_guards (Guards t) (join_ir i r)) (ffilter (\\<lambda>((origin, dest), t). origin = s) e)\"", "lemma one_outgoing_transition:\n  defines \"outgoing s \\<equiv> (\\<lambda>((origin, dest), t). origin = s)\"\n  assumes prem: \"size (ffilter (outgoing s) e) = 1\"\n  shows \"size (possible_steps e s r l i) \\<le> 1\"", "lemma choice_alt: \"choice t t' = choice_alt t t'\"", "lemma choice_symmetry: \"choice x y = choice y x\"", "lemma deterministic_alt_aux: \"size (possible_steps e s r l i) \\<le> 1 =(\n        possible_steps e s r l i = {||} \\<or>\n        (\\<exists>s' t.\n            ffilter\n             (\\<lambda>((origin, dest), t). origin = s \\<and> Label t = l \\<and> length i = Arity t \\<and> apply_guards (Guards t) (join_ir i r)) e =\n            {|((s, s'), t)|}))\"", "lemma deterministic_alt: \"deterministic e = (\n  \\<forall>s r l i.\n    possible_steps e s r l i = {||} \\<or>\n    (\\<exists>s' t. ffilter (\\<lambda>((origin, dest), t). origin = s \\<and> (Label t) = l \\<and> (length i) = (Arity t) \\<and> apply_guards (Guards t) (join_ir i r)) e = {|((s, s'), t)|})\n)\"", "lemma size_le_1: \"size f \\<le> 1 = (f = {||} \\<or> (\\<exists>e. f = {|e|}))\"", "lemma ffilter_empty_if: \"\\<forall>x |\\<in>| xs. \\<not> P x \\<Longrightarrow> ffilter P xs = {||}\"", "lemma empty_ffilter: \"ffilter P xs = {||} = (\\<forall>x |\\<in>| xs. \\<not> P x)\"", "lemma all_states_deterministic:\n\"(\\<forall>s l i r.\n  ffilter (\\<lambda>((origin, dest), t). origin = s \\<and> (Label t) = l \\<and> can_take_transition t i r) e = {||} \\<or>\n  (\\<exists>x. ffilter (\\<lambda>((origin, dest), t). origin = s \\<and> (Label t) = l \\<and> can_take_transition t i r) e = {|x|})\n) \\<Longrightarrow> deterministic e\"", "lemma deterministic_finsert:\n\"\\<forall>i r l.\n\\<forall>((a, b), t) |\\<in>| ffilter (\\<lambda>((origin, dest), t). origin = s) (finsert ((s, s'), t') e).\nLabel t = l \\<and> can_take_transition t i r \\<longrightarrow> \\<not> can_take_transition t' i r \\<Longrightarrow>\ndeterministic e \\<Longrightarrow>\ndeterministic (finsert ((s, s'), t') e)\"", "lemma ffilter_fBall: \"(\\<forall>x |\\<in>| xs. P x) = (ffilter P xs = xs)\"", "lemma fsubset_if: \"\\<forall>x. x |\\<in>| f1 \\<longrightarrow> x |\\<in>| f2 \\<Longrightarrow> f1 |\\<subseteq>| f2\"", "lemma in_possible_steps: \"(((s, s'), t)|\\<in>|e \\<and> Label t = l \\<and> can_take_transition t i r) = ((s', t) |\\<in>| possible_steps e s r l i)\"", "lemma possible_steps_can_take_transition:\n  \"(s2, t1) |\\<in>| possible_steps e1 s1 r l i \\<Longrightarrow> can_take_transition t1 i r\"", "lemma not_deterministic:\n  \"\\<exists>s l i r.\n    \\<exists>d1 d2 t1 t2.\n      d1 \\<noteq> d2 \\<and> t1 \\<noteq> t2 \\<and>\n      ((s, d1), t1) |\\<in>| e \\<and>\n      ((s, d2), t2) |\\<in>| e \\<and>\n      Label t1 = Label t2 \\<and>\n      can_take_transition t1 i r \\<and>\n      can_take_transition t2 i r \\<Longrightarrow>\n  \\<not>deterministic e\"", "lemma not_deterministic_conv:\n  \"\\<not>deterministic e \\<Longrightarrow>\n  \\<exists>s l i r.\n    \\<exists>d1 d2 t1 t2.\n      (d1 \\<noteq> d2 \\<or> t1 \\<noteq> t2) \\<and>\n      ((s, d1), t1) |\\<in>| e \\<and>\n      ((s, d2), t2) |\\<in>| e \\<and>\n      Label t1 = Label t2 \\<and>\n      can_take_transition t1 i r \\<and>\n      can_take_transition t2 i r\"", "lemma deterministic_if:\n\"\\<nexists>s l i r.\n  \\<exists>d1 d2 t1 t2.\n    (d1 \\<noteq> d2 \\<or> t1 \\<noteq> t2) \\<and>\n    ((s, d1), t1) |\\<in>| e \\<and>\n    ((s, d2), t2) |\\<in>| e \\<and>\n    Label t1 = Label t2 \\<and>\n    can_take_transition t1 i r \\<and>\n    can_take_transition t2 i r \\<Longrightarrow>\n  deterministic e\"", "lemma \"\\<forall>l i r.\n  (\\<forall>((s, s'), t) |\\<in>| e. Label t = l \\<and> can_take_transition t i r \\<and>\n  (\\<nexists>t' s''. ((s, s''), t') |\\<in>| e \\<and> (s' \\<noteq> s'' \\<or> t' \\<noteq> t) \\<and> Label t' = l \\<and> can_take_transition t' i r))\n \\<Longrightarrow> deterministic e\"", "lemma in_outgoing: \"((s1, s2), t) |\\<in>| outgoing_transitions e s = (((s1, s2), t) |\\<in>| e \\<and> s1 = s)\"", "lemma outgoing_transitions_deterministic:\n  \"\\<forall>s.\n    \\<forall>((s1, s2), t) |\\<in>| outgoing_transitions e s.\n      \\<forall>((s1', s2'), t') |\\<in>| outgoing_transitions e s.\n        s2 \\<noteq> s2' \\<or> t \\<noteq> t' \\<longrightarrow> Label t = Label t' \\<longrightarrow> \\<not> choice t t' \\<Longrightarrow> deterministic e\"", "lemma outgoing_transitions_deterministic2: \"(\\<And>s a b ba aa bb bc.\n       ((a, b), ba) |\\<in>| outgoing_transitions e s \\<Longrightarrow>\n       ((aa, bb), bc) |\\<in>| (outgoing_transitions e s) - {|((a, b), ba)|} \\<Longrightarrow> b \\<noteq> bb \\<or> ba \\<noteq> bc \\<Longrightarrow> \\<not>choice ba bc)\n        \\<Longrightarrow> deterministic e\"", "lemma outgoing_transitions_fprod_deterministic:\n\"(\\<And>s b ba bb bc.\n(((s, b), ba), ((s, bb), bc)) \\<in> fset (outgoing_transitions e s) \\<times> fset (outgoing_transitions e s)\n\\<Longrightarrow> b \\<noteq> bb \\<or> ba \\<noteq> bc \\<Longrightarrow> Label ba = Label bc \\<Longrightarrow> \\<not>choice ba bc)\n\\<Longrightarrow> deterministic e\"", "lemma random_member_nonempty: \"s \\<noteq> {||} = (random_member s \\<noteq> None)\"", "lemma random_member_singleton [simp]: \"random_member {|a|} = Some a\"", "lemma random_member_is_member:\n  \"random_member ss = Some s \\<Longrightarrow> s |\\<in>| ss\"", "lemma random_member_None[simp]: \"random_member ss = None = (ss = {||})\"", "lemma random_member_empty[simp]: \"random_member {||} = None\"", "lemma possible_steps_not_empty_iff:\n  \"step e s r a b \\<noteq> None \\<Longrightarrow>\n   \\<exists>aa ba. (aa, ba) |\\<in>| possible_steps e s r a b\"", "lemma step_member: \"step e s r l i = Some (t, s', p, r') \\<Longrightarrow> (s', t) |\\<in>| possible_steps e s r l i\"", "lemma step_outputs: \"step e s r l i = Some (t, s', p, r') \\<Longrightarrow> evaluate_outputs t i r = p\"", "lemma step:\n  \"possibilities = (possible_steps e s r l i) \\<Longrightarrow>\n   random_member possibilities = Some (s', t) \\<Longrightarrow>\n   evaluate_outputs t i r = p \\<Longrightarrow>\n   evaluate_updates t i r = r' \\<Longrightarrow>\n   step e s r l i = Some (t, s', p, r')\"", "lemma step_None: \"step e s r l i = None = (possible_steps e s r l i = {||})\"", "lemma step_Some: \"step e s r l i = Some (t, s', p, r') =\n  (\n    random_member (possible_steps e s r l i) = Some (s', t) \\<and>\n    evaluate_outputs t i r = p \\<and>\n    evaluate_updates t i r = r'\n  )\"", "lemma no_possible_steps_1:\n  \"possible_steps e s r l i = {||} \\<Longrightarrow> step e s r l i = None\"", "lemma observe_execution_step_def: \"observe_execution e s r ((l, i)#as)  = (\n    case step e s r l i of\n      None \\<Rightarrow> []|\n      Some (t, s', p, r') \\<Rightarrow> p#(observe_execution e s' r' as)\n    )\"", "lemma observe_execution_first_outputs_equiv:\n  \"observe_execution e1 s1 r1 ((l, i) # ts) = observe_execution e2 s2 r2 ((l, i) # ts) \\<Longrightarrow>\n   step e1 s1 r1 l i = Some (t, s', p, r') \\<Longrightarrow>\n   \\<exists>(s2', t2)|\\<in>|possible_steps e2 s2 r2 l i. evaluate_outputs t2 i r2 = p\"", "lemma observe_execution_step:\n  \"step e s r (fst h) (snd h) = Some (t, s', p, r') \\<Longrightarrow>\n   observe_execution e s' r' es = obs \\<Longrightarrow>\n   observe_execution e s r (h#es) = p#obs\"", "lemma observe_execution_possible_step:\n  \"possible_steps e s r (fst h) (snd h) = {|(s', t)|} \\<Longrightarrow>\n   apply_outputs (Outputs t) (join_ir (snd h) r) = p \\<Longrightarrow>\n   apply_updates (Updates t) (join_ir (snd h) r) r = r' \\<Longrightarrow>\n   observe_execution e s' r' es = obs \\<Longrightarrow>\n   observe_execution e s r (h#es) = p#obs\"", "lemma observe_execution_no_possible_step:\n  \"possible_steps e s r (fst h) (snd h) = {||} \\<Longrightarrow>\n   observe_execution e s r (h#es) = []\"", "lemma observe_execution_no_possible_steps:\n  \"possible_steps e1 s1 r1 (fst h) (snd h) = {||} \\<Longrightarrow>\n   possible_steps e2 s2 r2 (fst h) (snd h) = {||} \\<Longrightarrow>\n   (observe_execution e1 s1 r1 (h#t)) = (observe_execution e2 s2 r2 (h#t))\"", "lemma observe_execution_one_possible_step:\n  \"possible_steps e1 s1 r (fst h) (snd h) = {|(s1', t1)|} \\<Longrightarrow>\n   possible_steps e2 s2 r (fst h) (snd h) = {|(s2', t2)|} \\<Longrightarrow>\n   apply_outputs (Outputs t1) (join_ir (snd h) r) = apply_outputs (Outputs t2) (join_ir (snd h) r) \\<Longrightarrow>\n\n   apply_updates (Updates t1) (join_ir (snd h) r) r = r' \\<Longrightarrow>\n   apply_updates (Updates t2) (join_ir (snd h) r) r = r' \\<Longrightarrow>\n   (observe_execution e1 s1' r' t) = (observe_execution e2 s2' r' t) \\<Longrightarrow>\n   (observe_execution e1 s1 r (h#t)) = (observe_execution e2 s2 r (h#t))\"", "lemma finite_all_regs: \"finite (all_regs e)\"", "lemma no_possible_steps_rejects:\n  \"possible_steps e s r l i = {||} \\<Longrightarrow> \\<not> recognises_execution e s r ((l, i)#t)\"", "lemma recognises_step_equiv: \"recognises_execution e s r ((l, i)#t) =\n   (\\<exists>(s', T) |\\<in>| possible_steps e s r l i. recognises_execution e s' (evaluate_updates T i r) t)\"", "lemma recognises_prim [code]: \"recognises_execution e s r t = recognises_prim e s r t\"", "lemma recognises_single_possible_step:\n  assumes \"possible_steps e s r l i = {|(s', t)|}\"\n      and \"recognises_execution e s' (evaluate_updates t i r) trace\"\n    shows \"recognises_execution e s r ((l, i)#trace)\"", "lemma recognises_single_possible_step_atomic:\n  assumes \"possible_steps e s r (fst h) (snd h) = {|(s', t)|}\"\n      and \"recognises_execution e s' (apply_updates (Updates t) (join_ir (snd h) r) r) trace\"\n    shows \"recognises_execution e s r (h#trace)\"", "lemma recognises_must_be_possible_step:\n  \"recognises_execution e s r (h # t) \\<Longrightarrow>\n   \\<exists>aa ba. (aa, ba) |\\<in>| possible_steps e s r (fst h) (snd h)\"", "lemma recognises_possible_steps_not_empty:\n  \"recognises_execution e s r (h#t) \\<Longrightarrow> possible_steps e s r (fst h) (snd h) \\<noteq> {||}\"", "lemma recognises_must_be_step:\n  \"recognises_execution e s r (h#ts) \\<Longrightarrow>\n   \\<exists>t s' p d'. step e s r (fst h) (snd h) = Some (t, s', p, d')\"", "lemma recognises_cons_step:\n  \"recognises_execution e s r (h # t) \\<Longrightarrow> step e s r (fst h) (snd h) \\<noteq>  None\"", "lemma no_step_none:\n  \"step e s r aa ba = None \\<Longrightarrow> \\<not> recognises_execution e s r ((aa, ba) # p)\"", "lemma step_none_rejects:\n  \"step e s r (fst h) (snd h) = None \\<Longrightarrow> \\<not> recognises_execution e s r (h#t)\"", "lemma trace_reject:\n  \"(\\<not> recognises_execution e s r ((l, i)#t)) = (possible_steps e s r l i = {||} \\<or> (\\<forall>(s', T) |\\<in>| possible_steps e s r l i. \\<not> recognises_execution e s' (evaluate_updates T i r) t))\"", "lemma trace_reject_no_possible_steps_atomic:\n  \"possible_steps e s r (fst a) (snd a) = {||} \\<Longrightarrow> \\<not> recognises_execution e s r (a#t)\"", "lemma trace_reject_later:\n  \"\\<forall>(s', T) |\\<in>| possible_steps e s r l i. \\<not> recognises_execution e s' (evaluate_updates T i r) t \\<Longrightarrow>\n   \\<not> recognises_execution e s r ((l, i)#t)\"", "lemma recognition_prefix_closure: \"recognises_execution e s r (t@t') \\<Longrightarrow> recognises_execution e s r t\"", "lemma rejects_prefix: \"\\<not> recognises_execution e s r t \\<Longrightarrow> \\<not> recognises_execution e s r (t @ t')\"", "lemma recognises_head: \"recognises_execution e s r (h#t) \\<Longrightarrow> recognises_execution e s r [h]\"", "lemma accepts_trace_step:\n  \"accepts_trace e s r ((l, i, p)#t) = (\\<exists>(s', T) |\\<in>| possible_steps e s r l i.\n         evaluate_outputs T i r = map Some p \\<and>\n         accepts_trace e s' (evaluate_updates T i r) t)\"", "lemma accepts_trace_exists_possible_step:\n  \"accepts_trace e1 s1 r1 ((aa, b, c) # t) \\<Longrightarrow>\n       \\<exists>(s1', t1)|\\<in>|possible_steps e1 s1 r1 aa b.\n          evaluate_outputs t1 b r1 = map Some c\"", "lemma rejects_trace_step:\n\"rejects_trace e s r ((l, i, p)#t) = (\n  (\\<forall>(s', T) |\\<in>| possible_steps e s r l i.  evaluate_outputs T i r \\<noteq> map Some p \\<or> rejects_trace e s' (evaluate_updates T i r) t)\n)\"", "lemma prefix_closure: \"accepts_trace e s r (t@t') \\<Longrightarrow> accepts_trace e s r t\"", "lemma accepts_trace_prim [code]: \"accepts_trace e s r l = accepts_trace_prim e s r l\"", "lemma trace_simulation_step:\n\"trace_simulation f e1 s1 r1 e2 s2 r2 ((l, i, o)#es) = (\n  (s2 = f s1) \\<and> (\\<forall>(s1', t1) |\\<in>| ffilter (\\<lambda>(s1', t1). evaluate_outputs t1 i r1 = map Some o) (possible_steps e1 s1 r1 l i).\n         (\\<exists>(s2', t2) |\\<in>| possible_steps e2 s2 r2 l i. evaluate_outputs t2 i r2 = map Some o \\<and>\n         trace_simulation f e1 s1' (evaluate_updates t1 i r1) e2 s2' (evaluate_updates t2 i r2) es))\n)\"", "lemma trace_simulation_step_none:\n  \"s2 = f s1 \\<Longrightarrow>\n   \\<nexists>(s1', t1) |\\<in>| possible_steps e1 s1 r1 l i. evaluate_outputs t1 i r1 = map Some o \\<Longrightarrow>\n   trace_simulation f e1 s1 r1 e2 s2 r2 ((l, i, o)#es)\"", "lemma rejects_trace_simulation:\n  \"rejects_trace e2 s2 r2 t \\<Longrightarrow>\n   accepts_trace e1 s1 r1 t \\<Longrightarrow>\n   \\<not>trace_simulation f e1 s1 r1 e2 s2 r2 t\"", "lemma accepts_trace_simulation:\n  \"accepts_trace e1 s1 r1 t \\<Longrightarrow>\n   trace_simulation f e1 s1 r1 e2 s2 r2 t \\<Longrightarrow>\n   accepts_trace e2 s2 r2 t\"", "lemma simulates_trace_subset: \"trace_simulates e1 e2 \\<Longrightarrow> T e1 \\<subseteq> T e2\"", "lemma simulation_implies_trace_equivalent:\n  \"trace_simulates e1 e2 \\<Longrightarrow> trace_simulates e2 e1 \\<Longrightarrow> trace_equivalent e1 e2\"", "lemma trace_equivalent_reflexive: \"trace_equivalent e1 e1\"", "lemma trace_equivalent_symmetric:\n  \"trace_equivalent e1 e2 = trace_equivalent e2 e1\"", "lemma trace_equivalent_transitive:\n  \"trace_equivalent e1 e2 \\<Longrightarrow>\n   trace_equivalent e2 e3 \\<Longrightarrow>\n   trace_equivalent e1 e3\"", "lemma trace_equivalent:\n  \"\\<forall>t. accepts_trace e1 0 <> t = accepts_trace e2 0 <> t \\<Longrightarrow> trace_equivalent e1 e2\"", "lemma accepts_trace_step_2: \"(s2', t2) |\\<in>| possible_steps e2 s2 r2 l i \\<Longrightarrow>\n       accepts_trace e2 s2' (evaluate_updates t2 i r2) t \\<Longrightarrow>\n       evaluate_outputs t2 i r2 = map Some p \\<Longrightarrow>\n       accepts_trace e2 s2 r2 ((l, i, p)#t)\"", "lemma execution_simulation_step:\n\"execution_simulation f e1 s1 r1 e2 s2 r2 ((l, i)#es) =\n (s2 = f s1 \\<and>\n (\\<forall>(s1', t1) |\\<in>| (possible_steps e1 s1 r1 l i).\n         (\\<exists>(s2', t2) |\\<in>| possible_steps e2 s2 r2 l i. evaluate_outputs t1 i r1 = evaluate_outputs t2 i r2 \\<and>\n         execution_simulation f e1 s1' (evaluate_updates t1 i r1) e2 s2' (evaluate_updates t2 i r2) es))\n)\"", "lemma execution_simulation_trace_simulation:\n  \"execution_simulation f e1 s1 r1 e2 s2 r2 (map (\\<lambda>(l, i, o). (l, i)) t) \\<Longrightarrow>\n   trace_simulation f e1 s1 r1 e2 s2 r2 t\"", "lemma execution_simulates_trace_simulates:\n  \"execution_simulates e1 e2 \\<Longrightarrow> trace_simulates e1 e2\"", "lemma executionally_equivalent_step:\n\"executionally_equivalent e1 s1 r1 e2 s2 r2 ((l, i)#es) = (\n  (\\<forall>(s1', t1) |\\<in>| (possible_steps e1 s1 r1 l i). (\\<exists>(s2', t2) |\\<in>| possible_steps e2 s2 r2 l i. evaluate_outputs t1 i r1 = evaluate_outputs t2 i r2 \\<and>\n   executionally_equivalent e1 s1' (evaluate_updates t1 i r1) e2 s2' (evaluate_updates t2 i r2) es)) \\<and>\n  (\\<forall>(s2', t2) |\\<in>| (possible_steps e2 s2 r2 l i). (\\<exists>(s1', t1) |\\<in>| possible_steps e1 s1 r1 l i. evaluate_outputs t1 i r1 = evaluate_outputs t2 i r2 \\<and>\n   executionally_equivalent e1 s1' (evaluate_updates t1 i r1) e2 s2' (evaluate_updates t2 i r2) es)))\"", "lemma execution_end:\n  \"possible_steps e1 s1 r1 l i = {||} \\<Longrightarrow>\n   possible_steps e2 s2 r2 l i = {||} \\<Longrightarrow>\n  executionally_equivalent e1 s1 r1 e2 s2 r2 ((l, i)#es)\"", "lemma possible_steps_disparity:\n  \"possible_steps e1 s1 r1 l i \\<noteq> {||} \\<Longrightarrow>\n   possible_steps e2 s2 r2 l i = {||} \\<Longrightarrow>\n   \\<not>executionally_equivalent e1 s1 r1 e2 s2 r2 ((l, i)#es)\"", "lemma executionally_equivalent_acceptance_map:\n  \"executionally_equivalent e1 s1 r1 e2 s2 r2 (map (\\<lambda>(l, i, o). (l, i)) t) \\<Longrightarrow>\n   accepts_trace e2 s2 r2 t = accepts_trace e1 s1 r1 t\"", "lemma executionally_equivalent_acceptance:\n  \"\\<forall>x. executionally_equivalent e1 s1 r1 e2 s2 r2 x \\<Longrightarrow> accepts_trace e1 s1 r1  t \\<Longrightarrow> accepts_trace e2 s2 r2 t\"", "lemma executionally_equivalent_trace_equivalent:\n  \"\\<forall>x. executionally_equivalent e1 0 <> e2 0 <> x \\<Longrightarrow> trace_equivalent e1 e2\"", "lemma executionally_equivalent_symmetry:\n  \"executionally_equivalent e1 s1 r1 e2 s2 r2 x \\<Longrightarrow>\n   executionally_equivalent e2 s2 r2 e1 s1 r1 x\"", "lemma executionally_equivalent_transitivity:\n  \"executionally_equivalent e1 s1 r1 e2 s2 r2 x \\<Longrightarrow>\n   executionally_equivalent e2 s2 r2 e3 s3 r3 x \\<Longrightarrow>\n   executionally_equivalent e1 s1 r1 e3 s3 r3 x\"", "lemma no_further_steps:\n  \"s \\<noteq> s' \\<Longrightarrow> \\<not> visits s e s' r []\"", "lemma visits_base: \"visits target e s r [] = (s = target)\"", "lemma visits_step:\n  \"visits target e s r (h#t) = (\\<exists>(s', T) |\\<in>| possible_steps e s r (fst h) (snd h). visits target e s' (evaluate_updates T (snd h) r) t)\"", "lemma reachable_initial: \"reachable 0 e\"", "lemma visits_finsert:\n  \"visits s e s' r t \\<Longrightarrow> visits s (finsert ((aa, ba), b) e) s' r t\"", "lemma reachable_finsert:\n  \"reachable s e \\<Longrightarrow> reachable s (finsert ((aa, ba), b) e)\"", "lemma reachable_finsert_contra:\n  \"\\<not> reachable s (finsert ((aa, ba), b) e) \\<Longrightarrow> \\<not>reachable s e\"", "lemma visits_empty: \"visits s e s' r [] = (s = s')\"", "lemma obtains_obtainable:\n  \"obtains s r e 0 <> t \\<Longrightarrow> obtainable s r e\"", "lemma obtains_base: \"obtains s r e s' r' [] = (s = s' \\<and> r = r')\"", "lemma obtains_step: \"obtains s r e s' r' ((l, i)#t) = (\\<exists>(s'', T) |\\<in>| possible_steps e s' r' l i. obtains s r e s'' (evaluate_updates T i r') t)\"", "lemma obtains_recognises:\n  \"obtains s c e s' r t \\<Longrightarrow> recognises_execution e s' r t\"", "lemma ex_comm4:\n  \"(\\<exists>c1 s a b. (a, b) \\<in> fset (possible_steps e s' r l i) \\<and> obtains s c1 e a (evaluate_updates b i r) t) =\n   (\\<exists>a b s c1. (a, b) \\<in> fset (possible_steps e s' r l i) \\<and> obtains s c1 e a (evaluate_updates b i r) t)\"", "lemma recognises_execution_obtains:\n  \"recognises_execution e s' r t \\<Longrightarrow> \\<exists>c1 s. obtains s c1 e s' r t\"", "lemma obtainable_empty_efsm:\n  \"obtainable s c {||} = (s=0 \\<and> c = <>)\"", "lemma obtains_visits: \"obtains s r e s' r' t \\<Longrightarrow> visits s e s' r' t\"", "lemma unobtainable_if: \"\\<not> visits s e s' r' t \\<Longrightarrow> \\<not> obtains s r e s' r' t\"", "lemma obtainable_if_unreachable: \"\\<not>reachable s e \\<Longrightarrow> \\<not>obtainable s r e\"", "lemma obtains_step_append:\n  \"obtains s r e s' r' t \\<Longrightarrow>\n  (s'', ta) |\\<in>| possible_steps e s r l i \\<Longrightarrow>\n  obtains s'' (evaluate_updates ta i r) e s' r' (t @ [(l, i)])\"", "lemma reachable_if_obtainable_step:\n  \"obtainable s r e \\<Longrightarrow> \\<exists>l i t. (s', t) |\\<in>| possible_steps e s r l i \\<Longrightarrow> reachable s' e\"", "lemma possible_steps_remove_unreachable:\n  \"obtainable s r e \\<Longrightarrow>\n  \\<not> reachable s' e \\<Longrightarrow>\n  possible_steps (remove_state s' e) s r l i = possible_steps e s r l i\"", "lemma executionally_equivalent_remove_unreachable_state_arbitrary:\n  \"obtainable s r e \\<Longrightarrow> \\<not> reachable s' e \\<Longrightarrow> executionally_equivalent e s r (remove_state s' e) s r x\"", "lemma executionally_equivalent_remove_unreachable_state:\n  \"\\<not> reachable s' e \\<Longrightarrow> executionally_equivalent e 0 <> (remove_state s' e) 0 <> x\"", "lemma replace_finsert:\n  \"replace (finsert ((aaa, baa), b) e1) old new = (if ((aaa, baa), b) = old then (finsert new (replace e1 old new)) else (finsert ((aaa, baa), b) (replace e1 old new)))\"", "lemma possible_steps_replace_unchanged:\n  \"((s, aa), ba) \\<noteq> ((s1, s2), t1) \\<Longrightarrow>\n  (aa, ba) |\\<in>| possible_steps e1 s r l i \\<Longrightarrow>\n  (aa, ba) |\\<in>| possible_steps (replace e1 ((s1, s2), t1) ((s1, s2), t2)) s r l i\""], "translations": [["", "lemma str_not_num: \"Str s \\<noteq> Num x1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. EFSM.Str s \\<noteq> Num x1", "by (simp add: Str_def)"], ["", "definition S :: \"transition_matrix \\<Rightarrow> nat fset\" where\n  \"S m = (fimage (\\<lambda>((s, s'), t). s) m) |\\<union>| fimage (\\<lambda>((s, s'), t). s') m\""], ["", "lemma S_ffUnion: \"S e = ffUnion (fimage (\\<lambda>((s, s'), _). {|s, s'|}) e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S e = ffUnion ((\\<lambda>((s, s'), uu_). {|s, s'|}) |`| e)", "unfolding S_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>((s, s'), t). s) |`| e |\\<union>|\n    (\\<lambda>((s, s'), t). s') |`| e =\n    ffUnion ((\\<lambda>((s, s'), uu_). {|s, s'|}) |`| e)", "by(induct e, auto)"], ["", "subsection\\<open>Possible Steps\\<close>"], ["", "text\\<open>From a given state, the possible steps for a given action are those transitions with labels\nwhich correspond to the action label, arities which correspond to the number of inputs, and guards\nwhich are satisfied by those inputs.\\<close>"], ["", "definition possible_steps :: \"transition_matrix \\<Rightarrow> cfstate \\<Rightarrow> registers \\<Rightarrow> label \\<Rightarrow> inputs \\<Rightarrow> (cfstate \\<times> transition) fset\" where\n  \"possible_steps e s r l i = fimage (\\<lambda>((origin, dest), t). (dest, t)) (ffilter (\\<lambda>((origin, dest), t). origin = s \\<and> (Label t) = l \\<and> (length i) = (Arity t) \\<and> apply_guards (Guards t) (join_ir i r)) e)\""], ["", "lemma possible_steps_finsert:\n\"possible_steps (finsert ((s, s'), t) e) ss r l i = (\n  if s = ss \\<and> (Label t) = l \\<and> (length i) = (Arity t) \\<and> apply_guards (Guards t) (join_ir i r) then\n    finsert (s', t) (possible_steps e s r l i)\n  else\n    possible_steps e ss r l i\n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. possible_steps (finsert ((s, s'), t) e) ss r l i =\n    (if s = ss \\<and>\n        Label t = l \\<and>\n        length i = Arity t \\<and> apply_guards (Guards t) (join_ir i r)\n     then finsert (s', t) (possible_steps e s r l i)\n     else possible_steps e ss r l i)", "by (simp add: possible_steps_def ffilter_finsert)"], ["", "lemma split_origin:\n\"ffilter (\\<lambda>((origin, dest), t). origin = s \\<and> Label t = l \\<and> can_take_transition t i r) e =\nffilter (\\<lambda>((origin, dest), t). Label t = l \\<and> can_take_transition t i r) (ffilter (\\<lambda>((origin, dest), t). origin = s) e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ffilter\n     (\\<lambda>((origin, dest), t).\n         origin = s \\<and> Label t = l \\<and> can_take_transition t i r)\n     e =\n    ffilter\n     (\\<lambda>((origin, dest), t).\n         Label t = l \\<and> can_take_transition t i r)\n     (ffilter (\\<lambda>((origin, dest), t). origin = s) e)", "by auto"], ["", "lemma split_label:\n\"ffilter (\\<lambda>((origin, dest), t). origin = s \\<and> Label t = l \\<and> can_take_transition t i r) e =\nffilter (\\<lambda>((origin, dest), t). origin = s \\<and> can_take_transition t i r) (ffilter (\\<lambda>((origin, dest), t). Label t = l) e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ffilter\n     (\\<lambda>((origin, dest), t).\n         origin = s \\<and> Label t = l \\<and> can_take_transition t i r)\n     e =\n    ffilter\n     (\\<lambda>((origin, dest), t).\n         origin = s \\<and> can_take_transition t i r)\n     (ffilter (\\<lambda>((origin, dest), t). Label t = l) e)", "by auto"], ["", "lemma possible_steps_empty_guards_false:\n  \"\\<forall>((s1, s2), t) |\\<in>| ffilter (\\<lambda>((origin, dest), t). Label t = l) e. \\<not>can_take_transition t i r \\<Longrightarrow>\n  possible_steps e s r l i = {||}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>((s1, s2), t)\n             |\\<in>|ffilter (\\<lambda>((origin, dest), t). Label t = l) e.\n       \\<not> can_take_transition t i r \\<Longrightarrow>\n    possible_steps e s r l i = {||}", "apply (simp add: possible_steps_def can_take[symmetric] split_label)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>((s1, s2), t)\n             |\\<in>|ffilter (\\<lambda>((origin, dest), t). Label t = l) e.\n       \\<not> can_take_transition t i r \\<Longrightarrow>\n    ffilter\n     (\\<lambda>((origin, dest), t).\n         origin = s \\<and> can_take_transition t i r)\n     (ffilter (\\<lambda>((origin, dest), t). Label t = l) e) =\n    {||}", "by (simp add: Abs_ffilter fBall_def Ball_def)"], ["", "lemma fmember_possible_steps: \"(s', t) |\\<in>| possible_steps e s r l i = (((s, s'), t) \\<in> {((origin, dest), t) \\<in> fset e. origin = s \\<and> Label t = l \\<and> length i = Arity t \\<and> apply_guards (Guards t) (join_ir i r)})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((s', t) |\\<in>| possible_steps e s r l i) =\n    (((s, s'), t)\n     \\<in> {((origin, dest), t).\n            ((origin, dest), t) \\<in> fset e \\<and>\n            origin = s \\<and>\n            Label t = l \\<and>\n            length i = Arity t \\<and>\n            apply_guards (Guards t) (join_ir i r)})", "apply (simp add: possible_steps_def ffilter_def fimage_def fmember_def Abs_fset_inverse)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((s', t)\n     \\<in> case_prod (\\<lambda>(origin, y). Pair y) `\n           Set.filter\n            (\\<lambda>((origin, dest), t).\n                origin = s \\<and>\n                Label t = l \\<and>\n                length i = Arity t \\<and>\n                apply_guards (Guards t) (join_ir i r))\n            (fset e)) =\n    (((s, s'), t) \\<in> fset e \\<and>\n     Label t = l \\<and>\n     length i = Arity t \\<and> apply_guards (Guards t) (join_ir i r))", "by force"], ["", "lemma possible_steps_alt_aux:\n  \"possible_steps e s r l i = {|(d, t)|} \\<Longrightarrow>\n       ffilter (\\<lambda>((origin, dest), t). origin = s \\<and> Label t = l \\<and> length i = Arity t \\<and> apply_guards (Guards t) (join_ir i r)) e = {|((s, d), t)|}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. possible_steps e s r l i = {|(d, t)|} \\<Longrightarrow>\n    ffilter\n     (\\<lambda>((origin, dest), t).\n         origin = s \\<and>\n         Label t = l \\<and>\n         length i = Arity t \\<and> apply_guards (Guards t) (join_ir i r))\n     e =\n    {|((s, d), t)|}", "proof(induct e)"], ["proof (state)\ngoal (2 subgoals):\n 1. possible_steps {||} s r l i = {|(d, t)|} \\<Longrightarrow>\n    ffilter\n     (\\<lambda>((origin, dest), t).\n         origin = s \\<and>\n         Label t = l \\<and>\n         length i = Arity t \\<and> apply_guards (Guards t) (join_ir i r))\n     {||} =\n    {|((s, d), t)|}\n 2. \\<And>x e.\n       \\<lbrakk>x |\\<notin>| e;\n        possible_steps e s r l i = {|(d, t)|} \\<Longrightarrow>\n        ffilter\n         (\\<lambda>((origin, dest), t).\n             origin = s \\<and>\n             Label t = l \\<and>\n             length i = Arity t \\<and>\n             apply_guards (Guards t) (join_ir i r))\n         e =\n        {|((s, d), t)|};\n        possible_steps (finsert x e) s r l i = {|(d, t)|}\\<rbrakk>\n       \\<Longrightarrow> ffilter\n                          (\\<lambda>((origin, dest), t).\n                              origin = s \\<and>\n                              Label t = l \\<and>\n                              length i = Arity t \\<and>\n                              apply_guards (Guards t) (join_ir i r))\n                          (finsert x e) =\n                         {|((s, d), t)|}", "case empty"], ["proof (state)\nthis:\n  possible_steps {||} s r l i = {|(d, t)|}\n\ngoal (2 subgoals):\n 1. possible_steps {||} s r l i = {|(d, t)|} \\<Longrightarrow>\n    ffilter\n     (\\<lambda>((origin, dest), t).\n         origin = s \\<and>\n         Label t = l \\<and>\n         length i = Arity t \\<and> apply_guards (Guards t) (join_ir i r))\n     {||} =\n    {|((s, d), t)|}\n 2. \\<And>x e.\n       \\<lbrakk>x |\\<notin>| e;\n        possible_steps e s r l i = {|(d, t)|} \\<Longrightarrow>\n        ffilter\n         (\\<lambda>((origin, dest), t).\n             origin = s \\<and>\n             Label t = l \\<and>\n             length i = Arity t \\<and>\n             apply_guards (Guards t) (join_ir i r))\n         e =\n        {|((s, d), t)|};\n        possible_steps (finsert x e) s r l i = {|(d, t)|}\\<rbrakk>\n       \\<Longrightarrow> ffilter\n                          (\\<lambda>((origin, dest), t).\n                              origin = s \\<and>\n                              Label t = l \\<and>\n                              length i = Arity t \\<and>\n                              apply_guards (Guards t) (join_ir i r))\n                          (finsert x e) =\n                         {|((s, d), t)|}", "then"], ["proof (chain)\npicking this:\n  possible_steps {||} s r l i = {|(d, t)|}", "show ?case"], ["proof (prove)\nusing this:\n  possible_steps {||} s r l i = {|(d, t)|}\n\ngoal (1 subgoal):\n 1. ffilter\n     (\\<lambda>a.\n         case a of\n         (a, b) \\<Rightarrow>\n           (case a of\n            (origin, dest) \\<Rightarrow>\n              \\<lambda>t.\n                 origin = s \\<and>\n                 Label t = l \\<and>\n                 length i = Arity t \\<and>\n                 apply_guards (Guards t) (join_ir i r))\n            b)\n     {||} =\n    {|((s, d), t)|}", "by (simp add: fempty_not_finsert possible_steps_def)"], ["proof (state)\nthis:\n  ffilter\n   (\\<lambda>a.\n       case a of\n       (a, b) \\<Rightarrow>\n         (case a of\n          (origin, dest) \\<Rightarrow>\n            \\<lambda>t.\n               origin = s \\<and>\n               Label t = l \\<and>\n               length i = Arity t \\<and>\n               apply_guards (Guards t) (join_ir i r))\n          b)\n   {||} =\n  {|((s, d), t)|}\n\ngoal (1 subgoal):\n 1. \\<And>x e.\n       \\<lbrakk>x |\\<notin>| e;\n        possible_steps e s r l i = {|(d, t)|} \\<Longrightarrow>\n        ffilter\n         (\\<lambda>((origin, dest), t).\n             origin = s \\<and>\n             Label t = l \\<and>\n             length i = Arity t \\<and>\n             apply_guards (Guards t) (join_ir i r))\n         e =\n        {|((s, d), t)|};\n        possible_steps (finsert x e) s r l i = {|(d, t)|}\\<rbrakk>\n       \\<Longrightarrow> ffilter\n                          (\\<lambda>((origin, dest), t).\n                              origin = s \\<and>\n                              Label t = l \\<and>\n                              length i = Arity t \\<and>\n                              apply_guards (Guards t) (join_ir i r))\n                          (finsert x e) =\n                         {|((s, d), t)|}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x e.\n       \\<lbrakk>x |\\<notin>| e;\n        possible_steps e s r l i = {|(d, t)|} \\<Longrightarrow>\n        ffilter\n         (\\<lambda>((origin, dest), t).\n             origin = s \\<and>\n             Label t = l \\<and>\n             length i = Arity t \\<and>\n             apply_guards (Guards t) (join_ir i r))\n         e =\n        {|((s, d), t)|};\n        possible_steps (finsert x e) s r l i = {|(d, t)|}\\<rbrakk>\n       \\<Longrightarrow> ffilter\n                          (\\<lambda>((origin, dest), t).\n                              origin = s \\<and>\n                              Label t = l \\<and>\n                              length i = Arity t \\<and>\n                              apply_guards (Guards t) (join_ir i r))\n                          (finsert x e) =\n                         {|((s, d), t)|}", "case (insert x e)"], ["proof (state)\nthis:\n  x |\\<notin>| e\n  possible_steps e s r l i = {|(d, t)|} \\<Longrightarrow>\n  ffilter\n   (\\<lambda>a.\n       case a of\n       (a, b) \\<Rightarrow>\n         (case a of\n          (origin, dest) \\<Rightarrow>\n            \\<lambda>t.\n               origin = s \\<and>\n               Label t = l \\<and>\n               length i = Arity t \\<and>\n               apply_guards (Guards t) (join_ir i r))\n          b)\n   e =\n  {|((s, d), t)|}\n  possible_steps (finsert x e) s r l i = {|(d, t)|}\n\ngoal (1 subgoal):\n 1. \\<And>x e.\n       \\<lbrakk>x |\\<notin>| e;\n        possible_steps e s r l i = {|(d, t)|} \\<Longrightarrow>\n        ffilter\n         (\\<lambda>((origin, dest), t).\n             origin = s \\<and>\n             Label t = l \\<and>\n             length i = Arity t \\<and>\n             apply_guards (Guards t) (join_ir i r))\n         e =\n        {|((s, d), t)|};\n        possible_steps (finsert x e) s r l i = {|(d, t)|}\\<rbrakk>\n       \\<Longrightarrow> ffilter\n                          (\\<lambda>((origin, dest), t).\n                              origin = s \\<and>\n                              Label t = l \\<and>\n                              length i = Arity t \\<and>\n                              apply_guards (Guards t) (join_ir i r))\n                          (finsert x e) =\n                         {|((s, d), t)|}", "then"], ["proof (chain)\npicking this:\n  x |\\<notin>| e\n  possible_steps e s r l i = {|(d, t)|} \\<Longrightarrow>\n  ffilter\n   (\\<lambda>a.\n       case a of\n       (a, b) \\<Rightarrow>\n         (case a of\n          (origin, dest) \\<Rightarrow>\n            \\<lambda>t.\n               origin = s \\<and>\n               Label t = l \\<and>\n               length i = Arity t \\<and>\n               apply_guards (Guards t) (join_ir i r))\n          b)\n   e =\n  {|((s, d), t)|}\n  possible_steps (finsert x e) s r l i = {|(d, t)|}", "show ?case"], ["proof (prove)\nusing this:\n  x |\\<notin>| e\n  possible_steps e s r l i = {|(d, t)|} \\<Longrightarrow>\n  ffilter\n   (\\<lambda>a.\n       case a of\n       (a, b) \\<Rightarrow>\n         (case a of\n          (origin, dest) \\<Rightarrow>\n            \\<lambda>t.\n               origin = s \\<and>\n               Label t = l \\<and>\n               length i = Arity t \\<and>\n               apply_guards (Guards t) (join_ir i r))\n          b)\n   e =\n  {|((s, d), t)|}\n  possible_steps (finsert x e) s r l i = {|(d, t)|}\n\ngoal (1 subgoal):\n 1. ffilter\n     (\\<lambda>a.\n         case a of\n         (a, b) \\<Rightarrow>\n           (case a of\n            (origin, dest) \\<Rightarrow>\n              \\<lambda>t.\n                 origin = s \\<and>\n                 Label t = l \\<and>\n                 length i = Arity t \\<and>\n                 apply_guards (Guards t) (join_ir i r))\n            b)\n     (finsert x e) =\n    {|((s, d), t)|}", "apply (case_tac x)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>x |\\<notin>| e;\n        possible_steps e s r l i = {|(d, t)|} \\<Longrightarrow>\n        ffilter\n         (\\<lambda>a.\n             case a of\n             (a, b) \\<Rightarrow>\n               (case a of\n                (origin, dest) \\<Rightarrow>\n                  \\<lambda>t.\n                     origin = s \\<and>\n                     Label t = l \\<and>\n                     length i = Arity t \\<and>\n                     apply_guards (Guards t) (join_ir i r))\n                b)\n         e =\n        {|((s, d), t)|};\n        possible_steps (finsert x e) s r l i = {|(d, t)|};\n        x = (a, b)\\<rbrakk>\n       \\<Longrightarrow> ffilter\n                          (\\<lambda>a.\n                              case a of\n                              (a, b) \\<Rightarrow>\n                                (case a of\n                                 (origin, dest) \\<Rightarrow>\n                                   \\<lambda>t.\norigin = s \\<and>\nLabel t = l \\<and>\nlength i = Arity t \\<and> apply_guards (Guards t) (join_ir i r))\n                                 b)\n                          (finsert x e) =\n                         {|((s, d), t)|}", "subgoal for a b"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x |\\<notin>| e;\n     possible_steps e s r l i = {|(d, t)|} \\<Longrightarrow>\n     ffilter\n      (\\<lambda>a.\n          case a of\n          (a, b) \\<Rightarrow>\n            (case a of\n             (origin, dest) \\<Rightarrow>\n               \\<lambda>t.\n                  origin = s \\<and>\n                  Label t = l \\<and>\n                  length i = Arity t \\<and>\n                  apply_guards (Guards t) (join_ir i r))\n             b)\n      e =\n     {|((s, d), t)|};\n     possible_steps (finsert x e) s r l i = {|(d, t)|}; x = (a, b)\\<rbrakk>\n    \\<Longrightarrow> ffilter\n                       (\\<lambda>a.\n                           case a of\n                           (a, b) \\<Rightarrow>\n                             (case a of\n                              (origin, dest) \\<Rightarrow>\n                                \\<lambda>t.\n                                   origin = s \\<and>\n                                   Label t = l \\<and>\n                                   length i = Arity t \\<and>\n                                   apply_guards (Guards t) (join_ir i r))\n                              b)\n                       (finsert x e) =\n                      {|((s, d), t)|}", "apply (case_tac a)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa ba.\n       \\<lbrakk>x |\\<notin>| e;\n        possible_steps e s r l i = {|(d, t)|} \\<Longrightarrow>\n        ffilter\n         (\\<lambda>a.\n             case a of\n             (a, b) \\<Rightarrow>\n               (case a of\n                (origin, dest) \\<Rightarrow>\n                  \\<lambda>t.\n                     origin = s \\<and>\n                     Label t = l \\<and>\n                     length i = Arity t \\<and>\n                     apply_guards (Guards t) (join_ir i r))\n                b)\n         e =\n        {|((s, d), t)|};\n        possible_steps (finsert x e) s r l i = {|(d, t)|}; x = (a, b);\n        a = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> ffilter\n                          (\\<lambda>a.\n                              case a of\n                              (a, b) \\<Rightarrow>\n                                (case a of\n                                 (origin, dest) \\<Rightarrow>\n                                   \\<lambda>t.\norigin = s \\<and>\nLabel t = l \\<and>\nlength i = Arity t \\<and> apply_guards (Guards t) (join_ir i r))\n                                 b)\n                          (finsert x e) =\n                         {|((s, d), t)|}", "subgoal for aa _"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x |\\<notin>| e;\n     possible_steps e s r l i = {|(d, t)|} \\<Longrightarrow>\n     ffilter\n      (\\<lambda>a.\n          case a of\n          (a, b) \\<Rightarrow>\n            (case a of\n             (origin, dest) \\<Rightarrow>\n               \\<lambda>t.\n                  origin = s \\<and>\n                  Label t = l \\<and>\n                  length i = Arity t \\<and>\n                  apply_guards (Guards t) (join_ir i r))\n             b)\n      e =\n     {|((s, d), t)|};\n     possible_steps (finsert x e) s r l i = {|(d, t)|}; x = (a, b);\n     a = (aa, ba_)\\<rbrakk>\n    \\<Longrightarrow> ffilter\n                       (\\<lambda>a.\n                           case a of\n                           (a, b) \\<Rightarrow>\n                             (case a of\n                              (origin, dest) \\<Rightarrow>\n                                \\<lambda>t.\n                                   origin = s \\<and>\n                                   Label t = l \\<and>\n                                   length i = Arity t \\<and>\n                                   apply_guards (Guards t) (join_ir i r))\n                              b)\n                       (finsert x e) =\n                      {|((s, d), t)|}", "apply (simp add: possible_steps_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>((aa, ba_), b) |\\<notin>| e;\n     (\\<lambda>((origin, dest), t). (dest, t)) |`|\n     ffilter\n      (\\<lambda>((origin, dest), t).\n          origin = s \\<and>\n          Label t = l \\<and>\n          length i = Arity t \\<and> apply_guards (Guards t) (join_ir i r))\n      e =\n     {|(d, t)|} \\<Longrightarrow>\n     ffilter\n      (\\<lambda>a.\n          case a of\n          (a, b) \\<Rightarrow>\n            (case a of\n             (origin, dest) \\<Rightarrow>\n               \\<lambda>t.\n                  origin = s \\<and>\n                  Label t = l \\<and>\n                  length i = Arity t \\<and>\n                  apply_guards (Guards t) (join_ir i r))\n             b)\n      e =\n     {|((s, d), t)|};\n     (\\<lambda>((origin, dest), t). (dest, t)) |`|\n     ffilter\n      (\\<lambda>((origin, dest), t).\n          origin = s \\<and>\n          Label t = l \\<and>\n          length i = Arity t \\<and> apply_guards (Guards t) (join_ir i r))\n      (finsert ((aa, ba_), b) e) =\n     {|(d, t)|};\n     x = ((aa, ba_), b); a = (aa, ba_)\\<rbrakk>\n    \\<Longrightarrow> ffilter\n                       (\\<lambda>a.\n                           case a of\n                           (a, b) \\<Rightarrow>\n                             (case a of\n                              (origin, dest) \\<Rightarrow>\n                                \\<lambda>t.\n                                   origin = s \\<and>\n                                   Label t = l \\<and>\n                                   length i = Arity t \\<and>\n                                   apply_guards (Guards t) (join_ir i r))\n                              b)\n                       (finsert ((aa, ba_), b) e) =\n                      {|((s, d), t)|}", "apply (simp add: ffilter_finsert)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>((aa, ba_), b) |\\<notin>| e;\n     (\\<lambda>((origin, dest), t). (dest, t)) |`|\n     ffilter\n      (\\<lambda>((origin, dest), t).\n          origin = s \\<and>\n          Label t = l \\<and>\n          length i = Arity t \\<and> apply_guards (Guards t) (join_ir i r))\n      e =\n     {|(d, t)|} \\<Longrightarrow>\n     ffilter\n      (\\<lambda>a.\n          case a of\n          (a, b) \\<Rightarrow>\n            (case a of\n             (origin, dest) \\<Rightarrow>\n               \\<lambda>t.\n                  origin = s \\<and>\n                  Label t = l \\<and>\n                  length i = Arity t \\<and>\n                  apply_guards (Guards t) (join_ir i r))\n             b)\n      e =\n     {|((s, d), t)|};\n     (\\<lambda>((origin, dest), t). (dest, t)) |`|\n     (if aa = s \\<and>\n         Label b = l \\<and>\n         length i = Arity b \\<and> apply_guards (Guards b) (join_ir i r)\n      then finsert ((aa, ba_), b)\n            (ffilter\n              (\\<lambda>((origin, dest), t).\n                  origin = s \\<and>\n                  Label t = l \\<and>\n                  length i = Arity t \\<and>\n                  apply_guards (Guards t) (join_ir i r))\n              e)\n      else ffilter\n            (\\<lambda>((origin, dest), t).\n                origin = s \\<and>\n                Label t = l \\<and>\n                length i = Arity t \\<and>\n                apply_guards (Guards t) (join_ir i r))\n            e) =\n     {|(d, t)|};\n     x = ((aa, ba_), b); a = (aa, ba_)\\<rbrakk>\n    \\<Longrightarrow> (aa = s \\<and>\n                       Label b = l \\<and>\n                       length i = Arity b \\<and>\n                       apply_guards (Guards b)\n                        (join_ir i r) \\<longrightarrow>\n                       ba_ = d \\<and>\n                       b = t \\<and>\n                       ffilter\n                        (\\<lambda>((origin, dest), t).\n                            origin = s \\<and>\n                            Label t = l \\<and>\n                            Arity b = Arity t \\<and>\n                            apply_guards (Guards t) (join_ir i r))\n                        e |\\<subseteq>|\n                       {|((s, d), t)|}) \\<and>\n                      ((length i = Arity b \\<longrightarrow>\n                        Label b = l \\<longrightarrow>\n                        aa = s \\<longrightarrow>\n                        \\<not> apply_guards (Guards b)\n                                (join_ir i r)) \\<longrightarrow>\n                       ffilter\n                        (\\<lambda>((origin, dest), t).\n                            origin = s \\<and>\n                            Label t = l \\<and>\n                            length i = Arity t \\<and>\n                            apply_guards (Guards t) (join_ir i r))\n                        e =\n                       {|((s, d), t)|})", "apply (case_tac \"aa = s \\<and> Label b = l \\<and> length i = Arity b \\<and> apply_guards (Guards b) (join_ir i r)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>((aa, ba_), b) |\\<notin>| e;\n     (\\<lambda>((origin, dest), t). (dest, t)) |`|\n     ffilter\n      (\\<lambda>((origin, dest), t).\n          origin = s \\<and>\n          Label t = l \\<and>\n          length i = Arity t \\<and> apply_guards (Guards t) (join_ir i r))\n      e =\n     {|(d, t)|} \\<Longrightarrow>\n     ffilter\n      (\\<lambda>a.\n          case a of\n          (a, b) \\<Rightarrow>\n            (case a of\n             (origin, dest) \\<Rightarrow>\n               \\<lambda>t.\n                  origin = s \\<and>\n                  Label t = l \\<and>\n                  length i = Arity t \\<and>\n                  apply_guards (Guards t) (join_ir i r))\n             b)\n      e =\n     {|((s, d), t)|};\n     (\\<lambda>((origin, dest), t). (dest, t)) |`|\n     (if aa = s \\<and>\n         Label b = l \\<and>\n         length i = Arity b \\<and> apply_guards (Guards b) (join_ir i r)\n      then finsert ((aa, ba_), b)\n            (ffilter\n              (\\<lambda>((origin, dest), t).\n                  origin = s \\<and>\n                  Label t = l \\<and>\n                  length i = Arity t \\<and>\n                  apply_guards (Guards t) (join_ir i r))\n              e)\n      else ffilter\n            (\\<lambda>((origin, dest), t).\n                origin = s \\<and>\n                Label t = l \\<and>\n                length i = Arity t \\<and>\n                apply_guards (Guards t) (join_ir i r))\n            e) =\n     {|(d, t)|};\n     x = ((aa, ba_), b); a = (aa, ba_);\n     aa = s \\<and>\n     Label b = l \\<and>\n     length i = Arity b \\<and>\n     apply_guards (Guards b) (join_ir i r)\\<rbrakk>\n    \\<Longrightarrow> (aa = s \\<and>\n                       Label b = l \\<and>\n                       length i = Arity b \\<and>\n                       apply_guards (Guards b)\n                        (join_ir i r) \\<longrightarrow>\n                       ba_ = d \\<and>\n                       b = t \\<and>\n                       ffilter\n                        (\\<lambda>((origin, dest), t).\n                            origin = s \\<and>\n                            Label t = l \\<and>\n                            Arity b = Arity t \\<and>\n                            apply_guards (Guards t) (join_ir i r))\n                        e |\\<subseteq>|\n                       {|((s, d), t)|}) \\<and>\n                      ((length i = Arity b \\<longrightarrow>\n                        Label b = l \\<longrightarrow>\n                        aa = s \\<longrightarrow>\n                        \\<not> apply_guards (Guards b)\n                                (join_ir i r)) \\<longrightarrow>\n                       ffilter\n                        (\\<lambda>((origin, dest), t).\n                            origin = s \\<and>\n                            Label t = l \\<and>\n                            length i = Arity t \\<and>\n                            apply_guards (Guards t) (join_ir i r))\n                        e =\n                       {|((s, d), t)|})\n 2. \\<lbrakk>((aa, ba_), b) |\\<notin>| e;\n     (\\<lambda>((origin, dest), t). (dest, t)) |`|\n     ffilter\n      (\\<lambda>((origin, dest), t).\n          origin = s \\<and>\n          Label t = l \\<and>\n          length i = Arity t \\<and> apply_guards (Guards t) (join_ir i r))\n      e =\n     {|(d, t)|} \\<Longrightarrow>\n     ffilter\n      (\\<lambda>a.\n          case a of\n          (a, b) \\<Rightarrow>\n            (case a of\n             (origin, dest) \\<Rightarrow>\n               \\<lambda>t.\n                  origin = s \\<and>\n                  Label t = l \\<and>\n                  length i = Arity t \\<and>\n                  apply_guards (Guards t) (join_ir i r))\n             b)\n      e =\n     {|((s, d), t)|};\n     (\\<lambda>((origin, dest), t). (dest, t)) |`|\n     (if aa = s \\<and>\n         Label b = l \\<and>\n         length i = Arity b \\<and> apply_guards (Guards b) (join_ir i r)\n      then finsert ((aa, ba_), b)\n            (ffilter\n              (\\<lambda>((origin, dest), t).\n                  origin = s \\<and>\n                  Label t = l \\<and>\n                  length i = Arity t \\<and>\n                  apply_guards (Guards t) (join_ir i r))\n              e)\n      else ffilter\n            (\\<lambda>((origin, dest), t).\n                origin = s \\<and>\n                Label t = l \\<and>\n                length i = Arity t \\<and>\n                apply_guards (Guards t) (join_ir i r))\n            e) =\n     {|(d, t)|};\n     x = ((aa, ba_), b); a = (aa, ba_);\n     \\<not> (aa = s \\<and>\n             Label b = l \\<and>\n             length i = Arity b \\<and>\n             apply_guards (Guards b) (join_ir i r))\\<rbrakk>\n    \\<Longrightarrow> (aa = s \\<and>\n                       Label b = l \\<and>\n                       length i = Arity b \\<and>\n                       apply_guards (Guards b)\n                        (join_ir i r) \\<longrightarrow>\n                       ba_ = d \\<and>\n                       b = t \\<and>\n                       ffilter\n                        (\\<lambda>((origin, dest), t).\n                            origin = s \\<and>\n                            Label t = l \\<and>\n                            Arity b = Arity t \\<and>\n                            apply_guards (Guards t) (join_ir i r))\n                        e |\\<subseteq>|\n                       {|((s, d), t)|}) \\<and>\n                      ((length i = Arity b \\<longrightarrow>\n                        Label b = l \\<longrightarrow>\n                        aa = s \\<longrightarrow>\n                        \\<not> apply_guards (Guards b)\n                                (join_ir i r)) \\<longrightarrow>\n                       ffilter\n                        (\\<lambda>((origin, dest), t).\n                            origin = s \\<and>\n                            Label t = l \\<and>\n                            length i = Arity t \\<and>\n                            apply_guards (Guards t) (join_ir i r))\n                        e =\n                       {|((s, d), t)|})", "by auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  ffilter\n   (\\<lambda>a.\n       case a of\n       (a, b) \\<Rightarrow>\n         (case a of\n          (origin, dest) \\<Rightarrow>\n            \\<lambda>t.\n               origin = s \\<and>\n               Label t = l \\<and>\n               length i = Arity t \\<and>\n               apply_guards (Guards t) (join_ir i r))\n          b)\n   (finsert x e) =\n  {|((s, d), t)|}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma possible_steps_alt: \"(possible_steps e s r l i = {|(d, t)|}) = (ffilter\n     (\\<lambda>((origin, dest), t). origin = s \\<and> Label t = l \\<and> length i = Arity t \\<and> apply_guards (Guards t) (join_ir i r))\n     e = {|((s, d), t)|})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (possible_steps e s r l i = {|(d, t)|}) =\n    (ffilter\n      (\\<lambda>((origin, dest), t).\n          origin = s \\<and>\n          Label t = l \\<and>\n          length i = Arity t \\<and> apply_guards (Guards t) (join_ir i r))\n      e =\n     {|((s, d), t)|})", "apply standard"], ["proof (prove)\ngoal (2 subgoals):\n 1. possible_steps e s r l i = {|(d, t)|} \\<Longrightarrow>\n    ffilter\n     (\\<lambda>((origin, dest), t).\n         origin = s \\<and>\n         Label t = l \\<and>\n         length i = Arity t \\<and> apply_guards (Guards t) (join_ir i r))\n     e =\n    {|((s, d), t)|}\n 2. ffilter\n     (\\<lambda>((origin, dest), t).\n         origin = s \\<and>\n         Label t = l \\<and>\n         length i = Arity t \\<and> apply_guards (Guards t) (join_ir i r))\n     e =\n    {|((s, d), t)|} \\<Longrightarrow>\n    possible_steps e s r l i = {|(d, t)|}", "apply (simp add: possible_steps_alt_aux)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ffilter\n     (\\<lambda>((origin, dest), t).\n         origin = s \\<and>\n         Label t = l \\<and>\n         length i = Arity t \\<and> apply_guards (Guards t) (join_ir i r))\n     e =\n    {|((s, d), t)|} \\<Longrightarrow>\n    possible_steps e s r l i = {|(d, t)|}", "by (simp add: possible_steps_def)"], ["", "lemma possible_steps_alt3: \"(possible_steps e s r l i = {|(d, t)|}) = (ffilter\n     (\\<lambda>((origin, dest), t). origin = s \\<and> Label t = l \\<and> can_take_transition t i r)\n     e = {|((s, d), t)|})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (possible_steps e s r l i = {|(d, t)|}) =\n    (ffilter\n      (\\<lambda>((origin, dest), t).\n          origin = s \\<and> Label t = l \\<and> can_take_transition t i r)\n      e =\n     {|((s, d), t)|})", "apply standard"], ["proof (prove)\ngoal (2 subgoals):\n 1. possible_steps e s r l i = {|(d, t)|} \\<Longrightarrow>\n    ffilter\n     (\\<lambda>((origin, dest), t).\n         origin = s \\<and> Label t = l \\<and> can_take_transition t i r)\n     e =\n    {|((s, d), t)|}\n 2. ffilter\n     (\\<lambda>((origin, dest), t).\n         origin = s \\<and> Label t = l \\<and> can_take_transition t i r)\n     e =\n    {|((s, d), t)|} \\<Longrightarrow>\n    possible_steps e s r l i = {|(d, t)|}", "apply (simp add: possible_steps_alt_aux can_take)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ffilter\n     (\\<lambda>((origin, dest), t).\n         origin = s \\<and> Label t = l \\<and> can_take_transition t i r)\n     e =\n    {|((s, d), t)|} \\<Longrightarrow>\n    possible_steps e s r l i = {|(d, t)|}", "by (simp add: possible_steps_def can_take)"], ["", "lemma possible_steps_alt_atom: \"(possible_steps e s r l i = {|dt|}) = (ffilter\n     (\\<lambda>((origin, dest), t). origin = s \\<and> Label t = l \\<and> can_take_transition t i r)\n     e = {|((s, fst dt), snd dt)|})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (possible_steps e s r l i = {|dt|}) =\n    (ffilter\n      (\\<lambda>((origin, dest), t).\n          origin = s \\<and> Label t = l \\<and> can_take_transition t i r)\n      e =\n     {|((s, fst dt), snd dt)|})", "apply (cases dt)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       dt = (a, b) \\<Longrightarrow>\n       (possible_steps e s r l i = {|dt|}) =\n       (ffilter\n         (\\<lambda>((origin, dest), t).\n             origin = s \\<and> Label t = l \\<and> can_take_transition t i r)\n         e =\n        {|((s, fst dt), snd dt)|})", "by (simp add: possible_steps_alt can_take_transition_def can_take_def)"], ["", "lemma possible_steps_alt2: \"(possible_steps e s r l i = {|(d, t)|}) = (\n     (ffilter (\\<lambda>((origin, dest), t). Label t = l \\<and> length i = Arity t \\<and> apply_guards (Guards t) (join_ir i r)) (ffilter (\\<lambda>((origin, dest), t). origin = s) e) = {|((s, d), t)|}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (possible_steps e s r l i = {|(d, t)|}) =\n    (ffilter\n      (\\<lambda>((origin, dest), t).\n          Label t = l \\<and>\n          length i = Arity t \\<and> apply_guards (Guards t) (join_ir i r))\n      (ffilter (\\<lambda>((origin, dest), t). origin = s) e) =\n     {|((s, d), t)|})", "apply (simp add: possible_steps_alt)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (ffilter\n      (\\<lambda>((origin, dest), t).\n          origin = s \\<and>\n          Label t = l \\<and>\n          length i = Arity t \\<and> apply_guards (Guards t) (join_ir i r))\n      e =\n     {|((s, d), t)|}) =\n    (ffilter\n      (\\<lambda>((origin, dest), t).\n          Label t = l \\<and>\n          length i = Arity t \\<and> apply_guards (Guards t) (join_ir i r))\n      (ffilter (\\<lambda>((origin, dest), t). origin = s) e) =\n     {|((s, d), t)|})", "apply (simp only: filter_filter)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (ffilter\n      (\\<lambda>((origin, dest), t).\n          origin = s \\<and>\n          Label t = l \\<and>\n          length i = Arity t \\<and> apply_guards (Guards t) (join_ir i r))\n      e =\n     {|((s, d), t)|}) =\n    (ffilter\n      (\\<lambda>x.\n          (case x of\n           (x, xa) \\<Rightarrow>\n             (case x of (origin, dest) \\<Rightarrow> \\<lambda>t. origin = s)\n              xa) \\<and>\n          (case x of\n           (x, xa) \\<Rightarrow>\n             (case x of\n              (origin, dest) \\<Rightarrow>\n                \\<lambda>t.\n                   Label t = l \\<and>\n                   length i = Arity t \\<and>\n                   apply_guards (Guards t) (join_ir i r))\n              xa))\n      e =\n     {|((s, d), t)|})", "apply (rule arg_cong [of \"(\\<lambda>((origin, dest), t). origin = s \\<and> Label t = l \\<and> length i = Arity t \\<and> apply_guards (Guards t) (join_ir i r))\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>((origin, dest), t).\n        origin = s \\<and>\n        Label t = l \\<and>\n        length i = Arity t \\<and> apply_guards (Guards t) (join_ir i r)) =\n    (\\<lambda>a.\n        (case a of\n         (a, b) \\<Rightarrow>\n           (case a of (origin, dest) \\<Rightarrow> \\<lambda>t. origin = s)\n            b) \\<and>\n        (case a of\n         (a, b) \\<Rightarrow>\n           (case a of\n            (origin, dest) \\<Rightarrow>\n              \\<lambda>t.\n                 Label t = l \\<and>\n                 length i = Arity t \\<and>\n                 apply_guards (Guards t) (join_ir i r))\n            b))", "by (rule ext, auto)"], ["", "lemma possible_steps_single_out:\n\"ffilter (\\<lambda>((origin, dest), t). origin = s) e = {|((s, d), t)|} \\<Longrightarrow>\nLabel t = l \\<and> length i = Arity t \\<and> apply_guards (Guards t) (join_ir i r) \\<Longrightarrow>\npossible_steps e s r l i = {|(d, t)|}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ffilter (\\<lambda>((origin, dest), t). origin = s) e =\n             {|((s, d), t)|};\n     Label t = l \\<and>\n     length i = Arity t \\<and>\n     apply_guards (Guards t) (join_ir i r)\\<rbrakk>\n    \\<Longrightarrow> possible_steps e s r l i = {|(d, t)|}", "apply (simp add: possible_steps_alt2 Abs_ffilter)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>{ea \\<in> fset e.\n              case ea of\n              (x, xa) \\<Rightarrow>\n                (case x of\n                 (origin, dest) \\<Rightarrow> \\<lambda>t. origin = s)\n                 xa} =\n             {((s, d), t)};\n     Label t = l \\<and>\n     length i = Arity t \\<and>\n     apply_guards (Guards t) (join_ir i r)\\<rbrakk>\n    \\<Longrightarrow> {ea.\n                       (case ea of\n                        (x, xa) \\<Rightarrow>\n                          (case x of\n                           (origin, dest) \\<Rightarrow>\n                             \\<lambda>t. origin = s)\n                           xa) \\<and>\n                       ea \\<in> fset e \\<and>\n                       (case ea of\n                        (x, xa) \\<Rightarrow>\n                          (case x of\n                           (origin, dest) \\<Rightarrow>\n                             \\<lambda>ta.\n                                Label ta = l \\<and>\n                                Arity t = Arity ta \\<and>\n                                apply_guards (Guards ta) (join_ir i r))\n                           xa)} =\n                      {((s, d), t)}", "by blast"], ["", "lemma possible_steps_singleton: \"(possible_steps e s r l i = {|(d, t)|}) =\n    ({((origin, dest), t) \\<in> fset e. origin = s \\<and> Label t = l \\<and> length i = Arity t \\<and> apply_guards (Guards t) (join_ir i r)} = {((s, d), t)})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (possible_steps e s r l i = {|(d, t)|}) =\n    ({((origin, dest), t).\n      ((origin, dest), t) \\<in> fset e \\<and>\n      origin = s \\<and>\n      Label t = l \\<and>\n      length i = Arity t \\<and> apply_guards (Guards t) (join_ir i r)} =\n     {((s, d), t)})", "apply (simp add: possible_steps_alt Abs_ffilter Set.filter_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ({ea \\<in> fset e.\n      case ea of\n      (x, xa) \\<Rightarrow>\n        (case x of\n         (origin, dest) \\<Rightarrow>\n           \\<lambda>t.\n              origin = s \\<and>\n              Label t = l \\<and>\n              length i = Arity t \\<and>\n              apply_guards (Guards t) (join_ir i r))\n         xa} =\n     {((s, d), t)}) =\n    ({((origin, dest), t).\n      ((origin, dest), t) \\<in> fset e \\<and>\n      origin = s \\<and>\n      Label t = l \\<and>\n      length i = Arity t \\<and> apply_guards (Guards t) (join_ir i r)} =\n     {((s, d), t)})", "by fast"], ["", "lemma possible_steps_apply_guards:\n  \"possible_steps e s r l i = {|(s', t)|} \\<Longrightarrow>\n   apply_guards (Guards t) (join_ir i r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. possible_steps e s r l i = {|(s', t)|} \\<Longrightarrow>\n    apply_guards (Guards t) (join_ir i r)", "apply (simp add: possible_steps_singleton)"], ["proof (prove)\ngoal (1 subgoal):\n 1. {((origin, dest), t).\n     ((origin, dest), t) \\<in> fset e \\<and>\n     origin = s \\<and>\n     Label t = l \\<and>\n     length i = Arity t \\<and> apply_guards (Guards t) (join_ir i r)} =\n    {((s, s'), t)} \\<Longrightarrow>\n    apply_guards (Guards t) (join_ir i r)", "by auto"], ["", "lemma possible_steps_empty:\n  \"(possible_steps e s r l i = {||}) = (\\<forall>((origin, dest), t) \\<in> fset e. origin \\<noteq> s \\<or> Label t \\<noteq> l \\<or> \\<not> can_take_transition t i r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (possible_steps e s r l i = {||}) =\n    (\\<forall>((origin, dest), t)\\<in>fset e.\n        origin \\<noteq> s \\<or>\n        Label t \\<noteq> l \\<or> \\<not> can_take_transition t i r)", "apply (simp add: can_take_transition_def can_take_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (possible_steps e s r l i = {||}) =\n    (\\<forall>x\\<in>fset e.\n        case x of\n        (x, xa) \\<Rightarrow>\n          (case x of\n           (origin, dest) \\<Rightarrow>\n             \\<lambda>t.\n                length i = Arity t \\<longrightarrow>\n                Label t = l \\<longrightarrow>\n                origin = s \\<longrightarrow>\n                \\<not> apply_guards (Guards t) (join_ir i r))\n           xa)", "apply (simp add: possible_steps_def Abs_ffilter Set.filter_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>b ba.\n        ((s, b), ba) \\<in> fset e \\<longrightarrow>\n        length i = Arity ba \\<longrightarrow>\n        Label ba = l \\<longrightarrow>\n        \\<not> apply_guards (Guards ba) (join_ir i r)) =\n    (\\<forall>x\\<in>fset e.\n        case x of\n        (x, xa) \\<Rightarrow>\n          (case x of\n           (origin, dest) \\<Rightarrow>\n             \\<lambda>t.\n                length i = Arity t \\<longrightarrow>\n                Label t = l \\<longrightarrow>\n                origin = s \\<longrightarrow>\n                \\<not> apply_guards (Guards t) (join_ir i r))\n           xa)", "by auto"], ["", "lemma singleton_dest:\n  assumes \"fis_singleton (possible_steps e s r aa b)\"\n      and \"fthe_elem (possible_steps e s r aa b) = (baa, aba)\"\n    shows \"((s, baa), aba) |\\<in>| e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((s, baa), aba) |\\<in>| e", "using assms"], ["proof (prove)\nusing this:\n  fis_singleton (possible_steps e s r aa b)\n  fthe_elem (possible_steps e s r aa b) = (baa, aba)\n\ngoal (1 subgoal):\n 1. ((s, baa), aba) |\\<in>| e", "apply (simp add: fis_singleton_fthe_elem)"], ["proof (prove)\ngoal (1 subgoal):\n 1. possible_steps e s r aa b = {|(baa, aba)|} \\<Longrightarrow>\n    ((s, baa), aba) |\\<in>| e", "using possible_steps_alt_aux"], ["proof (prove)\nusing this:\n  possible_steps ?e ?s ?r ?l ?i = {|(?d, ?t)|} \\<Longrightarrow>\n  ffilter\n   (\\<lambda>((origin, dest), t).\n       origin = ?s \\<and>\n       Label t = ?l \\<and>\n       length ?i = Arity t \\<and> apply_guards (Guards t) (join_ir ?i ?r))\n   ?e =\n  {|((?s, ?d), ?t)|}\n\ngoal (1 subgoal):\n 1. possible_steps e s r aa b = {|(baa, aba)|} \\<Longrightarrow>\n    ((s, baa), aba) |\\<in>| e", "by force"], ["", "lemma no_outgoing_transitions:\n\"ffilter (\\<lambda>((s', _), _). s = s') e = {||} \\<Longrightarrow>\npossible_steps e s r l i = {||}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ffilter (\\<lambda>((s', uu_), uu_). s = s') e = {||} \\<Longrightarrow>\n    possible_steps e s r l i = {||}", "apply (simp add: possible_steps_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ffilter (\\<lambda>((s', uu_), uu_). s = s') e = {||} \\<Longrightarrow>\n    ffilter\n     (\\<lambda>((origin, dest), t).\n         origin = s \\<and>\n         Label t = l \\<and>\n         length i = Arity t \\<and> apply_guards (Guards t) (join_ir i r))\n     e =\n    {||}", "by auto"], ["", "lemma ffilter_split: \"ffilter (\\<lambda>((origin, dest), t). origin = s \\<and> Label t = l \\<and> length i = Arity t \\<and> apply_guards (Guards t) (join_ir i r)) e =\n                      ffilter (\\<lambda>((origin, dest), t). Label t = l \\<and> length i = Arity t \\<and> apply_guards (Guards t) (join_ir i r)) (ffilter (\\<lambda>((origin, dest), t). origin = s) e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ffilter\n     (\\<lambda>((origin, dest), t).\n         origin = s \\<and>\n         Label t = l \\<and>\n         length i = Arity t \\<and> apply_guards (Guards t) (join_ir i r))\n     e =\n    ffilter\n     (\\<lambda>((origin, dest), t).\n         Label t = l \\<and>\n         length i = Arity t \\<and> apply_guards (Guards t) (join_ir i r))\n     (ffilter (\\<lambda>((origin, dest), t). origin = s) e)", "by auto"], ["", "lemma one_outgoing_transition:\n  defines \"outgoing s \\<equiv> (\\<lambda>((origin, dest), t). origin = s)\"\n  assumes prem: \"size (ffilter (outgoing s) e) = 1\"\n  shows \"size (possible_steps e s r l i) \\<le> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. size (possible_steps e s r l i) \\<le> 1", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. size (possible_steps e s r l i) \\<le> 1", "have less_eq_1: \"\\<And>x::nat. (x \\<le> 1) = (x = 1 \\<or> x = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. (x \\<le> 1) = (x = 1 \\<or> x = 0)", "by auto"], ["proof (state)\nthis:\n  (?x \\<le> 1) = (?x = 1 \\<or> ?x = 0)\n\ngoal (1 subgoal):\n 1. size (possible_steps e s r l i) \\<le> 1", "have size_empty: \"\\<And>f. (size f = 0) = (f = {||})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f. (size f = 0) = (f = {||})", "subgoal for f"], ["proof (prove)\ngoal (1 subgoal):\n 1. (size f = 0) = (f = {||})", "by (induct f, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (size ?f = 0) = (?f = {||})\n\ngoal (1 subgoal):\n 1. size (possible_steps e s r l i) \\<le> 1", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. size (possible_steps e s r l i) \\<le> 1", "using prem"], ["proof (prove)\nusing this:\n  size (ffilter (outgoing s) e) = 1\n\ngoal (1 subgoal):\n 1. size (possible_steps e s r l i) \\<le> 1", "apply (simp only: possible_steps_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. size (ffilter (outgoing s) e) = 1 \\<Longrightarrow>\n    size\n     ((\\<lambda>((origin, dest), t). (dest, t)) |`|\n      ffilter\n       (\\<lambda>((origin, dest), t).\n           origin = s \\<and>\n           Label t = l \\<and>\n           length i = Arity t \\<and> apply_guards (Guards t) (join_ir i r))\n       e)\n    \\<le> 1", "apply (rule fimage_size_le)"], ["proof (prove)\ngoal (1 subgoal):\n 1. size (ffilter (outgoing s) e) = 1 \\<Longrightarrow>\n    size\n     (ffilter\n       (\\<lambda>((origin, dest), t).\n           origin = s \\<and>\n           Label t = l \\<and>\n           length i = Arity t \\<and> apply_guards (Guards t) (join_ir i r))\n       e)\n    \\<le> 1", "apply (simp only: ffilter_split outgoing_def[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. size (ffilter (outgoing s) e) = 1 \\<Longrightarrow>\n    size\n     (ffilter\n       (\\<lambda>((origin, dest), t).\n           Label t = l \\<and>\n           length i = Arity t \\<and> apply_guards (Guards t) (join_ir i r))\n       (ffilter (outgoing s) e))\n    \\<le> 1", "by (metis (no_types, lifting) size_ffilter)"], ["proof (state)\nthis:\n  size (possible_steps e s r l i) \\<le> 1\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection\\<open>Choice\\<close>"], ["", "text\\<open>Here we define the \\texttt{choice} operator which determines whether or not two transitions are\nnondeterministic.\\<close>"], ["", "definition choice :: \"transition \\<Rightarrow> transition \\<Rightarrow> bool\" where\n  \"choice t t' = (\\<exists> i r. apply_guards (Guards t) (join_ir i r) \\<and> apply_guards (Guards t') (join_ir i r))\""], ["", "definition choice_alt :: \"transition \\<Rightarrow> transition \\<Rightarrow> bool\" where\n  \"choice_alt t t' = (\\<exists> i r. apply_guards (Guards t@Guards t') (join_ir i r))\""], ["", "lemma choice_alt: \"choice t t' = choice_alt t t'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. choice t t' = choice_alt t t'", "by (simp add: choice_def choice_alt_def apply_guards_append)"], ["", "lemma choice_symmetry: \"choice x y = choice y x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. choice x y = choice y x", "using choice_def"], ["proof (prove)\nusing this:\n  choice ?t ?t' =\n  (\\<exists>i r.\n      apply_guards (Guards ?t) (join_ir i r) \\<and>\n      apply_guards (Guards ?t') (join_ir i r))\n\ngoal (1 subgoal):\n 1. choice x y = choice y x", "by auto"], ["", "definition deterministic :: \"transition_matrix \\<Rightarrow> bool\" where\n  \"deterministic e = (\\<forall>s r l i. size (possible_steps e s r l i) \\<le> 1)\""], ["", "lemma deterministic_alt_aux: \"size (possible_steps e s r l i) \\<le> 1 =(\n        possible_steps e s r l i = {||} \\<or>\n        (\\<exists>s' t.\n            ffilter\n             (\\<lambda>((origin, dest), t). origin = s \\<and> Label t = l \\<and> length i = Arity t \\<and> apply_guards (Guards t) (join_ir i r)) e =\n            {|((s, s'), t)|}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (size (possible_steps e s r l i) \\<le> 1) =\n    (possible_steps e s r l i = {||} \\<or>\n     (\\<exists>s' t.\n         ffilter\n          (\\<lambda>((origin, dest), t).\n              origin = s \\<and>\n              Label t = l \\<and>\n              length i = Arity t \\<and>\n              apply_guards (Guards t) (join_ir i r))\n          e =\n         {|((s, s'), t)|}))", "apply (case_tac \"size (possible_steps e s r l i) = 0\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. size (possible_steps e s r l i) = 0 \\<Longrightarrow>\n    (size (possible_steps e s r l i) \\<le> 1) =\n    (possible_steps e s r l i = {||} \\<or>\n     (\\<exists>s' t.\n         ffilter\n          (\\<lambda>((origin, dest), t).\n              origin = s \\<and>\n              Label t = l \\<and>\n              length i = Arity t \\<and>\n              apply_guards (Guards t) (join_ir i r))\n          e =\n         {|((s, s'), t)|}))\n 2. size (possible_steps e s r l i) \\<noteq> 0 \\<Longrightarrow>\n    (size (possible_steps e s r l i) \\<le> 1) =\n    (possible_steps e s r l i = {||} \\<or>\n     (\\<exists>s' t.\n         ffilter\n          (\\<lambda>((origin, dest), t).\n              origin = s \\<and>\n              Label t = l \\<and>\n              length i = Arity t \\<and>\n              apply_guards (Guards t) (join_ir i r))\n          e =\n         {|((s, s'), t)|}))", "apply (simp add: fset_equiv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. size (possible_steps e s r l i) \\<noteq> 0 \\<Longrightarrow>\n    (size (possible_steps e s r l i) \\<le> 1) =\n    (possible_steps e s r l i = {||} \\<or>\n     (\\<exists>s' t.\n         ffilter\n          (\\<lambda>((origin, dest), t).\n              origin = s \\<and>\n              Label t = l \\<and>\n              length i = Arity t \\<and>\n              apply_guards (Guards t) (join_ir i r))\n          e =\n         {|((s, s'), t)|}))", "apply (case_tac \"possible_steps e s r l i = {||}\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>size (possible_steps e s r l i) \\<noteq> 0;\n     possible_steps e s r l i = {||}\\<rbrakk>\n    \\<Longrightarrow> (size (possible_steps e s r l i) \\<le> 1) =\n                      (possible_steps e s r l i = {||} \\<or>\n                       (\\<exists>s' t.\n                           ffilter\n                            (\\<lambda>((origin, dest), t).\n                                origin = s \\<and>\n                                Label t = l \\<and>\n                                length i = Arity t \\<and>\n                                apply_guards (Guards t) (join_ir i r))\n                            e =\n                           {|((s, s'), t)|}))\n 2. \\<lbrakk>size (possible_steps e s r l i) \\<noteq> 0;\n     possible_steps e s r l i \\<noteq> {||}\\<rbrakk>\n    \\<Longrightarrow> (size (possible_steps e s r l i) \\<le> 1) =\n                      (possible_steps e s r l i = {||} \\<or>\n                       (\\<exists>s' t.\n                           ffilter\n                            (\\<lambda>((origin, dest), t).\n                                origin = s \\<and>\n                                Label t = l \\<and>\n                                length i = Arity t \\<and>\n                                apply_guards (Guards t) (join_ir i r))\n                            e =\n                           {|((s, s'), t)|}))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>size (possible_steps e s r l i) \\<noteq> 0;\n     possible_steps e s r l i \\<noteq> {||}\\<rbrakk>\n    \\<Longrightarrow> (size (possible_steps e s r l i) \\<le> 1) =\n                      (possible_steps e s r l i = {||} \\<or>\n                       (\\<exists>s' t.\n                           ffilter\n                            (\\<lambda>((origin, dest), t).\n                                origin = s \\<and>\n                                Label t = l \\<and>\n                                length i = Arity t \\<and>\n                                apply_guards (Guards t) (join_ir i r))\n                            e =\n                           {|((s, s'), t)|}))", "apply (simp only: possible_steps_alt[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>size (possible_steps e s r l i) \\<noteq> 0;\n     possible_steps e s r l i \\<noteq> {||}\\<rbrakk>\n    \\<Longrightarrow> (size (possible_steps e s r l i) \\<le> 1) =\n                      (False \\<or>\n                       (\\<exists>s' t.\n                           possible_steps e s r l i = {|(s', t)|}))", "by (metis le_neq_implies_less le_numeral_extra(4) less_one prod.collapse size_fsingleton)"], ["", "lemma deterministic_alt: \"deterministic e = (\n  \\<forall>s r l i.\n    possible_steps e s r l i = {||} \\<or>\n    (\\<exists>s' t. ffilter (\\<lambda>((origin, dest), t). origin = s \\<and> (Label t) = l \\<and> (length i) = (Arity t) \\<and> apply_guards (Guards t) (join_ir i r)) e = {|((s, s'), t)|})\n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. deterministic e =\n    (\\<forall>s r l i.\n        possible_steps e s r l i = {||} \\<or>\n        (\\<exists>s' t.\n            ffilter\n             (\\<lambda>((origin, dest), t).\n                 origin = s \\<and>\n                 Label t = l \\<and>\n                 length i = Arity t \\<and>\n                 apply_guards (Guards t) (join_ir i r))\n             e =\n            {|((s, s'), t)|}))", "using deterministic_alt_aux"], ["proof (prove)\nusing this:\n  (size (possible_steps ?e ?s ?r ?l ?i) \\<le> 1) =\n  (possible_steps ?e ?s ?r ?l ?i = {||} \\<or>\n   (\\<exists>s' t.\n       ffilter\n        (\\<lambda>((origin, dest), t).\n            origin = ?s \\<and>\n            Label t = ?l \\<and>\n            length ?i = Arity t \\<and>\n            apply_guards (Guards t) (join_ir ?i ?r))\n        ?e =\n       {|((?s, s'), t)|}))\n\ngoal (1 subgoal):\n 1. deterministic e =\n    (\\<forall>s r l i.\n        possible_steps e s r l i = {||} \\<or>\n        (\\<exists>s' t.\n            ffilter\n             (\\<lambda>((origin, dest), t).\n                 origin = s \\<and>\n                 Label t = l \\<and>\n                 length i = Arity t \\<and>\n                 apply_guards (Guards t) (join_ir i r))\n             e =\n            {|((s, s'), t)|}))", "by (simp add: deterministic_def)"], ["", "lemma size_le_1: \"size f \\<le> 1 = (f = {||} \\<or> (\\<exists>e. f = {|e|}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (size f \\<le> 1) = (f = {||} \\<or> (\\<exists>e. f = {|e|}))", "apply standard"], ["proof (prove)\ngoal (2 subgoals):\n 1. size f \\<le> 1 \\<Longrightarrow> f = {||} \\<or> (\\<exists>e. f = {|e|})\n 2. f = {||} \\<or> (\\<exists>e. f = {|e|}) \\<Longrightarrow> size f \\<le> 1", "apply (metis bot.not_eq_extremum gr_implies_not0 le_neq_implies_less less_one size_fsingleton size_fsubset)"], ["proof (prove)\ngoal (1 subgoal):\n 1. f = {||} \\<or> (\\<exists>e. f = {|e|}) \\<Longrightarrow> size f \\<le> 1", "by auto"], ["", "lemma ffilter_empty_if: \"\\<forall>x |\\<in>| xs. \\<not> P x \\<Longrightarrow> ffilter P xs = {||}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x|\\<in>|xs. \\<not> P x \\<Longrightarrow> ffilter P xs = {||}", "by auto"], ["", "lemma empty_ffilter: \"ffilter P xs = {||} = (\\<forall>x |\\<in>| xs. \\<not> P x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ffilter P xs = {||}) = (\\<forall>x|\\<in>|xs. \\<not> P x)", "by auto"], ["", "lemma all_states_deterministic:\n\"(\\<forall>s l i r.\n  ffilter (\\<lambda>((origin, dest), t). origin = s \\<and> (Label t) = l \\<and> can_take_transition t i r) e = {||} \\<or>\n  (\\<exists>x. ffilter (\\<lambda>((origin, dest), t). origin = s \\<and> (Label t) = l \\<and> can_take_transition t i r) e = {|x|})\n) \\<Longrightarrow> deterministic e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>s l i r.\n       ffilter\n        (\\<lambda>((origin, dest), t).\n            origin = s \\<and> Label t = l \\<and> can_take_transition t i r)\n        e =\n       {||} \\<or>\n       (\\<exists>x.\n           ffilter\n            (\\<lambda>((origin, dest), t).\n                origin = s \\<and>\n                Label t = l \\<and> can_take_transition t i r)\n            e =\n           {|x|}) \\<Longrightarrow>\n    deterministic e", "unfolding deterministic_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>s l i r.\n       ffilter\n        (\\<lambda>((origin, dest), t).\n            origin = s \\<and> Label t = l \\<and> can_take_transition t i r)\n        e =\n       {||} \\<or>\n       (\\<exists>x.\n           ffilter\n            (\\<lambda>((origin, dest), t).\n                origin = s \\<and>\n                Label t = l \\<and> can_take_transition t i r)\n            e =\n           {|x|}) \\<Longrightarrow>\n    \\<forall>s r l i. size (possible_steps e s r l i) \\<le> 1", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s r l i.\n       \\<forall>s l i r.\n          ffilter\n           (\\<lambda>((origin, dest), t).\n               origin = s \\<and>\n               Label t = l \\<and> can_take_transition t i r)\n           e =\n          {||} \\<or>\n          (\\<exists>x.\n              ffilter\n               (\\<lambda>((origin, dest), t).\n                   origin = s \\<and>\n                   Label t = l \\<and> can_take_transition t i r)\n               e =\n              {|x|}) \\<Longrightarrow>\n       size (possible_steps e s r l i) \\<le> 1", "subgoal for s r l i"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>s l i r.\n       ffilter\n        (\\<lambda>((origin, dest), t).\n            origin = s \\<and> Label t = l \\<and> can_take_transition t i r)\n        e =\n       {||} \\<or>\n       (\\<exists>x.\n           ffilter\n            (\\<lambda>((origin, dest), t).\n                origin = s \\<and>\n                Label t = l \\<and> can_take_transition t i r)\n            e =\n           {|x|}) \\<Longrightarrow>\n    size (possible_steps e s r l i) \\<le> 1", "apply (erule_tac x=s in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>l i r.\n       ffilter\n        (\\<lambda>((origin, dest), t).\n            origin = s \\<and> Label t = l \\<and> can_take_transition t i r)\n        e =\n       {||} \\<or>\n       (\\<exists>x.\n           ffilter\n            (\\<lambda>((origin, dest), t).\n                origin = s \\<and>\n                Label t = l \\<and> can_take_transition t i r)\n            e =\n           {|x|}) \\<Longrightarrow>\n    size (possible_steps e s r l i) \\<le> 1", "apply (erule_tac x=l in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i r.\n       ffilter\n        (\\<lambda>((origin, dest), t).\n            origin = s \\<and> Label t = l \\<and> can_take_transition t i r)\n        e =\n       {||} \\<or>\n       (\\<exists>x.\n           ffilter\n            (\\<lambda>((origin, dest), t).\n                origin = s \\<and>\n                Label t = l \\<and> can_take_transition t i r)\n            e =\n           {|x|}) \\<Longrightarrow>\n    size (possible_steps e s r l i) \\<le> 1", "apply (erule_tac x=i in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>r.\n       ffilter\n        (\\<lambda>((origin, dest), t).\n            origin = s \\<and> Label t = l \\<and> can_take_transition t i r)\n        e =\n       {||} \\<or>\n       (\\<exists>x.\n           ffilter\n            (\\<lambda>((origin, dest), t).\n                origin = s \\<and>\n                Label t = l \\<and> can_take_transition t i r)\n            e =\n           {|x|}) \\<Longrightarrow>\n    size (possible_steps e s r l i) \\<le> 1", "apply (erule_tac x=r in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ffilter\n     (\\<lambda>((origin, dest), t).\n         origin = s \\<and> Label t = l \\<and> can_take_transition t i r)\n     e =\n    {||} \\<or>\n    (\\<exists>x.\n        ffilter\n         (\\<lambda>((origin, dest), t).\n             origin = s \\<and> Label t = l \\<and> can_take_transition t i r)\n         e =\n        {|x|}) \\<Longrightarrow>\n    size (possible_steps e s r l i) \\<le> 1", "apply (simp only: size_le_1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ffilter\n     (\\<lambda>((origin, dest), t).\n         origin = s \\<and> Label t = l \\<and> can_take_transition t i r)\n     e =\n    {||} \\<or>\n    (\\<exists>x.\n        ffilter\n         (\\<lambda>((origin, dest), t).\n             origin = s \\<and> Label t = l \\<and> can_take_transition t i r)\n         e =\n        {|x|}) \\<Longrightarrow>\n    possible_steps e s r l i = {||} \\<or>\n    (\\<exists>ea. possible_steps e s r l i = {|ea|})", "apply (erule disjE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. ffilter\n     (\\<lambda>((origin, dest), t).\n         origin = s \\<and> Label t = l \\<and> can_take_transition t i r)\n     e =\n    {||} \\<Longrightarrow>\n    possible_steps e s r l i = {||} \\<or>\n    (\\<exists>ea. possible_steps e s r l i = {|ea|})\n 2. \\<exists>x.\n       ffilter\n        (\\<lambda>((origin, dest), t).\n            origin = s \\<and> Label t = l \\<and> can_take_transition t i r)\n        e =\n       {|x|} \\<Longrightarrow>\n    possible_steps e s r l i = {||} \\<or>\n    (\\<exists>ea. possible_steps e s r l i = {|ea|})", "apply (rule_tac disjI1)"], ["proof (prove)\ngoal (2 subgoals):\n 1. ffilter\n     (\\<lambda>((origin, dest), t).\n         origin = s \\<and> Label t = l \\<and> can_take_transition t i r)\n     e =\n    {||} \\<Longrightarrow>\n    possible_steps e s r l i = {||}\n 2. \\<exists>x.\n       ffilter\n        (\\<lambda>((origin, dest), t).\n            origin = s \\<and> Label t = l \\<and> can_take_transition t i r)\n        e =\n       {|x|} \\<Longrightarrow>\n    possible_steps e s r l i = {||} \\<or>\n    (\\<exists>ea. possible_steps e s r l i = {|ea|})", "apply (simp add: possible_steps_def can_take_transition_def can_take_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x.\n       ffilter\n        (\\<lambda>((origin, dest), t).\n            origin = s \\<and> Label t = l \\<and> can_take_transition t i r)\n        e =\n       {|x|} \\<Longrightarrow>\n    possible_steps e s r l i = {||} \\<or>\n    (\\<exists>ea. possible_steps e s r l i = {|ea|})", "apply (erule exE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       ffilter\n        (\\<lambda>((origin, dest), t).\n            origin = s \\<and> Label t = l \\<and> can_take_transition t i r)\n        e =\n       {|x|} \\<Longrightarrow>\n       possible_steps e s r l i = {||} \\<or>\n       (\\<exists>ea. possible_steps e s r l i = {|ea|})", "subgoal for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. ffilter\n     (\\<lambda>((origin, dest), t).\n         origin = s \\<and> Label t = l \\<and> can_take_transition t i r)\n     e =\n    {|x|} \\<Longrightarrow>\n    possible_steps e s r l i = {||} \\<or>\n    (\\<exists>ea. possible_steps e s r l i = {|ea|})", "apply (case_tac x)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>ffilter\n                 (\\<lambda>((origin, dest), t).\n                     origin = s \\<and>\n                     Label t = l \\<and> can_take_transition t i r)\n                 e =\n                {|x|};\n        x = (a, b)\\<rbrakk>\n       \\<Longrightarrow> possible_steps e s r l i = {||} \\<or>\n                         (\\<exists>ea. possible_steps e s r l i = {|ea|})", "subgoal for a b"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ffilter\n              (\\<lambda>((origin, dest), t).\n                  origin = s \\<and>\n                  Label t = l \\<and> can_take_transition t i r)\n              e =\n             {|x|};\n     x = (a, b)\\<rbrakk>\n    \\<Longrightarrow> possible_steps e s r l i = {||} \\<or>\n                      (\\<exists>ea. possible_steps e s r l i = {|ea|})", "apply (case_tac a)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa ba.\n       \\<lbrakk>ffilter\n                 (\\<lambda>((origin, dest), t).\n                     origin = s \\<and>\n                     Label t = l \\<and> can_take_transition t i r)\n                 e =\n                {|x|};\n        x = (a, b); a = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> possible_steps e s r l i = {||} \\<or>\n                         (\\<exists>ea. possible_steps e s r l i = {|ea|})", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa ba.\n       \\<lbrakk>ffilter\n                 (\\<lambda>((origin, dest), t).\n                     origin = s \\<and>\n                     Label t = l \\<and> can_take_transition t i r)\n                 e =\n                {|((aa, ba), b)|};\n        x = ((aa, ba), b); a = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> possible_steps e s r l i = {||} \\<or>\n                         (\\<exists>a b.\n                             possible_steps e s r l i = {|(a, b)|})", "apply (induct e)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa ba.\n       \\<lbrakk>ffilter\n                 (\\<lambda>((origin, dest), t).\n                     origin = s \\<and>\n                     Label t = l \\<and> can_take_transition t i r)\n                 {||} =\n                {|((aa, ba), b)|};\n        x = ((aa, ba), b); a = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> possible_steps {||} s r l i = {||} \\<or>\n                         (\\<exists>a b.\n                             possible_steps {||} s r l i = {|(a, b)|})\n 2. \\<And>xa e aa ba.\n       \\<lbrakk>xa |\\<notin>| e;\n        \\<And>aa ba.\n           \\<lbrakk>ffilter\n                     (\\<lambda>((origin, dest), t).\n                         origin = s \\<and>\n                         Label t = l \\<and> can_take_transition t i r)\n                     e =\n                    {|((aa, ba), b)|};\n            x = ((aa, ba), b); a = (aa, ba)\\<rbrakk>\n           \\<Longrightarrow> possible_steps e s r l i = {||} \\<or>\n                             (\\<exists>a b.\n                                 possible_steps e s r l i = {|(a, b)|});\n        ffilter\n         (\\<lambda>((origin, dest), t).\n             origin = s \\<and> Label t = l \\<and> can_take_transition t i r)\n         (finsert xa e) =\n        {|((aa, ba), b)|};\n        x = ((aa, ba), b); a = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> possible_steps (finsert xa e) s r l i = {||} \\<or>\n                         (\\<exists>a b.\n                             possible_steps (finsert xa e) s r l i =\n                             {|(a, b)|})", "apply auto[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa e aa ba.\n       \\<lbrakk>xa |\\<notin>| e;\n        \\<And>aa ba.\n           \\<lbrakk>ffilter\n                     (\\<lambda>((origin, dest), t).\n                         origin = s \\<and>\n                         Label t = l \\<and> can_take_transition t i r)\n                     e =\n                    {|((aa, ba), b)|};\n            x = ((aa, ba), b); a = (aa, ba)\\<rbrakk>\n           \\<Longrightarrow> possible_steps e s r l i = {||} \\<or>\n                             (\\<exists>a b.\n                                 possible_steps e s r l i = {|(a, b)|});\n        ffilter\n         (\\<lambda>((origin, dest), t).\n             origin = s \\<and> Label t = l \\<and> can_take_transition t i r)\n         (finsert xa e) =\n        {|((aa, ba), b)|};\n        x = ((aa, ba), b); a = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> possible_steps (finsert xa e) s r l i = {||} \\<or>\n                         (\\<exists>a b.\n                             possible_steps (finsert xa e) s r l i =\n                             {|(a, b)|})", "subgoal for _ _ _ ba"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>xa_ |\\<notin>| e_;\n     \\<And>aa ba.\n        \\<lbrakk>ffilter\n                  (\\<lambda>((origin, dest), t).\n                      origin = s \\<and>\n                      Label t = l \\<and> can_take_transition t i r)\n                  e_ =\n                 {|((aa, ba), b)|};\n         x = ((aa, ba), b); a = (aa, ba)\\<rbrakk>\n        \\<Longrightarrow> possible_steps e_ s r l i = {||} \\<or>\n                          (\\<exists>a b.\n                              possible_steps e_ s r l i = {|(a, b)|});\n     ffilter\n      (\\<lambda>((origin, dest), t).\n          origin = s \\<and> Label t = l \\<and> can_take_transition t i r)\n      (finsert xa_ e_) =\n     {|((aa_, ba), b)|};\n     x = ((aa_, ba), b); a = (aa_, ba)\\<rbrakk>\n    \\<Longrightarrow> possible_steps (finsert xa_ e_) s r l i = {||} \\<or>\n                      (\\<exists>a b.\n                          possible_steps (finsert xa_ e_) s r l i =\n                          {|(a, b)|})", "apply (rule disjI2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>xa_ |\\<notin>| e_;\n     \\<And>aa ba.\n        \\<lbrakk>ffilter\n                  (\\<lambda>((origin, dest), t).\n                      origin = s \\<and>\n                      Label t = l \\<and> can_take_transition t i r)\n                  e_ =\n                 {|((aa, ba), b)|};\n         x = ((aa, ba), b); a = (aa, ba)\\<rbrakk>\n        \\<Longrightarrow> possible_steps e_ s r l i = {||} \\<or>\n                          (\\<exists>a b.\n                              possible_steps e_ s r l i = {|(a, b)|});\n     ffilter\n      (\\<lambda>((origin, dest), t).\n          origin = s \\<and> Label t = l \\<and> can_take_transition t i r)\n      (finsert xa_ e_) =\n     {|((aa_, ba), b)|};\n     x = ((aa_, ba), b); a = (aa_, ba)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a b.\n                         possible_steps (finsert xa_ e_) s r l i =\n                         {|(a, b)|}", "apply (rule_tac x=ba in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>xa_ |\\<notin>| e_;\n     \\<And>aa ba.\n        \\<lbrakk>ffilter\n                  (\\<lambda>((origin, dest), t).\n                      origin = s \\<and>\n                      Label t = l \\<and> can_take_transition t i r)\n                  e_ =\n                 {|((aa, ba), b)|};\n         x = ((aa, ba), b); a = (aa, ba)\\<rbrakk>\n        \\<Longrightarrow> possible_steps e_ s r l i = {||} \\<or>\n                          (\\<exists>a b.\n                              possible_steps e_ s r l i = {|(a, b)|});\n     ffilter\n      (\\<lambda>((origin, dest), t).\n          origin = s \\<and> Label t = l \\<and> can_take_transition t i r)\n      (finsert xa_ e_) =\n     {|((aa_, ba), b)|};\n     x = ((aa_, ba), b); a = (aa_, ba)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>b.\n                         possible_steps (finsert xa_ e_) s r l i =\n                         {|(ba, b)|}", "apply (rule_tac x=b in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>xa_ |\\<notin>| e_;\n     \\<And>aa ba.\n        \\<lbrakk>ffilter\n                  (\\<lambda>((origin, dest), t).\n                      origin = s \\<and>\n                      Label t = l \\<and> can_take_transition t i r)\n                  e_ =\n                 {|((aa, ba), b)|};\n         x = ((aa, ba), b); a = (aa, ba)\\<rbrakk>\n        \\<Longrightarrow> possible_steps e_ s r l i = {||} \\<or>\n                          (\\<exists>a b.\n                              possible_steps e_ s r l i = {|(a, b)|});\n     ffilter\n      (\\<lambda>((origin, dest), t).\n          origin = s \\<and> Label t = l \\<and> can_take_transition t i r)\n      (finsert xa_ e_) =\n     {|((aa_, ba), b)|};\n     x = ((aa_, ba), b); a = (aa_, ba)\\<rbrakk>\n    \\<Longrightarrow> possible_steps (finsert xa_ e_) s r l i = {|(ba, b)|}", "by (simp add: possible_steps_def can_take_transition_def[symmetric] can_take_def[symmetric])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma deterministic_finsert:\n\"\\<forall>i r l.\n\\<forall>((a, b), t) |\\<in>| ffilter (\\<lambda>((origin, dest), t). origin = s) (finsert ((s, s'), t') e).\nLabel t = l \\<and> can_take_transition t i r \\<longrightarrow> \\<not> can_take_transition t' i r \\<Longrightarrow>\ndeterministic e \\<Longrightarrow>\ndeterministic (finsert ((s, s'), t') e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>i r l.\n                \\<forall>((a, b), t)\n                         |\\<in>|ffilter\n                                 (\\<lambda>((origin, dest), t). origin = s)\n                                 (finsert ((s, s'), t') e).\n                   Label t = l \\<and>\n                   can_take_transition t i r \\<longrightarrow>\n                   \\<not> can_take_transition t' i r;\n     deterministic e\\<rbrakk>\n    \\<Longrightarrow> deterministic (finsert ((s, s'), t') e)", "apply (simp add: deterministic_def possible_steps_finsert can_take del: size_fset_overloaded_simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>i r l.\n                \\<forall>((a, b), t)\n                         |\\<in>|ffilter\n                                 (\\<lambda>((origin, dest), t). origin = s)\n                                 (finsert ((s, s'), t') e).\n                   Label t = l \\<and>\n                   length i = Arity t \\<and>\n                   apply_guards (Guards t) (join_ir i r) \\<longrightarrow>\n                   Arity t = Arity t' \\<longrightarrow>\n                   \\<not> apply_guards (Guards t') (join_ir i r);\n     \\<forall>s r l i. size (possible_steps e s r l i) \\<le> 1\\<rbrakk>\n    \\<Longrightarrow> \\<forall>r i.\n                         length i = Arity t' \\<and>\n                         apply_guards (Guards t')\n                          (join_ir i r) \\<longrightarrow>\n                         size\n                          (finsert (s', t')\n                            (possible_steps e s r (Label t') i))\n                         \\<le> 1", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>r i.\n       \\<lbrakk>\\<forall>i r l.\n                   \\<forall>((a, b), t)\n                            |\\<in>|ffilter\n                                    (\\<lambda>((origin, dest), t).\n  origin = s)\n                                    (finsert ((s, s'), t') e).\n                      Label t = l \\<and>\n                      length i = Arity t \\<and>\n                      apply_guards (Guards t)\n                       (join_ir i r) \\<longrightarrow>\n                      Arity t = Arity t' \\<longrightarrow>\n                      \\<not> apply_guards (Guards t') (join_ir i r);\n        \\<forall>s r l i. size (possible_steps e s r l i) \\<le> 1;\n        length i = Arity t'; apply_guards (Guards t') (join_ir i r)\\<rbrakk>\n       \\<Longrightarrow> size\n                          (finsert (s', t')\n                            (possible_steps e s r (Label t') i))\n                         \\<le> 1", "subgoal for r i"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>i r l.\n                \\<forall>((a, b), t)\n                         |\\<in>|ffilter\n                                 (\\<lambda>((origin, dest), t). origin = s)\n                                 (finsert ((s, s'), t') e).\n                   Label t = l \\<and>\n                   length i = Arity t \\<and>\n                   apply_guards (Guards t) (join_ir i r) \\<longrightarrow>\n                   Arity t = Arity t' \\<longrightarrow>\n                   \\<not> apply_guards (Guards t') (join_ir i r);\n     \\<forall>s r l i. size (possible_steps e s r l i) \\<le> 1;\n     length i = Arity t'; apply_guards (Guards t') (join_ir i r)\\<rbrakk>\n    \\<Longrightarrow> size\n                       (finsert (s', t')\n                         (possible_steps e s r (Label t') i))\n                      \\<le> 1", "apply (erule_tac x=s in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>i r l.\n                \\<forall>((a, b), t)\n                         |\\<in>|ffilter\n                                 (\\<lambda>((origin, dest), t). origin = s)\n                                 (finsert ((s, s'), t') e).\n                   Label t = l \\<and>\n                   length i = Arity t \\<and>\n                   apply_guards (Guards t) (join_ir i r) \\<longrightarrow>\n                   Arity t = Arity t' \\<longrightarrow>\n                   \\<not> apply_guards (Guards t') (join_ir i r);\n     length i = Arity t'; apply_guards (Guards t') (join_ir i r);\n     \\<forall>r l i. size (possible_steps e s r l i) \\<le> 1\\<rbrakk>\n    \\<Longrightarrow> size\n                       (finsert (s', t')\n                         (possible_steps e s r (Label t') i))\n                      \\<le> 1", "apply (erule_tac x=r in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>i r l.\n                \\<forall>((a, b), t)\n                         |\\<in>|ffilter\n                                 (\\<lambda>((origin, dest), t). origin = s)\n                                 (finsert ((s, s'), t') e).\n                   Label t = l \\<and>\n                   length i = Arity t \\<and>\n                   apply_guards (Guards t) (join_ir i r) \\<longrightarrow>\n                   Arity t = Arity t' \\<longrightarrow>\n                   \\<not> apply_guards (Guards t') (join_ir i r);\n     length i = Arity t'; apply_guards (Guards t') (join_ir i r);\n     \\<forall>l i. size (possible_steps e s r l i) \\<le> 1\\<rbrakk>\n    \\<Longrightarrow> size\n                       (finsert (s', t')\n                         (possible_steps e s r (Label t') i))\n                      \\<le> 1", "apply (erule_tac x=\"Label t'\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>i r l.\n                \\<forall>((a, b), t)\n                         |\\<in>|ffilter\n                                 (\\<lambda>((origin, dest), t). origin = s)\n                                 (finsert ((s, s'), t') e).\n                   Label t = l \\<and>\n                   length i = Arity t \\<and>\n                   apply_guards (Guards t) (join_ir i r) \\<longrightarrow>\n                   Arity t = Arity t' \\<longrightarrow>\n                   \\<not> apply_guards (Guards t') (join_ir i r);\n     length i = Arity t'; apply_guards (Guards t') (join_ir i r);\n     \\<forall>i. size (possible_steps e s r (Label t') i) \\<le> 1\\<rbrakk>\n    \\<Longrightarrow> size\n                       (finsert (s', t')\n                         (possible_steps e s r (Label t') i))\n                      \\<le> 1", "apply (erule_tac x=i in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length i = Arity t'; apply_guards (Guards t') (join_ir i r);\n     \\<forall>i. size (possible_steps e s r (Label t') i) \\<le> 1;\n     \\<forall>r l.\n        \\<forall>((a, b), t)\n                 |\\<in>|ffilter (\\<lambda>((origin, dest), t). origin = s)\n                         (finsert ((s, s'), t') e).\n           Label t = l \\<and>\n           length i = Arity t \\<and>\n           apply_guards (Guards t) (join_ir i r) \\<longrightarrow>\n           Arity t = Arity t' \\<longrightarrow>\n           \\<not> apply_guards (Guards t') (join_ir i r)\\<rbrakk>\n    \\<Longrightarrow> size\n                       (finsert (s', t')\n                         (possible_steps e s r (Label t') i))\n                      \\<le> 1", "apply (erule_tac x=r in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length i = Arity t'; apply_guards (Guards t') (join_ir i r);\n     \\<forall>i. size (possible_steps e s r (Label t') i) \\<le> 1;\n     \\<forall>l.\n        \\<forall>((a, b), t)\n                 |\\<in>|ffilter (\\<lambda>((origin, dest), t). origin = s)\n                         (finsert ((s, s'), t') e).\n           Label t = l \\<and>\n           length i = Arity t \\<and>\n           apply_guards (Guards t) (join_ir i r) \\<longrightarrow>\n           Arity t = Arity t' \\<longrightarrow>\n           \\<not> apply_guards (Guards t') (join_ir i r)\\<rbrakk>\n    \\<Longrightarrow> size\n                       (finsert (s', t')\n                         (possible_steps e s r (Label t') i))\n                      \\<le> 1", "apply (erule_tac x=i in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length i = Arity t'; apply_guards (Guards t') (join_ir i r);\n     \\<forall>l.\n        \\<forall>((a, b), t)\n                 |\\<in>|ffilter (\\<lambda>((origin, dest), t). origin = s)\n                         (finsert ((s, s'), t') e).\n           Label t = l \\<and>\n           length i = Arity t \\<and>\n           apply_guards (Guards t) (join_ir i r) \\<longrightarrow>\n           Arity t = Arity t' \\<longrightarrow>\n           \\<not> apply_guards (Guards t') (join_ir i r);\n     size (possible_steps e s r (Label t') i) \\<le> 1\\<rbrakk>\n    \\<Longrightarrow> size\n                       (finsert (s', t')\n                         (possible_steps e s r (Label t') i))\n                      \\<le> 1", "apply (erule_tac x=\"Label t'\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length i = Arity t'; apply_guards (Guards t') (join_ir i r);\n     size (possible_steps e s r (Label t') i) \\<le> 1;\n     \\<forall>((a, b), t)\n              |\\<in>|ffilter (\\<lambda>((origin, dest), t). origin = s)\n                      (finsert ((s, s'), t') e).\n        Label t = Label t' \\<and>\n        length i = Arity t \\<and>\n        apply_guards (Guards t) (join_ir i r) \\<longrightarrow>\n        Arity t = Arity t' \\<longrightarrow>\n        \\<not> apply_guards (Guards t') (join_ir i r)\\<rbrakk>\n    \\<Longrightarrow> size\n                       (finsert (s', t')\n                         (possible_steps e s r (Label t') i))\n                      \\<le> 1", "by auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma ffilter_fBall: \"(\\<forall>x |\\<in>| xs. P x) = (ffilter P xs = xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fBall xs P = (ffilter P xs = xs)", "by auto"], ["", "lemma fsubset_if: \"\\<forall>x. x |\\<in>| f1 \\<longrightarrow> x |\\<in>| f2 \\<Longrightarrow> f1 |\\<subseteq>| f2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       x |\\<in>| f1 \\<longrightarrow> x |\\<in>| f2 \\<Longrightarrow>\n    f1 |\\<subseteq>| f2", "by auto"], ["", "lemma in_possible_steps: \"(((s, s'), t)|\\<in>|e \\<and> Label t = l \\<and> can_take_transition t i r) = ((s', t) |\\<in>| possible_steps e s r l i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (((s, s'), t) |\\<in>| e \\<and>\n     Label t = l \\<and> can_take_transition t i r) =\n    ((s', t) |\\<in>| possible_steps e s r l i)", "apply (simp add: fmember_possible_steps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (((s, s'), t) |\\<in>| e \\<and>\n     Label t = l \\<and> can_take_transition t i r) =\n    (((s, s'), t) \\<in> fset e \\<and>\n     Label t = l \\<and>\n     length i = Arity t \\<and> apply_guards (Guards t) (join_ir i r))", "by (simp add: can_take_def can_take_transition_def fmember.rep_eq)"], ["", "lemma possible_steps_can_take_transition:\n  \"(s2, t1) |\\<in>| possible_steps e1 s1 r l i \\<Longrightarrow> can_take_transition t1 i r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (s2, t1) |\\<in>| possible_steps e1 s1 r l i \\<Longrightarrow>\n    can_take_transition t1 i r", "using in_possible_steps"], ["proof (prove)\nusing this:\n  (((?s, ?s'), ?t) |\\<in>| ?e \\<and>\n   Label ?t = ?l \\<and> can_take_transition ?t ?i ?r) =\n  ((?s', ?t) |\\<in>| possible_steps ?e ?s ?r ?l ?i)\n\ngoal (1 subgoal):\n 1. (s2, t1) |\\<in>| possible_steps e1 s1 r l i \\<Longrightarrow>\n    can_take_transition t1 i r", "by blast"], ["", "lemma not_deterministic:\n  \"\\<exists>s l i r.\n    \\<exists>d1 d2 t1 t2.\n      d1 \\<noteq> d2 \\<and> t1 \\<noteq> t2 \\<and>\n      ((s, d1), t1) |\\<in>| e \\<and>\n      ((s, d2), t2) |\\<in>| e \\<and>\n      Label t1 = Label t2 \\<and>\n      can_take_transition t1 i r \\<and>\n      can_take_transition t2 i r \\<Longrightarrow>\n  \\<not>deterministic e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>s l i r d1 d2 t1 t2.\n       d1 \\<noteq> d2 \\<and>\n       t1 \\<noteq> t2 \\<and>\n       ((s, d1), t1) |\\<in>| e \\<and>\n       ((s, d2), t2) |\\<in>| e \\<and>\n       Label t1 = Label t2 \\<and>\n       can_take_transition t1 i r \\<and>\n       can_take_transition t2 i r \\<Longrightarrow>\n    \\<not> deterministic e", "apply (simp add: deterministic_def not_le del: size_fset_overloaded_simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>s i r d1 d2.\n       d1 \\<noteq> d2 \\<and>\n       (\\<exists>t1 t2.\n           t1 \\<noteq> t2 \\<and>\n           ((s, d1), t1) |\\<in>| e \\<and>\n           ((s, d2), t2) |\\<in>| e \\<and>\n           Label t1 = Label t2 \\<and>\n           can_take_transition t1 i r \\<and>\n           can_take_transition t2 i r) \\<Longrightarrow>\n    \\<exists>s r l i. 1 < size (possible_steps e s r l i)", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s i r d1 d2 t1 t2.\n       \\<lbrakk>d1 \\<noteq> d2; t1 \\<noteq> t2; ((s, d1), t1) |\\<in>| e;\n        ((s, d2), t2) |\\<in>| e; Label t1 = Label t2;\n        can_take_transition t1 i r; can_take_transition t2 i r\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s r l i.\n                            1 < size (possible_steps e s r l i)", "subgoal for s i r d1 d2 t1 t2"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>d1 \\<noteq> d2; t1 \\<noteq> t2; ((s, d1), t1) |\\<in>| e;\n     ((s, d2), t2) |\\<in>| e; Label t1 = Label t2;\n     can_take_transition t1 i r; can_take_transition t2 i r\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s r l i. 1 < size (possible_steps e s r l i)", "apply (rule_tac x=s in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>d1 \\<noteq> d2; t1 \\<noteq> t2; ((s, d1), t1) |\\<in>| e;\n     ((s, d2), t2) |\\<in>| e; Label t1 = Label t2;\n     can_take_transition t1 i r; can_take_transition t2 i r\\<rbrakk>\n    \\<Longrightarrow> \\<exists>r l i. 1 < size (possible_steps e s r l i)", "apply (rule_tac x=r in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>d1 \\<noteq> d2; t1 \\<noteq> t2; ((s, d1), t1) |\\<in>| e;\n     ((s, d2), t2) |\\<in>| e; Label t1 = Label t2;\n     can_take_transition t1 i r; can_take_transition t2 i r\\<rbrakk>\n    \\<Longrightarrow> \\<exists>l i. 1 < size (possible_steps e s r l i)", "apply (rule_tac x=\"Label t1\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>d1 \\<noteq> d2; t1 \\<noteq> t2; ((s, d1), t1) |\\<in>| e;\n     ((s, d2), t2) |\\<in>| e; Label t1 = Label t2;\n     can_take_transition t1 i r; can_take_transition t2 i r\\<rbrakk>\n    \\<Longrightarrow> \\<exists>i.\n                         1 < size (possible_steps e s r (Label t1) i)", "apply (rule_tac x=i in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>d1 \\<noteq> d2; t1 \\<noteq> t2; ((s, d1), t1) |\\<in>| e;\n     ((s, d2), t2) |\\<in>| e; Label t1 = Label t2;\n     can_take_transition t1 i r; can_take_transition t2 i r\\<rbrakk>\n    \\<Longrightarrow> 1 < size (possible_steps e s r (Label t1) i)", "apply (case_tac \"(d1, t1) |\\<in>| possible_steps e s r (Label t1) i\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>d1 \\<noteq> d2; t1 \\<noteq> t2; ((s, d1), t1) |\\<in>| e;\n     ((s, d2), t2) |\\<in>| e; Label t1 = Label t2;\n     can_take_transition t1 i r; can_take_transition t2 i r;\n     (d1, t1) |\\<in>| possible_steps e s r (Label t1) i\\<rbrakk>\n    \\<Longrightarrow> 1 < size (possible_steps e s r (Label t1) i)\n 2. \\<lbrakk>d1 \\<noteq> d2; t1 \\<noteq> t2; ((s, d1), t1) |\\<in>| e;\n     ((s, d2), t2) |\\<in>| e; Label t1 = Label t2;\n     can_take_transition t1 i r; can_take_transition t2 i r;\n     (d1, t1) |\\<notin>| possible_steps e s r (Label t1) i\\<rbrakk>\n    \\<Longrightarrow> 1 < size (possible_steps e s r (Label t1) i)", "defer"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>d1 \\<noteq> d2; t1 \\<noteq> t2; ((s, d1), t1) |\\<in>| e;\n     ((s, d2), t2) |\\<in>| e; Label t1 = Label t2;\n     can_take_transition t1 i r; can_take_transition t2 i r;\n     (d1, t1) |\\<notin>| possible_steps e s r (Label t1) i\\<rbrakk>\n    \\<Longrightarrow> 1 < size (possible_steps e s r (Label t1) i)\n 2. \\<lbrakk>d1 \\<noteq> d2; t1 \\<noteq> t2; ((s, d1), t1) |\\<in>| e;\n     ((s, d2), t2) |\\<in>| e; Label t1 = Label t2;\n     can_take_transition t1 i r; can_take_transition t2 i r;\n     (d1, t1) |\\<in>| possible_steps e s r (Label t1) i\\<rbrakk>\n    \\<Longrightarrow> 1 < size (possible_steps e s r (Label t1) i)", "using in_possible_steps"], ["proof (prove)\nusing this:\n  (((?s, ?s'), ?t) |\\<in>| ?e \\<and>\n   Label ?t = ?l \\<and> can_take_transition ?t ?i ?r) =\n  ((?s', ?t) |\\<in>| possible_steps ?e ?s ?r ?l ?i)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>d1 \\<noteq> d2; t1 \\<noteq> t2; ((s, d1), t1) |\\<in>| e;\n     ((s, d2), t2) |\\<in>| e; Label t1 = Label t2;\n     can_take_transition t1 i r; can_take_transition t2 i r;\n     (d1, t1) |\\<notin>| possible_steps e s r (Label t1) i\\<rbrakk>\n    \\<Longrightarrow> 1 < size (possible_steps e s r (Label t1) i)\n 2. \\<lbrakk>d1 \\<noteq> d2; t1 \\<noteq> t2; ((s, d1), t1) |\\<in>| e;\n     ((s, d2), t2) |\\<in>| e; Label t1 = Label t2;\n     can_take_transition t1 i r; can_take_transition t2 i r;\n     (d1, t1) |\\<in>| possible_steps e s r (Label t1) i\\<rbrakk>\n    \\<Longrightarrow> 1 < size (possible_steps e s r (Label t1) i)", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>d1 \\<noteq> d2; t1 \\<noteq> t2; ((s, d1), t1) |\\<in>| e;\n     ((s, d2), t2) |\\<in>| e; Label t1 = Label t2;\n     can_take_transition t1 i r; can_take_transition t2 i r;\n     (d1, t1) |\\<in>| possible_steps e s r (Label t1) i\\<rbrakk>\n    \\<Longrightarrow> 1 < size (possible_steps e s r (Label t1) i)", "apply (case_tac \"(d2, t2) |\\<in>| possible_steps e s r (Label t1) i\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>d1 \\<noteq> d2; t1 \\<noteq> t2; ((s, d1), t1) |\\<in>| e;\n     ((s, d2), t2) |\\<in>| e; Label t1 = Label t2;\n     can_take_transition t1 i r; can_take_transition t2 i r;\n     (d1, t1) |\\<in>| possible_steps e s r (Label t1) i;\n     (d2, t2) |\\<in>| possible_steps e s r (Label t1) i\\<rbrakk>\n    \\<Longrightarrow> 1 < size (possible_steps e s r (Label t1) i)\n 2. \\<lbrakk>d1 \\<noteq> d2; t1 \\<noteq> t2; ((s, d1), t1) |\\<in>| e;\n     ((s, d2), t2) |\\<in>| e; Label t1 = Label t2;\n     can_take_transition t1 i r; can_take_transition t2 i r;\n     (d1, t1) |\\<in>| possible_steps e s r (Label t1) i;\n     (d2, t2) |\\<notin>| possible_steps e s r (Label t1) i\\<rbrakk>\n    \\<Longrightarrow> 1 < size (possible_steps e s r (Label t1) i)", "apply (metis fempty_iff fsingleton_iff not_le_imp_less prod.inject size_le_1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>d1 \\<noteq> d2; t1 \\<noteq> t2; ((s, d1), t1) |\\<in>| e;\n     ((s, d2), t2) |\\<in>| e; Label t1 = Label t2;\n     can_take_transition t1 i r; can_take_transition t2 i r;\n     (d1, t1) |\\<in>| possible_steps e s r (Label t1) i;\n     (d2, t2) |\\<notin>| possible_steps e s r (Label t1) i\\<rbrakk>\n    \\<Longrightarrow> 1 < size (possible_steps e s r (Label t1) i)", "using in_possible_steps"], ["proof (prove)\nusing this:\n  (((?s, ?s'), ?t) |\\<in>| ?e \\<and>\n   Label ?t = ?l \\<and> can_take_transition ?t ?i ?r) =\n  ((?s', ?t) |\\<in>| possible_steps ?e ?s ?r ?l ?i)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>d1 \\<noteq> d2; t1 \\<noteq> t2; ((s, d1), t1) |\\<in>| e;\n     ((s, d2), t2) |\\<in>| e; Label t1 = Label t2;\n     can_take_transition t1 i r; can_take_transition t2 i r;\n     (d1, t1) |\\<in>| possible_steps e s r (Label t1) i;\n     (d2, t2) |\\<notin>| possible_steps e s r (Label t1) i\\<rbrakk>\n    \\<Longrightarrow> 1 < size (possible_steps e s r (Label t1) i)", "by force"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma not_deterministic_conv:\n  \"\\<not>deterministic e \\<Longrightarrow>\n  \\<exists>s l i r.\n    \\<exists>d1 d2 t1 t2.\n      (d1 \\<noteq> d2 \\<or> t1 \\<noteq> t2) \\<and>\n      ((s, d1), t1) |\\<in>| e \\<and>\n      ((s, d2), t2) |\\<in>| e \\<and>\n      Label t1 = Label t2 \\<and>\n      can_take_transition t1 i r \\<and>\n      can_take_transition t2 i r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> deterministic e \\<Longrightarrow>\n    \\<exists>s l i r d1 d2 t1 t2.\n       (d1 \\<noteq> d2 \\<or> t1 \\<noteq> t2) \\<and>\n       ((s, d1), t1) |\\<in>| e \\<and>\n       ((s, d2), t2) |\\<in>| e \\<and>\n       Label t1 = Label t2 \\<and>\n       can_take_transition t1 i r \\<and> can_take_transition t2 i r", "apply (simp add: deterministic_def not_le del: size_fset_overloaded_simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>s r l i. 1 < size (possible_steps e s r l i) \\<Longrightarrow>\n    \\<exists>s i r d1 d2 t1 t2.\n       (d1 = d2 \\<longrightarrow> t1 \\<noteq> t2) \\<and>\n       ((s, d1), t1) |\\<in>| e \\<and>\n       ((s, d2), t2) |\\<in>| e \\<and>\n       Label t1 = Label t2 \\<and>\n       can_take_transition t1 i r \\<and> can_take_transition t2 i r", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s r l i.\n       1 < size (possible_steps e s r l i) \\<Longrightarrow>\n       \\<exists>s i r d1 d2 t1 t2.\n          (d1 = d2 \\<longrightarrow> t1 \\<noteq> t2) \\<and>\n          ((s, d1), t1) |\\<in>| e \\<and>\n          ((s, d2), t2) |\\<in>| e \\<and>\n          Label t1 = Label t2 \\<and>\n          can_take_transition t1 i r \\<and> can_take_transition t2 i r", "subgoal for s r l i"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 < size (possible_steps e s r l i) \\<Longrightarrow>\n    \\<exists>s i r d1 d2 t1 t2.\n       (d1 = d2 \\<longrightarrow> t1 \\<noteq> t2) \\<and>\n       ((s, d1), t1) |\\<in>| e \\<and>\n       ((s, d2), t2) |\\<in>| e \\<and>\n       Label t1 = Label t2 \\<and>\n       can_take_transition t1 i r \\<and> can_take_transition t2 i r", "apply (case_tac \"\\<exists>e1 e2 f'. e1 \\<noteq> e2 \\<and> possible_steps e s r l i = finsert e1 (finsert e2 f')\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>1 < size (possible_steps e s r l i);\n     \\<exists>e1 e2 f'.\n        e1 \\<noteq> e2 \\<and>\n        possible_steps e s r l i = finsert e1 (finsert e2 f')\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s i r d1 d2 t1 t2.\n                         (d1 = d2 \\<longrightarrow> t1 \\<noteq> t2) \\<and>\n                         ((s, d1), t1) |\\<in>| e \\<and>\n                         ((s, d2), t2) |\\<in>| e \\<and>\n                         Label t1 = Label t2 \\<and>\n                         can_take_transition t1 i r \\<and>\n                         can_take_transition t2 i r\n 2. \\<lbrakk>1 < size (possible_steps e s r l i);\n     \\<nexists>e1 e2 f'.\n        e1 \\<noteq> e2 \\<and>\n        possible_steps e s r l i = finsert e1 (finsert e2 f')\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s i r d1 d2 t1 t2.\n                         (d1 = d2 \\<longrightarrow> t1 \\<noteq> t2) \\<and>\n                         ((s, d1), t1) |\\<in>| e \\<and>\n                         ((s, d2), t2) |\\<in>| e \\<and>\n                         Label t1 = Label t2 \\<and>\n                         can_take_transition t1 i r \\<and>\n                         can_take_transition t2 i r", "defer"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>1 < size (possible_steps e s r l i);\n     \\<nexists>e1 e2 f'.\n        e1 \\<noteq> e2 \\<and>\n        possible_steps e s r l i = finsert e1 (finsert e2 f')\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s i r d1 d2 t1 t2.\n                         (d1 = d2 \\<longrightarrow> t1 \\<noteq> t2) \\<and>\n                         ((s, d1), t1) |\\<in>| e \\<and>\n                         ((s, d2), t2) |\\<in>| e \\<and>\n                         Label t1 = Label t2 \\<and>\n                         can_take_transition t1 i r \\<and>\n                         can_take_transition t2 i r\n 2. \\<lbrakk>1 < size (possible_steps e s r l i);\n     \\<exists>e1 e2 f'.\n        e1 \\<noteq> e2 \\<and>\n        possible_steps e s r l i = finsert e1 (finsert e2 f')\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s i r d1 d2 t1 t2.\n                         (d1 = d2 \\<longrightarrow> t1 \\<noteq> t2) \\<and>\n                         ((s, d1), t1) |\\<in>| e \\<and>\n                         ((s, d2), t2) |\\<in>| e \\<and>\n                         Label t1 = Label t2 \\<and>\n                         can_take_transition t1 i r \\<and>\n                         can_take_transition t2 i r", "using size_gt_1"], ["proof (prove)\nusing this:\n  1 < size ?f \\<Longrightarrow>\n  \\<exists>e1 e2 f'. e1 \\<noteq> e2 \\<and> ?f = finsert e1 (finsert e2 f')\n\ngoal (2 subgoals):\n 1. \\<lbrakk>1 < size (possible_steps e s r l i);\n     \\<nexists>e1 e2 f'.\n        e1 \\<noteq> e2 \\<and>\n        possible_steps e s r l i = finsert e1 (finsert e2 f')\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s i r d1 d2 t1 t2.\n                         (d1 = d2 \\<longrightarrow> t1 \\<noteq> t2) \\<and>\n                         ((s, d1), t1) |\\<in>| e \\<and>\n                         ((s, d2), t2) |\\<in>| e \\<and>\n                         Label t1 = Label t2 \\<and>\n                         can_take_transition t1 i r \\<and>\n                         can_take_transition t2 i r\n 2. \\<lbrakk>1 < size (possible_steps e s r l i);\n     \\<exists>e1 e2 f'.\n        e1 \\<noteq> e2 \\<and>\n        possible_steps e s r l i = finsert e1 (finsert e2 f')\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s i r d1 d2 t1 t2.\n                         (d1 = d2 \\<longrightarrow> t1 \\<noteq> t2) \\<and>\n                         ((s, d1), t1) |\\<in>| e \\<and>\n                         ((s, d2), t2) |\\<in>| e \\<and>\n                         Label t1 = Label t2 \\<and>\n                         can_take_transition t1 i r \\<and>\n                         can_take_transition t2 i r", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>1 < size (possible_steps e s r l i);\n     \\<exists>e1 e2 f'.\n        e1 \\<noteq> e2 \\<and>\n        possible_steps e s r l i = finsert e1 (finsert e2 f')\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s i r d1 d2 t1 t2.\n                         (d1 = d2 \\<longrightarrow> t1 \\<noteq> t2) \\<and>\n                         ((s, d1), t1) |\\<in>| e \\<and>\n                         ((s, d2), t2) |\\<in>| e \\<and>\n                         Label t1 = Label t2 \\<and>\n                         can_take_transition t1 i r \\<and>\n                         can_take_transition t2 i r", "apply (erule exE)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>e1 e2 f'.\n       \\<lbrakk>1 < size (possible_steps e s r l i);\n        e1 \\<noteq> e2 \\<and>\n        possible_steps e s r l i = finsert e1 (finsert e2 f')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s i r d1 d2 t1 t2.\n                            (d1 = d2 \\<longrightarrow>\n                             t1 \\<noteq> t2) \\<and>\n                            ((s, d1), t1) |\\<in>| e \\<and>\n                            ((s, d2), t2) |\\<in>| e \\<and>\n                            Label t1 = Label t2 \\<and>\n                            can_take_transition t1 i r \\<and>\n                            can_take_transition t2 i r", "subgoal for e1 e2 f'"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>1 < size (possible_steps e s r l i);\n     e1 \\<noteq> e2 \\<and>\n     possible_steps e s r l i = finsert e1 (finsert e2 f')\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s i r d1 d2 t1 t2.\n                         (d1 = d2 \\<longrightarrow> t1 \\<noteq> t2) \\<and>\n                         ((s, d1), t1) |\\<in>| e \\<and>\n                         ((s, d2), t2) |\\<in>| e \\<and>\n                         Label t1 = Label t2 \\<and>\n                         can_take_transition t1 i r \\<and>\n                         can_take_transition t2 i r", "apply (case_tac e1, case_tac e2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>1 < size (possible_steps e s r l i);\n        e1 \\<noteq> e2 \\<and>\n        possible_steps e s r l i = finsert e1 (finsert e2 f');\n        e1 = (a, b); e2 = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s i r d1 d2 t1 t2.\n                            (d1 = d2 \\<longrightarrow>\n                             t1 \\<noteq> t2) \\<and>\n                            ((s, d1), t1) |\\<in>| e \\<and>\n                            ((s, d2), t2) |\\<in>| e \\<and>\n                            Label t1 = Label t2 \\<and>\n                            can_take_transition t1 i r \\<and>\n                            can_take_transition t2 i r", "subgoal for a b aa ba"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>1 < size (possible_steps e s r l i);\n     e1 \\<noteq> e2 \\<and>\n     possible_steps e s r l i = finsert e1 (finsert e2 f');\n     e1 = (a, b); e2 = (aa, ba)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s i r d1 d2 t1 t2.\n                         (d1 = d2 \\<longrightarrow> t1 \\<noteq> t2) \\<and>\n                         ((s, d1), t1) |\\<in>| e \\<and>\n                         ((s, d2), t2) |\\<in>| e \\<and>\n                         Label t1 = Label t2 \\<and>\n                         can_take_transition t1 i r \\<and>\n                         can_take_transition t2 i r", "apply (simp del: size_fset_overloaded_simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>1 < size (finsert (a, b) (finsert (aa, ba) f'));\n     (a = aa \\<longrightarrow> b \\<noteq> ba) \\<and>\n     possible_steps e s r l i = finsert (a, b) (finsert (aa, ba) f');\n     e1 = (a, b); e2 = (aa, ba)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s i r d1 d2 t1 t2.\n                         (d1 = d2 \\<longrightarrow> t1 \\<noteq> t2) \\<and>\n                         ((s, d1), t1) |\\<in>| e \\<and>\n                         ((s, d2), t2) |\\<in>| e \\<and>\n                         Label t1 = Label t2 \\<and>\n                         can_take_transition t1 i r \\<and>\n                         can_take_transition t2 i r", "apply (rule_tac x=s in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>1 < size (finsert (a, b) (finsert (aa, ba) f'));\n     (a = aa \\<longrightarrow> b \\<noteq> ba) \\<and>\n     possible_steps e s r l i = finsert (a, b) (finsert (aa, ba) f');\n     e1 = (a, b); e2 = (aa, ba)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>i r d1 d2 t1 t2.\n                         (d1 = d2 \\<longrightarrow> t1 \\<noteq> t2) \\<and>\n                         ((s, d1), t1) |\\<in>| e \\<and>\n                         ((s, d2), t2) |\\<in>| e \\<and>\n                         Label t1 = Label t2 \\<and>\n                         can_take_transition t1 i r \\<and>\n                         can_take_transition t2 i r", "apply (rule_tac x=i in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>1 < size (finsert (a, b) (finsert (aa, ba) f'));\n     (a = aa \\<longrightarrow> b \\<noteq> ba) \\<and>\n     possible_steps e s r l i = finsert (a, b) (finsert (aa, ba) f');\n     e1 = (a, b); e2 = (aa, ba)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>r d1 d2 t1 t2.\n                         (d1 = d2 \\<longrightarrow> t1 \\<noteq> t2) \\<and>\n                         ((s, d1), t1) |\\<in>| e \\<and>\n                         ((s, d2), t2) |\\<in>| e \\<and>\n                         Label t1 = Label t2 \\<and>\n                         can_take_transition t1 i r \\<and>\n                         can_take_transition t2 i r", "apply (rule_tac x=r in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>1 < size (finsert (a, b) (finsert (aa, ba) f'));\n     (a = aa \\<longrightarrow> b \\<noteq> ba) \\<and>\n     possible_steps e s r l i = finsert (a, b) (finsert (aa, ba) f');\n     e1 = (a, b); e2 = (aa, ba)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>d1 d2 t1 t2.\n                         (d1 = d2 \\<longrightarrow> t1 \\<noteq> t2) \\<and>\n                         ((s, d1), t1) |\\<in>| e \\<and>\n                         ((s, d2), t2) |\\<in>| e \\<and>\n                         Label t1 = Label t2 \\<and>\n                         can_take_transition t1 i r \\<and>\n                         can_take_transition t2 i r", "apply (rule_tac x=a in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>1 < size (finsert (a, b) (finsert (aa, ba) f'));\n     (a = aa \\<longrightarrow> b \\<noteq> ba) \\<and>\n     possible_steps e s r l i = finsert (a, b) (finsert (aa, ba) f');\n     e1 = (a, b); e2 = (aa, ba)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>d2 t1 t2.\n                         (a = d2 \\<longrightarrow> t1 \\<noteq> t2) \\<and>\n                         ((s, a), t1) |\\<in>| e \\<and>\n                         ((s, d2), t2) |\\<in>| e \\<and>\n                         Label t1 = Label t2 \\<and>\n                         can_take_transition t1 i r \\<and>\n                         can_take_transition t2 i r", "apply (rule_tac x=aa in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>1 < size (finsert (a, b) (finsert (aa, ba) f'));\n     (a = aa \\<longrightarrow> b \\<noteq> ba) \\<and>\n     possible_steps e s r l i = finsert (a, b) (finsert (aa, ba) f');\n     e1 = (a, b); e2 = (aa, ba)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t1 t2.\n                         (a = aa \\<longrightarrow> t1 \\<noteq> t2) \\<and>\n                         ((s, a), t1) |\\<in>| e \\<and>\n                         ((s, aa), t2) |\\<in>| e \\<and>\n                         Label t1 = Label t2 \\<and>\n                         can_take_transition t1 i r \\<and>\n                         can_take_transition t2 i r", "apply (rule_tac x=b in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>1 < size (finsert (a, b) (finsert (aa, ba) f'));\n     (a = aa \\<longrightarrow> b \\<noteq> ba) \\<and>\n     possible_steps e s r l i = finsert (a, b) (finsert (aa, ba) f');\n     e1 = (a, b); e2 = (aa, ba)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t2.\n                         (a = aa \\<longrightarrow> b \\<noteq> t2) \\<and>\n                         ((s, a), b) |\\<in>| e \\<and>\n                         ((s, aa), t2) |\\<in>| e \\<and>\n                         Label b = Label t2 \\<and>\n                         can_take_transition b i r \\<and>\n                         can_take_transition t2 i r", "apply (rule_tac x=ba in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>1 < size (finsert (a, b) (finsert (aa, ba) f'));\n     (a = aa \\<longrightarrow> b \\<noteq> ba) \\<and>\n     possible_steps e s r l i = finsert (a, b) (finsert (aa, ba) f');\n     e1 = (a, b); e2 = (aa, ba)\\<rbrakk>\n    \\<Longrightarrow> (a = aa \\<longrightarrow> b \\<noteq> ba) \\<and>\n                      ((s, a), b) |\\<in>| e \\<and>\n                      ((s, aa), ba) |\\<in>| e \\<and>\n                      Label b = Label ba \\<and>\n                      can_take_transition b i r \\<and>\n                      can_take_transition ba i r", "by (metis finsertI1 finsert_commute in_possible_steps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma deterministic_if:\n\"\\<nexists>s l i r.\n  \\<exists>d1 d2 t1 t2.\n    (d1 \\<noteq> d2 \\<or> t1 \\<noteq> t2) \\<and>\n    ((s, d1), t1) |\\<in>| e \\<and>\n    ((s, d2), t2) |\\<in>| e \\<and>\n    Label t1 = Label t2 \\<and>\n    can_take_transition t1 i r \\<and>\n    can_take_transition t2 i r \\<Longrightarrow>\n  deterministic e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nexists>s l i r d1 d2 t1 t2.\n       (d1 \\<noteq> d2 \\<or> t1 \\<noteq> t2) \\<and>\n       ((s, d1), t1) |\\<in>| e \\<and>\n       ((s, d2), t2) |\\<in>| e \\<and>\n       Label t1 = Label t2 \\<and>\n       can_take_transition t1 i r \\<and>\n       can_take_transition t2 i r \\<Longrightarrow>\n    deterministic e", "using not_deterministic_conv"], ["proof (prove)\nusing this:\n  \\<not> deterministic ?e \\<Longrightarrow>\n  \\<exists>s l i r d1 d2 t1 t2.\n     (d1 \\<noteq> d2 \\<or> t1 \\<noteq> t2) \\<and>\n     ((s, d1), t1) |\\<in>| ?e \\<and>\n     ((s, d2), t2) |\\<in>| ?e \\<and>\n     Label t1 = Label t2 \\<and>\n     can_take_transition t1 i r \\<and> can_take_transition t2 i r\n\ngoal (1 subgoal):\n 1. \\<nexists>s l i r d1 d2 t1 t2.\n       (d1 \\<noteq> d2 \\<or> t1 \\<noteq> t2) \\<and>\n       ((s, d1), t1) |\\<in>| e \\<and>\n       ((s, d2), t2) |\\<in>| e \\<and>\n       Label t1 = Label t2 \\<and>\n       can_take_transition t1 i r \\<and>\n       can_take_transition t2 i r \\<Longrightarrow>\n    deterministic e", "by blast"], ["", "lemma \"\\<forall>l i r.\n  (\\<forall>((s, s'), t) |\\<in>| e. Label t = l \\<and> can_take_transition t i r \\<and>\n  (\\<nexists>t' s''. ((s, s''), t') |\\<in>| e \\<and> (s' \\<noteq> s'' \\<or> t' \\<noteq> t) \\<and> Label t' = l \\<and> can_take_transition t' i r))\n \\<Longrightarrow> deterministic e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>l i r.\n       \\<forall>((s, s'), t)|\\<in>|e.\n          Label t = l \\<and>\n          can_take_transition t i r \\<and>\n          (\\<nexists>t' s''.\n              ((s, s''), t') |\\<in>| e \\<and>\n              (s' \\<noteq> s'' \\<or> t' \\<noteq> t) \\<and>\n              Label t' = l \\<and>\n              can_take_transition t' i r) \\<Longrightarrow>\n    deterministic e", "apply (simp add: deterministic_def del: size_fset_overloaded_simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>l i r.\n       \\<forall>((s, s'), t)|\\<in>|e.\n          Label t = l \\<and>\n          can_take_transition t i r \\<and>\n          (\\<forall>t'.\n              Label t' = l \\<longrightarrow>\n              (\\<forall>s''.\n                  ((s, s''), t') |\\<in>| e \\<longrightarrow>\n                  s' = s'' \\<and> t' = t \\<or>\n                  \\<not> can_take_transition t' i r)) \\<Longrightarrow>\n    \\<forall>s r l i. size (possible_steps e s r l i) \\<le> 1", "apply (rule allI)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s r l i.\n       \\<forall>l i r.\n          \\<forall>((s, s'), t)|\\<in>|e.\n             Label t = l \\<and>\n             can_take_transition t i r \\<and>\n             (\\<forall>t'.\n                 Label t' = l \\<longrightarrow>\n                 (\\<forall>s''.\n                     ((s, s''), t') |\\<in>| e \\<longrightarrow>\n                     s' = s'' \\<and> t' = t \\<or>\n                     \\<not> can_take_transition t' i r)) \\<Longrightarrow>\n       size (possible_steps e s r l i) \\<le> 1", "apply (simp only: size_le_1 possible_steps_empty)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s r l i.\n       \\<forall>l i r.\n          \\<forall>((s, s'), t)|\\<in>|e.\n             Label t = l \\<and>\n             can_take_transition t i r \\<and>\n             (\\<forall>t'.\n                 Label t' = l \\<longrightarrow>\n                 (\\<forall>s''.\n                     ((s, s''), t') |\\<in>| e \\<longrightarrow>\n                     s' = s'' \\<and> t' = t \\<or>\n                     \\<not> can_take_transition t' i r)) \\<Longrightarrow>\n       (\\<forall>((origin, dest), t)\\<in>fset e.\n           origin \\<noteq> s \\<or>\n           Label t \\<noteq> l \\<or> \\<not> can_take_transition t i r) \\<or>\n       (\\<exists>ea. possible_steps e s r l i = {|ea|})", "apply (case_tac \"\\<exists>t s'. ((s, s'), t)|\\<in>|e \\<and> Label t = l \\<and> can_take_transition t i r\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s r l i.\n       \\<lbrakk>\\<forall>l i r.\n                   \\<forall>((s, s'), t)|\\<in>|e.\n                      Label t = l \\<and>\n                      can_take_transition t i r \\<and>\n                      (\\<forall>t'.\n                          Label t' = l \\<longrightarrow>\n                          (\\<forall>s''.\n                              ((s, s''), t') |\\<in>| e \\<longrightarrow>\n                              s' = s'' \\<and> t' = t \\<or>\n                              \\<not> can_take_transition t' i r));\n        \\<exists>t s'.\n           ((s, s'), t) |\\<in>| e \\<and>\n           Label t = l \\<and> can_take_transition t i r\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>((origin, dest), t)\\<in>fset e.\n                             origin \\<noteq> s \\<or>\n                             Label t \\<noteq> l \\<or>\n                             \\<not> can_take_transition t i r) \\<or>\n                         (\\<exists>ea. possible_steps e s r l i = {|ea|})\n 2. \\<And>s r l i.\n       \\<lbrakk>\\<forall>l i r.\n                   \\<forall>((s, s'), t)|\\<in>|e.\n                      Label t = l \\<and>\n                      can_take_transition t i r \\<and>\n                      (\\<forall>t'.\n                          Label t' = l \\<longrightarrow>\n                          (\\<forall>s''.\n                              ((s, s''), t') |\\<in>| e \\<longrightarrow>\n                              s' = s'' \\<and> t' = t \\<or>\n                              \\<not> can_take_transition t' i r));\n        \\<nexists>t s'.\n           ((s, s'), t) |\\<in>| e \\<and>\n           Label t = l \\<and> can_take_transition t i r\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>((origin, dest), t)\\<in>fset e.\n                             origin \\<noteq> s \\<or>\n                             Label t \\<noteq> l \\<or>\n                             \\<not> can_take_transition t i r) \\<or>\n                         (\\<exists>ea. possible_steps e s r l i = {|ea|})", "defer"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s r l i.\n       \\<lbrakk>\\<forall>l i r.\n                   \\<forall>((s, s'), t)|\\<in>|e.\n                      Label t = l \\<and>\n                      can_take_transition t i r \\<and>\n                      (\\<forall>t'.\n                          Label t' = l \\<longrightarrow>\n                          (\\<forall>s''.\n                              ((s, s''), t') |\\<in>| e \\<longrightarrow>\n                              s' = s'' \\<and> t' = t \\<or>\n                              \\<not> can_take_transition t' i r));\n        \\<nexists>t s'.\n           ((s, s'), t) |\\<in>| e \\<and>\n           Label t = l \\<and> can_take_transition t i r\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>((origin, dest), t)\\<in>fset e.\n                             origin \\<noteq> s \\<or>\n                             Label t \\<noteq> l \\<or>\n                             \\<not> can_take_transition t i r) \\<or>\n                         (\\<exists>ea. possible_steps e s r l i = {|ea|})\n 2. \\<And>s r l i.\n       \\<lbrakk>\\<forall>l i r.\n                   \\<forall>((s, s'), t)|\\<in>|e.\n                      Label t = l \\<and>\n                      can_take_transition t i r \\<and>\n                      (\\<forall>t'.\n                          Label t' = l \\<longrightarrow>\n                          (\\<forall>s''.\n                              ((s, s''), t') |\\<in>| e \\<longrightarrow>\n                              s' = s'' \\<and> t' = t \\<or>\n                              \\<not> can_take_transition t' i r));\n        \\<exists>t s'.\n           ((s, s'), t) |\\<in>| e \\<and>\n           Label t = l \\<and> can_take_transition t i r\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>((origin, dest), t)\\<in>fset e.\n                             origin \\<noteq> s \\<or>\n                             Label t \\<noteq> l \\<or>\n                             \\<not> can_take_transition t i r) \\<or>\n                         (\\<exists>ea. possible_steps e s r l i = {|ea|})", "using notin_fset"], ["proof (prove)\nusing this:\n  (?x |\\<notin>| ?S) = (?x \\<notin> fset ?S)\n\ngoal (2 subgoals):\n 1. \\<And>s r l i.\n       \\<lbrakk>\\<forall>l i r.\n                   \\<forall>((s, s'), t)|\\<in>|e.\n                      Label t = l \\<and>\n                      can_take_transition t i r \\<and>\n                      (\\<forall>t'.\n                          Label t' = l \\<longrightarrow>\n                          (\\<forall>s''.\n                              ((s, s''), t') |\\<in>| e \\<longrightarrow>\n                              s' = s'' \\<and> t' = t \\<or>\n                              \\<not> can_take_transition t' i r));\n        \\<nexists>t s'.\n           ((s, s'), t) |\\<in>| e \\<and>\n           Label t = l \\<and> can_take_transition t i r\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>((origin, dest), t)\\<in>fset e.\n                             origin \\<noteq> s \\<or>\n                             Label t \\<noteq> l \\<or>\n                             \\<not> can_take_transition t i r) \\<or>\n                         (\\<exists>ea. possible_steps e s r l i = {|ea|})\n 2. \\<And>s r l i.\n       \\<lbrakk>\\<forall>l i r.\n                   \\<forall>((s, s'), t)|\\<in>|e.\n                      Label t = l \\<and>\n                      can_take_transition t i r \\<and>\n                      (\\<forall>t'.\n                          Label t' = l \\<longrightarrow>\n                          (\\<forall>s''.\n                              ((s, s''), t') |\\<in>| e \\<longrightarrow>\n                              s' = s'' \\<and> t' = t \\<or>\n                              \\<not> can_take_transition t' i r));\n        \\<exists>t s'.\n           ((s, s'), t) |\\<in>| e \\<and>\n           Label t = l \\<and> can_take_transition t i r\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>((origin, dest), t)\\<in>fset e.\n                             origin \\<noteq> s \\<or>\n                             Label t \\<noteq> l \\<or>\n                             \\<not> can_take_transition t i r) \\<or>\n                         (\\<exists>ea. possible_steps e s r l i = {|ea|})", "apply fastforce"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s r l i.\n       \\<lbrakk>\\<forall>l i r.\n                   \\<forall>((s, s'), t)|\\<in>|e.\n                      Label t = l \\<and>\n                      can_take_transition t i r \\<and>\n                      (\\<forall>t'.\n                          Label t' = l \\<longrightarrow>\n                          (\\<forall>s''.\n                              ((s, s''), t') |\\<in>| e \\<longrightarrow>\n                              s' = s'' \\<and> t' = t \\<or>\n                              \\<not> can_take_transition t' i r));\n        \\<exists>t s'.\n           ((s, s'), t) |\\<in>| e \\<and>\n           Label t = l \\<and> can_take_transition t i r\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>((origin, dest), t)\\<in>fset e.\n                             origin \\<noteq> s \\<or>\n                             Label t \\<noteq> l \\<or>\n                             \\<not> can_take_transition t i r) \\<or>\n                         (\\<exists>ea. possible_steps e s r l i = {|ea|})", "apply (rule disjI2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s r l i.\n       \\<lbrakk>\\<forall>l i r.\n                   \\<forall>((s, s'), t)|\\<in>|e.\n                      Label t = l \\<and>\n                      can_take_transition t i r \\<and>\n                      (\\<forall>t'.\n                          Label t' = l \\<longrightarrow>\n                          (\\<forall>s''.\n                              ((s, s''), t') |\\<in>| e \\<longrightarrow>\n                              s' = s'' \\<and> t' = t \\<or>\n                              \\<not> can_take_transition t' i r));\n        \\<exists>t s'.\n           ((s, s'), t) |\\<in>| e \\<and>\n           Label t = l \\<and> can_take_transition t i r\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ea. possible_steps e s r l i = {|ea|}", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s r l i t s'.\n       \\<lbrakk>\\<forall>l i r.\n                   \\<forall>((s, s'), t)|\\<in>|e.\n                      Label t = l \\<and>\n                      can_take_transition t i r \\<and>\n                      (\\<forall>t'.\n                          Label t' = l \\<longrightarrow>\n                          (\\<forall>s''.\n                              ((s, s''), t') |\\<in>| e \\<longrightarrow>\n                              s' = s'' \\<and> t' = t \\<or>\n                              \\<not> can_take_transition t' i r));\n        ((s, s'), t) |\\<in>| e; can_take_transition t i r\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ea.\n                            possible_steps e s r (Label t) i = {|ea|}", "apply (rule_tac x=\"(s', t)\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s r l i t s'.\n       \\<lbrakk>\\<forall>l i r.\n                   \\<forall>((s, s'), t)|\\<in>|e.\n                      Label t = l \\<and>\n                      can_take_transition t i r \\<and>\n                      (\\<forall>t'.\n                          Label t' = l \\<longrightarrow>\n                          (\\<forall>s''.\n                              ((s, s''), t') |\\<in>| e \\<longrightarrow>\n                              s' = s'' \\<and> t' = t \\<or>\n                              \\<not> can_take_transition t' i r));\n        ((s, s'), t) |\\<in>| e; can_take_transition t i r\\<rbrakk>\n       \\<Longrightarrow> possible_steps e s r (Label t) i = {|(s', t)|}", "apply standard"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s r l i t s'.\n       \\<lbrakk>\\<forall>l i r.\n                   \\<forall>((s, s'), t)|\\<in>|e.\n                      Label t = l \\<and>\n                      can_take_transition t i r \\<and>\n                      (\\<forall>t'.\n                          Label t' = l \\<longrightarrow>\n                          (\\<forall>s''.\n                              ((s, s''), t') |\\<in>| e \\<longrightarrow>\n                              s' = s'' \\<and> t' = t \\<or>\n                              \\<not> can_take_transition t' i r));\n        ((s, s'), t) |\\<in>| e; can_take_transition t i r\\<rbrakk>\n       \\<Longrightarrow> possible_steps e s r (Label t) i |\\<subseteq>|\n                         {|(s', t)|}\n 2. \\<And>s r l i t s'.\n       \\<lbrakk>\\<forall>l i r.\n                   \\<forall>((s, s'), t)|\\<in>|e.\n                      Label t = l \\<and>\n                      can_take_transition t i r \\<and>\n                      (\\<forall>t'.\n                          Label t' = l \\<longrightarrow>\n                          (\\<forall>s''.\n                              ((s, s''), t') |\\<in>| e \\<longrightarrow>\n                              s' = s'' \\<and> t' = t \\<or>\n                              \\<not> can_take_transition t' i r));\n        ((s, s'), t) |\\<in>| e; can_take_transition t i r\\<rbrakk>\n       \\<Longrightarrow> {|(s', t)|} |\\<subseteq>|\n                         possible_steps e s r (Label t) i", "defer"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s r l i t s'.\n       \\<lbrakk>\\<forall>l i r.\n                   \\<forall>((s, s'), t)|\\<in>|e.\n                      Label t = l \\<and>\n                      can_take_transition t i r \\<and>\n                      (\\<forall>t'.\n                          Label t' = l \\<longrightarrow>\n                          (\\<forall>s''.\n                              ((s, s''), t') |\\<in>| e \\<longrightarrow>\n                              s' = s'' \\<and> t' = t \\<or>\n                              \\<not> can_take_transition t' i r));\n        ((s, s'), t) |\\<in>| e; can_take_transition t i r\\<rbrakk>\n       \\<Longrightarrow> {|(s', t)|} |\\<subseteq>|\n                         possible_steps e s r (Label t) i\n 2. \\<And>s r l i t s'.\n       \\<lbrakk>\\<forall>l i r.\n                   \\<forall>((s, s'), t)|\\<in>|e.\n                      Label t = l \\<and>\n                      can_take_transition t i r \\<and>\n                      (\\<forall>t'.\n                          Label t' = l \\<longrightarrow>\n                          (\\<forall>s''.\n                              ((s, s''), t') |\\<in>| e \\<longrightarrow>\n                              s' = s'' \\<and> t' = t \\<or>\n                              \\<not> can_take_transition t' i r));\n        ((s, s'), t) |\\<in>| e; can_take_transition t i r\\<rbrakk>\n       \\<Longrightarrow> possible_steps e s r (Label t) i |\\<subseteq>|\n                         {|(s', t)|}", "apply (meson fempty_fsubsetI finsert_fsubset in_possible_steps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s r l i t s'.\n       \\<lbrakk>\\<forall>l i r.\n                   \\<forall>((s, s'), t)|\\<in>|e.\n                      Label t = l \\<and>\n                      can_take_transition t i r \\<and>\n                      (\\<forall>t'.\n                          Label t' = l \\<longrightarrow>\n                          (\\<forall>s''.\n                              ((s, s''), t') |\\<in>| e \\<longrightarrow>\n                              s' = s'' \\<and> t' = t \\<or>\n                              \\<not> can_take_transition t' i r));\n        ((s, s'), t) |\\<in>| e; can_take_transition t i r\\<rbrakk>\n       \\<Longrightarrow> possible_steps e s r (Label t) i |\\<subseteq>|\n                         {|(s', t)|}", "apply standard"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s r l i t s' x.\n       \\<lbrakk>\\<forall>l i r.\n                   \\<forall>((s, s'), t)|\\<in>|e.\n                      Label t = l \\<and>\n                      can_take_transition t i r \\<and>\n                      (\\<forall>t'.\n                          Label t' = l \\<longrightarrow>\n                          (\\<forall>s''.\n                              ((s, s''), t') |\\<in>| e \\<longrightarrow>\n                              s' = s'' \\<and> t' = t \\<or>\n                              \\<not> can_take_transition t' i r));\n        ((s, s'), t) |\\<in>| e; can_take_transition t i r;\n        x |\\<in>| possible_steps e s r (Label t) i\\<rbrakk>\n       \\<Longrightarrow> x |\\<in>| {|(s', t)|}", "apply (case_tac x)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s r l i t s' x a b.\n       \\<lbrakk>\\<forall>l i r.\n                   \\<forall>((s, s'), t)|\\<in>|e.\n                      Label t = l \\<and>\n                      can_take_transition t i r \\<and>\n                      (\\<forall>t'.\n                          Label t' = l \\<longrightarrow>\n                          (\\<forall>s''.\n                              ((s, s''), t') |\\<in>| e \\<longrightarrow>\n                              s' = s'' \\<and> t' = t \\<or>\n                              \\<not> can_take_transition t' i r));\n        ((s, s'), t) |\\<in>| e; can_take_transition t i r;\n        x |\\<in>| possible_steps e s r (Label t) i; x = (a, b)\\<rbrakk>\n       \\<Longrightarrow> x |\\<in>| {|(s', t)|}", "apply (simp add: in_possible_steps[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s r i t s' x a b.\n       \\<lbrakk>\\<forall>l i r.\n                   \\<forall>((s, s'), t)|\\<in>|e.\n                      Label t = l \\<and>\n                      can_take_transition t i r \\<and>\n                      (\\<forall>t'.\n                          Label t' = l \\<longrightarrow>\n                          (\\<forall>s''.\n                              ((s, s''), t') |\\<in>| e \\<longrightarrow>\n                              s' = s'' \\<and> t' = t \\<or>\n                              \\<not> can_take_transition t' i r));\n        ((s, s'), t) |\\<in>| e; can_take_transition t i r;\n        ((s, a), b) |\\<in>| e \\<and>\n        Label b = Label t \\<and> can_take_transition b i r;\n        x = (a, b)\\<rbrakk>\n       \\<Longrightarrow> a = s' \\<and> b = t", "apply (erule_tac x=\"Label t\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s r i t s' x a b.\n       \\<lbrakk>((s, s'), t) |\\<in>| e; can_take_transition t i r;\n        ((s, a), b) |\\<in>| e \\<and>\n        Label b = Label t \\<and> can_take_transition b i r;\n        x = (a, b);\n        \\<forall>i r.\n           \\<forall>((s, s'), ta)|\\<in>|e.\n              Label ta = Label t \\<and>\n              can_take_transition ta i r \\<and>\n              (\\<forall>t'.\n                  Label t' = Label t \\<longrightarrow>\n                  (\\<forall>s''.\n                      ((s, s''), t') |\\<in>| e \\<longrightarrow>\n                      s' = s'' \\<and> t' = ta \\<or>\n                      \\<not> can_take_transition t' i r))\\<rbrakk>\n       \\<Longrightarrow> a = s' \\<and> b = t", "apply (erule_tac x=i in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s r i t s' x a b.\n       \\<lbrakk>((s, s'), t) |\\<in>| e; can_take_transition t i r;\n        ((s, a), b) |\\<in>| e \\<and>\n        Label b = Label t \\<and> can_take_transition b i r;\n        x = (a, b);\n        \\<forall>r.\n           \\<forall>((s, s'), ta)|\\<in>|e.\n              Label ta = Label t \\<and>\n              can_take_transition ta i r \\<and>\n              (\\<forall>t'.\n                  Label t' = Label t \\<longrightarrow>\n                  (\\<forall>s''.\n                      ((s, s''), t') |\\<in>| e \\<longrightarrow>\n                      s' = s'' \\<and> t' = ta \\<or>\n                      \\<not> can_take_transition t' i r))\\<rbrakk>\n       \\<Longrightarrow> a = s' \\<and> b = t", "apply (erule_tac x=r in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s r i t s' x a b.\n       \\<lbrakk>((s, s'), t) |\\<in>| e; can_take_transition t i r;\n        ((s, a), b) |\\<in>| e \\<and>\n        Label b = Label t \\<and> can_take_transition b i r;\n        x = (a, b);\n        \\<forall>((s, s'), ta)|\\<in>|e.\n           Label ta = Label t \\<and>\n           can_take_transition ta i r \\<and>\n           (\\<forall>t'.\n               Label t' = Label t \\<longrightarrow>\n               (\\<forall>s''.\n                   ((s, s''), t') |\\<in>| e \\<longrightarrow>\n                   s' = s'' \\<and> t' = ta \\<or>\n                   \\<not> can_take_transition t' i r))\\<rbrakk>\n       \\<Longrightarrow> a = s' \\<and> b = t", "apply (erule_tac x=\"((s, s'), t)\" in fBallE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s r i t s' x a b.\n       \\<lbrakk>((s, s'), t) |\\<in>| e; can_take_transition t i r;\n        ((s, a), b) |\\<in>| e \\<and>\n        Label b = Label t \\<and> can_take_transition b i r;\n        x = (a, b);\n        case ((s, s'), t) of\n        (x, xa) \\<Rightarrow>\n          (case x of\n           (s, s') \\<Rightarrow>\n             \\<lambda>ta.\n                Label ta = Label t \\<and>\n                can_take_transition ta i r \\<and>\n                (\\<forall>t'.\n                    Label t' = Label t \\<longrightarrow>\n                    (\\<forall>s''.\n                        ((s, s''), t') |\\<in>| e \\<longrightarrow>\n                        s' = s'' \\<and> t' = ta \\<or>\n                        \\<not> can_take_transition t' i r)))\n           xa\\<rbrakk>\n       \\<Longrightarrow> a = s' \\<and> b = t\n 2. \\<And>s r i t s' x a b.\n       \\<lbrakk>((s, s'), t) |\\<in>| e; can_take_transition t i r;\n        ((s, a), b) |\\<in>| e \\<and>\n        Label b = Label t \\<and> can_take_transition b i r;\n        x = (a, b); ((s, s'), t) |\\<notin>| e\\<rbrakk>\n       \\<Longrightarrow> a = s' \\<and> b = t", "defer"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s r i t s' x a b.\n       \\<lbrakk>((s, s'), t) |\\<in>| e; can_take_transition t i r;\n        ((s, a), b) |\\<in>| e \\<and>\n        Label b = Label t \\<and> can_take_transition b i r;\n        x = (a, b); ((s, s'), t) |\\<notin>| e\\<rbrakk>\n       \\<Longrightarrow> a = s' \\<and> b = t\n 2. \\<And>s r i t s' x a b.\n       \\<lbrakk>((s, s'), t) |\\<in>| e; can_take_transition t i r;\n        ((s, a), b) |\\<in>| e \\<and>\n        Label b = Label t \\<and> can_take_transition b i r;\n        x = (a, b);\n        case ((s, s'), t) of\n        (x, xa) \\<Rightarrow>\n          (case x of\n           (s, s') \\<Rightarrow>\n             \\<lambda>ta.\n                Label ta = Label t \\<and>\n                can_take_transition ta i r \\<and>\n                (\\<forall>t'.\n                    Label t' = Label t \\<longrightarrow>\n                    (\\<forall>s''.\n                        ((s, s''), t') |\\<in>| e \\<longrightarrow>\n                        s' = s'' \\<and> t' = ta \\<or>\n                        \\<not> can_take_transition t' i r)))\n           xa\\<rbrakk>\n       \\<Longrightarrow> a = s' \\<and> b = t", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s r i t s' x a b.\n       \\<lbrakk>((s, s'), t) |\\<in>| e; can_take_transition t i r;\n        ((s, a), b) |\\<in>| e \\<and>\n        Label b = Label t \\<and> can_take_transition b i r;\n        x = (a, b);\n        case ((s, s'), t) of\n        (x, xa) \\<Rightarrow>\n          (case x of\n           (s, s') \\<Rightarrow>\n             \\<lambda>ta.\n                Label ta = Label t \\<and>\n                can_take_transition ta i r \\<and>\n                (\\<forall>t'.\n                    Label t' = Label t \\<longrightarrow>\n                    (\\<forall>s''.\n                        ((s, s''), t') |\\<in>| e \\<longrightarrow>\n                        s' = s'' \\<and> t' = ta \\<or>\n                        \\<not> can_take_transition t' i r)))\n           xa\\<rbrakk>\n       \\<Longrightarrow> a = s' \\<and> b = t", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s r i t s' x a b.\n       \\<lbrakk>((s, s'), t) |\\<in>| e; can_take_transition t i r;\n        ((s, a), b) |\\<in>| e \\<and>\n        Label b = Label t \\<and> can_take_transition b i r;\n        x = (a, b);\n        \\<forall>t'.\n           Label t' = Label t \\<longrightarrow>\n           (\\<forall>s''.\n               ((s, s''), t') |\\<in>| e \\<longrightarrow>\n               s' = s'' \\<and> t' = t \\<or>\n               \\<not> can_take_transition t' i r)\\<rbrakk>\n       \\<Longrightarrow> a = s' \\<and> b = t", "apply (erule_tac x=b in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s r i t s' x a b.\n       \\<lbrakk>((s, s'), t) |\\<in>| e; can_take_transition t i r;\n        ((s, a), b) |\\<in>| e \\<and>\n        Label b = Label t \\<and> can_take_transition b i r;\n        x = (a, b);\n        Label b = Label t \\<longrightarrow>\n        (\\<forall>s''.\n            ((s, s''), b) |\\<in>| e \\<longrightarrow>\n            s' = s'' \\<and> b = t \\<or>\n            \\<not> can_take_transition b i r)\\<rbrakk>\n       \\<Longrightarrow> a = s' \\<and> b = t", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s r i t s' x a b.\n       \\<lbrakk>((s, s'), t) |\\<in>| e; can_take_transition t i r;\n        ((s, a), b) |\\<in>| e \\<and>\n        Label b = Label t \\<and> can_take_transition b i r;\n        x = (a, b);\n        \\<forall>s''.\n           ((s, s''), b) |\\<in>| e \\<longrightarrow>\n           s' = s'' \\<and> b = t\\<rbrakk>\n       \\<Longrightarrow> a = s' \\<and> b = t", "apply (erule_tac x=a in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s r i t s' x a b.\n       \\<lbrakk>((s, s'), t) |\\<in>| e; can_take_transition t i r;\n        ((s, a), b) |\\<in>| e \\<and>\n        Label b = Label t \\<and> can_take_transition b i r;\n        x = (a, b);\n        ((s, a), b) |\\<in>| e \\<longrightarrow> s' = a \\<and> b = t\\<rbrakk>\n       \\<Longrightarrow> a = s' \\<and> b = t", "by simp"], ["", "definition \"outgoing_transitions e s = ffilter (\\<lambda>((o, _), _). o = s) e\""], ["", "lemma in_outgoing: \"((s1, s2), t) |\\<in>| outgoing_transitions e s = (((s1, s2), t) |\\<in>| e \\<and> s1 = s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (((s1, s2), t) |\\<in>| outgoing_transitions e s) =\n    (((s1, s2), t) |\\<in>| e \\<and> s1 = s)", "by (simp add: outgoing_transitions_def)"], ["", "lemma outgoing_transitions_deterministic:\n  \"\\<forall>s.\n    \\<forall>((s1, s2), t) |\\<in>| outgoing_transitions e s.\n      \\<forall>((s1', s2'), t') |\\<in>| outgoing_transitions e s.\n        s2 \\<noteq> s2' \\<or> t \\<noteq> t' \\<longrightarrow> Label t = Label t' \\<longrightarrow> \\<not> choice t t' \\<Longrightarrow> deterministic e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>s.\n       \\<forall>((s1, s2), t)|\\<in>|outgoing_transitions e s.\n          \\<forall>((s1', s2'), t')|\\<in>|outgoing_transitions e s.\n             s2 \\<noteq> s2' \\<or> t \\<noteq> t' \\<longrightarrow>\n             Label t = Label t' \\<longrightarrow>\n             \\<not> choice t t' \\<Longrightarrow>\n    deterministic e", "apply (rule deterministic_if)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>s.\n       \\<forall>((s1, s2), t)|\\<in>|outgoing_transitions e s.\n          \\<forall>((s1', s2'), t')|\\<in>|outgoing_transitions e s.\n             s2 \\<noteq> s2' \\<or> t \\<noteq> t' \\<longrightarrow>\n             Label t = Label t' \\<longrightarrow>\n             \\<not> choice t t' \\<Longrightarrow>\n    \\<nexists>s l i r d1 d2 t1 t2.\n       (d1 \\<noteq> d2 \\<or> t1 \\<noteq> t2) \\<and>\n       ((s, d1), t1) |\\<in>| e \\<and>\n       ((s, d2), t2) |\\<in>| e \\<and>\n       Label t1 = Label t2 \\<and>\n       can_take_transition t1 i r \\<and> can_take_transition t2 i r", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>s.\n       \\<forall>((s1, s2), t)|\\<in>|outgoing_transitions e s.\n          \\<forall>((s1', s2'), t')|\\<in>|outgoing_transitions e s.\n             (s2 = s2' \\<longrightarrow> t \\<noteq> t') \\<longrightarrow>\n             Label t = Label t' \\<longrightarrow>\n             \\<not> choice t t' \\<Longrightarrow>\n    \\<forall>s i r d1 d2 t1.\n       can_take_transition t1 i r \\<longrightarrow>\n       (\\<forall>t2.\n           Label t1 = Label t2 \\<longrightarrow>\n           ((s, d2), t2) |\\<in>| e \\<longrightarrow>\n           ((s, d1), t1) |\\<in>| e \\<longrightarrow>\n           d1 = d2 \\<and> t1 = t2 \\<or> \\<not> can_take_transition t2 i r)", "apply (rule allI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<forall>s.\n          \\<forall>((s1, s2), t)|\\<in>|outgoing_transitions e s.\n             \\<forall>((s1', s2'), t')|\\<in>|outgoing_transitions e s.\n                (s2 = s2' \\<longrightarrow> t \\<noteq> t') \\<longrightarrow>\n                Label t = Label t' \\<longrightarrow>\n                \\<not> choice t t' \\<Longrightarrow>\n       \\<forall>i r d1 d2 t1.\n          can_take_transition t1 i r \\<longrightarrow>\n          (\\<forall>t2.\n              Label t1 = Label t2 \\<longrightarrow>\n              ((s, d2), t2) |\\<in>| e \\<longrightarrow>\n              ((s, d1), t1) |\\<in>| e \\<longrightarrow>\n              d1 = d2 \\<and> t1 = t2 \\<or>\n              \\<not> can_take_transition t2 i r)", "subgoal for s"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>s.\n       \\<forall>((s1, s2), t)|\\<in>|outgoing_transitions e s.\n          \\<forall>((s1', s2'), t')|\\<in>|outgoing_transitions e s.\n             (s2 = s2' \\<longrightarrow> t \\<noteq> t') \\<longrightarrow>\n             Label t = Label t' \\<longrightarrow>\n             \\<not> choice t t' \\<Longrightarrow>\n    \\<forall>i r d1 d2 t1.\n       can_take_transition t1 i r \\<longrightarrow>\n       (\\<forall>t2.\n           Label t1 = Label t2 \\<longrightarrow>\n           ((s, d2), t2) |\\<in>| e \\<longrightarrow>\n           ((s, d1), t1) |\\<in>| e \\<longrightarrow>\n           d1 = d2 \\<and> t1 = t2 \\<or> \\<not> can_take_transition t2 i r)", "apply (erule_tac x=s in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>((s1, s2), t)|\\<in>|outgoing_transitions e s.\n       \\<forall>((s1', s2'), t')|\\<in>|outgoing_transitions e s.\n          (s2 = s2' \\<longrightarrow> t \\<noteq> t') \\<longrightarrow>\n          Label t = Label t' \\<longrightarrow>\n          \\<not> choice t t' \\<Longrightarrow>\n    \\<forall>i r d1 d2 t1.\n       can_take_transition t1 i r \\<longrightarrow>\n       (\\<forall>t2.\n           Label t1 = Label t2 \\<longrightarrow>\n           ((s, d2), t2) |\\<in>| e \\<longrightarrow>\n           ((s, d1), t1) |\\<in>| e \\<longrightarrow>\n           d1 = d2 \\<and> t1 = t2 \\<or> \\<not> can_take_transition t2 i r)", "apply (simp add: fBall_def Ball_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a b ba.\n       ((a, b), ba) \\<in> fset (outgoing_transitions e s) \\<longrightarrow>\n       (\\<forall>a bb bc.\n           ((a, bb), bc)\n           \\<in> fset (outgoing_transitions e s) \\<longrightarrow>\n           (b = bb \\<longrightarrow> ba \\<noteq> bc) \\<longrightarrow>\n           Label ba = Label bc \\<longrightarrow>\n           \\<not> choice ba bc) \\<Longrightarrow>\n    \\<forall>i r d1 d2 t1.\n       can_take_transition t1 i r \\<longrightarrow>\n       (\\<forall>t2.\n           Label t1 = Label t2 \\<longrightarrow>\n           ((s, d2), t2) |\\<in>| e \\<longrightarrow>\n           ((s, d1), t1) |\\<in>| e \\<longrightarrow>\n           d1 = d2 \\<and> t1 = t2 \\<or> \\<not> can_take_transition t2 i r)", "apply (rule allI)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i r d1 d2 t1.\n       \\<forall>a b ba.\n          ((a, b), ba)\n          \\<in> fset (outgoing_transitions e s) \\<longrightarrow>\n          (\\<forall>a bb bc.\n              ((a, bb), bc)\n              \\<in> fset (outgoing_transitions e s) \\<longrightarrow>\n              (b = bb \\<longrightarrow> ba \\<noteq> bc) \\<longrightarrow>\n              Label ba = Label bc \\<longrightarrow>\n              \\<not> choice ba bc) \\<Longrightarrow>\n       can_take_transition t1 i r \\<longrightarrow>\n       (\\<forall>t2.\n           Label t1 = Label t2 \\<longrightarrow>\n           ((s, d2), t2) |\\<in>| e \\<longrightarrow>\n           ((s, d1), t1) |\\<in>| e \\<longrightarrow>\n           d1 = d2 \\<and> t1 = t2 \\<or> \\<not> can_take_transition t2 i r)", "subgoal for i r d1 d2 t1"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a b ba.\n       ((a, b), ba) \\<in> fset (outgoing_transitions e s) \\<longrightarrow>\n       (\\<forall>a bb bc.\n           ((a, bb), bc)\n           \\<in> fset (outgoing_transitions e s) \\<longrightarrow>\n           (b = bb \\<longrightarrow> ba \\<noteq> bc) \\<longrightarrow>\n           Label ba = Label bc \\<longrightarrow>\n           \\<not> choice ba bc) \\<Longrightarrow>\n    can_take_transition t1 i r \\<longrightarrow>\n    (\\<forall>t2.\n        Label t1 = Label t2 \\<longrightarrow>\n        ((s, d2), t2) |\\<in>| e \\<longrightarrow>\n        ((s, d1), t1) |\\<in>| e \\<longrightarrow>\n        d1 = d2 \\<and> t1 = t2 \\<or> \\<not> can_take_transition t2 i r)", "apply (erule_tac x=s in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>b ba.\n       ((s, b), ba) \\<in> fset (outgoing_transitions e s) \\<longrightarrow>\n       (\\<forall>a bb bc.\n           ((a, bb), bc)\n           \\<in> fset (outgoing_transitions e s) \\<longrightarrow>\n           (b = bb \\<longrightarrow> ba \\<noteq> bc) \\<longrightarrow>\n           Label ba = Label bc \\<longrightarrow>\n           \\<not> choice ba bc) \\<Longrightarrow>\n    can_take_transition t1 i r \\<longrightarrow>\n    (\\<forall>t2.\n        Label t1 = Label t2 \\<longrightarrow>\n        ((s, d2), t2) |\\<in>| e \\<longrightarrow>\n        ((s, d1), t1) |\\<in>| e \\<longrightarrow>\n        d1 = d2 \\<and> t1 = t2 \\<or> \\<not> can_take_transition t2 i r)", "apply (erule_tac x=d1 in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>b.\n       ((s, d1), b) \\<in> fset (outgoing_transitions e s) \\<longrightarrow>\n       (\\<forall>a ba bb.\n           ((a, ba), bb)\n           \\<in> fset (outgoing_transitions e s) \\<longrightarrow>\n           (d1 = ba \\<longrightarrow> b \\<noteq> bb) \\<longrightarrow>\n           Label b = Label bb \\<longrightarrow>\n           \\<not> choice b bb) \\<Longrightarrow>\n    can_take_transition t1 i r \\<longrightarrow>\n    (\\<forall>t2.\n        Label t1 = Label t2 \\<longrightarrow>\n        ((s, d2), t2) |\\<in>| e \\<longrightarrow>\n        ((s, d1), t1) |\\<in>| e \\<longrightarrow>\n        d1 = d2 \\<and> t1 = t2 \\<or> \\<not> can_take_transition t2 i r)", "apply (erule_tac x=t1 in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((s, d1), t1) \\<in> fset (outgoing_transitions e s) \\<longrightarrow>\n    (\\<forall>a b ba.\n        ((a, b), ba) \\<in> fset (outgoing_transitions e s) \\<longrightarrow>\n        (d1 = b \\<longrightarrow> t1 \\<noteq> ba) \\<longrightarrow>\n        Label t1 = Label ba \\<longrightarrow>\n        \\<not> choice t1 ba) \\<Longrightarrow>\n    can_take_transition t1 i r \\<longrightarrow>\n    (\\<forall>t2.\n        Label t1 = Label t2 \\<longrightarrow>\n        ((s, d2), t2) |\\<in>| e \\<longrightarrow>\n        ((s, d1), t1) |\\<in>| e \\<longrightarrow>\n        d1 = d2 \\<and> t1 = t2 \\<or> \\<not> can_take_transition t2 i r)", "apply (rule impI, rule allI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>t2.\n       \\<lbrakk>((s, d1), t1)\n                \\<in> fset (outgoing_transitions e s) \\<longrightarrow>\n                (\\<forall>a b ba.\n                    ((a, b), ba)\n                    \\<in> fset (outgoing_transitions e s) \\<longrightarrow>\n                    (d1 = b \\<longrightarrow>\n                     t1 \\<noteq> ba) \\<longrightarrow>\n                    Label t1 = Label ba \\<longrightarrow>\n                    \\<not> choice t1 ba);\n        can_take_transition t1 i r\\<rbrakk>\n       \\<Longrightarrow> Label t1 = Label t2 \\<longrightarrow>\n                         ((s, d2), t2) |\\<in>| e \\<longrightarrow>\n                         ((s, d1), t1) |\\<in>| e \\<longrightarrow>\n                         d1 = d2 \\<and> t1 = t2 \\<or>\n                         \\<not> can_take_transition t2 i r", "subgoal for t2"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>((s, d1), t1)\n             \\<in> fset (outgoing_transitions e s) \\<longrightarrow>\n             (\\<forall>a b ba.\n                 ((a, b), ba)\n                 \\<in> fset (outgoing_transitions e s) \\<longrightarrow>\n                 (d1 = b \\<longrightarrow> t1 \\<noteq> ba) \\<longrightarrow>\n                 Label t1 = Label ba \\<longrightarrow> \\<not> choice t1 ba);\n     can_take_transition t1 i r\\<rbrakk>\n    \\<Longrightarrow> Label t1 = Label t2 \\<longrightarrow>\n                      ((s, d2), t2) |\\<in>| e \\<longrightarrow>\n                      ((s, d1), t1) |\\<in>| e \\<longrightarrow>\n                      d1 = d2 \\<and> t1 = t2 \\<or>\n                      \\<not> can_take_transition t2 i r", "apply (case_tac \"((s, d1), t1) \\<in> fset (outgoing_transitions e s)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>((s, d1), t1)\n             \\<in> fset (outgoing_transitions e s) \\<longrightarrow>\n             (\\<forall>a b ba.\n                 ((a, b), ba)\n                 \\<in> fset (outgoing_transitions e s) \\<longrightarrow>\n                 (d1 = b \\<longrightarrow> t1 \\<noteq> ba) \\<longrightarrow>\n                 Label t1 = Label ba \\<longrightarrow> \\<not> choice t1 ba);\n     can_take_transition t1 i r;\n     ((s, d1), t1) \\<in> fset (outgoing_transitions e s)\\<rbrakk>\n    \\<Longrightarrow> Label t1 = Label t2 \\<longrightarrow>\n                      ((s, d2), t2) |\\<in>| e \\<longrightarrow>\n                      ((s, d1), t1) |\\<in>| e \\<longrightarrow>\n                      d1 = d2 \\<and> t1 = t2 \\<or>\n                      \\<not> can_take_transition t2 i r\n 2. \\<lbrakk>((s, d1), t1)\n             \\<in> fset (outgoing_transitions e s) \\<longrightarrow>\n             (\\<forall>a b ba.\n                 ((a, b), ba)\n                 \\<in> fset (outgoing_transitions e s) \\<longrightarrow>\n                 (d1 = b \\<longrightarrow> t1 \\<noteq> ba) \\<longrightarrow>\n                 Label t1 = Label ba \\<longrightarrow> \\<not> choice t1 ba);\n     can_take_transition t1 i r;\n     ((s, d1), t1) \\<notin> fset (outgoing_transitions e s)\\<rbrakk>\n    \\<Longrightarrow> Label t1 = Label t2 \\<longrightarrow>\n                      ((s, d2), t2) |\\<in>| e \\<longrightarrow>\n                      ((s, d1), t1) |\\<in>| e \\<longrightarrow>\n                      d1 = d2 \\<and> t1 = t2 \\<or>\n                      \\<not> can_take_transition t2 i r", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>a b ba.\n                ((a, b), ba)\n                \\<in> fset (outgoing_transitions e s) \\<longrightarrow>\n                (d1 = b \\<longrightarrow> t1 \\<noteq> ba) \\<longrightarrow>\n                Label t1 = Label ba \\<longrightarrow> \\<not> choice t1 ba;\n     can_take_transition t1 i r;\n     ((s, d1), t1) \\<in> fset (outgoing_transitions e s)\\<rbrakk>\n    \\<Longrightarrow> Label t1 = Label t2 \\<longrightarrow>\n                      ((s, d2), t2) |\\<in>| e \\<longrightarrow>\n                      ((s, d1), t1) |\\<in>| e \\<longrightarrow>\n                      d1 = d2 \\<and> t1 = t2 \\<or>\n                      \\<not> can_take_transition t2 i r\n 2. \\<lbrakk>((s, d1), t1)\n             \\<in> fset (outgoing_transitions e s) \\<longrightarrow>\n             (\\<forall>a b ba.\n                 ((a, b), ba)\n                 \\<in> fset (outgoing_transitions e s) \\<longrightarrow>\n                 (d1 = b \\<longrightarrow> t1 \\<noteq> ba) \\<longrightarrow>\n                 Label t1 = Label ba \\<longrightarrow> \\<not> choice t1 ba);\n     can_take_transition t1 i r;\n     ((s, d1), t1) \\<notin> fset (outgoing_transitions e s)\\<rbrakk>\n    \\<Longrightarrow> Label t1 = Label t2 \\<longrightarrow>\n                      ((s, d2), t2) |\\<in>| e \\<longrightarrow>\n                      ((s, d1), t1) |\\<in>| e \\<longrightarrow>\n                      d1 = d2 \\<and> t1 = t2 \\<or>\n                      \\<not> can_take_transition t2 i r", "apply (erule_tac x=s in allE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>can_take_transition t1 i r;\n     ((s, d1), t1) \\<in> fset (outgoing_transitions e s);\n     \\<forall>b ba.\n        ((s, b), ba) \\<in> fset (outgoing_transitions e s) \\<longrightarrow>\n        (d1 = b \\<longrightarrow> t1 \\<noteq> ba) \\<longrightarrow>\n        Label t1 = Label ba \\<longrightarrow> \\<not> choice t1 ba\\<rbrakk>\n    \\<Longrightarrow> Label t1 = Label t2 \\<longrightarrow>\n                      ((s, d2), t2) |\\<in>| e \\<longrightarrow>\n                      ((s, d1), t1) |\\<in>| e \\<longrightarrow>\n                      d1 = d2 \\<and> t1 = t2 \\<or>\n                      \\<not> can_take_transition t2 i r\n 2. \\<lbrakk>((s, d1), t1)\n             \\<in> fset (outgoing_transitions e s) \\<longrightarrow>\n             (\\<forall>a b ba.\n                 ((a, b), ba)\n                 \\<in> fset (outgoing_transitions e s) \\<longrightarrow>\n                 (d1 = b \\<longrightarrow> t1 \\<noteq> ba) \\<longrightarrow>\n                 Label t1 = Label ba \\<longrightarrow> \\<not> choice t1 ba);\n     can_take_transition t1 i r;\n     ((s, d1), t1) \\<notin> fset (outgoing_transitions e s)\\<rbrakk>\n    \\<Longrightarrow> Label t1 = Label t2 \\<longrightarrow>\n                      ((s, d2), t2) |\\<in>| e \\<longrightarrow>\n                      ((s, d1), t1) |\\<in>| e \\<longrightarrow>\n                      d1 = d2 \\<and> t1 = t2 \\<or>\n                      \\<not> can_take_transition t2 i r", "apply (erule_tac x=d2 in allE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>can_take_transition t1 i r;\n     ((s, d1), t1) \\<in> fset (outgoing_transitions e s);\n     \\<forall>b.\n        ((s, d2), b) \\<in> fset (outgoing_transitions e s) \\<longrightarrow>\n        (d1 = d2 \\<longrightarrow> t1 \\<noteq> b) \\<longrightarrow>\n        Label t1 = Label b \\<longrightarrow> \\<not> choice t1 b\\<rbrakk>\n    \\<Longrightarrow> Label t1 = Label t2 \\<longrightarrow>\n                      ((s, d2), t2) |\\<in>| e \\<longrightarrow>\n                      ((s, d1), t1) |\\<in>| e \\<longrightarrow>\n                      d1 = d2 \\<and> t1 = t2 \\<or>\n                      \\<not> can_take_transition t2 i r\n 2. \\<lbrakk>((s, d1), t1)\n             \\<in> fset (outgoing_transitions e s) \\<longrightarrow>\n             (\\<forall>a b ba.\n                 ((a, b), ba)\n                 \\<in> fset (outgoing_transitions e s) \\<longrightarrow>\n                 (d1 = b \\<longrightarrow> t1 \\<noteq> ba) \\<longrightarrow>\n                 Label t1 = Label ba \\<longrightarrow> \\<not> choice t1 ba);\n     can_take_transition t1 i r;\n     ((s, d1), t1) \\<notin> fset (outgoing_transitions e s)\\<rbrakk>\n    \\<Longrightarrow> Label t1 = Label t2 \\<longrightarrow>\n                      ((s, d2), t2) |\\<in>| e \\<longrightarrow>\n                      ((s, d1), t1) |\\<in>| e \\<longrightarrow>\n                      d1 = d2 \\<and> t1 = t2 \\<or>\n                      \\<not> can_take_transition t2 i r", "apply (erule_tac x=t2 in allE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>can_take_transition t1 i r;\n     ((s, d1), t1) \\<in> fset (outgoing_transitions e s);\n     ((s, d2), t2) \\<in> fset (outgoing_transitions e s) \\<longrightarrow>\n     (d1 = d2 \\<longrightarrow> t1 \\<noteq> t2) \\<longrightarrow>\n     Label t1 = Label t2 \\<longrightarrow> \\<not> choice t1 t2\\<rbrakk>\n    \\<Longrightarrow> Label t1 = Label t2 \\<longrightarrow>\n                      ((s, d2), t2) |\\<in>| e \\<longrightarrow>\n                      ((s, d1), t1) |\\<in>| e \\<longrightarrow>\n                      d1 = d2 \\<and> t1 = t2 \\<or>\n                      \\<not> can_take_transition t2 i r\n 2. \\<lbrakk>((s, d1), t1)\n             \\<in> fset (outgoing_transitions e s) \\<longrightarrow>\n             (\\<forall>a b ba.\n                 ((a, b), ba)\n                 \\<in> fset (outgoing_transitions e s) \\<longrightarrow>\n                 (d1 = b \\<longrightarrow> t1 \\<noteq> ba) \\<longrightarrow>\n                 Label t1 = Label ba \\<longrightarrow> \\<not> choice t1 ba);\n     can_take_transition t1 i r;\n     ((s, d1), t1) \\<notin> fset (outgoing_transitions e s)\\<rbrakk>\n    \\<Longrightarrow> Label t1 = Label t2 \\<longrightarrow>\n                      ((s, d2), t2) |\\<in>| e \\<longrightarrow>\n                      ((s, d1), t1) |\\<in>| e \\<longrightarrow>\n                      d1 = d2 \\<and> t1 = t2 \\<or>\n                      \\<not> can_take_transition t2 i r", "apply (simp add: outgoing_transitions_def choice_def can_take)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>length i = Arity t1 \\<and>\n             apply_guards (Guards t1) (join_ir i r);\n     ((s, d1), t1) \\<in> fset e;\n     ((s, d2), t2) \\<in> fset e \\<longrightarrow>\n     (d1 = d2 \\<longrightarrow> t1 \\<noteq> t2) \\<longrightarrow>\n     Label t1 = Label t2 \\<longrightarrow>\n     (\\<forall>i r.\n         apply_guards (Guards t1) (join_ir i r) \\<longrightarrow>\n         \\<not> apply_guards (Guards t2) (join_ir i r))\\<rbrakk>\n    \\<Longrightarrow> Label t1 = Label t2 \\<longrightarrow>\n                      ((s, d2), t2) |\\<in>| e \\<longrightarrow>\n                      ((s, d1), t1) |\\<in>| e \\<longrightarrow>\n                      Arity t1 = Arity t2 \\<longrightarrow>\n                      d1 = d2 \\<and> t1 = t2 \\<or>\n                      \\<not> apply_guards (Guards t2) (join_ir i r)\n 2. \\<lbrakk>((s, d1), t1)\n             \\<in> fset (outgoing_transitions e s) \\<longrightarrow>\n             (\\<forall>a b ba.\n                 ((a, b), ba)\n                 \\<in> fset (outgoing_transitions e s) \\<longrightarrow>\n                 (d1 = b \\<longrightarrow> t1 \\<noteq> ba) \\<longrightarrow>\n                 Label t1 = Label ba \\<longrightarrow> \\<not> choice t1 ba);\n     can_take_transition t1 i r;\n     ((s, d1), t1) \\<notin> fset (outgoing_transitions e s)\\<rbrakk>\n    \\<Longrightarrow> Label t1 = Label t2 \\<longrightarrow>\n                      ((s, d2), t2) |\\<in>| e \\<longrightarrow>\n                      ((s, d1), t1) |\\<in>| e \\<longrightarrow>\n                      d1 = d2 \\<and> t1 = t2 \\<or>\n                      \\<not> can_take_transition t2 i r", "apply (meson fmember_implies_member)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>((s, d1), t1)\n             \\<in> fset (outgoing_transitions e s) \\<longrightarrow>\n             (\\<forall>a b ba.\n                 ((a, b), ba)\n                 \\<in> fset (outgoing_transitions e s) \\<longrightarrow>\n                 (d1 = b \\<longrightarrow> t1 \\<noteq> ba) \\<longrightarrow>\n                 Label t1 = Label ba \\<longrightarrow> \\<not> choice t1 ba);\n     can_take_transition t1 i r;\n     ((s, d1), t1) \\<notin> fset (outgoing_transitions e s)\\<rbrakk>\n    \\<Longrightarrow> Label t1 = Label t2 \\<longrightarrow>\n                      ((s, d2), t2) |\\<in>| e \\<longrightarrow>\n                      ((s, d1), t1) |\\<in>| e \\<longrightarrow>\n                      d1 = d2 \\<and> t1 = t2 \\<or>\n                      \\<not> can_take_transition t2 i r", "apply (simp add: outgoing_transitions_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>can_take_transition t1 i r;\n     ((s, d1), t1) \\<notin> fset e\\<rbrakk>\n    \\<Longrightarrow> Label t1 = Label t2 \\<longrightarrow>\n                      ((s, d2), t2) |\\<in>| e \\<longrightarrow>\n                      ((s, d1), t1) |\\<in>| e \\<longrightarrow>\n                      d1 = d2 \\<and> t1 = t2 \\<or>\n                      \\<not> can_take_transition t2 i r", "by (meson fmember_implies_member)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma outgoing_transitions_deterministic2: \"(\\<And>s a b ba aa bb bc.\n       ((a, b), ba) |\\<in>| outgoing_transitions e s \\<Longrightarrow>\n       ((aa, bb), bc) |\\<in>| (outgoing_transitions e s) - {|((a, b), ba)|} \\<Longrightarrow> b \\<noteq> bb \\<or> ba \\<noteq> bc \\<Longrightarrow> \\<not>choice ba bc)\n        \\<Longrightarrow> deterministic e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>s a b ba aa bb bc.\n        \\<lbrakk>((a, b), ba) |\\<in>| outgoing_transitions e s;\n         ((aa, bb), bc) |\\<in>|\n         outgoing_transitions e s |-| {|((a, b), ba)|};\n         b \\<noteq> bb \\<or> ba \\<noteq> bc\\<rbrakk>\n        \\<Longrightarrow> \\<not> choice ba bc) \\<Longrightarrow>\n    deterministic e", "apply (rule outgoing_transitions_deterministic)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>s a b ba aa bb bc.\n        \\<lbrakk>((a, b), ba) |\\<in>| outgoing_transitions e s;\n         ((aa, bb), bc) |\\<in>|\n         outgoing_transitions e s |-| {|((a, b), ba)|};\n         b \\<noteq> bb \\<or> ba \\<noteq> bc\\<rbrakk>\n        \\<Longrightarrow> \\<not> choice ba bc) \\<Longrightarrow>\n    \\<forall>s.\n       \\<forall>((s1, s2), t)|\\<in>|outgoing_transitions e s.\n          \\<forall>((s1', s2'), t')|\\<in>|outgoing_transitions e s.\n             s2 \\<noteq> s2' \\<or> t \\<noteq> t' \\<longrightarrow>\n             Label t = Label t' \\<longrightarrow> \\<not> choice t t'", "by blast"], ["", "lemma outgoing_transitions_fprod_deterministic:\n\"(\\<And>s b ba bb bc.\n(((s, b), ba), ((s, bb), bc)) \\<in> fset (outgoing_transitions e s) \\<times> fset (outgoing_transitions e s)\n\\<Longrightarrow> b \\<noteq> bb \\<or> ba \\<noteq> bc \\<Longrightarrow> Label ba = Label bc \\<Longrightarrow> \\<not>choice ba bc)\n\\<Longrightarrow> deterministic e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>s b ba bb bc.\n        \\<lbrakk>(((s, b), ba), (s, bb), bc)\n                 \\<in> fset (outgoing_transitions e s) \\<times>\n                       fset (outgoing_transitions e s);\n         b \\<noteq> bb \\<or> ba \\<noteq> bc; Label ba = Label bc\\<rbrakk>\n        \\<Longrightarrow> \\<not> choice ba bc) \\<Longrightarrow>\n    deterministic e", "apply (rule outgoing_transitions_deterministic)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>s b ba bb bc.\n        \\<lbrakk>(((s, b), ba), (s, bb), bc)\n                 \\<in> fset (outgoing_transitions e s) \\<times>\n                       fset (outgoing_transitions e s);\n         b \\<noteq> bb \\<or> ba \\<noteq> bc; Label ba = Label bc\\<rbrakk>\n        \\<Longrightarrow> \\<not> choice ba bc) \\<Longrightarrow>\n    \\<forall>s.\n       \\<forall>((s1, s2), t)|\\<in>|outgoing_transitions e s.\n          \\<forall>((s1', s2'), t')|\\<in>|outgoing_transitions e s.\n             s2 \\<noteq> s2' \\<or> t \\<noteq> t' \\<longrightarrow>\n             Label t = Label t' \\<longrightarrow> \\<not> choice t t'", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s a b ba aa bb bc.\n       \\<lbrakk>\\<And>s b ba bb bc.\n                   \\<lbrakk>(((s, b), ba), (s, bb), bc)\n                            \\<in> fset (outgoing_transitions e s) \\<times>\n                                  fset (outgoing_transitions e s);\n                    b \\<noteq> bb \\<or> ba \\<noteq> bc;\n                    Label ba = Label bc\\<rbrakk>\n                   \\<Longrightarrow> \\<not> choice ba bc;\n        ((a, b), ba) |\\<in>| outgoing_transitions e s;\n        ((aa, bb), bc) |\\<in>| outgoing_transitions e s;\n        b \\<noteq> bb \\<or> ba \\<noteq> bc; Label ba = Label bc;\n        choice ba bc\\<rbrakk>\n       \\<Longrightarrow> False", "by (metis SigmaI fmember_implies_member in_outgoing)"], ["", "text\\<open>The \\texttt{random\\_member} function returns a random member from a finite set, or\n\\texttt{None}, if the set is empty.\\<close>"], ["", "definition random_member :: \"'a fset \\<Rightarrow> 'a option\" where\n  \"random_member f = (if f = {||} then None else Some (Eps (\\<lambda>x. x |\\<in>| f)))\""], ["", "lemma random_member_nonempty: \"s \\<noteq> {||} = (random_member s \\<noteq> None)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (s \\<noteq> {||}) = (random_member s \\<noteq> None)", "by (simp add: random_member_def)"], ["", "lemma random_member_singleton [simp]: \"random_member {|a|} = Some a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. random_member {|a|} = Some a", "by (simp add: random_member_def)"], ["", "lemma random_member_is_member:\n  \"random_member ss = Some s \\<Longrightarrow> s |\\<in>| ss\""], ["proof (prove)\ngoal (1 subgoal):\n 1. random_member ss = Some s \\<Longrightarrow> s |\\<in>| ss", "apply (simp add: random_member_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if ss = {||} then None else Some (SOME x. x |\\<in>| ss)) =\n    Some s \\<Longrightarrow>\n    s |\\<in>| ss", "by (metis equalsffemptyI option.distinct(1) option.inject verit_sko_ex_indirect)"], ["", "lemma random_member_None[simp]: \"random_member ss = None = (ss = {||})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (random_member ss = None) = (ss = {||})", "by (simp add: random_member_def)"], ["", "lemma random_member_empty[simp]: \"random_member {||} = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. random_member {||} = None", "by simp"], ["", "definition step :: \"transition_matrix \\<Rightarrow> cfstate \\<Rightarrow> registers \\<Rightarrow> label \\<Rightarrow> inputs \\<Rightarrow> (transition \\<times> cfstate \\<times> outputs \\<times> registers) option\" where\n  \"step e s r l i = (case random_member (possible_steps e s r l i) of\n      None \\<Rightarrow> None |\n      Some (s', t) \\<Rightarrow>  Some (t, s', evaluate_outputs t i r, evaluate_updates t i r)\n  )\""], ["", "lemma possible_steps_not_empty_iff:\n  \"step e s r a b \\<noteq> None \\<Longrightarrow>\n   \\<exists>aa ba. (aa, ba) |\\<in>| possible_steps e s r a b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. step e s r a b \\<noteq> None \\<Longrightarrow>\n    \\<exists>aa ba. (aa, ba) |\\<in>| possible_steps e s r a b", "apply (simp add: step_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>aa aaa aaaa ba.\n       (case random_member (possible_steps e s r a b) of\n        None \\<Rightarrow> None\n        | Some (s', t) \\<Rightarrow>\n            Some (t, s', evaluate_outputs t b r, evaluate_updates t b r)) =\n       Some (aa, aaa, aaaa, ba) \\<Longrightarrow>\n    \\<exists>aa ba. (aa, ba) |\\<in>| possible_steps e s r a b", "apply (case_tac \"possible_steps e s r a b\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<exists>aa aaa aaaa ba.\n                (case random_member (possible_steps e s r a b) of\n                 None \\<Rightarrow> None\n                 | Some (s', t) \\<Rightarrow>\n                     Some\n                      (t, s', evaluate_outputs t b r,\n                       evaluate_updates t b r)) =\n                Some (aa, aaa, aaaa, ba);\n     possible_steps e s r a b = {||}\\<rbrakk>\n    \\<Longrightarrow> \\<exists>aa ba.\n                         (aa, ba) |\\<in>| possible_steps e s r a b\n 2. \\<And>x S'.\n       \\<lbrakk>\\<exists>aa aaa aaaa ba.\n                   (case random_member (possible_steps e s r a b) of\n                    None \\<Rightarrow> None\n                    | Some (s', t) \\<Rightarrow>\n                        Some\n                         (t, s', evaluate_outputs t b r,\n                          evaluate_updates t b r)) =\n                   Some (aa, aaa, aaaa, ba);\n        possible_steps e s r a b = finsert x S'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>aa ba.\n                            (aa, ba) |\\<in>| possible_steps e s r a b", "apply (simp add: random_member_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x S'.\n       \\<lbrakk>\\<exists>aa aaa aaaa ba.\n                   (case random_member (possible_steps e s r a b) of\n                    None \\<Rightarrow> None\n                    | Some (s', t) \\<Rightarrow>\n                        Some\n                         (t, s', evaluate_outputs t b r,\n                          evaluate_updates t b r)) =\n                   Some (aa, aaa, aaaa, ba);\n        possible_steps e s r a b = finsert x S'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>aa ba.\n                            (aa, ba) |\\<in>| possible_steps e s r a b", "by auto"], ["", "lemma step_member: \"step e s r l i = Some (t, s', p, r') \\<Longrightarrow> (s', t) |\\<in>| possible_steps e s r l i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. step e s r l i = Some (t, s', p, r') \\<Longrightarrow>\n    (s', t) |\\<in>| possible_steps e s r l i", "apply (simp add: step_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case random_member (possible_steps e s r l i) of\n     None \\<Rightarrow> None\n     | Some (s', t) \\<Rightarrow>\n         Some (t, s', evaluate_outputs t i r, evaluate_updates t i r)) =\n    Some (t, s', p, r') \\<Longrightarrow>\n    (s', t) |\\<in>| possible_steps e s r l i", "apply (case_tac \"random_member (possible_steps e s r l i)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>(case random_member (possible_steps e s r l i) of\n              None \\<Rightarrow> None\n              | Some (s', t) \\<Rightarrow>\n                  Some\n                   (t, s', evaluate_outputs t i r,\n                    evaluate_updates t i r)) =\n             Some (t, s', p, r');\n     random_member (possible_steps e s r l i) = None\\<rbrakk>\n    \\<Longrightarrow> (s', t) |\\<in>| possible_steps e s r l i\n 2. \\<And>a.\n       \\<lbrakk>(case random_member (possible_steps e s r l i) of\n                 None \\<Rightarrow> None\n                 | Some (s', t) \\<Rightarrow>\n                     Some\n                      (t, s', evaluate_outputs t i r,\n                       evaluate_updates t i r)) =\n                Some (t, s', p, r');\n        random_member (possible_steps e s r l i) = Some a\\<rbrakk>\n       \\<Longrightarrow> (s', t) |\\<in>| possible_steps e s r l i", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>(case random_member (possible_steps e s r l i) of\n                 None \\<Rightarrow> None\n                 | Some (s', t) \\<Rightarrow>\n                     Some\n                      (t, s', evaluate_outputs t i r,\n                       evaluate_updates t i r)) =\n                Some (t, s', p, r');\n        random_member (possible_steps e s r l i) = Some a\\<rbrakk>\n       \\<Longrightarrow> (s', t) |\\<in>| possible_steps e s r l i", "subgoal for a"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(case random_member (possible_steps e s r l i) of\n              None \\<Rightarrow> None\n              | Some (s', t) \\<Rightarrow>\n                  Some\n                   (t, s', evaluate_outputs t i r,\n                    evaluate_updates t i r)) =\n             Some (t, s', p, r');\n     random_member (possible_steps e s r l i) = Some a\\<rbrakk>\n    \\<Longrightarrow> (s', t) |\\<in>| possible_steps e s r l i", "by (case_tac a, simp add: random_member_is_member)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma step_outputs: \"step e s r l i = Some (t, s', p, r') \\<Longrightarrow> evaluate_outputs t i r = p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. step e s r l i = Some (t, s', p, r') \\<Longrightarrow>\n    evaluate_outputs t i r = p", "apply (simp add: step_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case random_member (possible_steps e s r l i) of\n     None \\<Rightarrow> None\n     | Some (s', t) \\<Rightarrow>\n         Some (t, s', evaluate_outputs t i r, evaluate_updates t i r)) =\n    Some (t, s', p, r') \\<Longrightarrow>\n    evaluate_outputs t i r = p", "apply (case_tac \"random_member (possible_steps e s r l i)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>(case random_member (possible_steps e s r l i) of\n              None \\<Rightarrow> None\n              | Some (s', t) \\<Rightarrow>\n                  Some\n                   (t, s', evaluate_outputs t i r,\n                    evaluate_updates t i r)) =\n             Some (t, s', p, r');\n     random_member (possible_steps e s r l i) = None\\<rbrakk>\n    \\<Longrightarrow> evaluate_outputs t i r = p\n 2. \\<And>a.\n       \\<lbrakk>(case random_member (possible_steps e s r l i) of\n                 None \\<Rightarrow> None\n                 | Some (s', t) \\<Rightarrow>\n                     Some\n                      (t, s', evaluate_outputs t i r,\n                       evaluate_updates t i r)) =\n                Some (t, s', p, r');\n        random_member (possible_steps e s r l i) = Some a\\<rbrakk>\n       \\<Longrightarrow> evaluate_outputs t i r = p", "by auto"], ["", "lemma step:\n  \"possibilities = (possible_steps e s r l i) \\<Longrightarrow>\n   random_member possibilities = Some (s', t) \\<Longrightarrow>\n   evaluate_outputs t i r = p \\<Longrightarrow>\n   evaluate_updates t i r = r' \\<Longrightarrow>\n   step e s r l i = Some (t, s', p, r')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>possibilities = possible_steps e s r l i;\n     random_member possibilities = Some (s', t); evaluate_outputs t i r = p;\n     evaluate_updates t i r = r'\\<rbrakk>\n    \\<Longrightarrow> step e s r l i = Some (t, s', p, r')", "by (simp add: step_def)"], ["", "lemma step_None: \"step e s r l i = None = (possible_steps e s r l i = {||})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (step e s r l i = None) = (possible_steps e s r l i = {||})", "by (simp add: step_def prod.case_eq_if random_member_def)"], ["", "lemma step_Some: \"step e s r l i = Some (t, s', p, r') =\n  (\n    random_member (possible_steps e s r l i) = Some (s', t) \\<and>\n    evaluate_outputs t i r = p \\<and>\n    evaluate_updates t i r = r'\n  )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (step e s r l i = Some (t, s', p, r')) =\n    (random_member (possible_steps e s r l i) = Some (s', t) \\<and>\n     evaluate_outputs t i r = p \\<and> evaluate_updates t i r = r')", "apply (simp add: step_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((case random_member (possible_steps e s r l i) of\n      None \\<Rightarrow> None\n      | Some (s', t) \\<Rightarrow>\n          Some (t, s', evaluate_outputs t i r, evaluate_updates t i r)) =\n     Some (t, s', p, r')) =\n    (random_member (possible_steps e s r l i) = Some (s', t) \\<and>\n     evaluate_outputs t i r = p \\<and> evaluate_updates t i r = r')", "apply (case_tac \"random_member (possible_steps e s r l i)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. random_member (possible_steps e s r l i) = None \\<Longrightarrow>\n    ((case random_member (possible_steps e s r l i) of\n      None \\<Rightarrow> None\n      | Some (s', t) \\<Rightarrow>\n          Some (t, s', evaluate_outputs t i r, evaluate_updates t i r)) =\n     Some (t, s', p, r')) =\n    (random_member (possible_steps e s r l i) = Some (s', t) \\<and>\n     evaluate_outputs t i r = p \\<and> evaluate_updates t i r = r')\n 2. \\<And>a.\n       random_member (possible_steps e s r l i) = Some a \\<Longrightarrow>\n       ((case random_member (possible_steps e s r l i) of\n         None \\<Rightarrow> None\n         | Some (s', t) \\<Rightarrow>\n             Some (t, s', evaluate_outputs t i r, evaluate_updates t i r)) =\n        Some (t, s', p, r')) =\n       (random_member (possible_steps e s r l i) = Some (s', t) \\<and>\n        evaluate_outputs t i r = p \\<and> evaluate_updates t i r = r')", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       random_member (possible_steps e s r l i) = Some a \\<Longrightarrow>\n       ((case random_member (possible_steps e s r l i) of\n         None \\<Rightarrow> None\n         | Some (s', t) \\<Rightarrow>\n             Some (t, s', evaluate_outputs t i r, evaluate_updates t i r)) =\n        Some (t, s', p, r')) =\n       (random_member (possible_steps e s r l i) = Some (s', t) \\<and>\n        evaluate_outputs t i r = p \\<and> evaluate_updates t i r = r')", "subgoal for a"], ["proof (prove)\ngoal (1 subgoal):\n 1. random_member (possible_steps e s r l i) = Some a \\<Longrightarrow>\n    ((case random_member (possible_steps e s r l i) of\n      None \\<Rightarrow> None\n      | Some (s', t) \\<Rightarrow>\n          Some (t, s', evaluate_outputs t i r, evaluate_updates t i r)) =\n     Some (t, s', p, r')) =\n    (random_member (possible_steps e s r l i) = Some (s', t) \\<and>\n     evaluate_outputs t i r = p \\<and> evaluate_updates t i r = r')", "by (case_tac a, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma no_possible_steps_1:\n  \"possible_steps e s r l i = {||} \\<Longrightarrow> step e s r l i = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. possible_steps e s r l i = {||} \\<Longrightarrow> step e s r l i = None", "by (simp add: step_def random_member_def)"], ["", "subsection\\<open>Execution Observation\\<close>"], ["", "text\\<open>One of the key features of this formalisation of EFSMs is their ability to produce\n\\emph{outputs}, which represent function return values. When action sequences are executed in an\nEFSM, they produce a corresponding \\emph{observation}.\\<close>"], ["", "text_raw\\<open>\\snip{observe}{1}{2}{%\\<close>"], ["", "fun observe_execution :: \"transition_matrix \\<Rightarrow> cfstate \\<Rightarrow> registers \\<Rightarrow> execution \\<Rightarrow> outputs list\" where\n  \"observe_execution _ _ _ [] = []\" |\n  \"observe_execution e s r ((l, i)#as)  = (\n    let viable = possible_steps e s r l i in\n    if viable = {||} then\n      []\n    else\n      let (s', t) = Eps (\\<lambda>x. x |\\<in>| viable) in\n      (evaluate_outputs t i r)#(observe_execution e s' (evaluate_updates t i r) as)\n    )\""], ["", "text_raw\\<open>}%endsnip\\<close>"], ["", "lemma observe_execution_step_def: \"observe_execution e s r ((l, i)#as)  = (\n    case step e s r l i of\n      None \\<Rightarrow> []|\n      Some (t, s', p, r') \\<Rightarrow> p#(observe_execution e s' r' as)\n    )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. observe_execution e s r ((l, i) # as) =\n    (case step e s r l i of None \\<Rightarrow> []\n     | Some (t, s', p, r') \\<Rightarrow> p # observe_execution e s' r' as)", "apply (simp add: step_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (let viable = possible_steps e s r l i\n     in if viable = {||} then []\n        else let (s', t) = SOME x. x |\\<in>| viable\n             in evaluate_outputs t i r #\n                observe_execution e s' (evaluate_updates t i r) as) =\n    (case case random_member (possible_steps e s r l i) of\n          None \\<Rightarrow> None\n          | Some (s', t) \\<Rightarrow>\n              Some\n               (t, s', evaluate_outputs t i r, evaluate_updates t i r) of\n     None \\<Rightarrow> []\n     | Some (t, s', p, r') \\<Rightarrow> p # observe_execution e s' r' as)", "apply (case_tac \"possible_steps e s r l i\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. possible_steps e s r l i = {||} \\<Longrightarrow>\n    (let viable = possible_steps e s r l i\n     in if viable = {||} then []\n        else let (s', t) = SOME x. x |\\<in>| viable\n             in evaluate_outputs t i r #\n                observe_execution e s' (evaluate_updates t i r) as) =\n    (case case random_member (possible_steps e s r l i) of\n          None \\<Rightarrow> None\n          | Some (s', t) \\<Rightarrow>\n              Some\n               (t, s', evaluate_outputs t i r, evaluate_updates t i r) of\n     None \\<Rightarrow> []\n     | Some (t, s', p, r') \\<Rightarrow> p # observe_execution e s' r' as)\n 2. \\<And>x S'.\n       possible_steps e s r l i = finsert x S' \\<Longrightarrow>\n       (let viable = possible_steps e s r l i\n        in if viable = {||} then []\n           else let (s', t) = SOME x. x |\\<in>| viable\n                in evaluate_outputs t i r #\n                   observe_execution e s' (evaluate_updates t i r) as) =\n       (case case random_member (possible_steps e s r l i) of\n             None \\<Rightarrow> None\n             | Some (s', t) \\<Rightarrow>\n                 Some\n                  (t, s', evaluate_outputs t i r, evaluate_updates t i r) of\n        None \\<Rightarrow> []\n        | Some (t, s', p, r') \\<Rightarrow>\n            p # observe_execution e s' r' as)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x S'.\n       possible_steps e s r l i = finsert x S' \\<Longrightarrow>\n       (let viable = possible_steps e s r l i\n        in if viable = {||} then []\n           else let (s', t) = SOME x. x |\\<in>| viable\n                in evaluate_outputs t i r #\n                   observe_execution e s' (evaluate_updates t i r) as) =\n       (case case random_member (possible_steps e s r l i) of\n             None \\<Rightarrow> None\n             | Some (s', t) \\<Rightarrow>\n                 Some\n                  (t, s', evaluate_outputs t i r, evaluate_updates t i r) of\n        None \\<Rightarrow> []\n        | Some (t, s', p, r') \\<Rightarrow>\n            p # observe_execution e s' r' as)", "subgoal for x S'"], ["proof (prove)\ngoal (1 subgoal):\n 1. possible_steps e s r l i = finsert x S' \\<Longrightarrow>\n    (let viable = possible_steps e s r l i\n     in if viable = {||} then []\n        else let (s', t) = SOME x. x |\\<in>| viable\n             in evaluate_outputs t i r #\n                observe_execution e s' (evaluate_updates t i r) as) =\n    (case case random_member (possible_steps e s r l i) of\n          None \\<Rightarrow> None\n          | Some (s', t) \\<Rightarrow>\n              Some\n               (t, s', evaluate_outputs t i r, evaluate_updates t i r) of\n     None \\<Rightarrow> []\n     | Some (t, s', p, r') \\<Rightarrow> p # observe_execution e s' r' as)", "apply (simp add: random_member_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. possible_steps e s r l i = finsert x S' \\<Longrightarrow>\n    (case SOME xa. xa = x \\<or> xa |\\<in>| S' of\n     (s', t) \\<Rightarrow>\n       evaluate_outputs t i r #\n       observe_execution e s' (evaluate_updates t i r) as) =\n    (case case SOME xa. xa = x \\<or> xa |\\<in>| S' of\n          (s', t) \\<Rightarrow>\n            Some (t, s', evaluate_outputs t i r, evaluate_updates t i r) of\n     None \\<Rightarrow> []\n     | Some (t, s', p, r') \\<Rightarrow> p # observe_execution e s' r' as)", "apply (case_tac \"SOME xa. xa = x \\<or> xa |\\<in>| S'\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>possible_steps e s r l i = finsert x S';\n        (SOME xa. xa = x \\<or> xa |\\<in>| S') = (a, b)\\<rbrakk>\n       \\<Longrightarrow> (case SOME xa. xa = x \\<or> xa |\\<in>| S' of\n                          (s', t) \\<Rightarrow>\n                            evaluate_outputs t i r #\n                            observe_execution e s' (evaluate_updates t i r)\n                             as) =\n                         (case case SOME xa. xa = x \\<or> xa |\\<in>| S' of\n                               (s', t) \\<Rightarrow>\n                                 Some\n                                  (t, s', evaluate_outputs t i r,\n                                   evaluate_updates t i r) of\n                          None \\<Rightarrow> []\n                          | Some (t, s', p, r') \\<Rightarrow>\n                              p # observe_execution e s' r' as)", "by simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma observe_execution_first_outputs_equiv:\n  \"observe_execution e1 s1 r1 ((l, i) # ts) = observe_execution e2 s2 r2 ((l, i) # ts) \\<Longrightarrow>\n   step e1 s1 r1 l i = Some (t, s', p, r') \\<Longrightarrow>\n   \\<exists>(s2', t2)|\\<in>|possible_steps e2 s2 r2 l i. evaluate_outputs t2 i r2 = p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>observe_execution e1 s1 r1 ((l, i) # ts) =\n             observe_execution e2 s2 r2 ((l, i) # ts);\n     step e1 s1 r1 l i = Some (t, s', p, r')\\<rbrakk>\n    \\<Longrightarrow> \\<exists>(s2', t2)|\\<in>|possible_steps e2 s2 r2 l i.\n                         evaluate_outputs t2 i r2 = p", "apply (simp only: observe_execution_step_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(case Some (t, s', p, r') of None \\<Rightarrow> []\n              | Some (t, s', p, r') \\<Rightarrow>\n                  p # observe_execution e1 s' r' ts) =\n             (case step e2 s2 r2 l i of None \\<Rightarrow> []\n              | Some (t, s', p, r') \\<Rightarrow>\n                  p # observe_execution e2 s' r' ts);\n     step e1 s1 r1 l i = Some (t, s', p, r')\\<rbrakk>\n    \\<Longrightarrow> \\<exists>(s2', t2)|\\<in>|possible_steps e2 s2 r2 l i.\n                         evaluate_outputs t2 i r2 = p", "apply (case_tac \"step e2 s2 r2 l i\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>(case Some (t, s', p, r') of None \\<Rightarrow> []\n              | Some (t, s', p, r') \\<Rightarrow>\n                  p # observe_execution e1 s' r' ts) =\n             (case step e2 s2 r2 l i of None \\<Rightarrow> []\n              | Some (t, s', p, r') \\<Rightarrow>\n                  p # observe_execution e2 s' r' ts);\n     step e1 s1 r1 l i = Some (t, s', p, r');\n     step e2 s2 r2 l i = None\\<rbrakk>\n    \\<Longrightarrow> \\<exists>(s2', t2)|\\<in>|possible_steps e2 s2 r2 l i.\n                         evaluate_outputs t2 i r2 = p\n 2. \\<And>a.\n       \\<lbrakk>(case Some (t, s', p, r') of None \\<Rightarrow> []\n                 | Some (t, s', p, r') \\<Rightarrow>\n                     p # observe_execution e1 s' r' ts) =\n                (case step e2 s2 r2 l i of None \\<Rightarrow> []\n                 | Some (t, s', p, r') \\<Rightarrow>\n                     p # observe_execution e2 s' r' ts);\n        step e1 s1 r1 l i = Some (t, s', p, r');\n        step e2 s2 r2 l i = Some a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>(s2', t2)\n                                  |\\<in>|possible_steps e2 s2 r2 l i.\n                            evaluate_outputs t2 i r2 = p", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>(case Some (t, s', p, r') of None \\<Rightarrow> []\n                 | Some (t, s', p, r') \\<Rightarrow>\n                     p # observe_execution e1 s' r' ts) =\n                (case step e2 s2 r2 l i of None \\<Rightarrow> []\n                 | Some (t, s', p, r') \\<Rightarrow>\n                     p # observe_execution e2 s' r' ts);\n        step e1 s1 r1 l i = Some (t, s', p, r');\n        step e2 s2 r2 l i = Some a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>(s2', t2)\n                                  |\\<in>|possible_steps e2 s2 r2 l i.\n                            evaluate_outputs t2 i r2 = p", "subgoal for a"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(case Some (t, s', p, r') of None \\<Rightarrow> []\n              | Some (t, s', p, r') \\<Rightarrow>\n                  p # observe_execution e1 s' r' ts) =\n             (case step e2 s2 r2 l i of None \\<Rightarrow> []\n              | Some (t, s', p, r') \\<Rightarrow>\n                  p # observe_execution e2 s' r' ts);\n     step e1 s1 r1 l i = Some (t, s', p, r');\n     step e2 s2 r2 l i = Some a\\<rbrakk>\n    \\<Longrightarrow> \\<exists>(s2', t2)|\\<in>|possible_steps e2 s2 r2 l i.\n                         evaluate_outputs t2 i r2 = p", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>p # observe_execution e1 s' r' ts =\n             (case a of\n              (t, s', p, r') \\<Rightarrow>\n                p # observe_execution e2 s' r' ts);\n     step e1 s1 r1 l i = Some (t, s', p, r');\n     step e2 s2 r2 l i = Some a\\<rbrakk>\n    \\<Longrightarrow> \\<exists>(s2', t2)|\\<in>|possible_steps e2 s2 r2 l i.\n                         evaluate_outputs t2 i r2 = p", "apply (case_tac a)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b c d.\n       \\<lbrakk>p # observe_execution e1 s' r' ts =\n                (case a of\n                 (t, s', p, r') \\<Rightarrow>\n                   p # observe_execution e2 s' r' ts);\n        step e1 s1 r1 l i = Some (t, s', p, r'); step e2 s2 r2 l i = Some a;\n        a = (aa, b, c, d)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>(s2', t2)\n                                  |\\<in>|possible_steps e2 s2 r2 l i.\n                            evaluate_outputs t2 i r2 = p", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b d.\n       \\<lbrakk>observe_execution e1 s' r' ts = observe_execution e2 b d ts;\n        step e1 s1 r1 l i = Some (t, s', p, r');\n        step e2 s2 r2 l i = Some (aa, b, p, d); a = (aa, b, p, d)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>(s2', t2)\n                                  |\\<in>|possible_steps e2 s2 r2 l i.\n                            evaluate_outputs t2 i r2 = p", "by (meson step_member case_prodI rev_fBexI step_outputs)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma observe_execution_step:\n  \"step e s r (fst h) (snd h) = Some (t, s', p, r') \\<Longrightarrow>\n   observe_execution e s' r' es = obs \\<Longrightarrow>\n   observe_execution e s r (h#es) = p#obs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>step e s r (fst h) (snd h) = Some (t, s', p, r');\n     observe_execution e s' r' es = obs\\<rbrakk>\n    \\<Longrightarrow> observe_execution e s r (h # es) = p # obs", "apply (cases h, simp add: step_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(case random_member (possible_steps e s r a b) of\n                 None \\<Rightarrow> None\n                 | Some (s', t) \\<Rightarrow>\n                     Some\n                      (t, s', evaluate_outputs t b r,\n                       evaluate_updates t b r)) =\n                Some (t, s', p, r');\n        observe_execution e s' r' es = obs; h = (a, b)\\<rbrakk>\n       \\<Longrightarrow> (let viable = possible_steps e s r a b\n                          in if viable = {||} then []\n                             else let (s', t) = SOME x. x |\\<in>| viable\n                                  in evaluate_outputs t b r #\n                                     observe_execution e s'\n(evaluate_updates t b r) es) =\n                         p # obs", "apply (case_tac \"possible_steps e s r a b = {||}\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>(case random_member (possible_steps e s r a b) of\n                 None \\<Rightarrow> None\n                 | Some (s', t) \\<Rightarrow>\n                     Some\n                      (t, s', evaluate_outputs t b r,\n                       evaluate_updates t b r)) =\n                Some (t, s', p, r');\n        observe_execution e s' r' es = obs; h = (a, b);\n        possible_steps e s r a b = {||}\\<rbrakk>\n       \\<Longrightarrow> (let viable = possible_steps e s r a b\n                          in if viable = {||} then []\n                             else let (s', t) = SOME x. x |\\<in>| viable\n                                  in evaluate_outputs t b r #\n                                     observe_execution e s'\n(evaluate_updates t b r) es) =\n                         p # obs\n 2. \\<And>a b.\n       \\<lbrakk>(case random_member (possible_steps e s r a b) of\n                 None \\<Rightarrow> None\n                 | Some (s', t) \\<Rightarrow>\n                     Some\n                      (t, s', evaluate_outputs t b r,\n                       evaluate_updates t b r)) =\n                Some (t, s', p, r');\n        observe_execution e s' r' es = obs; h = (a, b);\n        possible_steps e s r a b \\<noteq> {||}\\<rbrakk>\n       \\<Longrightarrow> (let viable = possible_steps e s r a b\n                          in if viable = {||} then []\n                             else let (s', t) = SOME x. x |\\<in>| viable\n                                  in evaluate_outputs t b r #\n                                     observe_execution e s'\n(evaluate_updates t b r) es) =\n                         p # obs", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(case random_member (possible_steps e s r a b) of\n                 None \\<Rightarrow> None\n                 | Some (s', t) \\<Rightarrow>\n                     Some\n                      (t, s', evaluate_outputs t b r,\n                       evaluate_updates t b r)) =\n                Some (t, s', p, r');\n        observe_execution e s' r' es = obs; h = (a, b);\n        possible_steps e s r a b \\<noteq> {||}\\<rbrakk>\n       \\<Longrightarrow> (let viable = possible_steps e s r a b\n                          in if viable = {||} then []\n                             else let (s', t) = SOME x. x |\\<in>| viable\n                                  in evaluate_outputs t b r #\n                                     observe_execution e s'\n(evaluate_updates t b r) es) =\n                         p # obs", "subgoal for a b"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(case random_member (possible_steps e s r a b) of\n              None \\<Rightarrow> None\n              | Some (s', t) \\<Rightarrow>\n                  Some\n                   (t, s', evaluate_outputs t b r,\n                    evaluate_updates t b r)) =\n             Some (t, s', p, r');\n     observe_execution e s' r' es = obs; h = (a, b);\n     possible_steps e s r a b \\<noteq> {||}\\<rbrakk>\n    \\<Longrightarrow> (let viable = possible_steps e s r a b\n                       in if viable = {||} then []\n                          else let (s', t) = SOME x. x |\\<in>| viable\n                               in evaluate_outputs t b r #\n                                  observe_execution e s'\n                                   (evaluate_updates t b r) es) =\n                      p # obs", "apply (case_tac \"SOME x. x |\\<in>| possible_steps e s r a b\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa ba.\n       \\<lbrakk>(case random_member (possible_steps e s r a b) of\n                 None \\<Rightarrow> None\n                 | Some (s', t) \\<Rightarrow>\n                     Some\n                      (t, s', evaluate_outputs t b r,\n                       evaluate_updates t b r)) =\n                Some (t, s', p, r');\n        observe_execution e s' r' es = obs; h = (a, b);\n        possible_steps e s r a b \\<noteq> {||};\n        (SOME x. x |\\<in>| possible_steps e s r a b) = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> (let viable = possible_steps e s r a b\n                          in if viable = {||} then []\n                             else let (s', t) = SOME x. x |\\<in>| viable\n                                  in evaluate_outputs t b r #\n                                     observe_execution e s'\n(evaluate_updates t b r) es) =\n                         p # obs", "by (simp add: random_member_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma observe_execution_possible_step:\n  \"possible_steps e s r (fst h) (snd h) = {|(s', t)|} \\<Longrightarrow>\n   apply_outputs (Outputs t) (join_ir (snd h) r) = p \\<Longrightarrow>\n   apply_updates (Updates t) (join_ir (snd h) r) r = r' \\<Longrightarrow>\n   observe_execution e s' r' es = obs \\<Longrightarrow>\n   observe_execution e s r (h#es) = p#obs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>possible_steps e s r (fst h) (snd h) = {|(s', t)|};\n     evaluate_outputs t (snd h) r = p; evaluate_updates t (snd h) r = r';\n     observe_execution e s' r' es = obs\\<rbrakk>\n    \\<Longrightarrow> observe_execution e s r (h # es) = p # obs", "by (simp add: observe_execution_step step)"], ["", "lemma observe_execution_no_possible_step:\n  \"possible_steps e s r (fst h) (snd h) = {||} \\<Longrightarrow>\n   observe_execution e s r (h#es) = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. possible_steps e s r (fst h) (snd h) = {||} \\<Longrightarrow>\n    observe_execution e s r (h # es) = []", "by (cases h, simp)"], ["", "lemma observe_execution_no_possible_steps:\n  \"possible_steps e1 s1 r1 (fst h) (snd h) = {||} \\<Longrightarrow>\n   possible_steps e2 s2 r2 (fst h) (snd h) = {||} \\<Longrightarrow>\n   (observe_execution e1 s1 r1 (h#t)) = (observe_execution e2 s2 r2 (h#t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>possible_steps e1 s1 r1 (fst h) (snd h) = {||};\n     possible_steps e2 s2 r2 (fst h) (snd h) = {||}\\<rbrakk>\n    \\<Longrightarrow> observe_execution e1 s1 r1 (h # t) =\n                      observe_execution e2 s2 r2 (h # t)", "by (simp add: observe_execution_no_possible_step)"], ["", "lemma observe_execution_one_possible_step:\n  \"possible_steps e1 s1 r (fst h) (snd h) = {|(s1', t1)|} \\<Longrightarrow>\n   possible_steps e2 s2 r (fst h) (snd h) = {|(s2', t2)|} \\<Longrightarrow>\n   apply_outputs (Outputs t1) (join_ir (snd h) r) = apply_outputs (Outputs t2) (join_ir (snd h) r) \\<Longrightarrow>\n\n   apply_updates (Updates t1) (join_ir (snd h) r) r = r' \\<Longrightarrow>\n   apply_updates (Updates t2) (join_ir (snd h) r) r = r' \\<Longrightarrow>\n   (observe_execution e1 s1' r' t) = (observe_execution e2 s2' r' t) \\<Longrightarrow>\n   (observe_execution e1 s1 r (h#t)) = (observe_execution e2 s2 r (h#t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>possible_steps e1 s1 r (fst h) (snd h) = {|(s1', t1)|};\n     possible_steps e2 s2 r (fst h) (snd h) = {|(s2', t2)|};\n     evaluate_outputs t1 (snd h) r = evaluate_outputs t2 (snd h) r;\n     evaluate_updates t1 (snd h) r = r'; evaluate_updates t2 (snd h) r = r';\n     observe_execution e1 s1' r' t = observe_execution e2 s2' r' t\\<rbrakk>\n    \\<Longrightarrow> observe_execution e1 s1 r (h # t) =\n                      observe_execution e2 s2 r (h # t)", "by (simp add: observe_execution_possible_step)"], ["", "subsubsection\\<open>Utilities\\<close>"], ["", "text\\<open>Here we define some utility functions to access the various key properties of a given EFSM.\\<close>"], ["", "definition max_reg :: \"transition_matrix \\<Rightarrow> nat option\" where\n  \"max_reg e = (let maxes = (fimage (\\<lambda>(_, t). Transition.max_reg t) e) in if maxes = {||} then None else fMax maxes)\""], ["", "definition enumerate_ints :: \"transition_matrix \\<Rightarrow> int set\" where\n  \"enumerate_ints e = \\<Union> (image (\\<lambda>(_, t). Transition.enumerate_ints t) (fset e))\""], ["", "definition max_int :: \"transition_matrix \\<Rightarrow> int\" where\n  \"max_int e = Max (insert 0 (enumerate_ints e))\""], ["", "definition max_output :: \"transition_matrix \\<Rightarrow> nat\" where\n  \"max_output e = fMax (fimage (\\<lambda>(_, t). length (Outputs t)) e)\""], ["", "definition all_regs :: \"transition_matrix \\<Rightarrow> nat set\" where\n  \"all_regs e = \\<Union> (image (\\<lambda>(_, t). enumerate_regs t) (fset e))\""], ["", "text_raw\\<open>\\snip{finiteRegs}{1}{2}{%\\<close>"], ["", "lemma finite_all_regs: \"finite (all_regs e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (all_regs e)", "text_raw\\<open>}%endsnip\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (all_regs e)", "apply (simp add: all_regs_def enumerate_regs_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>fset e.\n       finite\n        (case x of\n         (uu_, t) \\<Rightarrow>\n           \\<Union> (GExp.enumerate_regs ` set (Guards t)) \\<union>\n           \\<Union> (AExp.enumerate_regs ` set (Outputs t)) \\<union>\n           (\\<Union>x\\<in>set (Updates t).\n               case x of\n               (uu_, x) \\<Rightarrow> AExp.enumerate_regs x) \\<union>\n           (\\<Union>x\\<in>set (Updates t).\n               case x of (r, uu_) \\<Rightarrow> {r}))", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b ba.\n       ((a, b), ba) \\<in> fset e \\<Longrightarrow>\n       finite\n        (\\<Union> (GExp.enumerate_regs ` set (Guards ba)) \\<union>\n         \\<Union> (AExp.enumerate_regs ` set (Outputs ba)) \\<union>\n         (\\<Union>(uu_, y)\\<in>set (Updates ba).\n             AExp.enumerate_regs y)) \\<and>\n       finite (\\<Union>(r, uu_)\\<in>set (Updates ba). {r})", "apply standard"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b ba.\n       ((a, b), ba) \\<in> fset e \\<Longrightarrow>\n       finite\n        (\\<Union> (GExp.enumerate_regs ` set (Guards ba)) \\<union>\n         \\<Union> (AExp.enumerate_regs ` set (Outputs ba)) \\<union>\n         (\\<Union>(uu_, y)\\<in>set (Updates ba). AExp.enumerate_regs y))\n 2. \\<And>a b ba.\n       ((a, b), ba) \\<in> fset e \\<Longrightarrow>\n       finite (\\<Union>(r, uu_)\\<in>set (Updates ba). {r})", "apply (rule finite_UnI)+"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a b ba.\n       ((a, b), ba) \\<in> fset e \\<Longrightarrow>\n       finite (\\<Union> (GExp.enumerate_regs ` set (Guards ba)))\n 2. \\<And>a b ba.\n       ((a, b), ba) \\<in> fset e \\<Longrightarrow>\n       finite (\\<Union> (AExp.enumerate_regs ` set (Outputs ba)))\n 3. \\<And>a b ba.\n       ((a, b), ba) \\<in> fset e \\<Longrightarrow>\n       finite (\\<Union>(uu_, y)\\<in>set (Updates ba). AExp.enumerate_regs y)\n 4. \\<And>a b ba.\n       ((a, b), ba) \\<in> fset e \\<Longrightarrow>\n       finite (\\<Union>(r, uu_)\\<in>set (Updates ba). {r})", "using GExp.finite_enumerate_regs"], ["proof (prove)\nusing this:\n  finite (GExp.enumerate_regs ?g)\n\ngoal (4 subgoals):\n 1. \\<And>a b ba.\n       ((a, b), ba) \\<in> fset e \\<Longrightarrow>\n       finite (\\<Union> (GExp.enumerate_regs ` set (Guards ba)))\n 2. \\<And>a b ba.\n       ((a, b), ba) \\<in> fset e \\<Longrightarrow>\n       finite (\\<Union> (AExp.enumerate_regs ` set (Outputs ba)))\n 3. \\<And>a b ba.\n       ((a, b), ba) \\<in> fset e \\<Longrightarrow>\n       finite (\\<Union>(uu_, y)\\<in>set (Updates ba). AExp.enumerate_regs y)\n 4. \\<And>a b ba.\n       ((a, b), ba) \\<in> fset e \\<Longrightarrow>\n       finite (\\<Union>(r, uu_)\\<in>set (Updates ba). {r})", "apply blast"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b ba.\n       ((a, b), ba) \\<in> fset e \\<Longrightarrow>\n       finite (\\<Union> (AExp.enumerate_regs ` set (Outputs ba)))\n 2. \\<And>a b ba.\n       ((a, b), ba) \\<in> fset e \\<Longrightarrow>\n       finite (\\<Union>(uu_, y)\\<in>set (Updates ba). AExp.enumerate_regs y)\n 3. \\<And>a b ba.\n       ((a, b), ba) \\<in> fset e \\<Longrightarrow>\n       finite (\\<Union>(r, uu_)\\<in>set (Updates ba). {r})", "using AExp.finite_enumerate_regs"], ["proof (prove)\nusing this:\n  finite (AExp.enumerate_regs ?a)\n\ngoal (3 subgoals):\n 1. \\<And>a b ba.\n       ((a, b), ba) \\<in> fset e \\<Longrightarrow>\n       finite (\\<Union> (AExp.enumerate_regs ` set (Outputs ba)))\n 2. \\<And>a b ba.\n       ((a, b), ba) \\<in> fset e \\<Longrightarrow>\n       finite (\\<Union>(uu_, y)\\<in>set (Updates ba). AExp.enumerate_regs y)\n 3. \\<And>a b ba.\n       ((a, b), ba) \\<in> fset e \\<Longrightarrow>\n       finite (\\<Union>(r, uu_)\\<in>set (Updates ba). {r})", "apply blast"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b ba.\n       ((a, b), ba) \\<in> fset e \\<Longrightarrow>\n       finite (\\<Union>(uu_, y)\\<in>set (Updates ba). AExp.enumerate_regs y)\n 2. \\<And>a b ba.\n       ((a, b), ba) \\<in> fset e \\<Longrightarrow>\n       finite (\\<Union>(r, uu_)\\<in>set (Updates ba). {r})", "apply (simp add: AExp.finite_enumerate_regs prod.case_eq_if)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b ba.\n       ((a, b), ba) \\<in> fset e \\<Longrightarrow>\n       finite (\\<Union>(r, uu_)\\<in>set (Updates ba). {r})", "by auto"], ["", "definition max_input :: \"transition_matrix \\<Rightarrow> nat option\" where\n  \"max_input e = fMax (fimage (\\<lambda>(_, t). Transition.max_input t) e)\""], ["", "fun maxS :: \"transition_matrix \\<Rightarrow> nat\" where\n  \"maxS t = (if t = {||} then 0 else fMax ((fimage (\\<lambda>((origin, dest), t). origin) t) |\\<union>| (fimage (\\<lambda>((origin, dest), t). dest) t)))\""], ["", "subsection\\<open>Execution Recognition\\<close>"], ["", "text\\<open>The \\texttt{recognises} function returns true if the given EFSM recognises a given execution.\nThat is, the EFSM is able to respond to each event in sequence. There is no restriction on the\noutputs produced. When a recognised execution is observed, it produces an accepted trace of the\nEFSM.\\<close>"], ["", "text_raw\\<open>\\snip{recognises}{1}{2}{%\\<close>"], ["", "inductive recognises_execution :: \"transition_matrix \\<Rightarrow> nat \\<Rightarrow> registers \\<Rightarrow> execution \\<Rightarrow> bool\" where\n  base [simp]: \"recognises_execution e s r []\" |\n  step: \"\\<exists>(s', T) |\\<in>| possible_steps e s r l i.\n         recognises_execution e s' (evaluate_updates T i r) t \\<Longrightarrow>\n         recognises_execution e s r ((l, i)#t)\""], ["", "text_raw\\<open>}%endsnip\\<close>"], ["", "abbreviation \"recognises e t \\<equiv> recognises_execution e 0 <> t\""], ["", "definition \"E e = {x. recognises e x}\""], ["", "lemma no_possible_steps_rejects:\n  \"possible_steps e s r l i = {||} \\<Longrightarrow> \\<not> recognises_execution e s r ((l, i)#t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. possible_steps e s r l i = {||} \\<Longrightarrow>\n    \\<not> recognises_execution e s r ((l, i) # t)", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>possible_steps e s r l i = {||};\n     recognises_execution e s r ((l, i) # t)\\<rbrakk>\n    \\<Longrightarrow> False", "by (rule recognises_execution.cases, auto)"], ["", "lemma recognises_step_equiv: \"recognises_execution e s r ((l, i)#t) =\n   (\\<exists>(s', T) |\\<in>| possible_steps e s r l i. recognises_execution e s' (evaluate_updates T i r) t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. recognises_execution e s r ((l, i) # t) =\n    (\\<exists>(s', T)|\\<in>|possible_steps e s r l i.\n        recognises_execution e s' (evaluate_updates T i r) t)", "apply standard"], ["proof (prove)\ngoal (2 subgoals):\n 1. recognises_execution e s r ((l, i) # t) \\<Longrightarrow>\n    \\<exists>(s', T)|\\<in>|possible_steps e s r l i.\n       recognises_execution e s' (evaluate_updates T i r) t\n 2. \\<exists>(s', T)|\\<in>|possible_steps e s r l i.\n       recognises_execution e s' (evaluate_updates T i r)\n        t \\<Longrightarrow>\n    recognises_execution e s r ((l, i) # t)", "apply (rule recognises_execution.cases)"], ["proof (prove)\ngoal (4 subgoals):\n 1. recognises_execution e s r ((l, i) # t) \\<Longrightarrow>\n    recognises_execution ?a1.3 ?a2.3 ?a3.3 ?a4.3\n 2. \\<And>ea sa ra.\n       \\<lbrakk>recognises_execution e s r ((l, i) # t); ?a1.3 = ea;\n        ?a2.3 = sa; ?a3.3 = ra; ?a4.3 = []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>(s', T)|\\<in>|possible_steps e s r l i.\n                            recognises_execution e s'\n                             (evaluate_updates T i r) t\n 3. \\<And>ea sa ra la ia ta.\n       \\<lbrakk>recognises_execution e s r ((l, i) # t); ?a1.3 = ea;\n        ?a2.3 = sa; ?a3.3 = ra; ?a4.3 = (la, ia) # ta;\n        \\<exists>(s', T)|\\<in>|possible_steps ea sa ra la ia.\n           recognises_execution ea s' (evaluate_updates T ia ra) ta\\<rbrakk>\n       \\<Longrightarrow> \\<exists>(s', T)|\\<in>|possible_steps e s r l i.\n                            recognises_execution e s'\n                             (evaluate_updates T i r) t\n 4. \\<exists>(s', T)|\\<in>|possible_steps e s r l i.\n       recognises_execution e s' (evaluate_updates T i r)\n        t \\<Longrightarrow>\n    recognises_execution e s r ((l, i) # t)", "by (auto simp: recognises_execution.step)"], ["", "fun recognises_prim :: \"transition_matrix \\<Rightarrow> nat \\<Rightarrow> registers \\<Rightarrow> execution \\<Rightarrow> bool\" where\n  \"recognises_prim e s r [] = True\" |\n  \"recognises_prim e s r ((l, i)#t) = (\n    let poss_steps = possible_steps e s r l i in\n    (\\<exists>(s', T) |\\<in>| poss_steps. recognises_prim e s' (evaluate_updates T i r) t)\n  )\""], ["", "lemma recognises_prim [code]: \"recognises_execution e s r t = recognises_prim e s r t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. recognises_execution e s r t = recognises_prim e s r t", "proof(induct t arbitrary: r s)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>r s. recognises_execution e s r [] = recognises_prim e s r []\n 2. \\<And>a t r s.\n       (\\<And>r s.\n           recognises_execution e s r t =\n           recognises_prim e s r t) \\<Longrightarrow>\n       recognises_execution e s r (a # t) = recognises_prim e s r (a # t)", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>r s. recognises_execution e s r [] = recognises_prim e s r []\n 2. \\<And>a t r s.\n       (\\<And>r s.\n           recognises_execution e s r t =\n           recognises_prim e s r t) \\<Longrightarrow>\n       recognises_execution e s r (a # t) = recognises_prim e s r (a # t)", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. recognises_execution e s r [] = recognises_prim e s r []", "by simp"], ["proof (state)\nthis:\n  recognises_execution e s r [] = recognises_prim e s r []\n\ngoal (1 subgoal):\n 1. \\<And>a t r s.\n       (\\<And>r s.\n           recognises_execution e s r t =\n           recognises_prim e s r t) \\<Longrightarrow>\n       recognises_execution e s r (a # t) = recognises_prim e s r (a # t)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a t r s.\n       (\\<And>r s.\n           recognises_execution e s r t =\n           recognises_prim e s r t) \\<Longrightarrow>\n       recognises_execution e s r (a # t) = recognises_prim e s r (a # t)", "case (Cons h t)"], ["proof (state)\nthis:\n  recognises_execution e ?s ?r t = recognises_prim e ?s ?r t\n\ngoal (1 subgoal):\n 1. \\<And>a t r s.\n       (\\<And>r s.\n           recognises_execution e s r t =\n           recognises_prim e s r t) \\<Longrightarrow>\n       recognises_execution e s r (a # t) = recognises_prim e s r (a # t)", "then"], ["proof (chain)\npicking this:\n  recognises_execution e ?s ?r t = recognises_prim e ?s ?r t", "show ?case"], ["proof (prove)\nusing this:\n  recognises_execution e ?s ?r t = recognises_prim e ?s ?r t\n\ngoal (1 subgoal):\n 1. recognises_execution e s r (h # t) = recognises_prim e s r (h # t)", "apply (cases h)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>s r.\n                   recognises_execution e s r t = recognises_prim e s r t;\n        h = (a, b)\\<rbrakk>\n       \\<Longrightarrow> recognises_execution e s r (h # t) =\n                         recognises_prim e s r (h # t)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>s r.\n                   recognises_execution e s r t = recognises_prim e s r t;\n        h = (a, b)\\<rbrakk>\n       \\<Longrightarrow> recognises_execution e s r ((a, b) # t) =\n                         (\\<exists>(s', T)|\\<in>|possible_steps e s r a b.\n                             recognises_prim e s' (evaluate_updates T b r)\n                              t)", "apply standard"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>s r.\n                   recognises_execution e s r t = recognises_prim e s r t;\n        h = (a, b); recognises_execution e s r ((a, b) # t)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>(s', T)|\\<in>|possible_steps e s r a b.\n                            recognises_prim e s' (evaluate_updates T b r) t\n 2. \\<And>a b.\n       \\<lbrakk>\\<And>s r.\n                   recognises_execution e s r t = recognises_prim e s r t;\n        h = (a, b);\n        \\<exists>(s', T)|\\<in>|possible_steps e s r a b.\n           recognises_prim e s' (evaluate_updates T b r) t\\<rbrakk>\n       \\<Longrightarrow> recognises_execution e s r ((a, b) # t)", "apply (rule recognises_execution.cases, simp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b ea s r.\n       \\<lbrakk>\\<And>s r.\n                   recognises_execution e s r t = recognises_prim e s r t;\n        h = (a, b); recognises_execution e s r ((a, b) # t); e = ea; s = s;\n        r = r; (a, b) # t = []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>(s', T)|\\<in>|possible_steps e s r a b.\n                            recognises_prim e s' (evaluate_updates T b r) t\n 2. \\<And>a b ea s r l i t.\n       \\<lbrakk>\\<And>s r.\n                   recognises_execution e s r t = recognises_prim e s r t;\n        h = (a, b); recognises_execution e s r ((a, b) # t); e = ea; s = s;\n        r = r; (a, b) # t = (l, i) # t;\n        \\<exists>(s', T)|\\<in>|possible_steps ea s r l i.\n           recognises_execution ea s' (evaluate_updates T i r) t\\<rbrakk>\n       \\<Longrightarrow> \\<exists>(s', T)|\\<in>|possible_steps e s r a b.\n                            recognises_prim e s' (evaluate_updates T b r) t\n 3. \\<And>a b.\n       \\<lbrakk>\\<And>s r.\n                   recognises_execution e s r t = recognises_prim e s r t;\n        h = (a, b);\n        \\<exists>(s', T)|\\<in>|possible_steps e s r a b.\n           recognises_prim e s' (evaluate_updates T b r) t\\<rbrakk>\n       \\<Longrightarrow> recognises_execution e s r ((a, b) # t)", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b ea s r l i t.\n       \\<lbrakk>\\<And>s r.\n                   recognises_execution e s r t = recognises_prim e s r t;\n        h = (a, b); recognises_execution e s r ((a, b) # t); e = ea; s = s;\n        r = r; (a, b) # t = (l, i) # t;\n        \\<exists>(s', T)|\\<in>|possible_steps ea s r l i.\n           recognises_execution ea s' (evaluate_updates T i r) t\\<rbrakk>\n       \\<Longrightarrow> \\<exists>(s', T)|\\<in>|possible_steps e s r a b.\n                            recognises_prim e s' (evaluate_updates T b r) t\n 2. \\<And>a b.\n       \\<lbrakk>\\<And>s r.\n                   recognises_execution e s r t = recognises_prim e s r t;\n        h = (a, b);\n        \\<exists>(s', T)|\\<in>|possible_steps e s r a b.\n           recognises_prim e s' (evaluate_updates T b r) t\\<rbrakk>\n       \\<Longrightarrow> recognises_execution e s r ((a, b) # t)", "apply auto[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>s r.\n                   recognises_execution e s r t = recognises_prim e s r t;\n        h = (a, b);\n        \\<exists>(s', T)|\\<in>|possible_steps e s r a b.\n           recognises_prim e s' (evaluate_updates T b r) t\\<rbrakk>\n       \\<Longrightarrow> recognises_execution e s r ((a, b) # t)", "using recognises_execution.step"], ["proof (prove)\nusing this:\n  \\<exists>(s', T)|\\<in>|possible_steps ?e ?s ?r ?l ?i.\n     recognises_execution ?e s' (evaluate_updates T ?i ?r)\n      ?t \\<Longrightarrow>\n  recognises_execution ?e ?s ?r ((?l, ?i) # ?t)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>s r.\n                   recognises_execution e s r t = recognises_prim e s r t;\n        h = (a, b);\n        \\<exists>(s', T)|\\<in>|possible_steps e s r a b.\n           recognises_prim e s' (evaluate_updates T b r) t\\<rbrakk>\n       \\<Longrightarrow> recognises_execution e s r ((a, b) # t)", "by blast"], ["proof (state)\nthis:\n  recognises_execution e s r (h # t) = recognises_prim e s r (h # t)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma recognises_single_possible_step:\n  assumes \"possible_steps e s r l i = {|(s', t)|}\"\n      and \"recognises_execution e s' (evaluate_updates t i r) trace\"\n    shows \"recognises_execution e s r ((l, i)#trace)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. recognises_execution e s r ((l, i) # trace)", "apply (rule recognises_execution.step)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>(s', T)|\\<in>|possible_steps e s r l i.\n       recognises_execution e s' (evaluate_updates T i r) trace", "using assms"], ["proof (prove)\nusing this:\n  possible_steps e s r l i = {|(s', t)|}\n  recognises_execution e s' (evaluate_updates t i r) trace\n\ngoal (1 subgoal):\n 1. \\<exists>(s', T)|\\<in>|possible_steps e s r l i.\n       recognises_execution e s' (evaluate_updates T i r) trace", "by auto"], ["", "lemma recognises_single_possible_step_atomic:\n  assumes \"possible_steps e s r (fst h) (snd h) = {|(s', t)|}\"\n      and \"recognises_execution e s' (apply_updates (Updates t) (join_ir (snd h) r) r) trace\"\n    shows \"recognises_execution e s r (h#trace)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. recognises_execution e s r (h # trace)", "by (metis assms prod.collapse recognises_single_possible_step)"], ["", "lemma recognises_must_be_possible_step:\n  \"recognises_execution e s r (h # t) \\<Longrightarrow>\n   \\<exists>aa ba. (aa, ba) |\\<in>| possible_steps e s r (fst h) (snd h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. recognises_execution e s r (h # t) \\<Longrightarrow>\n    \\<exists>aa ba. (aa, ba) |\\<in>| possible_steps e s r (fst h) (snd h)", "using recognises_step_equiv"], ["proof (prove)\nusing this:\n  recognises_execution ?e ?s ?r ((?l, ?i) # ?t) =\n  (\\<exists>(s', T)|\\<in>|possible_steps ?e ?s ?r ?l ?i.\n      recognises_execution ?e s' (evaluate_updates T ?i ?r) ?t)\n\ngoal (1 subgoal):\n 1. recognises_execution e s r (h # t) \\<Longrightarrow>\n    \\<exists>aa ba. (aa, ba) |\\<in>| possible_steps e s r (fst h) (snd h)", "by fastforce"], ["", "lemma recognises_possible_steps_not_empty:\n  \"recognises_execution e s r (h#t) \\<Longrightarrow> possible_steps e s r (fst h) (snd h) \\<noteq> {||}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. recognises_execution e s r (h # t) \\<Longrightarrow>\n    possible_steps e s r (fst h) (snd h) \\<noteq> {||}", "apply (rule recognises_execution.cases)"], ["proof (prove)\ngoal (3 subgoals):\n 1. recognises_execution e s r (h # t) \\<Longrightarrow>\n    recognises_execution ?a1.0 ?a2.0 ?a3.0 ?a4.0\n 2. \\<And>ea sa ra.\n       \\<lbrakk>recognises_execution e s r (h # t); ?a1.0 = ea; ?a2.0 = sa;\n        ?a3.0 = ra; ?a4.0 = []\\<rbrakk>\n       \\<Longrightarrow> possible_steps e s r (fst h) (snd h) \\<noteq> {||}\n 3. \\<And>ea sa ra l i ta.\n       \\<lbrakk>recognises_execution e s r (h # t); ?a1.0 = ea; ?a2.0 = sa;\n        ?a3.0 = ra; ?a4.0 = (l, i) # ta;\n        \\<exists>(s', T)|\\<in>|possible_steps ea sa ra l i.\n           recognises_execution ea s' (evaluate_updates T i ra) ta\\<rbrakk>\n       \\<Longrightarrow> possible_steps e s r (fst h) (snd h) \\<noteq> {||}", "by auto"], ["", "lemma recognises_must_be_step:\n  \"recognises_execution e s r (h#ts) \\<Longrightarrow>\n   \\<exists>t s' p d'. step e s r (fst h) (snd h) = Some (t, s', p, d')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. recognises_execution e s r (h # ts) \\<Longrightarrow>\n    \\<exists>t s' p d'. step e s r (fst h) (snd h) = Some (t, s', p, d')", "apply (cases h)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>recognises_execution e s r (h # ts); h = (a, b)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t s' p d'.\n                            step e s r (fst h) (snd h) = Some (t, s', p, d')", "subgoal for a b"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>recognises_execution e s r (h # ts); h = (a, b)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t s' p d'.\n                         step e s r (fst h) (snd h) = Some (t, s', p, d')", "apply (simp add: recognises_step_equiv step_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<exists>(s', T)|\\<in>|possible_steps e s r a b.\n                recognises_execution e s' (evaluate_updates T b r) ts;\n     h = (a, b)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t s' p d'.\n                         (case random_member (possible_steps e s r a b) of\n                          None \\<Rightarrow> None\n                          | Some (s', t) \\<Rightarrow>\n                              Some\n                               (t, s', evaluate_outputs t b r,\n                                evaluate_updates t b r)) =\n                         Some (t, s', p, d')", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa ba.\n       \\<lbrakk>h = (a, b); (aa, ba) |\\<in>| possible_steps e s r a b;\n        recognises_execution e aa (evaluate_updates ba b r) ts\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t s' p d'.\n                            (case random_member\n                                   (possible_steps e s r a b) of\n                             None \\<Rightarrow> None\n                             | Some (s', t) \\<Rightarrow>\n                                 Some\n                                  (t, s', evaluate_outputs t b r,\n                                   evaluate_updates t b r)) =\n                            Some (t, s', p, d')", "apply (case_tac \"(possible_steps e s r a b)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa ba.\n       \\<lbrakk>h = (a, b); (aa, ba) |\\<in>| possible_steps e s r a b;\n        recognises_execution e aa (evaluate_updates ba b r) ts;\n        possible_steps e s r a b = {||}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t s' p d'.\n                            (case random_member\n                                   (possible_steps e s r a b) of\n                             None \\<Rightarrow> None\n                             | Some (s', t) \\<Rightarrow>\n                                 Some\n                                  (t, s', evaluate_outputs t b r,\n                                   evaluate_updates t b r)) =\n                            Some (t, s', p, d')\n 2. \\<And>aa ba x S'.\n       \\<lbrakk>h = (a, b); (aa, ba) |\\<in>| possible_steps e s r a b;\n        recognises_execution e aa (evaluate_updates ba b r) ts;\n        possible_steps e s r a b = finsert x S'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t s' p d'.\n                            (case random_member\n                                   (possible_steps e s r a b) of\n                             None \\<Rightarrow> None\n                             | Some (s', t) \\<Rightarrow>\n                                 Some\n                                  (t, s', evaluate_outputs t b r,\n                                   evaluate_updates t b r)) =\n                            Some (t, s', p, d')", "apply (simp add: random_member_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa ba x S'.\n       \\<lbrakk>h = (a, b); (aa, ba) |\\<in>| possible_steps e s r a b;\n        recognises_execution e aa (evaluate_updates ba b r) ts;\n        possible_steps e s r a b = finsert x S'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t s' p d'.\n                            (case random_member\n                                   (possible_steps e s r a b) of\n                             None \\<Rightarrow> None\n                             | Some (s', t) \\<Rightarrow>\n                                 Some\n                                  (t, s', evaluate_outputs t b r,\n                                   evaluate_updates t b r)) =\n                            Some (t, s', p, d')", "apply (simp add: random_member_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa ba x S'.\n       \\<lbrakk>h = (a, b); (aa, ba) = x \\<or> (aa, ba) |\\<in>| S';\n        recognises_execution e aa (evaluate_updates ba b r) ts;\n        possible_steps e s r a b = finsert x S'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t s' p d'.\n                            (case SOME xa. xa = x \\<or> xa |\\<in>| S' of\n                             (s', t) \\<Rightarrow>\n                               Some\n                                (t, s', evaluate_outputs t b r,\n                                 evaluate_updates t b r)) =\n                            Some (t, s', p, d')", "subgoal for _ _ x S'"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h = (a, b); (aa_, ba_) = x \\<or> (aa_, ba_) |\\<in>| S';\n     recognises_execution e aa_ (evaluate_updates ba_ b r) ts;\n     possible_steps e s r a b = finsert x S'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t s' p d'.\n                         (case SOME xa. xa = x \\<or> xa |\\<in>| S' of\n                          (s', t) \\<Rightarrow>\n                            Some\n                             (t, s', evaluate_outputs t b r,\n                              evaluate_updates t b r)) =\n                         Some (t, s', p, d')", "apply (case_tac \"SOME xa. xa = x \\<or> xa |\\<in>| S'\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ab bb.\n       \\<lbrakk>h = (a, b); (aa_, ba_) = x \\<or> (aa_, ba_) |\\<in>| S';\n        recognises_execution e aa_ (evaluate_updates ba_ b r) ts;\n        possible_steps e s r a b = finsert x S';\n        (SOME xa. xa = x \\<or> xa |\\<in>| S') = (ab, bb)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t s' p d'.\n                            (case SOME xa. xa = x \\<or> xa |\\<in>| S' of\n                             (s', t) \\<Rightarrow>\n                               Some\n                                (t, s', evaluate_outputs t b r,\n                                 evaluate_updates t b r)) =\n                            Some (t, s', p, d')", "by simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma recognises_cons_step:\n  \"recognises_execution e s r (h # t) \\<Longrightarrow> step e s r (fst h) (snd h) \\<noteq>  None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. recognises_execution e s r (h # t) \\<Longrightarrow>\n    step e s r (fst h) (snd h) \\<noteq> None", "by (simp add: recognises_must_be_step)"], ["", "lemma no_step_none:\n  \"step e s r aa ba = None \\<Longrightarrow> \\<not> recognises_execution e s r ((aa, ba) # p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. step e s r aa ba = None \\<Longrightarrow>\n    \\<not> recognises_execution e s r ((aa, ba) # p)", "using recognises_cons_step"], ["proof (prove)\nusing this:\n  recognises_execution ?e ?s ?r (?h # ?t) \\<Longrightarrow>\n  step ?e ?s ?r (fst ?h) (snd ?h) \\<noteq> None\n\ngoal (1 subgoal):\n 1. step e s r aa ba = None \\<Longrightarrow>\n    \\<not> recognises_execution e s r ((aa, ba) # p)", "by fastforce"], ["", "lemma step_none_rejects:\n  \"step e s r (fst h) (snd h) = None \\<Longrightarrow> \\<not> recognises_execution e s r (h#t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. step e s r (fst h) (snd h) = None \\<Longrightarrow>\n    \\<not> recognises_execution e s r (h # t)", "using no_step_none surjective_pairing"], ["proof (prove)\nusing this:\n  step ?e ?s ?r ?aa ?ba = None \\<Longrightarrow>\n  \\<not> recognises_execution ?e ?s ?r ((?aa, ?ba) # ?p)\n  ?t = (fst ?t, snd ?t)\n\ngoal (1 subgoal):\n 1. step e s r (fst h) (snd h) = None \\<Longrightarrow>\n    \\<not> recognises_execution e s r (h # t)", "by fastforce"], ["", "lemma trace_reject:\n  \"(\\<not> recognises_execution e s r ((l, i)#t)) = (possible_steps e s r l i = {||} \\<or> (\\<forall>(s', T) |\\<in>| possible_steps e s r l i. \\<not> recognises_execution e s' (evaluate_updates T i r) t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<not> recognises_execution e s r ((l, i) # t)) =\n    (possible_steps e s r l i = {||} \\<or>\n     (\\<forall>(s', T)|\\<in>|possible_steps e s r l i.\n         \\<not> recognises_execution e s' (evaluate_updates T i r) t))", "using recognises_prim"], ["proof (prove)\nusing this:\n  recognises_execution ?e ?s ?r ?t = recognises_prim ?e ?s ?r ?t\n\ngoal (1 subgoal):\n 1. (\\<not> recognises_execution e s r ((l, i) # t)) =\n    (possible_steps e s r l i = {||} \\<or>\n     (\\<forall>(s', T)|\\<in>|possible_steps e s r l i.\n         \\<not> recognises_execution e s' (evaluate_updates T i r) t))", "by fastforce"], ["", "lemma trace_reject_no_possible_steps_atomic:\n  \"possible_steps e s r (fst a) (snd a) = {||} \\<Longrightarrow> \\<not> recognises_execution e s r (a#t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. possible_steps e s r (fst a) (snd a) = {||} \\<Longrightarrow>\n    \\<not> recognises_execution e s r (a # t)", "using recognises_possible_steps_not_empty"], ["proof (prove)\nusing this:\n  recognises_execution ?e ?s ?r (?h # ?t) \\<Longrightarrow>\n  possible_steps ?e ?s ?r (fst ?h) (snd ?h) \\<noteq> {||}\n\ngoal (1 subgoal):\n 1. possible_steps e s r (fst a) (snd a) = {||} \\<Longrightarrow>\n    \\<not> recognises_execution e s r (a # t)", "by auto"], ["", "lemma trace_reject_later:\n  \"\\<forall>(s', T) |\\<in>| possible_steps e s r l i. \\<not> recognises_execution e s' (evaluate_updates T i r) t \\<Longrightarrow>\n   \\<not> recognises_execution e s r ((l, i)#t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>(s', T)|\\<in>|possible_steps e s r l i.\n       \\<not> recognises_execution e s' (evaluate_updates T i r)\n               t \\<Longrightarrow>\n    \\<not> recognises_execution e s r ((l, i) # t)", "using trace_reject"], ["proof (prove)\nusing this:\n  (\\<not> recognises_execution ?e ?s ?r ((?l, ?i) # ?t)) =\n  (possible_steps ?e ?s ?r ?l ?i = {||} \\<or>\n   (\\<forall>(s', T)|\\<in>|possible_steps ?e ?s ?r ?l ?i.\n       \\<not> recognises_execution ?e s' (evaluate_updates T ?i ?r) ?t))\n\ngoal (1 subgoal):\n 1. \\<forall>(s', T)|\\<in>|possible_steps e s r l i.\n       \\<not> recognises_execution e s' (evaluate_updates T i r)\n               t \\<Longrightarrow>\n    \\<not> recognises_execution e s r ((l, i) # t)", "by auto"], ["", "lemma recognition_prefix_closure: \"recognises_execution e s r (t@t') \\<Longrightarrow> recognises_execution e s r t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. recognises_execution e s r (t @ t') \\<Longrightarrow>\n    recognises_execution e s r t", "proof(induct t arbitrary: s r)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s r.\n       recognises_execution e s r ([] @ t') \\<Longrightarrow>\n       recognises_execution e s r []\n 2. \\<And>a t s r.\n       \\<lbrakk>\\<And>s r.\n                   recognises_execution e s r (t @ t') \\<Longrightarrow>\n                   recognises_execution e s r t;\n        recognises_execution e s r ((a # t) @ t')\\<rbrakk>\n       \\<Longrightarrow> recognises_execution e s r (a # t)", "case (Cons a t)"], ["proof (state)\nthis:\n  recognises_execution e ?s ?r (t @ t') \\<Longrightarrow>\n  recognises_execution e ?s ?r t\n  recognises_execution e s r ((a # t) @ t')\n\ngoal (2 subgoals):\n 1. \\<And>s r.\n       recognises_execution e s r ([] @ t') \\<Longrightarrow>\n       recognises_execution e s r []\n 2. \\<And>a t s r.\n       \\<lbrakk>\\<And>s r.\n                   recognises_execution e s r (t @ t') \\<Longrightarrow>\n                   recognises_execution e s r t;\n        recognises_execution e s r ((a # t) @ t')\\<rbrakk>\n       \\<Longrightarrow> recognises_execution e s r (a # t)", "then"], ["proof (chain)\npicking this:\n  recognises_execution e ?s ?r (t @ t') \\<Longrightarrow>\n  recognises_execution e ?s ?r t\n  recognises_execution e s r ((a # t) @ t')", "show ?case"], ["proof (prove)\nusing this:\n  recognises_execution e ?s ?r (t @ t') \\<Longrightarrow>\n  recognises_execution e ?s ?r t\n  recognises_execution e s r ((a # t) @ t')\n\ngoal (1 subgoal):\n 1. recognises_execution e s r (a # t)", "apply (cases a, clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b.\n       \\<lbrakk>recognises_execution e s r ((aa, b) # t @ t'); a = (aa, b);\n        \\<And>s r.\n           recognises_execution e s r (t @ t') \\<Longrightarrow>\n           recognises_execution e s r t\\<rbrakk>\n       \\<Longrightarrow> recognises_execution e s r ((aa, b) # t)", "apply (rule recognises_execution.cases)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>aa b.\n       \\<lbrakk>recognises_execution e s r ((aa, b) # t @ t'); a = (aa, b);\n        \\<And>s r.\n           recognises_execution e s r (t @ t') \\<Longrightarrow>\n           recognises_execution e s r t\\<rbrakk>\n       \\<Longrightarrow> recognises_execution (?a1.7 aa b) (?a2.7 aa b)\n                          (?a3.7 aa b) (?a4.7 aa b)\n 2. \\<And>aa b ea s r.\n       \\<lbrakk>recognises_execution e s r ((aa, b) # t @ t'); a = (aa, b);\n        \\<And>s r.\n           recognises_execution e s r (t @ t') \\<Longrightarrow>\n           recognises_execution e s r t;\n        ?a1.7 aa b = ea; ?a2.7 aa b = s; ?a3.7 aa b = r;\n        ?a4.7 aa b = []\\<rbrakk>\n       \\<Longrightarrow> recognises_execution e s r ((aa, b) # t)\n 3. \\<And>aa b ea s r l i t.\n       \\<lbrakk>recognises_execution e s r ((aa, b) # t @ t'); a = (aa, b);\n        \\<And>s r.\n           recognises_execution e s r (t @ t') \\<Longrightarrow>\n           recognises_execution e s r t;\n        ?a1.7 aa b = ea; ?a2.7 aa b = s; ?a3.7 aa b = r;\n        ?a4.7 aa b = (l, i) # t;\n        \\<exists>(s', T)|\\<in>|possible_steps ea s r l i.\n           recognises_execution ea s' (evaluate_updates T i r) t\\<rbrakk>\n       \\<Longrightarrow> recognises_execution e s r ((aa, b) # t)", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa b ea s r.\n       \\<lbrakk>recognises_execution e s r ((aa, b) # t @ t'); a = (aa, b);\n        \\<And>s r.\n           recognises_execution e s r (t @ t') \\<Longrightarrow>\n           recognises_execution e s r t;\n        e = ea; s = s; r = r; (aa, b) # t @ t' = []\\<rbrakk>\n       \\<Longrightarrow> recognises_execution e s r ((aa, b) # t)\n 2. \\<And>aa b ea s r l i t.\n       \\<lbrakk>recognises_execution e s r ((aa, b) # t @ t'); a = (aa, b);\n        \\<And>s r.\n           recognises_execution e s r (t @ t') \\<Longrightarrow>\n           recognises_execution e s r t;\n        e = ea; s = s; r = r; (aa, b) # t @ t' = (l, i) # t;\n        \\<exists>(s', T)|\\<in>|possible_steps ea s r l i.\n           recognises_execution ea s' (evaluate_updates T i r) t\\<rbrakk>\n       \\<Longrightarrow> recognises_execution e s r ((aa, b) # t)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b ea s r l i t.\n       \\<lbrakk>recognises_execution e s r ((aa, b) # t @ t'); a = (aa, b);\n        \\<And>s r.\n           recognises_execution e s r (t @ t') \\<Longrightarrow>\n           recognises_execution e s r t;\n        e = ea; s = s; r = r; (aa, b) # t @ t' = (l, i) # t;\n        \\<exists>(s', T)|\\<in>|possible_steps ea s r l i.\n           recognises_execution ea s' (evaluate_updates T i r) t\\<rbrakk>\n       \\<Longrightarrow> recognises_execution e s r ((aa, b) # t)", "by (rule recognises_execution.step, auto)"], ["proof (state)\nthis:\n  recognises_execution e s r (a # t)\n\ngoal (1 subgoal):\n 1. \\<And>s r.\n       recognises_execution e s r ([] @ t') \\<Longrightarrow>\n       recognises_execution e s r []", "qed auto"], ["", "lemma rejects_prefix: \"\\<not> recognises_execution e s r t \\<Longrightarrow> \\<not> recognises_execution e s r (t @ t')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> recognises_execution e s r t \\<Longrightarrow>\n    \\<not> recognises_execution e s r (t @ t')", "using recognition_prefix_closure"], ["proof (prove)\nusing this:\n  recognises_execution ?e ?s ?r (?t @ ?t') \\<Longrightarrow>\n  recognises_execution ?e ?s ?r ?t\n\ngoal (1 subgoal):\n 1. \\<not> recognises_execution e s r t \\<Longrightarrow>\n    \\<not> recognises_execution e s r (t @ t')", "by blast"], ["", "lemma recognises_head: \"recognises_execution e s r (h#t) \\<Longrightarrow> recognises_execution e s r [h]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. recognises_execution e s r (h # t) \\<Longrightarrow>\n    recognises_execution e s r [h]", "by (simp add: recognition_prefix_closure)"], ["", "subsubsection\\<open>Trace Acceptance\\<close>"], ["", "text\\<open>The \\texttt{accepts} function returns true if the given EFSM accepts a given trace. That is,\nthe EFSM is able to respond to each event in sequence \\emph{and} is able to produce the expected\noutput. Accepted traces represent valid runs of an EFSM.\\<close>"], ["", "text_raw\\<open>\\snip{accepts}{1}{2}{%\\<close>"], ["", "inductive accepts_trace :: \"transition_matrix \\<Rightarrow> cfstate \\<Rightarrow> registers \\<Rightarrow> trace \\<Rightarrow> bool\" where\n  base [simp]: \"accepts_trace e s r []\" |\n  step: \"\\<exists>(s', T) |\\<in>| possible_steps e s r l i.\n         evaluate_outputs T i r = map Some p \\<and> accepts_trace e s' (evaluate_updates T i r) t \\<Longrightarrow>\n         accepts_trace e s r ((l, i, p)#t)\""], ["", "text_raw\\<open>}%endsnip\\<close>"], ["", "text_raw\\<open>\\snip{T}{1}{2}{%\\<close>"], ["", "definition T :: \"transition_matrix \\<Rightarrow> trace set\" where\n  \"T e = {t. accepts_trace e 0 <> t}\""], ["", "text_raw\\<open>}%endsnip\\<close>"], ["", "abbreviation \"rejects_trace e s r t \\<equiv> \\<not> accepts_trace e s r t\""], ["", "lemma accepts_trace_step:\n  \"accepts_trace e s r ((l, i, p)#t) = (\\<exists>(s', T) |\\<in>| possible_steps e s r l i.\n         evaluate_outputs T i r = map Some p \\<and>\n         accepts_trace e s' (evaluate_updates T i r) t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. accepts_trace e s r ((l, i, p) # t) =\n    (\\<exists>(s', T)|\\<in>|possible_steps e s r l i.\n        evaluate_outputs T i r = map Some p \\<and>\n        accepts_trace e s' (evaluate_updates T i r) t)", "apply standard"], ["proof (prove)\ngoal (2 subgoals):\n 1. accepts_trace e s r ((l, i, p) # t) \\<Longrightarrow>\n    \\<exists>(s', T)|\\<in>|possible_steps e s r l i.\n       evaluate_outputs T i r = map Some p \\<and>\n       accepts_trace e s' (evaluate_updates T i r) t\n 2. \\<exists>(s', T)|\\<in>|possible_steps e s r l i.\n       evaluate_outputs T i r = map Some p \\<and>\n       accepts_trace e s' (evaluate_updates T i r) t \\<Longrightarrow>\n    accepts_trace e s r ((l, i, p) # t)", "by (rule accepts_trace.cases, auto simp: accepts_trace.step)"], ["", "lemma accepts_trace_exists_possible_step:\n  \"accepts_trace e1 s1 r1 ((aa, b, c) # t) \\<Longrightarrow>\n       \\<exists>(s1', t1)|\\<in>|possible_steps e1 s1 r1 aa b.\n          evaluate_outputs t1 b r1 = map Some c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. accepts_trace e1 s1 r1 ((aa, b, c) # t) \\<Longrightarrow>\n    \\<exists>(s1', t1)|\\<in>|possible_steps e1 s1 r1 aa b.\n       evaluate_outputs t1 b r1 = map Some c", "using accepts_trace_step"], ["proof (prove)\nusing this:\n  accepts_trace ?e ?s ?r ((?l, ?i, ?p) # ?t) =\n  (\\<exists>(s', T)|\\<in>|possible_steps ?e ?s ?r ?l ?i.\n      evaluate_outputs T ?i ?r = map Some ?p \\<and>\n      accepts_trace ?e s' (evaluate_updates T ?i ?r) ?t)\n\ngoal (1 subgoal):\n 1. accepts_trace e1 s1 r1 ((aa, b, c) # t) \\<Longrightarrow>\n    \\<exists>(s1', t1)|\\<in>|possible_steps e1 s1 r1 aa b.\n       evaluate_outputs t1 b r1 = map Some c", "by auto"], ["", "lemma rejects_trace_step:\n\"rejects_trace e s r ((l, i, p)#t) = (\n  (\\<forall>(s', T) |\\<in>| possible_steps e s r l i.  evaluate_outputs T i r \\<noteq> map Some p \\<or> rejects_trace e s' (evaluate_updates T i r) t)\n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rejects_trace e s r ((l, i, p) # t) =\n    (\\<forall>(s', T)|\\<in>|possible_steps e s r l i.\n        evaluate_outputs T i r \\<noteq> map Some p \\<or>\n        rejects_trace e s' (evaluate_updates T i r) t)", "apply (simp add: accepts_trace_step)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x|\\<in>|possible_steps e s r l i.\n        \\<not> (case x of\n                (s', T) \\<Rightarrow>\n                  evaluate_outputs T i r = map Some p \\<and>\n                  accepts_trace e s' (evaluate_updates T i r) t)) =\n    (\\<forall>(s', T)|\\<in>|possible_steps e s r l i.\n        evaluate_outputs T i r = map Some p \\<longrightarrow>\n        rejects_trace e s' (evaluate_updates T i r) t)", "by auto"], ["", "definition accepts_log :: \"trace set \\<Rightarrow> transition_matrix \\<Rightarrow> bool\" where\n  \"accepts_log l e = (\\<forall>t \\<in> l. accepts_trace e 0 <> t)\""], ["", "text_raw\\<open>\\snip{prefixClosure}{1}{2}{%\\<close>"], ["", "lemma prefix_closure: \"accepts_trace e s r (t@t') \\<Longrightarrow> accepts_trace e s r t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. accepts_trace e s r (t @ t') \\<Longrightarrow> accepts_trace e s r t", "text_raw\\<open>}%endsnip\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. accepts_trace e s r (t @ t') \\<Longrightarrow> accepts_trace e s r t", "proof(induct t arbitrary: s r)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s r.\n       accepts_trace e s r ([] @ t') \\<Longrightarrow>\n       accepts_trace e s r []\n 2. \\<And>a t s r.\n       \\<lbrakk>\\<And>s r.\n                   accepts_trace e s r (t @ t') \\<Longrightarrow>\n                   accepts_trace e s r t;\n        accepts_trace e s r ((a # t) @ t')\\<rbrakk>\n       \\<Longrightarrow> accepts_trace e s r (a # t)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s r.\n       accepts_trace e s r ([] @ t') \\<Longrightarrow>\n       accepts_trace e s r []\n 2. \\<And>a t s r.\n       \\<lbrakk>\\<And>s r.\n                   accepts_trace e s r (t @ t') \\<Longrightarrow>\n                   accepts_trace e s r t;\n        accepts_trace e s r ((a # t) @ t')\\<rbrakk>\n       \\<Longrightarrow> accepts_trace e s r (a # t)", "case (Cons a t)"], ["proof (state)\nthis:\n  accepts_trace e ?s ?r (t @ t') \\<Longrightarrow> accepts_trace e ?s ?r t\n  accepts_trace e s r ((a # t) @ t')\n\ngoal (2 subgoals):\n 1. \\<And>s r.\n       accepts_trace e s r ([] @ t') \\<Longrightarrow>\n       accepts_trace e s r []\n 2. \\<And>a t s r.\n       \\<lbrakk>\\<And>s r.\n                   accepts_trace e s r (t @ t') \\<Longrightarrow>\n                   accepts_trace e s r t;\n        accepts_trace e s r ((a # t) @ t')\\<rbrakk>\n       \\<Longrightarrow> accepts_trace e s r (a # t)", "then"], ["proof (chain)\npicking this:\n  accepts_trace e ?s ?r (t @ t') \\<Longrightarrow> accepts_trace e ?s ?r t\n  accepts_trace e s r ((a # t) @ t')", "show ?case"], ["proof (prove)\nusing this:\n  accepts_trace e ?s ?r (t @ t') \\<Longrightarrow> accepts_trace e ?s ?r t\n  accepts_trace e s r ((a # t) @ t')\n\ngoal (1 subgoal):\n 1. accepts_trace e s r (a # t)", "apply (cases a, clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b c.\n       \\<lbrakk>accepts_trace e s r ((aa, b, c) # t @ t'); a = (aa, b, c);\n        \\<And>s r.\n           accepts_trace e s r (t @ t') \\<Longrightarrow>\n           accepts_trace e s r t\\<rbrakk>\n       \\<Longrightarrow> accepts_trace e s r ((aa, b, c) # t)", "apply (simp add: accepts_trace_step)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b c.\n       \\<lbrakk>\\<exists>(s', T)|\\<in>|possible_steps e s r aa b.\n                   evaluate_outputs T b r = map Some c \\<and>\n                   accepts_trace e s' (evaluate_updates T b r) (t @ t');\n        a = (aa, b, c);\n        \\<And>s r.\n           accepts_trace e s r (t @ t') \\<Longrightarrow>\n           accepts_trace e s r t\\<rbrakk>\n       \\<Longrightarrow> \\<exists>(s', T)|\\<in>|possible_steps e s r aa b.\n                            evaluate_outputs T b r = map Some c \\<and>\n                            accepts_trace e s' (evaluate_updates T b r) t", "by auto"], ["proof (state)\nthis:\n  accepts_trace e s r (a # t)\n\ngoal (1 subgoal):\n 1. \\<And>s r.\n       accepts_trace e s r ([] @ t') \\<Longrightarrow>\n       accepts_trace e s r []", "qed auto"], ["", "text\\<open>For code generation, it is much more efficient to re-implement the \\texttt{accepts\\_trace}\nfunction primitively than to use the code generator's default setup for inductive definitions.\\<close>"], ["", "fun accepts_trace_prim :: \"transition_matrix \\<Rightarrow> cfstate \\<Rightarrow> registers \\<Rightarrow> trace \\<Rightarrow> bool\" where\n  \"accepts_trace_prim _ _ _ [] = True\" |\n  \"accepts_trace_prim e s r ((l, i, p)#t) = (\n    let poss_steps = possible_steps e s r l i in\n    if fis_singleton poss_steps then\n      let (s', T) = fthe_elem poss_steps in\n      if evaluate_outputs T i r = map Some p then\n        accepts_trace_prim e s' (evaluate_updates T i r) t\n      else False\n    else\n      (\\<exists>(s', T) |\\<in>| poss_steps.\n         evaluate_outputs T i r = (map Some p) \\<and>\n         accepts_trace_prim e s' (evaluate_updates T i r) t))\""], ["", "lemma accepts_trace_prim [code]: \"accepts_trace e s r l = accepts_trace_prim e s r l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. accepts_trace e s r l = accepts_trace_prim e s r l", "proof(induct l arbitrary: s r)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s r. accepts_trace e s r [] = accepts_trace_prim e s r []\n 2. \\<And>a l s r.\n       (\\<And>s r.\n           accepts_trace e s r l =\n           accepts_trace_prim e s r l) \\<Longrightarrow>\n       accepts_trace e s r (a # l) = accepts_trace_prim e s r (a # l)", "case (Cons a l)"], ["proof (state)\nthis:\n  accepts_trace e ?s ?r l = accepts_trace_prim e ?s ?r l\n\ngoal (2 subgoals):\n 1. \\<And>s r. accepts_trace e s r [] = accepts_trace_prim e s r []\n 2. \\<And>a l s r.\n       (\\<And>s r.\n           accepts_trace e s r l =\n           accepts_trace_prim e s r l) \\<Longrightarrow>\n       accepts_trace e s r (a # l) = accepts_trace_prim e s r (a # l)", "then"], ["proof (chain)\npicking this:\n  accepts_trace e ?s ?r l = accepts_trace_prim e ?s ?r l", "show ?case"], ["proof (prove)\nusing this:\n  accepts_trace e ?s ?r l = accepts_trace_prim e ?s ?r l\n\ngoal (1 subgoal):\n 1. accepts_trace e s r (a # l) = accepts_trace_prim e s r (a # l)", "apply (cases a)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b c.\n       \\<lbrakk>\\<And>s r.\n                   accepts_trace e s r l = accepts_trace_prim e s r l;\n        a = (aa, b, c)\\<rbrakk>\n       \\<Longrightarrow> accepts_trace e s r (a # l) =\n                         accepts_trace_prim e s r (a # l)", "apply (simp add: accepts_trace_step Let_def fis_singleton_alt)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b c.\n       \\<lbrakk>\\<And>s r.\n                   accepts_trace e s r l = accepts_trace_prim e s r l;\n        a = (aa, b, c)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>aaa ba.\n                             possible_steps e s r aa b =\n                             {|(aaa, ba)|}) \\<longrightarrow>\n                         (\\<exists>(s', T)|\\<in>|possible_steps e s r aa b.\n                             evaluate_outputs T b r = map Some c \\<and>\n                             accepts_trace_prim e s'\n                              (evaluate_updates T b r) l) =\n                         (case fthe_elem (possible_steps e s r aa b) of\n                          (s', T) \\<Rightarrow>\n                            (evaluate_outputs T b r =\n                             map Some c \\<longrightarrow>\n                             accepts_trace_prim e s'\n                              (evaluate_updates T b r) l) \\<and>\n                            evaluate_outputs T b r = map Some c)", "by auto"], ["proof (state)\nthis:\n  accepts_trace e s r (a # l) = accepts_trace_prim e s r (a # l)\n\ngoal (1 subgoal):\n 1. \\<And>s r. accepts_trace e s r [] = accepts_trace_prim e s r []", "qed auto"], ["", "subsection\\<open>EFSM Comparison\\<close>"], ["", "text\\<open>Here, we define some different metrics of EFSM equality.\\<close>"], ["", "subsubsection\\<open>State Isomporphism\\<close>"], ["", "text\\<open>Two EFSMs are isomorphic with respect to states if there exists a bijective function between\nthe state names of the two EFSMs, i.e. the only difference between the two models is the way the\nstates are indexed.\\<close>"], ["", "definition isomorphic :: \"transition_matrix \\<Rightarrow> transition_matrix \\<Rightarrow> bool\" where\n  \"isomorphic e1 e2 = (\\<exists>f. bij f \\<and> (\\<forall>((s1, s2), t) |\\<in>| e1. ((f s1, f s2), t) |\\<in>| e2))\""], ["", "subsubsection\\<open>Register Isomporphism\\<close>"], ["", "text\\<open>Two EFSMs are isomorphic with respect to registers if there exists a bijective function between\nthe indices of the registers in the two EFSMs, i.e. the only difference between the two models is\nthe way the registers are indexed.\\<close>"], ["", "definition rename_regs :: \"(nat \\<Rightarrow> nat) \\<Rightarrow> transition_matrix \\<Rightarrow> transition_matrix\" where\n  \"rename_regs f e = fimage (\\<lambda>(tf, t). (tf, Transition.rename_regs f t)) e\""], ["", "definition eq_upto_rename_strong :: \"transition_matrix \\<Rightarrow> transition_matrix \\<Rightarrow> bool\" where\n  \"eq_upto_rename_strong e1 e2 = (\\<exists>f. bij f \\<and> rename_regs f e1 = e2)\""], ["", "subsubsection\\<open>Trace Simulation\\<close>"], ["", "text\\<open>An EFSM, $e_1$ simulates another EFSM $e_2$ if there is a function between the states of the\nstates of $e_1$ and $e_1$ such that in each state, if $e_1$ can respond to the event and produce\nthe correct output, so can $e_2$.\\<close>"], ["", "text_raw\\<open>\\snip{traceSim}{1}{2}{%\\<close>"], ["", "inductive trace_simulation :: \"(cfstate \\<Rightarrow> cfstate) \\<Rightarrow> transition_matrix \\<Rightarrow> cfstate \\<Rightarrow> registers \\<Rightarrow>\ntransition_matrix \\<Rightarrow> cfstate \\<Rightarrow> registers \\<Rightarrow> trace \\<Rightarrow> bool\" where\n  base: \"s2 = f s1 \\<Longrightarrow> trace_simulation f e1 s1 r1 e2 s2 r2 []\" |\n  step: \"s2 = f s1 \\<Longrightarrow>\n         \\<forall>(s1', t1) |\\<in>| ffilter (\\<lambda>(s1', t1). evaluate_outputs t1 i r1 = map Some o) (possible_steps e1 s1 r1 l i).\n           \\<exists>(s2', t2) |\\<in>| possible_steps e2 s2 r2 l i. evaluate_outputs t2 i r2 = map Some o \\<and>\n            trace_simulation f e1 s1' (evaluate_updates t1 i r1) e2 s2' (evaluate_updates t2 i r2) es \\<Longrightarrow>\n         trace_simulation f e1 s1 r1 e2 s2 r2 ((l, i, o)#es)\""], ["", "text_raw\\<open>}%endsnip\\<close>"], ["", "lemma trace_simulation_step:\n\"trace_simulation f e1 s1 r1 e2 s2 r2 ((l, i, o)#es) = (\n  (s2 = f s1) \\<and> (\\<forall>(s1', t1) |\\<in>| ffilter (\\<lambda>(s1', t1). evaluate_outputs t1 i r1 = map Some o) (possible_steps e1 s1 r1 l i).\n         (\\<exists>(s2', t2) |\\<in>| possible_steps e2 s2 r2 l i. evaluate_outputs t2 i r2 = map Some o \\<and>\n         trace_simulation f e1 s1' (evaluate_updates t1 i r1) e2 s2' (evaluate_updates t2 i r2) es))\n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace_simulation f e1 s1 r1 e2 s2 r2 ((l, i, o) # es) =\n    (s2 = f s1 \\<and>\n     (\\<forall>(s1', t1)\n               |\\<in>|ffilter\n                       (\\<lambda>(s1', t1).\n                           evaluate_outputs t1 i r1 = map Some o)\n                       (possible_steps e1 s1 r1 l i).\n         \\<exists>(s2', t2)|\\<in>|possible_steps e2 s2 r2 l i.\n            evaluate_outputs t2 i r2 = map Some o \\<and>\n            trace_simulation f e1 s1' (evaluate_updates t1 i r1) e2 s2'\n             (evaluate_updates t2 i r2) es))", "apply standard"], ["proof (prove)\ngoal (2 subgoals):\n 1. trace_simulation f e1 s1 r1 e2 s2 r2 ((l, i, o) # es) \\<Longrightarrow>\n    s2 = f s1 \\<and>\n    (\\<forall>(s1', t1)\n              |\\<in>|ffilter\n                      (\\<lambda>(s1', t1).\n                          evaluate_outputs t1 i r1 = map Some o)\n                      (possible_steps e1 s1 r1 l i).\n        \\<exists>(s2', t2)|\\<in>|possible_steps e2 s2 r2 l i.\n           evaluate_outputs t2 i r2 = map Some o \\<and>\n           trace_simulation f e1 s1' (evaluate_updates t1 i r1) e2 s2'\n            (evaluate_updates t2 i r2) es)\n 2. s2 = f s1 \\<and>\n    (\\<forall>(s1', t1)\n              |\\<in>|ffilter\n                      (\\<lambda>(s1', t1).\n                          evaluate_outputs t1 i r1 = map Some o)\n                      (possible_steps e1 s1 r1 l i).\n        \\<exists>(s2', t2)|\\<in>|possible_steps e2 s2 r2 l i.\n           evaluate_outputs t2 i r2 = map Some o \\<and>\n           trace_simulation f e1 s1' (evaluate_updates t1 i r1) e2 s2'\n            (evaluate_updates t2 i r2) es) \\<Longrightarrow>\n    trace_simulation f e1 s1 r1 e2 s2 r2 ((l, i, o) # es)", "apply (rule trace_simulation.cases, simp+)"], ["proof (prove)\ngoal (1 subgoal):\n 1. s2 = f s1 \\<and>\n    (\\<forall>(s1', t1)\n              |\\<in>|ffilter\n                      (\\<lambda>(s1', t1).\n                          evaluate_outputs t1 i r1 = map Some o)\n                      (possible_steps e1 s1 r1 l i).\n        \\<exists>(s2', t2)|\\<in>|possible_steps e2 s2 r2 l i.\n           evaluate_outputs t2 i r2 = map Some o \\<and>\n           trace_simulation f e1 s1' (evaluate_updates t1 i r1) e2 s2'\n            (evaluate_updates t2 i r2) es) \\<Longrightarrow>\n    trace_simulation f e1 s1 r1 e2 (f s1) r2 ((l, i, o) # es)", "apply (rule trace_simulation.step)"], ["proof (prove)\ngoal (2 subgoals):\n 1. s2 = f s1 \\<and>\n    (\\<forall>(s1', t1)\n              |\\<in>|ffilter\n                      (\\<lambda>(s1', t1).\n                          evaluate_outputs t1 i r1 = map Some o)\n                      (possible_steps e1 s1 r1 l i).\n        \\<exists>(s2', t2)|\\<in>|possible_steps e2 s2 r2 l i.\n           evaluate_outputs t2 i r2 = map Some o \\<and>\n           trace_simulation f e1 s1' (evaluate_updates t1 i r1) e2 s2'\n            (evaluate_updates t2 i r2) es) \\<Longrightarrow>\n    f s1 = f s1\n 2. s2 = f s1 \\<and>\n    (\\<forall>(s1', t1)\n              |\\<in>|ffilter\n                      (\\<lambda>(s1', t1).\n                          evaluate_outputs t1 i r1 = map Some o)\n                      (possible_steps e1 s1 r1 l i).\n        \\<exists>(s2', t2)|\\<in>|possible_steps e2 s2 r2 l i.\n           evaluate_outputs t2 i r2 = map Some o \\<and>\n           trace_simulation f e1 s1' (evaluate_updates t1 i r1) e2 s2'\n            (evaluate_updates t2 i r2) es) \\<Longrightarrow>\n    \\<forall>(s1', t1)\n             |\\<in>|ffilter\n                     (\\<lambda>(s1', t1).\n                         evaluate_outputs t1 i r1 = map Some o)\n                     (possible_steps e1 s1 r1 l i).\n       \\<exists>(s2', t2)|\\<in>|possible_steps e2 (f s1) r2 l i.\n          evaluate_outputs t2 i r2 = map Some o \\<and>\n          trace_simulation f e1 s1' (evaluate_updates t1 i r1) e2 s2'\n           (evaluate_updates t2 i r2) es", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. s2 = f s1 \\<and>\n    (\\<forall>(s1', t1)\n              |\\<in>|ffilter\n                      (\\<lambda>(s1', t1).\n                          evaluate_outputs t1 i r1 = map Some o)\n                      (possible_steps e1 s1 r1 l i).\n        \\<exists>(s2', t2)|\\<in>|possible_steps e2 s2 r2 l i.\n           evaluate_outputs t2 i r2 = map Some o \\<and>\n           trace_simulation f e1 s1' (evaluate_updates t1 i r1) e2 s2'\n            (evaluate_updates t2 i r2) es) \\<Longrightarrow>\n    \\<forall>(s1', t1)\n             |\\<in>|ffilter\n                     (\\<lambda>(s1', t1).\n                         evaluate_outputs t1 i r1 = map Some o)\n                     (possible_steps e1 s1 r1 l i).\n       \\<exists>(s2', t2)|\\<in>|possible_steps e2 (f s1) r2 l i.\n          evaluate_outputs t2 i r2 = map Some o \\<and>\n          trace_simulation f e1 s1' (evaluate_updates t1 i r1) e2 s2'\n           (evaluate_updates t2 i r2) es", "by blast"], ["", "lemma trace_simulation_step_none:\n  \"s2 = f s1 \\<Longrightarrow>\n   \\<nexists>(s1', t1) |\\<in>| possible_steps e1 s1 r1 l i. evaluate_outputs t1 i r1 = map Some o \\<Longrightarrow>\n   trace_simulation f e1 s1 r1 e2 s2 r2 ((l, i, o)#es)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s2 = f s1;\n     \\<forall>(s1', t1)|\\<in>|possible_steps e1 s1 r1 l i.\n        evaluate_outputs t1 i r1 \\<noteq> map Some o\\<rbrakk>\n    \\<Longrightarrow> trace_simulation f e1 s1 r1 e2 s2 r2 ((l, i, o) # es)", "apply (rule trace_simulation.step)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>s2 = f s1;\n     \\<forall>(s1', t1)|\\<in>|possible_steps e1 s1 r1 l i.\n        evaluate_outputs t1 i r1 \\<noteq> map Some o\\<rbrakk>\n    \\<Longrightarrow> s2 = f s1\n 2. \\<lbrakk>s2 = f s1;\n     \\<forall>(s1', t1)|\\<in>|possible_steps e1 s1 r1 l i.\n        evaluate_outputs t1 i r1 \\<noteq> map Some o\\<rbrakk>\n    \\<Longrightarrow> \\<forall>(s1', t1)\n                               |\\<in>|ffilter\n (\\<lambda>(s1', t1). evaluate_outputs t1 i r1 = map Some o)\n (possible_steps e1 s1 r1 l i).\n                         \\<exists>(s2', t2)\n                                  |\\<in>|possible_steps e2 s2 r2 l i.\n                            evaluate_outputs t2 i r2 = map Some o \\<and>\n                            trace_simulation f e1 s1'\n                             (evaluate_updates t1 i r1) e2 s2'\n                             (evaluate_updates t2 i r2) es", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s2 = f s1;\n     \\<forall>(s1', t1)|\\<in>|possible_steps e1 s1 r1 l i.\n        evaluate_outputs t1 i r1 \\<noteq> map Some o\\<rbrakk>\n    \\<Longrightarrow> \\<forall>(s1', t1)\n                               |\\<in>|ffilter\n (\\<lambda>(s1', t1). evaluate_outputs t1 i r1 = map Some o)\n (possible_steps e1 s1 r1 l i).\n                         \\<exists>(s2', t2)\n                                  |\\<in>|possible_steps e2 s2 r2 l i.\n                            evaluate_outputs t2 i r2 = map Some o \\<and>\n                            trace_simulation f e1 s1'\n                             (evaluate_updates t1 i r1) e2 s2'\n                             (evaluate_updates t2 i r2) es", "apply (case_tac \"ffilter (\\<lambda>(s1', t1). evaluate_outputs t1 i r1 = map Some o) (possible_steps e1 s1 r1 l i)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>s2 = f s1;\n     \\<forall>(s1', t1)|\\<in>|possible_steps e1 s1 r1 l i.\n        evaluate_outputs t1 i r1 \\<noteq> map Some o;\n     ffilter (\\<lambda>(s1', t1). evaluate_outputs t1 i r1 = map Some o)\n      (possible_steps e1 s1 r1 l i) =\n     {||}\\<rbrakk>\n    \\<Longrightarrow> \\<forall>(s1', t1)\n                               |\\<in>|ffilter\n (\\<lambda>(s1', t1). evaluate_outputs t1 i r1 = map Some o)\n (possible_steps e1 s1 r1 l i).\n                         \\<exists>(s2', t2)\n                                  |\\<in>|possible_steps e2 s2 r2 l i.\n                            evaluate_outputs t2 i r2 = map Some o \\<and>\n                            trace_simulation f e1 s1'\n                             (evaluate_updates t1 i r1) e2 s2'\n                             (evaluate_updates t2 i r2) es\n 2. \\<And>x S'.\n       \\<lbrakk>s2 = f s1;\n        \\<forall>(s1', t1)|\\<in>|possible_steps e1 s1 r1 l i.\n           evaluate_outputs t1 i r1 \\<noteq> map Some o;\n        ffilter (\\<lambda>(s1', t1). evaluate_outputs t1 i r1 = map Some o)\n         (possible_steps e1 s1 r1 l i) =\n        finsert x S'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(s1', t1)\n                                  |\\<in>|ffilter\n    (\\<lambda>(s1', t1). evaluate_outputs t1 i r1 = map Some o)\n    (possible_steps e1 s1 r1 l i).\n                            \\<exists>(s2', t2)\n                                     |\\<in>|possible_steps e2 s2 r2 l i.\n                               evaluate_outputs t2 i r2 = map Some o \\<and>\n                               trace_simulation f e1 s1'\n                                (evaluate_updates t1 i r1) e2 s2'\n                                (evaluate_updates t2 i r2) es", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x S'.\n       \\<lbrakk>s2 = f s1;\n        \\<forall>(s1', t1)|\\<in>|possible_steps e1 s1 r1 l i.\n           evaluate_outputs t1 i r1 \\<noteq> map Some o;\n        ffilter (\\<lambda>(s1', t1). evaluate_outputs t1 i r1 = map Some o)\n         (possible_steps e1 s1 r1 l i) =\n        finsert x S'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(s1', t1)\n                                  |\\<in>|ffilter\n    (\\<lambda>(s1', t1). evaluate_outputs t1 i r1 = map Some o)\n    (possible_steps e1 s1 r1 l i).\n                            \\<exists>(s2', t2)\n                                     |\\<in>|possible_steps e2 s2 r2 l i.\n                               evaluate_outputs t2 i r2 = map Some o \\<and>\n                               trace_simulation f e1 s1'\n                                (evaluate_updates t1 i r1) e2 s2'\n                                (evaluate_updates t2 i r2) es", "by fastforce"], ["", "definition \"trace_simulates e1 e2 = (\\<exists>f. \\<forall>t. trace_simulation f e1 0 <> e2 0 <> t)\""], ["", "lemma rejects_trace_simulation:\n  \"rejects_trace e2 s2 r2 t \\<Longrightarrow>\n   accepts_trace e1 s1 r1 t \\<Longrightarrow>\n   \\<not>trace_simulation f e1 s1 r1 e2 s2 r2 t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>rejects_trace e2 s2 r2 t; accepts_trace e1 s1 r1 t\\<rbrakk>\n    \\<Longrightarrow> \\<not> trace_simulation f e1 s1 r1 e2 s2 r2 t", "proof(induct t arbitrary: s1 r1 s2 r2)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s1 r1 s2 r2.\n       \\<lbrakk>rejects_trace e2 s2 r2 [];\n        accepts_trace e1 s1 r1 []\\<rbrakk>\n       \\<Longrightarrow> \\<not> trace_simulation f e1 s1 r1 e2 s2 r2 []\n 2. \\<And>a t s1 r1 s2 r2.\n       \\<lbrakk>\\<And>s1 r1 s2 r2.\n                   \\<lbrakk>rejects_trace e2 s2 r2 t;\n                    accepts_trace e1 s1 r1 t\\<rbrakk>\n                   \\<Longrightarrow> \\<not> trace_simulation f e1 s1 r1 e2\n       s2 r2 t;\n        rejects_trace e2 s2 r2 (a # t);\n        accepts_trace e1 s1 r1 (a # t)\\<rbrakk>\n       \\<Longrightarrow> \\<not> trace_simulation f e1 s1 r1 e2 s2 r2 (a # t)", "case Nil"], ["proof (state)\nthis:\n  rejects_trace e2 s2 r2 []\n  accepts_trace e1 s1 r1 []\n\ngoal (2 subgoals):\n 1. \\<And>s1 r1 s2 r2.\n       \\<lbrakk>rejects_trace e2 s2 r2 [];\n        accepts_trace e1 s1 r1 []\\<rbrakk>\n       \\<Longrightarrow> \\<not> trace_simulation f e1 s1 r1 e2 s2 r2 []\n 2. \\<And>a t s1 r1 s2 r2.\n       \\<lbrakk>\\<And>s1 r1 s2 r2.\n                   \\<lbrakk>rejects_trace e2 s2 r2 t;\n                    accepts_trace e1 s1 r1 t\\<rbrakk>\n                   \\<Longrightarrow> \\<not> trace_simulation f e1 s1 r1 e2\n       s2 r2 t;\n        rejects_trace e2 s2 r2 (a # t);\n        accepts_trace e1 s1 r1 (a # t)\\<rbrakk>\n       \\<Longrightarrow> \\<not> trace_simulation f e1 s1 r1 e2 s2 r2 (a # t)", "then"], ["proof (chain)\npicking this:\n  rejects_trace e2 s2 r2 []\n  accepts_trace e1 s1 r1 []", "show ?case"], ["proof (prove)\nusing this:\n  rejects_trace e2 s2 r2 []\n  accepts_trace e1 s1 r1 []\n\ngoal (1 subgoal):\n 1. \\<not> trace_simulation f e1 s1 r1 e2 s2 r2 []", "using accepts_trace.base"], ["proof (prove)\nusing this:\n  rejects_trace e2 s2 r2 []\n  accepts_trace e1 s1 r1 []\n  accepts_trace ?e ?s ?r []\n\ngoal (1 subgoal):\n 1. \\<not> trace_simulation f e1 s1 r1 e2 s2 r2 []", "by blast"], ["proof (state)\nthis:\n  \\<not> trace_simulation f e1 s1 r1 e2 s2 r2 []\n\ngoal (1 subgoal):\n 1. \\<And>a t s1 r1 s2 r2.\n       \\<lbrakk>\\<And>s1 r1 s2 r2.\n                   \\<lbrakk>rejects_trace e2 s2 r2 t;\n                    accepts_trace e1 s1 r1 t\\<rbrakk>\n                   \\<Longrightarrow> \\<not> trace_simulation f e1 s1 r1 e2\n       s2 r2 t;\n        rejects_trace e2 s2 r2 (a # t);\n        accepts_trace e1 s1 r1 (a # t)\\<rbrakk>\n       \\<Longrightarrow> \\<not> trace_simulation f e1 s1 r1 e2 s2 r2 (a # t)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a t s1 r1 s2 r2.\n       \\<lbrakk>\\<And>s1 r1 s2 r2.\n                   \\<lbrakk>rejects_trace e2 s2 r2 t;\n                    accepts_trace e1 s1 r1 t\\<rbrakk>\n                   \\<Longrightarrow> \\<not> trace_simulation f e1 s1 r1 e2\n       s2 r2 t;\n        rejects_trace e2 s2 r2 (a # t);\n        accepts_trace e1 s1 r1 (a # t)\\<rbrakk>\n       \\<Longrightarrow> \\<not> trace_simulation f e1 s1 r1 e2 s2 r2 (a # t)", "case (Cons a t)"], ["proof (state)\nthis:\n  \\<lbrakk>rejects_trace e2 ?s2.0 ?r2.0 t;\n   accepts_trace e1 ?s1.0 ?r1.0 t\\<rbrakk>\n  \\<Longrightarrow> \\<not> trace_simulation f e1 ?s1.0 ?r1.0 e2 ?s2.0 ?r2.0\n                            t\n  rejects_trace e2 s2 r2 (a # t)\n  accepts_trace e1 s1 r1 (a # t)\n\ngoal (1 subgoal):\n 1. \\<And>a t s1 r1 s2 r2.\n       \\<lbrakk>\\<And>s1 r1 s2 r2.\n                   \\<lbrakk>rejects_trace e2 s2 r2 t;\n                    accepts_trace e1 s1 r1 t\\<rbrakk>\n                   \\<Longrightarrow> \\<not> trace_simulation f e1 s1 r1 e2\n       s2 r2 t;\n        rejects_trace e2 s2 r2 (a # t);\n        accepts_trace e1 s1 r1 (a # t)\\<rbrakk>\n       \\<Longrightarrow> \\<not> trace_simulation f e1 s1 r1 e2 s2 r2 (a # t)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>rejects_trace e2 ?s2.0 ?r2.0 t;\n   accepts_trace e1 ?s1.0 ?r1.0 t\\<rbrakk>\n  \\<Longrightarrow> \\<not> trace_simulation f e1 ?s1.0 ?r1.0 e2 ?s2.0 ?r2.0\n                            t\n  rejects_trace e2 s2 r2 (a # t)\n  accepts_trace e1 s1 r1 (a # t)", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>rejects_trace e2 ?s2.0 ?r2.0 t;\n   accepts_trace e1 ?s1.0 ?r1.0 t\\<rbrakk>\n  \\<Longrightarrow> \\<not> trace_simulation f e1 ?s1.0 ?r1.0 e2 ?s2.0 ?r2.0\n                            t\n  rejects_trace e2 s2 r2 (a # t)\n  accepts_trace e1 s1 r1 (a # t)\n\ngoal (1 subgoal):\n 1. \\<not> trace_simulation f e1 s1 r1 e2 s2 r2 (a # t)", "apply (cases a)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b c.\n       \\<lbrakk>\\<And>s2 r2 s1 r1.\n                   \\<lbrakk>rejects_trace e2 s2 r2 t;\n                    accepts_trace e1 s1 r1 t\\<rbrakk>\n                   \\<Longrightarrow> \\<not> trace_simulation f e1 s1 r1 e2\n       s2 r2 t;\n        rejects_trace e2 s2 r2 (a # t); accepts_trace e1 s1 r1 (a # t);\n        a = (aa, b, c)\\<rbrakk>\n       \\<Longrightarrow> \\<not> trace_simulation f e1 s1 r1 e2 s2 r2 (a # t)", "apply (simp add: rejects_trace_step)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b c.\n       \\<lbrakk>\\<And>s2 r2 s1 r1.\n                   \\<lbrakk>rejects_trace e2 s2 r2 t;\n                    accepts_trace e1 s1 r1 t\\<rbrakk>\n                   \\<Longrightarrow> \\<not> trace_simulation f e1 s1 r1 e2\n       s2 r2 t;\n        \\<forall>(s', T)|\\<in>|possible_steps e2 s2 r2 aa b.\n           evaluate_outputs T b r2 = map Some c \\<longrightarrow>\n           rejects_trace e2 s' (evaluate_updates T b r2) t;\n        accepts_trace e1 s1 r1 ((aa, b, c) # t); a = (aa, b, c)\\<rbrakk>\n       \\<Longrightarrow> \\<not> trace_simulation f e1 s1 r1 e2 s2 r2\n                                 ((aa, b, c) # t)", "apply (simp add: accepts_trace_step)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b c.\n       \\<lbrakk>\\<And>s2 r2 s1 r1.\n                   \\<lbrakk>rejects_trace e2 s2 r2 t;\n                    accepts_trace e1 s1 r1 t\\<rbrakk>\n                   \\<Longrightarrow> \\<not> trace_simulation f e1 s1 r1 e2\n       s2 r2 t;\n        \\<forall>(s', T)|\\<in>|possible_steps e2 s2 r2 aa b.\n           evaluate_outputs T b r2 = map Some c \\<longrightarrow>\n           rejects_trace e2 s' (evaluate_updates T b r2) t;\n        \\<exists>(s', T)|\\<in>|possible_steps e1 s1 r1 aa b.\n           evaluate_outputs T b r1 = map Some c \\<and>\n           accepts_trace e1 s' (evaluate_updates T b r1) t;\n        a = (aa, b, c)\\<rbrakk>\n       \\<Longrightarrow> \\<not> trace_simulation f e1 s1 r1 e2 s2 r2\n                                 ((aa, b, c) # t)", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b c aaa ba.\n       \\<lbrakk>\\<And>s2 r2 s1 r1.\n                   \\<lbrakk>rejects_trace e2 s2 r2 t;\n                    accepts_trace e1 s1 r1 t\\<rbrakk>\n                   \\<Longrightarrow> \\<not> trace_simulation f e1 s1 r1 e2\n       s2 r2 t;\n        \\<forall>(s', T)|\\<in>|possible_steps e2 s2 r2 aa b.\n           evaluate_outputs T b r2 = map Some c \\<longrightarrow>\n           rejects_trace e2 s' (evaluate_updates T b r2) t;\n        a = (aa, b, c); (aaa, ba) |\\<in>| possible_steps e1 s1 r1 aa b;\n        evaluate_outputs ba b r1 = map Some c;\n        accepts_trace e1 aaa (evaluate_updates ba b r1) t;\n        trace_simulation f e1 s1 r1 e2 s2 r2 ((aa, b, c) # t)\\<rbrakk>\n       \\<Longrightarrow> False", "apply (rule trace_simulation.cases)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>aa b c aaa ba.\n       \\<lbrakk>\\<And>s2 r2 s1 r1.\n                   \\<lbrakk>rejects_trace e2 s2 r2 t;\n                    accepts_trace e1 s1 r1 t\\<rbrakk>\n                   \\<Longrightarrow> \\<not> trace_simulation f e1 s1 r1 e2\n       s2 r2 t;\n        \\<forall>(s', T)|\\<in>|possible_steps e2 s2 r2 aa b.\n           evaluate_outputs T b r2 = map Some c \\<longrightarrow>\n           rejects_trace e2 s' (evaluate_updates T b r2) t;\n        a = (aa, b, c); (aaa, ba) |\\<in>| possible_steps e1 s1 r1 aa b;\n        evaluate_outputs ba b r1 = map Some c;\n        accepts_trace e1 aaa (evaluate_updates ba b r1) t;\n        trace_simulation f e1 s1 r1 e2 s2 r2 ((aa, b, c) # t)\\<rbrakk>\n       \\<Longrightarrow> trace_simulation (?a1.8 aa b c aaa ba)\n                          (?a2.8 aa b c aaa ba) (?a3.8 aa b c aaa ba)\n                          (?a4.8 aa b c aaa ba) (?a5.8 aa b c aaa ba)\n                          (?a6.8 aa b c aaa ba) (?a7.8 aa b c aaa ba)\n                          (?a8.8 aa b c aaa ba)\n 2. \\<And>aa b c aaa ba s2 fa s1 e1a r1 e2a r2.\n       \\<lbrakk>\\<And>s2 r2 s1 r1.\n                   \\<lbrakk>rejects_trace e2 s2 r2 t;\n                    accepts_trace e1 s1 r1 t\\<rbrakk>\n                   \\<Longrightarrow> \\<not> trace_simulation f e1 s1 r1 e2\n       s2 r2 t;\n        \\<forall>(s', T)|\\<in>|possible_steps e2 s2 r2 aa b.\n           evaluate_outputs T b r2 = map Some c \\<longrightarrow>\n           rejects_trace e2 s' (evaluate_updates T b r2) t;\n        a = (aa, b, c); (aaa, ba) |\\<in>| possible_steps e1 s1 r1 aa b;\n        evaluate_outputs ba b r1 = map Some c;\n        accepts_trace e1 aaa (evaluate_updates ba b r1) t;\n        trace_simulation f e1 s1 r1 e2 s2 r2 ((aa, b, c) # t);\n        ?a1.8 aa b c aaa ba = fa; ?a2.8 aa b c aaa ba = e1a;\n        ?a3.8 aa b c aaa ba = s1; ?a4.8 aa b c aaa ba = r1;\n        ?a5.8 aa b c aaa ba = e2a; ?a6.8 aa b c aaa ba = s2;\n        ?a7.8 aa b c aaa ba = r2; ?a8.8 aa b c aaa ba = [];\n        s2 = fa s1\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>aa b c aaa ba s2 fa s1 i r1 o e1a l e2a r2 es.\n       \\<lbrakk>\\<And>s2 r2 s1 r1.\n                   \\<lbrakk>rejects_trace e2 s2 r2 t;\n                    accepts_trace e1 s1 r1 t\\<rbrakk>\n                   \\<Longrightarrow> \\<not> trace_simulation f e1 s1 r1 e2\n       s2 r2 t;\n        \\<forall>(s', T)|\\<in>|possible_steps e2 s2 r2 aa b.\n           evaluate_outputs T b r2 = map Some c \\<longrightarrow>\n           rejects_trace e2 s' (evaluate_updates T b r2) t;\n        a = (aa, b, c); (aaa, ba) |\\<in>| possible_steps e1 s1 r1 aa b;\n        evaluate_outputs ba b r1 = map Some c;\n        accepts_trace e1 aaa (evaluate_updates ba b r1) t;\n        trace_simulation f e1 s1 r1 e2 s2 r2 ((aa, b, c) # t);\n        ?a1.8 aa b c aaa ba = fa; ?a2.8 aa b c aaa ba = e1a;\n        ?a3.8 aa b c aaa ba = s1; ?a4.8 aa b c aaa ba = r1;\n        ?a5.8 aa b c aaa ba = e2a; ?a6.8 aa b c aaa ba = s2;\n        ?a7.8 aa b c aaa ba = r2; ?a8.8 aa b c aaa ba = (l, i, o) # es;\n        s2 = fa s1;\n        \\<forall>(s1', t1)\n                 |\\<in>|ffilter\n                         (\\<lambda>(s1', t1).\n                             evaluate_outputs t1 i r1 = map Some o)\n                         (possible_steps e1a s1 r1 l i).\n           \\<exists>(s2', t2)|\\<in>|possible_steps e2a s2 r2 l i.\n              evaluate_outputs t2 i r2 = map Some o \\<and>\n              trace_simulation fa e1a s1' (evaluate_updates t1 i r1) e2a s2'\n               (evaluate_updates t2 i r2) es\\<rbrakk>\n       \\<Longrightarrow> False", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa b c aaa ba s2 fa s1 e1a r1 e2a r2.\n       \\<lbrakk>\\<And>s2 r2 s1 r1.\n                   \\<lbrakk>rejects_trace e2 s2 r2 t;\n                    accepts_trace e1 s1 r1 t\\<rbrakk>\n                   \\<Longrightarrow> \\<not> trace_simulation f e1 s1 r1 e2\n       s2 r2 t;\n        \\<forall>(s', T)|\\<in>|possible_steps e2 s2 r2 aa b.\n           evaluate_outputs T b r2 = map Some c \\<longrightarrow>\n           rejects_trace e2 s' (evaluate_updates T b r2) t;\n        a = (aa, b, c); (aaa, ba) |\\<in>| possible_steps e1 s1 r1 aa b;\n        evaluate_outputs ba b r1 = map Some c;\n        accepts_trace e1 aaa (evaluate_updates ba b r1) t;\n        trace_simulation f e1 s1 r1 e2 s2 r2 ((aa, b, c) # t); f = fa;\n        e1 = e1a; s1 = s1; r1 = r1; e2 = e2a; s2 = s2; r2 = r2;\n        (aa, b, c) # t = []; s2 = fa s1\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>aa b c aaa ba s2 fa s1 i r1 o e1a l e2a r2 es.\n       \\<lbrakk>\\<And>s2 r2 s1 r1.\n                   \\<lbrakk>rejects_trace e2 s2 r2 t;\n                    accepts_trace e1 s1 r1 t\\<rbrakk>\n                   \\<Longrightarrow> \\<not> trace_simulation f e1 s1 r1 e2\n       s2 r2 t;\n        \\<forall>(s', T)|\\<in>|possible_steps e2 s2 r2 aa b.\n           evaluate_outputs T b r2 = map Some c \\<longrightarrow>\n           rejects_trace e2 s' (evaluate_updates T b r2) t;\n        a = (aa, b, c); (aaa, ba) |\\<in>| possible_steps e1 s1 r1 aa b;\n        evaluate_outputs ba b r1 = map Some c;\n        accepts_trace e1 aaa (evaluate_updates ba b r1) t;\n        trace_simulation f e1 s1 r1 e2 s2 r2 ((aa, b, c) # t); f = fa;\n        e1 = e1a; s1 = s1; r1 = r1; e2 = e2a; s2 = s2; r2 = r2;\n        (aa, b, c) # t = (l, i, o) # es; s2 = fa s1;\n        \\<forall>(s1', t1)\n                 |\\<in>|ffilter\n                         (\\<lambda>(s1', t1).\n                             evaluate_outputs t1 i r1 = map Some o)\n                         (possible_steps e1a s1 r1 l i).\n           \\<exists>(s2', t2)|\\<in>|possible_steps e2a s2 r2 l i.\n              evaluate_outputs t2 i r2 = map Some o \\<and>\n              trace_simulation fa e1a s1' (evaluate_updates t1 i r1) e2a s2'\n               (evaluate_updates t2 i r2) es\\<rbrakk>\n       \\<Longrightarrow> False", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b c aaa ba s2 fa s1 i r1 o e1a l e2a r2 es.\n       \\<lbrakk>\\<And>s2 r2 s1 r1.\n                   \\<lbrakk>rejects_trace e2 s2 r2 t;\n                    accepts_trace e1 s1 r1 t\\<rbrakk>\n                   \\<Longrightarrow> \\<not> trace_simulation f e1 s1 r1 e2\n       s2 r2 t;\n        \\<forall>(s', T)|\\<in>|possible_steps e2 s2 r2 aa b.\n           evaluate_outputs T b r2 = map Some c \\<longrightarrow>\n           rejects_trace e2 s' (evaluate_updates T b r2) t;\n        a = (aa, b, c); (aaa, ba) |\\<in>| possible_steps e1 s1 r1 aa b;\n        evaluate_outputs ba b r1 = map Some c;\n        accepts_trace e1 aaa (evaluate_updates ba b r1) t;\n        trace_simulation f e1 s1 r1 e2 s2 r2 ((aa, b, c) # t); f = fa;\n        e1 = e1a; s1 = s1; r1 = r1; e2 = e2a; s2 = s2; r2 = r2;\n        (aa, b, c) # t = (l, i, o) # es; s2 = fa s1;\n        \\<forall>(s1', t1)\n                 |\\<in>|ffilter\n                         (\\<lambda>(s1', t1).\n                             evaluate_outputs t1 i r1 = map Some o)\n                         (possible_steps e1a s1 r1 l i).\n           \\<exists>(s2', t2)|\\<in>|possible_steps e2a s2 r2 l i.\n              evaluate_outputs t2 i r2 = map Some o \\<and>\n              trace_simulation fa e1a s1' (evaluate_updates t1 i r1) e2a s2'\n               (evaluate_updates t2 i r2) es\\<rbrakk>\n       \\<Longrightarrow> False", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa c aaa ba i.\n       \\<lbrakk>\\<And>s2 r2 s1 r1.\n                   \\<lbrakk>rejects_trace e2 s2 r2 t;\n                    accepts_trace e1 s1 r1 t\\<rbrakk>\n                   \\<Longrightarrow> \\<not> trace_simulation f e1 s1 r1 e2\n       s2 r2 t;\n        \\<forall>(s', T)|\\<in>|possible_steps e2 (f s1) r2 aa i.\n           evaluate_outputs T i r2 = map Some c \\<longrightarrow>\n           rejects_trace e2 s' (evaluate_updates T i r2) t;\n        a = (aa, i, c); (aaa, ba) |\\<in>| possible_steps e1 s1 r1 aa i;\n        evaluate_outputs ba i r1 = map Some c;\n        accepts_trace e1 aaa (evaluate_updates ba i r1) t;\n        trace_simulation f e1 s1 r1 e2 (f s1) r2 ((aa, i, c) # t);\n        s2 = f s1;\n        \\<forall>(s1', t1)\n                 |\\<in>|ffilter\n                         (\\<lambda>(s1', t1).\n                             evaluate_outputs t1 i r1 = map Some c)\n                         (possible_steps e1 s1 r1 aa i).\n           \\<exists>(s2', t2)|\\<in>|possible_steps e2 (f s1) r2 aa i.\n              evaluate_outputs t2 i r2 = map Some c \\<and>\n              trace_simulation f e1 s1' (evaluate_updates t1 i r1) e2 s2'\n               (evaluate_updates t2 i r2) t\\<rbrakk>\n       \\<Longrightarrow> False", "subgoal for l o _ _ i"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>s2 r2 s1 r1.\n                \\<lbrakk>rejects_trace e2 s2 r2 t;\n                 accepts_trace e1 s1 r1 t\\<rbrakk>\n                \\<Longrightarrow> \\<not> trace_simulation f e1 s1 r1 e2 s2\n    r2 t;\n     \\<forall>(s', T)|\\<in>|possible_steps e2 (f s1) r2 l i.\n        evaluate_outputs T i r2 = map Some o \\<longrightarrow>\n        rejects_trace e2 s' (evaluate_updates T i r2) t;\n     a = (l, i, o); (aaa_, ba_) |\\<in>| possible_steps e1 s1 r1 l i;\n     evaluate_outputs ba_ i r1 = map Some o;\n     accepts_trace e1 aaa_ (evaluate_updates ba_ i r1) t;\n     trace_simulation f e1 s1 r1 e2 (f s1) r2 ((l, i, o) # t); s2 = f s1;\n     \\<forall>(s1', t1)\n              |\\<in>|ffilter\n                      (\\<lambda>(s1', t1).\n                          evaluate_outputs t1 i r1 = map Some o)\n                      (possible_steps e1 s1 r1 l i).\n        \\<exists>(s2', t2)|\\<in>|possible_steps e2 (f s1) r2 l i.\n           evaluate_outputs t2 i r2 = map Some o \\<and>\n           trace_simulation f e1 s1' (evaluate_updates t1 i r1) e2 s2'\n            (evaluate_updates t2 i r2) t\\<rbrakk>\n    \\<Longrightarrow> False", "apply (case_tac \"ffilter (\\<lambda>(s1', t1). evaluate_outputs t1 i r1 = map Some o) (possible_steps e1 s1 r1 l i) = {||}\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>s2 r2 s1 r1.\n                \\<lbrakk>rejects_trace e2 s2 r2 t;\n                 accepts_trace e1 s1 r1 t\\<rbrakk>\n                \\<Longrightarrow> \\<not> trace_simulation f e1 s1 r1 e2 s2\n    r2 t;\n     \\<forall>(s', T)|\\<in>|possible_steps e2 (f s1) r2 l i.\n        evaluate_outputs T i r2 = map Some o \\<longrightarrow>\n        rejects_trace e2 s' (evaluate_updates T i r2) t;\n     a = (l, i, o); (aaa_, ba_) |\\<in>| possible_steps e1 s1 r1 l i;\n     evaluate_outputs ba_ i r1 = map Some o;\n     accepts_trace e1 aaa_ (evaluate_updates ba_ i r1) t;\n     trace_simulation f e1 s1 r1 e2 (f s1) r2 ((l, i, o) # t); s2 = f s1;\n     \\<forall>(s1', t1)\n              |\\<in>|ffilter\n                      (\\<lambda>(s1', t1).\n                          evaluate_outputs t1 i r1 = map Some o)\n                      (possible_steps e1 s1 r1 l i).\n        \\<exists>(s2', t2)|\\<in>|possible_steps e2 (f s1) r2 l i.\n           evaluate_outputs t2 i r2 = map Some o \\<and>\n           trace_simulation f e1 s1' (evaluate_updates t1 i r1) e2 s2'\n            (evaluate_updates t2 i r2) t;\n     ffilter (\\<lambda>(s1', t1). evaluate_outputs t1 i r1 = map Some o)\n      (possible_steps e1 s1 r1 l i) =\n     {||}\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>\\<And>s2 r2 s1 r1.\n                \\<lbrakk>rejects_trace e2 s2 r2 t;\n                 accepts_trace e1 s1 r1 t\\<rbrakk>\n                \\<Longrightarrow> \\<not> trace_simulation f e1 s1 r1 e2 s2\n    r2 t;\n     \\<forall>(s', T)|\\<in>|possible_steps e2 (f s1) r2 l i.\n        evaluate_outputs T i r2 = map Some o \\<longrightarrow>\n        rejects_trace e2 s' (evaluate_updates T i r2) t;\n     a = (l, i, o); (aaa_, ba_) |\\<in>| possible_steps e1 s1 r1 l i;\n     evaluate_outputs ba_ i r1 = map Some o;\n     accepts_trace e1 aaa_ (evaluate_updates ba_ i r1) t;\n     trace_simulation f e1 s1 r1 e2 (f s1) r2 ((l, i, o) # t); s2 = f s1;\n     \\<forall>(s1', t1)\n              |\\<in>|ffilter\n                      (\\<lambda>(s1', t1).\n                          evaluate_outputs t1 i r1 = map Some o)\n                      (possible_steps e1 s1 r1 l i).\n        \\<exists>(s2', t2)|\\<in>|possible_steps e2 (f s1) r2 l i.\n           evaluate_outputs t2 i r2 = map Some o \\<and>\n           trace_simulation f e1 s1' (evaluate_updates t1 i r1) e2 s2'\n            (evaluate_updates t2 i r2) t;\n     ffilter (\\<lambda>(s1', t1). evaluate_outputs t1 i r1 = map Some o)\n      (possible_steps e1 s1 r1 l i) \\<noteq>\n     {||}\\<rbrakk>\n    \\<Longrightarrow> False", "apply auto[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>s2 r2 s1 r1.\n                \\<lbrakk>rejects_trace e2 s2 r2 t;\n                 accepts_trace e1 s1 r1 t\\<rbrakk>\n                \\<Longrightarrow> \\<not> trace_simulation f e1 s1 r1 e2 s2\n    r2 t;\n     \\<forall>(s', T)|\\<in>|possible_steps e2 (f s1) r2 l i.\n        evaluate_outputs T i r2 = map Some o \\<longrightarrow>\n        rejects_trace e2 s' (evaluate_updates T i r2) t;\n     a = (l, i, o); (aaa_, ba_) |\\<in>| possible_steps e1 s1 r1 l i;\n     evaluate_outputs ba_ i r1 = map Some o;\n     accepts_trace e1 aaa_ (evaluate_updates ba_ i r1) t;\n     trace_simulation f e1 s1 r1 e2 (f s1) r2 ((l, i, o) # t); s2 = f s1;\n     \\<forall>(s1', t1)\n              |\\<in>|ffilter\n                      (\\<lambda>(s1', t1).\n                          evaluate_outputs t1 i r1 = map Some o)\n                      (possible_steps e1 s1 r1 l i).\n        \\<exists>(s2', t2)|\\<in>|possible_steps e2 (f s1) r2 l i.\n           evaluate_outputs t2 i r2 = map Some o \\<and>\n           trace_simulation f e1 s1' (evaluate_updates t1 i r1) e2 s2'\n            (evaluate_updates t2 i r2) t;\n     ffilter (\\<lambda>(s1', t1). evaluate_outputs t1 i r1 = map Some o)\n      (possible_steps e1 s1 r1 l i) \\<noteq>\n     {||}\\<rbrakk>\n    \\<Longrightarrow> False", "by fastforce"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<not> trace_simulation f e1 s1 r1 e2 s2 r2 (a # t)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma accepts_trace_simulation:\n  \"accepts_trace e1 s1 r1 t \\<Longrightarrow>\n   trace_simulation f e1 s1 r1 e2 s2 r2 t \\<Longrightarrow>\n   accepts_trace e2 s2 r2 t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>accepts_trace e1 s1 r1 t;\n     trace_simulation f e1 s1 r1 e2 s2 r2 t\\<rbrakk>\n    \\<Longrightarrow> accepts_trace e2 s2 r2 t", "using rejects_trace_simulation"], ["proof (prove)\nusing this:\n  \\<lbrakk>rejects_trace ?e2.0 ?s2.0 ?r2.0 ?t;\n   accepts_trace ?e1.0 ?s1.0 ?r1.0 ?t\\<rbrakk>\n  \\<Longrightarrow> \\<not> trace_simulation ?f ?e1.0 ?s1.0 ?r1.0 ?e2.0 ?s2.0\n                            ?r2.0 ?t\n\ngoal (1 subgoal):\n 1. \\<lbrakk>accepts_trace e1 s1 r1 t;\n     trace_simulation f e1 s1 r1 e2 s2 r2 t\\<rbrakk>\n    \\<Longrightarrow> accepts_trace e2 s2 r2 t", "by blast"], ["", "lemma simulates_trace_subset: \"trace_simulates e1 e2 \\<Longrightarrow> T e1 \\<subseteq> T e2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace_simulates e1 e2 \\<Longrightarrow> T e1 \\<subseteq> T e2", "using T_def accepts_trace_simulation trace_simulates_def"], ["proof (prove)\nusing this:\n  T ?e = {t. accepts_trace ?e 0 <> t}\n  \\<lbrakk>accepts_trace ?e1.0 ?s1.0 ?r1.0 ?t;\n   trace_simulation ?f ?e1.0 ?s1.0 ?r1.0 ?e2.0 ?s2.0 ?r2.0 ?t\\<rbrakk>\n  \\<Longrightarrow> accepts_trace ?e2.0 ?s2.0 ?r2.0 ?t\n  trace_simulates ?e1.0 ?e2.0 =\n  (\\<exists>f. \\<forall>t. trace_simulation f ?e1.0 0 <> ?e2.0 0 <> t)\n\ngoal (1 subgoal):\n 1. trace_simulates e1 e2 \\<Longrightarrow> T e1 \\<subseteq> T e2", "by fastforce"], ["", "subsubsection\\<open>Trace Equivalence\\<close>"], ["", "text\\<open>Two EFSMs are trace equivalent if they accept the same traces. This is the intuitive definition\nof ``observable equivalence'' between the behaviours of the two models. If two EFSMs are trace\nequivalent, there is no trace which can distinguish the two.\\<close>"], ["", "text_raw\\<open>\\snip{traceEquiv}{1}{2}{%\\<close>"], ["", "definition \"trace_equivalent e1 e2 = (T e1 = T e2)\""], ["", "text_raw\\<open>}%endsnip\\<close>"], ["", "text_raw\\<open>\\snip{simEquiv}{1}{2}{%\\<close>"], ["", "lemma simulation_implies_trace_equivalent:\n  \"trace_simulates e1 e2 \\<Longrightarrow> trace_simulates e2 e1 \\<Longrightarrow> trace_equivalent e1 e2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>trace_simulates e1 e2; trace_simulates e2 e1\\<rbrakk>\n    \\<Longrightarrow> trace_equivalent e1 e2", "text_raw\\<open>}%endsnip\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>trace_simulates e1 e2; trace_simulates e2 e1\\<rbrakk>\n    \\<Longrightarrow> trace_equivalent e1 e2", "using simulates_trace_subset trace_equivalent_def"], ["proof (prove)\nusing this:\n  trace_simulates ?e1.0 ?e2.0 \\<Longrightarrow> T ?e1.0 \\<subseteq> T ?e2.0\n  trace_equivalent ?e1.0 ?e2.0 = (T ?e1.0 = T ?e2.0)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>trace_simulates e1 e2; trace_simulates e2 e1\\<rbrakk>\n    \\<Longrightarrow> trace_equivalent e1 e2", "by auto"], ["", "lemma trace_equivalent_reflexive: \"trace_equivalent e1 e1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace_equivalent e1 e1", "by (simp add: trace_equivalent_def)"], ["", "lemma trace_equivalent_symmetric:\n  \"trace_equivalent e1 e2 = trace_equivalent e2 e1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace_equivalent e1 e2 = trace_equivalent e2 e1", "using trace_equivalent_def"], ["proof (prove)\nusing this:\n  trace_equivalent ?e1.0 ?e2.0 = (T ?e1.0 = T ?e2.0)\n\ngoal (1 subgoal):\n 1. trace_equivalent e1 e2 = trace_equivalent e2 e1", "by auto"], ["", "lemma trace_equivalent_transitive:\n  \"trace_equivalent e1 e2 \\<Longrightarrow>\n   trace_equivalent e2 e3 \\<Longrightarrow>\n   trace_equivalent e1 e3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>trace_equivalent e1 e2; trace_equivalent e2 e3\\<rbrakk>\n    \\<Longrightarrow> trace_equivalent e1 e3", "by (simp add: trace_equivalent_def)"], ["", "text\\<open>Two EFSMs are trace equivalent if they accept the same traces.\\<close>"], ["", "lemma trace_equivalent:\n  \"\\<forall>t. accepts_trace e1 0 <> t = accepts_trace e2 0 <> t \\<Longrightarrow> trace_equivalent e1 e2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>t.\n       accepts_trace e1 0 <> t = accepts_trace e2 0 <> t \\<Longrightarrow>\n    trace_equivalent e1 e2", "by (simp add: T_def trace_equivalent_def)"], ["", "lemma accepts_trace_step_2: \"(s2', t2) |\\<in>| possible_steps e2 s2 r2 l i \\<Longrightarrow>\n       accepts_trace e2 s2' (evaluate_updates t2 i r2) t \\<Longrightarrow>\n       evaluate_outputs t2 i r2 = map Some p \\<Longrightarrow>\n       accepts_trace e2 s2 r2 ((l, i, p)#t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(s2', t2) |\\<in>| possible_steps e2 s2 r2 l i;\n     accepts_trace e2 s2' (evaluate_updates t2 i r2) t;\n     evaluate_outputs t2 i r2 = map Some p\\<rbrakk>\n    \\<Longrightarrow> accepts_trace e2 s2 r2 ((l, i, p) # t)", "by (rule accepts_trace.step, auto)"], ["", "subsubsection\\<open>Execution Simulation\\<close>"], ["", "text\\<open>Execution simulation is similar to trace simulation but for executions rather than traces.\nExecution simulation has no notion of ``expected'' output. It simply requires that the simulating\nEFSM must be able to produce equivalent output for each action.\\<close>"], ["", "text_raw\\<open>\\snip{execSim}{1}{2}{%\\<close>"], ["", "inductive execution_simulation :: \"(cfstate \\<Rightarrow> cfstate) \\<Rightarrow> transition_matrix \\<Rightarrow> cfstate \\<Rightarrow>\nregisters \\<Rightarrow> transition_matrix \\<Rightarrow> cfstate \\<Rightarrow> registers \\<Rightarrow> execution \\<Rightarrow> bool\" where\n  base: \"s2 = f s1 \\<Longrightarrow> execution_simulation f e1 s1 r1 e2 s2 r2 []\" |\n  step: \"s2 = f s1 \\<Longrightarrow>\n         \\<forall>(s1', t1) |\\<in>| (possible_steps e1 s1 r1 l i).\n           \\<exists>(s2', t2) |\\<in>| possible_steps e2 s2 r2 l i.\n            evaluate_outputs t1 i r1 = evaluate_outputs t2 i r2 \\<and>\n            execution_simulation f e1 s1' (evaluate_updates t1 i r1) e2 s2' (evaluate_updates t2 i r2) es \\<Longrightarrow>\n         execution_simulation f e1 s1 r1 e2 s2 r2 ((l, i)#es)\""], ["", "text_raw\\<open>}%endsnip\\<close>"], ["", "definition \"execution_simulates e1 e2 = (\\<exists>f. \\<forall>t. execution_simulation f e1 0 <> e2 0 <> t)\""], ["", "lemma execution_simulation_step:\n\"execution_simulation f e1 s1 r1 e2 s2 r2 ((l, i)#es) =\n (s2 = f s1 \\<and>\n (\\<forall>(s1', t1) |\\<in>| (possible_steps e1 s1 r1 l i).\n         (\\<exists>(s2', t2) |\\<in>| possible_steps e2 s2 r2 l i. evaluate_outputs t1 i r1 = evaluate_outputs t2 i r2 \\<and>\n         execution_simulation f e1 s1' (evaluate_updates t1 i r1) e2 s2' (evaluate_updates t2 i r2) es))\n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. execution_simulation f e1 s1 r1 e2 s2 r2 ((l, i) # es) =\n    (s2 = f s1 \\<and>\n     (\\<forall>(s1', t1)|\\<in>|possible_steps e1 s1 r1 l i.\n         \\<exists>(s2', t2)|\\<in>|possible_steps e2 s2 r2 l i.\n            evaluate_outputs t1 i r1 = evaluate_outputs t2 i r2 \\<and>\n            execution_simulation f e1 s1' (evaluate_updates t1 i r1) e2 s2'\n             (evaluate_updates t2 i r2) es))", "apply standard"], ["proof (prove)\ngoal (2 subgoals):\n 1. execution_simulation f e1 s1 r1 e2 s2 r2 ((l, i) # es) \\<Longrightarrow>\n    s2 = f s1 \\<and>\n    (\\<forall>(s1', t1)|\\<in>|possible_steps e1 s1 r1 l i.\n        \\<exists>(s2', t2)|\\<in>|possible_steps e2 s2 r2 l i.\n           evaluate_outputs t1 i r1 = evaluate_outputs t2 i r2 \\<and>\n           execution_simulation f e1 s1' (evaluate_updates t1 i r1) e2 s2'\n            (evaluate_updates t2 i r2) es)\n 2. s2 = f s1 \\<and>\n    (\\<forall>(s1', t1)|\\<in>|possible_steps e1 s1 r1 l i.\n        \\<exists>(s2', t2)|\\<in>|possible_steps e2 s2 r2 l i.\n           evaluate_outputs t1 i r1 = evaluate_outputs t2 i r2 \\<and>\n           execution_simulation f e1 s1' (evaluate_updates t1 i r1) e2 s2'\n            (evaluate_updates t2 i r2) es) \\<Longrightarrow>\n    execution_simulation f e1 s1 r1 e2 s2 r2 ((l, i) # es)", "apply (rule execution_simulation.cases)"], ["proof (prove)\ngoal (4 subgoals):\n 1. execution_simulation f e1 s1 r1 e2 s2 r2 ((l, i) # es) \\<Longrightarrow>\n    execution_simulation ?a1.3 ?a2.3 ?a3.3 ?a4.3 ?a5.3 ?a6.3 ?a7.3 ?a8.3\n 2. \\<And>s2a fa s1a e1a r1a e2a r2a.\n       \\<lbrakk>execution_simulation f e1 s1 r1 e2 s2 r2 ((l, i) # es);\n        ?a1.3 = fa; ?a2.3 = e1a; ?a3.3 = s1a; ?a4.3 = r1a; ?a5.3 = e2a;\n        ?a6.3 = s2a; ?a7.3 = r2a; ?a8.3 = []; s2a = fa s1a\\<rbrakk>\n       \\<Longrightarrow> s2 = f s1 \\<and>\n                         (\\<forall>(s1', t1)\n                                   |\\<in>|possible_steps e1 s1 r1 l i.\n                             \\<exists>(s2', t2)\n|\\<in>|possible_steps e2 s2 r2 l i.\n                                evaluate_outputs t1 i r1 =\n                                evaluate_outputs t2 i r2 \\<and>\n                                execution_simulation f e1 s1'\n                                 (evaluate_updates t1 i r1) e2 s2'\n                                 (evaluate_updates t2 i r2) es)\n 3. \\<And>s2a fa s1a e1a r1a la ia e2a r2a esa.\n       \\<lbrakk>execution_simulation f e1 s1 r1 e2 s2 r2 ((l, i) # es);\n        ?a1.3 = fa; ?a2.3 = e1a; ?a3.3 = s1a; ?a4.3 = r1a; ?a5.3 = e2a;\n        ?a6.3 = s2a; ?a7.3 = r2a; ?a8.3 = (la, ia) # esa; s2a = fa s1a;\n        \\<forall>(s1', t1)|\\<in>|possible_steps e1a s1a r1a la ia.\n           \\<exists>(s2', t2)|\\<in>|possible_steps e2a s2a r2a la ia.\n              evaluate_outputs t1 ia r1a = evaluate_outputs t2 ia r2a \\<and>\n              execution_simulation fa e1a s1' (evaluate_updates t1 ia r1a)\n               e2a s2' (evaluate_updates t2 ia r2a) esa\\<rbrakk>\n       \\<Longrightarrow> s2 = f s1 \\<and>\n                         (\\<forall>(s1', t1)\n                                   |\\<in>|possible_steps e1 s1 r1 l i.\n                             \\<exists>(s2', t2)\n|\\<in>|possible_steps e2 s2 r2 l i.\n                                evaluate_outputs t1 i r1 =\n                                evaluate_outputs t2 i r2 \\<and>\n                                execution_simulation f e1 s1'\n                                 (evaluate_updates t1 i r1) e2 s2'\n                                 (evaluate_updates t2 i r2) es)\n 4. s2 = f s1 \\<and>\n    (\\<forall>(s1', t1)|\\<in>|possible_steps e1 s1 r1 l i.\n        \\<exists>(s2', t2)|\\<in>|possible_steps e2 s2 r2 l i.\n           evaluate_outputs t1 i r1 = evaluate_outputs t2 i r2 \\<and>\n           execution_simulation f e1 s1' (evaluate_updates t1 i r1) e2 s2'\n            (evaluate_updates t2 i r2) es) \\<Longrightarrow>\n    execution_simulation f e1 s1 r1 e2 s2 r2 ((l, i) # es)", "apply simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s2a fa s1a e1a r1a e2a r2a.\n       \\<lbrakk>execution_simulation f e1 s1 r1 e2 s2 r2 ((l, i) # es);\n        f = fa; e1 = e1a; s1 = s1a; r1 = r1a; e2 = e2a; s2 = s2a; r2 = r2a;\n        (l, i) # es = []; s2a = fa s1a\\<rbrakk>\n       \\<Longrightarrow> s2 = f s1 \\<and>\n                         (\\<forall>(s1', t1)\n                                   |\\<in>|possible_steps e1 s1 r1 l i.\n                             \\<exists>(s2', t2)\n|\\<in>|possible_steps e2 s2 r2 l i.\n                                evaluate_outputs t1 i r1 =\n                                evaluate_outputs t2 i r2 \\<and>\n                                execution_simulation f e1 s1'\n                                 (evaluate_updates t1 i r1) e2 s2'\n                                 (evaluate_updates t2 i r2) es)\n 2. \\<And>s2a fa s1a e1a r1a la ia e2a r2a esa.\n       \\<lbrakk>execution_simulation f e1 s1 r1 e2 s2 r2 ((l, i) # es);\n        f = fa; e1 = e1a; s1 = s1a; r1 = r1a; e2 = e2a; s2 = s2a; r2 = r2a;\n        (l, i) # es = (la, ia) # esa; s2a = fa s1a;\n        \\<forall>(s1', t1)|\\<in>|possible_steps e1a s1a r1a la ia.\n           \\<exists>(s2', t2)|\\<in>|possible_steps e2a s2a r2a la ia.\n              evaluate_outputs t1 ia r1a = evaluate_outputs t2 ia r2a \\<and>\n              execution_simulation fa e1a s1' (evaluate_updates t1 ia r1a)\n               e2a s2' (evaluate_updates t2 ia r2a) esa\\<rbrakk>\n       \\<Longrightarrow> s2 = f s1 \\<and>\n                         (\\<forall>(s1', t1)\n                                   |\\<in>|possible_steps e1 s1 r1 l i.\n                             \\<exists>(s2', t2)\n|\\<in>|possible_steps e2 s2 r2 l i.\n                                evaluate_outputs t1 i r1 =\n                                evaluate_outputs t2 i r2 \\<and>\n                                execution_simulation f e1 s1'\n                                 (evaluate_updates t1 i r1) e2 s2'\n                                 (evaluate_updates t2 i r2) es)\n 3. s2 = f s1 \\<and>\n    (\\<forall>(s1', t1)|\\<in>|possible_steps e1 s1 r1 l i.\n        \\<exists>(s2', t2)|\\<in>|possible_steps e2 s2 r2 l i.\n           evaluate_outputs t1 i r1 = evaluate_outputs t2 i r2 \\<and>\n           execution_simulation f e1 s1' (evaluate_updates t1 i r1) e2 s2'\n            (evaluate_updates t2 i r2) es) \\<Longrightarrow>\n    execution_simulation f e1 s1 r1 e2 s2 r2 ((l, i) # es)", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s2a fa s1a e1a r1a la ia e2a r2a esa.\n       \\<lbrakk>execution_simulation f e1 s1 r1 e2 s2 r2 ((l, i) # es);\n        f = fa; e1 = e1a; s1 = s1a; r1 = r1a; e2 = e2a; s2 = s2a; r2 = r2a;\n        (l, i) # es = (la, ia) # esa; s2a = fa s1a;\n        \\<forall>(s1', t1)|\\<in>|possible_steps e1a s1a r1a la ia.\n           \\<exists>(s2', t2)|\\<in>|possible_steps e2a s2a r2a la ia.\n              evaluate_outputs t1 ia r1a = evaluate_outputs t2 ia r2a \\<and>\n              execution_simulation fa e1a s1' (evaluate_updates t1 ia r1a)\n               e2a s2' (evaluate_updates t2 ia r2a) esa\\<rbrakk>\n       \\<Longrightarrow> s2 = f s1 \\<and>\n                         (\\<forall>(s1', t1)\n                                   |\\<in>|possible_steps e1 s1 r1 l i.\n                             \\<exists>(s2', t2)\n|\\<in>|possible_steps e2 s2 r2 l i.\n                                evaluate_outputs t1 i r1 =\n                                evaluate_outputs t2 i r2 \\<and>\n                                execution_simulation f e1 s1'\n                                 (evaluate_updates t1 i r1) e2 s2'\n                                 (evaluate_updates t2 i r2) es)\n 2. s2 = f s1 \\<and>\n    (\\<forall>(s1', t1)|\\<in>|possible_steps e1 s1 r1 l i.\n        \\<exists>(s2', t2)|\\<in>|possible_steps e2 s2 r2 l i.\n           evaluate_outputs t1 i r1 = evaluate_outputs t2 i r2 \\<and>\n           execution_simulation f e1 s1' (evaluate_updates t1 i r1) e2 s2'\n            (evaluate_updates t2 i r2) es) \\<Longrightarrow>\n    execution_simulation f e1 s1 r1 e2 s2 r2 ((l, i) # es)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. s2 = f s1 \\<and>\n    (\\<forall>(s1', t1)|\\<in>|possible_steps e1 s1 r1 l i.\n        \\<exists>(s2', t2)|\\<in>|possible_steps e2 s2 r2 l i.\n           evaluate_outputs t1 i r1 = evaluate_outputs t2 i r2 \\<and>\n           execution_simulation f e1 s1' (evaluate_updates t1 i r1) e2 s2'\n            (evaluate_updates t2 i r2) es) \\<Longrightarrow>\n    execution_simulation f e1 s1 r1 e2 s2 r2 ((l, i) # es)", "apply (rule execution_simulation.step)"], ["proof (prove)\ngoal (2 subgoals):\n 1. s2 = f s1 \\<and>\n    (\\<forall>(s1', t1)|\\<in>|possible_steps e1 s1 r1 l i.\n        \\<exists>(s2', t2)|\\<in>|possible_steps e2 s2 r2 l i.\n           evaluate_outputs t1 i r1 = evaluate_outputs t2 i r2 \\<and>\n           execution_simulation f e1 s1' (evaluate_updates t1 i r1) e2 s2'\n            (evaluate_updates t2 i r2) es) \\<Longrightarrow>\n    s2 = f s1\n 2. s2 = f s1 \\<and>\n    (\\<forall>(s1', t1)|\\<in>|possible_steps e1 s1 r1 l i.\n        \\<exists>(s2', t2)|\\<in>|possible_steps e2 s2 r2 l i.\n           evaluate_outputs t1 i r1 = evaluate_outputs t2 i r2 \\<and>\n           execution_simulation f e1 s1' (evaluate_updates t1 i r1) e2 s2'\n            (evaluate_updates t2 i r2) es) \\<Longrightarrow>\n    \\<forall>(s1', t1)|\\<in>|possible_steps e1 s1 r1 l i.\n       \\<exists>(s2', t2)|\\<in>|possible_steps e2 s2 r2 l i.\n          evaluate_outputs t1 i r1 = evaluate_outputs t2 i r2 \\<and>\n          execution_simulation f e1 s1' (evaluate_updates t1 i r1) e2 s2'\n           (evaluate_updates t2 i r2) es", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. s2 = f s1 \\<and>\n    (\\<forall>(s1', t1)|\\<in>|possible_steps e1 s1 r1 l i.\n        \\<exists>(s2', t2)|\\<in>|possible_steps e2 s2 r2 l i.\n           evaluate_outputs t1 i r1 = evaluate_outputs t2 i r2 \\<and>\n           execution_simulation f e1 s1' (evaluate_updates t1 i r1) e2 s2'\n            (evaluate_updates t2 i r2) es) \\<Longrightarrow>\n    \\<forall>(s1', t1)|\\<in>|possible_steps e1 s1 r1 l i.\n       \\<exists>(s2', t2)|\\<in>|possible_steps e2 s2 r2 l i.\n          evaluate_outputs t1 i r1 = evaluate_outputs t2 i r2 \\<and>\n          execution_simulation f e1 s1' (evaluate_updates t1 i r1) e2 s2'\n           (evaluate_updates t2 i r2) es", "by blast"], ["", "text_raw\\<open>\\snip{execTraceSim}{1}{2}{%\\<close>"], ["", "lemma execution_simulation_trace_simulation:\n  \"execution_simulation f e1 s1 r1 e2 s2 r2 (map (\\<lambda>(l, i, o). (l, i)) t) \\<Longrightarrow>\n   trace_simulation f e1 s1 r1 e2 s2 r2 t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. execution_simulation f e1 s1 r1 e2 s2 r2\n     (map (\\<lambda>(l, i, o). (l, i)) t) \\<Longrightarrow>\n    trace_simulation f e1 s1 r1 e2 s2 r2 t", "text_raw\\<open>}%endsnip\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. execution_simulation f e1 s1 r1 e2 s2 r2\n     (map (\\<lambda>(l, i, o). (l, i)) t) \\<Longrightarrow>\n    trace_simulation f e1 s1 r1 e2 s2 r2 t", "proof(induct t arbitrary: s1 s2 r1 r2)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s1 s2 r1 r2.\n       execution_simulation f e1 s1 r1 e2 s2 r2\n        (map (\\<lambda>(l, i, o). (l, i)) []) \\<Longrightarrow>\n       trace_simulation f e1 s1 r1 e2 s2 r2 []\n 2. \\<And>a t s1 s2 r1 r2.\n       \\<lbrakk>\\<And>s1 s2 r1 r2.\n                   execution_simulation f e1 s1 r1 e2 s2 r2\n                    (map (\\<lambda>(l, i, o). (l, i)) t) \\<Longrightarrow>\n                   trace_simulation f e1 s1 r1 e2 s2 r2 t;\n        execution_simulation f e1 s1 r1 e2 s2 r2\n         (map (\\<lambda>(l, i, o). (l, i)) (a # t))\\<rbrakk>\n       \\<Longrightarrow> trace_simulation f e1 s1 r1 e2 s2 r2 (a # t)", "case Nil"], ["proof (state)\nthis:\n  execution_simulation f e1 s1 r1 e2 s2 r2\n   (map (\\<lambda>a. case a of (l, i, o) \\<Rightarrow> (l, i)) [])\n\ngoal (2 subgoals):\n 1. \\<And>s1 s2 r1 r2.\n       execution_simulation f e1 s1 r1 e2 s2 r2\n        (map (\\<lambda>(l, i, o). (l, i)) []) \\<Longrightarrow>\n       trace_simulation f e1 s1 r1 e2 s2 r2 []\n 2. \\<And>a t s1 s2 r1 r2.\n       \\<lbrakk>\\<And>s1 s2 r1 r2.\n                   execution_simulation f e1 s1 r1 e2 s2 r2\n                    (map (\\<lambda>(l, i, o). (l, i)) t) \\<Longrightarrow>\n                   trace_simulation f e1 s1 r1 e2 s2 r2 t;\n        execution_simulation f e1 s1 r1 e2 s2 r2\n         (map (\\<lambda>(l, i, o). (l, i)) (a # t))\\<rbrakk>\n       \\<Longrightarrow> trace_simulation f e1 s1 r1 e2 s2 r2 (a # t)", "then"], ["proof (chain)\npicking this:\n  execution_simulation f e1 s1 r1 e2 s2 r2\n   (map (\\<lambda>a. case a of (l, i, o) \\<Rightarrow> (l, i)) [])", "show ?case"], ["proof (prove)\nusing this:\n  execution_simulation f e1 s1 r1 e2 s2 r2\n   (map (\\<lambda>a. case a of (l, i, o) \\<Rightarrow> (l, i)) [])\n\ngoal (1 subgoal):\n 1. trace_simulation f e1 s1 r1 e2 s2 r2 []", "apply (rule execution_simulation.cases)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s2 fa s1 e1a r1 e2a r2.\n       \\<lbrakk>f = fa; e1 = e1a; s1 = s1; r1 = r1; e2 = e2a; s2 = s2;\n        r2 = r2;\n        map (\\<lambda>a. case a of (l, i, o) \\<Rightarrow> (l, i)) [] = [];\n        s2 = fa s1\\<rbrakk>\n       \\<Longrightarrow> trace_simulation f e1 s1 r1 e2 s2 r2 []\n 2. \\<And>s2 fa s1 e1a r1 l i e2a r2 es.\n       \\<lbrakk>f = fa; e1 = e1a; s1 = s1; r1 = r1; e2 = e2a; s2 = s2;\n        r2 = r2;\n        map (\\<lambda>a. case a of (l, i, o) \\<Rightarrow> (l, i)) [] =\n        (l, i) # es;\n        s2 = fa s1;\n        \\<forall>(s1', t1)|\\<in>|possible_steps e1a s1 r1 l i.\n           \\<exists>(s2', t2)|\\<in>|possible_steps e2a s2 r2 l i.\n              evaluate_outputs t1 i r1 = evaluate_outputs t2 i r2 \\<and>\n              execution_simulation fa e1a s1' (evaluate_updates t1 i r1) e2a\n               s2' (evaluate_updates t2 i r2) es\\<rbrakk>\n       \\<Longrightarrow> trace_simulation f e1 s1 r1 e2 s2 r2 []", "apply (simp add: trace_simulation.base)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s2 fa s1 e1a r1 l i e2a r2 es.\n       \\<lbrakk>f = fa; e1 = e1a; s1 = s1; r1 = r1; e2 = e2a; s2 = s2;\n        r2 = r2;\n        map (\\<lambda>a. case a of (l, i, o) \\<Rightarrow> (l, i)) [] =\n        (l, i) # es;\n        s2 = fa s1;\n        \\<forall>(s1', t1)|\\<in>|possible_steps e1a s1 r1 l i.\n           \\<exists>(s2', t2)|\\<in>|possible_steps e2a s2 r2 l i.\n              evaluate_outputs t1 i r1 = evaluate_outputs t2 i r2 \\<and>\n              execution_simulation fa e1a s1' (evaluate_updates t1 i r1) e2a\n               s2' (evaluate_updates t2 i r2) es\\<rbrakk>\n       \\<Longrightarrow> trace_simulation f e1 s1 r1 e2 s2 r2 []", "by simp"], ["proof (state)\nthis:\n  trace_simulation f e1 s1 r1 e2 s2 r2 []\n\ngoal (1 subgoal):\n 1. \\<And>a t s1 s2 r1 r2.\n       \\<lbrakk>\\<And>s1 s2 r1 r2.\n                   execution_simulation f e1 s1 r1 e2 s2 r2\n                    (map (\\<lambda>(l, i, o). (l, i)) t) \\<Longrightarrow>\n                   trace_simulation f e1 s1 r1 e2 s2 r2 t;\n        execution_simulation f e1 s1 r1 e2 s2 r2\n         (map (\\<lambda>(l, i, o). (l, i)) (a # t))\\<rbrakk>\n       \\<Longrightarrow> trace_simulation f e1 s1 r1 e2 s2 r2 (a # t)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a t s1 s2 r1 r2.\n       \\<lbrakk>\\<And>s1 s2 r1 r2.\n                   execution_simulation f e1 s1 r1 e2 s2 r2\n                    (map (\\<lambda>(l, i, o). (l, i)) t) \\<Longrightarrow>\n                   trace_simulation f e1 s1 r1 e2 s2 r2 t;\n        execution_simulation f e1 s1 r1 e2 s2 r2\n         (map (\\<lambda>(l, i, o). (l, i)) (a # t))\\<rbrakk>\n       \\<Longrightarrow> trace_simulation f e1 s1 r1 e2 s2 r2 (a # t)", "case (Cons a t)"], ["proof (state)\nthis:\n  execution_simulation f e1 ?s1.0 ?r1.0 e2 ?s2.0 ?r2.0\n   (map (\\<lambda>a. case a of (l, i, o) \\<Rightarrow> (l, i))\n     t) \\<Longrightarrow>\n  trace_simulation f e1 ?s1.0 ?r1.0 e2 ?s2.0 ?r2.0 t\n  execution_simulation f e1 s1 r1 e2 s2 r2\n   (map (\\<lambda>a. case a of (l, i, o) \\<Rightarrow> (l, i)) (a # t))\n\ngoal (1 subgoal):\n 1. \\<And>a t s1 s2 r1 r2.\n       \\<lbrakk>\\<And>s1 s2 r1 r2.\n                   execution_simulation f e1 s1 r1 e2 s2 r2\n                    (map (\\<lambda>(l, i, o). (l, i)) t) \\<Longrightarrow>\n                   trace_simulation f e1 s1 r1 e2 s2 r2 t;\n        execution_simulation f e1 s1 r1 e2 s2 r2\n         (map (\\<lambda>(l, i, o). (l, i)) (a # t))\\<rbrakk>\n       \\<Longrightarrow> trace_simulation f e1 s1 r1 e2 s2 r2 (a # t)", "then"], ["proof (chain)\npicking this:\n  execution_simulation f e1 ?s1.0 ?r1.0 e2 ?s2.0 ?r2.0\n   (map (\\<lambda>a. case a of (l, i, o) \\<Rightarrow> (l, i))\n     t) \\<Longrightarrow>\n  trace_simulation f e1 ?s1.0 ?r1.0 e2 ?s2.0 ?r2.0 t\n  execution_simulation f e1 s1 r1 e2 s2 r2\n   (map (\\<lambda>a. case a of (l, i, o) \\<Rightarrow> (l, i)) (a # t))", "show ?case"], ["proof (prove)\nusing this:\n  execution_simulation f e1 ?s1.0 ?r1.0 e2 ?s2.0 ?r2.0\n   (map (\\<lambda>a. case a of (l, i, o) \\<Rightarrow> (l, i))\n     t) \\<Longrightarrow>\n  trace_simulation f e1 ?s1.0 ?r1.0 e2 ?s2.0 ?r2.0 t\n  execution_simulation f e1 s1 r1 e2 s2 r2\n   (map (\\<lambda>a. case a of (l, i, o) \\<Rightarrow> (l, i)) (a # t))\n\ngoal (1 subgoal):\n 1. trace_simulation f e1 s1 r1 e2 s2 r2 (a # t)", "apply (cases a, clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b c.\n       \\<lbrakk>execution_simulation f e1 s1 r1 e2 s2 r2\n                 ((aa, b) # map (\\<lambda>(l, i, o). (l, i)) t);\n        a = (aa, b, c);\n        \\<And>s1 r1 s2 r2.\n           execution_simulation f e1 s1 r1 e2 s2 r2\n            (map (\\<lambda>(l, i, o). (l, i)) t) \\<Longrightarrow>\n           trace_simulation f e1 s1 r1 e2 s2 r2 t\\<rbrakk>\n       \\<Longrightarrow> trace_simulation f e1 s1 r1 e2 s2 r2\n                          ((aa, b, c) # t)", "apply (rule execution_simulation.cases)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>aa b c.\n       \\<lbrakk>execution_simulation f e1 s1 r1 e2 s2 r2\n                 ((aa, b) # map (\\<lambda>(l, i, o). (l, i)) t);\n        a = (aa, b, c);\n        \\<And>s1 r1 s2 r2.\n           execution_simulation f e1 s1 r1 e2 s2 r2\n            (map (\\<lambda>(l, i, o). (l, i)) t) \\<Longrightarrow>\n           trace_simulation f e1 s1 r1 e2 s2 r2 t\\<rbrakk>\n       \\<Longrightarrow> execution_simulation (?a1.7 aa b c) (?a2.7 aa b c)\n                          (?a3.7 aa b c) (?a4.7 aa b c) (?a5.7 aa b c)\n                          (?a6.7 aa b c) (?a7.7 aa b c) (?a8.7 aa b c)\n 2. \\<And>aa b c s2 fa s1 e1a r1 e2a r2.\n       \\<lbrakk>execution_simulation f e1 s1 r1 e2 s2 r2\n                 ((aa, b) # map (\\<lambda>(l, i, o). (l, i)) t);\n        a = (aa, b, c);\n        \\<And>s1 r1 s2 r2.\n           execution_simulation f e1 s1 r1 e2 s2 r2\n            (map (\\<lambda>(l, i, o). (l, i)) t) \\<Longrightarrow>\n           trace_simulation f e1 s1 r1 e2 s2 r2 t;\n        ?a1.7 aa b c = fa; ?a2.7 aa b c = e1a; ?a3.7 aa b c = s1;\n        ?a4.7 aa b c = r1; ?a5.7 aa b c = e2a; ?a6.7 aa b c = s2;\n        ?a7.7 aa b c = r2; ?a8.7 aa b c = []; s2 = fa s1\\<rbrakk>\n       \\<Longrightarrow> trace_simulation f e1 s1 r1 e2 s2 r2\n                          ((aa, b, c) # t)\n 3. \\<And>aa b c s2 fa s1 e1a r1 l i e2a r2 es.\n       \\<lbrakk>execution_simulation f e1 s1 r1 e2 s2 r2\n                 ((aa, b) # map (\\<lambda>(l, i, o). (l, i)) t);\n        a = (aa, b, c);\n        \\<And>s1 r1 s2 r2.\n           execution_simulation f e1 s1 r1 e2 s2 r2\n            (map (\\<lambda>(l, i, o). (l, i)) t) \\<Longrightarrow>\n           trace_simulation f e1 s1 r1 e2 s2 r2 t;\n        ?a1.7 aa b c = fa; ?a2.7 aa b c = e1a; ?a3.7 aa b c = s1;\n        ?a4.7 aa b c = r1; ?a5.7 aa b c = e2a; ?a6.7 aa b c = s2;\n        ?a7.7 aa b c = r2; ?a8.7 aa b c = (l, i) # es; s2 = fa s1;\n        \\<forall>(s1', t1)|\\<in>|possible_steps e1a s1 r1 l i.\n           \\<exists>(s2', t2)|\\<in>|possible_steps e2a s2 r2 l i.\n              evaluate_outputs t1 i r1 = evaluate_outputs t2 i r2 \\<and>\n              execution_simulation fa e1a s1' (evaluate_updates t1 i r1) e2a\n               s2' (evaluate_updates t2 i r2) es\\<rbrakk>\n       \\<Longrightarrow> trace_simulation f e1 s1 r1 e2 s2 r2\n                          ((aa, b, c) # t)", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa b c s2 fa s1 e1a r1 e2a r2.\n       \\<lbrakk>execution_simulation f e1 s1 r1 e2 s2 r2\n                 ((aa, b) # map (\\<lambda>(l, i, o). (l, i)) t);\n        a = (aa, b, c);\n        \\<And>s1 r1 s2 r2.\n           execution_simulation f e1 s1 r1 e2 s2 r2\n            (map (\\<lambda>(l, i, o). (l, i)) t) \\<Longrightarrow>\n           trace_simulation f e1 s1 r1 e2 s2 r2 t;\n        f = fa; e1 = e1a; s1 = s1; r1 = r1; e2 = e2a; s2 = s2; r2 = r2;\n        (aa, b) # map (\\<lambda>(l, i, o). (l, i)) t = [];\n        s2 = fa s1\\<rbrakk>\n       \\<Longrightarrow> trace_simulation f e1 s1 r1 e2 s2 r2\n                          ((aa, b, c) # t)\n 2. \\<And>aa b c s2 fa s1 e1a r1 l i e2a r2 es.\n       \\<lbrakk>execution_simulation f e1 s1 r1 e2 s2 r2\n                 ((aa, b) # map (\\<lambda>(l, i, o). (l, i)) t);\n        a = (aa, b, c);\n        \\<And>s1 r1 s2 r2.\n           execution_simulation f e1 s1 r1 e2 s2 r2\n            (map (\\<lambda>(l, i, o). (l, i)) t) \\<Longrightarrow>\n           trace_simulation f e1 s1 r1 e2 s2 r2 t;\n        f = fa; e1 = e1a; s1 = s1; r1 = r1; e2 = e2a; s2 = s2; r2 = r2;\n        (aa, b) # map (\\<lambda>(l, i, o). (l, i)) t = (l, i) # es;\n        s2 = fa s1;\n        \\<forall>(s1', t1)|\\<in>|possible_steps e1a s1 r1 l i.\n           \\<exists>(s2', t2)|\\<in>|possible_steps e2a s2 r2 l i.\n              evaluate_outputs t1 i r1 = evaluate_outputs t2 i r2 \\<and>\n              execution_simulation fa e1a s1' (evaluate_updates t1 i r1) e2a\n               s2' (evaluate_updates t2 i r2) es\\<rbrakk>\n       \\<Longrightarrow> trace_simulation f e1 s1 r1 e2 s2 r2\n                          ((aa, b, c) # t)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b c s2 fa s1 e1a r1 l i e2a r2 es.\n       \\<lbrakk>execution_simulation f e1 s1 r1 e2 s2 r2\n                 ((aa, b) # map (\\<lambda>(l, i, o). (l, i)) t);\n        a = (aa, b, c);\n        \\<And>s1 r1 s2 r2.\n           execution_simulation f e1 s1 r1 e2 s2 r2\n            (map (\\<lambda>(l, i, o). (l, i)) t) \\<Longrightarrow>\n           trace_simulation f e1 s1 r1 e2 s2 r2 t;\n        f = fa; e1 = e1a; s1 = s1; r1 = r1; e2 = e2a; s2 = s2; r2 = r2;\n        (aa, b) # map (\\<lambda>(l, i, o). (l, i)) t = (l, i) # es;\n        s2 = fa s1;\n        \\<forall>(s1', t1)|\\<in>|possible_steps e1a s1 r1 l i.\n           \\<exists>(s2', t2)|\\<in>|possible_steps e2a s2 r2 l i.\n              evaluate_outputs t1 i r1 = evaluate_outputs t2 i r2 \\<and>\n              execution_simulation fa e1a s1' (evaluate_updates t1 i r1) e2a\n               s2' (evaluate_updates t2 i r2) es\\<rbrakk>\n       \\<Longrightarrow> trace_simulation f e1 s1 r1 e2 s2 r2\n                          ((aa, b, c) # t)", "apply (rule trace_simulation.step)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa b c s2 fa s1 e1a r1 l i e2a r2 es.\n       \\<lbrakk>execution_simulation f e1 s1 r1 e2 s2 r2\n                 ((aa, b) # map (\\<lambda>(l, i, o). (l, i)) t);\n        a = (aa, b, c);\n        \\<And>s1 r1 s2 r2.\n           execution_simulation f e1 s1 r1 e2 s2 r2\n            (map (\\<lambda>(l, i, o). (l, i)) t) \\<Longrightarrow>\n           trace_simulation f e1 s1 r1 e2 s2 r2 t;\n        f = fa; e1 = e1a; s1 = s1; r1 = r1; e2 = e2a; s2 = s2; r2 = r2;\n        (aa, b) # map (\\<lambda>(l, i, o). (l, i)) t = (l, i) # es;\n        s2 = fa s1;\n        \\<forall>(s1', t1)|\\<in>|possible_steps e1a s1 r1 l i.\n           \\<exists>(s2', t2)|\\<in>|possible_steps e2a s2 r2 l i.\n              evaluate_outputs t1 i r1 = evaluate_outputs t2 i r2 \\<and>\n              execution_simulation fa e1a s1' (evaluate_updates t1 i r1) e2a\n               s2' (evaluate_updates t2 i r2) es\\<rbrakk>\n       \\<Longrightarrow> s2 = f s1\n 2. \\<And>aa b c s2 fa s1 e1a r1 l i e2a r2 es.\n       \\<lbrakk>execution_simulation f e1 s1 r1 e2 s2 r2\n                 ((aa, b) # map (\\<lambda>(l, i, o). (l, i)) t);\n        a = (aa, b, c);\n        \\<And>s1 r1 s2 r2.\n           execution_simulation f e1 s1 r1 e2 s2 r2\n            (map (\\<lambda>(l, i, o). (l, i)) t) \\<Longrightarrow>\n           trace_simulation f e1 s1 r1 e2 s2 r2 t;\n        f = fa; e1 = e1a; s1 = s1; r1 = r1; e2 = e2a; s2 = s2; r2 = r2;\n        (aa, b) # map (\\<lambda>(l, i, o). (l, i)) t = (l, i) # es;\n        s2 = fa s1;\n        \\<forall>(s1', t1)|\\<in>|possible_steps e1a s1 r1 l i.\n           \\<exists>(s2', t2)|\\<in>|possible_steps e2a s2 r2 l i.\n              evaluate_outputs t1 i r1 = evaluate_outputs t2 i r2 \\<and>\n              execution_simulation fa e1a s1' (evaluate_updates t1 i r1) e2a\n               s2' (evaluate_updates t2 i r2) es\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(s1', t1)\n                                  |\\<in>|ffilter\n    (\\<lambda>(s1', t1). evaluate_outputs t1 b r1 = map Some c)\n    (possible_steps e1 s1 r1 aa b).\n                            \\<exists>(s2', t2)\n                                     |\\<in>|possible_steps e2 s2 r2 aa b.\n                               evaluate_outputs t2 b r2 = map Some c \\<and>\n                               trace_simulation f e1 s1'\n                                (evaluate_updates t1 b r1) e2 s2'\n                                (evaluate_updates t2 b r2) t", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b c s2 fa s1 e1a r1 l i e2a r2 es.\n       \\<lbrakk>execution_simulation f e1 s1 r1 e2 s2 r2\n                 ((aa, b) # map (\\<lambda>(l, i, o). (l, i)) t);\n        a = (aa, b, c);\n        \\<And>s1 r1 s2 r2.\n           execution_simulation f e1 s1 r1 e2 s2 r2\n            (map (\\<lambda>(l, i, o). (l, i)) t) \\<Longrightarrow>\n           trace_simulation f e1 s1 r1 e2 s2 r2 t;\n        f = fa; e1 = e1a; s1 = s1; r1 = r1; e2 = e2a; s2 = s2; r2 = r2;\n        (aa, b) # map (\\<lambda>(l, i, o). (l, i)) t = (l, i) # es;\n        s2 = fa s1;\n        \\<forall>(s1', t1)|\\<in>|possible_steps e1a s1 r1 l i.\n           \\<exists>(s2', t2)|\\<in>|possible_steps e2a s2 r2 l i.\n              evaluate_outputs t1 i r1 = evaluate_outputs t2 i r2 \\<and>\n              execution_simulation fa e1a s1' (evaluate_updates t1 i r1) e2a\n               s2' (evaluate_updates t2 i r2) es\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(s1', t1)\n                                  |\\<in>|ffilter\n    (\\<lambda>(s1', t1). evaluate_outputs t1 b r1 = map Some c)\n    (possible_steps e1 s1 r1 aa b).\n                            \\<exists>(s2', t2)\n                                     |\\<in>|possible_steps e2 s2 r2 aa b.\n                               evaluate_outputs t2 b r2 = map Some c \\<and>\n                               trace_simulation f e1 s1'\n                                (evaluate_updates t1 b r1) e2 s2'\n                                (evaluate_updates t2 b r2) t", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b c l aa ba.\n       \\<lbrakk>execution_simulation f e1 s1 r1 e2 (f s1) r2\n                 ((l, b) # map (\\<lambda>(l, i, o). (l, i)) t);\n        a = (l, b, c);\n        \\<And>s1 r1 s2 r2.\n           execution_simulation f e1 s1 r1 e2 s2 r2\n            (map (\\<lambda>(l, i, o). (l, i)) t) \\<Longrightarrow>\n           trace_simulation f e1 s1 r1 e2 s2 r2 t;\n        s2 = f s1;\n        \\<forall>(s1', t1)|\\<in>|possible_steps e1 s1 r1 l b.\n           \\<exists>(s2', t2)|\\<in>|possible_steps e2 (f s1) r2 l b.\n              evaluate_outputs t1 b r1 = evaluate_outputs t2 b r2 \\<and>\n              execution_simulation f e1 s1' (evaluate_updates t1 b r1) e2\n               s2' (evaluate_updates t2 b r2)\n               (map (\\<lambda>(l, i, o). (l, i)) t);\n        (aa, ba) |\\<in>| possible_steps e1 s1 r1 l b;\n        evaluate_outputs ba b r1 = map Some c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>(s2', t2)\n                                  |\\<in>|possible_steps e2 (f s1) r2 l b.\n                            evaluate_outputs t2 b r2 = map Some c \\<and>\n                            trace_simulation f e1 aa\n                             (evaluate_updates ba b r1) e2 s2'\n                             (evaluate_updates t2 b r2) t", "subgoal for _ _ _ aa ba"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>execution_simulation f e1 s1 r1 e2 (f s1) r2\n              ((l_, b_) # map (\\<lambda>(l, i, o). (l, i)) t);\n     a = (l_, b_, c_);\n     \\<And>s1 r1 s2 r2.\n        execution_simulation f e1 s1 r1 e2 s2 r2\n         (map (\\<lambda>(l, i, o). (l, i)) t) \\<Longrightarrow>\n        trace_simulation f e1 s1 r1 e2 s2 r2 t;\n     s2 = f s1;\n     \\<forall>(s1', t1)|\\<in>|possible_steps e1 s1 r1 l_ b_.\n        \\<exists>(s2', t2)|\\<in>|possible_steps e2 (f s1) r2 l_ b_.\n           evaluate_outputs t1 b_ r1 = evaluate_outputs t2 b_ r2 \\<and>\n           execution_simulation f e1 s1' (evaluate_updates t1 b_ r1) e2 s2'\n            (evaluate_updates t2 b_ r2)\n            (map (\\<lambda>(l, i, o). (l, i)) t);\n     (aa, ba) |\\<in>| possible_steps e1 s1 r1 l_ b_;\n     evaluate_outputs ba b_ r1 = map Some c_\\<rbrakk>\n    \\<Longrightarrow> \\<exists>(s2', t2)\n                               |\\<in>|possible_steps e2 (f s1) r2 l_ b_.\n                         evaluate_outputs t2 b_ r2 = map Some c_ \\<and>\n                         trace_simulation f e1 aa\n                          (evaluate_updates ba b_ r1) e2 s2'\n                          (evaluate_updates t2 b_ r2) t", "apply (erule_tac x=\"(aa, ba)\" in fBallE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>execution_simulation f e1 s1 r1 e2 (f s1) r2\n              ((l_, b_) # map (\\<lambda>(l, i, o). (l, i)) t);\n     a = (l_, b_, c_);\n     \\<And>s1 r1 s2 r2.\n        execution_simulation f e1 s1 r1 e2 s2 r2\n         (map (\\<lambda>(l, i, o). (l, i)) t) \\<Longrightarrow>\n        trace_simulation f e1 s1 r1 e2 s2 r2 t;\n     s2 = f s1; (aa, ba) |\\<in>| possible_steps e1 s1 r1 l_ b_;\n     evaluate_outputs ba b_ r1 = map Some c_;\n     case (aa, ba) of\n     (s1', t1) \\<Rightarrow>\n       \\<exists>(s2', t2)|\\<in>|possible_steps e2 (f s1) r2 l_ b_.\n          evaluate_outputs t1 b_ r1 = evaluate_outputs t2 b_ r2 \\<and>\n          execution_simulation f e1 s1' (evaluate_updates t1 b_ r1) e2 s2'\n           (evaluate_updates t2 b_ r2)\n           (map (\\<lambda>(l, i, o). (l, i)) t)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>(s2', t2)\n                               |\\<in>|possible_steps e2 (f s1) r2 l_ b_.\n                         evaluate_outputs t2 b_ r2 = map Some c_ \\<and>\n                         trace_simulation f e1 aa\n                          (evaluate_updates ba b_ r1) e2 s2'\n                          (evaluate_updates t2 b_ r2) t\n 2. \\<lbrakk>execution_simulation f e1 s1 r1 e2 (f s1) r2\n              ((l_, b_) # map (\\<lambda>(l, i, o). (l, i)) t);\n     a = (l_, b_, c_);\n     \\<And>s1 r1 s2 r2.\n        execution_simulation f e1 s1 r1 e2 s2 r2\n         (map (\\<lambda>(l, i, o). (l, i)) t) \\<Longrightarrow>\n        trace_simulation f e1 s1 r1 e2 s2 r2 t;\n     s2 = f s1; (aa, ba) |\\<in>| possible_steps e1 s1 r1 l_ b_;\n     evaluate_outputs ba b_ r1 = map Some c_;\n     (aa, ba) |\\<notin>| possible_steps e1 s1 r1 l_ b_\\<rbrakk>\n    \\<Longrightarrow> \\<exists>(s2', t2)\n                               |\\<in>|possible_steps e2 (f s1) r2 l_ b_.\n                         evaluate_outputs t2 b_ r2 = map Some c_ \\<and>\n                         trace_simulation f e1 aa\n                          (evaluate_updates ba b_ r1) e2 s2'\n                          (evaluate_updates t2 b_ r2) t", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ab bb.\n       \\<lbrakk>execution_simulation f e1 s1 r1 e2 (f s1) r2\n                 ((l_, b_) # map (\\<lambda>(l, i, o). (l, i)) t);\n        a = (l_, b_, c_);\n        \\<And>s1 r1 s2 r2.\n           execution_simulation f e1 s1 r1 e2 s2 r2\n            (map (\\<lambda>(l, i, o). (l, i)) t) \\<Longrightarrow>\n           trace_simulation f e1 s1 r1 e2 s2 r2 t;\n        s2 = f s1; (aa, ba) |\\<in>| possible_steps e1 s1 r1 l_ b_;\n        evaluate_outputs ba b_ r1 = evaluate_outputs bb b_ r2;\n        (ab, bb) |\\<in>| possible_steps e2 (f s1) r2 l_ b_;\n        map Some c_ = evaluate_outputs bb b_ r2;\n        execution_simulation f e1 aa (evaluate_updates ba b_ r1) e2 ab\n         (evaluate_updates bb b_ r2)\n         (map (\\<lambda>(l, i, o). (l, i)) t)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>(s2', t2)\n                                  |\\<in>|possible_steps e2 (f s1) r2 l_ b_.\n                            evaluate_outputs t2 b_ r2 =\n                            evaluate_outputs bb b_ r2 \\<and>\n                            trace_simulation f e1 aa\n                             (evaluate_updates ba b_ r1) e2 s2'\n                             (evaluate_updates t2 b_ r2) t\n 2. \\<lbrakk>execution_simulation f e1 s1 r1 e2 (f s1) r2\n              ((l_, b_) # map (\\<lambda>(l, i, o). (l, i)) t);\n     a = (l_, b_, c_);\n     \\<And>s1 r1 s2 r2.\n        execution_simulation f e1 s1 r1 e2 s2 r2\n         (map (\\<lambda>(l, i, o). (l, i)) t) \\<Longrightarrow>\n        trace_simulation f e1 s1 r1 e2 s2 r2 t;\n     s2 = f s1; (aa, ba) |\\<in>| possible_steps e1 s1 r1 l_ b_;\n     evaluate_outputs ba b_ r1 = map Some c_;\n     (aa, ba) |\\<notin>| possible_steps e1 s1 r1 l_ b_\\<rbrakk>\n    \\<Longrightarrow> \\<exists>(s2', t2)\n                               |\\<in>|possible_steps e2 (f s1) r2 l_ b_.\n                         evaluate_outputs t2 b_ r2 = map Some c_ \\<and>\n                         trace_simulation f e1 aa\n                          (evaluate_updates ba b_ r1) e2 s2'\n                          (evaluate_updates t2 b_ r2) t", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>execution_simulation f e1 s1 r1 e2 (f s1) r2\n              ((l_, b_) # map (\\<lambda>(l, i, o). (l, i)) t);\n     a = (l_, b_, c_);\n     \\<And>s1 r1 s2 r2.\n        execution_simulation f e1 s1 r1 e2 s2 r2\n         (map (\\<lambda>(l, i, o). (l, i)) t) \\<Longrightarrow>\n        trace_simulation f e1 s1 r1 e2 s2 r2 t;\n     s2 = f s1; (aa, ba) |\\<in>| possible_steps e1 s1 r1 l_ b_;\n     evaluate_outputs ba b_ r1 = map Some c_;\n     (aa, ba) |\\<notin>| possible_steps e1 s1 r1 l_ b_\\<rbrakk>\n    \\<Longrightarrow> \\<exists>(s2', t2)\n                               |\\<in>|possible_steps e2 (f s1) r2 l_ b_.\n                         evaluate_outputs t2 b_ r2 = map Some c_ \\<and>\n                         trace_simulation f e1 aa\n                          (evaluate_updates ba b_ r1) e2 s2'\n                          (evaluate_updates t2 b_ r2) t", "by simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  trace_simulation f e1 s1 r1 e2 s2 r2 (a # t)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma execution_simulates_trace_simulates:\n  \"execution_simulates e1 e2 \\<Longrightarrow> trace_simulates e1 e2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. execution_simulates e1 e2 \\<Longrightarrow> trace_simulates e1 e2", "apply (simp add: execution_simulates_def trace_simulates_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>f.\n       \\<forall>t.\n          execution_simulation f e1 0 <> e2 0 <> t \\<Longrightarrow>\n    \\<exists>f. \\<forall>t. trace_simulation f e1 0 <> e2 0 <> t", "using execution_simulation_trace_simulation"], ["proof (prove)\nusing this:\n  execution_simulation ?f ?e1.0 ?s1.0 ?r1.0 ?e2.0 ?s2.0 ?r2.0\n   (map (\\<lambda>(l, i, o). (l, i)) ?t) \\<Longrightarrow>\n  trace_simulation ?f ?e1.0 ?s1.0 ?r1.0 ?e2.0 ?s2.0 ?r2.0 ?t\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       \\<forall>t.\n          execution_simulation f e1 0 <> e2 0 <> t \\<Longrightarrow>\n    \\<exists>f. \\<forall>t. trace_simulation f e1 0 <> e2 0 <> t", "by blast"], ["", "subsubsection\\<open>Executional Equivalence\\<close>"], ["", "text\\<open>Two EFSMs are executionally equivalent if there is no execution which can distinguish between\nthe two. That is, for every execution, they must produce equivalent outputs.\\<close>"], ["", "text_raw\\<open>\\snip{execEquiv}{1}{2}{%\\<close>"], ["", "inductive executionally_equivalent :: \"transition_matrix \\<Rightarrow> cfstate \\<Rightarrow> registers \\<Rightarrow>\ntransition_matrix \\<Rightarrow> cfstate \\<Rightarrow> registers \\<Rightarrow> execution \\<Rightarrow> bool\" where\n  base [simp]: \"executionally_equivalent e1 s1 r1 e2 s2 r2 []\" |\n  step: \"\\<forall>(s1', t1) |\\<in>| possible_steps e1 s1 r1 l i.\n           \\<exists>(s2', t2) |\\<in>| possible_steps e2 s2 r2 l i.\n             evaluate_outputs t1 i r1 = evaluate_outputs t2 i r2 \\<and>\n             executionally_equivalent e1 s1' (evaluate_updates t1 i r1) e2 s2' (evaluate_updates t2 i r2) es \\<Longrightarrow>\n         \\<forall>(s2', t2) |\\<in>| possible_steps e2 s2 r2 l i.\n           \\<exists>(s1', t1) |\\<in>| possible_steps e1 s1 r1 l i.\n             evaluate_outputs t1 i r1 = evaluate_outputs t2 i r2 \\<and>\n             executionally_equivalent e1 s1' (evaluate_updates t1 i r1) e2 s2' (evaluate_updates t2 i r2) es \\<Longrightarrow>\n         executionally_equivalent e1 s1 r1 e2 s2 r2 ((l, i)#es)\""], ["", "text_raw\\<open>}%endsnip\\<close>"], ["", "lemma executionally_equivalent_step:\n\"executionally_equivalent e1 s1 r1 e2 s2 r2 ((l, i)#es) = (\n  (\\<forall>(s1', t1) |\\<in>| (possible_steps e1 s1 r1 l i). (\\<exists>(s2', t2) |\\<in>| possible_steps e2 s2 r2 l i. evaluate_outputs t1 i r1 = evaluate_outputs t2 i r2 \\<and>\n   executionally_equivalent e1 s1' (evaluate_updates t1 i r1) e2 s2' (evaluate_updates t2 i r2) es)) \\<and>\n  (\\<forall>(s2', t2) |\\<in>| (possible_steps e2 s2 r2 l i). (\\<exists>(s1', t1) |\\<in>| possible_steps e1 s1 r1 l i. evaluate_outputs t1 i r1 = evaluate_outputs t2 i r2 \\<and>\n   executionally_equivalent e1 s1' (evaluate_updates t1 i r1) e2 s2' (evaluate_updates t2 i r2) es)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. executionally_equivalent e1 s1 r1 e2 s2 r2 ((l, i) # es) =\n    ((\\<forall>(s1', t1)|\\<in>|possible_steps e1 s1 r1 l i.\n         \\<exists>(s2', t2)|\\<in>|possible_steps e2 s2 r2 l i.\n            evaluate_outputs t1 i r1 = evaluate_outputs t2 i r2 \\<and>\n            executionally_equivalent e1 s1' (evaluate_updates t1 i r1) e2\n             s2' (evaluate_updates t2 i r2) es) \\<and>\n     (\\<forall>(s2', t2)|\\<in>|possible_steps e2 s2 r2 l i.\n         \\<exists>(s1', t1)|\\<in>|possible_steps e1 s1 r1 l i.\n            evaluate_outputs t1 i r1 = evaluate_outputs t2 i r2 \\<and>\n            executionally_equivalent e1 s1' (evaluate_updates t1 i r1) e2\n             s2' (evaluate_updates t2 i r2) es))", "apply standard"], ["proof (prove)\ngoal (2 subgoals):\n 1. executionally_equivalent e1 s1 r1 e2 s2 r2\n     ((l, i) # es) \\<Longrightarrow>\n    (\\<forall>(s1', t1)|\\<in>|possible_steps e1 s1 r1 l i.\n        \\<exists>(s2', t2)|\\<in>|possible_steps e2 s2 r2 l i.\n           evaluate_outputs t1 i r1 = evaluate_outputs t2 i r2 \\<and>\n           executionally_equivalent e1 s1' (evaluate_updates t1 i r1) e2 s2'\n            (evaluate_updates t2 i r2) es) \\<and>\n    (\\<forall>(s2', t2)|\\<in>|possible_steps e2 s2 r2 l i.\n        \\<exists>(s1', t1)|\\<in>|possible_steps e1 s1 r1 l i.\n           evaluate_outputs t1 i r1 = evaluate_outputs t2 i r2 \\<and>\n           executionally_equivalent e1 s1' (evaluate_updates t1 i r1) e2 s2'\n            (evaluate_updates t2 i r2) es)\n 2. (\\<forall>(s1', t1)|\\<in>|possible_steps e1 s1 r1 l i.\n        \\<exists>(s2', t2)|\\<in>|possible_steps e2 s2 r2 l i.\n           evaluate_outputs t1 i r1 = evaluate_outputs t2 i r2 \\<and>\n           executionally_equivalent e1 s1' (evaluate_updates t1 i r1) e2 s2'\n            (evaluate_updates t2 i r2) es) \\<and>\n    (\\<forall>(s2', t2)|\\<in>|possible_steps e2 s2 r2 l i.\n        \\<exists>(s1', t1)|\\<in>|possible_steps e1 s1 r1 l i.\n           evaluate_outputs t1 i r1 = evaluate_outputs t2 i r2 \\<and>\n           executionally_equivalent e1 s1' (evaluate_updates t1 i r1) e2 s2'\n            (evaluate_updates t2 i r2) es) \\<Longrightarrow>\n    executionally_equivalent e1 s1 r1 e2 s2 r2 ((l, i) # es)", "apply (rule executionally_equivalent.cases)"], ["proof (prove)\ngoal (4 subgoals):\n 1. executionally_equivalent e1 s1 r1 e2 s2 r2\n     ((l, i) # es) \\<Longrightarrow>\n    executionally_equivalent ?a1.3 ?a2.3 ?a3.3 ?a4.3 ?a5.3 ?a6.3 ?a7.3\n 2. \\<And>e1a s1a r1a e2a s2a r2a.\n       \\<lbrakk>executionally_equivalent e1 s1 r1 e2 s2 r2 ((l, i) # es);\n        ?a1.3 = e1a; ?a2.3 = s1a; ?a3.3 = r1a; ?a4.3 = e2a; ?a5.3 = s2a;\n        ?a6.3 = r2a; ?a7.3 = []\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>(s1', t1)\n                                   |\\<in>|possible_steps e1 s1 r1 l i.\n                             \\<exists>(s2', t2)\n|\\<in>|possible_steps e2 s2 r2 l i.\n                                evaluate_outputs t1 i r1 =\n                                evaluate_outputs t2 i r2 \\<and>\n                                executionally_equivalent e1 s1'\n                                 (evaluate_updates t1 i r1) e2 s2'\n                                 (evaluate_updates t2 i r2) es) \\<and>\n                         (\\<forall>(s2', t2)\n                                   |\\<in>|possible_steps e2 s2 r2 l i.\n                             \\<exists>(s1', t1)\n|\\<in>|possible_steps e1 s1 r1 l i.\n                                evaluate_outputs t1 i r1 =\n                                evaluate_outputs t2 i r2 \\<and>\n                                executionally_equivalent e1 s1'\n                                 (evaluate_updates t1 i r1) e2 s2'\n                                 (evaluate_updates t2 i r2) es)\n 3. \\<And>e1a s1a r1a la ia e2a s2a r2a esa.\n       \\<lbrakk>executionally_equivalent e1 s1 r1 e2 s2 r2 ((l, i) # es);\n        ?a1.3 = e1a; ?a2.3 = s1a; ?a3.3 = r1a; ?a4.3 = e2a; ?a5.3 = s2a;\n        ?a6.3 = r2a; ?a7.3 = (la, ia) # esa;\n        \\<forall>(s1', t1)|\\<in>|possible_steps e1a s1a r1a la ia.\n           \\<exists>(s2', t2)|\\<in>|possible_steps e2a s2a r2a la ia.\n              evaluate_outputs t1 ia r1a = evaluate_outputs t2 ia r2a \\<and>\n              executionally_equivalent e1a s1' (evaluate_updates t1 ia r1a)\n               e2a s2' (evaluate_updates t2 ia r2a) esa;\n        \\<forall>(s2', t2)|\\<in>|possible_steps e2a s2a r2a la ia.\n           \\<exists>(s1', t1)|\\<in>|possible_steps e1a s1a r1a la ia.\n              evaluate_outputs t1 ia r1a = evaluate_outputs t2 ia r2a \\<and>\n              executionally_equivalent e1a s1' (evaluate_updates t1 ia r1a)\n               e2a s2' (evaluate_updates t2 ia r2a) esa\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>(s1', t1)\n                                   |\\<in>|possible_steps e1 s1 r1 l i.\n                             \\<exists>(s2', t2)\n|\\<in>|possible_steps e2 s2 r2 l i.\n                                evaluate_outputs t1 i r1 =\n                                evaluate_outputs t2 i r2 \\<and>\n                                executionally_equivalent e1 s1'\n                                 (evaluate_updates t1 i r1) e2 s2'\n                                 (evaluate_updates t2 i r2) es) \\<and>\n                         (\\<forall>(s2', t2)\n                                   |\\<in>|possible_steps e2 s2 r2 l i.\n                             \\<exists>(s1', t1)\n|\\<in>|possible_steps e1 s1 r1 l i.\n                                evaluate_outputs t1 i r1 =\n                                evaluate_outputs t2 i r2 \\<and>\n                                executionally_equivalent e1 s1'\n                                 (evaluate_updates t1 i r1) e2 s2'\n                                 (evaluate_updates t2 i r2) es)\n 4. (\\<forall>(s1', t1)|\\<in>|possible_steps e1 s1 r1 l i.\n        \\<exists>(s2', t2)|\\<in>|possible_steps e2 s2 r2 l i.\n           evaluate_outputs t1 i r1 = evaluate_outputs t2 i r2 \\<and>\n           executionally_equivalent e1 s1' (evaluate_updates t1 i r1) e2 s2'\n            (evaluate_updates t2 i r2) es) \\<and>\n    (\\<forall>(s2', t2)|\\<in>|possible_steps e2 s2 r2 l i.\n        \\<exists>(s1', t1)|\\<in>|possible_steps e1 s1 r1 l i.\n           evaluate_outputs t1 i r1 = evaluate_outputs t2 i r2 \\<and>\n           executionally_equivalent e1 s1' (evaluate_updates t1 i r1) e2 s2'\n            (evaluate_updates t2 i r2) es) \\<Longrightarrow>\n    executionally_equivalent e1 s1 r1 e2 s2 r2 ((l, i) # es)", "apply simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>e1a s1a r1a e2a s2a r2a.\n       \\<lbrakk>executionally_equivalent e1 s1 r1 e2 s2 r2 ((l, i) # es);\n        e1 = e1a; s1 = s1a; r1 = r1a; e2 = e2a; s2 = s2a; r2 = r2a;\n        (l, i) # es = []\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>(s1', t1)\n                                   |\\<in>|possible_steps e1 s1 r1 l i.\n                             \\<exists>(s2', t2)\n|\\<in>|possible_steps e2 s2 r2 l i.\n                                evaluate_outputs t1 i r1 =\n                                evaluate_outputs t2 i r2 \\<and>\n                                executionally_equivalent e1 s1'\n                                 (evaluate_updates t1 i r1) e2 s2'\n                                 (evaluate_updates t2 i r2) es) \\<and>\n                         (\\<forall>(s2', t2)\n                                   |\\<in>|possible_steps e2 s2 r2 l i.\n                             \\<exists>(s1', t1)\n|\\<in>|possible_steps e1 s1 r1 l i.\n                                evaluate_outputs t1 i r1 =\n                                evaluate_outputs t2 i r2 \\<and>\n                                executionally_equivalent e1 s1'\n                                 (evaluate_updates t1 i r1) e2 s2'\n                                 (evaluate_updates t2 i r2) es)\n 2. \\<And>e1a s1a r1a la ia e2a s2a r2a esa.\n       \\<lbrakk>executionally_equivalent e1 s1 r1 e2 s2 r2 ((l, i) # es);\n        e1 = e1a; s1 = s1a; r1 = r1a; e2 = e2a; s2 = s2a; r2 = r2a;\n        (l, i) # es = (la, ia) # esa;\n        \\<forall>(s1', t1)|\\<in>|possible_steps e1a s1a r1a la ia.\n           \\<exists>(s2', t2)|\\<in>|possible_steps e2a s2a r2a la ia.\n              evaluate_outputs t1 ia r1a = evaluate_outputs t2 ia r2a \\<and>\n              executionally_equivalent e1a s1' (evaluate_updates t1 ia r1a)\n               e2a s2' (evaluate_updates t2 ia r2a) esa;\n        \\<forall>(s2', t2)|\\<in>|possible_steps e2a s2a r2a la ia.\n           \\<exists>(s1', t1)|\\<in>|possible_steps e1a s1a r1a la ia.\n              evaluate_outputs t1 ia r1a = evaluate_outputs t2 ia r2a \\<and>\n              executionally_equivalent e1a s1' (evaluate_updates t1 ia r1a)\n               e2a s2' (evaluate_updates t2 ia r2a) esa\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>(s1', t1)\n                                   |\\<in>|possible_steps e1 s1 r1 l i.\n                             \\<exists>(s2', t2)\n|\\<in>|possible_steps e2 s2 r2 l i.\n                                evaluate_outputs t1 i r1 =\n                                evaluate_outputs t2 i r2 \\<and>\n                                executionally_equivalent e1 s1'\n                                 (evaluate_updates t1 i r1) e2 s2'\n                                 (evaluate_updates t2 i r2) es) \\<and>\n                         (\\<forall>(s2', t2)\n                                   |\\<in>|possible_steps e2 s2 r2 l i.\n                             \\<exists>(s1', t1)\n|\\<in>|possible_steps e1 s1 r1 l i.\n                                evaluate_outputs t1 i r1 =\n                                evaluate_outputs t2 i r2 \\<and>\n                                executionally_equivalent e1 s1'\n                                 (evaluate_updates t1 i r1) e2 s2'\n                                 (evaluate_updates t2 i r2) es)\n 3. (\\<forall>(s1', t1)|\\<in>|possible_steps e1 s1 r1 l i.\n        \\<exists>(s2', t2)|\\<in>|possible_steps e2 s2 r2 l i.\n           evaluate_outputs t1 i r1 = evaluate_outputs t2 i r2 \\<and>\n           executionally_equivalent e1 s1' (evaluate_updates t1 i r1) e2 s2'\n            (evaluate_updates t2 i r2) es) \\<and>\n    (\\<forall>(s2', t2)|\\<in>|possible_steps e2 s2 r2 l i.\n        \\<exists>(s1', t1)|\\<in>|possible_steps e1 s1 r1 l i.\n           evaluate_outputs t1 i r1 = evaluate_outputs t2 i r2 \\<and>\n           executionally_equivalent e1 s1' (evaluate_updates t1 i r1) e2 s2'\n            (evaluate_updates t2 i r2) es) \\<Longrightarrow>\n    executionally_equivalent e1 s1 r1 e2 s2 r2 ((l, i) # es)", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>e1a s1a r1a la ia e2a s2a r2a esa.\n       \\<lbrakk>executionally_equivalent e1 s1 r1 e2 s2 r2 ((l, i) # es);\n        e1 = e1a; s1 = s1a; r1 = r1a; e2 = e2a; s2 = s2a; r2 = r2a;\n        (l, i) # es = (la, ia) # esa;\n        \\<forall>(s1', t1)|\\<in>|possible_steps e1a s1a r1a la ia.\n           \\<exists>(s2', t2)|\\<in>|possible_steps e2a s2a r2a la ia.\n              evaluate_outputs t1 ia r1a = evaluate_outputs t2 ia r2a \\<and>\n              executionally_equivalent e1a s1' (evaluate_updates t1 ia r1a)\n               e2a s2' (evaluate_updates t2 ia r2a) esa;\n        \\<forall>(s2', t2)|\\<in>|possible_steps e2a s2a r2a la ia.\n           \\<exists>(s1', t1)|\\<in>|possible_steps e1a s1a r1a la ia.\n              evaluate_outputs t1 ia r1a = evaluate_outputs t2 ia r2a \\<and>\n              executionally_equivalent e1a s1' (evaluate_updates t1 ia r1a)\n               e2a s2' (evaluate_updates t2 ia r2a) esa\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>(s1', t1)\n                                   |\\<in>|possible_steps e1 s1 r1 l i.\n                             \\<exists>(s2', t2)\n|\\<in>|possible_steps e2 s2 r2 l i.\n                                evaluate_outputs t1 i r1 =\n                                evaluate_outputs t2 i r2 \\<and>\n                                executionally_equivalent e1 s1'\n                                 (evaluate_updates t1 i r1) e2 s2'\n                                 (evaluate_updates t2 i r2) es) \\<and>\n                         (\\<forall>(s2', t2)\n                                   |\\<in>|possible_steps e2 s2 r2 l i.\n                             \\<exists>(s1', t1)\n|\\<in>|possible_steps e1 s1 r1 l i.\n                                evaluate_outputs t1 i r1 =\n                                evaluate_outputs t2 i r2 \\<and>\n                                executionally_equivalent e1 s1'\n                                 (evaluate_updates t1 i r1) e2 s2'\n                                 (evaluate_updates t2 i r2) es)\n 2. (\\<forall>(s1', t1)|\\<in>|possible_steps e1 s1 r1 l i.\n        \\<exists>(s2', t2)|\\<in>|possible_steps e2 s2 r2 l i.\n           evaluate_outputs t1 i r1 = evaluate_outputs t2 i r2 \\<and>\n           executionally_equivalent e1 s1' (evaluate_updates t1 i r1) e2 s2'\n            (evaluate_updates t2 i r2) es) \\<and>\n    (\\<forall>(s2', t2)|\\<in>|possible_steps e2 s2 r2 l i.\n        \\<exists>(s1', t1)|\\<in>|possible_steps e1 s1 r1 l i.\n           evaluate_outputs t1 i r1 = evaluate_outputs t2 i r2 \\<and>\n           executionally_equivalent e1 s1' (evaluate_updates t1 i r1) e2 s2'\n            (evaluate_updates t2 i r2) es) \\<Longrightarrow>\n    executionally_equivalent e1 s1 r1 e2 s2 r2 ((l, i) # es)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>(s1', t1)|\\<in>|possible_steps e1 s1 r1 l i.\n        \\<exists>(s2', t2)|\\<in>|possible_steps e2 s2 r2 l i.\n           evaluate_outputs t1 i r1 = evaluate_outputs t2 i r2 \\<and>\n           executionally_equivalent e1 s1' (evaluate_updates t1 i r1) e2 s2'\n            (evaluate_updates t2 i r2) es) \\<and>\n    (\\<forall>(s2', t2)|\\<in>|possible_steps e2 s2 r2 l i.\n        \\<exists>(s1', t1)|\\<in>|possible_steps e1 s1 r1 l i.\n           evaluate_outputs t1 i r1 = evaluate_outputs t2 i r2 \\<and>\n           executionally_equivalent e1 s1' (evaluate_updates t1 i r1) e2 s2'\n            (evaluate_updates t2 i r2) es) \\<Longrightarrow>\n    executionally_equivalent e1 s1 r1 e2 s2 r2 ((l, i) # es)", "by (rule executionally_equivalent.step, auto)"], ["", "lemma execution_end:\n  \"possible_steps e1 s1 r1 l i = {||} \\<Longrightarrow>\n   possible_steps e2 s2 r2 l i = {||} \\<Longrightarrow>\n  executionally_equivalent e1 s1 r1 e2 s2 r2 ((l, i)#es)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>possible_steps e1 s1 r1 l i = {||};\n     possible_steps e2 s2 r2 l i = {||}\\<rbrakk>\n    \\<Longrightarrow> executionally_equivalent e1 s1 r1 e2 s2 r2\n                       ((l, i) # es)", "by (simp add: executionally_equivalent_step)"], ["", "lemma possible_steps_disparity:\n  \"possible_steps e1 s1 r1 l i \\<noteq> {||} \\<Longrightarrow>\n   possible_steps e2 s2 r2 l i = {||} \\<Longrightarrow>\n   \\<not>executionally_equivalent e1 s1 r1 e2 s2 r2 ((l, i)#es)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>possible_steps e1 s1 r1 l i \\<noteq> {||};\n     possible_steps e2 s2 r2 l i = {||}\\<rbrakk>\n    \\<Longrightarrow> \\<not> executionally_equivalent e1 s1 r1 e2 s2 r2\n                              ((l, i) # es)", "by (simp add: executionally_equivalent_step, auto)"], ["", "lemma executionally_equivalent_acceptance_map:\n  \"executionally_equivalent e1 s1 r1 e2 s2 r2 (map (\\<lambda>(l, i, o). (l, i)) t) \\<Longrightarrow>\n   accepts_trace e2 s2 r2 t = accepts_trace e1 s1 r1 t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. executionally_equivalent e1 s1 r1 e2 s2 r2\n     (map (\\<lambda>(l, i, o). (l, i)) t) \\<Longrightarrow>\n    accepts_trace e2 s2 r2 t = accepts_trace e1 s1 r1 t", "proof(induct t arbitrary: s1 s2 r1 r2)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s1 s2 r1 r2.\n       executionally_equivalent e1 s1 r1 e2 s2 r2\n        (map (\\<lambda>(l, i, o). (l, i)) []) \\<Longrightarrow>\n       accepts_trace e2 s2 r2 [] = accepts_trace e1 s1 r1 []\n 2. \\<And>a t s1 s2 r1 r2.\n       \\<lbrakk>\\<And>s1 s2 r1 r2.\n                   executionally_equivalent e1 s1 r1 e2 s2 r2\n                    (map (\\<lambda>(l, i, o). (l, i)) t) \\<Longrightarrow>\n                   accepts_trace e2 s2 r2 t = accepts_trace e1 s1 r1 t;\n        executionally_equivalent e1 s1 r1 e2 s2 r2\n         (map (\\<lambda>(l, i, o). (l, i)) (a # t))\\<rbrakk>\n       \\<Longrightarrow> accepts_trace e2 s2 r2 (a # t) =\n                         accepts_trace e1 s1 r1 (a # t)", "case (Cons a t)"], ["proof (state)\nthis:\n  executionally_equivalent e1 ?s1.0 ?r1.0 e2 ?s2.0 ?r2.0\n   (map (\\<lambda>a. case a of (l, i, o) \\<Rightarrow> (l, i))\n     t) \\<Longrightarrow>\n  accepts_trace e2 ?s2.0 ?r2.0 t = accepts_trace e1 ?s1.0 ?r1.0 t\n  executionally_equivalent e1 s1 r1 e2 s2 r2\n   (map (\\<lambda>a. case a of (l, i, o) \\<Rightarrow> (l, i)) (a # t))\n\ngoal (2 subgoals):\n 1. \\<And>s1 s2 r1 r2.\n       executionally_equivalent e1 s1 r1 e2 s2 r2\n        (map (\\<lambda>(l, i, o). (l, i)) []) \\<Longrightarrow>\n       accepts_trace e2 s2 r2 [] = accepts_trace e1 s1 r1 []\n 2. \\<And>a t s1 s2 r1 r2.\n       \\<lbrakk>\\<And>s1 s2 r1 r2.\n                   executionally_equivalent e1 s1 r1 e2 s2 r2\n                    (map (\\<lambda>(l, i, o). (l, i)) t) \\<Longrightarrow>\n                   accepts_trace e2 s2 r2 t = accepts_trace e1 s1 r1 t;\n        executionally_equivalent e1 s1 r1 e2 s2 r2\n         (map (\\<lambda>(l, i, o). (l, i)) (a # t))\\<rbrakk>\n       \\<Longrightarrow> accepts_trace e2 s2 r2 (a # t) =\n                         accepts_trace e1 s1 r1 (a # t)", "then"], ["proof (chain)\npicking this:\n  executionally_equivalent e1 ?s1.0 ?r1.0 e2 ?s2.0 ?r2.0\n   (map (\\<lambda>a. case a of (l, i, o) \\<Rightarrow> (l, i))\n     t) \\<Longrightarrow>\n  accepts_trace e2 ?s2.0 ?r2.0 t = accepts_trace e1 ?s1.0 ?r1.0 t\n  executionally_equivalent e1 s1 r1 e2 s2 r2\n   (map (\\<lambda>a. case a of (l, i, o) \\<Rightarrow> (l, i)) (a # t))", "show ?case"], ["proof (prove)\nusing this:\n  executionally_equivalent e1 ?s1.0 ?r1.0 e2 ?s2.0 ?r2.0\n   (map (\\<lambda>a. case a of (l, i, o) \\<Rightarrow> (l, i))\n     t) \\<Longrightarrow>\n  accepts_trace e2 ?s2.0 ?r2.0 t = accepts_trace e1 ?s1.0 ?r1.0 t\n  executionally_equivalent e1 s1 r1 e2 s2 r2\n   (map (\\<lambda>a. case a of (l, i, o) \\<Rightarrow> (l, i)) (a # t))\n\ngoal (1 subgoal):\n 1. accepts_trace e2 s2 r2 (a # t) = accepts_trace e1 s1 r1 (a # t)", "apply (cases a, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b c.\n       \\<lbrakk>executionally_equivalent e1 s1 r1 e2 s2 r2\n                 ((aa, b) # map (\\<lambda>(l, i, o). (l, i)) t);\n        a = (aa, b, c);\n        \\<And>s1 r1 s2 r2.\n           executionally_equivalent e1 s1 r1 e2 s2 r2\n            (map (\\<lambda>(l, i, o). (l, i)) t) \\<Longrightarrow>\n           accepts_trace e2 s2 r2 t = accepts_trace e1 s1 r1 t\\<rbrakk>\n       \\<Longrightarrow> accepts_trace e2 s2 r2 ((aa, b, c) # t) =\n                         accepts_trace e1 s1 r1 ((aa, b, c) # t)", "apply (rule executionally_equivalent.cases)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>aa b c.\n       \\<lbrakk>executionally_equivalent e1 s1 r1 e2 s2 r2\n                 ((aa, b) # map (\\<lambda>(l, i, o). (l, i)) t);\n        a = (aa, b, c);\n        \\<And>s1 r1 s2 r2.\n           executionally_equivalent e1 s1 r1 e2 s2 r2\n            (map (\\<lambda>(l, i, o). (l, i)) t) \\<Longrightarrow>\n           accepts_trace e2 s2 r2 t = accepts_trace e1 s1 r1 t\\<rbrakk>\n       \\<Longrightarrow> executionally_equivalent (?a1.7 aa b c)\n                          (?a2.7 aa b c) (?a3.7 aa b c) (?a4.7 aa b c)\n                          (?a5.7 aa b c) (?a6.7 aa b c) (?a7.7 aa b c)\n 2. \\<And>aa b c e1a s1 r1 e2a s2 r2.\n       \\<lbrakk>executionally_equivalent e1 s1 r1 e2 s2 r2\n                 ((aa, b) # map (\\<lambda>(l, i, o). (l, i)) t);\n        a = (aa, b, c);\n        \\<And>s1 r1 s2 r2.\n           executionally_equivalent e1 s1 r1 e2 s2 r2\n            (map (\\<lambda>(l, i, o). (l, i)) t) \\<Longrightarrow>\n           accepts_trace e2 s2 r2 t = accepts_trace e1 s1 r1 t;\n        ?a1.7 aa b c = e1a; ?a2.7 aa b c = s1; ?a3.7 aa b c = r1;\n        ?a4.7 aa b c = e2a; ?a5.7 aa b c = s2; ?a6.7 aa b c = r2;\n        ?a7.7 aa b c = []\\<rbrakk>\n       \\<Longrightarrow> accepts_trace e2 s2 r2 ((aa, b, c) # t) =\n                         accepts_trace e1 s1 r1 ((aa, b, c) # t)\n 3. \\<And>aa b c e1a s1 r1 l i e2a s2 r2 es.\n       \\<lbrakk>executionally_equivalent e1 s1 r1 e2 s2 r2\n                 ((aa, b) # map (\\<lambda>(l, i, o). (l, i)) t);\n        a = (aa, b, c);\n        \\<And>s1 r1 s2 r2.\n           executionally_equivalent e1 s1 r1 e2 s2 r2\n            (map (\\<lambda>(l, i, o). (l, i)) t) \\<Longrightarrow>\n           accepts_trace e2 s2 r2 t = accepts_trace e1 s1 r1 t;\n        ?a1.7 aa b c = e1a; ?a2.7 aa b c = s1; ?a3.7 aa b c = r1;\n        ?a4.7 aa b c = e2a; ?a5.7 aa b c = s2; ?a6.7 aa b c = r2;\n        ?a7.7 aa b c = (l, i) # es;\n        \\<forall>(s1', t1)|\\<in>|possible_steps e1a s1 r1 l i.\n           \\<exists>(s2', t2)|\\<in>|possible_steps e2a s2 r2 l i.\n              evaluate_outputs t1 i r1 = evaluate_outputs t2 i r2 \\<and>\n              executionally_equivalent e1a s1' (evaluate_updates t1 i r1)\n               e2a s2' (evaluate_updates t2 i r2) es;\n        \\<forall>(s2', t2)|\\<in>|possible_steps e2a s2 r2 l i.\n           \\<exists>(s1', t1)|\\<in>|possible_steps e1a s1 r1 l i.\n              evaluate_outputs t1 i r1 = evaluate_outputs t2 i r2 \\<and>\n              executionally_equivalent e1a s1' (evaluate_updates t1 i r1)\n               e2a s2' (evaluate_updates t2 i r2) es\\<rbrakk>\n       \\<Longrightarrow> accepts_trace e2 s2 r2 ((aa, b, c) # t) =\n                         accepts_trace e1 s1 r1 ((aa, b, c) # t)", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa b c e1a s1 r1 e2a s2 r2.\n       \\<lbrakk>executionally_equivalent e1 s1 r1 e2 s2 r2\n                 ((aa, b) # map (\\<lambda>(l, i, o). (l, i)) t);\n        a = (aa, b, c);\n        \\<And>s1 r1 s2 r2.\n           executionally_equivalent e1 s1 r1 e2 s2 r2\n            (map (\\<lambda>(l, i, o). (l, i)) t) \\<Longrightarrow>\n           accepts_trace e2 s2 r2 t = accepts_trace e1 s1 r1 t;\n        e1 = e1a; s1 = s1; r1 = r1; e2 = e2a; s2 = s2; r2 = r2;\n        (aa, b) # map (\\<lambda>(l, i, o). (l, i)) t = []\\<rbrakk>\n       \\<Longrightarrow> accepts_trace e2 s2 r2 ((aa, b, c) # t) =\n                         accepts_trace e1 s1 r1 ((aa, b, c) # t)\n 2. \\<And>aa b c e1a s1 r1 l i e2a s2 r2 es.\n       \\<lbrakk>executionally_equivalent e1 s1 r1 e2 s2 r2\n                 ((aa, b) # map (\\<lambda>(l, i, o). (l, i)) t);\n        a = (aa, b, c);\n        \\<And>s1 r1 s2 r2.\n           executionally_equivalent e1 s1 r1 e2 s2 r2\n            (map (\\<lambda>(l, i, o). (l, i)) t) \\<Longrightarrow>\n           accepts_trace e2 s2 r2 t = accepts_trace e1 s1 r1 t;\n        e1 = e1a; s1 = s1; r1 = r1; e2 = e2a; s2 = s2; r2 = r2;\n        (aa, b) # map (\\<lambda>(l, i, o). (l, i)) t = (l, i) # es;\n        \\<forall>(s1', t1)|\\<in>|possible_steps e1a s1 r1 l i.\n           \\<exists>(s2', t2)|\\<in>|possible_steps e2a s2 r2 l i.\n              evaluate_outputs t1 i r1 = evaluate_outputs t2 i r2 \\<and>\n              executionally_equivalent e1a s1' (evaluate_updates t1 i r1)\n               e2a s2' (evaluate_updates t2 i r2) es;\n        \\<forall>(s2', t2)|\\<in>|possible_steps e2a s2 r2 l i.\n           \\<exists>(s1', t1)|\\<in>|possible_steps e1a s1 r1 l i.\n              evaluate_outputs t1 i r1 = evaluate_outputs t2 i r2 \\<and>\n              executionally_equivalent e1a s1' (evaluate_updates t1 i r1)\n               e2a s2' (evaluate_updates t2 i r2) es\\<rbrakk>\n       \\<Longrightarrow> accepts_trace e2 s2 r2 ((aa, b, c) # t) =\n                         accepts_trace e1 s1 r1 ((aa, b, c) # t)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b c e1a s1 r1 l i e2a s2 r2 es.\n       \\<lbrakk>executionally_equivalent e1 s1 r1 e2 s2 r2\n                 ((aa, b) # map (\\<lambda>(l, i, o). (l, i)) t);\n        a = (aa, b, c);\n        \\<And>s1 r1 s2 r2.\n           executionally_equivalent e1 s1 r1 e2 s2 r2\n            (map (\\<lambda>(l, i, o). (l, i)) t) \\<Longrightarrow>\n           accepts_trace e2 s2 r2 t = accepts_trace e1 s1 r1 t;\n        e1 = e1a; s1 = s1; r1 = r1; e2 = e2a; s2 = s2; r2 = r2;\n        (aa, b) # map (\\<lambda>(l, i, o). (l, i)) t = (l, i) # es;\n        \\<forall>(s1', t1)|\\<in>|possible_steps e1a s1 r1 l i.\n           \\<exists>(s2', t2)|\\<in>|possible_steps e2a s2 r2 l i.\n              evaluate_outputs t1 i r1 = evaluate_outputs t2 i r2 \\<and>\n              executionally_equivalent e1a s1' (evaluate_updates t1 i r1)\n               e2a s2' (evaluate_updates t2 i r2) es;\n        \\<forall>(s2', t2)|\\<in>|possible_steps e2a s2 r2 l i.\n           \\<exists>(s1', t1)|\\<in>|possible_steps e1a s1 r1 l i.\n              evaluate_outputs t1 i r1 = evaluate_outputs t2 i r2 \\<and>\n              executionally_equivalent e1a s1' (evaluate_updates t1 i r1)\n               e2a s2' (evaluate_updates t2 i r2) es\\<rbrakk>\n       \\<Longrightarrow> accepts_trace e2 s2 r2 ((aa, b, c) # t) =\n                         accepts_trace e1 s1 r1 ((aa, b, c) # t)", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b c l.\n       \\<lbrakk>executionally_equivalent e1 s1 r1 e2 s2 r2\n                 ((l, b) # map (\\<lambda>(l, i, o). (l, i)) t);\n        a = (l, b, c);\n        \\<And>s1 r1 s2 r2.\n           executionally_equivalent e1 s1 r1 e2 s2 r2\n            (map (\\<lambda>(l, i, o). (l, i)) t) \\<Longrightarrow>\n           accepts_trace e2 s2 r2 t = accepts_trace e1 s1 r1 t;\n        \\<forall>(s1', t1)|\\<in>|possible_steps e1 s1 r1 l b.\n           \\<exists>(s2', t2)|\\<in>|possible_steps e2 s2 r2 l b.\n              evaluate_outputs t1 b r1 = evaluate_outputs t2 b r2 \\<and>\n              executionally_equivalent e1 s1' (evaluate_updates t1 b r1) e2\n               s2' (evaluate_updates t2 b r2)\n               (map (\\<lambda>(l, i, o). (l, i)) t);\n        \\<forall>(s2', t2)|\\<in>|possible_steps e2 s2 r2 l b.\n           \\<exists>(s1', t1)|\\<in>|possible_steps e1 s1 r1 l b.\n              evaluate_outputs t1 b r1 = evaluate_outputs t2 b r2 \\<and>\n              executionally_equivalent e1 s1' (evaluate_updates t1 b r1) e2\n               s2' (evaluate_updates t2 b r2)\n               (map (\\<lambda>(l, i, o). (l, i)) t)\\<rbrakk>\n       \\<Longrightarrow> accepts_trace e2 s2 r2 ((l, b, c) # t) =\n                         accepts_trace e1 s1 r1 ((l, b, c) # t)", "apply standard"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>b c l.\n       \\<lbrakk>executionally_equivalent e1 s1 r1 e2 s2 r2\n                 ((l, b) # map (\\<lambda>(l, i, o). (l, i)) t);\n        a = (l, b, c);\n        \\<And>s1 r1 s2 r2.\n           executionally_equivalent e1 s1 r1 e2 s2 r2\n            (map (\\<lambda>(l, i, o). (l, i)) t) \\<Longrightarrow>\n           accepts_trace e2 s2 r2 t = accepts_trace e1 s1 r1 t;\n        \\<forall>(s1', t1)|\\<in>|possible_steps e1 s1 r1 l b.\n           \\<exists>(s2', t2)|\\<in>|possible_steps e2 s2 r2 l b.\n              evaluate_outputs t1 b r1 = evaluate_outputs t2 b r2 \\<and>\n              executionally_equivalent e1 s1' (evaluate_updates t1 b r1) e2\n               s2' (evaluate_updates t2 b r2)\n               (map (\\<lambda>(l, i, o). (l, i)) t);\n        \\<forall>(s2', t2)|\\<in>|possible_steps e2 s2 r2 l b.\n           \\<exists>(s1', t1)|\\<in>|possible_steps e1 s1 r1 l b.\n              evaluate_outputs t1 b r1 = evaluate_outputs t2 b r2 \\<and>\n              executionally_equivalent e1 s1' (evaluate_updates t1 b r1) e2\n               s2' (evaluate_updates t2 b r2)\n               (map (\\<lambda>(l, i, o). (l, i)) t);\n        accepts_trace e2 s2 r2 ((l, b, c) # t)\\<rbrakk>\n       \\<Longrightarrow> accepts_trace e1 s1 r1 ((l, b, c) # t)\n 2. \\<And>b c l.\n       \\<lbrakk>executionally_equivalent e1 s1 r1 e2 s2 r2\n                 ((l, b) # map (\\<lambda>(l, i, o). (l, i)) t);\n        a = (l, b, c);\n        \\<And>s1 r1 s2 r2.\n           executionally_equivalent e1 s1 r1 e2 s2 r2\n            (map (\\<lambda>(l, i, o). (l, i)) t) \\<Longrightarrow>\n           accepts_trace e2 s2 r2 t = accepts_trace e1 s1 r1 t;\n        \\<forall>(s1', t1)|\\<in>|possible_steps e1 s1 r1 l b.\n           \\<exists>(s2', t2)|\\<in>|possible_steps e2 s2 r2 l b.\n              evaluate_outputs t1 b r1 = evaluate_outputs t2 b r2 \\<and>\n              executionally_equivalent e1 s1' (evaluate_updates t1 b r1) e2\n               s2' (evaluate_updates t2 b r2)\n               (map (\\<lambda>(l, i, o). (l, i)) t);\n        \\<forall>(s2', t2)|\\<in>|possible_steps e2 s2 r2 l b.\n           \\<exists>(s1', t1)|\\<in>|possible_steps e1 s1 r1 l b.\n              evaluate_outputs t1 b r1 = evaluate_outputs t2 b r2 \\<and>\n              executionally_equivalent e1 s1' (evaluate_updates t1 b r1) e2\n               s2' (evaluate_updates t2 b r2)\n               (map (\\<lambda>(l, i, o). (l, i)) t);\n        accepts_trace e1 s1 r1 ((l, b, c) # t)\\<rbrakk>\n       \\<Longrightarrow> accepts_trace e2 s2 r2 ((l, b, c) # t)", "subgoal for i p l"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>executionally_equivalent e1 s1 r1 e2 s2 r2\n              ((l, i) # map (\\<lambda>(l, i, o). (l, i)) t);\n     a = (l, i, p);\n     \\<And>s1 r1 s2 r2.\n        executionally_equivalent e1 s1 r1 e2 s2 r2\n         (map (\\<lambda>(l, i, o). (l, i)) t) \\<Longrightarrow>\n        accepts_trace e2 s2 r2 t = accepts_trace e1 s1 r1 t;\n     \\<forall>(s1', t1)|\\<in>|possible_steps e1 s1 r1 l i.\n        \\<exists>(s2', t2)|\\<in>|possible_steps e2 s2 r2 l i.\n           evaluate_outputs t1 i r1 = evaluate_outputs t2 i r2 \\<and>\n           executionally_equivalent e1 s1' (evaluate_updates t1 i r1) e2 s2'\n            (evaluate_updates t2 i r2) (map (\\<lambda>(l, i, o). (l, i)) t);\n     \\<forall>(s2', t2)|\\<in>|possible_steps e2 s2 r2 l i.\n        \\<exists>(s1', t1)|\\<in>|possible_steps e1 s1 r1 l i.\n           evaluate_outputs t1 i r1 = evaluate_outputs t2 i r2 \\<and>\n           executionally_equivalent e1 s1' (evaluate_updates t1 i r1) e2 s2'\n            (evaluate_updates t2 i r2) (map (\\<lambda>(l, i, o). (l, i)) t);\n     accepts_trace e2 s2 r2 ((l, i, p) # t)\\<rbrakk>\n    \\<Longrightarrow> accepts_trace e1 s1 r1 ((l, i, p) # t)", "apply (rule accepts_trace.cases)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>executionally_equivalent e1 s1 r1 e2 s2 r2\n              ((l, i) # map (\\<lambda>(l, i, o). (l, i)) t);\n     a = (l, i, p);\n     \\<And>s1 r1 s2 r2.\n        executionally_equivalent e1 s1 r1 e2 s2 r2\n         (map (\\<lambda>(l, i, o). (l, i)) t) \\<Longrightarrow>\n        accepts_trace e2 s2 r2 t = accepts_trace e1 s1 r1 t;\n     \\<forall>(s1', t1)|\\<in>|possible_steps e1 s1 r1 l i.\n        \\<exists>(s2', t2)|\\<in>|possible_steps e2 s2 r2 l i.\n           evaluate_outputs t1 i r1 = evaluate_outputs t2 i r2 \\<and>\n           executionally_equivalent e1 s1' (evaluate_updates t1 i r1) e2 s2'\n            (evaluate_updates t2 i r2) (map (\\<lambda>(l, i, o). (l, i)) t);\n     \\<forall>(s2', t2)|\\<in>|possible_steps e2 s2 r2 l i.\n        \\<exists>(s1', t1)|\\<in>|possible_steps e1 s1 r1 l i.\n           evaluate_outputs t1 i r1 = evaluate_outputs t2 i r2 \\<and>\n           executionally_equivalent e1 s1' (evaluate_updates t1 i r1) e2 s2'\n            (evaluate_updates t2 i r2) (map (\\<lambda>(l, i, o). (l, i)) t);\n     accepts_trace e2 s2 r2 ((l, i, p) # t)\\<rbrakk>\n    \\<Longrightarrow> accepts_trace ?a1.0 ?a2.0 ?a3.0 ?a4.0\n 2. \\<And>e s r.\n       \\<lbrakk>executionally_equivalent e1 s1 r1 e2 s2 r2\n                 ((l, i) # map (\\<lambda>(l, i, o). (l, i)) t);\n        a = (l, i, p);\n        \\<And>s1 r1 s2 r2.\n           executionally_equivalent e1 s1 r1 e2 s2 r2\n            (map (\\<lambda>(l, i, o). (l, i)) t) \\<Longrightarrow>\n           accepts_trace e2 s2 r2 t = accepts_trace e1 s1 r1 t;\n        \\<forall>(s1', t1)|\\<in>|possible_steps e1 s1 r1 l i.\n           \\<exists>(s2', t2)|\\<in>|possible_steps e2 s2 r2 l i.\n              evaluate_outputs t1 i r1 = evaluate_outputs t2 i r2 \\<and>\n              executionally_equivalent e1 s1' (evaluate_updates t1 i r1) e2\n               s2' (evaluate_updates t2 i r2)\n               (map (\\<lambda>(l, i, o). (l, i)) t);\n        \\<forall>(s2', t2)|\\<in>|possible_steps e2 s2 r2 l i.\n           \\<exists>(s1', t1)|\\<in>|possible_steps e1 s1 r1 l i.\n              evaluate_outputs t1 i r1 = evaluate_outputs t2 i r2 \\<and>\n              executionally_equivalent e1 s1' (evaluate_updates t1 i r1) e2\n               s2' (evaluate_updates t2 i r2)\n               (map (\\<lambda>(l, i, o). (l, i)) t);\n        accepts_trace e2 s2 r2 ((l, i, p) # t); ?a1.0 = e; ?a2.0 = s;\n        ?a3.0 = r; ?a4.0 = []\\<rbrakk>\n       \\<Longrightarrow> accepts_trace e1 s1 r1 ((l, i, p) # t)\n 3. \\<And>e s r la ia pa t.\n       \\<lbrakk>executionally_equivalent e1 s1 r1 e2 s2 r2\n                 ((l, i) # map (\\<lambda>(l, i, o). (l, i)) t);\n        a = (l, i, p);\n        \\<And>s1 r1 s2 r2.\n           executionally_equivalent e1 s1 r1 e2 s2 r2\n            (map (\\<lambda>(l, i, o). (l, i)) t) \\<Longrightarrow>\n           accepts_trace e2 s2 r2 t = accepts_trace e1 s1 r1 t;\n        \\<forall>(s1', t1)|\\<in>|possible_steps e1 s1 r1 l i.\n           \\<exists>(s2', t2)|\\<in>|possible_steps e2 s2 r2 l i.\n              evaluate_outputs t1 i r1 = evaluate_outputs t2 i r2 \\<and>\n              executionally_equivalent e1 s1' (evaluate_updates t1 i r1) e2\n               s2' (evaluate_updates t2 i r2)\n               (map (\\<lambda>(l, i, o). (l, i)) t);\n        \\<forall>(s2', t2)|\\<in>|possible_steps e2 s2 r2 l i.\n           \\<exists>(s1', t1)|\\<in>|possible_steps e1 s1 r1 l i.\n              evaluate_outputs t1 i r1 = evaluate_outputs t2 i r2 \\<and>\n              executionally_equivalent e1 s1' (evaluate_updates t1 i r1) e2\n               s2' (evaluate_updates t2 i r2)\n               (map (\\<lambda>(l, i, o). (l, i)) t);\n        accepts_trace e2 s2 r2 ((l, i, p) # t); ?a1.0 = e; ?a2.0 = s;\n        ?a3.0 = r; ?a4.0 = (la, ia, pa) # t;\n        \\<exists>(s', T)|\\<in>|possible_steps e s r la ia.\n           evaluate_outputs T ia r = map Some pa \\<and>\n           accepts_trace e s' (evaluate_updates T ia r) t\\<rbrakk>\n       \\<Longrightarrow> accepts_trace e1 s1 r1 ((l, i, p) # t)", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>e s r.\n       \\<lbrakk>executionally_equivalent e1 s1 r1 e2 s2 r2\n                 ((l, i) # map (\\<lambda>(l, i, o). (l, i)) t);\n        a = (l, i, p);\n        \\<And>s1 r1 s2 r2.\n           executionally_equivalent e1 s1 r1 e2 s2 r2\n            (map (\\<lambda>(l, i, o). (l, i)) t) \\<Longrightarrow>\n           accepts_trace e2 s2 r2 t = accepts_trace e1 s1 r1 t;\n        \\<forall>(s1', t1)|\\<in>|possible_steps e1 s1 r1 l i.\n           \\<exists>(s2', t2)|\\<in>|possible_steps e2 s2 r2 l i.\n              evaluate_outputs t1 i r1 = evaluate_outputs t2 i r2 \\<and>\n              executionally_equivalent e1 s1' (evaluate_updates t1 i r1) e2\n               s2' (evaluate_updates t2 i r2)\n               (map (\\<lambda>(l, i, o). (l, i)) t);\n        \\<forall>(s2', t2)|\\<in>|possible_steps e2 s2 r2 l i.\n           \\<exists>(s1', t1)|\\<in>|possible_steps e1 s1 r1 l i.\n              evaluate_outputs t1 i r1 = evaluate_outputs t2 i r2 \\<and>\n              executionally_equivalent e1 s1' (evaluate_updates t1 i r1) e2\n               s2' (evaluate_updates t2 i r2)\n               (map (\\<lambda>(l, i, o). (l, i)) t);\n        accepts_trace e2 s2 r2 ((l, i, p) # t); e2 = e; s2 = s; r2 = r;\n        (l, i, p) # t = []\\<rbrakk>\n       \\<Longrightarrow> accepts_trace e1 s1 r1 ((l, i, p) # t)\n 2. \\<And>e s r la ia pa t.\n       \\<lbrakk>executionally_equivalent e1 s1 r1 e2 s2 r2\n                 ((l, i) # map (\\<lambda>(l, i, o). (l, i)) t);\n        a = (l, i, p);\n        \\<And>s1 r1 s2 r2.\n           executionally_equivalent e1 s1 r1 e2 s2 r2\n            (map (\\<lambda>(l, i, o). (l, i)) t) \\<Longrightarrow>\n           accepts_trace e2 s2 r2 t = accepts_trace e1 s1 r1 t;\n        \\<forall>(s1', t1)|\\<in>|possible_steps e1 s1 r1 l i.\n           \\<exists>(s2', t2)|\\<in>|possible_steps e2 s2 r2 l i.\n              evaluate_outputs t1 i r1 = evaluate_outputs t2 i r2 \\<and>\n              executionally_equivalent e1 s1' (evaluate_updates t1 i r1) e2\n               s2' (evaluate_updates t2 i r2)\n               (map (\\<lambda>(l, i, o). (l, i)) t);\n        \\<forall>(s2', t2)|\\<in>|possible_steps e2 s2 r2 l i.\n           \\<exists>(s1', t1)|\\<in>|possible_steps e1 s1 r1 l i.\n              evaluate_outputs t1 i r1 = evaluate_outputs t2 i r2 \\<and>\n              executionally_equivalent e1 s1' (evaluate_updates t1 i r1) e2\n               s2' (evaluate_updates t2 i r2)\n               (map (\\<lambda>(l, i, o). (l, i)) t);\n        accepts_trace e2 s2 r2 ((l, i, p) # t); e2 = e; s2 = s; r2 = r;\n        (l, i, p) # t = (la, ia, pa) # t;\n        \\<exists>(s', T)|\\<in>|possible_steps e s r la ia.\n           evaluate_outputs T ia r = map Some pa \\<and>\n           accepts_trace e s' (evaluate_updates T ia r) t\\<rbrakk>\n       \\<Longrightarrow> accepts_trace e1 s1 r1 ((l, i, p) # t)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>e s r la ia pa t.\n       \\<lbrakk>executionally_equivalent e1 s1 r1 e2 s2 r2\n                 ((l, i) # map (\\<lambda>(l, i, o). (l, i)) t);\n        a = (l, i, p);\n        \\<And>s1 r1 s2 r2.\n           executionally_equivalent e1 s1 r1 e2 s2 r2\n            (map (\\<lambda>(l, i, o). (l, i)) t) \\<Longrightarrow>\n           accepts_trace e2 s2 r2 t = accepts_trace e1 s1 r1 t;\n        \\<forall>(s1', t1)|\\<in>|possible_steps e1 s1 r1 l i.\n           \\<exists>(s2', t2)|\\<in>|possible_steps e2 s2 r2 l i.\n              evaluate_outputs t1 i r1 = evaluate_outputs t2 i r2 \\<and>\n              executionally_equivalent e1 s1' (evaluate_updates t1 i r1) e2\n               s2' (evaluate_updates t2 i r2)\n               (map (\\<lambda>(l, i, o). (l, i)) t);\n        \\<forall>(s2', t2)|\\<in>|possible_steps e2 s2 r2 l i.\n           \\<exists>(s1', t1)|\\<in>|possible_steps e1 s1 r1 l i.\n              evaluate_outputs t1 i r1 = evaluate_outputs t2 i r2 \\<and>\n              executionally_equivalent e1 s1' (evaluate_updates t1 i r1) e2\n               s2' (evaluate_updates t2 i r2)\n               (map (\\<lambda>(l, i, o). (l, i)) t);\n        accepts_trace e2 s2 r2 ((l, i, p) # t); e2 = e; s2 = s; r2 = r;\n        (l, i, p) # t = (la, ia, pa) # t;\n        \\<exists>(s', T)|\\<in>|possible_steps e s r la ia.\n           evaluate_outputs T ia r = map Some pa \\<and>\n           accepts_trace e s' (evaluate_updates T ia r) t\\<rbrakk>\n       \\<Longrightarrow> accepts_trace e1 s1 r1 ((l, i, p) # t)", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b.\n       \\<lbrakk>executionally_equivalent e1 s1 r1 e2 s2 r2\n                 ((l, i) # map (\\<lambda>(l, i, o). (l, i)) t);\n        a = (l, i, p);\n        \\<And>s1 r1 s2 r2.\n           executionally_equivalent e1 s1 r1 e2 s2 r2\n            (map (\\<lambda>(l, i, o). (l, i)) t) \\<Longrightarrow>\n           accepts_trace e2 s2 r2 t = accepts_trace e1 s1 r1 t;\n        \\<forall>(s1', t1)|\\<in>|possible_steps e1 s1 r1 l i.\n           \\<exists>(s2', t2)|\\<in>|possible_steps e2 s2 r2 l i.\n              evaluate_outputs t1 i r1 = evaluate_outputs t2 i r2 \\<and>\n              executionally_equivalent e1 s1' (evaluate_updates t1 i r1) e2\n               s2' (evaluate_updates t2 i r2)\n               (map (\\<lambda>(l, i, o). (l, i)) t);\n        \\<forall>(s2', t2)|\\<in>|possible_steps e2 s2 r2 l i.\n           \\<exists>(s1', t1)|\\<in>|possible_steps e1 s1 r1 l i.\n              evaluate_outputs t1 i r1 = evaluate_outputs t2 i r2 \\<and>\n              executionally_equivalent e1 s1' (evaluate_updates t1 i r1) e2\n               s2' (evaluate_updates t2 i r2)\n               (map (\\<lambda>(l, i, o). (l, i)) t);\n        accepts_trace e2 s2 r2 ((l, i, p) # t);\n        (aa, b) |\\<in>| possible_steps e2 s2 r2 l i;\n        evaluate_outputs b i r2 = map Some p;\n        accepts_trace e2 aa (evaluate_updates b i r2) t\\<rbrakk>\n       \\<Longrightarrow> accepts_trace e1 s1 r1 ((l, i, p) # t)", "subgoal for aa b"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>executionally_equivalent e1 s1 r1 e2 s2 r2\n              ((l, i) # map (\\<lambda>(l, i, o). (l, i)) t);\n     a = (l, i, p);\n     \\<And>s1 r1 s2 r2.\n        executionally_equivalent e1 s1 r1 e2 s2 r2\n         (map (\\<lambda>(l, i, o). (l, i)) t) \\<Longrightarrow>\n        accepts_trace e2 s2 r2 t = accepts_trace e1 s1 r1 t;\n     \\<forall>(s1', t1)|\\<in>|possible_steps e1 s1 r1 l i.\n        \\<exists>(s2', t2)|\\<in>|possible_steps e2 s2 r2 l i.\n           evaluate_outputs t1 i r1 = evaluate_outputs t2 i r2 \\<and>\n           executionally_equivalent e1 s1' (evaluate_updates t1 i r1) e2 s2'\n            (evaluate_updates t2 i r2) (map (\\<lambda>(l, i, o). (l, i)) t);\n     \\<forall>(s2', t2)|\\<in>|possible_steps e2 s2 r2 l i.\n        \\<exists>(s1', t1)|\\<in>|possible_steps e1 s1 r1 l i.\n           evaluate_outputs t1 i r1 = evaluate_outputs t2 i r2 \\<and>\n           executionally_equivalent e1 s1' (evaluate_updates t1 i r1) e2 s2'\n            (evaluate_updates t2 i r2) (map (\\<lambda>(l, i, o). (l, i)) t);\n     accepts_trace e2 s2 r2 ((l, i, p) # t);\n     (aa, b) |\\<in>| possible_steps e2 s2 r2 l i;\n     evaluate_outputs b i r2 = map Some p;\n     accepts_trace e2 aa (evaluate_updates b i r2) t\\<rbrakk>\n    \\<Longrightarrow> accepts_trace e1 s1 r1 ((l, i, p) # t)", "apply (rule accepts_trace.step)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>executionally_equivalent e1 s1 r1 e2 s2 r2\n              ((l, i) # map (\\<lambda>(l, i, o). (l, i)) t);\n     a = (l, i, p);\n     \\<And>s1 r1 s2 r2.\n        executionally_equivalent e1 s1 r1 e2 s2 r2\n         (map (\\<lambda>(l, i, o). (l, i)) t) \\<Longrightarrow>\n        accepts_trace e2 s2 r2 t = accepts_trace e1 s1 r1 t;\n     \\<forall>(s1', t1)|\\<in>|possible_steps e1 s1 r1 l i.\n        \\<exists>(s2', t2)|\\<in>|possible_steps e2 s2 r2 l i.\n           evaluate_outputs t1 i r1 = evaluate_outputs t2 i r2 \\<and>\n           executionally_equivalent e1 s1' (evaluate_updates t1 i r1) e2 s2'\n            (evaluate_updates t2 i r2) (map (\\<lambda>(l, i, o). (l, i)) t);\n     \\<forall>(s2', t2)|\\<in>|possible_steps e2 s2 r2 l i.\n        \\<exists>(s1', t1)|\\<in>|possible_steps e1 s1 r1 l i.\n           evaluate_outputs t1 i r1 = evaluate_outputs t2 i r2 \\<and>\n           executionally_equivalent e1 s1' (evaluate_updates t1 i r1) e2 s2'\n            (evaluate_updates t2 i r2) (map (\\<lambda>(l, i, o). (l, i)) t);\n     accepts_trace e2 s2 r2 ((l, i, p) # t);\n     (aa, b) |\\<in>| possible_steps e2 s2 r2 l i;\n     evaluate_outputs b i r2 = map Some p;\n     accepts_trace e2 aa (evaluate_updates b i r2) t\\<rbrakk>\n    \\<Longrightarrow> \\<exists>(s', T)|\\<in>|possible_steps e1 s1 r1 l i.\n                         evaluate_outputs T i r1 = map Some p \\<and>\n                         accepts_trace e1 s' (evaluate_updates T i r1) t", "apply (erule_tac x=\"(aa, b)\" in fBallE[of \"possible_steps e2 s2 r2 l i\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>executionally_equivalent e1 s1 r1 e2 s2 r2\n              ((l, i) # map (\\<lambda>(l, i, o). (l, i)) t);\n     a = (l, i, p);\n     \\<And>s1 r1 s2 r2.\n        executionally_equivalent e1 s1 r1 e2 s2 r2\n         (map (\\<lambda>(l, i, o). (l, i)) t) \\<Longrightarrow>\n        accepts_trace e2 s2 r2 t = accepts_trace e1 s1 r1 t;\n     \\<forall>(s1', t1)|\\<in>|possible_steps e1 s1 r1 l i.\n        \\<exists>(s2', t2)|\\<in>|possible_steps e2 s2 r2 l i.\n           evaluate_outputs t1 i r1 = evaluate_outputs t2 i r2 \\<and>\n           executionally_equivalent e1 s1' (evaluate_updates t1 i r1) e2 s2'\n            (evaluate_updates t2 i r2) (map (\\<lambda>(l, i, o). (l, i)) t);\n     accepts_trace e2 s2 r2 ((l, i, p) # t);\n     (aa, b) |\\<in>| possible_steps e2 s2 r2 l i;\n     evaluate_outputs b i r2 = map Some p;\n     accepts_trace e2 aa (evaluate_updates b i r2) t;\n     case (aa, b) of\n     (s2', t2) \\<Rightarrow>\n       \\<exists>(s1', t1)|\\<in>|possible_steps e1 s1 r1 l i.\n          evaluate_outputs t1 i r1 = evaluate_outputs t2 i r2 \\<and>\n          executionally_equivalent e1 s1' (evaluate_updates t1 i r1) e2 s2'\n           (evaluate_updates t2 i r2)\n           (map (\\<lambda>(l, i, o). (l, i)) t)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>(s', T)|\\<in>|possible_steps e1 s1 r1 l i.\n                         evaluate_outputs T i r1 = map Some p \\<and>\n                         accepts_trace e1 s' (evaluate_updates T i r1) t\n 2. \\<lbrakk>executionally_equivalent e1 s1 r1 e2 s2 r2\n              ((l, i) # map (\\<lambda>(l, i, o). (l, i)) t);\n     a = (l, i, p);\n     \\<And>s1 r1 s2 r2.\n        executionally_equivalent e1 s1 r1 e2 s2 r2\n         (map (\\<lambda>(l, i, o). (l, i)) t) \\<Longrightarrow>\n        accepts_trace e2 s2 r2 t = accepts_trace e1 s1 r1 t;\n     \\<forall>(s1', t1)|\\<in>|possible_steps e1 s1 r1 l i.\n        \\<exists>(s2', t2)|\\<in>|possible_steps e2 s2 r2 l i.\n           evaluate_outputs t1 i r1 = evaluate_outputs t2 i r2 \\<and>\n           executionally_equivalent e1 s1' (evaluate_updates t1 i r1) e2 s2'\n            (evaluate_updates t2 i r2) (map (\\<lambda>(l, i, o). (l, i)) t);\n     accepts_trace e2 s2 r2 ((l, i, p) # t);\n     (aa, b) |\\<in>| possible_steps e2 s2 r2 l i;\n     evaluate_outputs b i r2 = map Some p;\n     accepts_trace e2 aa (evaluate_updates b i r2) t;\n     (aa, b) |\\<notin>| possible_steps e2 s2 r2 l i\\<rbrakk>\n    \\<Longrightarrow> \\<exists>(s', T)|\\<in>|possible_steps e1 s1 r1 l i.\n                         evaluate_outputs T i r1 = map Some p \\<and>\n                         accepts_trace e1 s' (evaluate_updates T i r1) t", "defer"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>executionally_equivalent e1 s1 r1 e2 s2 r2\n              ((l, i) # map (\\<lambda>(l, i, o). (l, i)) t);\n     a = (l, i, p);\n     \\<And>s1 r1 s2 r2.\n        executionally_equivalent e1 s1 r1 e2 s2 r2\n         (map (\\<lambda>(l, i, o). (l, i)) t) \\<Longrightarrow>\n        accepts_trace e2 s2 r2 t = accepts_trace e1 s1 r1 t;\n     \\<forall>(s1', t1)|\\<in>|possible_steps e1 s1 r1 l i.\n        \\<exists>(s2', t2)|\\<in>|possible_steps e2 s2 r2 l i.\n           evaluate_outputs t1 i r1 = evaluate_outputs t2 i r2 \\<and>\n           executionally_equivalent e1 s1' (evaluate_updates t1 i r1) e2 s2'\n            (evaluate_updates t2 i r2) (map (\\<lambda>(l, i, o). (l, i)) t);\n     accepts_trace e2 s2 r2 ((l, i, p) # t);\n     (aa, b) |\\<in>| possible_steps e2 s2 r2 l i;\n     evaluate_outputs b i r2 = map Some p;\n     accepts_trace e2 aa (evaluate_updates b i r2) t;\n     (aa, b) |\\<notin>| possible_steps e2 s2 r2 l i\\<rbrakk>\n    \\<Longrightarrow> \\<exists>(s', T)|\\<in>|possible_steps e1 s1 r1 l i.\n                         evaluate_outputs T i r1 = map Some p \\<and>\n                         accepts_trace e1 s' (evaluate_updates T i r1) t\n 2. \\<lbrakk>executionally_equivalent e1 s1 r1 e2 s2 r2\n              ((l, i) # map (\\<lambda>(l, i, o). (l, i)) t);\n     a = (l, i, p);\n     \\<And>s1 r1 s2 r2.\n        executionally_equivalent e1 s1 r1 e2 s2 r2\n         (map (\\<lambda>(l, i, o). (l, i)) t) \\<Longrightarrow>\n        accepts_trace e2 s2 r2 t = accepts_trace e1 s1 r1 t;\n     \\<forall>(s1', t1)|\\<in>|possible_steps e1 s1 r1 l i.\n        \\<exists>(s2', t2)|\\<in>|possible_steps e2 s2 r2 l i.\n           evaluate_outputs t1 i r1 = evaluate_outputs t2 i r2 \\<and>\n           executionally_equivalent e1 s1' (evaluate_updates t1 i r1) e2 s2'\n            (evaluate_updates t2 i r2) (map (\\<lambda>(l, i, o). (l, i)) t);\n     accepts_trace e2 s2 r2 ((l, i, p) # t);\n     (aa, b) |\\<in>| possible_steps e2 s2 r2 l i;\n     evaluate_outputs b i r2 = map Some p;\n     accepts_trace e2 aa (evaluate_updates b i r2) t;\n     case (aa, b) of\n     (s2', t2) \\<Rightarrow>\n       \\<exists>(s1', t1)|\\<in>|possible_steps e1 s1 r1 l i.\n          evaluate_outputs t1 i r1 = evaluate_outputs t2 i r2 \\<and>\n          executionally_equivalent e1 s1' (evaluate_updates t1 i r1) e2 s2'\n           (evaluate_updates t2 i r2)\n           (map (\\<lambda>(l, i, o). (l, i)) t)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>(s', T)|\\<in>|possible_steps e1 s1 r1 l i.\n                         evaluate_outputs T i r1 = map Some p \\<and>\n                         accepts_trace e1 s' (evaluate_updates T i r1) t", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>executionally_equivalent e1 s1 r1 e2 s2 r2\n              ((l, i) # map (\\<lambda>(l, i, o). (l, i)) t);\n     a = (l, i, p);\n     \\<And>s1 r1 s2 r2.\n        executionally_equivalent e1 s1 r1 e2 s2 r2\n         (map (\\<lambda>(l, i, o). (l, i)) t) \\<Longrightarrow>\n        accepts_trace e2 s2 r2 t = accepts_trace e1 s1 r1 t;\n     \\<forall>(s1', t1)|\\<in>|possible_steps e1 s1 r1 l i.\n        \\<exists>(s2', t2)|\\<in>|possible_steps e2 s2 r2 l i.\n           evaluate_outputs t1 i r1 = evaluate_outputs t2 i r2 \\<and>\n           executionally_equivalent e1 s1' (evaluate_updates t1 i r1) e2 s2'\n            (evaluate_updates t2 i r2) (map (\\<lambda>(l, i, o). (l, i)) t);\n     accepts_trace e2 s2 r2 ((l, i, p) # t);\n     (aa, b) |\\<in>| possible_steps e2 s2 r2 l i;\n     evaluate_outputs b i r2 = map Some p;\n     accepts_trace e2 aa (evaluate_updates b i r2) t;\n     case (aa, b) of\n     (s2', t2) \\<Rightarrow>\n       \\<exists>(s1', t1)|\\<in>|possible_steps e1 s1 r1 l i.\n          evaluate_outputs t1 i r1 = evaluate_outputs t2 i r2 \\<and>\n          executionally_equivalent e1 s1' (evaluate_updates t1 i r1) e2 s2'\n           (evaluate_updates t2 i r2)\n           (map (\\<lambda>(l, i, o). (l, i)) t)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>(s', T)|\\<in>|possible_steps e1 s1 r1 l i.\n                         evaluate_outputs T i r1 = map Some p \\<and>\n                         accepts_trace e1 s' (evaluate_updates T i r1) t", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>executionally_equivalent e1 s1 r1 e2 s2 r2\n              ((l, i) # map (\\<lambda>(l, i, o). (l, i)) t);\n     a = (l, i, p);\n     \\<And>s1 r1 s2 r2.\n        executionally_equivalent e1 s1 r1 e2 s2 r2\n         (map (\\<lambda>(l, i, o). (l, i)) t) \\<Longrightarrow>\n        accepts_trace e2 s2 r2 t = accepts_trace e1 s1 r1 t;\n     \\<forall>(s1', t1)|\\<in>|possible_steps e1 s1 r1 l i.\n        \\<exists>(s2', t2)|\\<in>|possible_steps e2 s2 r2 l i.\n           evaluate_outputs t1 i r1 = evaluate_outputs t2 i r2 \\<and>\n           executionally_equivalent e1 s1' (evaluate_updates t1 i r1) e2 s2'\n            (evaluate_updates t2 i r2) (map (\\<lambda>(l, i, o). (l, i)) t);\n     accepts_trace e2 s2 r2 ((l, i, p) # t);\n     (aa, b) |\\<in>| possible_steps e2 s2 r2 l i;\n     evaluate_outputs b i r2 = map Some p;\n     accepts_trace e2 aa (evaluate_updates b i r2) t;\n     \\<exists>(s1', t1)|\\<in>|possible_steps e1 s1 r1 l i.\n        evaluate_outputs t1 i r1 = map Some p \\<and>\n        executionally_equivalent e1 s1' (evaluate_updates t1 i r1) e2 aa\n         (evaluate_updates b i r2)\n         (map (\\<lambda>(l, i, o). (l, i)) t)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>(s', T)|\\<in>|possible_steps e1 s1 r1 l i.\n                         evaluate_outputs T i r1 = map Some p \\<and>\n                         accepts_trace e1 s' (evaluate_updates T i r1) t", "by blast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b c l.\n       \\<lbrakk>executionally_equivalent e1 s1 r1 e2 s2 r2\n                 ((l, b) # map (\\<lambda>(l, i, o). (l, i)) t);\n        a = (l, b, c);\n        \\<And>s1 r1 s2 r2.\n           executionally_equivalent e1 s1 r1 e2 s2 r2\n            (map (\\<lambda>(l, i, o). (l, i)) t) \\<Longrightarrow>\n           accepts_trace e2 s2 r2 t = accepts_trace e1 s1 r1 t;\n        \\<forall>(s1', t1)|\\<in>|possible_steps e1 s1 r1 l b.\n           \\<exists>(s2', t2)|\\<in>|possible_steps e2 s2 r2 l b.\n              evaluate_outputs t1 b r1 = evaluate_outputs t2 b r2 \\<and>\n              executionally_equivalent e1 s1' (evaluate_updates t1 b r1) e2\n               s2' (evaluate_updates t2 b r2)\n               (map (\\<lambda>(l, i, o). (l, i)) t);\n        \\<forall>(s2', t2)|\\<in>|possible_steps e2 s2 r2 l b.\n           \\<exists>(s1', t1)|\\<in>|possible_steps e1 s1 r1 l b.\n              evaluate_outputs t1 b r1 = evaluate_outputs t2 b r2 \\<and>\n              executionally_equivalent e1 s1' (evaluate_updates t1 b r1) e2\n               s2' (evaluate_updates t2 b r2)\n               (map (\\<lambda>(l, i, o). (l, i)) t);\n        accepts_trace e1 s1 r1 ((l, b, c) # t)\\<rbrakk>\n       \\<Longrightarrow> accepts_trace e2 s2 r2 ((l, b, c) # t)", "apply (rule accepts_trace.cases)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>b c l.\n       \\<lbrakk>executionally_equivalent e1 s1 r1 e2 s2 r2\n                 ((l, b) # map (\\<lambda>(l, i, o). (l, i)) t);\n        a = (l, b, c);\n        \\<And>s1 r1 s2 r2.\n           executionally_equivalent e1 s1 r1 e2 s2 r2\n            (map (\\<lambda>(l, i, o). (l, i)) t) \\<Longrightarrow>\n           accepts_trace e2 s2 r2 t = accepts_trace e1 s1 r1 t;\n        \\<forall>(s1', t1)|\\<in>|possible_steps e1 s1 r1 l b.\n           \\<exists>(s2', t2)|\\<in>|possible_steps e2 s2 r2 l b.\n              evaluate_outputs t1 b r1 = evaluate_outputs t2 b r2 \\<and>\n              executionally_equivalent e1 s1' (evaluate_updates t1 b r1) e2\n               s2' (evaluate_updates t2 b r2)\n               (map (\\<lambda>(l, i, o). (l, i)) t);\n        \\<forall>(s2', t2)|\\<in>|possible_steps e2 s2 r2 l b.\n           \\<exists>(s1', t1)|\\<in>|possible_steps e1 s1 r1 l b.\n              evaluate_outputs t1 b r1 = evaluate_outputs t2 b r2 \\<and>\n              executionally_equivalent e1 s1' (evaluate_updates t1 b r1) e2\n               s2' (evaluate_updates t2 b r2)\n               (map (\\<lambda>(l, i, o). (l, i)) t);\n        accepts_trace e1 s1 r1 ((l, b, c) # t)\\<rbrakk>\n       \\<Longrightarrow> accepts_trace (?a1.21 b c l) (?a2.21 b c l)\n                          (?a3.21 b c l) (?a4.21 b c l)\n 2. \\<And>b c l e s r.\n       \\<lbrakk>executionally_equivalent e1 s1 r1 e2 s2 r2\n                 ((l, b) # map (\\<lambda>(l, i, o). (l, i)) t);\n        a = (l, b, c);\n        \\<And>s1 r1 s2 r2.\n           executionally_equivalent e1 s1 r1 e2 s2 r2\n            (map (\\<lambda>(l, i, o). (l, i)) t) \\<Longrightarrow>\n           accepts_trace e2 s2 r2 t = accepts_trace e1 s1 r1 t;\n        \\<forall>(s1', t1)|\\<in>|possible_steps e1 s1 r1 l b.\n           \\<exists>(s2', t2)|\\<in>|possible_steps e2 s2 r2 l b.\n              evaluate_outputs t1 b r1 = evaluate_outputs t2 b r2 \\<and>\n              executionally_equivalent e1 s1' (evaluate_updates t1 b r1) e2\n               s2' (evaluate_updates t2 b r2)\n               (map (\\<lambda>(l, i, o). (l, i)) t);\n        \\<forall>(s2', t2)|\\<in>|possible_steps e2 s2 r2 l b.\n           \\<exists>(s1', t1)|\\<in>|possible_steps e1 s1 r1 l b.\n              evaluate_outputs t1 b r1 = evaluate_outputs t2 b r2 \\<and>\n              executionally_equivalent e1 s1' (evaluate_updates t1 b r1) e2\n               s2' (evaluate_updates t2 b r2)\n               (map (\\<lambda>(l, i, o). (l, i)) t);\n        accepts_trace e1 s1 r1 ((l, b, c) # t); ?a1.21 b c l = e;\n        ?a2.21 b c l = s; ?a3.21 b c l = r; ?a4.21 b c l = []\\<rbrakk>\n       \\<Longrightarrow> accepts_trace e2 s2 r2 ((l, b, c) # t)\n 3. \\<And>b c l e s r la i p t.\n       \\<lbrakk>executionally_equivalent e1 s1 r1 e2 s2 r2\n                 ((l, b) # map (\\<lambda>(l, i, o). (l, i)) t);\n        a = (l, b, c);\n        \\<And>s1 r1 s2 r2.\n           executionally_equivalent e1 s1 r1 e2 s2 r2\n            (map (\\<lambda>(l, i, o). (l, i)) t) \\<Longrightarrow>\n           accepts_trace e2 s2 r2 t = accepts_trace e1 s1 r1 t;\n        \\<forall>(s1', t1)|\\<in>|possible_steps e1 s1 r1 l b.\n           \\<exists>(s2', t2)|\\<in>|possible_steps e2 s2 r2 l b.\n              evaluate_outputs t1 b r1 = evaluate_outputs t2 b r2 \\<and>\n              executionally_equivalent e1 s1' (evaluate_updates t1 b r1) e2\n               s2' (evaluate_updates t2 b r2)\n               (map (\\<lambda>(l, i, o). (l, i)) t);\n        \\<forall>(s2', t2)|\\<in>|possible_steps e2 s2 r2 l b.\n           \\<exists>(s1', t1)|\\<in>|possible_steps e1 s1 r1 l b.\n              evaluate_outputs t1 b r1 = evaluate_outputs t2 b r2 \\<and>\n              executionally_equivalent e1 s1' (evaluate_updates t1 b r1) e2\n               s2' (evaluate_updates t2 b r2)\n               (map (\\<lambda>(l, i, o). (l, i)) t);\n        accepts_trace e1 s1 r1 ((l, b, c) # t); ?a1.21 b c l = e;\n        ?a2.21 b c l = s; ?a3.21 b c l = r; ?a4.21 b c l = (la, i, p) # t;\n        \\<exists>(s', T)|\\<in>|possible_steps e s r la i.\n           evaluate_outputs T i r = map Some p \\<and>\n           accepts_trace e s' (evaluate_updates T i r) t\\<rbrakk>\n       \\<Longrightarrow> accepts_trace e2 s2 r2 ((l, b, c) # t)", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>b c l e s r.\n       \\<lbrakk>executionally_equivalent e1 s1 r1 e2 s2 r2\n                 ((l, b) # map (\\<lambda>(l, i, o). (l, i)) t);\n        a = (l, b, c);\n        \\<And>s1 r1 s2 r2.\n           executionally_equivalent e1 s1 r1 e2 s2 r2\n            (map (\\<lambda>(l, i, o). (l, i)) t) \\<Longrightarrow>\n           accepts_trace e2 s2 r2 t = accepts_trace e1 s1 r1 t;\n        \\<forall>(s1', t1)|\\<in>|possible_steps e1 s1 r1 l b.\n           \\<exists>(s2', t2)|\\<in>|possible_steps e2 s2 r2 l b.\n              evaluate_outputs t1 b r1 = evaluate_outputs t2 b r2 \\<and>\n              executionally_equivalent e1 s1' (evaluate_updates t1 b r1) e2\n               s2' (evaluate_updates t2 b r2)\n               (map (\\<lambda>(l, i, o). (l, i)) t);\n        \\<forall>(s2', t2)|\\<in>|possible_steps e2 s2 r2 l b.\n           \\<exists>(s1', t1)|\\<in>|possible_steps e1 s1 r1 l b.\n              evaluate_outputs t1 b r1 = evaluate_outputs t2 b r2 \\<and>\n              executionally_equivalent e1 s1' (evaluate_updates t1 b r1) e2\n               s2' (evaluate_updates t2 b r2)\n               (map (\\<lambda>(l, i, o). (l, i)) t);\n        accepts_trace e1 s1 r1 ((l, b, c) # t); e1 = e; s1 = s; r1 = r;\n        (l, b, c) # t = []\\<rbrakk>\n       \\<Longrightarrow> accepts_trace e2 s2 r2 ((l, b, c) # t)\n 2. \\<And>b c l e s r la i p t.\n       \\<lbrakk>executionally_equivalent e1 s1 r1 e2 s2 r2\n                 ((l, b) # map (\\<lambda>(l, i, o). (l, i)) t);\n        a = (l, b, c);\n        \\<And>s1 r1 s2 r2.\n           executionally_equivalent e1 s1 r1 e2 s2 r2\n            (map (\\<lambda>(l, i, o). (l, i)) t) \\<Longrightarrow>\n           accepts_trace e2 s2 r2 t = accepts_trace e1 s1 r1 t;\n        \\<forall>(s1', t1)|\\<in>|possible_steps e1 s1 r1 l b.\n           \\<exists>(s2', t2)|\\<in>|possible_steps e2 s2 r2 l b.\n              evaluate_outputs t1 b r1 = evaluate_outputs t2 b r2 \\<and>\n              executionally_equivalent e1 s1' (evaluate_updates t1 b r1) e2\n               s2' (evaluate_updates t2 b r2)\n               (map (\\<lambda>(l, i, o). (l, i)) t);\n        \\<forall>(s2', t2)|\\<in>|possible_steps e2 s2 r2 l b.\n           \\<exists>(s1', t1)|\\<in>|possible_steps e1 s1 r1 l b.\n              evaluate_outputs t1 b r1 = evaluate_outputs t2 b r2 \\<and>\n              executionally_equivalent e1 s1' (evaluate_updates t1 b r1) e2\n               s2' (evaluate_updates t2 b r2)\n               (map (\\<lambda>(l, i, o). (l, i)) t);\n        accepts_trace e1 s1 r1 ((l, b, c) # t); e1 = e; s1 = s; r1 = r;\n        (l, b, c) # t = (la, i, p) # t;\n        \\<exists>(s', T)|\\<in>|possible_steps e s r la i.\n           evaluate_outputs T i r = map Some p \\<and>\n           accepts_trace e s' (evaluate_updates T i r) t\\<rbrakk>\n       \\<Longrightarrow> accepts_trace e2 s2 r2 ((l, b, c) # t)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b c l e s r la i p t.\n       \\<lbrakk>executionally_equivalent e1 s1 r1 e2 s2 r2\n                 ((l, b) # map (\\<lambda>(l, i, o). (l, i)) t);\n        a = (l, b, c);\n        \\<And>s1 r1 s2 r2.\n           executionally_equivalent e1 s1 r1 e2 s2 r2\n            (map (\\<lambda>(l, i, o). (l, i)) t) \\<Longrightarrow>\n           accepts_trace e2 s2 r2 t = accepts_trace e1 s1 r1 t;\n        \\<forall>(s1', t1)|\\<in>|possible_steps e1 s1 r1 l b.\n           \\<exists>(s2', t2)|\\<in>|possible_steps e2 s2 r2 l b.\n              evaluate_outputs t1 b r1 = evaluate_outputs t2 b r2 \\<and>\n              executionally_equivalent e1 s1' (evaluate_updates t1 b r1) e2\n               s2' (evaluate_updates t2 b r2)\n               (map (\\<lambda>(l, i, o). (l, i)) t);\n        \\<forall>(s2', t2)|\\<in>|possible_steps e2 s2 r2 l b.\n           \\<exists>(s1', t1)|\\<in>|possible_steps e1 s1 r1 l b.\n              evaluate_outputs t1 b r1 = evaluate_outputs t2 b r2 \\<and>\n              executionally_equivalent e1 s1' (evaluate_updates t1 b r1) e2\n               s2' (evaluate_updates t2 b r2)\n               (map (\\<lambda>(l, i, o). (l, i)) t);\n        accepts_trace e1 s1 r1 ((l, b, c) # t); e1 = e; s1 = s; r1 = r;\n        (l, b, c) # t = (la, i, p) # t;\n        \\<exists>(s', T)|\\<in>|possible_steps e s r la i.\n           evaluate_outputs T i r = map Some p \\<and>\n           accepts_trace e s' (evaluate_updates T i r) t\\<rbrakk>\n       \\<Longrightarrow> accepts_trace e2 s2 r2 ((l, b, c) # t)", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b c la aa ba.\n       \\<lbrakk>executionally_equivalent e1 s1 r1 e2 s2 r2\n                 ((la, b) # map (\\<lambda>(l, i, o). (l, i)) t);\n        a = (la, b, c);\n        \\<And>s1 r1 s2 r2.\n           executionally_equivalent e1 s1 r1 e2 s2 r2\n            (map (\\<lambda>(l, i, o). (l, i)) t) \\<Longrightarrow>\n           accepts_trace e2 s2 r2 t = accepts_trace e1 s1 r1 t;\n        \\<forall>(s1', t1)|\\<in>|possible_steps e1 s1 r1 la b.\n           \\<exists>(s2', t2)|\\<in>|possible_steps e2 s2 r2 la b.\n              evaluate_outputs t1 b r1 = evaluate_outputs t2 b r2 \\<and>\n              executionally_equivalent e1 s1' (evaluate_updates t1 b r1) e2\n               s2' (evaluate_updates t2 b r2)\n               (map (\\<lambda>(l, i, o). (l, i)) t);\n        \\<forall>(s2', t2)|\\<in>|possible_steps e2 s2 r2 la b.\n           \\<exists>(s1', t1)|\\<in>|possible_steps e1 s1 r1 la b.\n              evaluate_outputs t1 b r1 = evaluate_outputs t2 b r2 \\<and>\n              executionally_equivalent e1 s1' (evaluate_updates t1 b r1) e2\n               s2' (evaluate_updates t2 b r2)\n               (map (\\<lambda>(l, i, o). (l, i)) t);\n        accepts_trace e1 s1 r1 ((la, b, c) # t);\n        (aa, ba) |\\<in>| possible_steps e1 s1 r1 la b;\n        evaluate_outputs ba b r1 = map Some c;\n        accepts_trace e1 aa (evaluate_updates ba b r1) t\\<rbrakk>\n       \\<Longrightarrow> accepts_trace e2 s2 r2 ((la, b, c) # t)", "subgoal for _ _ _ aa b"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>executionally_equivalent e1 s1 r1 e2 s2 r2\n              ((la_, b_) # map (\\<lambda>(l, i, o). (l, i)) t);\n     a = (la_, b_, c_);\n     \\<And>s1 r1 s2 r2.\n        executionally_equivalent e1 s1 r1 e2 s2 r2\n         (map (\\<lambda>(l, i, o). (l, i)) t) \\<Longrightarrow>\n        accepts_trace e2 s2 r2 t = accepts_trace e1 s1 r1 t;\n     \\<forall>(s1', t1)|\\<in>|possible_steps e1 s1 r1 la_ b_.\n        \\<exists>(s2', t2)|\\<in>|possible_steps e2 s2 r2 la_ b_.\n           evaluate_outputs t1 b_ r1 = evaluate_outputs t2 b_ r2 \\<and>\n           executionally_equivalent e1 s1' (evaluate_updates t1 b_ r1) e2\n            s2' (evaluate_updates t2 b_ r2)\n            (map (\\<lambda>(l, i, o). (l, i)) t);\n     \\<forall>(s2', t2)|\\<in>|possible_steps e2 s2 r2 la_ b_.\n        \\<exists>(s1', t1)|\\<in>|possible_steps e1 s1 r1 la_ b_.\n           evaluate_outputs t1 b_ r1 = evaluate_outputs t2 b_ r2 \\<and>\n           executionally_equivalent e1 s1' (evaluate_updates t1 b_ r1) e2\n            s2' (evaluate_updates t2 b_ r2)\n            (map (\\<lambda>(l, i, o). (l, i)) t);\n     accepts_trace e1 s1 r1 ((la_, b_, c_) # t);\n     (aa, b) |\\<in>| possible_steps e1 s1 r1 la_ b_;\n     evaluate_outputs b b_ r1 = map Some c_;\n     accepts_trace e1 aa (evaluate_updates b b_ r1) t\\<rbrakk>\n    \\<Longrightarrow> accepts_trace e2 s2 r2 ((la_, b_, c_) # t)", "apply (rule accepts_trace.step)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>executionally_equivalent e1 s1 r1 e2 s2 r2\n              ((la_, b_) # map (\\<lambda>(l, i, o). (l, i)) t);\n     a = (la_, b_, c_);\n     \\<And>s1 r1 s2 r2.\n        executionally_equivalent e1 s1 r1 e2 s2 r2\n         (map (\\<lambda>(l, i, o). (l, i)) t) \\<Longrightarrow>\n        accepts_trace e2 s2 r2 t = accepts_trace e1 s1 r1 t;\n     \\<forall>(s1', t1)|\\<in>|possible_steps e1 s1 r1 la_ b_.\n        \\<exists>(s2', t2)|\\<in>|possible_steps e2 s2 r2 la_ b_.\n           evaluate_outputs t1 b_ r1 = evaluate_outputs t2 b_ r2 \\<and>\n           executionally_equivalent e1 s1' (evaluate_updates t1 b_ r1) e2\n            s2' (evaluate_updates t2 b_ r2)\n            (map (\\<lambda>(l, i, o). (l, i)) t);\n     \\<forall>(s2', t2)|\\<in>|possible_steps e2 s2 r2 la_ b_.\n        \\<exists>(s1', t1)|\\<in>|possible_steps e1 s1 r1 la_ b_.\n           evaluate_outputs t1 b_ r1 = evaluate_outputs t2 b_ r2 \\<and>\n           executionally_equivalent e1 s1' (evaluate_updates t1 b_ r1) e2\n            s2' (evaluate_updates t2 b_ r2)\n            (map (\\<lambda>(l, i, o). (l, i)) t);\n     accepts_trace e1 s1 r1 ((la_, b_, c_) # t);\n     (aa, b) |\\<in>| possible_steps e1 s1 r1 la_ b_;\n     evaluate_outputs b b_ r1 = map Some c_;\n     accepts_trace e1 aa (evaluate_updates b b_ r1) t\\<rbrakk>\n    \\<Longrightarrow> \\<exists>(s', T)|\\<in>|possible_steps e2 s2 r2 la_ b_.\n                         evaluate_outputs T b_ r2 = map Some c_ \\<and>\n                         accepts_trace e2 s' (evaluate_updates T b_ r2) t", "apply (erule_tac x=\"(aa, b)\" in fBallE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>executionally_equivalent e1 s1 r1 e2 s2 r2\n              ((la_, b_) # map (\\<lambda>(l, i, o). (l, i)) t);\n     a = (la_, b_, c_);\n     \\<And>s1 r1 s2 r2.\n        executionally_equivalent e1 s1 r1 e2 s2 r2\n         (map (\\<lambda>(l, i, o). (l, i)) t) \\<Longrightarrow>\n        accepts_trace e2 s2 r2 t = accepts_trace e1 s1 r1 t;\n     \\<forall>(s2', t2)|\\<in>|possible_steps e2 s2 r2 la_ b_.\n        \\<exists>(s1', t1)|\\<in>|possible_steps e1 s1 r1 la_ b_.\n           evaluate_outputs t1 b_ r1 = evaluate_outputs t2 b_ r2 \\<and>\n           executionally_equivalent e1 s1' (evaluate_updates t1 b_ r1) e2\n            s2' (evaluate_updates t2 b_ r2)\n            (map (\\<lambda>(l, i, o). (l, i)) t);\n     accepts_trace e1 s1 r1 ((la_, b_, c_) # t);\n     (aa, b) |\\<in>| possible_steps e1 s1 r1 la_ b_;\n     evaluate_outputs b b_ r1 = map Some c_;\n     accepts_trace e1 aa (evaluate_updates b b_ r1) t;\n     case (aa, b) of\n     (s1', t1) \\<Rightarrow>\n       \\<exists>(s2', t2)|\\<in>|possible_steps e2 s2 r2 la_ b_.\n          evaluate_outputs t1 b_ r1 = evaluate_outputs t2 b_ r2 \\<and>\n          executionally_equivalent e1 s1' (evaluate_updates t1 b_ r1) e2 s2'\n           (evaluate_updates t2 b_ r2)\n           (map (\\<lambda>(l, i, o). (l, i)) t)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>(s', T)|\\<in>|possible_steps e2 s2 r2 la_ b_.\n                         evaluate_outputs T b_ r2 = map Some c_ \\<and>\n                         accepts_trace e2 s' (evaluate_updates T b_ r2) t\n 2. \\<lbrakk>executionally_equivalent e1 s1 r1 e2 s2 r2\n              ((la_, b_) # map (\\<lambda>(l, i, o). (l, i)) t);\n     a = (la_, b_, c_);\n     \\<And>s1 r1 s2 r2.\n        executionally_equivalent e1 s1 r1 e2 s2 r2\n         (map (\\<lambda>(l, i, o). (l, i)) t) \\<Longrightarrow>\n        accepts_trace e2 s2 r2 t = accepts_trace e1 s1 r1 t;\n     \\<forall>(s2', t2)|\\<in>|possible_steps e2 s2 r2 la_ b_.\n        \\<exists>(s1', t1)|\\<in>|possible_steps e1 s1 r1 la_ b_.\n           evaluate_outputs t1 b_ r1 = evaluate_outputs t2 b_ r2 \\<and>\n           executionally_equivalent e1 s1' (evaluate_updates t1 b_ r1) e2\n            s2' (evaluate_updates t2 b_ r2)\n            (map (\\<lambda>(l, i, o). (l, i)) t);\n     accepts_trace e1 s1 r1 ((la_, b_, c_) # t);\n     (aa, b) |\\<in>| possible_steps e1 s1 r1 la_ b_;\n     evaluate_outputs b b_ r1 = map Some c_;\n     accepts_trace e1 aa (evaluate_updates b b_ r1) t;\n     (aa, b) |\\<notin>| possible_steps e1 s1 r1 la_ b_\\<rbrakk>\n    \\<Longrightarrow> \\<exists>(s', T)|\\<in>|possible_steps e2 s2 r2 la_ b_.\n                         evaluate_outputs T b_ r2 = map Some c_ \\<and>\n                         accepts_trace e2 s' (evaluate_updates T b_ r2) t", "defer"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>executionally_equivalent e1 s1 r1 e2 s2 r2\n              ((la_, b_) # map (\\<lambda>(l, i, o). (l, i)) t);\n     a = (la_, b_, c_);\n     \\<And>s1 r1 s2 r2.\n        executionally_equivalent e1 s1 r1 e2 s2 r2\n         (map (\\<lambda>(l, i, o). (l, i)) t) \\<Longrightarrow>\n        accepts_trace e2 s2 r2 t = accepts_trace e1 s1 r1 t;\n     \\<forall>(s2', t2)|\\<in>|possible_steps e2 s2 r2 la_ b_.\n        \\<exists>(s1', t1)|\\<in>|possible_steps e1 s1 r1 la_ b_.\n           evaluate_outputs t1 b_ r1 = evaluate_outputs t2 b_ r2 \\<and>\n           executionally_equivalent e1 s1' (evaluate_updates t1 b_ r1) e2\n            s2' (evaluate_updates t2 b_ r2)\n            (map (\\<lambda>(l, i, o). (l, i)) t);\n     accepts_trace e1 s1 r1 ((la_, b_, c_) # t);\n     (aa, b) |\\<in>| possible_steps e1 s1 r1 la_ b_;\n     evaluate_outputs b b_ r1 = map Some c_;\n     accepts_trace e1 aa (evaluate_updates b b_ r1) t;\n     (aa, b) |\\<notin>| possible_steps e1 s1 r1 la_ b_\\<rbrakk>\n    \\<Longrightarrow> \\<exists>(s', T)|\\<in>|possible_steps e2 s2 r2 la_ b_.\n                         evaluate_outputs T b_ r2 = map Some c_ \\<and>\n                         accepts_trace e2 s' (evaluate_updates T b_ r2) t\n 2. \\<lbrakk>executionally_equivalent e1 s1 r1 e2 s2 r2\n              ((la_, b_) # map (\\<lambda>(l, i, o). (l, i)) t);\n     a = (la_, b_, c_);\n     \\<And>s1 r1 s2 r2.\n        executionally_equivalent e1 s1 r1 e2 s2 r2\n         (map (\\<lambda>(l, i, o). (l, i)) t) \\<Longrightarrow>\n        accepts_trace e2 s2 r2 t = accepts_trace e1 s1 r1 t;\n     \\<forall>(s2', t2)|\\<in>|possible_steps e2 s2 r2 la_ b_.\n        \\<exists>(s1', t1)|\\<in>|possible_steps e1 s1 r1 la_ b_.\n           evaluate_outputs t1 b_ r1 = evaluate_outputs t2 b_ r2 \\<and>\n           executionally_equivalent e1 s1' (evaluate_updates t1 b_ r1) e2\n            s2' (evaluate_updates t2 b_ r2)\n            (map (\\<lambda>(l, i, o). (l, i)) t);\n     accepts_trace e1 s1 r1 ((la_, b_, c_) # t);\n     (aa, b) |\\<in>| possible_steps e1 s1 r1 la_ b_;\n     evaluate_outputs b b_ r1 = map Some c_;\n     accepts_trace e1 aa (evaluate_updates b b_ r1) t;\n     case (aa, b) of\n     (s1', t1) \\<Rightarrow>\n       \\<exists>(s2', t2)|\\<in>|possible_steps e2 s2 r2 la_ b_.\n          evaluate_outputs t1 b_ r1 = evaluate_outputs t2 b_ r2 \\<and>\n          executionally_equivalent e1 s1' (evaluate_updates t1 b_ r1) e2 s2'\n           (evaluate_updates t2 b_ r2)\n           (map (\\<lambda>(l, i, o). (l, i)) t)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>(s', T)|\\<in>|possible_steps e2 s2 r2 la_ b_.\n                         evaluate_outputs T b_ r2 = map Some c_ \\<and>\n                         accepts_trace e2 s' (evaluate_updates T b_ r2) t", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>executionally_equivalent e1 s1 r1 e2 s2 r2\n              ((la_, b_) # map (\\<lambda>(l, i, o). (l, i)) t);\n     a = (la_, b_, c_);\n     \\<And>s1 r1 s2 r2.\n        executionally_equivalent e1 s1 r1 e2 s2 r2\n         (map (\\<lambda>(l, i, o). (l, i)) t) \\<Longrightarrow>\n        accepts_trace e2 s2 r2 t = accepts_trace e1 s1 r1 t;\n     \\<forall>(s2', t2)|\\<in>|possible_steps e2 s2 r2 la_ b_.\n        \\<exists>(s1', t1)|\\<in>|possible_steps e1 s1 r1 la_ b_.\n           evaluate_outputs t1 b_ r1 = evaluate_outputs t2 b_ r2 \\<and>\n           executionally_equivalent e1 s1' (evaluate_updates t1 b_ r1) e2\n            s2' (evaluate_updates t2 b_ r2)\n            (map (\\<lambda>(l, i, o). (l, i)) t);\n     accepts_trace e1 s1 r1 ((la_, b_, c_) # t);\n     (aa, b) |\\<in>| possible_steps e1 s1 r1 la_ b_;\n     evaluate_outputs b b_ r1 = map Some c_;\n     accepts_trace e1 aa (evaluate_updates b b_ r1) t;\n     case (aa, b) of\n     (s1', t1) \\<Rightarrow>\n       \\<exists>(s2', t2)|\\<in>|possible_steps e2 s2 r2 la_ b_.\n          evaluate_outputs t1 b_ r1 = evaluate_outputs t2 b_ r2 \\<and>\n          executionally_equivalent e1 s1' (evaluate_updates t1 b_ r1) e2 s2'\n           (evaluate_updates t2 b_ r2)\n           (map (\\<lambda>(l, i, o). (l, i)) t)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>(s', T)|\\<in>|possible_steps e2 s2 r2 la_ b_.\n                         evaluate_outputs T b_ r2 = map Some c_ \\<and>\n                         accepts_trace e2 s' (evaluate_updates T b_ r2) t", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>executionally_equivalent e1 s1 r1 e2 s2 r2\n              ((la_, b_) # map (\\<lambda>(l, i, o). (l, i)) t);\n     a = (la_, b_, c_);\n     \\<And>s1 r1 s2 r2.\n        executionally_equivalent e1 s1 r1 e2 s2 r2\n         (map (\\<lambda>(l, i, o). (l, i)) t) \\<Longrightarrow>\n        accepts_trace e2 s2 r2 t = accepts_trace e1 s1 r1 t;\n     \\<forall>(s2', t2)|\\<in>|possible_steps e2 s2 r2 la_ b_.\n        \\<exists>(s1', t1)|\\<in>|possible_steps e1 s1 r1 la_ b_.\n           evaluate_outputs t1 b_ r1 = evaluate_outputs t2 b_ r2 \\<and>\n           executionally_equivalent e1 s1' (evaluate_updates t1 b_ r1) e2\n            s2' (evaluate_updates t2 b_ r2)\n            (map (\\<lambda>(l, i, o). (l, i)) t);\n     accepts_trace e1 s1 r1 ((la_, b_, c_) # t);\n     (aa, b) |\\<in>| possible_steps e1 s1 r1 la_ b_;\n     evaluate_outputs b b_ r1 = map Some c_;\n     accepts_trace e1 aa (evaluate_updates b b_ r1) t;\n     \\<exists>(s2', t2)|\\<in>|possible_steps e2 s2 r2 la_ b_.\n        map Some c_ = evaluate_outputs t2 b_ r2 \\<and>\n        executionally_equivalent e1 aa (evaluate_updates b b_ r1) e2 s2'\n         (evaluate_updates t2 b_ r2)\n         (map (\\<lambda>(l, i, o). (l, i)) t)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>(s', T)|\\<in>|possible_steps e2 s2 r2 la_ b_.\n                         evaluate_outputs T b_ r2 = map Some c_ \\<and>\n                         accepts_trace e2 s' (evaluate_updates T b_ r2) t", "by fastforce"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  accepts_trace e2 s2 r2 (a # t) = accepts_trace e1 s1 r1 (a # t)\n\ngoal (1 subgoal):\n 1. \\<And>s1 s2 r1 r2.\n       executionally_equivalent e1 s1 r1 e2 s2 r2\n        (map (\\<lambda>(l, i, o). (l, i)) []) \\<Longrightarrow>\n       accepts_trace e2 s2 r2 [] = accepts_trace e1 s1 r1 []", "qed auto"], ["", "lemma executionally_equivalent_acceptance:\n  \"\\<forall>x. executionally_equivalent e1 s1 r1 e2 s2 r2 x \\<Longrightarrow> accepts_trace e1 s1 r1  t \\<Longrightarrow> accepts_trace e2 s2 r2 t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>x. executionally_equivalent e1 s1 r1 e2 s2 r2 x;\n     accepts_trace e1 s1 r1 t\\<rbrakk>\n    \\<Longrightarrow> accepts_trace e2 s2 r2 t", "using executionally_equivalent_acceptance_map"], ["proof (prove)\nusing this:\n  executionally_equivalent ?e1.0 ?s1.0 ?r1.0 ?e2.0 ?s2.0 ?r2.0\n   (map (\\<lambda>(l, i, o). (l, i)) ?t) \\<Longrightarrow>\n  accepts_trace ?e2.0 ?s2.0 ?r2.0 ?t = accepts_trace ?e1.0 ?s1.0 ?r1.0 ?t\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>x. executionally_equivalent e1 s1 r1 e2 s2 r2 x;\n     accepts_trace e1 s1 r1 t\\<rbrakk>\n    \\<Longrightarrow> accepts_trace e2 s2 r2 t", "by blast"], ["", "lemma executionally_equivalent_trace_equivalent:\n  \"\\<forall>x. executionally_equivalent e1 0 <> e2 0 <> x \\<Longrightarrow> trace_equivalent e1 e2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. executionally_equivalent e1 0 <> e2 0 <> x \\<Longrightarrow>\n    trace_equivalent e1 e2", "apply (rule trace_equivalent)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. executionally_equivalent e1 0 <> e2 0 <> x \\<Longrightarrow>\n    \\<forall>t. accepts_trace e1 0 <> t = accepts_trace e2 0 <> t", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>t.\n       \\<forall>x.\n          executionally_equivalent e1 0 <> e2 0 <> x \\<Longrightarrow>\n       accepts_trace e1 0 <> t = accepts_trace e2 0 <> t", "subgoal for t"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. executionally_equivalent e1 0 <> e2 0 <> x \\<Longrightarrow>\n    accepts_trace e1 0 <> t = accepts_trace e2 0 <> t", "apply (erule_tac x=\"map (\\<lambda>(l, i, o). (l, i)) t\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. executionally_equivalent e1 0 <> e2 0 <>\n     (map (\\<lambda>(l, i, o). (l, i)) t) \\<Longrightarrow>\n    accepts_trace e1 0 <> t = accepts_trace e2 0 <> t", "by (simp add: executionally_equivalent_acceptance_map)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma executionally_equivalent_symmetry:\n  \"executionally_equivalent e1 s1 r1 e2 s2 r2 x \\<Longrightarrow>\n   executionally_equivalent e2 s2 r2 e1 s1 r1 x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. executionally_equivalent e1 s1 r1 e2 s2 r2 x \\<Longrightarrow>\n    executionally_equivalent e2 s2 r2 e1 s1 r1 x", "proof(induct x arbitrary: s1 s2 r1 r2)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s1 s2 r1 r2.\n       executionally_equivalent e1 s1 r1 e2 s2 r2 [] \\<Longrightarrow>\n       executionally_equivalent e2 s2 r2 e1 s1 r1 []\n 2. \\<And>a x s1 s2 r1 r2.\n       \\<lbrakk>\\<And>s1 s2 r1 r2.\n                   executionally_equivalent e1 s1 r1 e2 s2 r2\n                    x \\<Longrightarrow>\n                   executionally_equivalent e2 s2 r2 e1 s1 r1 x;\n        executionally_equivalent e1 s1 r1 e2 s2 r2 (a # x)\\<rbrakk>\n       \\<Longrightarrow> executionally_equivalent e2 s2 r2 e1 s1 r1 (a # x)", "case (Cons a x)"], ["proof (state)\nthis:\n  executionally_equivalent e1 ?s1.0 ?r1.0 e2 ?s2.0 ?r2.0 x \\<Longrightarrow>\n  executionally_equivalent e2 ?s2.0 ?r2.0 e1 ?s1.0 ?r1.0 x\n  executionally_equivalent e1 s1 r1 e2 s2 r2 (a # x)\n\ngoal (2 subgoals):\n 1. \\<And>s1 s2 r1 r2.\n       executionally_equivalent e1 s1 r1 e2 s2 r2 [] \\<Longrightarrow>\n       executionally_equivalent e2 s2 r2 e1 s1 r1 []\n 2. \\<And>a x s1 s2 r1 r2.\n       \\<lbrakk>\\<And>s1 s2 r1 r2.\n                   executionally_equivalent e1 s1 r1 e2 s2 r2\n                    x \\<Longrightarrow>\n                   executionally_equivalent e2 s2 r2 e1 s1 r1 x;\n        executionally_equivalent e1 s1 r1 e2 s2 r2 (a # x)\\<rbrakk>\n       \\<Longrightarrow> executionally_equivalent e2 s2 r2 e1 s1 r1 (a # x)", "then"], ["proof (chain)\npicking this:\n  executionally_equivalent e1 ?s1.0 ?r1.0 e2 ?s2.0 ?r2.0 x \\<Longrightarrow>\n  executionally_equivalent e2 ?s2.0 ?r2.0 e1 ?s1.0 ?r1.0 x\n  executionally_equivalent e1 s1 r1 e2 s2 r2 (a # x)", "show ?case"], ["proof (prove)\nusing this:\n  executionally_equivalent e1 ?s1.0 ?r1.0 e2 ?s2.0 ?r2.0 x \\<Longrightarrow>\n  executionally_equivalent e2 ?s2.0 ?r2.0 e1 ?s1.0 ?r1.0 x\n  executionally_equivalent e1 s1 r1 e2 s2 r2 (a # x)\n\ngoal (1 subgoal):\n 1. executionally_equivalent e2 s2 r2 e1 s1 r1 (a # x)", "apply (cases a, clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b.\n       \\<lbrakk>executionally_equivalent e1 s1 r1 e2 s2 r2 ((aa, b) # x);\n        a = (aa, b);\n        \\<And>s1 r1 s2 r2.\n           executionally_equivalent e1 s1 r1 e2 s2 r2 x \\<Longrightarrow>\n           executionally_equivalent e2 s2 r2 e1 s1 r1 x\\<rbrakk>\n       \\<Longrightarrow> executionally_equivalent e2 s2 r2 e1 s1 r1\n                          ((aa, b) # x)", "apply (simp add: executionally_equivalent_step)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b.\n       \\<lbrakk>(\\<forall>(s1', t1)|\\<in>|possible_steps e1 s1 r1 aa b.\n                    \\<exists>(s2', t2)|\\<in>|possible_steps e2 s2 r2 aa b.\n                       evaluate_outputs t1 b r1 =\n                       evaluate_outputs t2 b r2 \\<and>\n                       executionally_equivalent e1 s1'\n                        (evaluate_updates t1 b r1) e2 s2'\n                        (evaluate_updates t2 b r2) x) \\<and>\n                (\\<forall>(s2', t2)|\\<in>|possible_steps e2 s2 r2 aa b.\n                    \\<exists>(s1', t1)|\\<in>|possible_steps e1 s1 r1 aa b.\n                       evaluate_outputs t1 b r1 =\n                       evaluate_outputs t2 b r2 \\<and>\n                       executionally_equivalent e1 s1'\n                        (evaluate_updates t1 b r1) e2 s2'\n                        (evaluate_updates t2 b r2) x);\n        a = (aa, b);\n        \\<And>s1 r1 s2 r2.\n           executionally_equivalent e1 s1 r1 e2 s2 r2 x \\<Longrightarrow>\n           executionally_equivalent e2 s2 r2 e1 s1 r1 x\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>(s1', t1)\n                                   |\\<in>|possible_steps e2 s2 r2 aa b.\n                             \\<exists>(s2', t2)\n|\\<in>|possible_steps e1 s1 r1 aa b.\n                                evaluate_outputs t1 b r2 =\n                                evaluate_outputs t2 b r1 \\<and>\n                                executionally_equivalent e2 s1'\n                                 (evaluate_updates t1 b r2) e1 s2'\n                                 (evaluate_updates t2 b r1) x) \\<and>\n                         (\\<forall>(s2', t2)\n                                   |\\<in>|possible_steps e1 s1 r1 aa b.\n                             \\<exists>(s1', t1)\n|\\<in>|possible_steps e2 s2 r2 aa b.\n                                evaluate_outputs t1 b r2 =\n                                evaluate_outputs t2 b r1 \\<and>\n                                executionally_equivalent e2 s1'\n                                 (evaluate_updates t1 b r2) e1 s2'\n                                 (evaluate_updates t2 b r1) x)", "apply standard"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa b.\n       \\<lbrakk>(\\<forall>(s1', t1)|\\<in>|possible_steps e1 s1 r1 aa b.\n                    \\<exists>(s2', t2)|\\<in>|possible_steps e2 s2 r2 aa b.\n                       evaluate_outputs t1 b r1 =\n                       evaluate_outputs t2 b r2 \\<and>\n                       executionally_equivalent e1 s1'\n                        (evaluate_updates t1 b r1) e2 s2'\n                        (evaluate_updates t2 b r2) x) \\<and>\n                (\\<forall>(s2', t2)|\\<in>|possible_steps e2 s2 r2 aa b.\n                    \\<exists>(s1', t1)|\\<in>|possible_steps e1 s1 r1 aa b.\n                       evaluate_outputs t1 b r1 =\n                       evaluate_outputs t2 b r2 \\<and>\n                       executionally_equivalent e1 s1'\n                        (evaluate_updates t1 b r1) e2 s2'\n                        (evaluate_updates t2 b r2) x);\n        a = (aa, b);\n        \\<And>s1 r1 s2 r2.\n           executionally_equivalent e1 s1 r1 e2 s2 r2 x \\<Longrightarrow>\n           executionally_equivalent e2 s2 r2 e1 s1 r1 x\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(s1', t1)\n                                  |\\<in>|possible_steps e2 s2 r2 aa b.\n                            \\<exists>(s2', t2)\n                                     |\\<in>|possible_steps e1 s1 r1 aa b.\n                               evaluate_outputs t1 b r2 =\n                               evaluate_outputs t2 b r1 \\<and>\n                               executionally_equivalent e2 s1'\n                                (evaluate_updates t1 b r2) e1 s2'\n                                (evaluate_updates t2 b r1) x\n 2. \\<And>aa b.\n       \\<lbrakk>(\\<forall>(s1', t1)|\\<in>|possible_steps e1 s1 r1 aa b.\n                    \\<exists>(s2', t2)|\\<in>|possible_steps e2 s2 r2 aa b.\n                       evaluate_outputs t1 b r1 =\n                       evaluate_outputs t2 b r2 \\<and>\n                       executionally_equivalent e1 s1'\n                        (evaluate_updates t1 b r1) e2 s2'\n                        (evaluate_updates t2 b r2) x) \\<and>\n                (\\<forall>(s2', t2)|\\<in>|possible_steps e2 s2 r2 aa b.\n                    \\<exists>(s1', t1)|\\<in>|possible_steps e1 s1 r1 aa b.\n                       evaluate_outputs t1 b r1 =\n                       evaluate_outputs t2 b r2 \\<and>\n                       executionally_equivalent e1 s1'\n                        (evaluate_updates t1 b r1) e2 s2'\n                        (evaluate_updates t2 b r2) x);\n        a = (aa, b);\n        \\<And>s1 r1 s2 r2.\n           executionally_equivalent e1 s1 r1 e2 s2 r2 x \\<Longrightarrow>\n           executionally_equivalent e2 s2 r2 e1 s1 r1 x\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(s2', t2)\n                                  |\\<in>|possible_steps e1 s1 r1 aa b.\n                            \\<exists>(s1', t1)\n                                     |\\<in>|possible_steps e2 s2 r2 aa b.\n                               evaluate_outputs t1 b r2 =\n                               evaluate_outputs t2 b r1 \\<and>\n                               executionally_equivalent e2 s1'\n                                (evaluate_updates t1 b r2) e1 s2'\n                                (evaluate_updates t2 b r1) x", "apply (rule fBallI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa b x.\n       \\<lbrakk>(\\<forall>(s1', t1)|\\<in>|possible_steps e1 s1 r1 aa b.\n                    \\<exists>(s2', t2)|\\<in>|possible_steps e2 s2 r2 aa b.\n                       evaluate_outputs t1 b r1 =\n                       evaluate_outputs t2 b r2 \\<and>\n                       executionally_equivalent e1 s1'\n                        (evaluate_updates t1 b r1) e2 s2'\n                        (evaluate_updates t2 b r2) x) \\<and>\n                (\\<forall>(s2', t2)|\\<in>|possible_steps e2 s2 r2 aa b.\n                    \\<exists>(s1', t1)|\\<in>|possible_steps e1 s1 r1 aa b.\n                       evaluate_outputs t1 b r1 =\n                       evaluate_outputs t2 b r2 \\<and>\n                       executionally_equivalent e1 s1'\n                        (evaluate_updates t1 b r1) e2 s2'\n                        (evaluate_updates t2 b r2) x);\n        a = (aa, b);\n        \\<And>s1 r1 s2 r2.\n           executionally_equivalent e1 s1 r1 e2 s2 r2 x \\<Longrightarrow>\n           executionally_equivalent e2 s2 r2 e1 s1 r1 x;\n        x |\\<in>| possible_steps e2 s2 r2 aa b\\<rbrakk>\n       \\<Longrightarrow> case x of\n                         (s1', t1) \\<Rightarrow>\n                           \\<exists>(s2', t2)\n                                    |\\<in>|possible_steps e1 s1 r1 aa b.\n                              evaluate_outputs t1 b r2 =\n                              evaluate_outputs t2 b r1 \\<and>\n                              executionally_equivalent e2 s1'\n                               (evaluate_updates t1 b r2) e1 s2'\n                               (evaluate_updates t2 b r1) x\n 2. \\<And>aa b.\n       \\<lbrakk>(\\<forall>(s1', t1)|\\<in>|possible_steps e1 s1 r1 aa b.\n                    \\<exists>(s2', t2)|\\<in>|possible_steps e2 s2 r2 aa b.\n                       evaluate_outputs t1 b r1 =\n                       evaluate_outputs t2 b r2 \\<and>\n                       executionally_equivalent e1 s1'\n                        (evaluate_updates t1 b r1) e2 s2'\n                        (evaluate_updates t2 b r2) x) \\<and>\n                (\\<forall>(s2', t2)|\\<in>|possible_steps e2 s2 r2 aa b.\n                    \\<exists>(s1', t1)|\\<in>|possible_steps e1 s1 r1 aa b.\n                       evaluate_outputs t1 b r1 =\n                       evaluate_outputs t2 b r2 \\<and>\n                       executionally_equivalent e1 s1'\n                        (evaluate_updates t1 b r1) e2 s2'\n                        (evaluate_updates t2 b r2) x);\n        a = (aa, b);\n        \\<And>s1 r1 s2 r2.\n           executionally_equivalent e1 s1 r1 e2 s2 r2 x \\<Longrightarrow>\n           executionally_equivalent e2 s2 r2 e1 s1 r1 x\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(s2', t2)\n                                  |\\<in>|possible_steps e1 s1 r1 aa b.\n                            \\<exists>(s1', t1)\n                                     |\\<in>|possible_steps e2 s2 r2 aa b.\n                               evaluate_outputs t1 b r2 =\n                               evaluate_outputs t2 b r1 \\<and>\n                               executionally_equivalent e2 s1'\n                                (evaluate_updates t1 b r2) e1 s2'\n                                (evaluate_updates t2 b r1) x", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa b aaa ba.\n       \\<lbrakk>a = (aa, b);\n        \\<And>s1 r1 s2 r2.\n           executionally_equivalent e1 s1 r1 e2 s2 r2 x \\<Longrightarrow>\n           executionally_equivalent e2 s2 r2 e1 s1 r1 x;\n        (aaa, ba) |\\<in>| possible_steps e2 s2 r2 aa b;\n        \\<forall>(s1', t1)|\\<in>|possible_steps e1 s1 r1 aa b.\n           \\<exists>(s2', t2)|\\<in>|possible_steps e2 s2 r2 aa b.\n              evaluate_outputs t1 b r1 = evaluate_outputs t2 b r2 \\<and>\n              executionally_equivalent e1 s1' (evaluate_updates t1 b r1) e2\n               s2' (evaluate_updates t2 b r2) x;\n        \\<forall>(s2', t2)|\\<in>|possible_steps e2 s2 r2 aa b.\n           \\<exists>(s1', t1)|\\<in>|possible_steps e1 s1 r1 aa b.\n              evaluate_outputs t1 b r1 = evaluate_outputs t2 b r2 \\<and>\n              executionally_equivalent e1 s1' (evaluate_updates t1 b r1) e2\n               s2' (evaluate_updates t2 b r2) x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>(s2', t2)\n                                  |\\<in>|possible_steps e1 s1 r1 aa b.\n                            evaluate_outputs ba b r2 =\n                            evaluate_outputs t2 b r1 \\<and>\n                            executionally_equivalent e2 aaa\n                             (evaluate_updates ba b r2) e1 s2'\n                             (evaluate_updates t2 b r1) x\n 2. \\<And>aa b.\n       \\<lbrakk>(\\<forall>(s1', t1)|\\<in>|possible_steps e1 s1 r1 aa b.\n                    \\<exists>(s2', t2)|\\<in>|possible_steps e2 s2 r2 aa b.\n                       evaluate_outputs t1 b r1 =\n                       evaluate_outputs t2 b r2 \\<and>\n                       executionally_equivalent e1 s1'\n                        (evaluate_updates t1 b r1) e2 s2'\n                        (evaluate_updates t2 b r2) x) \\<and>\n                (\\<forall>(s2', t2)|\\<in>|possible_steps e2 s2 r2 aa b.\n                    \\<exists>(s1', t1)|\\<in>|possible_steps e1 s1 r1 aa b.\n                       evaluate_outputs t1 b r1 =\n                       evaluate_outputs t2 b r2 \\<and>\n                       executionally_equivalent e1 s1'\n                        (evaluate_updates t1 b r1) e2 s2'\n                        (evaluate_updates t2 b r2) x);\n        a = (aa, b);\n        \\<And>s1 r1 s2 r2.\n           executionally_equivalent e1 s1 r1 e2 s2 r2 x \\<Longrightarrow>\n           executionally_equivalent e2 s2 r2 e1 s1 r1 x\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(s2', t2)\n                                  |\\<in>|possible_steps e1 s1 r1 aa b.\n                            \\<exists>(s1', t1)\n                                     |\\<in>|possible_steps e2 s2 r2 aa b.\n                               evaluate_outputs t1 b r2 =\n                               evaluate_outputs t2 b r1 \\<and>\n                               executionally_equivalent e2 s1'\n                                (evaluate_updates t1 b r2) e1 s2'\n                                (evaluate_updates t2 b r1) x", "subgoal for aa b aaa ba"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a = (aa, b);\n     \\<And>s1 r1 s2 r2.\n        executionally_equivalent e1 s1 r1 e2 s2 r2 x \\<Longrightarrow>\n        executionally_equivalent e2 s2 r2 e1 s1 r1 x;\n     (aaa, ba) |\\<in>| possible_steps e2 s2 r2 aa b;\n     \\<forall>(s1', t1)|\\<in>|possible_steps e1 s1 r1 aa b.\n        \\<exists>(s2', t2)|\\<in>|possible_steps e2 s2 r2 aa b.\n           evaluate_outputs t1 b r1 = evaluate_outputs t2 b r2 \\<and>\n           executionally_equivalent e1 s1' (evaluate_updates t1 b r1) e2 s2'\n            (evaluate_updates t2 b r2) x;\n     \\<forall>(s2', t2)|\\<in>|possible_steps e2 s2 r2 aa b.\n        \\<exists>(s1', t1)|\\<in>|possible_steps e1 s1 r1 aa b.\n           evaluate_outputs t1 b r1 = evaluate_outputs t2 b r2 \\<and>\n           executionally_equivalent e1 s1' (evaluate_updates t1 b r1) e2 s2'\n            (evaluate_updates t2 b r2) x\\<rbrakk>\n    \\<Longrightarrow> \\<exists>(s2', t2)|\\<in>|possible_steps e1 s1 r1 aa b.\n                         evaluate_outputs ba b r2 =\n                         evaluate_outputs t2 b r1 \\<and>\n                         executionally_equivalent e2 aaa\n                          (evaluate_updates ba b r2) e1 s2'\n                          (evaluate_updates t2 b r1) x", "apply (erule_tac x=\"(aaa, ba)\" in fBallE[of \"possible_steps e2 s2 r2 aa b\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>a = (aa, b);\n     \\<And>s1 r1 s2 r2.\n        executionally_equivalent e1 s1 r1 e2 s2 r2 x \\<Longrightarrow>\n        executionally_equivalent e2 s2 r2 e1 s1 r1 x;\n     (aaa, ba) |\\<in>| possible_steps e2 s2 r2 aa b;\n     \\<forall>(s1', t1)|\\<in>|possible_steps e1 s1 r1 aa b.\n        \\<exists>(s2', t2)|\\<in>|possible_steps e2 s2 r2 aa b.\n           evaluate_outputs t1 b r1 = evaluate_outputs t2 b r2 \\<and>\n           executionally_equivalent e1 s1' (evaluate_updates t1 b r1) e2 s2'\n            (evaluate_updates t2 b r2) x;\n     case (aaa, ba) of\n     (s2', t2) \\<Rightarrow>\n       \\<exists>(s1', t1)|\\<in>|possible_steps e1 s1 r1 aa b.\n          evaluate_outputs t1 b r1 = evaluate_outputs t2 b r2 \\<and>\n          executionally_equivalent e1 s1' (evaluate_updates t1 b r1) e2 s2'\n           (evaluate_updates t2 b r2) x\\<rbrakk>\n    \\<Longrightarrow> \\<exists>(s2', t2)|\\<in>|possible_steps e1 s1 r1 aa b.\n                         evaluate_outputs ba b r2 =\n                         evaluate_outputs t2 b r1 \\<and>\n                         executionally_equivalent e2 aaa\n                          (evaluate_updates ba b r2) e1 s2'\n                          (evaluate_updates t2 b r1) x\n 2. \\<lbrakk>a = (aa, b);\n     \\<And>s1 r1 s2 r2.\n        executionally_equivalent e1 s1 r1 e2 s2 r2 x \\<Longrightarrow>\n        executionally_equivalent e2 s2 r2 e1 s1 r1 x;\n     (aaa, ba) |\\<in>| possible_steps e2 s2 r2 aa b;\n     \\<forall>(s1', t1)|\\<in>|possible_steps e1 s1 r1 aa b.\n        \\<exists>(s2', t2)|\\<in>|possible_steps e2 s2 r2 aa b.\n           evaluate_outputs t1 b r1 = evaluate_outputs t2 b r2 \\<and>\n           executionally_equivalent e1 s1' (evaluate_updates t1 b r1) e2 s2'\n            (evaluate_updates t2 b r2) x;\n     (aaa, ba) |\\<notin>| possible_steps e2 s2 r2 aa b\\<rbrakk>\n    \\<Longrightarrow> \\<exists>(s2', t2)|\\<in>|possible_steps e1 s1 r1 aa b.\n                         evaluate_outputs ba b r2 =\n                         evaluate_outputs t2 b r1 \\<and>\n                         executionally_equivalent e2 aaa\n                          (evaluate_updates ba b r2) e1 s2'\n                          (evaluate_updates t2 b r1) x", "by (force, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b.\n       \\<lbrakk>(\\<forall>(s1', t1)|\\<in>|possible_steps e1 s1 r1 aa b.\n                    \\<exists>(s2', t2)|\\<in>|possible_steps e2 s2 r2 aa b.\n                       evaluate_outputs t1 b r1 =\n                       evaluate_outputs t2 b r2 \\<and>\n                       executionally_equivalent e1 s1'\n                        (evaluate_updates t1 b r1) e2 s2'\n                        (evaluate_updates t2 b r2) x) \\<and>\n                (\\<forall>(s2', t2)|\\<in>|possible_steps e2 s2 r2 aa b.\n                    \\<exists>(s1', t1)|\\<in>|possible_steps e1 s1 r1 aa b.\n                       evaluate_outputs t1 b r1 =\n                       evaluate_outputs t2 b r2 \\<and>\n                       executionally_equivalent e1 s1'\n                        (evaluate_updates t1 b r1) e2 s2'\n                        (evaluate_updates t2 b r2) x);\n        a = (aa, b);\n        \\<And>s1 r1 s2 r2.\n           executionally_equivalent e1 s1 r1 e2 s2 r2 x \\<Longrightarrow>\n           executionally_equivalent e2 s2 r2 e1 s1 r1 x\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(s2', t2)\n                                  |\\<in>|possible_steps e1 s1 r1 aa b.\n                            \\<exists>(s1', t1)\n                                     |\\<in>|possible_steps e2 s2 r2 aa b.\n                               evaluate_outputs t1 b r2 =\n                               evaluate_outputs t2 b r1 \\<and>\n                               executionally_equivalent e2 s1'\n                                (evaluate_updates t1 b r2) e1 s2'\n                                (evaluate_updates t2 b r1) x", "apply (rule fBallI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b x.\n       \\<lbrakk>(\\<forall>(s1', t1)|\\<in>|possible_steps e1 s1 r1 aa b.\n                    \\<exists>(s2', t2)|\\<in>|possible_steps e2 s2 r2 aa b.\n                       evaluate_outputs t1 b r1 =\n                       evaluate_outputs t2 b r2 \\<and>\n                       executionally_equivalent e1 s1'\n                        (evaluate_updates t1 b r1) e2 s2'\n                        (evaluate_updates t2 b r2) x) \\<and>\n                (\\<forall>(s2', t2)|\\<in>|possible_steps e2 s2 r2 aa b.\n                    \\<exists>(s1', t1)|\\<in>|possible_steps e1 s1 r1 aa b.\n                       evaluate_outputs t1 b r1 =\n                       evaluate_outputs t2 b r2 \\<and>\n                       executionally_equivalent e1 s1'\n                        (evaluate_updates t1 b r1) e2 s2'\n                        (evaluate_updates t2 b r2) x);\n        a = (aa, b);\n        \\<And>s1 r1 s2 r2.\n           executionally_equivalent e1 s1 r1 e2 s2 r2 x \\<Longrightarrow>\n           executionally_equivalent e2 s2 r2 e1 s1 r1 x;\n        x |\\<in>| possible_steps e1 s1 r1 aa b\\<rbrakk>\n       \\<Longrightarrow> case x of\n                         (s2', t2) \\<Rightarrow>\n                           \\<exists>(s1', t1)\n                                    |\\<in>|possible_steps e2 s2 r2 aa b.\n                              evaluate_outputs t1 b r2 =\n                              evaluate_outputs t2 b r1 \\<and>\n                              executionally_equivalent e2 s1'\n                               (evaluate_updates t1 b r2) e1 s2'\n                               (evaluate_updates t2 b r1) x", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b aaa ba.\n       \\<lbrakk>a = (aa, b);\n        \\<And>s1 r1 s2 r2.\n           executionally_equivalent e1 s1 r1 e2 s2 r2 x \\<Longrightarrow>\n           executionally_equivalent e2 s2 r2 e1 s1 r1 x;\n        (aaa, ba) |\\<in>| possible_steps e1 s1 r1 aa b;\n        \\<forall>(s1', t1)|\\<in>|possible_steps e1 s1 r1 aa b.\n           \\<exists>(s2', t2)|\\<in>|possible_steps e2 s2 r2 aa b.\n              evaluate_outputs t1 b r1 = evaluate_outputs t2 b r2 \\<and>\n              executionally_equivalent e1 s1' (evaluate_updates t1 b r1) e2\n               s2' (evaluate_updates t2 b r2) x;\n        \\<forall>(s2', t2)|\\<in>|possible_steps e2 s2 r2 aa b.\n           \\<exists>(s1', t1)|\\<in>|possible_steps e1 s1 r1 aa b.\n              evaluate_outputs t1 b r1 = evaluate_outputs t2 b r2 \\<and>\n              executionally_equivalent e1 s1' (evaluate_updates t1 b r1) e2\n               s2' (evaluate_updates t2 b r2) x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>(s1', t1)\n                                  |\\<in>|possible_steps e2 s2 r2 aa b.\n                            evaluate_outputs t1 b r2 =\n                            evaluate_outputs ba b r1 \\<and>\n                            executionally_equivalent e2 s1'\n                             (evaluate_updates t1 b r2) e1 aaa\n                             (evaluate_updates ba b r1) x", "subgoal for aa b aaa ba"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a = (aa, b);\n     \\<And>s1 r1 s2 r2.\n        executionally_equivalent e1 s1 r1 e2 s2 r2 x \\<Longrightarrow>\n        executionally_equivalent e2 s2 r2 e1 s1 r1 x;\n     (aaa, ba) |\\<in>| possible_steps e1 s1 r1 aa b;\n     \\<forall>(s1', t1)|\\<in>|possible_steps e1 s1 r1 aa b.\n        \\<exists>(s2', t2)|\\<in>|possible_steps e2 s2 r2 aa b.\n           evaluate_outputs t1 b r1 = evaluate_outputs t2 b r2 \\<and>\n           executionally_equivalent e1 s1' (evaluate_updates t1 b r1) e2 s2'\n            (evaluate_updates t2 b r2) x;\n     \\<forall>(s2', t2)|\\<in>|possible_steps e2 s2 r2 aa b.\n        \\<exists>(s1', t1)|\\<in>|possible_steps e1 s1 r1 aa b.\n           evaluate_outputs t1 b r1 = evaluate_outputs t2 b r2 \\<and>\n           executionally_equivalent e1 s1' (evaluate_updates t1 b r1) e2 s2'\n            (evaluate_updates t2 b r2) x\\<rbrakk>\n    \\<Longrightarrow> \\<exists>(s1', t1)|\\<in>|possible_steps e2 s2 r2 aa b.\n                         evaluate_outputs t1 b r2 =\n                         evaluate_outputs ba b r1 \\<and>\n                         executionally_equivalent e2 s1'\n                          (evaluate_updates t1 b r2) e1 aaa\n                          (evaluate_updates ba b r1) x", "apply (erule_tac x=\"(aaa, ba)\" in fBallE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>a = (aa, b);\n     \\<And>s1 r1 s2 r2.\n        executionally_equivalent e1 s1 r1 e2 s2 r2 x \\<Longrightarrow>\n        executionally_equivalent e2 s2 r2 e1 s1 r1 x;\n     (aaa, ba) |\\<in>| possible_steps e1 s1 r1 aa b;\n     \\<forall>(s2', t2)|\\<in>|possible_steps e2 s2 r2 aa b.\n        \\<exists>(s1', t1)|\\<in>|possible_steps e1 s1 r1 aa b.\n           evaluate_outputs t1 b r1 = evaluate_outputs t2 b r2 \\<and>\n           executionally_equivalent e1 s1' (evaluate_updates t1 b r1) e2 s2'\n            (evaluate_updates t2 b r2) x;\n     case (aaa, ba) of\n     (s1', t1) \\<Rightarrow>\n       \\<exists>(s2', t2)|\\<in>|possible_steps e2 s2 r2 aa b.\n          evaluate_outputs t1 b r1 = evaluate_outputs t2 b r2 \\<and>\n          executionally_equivalent e1 s1' (evaluate_updates t1 b r1) e2 s2'\n           (evaluate_updates t2 b r2) x\\<rbrakk>\n    \\<Longrightarrow> \\<exists>(s1', t1)|\\<in>|possible_steps e2 s2 r2 aa b.\n                         evaluate_outputs t1 b r2 =\n                         evaluate_outputs ba b r1 \\<and>\n                         executionally_equivalent e2 s1'\n                          (evaluate_updates t1 b r2) e1 aaa\n                          (evaluate_updates ba b r1) x\n 2. \\<lbrakk>a = (aa, b);\n     \\<And>s1 r1 s2 r2.\n        executionally_equivalent e1 s1 r1 e2 s2 r2 x \\<Longrightarrow>\n        executionally_equivalent e2 s2 r2 e1 s1 r1 x;\n     (aaa, ba) |\\<in>| possible_steps e1 s1 r1 aa b;\n     \\<forall>(s2', t2)|\\<in>|possible_steps e2 s2 r2 aa b.\n        \\<exists>(s1', t1)|\\<in>|possible_steps e1 s1 r1 aa b.\n           evaluate_outputs t1 b r1 = evaluate_outputs t2 b r2 \\<and>\n           executionally_equivalent e1 s1' (evaluate_updates t1 b r1) e2 s2'\n            (evaluate_updates t2 b r2) x;\n     (aaa, ba) |\\<notin>| possible_steps e1 s1 r1 aa b\\<rbrakk>\n    \\<Longrightarrow> \\<exists>(s1', t1)|\\<in>|possible_steps e2 s2 r2 aa b.\n                         evaluate_outputs t1 b r2 =\n                         evaluate_outputs ba b r1 \\<and>\n                         executionally_equivalent e2 s1'\n                          (evaluate_updates t1 b r2) e1 aaa\n                          (evaluate_updates ba b r1) x", "by (force, simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  executionally_equivalent e2 s2 r2 e1 s1 r1 (a # x)\n\ngoal (1 subgoal):\n 1. \\<And>s1 s2 r1 r2.\n       executionally_equivalent e1 s1 r1 e2 s2 r2 [] \\<Longrightarrow>\n       executionally_equivalent e2 s2 r2 e1 s1 r1 []", "qed auto"], ["", "lemma executionally_equivalent_transitivity:\n  \"executionally_equivalent e1 s1 r1 e2 s2 r2 x \\<Longrightarrow>\n   executionally_equivalent e2 s2 r2 e3 s3 r3 x \\<Longrightarrow>\n   executionally_equivalent e1 s1 r1 e3 s3 r3 x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>executionally_equivalent e1 s1 r1 e2 s2 r2 x;\n     executionally_equivalent e2 s2 r2 e3 s3 r3 x\\<rbrakk>\n    \\<Longrightarrow> executionally_equivalent e1 s1 r1 e3 s3 r3 x", "proof(induct x arbitrary: s1 s2 s3 r1 r2 r3)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s1 s2 s3 r1 r2 r3.\n       \\<lbrakk>executionally_equivalent e1 s1 r1 e2 s2 r2 [];\n        executionally_equivalent e2 s2 r2 e3 s3 r3 []\\<rbrakk>\n       \\<Longrightarrow> executionally_equivalent e1 s1 r1 e3 s3 r3 []\n 2. \\<And>a x s1 s2 s3 r1 r2 r3.\n       \\<lbrakk>\\<And>s1 s2 s3 r1 r2 r3.\n                   \\<lbrakk>executionally_equivalent e1 s1 r1 e2 s2 r2 x;\n                    executionally_equivalent e2 s2 r2 e3 s3 r3 x\\<rbrakk>\n                   \\<Longrightarrow> executionally_equivalent e1 s1 r1 e3 s3\nr3 x;\n        executionally_equivalent e1 s1 r1 e2 s2 r2 (a # x);\n        executionally_equivalent e2 s2 r2 e3 s3 r3 (a # x)\\<rbrakk>\n       \\<Longrightarrow> executionally_equivalent e1 s1 r1 e3 s3 r3 (a # x)", "case (Cons a x)"], ["proof (state)\nthis:\n  \\<lbrakk>executionally_equivalent e1 ?s1.0 ?r1.0 e2 ?s2.0 ?r2.0 x;\n   executionally_equivalent e2 ?s2.0 ?r2.0 e3 ?s3.0 ?r3.0 x\\<rbrakk>\n  \\<Longrightarrow> executionally_equivalent e1 ?s1.0 ?r1.0 e3 ?s3.0 ?r3.0 x\n  executionally_equivalent e1 s1 r1 e2 s2 r2 (a # x)\n  executionally_equivalent e2 s2 r2 e3 s3 r3 (a # x)\n\ngoal (2 subgoals):\n 1. \\<And>s1 s2 s3 r1 r2 r3.\n       \\<lbrakk>executionally_equivalent e1 s1 r1 e2 s2 r2 [];\n        executionally_equivalent e2 s2 r2 e3 s3 r3 []\\<rbrakk>\n       \\<Longrightarrow> executionally_equivalent e1 s1 r1 e3 s3 r3 []\n 2. \\<And>a x s1 s2 s3 r1 r2 r3.\n       \\<lbrakk>\\<And>s1 s2 s3 r1 r2 r3.\n                   \\<lbrakk>executionally_equivalent e1 s1 r1 e2 s2 r2 x;\n                    executionally_equivalent e2 s2 r2 e3 s3 r3 x\\<rbrakk>\n                   \\<Longrightarrow> executionally_equivalent e1 s1 r1 e3 s3\nr3 x;\n        executionally_equivalent e1 s1 r1 e2 s2 r2 (a # x);\n        executionally_equivalent e2 s2 r2 e3 s3 r3 (a # x)\\<rbrakk>\n       \\<Longrightarrow> executionally_equivalent e1 s1 r1 e3 s3 r3 (a # x)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>executionally_equivalent e1 ?s1.0 ?r1.0 e2 ?s2.0 ?r2.0 x;\n   executionally_equivalent e2 ?s2.0 ?r2.0 e3 ?s3.0 ?r3.0 x\\<rbrakk>\n  \\<Longrightarrow> executionally_equivalent e1 ?s1.0 ?r1.0 e3 ?s3.0 ?r3.0 x\n  executionally_equivalent e1 s1 r1 e2 s2 r2 (a # x)\n  executionally_equivalent e2 s2 r2 e3 s3 r3 (a # x)", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>executionally_equivalent e1 ?s1.0 ?r1.0 e2 ?s2.0 ?r2.0 x;\n   executionally_equivalent e2 ?s2.0 ?r2.0 e3 ?s3.0 ?r3.0 x\\<rbrakk>\n  \\<Longrightarrow> executionally_equivalent e1 ?s1.0 ?r1.0 e3 ?s3.0 ?r3.0 x\n  executionally_equivalent e1 s1 r1 e2 s2 r2 (a # x)\n  executionally_equivalent e2 s2 r2 e3 s3 r3 (a # x)\n\ngoal (1 subgoal):\n 1. executionally_equivalent e1 s1 r1 e3 s3 r3 (a # x)", "apply (cases a, clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b.\n       \\<lbrakk>executionally_equivalent e1 s1 r1 e2 s2 r2 ((aa, b) # x);\n        executionally_equivalent e2 s2 r2 e3 s3 r3 ((aa, b) # x);\n        a = (aa, b);\n        \\<And>s1 r1 s2 r2 s3 r3.\n           \\<lbrakk>executionally_equivalent e1 s1 r1 e2 s2 r2 x;\n            executionally_equivalent e2 s2 r2 e3 s3 r3 x\\<rbrakk>\n           \\<Longrightarrow> executionally_equivalent e1 s1 r1 e3 s3 r3\n                              x\\<rbrakk>\n       \\<Longrightarrow> executionally_equivalent e1 s1 r1 e3 s3 r3\n                          ((aa, b) # x)", "apply (simp add: executionally_equivalent_step)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b.\n       \\<lbrakk>(\\<forall>(s1', t1)|\\<in>|possible_steps e1 s1 r1 aa b.\n                    \\<exists>(s2', t2)|\\<in>|possible_steps e2 s2 r2 aa b.\n                       evaluate_outputs t1 b r1 =\n                       evaluate_outputs t2 b r2 \\<and>\n                       executionally_equivalent e1 s1'\n                        (evaluate_updates t1 b r1) e2 s2'\n                        (evaluate_updates t2 b r2) x) \\<and>\n                (\\<forall>(s2', t2)|\\<in>|possible_steps e2 s2 r2 aa b.\n                    \\<exists>(s1', t1)|\\<in>|possible_steps e1 s1 r1 aa b.\n                       evaluate_outputs t1 b r1 =\n                       evaluate_outputs t2 b r2 \\<and>\n                       executionally_equivalent e1 s1'\n                        (evaluate_updates t1 b r1) e2 s2'\n                        (evaluate_updates t2 b r2) x);\n        (\\<forall>(s1', t1)|\\<in>|possible_steps e2 s2 r2 aa b.\n            \\<exists>(s2', t2)|\\<in>|possible_steps e3 s3 r3 aa b.\n               evaluate_outputs t1 b r2 = evaluate_outputs t2 b r3 \\<and>\n               executionally_equivalent e2 s1' (evaluate_updates t1 b r2) e3\n                s2' (evaluate_updates t2 b r3) x) \\<and>\n        (\\<forall>(s2', t2)|\\<in>|possible_steps e3 s3 r3 aa b.\n            \\<exists>(s1', t1)|\\<in>|possible_steps e2 s2 r2 aa b.\n               evaluate_outputs t1 b r2 = evaluate_outputs t2 b r3 \\<and>\n               executionally_equivalent e2 s1' (evaluate_updates t1 b r2) e3\n                s2' (evaluate_updates t2 b r3) x);\n        a = (aa, b);\n        \\<And>s1 r1 s2 r2 s3 r3.\n           \\<lbrakk>executionally_equivalent e1 s1 r1 e2 s2 r2 x;\n            executionally_equivalent e2 s2 r2 e3 s3 r3 x\\<rbrakk>\n           \\<Longrightarrow> executionally_equivalent e1 s1 r1 e3 s3 r3\n                              x\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>(s1', t1)\n                                   |\\<in>|possible_steps e1 s1 r1 aa b.\n                             \\<exists>(s2', t2)\n|\\<in>|possible_steps e3 s3 r3 aa b.\n                                evaluate_outputs t1 b r1 =\n                                evaluate_outputs t2 b r3 \\<and>\n                                executionally_equivalent e1 s1'\n                                 (evaluate_updates t1 b r1) e3 s2'\n                                 (evaluate_updates t2 b r3) x) \\<and>\n                         (\\<forall>(s2', t2)\n                                   |\\<in>|possible_steps e3 s3 r3 aa b.\n                             \\<exists>(s1', t1)\n|\\<in>|possible_steps e1 s1 r1 aa b.\n                                evaluate_outputs t1 b r1 =\n                                evaluate_outputs t2 b r3 \\<and>\n                                executionally_equivalent e1 s1'\n                                 (evaluate_updates t1 b r1) e3 s2'\n                                 (evaluate_updates t2 b r3) x)", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b.\n       \\<lbrakk>a = (aa, b);\n        \\<And>s1 r1 s2 r2 s3 r3.\n           \\<lbrakk>executionally_equivalent e1 s1 r1 e2 s2 r2 x;\n            executionally_equivalent e2 s2 r2 e3 s3 r3 x\\<rbrakk>\n           \\<Longrightarrow> executionally_equivalent e1 s1 r1 e3 s3 r3 x;\n        \\<forall>(s1', t1)|\\<in>|possible_steps e1 s1 r1 aa b.\n           \\<exists>(s2', t2)|\\<in>|possible_steps e2 s2 r2 aa b.\n              evaluate_outputs t1 b r1 = evaluate_outputs t2 b r2 \\<and>\n              executionally_equivalent e1 s1' (evaluate_updates t1 b r1) e2\n               s2' (evaluate_updates t2 b r2) x;\n        \\<forall>(s2', t2)|\\<in>|possible_steps e2 s2 r2 aa b.\n           \\<exists>(s1', t1)|\\<in>|possible_steps e1 s1 r1 aa b.\n              evaluate_outputs t1 b r1 = evaluate_outputs t2 b r2 \\<and>\n              executionally_equivalent e1 s1' (evaluate_updates t1 b r1) e2\n               s2' (evaluate_updates t2 b r2) x;\n        \\<forall>(s1', t1)|\\<in>|possible_steps e2 s2 r2 aa b.\n           \\<exists>(s2', t2)|\\<in>|possible_steps e3 s3 r3 aa b.\n              evaluate_outputs t1 b r2 = evaluate_outputs t2 b r3 \\<and>\n              executionally_equivalent e2 s1' (evaluate_updates t1 b r2) e3\n               s2' (evaluate_updates t2 b r3) x;\n        \\<forall>(s2', t2)|\\<in>|possible_steps e3 s3 r3 aa b.\n           \\<exists>(s1', t1)|\\<in>|possible_steps e2 s2 r2 aa b.\n              evaluate_outputs t1 b r2 = evaluate_outputs t2 b r3 \\<and>\n              executionally_equivalent e2 s1' (evaluate_updates t1 b r2) e3\n               s2' (evaluate_updates t2 b r3) x\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>(s1', t1)\n                                   |\\<in>|possible_steps e1 s1 r1 aa b.\n                             \\<exists>(s2', t2)\n|\\<in>|possible_steps e3 s3 r3 aa b.\n                                evaluate_outputs t1 b r1 =\n                                evaluate_outputs t2 b r3 \\<and>\n                                executionally_equivalent e1 s1'\n                                 (evaluate_updates t1 b r1) e3 s2'\n                                 (evaluate_updates t2 b r3) x) \\<and>\n                         (\\<forall>(s2', t2)\n                                   |\\<in>|possible_steps e3 s3 r3 aa b.\n                             \\<exists>(s1', t1)\n|\\<in>|possible_steps e1 s1 r1 aa b.\n                                evaluate_outputs t1 b r1 =\n                                evaluate_outputs t2 b r3 \\<and>\n                                executionally_equivalent e1 s1'\n                                 (evaluate_updates t1 b r1) e3 s2'\n                                 (evaluate_updates t2 b r3) x)", "apply standard"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa b.\n       \\<lbrakk>a = (aa, b);\n        \\<And>s1 r1 s2 r2 s3 r3.\n           \\<lbrakk>executionally_equivalent e1 s1 r1 e2 s2 r2 x;\n            executionally_equivalent e2 s2 r2 e3 s3 r3 x\\<rbrakk>\n           \\<Longrightarrow> executionally_equivalent e1 s1 r1 e3 s3 r3 x;\n        \\<forall>(s1', t1)|\\<in>|possible_steps e1 s1 r1 aa b.\n           \\<exists>(s2', t2)|\\<in>|possible_steps e2 s2 r2 aa b.\n              evaluate_outputs t1 b r1 = evaluate_outputs t2 b r2 \\<and>\n              executionally_equivalent e1 s1' (evaluate_updates t1 b r1) e2\n               s2' (evaluate_updates t2 b r2) x;\n        \\<forall>(s2', t2)|\\<in>|possible_steps e2 s2 r2 aa b.\n           \\<exists>(s1', t1)|\\<in>|possible_steps e1 s1 r1 aa b.\n              evaluate_outputs t1 b r1 = evaluate_outputs t2 b r2 \\<and>\n              executionally_equivalent e1 s1' (evaluate_updates t1 b r1) e2\n               s2' (evaluate_updates t2 b r2) x;\n        \\<forall>(s1', t1)|\\<in>|possible_steps e2 s2 r2 aa b.\n           \\<exists>(s2', t2)|\\<in>|possible_steps e3 s3 r3 aa b.\n              evaluate_outputs t1 b r2 = evaluate_outputs t2 b r3 \\<and>\n              executionally_equivalent e2 s1' (evaluate_updates t1 b r2) e3\n               s2' (evaluate_updates t2 b r3) x;\n        \\<forall>(s2', t2)|\\<in>|possible_steps e3 s3 r3 aa b.\n           \\<exists>(s1', t1)|\\<in>|possible_steps e2 s2 r2 aa b.\n              evaluate_outputs t1 b r2 = evaluate_outputs t2 b r3 \\<and>\n              executionally_equivalent e2 s1' (evaluate_updates t1 b r2) e3\n               s2' (evaluate_updates t2 b r3) x\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(s1', t1)\n                                  |\\<in>|possible_steps e1 s1 r1 aa b.\n                            \\<exists>(s2', t2)\n                                     |\\<in>|possible_steps e3 s3 r3 aa b.\n                               evaluate_outputs t1 b r1 =\n                               evaluate_outputs t2 b r3 \\<and>\n                               executionally_equivalent e1 s1'\n                                (evaluate_updates t1 b r1) e3 s2'\n                                (evaluate_updates t2 b r3) x\n 2. \\<And>aa b.\n       \\<lbrakk>a = (aa, b);\n        \\<And>s1 r1 s2 r2 s3 r3.\n           \\<lbrakk>executionally_equivalent e1 s1 r1 e2 s2 r2 x;\n            executionally_equivalent e2 s2 r2 e3 s3 r3 x\\<rbrakk>\n           \\<Longrightarrow> executionally_equivalent e1 s1 r1 e3 s3 r3 x;\n        \\<forall>(s1', t1)|\\<in>|possible_steps e1 s1 r1 aa b.\n           \\<exists>(s2', t2)|\\<in>|possible_steps e2 s2 r2 aa b.\n              evaluate_outputs t1 b r1 = evaluate_outputs t2 b r2 \\<and>\n              executionally_equivalent e1 s1' (evaluate_updates t1 b r1) e2\n               s2' (evaluate_updates t2 b r2) x;\n        \\<forall>(s2', t2)|\\<in>|possible_steps e2 s2 r2 aa b.\n           \\<exists>(s1', t1)|\\<in>|possible_steps e1 s1 r1 aa b.\n              evaluate_outputs t1 b r1 = evaluate_outputs t2 b r2 \\<and>\n              executionally_equivalent e1 s1' (evaluate_updates t1 b r1) e2\n               s2' (evaluate_updates t2 b r2) x;\n        \\<forall>(s1', t1)|\\<in>|possible_steps e2 s2 r2 aa b.\n           \\<exists>(s2', t2)|\\<in>|possible_steps e3 s3 r3 aa b.\n              evaluate_outputs t1 b r2 = evaluate_outputs t2 b r3 \\<and>\n              executionally_equivalent e2 s1' (evaluate_updates t1 b r2) e3\n               s2' (evaluate_updates t2 b r3) x;\n        \\<forall>(s2', t2)|\\<in>|possible_steps e3 s3 r3 aa b.\n           \\<exists>(s1', t1)|\\<in>|possible_steps e2 s2 r2 aa b.\n              evaluate_outputs t1 b r2 = evaluate_outputs t2 b r3 \\<and>\n              executionally_equivalent e2 s1' (evaluate_updates t1 b r2) e3\n               s2' (evaluate_updates t2 b r3) x\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(s2', t2)\n                                  |\\<in>|possible_steps e3 s3 r3 aa b.\n                            \\<exists>(s1', t1)\n                                     |\\<in>|possible_steps e1 s1 r1 aa b.\n                               evaluate_outputs t1 b r1 =\n                               evaluate_outputs t2 b r3 \\<and>\n                               executionally_equivalent e1 s1'\n                                (evaluate_updates t1 b r1) e3 s2'\n                                (evaluate_updates t2 b r3) x", "apply (rule fBallI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa b x.\n       \\<lbrakk>a = (aa, b);\n        \\<And>s1 r1 s2 r2 s3 r3.\n           \\<lbrakk>executionally_equivalent e1 s1 r1 e2 s2 r2 x;\n            executionally_equivalent e2 s2 r2 e3 s3 r3 x\\<rbrakk>\n           \\<Longrightarrow> executionally_equivalent e1 s1 r1 e3 s3 r3 x;\n        \\<forall>(s1', t1)|\\<in>|possible_steps e1 s1 r1 aa b.\n           \\<exists>(s2', t2)|\\<in>|possible_steps e2 s2 r2 aa b.\n              evaluate_outputs t1 b r1 = evaluate_outputs t2 b r2 \\<and>\n              executionally_equivalent e1 s1' (evaluate_updates t1 b r1) e2\n               s2' (evaluate_updates t2 b r2) x;\n        \\<forall>(s2', t2)|\\<in>|possible_steps e2 s2 r2 aa b.\n           \\<exists>(s1', t1)|\\<in>|possible_steps e1 s1 r1 aa b.\n              evaluate_outputs t1 b r1 = evaluate_outputs t2 b r2 \\<and>\n              executionally_equivalent e1 s1' (evaluate_updates t1 b r1) e2\n               s2' (evaluate_updates t2 b r2) x;\n        \\<forall>(s1', t1)|\\<in>|possible_steps e2 s2 r2 aa b.\n           \\<exists>(s2', t2)|\\<in>|possible_steps e3 s3 r3 aa b.\n              evaluate_outputs t1 b r2 = evaluate_outputs t2 b r3 \\<and>\n              executionally_equivalent e2 s1' (evaluate_updates t1 b r2) e3\n               s2' (evaluate_updates t2 b r3) x;\n        \\<forall>(s2', t2)|\\<in>|possible_steps e3 s3 r3 aa b.\n           \\<exists>(s1', t1)|\\<in>|possible_steps e2 s2 r2 aa b.\n              evaluate_outputs t1 b r2 = evaluate_outputs t2 b r3 \\<and>\n              executionally_equivalent e2 s1' (evaluate_updates t1 b r2) e3\n               s2' (evaluate_updates t2 b r3) x;\n        x |\\<in>| possible_steps e1 s1 r1 aa b\\<rbrakk>\n       \\<Longrightarrow> case x of\n                         (s1', t1) \\<Rightarrow>\n                           \\<exists>(s2', t2)\n                                    |\\<in>|possible_steps e3 s3 r3 aa b.\n                              evaluate_outputs t1 b r1 =\n                              evaluate_outputs t2 b r3 \\<and>\n                              executionally_equivalent e1 s1'\n                               (evaluate_updates t1 b r1) e3 s2'\n                               (evaluate_updates t2 b r3) x\n 2. \\<And>aa b.\n       \\<lbrakk>a = (aa, b);\n        \\<And>s1 r1 s2 r2 s3 r3.\n           \\<lbrakk>executionally_equivalent e1 s1 r1 e2 s2 r2 x;\n            executionally_equivalent e2 s2 r2 e3 s3 r3 x\\<rbrakk>\n           \\<Longrightarrow> executionally_equivalent e1 s1 r1 e3 s3 r3 x;\n        \\<forall>(s1', t1)|\\<in>|possible_steps e1 s1 r1 aa b.\n           \\<exists>(s2', t2)|\\<in>|possible_steps e2 s2 r2 aa b.\n              evaluate_outputs t1 b r1 = evaluate_outputs t2 b r2 \\<and>\n              executionally_equivalent e1 s1' (evaluate_updates t1 b r1) e2\n               s2' (evaluate_updates t2 b r2) x;\n        \\<forall>(s2', t2)|\\<in>|possible_steps e2 s2 r2 aa b.\n           \\<exists>(s1', t1)|\\<in>|possible_steps e1 s1 r1 aa b.\n              evaluate_outputs t1 b r1 = evaluate_outputs t2 b r2 \\<and>\n              executionally_equivalent e1 s1' (evaluate_updates t1 b r1) e2\n               s2' (evaluate_updates t2 b r2) x;\n        \\<forall>(s1', t1)|\\<in>|possible_steps e2 s2 r2 aa b.\n           \\<exists>(s2', t2)|\\<in>|possible_steps e3 s3 r3 aa b.\n              evaluate_outputs t1 b r2 = evaluate_outputs t2 b r3 \\<and>\n              executionally_equivalent e2 s1' (evaluate_updates t1 b r2) e3\n               s2' (evaluate_updates t2 b r3) x;\n        \\<forall>(s2', t2)|\\<in>|possible_steps e3 s3 r3 aa b.\n           \\<exists>(s1', t1)|\\<in>|possible_steps e2 s2 r2 aa b.\n              evaluate_outputs t1 b r2 = evaluate_outputs t2 b r3 \\<and>\n              executionally_equivalent e2 s1' (evaluate_updates t1 b r2) e3\n               s2' (evaluate_updates t2 b r3) x\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(s2', t2)\n                                  |\\<in>|possible_steps e3 s3 r3 aa b.\n                            \\<exists>(s1', t1)\n                                     |\\<in>|possible_steps e1 s1 r1 aa b.\n                               evaluate_outputs t1 b r1 =\n                               evaluate_outputs t2 b r3 \\<and>\n                               executionally_equivalent e1 s1'\n                                (evaluate_updates t1 b r1) e3 s2'\n                                (evaluate_updates t2 b r3) x", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa b ab ba.\n       \\<lbrakk>a = (aa, b);\n        \\<And>s1 r1 s2 r2 s3 r3.\n           \\<lbrakk>executionally_equivalent e1 s1 r1 e2 s2 r2 x;\n            executionally_equivalent e2 s2 r2 e3 s3 r3 x\\<rbrakk>\n           \\<Longrightarrow> executionally_equivalent e1 s1 r1 e3 s3 r3 x;\n        \\<forall>(s1', t1)|\\<in>|possible_steps e1 s1 r1 aa b.\n           \\<exists>(s2', t2)|\\<in>|possible_steps e2 s2 r2 aa b.\n              evaluate_outputs t1 b r1 = evaluate_outputs t2 b r2 \\<and>\n              executionally_equivalent e1 s1' (evaluate_updates t1 b r1) e2\n               s2' (evaluate_updates t2 b r2) x;\n        \\<forall>(s2', t2)|\\<in>|possible_steps e2 s2 r2 aa b.\n           \\<exists>(s1', t1)|\\<in>|possible_steps e1 s1 r1 aa b.\n              evaluate_outputs t1 b r1 = evaluate_outputs t2 b r2 \\<and>\n              executionally_equivalent e1 s1' (evaluate_updates t1 b r1) e2\n               s2' (evaluate_updates t2 b r2) x;\n        \\<forall>(s1', t1)|\\<in>|possible_steps e2 s2 r2 aa b.\n           \\<exists>(s2', t2)|\\<in>|possible_steps e3 s3 r3 aa b.\n              evaluate_outputs t1 b r2 = evaluate_outputs t2 b r3 \\<and>\n              executionally_equivalent e2 s1' (evaluate_updates t1 b r2) e3\n               s2' (evaluate_updates t2 b r3) x;\n        \\<forall>(s2', t2)|\\<in>|possible_steps e3 s3 r3 aa b.\n           \\<exists>(s1', t1)|\\<in>|possible_steps e2 s2 r2 aa b.\n              evaluate_outputs t1 b r2 = evaluate_outputs t2 b r3 \\<and>\n              executionally_equivalent e2 s1' (evaluate_updates t1 b r2) e3\n               s2' (evaluate_updates t2 b r3) x;\n        (ab, ba) |\\<in>| possible_steps e1 s1 r1 aa b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>(s2', t2)\n                                  |\\<in>|possible_steps e3 s3 r3 aa b.\n                            evaluate_outputs ba b r1 =\n                            evaluate_outputs t2 b r3 \\<and>\n                            executionally_equivalent e1 ab\n                             (evaluate_updates ba b r1) e3 s2'\n                             (evaluate_updates t2 b r3) x\n 2. \\<And>aa b.\n       \\<lbrakk>a = (aa, b);\n        \\<And>s1 r1 s2 r2 s3 r3.\n           \\<lbrakk>executionally_equivalent e1 s1 r1 e2 s2 r2 x;\n            executionally_equivalent e2 s2 r2 e3 s3 r3 x\\<rbrakk>\n           \\<Longrightarrow> executionally_equivalent e1 s1 r1 e3 s3 r3 x;\n        \\<forall>(s1', t1)|\\<in>|possible_steps e1 s1 r1 aa b.\n           \\<exists>(s2', t2)|\\<in>|possible_steps e2 s2 r2 aa b.\n              evaluate_outputs t1 b r1 = evaluate_outputs t2 b r2 \\<and>\n              executionally_equivalent e1 s1' (evaluate_updates t1 b r1) e2\n               s2' (evaluate_updates t2 b r2) x;\n        \\<forall>(s2', t2)|\\<in>|possible_steps e2 s2 r2 aa b.\n           \\<exists>(s1', t1)|\\<in>|possible_steps e1 s1 r1 aa b.\n              evaluate_outputs t1 b r1 = evaluate_outputs t2 b r2 \\<and>\n              executionally_equivalent e1 s1' (evaluate_updates t1 b r1) e2\n               s2' (evaluate_updates t2 b r2) x;\n        \\<forall>(s1', t1)|\\<in>|possible_steps e2 s2 r2 aa b.\n           \\<exists>(s2', t2)|\\<in>|possible_steps e3 s3 r3 aa b.\n              evaluate_outputs t1 b r2 = evaluate_outputs t2 b r3 \\<and>\n              executionally_equivalent e2 s1' (evaluate_updates t1 b r2) e3\n               s2' (evaluate_updates t2 b r3) x;\n        \\<forall>(s2', t2)|\\<in>|possible_steps e3 s3 r3 aa b.\n           \\<exists>(s1', t1)|\\<in>|possible_steps e2 s2 r2 aa b.\n              evaluate_outputs t1 b r2 = evaluate_outputs t2 b r3 \\<and>\n              executionally_equivalent e2 s1' (evaluate_updates t1 b r2) e3\n               s2' (evaluate_updates t2 b r3) x\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(s2', t2)\n                                  |\\<in>|possible_steps e3 s3 r3 aa b.\n                            \\<exists>(s1', t1)\n                                     |\\<in>|possible_steps e1 s1 r1 aa b.\n                               evaluate_outputs t1 b r1 =\n                               evaluate_outputs t2 b r3 \\<and>\n                               executionally_equivalent e1 s1'\n                                (evaluate_updates t1 b r1) e3 s2'\n                                (evaluate_updates t2 b r3) x", "subgoal for aa b ab ba"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a = (aa, b);\n     \\<And>s1 r1 s2 r2 s3 r3.\n        \\<lbrakk>executionally_equivalent e1 s1 r1 e2 s2 r2 x;\n         executionally_equivalent e2 s2 r2 e3 s3 r3 x\\<rbrakk>\n        \\<Longrightarrow> executionally_equivalent e1 s1 r1 e3 s3 r3 x;\n     \\<forall>(s1', t1)|\\<in>|possible_steps e1 s1 r1 aa b.\n        \\<exists>(s2', t2)|\\<in>|possible_steps e2 s2 r2 aa b.\n           evaluate_outputs t1 b r1 = evaluate_outputs t2 b r2 \\<and>\n           executionally_equivalent e1 s1' (evaluate_updates t1 b r1) e2 s2'\n            (evaluate_updates t2 b r2) x;\n     \\<forall>(s2', t2)|\\<in>|possible_steps e2 s2 r2 aa b.\n        \\<exists>(s1', t1)|\\<in>|possible_steps e1 s1 r1 aa b.\n           evaluate_outputs t1 b r1 = evaluate_outputs t2 b r2 \\<and>\n           executionally_equivalent e1 s1' (evaluate_updates t1 b r1) e2 s2'\n            (evaluate_updates t2 b r2) x;\n     \\<forall>(s1', t1)|\\<in>|possible_steps e2 s2 r2 aa b.\n        \\<exists>(s2', t2)|\\<in>|possible_steps e3 s3 r3 aa b.\n           evaluate_outputs t1 b r2 = evaluate_outputs t2 b r3 \\<and>\n           executionally_equivalent e2 s1' (evaluate_updates t1 b r2) e3 s2'\n            (evaluate_updates t2 b r3) x;\n     \\<forall>(s2', t2)|\\<in>|possible_steps e3 s3 r3 aa b.\n        \\<exists>(s1', t1)|\\<in>|possible_steps e2 s2 r2 aa b.\n           evaluate_outputs t1 b r2 = evaluate_outputs t2 b r3 \\<and>\n           executionally_equivalent e2 s1' (evaluate_updates t1 b r2) e3 s2'\n            (evaluate_updates t2 b r3) x;\n     (ab, ba) |\\<in>| possible_steps e1 s1 r1 aa b\\<rbrakk>\n    \\<Longrightarrow> \\<exists>(s2', t2)|\\<in>|possible_steps e3 s3 r3 aa b.\n                         evaluate_outputs ba b r1 =\n                         evaluate_outputs t2 b r3 \\<and>\n                         executionally_equivalent e1 ab\n                          (evaluate_updates ba b r1) e3 s2'\n                          (evaluate_updates t2 b r3) x", "apply (erule_tac x=\"(ab, ba)\" in fBallE[of \"possible_steps e1 s1 r1 aa b\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>a = (aa, b);\n     \\<And>s1 r1 s2 r2 s3 r3.\n        \\<lbrakk>executionally_equivalent e1 s1 r1 e2 s2 r2 x;\n         executionally_equivalent e2 s2 r2 e3 s3 r3 x\\<rbrakk>\n        \\<Longrightarrow> executionally_equivalent e1 s1 r1 e3 s3 r3 x;\n     \\<forall>(s2', t2)|\\<in>|possible_steps e2 s2 r2 aa b.\n        \\<exists>(s1', t1)|\\<in>|possible_steps e1 s1 r1 aa b.\n           evaluate_outputs t1 b r1 = evaluate_outputs t2 b r2 \\<and>\n           executionally_equivalent e1 s1' (evaluate_updates t1 b r1) e2 s2'\n            (evaluate_updates t2 b r2) x;\n     \\<forall>(s1', t1)|\\<in>|possible_steps e2 s2 r2 aa b.\n        \\<exists>(s2', t2)|\\<in>|possible_steps e3 s3 r3 aa b.\n           evaluate_outputs t1 b r2 = evaluate_outputs t2 b r3 \\<and>\n           executionally_equivalent e2 s1' (evaluate_updates t1 b r2) e3 s2'\n            (evaluate_updates t2 b r3) x;\n     \\<forall>(s2', t2)|\\<in>|possible_steps e3 s3 r3 aa b.\n        \\<exists>(s1', t1)|\\<in>|possible_steps e2 s2 r2 aa b.\n           evaluate_outputs t1 b r2 = evaluate_outputs t2 b r3 \\<and>\n           executionally_equivalent e2 s1' (evaluate_updates t1 b r2) e3 s2'\n            (evaluate_updates t2 b r3) x;\n     (ab, ba) |\\<in>| possible_steps e1 s1 r1 aa b;\n     case (ab, ba) of\n     (s1', t1) \\<Rightarrow>\n       \\<exists>(s2', t2)|\\<in>|possible_steps e2 s2 r2 aa b.\n          evaluate_outputs t1 b r1 = evaluate_outputs t2 b r2 \\<and>\n          executionally_equivalent e1 s1' (evaluate_updates t1 b r1) e2 s2'\n           (evaluate_updates t2 b r2) x\\<rbrakk>\n    \\<Longrightarrow> \\<exists>(s2', t2)|\\<in>|possible_steps e3 s3 r3 aa b.\n                         evaluate_outputs ba b r1 =\n                         evaluate_outputs t2 b r3 \\<and>\n                         executionally_equivalent e1 ab\n                          (evaluate_updates ba b r1) e3 s2'\n                          (evaluate_updates t2 b r3) x\n 2. \\<lbrakk>a = (aa, b);\n     \\<And>s1 r1 s2 r2 s3 r3.\n        \\<lbrakk>executionally_equivalent e1 s1 r1 e2 s2 r2 x;\n         executionally_equivalent e2 s2 r2 e3 s3 r3 x\\<rbrakk>\n        \\<Longrightarrow> executionally_equivalent e1 s1 r1 e3 s3 r3 x;\n     \\<forall>(s2', t2)|\\<in>|possible_steps e2 s2 r2 aa b.\n        \\<exists>(s1', t1)|\\<in>|possible_steps e1 s1 r1 aa b.\n           evaluate_outputs t1 b r1 = evaluate_outputs t2 b r2 \\<and>\n           executionally_equivalent e1 s1' (evaluate_updates t1 b r1) e2 s2'\n            (evaluate_updates t2 b r2) x;\n     \\<forall>(s1', t1)|\\<in>|possible_steps e2 s2 r2 aa b.\n        \\<exists>(s2', t2)|\\<in>|possible_steps e3 s3 r3 aa b.\n           evaluate_outputs t1 b r2 = evaluate_outputs t2 b r3 \\<and>\n           executionally_equivalent e2 s1' (evaluate_updates t1 b r2) e3 s2'\n            (evaluate_updates t2 b r3) x;\n     \\<forall>(s2', t2)|\\<in>|possible_steps e3 s3 r3 aa b.\n        \\<exists>(s1', t1)|\\<in>|possible_steps e2 s2 r2 aa b.\n           evaluate_outputs t1 b r2 = evaluate_outputs t2 b r3 \\<and>\n           executionally_equivalent e2 s1' (evaluate_updates t1 b r2) e3 s2'\n            (evaluate_updates t2 b r3) x;\n     (ab, ba) |\\<in>| possible_steps e1 s1 r1 aa b;\n     (ab, ba) |\\<notin>| possible_steps e1 s1 r1 aa b\\<rbrakk>\n    \\<Longrightarrow> \\<exists>(s2', t2)|\\<in>|possible_steps e3 s3 r3 aa b.\n                         evaluate_outputs ba b r1 =\n                         evaluate_outputs t2 b r3 \\<and>\n                         executionally_equivalent e1 ab\n                          (evaluate_updates ba b r1) e3 s2'\n                          (evaluate_updates t2 b r3) x", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>a = (aa, b);\n     \\<And>s1 r1 s2 r2 s3 r3.\n        \\<lbrakk>executionally_equivalent e1 s1 r1 e2 s2 r2 x;\n         executionally_equivalent e2 s2 r2 e3 s3 r3 x\\<rbrakk>\n        \\<Longrightarrow> executionally_equivalent e1 s1 r1 e3 s3 r3 x;\n     \\<forall>(s2', t2)|\\<in>|possible_steps e2 s2 r2 aa b.\n        \\<exists>(s1', t1)|\\<in>|possible_steps e1 s1 r1 aa b.\n           evaluate_outputs t1 b r1 = evaluate_outputs t2 b r2 \\<and>\n           executionally_equivalent e1 s1' (evaluate_updates t1 b r1) e2 s2'\n            (evaluate_updates t2 b r2) x;\n     \\<forall>(s1', t1)|\\<in>|possible_steps e2 s2 r2 aa b.\n        \\<exists>(s2', t2)|\\<in>|possible_steps e3 s3 r3 aa b.\n           evaluate_outputs t1 b r2 = evaluate_outputs t2 b r3 \\<and>\n           executionally_equivalent e2 s1' (evaluate_updates t1 b r2) e3 s2'\n            (evaluate_updates t2 b r3) x;\n     \\<forall>(s2', t2)|\\<in>|possible_steps e3 s3 r3 aa b.\n        \\<exists>(s1', t1)|\\<in>|possible_steps e2 s2 r2 aa b.\n           evaluate_outputs t1 b r2 = evaluate_outputs t2 b r3 \\<and>\n           executionally_equivalent e2 s1' (evaluate_updates t1 b r2) e3 s2'\n            (evaluate_updates t2 b r3) x;\n     (ab, ba) |\\<in>| possible_steps e1 s1 r1 aa b;\n     (ab, ba) |\\<notin>| possible_steps e1 s1 r1 aa b\\<rbrakk>\n    \\<Longrightarrow> \\<exists>(s2', t2)|\\<in>|possible_steps e3 s3 r3 aa b.\n                         evaluate_outputs ba b r1 =\n                         evaluate_outputs t2 b r3 \\<and>\n                         executionally_equivalent e1 ab\n                          (evaluate_updates ba b r1) e3 s2'\n                          (evaluate_updates t2 b r3) x\n 2. \\<lbrakk>a = (aa, b);\n     \\<And>s1 r1 s2 r2 s3 r3.\n        \\<lbrakk>executionally_equivalent e1 s1 r1 e2 s2 r2 x;\n         executionally_equivalent e2 s2 r2 e3 s3 r3 x\\<rbrakk>\n        \\<Longrightarrow> executionally_equivalent e1 s1 r1 e3 s3 r3 x;\n     \\<forall>(s2', t2)|\\<in>|possible_steps e2 s2 r2 aa b.\n        \\<exists>(s1', t1)|\\<in>|possible_steps e1 s1 r1 aa b.\n           evaluate_outputs t1 b r1 = evaluate_outputs t2 b r2 \\<and>\n           executionally_equivalent e1 s1' (evaluate_updates t1 b r1) e2 s2'\n            (evaluate_updates t2 b r2) x;\n     \\<forall>(s1', t1)|\\<in>|possible_steps e2 s2 r2 aa b.\n        \\<exists>(s2', t2)|\\<in>|possible_steps e3 s3 r3 aa b.\n           evaluate_outputs t1 b r2 = evaluate_outputs t2 b r3 \\<and>\n           executionally_equivalent e2 s1' (evaluate_updates t1 b r2) e3 s2'\n            (evaluate_updates t2 b r3) x;\n     \\<forall>(s2', t2)|\\<in>|possible_steps e3 s3 r3 aa b.\n        \\<exists>(s1', t1)|\\<in>|possible_steps e2 s2 r2 aa b.\n           evaluate_outputs t1 b r2 = evaluate_outputs t2 b r3 \\<and>\n           executionally_equivalent e2 s1' (evaluate_updates t1 b r2) e3 s2'\n            (evaluate_updates t2 b r3) x;\n     (ab, ba) |\\<in>| possible_steps e1 s1 r1 aa b;\n     case (ab, ba) of\n     (s1', t1) \\<Rightarrow>\n       \\<exists>(s2', t2)|\\<in>|possible_steps e2 s2 r2 aa b.\n          evaluate_outputs t1 b r1 = evaluate_outputs t2 b r2 \\<and>\n          executionally_equivalent e1 s1' (evaluate_updates t1 b r1) e2 s2'\n           (evaluate_updates t2 b r2) x\\<rbrakk>\n    \\<Longrightarrow> \\<exists>(s2', t2)|\\<in>|possible_steps e3 s3 r3 aa b.\n                         evaluate_outputs ba b r1 =\n                         evaluate_outputs t2 b r3 \\<and>\n                         executionally_equivalent e1 ab\n                          (evaluate_updates ba b r1) e3 s2'\n                          (evaluate_updates t2 b r3) x", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a = (aa, b);\n     \\<And>s1 r1 s2 r2 s3 r3.\n        \\<lbrakk>executionally_equivalent e1 s1 r1 e2 s2 r2 x;\n         executionally_equivalent e2 s2 r2 e3 s3 r3 x\\<rbrakk>\n        \\<Longrightarrow> executionally_equivalent e1 s1 r1 e3 s3 r3 x;\n     \\<forall>(s2', t2)|\\<in>|possible_steps e2 s2 r2 aa b.\n        \\<exists>(s1', t1)|\\<in>|possible_steps e1 s1 r1 aa b.\n           evaluate_outputs t1 b r1 = evaluate_outputs t2 b r2 \\<and>\n           executionally_equivalent e1 s1' (evaluate_updates t1 b r1) e2 s2'\n            (evaluate_updates t2 b r2) x;\n     \\<forall>(s1', t1)|\\<in>|possible_steps e2 s2 r2 aa b.\n        \\<exists>(s2', t2)|\\<in>|possible_steps e3 s3 r3 aa b.\n           evaluate_outputs t1 b r2 = evaluate_outputs t2 b r3 \\<and>\n           executionally_equivalent e2 s1' (evaluate_updates t1 b r2) e3 s2'\n            (evaluate_updates t2 b r3) x;\n     \\<forall>(s2', t2)|\\<in>|possible_steps e3 s3 r3 aa b.\n        \\<exists>(s1', t1)|\\<in>|possible_steps e2 s2 r2 aa b.\n           evaluate_outputs t1 b r2 = evaluate_outputs t2 b r3 \\<and>\n           executionally_equivalent e2 s1' (evaluate_updates t1 b r2) e3 s2'\n            (evaluate_updates t2 b r3) x;\n     (ab, ba) |\\<in>| possible_steps e1 s1 r1 aa b;\n     case (ab, ba) of\n     (s1', t1) \\<Rightarrow>\n       \\<exists>(s2', t2)|\\<in>|possible_steps e2 s2 r2 aa b.\n          evaluate_outputs t1 b r1 = evaluate_outputs t2 b r2 \\<and>\n          executionally_equivalent e1 s1' (evaluate_updates t1 b r1) e2 s2'\n           (evaluate_updates t2 b r2) x\\<rbrakk>\n    \\<Longrightarrow> \\<exists>(s2', t2)|\\<in>|possible_steps e3 s3 r3 aa b.\n                         evaluate_outputs ba b r1 =\n                         evaluate_outputs t2 b r3 \\<and>\n                         executionally_equivalent e1 ab\n                          (evaluate_updates ba b r1) e3 s2'\n                          (evaluate_updates t2 b r3) x", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a = (aa, b);\n     \\<And>s1 r1 s2 r2 s3 r3.\n        \\<lbrakk>executionally_equivalent e1 s1 r1 e2 s2 r2 x;\n         executionally_equivalent e2 s2 r2 e3 s3 r3 x\\<rbrakk>\n        \\<Longrightarrow> executionally_equivalent e1 s1 r1 e3 s3 r3 x;\n     \\<forall>(s2', t2)|\\<in>|possible_steps e2 s2 r2 aa b.\n        \\<exists>(s1', t1)|\\<in>|possible_steps e1 s1 r1 aa b.\n           evaluate_outputs t1 b r1 = evaluate_outputs t2 b r2 \\<and>\n           executionally_equivalent e1 s1' (evaluate_updates t1 b r1) e2 s2'\n            (evaluate_updates t2 b r2) x;\n     \\<forall>(s1', t1)|\\<in>|possible_steps e2 s2 r2 aa b.\n        \\<exists>(s2', t2)|\\<in>|possible_steps e3 s3 r3 aa b.\n           evaluate_outputs t1 b r2 = evaluate_outputs t2 b r3 \\<and>\n           executionally_equivalent e2 s1' (evaluate_updates t1 b r2) e3 s2'\n            (evaluate_updates t2 b r3) x;\n     \\<forall>(s2', t2)|\\<in>|possible_steps e3 s3 r3 aa b.\n        \\<exists>(s1', t1)|\\<in>|possible_steps e2 s2 r2 aa b.\n           evaluate_outputs t1 b r2 = evaluate_outputs t2 b r3 \\<and>\n           executionally_equivalent e2 s1' (evaluate_updates t1 b r2) e3 s2'\n            (evaluate_updates t2 b r3) x;\n     (ab, ba) |\\<in>| possible_steps e1 s1 r1 aa b;\n     \\<exists>(s2', t2)|\\<in>|possible_steps e2 s2 r2 aa b.\n        evaluate_outputs ba b r1 = evaluate_outputs t2 b r2 \\<and>\n        executionally_equivalent e1 ab (evaluate_updates ba b r1) e2 s2'\n         (evaluate_updates t2 b r2) x\\<rbrakk>\n    \\<Longrightarrow> \\<exists>(s2', t2)|\\<in>|possible_steps e3 s3 r3 aa b.\n                         evaluate_outputs ba b r1 =\n                         evaluate_outputs t2 b r3 \\<and>\n                         executionally_equivalent e1 ab\n                          (evaluate_updates ba b r1) e3 s2'\n                          (evaluate_updates t2 b r3) x", "apply (erule fBexE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>a = (aa, b);\n        \\<And>s1 r1 s2 r2 s3 r3.\n           \\<lbrakk>executionally_equivalent e1 s1 r1 e2 s2 r2 x;\n            executionally_equivalent e2 s2 r2 e3 s3 r3 x\\<rbrakk>\n           \\<Longrightarrow> executionally_equivalent e1 s1 r1 e3 s3 r3 x;\n        \\<forall>(s2', t2)|\\<in>|possible_steps e2 s2 r2 aa b.\n           \\<exists>(s1', t1)|\\<in>|possible_steps e1 s1 r1 aa b.\n              evaluate_outputs t1 b r1 = evaluate_outputs t2 b r2 \\<and>\n              executionally_equivalent e1 s1' (evaluate_updates t1 b r1) e2\n               s2' (evaluate_updates t2 b r2) x;\n        \\<forall>(s1', t1)|\\<in>|possible_steps e2 s2 r2 aa b.\n           \\<exists>(s2', t2)|\\<in>|possible_steps e3 s3 r3 aa b.\n              evaluate_outputs t1 b r2 = evaluate_outputs t2 b r3 \\<and>\n              executionally_equivalent e2 s1' (evaluate_updates t1 b r2) e3\n               s2' (evaluate_updates t2 b r3) x;\n        \\<forall>(s2', t2)|\\<in>|possible_steps e3 s3 r3 aa b.\n           \\<exists>(s1', t1)|\\<in>|possible_steps e2 s2 r2 aa b.\n              evaluate_outputs t1 b r2 = evaluate_outputs t2 b r3 \\<and>\n              executionally_equivalent e2 s1' (evaluate_updates t1 b r2) e3\n               s2' (evaluate_updates t2 b r3) x;\n        (ab, ba) |\\<in>| possible_steps e1 s1 r1 aa b;\n        x |\\<in>| possible_steps e2 s2 r2 aa b;\n        case x of\n        (s2', t2) \\<Rightarrow>\n          evaluate_outputs ba b r1 = evaluate_outputs t2 b r2 \\<and>\n          executionally_equivalent e1 ab (evaluate_updates ba b r1) e2 s2'\n           (evaluate_updates t2 b r2) x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>(s2', t2)\n                                  |\\<in>|possible_steps e3 s3 r3 aa b.\n                            evaluate_outputs ba b r1 =\n                            evaluate_outputs t2 b r3 \\<and>\n                            executionally_equivalent e1 ab\n                             (evaluate_updates ba b r1) e3 s2'\n                             (evaluate_updates t2 b r3) x", "subgoal for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a = (aa, b);\n     \\<And>s1 r1 s2 r2 s3 r3.\n        \\<lbrakk>executionally_equivalent e1 s1 r1 e2 s2 r2 xa__;\n         executionally_equivalent e2 s2 r2 e3 s3 r3 xa__\\<rbrakk>\n        \\<Longrightarrow> executionally_equivalent e1 s1 r1 e3 s3 r3 xa__;\n     \\<forall>(s2', t2)|\\<in>|possible_steps e2 s2 r2 aa b.\n        \\<exists>(s1', t1)|\\<in>|possible_steps e1 s1 r1 aa b.\n           evaluate_outputs t1 b r1 = evaluate_outputs t2 b r2 \\<and>\n           executionally_equivalent e1 s1' (evaluate_updates t1 b r1) e2 s2'\n            (evaluate_updates t2 b r2) xa__;\n     \\<forall>(s1', t1)|\\<in>|possible_steps e2 s2 r2 aa b.\n        \\<exists>(s2', t2)|\\<in>|possible_steps e3 s3 r3 aa b.\n           evaluate_outputs t1 b r2 = evaluate_outputs t2 b r3 \\<and>\n           executionally_equivalent e2 s1' (evaluate_updates t1 b r2) e3 s2'\n            (evaluate_updates t2 b r3) xa__;\n     \\<forall>(s2', t2)|\\<in>|possible_steps e3 s3 r3 aa b.\n        \\<exists>(s1', t1)|\\<in>|possible_steps e2 s2 r2 aa b.\n           evaluate_outputs t1 b r2 = evaluate_outputs t2 b r3 \\<and>\n           executionally_equivalent e2 s1' (evaluate_updates t1 b r2) e3 s2'\n            (evaluate_updates t2 b r3) xa__;\n     (ab, ba) |\\<in>| possible_steps e1 s1 r1 aa b;\n     x |\\<in>| possible_steps e2 s2 r2 aa b;\n     case x of\n     (s2', t2) \\<Rightarrow>\n       evaluate_outputs ba b r1 = evaluate_outputs t2 b r2 \\<and>\n       executionally_equivalent e1 ab (evaluate_updates ba b r1) e2 s2'\n        (evaluate_updates t2 b r2) xa__\\<rbrakk>\n    \\<Longrightarrow> \\<exists>(s2', t2)|\\<in>|possible_steps e3 s3 r3 aa b.\n                         evaluate_outputs ba b r1 =\n                         evaluate_outputs t2 b r3 \\<and>\n                         executionally_equivalent e1 ab\n                          (evaluate_updates ba b r1) e3 s2'\n                          (evaluate_updates t2 b r3) xa__", "apply (case_tac x)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ac bb.\n       \\<lbrakk>a = (aa, b);\n        \\<And>s1 r1 s2 r2 s3 r3.\n           \\<lbrakk>executionally_equivalent e1 s1 r1 e2 s2 r2 xa__;\n            executionally_equivalent e2 s2 r2 e3 s3 r3 xa__\\<rbrakk>\n           \\<Longrightarrow> executionally_equivalent e1 s1 r1 e3 s3 r3\n                              xa__;\n        \\<forall>(s2', t2)|\\<in>|possible_steps e2 s2 r2 aa b.\n           \\<exists>(s1', t1)|\\<in>|possible_steps e1 s1 r1 aa b.\n              evaluate_outputs t1 b r1 = evaluate_outputs t2 b r2 \\<and>\n              executionally_equivalent e1 s1' (evaluate_updates t1 b r1) e2\n               s2' (evaluate_updates t2 b r2) xa__;\n        \\<forall>(s1', t1)|\\<in>|possible_steps e2 s2 r2 aa b.\n           \\<exists>(s2', t2)|\\<in>|possible_steps e3 s3 r3 aa b.\n              evaluate_outputs t1 b r2 = evaluate_outputs t2 b r3 \\<and>\n              executionally_equivalent e2 s1' (evaluate_updates t1 b r2) e3\n               s2' (evaluate_updates t2 b r3) xa__;\n        \\<forall>(s2', t2)|\\<in>|possible_steps e3 s3 r3 aa b.\n           \\<exists>(s1', t1)|\\<in>|possible_steps e2 s2 r2 aa b.\n              evaluate_outputs t1 b r2 = evaluate_outputs t2 b r3 \\<and>\n              executionally_equivalent e2 s1' (evaluate_updates t1 b r2) e3\n               s2' (evaluate_updates t2 b r3) xa__;\n        (ab, ba) |\\<in>| possible_steps e1 s1 r1 aa b;\n        x |\\<in>| possible_steps e2 s2 r2 aa b;\n        case x of\n        (s2', t2) \\<Rightarrow>\n          evaluate_outputs ba b r1 = evaluate_outputs t2 b r2 \\<and>\n          executionally_equivalent e1 ab (evaluate_updates ba b r1) e2 s2'\n           (evaluate_updates t2 b r2) xa__;\n        x = (ac, bb)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>(s2', t2)\n                                  |\\<in>|possible_steps e3 s3 r3 aa b.\n                            evaluate_outputs ba b r1 =\n                            evaluate_outputs t2 b r3 \\<and>\n                            executionally_equivalent e1 ab\n                             (evaluate_updates ba b r1) e3 s2'\n                             (evaluate_updates t2 b r3) xa__", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ac bb.\n       \\<lbrakk>a = (aa, b);\n        \\<And>s1 r1 s2 r2 s3 r3.\n           \\<lbrakk>executionally_equivalent e1 s1 r1 e2 s2 r2 xa__;\n            executionally_equivalent e2 s2 r2 e3 s3 r3 xa__\\<rbrakk>\n           \\<Longrightarrow> executionally_equivalent e1 s1 r1 e3 s3 r3\n                              xa__;\n        \\<forall>(s2', t2)|\\<in>|possible_steps e2 s2 r2 aa b.\n           \\<exists>(s1', t1)|\\<in>|possible_steps e1 s1 r1 aa b.\n              evaluate_outputs t1 b r1 = evaluate_outputs t2 b r2 \\<and>\n              executionally_equivalent e1 s1' (evaluate_updates t1 b r1) e2\n               s2' (evaluate_updates t2 b r2) xa__;\n        \\<forall>(s1', t1)|\\<in>|possible_steps e2 s2 r2 aa b.\n           \\<exists>(s2', t2)|\\<in>|possible_steps e3 s3 r3 aa b.\n              evaluate_outputs t1 b r2 = evaluate_outputs t2 b r3 \\<and>\n              executionally_equivalent e2 s1' (evaluate_updates t1 b r2) e3\n               s2' (evaluate_updates t2 b r3) xa__;\n        \\<forall>(s2', t2)|\\<in>|possible_steps e3 s3 r3 aa b.\n           \\<exists>(s1', t1)|\\<in>|possible_steps e2 s2 r2 aa b.\n              evaluate_outputs t1 b r2 = evaluate_outputs t2 b r3 \\<and>\n              executionally_equivalent e2 s1' (evaluate_updates t1 b r2) e3\n               s2' (evaluate_updates t2 b r3) xa__;\n        (ab, ba) |\\<in>| possible_steps e1 s1 r1 aa b;\n        (ac, bb) |\\<in>| possible_steps e2 s2 r2 aa b;\n        evaluate_outputs ba b r1 = evaluate_outputs bb b r2 \\<and>\n        executionally_equivalent e1 ab (evaluate_updates ba b r1) e2 ac\n         (evaluate_updates bb b r2) xa__;\n        x = (ac, bb)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>(s2', t2)\n                                  |\\<in>|possible_steps e3 s3 r3 aa b.\n                            evaluate_outputs bb b r2 =\n                            evaluate_outputs t2 b r3 \\<and>\n                            executionally_equivalent e1 ab\n                             (evaluate_updates ba b r1) e3 s2'\n                             (evaluate_updates t2 b r3) xa__", "by blast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b.\n       \\<lbrakk>a = (aa, b);\n        \\<And>s1 r1 s2 r2 s3 r3.\n           \\<lbrakk>executionally_equivalent e1 s1 r1 e2 s2 r2 x;\n            executionally_equivalent e2 s2 r2 e3 s3 r3 x\\<rbrakk>\n           \\<Longrightarrow> executionally_equivalent e1 s1 r1 e3 s3 r3 x;\n        \\<forall>(s1', t1)|\\<in>|possible_steps e1 s1 r1 aa b.\n           \\<exists>(s2', t2)|\\<in>|possible_steps e2 s2 r2 aa b.\n              evaluate_outputs t1 b r1 = evaluate_outputs t2 b r2 \\<and>\n              executionally_equivalent e1 s1' (evaluate_updates t1 b r1) e2\n               s2' (evaluate_updates t2 b r2) x;\n        \\<forall>(s2', t2)|\\<in>|possible_steps e2 s2 r2 aa b.\n           \\<exists>(s1', t1)|\\<in>|possible_steps e1 s1 r1 aa b.\n              evaluate_outputs t1 b r1 = evaluate_outputs t2 b r2 \\<and>\n              executionally_equivalent e1 s1' (evaluate_updates t1 b r1) e2\n               s2' (evaluate_updates t2 b r2) x;\n        \\<forall>(s1', t1)|\\<in>|possible_steps e2 s2 r2 aa b.\n           \\<exists>(s2', t2)|\\<in>|possible_steps e3 s3 r3 aa b.\n              evaluate_outputs t1 b r2 = evaluate_outputs t2 b r3 \\<and>\n              executionally_equivalent e2 s1' (evaluate_updates t1 b r2) e3\n               s2' (evaluate_updates t2 b r3) x;\n        \\<forall>(s2', t2)|\\<in>|possible_steps e3 s3 r3 aa b.\n           \\<exists>(s1', t1)|\\<in>|possible_steps e2 s2 r2 aa b.\n              evaluate_outputs t1 b r2 = evaluate_outputs t2 b r3 \\<and>\n              executionally_equivalent e2 s1' (evaluate_updates t1 b r2) e3\n               s2' (evaluate_updates t2 b r3) x\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(s2', t2)\n                                  |\\<in>|possible_steps e3 s3 r3 aa b.\n                            \\<exists>(s1', t1)\n                                     |\\<in>|possible_steps e1 s1 r1 aa b.\n                               evaluate_outputs t1 b r1 =\n                               evaluate_outputs t2 b r3 \\<and>\n                               executionally_equivalent e1 s1'\n                                (evaluate_updates t1 b r1) e3 s2'\n                                (evaluate_updates t2 b r3) x", "apply (rule fBallI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b x.\n       \\<lbrakk>a = (aa, b);\n        \\<And>s1 r1 s2 r2 s3 r3.\n           \\<lbrakk>executionally_equivalent e1 s1 r1 e2 s2 r2 x;\n            executionally_equivalent e2 s2 r2 e3 s3 r3 x\\<rbrakk>\n           \\<Longrightarrow> executionally_equivalent e1 s1 r1 e3 s3 r3 x;\n        \\<forall>(s1', t1)|\\<in>|possible_steps e1 s1 r1 aa b.\n           \\<exists>(s2', t2)|\\<in>|possible_steps e2 s2 r2 aa b.\n              evaluate_outputs t1 b r1 = evaluate_outputs t2 b r2 \\<and>\n              executionally_equivalent e1 s1' (evaluate_updates t1 b r1) e2\n               s2' (evaluate_updates t2 b r2) x;\n        \\<forall>(s2', t2)|\\<in>|possible_steps e2 s2 r2 aa b.\n           \\<exists>(s1', t1)|\\<in>|possible_steps e1 s1 r1 aa b.\n              evaluate_outputs t1 b r1 = evaluate_outputs t2 b r2 \\<and>\n              executionally_equivalent e1 s1' (evaluate_updates t1 b r1) e2\n               s2' (evaluate_updates t2 b r2) x;\n        \\<forall>(s1', t1)|\\<in>|possible_steps e2 s2 r2 aa b.\n           \\<exists>(s2', t2)|\\<in>|possible_steps e3 s3 r3 aa b.\n              evaluate_outputs t1 b r2 = evaluate_outputs t2 b r3 \\<and>\n              executionally_equivalent e2 s1' (evaluate_updates t1 b r2) e3\n               s2' (evaluate_updates t2 b r3) x;\n        \\<forall>(s2', t2)|\\<in>|possible_steps e3 s3 r3 aa b.\n           \\<exists>(s1', t1)|\\<in>|possible_steps e2 s2 r2 aa b.\n              evaluate_outputs t1 b r2 = evaluate_outputs t2 b r3 \\<and>\n              executionally_equivalent e2 s1' (evaluate_updates t1 b r2) e3\n               s2' (evaluate_updates t2 b r3) x;\n        x |\\<in>| possible_steps e3 s3 r3 aa b\\<rbrakk>\n       \\<Longrightarrow> case x of\n                         (s2', t2) \\<Rightarrow>\n                           \\<exists>(s1', t1)\n                                    |\\<in>|possible_steps e1 s1 r1 aa b.\n                              evaluate_outputs t1 b r1 =\n                              evaluate_outputs t2 b r3 \\<and>\n                              executionally_equivalent e1 s1'\n                               (evaluate_updates t1 b r1) e3 s2'\n                               (evaluate_updates t2 b r3) x", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b ab ba.\n       \\<lbrakk>a = (aa, b);\n        \\<And>s1 r1 s2 r2 s3 r3.\n           \\<lbrakk>executionally_equivalent e1 s1 r1 e2 s2 r2 x;\n            executionally_equivalent e2 s2 r2 e3 s3 r3 x\\<rbrakk>\n           \\<Longrightarrow> executionally_equivalent e1 s1 r1 e3 s3 r3 x;\n        \\<forall>(s1', t1)|\\<in>|possible_steps e1 s1 r1 aa b.\n           \\<exists>(s2', t2)|\\<in>|possible_steps e2 s2 r2 aa b.\n              evaluate_outputs t1 b r1 = evaluate_outputs t2 b r2 \\<and>\n              executionally_equivalent e1 s1' (evaluate_updates t1 b r1) e2\n               s2' (evaluate_updates t2 b r2) x;\n        \\<forall>(s2', t2)|\\<in>|possible_steps e2 s2 r2 aa b.\n           \\<exists>(s1', t1)|\\<in>|possible_steps e1 s1 r1 aa b.\n              evaluate_outputs t1 b r1 = evaluate_outputs t2 b r2 \\<and>\n              executionally_equivalent e1 s1' (evaluate_updates t1 b r1) e2\n               s2' (evaluate_updates t2 b r2) x;\n        \\<forall>(s1', t1)|\\<in>|possible_steps e2 s2 r2 aa b.\n           \\<exists>(s2', t2)|\\<in>|possible_steps e3 s3 r3 aa b.\n              evaluate_outputs t1 b r2 = evaluate_outputs t2 b r3 \\<and>\n              executionally_equivalent e2 s1' (evaluate_updates t1 b r2) e3\n               s2' (evaluate_updates t2 b r3) x;\n        \\<forall>(s2', t2)|\\<in>|possible_steps e3 s3 r3 aa b.\n           \\<exists>(s1', t1)|\\<in>|possible_steps e2 s2 r2 aa b.\n              evaluate_outputs t1 b r2 = evaluate_outputs t2 b r3 \\<and>\n              executionally_equivalent e2 s1' (evaluate_updates t1 b r2) e3\n               s2' (evaluate_updates t2 b r3) x;\n        (ab, ba) |\\<in>| possible_steps e3 s3 r3 aa b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>(s1', t1)\n                                  |\\<in>|possible_steps e1 s1 r1 aa b.\n                            evaluate_outputs t1 b r1 =\n                            evaluate_outputs ba b r3 \\<and>\n                            executionally_equivalent e1 s1'\n                             (evaluate_updates t1 b r1) e3 ab\n                             (evaluate_updates ba b r3) x", "subgoal for aa b ab ba"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a = (aa, b);\n     \\<And>s1 r1 s2 r2 s3 r3.\n        \\<lbrakk>executionally_equivalent e1 s1 r1 e2 s2 r2 x;\n         executionally_equivalent e2 s2 r2 e3 s3 r3 x\\<rbrakk>\n        \\<Longrightarrow> executionally_equivalent e1 s1 r1 e3 s3 r3 x;\n     \\<forall>(s1', t1)|\\<in>|possible_steps e1 s1 r1 aa b.\n        \\<exists>(s2', t2)|\\<in>|possible_steps e2 s2 r2 aa b.\n           evaluate_outputs t1 b r1 = evaluate_outputs t2 b r2 \\<and>\n           executionally_equivalent e1 s1' (evaluate_updates t1 b r1) e2 s2'\n            (evaluate_updates t2 b r2) x;\n     \\<forall>(s2', t2)|\\<in>|possible_steps e2 s2 r2 aa b.\n        \\<exists>(s1', t1)|\\<in>|possible_steps e1 s1 r1 aa b.\n           evaluate_outputs t1 b r1 = evaluate_outputs t2 b r2 \\<and>\n           executionally_equivalent e1 s1' (evaluate_updates t1 b r1) e2 s2'\n            (evaluate_updates t2 b r2) x;\n     \\<forall>(s1', t1)|\\<in>|possible_steps e2 s2 r2 aa b.\n        \\<exists>(s2', t2)|\\<in>|possible_steps e3 s3 r3 aa b.\n           evaluate_outputs t1 b r2 = evaluate_outputs t2 b r3 \\<and>\n           executionally_equivalent e2 s1' (evaluate_updates t1 b r2) e3 s2'\n            (evaluate_updates t2 b r3) x;\n     \\<forall>(s2', t2)|\\<in>|possible_steps e3 s3 r3 aa b.\n        \\<exists>(s1', t1)|\\<in>|possible_steps e2 s2 r2 aa b.\n           evaluate_outputs t1 b r2 = evaluate_outputs t2 b r3 \\<and>\n           executionally_equivalent e2 s1' (evaluate_updates t1 b r2) e3 s2'\n            (evaluate_updates t2 b r3) x;\n     (ab, ba) |\\<in>| possible_steps e3 s3 r3 aa b\\<rbrakk>\n    \\<Longrightarrow> \\<exists>(s1', t1)|\\<in>|possible_steps e1 s1 r1 aa b.\n                         evaluate_outputs t1 b r1 =\n                         evaluate_outputs ba b r3 \\<and>\n                         executionally_equivalent e1 s1'\n                          (evaluate_updates t1 b r1) e3 ab\n                          (evaluate_updates ba b r3) x", "apply (erule_tac x=\"(ab, ba)\" in fBallE[of \"possible_steps e3 s3 r3 aa b\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>a = (aa, b);\n     \\<And>s1 r1 s2 r2 s3 r3.\n        \\<lbrakk>executionally_equivalent e1 s1 r1 e2 s2 r2 x;\n         executionally_equivalent e2 s2 r2 e3 s3 r3 x\\<rbrakk>\n        \\<Longrightarrow> executionally_equivalent e1 s1 r1 e3 s3 r3 x;\n     \\<forall>(s1', t1)|\\<in>|possible_steps e1 s1 r1 aa b.\n        \\<exists>(s2', t2)|\\<in>|possible_steps e2 s2 r2 aa b.\n           evaluate_outputs t1 b r1 = evaluate_outputs t2 b r2 \\<and>\n           executionally_equivalent e1 s1' (evaluate_updates t1 b r1) e2 s2'\n            (evaluate_updates t2 b r2) x;\n     \\<forall>(s2', t2)|\\<in>|possible_steps e2 s2 r2 aa b.\n        \\<exists>(s1', t1)|\\<in>|possible_steps e1 s1 r1 aa b.\n           evaluate_outputs t1 b r1 = evaluate_outputs t2 b r2 \\<and>\n           executionally_equivalent e1 s1' (evaluate_updates t1 b r1) e2 s2'\n            (evaluate_updates t2 b r2) x;\n     \\<forall>(s1', t1)|\\<in>|possible_steps e2 s2 r2 aa b.\n        \\<exists>(s2', t2)|\\<in>|possible_steps e3 s3 r3 aa b.\n           evaluate_outputs t1 b r2 = evaluate_outputs t2 b r3 \\<and>\n           executionally_equivalent e2 s1' (evaluate_updates t1 b r2) e3 s2'\n            (evaluate_updates t2 b r3) x;\n     (ab, ba) |\\<in>| possible_steps e3 s3 r3 aa b;\n     case (ab, ba) of\n     (s2', t2) \\<Rightarrow>\n       \\<exists>(s1', t1)|\\<in>|possible_steps e2 s2 r2 aa b.\n          evaluate_outputs t1 b r2 = evaluate_outputs t2 b r3 \\<and>\n          executionally_equivalent e2 s1' (evaluate_updates t1 b r2) e3 s2'\n           (evaluate_updates t2 b r3) x\\<rbrakk>\n    \\<Longrightarrow> \\<exists>(s1', t1)|\\<in>|possible_steps e1 s1 r1 aa b.\n                         evaluate_outputs t1 b r1 =\n                         evaluate_outputs ba b r3 \\<and>\n                         executionally_equivalent e1 s1'\n                          (evaluate_updates t1 b r1) e3 ab\n                          (evaluate_updates ba b r3) x\n 2. \\<lbrakk>a = (aa, b);\n     \\<And>s1 r1 s2 r2 s3 r3.\n        \\<lbrakk>executionally_equivalent e1 s1 r1 e2 s2 r2 x;\n         executionally_equivalent e2 s2 r2 e3 s3 r3 x\\<rbrakk>\n        \\<Longrightarrow> executionally_equivalent e1 s1 r1 e3 s3 r3 x;\n     \\<forall>(s1', t1)|\\<in>|possible_steps e1 s1 r1 aa b.\n        \\<exists>(s2', t2)|\\<in>|possible_steps e2 s2 r2 aa b.\n           evaluate_outputs t1 b r1 = evaluate_outputs t2 b r2 \\<and>\n           executionally_equivalent e1 s1' (evaluate_updates t1 b r1) e2 s2'\n            (evaluate_updates t2 b r2) x;\n     \\<forall>(s2', t2)|\\<in>|possible_steps e2 s2 r2 aa b.\n        \\<exists>(s1', t1)|\\<in>|possible_steps e1 s1 r1 aa b.\n           evaluate_outputs t1 b r1 = evaluate_outputs t2 b r2 \\<and>\n           executionally_equivalent e1 s1' (evaluate_updates t1 b r1) e2 s2'\n            (evaluate_updates t2 b r2) x;\n     \\<forall>(s1', t1)|\\<in>|possible_steps e2 s2 r2 aa b.\n        \\<exists>(s2', t2)|\\<in>|possible_steps e3 s3 r3 aa b.\n           evaluate_outputs t1 b r2 = evaluate_outputs t2 b r3 \\<and>\n           executionally_equivalent e2 s1' (evaluate_updates t1 b r2) e3 s2'\n            (evaluate_updates t2 b r3) x;\n     (ab, ba) |\\<in>| possible_steps e3 s3 r3 aa b;\n     (ab, ba) |\\<notin>| possible_steps e3 s3 r3 aa b\\<rbrakk>\n    \\<Longrightarrow> \\<exists>(s1', t1)|\\<in>|possible_steps e1 s1 r1 aa b.\n                         evaluate_outputs t1 b r1 =\n                         evaluate_outputs ba b r3 \\<and>\n                         executionally_equivalent e1 s1'\n                          (evaluate_updates t1 b r1) e3 ab\n                          (evaluate_updates ba b r3) x", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>a = (aa, b);\n     \\<And>s1 r1 s2 r2 s3 r3.\n        \\<lbrakk>executionally_equivalent e1 s1 r1 e2 s2 r2 x;\n         executionally_equivalent e2 s2 r2 e3 s3 r3 x\\<rbrakk>\n        \\<Longrightarrow> executionally_equivalent e1 s1 r1 e3 s3 r3 x;\n     \\<forall>(s1', t1)|\\<in>|possible_steps e1 s1 r1 aa b.\n        \\<exists>(s2', t2)|\\<in>|possible_steps e2 s2 r2 aa b.\n           evaluate_outputs t1 b r1 = evaluate_outputs t2 b r2 \\<and>\n           executionally_equivalent e1 s1' (evaluate_updates t1 b r1) e2 s2'\n            (evaluate_updates t2 b r2) x;\n     \\<forall>(s2', t2)|\\<in>|possible_steps e2 s2 r2 aa b.\n        \\<exists>(s1', t1)|\\<in>|possible_steps e1 s1 r1 aa b.\n           evaluate_outputs t1 b r1 = evaluate_outputs t2 b r2 \\<and>\n           executionally_equivalent e1 s1' (evaluate_updates t1 b r1) e2 s2'\n            (evaluate_updates t2 b r2) x;\n     \\<forall>(s1', t1)|\\<in>|possible_steps e2 s2 r2 aa b.\n        \\<exists>(s2', t2)|\\<in>|possible_steps e3 s3 r3 aa b.\n           evaluate_outputs t1 b r2 = evaluate_outputs t2 b r3 \\<and>\n           executionally_equivalent e2 s1' (evaluate_updates t1 b r2) e3 s2'\n            (evaluate_updates t2 b r3) x;\n     (ab, ba) |\\<in>| possible_steps e3 s3 r3 aa b;\n     (ab, ba) |\\<notin>| possible_steps e3 s3 r3 aa b\\<rbrakk>\n    \\<Longrightarrow> \\<exists>(s1', t1)|\\<in>|possible_steps e1 s1 r1 aa b.\n                         evaluate_outputs t1 b r1 =\n                         evaluate_outputs ba b r3 \\<and>\n                         executionally_equivalent e1 s1'\n                          (evaluate_updates t1 b r1) e3 ab\n                          (evaluate_updates ba b r3) x\n 2. \\<lbrakk>a = (aa, b);\n     \\<And>s1 r1 s2 r2 s3 r3.\n        \\<lbrakk>executionally_equivalent e1 s1 r1 e2 s2 r2 x;\n         executionally_equivalent e2 s2 r2 e3 s3 r3 x\\<rbrakk>\n        \\<Longrightarrow> executionally_equivalent e1 s1 r1 e3 s3 r3 x;\n     \\<forall>(s1', t1)|\\<in>|possible_steps e1 s1 r1 aa b.\n        \\<exists>(s2', t2)|\\<in>|possible_steps e2 s2 r2 aa b.\n           evaluate_outputs t1 b r1 = evaluate_outputs t2 b r2 \\<and>\n           executionally_equivalent e1 s1' (evaluate_updates t1 b r1) e2 s2'\n            (evaluate_updates t2 b r2) x;\n     \\<forall>(s2', t2)|\\<in>|possible_steps e2 s2 r2 aa b.\n        \\<exists>(s1', t1)|\\<in>|possible_steps e1 s1 r1 aa b.\n           evaluate_outputs t1 b r1 = evaluate_outputs t2 b r2 \\<and>\n           executionally_equivalent e1 s1' (evaluate_updates t1 b r1) e2 s2'\n            (evaluate_updates t2 b r2) x;\n     \\<forall>(s1', t1)|\\<in>|possible_steps e2 s2 r2 aa b.\n        \\<exists>(s2', t2)|\\<in>|possible_steps e3 s3 r3 aa b.\n           evaluate_outputs t1 b r2 = evaluate_outputs t2 b r3 \\<and>\n           executionally_equivalent e2 s1' (evaluate_updates t1 b r2) e3 s2'\n            (evaluate_updates t2 b r3) x;\n     (ab, ba) |\\<in>| possible_steps e3 s3 r3 aa b;\n     case (ab, ba) of\n     (s2', t2) \\<Rightarrow>\n       \\<exists>(s1', t1)|\\<in>|possible_steps e2 s2 r2 aa b.\n          evaluate_outputs t1 b r2 = evaluate_outputs t2 b r3 \\<and>\n          executionally_equivalent e2 s1' (evaluate_updates t1 b r2) e3 s2'\n           (evaluate_updates t2 b r3) x\\<rbrakk>\n    \\<Longrightarrow> \\<exists>(s1', t1)|\\<in>|possible_steps e1 s1 r1 aa b.\n                         evaluate_outputs t1 b r1 =\n                         evaluate_outputs ba b r3 \\<and>\n                         executionally_equivalent e1 s1'\n                          (evaluate_updates t1 b r1) e3 ab\n                          (evaluate_updates ba b r3) x", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a = (aa, b);\n     \\<And>s1 r1 s2 r2 s3 r3.\n        \\<lbrakk>executionally_equivalent e1 s1 r1 e2 s2 r2 x;\n         executionally_equivalent e2 s2 r2 e3 s3 r3 x\\<rbrakk>\n        \\<Longrightarrow> executionally_equivalent e1 s1 r1 e3 s3 r3 x;\n     \\<forall>(s1', t1)|\\<in>|possible_steps e1 s1 r1 aa b.\n        \\<exists>(s2', t2)|\\<in>|possible_steps e2 s2 r2 aa b.\n           evaluate_outputs t1 b r1 = evaluate_outputs t2 b r2 \\<and>\n           executionally_equivalent e1 s1' (evaluate_updates t1 b r1) e2 s2'\n            (evaluate_updates t2 b r2) x;\n     \\<forall>(s2', t2)|\\<in>|possible_steps e2 s2 r2 aa b.\n        \\<exists>(s1', t1)|\\<in>|possible_steps e1 s1 r1 aa b.\n           evaluate_outputs t1 b r1 = evaluate_outputs t2 b r2 \\<and>\n           executionally_equivalent e1 s1' (evaluate_updates t1 b r1) e2 s2'\n            (evaluate_updates t2 b r2) x;\n     \\<forall>(s1', t1)|\\<in>|possible_steps e2 s2 r2 aa b.\n        \\<exists>(s2', t2)|\\<in>|possible_steps e3 s3 r3 aa b.\n           evaluate_outputs t1 b r2 = evaluate_outputs t2 b r3 \\<and>\n           executionally_equivalent e2 s1' (evaluate_updates t1 b r2) e3 s2'\n            (evaluate_updates t2 b r3) x;\n     (ab, ba) |\\<in>| possible_steps e3 s3 r3 aa b;\n     case (ab, ba) of\n     (s2', t2) \\<Rightarrow>\n       \\<exists>(s1', t1)|\\<in>|possible_steps e2 s2 r2 aa b.\n          evaluate_outputs t1 b r2 = evaluate_outputs t2 b r3 \\<and>\n          executionally_equivalent e2 s1' (evaluate_updates t1 b r2) e3 s2'\n           (evaluate_updates t2 b r3) x\\<rbrakk>\n    \\<Longrightarrow> \\<exists>(s1', t1)|\\<in>|possible_steps e1 s1 r1 aa b.\n                         evaluate_outputs t1 b r1 =\n                         evaluate_outputs ba b r3 \\<and>\n                         executionally_equivalent e1 s1'\n                          (evaluate_updates t1 b r1) e3 ab\n                          (evaluate_updates ba b r3) x", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a = (aa, b);\n     \\<And>s1 r1 s2 r2 s3 r3.\n        \\<lbrakk>executionally_equivalent e1 s1 r1 e2 s2 r2 x;\n         executionally_equivalent e2 s2 r2 e3 s3 r3 x\\<rbrakk>\n        \\<Longrightarrow> executionally_equivalent e1 s1 r1 e3 s3 r3 x;\n     \\<forall>(s1', t1)|\\<in>|possible_steps e1 s1 r1 aa b.\n        \\<exists>(s2', t2)|\\<in>|possible_steps e2 s2 r2 aa b.\n           evaluate_outputs t1 b r1 = evaluate_outputs t2 b r2 \\<and>\n           executionally_equivalent e1 s1' (evaluate_updates t1 b r1) e2 s2'\n            (evaluate_updates t2 b r2) x;\n     \\<forall>(s2', t2)|\\<in>|possible_steps e2 s2 r2 aa b.\n        \\<exists>(s1', t1)|\\<in>|possible_steps e1 s1 r1 aa b.\n           evaluate_outputs t1 b r1 = evaluate_outputs t2 b r2 \\<and>\n           executionally_equivalent e1 s1' (evaluate_updates t1 b r1) e2 s2'\n            (evaluate_updates t2 b r2) x;\n     \\<forall>(s1', t1)|\\<in>|possible_steps e2 s2 r2 aa b.\n        \\<exists>(s2', t2)|\\<in>|possible_steps e3 s3 r3 aa b.\n           evaluate_outputs t1 b r2 = evaluate_outputs t2 b r3 \\<and>\n           executionally_equivalent e2 s1' (evaluate_updates t1 b r2) e3 s2'\n            (evaluate_updates t2 b r3) x;\n     (ab, ba) |\\<in>| possible_steps e3 s3 r3 aa b;\n     \\<exists>(s1', t1)|\\<in>|possible_steps e2 s2 r2 aa b.\n        evaluate_outputs t1 b r2 = evaluate_outputs ba b r3 \\<and>\n        executionally_equivalent e2 s1' (evaluate_updates t1 b r2) e3 ab\n         (evaluate_updates ba b r3) x\\<rbrakk>\n    \\<Longrightarrow> \\<exists>(s1', t1)|\\<in>|possible_steps e1 s1 r1 aa b.\n                         evaluate_outputs t1 b r1 =\n                         evaluate_outputs ba b r3 \\<and>\n                         executionally_equivalent e1 s1'\n                          (evaluate_updates t1 b r1) e3 ab\n                          (evaluate_updates ba b r3) x", "apply (erule fBexE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>a = (aa, b);\n        \\<And>s1 r1 s2 r2 s3 r3.\n           \\<lbrakk>executionally_equivalent e1 s1 r1 e2 s2 r2 x;\n            executionally_equivalent e2 s2 r2 e3 s3 r3 x\\<rbrakk>\n           \\<Longrightarrow> executionally_equivalent e1 s1 r1 e3 s3 r3 x;\n        \\<forall>(s1', t1)|\\<in>|possible_steps e1 s1 r1 aa b.\n           \\<exists>(s2', t2)|\\<in>|possible_steps e2 s2 r2 aa b.\n              evaluate_outputs t1 b r1 = evaluate_outputs t2 b r2 \\<and>\n              executionally_equivalent e1 s1' (evaluate_updates t1 b r1) e2\n               s2' (evaluate_updates t2 b r2) x;\n        \\<forall>(s2', t2)|\\<in>|possible_steps e2 s2 r2 aa b.\n           \\<exists>(s1', t1)|\\<in>|possible_steps e1 s1 r1 aa b.\n              evaluate_outputs t1 b r1 = evaluate_outputs t2 b r2 \\<and>\n              executionally_equivalent e1 s1' (evaluate_updates t1 b r1) e2\n               s2' (evaluate_updates t2 b r2) x;\n        \\<forall>(s1', t1)|\\<in>|possible_steps e2 s2 r2 aa b.\n           \\<exists>(s2', t2)|\\<in>|possible_steps e3 s3 r3 aa b.\n              evaluate_outputs t1 b r2 = evaluate_outputs t2 b r3 \\<and>\n              executionally_equivalent e2 s1' (evaluate_updates t1 b r2) e3\n               s2' (evaluate_updates t2 b r3) x;\n        (ab, ba) |\\<in>| possible_steps e3 s3 r3 aa b;\n        x |\\<in>| possible_steps e2 s2 r2 aa b;\n        case x of\n        (s1', t1) \\<Rightarrow>\n          evaluate_outputs t1 b r2 = evaluate_outputs ba b r3 \\<and>\n          executionally_equivalent e2 s1' (evaluate_updates t1 b r2) e3 ab\n           (evaluate_updates ba b r3) x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>(s1', t1)\n                                  |\\<in>|possible_steps e1 s1 r1 aa b.\n                            evaluate_outputs t1 b r1 =\n                            evaluate_outputs ba b r3 \\<and>\n                            executionally_equivalent e1 s1'\n                             (evaluate_updates t1 b r1) e3 ab\n                             (evaluate_updates ba b r3) x", "subgoal for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a = (aa, b);\n     \\<And>s1 r1 s2 r2 s3 r3.\n        \\<lbrakk>executionally_equivalent e1 s1 r1 e2 s2 r2 xa__;\n         executionally_equivalent e2 s2 r2 e3 s3 r3 xa__\\<rbrakk>\n        \\<Longrightarrow> executionally_equivalent e1 s1 r1 e3 s3 r3 xa__;\n     \\<forall>(s1', t1)|\\<in>|possible_steps e1 s1 r1 aa b.\n        \\<exists>(s2', t2)|\\<in>|possible_steps e2 s2 r2 aa b.\n           evaluate_outputs t1 b r1 = evaluate_outputs t2 b r2 \\<and>\n           executionally_equivalent e1 s1' (evaluate_updates t1 b r1) e2 s2'\n            (evaluate_updates t2 b r2) xa__;\n     \\<forall>(s2', t2)|\\<in>|possible_steps e2 s2 r2 aa b.\n        \\<exists>(s1', t1)|\\<in>|possible_steps e1 s1 r1 aa b.\n           evaluate_outputs t1 b r1 = evaluate_outputs t2 b r2 \\<and>\n           executionally_equivalent e1 s1' (evaluate_updates t1 b r1) e2 s2'\n            (evaluate_updates t2 b r2) xa__;\n     \\<forall>(s1', t1)|\\<in>|possible_steps e2 s2 r2 aa b.\n        \\<exists>(s2', t2)|\\<in>|possible_steps e3 s3 r3 aa b.\n           evaluate_outputs t1 b r2 = evaluate_outputs t2 b r3 \\<and>\n           executionally_equivalent e2 s1' (evaluate_updates t1 b r2) e3 s2'\n            (evaluate_updates t2 b r3) xa__;\n     (ab, ba) |\\<in>| possible_steps e3 s3 r3 aa b;\n     x |\\<in>| possible_steps e2 s2 r2 aa b;\n     case x of\n     (s1', t1) \\<Rightarrow>\n       evaluate_outputs t1 b r2 = evaluate_outputs ba b r3 \\<and>\n       executionally_equivalent e2 s1' (evaluate_updates t1 b r2) e3 ab\n        (evaluate_updates ba b r3) xa__\\<rbrakk>\n    \\<Longrightarrow> \\<exists>(s1', t1)|\\<in>|possible_steps e1 s1 r1 aa b.\n                         evaluate_outputs t1 b r1 =\n                         evaluate_outputs ba b r3 \\<and>\n                         executionally_equivalent e1 s1'\n                          (evaluate_updates t1 b r1) e3 ab\n                          (evaluate_updates ba b r3) xa__", "apply (case_tac x)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ac bb.\n       \\<lbrakk>a = (aa, b);\n        \\<And>s1 r1 s2 r2 s3 r3.\n           \\<lbrakk>executionally_equivalent e1 s1 r1 e2 s2 r2 xa__;\n            executionally_equivalent e2 s2 r2 e3 s3 r3 xa__\\<rbrakk>\n           \\<Longrightarrow> executionally_equivalent e1 s1 r1 e3 s3 r3\n                              xa__;\n        \\<forall>(s1', t1)|\\<in>|possible_steps e1 s1 r1 aa b.\n           \\<exists>(s2', t2)|\\<in>|possible_steps e2 s2 r2 aa b.\n              evaluate_outputs t1 b r1 = evaluate_outputs t2 b r2 \\<and>\n              executionally_equivalent e1 s1' (evaluate_updates t1 b r1) e2\n               s2' (evaluate_updates t2 b r2) xa__;\n        \\<forall>(s2', t2)|\\<in>|possible_steps e2 s2 r2 aa b.\n           \\<exists>(s1', t1)|\\<in>|possible_steps e1 s1 r1 aa b.\n              evaluate_outputs t1 b r1 = evaluate_outputs t2 b r2 \\<and>\n              executionally_equivalent e1 s1' (evaluate_updates t1 b r1) e2\n               s2' (evaluate_updates t2 b r2) xa__;\n        \\<forall>(s1', t1)|\\<in>|possible_steps e2 s2 r2 aa b.\n           \\<exists>(s2', t2)|\\<in>|possible_steps e3 s3 r3 aa b.\n              evaluate_outputs t1 b r2 = evaluate_outputs t2 b r3 \\<and>\n              executionally_equivalent e2 s1' (evaluate_updates t1 b r2) e3\n               s2' (evaluate_updates t2 b r3) xa__;\n        (ab, ba) |\\<in>| possible_steps e3 s3 r3 aa b;\n        x |\\<in>| possible_steps e2 s2 r2 aa b;\n        case x of\n        (s1', t1) \\<Rightarrow>\n          evaluate_outputs t1 b r2 = evaluate_outputs ba b r3 \\<and>\n          executionally_equivalent e2 s1' (evaluate_updates t1 b r2) e3 ab\n           (evaluate_updates ba b r3) xa__;\n        x = (ac, bb)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>(s1', t1)\n                                  |\\<in>|possible_steps e1 s1 r1 aa b.\n                            evaluate_outputs t1 b r1 =\n                            evaluate_outputs ba b r3 \\<and>\n                            executionally_equivalent e1 s1'\n                             (evaluate_updates t1 b r1) e3 ab\n                             (evaluate_updates ba b r3) xa__", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ac bb.\n       \\<lbrakk>a = (aa, b);\n        \\<And>s1 r1 s2 r2 s3 r3.\n           \\<lbrakk>executionally_equivalent e1 s1 r1 e2 s2 r2 xa__;\n            executionally_equivalent e2 s2 r2 e3 s3 r3 xa__\\<rbrakk>\n           \\<Longrightarrow> executionally_equivalent e1 s1 r1 e3 s3 r3\n                              xa__;\n        \\<forall>(s1', t1)|\\<in>|possible_steps e1 s1 r1 aa b.\n           \\<exists>(s2', t2)|\\<in>|possible_steps e2 s2 r2 aa b.\n              evaluate_outputs t1 b r1 = evaluate_outputs t2 b r2 \\<and>\n              executionally_equivalent e1 s1' (evaluate_updates t1 b r1) e2\n               s2' (evaluate_updates t2 b r2) xa__;\n        \\<forall>(s2', t2)|\\<in>|possible_steps e2 s2 r2 aa b.\n           \\<exists>(s1', t1)|\\<in>|possible_steps e1 s1 r1 aa b.\n              evaluate_outputs t1 b r1 = evaluate_outputs t2 b r2 \\<and>\n              executionally_equivalent e1 s1' (evaluate_updates t1 b r1) e2\n               s2' (evaluate_updates t2 b r2) xa__;\n        \\<forall>(s1', t1)|\\<in>|possible_steps e2 s2 r2 aa b.\n           \\<exists>(s2', t2)|\\<in>|possible_steps e3 s3 r3 aa b.\n              evaluate_outputs t1 b r2 = evaluate_outputs t2 b r3 \\<and>\n              executionally_equivalent e2 s1' (evaluate_updates t1 b r2) e3\n               s2' (evaluate_updates t2 b r3) xa__;\n        (ab, ba) |\\<in>| possible_steps e3 s3 r3 aa b;\n        (ac, bb) |\\<in>| possible_steps e2 s2 r2 aa b; x = (ac, bb);\n        evaluate_outputs bb b r2 = evaluate_outputs ba b r3;\n        executionally_equivalent e2 ac (evaluate_updates bb b r2) e3 ab\n         (evaluate_updates ba b r3) xa__\\<rbrakk>\n       \\<Longrightarrow> \\<exists>(s1', t1)\n                                  |\\<in>|possible_steps e1 s1 r1 aa b.\n                            evaluate_outputs t1 b r1 =\n                            evaluate_outputs ba b r3 \\<and>\n                            executionally_equivalent e1 s1'\n                             (evaluate_updates t1 b r1) e3 ab\n                             (evaluate_updates ba b r3) xa__", "subgoal for aaa baa"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a = (aa, b);\n     \\<And>s1 r1 s2 r2 s3 r3.\n        \\<lbrakk>executionally_equivalent e1 s1 r1 e2 s2 r2 xa__;\n         executionally_equivalent e2 s2 r2 e3 s3 r3 xa__\\<rbrakk>\n        \\<Longrightarrow> executionally_equivalent e1 s1 r1 e3 s3 r3 xa__;\n     \\<forall>(s1', t1)|\\<in>|possible_steps e1 s1 r1 aa b.\n        \\<exists>(s2', t2)|\\<in>|possible_steps e2 s2 r2 aa b.\n           evaluate_outputs t1 b r1 = evaluate_outputs t2 b r2 \\<and>\n           executionally_equivalent e1 s1' (evaluate_updates t1 b r1) e2 s2'\n            (evaluate_updates t2 b r2) xa__;\n     \\<forall>(s2', t2)|\\<in>|possible_steps e2 s2 r2 aa b.\n        \\<exists>(s1', t1)|\\<in>|possible_steps e1 s1 r1 aa b.\n           evaluate_outputs t1 b r1 = evaluate_outputs t2 b r2 \\<and>\n           executionally_equivalent e1 s1' (evaluate_updates t1 b r1) e2 s2'\n            (evaluate_updates t2 b r2) xa__;\n     \\<forall>(s1', t1)|\\<in>|possible_steps e2 s2 r2 aa b.\n        \\<exists>(s2', t2)|\\<in>|possible_steps e3 s3 r3 aa b.\n           evaluate_outputs t1 b r2 = evaluate_outputs t2 b r3 \\<and>\n           executionally_equivalent e2 s1' (evaluate_updates t1 b r2) e3 s2'\n            (evaluate_updates t2 b r3) xa__;\n     (ab, ba) |\\<in>| possible_steps e3 s3 r3 aa b;\n     (aaa, baa) |\\<in>| possible_steps e2 s2 r2 aa b; x = (aaa, baa);\n     evaluate_outputs baa b r2 = evaluate_outputs ba b r3;\n     executionally_equivalent e2 aaa (evaluate_updates baa b r2) e3 ab\n      (evaluate_updates ba b r3) xa__\\<rbrakk>\n    \\<Longrightarrow> \\<exists>(s1', t1)|\\<in>|possible_steps e1 s1 r1 aa b.\n                         evaluate_outputs t1 b r1 =\n                         evaluate_outputs ba b r3 \\<and>\n                         executionally_equivalent e1 s1'\n                          (evaluate_updates t1 b r1) e3 ab\n                          (evaluate_updates ba b r3) xa__", "apply (erule_tac x=\"(aaa, baa)\" in fBallE[of \"possible_steps e2 s2 r2 aa b\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>a = (aa, b);\n     \\<And>s1 r1 s2 r2 s3 r3.\n        \\<lbrakk>executionally_equivalent e1 s1 r1 e2 s2 r2 xa__;\n         executionally_equivalent e2 s2 r2 e3 s3 r3 xa__\\<rbrakk>\n        \\<Longrightarrow> executionally_equivalent e1 s1 r1 e3 s3 r3 xa__;\n     \\<forall>(s1', t1)|\\<in>|possible_steps e1 s1 r1 aa b.\n        \\<exists>(s2', t2)|\\<in>|possible_steps e2 s2 r2 aa b.\n           evaluate_outputs t1 b r1 = evaluate_outputs t2 b r2 \\<and>\n           executionally_equivalent e1 s1' (evaluate_updates t1 b r1) e2 s2'\n            (evaluate_updates t2 b r2) xa__;\n     \\<forall>(s1', t1)|\\<in>|possible_steps e2 s2 r2 aa b.\n        \\<exists>(s2', t2)|\\<in>|possible_steps e3 s3 r3 aa b.\n           evaluate_outputs t1 b r2 = evaluate_outputs t2 b r3 \\<and>\n           executionally_equivalent e2 s1' (evaluate_updates t1 b r2) e3 s2'\n            (evaluate_updates t2 b r3) xa__;\n     (ab, ba) |\\<in>| possible_steps e3 s3 r3 aa b;\n     (aaa, baa) |\\<in>| possible_steps e2 s2 r2 aa b; x = (aaa, baa);\n     evaluate_outputs baa b r2 = evaluate_outputs ba b r3;\n     executionally_equivalent e2 aaa (evaluate_updates baa b r2) e3 ab\n      (evaluate_updates ba b r3) xa__;\n     case (aaa, baa) of\n     (s2', t2) \\<Rightarrow>\n       \\<exists>(s1', t1)|\\<in>|possible_steps e1 s1 r1 aa b.\n          evaluate_outputs t1 b r1 = evaluate_outputs t2 b r2 \\<and>\n          executionally_equivalent e1 s1' (evaluate_updates t1 b r1) e2 s2'\n           (evaluate_updates t2 b r2) xa__\\<rbrakk>\n    \\<Longrightarrow> \\<exists>(s1', t1)|\\<in>|possible_steps e1 s1 r1 aa b.\n                         evaluate_outputs t1 b r1 =\n                         evaluate_outputs ba b r3 \\<and>\n                         executionally_equivalent e1 s1'\n                          (evaluate_updates t1 b r1) e3 ab\n                          (evaluate_updates ba b r3) xa__\n 2. \\<lbrakk>a = (aa, b);\n     \\<And>s1 r1 s2 r2 s3 r3.\n        \\<lbrakk>executionally_equivalent e1 s1 r1 e2 s2 r2 xa__;\n         executionally_equivalent e2 s2 r2 e3 s3 r3 xa__\\<rbrakk>\n        \\<Longrightarrow> executionally_equivalent e1 s1 r1 e3 s3 r3 xa__;\n     \\<forall>(s1', t1)|\\<in>|possible_steps e1 s1 r1 aa b.\n        \\<exists>(s2', t2)|\\<in>|possible_steps e2 s2 r2 aa b.\n           evaluate_outputs t1 b r1 = evaluate_outputs t2 b r2 \\<and>\n           executionally_equivalent e1 s1' (evaluate_updates t1 b r1) e2 s2'\n            (evaluate_updates t2 b r2) xa__;\n     \\<forall>(s1', t1)|\\<in>|possible_steps e2 s2 r2 aa b.\n        \\<exists>(s2', t2)|\\<in>|possible_steps e3 s3 r3 aa b.\n           evaluate_outputs t1 b r2 = evaluate_outputs t2 b r3 \\<and>\n           executionally_equivalent e2 s1' (evaluate_updates t1 b r2) e3 s2'\n            (evaluate_updates t2 b r3) xa__;\n     (ab, ba) |\\<in>| possible_steps e3 s3 r3 aa b;\n     (aaa, baa) |\\<in>| possible_steps e2 s2 r2 aa b; x = (aaa, baa);\n     evaluate_outputs baa b r2 = evaluate_outputs ba b r3;\n     executionally_equivalent e2 aaa (evaluate_updates baa b r2) e3 ab\n      (evaluate_updates ba b r3) xa__;\n     (aaa, baa) |\\<notin>| possible_steps e2 s2 r2 aa b\\<rbrakk>\n    \\<Longrightarrow> \\<exists>(s1', t1)|\\<in>|possible_steps e1 s1 r1 aa b.\n                         evaluate_outputs t1 b r1 =\n                         evaluate_outputs ba b r3 \\<and>\n                         executionally_equivalent e1 s1'\n                          (evaluate_updates t1 b r1) e3 ab\n                          (evaluate_updates ba b r3) xa__", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>a = (aa, b);\n     \\<And>s1 r1 s2 r2 s3 r3.\n        \\<lbrakk>executionally_equivalent e1 s1 r1 e2 s2 r2 xa__;\n         executionally_equivalent e2 s2 r2 e3 s3 r3 xa__\\<rbrakk>\n        \\<Longrightarrow> executionally_equivalent e1 s1 r1 e3 s3 r3 xa__;\n     \\<forall>(s1', t1)|\\<in>|possible_steps e1 s1 r1 aa b.\n        \\<exists>(s2', t2)|\\<in>|possible_steps e2 s2 r2 aa b.\n           evaluate_outputs t1 b r1 = evaluate_outputs t2 b r2 \\<and>\n           executionally_equivalent e1 s1' (evaluate_updates t1 b r1) e2 s2'\n            (evaluate_updates t2 b r2) xa__;\n     \\<forall>(s1', t1)|\\<in>|possible_steps e2 s2 r2 aa b.\n        \\<exists>(s2', t2)|\\<in>|possible_steps e3 s3 r3 aa b.\n           evaluate_outputs t1 b r2 = evaluate_outputs t2 b r3 \\<and>\n           executionally_equivalent e2 s1' (evaluate_updates t1 b r2) e3 s2'\n            (evaluate_updates t2 b r3) xa__;\n     (ab, ba) |\\<in>| possible_steps e3 s3 r3 aa b;\n     (aaa, baa) |\\<in>| possible_steps e2 s2 r2 aa b; x = (aaa, baa);\n     evaluate_outputs baa b r2 = evaluate_outputs ba b r3;\n     executionally_equivalent e2 aaa (evaluate_updates baa b r2) e3 ab\n      (evaluate_updates ba b r3) xa__;\n     (aaa, baa) |\\<notin>| possible_steps e2 s2 r2 aa b\\<rbrakk>\n    \\<Longrightarrow> \\<exists>(s1', t1)|\\<in>|possible_steps e1 s1 r1 aa b.\n                         evaluate_outputs t1 b r1 =\n                         evaluate_outputs ba b r3 \\<and>\n                         executionally_equivalent e1 s1'\n                          (evaluate_updates t1 b r1) e3 ab\n                          (evaluate_updates ba b r3) xa__\n 2. \\<lbrakk>a = (aa, b);\n     \\<And>s1 r1 s2 r2 s3 r3.\n        \\<lbrakk>executionally_equivalent e1 s1 r1 e2 s2 r2 xa__;\n         executionally_equivalent e2 s2 r2 e3 s3 r3 xa__\\<rbrakk>\n        \\<Longrightarrow> executionally_equivalent e1 s1 r1 e3 s3 r3 xa__;\n     \\<forall>(s1', t1)|\\<in>|possible_steps e1 s1 r1 aa b.\n        \\<exists>(s2', t2)|\\<in>|possible_steps e2 s2 r2 aa b.\n           evaluate_outputs t1 b r1 = evaluate_outputs t2 b r2 \\<and>\n           executionally_equivalent e1 s1' (evaluate_updates t1 b r1) e2 s2'\n            (evaluate_updates t2 b r2) xa__;\n     \\<forall>(s1', t1)|\\<in>|possible_steps e2 s2 r2 aa b.\n        \\<exists>(s2', t2)|\\<in>|possible_steps e3 s3 r3 aa b.\n           evaluate_outputs t1 b r2 = evaluate_outputs t2 b r3 \\<and>\n           executionally_equivalent e2 s1' (evaluate_updates t1 b r2) e3 s2'\n            (evaluate_updates t2 b r3) xa__;\n     (ab, ba) |\\<in>| possible_steps e3 s3 r3 aa b;\n     (aaa, baa) |\\<in>| possible_steps e2 s2 r2 aa b; x = (aaa, baa);\n     evaluate_outputs baa b r2 = evaluate_outputs ba b r3;\n     executionally_equivalent e2 aaa (evaluate_updates baa b r2) e3 ab\n      (evaluate_updates ba b r3) xa__;\n     case (aaa, baa) of\n     (s2', t2) \\<Rightarrow>\n       \\<exists>(s1', t1)|\\<in>|possible_steps e1 s1 r1 aa b.\n          evaluate_outputs t1 b r1 = evaluate_outputs t2 b r2 \\<and>\n          executionally_equivalent e1 s1' (evaluate_updates t1 b r1) e2 s2'\n           (evaluate_updates t2 b r2) xa__\\<rbrakk>\n    \\<Longrightarrow> \\<exists>(s1', t1)|\\<in>|possible_steps e1 s1 r1 aa b.\n                         evaluate_outputs t1 b r1 =\n                         evaluate_outputs ba b r3 \\<and>\n                         executionally_equivalent e1 s1'\n                          (evaluate_updates t1 b r1) e3 ab\n                          (evaluate_updates ba b r3) xa__", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a = (aa, b);\n     \\<And>s1 r1 s2 r2 s3 r3.\n        \\<lbrakk>executionally_equivalent e1 s1 r1 e2 s2 r2 xa__;\n         executionally_equivalent e2 s2 r2 e3 s3 r3 xa__\\<rbrakk>\n        \\<Longrightarrow> executionally_equivalent e1 s1 r1 e3 s3 r3 xa__;\n     \\<forall>(s1', t1)|\\<in>|possible_steps e1 s1 r1 aa b.\n        \\<exists>(s2', t2)|\\<in>|possible_steps e2 s2 r2 aa b.\n           evaluate_outputs t1 b r1 = evaluate_outputs t2 b r2 \\<and>\n           executionally_equivalent e1 s1' (evaluate_updates t1 b r1) e2 s2'\n            (evaluate_updates t2 b r2) xa__;\n     \\<forall>(s1', t1)|\\<in>|possible_steps e2 s2 r2 aa b.\n        \\<exists>(s2', t2)|\\<in>|possible_steps e3 s3 r3 aa b.\n           evaluate_outputs t1 b r2 = evaluate_outputs t2 b r3 \\<and>\n           executionally_equivalent e2 s1' (evaluate_updates t1 b r2) e3 s2'\n            (evaluate_updates t2 b r3) xa__;\n     (ab, ba) |\\<in>| possible_steps e3 s3 r3 aa b;\n     (aaa, baa) |\\<in>| possible_steps e2 s2 r2 aa b; x = (aaa, baa);\n     evaluate_outputs baa b r2 = evaluate_outputs ba b r3;\n     executionally_equivalent e2 aaa (evaluate_updates baa b r2) e3 ab\n      (evaluate_updates ba b r3) xa__;\n     case (aaa, baa) of\n     (s2', t2) \\<Rightarrow>\n       \\<exists>(s1', t1)|\\<in>|possible_steps e1 s1 r1 aa b.\n          evaluate_outputs t1 b r1 = evaluate_outputs t2 b r2 \\<and>\n          executionally_equivalent e1 s1' (evaluate_updates t1 b r1) e2 s2'\n           (evaluate_updates t2 b r2) xa__\\<rbrakk>\n    \\<Longrightarrow> \\<exists>(s1', t1)|\\<in>|possible_steps e1 s1 r1 aa b.\n                         evaluate_outputs t1 b r1 =\n                         evaluate_outputs ba b r3 \\<and>\n                         executionally_equivalent e1 s1'\n                          (evaluate_updates t1 b r1) e3 ab\n                          (evaluate_updates ba b r3) xa__", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a = (aa, b);\n     \\<And>s1 r1 s2 r2 s3 r3.\n        \\<lbrakk>executionally_equivalent e1 s1 r1 e2 s2 r2 xa__;\n         executionally_equivalent e2 s2 r2 e3 s3 r3 xa__\\<rbrakk>\n        \\<Longrightarrow> executionally_equivalent e1 s1 r1 e3 s3 r3 xa__;\n     \\<forall>(s1', t1)|\\<in>|possible_steps e1 s1 r1 aa b.\n        \\<exists>(s2', t2)|\\<in>|possible_steps e2 s2 r2 aa b.\n           evaluate_outputs t1 b r1 = evaluate_outputs t2 b r2 \\<and>\n           executionally_equivalent e1 s1' (evaluate_updates t1 b r1) e2 s2'\n            (evaluate_updates t2 b r2) xa__;\n     \\<forall>(s1', t1)|\\<in>|possible_steps e2 s2 r2 aa b.\n        \\<exists>(s2', t2)|\\<in>|possible_steps e3 s3 r3 aa b.\n           evaluate_outputs t1 b r2 = evaluate_outputs t2 b r3 \\<and>\n           executionally_equivalent e2 s1' (evaluate_updates t1 b r2) e3 s2'\n            (evaluate_updates t2 b r3) xa__;\n     (ab, ba) |\\<in>| possible_steps e3 s3 r3 aa b;\n     (aaa, baa) |\\<in>| possible_steps e2 s2 r2 aa b; x = (aaa, baa);\n     evaluate_outputs baa b r2 = evaluate_outputs ba b r3;\n     executionally_equivalent e2 aaa (evaluate_updates baa b r2) e3 ab\n      (evaluate_updates ba b r3) xa__;\n     \\<exists>(s1', t1)|\\<in>|possible_steps e1 s1 r1 aa b.\n        evaluate_outputs t1 b r1 = evaluate_outputs ba b r3 \\<and>\n        executionally_equivalent e1 s1' (evaluate_updates t1 b r1) e2 aaa\n         (evaluate_updates baa b r2) xa__\\<rbrakk>\n    \\<Longrightarrow> \\<exists>(s1', t1)|\\<in>|possible_steps e1 s1 r1 aa b.\n                         evaluate_outputs t1 b r1 =\n                         evaluate_outputs ba b r3 \\<and>\n                         executionally_equivalent e1 s1'\n                          (evaluate_updates t1 b r1) e3 ab\n                          (evaluate_updates ba b r3) xa__", "by blast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  executionally_equivalent e1 s1 r1 e3 s3 r3 (a # x)\n\ngoal (1 subgoal):\n 1. \\<And>s1 s2 s3 r1 r2 r3.\n       \\<lbrakk>executionally_equivalent e1 s1 r1 e2 s2 r2 [];\n        executionally_equivalent e2 s2 r2 e3 s3 r3 []\\<rbrakk>\n       \\<Longrightarrow> executionally_equivalent e1 s1 r1 e3 s3 r3 []", "qed auto"], ["", "subsection\\<open>Reachability\\<close>"], ["", "text\\<open>Here, we define the function \\texttt{visits} which returns true if the given execution\nleaves the given EFSM in the given state.\\<close>"], ["", "text_raw\\<open>\\snip{reachable}{1}{2}{%\\<close>"], ["", "inductive visits :: \"cfstate \\<Rightarrow> transition_matrix \\<Rightarrow> cfstate \\<Rightarrow> registers \\<Rightarrow> execution \\<Rightarrow> bool\" where\n  base [simp]: \"visits s e s r []\" |\n  step: \"\\<exists>(s', T) |\\<in>| possible_steps e s r l i. visits target e s' (evaluate_updates T i r) t \\<Longrightarrow>\n         visits target e s r ((l, i)#t)\""], ["", "definition \"reachable s e = (\\<exists>t. visits s e 0 <> t)\""], ["", "text_raw\\<open>}%endsnip\\<close>"], ["", "lemma no_further_steps:\n  \"s \\<noteq> s' \\<Longrightarrow> \\<not> visits s e s' r []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<noteq> s' \\<Longrightarrow> \\<not> visits s e s' r []", "apply safe"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<noteq> s'; visits s e s' r []\\<rbrakk>\n    \\<Longrightarrow> False", "apply (rule visits.cases)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>s \\<noteq> s'; visits s e s' r []\\<rbrakk>\n    \\<Longrightarrow> visits ?a1.1 ?a2.1 ?a3.1 ?a4.1 ?a5.1\n 2. \\<And>sa ea ra.\n       \\<lbrakk>s \\<noteq> s'; visits s e s' r []; ?a1.1 = sa; ?a2.1 = ea;\n        ?a3.1 = sa; ?a4.1 = ra; ?a5.1 = []\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>ea sa ra l i target t.\n       \\<lbrakk>s \\<noteq> s'; visits s e s' r []; ?a1.1 = target;\n        ?a2.1 = ea; ?a3.1 = sa; ?a4.1 = ra; ?a5.1 = (l, i) # t;\n        \\<exists>(s', T)|\\<in>|possible_steps ea sa ra l i.\n           visits target ea s' (evaluate_updates T i ra) t\\<rbrakk>\n       \\<Longrightarrow> False", "by auto"], ["", "lemma visits_base: \"visits target e s r [] = (s = target)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. visits target e s r [] = (s = target)", "by (metis visits.base no_further_steps)"], ["", "lemma visits_step:\n  \"visits target e s r (h#t) = (\\<exists>(s', T) |\\<in>| possible_steps e s r (fst h) (snd h). visits target e s' (evaluate_updates T (snd h) r) t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. visits target e s r (h # t) =\n    (\\<exists>(s', T)|\\<in>|possible_steps e s r (fst h) (snd h).\n        visits target e s' (evaluate_updates T (snd h) r) t)", "apply standard"], ["proof (prove)\ngoal (2 subgoals):\n 1. visits target e s r (h # t) \\<Longrightarrow>\n    \\<exists>(s', T)|\\<in>|possible_steps e s r (fst h) (snd h).\n       visits target e s' (evaluate_updates T (snd h) r) t\n 2. \\<exists>(s', T)|\\<in>|possible_steps e s r (fst h) (snd h).\n       visits target e s' (evaluate_updates T (snd h) r) t \\<Longrightarrow>\n    visits target e s r (h # t)", "apply (rule visits.cases)"], ["proof (prove)\ngoal (4 subgoals):\n 1. visits target e s r (h # t) \\<Longrightarrow>\n    visits ?a1.3 ?a2.3 ?a3.3 ?a4.3 ?a5.3\n 2. \\<And>sa ea ra.\n       \\<lbrakk>visits target e s r (h # t); ?a1.3 = sa; ?a2.3 = ea;\n        ?a3.3 = sa; ?a4.3 = ra; ?a5.3 = []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>(s', T)\n                                  |\\<in>|possible_steps e s r (fst h)\n    (snd h).\n                            visits target e s'\n                             (evaluate_updates T (snd h) r) t\n 3. \\<And>ea sa ra l i targeta ta.\n       \\<lbrakk>visits target e s r (h # t); ?a1.3 = targeta; ?a2.3 = ea;\n        ?a3.3 = sa; ?a4.3 = ra; ?a5.3 = (l, i) # ta;\n        \\<exists>(s', T)|\\<in>|possible_steps ea sa ra l i.\n           visits targeta ea s' (evaluate_updates T i ra) ta\\<rbrakk>\n       \\<Longrightarrow> \\<exists>(s', T)\n                                  |\\<in>|possible_steps e s r (fst h)\n    (snd h).\n                            visits target e s'\n                             (evaluate_updates T (snd h) r) t\n 4. \\<exists>(s', T)|\\<in>|possible_steps e s r (fst h) (snd h).\n       visits target e s' (evaluate_updates T (snd h) r) t \\<Longrightarrow>\n    visits target e s r (h # t)", "apply simp+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>(s', T)|\\<in>|possible_steps e s r (fst h) (snd h).\n       visits target e s' (evaluate_updates T (snd h) r) t \\<Longrightarrow>\n    visits target e s r (h # t)", "apply (cases h)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<exists>(s', T)|\\<in>|possible_steps e s r (fst h) (snd h).\n                   visits target e s' (evaluate_updates T (snd h) r) t;\n        h = (a, b)\\<rbrakk>\n       \\<Longrightarrow> visits target e s r (h # t)", "using visits.step"], ["proof (prove)\nusing this:\n  \\<exists>(s', T)|\\<in>|possible_steps ?e ?s ?r ?l ?i.\n     visits ?target ?e s' (evaluate_updates T ?i ?r) ?t \\<Longrightarrow>\n  visits ?target ?e ?s ?r ((?l, ?i) # ?t)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<exists>(s', T)|\\<in>|possible_steps e s r (fst h) (snd h).\n                   visits target e s' (evaluate_updates T (snd h) r) t;\n        h = (a, b)\\<rbrakk>\n       \\<Longrightarrow> visits target e s r (h # t)", "by auto"], ["", "lemma reachable_initial: \"reachable 0 e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reachable 0 e", "apply (simp add: reachable_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>t. visits 0 e 0 <> t", "apply (rule_tac x=\"[]\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. visits 0 e 0 <> []", "by simp"], ["", "lemma visits_finsert:\n  \"visits s e s' r t \\<Longrightarrow> visits s (finsert ((aa, ba), b) e) s' r t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. visits s e s' r t \\<Longrightarrow>\n    visits s (finsert ((aa, ba), b) e) s' r t", "proof(induct t arbitrary: s' r)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s' r.\n       visits s e s' r [] \\<Longrightarrow>\n       visits s (finsert ((aa, ba), b) e) s' r []\n 2. \\<And>a t s' r.\n       \\<lbrakk>\\<And>s' r.\n                   visits s e s' r t \\<Longrightarrow>\n                   visits s (finsert ((aa, ba), b) e) s' r t;\n        visits s e s' r (a # t)\\<rbrakk>\n       \\<Longrightarrow> visits s (finsert ((aa, ba), b) e) s' r (a # t)", "case Nil"], ["proof (state)\nthis:\n  visits s e s' r []\n\ngoal (2 subgoals):\n 1. \\<And>s' r.\n       visits s e s' r [] \\<Longrightarrow>\n       visits s (finsert ((aa, ba), b) e) s' r []\n 2. \\<And>a t s' r.\n       \\<lbrakk>\\<And>s' r.\n                   visits s e s' r t \\<Longrightarrow>\n                   visits s (finsert ((aa, ba), b) e) s' r t;\n        visits s e s' r (a # t)\\<rbrakk>\n       \\<Longrightarrow> visits s (finsert ((aa, ba), b) e) s' r (a # t)", "then"], ["proof (chain)\npicking this:\n  visits s e s' r []", "show ?case"], ["proof (prove)\nusing this:\n  visits s e s' r []\n\ngoal (1 subgoal):\n 1. visits s (finsert ((aa, ba), b) e) s' r []", "by (simp add: visits_base)"], ["proof (state)\nthis:\n  visits s (finsert ((aa, ba), b) e) s' r []\n\ngoal (1 subgoal):\n 1. \\<And>a t s' r.\n       \\<lbrakk>\\<And>s' r.\n                   visits s e s' r t \\<Longrightarrow>\n                   visits s (finsert ((aa, ba), b) e) s' r t;\n        visits s e s' r (a # t)\\<rbrakk>\n       \\<Longrightarrow> visits s (finsert ((aa, ba), b) e) s' r (a # t)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a t s' r.\n       \\<lbrakk>\\<And>s' r.\n                   visits s e s' r t \\<Longrightarrow>\n                   visits s (finsert ((aa, ba), b) e) s' r t;\n        visits s e s' r (a # t)\\<rbrakk>\n       \\<Longrightarrow> visits s (finsert ((aa, ba), b) e) s' r (a # t)", "case (Cons a t)"], ["proof (state)\nthis:\n  visits s e ?s' ?r t \\<Longrightarrow>\n  visits s (finsert ((aa, ba), b) e) ?s' ?r t\n  visits s e s' r (a # t)\n\ngoal (1 subgoal):\n 1. \\<And>a t s' r.\n       \\<lbrakk>\\<And>s' r.\n                   visits s e s' r t \\<Longrightarrow>\n                   visits s (finsert ((aa, ba), b) e) s' r t;\n        visits s e s' r (a # t)\\<rbrakk>\n       \\<Longrightarrow> visits s (finsert ((aa, ba), b) e) s' r (a # t)", "then"], ["proof (chain)\npicking this:\n  visits s e ?s' ?r t \\<Longrightarrow>\n  visits s (finsert ((aa, ba), b) e) ?s' ?r t\n  visits s e s' r (a # t)", "show ?case"], ["proof (prove)\nusing this:\n  visits s e ?s' ?r t \\<Longrightarrow>\n  visits s (finsert ((aa, ba), b) e) ?s' ?r t\n  visits s e s' r (a # t)\n\ngoal (1 subgoal):\n 1. visits s (finsert ((aa, ba), b) e) s' r (a # t)", "apply (simp add: visits_step)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>s' r.\n                visits s e s' r t \\<Longrightarrow>\n                visits s (finsert ((aa, ba), b) e) s' r t;\n     \\<exists>(s', T)|\\<in>|possible_steps e s' r (fst a) (snd a).\n        visits s e s' (evaluate_updates T (snd a) r) t\\<rbrakk>\n    \\<Longrightarrow> \\<exists>(s', T)\n                               |\\<in>|possible_steps\n (finsert ((aa, ba), b) e) s' r (fst a) (snd a).\n                         visits s (finsert ((aa, ba), b) e) s'\n                          (evaluate_updates T (snd a) r) t", "apply (erule fBexE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>s' r.\n                   visits s e s' r t \\<Longrightarrow>\n                   visits s (finsert ((aa, ba), b) e) s' r t;\n        x |\\<in>| possible_steps e s' r (fst a) (snd a);\n        case x of\n        (s', T) \\<Rightarrow>\n          visits s e s' (evaluate_updates T (snd a) r) t\\<rbrakk>\n       \\<Longrightarrow> \\<exists>(s', T)\n                                  |\\<in>|possible_steps\n    (finsert ((aa, ba), b) e) s' r (fst a) (snd a).\n                            visits s (finsert ((aa, ba), b) e) s'\n                             (evaluate_updates T (snd a) r) t", "apply (rule_tac x=x in fBexI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>s' r.\n                   visits s e s' r t \\<Longrightarrow>\n                   visits s (finsert ((aa, ba), b) e) s' r t;\n        x |\\<in>| possible_steps e s' r (fst a) (snd a);\n        case x of\n        (s', T) \\<Rightarrow>\n          visits s e s' (evaluate_updates T (snd a) r) t\\<rbrakk>\n       \\<Longrightarrow> case x of\n                         (s', T) \\<Rightarrow>\n                           visits s (finsert ((aa, ba), b) e) s'\n                            (evaluate_updates T (snd a) r) t\n 2. \\<And>x.\n       \\<lbrakk>\\<And>s' r.\n                   visits s e s' r t \\<Longrightarrow>\n                   visits s (finsert ((aa, ba), b) e) s' r t;\n        x |\\<in>| possible_steps e s' r (fst a) (snd a);\n        case x of\n        (s', T) \\<Rightarrow>\n          visits s e s' (evaluate_updates T (snd a) r) t\\<rbrakk>\n       \\<Longrightarrow> x |\\<in>|\n                         possible_steps (finsert ((aa, ba), b) e) s' r\n                          (fst a) (snd a)", "apply auto[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>s' r.\n                   visits s e s' r t \\<Longrightarrow>\n                   visits s (finsert ((aa, ba), b) e) s' r t;\n        x |\\<in>| possible_steps e s' r (fst a) (snd a);\n        case x of\n        (s', T) \\<Rightarrow>\n          visits s e s' (evaluate_updates T (snd a) r) t\\<rbrakk>\n       \\<Longrightarrow> x |\\<in>|\n                         possible_steps (finsert ((aa, ba), b) e) s' r\n                          (fst a) (snd a)", "by (simp add: possible_steps_finsert)"], ["proof (state)\nthis:\n  visits s (finsert ((aa, ba), b) e) s' r (a # t)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma reachable_finsert:\n  \"reachable s e \\<Longrightarrow> reachable s (finsert ((aa, ba), b) e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reachable s e \\<Longrightarrow> reachable s (finsert ((aa, ba), b) e)", "apply (simp add: reachable_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>t. visits s e 0 <> t \\<Longrightarrow>\n    \\<exists>t. visits s (finsert ((aa, ba), b) e) 0 <> t", "by (meson visits_finsert)"], ["", "lemma reachable_finsert_contra:\n  \"\\<not> reachable s (finsert ((aa, ba), b) e) \\<Longrightarrow> \\<not>reachable s e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> reachable s (finsert ((aa, ba), b) e) \\<Longrightarrow>\n    \\<not> reachable s e", "using reachable_finsert"], ["proof (prove)\nusing this:\n  reachable ?s ?e \\<Longrightarrow>\n  reachable ?s (finsert ((?aa, ?ba), ?b) ?e)\n\ngoal (1 subgoal):\n 1. \\<not> reachable s (finsert ((aa, ba), b) e) \\<Longrightarrow>\n    \\<not> reachable s e", "by blast"], ["", "lemma visits_empty: \"visits s e s' r [] = (s = s')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. visits s e s' r [] = (s = s')", "apply standard"], ["proof (prove)\ngoal (2 subgoals):\n 1. visits s e s' r [] \\<Longrightarrow> s = s'\n 2. s = s' \\<Longrightarrow> visits s e s' r []", "by (rule visits.cases, auto)"], ["", "definition \"remove_state s e = ffilter (\\<lambda>((from, to), t). from \\<noteq> s \\<and> to \\<noteq> s) e\""], ["", "text_raw\\<open>\\snip{obtainable}{1}{2}{%\\<close>"], ["", "inductive \"obtains\" :: \"cfstate \\<Rightarrow> registers \\<Rightarrow> transition_matrix \\<Rightarrow> cfstate \\<Rightarrow> registers \\<Rightarrow> execution \\<Rightarrow> bool\" where\n  base [simp]: \"obtains s r e s r []\" |\n  step: \"\\<exists>(s'', T) |\\<in>| possible_steps e s' r' l i. obtains s r e s'' (evaluate_updates T i r') t \\<Longrightarrow>\n         obtains s r e s' r' ((l, i)#t)\""], ["", "definition \"obtainable s r e = (\\<exists>t. obtains s r e 0 <> t)\""], ["", "text_raw\\<open>}%endsnip\\<close>"], ["", "lemma obtains_obtainable:\n  \"obtains s r e 0 <> t \\<Longrightarrow> obtainable s r e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. obtains s r e 0 <> t \\<Longrightarrow> obtainable s r e", "apply (simp add: obtainable_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. obtains s r e 0 <> t \\<Longrightarrow> \\<exists>t. obtains s r e 0 <> t", "by auto"], ["", "lemma obtains_base: \"obtains s r e s' r' [] = (s = s' \\<and> r = r')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. obtains s r e s' r' [] = (s = s' \\<and> r = r')", "apply standard"], ["proof (prove)\ngoal (2 subgoals):\n 1. obtains s r e s' r' [] \\<Longrightarrow> s = s' \\<and> r = r'\n 2. s = s' \\<and> r = r' \\<Longrightarrow> obtains s r e s' r' []", "by (rule obtains.cases, auto)"], ["", "lemma obtains_step: \"obtains s r e s' r' ((l, i)#t) = (\\<exists>(s'', T) |\\<in>| possible_steps e s' r' l i. obtains s r e s'' (evaluate_updates T i r') t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. obtains s r e s' r' ((l, i) # t) =\n    (\\<exists>(s'', T)|\\<in>|possible_steps e s' r' l i.\n        obtains s r e s'' (evaluate_updates T i r') t)", "apply standard"], ["proof (prove)\ngoal (2 subgoals):\n 1. obtains s r e s' r' ((l, i) # t) \\<Longrightarrow>\n    \\<exists>(s'', T)|\\<in>|possible_steps e s' r' l i.\n       obtains s r e s'' (evaluate_updates T i r') t\n 2. \\<exists>(s'', T)|\\<in>|possible_steps e s' r' l i.\n       obtains s r e s'' (evaluate_updates T i r') t \\<Longrightarrow>\n    obtains s r e s' r' ((l, i) # t)", "by (rule obtains.cases, auto simp add: obtains.step)"], ["", "lemma obtains_recognises:\n  \"obtains s c e s' r t \\<Longrightarrow> recognises_execution e s' r t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. obtains s c e s' r t \\<Longrightarrow> recognises_execution e s' r t", "proof(induct t arbitrary: s' r)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s' r.\n       obtains s c e s' r [] \\<Longrightarrow>\n       recognises_execution e s' r []\n 2. \\<And>a t s' r.\n       \\<lbrakk>\\<And>s' r.\n                   obtains s c e s' r t \\<Longrightarrow>\n                   recognises_execution e s' r t;\n        obtains s c e s' r (a # t)\\<rbrakk>\n       \\<Longrightarrow> recognises_execution e s' r (a # t)", "case Nil"], ["proof (state)\nthis:\n  obtains s c e s' r []\n\ngoal (2 subgoals):\n 1. \\<And>s' r.\n       obtains s c e s' r [] \\<Longrightarrow>\n       recognises_execution e s' r []\n 2. \\<And>a t s' r.\n       \\<lbrakk>\\<And>s' r.\n                   obtains s c e s' r t \\<Longrightarrow>\n                   recognises_execution e s' r t;\n        obtains s c e s' r (a # t)\\<rbrakk>\n       \\<Longrightarrow> recognises_execution e s' r (a # t)", "then"], ["proof (chain)\npicking this:\n  obtains s c e s' r []", "show ?case"], ["proof (prove)\nusing this:\n  obtains s c e s' r []\n\ngoal (1 subgoal):\n 1. recognises_execution e s' r []", "by (simp add: obtains_base)"], ["proof (state)\nthis:\n  recognises_execution e s' r []\n\ngoal (1 subgoal):\n 1. \\<And>a t s' r.\n       \\<lbrakk>\\<And>s' r.\n                   obtains s c e s' r t \\<Longrightarrow>\n                   recognises_execution e s' r t;\n        obtains s c e s' r (a # t)\\<rbrakk>\n       \\<Longrightarrow> recognises_execution e s' r (a # t)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a t s' r.\n       \\<lbrakk>\\<And>s' r.\n                   obtains s c e s' r t \\<Longrightarrow>\n                   recognises_execution e s' r t;\n        obtains s c e s' r (a # t)\\<rbrakk>\n       \\<Longrightarrow> recognises_execution e s' r (a # t)", "case (Cons a t)"], ["proof (state)\nthis:\n  obtains s c e ?s' ?r t \\<Longrightarrow> recognises_execution e ?s' ?r t\n  obtains s c e s' r (a # t)\n\ngoal (1 subgoal):\n 1. \\<And>a t s' r.\n       \\<lbrakk>\\<And>s' r.\n                   obtains s c e s' r t \\<Longrightarrow>\n                   recognises_execution e s' r t;\n        obtains s c e s' r (a # t)\\<rbrakk>\n       \\<Longrightarrow> recognises_execution e s' r (a # t)", "then"], ["proof (chain)\npicking this:\n  obtains s c e ?s' ?r t \\<Longrightarrow> recognises_execution e ?s' ?r t\n  obtains s c e s' r (a # t)", "show ?case"], ["proof (prove)\nusing this:\n  obtains s c e ?s' ?r t \\<Longrightarrow> recognises_execution e ?s' ?r t\n  obtains s c e s' r (a # t)\n\ngoal (1 subgoal):\n 1. recognises_execution e s' r (a # t)", "apply (cases a)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b.\n       \\<lbrakk>\\<And>s' r.\n                   obtains s c e s' r t \\<Longrightarrow>\n                   recognises_execution e s' r t;\n        obtains s c e s' r (a # t); a = (aa, b)\\<rbrakk>\n       \\<Longrightarrow> recognises_execution e s' r (a # t)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b.\n       \\<lbrakk>\\<And>s' r.\n                   obtains s c e s' r t \\<Longrightarrow>\n                   recognises_execution e s' r t;\n        obtains s c e s' r ((aa, b) # t); a = (aa, b)\\<rbrakk>\n       \\<Longrightarrow> recognises_execution e s' r ((aa, b) # t)", "apply (rule obtains.cases)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>aa b.\n       \\<lbrakk>\\<And>s' r.\n                   obtains s c e s' r t \\<Longrightarrow>\n                   recognises_execution e s' r t;\n        obtains s c e s' r ((aa, b) # t); a = (aa, b)\\<rbrakk>\n       \\<Longrightarrow> obtains (?a1.4 aa b) (?a2.4 aa b) (?a3.4 aa b)\n                          (?a4.4 aa b) (?a5.4 aa b) (?a6.4 aa b)\n 2. \\<And>aa b sa r ea.\n       \\<lbrakk>\\<And>s' r.\n                   obtains s c e s' r t \\<Longrightarrow>\n                   recognises_execution e s' r t;\n        obtains s c e s' r ((aa, b) # t); a = (aa, b); ?a1.4 aa b = sa;\n        ?a2.4 aa b = r; ?a3.4 aa b = ea; ?a4.4 aa b = sa; ?a5.4 aa b = r;\n        ?a6.4 aa b = []\\<rbrakk>\n       \\<Longrightarrow> recognises_execution e s' r ((aa, b) # t)\n 3. \\<And>aa b ea s' r' l i sa r t.\n       \\<lbrakk>\\<And>s' r.\n                   obtains s c e s' r t \\<Longrightarrow>\n                   recognises_execution e s' r t;\n        obtains s c e s' r ((aa, b) # t); a = (aa, b); ?a1.4 aa b = sa;\n        ?a2.4 aa b = r; ?a3.4 aa b = ea; ?a4.4 aa b = s'; ?a5.4 aa b = r';\n        ?a6.4 aa b = (l, i) # t;\n        \\<exists>(s'', T)|\\<in>|possible_steps ea s' r' l i.\n           obtains sa r ea s'' (evaluate_updates T i r') t\\<rbrakk>\n       \\<Longrightarrow> recognises_execution e s' r ((aa, b) # t)", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa b sa r ea.\n       \\<lbrakk>\\<And>s' r.\n                   obtains s c e s' r t \\<Longrightarrow>\n                   recognises_execution e s' r t;\n        obtains s c e s' r ((aa, b) # t); a = (aa, b); s = sa; c = r;\n        e = ea; s' = sa; r = r; (aa, b) # t = []\\<rbrakk>\n       \\<Longrightarrow> recognises_execution e s' r ((aa, b) # t)\n 2. \\<And>aa b ea s' r' l i sa r t.\n       \\<lbrakk>\\<And>s' r.\n                   obtains s c e s' r t \\<Longrightarrow>\n                   recognises_execution e s' r t;\n        obtains s c e s' r ((aa, b) # t); a = (aa, b); s = sa; c = r;\n        e = ea; s' = s'; r = r'; (aa, b) # t = (l, i) # t;\n        \\<exists>(s'', T)|\\<in>|possible_steps ea s' r' l i.\n           obtains sa r ea s'' (evaluate_updates T i r') t\\<rbrakk>\n       \\<Longrightarrow> recognises_execution e s' r ((aa, b) # t)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b ea s' r' l i sa r t.\n       \\<lbrakk>\\<And>s' r.\n                   obtains s c e s' r t \\<Longrightarrow>\n                   recognises_execution e s' r t;\n        obtains s c e s' r ((aa, b) # t); a = (aa, b); s = sa; c = r;\n        e = ea; s' = s'; r = r'; (aa, b) # t = (l, i) # t;\n        \\<exists>(s'', T)|\\<in>|possible_steps ea s' r' l i.\n           obtains sa r ea s'' (evaluate_updates T i r') t\\<rbrakk>\n       \\<Longrightarrow> recognises_execution e s' r ((aa, b) # t)", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b l aa ba.\n       \\<lbrakk>\\<And>s' r.\n                   obtains s c e s' r t \\<Longrightarrow>\n                   recognises_execution e s' r t;\n        obtains s c e s' r ((l, b) # t); a = (l, b);\n        (aa, ba) |\\<in>| possible_steps e s' r l b;\n        obtains s c e aa (evaluate_updates ba b r) t\\<rbrakk>\n       \\<Longrightarrow> recognises_execution e s' r ((l, b) # t)", "using recognises_execution.step"], ["proof (prove)\nusing this:\n  \\<exists>(s', T)|\\<in>|possible_steps ?e ?s ?r ?l ?i.\n     recognises_execution ?e s' (evaluate_updates T ?i ?r)\n      ?t \\<Longrightarrow>\n  recognises_execution ?e ?s ?r ((?l, ?i) # ?t)\n\ngoal (1 subgoal):\n 1. \\<And>b l aa ba.\n       \\<lbrakk>\\<And>s' r.\n                   obtains s c e s' r t \\<Longrightarrow>\n                   recognises_execution e s' r t;\n        obtains s c e s' r ((l, b) # t); a = (l, b);\n        (aa, ba) |\\<in>| possible_steps e s' r l b;\n        obtains s c e aa (evaluate_updates ba b r) t\\<rbrakk>\n       \\<Longrightarrow> recognises_execution e s' r ((l, b) # t)", "by fastforce"], ["proof (state)\nthis:\n  recognises_execution e s' r (a # t)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ex_comm4:\n  \"(\\<exists>c1 s a b. (a, b) \\<in> fset (possible_steps e s' r l i) \\<and> obtains s c1 e a (evaluate_updates b i r) t) =\n   (\\<exists>a b s c1. (a, b) \\<in> fset (possible_steps e s' r l i) \\<and> obtains s c1 e a (evaluate_updates b i r) t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>c1 s a b.\n        (a, b) \\<in> fset (possible_steps e s' r l i) \\<and>\n        obtains s c1 e a (evaluate_updates b i r) t) =\n    (\\<exists>a b s c1.\n        (a, b) \\<in> fset (possible_steps e s' r l i) \\<and>\n        obtains s c1 e a (evaluate_updates b i r) t)", "by auto"], ["", "lemma recognises_execution_obtains:\n  \"recognises_execution e s' r t \\<Longrightarrow> \\<exists>c1 s. obtains s c1 e s' r t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. recognises_execution e s' r t \\<Longrightarrow>\n    \\<exists>c1 s. obtains s c1 e s' r t", "proof(induct t arbitrary: s' r)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s' r.\n       recognises_execution e s' r [] \\<Longrightarrow>\n       \\<exists>c1 s. obtains s c1 e s' r []\n 2. \\<And>a t s' r.\n       \\<lbrakk>\\<And>s' r.\n                   recognises_execution e s' r t \\<Longrightarrow>\n                   \\<exists>c1 s. obtains s c1 e s' r t;\n        recognises_execution e s' r (a # t)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c1 s. obtains s c1 e s' r (a # t)", "case Nil"], ["proof (state)\nthis:\n  recognises_execution e s' r []\n\ngoal (2 subgoals):\n 1. \\<And>s' r.\n       recognises_execution e s' r [] \\<Longrightarrow>\n       \\<exists>c1 s. obtains s c1 e s' r []\n 2. \\<And>a t s' r.\n       \\<lbrakk>\\<And>s' r.\n                   recognises_execution e s' r t \\<Longrightarrow>\n                   \\<exists>c1 s. obtains s c1 e s' r t;\n        recognises_execution e s' r (a # t)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c1 s. obtains s c1 e s' r (a # t)", "then"], ["proof (chain)\npicking this:\n  recognises_execution e s' r []", "show ?case"], ["proof (prove)\nusing this:\n  recognises_execution e s' r []\n\ngoal (1 subgoal):\n 1. \\<exists>c1 s. obtains s c1 e s' r []", "by (simp add: obtains_base)"], ["proof (state)\nthis:\n  \\<exists>c1 s. obtains s c1 e s' r []\n\ngoal (1 subgoal):\n 1. \\<And>a t s' r.\n       \\<lbrakk>\\<And>s' r.\n                   recognises_execution e s' r t \\<Longrightarrow>\n                   \\<exists>c1 s. obtains s c1 e s' r t;\n        recognises_execution e s' r (a # t)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c1 s. obtains s c1 e s' r (a # t)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a t s' r.\n       \\<lbrakk>\\<And>s' r.\n                   recognises_execution e s' r t \\<Longrightarrow>\n                   \\<exists>c1 s. obtains s c1 e s' r t;\n        recognises_execution e s' r (a # t)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c1 s. obtains s c1 e s' r (a # t)", "case (Cons a t)"], ["proof (state)\nthis:\n  recognises_execution e ?s' ?r t \\<Longrightarrow>\n  \\<exists>c1 s. obtains s c1 e ?s' ?r t\n  recognises_execution e s' r (a # t)\n\ngoal (1 subgoal):\n 1. \\<And>a t s' r.\n       \\<lbrakk>\\<And>s' r.\n                   recognises_execution e s' r t \\<Longrightarrow>\n                   \\<exists>c1 s. obtains s c1 e s' r t;\n        recognises_execution e s' r (a # t)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c1 s. obtains s c1 e s' r (a # t)", "then"], ["proof (chain)\npicking this:\n  recognises_execution e ?s' ?r t \\<Longrightarrow>\n  \\<exists>c1 s. obtains s c1 e ?s' ?r t\n  recognises_execution e s' r (a # t)", "show ?case"], ["proof (prove)\nusing this:\n  recognises_execution e ?s' ?r t \\<Longrightarrow>\n  \\<exists>c1 s. obtains s c1 e ?s' ?r t\n  recognises_execution e s' r (a # t)\n\ngoal (1 subgoal):\n 1. \\<exists>c1 s. obtains s c1 e s' r (a # t)", "apply (cases a)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b.\n       \\<lbrakk>\\<And>s' r.\n                   recognises_execution e s' r t \\<Longrightarrow>\n                   \\<exists>c1 s. obtains s c1 e s' r t;\n        recognises_execution e s' r (a # t); a = (aa, b)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c1 s. obtains s c1 e s' r (a # t)", "apply (simp add: obtains_step)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b.\n       \\<lbrakk>\\<And>s' r.\n                   recognises_execution e s' r t \\<Longrightarrow>\n                   \\<exists>c1 s. obtains s c1 e s' r t;\n        recognises_execution e s' r ((aa, b) # t); a = (aa, b)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c1 s.\n                            \\<exists>(s'', T)\n                                     |\\<in>|possible_steps e s' r aa b.\n                               obtains s c1 e s'' (evaluate_updates T b r) t", "apply (rule recognises_execution.cases)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>aa b.\n       \\<lbrakk>\\<And>s' r.\n                   recognises_execution e s' r t \\<Longrightarrow>\n                   \\<exists>c1 s. obtains s c1 e s' r t;\n        recognises_execution e s' r ((aa, b) # t); a = (aa, b)\\<rbrakk>\n       \\<Longrightarrow> recognises_execution (?a1.4 aa b) (?a2.4 aa b)\n                          (?a3.4 aa b) (?a4.4 aa b)\n 2. \\<And>aa b ea s r.\n       \\<lbrakk>\\<And>s' r.\n                   recognises_execution e s' r t \\<Longrightarrow>\n                   \\<exists>c1 s. obtains s c1 e s' r t;\n        recognises_execution e s' r ((aa, b) # t); a = (aa, b);\n        ?a1.4 aa b = ea; ?a2.4 aa b = s; ?a3.4 aa b = r;\n        ?a4.4 aa b = []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c1 s.\n                            \\<exists>(s'', T)\n                                     |\\<in>|possible_steps e s' r aa b.\n                               obtains s c1 e s'' (evaluate_updates T b r) t\n 3. \\<And>aa b ea s r l i t.\n       \\<lbrakk>\\<And>s' r.\n                   recognises_execution e s' r t \\<Longrightarrow>\n                   \\<exists>c1 s. obtains s c1 e s' r t;\n        recognises_execution e s' r ((aa, b) # t); a = (aa, b);\n        ?a1.4 aa b = ea; ?a2.4 aa b = s; ?a3.4 aa b = r;\n        ?a4.4 aa b = (l, i) # t;\n        \\<exists>(s', T)|\\<in>|possible_steps ea s r l i.\n           recognises_execution ea s' (evaluate_updates T i r) t\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c1 s.\n                            \\<exists>(s'', T)\n                                     |\\<in>|possible_steps e s' r aa b.\n                               obtains s c1 e s'' (evaluate_updates T b r) t", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa b ea s r.\n       \\<lbrakk>\\<And>s' r.\n                   recognises_execution e s' r t \\<Longrightarrow>\n                   \\<exists>c1 s. obtains s c1 e s' r t;\n        recognises_execution e s' r ((aa, b) # t); a = (aa, b); e = ea;\n        s' = s; r = r; (aa, b) # t = []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c1 s.\n                            \\<exists>(s'', T)\n                                     |\\<in>|possible_steps e s' r aa b.\n                               obtains s c1 e s'' (evaluate_updates T b r) t\n 2. \\<And>aa b ea s r l i t.\n       \\<lbrakk>\\<And>s' r.\n                   recognises_execution e s' r t \\<Longrightarrow>\n                   \\<exists>c1 s. obtains s c1 e s' r t;\n        recognises_execution e s' r ((aa, b) # t); a = (aa, b); e = ea;\n        s' = s; r = r; (aa, b) # t = (l, i) # t;\n        \\<exists>(s', T)|\\<in>|possible_steps ea s r l i.\n           recognises_execution ea s' (evaluate_updates T i r) t\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c1 s.\n                            \\<exists>(s'', T)\n                                     |\\<in>|possible_steps e s' r aa b.\n                               obtains s c1 e s'' (evaluate_updates T b r) t", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b ea s r l i t.\n       \\<lbrakk>\\<And>s' r.\n                   recognises_execution e s' r t \\<Longrightarrow>\n                   \\<exists>c1 s. obtains s c1 e s' r t;\n        recognises_execution e s' r ((aa, b) # t); a = (aa, b); e = ea;\n        s' = s; r = r; (aa, b) # t = (l, i) # t;\n        \\<exists>(s', T)|\\<in>|possible_steps ea s r l i.\n           recognises_execution ea s' (evaluate_updates T i r) t\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c1 s.\n                            \\<exists>(s'', T)\n                                     |\\<in>|possible_steps e s' r aa b.\n                               obtains s c1 e s'' (evaluate_updates T b r) t", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b l aa ba.\n       \\<lbrakk>\\<And>s' r.\n                   recognises_execution e s' r t \\<Longrightarrow>\n                   \\<exists>c1 s. obtains s c1 e s' r t;\n        recognises_execution e s' r ((l, b) # t); a = (l, b);\n        (aa, ba) |\\<in>| possible_steps e s' r l b;\n        recognises_execution e aa (evaluate_updates ba b r) t\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c1 s.\n                            \\<exists>(s'', T)\n                                     |\\<in>|possible_steps e s' r l b.\n                               obtains s c1 e s'' (evaluate_updates T b r) t", "apply (simp add: fBex_def Bex_def ex_comm4)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b l aa ba.\n       \\<lbrakk>\\<And>s' r.\n                   recognises_execution e s' r t \\<Longrightarrow>\n                   \\<exists>c1 s. obtains s c1 e s' r t;\n        recognises_execution e s' r ((l, b) # t); a = (l, b);\n        (aa, ba) |\\<in>| possible_steps e s' r l b;\n        recognises_execution e aa (evaluate_updates ba b r) t\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a ba.\n                            (a, ba)\n                            \\<in> fset (possible_steps e s' r l b) \\<and>\n                            (\\<exists>s c1.\n                                obtains s c1 e a (evaluate_updates ba b r)\n                                 t)", "subgoal for _ _ aa ba"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>s' r.\n                recognises_execution e s' r t \\<Longrightarrow>\n                \\<exists>c1 s. obtains s c1 e s' r t;\n     recognises_execution e s' r ((l_, b_) # t); a = (l_, b_);\n     (aa, ba) |\\<in>| possible_steps e s' r l_ b_;\n     recognises_execution e aa (evaluate_updates ba b_ r) t\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a ba.\n                         (a, ba)\n                         \\<in> fset (possible_steps e s' r l_ b_) \\<and>\n                         (\\<exists>s c1.\n                             obtains s c1 e a (evaluate_updates ba b_ r) t)", "apply (rule_tac x=aa in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>s' r.\n                recognises_execution e s' r t \\<Longrightarrow>\n                \\<exists>c1 s. obtains s c1 e s' r t;\n     recognises_execution e s' r ((l_, b_) # t); a = (l_, b_);\n     (aa, ba) |\\<in>| possible_steps e s' r l_ b_;\n     recognises_execution e aa (evaluate_updates ba b_ r) t\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ba.\n                         (aa, ba)\n                         \\<in> fset (possible_steps e s' r l_ b_) \\<and>\n                         (\\<exists>s c1.\n                             obtains s c1 e aa (evaluate_updates ba b_ r) t)", "apply (rule_tac x=ba in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>s' r.\n                recognises_execution e s' r t \\<Longrightarrow>\n                \\<exists>c1 s. obtains s c1 e s' r t;\n     recognises_execution e s' r ((l_, b_) # t); a = (l_, b_);\n     (aa, ba) |\\<in>| possible_steps e s' r l_ b_;\n     recognises_execution e aa (evaluate_updates ba b_ r) t\\<rbrakk>\n    \\<Longrightarrow> (aa, ba)\n                      \\<in> fset (possible_steps e s' r l_ b_) \\<and>\n                      (\\<exists>s c1.\n                          obtains s c1 e aa (evaluate_updates ba b_ r) t)", "apply (simp add: fmember_implies_member)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>s' r.\n                recognises_execution e s' r t \\<Longrightarrow>\n                \\<exists>c1 s. obtains s c1 e s' r t;\n     recognises_execution e s' r ((l_, b_) # t); a = (l_, b_);\n     (aa, ba) |\\<in>| possible_steps e s' r l_ b_;\n     recognises_execution e aa (evaluate_updates ba b_ r) t\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s c1.\n                         obtains s c1 e aa (evaluate_updates ba b_ r) t", "by blast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>c1 s. obtains s c1 e s' r (a # t)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma obtainable_empty_efsm:\n  \"obtainable s c {||} = (s=0 \\<and> c = <>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. obtainable s c {||} = (s = 0 \\<and> c = <>)", "apply (simp add: obtainable_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>t. obtains s c {||} 0 <> t) = (s = 0 \\<and> c = <>)", "apply standard"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<exists>t. obtains s c {||} 0 <> t \\<Longrightarrow>\n    s = 0 \\<and> c = <>\n 2. s = 0 \\<and> c = <> \\<Longrightarrow>\n    \\<exists>t. obtains s c {||} 0 <> t", "apply (metis ffilter_empty no_outgoing_transitions no_step_none obtains.cases obtains_recognises step_None)"], ["proof (prove)\ngoal (1 subgoal):\n 1. s = 0 \\<and> c = <> \\<Longrightarrow>\n    \\<exists>t. obtains s c {||} 0 <> t", "using obtains_base"], ["proof (prove)\nusing this:\n  obtains ?s ?r ?e ?s' ?r' [] = (?s = ?s' \\<and> ?r = ?r')\n\ngoal (1 subgoal):\n 1. s = 0 \\<and> c = <> \\<Longrightarrow>\n    \\<exists>t. obtains s c {||} 0 <> t", "by blast"], ["", "lemma obtains_visits: \"obtains s r e s' r' t \\<Longrightarrow> visits s e s' r' t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. obtains s r e s' r' t \\<Longrightarrow> visits s e s' r' t", "proof(induct t arbitrary: s' r')"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s' r'.\n       obtains s r e s' r' [] \\<Longrightarrow> visits s e s' r' []\n 2. \\<And>a t s' r'.\n       \\<lbrakk>\\<And>s' r'.\n                   obtains s r e s' r' t \\<Longrightarrow>\n                   visits s e s' r' t;\n        obtains s r e s' r' (a # t)\\<rbrakk>\n       \\<Longrightarrow> visits s e s' r' (a # t)", "case Nil"], ["proof (state)\nthis:\n  obtains s r e s' r' []\n\ngoal (2 subgoals):\n 1. \\<And>s' r'.\n       obtains s r e s' r' [] \\<Longrightarrow> visits s e s' r' []\n 2. \\<And>a t s' r'.\n       \\<lbrakk>\\<And>s' r'.\n                   obtains s r e s' r' t \\<Longrightarrow>\n                   visits s e s' r' t;\n        obtains s r e s' r' (a # t)\\<rbrakk>\n       \\<Longrightarrow> visits s e s' r' (a # t)", "then"], ["proof (chain)\npicking this:\n  obtains s r e s' r' []", "show ?case"], ["proof (prove)\nusing this:\n  obtains s r e s' r' []\n\ngoal (1 subgoal):\n 1. visits s e s' r' []", "by (simp add: obtains_base)"], ["proof (state)\nthis:\n  visits s e s' r' []\n\ngoal (1 subgoal):\n 1. \\<And>a t s' r'.\n       \\<lbrakk>\\<And>s' r'.\n                   obtains s r e s' r' t \\<Longrightarrow>\n                   visits s e s' r' t;\n        obtains s r e s' r' (a # t)\\<rbrakk>\n       \\<Longrightarrow> visits s e s' r' (a # t)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a t s' r'.\n       \\<lbrakk>\\<And>s' r'.\n                   obtains s r e s' r' t \\<Longrightarrow>\n                   visits s e s' r' t;\n        obtains s r e s' r' (a # t)\\<rbrakk>\n       \\<Longrightarrow> visits s e s' r' (a # t)", "case (Cons a t)"], ["proof (state)\nthis:\n  obtains s r e ?s' ?r' t \\<Longrightarrow> visits s e ?s' ?r' t\n  obtains s r e s' r' (a # t)\n\ngoal (1 subgoal):\n 1. \\<And>a t s' r'.\n       \\<lbrakk>\\<And>s' r'.\n                   obtains s r e s' r' t \\<Longrightarrow>\n                   visits s e s' r' t;\n        obtains s r e s' r' (a # t)\\<rbrakk>\n       \\<Longrightarrow> visits s e s' r' (a # t)", "then"], ["proof (chain)\npicking this:\n  obtains s r e ?s' ?r' t \\<Longrightarrow> visits s e ?s' ?r' t\n  obtains s r e s' r' (a # t)", "show ?case"], ["proof (prove)\nusing this:\n  obtains s r e ?s' ?r' t \\<Longrightarrow> visits s e ?s' ?r' t\n  obtains s r e s' r' (a # t)\n\ngoal (1 subgoal):\n 1. visits s e s' r' (a # t)", "apply (cases a)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b.\n       \\<lbrakk>\\<And>s' r'.\n                   obtains s r e s' r' t \\<Longrightarrow>\n                   visits s e s' r' t;\n        obtains s r e s' r' (a # t); a = (aa, b)\\<rbrakk>\n       \\<Longrightarrow> visits s e s' r' (a # t)", "apply (rule obtains.cases)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>aa b.\n       \\<lbrakk>\\<And>s' r'.\n                   obtains s r e s' r' t \\<Longrightarrow>\n                   visits s e s' r' t;\n        obtains s r e s' r' (a # t); a = (aa, b)\\<rbrakk>\n       \\<Longrightarrow> obtains (?a1.4 aa b) (?a2.4 aa b) (?a3.4 aa b)\n                          (?a4.4 aa b) (?a5.4 aa b) (?a6.4 aa b)\n 2. \\<And>aa b sa ra ea.\n       \\<lbrakk>\\<And>s' r'.\n                   obtains s r e s' r' t \\<Longrightarrow>\n                   visits s e s' r' t;\n        obtains s r e s' r' (a # t); a = (aa, b); ?a1.4 aa b = sa;\n        ?a2.4 aa b = ra; ?a3.4 aa b = ea; ?a4.4 aa b = sa; ?a5.4 aa b = ra;\n        ?a6.4 aa b = []\\<rbrakk>\n       \\<Longrightarrow> visits s e s' r' (a # t)\n 3. \\<And>aa b ea s' r' l i sa ra t.\n       \\<lbrakk>\\<And>s' r'.\n                   obtains s r e s' r' t \\<Longrightarrow>\n                   visits s e s' r' t;\n        obtains s r e s' r' (a # t); a = (aa, b); ?a1.4 aa b = sa;\n        ?a2.4 aa b = ra; ?a3.4 aa b = ea; ?a4.4 aa b = s'; ?a5.4 aa b = r';\n        ?a6.4 aa b = (l, i) # t;\n        \\<exists>(s'', T)|\\<in>|possible_steps ea s' r' l i.\n           obtains sa ra ea s'' (evaluate_updates T i r') t\\<rbrakk>\n       \\<Longrightarrow> visits s e s' r' (a # t)", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa b sa ra ea.\n       \\<lbrakk>\\<And>s' r'.\n                   obtains s r e s' r' t \\<Longrightarrow>\n                   visits s e s' r' t;\n        obtains s r e s' r' (a # t); a = (aa, b); s = sa; r = ra; e = ea;\n        s' = sa; r' = ra; (aa, b) # t = []\\<rbrakk>\n       \\<Longrightarrow> visits s e s' r' (a # t)\n 2. \\<And>aa b ea s' r' l i sa ra t.\n       \\<lbrakk>\\<And>s' r'.\n                   obtains s r e s' r' t \\<Longrightarrow>\n                   visits s e s' r' t;\n        obtains s r e s' r' (a # t); a = (aa, b); s = sa; r = ra; e = ea;\n        s' = s'; r' = r'; (aa, b) # t = (l, i) # t;\n        \\<exists>(s'', T)|\\<in>|possible_steps ea s' r' l i.\n           obtains sa ra ea s'' (evaluate_updates T i r') t\\<rbrakk>\n       \\<Longrightarrow> visits s e s' r' (a # t)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b ea s' r' l i sa ra t.\n       \\<lbrakk>\\<And>s' r'.\n                   obtains s r e s' r' t \\<Longrightarrow>\n                   visits s e s' r' t;\n        obtains s r e s' r' (a # t); a = (aa, b); s = sa; r = ra; e = ea;\n        s' = s'; r' = r'; (aa, b) # t = (l, i) # t;\n        \\<exists>(s'', T)|\\<in>|possible_steps ea s' r' l i.\n           obtains sa ra ea s'' (evaluate_updates T i r') t\\<rbrakk>\n       \\<Longrightarrow> visits s e s' r' (a # t)", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b l aa ba.\n       \\<lbrakk>\\<And>s' r'.\n                   obtains s r e s' r' t \\<Longrightarrow>\n                   visits s e s' r' t;\n        obtains s r e s' r' ((l, b) # t); a = (l, b);\n        (aa, ba) |\\<in>| possible_steps e s' r' l b;\n        obtains s r e aa (evaluate_updates ba b r') t\\<rbrakk>\n       \\<Longrightarrow> visits s e s' r' ((l, b) # t)", "apply (rule visits.step)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b l aa ba.\n       \\<lbrakk>\\<And>s' r'.\n                   obtains s r e s' r' t \\<Longrightarrow>\n                   visits s e s' r' t;\n        obtains s r e s' r' ((l, b) # t); a = (l, b);\n        (aa, ba) |\\<in>| possible_steps e s' r' l b;\n        obtains s r e aa (evaluate_updates ba b r') t\\<rbrakk>\n       \\<Longrightarrow> \\<exists>(s', T)|\\<in>|possible_steps e s' r' l b.\n                            visits s e s' (evaluate_updates T b r') t", "by auto"], ["proof (state)\nthis:\n  visits s e s' r' (a # t)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma unobtainable_if: \"\\<not> visits s e s' r' t \\<Longrightarrow> \\<not> obtains s r e s' r' t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> visits s e s' r' t \\<Longrightarrow> \\<not> obtains s r e s' r' t", "using obtains_visits"], ["proof (prove)\nusing this:\n  obtains ?s ?r ?e ?s' ?r' ?t \\<Longrightarrow> visits ?s ?e ?s' ?r' ?t\n\ngoal (1 subgoal):\n 1. \\<not> visits s e s' r' t \\<Longrightarrow> \\<not> obtains s r e s' r' t", "by blast"], ["", "lemma obtainable_if_unreachable: \"\\<not>reachable s e \\<Longrightarrow> \\<not>obtainable s r e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> reachable s e \\<Longrightarrow> \\<not> obtainable s r e", "by (simp add: reachable_def obtainable_def unobtainable_if)"], ["", "lemma obtains_step_append:\n  \"obtains s r e s' r' t \\<Longrightarrow>\n  (s'', ta) |\\<in>| possible_steps e s r l i \\<Longrightarrow>\n  obtains s'' (evaluate_updates ta i r) e s' r' (t @ [(l, i)])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>obtains s r e s' r' t;\n     (s'', ta) |\\<in>| possible_steps e s r l i\\<rbrakk>\n    \\<Longrightarrow> obtains s'' (evaluate_updates ta i r) e s' r'\n                       (t @ [(l, i)])", "proof(induct t arbitrary: s' r')"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s' r'.\n       \\<lbrakk>obtains s r e s' r' [];\n        (s'', ta) |\\<in>| possible_steps e s r l i\\<rbrakk>\n       \\<Longrightarrow> obtains s'' (evaluate_updates ta i r) e s' r'\n                          ([] @ [(l, i)])\n 2. \\<And>a t s' r'.\n       \\<lbrakk>\\<And>s' r'.\n                   \\<lbrakk>obtains s r e s' r' t;\n                    (s'', ta) |\\<in>| possible_steps e s r l i\\<rbrakk>\n                   \\<Longrightarrow> obtains s'' (evaluate_updates ta i r) e\ns' r' (t @ [(l, i)]);\n        obtains s r e s' r' (a # t);\n        (s'', ta) |\\<in>| possible_steps e s r l i\\<rbrakk>\n       \\<Longrightarrow> obtains s'' (evaluate_updates ta i r) e s' r'\n                          ((a # t) @ [(l, i)])", "case Nil"], ["proof (state)\nthis:\n  obtains s r e s' r' []\n  (s'', ta) |\\<in>| possible_steps e s r l i\n\ngoal (2 subgoals):\n 1. \\<And>s' r'.\n       \\<lbrakk>obtains s r e s' r' [];\n        (s'', ta) |\\<in>| possible_steps e s r l i\\<rbrakk>\n       \\<Longrightarrow> obtains s'' (evaluate_updates ta i r) e s' r'\n                          ([] @ [(l, i)])\n 2. \\<And>a t s' r'.\n       \\<lbrakk>\\<And>s' r'.\n                   \\<lbrakk>obtains s r e s' r' t;\n                    (s'', ta) |\\<in>| possible_steps e s r l i\\<rbrakk>\n                   \\<Longrightarrow> obtains s'' (evaluate_updates ta i r) e\ns' r' (t @ [(l, i)]);\n        obtains s r e s' r' (a # t);\n        (s'', ta) |\\<in>| possible_steps e s r l i\\<rbrakk>\n       \\<Longrightarrow> obtains s'' (evaluate_updates ta i r) e s' r'\n                          ((a # t) @ [(l, i)])", "then"], ["proof (chain)\npicking this:\n  obtains s r e s' r' []\n  (s'', ta) |\\<in>| possible_steps e s r l i", "show ?case"], ["proof (prove)\nusing this:\n  obtains s r e s' r' []\n  (s'', ta) |\\<in>| possible_steps e s r l i\n\ngoal (1 subgoal):\n 1. obtains s'' (evaluate_updates ta i r) e s' r' ([] @ [(l, i)])", "apply (simp add: obtains_base)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s = s' \\<and> r = r';\n     (s'', ta) |\\<in>| possible_steps e s' r' l i\\<rbrakk>\n    \\<Longrightarrow> obtains s'' (evaluate_updates ta i r') e s' r'\n                       [(l, i)]", "apply (rule obtains.step)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s = s' \\<and> r = r';\n     (s'', ta) |\\<in>| possible_steps e s' r' l i\\<rbrakk>\n    \\<Longrightarrow> \\<exists>(s''a, T)|\\<in>|possible_steps e s' r' l i.\n                         obtains s'' (evaluate_updates ta i r') e s''a\n                          (evaluate_updates T i r') []", "apply (rule_tac x=\"(s'', ta)\" in fBexI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>s = s' \\<and> r = r';\n     (s'', ta) |\\<in>| possible_steps e s' r' l i\\<rbrakk>\n    \\<Longrightarrow> case (s'', ta) of\n                      (s''a, T) \\<Rightarrow>\n                        obtains s'' (evaluate_updates ta i r') e s''a\n                         (evaluate_updates T i r') []\n 2. \\<lbrakk>s = s' \\<and> r = r';\n     (s'', ta) |\\<in>| possible_steps e s' r' l i\\<rbrakk>\n    \\<Longrightarrow> (s'', ta) |\\<in>| possible_steps e s' r' l i", "by auto"], ["proof (state)\nthis:\n  obtains s'' (evaluate_updates ta i r) e s' r' ([] @ [(l, i)])\n\ngoal (1 subgoal):\n 1. \\<And>a t s' r'.\n       \\<lbrakk>\\<And>s' r'.\n                   \\<lbrakk>obtains s r e s' r' t;\n                    (s'', ta) |\\<in>| possible_steps e s r l i\\<rbrakk>\n                   \\<Longrightarrow> obtains s'' (evaluate_updates ta i r) e\ns' r' (t @ [(l, i)]);\n        obtains s r e s' r' (a # t);\n        (s'', ta) |\\<in>| possible_steps e s r l i\\<rbrakk>\n       \\<Longrightarrow> obtains s'' (evaluate_updates ta i r) e s' r'\n                          ((a # t) @ [(l, i)])", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a t s' r'.\n       \\<lbrakk>\\<And>s' r'.\n                   \\<lbrakk>obtains s r e s' r' t;\n                    (s'', ta) |\\<in>| possible_steps e s r l i\\<rbrakk>\n                   \\<Longrightarrow> obtains s'' (evaluate_updates ta i r) e\ns' r' (t @ [(l, i)]);\n        obtains s r e s' r' (a # t);\n        (s'', ta) |\\<in>| possible_steps e s r l i\\<rbrakk>\n       \\<Longrightarrow> obtains s'' (evaluate_updates ta i r) e s' r'\n                          ((a # t) @ [(l, i)])", "case (Cons a t)"], ["proof (state)\nthis:\n  \\<lbrakk>obtains s r e ?s' ?r' t;\n   (s'', ta) |\\<in>| possible_steps e s r l i\\<rbrakk>\n  \\<Longrightarrow> obtains s'' (evaluate_updates ta i r) e ?s' ?r'\n                     (t @ [(l, i)])\n  obtains s r e s' r' (a # t)\n  (s'', ta) |\\<in>| possible_steps e s r l i\n\ngoal (1 subgoal):\n 1. \\<And>a t s' r'.\n       \\<lbrakk>\\<And>s' r'.\n                   \\<lbrakk>obtains s r e s' r' t;\n                    (s'', ta) |\\<in>| possible_steps e s r l i\\<rbrakk>\n                   \\<Longrightarrow> obtains s'' (evaluate_updates ta i r) e\ns' r' (t @ [(l, i)]);\n        obtains s r e s' r' (a # t);\n        (s'', ta) |\\<in>| possible_steps e s r l i\\<rbrakk>\n       \\<Longrightarrow> obtains s'' (evaluate_updates ta i r) e s' r'\n                          ((a # t) @ [(l, i)])", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>obtains s r e ?s' ?r' t;\n   (s'', ta) |\\<in>| possible_steps e s r l i\\<rbrakk>\n  \\<Longrightarrow> obtains s'' (evaluate_updates ta i r) e ?s' ?r'\n                     (t @ [(l, i)])\n  obtains s r e s' r' (a # t)\n  (s'', ta) |\\<in>| possible_steps e s r l i", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>obtains s r e ?s' ?r' t;\n   (s'', ta) |\\<in>| possible_steps e s r l i\\<rbrakk>\n  \\<Longrightarrow> obtains s'' (evaluate_updates ta i r) e ?s' ?r'\n                     (t @ [(l, i)])\n  obtains s r e s' r' (a # t)\n  (s'', ta) |\\<in>| possible_steps e s r l i\n\ngoal (1 subgoal):\n 1. obtains s'' (evaluate_updates ta i r) e s' r' ((a # t) @ [(l, i)])", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>s' r'.\n                obtains s r e s' r' t \\<Longrightarrow>\n                obtains s'' (evaluate_updates ta i r) e s' r'\n                 (t @ [(l, i)]);\n     obtains s r e s' r' (a # t);\n     (s'', ta) |\\<in>| possible_steps e s r l i\\<rbrakk>\n    \\<Longrightarrow> obtains s'' (evaluate_updates ta i r) e s' r'\n                       (a # t @ [(l, i)])", "apply (rule obtains.cases)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<And>s' r'.\n                obtains s r e s' r' t \\<Longrightarrow>\n                obtains s'' (evaluate_updates ta i r) e s' r'\n                 (t @ [(l, i)]);\n     obtains s r e s' r' (a # t);\n     (s'', ta) |\\<in>| possible_steps e s r l i\\<rbrakk>\n    \\<Longrightarrow> obtains ?a1.4 ?a2.4 ?a3.4 ?a4.4 ?a5.4 ?a6.4\n 2. \\<And>sa ra ea.\n       \\<lbrakk>\\<And>s' r'.\n                   obtains s r e s' r' t \\<Longrightarrow>\n                   obtains s'' (evaluate_updates ta i r) e s' r'\n                    (t @ [(l, i)]);\n        obtains s r e s' r' (a # t);\n        (s'', ta) |\\<in>| possible_steps e s r l i; ?a1.4 = sa; ?a2.4 = ra;\n        ?a3.4 = ea; ?a4.4 = sa; ?a5.4 = ra; ?a6.4 = []\\<rbrakk>\n       \\<Longrightarrow> obtains s'' (evaluate_updates ta i r) e s' r'\n                          (a # t @ [(l, i)])\n 3. \\<And>ea s' r' la ia sa ra t.\n       \\<lbrakk>\\<And>s' r'.\n                   obtains s r e s' r' t \\<Longrightarrow>\n                   obtains s'' (evaluate_updates ta i r) e s' r'\n                    (t @ [(l, i)]);\n        obtains s r e s' r' (a # t);\n        (s'', ta) |\\<in>| possible_steps e s r l i; ?a1.4 = sa; ?a2.4 = ra;\n        ?a3.4 = ea; ?a4.4 = s'; ?a5.4 = r'; ?a6.4 = (la, ia) # t;\n        \\<exists>(s'', T)|\\<in>|possible_steps ea s' r' la ia.\n           obtains sa ra ea s'' (evaluate_updates T ia r') t\\<rbrakk>\n       \\<Longrightarrow> obtains s'' (evaluate_updates ta i r) e s' r'\n                          (a # t @ [(l, i)])", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>sa ra ea.\n       \\<lbrakk>\\<And>s' r'.\n                   obtains s r e s' r' t \\<Longrightarrow>\n                   obtains s'' (evaluate_updates ta i r) e s' r'\n                    (t @ [(l, i)]);\n        obtains s r e s' r' (a # t);\n        (s'', ta) |\\<in>| possible_steps e s r l i; s = sa; r = ra; e = ea;\n        s' = sa; r' = ra; a # t = []\\<rbrakk>\n       \\<Longrightarrow> obtains s'' (evaluate_updates ta i r) e s' r'\n                          (a # t @ [(l, i)])\n 2. \\<And>ea s' r' la ia sa ra t.\n       \\<lbrakk>\\<And>s' r'.\n                   obtains s r e s' r' t \\<Longrightarrow>\n                   obtains s'' (evaluate_updates ta i r) e s' r'\n                    (t @ [(l, i)]);\n        obtains s r e s' r' (a # t);\n        (s'', ta) |\\<in>| possible_steps e s r l i; s = sa; r = ra; e = ea;\n        s' = s'; r' = r'; a # t = (la, ia) # t;\n        \\<exists>(s'', T)|\\<in>|possible_steps ea s' r' la ia.\n           obtains sa ra ea s'' (evaluate_updates T ia r') t\\<rbrakk>\n       \\<Longrightarrow> obtains s'' (evaluate_updates ta i r) e s' r'\n                          (a # t @ [(l, i)])", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ea s' r' la ia sa ra t.\n       \\<lbrakk>\\<And>s' r'.\n                   obtains s r e s' r' t \\<Longrightarrow>\n                   obtains s'' (evaluate_updates ta i r) e s' r'\n                    (t @ [(l, i)]);\n        obtains s r e s' r' (a # t);\n        (s'', ta) |\\<in>| possible_steps e s r l i; s = sa; r = ra; e = ea;\n        s' = s'; r' = r'; a # t = (la, ia) # t;\n        \\<exists>(s'', T)|\\<in>|possible_steps ea s' r' la ia.\n           obtains sa ra ea s'' (evaluate_updates T ia r') t\\<rbrakk>\n       \\<Longrightarrow> obtains s'' (evaluate_updates ta i r) e s' r'\n                          (a # t @ [(l, i)])", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>la ia aa b.\n       \\<lbrakk>\\<And>s' r'.\n                   obtains s r e s' r' t \\<Longrightarrow>\n                   obtains s'' (evaluate_updates ta i r) e s' r'\n                    (t @ [(l, i)]);\n        obtains s r e s' r' ((la, ia) # t);\n        (s'', ta) |\\<in>| possible_steps e s r l i; a = (la, ia);\n        (aa, b) |\\<in>| possible_steps e s' r' la ia;\n        obtains s r e aa (evaluate_updates b ia r') t\\<rbrakk>\n       \\<Longrightarrow> obtains s'' (evaluate_updates ta i r) e s' r'\n                          ((la, ia) # t @ [(l, i)])", "apply (rule obtains.step)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>la ia aa b.\n       \\<lbrakk>\\<And>s' r'.\n                   obtains s r e s' r' t \\<Longrightarrow>\n                   obtains s'' (evaluate_updates ta i r) e s' r'\n                    (t @ [(l, i)]);\n        obtains s r e s' r' ((la, ia) # t);\n        (s'', ta) |\\<in>| possible_steps e s r l i; a = (la, ia);\n        (aa, b) |\\<in>| possible_steps e s' r' la ia;\n        obtains s r e aa (evaluate_updates b ia r') t\\<rbrakk>\n       \\<Longrightarrow> \\<exists>(s''a, T)\n                                  |\\<in>|possible_steps e s' r' la ia.\n                            obtains s'' (evaluate_updates ta i r) e s''a\n                             (evaluate_updates T ia r') (t @ [(l, i)])", "by auto"], ["proof (state)\nthis:\n  obtains s'' (evaluate_updates ta i r) e s' r' ((a # t) @ [(l, i)])\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma reachable_if_obtainable_step:\n  \"obtainable s r e \\<Longrightarrow> \\<exists>l i t. (s', t) |\\<in>| possible_steps e s r l i \\<Longrightarrow> reachable s' e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>obtainable s r e;\n     \\<exists>l i t. (s', t) |\\<in>| possible_steps e s r l i\\<rbrakk>\n    \\<Longrightarrow> reachable s' e", "apply (simp add: reachable_def obtainable_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<exists>t. obtains s r e 0 <> t;\n     \\<exists>l i t. (s', t) |\\<in>| possible_steps e s r l i\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t. visits s' e 0 <> t", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>t l i ta.\n       \\<lbrakk>obtains s r e 0 <> t;\n        (s', ta) |\\<in>| possible_steps e s r l i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t. visits s' e 0 <> t", "subgoal for t l i"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>obtains s r e 0 <> t;\n     (s', ta_) |\\<in>| possible_steps e s r l i\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t. visits s' e 0 <> t", "apply (rule_tac x=\"t@[(l, i)]\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>obtains s r e 0 <> t;\n     (s', ta_) |\\<in>| possible_steps e s r l i\\<rbrakk>\n    \\<Longrightarrow> visits s' e 0 <> (t @ [(l, i)])", "using obtains_step_append unobtainable_if"], ["proof (prove)\nusing this:\n  \\<lbrakk>obtains ?s ?r ?e ?s' ?r' ?t;\n   (?s'', ?ta) |\\<in>| possible_steps ?e ?s ?r ?l ?i\\<rbrakk>\n  \\<Longrightarrow> obtains ?s'' (evaluate_updates ?ta ?i ?r) ?e ?s' ?r'\n                     (?t @ [(?l, ?i)])\n  \\<not> visits ?s ?e ?s' ?r' ?t \\<Longrightarrow>\n  \\<not> obtains ?s ?r ?e ?s' ?r' ?t\n\ngoal (1 subgoal):\n 1. \\<lbrakk>obtains s r e 0 <> t;\n     (s', ta_) |\\<in>| possible_steps e s r l i\\<rbrakk>\n    \\<Longrightarrow> visits s' e 0 <> (t @ [(l, i)])", "by blast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma possible_steps_remove_unreachable:\n  \"obtainable s r e \\<Longrightarrow>\n  \\<not> reachable s' e \\<Longrightarrow>\n  possible_steps (remove_state s' e) s r l i = possible_steps e s r l i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>obtainable s r e; \\<not> reachable s' e\\<rbrakk>\n    \\<Longrightarrow> possible_steps (remove_state s' e) s r l i =\n                      possible_steps e s r l i", "apply standard"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>obtainable s r e; \\<not> reachable s' e\\<rbrakk>\n    \\<Longrightarrow> possible_steps (remove_state s' e) s r l\n                       i |\\<subseteq>|\n                      possible_steps e s r l i\n 2. \\<lbrakk>obtainable s r e; \\<not> reachable s' e\\<rbrakk>\n    \\<Longrightarrow> possible_steps e s r l i |\\<subseteq>|\n                      possible_steps (remove_state s' e) s r l i", "apply (simp add: fsubset_eq)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>obtainable s r e; \\<not> reachable s' e\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x|\\<in>|possible_steps (remove_state s' e) s\n  r l i.\n                         x |\\<in>| possible_steps e s r l i\n 2. \\<lbrakk>obtainable s r e; \\<not> reachable s' e\\<rbrakk>\n    \\<Longrightarrow> possible_steps e s r l i |\\<subseteq>|\n                      possible_steps (remove_state s' e) s r l i", "apply (rule fBallI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>obtainable s r e; \\<not> reachable s' e;\n        x |\\<in>| possible_steps (remove_state s' e) s r l i\\<rbrakk>\n       \\<Longrightarrow> x |\\<in>| possible_steps e s r l i\n 2. \\<lbrakk>obtainable s r e; \\<not> reachable s' e\\<rbrakk>\n    \\<Longrightarrow> possible_steps e s r l i |\\<subseteq>|\n                      possible_steps (remove_state s' e) s r l i", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>obtainable s r e; \\<not> reachable s' e;\n        (a, b) |\\<in>| possible_steps (remove_state s' e) s r l i\\<rbrakk>\n       \\<Longrightarrow> (a, b) |\\<in>| possible_steps e s r l i\n 2. \\<lbrakk>obtainable s r e; \\<not> reachable s' e\\<rbrakk>\n    \\<Longrightarrow> possible_steps e s r l i |\\<subseteq>|\n                      possible_steps (remove_state s' e) s r l i", "apply (metis ffmember_filter in_possible_steps remove_state_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>obtainable s r e; \\<not> reachable s' e\\<rbrakk>\n    \\<Longrightarrow> possible_steps e s r l i |\\<subseteq>|\n                      possible_steps (remove_state s' e) s r l i", "apply (simp add: fsubset_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>obtainable s r e; \\<not> reachable s' e\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x|\\<in>|possible_steps e s r l i.\n                         x |\\<in>|\n                         possible_steps (remove_state s' e) s r l i", "apply (rule fBallI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>obtainable s r e; \\<not> reachable s' e;\n        x |\\<in>| possible_steps e s r l i\\<rbrakk>\n       \\<Longrightarrow> x |\\<in>|\n                         possible_steps (remove_state s' e) s r l i", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>obtainable s r e; \\<not> reachable s' e;\n        (a, b) |\\<in>| possible_steps e s r l i\\<rbrakk>\n       \\<Longrightarrow> (a, b) |\\<in>|\n                         possible_steps (remove_state s' e) s r l i", "subgoal for a b"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>obtainable s r e; \\<not> reachable s' e;\n     (a, b) |\\<in>| possible_steps e s r l i\\<rbrakk>\n    \\<Longrightarrow> (a, b) |\\<in>|\n                      possible_steps (remove_state s' e) s r l i", "apply (case_tac \"a = s'\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>obtainable s r e; \\<not> reachable s' e;\n     (a, b) |\\<in>| possible_steps e s r l i; a = s'\\<rbrakk>\n    \\<Longrightarrow> (a, b) |\\<in>|\n                      possible_steps (remove_state s' e) s r l i\n 2. \\<lbrakk>obtainable s r e; \\<not> reachable s' e;\n     (a, b) |\\<in>| possible_steps e s r l i; a \\<noteq> s'\\<rbrakk>\n    \\<Longrightarrow> (a, b) |\\<in>|\n                      possible_steps (remove_state s' e) s r l i", "using reachable_if_obtainable_step"], ["proof (prove)\nusing this:\n  \\<lbrakk>obtainable ?s ?r ?e;\n   \\<exists>l i t. (?s', t) |\\<in>| possible_steps ?e ?s ?r l i\\<rbrakk>\n  \\<Longrightarrow> reachable ?s' ?e\n\ngoal (2 subgoals):\n 1. \\<lbrakk>obtainable s r e; \\<not> reachable s' e;\n     (a, b) |\\<in>| possible_steps e s r l i; a = s'\\<rbrakk>\n    \\<Longrightarrow> (a, b) |\\<in>|\n                      possible_steps (remove_state s' e) s r l i\n 2. \\<lbrakk>obtainable s r e; \\<not> reachable s' e;\n     (a, b) |\\<in>| possible_steps e s r l i; a \\<noteq> s'\\<rbrakk>\n    \\<Longrightarrow> (a, b) |\\<in>|\n                      possible_steps (remove_state s' e) s r l i", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>obtainable s r e; \\<not> reachable s' e;\n     (a, b) |\\<in>| possible_steps e s r l i; a \\<noteq> s'\\<rbrakk>\n    \\<Longrightarrow> (a, b) |\\<in>|\n                      possible_steps (remove_state s' e) s r l i", "apply (simp add: remove_state_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>obtainable s r e; \\<not> reachable s' e;\n     (a, b) |\\<in>| possible_steps e s r l i; a \\<noteq> s'\\<rbrakk>\n    \\<Longrightarrow> (a, b) |\\<in>|\n                      possible_steps\n                       (ffilter\n                         (\\<lambda>((from, to), t).\n                             from \\<noteq> s' \\<and> to \\<noteq> s')\n                         e)\n                       s r l i", "by (metis (mono_tags, lifting) ffmember_filter in_possible_steps obtainable_if_unreachable old.prod.case)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text_raw\\<open>\\snip{removeUnreachableArb}{1}{2}{%\\<close>"], ["", "lemma executionally_equivalent_remove_unreachable_state_arbitrary:\n  \"obtainable s r e \\<Longrightarrow> \\<not> reachable s' e \\<Longrightarrow> executionally_equivalent e s r (remove_state s' e) s r x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>obtainable s r e; \\<not> reachable s' e\\<rbrakk>\n    \\<Longrightarrow> executionally_equivalent e s r (remove_state s' e) s r\n                       x", "text_raw\\<open>}%endsnip\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>obtainable s r e; \\<not> reachable s' e\\<rbrakk>\n    \\<Longrightarrow> executionally_equivalent e s r (remove_state s' e) s r\n                       x", "proof(induct x arbitrary: s r)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s r.\n       \\<lbrakk>obtainable s r e; \\<not> reachable s' e\\<rbrakk>\n       \\<Longrightarrow> executionally_equivalent e s r (remove_state s' e)\n                          s r []\n 2. \\<And>a x s r.\n       \\<lbrakk>\\<And>s r.\n                   \\<lbrakk>obtainable s r e; \\<not> reachable s' e\\<rbrakk>\n                   \\<Longrightarrow> executionally_equivalent e s r\n(remove_state s' e) s r x;\n        obtainable s r e; \\<not> reachable s' e\\<rbrakk>\n       \\<Longrightarrow> executionally_equivalent e s r (remove_state s' e)\n                          s r (a # x)", "case (Cons a x)"], ["proof (state)\nthis:\n  \\<lbrakk>obtainable ?s ?r e; \\<not> reachable s' e\\<rbrakk>\n  \\<Longrightarrow> executionally_equivalent e ?s ?r (remove_state s' e) ?s\n                     ?r x\n  obtainable s r e\n  \\<not> reachable s' e\n\ngoal (2 subgoals):\n 1. \\<And>s r.\n       \\<lbrakk>obtainable s r e; \\<not> reachable s' e\\<rbrakk>\n       \\<Longrightarrow> executionally_equivalent e s r (remove_state s' e)\n                          s r []\n 2. \\<And>a x s r.\n       \\<lbrakk>\\<And>s r.\n                   \\<lbrakk>obtainable s r e; \\<not> reachable s' e\\<rbrakk>\n                   \\<Longrightarrow> executionally_equivalent e s r\n(remove_state s' e) s r x;\n        obtainable s r e; \\<not> reachable s' e\\<rbrakk>\n       \\<Longrightarrow> executionally_equivalent e s r (remove_state s' e)\n                          s r (a # x)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>obtainable ?s ?r e; \\<not> reachable s' e\\<rbrakk>\n  \\<Longrightarrow> executionally_equivalent e ?s ?r (remove_state s' e) ?s\n                     ?r x\n  obtainable s r e\n  \\<not> reachable s' e", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>obtainable ?s ?r e; \\<not> reachable s' e\\<rbrakk>\n  \\<Longrightarrow> executionally_equivalent e ?s ?r (remove_state s' e) ?s\n                     ?r x\n  obtainable s r e\n  \\<not> reachable s' e\n\ngoal (1 subgoal):\n 1. executionally_equivalent e s r (remove_state s' e) s r (a # x)", "apply (cases a, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b.\n       \\<lbrakk>a = (aa, b);\n        \\<And>s r.\n           obtainable s r e \\<Longrightarrow>\n           executionally_equivalent e s r (remove_state s' e) s r x;\n        obtainable s r e; \\<not> reachable s' e\\<rbrakk>\n       \\<Longrightarrow> executionally_equivalent e s r (remove_state s' e)\n                          s r ((aa, b) # x)", "apply (rule executionally_equivalent.step)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa b.\n       \\<lbrakk>a = (aa, b);\n        \\<And>s r.\n           obtainable s r e \\<Longrightarrow>\n           executionally_equivalent e s r (remove_state s' e) s r x;\n        obtainable s r e; \\<not> reachable s' e\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(s1', t1)|\\<in>|possible_steps e s r aa b.\n                            \\<exists>(s2', t2)\n                                     |\\<in>|possible_steps\n       (remove_state s' e) s r aa b.\n                               evaluate_outputs t1 b r =\n                               evaluate_outputs t2 b r \\<and>\n                               executionally_equivalent e s1'\n                                (evaluate_updates t1 b r)\n                                (remove_state s' e) s2'\n                                (evaluate_updates t2 b r) x\n 2. \\<And>aa b.\n       \\<lbrakk>a = (aa, b);\n        \\<And>s r.\n           obtainable s r e \\<Longrightarrow>\n           executionally_equivalent e s r (remove_state s' e) s r x;\n        obtainable s r e; \\<not> reachable s' e\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(s2', t2)\n                                  |\\<in>|possible_steps (remove_state s' e)\n    s r aa b.\n                            \\<exists>(s1', t1)\n                                     |\\<in>|possible_steps e s r aa b.\n                               evaluate_outputs t1 b r =\n                               evaluate_outputs t2 b r \\<and>\n                               executionally_equivalent e s1'\n                                (evaluate_updates t1 b r)\n                                (remove_state s' e) s2'\n                                (evaluate_updates t2 b r) x", "apply (simp add: possible_steps_remove_unreachable)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa b.\n       \\<lbrakk>a = (aa, b);\n        \\<And>s r.\n           obtainable s r e \\<Longrightarrow>\n           executionally_equivalent e s r (remove_state s' e) s r x;\n        obtainable s r e; \\<not> reachable s' e\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(s1', t1)|\\<in>|possible_steps e s r aa b.\n                            \\<exists>(s2', t2)\n                                     |\\<in>|possible_steps e s r aa b.\n                               evaluate_outputs t1 b r =\n                               evaluate_outputs t2 b r \\<and>\n                               executionally_equivalent e s1'\n                                (evaluate_updates t1 b r)\n                                (remove_state s' e) s2'\n                                (evaluate_updates t2 b r) x\n 2. \\<And>aa b.\n       \\<lbrakk>a = (aa, b);\n        \\<And>s r.\n           obtainable s r e \\<Longrightarrow>\n           executionally_equivalent e s r (remove_state s' e) s r x;\n        obtainable s r e; \\<not> reachable s' e\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(s2', t2)\n                                  |\\<in>|possible_steps (remove_state s' e)\n    s r aa b.\n                            \\<exists>(s1', t1)\n                                     |\\<in>|possible_steps e s r aa b.\n                               evaluate_outputs t1 b r =\n                               evaluate_outputs t2 b r \\<and>\n                               executionally_equivalent e s1'\n                                (evaluate_updates t1 b r)\n                                (remove_state s' e) s2'\n                                (evaluate_updates t2 b r) x", "apply standard"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa b x.\n       \\<lbrakk>a = (aa, b);\n        \\<And>s r.\n           obtainable s r e \\<Longrightarrow>\n           executionally_equivalent e s r (remove_state s' e) s r x;\n        obtainable s r e; \\<not> reachable s' e;\n        x |\\<in>| possible_steps e s r aa b\\<rbrakk>\n       \\<Longrightarrow> case x of\n                         (s1', t1) \\<Rightarrow>\n                           \\<exists>(s2', t2)\n                                    |\\<in>|possible_steps e s r aa b.\n                              evaluate_outputs t1 b r =\n                              evaluate_outputs t2 b r \\<and>\n                              executionally_equivalent e s1'\n                               (evaluate_updates t1 b r) (remove_state s' e)\n                               s2' (evaluate_updates t2 b r) x\n 2. \\<And>aa b.\n       \\<lbrakk>a = (aa, b);\n        \\<And>s r.\n           obtainable s r e \\<Longrightarrow>\n           executionally_equivalent e s r (remove_state s' e) s r x;\n        obtainable s r e; \\<not> reachable s' e\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(s2', t2)\n                                  |\\<in>|possible_steps (remove_state s' e)\n    s r aa b.\n                            \\<exists>(s1', t1)\n                                     |\\<in>|possible_steps e s r aa b.\n                               evaluate_outputs t1 b r =\n                               evaluate_outputs t2 b r \\<and>\n                               executionally_equivalent e s1'\n                                (evaluate_updates t1 b r)\n                                (remove_state s' e) s2'\n                                (evaluate_updates t2 b r) x", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa b ab ba.\n       \\<lbrakk>a = (aa, b);\n        \\<And>s r.\n           obtainable s r e \\<Longrightarrow>\n           executionally_equivalent e s r (remove_state s' e) s r x;\n        obtainable s r e; \\<not> reachable s' e;\n        (ab, ba) |\\<in>| possible_steps e s r aa b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>(s2', t2)|\\<in>|possible_steps e s r aa b.\n                            evaluate_outputs ba b r =\n                            evaluate_outputs t2 b r \\<and>\n                            executionally_equivalent e ab\n                             (evaluate_updates ba b r) (remove_state s' e)\n                             s2' (evaluate_updates t2 b r) x\n 2. \\<And>aa b.\n       \\<lbrakk>a = (aa, b);\n        \\<And>s r.\n           obtainable s r e \\<Longrightarrow>\n           executionally_equivalent e s r (remove_state s' e) s r x;\n        obtainable s r e; \\<not> reachable s' e\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(s2', t2)\n                                  |\\<in>|possible_steps (remove_state s' e)\n    s r aa b.\n                            \\<exists>(s1', t1)\n                                     |\\<in>|possible_steps e s r aa b.\n                               evaluate_outputs t1 b r =\n                               evaluate_outputs t2 b r \\<and>\n                               executionally_equivalent e s1'\n                                (evaluate_updates t1 b r)\n                                (remove_state s' e) s2'\n                                (evaluate_updates t2 b r) x", "subgoal for aa b ab ba"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a = (aa, b);\n     \\<And>s r.\n        obtainable s r e \\<Longrightarrow>\n        executionally_equivalent e s r (remove_state s' e) s r x;\n     obtainable s r e; \\<not> reachable s' e;\n     (ab, ba) |\\<in>| possible_steps e s r aa b\\<rbrakk>\n    \\<Longrightarrow> \\<exists>(s2', t2)|\\<in>|possible_steps e s r aa b.\n                         evaluate_outputs ba b r =\n                         evaluate_outputs t2 b r \\<and>\n                         executionally_equivalent e ab\n                          (evaluate_updates ba b r) (remove_state s' e) s2'\n                          (evaluate_updates t2 b r) x", "apply (rule_tac x=\"(ab, ba)\" in fBexI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>a = (aa, b);\n     \\<And>s r.\n        obtainable s r e \\<Longrightarrow>\n        executionally_equivalent e s r (remove_state s' e) s r x;\n     obtainable s r e; \\<not> reachable s' e;\n     (ab, ba) |\\<in>| possible_steps e s r aa b\\<rbrakk>\n    \\<Longrightarrow> case (ab, ba) of\n                      (s2', t2) \\<Rightarrow>\n                        evaluate_outputs ba b r =\n                        evaluate_outputs t2 b r \\<and>\n                        executionally_equivalent e ab\n                         (evaluate_updates ba b r) (remove_state s' e) s2'\n                         (evaluate_updates t2 b r) x\n 2. \\<lbrakk>a = (aa, b);\n     \\<And>s r.\n        obtainable s r e \\<Longrightarrow>\n        executionally_equivalent e s r (remove_state s' e) s r x;\n     obtainable s r e; \\<not> reachable s' e;\n     (ab, ba) |\\<in>| possible_steps e s r aa b\\<rbrakk>\n    \\<Longrightarrow> (ab, ba) |\\<in>| possible_steps e s r aa b", "apply (metis (mono_tags, lifting) obtainable_def obtains_step_append case_prodI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a = (aa, b);\n     \\<And>s r.\n        obtainable s r e \\<Longrightarrow>\n        executionally_equivalent e s r (remove_state s' e) s r x;\n     obtainable s r e; \\<not> reachable s' e;\n     (ab, ba) |\\<in>| possible_steps e s r aa b\\<rbrakk>\n    \\<Longrightarrow> (ab, ba) |\\<in>| possible_steps e s r aa b", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b.\n       \\<lbrakk>a = (aa, b);\n        \\<And>s r.\n           obtainable s r e \\<Longrightarrow>\n           executionally_equivalent e s r (remove_state s' e) s r x;\n        obtainable s r e; \\<not> reachable s' e\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(s2', t2)\n                                  |\\<in>|possible_steps (remove_state s' e)\n    s r aa b.\n                            \\<exists>(s1', t1)\n                                     |\\<in>|possible_steps e s r aa b.\n                               evaluate_outputs t1 b r =\n                               evaluate_outputs t2 b r \\<and>\n                               executionally_equivalent e s1'\n                                (evaluate_updates t1 b r)\n                                (remove_state s' e) s2'\n                                (evaluate_updates t2 b r) x", "apply (rule fBallI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b x.\n       \\<lbrakk>a = (aa, b);\n        \\<And>s r.\n           obtainable s r e \\<Longrightarrow>\n           executionally_equivalent e s r (remove_state s' e) s r x;\n        obtainable s r e; \\<not> reachable s' e;\n        x |\\<in>| possible_steps (remove_state s' e) s r aa b\\<rbrakk>\n       \\<Longrightarrow> case x of\n                         (s2', t2) \\<Rightarrow>\n                           \\<exists>(s1', t1)\n                                    |\\<in>|possible_steps e s r aa b.\n                              evaluate_outputs t1 b r =\n                              evaluate_outputs t2 b r \\<and>\n                              executionally_equivalent e s1'\n                               (evaluate_updates t1 b r) (remove_state s' e)\n                               s2' (evaluate_updates t2 b r) x", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b ab ba.\n       \\<lbrakk>a = (aa, b);\n        \\<And>s r.\n           obtainable s r e \\<Longrightarrow>\n           executionally_equivalent e s r (remove_state s' e) s r x;\n        obtainable s r e; \\<not> reachable s' e;\n        (ab, ba) |\\<in>|\n        possible_steps (remove_state s' e) s r aa b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>(s1', t1)|\\<in>|possible_steps e s r aa b.\n                            evaluate_outputs t1 b r =\n                            evaluate_outputs ba b r \\<and>\n                            executionally_equivalent e s1'\n                             (evaluate_updates t1 b r) (remove_state s' e)\n                             ab (evaluate_updates ba b r) x", "apply (rule_tac x=\"(ab, ba)\" in fBexI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa b aaa ba.\n       \\<lbrakk>a = (aa, b);\n        \\<And>s r.\n           obtainable s r e \\<Longrightarrow>\n           executionally_equivalent e s r (remove_state s' e) s r x;\n        obtainable s r e; \\<not> reachable s' e;\n        (aaa, ba) |\\<in>|\n        possible_steps (remove_state s' e) s r aa b\\<rbrakk>\n       \\<Longrightarrow> case (aaa, ba) of\n                         (s1', t1) \\<Rightarrow>\n                           evaluate_outputs t1 b r =\n                           evaluate_outputs ba b r \\<and>\n                           executionally_equivalent e s1'\n                            (evaluate_updates t1 b r) (remove_state s' e)\n                            aaa (evaluate_updates ba b r) x\n 2. \\<And>aa b aaa ba.\n       \\<lbrakk>a = (aa, b);\n        \\<And>s r.\n           obtainable s r e \\<Longrightarrow>\n           executionally_equivalent e s r (remove_state s' e) s r x;\n        obtainable s r e; \\<not> reachable s' e;\n        (aaa, ba) |\\<in>|\n        possible_steps (remove_state s' e) s r aa b\\<rbrakk>\n       \\<Longrightarrow> (aaa, ba) |\\<in>| possible_steps e s r aa b", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa b aaa ba.\n       \\<lbrakk>a = (aa, b);\n        \\<And>s r.\n           obtainable s r e \\<Longrightarrow>\n           executionally_equivalent e s r (remove_state s' e) s r x;\n        obtainable s r e; \\<not> reachable s' e;\n        (aaa, ba) |\\<in>|\n        possible_steps (remove_state s' e) s r aa b\\<rbrakk>\n       \\<Longrightarrow> executionally_equivalent e aaa\n                          (evaluate_updates ba b r) (remove_state s' e) aaa\n                          (evaluate_updates ba b r) x\n 2. \\<And>aa b aaa ba.\n       \\<lbrakk>a = (aa, b);\n        \\<And>s r.\n           obtainable s r e \\<Longrightarrow>\n           executionally_equivalent e s r (remove_state s' e) s r x;\n        obtainable s r e; \\<not> reachable s' e;\n        (aaa, ba) |\\<in>|\n        possible_steps (remove_state s' e) s r aa b\\<rbrakk>\n       \\<Longrightarrow> (aaa, ba) |\\<in>| possible_steps e s r aa b", "apply (metis obtainable_def obtains_step_append possible_steps_remove_unreachable)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b aaa ba.\n       \\<lbrakk>a = (aa, b);\n        \\<And>s r.\n           obtainable s r e \\<Longrightarrow>\n           executionally_equivalent e s r (remove_state s' e) s r x;\n        obtainable s r e; \\<not> reachable s' e;\n        (aaa, ba) |\\<in>|\n        possible_steps (remove_state s' e) s r aa b\\<rbrakk>\n       \\<Longrightarrow> (aaa, ba) |\\<in>| possible_steps e s r aa b", "by (simp add: possible_steps_remove_unreachable)"], ["proof (state)\nthis:\n  executionally_equivalent e s r (remove_state s' e) s r (a # x)\n\ngoal (1 subgoal):\n 1. \\<And>s r.\n       \\<lbrakk>obtainable s r e; \\<not> reachable s' e\\<rbrakk>\n       \\<Longrightarrow> executionally_equivalent e s r (remove_state s' e)\n                          s r []", "qed auto"], ["", "text_raw\\<open>\\snip{removeUnreachable}{1}{2}{%\\<close>"], ["", "lemma executionally_equivalent_remove_unreachable_state:\n  \"\\<not> reachable s' e \\<Longrightarrow> executionally_equivalent e 0 <> (remove_state s' e) 0 <> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> reachable s' e \\<Longrightarrow>\n    executionally_equivalent e 0 <> (remove_state s' e) 0 <> x", "text_raw\\<open>}%endsnip\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> reachable s' e \\<Longrightarrow>\n    executionally_equivalent e 0 <> (remove_state s' e) 0 <> x", "by (meson executionally_equivalent_remove_unreachable_state_arbitrary\n      obtains.simps obtains_obtainable)"], ["", "subsection\\<open>Transition Replacement\\<close>"], ["", "text\\<open>Here, we define the function \\texttt{replace} to replace one transition with another, and prove\nsome of its properties.\\<close>"], ["", "definition \"replace e1 old new = fimage (\\<lambda>x. if x = old then new else x) e1\""], ["", "lemma replace_finsert:\n  \"replace (finsert ((aaa, baa), b) e1) old new = (if ((aaa, baa), b) = old then (finsert new (replace e1 old new)) else (finsert ((aaa, baa), b) (replace e1 old new)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. replace (finsert ((aaa, baa), b) e1) old new =\n    (if ((aaa, baa), b) = old then finsert new (replace e1 old new)\n     else finsert ((aaa, baa), b) (replace e1 old new))", "by (simp add: replace_def)"], ["", "lemma possible_steps_replace_unchanged:\n  \"((s, aa), ba) \\<noteq> ((s1, s2), t1) \\<Longrightarrow>\n  (aa, ba) |\\<in>| possible_steps e1 s r l i \\<Longrightarrow>\n  (aa, ba) |\\<in>| possible_steps (replace e1 ((s1, s2), t1) ((s1, s2), t2)) s r l i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>((s, aa), ba) \\<noteq> ((s1, s2), t1);\n     (aa, ba) |\\<in>| possible_steps e1 s r l i\\<rbrakk>\n    \\<Longrightarrow> (aa, ba) |\\<in>|\n                      possible_steps\n                       (replace e1 ((s1, s2), t1) ((s1, s2), t2)) s r l i", "apply (simp add: in_possible_steps[symmetric] replace_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>aa = s2 \\<longrightarrow>\n             s = s1 \\<longrightarrow> ba \\<noteq> t1;\n     ((s, aa), ba) |\\<in>| e1 \\<and>\n     Label ba = l \\<and> can_take_transition ba i r\\<rbrakk>\n    \\<Longrightarrow> ((s, aa), ba) |\\<in>|\n                      (\\<lambda>x.\n                          if x = ((s1, s2), t1) then ((s1, s2), t2)\n                          else x) |`|\n                      e1", "by fastforce"], ["", "end"]]}