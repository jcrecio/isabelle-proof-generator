{"file_name": "/home/qj213/afp-2021-10-22/thys/Extended_Finite_State_Machines/Transition.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Extended_Finite_State_Machines", "problem_names": ["lemma can_take_empty [simp]: \"length i = a \\<Longrightarrow> can_take a [] i c\"", "lemma can_take_subset_append:\n  assumes \"set (Guards t) \\<subseteq> set (Guards t')\"\n  shows \"can_take a (Guards t @ Guards t') i c = can_take a (Guards t') i c\"", "lemmas can_take = can_take_def can_take_transition_def", "lemma can_take_transition_empty_guard:\n  \"Guards t = [] \\<Longrightarrow> \\<exists>i. can_take_transition t i c\"", "lemma can_take_subset: \"length i = Arity t \\<Longrightarrow>\n   Arity t = Arity t' \\<Longrightarrow>\n   set (Guards t') \\<subseteq> set (Guards t) \\<Longrightarrow>\n   can_take_transition t i r \\<Longrightarrow>\n   can_take_transition t' i r\"", "lemma valid_list_can_take:\n  \"\\<forall>g \\<in> set (Guards t). valid g \\<Longrightarrow> \\<exists>i. can_take_transition t i c\"", "lemma cant_take_if:\n  \"\\<exists>g \\<in> set (Guards t). gval g (join_ir i r) \\<noteq> true \\<Longrightarrow>\n   \\<not> can_take_transition t i r\"", "lemma apply_outputs_nth:\n  \"i < length p \\<Longrightarrow> apply_outputs p s ! i = aval (p ! i) s\"", "lemmas apply_outputs = datastate apply_outputs_def value_plus_def value_minus_def value_times_def", "lemma apply_outputs_empty [simp]: \"apply_outputs [] s = []\"", "lemma apply_outputs_preserves_length: \"length (apply_outputs p s) = length p\"", "lemma apply_outputs_literal: assumes \"P ! r = L v\"\n      and \"r < length P\"\n    shows \"apply_outputs P s ! r = Some v\"", "lemma apply_outputs_register: assumes \"r < length P\"\n  shows \"apply_outputs (list_update P r (V (R p))) (join_ir i c) ! r = c $ p\"", "lemma apply_outputs_unupdated: assumes \"ia \\<noteq> r\"\n      and \"ia < length P\"\n    shows \"apply_outputs P j ! ia = apply_outputs (list_update P r v)j ! ia\"", "lemma apply_updates_cons: \"ra \\<noteq> r \\<Longrightarrow>\n       apply_updates u (join_ir ia c) c $ ra = apply_updates ((r, a) # u) (join_ir ia c) c $ ra\"", "lemma update_twice:\n  \"apply_updates [(r, a), (r, b)] s regs = regs (r $:= aval b s)\"", "lemma r_not_updated_stays_the_same:\n  \"r \\<notin> fst ` set U \\<Longrightarrow> apply_updates U c d $ r = d $ r\""], "translations": [["", "lemma can_take_empty [simp]: \"length i = a \\<Longrightarrow> can_take a [] i c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length i = a \\<Longrightarrow> can_take a [] i c", "by (simp add: can_take_def)"], ["", "lemma can_take_subset_append:\n  assumes \"set (Guards t) \\<subseteq> set (Guards t')\"\n  shows \"can_take a (Guards t @ Guards t') i c = can_take a (Guards t') i c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. can_take a (Guards t @ Guards t') i c = can_take a (Guards t') i c", "using assms"], ["proof (prove)\nusing this:\n  set (Guards t) \\<subseteq> set (Guards t')\n\ngoal (1 subgoal):\n 1. can_take a (Guards t @ Guards t') i c = can_take a (Guards t') i c", "by (simp add: apply_guards_subset_append can_take_def)"], ["", "definition \"can_take_transition t i r = can_take (Arity t) (Guards t) i r\""], ["", "lemmas can_take = can_take_def can_take_transition_def"], ["", "lemma can_take_transition_empty_guard:\n  \"Guards t = [] \\<Longrightarrow> \\<exists>i. can_take_transition t i c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Guards t = [] \\<Longrightarrow> \\<exists>i. can_take_transition t i c", "by (simp add: can_take_transition_def can_take_def Ex_list_of_length)"], ["", "lemma can_take_subset: \"length i = Arity t \\<Longrightarrow>\n   Arity t = Arity t' \\<Longrightarrow>\n   set (Guards t') \\<subseteq> set (Guards t) \\<Longrightarrow>\n   can_take_transition t i r \\<Longrightarrow>\n   can_take_transition t' i r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length i = Arity t; Arity t = Arity t';\n     set (Guards t') \\<subseteq> set (Guards t);\n     can_take_transition t i r\\<rbrakk>\n    \\<Longrightarrow> can_take_transition t' i r", "by (simp add: can_take_transition_def can_take_def apply_guards_subset)"], ["", "lemma valid_list_can_take:\n  \"\\<forall>g \\<in> set (Guards t). valid g \\<Longrightarrow> \\<exists>i. can_take_transition t i c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>g\\<in>set (Guards t). valid g \\<Longrightarrow>\n    \\<exists>i. can_take_transition t i c", "by (simp add: can_take_transition_def can_take_def apply_guards_def valid_def Ex_list_of_length)"], ["", "lemma cant_take_if:\n  \"\\<exists>g \\<in> set (Guards t). gval g (join_ir i r) \\<noteq> true \\<Longrightarrow>\n   \\<not> can_take_transition t i r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>g\\<in>set (Guards t).\n       gval g (join_ir i r) \\<noteq> true \\<Longrightarrow>\n    \\<not> can_take_transition t i r", "using apply_guards_cons apply_guards_rearrange can_take_def can_take_transition_def"], ["proof (prove)\nusing this:\n  apply_guards (?a # ?G) ?c = (gval ?a ?c = true \\<and> apply_guards ?G ?c)\n  ?x \\<in> set ?G \\<Longrightarrow>\n  apply_guards ?G ?s = apply_guards (?x # ?G) ?s\n  can_take ?a ?g ?i ?r =\n  (length ?i = ?a \\<and> apply_guards ?g (join_ir ?i ?r))\n  can_take_transition ?t ?i ?r = can_take (Arity ?t) (Guards ?t) ?i ?r\n\ngoal (1 subgoal):\n 1. \\<exists>g\\<in>set (Guards t).\n       gval g (join_ir i r) \\<noteq> true \\<Longrightarrow>\n    \\<not> can_take_transition t i r", "by blast"], ["", "definition apply_outputs :: \"'a aexp list \\<Rightarrow> 'a datastate \\<Rightarrow> value option list\" where\n  \"apply_outputs p s = map (\\<lambda>p. aval p s) p\""], ["", "abbreviation \"evaluate_outputs t i r \\<equiv> apply_outputs (Outputs t) (join_ir i r)\""], ["", "lemma apply_outputs_nth:\n  \"i < length p \\<Longrightarrow> apply_outputs p s ! i = aval (p ! i) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < length p \\<Longrightarrow> apply_outputs p s ! i = aval (p ! i) s", "by (simp add: apply_outputs_def)"], ["", "lemmas apply_outputs = datastate apply_outputs_def value_plus_def value_minus_def value_times_def"], ["", "lemma apply_outputs_empty [simp]: \"apply_outputs [] s = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. apply_outputs [] s = []", "by (simp add: apply_outputs_def)"], ["", "lemma apply_outputs_preserves_length: \"length (apply_outputs p s) = length p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (apply_outputs p s) = length p", "by (simp add: apply_outputs_def)"], ["", "lemma apply_outputs_literal: assumes \"P ! r = L v\"\n      and \"r < length P\"\n    shows \"apply_outputs P s ! r = Some v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. apply_outputs P s ! r = Some v", "by (simp add: assms apply_outputs_nth)"], ["", "lemma apply_outputs_register: assumes \"r < length P\"\n  shows \"apply_outputs (list_update P r (V (R p))) (join_ir i c) ! r = c $ p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. apply_outputs (P[r := V (R p)]) (join_ir i c) ! r = c $ p", "by (metis apply_outputs_nth assms aval.simps(2) join_ir_R length_list_update nth_list_update_eq)"], ["", "lemma apply_outputs_unupdated: assumes \"ia \\<noteq> r\"\n      and \"ia < length P\"\n    shows \"apply_outputs P j ! ia = apply_outputs (list_update P r v)j ! ia\""], ["proof (prove)\ngoal (1 subgoal):\n 1. apply_outputs P j ! ia = apply_outputs (P[r := v]) j ! ia", "by (metis apply_outputs_nth assms(1) assms(2) length_list_update nth_list_update_neq)"], ["", "definition apply_updates :: \"update_function list \\<Rightarrow> vname datastate \\<Rightarrow> registers \\<Rightarrow> registers\" where\n  \"apply_updates u old = fold (\\<lambda>h r. r(fst h $:= aval (snd h) old)) u\""], ["", "abbreviation \"evaluate_updates t i r \\<equiv> apply_updates (Updates t) (join_ir i r) r\""], ["", "lemma apply_updates_cons: \"ra \\<noteq> r \\<Longrightarrow>\n       apply_updates u (join_ir ia c) c $ ra = apply_updates ((r, a) # u) (join_ir ia c) c $ ra\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ra \\<noteq> r \\<Longrightarrow>\n    apply_updates u (join_ir ia c) c $ ra =\n    apply_updates ((r, a) # u) (join_ir ia c) c $ ra", "proof(induct u rule: rev_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. ra \\<noteq> r \\<Longrightarrow>\n    apply_updates [] (join_ir ia c) c $ ra =\n    apply_updates [(r, a)] (join_ir ia c) c $ ra\n 2. \\<And>x xs.\n       \\<lbrakk>ra \\<noteq> r \\<Longrightarrow>\n                apply_updates xs (join_ir ia c) c $ ra =\n                apply_updates ((r, a) # xs) (join_ir ia c) c $ ra;\n        ra \\<noteq> r\\<rbrakk>\n       \\<Longrightarrow> apply_updates (xs @ [x]) (join_ir ia c) c $ ra =\n                         apply_updates ((r, a) # xs @ [x]) (join_ir ia c)\n                          c $\n                         ra", "case Nil"], ["proof (state)\nthis:\n  ra \\<noteq> r\n\ngoal (2 subgoals):\n 1. ra \\<noteq> r \\<Longrightarrow>\n    apply_updates [] (join_ir ia c) c $ ra =\n    apply_updates [(r, a)] (join_ir ia c) c $ ra\n 2. \\<And>x xs.\n       \\<lbrakk>ra \\<noteq> r \\<Longrightarrow>\n                apply_updates xs (join_ir ia c) c $ ra =\n                apply_updates ((r, a) # xs) (join_ir ia c) c $ ra;\n        ra \\<noteq> r\\<rbrakk>\n       \\<Longrightarrow> apply_updates (xs @ [x]) (join_ir ia c) c $ ra =\n                         apply_updates ((r, a) # xs @ [x]) (join_ir ia c)\n                          c $\n                         ra", "then"], ["proof (chain)\npicking this:\n  ra \\<noteq> r", "show ?case"], ["proof (prove)\nusing this:\n  ra \\<noteq> r\n\ngoal (1 subgoal):\n 1. apply_updates [] (join_ir ia c) c $ ra =\n    apply_updates [(r, a)] (join_ir ia c) c $ ra", "by (simp add: apply_updates_def)"], ["proof (state)\nthis:\n  apply_updates [] (join_ir ia c) c $ ra =\n  apply_updates [(r, a)] (join_ir ia c) c $ ra\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>ra \\<noteq> r \\<Longrightarrow>\n                apply_updates xs (join_ir ia c) c $ ra =\n                apply_updates ((r, a) # xs) (join_ir ia c) c $ ra;\n        ra \\<noteq> r\\<rbrakk>\n       \\<Longrightarrow> apply_updates (xs @ [x]) (join_ir ia c) c $ ra =\n                         apply_updates ((r, a) # xs @ [x]) (join_ir ia c)\n                          c $\n                         ra", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>ra \\<noteq> r \\<Longrightarrow>\n                apply_updates xs (join_ir ia c) c $ ra =\n                apply_updates ((r, a) # xs) (join_ir ia c) c $ ra;\n        ra \\<noteq> r\\<rbrakk>\n       \\<Longrightarrow> apply_updates (xs @ [x]) (join_ir ia c) c $ ra =\n                         apply_updates ((r, a) # xs @ [x]) (join_ir ia c)\n                          c $\n                         ra", "case (snoc u us)"], ["proof (state)\nthis:\n  ra \\<noteq> r \\<Longrightarrow>\n  apply_updates us (join_ir ia c) c $ ra =\n  apply_updates ((r, a) # us) (join_ir ia c) c $ ra\n  ra \\<noteq> r\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>ra \\<noteq> r \\<Longrightarrow>\n                apply_updates xs (join_ir ia c) c $ ra =\n                apply_updates ((r, a) # xs) (join_ir ia c) c $ ra;\n        ra \\<noteq> r\\<rbrakk>\n       \\<Longrightarrow> apply_updates (xs @ [x]) (join_ir ia c) c $ ra =\n                         apply_updates ((r, a) # xs @ [x]) (join_ir ia c)\n                          c $\n                         ra", "then"], ["proof (chain)\npicking this:\n  ra \\<noteq> r \\<Longrightarrow>\n  apply_updates us (join_ir ia c) c $ ra =\n  apply_updates ((r, a) # us) (join_ir ia c) c $ ra\n  ra \\<noteq> r", "show ?case"], ["proof (prove)\nusing this:\n  ra \\<noteq> r \\<Longrightarrow>\n  apply_updates us (join_ir ia c) c $ ra =\n  apply_updates ((r, a) # us) (join_ir ia c) c $ ra\n  ra \\<noteq> r\n\ngoal (1 subgoal):\n 1. apply_updates (us @ [u]) (join_ir ia c) c $ ra =\n    apply_updates ((r, a) # us @ [u]) (join_ir ia c) c $ ra", "apply (cases u)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b.\n       \\<lbrakk>ra \\<noteq> r \\<Longrightarrow>\n                apply_updates us (join_ir ia c) c $ ra =\n                apply_updates ((r, a) # us) (join_ir ia c) c $ ra;\n        ra \\<noteq> r; u = (aa, b)\\<rbrakk>\n       \\<Longrightarrow> apply_updates (us @ [u]) (join_ir ia c) c $ ra =\n                         apply_updates ((r, a) # us @ [u]) (join_ir ia c)\n                          c $\n                         ra", "apply (simp add: apply_updates_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b.\n       \\<lbrakk>fold\n                 (\\<lambda>h r. r(fst h $:= aval (snd h) (join_ir ia c))) us\n                 c $\n                ra =\n                fold\n                 (\\<lambda>h r. r(fst h $:= aval (snd h) (join_ir ia c))) us\n                 (c(r $:= aval a (join_ir ia c))) $\n                ra;\n        ra \\<noteq> r; u = (aa, b)\\<rbrakk>\n       \\<Longrightarrow> ((fold\n                            (\\<lambda>h r. r\n                                (fst h $:= aval (snd h) (join_ir ia c)))\n                            us c)\n                          (aa $:= aval b (join_ir ia c))) $\n                         ra =\n                         ((fold\n                            (\\<lambda>h r. r\n                                (fst h $:= aval (snd h) (join_ir ia c)))\n                            us (c(r $:= aval a (join_ir ia c))))\n                          (aa $:= aval b (join_ir ia c))) $\n                         ra", "by (case_tac \"ra = aa\", auto)"], ["proof (state)\nthis:\n  apply_updates (us @ [u]) (join_ir ia c) c $ ra =\n  apply_updates ((r, a) # us @ [u]) (join_ir ia c) c $ ra\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma update_twice:\n  \"apply_updates [(r, a), (r, b)] s regs = regs (r $:= aval b s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. apply_updates [(r, a), (r, b)] s regs = regs(r $:= aval b s)", "by (simp add: apply_updates_def)"], ["", "lemma r_not_updated_stays_the_same:\n  \"r \\<notin> fst ` set U \\<Longrightarrow> apply_updates U c d $ r = d $ r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r \\<notin> fst ` set U \\<Longrightarrow> apply_updates U c d $ r = d $ r", "using apply_updates_def"], ["proof (prove)\nusing this:\n  apply_updates ?u ?old =\n  fold (\\<lambda>h r. r(fst h $:= aval (snd h) ?old)) ?u\n\ngoal (1 subgoal):\n 1. r \\<notin> fst ` set U \\<Longrightarrow> apply_updates U c d $ r = d $ r", "by (induct U rule: rev_induct, auto)"], ["", "definition rename_regs :: \"(nat \\<Rightarrow> nat) \\<Rightarrow> transition \\<Rightarrow> transition\" where\n  \"rename_regs f t = t\\<lparr>\n      Guards  := map (GExp.rename_regs f) (Guards t),\n      Outputs := map (AExp.rename_regs f) (Outputs t),\n      Updates := map (\\<lambda>(r, u). (f r, AExp.rename_regs f u)) (Updates t)\n    \\<rparr>\""], ["", "definition eq_upto_rename_strong :: \"transition \\<Rightarrow> transition \\<Rightarrow> bool\" where\n  \"eq_upto_rename_strong t1 t2 = (\\<exists>f. bij f \\<and> rename_regs f t1 = t2)\""], ["", "inductive eq_upto_rename :: \"transition \\<Rightarrow> transition \\<Rightarrow> bool\" where\n  \"Label t1 = Label t2 \\<Longrightarrow>\n   Arity t2 = Arity t2 \\<Longrightarrow>\n   apply_guards (map (GExp.rename_regs f) (Guards t1)) = apply_guards (Guards t2) \\<Longrightarrow>\n\n   apply_outputs (map (AExp.rename_regs f) (Outputs t1)) = apply_outputs (Outputs t2) \\<Longrightarrow>\n\n   apply_updates (map (\\<lambda>(r, u). (f r, AExp.rename_regs f u)) (Updates t1)) = apply_updates (Updates t2) \\<Longrightarrow>\n\n   eq_upto_rename t1 t2\""], ["", "end"]]}