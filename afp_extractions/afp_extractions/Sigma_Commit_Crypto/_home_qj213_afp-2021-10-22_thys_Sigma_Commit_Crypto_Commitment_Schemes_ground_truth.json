{"file_name": "/home/qj213/afp-2021-10-22/thys/Sigma_Commit_Crypto/Commitment_Schemes.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Sigma_Commit_Crypto", "problem_names": ["lemma   \"\\<lbrakk> lossless_spmf key_gen; lossless_spmf TI;\n          \\<And>pk m. valid_msg m \\<Longrightarrow> lossless_spmf (commit pk m) \\<rbrakk>\n              \\<Longrightarrow> valid_msg m \\<Longrightarrow> lossless_spmf (correct_game m)\"", "lemma lossless_hiding_game:\n  \"\\<lbrakk> lossless \\<A>; lossless_spmf key_gen;\n     \\<And>pk plain. valid_msg plain \\<Longrightarrow> lossless_spmf (commit pk plain) \\<rbrakk>\n  \\<Longrightarrow> lossless_spmf (hiding_game_ind_cpa \\<A>)\"", "lemma bind_game_alt_def:\n  \"bind_game \\<A> = TRY do {\n  (ck, vk) \\<leftarrow> key_gen;\n  (c, m, d, m', d') \\<leftarrow> \\<A> ck;\n  _ :: unit \\<leftarrow> assert_spmf (m \\<noteq> m' \\<and> valid_msg m \\<and> valid_msg m');\n  let b = verify vk m c d;\n  let b' = verify vk m' c d';\n  _ :: unit \\<leftarrow> assert_spmf (b \\<and> b'); \n  return_spmf True} ELSE return_spmf False\"\n  (is \"?lhs = ?rhs\")", "lemma lossless_binding_game: \"lossless_spmf (bind_game \\<A>)\""], "translations": [["", "lemma   \"\\<lbrakk> lossless_spmf key_gen; lossless_spmf TI;\n          \\<And>pk m. valid_msg m \\<Longrightarrow> lossless_spmf (commit pk m) \\<rbrakk>\n              \\<Longrightarrow> valid_msg m \\<Longrightarrow> lossless_spmf (correct_game m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>lossless_spmf key_gen; lossless_spmf TI;\n     \\<And>pk m. valid_msg m \\<Longrightarrow> lossless_spmf (commit pk m);\n     valid_msg m\\<rbrakk>\n    \\<Longrightarrow> lossless_spmf (correct_game m)", "by(simp add: lossless_def correct_game_def split_def Let_def)"], ["", "definition correct where \"correct \\<equiv> (\\<forall>m. valid_msg m \\<longrightarrow> spmf (correct_game m) True = 1)\""], ["", "text\\<open>The hiding property is defined using the hiding game. Here the adversary is asked to output two\nmessages, the challenger flips a coin to decide which message to commit and hand to the adversary.\nThe adversary's challenge is to guess which commitment it was handed. Note we must check the two \nmessages outputted by the adversary are valid.\\<close>"], ["", "primrec hiding_game_ind_cpa :: \"('vk, 'plain, 'commit, 'state) hid_adv \\<Rightarrow> bool spmf\"\n  where \"hiding_game_ind_cpa (\\<A>1, \\<A>2) = TRY do {\n  (ck, vk) \\<leftarrow> key_gen;\n  ((m0, m1), \\<sigma>) \\<leftarrow> \\<A>1 vk;\n  _ :: unit \\<leftarrow> assert_spmf (valid_msg m0 \\<and> valid_msg m1);\n  b \\<leftarrow> coin_spmf; \n  (c,d) \\<leftarrow> commit ck (if b then m0 else m1);\n  b' :: bool \\<leftarrow> \\<A>2 c \\<sigma>;\n  return_spmf (b' = b)} ELSE coin_spmf\""], ["", "text\\<open>The adversary wins the game if \\<open>b = b'\\<close>.\\<close>"], ["", "lemma lossless_hiding_game:\n  \"\\<lbrakk> lossless \\<A>; lossless_spmf key_gen;\n     \\<And>pk plain. valid_msg plain \\<Longrightarrow> lossless_spmf (commit pk plain) \\<rbrakk>\n  \\<Longrightarrow> lossless_spmf (hiding_game_ind_cpa \\<A>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>lossless \\<A>; lossless_spmf key_gen;\n     \\<And>pk plain.\n        valid_msg plain \\<Longrightarrow>\n        lossless_spmf (commit pk plain)\\<rbrakk>\n    \\<Longrightarrow> lossless_spmf (hiding_game_ind_cpa \\<A>)", "by(auto simp add: lossless_def hiding_game_ind_cpa_def split_def Let_def)"], ["", "text\\<open>To define security we consider the advantage an adversary has of winning the game over a tossing \na coin to determine their output.\\<close>"], ["", "definition hiding_advantage_ind_cpa :: \"('vk, 'plain, 'commit, 'state) hid_adv \\<Rightarrow> real\"\n  where \"hiding_advantage_ind_cpa \\<A> \\<equiv> \\<bar>spmf (hiding_game_ind_cpa \\<A>) True - 1/2\\<bar>\""], ["", "definition perfect_hiding_ind_cpa :: \"('vk, 'plain, 'commit, 'state) hid_adv \\<Rightarrow> bool\"\n  where \"perfect_hiding_ind_cpa \\<A> \\<equiv> (hiding_advantage_ind_cpa \\<A> = 0)\""], ["", "text\\<open>The binding game challenges an adversary to bind two messages to the same committed value. Both\nopening values and messages are verified with respect to the same committed value, the adversary wins\nif the game outputs true. We must check some conditions of the adversaries output are met;\nwe will always require that \\<open>m \\<noteq> m'\\<close>, other conditions will be dependent on the protocol for example \nwe may require group or field membership.\\<close>"], ["", "definition bind_game :: \"('ck, 'plain, 'commit, 'opening) bind_adversary \\<Rightarrow> bool spmf\"\n  where \"bind_game \\<A> = TRY do {\n  (ck, vk) \\<leftarrow> key_gen;\n  (c, m, d, m', d') \\<leftarrow> \\<A> ck;\n  _ :: unit \\<leftarrow> assert_spmf (m \\<noteq> m' \\<and> valid_msg m \\<and> valid_msg m');\n  let b = verify vk m c d;\n  let b' = verify vk m' c d';\n  return_spmf (b \\<and> b')} ELSE return_spmf False\""], ["", "text\\<open>We proof the binding game is equivalent to the following game which is easier to work with. In particular \nwe assert b and b' in the game and return True.\\<close>"], ["", "lemma bind_game_alt_def:\n  \"bind_game \\<A> = TRY do {\n  (ck, vk) \\<leftarrow> key_gen;\n  (c, m, d, m', d') \\<leftarrow> \\<A> ck;\n  _ :: unit \\<leftarrow> assert_spmf (m \\<noteq> m' \\<and> valid_msg m \\<and> valid_msg m');\n  let b = verify vk m c d;\n  let b' = verify vk m' c d';\n  _ :: unit \\<leftarrow> assert_spmf (b \\<and> b'); \n  return_spmf True} ELSE return_spmf False\"\n  (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. bind_game \\<A> =\n    TRY key_gen \\<bind>\n        (\\<lambda>(ck, vk).\n            \\<A> ck \\<bind>\n            (\\<lambda>(c, m, d, m', d').\n                assert_spmf\n                 (m \\<noteq> m' \\<and>\n                  valid_msg m \\<and> valid_msg m') \\<bind>\n                (\\<lambda>_.\n                    let b = verify vk m c d; b' = verify vk m' c d'\n                    in assert_spmf (b \\<and> b') \\<bind>\n                       (\\<lambda>_.\n                           return_spmf True)))) ELSE return_spmf False", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. bind_game \\<A> =\n    TRY key_gen \\<bind>\n        (\\<lambda>(ck, vk).\n            \\<A> ck \\<bind>\n            (\\<lambda>(c, m, d, m', d').\n                assert_spmf\n                 (m \\<noteq> m' \\<and>\n                  valid_msg m \\<and> valid_msg m') \\<bind>\n                (\\<lambda>_.\n                    let b = verify vk m c d; b' = verify vk m' c d'\n                    in assert_spmf (b \\<and> b') \\<bind>\n                       (\\<lambda>_.\n                           return_spmf True)))) ELSE return_spmf False", "have \"?lhs = TRY do {\n      (ck, vk) \\<leftarrow> key_gen;\n      TRY do {\n        (c, m, d, m', d') \\<leftarrow> \\<A> ck;\n        TRY do {\n          _ :: unit \\<leftarrow> assert_spmf (m \\<noteq> m' \\<and> valid_msg m \\<and> valid_msg m');\n          TRY return_spmf (verify vk m c d \\<and> verify vk m' c d') ELSE return_spmf False\n        } ELSE return_spmf False\n      } ELSE return_spmf False\n    } ELSE return_spmf False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bind_game \\<A> =\n    TRY key_gen \\<bind>\n        (\\<lambda>(ck, vk).\n            TRY \\<A> ck \\<bind>\n                (\\<lambda>(c, m, d, m', d').\n                    TRY assert_spmf\n                         (m \\<noteq> m' \\<and>\n                          valid_msg m \\<and> valid_msg m') \\<bind>\n                        (\\<lambda>_.\n                            TRY return_spmf\n                                 (verify vk m c d \\<and>\n                                  verify vk m' c\n                                   d') ELSE return_spmf\n       False) ELSE return_spmf\n                    False) ELSE return_spmf False) ELSE return_spmf False", "unfolding split_def bind_game_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. TRY key_gen \\<bind>\n        (\\<lambda>p.\n            \\<A> (fst p) \\<bind>\n            (\\<lambda>pa.\n                assert_spmf\n                 (fst (snd pa) \\<noteq> fst (snd (snd (snd pa))) \\<and>\n                  valid_msg (fst (snd pa)) \\<and>\n                  valid_msg (fst (snd (snd (snd pa))))) \\<bind>\n                (\\<lambda>_.\n                    let b = verify (snd p) (fst (snd pa)) (fst pa)\n                             (fst (snd (snd pa)));\n                        b' = verify (snd p) (fst (snd (snd (snd pa))))\n                              (fst pa) (snd (snd (snd (snd pa))))\n                    in return_spmf (b \\<and> b')))) ELSE return_spmf False =\n    TRY key_gen \\<bind>\n        (\\<lambda>p.\n            TRY \\<A> (fst p) \\<bind>\n                (\\<lambda>pa.\n                    TRY assert_spmf\n                         (fst (snd pa) \\<noteq>\n                          fst (snd (snd (snd pa))) \\<and>\n                          valid_msg (fst (snd pa)) \\<and>\n                          valid_msg (fst (snd (snd (snd pa))))) \\<bind>\n                        (\\<lambda>_.\n                            TRY return_spmf\n                                 (verify (snd p) (fst (snd pa)) (fst pa)\n                                   (fst (snd (snd pa))) \\<and>\n                                  verify (snd p) (fst (snd (snd (snd pa))))\n                                   (fst pa)\n                                   (snd (snd\n    (snd (snd pa))))) ELSE return_spmf\n                            False) ELSE return_spmf\n   False) ELSE return_spmf False) ELSE return_spmf False", "by(fold try_bind_spmf_lossless2[OF lossless_return_spmf]) simp"], ["proof (state)\nthis:\n  bind_game \\<A> =\n  TRY key_gen \\<bind>\n      (\\<lambda>(ck, vk).\n          TRY \\<A> ck \\<bind>\n              (\\<lambda>(c, m, d, m', d').\n                  TRY assert_spmf\n                       (m \\<noteq> m' \\<and>\n                        valid_msg m \\<and> valid_msg m') \\<bind>\n                      (\\<lambda>_.\n                          TRY return_spmf\n                               (verify vk m c d \\<and>\n                                verify vk m' c\n                                 d') ELSE return_spmf\n     False) ELSE return_spmf\n                  False) ELSE return_spmf False) ELSE return_spmf False\n\ngoal (1 subgoal):\n 1. bind_game \\<A> =\n    TRY key_gen \\<bind>\n        (\\<lambda>(ck, vk).\n            \\<A> ck \\<bind>\n            (\\<lambda>(c, m, d, m', d').\n                assert_spmf\n                 (m \\<noteq> m' \\<and>\n                  valid_msg m \\<and> valid_msg m') \\<bind>\n                (\\<lambda>_.\n                    let b = verify vk m c d; b' = verify vk m' c d'\n                    in assert_spmf (b \\<and> b') \\<bind>\n                       (\\<lambda>_.\n                           return_spmf True)))) ELSE return_spmf False", "also"], ["proof (state)\nthis:\n  bind_game \\<A> =\n  TRY key_gen \\<bind>\n      (\\<lambda>(ck, vk).\n          TRY \\<A> ck \\<bind>\n              (\\<lambda>(c, m, d, m', d').\n                  TRY assert_spmf\n                       (m \\<noteq> m' \\<and>\n                        valid_msg m \\<and> valid_msg m') \\<bind>\n                      (\\<lambda>_.\n                          TRY return_spmf\n                               (verify vk m c d \\<and>\n                                verify vk m' c\n                                 d') ELSE return_spmf\n     False) ELSE return_spmf\n                  False) ELSE return_spmf False) ELSE return_spmf False\n\ngoal (1 subgoal):\n 1. bind_game \\<A> =\n    TRY key_gen \\<bind>\n        (\\<lambda>(ck, vk).\n            \\<A> ck \\<bind>\n            (\\<lambda>(c, m, d, m', d').\n                assert_spmf\n                 (m \\<noteq> m' \\<and>\n                  valid_msg m \\<and> valid_msg m') \\<bind>\n                (\\<lambda>_.\n                    let b = verify vk m c d; b' = verify vk m' c d'\n                    in assert_spmf (b \\<and> b') \\<bind>\n                       (\\<lambda>_.\n                           return_spmf True)))) ELSE return_spmf False", "have \"\\<dots> = TRY do {\n      (ck, vk) \\<leftarrow> key_gen;\n      TRY do {\n        (c, m, d, m', d') \\<leftarrow> \\<A> ck;\n        TRY do {\n          _ :: unit \\<leftarrow> assert_spmf (m \\<noteq> m' \\<and> valid_msg m \\<and> valid_msg m');\n          TRY do {\n            _ :: unit \\<leftarrow> assert_spmf (verify vk m c d \\<and> verify vk m' c d');\n            return_spmf True\n          } ELSE return_spmf False\n        } ELSE return_spmf False\n      } ELSE return_spmf False\n    } ELSE return_spmf False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. TRY key_gen \\<bind>\n        (\\<lambda>(ck, vk).\n            TRY \\<A> ck \\<bind>\n                (\\<lambda>(c, m, d, m', d').\n                    TRY assert_spmf\n                         (m \\<noteq> m' \\<and>\n                          valid_msg m \\<and> valid_msg m') \\<bind>\n                        (\\<lambda>_.\n                            TRY return_spmf\n                                 (verify vk m c d \\<and>\n                                  verify vk m' c\n                                   d') ELSE return_spmf\n       False) ELSE return_spmf\n                    False) ELSE return_spmf False) ELSE return_spmf False =\n    TRY key_gen \\<bind>\n        (\\<lambda>(ck, vk).\n            TRY \\<A> ck \\<bind>\n                (\\<lambda>(c, m, d, m', d').\n                    TRY assert_spmf\n                         (m \\<noteq> m' \\<and>\n                          valid_msg m \\<and> valid_msg m') \\<bind>\n                        (\\<lambda>_.\n                            TRY assert_spmf\n                                 (verify vk m c d \\<and>\n                                  verify vk m' c d') \\<bind>\n                                (\\<lambda>_.\n                                    return_spmf\n                                     True) ELSE return_spmf\n           False) ELSE return_spmf\n                        False) ELSE return_spmf\n                                     False) ELSE return_spmf False", "by(auto simp add: try_bind_assert_spmf try_spmf_return_spmf1 intro!: try_spmf_cong bind_spmf_cong)"], ["proof (state)\nthis:\n  TRY key_gen \\<bind>\n      (\\<lambda>(ck, vk).\n          TRY \\<A> ck \\<bind>\n              (\\<lambda>(c, m, d, m', d').\n                  TRY assert_spmf\n                       (m \\<noteq> m' \\<and>\n                        valid_msg m \\<and> valid_msg m') \\<bind>\n                      (\\<lambda>_.\n                          TRY return_spmf\n                               (verify vk m c d \\<and>\n                                verify vk m' c\n                                 d') ELSE return_spmf\n     False) ELSE return_spmf\n                  False) ELSE return_spmf False) ELSE return_spmf False =\n  TRY key_gen \\<bind>\n      (\\<lambda>(ck, vk).\n          TRY \\<A> ck \\<bind>\n              (\\<lambda>(c, m, d, m', d').\n                  TRY assert_spmf\n                       (m \\<noteq> m' \\<and>\n                        valid_msg m \\<and> valid_msg m') \\<bind>\n                      (\\<lambda>_.\n                          TRY assert_spmf\n                               (verify vk m c d \\<and>\n                                verify vk m' c d') \\<bind>\n                              (\\<lambda>_.\n                                  return_spmf\n                                   True) ELSE return_spmf\n         False) ELSE return_spmf\n                      False) ELSE return_spmf False) ELSE return_spmf False\n\ngoal (1 subgoal):\n 1. bind_game \\<A> =\n    TRY key_gen \\<bind>\n        (\\<lambda>(ck, vk).\n            \\<A> ck \\<bind>\n            (\\<lambda>(c, m, d, m', d').\n                assert_spmf\n                 (m \\<noteq> m' \\<and>\n                  valid_msg m \\<and> valid_msg m') \\<bind>\n                (\\<lambda>_.\n                    let b = verify vk m c d; b' = verify vk m' c d'\n                    in assert_spmf (b \\<and> b') \\<bind>\n                       (\\<lambda>_.\n                           return_spmf True)))) ELSE return_spmf False", "also"], ["proof (state)\nthis:\n  TRY key_gen \\<bind>\n      (\\<lambda>(ck, vk).\n          TRY \\<A> ck \\<bind>\n              (\\<lambda>(c, m, d, m', d').\n                  TRY assert_spmf\n                       (m \\<noteq> m' \\<and>\n                        valid_msg m \\<and> valid_msg m') \\<bind>\n                      (\\<lambda>_.\n                          TRY return_spmf\n                               (verify vk m c d \\<and>\n                                verify vk m' c\n                                 d') ELSE return_spmf\n     False) ELSE return_spmf\n                  False) ELSE return_spmf False) ELSE return_spmf False =\n  TRY key_gen \\<bind>\n      (\\<lambda>(ck, vk).\n          TRY \\<A> ck \\<bind>\n              (\\<lambda>(c, m, d, m', d').\n                  TRY assert_spmf\n                       (m \\<noteq> m' \\<and>\n                        valid_msg m \\<and> valid_msg m') \\<bind>\n                      (\\<lambda>_.\n                          TRY assert_spmf\n                               (verify vk m c d \\<and>\n                                verify vk m' c d') \\<bind>\n                              (\\<lambda>_.\n                                  return_spmf\n                                   True) ELSE return_spmf\n         False) ELSE return_spmf\n                      False) ELSE return_spmf False) ELSE return_spmf False\n\ngoal (1 subgoal):\n 1. bind_game \\<A> =\n    TRY key_gen \\<bind>\n        (\\<lambda>(ck, vk).\n            \\<A> ck \\<bind>\n            (\\<lambda>(c, m, d, m', d').\n                assert_spmf\n                 (m \\<noteq> m' \\<and>\n                  valid_msg m \\<and> valid_msg m') \\<bind>\n                (\\<lambda>_.\n                    let b = verify vk m c d; b' = verify vk m' c d'\n                    in assert_spmf (b \\<and> b') \\<bind>\n                       (\\<lambda>_.\n                           return_spmf True)))) ELSE return_spmf False", "have \"\\<dots> = ?rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. TRY key_gen \\<bind>\n        (\\<lambda>(ck, vk).\n            TRY \\<A> ck \\<bind>\n                (\\<lambda>(c, m, d, m', d').\n                    TRY assert_spmf\n                         (m \\<noteq> m' \\<and>\n                          valid_msg m \\<and> valid_msg m') \\<bind>\n                        (\\<lambda>_.\n                            TRY assert_spmf\n                                 (verify vk m c d \\<and>\n                                  verify vk m' c d') \\<bind>\n                                (\\<lambda>_.\n                                    return_spmf\n                                     True) ELSE return_spmf\n           False) ELSE return_spmf\n                        False) ELSE return_spmf\n                                     False) ELSE return_spmf False =\n    TRY key_gen \\<bind>\n        (\\<lambda>(ck, vk).\n            \\<A> ck \\<bind>\n            (\\<lambda>(c, m, d, m', d').\n                assert_spmf\n                 (m \\<noteq> m' \\<and>\n                  valid_msg m \\<and> valid_msg m') \\<bind>\n                (\\<lambda>_.\n                    let b = verify vk m c d; b' = verify vk m' c d'\n                    in assert_spmf (b \\<and> b') \\<bind>\n                       (\\<lambda>_.\n                           return_spmf True)))) ELSE return_spmf False", "unfolding split_def Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. TRY key_gen \\<bind>\n        (\\<lambda>p.\n            TRY \\<A> (fst p) \\<bind>\n                (\\<lambda>pa.\n                    TRY assert_spmf\n                         (fst (snd pa) \\<noteq>\n                          fst (snd (snd (snd pa))) \\<and>\n                          valid_msg (fst (snd pa)) \\<and>\n                          valid_msg (fst (snd (snd (snd pa))))) \\<bind>\n                        (\\<lambda>_.\n                            TRY assert_spmf\n                                 (verify (snd p) (fst (snd pa)) (fst pa)\n                                   (fst (snd (snd pa))) \\<and>\n                                  verify (snd p) (fst (snd (snd (snd pa))))\n                                   (fst pa)\n                                   (snd (snd (snd (snd pa))))) \\<bind>\n                                (\\<lambda>_.\n                                    return_spmf\n                                     True) ELSE return_spmf\n           False) ELSE return_spmf\n                        False) ELSE return_spmf\n                                     False) ELSE return_spmf False =\n    TRY key_gen \\<bind>\n        (\\<lambda>p.\n            \\<A> (fst p) \\<bind>\n            (\\<lambda>pa.\n                assert_spmf\n                 (fst (snd pa) \\<noteq> fst (snd (snd (snd pa))) \\<and>\n                  valid_msg (fst (snd pa)) \\<and>\n                  valid_msg (fst (snd (snd (snd pa))))) \\<bind>\n                (\\<lambda>_.\n                    assert_spmf\n                     (verify (snd p) (fst (snd pa)) (fst pa)\n                       (fst (snd (snd pa))) \\<and>\n                      verify (snd p) (fst (snd (snd (snd pa)))) (fst pa)\n                       (snd (snd (snd (snd pa))))) \\<bind>\n                    (\\<lambda>_. return_spmf True)))) ELSE return_spmf False", "by(fold try_bind_spmf_lossless2[OF lossless_return_spmf]) simp"], ["proof (state)\nthis:\n  TRY key_gen \\<bind>\n      (\\<lambda>(ck, vk).\n          TRY \\<A> ck \\<bind>\n              (\\<lambda>(c, m, d, m', d').\n                  TRY assert_spmf\n                       (m \\<noteq> m' \\<and>\n                        valid_msg m \\<and> valid_msg m') \\<bind>\n                      (\\<lambda>_.\n                          TRY assert_spmf\n                               (verify vk m c d \\<and>\n                                verify vk m' c d') \\<bind>\n                              (\\<lambda>_.\n                                  return_spmf\n                                   True) ELSE return_spmf\n         False) ELSE return_spmf\n                      False) ELSE return_spmf\n                                   False) ELSE return_spmf False =\n  TRY key_gen \\<bind>\n      (\\<lambda>(ck, vk).\n          \\<A> ck \\<bind>\n          (\\<lambda>(c, m, d, m', d').\n              assert_spmf\n               (m \\<noteq> m' \\<and>\n                valid_msg m \\<and> valid_msg m') \\<bind>\n              (\\<lambda>_.\n                  let b = verify vk m c d; b' = verify vk m' c d'\n                  in assert_spmf (b \\<and> b') \\<bind>\n                     (\\<lambda>_.\n                         return_spmf True)))) ELSE return_spmf False\n\ngoal (1 subgoal):\n 1. bind_game \\<A> =\n    TRY key_gen \\<bind>\n        (\\<lambda>(ck, vk).\n            \\<A> ck \\<bind>\n            (\\<lambda>(c, m, d, m', d').\n                assert_spmf\n                 (m \\<noteq> m' \\<and>\n                  valid_msg m \\<and> valid_msg m') \\<bind>\n                (\\<lambda>_.\n                    let b = verify vk m c d; b' = verify vk m' c d'\n                    in assert_spmf (b \\<and> b') \\<bind>\n                       (\\<lambda>_.\n                           return_spmf True)))) ELSE return_spmf False", "finally"], ["proof (chain)\npicking this:\n  bind_game \\<A> =\n  TRY key_gen \\<bind>\n      (\\<lambda>(ck, vk).\n          \\<A> ck \\<bind>\n          (\\<lambda>(c, m, d, m', d').\n              assert_spmf\n               (m \\<noteq> m' \\<and>\n                valid_msg m \\<and> valid_msg m') \\<bind>\n              (\\<lambda>_.\n                  let b = verify vk m c d; b' = verify vk m' c d'\n                  in assert_spmf (b \\<and> b') \\<bind>\n                     (\\<lambda>_.\n                         return_spmf True)))) ELSE return_spmf False", "show ?thesis"], ["proof (prove)\nusing this:\n  bind_game \\<A> =\n  TRY key_gen \\<bind>\n      (\\<lambda>(ck, vk).\n          \\<A> ck \\<bind>\n          (\\<lambda>(c, m, d, m', d').\n              assert_spmf\n               (m \\<noteq> m' \\<and>\n                valid_msg m \\<and> valid_msg m') \\<bind>\n              (\\<lambda>_.\n                  let b = verify vk m c d; b' = verify vk m' c d'\n                  in assert_spmf (b \\<and> b') \\<bind>\n                     (\\<lambda>_.\n                         return_spmf True)))) ELSE return_spmf False\n\ngoal (1 subgoal):\n 1. bind_game \\<A> =\n    TRY key_gen \\<bind>\n        (\\<lambda>(ck, vk).\n            \\<A> ck \\<bind>\n            (\\<lambda>(c, m, d, m', d').\n                assert_spmf\n                 (m \\<noteq> m' \\<and>\n                  valid_msg m \\<and> valid_msg m') \\<bind>\n                (\\<lambda>_.\n                    let b = verify vk m c d; b' = verify vk m' c d'\n                    in assert_spmf (b \\<and> b') \\<bind>\n                       (\\<lambda>_.\n                           return_spmf True)))) ELSE return_spmf False", "."], ["proof (state)\nthis:\n  bind_game \\<A> =\n  TRY key_gen \\<bind>\n      (\\<lambda>(ck, vk).\n          \\<A> ck \\<bind>\n          (\\<lambda>(c, m, d, m', d').\n              assert_spmf\n               (m \\<noteq> m' \\<and>\n                valid_msg m \\<and> valid_msg m') \\<bind>\n              (\\<lambda>_.\n                  let b = verify vk m c d; b' = verify vk m' c d'\n                  in assert_spmf (b \\<and> b') \\<bind>\n                     (\\<lambda>_.\n                         return_spmf True)))) ELSE return_spmf False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lossless_binding_game: \"lossless_spmf (bind_game \\<A>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lossless_spmf (bind_game \\<A>)", "by (simp add: bind_game_def)"], ["", "definition bind_advantage :: \"('ck, 'plain, 'commit, 'opening) bind_adversary \\<Rightarrow> real\"\n  where \"bind_advantage \\<A> \\<equiv> spmf (bind_game \\<A>) True\""], ["", "end"], ["", "end"]]}