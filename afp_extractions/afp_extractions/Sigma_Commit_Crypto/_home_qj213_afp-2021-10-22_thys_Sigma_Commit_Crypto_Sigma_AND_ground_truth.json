{"file_name": "/home/qj213/afp-2021-10-22/thys/Sigma_Commit_Crypto/Sigma_AND.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Sigma_Commit_Crypto", "problem_names": ["lemma lossless_init_AND: \"lossless_spmf (init_AND X W)\"", "lemma lossless_response_AND: \"lossless_spmf (response_AND R W s)\"", "lemma hvzk: \n  assumes Rel_AND: \"((x0,x1), (w0,w1)) \\<in> Rel_AND\"\n  and \"e \\<in> challenge_space\" \n  shows \"\\<Sigma>_AND.R (x0,x1) (w0,w1) e = \\<Sigma>_AND.S (x0,x1) e\"", "lemma HVZK: \"\\<Sigma>_AND.HVZK\"", "lemma correct: \n  assumes Rel_AND: \"((x0,x1), (w0,w1)) \\<in> Rel_AND\"\n  and \"e \\<in> challenge_space\" \n  shows \"\\<Sigma>_AND.completeness_game (x0,x1) (w0,w1) e = return_spmf True\"", "lemma completeness: \"\\<Sigma>_AND.completeness\"", "lemma ss:\n  assumes e_neq_e': \"s \\<noteq> s'\"\n    and valid_pub: \"(x0,x1) \\<in> valid_pub_AND\"\n    and challenge_space: \"s \\<in> challenge_space\" \"s' \\<in> challenge_space\"\n    and \"check_AND (x0,x1) (a0,a1) s (z0,z1)\" \n    and \"check_AND  (x0,x1) (a0,a1) s' (z0',z1')\" \n  shows  \"lossless_spmf (\\<A>ss_AND  (x0,x1) ((a0,a1), s, (z0,z1)) ((a0,a1), s', (z0',z1'))) \n              \\<and> (\\<forall>w'\\<in>set_spmf (\\<A>ss_AND  (x0,x1) ((a0,a1), s, (z0,z1)) ((a0,a1), s', (z0',z1'))). ((x0,x1), w') \\<in> Rel_AND)\"", "lemma special_soundness:\n  shows \"\\<Sigma>_AND.special_soundness\"", "theorem \\<Sigma>_protocol:\n  shows \"\\<Sigma>_AND.\\<Sigma>_protocol\"", "lemma \"AND_\\<Sigma>_commit.abstract_com.correct\"", "lemma \"AND_\\<Sigma>_commit.abstract_com.perfect_hiding_ind_cpa \\<A>\"", "lemma bind_advantage_bound_dis_log: \n  shows \"AND_\\<Sigma>_commit.abstract_com.bind_advantage \\<A> \\<le> AND_\\<Sigma>_commit.rel_advantage (AND_\\<Sigma>_commit.adversary \\<A>)\""], "translations": [["", "lemma lossless_init_AND: \"lossless_spmf (init_AND X W)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lossless_spmf (init_AND X W)", "by(simp add: lossless_init init_AND_def split_def)"], ["", "definition response_AND :: \"('rand0 \\<times> 'rand1) \\<Rightarrow> ('witness0 \\<times> 'witness1) \\<Rightarrow> 'bool \\<Rightarrow> ('response0 \\<times> 'response1) spmf\"\n  where \"response_AND R W s = do {\n    let (r0,r1) = R;\n    let (w0,w1) = W;  \n    z0 \\<leftarrow> response0 r0 w0 s;\n    z1  :: 'response1 \\<leftarrow> response1 r1 w1 s;\n    return_spmf (z0,z1)}\""], ["", "lemma lossless_response_AND: \"lossless_spmf (response_AND R W s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lossless_spmf (response_AND R W s)", "by(simp add: response_AND_def lossless_response split_def)"], ["", "fun check_AND :: \"('pub0 \\<times> 'pub1) \\<Rightarrow> ('msg0 \\<times> 'msg1) \\<Rightarrow> 'bool \\<Rightarrow> ('response0 \\<times> 'response1) \\<Rightarrow> bool\"\n  where \"check_AND (x0,x1) (a0,a1) s (z0,z1) = (check0 x0 a0 s z0 \\<and> check1 x1 a1 s z1)\""], ["", "definition S_AND :: \"'pub0 \\<times> 'pub1 \\<Rightarrow> 'bool \\<Rightarrow> (('msg0 \\<times> 'msg1) \\<times> 'response0 \\<times> 'response1) spmf\"\n  where \"S_AND X e = do {\n    let (x0,x1) = X;\n    (a0, z0) \\<leftarrow> S0_raw x0 e;\n    (a1, z1) \\<leftarrow> S1_raw x1 e;\n    return_spmf ((a0,a1),(z0,z1))}\""], ["", "fun \\<A>ss_AND :: \"'pub0 \\<times> 'pub1 \\<Rightarrow> ('msg0 \\<times> 'msg1) \\<times> 'bool \\<times> 'response0 \\<times> 'response1 \\<Rightarrow> ('msg0 \\<times> 'msg1) \\<times> 'bool \\<times> 'response0 \\<times> 'response1 \\<Rightarrow> ('witness0 \\<times> 'witness1) spmf\"\n  where \"\\<A>ss_AND (x0,x1) ((a0,a1), e, (z0,z1)) ((a0',a1'), e', (z0',z1')) = do {\n    w0 :: 'witness0 \\<leftarrow> \\<A>ss0 x0 (a0,e,z0) (a0',e',z0');\n    w1 \\<leftarrow> \\<A>ss1 x1 (a1,e,z1) (a1',e',z1');\n    return_spmf (w0,w1)}\""], ["", "definition \"valid_pub_AND = {(x0,x1). x0 \\<in> valid_pub0 \\<and> x1 \\<in> valid_pub1}\""], ["", "sublocale \\<Sigma>_AND: \\<Sigma>_protocols_base init_AND response_AND check_AND Rel_AND S_AND \\<A>ss_AND challenge_space valid_pub_AND"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sigma>_protocols_base Rel_AND valid_pub_AND", "apply unfold_locales"], ["proof (prove)\ngoal (1 subgoal):\n 1. Domain Rel_AND \\<subseteq> valid_pub_AND", "apply(simp add: Rel_AND_def valid_pub_AND_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. \\<exists>a b.\n           (case x of\n            (x0, x1) \\<Rightarrow>\n              \\<lambda>(w0, w1).\n                 (x0, w0) \\<in> Rel0 \\<and> (x1, w1) \\<in> Rel1)\n            (a, b)}\n    \\<subseteq> valid_pub0 \\<times> valid_pub1", "using \\<Sigma>1.domain_subset_valid_pub \\<Sigma>0.domain_subset_valid_pub"], ["proof (prove)\nusing this:\n  Domain Rel1 \\<subseteq> valid_pub1\n  Domain Rel0 \\<subseteq> valid_pub0\n\ngoal (1 subgoal):\n 1. {x. \\<exists>a b.\n           (case x of\n            (x0, x1) \\<Rightarrow>\n              \\<lambda>(w0, w1).\n                 (x0, w0) \\<in> Rel0 \\<and> (x1, w1) \\<in> Rel1)\n            (a, b)}\n    \\<subseteq> valid_pub0 \\<times> valid_pub1", "by blast"], ["", "end"], ["", "locale \\<Sigma>_AND = \\<Sigma>_AND_base +\n  assumes set_spmf_G_L: \"((x0, x1), w0, w1) \\<in> set_spmf G \\<Longrightarrow> ((x0, x1), (w0,w1)) \\<in> Rel_AND\"\nbegin"], ["", "lemma hvzk: \n  assumes Rel_AND: \"((x0,x1), (w0,w1)) \\<in> Rel_AND\"\n  and \"e \\<in> challenge_space\" \n  shows \"\\<Sigma>_AND.R (x0,x1) (w0,w1) e = \\<Sigma>_AND.S (x0,x1) e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sigma>_AND.R (x0, x1) (w0, w1) e = \\<Sigma>_AND.S (x0, x1) e", "including monad_normalisation"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sigma>_AND.R (x0, x1) (w0, w1) e = \\<Sigma>_AND.S (x0, x1) e", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Sigma>_AND.R (x0, x1) (w0, w1) e = \\<Sigma>_AND.S (x0, x1) e", "have x_in_dom: \"x0 \\<in> Domain Rel0\" and \"x1 \\<in> Domain Rel1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x0 \\<in> Domain Rel0 &&& x1 \\<in> Domain Rel1", "using Rel_AND Rel_AND_def"], ["proof (prove)\nusing this:\n  ((x0, x1), w0, w1) \\<in> Rel_AND\n  Rel_AND =\n  {((x0, x1), w0, w1). (x0, w0) \\<in> Rel0 \\<and> (x1, w1) \\<in> Rel1}\n\ngoal (1 subgoal):\n 1. x0 \\<in> Domain Rel0 &&& x1 \\<in> Domain Rel1", "by auto"], ["proof (state)\nthis:\n  x0 \\<in> Domain Rel0\n  x1 \\<in> Domain Rel1\n\ngoal (1 subgoal):\n 1. \\<Sigma>_AND.R (x0, x1) (w0, w1) e = \\<Sigma>_AND.S (x0, x1) e", "have \"\\<Sigma>_AND.R (x0,x1) (w0,w1) e = do {\n    ((r0,r1),(a0,a1)) \\<leftarrow> init_AND (x0,x1) (w0,w1);\n    (z0,z1) \\<leftarrow> response_AND (r0,r1) (w0,w1) e;\n    return_spmf ((a0,a1),e,(z0,z1))}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sigma>_AND.R (x0, x1) (w0, w1) e =\n    init_AND (x0, x1) (w0, w1) \\<bind>\n    (\\<lambda>((r0, r1), a0, a1).\n        response_AND (r0, r1) (w0, w1) e \\<bind>\n        (\\<lambda>(z0, z1). return_spmf ((a0, a1), e, z0, z1)))", "by(simp add: \\<Sigma>_AND.R_def split_def)"], ["proof (state)\nthis:\n  \\<Sigma>_AND.R (x0, x1) (w0, w1) e =\n  init_AND (x0, x1) (w0, w1) \\<bind>\n  (\\<lambda>((r0, r1), a0, a1).\n      response_AND (r0, r1) (w0, w1) e \\<bind>\n      (\\<lambda>(z0, z1). return_spmf ((a0, a1), e, z0, z1)))\n\ngoal (1 subgoal):\n 1. \\<Sigma>_AND.R (x0, x1) (w0, w1) e = \\<Sigma>_AND.S (x0, x1) e", "also"], ["proof (state)\nthis:\n  \\<Sigma>_AND.R (x0, x1) (w0, w1) e =\n  init_AND (x0, x1) (w0, w1) \\<bind>\n  (\\<lambda>((r0, r1), a0, a1).\n      response_AND (r0, r1) (w0, w1) e \\<bind>\n      (\\<lambda>(z0, z1). return_spmf ((a0, a1), e, z0, z1)))\n\ngoal (1 subgoal):\n 1. \\<Sigma>_AND.R (x0, x1) (w0, w1) e = \\<Sigma>_AND.S (x0, x1) e", "have \"... = do {\n    (r0, a0) \\<leftarrow> init0 x0 w0;\n    z0 \\<leftarrow> response0 r0 w0 e;\n    (r1, a1) \\<leftarrow> init1 x1 w1;\n    z1 :: 'f \\<leftarrow> response1 r1 w1 e;\n    return_spmf ((a0,a1),e,(z0,z1))}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. init_AND (x0, x1) (w0, w1) \\<bind>\n    (\\<lambda>((r0, r1), a0, a1).\n        response_AND (r0, r1) (w0, w1) e \\<bind>\n        (\\<lambda>(z0, z1). return_spmf ((a0, a1), e, z0, z1))) =\n    init0 x0 w0 \\<bind>\n    (\\<lambda>(r0, a0).\n        response0 r0 w0 e \\<bind>\n        (\\<lambda>z0.\n            init1 x1 w1 \\<bind>\n            (\\<lambda>(r1, a1).\n                response1 r1 w1 e \\<bind>\n                (\\<lambda>z1. return_spmf ((a0, a1), e, z0, z1)))))", "apply(simp add: init_AND_def response_AND_def split_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. init1 x1 w1 \\<bind>\n    (\\<lambda>y.\n        response1 (fst y) w1 e \\<bind>\n        (\\<lambda>ya.\n            init0 x0 w0 \\<bind>\n            (\\<lambda>yb.\n                response0 (fst yb) w0 e \\<bind>\n                (\\<lambda>yc. return_spmf ((snd yb, snd y), e, yc, ya))))) =\n    init0 x0 w0 \\<bind>\n    (\\<lambda>p.\n        response0 (fst p) w0 e \\<bind>\n        (\\<lambda>z0.\n            init1 x1 w1 \\<bind>\n            (\\<lambda>pa.\n                response1 (fst pa) w1 e \\<bind>\n                (\\<lambda>z1. return_spmf ((snd p, snd pa), e, z0, z1)))))", "apply(rewrite bind_commute_spmf[of \"response0 _ w0 e\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. init1 x1 w1 \\<bind>\n    (\\<lambda>y.\n        response1 (fst y) w1 e \\<bind>\n        (\\<lambda>ya.\n            init0 x0 w0 \\<bind>\n            (\\<lambda>yb.\n                response0 (fst yb) w0 e \\<bind>\n                (\\<lambda>yc. return_spmf ((snd yb, snd y), e, yc, ya))))) =\n    init0 x0 w0 \\<bind>\n    (\\<lambda>p.\n        init1 x1 w1 \\<bind>\n        (\\<lambda>y.\n            response0 (fst p) w0 e \\<bind>\n            (\\<lambda>z0.\n                response1 (fst y) w1 e \\<bind>\n                (\\<lambda>z1. return_spmf ((snd p, snd y), e, z0, z1)))))", "by simp"], ["proof (state)\nthis:\n  init_AND (x0, x1) (w0, w1) \\<bind>\n  (\\<lambda>((r0, r1), a0, a1).\n      response_AND (r0, r1) (w0, w1) e \\<bind>\n      (\\<lambda>(z0, z1). return_spmf ((a0, a1), e, z0, z1))) =\n  init0 x0 w0 \\<bind>\n  (\\<lambda>(r0, a0).\n      response0 r0 w0 e \\<bind>\n      (\\<lambda>z0.\n          init1 x1 w1 \\<bind>\n          (\\<lambda>(r1, a1).\n              response1 r1 w1 e \\<bind>\n              (\\<lambda>z1. return_spmf ((a0, a1), e, z0, z1)))))\n\ngoal (1 subgoal):\n 1. \\<Sigma>_AND.R (x0, x1) (w0, w1) e = \\<Sigma>_AND.S (x0, x1) e", "also"], ["proof (state)\nthis:\n  init_AND (x0, x1) (w0, w1) \\<bind>\n  (\\<lambda>((r0, r1), a0, a1).\n      response_AND (r0, r1) (w0, w1) e \\<bind>\n      (\\<lambda>(z0, z1). return_spmf ((a0, a1), e, z0, z1))) =\n  init0 x0 w0 \\<bind>\n  (\\<lambda>(r0, a0).\n      response0 r0 w0 e \\<bind>\n      (\\<lambda>z0.\n          init1 x1 w1 \\<bind>\n          (\\<lambda>(r1, a1).\n              response1 r1 w1 e \\<bind>\n              (\\<lambda>z1. return_spmf ((a0, a1), e, z0, z1)))))\n\ngoal (1 subgoal):\n 1. \\<Sigma>_AND.R (x0, x1) (w0, w1) e = \\<Sigma>_AND.S (x0, x1) e", "have \"... = do {\n    (a0, c0, z0) \\<leftarrow> \\<Sigma>0.R x0 w0 e;\n    (a1, c1, z1) \\<leftarrow> \\<Sigma>1.R x1 w1 e;\n    return_spmf ((a0,a1),e,(z0,z1))}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. init0 x0 w0 \\<bind>\n    (\\<lambda>(r0, a0).\n        response0 r0 w0 e \\<bind>\n        (\\<lambda>z0.\n            init1 x1 w1 \\<bind>\n            (\\<lambda>(r1, a1).\n                response1 r1 w1 e \\<bind>\n                (\\<lambda>z1. return_spmf ((a0, a1), e, z0, z1))))) =\n    \\<Sigma>0.R x0 w0 e \\<bind>\n    (\\<lambda>(a0, c0, z0).\n        \\<Sigma>1.R x1 w1 e \\<bind>\n        (\\<lambda>(a1, c1, z1). return_spmf ((a0, a1), e, z0, z1)))", "by(simp add: \\<Sigma>0.R_def \\<Sigma>1.R_def split_def)"], ["proof (state)\nthis:\n  init0 x0 w0 \\<bind>\n  (\\<lambda>(r0, a0).\n      response0 r0 w0 e \\<bind>\n      (\\<lambda>z0.\n          init1 x1 w1 \\<bind>\n          (\\<lambda>(r1, a1).\n              response1 r1 w1 e \\<bind>\n              (\\<lambda>z1. return_spmf ((a0, a1), e, z0, z1))))) =\n  \\<Sigma>0.R x0 w0 e \\<bind>\n  (\\<lambda>(a0, c0, z0).\n      \\<Sigma>1.R x1 w1 e \\<bind>\n      (\\<lambda>(a1, c1, z1). return_spmf ((a0, a1), e, z0, z1)))\n\ngoal (1 subgoal):\n 1. \\<Sigma>_AND.R (x0, x1) (w0, w1) e = \\<Sigma>_AND.S (x0, x1) e", "also"], ["proof (state)\nthis:\n  init0 x0 w0 \\<bind>\n  (\\<lambda>(r0, a0).\n      response0 r0 w0 e \\<bind>\n      (\\<lambda>z0.\n          init1 x1 w1 \\<bind>\n          (\\<lambda>(r1, a1).\n              response1 r1 w1 e \\<bind>\n              (\\<lambda>z1. return_spmf ((a0, a1), e, z0, z1))))) =\n  \\<Sigma>0.R x0 w0 e \\<bind>\n  (\\<lambda>(a0, c0, z0).\n      \\<Sigma>1.R x1 w1 e \\<bind>\n      (\\<lambda>(a1, c1, z1). return_spmf ((a0, a1), e, z0, z1)))\n\ngoal (1 subgoal):\n 1. \\<Sigma>_AND.R (x0, x1) (w0, w1) e = \\<Sigma>_AND.S (x0, x1) e", "have \"... = do {\n    (a0, c0, z0) \\<leftarrow> \\<Sigma>0.S x0 e;\n    (a1, c1, z1) \\<leftarrow> \\<Sigma>1.S x1 e;\n    return_spmf ((a0,a1),e,(z0,z1))}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sigma>0.R x0 w0 e \\<bind>\n    (\\<lambda>(a0, c0, z0).\n        \\<Sigma>1.R x1 w1 e \\<bind>\n        (\\<lambda>(a1, c1, z1). return_spmf ((a0, a1), e, z0, z1))) =\n    \\<Sigma>0.S x0 e \\<bind>\n    (\\<lambda>(a0, c0, z0).\n        \\<Sigma>1.S x1 e \\<bind>\n        (\\<lambda>(a1, c1, z1). return_spmf ((a0, a1), e, z0, z1)))", "using Rel_AND_def S_AND_def \\<Sigma>_prot1 \\<Sigma>_prot0 assms  \\<Sigma>0.HVZK_unfold1 \\<Sigma>1.HVZK_unfold1 \n          valid_pub_AND_def split_def challenge_space_def x_in_dom"], ["proof (prove)\nusing this:\n  Rel_AND =\n  {((x0, x1), w0, w1). (x0, w0) \\<in> Rel0 \\<and> (x1, w1) \\<in> Rel1}\n  S_AND ?X ?e =\n  (let (x0, x1) = ?X\n   in S0_raw x0 ?e \\<bind>\n      (\\<lambda>(a0, z0).\n          S1_raw x1 ?e \\<bind>\n          (\\<lambda>(a1, z1). return_spmf ((a0, a1), z0, z1))))\n  \\<Sigma>1.\\<Sigma>_protocol\n  \\<Sigma>0.\\<Sigma>_protocol\n  ((x0, x1), w0, w1) \\<in> Rel_AND\n  e \\<in> challenge_space\n  \\<Sigma>0.\\<Sigma>_protocol \\<Longrightarrow>\n  \\<forall>h w e.\n     (h, w) \\<in> Rel0 \\<longrightarrow>\n     e \\<in> carrier L \\<longrightarrow> \\<Sigma>0.R h w e = \\<Sigma>0.S h e\n  \\<Sigma>1.\\<Sigma>_protocol \\<Longrightarrow>\n  \\<forall>h w e.\n     (h, w) \\<in> Rel1 \\<longrightarrow>\n     e \\<in> carrier L \\<longrightarrow> \\<Sigma>1.R h w e = \\<Sigma>1.S h e\n  valid_pub_AND = {(x0, x1). x0 \\<in> valid_pub0 \\<and> x1 \\<in> valid_pub1}\n  case_prod = (\\<lambda>c p. c (fst p) (snd p))\n  challenge_space = carrier L\n  x0 \\<in> Domain Rel0\n\ngoal (1 subgoal):\n 1. \\<Sigma>0.R x0 w0 e \\<bind>\n    (\\<lambda>(a0, c0, z0).\n        \\<Sigma>1.R x1 w1 e \\<bind>\n        (\\<lambda>(a1, c1, z1). return_spmf ((a0, a1), e, z0, z1))) =\n    \\<Sigma>0.S x0 e \\<bind>\n    (\\<lambda>(a0, c0, z0).\n        \\<Sigma>1.S x1 e \\<bind>\n        (\\<lambda>(a1, c1, z1). return_spmf ((a0, a1), e, z0, z1)))", "by auto"], ["proof (state)\nthis:\n  \\<Sigma>0.R x0 w0 e \\<bind>\n  (\\<lambda>(a0, c0, z0).\n      \\<Sigma>1.R x1 w1 e \\<bind>\n      (\\<lambda>(a1, c1, z1). return_spmf ((a0, a1), e, z0, z1))) =\n  \\<Sigma>0.S x0 e \\<bind>\n  (\\<lambda>(a0, c0, z0).\n      \\<Sigma>1.S x1 e \\<bind>\n      (\\<lambda>(a1, c1, z1). return_spmf ((a0, a1), e, z0, z1)))\n\ngoal (1 subgoal):\n 1. \\<Sigma>_AND.R (x0, x1) (w0, w1) e = \\<Sigma>_AND.S (x0, x1) e", "ultimately"], ["proof (chain)\npicking this:\n  \\<Sigma>_AND.R (x0, x1) (w0, w1) e =\n  \\<Sigma>0.R x0 w0 e \\<bind>\n  (\\<lambda>(a0, c0, z0).\n      \\<Sigma>1.R x1 w1 e \\<bind>\n      (\\<lambda>(a1, c1, z1). return_spmf ((a0, a1), e, z0, z1)))\n  \\<Sigma>0.R x0 w0 e \\<bind>\n  (\\<lambda>(a0, c0, z0).\n      \\<Sigma>1.R x1 w1 e \\<bind>\n      (\\<lambda>(a1, c1, z1). return_spmf ((a0, a1), e, z0, z1))) =\n  \\<Sigma>0.S x0 e \\<bind>\n  (\\<lambda>(a0, c0, z0).\n      \\<Sigma>1.S x1 e \\<bind>\n      (\\<lambda>(a1, c1, z1). return_spmf ((a0, a1), e, z0, z1)))", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<Sigma>_AND.R (x0, x1) (w0, w1) e =\n  \\<Sigma>0.R x0 w0 e \\<bind>\n  (\\<lambda>(a0, c0, z0).\n      \\<Sigma>1.R x1 w1 e \\<bind>\n      (\\<lambda>(a1, c1, z1). return_spmf ((a0, a1), e, z0, z1)))\n  \\<Sigma>0.R x0 w0 e \\<bind>\n  (\\<lambda>(a0, c0, z0).\n      \\<Sigma>1.R x1 w1 e \\<bind>\n      (\\<lambda>(a1, c1, z1). return_spmf ((a0, a1), e, z0, z1))) =\n  \\<Sigma>0.S x0 e \\<bind>\n  (\\<lambda>(a0, c0, z0).\n      \\<Sigma>1.S x1 e \\<bind>\n      (\\<lambda>(a1, c1, z1). return_spmf ((a0, a1), e, z0, z1)))\n\ngoal (1 subgoal):\n 1. \\<Sigma>_AND.R (x0, x1) (w0, w1) e = \\<Sigma>_AND.S (x0, x1) e", "by(simp add: \\<Sigma>0.S_def \\<Sigma>1.S_def bind_map_spmf o_def split_def Let_def \\<Sigma>_AND.S_def map_spmf_conv_bind_spmf S_AND_def)"], ["proof (state)\nthis:\n  \\<Sigma>_AND.R (x0, x1) (w0, w1) e = \\<Sigma>_AND.S (x0, x1) e\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma HVZK: \"\\<Sigma>_AND.HVZK\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sigma>_AND.HVZK", "using \\<Sigma>_AND.HVZK_def hvzk challenge_space_def"], ["proof (prove)\nusing this:\n  \\<Sigma>_AND.HVZK \\<equiv>\n  \\<forall>e\\<in>challenge_space.\n     (\\<forall>(h, w)\\<in>Rel_AND.\n         \\<Sigma>_AND.R h w e = \\<Sigma>_AND.S h e) \\<and>\n     (\\<forall>h\\<in>valid_pub_AND.\n         \\<forall>(a, z)\\<in>set_spmf (S_AND h e). check_AND h a e z)\n  \\<lbrakk>((?x0.0, ?x1.0), ?w0.0, ?w1.0) \\<in> Rel_AND;\n   ?e \\<in> challenge_space\\<rbrakk>\n  \\<Longrightarrow> \\<Sigma>_AND.R (?x0.0, ?x1.0) (?w0.0, ?w1.0) ?e =\n                    \\<Sigma>_AND.S (?x0.0, ?x1.0) ?e\n  challenge_space = carrier L\n\ngoal (1 subgoal):\n 1. \\<Sigma>_AND.HVZK", "apply(simp add: S_AND_def split_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<Sigma>_protocols_base.HVZK init_AND response_AND check_AND\n              Rel_AND S_AND (carrier L) valid_pub_AND \\<equiv>\n             \\<forall>e\\<in>carrier L.\n                (\\<forall>x\\<in>Rel_AND.\n                    \\<Sigma>_AND.R (fst x) (snd x) e =\n                    \\<Sigma>_AND.S (fst x) e) \\<and>\n                (\\<forall>h\\<in>valid_pub_AND.\n                    \\<forall>x\\<in>set_spmf (S0_raw (fst h) e) \\<bind>\n                                   set_spmf \\<circ>\n                                   (\\<lambda>p.\n S1_raw (snd h) e \\<bind>\n (\\<lambda>pa. return_spmf ((fst p, fst pa), snd p, snd pa))).\n                       check_AND h (fst x) e (snd x));\n     \\<And>x0 x1 w0 w1 e.\n        \\<lbrakk>((x0, x1), w0, w1) \\<in> Rel_AND;\n         e \\<in> carrier L\\<rbrakk>\n        \\<Longrightarrow> \\<Sigma>_AND.R (x0, x1) (w0, w1) e =\n                          \\<Sigma>_AND.S (x0, x1) e;\n     challenge_space = carrier L\\<rbrakk>\n    \\<Longrightarrow> \\<forall>e\\<in>carrier L.\n                         (\\<forall>x\\<in>Rel_AND.\n                             \\<Sigma>_AND.R (fst x) (snd x) e =\n                             \\<Sigma>_AND.S (fst x) e) \\<and>\n                         (\\<forall>h\\<in>valid_pub_AND.\n                             \\<forall>x\n\\<in>set_spmf (S0_raw (fst h) e) \\<bind>\n     set_spmf \\<circ>\n     (\\<lambda>p.\n         S1_raw (snd h) e \\<bind>\n         (\\<lambda>pa. return_spmf ((fst p, fst pa), snd p, snd pa))).\n                                check_AND h (fst x) e (snd x))", "using \\<Sigma>_prot1 \\<Sigma>_prot0 \\<Sigma>0.HVZK_unfold2 \\<Sigma>1.HVZK_unfold2 valid_pub_AND_def"], ["proof (prove)\nusing this:\n  \\<Sigma>1.\\<Sigma>_protocol\n  \\<Sigma>0.\\<Sigma>_protocol\n  \\<Sigma>0.\\<Sigma>_protocol \\<Longrightarrow>\n  \\<forall>h e out.\n     e \\<in> carrier L \\<longrightarrow>\n     h \\<in> valid_pub0 \\<longrightarrow>\n     out \\<in> set_spmf (S0_raw h e) \\<longrightarrow>\n     check0 h (fst out) e (snd out)\n  \\<Sigma>1.\\<Sigma>_protocol \\<Longrightarrow>\n  \\<forall>h e out.\n     e \\<in> carrier L \\<longrightarrow>\n     h \\<in> valid_pub1 \\<longrightarrow>\n     out \\<in> set_spmf (S1_raw h e) \\<longrightarrow>\n     check1 h (fst out) e (snd out)\n  valid_pub_AND = {(x0, x1). x0 \\<in> valid_pub0 \\<and> x1 \\<in> valid_pub1}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<Sigma>_protocols_base.HVZK init_AND response_AND check_AND\n              Rel_AND S_AND (carrier L) valid_pub_AND \\<equiv>\n             \\<forall>e\\<in>carrier L.\n                (\\<forall>x\\<in>Rel_AND.\n                    \\<Sigma>_AND.R (fst x) (snd x) e =\n                    \\<Sigma>_AND.S (fst x) e) \\<and>\n                (\\<forall>h\\<in>valid_pub_AND.\n                    \\<forall>x\\<in>set_spmf (S0_raw (fst h) e) \\<bind>\n                                   set_spmf \\<circ>\n                                   (\\<lambda>p.\n S1_raw (snd h) e \\<bind>\n (\\<lambda>pa. return_spmf ((fst p, fst pa), snd p, snd pa))).\n                       check_AND h (fst x) e (snd x));\n     \\<And>x0 x1 w0 w1 e.\n        \\<lbrakk>((x0, x1), w0, w1) \\<in> Rel_AND;\n         e \\<in> carrier L\\<rbrakk>\n        \\<Longrightarrow> \\<Sigma>_AND.R (x0, x1) (w0, w1) e =\n                          \\<Sigma>_AND.S (x0, x1) e;\n     challenge_space = carrier L\\<rbrakk>\n    \\<Longrightarrow> \\<forall>e\\<in>carrier L.\n                         (\\<forall>x\\<in>Rel_AND.\n                             \\<Sigma>_AND.R (fst x) (snd x) e =\n                             \\<Sigma>_AND.S (fst x) e) \\<and>\n                         (\\<forall>h\\<in>valid_pub_AND.\n                             \\<forall>x\n\\<in>set_spmf (S0_raw (fst h) e) \\<bind>\n     set_spmf \\<circ>\n     (\\<lambda>p.\n         S1_raw (snd h) e \\<bind>\n         (\\<lambda>pa. return_spmf ((fst p, fst pa), snd p, snd pa))).\n                                check_AND h (fst x) e (snd x))", "by auto"], ["", "lemma correct: \n  assumes Rel_AND: \"((x0,x1), (w0,w1)) \\<in> Rel_AND\"\n  and \"e \\<in> challenge_space\" \n  shows \"\\<Sigma>_AND.completeness_game (x0,x1) (w0,w1) e = return_spmf True\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sigma>_AND.completeness_game (x0, x1) (w0, w1) e = return_spmf True", "including monad_normalisation"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sigma>_AND.completeness_game (x0, x1) (w0, w1) e = return_spmf True", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Sigma>_AND.completeness_game (x0, x1) (w0, w1) e = return_spmf True", "have \"\\<Sigma>_AND.completeness_game (x0,x1) (w0,w1) e = do {\n    ((r0,r1),(a0,a1)) \\<leftarrow> init_AND (x0,x1) (w0,w1);\n    (z0,z1) \\<leftarrow> response_AND (r0,r1) (w0,w1) e;\n    return_spmf (check_AND (x0,x1) (a0,a1) e (z0,z1))}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sigma>_AND.completeness_game (x0, x1) (w0, w1) e =\n    init_AND (x0, x1) (w0, w1) \\<bind>\n    (\\<lambda>((r0, r1), a0, a1).\n        response_AND (r0, r1) (w0, w1) e \\<bind>\n        (\\<lambda>(z0, z1).\n            return_spmf (check_AND (x0, x1) (a0, a1) e (z0, z1))))", "by(simp add: \\<Sigma>_AND.completeness_game_def split_def del: check_AND.simps)"], ["proof (state)\nthis:\n  \\<Sigma>_AND.completeness_game (x0, x1) (w0, w1) e =\n  init_AND (x0, x1) (w0, w1) \\<bind>\n  (\\<lambda>((r0, r1), a0, a1).\n      response_AND (r0, r1) (w0, w1) e \\<bind>\n      (\\<lambda>(z0, z1).\n          return_spmf (check_AND (x0, x1) (a0, a1) e (z0, z1))))\n\ngoal (1 subgoal):\n 1. \\<Sigma>_AND.completeness_game (x0, x1) (w0, w1) e = return_spmf True", "also"], ["proof (state)\nthis:\n  \\<Sigma>_AND.completeness_game (x0, x1) (w0, w1) e =\n  init_AND (x0, x1) (w0, w1) \\<bind>\n  (\\<lambda>((r0, r1), a0, a1).\n      response_AND (r0, r1) (w0, w1) e \\<bind>\n      (\\<lambda>(z0, z1).\n          return_spmf (check_AND (x0, x1) (a0, a1) e (z0, z1))))\n\ngoal (1 subgoal):\n 1. \\<Sigma>_AND.completeness_game (x0, x1) (w0, w1) e = return_spmf True", "have \"... = do {\n    (r0, a0) \\<leftarrow> init0 x0 w0;\n    z0 \\<leftarrow> response0 r0 w0 e;\n    (r1, a1) \\<leftarrow> init1 x1 w1;\n    z1 \\<leftarrow> response1 r1 w1 e;\n    return_spmf ((check0 x0 a0 e z0 \\<and> check1 x1 a1 e z1))}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. init_AND (x0, x1) (w0, w1) \\<bind>\n    (\\<lambda>((r0, r1), a0, a1).\n        response_AND (r0, r1) (w0, w1) e \\<bind>\n        (\\<lambda>(z0, z1).\n            return_spmf (check_AND (x0, x1) (a0, a1) e (z0, z1)))) =\n    init0 x0 w0 \\<bind>\n    (\\<lambda>(r0, a0).\n        response0 r0 w0 e \\<bind>\n        (\\<lambda>z0.\n            init1 x1 w1 \\<bind>\n            (\\<lambda>(r1, a1).\n                response1 r1 w1 e \\<bind>\n                (\\<lambda>z1.\n                    return_spmf\n                     (check0 x0 a0 e z0 \\<and> check1 x1 a1 e z1)))))", "apply(simp add: init_AND_def response_AND_def split_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. init1 x1 w1 \\<bind>\n    (\\<lambda>y.\n        response1 (fst y) w1 e \\<bind>\n        (\\<lambda>ya.\n            init0 x0 w0 \\<bind>\n            (\\<lambda>yb.\n                response0 (fst yb) w0 e \\<bind>\n                (\\<lambda>yc.\n                    return_spmf\n                     (check0 x0 (snd yb) e yc \\<and>\n                      check1 x1 (snd y) e ya))))) =\n    init0 x0 w0 \\<bind>\n    (\\<lambda>p.\n        response0 (fst p) w0 e \\<bind>\n        (\\<lambda>z0.\n            init1 x1 w1 \\<bind>\n            (\\<lambda>pa.\n                response1 (fst pa) w1 e \\<bind>\n                (\\<lambda>z1.\n                    return_spmf\n                     (check0 x0 (snd p) e z0 \\<and>\n                      check1 x1 (snd pa) e z1)))))", "apply(rewrite bind_commute_spmf[of \"response0 _ w0 e\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. init1 x1 w1 \\<bind>\n    (\\<lambda>y.\n        response1 (fst y) w1 e \\<bind>\n        (\\<lambda>ya.\n            init0 x0 w0 \\<bind>\n            (\\<lambda>yb.\n                response0 (fst yb) w0 e \\<bind>\n                (\\<lambda>yc.\n                    return_spmf\n                     (check0 x0 (snd yb) e yc \\<and>\n                      check1 x1 (snd y) e ya))))) =\n    init0 x0 w0 \\<bind>\n    (\\<lambda>p.\n        init1 x1 w1 \\<bind>\n        (\\<lambda>y.\n            response0 (fst p) w0 e \\<bind>\n            (\\<lambda>z0.\n                response1 (fst y) w1 e \\<bind>\n                (\\<lambda>z1.\n                    return_spmf\n                     (check0 x0 (snd p) e z0 \\<and>\n                      check1 x1 (snd y) e z1)))))", "by simp"], ["proof (state)\nthis:\n  init_AND (x0, x1) (w0, w1) \\<bind>\n  (\\<lambda>((r0, r1), a0, a1).\n      response_AND (r0, r1) (w0, w1) e \\<bind>\n      (\\<lambda>(z0, z1).\n          return_spmf (check_AND (x0, x1) (a0, a1) e (z0, z1)))) =\n  init0 x0 w0 \\<bind>\n  (\\<lambda>(r0, a0).\n      response0 r0 w0 e \\<bind>\n      (\\<lambda>z0.\n          init1 x1 w1 \\<bind>\n          (\\<lambda>(r1, a1).\n              response1 r1 w1 e \\<bind>\n              (\\<lambda>z1.\n                  return_spmf\n                   (check0 x0 a0 e z0 \\<and> check1 x1 a1 e z1)))))\n\ngoal (1 subgoal):\n 1. \\<Sigma>_AND.completeness_game (x0, x1) (w0, w1) e = return_spmf True", "ultimately"], ["proof (chain)\npicking this:\n  \\<Sigma>_AND.completeness_game (x0, x1) (w0, w1) e =\n  init_AND (x0, x1) (w0, w1) \\<bind>\n  (\\<lambda>((r0, r1), a0, a1).\n      response_AND (r0, r1) (w0, w1) e \\<bind>\n      (\\<lambda>(z0, z1).\n          return_spmf (check_AND (x0, x1) (a0, a1) e (z0, z1))))\n  init_AND (x0, x1) (w0, w1) \\<bind>\n  (\\<lambda>((r0, r1), a0, a1).\n      response_AND (r0, r1) (w0, w1) e \\<bind>\n      (\\<lambda>(z0, z1).\n          return_spmf (check_AND (x0, x1) (a0, a1) e (z0, z1)))) =\n  init0 x0 w0 \\<bind>\n  (\\<lambda>(r0, a0).\n      response0 r0 w0 e \\<bind>\n      (\\<lambda>z0.\n          init1 x1 w1 \\<bind>\n          (\\<lambda>(r1, a1).\n              response1 r1 w1 e \\<bind>\n              (\\<lambda>z1.\n                  return_spmf\n                   (check0 x0 a0 e z0 \\<and> check1 x1 a1 e z1)))))", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<Sigma>_AND.completeness_game (x0, x1) (w0, w1) e =\n  init_AND (x0, x1) (w0, w1) \\<bind>\n  (\\<lambda>((r0, r1), a0, a1).\n      response_AND (r0, r1) (w0, w1) e \\<bind>\n      (\\<lambda>(z0, z1).\n          return_spmf (check_AND (x0, x1) (a0, a1) e (z0, z1))))\n  init_AND (x0, x1) (w0, w1) \\<bind>\n  (\\<lambda>((r0, r1), a0, a1).\n      response_AND (r0, r1) (w0, w1) e \\<bind>\n      (\\<lambda>(z0, z1).\n          return_spmf (check_AND (x0, x1) (a0, a1) e (z0, z1)))) =\n  init0 x0 w0 \\<bind>\n  (\\<lambda>(r0, a0).\n      response0 r0 w0 e \\<bind>\n      (\\<lambda>z0.\n          init1 x1 w1 \\<bind>\n          (\\<lambda>(r1, a1).\n              response1 r1 w1 e \\<bind>\n              (\\<lambda>z1.\n                  return_spmf\n                   (check0 x0 a0 e z0 \\<and> check1 x1 a1 e z1)))))\n\ngoal (1 subgoal):\n 1. \\<Sigma>_AND.completeness_game (x0, x1) (w0, w1) e = return_spmf True", "using \\<Sigma>1.complete_game_return_true \\<Sigma>_prot1 \\<Sigma>1.\\<Sigma>_protocol_def \\<Sigma>1.completeness_game_def assms\n          \\<Sigma>0.complete_game_return_true \\<Sigma>_prot0 \\<Sigma>0.\\<Sigma>_protocol_def \\<Sigma>0.completeness_game_def challenge_space_def"], ["proof (prove)\nusing this:\n  \\<Sigma>_AND.completeness_game (x0, x1) (w0, w1) e =\n  init_AND (x0, x1) (w0, w1) \\<bind>\n  (\\<lambda>((r0, r1), a0, a1).\n      response_AND (r0, r1) (w0, w1) e \\<bind>\n      (\\<lambda>(z0, z1).\n          return_spmf (check_AND (x0, x1) (a0, a1) e (z0, z1))))\n  init_AND (x0, x1) (w0, w1) \\<bind>\n  (\\<lambda>((r0, r1), a0, a1).\n      response_AND (r0, r1) (w0, w1) e \\<bind>\n      (\\<lambda>(z0, z1).\n          return_spmf (check_AND (x0, x1) (a0, a1) e (z0, z1)))) =\n  init0 x0 w0 \\<bind>\n  (\\<lambda>(r0, a0).\n      response0 r0 w0 e \\<bind>\n      (\\<lambda>z0.\n          init1 x1 w1 \\<bind>\n          (\\<lambda>(r1, a1).\n              response1 r1 w1 e \\<bind>\n              (\\<lambda>z1.\n                  return_spmf\n                   (check0 x0 a0 e z0 \\<and> check1 x1 a1 e z1)))))\n  \\<lbrakk>(?h, ?w) \\<in> Rel1; \\<Sigma>1.completeness;\n   \\<forall>h w. lossless_spmf (init1 h w);\n   \\<forall>r w e. lossless_spmf (response1 r w e);\n   ?e \\<in> carrier L\\<rbrakk>\n  \\<Longrightarrow> \\<Sigma>1.completeness_game ?h ?w ?e = return_spmf True\n  \\<Sigma>1.\\<Sigma>_protocol\n  \\<Sigma>1.\\<Sigma>_protocol \\<equiv>\n  \\<Sigma>1.completeness \\<and>\n  \\<Sigma>1.special_soundness \\<and> \\<Sigma>1.HVZK\n  \\<Sigma>1.completeness_game ?h ?w ?e =\n  init1 ?h ?w \\<bind>\n  (\\<lambda>(r, a).\n      response1 r ?w ?e \\<bind>\n      (\\<lambda>z. return_spmf (check1 ?h a ?e z)))\n  ((x0, x1), w0, w1) \\<in> Rel_AND\n  e \\<in> challenge_space\n  \\<lbrakk>(?h, ?w) \\<in> Rel0; \\<Sigma>0.completeness;\n   \\<forall>h w. lossless_spmf (init0 h w);\n   \\<forall>r w e. lossless_spmf (response0 r w e);\n   ?e \\<in> carrier L\\<rbrakk>\n  \\<Longrightarrow> \\<Sigma>0.completeness_game ?h ?w ?e = return_spmf True\n  \\<Sigma>0.\\<Sigma>_protocol\n  \\<Sigma>0.\\<Sigma>_protocol \\<equiv>\n  \\<Sigma>0.completeness \\<and>\n  \\<Sigma>0.special_soundness \\<and> \\<Sigma>0.HVZK\n  \\<Sigma>0.completeness_game ?h ?w ?e =\n  init0 ?h ?w \\<bind>\n  (\\<lambda>(r, a).\n      response0 r ?w ?e \\<bind>\n      (\\<lambda>z. return_spmf (check0 ?h a ?e z)))\n  challenge_space = carrier L\n\ngoal (1 subgoal):\n 1. \\<Sigma>_AND.completeness_game (x0, x1) (w0, w1) e = return_spmf True", "apply(auto simp add: Let_def split_def bind_eq_return_spmf lossless_init lossless_response Rel_AND_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b y aa ba ya.\n       \\<lbrakk>\\<Sigma>_AND.completeness_game (x0, x1) (w0, w1) e =\n                init0 x0 w0 \\<bind>\n                (\\<lambda>p.\n                    response0 (fst p) w0 e \\<bind>\n                    (\\<lambda>z0.\n                        init1 x1 w1 \\<bind>\n                        (\\<lambda>pa.\n                            response1 (fst pa) w1 e \\<bind>\n                            (\\<lambda>z1.\n                                return_spmf\n                                 (check0 x0 (snd p) e z0 \\<and>\n                                  check1 x1 (snd pa) e z1)))));\n        init_AND (x0, x1) (w0, w1) \\<bind>\n        (\\<lambda>p.\n            response_AND (fst p) (w0, w1) e \\<bind>\n            (\\<lambda>pa.\n                return_spmf\n                 (check0 x0 (fst (snd p)) e (fst pa) \\<and>\n                  check1 x1 (snd (snd p)) e (snd pa)))) =\n        init0 x0 w0 \\<bind>\n        (\\<lambda>p.\n            response0 (fst p) w0 e \\<bind>\n            (\\<lambda>z0.\n                init1 x1 w1 \\<bind>\n                (\\<lambda>pa.\n                    response1 (fst pa) w1 e \\<bind>\n                    (\\<lambda>z1.\n                        return_spmf\n                         (check0 x0 (snd p) e z0 \\<and>\n                          check1 x1 (snd pa) e z1)))));\n        \\<And>h w e.\n           \\<lbrakk>(h, w) \\<in> Rel1; e \\<in> carrier L\\<rbrakk>\n           \\<Longrightarrow> \\<forall>y\\<in>set_spmf (init1 h w).\n                                \\<forall>x\n   \\<in>set_spmf (response1 (fst y) w e).\n                                   check1 h (snd y) e x;\n        \\<Sigma>1.\\<Sigma>_protocol \\<equiv> True;\n        \\<And>h w e.\n           \\<Sigma>1.completeness_game h w e =\n           init1 h w \\<bind>\n           (\\<lambda>p.\n               response1 (fst p) w e \\<bind>\n               (\\<lambda>z. return_spmf (check1 h (snd p) e z)));\n        e \\<in> carrier L;\n        \\<And>h w e.\n           \\<lbrakk>(h, w) \\<in> Rel0; e \\<in> carrier L\\<rbrakk>\n           \\<Longrightarrow> \\<forall>y\\<in>set_spmf (init0 h w).\n                                \\<forall>x\n   \\<in>set_spmf (response0 (fst y) w e).\n                                   check0 h (snd y) e x;\n        \\<Sigma>0.\\<Sigma>_protocol \\<equiv> True;\n        \\<And>h w e.\n           \\<Sigma>0.completeness_game h w e =\n           init0 h w \\<bind>\n           (\\<lambda>p.\n               response0 (fst p) w e \\<bind>\n               (\\<lambda>z. return_spmf (check0 h (snd p) e z)));\n        challenge_space = carrier L; (a, b) \\<in> set_spmf (init0 x0 w0);\n        y \\<in> set_spmf (response0 a w0 e);\n        (aa, ba) \\<in> set_spmf (init1 x1 w1);\n        ya \\<in> set_spmf (response1 aa w1 e); \\<Sigma>1.completeness;\n        (x0, w0) \\<in> Rel0; (x1, w1) \\<in> Rel1; \\<Sigma>0.completeness;\n        \\<Sigma>1.special_soundness; \\<Sigma>1.HVZK;\n        \\<Sigma>0.special_soundness; \\<Sigma>0.HVZK\\<rbrakk>\n       \\<Longrightarrow> check0 x0 b e y\n 2. \\<And>a b y aa ba ya.\n       \\<lbrakk>\\<Sigma>_AND.completeness_game (x0, x1) (w0, w1) e =\n                init0 x0 w0 \\<bind>\n                (\\<lambda>p.\n                    response0 (fst p) w0 e \\<bind>\n                    (\\<lambda>z0.\n                        init1 x1 w1 \\<bind>\n                        (\\<lambda>pa.\n                            response1 (fst pa) w1 e \\<bind>\n                            (\\<lambda>z1.\n                                return_spmf\n                                 (check0 x0 (snd p) e z0 \\<and>\n                                  check1 x1 (snd pa) e z1)))));\n        init_AND (x0, x1) (w0, w1) \\<bind>\n        (\\<lambda>p.\n            response_AND (fst p) (w0, w1) e \\<bind>\n            (\\<lambda>pa.\n                return_spmf\n                 (check0 x0 (fst (snd p)) e (fst pa) \\<and>\n                  check1 x1 (snd (snd p)) e (snd pa)))) =\n        init0 x0 w0 \\<bind>\n        (\\<lambda>p.\n            response0 (fst p) w0 e \\<bind>\n            (\\<lambda>z0.\n                init1 x1 w1 \\<bind>\n                (\\<lambda>pa.\n                    response1 (fst pa) w1 e \\<bind>\n                    (\\<lambda>z1.\n                        return_spmf\n                         (check0 x0 (snd p) e z0 \\<and>\n                          check1 x1 (snd pa) e z1)))));\n        \\<And>h w e.\n           \\<lbrakk>(h, w) \\<in> Rel1; e \\<in> carrier L\\<rbrakk>\n           \\<Longrightarrow> \\<forall>y\\<in>set_spmf (init1 h w).\n                                \\<forall>x\n   \\<in>set_spmf (response1 (fst y) w e).\n                                   check1 h (snd y) e x;\n        \\<Sigma>1.\\<Sigma>_protocol \\<equiv> True;\n        \\<And>h w e.\n           \\<Sigma>1.completeness_game h w e =\n           init1 h w \\<bind>\n           (\\<lambda>p.\n               response1 (fst p) w e \\<bind>\n               (\\<lambda>z. return_spmf (check1 h (snd p) e z)));\n        e \\<in> carrier L;\n        \\<And>h w e.\n           \\<lbrakk>(h, w) \\<in> Rel0; e \\<in> carrier L\\<rbrakk>\n           \\<Longrightarrow> \\<forall>y\\<in>set_spmf (init0 h w).\n                                \\<forall>x\n   \\<in>set_spmf (response0 (fst y) w e).\n                                   check0 h (snd y) e x;\n        \\<Sigma>0.\\<Sigma>_protocol \\<equiv> True;\n        \\<And>h w e.\n           \\<Sigma>0.completeness_game h w e =\n           init0 h w \\<bind>\n           (\\<lambda>p.\n               response0 (fst p) w e \\<bind>\n               (\\<lambda>z. return_spmf (check0 h (snd p) e z)));\n        challenge_space = carrier L; (a, b) \\<in> set_spmf (init0 x0 w0);\n        y \\<in> set_spmf (response0 a w0 e);\n        (aa, ba) \\<in> set_spmf (init1 x1 w1);\n        ya \\<in> set_spmf (response1 aa w1 e); \\<Sigma>1.completeness;\n        (x0, w0) \\<in> Rel0; (x1, w1) \\<in> Rel1; \\<Sigma>0.completeness;\n        \\<Sigma>1.special_soundness; \\<Sigma>1.HVZK;\n        \\<Sigma>0.special_soundness; \\<Sigma>0.HVZK\\<rbrakk>\n       \\<Longrightarrow> check1 x1 ba e ya", "by(metis (mono_tags, lifting) assms(2) fst_conv snd_conv)+"], ["proof (state)\nthis:\n  \\<Sigma>_AND.completeness_game (x0, x1) (w0, w1) e = return_spmf True\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma completeness: \"\\<Sigma>_AND.completeness\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sigma>_AND.completeness", "using \\<Sigma>_AND.completeness_def correct challenge_space_def"], ["proof (prove)\nusing this:\n  \\<Sigma>_AND.completeness \\<equiv>\n  \\<forall>h w e.\n     (h, w) \\<in> Rel_AND \\<longrightarrow>\n     e \\<in> challenge_space \\<longrightarrow>\n     spmf (\\<Sigma>_AND.completeness_game h w e) True = 1\n  \\<lbrakk>((?x0.0, ?x1.0), ?w0.0, ?w1.0) \\<in> Rel_AND;\n   ?e \\<in> challenge_space\\<rbrakk>\n  \\<Longrightarrow> \\<Sigma>_AND.completeness_game (?x0.0, ?x1.0)\n                     (?w0.0, ?w1.0) ?e =\n                    return_spmf True\n  challenge_space = carrier L\n\ngoal (1 subgoal):\n 1. \\<Sigma>_AND.completeness", "by force"], ["", "lemma ss:\n  assumes e_neq_e': \"s \\<noteq> s'\"\n    and valid_pub: \"(x0,x1) \\<in> valid_pub_AND\"\n    and challenge_space: \"s \\<in> challenge_space\" \"s' \\<in> challenge_space\"\n    and \"check_AND (x0,x1) (a0,a1) s (z0,z1)\" \n    and \"check_AND  (x0,x1) (a0,a1) s' (z0',z1')\" \n  shows  \"lossless_spmf (\\<A>ss_AND  (x0,x1) ((a0,a1), s, (z0,z1)) ((a0,a1), s', (z0',z1'))) \n              \\<and> (\\<forall>w'\\<in>set_spmf (\\<A>ss_AND  (x0,x1) ((a0,a1), s, (z0,z1)) ((a0,a1), s', (z0',z1'))). ((x0,x1), w') \\<in> Rel_AND)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lossless_spmf\n     (\\<A>ss_AND (x0, x1) ((a0, a1), s, z0, z1)\n       ((a0, a1), s', z0', z1')) \\<and>\n    (\\<forall>w'\\<in>set_spmf\n                      (\\<A>ss_AND (x0, x1) ((a0, a1), s, z0, z1)\n                        ((a0, a1), s', z0', z1')).\n        ((x0, x1), w') \\<in> Rel_AND)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. lossless_spmf\n     (\\<A>ss_AND (x0, x1) ((a0, a1), s, z0, z1)\n       ((a0, a1), s', z0', z1')) \\<and>\n    (\\<forall>w'\\<in>set_spmf\n                      (\\<A>ss_AND (x0, x1) ((a0, a1), s, z0, z1)\n                        ((a0, a1), s', z0', z1')).\n        ((x0, x1), w') \\<in> Rel_AND)", "have x0_in_dom: \"x0 \\<in> valid_pub0\" and x1_in_dom: \"x1 \\<in> valid_pub1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x0 \\<in> valid_pub0 &&& x1 \\<in> valid_pub1", "using valid_pub valid_pub_AND_def"], ["proof (prove)\nusing this:\n  (x0, x1) \\<in> valid_pub_AND\n  valid_pub_AND = {(x0, x1). x0 \\<in> valid_pub0 \\<and> x1 \\<in> valid_pub1}\n\ngoal (1 subgoal):\n 1. x0 \\<in> valid_pub0 &&& x1 \\<in> valid_pub1", "by auto"], ["proof (state)\nthis:\n  x0 \\<in> valid_pub0\n  x1 \\<in> valid_pub1\n\ngoal (1 subgoal):\n 1. lossless_spmf\n     (\\<A>ss_AND (x0, x1) ((a0, a1), s, z0, z1)\n       ((a0, a1), s', z0', z1')) \\<and>\n    (\\<forall>w'\\<in>set_spmf\n                      (\\<A>ss_AND (x0, x1) ((a0, a1), s, z0, z1)\n                        ((a0, a1), s', z0', z1')).\n        ((x0, x1), w') \\<in> Rel_AND)", "moreover"], ["proof (state)\nthis:\n  x0 \\<in> valid_pub0\n  x1 \\<in> valid_pub1\n\ngoal (1 subgoal):\n 1. lossless_spmf\n     (\\<A>ss_AND (x0, x1) ((a0, a1), s, z0, z1)\n       ((a0, a1), s', z0', z1')) \\<and>\n    (\\<forall>w'\\<in>set_spmf\n                      (\\<A>ss_AND (x0, x1) ((a0, a1), s, z0, z1)\n                        ((a0, a1), s', z0', z1')).\n        ((x0, x1), w') \\<in> Rel_AND)", "have 3: \"check0 x0 a0 s z0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. check0 x0 a0 s z0", "using assms"], ["proof (prove)\nusing this:\n  s \\<noteq> s'\n  (x0, x1) \\<in> valid_pub_AND\n  s \\<in> challenge_space\n  s' \\<in> challenge_space\n  check_AND (x0, x1) (a0, a1) s (z0, z1)\n  check_AND (x0, x1) (a0, a1) s' (z0', z1')\n\ngoal (1 subgoal):\n 1. check0 x0 a0 s z0", "by simp"], ["proof (state)\nthis:\n  check0 x0 a0 s z0\n\ngoal (1 subgoal):\n 1. lossless_spmf\n     (\\<A>ss_AND (x0, x1) ((a0, a1), s, z0, z1)\n       ((a0, a1), s', z0', z1')) \\<and>\n    (\\<forall>w'\\<in>set_spmf\n                      (\\<A>ss_AND (x0, x1) ((a0, a1), s, z0, z1)\n                        ((a0, a1), s', z0', z1')).\n        ((x0, x1), w') \\<in> Rel_AND)", "moreover"], ["proof (state)\nthis:\n  check0 x0 a0 s z0\n\ngoal (1 subgoal):\n 1. lossless_spmf\n     (\\<A>ss_AND (x0, x1) ((a0, a1), s, z0, z1)\n       ((a0, a1), s', z0', z1')) \\<and>\n    (\\<forall>w'\\<in>set_spmf\n                      (\\<A>ss_AND (x0, x1) ((a0, a1), s, z0, z1)\n                        ((a0, a1), s', z0', z1')).\n        ((x0, x1), w') \\<in> Rel_AND)", "have 4: \"check1 x1 a1 s' z1'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. check1 x1 a1 s' z1'", "using assms"], ["proof (prove)\nusing this:\n  s \\<noteq> s'\n  (x0, x1) \\<in> valid_pub_AND\n  s \\<in> challenge_space\n  s' \\<in> challenge_space\n  check_AND (x0, x1) (a0, a1) s (z0, z1)\n  check_AND (x0, x1) (a0, a1) s' (z0', z1')\n\ngoal (1 subgoal):\n 1. check1 x1 a1 s' z1'", "by simp"], ["proof (state)\nthis:\n  check1 x1 a1 s' z1'\n\ngoal (1 subgoal):\n 1. lossless_spmf\n     (\\<A>ss_AND (x0, x1) ((a0, a1), s, z0, z1)\n       ((a0, a1), s', z0', z1')) \\<and>\n    (\\<forall>w'\\<in>set_spmf\n                      (\\<A>ss_AND (x0, x1) ((a0, a1), s, z0, z1)\n                        ((a0, a1), s', z0', z1')).\n        ((x0, x1), w') \\<in> Rel_AND)", "moreover"], ["proof (state)\nthis:\n  check1 x1 a1 s' z1'\n\ngoal (1 subgoal):\n 1. lossless_spmf\n     (\\<A>ss_AND (x0, x1) ((a0, a1), s, z0, z1)\n       ((a0, a1), s', z0', z1')) \\<and>\n    (\\<forall>w'\\<in>set_spmf\n                      (\\<A>ss_AND (x0, x1) ((a0, a1), s, z0, z1)\n                        ((a0, a1), s', z0', z1')).\n        ((x0, x1), w') \\<in> Rel_AND)", "have \"w0 \\<in> set_spmf (\\<A>ss0 x0 (a0, s, z0) (a0, s', z0')) \\<longrightarrow> (x0,w0) \\<in> Rel0\" for w0"], ["proof (prove)\ngoal (1 subgoal):\n 1. w0 \\<in> set_spmf\n              (\\<A>ss0 x0 (a0, s, z0) (a0, s', z0')) \\<longrightarrow>\n    (x0, w0) \\<in> Rel0", "using 3 4 \\<Sigma>0.special_soundness_def \\<Sigma>_prot0 \\<Sigma>0.\\<Sigma>_protocol_def x0_in_dom challenge_space_def assms valid_pub_AND_def valid_pub"], ["proof (prove)\nusing this:\n  check0 x0 a0 s z0\n  check1 x1 a1 s' z1'\n  \\<Sigma>0.special_soundness \\<equiv>\n  \\<forall>h e e' a z z'.\n     h \\<in> valid_pub0 \\<longrightarrow>\n     e \\<in> carrier L \\<longrightarrow>\n     e' \\<in> carrier L \\<longrightarrow>\n     e \\<noteq> e' \\<longrightarrow>\n     check0 h a e z \\<longrightarrow>\n     check0 h a e' z' \\<longrightarrow>\n     lossless_spmf (\\<A>ss0 h (a, e, z) (a, e', z')) \\<and>\n     (\\<forall>w'\\<in>set_spmf (\\<A>ss0 h (a, e, z) (a, e', z')).\n         (h, w') \\<in> Rel0)\n  \\<Sigma>0.\\<Sigma>_protocol\n  \\<Sigma>0.\\<Sigma>_protocol \\<equiv>\n  \\<Sigma>0.completeness \\<and>\n  \\<Sigma>0.special_soundness \\<and> \\<Sigma>0.HVZK\n  x0 \\<in> valid_pub0\n  challenge_space = carrier L\n  s \\<noteq> s'\n  (x0, x1) \\<in> valid_pub_AND\n  s \\<in> challenge_space\n  s' \\<in> challenge_space\n  check_AND (x0, x1) (a0, a1) s (z0, z1)\n  check_AND (x0, x1) (a0, a1) s' (z0', z1')\n  valid_pub_AND = {(x0, x1). x0 \\<in> valid_pub0 \\<and> x1 \\<in> valid_pub1}\n  (x0, x1) \\<in> valid_pub_AND\n\ngoal (1 subgoal):\n 1. w0 \\<in> set_spmf\n              (\\<A>ss0 x0 (a0, s, z0) (a0, s', z0')) \\<longrightarrow>\n    (x0, w0) \\<in> Rel0", "by fastforce"], ["proof (state)\nthis:\n  ?w0.0\n  \\<in> set_spmf (\\<A>ss0 x0 (a0, s, z0) (a0, s', z0')) \\<longrightarrow>\n  (x0, ?w0.0) \\<in> Rel0\n\ngoal (1 subgoal):\n 1. lossless_spmf\n     (\\<A>ss_AND (x0, x1) ((a0, a1), s, z0, z1)\n       ((a0, a1), s', z0', z1')) \\<and>\n    (\\<forall>w'\\<in>set_spmf\n                      (\\<A>ss_AND (x0, x1) ((a0, a1), s, z0, z1)\n                        ((a0, a1), s', z0', z1')).\n        ((x0, x1), w') \\<in> Rel_AND)", "moreover"], ["proof (state)\nthis:\n  ?w0.0\n  \\<in> set_spmf (\\<A>ss0 x0 (a0, s, z0) (a0, s', z0')) \\<longrightarrow>\n  (x0, ?w0.0) \\<in> Rel0\n\ngoal (1 subgoal):\n 1. lossless_spmf\n     (\\<A>ss_AND (x0, x1) ((a0, a1), s, z0, z1)\n       ((a0, a1), s', z0', z1')) \\<and>\n    (\\<forall>w'\\<in>set_spmf\n                      (\\<A>ss_AND (x0, x1) ((a0, a1), s, z0, z1)\n                        ((a0, a1), s', z0', z1')).\n        ((x0, x1), w') \\<in> Rel_AND)", "have \"w1 \\<in> set_spmf (\\<A>ss1 x1 (a1, s, z1) (a1, s', z1')) \\<longrightarrow> (x1,w1) \\<in> Rel1\" for w1"], ["proof (prove)\ngoal (1 subgoal):\n 1. w1 \\<in> set_spmf\n              (\\<A>ss1 x1 (a1, s, z1) (a1, s', z1')) \\<longrightarrow>\n    (x1, w1) \\<in> Rel1", "using 3 4 \\<Sigma>1.special_soundness_def \\<Sigma>_prot1 \\<Sigma>1.\\<Sigma>_protocol_def x1_in_dom challenge_space_def assms valid_pub_AND_def valid_pub"], ["proof (prove)\nusing this:\n  check0 x0 a0 s z0\n  check1 x1 a1 s' z1'\n  \\<Sigma>1.special_soundness \\<equiv>\n  \\<forall>h e e' a z z'.\n     h \\<in> valid_pub1 \\<longrightarrow>\n     e \\<in> carrier L \\<longrightarrow>\n     e' \\<in> carrier L \\<longrightarrow>\n     e \\<noteq> e' \\<longrightarrow>\n     check1 h a e z \\<longrightarrow>\n     check1 h a e' z' \\<longrightarrow>\n     lossless_spmf (\\<A>ss1 h (a, e, z) (a, e', z')) \\<and>\n     (\\<forall>w'\\<in>set_spmf (\\<A>ss1 h (a, e, z) (a, e', z')).\n         (h, w') \\<in> Rel1)\n  \\<Sigma>1.\\<Sigma>_protocol\n  \\<Sigma>1.\\<Sigma>_protocol \\<equiv>\n  \\<Sigma>1.completeness \\<and>\n  \\<Sigma>1.special_soundness \\<and> \\<Sigma>1.HVZK\n  x1 \\<in> valid_pub1\n  challenge_space = carrier L\n  s \\<noteq> s'\n  (x0, x1) \\<in> valid_pub_AND\n  s \\<in> challenge_space\n  s' \\<in> challenge_space\n  check_AND (x0, x1) (a0, a1) s (z0, z1)\n  check_AND (x0, x1) (a0, a1) s' (z0', z1')\n  valid_pub_AND = {(x0, x1). x0 \\<in> valid_pub0 \\<and> x1 \\<in> valid_pub1}\n  (x0, x1) \\<in> valid_pub_AND\n\ngoal (1 subgoal):\n 1. w1 \\<in> set_spmf\n              (\\<A>ss1 x1 (a1, s, z1) (a1, s', z1')) \\<longrightarrow>\n    (x1, w1) \\<in> Rel1", "by fastforce"], ["proof (state)\nthis:\n  ?w1.0\n  \\<in> set_spmf (\\<A>ss1 x1 (a1, s, z1) (a1, s', z1')) \\<longrightarrow>\n  (x1, ?w1.0) \\<in> Rel1\n\ngoal (1 subgoal):\n 1. lossless_spmf\n     (\\<A>ss_AND (x0, x1) ((a0, a1), s, z0, z1)\n       ((a0, a1), s', z0', z1')) \\<and>\n    (\\<forall>w'\\<in>set_spmf\n                      (\\<A>ss_AND (x0, x1) ((a0, a1), s, z0, z1)\n                        ((a0, a1), s', z0', z1')).\n        ((x0, x1), w') \\<in> Rel_AND)", "ultimately"], ["proof (chain)\npicking this:\n  x0 \\<in> valid_pub0\n  x1 \\<in> valid_pub1\n  check0 x0 a0 s z0\n  check1 x1 a1 s' z1'\n  ?w0.0\n  \\<in> set_spmf (\\<A>ss0 x0 (a0, s, z0) (a0, s', z0')) \\<longrightarrow>\n  (x0, ?w0.0) \\<in> Rel0\n  ?w1.0\n  \\<in> set_spmf (\\<A>ss1 x1 (a1, s, z1) (a1, s', z1')) \\<longrightarrow>\n  (x1, ?w1.0) \\<in> Rel1", "show ?thesis"], ["proof (prove)\nusing this:\n  x0 \\<in> valid_pub0\n  x1 \\<in> valid_pub1\n  check0 x0 a0 s z0\n  check1 x1 a1 s' z1'\n  ?w0.0\n  \\<in> set_spmf (\\<A>ss0 x0 (a0, s, z0) (a0, s', z0')) \\<longrightarrow>\n  (x0, ?w0.0) \\<in> Rel0\n  ?w1.0\n  \\<in> set_spmf (\\<A>ss1 x1 (a1, s, z1) (a1, s', z1')) \\<longrightarrow>\n  (x1, ?w1.0) \\<in> Rel1\n\ngoal (1 subgoal):\n 1. lossless_spmf\n     (\\<A>ss_AND (x0, x1) ((a0, a1), s, z0, z1)\n       ((a0, a1), s', z0', z1')) \\<and>\n    (\\<forall>w'\\<in>set_spmf\n                      (\\<A>ss_AND (x0, x1) ((a0, a1), s, z0, z1)\n                        ((a0, a1), s', z0', z1')).\n        ((x0, x1), w') \\<in> Rel_AND)", "by(auto simp add: lossless_\\<A>ss Rel_AND_def)"], ["proof (state)\nthis:\n  lossless_spmf\n   (\\<A>ss_AND (x0, x1) ((a0, a1), s, z0, z1)\n     ((a0, a1), s', z0', z1')) \\<and>\n  (\\<forall>w'\\<in>set_spmf\n                    (\\<A>ss_AND (x0, x1) ((a0, a1), s, z0, z1)\n                      ((a0, a1), s', z0', z1')).\n      ((x0, x1), w') \\<in> Rel_AND)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma special_soundness:\n  shows \"\\<Sigma>_AND.special_soundness\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sigma>_AND.special_soundness", "using \\<Sigma>_AND.special_soundness_def ss"], ["proof (prove)\nusing this:\n  \\<Sigma>_AND.special_soundness \\<equiv>\n  \\<forall>h e e' a z z'.\n     h \\<in> valid_pub_AND \\<longrightarrow>\n     e \\<in> challenge_space \\<longrightarrow>\n     e' \\<in> challenge_space \\<longrightarrow>\n     e \\<noteq> e' \\<longrightarrow>\n     check_AND h a e z \\<longrightarrow>\n     check_AND h a e' z' \\<longrightarrow>\n     lossless_spmf (\\<A>ss_AND h (a, e, z) (a, e', z')) \\<and>\n     (\\<forall>w'\\<in>set_spmf (\\<A>ss_AND h (a, e, z) (a, e', z')).\n         (h, w') \\<in> Rel_AND)\n  \\<lbrakk>?s \\<noteq> ?s'; (?x0.0, ?x1.0) \\<in> valid_pub_AND;\n   ?s \\<in> challenge_space; ?s' \\<in> challenge_space;\n   check_AND (?x0.0, ?x1.0) (?a0.0, ?a1.0) ?s (?z0.0, ?z1.0);\n   check_AND (?x0.0, ?x1.0) (?a0.0, ?a1.0) ?s' (?z0', ?z1')\\<rbrakk>\n  \\<Longrightarrow> lossless_spmf\n                     (\\<A>ss_AND (?x0.0, ?x1.0)\n                       ((?a0.0, ?a1.0), ?s, ?z0.0, ?z1.0)\n                       ((?a0.0, ?a1.0), ?s', ?z0', ?z1')) \\<and>\n                    (\\<forall>w'\\<in>set_spmf\n(\\<A>ss_AND (?x0.0, ?x1.0) ((?a0.0, ?a1.0), ?s, ?z0.0, ?z1.0)\n  ((?a0.0, ?a1.0), ?s', ?z0', ?z1')).\n                        ((?x0.0, ?x1.0), w') \\<in> Rel_AND)\n\ngoal (1 subgoal):\n 1. \\<Sigma>_AND.special_soundness", "by fast"], ["", "theorem \\<Sigma>_protocol:\n  shows \"\\<Sigma>_AND.\\<Sigma>_protocol\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sigma>_AND.\\<Sigma>_protocol", "by(auto simp add: \\<Sigma>_AND.\\<Sigma>_protocol_def completeness HVZK special_soundness)"], ["", "sublocale AND_\\<Sigma>_commit: \\<Sigma>_protocols_to_commitments init_AND response_AND check_AND Rel_AND S_AND \\<A>ss_AND challenge_space valid_pub_AND G"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sigma>_protocols_to_commitments init_AND response_AND check_AND\n     Rel_AND S_AND \\<A>ss_AND challenge_space valid_pub_AND G", "apply unfold_locales"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<Sigma>_AND.\\<Sigma>_protocol\n 2. \\<And>h w.\n       (h, w) \\<in> set_spmf G \\<Longrightarrow> (h, w) \\<in> Rel_AND\n 3. lossless_spmf G\n 4. \\<And>h w. lossless_spmf (init_AND h w)\n 5. \\<And>r w e. lossless_spmf (response_AND r w e)", "by(auto simp add: \\<Sigma>_protocol set_spmf_G_L lossless_G lossless_init_AND lossless_response_AND)"], ["", "lemma \"AND_\\<Sigma>_commit.abstract_com.correct\""], ["proof (prove)\ngoal (1 subgoal):\n 1. AND_\\<Sigma>_commit.abstract_com.correct", "using AND_\\<Sigma>_commit.commit_correct"], ["proof (prove)\nusing this:\n  AND_\\<Sigma>_commit.abstract_com.correct\n\ngoal (1 subgoal):\n 1. AND_\\<Sigma>_commit.abstract_com.correct", "by simp"], ["", "lemma \"AND_\\<Sigma>_commit.abstract_com.perfect_hiding_ind_cpa \\<A>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. AND_\\<Sigma>_commit.abstract_com.perfect_hiding_ind_cpa \\<A>", "using AND_\\<Sigma>_commit.perfect_hiding"], ["proof (prove)\nusing this:\n  AND_\\<Sigma>_commit.abstract_com.perfect_hiding_ind_cpa ?\\<A>\n\ngoal (1 subgoal):\n 1. AND_\\<Sigma>_commit.abstract_com.perfect_hiding_ind_cpa \\<A>", "by blast"], ["", "lemma bind_advantage_bound_dis_log: \n  shows \"AND_\\<Sigma>_commit.abstract_com.bind_advantage \\<A> \\<le> AND_\\<Sigma>_commit.rel_advantage (AND_\\<Sigma>_commit.adversary \\<A>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. AND_\\<Sigma>_commit.abstract_com.bind_advantage \\<A>\n    \\<le> AND_\\<Sigma>_commit.rel_advantage\n           (AND_\\<Sigma>_commit.adversary \\<A>)", "using AND_\\<Sigma>_commit.bind_advantage"], ["proof (prove)\nusing this:\n  AND_\\<Sigma>_commit.abstract_com.bind_advantage ?\\<A>\n  \\<le> AND_\\<Sigma>_commit.rel_advantage\n         (AND_\\<Sigma>_commit.adversary ?\\<A>)\n\ngoal (1 subgoal):\n 1. AND_\\<Sigma>_commit.abstract_com.bind_advantage \\<A>\n    \\<le> AND_\\<Sigma>_commit.rel_advantage\n           (AND_\\<Sigma>_commit.adversary \\<A>)", "by simp"], ["", "end"], ["", "end"]]}