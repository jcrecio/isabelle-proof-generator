{"file_name": "/home/qj213/afp-2021-10-22/thys/Sigma_Commit_Crypto/Discrete_Log.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Sigma_Commit_Crypto", "problem_names": ["lemma lossless_dis_log: \"\\<lbrakk>0 < order \\<G>; \\<forall> h. lossless_spmf (\\<A> h)\\<rbrakk> \\<Longrightarrow> lossless_spmf (dis_log \\<A>)\"", "lemma dis_log_adv3:\n  shows \"advantage3 \\<A> = dis_log.advantage (adversary3 \\<A>)\"", "lemma dis_log_adv2:\n  shows  \"advantage2 \\<A> = dis_log.advantage (adversary2 \\<A>)\""], "translations": [["", "lemma lossless_dis_log: \"\\<lbrakk>0 < order \\<G>; \\<forall> h. lossless_spmf (\\<A> h)\\<rbrakk> \\<Longrightarrow> lossless_spmf (dis_log \\<A>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < order \\<G>; \\<forall>h. lossless_spmf (\\<A> h)\\<rbrakk>\n    \\<Longrightarrow> lossless_spmf (local.dis_log \\<A>)", "by(auto simp add:  dis_log_def)"], ["", "end"], ["", "locale dis_log_alt = \n  fixes \\<G> :: \"'grp cyclic_group\" (structure)\n    and x :: nat\n  assumes order_gt_0 [simp]: \"order \\<G> > 0\"\nbegin"], ["", "sublocale dis_log: dis_log \\<G>"], ["proof (prove)\ngoal (1 subgoal):\n 1. dis_log \\<G>", "unfolding dis_log_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < order \\<G>", "by simp"], ["", "definition \"g' = \\<^bold>g [^] x\""], ["", "definition dis_log2 :: \"'grp dis_log.dislog_adv' \\<Rightarrow> bool spmf\"\nwhere \"dis_log2 \\<A> = TRY do {\n    w \\<leftarrow> sample_uniform (order \\<G>);\n    let h = \\<^bold>g [^] w;\n    (w1',w2') \\<leftarrow> \\<A> h;\n    return_spmf ([w = (w1' + x * w2')]  (mod (order \\<G>)))} ELSE return_spmf False\""], ["", "definition advantage2 :: \"'grp dis_log.dislog_adv' \\<Rightarrow> real\"\nwhere \"advantage2 \\<A> \\<equiv> spmf (dis_log2 \\<A>) True\""], ["", "definition adversary2 :: \"('grp \\<Rightarrow> (nat \\<times> nat) spmf) \\<Rightarrow> 'grp \\<Rightarrow> nat spmf\"\n  where \"adversary2 \\<A> h = do {\n    (w1,w2) \\<leftarrow> \\<A> h;\n    return_spmf (w1 + x * w2)}\""], ["", "definition dis_log3 :: \"'grp dis_log.dislog_adv2 \\<Rightarrow> bool spmf\"\nwhere \"dis_log3 \\<A> = TRY do {\n    w \\<leftarrow> sample_uniform (order \\<G>);\n    let (h,w) = ((\\<^bold>g [^] w, g' [^] w), w);\n    w' \\<leftarrow> \\<A> h;\n    return_spmf ([w = w'] (mod (order \\<G>)))} ELSE return_spmf False\""], ["", "definition advantage3 :: \"'grp dis_log.dislog_adv2 \\<Rightarrow> real\"\n  where \"advantage3 \\<A> \\<equiv> spmf (dis_log3 \\<A>) True\""], ["", "definition adversary3:: \"'grp dis_log.dislog_adv2 \\<Rightarrow> 'grp \\<Rightarrow> nat spmf\"\n  where \"adversary3 \\<A> g = do {\n    \\<A> (g, g [^] x)}\""], ["", "end"], ["", "locale dis_log_alt_reductions = dis_log_alt + cyclic_group \\<G> \nbegin"], ["", "lemma dis_log_adv3:\n  shows \"advantage3 \\<A> = dis_log.advantage (adversary3 \\<A>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. advantage3 \\<A> = local.dis_log.advantage (adversary3 \\<A>)", "unfolding dis_log_alt.advantage3_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. advantage3 \\<A> = local.dis_log.advantage (adversary3 \\<A>)", "by(simp add: advantage3_def dis_log.advantage_def adversary3_def dis_log.dis_log_def dis_log3_def Let_def g'_def power_swap)"], ["", "lemma dis_log_adv2:\n  shows  \"advantage2 \\<A> = dis_log.advantage (adversary2 \\<A>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. advantage2 \\<A> = local.dis_log.advantage (adversary2 \\<A>)", "unfolding dis_log_alt.advantage2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. advantage2 \\<A> = local.dis_log.advantage (adversary2 \\<A>)", "by(simp add: advantage2_def dis_log2_def dis_log.advantage_def dis_log.dis_log_def adversary2_def split_def)"], ["", "end"], ["", "end"]]}