{"file_name": "/home/qj213/afp-2021-10-22/thys/Sigma_Commit_Crypto/Number_Theory_Aux.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Sigma_Commit_Crypto", "problem_names": ["lemma inverse: assumes \"gcd x q = 1\" \n  shows \"[x * inverse x q = 1] (mod q)\"", "lemma prod_not_prime: \n  assumes \"prime (x::nat)\" \n    and \"prime y\" \n    and \"x > 2\" \n    and \"y > 2\" \n  shows \"\\<not> prime ((x-1)*(y-1))\"", "lemma ex_inverse:\n  assumes coprime: \"coprime (e :: nat) ((P-1)*(Q-1))\" \n    and \"prime P\" \n    and \"prime Q\"   \n    and \"P \\<noteq> Q\" \n  shows \"\\<exists> d. [e*d = 1] (mod (P-1)) \\<and> d \\<noteq> 0\"", "lemma ex_k1_k2:\n  assumes coprime: \"coprime (e :: nat) ((P-1)*(Q-1))\" \n    and \" [e*d = 1] (mod (P-1))\"\n  shows \"\\<exists> k1 k2. e*d + k1*(P-1) = 1 + k2*(P-1)\"", "lemma \"a > b \\<Longrightarrow>int a - int b = int (a - b)\"", "lemma ex_k_mod:\n  assumes coprime: \"coprime (e :: nat) ((P-1)*(Q-1))\" \n    and \"P \\<noteq> Q\"\n    and \"prime P\"\n    and \"prime Q\"\n    and \"d \\<noteq> 0\"\n    and \" [e*d = 1] (mod (P-1))\"\n  shows \"\\<exists> k. e*d = 1 + k*(P-1)\"", "lemma fermat_little_theorem:\n  assumes \"prime (P :: nat)\" \n  shows \"[x^P = x] (mod P)\"", "lemma prime_field:\n  assumes \"prime (q::nat)\" \n    and \"a < q\" \n    and \"a \\<noteq> 0\"\n  shows \"coprime a q\""], "translations": [["", "lemma inverse: assumes \"gcd x q = 1\" \n  shows \"[x * inverse x q = 1] (mod q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [int x * Number_Theory_Aux.inverse x q = 1] (mod int q)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. [int x * Number_Theory_Aux.inverse x q = 1] (mod int q)", "have 2: \"fst (bezw x q) * x + snd (bezw x q) * int q = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Number_Theory_Aux.inverse x q * int x + snd (bezw x q) * int q = 1", "using bezw_aux assms int_minus"], ["proof (prove)\nusing this:\n  int (gcd ?x ?y) =\n  Number_Theory_Aux.inverse ?x ?y * int ?x + snd (bezw ?x ?y) * int ?y\n  gcd x q = 1\n  int (?n - ?m) = int (nat (int ?n - int ?m))\n\ngoal (1 subgoal):\n 1. Number_Theory_Aux.inverse x q * int x + snd (bezw x q) * int q = 1", "by (metis Num.of_nat_simps(2))"], ["proof (state)\nthis:\n  Number_Theory_Aux.inverse x q * int x + snd (bezw x q) * int q = 1\n\ngoal (1 subgoal):\n 1. [int x * Number_Theory_Aux.inverse x q = 1] (mod int q)", "hence 3: \"(fst (bezw x q) * x + snd (bezw x q) * int q) mod q = 1 mod q\""], ["proof (prove)\nusing this:\n  Number_Theory_Aux.inverse x q * int x + snd (bezw x q) * int q = 1\n\ngoal (1 subgoal):\n 1. (Number_Theory_Aux.inverse x q * int x + snd (bezw x q) * int q) mod\n    int q =\n    int (1 mod q)", "by (metis assms bezw_aux of_nat_mod)"], ["proof (state)\nthis:\n  (Number_Theory_Aux.inverse x q * int x + snd (bezw x q) * int q) mod\n  int q =\n  int (1 mod q)\n\ngoal (1 subgoal):\n 1. [int x * Number_Theory_Aux.inverse x q = 1] (mod int q)", "hence 4: \"(fst (bezw x q) * x) mod q = 1 mod q\""], ["proof (prove)\nusing this:\n  (Number_Theory_Aux.inverse x q * int x + snd (bezw x q) * int q) mod\n  int q =\n  int (1 mod q)\n\ngoal (1 subgoal):\n 1. Number_Theory_Aux.inverse x q * int x mod int q = int (1 mod q)", "by simp"], ["proof (state)\nthis:\n  Number_Theory_Aux.inverse x q * int x mod int q = int (1 mod q)\n\ngoal (1 subgoal):\n 1. [int x * Number_Theory_Aux.inverse x q = 1] (mod int q)", "hence 5:  \"[(fst (bezw x q)) * x  = 1] (mod q)\""], ["proof (prove)\nusing this:\n  Number_Theory_Aux.inverse x q * int x mod int q = int (1 mod q)\n\ngoal (1 subgoal):\n 1. [Number_Theory_Aux.inverse x q * int x = 1] (mod int q)", "using 2 3 cong_def"], ["proof (prove)\nusing this:\n  Number_Theory_Aux.inverse x q * int x mod int q = int (1 mod q)\n  Number_Theory_Aux.inverse x q * int x + snd (bezw x q) * int q = 1\n  (Number_Theory_Aux.inverse x q * int x + snd (bezw x q) * int q) mod\n  int q =\n  int (1 mod q)\n  [?b = ?c] (mod ?a) = (?b mod ?a = ?c mod ?a)\n\ngoal (1 subgoal):\n 1. [Number_Theory_Aux.inverse x q * int x = 1] (mod int q)", "by force"], ["proof (state)\nthis:\n  [Number_Theory_Aux.inverse x q * int x = 1] (mod int q)\n\ngoal (1 subgoal):\n 1. [int x * Number_Theory_Aux.inverse x q = 1] (mod int q)", "then"], ["proof (chain)\npicking this:\n  [Number_Theory_Aux.inverse x q * int x = 1] (mod int q)", "show ?thesis"], ["proof (prove)\nusing this:\n  [Number_Theory_Aux.inverse x q * int x = 1] (mod int q)\n\ngoal (1 subgoal):\n 1. [int x * Number_Theory_Aux.inverse x q = 1] (mod int q)", "by(simp add: mult.commute)"], ["proof (state)\nthis:\n  [int x * Number_Theory_Aux.inverse x q = 1] (mod int q)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma prod_not_prime: \n  assumes \"prime (x::nat)\" \n    and \"prime y\" \n    and \"x > 2\" \n    and \"y > 2\" \n  shows \"\\<not> prime ((x-1)*(y-1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> prime ((x - 1) * (y - 1))", "by (metis assms One_nat_def Suc_diff_1 nat_neq_iff numeral_2_eq_2 prime_gt_0_nat prime_product)"], ["", "lemma ex_inverse:\n  assumes coprime: \"coprime (e :: nat) ((P-1)*(Q-1))\" \n    and \"prime P\" \n    and \"prime Q\"   \n    and \"P \\<noteq> Q\" \n  shows \"\\<exists> d. [e*d = 1] (mod (P-1)) \\<and> d \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>d. [e * d = 1] (mod P - 1) \\<and> d \\<noteq> 0", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>d. [e * d = 1] (mod P - 1) \\<and> d \\<noteq> 0", "have \"coprime e (P-1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coprime e (P - 1)", "using assms(1)"], ["proof (prove)\nusing this:\n  coprime e ((P - 1) * (Q - 1))\n\ngoal (1 subgoal):\n 1. coprime e (P - 1)", "by simp"], ["proof (state)\nthis:\n  coprime e (P - 1)\n\ngoal (1 subgoal):\n 1. \\<exists>d. [e * d = 1] (mod P - 1) \\<and> d \\<noteq> 0", "then"], ["proof (chain)\npicking this:\n  coprime e (P - 1)", "obtain d where d: \"[e*d = 1] (mod (P-1))\""], ["proof (prove)\nusing this:\n  coprime e (P - 1)\n\ngoal (1 subgoal):\n 1. (\\<And>d.\n        [e * d = 1] (mod P - 1) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using cong_solve_coprime_nat"], ["proof (prove)\nusing this:\n  coprime e (P - 1)\n  coprime ?a ?n \\<Longrightarrow> \\<exists>x. [?a * x = Suc 0] (mod ?n)\n\ngoal (1 subgoal):\n 1. (\\<And>d.\n        [e * d = 1] (mod P - 1) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  [e * d = 1] (mod P - 1)\n\ngoal (1 subgoal):\n 1. \\<exists>d. [e * d = 1] (mod P - 1) \\<and> d \\<noteq> 0", "then"], ["proof (chain)\npicking this:\n  [e * d = 1] (mod P - 1)", "show ?thesis"], ["proof (prove)\nusing this:\n  [e * d = 1] (mod P - 1)\n\ngoal (1 subgoal):\n 1. \\<exists>d. [e * d = 1] (mod P - 1) \\<and> d \\<noteq> 0", "by (metis cong_0_1_nat cong_1 mult_0_right zero_neq_one)"], ["proof (state)\nthis:\n  \\<exists>d. [e * d = 1] (mod P - 1) \\<and> d \\<noteq> 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ex_k1_k2:\n  assumes coprime: \"coprime (e :: nat) ((P-1)*(Q-1))\" \n    and \" [e*d = 1] (mod (P-1))\"\n  shows \"\\<exists> k1 k2. e*d + k1*(P-1) = 1 + k2*(P-1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>k1 k2. e * d + k1 * (P - 1) = 1 + k2 * (P - 1)", "by (metis assms(2) cong_iff_lin_nat)"], ["", "lemma \"a > b \\<Longrightarrow>int a - int b = int (a - b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b < a \\<Longrightarrow> int a - int b = int (a - b)", "by simp"], ["", "lemma ex_k_mod:\n  assumes coprime: \"coprime (e :: nat) ((P-1)*(Q-1))\" \n    and \"P \\<noteq> Q\"\n    and \"prime P\"\n    and \"prime Q\"\n    and \"d \\<noteq> 0\"\n    and \" [e*d = 1] (mod (P-1))\"\n  shows \"\\<exists> k. e*d = 1 + k*(P-1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>k. e * d = 1 + k * (P - 1)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>k. e * d = 1 + k * (P - 1)", "have \"e > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < e", "using assms(1) assms(2) prime_gt_0_nat"], ["proof (prove)\nusing this:\n  coprime e ((P - 1) * (Q - 1))\n  P \\<noteq> Q\n  prime ?p \\<Longrightarrow> 0 < ?p\n\ngoal (1 subgoal):\n 1. 0 < e", "by fastforce"], ["proof (state)\nthis:\n  0 < e\n\ngoal (1 subgoal):\n 1. \\<exists>k. e * d = 1 + k * (P - 1)", "then"], ["proof (chain)\npicking this:\n  0 < e", "have \"e*d \\<ge> 1\""], ["proof (prove)\nusing this:\n  0 < e\n\ngoal (1 subgoal):\n 1. 1 \\<le> e * d", "using assms"], ["proof (prove)\nusing this:\n  0 < e\n  coprime e ((P - 1) * (Q - 1))\n  P \\<noteq> Q\n  prime P\n  prime Q\n  d \\<noteq> 0\n  [e * d = 1] (mod P - 1)\n\ngoal (1 subgoal):\n 1. 1 \\<le> e * d", "by simp"], ["proof (state)\nthis:\n  1 \\<le> e * d\n\ngoal (1 subgoal):\n 1. \\<exists>k. e * d = 1 + k * (P - 1)", "then"], ["proof (chain)\npicking this:\n  1 \\<le> e * d", "obtain k where k: \"e*d = 1 + k*(P-1)\""], ["proof (prove)\nusing this:\n  1 \\<le> e * d\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        e * d = 1 + k * (P - 1) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms(6) cong_to_1'_nat"], ["proof (prove)\nusing this:\n  1 \\<le> e * d\n  [e * d = 1] (mod P - 1)\n  [?a = 1] (mod ?n) =\n  (?a = 0 \\<and> ?n = 1 \\<or> (\\<exists>m. ?a = 1 + m * ?n))\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        e * d = 1 + k * (P - 1) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  e * d = 1 + k * (P - 1)\n\ngoal (1 subgoal):\n 1. \\<exists>k. e * d = 1 + k * (P - 1)", "then"], ["proof (chain)\npicking this:\n  e * d = 1 + k * (P - 1)", "show ?thesis"], ["proof (prove)\nusing this:\n  e * d = 1 + k * (P - 1)\n\ngoal (1 subgoal):\n 1. \\<exists>k. e * d = 1 + k * (P - 1)", "by simp"], ["proof (state)\nthis:\n  \\<exists>k. e * d = 1 + k * (P - 1)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma fermat_little_theorem:\n  assumes \"prime (P :: nat)\" \n  shows \"[x^P = x] (mod P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [x ^ P = x] (mod P)", "proof(cases \"P dvd x\")"], ["proof (state)\ngoal (2 subgoals):\n 1. P dvd x \\<Longrightarrow> [x ^ P = x] (mod P)\n 2. \\<not> P dvd x \\<Longrightarrow> [x ^ P = x] (mod P)", "case True"], ["proof (state)\nthis:\n  P dvd x\n\ngoal (2 subgoals):\n 1. P dvd x \\<Longrightarrow> [x ^ P = x] (mod P)\n 2. \\<not> P dvd x \\<Longrightarrow> [x ^ P = x] (mod P)", "hence \"x mod P = 0\""], ["proof (prove)\nusing this:\n  P dvd x\n\ngoal (1 subgoal):\n 1. x mod P = 0", "by simp"], ["proof (state)\nthis:\n  x mod P = 0\n\ngoal (2 subgoals):\n 1. P dvd x \\<Longrightarrow> [x ^ P = x] (mod P)\n 2. \\<not> P dvd x \\<Longrightarrow> [x ^ P = x] (mod P)", "moreover"], ["proof (state)\nthis:\n  x mod P = 0\n\ngoal (2 subgoals):\n 1. P dvd x \\<Longrightarrow> [x ^ P = x] (mod P)\n 2. \\<not> P dvd x \\<Longrightarrow> [x ^ P = x] (mod P)", "have \"x ^ P mod P = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x ^ P mod P = 0", "by (simp add: True assms prime_dvd_power_nat_iff prime_gt_0_nat)"], ["proof (state)\nthis:\n  x ^ P mod P = 0\n\ngoal (2 subgoals):\n 1. P dvd x \\<Longrightarrow> [x ^ P = x] (mod P)\n 2. \\<not> P dvd x \\<Longrightarrow> [x ^ P = x] (mod P)", "ultimately"], ["proof (chain)\npicking this:\n  x mod P = 0\n  x ^ P mod P = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  x mod P = 0\n  x ^ P mod P = 0\n\ngoal (1 subgoal):\n 1. [x ^ P = x] (mod P)", "by (simp add: cong_def)"], ["proof (state)\nthis:\n  [x ^ P = x] (mod P)\n\ngoal (1 subgoal):\n 1. \\<not> P dvd x \\<Longrightarrow> [x ^ P = x] (mod P)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> P dvd x \\<Longrightarrow> [x ^ P = x] (mod P)", "case False"], ["proof (state)\nthis:\n  \\<not> P dvd x\n\ngoal (1 subgoal):\n 1. \\<not> P dvd x \\<Longrightarrow> [x ^ P = x] (mod P)", "hence \"[x ^ (P - 1) = 1] (mod P)\""], ["proof (prove)\nusing this:\n  \\<not> P dvd x\n\ngoal (1 subgoal):\n 1. [x ^ (P - 1) = 1] (mod P)", "using fermat_theorem assms"], ["proof (prove)\nusing this:\n  \\<not> P dvd x\n  \\<lbrakk>prime ?p; \\<not> ?p dvd ?a\\<rbrakk>\n  \\<Longrightarrow> [?a ^ (?p - 1) = 1] (mod ?p)\n  prime P\n\ngoal (1 subgoal):\n 1. [x ^ (P - 1) = 1] (mod P)", "by blast"], ["proof (state)\nthis:\n  [x ^ (P - 1) = 1] (mod P)\n\ngoal (1 subgoal):\n 1. \\<not> P dvd x \\<Longrightarrow> [x ^ P = x] (mod P)", "then"], ["proof (chain)\npicking this:\n  [x ^ (P - 1) = 1] (mod P)", "show ?thesis"], ["proof (prove)\nusing this:\n  [x ^ (P - 1) = 1] (mod P)\n\ngoal (1 subgoal):\n 1. [x ^ P = x] (mod P)", "by (metis Suc_diff_1 assms cong_scalar_left nat_mult_1_right not_gr_zero not_prime_0 power_Suc)"], ["proof (state)\nthis:\n  [x ^ P = x] (mod P)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma prime_field:\n  assumes \"prime (q::nat)\" \n    and \"a < q\" \n    and \"a \\<noteq> 0\"\n  shows \"coprime a q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coprime a q", "by (meson assms coprime_commute dvd_imp_le linorder_not_le neq0_conv prime_imp_coprime)"], ["", "end"]]}