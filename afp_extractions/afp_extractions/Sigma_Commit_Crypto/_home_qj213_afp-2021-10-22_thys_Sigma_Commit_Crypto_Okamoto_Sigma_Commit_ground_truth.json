{"file_name": "/home/qj213/afp-2021-10-22/thys/Sigma_Commit_Crypto/Okamoto_Sigma_Commit.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Sigma_Commit_Crypto", "problem_names": ["lemma order_gt_1: \"order \\<G> > 1\"", "lemma order_gt_0 [simp]:\"order \\<G> > 0\"", "lemma lossless_response: \"lossless_spmf (response r w e)\"", "lemma lossless_init: \"lossless_spmf (init h  w)\"", "lemma lossless_G: \"lossless_spmf G\"", "lemma g'_in_carrier [simp]: \"g' \\<in> carrier \\<G>\"", "lemma \"\\<Sigma>_protocols_base.R h w c = R2 h w c\"", "lemma completeness: \n  shows \"\\<Sigma>_protocols_base.completeness\"", "lemma hvzk_z_r:\n  assumes r1: \"r1 < order \\<G>\" \n  shows \"r1 = ((r1 + c * (x1 :: nat)) mod (order \\<G>) + order \\<G> * c * x1 - c * x1) mod (order \\<G>)\"", "lemma hvzk_z1_r1_tuple_rewrite: \n  assumes r1: \"r1 < order \\<G>\" \n  shows \"(\\<^bold>g [^] r1 \\<otimes> g' [^] r2, c, (r1 + c * x1) mod order \\<G>, (r2 + c * x2) mod order \\<G>) = \n              (\\<^bold>g [^] (((r1 + c * x1) mod order \\<G> + order \\<G> * c * x1 - c * x1) mod order \\<G>)  \n                  \\<otimes> g' [^] r2, c, (r1 + c * x1) mod order \\<G>, (r2 + c * x2) mod order \\<G>)\"", "lemma hvzk_z2_r2_tuple_rewrite: \n  assumes \"xb < order \\<G>\" \n  shows \"(\\<^bold>g [^] (((x' + xa * x1) mod order \\<G> + order \\<G> * xa * x1 - xa * x1) mod order \\<G>) \n            \\<otimes> g' [^] xb, xa, (x' + xa * x1) mod order \\<G>, (xb + xa * x2) mod order \\<G>) =\n               (\\<^bold>g [^] (((x' + xa * x1) mod order \\<G> + order \\<G> * xa * x1 - xa * x1) mod order \\<G>) \n                \\<otimes> g' [^] (((xb + xa * x2) mod order \\<G> + order \\<G> * xa * x2 - xa * x2) mod order \\<G>), xa, (x' + xa * x1) mod order \\<G>, (xb + xa * x2) mod order \\<G>)\"", "lemma hvzk_sim_inverse_rewrite: \n  assumes h: \"h =  \\<^bold>g [^] (x1 :: nat) \\<otimes> g' [^] (x2 :: nat)\"\n  shows \"\\<^bold>g [^] (((z1::nat) + order \\<G> * c * x1 - c * x1) mod (order \\<G>)) \n            \\<otimes> g' [^] (((z2::nat) + order \\<G> * c * x2 - c * x2) mod (order \\<G>))\n                = (\\<^bold>g [^] z1 \\<otimes> g' [^] z2) \\<otimes> (inv h [^] c)\"\n(is \"?lhs = ?rhs\")", "lemma hv_zk: \n  assumes \"h =  \\<^bold>g [^] x1 \\<otimes> g' [^] x2\"\n  shows \"\\<Sigma>_protocols_base.R h (x1,x2) c = \\<Sigma>_protocols_base.S h c\"", "lemma HVZK: \n  shows \"\\<Sigma>_protocols_base.HVZK\"", "lemma ss_rewrite:\n  assumes \"h \\<in> carrier \\<G>\"\n    and \"a \\<in> carrier \\<G>\"\n    and \"e < order \\<G>\" \n    and \"\\<^bold>g [^] z1 \\<otimes> g' [^] z1' = a \\<otimes> h [^] e\"\n    and \"e' < e\"\n    and \"\\<^bold>g [^] z2 \\<otimes> g' [^] z2' = a \\<otimes> h [^] e' \"\n  shows \"h = \\<^bold>g [^] ((int z1 - int z2) * fst (bezw (e - e') (order \\<G>)) mod int (order \\<G>)) \\<otimes> g' [^] ((int z1' - int z2') * fst (bezw (e - e') (order \\<G>)) mod int (order \\<G>))\"", "lemma \n  assumes h_mem: \"h \\<in> carrier \\<G>\" \n    and a_mem: \"a \\<in> carrier \\<G>\" \n    and a: \"\\<^bold>g [^] fst z \\<otimes> g' [^] snd z = a \\<otimes> h [^] e\"\n    and a': \"\\<^bold>g [^] fst z' \\<otimes> g' [^] snd z' = a \\<otimes> h [^] e'\"\n    and e_e'_mod: \"e' mod order \\<G> < e mod order \\<G>\"\n  shows \"h = \\<^bold>g [^] ((int (fst z) - int (fst z')) * fst (bezw ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>) (order \\<G>)) mod int (order \\<G>)) \n              \\<otimes> g' [^] ((int (snd z) - int (snd z')) * fst (bezw ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>) (order \\<G>)) mod int (order \\<G>))\"", "lemma special_soundness:\n  shows \"\\<Sigma>_protocols_base.special_soundness\"", "theorem \\<Sigma>_protocol: \n  shows \"\\<Sigma>_protocols_base.\\<Sigma>_protocol\"", "lemma reduction_to_dis_log:\n  shows \"okamoto_\\<Sigma>_commit.rel_advantage \\<A> = dis_log.advantage (dis_log_alt.adversary2 \\<A>)\"", "lemma commitment_correct: \"okamoto_\\<Sigma>_commit.abstract_com.correct\"", "lemma \"okamoto_\\<Sigma>_commit.abstract_com.perfect_hiding_ind_cpa \\<A>\"", "lemma binding: \n  shows \"okamoto_\\<Sigma>_commit.abstract_com.bind_advantage \\<A> \n          \\<le> dis_log.advantage (dis_log_alt.adversary2 (okamoto_\\<Sigma>_commit.adversary \\<A>))\"", "theorem sigma_protocol:\n  shows \"\\<Sigma>_protocols_base.\\<Sigma>_protocol n\"", "lemma asymp_correct: \"okamoto_\\<Sigma>_commit.abstract_com.correct n\"", "lemma asymp_perfect_hiding: \"okamoto_\\<Sigma>_commit.abstract_com.perfect_hiding_ind_cpa n (\\<A> n)\"", "lemma asymp_computational_binding: \n  assumes \"negligible (\\<lambda> n. dis_log.advantage n (dis_log_alt.adversary2 (okamoto_\\<Sigma>_commit.adversary n (\\<A> n))))\"\n  shows \"negligible (\\<lambda> n. okamoto_\\<Sigma>_commit.abstract_com.bind_advantage n (\\<A> n))\""], "translations": [["", "lemma order_gt_1: \"order \\<G> > 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 < order \\<G>", "using prime_order"], ["proof (prove)\nusing this:\n  prime (order \\<G>)\n\ngoal (1 subgoal):\n 1. 1 < order \\<G>", "using prime_gt_1_nat"], ["proof (prove)\nusing this:\n  prime (order \\<G>)\n  prime ?p \\<Longrightarrow> 1 < ?p\n\ngoal (1 subgoal):\n 1. 1 < order \\<G>", "by blast"], ["", "lemma order_gt_0 [simp]:\"order \\<G> > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < order \\<G>", "using order_gt_1"], ["proof (prove)\nusing this:\n  1 < order \\<G>\n\ngoal (1 subgoal):\n 1. 0 < order \\<G>", "by simp"], ["", "definition \"response r w e = do {\n  let (r1,r2) = r;\n  let (x1,x2) = w;\n  let z1 = (e * x1 + r1) mod (order \\<G>);\n  let z2 = (e * x2 + r2) mod (order \\<G>);\n  return_spmf ((z1,z2))}\""], ["", "lemma lossless_response: \"lossless_spmf (response r w e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lossless_spmf (response r w e)", "by(simp add: response_def split_def)"], ["", "type_synonym witness = \"nat \\<times> nat\""], ["", "type_synonym rand = \"nat \\<times> nat\""], ["", "type_synonym 'grp' msg = \"'grp'\""], ["", "type_synonym response = \"(nat \\<times> nat)\""], ["", "type_synonym challenge = nat"], ["", "type_synonym 'grp' pub_in = \"'grp'\""], ["", "definition init :: \"'grp pub_in \\<Rightarrow> witness \\<Rightarrow> (rand \\<times> 'grp msg) spmf\"\n  where \"init y w = do {\n    let (x1,x2) = w; \n    r1 \\<leftarrow> sample_uniform (order \\<G>);\n    r2 \\<leftarrow> sample_uniform (order \\<G>);\n    return_spmf ((r1,r2), \\<^bold>g [^] r1 \\<otimes> g' [^] r2)}\""], ["", "lemma lossless_init: \"lossless_spmf (init h  w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lossless_spmf (init h w)", "by(simp add: init_def)"], ["", "definition check :: \"'grp pub_in \\<Rightarrow> 'grp msg \\<Rightarrow> challenge \\<Rightarrow> response \\<Rightarrow> bool\"\n  where \"check h a e z = (\\<^bold>g [^] (fst z) \\<otimes> g' [^] (snd z) = a \\<otimes> (h [^] e) \\<and> a \\<in> carrier \\<G>)\""], ["", "definition R :: \"('grp pub_in \\<times> witness) set\"\n  where \"R \\<equiv> {(h, w). (h = \\<^bold>g [^] (fst w) \\<otimes> g' [^] (snd w))}\""], ["", "definition G :: \"('grp pub_in \\<times> witness) spmf\"\n  where \"G = do {\n    w1 \\<leftarrow> sample_uniform (order \\<G>);\n    w2 \\<leftarrow> sample_uniform (order \\<G>);\n    return_spmf (\\<^bold>g [^] w1 \\<otimes> g' [^] w2 , (w1,w2))}\""], ["", "definition \"challenge_space = {..< order \\<G>}\""], ["", "lemma lossless_G: \"lossless_spmf G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lossless_spmf G", "by(simp add: G_def)"], ["", "definition S2 :: \"'grp pub_in \\<Rightarrow> challenge \\<Rightarrow> ('grp msg, response) sim_out spmf\"\n  where \"S2 h c = do {\n    z1 \\<leftarrow> sample_uniform  (order \\<G>);\n    z2 \\<leftarrow> sample_uniform  (order \\<G>);\n  let a =  (\\<^bold>g [^] z1 \\<otimes> g' [^] z2) \\<otimes> (inv h [^] c); \n  return_spmf (a, (z1,z2))}\""], ["", "definition R2 :: \"'grp pub_in \\<Rightarrow> witness \\<Rightarrow> challenge \\<Rightarrow> ('grp msg, challenge, response) conv_tuple spmf\"\n  where \"R2 h w c = do { \n    let (x1,x2) = w; \n    r1 \\<leftarrow> sample_uniform (order \\<G>);\n    r2 \\<leftarrow> sample_uniform (order \\<G>);\n    let z1 = (c * x1 + r1) mod (order \\<G>);\n    let z2 = (c * x2 + r2) mod (order \\<G>);\n    return_spmf (\\<^bold>g [^] r1 \\<otimes> g' [^] r2 ,c,(z1,z2))}\""], ["", "definition ss_adversary :: \"'grp \\<Rightarrow> ('grp msg, challenge, response) conv_tuple \\<Rightarrow> ('grp msg, challenge, response) conv_tuple \\<Rightarrow> (nat \\<times> nat) spmf\"\n  where \"ss_adversary y c1 c2 = do {\n    let (a, e, (z1,z2)) = c1;\n    let (a', e', (z1',z2')) = c2;\n    return_spmf (if (e > e') then (nat ((int z1 - int z1') * inverse (e - e') (order \\<G>) mod order \\<G>)) else \n                      (nat ((int z1' - int z1) * inverse (e' - e) (order \\<G>) mod order \\<G>)), \n                 if (e > e') then (nat ((int z2  - int z2') * inverse (e - e') (order \\<G>) mod order \\<G>)) else \n                      (nat ((int z2' - int z2) * inverse (e' - e) (order \\<G>) mod order \\<G>)))}\""], ["", "definition \"valid_pub = carrier \\<G>\""], ["", "end"], ["", "locale okamoto = okamoto_base + cyclic_group \\<G>\nbegin"], ["", "lemma g'_in_carrier [simp]: \"g' \\<in> carrier \\<G>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g' \\<in> carrier \\<G>", "using g'_def"], ["proof (prove)\nusing this:\n  g' = \\<^bold>g [^] x\n\ngoal (1 subgoal):\n 1. g' \\<in> carrier \\<G>", "by auto"], ["", "sublocale \\<Sigma>_protocols_base: \\<Sigma>_protocols_base init response check R S2 ss_adversary challenge_space valid_pub"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sigma>_protocols_base R valid_pub", "by unfold_locales (auto simp add: R_def valid_pub_def)"], ["", "lemma \"\\<Sigma>_protocols_base.R h w c = R2 h w c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.\\<Sigma>_protocols_base.R h w c = R2 h w c", "by(simp add: \\<Sigma>_protocols_base.R_def R2_def; simp add: init_def split_def response_def)"], ["", "lemma completeness: \n  shows \"\\<Sigma>_protocols_base.completeness\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.\\<Sigma>_protocols_base.completeness", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. local.\\<Sigma>_protocols_base.completeness", "have \"(\\<^bold>g [^] ((e * fst w' + y) mod order \\<G>) \\<otimes> g' [^] ((e * snd w' + ya) mod order \\<G>) = \\<^bold>g [^] y \\<otimes> g' [^] ya \\<otimes> (\\<^bold>g [^] fst w' \\<otimes> g' [^] snd w') [^] e)\" \n    for e y ya :: nat and w' :: \"nat \\<times> nat\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<^bold>g [^] ((e * fst w' + y) mod order \\<G>) \\<otimes>\n    g' [^] ((e * snd w' + ya) mod order \\<G>) =\n    \\<^bold>g [^] y \\<otimes> g' [^] ya \\<otimes>\n    (\\<^bold>g [^] fst w' \\<otimes> g' [^] snd w') [^] e", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<^bold>g [^] ((e * fst w' + y) mod order \\<G>) \\<otimes>\n    g' [^] ((e * snd w' + ya) mod order \\<G>) =\n    \\<^bold>g [^] y \\<otimes> g' [^] ya \\<otimes>\n    (\\<^bold>g [^] fst w' \\<otimes> g' [^] snd w') [^] e", "have \"\\<^bold>g [^] ((e * fst w' + y) mod order \\<G>) \\<otimes> g' [^] ((e * snd w' + ya) mod order \\<G>) = \\<^bold>g [^] ((y + e * fst w')) \\<otimes> g' [^] ((ya + e * snd w'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<^bold>g [^] ((e * fst w' + y) mod order \\<G>) \\<otimes>\n    g' [^] ((e * snd w' + ya) mod order \\<G>) =\n    \\<^bold>g [^] (y + e * fst w') \\<otimes> g' [^] (ya + e * snd w')", "by (simp add: cyclic_group.pow_carrier_mod cyclic_group_axioms g'_def add.commute pow_generator_mod)"], ["proof (state)\nthis:\n  \\<^bold>g [^] ((e * fst w' + y) mod order \\<G>) \\<otimes>\n  g' [^] ((e * snd w' + ya) mod order \\<G>) =\n  \\<^bold>g [^] (y + e * fst w') \\<otimes> g' [^] (ya + e * snd w')\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^] ((e * fst w' + y) mod order \\<G>) \\<otimes>\n    g' [^] ((e * snd w' + ya) mod order \\<G>) =\n    \\<^bold>g [^] y \\<otimes> g' [^] ya \\<otimes>\n    (\\<^bold>g [^] fst w' \\<otimes> g' [^] snd w') [^] e", "also"], ["proof (state)\nthis:\n  \\<^bold>g [^] ((e * fst w' + y) mod order \\<G>) \\<otimes>\n  g' [^] ((e * snd w' + ya) mod order \\<G>) =\n  \\<^bold>g [^] (y + e * fst w') \\<otimes> g' [^] (ya + e * snd w')\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^] ((e * fst w' + y) mod order \\<G>) \\<otimes>\n    g' [^] ((e * snd w' + ya) mod order \\<G>) =\n    \\<^bold>g [^] y \\<otimes> g' [^] ya \\<otimes>\n    (\\<^bold>g [^] fst w' \\<otimes> g' [^] snd w') [^] e", "have \"... = \\<^bold>g [^] y \\<otimes> \\<^bold>g [^] (e * fst w') \\<otimes> g' [^] ya \\<otimes> g' [^] (e * snd w')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<^bold>g [^] (y + e * fst w') \\<otimes> g' [^] (ya + e * snd w') =\n    \\<^bold>g [^] y \\<otimes> \\<^bold>g [^] (e * fst w') \\<otimes>\n    g' [^] ya \\<otimes>\n    g' [^] (e * snd w')", "by (simp add: g'_def m_assoc nat_pow_mult)"], ["proof (state)\nthis:\n  \\<^bold>g [^] (y + e * fst w') \\<otimes> g' [^] (ya + e * snd w') =\n  \\<^bold>g [^] y \\<otimes> \\<^bold>g [^] (e * fst w') \\<otimes>\n  g' [^] ya \\<otimes>\n  g' [^] (e * snd w')\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^] ((e * fst w' + y) mod order \\<G>) \\<otimes>\n    g' [^] ((e * snd w' + ya) mod order \\<G>) =\n    \\<^bold>g [^] y \\<otimes> g' [^] ya \\<otimes>\n    (\\<^bold>g [^] fst w' \\<otimes> g' [^] snd w') [^] e", "also"], ["proof (state)\nthis:\n  \\<^bold>g [^] (y + e * fst w') \\<otimes> g' [^] (ya + e * snd w') =\n  \\<^bold>g [^] y \\<otimes> \\<^bold>g [^] (e * fst w') \\<otimes>\n  g' [^] ya \\<otimes>\n  g' [^] (e * snd w')\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^] ((e * fst w' + y) mod order \\<G>) \\<otimes>\n    g' [^] ((e * snd w' + ya) mod order \\<G>) =\n    \\<^bold>g [^] y \\<otimes> g' [^] ya \\<otimes>\n    (\\<^bold>g [^] fst w' \\<otimes> g' [^] snd w') [^] e", "have \"... = \\<^bold>g [^] y \\<otimes> g' [^] ya \\<otimes> \\<^bold>g [^] (e * fst w') \\<otimes> g' [^] (e * snd w')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<^bold>g [^] y \\<otimes> \\<^bold>g [^] (e * fst w') \\<otimes>\n    g' [^] ya \\<otimes>\n    g' [^] (e * snd w') =\n    \\<^bold>g [^] y \\<otimes> g' [^] ya \\<otimes>\n    \\<^bold>g [^] (e * fst w') \\<otimes>\n    g' [^] (e * snd w')", "by (smt add.commute g'_def generator_closed m_assoc nat_pow_closed nat_pow_mult nat_pow_pow)"], ["proof (state)\nthis:\n  \\<^bold>g [^] y \\<otimes> \\<^bold>g [^] (e * fst w') \\<otimes>\n  g' [^] ya \\<otimes>\n  g' [^] (e * snd w') =\n  \\<^bold>g [^] y \\<otimes> g' [^] ya \\<otimes>\n  \\<^bold>g [^] (e * fst w') \\<otimes>\n  g' [^] (e * snd w')\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^] ((e * fst w' + y) mod order \\<G>) \\<otimes>\n    g' [^] ((e * snd w' + ya) mod order \\<G>) =\n    \\<^bold>g [^] y \\<otimes> g' [^] ya \\<otimes>\n    (\\<^bold>g [^] fst w' \\<otimes> g' [^] snd w') [^] e", "also"], ["proof (state)\nthis:\n  \\<^bold>g [^] y \\<otimes> \\<^bold>g [^] (e * fst w') \\<otimes>\n  g' [^] ya \\<otimes>\n  g' [^] (e * snd w') =\n  \\<^bold>g [^] y \\<otimes> g' [^] ya \\<otimes>\n  \\<^bold>g [^] (e * fst w') \\<otimes>\n  g' [^] (e * snd w')\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^] ((e * fst w' + y) mod order \\<G>) \\<otimes>\n    g' [^] ((e * snd w' + ya) mod order \\<G>) =\n    \\<^bold>g [^] y \\<otimes> g' [^] ya \\<otimes>\n    (\\<^bold>g [^] fst w' \\<otimes> g' [^] snd w') [^] e", "have \"... = \\<^bold>g [^] y \\<otimes> g' [^] ya \\<otimes> ((\\<^bold>g [^] fst w') [^] e \\<otimes> (g' [^] snd w') [^] e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<^bold>g [^] y \\<otimes> g' [^] ya \\<otimes>\n    \\<^bold>g [^] (e * fst w') \\<otimes>\n    g' [^] (e * snd w') =\n    \\<^bold>g [^] y \\<otimes> g' [^] ya \\<otimes>\n    ((\\<^bold>g [^] fst w') [^] e \\<otimes> (g' [^] snd w') [^] e)", "by (simp add: m_assoc mult.commute nat_pow_pow)"], ["proof (state)\nthis:\n  \\<^bold>g [^] y \\<otimes> g' [^] ya \\<otimes>\n  \\<^bold>g [^] (e * fst w') \\<otimes>\n  g' [^] (e * snd w') =\n  \\<^bold>g [^] y \\<otimes> g' [^] ya \\<otimes>\n  ((\\<^bold>g [^] fst w') [^] e \\<otimes> (g' [^] snd w') [^] e)\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^] ((e * fst w' + y) mod order \\<G>) \\<otimes>\n    g' [^] ((e * snd w' + ya) mod order \\<G>) =\n    \\<^bold>g [^] y \\<otimes> g' [^] ya \\<otimes>\n    (\\<^bold>g [^] fst w' \\<otimes> g' [^] snd w') [^] e", "also"], ["proof (state)\nthis:\n  \\<^bold>g [^] y \\<otimes> g' [^] ya \\<otimes>\n  \\<^bold>g [^] (e * fst w') \\<otimes>\n  g' [^] (e * snd w') =\n  \\<^bold>g [^] y \\<otimes> g' [^] ya \\<otimes>\n  ((\\<^bold>g [^] fst w') [^] e \\<otimes> (g' [^] snd w') [^] e)\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^] ((e * fst w' + y) mod order \\<G>) \\<otimes>\n    g' [^] ((e * snd w' + ya) mod order \\<G>) =\n    \\<^bold>g [^] y \\<otimes> g' [^] ya \\<otimes>\n    (\\<^bold>g [^] fst w' \\<otimes> g' [^] snd w') [^] e", "have \"... =  \\<^bold>g [^] y \\<otimes> g' [^] ya \\<otimes> ((\\<^bold>g [^] fst w' \\<otimes> g' [^] snd w') [^] e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<^bold>g [^] y \\<otimes> g' [^] ya \\<otimes>\n    ((\\<^bold>g [^] fst w') [^] e \\<otimes> (g' [^] snd w') [^] e) =\n    \\<^bold>g [^] y \\<otimes> g' [^] ya \\<otimes>\n    (\\<^bold>g [^] fst w' \\<otimes> g' [^] snd w') [^] e", "by (smt power_distrib g'_def generator_closed mult.commute nat_pow_closed nat_pow_mult nat_pow_pow)"], ["proof (state)\nthis:\n  \\<^bold>g [^] y \\<otimes> g' [^] ya \\<otimes>\n  ((\\<^bold>g [^] fst w') [^] e \\<otimes> (g' [^] snd w') [^] e) =\n  \\<^bold>g [^] y \\<otimes> g' [^] ya \\<otimes>\n  (\\<^bold>g [^] fst w' \\<otimes> g' [^] snd w') [^] e\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^] ((e * fst w' + y) mod order \\<G>) \\<otimes>\n    g' [^] ((e * snd w' + ya) mod order \\<G>) =\n    \\<^bold>g [^] y \\<otimes> g' [^] ya \\<otimes>\n    (\\<^bold>g [^] fst w' \\<otimes> g' [^] snd w') [^] e", "ultimately"], ["proof (chain)\npicking this:\n  \\<^bold>g [^] ((e * fst w' + y) mod order \\<G>) \\<otimes>\n  g' [^] ((e * snd w' + ya) mod order \\<G>) =\n  \\<^bold>g [^] y \\<otimes> g' [^] ya \\<otimes>\n  ((\\<^bold>g [^] fst w') [^] e \\<otimes> (g' [^] snd w') [^] e)\n  \\<^bold>g [^] y \\<otimes> g' [^] ya \\<otimes>\n  ((\\<^bold>g [^] fst w') [^] e \\<otimes> (g' [^] snd w') [^] e) =\n  \\<^bold>g [^] y \\<otimes> g' [^] ya \\<otimes>\n  (\\<^bold>g [^] fst w' \\<otimes> g' [^] snd w') [^] e", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<^bold>g [^] ((e * fst w' + y) mod order \\<G>) \\<otimes>\n  g' [^] ((e * snd w' + ya) mod order \\<G>) =\n  \\<^bold>g [^] y \\<otimes> g' [^] ya \\<otimes>\n  ((\\<^bold>g [^] fst w') [^] e \\<otimes> (g' [^] snd w') [^] e)\n  \\<^bold>g [^] y \\<otimes> g' [^] ya \\<otimes>\n  ((\\<^bold>g [^] fst w') [^] e \\<otimes> (g' [^] snd w') [^] e) =\n  \\<^bold>g [^] y \\<otimes> g' [^] ya \\<otimes>\n  (\\<^bold>g [^] fst w' \\<otimes> g' [^] snd w') [^] e\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^] ((e * fst w' + y) mod order \\<G>) \\<otimes>\n    g' [^] ((e * snd w' + ya) mod order \\<G>) =\n    \\<^bold>g [^] y \\<otimes> g' [^] ya \\<otimes>\n    (\\<^bold>g [^] fst w' \\<otimes> g' [^] snd w') [^] e", "by simp"], ["proof (state)\nthis:\n  \\<^bold>g [^] ((e * fst w' + y) mod order \\<G>) \\<otimes>\n  g' [^] ((e * snd w' + ya) mod order \\<G>) =\n  \\<^bold>g [^] y \\<otimes> g' [^] ya \\<otimes>\n  (\\<^bold>g [^] fst w' \\<otimes> g' [^] snd w') [^] e\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<^bold>g [^] ((?e * fst ?w' + ?y) mod order \\<G>) \\<otimes>\n  g' [^] ((?e * snd ?w' + ?ya) mod order \\<G>) =\n  \\<^bold>g [^] ?y \\<otimes> g' [^] ?ya \\<otimes>\n  (\\<^bold>g [^] fst ?w' \\<otimes> g' [^] snd ?w') [^] ?e\n\ngoal (1 subgoal):\n 1. local.\\<Sigma>_protocols_base.completeness", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<^bold>g [^] ((?e * fst ?w' + ?y) mod order \\<G>) \\<otimes>\n  g' [^] ((?e * snd ?w' + ?ya) mod order \\<G>) =\n  \\<^bold>g [^] ?y \\<otimes> g' [^] ?ya \\<otimes>\n  (\\<^bold>g [^] fst ?w' \\<otimes> g' [^] snd ?w') [^] ?e\n\ngoal (1 subgoal):\n 1. local.\\<Sigma>_protocols_base.completeness", "unfolding \\<Sigma>_protocols_base.completeness_def \\<Sigma>_protocols_base.completeness_game_def"], ["proof (prove)\nusing this:\n  \\<^bold>g [^] ((?e * fst ?w' + ?y) mod order \\<G>) \\<otimes>\n  g' [^] ((?e * snd ?w' + ?ya) mod order \\<G>) =\n  \\<^bold>g [^] ?y \\<otimes> g' [^] ?ya \\<otimes>\n  (\\<^bold>g [^] fst ?w' \\<otimes> g' [^] snd ?w') [^] ?e\n\ngoal (1 subgoal):\n 1. \\<forall>h w e.\n       (h, w) \\<in> R \\<longrightarrow>\n       e \\<in> challenge_space \\<longrightarrow>\n       spmf\n        (init h w \\<bind>\n         (\\<lambda>(r, a).\n             response r w e \\<bind>\n             (\\<lambda>z. return_spmf (check h a e z))))\n        True =\n       1", "by(simp add: R_def challenge_space_def init_def check_def response_def split_def bind_spmf_const)"], ["proof (state)\nthis:\n  local.\\<Sigma>_protocols_base.completeness\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma hvzk_z_r:\n  assumes r1: \"r1 < order \\<G>\" \n  shows \"r1 = ((r1 + c * (x1 :: nat)) mod (order \\<G>) + order \\<G> * c * x1 - c * x1) mod (order \\<G>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r1 =\n    ((r1 + c * x1) mod order \\<G> + order \\<G> * c * x1 - c * x1) mod\n    order \\<G>", "proof(cases \"x1 = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x1 = 0 \\<Longrightarrow>\n    r1 =\n    ((r1 + c * x1) mod order \\<G> + order \\<G> * c * x1 - c * x1) mod\n    order \\<G>\n 2. x1 \\<noteq> 0 \\<Longrightarrow>\n    r1 =\n    ((r1 + c * x1) mod order \\<G> + order \\<G> * c * x1 - c * x1) mod\n    order \\<G>", "case True"], ["proof (state)\nthis:\n  x1 = 0\n\ngoal (2 subgoals):\n 1. x1 = 0 \\<Longrightarrow>\n    r1 =\n    ((r1 + c * x1) mod order \\<G> + order \\<G> * c * x1 - c * x1) mod\n    order \\<G>\n 2. x1 \\<noteq> 0 \\<Longrightarrow>\n    r1 =\n    ((r1 + c * x1) mod order \\<G> + order \\<G> * c * x1 - c * x1) mod\n    order \\<G>", "then"], ["proof (chain)\npicking this:\n  x1 = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  x1 = 0\n\ngoal (1 subgoal):\n 1. r1 =\n    ((r1 + c * x1) mod order \\<G> + order \\<G> * c * x1 - c * x1) mod\n    order \\<G>", "using r1"], ["proof (prove)\nusing this:\n  x1 = 0\n  r1 < order \\<G>\n\ngoal (1 subgoal):\n 1. r1 =\n    ((r1 + c * x1) mod order \\<G> + order \\<G> * c * x1 - c * x1) mod\n    order \\<G>", "by simp"], ["proof (state)\nthis:\n  r1 =\n  ((r1 + c * x1) mod order \\<G> + order \\<G> * c * x1 - c * x1) mod\n  order \\<G>\n\ngoal (1 subgoal):\n 1. x1 \\<noteq> 0 \\<Longrightarrow>\n    r1 =\n    ((r1 + c * x1) mod order \\<G> + order \\<G> * c * x1 - c * x1) mod\n    order \\<G>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x1 \\<noteq> 0 \\<Longrightarrow>\n    r1 =\n    ((r1 + c * x1) mod order \\<G> + order \\<G> * c * x1 - c * x1) mod\n    order \\<G>", "case x1_neq_0: False"], ["proof (state)\nthis:\n  x1 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. x1 \\<noteq> 0 \\<Longrightarrow>\n    r1 =\n    ((r1 + c * x1) mod order \\<G> + order \\<G> * c * x1 - c * x1) mod\n    order \\<G>", "have z1_eq: \"[(r1 + c * x1) mod (order \\<G>) + order \\<G> * c * x1 = r1 + c * x1] (mod (order \\<G>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [(r1 + c * x1) mod order \\<G> +\n     order \\<G> * c * x1 = r1 + c * x1] (mod order \\<G>)", "using gr_implies_not_zero order_gt_1"], ["proof (prove)\nusing this:\n  ?m < ?n \\<Longrightarrow> ?n \\<noteq> (0::?'a)\n  1 < order \\<G>\n\ngoal (1 subgoal):\n 1. [(r1 + c * x1) mod order \\<G> +\n     order \\<G> * c * x1 = r1 + c * x1] (mod order \\<G>)", "by (simp add: Groups.mult_ac(1) cong_def)"], ["proof (state)\nthis:\n  [(r1 + c * x1) mod order \\<G> +\n   order \\<G> * c * x1 = r1 + c * x1] (mod order \\<G>)\n\ngoal (1 subgoal):\n 1. x1 \\<noteq> 0 \\<Longrightarrow>\n    r1 =\n    ((r1 + c * x1) mod order \\<G> + order \\<G> * c * x1 - c * x1) mod\n    order \\<G>", "hence \"[(r1 + c * x1) mod (order \\<G>) + order \\<G> * c * x1 - c * x1 = r1] (mod (order \\<G>))\""], ["proof (prove)\nusing this:\n  [(r1 + c * x1) mod order \\<G> +\n   order \\<G> * c * x1 = r1 + c * x1] (mod order \\<G>)\n\ngoal (1 subgoal):\n 1. [(r1 + c * x1) mod order \\<G> + order \\<G> * c * x1 -\n     c * x1 = r1] (mod order \\<G>)", "proof(cases \"c = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>[(r1 + c * x1) mod order \\<G> +\n              order \\<G> * c * x1 = r1 + c * x1] (mod order \\<G>);\n     c = 0\\<rbrakk>\n    \\<Longrightarrow> [(r1 + c * x1) mod order \\<G> + order \\<G> * c * x1 -\n                       c * x1 = r1] (mod order \\<G>)\n 2. \\<lbrakk>[(r1 + c * x1) mod order \\<G> +\n              order \\<G> * c * x1 = r1 + c * x1] (mod order \\<G>);\n     c \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> [(r1 + c * x1) mod order \\<G> + order \\<G> * c * x1 -\n                       c * x1 = r1] (mod order \\<G>)", "case True"], ["proof (state)\nthis:\n  c = 0\n\ngoal (2 subgoals):\n 1. \\<lbrakk>[(r1 + c * x1) mod order \\<G> +\n              order \\<G> * c * x1 = r1 + c * x1] (mod order \\<G>);\n     c = 0\\<rbrakk>\n    \\<Longrightarrow> [(r1 + c * x1) mod order \\<G> + order \\<G> * c * x1 -\n                       c * x1 = r1] (mod order \\<G>)\n 2. \\<lbrakk>[(r1 + c * x1) mod order \\<G> +\n              order \\<G> * c * x1 = r1 + c * x1] (mod order \\<G>);\n     c \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> [(r1 + c * x1) mod order \\<G> + order \\<G> * c * x1 -\n                       c * x1 = r1] (mod order \\<G>)", "then"], ["proof (chain)\npicking this:\n  c = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  c = 0\n\ngoal (1 subgoal):\n 1. [(r1 + c * x1) mod order \\<G> + order \\<G> * c * x1 -\n     c * x1 = r1] (mod order \\<G>)", "using z1_eq"], ["proof (prove)\nusing this:\n  c = 0\n  [(r1 + c * x1) mod order \\<G> +\n   order \\<G> * c * x1 = r1 + c * x1] (mod order \\<G>)\n\ngoal (1 subgoal):\n 1. [(r1 + c * x1) mod order \\<G> + order \\<G> * c * x1 -\n     c * x1 = r1] (mod order \\<G>)", "by auto"], ["proof (state)\nthis:\n  [(r1 + c * x1) mod order \\<G> + order \\<G> * c * x1 -\n   c * x1 = r1] (mod order \\<G>)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>[(r1 + c * x1) mod order \\<G> +\n              order \\<G> * c * x1 = r1 + c * x1] (mod order \\<G>);\n     c \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> [(r1 + c * x1) mod order \\<G> + order \\<G> * c * x1 -\n                       c * x1 = r1] (mod order \\<G>)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>[(r1 + c * x1) mod order \\<G> +\n              order \\<G> * c * x1 = r1 + c * x1] (mod order \\<G>);\n     c \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> [(r1 + c * x1) mod order \\<G> + order \\<G> * c * x1 -\n                       c * x1 = r1] (mod order \\<G>)", "case False"], ["proof (state)\nthis:\n  c \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>[(r1 + c * x1) mod order \\<G> +\n              order \\<G> * c * x1 = r1 + c * x1] (mod order \\<G>);\n     c \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> [(r1 + c * x1) mod order \\<G> + order \\<G> * c * x1 -\n                       c * x1 = r1] (mod order \\<G>)", "have \"order \\<G> * c * x1 - c * x1 > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < order \\<G> * c * x1 - c * x1", "using x1_neq_0 False"], ["proof (prove)\nusing this:\n  x1 \\<noteq> 0\n  c \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 < order \\<G> * c * x1 - c * x1", "using prime_gt_1_nat prime_order"], ["proof (prove)\nusing this:\n  x1 \\<noteq> 0\n  c \\<noteq> 0\n  prime ?p \\<Longrightarrow> 1 < ?p\n  prime (order \\<G>)\n\ngoal (1 subgoal):\n 1. 0 < order \\<G> * c * x1 - c * x1", "by auto"], ["proof (state)\nthis:\n  0 < order \\<G> * c * x1 - c * x1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>[(r1 + c * x1) mod order \\<G> +\n              order \\<G> * c * x1 = r1 + c * x1] (mod order \\<G>);\n     c \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> [(r1 + c * x1) mod order \\<G> + order \\<G> * c * x1 -\n                       c * x1 = r1] (mod order \\<G>)", "thus ?thesis"], ["proof (prove)\nusing this:\n  0 < order \\<G> * c * x1 - c * x1\n\ngoal (1 subgoal):\n 1. [(r1 + c * x1) mod order \\<G> + order \\<G> * c * x1 -\n     c * x1 = r1] (mod order \\<G>)", "by (smt Groups.add_ac(2) add_diff_inverse_nat cong_add_lcancel_nat diff_is_0_eq le_simps(1) neq0_conv trans_less_add2 z1_eq zero_less_diff)"], ["proof (state)\nthis:\n  [(r1 + c * x1) mod order \\<G> + order \\<G> * c * x1 -\n   c * x1 = r1] (mod order \\<G>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  [(r1 + c * x1) mod order \\<G> + order \\<G> * c * x1 -\n   c * x1 = r1] (mod order \\<G>)\n\ngoal (1 subgoal):\n 1. x1 \\<noteq> 0 \\<Longrightarrow>\n    r1 =\n    ((r1 + c * x1) mod order \\<G> + order \\<G> * c * x1 - c * x1) mod\n    order \\<G>", "thus ?thesis"], ["proof (prove)\nusing this:\n  [(r1 + c * x1) mod order \\<G> + order \\<G> * c * x1 -\n   c * x1 = r1] (mod order \\<G>)\n\ngoal (1 subgoal):\n 1. r1 =\n    ((r1 + c * x1) mod order \\<G> + order \\<G> * c * x1 - c * x1) mod\n    order \\<G>", "by (simp add: r1 cong_def)"], ["proof (state)\nthis:\n  r1 =\n  ((r1 + c * x1) mod order \\<G> + order \\<G> * c * x1 - c * x1) mod\n  order \\<G>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma hvzk_z1_r1_tuple_rewrite: \n  assumes r1: \"r1 < order \\<G>\" \n  shows \"(\\<^bold>g [^] r1 \\<otimes> g' [^] r2, c, (r1 + c * x1) mod order \\<G>, (r2 + c * x2) mod order \\<G>) = \n              (\\<^bold>g [^] (((r1 + c * x1) mod order \\<G> + order \\<G> * c * x1 - c * x1) mod order \\<G>)  \n                  \\<otimes> g' [^] r2, c, (r1 + c * x1) mod order \\<G>, (r2 + c * x2) mod order \\<G>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<^bold>g [^] r1 \\<otimes> g' [^] r2, c, (r1 + c * x1) mod order \\<G>,\n     (r2 + c * x2) mod order \\<G>) =\n    (\\<^bold>g [^]\n     (((r1 + c * x1) mod order \\<G> + order \\<G> * c * x1 - c * x1) mod\n      order \\<G>) \\<otimes>\n     g' [^] r2,\n     c, (r1 + c * x1) mod order \\<G>, (r2 + c * x2) mod order \\<G>)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<^bold>g [^] r1 \\<otimes> g' [^] r2, c, (r1 + c * x1) mod order \\<G>,\n     (r2 + c * x2) mod order \\<G>) =\n    (\\<^bold>g [^]\n     (((r1 + c * x1) mod order \\<G> + order \\<G> * c * x1 - c * x1) mod\n      order \\<G>) \\<otimes>\n     g' [^] r2,\n     c, (r1 + c * x1) mod order \\<G>, (r2 + c * x2) mod order \\<G>)", "have \"\\<^bold>g [^] r1 = \\<^bold>g [^] (((r1 + c * x1) mod order \\<G> + order \\<G> * c * x1 - c * x1) mod order \\<G>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<^bold>g [^] r1 =\n    \\<^bold>g [^]\n    (((r1 + c * x1) mod order \\<G> + order \\<G> * c * x1 - c * x1) mod\n     order \\<G>)", "using assms hvzk_z_r"], ["proof (prove)\nusing this:\n  r1 < order \\<G>\n  ?r1.0 < order \\<G> \\<Longrightarrow>\n  ?r1.0 =\n  ((?r1.0 + ?c * ?x1.0) mod order \\<G> + order \\<G> * ?c * ?x1.0 -\n   ?c * ?x1.0) mod\n  order \\<G>\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^] r1 =\n    \\<^bold>g [^]\n    (((r1 + c * x1) mod order \\<G> + order \\<G> * c * x1 - c * x1) mod\n     order \\<G>)", "by simp"], ["proof (state)\nthis:\n  \\<^bold>g [^] r1 =\n  \\<^bold>g [^]\n  (((r1 + c * x1) mod order \\<G> + order \\<G> * c * x1 - c * x1) mod\n   order \\<G>)\n\ngoal (1 subgoal):\n 1. (\\<^bold>g [^] r1 \\<otimes> g' [^] r2, c, (r1 + c * x1) mod order \\<G>,\n     (r2 + c * x2) mod order \\<G>) =\n    (\\<^bold>g [^]\n     (((r1 + c * x1) mod order \\<G> + order \\<G> * c * x1 - c * x1) mod\n      order \\<G>) \\<otimes>\n     g' [^] r2,\n     c, (r1 + c * x1) mod order \\<G>, (r2 + c * x2) mod order \\<G>)", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<^bold>g [^] r1 =\n  \\<^bold>g [^]\n  (((r1 + c * x1) mod order \\<G> + order \\<G> * c * x1 - c * x1) mod\n   order \\<G>)\n\ngoal (1 subgoal):\n 1. (\\<^bold>g [^] r1 \\<otimes> g' [^] r2, c, (r1 + c * x1) mod order \\<G>,\n     (r2 + c * x2) mod order \\<G>) =\n    (\\<^bold>g [^]\n     (((r1 + c * x1) mod order \\<G> + order \\<G> * c * x1 - c * x1) mod\n      order \\<G>) \\<otimes>\n     g' [^] r2,\n     c, (r1 + c * x1) mod order \\<G>, (r2 + c * x2) mod order \\<G>)", "by argo"], ["proof (state)\nthis:\n  (\\<^bold>g [^] r1 \\<otimes> g' [^] r2, c, (r1 + c * x1) mod order \\<G>,\n   (r2 + c * x2) mod order \\<G>) =\n  (\\<^bold>g [^]\n   (((r1 + c * x1) mod order \\<G> + order \\<G> * c * x1 - c * x1) mod\n    order \\<G>) \\<otimes>\n   g' [^] r2,\n   c, (r1 + c * x1) mod order \\<G>, (r2 + c * x2) mod order \\<G>)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma hvzk_z2_r2_tuple_rewrite: \n  assumes \"xb < order \\<G>\" \n  shows \"(\\<^bold>g [^] (((x' + xa * x1) mod order \\<G> + order \\<G> * xa * x1 - xa * x1) mod order \\<G>) \n            \\<otimes> g' [^] xb, xa, (x' + xa * x1) mod order \\<G>, (xb + xa * x2) mod order \\<G>) =\n               (\\<^bold>g [^] (((x' + xa * x1) mod order \\<G> + order \\<G> * xa * x1 - xa * x1) mod order \\<G>) \n                \\<otimes> g' [^] (((xb + xa * x2) mod order \\<G> + order \\<G> * xa * x2 - xa * x2) mod order \\<G>), xa, (x' + xa * x1) mod order \\<G>, (xb + xa * x2) mod order \\<G>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<^bold>g [^]\n     (((x' + xa * x1) mod order \\<G> + order \\<G> * xa * x1 - xa * x1) mod\n      order \\<G>) \\<otimes>\n     g' [^] xb,\n     xa, (x' + xa * x1) mod order \\<G>, (xb + xa * x2) mod order \\<G>) =\n    (\\<^bold>g [^]\n     (((x' + xa * x1) mod order \\<G> + order \\<G> * xa * x1 - xa * x1) mod\n      order \\<G>) \\<otimes>\n     g' [^]\n     (((xb + xa * x2) mod order \\<G> + order \\<G> * xa * x2 - xa * x2) mod\n      order \\<G>),\n     xa, (x' + xa * x1) mod order \\<G>, (xb + xa * x2) mod order \\<G>)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<^bold>g [^]\n     (((x' + xa * x1) mod order \\<G> + order \\<G> * xa * x1 - xa * x1) mod\n      order \\<G>) \\<otimes>\n     g' [^] xb,\n     xa, (x' + xa * x1) mod order \\<G>, (xb + xa * x2) mod order \\<G>) =\n    (\\<^bold>g [^]\n     (((x' + xa * x1) mod order \\<G> + order \\<G> * xa * x1 - xa * x1) mod\n      order \\<G>) \\<otimes>\n     g' [^]\n     (((xb + xa * x2) mod order \\<G> + order \\<G> * xa * x2 - xa * x2) mod\n      order \\<G>),\n     xa, (x' + xa * x1) mod order \\<G>, (xb + xa * x2) mod order \\<G>)", "have \"g' [^] xb = g' [^] (((xb + xa * x2) mod order \\<G> + order \\<G> * xa * x2 - xa * x2) mod order \\<G>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g' [^] xb =\n    g' [^]\n    (((xb + xa * x2) mod order \\<G> + order \\<G> * xa * x2 - xa * x2) mod\n     order \\<G>)", "using hvzk_z_r assms"], ["proof (prove)\nusing this:\n  ?r1.0 < order \\<G> \\<Longrightarrow>\n  ?r1.0 =\n  ((?r1.0 + ?c * ?x1.0) mod order \\<G> + order \\<G> * ?c * ?x1.0 -\n   ?c * ?x1.0) mod\n  order \\<G>\n  xb < order \\<G>\n\ngoal (1 subgoal):\n 1. g' [^] xb =\n    g' [^]\n    (((xb + xa * x2) mod order \\<G> + order \\<G> * xa * x2 - xa * x2) mod\n     order \\<G>)", "by simp"], ["proof (state)\nthis:\n  g' [^] xb =\n  g' [^]\n  (((xb + xa * x2) mod order \\<G> + order \\<G> * xa * x2 - xa * x2) mod\n   order \\<G>)\n\ngoal (1 subgoal):\n 1. (\\<^bold>g [^]\n     (((x' + xa * x1) mod order \\<G> + order \\<G> * xa * x1 - xa * x1) mod\n      order \\<G>) \\<otimes>\n     g' [^] xb,\n     xa, (x' + xa * x1) mod order \\<G>, (xb + xa * x2) mod order \\<G>) =\n    (\\<^bold>g [^]\n     (((x' + xa * x1) mod order \\<G> + order \\<G> * xa * x1 - xa * x1) mod\n      order \\<G>) \\<otimes>\n     g' [^]\n     (((xb + xa * x2) mod order \\<G> + order \\<G> * xa * x2 - xa * x2) mod\n      order \\<G>),\n     xa, (x' + xa * x1) mod order \\<G>, (xb + xa * x2) mod order \\<G>)", "thus ?thesis"], ["proof (prove)\nusing this:\n  g' [^] xb =\n  g' [^]\n  (((xb + xa * x2) mod order \\<G> + order \\<G> * xa * x2 - xa * x2) mod\n   order \\<G>)\n\ngoal (1 subgoal):\n 1. (\\<^bold>g [^]\n     (((x' + xa * x1) mod order \\<G> + order \\<G> * xa * x1 - xa * x1) mod\n      order \\<G>) \\<otimes>\n     g' [^] xb,\n     xa, (x' + xa * x1) mod order \\<G>, (xb + xa * x2) mod order \\<G>) =\n    (\\<^bold>g [^]\n     (((x' + xa * x1) mod order \\<G> + order \\<G> * xa * x1 - xa * x1) mod\n      order \\<G>) \\<otimes>\n     g' [^]\n     (((xb + xa * x2) mod order \\<G> + order \\<G> * xa * x2 - xa * x2) mod\n      order \\<G>),\n     xa, (x' + xa * x1) mod order \\<G>, (xb + xa * x2) mod order \\<G>)", "by argo"], ["proof (state)\nthis:\n  (\\<^bold>g [^]\n   (((x' + xa * x1) mod order \\<G> + order \\<G> * xa * x1 - xa * x1) mod\n    order \\<G>) \\<otimes>\n   g' [^] xb,\n   xa, (x' + xa * x1) mod order \\<G>, (xb + xa * x2) mod order \\<G>) =\n  (\\<^bold>g [^]\n   (((x' + xa * x1) mod order \\<G> + order \\<G> * xa * x1 - xa * x1) mod\n    order \\<G>) \\<otimes>\n   g' [^]\n   (((xb + xa * x2) mod order \\<G> + order \\<G> * xa * x2 - xa * x2) mod\n    order \\<G>),\n   xa, (x' + xa * x1) mod order \\<G>, (xb + xa * x2) mod order \\<G>)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma hvzk_sim_inverse_rewrite: \n  assumes h: \"h =  \\<^bold>g [^] (x1 :: nat) \\<otimes> g' [^] (x2 :: nat)\"\n  shows \"\\<^bold>g [^] (((z1::nat) + order \\<G> * c * x1 - c * x1) mod (order \\<G>)) \n            \\<otimes> g' [^] (((z2::nat) + order \\<G> * c * x2 - c * x2) mod (order \\<G>))\n                = (\\<^bold>g [^] z1 \\<otimes> g' [^] z2) \\<otimes> (inv h [^] c)\"\n(is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<^bold>g [^]\n    ((z1 + order \\<G> * c * x1 - c * x1) mod order \\<G>) \\<otimes>\n    g' [^] ((z2 + order \\<G> * c * x2 - c * x2) mod order \\<G>) =\n    \\<^bold>g [^] z1 \\<otimes> g' [^] z2 \\<otimes> inv h [^] c", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<^bold>g [^]\n    ((z1 + order \\<G> * c * x1 - c * x1) mod order \\<G>) \\<otimes>\n    g' [^] ((z2 + order \\<G> * c * x2 - c * x2) mod order \\<G>) =\n    \\<^bold>g [^] z1 \\<otimes> g' [^] z2 \\<otimes> inv h [^] c", "have in_carrier1: \"(g' [^] x2) [^] c \\<in> carrier \\<G>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (g' [^] x2) [^] c \\<in> carrier \\<G>", "by simp"], ["proof (state)\nthis:\n  (g' [^] x2) [^] c \\<in> carrier \\<G>\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^]\n    ((z1 + order \\<G> * c * x1 - c * x1) mod order \\<G>) \\<otimes>\n    g' [^] ((z2 + order \\<G> * c * x2 - c * x2) mod order \\<G>) =\n    \\<^bold>g [^] z1 \\<otimes> g' [^] z2 \\<otimes> inv h [^] c", "have in_carrier2: \"(\\<^bold>g [^] x1) [^] c \\<in> carrier \\<G>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<^bold>g [^] x1) [^] c \\<in> carrier \\<G>", "by simp"], ["proof (state)\nthis:\n  (\\<^bold>g [^] x1) [^] c \\<in> carrier \\<G>\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^]\n    ((z1 + order \\<G> * c * x1 - c * x1) mod order \\<G>) \\<otimes>\n    g' [^] ((z2 + order \\<G> * c * x2 - c * x2) mod order \\<G>) =\n    \\<^bold>g [^] z1 \\<otimes> g' [^] z2 \\<otimes> inv h [^] c", "have pow_distrib1: \"order \\<G> * c * x1 - c * x1 = (order \\<G> - 1) * c * x1\" \n    and pow_distrib2: \"order \\<G> * c * x2 - c * x2 = (order \\<G> - 1) * c * x2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order \\<G> * c * x1 - c * x1 = (order \\<G> - 1) * c * x1 &&&\n    order \\<G> * c * x2 - c * x2 = (order \\<G> - 1) * c * x2", "using assms"], ["proof (prove)\nusing this:\n  h = \\<^bold>g [^] x1 \\<otimes> g' [^] x2\n\ngoal (1 subgoal):\n 1. order \\<G> * c * x1 - c * x1 = (order \\<G> - 1) * c * x1 &&&\n    order \\<G> * c * x2 - c * x2 = (order \\<G> - 1) * c * x2", "by (simp add: diff_mult_distrib)+"], ["proof (state)\nthis:\n  order \\<G> * c * x1 - c * x1 = (order \\<G> - 1) * c * x1\n  order \\<G> * c * x2 - c * x2 = (order \\<G> - 1) * c * x2\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^]\n    ((z1 + order \\<G> * c * x1 - c * x1) mod order \\<G>) \\<otimes>\n    g' [^] ((z2 + order \\<G> * c * x2 - c * x2) mod order \\<G>) =\n    \\<^bold>g [^] z1 \\<otimes> g' [^] z2 \\<otimes> inv h [^] c", "have \"?lhs = \\<^bold>g [^] (z1 + order \\<G> * c * x1 - c * x1) \\<otimes> g' [^] (z2 + order \\<G> * c  * x2 - c * x2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<^bold>g [^]\n    ((z1 + order \\<G> * c * x1 - c * x1) mod order \\<G>) \\<otimes>\n    g' [^] ((z2 + order \\<G> * c * x2 - c * x2) mod order \\<G>) =\n    \\<^bold>g [^] (z1 + order \\<G> * c * x1 - c * x1) \\<otimes>\n    g' [^] (z2 + order \\<G> * c * x2 - c * x2)", "by (simp add: pow_carrier_mod)"], ["proof (state)\nthis:\n  \\<^bold>g [^]\n  ((z1 + order \\<G> * c * x1 - c * x1) mod order \\<G>) \\<otimes>\n  g' [^] ((z2 + order \\<G> * c * x2 - c * x2) mod order \\<G>) =\n  \\<^bold>g [^] (z1 + order \\<G> * c * x1 - c * x1) \\<otimes>\n  g' [^] (z2 + order \\<G> * c * x2 - c * x2)\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^]\n    ((z1 + order \\<G> * c * x1 - c * x1) mod order \\<G>) \\<otimes>\n    g' [^] ((z2 + order \\<G> * c * x2 - c * x2) mod order \\<G>) =\n    \\<^bold>g [^] z1 \\<otimes> g' [^] z2 \\<otimes> inv h [^] c", "also"], ["proof (state)\nthis:\n  \\<^bold>g [^]\n  ((z1 + order \\<G> * c * x1 - c * x1) mod order \\<G>) \\<otimes>\n  g' [^] ((z2 + order \\<G> * c * x2 - c * x2) mod order \\<G>) =\n  \\<^bold>g [^] (z1 + order \\<G> * c * x1 - c * x1) \\<otimes>\n  g' [^] (z2 + order \\<G> * c * x2 - c * x2)\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^]\n    ((z1 + order \\<G> * c * x1 - c * x1) mod order \\<G>) \\<otimes>\n    g' [^] ((z2 + order \\<G> * c * x2 - c * x2) mod order \\<G>) =\n    \\<^bold>g [^] z1 \\<otimes> g' [^] z2 \\<otimes> inv h [^] c", "have \"... = \\<^bold>g [^] (z1 + (order \\<G> * c * x1 - c * x1)) \\<otimes> g' [^] (z2 + (order \\<G> * c * x2 - c * x2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<^bold>g [^] (z1 + order \\<G> * c * x1 - c * x1) \\<otimes>\n    g' [^] (z2 + order \\<G> * c * x2 - c * x2) =\n    \\<^bold>g [^] (z1 + (order \\<G> * c * x1 - c * x1)) \\<otimes>\n    g' [^] (z2 + (order \\<G> * c * x2 - c * x2))", "using h"], ["proof (prove)\nusing this:\n  h = \\<^bold>g [^] x1 \\<otimes> g' [^] x2\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^] (z1 + order \\<G> * c * x1 - c * x1) \\<otimes>\n    g' [^] (z2 + order \\<G> * c * x2 - c * x2) =\n    \\<^bold>g [^] (z1 + (order \\<G> * c * x1 - c * x1)) \\<otimes>\n    g' [^] (z2 + (order \\<G> * c * x2 - c * x2))", "by (smt Nat.add_diff_assoc diff_zero le_simps(1) nat_0_less_mult_iff neq0_conv pow_distrib1 pow_distrib2 prime_gt_1_nat prime_order zero_less_diff)"], ["proof (state)\nthis:\n  \\<^bold>g [^] (z1 + order \\<G> * c * x1 - c * x1) \\<otimes>\n  g' [^] (z2 + order \\<G> * c * x2 - c * x2) =\n  \\<^bold>g [^] (z1 + (order \\<G> * c * x1 - c * x1)) \\<otimes>\n  g' [^] (z2 + (order \\<G> * c * x2 - c * x2))\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^]\n    ((z1 + order \\<G> * c * x1 - c * x1) mod order \\<G>) \\<otimes>\n    g' [^] ((z2 + order \\<G> * c * x2 - c * x2) mod order \\<G>) =\n    \\<^bold>g [^] z1 \\<otimes> g' [^] z2 \\<otimes> inv h [^] c", "also"], ["proof (state)\nthis:\n  \\<^bold>g [^] (z1 + order \\<G> * c * x1 - c * x1) \\<otimes>\n  g' [^] (z2 + order \\<G> * c * x2 - c * x2) =\n  \\<^bold>g [^] (z1 + (order \\<G> * c * x1 - c * x1)) \\<otimes>\n  g' [^] (z2 + (order \\<G> * c * x2 - c * x2))\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^]\n    ((z1 + order \\<G> * c * x1 - c * x1) mod order \\<G>) \\<otimes>\n    g' [^] ((z2 + order \\<G> * c * x2 - c * x2) mod order \\<G>) =\n    \\<^bold>g [^] z1 \\<otimes> g' [^] z2 \\<otimes> inv h [^] c", "have \"... =  \\<^bold>g [^] z1 \\<otimes> \\<^bold>g [^] (order \\<G> * c * x1 - c * x1) \\<otimes> g' [^] z2 \\<otimes> g' [^] (order \\<G> * c * x2 - c * x2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<^bold>g [^] (z1 + (order \\<G> * c * x1 - c * x1)) \\<otimes>\n    g' [^] (z2 + (order \\<G> * c * x2 - c * x2)) =\n    \\<^bold>g [^] z1 \\<otimes>\n    \\<^bold>g [^] (order \\<G> * c * x1 - c * x1) \\<otimes>\n    g' [^] z2 \\<otimes>\n    g' [^] (order \\<G> * c * x2 - c * x2)", "using nat_pow_mult"], ["proof (prove)\nusing this:\n  ?x \\<in> carrier \\<G> \\<Longrightarrow>\n  ?x [^] ?n \\<otimes> ?x [^] ?m = ?x [^] (?n + ?m)\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^] (z1 + (order \\<G> * c * x1 - c * x1)) \\<otimes>\n    g' [^] (z2 + (order \\<G> * c * x2 - c * x2)) =\n    \\<^bold>g [^] z1 \\<otimes>\n    \\<^bold>g [^] (order \\<G> * c * x1 - c * x1) \\<otimes>\n    g' [^] z2 \\<otimes>\n    g' [^] (order \\<G> * c * x2 - c * x2)", "by (simp add: m_assoc)"], ["proof (state)\nthis:\n  \\<^bold>g [^] (z1 + (order \\<G> * c * x1 - c * x1)) \\<otimes>\n  g' [^] (z2 + (order \\<G> * c * x2 - c * x2)) =\n  \\<^bold>g [^] z1 \\<otimes>\n  \\<^bold>g [^] (order \\<G> * c * x1 - c * x1) \\<otimes>\n  g' [^] z2 \\<otimes>\n  g' [^] (order \\<G> * c * x2 - c * x2)\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^]\n    ((z1 + order \\<G> * c * x1 - c * x1) mod order \\<G>) \\<otimes>\n    g' [^] ((z2 + order \\<G> * c * x2 - c * x2) mod order \\<G>) =\n    \\<^bold>g [^] z1 \\<otimes> g' [^] z2 \\<otimes> inv h [^] c", "also"], ["proof (state)\nthis:\n  \\<^bold>g [^] (z1 + (order \\<G> * c * x1 - c * x1)) \\<otimes>\n  g' [^] (z2 + (order \\<G> * c * x2 - c * x2)) =\n  \\<^bold>g [^] z1 \\<otimes>\n  \\<^bold>g [^] (order \\<G> * c * x1 - c * x1) \\<otimes>\n  g' [^] z2 \\<otimes>\n  g' [^] (order \\<G> * c * x2 - c * x2)\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^]\n    ((z1 + order \\<G> * c * x1 - c * x1) mod order \\<G>) \\<otimes>\n    g' [^] ((z2 + order \\<G> * c * x2 - c * x2) mod order \\<G>) =\n    \\<^bold>g [^] z1 \\<otimes> g' [^] z2 \\<otimes> inv h [^] c", "have \"... = \\<^bold>g [^] z1 \\<otimes> g' [^] z2 \\<otimes> \\<^bold>g [^] (order \\<G> * c * x1 - c * x1) \\<otimes> g' [^] (order \\<G> * c * x2 - c * x2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<^bold>g [^] z1 \\<otimes>\n    \\<^bold>g [^] (order \\<G> * c * x1 - c * x1) \\<otimes>\n    g' [^] z2 \\<otimes>\n    g' [^] (order \\<G> * c * x2 - c * x2) =\n    \\<^bold>g [^] z1 \\<otimes> g' [^] z2 \\<otimes>\n    \\<^bold>g [^] (order \\<G> * c * x1 - c * x1) \\<otimes>\n    g' [^] (order \\<G> * c * x2 - c * x2)", "by (smt add.commute g'_def generator_closed m_assoc nat_pow_closed nat_pow_mult nat_pow_pow)"], ["proof (state)\nthis:\n  \\<^bold>g [^] z1 \\<otimes>\n  \\<^bold>g [^] (order \\<G> * c * x1 - c * x1) \\<otimes>\n  g' [^] z2 \\<otimes>\n  g' [^] (order \\<G> * c * x2 - c * x2) =\n  \\<^bold>g [^] z1 \\<otimes> g' [^] z2 \\<otimes>\n  \\<^bold>g [^] (order \\<G> * c * x1 - c * x1) \\<otimes>\n  g' [^] (order \\<G> * c * x2 - c * x2)\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^]\n    ((z1 + order \\<G> * c * x1 - c * x1) mod order \\<G>) \\<otimes>\n    g' [^] ((z2 + order \\<G> * c * x2 - c * x2) mod order \\<G>) =\n    \\<^bold>g [^] z1 \\<otimes> g' [^] z2 \\<otimes> inv h [^] c", "also"], ["proof (state)\nthis:\n  \\<^bold>g [^] z1 \\<otimes>\n  \\<^bold>g [^] (order \\<G> * c * x1 - c * x1) \\<otimes>\n  g' [^] z2 \\<otimes>\n  g' [^] (order \\<G> * c * x2 - c * x2) =\n  \\<^bold>g [^] z1 \\<otimes> g' [^] z2 \\<otimes>\n  \\<^bold>g [^] (order \\<G> * c * x1 - c * x1) \\<otimes>\n  g' [^] (order \\<G> * c * x2 - c * x2)\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^]\n    ((z1 + order \\<G> * c * x1 - c * x1) mod order \\<G>) \\<otimes>\n    g' [^] ((z2 + order \\<G> * c * x2 - c * x2) mod order \\<G>) =\n    \\<^bold>g [^] z1 \\<otimes> g' [^] z2 \\<otimes> inv h [^] c", "have \"... = \\<^bold>g [^] z1 \\<otimes> g' [^] z2 \\<otimes> \\<^bold>g [^] ((order \\<G> - 1) * c * x1) \\<otimes> g' [^] ((order \\<G> - 1) * c * x2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<^bold>g [^] z1 \\<otimes> g' [^] z2 \\<otimes>\n    \\<^bold>g [^] (order \\<G> * c * x1 - c * x1) \\<otimes>\n    g' [^] (order \\<G> * c * x2 - c * x2) =\n    \\<^bold>g [^] z1 \\<otimes> g' [^] z2 \\<otimes>\n    \\<^bold>g [^] ((order \\<G> - 1) * c * x1) \\<otimes>\n    g' [^] ((order \\<G> - 1) * c * x2)", "using pow_distrib1 pow_distrib2"], ["proof (prove)\nusing this:\n  order \\<G> * c * x1 - c * x1 = (order \\<G> - 1) * c * x1\n  order \\<G> * c * x2 - c * x2 = (order \\<G> - 1) * c * x2\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^] z1 \\<otimes> g' [^] z2 \\<otimes>\n    \\<^bold>g [^] (order \\<G> * c * x1 - c * x1) \\<otimes>\n    g' [^] (order \\<G> * c * x2 - c * x2) =\n    \\<^bold>g [^] z1 \\<otimes> g' [^] z2 \\<otimes>\n    \\<^bold>g [^] ((order \\<G> - 1) * c * x1) \\<otimes>\n    g' [^] ((order \\<G> - 1) * c * x2)", "by argo"], ["proof (state)\nthis:\n  \\<^bold>g [^] z1 \\<otimes> g' [^] z2 \\<otimes>\n  \\<^bold>g [^] (order \\<G> * c * x1 - c * x1) \\<otimes>\n  g' [^] (order \\<G> * c * x2 - c * x2) =\n  \\<^bold>g [^] z1 \\<otimes> g' [^] z2 \\<otimes>\n  \\<^bold>g [^] ((order \\<G> - 1) * c * x1) \\<otimes>\n  g' [^] ((order \\<G> - 1) * c * x2)\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^]\n    ((z1 + order \\<G> * c * x1 - c * x1) mod order \\<G>) \\<otimes>\n    g' [^] ((z2 + order \\<G> * c * x2 - c * x2) mod order \\<G>) =\n    \\<^bold>g [^] z1 \\<otimes> g' [^] z2 \\<otimes> inv h [^] c", "also"], ["proof (state)\nthis:\n  \\<^bold>g [^] z1 \\<otimes> g' [^] z2 \\<otimes>\n  \\<^bold>g [^] (order \\<G> * c * x1 - c * x1) \\<otimes>\n  g' [^] (order \\<G> * c * x2 - c * x2) =\n  \\<^bold>g [^] z1 \\<otimes> g' [^] z2 \\<otimes>\n  \\<^bold>g [^] ((order \\<G> - 1) * c * x1) \\<otimes>\n  g' [^] ((order \\<G> - 1) * c * x2)\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^]\n    ((z1 + order \\<G> * c * x1 - c * x1) mod order \\<G>) \\<otimes>\n    g' [^] ((z2 + order \\<G> * c * x2 - c * x2) mod order \\<G>) =\n    \\<^bold>g [^] z1 \\<otimes> g' [^] z2 \\<otimes> inv h [^] c", "have \"... = \\<^bold>g [^] z1 \\<otimes> g' [^] z2 \\<otimes> (\\<^bold>g [^] (order \\<G> - 1)) [^] (c * x1) \\<otimes> (g' [^] ((order \\<G> - 1))) [^] (c * x2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<^bold>g [^] z1 \\<otimes> g' [^] z2 \\<otimes>\n    \\<^bold>g [^] ((order \\<G> - 1) * c * x1) \\<otimes>\n    g' [^] ((order \\<G> - 1) * c * x2) =\n    \\<^bold>g [^] z1 \\<otimes> g' [^] z2 \\<otimes>\n    (\\<^bold>g [^] (order \\<G> - 1)) [^] (c * x1) \\<otimes>\n    (g' [^] (order \\<G> - 1)) [^] (c * x2)", "by (simp add: more_arith_simps(11) nat_pow_pow)"], ["proof (state)\nthis:\n  \\<^bold>g [^] z1 \\<otimes> g' [^] z2 \\<otimes>\n  \\<^bold>g [^] ((order \\<G> - 1) * c * x1) \\<otimes>\n  g' [^] ((order \\<G> - 1) * c * x2) =\n  \\<^bold>g [^] z1 \\<otimes> g' [^] z2 \\<otimes>\n  (\\<^bold>g [^] (order \\<G> - 1)) [^] (c * x1) \\<otimes>\n  (g' [^] (order \\<G> - 1)) [^] (c * x2)\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^]\n    ((z1 + order \\<G> * c * x1 - c * x1) mod order \\<G>) \\<otimes>\n    g' [^] ((z2 + order \\<G> * c * x2 - c * x2) mod order \\<G>) =\n    \\<^bold>g [^] z1 \\<otimes> g' [^] z2 \\<otimes> inv h [^] c", "also"], ["proof (state)\nthis:\n  \\<^bold>g [^] z1 \\<otimes> g' [^] z2 \\<otimes>\n  \\<^bold>g [^] ((order \\<G> - 1) * c * x1) \\<otimes>\n  g' [^] ((order \\<G> - 1) * c * x2) =\n  \\<^bold>g [^] z1 \\<otimes> g' [^] z2 \\<otimes>\n  (\\<^bold>g [^] (order \\<G> - 1)) [^] (c * x1) \\<otimes>\n  (g' [^] (order \\<G> - 1)) [^] (c * x2)\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^]\n    ((z1 + order \\<G> * c * x1 - c * x1) mod order \\<G>) \\<otimes>\n    g' [^] ((z2 + order \\<G> * c * x2 - c * x2) mod order \\<G>) =\n    \\<^bold>g [^] z1 \\<otimes> g' [^] z2 \\<otimes> inv h [^] c", "have \"... = \\<^bold>g [^] z1 \\<otimes> g' [^] z2 \\<otimes> (inv (\\<^bold>g [^] c)) [^] x1 \\<otimes> (inv (g' [^] c)) [^] x2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<^bold>g [^] z1 \\<otimes> g' [^] z2 \\<otimes>\n    (\\<^bold>g [^] (order \\<G> - 1)) [^] (c * x1) \\<otimes>\n    (g' [^] (order \\<G> - 1)) [^] (c * x2) =\n    \\<^bold>g [^] z1 \\<otimes> g' [^] z2 \\<otimes>\n    inv (\\<^bold>g [^] c) [^] x1 \\<otimes>\n    inv (g' [^] c) [^] x2", "using assms neg_power_inverse  inverse_pow_pow nat_pow_pow prime_gt_1_nat prime_order"], ["proof (prove)\nusing this:\n  h = \\<^bold>g [^] x1 \\<otimes> g' [^] x2\n  \\<lbrakk>?g \\<in> carrier \\<G>; ?x < order \\<G>\\<rbrakk>\n  \\<Longrightarrow> ?g [^] (order \\<G> - ?x) = inv (?g [^] ?x)\n  ?a \\<in> carrier \\<G> \\<Longrightarrow> inv (?a [^] ?r) = inv ?a [^] ?r\n  ?x \\<in> carrier \\<G> \\<Longrightarrow>\n  (?x [^] ?n) [^] ?m = ?x [^] (?n * ?m)\n  prime ?p \\<Longrightarrow> 1 < ?p\n  prime (order \\<G>)\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^] z1 \\<otimes> g' [^] z2 \\<otimes>\n    (\\<^bold>g [^] (order \\<G> - 1)) [^] (c * x1) \\<otimes>\n    (g' [^] (order \\<G> - 1)) [^] (c * x2) =\n    \\<^bold>g [^] z1 \\<otimes> g' [^] z2 \\<otimes>\n    inv (\\<^bold>g [^] c) [^] x1 \\<otimes>\n    inv (g' [^] c) [^] x2", "by auto"], ["proof (state)\nthis:\n  \\<^bold>g [^] z1 \\<otimes> g' [^] z2 \\<otimes>\n  (\\<^bold>g [^] (order \\<G> - 1)) [^] (c * x1) \\<otimes>\n  (g' [^] (order \\<G> - 1)) [^] (c * x2) =\n  \\<^bold>g [^] z1 \\<otimes> g' [^] z2 \\<otimes>\n  inv (\\<^bold>g [^] c) [^] x1 \\<otimes>\n  inv (g' [^] c) [^] x2\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^]\n    ((z1 + order \\<G> * c * x1 - c * x1) mod order \\<G>) \\<otimes>\n    g' [^] ((z2 + order \\<G> * c * x2 - c * x2) mod order \\<G>) =\n    \\<^bold>g [^] z1 \\<otimes> g' [^] z2 \\<otimes> inv h [^] c", "also"], ["proof (state)\nthis:\n  \\<^bold>g [^] z1 \\<otimes> g' [^] z2 \\<otimes>\n  (\\<^bold>g [^] (order \\<G> - 1)) [^] (c * x1) \\<otimes>\n  (g' [^] (order \\<G> - 1)) [^] (c * x2) =\n  \\<^bold>g [^] z1 \\<otimes> g' [^] z2 \\<otimes>\n  inv (\\<^bold>g [^] c) [^] x1 \\<otimes>\n  inv (g' [^] c) [^] x2\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^]\n    ((z1 + order \\<G> * c * x1 - c * x1) mod order \\<G>) \\<otimes>\n    g' [^] ((z2 + order \\<G> * c * x2 - c * x2) mod order \\<G>) =\n    \\<^bold>g [^] z1 \\<otimes> g' [^] z2 \\<otimes> inv h [^] c", "have \"... = \\<^bold>g [^] z1 \\<otimes> g' [^] z2 \\<otimes> (inv ((\\<^bold>g [^] c) [^] x1)) \\<otimes> (inv ((g' [^] c) [^] x2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<^bold>g [^] z1 \\<otimes> g' [^] z2 \\<otimes>\n    inv (\\<^bold>g [^] c) [^] x1 \\<otimes>\n    inv (g' [^] c) [^] x2 =\n    \\<^bold>g [^] z1 \\<otimes> g' [^] z2 \\<otimes>\n    inv ((\\<^bold>g [^] c) [^] x1) \\<otimes>\n    inv ((g' [^] c) [^] x2)", "by (simp add: inverse_pow_pow)"], ["proof (state)\nthis:\n  \\<^bold>g [^] z1 \\<otimes> g' [^] z2 \\<otimes>\n  inv (\\<^bold>g [^] c) [^] x1 \\<otimes>\n  inv (g' [^] c) [^] x2 =\n  \\<^bold>g [^] z1 \\<otimes> g' [^] z2 \\<otimes>\n  inv ((\\<^bold>g [^] c) [^] x1) \\<otimes>\n  inv ((g' [^] c) [^] x2)\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^]\n    ((z1 + order \\<G> * c * x1 - c * x1) mod order \\<G>) \\<otimes>\n    g' [^] ((z2 + order \\<G> * c * x2 - c * x2) mod order \\<G>) =\n    \\<^bold>g [^] z1 \\<otimes> g' [^] z2 \\<otimes> inv h [^] c", "also"], ["proof (state)\nthis:\n  \\<^bold>g [^] z1 \\<otimes> g' [^] z2 \\<otimes>\n  inv (\\<^bold>g [^] c) [^] x1 \\<otimes>\n  inv (g' [^] c) [^] x2 =\n  \\<^bold>g [^] z1 \\<otimes> g' [^] z2 \\<otimes>\n  inv ((\\<^bold>g [^] c) [^] x1) \\<otimes>\n  inv ((g' [^] c) [^] x2)\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^]\n    ((z1 + order \\<G> * c * x1 - c * x1) mod order \\<G>) \\<otimes>\n    g' [^] ((z2 + order \\<G> * c * x2 - c * x2) mod order \\<G>) =\n    \\<^bold>g [^] z1 \\<otimes> g' [^] z2 \\<otimes> inv h [^] c", "have \"... = \\<^bold>g [^] z1 \\<otimes> g' [^] z2 \\<otimes> ((inv ((\\<^bold>g [^] x1) [^] c)) \\<otimes> (inv ((g' [^] x2) [^] c)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<^bold>g [^] z1 \\<otimes> g' [^] z2 \\<otimes>\n    inv ((\\<^bold>g [^] c) [^] x1) \\<otimes>\n    inv ((g' [^] c) [^] x2) =\n    \\<^bold>g [^] z1 \\<otimes> g' [^] z2 \\<otimes>\n    (inv ((\\<^bold>g [^] x1) [^] c) \\<otimes> inv ((g' [^] x2) [^] c))", "by (simp add: mult.commute cyclic_group_assoc nat_pow_pow)"], ["proof (state)\nthis:\n  \\<^bold>g [^] z1 \\<otimes> g' [^] z2 \\<otimes>\n  inv ((\\<^bold>g [^] c) [^] x1) \\<otimes>\n  inv ((g' [^] c) [^] x2) =\n  \\<^bold>g [^] z1 \\<otimes> g' [^] z2 \\<otimes>\n  (inv ((\\<^bold>g [^] x1) [^] c) \\<otimes> inv ((g' [^] x2) [^] c))\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^]\n    ((z1 + order \\<G> * c * x1 - c * x1) mod order \\<G>) \\<otimes>\n    g' [^] ((z2 + order \\<G> * c * x2 - c * x2) mod order \\<G>) =\n    \\<^bold>g [^] z1 \\<otimes> g' [^] z2 \\<otimes> inv h [^] c", "also"], ["proof (state)\nthis:\n  \\<^bold>g [^] z1 \\<otimes> g' [^] z2 \\<otimes>\n  inv ((\\<^bold>g [^] c) [^] x1) \\<otimes>\n  inv ((g' [^] c) [^] x2) =\n  \\<^bold>g [^] z1 \\<otimes> g' [^] z2 \\<otimes>\n  (inv ((\\<^bold>g [^] x1) [^] c) \\<otimes> inv ((g' [^] x2) [^] c))\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^]\n    ((z1 + order \\<G> * c * x1 - c * x1) mod order \\<G>) \\<otimes>\n    g' [^] ((z2 + order \\<G> * c * x2 - c * x2) mod order \\<G>) =\n    \\<^bold>g [^] z1 \\<otimes> g' [^] z2 \\<otimes> inv h [^] c", "have \"... = \\<^bold>g [^] z1 \\<otimes> g' [^] z2 \\<otimes> inv ((\\<^bold>g [^] x1) [^] c \\<otimes> (g' [^] x2) [^] c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<^bold>g [^] z1 \\<otimes> g' [^] z2 \\<otimes>\n    (inv ((\\<^bold>g [^] x1) [^] c) \\<otimes> inv ((g' [^] x2) [^] c)) =\n    \\<^bold>g [^] z1 \\<otimes> g' [^] z2 \\<otimes>\n    inv ((\\<^bold>g [^] x1) [^] c \\<otimes> (g' [^] x2) [^] c)", "using inverse_split in_carrier2 in_carrier1"], ["proof (prove)\nusing this:\n  \\<lbrakk>?a \\<in> carrier \\<G>; ?b \\<in> carrier \\<G>\\<rbrakk>\n  \\<Longrightarrow> inv (?a \\<otimes> ?b) = inv ?a \\<otimes> inv ?b\n  (\\<^bold>g [^] x1) [^] c \\<in> carrier \\<G>\n  (g' [^] x2) [^] c \\<in> carrier \\<G>\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^] z1 \\<otimes> g' [^] z2 \\<otimes>\n    (inv ((\\<^bold>g [^] x1) [^] c) \\<otimes> inv ((g' [^] x2) [^] c)) =\n    \\<^bold>g [^] z1 \\<otimes> g' [^] z2 \\<otimes>\n    inv ((\\<^bold>g [^] x1) [^] c \\<otimes> (g' [^] x2) [^] c)", "by simp"], ["proof (state)\nthis:\n  \\<^bold>g [^] z1 \\<otimes> g' [^] z2 \\<otimes>\n  (inv ((\\<^bold>g [^] x1) [^] c) \\<otimes> inv ((g' [^] x2) [^] c)) =\n  \\<^bold>g [^] z1 \\<otimes> g' [^] z2 \\<otimes>\n  inv ((\\<^bold>g [^] x1) [^] c \\<otimes> (g' [^] x2) [^] c)\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^]\n    ((z1 + order \\<G> * c * x1 - c * x1) mod order \\<G>) \\<otimes>\n    g' [^] ((z2 + order \\<G> * c * x2 - c * x2) mod order \\<G>) =\n    \\<^bold>g [^] z1 \\<otimes> g' [^] z2 \\<otimes> inv h [^] c", "also"], ["proof (state)\nthis:\n  \\<^bold>g [^] z1 \\<otimes> g' [^] z2 \\<otimes>\n  (inv ((\\<^bold>g [^] x1) [^] c) \\<otimes> inv ((g' [^] x2) [^] c)) =\n  \\<^bold>g [^] z1 \\<otimes> g' [^] z2 \\<otimes>\n  inv ((\\<^bold>g [^] x1) [^] c \\<otimes> (g' [^] x2) [^] c)\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^]\n    ((z1 + order \\<G> * c * x1 - c * x1) mod order \\<G>) \\<otimes>\n    g' [^] ((z2 + order \\<G> * c * x2 - c * x2) mod order \\<G>) =\n    \\<^bold>g [^] z1 \\<otimes> g' [^] z2 \\<otimes> inv h [^] c", "have \"... = \\<^bold>g [^] z1 \\<otimes> g' [^] z2 \\<otimes> inv (h [^] c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<^bold>g [^] z1 \\<otimes> g' [^] z2 \\<otimes>\n    inv ((\\<^bold>g [^] x1) [^] c \\<otimes> (g' [^] x2) [^] c) =\n    \\<^bold>g [^] z1 \\<otimes> g' [^] z2 \\<otimes> inv (h [^] c)", "using h  cyclic_group_commute monoid_comm_monoidI"], ["proof (prove)\nusing this:\n  h = \\<^bold>g [^] x1 \\<otimes> g' [^] x2\n  \\<lbrakk>?a \\<in> carrier \\<G>; ?b \\<in> carrier \\<G>\\<rbrakk>\n  \\<Longrightarrow> ?a \\<otimes> ?b = ?b \\<otimes> ?a\n  (\\<And>x y.\n      \\<lbrakk>x \\<in> carrier \\<G>; y \\<in> carrier \\<G>\\<rbrakk>\n      \\<Longrightarrow> x \\<otimes> y = y \\<otimes> x) \\<Longrightarrow>\n  Group.comm_monoid \\<G>\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^] z1 \\<otimes> g' [^] z2 \\<otimes>\n    inv ((\\<^bold>g [^] x1) [^] c \\<otimes> (g' [^] x2) [^] c) =\n    \\<^bold>g [^] z1 \\<otimes> g' [^] z2 \\<otimes> inv (h [^] c)", "by (simp add: pow_mult_distrib)"], ["proof (state)\nthis:\n  \\<^bold>g [^] z1 \\<otimes> g' [^] z2 \\<otimes>\n  inv ((\\<^bold>g [^] x1) [^] c \\<otimes> (g' [^] x2) [^] c) =\n  \\<^bold>g [^] z1 \\<otimes> g' [^] z2 \\<otimes> inv (h [^] c)\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^]\n    ((z1 + order \\<G> * c * x1 - c * x1) mod order \\<G>) \\<otimes>\n    g' [^] ((z2 + order \\<G> * c * x2 - c * x2) mod order \\<G>) =\n    \\<^bold>g [^] z1 \\<otimes> g' [^] z2 \\<otimes> inv h [^] c", "ultimately"], ["proof (chain)\npicking this:\n  \\<^bold>g [^]\n  ((z1 + order \\<G> * c * x1 - c * x1) mod order \\<G>) \\<otimes>\n  g' [^] ((z2 + order \\<G> * c * x2 - c * x2) mod order \\<G>) =\n  \\<^bold>g [^] z1 \\<otimes> g' [^] z2 \\<otimes>\n  inv ((\\<^bold>g [^] x1) [^] c \\<otimes> (g' [^] x2) [^] c)\n  \\<^bold>g [^] z1 \\<otimes> g' [^] z2 \\<otimes>\n  inv ((\\<^bold>g [^] x1) [^] c \\<otimes> (g' [^] x2) [^] c) =\n  \\<^bold>g [^] z1 \\<otimes> g' [^] z2 \\<otimes> inv (h [^] c)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<^bold>g [^]\n  ((z1 + order \\<G> * c * x1 - c * x1) mod order \\<G>) \\<otimes>\n  g' [^] ((z2 + order \\<G> * c * x2 - c * x2) mod order \\<G>) =\n  \\<^bold>g [^] z1 \\<otimes> g' [^] z2 \\<otimes>\n  inv ((\\<^bold>g [^] x1) [^] c \\<otimes> (g' [^] x2) [^] c)\n  \\<^bold>g [^] z1 \\<otimes> g' [^] z2 \\<otimes>\n  inv ((\\<^bold>g [^] x1) [^] c \\<otimes> (g' [^] x2) [^] c) =\n  \\<^bold>g [^] z1 \\<otimes> g' [^] z2 \\<otimes> inv (h [^] c)\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^]\n    ((z1 + order \\<G> * c * x1 - c * x1) mod order \\<G>) \\<otimes>\n    g' [^] ((z2 + order \\<G> * c * x2 - c * x2) mod order \\<G>) =\n    \\<^bold>g [^] z1 \\<otimes> g' [^] z2 \\<otimes> inv h [^] c", "by (simp add: h inverse_pow_pow)"], ["proof (state)\nthis:\n  \\<^bold>g [^]\n  ((z1 + order \\<G> * c * x1 - c * x1) mod order \\<G>) \\<otimes>\n  g' [^] ((z2 + order \\<G> * c * x2 - c * x2) mod order \\<G>) =\n  \\<^bold>g [^] z1 \\<otimes> g' [^] z2 \\<otimes> inv h [^] c\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma hv_zk: \n  assumes \"h =  \\<^bold>g [^] x1 \\<otimes> g' [^] x2\"\n  shows \"\\<Sigma>_protocols_base.R h (x1,x2) c = \\<Sigma>_protocols_base.S h c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.\\<Sigma>_protocols_base.R h (x1, x2) c =\n    local.\\<Sigma>_protocols_base.S h c", "including monad_normalisation"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.\\<Sigma>_protocols_base.R h (x1, x2) c =\n    local.\\<Sigma>_protocols_base.S h c", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. local.\\<Sigma>_protocols_base.R h (x1, x2) c =\n    local.\\<Sigma>_protocols_base.S h c", "have \"\\<Sigma>_protocols_base.R h (x1,x2) c = do { \n    r1 \\<leftarrow> sample_uniform (order \\<G>);\n    r2 \\<leftarrow> sample_uniform (order \\<G>);\n    let z1 = (r1 + c * x1) mod (order \\<G>);\n    let z2 = (r2 + c * x2) mod (order \\<G>);\n    return_spmf ( \\<^bold>g [^] r1 \\<otimes> g' [^] r2 ,c,(z1,z2))}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.\\<Sigma>_protocols_base.R h (x1, x2) c =\n    sample_uniform (order \\<G>) \\<bind>\n    (\\<lambda>r1.\n        sample_uniform (order \\<G>) \\<bind>\n        (\\<lambda>r2.\n            let z1 = (r1 + c * x1) mod order \\<G>;\n                z2 = (r2 + c * x2) mod order \\<G>\n            in return_spmf\n                (\\<^bold>g [^] r1 \\<otimes> g' [^] r2, c, z1, z2)))", "by(simp add: \\<Sigma>_protocols_base.R_def R2_def; simp add: add.commute init_def split_def response_def)"], ["proof (state)\nthis:\n  local.\\<Sigma>_protocols_base.R h (x1, x2) c =\n  sample_uniform (order \\<G>) \\<bind>\n  (\\<lambda>r1.\n      sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>r2.\n          let z1 = (r1 + c * x1) mod order \\<G>;\n              z2 = (r2 + c * x2) mod order \\<G>\n          in return_spmf (\\<^bold>g [^] r1 \\<otimes> g' [^] r2, c, z1, z2)))\n\ngoal (1 subgoal):\n 1. local.\\<Sigma>_protocols_base.R h (x1, x2) c =\n    local.\\<Sigma>_protocols_base.S h c", "also"], ["proof (state)\nthis:\n  local.\\<Sigma>_protocols_base.R h (x1, x2) c =\n  sample_uniform (order \\<G>) \\<bind>\n  (\\<lambda>r1.\n      sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>r2.\n          let z1 = (r1 + c * x1) mod order \\<G>;\n              z2 = (r2 + c * x2) mod order \\<G>\n          in return_spmf (\\<^bold>g [^] r1 \\<otimes> g' [^] r2, c, z1, z2)))\n\ngoal (1 subgoal):\n 1. local.\\<Sigma>_protocols_base.R h (x1, x2) c =\n    local.\\<Sigma>_protocols_base.S h c", "have \"... = do { \n    r2 \\<leftarrow> sample_uniform (order \\<G>);\n    z1 \\<leftarrow> map_spmf (\\<lambda> r1. (r1 + c * x1) mod (order \\<G>)) (sample_uniform (order \\<G>));\n    let z2 = (r2 + c * x2) mod (order \\<G>);\n    return_spmf (\\<^bold>g [^] ((z1 + order \\<G> * c * x1 - c * x1) mod (order \\<G>)) \\<otimes> g' [^] r2 ,c,(z1,z2))}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sample_uniform (order \\<G>) \\<bind>\n    (\\<lambda>r1.\n        sample_uniform (order \\<G>) \\<bind>\n        (\\<lambda>r2.\n            let z1 = (r1 + c * x1) mod order \\<G>;\n                z2 = (r2 + c * x2) mod order \\<G>\n            in return_spmf\n                (\\<^bold>g [^] r1 \\<otimes> g' [^] r2, c, z1, z2))) =\n    sample_uniform (order \\<G>) \\<bind>\n    (\\<lambda>r2.\n        map_spmf (\\<lambda>r1. (r1 + c * x1) mod order \\<G>)\n         (sample_uniform (order \\<G>)) \\<bind>\n        (\\<lambda>z1.\n            let z2 = (r2 + c * x2) mod order \\<G>\n            in return_spmf\n                (\\<^bold>g [^]\n                 ((z1 + order \\<G> * c * x1 - c * x1) mod\n                  order \\<G>) \\<otimes>\n                 g' [^] r2,\n                 c, z1, z2)))", "by(simp add: bind_map_spmf o_def Let_def hvzk_z1_r1_tuple_rewrite assms cong: bind_spmf_cong_simp)"], ["proof (state)\nthis:\n  sample_uniform (order \\<G>) \\<bind>\n  (\\<lambda>r1.\n      sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>r2.\n          let z1 = (r1 + c * x1) mod order \\<G>;\n              z2 = (r2 + c * x2) mod order \\<G>\n          in return_spmf\n              (\\<^bold>g [^] r1 \\<otimes> g' [^] r2, c, z1, z2))) =\n  sample_uniform (order \\<G>) \\<bind>\n  (\\<lambda>r2.\n      map_spmf (\\<lambda>r1. (r1 + c * x1) mod order \\<G>)\n       (sample_uniform (order \\<G>)) \\<bind>\n      (\\<lambda>z1.\n          let z2 = (r2 + c * x2) mod order \\<G>\n          in return_spmf\n              (\\<^bold>g [^]\n               ((z1 + order \\<G> * c * x1 - c * x1) mod\n                order \\<G>) \\<otimes>\n               g' [^] r2,\n               c, z1, z2)))\n\ngoal (1 subgoal):\n 1. local.\\<Sigma>_protocols_base.R h (x1, x2) c =\n    local.\\<Sigma>_protocols_base.S h c", "also"], ["proof (state)\nthis:\n  sample_uniform (order \\<G>) \\<bind>\n  (\\<lambda>r1.\n      sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>r2.\n          let z1 = (r1 + c * x1) mod order \\<G>;\n              z2 = (r2 + c * x2) mod order \\<G>\n          in return_spmf\n              (\\<^bold>g [^] r1 \\<otimes> g' [^] r2, c, z1, z2))) =\n  sample_uniform (order \\<G>) \\<bind>\n  (\\<lambda>r2.\n      map_spmf (\\<lambda>r1. (r1 + c * x1) mod order \\<G>)\n       (sample_uniform (order \\<G>)) \\<bind>\n      (\\<lambda>z1.\n          let z2 = (r2 + c * x2) mod order \\<G>\n          in return_spmf\n              (\\<^bold>g [^]\n               ((z1 + order \\<G> * c * x1 - c * x1) mod\n                order \\<G>) \\<otimes>\n               g' [^] r2,\n               c, z1, z2)))\n\ngoal (1 subgoal):\n 1. local.\\<Sigma>_protocols_base.R h (x1, x2) c =\n    local.\\<Sigma>_protocols_base.S h c", "have \"... = do { \n    z1 \\<leftarrow> map_spmf (\\<lambda> r1. (r1 + c * x1) mod (order \\<G>)) (sample_uniform (order \\<G>));\n    z2 \\<leftarrow> map_spmf (\\<lambda> r2. (r2 + c * x2) mod (order \\<G>)) (sample_uniform (order \\<G>));\n    return_spmf (\\<^bold>g [^] ((z1 + order \\<G> * c * x1 - c * x1) mod (order \\<G>)) \\<otimes> g' [^] ((z2 + order \\<G> * c * x2 - c * x2) mod (order \\<G>)) ,c,(z1,z2))}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sample_uniform (order \\<G>) \\<bind>\n    (\\<lambda>r2.\n        map_spmf (\\<lambda>r1. (r1 + c * x1) mod order \\<G>)\n         (sample_uniform (order \\<G>)) \\<bind>\n        (\\<lambda>z1.\n            let z2 = (r2 + c * x2) mod order \\<G>\n            in return_spmf\n                (\\<^bold>g [^]\n                 ((z1 + order \\<G> * c * x1 - c * x1) mod\n                  order \\<G>) \\<otimes>\n                 g' [^] r2,\n                 c, z1, z2))) =\n    map_spmf (\\<lambda>r1. (r1 + c * x1) mod order \\<G>)\n     (sample_uniform (order \\<G>)) \\<bind>\n    (\\<lambda>z1.\n        map_spmf (\\<lambda>r2. (r2 + c * x2) mod order \\<G>)\n         (sample_uniform (order \\<G>)) \\<bind>\n        (\\<lambda>z2.\n            return_spmf\n             (\\<^bold>g [^]\n              ((z1 + order \\<G> * c * x1 - c * x1) mod order \\<G>) \\<otimes>\n              g' [^] ((z2 + order \\<G> * c * x2 - c * x2) mod order \\<G>),\n              c, z1, z2)))", "by(simp add: bind_map_spmf o_def Let_def hvzk_z2_r2_tuple_rewrite cong: bind_spmf_cong_simp)"], ["proof (state)\nthis:\n  sample_uniform (order \\<G>) \\<bind>\n  (\\<lambda>r2.\n      map_spmf (\\<lambda>r1. (r1 + c * x1) mod order \\<G>)\n       (sample_uniform (order \\<G>)) \\<bind>\n      (\\<lambda>z1.\n          let z2 = (r2 + c * x2) mod order \\<G>\n          in return_spmf\n              (\\<^bold>g [^]\n               ((z1 + order \\<G> * c * x1 - c * x1) mod\n                order \\<G>) \\<otimes>\n               g' [^] r2,\n               c, z1, z2))) =\n  map_spmf (\\<lambda>r1. (r1 + c * x1) mod order \\<G>)\n   (sample_uniform (order \\<G>)) \\<bind>\n  (\\<lambda>z1.\n      map_spmf (\\<lambda>r2. (r2 + c * x2) mod order \\<G>)\n       (sample_uniform (order \\<G>)) \\<bind>\n      (\\<lambda>z2.\n          return_spmf\n           (\\<^bold>g [^]\n            ((z1 + order \\<G> * c * x1 - c * x1) mod order \\<G>) \\<otimes>\n            g' [^] ((z2 + order \\<G> * c * x2 - c * x2) mod order \\<G>),\n            c, z1, z2)))\n\ngoal (1 subgoal):\n 1. local.\\<Sigma>_protocols_base.R h (x1, x2) c =\n    local.\\<Sigma>_protocols_base.S h c", "also"], ["proof (state)\nthis:\n  sample_uniform (order \\<G>) \\<bind>\n  (\\<lambda>r2.\n      map_spmf (\\<lambda>r1. (r1 + c * x1) mod order \\<G>)\n       (sample_uniform (order \\<G>)) \\<bind>\n      (\\<lambda>z1.\n          let z2 = (r2 + c * x2) mod order \\<G>\n          in return_spmf\n              (\\<^bold>g [^]\n               ((z1 + order \\<G> * c * x1 - c * x1) mod\n                order \\<G>) \\<otimes>\n               g' [^] r2,\n               c, z1, z2))) =\n  map_spmf (\\<lambda>r1. (r1 + c * x1) mod order \\<G>)\n   (sample_uniform (order \\<G>)) \\<bind>\n  (\\<lambda>z1.\n      map_spmf (\\<lambda>r2. (r2 + c * x2) mod order \\<G>)\n       (sample_uniform (order \\<G>)) \\<bind>\n      (\\<lambda>z2.\n          return_spmf\n           (\\<^bold>g [^]\n            ((z1 + order \\<G> * c * x1 - c * x1) mod order \\<G>) \\<otimes>\n            g' [^] ((z2 + order \\<G> * c * x2 - c * x2) mod order \\<G>),\n            c, z1, z2)))\n\ngoal (1 subgoal):\n 1. local.\\<Sigma>_protocols_base.R h (x1, x2) c =\n    local.\\<Sigma>_protocols_base.S h c", "have \"... = do { \n    z1 \\<leftarrow> map_spmf (\\<lambda> r1. (c * x1 + r1) mod (order \\<G>)) (sample_uniform (order \\<G>));\n    z2 \\<leftarrow> map_spmf (\\<lambda> r2. (c * x2 + r2) mod (order \\<G>)) (sample_uniform (order \\<G>));\n    return_spmf (\\<^bold>g [^] ((z1 + order \\<G> * c * x1 - c * x1) mod (order \\<G>)) \\<otimes> g' [^] ((z2 + order \\<G> * c * x2 - c * x2) mod (order \\<G>)) ,c,(z1,z2))}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_spmf (\\<lambda>r1. (r1 + c * x1) mod order \\<G>)\n     (sample_uniform (order \\<G>)) \\<bind>\n    (\\<lambda>z1.\n        map_spmf (\\<lambda>r2. (r2 + c * x2) mod order \\<G>)\n         (sample_uniform (order \\<G>)) \\<bind>\n        (\\<lambda>z2.\n            return_spmf\n             (\\<^bold>g [^]\n              ((z1 + order \\<G> * c * x1 - c * x1) mod order \\<G>) \\<otimes>\n              g' [^] ((z2 + order \\<G> * c * x2 - c * x2) mod order \\<G>),\n              c, z1, z2))) =\n    map_spmf (\\<lambda>r1. (c * x1 + r1) mod order \\<G>)\n     (sample_uniform (order \\<G>)) \\<bind>\n    (\\<lambda>z1.\n        map_spmf (\\<lambda>r2. (c * x2 + r2) mod order \\<G>)\n         (sample_uniform (order \\<G>)) \\<bind>\n        (\\<lambda>z2.\n            return_spmf\n             (\\<^bold>g [^]\n              ((z1 + order \\<G> * c * x1 - c * x1) mod order \\<G>) \\<otimes>\n              g' [^] ((z2 + order \\<G> * c * x2 - c * x2) mod order \\<G>),\n              c, z1, z2)))", "by(simp add: add.commute)"], ["proof (state)\nthis:\n  map_spmf (\\<lambda>r1. (r1 + c * x1) mod order \\<G>)\n   (sample_uniform (order \\<G>)) \\<bind>\n  (\\<lambda>z1.\n      map_spmf (\\<lambda>r2. (r2 + c * x2) mod order \\<G>)\n       (sample_uniform (order \\<G>)) \\<bind>\n      (\\<lambda>z2.\n          return_spmf\n           (\\<^bold>g [^]\n            ((z1 + order \\<G> * c * x1 - c * x1) mod order \\<G>) \\<otimes>\n            g' [^] ((z2 + order \\<G> * c * x2 - c * x2) mod order \\<G>),\n            c, z1, z2))) =\n  map_spmf (\\<lambda>r1. (c * x1 + r1) mod order \\<G>)\n   (sample_uniform (order \\<G>)) \\<bind>\n  (\\<lambda>z1.\n      map_spmf (\\<lambda>r2. (c * x2 + r2) mod order \\<G>)\n       (sample_uniform (order \\<G>)) \\<bind>\n      (\\<lambda>z2.\n          return_spmf\n           (\\<^bold>g [^]\n            ((z1 + order \\<G> * c * x1 - c * x1) mod order \\<G>) \\<otimes>\n            g' [^] ((z2 + order \\<G> * c * x2 - c * x2) mod order \\<G>),\n            c, z1, z2)))\n\ngoal (1 subgoal):\n 1. local.\\<Sigma>_protocols_base.R h (x1, x2) c =\n    local.\\<Sigma>_protocols_base.S h c", "also"], ["proof (state)\nthis:\n  map_spmf (\\<lambda>r1. (r1 + c * x1) mod order \\<G>)\n   (sample_uniform (order \\<G>)) \\<bind>\n  (\\<lambda>z1.\n      map_spmf (\\<lambda>r2. (r2 + c * x2) mod order \\<G>)\n       (sample_uniform (order \\<G>)) \\<bind>\n      (\\<lambda>z2.\n          return_spmf\n           (\\<^bold>g [^]\n            ((z1 + order \\<G> * c * x1 - c * x1) mod order \\<G>) \\<otimes>\n            g' [^] ((z2 + order \\<G> * c * x2 - c * x2) mod order \\<G>),\n            c, z1, z2))) =\n  map_spmf (\\<lambda>r1. (c * x1 + r1) mod order \\<G>)\n   (sample_uniform (order \\<G>)) \\<bind>\n  (\\<lambda>z1.\n      map_spmf (\\<lambda>r2. (c * x2 + r2) mod order \\<G>)\n       (sample_uniform (order \\<G>)) \\<bind>\n      (\\<lambda>z2.\n          return_spmf\n           (\\<^bold>g [^]\n            ((z1 + order \\<G> * c * x1 - c * x1) mod order \\<G>) \\<otimes>\n            g' [^] ((z2 + order \\<G> * c * x2 - c * x2) mod order \\<G>),\n            c, z1, z2)))\n\ngoal (1 subgoal):\n 1. local.\\<Sigma>_protocols_base.R h (x1, x2) c =\n    local.\\<Sigma>_protocols_base.S h c", "have \"... = do { \n    z1 \\<leftarrow> (sample_uniform (order \\<G>));\n    z2 \\<leftarrow> (sample_uniform (order \\<G>));\n    return_spmf (\\<^bold>g [^] ((z1 + order \\<G> * c * x1 - c * x1) mod (order \\<G>)) \\<otimes> g' [^] ((z2 + order \\<G> * c * x2 - c * x2) mod (order \\<G>)) ,c,(z1,z2))}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_spmf (\\<lambda>r1. (c * x1 + r1) mod order \\<G>)\n     (sample_uniform (order \\<G>)) \\<bind>\n    (\\<lambda>z1.\n        map_spmf (\\<lambda>r2. (c * x2 + r2) mod order \\<G>)\n         (sample_uniform (order \\<G>)) \\<bind>\n        (\\<lambda>z2.\n            return_spmf\n             (\\<^bold>g [^]\n              ((z1 + order \\<G> * c * x1 - c * x1) mod order \\<G>) \\<otimes>\n              g' [^] ((z2 + order \\<G> * c * x2 - c * x2) mod order \\<G>),\n              c, z1, z2))) =\n    sample_uniform (order \\<G>) \\<bind>\n    (\\<lambda>z1.\n        sample_uniform (order \\<G>) \\<bind>\n        (\\<lambda>z2.\n            return_spmf\n             (\\<^bold>g [^]\n              ((z1 + order \\<G> * c * x1 - c * x1) mod order \\<G>) \\<otimes>\n              g' [^] ((z2 + order \\<G> * c * x2 - c * x2) mod order \\<G>),\n              c, z1, z2)))", "by(simp add: samp_uni_plus_one_time_pad)"], ["proof (state)\nthis:\n  map_spmf (\\<lambda>r1. (c * x1 + r1) mod order \\<G>)\n   (sample_uniform (order \\<G>)) \\<bind>\n  (\\<lambda>z1.\n      map_spmf (\\<lambda>r2. (c * x2 + r2) mod order \\<G>)\n       (sample_uniform (order \\<G>)) \\<bind>\n      (\\<lambda>z2.\n          return_spmf\n           (\\<^bold>g [^]\n            ((z1 + order \\<G> * c * x1 - c * x1) mod order \\<G>) \\<otimes>\n            g' [^] ((z2 + order \\<G> * c * x2 - c * x2) mod order \\<G>),\n            c, z1, z2))) =\n  sample_uniform (order \\<G>) \\<bind>\n  (\\<lambda>z1.\n      sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>z2.\n          return_spmf\n           (\\<^bold>g [^]\n            ((z1 + order \\<G> * c * x1 - c * x1) mod order \\<G>) \\<otimes>\n            g' [^] ((z2 + order \\<G> * c * x2 - c * x2) mod order \\<G>),\n            c, z1, z2)))\n\ngoal (1 subgoal):\n 1. local.\\<Sigma>_protocols_base.R h (x1, x2) c =\n    local.\\<Sigma>_protocols_base.S h c", "also"], ["proof (state)\nthis:\n  map_spmf (\\<lambda>r1. (c * x1 + r1) mod order \\<G>)\n   (sample_uniform (order \\<G>)) \\<bind>\n  (\\<lambda>z1.\n      map_spmf (\\<lambda>r2. (c * x2 + r2) mod order \\<G>)\n       (sample_uniform (order \\<G>)) \\<bind>\n      (\\<lambda>z2.\n          return_spmf\n           (\\<^bold>g [^]\n            ((z1 + order \\<G> * c * x1 - c * x1) mod order \\<G>) \\<otimes>\n            g' [^] ((z2 + order \\<G> * c * x2 - c * x2) mod order \\<G>),\n            c, z1, z2))) =\n  sample_uniform (order \\<G>) \\<bind>\n  (\\<lambda>z1.\n      sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>z2.\n          return_spmf\n           (\\<^bold>g [^]\n            ((z1 + order \\<G> * c * x1 - c * x1) mod order \\<G>) \\<otimes>\n            g' [^] ((z2 + order \\<G> * c * x2 - c * x2) mod order \\<G>),\n            c, z1, z2)))\n\ngoal (1 subgoal):\n 1. local.\\<Sigma>_protocols_base.R h (x1, x2) c =\n    local.\\<Sigma>_protocols_base.S h c", "have \"... = do { \n    z1 \\<leftarrow> (sample_uniform (order \\<G>));\n    z2 \\<leftarrow> (sample_uniform (order \\<G>));\n    return_spmf ((\\<^bold>g [^] z1 \\<otimes> g' [^] z2) \\<otimes> (inv h [^] c) ,c,(z1,z2))}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sample_uniform (order \\<G>) \\<bind>\n    (\\<lambda>z1.\n        sample_uniform (order \\<G>) \\<bind>\n        (\\<lambda>z2.\n            return_spmf\n             (\\<^bold>g [^]\n              ((z1 + order \\<G> * c * x1 - c * x1) mod order \\<G>) \\<otimes>\n              g' [^] ((z2 + order \\<G> * c * x2 - c * x2) mod order \\<G>),\n              c, z1, z2))) =\n    sample_uniform (order \\<G>) \\<bind>\n    (\\<lambda>z1.\n        sample_uniform (order \\<G>) \\<bind>\n        (\\<lambda>z2.\n            return_spmf\n             (\\<^bold>g [^] z1 \\<otimes> g' [^] z2 \\<otimes> inv h [^] c, c,\n              z1, z2)))", "by(simp add: hvzk_sim_inverse_rewrite assms cong: bind_spmf_cong_simp)"], ["proof (state)\nthis:\n  sample_uniform (order \\<G>) \\<bind>\n  (\\<lambda>z1.\n      sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>z2.\n          return_spmf\n           (\\<^bold>g [^]\n            ((z1 + order \\<G> * c * x1 - c * x1) mod order \\<G>) \\<otimes>\n            g' [^] ((z2 + order \\<G> * c * x2 - c * x2) mod order \\<G>),\n            c, z1, z2))) =\n  sample_uniform (order \\<G>) \\<bind>\n  (\\<lambda>z1.\n      sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>z2.\n          return_spmf\n           (\\<^bold>g [^] z1 \\<otimes> g' [^] z2 \\<otimes> inv h [^] c, c,\n            z1, z2)))\n\ngoal (1 subgoal):\n 1. local.\\<Sigma>_protocols_base.R h (x1, x2) c =\n    local.\\<Sigma>_protocols_base.S h c", "ultimately"], ["proof (chain)\npicking this:\n  local.\\<Sigma>_protocols_base.R h (x1, x2) c =\n  sample_uniform (order \\<G>) \\<bind>\n  (\\<lambda>z1.\n      sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>z2.\n          return_spmf\n           (\\<^bold>g [^]\n            ((z1 + order \\<G> * c * x1 - c * x1) mod order \\<G>) \\<otimes>\n            g' [^] ((z2 + order \\<G> * c * x2 - c * x2) mod order \\<G>),\n            c, z1, z2)))\n  sample_uniform (order \\<G>) \\<bind>\n  (\\<lambda>z1.\n      sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>z2.\n          return_spmf\n           (\\<^bold>g [^]\n            ((z1 + order \\<G> * c * x1 - c * x1) mod order \\<G>) \\<otimes>\n            g' [^] ((z2 + order \\<G> * c * x2 - c * x2) mod order \\<G>),\n            c, z1, z2))) =\n  sample_uniform (order \\<G>) \\<bind>\n  (\\<lambda>z1.\n      sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>z2.\n          return_spmf\n           (\\<^bold>g [^] z1 \\<otimes> g' [^] z2 \\<otimes> inv h [^] c, c,\n            z1, z2)))", "show ?thesis"], ["proof (prove)\nusing this:\n  local.\\<Sigma>_protocols_base.R h (x1, x2) c =\n  sample_uniform (order \\<G>) \\<bind>\n  (\\<lambda>z1.\n      sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>z2.\n          return_spmf\n           (\\<^bold>g [^]\n            ((z1 + order \\<G> * c * x1 - c * x1) mod order \\<G>) \\<otimes>\n            g' [^] ((z2 + order \\<G> * c * x2 - c * x2) mod order \\<G>),\n            c, z1, z2)))\n  sample_uniform (order \\<G>) \\<bind>\n  (\\<lambda>z1.\n      sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>z2.\n          return_spmf\n           (\\<^bold>g [^]\n            ((z1 + order \\<G> * c * x1 - c * x1) mod order \\<G>) \\<otimes>\n            g' [^] ((z2 + order \\<G> * c * x2 - c * x2) mod order \\<G>),\n            c, z1, z2))) =\n  sample_uniform (order \\<G>) \\<bind>\n  (\\<lambda>z1.\n      sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>z2.\n          return_spmf\n           (\\<^bold>g [^] z1 \\<otimes> g' [^] z2 \\<otimes> inv h [^] c, c,\n            z1, z2)))\n\ngoal (1 subgoal):\n 1. local.\\<Sigma>_protocols_base.R h (x1, x2) c =\n    local.\\<Sigma>_protocols_base.S h c", "by(simp add: \\<Sigma>_protocols_base.S_def S2_def bind_map_spmf map_spmf_conv_bind_spmf)"], ["proof (state)\nthis:\n  local.\\<Sigma>_protocols_base.R h (x1, x2) c =\n  local.\\<Sigma>_protocols_base.S h c\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma HVZK: \n  shows \"\\<Sigma>_protocols_base.HVZK\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.\\<Sigma>_protocols_base.HVZK", "unfolding \\<Sigma>_protocols_base.HVZK_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>e\\<in>challenge_space.\n       (\\<forall>(h, w)\\<in>R.\n           local.\\<Sigma>_protocols_base.R h w e =\n           local.\\<Sigma>_protocols_base.S h e) \\<and>\n       (\\<forall>h\\<in>valid_pub.\n           \\<forall>(a, z)\\<in>set_spmf (S2 h e). check h a e z)", "apply(auto simp add: R_def challenge_space_def hv_zk S2_def check_def valid_pub_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>e h aa b.\n       \\<lbrakk>e < order \\<G>; h \\<in> carrier \\<G>; b < order \\<G>;\n        aa < order \\<G>\\<rbrakk>\n       \\<Longrightarrow> \\<^bold>g [^] aa \\<otimes> g' [^] b =\n                         \\<^bold>g [^] aa \\<otimes> g' [^] b \\<otimes>\n                         inv h [^] e \\<otimes>\n                         h [^] e", "by (metis (no_types, lifting) cyclic_group_commute g'_in_carrier generator_closed inv_closed inv_solve_left inverse_pow_pow m_closed nat_pow_closed)"], ["", "lemma ss_rewrite:\n  assumes \"h \\<in> carrier \\<G>\"\n    and \"a \\<in> carrier \\<G>\"\n    and \"e < order \\<G>\" \n    and \"\\<^bold>g [^] z1 \\<otimes> g' [^] z1' = a \\<otimes> h [^] e\"\n    and \"e' < e\"\n    and \"\\<^bold>g [^] z2 \\<otimes> g' [^] z2' = a \\<otimes> h [^] e' \"\n  shows \"h = \\<^bold>g [^] ((int z1 - int z2) * fst (bezw (e - e') (order \\<G>)) mod int (order \\<G>)) \\<otimes> g' [^] ((int z1' - int z2') * fst (bezw (e - e') (order \\<G>)) mod int (order \\<G>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h =\n    \\<^bold>g [^]\n    ((int z1 - int z2) * Number_Theory_Aux.inverse (e - e') (order \\<G>) mod\n     int (order \\<G>)) \\<otimes>\n    g' [^]\n    ((int z1' - int z2') *\n     Number_Theory_Aux.inverse (e - e') (order \\<G>) mod\n     int (order \\<G>))", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. h =\n    \\<^bold>g [^]\n    ((int z1 - int z2) * Number_Theory_Aux.inverse (e - e') (order \\<G>) mod\n     int (order \\<G>)) \\<otimes>\n    g' [^]\n    ((int z1' - int z2') *\n     Number_Theory_Aux.inverse (e - e') (order \\<G>) mod\n     int (order \\<G>))", "have gcd: \"gcd (e - e') (order \\<G>) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gcd (e - e') (order \\<G>) = 1", "using prime_field assms prime_order"], ["proof (prove)\nusing this:\n  \\<lbrakk>prime ?q; ?a < ?q; ?a \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> coprime ?a ?q\n  h \\<in> carrier \\<G>\n  a \\<in> carrier \\<G>\n  e < order \\<G>\n  \\<^bold>g [^] z1 \\<otimes> g' [^] z1' = a \\<otimes> h [^] e\n  e' < e\n  \\<^bold>g [^] z2 \\<otimes> g' [^] z2' = a \\<otimes> h [^] e'\n  prime (order \\<G>)\n\ngoal (1 subgoal):\n 1. gcd (e - e') (order \\<G>) = 1", "by simp"], ["proof (state)\nthis:\n  gcd (e - e') (order \\<G>) = 1\n\ngoal (1 subgoal):\n 1. h =\n    \\<^bold>g [^]\n    ((int z1 - int z2) * Number_Theory_Aux.inverse (e - e') (order \\<G>) mod\n     int (order \\<G>)) \\<otimes>\n    g' [^]\n    ((int z1' - int z2') *\n     Number_Theory_Aux.inverse (e - e') (order \\<G>) mod\n     int (order \\<G>))", "have \"\\<^bold>g [^] z1 \\<otimes> g' [^] z1' \\<otimes> inv (h [^] e) = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<^bold>g [^] z1 \\<otimes> g' [^] z1' \\<otimes> inv (h [^] e) = a", "by (simp add: inv_solve_right' assms)"], ["proof (state)\nthis:\n  \\<^bold>g [^] z1 \\<otimes> g' [^] z1' \\<otimes> inv (h [^] e) = a\n\ngoal (1 subgoal):\n 1. h =\n    \\<^bold>g [^]\n    ((int z1 - int z2) * Number_Theory_Aux.inverse (e - e') (order \\<G>) mod\n     int (order \\<G>)) \\<otimes>\n    g' [^]\n    ((int z1' - int z2') *\n     Number_Theory_Aux.inverse (e - e') (order \\<G>) mod\n     int (order \\<G>))", "moreover"], ["proof (state)\nthis:\n  \\<^bold>g [^] z1 \\<otimes> g' [^] z1' \\<otimes> inv (h [^] e) = a\n\ngoal (1 subgoal):\n 1. h =\n    \\<^bold>g [^]\n    ((int z1 - int z2) * Number_Theory_Aux.inverse (e - e') (order \\<G>) mod\n     int (order \\<G>)) \\<otimes>\n    g' [^]\n    ((int z1' - int z2') *\n     Number_Theory_Aux.inverse (e - e') (order \\<G>) mod\n     int (order \\<G>))", "have \"\\<^bold>g [^] z2 \\<otimes> g' [^] z2' \\<otimes> inv (h [^] e') = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<^bold>g [^] z2 \\<otimes> g' [^] z2' \\<otimes> inv (h [^] e') = a", "by (simp add: assms inv_solve_right')"], ["proof (state)\nthis:\n  \\<^bold>g [^] z2 \\<otimes> g' [^] z2' \\<otimes> inv (h [^] e') = a\n\ngoal (1 subgoal):\n 1. h =\n    \\<^bold>g [^]\n    ((int z1 - int z2) * Number_Theory_Aux.inverse (e - e') (order \\<G>) mod\n     int (order \\<G>)) \\<otimes>\n    g' [^]\n    ((int z1' - int z2') *\n     Number_Theory_Aux.inverse (e - e') (order \\<G>) mod\n     int (order \\<G>))", "ultimately"], ["proof (chain)\npicking this:\n  \\<^bold>g [^] z1 \\<otimes> g' [^] z1' \\<otimes> inv (h [^] e) = a\n  \\<^bold>g [^] z2 \\<otimes> g' [^] z2' \\<otimes> inv (h [^] e') = a", "have \"\\<^bold>g [^] z2 \\<otimes> g' [^] z2' \\<otimes> inv (h [^] e') = \\<^bold>g [^] z1 \\<otimes> g' [^] z1' \\<otimes> inv (h [^] e)\""], ["proof (prove)\nusing this:\n  \\<^bold>g [^] z1 \\<otimes> g' [^] z1' \\<otimes> inv (h [^] e) = a\n  \\<^bold>g [^] z2 \\<otimes> g' [^] z2' \\<otimes> inv (h [^] e') = a\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^] z2 \\<otimes> g' [^] z2' \\<otimes> inv (h [^] e') =\n    \\<^bold>g [^] z1 \\<otimes> g' [^] z1' \\<otimes> inv (h [^] e)", "using g'_def"], ["proof (prove)\nusing this:\n  \\<^bold>g [^] z1 \\<otimes> g' [^] z1' \\<otimes> inv (h [^] e) = a\n  \\<^bold>g [^] z2 \\<otimes> g' [^] z2' \\<otimes> inv (h [^] e') = a\n  g' = \\<^bold>g [^] x\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^] z2 \\<otimes> g' [^] z2' \\<otimes> inv (h [^] e') =\n    \\<^bold>g [^] z1 \\<otimes> g' [^] z1' \\<otimes> inv (h [^] e)", "by (simp add: nat_pow_pow)"], ["proof (state)\nthis:\n  \\<^bold>g [^] z2 \\<otimes> g' [^] z2' \\<otimes> inv (h [^] e') =\n  \\<^bold>g [^] z1 \\<otimes> g' [^] z1' \\<otimes> inv (h [^] e)\n\ngoal (1 subgoal):\n 1. h =\n    \\<^bold>g [^]\n    ((int z1 - int z2) * Number_Theory_Aux.inverse (e - e') (order \\<G>) mod\n     int (order \\<G>)) \\<otimes>\n    g' [^]\n    ((int z1' - int z2') *\n     Number_Theory_Aux.inverse (e - e') (order \\<G>) mod\n     int (order \\<G>))", "moreover"], ["proof (state)\nthis:\n  \\<^bold>g [^] z2 \\<otimes> g' [^] z2' \\<otimes> inv (h [^] e') =\n  \\<^bold>g [^] z1 \\<otimes> g' [^] z1' \\<otimes> inv (h [^] e)\n\ngoal (1 subgoal):\n 1. h =\n    \\<^bold>g [^]\n    ((int z1 - int z2) * Number_Theory_Aux.inverse (e - e') (order \\<G>) mod\n     int (order \\<G>)) \\<otimes>\n    g' [^]\n    ((int z1' - int z2') *\n     Number_Theory_Aux.inverse (e - e') (order \\<G>) mod\n     int (order \\<G>))", "obtain t :: nat where t: \"h = \\<^bold>g [^] t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>t.\n        h = \\<^bold>g [^] t \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms generatorE"], ["proof (prove)\nusing this:\n  h \\<in> carrier \\<G>\n  a \\<in> carrier \\<G>\n  e < order \\<G>\n  \\<^bold>g [^] z1 \\<otimes> g' [^] z1' = a \\<otimes> h [^] e\n  e' < e\n  \\<^bold>g [^] z2 \\<otimes> g' [^] z2' = a \\<otimes> h [^] e'\n  \\<lbrakk>?x \\<in> carrier \\<G>;\n   \\<And>n. ?x = \\<^bold>g [^] n \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        h = \\<^bold>g [^] t \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  h = \\<^bold>g [^] t\n\ngoal (1 subgoal):\n 1. h =\n    \\<^bold>g [^]\n    ((int z1 - int z2) * Number_Theory_Aux.inverse (e - e') (order \\<G>) mod\n     int (order \\<G>)) \\<otimes>\n    g' [^]\n    ((int z1' - int z2') *\n     Number_Theory_Aux.inverse (e - e') (order \\<G>) mod\n     int (order \\<G>))", "ultimately"], ["proof (chain)\npicking this:\n  \\<^bold>g [^] z2 \\<otimes> g' [^] z2' \\<otimes> inv (h [^] e') =\n  \\<^bold>g [^] z1 \\<otimes> g' [^] z1' \\<otimes> inv (h [^] e)\n  h = \\<^bold>g [^] t", "have \"\\<^bold>g [^] z2 \\<otimes> \\<^bold>g [^] (x * z2') \\<otimes> \\<^bold>g [^] (t * e) = \\<^bold>g [^] z1 \\<otimes> \\<^bold>g [^] (x * z1') \\<otimes> (\\<^bold>g [^] (t * e'))\""], ["proof (prove)\nusing this:\n  \\<^bold>g [^] z2 \\<otimes> g' [^] z2' \\<otimes> inv (h [^] e') =\n  \\<^bold>g [^] z1 \\<otimes> g' [^] z1' \\<otimes> inv (h [^] e)\n  h = \\<^bold>g [^] t\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^] z2 \\<otimes> \\<^bold>g [^] (x * z2') \\<otimes>\n    \\<^bold>g [^] (t * e) =\n    \\<^bold>g [^] z1 \\<otimes> \\<^bold>g [^] (x * z1') \\<otimes>\n    \\<^bold>g [^] (t * e')", "using assms(2) assms(4) cyclic_group_commute m_assoc g'_def nat_pow_pow"], ["proof (prove)\nusing this:\n  \\<^bold>g [^] z2 \\<otimes> g' [^] z2' \\<otimes> inv (h [^] e') =\n  \\<^bold>g [^] z1 \\<otimes> g' [^] z1' \\<otimes> inv (h [^] e)\n  h = \\<^bold>g [^] t\n  a \\<in> carrier \\<G>\n  \\<^bold>g [^] z1 \\<otimes> g' [^] z1' = a \\<otimes> h [^] e\n  \\<lbrakk>?a \\<in> carrier \\<G>; ?b \\<in> carrier \\<G>\\<rbrakk>\n  \\<Longrightarrow> ?a \\<otimes> ?b = ?b \\<otimes> ?a\n  \\<lbrakk>?x \\<in> carrier \\<G>; ?y \\<in> carrier \\<G>;\n   ?z \\<in> carrier \\<G>\\<rbrakk>\n  \\<Longrightarrow> ?x \\<otimes> ?y \\<otimes> ?z =\n                    ?x \\<otimes> (?y \\<otimes> ?z)\n  g' = \\<^bold>g [^] x\n  ?x \\<in> carrier \\<G> \\<Longrightarrow>\n  (?x [^] ?n) [^] ?m = ?x [^] (?n * ?m)\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^] z2 \\<otimes> \\<^bold>g [^] (x * z2') \\<otimes>\n    \\<^bold>g [^] (t * e) =\n    \\<^bold>g [^] z1 \\<otimes> \\<^bold>g [^] (x * z1') \\<otimes>\n    \\<^bold>g [^] (t * e')", "by auto"], ["proof (state)\nthis:\n  \\<^bold>g [^] z2 \\<otimes> \\<^bold>g [^] (x * z2') \\<otimes>\n  \\<^bold>g [^] (t * e) =\n  \\<^bold>g [^] z1 \\<otimes> \\<^bold>g [^] (x * z1') \\<otimes>\n  \\<^bold>g [^] (t * e')\n\ngoal (1 subgoal):\n 1. h =\n    \\<^bold>g [^]\n    ((int z1 - int z2) * Number_Theory_Aux.inverse (e - e') (order \\<G>) mod\n     int (order \\<G>)) \\<otimes>\n    g' [^]\n    ((int z1' - int z2') *\n     Number_Theory_Aux.inverse (e - e') (order \\<G>) mod\n     int (order \\<G>))", "hence \"\\<^bold>g [^] (z2 + x * z2' + t * e) = \\<^bold>g [^] (z1 + x * z1' + t * e')\""], ["proof (prove)\nusing this:\n  \\<^bold>g [^] z2 \\<otimes> \\<^bold>g [^] (x * z2') \\<otimes>\n  \\<^bold>g [^] (t * e) =\n  \\<^bold>g [^] z1 \\<otimes> \\<^bold>g [^] (x * z1') \\<otimes>\n  \\<^bold>g [^] (t * e')\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^] (z2 + x * z2' + t * e) =\n    \\<^bold>g [^] (z1 + x * z1' + t * e')", "by (simp add: nat_pow_mult)"], ["proof (state)\nthis:\n  \\<^bold>g [^] (z2 + x * z2' + t * e) =\n  \\<^bold>g [^] (z1 + x * z1' + t * e')\n\ngoal (1 subgoal):\n 1. h =\n    \\<^bold>g [^]\n    ((int z1 - int z2) * Number_Theory_Aux.inverse (e - e') (order \\<G>) mod\n     int (order \\<G>)) \\<otimes>\n    g' [^]\n    ((int z1' - int z2') *\n     Number_Theory_Aux.inverse (e - e') (order \\<G>) mod\n     int (order \\<G>))", "hence \"[z2 + x * z2' + t * e = z1 + x * z1' + t * e'] (mod order \\<G>)\""], ["proof (prove)\nusing this:\n  \\<^bold>g [^] (z2 + x * z2' + t * e) =\n  \\<^bold>g [^] (z1 + x * z1' + t * e')\n\ngoal (1 subgoal):\n 1. [z2 + x * z2' + t * e = z1 + x * z1' + t * e'] (mod order \\<G>)", "using group_eq_pow_eq_mod order_gt_0"], ["proof (prove)\nusing this:\n  \\<^bold>g [^] (z2 + x * z2' + t * e) =\n  \\<^bold>g [^] (z1 + x * z1' + t * e')\n  \\<lbrakk>\\<^bold>g [^] ?a = \\<^bold>g [^] ?b; 0 < order \\<G>\\<rbrakk>\n  \\<Longrightarrow> [?a = ?b] (mod order \\<G>)\n  0 < order \\<G>\n\ngoal (1 subgoal):\n 1. [z2 + x * z2' + t * e = z1 + x * z1' + t * e'] (mod order \\<G>)", "by blast"], ["proof (state)\nthis:\n  [z2 + x * z2' + t * e = z1 + x * z1' + t * e'] (mod order \\<G>)\n\ngoal (1 subgoal):\n 1. h =\n    \\<^bold>g [^]\n    ((int z1 - int z2) * Number_Theory_Aux.inverse (e - e') (order \\<G>) mod\n     int (order \\<G>)) \\<otimes>\n    g' [^]\n    ((int z1' - int z2') *\n     Number_Theory_Aux.inverse (e - e') (order \\<G>) mod\n     int (order \\<G>))", "hence \"[int z2 + int x * int z2' + int t * int e = int z1 + int x * int z1' + int t * int e'] (mod order \\<G>)\""], ["proof (prove)\nusing this:\n  [z2 + x * z2' + t * e = z1 + x * z1' + t * e'] (mod order \\<G>)\n\ngoal (1 subgoal):\n 1. [int z2 + int x * int z2' +\n     int t *\n     int e = int z1 + int x * int z1' +\n             int t * int e'] (mod int (order \\<G>))", "using cong_int_iff"], ["proof (prove)\nusing this:\n  [z2 + x * z2' + t * e = z1 + x * z1' + t * e'] (mod order \\<G>)\n  [int ?m = int ?q] (mod int ?n) = [?m = ?q] (mod ?n)\n\ngoal (1 subgoal):\n 1. [int z2 + int x * int z2' +\n     int t *\n     int e = int z1 + int x * int z1' +\n             int t * int e'] (mod int (order \\<G>))", "by force"], ["proof (state)\nthis:\n  [int z2 + int x * int z2' +\n   int t *\n   int e = int z1 + int x * int z1' + int t * int e'] (mod int (order \\<G>))\n\ngoal (1 subgoal):\n 1. h =\n    \\<^bold>g [^]\n    ((int z1 - int z2) * Number_Theory_Aux.inverse (e - e') (order \\<G>) mod\n     int (order \\<G>)) \\<otimes>\n    g' [^]\n    ((int z1' - int z2') *\n     Number_Theory_Aux.inverse (e - e') (order \\<G>) mod\n     int (order \\<G>))", "hence \"[int z1 + int x * int z1' - int z2 - int x * int z2' = int t * int e - int t * int e'] (mod order \\<G>)\""], ["proof (prove)\nusing this:\n  [int z2 + int x * int z2' +\n   int t *\n   int e = int z1 + int x * int z1' + int t * int e'] (mod int (order \\<G>))\n\ngoal (1 subgoal):\n 1. [int z1 + int x * int z1' - int z2 -\n     int x *\n     int z2' = int t * int e - int t * int e'] (mod int (order \\<G>))", "by (smt cong_diff_iff_cong_0 cong_sym)"], ["proof (state)\nthis:\n  [int z1 + int x * int z1' - int z2 -\n   int x * int z2' = int t * int e - int t * int e'] (mod int (order \\<G>))\n\ngoal (1 subgoal):\n 1. h =\n    \\<^bold>g [^]\n    ((int z1 - int z2) * Number_Theory_Aux.inverse (e - e') (order \\<G>) mod\n     int (order \\<G>)) \\<otimes>\n    g' [^]\n    ((int z1' - int z2') *\n     Number_Theory_Aux.inverse (e - e') (order \\<G>) mod\n     int (order \\<G>))", "hence \"[int z1 + int x * int z1' - int z2 - int x * int z2' = int t * (e - e')] (mod order \\<G>)\""], ["proof (prove)\nusing this:\n  [int z1 + int x * int z1' - int z2 -\n   int x * int z2' = int t * int e - int t * int e'] (mod int (order \\<G>))\n\ngoal (1 subgoal):\n 1. [int z1 + int x * int z1' - int z2 -\n     int x * int z2' = int t * int (e - e')] (mod int (order \\<G>))", "using int_distrib(4) assms"], ["proof (prove)\nusing this:\n  [int z1 + int x * int z1' - int z2 -\n   int x * int z2' = int t * int e - int t * int e'] (mod int (order \\<G>))\n  ?w * (?z1.0 - ?z2.0) = ?w * ?z1.0 - ?w * ?z2.0\n  h \\<in> carrier \\<G>\n  a \\<in> carrier \\<G>\n  e < order \\<G>\n  \\<^bold>g [^] z1 \\<otimes> g' [^] z1' = a \\<otimes> h [^] e\n  e' < e\n  \\<^bold>g [^] z2 \\<otimes> g' [^] z2' = a \\<otimes> h [^] e'\n\ngoal (1 subgoal):\n 1. [int z1 + int x * int z1' - int z2 -\n     int x * int z2' = int t * int (e - e')] (mod int (order \\<G>))", "by (simp add: of_nat_diff)"], ["proof (state)\nthis:\n  [int z1 + int x * int z1' - int z2 -\n   int x * int z2' = int t * int (e - e')] (mod int (order \\<G>))\n\ngoal (1 subgoal):\n 1. h =\n    \\<^bold>g [^]\n    ((int z1 - int z2) * Number_Theory_Aux.inverse (e - e') (order \\<G>) mod\n     int (order \\<G>)) \\<otimes>\n    g' [^]\n    ((int z1' - int z2') *\n     Number_Theory_Aux.inverse (e - e') (order \\<G>) mod\n     int (order \\<G>))", "hence \"[(int z1 + int x * int z1' - int z2 - int x * int z2') * fst (bezw (e - e') (order \\<G>)) = int t * (e - e') * fst (bezw (e - e') (order \\<G>))] (mod order \\<G>)\""], ["proof (prove)\nusing this:\n  [int z1 + int x * int z1' - int z2 -\n   int x * int z2' = int t * int (e - e')] (mod int (order \\<G>))\n\ngoal (1 subgoal):\n 1. [(int z1 + int x * int z1' - int z2 - int x * int z2') *\n     Number_Theory_Aux.inverse (e - e')\n      (order\n        \\<G>) = int t * int (e - e') *\n                Number_Theory_Aux.inverse (e - e')\n                 (order \\<G>)] (mod int (order \\<G>))", "using cong_scalar_right"], ["proof (prove)\nusing this:\n  [int z1 + int x * int z1' - int z2 -\n   int x * int z2' = int t * int (e - e')] (mod int (order \\<G>))\n  [?b = ?c] (mod ?a) \\<Longrightarrow> [?b * ?d = ?c * ?d] (mod ?a)\n\ngoal (1 subgoal):\n 1. [(int z1 + int x * int z1' - int z2 - int x * int z2') *\n     Number_Theory_Aux.inverse (e - e')\n      (order\n        \\<G>) = int t * int (e - e') *\n                Number_Theory_Aux.inverse (e - e')\n                 (order \\<G>)] (mod int (order \\<G>))", "by blast"], ["proof (state)\nthis:\n  [(int z1 + int x * int z1' - int z2 - int x * int z2') *\n   Number_Theory_Aux.inverse (e - e')\n    (order\n      \\<G>) = int t * int (e - e') *\n              Number_Theory_Aux.inverse (e - e')\n               (order \\<G>)] (mod int (order \\<G>))\n\ngoal (1 subgoal):\n 1. h =\n    \\<^bold>g [^]\n    ((int z1 - int z2) * Number_Theory_Aux.inverse (e - e') (order \\<G>) mod\n     int (order \\<G>)) \\<otimes>\n    g' [^]\n    ((int z1' - int z2') *\n     Number_Theory_Aux.inverse (e - e') (order \\<G>) mod\n     int (order \\<G>))", "hence \"[(int z1 + int x * int z1' - int z2 - int x * int z2') * fst (bezw (e - e') (order \\<G>)) = int t * ((e - e') * fst (bezw (e - e') (order \\<G>)))] (mod order \\<G>)\""], ["proof (prove)\nusing this:\n  [(int z1 + int x * int z1' - int z2 - int x * int z2') *\n   Number_Theory_Aux.inverse (e - e')\n    (order\n      \\<G>) = int t * int (e - e') *\n              Number_Theory_Aux.inverse (e - e')\n               (order \\<G>)] (mod int (order \\<G>))\n\ngoal (1 subgoal):\n 1. [(int z1 + int x * int z1' - int z2 - int x * int z2') *\n     Number_Theory_Aux.inverse (e - e')\n      (order\n        \\<G>) = int t *\n                (int (e - e') *\n                 Number_Theory_Aux.inverse (e - e')\n                  (order \\<G>))] (mod int (order \\<G>))", "by (simp add: mult.assoc)"], ["proof (state)\nthis:\n  [(int z1 + int x * int z1' - int z2 - int x * int z2') *\n   Number_Theory_Aux.inverse (e - e')\n    (order\n      \\<G>) = int t *\n              (int (e - e') *\n               Number_Theory_Aux.inverse (e - e')\n                (order \\<G>))] (mod int (order \\<G>))\n\ngoal (1 subgoal):\n 1. h =\n    \\<^bold>g [^]\n    ((int z1 - int z2) * Number_Theory_Aux.inverse (e - e') (order \\<G>) mod\n     int (order \\<G>)) \\<otimes>\n    g' [^]\n    ((int z1' - int z2') *\n     Number_Theory_Aux.inverse (e - e') (order \\<G>) mod\n     int (order \\<G>))", "hence \"[(int z1 + int x * int z1' - int z2 - int x * int z2') * fst (bezw (e - e') (order \\<G>)) = int t * 1] (mod order \\<G>)\""], ["proof (prove)\nusing this:\n  [(int z1 + int x * int z1' - int z2 - int x * int z2') *\n   Number_Theory_Aux.inverse (e - e')\n    (order\n      \\<G>) = int t *\n              (int (e - e') *\n               Number_Theory_Aux.inverse (e - e')\n                (order \\<G>))] (mod int (order \\<G>))\n\ngoal (1 subgoal):\n 1. [(int z1 + int x * int z1' - int z2 - int x * int z2') *\n     Number_Theory_Aux.inverse (e - e')\n      (order \\<G>) = int t * 1] (mod int (order \\<G>))", "by (metis (no_types, hide_lams) cong_scalar_left cong_trans inverse gcd)"], ["proof (state)\nthis:\n  [(int z1 + int x * int z1' - int z2 - int x * int z2') *\n   Number_Theory_Aux.inverse (e - e')\n    (order \\<G>) = int t * 1] (mod int (order \\<G>))\n\ngoal (1 subgoal):\n 1. h =\n    \\<^bold>g [^]\n    ((int z1 - int z2) * Number_Theory_Aux.inverse (e - e') (order \\<G>) mod\n     int (order \\<G>)) \\<otimes>\n    g' [^]\n    ((int z1' - int z2') *\n     Number_Theory_Aux.inverse (e - e') (order \\<G>) mod\n     int (order \\<G>))", "hence \"[(int z1 - int z2 + int x * int z1' - int x * int z2') * fst (bezw (e - e') (order \\<G>)) = int t] (mod order \\<G>)\""], ["proof (prove)\nusing this:\n  [(int z1 + int x * int z1' - int z2 - int x * int z2') *\n   Number_Theory_Aux.inverse (e - e')\n    (order \\<G>) = int t * 1] (mod int (order \\<G>))\n\ngoal (1 subgoal):\n 1. [(int z1 - int z2 + int x * int z1' - int x * int z2') *\n     Number_Theory_Aux.inverse (e - e')\n      (order \\<G>) = int t] (mod int (order \\<G>))", "by smt"], ["proof (state)\nthis:\n  [(int z1 - int z2 + int x * int z1' - int x * int z2') *\n   Number_Theory_Aux.inverse (e - e')\n    (order \\<G>) = int t] (mod int (order \\<G>))\n\ngoal (1 subgoal):\n 1. h =\n    \\<^bold>g [^]\n    ((int z1 - int z2) * Number_Theory_Aux.inverse (e - e') (order \\<G>) mod\n     int (order \\<G>)) \\<otimes>\n    g' [^]\n    ((int z1' - int z2') *\n     Number_Theory_Aux.inverse (e - e') (order \\<G>) mod\n     int (order \\<G>))", "hence \"[(int z1 - int z2 + int x * (int z1' - int z2')) * fst (bezw (e - e') (order \\<G>)) = int t] (mod order \\<G>)\""], ["proof (prove)\nusing this:\n  [(int z1 - int z2 + int x * int z1' - int x * int z2') *\n   Number_Theory_Aux.inverse (e - e')\n    (order \\<G>) = int t] (mod int (order \\<G>))\n\ngoal (1 subgoal):\n 1. [(int z1 - int z2 + int x * (int z1' - int z2')) *\n     Number_Theory_Aux.inverse (e - e')\n      (order \\<G>) = int t] (mod int (order \\<G>))", "by (simp add: Rings.ring_distribs(4) add_diff_eq)"], ["proof (state)\nthis:\n  [(int z1 - int z2 + int x * (int z1' - int z2')) *\n   Number_Theory_Aux.inverse (e - e')\n    (order \\<G>) = int t] (mod int (order \\<G>))\n\ngoal (1 subgoal):\n 1. h =\n    \\<^bold>g [^]\n    ((int z1 - int z2) * Number_Theory_Aux.inverse (e - e') (order \\<G>) mod\n     int (order \\<G>)) \\<otimes>\n    g' [^]\n    ((int z1' - int z2') *\n     Number_Theory_Aux.inverse (e - e') (order \\<G>) mod\n     int (order \\<G>))", "hence \"[nat ((int z1 - int z2 + int x * (int z1' - int z2')) * fst (bezw (e - e') (order \\<G>)) mod (order \\<G>)) = int t] (mod order \\<G>)\""], ["proof (prove)\nusing this:\n  [(int z1 - int z2 + int x * (int z1' - int z2')) *\n   Number_Theory_Aux.inverse (e - e')\n    (order \\<G>) = int t] (mod int (order \\<G>))\n\ngoal (1 subgoal):\n 1. [int (nat ((int z1 - int z2 + int x * (int z1' - int z2')) *\n               Number_Theory_Aux.inverse (e - e') (order \\<G>) mod\n               int (order \\<G>))) = int t] (mod int (order \\<G>))", "by auto"], ["proof (state)\nthis:\n  [int (nat ((int z1 - int z2 + int x * (int z1' - int z2')) *\n             Number_Theory_Aux.inverse (e - e') (order \\<G>) mod\n             int (order \\<G>))) = int t] (mod int (order \\<G>))\n\ngoal (1 subgoal):\n 1. h =\n    \\<^bold>g [^]\n    ((int z1 - int z2) * Number_Theory_Aux.inverse (e - e') (order \\<G>) mod\n     int (order \\<G>)) \\<otimes>\n    g' [^]\n    ((int z1' - int z2') *\n     Number_Theory_Aux.inverse (e - e') (order \\<G>) mod\n     int (order \\<G>))", "hence \"\\<^bold>g [^] (nat ((int z1 - int z2 + int x * (int z1' - int z2')) * fst (bezw (e - e') (order \\<G>)) mod (order \\<G>))) = \\<^bold>g [^] t\""], ["proof (prove)\nusing this:\n  [int (nat ((int z1 - int z2 + int x * (int z1' - int z2')) *\n             Number_Theory_Aux.inverse (e - e') (order \\<G>) mod\n             int (order \\<G>))) = int t] (mod int (order \\<G>))\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^]\n    nat ((int z1 - int z2 + int x * (int z1' - int z2')) *\n         Number_Theory_Aux.inverse (e - e') (order \\<G>) mod\n         int (order \\<G>)) =\n    \\<^bold>g [^] t", "using cong_int_iff finite_carrier pow_generator_eq_iff_cong"], ["proof (prove)\nusing this:\n  [int (nat ((int z1 - int z2 + int x * (int z1' - int z2')) *\n             Number_Theory_Aux.inverse (e - e') (order \\<G>) mod\n             int (order \\<G>))) = int t] (mod int (order \\<G>))\n  [int ?m = int ?q] (mod int ?n) = [?m = ?q] (mod ?n)\n  finite (carrier \\<G>)\n  finite (carrier \\<G>) \\<Longrightarrow>\n  (\\<^bold>g [^] ?x = \\<^bold>g [^] ?y) = [?x = ?y] (mod order \\<G>)\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^]\n    nat ((int z1 - int z2 + int x * (int z1' - int z2')) *\n         Number_Theory_Aux.inverse (e - e') (order \\<G>) mod\n         int (order \\<G>)) =\n    \\<^bold>g [^] t", "by blast"], ["proof (state)\nthis:\n  \\<^bold>g [^]\n  nat ((int z1 - int z2 + int x * (int z1' - int z2')) *\n       Number_Theory_Aux.inverse (e - e') (order \\<G>) mod\n       int (order \\<G>)) =\n  \\<^bold>g [^] t\n\ngoal (1 subgoal):\n 1. h =\n    \\<^bold>g [^]\n    ((int z1 - int z2) * Number_Theory_Aux.inverse (e - e') (order \\<G>) mod\n     int (order \\<G>)) \\<otimes>\n    g' [^]\n    ((int z1' - int z2') *\n     Number_Theory_Aux.inverse (e - e') (order \\<G>) mod\n     int (order \\<G>))", "hence \"\\<^bold>g [^] ((int z1 - int z2 + int x * (int z1' - int z2')) * fst (bezw (e - e') (order \\<G>))) = \\<^bold>g [^] t\""], ["proof (prove)\nusing this:\n  \\<^bold>g [^]\n  nat ((int z1 - int z2 + int x * (int z1' - int z2')) *\n       Number_Theory_Aux.inverse (e - e') (order \\<G>) mod\n       int (order \\<G>)) =\n  \\<^bold>g [^] t\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^]\n    ((int z1 - int z2 + int x * (int z1' - int z2')) *\n     Number_Theory_Aux.inverse (e - e') (order \\<G>)) =\n    \\<^bold>g [^] t", "using pow_generator_mod_int"], ["proof (prove)\nusing this:\n  \\<^bold>g [^]\n  nat ((int z1 - int z2 + int x * (int z1' - int z2')) *\n       Number_Theory_Aux.inverse (e - e') (order \\<G>) mod\n       int (order \\<G>)) =\n  \\<^bold>g [^] t\n  \\<^bold>g [^] (?k mod int (order \\<G>)) = \\<^bold>g [^] ?k\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^]\n    ((int z1 - int z2 + int x * (int z1' - int z2')) *\n     Number_Theory_Aux.inverse (e - e') (order \\<G>)) =\n    \\<^bold>g [^] t", "by auto"], ["proof (state)\nthis:\n  \\<^bold>g [^]\n  ((int z1 - int z2 + int x * (int z1' - int z2')) *\n   Number_Theory_Aux.inverse (e - e') (order \\<G>)) =\n  \\<^bold>g [^] t\n\ngoal (1 subgoal):\n 1. h =\n    \\<^bold>g [^]\n    ((int z1 - int z2) * Number_Theory_Aux.inverse (e - e') (order \\<G>) mod\n     int (order \\<G>)) \\<otimes>\n    g' [^]\n    ((int z1' - int z2') *\n     Number_Theory_Aux.inverse (e - e') (order \\<G>) mod\n     int (order \\<G>))", "hence \"\\<^bold>g [^] ((int z1 - int z2) * fst (bezw (e - e') (order \\<G>)) + int x * (int z1' - int z2') * fst (bezw (e - e') (order \\<G>))) = \\<^bold>g [^] t\""], ["proof (prove)\nusing this:\n  \\<^bold>g [^]\n  ((int z1 - int z2 + int x * (int z1' - int z2')) *\n   Number_Theory_Aux.inverse (e - e') (order \\<G>)) =\n  \\<^bold>g [^] t\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^]\n    ((int z1 - int z2) * Number_Theory_Aux.inverse (e - e') (order \\<G>) +\n     int x * (int z1' - int z2') *\n     Number_Theory_Aux.inverse (e - e') (order \\<G>)) =\n    \\<^bold>g [^] t", "by (metis Rings.ring_distribs(2) t)"], ["proof (state)\nthis:\n  \\<^bold>g [^]\n  ((int z1 - int z2) * Number_Theory_Aux.inverse (e - e') (order \\<G>) +\n   int x * (int z1' - int z2') *\n   Number_Theory_Aux.inverse (e - e') (order \\<G>)) =\n  \\<^bold>g [^] t\n\ngoal (1 subgoal):\n 1. h =\n    \\<^bold>g [^]\n    ((int z1 - int z2) * Number_Theory_Aux.inverse (e - e') (order \\<G>) mod\n     int (order \\<G>)) \\<otimes>\n    g' [^]\n    ((int z1' - int z2') *\n     Number_Theory_Aux.inverse (e - e') (order \\<G>) mod\n     int (order \\<G>))", "hence \"\\<^bold>g [^] ((int z1 - int z2) * fst (bezw (e - e') (order \\<G>))) \\<otimes> \\<^bold>g [^] (int x * (int z1' - int z2') * fst (bezw (e - e') (order \\<G>))) = \\<^bold>g [^] t\""], ["proof (prove)\nusing this:\n  \\<^bold>g [^]\n  ((int z1 - int z2) * Number_Theory_Aux.inverse (e - e') (order \\<G>) +\n   int x * (int z1' - int z2') *\n   Number_Theory_Aux.inverse (e - e') (order \\<G>)) =\n  \\<^bold>g [^] t\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^]\n    ((int z1 - int z2) *\n     Number_Theory_Aux.inverse (e - e') (order \\<G>)) \\<otimes>\n    \\<^bold>g [^]\n    (int x * (int z1' - int z2') *\n     Number_Theory_Aux.inverse (e - e') (order \\<G>)) =\n    \\<^bold>g [^] t", "using int_pow_mult"], ["proof (prove)\nusing this:\n  \\<^bold>g [^]\n  ((int z1 - int z2) * Number_Theory_Aux.inverse (e - e') (order \\<G>) +\n   int x * (int z1' - int z2') *\n   Number_Theory_Aux.inverse (e - e') (order \\<G>)) =\n  \\<^bold>g [^] t\n  ?x \\<in> carrier \\<G> \\<Longrightarrow>\n  ?x [^] (?i + ?j) = ?x [^] ?i \\<otimes> ?x [^] ?j\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^]\n    ((int z1 - int z2) *\n     Number_Theory_Aux.inverse (e - e') (order \\<G>)) \\<otimes>\n    \\<^bold>g [^]\n    (int x * (int z1' - int z2') *\n     Number_Theory_Aux.inverse (e - e') (order \\<G>)) =\n    \\<^bold>g [^] t", "by auto"], ["proof (state)\nthis:\n  \\<^bold>g [^]\n  ((int z1 - int z2) *\n   Number_Theory_Aux.inverse (e - e') (order \\<G>)) \\<otimes>\n  \\<^bold>g [^]\n  (int x * (int z1' - int z2') *\n   Number_Theory_Aux.inverse (e - e') (order \\<G>)) =\n  \\<^bold>g [^] t\n\ngoal (1 subgoal):\n 1. h =\n    \\<^bold>g [^]\n    ((int z1 - int z2) * Number_Theory_Aux.inverse (e - e') (order \\<G>) mod\n     int (order \\<G>)) \\<otimes>\n    g' [^]\n    ((int z1' - int z2') *\n     Number_Theory_Aux.inverse (e - e') (order \\<G>) mod\n     int (order \\<G>))", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<^bold>g [^]\n  ((int z1 - int z2) *\n   Number_Theory_Aux.inverse (e - e') (order \\<G>)) \\<otimes>\n  \\<^bold>g [^]\n  (int x * (int z1' - int z2') *\n   Number_Theory_Aux.inverse (e - e') (order \\<G>)) =\n  \\<^bold>g [^] t\n\ngoal (1 subgoal):\n 1. h =\n    \\<^bold>g [^]\n    ((int z1 - int z2) * Number_Theory_Aux.inverse (e - e') (order \\<G>) mod\n     int (order \\<G>)) \\<otimes>\n    g' [^]\n    ((int z1' - int z2') *\n     Number_Theory_Aux.inverse (e - e') (order \\<G>) mod\n     int (order \\<G>))", "by (metis (mono_tags, hide_lams) g'_def generator_closed int_pow_int int_pow_pow mod_mult_right_eq more_arith_simps(11) pow_generator_mod_int t)"], ["proof (state)\nthis:\n  h =\n  \\<^bold>g [^]\n  ((int z1 - int z2) * Number_Theory_Aux.inverse (e - e') (order \\<G>) mod\n   int (order \\<G>)) \\<otimes>\n  g' [^]\n  ((int z1' - int z2') * Number_Theory_Aux.inverse (e - e') (order \\<G>) mod\n   int (order \\<G>))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma \n  assumes h_mem: \"h \\<in> carrier \\<G>\" \n    and a_mem: \"a \\<in> carrier \\<G>\" \n    and a: \"\\<^bold>g [^] fst z \\<otimes> g' [^] snd z = a \\<otimes> h [^] e\"\n    and a': \"\\<^bold>g [^] fst z' \\<otimes> g' [^] snd z' = a \\<otimes> h [^] e'\"\n    and e_e'_mod: \"e' mod order \\<G> < e mod order \\<G>\"\n  shows \"h = \\<^bold>g [^] ((int (fst z) - int (fst z')) * fst (bezw ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>) (order \\<G>)) mod int (order \\<G>)) \n              \\<otimes> g' [^] ((int (snd z) - int (snd z')) * fst (bezw ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>) (order \\<G>)) mod int (order \\<G>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h =\n    \\<^bold>g [^]\n    ((int (fst z) - int (fst z')) *\n     Number_Theory_Aux.inverse\n      ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n      (order \\<G>) mod\n     int (order \\<G>)) \\<otimes>\n    g' [^]\n    ((int (snd z) - int (snd z')) *\n     Number_Theory_Aux.inverse\n      ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n      (order \\<G>) mod\n     int (order \\<G>))", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. h =\n    \\<^bold>g [^]\n    ((int (fst z) - int (fst z')) *\n     Number_Theory_Aux.inverse\n      ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n      (order \\<G>) mod\n     int (order \\<G>)) \\<otimes>\n    g' [^]\n    ((int (snd z) - int (snd z')) *\n     Number_Theory_Aux.inverse\n      ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n      (order \\<G>) mod\n     int (order \\<G>))", "have gcd: \"gcd ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>) (order \\<G>) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gcd ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n     (order \\<G>) =\n    1", "using prime_field"], ["proof (prove)\nusing this:\n  \\<lbrakk>prime ?q; ?a < ?q; ?a \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> coprime ?a ?q\n\ngoal (1 subgoal):\n 1. gcd ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n     (order \\<G>) =\n    1", "by (simp add: assms less_imp_diff_less linorder_not_le prime_order)"], ["proof (state)\nthis:\n  gcd ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>) (order \\<G>) =\n  1\n\ngoal (1 subgoal):\n 1. h =\n    \\<^bold>g [^]\n    ((int (fst z) - int (fst z')) *\n     Number_Theory_Aux.inverse\n      ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n      (order \\<G>) mod\n     int (order \\<G>)) \\<otimes>\n    g' [^]\n    ((int (snd z) - int (snd z')) *\n     Number_Theory_Aux.inverse\n      ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n      (order \\<G>) mod\n     int (order \\<G>))", "have \"\\<^bold>g [^] fst z \\<otimes> g' [^] snd z \\<otimes> inv (h [^] e) = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<^bold>g [^] fst z \\<otimes> g' [^] snd z \\<otimes> inv (h [^] e) = a", "using a h_mem a_mem"], ["proof (prove)\nusing this:\n  \\<^bold>g [^] fst z \\<otimes> g' [^] snd z = a \\<otimes> h [^] e\n  h \\<in> carrier \\<G>\n  a \\<in> carrier \\<G>\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^] fst z \\<otimes> g' [^] snd z \\<otimes> inv (h [^] e) = a", "by (simp add: inv_solve_right')"], ["proof (state)\nthis:\n  \\<^bold>g [^] fst z \\<otimes> g' [^] snd z \\<otimes> inv (h [^] e) = a\n\ngoal (1 subgoal):\n 1. h =\n    \\<^bold>g [^]\n    ((int (fst z) - int (fst z')) *\n     Number_Theory_Aux.inverse\n      ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n      (order \\<G>) mod\n     int (order \\<G>)) \\<otimes>\n    g' [^]\n    ((int (snd z) - int (snd z')) *\n     Number_Theory_Aux.inverse\n      ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n      (order \\<G>) mod\n     int (order \\<G>))", "moreover"], ["proof (state)\nthis:\n  \\<^bold>g [^] fst z \\<otimes> g' [^] snd z \\<otimes> inv (h [^] e) = a\n\ngoal (1 subgoal):\n 1. h =\n    \\<^bold>g [^]\n    ((int (fst z) - int (fst z')) *\n     Number_Theory_Aux.inverse\n      ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n      (order \\<G>) mod\n     int (order \\<G>)) \\<otimes>\n    g' [^]\n    ((int (snd z) - int (snd z')) *\n     Number_Theory_Aux.inverse\n      ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n      (order \\<G>) mod\n     int (order \\<G>))", "have \"\\<^bold>g [^] fst z' \\<otimes> g' [^] snd z' \\<otimes> inv (h [^] e') = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<^bold>g [^] fst z' \\<otimes> g' [^] snd z' \\<otimes> inv (h [^] e') =\n    a", "using a h_mem a_mem"], ["proof (prove)\nusing this:\n  \\<^bold>g [^] fst z \\<otimes> g' [^] snd z = a \\<otimes> h [^] e\n  h \\<in> carrier \\<G>\n  a \\<in> carrier \\<G>\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^] fst z' \\<otimes> g' [^] snd z' \\<otimes> inv (h [^] e') =\n    a", "by (simp add: assms(4) inv_solve_right')"], ["proof (state)\nthis:\n  \\<^bold>g [^] fst z' \\<otimes> g' [^] snd z' \\<otimes> inv (h [^] e') = a\n\ngoal (1 subgoal):\n 1. h =\n    \\<^bold>g [^]\n    ((int (fst z) - int (fst z')) *\n     Number_Theory_Aux.inverse\n      ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n      (order \\<G>) mod\n     int (order \\<G>)) \\<otimes>\n    g' [^]\n    ((int (snd z) - int (snd z')) *\n     Number_Theory_Aux.inverse\n      ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n      (order \\<G>) mod\n     int (order \\<G>))", "ultimately"], ["proof (chain)\npicking this:\n  \\<^bold>g [^] fst z \\<otimes> g' [^] snd z \\<otimes> inv (h [^] e) = a\n  \\<^bold>g [^] fst z' \\<otimes> g' [^] snd z' \\<otimes> inv (h [^] e') = a", "have \"\\<^bold>g [^] fst z \\<otimes> \\<^bold>g [^] (x * snd z) \\<otimes> inv (h [^] e) = \\<^bold>g [^] fst z' \\<otimes> \\<^bold>g [^] (x * snd z') \\<otimes> inv (h [^] e')\""], ["proof (prove)\nusing this:\n  \\<^bold>g [^] fst z \\<otimes> g' [^] snd z \\<otimes> inv (h [^] e) = a\n  \\<^bold>g [^] fst z' \\<otimes> g' [^] snd z' \\<otimes> inv (h [^] e') = a\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^] fst z \\<otimes> \\<^bold>g [^] (x * snd z) \\<otimes>\n    inv (h [^] e) =\n    \\<^bold>g [^] fst z' \\<otimes> \\<^bold>g [^] (x * snd z') \\<otimes>\n    inv (h [^] e')", "using g'_def"], ["proof (prove)\nusing this:\n  \\<^bold>g [^] fst z \\<otimes> g' [^] snd z \\<otimes> inv (h [^] e) = a\n  \\<^bold>g [^] fst z' \\<otimes> g' [^] snd z' \\<otimes> inv (h [^] e') = a\n  g' = \\<^bold>g [^] x\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^] fst z \\<otimes> \\<^bold>g [^] (x * snd z) \\<otimes>\n    inv (h [^] e) =\n    \\<^bold>g [^] fst z' \\<otimes> \\<^bold>g [^] (x * snd z') \\<otimes>\n    inv (h [^] e')", "by (simp add: nat_pow_pow)"], ["proof (state)\nthis:\n  \\<^bold>g [^] fst z \\<otimes> \\<^bold>g [^] (x * snd z) \\<otimes>\n  inv (h [^] e) =\n  \\<^bold>g [^] fst z' \\<otimes> \\<^bold>g [^] (x * snd z') \\<otimes>\n  inv (h [^] e')\n\ngoal (1 subgoal):\n 1. h =\n    \\<^bold>g [^]\n    ((int (fst z) - int (fst z')) *\n     Number_Theory_Aux.inverse\n      ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n      (order \\<G>) mod\n     int (order \\<G>)) \\<otimes>\n    g' [^]\n    ((int (snd z) - int (snd z')) *\n     Number_Theory_Aux.inverse\n      ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n      (order \\<G>) mod\n     int (order \\<G>))", "moreover"], ["proof (state)\nthis:\n  \\<^bold>g [^] fst z \\<otimes> \\<^bold>g [^] (x * snd z) \\<otimes>\n  inv (h [^] e) =\n  \\<^bold>g [^] fst z' \\<otimes> \\<^bold>g [^] (x * snd z') \\<otimes>\n  inv (h [^] e')\n\ngoal (1 subgoal):\n 1. h =\n    \\<^bold>g [^]\n    ((int (fst z) - int (fst z')) *\n     Number_Theory_Aux.inverse\n      ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n      (order \\<G>) mod\n     int (order \\<G>)) \\<otimes>\n    g' [^]\n    ((int (snd z) - int (snd z')) *\n     Number_Theory_Aux.inverse\n      ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n      (order \\<G>) mod\n     int (order \\<G>))", "obtain t :: nat where t: \"h = \\<^bold>g [^] t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>t.\n        h = \\<^bold>g [^] t \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using h_mem generatorE"], ["proof (prove)\nusing this:\n  h \\<in> carrier \\<G>\n  \\<lbrakk>?x \\<in> carrier \\<G>;\n   \\<And>n. ?x = \\<^bold>g [^] n \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        h = \\<^bold>g [^] t \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  h = \\<^bold>g [^] t\n\ngoal (1 subgoal):\n 1. h =\n    \\<^bold>g [^]\n    ((int (fst z) - int (fst z')) *\n     Number_Theory_Aux.inverse\n      ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n      (order \\<G>) mod\n     int (order \\<G>)) \\<otimes>\n    g' [^]\n    ((int (snd z) - int (snd z')) *\n     Number_Theory_Aux.inverse\n      ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n      (order \\<G>) mod\n     int (order \\<G>))", "ultimately"], ["proof (chain)\npicking this:\n  \\<^bold>g [^] fst z \\<otimes> \\<^bold>g [^] (x * snd z) \\<otimes>\n  inv (h [^] e) =\n  \\<^bold>g [^] fst z' \\<otimes> \\<^bold>g [^] (x * snd z') \\<otimes>\n  inv (h [^] e')\n  h = \\<^bold>g [^] t", "have \"\\<^bold>g [^] fst z \\<otimes> \\<^bold>g [^] (x * snd z) \\<otimes> \\<^bold>g [^] (t * e') = \\<^bold>g [^] fst z' \\<otimes> \\<^bold>g [^] (x * snd z') \\<otimes> \\<^bold>g [^] (t * e)\""], ["proof (prove)\nusing this:\n  \\<^bold>g [^] fst z \\<otimes> \\<^bold>g [^] (x * snd z) \\<otimes>\n  inv (h [^] e) =\n  \\<^bold>g [^] fst z' \\<otimes> \\<^bold>g [^] (x * snd z') \\<otimes>\n  inv (h [^] e')\n  h = \\<^bold>g [^] t\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^] fst z \\<otimes> \\<^bold>g [^] (x * snd z) \\<otimes>\n    \\<^bold>g [^] (t * e') =\n    \\<^bold>g [^] fst z' \\<otimes> \\<^bold>g [^] (x * snd z') \\<otimes>\n    \\<^bold>g [^] (t * e)", "using a_mem assms(3) assms(4) cyclic_group_assoc cyclic_group_commute g'_def nat_pow_pow"], ["proof (prove)\nusing this:\n  \\<^bold>g [^] fst z \\<otimes> \\<^bold>g [^] (x * snd z) \\<otimes>\n  inv (h [^] e) =\n  \\<^bold>g [^] fst z' \\<otimes> \\<^bold>g [^] (x * snd z') \\<otimes>\n  inv (h [^] e')\n  h = \\<^bold>g [^] t\n  a \\<in> carrier \\<G>\n  \\<^bold>g [^] fst z \\<otimes> g' [^] snd z = a \\<otimes> h [^] e\n  \\<^bold>g [^] fst z' \\<otimes> g' [^] snd z' = a \\<otimes> h [^] e'\n  \\<lbrakk>?a \\<in> carrier \\<G>; ?b \\<in> carrier \\<G>;\n   ?c \\<in> carrier \\<G>\\<rbrakk>\n  \\<Longrightarrow> ?a \\<otimes> ?b \\<otimes> ?c =\n                    ?a \\<otimes> (?b \\<otimes> ?c)\n  \\<lbrakk>?a \\<in> carrier \\<G>; ?b \\<in> carrier \\<G>\\<rbrakk>\n  \\<Longrightarrow> ?a \\<otimes> ?b = ?b \\<otimes> ?a\n  g' = \\<^bold>g [^] x\n  ?x \\<in> carrier \\<G> \\<Longrightarrow>\n  (?x [^] ?n) [^] ?m = ?x [^] (?n * ?m)\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^] fst z \\<otimes> \\<^bold>g [^] (x * snd z) \\<otimes>\n    \\<^bold>g [^] (t * e') =\n    \\<^bold>g [^] fst z' \\<otimes> \\<^bold>g [^] (x * snd z') \\<otimes>\n    \\<^bold>g [^] (t * e)", "by auto"], ["proof (state)\nthis:\n  \\<^bold>g [^] fst z \\<otimes> \\<^bold>g [^] (x * snd z) \\<otimes>\n  \\<^bold>g [^] (t * e') =\n  \\<^bold>g [^] fst z' \\<otimes> \\<^bold>g [^] (x * snd z') \\<otimes>\n  \\<^bold>g [^] (t * e)\n\ngoal (1 subgoal):\n 1. h =\n    \\<^bold>g [^]\n    ((int (fst z) - int (fst z')) *\n     Number_Theory_Aux.inverse\n      ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n      (order \\<G>) mod\n     int (order \\<G>)) \\<otimes>\n    g' [^]\n    ((int (snd z) - int (snd z')) *\n     Number_Theory_Aux.inverse\n      ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n      (order \\<G>) mod\n     int (order \\<G>))", "hence \"\\<^bold>g [^] (fst z + x * snd z + t * e') = \\<^bold>g [^] (fst z' + x * snd z' + t * e)\""], ["proof (prove)\nusing this:\n  \\<^bold>g [^] fst z \\<otimes> \\<^bold>g [^] (x * snd z) \\<otimes>\n  \\<^bold>g [^] (t * e') =\n  \\<^bold>g [^] fst z' \\<otimes> \\<^bold>g [^] (x * snd z') \\<otimes>\n  \\<^bold>g [^] (t * e)\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^] (fst z + x * snd z + t * e') =\n    \\<^bold>g [^] (fst z' + x * snd z' + t * e)", "by (simp add: nat_pow_mult)"], ["proof (state)\nthis:\n  \\<^bold>g [^] (fst z + x * snd z + t * e') =\n  \\<^bold>g [^] (fst z' + x * snd z' + t * e)\n\ngoal (1 subgoal):\n 1. h =\n    \\<^bold>g [^]\n    ((int (fst z) - int (fst z')) *\n     Number_Theory_Aux.inverse\n      ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n      (order \\<G>) mod\n     int (order \\<G>)) \\<otimes>\n    g' [^]\n    ((int (snd z) - int (snd z')) *\n     Number_Theory_Aux.inverse\n      ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n      (order \\<G>) mod\n     int (order \\<G>))", "hence \"[fst z + x * snd z + t * e' = fst z' + x * snd z' + t * e] (mod order \\<G>)\""], ["proof (prove)\nusing this:\n  \\<^bold>g [^] (fst z + x * snd z + t * e') =\n  \\<^bold>g [^] (fst z' + x * snd z' + t * e)\n\ngoal (1 subgoal):\n 1. [fst z + x * snd z +\n     t * e' = fst z' + x * snd z' + t * e] (mod order \\<G>)", "using group_eq_pow_eq_mod order_gt_0"], ["proof (prove)\nusing this:\n  \\<^bold>g [^] (fst z + x * snd z + t * e') =\n  \\<^bold>g [^] (fst z' + x * snd z' + t * e)\n  \\<lbrakk>\\<^bold>g [^] ?a = \\<^bold>g [^] ?b; 0 < order \\<G>\\<rbrakk>\n  \\<Longrightarrow> [?a = ?b] (mod order \\<G>)\n  0 < order \\<G>\n\ngoal (1 subgoal):\n 1. [fst z + x * snd z +\n     t * e' = fst z' + x * snd z' + t * e] (mod order \\<G>)", "by blast"], ["proof (state)\nthis:\n  [fst z + x * snd z +\n   t * e' = fst z' + x * snd z' + t * e] (mod order \\<G>)\n\ngoal (1 subgoal):\n 1. h =\n    \\<^bold>g [^]\n    ((int (fst z) - int (fst z')) *\n     Number_Theory_Aux.inverse\n      ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n      (order \\<G>) mod\n     int (order \\<G>)) \\<otimes>\n    g' [^]\n    ((int (snd z) - int (snd z')) *\n     Number_Theory_Aux.inverse\n      ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n      (order \\<G>) mod\n     int (order \\<G>))", "hence \"[int (fst z) + int x * int (snd z) + int t * int e' = int (fst z') + int x * int (snd z') + int t * int e] (mod order \\<G>)\""], ["proof (prove)\nusing this:\n  [fst z + x * snd z +\n   t * e' = fst z' + x * snd z' + t * e] (mod order \\<G>)\n\ngoal (1 subgoal):\n 1. [int (fst z) + int x * int (snd z) +\n     int t *\n     int e' = int (fst z') + int x * int (snd z') +\n              int t * int e] (mod int (order \\<G>))", "using cong_int_iff"], ["proof (prove)\nusing this:\n  [fst z + x * snd z +\n   t * e' = fst z' + x * snd z' + t * e] (mod order \\<G>)\n  [int ?m = int ?q] (mod int ?n) = [?m = ?q] (mod ?n)\n\ngoal (1 subgoal):\n 1. [int (fst z) + int x * int (snd z) +\n     int t *\n     int e' = int (fst z') + int x * int (snd z') +\n              int t * int e] (mod int (order \\<G>))", "by force"], ["proof (state)\nthis:\n  [int (fst z) + int x * int (snd z) +\n   int t *\n   int e' = int (fst z') + int x * int (snd z') +\n            int t * int e] (mod int (order \\<G>))\n\ngoal (1 subgoal):\n 1. h =\n    \\<^bold>g [^]\n    ((int (fst z) - int (fst z')) *\n     Number_Theory_Aux.inverse\n      ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n      (order \\<G>) mod\n     int (order \\<G>)) \\<otimes>\n    g' [^]\n    ((int (snd z) - int (snd z')) *\n     Number_Theory_Aux.inverse\n      ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n      (order \\<G>) mod\n     int (order \\<G>))", "hence \"[int (fst z) - int (fst z') + int x * int (snd z) - int x * int (snd z') =  int t * int e - int t  * int e'] (mod order \\<G>)\""], ["proof (prove)\nusing this:\n  [int (fst z) + int x * int (snd z) +\n   int t *\n   int e' = int (fst z') + int x * int (snd z') +\n            int t * int e] (mod int (order \\<G>))\n\ngoal (1 subgoal):\n 1. [int (fst z) - int (fst z') + int x * int (snd z) -\n     int x *\n     int (snd z') = int t * int e - int t * int e'] (mod int (order \\<G>))", "by (smt cong_diff_iff_cong_0)"], ["proof (state)\nthis:\n  [int (fst z) - int (fst z') + int x * int (snd z) -\n   int x *\n   int (snd z') = int t * int e - int t * int e'] (mod int (order \\<G>))\n\ngoal (1 subgoal):\n 1. h =\n    \\<^bold>g [^]\n    ((int (fst z) - int (fst z')) *\n     Number_Theory_Aux.inverse\n      ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n      (order \\<G>) mod\n     int (order \\<G>)) \\<otimes>\n    g' [^]\n    ((int (snd z) - int (snd z')) *\n     Number_Theory_Aux.inverse\n      ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n      (order \\<G>) mod\n     int (order \\<G>))", "hence \"[int (fst z) - int (fst z') + int x * (int (snd z) - int (snd z')) =  int t * (int e -  int e')] (mod order \\<G>)\""], ["proof (prove)\nusing this:\n  [int (fst z) - int (fst z') + int x * int (snd z) -\n   int x *\n   int (snd z') = int t * int e - int t * int e'] (mod int (order \\<G>))\n\ngoal (1 subgoal):\n 1. [int (fst z) - int (fst z') +\n     int x *\n     (int (snd z) -\n      int (snd z')) = int t * (int e - int e')] (mod int (order \\<G>))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. [int (fst z) - int (fst z') + int x * int (snd z) -\n     int x *\n     int (snd z') = int t * int e -\n                    int t * int e'] (mod int (order \\<G>)) \\<Longrightarrow>\n    [int (fst z) - int (fst z') +\n     int x *\n     (int (snd z) -\n      int (snd z')) = int t * (int e - int e')] (mod int (order \\<G>))", "have \"[int (fst z) + (int (x * snd z) - (int (fst z') + int (x * snd z'))) = int t * (int e - int e')] (mod int (order \\<G>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [int (fst z) +\n     (int (x * snd z) -\n      (int (fst z') +\n       int (x * snd z'))) = int t * (int e - int e')] (mod int (order \\<G>))", "by (simp add: Rings.ring_distribs(4) \\<open>[int (fst z) - int (fst z') + int x * int (snd z) - int x * int (snd z') = int t * int e - int t * int e'] (mod int (order \\<G>))\\<close> add_diff_add add_diff_eq)"], ["proof (state)\nthis:\n  [int (fst z) +\n   (int (x * snd z) -\n    (int (fst z') +\n     int (x * snd z'))) = int t * (int e - int e')] (mod int (order \\<G>))\n\ngoal (1 subgoal):\n 1. [int (fst z) - int (fst z') + int x * int (snd z) -\n     int x *\n     int (snd z') = int t * int e -\n                    int t * int e'] (mod int (order \\<G>)) \\<Longrightarrow>\n    [int (fst z) - int (fst z') +\n     int x *\n     (int (snd z) -\n      int (snd z')) = int t * (int e - int e')] (mod int (order \\<G>))", "then"], ["proof (chain)\npicking this:\n  [int (fst z) +\n   (int (x * snd z) -\n    (int (fst z') +\n     int (x * snd z'))) = int t * (int e - int e')] (mod int (order \\<G>))", "have \"\\<exists>i. [int (fst z) + (int x * int (snd z) - (int (fst z') + i * int (snd z'))) = int t * (int e - int e') + int (snd z') * (int x - i)] (mod int (order \\<G>))\""], ["proof (prove)\nusing this:\n  [int (fst z) +\n   (int (x * snd z) -\n    (int (fst z') +\n     int (x * snd z'))) = int t * (int e - int e')] (mod int (order \\<G>))\n\ngoal (1 subgoal):\n 1. \\<exists>i.\n       [int (fst z) +\n        (int x * int (snd z) -\n         (int (fst z') +\n          i *\n          int (snd z'))) = int t * (int e - int e') +\n                           int (snd z') *\n                           (int x - i)] (mod int (order \\<G>))", "by (metis (no_types) add.commute arith_simps(49) cancel_comm_monoid_add_class.diff_cancel int_ops(7) mult_eq_0_iff)"], ["proof (state)\nthis:\n  \\<exists>i.\n     [int (fst z) +\n      (int x * int (snd z) -\n       (int (fst z') +\n        i *\n        int (snd z'))) = int t * (int e - int e') +\n                         int (snd z') * (int x - i)] (mod int (order \\<G>))\n\ngoal (1 subgoal):\n 1. [int (fst z) - int (fst z') + int x * int (snd z) -\n     int x *\n     int (snd z') = int t * int e -\n                    int t * int e'] (mod int (order \\<G>)) \\<Longrightarrow>\n    [int (fst z) - int (fst z') +\n     int x *\n     (int (snd z) -\n      int (snd z')) = int t * (int e - int e')] (mod int (order \\<G>))", "then"], ["proof (chain)\npicking this:\n  \\<exists>i.\n     [int (fst z) +\n      (int x * int (snd z) -\n       (int (fst z') +\n        i *\n        int (snd z'))) = int t * (int e - int e') +\n                         int (snd z') * (int x - i)] (mod int (order \\<G>))", "have \"\\<exists>i. [int (fst z) - int (fst z') + (int x * (int (snd z) - int (snd z')) + i) = int t * (int e - int e') + i] (mod int (order \\<G>))\""], ["proof (prove)\nusing this:\n  \\<exists>i.\n     [int (fst z) +\n      (int x * int (snd z) -\n       (int (fst z') +\n        i *\n        int (snd z'))) = int t * (int e - int e') +\n                         int (snd z') * (int x - i)] (mod int (order \\<G>))\n\ngoal (1 subgoal):\n 1. \\<exists>i.\n       [int (fst z) - int (fst z') +\n        (int x * (int (snd z) - int (snd z')) +\n         i) = int t * (int e - int e') + i] (mod int (order \\<G>))", "by (metis (no_types) add_diff_add add_diff_eq mult_diff_mult mult_of_nat_commute)"], ["proof (state)\nthis:\n  \\<exists>i.\n     [int (fst z) - int (fst z') +\n      (int x * (int (snd z) - int (snd z')) +\n       i) = int t * (int e - int e') + i] (mod int (order \\<G>))\n\ngoal (1 subgoal):\n 1. [int (fst z) - int (fst z') + int x * int (snd z) -\n     int x *\n     int (snd z') = int t * int e -\n                    int t * int e'] (mod int (order \\<G>)) \\<Longrightarrow>\n    [int (fst z) - int (fst z') +\n     int x *\n     (int (snd z) -\n      int (snd z')) = int t * (int e - int e')] (mod int (order \\<G>))", "then"], ["proof (chain)\npicking this:\n  \\<exists>i.\n     [int (fst z) - int (fst z') +\n      (int x * (int (snd z) - int (snd z')) +\n       i) = int t * (int e - int e') + i] (mod int (order \\<G>))", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>i.\n     [int (fst z) - int (fst z') +\n      (int x * (int (snd z) - int (snd z')) +\n       i) = int t * (int e - int e') + i] (mod int (order \\<G>))\n\ngoal (1 subgoal):\n 1. [int (fst z) - int (fst z') +\n     int x *\n     (int (snd z) -\n      int (snd z')) = int t * (int e - int e')] (mod int (order \\<G>))", "by (metis (no_types) add.assoc cong_add_rcancel)"], ["proof (state)\nthis:\n  [int (fst z) - int (fst z') +\n   int x *\n   (int (snd z) -\n    int (snd z')) = int t * (int e - int e')] (mod int (order \\<G>))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  [int (fst z) - int (fst z') +\n   int x *\n   (int (snd z) -\n    int (snd z')) = int t * (int e - int e')] (mod int (order \\<G>))\n\ngoal (1 subgoal):\n 1. h =\n    \\<^bold>g [^]\n    ((int (fst z) - int (fst z')) *\n     Number_Theory_Aux.inverse\n      ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n      (order \\<G>) mod\n     int (order \\<G>)) \\<otimes>\n    g' [^]\n    ((int (snd z) - int (snd z')) *\n     Number_Theory_Aux.inverse\n      ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n      (order \\<G>) mod\n     int (order \\<G>))", "hence \"[int (fst z) - int (fst z') + int x * (int (snd z) - int (snd z')) =  int t * (int e mod order \\<G> - int e' mod order \\<G>) mod order \\<G>] (mod order \\<G>)\""], ["proof (prove)\nusing this:\n  [int (fst z) - int (fst z') +\n   int x *\n   (int (snd z) -\n    int (snd z')) = int t * (int e - int e')] (mod int (order \\<G>))\n\ngoal (1 subgoal):\n 1. [int (fst z) - int (fst z') +\n     int x *\n     (int (snd z) -\n      int (snd z')) = int t *\n                      (int e mod int (order \\<G>) -\n                       int e' mod int (order \\<G>)) mod\n                      int (order \\<G>)] (mod int (order \\<G>))", "by (metis (mono_tags, lifting) cong_def mod_diff_eq mod_mod_trivial mod_mult_right_eq)"], ["proof (state)\nthis:\n  [int (fst z) - int (fst z') +\n   int x *\n   (int (snd z) -\n    int (snd z')) = int t *\n                    (int e mod int (order \\<G>) -\n                     int e' mod int (order \\<G>)) mod\n                    int (order \\<G>)] (mod int (order \\<G>))\n\ngoal (1 subgoal):\n 1. h =\n    \\<^bold>g [^]\n    ((int (fst z) - int (fst z')) *\n     Number_Theory_Aux.inverse\n      ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n      (order \\<G>) mod\n     int (order \\<G>)) \\<otimes>\n    g' [^]\n    ((int (snd z) - int (snd z')) *\n     Number_Theory_Aux.inverse\n      ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n      (order \\<G>) mod\n     int (order \\<G>))", "hence \"[int (fst z) - int (fst z') + int x * (int (snd z) - int (snd z')) =  int t * (e mod order \\<G> - e' mod order \\<G>) mod order \\<G>] (mod order \\<G>)\""], ["proof (prove)\nusing this:\n  [int (fst z) - int (fst z') +\n   int x *\n   (int (snd z) -\n    int (snd z')) = int t *\n                    (int e mod int (order \\<G>) -\n                     int e' mod int (order \\<G>)) mod\n                    int (order \\<G>)] (mod int (order \\<G>))\n\ngoal (1 subgoal):\n 1. [int (fst z) - int (fst z') +\n     int x *\n     (int (snd z) -\n      int (snd z')) = int t * int (e mod order \\<G> - e' mod order \\<G>) mod\n                      int (order \\<G>)] (mod int (order \\<G>))", "using e_e'_mod"], ["proof (prove)\nusing this:\n  [int (fst z) - int (fst z') +\n   int x *\n   (int (snd z) -\n    int (snd z')) = int t *\n                    (int e mod int (order \\<G>) -\n                     int e' mod int (order \\<G>)) mod\n                    int (order \\<G>)] (mod int (order \\<G>))\n  e' mod order \\<G> < e mod order \\<G>\n\ngoal (1 subgoal):\n 1. [int (fst z) - int (fst z') +\n     int x *\n     (int (snd z) -\n      int (snd z')) = int t * int (e mod order \\<G> - e' mod order \\<G>) mod\n                      int (order \\<G>)] (mod int (order \\<G>))", "by (simp add: int_ops(9) of_nat_diff)"], ["proof (state)\nthis:\n  [int (fst z) - int (fst z') +\n   int x *\n   (int (snd z) -\n    int (snd z')) = int t * int (e mod order \\<G> - e' mod order \\<G>) mod\n                    int (order \\<G>)] (mod int (order \\<G>))\n\ngoal (1 subgoal):\n 1. h =\n    \\<^bold>g [^]\n    ((int (fst z) - int (fst z')) *\n     Number_Theory_Aux.inverse\n      ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n      (order \\<G>) mod\n     int (order \\<G>)) \\<otimes>\n    g' [^]\n    ((int (snd z) - int (snd z')) *\n     Number_Theory_Aux.inverse\n      ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n      (order \\<G>) mod\n     int (order \\<G>))", "hence \"[(int (fst z) - int (fst z') + int x * (int (snd z) - int (snd z'))) \n            * fst (bezw ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>) (order \\<G>)) mod order \\<G> \n               =  int t * (e mod order \\<G> - e' mod order \\<G>) mod order \\<G> \n                  * fst (bezw ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>) (order \\<G>)) mod order \\<G>] (mod order \\<G>)\""], ["proof (prove)\nusing this:\n  [int (fst z) - int (fst z') +\n   int x *\n   (int (snd z) -\n    int (snd z')) = int t * int (e mod order \\<G> - e' mod order \\<G>) mod\n                    int (order \\<G>)] (mod int (order \\<G>))\n\ngoal (1 subgoal):\n 1. [(int (fst z) - int (fst z') + int x * (int (snd z) - int (snd z'))) *\n     Number_Theory_Aux.inverse\n      ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n      (order \\<G>) mod\n     int (order\n           \\<G>) = int t * int (e mod order \\<G> - e' mod order \\<G>) mod\n                   int (order \\<G>) *\n                   Number_Theory_Aux.inverse\n                    ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n                    (order \\<G>) mod\n                   int (order \\<G>)] (mod int (order \\<G>))", "using cong_cong_mod_int cong_scalar_right"], ["proof (prove)\nusing this:\n  [int (fst z) - int (fst z') +\n   int x *\n   (int (snd z) -\n    int (snd z')) = int t * int (e mod order \\<G> - e' mod order \\<G>) mod\n                    int (order \\<G>)] (mod int (order \\<G>))\n  [?a = ?b] (mod ?m) = [?a mod ?m = ?b mod ?m] (mod ?m)\n  [?b = ?c] (mod ?a) \\<Longrightarrow> [?b * ?d = ?c * ?d] (mod ?a)\n\ngoal (1 subgoal):\n 1. [(int (fst z) - int (fst z') + int x * (int (snd z) - int (snd z'))) *\n     Number_Theory_Aux.inverse\n      ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n      (order \\<G>) mod\n     int (order\n           \\<G>) = int t * int (e mod order \\<G> - e' mod order \\<G>) mod\n                   int (order \\<G>) *\n                   Number_Theory_Aux.inverse\n                    ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n                    (order \\<G>) mod\n                   int (order \\<G>)] (mod int (order \\<G>))", "by blast"], ["proof (state)\nthis:\n  [(int (fst z) - int (fst z') + int x * (int (snd z) - int (snd z'))) *\n   Number_Theory_Aux.inverse\n    ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>) (order \\<G>) mod\n   int (order\n         \\<G>) = int t * int (e mod order \\<G> - e' mod order \\<G>) mod\n                 int (order \\<G>) *\n                 Number_Theory_Aux.inverse\n                  ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n                  (order \\<G>) mod\n                 int (order \\<G>)] (mod int (order \\<G>))\n\ngoal (1 subgoal):\n 1. h =\n    \\<^bold>g [^]\n    ((int (fst z) - int (fst z')) *\n     Number_Theory_Aux.inverse\n      ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n      (order \\<G>) mod\n     int (order \\<G>)) \\<otimes>\n    g' [^]\n    ((int (snd z) - int (snd z')) *\n     Number_Theory_Aux.inverse\n      ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n      (order \\<G>) mod\n     int (order \\<G>))", "hence \"[(int (fst z) - int (fst z') + int x * (int (snd z) - int (snd z'))) \n            * fst (bezw ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>) (order \\<G>)) mod order \\<G> \n               =  int t * ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G> \n                  * fst (bezw ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>) (order \\<G>)) mod order \\<G>)] (mod order \\<G>)\""], ["proof (prove)\nusing this:\n  [(int (fst z) - int (fst z') + int x * (int (snd z) - int (snd z'))) *\n   Number_Theory_Aux.inverse\n    ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>) (order \\<G>) mod\n   int (order\n         \\<G>) = int t * int (e mod order \\<G> - e' mod order \\<G>) mod\n                 int (order \\<G>) *\n                 Number_Theory_Aux.inverse\n                  ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n                  (order \\<G>) mod\n                 int (order \\<G>)] (mod int (order \\<G>))\n\ngoal (1 subgoal):\n 1. [(int (fst z) - int (fst z') + int x * (int (snd z) - int (snd z'))) *\n     Number_Theory_Aux.inverse\n      ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n      (order \\<G>) mod\n     int (order\n           \\<G>) = int t *\n                   (int ((e mod order \\<G> - e' mod order \\<G>) mod\n                         order \\<G>) *\n                    Number_Theory_Aux.inverse\n                     ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n                     (order \\<G>) mod\n                    int (order \\<G>))] (mod int (order \\<G>))", "by (metis (no_types, lifting) Groups.mult_ac(1) cong_mod_right less_imp_diff_less mod_less mod_mult_left_eq mod_mult_right_eq order_gt_0 unique_euclidean_semiring_numeral_class.pos_mod_bound)"], ["proof (state)\nthis:\n  [(int (fst z) - int (fst z') + int x * (int (snd z) - int (snd z'))) *\n   Number_Theory_Aux.inverse\n    ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>) (order \\<G>) mod\n   int (order\n         \\<G>) = int t *\n                 (int ((e mod order \\<G> - e' mod order \\<G>) mod\n                       order \\<G>) *\n                  Number_Theory_Aux.inverse\n                   ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n                   (order \\<G>) mod\n                  int (order \\<G>))] (mod int (order \\<G>))\n\ngoal (1 subgoal):\n 1. h =\n    \\<^bold>g [^]\n    ((int (fst z) - int (fst z')) *\n     Number_Theory_Aux.inverse\n      ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n      (order \\<G>) mod\n     int (order \\<G>)) \\<otimes>\n    g' [^]\n    ((int (snd z) - int (snd z')) *\n     Number_Theory_Aux.inverse\n      ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n      (order \\<G>) mod\n     int (order \\<G>))", "hence \"[(int (fst z) - int (fst z') + int x * (int (snd z) - int (snd z'))) \n            * fst (bezw ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>) (order \\<G>)) mod order \\<G> \n               =  int t * 1] (mod order \\<G>)\""], ["proof (prove)\nusing this:\n  [(int (fst z) - int (fst z') + int x * (int (snd z) - int (snd z'))) *\n   Number_Theory_Aux.inverse\n    ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>) (order \\<G>) mod\n   int (order\n         \\<G>) = int t *\n                 (int ((e mod order \\<G> - e' mod order \\<G>) mod\n                       order \\<G>) *\n                  Number_Theory_Aux.inverse\n                   ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n                   (order \\<G>) mod\n                  int (order \\<G>))] (mod int (order \\<G>))\n\ngoal (1 subgoal):\n 1. [(int (fst z) - int (fst z') + int x * (int (snd z) - int (snd z'))) *\n     Number_Theory_Aux.inverse\n      ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n      (order \\<G>) mod\n     int (order \\<G>) = int t * 1] (mod int (order \\<G>))", "using inverse gcd"], ["proof (prove)\nusing this:\n  [(int (fst z) - int (fst z') + int x * (int (snd z) - int (snd z'))) *\n   Number_Theory_Aux.inverse\n    ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>) (order \\<G>) mod\n   int (order\n         \\<G>) = int t *\n                 (int ((e mod order \\<G> - e' mod order \\<G>) mod\n                       order \\<G>) *\n                  Number_Theory_Aux.inverse\n                   ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n                   (order \\<G>) mod\n                  int (order \\<G>))] (mod int (order \\<G>))\n  gcd ?x ?q = 1 \\<Longrightarrow>\n  [int ?x * Number_Theory_Aux.inverse ?x ?q = 1] (mod int ?q)\n  gcd ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>) (order \\<G>) =\n  1\n\ngoal (1 subgoal):\n 1. [(int (fst z) - int (fst z') + int x * (int (snd z) - int (snd z'))) *\n     Number_Theory_Aux.inverse\n      ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n      (order \\<G>) mod\n     int (order \\<G>) = int t * 1] (mod int (order \\<G>))", "by (smt Num.of_nat_simps(5) Number_Theory_Aux.inverse cong_def mod_mult_right_eq more_arith_simps(6) of_nat_1)"], ["proof (state)\nthis:\n  [(int (fst z) - int (fst z') + int x * (int (snd z) - int (snd z'))) *\n   Number_Theory_Aux.inverse\n    ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>) (order \\<G>) mod\n   int (order \\<G>) = int t * 1] (mod int (order \\<G>))\n\ngoal (1 subgoal):\n 1. h =\n    \\<^bold>g [^]\n    ((int (fst z) - int (fst z')) *\n     Number_Theory_Aux.inverse\n      ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n      (order \\<G>) mod\n     int (order \\<G>)) \\<otimes>\n    g' [^]\n    ((int (snd z) - int (snd z')) *\n     Number_Theory_Aux.inverse\n      ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n      (order \\<G>) mod\n     int (order \\<G>))", "hence \"[((int (fst z) - int (fst z')) + (int x * (int (snd z) - int (snd z')))) \n            * fst (bezw ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>) (order \\<G>)) mod order \\<G> \n               = int t] (mod order \\<G>)\""], ["proof (prove)\nusing this:\n  [(int (fst z) - int (fst z') + int x * (int (snd z) - int (snd z'))) *\n   Number_Theory_Aux.inverse\n    ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>) (order \\<G>) mod\n   int (order \\<G>) = int t * 1] (mod int (order \\<G>))\n\ngoal (1 subgoal):\n 1. [(int (fst z) - int (fst z') + int x * (int (snd z) - int (snd z'))) *\n     Number_Theory_Aux.inverse\n      ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n      (order \\<G>) mod\n     int (order \\<G>) = int t] (mod int (order \\<G>))", "by auto"], ["proof (state)\nthis:\n  [(int (fst z) - int (fst z') + int x * (int (snd z) - int (snd z'))) *\n   Number_Theory_Aux.inverse\n    ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>) (order \\<G>) mod\n   int (order \\<G>) = int t] (mod int (order \\<G>))\n\ngoal (1 subgoal):\n 1. h =\n    \\<^bold>g [^]\n    ((int (fst z) - int (fst z')) *\n     Number_Theory_Aux.inverse\n      ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n      (order \\<G>) mod\n     int (order \\<G>)) \\<otimes>\n    g' [^]\n    ((int (snd z) - int (snd z')) *\n     Number_Theory_Aux.inverse\n      ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n      (order \\<G>) mod\n     int (order \\<G>))", "hence \"[(int (fst z) - int (fst z')) * (fst (bezw ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>) (order \\<G>)) mod order \\<G>) + (int x * (int (snd z) - int (snd z'))) \n            * (fst (bezw ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>) (order \\<G>)) mod order \\<G>) \n               = int t] (mod order \\<G>)\""], ["proof (prove)\nusing this:\n  [(int (fst z) - int (fst z') + int x * (int (snd z) - int (snd z'))) *\n   Number_Theory_Aux.inverse\n    ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>) (order \\<G>) mod\n   int (order \\<G>) = int t] (mod int (order \\<G>))\n\ngoal (1 subgoal):\n 1. [(int (fst z) - int (fst z')) *\n     (Number_Theory_Aux.inverse\n       ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n       (order \\<G>) mod\n      int (order \\<G>)) +\n     int x * (int (snd z) - int (snd z')) *\n     (Number_Theory_Aux.inverse\n       ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n       (order \\<G>) mod\n      int (order \\<G>)) = int t] (mod int (order \\<G>))", "by (metis (no_types, hide_lams) cong_mod_left distrib_right mod_mult_right_eq)"], ["proof (state)\nthis:\n  [(int (fst z) - int (fst z')) *\n   (Number_Theory_Aux.inverse\n     ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n     (order \\<G>) mod\n    int (order \\<G>)) +\n   int x * (int (snd z) - int (snd z')) *\n   (Number_Theory_Aux.inverse\n     ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n     (order \\<G>) mod\n    int (order \\<G>)) = int t] (mod int (order \\<G>))\n\ngoal (1 subgoal):\n 1. h =\n    \\<^bold>g [^]\n    ((int (fst z) - int (fst z')) *\n     Number_Theory_Aux.inverse\n      ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n      (order \\<G>) mod\n     int (order \\<G>)) \\<otimes>\n    g' [^]\n    ((int (snd z) - int (snd z')) *\n     Number_Theory_Aux.inverse\n      ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n      (order \\<G>) mod\n     int (order \\<G>))", "hence \"[(int (fst z) - int (fst z')) * fst (bezw ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>) (order \\<G>)) mod order \\<G> + (int x * (int (snd z) - int (snd z'))) \n            * (fst (bezw ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>) (order \\<G>)) mod order \\<G>) \n               = t] (mod order \\<G>)\""], ["proof (prove)\nusing this:\n  [(int (fst z) - int (fst z')) *\n   (Number_Theory_Aux.inverse\n     ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n     (order \\<G>) mod\n    int (order \\<G>)) +\n   int x * (int (snd z) - int (snd z')) *\n   (Number_Theory_Aux.inverse\n     ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n     (order \\<G>) mod\n    int (order \\<G>)) = int t] (mod int (order \\<G>))\n\ngoal (1 subgoal):\n 1. [(int (fst z) - int (fst z')) *\n     Number_Theory_Aux.inverse\n      ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n      (order \\<G>) mod\n     int (order \\<G>) +\n     int x * (int (snd z) - int (snd z')) *\n     (Number_Theory_Aux.inverse\n       ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n       (order \\<G>) mod\n      int (order \\<G>)) = int t] (mod int (order \\<G>))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. [(int (fst z) - int (fst z')) *\n     (Number_Theory_Aux.inverse\n       ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n       (order \\<G>) mod\n      int (order \\<G>)) +\n     int x * (int (snd z) - int (snd z')) *\n     (Number_Theory_Aux.inverse\n       ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n       (order \\<G>) mod\n      int (order \\<G>)) = int t] (mod int (order \\<G>)) \\<Longrightarrow>\n    [(int (fst z) - int (fst z')) *\n     Number_Theory_Aux.inverse\n      ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n      (order \\<G>) mod\n     int (order \\<G>) +\n     int x * (int (snd z) - int (snd z')) *\n     (Number_Theory_Aux.inverse\n       ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n       (order \\<G>) mod\n      int (order \\<G>)) = int t] (mod int (order \\<G>))", "have \"[(int (fst z) - int (fst z')) * fst (bezw ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>) (order \\<G>)) = (int (fst z) - int (fst z')) * (fst (bezw ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>) (order \\<G>)) mod int (order \\<G>))] (mod int (order \\<G>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [(int (fst z) - int (fst z')) *\n     Number_Theory_Aux.inverse\n      ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n      (order\n        \\<G>) = (int (fst z) - int (fst z')) *\n                (Number_Theory_Aux.inverse\n                  ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n                  (order \\<G>) mod\n                 int (order \\<G>))] (mod int (order \\<G>))", "by (metis (no_types) cong_def mod_mult_right_eq)"], ["proof (state)\nthis:\n  [(int (fst z) - int (fst z')) *\n   Number_Theory_Aux.inverse\n    ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n    (order\n      \\<G>) = (int (fst z) - int (fst z')) *\n              (Number_Theory_Aux.inverse\n                ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n                (order \\<G>) mod\n               int (order \\<G>))] (mod int (order \\<G>))\n\ngoal (1 subgoal):\n 1. [(int (fst z) - int (fst z')) *\n     (Number_Theory_Aux.inverse\n       ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n       (order \\<G>) mod\n      int (order \\<G>)) +\n     int x * (int (snd z) - int (snd z')) *\n     (Number_Theory_Aux.inverse\n       ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n       (order \\<G>) mod\n      int (order \\<G>)) = int t] (mod int (order \\<G>)) \\<Longrightarrow>\n    [(int (fst z) - int (fst z')) *\n     Number_Theory_Aux.inverse\n      ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n      (order \\<G>) mod\n     int (order \\<G>) +\n     int x * (int (snd z) - int (snd z')) *\n     (Number_Theory_Aux.inverse\n       ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n       (order \\<G>) mod\n      int (order \\<G>)) = int t] (mod int (order \\<G>))", "then"], ["proof (chain)\npicking this:\n  [(int (fst z) - int (fst z')) *\n   Number_Theory_Aux.inverse\n    ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n    (order\n      \\<G>) = (int (fst z) - int (fst z')) *\n              (Number_Theory_Aux.inverse\n                ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n                (order \\<G>) mod\n               int (order \\<G>))] (mod int (order \\<G>))", "show ?thesis"], ["proof (prove)\nusing this:\n  [(int (fst z) - int (fst z')) *\n   Number_Theory_Aux.inverse\n    ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n    (order\n      \\<G>) = (int (fst z) - int (fst z')) *\n              (Number_Theory_Aux.inverse\n                ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n                (order \\<G>) mod\n               int (order \\<G>))] (mod int (order \\<G>))\n\ngoal (1 subgoal):\n 1. [(int (fst z) - int (fst z')) *\n     Number_Theory_Aux.inverse\n      ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n      (order \\<G>) mod\n     int (order \\<G>) +\n     int x * (int (snd z) - int (snd z')) *\n     (Number_Theory_Aux.inverse\n       ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n       (order \\<G>) mod\n      int (order \\<G>)) = int t] (mod int (order \\<G>))", "by (meson \\<open>[(int (fst z) - int (fst z')) * (fst (bezw ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>) (order \\<G>)) mod int (order \\<G>)) + int x * (int (snd z) - int (snd z')) * (fst (bezw ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>) (order \\<G>)) mod int (order \\<G>)) = int t] (mod int (order \\<G>))\\<close> cong_add_rcancel cong_mod_left cong_trans)"], ["proof (state)\nthis:\n  [(int (fst z) - int (fst z')) *\n   Number_Theory_Aux.inverse\n    ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>) (order \\<G>) mod\n   int (order \\<G>) +\n   int x * (int (snd z) - int (snd z')) *\n   (Number_Theory_Aux.inverse\n     ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n     (order \\<G>) mod\n    int (order \\<G>)) = int t] (mod int (order \\<G>))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  [(int (fst z) - int (fst z')) *\n   Number_Theory_Aux.inverse\n    ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>) (order \\<G>) mod\n   int (order \\<G>) +\n   int x * (int (snd z) - int (snd z')) *\n   (Number_Theory_Aux.inverse\n     ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n     (order \\<G>) mod\n    int (order \\<G>)) = int t] (mod int (order \\<G>))\n\ngoal (1 subgoal):\n 1. h =\n    \\<^bold>g [^]\n    ((int (fst z) - int (fst z')) *\n     Number_Theory_Aux.inverse\n      ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n      (order \\<G>) mod\n     int (order \\<G>)) \\<otimes>\n    g' [^]\n    ((int (snd z) - int (snd z')) *\n     Number_Theory_Aux.inverse\n      ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n      (order \\<G>) mod\n     int (order \\<G>))", "hence \"[(int (fst z) - int (fst z')) * fst (bezw ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>) (order \\<G>)) mod order \\<G> + (int x * (int (snd z) - int (snd z'))) \n            * fst (bezw ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>) (order \\<G>)) mod order \\<G>\n               = t] (mod order \\<G>)\""], ["proof (prove)\nusing this:\n  [(int (fst z) - int (fst z')) *\n   Number_Theory_Aux.inverse\n    ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>) (order \\<G>) mod\n   int (order \\<G>) +\n   int x * (int (snd z) - int (snd z')) *\n   (Number_Theory_Aux.inverse\n     ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n     (order \\<G>) mod\n    int (order \\<G>)) = int t] (mod int (order \\<G>))\n\ngoal (1 subgoal):\n 1. [(int (fst z) - int (fst z')) *\n     Number_Theory_Aux.inverse\n      ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n      (order \\<G>) mod\n     int (order \\<G>) +\n     int x * (int (snd z) - int (snd z')) *\n     Number_Theory_Aux.inverse\n      ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n      (order \\<G>) mod\n     int (order \\<G>) = int t] (mod int (order \\<G>))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. [(int (fst z) - int (fst z')) *\n     Number_Theory_Aux.inverse\n      ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n      (order \\<G>) mod\n     int (order \\<G>) +\n     int x * (int (snd z) - int (snd z')) *\n     (Number_Theory_Aux.inverse\n       ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n       (order \\<G>) mod\n      int (order \\<G>)) = int t] (mod int (order \\<G>)) \\<Longrightarrow>\n    [(int (fst z) - int (fst z')) *\n     Number_Theory_Aux.inverse\n      ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n      (order \\<G>) mod\n     int (order \\<G>) +\n     int x * (int (snd z) - int (snd z')) *\n     Number_Theory_Aux.inverse\n      ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n      (order \\<G>) mod\n     int (order \\<G>) = int t] (mod int (order \\<G>))", "have \"int x * ((int (snd z) - int (snd z')) * (fst (bezw ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>) (order \\<G>)) mod int (order \\<G>))) mod int (order \\<G>) = int x * ((int (snd z) - int (snd z')) * fst (bezw ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>) (order \\<G>))) mod int (order \\<G>) mod int (order \\<G>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int x *\n    ((int (snd z) - int (snd z')) *\n     (Number_Theory_Aux.inverse\n       ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n       (order \\<G>) mod\n      int (order \\<G>))) mod\n    int (order \\<G>) =\n    int x *\n    ((int (snd z) - int (snd z')) *\n     Number_Theory_Aux.inverse\n      ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n      (order \\<G>)) mod\n    int (order \\<G>) mod\n    int (order \\<G>)", "by (metis (no_types) mod_mod_trivial mod_mult_right_eq)"], ["proof (state)\nthis:\n  int x *\n  ((int (snd z) - int (snd z')) *\n   (Number_Theory_Aux.inverse\n     ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n     (order \\<G>) mod\n    int (order \\<G>))) mod\n  int (order \\<G>) =\n  int x *\n  ((int (snd z) - int (snd z')) *\n   Number_Theory_Aux.inverse\n    ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n    (order \\<G>)) mod\n  int (order \\<G>) mod\n  int (order \\<G>)\n\ngoal (1 subgoal):\n 1. [(int (fst z) - int (fst z')) *\n     Number_Theory_Aux.inverse\n      ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n      (order \\<G>) mod\n     int (order \\<G>) +\n     int x * (int (snd z) - int (snd z')) *\n     (Number_Theory_Aux.inverse\n       ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n       (order \\<G>) mod\n      int (order \\<G>)) = int t] (mod int (order \\<G>)) \\<Longrightarrow>\n    [(int (fst z) - int (fst z')) *\n     Number_Theory_Aux.inverse\n      ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n      (order \\<G>) mod\n     int (order \\<G>) +\n     int x * (int (snd z) - int (snd z')) *\n     Number_Theory_Aux.inverse\n      ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n      (order \\<G>) mod\n     int (order \\<G>) = int t] (mod int (order \\<G>))", "then"], ["proof (chain)\npicking this:\n  int x *\n  ((int (snd z) - int (snd z')) *\n   (Number_Theory_Aux.inverse\n     ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n     (order \\<G>) mod\n    int (order \\<G>))) mod\n  int (order \\<G>) =\n  int x *\n  ((int (snd z) - int (snd z')) *\n   Number_Theory_Aux.inverse\n    ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n    (order \\<G>)) mod\n  int (order \\<G>) mod\n  int (order \\<G>)", "have \"[int x * ((int (snd z) - int (snd z')) * fst (bezw ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>) (order \\<G>))) mod int (order \\<G>) = int x * ((int (snd z) - int (snd z')) * (fst (bezw ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>) (order \\<G>)) mod int (order \\<G>)))] (mod int (order \\<G>))\""], ["proof (prove)\nusing this:\n  int x *\n  ((int (snd z) - int (snd z')) *\n   (Number_Theory_Aux.inverse\n     ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n     (order \\<G>) mod\n    int (order \\<G>))) mod\n  int (order \\<G>) =\n  int x *\n  ((int (snd z) - int (snd z')) *\n   Number_Theory_Aux.inverse\n    ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n    (order \\<G>)) mod\n  int (order \\<G>) mod\n  int (order \\<G>)\n\ngoal (1 subgoal):\n 1. [int x *\n     ((int (snd z) - int (snd z')) *\n      Number_Theory_Aux.inverse\n       ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n       (order \\<G>)) mod\n     int (order\n           \\<G>) = int x *\n                   ((int (snd z) - int (snd z')) *\n                    (Number_Theory_Aux.inverse\n                      ((e mod order \\<G> - e' mod order \\<G>) mod\n                       order \\<G>)\n                      (order \\<G>) mod\n                     int (order \\<G>)))] (mod int (order \\<G>))", "by (metis (no_types) cong_def)"], ["proof (state)\nthis:\n  [int x *\n   ((int (snd z) - int (snd z')) *\n    Number_Theory_Aux.inverse\n     ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n     (order \\<G>)) mod\n   int (order\n         \\<G>) = int x *\n                 ((int (snd z) - int (snd z')) *\n                  (Number_Theory_Aux.inverse\n                    ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n                    (order \\<G>) mod\n                   int (order \\<G>)))] (mod int (order \\<G>))\n\ngoal (1 subgoal):\n 1. [(int (fst z) - int (fst z')) *\n     Number_Theory_Aux.inverse\n      ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n      (order \\<G>) mod\n     int (order \\<G>) +\n     int x * (int (snd z) - int (snd z')) *\n     (Number_Theory_Aux.inverse\n       ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n       (order \\<G>) mod\n      int (order \\<G>)) = int t] (mod int (order \\<G>)) \\<Longrightarrow>\n    [(int (fst z) - int (fst z')) *\n     Number_Theory_Aux.inverse\n      ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n      (order \\<G>) mod\n     int (order \\<G>) +\n     int x * (int (snd z) - int (snd z')) *\n     Number_Theory_Aux.inverse\n      ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n      (order \\<G>) mod\n     int (order \\<G>) = int t] (mod int (order \\<G>))", "then"], ["proof (chain)\npicking this:\n  [int x *\n   ((int (snd z) - int (snd z')) *\n    Number_Theory_Aux.inverse\n     ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n     (order \\<G>)) mod\n   int (order\n         \\<G>) = int x *\n                 ((int (snd z) - int (snd z')) *\n                  (Number_Theory_Aux.inverse\n                    ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n                    (order \\<G>) mod\n                   int (order \\<G>)))] (mod int (order \\<G>))", "have \"[(int (fst z) - int (fst z')) * fst (bezw ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>) (order \\<G>)) mod int (order \\<G>) + int x * ((int (snd z) - int (snd z')) * fst (bezw ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>) (order \\<G>))) mod int (order \\<G>) = (int (fst z) - int (fst z')) * fst (bezw ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>) (order \\<G>)) mod int (order \\<G>) + int x * (int (snd z) - int (snd z')) * (fst (bezw ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>) (order \\<G>)) mod int (order \\<G>))] (mod int (order \\<G>))\""], ["proof (prove)\nusing this:\n  [int x *\n   ((int (snd z) - int (snd z')) *\n    Number_Theory_Aux.inverse\n     ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n     (order \\<G>)) mod\n   int (order\n         \\<G>) = int x *\n                 ((int (snd z) - int (snd z')) *\n                  (Number_Theory_Aux.inverse\n                    ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n                    (order \\<G>) mod\n                   int (order \\<G>)))] (mod int (order \\<G>))\n\ngoal (1 subgoal):\n 1. [(int (fst z) - int (fst z')) *\n     Number_Theory_Aux.inverse\n      ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n      (order \\<G>) mod\n     int (order \\<G>) +\n     int x *\n     ((int (snd z) - int (snd z')) *\n      Number_Theory_Aux.inverse\n       ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n       (order \\<G>)) mod\n     int (order\n           \\<G>) = (int (fst z) - int (fst z')) *\n                   Number_Theory_Aux.inverse\n                    ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n                    (order \\<G>) mod\n                   int (order \\<G>) +\n                   int x * (int (snd z) - int (snd z')) *\n                   (Number_Theory_Aux.inverse\n                     ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n                     (order \\<G>) mod\n                    int (order \\<G>))] (mod int (order \\<G>))", "by (metis (no_types) Groups.mult_ac(1) cong_add cong_refl)"], ["proof (state)\nthis:\n  [(int (fst z) - int (fst z')) *\n   Number_Theory_Aux.inverse\n    ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>) (order \\<G>) mod\n   int (order \\<G>) +\n   int x *\n   ((int (snd z) - int (snd z')) *\n    Number_Theory_Aux.inverse\n     ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n     (order \\<G>)) mod\n   int (order\n         \\<G>) = (int (fst z) - int (fst z')) *\n                 Number_Theory_Aux.inverse\n                  ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n                  (order \\<G>) mod\n                 int (order \\<G>) +\n                 int x * (int (snd z) - int (snd z')) *\n                 (Number_Theory_Aux.inverse\n                   ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n                   (order \\<G>) mod\n                  int (order \\<G>))] (mod int (order \\<G>))\n\ngoal (1 subgoal):\n 1. [(int (fst z) - int (fst z')) *\n     Number_Theory_Aux.inverse\n      ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n      (order \\<G>) mod\n     int (order \\<G>) +\n     int x * (int (snd z) - int (snd z')) *\n     (Number_Theory_Aux.inverse\n       ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n       (order \\<G>) mod\n      int (order \\<G>)) = int t] (mod int (order \\<G>)) \\<Longrightarrow>\n    [(int (fst z) - int (fst z')) *\n     Number_Theory_Aux.inverse\n      ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n      (order \\<G>) mod\n     int (order \\<G>) +\n     int x * (int (snd z) - int (snd z')) *\n     Number_Theory_Aux.inverse\n      ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n      (order \\<G>) mod\n     int (order \\<G>) = int t] (mod int (order \\<G>))", "then"], ["proof (chain)\npicking this:\n  [(int (fst z) - int (fst z')) *\n   Number_Theory_Aux.inverse\n    ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>) (order \\<G>) mod\n   int (order \\<G>) +\n   int x *\n   ((int (snd z) - int (snd z')) *\n    Number_Theory_Aux.inverse\n     ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n     (order \\<G>)) mod\n   int (order\n         \\<G>) = (int (fst z) - int (fst z')) *\n                 Number_Theory_Aux.inverse\n                  ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n                  (order \\<G>) mod\n                 int (order \\<G>) +\n                 int x * (int (snd z) - int (snd z')) *\n                 (Number_Theory_Aux.inverse\n                   ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n                   (order \\<G>) mod\n                  int (order \\<G>))] (mod int (order \\<G>))", "have \"[(int (fst z) - int (fst z')) * fst (bezw ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>) (order \\<G>)) mod int (order \\<G>) + int x * ((int (snd z) - int (snd z')) * fst (bezw ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>) (order \\<G>))) mod int (order \\<G>) = int t] (mod int (order \\<G>))\""], ["proof (prove)\nusing this:\n  [(int (fst z) - int (fst z')) *\n   Number_Theory_Aux.inverse\n    ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>) (order \\<G>) mod\n   int (order \\<G>) +\n   int x *\n   ((int (snd z) - int (snd z')) *\n    Number_Theory_Aux.inverse\n     ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n     (order \\<G>)) mod\n   int (order\n         \\<G>) = (int (fst z) - int (fst z')) *\n                 Number_Theory_Aux.inverse\n                  ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n                  (order \\<G>) mod\n                 int (order \\<G>) +\n                 int x * (int (snd z) - int (snd z')) *\n                 (Number_Theory_Aux.inverse\n                   ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n                   (order \\<G>) mod\n                  int (order \\<G>))] (mod int (order \\<G>))\n\ngoal (1 subgoal):\n 1. [(int (fst z) - int (fst z')) *\n     Number_Theory_Aux.inverse\n      ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n      (order \\<G>) mod\n     int (order \\<G>) +\n     int x *\n     ((int (snd z) - int (snd z')) *\n      Number_Theory_Aux.inverse\n       ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n       (order \\<G>)) mod\n     int (order \\<G>) = int t] (mod int (order \\<G>))", "using \\<open>[(int (fst z) - int (fst z')) * fst (bezw ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>) (order \\<G>)) mod int (order \\<G>) + int x * (int (snd z) - int (snd z')) * (fst (bezw ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>) (order \\<G>)) mod int (order \\<G>)) = int t] (mod int (order \\<G>))\\<close> cong_trans"], ["proof (prove)\nusing this:\n  [(int (fst z) - int (fst z')) *\n   Number_Theory_Aux.inverse\n    ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>) (order \\<G>) mod\n   int (order \\<G>) +\n   int x *\n   ((int (snd z) - int (snd z')) *\n    Number_Theory_Aux.inverse\n     ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n     (order \\<G>)) mod\n   int (order\n         \\<G>) = (int (fst z) - int (fst z')) *\n                 Number_Theory_Aux.inverse\n                  ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n                  (order \\<G>) mod\n                 int (order \\<G>) +\n                 int x * (int (snd z) - int (snd z')) *\n                 (Number_Theory_Aux.inverse\n                   ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n                   (order \\<G>) mod\n                  int (order \\<G>))] (mod int (order \\<G>))\n  [(int (fst z) - int (fst z')) *\n   Number_Theory_Aux.inverse\n    ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>) (order \\<G>) mod\n   int (order \\<G>) +\n   int x * (int (snd z) - int (snd z')) *\n   (Number_Theory_Aux.inverse\n     ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n     (order \\<G>) mod\n    int (order \\<G>)) = int t] (mod int (order \\<G>))\n  \\<lbrakk>[?b = ?c] (mod ?a); [?c = ?d] (mod ?a)\\<rbrakk>\n  \\<Longrightarrow> [?b = ?d] (mod ?a)\n\ngoal (1 subgoal):\n 1. [(int (fst z) - int (fst z')) *\n     Number_Theory_Aux.inverse\n      ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n      (order \\<G>) mod\n     int (order \\<G>) +\n     int x *\n     ((int (snd z) - int (snd z')) *\n      Number_Theory_Aux.inverse\n       ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n       (order \\<G>)) mod\n     int (order \\<G>) = int t] (mod int (order \\<G>))", "by blast"], ["proof (state)\nthis:\n  [(int (fst z) - int (fst z')) *\n   Number_Theory_Aux.inverse\n    ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>) (order \\<G>) mod\n   int (order \\<G>) +\n   int x *\n   ((int (snd z) - int (snd z')) *\n    Number_Theory_Aux.inverse\n     ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n     (order \\<G>)) mod\n   int (order \\<G>) = int t] (mod int (order \\<G>))\n\ngoal (1 subgoal):\n 1. [(int (fst z) - int (fst z')) *\n     Number_Theory_Aux.inverse\n      ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n      (order \\<G>) mod\n     int (order \\<G>) +\n     int x * (int (snd z) - int (snd z')) *\n     (Number_Theory_Aux.inverse\n       ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n       (order \\<G>) mod\n      int (order \\<G>)) = int t] (mod int (order \\<G>)) \\<Longrightarrow>\n    [(int (fst z) - int (fst z')) *\n     Number_Theory_Aux.inverse\n      ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n      (order \\<G>) mod\n     int (order \\<G>) +\n     int x * (int (snd z) - int (snd z')) *\n     Number_Theory_Aux.inverse\n      ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n      (order \\<G>) mod\n     int (order \\<G>) = int t] (mod int (order \\<G>))", "then"], ["proof (chain)\npicking this:\n  [(int (fst z) - int (fst z')) *\n   Number_Theory_Aux.inverse\n    ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>) (order \\<G>) mod\n   int (order \\<G>) +\n   int x *\n   ((int (snd z) - int (snd z')) *\n    Number_Theory_Aux.inverse\n     ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n     (order \\<G>)) mod\n   int (order \\<G>) = int t] (mod int (order \\<G>))", "show ?thesis"], ["proof (prove)\nusing this:\n  [(int (fst z) - int (fst z')) *\n   Number_Theory_Aux.inverse\n    ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>) (order \\<G>) mod\n   int (order \\<G>) +\n   int x *\n   ((int (snd z) - int (snd z')) *\n    Number_Theory_Aux.inverse\n     ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n     (order \\<G>)) mod\n   int (order \\<G>) = int t] (mod int (order \\<G>))\n\ngoal (1 subgoal):\n 1. [(int (fst z) - int (fst z')) *\n     Number_Theory_Aux.inverse\n      ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n      (order \\<G>) mod\n     int (order \\<G>) +\n     int x * (int (snd z) - int (snd z')) *\n     Number_Theory_Aux.inverse\n      ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n      (order \\<G>) mod\n     int (order \\<G>) = int t] (mod int (order \\<G>))", "by (metis (no_types) Groups.mult_ac(1))"], ["proof (state)\nthis:\n  [(int (fst z) - int (fst z')) *\n   Number_Theory_Aux.inverse\n    ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>) (order \\<G>) mod\n   int (order \\<G>) +\n   int x * (int (snd z) - int (snd z')) *\n   Number_Theory_Aux.inverse\n    ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>) (order \\<G>) mod\n   int (order \\<G>) = int t] (mod int (order \\<G>))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  [(int (fst z) - int (fst z')) *\n   Number_Theory_Aux.inverse\n    ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>) (order \\<G>) mod\n   int (order \\<G>) +\n   int x * (int (snd z) - int (snd z')) *\n   Number_Theory_Aux.inverse\n    ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>) (order \\<G>) mod\n   int (order \\<G>) = int t] (mod int (order \\<G>))\n\ngoal (1 subgoal):\n 1. h =\n    \\<^bold>g [^]\n    ((int (fst z) - int (fst z')) *\n     Number_Theory_Aux.inverse\n      ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n      (order \\<G>) mod\n     int (order \\<G>)) \\<otimes>\n    g' [^]\n    ((int (snd z) - int (snd z')) *\n     Number_Theory_Aux.inverse\n      ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n      (order \\<G>) mod\n     int (order \\<G>))", "hence \"\\<^bold>g [^] ((int (fst z) - int (fst z')) * fst (bezw ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>) (order \\<G>)) mod order \\<G> + (int x * (int (snd z) - int (snd z'))) \n            * fst (bezw ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>) (order \\<G>)) mod order \\<G>)\n               = \\<^bold>g [^] t\""], ["proof (prove)\nusing this:\n  [(int (fst z) - int (fst z')) *\n   Number_Theory_Aux.inverse\n    ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>) (order \\<G>) mod\n   int (order \\<G>) +\n   int x * (int (snd z) - int (snd z')) *\n   Number_Theory_Aux.inverse\n    ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>) (order \\<G>) mod\n   int (order \\<G>) = int t] (mod int (order \\<G>))\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^]\n    ((int (fst z) - int (fst z')) *\n     Number_Theory_Aux.inverse\n      ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n      (order \\<G>) mod\n     int (order \\<G>) +\n     int x * (int (snd z) - int (snd z')) *\n     Number_Theory_Aux.inverse\n      ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n      (order \\<G>) mod\n     int (order \\<G>)) =\n    \\<^bold>g [^] t", "by (metis cong_def int_pow_int pow_generator_mod_int)"], ["proof (state)\nthis:\n  \\<^bold>g [^]\n  ((int (fst z) - int (fst z')) *\n   Number_Theory_Aux.inverse\n    ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>) (order \\<G>) mod\n   int (order \\<G>) +\n   int x * (int (snd z) - int (snd z')) *\n   Number_Theory_Aux.inverse\n    ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>) (order \\<G>) mod\n   int (order \\<G>)) =\n  \\<^bold>g [^] t\n\ngoal (1 subgoal):\n 1. h =\n    \\<^bold>g [^]\n    ((int (fst z) - int (fst z')) *\n     Number_Theory_Aux.inverse\n      ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n      (order \\<G>) mod\n     int (order \\<G>)) \\<otimes>\n    g' [^]\n    ((int (snd z) - int (snd z')) *\n     Number_Theory_Aux.inverse\n      ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n      (order \\<G>) mod\n     int (order \\<G>))", "hence \"\\<^bold>g [^] ((int (fst z) - int (fst z')) * fst (bezw ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>) (order \\<G>)) mod order \\<G>) \\<otimes> \\<^bold>g [^] ((int x * (int (snd z) - int (snd z'))) \n            * fst (bezw ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>) (order \\<G>)) mod order \\<G>)\n               = \\<^bold>g [^] t\""], ["proof (prove)\nusing this:\n  \\<^bold>g [^]\n  ((int (fst z) - int (fst z')) *\n   Number_Theory_Aux.inverse\n    ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>) (order \\<G>) mod\n   int (order \\<G>) +\n   int x * (int (snd z) - int (snd z')) *\n   Number_Theory_Aux.inverse\n    ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>) (order \\<G>) mod\n   int (order \\<G>)) =\n  \\<^bold>g [^] t\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^]\n    ((int (fst z) - int (fst z')) *\n     Number_Theory_Aux.inverse\n      ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n      (order \\<G>) mod\n     int (order \\<G>)) \\<otimes>\n    \\<^bold>g [^]\n    (int x * (int (snd z) - int (snd z')) *\n     Number_Theory_Aux.inverse\n      ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n      (order \\<G>) mod\n     int (order \\<G>)) =\n    \\<^bold>g [^] t", "using int_pow_mult"], ["proof (prove)\nusing this:\n  \\<^bold>g [^]\n  ((int (fst z) - int (fst z')) *\n   Number_Theory_Aux.inverse\n    ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>) (order \\<G>) mod\n   int (order \\<G>) +\n   int x * (int (snd z) - int (snd z')) *\n   Number_Theory_Aux.inverse\n    ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>) (order \\<G>) mod\n   int (order \\<G>)) =\n  \\<^bold>g [^] t\n  ?x \\<in> carrier \\<G> \\<Longrightarrow>\n  ?x [^] (?i + ?j) = ?x [^] ?i \\<otimes> ?x [^] ?j\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^]\n    ((int (fst z) - int (fst z')) *\n     Number_Theory_Aux.inverse\n      ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n      (order \\<G>) mod\n     int (order \\<G>)) \\<otimes>\n    \\<^bold>g [^]\n    (int x * (int (snd z) - int (snd z')) *\n     Number_Theory_Aux.inverse\n      ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n      (order \\<G>) mod\n     int (order \\<G>)) =\n    \\<^bold>g [^] t", "by auto"], ["proof (state)\nthis:\n  \\<^bold>g [^]\n  ((int (fst z) - int (fst z')) *\n   Number_Theory_Aux.inverse\n    ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>) (order \\<G>) mod\n   int (order \\<G>)) \\<otimes>\n  \\<^bold>g [^]\n  (int x * (int (snd z) - int (snd z')) *\n   Number_Theory_Aux.inverse\n    ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>) (order \\<G>) mod\n   int (order \\<G>)) =\n  \\<^bold>g [^] t\n\ngoal (1 subgoal):\n 1. h =\n    \\<^bold>g [^]\n    ((int (fst z) - int (fst z')) *\n     Number_Theory_Aux.inverse\n      ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n      (order \\<G>) mod\n     int (order \\<G>)) \\<otimes>\n    g' [^]\n    ((int (snd z) - int (snd z')) *\n     Number_Theory_Aux.inverse\n      ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n      (order \\<G>) mod\n     int (order \\<G>))", "hence \"\\<^bold>g [^] ((int (fst z) - int (fst z')) * fst (bezw ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>) (order \\<G>)) mod order \\<G>) \\<otimes> \\<^bold>g [^] ((int x * ((int (snd z) - int (snd z'))) \n            * fst (bezw ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>) (order \\<G>)) mod order \\<G>))\n               = \\<^bold>g [^] t\""], ["proof (prove)\nusing this:\n  \\<^bold>g [^]\n  ((int (fst z) - int (fst z')) *\n   Number_Theory_Aux.inverse\n    ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>) (order \\<G>) mod\n   int (order \\<G>)) \\<otimes>\n  \\<^bold>g [^]\n  (int x * (int (snd z) - int (snd z')) *\n   Number_Theory_Aux.inverse\n    ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>) (order \\<G>) mod\n   int (order \\<G>)) =\n  \\<^bold>g [^] t\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^]\n    ((int (fst z) - int (fst z')) *\n     Number_Theory_Aux.inverse\n      ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n      (order \\<G>) mod\n     int (order \\<G>)) \\<otimes>\n    \\<^bold>g [^]\n    (int x * (int (snd z) - int (snd z')) *\n     Number_Theory_Aux.inverse\n      ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n      (order \\<G>) mod\n     int (order \\<G>)) =\n    \\<^bold>g [^] t", "by blast"], ["proof (state)\nthis:\n  \\<^bold>g [^]\n  ((int (fst z) - int (fst z')) *\n   Number_Theory_Aux.inverse\n    ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>) (order \\<G>) mod\n   int (order \\<G>)) \\<otimes>\n  \\<^bold>g [^]\n  (int x * (int (snd z) - int (snd z')) *\n   Number_Theory_Aux.inverse\n    ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>) (order \\<G>) mod\n   int (order \\<G>)) =\n  \\<^bold>g [^] t\n\ngoal (1 subgoal):\n 1. h =\n    \\<^bold>g [^]\n    ((int (fst z) - int (fst z')) *\n     Number_Theory_Aux.inverse\n      ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n      (order \\<G>) mod\n     int (order \\<G>)) \\<otimes>\n    g' [^]\n    ((int (snd z) - int (snd z')) *\n     Number_Theory_Aux.inverse\n      ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n      (order \\<G>) mod\n     int (order \\<G>))", "hence \"\\<^bold>g [^] ((int (fst z) - int (fst z')) * fst (bezw ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>) (order \\<G>)) mod order \\<G>) \\<otimes> g' [^] ((((int (snd z) - int (snd z'))) \n            * fst (bezw ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>) (order \\<G>)) mod order \\<G>))\n               = \\<^bold>g [^] t\""], ["proof (prove)\nusing this:\n  \\<^bold>g [^]\n  ((int (fst z) - int (fst z')) *\n   Number_Theory_Aux.inverse\n    ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>) (order \\<G>) mod\n   int (order \\<G>)) \\<otimes>\n  \\<^bold>g [^]\n  (int x * (int (snd z) - int (snd z')) *\n   Number_Theory_Aux.inverse\n    ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>) (order \\<G>) mod\n   int (order \\<G>)) =\n  \\<^bold>g [^] t\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^]\n    ((int (fst z) - int (fst z')) *\n     Number_Theory_Aux.inverse\n      ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n      (order \\<G>) mod\n     int (order \\<G>)) \\<otimes>\n    g' [^]\n    ((int (snd z) - int (snd z')) *\n     Number_Theory_Aux.inverse\n      ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n      (order \\<G>) mod\n     int (order \\<G>)) =\n    \\<^bold>g [^] t", "by (smt g'_def cyclic_group.generator_closed int_pow_int int_pow_pow mod_mult_right_eq more_arith_simps(11) okamoto_axioms okamoto_def pow_generator_mod_int)"], ["proof (state)\nthis:\n  \\<^bold>g [^]\n  ((int (fst z) - int (fst z')) *\n   Number_Theory_Aux.inverse\n    ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>) (order \\<G>) mod\n   int (order \\<G>)) \\<otimes>\n  g' [^]\n  ((int (snd z) - int (snd z')) *\n   Number_Theory_Aux.inverse\n    ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>) (order \\<G>) mod\n   int (order \\<G>)) =\n  \\<^bold>g [^] t\n\ngoal (1 subgoal):\n 1. h =\n    \\<^bold>g [^]\n    ((int (fst z) - int (fst z')) *\n     Number_Theory_Aux.inverse\n      ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n      (order \\<G>) mod\n     int (order \\<G>)) \\<otimes>\n    g' [^]\n    ((int (snd z) - int (snd z')) *\n     Number_Theory_Aux.inverse\n      ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n      (order \\<G>) mod\n     int (order \\<G>))", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<^bold>g [^]\n  ((int (fst z) - int (fst z')) *\n   Number_Theory_Aux.inverse\n    ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>) (order \\<G>) mod\n   int (order \\<G>)) \\<otimes>\n  g' [^]\n  ((int (snd z) - int (snd z')) *\n   Number_Theory_Aux.inverse\n    ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>) (order \\<G>) mod\n   int (order \\<G>)) =\n  \\<^bold>g [^] t\n\ngoal (1 subgoal):\n 1. h =\n    \\<^bold>g [^]\n    ((int (fst z) - int (fst z')) *\n     Number_Theory_Aux.inverse\n      ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n      (order \\<G>) mod\n     int (order \\<G>)) \\<otimes>\n    g' [^]\n    ((int (snd z) - int (snd z')) *\n     Number_Theory_Aux.inverse\n      ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n      (order \\<G>) mod\n     int (order \\<G>))", "using t"], ["proof (prove)\nusing this:\n  \\<^bold>g [^]\n  ((int (fst z) - int (fst z')) *\n   Number_Theory_Aux.inverse\n    ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>) (order \\<G>) mod\n   int (order \\<G>)) \\<otimes>\n  g' [^]\n  ((int (snd z) - int (snd z')) *\n   Number_Theory_Aux.inverse\n    ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>) (order \\<G>) mod\n   int (order \\<G>)) =\n  \\<^bold>g [^] t\n  h = \\<^bold>g [^] t\n\ngoal (1 subgoal):\n 1. h =\n    \\<^bold>g [^]\n    ((int (fst z) - int (fst z')) *\n     Number_Theory_Aux.inverse\n      ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n      (order \\<G>) mod\n     int (order \\<G>)) \\<otimes>\n    g' [^]\n    ((int (snd z) - int (snd z')) *\n     Number_Theory_Aux.inverse\n      ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n      (order \\<G>) mod\n     int (order \\<G>))", "by simp"], ["proof (state)\nthis:\n  h =\n  \\<^bold>g [^]\n  ((int (fst z) - int (fst z')) *\n   Number_Theory_Aux.inverse\n    ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>) (order \\<G>) mod\n   int (order \\<G>)) \\<otimes>\n  g' [^]\n  ((int (snd z) - int (snd z')) *\n   Number_Theory_Aux.inverse\n    ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>) (order \\<G>) mod\n   int (order \\<G>))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma special_soundness:\n  shows \"\\<Sigma>_protocols_base.special_soundness\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.\\<Sigma>_protocols_base.special_soundness", "unfolding \\<Sigma>_protocols_base.special_soundness_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>h e e' a z z'.\n       h \\<in> valid_pub \\<longrightarrow>\n       e \\<in> challenge_space \\<longrightarrow>\n       e' \\<in> challenge_space \\<longrightarrow>\n       e \\<noteq> e' \\<longrightarrow>\n       check h a e z \\<longrightarrow>\n       check h a e' z' \\<longrightarrow>\n       lossless_spmf (ss_adversary h (a, e, z) (a, e', z')) \\<and>\n       (\\<forall>w'\\<in>set_spmf (ss_adversary h (a, e, z) (a, e', z')).\n           (h, w') \\<in> R)", "by(auto simp add: valid_pub_def check_def R_def ss_adversary_def Let_def ss_rewrite challenge_space_def split_def)"], ["", "theorem \\<Sigma>_protocol: \n  shows \"\\<Sigma>_protocols_base.\\<Sigma>_protocol\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.\\<Sigma>_protocols_base.\\<Sigma>_protocol", "by(simp add: \\<Sigma>_protocols_base.\\<Sigma>_protocol_def completeness HVZK special_soundness)"], ["", "sublocale okamoto_\\<Sigma>_commit: \\<Sigma>_protocols_to_commitments init response check R S2 ss_adversary challenge_space valid_pub G"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sigma>_protocols_to_commitments init response check R S2 ss_adversary\n     challenge_space valid_pub G", "apply unfold_locales"], ["proof (prove)\ngoal (5 subgoals):\n 1. local.\\<Sigma>_protocols_base.\\<Sigma>_protocol\n 2. \\<And>h w. (h, w) \\<in> set_spmf G \\<Longrightarrow> (h, w) \\<in> R\n 3. lossless_spmf G\n 4. \\<And>h w. lossless_spmf (init h w)\n 5. \\<And>r w e. lossless_spmf (response r w e)", "apply(auto simp add: \\<Sigma>_protocol)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>h a b.\n       (h, a, b) \\<in> set_spmf G \\<Longrightarrow> (h, a, b) \\<in> R\n 2. lossless_spmf G\n 3. \\<And>h a b. lossless_spmf (init h (a, b))\n 4. \\<And>a b aa ba e. lossless_spmf (response (a, b) (aa, ba) e)", "by(auto simp add: G_def R_def lossless_init lossless_response)"], ["", "sublocale dis_log: dis_log \\<G>"], ["proof (prove)\ngoal (1 subgoal):\n 1. dis_log \\<G>", "unfolding dis_log_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < order \\<G>", "by simp"], ["", "sublocale dis_log_alt: dis_log_alt \\<G> x"], ["proof (prove)\ngoal (1 subgoal):\n 1. dis_log_alt \\<G>", "unfolding dis_log_alt_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < order \\<G>", "by(simp add:)"], ["", "lemma reduction_to_dis_log:\n  shows \"okamoto_\\<Sigma>_commit.rel_advantage \\<A> = dis_log.advantage (dis_log_alt.adversary2 \\<A>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. okamoto_\\<Sigma>_commit.rel_advantage \\<A> =\n    local.dis_log.advantage (local.dis_log_alt.adversary2 \\<A>)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. okamoto_\\<Sigma>_commit.rel_advantage \\<A> =\n    local.dis_log.advantage (local.dis_log_alt.adversary2 \\<A>)", "have exp_rewrite: \"\\<^bold>g [^] w1 \\<otimes> g' [^] w2 =  \\<^bold>g [^] (w1 + x * w2)\" for w1 w2 :: nat"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<^bold>g [^] w1 \\<otimes> g' [^] w2 = \\<^bold>g [^] (w1 + x * w2)", "by (simp add: nat_pow_mult nat_pow_pow g'_def)"], ["proof (state)\nthis:\n  \\<^bold>g [^] ?w1.1 \\<otimes> g' [^] ?w2.1 =\n  \\<^bold>g [^] (?w1.1 + x * ?w2.1)\n\ngoal (1 subgoal):\n 1. okamoto_\\<Sigma>_commit.rel_advantage \\<A> =\n    local.dis_log.advantage (local.dis_log_alt.adversary2 \\<A>)", "have \"okamoto_\\<Sigma>_commit.rel_game \\<A> = TRY do {\n    w1 \\<leftarrow> sample_uniform (order \\<G>);\n    w2 \\<leftarrow> sample_uniform (order \\<G>);\n    let h = (\\<^bold>g [^] w1 \\<otimes> g' [^] w2);\n    (w1',w2') \\<leftarrow> \\<A> h;\n    return_spmf (h = \\<^bold>g [^] w1' \\<otimes> g' [^] w2')} ELSE return_spmf False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. okamoto_\\<Sigma>_commit.rel_game \\<A> =\n    TRY sample_uniform (order \\<G>) \\<bind>\n        (\\<lambda>w1.\n            sample_uniform (order \\<G>) \\<bind>\n            (\\<lambda>w2.\n                let h = \\<^bold>g [^] w1 \\<otimes> g' [^] w2\n                in \\<A> h \\<bind>\n                   (\\<lambda>(w1', w2').\n                       return_spmf\n                        (h =\n                         \\<^bold>g [^] w1' \\<otimes>\n                         g' [^] w2')))) ELSE return_spmf False", "unfolding okamoto_\\<Sigma>_commit.rel_game_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. TRY G \\<bind>\n        (\\<lambda>(h, w).\n            \\<A> h \\<bind>\n            (\\<lambda>w'.\n                return_spmf ((h, w') \\<in> R))) ELSE return_spmf False =\n    TRY sample_uniform (order \\<G>) \\<bind>\n        (\\<lambda>w1.\n            sample_uniform (order \\<G>) \\<bind>\n            (\\<lambda>w2.\n                let h = \\<^bold>g [^] w1 \\<otimes> g' [^] w2\n                in \\<A> h \\<bind>\n                   (\\<lambda>(w1', w2').\n                       return_spmf\n                        (h =\n                         \\<^bold>g [^] w1' \\<otimes>\n                         g' [^] w2')))) ELSE return_spmf False", "by(simp add: Let_def split_def R_def G_def)"], ["proof (state)\nthis:\n  okamoto_\\<Sigma>_commit.rel_game \\<A> =\n  TRY sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>w1.\n          sample_uniform (order \\<G>) \\<bind>\n          (\\<lambda>w2.\n              let h = \\<^bold>g [^] w1 \\<otimes> g' [^] w2\n              in \\<A> h \\<bind>\n                 (\\<lambda>(w1', w2').\n                     return_spmf\n                      (h =\n                       \\<^bold>g [^] w1' \\<otimes>\n                       g' [^] w2')))) ELSE return_spmf False\n\ngoal (1 subgoal):\n 1. okamoto_\\<Sigma>_commit.rel_advantage \\<A> =\n    local.dis_log.advantage (local.dis_log_alt.adversary2 \\<A>)", "also"], ["proof (state)\nthis:\n  okamoto_\\<Sigma>_commit.rel_game \\<A> =\n  TRY sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>w1.\n          sample_uniform (order \\<G>) \\<bind>\n          (\\<lambda>w2.\n              let h = \\<^bold>g [^] w1 \\<otimes> g' [^] w2\n              in \\<A> h \\<bind>\n                 (\\<lambda>(w1', w2').\n                     return_spmf\n                      (h =\n                       \\<^bold>g [^] w1' \\<otimes>\n                       g' [^] w2')))) ELSE return_spmf False\n\ngoal (1 subgoal):\n 1. okamoto_\\<Sigma>_commit.rel_advantage \\<A> =\n    local.dis_log.advantage (local.dis_log_alt.adversary2 \\<A>)", "have \"... = TRY do {\n    w1 \\<leftarrow> sample_uniform (order \\<G>);\n    w2 \\<leftarrow> sample_uniform (order \\<G>);\n    let w = (w1 + x * w2) mod (order \\<G>);\n    let h = \\<^bold>g [^] w;\n    (w1',w2') \\<leftarrow> \\<A> h;\n    return_spmf (h = \\<^bold>g [^] w1' \\<otimes> g' [^] w2')} ELSE return_spmf False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. TRY sample_uniform (order \\<G>) \\<bind>\n        (\\<lambda>w1.\n            sample_uniform (order \\<G>) \\<bind>\n            (\\<lambda>w2.\n                let h = \\<^bold>g [^] w1 \\<otimes> g' [^] w2\n                in \\<A> h \\<bind>\n                   (\\<lambda>(w1', w2').\n                       return_spmf\n                        (h =\n                         \\<^bold>g [^] w1' \\<otimes>\n                         g' [^] w2')))) ELSE return_spmf False =\n    TRY sample_uniform (order \\<G>) \\<bind>\n        (\\<lambda>w1.\n            sample_uniform (order \\<G>) \\<bind>\n            (\\<lambda>w2.\n                let w = (w1 + x * w2) mod order \\<G>; h = \\<^bold>g [^] w\n                in \\<A> h \\<bind>\n                   (\\<lambda>(w1', w2').\n                       return_spmf\n                        (h =\n                         \\<^bold>g [^] w1' \\<otimes>\n                         g' [^] w2')))) ELSE return_spmf False", "using g'_def exp_rewrite pow_generator_mod"], ["proof (prove)\nusing this:\n  g' = \\<^bold>g [^] x\n  \\<^bold>g [^] ?w1.1 \\<otimes> g' [^] ?w2.1 =\n  \\<^bold>g [^] (?w1.1 + x * ?w2.1)\n  \\<^bold>g [^] (?k mod order \\<G>) = \\<^bold>g [^] ?k\n\ngoal (1 subgoal):\n 1. TRY sample_uniform (order \\<G>) \\<bind>\n        (\\<lambda>w1.\n            sample_uniform (order \\<G>) \\<bind>\n            (\\<lambda>w2.\n                let h = \\<^bold>g [^] w1 \\<otimes> g' [^] w2\n                in \\<A> h \\<bind>\n                   (\\<lambda>(w1', w2').\n                       return_spmf\n                        (h =\n                         \\<^bold>g [^] w1' \\<otimes>\n                         g' [^] w2')))) ELSE return_spmf False =\n    TRY sample_uniform (order \\<G>) \\<bind>\n        (\\<lambda>w1.\n            sample_uniform (order \\<G>) \\<bind>\n            (\\<lambda>w2.\n                let w = (w1 + x * w2) mod order \\<G>; h = \\<^bold>g [^] w\n                in \\<A> h \\<bind>\n                   (\\<lambda>(w1', w2').\n                       return_spmf\n                        (h =\n                         \\<^bold>g [^] w1' \\<otimes>\n                         g' [^] w2')))) ELSE return_spmf False", "by simp"], ["proof (state)\nthis:\n  TRY sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>w1.\n          sample_uniform (order \\<G>) \\<bind>\n          (\\<lambda>w2.\n              let h = \\<^bold>g [^] w1 \\<otimes> g' [^] w2\n              in \\<A> h \\<bind>\n                 (\\<lambda>(w1', w2').\n                     return_spmf\n                      (h =\n                       \\<^bold>g [^] w1' \\<otimes>\n                       g' [^] w2')))) ELSE return_spmf False =\n  TRY sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>w1.\n          sample_uniform (order \\<G>) \\<bind>\n          (\\<lambda>w2.\n              let w = (w1 + x * w2) mod order \\<G>; h = \\<^bold>g [^] w\n              in \\<A> h \\<bind>\n                 (\\<lambda>(w1', w2').\n                     return_spmf\n                      (h =\n                       \\<^bold>g [^] w1' \\<otimes>\n                       g' [^] w2')))) ELSE return_spmf False\n\ngoal (1 subgoal):\n 1. okamoto_\\<Sigma>_commit.rel_advantage \\<A> =\n    local.dis_log.advantage (local.dis_log_alt.adversary2 \\<A>)", "also"], ["proof (state)\nthis:\n  TRY sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>w1.\n          sample_uniform (order \\<G>) \\<bind>\n          (\\<lambda>w2.\n              let h = \\<^bold>g [^] w1 \\<otimes> g' [^] w2\n              in \\<A> h \\<bind>\n                 (\\<lambda>(w1', w2').\n                     return_spmf\n                      (h =\n                       \\<^bold>g [^] w1' \\<otimes>\n                       g' [^] w2')))) ELSE return_spmf False =\n  TRY sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>w1.\n          sample_uniform (order \\<G>) \\<bind>\n          (\\<lambda>w2.\n              let w = (w1 + x * w2) mod order \\<G>; h = \\<^bold>g [^] w\n              in \\<A> h \\<bind>\n                 (\\<lambda>(w1', w2').\n                     return_spmf\n                      (h =\n                       \\<^bold>g [^] w1' \\<otimes>\n                       g' [^] w2')))) ELSE return_spmf False\n\ngoal (1 subgoal):\n 1. okamoto_\\<Sigma>_commit.rel_advantage \\<A> =\n    local.dis_log.advantage (local.dis_log_alt.adversary2 \\<A>)", "have \"... = TRY do {\n    w2 \\<leftarrow> sample_uniform (order \\<G>);\n    w \\<leftarrow> map_spmf (\\<lambda> w1. (x * w2 + w1) mod (order \\<G>)) (sample_uniform (order \\<G>));\n    let h = \\<^bold>g [^] w;\n    (w1',w2') \\<leftarrow> \\<A> h;\n    return_spmf (h = \\<^bold>g [^] w1' \\<otimes> g' [^] w2')} ELSE return_spmf False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. TRY sample_uniform (order \\<G>) \\<bind>\n        (\\<lambda>w1.\n            sample_uniform (order \\<G>) \\<bind>\n            (\\<lambda>w2.\n                let w = (w1 + x * w2) mod order \\<G>; h = \\<^bold>g [^] w\n                in \\<A> h \\<bind>\n                   (\\<lambda>(w1', w2').\n                       return_spmf\n                        (h =\n                         \\<^bold>g [^] w1' \\<otimes>\n                         g' [^] w2')))) ELSE return_spmf False =\n    TRY sample_uniform (order \\<G>) \\<bind>\n        (\\<lambda>w2.\n            map_spmf (\\<lambda>w1. (x * w2 + w1) mod order \\<G>)\n             (sample_uniform (order \\<G>)) \\<bind>\n            (\\<lambda>w.\n                let h = \\<^bold>g [^] w\n                in \\<A> h \\<bind>\n                   (\\<lambda>(w1', w2').\n                       return_spmf\n                        (h =\n                         \\<^bold>g [^] w1' \\<otimes>\n                         g' [^] w2')))) ELSE return_spmf False", "including monad_normalisation"], ["proof (prove)\ngoal (1 subgoal):\n 1. TRY sample_uniform (order \\<G>) \\<bind>\n        (\\<lambda>w1.\n            sample_uniform (order \\<G>) \\<bind>\n            (\\<lambda>w2.\n                let w = (w1 + x * w2) mod order \\<G>; h = \\<^bold>g [^] w\n                in \\<A> h \\<bind>\n                   (\\<lambda>(w1', w2').\n                       return_spmf\n                        (h =\n                         \\<^bold>g [^] w1' \\<otimes>\n                         g' [^] w2')))) ELSE return_spmf False =\n    TRY sample_uniform (order \\<G>) \\<bind>\n        (\\<lambda>w2.\n            map_spmf (\\<lambda>w1. (x * w2 + w1) mod order \\<G>)\n             (sample_uniform (order \\<G>)) \\<bind>\n            (\\<lambda>w.\n                let h = \\<^bold>g [^] w\n                in \\<A> h \\<bind>\n                   (\\<lambda>(w1', w2').\n                       return_spmf\n                        (h =\n                         \\<^bold>g [^] w1' \\<otimes>\n                         g' [^] w2')))) ELSE return_spmf False", "by(simp add: bind_map_spmf o_def Let_def add.commute)"], ["proof (state)\nthis:\n  TRY sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>w1.\n          sample_uniform (order \\<G>) \\<bind>\n          (\\<lambda>w2.\n              let w = (w1 + x * w2) mod order \\<G>; h = \\<^bold>g [^] w\n              in \\<A> h \\<bind>\n                 (\\<lambda>(w1', w2').\n                     return_spmf\n                      (h =\n                       \\<^bold>g [^] w1' \\<otimes>\n                       g' [^] w2')))) ELSE return_spmf False =\n  TRY sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>w2.\n          map_spmf (\\<lambda>w1. (x * w2 + w1) mod order \\<G>)\n           (sample_uniform (order \\<G>)) \\<bind>\n          (\\<lambda>w.\n              let h = \\<^bold>g [^] w\n              in \\<A> h \\<bind>\n                 (\\<lambda>(w1', w2').\n                     return_spmf\n                      (h =\n                       \\<^bold>g [^] w1' \\<otimes>\n                       g' [^] w2')))) ELSE return_spmf False\n\ngoal (1 subgoal):\n 1. okamoto_\\<Sigma>_commit.rel_advantage \\<A> =\n    local.dis_log.advantage (local.dis_log_alt.adversary2 \\<A>)", "also"], ["proof (state)\nthis:\n  TRY sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>w1.\n          sample_uniform (order \\<G>) \\<bind>\n          (\\<lambda>w2.\n              let w = (w1 + x * w2) mod order \\<G>; h = \\<^bold>g [^] w\n              in \\<A> h \\<bind>\n                 (\\<lambda>(w1', w2').\n                     return_spmf\n                      (h =\n                       \\<^bold>g [^] w1' \\<otimes>\n                       g' [^] w2')))) ELSE return_spmf False =\n  TRY sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>w2.\n          map_spmf (\\<lambda>w1. (x * w2 + w1) mod order \\<G>)\n           (sample_uniform (order \\<G>)) \\<bind>\n          (\\<lambda>w.\n              let h = \\<^bold>g [^] w\n              in \\<A> h \\<bind>\n                 (\\<lambda>(w1', w2').\n                     return_spmf\n                      (h =\n                       \\<^bold>g [^] w1' \\<otimes>\n                       g' [^] w2')))) ELSE return_spmf False\n\ngoal (1 subgoal):\n 1. okamoto_\\<Sigma>_commit.rel_advantage \\<A> =\n    local.dis_log.advantage (local.dis_log_alt.adversary2 \\<A>)", "have \"... = TRY do {\n    w2 :: nat \\<leftarrow> sample_uniform (order \\<G>);\n    w \\<leftarrow> sample_uniform (order \\<G>);\n    let h = \\<^bold>g [^] w;\n    (w1',w2') \\<leftarrow> \\<A> h;\n    return_spmf (h = \\<^bold>g [^] w1' \\<otimes> g' [^] w2')} ELSE return_spmf False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. TRY sample_uniform (order \\<G>) \\<bind>\n        (\\<lambda>w2.\n            map_spmf (\\<lambda>w1. (x * w2 + w1) mod order \\<G>)\n             (sample_uniform (order \\<G>)) \\<bind>\n            (\\<lambda>w.\n                let h = \\<^bold>g [^] w\n                in \\<A> h \\<bind>\n                   (\\<lambda>(w1', w2').\n                       return_spmf\n                        (h =\n                         \\<^bold>g [^] w1' \\<otimes>\n                         g' [^] w2')))) ELSE return_spmf False =\n    TRY sample_uniform (order \\<G>) \\<bind>\n        (\\<lambda>w2.\n            sample_uniform (order \\<G>) \\<bind>\n            (\\<lambda>w.\n                let h = \\<^bold>g [^] w\n                in \\<A> h \\<bind>\n                   (\\<lambda>(w1', w2').\n                       return_spmf\n                        (h =\n                         \\<^bold>g [^] w1' \\<otimes>\n                         g' [^] w2')))) ELSE return_spmf False", "using samp_uni_plus_one_time_pad add.commute"], ["proof (prove)\nusing this:\n  map_spmf (\\<lambda>b. (?y + b) mod ?q) (sample_uniform ?q) =\n  sample_uniform ?q\n  ?a + ?b = ?b + ?a\n\ngoal (1 subgoal):\n 1. TRY sample_uniform (order \\<G>) \\<bind>\n        (\\<lambda>w2.\n            map_spmf (\\<lambda>w1. (x * w2 + w1) mod order \\<G>)\n             (sample_uniform (order \\<G>)) \\<bind>\n            (\\<lambda>w.\n                let h = \\<^bold>g [^] w\n                in \\<A> h \\<bind>\n                   (\\<lambda>(w1', w2').\n                       return_spmf\n                        (h =\n                         \\<^bold>g [^] w1' \\<otimes>\n                         g' [^] w2')))) ELSE return_spmf False =\n    TRY sample_uniform (order \\<G>) \\<bind>\n        (\\<lambda>w2.\n            sample_uniform (order \\<G>) \\<bind>\n            (\\<lambda>w.\n                let h = \\<^bold>g [^] w\n                in \\<A> h \\<bind>\n                   (\\<lambda>(w1', w2').\n                       return_spmf\n                        (h =\n                         \\<^bold>g [^] w1' \\<otimes>\n                         g' [^] w2')))) ELSE return_spmf False", "by simp"], ["proof (state)\nthis:\n  TRY sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>w2.\n          map_spmf (\\<lambda>w1. (x * w2 + w1) mod order \\<G>)\n           (sample_uniform (order \\<G>)) \\<bind>\n          (\\<lambda>w.\n              let h = \\<^bold>g [^] w\n              in \\<A> h \\<bind>\n                 (\\<lambda>(w1', w2').\n                     return_spmf\n                      (h =\n                       \\<^bold>g [^] w1' \\<otimes>\n                       g' [^] w2')))) ELSE return_spmf False =\n  TRY sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>w2.\n          sample_uniform (order \\<G>) \\<bind>\n          (\\<lambda>w.\n              let h = \\<^bold>g [^] w\n              in \\<A> h \\<bind>\n                 (\\<lambda>(w1', w2').\n                     return_spmf\n                      (h =\n                       \\<^bold>g [^] w1' \\<otimes>\n                       g' [^] w2')))) ELSE return_spmf False\n\ngoal (1 subgoal):\n 1. okamoto_\\<Sigma>_commit.rel_advantage \\<A> =\n    local.dis_log.advantage (local.dis_log_alt.adversary2 \\<A>)", "also"], ["proof (state)\nthis:\n  TRY sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>w2.\n          map_spmf (\\<lambda>w1. (x * w2 + w1) mod order \\<G>)\n           (sample_uniform (order \\<G>)) \\<bind>\n          (\\<lambda>w.\n              let h = \\<^bold>g [^] w\n              in \\<A> h \\<bind>\n                 (\\<lambda>(w1', w2').\n                     return_spmf\n                      (h =\n                       \\<^bold>g [^] w1' \\<otimes>\n                       g' [^] w2')))) ELSE return_spmf False =\n  TRY sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>w2.\n          sample_uniform (order \\<G>) \\<bind>\n          (\\<lambda>w.\n              let h = \\<^bold>g [^] w\n              in \\<A> h \\<bind>\n                 (\\<lambda>(w1', w2').\n                     return_spmf\n                      (h =\n                       \\<^bold>g [^] w1' \\<otimes>\n                       g' [^] w2')))) ELSE return_spmf False\n\ngoal (1 subgoal):\n 1. okamoto_\\<Sigma>_commit.rel_advantage \\<A> =\n    local.dis_log.advantage (local.dis_log_alt.adversary2 \\<A>)", "have \"... = TRY do {\n    w \\<leftarrow> sample_uniform (order \\<G>);\n    let h = \\<^bold>g [^] w;\n    (w1',w2') \\<leftarrow> \\<A> h;\n    return_spmf (h = \\<^bold>g [^] w1' \\<otimes> g' [^] w2')} ELSE return_spmf False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. TRY sample_uniform (order \\<G>) \\<bind>\n        (\\<lambda>w2.\n            sample_uniform (order \\<G>) \\<bind>\n            (\\<lambda>w.\n                let h = \\<^bold>g [^] w\n                in \\<A> h \\<bind>\n                   (\\<lambda>(w1', w2').\n                       return_spmf\n                        (h =\n                         \\<^bold>g [^] w1' \\<otimes>\n                         g' [^] w2')))) ELSE return_spmf False =\n    TRY sample_uniform (order \\<G>) \\<bind>\n        (\\<lambda>w.\n            let h = \\<^bold>g [^] w\n            in \\<A> h \\<bind>\n               (\\<lambda>(w1', w2').\n                   return_spmf\n                    (h =\n                     \\<^bold>g [^] w1' \\<otimes>\n                     g' [^] w2'))) ELSE return_spmf False", "by(simp add: bind_spmf_const)"], ["proof (state)\nthis:\n  TRY sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>w2.\n          sample_uniform (order \\<G>) \\<bind>\n          (\\<lambda>w.\n              let h = \\<^bold>g [^] w\n              in \\<A> h \\<bind>\n                 (\\<lambda>(w1', w2').\n                     return_spmf\n                      (h =\n                       \\<^bold>g [^] w1' \\<otimes>\n                       g' [^] w2')))) ELSE return_spmf False =\n  TRY sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>w.\n          let h = \\<^bold>g [^] w\n          in \\<A> h \\<bind>\n             (\\<lambda>(w1', w2').\n                 return_spmf\n                  (h =\n                   \\<^bold>g [^] w1' \\<otimes>\n                   g' [^] w2'))) ELSE return_spmf False\n\ngoal (1 subgoal):\n 1. okamoto_\\<Sigma>_commit.rel_advantage \\<A> =\n    local.dis_log.advantage (local.dis_log_alt.adversary2 \\<A>)", "also"], ["proof (state)\nthis:\n  TRY sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>w2.\n          sample_uniform (order \\<G>) \\<bind>\n          (\\<lambda>w.\n              let h = \\<^bold>g [^] w\n              in \\<A> h \\<bind>\n                 (\\<lambda>(w1', w2').\n                     return_spmf\n                      (h =\n                       \\<^bold>g [^] w1' \\<otimes>\n                       g' [^] w2')))) ELSE return_spmf False =\n  TRY sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>w.\n          let h = \\<^bold>g [^] w\n          in \\<A> h \\<bind>\n             (\\<lambda>(w1', w2').\n                 return_spmf\n                  (h =\n                   \\<^bold>g [^] w1' \\<otimes>\n                   g' [^] w2'))) ELSE return_spmf False\n\ngoal (1 subgoal):\n 1. okamoto_\\<Sigma>_commit.rel_advantage \\<A> =\n    local.dis_log.advantage (local.dis_log_alt.adversary2 \\<A>)", "have \"... = dis_log_alt.dis_log2 \\<A>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. TRY sample_uniform (order \\<G>) \\<bind>\n        (\\<lambda>w.\n            let h = \\<^bold>g [^] w\n            in \\<A> h \\<bind>\n               (\\<lambda>(w1', w2').\n                   return_spmf\n                    (h =\n                     \\<^bold>g [^] w1' \\<otimes>\n                     g' [^] w2'))) ELSE return_spmf False =\n    local.dis_log_alt.dis_log2 \\<A>", "apply(simp add: dis_log_alt.dis_log2_def Let_def dis_log_alt.g'_def g'_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. TRY sample_uniform (order \\<G>) \\<bind>\n        (\\<lambda>w.\n            \\<A> (\\<^bold>g [^] w) \\<bind>\n            (\\<lambda>(w1', w2').\n                return_spmf\n                 (\\<^bold>g [^] w =\n                  \\<^bold>g [^] w1' \\<otimes>\n                  (\\<^bold>g [^] x) [^] w2'))) ELSE return_spmf False =\n    TRY sample_uniform (order \\<G>) \\<bind>\n        (\\<lambda>w.\n            \\<A> (\\<^bold>g [^] w) \\<bind>\n            (\\<lambda>(w1', w2').\n                return_spmf\n                 [w = w1' +\n                      x * w2'] (mod order \\<G>))) ELSE return_spmf False", "apply(intro try_spmf_cong)"], ["proof (prove)\ngoal (2 subgoals):\n 1. sample_uniform (order \\<G>) \\<bind>\n    (\\<lambda>w.\n        \\<A> (\\<^bold>g [^] w) \\<bind>\n        (\\<lambda>(w1', w2').\n            return_spmf\n             (\\<^bold>g [^] w =\n              \\<^bold>g [^] w1' \\<otimes> (\\<^bold>g [^] x) [^] w2'))) =\n    sample_uniform (order \\<G>) \\<bind>\n    (\\<lambda>w.\n        \\<A> (\\<^bold>g [^] w) \\<bind>\n        (\\<lambda>(w1', w2').\n            return_spmf [w = w1' + x * w2'] (mod order \\<G>)))\n 2. \\<not> lossless_spmf\n            (sample_uniform (order \\<G>) \\<bind>\n             (\\<lambda>w.\n                 \\<A> (\\<^bold>g [^] w) \\<bind>\n                 (\\<lambda>(w1', w2').\n                     return_spmf\n                      [w = w1' +\n                           x * w2'] (mod order \\<G>)))) \\<Longrightarrow>\n    return_spmf False = return_spmf False", "apply(intro bind_spmf_cong[OF refl]; clarsimp?)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa a b.\n       \\<lbrakk>xa < order \\<G>;\n        (a, b) \\<in> set_spmf (\\<A> (\\<^bold>g [^] xa))\\<rbrakk>\n       \\<Longrightarrow> (\\<^bold>g [^] xa =\n                          \\<^bold>g [^] a \\<otimes>\n                          (\\<^bold>g [^] x) [^] b) =\n                         [xa = a + x * b] (mod order \\<G>)\n 2. \\<not> lossless_spmf\n            (sample_uniform (order \\<G>) \\<bind>\n             (\\<lambda>w.\n                 \\<A> (\\<^bold>g [^] w) \\<bind>\n                 (\\<lambda>(w1', w2').\n                     return_spmf\n                      [w = w1' +\n                           x * w2'] (mod order \\<G>)))) \\<Longrightarrow>\n    return_spmf False = return_spmf False", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa a b.\n       \\<lbrakk>xa < order \\<G>;\n        (a, b)\n        \\<in> set_spmf\n               (\\<A> (\\<^bold>g [^] a \\<otimes> (\\<^bold>g [^] x) [^] b));\n        \\<^bold>g [^] xa =\n        \\<^bold>g [^] a \\<otimes> (\\<^bold>g [^] x) [^] b\\<rbrakk>\n       \\<Longrightarrow> [xa = a + x * b] (mod order \\<G>)\n 2. \\<And>xa a b.\n       \\<lbrakk>xa < order \\<G>;\n        (a, b) \\<in> set_spmf (\\<A> (\\<^bold>g [^] xa));\n        [xa = a + x * b] (mod order \\<G>)\\<rbrakk>\n       \\<Longrightarrow> \\<^bold>g [^] xa =\n                         \\<^bold>g [^] a \\<otimes> (\\<^bold>g [^] x) [^] b", "using exp_rewrite pow_generator_mod g'_def"], ["proof (prove)\nusing this:\n  \\<^bold>g [^] ?w1.1 \\<otimes> g' [^] ?w2.1 =\n  \\<^bold>g [^] (?w1.1 + x * ?w2.1)\n  \\<^bold>g [^] (?k mod order \\<G>) = \\<^bold>g [^] ?k\n  g' = \\<^bold>g [^] x\n\ngoal (2 subgoals):\n 1. \\<And>xa a b.\n       \\<lbrakk>xa < order \\<G>;\n        (a, b)\n        \\<in> set_spmf\n               (\\<A> (\\<^bold>g [^] a \\<otimes> (\\<^bold>g [^] x) [^] b));\n        \\<^bold>g [^] xa =\n        \\<^bold>g [^] a \\<otimes> (\\<^bold>g [^] x) [^] b\\<rbrakk>\n       \\<Longrightarrow> [xa = a + x * b] (mod order \\<G>)\n 2. \\<And>xa a b.\n       \\<lbrakk>xa < order \\<G>;\n        (a, b) \\<in> set_spmf (\\<A> (\\<^bold>g [^] xa));\n        [xa = a + x * b] (mod order \\<G>)\\<rbrakk>\n       \\<Longrightarrow> \\<^bold>g [^] xa =\n                         \\<^bold>g [^] a \\<otimes> (\\<^bold>g [^] x) [^] b", "apply (metis group_eq_pow_eq_mod okamoto_axioms okamoto_base.order_gt_0 okamoto_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa a b.\n       \\<lbrakk>xa < order \\<G>;\n        (a, b) \\<in> set_spmf (\\<A> (\\<^bold>g [^] xa));\n        [xa = a + x * b] (mod order \\<G>)\\<rbrakk>\n       \\<Longrightarrow> \\<^bold>g [^] xa =\n                         \\<^bold>g [^] a \\<otimes> (\\<^bold>g [^] x) [^] b", "using exp_rewrite g'_def order_gt_0_iff_finite pow_generator_eq_iff_cong"], ["proof (prove)\nusing this:\n  \\<^bold>g [^] ?w1.1 \\<otimes> g' [^] ?w2.1 =\n  \\<^bold>g [^] (?w1.1 + x * ?w2.1)\n  g' = \\<^bold>g [^] x\n  (0 < order \\<G>) = finite (carrier \\<G>)\n  finite (carrier \\<G>) \\<Longrightarrow>\n  (\\<^bold>g [^] ?x = \\<^bold>g [^] ?y) = [?x = ?y] (mod order \\<G>)\n\ngoal (1 subgoal):\n 1. \\<And>xa a b.\n       \\<lbrakk>xa < order \\<G>;\n        (a, b) \\<in> set_spmf (\\<A> (\\<^bold>g [^] xa));\n        [xa = a + x * b] (mod order \\<G>)\\<rbrakk>\n       \\<Longrightarrow> \\<^bold>g [^] xa =\n                         \\<^bold>g [^] a \\<otimes> (\\<^bold>g [^] x) [^] b", "by auto"], ["proof (state)\nthis:\n  TRY sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>w.\n          let h = \\<^bold>g [^] w\n          in \\<A> h \\<bind>\n             (\\<lambda>(w1', w2').\n                 return_spmf\n                  (h =\n                   \\<^bold>g [^] w1' \\<otimes>\n                   g' [^] w2'))) ELSE return_spmf False =\n  local.dis_log_alt.dis_log2 \\<A>\n\ngoal (1 subgoal):\n 1. okamoto_\\<Sigma>_commit.rel_advantage \\<A> =\n    local.dis_log.advantage (local.dis_log_alt.adversary2 \\<A>)", "ultimately"], ["proof (chain)\npicking this:\n  okamoto_\\<Sigma>_commit.rel_game \\<A> =\n  TRY sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>w.\n          let h = \\<^bold>g [^] w\n          in \\<A> h \\<bind>\n             (\\<lambda>(w1', w2').\n                 return_spmf\n                  (h =\n                   \\<^bold>g [^] w1' \\<otimes>\n                   g' [^] w2'))) ELSE return_spmf False\n  TRY sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>w.\n          let h = \\<^bold>g [^] w\n          in \\<A> h \\<bind>\n             (\\<lambda>(w1', w2').\n                 return_spmf\n                  (h =\n                   \\<^bold>g [^] w1' \\<otimes>\n                   g' [^] w2'))) ELSE return_spmf False =\n  local.dis_log_alt.dis_log2 \\<A>", "have \"okamoto_\\<Sigma>_commit.rel_game \\<A> = dis_log_alt.dis_log2 \\<A>\""], ["proof (prove)\nusing this:\n  okamoto_\\<Sigma>_commit.rel_game \\<A> =\n  TRY sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>w.\n          let h = \\<^bold>g [^] w\n          in \\<A> h \\<bind>\n             (\\<lambda>(w1', w2').\n                 return_spmf\n                  (h =\n                   \\<^bold>g [^] w1' \\<otimes>\n                   g' [^] w2'))) ELSE return_spmf False\n  TRY sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>w.\n          let h = \\<^bold>g [^] w\n          in \\<A> h \\<bind>\n             (\\<lambda>(w1', w2').\n                 return_spmf\n                  (h =\n                   \\<^bold>g [^] w1' \\<otimes>\n                   g' [^] w2'))) ELSE return_spmf False =\n  local.dis_log_alt.dis_log2 \\<A>\n\ngoal (1 subgoal):\n 1. okamoto_\\<Sigma>_commit.rel_game \\<A> = local.dis_log_alt.dis_log2 \\<A>", "by simp"], ["proof (state)\nthis:\n  okamoto_\\<Sigma>_commit.rel_game \\<A> = local.dis_log_alt.dis_log2 \\<A>\n\ngoal (1 subgoal):\n 1. okamoto_\\<Sigma>_commit.rel_advantage \\<A> =\n    local.dis_log.advantage (local.dis_log_alt.adversary2 \\<A>)", "hence \"okamoto_\\<Sigma>_commit.rel_advantage \\<A> = dis_log_alt.advantage2 \\<A>\""], ["proof (prove)\nusing this:\n  okamoto_\\<Sigma>_commit.rel_game \\<A> = local.dis_log_alt.dis_log2 \\<A>\n\ngoal (1 subgoal):\n 1. okamoto_\\<Sigma>_commit.rel_advantage \\<A> =\n    local.dis_log_alt.advantage2 \\<A>", "by(simp add: okamoto_\\<Sigma>_commit.rel_advantage_def dis_log_alt.advantage2_def)"], ["proof (state)\nthis:\n  okamoto_\\<Sigma>_commit.rel_advantage \\<A> =\n  local.dis_log_alt.advantage2 \\<A>\n\ngoal (1 subgoal):\n 1. okamoto_\\<Sigma>_commit.rel_advantage \\<A> =\n    local.dis_log.advantage (local.dis_log_alt.adversary2 \\<A>)", "thus ?thesis"], ["proof (prove)\nusing this:\n  okamoto_\\<Sigma>_commit.rel_advantage \\<A> =\n  local.dis_log_alt.advantage2 \\<A>\n\ngoal (1 subgoal):\n 1. okamoto_\\<Sigma>_commit.rel_advantage \\<A> =\n    local.dis_log.advantage (local.dis_log_alt.adversary2 \\<A>)", "by (simp add: dis_log_alt_reductions.dis_log_adv2 cyclic_group_axioms dis_log_alt.dis_log_alt_axioms dis_log_alt_reductions.intro)"], ["proof (state)\nthis:\n  okamoto_\\<Sigma>_commit.rel_advantage \\<A> =\n  local.dis_log.advantage (local.dis_log_alt.adversary2 \\<A>)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma commitment_correct: \"okamoto_\\<Sigma>_commit.abstract_com.correct\""], ["proof (prove)\ngoal (1 subgoal):\n 1. okamoto_\\<Sigma>_commit.abstract_com.correct", "by(simp add: okamoto_\\<Sigma>_commit.commit_correct)"], ["", "lemma \"okamoto_\\<Sigma>_commit.abstract_com.perfect_hiding_ind_cpa \\<A>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. okamoto_\\<Sigma>_commit.abstract_com.perfect_hiding_ind_cpa \\<A>", "using okamoto_\\<Sigma>_commit.perfect_hiding"], ["proof (prove)\nusing this:\n  okamoto_\\<Sigma>_commit.abstract_com.perfect_hiding_ind_cpa ?\\<A>\n\ngoal (1 subgoal):\n 1. okamoto_\\<Sigma>_commit.abstract_com.perfect_hiding_ind_cpa \\<A>", "by blast"], ["", "lemma binding: \n  shows \"okamoto_\\<Sigma>_commit.abstract_com.bind_advantage \\<A> \n          \\<le> dis_log.advantage (dis_log_alt.adversary2 (okamoto_\\<Sigma>_commit.adversary \\<A>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. okamoto_\\<Sigma>_commit.abstract_com.bind_advantage \\<A>\n    \\<le> local.dis_log.advantage\n           (local.dis_log_alt.adversary2\n             (okamoto_\\<Sigma>_commit.adversary \\<A>))", "using okamoto_\\<Sigma>_commit.bind_advantage reduction_to_dis_log"], ["proof (prove)\nusing this:\n  okamoto_\\<Sigma>_commit.abstract_com.bind_advantage ?\\<A>\n  \\<le> okamoto_\\<Sigma>_commit.rel_advantage\n         (okamoto_\\<Sigma>_commit.adversary ?\\<A>)\n  okamoto_\\<Sigma>_commit.rel_advantage ?\\<A> =\n  local.dis_log.advantage (local.dis_log_alt.adversary2 ?\\<A>)\n\ngoal (1 subgoal):\n 1. okamoto_\\<Sigma>_commit.abstract_com.bind_advantage \\<A>\n    \\<le> local.dis_log.advantage\n           (local.dis_log_alt.adversary2\n             (okamoto_\\<Sigma>_commit.adversary \\<A>))", "by auto"], ["", "end"], ["", "locale okamoto_asymp = \n  fixes \\<G> :: \"nat \\<Rightarrow> 'grp cyclic_group\"\n    and x :: nat\n  assumes okamoto: \"\\<And>\\<eta>. okamoto (\\<G> \\<eta>)\"\nbegin"], ["", "sublocale okamoto \"\\<G> \\<eta>\" for \\<eta>"], ["proof (prove)\ngoal (1 subgoal):\n 1. okamoto (\\<G> \\<eta>)", "by(simp add: okamoto)"], ["", "text\\<open>The \\<open>\\<Sigma>\\<close>-protocol statement comes easily in the asympotic setting.\\<close>"], ["", "theorem sigma_protocol:\n  shows \"\\<Sigma>_protocols_base.\\<Sigma>_protocol n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.\\<Sigma>_protocols_base.\\<Sigma>_protocol n", "by(simp add: \\<Sigma>_protocol)"], ["", "text\\<open>We now show the statements of security for the commitment scheme in the asymptotic setting, the main difference is that\nwe are able to show the binding advantage is negligible in the security parameter.\\<close>"], ["", "lemma asymp_correct: \"okamoto_\\<Sigma>_commit.abstract_com.correct n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. okamoto_\\<Sigma>_commit.abstract_com.correct n", "using  okamoto_\\<Sigma>_commit.commit_correct"], ["proof (prove)\nusing this:\n  okamoto_\\<Sigma>_commit.abstract_com.correct ?\\<eta>\n\ngoal (1 subgoal):\n 1. okamoto_\\<Sigma>_commit.abstract_com.correct n", "by simp"], ["", "lemma asymp_perfect_hiding: \"okamoto_\\<Sigma>_commit.abstract_com.perfect_hiding_ind_cpa n (\\<A> n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. okamoto_\\<Sigma>_commit.abstract_com.perfect_hiding_ind_cpa n (\\<A> n)", "using okamoto_\\<Sigma>_commit.perfect_hiding"], ["proof (prove)\nusing this:\n  okamoto_\\<Sigma>_commit.abstract_com.perfect_hiding_ind_cpa ?\\<eta> ?\\<A>\n\ngoal (1 subgoal):\n 1. okamoto_\\<Sigma>_commit.abstract_com.perfect_hiding_ind_cpa n (\\<A> n)", "by blast"], ["", "lemma asymp_computational_binding: \n  assumes \"negligible (\\<lambda> n. dis_log.advantage n (dis_log_alt.adversary2 (okamoto_\\<Sigma>_commit.adversary n (\\<A> n))))\"\n  shows \"negligible (\\<lambda> n. okamoto_\\<Sigma>_commit.abstract_com.bind_advantage n (\\<A> n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Negligible.negligible\n     (\\<lambda>n.\n         okamoto_\\<Sigma>_commit.abstract_com.bind_advantage n (\\<A> n))", "using okamoto_\\<Sigma>_commit.bind_advantage assms okamoto_\\<Sigma>_commit.abstract_com.bind_advantage_def negligible_le binding"], ["proof (prove)\nusing this:\n  okamoto_\\<Sigma>_commit.abstract_com.bind_advantage ?\\<eta> ?\\<A>\n  \\<le> okamoto_\\<Sigma>_commit.rel_advantage ?\\<eta>\n         (okamoto_\\<Sigma>_commit.adversary ?\\<eta> ?\\<A>)\n  Negligible.negligible\n   (\\<lambda>n.\n       local.dis_log.advantage n\n        (local.dis_log_alt.adversary2\n          (okamoto_\\<Sigma>_commit.adversary n (\\<A> n))))\n  okamoto_\\<Sigma>_commit.abstract_com.bind_advantage ?\\<eta> ?\\<A> \\<equiv>\n  spmf (okamoto_\\<Sigma>_commit.abstract_com.bind_game ?\\<eta> ?\\<A>) True\n  \\<lbrakk>Negligible.negligible ?g;\n   \\<And>\\<eta>. \\<bar>?f \\<eta>\\<bar> \\<le> ?g \\<eta>\\<rbrakk>\n  \\<Longrightarrow> Negligible.negligible ?f\n  okamoto_\\<Sigma>_commit.abstract_com.bind_advantage ?\\<eta> ?\\<A>\n  \\<le> local.dis_log.advantage ?\\<eta>\n         (local.dis_log_alt.adversary2\n           (okamoto_\\<Sigma>_commit.adversary ?\\<eta> ?\\<A>))\n\ngoal (1 subgoal):\n 1. Negligible.negligible\n     (\\<lambda>n.\n         okamoto_\\<Sigma>_commit.abstract_com.bind_advantage n (\\<A> n))", "by auto"], ["", "end"], ["", "end"]]}