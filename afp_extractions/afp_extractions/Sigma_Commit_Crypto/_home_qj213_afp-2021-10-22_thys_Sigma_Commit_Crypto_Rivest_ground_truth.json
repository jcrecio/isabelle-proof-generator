{"file_name": "/home/qj213/afp-2021-10-22/thys/Sigma_Commit_Crypto/Rivest.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Sigma_Commit_Crypto", "problem_names": ["lemma q_gt_0 [simp]: \"q > 0\"", "lemma abstract_correct: \"rivest_commit.correct\"", "lemma rivest_hiding: \"(spmf (rivest_commit.hiding_game_ind_cpa \\<A>) True - 1/2 = 0)\"", "lemma rivest_perfect_hiding: \"rivest_commit.perfect_hiding_ind_cpa \\<A>\"", "lemma samp_uni_break':\n  assumes fst_cond: \"m \\<noteq> m' \\<and> valid_msg m \\<and> valid_msg m'\"\n    and c: \"c = (m + a) mod q \\<and> y1 = (a * x1 + b) mod q\" \n    and  c': \"c = (m' + a') mod q \\<and> y1 = (a' * x1 + b') mod q\"\n    and x1: \"x1 < q\" \n  shows \"x1 = (if (a mod q > a' mod q) then nat ((int b'- int b) * (inverse (nat ((int a mod q - int a' mod q) mod q)) q) mod q)  else \n          nat ((int b- int b') * (inverse (nat ((int a' mod q - int a mod q) mod q)) q) mod q))\"", "lemma samp_uni_spmf_mod_q:\n  shows \"spmf (sample_uniform q) (x mod q) = 1/q\"", "lemma spmf_samp_uni_eq_return_bool_mod:\n  shows \"spmf (do { \n          x1 \\<leftarrow> sample_uniform q;\n          return_spmf (int x1 = y mod q)}) True = 1/q\"", "lemma bind_game_le_inv_q:\n  shows \"spmf (rivest_commit.bind_game \\<A>) True \\<le> 1 / q\"", "lemma rivest_bind:\n  shows \"rivest_commit.bind_advantage \\<A> \\<le> 1 / q\"", "theorem rivest_correct: \n  shows \"rivest_commit.correct n\"", "theorem rivest_perfect_hiding_asym:\n  assumes lossless_\\<A>: \"rivest_commit.lossless (\\<A> n)\" \n  shows \"rivest_commit.perfect_hiding_ind_cpa n (\\<A> n)\"", "theorem rivest_binding_asym:\n  assumes \"negligible (\\<lambda>n. 1 / (q n))\"\n  shows \"negligible (\\<lambda>n. rivest_commit.bind_advantage n (\\<A> n))\""], "translations": [["", "lemma q_gt_0 [simp]: \"q > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < q", "by (simp add: prime_q prime_gt_0_nat)"], ["", "type_synonym ck = \"nat \\<times> nat\""], ["", "type_synonym vk = \"nat \\<times> nat\""], ["", "type_synonym plain = \"nat\""], ["", "type_synonym commit = \"nat\""], ["", "type_synonym \"opening\" = \"nat \\<times> nat\""], ["", "definition key_gen :: \"(ck \\<times> vk) spmf\"\n  where \n    \"key_gen = do {\n    a :: nat \\<leftarrow> sample_uniform q;\n    b :: nat \\<leftarrow> sample_uniform q;\n    x1 :: nat \\<leftarrow> sample_uniform q;\n    let y1 = (a * x1 + b) mod q;\n    return_spmf ((a,b), (x1,y1))}\""], ["", "definition commit :: \"ck \\<Rightarrow> plain \\<Rightarrow> (commit \\<times> opening) spmf\"\n  where \n    \"commit ck m = do {\n  let (a,b) = ck;\n  return_spmf ((m + a) mod q, (a,b))}\""], ["", "fun verify :: \"vk \\<Rightarrow> plain \\<Rightarrow> commit \\<Rightarrow> opening \\<Rightarrow> bool\"\n  where \n    \"verify (x1,y1) m c (a,b) = (((c = (m + a) mod q)) \\<and> (y1 = (a * x1 + b) mod q))\""], ["", "definition valid_msg :: \"plain \\<Rightarrow> bool\"\n  where \"valid_msg msg \\<equiv> msg \\<in> {..< q}\""], ["", "sublocale rivest_commit: abstract_commitment key_gen commit verify valid_msg"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma abstract_correct: \"rivest_commit.correct\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rivest_commit.correct", "unfolding abstract_commitment.correct_def abstract_commitment.correct_game_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>m.\n       valid_msg m \\<longrightarrow>\n       spmf\n        (key_gen \\<bind>\n         (\\<lambda>(ck, vk).\n             commit ck m \\<bind>\n             (\\<lambda>(c, d). return_spmf (verify vk m c d))))\n        True =\n       1", "by(simp add: key_gen_def commit_def bind_spmf_const lossless_weight_spmfD)"], ["", "lemma rivest_hiding: \"(spmf (rivest_commit.hiding_game_ind_cpa \\<A>) True - 1/2 = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. spmf (rivest_commit.hiding_game_ind_cpa \\<A>) True - 1 / 2 = 0", "including monad_normalisation"], ["proof (prove)\ngoal (1 subgoal):\n 1. spmf (rivest_commit.hiding_game_ind_cpa \\<A>) True - 1 / 2 = 0", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. spmf (rivest_commit.hiding_game_ind_cpa \\<A>) True - 1 / 2 = 0", "note [simp] = Let_def split_def"], ["proof (state)\nthis:\n  Let ?s ?f \\<equiv> ?f ?s\n  case_prod = (\\<lambda>c p. c (fst p) (snd p))\n\ngoal (1 subgoal):\n 1. spmf (rivest_commit.hiding_game_ind_cpa \\<A>) True - 1 / 2 = 0", "obtain \\<A>1 \\<A>2 where [simp]: \"\\<A> = (\\<A>1, \\<A>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>\\<A>1 \\<A>2.\n        \\<A> = (\\<A>1, \\<A>2) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases \\<A>)"], ["proof (state)\nthis:\n  \\<A> = (\\<A>1, \\<A>2)\n\ngoal (1 subgoal):\n 1. spmf (rivest_commit.hiding_game_ind_cpa \\<A>) True - 1 / 2 = 0", "have \"rivest_commit.hiding_game_ind_cpa (\\<A>1, \\<A>2) = TRY do {\n    a :: nat \\<leftarrow> sample_uniform q;\n    x1 :: nat \\<leftarrow> sample_uniform q;\n    y1 \\<leftarrow> map_spmf (\\<lambda> b. (a * x1 + b) mod q) (sample_uniform q);\n    ((m0, m1), \\<sigma>) \\<leftarrow> \\<A>1 (x1,y1);\n    _ :: unit \\<leftarrow> assert_spmf (valid_msg m0 \\<and> valid_msg m1);\n    d \\<leftarrow> coin_spmf;  \n    let c = ((if d then m0 else m1) + a) mod q;\n    b' \\<leftarrow> \\<A>2 c \\<sigma>;\n    return_spmf (b' = d)} ELSE coin_spmf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rivest_commit.hiding_game_ind_cpa (\\<A>1, \\<A>2) =\n    TRY sample_uniform q \\<bind>\n        (\\<lambda>a.\n            sample_uniform q \\<bind>\n            (\\<lambda>x1.\n                map_spmf (\\<lambda>b. (a * x1 + b) mod q)\n                 (sample_uniform q) \\<bind>\n                (\\<lambda>y1.\n                    \\<A>1 (x1, y1) \\<bind>\n                    (\\<lambda>((m0, m1), \\<sigma>).\n                        assert_spmf\n                         (valid_msg m0 \\<and> valid_msg m1) \\<bind>\n                        (\\<lambda>_.\n                            coin_spmf \\<bind>\n                            (\\<lambda>d.\n                                let c = ((if d then m0 else m1) + a) mod q\n                                in \\<A>2 c \\<sigma> \\<bind>\n                                   (\\<lambda>b'.\n return_spmf (b' = d)))))))) ELSE coin_spmf", "unfolding abstract_commitment.hiding_game_ind_cpa_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case (\\<A>1, \\<A>2) of\n     (\\<A>1, \\<A>2) \\<Rightarrow>\n       TRY key_gen \\<bind>\n           (\\<lambda>(ck, vk).\n               \\<A>1 vk \\<bind>\n               (\\<lambda>((m0, m1), \\<sigma>).\n                   assert_spmf (valid_msg m0 \\<and> valid_msg m1) \\<bind>\n                   (\\<lambda>_.\n                       coin_spmf \\<bind>\n                       (\\<lambda>b.\n                           commit ck (if b then m0 else m1) \\<bind>\n                           (\\<lambda>(c, d).\n                               \\<A>2 c \\<sigma> \\<bind>\n                               (\\<lambda>b'.\n                                   return_spmf\n                                    (b' = b))))))) ELSE coin_spmf) =\n    TRY sample_uniform q \\<bind>\n        (\\<lambda>a.\n            sample_uniform q \\<bind>\n            (\\<lambda>x1.\n                map_spmf (\\<lambda>b. (a * x1 + b) mod q)\n                 (sample_uniform q) \\<bind>\n                (\\<lambda>y1.\n                    \\<A>1 (x1, y1) \\<bind>\n                    (\\<lambda>((m0, m1), \\<sigma>).\n                        assert_spmf\n                         (valid_msg m0 \\<and> valid_msg m1) \\<bind>\n                        (\\<lambda>_.\n                            coin_spmf \\<bind>\n                            (\\<lambda>d.\n                                let c = ((if d then m0 else m1) + a) mod q\n                                in \\<A>2 c \\<sigma> \\<bind>\n                                   (\\<lambda>b'.\n return_spmf (b' = d)))))))) ELSE coin_spmf", "by(simp add: commit_def key_gen_def o_def bind_map_spmf)"], ["proof (state)\nthis:\n  rivest_commit.hiding_game_ind_cpa (\\<A>1, \\<A>2) =\n  TRY sample_uniform q \\<bind>\n      (\\<lambda>a.\n          sample_uniform q \\<bind>\n          (\\<lambda>x1.\n              map_spmf (\\<lambda>b. (a * x1 + b) mod q)\n               (sample_uniform q) \\<bind>\n              (\\<lambda>y1.\n                  \\<A>1 (x1, y1) \\<bind>\n                  (\\<lambda>((m0, m1), \\<sigma>).\n                      assert_spmf (valid_msg m0 \\<and> valid_msg m1) \\<bind>\n                      (\\<lambda>_.\n                          coin_spmf \\<bind>\n                          (\\<lambda>d.\n                              let c = ((if d then m0 else m1) + a) mod q\n                              in \\<A>2 c \\<sigma> \\<bind>\n                                 (\\<lambda>b'.\n                                     return_spmf\n(b' = d)))))))) ELSE coin_spmf\n\ngoal (1 subgoal):\n 1. spmf (rivest_commit.hiding_game_ind_cpa \\<A>) True - 1 / 2 = 0", "also"], ["proof (state)\nthis:\n  rivest_commit.hiding_game_ind_cpa (\\<A>1, \\<A>2) =\n  TRY sample_uniform q \\<bind>\n      (\\<lambda>a.\n          sample_uniform q \\<bind>\n          (\\<lambda>x1.\n              map_spmf (\\<lambda>b. (a * x1 + b) mod q)\n               (sample_uniform q) \\<bind>\n              (\\<lambda>y1.\n                  \\<A>1 (x1, y1) \\<bind>\n                  (\\<lambda>((m0, m1), \\<sigma>).\n                      assert_spmf (valid_msg m0 \\<and> valid_msg m1) \\<bind>\n                      (\\<lambda>_.\n                          coin_spmf \\<bind>\n                          (\\<lambda>d.\n                              let c = ((if d then m0 else m1) + a) mod q\n                              in \\<A>2 c \\<sigma> \\<bind>\n                                 (\\<lambda>b'.\n                                     return_spmf\n(b' = d)))))))) ELSE coin_spmf\n\ngoal (1 subgoal):\n 1. spmf (rivest_commit.hiding_game_ind_cpa \\<A>) True - 1 / 2 = 0", "have \"... = TRY do {\n    a :: nat \\<leftarrow> sample_uniform q;\n    x1 :: nat \\<leftarrow> sample_uniform q;\n    y1 \\<leftarrow> sample_uniform q;\n    ((m0, m1), \\<sigma>) \\<leftarrow> \\<A>1 (x1,y1);\n    _ :: unit \\<leftarrow> assert_spmf (valid_msg m0 \\<and> valid_msg m1);\n    d \\<leftarrow> coin_spmf;  \n    let c = ((if d then m0 else m1) + a) mod q;\n    b' \\<leftarrow> \\<A>2 c \\<sigma>;\n    return_spmf (b' = d)} ELSE coin_spmf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. TRY sample_uniform q \\<bind>\n        (\\<lambda>a.\n            sample_uniform q \\<bind>\n            (\\<lambda>x1.\n                map_spmf (\\<lambda>b. (a * x1 + b) mod q)\n                 (sample_uniform q) \\<bind>\n                (\\<lambda>y1.\n                    \\<A>1 (x1, y1) \\<bind>\n                    (\\<lambda>((m0, m1), \\<sigma>).\n                        assert_spmf\n                         (valid_msg m0 \\<and> valid_msg m1) \\<bind>\n                        (\\<lambda>_.\n                            coin_spmf \\<bind>\n                            (\\<lambda>d.\n                                let c = ((if d then m0 else m1) + a) mod q\n                                in \\<A>2 c \\<sigma> \\<bind>\n                                   (\\<lambda>b'.\n return_spmf (b' = d)))))))) ELSE coin_spmf =\n    TRY sample_uniform q \\<bind>\n        (\\<lambda>a.\n            sample_uniform q \\<bind>\n            (\\<lambda>x1.\n                sample_uniform q \\<bind>\n                (\\<lambda>y1.\n                    \\<A>1 (x1, y1) \\<bind>\n                    (\\<lambda>((m0, m1), \\<sigma>).\n                        assert_spmf\n                         (valid_msg m0 \\<and> valid_msg m1) \\<bind>\n                        (\\<lambda>_.\n                            coin_spmf \\<bind>\n                            (\\<lambda>d.\n                                let c = ((if d then m0 else m1) + a) mod q\n                                in \\<A>2 c \\<sigma> \\<bind>\n                                   (\\<lambda>b'.\n return_spmf (b' = d)))))))) ELSE coin_spmf", "by(simp add: samp_uni_plus_one_time_pad)"], ["proof (state)\nthis:\n  TRY sample_uniform q \\<bind>\n      (\\<lambda>a.\n          sample_uniform q \\<bind>\n          (\\<lambda>x1.\n              map_spmf (\\<lambda>b. (a * x1 + b) mod q)\n               (sample_uniform q) \\<bind>\n              (\\<lambda>y1.\n                  \\<A>1 (x1, y1) \\<bind>\n                  (\\<lambda>((m0, m1), \\<sigma>).\n                      assert_spmf (valid_msg m0 \\<and> valid_msg m1) \\<bind>\n                      (\\<lambda>_.\n                          coin_spmf \\<bind>\n                          (\\<lambda>d.\n                              let c = ((if d then m0 else m1) + a) mod q\n                              in \\<A>2 c \\<sigma> \\<bind>\n                                 (\\<lambda>b'.\n                                     return_spmf\n(b' = d)))))))) ELSE coin_spmf =\n  TRY sample_uniform q \\<bind>\n      (\\<lambda>a.\n          sample_uniform q \\<bind>\n          (\\<lambda>x1.\n              sample_uniform q \\<bind>\n              (\\<lambda>y1.\n                  \\<A>1 (x1, y1) \\<bind>\n                  (\\<lambda>((m0, m1), \\<sigma>).\n                      assert_spmf (valid_msg m0 \\<and> valid_msg m1) \\<bind>\n                      (\\<lambda>_.\n                          coin_spmf \\<bind>\n                          (\\<lambda>d.\n                              let c = ((if d then m0 else m1) + a) mod q\n                              in \\<A>2 c \\<sigma> \\<bind>\n                                 (\\<lambda>b'.\n                                     return_spmf\n(b' = d)))))))) ELSE coin_spmf\n\ngoal (1 subgoal):\n 1. spmf (rivest_commit.hiding_game_ind_cpa \\<A>) True - 1 / 2 = 0", "also"], ["proof (state)\nthis:\n  TRY sample_uniform q \\<bind>\n      (\\<lambda>a.\n          sample_uniform q \\<bind>\n          (\\<lambda>x1.\n              map_spmf (\\<lambda>b. (a * x1 + b) mod q)\n               (sample_uniform q) \\<bind>\n              (\\<lambda>y1.\n                  \\<A>1 (x1, y1) \\<bind>\n                  (\\<lambda>((m0, m1), \\<sigma>).\n                      assert_spmf (valid_msg m0 \\<and> valid_msg m1) \\<bind>\n                      (\\<lambda>_.\n                          coin_spmf \\<bind>\n                          (\\<lambda>d.\n                              let c = ((if d then m0 else m1) + a) mod q\n                              in \\<A>2 c \\<sigma> \\<bind>\n                                 (\\<lambda>b'.\n                                     return_spmf\n(b' = d)))))))) ELSE coin_spmf =\n  TRY sample_uniform q \\<bind>\n      (\\<lambda>a.\n          sample_uniform q \\<bind>\n          (\\<lambda>x1.\n              sample_uniform q \\<bind>\n              (\\<lambda>y1.\n                  \\<A>1 (x1, y1) \\<bind>\n                  (\\<lambda>((m0, m1), \\<sigma>).\n                      assert_spmf (valid_msg m0 \\<and> valid_msg m1) \\<bind>\n                      (\\<lambda>_.\n                          coin_spmf \\<bind>\n                          (\\<lambda>d.\n                              let c = ((if d then m0 else m1) + a) mod q\n                              in \\<A>2 c \\<sigma> \\<bind>\n                                 (\\<lambda>b'.\n                                     return_spmf\n(b' = d)))))))) ELSE coin_spmf\n\ngoal (1 subgoal):\n 1. spmf (rivest_commit.hiding_game_ind_cpa \\<A>) True - 1 / 2 = 0", "have \"... = TRY do {\n    x1 :: nat \\<leftarrow> sample_uniform q;\n    y1 \\<leftarrow> sample_uniform q;\n    ((m0, m1), \\<sigma>) \\<leftarrow> \\<A>1 (x1,y1);\n    _ :: unit \\<leftarrow> assert_spmf (valid_msg m0 \\<and> valid_msg m1);\n    d \\<leftarrow> coin_spmf;  \n    c \\<leftarrow> map_spmf (\\<lambda> a. ((if d then m0 else m1) + a) mod q) (sample_uniform q);\n    b' \\<leftarrow> \\<A>2 c \\<sigma>;\n    return_spmf (b' = d)} ELSE coin_spmf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. TRY sample_uniform q \\<bind>\n        (\\<lambda>a.\n            sample_uniform q \\<bind>\n            (\\<lambda>x1.\n                sample_uniform q \\<bind>\n                (\\<lambda>y1.\n                    \\<A>1 (x1, y1) \\<bind>\n                    (\\<lambda>((m0, m1), \\<sigma>).\n                        assert_spmf\n                         (valid_msg m0 \\<and> valid_msg m1) \\<bind>\n                        (\\<lambda>_.\n                            coin_spmf \\<bind>\n                            (\\<lambda>d.\n                                let c = ((if d then m0 else m1) + a) mod q\n                                in \\<A>2 c \\<sigma> \\<bind>\n                                   (\\<lambda>b'.\n return_spmf (b' = d)))))))) ELSE coin_spmf =\n    TRY sample_uniform q \\<bind>\n        (\\<lambda>x1.\n            sample_uniform q \\<bind>\n            (\\<lambda>y1.\n                \\<A>1 (x1, y1) \\<bind>\n                (\\<lambda>((m0, m1), \\<sigma>).\n                    assert_spmf (valid_msg m0 \\<and> valid_msg m1) \\<bind>\n                    (\\<lambda>_.\n                        coin_spmf \\<bind>\n                        (\\<lambda>d.\n                            map_spmf\n                             (\\<lambda>a.\n                                 ((if d then m0 else m1) + a) mod q)\n                             (sample_uniform q) \\<bind>\n                            (\\<lambda>c.\n                                \\<A>2 c \\<sigma> \\<bind>\n                                (\\<lambda>b'.\n                                    return_spmf\n                                     (b' = d)))))))) ELSE coin_spmf", "by(simp add: o_def bind_map_spmf)"], ["proof (state)\nthis:\n  TRY sample_uniform q \\<bind>\n      (\\<lambda>a.\n          sample_uniform q \\<bind>\n          (\\<lambda>x1.\n              sample_uniform q \\<bind>\n              (\\<lambda>y1.\n                  \\<A>1 (x1, y1) \\<bind>\n                  (\\<lambda>((m0, m1), \\<sigma>).\n                      assert_spmf (valid_msg m0 \\<and> valid_msg m1) \\<bind>\n                      (\\<lambda>_.\n                          coin_spmf \\<bind>\n                          (\\<lambda>d.\n                              let c = ((if d then m0 else m1) + a) mod q\n                              in \\<A>2 c \\<sigma> \\<bind>\n                                 (\\<lambda>b'.\n                                     return_spmf\n(b' = d)))))))) ELSE coin_spmf =\n  TRY sample_uniform q \\<bind>\n      (\\<lambda>x1.\n          sample_uniform q \\<bind>\n          (\\<lambda>y1.\n              \\<A>1 (x1, y1) \\<bind>\n              (\\<lambda>((m0, m1), \\<sigma>).\n                  assert_spmf (valid_msg m0 \\<and> valid_msg m1) \\<bind>\n                  (\\<lambda>_.\n                      coin_spmf \\<bind>\n                      (\\<lambda>d.\n                          map_spmf\n                           (\\<lambda>a. ((if d then m0 else m1) + a) mod q)\n                           (sample_uniform q) \\<bind>\n                          (\\<lambda>c.\n                              \\<A>2 c \\<sigma> \\<bind>\n                              (\\<lambda>b'.\n                                  return_spmf (b' = d)))))))) ELSE coin_spmf\n\ngoal (1 subgoal):\n 1. spmf (rivest_commit.hiding_game_ind_cpa \\<A>) True - 1 / 2 = 0", "also"], ["proof (state)\nthis:\n  TRY sample_uniform q \\<bind>\n      (\\<lambda>a.\n          sample_uniform q \\<bind>\n          (\\<lambda>x1.\n              sample_uniform q \\<bind>\n              (\\<lambda>y1.\n                  \\<A>1 (x1, y1) \\<bind>\n                  (\\<lambda>((m0, m1), \\<sigma>).\n                      assert_spmf (valid_msg m0 \\<and> valid_msg m1) \\<bind>\n                      (\\<lambda>_.\n                          coin_spmf \\<bind>\n                          (\\<lambda>d.\n                              let c = ((if d then m0 else m1) + a) mod q\n                              in \\<A>2 c \\<sigma> \\<bind>\n                                 (\\<lambda>b'.\n                                     return_spmf\n(b' = d)))))))) ELSE coin_spmf =\n  TRY sample_uniform q \\<bind>\n      (\\<lambda>x1.\n          sample_uniform q \\<bind>\n          (\\<lambda>y1.\n              \\<A>1 (x1, y1) \\<bind>\n              (\\<lambda>((m0, m1), \\<sigma>).\n                  assert_spmf (valid_msg m0 \\<and> valid_msg m1) \\<bind>\n                  (\\<lambda>_.\n                      coin_spmf \\<bind>\n                      (\\<lambda>d.\n                          map_spmf\n                           (\\<lambda>a. ((if d then m0 else m1) + a) mod q)\n                           (sample_uniform q) \\<bind>\n                          (\\<lambda>c.\n                              \\<A>2 c \\<sigma> \\<bind>\n                              (\\<lambda>b'.\n                                  return_spmf (b' = d)))))))) ELSE coin_spmf\n\ngoal (1 subgoal):\n 1. spmf (rivest_commit.hiding_game_ind_cpa \\<A>) True - 1 / 2 = 0", "have \"... = TRY do {\n    x1 :: nat \\<leftarrow> sample_uniform q;\n    y1 \\<leftarrow> sample_uniform q;\n    ((m0, m1), \\<sigma>) \\<leftarrow> \\<A>1 (x1,y1);\n    _ :: unit \\<leftarrow> assert_spmf (valid_msg m0 \\<and> valid_msg m1);\n    d \\<leftarrow> coin_spmf;  \n    c \\<leftarrow> sample_uniform q;\n    b' :: bool \\<leftarrow> \\<A>2 c \\<sigma>;\n    return_spmf (b' = d)} ELSE coin_spmf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. TRY sample_uniform q \\<bind>\n        (\\<lambda>x1.\n            sample_uniform q \\<bind>\n            (\\<lambda>y1.\n                \\<A>1 (x1, y1) \\<bind>\n                (\\<lambda>((m0, m1), \\<sigma>).\n                    assert_spmf (valid_msg m0 \\<and> valid_msg m1) \\<bind>\n                    (\\<lambda>_.\n                        coin_spmf \\<bind>\n                        (\\<lambda>d.\n                            map_spmf\n                             (\\<lambda>a.\n                                 ((if d then m0 else m1) + a) mod q)\n                             (sample_uniform q) \\<bind>\n                            (\\<lambda>c.\n                                \\<A>2 c \\<sigma> \\<bind>\n                                (\\<lambda>b'.\n                                    return_spmf\n                                     (b' = d)))))))) ELSE coin_spmf =\n    TRY sample_uniform q \\<bind>\n        (\\<lambda>x1.\n            sample_uniform q \\<bind>\n            (\\<lambda>y1.\n                \\<A>1 (x1, y1) \\<bind>\n                (\\<lambda>((m0, m1), \\<sigma>).\n                    assert_spmf (valid_msg m0 \\<and> valid_msg m1) \\<bind>\n                    (\\<lambda>_.\n                        coin_spmf \\<bind>\n                        (\\<lambda>d.\n                            sample_uniform q \\<bind>\n                            (\\<lambda>c.\n                                \\<A>2 c \\<sigma> \\<bind>\n                                (\\<lambda>b'.\n                                    return_spmf\n                                     (b' = d)))))))) ELSE coin_spmf", "by(simp add: samp_uni_plus_one_time_pad)"], ["proof (state)\nthis:\n  TRY sample_uniform q \\<bind>\n      (\\<lambda>x1.\n          sample_uniform q \\<bind>\n          (\\<lambda>y1.\n              \\<A>1 (x1, y1) \\<bind>\n              (\\<lambda>((m0, m1), \\<sigma>).\n                  assert_spmf (valid_msg m0 \\<and> valid_msg m1) \\<bind>\n                  (\\<lambda>_.\n                      coin_spmf \\<bind>\n                      (\\<lambda>d.\n                          map_spmf\n                           (\\<lambda>a. ((if d then m0 else m1) + a) mod q)\n                           (sample_uniform q) \\<bind>\n                          (\\<lambda>c.\n                              \\<A>2 c \\<sigma> \\<bind>\n                              (\\<lambda>b'.\n                                  return_spmf\n                                   (b' = d)))))))) ELSE coin_spmf =\n  TRY sample_uniform q \\<bind>\n      (\\<lambda>x1.\n          sample_uniform q \\<bind>\n          (\\<lambda>y1.\n              \\<A>1 (x1, y1) \\<bind>\n              (\\<lambda>((m0, m1), \\<sigma>).\n                  assert_spmf (valid_msg m0 \\<and> valid_msg m1) \\<bind>\n                  (\\<lambda>_.\n                      coin_spmf \\<bind>\n                      (\\<lambda>d.\n                          sample_uniform q \\<bind>\n                          (\\<lambda>c.\n                              \\<A>2 c \\<sigma> \\<bind>\n                              (\\<lambda>b'.\n                                  return_spmf (b' = d)))))))) ELSE coin_spmf\n\ngoal (1 subgoal):\n 1. spmf (rivest_commit.hiding_game_ind_cpa \\<A>) True - 1 / 2 = 0", "also"], ["proof (state)\nthis:\n  TRY sample_uniform q \\<bind>\n      (\\<lambda>x1.\n          sample_uniform q \\<bind>\n          (\\<lambda>y1.\n              \\<A>1 (x1, y1) \\<bind>\n              (\\<lambda>((m0, m1), \\<sigma>).\n                  assert_spmf (valid_msg m0 \\<and> valid_msg m1) \\<bind>\n                  (\\<lambda>_.\n                      coin_spmf \\<bind>\n                      (\\<lambda>d.\n                          map_spmf\n                           (\\<lambda>a. ((if d then m0 else m1) + a) mod q)\n                           (sample_uniform q) \\<bind>\n                          (\\<lambda>c.\n                              \\<A>2 c \\<sigma> \\<bind>\n                              (\\<lambda>b'.\n                                  return_spmf\n                                   (b' = d)))))))) ELSE coin_spmf =\n  TRY sample_uniform q \\<bind>\n      (\\<lambda>x1.\n          sample_uniform q \\<bind>\n          (\\<lambda>y1.\n              \\<A>1 (x1, y1) \\<bind>\n              (\\<lambda>((m0, m1), \\<sigma>).\n                  assert_spmf (valid_msg m0 \\<and> valid_msg m1) \\<bind>\n                  (\\<lambda>_.\n                      coin_spmf \\<bind>\n                      (\\<lambda>d.\n                          sample_uniform q \\<bind>\n                          (\\<lambda>c.\n                              \\<A>2 c \\<sigma> \\<bind>\n                              (\\<lambda>b'.\n                                  return_spmf (b' = d)))))))) ELSE coin_spmf\n\ngoal (1 subgoal):\n 1. spmf (rivest_commit.hiding_game_ind_cpa \\<A>) True - 1 / 2 = 0", "have \"... = TRY do {\n    x1 :: nat \\<leftarrow> sample_uniform q;\n    y1 \\<leftarrow> sample_uniform q;\n    ((m0, m1), \\<sigma>) \\<leftarrow> \\<A>1 (x1,y1);\n    _ :: unit \\<leftarrow> assert_spmf (valid_msg m0 \\<and> valid_msg m1);\n    c :: nat \\<leftarrow> sample_uniform q;\n    guess :: bool \\<leftarrow> \\<A>2 c \\<sigma>;\n    map_spmf((=) guess) coin_spmf} ELSE coin_spmf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. TRY sample_uniform q \\<bind>\n        (\\<lambda>x1.\n            sample_uniform q \\<bind>\n            (\\<lambda>y1.\n                \\<A>1 (x1, y1) \\<bind>\n                (\\<lambda>((m0, m1), \\<sigma>).\n                    assert_spmf (valid_msg m0 \\<and> valid_msg m1) \\<bind>\n                    (\\<lambda>_.\n                        coin_spmf \\<bind>\n                        (\\<lambda>d.\n                            sample_uniform q \\<bind>\n                            (\\<lambda>c.\n                                \\<A>2 c \\<sigma> \\<bind>\n                                (\\<lambda>b'.\n                                    return_spmf\n                                     (b' = d)))))))) ELSE coin_spmf =\n    TRY sample_uniform q \\<bind>\n        (\\<lambda>x1.\n            sample_uniform q \\<bind>\n            (\\<lambda>y1.\n                \\<A>1 (x1, y1) \\<bind>\n                (\\<lambda>((m0, m1), \\<sigma>).\n                    assert_spmf (valid_msg m0 \\<and> valid_msg m1) \\<bind>\n                    (\\<lambda>_.\n                        sample_uniform q \\<bind>\n                        (\\<lambda>c.\n                            \\<A>2 c \\<sigma> \\<bind>\n                            (\\<lambda>guess.\n                                map_spmf ((=) guess)\n                                 coin_spmf)))))) ELSE coin_spmf", "by(simp add: map_spmf_conv_bind_spmf)"], ["proof (state)\nthis:\n  TRY sample_uniform q \\<bind>\n      (\\<lambda>x1.\n          sample_uniform q \\<bind>\n          (\\<lambda>y1.\n              \\<A>1 (x1, y1) \\<bind>\n              (\\<lambda>((m0, m1), \\<sigma>).\n                  assert_spmf (valid_msg m0 \\<and> valid_msg m1) \\<bind>\n                  (\\<lambda>_.\n                      coin_spmf \\<bind>\n                      (\\<lambda>d.\n                          sample_uniform q \\<bind>\n                          (\\<lambda>c.\n                              \\<A>2 c \\<sigma> \\<bind>\n                              (\\<lambda>b'.\n                                  return_spmf\n                                   (b' = d)))))))) ELSE coin_spmf =\n  TRY sample_uniform q \\<bind>\n      (\\<lambda>x1.\n          sample_uniform q \\<bind>\n          (\\<lambda>y1.\n              \\<A>1 (x1, y1) \\<bind>\n              (\\<lambda>((m0, m1), \\<sigma>).\n                  assert_spmf (valid_msg m0 \\<and> valid_msg m1) \\<bind>\n                  (\\<lambda>_.\n                      sample_uniform q \\<bind>\n                      (\\<lambda>c.\n                          \\<A>2 c \\<sigma> \\<bind>\n                          (\\<lambda>guess.\n                              map_spmf ((=) guess)\n                               coin_spmf)))))) ELSE coin_spmf\n\ngoal (1 subgoal):\n 1. spmf (rivest_commit.hiding_game_ind_cpa \\<A>) True - 1 / 2 = 0", "also"], ["proof (state)\nthis:\n  TRY sample_uniform q \\<bind>\n      (\\<lambda>x1.\n          sample_uniform q \\<bind>\n          (\\<lambda>y1.\n              \\<A>1 (x1, y1) \\<bind>\n              (\\<lambda>((m0, m1), \\<sigma>).\n                  assert_spmf (valid_msg m0 \\<and> valid_msg m1) \\<bind>\n                  (\\<lambda>_.\n                      coin_spmf \\<bind>\n                      (\\<lambda>d.\n                          sample_uniform q \\<bind>\n                          (\\<lambda>c.\n                              \\<A>2 c \\<sigma> \\<bind>\n                              (\\<lambda>b'.\n                                  return_spmf\n                                   (b' = d)))))))) ELSE coin_spmf =\n  TRY sample_uniform q \\<bind>\n      (\\<lambda>x1.\n          sample_uniform q \\<bind>\n          (\\<lambda>y1.\n              \\<A>1 (x1, y1) \\<bind>\n              (\\<lambda>((m0, m1), \\<sigma>).\n                  assert_spmf (valid_msg m0 \\<and> valid_msg m1) \\<bind>\n                  (\\<lambda>_.\n                      sample_uniform q \\<bind>\n                      (\\<lambda>c.\n                          \\<A>2 c \\<sigma> \\<bind>\n                          (\\<lambda>guess.\n                              map_spmf ((=) guess)\n                               coin_spmf)))))) ELSE coin_spmf\n\ngoal (1 subgoal):\n 1. spmf (rivest_commit.hiding_game_ind_cpa \\<A>) True - 1 / 2 = 0", "have \"... = coin_spmf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. TRY sample_uniform q \\<bind>\n        (\\<lambda>x1.\n            sample_uniform q \\<bind>\n            (\\<lambda>y1.\n                \\<A>1 (x1, y1) \\<bind>\n                (\\<lambda>((m0, m1), \\<sigma>).\n                    assert_spmf (valid_msg m0 \\<and> valid_msg m1) \\<bind>\n                    (\\<lambda>_.\n                        sample_uniform q \\<bind>\n                        (\\<lambda>c.\n                            \\<A>2 c \\<sigma> \\<bind>\n                            (\\<lambda>guess.\n                                map_spmf ((=) guess)\n                                 coin_spmf)))))) ELSE coin_spmf =\n    coin_spmf", "by(simp add: map_eq_const_coin_spmf bind_spmf_const try_bind_spmf_lossless2' \n        scale_bind_spmf weight_spmf_le_1 scale_scale_spmf)"], ["proof (state)\nthis:\n  TRY sample_uniform q \\<bind>\n      (\\<lambda>x1.\n          sample_uniform q \\<bind>\n          (\\<lambda>y1.\n              \\<A>1 (x1, y1) \\<bind>\n              (\\<lambda>((m0, m1), \\<sigma>).\n                  assert_spmf (valid_msg m0 \\<and> valid_msg m1) \\<bind>\n                  (\\<lambda>_.\n                      sample_uniform q \\<bind>\n                      (\\<lambda>c.\n                          \\<A>2 c \\<sigma> \\<bind>\n                          (\\<lambda>guess.\n                              map_spmf ((=) guess)\n                               coin_spmf)))))) ELSE coin_spmf =\n  coin_spmf\n\ngoal (1 subgoal):\n 1. spmf (rivest_commit.hiding_game_ind_cpa \\<A>) True - 1 / 2 = 0", "ultimately"], ["proof (chain)\npicking this:\n  rivest_commit.hiding_game_ind_cpa (\\<A>1, \\<A>2) =\n  TRY sample_uniform q \\<bind>\n      (\\<lambda>x1.\n          sample_uniform q \\<bind>\n          (\\<lambda>y1.\n              \\<A>1 (x1, y1) \\<bind>\n              (\\<lambda>((m0, m1), \\<sigma>).\n                  assert_spmf (valid_msg m0 \\<and> valid_msg m1) \\<bind>\n                  (\\<lambda>_.\n                      sample_uniform q \\<bind>\n                      (\\<lambda>c.\n                          \\<A>2 c \\<sigma> \\<bind>\n                          (\\<lambda>guess.\n                              map_spmf ((=) guess)\n                               coin_spmf)))))) ELSE coin_spmf\n  TRY sample_uniform q \\<bind>\n      (\\<lambda>x1.\n          sample_uniform q \\<bind>\n          (\\<lambda>y1.\n              \\<A>1 (x1, y1) \\<bind>\n              (\\<lambda>((m0, m1), \\<sigma>).\n                  assert_spmf (valid_msg m0 \\<and> valid_msg m1) \\<bind>\n                  (\\<lambda>_.\n                      sample_uniform q \\<bind>\n                      (\\<lambda>c.\n                          \\<A>2 c \\<sigma> \\<bind>\n                          (\\<lambda>guess.\n                              map_spmf ((=) guess)\n                               coin_spmf)))))) ELSE coin_spmf =\n  coin_spmf", "show ?thesis"], ["proof (prove)\nusing this:\n  rivest_commit.hiding_game_ind_cpa (\\<A>1, \\<A>2) =\n  TRY sample_uniform q \\<bind>\n      (\\<lambda>x1.\n          sample_uniform q \\<bind>\n          (\\<lambda>y1.\n              \\<A>1 (x1, y1) \\<bind>\n              (\\<lambda>((m0, m1), \\<sigma>).\n                  assert_spmf (valid_msg m0 \\<and> valid_msg m1) \\<bind>\n                  (\\<lambda>_.\n                      sample_uniform q \\<bind>\n                      (\\<lambda>c.\n                          \\<A>2 c \\<sigma> \\<bind>\n                          (\\<lambda>guess.\n                              map_spmf ((=) guess)\n                               coin_spmf)))))) ELSE coin_spmf\n  TRY sample_uniform q \\<bind>\n      (\\<lambda>x1.\n          sample_uniform q \\<bind>\n          (\\<lambda>y1.\n              \\<A>1 (x1, y1) \\<bind>\n              (\\<lambda>((m0, m1), \\<sigma>).\n                  assert_spmf (valid_msg m0 \\<and> valid_msg m1) \\<bind>\n                  (\\<lambda>_.\n                      sample_uniform q \\<bind>\n                      (\\<lambda>c.\n                          \\<A>2 c \\<sigma> \\<bind>\n                          (\\<lambda>guess.\n                              map_spmf ((=) guess)\n                               coin_spmf)))))) ELSE coin_spmf =\n  coin_spmf\n\ngoal (1 subgoal):\n 1. spmf (rivest_commit.hiding_game_ind_cpa \\<A>) True - 1 / 2 = 0", "by(simp add: spmf_of_set)"], ["proof (state)\nthis:\n  spmf (rivest_commit.hiding_game_ind_cpa \\<A>) True - 1 / 2 = 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rivest_perfect_hiding: \"rivest_commit.perfect_hiding_ind_cpa \\<A>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rivest_commit.perfect_hiding_ind_cpa \\<A>", "unfolding abstract_commitment.perfect_hiding_ind_cpa_def abstract_commitment.hiding_advantage_ind_cpa_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>spmf (rivest_commit.hiding_game_ind_cpa \\<A>) True - 1 / 2\\<bar> =\n    0", "by(simp add: rivest_hiding)"], ["", "lemma samp_uni_break':\n  assumes fst_cond: \"m \\<noteq> m' \\<and> valid_msg m \\<and> valid_msg m'\"\n    and c: \"c = (m + a) mod q \\<and> y1 = (a * x1 + b) mod q\" \n    and  c': \"c = (m' + a') mod q \\<and> y1 = (a' * x1 + b') mod q\"\n    and x1: \"x1 < q\" \n  shows \"x1 = (if (a mod q > a' mod q) then nat ((int b'- int b) * (inverse (nat ((int a mod q - int a' mod q) mod q)) q) mod q)  else \n          nat ((int b- int b') * (inverse (nat ((int a' mod q - int a mod q) mod q)) q) mod q))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x1 =\n    (if a' mod q < a mod q\n     then nat ((int b' - int b) *\n               Number_Theory_Aux.inverse\n                (nat ((int a mod int q - int a' mod int q) mod int q)) q mod\n               int q)\n     else nat ((int b - int b') *\n               Number_Theory_Aux.inverse\n                (nat ((int a' mod int q - int a mod int q) mod int q)) q mod\n               int q))", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. x1 =\n    (if a' mod q < a mod q\n     then nat ((int b' - int b) *\n               Number_Theory_Aux.inverse\n                (nat ((int a mod int q - int a' mod int q) mod int q)) q mod\n               int q)\n     else nat ((int b - int b') *\n               Number_Theory_Aux.inverse\n                (nat ((int a' mod int q - int a mod int q) mod int q)) q mod\n               int q))", "have m: \"m < q \\<and> m' < q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m < q \\<and> m' < q", "using fst_cond valid_msg_def"], ["proof (prove)\nusing this:\n  m \\<noteq> m' \\<and> valid_msg m \\<and> valid_msg m'\n  valid_msg ?msg \\<equiv> ?msg \\<in> {..<q}\n\ngoal (1 subgoal):\n 1. m < q \\<and> m' < q", "by simp"], ["proof (state)\nthis:\n  m < q \\<and> m' < q\n\ngoal (1 subgoal):\n 1. x1 =\n    (if a' mod q < a mod q\n     then nat ((int b' - int b) *\n               Number_Theory_Aux.inverse\n                (nat ((int a mod int q - int a' mod int q) mod int q)) q mod\n               int q)\n     else nat ((int b - int b') *\n               Number_Theory_Aux.inverse\n                (nat ((int a' mod int q - int a mod int q) mod int q)) q mod\n               int q))", "have a_a': \"\\<not> [a = a'] (mod q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [a \\<noteq> a'] (mod q)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. [a \\<noteq> a'] (mod q)", "have \"[m + a = m' + a'] (mod q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [m + a = m' + a'] (mod q)", "using assms cong_def"], ["proof (prove)\nusing this:\n  m \\<noteq> m' \\<and> valid_msg m \\<and> valid_msg m'\n  c = (m + a) mod q \\<and> y1 = (a * x1 + b) mod q\n  c = (m' + a') mod q \\<and> y1 = (a' * x1 + b') mod q\n  x1 < q\n  [?b = ?c] (mod ?a) = (?b mod ?a = ?c mod ?a)\n\ngoal (1 subgoal):\n 1. [m + a = m' + a'] (mod q)", "by blast"], ["proof (state)\nthis:\n  [m + a = m' + a'] (mod q)\n\ngoal (1 subgoal):\n 1. [a \\<noteq> a'] (mod q)", "thus ?thesis"], ["proof (prove)\nusing this:\n  [m + a = m' + a'] (mod q)\n\ngoal (1 subgoal):\n 1. [a \\<noteq> a'] (mod q)", "by (metis m fst_cond c c' add.commute cong_less_modulus_unique_nat cong_add_rcancel_nat cong_mod_right)"], ["proof (state)\nthis:\n  [a \\<noteq> a'] (mod q)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  [a \\<noteq> a'] (mod q)\n\ngoal (1 subgoal):\n 1. x1 =\n    (if a' mod q < a mod q\n     then nat ((int b' - int b) *\n               Number_Theory_Aux.inverse\n                (nat ((int a mod int q - int a' mod int q) mod int q)) q mod\n               int q)\n     else nat ((int b - int b') *\n               Number_Theory_Aux.inverse\n                (nat ((int a' mod int q - int a mod int q) mod int q)) q mod\n               int q))", "have cong_y1: \"[int a * int x1 + int b = int a' * int x1 + int b'] (mod q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [int a * int x1 + int b = int a' * int x1 + int b'] (mod int q)", "by (metis c c' cong_def Num.of_nat_simps(4) Num.of_nat_simps(5) cong_int_iff)"], ["proof (state)\nthis:\n  [int a * int x1 + int b = int a' * int x1 + int b'] (mod int q)\n\ngoal (1 subgoal):\n 1. x1 =\n    (if a' mod q < a mod q\n     then nat ((int b' - int b) *\n               Number_Theory_Aux.inverse\n                (nat ((int a mod int q - int a' mod int q) mod int q)) q mod\n               int q)\n     else nat ((int b - int b') *\n               Number_Theory_Aux.inverse\n                (nat ((int a' mod int q - int a mod int q) mod int q)) q mod\n               int q))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. x1 =\n    (if a' mod q < a mod q\n     then nat ((int b' - int b) *\n               Number_Theory_Aux.inverse\n                (nat ((int a mod int q - int a' mod int q) mod int q)) q mod\n               int q)\n     else nat ((int b - int b') *\n               Number_Theory_Aux.inverse\n                (nat ((int a' mod int q - int a mod int q) mod int q)) q mod\n               int q))", "proof(cases \"a mod q > a' mod q\")"], ["proof (state)\ngoal (2 subgoals):\n 1. a' mod q < a mod q \\<Longrightarrow>\n    x1 =\n    (if a' mod q < a mod q\n     then nat ((int b' - int b) *\n               Number_Theory_Aux.inverse\n                (nat ((int a mod int q - int a' mod int q) mod int q)) q mod\n               int q)\n     else nat ((int b - int b') *\n               Number_Theory_Aux.inverse\n                (nat ((int a' mod int q - int a mod int q) mod int q)) q mod\n               int q))\n 2. \\<not> a' mod q < a mod q \\<Longrightarrow>\n    x1 =\n    (if a' mod q < a mod q\n     then nat ((int b' - int b) *\n               Number_Theory_Aux.inverse\n                (nat ((int a mod int q - int a' mod int q) mod int q)) q mod\n               int q)\n     else nat ((int b - int b') *\n               Number_Theory_Aux.inverse\n                (nat ((int a' mod int q - int a mod int q) mod int q)) q mod\n               int q))", "case True"], ["proof (state)\nthis:\n  a' mod q < a mod q\n\ngoal (2 subgoals):\n 1. a' mod q < a mod q \\<Longrightarrow>\n    x1 =\n    (if a' mod q < a mod q\n     then nat ((int b' - int b) *\n               Number_Theory_Aux.inverse\n                (nat ((int a mod int q - int a' mod int q) mod int q)) q mod\n               int q)\n     else nat ((int b - int b') *\n               Number_Theory_Aux.inverse\n                (nat ((int a' mod int q - int a mod int q) mod int q)) q mod\n               int q))\n 2. \\<not> a' mod q < a mod q \\<Longrightarrow>\n    x1 =\n    (if a' mod q < a mod q\n     then nat ((int b' - int b) *\n               Number_Theory_Aux.inverse\n                (nat ((int a mod int q - int a' mod int q) mod int q)) q mod\n               int q)\n     else nat ((int b - int b') *\n               Number_Theory_Aux.inverse\n                (nat ((int a' mod int q - int a mod int q) mod int q)) q mod\n               int q))", "hence gcd: \"gcd (nat ((int a mod q - int a' mod q) mod q)) q = 1\""], ["proof (prove)\nusing this:\n  a' mod q < a mod q\n\ngoal (1 subgoal):\n 1. gcd (nat ((int a mod int q - int a' mod int q) mod int q)) q = 1", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. a' mod q < a mod q \\<Longrightarrow>\n    gcd (nat ((int a mod int q - int a' mod int q) mod int q)) q = 1", "have \"((int a mod q - int a' mod q) mod q) \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (int a mod int q - int a' mod int q) mod int q \\<noteq> 0", "by (metis True comm_monoid_add_class.add_0 diff_add_cancel mod_add_left_eq mod_diff_eq nat_mod_as_int order_less_irrefl)"], ["proof (state)\nthis:\n  (int a mod int q - int a' mod int q) mod int q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. a' mod q < a mod q \\<Longrightarrow>\n    gcd (nat ((int a mod int q - int a' mod int q) mod int q)) q = 1", "moreover"], ["proof (state)\nthis:\n  (int a mod int q - int a' mod int q) mod int q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. a' mod q < a mod q \\<Longrightarrow>\n    gcd (nat ((int a mod int q - int a' mod int q) mod int q)) q = 1", "have \"((int a mod q - int a' mod q) mod q) < q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (int a mod int q - int a' mod int q) mod int q < int q", "by simp"], ["proof (state)\nthis:\n  (int a mod int q - int a' mod int q) mod int q < int q\n\ngoal (1 subgoal):\n 1. a' mod q < a mod q \\<Longrightarrow>\n    gcd (nat ((int a mod int q - int a' mod int q) mod int q)) q = 1", "ultimately"], ["proof (chain)\npicking this:\n  (int a mod int q - int a' mod int q) mod int q \\<noteq> 0\n  (int a mod int q - int a' mod int q) mod int q < int q", "show ?thesis"], ["proof (prove)\nusing this:\n  (int a mod int q - int a' mod int q) mod int q \\<noteq> 0\n  (int a mod int q - int a' mod int q) mod int q < int q\n\ngoal (1 subgoal):\n 1. gcd (nat ((int a mod int q - int a' mod int q) mod int q)) q = 1", "using prime_field[of q \"nat ((int a mod int q - int a' mod int q) mod int q)\"] prime_q"], ["proof (prove)\nusing this:\n  (int a mod int q - int a' mod int q) mod int q \\<noteq> 0\n  (int a mod int q - int a' mod int q) mod int q < int q\n  \\<lbrakk>prime q;\n   nat ((int a mod int q - int a' mod int q) mod int q) < q;\n   nat ((int a mod int q - int a' mod int q) mod int q) \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> coprime\n                     (nat ((int a mod int q - int a' mod int q) mod int q))\n                     q\n  prime q\n\ngoal (1 subgoal):\n 1. gcd (nat ((int a mod int q - int a' mod int q) mod int q)) q = 1", "by (smt Euclidean_Division.pos_mod_sign coprime_imp_gcd_eq_1 int_nat_eq nat_less_iff of_nat_0_less_iff q_gt_0)"], ["proof (state)\nthis:\n  gcd (nat ((int a mod int q - int a' mod int q) mod int q)) q = 1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  gcd (nat ((int a mod int q - int a' mod int q) mod int q)) q = 1\n\ngoal (2 subgoals):\n 1. a' mod q < a mod q \\<Longrightarrow>\n    x1 =\n    (if a' mod q < a mod q\n     then nat ((int b' - int b) *\n               Number_Theory_Aux.inverse\n                (nat ((int a mod int q - int a' mod int q) mod int q)) q mod\n               int q)\n     else nat ((int b - int b') *\n               Number_Theory_Aux.inverse\n                (nat ((int a' mod int q - int a mod int q) mod int q)) q mod\n               int q))\n 2. \\<not> a' mod q < a mod q \\<Longrightarrow>\n    x1 =\n    (if a' mod q < a mod q\n     then nat ((int b' - int b) *\n               Number_Theory_Aux.inverse\n                (nat ((int a mod int q - int a' mod int q) mod int q)) q mod\n               int q)\n     else nat ((int b - int b') *\n               Number_Theory_Aux.inverse\n                (nat ((int a' mod int q - int a mod int q) mod int q)) q mod\n               int q))", "hence \"[int a * int x1 - int a' * int x1 = int b'- int b] (mod q)\""], ["proof (prove)\nusing this:\n  gcd (nat ((int a mod int q - int a' mod int q) mod int q)) q = 1\n\ngoal (1 subgoal):\n 1. [int a * int x1 - int a' * int x1 = int b' - int b] (mod int q)", "by (smt cong_diff_iff_cong_0 cong_y1 cong_diff cong_diff)"], ["proof (state)\nthis:\n  [int a * int x1 - int a' * int x1 = int b' - int b] (mod int q)\n\ngoal (2 subgoals):\n 1. a' mod q < a mod q \\<Longrightarrow>\n    x1 =\n    (if a' mod q < a mod q\n     then nat ((int b' - int b) *\n               Number_Theory_Aux.inverse\n                (nat ((int a mod int q - int a' mod int q) mod int q)) q mod\n               int q)\n     else nat ((int b - int b') *\n               Number_Theory_Aux.inverse\n                (nat ((int a' mod int q - int a mod int q) mod int q)) q mod\n               int q))\n 2. \\<not> a' mod q < a mod q \\<Longrightarrow>\n    x1 =\n    (if a' mod q < a mod q\n     then nat ((int b' - int b) *\n               Number_Theory_Aux.inverse\n                (nat ((int a mod int q - int a' mod int q) mod int q)) q mod\n               int q)\n     else nat ((int b - int b') *\n               Number_Theory_Aux.inverse\n                (nat ((int a' mod int q - int a mod int q) mod int q)) q mod\n               int q))", "hence \"[int a mod q * int x1 - int a' mod q * int x1 = int b'- int b] (mod q)\""], ["proof (prove)\nusing this:\n  [int a * int x1 - int a' * int x1 = int b' - int b] (mod int q)\n\ngoal (1 subgoal):\n 1. [int a mod int q * int x1 -\n     int a' mod int q * int x1 = int b' - int b] (mod int q)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. [int a * int x1 -\n     int a' * int x1 = int b' - int b] (mod int q) \\<Longrightarrow>\n    [int a mod int q * int x1 -\n     int a' mod int q * int x1 = int b' - int b] (mod int q)", "have \"[int x1 * (int a mod int q - int a' mod int q) = int x1 * (int a - int a')] (mod int q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [int x1 *\n     (int a mod int q -\n      int a' mod int q) = int x1 * (int a - int a')] (mod int q)", "by (meson cong_def cong_mult cong_refl mod_diff_eq)"], ["proof (state)\nthis:\n  [int x1 *\n   (int a mod int q -\n    int a' mod int q) = int x1 * (int a - int a')] (mod int q)\n\ngoal (1 subgoal):\n 1. [int a * int x1 -\n     int a' * int x1 = int b' - int b] (mod int q) \\<Longrightarrow>\n    [int a mod int q * int x1 -\n     int a' mod int q * int x1 = int b' - int b] (mod int q)", "then"], ["proof (chain)\npicking this:\n  [int x1 *\n   (int a mod int q -\n    int a' mod int q) = int x1 * (int a - int a')] (mod int q)", "show ?thesis"], ["proof (prove)\nusing this:\n  [int x1 *\n   (int a mod int q -\n    int a' mod int q) = int x1 * (int a - int a')] (mod int q)\n\ngoal (1 subgoal):\n 1. [int a mod int q * int x1 -\n     int a' mod int q * int x1 = int b' - int b] (mod int q)", "by (metis (no_types, hide_lams) Groups.mult_ac(2) \\<open>[int a * int x1 - int a' * int x1 = int b' - int b] (mod int q)\\<close> cong_def mod_diff_left_eq mod_diff_right_eq mod_mult_right_eq)"], ["proof (state)\nthis:\n  [int a mod int q * int x1 -\n   int a' mod int q * int x1 = int b' - int b] (mod int q)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  [int a mod int q * int x1 -\n   int a' mod int q * int x1 = int b' - int b] (mod int q)\n\ngoal (2 subgoals):\n 1. a' mod q < a mod q \\<Longrightarrow>\n    x1 =\n    (if a' mod q < a mod q\n     then nat ((int b' - int b) *\n               Number_Theory_Aux.inverse\n                (nat ((int a mod int q - int a' mod int q) mod int q)) q mod\n               int q)\n     else nat ((int b - int b') *\n               Number_Theory_Aux.inverse\n                (nat ((int a' mod int q - int a mod int q) mod int q)) q mod\n               int q))\n 2. \\<not> a' mod q < a mod q \\<Longrightarrow>\n    x1 =\n    (if a' mod q < a mod q\n     then nat ((int b' - int b) *\n               Number_Theory_Aux.inverse\n                (nat ((int a mod int q - int a' mod int q) mod int q)) q mod\n               int q)\n     else nat ((int b - int b') *\n               Number_Theory_Aux.inverse\n                (nat ((int a' mod int q - int a mod int q) mod int q)) q mod\n               int q))", "hence \"[int x1 * (int a mod q - int a' mod q) = int b'- int b] (mod q)\""], ["proof (prove)\nusing this:\n  [int a mod int q * int x1 -\n   int a' mod int q * int x1 = int b' - int b] (mod int q)\n\ngoal (1 subgoal):\n 1. [int x1 *\n     (int a mod int q - int a' mod int q) = int b' - int b] (mod int q)", "by(metis int_distrib(3) mult.commute)"], ["proof (state)\nthis:\n  [int x1 *\n   (int a mod int q - int a' mod int q) = int b' - int b] (mod int q)\n\ngoal (2 subgoals):\n 1. a' mod q < a mod q \\<Longrightarrow>\n    x1 =\n    (if a' mod q < a mod q\n     then nat ((int b' - int b) *\n               Number_Theory_Aux.inverse\n                (nat ((int a mod int q - int a' mod int q) mod int q)) q mod\n               int q)\n     else nat ((int b - int b') *\n               Number_Theory_Aux.inverse\n                (nat ((int a' mod int q - int a mod int q) mod int q)) q mod\n               int q))\n 2. \\<not> a' mod q < a mod q \\<Longrightarrow>\n    x1 =\n    (if a' mod q < a mod q\n     then nat ((int b' - int b) *\n               Number_Theory_Aux.inverse\n                (nat ((int a mod int q - int a' mod int q) mod int q)) q mod\n               int q)\n     else nat ((int b - int b') *\n               Number_Theory_Aux.inverse\n                (nat ((int a' mod int q - int a mod int q) mod int q)) q mod\n               int q))", "hence \"[int x1 * (int a mod q - int a' mod q) mod q = int b'- int b] (mod q)\""], ["proof (prove)\nusing this:\n  [int x1 *\n   (int a mod int q - int a' mod int q) = int b' - int b] (mod int q)\n\ngoal (1 subgoal):\n 1. [int x1 * (int a mod int q - int a' mod int q) mod\n     int q = int b' - int b] (mod int q)", "using cong_def"], ["proof (prove)\nusing this:\n  [int x1 *\n   (int a mod int q - int a' mod int q) = int b' - int b] (mod int q)\n  [?b = ?c] (mod ?a) = (?b mod ?a = ?c mod ?a)\n\ngoal (1 subgoal):\n 1. [int x1 * (int a mod int q - int a' mod int q) mod\n     int q = int b' - int b] (mod int q)", "by simp"], ["proof (state)\nthis:\n  [int x1 * (int a mod int q - int a' mod int q) mod\n   int q = int b' - int b] (mod int q)\n\ngoal (2 subgoals):\n 1. a' mod q < a mod q \\<Longrightarrow>\n    x1 =\n    (if a' mod q < a mod q\n     then nat ((int b' - int b) *\n               Number_Theory_Aux.inverse\n                (nat ((int a mod int q - int a' mod int q) mod int q)) q mod\n               int q)\n     else nat ((int b - int b') *\n               Number_Theory_Aux.inverse\n                (nat ((int a' mod int q - int a mod int q) mod int q)) q mod\n               int q))\n 2. \\<not> a' mod q < a mod q \\<Longrightarrow>\n    x1 =\n    (if a' mod q < a mod q\n     then nat ((int b' - int b) *\n               Number_Theory_Aux.inverse\n                (nat ((int a mod int q - int a' mod int q) mod int q)) q mod\n               int q)\n     else nat ((int b - int b') *\n               Number_Theory_Aux.inverse\n                (nat ((int a' mod int q - int a mod int q) mod int q)) q mod\n               int q))", "hence \"[int x1 * nat ((int a mod q - int a' mod q) mod q) = int b'- int b] (mod q)\""], ["proof (prove)\nusing this:\n  [int x1 * (int a mod int q - int a' mod int q) mod\n   int q = int b' - int b] (mod int q)\n\ngoal (1 subgoal):\n 1. [int x1 *\n     int (nat ((int a mod int q - int a' mod int q) mod\n               int q)) = int b' - int b] (mod int q)", "by (simp add: True cong_def mod_mult_right_eq)"], ["proof (state)\nthis:\n  [int x1 *\n   int (nat ((int a mod int q - int a' mod int q) mod\n             int q)) = int b' - int b] (mod int q)\n\ngoal (2 subgoals):\n 1. a' mod q < a mod q \\<Longrightarrow>\n    x1 =\n    (if a' mod q < a mod q\n     then nat ((int b' - int b) *\n               Number_Theory_Aux.inverse\n                (nat ((int a mod int q - int a' mod int q) mod int q)) q mod\n               int q)\n     else nat ((int b - int b') *\n               Number_Theory_Aux.inverse\n                (nat ((int a' mod int q - int a mod int q) mod int q)) q mod\n               int q))\n 2. \\<not> a' mod q < a mod q \\<Longrightarrow>\n    x1 =\n    (if a' mod q < a mod q\n     then nat ((int b' - int b) *\n               Number_Theory_Aux.inverse\n                (nat ((int a mod int q - int a' mod int q) mod int q)) q mod\n               int q)\n     else nat ((int b - int b') *\n               Number_Theory_Aux.inverse\n                (nat ((int a' mod int q - int a mod int q) mod int q)) q mod\n               int q))", "hence \"[int x1 * nat ((int a mod q - int a' mod q) mod q) * inverse (nat ((int a mod q - int a' mod q) mod q)) q \n              = (int b'- int b) * inverse (nat ((int a mod q - int a' mod q) mod q)) q] (mod q)\""], ["proof (prove)\nusing this:\n  [int x1 *\n   int (nat ((int a mod int q - int a' mod int q) mod\n             int q)) = int b' - int b] (mod int q)\n\ngoal (1 subgoal):\n 1. [int x1 * int (nat ((int a mod int q - int a' mod int q) mod int q)) *\n     Number_Theory_Aux.inverse\n      (nat ((int a mod int q - int a' mod int q) mod int q))\n      q = (int b' - int b) *\n          Number_Theory_Aux.inverse\n           (nat ((int a mod int q - int a' mod int q) mod int q))\n           q] (mod int q)", "using cong_scalar_right"], ["proof (prove)\nusing this:\n  [int x1 *\n   int (nat ((int a mod int q - int a' mod int q) mod\n             int q)) = int b' - int b] (mod int q)\n  [?b = ?c] (mod ?a) \\<Longrightarrow> [?b * ?d = ?c * ?d] (mod ?a)\n\ngoal (1 subgoal):\n 1. [int x1 * int (nat ((int a mod int q - int a' mod int q) mod int q)) *\n     Number_Theory_Aux.inverse\n      (nat ((int a mod int q - int a' mod int q) mod int q))\n      q = (int b' - int b) *\n          Number_Theory_Aux.inverse\n           (nat ((int a mod int q - int a' mod int q) mod int q))\n           q] (mod int q)", "by blast"], ["proof (state)\nthis:\n  [int x1 * int (nat ((int a mod int q - int a' mod int q) mod int q)) *\n   Number_Theory_Aux.inverse\n    (nat ((int a mod int q - int a' mod int q) mod int q))\n    q = (int b' - int b) *\n        Number_Theory_Aux.inverse\n         (nat ((int a mod int q - int a' mod int q) mod int q))\n         q] (mod int q)\n\ngoal (2 subgoals):\n 1. a' mod q < a mod q \\<Longrightarrow>\n    x1 =\n    (if a' mod q < a mod q\n     then nat ((int b' - int b) *\n               Number_Theory_Aux.inverse\n                (nat ((int a mod int q - int a' mod int q) mod int q)) q mod\n               int q)\n     else nat ((int b - int b') *\n               Number_Theory_Aux.inverse\n                (nat ((int a' mod int q - int a mod int q) mod int q)) q mod\n               int q))\n 2. \\<not> a' mod q < a mod q \\<Longrightarrow>\n    x1 =\n    (if a' mod q < a mod q\n     then nat ((int b' - int b) *\n               Number_Theory_Aux.inverse\n                (nat ((int a mod int q - int a' mod int q) mod int q)) q mod\n               int q)\n     else nat ((int b - int b') *\n               Number_Theory_Aux.inverse\n                (nat ((int a' mod int q - int a mod int q) mod int q)) q mod\n               int q))", "hence \"[int x1 * (nat ((int a mod q - int a' mod q) mod q) * inverse (nat ((int a mod q - int a' mod q) mod q)) q) \n              = (int b'- int b) * inverse (nat ((int a mod q - int a' mod q) mod q)) q] (mod q)\""], ["proof (prove)\nusing this:\n  [int x1 * int (nat ((int a mod int q - int a' mod int q) mod int q)) *\n   Number_Theory_Aux.inverse\n    (nat ((int a mod int q - int a' mod int q) mod int q))\n    q = (int b' - int b) *\n        Number_Theory_Aux.inverse\n         (nat ((int a mod int q - int a' mod int q) mod int q))\n         q] (mod int q)\n\ngoal (1 subgoal):\n 1. [int x1 *\n     (int (nat ((int a mod int q - int a' mod int q) mod int q)) *\n      Number_Theory_Aux.inverse\n       (nat ((int a mod int q - int a' mod int q) mod int q))\n       q) = (int b' - int b) *\n            Number_Theory_Aux.inverse\n             (nat ((int a mod int q - int a' mod int q) mod int q))\n             q] (mod int q)", "by (simp add: more_arith_simps(11))"], ["proof (state)\nthis:\n  [int x1 *\n   (int (nat ((int a mod int q - int a' mod int q) mod int q)) *\n    Number_Theory_Aux.inverse\n     (nat ((int a mod int q - int a' mod int q) mod int q))\n     q) = (int b' - int b) *\n          Number_Theory_Aux.inverse\n           (nat ((int a mod int q - int a' mod int q) mod int q))\n           q] (mod int q)\n\ngoal (2 subgoals):\n 1. a' mod q < a mod q \\<Longrightarrow>\n    x1 =\n    (if a' mod q < a mod q\n     then nat ((int b' - int b) *\n               Number_Theory_Aux.inverse\n                (nat ((int a mod int q - int a' mod int q) mod int q)) q mod\n               int q)\n     else nat ((int b - int b') *\n               Number_Theory_Aux.inverse\n                (nat ((int a' mod int q - int a mod int q) mod int q)) q mod\n               int q))\n 2. \\<not> a' mod q < a mod q \\<Longrightarrow>\n    x1 =\n    (if a' mod q < a mod q\n     then nat ((int b' - int b) *\n               Number_Theory_Aux.inverse\n                (nat ((int a mod int q - int a' mod int q) mod int q)) q mod\n               int q)\n     else nat ((int b - int b') *\n               Number_Theory_Aux.inverse\n                (nat ((int a' mod int q - int a mod int q) mod int q)) q mod\n               int q))", "hence \"[int x1 * 1 = (int b'- int b) * inverse (nat ((int a mod q - int a' mod q) mod q)) q] (mod q)\""], ["proof (prove)\nusing this:\n  [int x1 *\n   (int (nat ((int a mod int q - int a' mod int q) mod int q)) *\n    Number_Theory_Aux.inverse\n     (nat ((int a mod int q - int a' mod int q) mod int q))\n     q) = (int b' - int b) *\n          Number_Theory_Aux.inverse\n           (nat ((int a mod int q - int a' mod int q) mod int q))\n           q] (mod int q)\n\ngoal (1 subgoal):\n 1. [int x1 *\n     1 = (int b' - int b) *\n         Number_Theory_Aux.inverse\n          (nat ((int a mod int q - int a' mod int q) mod int q))\n          q] (mod int q)", "using inverse gcd"], ["proof (prove)\nusing this:\n  [int x1 *\n   (int (nat ((int a mod int q - int a' mod int q) mod int q)) *\n    Number_Theory_Aux.inverse\n     (nat ((int a mod int q - int a' mod int q) mod int q))\n     q) = (int b' - int b) *\n          Number_Theory_Aux.inverse\n           (nat ((int a mod int q - int a' mod int q) mod int q))\n           q] (mod int q)\n  gcd ?x ?q = 1 \\<Longrightarrow>\n  [int ?x * Number_Theory_Aux.inverse ?x ?q = 1] (mod int ?q)\n  gcd (nat ((int a mod int q - int a' mod int q) mod int q)) q = 1\n\ngoal (1 subgoal):\n 1. [int x1 *\n     1 = (int b' - int b) *\n         Number_Theory_Aux.inverse\n          (nat ((int a mod int q - int a' mod int q) mod int q))\n          q] (mod int q)", "by (meson cong_scalar_left cong_sym_eq cong_trans)"], ["proof (state)\nthis:\n  [int x1 *\n   1 = (int b' - int b) *\n       Number_Theory_Aux.inverse\n        (nat ((int a mod int q - int a' mod int q) mod int q))\n        q] (mod int q)\n\ngoal (2 subgoals):\n 1. a' mod q < a mod q \\<Longrightarrow>\n    x1 =\n    (if a' mod q < a mod q\n     then nat ((int b' - int b) *\n               Number_Theory_Aux.inverse\n                (nat ((int a mod int q - int a' mod int q) mod int q)) q mod\n               int q)\n     else nat ((int b - int b') *\n               Number_Theory_Aux.inverse\n                (nat ((int a' mod int q - int a mod int q) mod int q)) q mod\n               int q))\n 2. \\<not> a' mod q < a mod q \\<Longrightarrow>\n    x1 =\n    (if a' mod q < a mod q\n     then nat ((int b' - int b) *\n               Number_Theory_Aux.inverse\n                (nat ((int a mod int q - int a' mod int q) mod int q)) q mod\n               int q)\n     else nat ((int b - int b') *\n               Number_Theory_Aux.inverse\n                (nat ((int a' mod int q - int a mod int q) mod int q)) q mod\n               int q))", "hence \"[int x1 = (int b'- int b) * inverse (nat ((int a mod q - int a' mod q) mod q)) q] (mod q)\""], ["proof (prove)\nusing this:\n  [int x1 *\n   1 = (int b' - int b) *\n       Number_Theory_Aux.inverse\n        (nat ((int a mod int q - int a' mod int q) mod int q))\n        q] (mod int q)\n\ngoal (1 subgoal):\n 1. [int x1 = (int b' - int b) *\n              Number_Theory_Aux.inverse\n               (nat ((int a mod int q - int a' mod int q) mod int q))\n               q] (mod int q)", "by simp"], ["proof (state)\nthis:\n  [int x1 = (int b' - int b) *\n            Number_Theory_Aux.inverse\n             (nat ((int a mod int q - int a' mod int q) mod int q))\n             q] (mod int q)\n\ngoal (2 subgoals):\n 1. a' mod q < a mod q \\<Longrightarrow>\n    x1 =\n    (if a' mod q < a mod q\n     then nat ((int b' - int b) *\n               Number_Theory_Aux.inverse\n                (nat ((int a mod int q - int a' mod int q) mod int q)) q mod\n               int q)\n     else nat ((int b - int b') *\n               Number_Theory_Aux.inverse\n                (nat ((int a' mod int q - int a mod int q) mod int q)) q mod\n               int q))\n 2. \\<not> a' mod q < a mod q \\<Longrightarrow>\n    x1 =\n    (if a' mod q < a mod q\n     then nat ((int b' - int b) *\n               Number_Theory_Aux.inverse\n                (nat ((int a mod int q - int a' mod int q) mod int q)) q mod\n               int q)\n     else nat ((int b - int b') *\n               Number_Theory_Aux.inverse\n                (nat ((int a' mod int q - int a mod int q) mod int q)) q mod\n               int q))", "hence \"int x1 mod q = ((int b'- int b) * inverse (nat ((int a mod q - int a' mod q) mod q)) q) mod q\""], ["proof (prove)\nusing this:\n  [int x1 = (int b' - int b) *\n            Number_Theory_Aux.inverse\n             (nat ((int a mod int q - int a' mod int q) mod int q))\n             q] (mod int q)\n\ngoal (1 subgoal):\n 1. int x1 mod int q =\n    (int b' - int b) *\n    Number_Theory_Aux.inverse\n     (nat ((int a mod int q - int a' mod int q) mod int q)) q mod\n    int q", "using cong_def"], ["proof (prove)\nusing this:\n  [int x1 = (int b' - int b) *\n            Number_Theory_Aux.inverse\n             (nat ((int a mod int q - int a' mod int q) mod int q))\n             q] (mod int q)\n  [?b = ?c] (mod ?a) = (?b mod ?a = ?c mod ?a)\n\ngoal (1 subgoal):\n 1. int x1 mod int q =\n    (int b' - int b) *\n    Number_Theory_Aux.inverse\n     (nat ((int a mod int q - int a' mod int q) mod int q)) q mod\n    int q", "by fast"], ["proof (state)\nthis:\n  int x1 mod int q =\n  (int b' - int b) *\n  Number_Theory_Aux.inverse\n   (nat ((int a mod int q - int a' mod int q) mod int q)) q mod\n  int q\n\ngoal (2 subgoals):\n 1. a' mod q < a mod q \\<Longrightarrow>\n    x1 =\n    (if a' mod q < a mod q\n     then nat ((int b' - int b) *\n               Number_Theory_Aux.inverse\n                (nat ((int a mod int q - int a' mod int q) mod int q)) q mod\n               int q)\n     else nat ((int b - int b') *\n               Number_Theory_Aux.inverse\n                (nat ((int a' mod int q - int a mod int q) mod int q)) q mod\n               int q))\n 2. \\<not> a' mod q < a mod q \\<Longrightarrow>\n    x1 =\n    (if a' mod q < a mod q\n     then nat ((int b' - int b) *\n               Number_Theory_Aux.inverse\n                (nat ((int a mod int q - int a' mod int q) mod int q)) q mod\n               int q)\n     else nat ((int b - int b') *\n               Number_Theory_Aux.inverse\n                (nat ((int a' mod int q - int a mod int q) mod int q)) q mod\n               int q))", "thus ?thesis"], ["proof (prove)\nusing this:\n  int x1 mod int q =\n  (int b' - int b) *\n  Number_Theory_Aux.inverse\n   (nat ((int a mod int q - int a' mod int q) mod int q)) q mod\n  int q\n\ngoal (1 subgoal):\n 1. x1 =\n    (if a' mod q < a mod q\n     then nat ((int b' - int b) *\n               Number_Theory_Aux.inverse\n                (nat ((int a mod int q - int a' mod int q) mod int q)) q mod\n               int q)\n     else nat ((int b - int b') *\n               Number_Theory_Aux.inverse\n                (nat ((int a' mod int q - int a mod int q) mod int q)) q mod\n               int q))", "using x1 True"], ["proof (prove)\nusing this:\n  int x1 mod int q =\n  (int b' - int b) *\n  Number_Theory_Aux.inverse\n   (nat ((int a mod int q - int a' mod int q) mod int q)) q mod\n  int q\n  x1 < q\n  a' mod q < a mod q\n\ngoal (1 subgoal):\n 1. x1 =\n    (if a' mod q < a mod q\n     then nat ((int b' - int b) *\n               Number_Theory_Aux.inverse\n                (nat ((int a mod int q - int a' mod int q) mod int q)) q mod\n               int q)\n     else nat ((int b - int b') *\n               Number_Theory_Aux.inverse\n                (nat ((int a' mod int q - int a mod int q) mod int q)) q mod\n               int q))", "by simp"], ["proof (state)\nthis:\n  x1 =\n  (if a' mod q < a mod q\n   then nat ((int b' - int b) *\n             Number_Theory_Aux.inverse\n              (nat ((int a mod int q - int a' mod int q) mod int q)) q mod\n             int q)\n   else nat ((int b - int b') *\n             Number_Theory_Aux.inverse\n              (nat ((int a' mod int q - int a mod int q) mod int q)) q mod\n             int q))\n\ngoal (1 subgoal):\n 1. \\<not> a' mod q < a mod q \\<Longrightarrow>\n    x1 =\n    (if a' mod q < a mod q\n     then nat ((int b' - int b) *\n               Number_Theory_Aux.inverse\n                (nat ((int a mod int q - int a' mod int q) mod int q)) q mod\n               int q)\n     else nat ((int b - int b') *\n               Number_Theory_Aux.inverse\n                (nat ((int a' mod int q - int a mod int q) mod int q)) q mod\n               int q))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> a' mod q < a mod q \\<Longrightarrow>\n    x1 =\n    (if a' mod q < a mod q\n     then nat ((int b' - int b) *\n               Number_Theory_Aux.inverse\n                (nat ((int a mod int q - int a' mod int q) mod int q)) q mod\n               int q)\n     else nat ((int b - int b') *\n               Number_Theory_Aux.inverse\n                (nat ((int a' mod int q - int a mod int q) mod int q)) q mod\n               int q))", "case False"], ["proof (state)\nthis:\n  \\<not> a' mod q < a mod q\n\ngoal (1 subgoal):\n 1. \\<not> a' mod q < a mod q \\<Longrightarrow>\n    x1 =\n    (if a' mod q < a mod q\n     then nat ((int b' - int b) *\n               Number_Theory_Aux.inverse\n                (nat ((int a mod int q - int a' mod int q) mod int q)) q mod\n               int q)\n     else nat ((int b - int b') *\n               Number_Theory_Aux.inverse\n                (nat ((int a' mod int q - int a mod int q) mod int q)) q mod\n               int q))", "hence aa': \"a mod q < a' mod q\""], ["proof (prove)\nusing this:\n  \\<not> a' mod q < a mod q\n\ngoal (1 subgoal):\n 1. a mod q < a' mod q", "using a_a' cong_refl nat_neq_iff"], ["proof (prove)\nusing this:\n  \\<not> a' mod q < a mod q\n  [a \\<noteq> a'] (mod q)\n  [?b = ?b] (mod ?a)\n  (?m \\<noteq> ?n) = (?m < ?n \\<or> ?n < ?m)\n\ngoal (1 subgoal):\n 1. a mod q < a' mod q", "by (simp add: cong_def)"], ["proof (state)\nthis:\n  a mod q < a' mod q\n\ngoal (1 subgoal):\n 1. \\<not> a' mod q < a mod q \\<Longrightarrow>\n    x1 =\n    (if a' mod q < a mod q\n     then nat ((int b' - int b) *\n               Number_Theory_Aux.inverse\n                (nat ((int a mod int q - int a' mod int q) mod int q)) q mod\n               int q)\n     else nat ((int b - int b') *\n               Number_Theory_Aux.inverse\n                (nat ((int a' mod int q - int a mod int q) mod int q)) q mod\n               int q))", "hence gcd: \"gcd (nat ((int a' mod q - int a mod q) mod q)) q = 1\""], ["proof (prove)\nusing this:\n  a mod q < a' mod q\n\ngoal (1 subgoal):\n 1. gcd (nat ((int a' mod int q - int a mod int q) mod int q)) q = 1", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. a mod q < a' mod q \\<Longrightarrow>\n    gcd (nat ((int a' mod int q - int a mod int q) mod int q)) q = 1", "have \"((int a' mod q - int a mod q) mod q) \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (int a' mod int q - int a mod int q) mod int q \\<noteq> 0", "by (metis aa' comm_monoid_add_class.add_0 diff_add_cancel mod_add_left_eq mod_diff_eq nat_mod_as_int order_less_irrefl)"], ["proof (state)\nthis:\n  (int a' mod int q - int a mod int q) mod int q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. a mod q < a' mod q \\<Longrightarrow>\n    gcd (nat ((int a' mod int q - int a mod int q) mod int q)) q = 1", "moreover"], ["proof (state)\nthis:\n  (int a' mod int q - int a mod int q) mod int q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. a mod q < a' mod q \\<Longrightarrow>\n    gcd (nat ((int a' mod int q - int a mod int q) mod int q)) q = 1", "have \"((int a' mod q - int a mod q) mod q) < q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (int a' mod int q - int a mod int q) mod int q < int q", "by simp"], ["proof (state)\nthis:\n  (int a' mod int q - int a mod int q) mod int q < int q\n\ngoal (1 subgoal):\n 1. a mod q < a' mod q \\<Longrightarrow>\n    gcd (nat ((int a' mod int q - int a mod int q) mod int q)) q = 1", "ultimately"], ["proof (chain)\npicking this:\n  (int a' mod int q - int a mod int q) mod int q \\<noteq> 0\n  (int a' mod int q - int a mod int q) mod int q < int q", "show ?thesis"], ["proof (prove)\nusing this:\n  (int a' mod int q - int a mod int q) mod int q \\<noteq> 0\n  (int a' mod int q - int a mod int q) mod int q < int q\n\ngoal (1 subgoal):\n 1. gcd (nat ((int a' mod int q - int a mod int q) mod int q)) q = 1", "using prime_field[of q \"nat ((int a' mod int q - int a mod int q) mod int q)\"] prime_q"], ["proof (prove)\nusing this:\n  (int a' mod int q - int a mod int q) mod int q \\<noteq> 0\n  (int a' mod int q - int a mod int q) mod int q < int q\n  \\<lbrakk>prime q;\n   nat ((int a' mod int q - int a mod int q) mod int q) < q;\n   nat ((int a' mod int q - int a mod int q) mod int q) \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> coprime\n                     (nat ((int a' mod int q - int a mod int q) mod int q))\n                     q\n  prime q\n\ngoal (1 subgoal):\n 1. gcd (nat ((int a' mod int q - int a mod int q) mod int q)) q = 1", "by (smt Euclidean_Division.pos_mod_sign coprime_imp_gcd_eq_1 int_nat_eq nat_less_iff of_nat_0_less_iff q_gt_0)"], ["proof (state)\nthis:\n  gcd (nat ((int a' mod int q - int a mod int q) mod int q)) q = 1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  gcd (nat ((int a' mod int q - int a mod int q) mod int q)) q = 1\n\ngoal (1 subgoal):\n 1. \\<not> a' mod q < a mod q \\<Longrightarrow>\n    x1 =\n    (if a' mod q < a mod q\n     then nat ((int b' - int b) *\n               Number_Theory_Aux.inverse\n                (nat ((int a mod int q - int a' mod int q) mod int q)) q mod\n               int q)\n     else nat ((int b - int b') *\n               Number_Theory_Aux.inverse\n                (nat ((int a' mod int q - int a mod int q) mod int q)) q mod\n               int q))", "have \"[int b - int b' = int a' * int x1 - int a * int x1] (mod q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [int b - int b' = int a' * int x1 - int a * int x1] (mod int q)", "by (smt cong_diff_iff_cong_0 cong_y1 cong_diff cong_diff)"], ["proof (state)\nthis:\n  [int b - int b' = int a' * int x1 - int a * int x1] (mod int q)\n\ngoal (1 subgoal):\n 1. \\<not> a' mod q < a mod q \\<Longrightarrow>\n    x1 =\n    (if a' mod q < a mod q\n     then nat ((int b' - int b) *\n               Number_Theory_Aux.inverse\n                (nat ((int a mod int q - int a' mod int q) mod int q)) q mod\n               int q)\n     else nat ((int b - int b') *\n               Number_Theory_Aux.inverse\n                (nat ((int a' mod int q - int a mod int q) mod int q)) q mod\n               int q))", "hence \"[int b - int b' = int x1 * (int a' - int a)] (mod q)\""], ["proof (prove)\nusing this:\n  [int b - int b' = int a' * int x1 - int a * int x1] (mod int q)\n\ngoal (1 subgoal):\n 1. [int b - int b' = int x1 * (int a' - int a)] (mod int q)", "using int_distrib mult.commute"], ["proof (prove)\nusing this:\n  [int b - int b' = int a' * int x1 - int a * int x1] (mod int q)\n  (?z1.0 + ?z2.0) * ?w = ?z1.0 * ?w + ?z2.0 * ?w\n  ?w * (?z1.0 + ?z2.0) = ?w * ?z1.0 + ?w * ?z2.0\n  (?z1.0 - ?z2.0) * ?w = ?z1.0 * ?w - ?z2.0 * ?w\n  ?w * (?z1.0 - ?z2.0) = ?w * ?z1.0 - ?w * ?z2.0\n  ?a * ?b = ?b * ?a\n\ngoal (1 subgoal):\n 1. [int b - int b' = int x1 * (int a' - int a)] (mod int q)", "by metis"], ["proof (state)\nthis:\n  [int b - int b' = int x1 * (int a' - int a)] (mod int q)\n\ngoal (1 subgoal):\n 1. \\<not> a' mod q < a mod q \\<Longrightarrow>\n    x1 =\n    (if a' mod q < a mod q\n     then nat ((int b' - int b) *\n               Number_Theory_Aux.inverse\n                (nat ((int a mod int q - int a' mod int q) mod int q)) q mod\n               int q)\n     else nat ((int b - int b') *\n               Number_Theory_Aux.inverse\n                (nat ((int a' mod int q - int a mod int q) mod int q)) q mod\n               int q))", "hence \"[int b - int b' = int x1 * (int a' mod q - int a mod q)] (mod q)\""], ["proof (prove)\nusing this:\n  [int b - int b' = int x1 * (int a' - int a)] (mod int q)\n\ngoal (1 subgoal):\n 1. [int b -\n     int b' = int x1 * (int a' mod int q - int a mod int q)] (mod int q)", "by (metis (no_types, lifting) cong_def mod_diff_eq mod_mult_right_eq)"], ["proof (state)\nthis:\n  [int b -\n   int b' = int x1 * (int a' mod int q - int a mod int q)] (mod int q)\n\ngoal (1 subgoal):\n 1. \\<not> a' mod q < a mod q \\<Longrightarrow>\n    x1 =\n    (if a' mod q < a mod q\n     then nat ((int b' - int b) *\n               Number_Theory_Aux.inverse\n                (nat ((int a mod int q - int a' mod int q) mod int q)) q mod\n               int q)\n     else nat ((int b - int b') *\n               Number_Theory_Aux.inverse\n                (nat ((int a' mod int q - int a mod int q) mod int q)) q mod\n               int q))", "hence \"[int b - int b' = int x1 * (int a' mod q - int a mod q) mod q] (mod q)\""], ["proof (prove)\nusing this:\n  [int b -\n   int b' = int x1 * (int a' mod int q - int a mod int q)] (mod int q)\n\ngoal (1 subgoal):\n 1. [int b -\n     int b' = int x1 * (int a' mod int q - int a mod int q) mod\n              int q] (mod int q)", "using cong_def"], ["proof (prove)\nusing this:\n  [int b -\n   int b' = int x1 * (int a' mod int q - int a mod int q)] (mod int q)\n  [?b = ?c] (mod ?a) = (?b mod ?a = ?c mod ?a)\n\ngoal (1 subgoal):\n 1. [int b -\n     int b' = int x1 * (int a' mod int q - int a mod int q) mod\n              int q] (mod int q)", "by simp"], ["proof (state)\nthis:\n  [int b -\n   int b' = int x1 * (int a' mod int q - int a mod int q) mod\n            int q] (mod int q)\n\ngoal (1 subgoal):\n 1. \\<not> a' mod q < a mod q \\<Longrightarrow>\n    x1 =\n    (if a' mod q < a mod q\n     then nat ((int b' - int b) *\n               Number_Theory_Aux.inverse\n                (nat ((int a mod int q - int a' mod int q) mod int q)) q mod\n               int q)\n     else nat ((int b - int b') *\n               Number_Theory_Aux.inverse\n                (nat ((int a' mod int q - int a mod int q) mod int q)) q mod\n               int q))", "hence \"[(int b - int b') * inverse (nat ((int a' mod q - int a mod q) mod q)) q \n               = int x1 * (int a' mod q - int a mod q) mod q *  inverse (nat ((int a' mod q - int a mod q) mod q)) q ] (mod q)\""], ["proof (prove)\nusing this:\n  [int b -\n   int b' = int x1 * (int a' mod int q - int a mod int q) mod\n            int q] (mod int q)\n\ngoal (1 subgoal):\n 1. [(int b - int b') *\n     Number_Theory_Aux.inverse\n      (nat ((int a' mod int q - int a mod int q) mod int q))\n      q = int x1 * (int a' mod int q - int a mod int q) mod int q *\n          Number_Theory_Aux.inverse\n           (nat ((int a' mod int q - int a mod int q) mod int q))\n           q] (mod int q)", "using cong_scalar_right"], ["proof (prove)\nusing this:\n  [int b -\n   int b' = int x1 * (int a' mod int q - int a mod int q) mod\n            int q] (mod int q)\n  [?b = ?c] (mod ?a) \\<Longrightarrow> [?b * ?d = ?c * ?d] (mod ?a)\n\ngoal (1 subgoal):\n 1. [(int b - int b') *\n     Number_Theory_Aux.inverse\n      (nat ((int a' mod int q - int a mod int q) mod int q))\n      q = int x1 * (int a' mod int q - int a mod int q) mod int q *\n          Number_Theory_Aux.inverse\n           (nat ((int a' mod int q - int a mod int q) mod int q))\n           q] (mod int q)", "by blast"], ["proof (state)\nthis:\n  [(int b - int b') *\n   Number_Theory_Aux.inverse\n    (nat ((int a' mod int q - int a mod int q) mod int q))\n    q = int x1 * (int a' mod int q - int a mod int q) mod int q *\n        Number_Theory_Aux.inverse\n         (nat ((int a' mod int q - int a mod int q) mod int q))\n         q] (mod int q)\n\ngoal (1 subgoal):\n 1. \\<not> a' mod q < a mod q \\<Longrightarrow>\n    x1 =\n    (if a' mod q < a mod q\n     then nat ((int b' - int b) *\n               Number_Theory_Aux.inverse\n                (nat ((int a mod int q - int a' mod int q) mod int q)) q mod\n               int q)\n     else nat ((int b - int b') *\n               Number_Theory_Aux.inverse\n                (nat ((int a' mod int q - int a mod int q) mod int q)) q mod\n               int q))", "hence \"[(int b - int b') * inverse (nat ((int a' mod q - int a mod q) mod q)) q \n               = int x1 * ((int a' mod q - int a mod q) mod q *  inverse (nat ((int a' mod q - int a mod q) mod q)) q)] (mod q)\""], ["proof (prove)\nusing this:\n  [(int b - int b') *\n   Number_Theory_Aux.inverse\n    (nat ((int a' mod int q - int a mod int q) mod int q))\n    q = int x1 * (int a' mod int q - int a mod int q) mod int q *\n        Number_Theory_Aux.inverse\n         (nat ((int a' mod int q - int a mod int q) mod int q))\n         q] (mod int q)\n\ngoal (1 subgoal):\n 1. [(int b - int b') *\n     Number_Theory_Aux.inverse\n      (nat ((int a' mod int q - int a mod int q) mod int q))\n      q = int x1 *\n          ((int a' mod int q - int a mod int q) mod int q *\n           Number_Theory_Aux.inverse\n            (nat ((int a' mod int q - int a mod int q) mod int q))\n            q)] (mod int q)", "by (metis (mono_tags, lifting) cong_def mod_mult_left_eq mod_mult_right_eq more_arith_simps(11))"], ["proof (state)\nthis:\n  [(int b - int b') *\n   Number_Theory_Aux.inverse\n    (nat ((int a' mod int q - int a mod int q) mod int q))\n    q = int x1 *\n        ((int a' mod int q - int a mod int q) mod int q *\n         Number_Theory_Aux.inverse\n          (nat ((int a' mod int q - int a mod int q) mod int q))\n          q)] (mod int q)\n\ngoal (1 subgoal):\n 1. \\<not> a' mod q < a mod q \\<Longrightarrow>\n    x1 =\n    (if a' mod q < a mod q\n     then nat ((int b' - int b) *\n               Number_Theory_Aux.inverse\n                (nat ((int a mod int q - int a' mod int q) mod int q)) q mod\n               int q)\n     else nat ((int b - int b') *\n               Number_Theory_Aux.inverse\n                (nat ((int a' mod int q - int a mod int q) mod int q)) q mod\n               int q))", "hence *: \"[int x1 * ((int a' mod q - int a mod q) mod q * inverse (nat ((int a' mod q - int a mod q) mod q)) q) \n              = (int b - int b') * inverse (nat ((int a' mod q - int a mod q) mod q)) q] (mod q)\""], ["proof (prove)\nusing this:\n  [(int b - int b') *\n   Number_Theory_Aux.inverse\n    (nat ((int a' mod int q - int a mod int q) mod int q))\n    q = int x1 *\n        ((int a' mod int q - int a mod int q) mod int q *\n         Number_Theory_Aux.inverse\n          (nat ((int a' mod int q - int a mod int q) mod int q))\n          q)] (mod int q)\n\ngoal (1 subgoal):\n 1. [int x1 *\n     ((int a' mod int q - int a mod int q) mod int q *\n      Number_Theory_Aux.inverse\n       (nat ((int a' mod int q - int a mod int q) mod int q))\n       q) = (int b - int b') *\n            Number_Theory_Aux.inverse\n             (nat ((int a' mod int q - int a mod int q) mod int q))\n             q] (mod int q)", "using cong_sym_eq"], ["proof (prove)\nusing this:\n  [(int b - int b') *\n   Number_Theory_Aux.inverse\n    (nat ((int a' mod int q - int a mod int q) mod int q))\n    q = int x1 *\n        ((int a' mod int q - int a mod int q) mod int q *\n         Number_Theory_Aux.inverse\n          (nat ((int a' mod int q - int a mod int q) mod int q))\n          q)] (mod int q)\n  [?b = ?c] (mod ?a) = [?c = ?b] (mod ?a)\n\ngoal (1 subgoal):\n 1. [int x1 *\n     ((int a' mod int q - int a mod int q) mod int q *\n      Number_Theory_Aux.inverse\n       (nat ((int a' mod int q - int a mod int q) mod int q))\n       q) = (int b - int b') *\n            Number_Theory_Aux.inverse\n             (nat ((int a' mod int q - int a mod int q) mod int q))\n             q] (mod int q)", "by auto"], ["proof (state)\nthis:\n  [int x1 *\n   ((int a' mod int q - int a mod int q) mod int q *\n    Number_Theory_Aux.inverse\n     (nat ((int a' mod int q - int a mod int q) mod int q))\n     q) = (int b - int b') *\n          Number_Theory_Aux.inverse\n           (nat ((int a' mod int q - int a mod int q) mod int q))\n           q] (mod int q)\n\ngoal (1 subgoal):\n 1. \\<not> a' mod q < a mod q \\<Longrightarrow>\n    x1 =\n    (if a' mod q < a mod q\n     then nat ((int b' - int b) *\n               Number_Theory_Aux.inverse\n                (nat ((int a mod int q - int a' mod int q) mod int q)) q mod\n               int q)\n     else nat ((int b - int b') *\n               Number_Theory_Aux.inverse\n                (nat ((int a' mod int q - int a mod int q) mod int q)) q mod\n               int q))", "hence \"[int x1 * 1 = (int b - int b') * inverse (nat ((int a' mod q - int a mod q) mod q)) q] (mod q)\""], ["proof (prove)\nusing this:\n  [int x1 *\n   ((int a' mod int q - int a mod int q) mod int q *\n    Number_Theory_Aux.inverse\n     (nat ((int a' mod int q - int a mod int q) mod int q))\n     q) = (int b - int b') *\n          Number_Theory_Aux.inverse\n           (nat ((int a' mod int q - int a mod int q) mod int q))\n           q] (mod int q)\n\ngoal (1 subgoal):\n 1. [int x1 *\n     1 = (int b - int b') *\n         Number_Theory_Aux.inverse\n          (nat ((int a' mod int q - int a mod int q) mod int q))\n          q] (mod int q)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. [int x1 *\n     ((int a' mod int q - int a mod int q) mod int q *\n      Number_Theory_Aux.inverse\n       (nat ((int a' mod int q - int a mod int q) mod int q))\n       q) = (int b - int b') *\n            Number_Theory_Aux.inverse\n             (nat ((int a' mod int q - int a mod int q) mod int q))\n             q] (mod int q) \\<Longrightarrow>\n    [int x1 *\n     1 = (int b - int b') *\n         Number_Theory_Aux.inverse\n          (nat ((int a' mod int q - int a mod int q) mod int q))\n          q] (mod int q)", "have \"[(int a' mod int q - int a mod int q) mod int q * Number_Theory_Aux.inverse (nat ((int a' mod int q - int a mod int q) mod int q)) q = 1] (mod int q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [(int a' mod int q - int a mod int q) mod int q *\n     Number_Theory_Aux.inverse\n      (nat ((int a' mod int q - int a mod int q) mod int q))\n      q = 1] (mod int q)", "by (metis (no_types) Euclidean_Division.pos_mod_sign inverse gcd int_nat_eq of_nat_0_less_iff q_gt_0)"], ["proof (state)\nthis:\n  [(int a' mod int q - int a mod int q) mod int q *\n   Number_Theory_Aux.inverse\n    (nat ((int a' mod int q - int a mod int q) mod int q))\n    q = 1] (mod int q)\n\ngoal (1 subgoal):\n 1. [int x1 *\n     ((int a' mod int q - int a mod int q) mod int q *\n      Number_Theory_Aux.inverse\n       (nat ((int a' mod int q - int a mod int q) mod int q))\n       q) = (int b - int b') *\n            Number_Theory_Aux.inverse\n             (nat ((int a' mod int q - int a mod int q) mod int q))\n             q] (mod int q) \\<Longrightarrow>\n    [int x1 *\n     1 = (int b - int b') *\n         Number_Theory_Aux.inverse\n          (nat ((int a' mod int q - int a mod int q) mod int q))\n          q] (mod int q)", "then"], ["proof (chain)\npicking this:\n  [(int a' mod int q - int a mod int q) mod int q *\n   Number_Theory_Aux.inverse\n    (nat ((int a' mod int q - int a mod int q) mod int q))\n    q = 1] (mod int q)", "show ?thesis"], ["proof (prove)\nusing this:\n  [(int a' mod int q - int a mod int q) mod int q *\n   Number_Theory_Aux.inverse\n    (nat ((int a' mod int q - int a mod int q) mod int q))\n    q = 1] (mod int q)\n\ngoal (1 subgoal):\n 1. [int x1 *\n     1 = (int b - int b') *\n         Number_Theory_Aux.inverse\n          (nat ((int a' mod int q - int a mod int q) mod int q))\n          q] (mod int q)", "by (meson * cong_scalar_left cong_sym_eq cong_trans)"], ["proof (state)\nthis:\n  [int x1 *\n   1 = (int b - int b') *\n       Number_Theory_Aux.inverse\n        (nat ((int a' mod int q - int a mod int q) mod int q))\n        q] (mod int q)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  [int x1 *\n   1 = (int b - int b') *\n       Number_Theory_Aux.inverse\n        (nat ((int a' mod int q - int a mod int q) mod int q))\n        q] (mod int q)\n\ngoal (1 subgoal):\n 1. \\<not> a' mod q < a mod q \\<Longrightarrow>\n    x1 =\n    (if a' mod q < a mod q\n     then nat ((int b' - int b) *\n               Number_Theory_Aux.inverse\n                (nat ((int a mod int q - int a' mod int q) mod int q)) q mod\n               int q)\n     else nat ((int b - int b') *\n               Number_Theory_Aux.inverse\n                (nat ((int a' mod int q - int a mod int q) mod int q)) q mod\n               int q))", "hence \"[int x1 = (int b - int b') * inverse (nat ((int a' mod q - int a mod q) mod q)) q] (mod q)\""], ["proof (prove)\nusing this:\n  [int x1 *\n   1 = (int b - int b') *\n       Number_Theory_Aux.inverse\n        (nat ((int a' mod int q - int a mod int q) mod int q))\n        q] (mod int q)\n\ngoal (1 subgoal):\n 1. [int x1 = (int b - int b') *\n              Number_Theory_Aux.inverse\n               (nat ((int a' mod int q - int a mod int q) mod int q))\n               q] (mod int q)", "by simp"], ["proof (state)\nthis:\n  [int x1 = (int b - int b') *\n            Number_Theory_Aux.inverse\n             (nat ((int a' mod int q - int a mod int q) mod int q))\n             q] (mod int q)\n\ngoal (1 subgoal):\n 1. \\<not> a' mod q < a mod q \\<Longrightarrow>\n    x1 =\n    (if a' mod q < a mod q\n     then nat ((int b' - int b) *\n               Number_Theory_Aux.inverse\n                (nat ((int a mod int q - int a' mod int q) mod int q)) q mod\n               int q)\n     else nat ((int b - int b') *\n               Number_Theory_Aux.inverse\n                (nat ((int a' mod int q - int a mod int q) mod int q)) q mod\n               int q))", "hence \"int x1 mod q = (int b - int b') * (inverse (nat ((int a' mod q - int a mod q) mod q)) q) mod q\""], ["proof (prove)\nusing this:\n  [int x1 = (int b - int b') *\n            Number_Theory_Aux.inverse\n             (nat ((int a' mod int q - int a mod int q) mod int q))\n             q] (mod int q)\n\ngoal (1 subgoal):\n 1. int x1 mod int q =\n    (int b - int b') *\n    Number_Theory_Aux.inverse\n     (nat ((int a' mod int q - int a mod int q) mod int q)) q mod\n    int q", "using cong_def"], ["proof (prove)\nusing this:\n  [int x1 = (int b - int b') *\n            Number_Theory_Aux.inverse\n             (nat ((int a' mod int q - int a mod int q) mod int q))\n             q] (mod int q)\n  [?b = ?c] (mod ?a) = (?b mod ?a = ?c mod ?a)\n\ngoal (1 subgoal):\n 1. int x1 mod int q =\n    (int b - int b') *\n    Number_Theory_Aux.inverse\n     (nat ((int a' mod int q - int a mod int q) mod int q)) q mod\n    int q", "by auto"], ["proof (state)\nthis:\n  int x1 mod int q =\n  (int b - int b') *\n  Number_Theory_Aux.inverse\n   (nat ((int a' mod int q - int a mod int q) mod int q)) q mod\n  int q\n\ngoal (1 subgoal):\n 1. \\<not> a' mod q < a mod q \\<Longrightarrow>\n    x1 =\n    (if a' mod q < a mod q\n     then nat ((int b' - int b) *\n               Number_Theory_Aux.inverse\n                (nat ((int a mod int q - int a' mod int q) mod int q)) q mod\n               int q)\n     else nat ((int b - int b') *\n               Number_Theory_Aux.inverse\n                (nat ((int a' mod int q - int a mod int q) mod int q)) q mod\n               int q))", "thus ?thesis"], ["proof (prove)\nusing this:\n  int x1 mod int q =\n  (int b - int b') *\n  Number_Theory_Aux.inverse\n   (nat ((int a' mod int q - int a mod int q) mod int q)) q mod\n  int q\n\ngoal (1 subgoal):\n 1. x1 =\n    (if a' mod q < a mod q\n     then nat ((int b' - int b) *\n               Number_Theory_Aux.inverse\n                (nat ((int a mod int q - int a' mod int q) mod int q)) q mod\n               int q)\n     else nat ((int b - int b') *\n               Number_Theory_Aux.inverse\n                (nat ((int a' mod int q - int a mod int q) mod int q)) q mod\n               int q))", "using x1 aa'"], ["proof (prove)\nusing this:\n  int x1 mod int q =\n  (int b - int b') *\n  Number_Theory_Aux.inverse\n   (nat ((int a' mod int q - int a mod int q) mod int q)) q mod\n  int q\n  x1 < q\n  a mod q < a' mod q\n\ngoal (1 subgoal):\n 1. x1 =\n    (if a' mod q < a mod q\n     then nat ((int b' - int b) *\n               Number_Theory_Aux.inverse\n                (nat ((int a mod int q - int a' mod int q) mod int q)) q mod\n               int q)\n     else nat ((int b - int b') *\n               Number_Theory_Aux.inverse\n                (nat ((int a' mod int q - int a mod int q) mod int q)) q mod\n               int q))", "by simp"], ["proof (state)\nthis:\n  x1 =\n  (if a' mod q < a mod q\n   then nat ((int b' - int b) *\n             Number_Theory_Aux.inverse\n              (nat ((int a mod int q - int a' mod int q) mod int q)) q mod\n             int q)\n   else nat ((int b - int b') *\n             Number_Theory_Aux.inverse\n              (nat ((int a' mod int q - int a mod int q) mod int q)) q mod\n             int q))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x1 =\n  (if a' mod q < a mod q\n   then nat ((int b' - int b) *\n             Number_Theory_Aux.inverse\n              (nat ((int a mod int q - int a' mod int q) mod int q)) q mod\n             int q)\n   else nat ((int b - int b') *\n             Number_Theory_Aux.inverse\n              (nat ((int a' mod int q - int a mod int q) mod int q)) q mod\n             int q))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma samp_uni_spmf_mod_q:\n  shows \"spmf (sample_uniform q) (x mod q) = 1/q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. spmf (sample_uniform q) (x mod q) = 1 / real q", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. spmf (sample_uniform q) (x mod q) = 1 / real q", "have \"indicator {..< q} (x mod q) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. indicator {..<q} (x mod q) = (1::'a)", "using q_gt_0"], ["proof (prove)\nusing this:\n  0 < q\n\ngoal (1 subgoal):\n 1. indicator {..<q} (x mod q) = (1::'a)", "by auto"], ["proof (state)\nthis:\n  indicator {..<q} (x mod q) = (1::?'a2)\n\ngoal (1 subgoal):\n 1. spmf (sample_uniform q) (x mod q) = 1 / real q", "moreover"], ["proof (state)\nthis:\n  indicator {..<q} (x mod q) = (1::?'a2)\n\ngoal (1 subgoal):\n 1. spmf (sample_uniform q) (x mod q) = 1 / real q", "have \"real (card {..< q}) = q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real (card {..<q}) = real q", "by simp"], ["proof (state)\nthis:\n  real (card {..<q}) = real q\n\ngoal (1 subgoal):\n 1. spmf (sample_uniform q) (x mod q) = 1 / real q", "ultimately"], ["proof (chain)\npicking this:\n  indicator {..<q} (x mod q) = (1::?'a2)\n  real (card {..<q}) = real q", "show ?thesis"], ["proof (prove)\nusing this:\n  indicator {..<q} (x mod q) = (1::?'a2)\n  real (card {..<q}) = real q\n\ngoal (1 subgoal):\n 1. spmf (sample_uniform q) (x mod q) = 1 / real q", "by(auto simp add: spmf_of_set sample_uniform_def)"], ["proof (state)\nthis:\n  spmf (sample_uniform q) (x mod q) = 1 / real q\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma spmf_samp_uni_eq_return_bool_mod:\n  shows \"spmf (do { \n          x1 \\<leftarrow> sample_uniform q;\n          return_spmf (int x1 = y mod q)}) True = 1/q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. spmf\n     (sample_uniform q \\<bind>\n      (\\<lambda>x1. return_spmf (int x1 = int (y mod q))))\n     True =\n    1 / real q", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. spmf\n     (sample_uniform q \\<bind>\n      (\\<lambda>x1. return_spmf (int x1 = int (y mod q))))\n     True =\n    1 / real q", "have \"spmf (do { \n          x1 \\<leftarrow> sample_uniform q;\n          return_spmf (x1 = y mod q)}) True = spmf (sample_uniform q \\<bind> (\\<lambda> x1. return_spmf x1)) (y mod q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. spmf\n     (sample_uniform q \\<bind> (\\<lambda>x1. return_spmf (x1 = y mod q)))\n     True =\n    spmf (sample_uniform q \\<bind> return_spmf) (y mod q)", "apply(simp only: spmf_bind)"], ["proof (prove)\ngoal (1 subgoal):\n 1. LINT x|measure_spmf (sample_uniform q).\n       spmf (return_spmf (x = y mod q)) True =\n    LINT x|measure_spmf (sample_uniform q). spmf (return_spmf x) (y mod q)", "apply(rule Bochner_Integration.integral_cong[OF refl])+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> space (measure_spmf (sample_uniform q)) \\<Longrightarrow>\n       spmf (return_spmf (x = y mod q)) True =\n       spmf (return_spmf x) (y mod q)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> space (measure_spmf (sample_uniform q)) \\<Longrightarrow>\n       spmf (return_spmf (x = y mod q)) True =\n       spmf (return_spmf x) (y mod q)", "fix x :: nat"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> space (measure_spmf (sample_uniform q)) \\<Longrightarrow>\n       spmf (return_spmf (x = y mod q)) True =\n       spmf (return_spmf x) (y mod q)", "have \"y mod q = x \\<longrightarrow> indicator {True} (x = (y mod q)) = (indicator {(y mod q)} x::real)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y mod q = x \\<longrightarrow>\n    indicat_real {True} (x = y mod q) = indicat_real {y mod q} x", "by simp"], ["proof (state)\nthis:\n  y mod q = x \\<longrightarrow>\n  indicat_real {True} (x = y mod q) = indicat_real {y mod q} x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> space (measure_spmf (sample_uniform q)) \\<Longrightarrow>\n       spmf (return_spmf (x = y mod q)) True =\n       spmf (return_spmf x) (y mod q)", "then"], ["proof (chain)\npicking this:\n  y mod q = x \\<longrightarrow>\n  indicat_real {True} (x = y mod q) = indicat_real {y mod q} x", "have \"indicator {True} (x = y mod q) = (indicator {y mod q} x::real)\""], ["proof (prove)\nusing this:\n  y mod q = x \\<longrightarrow>\n  indicat_real {True} (x = y mod q) = indicat_real {y mod q} x\n\ngoal (1 subgoal):\n 1. indicat_real {True} (x = y mod q) = indicat_real {y mod q} x", "by fastforce"], ["proof (state)\nthis:\n  indicat_real {True} (x = y mod q) = indicat_real {y mod q} x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> space (measure_spmf (sample_uniform q)) \\<Longrightarrow>\n       spmf (return_spmf (x = y mod q)) True =\n       spmf (return_spmf x) (y mod q)", "then"], ["proof (chain)\npicking this:\n  indicat_real {True} (x = y mod q) = indicat_real {y mod q} x", "show \"spmf (return_spmf (x = y mod q)) True = spmf (return_spmf x) (y mod q)\""], ["proof (prove)\nusing this:\n  indicat_real {True} (x = y mod q) = indicat_real {y mod q} x\n\ngoal (1 subgoal):\n 1. spmf (return_spmf (x = y mod q)) True = spmf (return_spmf x) (y mod q)", "by (metis pmf_return spmf_of_pmf_return_pmf spmf_spmf_of_pmf)"], ["proof (state)\nthis:\n  spmf (return_spmf (x = y mod q)) True = spmf (return_spmf x) (y mod q)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  spmf (sample_uniform q \\<bind> (\\<lambda>x1. return_spmf (x1 = y mod q)))\n   True =\n  spmf (sample_uniform q \\<bind> return_spmf) (y mod q)\n\ngoal (1 subgoal):\n 1. spmf\n     (sample_uniform q \\<bind>\n      (\\<lambda>x1. return_spmf (int x1 = int (y mod q))))\n     True =\n    1 / real q", "thus ?thesis"], ["proof (prove)\nusing this:\n  spmf (sample_uniform q \\<bind> (\\<lambda>x1. return_spmf (x1 = y mod q)))\n   True =\n  spmf (sample_uniform q \\<bind> return_spmf) (y mod q)\n\ngoal (1 subgoal):\n 1. spmf\n     (sample_uniform q \\<bind>\n      (\\<lambda>x1. return_spmf (int x1 = int (y mod q))))\n     True =\n    1 / real q", "using samp_uni_spmf_mod_q"], ["proof (prove)\nusing this:\n  spmf (sample_uniform q \\<bind> (\\<lambda>x1. return_spmf (x1 = y mod q)))\n   True =\n  spmf (sample_uniform q \\<bind> return_spmf) (y mod q)\n  spmf (sample_uniform q) (?x mod q) = 1 / real q\n\ngoal (1 subgoal):\n 1. spmf\n     (sample_uniform q \\<bind>\n      (\\<lambda>x1. return_spmf (int x1 = int (y mod q))))\n     True =\n    1 / real q", "by simp"], ["proof (state)\nthis:\n  spmf\n   (sample_uniform q \\<bind>\n    (\\<lambda>x1. return_spmf (int x1 = int (y mod q))))\n   True =\n  1 / real q\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bind_game_le_inv_q:\n  shows \"spmf (rivest_commit.bind_game \\<A>) True \\<le> 1 / q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. spmf (rivest_commit.bind_game \\<A>) True \\<le> 1 / real q", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. spmf (rivest_commit.bind_game \\<A>) True \\<le> 1 / real q", "let ?eq = \"\\<lambda>a a' b b'. (=)\n   (if (a mod q > a' mod q) then nat ((int b'- int b) * (inverse (nat ((int a mod q - int a' mod q) mod q)) q) mod q)\n    else nat ((int b - int b') * (inverse (nat ((int a' mod q - int a mod q) mod q)) q) mod q))\""], ["proof (state)\ngoal (1 subgoal):\n 1. spmf (rivest_commit.bind_game \\<A>) True \\<le> 1 / real q", "have \"spmf (rivest_commit.bind_game \\<A>) True = spmf (do {\n    (ck,(x1,y1)) \\<leftarrow> key_gen;\n    (c, m, (a,b), m', (a',b')) \\<leftarrow> \\<A> ck;\n    _ :: unit \\<leftarrow> assert_spmf(m \\<noteq> m' \\<and> valid_msg m \\<and> valid_msg m');  \n    let b = verify (x1,y1) m c (a,b);\n    let b' = verify (x1,y1) m' c (a',b');\n    _ :: unit \\<leftarrow> assert_spmf (b \\<and> b');\n    return_spmf True}) True\""], ["proof (prove)\ngoal (1 subgoal):\n 1. spmf (rivest_commit.bind_game \\<A>) True =\n    spmf\n     (key_gen \\<bind>\n      (\\<lambda>(ck, x1, y1).\n          \\<A> ck \\<bind>\n          (\\<lambda>(c, m, (a, b), m', a', b').\n              assert_spmf\n               (m \\<noteq> m' \\<and>\n                valid_msg m \\<and> valid_msg m') \\<bind>\n              (\\<lambda>_.\n                  let b = verify (x1, y1) m c (a, b);\n                      b' = verify (x1, y1) m' c (a', b')\n                  in assert_spmf (b \\<and> b') \\<bind>\n                     (\\<lambda>_. return_spmf True)))))\n     True", "by(simp add: abstract_commitment.bind_game_alt_def split_def spmf_try_spmf del: verify.simps)"], ["proof (state)\nthis:\n  spmf (rivest_commit.bind_game \\<A>) True =\n  spmf\n   (key_gen \\<bind>\n    (\\<lambda>(ck, x1, y1).\n        \\<A> ck \\<bind>\n        (\\<lambda>(c, m, (a, b), m', a', b').\n            assert_spmf\n             (m \\<noteq> m' \\<and> valid_msg m \\<and> valid_msg m') \\<bind>\n            (\\<lambda>_.\n                let b = verify (x1, y1) m c (a, b);\n                    b' = verify (x1, y1) m' c (a', b')\n                in assert_spmf (b \\<and> b') \\<bind>\n                   (\\<lambda>_. return_spmf True)))))\n   True\n\ngoal (1 subgoal):\n 1. spmf (rivest_commit.bind_game \\<A>) True \\<le> 1 / real q", "also"], ["proof (state)\nthis:\n  spmf (rivest_commit.bind_game \\<A>) True =\n  spmf\n   (key_gen \\<bind>\n    (\\<lambda>(ck, x1, y1).\n        \\<A> ck \\<bind>\n        (\\<lambda>(c, m, (a, b), m', a', b').\n            assert_spmf\n             (m \\<noteq> m' \\<and> valid_msg m \\<and> valid_msg m') \\<bind>\n            (\\<lambda>_.\n                let b = verify (x1, y1) m c (a, b);\n                    b' = verify (x1, y1) m' c (a', b')\n                in assert_spmf (b \\<and> b') \\<bind>\n                   (\\<lambda>_. return_spmf True)))))\n   True\n\ngoal (1 subgoal):\n 1. spmf (rivest_commit.bind_game \\<A>) True \\<le> 1 / real q", "have \"... = spmf (do {\n    a' :: nat \\<leftarrow> sample_uniform q;\n    b' :: nat \\<leftarrow> sample_uniform q;\n    x1 :: nat \\<leftarrow> sample_uniform q;\n    let y1 = (a' * x1 + b') mod q;\n    (c, m, (a,b), m', (a',b')) \\<leftarrow> \\<A> (a',b');\n    _ :: unit \\<leftarrow> assert_spmf (m \\<noteq> m' \\<and> valid_msg m \\<and> valid_msg m');  \n    _ :: unit \\<leftarrow> assert_spmf (c = (m + a) mod q \\<and> y1 = (a * x1 + b) mod q \\<and> c = (m' + a') mod q \\<and> y1 = (a' * x1 + b') mod q);\n    return_spmf True}) True\""], ["proof (prove)\ngoal (1 subgoal):\n 1. spmf\n     (key_gen \\<bind>\n      (\\<lambda>(ck, x1, y1).\n          \\<A> ck \\<bind>\n          (\\<lambda>(c, m, (a, b), m', a', b').\n              assert_spmf\n               (m \\<noteq> m' \\<and>\n                valid_msg m \\<and> valid_msg m') \\<bind>\n              (\\<lambda>_.\n                  let b = verify (x1, y1) m c (a, b);\n                      b' = verify (x1, y1) m' c (a', b')\n                  in assert_spmf (b \\<and> b') \\<bind>\n                     (\\<lambda>_. return_spmf True)))))\n     True =\n    spmf\n     (sample_uniform q \\<bind>\n      (\\<lambda>a'.\n          sample_uniform q \\<bind>\n          (\\<lambda>b'.\n              sample_uniform q \\<bind>\n              (\\<lambda>x1.\n                  let y1 = (a' * x1 + b') mod q\n                  in \\<A> (a', b') \\<bind>\n                     (\\<lambda>(c, m, (a, b), m', a', b').\n                         assert_spmf\n                          (m \\<noteq> m' \\<and>\n                           valid_msg m \\<and> valid_msg m') \\<bind>\n                         (\\<lambda>_.\n                             assert_spmf\n                              (c = (m + a) mod q \\<and>\n                               y1 = (a * x1 + b) mod q \\<and>\n                               c = (m' + a') mod q \\<and>\n                               y1 = (a' * x1 + b') mod q) \\<bind>\n                             (\\<lambda>_. return_spmf True)))))))\n     True", "by(simp add: key_gen_def Let_def)"], ["proof (state)\nthis:\n  spmf\n   (key_gen \\<bind>\n    (\\<lambda>(ck, x1, y1).\n        \\<A> ck \\<bind>\n        (\\<lambda>(c, m, (a, b), m', a', b').\n            assert_spmf\n             (m \\<noteq> m' \\<and> valid_msg m \\<and> valid_msg m') \\<bind>\n            (\\<lambda>_.\n                let b = verify (x1, y1) m c (a, b);\n                    b' = verify (x1, y1) m' c (a', b')\n                in assert_spmf (b \\<and> b') \\<bind>\n                   (\\<lambda>_. return_spmf True)))))\n   True =\n  spmf\n   (sample_uniform q \\<bind>\n    (\\<lambda>a'.\n        sample_uniform q \\<bind>\n        (\\<lambda>b'.\n            sample_uniform q \\<bind>\n            (\\<lambda>x1.\n                let y1 = (a' * x1 + b') mod q\n                in \\<A> (a', b') \\<bind>\n                   (\\<lambda>(c, m, (a, b), m', a', b').\n                       assert_spmf\n                        (m \\<noteq> m' \\<and>\n                         valid_msg m \\<and> valid_msg m') \\<bind>\n                       (\\<lambda>_.\n                           assert_spmf\n                            (c = (m + a) mod q \\<and>\n                             y1 = (a * x1 + b) mod q \\<and>\n                             c = (m' + a') mod q \\<and>\n                             y1 = (a' * x1 + b') mod q) \\<bind>\n                           (\\<lambda>_. return_spmf True)))))))\n   True\n\ngoal (1 subgoal):\n 1. spmf (rivest_commit.bind_game \\<A>) True \\<le> 1 / real q", "also"], ["proof (state)\nthis:\n  spmf\n   (key_gen \\<bind>\n    (\\<lambda>(ck, x1, y1).\n        \\<A> ck \\<bind>\n        (\\<lambda>(c, m, (a, b), m', a', b').\n            assert_spmf\n             (m \\<noteq> m' \\<and> valid_msg m \\<and> valid_msg m') \\<bind>\n            (\\<lambda>_.\n                let b = verify (x1, y1) m c (a, b);\n                    b' = verify (x1, y1) m' c (a', b')\n                in assert_spmf (b \\<and> b') \\<bind>\n                   (\\<lambda>_. return_spmf True)))))\n   True =\n  spmf\n   (sample_uniform q \\<bind>\n    (\\<lambda>a'.\n        sample_uniform q \\<bind>\n        (\\<lambda>b'.\n            sample_uniform q \\<bind>\n            (\\<lambda>x1.\n                let y1 = (a' * x1 + b') mod q\n                in \\<A> (a', b') \\<bind>\n                   (\\<lambda>(c, m, (a, b), m', a', b').\n                       assert_spmf\n                        (m \\<noteq> m' \\<and>\n                         valid_msg m \\<and> valid_msg m') \\<bind>\n                       (\\<lambda>_.\n                           assert_spmf\n                            (c = (m + a) mod q \\<and>\n                             y1 = (a * x1 + b) mod q \\<and>\n                             c = (m' + a') mod q \\<and>\n                             y1 = (a' * x1 + b') mod q) \\<bind>\n                           (\\<lambda>_. return_spmf True)))))))\n   True\n\ngoal (1 subgoal):\n 1. spmf (rivest_commit.bind_game \\<A>) True \\<le> 1 / real q", "have \"... = spmf (do {\n    a'' :: nat \\<leftarrow> sample_uniform q;\n    b'' :: nat \\<leftarrow> sample_uniform q;\n    x1 :: nat \\<leftarrow> sample_uniform q;\n    let y1 = (a'' * x1 + b'') mod q;\n    (c, m, (a,b), m', (a',b')) \\<leftarrow> \\<A> (a'',b'');\n    _ :: unit \\<leftarrow> assert_spmf (m \\<noteq> m' \\<and> valid_msg m \\<and> valid_msg m');  \n    _ :: unit \\<leftarrow> assert_spmf (c = (m + a) mod q \\<and> y1 = (a * x1 + b) mod q \\<and> c = (m' + a') mod q \\<and> y1 = (a' * x1 + b') mod q);\n    return_spmf (?eq a a' b b' x1)}) True\""], ["proof (prove)\ngoal (1 subgoal):\n 1. spmf\n     (sample_uniform q \\<bind>\n      (\\<lambda>a'.\n          sample_uniform q \\<bind>\n          (\\<lambda>b'.\n              sample_uniform q \\<bind>\n              (\\<lambda>x1.\n                  let y1 = (a' * x1 + b') mod q\n                  in \\<A> (a', b') \\<bind>\n                     (\\<lambda>(c, m, (a, b), m', a', b').\n                         assert_spmf\n                          (m \\<noteq> m' \\<and>\n                           valid_msg m \\<and> valid_msg m') \\<bind>\n                         (\\<lambda>_.\n                             assert_spmf\n                              (c = (m + a) mod q \\<and>\n                               y1 = (a * x1 + b) mod q \\<and>\n                               c = (m' + a') mod q \\<and>\n                               y1 = (a' * x1 + b') mod q) \\<bind>\n                             (\\<lambda>_. return_spmf True)))))))\n     True =\n    spmf\n     (sample_uniform q \\<bind>\n      (\\<lambda>a''.\n          sample_uniform q \\<bind>\n          (\\<lambda>b''.\n              sample_uniform q \\<bind>\n              (\\<lambda>x1.\n                  let y1 = (a'' * x1 + b'') mod q\n                  in \\<A> (a'', b'') \\<bind>\n                     (\\<lambda>(c, m, (a, b), m', a', b').\n                         assert_spmf\n                          (m \\<noteq> m' \\<and>\n                           valid_msg m \\<and> valid_msg m') \\<bind>\n                         (\\<lambda>_.\n                             assert_spmf\n                              (c = (m + a) mod q \\<and>\n                               y1 = (a * x1 + b) mod q \\<and>\n                               c = (m' + a') mod q \\<and>\n                               y1 = (a' * x1 + b') mod q) \\<bind>\n                             (\\<lambda>_.\n                                 return_spmf\n                                  ((if a' mod q < a mod q\n                                    then nat\n    ((int b' - int b) *\n     Number_Theory_Aux.inverse\n      (nat ((int a mod int q - int a' mod int q) mod int q)) q mod\n     int q)\n                                    else nat\n    ((int b - int b') *\n     Number_Theory_Aux.inverse\n      (nat ((int a' mod int q - int a mod int q) mod int q)) q mod\n     int q)) =\n                                   x1))))))))\n     True", "unfolding split_def Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. spmf\n     (sample_uniform q \\<bind>\n      (\\<lambda>a'.\n          sample_uniform q \\<bind>\n          (\\<lambda>b'.\n              sample_uniform q \\<bind>\n              (\\<lambda>x1.\n                  \\<A> (a', b') \\<bind>\n                  (\\<lambda>p.\n                      assert_spmf\n                       (fst (snd p) \\<noteq> fst (snd (snd (snd p))) \\<and>\n                        valid_msg (fst (snd p)) \\<and>\n                        valid_msg (fst (snd (snd (snd p))))) \\<bind>\n                      (\\<lambda>_.\n                          assert_spmf\n                           (fst p =\n                            (fst (snd p) + fst (fst (snd (snd p)))) mod\n                            q \\<and>\n                            (a' * x1 + b') mod q =\n                            (fst (fst (snd (snd p))) * x1 +\n                             snd (fst (snd (snd p)))) mod\n                            q \\<and>\n                            fst p =\n                            (fst (snd (snd (snd p))) +\n                             fst (snd (snd (snd (snd p))))) mod\n                            q \\<and>\n                            (a' * x1 + b') mod q =\n                            (fst (snd (snd (snd (snd p)))) * x1 +\n                             snd (snd (snd (snd (snd p))))) mod\n                            q) \\<bind>\n                          (\\<lambda>_. return_spmf True)))))))\n     True =\n    spmf\n     (sample_uniform q \\<bind>\n      (\\<lambda>a''.\n          sample_uniform q \\<bind>\n          (\\<lambda>b''.\n              sample_uniform q \\<bind>\n              (\\<lambda>x1.\n                  \\<A> (a'', b'') \\<bind>\n                  (\\<lambda>p.\n                      assert_spmf\n                       (fst (snd p) \\<noteq> fst (snd (snd (snd p))) \\<and>\n                        valid_msg (fst (snd p)) \\<and>\n                        valid_msg (fst (snd (snd (snd p))))) \\<bind>\n                      (\\<lambda>_.\n                          assert_spmf\n                           (fst p =\n                            (fst (snd p) + fst (fst (snd (snd p)))) mod\n                            q \\<and>\n                            (a'' * x1 + b'') mod q =\n                            (fst (fst (snd (snd p))) * x1 +\n                             snd (fst (snd (snd p)))) mod\n                            q \\<and>\n                            fst p =\n                            (fst (snd (snd (snd p))) +\n                             fst (snd (snd (snd (snd p))))) mod\n                            q \\<and>\n                            (a'' * x1 + b'') mod q =\n                            (fst (snd (snd (snd (snd p)))) * x1 +\n                             snd (snd (snd (snd (snd p))))) mod\n                            q) \\<bind>\n                          (\\<lambda>_.\n                              return_spmf\n                               ((if fst (snd (snd (snd (snd p)))) mod q\n                                    < fst (fst (snd (snd p))) mod q\n                                 then nat\n ((int (snd (snd (snd (snd (snd p))))) - int (snd (fst (snd (snd p))))) *\n  Number_Theory_Aux.inverse\n   (nat ((int (fst (fst (snd (snd p)))) mod int q -\n          int (fst (snd (snd (snd (snd p))))) mod int q) mod\n         int q))\n   q mod\n  int q)\n                                 else nat\n ((int (snd (fst (snd (snd p)))) - int (snd (snd (snd (snd (snd p)))))) *\n  Number_Theory_Aux.inverse\n   (nat ((int (fst (snd (snd (snd (snd p))))) mod int q -\n          int (fst (fst (snd (snd p)))) mod int q) mod\n         int q))\n   q mod\n  int q)) =\n                                x1))))))))\n     True", "by(rule arg_cong2[where f=spmf, OF _ refl] bind_spmf_cong[OF refl])+\n      (auto simp add: eq_commute samp_uni_break' Let_def split_def valid_msg_def cong: bind_spmf_cong_simp)"], ["proof (state)\nthis:\n  spmf\n   (sample_uniform q \\<bind>\n    (\\<lambda>a'.\n        sample_uniform q \\<bind>\n        (\\<lambda>b'.\n            sample_uniform q \\<bind>\n            (\\<lambda>x1.\n                let y1 = (a' * x1 + b') mod q\n                in \\<A> (a', b') \\<bind>\n                   (\\<lambda>(c, m, (a, b), m', a', b').\n                       assert_spmf\n                        (m \\<noteq> m' \\<and>\n                         valid_msg m \\<and> valid_msg m') \\<bind>\n                       (\\<lambda>_.\n                           assert_spmf\n                            (c = (m + a) mod q \\<and>\n                             y1 = (a * x1 + b) mod q \\<and>\n                             c = (m' + a') mod q \\<and>\n                             y1 = (a' * x1 + b') mod q) \\<bind>\n                           (\\<lambda>_. return_spmf True)))))))\n   True =\n  spmf\n   (sample_uniform q \\<bind>\n    (\\<lambda>a''.\n        sample_uniform q \\<bind>\n        (\\<lambda>b''.\n            sample_uniform q \\<bind>\n            (\\<lambda>x1.\n                let y1 = (a'' * x1 + b'') mod q\n                in \\<A> (a'', b'') \\<bind>\n                   (\\<lambda>(c, m, (a, b), m', a', b').\n                       assert_spmf\n                        (m \\<noteq> m' \\<and>\n                         valid_msg m \\<and> valid_msg m') \\<bind>\n                       (\\<lambda>_.\n                           assert_spmf\n                            (c = (m + a) mod q \\<and>\n                             y1 = (a * x1 + b) mod q \\<and>\n                             c = (m' + a') mod q \\<and>\n                             y1 = (a' * x1 + b') mod q) \\<bind>\n                           (\\<lambda>_.\n                               return_spmf\n                                ((if a' mod q < a mod q\n                                  then nat\n  ((int b' - int b) *\n   Number_Theory_Aux.inverse\n    (nat ((int a mod int q - int a' mod int q) mod int q)) q mod\n   int q)\n                                  else nat\n  ((int b - int b') *\n   Number_Theory_Aux.inverse\n    (nat ((int a' mod int q - int a mod int q) mod int q)) q mod\n   int q)) =\n                                 x1))))))))\n   True\n\ngoal (1 subgoal):\n 1. spmf (rivest_commit.bind_game \\<A>) True \\<le> 1 / real q", "also"], ["proof (state)\nthis:\n  spmf\n   (sample_uniform q \\<bind>\n    (\\<lambda>a'.\n        sample_uniform q \\<bind>\n        (\\<lambda>b'.\n            sample_uniform q \\<bind>\n            (\\<lambda>x1.\n                let y1 = (a' * x1 + b') mod q\n                in \\<A> (a', b') \\<bind>\n                   (\\<lambda>(c, m, (a, b), m', a', b').\n                       assert_spmf\n                        (m \\<noteq> m' \\<and>\n                         valid_msg m \\<and> valid_msg m') \\<bind>\n                       (\\<lambda>_.\n                           assert_spmf\n                            (c = (m + a) mod q \\<and>\n                             y1 = (a * x1 + b) mod q \\<and>\n                             c = (m' + a') mod q \\<and>\n                             y1 = (a' * x1 + b') mod q) \\<bind>\n                           (\\<lambda>_. return_spmf True)))))))\n   True =\n  spmf\n   (sample_uniform q \\<bind>\n    (\\<lambda>a''.\n        sample_uniform q \\<bind>\n        (\\<lambda>b''.\n            sample_uniform q \\<bind>\n            (\\<lambda>x1.\n                let y1 = (a'' * x1 + b'') mod q\n                in \\<A> (a'', b'') \\<bind>\n                   (\\<lambda>(c, m, (a, b), m', a', b').\n                       assert_spmf\n                        (m \\<noteq> m' \\<and>\n                         valid_msg m \\<and> valid_msg m') \\<bind>\n                       (\\<lambda>_.\n                           assert_spmf\n                            (c = (m + a) mod q \\<and>\n                             y1 = (a * x1 + b) mod q \\<and>\n                             c = (m' + a') mod q \\<and>\n                             y1 = (a' * x1 + b') mod q) \\<bind>\n                           (\\<lambda>_.\n                               return_spmf\n                                ((if a' mod q < a mod q\n                                  then nat\n  ((int b' - int b) *\n   Number_Theory_Aux.inverse\n    (nat ((int a mod int q - int a' mod int q) mod int q)) q mod\n   int q)\n                                  else nat\n  ((int b - int b') *\n   Number_Theory_Aux.inverse\n    (nat ((int a' mod int q - int a mod int q) mod int q)) q mod\n   int q)) =\n                                 x1))))))))\n   True\n\ngoal (1 subgoal):\n 1. spmf (rivest_commit.bind_game \\<A>) True \\<le> 1 / real q", "have \"... \\<le> spmf (do {\n    a'' :: nat \\<leftarrow> sample_uniform q;\n    b'' :: nat \\<leftarrow> sample_uniform q;\n    (c, m, (a,(b::nat)), m', (a',b')) \\<leftarrow> \\<A> (a'',b'');\n    map_spmf (?eq a a' b b') (sample_uniform q)}) True\""], ["proof (prove)\ngoal (1 subgoal):\n 1. spmf\n     (sample_uniform q \\<bind>\n      (\\<lambda>a''.\n          sample_uniform q \\<bind>\n          (\\<lambda>b''.\n              sample_uniform q \\<bind>\n              (\\<lambda>x1.\n                  let y1 = (a'' * x1 + b'') mod q\n                  in \\<A> (a'', b'') \\<bind>\n                     (\\<lambda>(c, m, (a, b), m', a', b').\n                         assert_spmf\n                          (m \\<noteq> m' \\<and>\n                           valid_msg m \\<and> valid_msg m') \\<bind>\n                         (\\<lambda>_.\n                             assert_spmf\n                              (c = (m + a) mod q \\<and>\n                               y1 = (a * x1 + b) mod q \\<and>\n                               c = (m' + a') mod q \\<and>\n                               y1 = (a' * x1 + b') mod q) \\<bind>\n                             (\\<lambda>_.\n                                 return_spmf\n                                  ((if a' mod q < a mod q\n                                    then nat\n    ((int b' - int b) *\n     Number_Theory_Aux.inverse\n      (nat ((int a mod int q - int a' mod int q) mod int q)) q mod\n     int q)\n                                    else nat\n    ((int b - int b') *\n     Number_Theory_Aux.inverse\n      (nat ((int a' mod int q - int a mod int q) mod int q)) q mod\n     int q)) =\n                                   x1))))))))\n     True\n    \\<le> spmf\n           (sample_uniform q \\<bind>\n            (\\<lambda>a''.\n                sample_uniform q \\<bind>\n                (\\<lambda>b''.\n                    \\<A> (a'', b'') \\<bind>\n                    (\\<lambda>(c, m, (a, b), m', a', b').\n                        map_spmf\n                         ((=) (if a' mod q < a mod q\n                               then nat ((int b' - int b) *\n   Number_Theory_Aux.inverse\n    (nat ((int a mod int q - int a' mod int q) mod int q)) q mod\n   int q)\n                               else nat ((int b - int b') *\n   Number_Theory_Aux.inverse\n    (nat ((int a' mod int q - int a mod int q) mod int q)) q mod\n   int q)))\n                         (sample_uniform q)))))\n           True", "including monad_normalisation"], ["proof (prove)\ngoal (1 subgoal):\n 1. spmf\n     (sample_uniform q \\<bind>\n      (\\<lambda>a''.\n          sample_uniform q \\<bind>\n          (\\<lambda>b''.\n              sample_uniform q \\<bind>\n              (\\<lambda>x1.\n                  let y1 = (a'' * x1 + b'') mod q\n                  in \\<A> (a'', b'') \\<bind>\n                     (\\<lambda>(c, m, (a, b), m', a', b').\n                         assert_spmf\n                          (m \\<noteq> m' \\<and>\n                           valid_msg m \\<and> valid_msg m') \\<bind>\n                         (\\<lambda>_.\n                             assert_spmf\n                              (c = (m + a) mod q \\<and>\n                               y1 = (a * x1 + b) mod q \\<and>\n                               c = (m' + a') mod q \\<and>\n                               y1 = (a' * x1 + b') mod q) \\<bind>\n                             (\\<lambda>_.\n                                 return_spmf\n                                  ((if a' mod q < a mod q\n                                    then nat\n    ((int b' - int b) *\n     Number_Theory_Aux.inverse\n      (nat ((int a mod int q - int a' mod int q) mod int q)) q mod\n     int q)\n                                    else nat\n    ((int b - int b') *\n     Number_Theory_Aux.inverse\n      (nat ((int a' mod int q - int a mod int q) mod int q)) q mod\n     int q)) =\n                                   x1))))))))\n     True\n    \\<le> spmf\n           (sample_uniform q \\<bind>\n            (\\<lambda>a''.\n                sample_uniform q \\<bind>\n                (\\<lambda>b''.\n                    \\<A> (a'', b'') \\<bind>\n                    (\\<lambda>(c, m, (a, b), m', a', b').\n                        map_spmf\n                         ((=) (if a' mod q < a mod q\n                               then nat ((int b' - int b) *\n   Number_Theory_Aux.inverse\n    (nat ((int a mod int q - int a' mod int q) mod int q)) q mod\n   int q)\n                               else nat ((int b - int b') *\n   Number_Theory_Aux.inverse\n    (nat ((int a' mod int q - int a mod int q) mod int q)) q mod\n   int q)))\n                         (sample_uniform q)))))\n           True", "unfolding split_def Let_def assert_spmf_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. spmf\n     (sample_uniform q \\<bind>\n      (\\<lambda>a''.\n          sample_uniform q \\<bind>\n          (\\<lambda>b''.\n              sample_uniform q \\<bind>\n              (\\<lambda>x1.\n                  \\<A> (a'', b'') \\<bind>\n                  (\\<lambda>p.\n                      (if fst (snd p) \\<noteq>\n                          fst (snd (snd (snd p))) \\<and>\n                          valid_msg (fst (snd p)) \\<and>\n                          valid_msg (fst (snd (snd (snd p))))\n                       then return_spmf () else return_pmf None) \\<bind>\n                      (\\<lambda>_.\n                          (if fst p =\n                              (fst (snd p) + fst (fst (snd (snd p)))) mod\n                              q \\<and>\n                              (a'' * x1 + b'') mod q =\n                              (fst (fst (snd (snd p))) * x1 +\n                               snd (fst (snd (snd p)))) mod\n                              q \\<and>\n                              fst p =\n                              (fst (snd (snd (snd p))) +\n                               fst (snd (snd (snd (snd p))))) mod\n                              q \\<and>\n                              (a'' * x1 + b'') mod q =\n                              (fst (snd (snd (snd (snd p)))) * x1 +\n                               snd (snd (snd (snd (snd p))))) mod\n                              q\n                           then return_spmf () else return_pmf None) \\<bind>\n                          (\\<lambda>_.\n                              return_spmf\n                               ((if fst (snd (snd (snd (snd p)))) mod q\n                                    < fst (fst (snd (snd p))) mod q\n                                 then nat\n ((int (snd (snd (snd (snd (snd p))))) - int (snd (fst (snd (snd p))))) *\n  Number_Theory_Aux.inverse\n   (nat ((int (fst (fst (snd (snd p)))) mod int q -\n          int (fst (snd (snd (snd (snd p))))) mod int q) mod\n         int q))\n   q mod\n  int q)\n                                 else nat\n ((int (snd (fst (snd (snd p)))) - int (snd (snd (snd (snd (snd p)))))) *\n  Number_Theory_Aux.inverse\n   (nat ((int (fst (snd (snd (snd (snd p))))) mod int q -\n          int (fst (fst (snd (snd p)))) mod int q) mod\n         int q))\n   q mod\n  int q)) =\n                                x1))))))))\n     True\n    \\<le> spmf\n           (sample_uniform q \\<bind>\n            (\\<lambda>a''.\n                sample_uniform q \\<bind>\n                (\\<lambda>b''.\n                    \\<A> (a'', b'') \\<bind>\n                    (\\<lambda>p.\n                        map_spmf\n                         ((=) (if fst (snd (snd (snd (snd p)))) mod q\n                                  < fst (fst (snd (snd p))) mod q\n                               then nat ((int\n     (snd (snd (snd (snd (snd p))))) -\n    int (snd (fst (snd (snd p))))) *\n   Number_Theory_Aux.inverse\n    (nat ((int (fst (fst (snd (snd p)))) mod int q -\n           int (fst (snd (snd (snd (snd p))))) mod int q) mod\n          int q))\n    q mod\n   int q)\n                               else nat ((int (snd (fst (snd (snd p)))) -\n    int (snd (snd (snd (snd (snd p)))))) *\n   Number_Theory_Aux.inverse\n    (nat ((int (fst (snd (snd (snd (snd p))))) mod int q -\n           int (fst (fst (snd (snd p)))) mod int q) mod\n          int q))\n    q mod\n   int q)))\n                         (sample_uniform q)))))\n           True", "apply(simp add: map_spmf_conv_bind_spmf)"], ["proof (prove)\ngoal (1 subgoal):\n 1. spmf\n     (sample_uniform q \\<bind>\n      (\\<lambda>a''.\n          sample_uniform q \\<bind>\n          (\\<lambda>b''.\n              sample_uniform q \\<bind>\n              (\\<lambda>x1.\n                  \\<A> (a'', b'') \\<bind>\n                  (\\<lambda>p.\n                      (if fst (snd p) \\<noteq>\n                          fst (snd (snd (snd p))) \\<and>\n                          valid_msg (fst (snd p)) \\<and>\n                          valid_msg (fst (snd (snd (snd p))))\n                       then return_spmf () else return_pmf None) \\<bind>\n                      (\\<lambda>_.\n                          (if fst p =\n                              (fst (snd p) + fst (fst (snd (snd p)))) mod\n                              q \\<and>\n                              (a'' * x1 + b'') mod q =\n                              (fst (fst (snd (snd p))) * x1 +\n                               snd (fst (snd (snd p)))) mod\n                              q \\<and>\n                              fst p =\n                              (fst (snd (snd (snd p))) +\n                               fst (snd (snd (snd (snd p))))) mod\n                              q \\<and>\n                              (a'' * x1 + b'') mod q =\n                              (fst (snd (snd (snd (snd p)))) * x1 +\n                               snd (snd (snd (snd (snd p))))) mod\n                              q\n                           then return_spmf () else return_pmf None) \\<bind>\n                          (\\<lambda>_.\n                              return_spmf\n                               ((if fst (snd (snd (snd (snd p)))) mod q\n                                    < fst (fst (snd (snd p))) mod q\n                                 then nat\n ((int (snd (snd (snd (snd (snd p))))) - int (snd (fst (snd (snd p))))) *\n  Number_Theory_Aux.inverse\n   (nat ((int (fst (fst (snd (snd p)))) mod int q -\n          int (fst (snd (snd (snd (snd p))))) mod int q) mod\n         int q))\n   q mod\n  int q)\n                                 else nat\n ((int (snd (fst (snd (snd p)))) - int (snd (snd (snd (snd (snd p)))))) *\n  Number_Theory_Aux.inverse\n   (nat ((int (fst (snd (snd (snd (snd p))))) mod int q -\n          int (fst (fst (snd (snd p)))) mod int q) mod\n         int q))\n   q mod\n  int q)) =\n                                x1))))))))\n     True\n    \\<le> spmf\n           (sample_uniform q \\<bind>\n            (\\<lambda>a''.\n                sample_uniform q \\<bind>\n                (\\<lambda>b''.\n                    sample_uniform q \\<bind>\n                    (\\<lambda>x.\n                        \\<A> (a'', b'') \\<bind>\n                        (\\<lambda>p.\n                            return_spmf\n                             ((if fst (snd (snd (snd (snd p)))) mod q\n                                  < fst (fst (snd (snd p))) mod q\n                               then nat ((int\n     (snd (snd (snd (snd (snd p))))) -\n    int (snd (fst (snd (snd p))))) *\n   Number_Theory_Aux.inverse\n    (nat ((int (fst (fst (snd (snd p)))) mod int q -\n           int (fst (snd (snd (snd (snd p))))) mod int q) mod\n          int q))\n    q mod\n   int q)\n                               else nat ((int (snd (fst (snd (snd p)))) -\n    int (snd (snd (snd (snd (snd p)))))) *\n   Number_Theory_Aux.inverse\n    (nat ((int (fst (snd (snd (snd (snd p))))) mod int q -\n           int (fst (fst (snd (snd p)))) mod int q) mod\n          int q))\n    q mod\n   int q)) =\n                              x))))))\n           True", "apply(rule ord_spmf_eq_leD ord_spmf_bind_reflI)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa xb xc.\n       \\<lbrakk>x \\<in> set_spmf (sample_uniform q);\n        xa \\<in> set_spmf (sample_uniform q);\n        xb \\<in> set_spmf (sample_uniform q);\n        xc \\<in> set_spmf (\\<A> (x, xa))\\<rbrakk>\n       \\<Longrightarrow> ord_spmf (=)\n                          ((if fst (snd xc) \\<noteq>\n                               fst (snd (snd (snd xc))) \\<and>\n                               valid_msg (fst (snd xc)) \\<and>\n                               valid_msg (fst (snd (snd (snd xc))))\n                            then return_spmf ()\n                            else return_pmf None) \\<bind>\n                           (\\<lambda>_.\n                               (if fst xc =\n                                   (fst (snd xc) +\n                                    fst (fst (snd (snd xc)))) mod\n                                   q \\<and>\n                                   (x * xb + xa) mod q =\n                                   (fst (fst (snd (snd xc))) * xb +\n                                    snd (fst (snd (snd xc)))) mod\n                                   q \\<and>\n                                   fst xc =\n                                   (fst (snd (snd (snd xc))) +\n                                    fst (snd (snd (snd (snd xc))))) mod\n                                   q \\<and>\n                                   (x * xb + xa) mod q =\n                                   (fst (snd (snd (snd (snd xc)))) * xb +\n                                    snd (snd (snd (snd (snd xc))))) mod\n                                   q\n                                then return_spmf ()\n                                else return_pmf None) \\<bind>\n                               (\\<lambda>_.\n                                   return_spmf\n                                    ((if fst (snd (snd (snd (snd xc)))) mod\n   q\n   < fst (fst (snd (snd xc))) mod q\nthen nat ((int (snd (snd (snd (snd (snd xc))))) -\n           int (snd (fst (snd (snd xc))))) *\n          Number_Theory_Aux.inverse\n           (nat ((int (fst (fst (snd (snd xc)))) mod int q -\n                  int (fst (snd (snd (snd (snd xc))))) mod int q) mod\n                 int q))\n           q mod\n          int q)\nelse nat ((int (snd (fst (snd (snd xc)))) -\n           int (snd (snd (snd (snd (snd xc)))))) *\n          Number_Theory_Aux.inverse\n           (nat ((int (fst (snd (snd (snd (snd xc))))) mod int q -\n                  int (fst (fst (snd (snd xc)))) mod int q) mod\n                 int q))\n           q mod\n          int q)) =\n                                     xb))))\n                          (return_spmf\n                            ((if fst (snd (snd (snd (snd xc)))) mod q\n                                 < fst (fst (snd (snd xc))) mod q\n                              then nat ((int\n    (snd (snd (snd (snd (snd xc))))) -\n   int (snd (fst (snd (snd xc))))) *\n  Number_Theory_Aux.inverse\n   (nat ((int (fst (fst (snd (snd xc)))) mod int q -\n          int (fst (snd (snd (snd (snd xc))))) mod int q) mod\n         int q))\n   q mod\n  int q)\n                              else nat ((int (snd (fst (snd (snd xc)))) -\n   int (snd (snd (snd (snd (snd xc)))))) *\n  Number_Theory_Aux.inverse\n   (nat ((int (fst (snd (snd (snd (snd xc))))) mod int q -\n          int (fst (fst (snd (snd xc)))) mod int q) mod\n         int q))\n   q mod\n  int q)) =\n                             xb))", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  spmf\n   (sample_uniform q \\<bind>\n    (\\<lambda>a''.\n        sample_uniform q \\<bind>\n        (\\<lambda>b''.\n            sample_uniform q \\<bind>\n            (\\<lambda>x1.\n                let y1 = (a'' * x1 + b'') mod q\n                in \\<A> (a'', b'') \\<bind>\n                   (\\<lambda>(c, m, (a, b), m', a', b').\n                       assert_spmf\n                        (m \\<noteq> m' \\<and>\n                         valid_msg m \\<and> valid_msg m') \\<bind>\n                       (\\<lambda>_.\n                           assert_spmf\n                            (c = (m + a) mod q \\<and>\n                             y1 = (a * x1 + b) mod q \\<and>\n                             c = (m' + a') mod q \\<and>\n                             y1 = (a' * x1 + b') mod q) \\<bind>\n                           (\\<lambda>_.\n                               return_spmf\n                                ((if a' mod q < a mod q\n                                  then nat\n  ((int b' - int b) *\n   Number_Theory_Aux.inverse\n    (nat ((int a mod int q - int a' mod int q) mod int q)) q mod\n   int q)\n                                  else nat\n  ((int b - int b') *\n   Number_Theory_Aux.inverse\n    (nat ((int a' mod int q - int a mod int q) mod int q)) q mod\n   int q)) =\n                                 x1))))))))\n   True\n  \\<le> spmf\n         (sample_uniform q \\<bind>\n          (\\<lambda>a''.\n              sample_uniform q \\<bind>\n              (\\<lambda>b''.\n                  \\<A> (a'', b'') \\<bind>\n                  (\\<lambda>(c, m, (a, b), m', a', b').\n                      map_spmf\n                       ((=) (if a' mod q < a mod q\n                             then nat ((int b' - int b) *\n Number_Theory_Aux.inverse\n  (nat ((int a mod int q - int a' mod int q) mod int q)) q mod\n int q)\n                             else nat ((int b - int b') *\n Number_Theory_Aux.inverse\n  (nat ((int a' mod int q - int a mod int q) mod int q)) q mod\n int q)))\n                       (sample_uniform q)))))\n         True\n\ngoal (1 subgoal):\n 1. spmf (rivest_commit.bind_game \\<A>) True \\<le> 1 / real q", "also"], ["proof (state)\nthis:\n  spmf\n   (sample_uniform q \\<bind>\n    (\\<lambda>a''.\n        sample_uniform q \\<bind>\n        (\\<lambda>b''.\n            sample_uniform q \\<bind>\n            (\\<lambda>x1.\n                let y1 = (a'' * x1 + b'') mod q\n                in \\<A> (a'', b'') \\<bind>\n                   (\\<lambda>(c, m, (a, b), m', a', b').\n                       assert_spmf\n                        (m \\<noteq> m' \\<and>\n                         valid_msg m \\<and> valid_msg m') \\<bind>\n                       (\\<lambda>_.\n                           assert_spmf\n                            (c = (m + a) mod q \\<and>\n                             y1 = (a * x1 + b) mod q \\<and>\n                             c = (m' + a') mod q \\<and>\n                             y1 = (a' * x1 + b') mod q) \\<bind>\n                           (\\<lambda>_.\n                               return_spmf\n                                ((if a' mod q < a mod q\n                                  then nat\n  ((int b' - int b) *\n   Number_Theory_Aux.inverse\n    (nat ((int a mod int q - int a' mod int q) mod int q)) q mod\n   int q)\n                                  else nat\n  ((int b - int b') *\n   Number_Theory_Aux.inverse\n    (nat ((int a' mod int q - int a mod int q) mod int q)) q mod\n   int q)) =\n                                 x1))))))))\n   True\n  \\<le> spmf\n         (sample_uniform q \\<bind>\n          (\\<lambda>a''.\n              sample_uniform q \\<bind>\n              (\\<lambda>b''.\n                  \\<A> (a'', b'') \\<bind>\n                  (\\<lambda>(c, m, (a, b), m', a', b').\n                      map_spmf\n                       ((=) (if a' mod q < a mod q\n                             then nat ((int b' - int b) *\n Number_Theory_Aux.inverse\n  (nat ((int a mod int q - int a' mod int q) mod int q)) q mod\n int q)\n                             else nat ((int b - int b') *\n Number_Theory_Aux.inverse\n  (nat ((int a' mod int q - int a mod int q) mod int q)) q mod\n int q)))\n                       (sample_uniform q)))))\n         True\n\ngoal (1 subgoal):\n 1. spmf (rivest_commit.bind_game \\<A>) True \\<le> 1 / real q", "have \"... \\<le> 1/q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. spmf\n     (sample_uniform q \\<bind>\n      (\\<lambda>a''.\n          sample_uniform q \\<bind>\n          (\\<lambda>b''.\n              \\<A> (a'', b'') \\<bind>\n              (\\<lambda>(c, m, (a, b), m', a', b').\n                  map_spmf\n                   ((=) (if a' mod q < a mod q\n                         then nat ((int b' - int b) *\n                                   Number_Theory_Aux.inverse\n                                    (nat\n((int a mod int q - int a' mod int q) mod int q))\n                                    q mod\n                                   int q)\n                         else nat ((int b - int b') *\n                                   Number_Theory_Aux.inverse\n                                    (nat\n((int a' mod int q - int a mod int q) mod int q))\n                                    q mod\n                                   int q)))\n                   (sample_uniform q)))))\n     True\n    \\<le> 1 / real q", "proof((rule spmf_bind_leI)+, clarify)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>y ya a aa ab b ac ad ba.\n       \\<lbrakk>y \\<in> set_spmf (sample_uniform q);\n        ya \\<in> set_spmf (sample_uniform q);\n        (a, aa, (ab, b), ac, ad, ba) \\<in> set_spmf (\\<A> (y, ya))\\<rbrakk>\n       \\<Longrightarrow> spmf\n                          (map_spmf\n                            ((=) (if ad mod q < ab mod q\n                                  then nat\n  ((int ba - int b) *\n   Number_Theory_Aux.inverse\n    (nat ((int ab mod int q - int ad mod int q) mod int q)) q mod\n   int q)\n                                  else nat\n  ((int b - int ba) *\n   Number_Theory_Aux.inverse\n    (nat ((int ad mod int q - int ab mod int q) mod int q)) q mod\n   int q)))\n                            (sample_uniform q))\n                          True\n                         \\<le> 1 / real q\n 2. \\<And>y ya.\n       \\<lbrakk>y \\<in> set_spmf (sample_uniform q);\n        ya \\<in> set_spmf (sample_uniform q)\\<rbrakk>\n       \\<Longrightarrow> 0 \\<le> 1 / real q\n 3. \\<And>y.\n       y \\<in> set_spmf (sample_uniform q) \\<Longrightarrow>\n       0 \\<le> 1 / real q\n 4. 0 \\<le> 1 / real q", "fix a a' b b'"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>y ya a aa ab b ac ad ba.\n       \\<lbrakk>y \\<in> set_spmf (sample_uniform q);\n        ya \\<in> set_spmf (sample_uniform q);\n        (a, aa, (ab, b), ac, ad, ba) \\<in> set_spmf (\\<A> (y, ya))\\<rbrakk>\n       \\<Longrightarrow> spmf\n                          (map_spmf\n                            ((=) (if ad mod q < ab mod q\n                                  then nat\n  ((int ba - int b) *\n   Number_Theory_Aux.inverse\n    (nat ((int ab mod int q - int ad mod int q) mod int q)) q mod\n   int q)\n                                  else nat\n  ((int b - int ba) *\n   Number_Theory_Aux.inverse\n    (nat ((int ad mod int q - int ab mod int q) mod int q)) q mod\n   int q)))\n                            (sample_uniform q))\n                          True\n                         \\<le> 1 / real q\n 2. \\<And>y ya.\n       \\<lbrakk>y \\<in> set_spmf (sample_uniform q);\n        ya \\<in> set_spmf (sample_uniform q)\\<rbrakk>\n       \\<Longrightarrow> 0 \\<le> 1 / real q\n 3. \\<And>y.\n       y \\<in> set_spmf (sample_uniform q) \\<Longrightarrow>\n       0 \\<le> 1 / real q\n 4. 0 \\<le> 1 / real q", "define A where \"A = Collect (?eq a a' b b')\""], ["proof (state)\nthis:\n  A =\n  Collect\n   ((=) (if a' mod q < a mod q\n         then nat ((int b' - int b) *\n                   Number_Theory_Aux.inverse\n                    (nat ((int a mod int q - int a' mod int q) mod int q))\n                    q mod\n                   int q)\n         else nat ((int b - int b') *\n                   Number_Theory_Aux.inverse\n                    (nat ((int a' mod int q - int a mod int q) mod int q))\n                    q mod\n                   int q)))\n\ngoal (4 subgoals):\n 1. \\<And>y ya a aa ab b ac ad ba.\n       \\<lbrakk>y \\<in> set_spmf (sample_uniform q);\n        ya \\<in> set_spmf (sample_uniform q);\n        (a, aa, (ab, b), ac, ad, ba) \\<in> set_spmf (\\<A> (y, ya))\\<rbrakk>\n       \\<Longrightarrow> spmf\n                          (map_spmf\n                            ((=) (if ad mod q < ab mod q\n                                  then nat\n  ((int ba - int b) *\n   Number_Theory_Aux.inverse\n    (nat ((int ab mod int q - int ad mod int q) mod int q)) q mod\n   int q)\n                                  else nat\n  ((int b - int ba) *\n   Number_Theory_Aux.inverse\n    (nat ((int ad mod int q - int ab mod int q) mod int q)) q mod\n   int q)))\n                            (sample_uniform q))\n                          True\n                         \\<le> 1 / real q\n 2. \\<And>y ya.\n       \\<lbrakk>y \\<in> set_spmf (sample_uniform q);\n        ya \\<in> set_spmf (sample_uniform q)\\<rbrakk>\n       \\<Longrightarrow> 0 \\<le> 1 / real q\n 3. \\<And>y.\n       y \\<in> set_spmf (sample_uniform q) \\<Longrightarrow>\n       0 \\<le> 1 / real q\n 4. 0 \\<le> 1 / real q", "define x1 where \"x1 = The (?eq a a' b b')\""], ["proof (state)\nthis:\n  x1 =\n  The ((=) (if a' mod q < a mod q\n            then nat ((int b' - int b) *\n                      Number_Theory_Aux.inverse\n                       (nat ((int a mod int q - int a' mod int q) mod\n                             int q))\n                       q mod\n                      int q)\n            else nat ((int b - int b') *\n                      Number_Theory_Aux.inverse\n                       (nat ((int a' mod int q - int a mod int q) mod\n                             int q))\n                       q mod\n                      int q)))\n\ngoal (4 subgoals):\n 1. \\<And>y ya a aa ab b ac ad ba.\n       \\<lbrakk>y \\<in> set_spmf (sample_uniform q);\n        ya \\<in> set_spmf (sample_uniform q);\n        (a, aa, (ab, b), ac, ad, ba) \\<in> set_spmf (\\<A> (y, ya))\\<rbrakk>\n       \\<Longrightarrow> spmf\n                          (map_spmf\n                            ((=) (if ad mod q < ab mod q\n                                  then nat\n  ((int ba - int b) *\n   Number_Theory_Aux.inverse\n    (nat ((int ab mod int q - int ad mod int q) mod int q)) q mod\n   int q)\n                                  else nat\n  ((int b - int ba) *\n   Number_Theory_Aux.inverse\n    (nat ((int ad mod int q - int ab mod int q) mod int q)) q mod\n   int q)))\n                            (sample_uniform q))\n                          True\n                         \\<le> 1 / real q\n 2. \\<And>y ya.\n       \\<lbrakk>y \\<in> set_spmf (sample_uniform q);\n        ya \\<in> set_spmf (sample_uniform q)\\<rbrakk>\n       \\<Longrightarrow> 0 \\<le> 1 / real q\n 3. \\<And>y.\n       y \\<in> set_spmf (sample_uniform q) \\<Longrightarrow>\n       0 \\<le> 1 / real q\n 4. 0 \\<le> 1 / real q", "note q_gt_0[simp del]"], ["proof (state)\nthis:\n  0 < q\n\ngoal (4 subgoals):\n 1. \\<And>y ya a aa ab b ac ad ba.\n       \\<lbrakk>y \\<in> set_spmf (sample_uniform q);\n        ya \\<in> set_spmf (sample_uniform q);\n        (a, aa, (ab, b), ac, ad, ba) \\<in> set_spmf (\\<A> (y, ya))\\<rbrakk>\n       \\<Longrightarrow> spmf\n                          (map_spmf\n                            ((=) (if ad mod q < ab mod q\n                                  then nat\n  ((int ba - int b) *\n   Number_Theory_Aux.inverse\n    (nat ((int ab mod int q - int ad mod int q) mod int q)) q mod\n   int q)\n                                  else nat\n  ((int b - int ba) *\n   Number_Theory_Aux.inverse\n    (nat ((int ad mod int q - int ab mod int q) mod int q)) q mod\n   int q)))\n                            (sample_uniform q))\n                          True\n                         \\<le> 1 / real q\n 2. \\<And>y ya.\n       \\<lbrakk>y \\<in> set_spmf (sample_uniform q);\n        ya \\<in> set_spmf (sample_uniform q)\\<rbrakk>\n       \\<Longrightarrow> 0 \\<le> 1 / real q\n 3. \\<And>y.\n       y \\<in> set_spmf (sample_uniform q) \\<Longrightarrow>\n       0 \\<le> 1 / real q\n 4. 0 \\<le> 1 / real q", "have \"A \\<subseteq> {x1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<subseteq> {x1}", "by(auto simp add: A_def x1_def)"], ["proof (state)\nthis:\n  A \\<subseteq> {x1}\n\ngoal (4 subgoals):\n 1. \\<And>y ya a aa ab b ac ad ba.\n       \\<lbrakk>y \\<in> set_spmf (sample_uniform q);\n        ya \\<in> set_spmf (sample_uniform q);\n        (a, aa, (ab, b), ac, ad, ba) \\<in> set_spmf (\\<A> (y, ya))\\<rbrakk>\n       \\<Longrightarrow> spmf\n                          (map_spmf\n                            ((=) (if ad mod q < ab mod q\n                                  then nat\n  ((int ba - int b) *\n   Number_Theory_Aux.inverse\n    (nat ((int ab mod int q - int ad mod int q) mod int q)) q mod\n   int q)\n                                  else nat\n  ((int b - int ba) *\n   Number_Theory_Aux.inverse\n    (nat ((int ad mod int q - int ab mod int q) mod int q)) q mod\n   int q)))\n                            (sample_uniform q))\n                          True\n                         \\<le> 1 / real q\n 2. \\<And>y ya.\n       \\<lbrakk>y \\<in> set_spmf (sample_uniform q);\n        ya \\<in> set_spmf (sample_uniform q)\\<rbrakk>\n       \\<Longrightarrow> 0 \\<le> 1 / real q\n 3. \\<And>y.\n       y \\<in> set_spmf (sample_uniform q) \\<Longrightarrow>\n       0 \\<le> 1 / real q\n 4. 0 \\<le> 1 / real q", "hence \"card (A \\<inter> {..<q}) \\<le> card {x1}\""], ["proof (prove)\nusing this:\n  A \\<subseteq> {x1}\n\ngoal (1 subgoal):\n 1. card (A \\<inter> {..<q}) \\<le> card {x1}", "by(intro card_mono) auto"], ["proof (state)\nthis:\n  card (A \\<inter> {..<q}) \\<le> card {x1}\n\ngoal (4 subgoals):\n 1. \\<And>y ya a aa ab b ac ad ba.\n       \\<lbrakk>y \\<in> set_spmf (sample_uniform q);\n        ya \\<in> set_spmf (sample_uniform q);\n        (a, aa, (ab, b), ac, ad, ba) \\<in> set_spmf (\\<A> (y, ya))\\<rbrakk>\n       \\<Longrightarrow> spmf\n                          (map_spmf\n                            ((=) (if ad mod q < ab mod q\n                                  then nat\n  ((int ba - int b) *\n   Number_Theory_Aux.inverse\n    (nat ((int ab mod int q - int ad mod int q) mod int q)) q mod\n   int q)\n                                  else nat\n  ((int b - int ba) *\n   Number_Theory_Aux.inverse\n    (nat ((int ad mod int q - int ab mod int q) mod int q)) q mod\n   int q)))\n                            (sample_uniform q))\n                          True\n                         \\<le> 1 / real q\n 2. \\<And>y ya.\n       \\<lbrakk>y \\<in> set_spmf (sample_uniform q);\n        ya \\<in> set_spmf (sample_uniform q)\\<rbrakk>\n       \\<Longrightarrow> 0 \\<le> 1 / real q\n 3. \\<And>y.\n       y \\<in> set_spmf (sample_uniform q) \\<Longrightarrow>\n       0 \\<le> 1 / real q\n 4. 0 \\<le> 1 / real q", "also"], ["proof (state)\nthis:\n  card (A \\<inter> {..<q}) \\<le> card {x1}\n\ngoal (4 subgoals):\n 1. \\<And>y ya a aa ab b ac ad ba.\n       \\<lbrakk>y \\<in> set_spmf (sample_uniform q);\n        ya \\<in> set_spmf (sample_uniform q);\n        (a, aa, (ab, b), ac, ad, ba) \\<in> set_spmf (\\<A> (y, ya))\\<rbrakk>\n       \\<Longrightarrow> spmf\n                          (map_spmf\n                            ((=) (if ad mod q < ab mod q\n                                  then nat\n  ((int ba - int b) *\n   Number_Theory_Aux.inverse\n    (nat ((int ab mod int q - int ad mod int q) mod int q)) q mod\n   int q)\n                                  else nat\n  ((int b - int ba) *\n   Number_Theory_Aux.inverse\n    (nat ((int ad mod int q - int ab mod int q) mod int q)) q mod\n   int q)))\n                            (sample_uniform q))\n                          True\n                         \\<le> 1 / real q\n 2. \\<And>y ya.\n       \\<lbrakk>y \\<in> set_spmf (sample_uniform q);\n        ya \\<in> set_spmf (sample_uniform q)\\<rbrakk>\n       \\<Longrightarrow> 0 \\<le> 1 / real q\n 3. \\<And>y.\n       y \\<in> set_spmf (sample_uniform q) \\<Longrightarrow>\n       0 \\<le> 1 / real q\n 4. 0 \\<le> 1 / real q", "have \"\\<dots> = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card {x1} = 1", "by simp"], ["proof (state)\nthis:\n  card {x1} = 1\n\ngoal (4 subgoals):\n 1. \\<And>y ya a aa ab b ac ad ba.\n       \\<lbrakk>y \\<in> set_spmf (sample_uniform q);\n        ya \\<in> set_spmf (sample_uniform q);\n        (a, aa, (ab, b), ac, ad, ba) \\<in> set_spmf (\\<A> (y, ya))\\<rbrakk>\n       \\<Longrightarrow> spmf\n                          (map_spmf\n                            ((=) (if ad mod q < ab mod q\n                                  then nat\n  ((int ba - int b) *\n   Number_Theory_Aux.inverse\n    (nat ((int ab mod int q - int ad mod int q) mod int q)) q mod\n   int q)\n                                  else nat\n  ((int b - int ba) *\n   Number_Theory_Aux.inverse\n    (nat ((int ad mod int q - int ab mod int q) mod int q)) q mod\n   int q)))\n                            (sample_uniform q))\n                          True\n                         \\<le> 1 / real q\n 2. \\<And>y ya.\n       \\<lbrakk>y \\<in> set_spmf (sample_uniform q);\n        ya \\<in> set_spmf (sample_uniform q)\\<rbrakk>\n       \\<Longrightarrow> 0 \\<le> 1 / real q\n 3. \\<And>y.\n       y \\<in> set_spmf (sample_uniform q) \\<Longrightarrow>\n       0 \\<le> 1 / real q\n 4. 0 \\<le> 1 / real q", "finally"], ["proof (chain)\npicking this:\n  card (A \\<inter> {..<q}) \\<le> 1", "have \"spmf (map_spmf (\\<lambda>x. x \\<in> A) (sample_uniform q)) True \\<le> 1 / q\""], ["proof (prove)\nusing this:\n  card (A \\<inter> {..<q}) \\<le> 1\n\ngoal (1 subgoal):\n 1. spmf (map_spmf (\\<lambda>x. x \\<in> A) (sample_uniform q)) True\n    \\<le> 1 / real q", "using q_gt_0"], ["proof (prove)\nusing this:\n  card (A \\<inter> {..<q}) \\<le> 1\n  0 < q\n\ngoal (1 subgoal):\n 1. spmf (map_spmf (\\<lambda>x. x \\<in> A) (sample_uniform q)) True\n    \\<le> 1 / real q", "unfolding sample_uniform_def"], ["proof (prove)\nusing this:\n  card (A \\<inter> {..<q}) \\<le> 1\n  0 < q\n\ngoal (1 subgoal):\n 1. spmf (map_spmf (\\<lambda>x. x \\<in> A) (spmf_of_set {..<q})) True\n    \\<le> 1 / real q", "by(subst map_mem_spmf_of_set)(auto simp add: field_simps)"], ["proof (state)\nthis:\n  spmf (map_spmf (\\<lambda>x. x \\<in> A) (sample_uniform q)) True\n  \\<le> 1 / real q\n\ngoal (4 subgoals):\n 1. \\<And>y ya a aa ab b ac ad ba.\n       \\<lbrakk>y \\<in> set_spmf (sample_uniform q);\n        ya \\<in> set_spmf (sample_uniform q);\n        (a, aa, (ab, b), ac, ad, ba) \\<in> set_spmf (\\<A> (y, ya))\\<rbrakk>\n       \\<Longrightarrow> spmf\n                          (map_spmf\n                            ((=) (if ad mod q < ab mod q\n                                  then nat\n  ((int ba - int b) *\n   Number_Theory_Aux.inverse\n    (nat ((int ab mod int q - int ad mod int q) mod int q)) q mod\n   int q)\n                                  else nat\n  ((int b - int ba) *\n   Number_Theory_Aux.inverse\n    (nat ((int ad mod int q - int ab mod int q) mod int q)) q mod\n   int q)))\n                            (sample_uniform q))\n                          True\n                         \\<le> 1 / real q\n 2. \\<And>y ya.\n       \\<lbrakk>y \\<in> set_spmf (sample_uniform q);\n        ya \\<in> set_spmf (sample_uniform q)\\<rbrakk>\n       \\<Longrightarrow> 0 \\<le> 1 / real q\n 3. \\<And>y.\n       y \\<in> set_spmf (sample_uniform q) \\<Longrightarrow>\n       0 \\<le> 1 / real q\n 4. 0 \\<le> 1 / real q", "then"], ["proof (chain)\npicking this:\n  spmf (map_spmf (\\<lambda>x. x \\<in> A) (sample_uniform q)) True\n  \\<le> 1 / real q", "show \"spmf (map_spmf (?eq a a' b b') (sample_uniform q)) True \\<le> 1 / q\""], ["proof (prove)\nusing this:\n  spmf (map_spmf (\\<lambda>x. x \\<in> A) (sample_uniform q)) True\n  \\<le> 1 / real q\n\ngoal (1 subgoal):\n 1. spmf\n     (map_spmf\n       ((=) (if a' mod q < a mod q\n             then nat ((int b' - int b) *\n                       Number_Theory_Aux.inverse\n                        (nat ((int a mod int q - int a' mod int q) mod\n                              int q))\n                        q mod\n                       int q)\n             else nat ((int b - int b') *\n                       Number_Theory_Aux.inverse\n                        (nat ((int a' mod int q - int a mod int q) mod\n                              int q))\n                        q mod\n                       int q)))\n       (sample_uniform q))\n     True\n    \\<le> 1 / real q", "unfolding A_def mem_Collect_eq"], ["proof (prove)\nusing this:\n  spmf\n   (map_spmf\n     ((=) (if a' mod q < a mod q\n           then nat ((int b' - int b) *\n                     Number_Theory_Aux.inverse\n                      (nat ((int a mod int q - int a' mod int q) mod int q))\n                      q mod\n                     int q)\n           else nat ((int b - int b') *\n                     Number_Theory_Aux.inverse\n                      (nat ((int a' mod int q - int a mod int q) mod int q))\n                      q mod\n                     int q)))\n     (sample_uniform q))\n   True\n  \\<le> 1 / real q\n\ngoal (1 subgoal):\n 1. spmf\n     (map_spmf\n       ((=) (if a' mod q < a mod q\n             then nat ((int b' - int b) *\n                       Number_Theory_Aux.inverse\n                        (nat ((int a mod int q - int a' mod int q) mod\n                              int q))\n                        q mod\n                       int q)\n             else nat ((int b - int b') *\n                       Number_Theory_Aux.inverse\n                        (nat ((int a' mod int q - int a mod int q) mod\n                              int q))\n                        q mod\n                       int q)))\n       (sample_uniform q))\n     True\n    \\<le> 1 / real q", "."], ["proof (state)\nthis:\n  spmf\n   (map_spmf\n     ((=) (if a' mod q < a mod q\n           then nat ((int b' - int b) *\n                     Number_Theory_Aux.inverse\n                      (nat ((int a mod int q - int a' mod int q) mod int q))\n                      q mod\n                     int q)\n           else nat ((int b - int b') *\n                     Number_Theory_Aux.inverse\n                      (nat ((int a' mod int q - int a mod int q) mod int q))\n                      q mod\n                     int q)))\n     (sample_uniform q))\n   True\n  \\<le> 1 / real q\n\ngoal (3 subgoals):\n 1. \\<And>y ya.\n       \\<lbrakk>y \\<in> set_spmf (sample_uniform q);\n        ya \\<in> set_spmf (sample_uniform q)\\<rbrakk>\n       \\<Longrightarrow> 0 \\<le> 1 / real q\n 2. \\<And>y.\n       y \\<in> set_spmf (sample_uniform q) \\<Longrightarrow>\n       0 \\<le> 1 / real q\n 3. 0 \\<le> 1 / real q", "qed auto"], ["proof (state)\nthis:\n  spmf\n   (sample_uniform q \\<bind>\n    (\\<lambda>a''.\n        sample_uniform q \\<bind>\n        (\\<lambda>b''.\n            \\<A> (a'', b'') \\<bind>\n            (\\<lambda>(c, m, (a, b), m', a', b').\n                map_spmf\n                 ((=) (if a' mod q < a mod q\n                       then nat ((int b' - int b) *\n                                 Number_Theory_Aux.inverse\n                                  (nat ((int a mod int q -\n   int a' mod int q) mod\n  int q))\n                                  q mod\n                                 int q)\n                       else nat ((int b - int b') *\n                                 Number_Theory_Aux.inverse\n                                  (nat ((int a' mod int q -\n   int a mod int q) mod\n  int q))\n                                  q mod\n                                 int q)))\n                 (sample_uniform q)))))\n   True\n  \\<le> 1 / real q\n\ngoal (1 subgoal):\n 1. spmf (rivest_commit.bind_game \\<A>) True \\<le> 1 / real q", "finally"], ["proof (chain)\npicking this:\n  spmf (rivest_commit.bind_game \\<A>) True \\<le> 1 / real q", "show ?thesis"], ["proof (prove)\nusing this:\n  spmf (rivest_commit.bind_game \\<A>) True \\<le> 1 / real q\n\ngoal (1 subgoal):\n 1. spmf (rivest_commit.bind_game \\<A>) True \\<le> 1 / real q", "."], ["proof (state)\nthis:\n  spmf (rivest_commit.bind_game \\<A>) True \\<le> 1 / real q\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rivest_bind:\n  shows \"rivest_commit.bind_advantage \\<A> \\<le> 1 / q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rivest_commit.bind_advantage \\<A> \\<le> 1 / real q", "using bind_game_le_inv_q rivest_commit.bind_advantage_def"], ["proof (prove)\nusing this:\n  spmf (rivest_commit.bind_game ?\\<A>) True \\<le> 1 / real q\n  rivest_commit.bind_advantage ?\\<A> \\<equiv>\n  spmf (rivest_commit.bind_game ?\\<A>) True\n\ngoal (1 subgoal):\n 1. rivest_commit.bind_advantage \\<A> \\<le> 1 / real q", "by simp"], ["", "end"], ["", "locale rivest_asymp = \n  fixes q :: \"nat \\<Rightarrow> nat\"\n  assumes rivest: \"\\<And>\\<eta>. rivest (q \\<eta>)\"\nbegin"], ["", "sublocale rivest \"q \\<eta>\" for \\<eta>"], ["proof (prove)\ngoal (1 subgoal):\n 1. rivest (q \\<eta>)", "by(simp add: rivest)"], ["", "theorem rivest_correct: \n  shows \"rivest_commit.correct n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rivest_commit.correct n", "using abstract_correct"], ["proof (prove)\nusing this:\n  rivest_commit.correct ?\\<eta>\n\ngoal (1 subgoal):\n 1. rivest_commit.correct n", "by simp"], ["", "theorem rivest_perfect_hiding_asym:\n  assumes lossless_\\<A>: \"rivest_commit.lossless (\\<A> n)\" \n  shows \"rivest_commit.perfect_hiding_ind_cpa n (\\<A> n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rivest_commit.perfect_hiding_ind_cpa n (\\<A> n)", "by (simp add: lossless_\\<A> rivest_perfect_hiding)"], ["", "theorem rivest_binding_asym:\n  assumes \"negligible (\\<lambda>n. 1 / (q n))\"\n  shows \"negligible (\\<lambda>n. rivest_commit.bind_advantage n (\\<A> n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Negligible.negligible\n     (\\<lambda>n. rivest_commit.bind_advantage n (\\<A> n))", "using negligible_le rivest_bind assms rivest_commit.bind_advantage_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>Negligible.negligible ?g;\n   \\<And>\\<eta>. \\<bar>?f \\<eta>\\<bar> \\<le> ?g \\<eta>\\<rbrakk>\n  \\<Longrightarrow> Negligible.negligible ?f\n  rivest_commit.bind_advantage ?\\<eta> ?\\<A> \\<le> 1 / real (q ?\\<eta>)\n  Negligible.negligible (\\<lambda>n. 1 / real (q n))\n  rivest_commit.bind_advantage ?\\<eta> ?\\<A> \\<equiv>\n  spmf (rivest_commit.bind_game ?\\<eta> ?\\<A>) True\n\ngoal (1 subgoal):\n 1. Negligible.negligible\n     (\\<lambda>n. rivest_commit.bind_advantage n (\\<A> n))", "by auto"], ["", "end"], ["", "end"]]}