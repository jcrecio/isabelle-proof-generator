{"file_name": "/home/qj213/afp-2021-10-22/thys/Sigma_Commit_Crypto/Chaum_Pedersen_Sigma_Commit.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Sigma_Commit_Crypto", "problem_names": ["lemma or_gt_1: \"order \\<G> > 1\"", "lemma or_gt_0 [simp]:\"order \\<G> > 0\"", "lemma lossless_G: \"lossless_spmf G\"", "lemma lossless_init: \"lossless_spmf (init h w)\"", "lemma lossless_response: \"lossless_spmf (response r w  e)\"", "lemma g'_in_carrier [simp]: \"g' \\<in> carrier \\<G>\"", "lemma completeness: \n  shows \"chaum_ped_sigma.completeness\"", "lemma hvzk_xr'_rewrite:\n  assumes r: \"r < order \\<G>\"\n  shows \"((w*c + r) mod (order \\<G>) mod (order \\<G>) + (order \\<G>) * w*c - w*c) mod (order \\<G>) = r\"\n(is \"?lhs = ?rhs\")", "lemma hvzk_h_sub_rewrite:\n  assumes \"h = \\<^bold>g [^] w\"  \n    and z: \"z < order \\<G>\" \n  shows \"\\<^bold>g [^] ((z + (order \\<G>)* w * c - w*c)) = \\<^bold>g [^] z \\<otimes> inv (h [^] c)\" \n    (is \"?lhs = ?rhs\")", "lemma hvzk_h_sub2_rewrite:\n  assumes  \"h' = g' [^] w\" \n    and z: \"z < order \\<G>\" \n  shows \"g' [^] ((z + (order \\<G>)*w*c - w*c))  = g' [^] z \\<otimes> inv (h' [^] c)\" \n    (is \"?lhs = ?rhs\")", "lemma hv_zk2:\n  assumes \"(H, w) \\<in> R\" \n  shows \"chaum_ped_sigma.R H w c = chaum_ped_sigma.S H c\"", "lemma HVZK: \n  shows \"chaum_ped_sigma.HVZK\"", "lemma ss_rewrite1:\n  assumes \"fst h \\<in> carrier \\<G>\"\n    and \"a \\<in> carrier \\<G>\" \n    and e: \"e < order \\<G>\" \n    and \"a \\<otimes> fst h [^] e = \\<^bold>g [^] z\"  \n    and e': \"e' < e\"\n    and \"a \\<otimes> fst h [^] e' = \\<^bold>g [^] z'\"\n  shows \"fst h = \\<^bold>g [^] ((int z - int z') * inverse (e - e') (order \\<G>) mod int (order \\<G>))\"", "lemma ss_rewrite2:\n  assumes \"fst h \\<in> carrier \\<G>\"\n    and \"snd h \\<in> carrier \\<G>\" \n    and \"a \\<in> carrier \\<G>\" \n    and \"b \\<in> carrier \\<G>\"\n    and \"e < order \\<G>\" \n    and \"a \\<otimes> fst h [^] e = \\<^bold>g [^] z\" \n    and \"b \\<otimes> snd h [^] e = g' [^] z\"\n    and \"e' < e\" \n    and \"a \\<otimes> fst h [^] e' = \\<^bold>g [^] z'\"\n    and \"b \\<otimes> snd h [^] e' = g' [^] z'\"\n  shows \"snd h = g' [^] ((int z - int z') * inverse (e - e') (order \\<G>) mod int (order \\<G>))\"", "lemma ss_rewrite_snd_h:\n  assumes e_e'_mod: \"e' mod order \\<G> < e mod order \\<G>\"\n    and h_mem: \"snd h \\<in> carrier \\<G>\"\n    and a_mem: \"snd a \\<in> carrier \\<G>\"\n    and a1: \"snd a \\<otimes> snd h [^] e = g' [^] z\" \n    and a2: \"snd a \\<otimes> snd h [^] e' = g' [^] z'\" \n  shows \"snd h = g' [^] ((int z - int z') * fst (bezw ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>) (order \\<G>)) mod int (order \\<G>))\"", "lemma special_soundness:\n  shows \"chaum_ped_sigma.special_soundness\"", "theorem \\<Sigma>_protocol:  \"chaum_ped_sigma.\\<Sigma>_protocol\"", "lemma reduction_to_dis_log: \n  shows \"chaum_ped_\\<Sigma>_commit.rel_advantage \\<A> = dis_log.advantage (dis_log_alt.adversary3 \\<A>)\"", "lemma commitment_correct: \"chaum_ped_\\<Sigma>_commit.abstract_com.correct\"", "lemma  \"chaum_ped_\\<Sigma>_commit.abstract_com.perfect_hiding_ind_cpa \\<A>\"", "lemma binding: \"chaum_ped_\\<Sigma>_commit.abstract_com.bind_advantage \\<A> \\<le> dis_log.advantage (dis_log_alt.adversary3 ((chaum_ped_\\<Sigma>_commit.adversary \\<A>)))\"", "theorem sigma_protocol:\n  shows \"chaum_ped_sigma.\\<Sigma>_protocol n\"", "lemma asymp_correct: \"chaum_ped_\\<Sigma>_commit.abstract_com.correct n\"", "lemma asymp_perfect_hiding: \"chaum_ped_\\<Sigma>_commit.abstract_com.perfect_hiding_ind_cpa n (\\<A> n)\"", "lemma asymp_computational_binding: \n  assumes \"negligible (\\<lambda> n. dis_log.advantage n (dis_log_alt.adversary3 n ((chaum_ped_\\<Sigma>_commit.adversary n (\\<A> n)))))\"\n  shows \"negligible (\\<lambda> n. chaum_ped_\\<Sigma>_commit.abstract_com.bind_advantage n (\\<A> n))\""], "translations": [["", "lemma or_gt_1: \"order \\<G> > 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 < order \\<G>", "using prime_order"], ["proof (prove)\nusing this:\n  prime (order \\<G>)\n\ngoal (1 subgoal):\n 1. 1 < order \\<G>", "using prime_gt_1_nat"], ["proof (prove)\nusing this:\n  prime (order \\<G>)\n  prime ?p \\<Longrightarrow> 1 < ?p\n\ngoal (1 subgoal):\n 1. 1 < order \\<G>", "by blast"], ["", "lemma or_gt_0 [simp]:\"order \\<G> > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < order \\<G>", "using or_gt_1"], ["proof (prove)\nusing this:\n  1 < order \\<G>\n\ngoal (1 subgoal):\n 1. 0 < order \\<G>", "by simp"], ["", "type_synonym witness = \"nat\""], ["", "type_synonym rand = nat"], ["", "type_synonym 'grp' msg = \"'grp' \\<times> 'grp'\""], ["", "type_synonym response = nat"], ["", "type_synonym challenge = nat"], ["", "type_synonym 'grp' pub_in = \"'grp' \\<times> 'grp'\""], ["", "definition \"G = do {\n    w \\<leftarrow> sample_uniform (order \\<G>);\n    return_spmf ((\\<^bold>g [^] w, g' [^] w), w)}\""], ["", "lemma lossless_G: \"lossless_spmf G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lossless_spmf G", "by(simp add: G_def)"], ["", "definition \"challenge_space = {..< order \\<G>}\""], ["", "definition init :: \"'grp pub_in \\<Rightarrow> witness \\<Rightarrow> (rand \\<times> 'grp msg) spmf\"\n  where \"init h w = do {\n    let (h, h') = h;  \n    r \\<leftarrow> sample_uniform (order \\<G>);\n    return_spmf (r, \\<^bold>g [^] r, g' [^] r)}\""], ["", "lemma lossless_init: \"lossless_spmf (init h w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lossless_spmf (init h w)", "by(simp add:  init_def)"], ["", "definition \"response r w e = return_spmf ((w*e + r) mod (order \\<G>))\""], ["", "lemma lossless_response: \"lossless_spmf (response r w  e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lossless_spmf (response r w e)", "by(simp add: response_def)"], ["", "definition check :: \"'grp pub_in \\<Rightarrow> 'grp msg \\<Rightarrow> challenge \\<Rightarrow> response \\<Rightarrow> bool\"\n  where \"check h a e z =  (fst a \\<otimes> (fst h [^] e) = \\<^bold>g [^] z \\<and> snd a \\<otimes> (snd h [^] e) = g' [^] z \\<and> fst a \\<in> carrier \\<G> \\<and> snd a \\<in> carrier \\<G>)\""], ["", "definition R :: \"('grp pub_in \\<times> witness) set\"\n  where \"R = {(h, w). (fst h = \\<^bold>g [^] w \\<and> snd h = g' [^] w)}\""], ["", "definition S2 :: \"'grp pub_in \\<Rightarrow> challenge \\<Rightarrow> ('grp msg, response) sim_out spmf\"\n  where \"S2 H c = do {\n  let (h, h') = H;\n  z \\<leftarrow> (sample_uniform (order \\<G>));\n  let a = \\<^bold>g [^] z \\<otimes> inv (h [^] c); \n  let a' =  g' [^] z \\<otimes> inv (h' [^] c);\n  return_spmf ((a,a'), z)}\""], ["", "definition ss_adversary :: \"'grp pub_in \\<Rightarrow> ('grp msg, challenge, response) conv_tuple \\<Rightarrow> ('grp msg, challenge, response) conv_tuple \\<Rightarrow> nat spmf\"\n  where \"ss_adversary x' c1 c2 = do {\n    let ((a,a'), e, z) = c1;\n    let ((b,b'), e', z') = c2;\n    return_spmf (if (e mod order \\<G> > e' mod order \\<G>) then (nat ((int z - int z') * (fst (bezw ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>) (order \\<G>))) mod order \\<G>)) else \n(nat ((int z' - int z) * (fst (bezw ((e' mod order \\<G> - e mod order \\<G>) mod order \\<G>) (order \\<G>))) mod order \\<G>)))}\""], ["", "definition \"valid_pub = carrier \\<G> \\<times> carrier \\<G>\""], ["", "end"], ["", "locale chaum_ped_\\<Sigma> = chaum_ped_\\<Sigma>_base + cyclic_group \\<G>\nbegin"], ["", "lemma g'_in_carrier [simp]: \"g' \\<in> carrier \\<G>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g' \\<in> carrier \\<G>", "by(simp add: g'_def)"], ["", "sublocale chaum_ped_sigma: \\<Sigma>_protocols_base init response check R S2 ss_adversary challenge_space valid_pub"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sigma>_protocols_base R valid_pub", "by unfold_locales (auto simp add: R_def valid_pub_def)"], ["", "lemma completeness: \n  shows \"chaum_ped_sigma.completeness\""], ["proof (prove)\ngoal (1 subgoal):\n 1. chaum_ped_sigma.completeness", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. chaum_ped_sigma.completeness", "have \"g' [^] y \\<otimes> (g' [^] w') [^] e = g' [^] ((w' * e + y) mod order \\<G>)\" for y e w'"], ["proof (prove)\ngoal (1 subgoal):\n 1. g' [^] y \\<otimes> (g' [^] w') [^] e =\n    g' [^] ((w' * e + y) mod order \\<G>)", "by (simp add: Groups.add_ac(2) pow_carrier_mod nat_pow_pow nat_pow_mult)"], ["proof (state)\nthis:\n  g' [^] ?y \\<otimes> (g' [^] ?w') [^] ?e =\n  g' [^] ((?w' * ?e + ?y) mod order \\<G>)\n\ngoal (1 subgoal):\n 1. chaum_ped_sigma.completeness", "moreover"], ["proof (state)\nthis:\n  g' [^] ?y \\<otimes> (g' [^] ?w') [^] ?e =\n  g' [^] ((?w' * ?e + ?y) mod order \\<G>)\n\ngoal (1 subgoal):\n 1. chaum_ped_sigma.completeness", "have \"\\<^bold>g [^] y \\<otimes> (\\<^bold>g [^] w') [^] e = \\<^bold>g [^] ((w' * e + y) mod order \\<G>)\" for y e w'"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<^bold>g [^] y \\<otimes> (\\<^bold>g [^] w') [^] e =\n    \\<^bold>g [^] ((w' * e + y) mod order \\<G>)", "by (metis add.commute nat_pow_pow nat_pow_mult pow_generator_mod generator_closed mod_mult_right_eq)"], ["proof (state)\nthis:\n  \\<^bold>g [^] ?y \\<otimes> (\\<^bold>g [^] ?w') [^] ?e =\n  \\<^bold>g [^] ((?w' * ?e + ?y) mod order \\<G>)\n\ngoal (1 subgoal):\n 1. chaum_ped_sigma.completeness", "ultimately"], ["proof (chain)\npicking this:\n  g' [^] ?y \\<otimes> (g' [^] ?w') [^] ?e =\n  g' [^] ((?w' * ?e + ?y) mod order \\<G>)\n  \\<^bold>g [^] ?y \\<otimes> (\\<^bold>g [^] ?w') [^] ?e =\n  \\<^bold>g [^] ((?w' * ?e + ?y) mod order \\<G>)", "show ?thesis"], ["proof (prove)\nusing this:\n  g' [^] ?y \\<otimes> (g' [^] ?w') [^] ?e =\n  g' [^] ((?w' * ?e + ?y) mod order \\<G>)\n  \\<^bold>g [^] ?y \\<otimes> (\\<^bold>g [^] ?w') [^] ?e =\n  \\<^bold>g [^] ((?w' * ?e + ?y) mod order \\<G>)\n\ngoal (1 subgoal):\n 1. chaum_ped_sigma.completeness", "unfolding chaum_ped_sigma.completeness_def chaum_ped_sigma.completeness_game_def"], ["proof (prove)\nusing this:\n  g' [^] ?y \\<otimes> (g' [^] ?w') [^] ?e =\n  g' [^] ((?w' * ?e + ?y) mod order \\<G>)\n  \\<^bold>g [^] ?y \\<otimes> (\\<^bold>g [^] ?w') [^] ?e =\n  \\<^bold>g [^] ((?w' * ?e + ?y) mod order \\<G>)\n\ngoal (1 subgoal):\n 1. \\<forall>h w e.\n       (h, w) \\<in> R \\<longrightarrow>\n       e \\<in> challenge_space \\<longrightarrow>\n       spmf\n        (init h w \\<bind>\n         (\\<lambda>(r, a).\n             response r w e \\<bind>\n             (\\<lambda>z. return_spmf (check h a e z))))\n        True =\n       1", "by(auto simp add: R_def challenge_space_def init_def check_def response_def split_def bind_spmf_const)"], ["proof (state)\nthis:\n  chaum_ped_sigma.completeness\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma hvzk_xr'_rewrite:\n  assumes r: \"r < order \\<G>\"\n  shows \"((w*c + r) mod (order \\<G>) mod (order \\<G>) + (order \\<G>) * w*c - w*c) mod (order \\<G>) = r\"\n(is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((w * c + r) mod order \\<G> mod order \\<G> + order \\<G> * w * c -\n     w * c) mod\n    order \\<G> =\n    r", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. ((w * c + r) mod order \\<G> mod order \\<G> + order \\<G> * w * c -\n     w * c) mod\n    order \\<G> =\n    r", "have \"?lhs = (w*c + r  + (order \\<G>) * w*c- w*c) mod (order \\<G>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((w * c + r) mod order \\<G> mod order \\<G> + order \\<G> * w * c -\n     w * c) mod\n    order \\<G> =\n    (w * c + r + order \\<G> * w * c - w * c) mod order \\<G>", "by (metis Nat.add_diff_assoc Num.of_nat_simps(1) One_nat_def add_less_same_cancel2 less_imp_le_nat \n        mod_add_left_eq mult.assoc mult_0_right n_less_m_mult_n nat_neq_iff not_add_less2 of_nat_0_le_iff prime_gt_1_nat prime_order)"], ["proof (state)\nthis:\n  ((w * c + r) mod order \\<G> mod order \\<G> + order \\<G> * w * c -\n   w * c) mod\n  order \\<G> =\n  (w * c + r + order \\<G> * w * c - w * c) mod order \\<G>\n\ngoal (1 subgoal):\n 1. ((w * c + r) mod order \\<G> mod order \\<G> + order \\<G> * w * c -\n     w * c) mod\n    order \\<G> =\n    r", "thus ?thesis"], ["proof (prove)\nusing this:\n  ((w * c + r) mod order \\<G> mod order \\<G> + order \\<G> * w * c -\n   w * c) mod\n  order \\<G> =\n  (w * c + r + order \\<G> * w * c - w * c) mod order \\<G>\n\ngoal (1 subgoal):\n 1. ((w * c + r) mod order \\<G> mod order \\<G> + order \\<G> * w * c -\n     w * c) mod\n    order \\<G> =\n    r", "using r"], ["proof (prove)\nusing this:\n  ((w * c + r) mod order \\<G> mod order \\<G> + order \\<G> * w * c -\n   w * c) mod\n  order \\<G> =\n  (w * c + r + order \\<G> * w * c - w * c) mod order \\<G>\n  r < order \\<G>\n\ngoal (1 subgoal):\n 1. ((w * c + r) mod order \\<G> mod order \\<G> + order \\<G> * w * c -\n     w * c) mod\n    order \\<G> =\n    r", "by (metis ab_semigroup_add_class.add_ac(1) ab_semigroup_mult_class.mult_ac(1) diff_add_inverse mod_if mod_mult_self2)"], ["proof (state)\nthis:\n  ((w * c + r) mod order \\<G> mod order \\<G> + order \\<G> * w * c -\n   w * c) mod\n  order \\<G> =\n  r\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma hvzk_h_sub_rewrite:\n  assumes \"h = \\<^bold>g [^] w\"  \n    and z: \"z < order \\<G>\" \n  shows \"\\<^bold>g [^] ((z + (order \\<G>)* w * c - w*c)) = \\<^bold>g [^] z \\<otimes> inv (h [^] c)\" \n    (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<^bold>g [^] (z + order \\<G> * w * c - w * c) =\n    \\<^bold>g [^] z \\<otimes> inv (h [^] c)", "proof(cases \"w = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. w = 0 \\<Longrightarrow>\n    \\<^bold>g [^] (z + order \\<G> * w * c - w * c) =\n    \\<^bold>g [^] z \\<otimes> inv (h [^] c)\n 2. w \\<noteq> 0 \\<Longrightarrow>\n    \\<^bold>g [^] (z + order \\<G> * w * c - w * c) =\n    \\<^bold>g [^] z \\<otimes> inv (h [^] c)", "case True"], ["proof (state)\nthis:\n  w = 0\n\ngoal (2 subgoals):\n 1. w = 0 \\<Longrightarrow>\n    \\<^bold>g [^] (z + order \\<G> * w * c - w * c) =\n    \\<^bold>g [^] z \\<otimes> inv (h [^] c)\n 2. w \\<noteq> 0 \\<Longrightarrow>\n    \\<^bold>g [^] (z + order \\<G> * w * c - w * c) =\n    \\<^bold>g [^] z \\<otimes> inv (h [^] c)", "then"], ["proof (chain)\npicking this:\n  w = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  w = 0\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^] (z + order \\<G> * w * c - w * c) =\n    \\<^bold>g [^] z \\<otimes> inv (h [^] c)", "using assms"], ["proof (prove)\nusing this:\n  w = 0\n  h = \\<^bold>g [^] w\n  z < order \\<G>\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^] (z + order \\<G> * w * c - w * c) =\n    \\<^bold>g [^] z \\<otimes> inv (h [^] c)", "by simp"], ["proof (state)\nthis:\n  \\<^bold>g [^] (z + order \\<G> * w * c - w * c) =\n  \\<^bold>g [^] z \\<otimes> inv (h [^] c)\n\ngoal (1 subgoal):\n 1. w \\<noteq> 0 \\<Longrightarrow>\n    \\<^bold>g [^] (z + order \\<G> * w * c - w * c) =\n    \\<^bold>g [^] z \\<otimes> inv (h [^] c)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. w \\<noteq> 0 \\<Longrightarrow>\n    \\<^bold>g [^] (z + order \\<G> * w * c - w * c) =\n    \\<^bold>g [^] z \\<otimes> inv (h [^] c)", "case w_gt_0: False"], ["proof (state)\nthis:\n  w \\<noteq> 0\n\ngoal (1 subgoal):\n 1. w \\<noteq> 0 \\<Longrightarrow>\n    \\<^bold>g [^] (z + order \\<G> * w * c - w * c) =\n    \\<^bold>g [^] z \\<otimes> inv (h [^] c)", "then"], ["proof (chain)\npicking this:\n  w \\<noteq> 0", "show ?thesis"], ["proof (prove)\nusing this:\n  w \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^] (z + order \\<G> * w * c - w * c) =\n    \\<^bold>g [^] z \\<otimes> inv (h [^] c)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. w \\<noteq> 0 \\<Longrightarrow>\n    \\<^bold>g [^] (z + order \\<G> * w * c - w * c) =\n    \\<^bold>g [^] z \\<otimes> inv (h [^] c)", "have \"(z + order \\<G> * w * c - w * c) = (z + (order \\<G> * w * c- w * c))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z + order \\<G> * w * c - w * c = z + (order \\<G> * w * c - w * c)", "using z"], ["proof (prove)\nusing this:\n  z < order \\<G>\n\ngoal (1 subgoal):\n 1. z + order \\<G> * w * c - w * c = z + (order \\<G> * w * c - w * c)", "by (simp add: less_imp_le_nat mult_le_mono)"], ["proof (state)\nthis:\n  z + order \\<G> * w * c - w * c = z + (order \\<G> * w * c - w * c)\n\ngoal (1 subgoal):\n 1. w \\<noteq> 0 \\<Longrightarrow>\n    \\<^bold>g [^] (z + order \\<G> * w * c - w * c) =\n    \\<^bold>g [^] z \\<otimes> inv (h [^] c)", "then"], ["proof (chain)\npicking this:\n  z + order \\<G> * w * c - w * c = z + (order \\<G> * w * c - w * c)", "have lhs: \"?lhs = \\<^bold>g [^] z \\<otimes> \\<^bold>g [^] ((order \\<G>) * w *c - w*c)\""], ["proof (prove)\nusing this:\n  z + order \\<G> * w * c - w * c = z + (order \\<G> * w * c - w * c)\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^] (z + order \\<G> * w * c - w * c) =\n    \\<^bold>g [^] z \\<otimes> \\<^bold>g [^] (order \\<G> * w * c - w * c)", "by(simp add: nat_pow_mult)"], ["proof (state)\nthis:\n  \\<^bold>g [^] (z + order \\<G> * w * c - w * c) =\n  \\<^bold>g [^] z \\<otimes> \\<^bold>g [^] (order \\<G> * w * c - w * c)\n\ngoal (1 subgoal):\n 1. w \\<noteq> 0 \\<Longrightarrow>\n    \\<^bold>g [^] (z + order \\<G> * w * c - w * c) =\n    \\<^bold>g [^] z \\<otimes> inv (h [^] c)", "have \" \\<^bold>g [^] ((order \\<G>) * w *c - w*c) =  inv (h [^] c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<^bold>g [^] (order \\<G> * w * c - w * c) = inv (h [^] c)", "proof(cases \"c = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. c = 0 \\<Longrightarrow>\n    \\<^bold>g [^] (order \\<G> * w * c - w * c) = inv (h [^] c)\n 2. c \\<noteq> 0 \\<Longrightarrow>\n    \\<^bold>g [^] (order \\<G> * w * c - w * c) = inv (h [^] c)", "case True"], ["proof (state)\nthis:\n  c = 0\n\ngoal (2 subgoals):\n 1. c = 0 \\<Longrightarrow>\n    \\<^bold>g [^] (order \\<G> * w * c - w * c) = inv (h [^] c)\n 2. c \\<noteq> 0 \\<Longrightarrow>\n    \\<^bold>g [^] (order \\<G> * w * c - w * c) = inv (h [^] c)", "then"], ["proof (chain)\npicking this:\n  c = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  c = 0\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^] (order \\<G> * w * c - w * c) = inv (h [^] c)", "using lhs"], ["proof (prove)\nusing this:\n  c = 0\n  \\<^bold>g [^] (z + order \\<G> * w * c - w * c) =\n  \\<^bold>g [^] z \\<otimes> \\<^bold>g [^] (order \\<G> * w * c - w * c)\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^] (order \\<G> * w * c - w * c) = inv (h [^] c)", "by simp"], ["proof (state)\nthis:\n  \\<^bold>g [^] (order \\<G> * w * c - w * c) = inv (h [^] c)\n\ngoal (1 subgoal):\n 1. c \\<noteq> 0 \\<Longrightarrow>\n    \\<^bold>g [^] (order \\<G> * w * c - w * c) = inv (h [^] c)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. c \\<noteq> 0 \\<Longrightarrow>\n    \\<^bold>g [^] (order \\<G> * w * c - w * c) = inv (h [^] c)", "case False"], ["proof (state)\nthis:\n  c \\<noteq> 0\n\ngoal (1 subgoal):\n 1. c \\<noteq> 0 \\<Longrightarrow>\n    \\<^bold>g [^] (order \\<G> * w * c - w * c) = inv (h [^] c)", "hence *: \"((order \\<G>)*w *c - w*c) > 0\""], ["proof (prove)\nusing this:\n  c \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 < order \\<G> * w * c - w * c", "using assms w_gt_0"], ["proof (prove)\nusing this:\n  c \\<noteq> 0\n  h = \\<^bold>g [^] w\n  z < order \\<G>\n  w \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 < order \\<G> * w * c - w * c", "using gr0I mult_less_cancel2 n_less_m_mult_n numeral_nat(7) prime_gt_1_nat prime_order zero_less_diff"], ["proof (prove)\nusing this:\n  c \\<noteq> 0\n  h = \\<^bold>g [^] w\n  z < order \\<G>\n  w \\<noteq> 0\n  (?n = 0 \\<Longrightarrow> False) \\<Longrightarrow> 0 < ?n\n  (?m * ?k < ?n * ?k) = (0 < ?k \\<and> ?m < ?n)\n  \\<lbrakk>0 < ?n; Suc 0 < ?m\\<rbrakk> \\<Longrightarrow> ?n < ?m * ?n\n  1 = Suc 0\n  prime ?p \\<Longrightarrow> 1 < ?p\n  prime (order \\<G>)\n  (0 < ?n - ?m) = (?m < ?n)\n\ngoal (1 subgoal):\n 1. 0 < order \\<G> * w * c - w * c", "by presburger"], ["proof (state)\nthis:\n  0 < order \\<G> * w * c - w * c\n\ngoal (1 subgoal):\n 1. c \\<noteq> 0 \\<Longrightarrow>\n    \\<^bold>g [^] (order \\<G> * w * c - w * c) = inv (h [^] c)", "then"], ["proof (chain)\npicking this:\n  0 < order \\<G> * w * c - w * c", "have \" \\<^bold>g [^] ((order \\<G>)*w*c - w*c) =  \\<^bold>g [^] int ((order \\<G>)*w*c - w*c)\""], ["proof (prove)\nusing this:\n  0 < order \\<G> * w * c - w * c\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^] (order \\<G> * w * c - w * c) =\n    \\<^bold>g [^] int (order \\<G> * w * c - w * c)", "by (simp add: int_pow_int)"], ["proof (state)\nthis:\n  \\<^bold>g [^] (order \\<G> * w * c - w * c) =\n  \\<^bold>g [^] int (order \\<G> * w * c - w * c)\n\ngoal (1 subgoal):\n 1. c \\<noteq> 0 \\<Longrightarrow>\n    \\<^bold>g [^] (order \\<G> * w * c - w * c) = inv (h [^] c)", "also"], ["proof (state)\nthis:\n  \\<^bold>g [^] (order \\<G> * w * c - w * c) =\n  \\<^bold>g [^] int (order \\<G> * w * c - w * c)\n\ngoal (1 subgoal):\n 1. c \\<noteq> 0 \\<Longrightarrow>\n    \\<^bold>g [^] (order \\<G> * w * c - w * c) = inv (h [^] c)", "have \"... = \\<^bold>g [^] int ((order \\<G>)*w*c) \\<otimes> inv (\\<^bold>g [^] (w*c))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<^bold>g [^] int (order \\<G> * w * c - w * c) =\n    \\<^bold>g [^] int (order \\<G> * w * c) \\<otimes>\n    inv (\\<^bold>g [^] (w * c))", "using int_pow_diff[of \"\\<^bold>g\" \"order \\<G> * w * c\" \"w * c\"] * generator_closed int_ops(6) int_pow_neg int_pow_neg_int"], ["proof (prove)\nusing this:\n  \\<^bold>g \\<in> carrier \\<G> \\<Longrightarrow>\n  \\<^bold>g [^] (int (order \\<G> * w * c) - int (w * c)) =\n  \\<^bold>g [^] int (order \\<G> * w * c) \\<otimes>\n  inv (\\<^bold>g [^] int (w * c))\n  0 < order \\<G> * w * c - w * c\n  \\<^bold>g \\<in> carrier \\<G>\n  int (?a - ?b) = (if int ?a < int ?b then 0 else int ?a - int ?b)\n  ?x \\<in> carrier \\<G> \\<Longrightarrow> ?x [^] - ?i = inv (?x [^] ?i)\n  ?x \\<in> carrier \\<G> \\<Longrightarrow> ?x [^] - int ?n = inv (?x [^] ?n)\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^] int (order \\<G> * w * c - w * c) =\n    \\<^bold>g [^] int (order \\<G> * w * c) \\<otimes>\n    inv (\\<^bold>g [^] (w * c))", "by presburger"], ["proof (state)\nthis:\n  \\<^bold>g [^] int (order \\<G> * w * c - w * c) =\n  \\<^bold>g [^] int (order \\<G> * w * c) \\<otimes>\n  inv (\\<^bold>g [^] (w * c))\n\ngoal (1 subgoal):\n 1. c \\<noteq> 0 \\<Longrightarrow>\n    \\<^bold>g [^] (order \\<G> * w * c - w * c) = inv (h [^] c)", "also"], ["proof (state)\nthis:\n  \\<^bold>g [^] int (order \\<G> * w * c - w * c) =\n  \\<^bold>g [^] int (order \\<G> * w * c) \\<otimes>\n  inv (\\<^bold>g [^] (w * c))\n\ngoal (1 subgoal):\n 1. c \\<noteq> 0 \\<Longrightarrow>\n    \\<^bold>g [^] (order \\<G> * w * c - w * c) = inv (h [^] c)", "have \"... = \\<^bold>g [^] ((order \\<G>)*w*c) \\<otimes> inv (\\<^bold>g [^] (w*c))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<^bold>g [^] int (order \\<G> * w * c) \\<otimes>\n    inv (\\<^bold>g [^] (w * c)) =\n    \\<^bold>g [^] (order \\<G> * w * c) \\<otimes> inv (\\<^bold>g [^] (w * c))", "by (metis int_pow_int)"], ["proof (state)\nthis:\n  \\<^bold>g [^] int (order \\<G> * w * c) \\<otimes>\n  inv (\\<^bold>g [^] (w * c)) =\n  \\<^bold>g [^] (order \\<G> * w * c) \\<otimes> inv (\\<^bold>g [^] (w * c))\n\ngoal (1 subgoal):\n 1. c \\<noteq> 0 \\<Longrightarrow>\n    \\<^bold>g [^] (order \\<G> * w * c - w * c) = inv (h [^] c)", "also"], ["proof (state)\nthis:\n  \\<^bold>g [^] int (order \\<G> * w * c) \\<otimes>\n  inv (\\<^bold>g [^] (w * c)) =\n  \\<^bold>g [^] (order \\<G> * w * c) \\<otimes> inv (\\<^bold>g [^] (w * c))\n\ngoal (1 subgoal):\n 1. c \\<noteq> 0 \\<Longrightarrow>\n    \\<^bold>g [^] (order \\<G> * w * c - w * c) = inv (h [^] c)", "have \"... = \\<^bold>g [^] ((order \\<G>)*w*c) \\<otimes> inv ((\\<^bold>g [^] w) [^] c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<^bold>g [^] (order \\<G> * w * c) \\<otimes>\n    inv (\\<^bold>g [^] (w * c)) =\n    \\<^bold>g [^] (order \\<G> * w * c) \\<otimes>\n    inv ((\\<^bold>g [^] w) [^] c)", "by(simp add: nat_pow_pow)"], ["proof (state)\nthis:\n  \\<^bold>g [^] (order \\<G> * w * c) \\<otimes> inv (\\<^bold>g [^] (w * c)) =\n  \\<^bold>g [^] (order \\<G> * w * c) \\<otimes> inv ((\\<^bold>g [^] w) [^] c)\n\ngoal (1 subgoal):\n 1. c \\<noteq> 0 \\<Longrightarrow>\n    \\<^bold>g [^] (order \\<G> * w * c - w * c) = inv (h [^] c)", "also"], ["proof (state)\nthis:\n  \\<^bold>g [^] (order \\<G> * w * c) \\<otimes> inv (\\<^bold>g [^] (w * c)) =\n  \\<^bold>g [^] (order \\<G> * w * c) \\<otimes> inv ((\\<^bold>g [^] w) [^] c)\n\ngoal (1 subgoal):\n 1. c \\<noteq> 0 \\<Longrightarrow>\n    \\<^bold>g [^] (order \\<G> * w * c - w * c) = inv (h [^] c)", "have \"... = \\<^bold>g [^] ((order \\<G>)*w*c) \\<otimes> inv (h [^] c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<^bold>g [^] (order \\<G> * w * c) \\<otimes>\n    inv ((\\<^bold>g [^] w) [^] c) =\n    \\<^bold>g [^] (order \\<G> * w * c) \\<otimes> inv (h [^] c)", "using assms"], ["proof (prove)\nusing this:\n  h = \\<^bold>g [^] w\n  z < order \\<G>\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^] (order \\<G> * w * c) \\<otimes>\n    inv ((\\<^bold>g [^] w) [^] c) =\n    \\<^bold>g [^] (order \\<G> * w * c) \\<otimes> inv (h [^] c)", "by simp"], ["proof (state)\nthis:\n  \\<^bold>g [^] (order \\<G> * w * c) \\<otimes>\n  inv ((\\<^bold>g [^] w) [^] c) =\n  \\<^bold>g [^] (order \\<G> * w * c) \\<otimes> inv (h [^] c)\n\ngoal (1 subgoal):\n 1. c \\<noteq> 0 \\<Longrightarrow>\n    \\<^bold>g [^] (order \\<G> * w * c - w * c) = inv (h [^] c)", "also"], ["proof (state)\nthis:\n  \\<^bold>g [^] (order \\<G> * w * c) \\<otimes>\n  inv ((\\<^bold>g [^] w) [^] c) =\n  \\<^bold>g [^] (order \\<G> * w * c) \\<otimes> inv (h [^] c)\n\ngoal (1 subgoal):\n 1. c \\<noteq> 0 \\<Longrightarrow>\n    \\<^bold>g [^] (order \\<G> * w * c - w * c) = inv (h [^] c)", "have \"... = \\<one> \\<otimes> inv (h [^] c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<^bold>g [^] (order \\<G> * w * c) \\<otimes> inv (h [^] c) =\n    \\<one> \\<otimes> inv (h [^] c)", "using generator_pow_order"], ["proof (prove)\nusing this:\n  \\<^bold>g [^] order \\<G> = \\<one>\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^] (order \\<G> * w * c) \\<otimes> inv (h [^] c) =\n    \\<one> \\<otimes> inv (h [^] c)", "by (metis generator_closed mult_is_0 nat_pow_0 nat_pow_pow)"], ["proof (state)\nthis:\n  \\<^bold>g [^] (order \\<G> * w * c) \\<otimes> inv (h [^] c) =\n  \\<one> \\<otimes> inv (h [^] c)\n\ngoal (1 subgoal):\n 1. c \\<noteq> 0 \\<Longrightarrow>\n    \\<^bold>g [^] (order \\<G> * w * c - w * c) = inv (h [^] c)", "ultimately"], ["proof (chain)\npicking this:\n  \\<^bold>g [^] (order \\<G> * w * c - w * c) =\n  \\<^bold>g [^] (order \\<G> * w * c) \\<otimes> inv (h [^] c)\n  \\<^bold>g [^] (order \\<G> * w * c) \\<otimes> inv (h [^] c) =\n  \\<one> \\<otimes> inv (h [^] c)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<^bold>g [^] (order \\<G> * w * c - w * c) =\n  \\<^bold>g [^] (order \\<G> * w * c) \\<otimes> inv (h [^] c)\n  \\<^bold>g [^] (order \\<G> * w * c) \\<otimes> inv (h [^] c) =\n  \\<one> \\<otimes> inv (h [^] c)\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^] (order \\<G> * w * c - w * c) = inv (h [^] c)", "by (simp add: assms(1))"], ["proof (state)\nthis:\n  \\<^bold>g [^] (order \\<G> * w * c - w * c) = inv (h [^] c)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<^bold>g [^] (order \\<G> * w * c - w * c) = inv (h [^] c)\n\ngoal (1 subgoal):\n 1. w \\<noteq> 0 \\<Longrightarrow>\n    \\<^bold>g [^] (z + order \\<G> * w * c - w * c) =\n    \\<^bold>g [^] z \\<otimes> inv (h [^] c)", "then"], ["proof (chain)\npicking this:\n  \\<^bold>g [^] (order \\<G> * w * c - w * c) = inv (h [^] c)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<^bold>g [^] (order \\<G> * w * c - w * c) = inv (h [^] c)\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^] (z + order \\<G> * w * c - w * c) =\n    \\<^bold>g [^] z \\<otimes> inv (h [^] c)", "using lhs"], ["proof (prove)\nusing this:\n  \\<^bold>g [^] (order \\<G> * w * c - w * c) = inv (h [^] c)\n  \\<^bold>g [^] (z + order \\<G> * w * c - w * c) =\n  \\<^bold>g [^] z \\<otimes> \\<^bold>g [^] (order \\<G> * w * c - w * c)\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^] (z + order \\<G> * w * c - w * c) =\n    \\<^bold>g [^] z \\<otimes> inv (h [^] c)", "by simp"], ["proof (state)\nthis:\n  \\<^bold>g [^] (z + order \\<G> * w * c - w * c) =\n  \\<^bold>g [^] z \\<otimes> inv (h [^] c)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<^bold>g [^] (z + order \\<G> * w * c - w * c) =\n  \\<^bold>g [^] z \\<otimes> inv (h [^] c)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma hvzk_h_sub2_rewrite:\n  assumes  \"h' = g' [^] w\" \n    and z: \"z < order \\<G>\" \n  shows \"g' [^] ((z + (order \\<G>)*w*c - w*c))  = g' [^] z \\<otimes> inv (h' [^] c)\" \n    (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. g' [^] (z + order \\<G> * w * c - w * c) =\n    g' [^] z \\<otimes> inv (h' [^] c)", "proof(cases \"w = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. w = 0 \\<Longrightarrow>\n    g' [^] (z + order \\<G> * w * c - w * c) =\n    g' [^] z \\<otimes> inv (h' [^] c)\n 2. w \\<noteq> 0 \\<Longrightarrow>\n    g' [^] (z + order \\<G> * w * c - w * c) =\n    g' [^] z \\<otimes> inv (h' [^] c)", "case True"], ["proof (state)\nthis:\n  w = 0\n\ngoal (2 subgoals):\n 1. w = 0 \\<Longrightarrow>\n    g' [^] (z + order \\<G> * w * c - w * c) =\n    g' [^] z \\<otimes> inv (h' [^] c)\n 2. w \\<noteq> 0 \\<Longrightarrow>\n    g' [^] (z + order \\<G> * w * c - w * c) =\n    g' [^] z \\<otimes> inv (h' [^] c)", "then"], ["proof (chain)\npicking this:\n  w = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  w = 0\n\ngoal (1 subgoal):\n 1. g' [^] (z + order \\<G> * w * c - w * c) =\n    g' [^] z \\<otimes> inv (h' [^] c)", "using assms"], ["proof (prove)\nusing this:\n  w = 0\n  h' = g' [^] w\n  z < order \\<G>\n\ngoal (1 subgoal):\n 1. g' [^] (z + order \\<G> * w * c - w * c) =\n    g' [^] z \\<otimes> inv (h' [^] c)", "by (simp add: g'_def)"], ["proof (state)\nthis:\n  g' [^] (z + order \\<G> * w * c - w * c) =\n  g' [^] z \\<otimes> inv (h' [^] c)\n\ngoal (1 subgoal):\n 1. w \\<noteq> 0 \\<Longrightarrow>\n    g' [^] (z + order \\<G> * w * c - w * c) =\n    g' [^] z \\<otimes> inv (h' [^] c)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. w \\<noteq> 0 \\<Longrightarrow>\n    g' [^] (z + order \\<G> * w * c - w * c) =\n    g' [^] z \\<otimes> inv (h' [^] c)", "case w_gt_0: False"], ["proof (state)\nthis:\n  w \\<noteq> 0\n\ngoal (1 subgoal):\n 1. w \\<noteq> 0 \\<Longrightarrow>\n    g' [^] (z + order \\<G> * w * c - w * c) =\n    g' [^] z \\<otimes> inv (h' [^] c)", "then"], ["proof (chain)\npicking this:\n  w \\<noteq> 0", "show ?thesis"], ["proof (prove)\nusing this:\n  w \\<noteq> 0\n\ngoal (1 subgoal):\n 1. g' [^] (z + order \\<G> * w * c - w * c) =\n    g' [^] z \\<otimes> inv (h' [^] c)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. w \\<noteq> 0 \\<Longrightarrow>\n    g' [^] (z + order \\<G> * w * c - w * c) =\n    g' [^] z \\<otimes> inv (h' [^] c)", "have \"g' = \\<^bold>g [^] x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g' = \\<^bold>g [^] x", "using g'_def"], ["proof (prove)\nusing this:\n  g' = \\<^bold>g [^] x\n\ngoal (1 subgoal):\n 1. g' = \\<^bold>g [^] x", "by simp"], ["proof (state)\nthis:\n  g' = \\<^bold>g [^] x\n\ngoal (1 subgoal):\n 1. w \\<noteq> 0 \\<Longrightarrow>\n    g' [^] (z + order \\<G> * w * c - w * c) =\n    g' [^] z \\<otimes> inv (h' [^] c)", "have g'_carrier: \"g' \\<in> carrier \\<G>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g' \\<in> carrier \\<G>", "using g'_def"], ["proof (prove)\nusing this:\n  g' = \\<^bold>g [^] x\n\ngoal (1 subgoal):\n 1. g' \\<in> carrier \\<G>", "by simp"], ["proof (state)\nthis:\n  g' \\<in> carrier \\<G>\n\ngoal (1 subgoal):\n 1. w \\<noteq> 0 \\<Longrightarrow>\n    g' [^] (z + order \\<G> * w * c - w * c) =\n    g' [^] z \\<otimes> inv (h' [^] c)", "have 1: \"g' [^] ((order \\<G>)*w*c- w*c) = inv (h' [^] c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g' [^] (order \\<G> * w * c - w * c) = inv (h' [^] c)", "proof(cases \"c = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. c = 0 \\<Longrightarrow>\n    g' [^] (order \\<G> * w * c - w * c) = inv (h' [^] c)\n 2. c \\<noteq> 0 \\<Longrightarrow>\n    g' [^] (order \\<G> * w * c - w * c) = inv (h' [^] c)", "case True"], ["proof (state)\nthis:\n  c = 0\n\ngoal (2 subgoals):\n 1. c = 0 \\<Longrightarrow>\n    g' [^] (order \\<G> * w * c - w * c) = inv (h' [^] c)\n 2. c \\<noteq> 0 \\<Longrightarrow>\n    g' [^] (order \\<G> * w * c - w * c) = inv (h' [^] c)", "then"], ["proof (chain)\npicking this:\n  c = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  c = 0\n\ngoal (1 subgoal):\n 1. g' [^] (order \\<G> * w * c - w * c) = inv (h' [^] c)", "by simp"], ["proof (state)\nthis:\n  g' [^] (order \\<G> * w * c - w * c) = inv (h' [^] c)\n\ngoal (1 subgoal):\n 1. c \\<noteq> 0 \\<Longrightarrow>\n    g' [^] (order \\<G> * w * c - w * c) = inv (h' [^] c)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. c \\<noteq> 0 \\<Longrightarrow>\n    g' [^] (order \\<G> * w * c - w * c) = inv (h' [^] c)", "case False"], ["proof (state)\nthis:\n  c \\<noteq> 0\n\ngoal (1 subgoal):\n 1. c \\<noteq> 0 \\<Longrightarrow>\n    g' [^] (order \\<G> * w * c - w * c) = inv (h' [^] c)", "hence *: \"((order \\<G>)*w*c - w*c) > 0\""], ["proof (prove)\nusing this:\n  c \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 < order \\<G> * w * c - w * c", "using assms mult_strict_mono w_gt_0 prime_gt_1_nat prime_order"], ["proof (prove)\nusing this:\n  c \\<noteq> 0\n  h' = g' [^] w\n  z < order \\<G>\n  \\<lbrakk>?a < ?b; ?c < ?d; (0::?'a) < ?b; (0::?'a) \\<le> ?c\\<rbrakk>\n  \\<Longrightarrow> ?a * ?c < ?b * ?d\n  w \\<noteq> 0\n  prime ?p \\<Longrightarrow> 1 < ?p\n  prime (order \\<G>)\n\ngoal (1 subgoal):\n 1. 0 < order \\<G> * w * c - w * c", "by auto"], ["proof (state)\nthis:\n  0 < order \\<G> * w * c - w * c\n\ngoal (1 subgoal):\n 1. c \\<noteq> 0 \\<Longrightarrow>\n    g' [^] (order \\<G> * w * c - w * c) = inv (h' [^] c)", "then"], ["proof (chain)\npicking this:\n  0 < order \\<G> * w * c - w * c", "have \" g' [^] ((order \\<G>)*w*c - w*c) = g' [^] (int (order \\<G> * w * c) - int (w * c))\""], ["proof (prove)\nusing this:\n  0 < order \\<G> * w * c - w * c\n\ngoal (1 subgoal):\n 1. g' [^] (order \\<G> * w * c - w * c) =\n    g' [^] (int (order \\<G> * w * c) - int (w * c))", "by (metis int_ops(6) int_pow_int of_nat_0_less_iff order.irrefl)"], ["proof (state)\nthis:\n  g' [^] (order \\<G> * w * c - w * c) =\n  g' [^] (int (order \\<G> * w * c) - int (w * c))\n\ngoal (1 subgoal):\n 1. c \\<noteq> 0 \\<Longrightarrow>\n    g' [^] (order \\<G> * w * c - w * c) = inv (h' [^] c)", "also"], ["proof (state)\nthis:\n  g' [^] (order \\<G> * w * c - w * c) =\n  g' [^] (int (order \\<G> * w * c) - int (w * c))\n\ngoal (1 subgoal):\n 1. c \\<noteq> 0 \\<Longrightarrow>\n    g' [^] (order \\<G> * w * c - w * c) = inv (h' [^] c)", "have \"... = g' [^] ((order \\<G>)*w*c) \\<otimes> inv (g' [^] (w*c))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g' [^] (int (order \\<G> * w * c) - int (w * c)) =\n    g' [^] (order \\<G> * w * c) \\<otimes> inv (g' [^] (w * c))", "by (metis g'_carrier int_pow_diff int_pow_int)"], ["proof (state)\nthis:\n  g' [^] (int (order \\<G> * w * c) - int (w * c)) =\n  g' [^] (order \\<G> * w * c) \\<otimes> inv (g' [^] (w * c))\n\ngoal (1 subgoal):\n 1. c \\<noteq> 0 \\<Longrightarrow>\n    g' [^] (order \\<G> * w * c - w * c) = inv (h' [^] c)", "also"], ["proof (state)\nthis:\n  g' [^] (int (order \\<G> * w * c) - int (w * c)) =\n  g' [^] (order \\<G> * w * c) \\<otimes> inv (g' [^] (w * c))\n\ngoal (1 subgoal):\n 1. c \\<noteq> 0 \\<Longrightarrow>\n    g' [^] (order \\<G> * w * c - w * c) = inv (h' [^] c)", "have \"... = g' [^] ((order \\<G>)*w*c) \\<otimes> inv (h' [^] c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g' [^] (order \\<G> * w * c) \\<otimes> inv (g' [^] (w * c)) =\n    g' [^] (order \\<G> * w * c) \\<otimes> inv (h' [^] c)", "by(simp add: nat_pow_pow assms)"], ["proof (state)\nthis:\n  g' [^] (order \\<G> * w * c) \\<otimes> inv (g' [^] (w * c)) =\n  g' [^] (order \\<G> * w * c) \\<otimes> inv (h' [^] c)\n\ngoal (1 subgoal):\n 1. c \\<noteq> 0 \\<Longrightarrow>\n    g' [^] (order \\<G> * w * c - w * c) = inv (h' [^] c)", "also"], ["proof (state)\nthis:\n  g' [^] (order \\<G> * w * c) \\<otimes> inv (g' [^] (w * c)) =\n  g' [^] (order \\<G> * w * c) \\<otimes> inv (h' [^] c)\n\ngoal (1 subgoal):\n 1. c \\<noteq> 0 \\<Longrightarrow>\n    g' [^] (order \\<G> * w * c - w * c) = inv (h' [^] c)", "have \"... = \\<one> \\<otimes> inv (h' [^] c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g' [^] (order \\<G> * w * c) \\<otimes> inv (h' [^] c) =\n    \\<one> \\<otimes> inv (h' [^] c)", "by (metis g'_carrier nat_pow_one nat_pow_pow pow_order_eq_1)"], ["proof (state)\nthis:\n  g' [^] (order \\<G> * w * c) \\<otimes> inv (h' [^] c) =\n  \\<one> \\<otimes> inv (h' [^] c)\n\ngoal (1 subgoal):\n 1. c \\<noteq> 0 \\<Longrightarrow>\n    g' [^] (order \\<G> * w * c - w * c) = inv (h' [^] c)", "ultimately"], ["proof (chain)\npicking this:\n  g' [^] (order \\<G> * w * c - w * c) =\n  g' [^] (order \\<G> * w * c) \\<otimes> inv (h' [^] c)\n  g' [^] (order \\<G> * w * c) \\<otimes> inv (h' [^] c) =\n  \\<one> \\<otimes> inv (h' [^] c)", "show ?thesis"], ["proof (prove)\nusing this:\n  g' [^] (order \\<G> * w * c - w * c) =\n  g' [^] (order \\<G> * w * c) \\<otimes> inv (h' [^] c)\n  g' [^] (order \\<G> * w * c) \\<otimes> inv (h' [^] c) =\n  \\<one> \\<otimes> inv (h' [^] c)\n\ngoal (1 subgoal):\n 1. g' [^] (order \\<G> * w * c - w * c) = inv (h' [^] c)", "by (simp add: assms(1))"], ["proof (state)\nthis:\n  g' [^] (order \\<G> * w * c - w * c) = inv (h' [^] c)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  g' [^] (order \\<G> * w * c - w * c) = inv (h' [^] c)\n\ngoal (1 subgoal):\n 1. w \\<noteq> 0 \\<Longrightarrow>\n    g' [^] (z + order \\<G> * w * c - w * c) =\n    g' [^] z \\<otimes> inv (h' [^] c)", "have \"(z + order \\<G> * w * c - w * c) = (z + (order \\<G> * w * c - w * c))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z + order \\<G> * w * c - w * c = z + (order \\<G> * w * c - w * c)", "using z"], ["proof (prove)\nusing this:\n  z < order \\<G>\n\ngoal (1 subgoal):\n 1. z + order \\<G> * w * c - w * c = z + (order \\<G> * w * c - w * c)", "by (simp add: less_imp_le_nat mult_le_mono)"], ["proof (state)\nthis:\n  z + order \\<G> * w * c - w * c = z + (order \\<G> * w * c - w * c)\n\ngoal (1 subgoal):\n 1. w \\<noteq> 0 \\<Longrightarrow>\n    g' [^] (z + order \\<G> * w * c - w * c) =\n    g' [^] z \\<otimes> inv (h' [^] c)", "then"], ["proof (chain)\npicking this:\n  z + order \\<G> * w * c - w * c = z + (order \\<G> * w * c - w * c)", "have lhs: \"?lhs = g' [^] z \\<otimes> g' [^] ((order \\<G>)*w*c - w*c)\""], ["proof (prove)\nusing this:\n  z + order \\<G> * w * c - w * c = z + (order \\<G> * w * c - w * c)\n\ngoal (1 subgoal):\n 1. g' [^] (z + order \\<G> * w * c - w * c) =\n    g' [^] z \\<otimes> g' [^] (order \\<G> * w * c - w * c)", "by(auto simp add: nat_pow_mult)"], ["proof (state)\nthis:\n  g' [^] (z + order \\<G> * w * c - w * c) =\n  g' [^] z \\<otimes> g' [^] (order \\<G> * w * c - w * c)\n\ngoal (1 subgoal):\n 1. w \\<noteq> 0 \\<Longrightarrow>\n    g' [^] (z + order \\<G> * w * c - w * c) =\n    g' [^] z \\<otimes> inv (h' [^] c)", "then"], ["proof (chain)\npicking this:\n  g' [^] (z + order \\<G> * w * c - w * c) =\n  g' [^] z \\<otimes> g' [^] (order \\<G> * w * c - w * c)", "show ?thesis"], ["proof (prove)\nusing this:\n  g' [^] (z + order \\<G> * w * c - w * c) =\n  g' [^] z \\<otimes> g' [^] (order \\<G> * w * c - w * c)\n\ngoal (1 subgoal):\n 1. g' [^] (z + order \\<G> * w * c - w * c) =\n    g' [^] z \\<otimes> inv (h' [^] c)", "using 1"], ["proof (prove)\nusing this:\n  g' [^] (z + order \\<G> * w * c - w * c) =\n  g' [^] z \\<otimes> g' [^] (order \\<G> * w * c - w * c)\n  g' [^] (order \\<G> * w * c - w * c) = inv (h' [^] c)\n\ngoal (1 subgoal):\n 1. g' [^] (z + order \\<G> * w * c - w * c) =\n    g' [^] z \\<otimes> inv (h' [^] c)", "by simp"], ["proof (state)\nthis:\n  g' [^] (z + order \\<G> * w * c - w * c) =\n  g' [^] z \\<otimes> inv (h' [^] c)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  g' [^] (z + order \\<G> * w * c - w * c) =\n  g' [^] z \\<otimes> inv (h' [^] c)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma hv_zk2:\n  assumes \"(H, w) \\<in> R\" \n  shows \"chaum_ped_sigma.R H w c = chaum_ped_sigma.S H c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. chaum_ped_sigma.R H w c = chaum_ped_sigma.S H c", "including monad_normalisation"], ["proof (prove)\ngoal (1 subgoal):\n 1. chaum_ped_sigma.R H w c = chaum_ped_sigma.S H c", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. chaum_ped_sigma.R H w c = chaum_ped_sigma.S H c", "have H: \"H = (\\<^bold>g [^] (w::nat), g' [^] w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. H = (\\<^bold>g [^] w, g' [^] w)", "using assms R_def"], ["proof (prove)\nusing this:\n  (H, w) \\<in> R\n  R = {(h, w). fst h = \\<^bold>g [^] w \\<and> snd h = g' [^] w}\n\ngoal (1 subgoal):\n 1. H = (\\<^bold>g [^] w, g' [^] w)", "by(simp add: prod.expand)"], ["proof (state)\nthis:\n  H = (\\<^bold>g [^] w, g' [^] w)\n\ngoal (1 subgoal):\n 1. chaum_ped_sigma.R H w c = chaum_ped_sigma.S H c", "have g'_carrier: \"g' \\<in> carrier \\<G>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g' \\<in> carrier \\<G>", "using g'_def"], ["proof (prove)\nusing this:\n  g' = \\<^bold>g [^] x\n\ngoal (1 subgoal):\n 1. g' \\<in> carrier \\<G>", "by simp"], ["proof (state)\nthis:\n  g' \\<in> carrier \\<G>\n\ngoal (1 subgoal):\n 1. chaum_ped_sigma.R H w c = chaum_ped_sigma.S H c", "have \"chaum_ped_sigma.R H w c  = do {\n    let (h, h') = H;\n    r \\<leftarrow> sample_uniform (order \\<G>);\n    let z = (w*c + r) mod (order \\<G>);\n    let a = \\<^bold>g [^] ((z + (order \\<G>) * w*c - w*c) mod (order \\<G>)); \n    let a' = g' [^] ((z + (order \\<G>) * w*c - w*c) mod (order \\<G>));\n    return_spmf ((a,a'),c, z)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. chaum_ped_sigma.R H w c =\n    (let (h, h') = H\n     in sample_uniform (order \\<G>) \\<bind>\n        (\\<lambda>r.\n            let z = (w * c + r) mod order \\<G>;\n                a = \\<^bold>g [^]\n                    ((z + order \\<G> * w * c - w * c) mod order \\<G>);\n                a' = g' [^]\n                     ((z + order \\<G> * w * c - w * c) mod order \\<G>)\n            in return_spmf ((a, a'), c, z)))", "apply(simp add: chaum_ped_sigma.R_def Let_def response_def split_def init_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. sample_uniform (order \\<G>) \\<bind>\n    (\\<lambda>y.\n        return_spmf\n         ((\\<^bold>g [^] y, g' [^] y), c, (w * c + y) mod order \\<G>)) =\n    sample_uniform (order \\<G>) \\<bind>\n    (\\<lambda>r.\n        return_spmf\n         ((\\<^bold>g [^]\n           (((w * c + r) mod order \\<G> + order \\<G> * w * c - w * c) mod\n            order \\<G>),\n           g' [^]\n           (((w * c + r) mod order \\<G> + order \\<G> * w * c - w * c) mod\n            order \\<G>)),\n          c, (w * c + r) mod order \\<G>))", "using assms hvzk_xr'_rewrite"], ["proof (prove)\nusing this:\n  (H, w) \\<in> R\n  ?r < order \\<G> \\<Longrightarrow>\n  ((?w * ?c + ?r) mod order \\<G> mod order \\<G> + order \\<G> * ?w * ?c -\n   ?w * ?c) mod\n  order \\<G> =\n  ?r\n\ngoal (1 subgoal):\n 1. sample_uniform (order \\<G>) \\<bind>\n    (\\<lambda>y.\n        return_spmf\n         ((\\<^bold>g [^] y, g' [^] y), c, (w * c + y) mod order \\<G>)) =\n    sample_uniform (order \\<G>) \\<bind>\n    (\\<lambda>r.\n        return_spmf\n         ((\\<^bold>g [^]\n           (((w * c + r) mod order \\<G> + order \\<G> * w * c - w * c) mod\n            order \\<G>),\n           g' [^]\n           (((w * c + r) mod order \\<G> + order \\<G> * w * c - w * c) mod\n            order \\<G>)),\n          c, (w * c + r) mod order \\<G>))", "by(simp cong: bind_spmf_cong_simp)"], ["proof (state)\nthis:\n  chaum_ped_sigma.R H w c =\n  (let (h, h') = H\n   in sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>r.\n          let z = (w * c + r) mod order \\<G>;\n              a = \\<^bold>g [^]\n                  ((z + order \\<G> * w * c - w * c) mod order \\<G>);\n              a' = g' [^] ((z + order \\<G> * w * c - w * c) mod order \\<G>)\n          in return_spmf ((a, a'), c, z)))\n\ngoal (1 subgoal):\n 1. chaum_ped_sigma.R H w c = chaum_ped_sigma.S H c", "also"], ["proof (state)\nthis:\n  chaum_ped_sigma.R H w c =\n  (let (h, h') = H\n   in sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>r.\n          let z = (w * c + r) mod order \\<G>;\n              a = \\<^bold>g [^]\n                  ((z + order \\<G> * w * c - w * c) mod order \\<G>);\n              a' = g' [^] ((z + order \\<G> * w * c - w * c) mod order \\<G>)\n          in return_spmf ((a, a'), c, z)))\n\ngoal (1 subgoal):\n 1. chaum_ped_sigma.R H w c = chaum_ped_sigma.S H c", "have \"... = do {\n    let (h, h') = H;\n    z \\<leftarrow> map_spmf (\\<lambda> r. (w*c + r) mod (order \\<G>)) (sample_uniform (order \\<G>));\n    let a = \\<^bold>g [^] ((z + (order \\<G>) * w*c - w*c) mod (order \\<G>)); \n    let a' = g' [^] ((z + (order \\<G>) * w*c - w*c) mod (order \\<G>));\n    return_spmf ((a,a'),c, z)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (let (h, h') = H\n     in sample_uniform (order \\<G>) \\<bind>\n        (\\<lambda>r.\n            let z = (w * c + r) mod order \\<G>;\n                a = \\<^bold>g [^]\n                    ((z + order \\<G> * w * c - w * c) mod order \\<G>);\n                a' = g' [^]\n                     ((z + order \\<G> * w * c - w * c) mod order \\<G>)\n            in return_spmf ((a, a'), c, z))) =\n    (let (h, h') = H\n     in map_spmf (\\<lambda>r. (w * c + r) mod order \\<G>)\n         (sample_uniform (order \\<G>)) \\<bind>\n        (\\<lambda>z.\n            let a = \\<^bold>g [^]\n                    ((z + order \\<G> * w * c - w * c) mod order \\<G>);\n                a' = g' [^]\n                     ((z + order \\<G> * w * c - w * c) mod order \\<G>)\n            in return_spmf ((a, a'), c, z)))", "by(simp add: bind_map_spmf Let_def o_def)"], ["proof (state)\nthis:\n  (let (h, h') = H\n   in sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>r.\n          let z = (w * c + r) mod order \\<G>;\n              a = \\<^bold>g [^]\n                  ((z + order \\<G> * w * c - w * c) mod order \\<G>);\n              a' = g' [^] ((z + order \\<G> * w * c - w * c) mod order \\<G>)\n          in return_spmf ((a, a'), c, z))) =\n  (let (h, h') = H\n   in map_spmf (\\<lambda>r. (w * c + r) mod order \\<G>)\n       (sample_uniform (order \\<G>)) \\<bind>\n      (\\<lambda>z.\n          let a = \\<^bold>g [^]\n                  ((z + order \\<G> * w * c - w * c) mod order \\<G>);\n              a' = g' [^] ((z + order \\<G> * w * c - w * c) mod order \\<G>)\n          in return_spmf ((a, a'), c, z)))\n\ngoal (1 subgoal):\n 1. chaum_ped_sigma.R H w c = chaum_ped_sigma.S H c", "also"], ["proof (state)\nthis:\n  (let (h, h') = H\n   in sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>r.\n          let z = (w * c + r) mod order \\<G>;\n              a = \\<^bold>g [^]\n                  ((z + order \\<G> * w * c - w * c) mod order \\<G>);\n              a' = g' [^] ((z + order \\<G> * w * c - w * c) mod order \\<G>)\n          in return_spmf ((a, a'), c, z))) =\n  (let (h, h') = H\n   in map_spmf (\\<lambda>r. (w * c + r) mod order \\<G>)\n       (sample_uniform (order \\<G>)) \\<bind>\n      (\\<lambda>z.\n          let a = \\<^bold>g [^]\n                  ((z + order \\<G> * w * c - w * c) mod order \\<G>);\n              a' = g' [^] ((z + order \\<G> * w * c - w * c) mod order \\<G>)\n          in return_spmf ((a, a'), c, z)))\n\ngoal (1 subgoal):\n 1. chaum_ped_sigma.R H w c = chaum_ped_sigma.S H c", "have \"... = do {\n    let (h, h') = H;\n    z \\<leftarrow> (sample_uniform (order \\<G>));\n    let a = \\<^bold>g [^] ((z + (order \\<G>) * w*c - w*c) mod (order \\<G>)); \n    let a' = g' [^] ((z + (order \\<G>) * w*c - w*c) mod (order \\<G>));\n    return_spmf ((a,a'),c, z)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (let (h, h') = H\n     in map_spmf (\\<lambda>r. (w * c + r) mod order \\<G>)\n         (sample_uniform (order \\<G>)) \\<bind>\n        (\\<lambda>z.\n            let a = \\<^bold>g [^]\n                    ((z + order \\<G> * w * c - w * c) mod order \\<G>);\n                a' = g' [^]\n                     ((z + order \\<G> * w * c - w * c) mod order \\<G>)\n            in return_spmf ((a, a'), c, z))) =\n    (let (h, h') = H\n     in sample_uniform (order \\<G>) \\<bind>\n        (\\<lambda>z.\n            let a = \\<^bold>g [^]\n                    ((z + order \\<G> * w * c - w * c) mod order \\<G>);\n                a' = g' [^]\n                     ((z + order \\<G> * w * c - w * c) mod order \\<G>)\n            in return_spmf ((a, a'), c, z)))", "by(simp add: samp_uni_plus_one_time_pad)"], ["proof (state)\nthis:\n  (let (h, h') = H\n   in map_spmf (\\<lambda>r. (w * c + r) mod order \\<G>)\n       (sample_uniform (order \\<G>)) \\<bind>\n      (\\<lambda>z.\n          let a = \\<^bold>g [^]\n                  ((z + order \\<G> * w * c - w * c) mod order \\<G>);\n              a' = g' [^] ((z + order \\<G> * w * c - w * c) mod order \\<G>)\n          in return_spmf ((a, a'), c, z))) =\n  (let (h, h') = H\n   in sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>z.\n          let a = \\<^bold>g [^]\n                  ((z + order \\<G> * w * c - w * c) mod order \\<G>);\n              a' = g' [^] ((z + order \\<G> * w * c - w * c) mod order \\<G>)\n          in return_spmf ((a, a'), c, z)))\n\ngoal (1 subgoal):\n 1. chaum_ped_sigma.R H w c = chaum_ped_sigma.S H c", "also"], ["proof (state)\nthis:\n  (let (h, h') = H\n   in map_spmf (\\<lambda>r. (w * c + r) mod order \\<G>)\n       (sample_uniform (order \\<G>)) \\<bind>\n      (\\<lambda>z.\n          let a = \\<^bold>g [^]\n                  ((z + order \\<G> * w * c - w * c) mod order \\<G>);\n              a' = g' [^] ((z + order \\<G> * w * c - w * c) mod order \\<G>)\n          in return_spmf ((a, a'), c, z))) =\n  (let (h, h') = H\n   in sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>z.\n          let a = \\<^bold>g [^]\n                  ((z + order \\<G> * w * c - w * c) mod order \\<G>);\n              a' = g' [^] ((z + order \\<G> * w * c - w * c) mod order \\<G>)\n          in return_spmf ((a, a'), c, z)))\n\ngoal (1 subgoal):\n 1. chaum_ped_sigma.R H w c = chaum_ped_sigma.S H c", "have \"... = do {\n    let (h, h') = H;\n    z \\<leftarrow> (sample_uniform (order \\<G>));\n    let a = \\<^bold>g [^] z \\<otimes> inv (h [^] c); \n    let a' = g' [^] ((z + (order \\<G>) * w*c - w*c) mod (order \\<G>));\n    return_spmf ((a,a'),c, z)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (let (h, h') = H\n     in sample_uniform (order \\<G>) \\<bind>\n        (\\<lambda>z.\n            let a = \\<^bold>g [^]\n                    ((z + order \\<G> * w * c - w * c) mod order \\<G>);\n                a' = g' [^]\n                     ((z + order \\<G> * w * c - w * c) mod order \\<G>)\n            in return_spmf ((a, a'), c, z))) =\n    (let (h, h') = H\n     in sample_uniform (order \\<G>) \\<bind>\n        (\\<lambda>z.\n            let a = \\<^bold>g [^] z \\<otimes> inv (h [^] c);\n                a' = g' [^]\n                     ((z + order \\<G> * w * c - w * c) mod order \\<G>)\n            in return_spmf ((a, a'), c, z)))", "using hvzk_h_sub_rewrite assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>?h = \\<^bold>g [^] ?w; ?z < order \\<G>\\<rbrakk>\n  \\<Longrightarrow> \\<^bold>g [^] (?z + order \\<G> * ?w * ?c - ?w * ?c) =\n                    \\<^bold>g [^] ?z \\<otimes> inv (?h [^] ?c)\n  (H, w) \\<in> R\n\ngoal (1 subgoal):\n 1. (let (h, h') = H\n     in sample_uniform (order \\<G>) \\<bind>\n        (\\<lambda>z.\n            let a = \\<^bold>g [^]\n                    ((z + order \\<G> * w * c - w * c) mod order \\<G>);\n                a' = g' [^]\n                     ((z + order \\<G> * w * c - w * c) mod order \\<G>)\n            in return_spmf ((a, a'), c, z))) =\n    (let (h, h') = H\n     in sample_uniform (order \\<G>) \\<bind>\n        (\\<lambda>z.\n            let a = \\<^bold>g [^] z \\<otimes> inv (h [^] c);\n                a' = g' [^]\n                     ((z + order \\<G> * w * c - w * c) mod order \\<G>)\n            in return_spmf ((a, a'), c, z)))", "apply(simp add: Let_def H)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>h w z c.\n                \\<lbrakk>h = \\<^bold>g [^] w; z < order \\<G>\\<rbrakk>\n                \\<Longrightarrow> \\<^bold>g [^]\n                                  (z + order \\<G> * w * c - w * c) =\n                                  \\<^bold>g [^] z \\<otimes>\n                                  inv ((\\<^bold>g [^] w) [^] c);\n     ((\\<^bold>g [^] w, g' [^] w), w) \\<in> R\\<rbrakk>\n    \\<Longrightarrow> sample_uniform (order \\<G>) \\<bind>\n                      (\\<lambda>z.\n                          return_spmf\n                           ((\\<^bold>g [^]\n                             ((z + order \\<G> * w * c - w * c) mod\n                              order \\<G>),\n                             g' [^]\n                             ((z + order \\<G> * w * c - w * c) mod\n                              order \\<G>)),\n                            c, z)) =\n                      sample_uniform (order \\<G>) \\<bind>\n                      (\\<lambda>z.\n                          return_spmf\n                           ((\\<^bold>g [^] z \\<otimes>\n                             inv ((\\<^bold>g [^] w) [^] c),\n                             g' [^]\n                             ((z + order \\<G> * w * c - w * c) mod\n                              order \\<G>)),\n                            c, z))", "apply(intro bind_spmf_cong[OF refl]; clarsimp?)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>h w z c.\n                   \\<lbrakk>h = \\<^bold>g [^] w; z < order \\<G>\\<rbrakk>\n                   \\<Longrightarrow> \\<^bold>g [^]\n                                     (z + order \\<G> * w * c - w * c) =\n                                     \\<^bold>g [^] z \\<otimes>\n                                     inv ((\\<^bold>g [^] w) [^] c);\n        ((\\<^bold>g [^] w, g' [^] w), w) \\<in> R; x < order \\<G>\\<rbrakk>\n       \\<Longrightarrow> \\<^bold>g [^]\n                         ((x + order \\<G> * w * c - w * c) mod order \\<G>) =\n                         \\<^bold>g [^] x \\<otimes>\n                         inv ((\\<^bold>g [^] w) [^] c)", "by (simp add: pow_generator_mod)"], ["proof (state)\nthis:\n  (let (h, h') = H\n   in sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>z.\n          let a = \\<^bold>g [^]\n                  ((z + order \\<G> * w * c - w * c) mod order \\<G>);\n              a' = g' [^] ((z + order \\<G> * w * c - w * c) mod order \\<G>)\n          in return_spmf ((a, a'), c, z))) =\n  (let (h, h') = H\n   in sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>z.\n          let a = \\<^bold>g [^] z \\<otimes> inv (h [^] c);\n              a' = g' [^] ((z + order \\<G> * w * c - w * c) mod order \\<G>)\n          in return_spmf ((a, a'), c, z)))\n\ngoal (1 subgoal):\n 1. chaum_ped_sigma.R H w c = chaum_ped_sigma.S H c", "also"], ["proof (state)\nthis:\n  (let (h, h') = H\n   in sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>z.\n          let a = \\<^bold>g [^]\n                  ((z + order \\<G> * w * c - w * c) mod order \\<G>);\n              a' = g' [^] ((z + order \\<G> * w * c - w * c) mod order \\<G>)\n          in return_spmf ((a, a'), c, z))) =\n  (let (h, h') = H\n   in sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>z.\n          let a = \\<^bold>g [^] z \\<otimes> inv (h [^] c);\n              a' = g' [^] ((z + order \\<G> * w * c - w * c) mod order \\<G>)\n          in return_spmf ((a, a'), c, z)))\n\ngoal (1 subgoal):\n 1. chaum_ped_sigma.R H w c = chaum_ped_sigma.S H c", "have \"... = do {\n    let (h, h') = H;\n    z \\<leftarrow> (sample_uniform (order \\<G>));\n    let a = \\<^bold>g [^] z \\<otimes> inv (h [^] c); \n    let a' = g' [^] ((z + (order \\<G>)*w*c - w*c));\n    return_spmf ((a,a'),c, z)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (let (h, h') = H\n     in sample_uniform (order \\<G>) \\<bind>\n        (\\<lambda>z.\n            let a = \\<^bold>g [^] z \\<otimes> inv (h [^] c);\n                a' = g' [^]\n                     ((z + order \\<G> * w * c - w * c) mod order \\<G>)\n            in return_spmf ((a, a'), c, z))) =\n    (let (h, h') = H\n     in sample_uniform (order \\<G>) \\<bind>\n        (\\<lambda>z.\n            let a = \\<^bold>g [^] z \\<otimes> inv (h [^] c);\n                a' = g' [^] (z + order \\<G> * w * c - w * c)\n            in return_spmf ((a, a'), c, z)))", "using g'_carrier pow_carrier_mod[of \"g'\"]"], ["proof (prove)\nusing this:\n  g' \\<in> carrier \\<G>\n  g' \\<in> carrier \\<G> \\<Longrightarrow>\n  g' [^] (?k mod order \\<G>) = g' [^] ?k\n\ngoal (1 subgoal):\n 1. (let (h, h') = H\n     in sample_uniform (order \\<G>) \\<bind>\n        (\\<lambda>z.\n            let a = \\<^bold>g [^] z \\<otimes> inv (h [^] c);\n                a' = g' [^]\n                     ((z + order \\<G> * w * c - w * c) mod order \\<G>)\n            in return_spmf ((a, a'), c, z))) =\n    (let (h, h') = H\n     in sample_uniform (order \\<G>) \\<bind>\n        (\\<lambda>z.\n            let a = \\<^bold>g [^] z \\<otimes> inv (h [^] c);\n                a' = g' [^] (z + order \\<G> * w * c - w * c)\n            in return_spmf ((a, a'), c, z)))", "by simp"], ["proof (state)\nthis:\n  (let (h, h') = H\n   in sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>z.\n          let a = \\<^bold>g [^] z \\<otimes> inv (h [^] c);\n              a' = g' [^] ((z + order \\<G> * w * c - w * c) mod order \\<G>)\n          in return_spmf ((a, a'), c, z))) =\n  (let (h, h') = H\n   in sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>z.\n          let a = \\<^bold>g [^] z \\<otimes> inv (h [^] c);\n              a' = g' [^] (z + order \\<G> * w * c - w * c)\n          in return_spmf ((a, a'), c, z)))\n\ngoal (1 subgoal):\n 1. chaum_ped_sigma.R H w c = chaum_ped_sigma.S H c", "also"], ["proof (state)\nthis:\n  (let (h, h') = H\n   in sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>z.\n          let a = \\<^bold>g [^] z \\<otimes> inv (h [^] c);\n              a' = g' [^] ((z + order \\<G> * w * c - w * c) mod order \\<G>)\n          in return_spmf ((a, a'), c, z))) =\n  (let (h, h') = H\n   in sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>z.\n          let a = \\<^bold>g [^] z \\<otimes> inv (h [^] c);\n              a' = g' [^] (z + order \\<G> * w * c - w * c)\n          in return_spmf ((a, a'), c, z)))\n\ngoal (1 subgoal):\n 1. chaum_ped_sigma.R H w c = chaum_ped_sigma.S H c", "have \"... = do {\n    let (h, h') = H;\n    z \\<leftarrow> (sample_uniform (order \\<G>));\n    let a = \\<^bold>g [^] z \\<otimes> inv (h [^] c); \n    let a' =  g' [^] z \\<otimes> inv (h' [^] c);\n    return_spmf ((a,a'),c, z)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (let (h, h') = H\n     in sample_uniform (order \\<G>) \\<bind>\n        (\\<lambda>z.\n            let a = \\<^bold>g [^] z \\<otimes> inv (h [^] c);\n                a' = g' [^] (z + order \\<G> * w * c - w * c)\n            in return_spmf ((a, a'), c, z))) =\n    (let (h, h') = H\n     in sample_uniform (order \\<G>) \\<bind>\n        (\\<lambda>z.\n            let a = \\<^bold>g [^] z \\<otimes> inv (h [^] c);\n                a' = g' [^] z \\<otimes> inv (h' [^] c)\n            in return_spmf ((a, a'), c, z)))", "using hvzk_h_sub2_rewrite assms H"], ["proof (prove)\nusing this:\n  \\<lbrakk>?h' = g' [^] ?w; ?z < order \\<G>\\<rbrakk>\n  \\<Longrightarrow> g' [^] (?z + order \\<G> * ?w * ?c - ?w * ?c) =\n                    g' [^] ?z \\<otimes> inv (?h' [^] ?c)\n  (H, w) \\<in> R\n  H = (\\<^bold>g [^] w, g' [^] w)\n\ngoal (1 subgoal):\n 1. (let (h, h') = H\n     in sample_uniform (order \\<G>) \\<bind>\n        (\\<lambda>z.\n            let a = \\<^bold>g [^] z \\<otimes> inv (h [^] c);\n                a' = g' [^] (z + order \\<G> * w * c - w * c)\n            in return_spmf ((a, a'), c, z))) =\n    (let (h, h') = H\n     in sample_uniform (order \\<G>) \\<bind>\n        (\\<lambda>z.\n            let a = \\<^bold>g [^] z \\<otimes> inv (h [^] c);\n                a' = g' [^] z \\<otimes> inv (h' [^] c)\n            in return_spmf ((a, a'), c, z)))", "by(simp cong: bind_spmf_cong_simp)"], ["proof (state)\nthis:\n  (let (h, h') = H\n   in sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>z.\n          let a = \\<^bold>g [^] z \\<otimes> inv (h [^] c);\n              a' = g' [^] (z + order \\<G> * w * c - w * c)\n          in return_spmf ((a, a'), c, z))) =\n  (let (h, h') = H\n   in sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>z.\n          let a = \\<^bold>g [^] z \\<otimes> inv (h [^] c);\n              a' = g' [^] z \\<otimes> inv (h' [^] c)\n          in return_spmf ((a, a'), c, z)))\n\ngoal (1 subgoal):\n 1. chaum_ped_sigma.R H w c = chaum_ped_sigma.S H c", "ultimately"], ["proof (chain)\npicking this:\n  chaum_ped_sigma.R H w c =\n  (let (h, h') = H\n   in sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>z.\n          let a = \\<^bold>g [^] z \\<otimes> inv (h [^] c);\n              a' = g' [^] (z + order \\<G> * w * c - w * c)\n          in return_spmf ((a, a'), c, z)))\n  (let (h, h') = H\n   in sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>z.\n          let a = \\<^bold>g [^] z \\<otimes> inv (h [^] c);\n              a' = g' [^] (z + order \\<G> * w * c - w * c)\n          in return_spmf ((a, a'), c, z))) =\n  (let (h, h') = H\n   in sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>z.\n          let a = \\<^bold>g [^] z \\<otimes> inv (h [^] c);\n              a' = g' [^] z \\<otimes> inv (h' [^] c)\n          in return_spmf ((a, a'), c, z)))", "show ?thesis"], ["proof (prove)\nusing this:\n  chaum_ped_sigma.R H w c =\n  (let (h, h') = H\n   in sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>z.\n          let a = \\<^bold>g [^] z \\<otimes> inv (h [^] c);\n              a' = g' [^] (z + order \\<G> * w * c - w * c)\n          in return_spmf ((a, a'), c, z)))\n  (let (h, h') = H\n   in sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>z.\n          let a = \\<^bold>g [^] z \\<otimes> inv (h [^] c);\n              a' = g' [^] (z + order \\<G> * w * c - w * c)\n          in return_spmf ((a, a'), c, z))) =\n  (let (h, h') = H\n   in sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>z.\n          let a = \\<^bold>g [^] z \\<otimes> inv (h [^] c);\n              a' = g' [^] z \\<otimes> inv (h' [^] c)\n          in return_spmf ((a, a'), c, z)))\n\ngoal (1 subgoal):\n 1. chaum_ped_sigma.R H w c = chaum_ped_sigma.S H c", "unfolding chaum_ped_sigma.S_def chaum_ped_sigma.R_def"], ["proof (prove)\nusing this:\n  init H w \\<bind>\n  (\\<lambda>(r, a).\n      response r w c \\<bind> (\\<lambda>z. return_spmf (a, c, z))) =\n  (let (h, h') = H\n   in sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>z.\n          let a = \\<^bold>g [^] z \\<otimes> inv (h [^] c);\n              a' = g' [^] (z + order \\<G> * w * c - w * c)\n          in return_spmf ((a, a'), c, z)))\n  (let (h, h') = H\n   in sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>z.\n          let a = \\<^bold>g [^] z \\<otimes> inv (h [^] c);\n              a' = g' [^] (z + order \\<G> * w * c - w * c)\n          in return_spmf ((a, a'), c, z))) =\n  (let (h, h') = H\n   in sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>z.\n          let a = \\<^bold>g [^] z \\<otimes> inv (h [^] c);\n              a' = g' [^] z \\<otimes> inv (h' [^] c)\n          in return_spmf ((a, a'), c, z)))\n\ngoal (1 subgoal):\n 1. init H w \\<bind>\n    (\\<lambda>(r, a).\n        response r w c \\<bind> (\\<lambda>z. return_spmf (a, c, z))) =\n    map_spmf (\\<lambda>(a, z). (a, c, z)) (S2 H c)", "by(simp add: init_def S2_def split_def Let_def \\<Sigma>_protocols_base.S_def bind_map_spmf map_spmf_conv_bind_spmf)"], ["proof (state)\nthis:\n  chaum_ped_sigma.R H w c = chaum_ped_sigma.S H c\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma HVZK: \n  shows \"chaum_ped_sigma.HVZK\""], ["proof (prove)\ngoal (1 subgoal):\n 1. chaum_ped_sigma.HVZK", "unfolding chaum_ped_sigma.HVZK_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>e\\<in>challenge_space.\n       (\\<forall>(h, w)\\<in>R.\n           chaum_ped_sigma.R h w e = chaum_ped_sigma.S h e) \\<and>\n       (\\<forall>h\\<in>valid_pub.\n           \\<forall>(a, z)\\<in>set_spmf (S2 h e). check h a e z)", "by(auto simp add: hv_zk2 R_def valid_pub_def   S2_def check_def cyclic_group_assoc)"], ["", "lemma ss_rewrite1:\n  assumes \"fst h \\<in> carrier \\<G>\"\n    and \"a \\<in> carrier \\<G>\" \n    and e: \"e < order \\<G>\" \n    and \"a \\<otimes> fst h [^] e = \\<^bold>g [^] z\"  \n    and e': \"e' < e\"\n    and \"a \\<otimes> fst h [^] e' = \\<^bold>g [^] z'\"\n  shows \"fst h = \\<^bold>g [^] ((int z - int z') * inverse (e - e') (order \\<G>) mod int (order \\<G>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst h =\n    \\<^bold>g [^]\n    ((int z - int z') * Number_Theory_Aux.inverse (e - e') (order \\<G>) mod\n     int (order \\<G>))", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. fst h =\n    \\<^bold>g [^]\n    ((int z - int z') * Number_Theory_Aux.inverse (e - e') (order \\<G>) mod\n     int (order \\<G>))", "have gcd: \"gcd (e - e') (order \\<G>) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gcd (e - e') (order \\<G>) = 1", "using e e' prime_field prime_order"], ["proof (prove)\nusing this:\n  e < order \\<G>\n  e' < e\n  \\<lbrakk>prime ?q; ?a < ?q; ?a \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> coprime ?a ?q\n  prime (order \\<G>)\n\ngoal (1 subgoal):\n 1. gcd (e - e') (order \\<G>) = 1", "by simp"], ["proof (state)\nthis:\n  gcd (e - e') (order \\<G>) = 1\n\ngoal (1 subgoal):\n 1. fst h =\n    \\<^bold>g [^]\n    ((int z - int z') * Number_Theory_Aux.inverse (e - e') (order \\<G>) mod\n     int (order \\<G>))", "have \"a = \\<^bold>g [^] z \\<otimes> inv (fst h [^] e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a = \\<^bold>g [^] z \\<otimes> inv (fst h [^] e)", "using assms"], ["proof (prove)\nusing this:\n  fst h \\<in> carrier \\<G>\n  a \\<in> carrier \\<G>\n  e < order \\<G>\n  a \\<otimes> fst h [^] e = \\<^bold>g [^] z\n  e' < e\n  a \\<otimes> fst h [^] e' = \\<^bold>g [^] z'\n\ngoal (1 subgoal):\n 1. a = \\<^bold>g [^] z \\<otimes> inv (fst h [^] e)", "by (simp add: assms inv_solve_right)"], ["proof (state)\nthis:\n  a = \\<^bold>g [^] z \\<otimes> inv (fst h [^] e)\n\ngoal (1 subgoal):\n 1. fst h =\n    \\<^bold>g [^]\n    ((int z - int z') * Number_Theory_Aux.inverse (e - e') (order \\<G>) mod\n     int (order \\<G>))", "moreover"], ["proof (state)\nthis:\n  a = \\<^bold>g [^] z \\<otimes> inv (fst h [^] e)\n\ngoal (1 subgoal):\n 1. fst h =\n    \\<^bold>g [^]\n    ((int z - int z') * Number_Theory_Aux.inverse (e - e') (order \\<G>) mod\n     int (order \\<G>))", "have \"a = \\<^bold>g [^] z' \\<otimes> inv (fst h [^] e')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a = \\<^bold>g [^] z' \\<otimes> inv (fst h [^] e')", "using assms"], ["proof (prove)\nusing this:\n  fst h \\<in> carrier \\<G>\n  a \\<in> carrier \\<G>\n  e < order \\<G>\n  a \\<otimes> fst h [^] e = \\<^bold>g [^] z\n  e' < e\n  a \\<otimes> fst h [^] e' = \\<^bold>g [^] z'\n\ngoal (1 subgoal):\n 1. a = \\<^bold>g [^] z' \\<otimes> inv (fst h [^] e')", "by (simp add: assms inv_solve_right)"], ["proof (state)\nthis:\n  a = \\<^bold>g [^] z' \\<otimes> inv (fst h [^] e')\n\ngoal (1 subgoal):\n 1. fst h =\n    \\<^bold>g [^]\n    ((int z - int z') * Number_Theory_Aux.inverse (e - e') (order \\<G>) mod\n     int (order \\<G>))", "ultimately"], ["proof (chain)\npicking this:\n  a = \\<^bold>g [^] z \\<otimes> inv (fst h [^] e)\n  a = \\<^bold>g [^] z' \\<otimes> inv (fst h [^] e')", "have \"\\<^bold>g [^] z \\<otimes> fst h [^] e' = \\<^bold>g [^] z' \\<otimes> fst h [^] e\""], ["proof (prove)\nusing this:\n  a = \\<^bold>g [^] z \\<otimes> inv (fst h [^] e)\n  a = \\<^bold>g [^] z' \\<otimes> inv (fst h [^] e')\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^] z \\<otimes> fst h [^] e' =\n    \\<^bold>g [^] z' \\<otimes> fst h [^] e", "by (metis (no_types, lifting) assms cyclic_group_assoc cyclic_group_commute nat_pow_closed)"], ["proof (state)\nthis:\n  \\<^bold>g [^] z \\<otimes> fst h [^] e' =\n  \\<^bold>g [^] z' \\<otimes> fst h [^] e\n\ngoal (1 subgoal):\n 1. fst h =\n    \\<^bold>g [^]\n    ((int z - int z') * Number_Theory_Aux.inverse (e - e') (order \\<G>) mod\n     int (order \\<G>))", "moreover"], ["proof (state)\nthis:\n  \\<^bold>g [^] z \\<otimes> fst h [^] e' =\n  \\<^bold>g [^] z' \\<otimes> fst h [^] e\n\ngoal (1 subgoal):\n 1. fst h =\n    \\<^bold>g [^]\n    ((int z - int z') * Number_Theory_Aux.inverse (e - e') (order \\<G>) mod\n     int (order \\<G>))", "obtain t :: nat where t: \"fst h = \\<^bold>g [^] t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>t.\n        fst h = \\<^bold>g [^] t \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms generatorE"], ["proof (prove)\nusing this:\n  fst h \\<in> carrier \\<G>\n  a \\<in> carrier \\<G>\n  e < order \\<G>\n  a \\<otimes> fst h [^] e = \\<^bold>g [^] z\n  e' < e\n  a \\<otimes> fst h [^] e' = \\<^bold>g [^] z'\n  \\<lbrakk>?x \\<in> carrier \\<G>;\n   \\<And>n. ?x = \\<^bold>g [^] n \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        fst h = \\<^bold>g [^] t \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  fst h = \\<^bold>g [^] t\n\ngoal (1 subgoal):\n 1. fst h =\n    \\<^bold>g [^]\n    ((int z - int z') * Number_Theory_Aux.inverse (e - e') (order \\<G>) mod\n     int (order \\<G>))", "ultimately"], ["proof (chain)\npicking this:\n  \\<^bold>g [^] z \\<otimes> fst h [^] e' =\n  \\<^bold>g [^] z' \\<otimes> fst h [^] e\n  fst h = \\<^bold>g [^] t", "have \"\\<^bold>g [^] (z + t * e') = \\<^bold>g [^] (z' + t * e)\""], ["proof (prove)\nusing this:\n  \\<^bold>g [^] z \\<otimes> fst h [^] e' =\n  \\<^bold>g [^] z' \\<otimes> fst h [^] e\n  fst h = \\<^bold>g [^] t\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^] (z + t * e') = \\<^bold>g [^] (z' + t * e)", "using nat_pow_pow"], ["proof (prove)\nusing this:\n  \\<^bold>g [^] z \\<otimes> fst h [^] e' =\n  \\<^bold>g [^] z' \\<otimes> fst h [^] e\n  fst h = \\<^bold>g [^] t\n  ?x \\<in> carrier \\<G> \\<Longrightarrow>\n  (?x [^] ?n) [^] ?m = ?x [^] (?n * ?m)\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^] (z + t * e') = \\<^bold>g [^] (z' + t * e)", "by (simp add: nat_pow_mult)"], ["proof (state)\nthis:\n  \\<^bold>g [^] (z + t * e') = \\<^bold>g [^] (z' + t * e)\n\ngoal (1 subgoal):\n 1. fst h =\n    \\<^bold>g [^]\n    ((int z - int z') * Number_Theory_Aux.inverse (e - e') (order \\<G>) mod\n     int (order \\<G>))", "hence \"[z + t * e' = z' + t * e] (mod order \\<G>)\""], ["proof (prove)\nusing this:\n  \\<^bold>g [^] (z + t * e') = \\<^bold>g [^] (z' + t * e)\n\ngoal (1 subgoal):\n 1. [z + t * e' = z' + t * e] (mod order \\<G>)", "using group_eq_pow_eq_mod or_gt_0"], ["proof (prove)\nusing this:\n  \\<^bold>g [^] (z + t * e') = \\<^bold>g [^] (z' + t * e)\n  \\<lbrakk>\\<^bold>g [^] ?a = \\<^bold>g [^] ?b; 0 < order \\<G>\\<rbrakk>\n  \\<Longrightarrow> [?a = ?b] (mod order \\<G>)\n  0 < order \\<G>\n\ngoal (1 subgoal):\n 1. [z + t * e' = z' + t * e] (mod order \\<G>)", "by blast"], ["proof (state)\nthis:\n  [z + t * e' = z' + t * e] (mod order \\<G>)\n\ngoal (1 subgoal):\n 1. fst h =\n    \\<^bold>g [^]\n    ((int z - int z') * Number_Theory_Aux.inverse (e - e') (order \\<G>) mod\n     int (order \\<G>))", "hence \"[int z + int t * int e' = int z' + int t * int e] (mod order \\<G>)\""], ["proof (prove)\nusing this:\n  [z + t * e' = z' + t * e] (mod order \\<G>)\n\ngoal (1 subgoal):\n 1. [int z + int t * int e' = int z' + int t * int e] (mod int (order \\<G>))", "using cong_int_iff"], ["proof (prove)\nusing this:\n  [z + t * e' = z' + t * e] (mod order \\<G>)\n  [int ?m = int ?q] (mod int ?n) = [?m = ?q] (mod ?n)\n\ngoal (1 subgoal):\n 1. [int z + int t * int e' = int z' + int t * int e] (mod int (order \\<G>))", "by force"], ["proof (state)\nthis:\n  [int z + int t * int e' = int z' + int t * int e] (mod int (order \\<G>))\n\ngoal (1 subgoal):\n 1. fst h =\n    \\<^bold>g [^]\n    ((int z - int z') * Number_Theory_Aux.inverse (e - e') (order \\<G>) mod\n     int (order \\<G>))", "hence \"[int z - int z' = int t * int e - int t * int e'] (mod order \\<G>)\""], ["proof (prove)\nusing this:\n  [int z + int t * int e' = int z' + int t * int e] (mod int (order \\<G>))\n\ngoal (1 subgoal):\n 1. [int z - int z' = int t * int e - int t * int e'] (mod int (order \\<G>))", "by (smt cong_diff_iff_cong_0)"], ["proof (state)\nthis:\n  [int z - int z' = int t * int e - int t * int e'] (mod int (order \\<G>))\n\ngoal (1 subgoal):\n 1. fst h =\n    \\<^bold>g [^]\n    ((int z - int z') * Number_Theory_Aux.inverse (e - e') (order \\<G>) mod\n     int (order \\<G>))", "hence \"[int z - int z' = int t * (int e - int e')] (mod order \\<G>)\""], ["proof (prove)\nusing this:\n  [int z - int z' = int t * int e - int t * int e'] (mod int (order \\<G>))\n\ngoal (1 subgoal):\n 1. [int z - int z' = int t * (int e - int e')] (mod int (order \\<G>))", "by (simp add: right_diff_distrib)"], ["proof (state)\nthis:\n  [int z - int z' = int t * (int e - int e')] (mod int (order \\<G>))\n\ngoal (1 subgoal):\n 1. fst h =\n    \\<^bold>g [^]\n    ((int z - int z') * Number_Theory_Aux.inverse (e - e') (order \\<G>) mod\n     int (order \\<G>))", "hence \"[int z - int z' = int t * (e - e')] (mod order \\<G>)\""], ["proof (prove)\nusing this:\n  [int z - int z' = int t * (int e - int e')] (mod int (order \\<G>))\n\ngoal (1 subgoal):\n 1. [int z - int z' = int t * int (e - e')] (mod int (order \\<G>))", "using assms"], ["proof (prove)\nusing this:\n  [int z - int z' = int t * (int e - int e')] (mod int (order \\<G>))\n  fst h \\<in> carrier \\<G>\n  a \\<in> carrier \\<G>\n  e < order \\<G>\n  a \\<otimes> fst h [^] e = \\<^bold>g [^] z\n  e' < e\n  a \\<otimes> fst h [^] e' = \\<^bold>g [^] z'\n\ngoal (1 subgoal):\n 1. [int z - int z' = int t * int (e - e')] (mod int (order \\<G>))", "by (simp add: of_nat_diff)"], ["proof (state)\nthis:\n  [int z - int z' = int t * int (e - e')] (mod int (order \\<G>))\n\ngoal (1 subgoal):\n 1. fst h =\n    \\<^bold>g [^]\n    ((int z - int z') * Number_Theory_Aux.inverse (e - e') (order \\<G>) mod\n     int (order \\<G>))", "hence \"[(int z - int z') * fst (bezw (e - e') (order \\<G>))  = int t * (e - e') * fst (bezw (e - e') (order \\<G>))] (mod order \\<G>)\""], ["proof (prove)\nusing this:\n  [int z - int z' = int t * int (e - e')] (mod int (order \\<G>))\n\ngoal (1 subgoal):\n 1. [(int z - int z') *\n     Number_Theory_Aux.inverse (e - e')\n      (order\n        \\<G>) = int t * int (e - e') *\n                Number_Theory_Aux.inverse (e - e')\n                 (order \\<G>)] (mod int (order \\<G>))", "using cong_scalar_right"], ["proof (prove)\nusing this:\n  [int z - int z' = int t * int (e - e')] (mod int (order \\<G>))\n  [?b = ?c] (mod ?a) \\<Longrightarrow> [?b * ?d = ?c * ?d] (mod ?a)\n\ngoal (1 subgoal):\n 1. [(int z - int z') *\n     Number_Theory_Aux.inverse (e - e')\n      (order\n        \\<G>) = int t * int (e - e') *\n                Number_Theory_Aux.inverse (e - e')\n                 (order \\<G>)] (mod int (order \\<G>))", "by blast"], ["proof (state)\nthis:\n  [(int z - int z') *\n   Number_Theory_Aux.inverse (e - e')\n    (order\n      \\<G>) = int t * int (e - e') *\n              Number_Theory_Aux.inverse (e - e')\n               (order \\<G>)] (mod int (order \\<G>))\n\ngoal (1 subgoal):\n 1. fst h =\n    \\<^bold>g [^]\n    ((int z - int z') * Number_Theory_Aux.inverse (e - e') (order \\<G>) mod\n     int (order \\<G>))", "hence \"[(int z - int z') * fst (bezw (e - e') (order \\<G>))  = int t * ((e - e') * fst (bezw (e - e') (order \\<G>)))] (mod order \\<G>)\""], ["proof (prove)\nusing this:\n  [(int z - int z') *\n   Number_Theory_Aux.inverse (e - e')\n    (order\n      \\<G>) = int t * int (e - e') *\n              Number_Theory_Aux.inverse (e - e')\n               (order \\<G>)] (mod int (order \\<G>))\n\ngoal (1 subgoal):\n 1. [(int z - int z') *\n     Number_Theory_Aux.inverse (e - e')\n      (order\n        \\<G>) = int t *\n                (int (e - e') *\n                 Number_Theory_Aux.inverse (e - e')\n                  (order \\<G>))] (mod int (order \\<G>))", "by (simp add: more_arith_simps(11))"], ["proof (state)\nthis:\n  [(int z - int z') *\n   Number_Theory_Aux.inverse (e - e')\n    (order\n      \\<G>) = int t *\n              (int (e - e') *\n               Number_Theory_Aux.inverse (e - e')\n                (order \\<G>))] (mod int (order \\<G>))\n\ngoal (1 subgoal):\n 1. fst h =\n    \\<^bold>g [^]\n    ((int z - int z') * Number_Theory_Aux.inverse (e - e') (order \\<G>) mod\n     int (order \\<G>))", "hence \"[(int z - int z') * fst (bezw (e - e') (order \\<G>))  = int t * 1] (mod order \\<G>)\""], ["proof (prove)\nusing this:\n  [(int z - int z') *\n   Number_Theory_Aux.inverse (e - e')\n    (order\n      \\<G>) = int t *\n              (int (e - e') *\n               Number_Theory_Aux.inverse (e - e')\n                (order \\<G>))] (mod int (order \\<G>))\n\ngoal (1 subgoal):\n 1. [(int z - int z') *\n     Number_Theory_Aux.inverse (e - e')\n      (order \\<G>) = int t * 1] (mod int (order \\<G>))", "by (metis (no_types, hide_lams) cong_scalar_left cong_trans inverse gcd)"], ["proof (state)\nthis:\n  [(int z - int z') *\n   Number_Theory_Aux.inverse (e - e')\n    (order \\<G>) = int t * 1] (mod int (order \\<G>))\n\ngoal (1 subgoal):\n 1. fst h =\n    \\<^bold>g [^]\n    ((int z - int z') * Number_Theory_Aux.inverse (e - e') (order \\<G>) mod\n     int (order \\<G>))", "hence \"[(int z - int z') * fst (bezw (e - e') (order \\<G>)) mod order \\<G>  = t] (mod order \\<G>)\""], ["proof (prove)\nusing this:\n  [(int z - int z') *\n   Number_Theory_Aux.inverse (e - e')\n    (order \\<G>) = int t * 1] (mod int (order \\<G>))\n\ngoal (1 subgoal):\n 1. [(int z - int z') * Number_Theory_Aux.inverse (e - e') (order \\<G>) mod\n     int (order \\<G>) = int t] (mod int (order \\<G>))", "by simp"], ["proof (state)\nthis:\n  [(int z - int z') * Number_Theory_Aux.inverse (e - e') (order \\<G>) mod\n   int (order \\<G>) = int t] (mod int (order \\<G>))\n\ngoal (1 subgoal):\n 1. fst h =\n    \\<^bold>g [^]\n    ((int z - int z') * Number_Theory_Aux.inverse (e - e') (order \\<G>) mod\n     int (order \\<G>))", "hence \"[nat ((int z - int z') * fst (bezw (e - e') (order \\<G>)) mod order \\<G>)  = t] (mod order \\<G>)\""], ["proof (prove)\nusing this:\n  [(int z - int z') * Number_Theory_Aux.inverse (e - e') (order \\<G>) mod\n   int (order \\<G>) = int t] (mod int (order \\<G>))\n\ngoal (1 subgoal):\n 1. [nat ((int z - int z') *\n          Number_Theory_Aux.inverse (e - e') (order \\<G>) mod\n          int (order \\<G>)) = t] (mod order \\<G>)", "by (metis cong_def int_ops(9) mod_mod_trivial nat_int)"], ["proof (state)\nthis:\n  [nat ((int z - int z') *\n        Number_Theory_Aux.inverse (e - e') (order \\<G>) mod\n        int (order \\<G>)) = t] (mod order \\<G>)\n\ngoal (1 subgoal):\n 1. fst h =\n    \\<^bold>g [^]\n    ((int z - int z') * Number_Theory_Aux.inverse (e - e') (order \\<G>) mod\n     int (order \\<G>))", "hence \"\\<^bold>g [^] (nat ((int z - int z') * fst (bezw (e - e') (order \\<G>)) mod order \\<G>))  = \\<^bold>g [^] t\""], ["proof (prove)\nusing this:\n  [nat ((int z - int z') *\n        Number_Theory_Aux.inverse (e - e') (order \\<G>) mod\n        int (order \\<G>)) = t] (mod order \\<G>)\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^]\n    nat ((int z - int z') *\n         Number_Theory_Aux.inverse (e - e') (order \\<G>) mod\n         int (order \\<G>)) =\n    \\<^bold>g [^] t", "using order_gt_0 order_gt_0_iff_finite pow_generator_eq_iff_cong"], ["proof (prove)\nusing this:\n  [nat ((int z - int z') *\n        Number_Theory_Aux.inverse (e - e') (order \\<G>) mod\n        int (order \\<G>)) = t] (mod order \\<G>)\n  0 < order \\<G>\n  (0 < order \\<G>) = finite (carrier \\<G>)\n  finite (carrier \\<G>) \\<Longrightarrow>\n  (\\<^bold>g [^] ?x = \\<^bold>g [^] ?y) = [?x = ?y] (mod order \\<G>)\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^]\n    nat ((int z - int z') *\n         Number_Theory_Aux.inverse (e - e') (order \\<G>) mod\n         int (order \\<G>)) =\n    \\<^bold>g [^] t", "by blast"], ["proof (state)\nthis:\n  \\<^bold>g [^]\n  nat ((int z - int z') *\n       Number_Theory_Aux.inverse (e - e') (order \\<G>) mod\n       int (order \\<G>)) =\n  \\<^bold>g [^] t\n\ngoal (1 subgoal):\n 1. fst h =\n    \\<^bold>g [^]\n    ((int z - int z') * Number_Theory_Aux.inverse (e - e') (order \\<G>) mod\n     int (order \\<G>))", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<^bold>g [^]\n  nat ((int z - int z') *\n       Number_Theory_Aux.inverse (e - e') (order \\<G>) mod\n       int (order \\<G>)) =\n  \\<^bold>g [^] t\n\ngoal (1 subgoal):\n 1. fst h =\n    \\<^bold>g [^]\n    ((int z - int z') * Number_Theory_Aux.inverse (e - e') (order \\<G>) mod\n     int (order \\<G>))", "using t"], ["proof (prove)\nusing this:\n  \\<^bold>g [^]\n  nat ((int z - int z') *\n       Number_Theory_Aux.inverse (e - e') (order \\<G>) mod\n       int (order \\<G>)) =\n  \\<^bold>g [^] t\n  fst h = \\<^bold>g [^] t\n\ngoal (1 subgoal):\n 1. fst h =\n    \\<^bold>g [^]\n    ((int z - int z') * Number_Theory_Aux.inverse (e - e') (order \\<G>) mod\n     int (order \\<G>))", "by simp"], ["proof (state)\nthis:\n  fst h =\n  \\<^bold>g [^]\n  ((int z - int z') * Number_Theory_Aux.inverse (e - e') (order \\<G>) mod\n   int (order \\<G>))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ss_rewrite2:\n  assumes \"fst h \\<in> carrier \\<G>\"\n    and \"snd h \\<in> carrier \\<G>\" \n    and \"a \\<in> carrier \\<G>\" \n    and \"b \\<in> carrier \\<G>\"\n    and \"e < order \\<G>\" \n    and \"a \\<otimes> fst h [^] e = \\<^bold>g [^] z\" \n    and \"b \\<otimes> snd h [^] e = g' [^] z\"\n    and \"e' < e\" \n    and \"a \\<otimes> fst h [^] e' = \\<^bold>g [^] z'\"\n    and \"b \\<otimes> snd h [^] e' = g' [^] z'\"\n  shows \"snd h = g' [^] ((int z - int z') * inverse (e - e') (order \\<G>) mod int (order \\<G>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd h =\n    g' [^]\n    ((int z - int z') * Number_Theory_Aux.inverse (e - e') (order \\<G>) mod\n     int (order \\<G>))", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. snd h =\n    g' [^]\n    ((int z - int z') * Number_Theory_Aux.inverse (e - e') (order \\<G>) mod\n     int (order \\<G>))", "have gcd: \"gcd (e - e') (order \\<G>) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gcd (e - e') (order \\<G>) = 1", "using prime_field assms prime_order"], ["proof (prove)\nusing this:\n  \\<lbrakk>prime ?q; ?a < ?q; ?a \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> coprime ?a ?q\n  fst h \\<in> carrier \\<G>\n  snd h \\<in> carrier \\<G>\n  a \\<in> carrier \\<G>\n  b \\<in> carrier \\<G>\n  e < order \\<G>\n  a \\<otimes> fst h [^] e = \\<^bold>g [^] z\n  b \\<otimes> snd h [^] e = g' [^] z\n  e' < e\n  a \\<otimes> fst h [^] e' = \\<^bold>g [^] z'\n  b \\<otimes> snd h [^] e' = g' [^] z'\n  prime (order \\<G>)\n\ngoal (1 subgoal):\n 1. gcd (e - e') (order \\<G>) = 1", "by simp"], ["proof (state)\nthis:\n  gcd (e - e') (order \\<G>) = 1\n\ngoal (1 subgoal):\n 1. snd h =\n    g' [^]\n    ((int z - int z') * Number_Theory_Aux.inverse (e - e') (order \\<G>) mod\n     int (order \\<G>))", "have \"b = g' [^] z \\<otimes> inv (snd h [^] e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b = g' [^] z \\<otimes> inv (snd h [^] e)", "by (simp add: assms inv_solve_right)"], ["proof (state)\nthis:\n  b = g' [^] z \\<otimes> inv (snd h [^] e)\n\ngoal (1 subgoal):\n 1. snd h =\n    g' [^]\n    ((int z - int z') * Number_Theory_Aux.inverse (e - e') (order \\<G>) mod\n     int (order \\<G>))", "moreover"], ["proof (state)\nthis:\n  b = g' [^] z \\<otimes> inv (snd h [^] e)\n\ngoal (1 subgoal):\n 1. snd h =\n    g' [^]\n    ((int z - int z') * Number_Theory_Aux.inverse (e - e') (order \\<G>) mod\n     int (order \\<G>))", "have \"b = g' [^] z' \\<otimes> inv (snd h [^] e')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b = g' [^] z' \\<otimes> inv (snd h [^] e')", "by (metis assms(2) assms(4) assms(10) g'_def generator_closed group.inv_solve_right' group_l_invI l_inv_ex nat_pow_closed)"], ["proof (state)\nthis:\n  b = g' [^] z' \\<otimes> inv (snd h [^] e')\n\ngoal (1 subgoal):\n 1. snd h =\n    g' [^]\n    ((int z - int z') * Number_Theory_Aux.inverse (e - e') (order \\<G>) mod\n     int (order \\<G>))", "ultimately"], ["proof (chain)\npicking this:\n  b = g' [^] z \\<otimes> inv (snd h [^] e)\n  b = g' [^] z' \\<otimes> inv (snd h [^] e')", "have \"g' [^] z \\<otimes> snd h [^] e' = g' [^] z' \\<otimes> snd h [^] e\""], ["proof (prove)\nusing this:\n  b = g' [^] z \\<otimes> inv (snd h [^] e)\n  b = g' [^] z' \\<otimes> inv (snd h [^] e')\n\ngoal (1 subgoal):\n 1. g' [^] z \\<otimes> snd h [^] e' = g' [^] z' \\<otimes> snd h [^] e", "by (metis (no_types, lifting) assms cyclic_group_assoc cyclic_group_commute nat_pow_closed)"], ["proof (state)\nthis:\n  g' [^] z \\<otimes> snd h [^] e' = g' [^] z' \\<otimes> snd h [^] e\n\ngoal (1 subgoal):\n 1. snd h =\n    g' [^]\n    ((int z - int z') * Number_Theory_Aux.inverse (e - e') (order \\<G>) mod\n     int (order \\<G>))", "moreover"], ["proof (state)\nthis:\n  g' [^] z \\<otimes> snd h [^] e' = g' [^] z' \\<otimes> snd h [^] e\n\ngoal (1 subgoal):\n 1. snd h =\n    g' [^]\n    ((int z - int z') * Number_Theory_Aux.inverse (e - e') (order \\<G>) mod\n     int (order \\<G>))", "obtain t :: nat where t: \"snd h = \\<^bold>g [^] t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>t.\n        snd h = \\<^bold>g [^] t \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms(2) generatorE"], ["proof (prove)\nusing this:\n  snd h \\<in> carrier \\<G>\n  \\<lbrakk>?x \\<in> carrier \\<G>;\n   \\<And>n. ?x = \\<^bold>g [^] n \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        snd h = \\<^bold>g [^] t \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  snd h = \\<^bold>g [^] t\n\ngoal (1 subgoal):\n 1. snd h =\n    g' [^]\n    ((int z - int z') * Number_Theory_Aux.inverse (e - e') (order \\<G>) mod\n     int (order \\<G>))", "ultimately"], ["proof (chain)\npicking this:\n  g' [^] z \\<otimes> snd h [^] e' = g' [^] z' \\<otimes> snd h [^] e\n  snd h = \\<^bold>g [^] t", "have \"\\<^bold>g [^] (x * z + t * e') = \\<^bold>g [^] (x * z' + t * e)\""], ["proof (prove)\nusing this:\n  g' [^] z \\<otimes> snd h [^] e' = g' [^] z' \\<otimes> snd h [^] e\n  snd h = \\<^bold>g [^] t\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^] (x * z + t * e') = \\<^bold>g [^] (x * z' + t * e)", "using g'_def nat_pow_pow"], ["proof (prove)\nusing this:\n  g' [^] z \\<otimes> snd h [^] e' = g' [^] z' \\<otimes> snd h [^] e\n  snd h = \\<^bold>g [^] t\n  g' = \\<^bold>g [^] x\n  ?x \\<in> carrier \\<G> \\<Longrightarrow>\n  (?x [^] ?n) [^] ?m = ?x [^] (?n * ?m)\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^] (x * z + t * e') = \\<^bold>g [^] (x * z' + t * e)", "by (simp add: nat_pow_mult)"], ["proof (state)\nthis:\n  \\<^bold>g [^] (x * z + t * e') = \\<^bold>g [^] (x * z' + t * e)\n\ngoal (1 subgoal):\n 1. snd h =\n    g' [^]\n    ((int z - int z') * Number_Theory_Aux.inverse (e - e') (order \\<G>) mod\n     int (order \\<G>))", "hence \"[x * z + t * e' = x * z' + t * e] (mod order \\<G>)\""], ["proof (prove)\nusing this:\n  \\<^bold>g [^] (x * z + t * e') = \\<^bold>g [^] (x * z' + t * e)\n\ngoal (1 subgoal):\n 1. [x * z + t * e' = x * z' + t * e] (mod order \\<G>)", "using group_eq_pow_eq_mod order_gt_0"], ["proof (prove)\nusing this:\n  \\<^bold>g [^] (x * z + t * e') = \\<^bold>g [^] (x * z' + t * e)\n  \\<lbrakk>\\<^bold>g [^] ?a = \\<^bold>g [^] ?b; 0 < order \\<G>\\<rbrakk>\n  \\<Longrightarrow> [?a = ?b] (mod order \\<G>)\n  0 < order \\<G>\n\ngoal (1 subgoal):\n 1. [x * z + t * e' = x * z' + t * e] (mod order \\<G>)", "by blast"], ["proof (state)\nthis:\n  [x * z + t * e' = x * z' + t * e] (mod order \\<G>)\n\ngoal (1 subgoal):\n 1. snd h =\n    g' [^]\n    ((int z - int z') * Number_Theory_Aux.inverse (e - e') (order \\<G>) mod\n     int (order \\<G>))", "hence \"[int x * int z + int t * int e' = int x * int z' + int t * int e] (mod order \\<G>)\""], ["proof (prove)\nusing this:\n  [x * z + t * e' = x * z' + t * e] (mod order \\<G>)\n\ngoal (1 subgoal):\n 1. [int x * int z +\n     int t * int e' = int x * int z' + int t * int e] (mod int (order \\<G>))", "by (metis Groups.add_ac(2) Groups.mult_ac(2) cong_int_iff int_ops(7) int_plus)"], ["proof (state)\nthis:\n  [int x * int z +\n   int t * int e' = int x * int z' + int t * int e] (mod int (order \\<G>))\n\ngoal (1 subgoal):\n 1. snd h =\n    g' [^]\n    ((int z - int z') * Number_Theory_Aux.inverse (e - e') (order \\<G>) mod\n     int (order \\<G>))", "hence \"[int x * int z - int x * int z' = int t * int e - int t * int e'] (mod order \\<G>)\""], ["proof (prove)\nusing this:\n  [int x * int z +\n   int t * int e' = int x * int z' + int t * int e] (mod int (order \\<G>))\n\ngoal (1 subgoal):\n 1. [int x * int z -\n     int x * int z' = int t * int e - int t * int e'] (mod int (order \\<G>))", "by (smt cong_diff_iff_cong_0)"], ["proof (state)\nthis:\n  [int x * int z -\n   int x * int z' = int t * int e - int t * int e'] (mod int (order \\<G>))\n\ngoal (1 subgoal):\n 1. snd h =\n    g' [^]\n    ((int z - int z') * Number_Theory_Aux.inverse (e - e') (order \\<G>) mod\n     int (order \\<G>))", "hence \"[int x * (int z - int z') = int t * (int e - int e')] (mod order \\<G>)\""], ["proof (prove)\nusing this:\n  [int x * int z -\n   int x * int z' = int t * int e - int t * int e'] (mod int (order \\<G>))\n\ngoal (1 subgoal):\n 1. [int x *\n     (int z - int z') = int t * (int e - int e')] (mod int (order \\<G>))", "by (simp add: int_distrib(4))"], ["proof (state)\nthis:\n  [int x *\n   (int z - int z') = int t * (int e - int e')] (mod int (order \\<G>))\n\ngoal (1 subgoal):\n 1. snd h =\n    g' [^]\n    ((int z - int z') * Number_Theory_Aux.inverse (e - e') (order \\<G>) mod\n     int (order \\<G>))", "hence \"[int x * (int z - int z') = int t * (e - e')] (mod order \\<G>)\""], ["proof (prove)\nusing this:\n  [int x *\n   (int z - int z') = int t * (int e - int e')] (mod int (order \\<G>))\n\ngoal (1 subgoal):\n 1. [int x * (int z - int z') = int t * int (e - e')] (mod int (order \\<G>))", "using assms"], ["proof (prove)\nusing this:\n  [int x *\n   (int z - int z') = int t * (int e - int e')] (mod int (order \\<G>))\n  fst h \\<in> carrier \\<G>\n  snd h \\<in> carrier \\<G>\n  a \\<in> carrier \\<G>\n  b \\<in> carrier \\<G>\n  e < order \\<G>\n  a \\<otimes> fst h [^] e = \\<^bold>g [^] z\n  b \\<otimes> snd h [^] e = g' [^] z\n  e' < e\n  a \\<otimes> fst h [^] e' = \\<^bold>g [^] z'\n  b \\<otimes> snd h [^] e' = g' [^] z'\n\ngoal (1 subgoal):\n 1. [int x * (int z - int z') = int t * int (e - e')] (mod int (order \\<G>))", "by (simp add: of_nat_diff)"], ["proof (state)\nthis:\n  [int x * (int z - int z') = int t * int (e - e')] (mod int (order \\<G>))\n\ngoal (1 subgoal):\n 1. snd h =\n    g' [^]\n    ((int z - int z') * Number_Theory_Aux.inverse (e - e') (order \\<G>) mod\n     int (order \\<G>))", "hence \"[(int x * (int z - int z')) * fst (bezw (e - e') (order \\<G>)) = int t * (e - e') * fst (bezw (e - e') (order \\<G>))] (mod order \\<G>)\""], ["proof (prove)\nusing this:\n  [int x * (int z - int z') = int t * int (e - e')] (mod int (order \\<G>))\n\ngoal (1 subgoal):\n 1. [int x * (int z - int z') *\n     Number_Theory_Aux.inverse (e - e')\n      (order\n        \\<G>) = int t * int (e - e') *\n                Number_Theory_Aux.inverse (e - e')\n                 (order \\<G>)] (mod int (order \\<G>))", "using cong_scalar_right"], ["proof (prove)\nusing this:\n  [int x * (int z - int z') = int t * int (e - e')] (mod int (order \\<G>))\n  [?b = ?c] (mod ?a) \\<Longrightarrow> [?b * ?d = ?c * ?d] (mod ?a)\n\ngoal (1 subgoal):\n 1. [int x * (int z - int z') *\n     Number_Theory_Aux.inverse (e - e')\n      (order\n        \\<G>) = int t * int (e - e') *\n                Number_Theory_Aux.inverse (e - e')\n                 (order \\<G>)] (mod int (order \\<G>))", "by blast"], ["proof (state)\nthis:\n  [int x * (int z - int z') *\n   Number_Theory_Aux.inverse (e - e')\n    (order\n      \\<G>) = int t * int (e - e') *\n              Number_Theory_Aux.inverse (e - e')\n               (order \\<G>)] (mod int (order \\<G>))\n\ngoal (1 subgoal):\n 1. snd h =\n    g' [^]\n    ((int z - int z') * Number_Theory_Aux.inverse (e - e') (order \\<G>) mod\n     int (order \\<G>))", "hence \"[(int x * (int z - int z')) * fst (bezw (e - e') (order \\<G>)) = int t * ((e - e') * fst (bezw (e - e') (order \\<G>)))] (mod order \\<G>)\""], ["proof (prove)\nusing this:\n  [int x * (int z - int z') *\n   Number_Theory_Aux.inverse (e - e')\n    (order\n      \\<G>) = int t * int (e - e') *\n              Number_Theory_Aux.inverse (e - e')\n               (order \\<G>)] (mod int (order \\<G>))\n\ngoal (1 subgoal):\n 1. [int x * (int z - int z') *\n     Number_Theory_Aux.inverse (e - e')\n      (order\n        \\<G>) = int t *\n                (int (e - e') *\n                 Number_Theory_Aux.inverse (e - e')\n                  (order \\<G>))] (mod int (order \\<G>))", "by (simp add: more_arith_simps(11))"], ["proof (state)\nthis:\n  [int x * (int z - int z') *\n   Number_Theory_Aux.inverse (e - e')\n    (order\n      \\<G>) = int t *\n              (int (e - e') *\n               Number_Theory_Aux.inverse (e - e')\n                (order \\<G>))] (mod int (order \\<G>))\n\ngoal (1 subgoal):\n 1. snd h =\n    g' [^]\n    ((int z - int z') * Number_Theory_Aux.inverse (e - e') (order \\<G>) mod\n     int (order \\<G>))", "hence *: \"[(int x * (int z - int z')) * fst (bezw (e - e') (order \\<G>)) = int t * 1] (mod order \\<G>)\""], ["proof (prove)\nusing this:\n  [int x * (int z - int z') *\n   Number_Theory_Aux.inverse (e - e')\n    (order\n      \\<G>) = int t *\n              (int (e - e') *\n               Number_Theory_Aux.inverse (e - e')\n                (order \\<G>))] (mod int (order \\<G>))\n\ngoal (1 subgoal):\n 1. [int x * (int z - int z') *\n     Number_Theory_Aux.inverse (e - e')\n      (order \\<G>) = int t * 1] (mod int (order \\<G>))", "by (metis (no_types, hide_lams) cong_scalar_left cong_trans gcd inverse)"], ["proof (state)\nthis:\n  [int x * (int z - int z') *\n   Number_Theory_Aux.inverse (e - e')\n    (order \\<G>) = int t * 1] (mod int (order \\<G>))\n\ngoal (1 subgoal):\n 1. snd h =\n    g' [^]\n    ((int z - int z') * Number_Theory_Aux.inverse (e - e') (order \\<G>) mod\n     int (order \\<G>))", "hence \"[nat ((int x * (int z - int z')) * fst (bezw (e - e') (order \\<G>)) mod order \\<G>) = t] (mod order \\<G>)\""], ["proof (prove)\nusing this:\n  [int x * (int z - int z') *\n   Number_Theory_Aux.inverse (e - e')\n    (order \\<G>) = int t * 1] (mod int (order \\<G>))\n\ngoal (1 subgoal):\n 1. [nat (int x * (int z - int z') *\n          Number_Theory_Aux.inverse (e - e') (order \\<G>) mod\n          int (order \\<G>)) = t] (mod order \\<G>)", "by (metis cong_def cong_mod_right more_arith_simps(6) nat_int zmod_int)"], ["proof (state)\nthis:\n  [nat (int x * (int z - int z') *\n        Number_Theory_Aux.inverse (e - e') (order \\<G>) mod\n        int (order \\<G>)) = t] (mod order \\<G>)\n\ngoal (1 subgoal):\n 1. snd h =\n    g' [^]\n    ((int z - int z') * Number_Theory_Aux.inverse (e - e') (order \\<G>) mod\n     int (order \\<G>))", "hence \"\\<^bold>g [^] (nat ((int x * (int z - int z')) * fst (bezw (e - e') (order \\<G>)) mod order \\<G>)) = \\<^bold>g [^] t\""], ["proof (prove)\nusing this:\n  [nat (int x * (int z - int z') *\n        Number_Theory_Aux.inverse (e - e') (order \\<G>) mod\n        int (order \\<G>)) = t] (mod order \\<G>)\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^]\n    nat (int x * (int z - int z') *\n         Number_Theory_Aux.inverse (e - e') (order \\<G>) mod\n         int (order \\<G>)) =\n    \\<^bold>g [^] t", "using order_gt_0 order_gt_0_iff_finite pow_generator_eq_iff_cong"], ["proof (prove)\nusing this:\n  [nat (int x * (int z - int z') *\n        Number_Theory_Aux.inverse (e - e') (order \\<G>) mod\n        int (order \\<G>)) = t] (mod order \\<G>)\n  0 < order \\<G>\n  (0 < order \\<G>) = finite (carrier \\<G>)\n  finite (carrier \\<G>) \\<Longrightarrow>\n  (\\<^bold>g [^] ?x = \\<^bold>g [^] ?y) = [?x = ?y] (mod order \\<G>)\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^]\n    nat (int x * (int z - int z') *\n         Number_Theory_Aux.inverse (e - e') (order \\<G>) mod\n         int (order \\<G>)) =\n    \\<^bold>g [^] t", "by blast"], ["proof (state)\nthis:\n  \\<^bold>g [^]\n  nat (int x * (int z - int z') *\n       Number_Theory_Aux.inverse (e - e') (order \\<G>) mod\n       int (order \\<G>)) =\n  \\<^bold>g [^] t\n\ngoal (1 subgoal):\n 1. snd h =\n    g' [^]\n    ((int z - int z') * Number_Theory_Aux.inverse (e - e') (order \\<G>) mod\n     int (order \\<G>))", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<^bold>g [^]\n  nat (int x * (int z - int z') *\n       Number_Theory_Aux.inverse (e - e') (order \\<G>) mod\n       int (order \\<G>)) =\n  \\<^bold>g [^] t\n\ngoal (1 subgoal):\n 1. snd h =\n    g' [^]\n    ((int z - int z') * Number_Theory_Aux.inverse (e - e') (order \\<G>) mod\n     int (order \\<G>))", "using t"], ["proof (prove)\nusing this:\n  \\<^bold>g [^]\n  nat (int x * (int z - int z') *\n       Number_Theory_Aux.inverse (e - e') (order \\<G>) mod\n       int (order \\<G>)) =\n  \\<^bold>g [^] t\n  snd h = \\<^bold>g [^] t\n\ngoal (1 subgoal):\n 1. snd h =\n    g' [^]\n    ((int z - int z') * Number_Theory_Aux.inverse (e - e') (order \\<G>) mod\n     int (order \\<G>))", "by (metis (mono_tags, hide_lams) * cong_def g'_def generator_closed int_pow_int int_pow_pow mod_mult_right_eq more_arith_simps(11) more_arith_simps(6) pow_generator_mod_int)"], ["proof (state)\nthis:\n  snd h =\n  g' [^]\n  ((int z - int z') * Number_Theory_Aux.inverse (e - e') (order \\<G>) mod\n   int (order \\<G>))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ss_rewrite_snd_h:\n  assumes e_e'_mod: \"e' mod order \\<G> < e mod order \\<G>\"\n    and h_mem: \"snd h \\<in> carrier \\<G>\"\n    and a_mem: \"snd a \\<in> carrier \\<G>\"\n    and a1: \"snd a \\<otimes> snd h [^] e = g' [^] z\" \n    and a2: \"snd a \\<otimes> snd h [^] e' = g' [^] z'\" \n  shows \"snd h = g' [^] ((int z - int z') * fst (bezw ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>) (order \\<G>)) mod int (order \\<G>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd h =\n    g' [^]\n    ((int z - int z') *\n     Number_Theory_Aux.inverse\n      ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n      (order \\<G>) mod\n     int (order \\<G>))", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. snd h =\n    g' [^]\n    ((int z - int z') *\n     Number_Theory_Aux.inverse\n      ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n      (order \\<G>) mod\n     int (order \\<G>))", "have gcd: \"gcd ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>) (order \\<G>) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gcd ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n     (order \\<G>) =\n    1", "using prime_field"], ["proof (prove)\nusing this:\n  \\<lbrakk>prime ?q; ?a < ?q; ?a \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> coprime ?a ?q\n\ngoal (1 subgoal):\n 1. gcd ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n     (order \\<G>) =\n    1", "by (simp add: assms less_imp_diff_less linorder_not_le prime_order)"], ["proof (state)\nthis:\n  gcd ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>) (order \\<G>) =\n  1\n\ngoal (1 subgoal):\n 1. snd h =\n    g' [^]\n    ((int z - int z') *\n     Number_Theory_Aux.inverse\n      ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n      (order \\<G>) mod\n     int (order \\<G>))", "have \"snd a = g' [^] z \\<otimes> inv (snd h [^] e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd a = g' [^] z \\<otimes> inv (snd h [^] e)", "using a1"], ["proof (prove)\nusing this:\n  snd a \\<otimes> snd h [^] e = g' [^] z\n\ngoal (1 subgoal):\n 1. snd a = g' [^] z \\<otimes> inv (snd h [^] e)", "by (metis (no_types, lifting) Group.group.axioms(1) h_mem a_mem group.inv_closed group_l_invI l_inv_ex monoid.m_assoc nat_pow_closed r_inv r_one)"], ["proof (state)\nthis:\n  snd a = g' [^] z \\<otimes> inv (snd h [^] e)\n\ngoal (1 subgoal):\n 1. snd h =\n    g' [^]\n    ((int z - int z') *\n     Number_Theory_Aux.inverse\n      ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n      (order \\<G>) mod\n     int (order \\<G>))", "moreover"], ["proof (state)\nthis:\n  snd a = g' [^] z \\<otimes> inv (snd h [^] e)\n\ngoal (1 subgoal):\n 1. snd h =\n    g' [^]\n    ((int z - int z') *\n     Number_Theory_Aux.inverse\n      ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n      (order \\<G>) mod\n     int (order \\<G>))", "have \"snd a = g' [^] z' \\<otimes> inv (snd h [^] e')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd a = g' [^] z' \\<otimes> inv (snd h [^] e')", "by (metis a2 h_mem a_mem g'_def generator_closed group.inv_solve_right' group_l_invI l_inv_ex nat_pow_closed)"], ["proof (state)\nthis:\n  snd a = g' [^] z' \\<otimes> inv (snd h [^] e')\n\ngoal (1 subgoal):\n 1. snd h =\n    g' [^]\n    ((int z - int z') *\n     Number_Theory_Aux.inverse\n      ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n      (order \\<G>) mod\n     int (order \\<G>))", "ultimately"], ["proof (chain)\npicking this:\n  snd a = g' [^] z \\<otimes> inv (snd h [^] e)\n  snd a = g' [^] z' \\<otimes> inv (snd h [^] e')", "have \"g' [^] z \\<otimes> snd h [^] e' = g' [^] z' \\<otimes> snd h [^] e\""], ["proof (prove)\nusing this:\n  snd a = g' [^] z \\<otimes> inv (snd h [^] e)\n  snd a = g' [^] z' \\<otimes> inv (snd h [^] e')\n\ngoal (1 subgoal):\n 1. g' [^] z \\<otimes> snd h [^] e' = g' [^] z' \\<otimes> snd h [^] e", "by (metis (no_types, lifting) a2 h_mem a_mem a1 cyclic_group_assoc cyclic_group_commute nat_pow_closed)"], ["proof (state)\nthis:\n  g' [^] z \\<otimes> snd h [^] e' = g' [^] z' \\<otimes> snd h [^] e\n\ngoal (1 subgoal):\n 1. snd h =\n    g' [^]\n    ((int z - int z') *\n     Number_Theory_Aux.inverse\n      ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n      (order \\<G>) mod\n     int (order \\<G>))", "moreover"], ["proof (state)\nthis:\n  g' [^] z \\<otimes> snd h [^] e' = g' [^] z' \\<otimes> snd h [^] e\n\ngoal (1 subgoal):\n 1. snd h =\n    g' [^]\n    ((int z - int z') *\n     Number_Theory_Aux.inverse\n      ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n      (order \\<G>) mod\n     int (order \\<G>))", "obtain t :: nat where t: \"snd h = \\<^bold>g [^] t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>t.\n        snd h = \\<^bold>g [^] t \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms(2) generatorE"], ["proof (prove)\nusing this:\n  snd h \\<in> carrier \\<G>\n  \\<lbrakk>?x \\<in> carrier \\<G>;\n   \\<And>n. ?x = \\<^bold>g [^] n \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        snd h = \\<^bold>g [^] t \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  snd h = \\<^bold>g [^] t\n\ngoal (1 subgoal):\n 1. snd h =\n    g' [^]\n    ((int z - int z') *\n     Number_Theory_Aux.inverse\n      ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n      (order \\<G>) mod\n     int (order \\<G>))", "ultimately"], ["proof (chain)\npicking this:\n  g' [^] z \\<otimes> snd h [^] e' = g' [^] z' \\<otimes> snd h [^] e\n  snd h = \\<^bold>g [^] t", "have \"\\<^bold>g [^] (x * z + t * e') = \\<^bold>g [^] (x * z' + t * e)\""], ["proof (prove)\nusing this:\n  g' [^] z \\<otimes> snd h [^] e' = g' [^] z' \\<otimes> snd h [^] e\n  snd h = \\<^bold>g [^] t\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^] (x * z + t * e') = \\<^bold>g [^] (x * z' + t * e)", "using g'_def nat_pow_pow"], ["proof (prove)\nusing this:\n  g' [^] z \\<otimes> snd h [^] e' = g' [^] z' \\<otimes> snd h [^] e\n  snd h = \\<^bold>g [^] t\n  g' = \\<^bold>g [^] x\n  ?x \\<in> carrier \\<G> \\<Longrightarrow>\n  (?x [^] ?n) [^] ?m = ?x [^] (?n * ?m)\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^] (x * z + t * e') = \\<^bold>g [^] (x * z' + t * e)", "by (simp add: nat_pow_mult)"], ["proof (state)\nthis:\n  \\<^bold>g [^] (x * z + t * e') = \\<^bold>g [^] (x * z' + t * e)\n\ngoal (1 subgoal):\n 1. snd h =\n    g' [^]\n    ((int z - int z') *\n     Number_Theory_Aux.inverse\n      ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n      (order \\<G>) mod\n     int (order \\<G>))", "hence \"[x * z + t * e' = x * z' + t * e] (mod order \\<G>)\""], ["proof (prove)\nusing this:\n  \\<^bold>g [^] (x * z + t * e') = \\<^bold>g [^] (x * z' + t * e)\n\ngoal (1 subgoal):\n 1. [x * z + t * e' = x * z' + t * e] (mod order \\<G>)", "using group_eq_pow_eq_mod order_gt_0"], ["proof (prove)\nusing this:\n  \\<^bold>g [^] (x * z + t * e') = \\<^bold>g [^] (x * z' + t * e)\n  \\<lbrakk>\\<^bold>g [^] ?a = \\<^bold>g [^] ?b; 0 < order \\<G>\\<rbrakk>\n  \\<Longrightarrow> [?a = ?b] (mod order \\<G>)\n  0 < order \\<G>\n\ngoal (1 subgoal):\n 1. [x * z + t * e' = x * z' + t * e] (mod order \\<G>)", "by blast"], ["proof (state)\nthis:\n  [x * z + t * e' = x * z' + t * e] (mod order \\<G>)\n\ngoal (1 subgoal):\n 1. snd h =\n    g' [^]\n    ((int z - int z') *\n     Number_Theory_Aux.inverse\n      ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n      (order \\<G>) mod\n     int (order \\<G>))", "hence \"[int x * int z + int t * int e' = int x * int z' + int t * int e] (mod order \\<G>)\""], ["proof (prove)\nusing this:\n  [x * z + t * e' = x * z' + t * e] (mod order \\<G>)\n\ngoal (1 subgoal):\n 1. [int x * int z +\n     int t * int e' = int x * int z' + int t * int e] (mod int (order \\<G>))", "by (metis Groups.add_ac(2) Groups.mult_ac(2) cong_int_iff int_ops(7) int_plus)"], ["proof (state)\nthis:\n  [int x * int z +\n   int t * int e' = int x * int z' + int t * int e] (mod int (order \\<G>))\n\ngoal (1 subgoal):\n 1. snd h =\n    g' [^]\n    ((int z - int z') *\n     Number_Theory_Aux.inverse\n      ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n      (order \\<G>) mod\n     int (order \\<G>))", "hence \"[int x * int z - int x * int z' = int t * int e - int t * int e'] (mod order \\<G>)\""], ["proof (prove)\nusing this:\n  [int x * int z +\n   int t * int e' = int x * int z' + int t * int e] (mod int (order \\<G>))\n\ngoal (1 subgoal):\n 1. [int x * int z -\n     int x * int z' = int t * int e - int t * int e'] (mod int (order \\<G>))", "by (smt cong_diff_iff_cong_0)"], ["proof (state)\nthis:\n  [int x * int z -\n   int x * int z' = int t * int e - int t * int e'] (mod int (order \\<G>))\n\ngoal (1 subgoal):\n 1. snd h =\n    g' [^]\n    ((int z - int z') *\n     Number_Theory_Aux.inverse\n      ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n      (order \\<G>) mod\n     int (order \\<G>))", "hence \"[int x * (int z - int z') = int t * (int e - int e')] (mod order \\<G>)\""], ["proof (prove)\nusing this:\n  [int x * int z -\n   int x * int z' = int t * int e - int t * int e'] (mod int (order \\<G>))\n\ngoal (1 subgoal):\n 1. [int x *\n     (int z - int z') = int t * (int e - int e')] (mod int (order \\<G>))", "by (simp add: int_distrib(4))"], ["proof (state)\nthis:\n  [int x *\n   (int z - int z') = int t * (int e - int e')] (mod int (order \\<G>))\n\ngoal (1 subgoal):\n 1. snd h =\n    g' [^]\n    ((int z - int z') *\n     Number_Theory_Aux.inverse\n      ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n      (order \\<G>) mod\n     int (order \\<G>))", "hence \"[int x * (int z - int z') = int t * (int e mod order \\<G> - int e' mod order \\<G>) mod order \\<G>] (mod order \\<G>)\""], ["proof (prove)\nusing this:\n  [int x *\n   (int z - int z') = int t * (int e - int e')] (mod int (order \\<G>))\n\ngoal (1 subgoal):\n 1. [int x *\n     (int z -\n      int z') = int t *\n                (int e mod int (order \\<G>) -\n                 int e' mod int (order \\<G>)) mod\n                int (order \\<G>)] (mod int (order \\<G>))", "by (metis (no_types, lifting) cong_def mod_diff_eq mod_mod_trivial mod_mult_right_eq)"], ["proof (state)\nthis:\n  [int x *\n   (int z -\n    int z') = int t *\n              (int e mod int (order \\<G>) - int e' mod int (order \\<G>)) mod\n              int (order \\<G>)] (mod int (order \\<G>))\n\ngoal (1 subgoal):\n 1. snd h =\n    g' [^]\n    ((int z - int z') *\n     Number_Theory_Aux.inverse\n      ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n      (order \\<G>) mod\n     int (order \\<G>))", "hence *: \"[int x * (int z - int z') = int t * (e mod order \\<G> - e' mod order \\<G>) mod order \\<G>] (mod order \\<G>)\""], ["proof (prove)\nusing this:\n  [int x *\n   (int z -\n    int z') = int t *\n              (int e mod int (order \\<G>) - int e' mod int (order \\<G>)) mod\n              int (order \\<G>)] (mod int (order \\<G>))\n\ngoal (1 subgoal):\n 1. [int x *\n     (int z -\n      int z') = int t * int (e mod order \\<G> - e' mod order \\<G>) mod\n                int (order \\<G>)] (mod int (order \\<G>))", "by (simp add: assms(1) int_ops(9) less_imp_le_nat of_nat_diff)"], ["proof (state)\nthis:\n  [int x *\n   (int z -\n    int z') = int t * int (e mod order \\<G> - e' mod order \\<G>) mod\n              int (order \\<G>)] (mod int (order \\<G>))\n\ngoal (1 subgoal):\n 1. snd h =\n    g' [^]\n    ((int z - int z') *\n     Number_Theory_Aux.inverse\n      ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n      (order \\<G>) mod\n     int (order \\<G>))", "hence \"[int x * (int z - int z') * fst (bezw ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>) (order \\<G>)) \n               = int t * ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G> \n                  * fst (bezw ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>) (order \\<G>)))] (mod order \\<G>)\""], ["proof (prove)\nusing this:\n  [int x *\n   (int z -\n    int z') = int t * int (e mod order \\<G> - e' mod order \\<G>) mod\n              int (order \\<G>)] (mod int (order \\<G>))\n\ngoal (1 subgoal):\n 1. [int x * (int z - int z') *\n     Number_Theory_Aux.inverse\n      ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n      (order\n        \\<G>) = int t *\n                (int ((e mod order \\<G> - e' mod order \\<G>) mod\n                      order \\<G>) *\n                 Number_Theory_Aux.inverse\n                  ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n                  (order \\<G>))] (mod int (order \\<G>))", "by (metis (no_types, lifting) cong_mod_right cong_scalar_right less_imp_diff_less mod_if more_arith_simps(11) or_gt_0 unique_euclidean_semiring_numeral_class.pos_mod_bound)"], ["proof (state)\nthis:\n  [int x * (int z - int z') *\n   Number_Theory_Aux.inverse\n    ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n    (order\n      \\<G>) = int t *\n              (int ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>) *\n               Number_Theory_Aux.inverse\n                ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n                (order \\<G>))] (mod int (order \\<G>))\n\ngoal (1 subgoal):\n 1. snd h =\n    g' [^]\n    ((int z - int z') *\n     Number_Theory_Aux.inverse\n      ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n      (order \\<G>) mod\n     int (order \\<G>))", "hence \"[int x * (int z - int z') * fst (bezw ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>) (order \\<G>)) \n               = int t * 1] (mod order \\<G>)\""], ["proof (prove)\nusing this:\n  [int x * (int z - int z') *\n   Number_Theory_Aux.inverse\n    ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n    (order\n      \\<G>) = int t *\n              (int ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>) *\n               Number_Theory_Aux.inverse\n                ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n                (order \\<G>))] (mod int (order \\<G>))\n\ngoal (1 subgoal):\n 1. [int x * (int z - int z') *\n     Number_Theory_Aux.inverse\n      ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n      (order \\<G>) = int t * 1] (mod int (order \\<G>))", "by (meson Number_Theory_Aux.inverse * gcd cong_scalar_left cong_trans)"], ["proof (state)\nthis:\n  [int x * (int z - int z') *\n   Number_Theory_Aux.inverse\n    ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n    (order \\<G>) = int t * 1] (mod int (order \\<G>))\n\ngoal (1 subgoal):\n 1. snd h =\n    g' [^]\n    ((int z - int z') *\n     Number_Theory_Aux.inverse\n      ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n      (order \\<G>) mod\n     int (order \\<G>))", "hence \"\\<^bold>g [^] (int x * (int z - int z') * fst (bezw ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>) (order \\<G>))) = \\<^bold>g [^] t\""], ["proof (prove)\nusing this:\n  [int x * (int z - int z') *\n   Number_Theory_Aux.inverse\n    ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n    (order \\<G>) = int t * 1] (mod int (order \\<G>))\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^]\n    (int x * (int z - int z') *\n     Number_Theory_Aux.inverse\n      ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n      (order \\<G>)) =\n    \\<^bold>g [^] t", "by (metis cong_def int_pow_int more_arith_simps(6) pow_generator_mod_int)"], ["proof (state)\nthis:\n  \\<^bold>g [^]\n  (int x * (int z - int z') *\n   Number_Theory_Aux.inverse\n    ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>) (order \\<G>)) =\n  \\<^bold>g [^] t\n\ngoal (1 subgoal):\n 1. snd h =\n    g' [^]\n    ((int z - int z') *\n     Number_Theory_Aux.inverse\n      ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n      (order \\<G>) mod\n     int (order \\<G>))", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<^bold>g [^]\n  (int x * (int z - int z') *\n   Number_Theory_Aux.inverse\n    ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>) (order \\<G>)) =\n  \\<^bold>g [^] t\n\ngoal (1 subgoal):\n 1. snd h =\n    g' [^]\n    ((int z - int z') *\n     Number_Theory_Aux.inverse\n      ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n      (order \\<G>) mod\n     int (order \\<G>))", "using t"], ["proof (prove)\nusing this:\n  \\<^bold>g [^]\n  (int x * (int z - int z') *\n   Number_Theory_Aux.inverse\n    ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>) (order \\<G>)) =\n  \\<^bold>g [^] t\n  snd h = \\<^bold>g [^] t\n\ngoal (1 subgoal):\n 1. snd h =\n    g' [^]\n    ((int z - int z') *\n     Number_Theory_Aux.inverse\n      ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>)\n      (order \\<G>) mod\n     int (order \\<G>))", "by (metis (mono_tags, hide_lams) g'_def generator_closed int_pow_int int_pow_pow mod_mult_right_eq more_arith_simps(11) pow_generator_mod_int)"], ["proof (state)\nthis:\n  snd h =\n  g' [^]\n  ((int z - int z') *\n   Number_Theory_Aux.inverse\n    ((e mod order \\<G> - e' mod order \\<G>) mod order \\<G>) (order \\<G>) mod\n   int (order \\<G>))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma special_soundness:\n  shows \"chaum_ped_sigma.special_soundness\""], ["proof (prove)\ngoal (1 subgoal):\n 1. chaum_ped_sigma.special_soundness", "unfolding chaum_ped_sigma.special_soundness_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>h e e' a z z'.\n       h \\<in> valid_pub \\<longrightarrow>\n       e \\<in> challenge_space \\<longrightarrow>\n       e' \\<in> challenge_space \\<longrightarrow>\n       e \\<noteq> e' \\<longrightarrow>\n       check h a e z \\<longrightarrow>\n       check h a e' z' \\<longrightarrow>\n       lossless_spmf (ss_adversary h (a, e, z) (a, e', z')) \\<and>\n       (\\<forall>w'\\<in>set_spmf (ss_adversary h (a, e, z) (a, e', z')).\n           (h, w') \\<in> R)", "apply(auto simp add: challenge_space_def check_def ss_adversary_def R_def valid_pub_def)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a b e e' aa ba z z'.\n       \\<lbrakk>a \\<in> carrier \\<G>; b \\<in> carrier \\<G>; e < order \\<G>;\n        aa \\<otimes> a [^] e = \\<^bold>g [^] z;\n        ba \\<otimes> b [^] e = g' [^] z; aa \\<in> carrier \\<G>;\n        ba \\<in> carrier \\<G>; e' < e;\n        aa \\<otimes> a [^] e' = \\<^bold>g [^] z';\n        ba \\<otimes> b [^] e' = g' [^] z'\\<rbrakk>\n       \\<Longrightarrow> a =\n                         \\<^bold>g [^]\n                         ((int z - int z') *\n                          Number_Theory_Aux.inverse (e - e')\n                           (order \\<G>) mod\n                          int (order \\<G>))\n 2. \\<And>a b e e' aa ba z z'.\n       \\<lbrakk>a \\<in> carrier \\<G>; b \\<in> carrier \\<G>; e < order \\<G>;\n        aa \\<otimes> a [^] e = \\<^bold>g [^] z;\n        ba \\<otimes> b [^] e = g' [^] z; aa \\<in> carrier \\<G>;\n        ba \\<in> carrier \\<G>; e' < e;\n        aa \\<otimes> a [^] e' = \\<^bold>g [^] z';\n        ba \\<otimes> b [^] e' = g' [^] z'\\<rbrakk>\n       \\<Longrightarrow> b =\n                         g' [^]\n                         ((int z - int z') *\n                          Number_Theory_Aux.inverse (e - e')\n                           (order \\<G>) mod\n                          int (order \\<G>))\n 3. \\<And>a b e e' aa ba z z'.\n       \\<lbrakk>a \\<in> carrier \\<G>; b \\<in> carrier \\<G>; e' < order \\<G>;\n        e \\<noteq> e'; aa \\<otimes> a [^] e = \\<^bold>g [^] z;\n        ba \\<otimes> b [^] e = g' [^] z; aa \\<in> carrier \\<G>;\n        ba \\<in> carrier \\<G>; \\<not> e' < e;\n        aa \\<otimes> a [^] e' = \\<^bold>g [^] z';\n        ba \\<otimes> b [^] e' = g' [^] z'\\<rbrakk>\n       \\<Longrightarrow> a =\n                         \\<^bold>g [^]\n                         ((int z' - int z) *\n                          Number_Theory_Aux.inverse (e' - e)\n                           (order \\<G>) mod\n                          int (order \\<G>))\n 4. \\<And>a b e e' aa ba z z'.\n       \\<lbrakk>a \\<in> carrier \\<G>; b \\<in> carrier \\<G>; e' < order \\<G>;\n        e \\<noteq> e'; aa \\<otimes> a [^] e = \\<^bold>g [^] z;\n        ba \\<otimes> b [^] e = g' [^] z; aa \\<in> carrier \\<G>;\n        ba \\<in> carrier \\<G>; \\<not> e' < e;\n        aa \\<otimes> a [^] e' = \\<^bold>g [^] z';\n        ba \\<otimes> b [^] e' = g' [^] z'\\<rbrakk>\n       \\<Longrightarrow> b =\n                         g' [^]\n                         ((int z' - int z) *\n                          Number_Theory_Aux.inverse (e' - e)\n                           (order \\<G>) mod\n                          int (order \\<G>))", "using ss_rewrite2 ss_rewrite1"], ["proof (prove)\nusing this:\n  \\<lbrakk>fst ?h \\<in> carrier \\<G>; snd ?h \\<in> carrier \\<G>;\n   ?a \\<in> carrier \\<G>; ?b \\<in> carrier \\<G>; ?e < order \\<G>;\n   ?a \\<otimes> fst ?h [^] ?e = \\<^bold>g [^] ?z;\n   ?b \\<otimes> snd ?h [^] ?e = g' [^] ?z; ?e' < ?e;\n   ?a \\<otimes> fst ?h [^] ?e' = \\<^bold>g [^] ?z';\n   ?b \\<otimes> snd ?h [^] ?e' = g' [^] ?z'\\<rbrakk>\n  \\<Longrightarrow> snd ?h =\n                    g' [^]\n                    ((int ?z - int ?z') *\n                     Number_Theory_Aux.inverse (?e - ?e') (order \\<G>) mod\n                     int (order \\<G>))\n  \\<lbrakk>fst ?h \\<in> carrier \\<G>; ?a \\<in> carrier \\<G>;\n   ?e < order \\<G>; ?a \\<otimes> fst ?h [^] ?e = \\<^bold>g [^] ?z; ?e' < ?e;\n   ?a \\<otimes> fst ?h [^] ?e' = \\<^bold>g [^] ?z'\\<rbrakk>\n  \\<Longrightarrow> fst ?h =\n                    \\<^bold>g [^]\n                    ((int ?z - int ?z') *\n                     Number_Theory_Aux.inverse (?e - ?e') (order \\<G>) mod\n                     int (order \\<G>))\n\ngoal (4 subgoals):\n 1. \\<And>a b e e' aa ba z z'.\n       \\<lbrakk>a \\<in> carrier \\<G>; b \\<in> carrier \\<G>; e < order \\<G>;\n        aa \\<otimes> a [^] e = \\<^bold>g [^] z;\n        ba \\<otimes> b [^] e = g' [^] z; aa \\<in> carrier \\<G>;\n        ba \\<in> carrier \\<G>; e' < e;\n        aa \\<otimes> a [^] e' = \\<^bold>g [^] z';\n        ba \\<otimes> b [^] e' = g' [^] z'\\<rbrakk>\n       \\<Longrightarrow> a =\n                         \\<^bold>g [^]\n                         ((int z - int z') *\n                          Number_Theory_Aux.inverse (e - e')\n                           (order \\<G>) mod\n                          int (order \\<G>))\n 2. \\<And>a b e e' aa ba z z'.\n       \\<lbrakk>a \\<in> carrier \\<G>; b \\<in> carrier \\<G>; e < order \\<G>;\n        aa \\<otimes> a [^] e = \\<^bold>g [^] z;\n        ba \\<otimes> b [^] e = g' [^] z; aa \\<in> carrier \\<G>;\n        ba \\<in> carrier \\<G>; e' < e;\n        aa \\<otimes> a [^] e' = \\<^bold>g [^] z';\n        ba \\<otimes> b [^] e' = g' [^] z'\\<rbrakk>\n       \\<Longrightarrow> b =\n                         g' [^]\n                         ((int z - int z') *\n                          Number_Theory_Aux.inverse (e - e')\n                           (order \\<G>) mod\n                          int (order \\<G>))\n 3. \\<And>a b e e' aa ba z z'.\n       \\<lbrakk>a \\<in> carrier \\<G>; b \\<in> carrier \\<G>; e' < order \\<G>;\n        e \\<noteq> e'; aa \\<otimes> a [^] e = \\<^bold>g [^] z;\n        ba \\<otimes> b [^] e = g' [^] z; aa \\<in> carrier \\<G>;\n        ba \\<in> carrier \\<G>; \\<not> e' < e;\n        aa \\<otimes> a [^] e' = \\<^bold>g [^] z';\n        ba \\<otimes> b [^] e' = g' [^] z'\\<rbrakk>\n       \\<Longrightarrow> a =\n                         \\<^bold>g [^]\n                         ((int z' - int z) *\n                          Number_Theory_Aux.inverse (e' - e)\n                           (order \\<G>) mod\n                          int (order \\<G>))\n 4. \\<And>a b e e' aa ba z z'.\n       \\<lbrakk>a \\<in> carrier \\<G>; b \\<in> carrier \\<G>; e' < order \\<G>;\n        e \\<noteq> e'; aa \\<otimes> a [^] e = \\<^bold>g [^] z;\n        ba \\<otimes> b [^] e = g' [^] z; aa \\<in> carrier \\<G>;\n        ba \\<in> carrier \\<G>; \\<not> e' < e;\n        aa \\<otimes> a [^] e' = \\<^bold>g [^] z';\n        ba \\<otimes> b [^] e' = g' [^] z'\\<rbrakk>\n       \\<Longrightarrow> b =\n                         g' [^]\n                         ((int z' - int z) *\n                          Number_Theory_Aux.inverse (e' - e)\n                           (order \\<G>) mod\n                          int (order \\<G>))", "by auto"], ["", "theorem \\<Sigma>_protocol:  \"chaum_ped_sigma.\\<Sigma>_protocol\""], ["proof (prove)\ngoal (1 subgoal):\n 1. chaum_ped_sigma.\\<Sigma>_protocol", "by(simp add: chaum_ped_sigma.\\<Sigma>_protocol_def completeness HVZK special_soundness)"], ["", "sublocale chaum_ped_\\<Sigma>_commit: \\<Sigma>_protocols_to_commitments init response check R S2 ss_adversary challenge_space valid_pub G"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sigma>_protocols_to_commitments init response check R S2 ss_adversary\n     challenge_space valid_pub G", "apply unfold_locales"], ["proof (prove)\ngoal (5 subgoals):\n 1. chaum_ped_sigma.\\<Sigma>_protocol\n 2. \\<And>h w. (h, w) \\<in> set_spmf G \\<Longrightarrow> (h, w) \\<in> R\n 3. lossless_spmf G\n 4. \\<And>h w. lossless_spmf (init h w)\n 5. \\<And>r w e. lossless_spmf (response r w e)", "apply(auto simp add: \\<Sigma>_protocol lossless_init lossless_response lossless_G)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b w.\n       ((a, b), w) \\<in> set_spmf G \\<Longrightarrow> ((a, b), w) \\<in> R", "by(simp add: R_def G_def)"], ["", "sublocale dis_log: dis_log \\<G>"], ["proof (prove)\ngoal (1 subgoal):\n 1. dis_log \\<G>", "unfolding dis_log_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < order \\<G>", "by simp"], ["", "sublocale dis_log_alt: dis_log_alt \\<G> x"], ["proof (prove)\ngoal (1 subgoal):\n 1. dis_log_alt \\<G>", "unfolding dis_log_alt_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < order \\<G>", "by simp"], ["", "lemma reduction_to_dis_log: \n  shows \"chaum_ped_\\<Sigma>_commit.rel_advantage \\<A> = dis_log.advantage (dis_log_alt.adversary3 \\<A>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. chaum_ped_\\<Sigma>_commit.rel_advantage \\<A> =\n    local.dis_log.advantage (local.dis_log_alt.adversary3 \\<A>)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. chaum_ped_\\<Sigma>_commit.rel_advantage \\<A> =\n    local.dis_log.advantage (local.dis_log_alt.adversary3 \\<A>)", "have \"chaum_ped_\\<Sigma>_commit.rel_game \\<A> = TRY do {\n    w \\<leftarrow> sample_uniform (order \\<G>);\n    let (h,w) = ((\\<^bold>g [^] w, g' [^] w), w);\n    w' \\<leftarrow> \\<A> h;\n    return_spmf ((fst h = \\<^bold>g [^] w' \\<and> snd h = g' [^] w'))} ELSE return_spmf False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. chaum_ped_\\<Sigma>_commit.rel_game \\<A> =\n    TRY sample_uniform (order \\<G>) \\<bind>\n        (\\<lambda>w.\n            let (h, w) = ((\\<^bold>g [^] w, g' [^] w), w)\n            in \\<A> h \\<bind>\n               (\\<lambda>w'.\n                   return_spmf\n                    (fst h = \\<^bold>g [^] w' \\<and>\n                     snd h = g' [^] w'))) ELSE return_spmf False", "unfolding chaum_ped_\\<Sigma>_commit.rel_game_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. TRY G \\<bind>\n        (\\<lambda>(h, w).\n            \\<A> h \\<bind>\n            (\\<lambda>w'.\n                return_spmf ((h, w') \\<in> R))) ELSE return_spmf False =\n    TRY sample_uniform (order \\<G>) \\<bind>\n        (\\<lambda>w.\n            let (h, w) = ((\\<^bold>g [^] w, g' [^] w), w)\n            in \\<A> h \\<bind>\n               (\\<lambda>w'.\n                   return_spmf\n                    (fst h = \\<^bold>g [^] w' \\<and>\n                     snd h = g' [^] w'))) ELSE return_spmf False", "by(simp add:  G_def R_def)"], ["proof (state)\nthis:\n  chaum_ped_\\<Sigma>_commit.rel_game \\<A> =\n  TRY sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>w.\n          let (h, w) = ((\\<^bold>g [^] w, g' [^] w), w)\n          in \\<A> h \\<bind>\n             (\\<lambda>w'.\n                 return_spmf\n                  (fst h = \\<^bold>g [^] w' \\<and>\n                   snd h = g' [^] w'))) ELSE return_spmf False\n\ngoal (1 subgoal):\n 1. chaum_ped_\\<Sigma>_commit.rel_advantage \\<A> =\n    local.dis_log.advantage (local.dis_log_alt.adversary3 \\<A>)", "also"], ["proof (state)\nthis:\n  chaum_ped_\\<Sigma>_commit.rel_game \\<A> =\n  TRY sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>w.\n          let (h, w) = ((\\<^bold>g [^] w, g' [^] w), w)\n          in \\<A> h \\<bind>\n             (\\<lambda>w'.\n                 return_spmf\n                  (fst h = \\<^bold>g [^] w' \\<and>\n                   snd h = g' [^] w'))) ELSE return_spmf False\n\ngoal (1 subgoal):\n 1. chaum_ped_\\<Sigma>_commit.rel_advantage \\<A> =\n    local.dis_log.advantage (local.dis_log_alt.adversary3 \\<A>)", "have \"... = TRY do {    \n    w \\<leftarrow> sample_uniform (order \\<G>);\n    let (h,w) = ((\\<^bold>g [^] w, g' [^] w), w);\n    w' \\<leftarrow> \\<A> h;\n    return_spmf ([w = w'] (mod (order \\<G>)) \\<and> [x*w = x*w'] (mod order \\<G>))} ELSE return_spmf False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. TRY sample_uniform (order \\<G>) \\<bind>\n        (\\<lambda>w.\n            let (h, w) = ((\\<^bold>g [^] w, g' [^] w), w)\n            in \\<A> h \\<bind>\n               (\\<lambda>w'.\n                   return_spmf\n                    (fst h = \\<^bold>g [^] w' \\<and>\n                     snd h = g' [^] w'))) ELSE return_spmf False =\n    TRY sample_uniform (order \\<G>) \\<bind>\n        (\\<lambda>w.\n            let (h, w) = ((\\<^bold>g [^] w, g' [^] w), w)\n            in \\<A> h \\<bind>\n               (\\<lambda>w'.\n                   return_spmf\n                    ([w = w'] (mod order \\<G>) \\<and>\n                     [x *\n                      w = x * w'] (mod order \\<G>)))) ELSE return_spmf False", "apply(intro try_spmf_cong bind_spmf_cong[OF refl]; simp add: dis_log_alt.dis_log3_def dis_log_alt.g'_def g'_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa < order \\<G> \\<Longrightarrow>\n       \\<A> (\\<^bold>g [^] xa, (\\<^bold>g [^] x) [^] xa) \\<bind>\n       (\\<lambda>w'.\n           return_spmf\n            (\\<^bold>g [^] xa = \\<^bold>g [^] w' \\<and>\n             (\\<^bold>g [^] x) [^] xa = (\\<^bold>g [^] x) [^] w')) =\n       \\<A> (\\<^bold>g [^] xa, (\\<^bold>g [^] x) [^] xa) \\<bind>\n       (\\<lambda>w'.\n           return_spmf\n            ([xa = w'] (mod order \\<G>) \\<and>\n             [x * xa = x * w'] (mod order \\<G>)))", "by (simp add: finite_carrier nat_pow_pow pow_generator_eq_iff_cong)"], ["proof (state)\nthis:\n  TRY sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>w.\n          let (h, w) = ((\\<^bold>g [^] w, g' [^] w), w)\n          in \\<A> h \\<bind>\n             (\\<lambda>w'.\n                 return_spmf\n                  (fst h = \\<^bold>g [^] w' \\<and>\n                   snd h = g' [^] w'))) ELSE return_spmf False =\n  TRY sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>w.\n          let (h, w) = ((\\<^bold>g [^] w, g' [^] w), w)\n          in \\<A> h \\<bind>\n             (\\<lambda>w'.\n                 return_spmf\n                  ([w = w'] (mod order \\<G>) \\<and>\n                   [x *\n                    w = x * w'] (mod order \\<G>)))) ELSE return_spmf False\n\ngoal (1 subgoal):\n 1. chaum_ped_\\<Sigma>_commit.rel_advantage \\<A> =\n    local.dis_log.advantage (local.dis_log_alt.adversary3 \\<A>)", "also"], ["proof (state)\nthis:\n  TRY sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>w.\n          let (h, w) = ((\\<^bold>g [^] w, g' [^] w), w)\n          in \\<A> h \\<bind>\n             (\\<lambda>w'.\n                 return_spmf\n                  (fst h = \\<^bold>g [^] w' \\<and>\n                   snd h = g' [^] w'))) ELSE return_spmf False =\n  TRY sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>w.\n          let (h, w) = ((\\<^bold>g [^] w, g' [^] w), w)\n          in \\<A> h \\<bind>\n             (\\<lambda>w'.\n                 return_spmf\n                  ([w = w'] (mod order \\<G>) \\<and>\n                   [x *\n                    w = x * w'] (mod order \\<G>)))) ELSE return_spmf False\n\ngoal (1 subgoal):\n 1. chaum_ped_\\<Sigma>_commit.rel_advantage \\<A> =\n    local.dis_log.advantage (local.dis_log_alt.adversary3 \\<A>)", "have \"... = dis_log_alt.dis_log3 \\<A>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. TRY sample_uniform (order \\<G>) \\<bind>\n        (\\<lambda>w.\n            let (h, w) = ((\\<^bold>g [^] w, g' [^] w), w)\n            in \\<A> h \\<bind>\n               (\\<lambda>w'.\n                   return_spmf\n                    ([w = w'] (mod order \\<G>) \\<and>\n                     [x *\n                      w = x *\n                          w'] (mod order \\<G>)))) ELSE return_spmf False =\n    local.dis_log_alt.dis_log3 \\<A>", "apply(auto simp add:  dis_log_alt.dis_log3_def dis_log_alt.g'_def g'_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. TRY sample_uniform (order \\<G>) \\<bind>\n        (\\<lambda>w.\n            \\<A> (\\<^bold>g [^] w, (\\<^bold>g [^] x) [^] w) \\<bind>\n            (\\<lambda>w'.\n                return_spmf\n                 ([w = w'] (mod order \\<G>) \\<and>\n                  [x *\n                   w = x * w'] (mod order \\<G>)))) ELSE return_spmf False =\n    TRY sample_uniform (order \\<G>) \\<bind>\n        (\\<lambda>w.\n            \\<A> (\\<^bold>g [^] w, (\\<^bold>g [^] x) [^] w) \\<bind>\n            (\\<lambda>w'.\n                return_spmf\n                 [w = w'] (mod order \\<G>))) ELSE return_spmf False", "by(intro try_spmf_cong  bind_spmf_cong[OF refl]; clarsimp?; auto simp add: cong_scalar_left)"], ["proof (state)\nthis:\n  TRY sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>w.\n          let (h, w) = ((\\<^bold>g [^] w, g' [^] w), w)\n          in \\<A> h \\<bind>\n             (\\<lambda>w'.\n                 return_spmf\n                  ([w = w'] (mod order \\<G>) \\<and>\n                   [x *\n                    w = x * w'] (mod order \\<G>)))) ELSE return_spmf False =\n  local.dis_log_alt.dis_log3 \\<A>\n\ngoal (1 subgoal):\n 1. chaum_ped_\\<Sigma>_commit.rel_advantage \\<A> =\n    local.dis_log.advantage (local.dis_log_alt.adversary3 \\<A>)", "ultimately"], ["proof (chain)\npicking this:\n  chaum_ped_\\<Sigma>_commit.rel_game \\<A> =\n  TRY sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>w.\n          let (h, w) = ((\\<^bold>g [^] w, g' [^] w), w)\n          in \\<A> h \\<bind>\n             (\\<lambda>w'.\n                 return_spmf\n                  ([w = w'] (mod order \\<G>) \\<and>\n                   [x *\n                    w = x * w'] (mod order \\<G>)))) ELSE return_spmf False\n  TRY sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>w.\n          let (h, w) = ((\\<^bold>g [^] w, g' [^] w), w)\n          in \\<A> h \\<bind>\n             (\\<lambda>w'.\n                 return_spmf\n                  ([w = w'] (mod order \\<G>) \\<and>\n                   [x *\n                    w = x * w'] (mod order \\<G>)))) ELSE return_spmf False =\n  local.dis_log_alt.dis_log3 \\<A>", "have \"chaum_ped_\\<Sigma>_commit.rel_advantage \\<A> = dis_log_alt.advantage3 \\<A>\""], ["proof (prove)\nusing this:\n  chaum_ped_\\<Sigma>_commit.rel_game \\<A> =\n  TRY sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>w.\n          let (h, w) = ((\\<^bold>g [^] w, g' [^] w), w)\n          in \\<A> h \\<bind>\n             (\\<lambda>w'.\n                 return_spmf\n                  ([w = w'] (mod order \\<G>) \\<and>\n                   [x *\n                    w = x * w'] (mod order \\<G>)))) ELSE return_spmf False\n  TRY sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>w.\n          let (h, w) = ((\\<^bold>g [^] w, g' [^] w), w)\n          in \\<A> h \\<bind>\n             (\\<lambda>w'.\n                 return_spmf\n                  ([w = w'] (mod order \\<G>) \\<and>\n                   [x *\n                    w = x * w'] (mod order \\<G>)))) ELSE return_spmf False =\n  local.dis_log_alt.dis_log3 \\<A>\n\ngoal (1 subgoal):\n 1. chaum_ped_\\<Sigma>_commit.rel_advantage \\<A> =\n    local.dis_log_alt.advantage3 \\<A>", "by(simp add: chaum_ped_\\<Sigma>_commit.rel_advantage_def dis_log_alt.advantage3_def)"], ["proof (state)\nthis:\n  chaum_ped_\\<Sigma>_commit.rel_advantage \\<A> =\n  local.dis_log_alt.advantage3 \\<A>\n\ngoal (1 subgoal):\n 1. chaum_ped_\\<Sigma>_commit.rel_advantage \\<A> =\n    local.dis_log.advantage (local.dis_log_alt.adversary3 \\<A>)", "thus ?thesis"], ["proof (prove)\nusing this:\n  chaum_ped_\\<Sigma>_commit.rel_advantage \\<A> =\n  local.dis_log_alt.advantage3 \\<A>\n\ngoal (1 subgoal):\n 1. chaum_ped_\\<Sigma>_commit.rel_advantage \\<A> =\n    local.dis_log.advantage (local.dis_log_alt.adversary3 \\<A>)", "by (simp add: dis_log_alt_reductions.dis_log_adv3 cyclic_group_axioms dis_log_alt.dis_log_alt_axioms dis_log_alt_reductions.intro)"], ["proof (state)\nthis:\n  chaum_ped_\\<Sigma>_commit.rel_advantage \\<A> =\n  local.dis_log.advantage (local.dis_log_alt.adversary3 \\<A>)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma commitment_correct: \"chaum_ped_\\<Sigma>_commit.abstract_com.correct\""], ["proof (prove)\ngoal (1 subgoal):\n 1. chaum_ped_\\<Sigma>_commit.abstract_com.correct", "by(simp add: chaum_ped_\\<Sigma>_commit.commit_correct)"], ["", "lemma  \"chaum_ped_\\<Sigma>_commit.abstract_com.perfect_hiding_ind_cpa \\<A>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. chaum_ped_\\<Sigma>_commit.abstract_com.perfect_hiding_ind_cpa \\<A>", "using chaum_ped_\\<Sigma>_commit.perfect_hiding"], ["proof (prove)\nusing this:\n  chaum_ped_\\<Sigma>_commit.abstract_com.perfect_hiding_ind_cpa ?\\<A>\n\ngoal (1 subgoal):\n 1. chaum_ped_\\<Sigma>_commit.abstract_com.perfect_hiding_ind_cpa \\<A>", "by blast"], ["", "lemma binding: \"chaum_ped_\\<Sigma>_commit.abstract_com.bind_advantage \\<A> \\<le> dis_log.advantage (dis_log_alt.adversary3 ((chaum_ped_\\<Sigma>_commit.adversary \\<A>)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. chaum_ped_\\<Sigma>_commit.abstract_com.bind_advantage \\<A>\n    \\<le> local.dis_log.advantage\n           (local.dis_log_alt.adversary3\n             (chaum_ped_\\<Sigma>_commit.adversary \\<A>))", "using chaum_ped_\\<Sigma>_commit.bind_advantage reduction_to_dis_log"], ["proof (prove)\nusing this:\n  chaum_ped_\\<Sigma>_commit.abstract_com.bind_advantage ?\\<A>\n  \\<le> chaum_ped_\\<Sigma>_commit.rel_advantage\n         (chaum_ped_\\<Sigma>_commit.adversary ?\\<A>)\n  chaum_ped_\\<Sigma>_commit.rel_advantage ?\\<A> =\n  local.dis_log.advantage (local.dis_log_alt.adversary3 ?\\<A>)\n\ngoal (1 subgoal):\n 1. chaum_ped_\\<Sigma>_commit.abstract_com.bind_advantage \\<A>\n    \\<le> local.dis_log.advantage\n           (local.dis_log_alt.adversary3\n             (chaum_ped_\\<Sigma>_commit.adversary \\<A>))", "by simp"], ["", "end"], ["", "locale chaum_ped_asymp = \n  fixes \\<G> :: \"nat \\<Rightarrow> 'grp cyclic_group\"\n    and x :: nat\n  assumes cp_\\<Sigma>: \"\\<And>\\<eta>. chaum_ped_\\<Sigma> (\\<G> \\<eta>)\"\nbegin"], ["", "sublocale chaum_ped_\\<Sigma> \"\\<G> \\<eta>\" for \\<eta>"], ["proof (prove)\ngoal (1 subgoal):\n 1. chaum_ped_\\<Sigma> (\\<G> \\<eta>)", "by(simp add: cp_\\<Sigma>)"], ["", "text\\<open>The \\<open>\\<Sigma>\\<close>-protocol statement comes easily in the asympotic setting.\\<close>"], ["", "theorem sigma_protocol:\n  shows \"chaum_ped_sigma.\\<Sigma>_protocol n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. chaum_ped_sigma.\\<Sigma>_protocol n", "by(simp add: \\<Sigma>_protocol)"], ["", "text\\<open>We now show the statements of security for the commitment scheme in the asymptotic setting, the main difference is that\nwe are able to show the binding advantage is negligible in the security parameter.\\<close>"], ["", "lemma asymp_correct: \"chaum_ped_\\<Sigma>_commit.abstract_com.correct n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. chaum_ped_\\<Sigma>_commit.abstract_com.correct n", "using  chaum_ped_\\<Sigma>_commit.commit_correct"], ["proof (prove)\nusing this:\n  chaum_ped_\\<Sigma>_commit.abstract_com.correct ?\\<eta>\n\ngoal (1 subgoal):\n 1. chaum_ped_\\<Sigma>_commit.abstract_com.correct n", "by simp"], ["", "lemma asymp_perfect_hiding: \"chaum_ped_\\<Sigma>_commit.abstract_com.perfect_hiding_ind_cpa n (\\<A> n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. chaum_ped_\\<Sigma>_commit.abstract_com.perfect_hiding_ind_cpa n (\\<A> n)", "using chaum_ped_\\<Sigma>_commit.perfect_hiding"], ["proof (prove)\nusing this:\n  chaum_ped_\\<Sigma>_commit.abstract_com.perfect_hiding_ind_cpa ?\\<eta>\n   ?\\<A>\n\ngoal (1 subgoal):\n 1. chaum_ped_\\<Sigma>_commit.abstract_com.perfect_hiding_ind_cpa n (\\<A> n)", "by blast"], ["", "lemma asymp_computational_binding: \n  assumes \"negligible (\\<lambda> n. dis_log.advantage n (dis_log_alt.adversary3 n ((chaum_ped_\\<Sigma>_commit.adversary n (\\<A> n)))))\"\n  shows \"negligible (\\<lambda> n. chaum_ped_\\<Sigma>_commit.abstract_com.bind_advantage n (\\<A> n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Negligible.negligible\n     (\\<lambda>n.\n         chaum_ped_\\<Sigma>_commit.abstract_com.bind_advantage n (\\<A> n))", "using chaum_ped_\\<Sigma>_commit.bind_advantage assms chaum_ped_\\<Sigma>_commit.abstract_com.bind_advantage_def negligible_le binding"], ["proof (prove)\nusing this:\n  chaum_ped_\\<Sigma>_commit.abstract_com.bind_advantage ?\\<eta> ?\\<A>\n  \\<le> chaum_ped_\\<Sigma>_commit.rel_advantage ?\\<eta>\n         (chaum_ped_\\<Sigma>_commit.adversary ?\\<eta> ?\\<A>)\n  Negligible.negligible\n   (\\<lambda>n.\n       local.dis_log.advantage n\n        (local.dis_log_alt.adversary3 n\n          (chaum_ped_\\<Sigma>_commit.adversary n (\\<A> n))))\n  chaum_ped_\\<Sigma>_commit.abstract_com.bind_advantage ?\\<eta>\n   ?\\<A> \\<equiv>\n  spmf (chaum_ped_\\<Sigma>_commit.abstract_com.bind_game ?\\<eta> ?\\<A>) True\n  \\<lbrakk>Negligible.negligible ?g;\n   \\<And>\\<eta>. \\<bar>?f \\<eta>\\<bar> \\<le> ?g \\<eta>\\<rbrakk>\n  \\<Longrightarrow> Negligible.negligible ?f\n  chaum_ped_\\<Sigma>_commit.abstract_com.bind_advantage ?\\<eta> ?\\<A>\n  \\<le> local.dis_log.advantage ?\\<eta>\n         (local.dis_log_alt.adversary3 ?\\<eta>\n           (chaum_ped_\\<Sigma>_commit.adversary ?\\<eta> ?\\<A>))\n\ngoal (1 subgoal):\n 1. Negligible.negligible\n     (\\<lambda>n.\n         chaum_ped_\\<Sigma>_commit.abstract_com.bind_advantage n (\\<A> n))", "by auto"], ["", "end"], ["", "end"]]}