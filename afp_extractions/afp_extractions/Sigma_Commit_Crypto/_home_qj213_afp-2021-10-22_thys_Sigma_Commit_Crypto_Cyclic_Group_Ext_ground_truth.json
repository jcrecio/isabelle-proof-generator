{"file_name": "/home/qj213/afp-2021-10-22/thys/Sigma_Commit_Crypto/Cyclic_Group_Ext.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Sigma_Commit_Crypto", "problem_names": ["lemma generator_pow_order: \"\\<^bold>g [^] order G = \\<one>\"", "lemma generator_pow_mult_order: \"\\<^bold>g [^] (order G * order G) = \\<one>\"", "lemma pow_generator_mod: \"\\<^bold>g [^] (k mod order G) = \\<^bold>g [^] k\"", "lemma pow_carrier_mod: \n  assumes \"g \\<in> carrier G\"\n  shows \"g [^] (k mod order G) = g [^] k\"", "lemma pow_generator_mod_int: \"\\<^bold>g [^] ((k::int) mod order G) = \\<^bold>g [^] k\"", "lemma pow_generator_eq_iff_cong:\n  \"finite (carrier G) \\<Longrightarrow> \\<^bold>g [^] x = \\<^bold>g [^] y \\<longleftrightarrow> [x = y] (mod order G)\"", "lemma power_distrib: \n  assumes \"h \\<in> carrier G\" \n  shows \"\\<^bold>g [^] (e :: nat) \\<otimes> h [^] e = (\\<^bold>g \\<otimes> h ) [^] e\"\n(is \"?lhs = ?rhs\")", "lemma neg_power_inverse:\n  assumes \"g \\<in> carrier G\" \n    and \"x < order G\"\n  shows \"g [^] (order G - (x :: nat)) = inv (g [^] x)\"", "lemma int_nat_pow: assumes \"a \\<ge> 0\" shows \"(\\<^bold>g [^] (int (a ::nat))) [^] (b::int)  = \\<^bold>g [^] (a*b)\"", "lemma pow_gen_mod_mult:\n  shows\"(\\<^bold>g [^] (a::nat) \\<otimes> \\<^bold>g [^] (b::nat)) [^] ((c::int)*int (d::nat)) = (\\<^bold>g [^] a \\<otimes> \\<^bold>g [^] b) [^] ((c*int d) mod (order G))\"", "lemma cyclic_group_commute: assumes \"a \\<in> carrier G\" \"b \\<in> carrier G\" shows \"a \\<otimes> b = b \\<otimes> a\"\n(is \"?lhs = ?rhs\")", "lemma cyclic_group_assoc: \n  assumes \"a \\<in> carrier G\" \"b \\<in> carrier G\" \"c \\<in> carrier G\"\n  shows \"(a \\<otimes> b) \\<otimes> c = a \\<otimes> (b \\<otimes> c)\"\n(is \"?lhs = ?rhs\")", "lemma l_cancel_inv: \n  assumes \"h \\<in> carrier G\" \n  shows \"(\\<^bold>g [^] (a :: nat) \\<otimes> inv (\\<^bold>g [^] a)) \\<otimes> h = h\"\n(is \"?lhs = ?rhs\")", "lemma inverse_split: \n  assumes \"a \\<in> carrier G\" and \"b \\<in> carrier G\"\n  shows \"inv (a \\<otimes> b) = inv a \\<otimes> inv b\"", "lemma inverse_pow_pow:\n  assumes \"a \\<in> carrier G\"\n  shows \"inv (a [^] (r::nat)) = (inv a) [^] r\"", "lemma l_neq_1_exp_neq_0:\n  assumes \"l \\<in> carrier G\" \n    and \"l \\<noteq> \\<one>\" \n    and \"l = \\<^bold>g [^] (t::nat)\" \n  shows \"t \\<noteq> 0\"", "lemma order_gt_1_gen_not_1:\n  assumes \"order G > 1\"\n  shows \"\\<^bold>g \\<noteq> \\<one>\"", "lemma power_swap: \"((\\<^bold>g [^] (\\<alpha>0::nat)) [^] (r::nat)) = ((\\<^bold>g [^] r) [^] \\<alpha>0)\"\n(is \"?lhs = ?rhs\")", "lemma gen_power_0:\n  fixes r :: nat \n  assumes \"\\<^bold>g [^] r = \\<one>\" \n    and \"r < order G\"\n  shows \"r = 0\"", "lemma group_eq_pow_eq_mod: \n  fixes a b :: nat \n  assumes \"\\<^bold>g [^] a = \\<^bold>g [^] b\" \n    and \"order G > 0\"\n  shows \"[a = b] (mod order G)\""], "translations": [["", "lemma generator_pow_order: \"\\<^bold>g [^] order G = \\<one>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<^bold>g [^] order G = \\<one>", "proof(cases \"order G > 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 < order G \\<Longrightarrow> \\<^bold>g [^] order G = \\<one>\n 2. \\<not> 0 < order G \\<Longrightarrow> \\<^bold>g [^] order G = \\<one>", "case True"], ["proof (state)\nthis:\n  0 < order G\n\ngoal (2 subgoals):\n 1. 0 < order G \\<Longrightarrow> \\<^bold>g [^] order G = \\<one>\n 2. \\<not> 0 < order G \\<Longrightarrow> \\<^bold>g [^] order G = \\<one>", "hence fin: \"finite (carrier G)\""], ["proof (prove)\nusing this:\n  0 < order G\n\ngoal (1 subgoal):\n 1. finite (carrier G)", "by(simp add: order_gt_0_iff_finite)"], ["proof (state)\nthis:\n  finite (carrier G)\n\ngoal (2 subgoals):\n 1. 0 < order G \\<Longrightarrow> \\<^bold>g [^] order G = \\<one>\n 2. \\<not> 0 < order G \\<Longrightarrow> \\<^bold>g [^] order G = \\<one>", "then"], ["proof (chain)\npicking this:\n  finite (carrier G)", "have [symmetric]: \"(\\<lambda>x. x \\<otimes> \\<^bold>g) ` carrier G = carrier G\""], ["proof (prove)\nusing this:\n  finite (carrier G)\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. x \\<otimes> \\<^bold>g) ` carrier G = carrier G", "by(rule endo_inj_surj)(auto simp add: inj_on_multc)"], ["proof (state)\nthis:\n  carrier G = (\\<lambda>x. x \\<otimes> \\<^bold>g) ` carrier G\n\ngoal (2 subgoals):\n 1. 0 < order G \\<Longrightarrow> \\<^bold>g [^] order G = \\<one>\n 2. \\<not> 0 < order G \\<Longrightarrow> \\<^bold>g [^] order G = \\<one>", "then"], ["proof (chain)\npicking this:\n  carrier G = (\\<lambda>x. x \\<otimes> \\<^bold>g) ` carrier G", "have \"carrier G = (\\<lambda> n. \\<^bold>g [^] Suc n) ` {..<order G}\""], ["proof (prove)\nusing this:\n  carrier G = (\\<lambda>x. x \\<otimes> \\<^bold>g) ` carrier G\n\ngoal (1 subgoal):\n 1. carrier G = (\\<lambda>n. \\<^bold>g [^] Suc n) ` {..<order G}", "using fin"], ["proof (prove)\nusing this:\n  carrier G = (\\<lambda>x. x \\<otimes> \\<^bold>g) ` carrier G\n  finite (carrier G)\n\ngoal (1 subgoal):\n 1. carrier G = (\\<lambda>n. \\<^bold>g [^] Suc n) ` {..<order G}", "by(simp add: carrier_conv_generator image_image)"], ["proof (state)\nthis:\n  carrier G = (\\<lambda>n. \\<^bold>g [^] Suc n) ` {..<order G}\n\ngoal (2 subgoals):\n 1. 0 < order G \\<Longrightarrow> \\<^bold>g [^] order G = \\<one>\n 2. \\<not> 0 < order G \\<Longrightarrow> \\<^bold>g [^] order G = \\<one>", "then"], ["proof (chain)\npicking this:\n  carrier G = (\\<lambda>n. \\<^bold>g [^] Suc n) ` {..<order G}", "obtain n where n: \"\\<one> = \\<^bold>g [^] Suc n\" \"n < order G\""], ["proof (prove)\nusing this:\n  carrier G = (\\<lambda>n. \\<^bold>g [^] Suc n) ` {..<order G}\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        \\<lbrakk>\\<one> = \\<^bold>g [^] Suc n; n < order G\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  \\<one> = \\<^bold>g [^] Suc n\n  n < order G\n\ngoal (2 subgoals):\n 1. 0 < order G \\<Longrightarrow> \\<^bold>g [^] order G = \\<one>\n 2. \\<not> 0 < order G \\<Longrightarrow> \\<^bold>g [^] order G = \\<one>", "have \"n = order G - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n = order G - 1", "using n inj_onD[OF inj_on_generator, of 0 \"Suc n\"]"], ["proof (prove)\nusing this:\n  \\<one> = \\<^bold>g [^] Suc n\n  n < order G\n  \\<lbrakk>\\<^bold>g [^] 0 = \\<^bold>g [^] Suc n; 0 \\<in> {..<order G};\n   Suc n \\<in> {..<order G}\\<rbrakk>\n  \\<Longrightarrow> 0 = Suc n\n\ngoal (1 subgoal):\n 1. n = order G - 1", "by fastforce"], ["proof (state)\nthis:\n  n = order G - 1\n\ngoal (2 subgoals):\n 1. 0 < order G \\<Longrightarrow> \\<^bold>g [^] order G = \\<one>\n 2. \\<not> 0 < order G \\<Longrightarrow> \\<^bold>g [^] order G = \\<one>", "with True n"], ["proof (chain)\npicking this:\n  0 < order G\n  \\<one> = \\<^bold>g [^] Suc n\n  n < order G\n  n = order G - 1", "show ?thesis"], ["proof (prove)\nusing this:\n  0 < order G\n  \\<one> = \\<^bold>g [^] Suc n\n  n < order G\n  n = order G - 1\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^] order G = \\<one>", "by auto"], ["proof (state)\nthis:\n  \\<^bold>g [^] order G = \\<one>\n\ngoal (1 subgoal):\n 1. \\<not> 0 < order G \\<Longrightarrow> \\<^bold>g [^] order G = \\<one>", "qed simp"], ["", "lemma generator_pow_mult_order: \"\\<^bold>g [^] (order G * order G) = \\<one>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<^bold>g [^] (order G * order G) = \\<one>", "using generator_pow_order"], ["proof (prove)\nusing this:\n  \\<^bold>g [^] order G = \\<one>\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^] (order G * order G) = \\<one>", "by (metis generator_closed nat_pow_one nat_pow_pow)"], ["", "lemma pow_generator_mod: \"\\<^bold>g [^] (k mod order G) = \\<^bold>g [^] k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<^bold>g [^] (k mod order G) = \\<^bold>g [^] k", "proof(cases \"order G > 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 < order G \\<Longrightarrow>\n    \\<^bold>g [^] (k mod order G) = \\<^bold>g [^] k\n 2. \\<not> 0 < order G \\<Longrightarrow>\n    \\<^bold>g [^] (k mod order G) = \\<^bold>g [^] k", "case True"], ["proof (state)\nthis:\n  0 < order G\n\ngoal (2 subgoals):\n 1. 0 < order G \\<Longrightarrow>\n    \\<^bold>g [^] (k mod order G) = \\<^bold>g [^] k\n 2. \\<not> 0 < order G \\<Longrightarrow>\n    \\<^bold>g [^] (k mod order G) = \\<^bold>g [^] k", "obtain n where n: \"k = n * order G + k mod order G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>n.\n        k = n * order G + k mod order G \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis div_mult_mod_eq)"], ["proof (state)\nthis:\n  k = n * order G + k mod order G\n\ngoal (2 subgoals):\n 1. 0 < order G \\<Longrightarrow>\n    \\<^bold>g [^] (k mod order G) = \\<^bold>g [^] k\n 2. \\<not> 0 < order G \\<Longrightarrow>\n    \\<^bold>g [^] (k mod order G) = \\<^bold>g [^] k", "have \"\\<^bold>g [^] k = (\\<^bold>g [^] order G) [^] n \\<otimes> \\<^bold>g [^] (k mod order G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<^bold>g [^] k =\n    (\\<^bold>g [^] order G) [^] n \\<otimes> \\<^bold>g [^] (k mod order G)", "by(subst n)(simp add: nat_pow_mult nat_pow_pow mult_ac)"], ["proof (state)\nthis:\n  \\<^bold>g [^] k =\n  (\\<^bold>g [^] order G) [^] n \\<otimes> \\<^bold>g [^] (k mod order G)\n\ngoal (2 subgoals):\n 1. 0 < order G \\<Longrightarrow>\n    \\<^bold>g [^] (k mod order G) = \\<^bold>g [^] k\n 2. \\<not> 0 < order G \\<Longrightarrow>\n    \\<^bold>g [^] (k mod order G) = \\<^bold>g [^] k", "then"], ["proof (chain)\npicking this:\n  \\<^bold>g [^] k =\n  (\\<^bold>g [^] order G) [^] n \\<otimes> \\<^bold>g [^] (k mod order G)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<^bold>g [^] k =\n  (\\<^bold>g [^] order G) [^] n \\<otimes> \\<^bold>g [^] (k mod order G)\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^] (k mod order G) = \\<^bold>g [^] k", "by(simp add: generator_pow_order)"], ["proof (state)\nthis:\n  \\<^bold>g [^] (k mod order G) = \\<^bold>g [^] k\n\ngoal (1 subgoal):\n 1. \\<not> 0 < order G \\<Longrightarrow>\n    \\<^bold>g [^] (k mod order G) = \\<^bold>g [^] k", "qed simp"], ["", "lemma pow_carrier_mod: \n  assumes \"g \\<in> carrier G\"\n  shows \"g [^] (k mod order G) = g [^] k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g [^] (k mod order G) = g [^] k", "using assms pow_generator_mod"], ["proof (prove)\nusing this:\n  g \\<in> carrier G\n  \\<^bold>g [^] (?k mod order G) = \\<^bold>g [^] ?k\n\ngoal (1 subgoal):\n 1. g [^] (k mod order G) = g [^] k", "by (metis generatorE generator_closed mod_mult_right_eq nat_pow_pow)"], ["", "lemma pow_generator_mod_int: \"\\<^bold>g [^] ((k::int) mod order G) = \\<^bold>g [^] k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<^bold>g [^] (k mod int (order G)) = \\<^bold>g [^] k", "proof(cases \"order G > 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 < order G \\<Longrightarrow>\n    \\<^bold>g [^] (k mod int (order G)) = \\<^bold>g [^] k\n 2. \\<not> 0 < order G \\<Longrightarrow>\n    \\<^bold>g [^] (k mod int (order G)) = \\<^bold>g [^] k", "case True"], ["proof (state)\nthis:\n  0 < order G\n\ngoal (2 subgoals):\n 1. 0 < order G \\<Longrightarrow>\n    \\<^bold>g [^] (k mod int (order G)) = \\<^bold>g [^] k\n 2. \\<not> 0 < order G \\<Longrightarrow>\n    \\<^bold>g [^] (k mod int (order G)) = \\<^bold>g [^] k", "obtain n :: int where n: \"k = n * order G + k mod order G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>n.\n        k = n * int (order G) + k mod int (order G) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis div_mult_mod_eq)"], ["proof (state)\nthis:\n  k = n * int (order G) + k mod int (order G)\n\ngoal (2 subgoals):\n 1. 0 < order G \\<Longrightarrow>\n    \\<^bold>g [^] (k mod int (order G)) = \\<^bold>g [^] k\n 2. \\<not> 0 < order G \\<Longrightarrow>\n    \\<^bold>g [^] (k mod int (order G)) = \\<^bold>g [^] k", "have \"\\<^bold>g [^] k = (\\<^bold>g [^] order G) [^] n \\<otimes> \\<^bold>g [^] (k mod order G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<^bold>g [^] k =\n    (\\<^bold>g [^] order G) [^] n \\<otimes>\n    \\<^bold>g [^] (k mod int (order G))", "apply(subst n)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<^bold>g [^] (n * int (order G) + k mod int (order G)) =\n    (\\<^bold>g [^] order G) [^] n \\<otimes>\n    \\<^bold>g [^] (k mod int (order G))", "apply(simp add: int_pow_mult int_pow_pow mult_ac)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<^bold>g [^] (n * int (order G)) = (\\<^bold>g [^] order G) [^] n", "by (metis generator_closed int_pow_int int_pow_pow mult.commute)"], ["proof (state)\nthis:\n  \\<^bold>g [^] k =\n  (\\<^bold>g [^] order G) [^] n \\<otimes>\n  \\<^bold>g [^] (k mod int (order G))\n\ngoal (2 subgoals):\n 1. 0 < order G \\<Longrightarrow>\n    \\<^bold>g [^] (k mod int (order G)) = \\<^bold>g [^] k\n 2. \\<not> 0 < order G \\<Longrightarrow>\n    \\<^bold>g [^] (k mod int (order G)) = \\<^bold>g [^] k", "then"], ["proof (chain)\npicking this:\n  \\<^bold>g [^] k =\n  (\\<^bold>g [^] order G) [^] n \\<otimes>\n  \\<^bold>g [^] (k mod int (order G))", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<^bold>g [^] k =\n  (\\<^bold>g [^] order G) [^] n \\<otimes>\n  \\<^bold>g [^] (k mod int (order G))\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^] (k mod int (order G)) = \\<^bold>g [^] k", "by(simp add: generator_pow_order)"], ["proof (state)\nthis:\n  \\<^bold>g [^] (k mod int (order G)) = \\<^bold>g [^] k\n\ngoal (1 subgoal):\n 1. \\<not> 0 < order G \\<Longrightarrow>\n    \\<^bold>g [^] (k mod int (order G)) = \\<^bold>g [^] k", "qed simp"], ["", "lemma pow_generator_eq_iff_cong:\n  \"finite (carrier G) \\<Longrightarrow> \\<^bold>g [^] x = \\<^bold>g [^] y \\<longleftrightarrow> [x = y] (mod order G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (carrier G) \\<Longrightarrow>\n    (\\<^bold>g [^] x = \\<^bold>g [^] y) = [x = y] (mod order G)", "apply(subst (1 2) pow_generator_mod[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (carrier G) \\<Longrightarrow>\n    (\\<^bold>g [^] (x mod order G) = \\<^bold>g [^] (y mod order G)) =\n    [x = y] (mod order G)", "by(auto simp add: cong_def order_gt_0_iff_finite intro: inj_onD[OF inj_on_generator])"], ["", "lemma power_distrib: \n  assumes \"h \\<in> carrier G\" \n  shows \"\\<^bold>g [^] (e :: nat) \\<otimes> h [^] e = (\\<^bold>g \\<otimes> h ) [^] e\"\n(is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<^bold>g [^] e \\<otimes> h [^] e = (\\<^bold>g \\<otimes> h) [^] e", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<^bold>g [^] e \\<otimes> h [^] e = (\\<^bold>g \\<otimes> h) [^] e", "obtain x :: nat where x: \"h = \\<^bold>g [^] x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x.\n        h = \\<^bold>g [^] x \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms generatorE"], ["proof (prove)\nusing this:\n  h \\<in> carrier G\n  \\<lbrakk>?x \\<in> carrier G;\n   \\<And>n. ?x = \\<^bold>g [^] n \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        h = \\<^bold>g [^] x \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  h = \\<^bold>g [^] x\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^] e \\<otimes> h [^] e = (\\<^bold>g \\<otimes> h) [^] e", "hence \"?lhs = \\<^bold>g [^] (e * (1 + x))\""], ["proof (prove)\nusing this:\n  h = \\<^bold>g [^] x\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^] e \\<otimes> h [^] e = \\<^bold>g [^] (e * (1 + x))", "by (simp add: nat_pow_mult mult.commute nat_pow_pow)"], ["proof (state)\nthis:\n  \\<^bold>g [^] e \\<otimes> h [^] e = \\<^bold>g [^] (e * (1 + x))\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^] e \\<otimes> h [^] e = (\\<^bold>g \\<otimes> h) [^] e", "also"], ["proof (state)\nthis:\n  \\<^bold>g [^] e \\<otimes> h [^] e = \\<^bold>g [^] (e * (1 + x))\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^] e \\<otimes> h [^] e = (\\<^bold>g \\<otimes> h) [^] e", "have \"... = (\\<^bold>g [^] (1 + x)) [^] e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<^bold>g [^] (e * (1 + x)) = (\\<^bold>g [^] (1 + x)) [^] e", "by (metis generator_closed mult.commute nat_pow_pow)"], ["proof (state)\nthis:\n  \\<^bold>g [^] (e * (1 + x)) = (\\<^bold>g [^] (1 + x)) [^] e\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^] e \\<otimes> h [^] e = (\\<^bold>g \\<otimes> h) [^] e", "ultimately"], ["proof (chain)\npicking this:\n  \\<^bold>g [^] e \\<otimes> h [^] e = \\<^bold>g [^] (e * (1 + x))\n  \\<^bold>g [^] (e * (1 + x)) = (\\<^bold>g [^] (1 + x)) [^] e", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<^bold>g [^] e \\<otimes> h [^] e = \\<^bold>g [^] (e * (1 + x))\n  \\<^bold>g [^] (e * (1 + x)) = (\\<^bold>g [^] (1 + x)) [^] e\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^] e \\<otimes> h [^] e = (\\<^bold>g \\<otimes> h) [^] e", "by (metis x One_nat_def generator_closed l_one monoid.nat_pow_Suc monoid_axioms nat_pow_0 nat_pow_mult)"], ["proof (state)\nthis:\n  \\<^bold>g [^] e \\<otimes> h [^] e = (\\<^bold>g \\<otimes> h) [^] e\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma neg_power_inverse:\n  assumes \"g \\<in> carrier G\" \n    and \"x < order G\"\n  shows \"g [^] (order G - (x :: nat)) = inv (g [^] x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g [^] (order G - x) = inv (g [^] x)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. g [^] (order G - x) = inv (g [^] x)", "have \"inv (g [^] x) = g [^] (- int x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv (g [^] x) = g [^] - int x", "by (simp add: int_pow_int int_pow_neg assms)"], ["proof (state)\nthis:\n  inv (g [^] x) = g [^] - int x\n\ngoal (1 subgoal):\n 1. g [^] (order G - x) = inv (g [^] x)", "moreover"], ["proof (state)\nthis:\n  inv (g [^] x) = g [^] - int x\n\ngoal (1 subgoal):\n 1. g [^] (order G - x) = inv (g [^] x)", "have \"g [^] (order G - (x :: nat)) = g [^] (- int x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g [^] (order G - x) = g [^] - int x", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. g [^] (order G - x) = g [^] - int x", "have \"g [^] ((order G - (x :: nat)) mod (order G)) = g [^] ((- int x) mod (order G))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g [^] ((order G - x) mod order G) = g [^] (- int x mod int (order G))", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. g [^] ((order G - x) mod order G) = g [^] (- int x mod int (order G))", "have \"(order G - (x :: nat)) mod (order G) = (- int x) mod (order G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int ((order G - x) mod order G) = - int x mod int (order G)", "using assms(2) zmod_zminus1_eq_if"], ["proof (prove)\nusing this:\n  x < order G\n  - ?a mod ?b = (if ?a mod ?b = 0 then 0 else ?b - ?a mod ?b)\n\ngoal (1 subgoal):\n 1. int ((order G - x) mod order G) = - int x mod int (order G)", "by auto"], ["proof (state)\nthis:\n  int ((order G - x) mod order G) = - int x mod int (order G)\n\ngoal (1 subgoal):\n 1. g [^] ((order G - x) mod order G) = g [^] (- int x mod int (order G))", "thus ?thesis"], ["proof (prove)\nusing this:\n  int ((order G - x) mod order G) = - int x mod int (order G)\n\ngoal (1 subgoal):\n 1. g [^] ((order G - x) mod order G) = g [^] (- int x mod int (order G))", "by (metis int_pow_int)"], ["proof (state)\nthis:\n  g [^] ((order G - x) mod order G) = g [^] (- int x mod int (order G))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  g [^] ((order G - x) mod order G) = g [^] (- int x mod int (order G))\n\ngoal (1 subgoal):\n 1. g [^] (order G - x) = g [^] - int x", "thus ?thesis"], ["proof (prove)\nusing this:\n  g [^] ((order G - x) mod order G) = g [^] (- int x mod int (order G))\n\ngoal (1 subgoal):\n 1. g [^] (order G - x) = g [^] - int x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. g [^] ((order G - x) mod order G) =\n    g [^] (- int x mod int (order G)) \\<Longrightarrow>\n    g [^] (order G - x) = g [^] - int x", "have f1: \"\\<forall>a. a [^] int 0 = \\<one>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a. a [^] int 0 = \\<one>", "by simp"], ["proof (state)\nthis:\n  \\<forall>a. a [^] int 0 = \\<one>\n\ngoal (1 subgoal):\n 1. g [^] ((order G - x) mod order G) =\n    g [^] (- int x mod int (order G)) \\<Longrightarrow>\n    g [^] (order G - x) = g [^] - int x", "have f2: \"\\<forall>n na. ((na::nat) + n) mod na = n mod na\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n na. (na + n) mod na = n mod na", "by simp"], ["proof (state)\nthis:\n  \\<forall>n na. (na + n) mod na = n mod na\n\ngoal (1 subgoal):\n 1. g [^] ((order G - x) mod order G) =\n    g [^] (- int x mod int (order G)) \\<Longrightarrow>\n    g [^] (order G - x) = g [^] - int x", "have f3: \"\\<forall>a aa. aa \\<otimes> a [^] int 0 = aa \\<or> aa \\<notin> carrier G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a aa. aa \\<otimes> a [^] int 0 = aa \\<or> aa \\<notin> carrier G", "by force"], ["proof (state)\nthis:\n  \\<forall>a aa. aa \\<otimes> a [^] int 0 = aa \\<or> aa \\<notin> carrier G\n\ngoal (1 subgoal):\n 1. g [^] ((order G - x) mod order G) =\n    g [^] (- int x mod int (order G)) \\<Longrightarrow>\n    g [^] (order G - x) = g [^] - int x", "have f4: \"\\<forall>i a aa. a [^] int 0 \\<otimes> aa [^] i = aa [^] (int 0 + i) \\<or> aa \\<notin> carrier G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i a aa.\n       a [^] int 0 \\<otimes> aa [^] i = aa [^] (int 0 + i) \\<or>\n       aa \\<notin> carrier G", "by force"], ["proof (state)\nthis:\n  \\<forall>i a aa.\n     a [^] int 0 \\<otimes> aa [^] i = aa [^] (int 0 + i) \\<or>\n     aa \\<notin> carrier G\n\ngoal (1 subgoal):\n 1. g [^] ((order G - x) mod order G) =\n    g [^] (- int x mod int (order G)) \\<Longrightarrow>\n    g [^] (order G - x) = g [^] - int x", "have \"\\<forall>n a. a [^] int (n * 0) = a [^] (int 0 + int 0) \\<or> a \\<notin> carrier G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n a.\n       a [^] int (n * 0) = a [^] (int 0 + int 0) \\<or> a \\<notin> carrier G", "by simp"], ["proof (state)\nthis:\n  \\<forall>n a.\n     a [^] int (n * 0) = a [^] (int 0 + int 0) \\<or> a \\<notin> carrier G\n\ngoal (1 subgoal):\n 1. g [^] ((order G - x) mod order G) =\n    g [^] (- int x mod int (order G)) \\<Longrightarrow>\n    g [^] (order G - x) = g [^] - int x", "then"], ["proof (chain)\npicking this:\n  \\<forall>n a.\n     a [^] int (n * 0) = a [^] (int 0 + int 0) \\<or> a \\<notin> carrier G", "have f5: \"\\<forall>a aa. aa [^] int (order G) = a [^] int 0 \\<or> aa \\<notin> carrier G\""], ["proof (prove)\nusing this:\n  \\<forall>n a.\n     a [^] int (n * 0) = a [^] (int 0 + int 0) \\<or> a \\<notin> carrier G\n\ngoal (1 subgoal):\n 1. \\<forall>a aa.\n       aa [^] int (order G) = a [^] int 0 \\<or> aa \\<notin> carrier G", "using f4 f3 f2 f1"], ["proof (prove)\nusing this:\n  \\<forall>n a.\n     a [^] int (n * 0) = a [^] (int 0 + int 0) \\<or> a \\<notin> carrier G\n  \\<forall>i a aa.\n     a [^] int 0 \\<otimes> aa [^] i = aa [^] (int 0 + i) \\<or>\n     aa \\<notin> carrier G\n  \\<forall>a aa. aa \\<otimes> a [^] int 0 = aa \\<or> aa \\<notin> carrier G\n  \\<forall>n na. (na + n) mod na = n mod na\n  \\<forall>a. a [^] int 0 = \\<one>\n\ngoal (1 subgoal):\n 1. \\<forall>a aa.\n       aa [^] int (order G) = a [^] int 0 \\<or> aa \\<notin> carrier G", "by (metis int_pow_closed int_pow_int mod_mult_self2 pow_carrier_mod)"], ["proof (state)\nthis:\n  \\<forall>a aa.\n     aa [^] int (order G) = a [^] int 0 \\<or> aa \\<notin> carrier G\n\ngoal (1 subgoal):\n 1. g [^] ((order G - x) mod order G) =\n    g [^] (- int x mod int (order G)) \\<Longrightarrow>\n    g [^] (order G - x) = g [^] - int x", "have \"\\<forall>n na. int (n - na) = - int na + int n \\<or> \\<not> na \\<le> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n na. int (n - na) = - int na + int n \\<or> \\<not> na \\<le> n", "by auto"], ["proof (state)\nthis:\n  \\<forall>n na. int (n - na) = - int na + int n \\<or> \\<not> na \\<le> n\n\ngoal (1 subgoal):\n 1. g [^] ((order G - x) mod order G) =\n    g [^] (- int x mod int (order G)) \\<Longrightarrow>\n    g [^] (order G - x) = g [^] - int x", "then"], ["proof (chain)\npicking this:\n  \\<forall>n na. int (n - na) = - int na + int n \\<or> \\<not> na \\<le> n", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>n na. int (n - na) = - int na + int n \\<or> \\<not> na \\<le> n\n\ngoal (1 subgoal):\n 1. g [^] (order G - x) = g [^] - int x", "using f5 f3"], ["proof (prove)\nusing this:\n  \\<forall>n na. int (n - na) = - int na + int n \\<or> \\<not> na \\<le> n\n  \\<forall>a aa.\n     aa [^] int (order G) = a [^] int 0 \\<or> aa \\<notin> carrier G\n  \\<forall>a aa. aa \\<otimes> a [^] int 0 = aa \\<or> aa \\<notin> carrier G\n\ngoal (1 subgoal):\n 1. g [^] (order G - x) = g [^] - int x", "by (metis assms(1) assms(2) int_pow_closed int_pow_int int_pow_mult less_imp_le_nat)"], ["proof (state)\nthis:\n  g [^] (order G - x) = g [^] - int x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  g [^] (order G - x) = g [^] - int x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  g [^] (order G - x) = g [^] - int x\n\ngoal (1 subgoal):\n 1. g [^] (order G - x) = inv (g [^] x)", "ultimately"], ["proof (chain)\npicking this:\n  inv (g [^] x) = g [^] - int x\n  g [^] (order G - x) = g [^] - int x", "show ?thesis"], ["proof (prove)\nusing this:\n  inv (g [^] x) = g [^] - int x\n  g [^] (order G - x) = g [^] - int x\n\ngoal (1 subgoal):\n 1. g [^] (order G - x) = inv (g [^] x)", "by simp"], ["proof (state)\nthis:\n  g [^] (order G - x) = inv (g [^] x)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma int_nat_pow: assumes \"a \\<ge> 0\" shows \"(\\<^bold>g [^] (int (a ::nat))) [^] (b::int)  = \\<^bold>g [^] (a*b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<^bold>g [^] int a) [^] b = \\<^bold>g [^] (int a * b)", "using assms"], ["proof (prove)\nusing this:\n  0 \\<le> a\n\ngoal (1 subgoal):\n 1. (\\<^bold>g [^] int a) [^] b = \\<^bold>g [^] (int a * b)", "proof(cases \"a >0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 \\<le> a; 0 < a\\<rbrakk>\n    \\<Longrightarrow> (\\<^bold>g [^] int a) [^] b =\n                      \\<^bold>g [^] (int a * b)\n 2. \\<lbrakk>0 \\<le> a; \\<not> 0 < a\\<rbrakk>\n    \\<Longrightarrow> (\\<^bold>g [^] int a) [^] b =\n                      \\<^bold>g [^] (int a * b)", "case True"], ["proof (state)\nthis:\n  0 < a\n\ngoal (2 subgoals):\n 1. \\<lbrakk>0 \\<le> a; 0 < a\\<rbrakk>\n    \\<Longrightarrow> (\\<^bold>g [^] int a) [^] b =\n                      \\<^bold>g [^] (int a * b)\n 2. \\<lbrakk>0 \\<le> a; \\<not> 0 < a\\<rbrakk>\n    \\<Longrightarrow> (\\<^bold>g [^] int a) [^] b =\n                      \\<^bold>g [^] (int a * b)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<^bold>g [^] int a) [^] b = \\<^bold>g [^] (int a * b)", "using int_pow_pow"], ["proof (prove)\nusing this:\n  ?x \\<in> carrier G \\<Longrightarrow> (?x [^] ?n) [^] ?m = ?x [^] (?n * ?m)\n\ngoal (1 subgoal):\n 1. (\\<^bold>g [^] int a) [^] b = \\<^bold>g [^] (int a * b)", "by blast"], ["proof (state)\nthis:\n  (\\<^bold>g [^] int a) [^] b = \\<^bold>g [^] (int a * b)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 \\<le> a; \\<not> 0 < a\\<rbrakk>\n    \\<Longrightarrow> (\\<^bold>g [^] int a) [^] b =\n                      \\<^bold>g [^] (int a * b)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 \\<le> a; \\<not> 0 < a\\<rbrakk>\n    \\<Longrightarrow> (\\<^bold>g [^] int a) [^] b =\n                      \\<^bold>g [^] (int a * b)", "case False"], ["proof (state)\nthis:\n  \\<not> 0 < a\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 \\<le> a; \\<not> 0 < a\\<rbrakk>\n    \\<Longrightarrow> (\\<^bold>g [^] int a) [^] b =\n                      \\<^bold>g [^] (int a * b)", "have \"(\\<^bold>g [^] (int (a ::nat))) [^] (b::int) = \\<one>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<^bold>g [^] int a) [^] b = \\<one>", "using False"], ["proof (prove)\nusing this:\n  \\<not> 0 < a\n\ngoal (1 subgoal):\n 1. (\\<^bold>g [^] int a) [^] b = \\<one>", "by simp"], ["proof (state)\nthis:\n  (\\<^bold>g [^] int a) [^] b = \\<one>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 \\<le> a; \\<not> 0 < a\\<rbrakk>\n    \\<Longrightarrow> (\\<^bold>g [^] int a) [^] b =\n                      \\<^bold>g [^] (int a * b)", "also"], ["proof (state)\nthis:\n  (\\<^bold>g [^] int a) [^] b = \\<one>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 \\<le> a; \\<not> 0 < a\\<rbrakk>\n    \\<Longrightarrow> (\\<^bold>g [^] int a) [^] b =\n                      \\<^bold>g [^] (int a * b)", "have \"\\<^bold>g [^] (a*b) = \\<one>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<^bold>g [^] (int a * b) = \\<one>", "using False"], ["proof (prove)\nusing this:\n  \\<not> 0 < a\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^] (int a * b) = \\<one>", "by simp"], ["proof (state)\nthis:\n  \\<^bold>g [^] (int a * b) = \\<one>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 \\<le> a; \\<not> 0 < a\\<rbrakk>\n    \\<Longrightarrow> (\\<^bold>g [^] int a) [^] b =\n                      \\<^bold>g [^] (int a * b)", "ultimately"], ["proof (chain)\npicking this:\n  (\\<^bold>g [^] int a) [^] b = \\<one>\n  \\<^bold>g [^] (int a * b) = \\<one>", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<^bold>g [^] int a) [^] b = \\<one>\n  \\<^bold>g [^] (int a * b) = \\<one>\n\ngoal (1 subgoal):\n 1. (\\<^bold>g [^] int a) [^] b = \\<^bold>g [^] (int a * b)", "by simp"], ["proof (state)\nthis:\n  (\\<^bold>g [^] int a) [^] b = \\<^bold>g [^] (int a * b)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma pow_gen_mod_mult:\n  shows\"(\\<^bold>g [^] (a::nat) \\<otimes> \\<^bold>g [^] (b::nat)) [^] ((c::int)*int (d::nat)) = (\\<^bold>g [^] a \\<otimes> \\<^bold>g [^] b) [^] ((c*int d) mod (order G))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<^bold>g [^] a \\<otimes> \\<^bold>g [^] b) [^] (c * int d) =\n    (\\<^bold>g [^] a \\<otimes> \\<^bold>g [^] b) [^]\n    (c * int d mod int (order G))", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<^bold>g [^] a \\<otimes> \\<^bold>g [^] b) [^] (c * int d) =\n    (\\<^bold>g [^] a \\<otimes> \\<^bold>g [^] b) [^]\n    (c * int d mod int (order G))", "have \"(\\<^bold>g [^] (a::nat) \\<otimes> \\<^bold>g [^] (b::nat)) \\<in> carrier G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<^bold>g [^] a \\<otimes> \\<^bold>g [^] b \\<in> carrier G", "by simp"], ["proof (state)\nthis:\n  \\<^bold>g [^] a \\<otimes> \\<^bold>g [^] b \\<in> carrier G\n\ngoal (1 subgoal):\n 1. (\\<^bold>g [^] a \\<otimes> \\<^bold>g [^] b) [^] (c * int d) =\n    (\\<^bold>g [^] a \\<otimes> \\<^bold>g [^] b) [^]\n    (c * int d mod int (order G))", "then"], ["proof (chain)\npicking this:\n  \\<^bold>g [^] a \\<otimes> \\<^bold>g [^] b \\<in> carrier G", "obtain n :: nat where n: \"\\<^bold>g [^] n = (\\<^bold>g [^] (a::nat) \\<otimes> \\<^bold>g [^] (b::nat))\""], ["proof (prove)\nusing this:\n  \\<^bold>g [^] a \\<otimes> \\<^bold>g [^] b \\<in> carrier G\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        \\<^bold>g [^] n =\n        \\<^bold>g [^] a \\<otimes> \\<^bold>g [^] b \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (simp add: monoid.nat_pow_mult)"], ["proof (state)\nthis:\n  \\<^bold>g [^] n = \\<^bold>g [^] a \\<otimes> \\<^bold>g [^] b\n\ngoal (1 subgoal):\n 1. (\\<^bold>g [^] a \\<otimes> \\<^bold>g [^] b) [^] (c * int d) =\n    (\\<^bold>g [^] a \\<otimes> \\<^bold>g [^] b) [^]\n    (c * int d mod int (order G))", "also"], ["proof (state)\nthis:\n  \\<^bold>g [^] n = \\<^bold>g [^] a \\<otimes> \\<^bold>g [^] b\n\ngoal (1 subgoal):\n 1. (\\<^bold>g [^] a \\<otimes> \\<^bold>g [^] b) [^] (c * int d) =\n    (\\<^bold>g [^] a \\<otimes> \\<^bold>g [^] b) [^]\n    (c * int d mod int (order G))", "obtain r where r: \"r = c*int d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>r. r = c * int d \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by simp"], ["proof (state)\nthis:\n  r = c * int d\n\ngoal (1 subgoal):\n 1. (\\<^bold>g [^] a \\<otimes> \\<^bold>g [^] b) [^] (c * int d) =\n    (\\<^bold>g [^] a \\<otimes> \\<^bold>g [^] b) [^]\n    (c * int d mod int (order G))", "have 1: \"(\\<^bold>g [^] (a::nat) \\<otimes> \\<^bold>g [^] (b::nat)) [^] ((c::int)*int (d::nat)) = (\\<^bold>g [^] n) [^] r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<^bold>g [^] a \\<otimes> \\<^bold>g [^] b) [^] (c * int d) =\n    (\\<^bold>g [^] n) [^] r", "using n r"], ["proof (prove)\nusing this:\n  \\<^bold>g [^] n = \\<^bold>g [^] a \\<otimes> \\<^bold>g [^] b\n  r = c * int d\n\ngoal (1 subgoal):\n 1. (\\<^bold>g [^] a \\<otimes> \\<^bold>g [^] b) [^] (c * int d) =\n    (\\<^bold>g [^] n) [^] r", "by simp"], ["proof (state)\nthis:\n  (\\<^bold>g [^] a \\<otimes> \\<^bold>g [^] b) [^] (c * int d) =\n  (\\<^bold>g [^] n) [^] r\n\ngoal (1 subgoal):\n 1. (\\<^bold>g [^] a \\<otimes> \\<^bold>g [^] b) [^] (c * int d) =\n    (\\<^bold>g [^] a \\<otimes> \\<^bold>g [^] b) [^]\n    (c * int d mod int (order G))", "also"], ["proof (state)\nthis:\n  (\\<^bold>g [^] a \\<otimes> \\<^bold>g [^] b) [^] (c * int d) =\n  (\\<^bold>g [^] n) [^] r\n\ngoal (1 subgoal):\n 1. (\\<^bold>g [^] a \\<otimes> \\<^bold>g [^] b) [^] (c * int d) =\n    (\\<^bold>g [^] a \\<otimes> \\<^bold>g [^] b) [^]\n    (c * int d mod int (order G))", "have 2:\"... = (\\<^bold>g [^] n) [^] (r mod (order G))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<^bold>g [^] n) [^] r = (\\<^bold>g [^] n) [^] (r mod int (order G))", "using pow_generator_mod_int pow_generator_mod"], ["proof (prove)\nusing this:\n  \\<^bold>g [^] (?k mod int (order G)) = \\<^bold>g [^] ?k\n  \\<^bold>g [^] (?k mod order G) = \\<^bold>g [^] ?k\n\ngoal (1 subgoal):\n 1. (\\<^bold>g [^] n) [^] r = (\\<^bold>g [^] n) [^] (r mod int (order G))", "by (metis int_nat_pow int_pow_int mod_mult_right_eq zero_le)"], ["proof (state)\nthis:\n  (\\<^bold>g [^] n) [^] r = (\\<^bold>g [^] n) [^] (r mod int (order G))\n\ngoal (1 subgoal):\n 1. (\\<^bold>g [^] a \\<otimes> \\<^bold>g [^] b) [^] (c * int d) =\n    (\\<^bold>g [^] a \\<otimes> \\<^bold>g [^] b) [^]\n    (c * int d mod int (order G))", "also"], ["proof (state)\nthis:\n  (\\<^bold>g [^] n) [^] r = (\\<^bold>g [^] n) [^] (r mod int (order G))\n\ngoal (1 subgoal):\n 1. (\\<^bold>g [^] a \\<otimes> \\<^bold>g [^] b) [^] (c * int d) =\n    (\\<^bold>g [^] a \\<otimes> \\<^bold>g [^] b) [^]\n    (c * int d mod int (order G))", "have 3:\"... =  (\\<^bold>g [^] a \\<otimes> \\<^bold>g [^] b) [^] ((c*int d) mod (order G))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<^bold>g [^] n) [^] (r mod int (order G)) =\n    (\\<^bold>g [^] a \\<otimes> \\<^bold>g [^] b) [^]\n    (c * int d mod int (order G))", "using r n"], ["proof (prove)\nusing this:\n  r = c * int d\n  \\<^bold>g [^] n = \\<^bold>g [^] a \\<otimes> \\<^bold>g [^] b\n\ngoal (1 subgoal):\n 1. (\\<^bold>g [^] n) [^] (r mod int (order G)) =\n    (\\<^bold>g [^] a \\<otimes> \\<^bold>g [^] b) [^]\n    (c * int d mod int (order G))", "by simp"], ["proof (state)\nthis:\n  (\\<^bold>g [^] n) [^] (r mod int (order G)) =\n  (\\<^bold>g [^] a \\<otimes> \\<^bold>g [^] b) [^]\n  (c * int d mod int (order G))\n\ngoal (1 subgoal):\n 1. (\\<^bold>g [^] a \\<otimes> \\<^bold>g [^] b) [^] (c * int d) =\n    (\\<^bold>g [^] a \\<otimes> \\<^bold>g [^] b) [^]\n    (c * int d mod int (order G))", "ultimately"], ["proof (chain)\npicking this:\n  (\\<^bold>g [^] n) [^] (c * int d) =\n  (\\<^bold>g [^] n) [^] (r mod int (order G))\n  (\\<^bold>g [^] n) [^] (r mod int (order G)) =\n  (\\<^bold>g [^] a \\<otimes> \\<^bold>g [^] b) [^]\n  (c * int d mod int (order G))", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<^bold>g [^] n) [^] (c * int d) =\n  (\\<^bold>g [^] n) [^] (r mod int (order G))\n  (\\<^bold>g [^] n) [^] (r mod int (order G)) =\n  (\\<^bold>g [^] a \\<otimes> \\<^bold>g [^] b) [^]\n  (c * int d mod int (order G))\n\ngoal (1 subgoal):\n 1. (\\<^bold>g [^] a \\<otimes> \\<^bold>g [^] b) [^] (c * int d) =\n    (\\<^bold>g [^] a \\<otimes> \\<^bold>g [^] b) [^]\n    (c * int d mod int (order G))", "using 1 2 3"], ["proof (prove)\nusing this:\n  (\\<^bold>g [^] n) [^] (c * int d) =\n  (\\<^bold>g [^] n) [^] (r mod int (order G))\n  (\\<^bold>g [^] n) [^] (r mod int (order G)) =\n  (\\<^bold>g [^] a \\<otimes> \\<^bold>g [^] b) [^]\n  (c * int d mod int (order G))\n  (\\<^bold>g [^] a \\<otimes> \\<^bold>g [^] b) [^] (c * int d) =\n  (\\<^bold>g [^] n) [^] r\n  (\\<^bold>g [^] n) [^] r = (\\<^bold>g [^] n) [^] (r mod int (order G))\n  (\\<^bold>g [^] n) [^] (r mod int (order G)) =\n  (\\<^bold>g [^] a \\<otimes> \\<^bold>g [^] b) [^]\n  (c * int d mod int (order G))\n\ngoal (1 subgoal):\n 1. (\\<^bold>g [^] a \\<otimes> \\<^bold>g [^] b) [^] (c * int d) =\n    (\\<^bold>g [^] a \\<otimes> \\<^bold>g [^] b) [^]\n    (c * int d mod int (order G))", "by simp"], ["proof (state)\nthis:\n  (\\<^bold>g [^] a \\<otimes> \\<^bold>g [^] b) [^] (c * int d) =\n  (\\<^bold>g [^] a \\<otimes> \\<^bold>g [^] b) [^]\n  (c * int d mod int (order G))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cyclic_group_commute: assumes \"a \\<in> carrier G\" \"b \\<in> carrier G\" shows \"a \\<otimes> b = b \\<otimes> a\"\n(is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<otimes> b = b \\<otimes> a", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. a \\<otimes> b = b \\<otimes> a", "obtain n :: nat where n: \"a = \\<^bold>g [^] n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>n.\n        a = \\<^bold>g [^] n \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using generatorE assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<in> carrier G;\n   \\<And>n. ?x = \\<^bold>g [^] n \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  a \\<in> carrier G\n  b \\<in> carrier G\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        a = \\<^bold>g [^] n \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  a = \\<^bold>g [^] n\n\ngoal (1 subgoal):\n 1. a \\<otimes> b = b \\<otimes> a", "also"], ["proof (state)\nthis:\n  a = \\<^bold>g [^] n\n\ngoal (1 subgoal):\n 1. a \\<otimes> b = b \\<otimes> a", "obtain k :: nat where k: \"b = \\<^bold>g [^] k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>k.\n        b = \\<^bold>g [^] k \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using generatorE assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<in> carrier G;\n   \\<And>n. ?x = \\<^bold>g [^] n \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  a \\<in> carrier G\n  b \\<in> carrier G\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        b = \\<^bold>g [^] k \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  b = \\<^bold>g [^] k\n\ngoal (1 subgoal):\n 1. a \\<otimes> b = b \\<otimes> a", "ultimately"], ["proof (chain)\npicking this:\n  a = \\<^bold>g [^] n\n  b = \\<^bold>g [^] k", "have \"?lhs =  \\<^bold>g [^] n \\<otimes> \\<^bold>g [^] k\""], ["proof (prove)\nusing this:\n  a = \\<^bold>g [^] n\n  b = \\<^bold>g [^] k\n\ngoal (1 subgoal):\n 1. a \\<otimes> b = \\<^bold>g [^] n \\<otimes> \\<^bold>g [^] k", "by simp"], ["proof (state)\nthis:\n  a \\<otimes> b = \\<^bold>g [^] n \\<otimes> \\<^bold>g [^] k\n\ngoal (1 subgoal):\n 1. a \\<otimes> b = b \\<otimes> a", "then"], ["proof (chain)\npicking this:\n  a \\<otimes> b = \\<^bold>g [^] n \\<otimes> \\<^bold>g [^] k", "have \"... = \\<^bold>g [^] (n + k)\""], ["proof (prove)\nusing this:\n  a \\<otimes> b = \\<^bold>g [^] n \\<otimes> \\<^bold>g [^] k\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^] n \\<otimes> \\<^bold>g [^] k = \\<^bold>g [^] (n + k)", "by(simp add: nat_pow_mult)"], ["proof (state)\nthis:\n  \\<^bold>g [^] n \\<otimes> \\<^bold>g [^] k = \\<^bold>g [^] (n + k)\n\ngoal (1 subgoal):\n 1. a \\<otimes> b = b \\<otimes> a", "then"], ["proof (chain)\npicking this:\n  \\<^bold>g [^] n \\<otimes> \\<^bold>g [^] k = \\<^bold>g [^] (n + k)", "have \"... = \\<^bold>g [^] (k + n)\""], ["proof (prove)\nusing this:\n  \\<^bold>g [^] n \\<otimes> \\<^bold>g [^] k = \\<^bold>g [^] (n + k)\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^] (n + k) = \\<^bold>g [^] (k + n)", "by(simp add: add.commute)"], ["proof (state)\nthis:\n  \\<^bold>g [^] (n + k) = \\<^bold>g [^] (k + n)\n\ngoal (1 subgoal):\n 1. a \\<otimes> b = b \\<otimes> a", "then"], ["proof (chain)\npicking this:\n  \\<^bold>g [^] (n + k) = \\<^bold>g [^] (k + n)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<^bold>g [^] (n + k) = \\<^bold>g [^] (k + n)\n\ngoal (1 subgoal):\n 1. a \\<otimes> b = b \\<otimes> a", "by(simp add: nat_pow_mult n k)"], ["proof (state)\nthis:\n  a \\<otimes> b = b \\<otimes> a\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cyclic_group_assoc: \n  assumes \"a \\<in> carrier G\" \"b \\<in> carrier G\" \"c \\<in> carrier G\"\n  shows \"(a \\<otimes> b) \\<otimes> c = a \\<otimes> (b \\<otimes> c)\"\n(is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<otimes> b \\<otimes> c = a \\<otimes> (b \\<otimes> c)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. a \\<otimes> b \\<otimes> c = a \\<otimes> (b \\<otimes> c)", "obtain n :: nat where n: \"a = \\<^bold>g [^] n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>n.\n        a = \\<^bold>g [^] n \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using generatorE assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<in> carrier G;\n   \\<And>n. ?x = \\<^bold>g [^] n \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  a \\<in> carrier G\n  b \\<in> carrier G\n  c \\<in> carrier G\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        a = \\<^bold>g [^] n \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  a = \\<^bold>g [^] n\n\ngoal (1 subgoal):\n 1. a \\<otimes> b \\<otimes> c = a \\<otimes> (b \\<otimes> c)", "obtain k :: nat where k: \"b = \\<^bold>g [^] k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>k.\n        b = \\<^bold>g [^] k \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using generatorE assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<in> carrier G;\n   \\<And>n. ?x = \\<^bold>g [^] n \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  a \\<in> carrier G\n  b \\<in> carrier G\n  c \\<in> carrier G\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        b = \\<^bold>g [^] k \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  b = \\<^bold>g [^] k\n\ngoal (1 subgoal):\n 1. a \\<otimes> b \\<otimes> c = a \\<otimes> (b \\<otimes> c)", "obtain j :: nat where j: \"c = \\<^bold>g [^] j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>j.\n        c = \\<^bold>g [^] j \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using generatorE assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<in> carrier G;\n   \\<And>n. ?x = \\<^bold>g [^] n \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  a \\<in> carrier G\n  b \\<in> carrier G\n  c \\<in> carrier G\n\ngoal (1 subgoal):\n 1. (\\<And>j.\n        c = \\<^bold>g [^] j \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  c = \\<^bold>g [^] j\n\ngoal (1 subgoal):\n 1. a \\<otimes> b \\<otimes> c = a \\<otimes> (b \\<otimes> c)", "have \"?lhs = (\\<^bold>g [^] n \\<otimes> \\<^bold>g [^] k) \\<otimes> \\<^bold>g [^] j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<otimes> b \\<otimes> c =\n    \\<^bold>g [^] n \\<otimes> \\<^bold>g [^] k \\<otimes> \\<^bold>g [^] j", "using n k j"], ["proof (prove)\nusing this:\n  a = \\<^bold>g [^] n\n  b = \\<^bold>g [^] k\n  c = \\<^bold>g [^] j\n\ngoal (1 subgoal):\n 1. a \\<otimes> b \\<otimes> c =\n    \\<^bold>g [^] n \\<otimes> \\<^bold>g [^] k \\<otimes> \\<^bold>g [^] j", "by simp"], ["proof (state)\nthis:\n  a \\<otimes> b \\<otimes> c =\n  \\<^bold>g [^] n \\<otimes> \\<^bold>g [^] k \\<otimes> \\<^bold>g [^] j\n\ngoal (1 subgoal):\n 1. a \\<otimes> b \\<otimes> c = a \\<otimes> (b \\<otimes> c)", "then"], ["proof (chain)\npicking this:\n  a \\<otimes> b \\<otimes> c =\n  \\<^bold>g [^] n \\<otimes> \\<^bold>g [^] k \\<otimes> \\<^bold>g [^] j", "have \"... = \\<^bold>g [^] (n + (k + j))\""], ["proof (prove)\nusing this:\n  a \\<otimes> b \\<otimes> c =\n  \\<^bold>g [^] n \\<otimes> \\<^bold>g [^] k \\<otimes> \\<^bold>g [^] j\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^] n \\<otimes> \\<^bold>g [^] k \\<otimes> \\<^bold>g [^] j =\n    \\<^bold>g [^] (n + (k + j))", "by(simp add: nat_pow_mult add.assoc)"], ["proof (state)\nthis:\n  \\<^bold>g [^] n \\<otimes> \\<^bold>g [^] k \\<otimes> \\<^bold>g [^] j =\n  \\<^bold>g [^] (n + (k + j))\n\ngoal (1 subgoal):\n 1. a \\<otimes> b \\<otimes> c = a \\<otimes> (b \\<otimes> c)", "then"], ["proof (chain)\npicking this:\n  \\<^bold>g [^] n \\<otimes> \\<^bold>g [^] k \\<otimes> \\<^bold>g [^] j =\n  \\<^bold>g [^] (n + (k + j))", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<^bold>g [^] n \\<otimes> \\<^bold>g [^] k \\<otimes> \\<^bold>g [^] j =\n  \\<^bold>g [^] (n + (k + j))\n\ngoal (1 subgoal):\n 1. a \\<otimes> b \\<otimes> c = a \\<otimes> (b \\<otimes> c)", "by(simp add: nat_pow_mult n k j)"], ["proof (state)\nthis:\n  a \\<otimes> b \\<otimes> c = a \\<otimes> (b \\<otimes> c)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma l_cancel_inv: \n  assumes \"h \\<in> carrier G\" \n  shows \"(\\<^bold>g [^] (a :: nat) \\<otimes> inv (\\<^bold>g [^] a)) \\<otimes> h = h\"\n(is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<^bold>g [^] a \\<otimes> inv (\\<^bold>g [^] a) \\<otimes> h = h", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<^bold>g [^] a \\<otimes> inv (\\<^bold>g [^] a) \\<otimes> h = h", "have \"?lhs = (\\<^bold>g [^] int a \\<otimes> inv (\\<^bold>g [^] int a)) \\<otimes> h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<^bold>g [^] a \\<otimes> inv (\\<^bold>g [^] a) \\<otimes> h =\n    \\<^bold>g [^] int a \\<otimes> inv (\\<^bold>g [^] int a) \\<otimes> h", "by simp"], ["proof (state)\nthis:\n  \\<^bold>g [^] a \\<otimes> inv (\\<^bold>g [^] a) \\<otimes> h =\n  \\<^bold>g [^] int a \\<otimes> inv (\\<^bold>g [^] int a) \\<otimes> h\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^] a \\<otimes> inv (\\<^bold>g [^] a) \\<otimes> h = h", "then"], ["proof (chain)\npicking this:\n  \\<^bold>g [^] a \\<otimes> inv (\\<^bold>g [^] a) \\<otimes> h =\n  \\<^bold>g [^] int a \\<otimes> inv (\\<^bold>g [^] int a) \\<otimes> h", "have \"... = (\\<^bold>g [^] int a \\<otimes> (\\<^bold>g [^] (- a))) \\<otimes> h\""], ["proof (prove)\nusing this:\n  \\<^bold>g [^] a \\<otimes> inv (\\<^bold>g [^] a) \\<otimes> h =\n  \\<^bold>g [^] int a \\<otimes> inv (\\<^bold>g [^] int a) \\<otimes> h\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^] int a \\<otimes> inv (\\<^bold>g [^] int a) \\<otimes> h =\n    \\<^bold>g [^] int a \\<otimes> \\<^bold>g [^] - int a \\<otimes> h", "using int_pow_neg[symmetric]"], ["proof (prove)\nusing this:\n  \\<^bold>g [^] a \\<otimes> inv (\\<^bold>g [^] a) \\<otimes> h =\n  \\<^bold>g [^] int a \\<otimes> inv (\\<^bold>g [^] int a) \\<otimes> h\n  ?x \\<in> carrier G \\<Longrightarrow> inv (?x [^] ?i) = ?x [^] - ?i\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^] int a \\<otimes> inv (\\<^bold>g [^] int a) \\<otimes> h =\n    \\<^bold>g [^] int a \\<otimes> \\<^bold>g [^] - int a \\<otimes> h", "by simp"], ["proof (state)\nthis:\n  \\<^bold>g [^] int a \\<otimes> inv (\\<^bold>g [^] int a) \\<otimes> h =\n  \\<^bold>g [^] int a \\<otimes> \\<^bold>g [^] - int a \\<otimes> h\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^] a \\<otimes> inv (\\<^bold>g [^] a) \\<otimes> h = h", "then"], ["proof (chain)\npicking this:\n  \\<^bold>g [^] int a \\<otimes> inv (\\<^bold>g [^] int a) \\<otimes> h =\n  \\<^bold>g [^] int a \\<otimes> \\<^bold>g [^] - int a \\<otimes> h", "have \"... = \\<^bold>g [^] (int a - a)  \\<otimes> h\""], ["proof (prove)\nusing this:\n  \\<^bold>g [^] int a \\<otimes> inv (\\<^bold>g [^] int a) \\<otimes> h =\n  \\<^bold>g [^] int a \\<otimes> \\<^bold>g [^] - int a \\<otimes> h\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^] int a \\<otimes> \\<^bold>g [^] - int a \\<otimes> h =\n    \\<^bold>g [^] (int a - int a) \\<otimes> h", "by(simp add: int_pow_mult)"], ["proof (state)\nthis:\n  \\<^bold>g [^] int a \\<otimes> \\<^bold>g [^] - int a \\<otimes> h =\n  \\<^bold>g [^] (int a - int a) \\<otimes> h\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^] a \\<otimes> inv (\\<^bold>g [^] a) \\<otimes> h = h", "then"], ["proof (chain)\npicking this:\n  \\<^bold>g [^] int a \\<otimes> \\<^bold>g [^] - int a \\<otimes> h =\n  \\<^bold>g [^] (int a - int a) \\<otimes> h", "have \"... = \\<^bold>g [^] ((0:: int)) \\<otimes> h\""], ["proof (prove)\nusing this:\n  \\<^bold>g [^] int a \\<otimes> \\<^bold>g [^] - int a \\<otimes> h =\n  \\<^bold>g [^] (int a - int a) \\<otimes> h\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^] (int a - int a) \\<otimes> h = \\<^bold>g [^] 0 \\<otimes> h", "by simp"], ["proof (state)\nthis:\n  \\<^bold>g [^] (int a - int a) \\<otimes> h = \\<^bold>g [^] 0 \\<otimes> h\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^] a \\<otimes> inv (\\<^bold>g [^] a) \\<otimes> h = h", "then"], ["proof (chain)\npicking this:\n  \\<^bold>g [^] (int a - int a) \\<otimes> h = \\<^bold>g [^] 0 \\<otimes> h", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<^bold>g [^] (int a - int a) \\<otimes> h = \\<^bold>g [^] 0 \\<otimes> h\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^] a \\<otimes> inv (\\<^bold>g [^] a) \\<otimes> h = h", "by (simp add: assms)"], ["proof (state)\nthis:\n  \\<^bold>g [^] a \\<otimes> inv (\\<^bold>g [^] a) \\<otimes> h = h\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma inverse_split: \n  assumes \"a \\<in> carrier G\" and \"b \\<in> carrier G\"\n  shows \"inv (a \\<otimes> b) = inv a \\<otimes> inv b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv (a \\<otimes> b) = inv a \\<otimes> inv b", "by (simp add:  assms comm_group.inv_mult cyclic_group_commute group_comm_groupI)"], ["", "lemma inverse_pow_pow:\n  assumes \"a \\<in> carrier G\"\n  shows \"inv (a [^] (r::nat)) = (inv a) [^] r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv (a [^] r) = inv a [^] r", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. inv (a [^] r) = inv a [^] r", "have \"a [^] r \\<in> carrier G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a [^] r \\<in> carrier G", "using assms"], ["proof (prove)\nusing this:\n  a \\<in> carrier G\n\ngoal (1 subgoal):\n 1. a [^] r \\<in> carrier G", "by blast"], ["proof (state)\nthis:\n  a [^] r \\<in> carrier G\n\ngoal (1 subgoal):\n 1. inv (a [^] r) = inv a [^] r", "then"], ["proof (chain)\npicking this:\n  a [^] r \\<in> carrier G", "show ?thesis"], ["proof (prove)\nusing this:\n  a [^] r \\<in> carrier G\n\ngoal (1 subgoal):\n 1. inv (a [^] r) = inv a [^] r", "by (simp add: assms nat_pow_inv)"], ["proof (state)\nthis:\n  inv (a [^] r) = inv a [^] r\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma l_neq_1_exp_neq_0:\n  assumes \"l \\<in> carrier G\" \n    and \"l \\<noteq> \\<one>\" \n    and \"l = \\<^bold>g [^] (t::nat)\" \n  shows \"t \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<noteq> 0", "proof(rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> t \\<noteq> 0 \\<Longrightarrow> False", "assume \"\\<not> (t \\<noteq> 0)\""], ["proof (state)\nthis:\n  \\<not> t \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> t \\<noteq> 0 \\<Longrightarrow> False", "hence \"t = 0\""], ["proof (prove)\nusing this:\n  \\<not> t \\<noteq> 0\n\ngoal (1 subgoal):\n 1. t = 0", "by simp"], ["proof (state)\nthis:\n  t = 0\n\ngoal (1 subgoal):\n 1. \\<not> t \\<noteq> 0 \\<Longrightarrow> False", "hence \"\\<^bold>g [^] t = \\<one>\""], ["proof (prove)\nusing this:\n  t = 0\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^] t = \\<one>", "by simp"], ["proof (state)\nthis:\n  \\<^bold>g [^] t = \\<one>\n\ngoal (1 subgoal):\n 1. \\<not> t \\<noteq> 0 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<^bold>g [^] t = \\<one>", "show \"False\""], ["proof (prove)\nusing this:\n  \\<^bold>g [^] t = \\<one>\n\ngoal (1 subgoal):\n 1. False", "using assms"], ["proof (prove)\nusing this:\n  \\<^bold>g [^] t = \\<one>\n  l \\<in> carrier G\n  l \\<noteq> \\<one>\n  l = \\<^bold>g [^] t\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma order_gt_1_gen_not_1:\n  assumes \"order G > 1\"\n  shows \"\\<^bold>g \\<noteq> \\<one>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<^bold>g \\<noteq> \\<one>", "proof(rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> \\<^bold>g \\<noteq> \\<one> \\<Longrightarrow> False", "assume \"\\<not> \\<^bold>g \\<noteq> \\<one>\""], ["proof (state)\nthis:\n  \\<not> \\<^bold>g \\<noteq> \\<one>\n\ngoal (1 subgoal):\n 1. \\<not> \\<^bold>g \\<noteq> \\<one> \\<Longrightarrow> False", "hence \"\\<^bold>g = \\<one>\""], ["proof (prove)\nusing this:\n  \\<not> \\<^bold>g \\<noteq> \\<one>\n\ngoal (1 subgoal):\n 1. \\<^bold>g = \\<one>", "by simp"], ["proof (state)\nthis:\n  \\<^bold>g = \\<one>\n\ngoal (1 subgoal):\n 1. \\<not> \\<^bold>g \\<noteq> \\<one> \\<Longrightarrow> False", "hence g_pow_eq_1: \"\\<^bold>g [^] n = \\<one>\" for n :: nat"], ["proof (prove)\nusing this:\n  \\<^bold>g = \\<one>\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^] n = \\<one>", "by simp"], ["proof (state)\nthis:\n  \\<^bold>g [^] ?n = \\<one>\n\ngoal (1 subgoal):\n 1. \\<not> \\<^bold>g \\<noteq> \\<one> \\<Longrightarrow> False", "hence \"range (\\<lambda>n :: nat. \\<^bold>g [^] n) = {\\<one>}\""], ["proof (prove)\nusing this:\n  \\<^bold>g [^] ?n = \\<one>\n\ngoal (1 subgoal):\n 1. range (([^]) \\<^bold>g) = {\\<one>}", "by auto"], ["proof (state)\nthis:\n  range (([^]) \\<^bold>g) = {\\<one>}\n\ngoal (1 subgoal):\n 1. \\<not> \\<^bold>g \\<noteq> \\<one> \\<Longrightarrow> False", "hence \"carrier G \\<subseteq> {\\<one>}\""], ["proof (prove)\nusing this:\n  range (([^]) \\<^bold>g) = {\\<one>}\n\ngoal (1 subgoal):\n 1. carrier G \\<subseteq> {\\<one>}", "using generator"], ["proof (prove)\nusing this:\n  range (([^]) \\<^bold>g) = {\\<one>}\n  carrier G \\<subseteq> range (([^]) \\<^bold>g)\n\ngoal (1 subgoal):\n 1. carrier G \\<subseteq> {\\<one>}", "by auto"], ["proof (state)\nthis:\n  carrier G \\<subseteq> {\\<one>}\n\ngoal (1 subgoal):\n 1. \\<not> \\<^bold>g \\<noteq> \\<one> \\<Longrightarrow> False", "hence \"order G < 1\""], ["proof (prove)\nusing this:\n  carrier G \\<subseteq> {\\<one>}\n\ngoal (1 subgoal):\n 1. order G < 1", "by (metis inj_onD inj_on_generator lessThan_iff g_pow_eq_1 assms less_one neq0_conv)"], ["proof (state)\nthis:\n  order G < 1\n\ngoal (1 subgoal):\n 1. \\<not> \\<^bold>g \\<noteq> \\<one> \\<Longrightarrow> False", "with assms"], ["proof (chain)\npicking this:\n  1 < order G\n  order G < 1", "show \"False\""], ["proof (prove)\nusing this:\n  1 < order G\n  order G < 1\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma power_swap: \"((\\<^bold>g [^] (\\<alpha>0::nat)) [^] (r::nat)) = ((\\<^bold>g [^] r) [^] \\<alpha>0)\"\n(is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<^bold>g [^] \\<alpha>0) [^] r = (\\<^bold>g [^] r) [^] \\<alpha>0", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<^bold>g [^] \\<alpha>0) [^] r = (\\<^bold>g [^] r) [^] \\<alpha>0", "have \"?lhs = \\<^bold>g [^] (\\<alpha>0 * r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<^bold>g [^] \\<alpha>0) [^] r = \\<^bold>g [^] (\\<alpha>0 * r)", "using nat_pow_pow mult.commute"], ["proof (prove)\nusing this:\n  ?x \\<in> carrier G \\<Longrightarrow> (?x [^] ?n) [^] ?m = ?x [^] (?n * ?m)\n  ?a * ?b = ?b * ?a\n\ngoal (1 subgoal):\n 1. (\\<^bold>g [^] \\<alpha>0) [^] r = \\<^bold>g [^] (\\<alpha>0 * r)", "by auto"], ["proof (state)\nthis:\n  (\\<^bold>g [^] \\<alpha>0) [^] r = \\<^bold>g [^] (\\<alpha>0 * r)\n\ngoal (1 subgoal):\n 1. (\\<^bold>g [^] \\<alpha>0) [^] r = (\\<^bold>g [^] r) [^] \\<alpha>0", "hence \"... = \\<^bold>g [^] (r * \\<alpha>0)\""], ["proof (prove)\nusing this:\n  (\\<^bold>g [^] \\<alpha>0) [^] r = \\<^bold>g [^] (\\<alpha>0 * r)\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^] (\\<alpha>0 * r) = \\<^bold>g [^] (r * \\<alpha>0)", "by(metis mult.commute)"], ["proof (state)\nthis:\n  \\<^bold>g [^] (\\<alpha>0 * r) = \\<^bold>g [^] (r * \\<alpha>0)\n\ngoal (1 subgoal):\n 1. (\\<^bold>g [^] \\<alpha>0) [^] r = (\\<^bold>g [^] r) [^] \\<alpha>0", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<^bold>g [^] (\\<alpha>0 * r) = \\<^bold>g [^] (r * \\<alpha>0)\n\ngoal (1 subgoal):\n 1. (\\<^bold>g [^] \\<alpha>0) [^] r = (\\<^bold>g [^] r) [^] \\<alpha>0", "using nat_pow_pow"], ["proof (prove)\nusing this:\n  \\<^bold>g [^] (\\<alpha>0 * r) = \\<^bold>g [^] (r * \\<alpha>0)\n  ?x \\<in> carrier G \\<Longrightarrow> (?x [^] ?n) [^] ?m = ?x [^] (?n * ?m)\n\ngoal (1 subgoal):\n 1. (\\<^bold>g [^] \\<alpha>0) [^] r = (\\<^bold>g [^] r) [^] \\<alpha>0", "by auto"], ["proof (state)\nthis:\n  (\\<^bold>g [^] \\<alpha>0) [^] r = (\\<^bold>g [^] r) [^] \\<alpha>0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma gen_power_0:\n  fixes r :: nat \n  assumes \"\\<^bold>g [^] r = \\<one>\" \n    and \"r < order G\"\n  shows \"r = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r = 0", "using assms inj_onD inj_on_generator"], ["proof (prove)\nusing this:\n  \\<^bold>g [^] r = \\<one>\n  r < order G\n  \\<lbrakk>inj_on ?f ?A; ?f ?x = ?f ?y; ?x \\<in> ?A; ?y \\<in> ?A\\<rbrakk>\n  \\<Longrightarrow> ?x = ?y\n  inj_on (([^]) \\<^bold>g) {..<order G}\n\ngoal (1 subgoal):\n 1. r = 0", "by fastforce"], ["", "lemma group_eq_pow_eq_mod: \n  fixes a b :: nat \n  assumes \"\\<^bold>g [^] a = \\<^bold>g [^] b\" \n    and \"order G > 0\"\n  shows \"[a = b] (mod order G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [a = b] (mod order G)", "proof(cases \"a > b\")"], ["proof (state)\ngoal (2 subgoals):\n 1. b < a \\<Longrightarrow> [a = b] (mod order G)\n 2. \\<not> b < a \\<Longrightarrow> [a = b] (mod order G)", "case True"], ["proof (state)\nthis:\n  b < a\n\ngoal (2 subgoals):\n 1. b < a \\<Longrightarrow> [a = b] (mod order G)\n 2. \\<not> b < a \\<Longrightarrow> [a = b] (mod order G)", "have \"\\<^bold>g [^] a \\<otimes> inv (\\<^bold>g [^] b) = \\<one>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<^bold>g [^] a \\<otimes> inv (\\<^bold>g [^] b) = \\<one>", "using assms"], ["proof (prove)\nusing this:\n  \\<^bold>g [^] a = \\<^bold>g [^] b\n  0 < order G\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^] a \\<otimes> inv (\\<^bold>g [^] b) = \\<one>", "by simp"], ["proof (state)\nthis:\n  \\<^bold>g [^] a \\<otimes> inv (\\<^bold>g [^] b) = \\<one>\n\ngoal (2 subgoals):\n 1. b < a \\<Longrightarrow> [a = b] (mod order G)\n 2. \\<not> b < a \\<Longrightarrow> [a = b] (mod order G)", "hence \"\\<^bold>g [^] (a - b) = \\<one>\""], ["proof (prove)\nusing this:\n  \\<^bold>g [^] a \\<otimes> inv (\\<^bold>g [^] b) = \\<one>\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^] (a - b) = \\<one>", "by (smt True add_Suc_right assms diff_add_inverse generator_closed group.l_cancel_one' group_l_invI l_inv_ex less_imp_Suc_add nat_pow_closed nat_pow_mult)"], ["proof (state)\nthis:\n  \\<^bold>g [^] (a - b) = \\<one>\n\ngoal (2 subgoals):\n 1. b < a \\<Longrightarrow> [a = b] (mod order G)\n 2. \\<not> b < a \\<Longrightarrow> [a = b] (mod order G)", "hence \"\\<^bold>g [^] ((a - b) mod (order G)) = \\<one>\""], ["proof (prove)\nusing this:\n  \\<^bold>g [^] (a - b) = \\<one>\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^] ((a - b) mod order G) = \\<one>", "using pow_generator_mod"], ["proof (prove)\nusing this:\n  \\<^bold>g [^] (a - b) = \\<one>\n  \\<^bold>g [^] (?k mod order G) = \\<^bold>g [^] ?k\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^] ((a - b) mod order G) = \\<one>", "by auto"], ["proof (state)\nthis:\n  \\<^bold>g [^] ((a - b) mod order G) = \\<one>\n\ngoal (2 subgoals):\n 1. b < a \\<Longrightarrow> [a = b] (mod order G)\n 2. \\<not> b < a \\<Longrightarrow> [a = b] (mod order G)", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<^bold>g [^] ((a - b) mod order G) = \\<one>\n\ngoal (1 subgoal):\n 1. [a = b] (mod order G)", "using gen_power_0"], ["proof (prove)\nusing this:\n  \\<^bold>g [^] ((a - b) mod order G) = \\<one>\n  \\<lbrakk>\\<^bold>g [^] ?r = \\<one>; ?r < order G\\<rbrakk>\n  \\<Longrightarrow> ?r = 0\n\ngoal (1 subgoal):\n 1. [a = b] (mod order G)", "using assms(1) assms(2) order_gt_0_iff_finite pow_generator_eq_iff_cong"], ["proof (prove)\nusing this:\n  \\<^bold>g [^] ((a - b) mod order G) = \\<one>\n  \\<lbrakk>\\<^bold>g [^] ?r = \\<one>; ?r < order G\\<rbrakk>\n  \\<Longrightarrow> ?r = 0\n  \\<^bold>g [^] a = \\<^bold>g [^] b\n  0 < order G\n  (0 < order G) = finite (carrier G)\n  finite (carrier G) \\<Longrightarrow>\n  (\\<^bold>g [^] ?x = \\<^bold>g [^] ?y) = [?x = ?y] (mod order G)\n\ngoal (1 subgoal):\n 1. [a = b] (mod order G)", "by blast"], ["proof (state)\nthis:\n  [a = b] (mod order G)\n\ngoal (1 subgoal):\n 1. \\<not> b < a \\<Longrightarrow> [a = b] (mod order G)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> b < a \\<Longrightarrow> [a = b] (mod order G)", "case False"], ["proof (state)\nthis:\n  \\<not> b < a\n\ngoal (1 subgoal):\n 1. \\<not> b < a \\<Longrightarrow> [a = b] (mod order G)", "have \"\\<^bold>g [^] a \\<otimes> inv (\\<^bold>g [^] b) = \\<one>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<^bold>g [^] a \\<otimes> inv (\\<^bold>g [^] b) = \\<one>", "using assms"], ["proof (prove)\nusing this:\n  \\<^bold>g [^] a = \\<^bold>g [^] b\n  0 < order G\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^] a \\<otimes> inv (\\<^bold>g [^] b) = \\<one>", "by simp"], ["proof (state)\nthis:\n  \\<^bold>g [^] a \\<otimes> inv (\\<^bold>g [^] b) = \\<one>\n\ngoal (1 subgoal):\n 1. \\<not> b < a \\<Longrightarrow> [a = b] (mod order G)", "hence \"\\<^bold>g [^] (b - a) = \\<one>\""], ["proof (prove)\nusing this:\n  \\<^bold>g [^] a \\<otimes> inv (\\<^bold>g [^] b) = \\<one>\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^] (b - a) = \\<one>", "by (metis (no_types, lifting) False Group.group.axioms(1) Units_eq add_diff_inverse_nat assms(1) generator_closed group_l_invI l_inv_ex l_neq_1_exp_neq_0 monoid.Units_l_cancel nat_pow_closed nat_pow_mult r_one)"], ["proof (state)\nthis:\n  \\<^bold>g [^] (b - a) = \\<one>\n\ngoal (1 subgoal):\n 1. \\<not> b < a \\<Longrightarrow> [a = b] (mod order G)", "hence \"\\<^bold>g [^] ((b - a) mod (order G)) = \\<one>\""], ["proof (prove)\nusing this:\n  \\<^bold>g [^] (b - a) = \\<one>\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^] ((b - a) mod order G) = \\<one>", "using pow_generator_mod"], ["proof (prove)\nusing this:\n  \\<^bold>g [^] (b - a) = \\<one>\n  \\<^bold>g [^] (?k mod order G) = \\<^bold>g [^] ?k\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^] ((b - a) mod order G) = \\<one>", "by simp"], ["proof (state)\nthis:\n  \\<^bold>g [^] ((b - a) mod order G) = \\<one>\n\ngoal (1 subgoal):\n 1. \\<not> b < a \\<Longrightarrow> [a = b] (mod order G)", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<^bold>g [^] ((b - a) mod order G) = \\<one>\n\ngoal (1 subgoal):\n 1. [a = b] (mod order G)", "using gen_power_0"], ["proof (prove)\nusing this:\n  \\<^bold>g [^] ((b - a) mod order G) = \\<one>\n  \\<lbrakk>\\<^bold>g [^] ?r = \\<one>; ?r < order G\\<rbrakk>\n  \\<Longrightarrow> ?r = 0\n\ngoal (1 subgoal):\n 1. [a = b] (mod order G)", "using assms(1) assms(2) order_gt_0_iff_finite pow_generator_eq_iff_cong"], ["proof (prove)\nusing this:\n  \\<^bold>g [^] ((b - a) mod order G) = \\<one>\n  \\<lbrakk>\\<^bold>g [^] ?r = \\<one>; ?r < order G\\<rbrakk>\n  \\<Longrightarrow> ?r = 0\n  \\<^bold>g [^] a = \\<^bold>g [^] b\n  0 < order G\n  (0 < order G) = finite (carrier G)\n  finite (carrier G) \\<Longrightarrow>\n  (\\<^bold>g [^] ?x = \\<^bold>g [^] ?y) = [?x = ?y] (mod order G)\n\ngoal (1 subgoal):\n 1. [a = b] (mod order G)", "by blast"], ["proof (state)\nthis:\n  [a = b] (mod order G)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"]]}