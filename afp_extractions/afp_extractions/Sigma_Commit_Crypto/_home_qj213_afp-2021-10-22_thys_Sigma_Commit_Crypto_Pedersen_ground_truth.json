{"file_name": "/home/qj213/afp-2021-10-22/thys/Sigma_Commit_Crypto/Pedersen.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Sigma_Commit_Crypto", "problem_names": ["lemma order_gt_0 [simp]: \"order \\<G> > 0\"", "lemma mod_one_cancel: assumes \"[int y * z * x = y' * x] (mod order \\<G>)\" and \"[z * x = 1] (mod order \\<G>)\"\n  shows \"[int y = y' * x] (mod order \\<G>)\"", "lemma dis_log_break:\n  fixes d d' m m' :: nat\n  assumes c: \" \\<^bold>g [^] d' \\<otimes> (\\<^bold>g [^] y) [^] m' = \\<^bold>g [^] d \\<otimes> (\\<^bold>g [^] y) [^] m\"\n    and y_less_order: \"y < order \\<G>\"\n    and m_ge_m': \"m > m'\"\n    and m: \"m < order \\<G>\"\n  shows \"y = nat ((int d' - int d) * (fst (bezw ((m - m')) (order \\<G>))) mod order \\<G>)\"", "lemma dis_log_break':\n  assumes \"y < order \\<G>\"\n    and \"\\<not> m' < m\"\n    and \"m \\<noteq> m'\"\n    and m: \"m' < order \\<G>\"\n    and \"\\<^bold>g [^] d \\<otimes> (\\<^bold>g [^] y) [^] m = \\<^bold>g [^] d' \\<otimes> (\\<^bold>g [^] y) [^] m'\"\n  shows \"y = nat ((int d - int d') * fst (bezw ((m' - m)) (order \\<G>)) mod int (order \\<G>))\"", "lemma set_spmf_samp_uni [simp]: \"set_spmf (sample_uniform (order \\<G>)) = {x. x < order \\<G>}\"", "lemma correct:\n  shows \"spmf (ped_commit.correct_game m) True  = 1\"", "theorem abstract_correct:\n  shows \"ped_commit.correct\"", "lemma perfect_hiding:\n  shows \"spmf (ped_commit.hiding_game_ind_cpa \\<A>) True - 1/2 = 0\"", "theorem abstract_perfect_hiding: \n  shows \"ped_commit.perfect_hiding_ind_cpa \\<A>\"", "lemma bind_output_cong:  \n  assumes \"x < order \\<G>\" \n  shows \"(x = nat ((int b - int ab) * fst (bezw (aa - ac) (order \\<G>)) mod int (order \\<G>)))\n            \\<longleftrightarrow> [x = nat ((int b - int ab) * fst (bezw (aa - ac) (order \\<G>)) mod int (order \\<G>))] (mod order \\<G>)\"", "lemma bind_game_eq_dis_log:\n  shows \"ped_commit.bind_game \\<A> = discrete_log.dis_log (dis_log_\\<A> \\<A>)\"", "theorem pedersen_bind: \"ped_commit.bind_advantage \\<A> = discrete_log.advantage (dis_log_\\<A> \\<A>)\"", "theorem pedersen_correct_asym: \n shows \"ped_commit.correct n\"", "theorem pedersen_perfect_hiding_asym:\n  shows \"ped_commit.perfect_hiding_ind_cpa n (\\<A> n)\"", "theorem pedersen_bind_asym: \n  shows \"negligible (\\<lambda> n. ped_commit.bind_advantage n (\\<A> n)) \n            \\<longleftrightarrow> negligible (\\<lambda> n. discrete_log.advantage n (dis_log_\\<A> n (\\<A> n)))\""], "translations": [["", "lemma order_gt_0 [simp]: \"order \\<G> > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < order \\<G>", "by (simp add: prime_gt_0_nat prime_order)"], ["", "type_synonym 'grp' ck = \"'grp'\""], ["", "type_synonym 'grp' vk = \"'grp'\""], ["", "type_synonym plain = \"nat\""], ["", "type_synonym 'grp' commit = \"'grp'\""], ["", "type_synonym \"opening\" = \"nat\""], ["", "definition key_gen :: \"('grp ck \\<times> 'grp vk) spmf\"\nwhere \n  \"key_gen = do {\n    x :: nat \\<leftarrow> sample_uniform (order \\<G>);\n    let h = \\<^bold>g [^] x;\n    return_spmf (h, h) \n  }\""], ["", "definition commit :: \"'grp ck \\<Rightarrow> plain \\<Rightarrow> ('grp commit \\<times> opening) spmf\"\nwhere \n  \"commit ck m = do {\n    d :: nat \\<leftarrow> sample_uniform (order \\<G>);\n    let c = (\\<^bold>g [^] d) \\<otimes> (ck [^] m);\n    return_spmf (c,d) \n  }\""], ["", "definition commit_inv :: \"'grp ck \\<Rightarrow> plain \\<Rightarrow> ('grp commit \\<times> opening) spmf\"\nwhere \n  \"commit_inv ck m = do {\n    d :: nat \\<leftarrow> sample_uniform (order \\<G>);\n    let c = (\\<^bold>g [^] d) \\<otimes> (inv ck [^] m);\n    return_spmf (c,d) \n  }\""], ["", "definition verify :: \"'grp vk \\<Rightarrow> plain \\<Rightarrow> 'grp commit \\<Rightarrow> opening \\<Rightarrow> bool\"\nwhere \n  \"verify v_key m c d = (c = (\\<^bold>g [^] d \\<otimes>  v_key [^] m))\""], ["", "definition valid_msg :: \"plain \\<Rightarrow> bool\"\n  where \"valid_msg msg \\<equiv> (msg < order \\<G>)\""], ["", "definition dis_log_\\<A> :: \"('grp ck, plain, 'grp commit, opening) bind_adversary \\<Rightarrow> 'grp ck \\<Rightarrow> nat spmf\"\nwhere \"dis_log_\\<A> \\<A> h = do {\n  (c, m, d, m', d') \\<leftarrow> \\<A> h;\n  _ :: unit \\<leftarrow> assert_spmf (m \\<noteq> m'  \\<and> valid_msg m \\<and> valid_msg m');\n  _ :: unit \\<leftarrow> assert_spmf (c = \\<^bold>g [^] d \\<otimes> h [^] m \\<and> c = \\<^bold>g [^] d' \\<otimes> h [^] m'); \n  return_spmf  (if (m > m') then (nat ((int d' - int d) * inverse (m - m') (order \\<G>) mod order \\<G>)) else \n                  (nat ((int d - int d') * inverse (m' - m) (order \\<G>) mod order \\<G>)))}\""], ["", "sublocale ped_commit: abstract_commitment key_gen commit verify valid_msg"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "sublocale discrete_log: dis_log _"], ["proof (prove)\ngoal (1 subgoal):\n 1. dis_log \\<G>", "unfolding dis_log_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < order \\<G>", "by(simp)"], ["", "end"], ["", "locale pedersen = pedersen_base + cyclic_group \\<G> \nbegin"], ["", "lemma mod_one_cancel: assumes \"[int y * z * x = y' * x] (mod order \\<G>)\" and \"[z * x = 1] (mod order \\<G>)\"\n  shows \"[int y = y' * x] (mod order \\<G>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [int y = y' * x] (mod int (order \\<G>))", "by (metis assms Groups.mult_ac(2) cong_scalar_right cong_sym_eq cong_trans more_arith_simps(11) more_arith_simps(5))"], ["", "lemma dis_log_break:\n  fixes d d' m m' :: nat\n  assumes c: \" \\<^bold>g [^] d' \\<otimes> (\\<^bold>g [^] y) [^] m' = \\<^bold>g [^] d \\<otimes> (\\<^bold>g [^] y) [^] m\"\n    and y_less_order: \"y < order \\<G>\"\n    and m_ge_m': \"m > m'\"\n    and m: \"m < order \\<G>\"\n  shows \"y = nat ((int d' - int d) * (fst (bezw ((m - m')) (order \\<G>))) mod order \\<G>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y =\n    nat ((int d' - int d) *\n         Number_Theory_Aux.inverse (m - m') (order \\<G>) mod\n         int (order \\<G>))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. y =\n    nat ((int d' - int d) *\n         Number_Theory_Aux.inverse (m - m') (order \\<G>) mod\n         int (order \\<G>))", "have mm': \"\\<not> [m = m'] (mod order \\<G>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [m \\<noteq> m'] (mod order \\<G>)", "using m m_ge_m' basic_trans_rules(19) cong_less_modulus_unique_nat"], ["proof (prove)\nusing this:\n  m < order \\<G>\n  m' < m\n  \\<lbrakk>?x < ?y; ?y < ?z\\<rbrakk> \\<Longrightarrow> ?x < ?z\n  \\<lbrakk>[?x = ?y] (mod ?m); ?x < ?m; ?y < ?m\\<rbrakk>\n  \\<Longrightarrow> ?x = ?y\n\ngoal (1 subgoal):\n 1. [m \\<noteq> m'] (mod order \\<G>)", "by blast"], ["proof (state)\nthis:\n  [m \\<noteq> m'] (mod order \\<G>)\n\ngoal (1 subgoal):\n 1. y =\n    nat ((int d' - int d) *\n         Number_Theory_Aux.inverse (m - m') (order \\<G>) mod\n         int (order \\<G>))", "hence gcd: \"int (gcd ((m - m')) (order \\<G>)) = 1\""], ["proof (prove)\nusing this:\n  [m \\<noteq> m'] (mod order \\<G>)\n\ngoal (1 subgoal):\n 1. int (gcd (m - m') (order \\<G>)) = 1", "using assms(3) assms(4) prime_field prime_order"], ["proof (prove)\nusing this:\n  [m \\<noteq> m'] (mod order \\<G>)\n  m' < m\n  m < order \\<G>\n  \\<lbrakk>prime ?q; ?a < ?q; ?a \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> coprime ?a ?q\n  prime (order \\<G>)\n\ngoal (1 subgoal):\n 1. int (gcd (m - m') (order \\<G>)) = 1", "by auto"], ["proof (state)\nthis:\n  int (gcd (m - m') (order \\<G>)) = 1\n\ngoal (1 subgoal):\n 1. y =\n    nat ((int d' - int d) *\n         Number_Theory_Aux.inverse (m - m') (order \\<G>) mod\n         int (order \\<G>))", "have \"\\<^bold>g [^] (d + y * m) = \\<^bold>g [^] (d' + y * m')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<^bold>g [^] (d + y * m) = \\<^bold>g [^] (d' + y * m')", "using c"], ["proof (prove)\nusing this:\n  \\<^bold>g [^] d' \\<otimes> (\\<^bold>g [^] y) [^] m' =\n  \\<^bold>g [^] d \\<otimes> (\\<^bold>g [^] y) [^] m\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^] (d + y * m) = \\<^bold>g [^] (d' + y * m')", "by (simp add: nat_pow_mult nat_pow_pow)"], ["proof (state)\nthis:\n  \\<^bold>g [^] (d + y * m) = \\<^bold>g [^] (d' + y * m')\n\ngoal (1 subgoal):\n 1. y =\n    nat ((int d' - int d) *\n         Number_Theory_Aux.inverse (m - m') (order \\<G>) mod\n         int (order \\<G>))", "hence \"[d + y * m = d' + y * m'] (mod order \\<G>)\""], ["proof (prove)\nusing this:\n  \\<^bold>g [^] (d + y * m) = \\<^bold>g [^] (d' + y * m')\n\ngoal (1 subgoal):\n 1. [d + y * m = d' + y * m'] (mod order \\<G>)", "by(simp add: pow_generator_eq_iff_cong finite_carrier)"], ["proof (state)\nthis:\n  [d + y * m = d' + y * m'] (mod order \\<G>)\n\ngoal (1 subgoal):\n 1. y =\n    nat ((int d' - int d) *\n         Number_Theory_Aux.inverse (m - m') (order \\<G>) mod\n         int (order \\<G>))", "hence \"[int d + int y * int m = int d' + int y * int m'] (mod order \\<G>)\""], ["proof (prove)\nusing this:\n  [d + y * m = d' + y * m'] (mod order \\<G>)\n\ngoal (1 subgoal):\n 1. [int d + int y * int m = int d' + int y * int m'] (mod int (order \\<G>))", "using cong_int_iff"], ["proof (prove)\nusing this:\n  [d + y * m = d' + y * m'] (mod order \\<G>)\n  [int ?m = int ?q] (mod int ?n) = [?m = ?q] (mod ?n)\n\ngoal (1 subgoal):\n 1. [int d + int y * int m = int d' + int y * int m'] (mod int (order \\<G>))", "by force"], ["proof (state)\nthis:\n  [int d + int y * int m = int d' + int y * int m'] (mod int (order \\<G>))\n\ngoal (1 subgoal):\n 1. y =\n    nat ((int d' - int d) *\n         Number_Theory_Aux.inverse (m - m') (order \\<G>) mod\n         int (order \\<G>))", "from cong_diff[OF this cong_refl, of \"int d + int y * int m'\"]"], ["proof (chain)\npicking this:\n  [int d + int y * int m -\n   (int d +\n    int y *\n    int m') = int d' + int y * int m' -\n              (int d + int y * int m')] (mod int (order \\<G>))", "have \"[int y * int (m - m') = int d' - int d] (mod order \\<G>)\""], ["proof (prove)\nusing this:\n  [int d + int y * int m -\n   (int d +\n    int y *\n    int m') = int d' + int y * int m' -\n              (int d + int y * int m')] (mod int (order \\<G>))\n\ngoal (1 subgoal):\n 1. [int y * int (m - m') = int d' - int d] (mod int (order \\<G>))", "using m_ge_m'"], ["proof (prove)\nusing this:\n  [int d + int y * int m -\n   (int d +\n    int y *\n    int m') = int d' + int y * int m' -\n              (int d + int y * int m')] (mod int (order \\<G>))\n  m' < m\n\ngoal (1 subgoal):\n 1. [int y * int (m - m') = int d' - int d] (mod int (order \\<G>))", "by(simp add: int_distrib of_nat_diff)"], ["proof (state)\nthis:\n  [int y * int (m - m') = int d' - int d] (mod int (order \\<G>))\n\ngoal (1 subgoal):\n 1. y =\n    nat ((int d' - int d) *\n         Number_Theory_Aux.inverse (m - m') (order \\<G>) mod\n         int (order \\<G>))", "hence *: \"[int y * int (m - m') * (fst (bezw ((m - m')) (order \\<G>))) = (int d' - int d) * (fst (bezw ((m - m')) (order \\<G>)))] (mod order \\<G>)\""], ["proof (prove)\nusing this:\n  [int y * int (m - m') = int d' - int d] (mod int (order \\<G>))\n\ngoal (1 subgoal):\n 1. [int y * int (m - m') *\n     Number_Theory_Aux.inverse (m - m')\n      (order\n        \\<G>) = (int d' - int d) *\n                Number_Theory_Aux.inverse (m - m')\n                 (order \\<G>)] (mod int (order \\<G>))", "by (simp add: cong_scalar_right)"], ["proof (state)\nthis:\n  [int y * int (m - m') *\n   Number_Theory_Aux.inverse (m - m')\n    (order\n      \\<G>) = (int d' - int d) *\n              Number_Theory_Aux.inverse (m - m')\n               (order \\<G>)] (mod int (order \\<G>))\n\ngoal (1 subgoal):\n 1. y =\n    nat ((int d' - int d) *\n         Number_Theory_Aux.inverse (m - m') (order \\<G>) mod\n         int (order \\<G>))", "hence \"[int y * (int (m - m') * (fst (bezw ((m - m')) (order \\<G>)))) = (int d' - int d) * (fst (bezw ((m - m')) (order \\<G>)))] (mod order \\<G>)\""], ["proof (prove)\nusing this:\n  [int y * int (m - m') *\n   Number_Theory_Aux.inverse (m - m')\n    (order\n      \\<G>) = (int d' - int d) *\n              Number_Theory_Aux.inverse (m - m')\n               (order \\<G>)] (mod int (order \\<G>))\n\ngoal (1 subgoal):\n 1. [int y *\n     (int (m - m') *\n      Number_Theory_Aux.inverse (m - m')\n       (order\n         \\<G>)) = (int d' - int d) *\n                  Number_Theory_Aux.inverse (m - m')\n                   (order \\<G>)] (mod int (order \\<G>))", "by (simp add: more_arith_simps(11))"], ["proof (state)\nthis:\n  [int y *\n   (int (m - m') *\n    Number_Theory_Aux.inverse (m - m')\n     (order\n       \\<G>)) = (int d' - int d) *\n                Number_Theory_Aux.inverse (m - m')\n                 (order \\<G>)] (mod int (order \\<G>))\n\ngoal (1 subgoal):\n 1. y =\n    nat ((int d' - int d) *\n         Number_Theory_Aux.inverse (m - m') (order \\<G>) mod\n         int (order \\<G>))", "hence \"[int y * 1 = (int d' - int d) * (fst (bezw ((m - m')) (order \\<G>)))] (mod order \\<G>)\""], ["proof (prove)\nusing this:\n  [int y *\n   (int (m - m') *\n    Number_Theory_Aux.inverse (m - m')\n     (order\n       \\<G>)) = (int d' - int d) *\n                Number_Theory_Aux.inverse (m - m')\n                 (order \\<G>)] (mod int (order \\<G>))\n\ngoal (1 subgoal):\n 1. [int y *\n     1 = (int d' - int d) *\n         Number_Theory_Aux.inverse (m - m')\n          (order \\<G>)] (mod int (order \\<G>))", "using inverse gcd"], ["proof (prove)\nusing this:\n  [int y *\n   (int (m - m') *\n    Number_Theory_Aux.inverse (m - m')\n     (order\n       \\<G>)) = (int d' - int d) *\n                Number_Theory_Aux.inverse (m - m')\n                 (order \\<G>)] (mod int (order \\<G>))\n  gcd ?x ?q = 1 \\<Longrightarrow>\n  [int ?x * Number_Theory_Aux.inverse ?x ?q = 1] (mod int ?q)\n  int (gcd (m - m') (order \\<G>)) = 1\n\ngoal (1 subgoal):\n 1. [int y *\n     1 = (int d' - int d) *\n         Number_Theory_Aux.inverse (m - m')\n          (order \\<G>)] (mod int (order \\<G>))", "by (smt Groups.mult_ac(2) Number_Theory_Aux.inverse Totient.of_nat_eq_1_iff * cong_def int_ops(9) mod_mult_right_eq mod_one_cancel)"], ["proof (state)\nthis:\n  [int y *\n   1 = (int d' - int d) *\n       Number_Theory_Aux.inverse (m - m')\n        (order \\<G>)] (mod int (order \\<G>))\n\ngoal (1 subgoal):\n 1. y =\n    nat ((int d' - int d) *\n         Number_Theory_Aux.inverse (m - m') (order \\<G>) mod\n         int (order \\<G>))", "hence \"[int y = (int d' - int d) * (fst (bezw ((m - m')) (order \\<G>)))] (mod order \\<G>)\""], ["proof (prove)\nusing this:\n  [int y *\n   1 = (int d' - int d) *\n       Number_Theory_Aux.inverse (m - m')\n        (order \\<G>)] (mod int (order \\<G>))\n\ngoal (1 subgoal):\n 1. [int y = (int d' - int d) *\n             Number_Theory_Aux.inverse (m - m')\n              (order \\<G>)] (mod int (order \\<G>))", "by simp"], ["proof (state)\nthis:\n  [int y = (int d' - int d) *\n           Number_Theory_Aux.inverse (m - m')\n            (order \\<G>)] (mod int (order \\<G>))\n\ngoal (1 subgoal):\n 1. y =\n    nat ((int d' - int d) *\n         Number_Theory_Aux.inverse (m - m') (order \\<G>) mod\n         int (order \\<G>))", "hence \"y mod order \\<G> = (int d' - int d) * (fst (bezw ((m - m')) (order \\<G>))) mod order \\<G>\""], ["proof (prove)\nusing this:\n  [int y = (int d' - int d) *\n           Number_Theory_Aux.inverse (m - m')\n            (order \\<G>)] (mod int (order \\<G>))\n\ngoal (1 subgoal):\n 1. int (y mod order \\<G>) =\n    (int d' - int d) * Number_Theory_Aux.inverse (m - m') (order \\<G>) mod\n    int (order \\<G>)", "using cong_def zmod_int"], ["proof (prove)\nusing this:\n  [int y = (int d' - int d) *\n           Number_Theory_Aux.inverse (m - m')\n            (order \\<G>)] (mod int (order \\<G>))\n  [?b = ?c] (mod ?a) = (?b mod ?a = ?c mod ?a)\n  int (?a mod ?b) = int ?a mod int ?b\n\ngoal (1 subgoal):\n 1. int (y mod order \\<G>) =\n    (int d' - int d) * Number_Theory_Aux.inverse (m - m') (order \\<G>) mod\n    int (order \\<G>)", "by auto"], ["proof (state)\nthis:\n  int (y mod order \\<G>) =\n  (int d' - int d) * Number_Theory_Aux.inverse (m - m') (order \\<G>) mod\n  int (order \\<G>)\n\ngoal (1 subgoal):\n 1. y =\n    nat ((int d' - int d) *\n         Number_Theory_Aux.inverse (m - m') (order \\<G>) mod\n         int (order \\<G>))", "thus ?thesis"], ["proof (prove)\nusing this:\n  int (y mod order \\<G>) =\n  (int d' - int d) * Number_Theory_Aux.inverse (m - m') (order \\<G>) mod\n  int (order \\<G>)\n\ngoal (1 subgoal):\n 1. y =\n    nat ((int d' - int d) *\n         Number_Theory_Aux.inverse (m - m') (order \\<G>) mod\n         int (order \\<G>))", "using y_less_order"], ["proof (prove)\nusing this:\n  int (y mod order \\<G>) =\n  (int d' - int d) * Number_Theory_Aux.inverse (m - m') (order \\<G>) mod\n  int (order \\<G>)\n  y < order \\<G>\n\ngoal (1 subgoal):\n 1. y =\n    nat ((int d' - int d) *\n         Number_Theory_Aux.inverse (m - m') (order \\<G>) mod\n         int (order \\<G>))", "by simp"], ["proof (state)\nthis:\n  y =\n  nat ((int d' - int d) *\n       Number_Theory_Aux.inverse (m - m') (order \\<G>) mod\n       int (order \\<G>))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma dis_log_break':\n  assumes \"y < order \\<G>\"\n    and \"\\<not> m' < m\"\n    and \"m \\<noteq> m'\"\n    and m: \"m' < order \\<G>\"\n    and \"\\<^bold>g [^] d \\<otimes> (\\<^bold>g [^] y) [^] m = \\<^bold>g [^] d' \\<otimes> (\\<^bold>g [^] y) [^] m'\"\n  shows \"y = nat ((int d - int d') * fst (bezw ((m' - m)) (order \\<G>)) mod int (order \\<G>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y =\n    nat ((int d - int d') *\n         Number_Theory_Aux.inverse (m' - m) (order \\<G>) mod\n         int (order \\<G>))", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. y =\n    nat ((int d - int d') *\n         Number_Theory_Aux.inverse (m' - m) (order \\<G>) mod\n         int (order \\<G>))", "have \"m' > m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m < m'", "using assms"], ["proof (prove)\nusing this:\n  y < order \\<G>\n  \\<not> m' < m\n  m \\<noteq> m'\n  m' < order \\<G>\n  \\<^bold>g [^] d \\<otimes> (\\<^bold>g [^] y) [^] m =\n  \\<^bold>g [^] d' \\<otimes> (\\<^bold>g [^] y) [^] m'\n\ngoal (1 subgoal):\n 1. m < m'", "using group_eq_pow_eq_mod nat_neq_iff order_gt_0"], ["proof (prove)\nusing this:\n  y < order \\<G>\n  \\<not> m' < m\n  m \\<noteq> m'\n  m' < order \\<G>\n  \\<^bold>g [^] d \\<otimes> (\\<^bold>g [^] y) [^] m =\n  \\<^bold>g [^] d' \\<otimes> (\\<^bold>g [^] y) [^] m'\n  \\<lbrakk>\\<^bold>g [^] ?a = \\<^bold>g [^] ?b; 0 < order \\<G>\\<rbrakk>\n  \\<Longrightarrow> [?a = ?b] (mod order \\<G>)\n  (?m \\<noteq> ?n) = (?m < ?n \\<or> ?n < ?m)\n  0 < order \\<G>\n\ngoal (1 subgoal):\n 1. m < m'", "by blast"], ["proof (state)\nthis:\n  m < m'\n\ngoal (1 subgoal):\n 1. y =\n    nat ((int d - int d') *\n         Number_Theory_Aux.inverse (m' - m) (order \\<G>) mod\n         int (order \\<G>))", "thus ?thesis"], ["proof (prove)\nusing this:\n  m < m'\n\ngoal (1 subgoal):\n 1. y =\n    nat ((int d - int d') *\n         Number_Theory_Aux.inverse (m' - m) (order \\<G>) mod\n         int (order \\<G>))", "using dis_log_break[of d y m d' m' ]assms cong_sym_eq assms"], ["proof (prove)\nusing this:\n  m < m'\n  \\<lbrakk>\\<^bold>g [^] d \\<otimes> (\\<^bold>g [^] y) [^] m =\n           \\<^bold>g [^] d' \\<otimes> (\\<^bold>g [^] y) [^] m';\n   y < order \\<G>; m < m'; m' < order \\<G>\\<rbrakk>\n  \\<Longrightarrow> y =\n                    nat ((int d - int d') *\n                         Number_Theory_Aux.inverse (m' - m) (order \\<G>) mod\n                         int (order \\<G>))\n  y < order \\<G>\n  \\<not> m' < m\n  m \\<noteq> m'\n  m' < order \\<G>\n  \\<^bold>g [^] d \\<otimes> (\\<^bold>g [^] y) [^] m =\n  \\<^bold>g [^] d' \\<otimes> (\\<^bold>g [^] y) [^] m'\n  [?b = ?c] (mod ?a) = [?c = ?b] (mod ?a)\n  y < order \\<G>\n  \\<not> m' < m\n  m \\<noteq> m'\n  m' < order \\<G>\n  \\<^bold>g [^] d \\<otimes> (\\<^bold>g [^] y) [^] m =\n  \\<^bold>g [^] d' \\<otimes> (\\<^bold>g [^] y) [^] m'\n\ngoal (1 subgoal):\n 1. y =\n    nat ((int d - int d') *\n         Number_Theory_Aux.inverse (m' - m) (order \\<G>) mod\n         int (order \\<G>))", "by blast"], ["proof (state)\nthis:\n  y =\n  nat ((int d - int d') *\n       Number_Theory_Aux.inverse (m' - m) (order \\<G>) mod\n       int (order \\<G>))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma set_spmf_samp_uni [simp]: \"set_spmf (sample_uniform (order \\<G>)) = {x. x < order \\<G>}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_spmf (sample_uniform (order \\<G>)) = {x. x < order \\<G>}", "by(auto simp add: sample_uniform_def)"], ["", "lemma correct:\n  shows \"spmf (ped_commit.correct_game m) True  = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. spmf (ped_commit.correct_game m) True = 1", "using finite_carrier order_gt_0_iff_finite"], ["proof (prove)\nusing this:\n  finite (carrier \\<G>)\n  (0 < order \\<G>) = finite (carrier \\<G>)\n\ngoal (1 subgoal):\n 1. spmf (ped_commit.correct_game m) True = 1", "apply(simp add: abstract_commitment.correct_game_def Let_def commit_def verify_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (carrier \\<G>) \\<Longrightarrow>\n    spmf\n     (key_gen \\<bind>\n      (\\<lambda>(ck, vk).\n          sample_uniform (order \\<G>) \\<bind>\n          (\\<lambda>y.\n              return_spmf\n               (\\<^bold>g [^] y \\<otimes> ck [^] m =\n                \\<^bold>g [^] y \\<otimes> vk [^] m))))\n     True =\n    1", "by(simp add: key_gen_def Let_def bind_spmf_const cong: bind_spmf_cong_simp)"], ["", "theorem abstract_correct:\n  shows \"ped_commit.correct\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ped_commit.correct", "unfolding abstract_commitment.correct_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>m.\n       valid_msg m \\<longrightarrow>\n       spmf (ped_commit.correct_game m) True = 1", "using correct"], ["proof (prove)\nusing this:\n  spmf (ped_commit.correct_game ?m) True = 1\n\ngoal (1 subgoal):\n 1. \\<forall>m.\n       valid_msg m \\<longrightarrow>\n       spmf (ped_commit.correct_game m) True = 1", "by simp"], ["", "lemma perfect_hiding:\n  shows \"spmf (ped_commit.hiding_game_ind_cpa \\<A>) True - 1/2 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. spmf (ped_commit.hiding_game_ind_cpa \\<A>) True - 1 / 2 = 0", "including monad_normalisation"], ["proof (prove)\ngoal (1 subgoal):\n 1. spmf (ped_commit.hiding_game_ind_cpa \\<A>) True - 1 / 2 = 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. spmf (ped_commit.hiding_game_ind_cpa \\<A>) True - 1 / 2 = 0", "obtain \\<A>1 \\<A>2 where [simp]: \"\\<A> = (\\<A>1, \\<A>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>\\<A>1 \\<A>2.\n        \\<A> = (\\<A>1, \\<A>2) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases \\<A>)"], ["proof (state)\nthis:\n  \\<A> = (\\<A>1, \\<A>2)\n\ngoal (1 subgoal):\n 1. spmf (ped_commit.hiding_game_ind_cpa \\<A>) True - 1 / 2 = 0", "note [simp] = Let_def split_def"], ["proof (state)\nthis:\n  Let ?s ?f \\<equiv> ?f ?s\n  case_prod = (\\<lambda>c p. c (fst p) (snd p))\n\ngoal (1 subgoal):\n 1. spmf (ped_commit.hiding_game_ind_cpa \\<A>) True - 1 / 2 = 0", "have \"ped_commit.hiding_game_ind_cpa (\\<A>1, \\<A>2) = TRY do {\n    (ck,vk) \\<leftarrow> key_gen;\n    ((m0, m1), \\<sigma>) \\<leftarrow> \\<A>1 vk;\n    _ :: unit \\<leftarrow> assert_spmf (valid_msg m0 \\<and> valid_msg m1);\n    b \\<leftarrow> coin_spmf;  \n    (c,d) \\<leftarrow> commit ck (if b then m0 else m1);\n    b' \\<leftarrow> \\<A>2 c \\<sigma>;\n    return_spmf (b' = b)} ELSE coin_spmf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ped_commit.hiding_game_ind_cpa (\\<A>1, \\<A>2) =\n    TRY key_gen \\<bind>\n        (\\<lambda>(ck, vk).\n            \\<A>1 vk \\<bind>\n            (\\<lambda>((m0, m1), \\<sigma>).\n                assert_spmf (valid_msg m0 \\<and> valid_msg m1) \\<bind>\n                (\\<lambda>_.\n                    coin_spmf \\<bind>\n                    (\\<lambda>b.\n                        commit ck (if b then m0 else m1) \\<bind>\n                        (\\<lambda>(c, d).\n                            \\<A>2 c \\<sigma> \\<bind>\n                            (\\<lambda>b'.\n                                return_spmf (b' = b))))))) ELSE coin_spmf", "by(simp add: abstract_commitment.hiding_game_ind_cpa_def)"], ["proof (state)\nthis:\n  ped_commit.hiding_game_ind_cpa (\\<A>1, \\<A>2) =\n  TRY key_gen \\<bind>\n      (\\<lambda>(ck, vk).\n          \\<A>1 vk \\<bind>\n          (\\<lambda>((m0, m1), \\<sigma>).\n              assert_spmf (valid_msg m0 \\<and> valid_msg m1) \\<bind>\n              (\\<lambda>_.\n                  coin_spmf \\<bind>\n                  (\\<lambda>b.\n                      commit ck (if b then m0 else m1) \\<bind>\n                      (\\<lambda>(c, d).\n                          \\<A>2 c \\<sigma> \\<bind>\n                          (\\<lambda>b'.\n                              return_spmf (b' = b))))))) ELSE coin_spmf\n\ngoal (1 subgoal):\n 1. spmf (ped_commit.hiding_game_ind_cpa \\<A>) True - 1 / 2 = 0", "also"], ["proof (state)\nthis:\n  ped_commit.hiding_game_ind_cpa (\\<A>1, \\<A>2) =\n  TRY key_gen \\<bind>\n      (\\<lambda>(ck, vk).\n          \\<A>1 vk \\<bind>\n          (\\<lambda>((m0, m1), \\<sigma>).\n              assert_spmf (valid_msg m0 \\<and> valid_msg m1) \\<bind>\n              (\\<lambda>_.\n                  coin_spmf \\<bind>\n                  (\\<lambda>b.\n                      commit ck (if b then m0 else m1) \\<bind>\n                      (\\<lambda>(c, d).\n                          \\<A>2 c \\<sigma> \\<bind>\n                          (\\<lambda>b'.\n                              return_spmf (b' = b))))))) ELSE coin_spmf\n\ngoal (1 subgoal):\n 1. spmf (ped_commit.hiding_game_ind_cpa \\<A>) True - 1 / 2 = 0", "have \"... = TRY do {\n    x :: nat \\<leftarrow> sample_uniform (order \\<G>);\n    let h = \\<^bold>g [^] x;\n    ((m0, m1), \\<sigma>) \\<leftarrow> \\<A>1 h;\n    _ :: unit \\<leftarrow> assert_spmf (valid_msg m0 \\<and> valid_msg m1);\n     b \\<leftarrow> coin_spmf; \n    d :: nat \\<leftarrow> sample_uniform (order \\<G>);\n    let c = ((\\<^bold>g [^] d) \\<otimes> (h [^] (if b then m0 else m1)));\n    b' \\<leftarrow> \\<A>2 c \\<sigma>;\n    return_spmf (b' = b)} ELSE coin_spmf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. TRY key_gen \\<bind>\n        (\\<lambda>(ck, vk).\n            \\<A>1 vk \\<bind>\n            (\\<lambda>((m0, m1), \\<sigma>).\n                assert_spmf (valid_msg m0 \\<and> valid_msg m1) \\<bind>\n                (\\<lambda>_.\n                    coin_spmf \\<bind>\n                    (\\<lambda>b.\n                        commit ck (if b then m0 else m1) \\<bind>\n                        (\\<lambda>(c, d).\n                            \\<A>2 c \\<sigma> \\<bind>\n                            (\\<lambda>b'.\n                                return_spmf (b' = b))))))) ELSE coin_spmf =\n    TRY sample_uniform (order \\<G>) \\<bind>\n        (\\<lambda>x.\n            let h = \\<^bold>g [^] x\n            in \\<A>1 h \\<bind>\n               (\\<lambda>((m0, m1), \\<sigma>).\n                   assert_spmf (valid_msg m0 \\<and> valid_msg m1) \\<bind>\n                   (\\<lambda>_.\n                       coin_spmf \\<bind>\n                       (\\<lambda>b.\n                           sample_uniform (order \\<G>) \\<bind>\n                           (\\<lambda>d.\n                               let c = \\<^bold>g [^] d \\<otimes>\n h [^] (if b then m0 else m1)\n                               in \\<A>2 c \\<sigma> \\<bind>\n                                  (\\<lambda>b'.\nreturn_spmf (b' = b))))))) ELSE coin_spmf", "by(simp add: commit_def key_gen_def)"], ["proof (state)\nthis:\n  TRY key_gen \\<bind>\n      (\\<lambda>(ck, vk).\n          \\<A>1 vk \\<bind>\n          (\\<lambda>((m0, m1), \\<sigma>).\n              assert_spmf (valid_msg m0 \\<and> valid_msg m1) \\<bind>\n              (\\<lambda>_.\n                  coin_spmf \\<bind>\n                  (\\<lambda>b.\n                      commit ck (if b then m0 else m1) \\<bind>\n                      (\\<lambda>(c, d).\n                          \\<A>2 c \\<sigma> \\<bind>\n                          (\\<lambda>b'.\n                              return_spmf (b' = b))))))) ELSE coin_spmf =\n  TRY sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>x.\n          let h = \\<^bold>g [^] x\n          in \\<A>1 h \\<bind>\n             (\\<lambda>((m0, m1), \\<sigma>).\n                 assert_spmf (valid_msg m0 \\<and> valid_msg m1) \\<bind>\n                 (\\<lambda>_.\n                     coin_spmf \\<bind>\n                     (\\<lambda>b.\n                         sample_uniform (order \\<G>) \\<bind>\n                         (\\<lambda>d.\n                             let c = \\<^bold>g [^] d \\<otimes>\n                                     h [^] (if b then m0 else m1)\n                             in \\<A>2 c \\<sigma> \\<bind>\n                                (\\<lambda>b'.\n                                    return_spmf\n                                     (b' = b))))))) ELSE coin_spmf\n\ngoal (1 subgoal):\n 1. spmf (ped_commit.hiding_game_ind_cpa \\<A>) True - 1 / 2 = 0", "also"], ["proof (state)\nthis:\n  TRY key_gen \\<bind>\n      (\\<lambda>(ck, vk).\n          \\<A>1 vk \\<bind>\n          (\\<lambda>((m0, m1), \\<sigma>).\n              assert_spmf (valid_msg m0 \\<and> valid_msg m1) \\<bind>\n              (\\<lambda>_.\n                  coin_spmf \\<bind>\n                  (\\<lambda>b.\n                      commit ck (if b then m0 else m1) \\<bind>\n                      (\\<lambda>(c, d).\n                          \\<A>2 c \\<sigma> \\<bind>\n                          (\\<lambda>b'.\n                              return_spmf (b' = b))))))) ELSE coin_spmf =\n  TRY sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>x.\n          let h = \\<^bold>g [^] x\n          in \\<A>1 h \\<bind>\n             (\\<lambda>((m0, m1), \\<sigma>).\n                 assert_spmf (valid_msg m0 \\<and> valid_msg m1) \\<bind>\n                 (\\<lambda>_.\n                     coin_spmf \\<bind>\n                     (\\<lambda>b.\n                         sample_uniform (order \\<G>) \\<bind>\n                         (\\<lambda>d.\n                             let c = \\<^bold>g [^] d \\<otimes>\n                                     h [^] (if b then m0 else m1)\n                             in \\<A>2 c \\<sigma> \\<bind>\n                                (\\<lambda>b'.\n                                    return_spmf\n                                     (b' = b))))))) ELSE coin_spmf\n\ngoal (1 subgoal):\n 1. spmf (ped_commit.hiding_game_ind_cpa \\<A>) True - 1 / 2 = 0", "have \"... = TRY do {\n    x :: nat \\<leftarrow> sample_uniform (order \\<G>);\n    let h = (\\<^bold>g [^] x);\n    ((m0, m1), \\<sigma>) \\<leftarrow> \\<A>1 h;\n    _ :: unit \\<leftarrow> assert_spmf (valid_msg m0 \\<and> valid_msg m1);\n    b \\<leftarrow> coin_spmf;  \n    z \\<leftarrow> map_spmf (\\<lambda>z.  \\<^bold>g [^] z \\<otimes> (h [^] (if b then m0 else m1))) (sample_uniform (order \\<G>));\n    guess :: bool \\<leftarrow> \\<A>2 z \\<sigma>;\n    return_spmf(guess = b)} ELSE coin_spmf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. TRY sample_uniform (order \\<G>) \\<bind>\n        (\\<lambda>x.\n            let h = \\<^bold>g [^] x\n            in \\<A>1 h \\<bind>\n               (\\<lambda>((m0, m1), \\<sigma>).\n                   assert_spmf (valid_msg m0 \\<and> valid_msg m1) \\<bind>\n                   (\\<lambda>_.\n                       coin_spmf \\<bind>\n                       (\\<lambda>b.\n                           sample_uniform (order \\<G>) \\<bind>\n                           (\\<lambda>d.\n                               let c = \\<^bold>g [^] d \\<otimes>\n h [^] (if b then m0 else m1)\n                               in \\<A>2 c \\<sigma> \\<bind>\n                                  (\\<lambda>b'.\nreturn_spmf (b' = b))))))) ELSE coin_spmf =\n    TRY sample_uniform (order \\<G>) \\<bind>\n        (\\<lambda>x.\n            let h = \\<^bold>g [^] x\n            in \\<A>1 h \\<bind>\n               (\\<lambda>((m0, m1), \\<sigma>).\n                   assert_spmf (valid_msg m0 \\<and> valid_msg m1) \\<bind>\n                   (\\<lambda>_.\n                       coin_spmf \\<bind>\n                       (\\<lambda>b.\n                           map_spmf\n                            (\\<lambda>z.\n                                \\<^bold>g [^] z \\<otimes>\n                                h [^] (if b then m0 else m1))\n                            (sample_uniform (order \\<G>)) \\<bind>\n                           (\\<lambda>z.\n                               \\<A>2 z \\<sigma> \\<bind>\n                               (\\<lambda>guess.\n                                   return_spmf\n                                    (guess = b))))))) ELSE coin_spmf", "by(simp add: bind_map_spmf o_def)"], ["proof (state)\nthis:\n  TRY sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>x.\n          let h = \\<^bold>g [^] x\n          in \\<A>1 h \\<bind>\n             (\\<lambda>((m0, m1), \\<sigma>).\n                 assert_spmf (valid_msg m0 \\<and> valid_msg m1) \\<bind>\n                 (\\<lambda>_.\n                     coin_spmf \\<bind>\n                     (\\<lambda>b.\n                         sample_uniform (order \\<G>) \\<bind>\n                         (\\<lambda>d.\n                             let c = \\<^bold>g [^] d \\<otimes>\n                                     h [^] (if b then m0 else m1)\n                             in \\<A>2 c \\<sigma> \\<bind>\n                                (\\<lambda>b'.\n                                    return_spmf\n                                     (b' = b))))))) ELSE coin_spmf =\n  TRY sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>x.\n          let h = \\<^bold>g [^] x\n          in \\<A>1 h \\<bind>\n             (\\<lambda>((m0, m1), \\<sigma>).\n                 assert_spmf (valid_msg m0 \\<and> valid_msg m1) \\<bind>\n                 (\\<lambda>_.\n                     coin_spmf \\<bind>\n                     (\\<lambda>b.\n                         map_spmf\n                          (\\<lambda>z.\n                              \\<^bold>g [^] z \\<otimes>\n                              h [^] (if b then m0 else m1))\n                          (sample_uniform (order \\<G>)) \\<bind>\n                         (\\<lambda>z.\n                             \\<A>2 z \\<sigma> \\<bind>\n                             (\\<lambda>guess.\n                                 return_spmf\n                                  (guess = b))))))) ELSE coin_spmf\n\ngoal (1 subgoal):\n 1. spmf (ped_commit.hiding_game_ind_cpa \\<A>) True - 1 / 2 = 0", "also"], ["proof (state)\nthis:\n  TRY sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>x.\n          let h = \\<^bold>g [^] x\n          in \\<A>1 h \\<bind>\n             (\\<lambda>((m0, m1), \\<sigma>).\n                 assert_spmf (valid_msg m0 \\<and> valid_msg m1) \\<bind>\n                 (\\<lambda>_.\n                     coin_spmf \\<bind>\n                     (\\<lambda>b.\n                         sample_uniform (order \\<G>) \\<bind>\n                         (\\<lambda>d.\n                             let c = \\<^bold>g [^] d \\<otimes>\n                                     h [^] (if b then m0 else m1)\n                             in \\<A>2 c \\<sigma> \\<bind>\n                                (\\<lambda>b'.\n                                    return_spmf\n                                     (b' = b))))))) ELSE coin_spmf =\n  TRY sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>x.\n          let h = \\<^bold>g [^] x\n          in \\<A>1 h \\<bind>\n             (\\<lambda>((m0, m1), \\<sigma>).\n                 assert_spmf (valid_msg m0 \\<and> valid_msg m1) \\<bind>\n                 (\\<lambda>_.\n                     coin_spmf \\<bind>\n                     (\\<lambda>b.\n                         map_spmf\n                          (\\<lambda>z.\n                              \\<^bold>g [^] z \\<otimes>\n                              h [^] (if b then m0 else m1))\n                          (sample_uniform (order \\<G>)) \\<bind>\n                         (\\<lambda>z.\n                             \\<A>2 z \\<sigma> \\<bind>\n                             (\\<lambda>guess.\n                                 return_spmf\n                                  (guess = b))))))) ELSE coin_spmf\n\ngoal (1 subgoal):\n 1. spmf (ped_commit.hiding_game_ind_cpa \\<A>) True - 1 / 2 = 0", "have \"... = TRY do {\n    x :: nat \\<leftarrow> sample_uniform (order \\<G>);\n    let h = (\\<^bold>g [^] x);\n    ((m0, m1), \\<sigma>) \\<leftarrow> \\<A>1 h;\n    _ :: unit \\<leftarrow> assert_spmf (valid_msg m0 \\<and> valid_msg m1);\n    b \\<leftarrow> coin_spmf;  \n    z \\<leftarrow> map_spmf (\\<lambda>z. \\<^bold>g [^] z) (sample_uniform (order \\<G>));\n    guess :: bool \\<leftarrow> \\<A>2 z \\<sigma>;\n    return_spmf(guess = b)} ELSE coin_spmf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. TRY sample_uniform (order \\<G>) \\<bind>\n        (\\<lambda>x.\n            let h = \\<^bold>g [^] x\n            in \\<A>1 h \\<bind>\n               (\\<lambda>((m0, m1), \\<sigma>).\n                   assert_spmf (valid_msg m0 \\<and> valid_msg m1) \\<bind>\n                   (\\<lambda>_.\n                       coin_spmf \\<bind>\n                       (\\<lambda>b.\n                           map_spmf\n                            (\\<lambda>z.\n                                \\<^bold>g [^] z \\<otimes>\n                                h [^] (if b then m0 else m1))\n                            (sample_uniform (order \\<G>)) \\<bind>\n                           (\\<lambda>z.\n                               \\<A>2 z \\<sigma> \\<bind>\n                               (\\<lambda>guess.\n                                   return_spmf\n                                    (guess = b))))))) ELSE coin_spmf =\n    TRY sample_uniform (order \\<G>) \\<bind>\n        (\\<lambda>x.\n            let h = \\<^bold>g [^] x\n            in \\<A>1 h \\<bind>\n               (\\<lambda>((m0, m1), \\<sigma>).\n                   assert_spmf (valid_msg m0 \\<and> valid_msg m1) \\<bind>\n                   (\\<lambda>_.\n                       coin_spmf \\<bind>\n                       (\\<lambda>b.\n                           map_spmf (([^]) \\<^bold>g)\n                            (sample_uniform (order \\<G>)) \\<bind>\n                           (\\<lambda>z.\n                               \\<A>2 z \\<sigma> \\<bind>\n                               (\\<lambda>guess.\n                                   return_spmf\n                                    (guess = b))))))) ELSE coin_spmf", "by(simp add: sample_uniform_one_time_pad)"], ["proof (state)\nthis:\n  TRY sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>x.\n          let h = \\<^bold>g [^] x\n          in \\<A>1 h \\<bind>\n             (\\<lambda>((m0, m1), \\<sigma>).\n                 assert_spmf (valid_msg m0 \\<and> valid_msg m1) \\<bind>\n                 (\\<lambda>_.\n                     coin_spmf \\<bind>\n                     (\\<lambda>b.\n                         map_spmf\n                          (\\<lambda>z.\n                              \\<^bold>g [^] z \\<otimes>\n                              h [^] (if b then m0 else m1))\n                          (sample_uniform (order \\<G>)) \\<bind>\n                         (\\<lambda>z.\n                             \\<A>2 z \\<sigma> \\<bind>\n                             (\\<lambda>guess.\n                                 return_spmf\n                                  (guess = b))))))) ELSE coin_spmf =\n  TRY sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>x.\n          let h = \\<^bold>g [^] x\n          in \\<A>1 h \\<bind>\n             (\\<lambda>((m0, m1), \\<sigma>).\n                 assert_spmf (valid_msg m0 \\<and> valid_msg m1) \\<bind>\n                 (\\<lambda>_.\n                     coin_spmf \\<bind>\n                     (\\<lambda>b.\n                         map_spmf (([^]) \\<^bold>g)\n                          (sample_uniform (order \\<G>)) \\<bind>\n                         (\\<lambda>z.\n                             \\<A>2 z \\<sigma> \\<bind>\n                             (\\<lambda>guess.\n                                 return_spmf\n                                  (guess = b))))))) ELSE coin_spmf\n\ngoal (1 subgoal):\n 1. spmf (ped_commit.hiding_game_ind_cpa \\<A>) True - 1 / 2 = 0", "also"], ["proof (state)\nthis:\n  TRY sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>x.\n          let h = \\<^bold>g [^] x\n          in \\<A>1 h \\<bind>\n             (\\<lambda>((m0, m1), \\<sigma>).\n                 assert_spmf (valid_msg m0 \\<and> valid_msg m1) \\<bind>\n                 (\\<lambda>_.\n                     coin_spmf \\<bind>\n                     (\\<lambda>b.\n                         map_spmf\n                          (\\<lambda>z.\n                              \\<^bold>g [^] z \\<otimes>\n                              h [^] (if b then m0 else m1))\n                          (sample_uniform (order \\<G>)) \\<bind>\n                         (\\<lambda>z.\n                             \\<A>2 z \\<sigma> \\<bind>\n                             (\\<lambda>guess.\n                                 return_spmf\n                                  (guess = b))))))) ELSE coin_spmf =\n  TRY sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>x.\n          let h = \\<^bold>g [^] x\n          in \\<A>1 h \\<bind>\n             (\\<lambda>((m0, m1), \\<sigma>).\n                 assert_spmf (valid_msg m0 \\<and> valid_msg m1) \\<bind>\n                 (\\<lambda>_.\n                     coin_spmf \\<bind>\n                     (\\<lambda>b.\n                         map_spmf (([^]) \\<^bold>g)\n                          (sample_uniform (order \\<G>)) \\<bind>\n                         (\\<lambda>z.\n                             \\<A>2 z \\<sigma> \\<bind>\n                             (\\<lambda>guess.\n                                 return_spmf\n                                  (guess = b))))))) ELSE coin_spmf\n\ngoal (1 subgoal):\n 1. spmf (ped_commit.hiding_game_ind_cpa \\<A>) True - 1 / 2 = 0", "have \"... = TRY do {\n    x :: nat \\<leftarrow> sample_uniform (order \\<G>);\n    let h = (\\<^bold>g [^] x);\n    ((m0, m1), \\<sigma>) \\<leftarrow> \\<A>1 h;\n    _ :: unit \\<leftarrow> assert_spmf (valid_msg m0 \\<and> valid_msg m1);\n    z \\<leftarrow> map_spmf (\\<lambda>z.  \\<^bold>g [^] z)  (sample_uniform (order \\<G>));\n    guess :: bool \\<leftarrow> \\<A>2 z \\<sigma>;\n    map_spmf((=) guess) coin_spmf} ELSE coin_spmf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. TRY sample_uniform (order \\<G>) \\<bind>\n        (\\<lambda>x.\n            let h = \\<^bold>g [^] x\n            in \\<A>1 h \\<bind>\n               (\\<lambda>((m0, m1), \\<sigma>).\n                   assert_spmf (valid_msg m0 \\<and> valid_msg m1) \\<bind>\n                   (\\<lambda>_.\n                       coin_spmf \\<bind>\n                       (\\<lambda>b.\n                           map_spmf (([^]) \\<^bold>g)\n                            (sample_uniform (order \\<G>)) \\<bind>\n                           (\\<lambda>z.\n                               \\<A>2 z \\<sigma> \\<bind>\n                               (\\<lambda>guess.\n                                   return_spmf\n                                    (guess = b))))))) ELSE coin_spmf =\n    TRY sample_uniform (order \\<G>) \\<bind>\n        (\\<lambda>x.\n            let h = \\<^bold>g [^] x\n            in \\<A>1 h \\<bind>\n               (\\<lambda>((m0, m1), \\<sigma>).\n                   assert_spmf (valid_msg m0 \\<and> valid_msg m1) \\<bind>\n                   (\\<lambda>_.\n                       map_spmf (([^]) \\<^bold>g)\n                        (sample_uniform (order \\<G>)) \\<bind>\n                       (\\<lambda>z.\n                           \\<A>2 z \\<sigma> \\<bind>\n                           (\\<lambda>guess.\n                               map_spmf ((=) guess)\n                                coin_spmf))))) ELSE coin_spmf", "by(simp add: map_spmf_conv_bind_spmf)"], ["proof (state)\nthis:\n  TRY sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>x.\n          let h = \\<^bold>g [^] x\n          in \\<A>1 h \\<bind>\n             (\\<lambda>((m0, m1), \\<sigma>).\n                 assert_spmf (valid_msg m0 \\<and> valid_msg m1) \\<bind>\n                 (\\<lambda>_.\n                     coin_spmf \\<bind>\n                     (\\<lambda>b.\n                         map_spmf (([^]) \\<^bold>g)\n                          (sample_uniform (order \\<G>)) \\<bind>\n                         (\\<lambda>z.\n                             \\<A>2 z \\<sigma> \\<bind>\n                             (\\<lambda>guess.\n                                 return_spmf\n                                  (guess = b))))))) ELSE coin_spmf =\n  TRY sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>x.\n          let h = \\<^bold>g [^] x\n          in \\<A>1 h \\<bind>\n             (\\<lambda>((m0, m1), \\<sigma>).\n                 assert_spmf (valid_msg m0 \\<and> valid_msg m1) \\<bind>\n                 (\\<lambda>_.\n                     map_spmf (([^]) \\<^bold>g)\n                      (sample_uniform (order \\<G>)) \\<bind>\n                     (\\<lambda>z.\n                         \\<A>2 z \\<sigma> \\<bind>\n                         (\\<lambda>guess.\n                             map_spmf ((=) guess)\n                              coin_spmf))))) ELSE coin_spmf\n\ngoal (1 subgoal):\n 1. spmf (ped_commit.hiding_game_ind_cpa \\<A>) True - 1 / 2 = 0", "also"], ["proof (state)\nthis:\n  TRY sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>x.\n          let h = \\<^bold>g [^] x\n          in \\<A>1 h \\<bind>\n             (\\<lambda>((m0, m1), \\<sigma>).\n                 assert_spmf (valid_msg m0 \\<and> valid_msg m1) \\<bind>\n                 (\\<lambda>_.\n                     coin_spmf \\<bind>\n                     (\\<lambda>b.\n                         map_spmf (([^]) \\<^bold>g)\n                          (sample_uniform (order \\<G>)) \\<bind>\n                         (\\<lambda>z.\n                             \\<A>2 z \\<sigma> \\<bind>\n                             (\\<lambda>guess.\n                                 return_spmf\n                                  (guess = b))))))) ELSE coin_spmf =\n  TRY sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>x.\n          let h = \\<^bold>g [^] x\n          in \\<A>1 h \\<bind>\n             (\\<lambda>((m0, m1), \\<sigma>).\n                 assert_spmf (valid_msg m0 \\<and> valid_msg m1) \\<bind>\n                 (\\<lambda>_.\n                     map_spmf (([^]) \\<^bold>g)\n                      (sample_uniform (order \\<G>)) \\<bind>\n                     (\\<lambda>z.\n                         \\<A>2 z \\<sigma> \\<bind>\n                         (\\<lambda>guess.\n                             map_spmf ((=) guess)\n                              coin_spmf))))) ELSE coin_spmf\n\ngoal (1 subgoal):\n 1. spmf (ped_commit.hiding_game_ind_cpa \\<A>) True - 1 / 2 = 0", "have \"... = coin_spmf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. TRY sample_uniform (order \\<G>) \\<bind>\n        (\\<lambda>x.\n            let h = \\<^bold>g [^] x\n            in \\<A>1 h \\<bind>\n               (\\<lambda>((m0, m1), \\<sigma>).\n                   assert_spmf (valid_msg m0 \\<and> valid_msg m1) \\<bind>\n                   (\\<lambda>_.\n                       map_spmf (([^]) \\<^bold>g)\n                        (sample_uniform (order \\<G>)) \\<bind>\n                       (\\<lambda>z.\n                           \\<A>2 z \\<sigma> \\<bind>\n                           (\\<lambda>guess.\n                               map_spmf ((=) guess)\n                                coin_spmf))))) ELSE coin_spmf =\n    coin_spmf", "by(auto simp add: bind_spmf_const map_eq_const_coin_spmf try_bind_spmf_lossless2' scale_bind_spmf weight_spmf_le_1 scale_scale_spmf)"], ["proof (state)\nthis:\n  TRY sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>x.\n          let h = \\<^bold>g [^] x\n          in \\<A>1 h \\<bind>\n             (\\<lambda>((m0, m1), \\<sigma>).\n                 assert_spmf (valid_msg m0 \\<and> valid_msg m1) \\<bind>\n                 (\\<lambda>_.\n                     map_spmf (([^]) \\<^bold>g)\n                      (sample_uniform (order \\<G>)) \\<bind>\n                     (\\<lambda>z.\n                         \\<A>2 z \\<sigma> \\<bind>\n                         (\\<lambda>guess.\n                             map_spmf ((=) guess)\n                              coin_spmf))))) ELSE coin_spmf =\n  coin_spmf\n\ngoal (1 subgoal):\n 1. spmf (ped_commit.hiding_game_ind_cpa \\<A>) True - 1 / 2 = 0", "ultimately"], ["proof (chain)\npicking this:\n  ped_commit.hiding_game_ind_cpa (\\<A>1, \\<A>2) =\n  TRY sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>x.\n          let h = \\<^bold>g [^] x\n          in \\<A>1 h \\<bind>\n             (\\<lambda>((m0, m1), \\<sigma>).\n                 assert_spmf (valid_msg m0 \\<and> valid_msg m1) \\<bind>\n                 (\\<lambda>_.\n                     map_spmf (([^]) \\<^bold>g)\n                      (sample_uniform (order \\<G>)) \\<bind>\n                     (\\<lambda>z.\n                         \\<A>2 z \\<sigma> \\<bind>\n                         (\\<lambda>guess.\n                             map_spmf ((=) guess)\n                              coin_spmf))))) ELSE coin_spmf\n  TRY sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>x.\n          let h = \\<^bold>g [^] x\n          in \\<A>1 h \\<bind>\n             (\\<lambda>((m0, m1), \\<sigma>).\n                 assert_spmf (valid_msg m0 \\<and> valid_msg m1) \\<bind>\n                 (\\<lambda>_.\n                     map_spmf (([^]) \\<^bold>g)\n                      (sample_uniform (order \\<G>)) \\<bind>\n                     (\\<lambda>z.\n                         \\<A>2 z \\<sigma> \\<bind>\n                         (\\<lambda>guess.\n                             map_spmf ((=) guess)\n                              coin_spmf))))) ELSE coin_spmf =\n  coin_spmf", "show ?thesis"], ["proof (prove)\nusing this:\n  ped_commit.hiding_game_ind_cpa (\\<A>1, \\<A>2) =\n  TRY sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>x.\n          let h = \\<^bold>g [^] x\n          in \\<A>1 h \\<bind>\n             (\\<lambda>((m0, m1), \\<sigma>).\n                 assert_spmf (valid_msg m0 \\<and> valid_msg m1) \\<bind>\n                 (\\<lambda>_.\n                     map_spmf (([^]) \\<^bold>g)\n                      (sample_uniform (order \\<G>)) \\<bind>\n                     (\\<lambda>z.\n                         \\<A>2 z \\<sigma> \\<bind>\n                         (\\<lambda>guess.\n                             map_spmf ((=) guess)\n                              coin_spmf))))) ELSE coin_spmf\n  TRY sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>x.\n          let h = \\<^bold>g [^] x\n          in \\<A>1 h \\<bind>\n             (\\<lambda>((m0, m1), \\<sigma>).\n                 assert_spmf (valid_msg m0 \\<and> valid_msg m1) \\<bind>\n                 (\\<lambda>_.\n                     map_spmf (([^]) \\<^bold>g)\n                      (sample_uniform (order \\<G>)) \\<bind>\n                     (\\<lambda>z.\n                         \\<A>2 z \\<sigma> \\<bind>\n                         (\\<lambda>guess.\n                             map_spmf ((=) guess)\n                              coin_spmf))))) ELSE coin_spmf =\n  coin_spmf\n\ngoal (1 subgoal):\n 1. spmf (ped_commit.hiding_game_ind_cpa \\<A>) True - 1 / 2 = 0", "by(simp add: spmf_of_set)"], ["proof (state)\nthis:\n  spmf (ped_commit.hiding_game_ind_cpa \\<A>) True - 1 / 2 = 0\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem abstract_perfect_hiding: \n  shows \"ped_commit.perfect_hiding_ind_cpa \\<A>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ped_commit.perfect_hiding_ind_cpa \\<A>", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. ped_commit.perfect_hiding_ind_cpa \\<A>", "have \"spmf (ped_commit.hiding_game_ind_cpa \\<A>) True - 1/2 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. spmf (ped_commit.hiding_game_ind_cpa \\<A>) True - 1 / 2 = 0", "using perfect_hiding"], ["proof (prove)\nusing this:\n  spmf (ped_commit.hiding_game_ind_cpa ?\\<A>) True - 1 / 2 = 0\n\ngoal (1 subgoal):\n 1. spmf (ped_commit.hiding_game_ind_cpa \\<A>) True - 1 / 2 = 0", "by fastforce"], ["proof (state)\nthis:\n  spmf (ped_commit.hiding_game_ind_cpa \\<A>) True - 1 / 2 = 0\n\ngoal (1 subgoal):\n 1. ped_commit.perfect_hiding_ind_cpa \\<A>", "thus ?thesis"], ["proof (prove)\nusing this:\n  spmf (ped_commit.hiding_game_ind_cpa \\<A>) True - 1 / 2 = 0\n\ngoal (1 subgoal):\n 1. ped_commit.perfect_hiding_ind_cpa \\<A>", "by(simp add: abstract_commitment.perfect_hiding_ind_cpa_def abstract_commitment.hiding_advantage_ind_cpa_def)"], ["proof (state)\nthis:\n  ped_commit.perfect_hiding_ind_cpa \\<A>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bind_output_cong:  \n  assumes \"x < order \\<G>\" \n  shows \"(x = nat ((int b - int ab) * fst (bezw (aa - ac) (order \\<G>)) mod int (order \\<G>)))\n            \\<longleftrightarrow> [x = nat ((int b - int ab) * fst (bezw (aa - ac) (order \\<G>)) mod int (order \\<G>))] (mod order \\<G>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x =\n     nat ((int b - int ab) *\n          Number_Theory_Aux.inverse (aa - ac) (order \\<G>) mod\n          int (order \\<G>))) =\n    [x = nat ((int b - int ab) *\n              Number_Theory_Aux.inverse (aa - ac) (order \\<G>) mod\n              int (order \\<G>))] (mod order \\<G>)", "using assms cong_less_modulus_unique_nat nat_less_iff"], ["proof (prove)\nusing this:\n  x < order \\<G>\n  \\<lbrakk>[?x = ?y] (mod ?m); ?x < ?m; ?y < ?m\\<rbrakk>\n  \\<Longrightarrow> ?x = ?y\n  0 \\<le> ?w \\<Longrightarrow> (nat ?w < ?m) = (?w < int ?m)\n\ngoal (1 subgoal):\n 1. (x =\n     nat ((int b - int ab) *\n          Number_Theory_Aux.inverse (aa - ac) (order \\<G>) mod\n          int (order \\<G>))) =\n    [x = nat ((int b - int ab) *\n              Number_Theory_Aux.inverse (aa - ac) (order \\<G>) mod\n              int (order \\<G>))] (mod order \\<G>)", "by auto"], ["", "lemma bind_game_eq_dis_log:\n  shows \"ped_commit.bind_game \\<A> = discrete_log.dis_log (dis_log_\\<A> \\<A>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ped_commit.bind_game \\<A> = discrete_log.dis_log (dis_log_\\<A> \\<A>)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. ped_commit.bind_game \\<A> = discrete_log.dis_log (dis_log_\\<A> \\<A>)", "note [simp] = Let_def split_def"], ["proof (state)\nthis:\n  Let ?s ?f \\<equiv> ?f ?s\n  case_prod = (\\<lambda>c p. c (fst p) (snd p))\n\ngoal (1 subgoal):\n 1. ped_commit.bind_game \\<A> = discrete_log.dis_log (dis_log_\\<A> \\<A>)", "have \"ped_commit.bind_game \\<A> = TRY do {\n    (ck,vk) \\<leftarrow> key_gen;\n    (c, m, d, m', d') \\<leftarrow> \\<A> ck;\n    _ :: unit \\<leftarrow> assert_spmf(m \\<noteq> m' \\<and> valid_msg m \\<and> valid_msg m'); \n    let b = verify vk m c d;\n    let b' = verify vk m' c d';\n    _ :: unit \\<leftarrow> assert_spmf (b \\<and> b');\n    return_spmf True} ELSE return_spmf False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ped_commit.bind_game \\<A> =\n    TRY key_gen \\<bind>\n        (\\<lambda>(ck, vk).\n            \\<A> ck \\<bind>\n            (\\<lambda>(c, m, d, m', d').\n                assert_spmf\n                 (m \\<noteq> m' \\<and>\n                  valid_msg m \\<and> valid_msg m') \\<bind>\n                (\\<lambda>_.\n                    let b = verify vk m c d; b' = verify vk m' c d'\n                    in assert_spmf (b \\<and> b') \\<bind>\n                       (\\<lambda>_.\n                           return_spmf True)))) ELSE return_spmf False", "by(simp add: abstract_commitment.bind_game_alt_def)"], ["proof (state)\nthis:\n  ped_commit.bind_game \\<A> =\n  TRY key_gen \\<bind>\n      (\\<lambda>(ck, vk).\n          \\<A> ck \\<bind>\n          (\\<lambda>(c, m, d, m', d').\n              assert_spmf\n               (m \\<noteq> m' \\<and>\n                valid_msg m \\<and> valid_msg m') \\<bind>\n              (\\<lambda>_.\n                  let b = verify vk m c d; b' = verify vk m' c d'\n                  in assert_spmf (b \\<and> b') \\<bind>\n                     (\\<lambda>_.\n                         return_spmf True)))) ELSE return_spmf False\n\ngoal (1 subgoal):\n 1. ped_commit.bind_game \\<A> = discrete_log.dis_log (dis_log_\\<A> \\<A>)", "also"], ["proof (state)\nthis:\n  ped_commit.bind_game \\<A> =\n  TRY key_gen \\<bind>\n      (\\<lambda>(ck, vk).\n          \\<A> ck \\<bind>\n          (\\<lambda>(c, m, d, m', d').\n              assert_spmf\n               (m \\<noteq> m' \\<and>\n                valid_msg m \\<and> valid_msg m') \\<bind>\n              (\\<lambda>_.\n                  let b = verify vk m c d; b' = verify vk m' c d'\n                  in assert_spmf (b \\<and> b') \\<bind>\n                     (\\<lambda>_.\n                         return_spmf True)))) ELSE return_spmf False\n\ngoal (1 subgoal):\n 1. ped_commit.bind_game \\<A> = discrete_log.dis_log (dis_log_\\<A> \\<A>)", "have \"... = TRY do {\n    x :: nat \\<leftarrow> sample_uniform (Coset.order \\<G>);\n    (c, m, d, m', d') \\<leftarrow> \\<A> (\\<^bold>g [^] x);\n    _ :: unit \\<leftarrow> assert_spmf (m \\<noteq> m' \\<and> valid_msg m \\<and> valid_msg m'); \n    _ :: unit \\<leftarrow> assert_spmf (c = \\<^bold>g [^] d \\<otimes>  (\\<^bold>g [^] x) [^] m \\<and> c = \\<^bold>g [^] d' \\<otimes> (\\<^bold>g [^] x) [^] m');\n    return_spmf True} ELSE return_spmf False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. TRY key_gen \\<bind>\n        (\\<lambda>(ck, vk).\n            \\<A> ck \\<bind>\n            (\\<lambda>(c, m, d, m', d').\n                assert_spmf\n                 (m \\<noteq> m' \\<and>\n                  valid_msg m \\<and> valid_msg m') \\<bind>\n                (\\<lambda>_.\n                    let b = verify vk m c d; b' = verify vk m' c d'\n                    in assert_spmf (b \\<and> b') \\<bind>\n                       (\\<lambda>_.\n                           return_spmf True)))) ELSE return_spmf False =\n    TRY sample_uniform (order \\<G>) \\<bind>\n        (\\<lambda>x.\n            \\<A> (\\<^bold>g [^] x) \\<bind>\n            (\\<lambda>(c, m, d, m', d').\n                assert_spmf\n                 (m \\<noteq> m' \\<and>\n                  valid_msg m \\<and> valid_msg m') \\<bind>\n                (\\<lambda>_.\n                    assert_spmf\n                     (c =\n                      \\<^bold>g [^] d \\<otimes>\n                      (\\<^bold>g [^] x) [^] m \\<and>\n                      c =\n                      \\<^bold>g [^] d' \\<otimes>\n                      (\\<^bold>g [^] x) [^] m') \\<bind>\n                    (\\<lambda>_. return_spmf True)))) ELSE return_spmf False", "by(simp add: verify_def key_gen_def)"], ["proof (state)\nthis:\n  TRY key_gen \\<bind>\n      (\\<lambda>(ck, vk).\n          \\<A> ck \\<bind>\n          (\\<lambda>(c, m, d, m', d').\n              assert_spmf\n               (m \\<noteq> m' \\<and>\n                valid_msg m \\<and> valid_msg m') \\<bind>\n              (\\<lambda>_.\n                  let b = verify vk m c d; b' = verify vk m' c d'\n                  in assert_spmf (b \\<and> b') \\<bind>\n                     (\\<lambda>_.\n                         return_spmf True)))) ELSE return_spmf False =\n  TRY sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>x.\n          \\<A> (\\<^bold>g [^] x) \\<bind>\n          (\\<lambda>(c, m, d, m', d').\n              assert_spmf\n               (m \\<noteq> m' \\<and>\n                valid_msg m \\<and> valid_msg m') \\<bind>\n              (\\<lambda>_.\n                  assert_spmf\n                   (c =\n                    \\<^bold>g [^] d \\<otimes> (\\<^bold>g [^] x) [^] m \\<and>\n                    c =\n                    \\<^bold>g [^] d' \\<otimes>\n                    (\\<^bold>g [^] x) [^] m') \\<bind>\n                  (\\<lambda>_. return_spmf True)))) ELSE return_spmf False\n\ngoal (1 subgoal):\n 1. ped_commit.bind_game \\<A> = discrete_log.dis_log (dis_log_\\<A> \\<A>)", "also"], ["proof (state)\nthis:\n  TRY key_gen \\<bind>\n      (\\<lambda>(ck, vk).\n          \\<A> ck \\<bind>\n          (\\<lambda>(c, m, d, m', d').\n              assert_spmf\n               (m \\<noteq> m' \\<and>\n                valid_msg m \\<and> valid_msg m') \\<bind>\n              (\\<lambda>_.\n                  let b = verify vk m c d; b' = verify vk m' c d'\n                  in assert_spmf (b \\<and> b') \\<bind>\n                     (\\<lambda>_.\n                         return_spmf True)))) ELSE return_spmf False =\n  TRY sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>x.\n          \\<A> (\\<^bold>g [^] x) \\<bind>\n          (\\<lambda>(c, m, d, m', d').\n              assert_spmf\n               (m \\<noteq> m' \\<and>\n                valid_msg m \\<and> valid_msg m') \\<bind>\n              (\\<lambda>_.\n                  assert_spmf\n                   (c =\n                    \\<^bold>g [^] d \\<otimes> (\\<^bold>g [^] x) [^] m \\<and>\n                    c =\n                    \\<^bold>g [^] d' \\<otimes>\n                    (\\<^bold>g [^] x) [^] m') \\<bind>\n                  (\\<lambda>_. return_spmf True)))) ELSE return_spmf False\n\ngoal (1 subgoal):\n 1. ped_commit.bind_game \\<A> = discrete_log.dis_log (dis_log_\\<A> \\<A>)", "have \"... = TRY do {\n    x :: nat \\<leftarrow> sample_uniform (order \\<G>);\n    (c, m, d, m', d') \\<leftarrow> \\<A> (\\<^bold>g [^] x);\n    _ :: unit \\<leftarrow> assert_spmf (m \\<noteq> m' \\<and> valid_msg m \\<and> valid_msg m'); \n    _ :: unit \\<leftarrow> assert_spmf (c = \\<^bold>g [^] d \\<otimes>  (\\<^bold>g [^] x) [^] m \\<and> c = \\<^bold>g [^] d' \\<otimes> (\\<^bold>g [^] x) [^] m');\n    return_spmf (x = (if (m > m') then (nat ((int d' - int d) * (fst (bezw ((m - m')) (order \\<G>))) mod order \\<G>)) else \n                  (nat ((int d - int d') * (fst (bezw ((m' - m)) (order \\<G>))) mod order \\<G>))))} ELSE return_spmf False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. TRY sample_uniform (order \\<G>) \\<bind>\n        (\\<lambda>x.\n            \\<A> (\\<^bold>g [^] x) \\<bind>\n            (\\<lambda>(c, m, d, m', d').\n                assert_spmf\n                 (m \\<noteq> m' \\<and>\n                  valid_msg m \\<and> valid_msg m') \\<bind>\n                (\\<lambda>_.\n                    assert_spmf\n                     (c =\n                      \\<^bold>g [^] d \\<otimes>\n                      (\\<^bold>g [^] x) [^] m \\<and>\n                      c =\n                      \\<^bold>g [^] d' \\<otimes>\n                      (\\<^bold>g [^] x) [^] m') \\<bind>\n                    (\\<lambda>_.\n                        return_spmf True)))) ELSE return_spmf False =\n    TRY sample_uniform (order \\<G>) \\<bind>\n        (\\<lambda>x.\n            \\<A> (\\<^bold>g [^] x) \\<bind>\n            (\\<lambda>(c, m, d, m', d').\n                assert_spmf\n                 (m \\<noteq> m' \\<and>\n                  valid_msg m \\<and> valid_msg m') \\<bind>\n                (\\<lambda>_.\n                    assert_spmf\n                     (c =\n                      \\<^bold>g [^] d \\<otimes>\n                      (\\<^bold>g [^] x) [^] m \\<and>\n                      c =\n                      \\<^bold>g [^] d' \\<otimes>\n                      (\\<^bold>g [^] x) [^] m') \\<bind>\n                    (\\<lambda>_.\n                        return_spmf\n                         (x =\n                          (if m' < m\n                           then nat ((int d' - int d) *\n                                     Number_Theory_Aux.inverse (m - m')\n(order \\<G>) mod\n                                     int (order \\<G>))\n                           else nat ((int d - int d') *\n                                     Number_Theory_Aux.inverse (m' - m)\n(order \\<G>) mod\n                                     int\n(order \\<G>)))))))) ELSE return_spmf False", "apply(intro try_spmf_cong bind_spmf_cong[OF refl]; clarsimp?)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x a aa ab ac b.\n       \\<lbrakk>x < order \\<G>;\n        (a, aa, ab, ac, b) \\<in> set_spmf (\\<A> (\\<^bold>g [^] x))\\<rbrakk>\n       \\<Longrightarrow> (ac < aa \\<longrightarrow>\n                          assert_spmf\n                           (valid_msg aa \\<and> valid_msg ac) \\<bind>\n                          (\\<lambda>_.\n                              assert_spmf\n                               (a =\n                                \\<^bold>g [^] ab \\<otimes>\n                                (\\<^bold>g [^] x) [^] aa \\<and>\n                                a =\n                                \\<^bold>g [^] b \\<otimes>\n                                (\\<^bold>g [^] x) [^] ac) \\<bind>\n                              (\\<lambda>_. return_spmf True)) =\n                          assert_spmf\n                           (valid_msg aa \\<and> valid_msg ac) \\<bind>\n                          (\\<lambda>_.\n                              assert_spmf\n                               (a =\n                                \\<^bold>g [^] ab \\<otimes>\n                                (\\<^bold>g [^] x) [^] aa \\<and>\n                                a =\n                                \\<^bold>g [^] b \\<otimes>\n                                (\\<^bold>g [^] x) [^] ac) \\<bind>\n                              (\\<lambda>_.\n                                  return_spmf\n                                   (x =\n                                    nat ((int b - int ab) *\n   Number_Theory_Aux.inverse (aa - ac) (order \\<G>) mod\n   int (order \\<G>)))))) \\<and>\n                         (\\<not> ac < aa \\<longrightarrow>\n                          assert_spmf\n                           (aa \\<noteq> ac \\<and>\n                            valid_msg aa \\<and> valid_msg ac) \\<bind>\n                          (\\<lambda>_.\n                              assert_spmf\n                               (a =\n                                \\<^bold>g [^] ab \\<otimes>\n                                (\\<^bold>g [^] x) [^] aa \\<and>\n                                a =\n                                \\<^bold>g [^] b \\<otimes>\n                                (\\<^bold>g [^] x) [^] ac) \\<bind>\n                              (\\<lambda>_. return_spmf True)) =\n                          assert_spmf\n                           (aa \\<noteq> ac \\<and>\n                            valid_msg aa \\<and> valid_msg ac) \\<bind>\n                          (\\<lambda>_.\n                              assert_spmf\n                               (a =\n                                \\<^bold>g [^] ab \\<otimes>\n                                (\\<^bold>g [^] x) [^] aa \\<and>\n                                a =\n                                \\<^bold>g [^] b \\<otimes>\n                                (\\<^bold>g [^] x) [^] ac) \\<bind>\n                              (\\<lambda>_.\n                                  return_spmf\n                                   (x =\n                                    nat ((int ab - int b) *\n   Number_Theory_Aux.inverse (ac - aa) (order \\<G>) mod\n   int (order \\<G>))))))", "apply(auto simp add: valid_msg_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x a aa ab ac b.\n       \\<lbrakk>x < order \\<G>;\n        (a, aa, ab, ac, b) \\<in> set_spmf (\\<A> (\\<^bold>g [^] x));\n        ac < aa\\<rbrakk>\n       \\<Longrightarrow> assert_spmf\n                          (aa < order \\<G> \\<and> ac < order \\<G>) \\<bind>\n                         (\\<lambda>_.\n                             assert_spmf\n                              (a =\n                               \\<^bold>g [^] ab \\<otimes>\n                               (\\<^bold>g [^] x) [^] aa \\<and>\n                               a =\n                               \\<^bold>g [^] b \\<otimes>\n                               (\\<^bold>g [^] x) [^] ac) \\<bind>\n                             (\\<lambda>_. return_spmf True)) =\n                         assert_spmf\n                          (aa < order \\<G> \\<and> ac < order \\<G>) \\<bind>\n                         (\\<lambda>_.\n                             assert_spmf\n                              (a =\n                               \\<^bold>g [^] ab \\<otimes>\n                               (\\<^bold>g [^] x) [^] aa \\<and>\n                               a =\n                               \\<^bold>g [^] b \\<otimes>\n                               (\\<^bold>g [^] x) [^] ac) \\<bind>\n                             (\\<lambda>_.\n                                 return_spmf\n                                  (x =\n                                   nat ((int b - int ab) *\n  Number_Theory_Aux.inverse (aa - ac) (order \\<G>) mod\n  int (order \\<G>)))))\n 2. \\<And>x a aa ab ac b.\n       \\<lbrakk>x < order \\<G>;\n        (a, aa, ab, ac, b) \\<in> set_spmf (\\<A> (\\<^bold>g [^] x));\n        \\<not> ac < aa\\<rbrakk>\n       \\<Longrightarrow> assert_spmf\n                          (aa \\<noteq> ac \\<and>\n                           aa < order \\<G> \\<and> ac < order \\<G>) \\<bind>\n                         (\\<lambda>_.\n                             assert_spmf\n                              (a =\n                               \\<^bold>g [^] ab \\<otimes>\n                               (\\<^bold>g [^] x) [^] aa \\<and>\n                               a =\n                               \\<^bold>g [^] b \\<otimes>\n                               (\\<^bold>g [^] x) [^] ac) \\<bind>\n                             (\\<lambda>_. return_spmf True)) =\n                         assert_spmf\n                          (aa \\<noteq> ac \\<and>\n                           aa < order \\<G> \\<and> ac < order \\<G>) \\<bind>\n                         (\\<lambda>_.\n                             assert_spmf\n                              (a =\n                               \\<^bold>g [^] ab \\<otimes>\n                               (\\<^bold>g [^] x) [^] aa \\<and>\n                               a =\n                               \\<^bold>g [^] b \\<otimes>\n                               (\\<^bold>g [^] x) [^] ac) \\<bind>\n                             (\\<lambda>_.\n                                 return_spmf\n                                  (x =\n                                   nat ((int ab - int b) *\n  Number_Theory_Aux.inverse (ac - aa) (order \\<G>) mod\n  int (order \\<G>)))))", "apply(intro bind_spmf_cong[OF refl]; clarsimp?)+"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x aa ab ac b.\n       \\<lbrakk>\\<^bold>g [^] b \\<otimes> (\\<^bold>g [^] x) [^] ac =\n                \\<^bold>g [^] ab \\<otimes> (\\<^bold>g [^] x) [^] aa;\n        x < order \\<G>;\n        (\\<^bold>g [^] ab \\<otimes> (\\<^bold>g [^] x) [^] aa, aa, ab, ac, b)\n        \\<in> set_spmf (\\<A> (\\<^bold>g [^] x));\n        ac < aa; aa < order \\<G>\\<rbrakk>\n       \\<Longrightarrow> x =\n                         nat ((int b - int ab) *\n                              Number_Theory_Aux.inverse (aa - ac)\n                               (order \\<G>) mod\n                              int (order \\<G>))\n 2. \\<And>x a aa ab ac b.\n       \\<lbrakk>x < order \\<G>;\n        (a, aa, ab, ac, b) \\<in> set_spmf (\\<A> (\\<^bold>g [^] x));\n        \\<not> ac < aa\\<rbrakk>\n       \\<Longrightarrow> assert_spmf\n                          (aa \\<noteq> ac \\<and>\n                           aa < order \\<G> \\<and> ac < order \\<G>) \\<bind>\n                         (\\<lambda>_.\n                             assert_spmf\n                              (a =\n                               \\<^bold>g [^] ab \\<otimes>\n                               (\\<^bold>g [^] x) [^] aa \\<and>\n                               a =\n                               \\<^bold>g [^] b \\<otimes>\n                               (\\<^bold>g [^] x) [^] ac) \\<bind>\n                             (\\<lambda>_. return_spmf True)) =\n                         assert_spmf\n                          (aa \\<noteq> ac \\<and>\n                           aa < order \\<G> \\<and> ac < order \\<G>) \\<bind>\n                         (\\<lambda>_.\n                             assert_spmf\n                              (a =\n                               \\<^bold>g [^] ab \\<otimes>\n                               (\\<^bold>g [^] x) [^] aa \\<and>\n                               a =\n                               \\<^bold>g [^] b \\<otimes>\n                               (\\<^bold>g [^] x) [^] ac) \\<bind>\n                             (\\<lambda>_.\n                                 return_spmf\n                                  (x =\n                                   nat ((int ab - int b) *\n  Number_Theory_Aux.inverse (ac - aa) (order \\<G>) mod\n  int (order \\<G>)))))", "apply(simp add: dis_log_break)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x a aa ab ac b.\n       \\<lbrakk>x < order \\<G>;\n        (a, aa, ab, ac, b) \\<in> set_spmf (\\<A> (\\<^bold>g [^] x));\n        \\<not> ac < aa\\<rbrakk>\n       \\<Longrightarrow> assert_spmf\n                          (aa \\<noteq> ac \\<and>\n                           aa < order \\<G> \\<and> ac < order \\<G>) \\<bind>\n                         (\\<lambda>_.\n                             assert_spmf\n                              (a =\n                               \\<^bold>g [^] ab \\<otimes>\n                               (\\<^bold>g [^] x) [^] aa \\<and>\n                               a =\n                               \\<^bold>g [^] b \\<otimes>\n                               (\\<^bold>g [^] x) [^] ac) \\<bind>\n                             (\\<lambda>_. return_spmf True)) =\n                         assert_spmf\n                          (aa \\<noteq> ac \\<and>\n                           aa < order \\<G> \\<and> ac < order \\<G>) \\<bind>\n                         (\\<lambda>_.\n                             assert_spmf\n                              (a =\n                               \\<^bold>g [^] ab \\<otimes>\n                               (\\<^bold>g [^] x) [^] aa \\<and>\n                               a =\n                               \\<^bold>g [^] b \\<otimes>\n                               (\\<^bold>g [^] x) [^] ac) \\<bind>\n                             (\\<lambda>_.\n                                 return_spmf\n                                  (x =\n                                   nat ((int ab - int b) *\n  Number_Theory_Aux.inverse (ac - aa) (order \\<G>) mod\n  int (order \\<G>)))))", "apply(intro bind_spmf_cong[OF refl]; clarsimp?)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x aa ab ac b.\n       \\<lbrakk>\\<^bold>g [^] b \\<otimes> (\\<^bold>g [^] x) [^] ac =\n                \\<^bold>g [^] ab \\<otimes> (\\<^bold>g [^] x) [^] aa;\n        x < order \\<G>;\n        (\\<^bold>g [^] ab \\<otimes> (\\<^bold>g [^] x) [^] aa, aa, ab, ac, b)\n        \\<in> set_spmf (\\<A> (\\<^bold>g [^] x));\n        \\<not> ac < aa; aa \\<noteq> ac; ac < order \\<G>\\<rbrakk>\n       \\<Longrightarrow> x =\n                         nat ((int ab - int b) *\n                              Number_Theory_Aux.inverse (ac - aa)\n                               (order \\<G>) mod\n                              int (order \\<G>))", "by(simp add: dis_log_break')"], ["proof (state)\nthis:\n  TRY sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>x.\n          \\<A> (\\<^bold>g [^] x) \\<bind>\n          (\\<lambda>(c, m, d, m', d').\n              assert_spmf\n               (m \\<noteq> m' \\<and>\n                valid_msg m \\<and> valid_msg m') \\<bind>\n              (\\<lambda>_.\n                  assert_spmf\n                   (c =\n                    \\<^bold>g [^] d \\<otimes> (\\<^bold>g [^] x) [^] m \\<and>\n                    c =\n                    \\<^bold>g [^] d' \\<otimes>\n                    (\\<^bold>g [^] x) [^] m') \\<bind>\n                  (\\<lambda>_. return_spmf True)))) ELSE return_spmf False =\n  TRY sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>x.\n          \\<A> (\\<^bold>g [^] x) \\<bind>\n          (\\<lambda>(c, m, d, m', d').\n              assert_spmf\n               (m \\<noteq> m' \\<and>\n                valid_msg m \\<and> valid_msg m') \\<bind>\n              (\\<lambda>_.\n                  assert_spmf\n                   (c =\n                    \\<^bold>g [^] d \\<otimes> (\\<^bold>g [^] x) [^] m \\<and>\n                    c =\n                    \\<^bold>g [^] d' \\<otimes>\n                    (\\<^bold>g [^] x) [^] m') \\<bind>\n                  (\\<lambda>_.\n                      return_spmf\n                       (x =\n                        (if m' < m\n                         then nat ((int d' - int d) *\n                                   Number_Theory_Aux.inverse (m - m')\n                                    (order \\<G>) mod\n                                   int (order \\<G>))\n                         else nat ((int d - int d') *\n                                   Number_Theory_Aux.inverse (m' - m)\n                                    (order \\<G>) mod\n                                   int (order\n   \\<G>)))))))) ELSE return_spmf False\n\ngoal (1 subgoal):\n 1. ped_commit.bind_game \\<A> = discrete_log.dis_log (dis_log_\\<A> \\<A>)", "ultimately"], ["proof (chain)\npicking this:\n  ped_commit.bind_game \\<A> =\n  TRY sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>x.\n          \\<A> (\\<^bold>g [^] x) \\<bind>\n          (\\<lambda>(c, m, d, m', d').\n              assert_spmf\n               (m \\<noteq> m' \\<and>\n                valid_msg m \\<and> valid_msg m') \\<bind>\n              (\\<lambda>_.\n                  assert_spmf\n                   (c =\n                    \\<^bold>g [^] d \\<otimes> (\\<^bold>g [^] x) [^] m \\<and>\n                    c =\n                    \\<^bold>g [^] d' \\<otimes>\n                    (\\<^bold>g [^] x) [^] m') \\<bind>\n                  (\\<lambda>_. return_spmf True)))) ELSE return_spmf False\n  TRY sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>x.\n          \\<A> (\\<^bold>g [^] x) \\<bind>\n          (\\<lambda>(c, m, d, m', d').\n              assert_spmf\n               (m \\<noteq> m' \\<and>\n                valid_msg m \\<and> valid_msg m') \\<bind>\n              (\\<lambda>_.\n                  assert_spmf\n                   (c =\n                    \\<^bold>g [^] d \\<otimes> (\\<^bold>g [^] x) [^] m \\<and>\n                    c =\n                    \\<^bold>g [^] d' \\<otimes>\n                    (\\<^bold>g [^] x) [^] m') \\<bind>\n                  (\\<lambda>_. return_spmf True)))) ELSE return_spmf False =\n  TRY sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>x.\n          \\<A> (\\<^bold>g [^] x) \\<bind>\n          (\\<lambda>(c, m, d, m', d').\n              assert_spmf\n               (m \\<noteq> m' \\<and>\n                valid_msg m \\<and> valid_msg m') \\<bind>\n              (\\<lambda>_.\n                  assert_spmf\n                   (c =\n                    \\<^bold>g [^] d \\<otimes> (\\<^bold>g [^] x) [^] m \\<and>\n                    c =\n                    \\<^bold>g [^] d' \\<otimes>\n                    (\\<^bold>g [^] x) [^] m') \\<bind>\n                  (\\<lambda>_.\n                      return_spmf\n                       (x =\n                        (if m' < m\n                         then nat ((int d' - int d) *\n                                   Number_Theory_Aux.inverse (m - m')\n                                    (order \\<G>) mod\n                                   int (order \\<G>))\n                         else nat ((int d - int d') *\n                                   Number_Theory_Aux.inverse (m' - m)\n                                    (order \\<G>) mod\n                                   int (order\n   \\<G>)))))))) ELSE return_spmf False", "show ?thesis"], ["proof (prove)\nusing this:\n  ped_commit.bind_game \\<A> =\n  TRY sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>x.\n          \\<A> (\\<^bold>g [^] x) \\<bind>\n          (\\<lambda>(c, m, d, m', d').\n              assert_spmf\n               (m \\<noteq> m' \\<and>\n                valid_msg m \\<and> valid_msg m') \\<bind>\n              (\\<lambda>_.\n                  assert_spmf\n                   (c =\n                    \\<^bold>g [^] d \\<otimes> (\\<^bold>g [^] x) [^] m \\<and>\n                    c =\n                    \\<^bold>g [^] d' \\<otimes>\n                    (\\<^bold>g [^] x) [^] m') \\<bind>\n                  (\\<lambda>_. return_spmf True)))) ELSE return_spmf False\n  TRY sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>x.\n          \\<A> (\\<^bold>g [^] x) \\<bind>\n          (\\<lambda>(c, m, d, m', d').\n              assert_spmf\n               (m \\<noteq> m' \\<and>\n                valid_msg m \\<and> valid_msg m') \\<bind>\n              (\\<lambda>_.\n                  assert_spmf\n                   (c =\n                    \\<^bold>g [^] d \\<otimes> (\\<^bold>g [^] x) [^] m \\<and>\n                    c =\n                    \\<^bold>g [^] d' \\<otimes>\n                    (\\<^bold>g [^] x) [^] m') \\<bind>\n                  (\\<lambda>_. return_spmf True)))) ELSE return_spmf False =\n  TRY sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>x.\n          \\<A> (\\<^bold>g [^] x) \\<bind>\n          (\\<lambda>(c, m, d, m', d').\n              assert_spmf\n               (m \\<noteq> m' \\<and>\n                valid_msg m \\<and> valid_msg m') \\<bind>\n              (\\<lambda>_.\n                  assert_spmf\n                   (c =\n                    \\<^bold>g [^] d \\<otimes> (\\<^bold>g [^] x) [^] m \\<and>\n                    c =\n                    \\<^bold>g [^] d' \\<otimes>\n                    (\\<^bold>g [^] x) [^] m') \\<bind>\n                  (\\<lambda>_.\n                      return_spmf\n                       (x =\n                        (if m' < m\n                         then nat ((int d' - int d) *\n                                   Number_Theory_Aux.inverse (m - m')\n                                    (order \\<G>) mod\n                                   int (order \\<G>))\n                         else nat ((int d - int d') *\n                                   Number_Theory_Aux.inverse (m' - m)\n                                    (order \\<G>) mod\n                                   int (order\n   \\<G>)))))))) ELSE return_spmf False\n\ngoal (1 subgoal):\n 1. ped_commit.bind_game \\<A> = discrete_log.dis_log (dis_log_\\<A> \\<A>)", "apply(simp add: discrete_log.dis_log_def dis_log_\\<A>_def cong: bind_spmf_cong_simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ped_commit.bind_game \\<A> =\n             TRY sample_uniform (order \\<G>) \\<bind>\n                 (\\<lambda>x.\n                     \\<A> (\\<^bold>g [^] x) \\<bind>\n                     (\\<lambda>xa.\n                         assert_spmf\n                          (fst (snd xa) \\<noteq>\n                           fst (snd (snd (snd xa))) \\<and>\n                           valid_msg (fst (snd xa)) \\<and>\n                           valid_msg (fst (snd (snd (snd xa))))) \\<bind>\n                         (\\<lambda>_.\n                             assert_spmf\n                              (fst xa =\n                               \\<^bold>g [^] fst (snd (snd xa)) \\<otimes>\n                               (\\<^bold>g [^] x) [^] fst (snd xa) \\<and>\n                               fst xa =\n                               \\<^bold>g [^]\n                               snd (snd (snd (snd xa))) \\<otimes>\n                               (\\<^bold>g [^] x) [^]\n                               fst (snd (snd (snd xa)))) \\<bind>\n                             (\\<lambda>_.\n                                 return_spmf\n                                  (x =\n                                   (if fst (snd (snd (snd xa)))\n < fst (snd xa)\n                                    then nat\n    ((int (snd (snd (snd (snd xa)))) - int (fst (snd (snd xa)))) *\n     Number_Theory_Aux.inverse (fst (snd xa) - fst (snd (snd (snd xa))))\n      (order \\<G>) mod\n     int (order \\<G>))\n                                    else nat\n    ((int (fst (snd (snd xa))) - int (snd (snd (snd (snd xa))))) *\n     Number_Theory_Aux.inverse (fst (snd (snd (snd xa))) - fst (snd xa))\n      (order \\<G>) mod\n     int (order \\<G>)))))))) ELSE return_spmf False;\n     TRY sample_uniform (order \\<G>) \\<bind>\n         (\\<lambda>x.\n             \\<A> (\\<^bold>g [^] x) \\<bind>\n             (\\<lambda>xa.\n                 assert_spmf\n                  (fst (snd xa) \\<noteq> fst (snd (snd (snd xa))) \\<and>\n                   valid_msg (fst (snd xa)) \\<and>\n                   valid_msg (fst (snd (snd (snd xa))))) \\<bind>\n                 (\\<lambda>_.\n                     assert_spmf\n                      (fst xa =\n                       \\<^bold>g [^] fst (snd (snd xa)) \\<otimes>\n                       (\\<^bold>g [^] x) [^] fst (snd xa) \\<and>\n                       fst xa =\n                       \\<^bold>g [^] snd (snd (snd (snd xa))) \\<otimes>\n                       (\\<^bold>g [^] x) [^]\n                       fst (snd (snd (snd xa)))) \\<bind>\n                     (\\<lambda>_.\n                         return_spmf True)))) ELSE return_spmf False =\n     TRY sample_uniform (order \\<G>) \\<bind>\n         (\\<lambda>x.\n             \\<A> (\\<^bold>g [^] x) \\<bind>\n             (\\<lambda>xa.\n                 assert_spmf\n                  (fst (snd xa) \\<noteq> fst (snd (snd (snd xa))) \\<and>\n                   valid_msg (fst (snd xa)) \\<and>\n                   valid_msg (fst (snd (snd (snd xa))))) \\<bind>\n                 (\\<lambda>_.\n                     assert_spmf\n                      (fst xa =\n                       \\<^bold>g [^] fst (snd (snd xa)) \\<otimes>\n                       (\\<^bold>g [^] x) [^] fst (snd xa) \\<and>\n                       fst xa =\n                       \\<^bold>g [^] snd (snd (snd (snd xa))) \\<otimes>\n                       (\\<^bold>g [^] x) [^]\n                       fst (snd (snd (snd xa)))) \\<bind>\n                     (\\<lambda>_.\n                         return_spmf\n                          (x =\n                           (if fst (snd (snd (snd xa))) < fst (snd xa)\n                            then nat ((int (snd (snd (snd (snd xa)))) -\n int (fst (snd (snd xa)))) *\nNumber_Theory_Aux.inverse (fst (snd xa) - fst (snd (snd (snd xa))))\n (order \\<G>) mod\nint (order \\<G>))\n                            else nat ((int (fst (snd (snd xa))) -\n int (snd (snd (snd (snd xa))))) *\nNumber_Theory_Aux.inverse (fst (snd (snd (snd xa))) - fst (snd xa))\n (order \\<G>) mod\nint (order \\<G>)))))))) ELSE return_spmf False\\<rbrakk>\n    \\<Longrightarrow> TRY sample_uniform (order \\<G>) \\<bind>\n                          (\\<lambda>x.\n                              \\<A> (\\<^bold>g [^] x) \\<bind>\n                              (\\<lambda>xa.\n                                  assert_spmf\n                                   (fst (snd xa) \\<noteq>\n                                    fst (snd (snd (snd xa))) \\<and>\n                                    valid_msg (fst (snd xa)) \\<and>\n                                    valid_msg\n                                     (fst (snd (snd (snd xa))))) \\<bind>\n                                  (\\<lambda>_.\nassert_spmf\n (fst xa =\n  \\<^bold>g [^] fst (snd (snd xa)) \\<otimes>\n  (\\<^bold>g [^] x) [^] fst (snd xa) \\<and>\n  fst xa =\n  \\<^bold>g [^] snd (snd (snd (snd xa))) \\<otimes>\n  (\\<^bold>g [^] x) [^] fst (snd (snd (snd xa)))) \\<bind>\n(\\<lambda>_.\n    return_spmf\n     (x =\n      (if fst (snd (snd (snd xa))) < fst (snd xa)\n       then nat ((int (snd (snd (snd (snd xa)))) -\n                  int (fst (snd (snd xa)))) *\n                 Number_Theory_Aux.inverse\n                  (fst (snd xa) - fst (snd (snd (snd xa)))) (order \\<G>) mod\n                 int (order \\<G>))\n       else nat ((int (fst (snd (snd xa))) -\n                  int (snd (snd (snd (snd xa))))) *\n                 Number_Theory_Aux.inverse\n                  (fst (snd (snd (snd xa))) - fst (snd xa)) (order \\<G>) mod\n                 int (order \\<G>)))))))) ELSE return_spmf False =\n                      TRY sample_uniform (order \\<G>) \\<bind>\n                          (\\<lambda>x.\n                              \\<A> (\\<^bold>g [^] x) \\<bind>\n                              (\\<lambda>xa.\n                                  assert_spmf\n                                   (fst (snd xa) \\<noteq>\n                                    fst (snd (snd (snd xa))) \\<and>\n                                    valid_msg (fst (snd xa)) \\<and>\n                                    valid_msg\n                                     (fst (snd (snd (snd xa))))) \\<bind>\n                                  (\\<lambda>a.\nassert_spmf\n (fst xa =\n  \\<^bold>g [^] fst (snd (snd xa)) \\<otimes>\n  (\\<^bold>g [^] x) [^] fst (snd xa) \\<and>\n  fst xa =\n  \\<^bold>g [^] snd (snd (snd (snd xa))) \\<otimes>\n  (\\<^bold>g [^] x) [^] fst (snd (snd (snd xa)))) \\<bind>\n(\\<lambda>a.\n    return_spmf\n     [x = if fst (snd (snd (snd xa))) < fst (snd xa)\n          then nat ((int (snd (snd (snd (snd xa)))) -\n                     int (fst (snd (snd xa)))) *\n                    Number_Theory_Aux.inverse\n                     (fst (snd xa) - fst (snd (snd (snd xa))))\n                     (order \\<G>) mod\n                    int (order \\<G>))\n          else nat ((int (fst (snd (snd xa))) -\n                     int (snd (snd (snd (snd xa))))) *\n                    Number_Theory_Aux.inverse\n                     (fst (snd (snd (snd xa))) - fst (snd xa))\n                     (order \\<G>) mod\n                    int (order\n                          \\<G>))] (mod order\n  \\<G>))))) ELSE return_spmf False", "apply(intro try_spmf_cong bind_spmf_cong[OF refl]; clarsimp?)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x aa ab ac b.\n       \\<lbrakk>ped_commit.bind_game \\<A> =\n                TRY sample_uniform (order \\<G>) \\<bind>\n                    (\\<lambda>x.\n                        \\<A> (\\<^bold>g [^] x) \\<bind>\n                        (\\<lambda>xa.\n                            assert_spmf\n                             (fst (snd xa) \\<noteq>\n                              fst (snd (snd (snd xa))) \\<and>\n                              valid_msg (fst (snd xa)) \\<and>\n                              valid_msg (fst (snd (snd (snd xa))))) \\<bind>\n                            (\\<lambda>_.\n                                assert_spmf\n                                 (fst xa =\n                                  \\<^bold>g [^] fst (snd (snd xa)) \\<otimes>\n                                  (\\<^bold>g [^] x) [^] fst (snd xa) \\<and>\n                                  fst xa =\n                                  \\<^bold>g [^]\n                                  snd (snd (snd (snd xa))) \\<otimes>\n                                  (\\<^bold>g [^] x) [^]\n                                  fst (snd (snd (snd xa)))) \\<bind>\n                                (\\<lambda>_.\n                                    return_spmf\n                                     (x =\n(if fst (snd (snd (snd xa))) < fst (snd xa)\n then nat ((int (snd (snd (snd (snd xa)))) - int (fst (snd (snd xa)))) *\n           Number_Theory_Aux.inverse\n            (fst (snd xa) - fst (snd (snd (snd xa)))) (order \\<G>) mod\n           int (order \\<G>))\n else nat ((int (fst (snd (snd xa))) - int (snd (snd (snd (snd xa))))) *\n           Number_Theory_Aux.inverse\n            (fst (snd (snd (snd xa))) - fst (snd xa)) (order \\<G>) mod\n           int (order \\<G>)))))))) ELSE return_spmf False;\n        TRY sample_uniform (order \\<G>) \\<bind>\n            (\\<lambda>x.\n                \\<A> (\\<^bold>g [^] x) \\<bind>\n                (\\<lambda>xa.\n                    assert_spmf\n                     (fst (snd xa) \\<noteq> fst (snd (snd (snd xa))) \\<and>\n                      valid_msg (fst (snd xa)) \\<and>\n                      valid_msg (fst (snd (snd (snd xa))))) \\<bind>\n                    (\\<lambda>_.\n                        assert_spmf\n                         (fst xa =\n                          \\<^bold>g [^] fst (snd (snd xa)) \\<otimes>\n                          (\\<^bold>g [^] x) [^] fst (snd xa) \\<and>\n                          fst xa =\n                          \\<^bold>g [^] snd (snd (snd (snd xa))) \\<otimes>\n                          (\\<^bold>g [^] x) [^]\n                          fst (snd (snd (snd xa)))) \\<bind>\n                        (\\<lambda>_.\n                            return_spmf True)))) ELSE return_spmf False =\n        TRY sample_uniform (order \\<G>) \\<bind>\n            (\\<lambda>x.\n                \\<A> (\\<^bold>g [^] x) \\<bind>\n                (\\<lambda>xa.\n                    assert_spmf\n                     (fst (snd xa) \\<noteq> fst (snd (snd (snd xa))) \\<and>\n                      valid_msg (fst (snd xa)) \\<and>\n                      valid_msg (fst (snd (snd (snd xa))))) \\<bind>\n                    (\\<lambda>_.\n                        assert_spmf\n                         (fst xa =\n                          \\<^bold>g [^] fst (snd (snd xa)) \\<otimes>\n                          (\\<^bold>g [^] x) [^] fst (snd xa) \\<and>\n                          fst xa =\n                          \\<^bold>g [^] snd (snd (snd (snd xa))) \\<otimes>\n                          (\\<^bold>g [^] x) [^]\n                          fst (snd (snd (snd xa)))) \\<bind>\n                        (\\<lambda>_.\n                            return_spmf\n                             (x =\n                              (if fst (snd (snd (snd xa))) < fst (snd xa)\n                               then nat ((int (snd (snd (snd (snd xa)))) -\n    int (fst (snd (snd xa)))) *\n   Number_Theory_Aux.inverse (fst (snd xa) - fst (snd (snd (snd xa))))\n    (order \\<G>) mod\n   int (order \\<G>))\n                               else nat ((int (fst (snd (snd xa))) -\n    int (snd (snd (snd (snd xa))))) *\n   Number_Theory_Aux.inverse (fst (snd (snd (snd xa))) - fst (snd xa))\n    (order \\<G>) mod\n   int (order \\<G>)))))))) ELSE return_spmf False;\n        x < order \\<G>;\n        (\\<^bold>g [^] b \\<otimes> (\\<^bold>g [^] x) [^] ac, aa, ab, ac, b)\n        \\<in> set_spmf (\\<A> (\\<^bold>g [^] x));\n        aa \\<noteq> ac;\n        \\<^bold>g [^] ab \\<otimes> (\\<^bold>g [^] x) [^] aa =\n        \\<^bold>g [^] b \\<otimes> (\\<^bold>g [^] x) [^] ac;\n        valid_msg aa; valid_msg ac\\<rbrakk>\n       \\<Longrightarrow> (ac < aa \\<longrightarrow>\n                          (x =\n                           nat ((int b - int ab) *\n                                Number_Theory_Aux.inverse (aa - ac)\n                                 (order \\<G>) mod\n                                int (order \\<G>))) =\n                          [x = nat ((int b - int ab) *\n                                    Number_Theory_Aux.inverse (aa - ac)\n                                     (order \\<G>) mod\n                                    int (order\n    \\<G>))] (mod order \\<G>)) \\<and>\n                         (\\<not> ac < aa \\<longrightarrow>\n                          (x =\n                           nat ((int ab - int b) *\n                                Number_Theory_Aux.inverse (ac - aa)\n                                 (order \\<G>) mod\n                                int (order \\<G>))) =\n                          [x = nat ((int ab - int b) *\n                                    Number_Theory_Aux.inverse (ac - aa)\n                                     (order \\<G>) mod\n                                    int (order \\<G>))] (mod order \\<G>))", "using bind_output_cong"], ["proof (prove)\nusing this:\n  ?x < order \\<G> \\<Longrightarrow>\n  (?x =\n   nat ((int ?b - int ?ab) *\n        Number_Theory_Aux.inverse (?aa - ?ac) (order \\<G>) mod\n        int (order \\<G>))) =\n  [?x = nat ((int ?b - int ?ab) *\n             Number_Theory_Aux.inverse (?aa - ?ac) (order \\<G>) mod\n             int (order \\<G>))] (mod order \\<G>)\n\ngoal (1 subgoal):\n 1. \\<And>x aa ab ac b.\n       \\<lbrakk>ped_commit.bind_game \\<A> =\n                TRY sample_uniform (order \\<G>) \\<bind>\n                    (\\<lambda>x.\n                        \\<A> (\\<^bold>g [^] x) \\<bind>\n                        (\\<lambda>xa.\n                            assert_spmf\n                             (fst (snd xa) \\<noteq>\n                              fst (snd (snd (snd xa))) \\<and>\n                              valid_msg (fst (snd xa)) \\<and>\n                              valid_msg (fst (snd (snd (snd xa))))) \\<bind>\n                            (\\<lambda>_.\n                                assert_spmf\n                                 (fst xa =\n                                  \\<^bold>g [^] fst (snd (snd xa)) \\<otimes>\n                                  (\\<^bold>g [^] x) [^] fst (snd xa) \\<and>\n                                  fst xa =\n                                  \\<^bold>g [^]\n                                  snd (snd (snd (snd xa))) \\<otimes>\n                                  (\\<^bold>g [^] x) [^]\n                                  fst (snd (snd (snd xa)))) \\<bind>\n                                (\\<lambda>_.\n                                    return_spmf\n                                     (x =\n(if fst (snd (snd (snd xa))) < fst (snd xa)\n then nat ((int (snd (snd (snd (snd xa)))) - int (fst (snd (snd xa)))) *\n           Number_Theory_Aux.inverse\n            (fst (snd xa) - fst (snd (snd (snd xa)))) (order \\<G>) mod\n           int (order \\<G>))\n else nat ((int (fst (snd (snd xa))) - int (snd (snd (snd (snd xa))))) *\n           Number_Theory_Aux.inverse\n            (fst (snd (snd (snd xa))) - fst (snd xa)) (order \\<G>) mod\n           int (order \\<G>)))))))) ELSE return_spmf False;\n        TRY sample_uniform (order \\<G>) \\<bind>\n            (\\<lambda>x.\n                \\<A> (\\<^bold>g [^] x) \\<bind>\n                (\\<lambda>xa.\n                    assert_spmf\n                     (fst (snd xa) \\<noteq> fst (snd (snd (snd xa))) \\<and>\n                      valid_msg (fst (snd xa)) \\<and>\n                      valid_msg (fst (snd (snd (snd xa))))) \\<bind>\n                    (\\<lambda>_.\n                        assert_spmf\n                         (fst xa =\n                          \\<^bold>g [^] fst (snd (snd xa)) \\<otimes>\n                          (\\<^bold>g [^] x) [^] fst (snd xa) \\<and>\n                          fst xa =\n                          \\<^bold>g [^] snd (snd (snd (snd xa))) \\<otimes>\n                          (\\<^bold>g [^] x) [^]\n                          fst (snd (snd (snd xa)))) \\<bind>\n                        (\\<lambda>_.\n                            return_spmf True)))) ELSE return_spmf False =\n        TRY sample_uniform (order \\<G>) \\<bind>\n            (\\<lambda>x.\n                \\<A> (\\<^bold>g [^] x) \\<bind>\n                (\\<lambda>xa.\n                    assert_spmf\n                     (fst (snd xa) \\<noteq> fst (snd (snd (snd xa))) \\<and>\n                      valid_msg (fst (snd xa)) \\<and>\n                      valid_msg (fst (snd (snd (snd xa))))) \\<bind>\n                    (\\<lambda>_.\n                        assert_spmf\n                         (fst xa =\n                          \\<^bold>g [^] fst (snd (snd xa)) \\<otimes>\n                          (\\<^bold>g [^] x) [^] fst (snd xa) \\<and>\n                          fst xa =\n                          \\<^bold>g [^] snd (snd (snd (snd xa))) \\<otimes>\n                          (\\<^bold>g [^] x) [^]\n                          fst (snd (snd (snd xa)))) \\<bind>\n                        (\\<lambda>_.\n                            return_spmf\n                             (x =\n                              (if fst (snd (snd (snd xa))) < fst (snd xa)\n                               then nat ((int (snd (snd (snd (snd xa)))) -\n    int (fst (snd (snd xa)))) *\n   Number_Theory_Aux.inverse (fst (snd xa) - fst (snd (snd (snd xa))))\n    (order \\<G>) mod\n   int (order \\<G>))\n                               else nat ((int (fst (snd (snd xa))) -\n    int (snd (snd (snd (snd xa))))) *\n   Number_Theory_Aux.inverse (fst (snd (snd (snd xa))) - fst (snd xa))\n    (order \\<G>) mod\n   int (order \\<G>)))))))) ELSE return_spmf False;\n        x < order \\<G>;\n        (\\<^bold>g [^] b \\<otimes> (\\<^bold>g [^] x) [^] ac, aa, ab, ac, b)\n        \\<in> set_spmf (\\<A> (\\<^bold>g [^] x));\n        aa \\<noteq> ac;\n        \\<^bold>g [^] ab \\<otimes> (\\<^bold>g [^] x) [^] aa =\n        \\<^bold>g [^] b \\<otimes> (\\<^bold>g [^] x) [^] ac;\n        valid_msg aa; valid_msg ac\\<rbrakk>\n       \\<Longrightarrow> (ac < aa \\<longrightarrow>\n                          (x =\n                           nat ((int b - int ab) *\n                                Number_Theory_Aux.inverse (aa - ac)\n                                 (order \\<G>) mod\n                                int (order \\<G>))) =\n                          [x = nat ((int b - int ab) *\n                                    Number_Theory_Aux.inverse (aa - ac)\n                                     (order \\<G>) mod\n                                    int (order\n    \\<G>))] (mod order \\<G>)) \\<and>\n                         (\\<not> ac < aa \\<longrightarrow>\n                          (x =\n                           nat ((int ab - int b) *\n                                Number_Theory_Aux.inverse (ac - aa)\n                                 (order \\<G>) mod\n                                int (order \\<G>))) =\n                          [x = nat ((int ab - int b) *\n                                    Number_Theory_Aux.inverse (ac - aa)\n                                     (order \\<G>) mod\n                                    int (order \\<G>))] (mod order \\<G>))", "by auto"], ["proof (state)\nthis:\n  ped_commit.bind_game \\<A> = discrete_log.dis_log (dis_log_\\<A> \\<A>)\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem pedersen_bind: \"ped_commit.bind_advantage \\<A> = discrete_log.advantage (dis_log_\\<A> \\<A>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ped_commit.bind_advantage \\<A> =\n    discrete_log.advantage (dis_log_\\<A> \\<A>)", "unfolding abstract_commitment.bind_advantage_def discrete_log.advantage_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. spmf (ped_commit.bind_game \\<A>) True =\n    spmf (discrete_log.dis_log (dis_log_\\<A> \\<A>)) True", "using bind_game_eq_dis_log"], ["proof (prove)\nusing this:\n  ped_commit.bind_game ?\\<A> = discrete_log.dis_log (dis_log_\\<A> ?\\<A>)\n\ngoal (1 subgoal):\n 1. spmf (ped_commit.bind_game \\<A>) True =\n    spmf (discrete_log.dis_log (dis_log_\\<A> \\<A>)) True", "by simp"], ["", "end"], ["", "locale pedersen_asymp = \n  fixes \\<G> :: \"nat \\<Rightarrow> 'grp cyclic_group\"\n  assumes pedersen: \"\\<And>\\<eta>. pedersen (\\<G> \\<eta>)\"\nbegin"], ["", "sublocale pedersen \"\\<G> \\<eta>\" for \\<eta>"], ["proof (prove)\ngoal (1 subgoal):\n 1. pedersen (\\<G> \\<eta>)", "by(simp add: pedersen)"], ["", "theorem pedersen_correct_asym: \n shows \"ped_commit.correct n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ped_commit.correct n", "using abstract_correct"], ["proof (prove)\nusing this:\n  ped_commit.correct ?\\<eta>\n\ngoal (1 subgoal):\n 1. ped_commit.correct n", "by simp"], ["", "theorem pedersen_perfect_hiding_asym:\n  shows \"ped_commit.perfect_hiding_ind_cpa n (\\<A> n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ped_commit.perfect_hiding_ind_cpa n (\\<A> n)", "by (simp add: abstract_perfect_hiding)"], ["", "theorem pedersen_bind_asym: \n  shows \"negligible (\\<lambda> n. ped_commit.bind_advantage n (\\<A> n)) \n            \\<longleftrightarrow> negligible (\\<lambda> n. discrete_log.advantage n (dis_log_\\<A> n (\\<A> n)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Negligible.negligible\n     (\\<lambda>n. ped_commit.bind_advantage n (\\<A> n)) =\n    Negligible.negligible\n     (\\<lambda>n. discrete_log.advantage n (dis_log_\\<A> n (\\<A> n)))", "by(simp add: pedersen_bind)"], ["", "end"], ["", "end"]]}