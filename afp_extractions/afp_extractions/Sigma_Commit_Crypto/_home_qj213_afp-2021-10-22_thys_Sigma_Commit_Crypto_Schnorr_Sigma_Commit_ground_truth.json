{"file_name": "/home/qj213/afp-2021-10-22/thys/Sigma_Commit_Crypto/Schnorr_Sigma_Commit.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Sigma_Commit_Crypto", "problem_names": ["lemma order_gt_0 [simp]: \"order \\<G> > 0\"", "lemma  lossless_init: \"lossless_spmf (init h w)\"", "lemma lossless_response: \"lossless_spmf (response r w c)\"", "lemma lossless_G: \"lossless_spmf G\"", "lemma completeness: \"Schnorr_\\<Sigma>.completeness\"", "lemma zr_rewrite: \n  assumes z: \"z = (x*c + r) mod (order \\<G>)\" \n    and r: \"r < order \\<G>\"\n  shows \"(z + (order \\<G>)*x*c - x*c) mod (order \\<G>) = r\"", "lemma h_sub_rewrite:\n  assumes \"h = \\<^bold>g [^] x\" \n    and z: \"z < order \\<G>\" \n  shows \"\\<^bold>g [^] ((z + (order \\<G>)*x*c - x*c)) = \\<^bold>g [^] z \\<otimes> inv (h [^] c)\" \n    (is \"?lhs = ?rhs\")", "lemma hvzk_R_rewrite_grp:\n  fixes x c r :: nat\n  assumes \"r < order \\<G>\"\n  shows \"\\<^bold>g [^] (((x * c + order \\<G> - r) mod order \\<G> + order \\<G> * x * c - x * c) mod order \\<G>) = inv \\<^bold>g [^] r\"\n    (is \"?lhs = ?rhs\")", "lemma hv_zk: \n  assumes \"(h,x) \\<in> R_DL\"\n  shows \"Schnorr_\\<Sigma>.R h x c = Schnorr_\\<Sigma>.S h c\"", "lemma honest_verifier_ZK: \n  shows \"Schnorr_\\<Sigma>.HVZK\"", "lemma ss_rewrite:\n  assumes \"e' < e\"\n    and \"e < order \\<G>\" \n    and a_mem:\"a  \\<in> carrier \\<G>\"\n    and h_mem: \"h \\<in> carrier \\<G>\" \n    and a: \"a \\<otimes> h [^] e = \\<^bold>g [^] z\" \n    and a': \"a \\<otimes> h [^] e' = \\<^bold>g [^] z'\"\n  shows  \"h = \\<^bold>g [^] ((int z - int z') * inverse ((e - e')) (order \\<G>) mod int (order \\<G>))\"", "lemma special_soundness:\n  shows \"Schnorr_\\<Sigma>.special_soundness\"", "theorem sigma_protocol:\n  shows \"Schnorr_\\<Sigma>.\\<Sigma>_protocol\"", "lemma \"Schnorr_\\<Sigma>_commit.abstract_com.correct\"", "lemma \"Schnorr_\\<Sigma>_commit.abstract_com.perfect_hiding_ind_cpa \\<A>\"", "lemma rel_adv_eq_dis_log_adv: \n  \"Schnorr_\\<Sigma>_commit.rel_advantage \\<A> = discrete_log.advantage \\<A>\"", "lemma bind_advantage_bound_dis_log: \n  \"Schnorr_\\<Sigma>_commit.abstract_com.bind_advantage \\<A> \\<le> discrete_log.advantage (Schnorr_\\<Sigma>_commit.adversary \\<A>)\"", "theorem sigma_protocol:\n  shows \"Schnorr_\\<Sigma>.\\<Sigma>_protocol n\"", "lemma asymp_correct: \"Schnorr_\\<Sigma>_commit.abstract_com.correct n\"", "lemma asymp_perfect_hiding: \"Schnorr_\\<Sigma>_commit.abstract_com.perfect_hiding_ind_cpa n (\\<A> n)\"", "lemma asymp_computational_binding: \n  assumes \"negligible (\\<lambda> n. discrete_log.advantage n (Schnorr_\\<Sigma>_commit.adversary n (\\<A> n)))\"\n  shows \"negligible (\\<lambda> n. Schnorr_\\<Sigma>_commit.abstract_com.bind_advantage n (\\<A> n))\""], "translations": [["", "lemma order_gt_0 [simp]: \"order \\<G> > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < order \\<G>", "using prime_order prime_gt_0_nat"], ["proof (prove)\nusing this:\n  prime (order \\<G>)\n  prime ?p \\<Longrightarrow> 0 < ?p\n\ngoal (1 subgoal):\n 1. 0 < order \\<G>", "by blast"], ["", "text\\<open>The types for the \\<open>\\<Sigma>\\<close>-protocol.\\<close>"], ["", "type_synonym witness = \"nat\""], ["", "type_synonym rand = nat"], ["", "type_synonym 'grp' msg = \"'grp'\""], ["", "type_synonym response = nat"], ["", "type_synonym challenge = nat"], ["", "type_synonym 'grp' pub_in = \"'grp'\""], ["", "definition R_DL :: \"('grp pub_in \\<times> witness) set\"\n  where \"R_DL = {(h, w). h = \\<^bold>g [^] w}\""], ["", "definition init :: \"'grp pub_in \\<Rightarrow> witness \\<Rightarrow> (rand \\<times> 'grp msg) spmf\"\n  where \"init h w = do {\n    r \\<leftarrow> sample_uniform (order \\<G>);\n    return_spmf (r, \\<^bold>g [^] r)}\""], ["", "lemma  lossless_init: \"lossless_spmf (init h w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lossless_spmf (init h w)", "by(simp add: init_def)"], ["", "definition \"response r w c = return_spmf ((w*c + r) mod (order \\<G>))\""], ["", "lemma lossless_response: \"lossless_spmf (response r w c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lossless_spmf (response r w c)", "by(simp add: response_def)"], ["", "definition G :: \"('grp pub_in \\<times> witness) spmf\" \n  where \"G = do {\n    w \\<leftarrow> sample_uniform (order \\<G>);\n    return_spmf (\\<^bold>g [^] w, w)}\""], ["", "lemma lossless_G: \"lossless_spmf G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lossless_spmf G", "by(simp add: G_def)"], ["", "definition \"challenge_space = {..< order \\<G>}\""], ["", "definition check :: \"'grp pub_in \\<Rightarrow> 'grp msg \\<Rightarrow> challenge \\<Rightarrow> response \\<Rightarrow> bool\"\n  where \"check h a e z = (a \\<otimes> (h [^] e) = \\<^bold>g [^] z \\<and> a \\<in> carrier \\<G>)\""], ["", "definition S2 :: \"'grp \\<Rightarrow> challenge \\<Rightarrow> ('grp msg, response) sim_out spmf\"\n  where \"S2 h e = do {\n  c \\<leftarrow> sample_uniform (order \\<G>);\n  let a = \\<^bold>g [^] c \\<otimes> (inv (h [^] e));\n  return_spmf (a, c)}\""], ["", "definition ss_adversary :: \"'grp \\<Rightarrow> ('grp msg, challenge, response) conv_tuple \\<Rightarrow> ('grp msg, challenge, response) conv_tuple \\<Rightarrow> nat spmf\"\n  where \"ss_adversary x c1 c2 = do {\n    let (a, e, z) = c1;\n    let (a', e', z') = c2;\n    return_spmf (if (e > e') then \n                    (nat ((int z - int z') * inverse ((e - e')) (order \\<G>) mod order \\<G>)) else \n                        (nat ((int z' - int z) * inverse ((e' - e)) (order \\<G>) mod order \\<G>)))}\""], ["", "definition \"valid_pub = carrier \\<G>\""], ["", "text\\<open>We now use the Schnorr \\<open>\\<Sigma>\\<close>-protocol use Schnorr to construct a commitment scheme.\\<close>"], ["", "type_synonym 'grp' ck = \"'grp'\""], ["", "type_synonym 'grp' vk = \"'grp' \\<times> nat\""], ["", "type_synonym plain = \"nat\""], ["", "type_synonym 'grp' commit = \"'grp'\""], ["", "type_synonym \"opening\" = \"nat\""], ["", "text\\<open>The adversary we use in the discrete log game to reduce the binding property to the discrete log assumption.\\<close>"], ["", "definition dis_log_\\<A> :: \"('grp ck, plain, 'grp commit, opening) bind_adversary \\<Rightarrow> 'grp ck \\<Rightarrow> nat spmf\"\n  where \"dis_log_\\<A> \\<A> h = do {\n  (c, e, z, e', z') \\<leftarrow> \\<A> h;\n  _ :: unit \\<leftarrow> assert_spmf (e > e' \\<and> \\<not> [e = e'] (mod order \\<G>) \\<and> (gcd (e - e') (order \\<G>) = 1) \\<and> c \\<in> carrier \\<G>);\n  _ :: unit \\<leftarrow> assert_spmf (((c \\<otimes> h [^] e) = \\<^bold>g [^] z) \\<and> (c \\<otimes> h [^] e') = \\<^bold>g [^] z'); \n  return_spmf  (nat ((int z - int z') * inverse ((e - e')) (order \\<G>) mod order \\<G>))}\""], ["", "sublocale discrete_log: dis_log \\<G>"], ["proof (prove)\ngoal (1 subgoal):\n 1. dis_log \\<G>", "unfolding dis_log_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < order \\<G>", "by simp"], ["", "end"], ["", "locale schnorr_sigma_protocol = schnorr_base + cyclic_group \\<G>\nbegin"], ["", "sublocale Schnorr_\\<Sigma>: \\<Sigma>_protocols_base init response check R_DL S2 ss_adversary challenge_space valid_pub"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sigma>_protocols_base R_DL valid_pub", "apply unfold_locales"], ["proof (prove)\ngoal (1 subgoal):\n 1. Domain R_DL \\<subseteq> valid_pub", "by(simp add: R_DL_def valid_pub_def; blast)"], ["", "text\\<open>The Schnorr \\<open>\\<Sigma>\\<close>-protocol is complete.\\<close>"], ["", "lemma completeness: \"Schnorr_\\<Sigma>.completeness\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Schnorr_\\<Sigma>.completeness", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. Schnorr_\\<Sigma>.completeness", "have \"\\<^bold>g [^] y \\<otimes> (\\<^bold>g [^] w') [^] e = \\<^bold>g [^] (y + w' * e)\" for y e w' :: nat"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<^bold>g [^] y \\<otimes> (\\<^bold>g [^] w') [^] e =\n    \\<^bold>g [^] (y + w' * e)", "using nat_pow_pow nat_pow_mult"], ["proof (prove)\nusing this:\n  ?x \\<in> carrier \\<G> \\<Longrightarrow>\n  (?x [^] ?n) [^] ?m = ?x [^] (?n * ?m)\n  ?x \\<in> carrier \\<G> \\<Longrightarrow>\n  ?x [^] ?n \\<otimes> ?x [^] ?m = ?x [^] (?n + ?m)\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^] y \\<otimes> (\\<^bold>g [^] w') [^] e =\n    \\<^bold>g [^] (y + w' * e)", "by simp"], ["proof (state)\nthis:\n  \\<^bold>g [^] ?y \\<otimes> (\\<^bold>g [^] ?w') [^] ?e =\n  \\<^bold>g [^] (?y + ?w' * ?e)\n\ngoal (1 subgoal):\n 1. Schnorr_\\<Sigma>.completeness", "then"], ["proof (chain)\npicking this:\n  \\<^bold>g [^] ?y \\<otimes> (\\<^bold>g [^] ?w') [^] ?e =\n  \\<^bold>g [^] (?y + ?w' * ?e)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<^bold>g [^] ?y \\<otimes> (\\<^bold>g [^] ?w') [^] ?e =\n  \\<^bold>g [^] (?y + ?w' * ?e)\n\ngoal (1 subgoal):\n 1. Schnorr_\\<Sigma>.completeness", "unfolding Schnorr_\\<Sigma>.completeness_game_def Schnorr_\\<Sigma>.completeness_def"], ["proof (prove)\nusing this:\n  \\<^bold>g [^] ?y \\<otimes> (\\<^bold>g [^] ?w') [^] ?e =\n  \\<^bold>g [^] (?y + ?w' * ?e)\n\ngoal (1 subgoal):\n 1. \\<forall>h w e.\n       (h, w) \\<in> R_DL \\<longrightarrow>\n       e \\<in> challenge_space \\<longrightarrow>\n       spmf\n        (init h w \\<bind>\n         (\\<lambda>(r, a).\n             response r w e \\<bind>\n             (\\<lambda>z. return_spmf (check h a e z))))\n        True =\n       1", "by(auto simp add: init_def response_def check_def pow_generator_mod R_DL_def add.commute bind_spmf_const)"], ["proof (state)\nthis:\n  Schnorr_\\<Sigma>.completeness\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>The next two lemmas help us rewrite terms in the proof  of honest verfier zero knowledge.\\<close>"], ["", "lemma zr_rewrite: \n  assumes z: \"z = (x*c + r) mod (order \\<G>)\" \n    and r: \"r < order \\<G>\"\n  shows \"(z + (order \\<G>)*x*c - x*c) mod (order \\<G>) = r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (z + order \\<G> * x * c - x * c) mod order \\<G> = r", "proof(cases \"x = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x = 0 \\<Longrightarrow>\n    (z + order \\<G> * x * c - x * c) mod order \\<G> = r\n 2. x \\<noteq> 0 \\<Longrightarrow>\n    (z + order \\<G> * x * c - x * c) mod order \\<G> = r", "case True"], ["proof (state)\nthis:\n  x = 0\n\ngoal (2 subgoals):\n 1. x = 0 \\<Longrightarrow>\n    (z + order \\<G> * x * c - x * c) mod order \\<G> = r\n 2. x \\<noteq> 0 \\<Longrightarrow>\n    (z + order \\<G> * x * c - x * c) mod order \\<G> = r", "then"], ["proof (chain)\npicking this:\n  x = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  x = 0\n\ngoal (1 subgoal):\n 1. (z + order \\<G> * x * c - x * c) mod order \\<G> = r", "using assms"], ["proof (prove)\nusing this:\n  x = 0\n  z = (x * c + r) mod order \\<G>\n  r < order \\<G>\n\ngoal (1 subgoal):\n 1. (z + order \\<G> * x * c - x * c) mod order \\<G> = r", "by simp"], ["proof (state)\nthis:\n  (z + order \\<G> * x * c - x * c) mod order \\<G> = r\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    (z + order \\<G> * x * c - x * c) mod order \\<G> = r", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    (z + order \\<G> * x * c - x * c) mod order \\<G> = r", "case x_neq_0: False"], ["proof (state)\nthis:\n  x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    (z + order \\<G> * x * c - x * c) mod order \\<G> = r", "then"], ["proof (chain)\npicking this:\n  x \\<noteq> 0", "show ?thesis"], ["proof (prove)\nusing this:\n  x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (z + order \\<G> * x * c - x * c) mod order \\<G> = r", "proof(cases \"c = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<noteq> 0; c = 0\\<rbrakk>\n    \\<Longrightarrow> (z + order \\<G> * x * c - x * c) mod order \\<G> = r\n 2. \\<lbrakk>x \\<noteq> 0; c \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> (z + order \\<G> * x * c - x * c) mod order \\<G> = r", "case True"], ["proof (state)\nthis:\n  c = 0\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<noteq> 0; c = 0\\<rbrakk>\n    \\<Longrightarrow> (z + order \\<G> * x * c - x * c) mod order \\<G> = r\n 2. \\<lbrakk>x \\<noteq> 0; c \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> (z + order \\<G> * x * c - x * c) mod order \\<G> = r", "then"], ["proof (chain)\npicking this:\n  c = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  c = 0\n\ngoal (1 subgoal):\n 1. (z + order \\<G> * x * c - x * c) mod order \\<G> = r", "by (simp add: assms)"], ["proof (state)\nthis:\n  (z + order \\<G> * x * c - x * c) mod order \\<G> = r\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> 0; c \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> (z + order \\<G> * x * c - x * c) mod order \\<G> = r", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> 0; c \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> (z + order \\<G> * x * c - x * c) mod order \\<G> = r", "case False"], ["proof (state)\nthis:\n  c \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> 0; c \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> (z + order \\<G> * x * c - x * c) mod order \\<G> = r", "have cong: \"[z + (order \\<G>)*x*c = x*c + r] (mod (order \\<G>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [z + order \\<G> * x * c = x * c + r] (mod order \\<G>)", "by (simp add: cong_def mult.assoc z)"], ["proof (state)\nthis:\n  [z + order \\<G> * x * c = x * c + r] (mod order \\<G>)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> 0; c \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> (z + order \\<G> * x * c - x * c) mod order \\<G> = r", "hence \"[z + (order \\<G>)*x*c - x*c = r] (mod (order \\<G>))\""], ["proof (prove)\nusing this:\n  [z + order \\<G> * x * c = x * c + r] (mod order \\<G>)\n\ngoal (1 subgoal):\n 1. [z + order \\<G> * x * c - x * c = r] (mod order \\<G>)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. [z + order \\<G> * x * c = x * c + r] (mod order \\<G>) \\<Longrightarrow>\n    [z + order \\<G> * x * c - x * c = r] (mod order \\<G>)", "have \"z + (order \\<G>)*x*c > x*c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * c < z + order \\<G> * x * c", "by (metis One_nat_def mult_less_cancel2 n_less_m_mult_n neq0_conv prime_gt_1_nat prime_order trans_less_add2 x_neq_0 False)"], ["proof (state)\nthis:\n  x * c < z + order \\<G> * x * c\n\ngoal (1 subgoal):\n 1. [z + order \\<G> * x * c = x * c + r] (mod order \\<G>) \\<Longrightarrow>\n    [z + order \\<G> * x * c - x * c = r] (mod order \\<G>)", "then"], ["proof (chain)\npicking this:\n  x * c < z + order \\<G> * x * c", "show ?thesis"], ["proof (prove)\nusing this:\n  x * c < z + order \\<G> * x * c\n\ngoal (1 subgoal):\n 1. [z + order \\<G> * x * c - x * c = r] (mod order \\<G>)", "by (metis cong add_diff_inverse_nat cong_add_lcancel_nat less_imp_le linorder_not_le)"], ["proof (state)\nthis:\n  [z + order \\<G> * x * c - x * c = r] (mod order \\<G>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  [z + order \\<G> * x * c - x * c = r] (mod order \\<G>)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> 0; c \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> (z + order \\<G> * x * c - x * c) mod order \\<G> = r", "then"], ["proof (chain)\npicking this:\n  [z + order \\<G> * x * c - x * c = r] (mod order \\<G>)", "show ?thesis"], ["proof (prove)\nusing this:\n  [z + order \\<G> * x * c - x * c = r] (mod order \\<G>)\n\ngoal (1 subgoal):\n 1. (z + order \\<G> * x * c - x * c) mod order \\<G> = r", "by(simp add: cong_def r)"], ["proof (state)\nthis:\n  (z + order \\<G> * x * c - x * c) mod order \\<G> = r\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (z + order \\<G> * x * c - x * c) mod order \\<G> = r\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma h_sub_rewrite:\n  assumes \"h = \\<^bold>g [^] x\" \n    and z: \"z < order \\<G>\" \n  shows \"\\<^bold>g [^] ((z + (order \\<G>)*x*c - x*c)) = \\<^bold>g [^] z \\<otimes> inv (h [^] c)\" \n    (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<^bold>g [^] (z + order \\<G> * x * c - x * c) =\n    \\<^bold>g [^] z \\<otimes> inv (h [^] c)", "proof(cases \"x = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x = 0 \\<Longrightarrow>\n    \\<^bold>g [^] (z + order \\<G> * x * c - x * c) =\n    \\<^bold>g [^] z \\<otimes> inv (h [^] c)\n 2. x \\<noteq> 0 \\<Longrightarrow>\n    \\<^bold>g [^] (z + order \\<G> * x * c - x * c) =\n    \\<^bold>g [^] z \\<otimes> inv (h [^] c)", "case True"], ["proof (state)\nthis:\n  x = 0\n\ngoal (2 subgoals):\n 1. x = 0 \\<Longrightarrow>\n    \\<^bold>g [^] (z + order \\<G> * x * c - x * c) =\n    \\<^bold>g [^] z \\<otimes> inv (h [^] c)\n 2. x \\<noteq> 0 \\<Longrightarrow>\n    \\<^bold>g [^] (z + order \\<G> * x * c - x * c) =\n    \\<^bold>g [^] z \\<otimes> inv (h [^] c)", "then"], ["proof (chain)\npicking this:\n  x = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  x = 0\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^] (z + order \\<G> * x * c - x * c) =\n    \\<^bold>g [^] z \\<otimes> inv (h [^] c)", "using assms"], ["proof (prove)\nusing this:\n  x = 0\n  h = \\<^bold>g [^] x\n  z < order \\<G>\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^] (z + order \\<G> * x * c - x * c) =\n    \\<^bold>g [^] z \\<otimes> inv (h [^] c)", "by simp"], ["proof (state)\nthis:\n  \\<^bold>g [^] (z + order \\<G> * x * c - x * c) =\n  \\<^bold>g [^] z \\<otimes> inv (h [^] c)\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    \\<^bold>g [^] (z + order \\<G> * x * c - x * c) =\n    \\<^bold>g [^] z \\<otimes> inv (h [^] c)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    \\<^bold>g [^] (z + order \\<G> * x * c - x * c) =\n    \\<^bold>g [^] z \\<otimes> inv (h [^] c)", "case x_neq_0: False"], ["proof (state)\nthis:\n  x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    \\<^bold>g [^] (z + order \\<G> * x * c - x * c) =\n    \\<^bold>g [^] z \\<otimes> inv (h [^] c)", "then"], ["proof (chain)\npicking this:\n  x \\<noteq> 0", "show ?thesis"], ["proof (prove)\nusing this:\n  x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^] (z + order \\<G> * x * c - x * c) =\n    \\<^bold>g [^] z \\<otimes> inv (h [^] c)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    \\<^bold>g [^] (z + order \\<G> * x * c - x * c) =\n    \\<^bold>g [^] z \\<otimes> inv (h [^] c)", "have \"(z + order \\<G> * x * c - x * c) = (z + (order \\<G> * x * c - x * c))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z + order \\<G> * x * c - x * c = z + (order \\<G> * x * c - x * c)", "using z"], ["proof (prove)\nusing this:\n  z < order \\<G>\n\ngoal (1 subgoal):\n 1. z + order \\<G> * x * c - x * c = z + (order \\<G> * x * c - x * c)", "by (simp add: less_imp_le_nat mult_le_mono)"], ["proof (state)\nthis:\n  z + order \\<G> * x * c - x * c = z + (order \\<G> * x * c - x * c)\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    \\<^bold>g [^] (z + order \\<G> * x * c - x * c) =\n    \\<^bold>g [^] z \\<otimes> inv (h [^] c)", "then"], ["proof (chain)\npicking this:\n  z + order \\<G> * x * c - x * c = z + (order \\<G> * x * c - x * c)", "have lhs: \"?lhs = \\<^bold>g [^] z \\<otimes> \\<^bold>g [^] ((order \\<G>)*x*c - x*c)\""], ["proof (prove)\nusing this:\n  z + order \\<G> * x * c - x * c = z + (order \\<G> * x * c - x * c)\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^] (z + order \\<G> * x * c - x * c) =\n    \\<^bold>g [^] z \\<otimes> \\<^bold>g [^] (order \\<G> * x * c - x * c)", "by(simp add: nat_pow_mult)"], ["proof (state)\nthis:\n  \\<^bold>g [^] (z + order \\<G> * x * c - x * c) =\n  \\<^bold>g [^] z \\<otimes> \\<^bold>g [^] (order \\<G> * x * c - x * c)\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    \\<^bold>g [^] (z + order \\<G> * x * c - x * c) =\n    \\<^bold>g [^] z \\<otimes> inv (h [^] c)", "have \" \\<^bold>g [^] ((order \\<G>)*x*c - x*c) =  inv (h [^] c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<^bold>g [^] (order \\<G> * x * c - x * c) = inv (h [^] c)", "proof(cases \"c = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. c = 0 \\<Longrightarrow>\n    \\<^bold>g [^] (order \\<G> * x * c - x * c) = inv (h [^] c)\n 2. c \\<noteq> 0 \\<Longrightarrow>\n    \\<^bold>g [^] (order \\<G> * x * c - x * c) = inv (h [^] c)", "case True"], ["proof (state)\nthis:\n  c = 0\n\ngoal (2 subgoals):\n 1. c = 0 \\<Longrightarrow>\n    \\<^bold>g [^] (order \\<G> * x * c - x * c) = inv (h [^] c)\n 2. c \\<noteq> 0 \\<Longrightarrow>\n    \\<^bold>g [^] (order \\<G> * x * c - x * c) = inv (h [^] c)", "then"], ["proof (chain)\npicking this:\n  c = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  c = 0\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^] (order \\<G> * x * c - x * c) = inv (h [^] c)", "by simp"], ["proof (state)\nthis:\n  \\<^bold>g [^] (order \\<G> * x * c - x * c) = inv (h [^] c)\n\ngoal (1 subgoal):\n 1. c \\<noteq> 0 \\<Longrightarrow>\n    \\<^bold>g [^] (order \\<G> * x * c - x * c) = inv (h [^] c)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. c \\<noteq> 0 \\<Longrightarrow>\n    \\<^bold>g [^] (order \\<G> * x * c - x * c) = inv (h [^] c)", "case False"], ["proof (state)\nthis:\n  c \\<noteq> 0\n\ngoal (1 subgoal):\n 1. c \\<noteq> 0 \\<Longrightarrow>\n    \\<^bold>g [^] (order \\<G> * x * c - x * c) = inv (h [^] c)", "hence bound: \"((order \\<G>)*x*c - x*c) > 0\""], ["proof (prove)\nusing this:\n  c \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 < order \\<G> * x * c - x * c", "using assms x_neq_0 prime_gt_1_nat prime_order"], ["proof (prove)\nusing this:\n  c \\<noteq> 0\n  h = \\<^bold>g [^] x\n  z < order \\<G>\n  x \\<noteq> 0\n  prime ?p \\<Longrightarrow> 1 < ?p\n  prime (order \\<G>)\n\ngoal (1 subgoal):\n 1. 0 < order \\<G> * x * c - x * c", "by auto"], ["proof (state)\nthis:\n  0 < order \\<G> * x * c - x * c\n\ngoal (1 subgoal):\n 1. c \\<noteq> 0 \\<Longrightarrow>\n    \\<^bold>g [^] (order \\<G> * x * c - x * c) = inv (h [^] c)", "then"], ["proof (chain)\npicking this:\n  0 < order \\<G> * x * c - x * c", "have \"\\<^bold>g [^] ((order \\<G>)*x*c- x*c) = \\<^bold>g [^] int ((order \\<G>)*x*c - x*c)\""], ["proof (prove)\nusing this:\n  0 < order \\<G> * x * c - x * c\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^] (order \\<G> * x * c - x * c) =\n    \\<^bold>g [^] int (order \\<G> * x * c - x * c)", "by (simp add: int_pow_int)"], ["proof (state)\nthis:\n  \\<^bold>g [^] (order \\<G> * x * c - x * c) =\n  \\<^bold>g [^] int (order \\<G> * x * c - x * c)\n\ngoal (1 subgoal):\n 1. c \\<noteq> 0 \\<Longrightarrow>\n    \\<^bold>g [^] (order \\<G> * x * c - x * c) = inv (h [^] c)", "also"], ["proof (state)\nthis:\n  \\<^bold>g [^] (order \\<G> * x * c - x * c) =\n  \\<^bold>g [^] int (order \\<G> * x * c - x * c)\n\ngoal (1 subgoal):\n 1. c \\<noteq> 0 \\<Longrightarrow>\n    \\<^bold>g [^] (order \\<G> * x * c - x * c) = inv (h [^] c)", "have \"... = \\<^bold>g [^] int ((order \\<G>)*x*c) \\<otimes> inv (\\<^bold>g [^] (x*c))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<^bold>g [^] int (order \\<G> * x * c - x * c) =\n    \\<^bold>g [^] int (order \\<G> * x * c) \\<otimes>\n    inv (\\<^bold>g [^] (x * c))", "by (metis bound generator_closed int_ops(6) int_pow_int of_nat_eq_0_iff of_nat_less_0_iff of_nat_less_iff int_pow_diff)"], ["proof (state)\nthis:\n  \\<^bold>g [^] int (order \\<G> * x * c - x * c) =\n  \\<^bold>g [^] int (order \\<G> * x * c) \\<otimes>\n  inv (\\<^bold>g [^] (x * c))\n\ngoal (1 subgoal):\n 1. c \\<noteq> 0 \\<Longrightarrow>\n    \\<^bold>g [^] (order \\<G> * x * c - x * c) = inv (h [^] c)", "also"], ["proof (state)\nthis:\n  \\<^bold>g [^] int (order \\<G> * x * c - x * c) =\n  \\<^bold>g [^] int (order \\<G> * x * c) \\<otimes>\n  inv (\\<^bold>g [^] (x * c))\n\ngoal (1 subgoal):\n 1. c \\<noteq> 0 \\<Longrightarrow>\n    \\<^bold>g [^] (order \\<G> * x * c - x * c) = inv (h [^] c)", "have \"... = \\<^bold>g [^] ((order \\<G>)*x*c) \\<otimes> inv (\\<^bold>g [^] (x*c))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<^bold>g [^] int (order \\<G> * x * c) \\<otimes>\n    inv (\\<^bold>g [^] (x * c)) =\n    \\<^bold>g [^] (order \\<G> * x * c) \\<otimes> inv (\\<^bold>g [^] (x * c))", "by (metis int_pow_int)"], ["proof (state)\nthis:\n  \\<^bold>g [^] int (order \\<G> * x * c) \\<otimes>\n  inv (\\<^bold>g [^] (x * c)) =\n  \\<^bold>g [^] (order \\<G> * x * c) \\<otimes> inv (\\<^bold>g [^] (x * c))\n\ngoal (1 subgoal):\n 1. c \\<noteq> 0 \\<Longrightarrow>\n    \\<^bold>g [^] (order \\<G> * x * c - x * c) = inv (h [^] c)", "also"], ["proof (state)\nthis:\n  \\<^bold>g [^] int (order \\<G> * x * c) \\<otimes>\n  inv (\\<^bold>g [^] (x * c)) =\n  \\<^bold>g [^] (order \\<G> * x * c) \\<otimes> inv (\\<^bold>g [^] (x * c))\n\ngoal (1 subgoal):\n 1. c \\<noteq> 0 \\<Longrightarrow>\n    \\<^bold>g [^] (order \\<G> * x * c - x * c) = inv (h [^] c)", "have \"... = \\<^bold>g [^] ((order \\<G>)*x*c) \\<otimes> inv ((\\<^bold>g [^] x) [^] c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<^bold>g [^] (order \\<G> * x * c) \\<otimes>\n    inv (\\<^bold>g [^] (x * c)) =\n    \\<^bold>g [^] (order \\<G> * x * c) \\<otimes>\n    inv ((\\<^bold>g [^] x) [^] c)", "by(simp add: nat_pow_pow)"], ["proof (state)\nthis:\n  \\<^bold>g [^] (order \\<G> * x * c) \\<otimes> inv (\\<^bold>g [^] (x * c)) =\n  \\<^bold>g [^] (order \\<G> * x * c) \\<otimes> inv ((\\<^bold>g [^] x) [^] c)\n\ngoal (1 subgoal):\n 1. c \\<noteq> 0 \\<Longrightarrow>\n    \\<^bold>g [^] (order \\<G> * x * c - x * c) = inv (h [^] c)", "also"], ["proof (state)\nthis:\n  \\<^bold>g [^] (order \\<G> * x * c) \\<otimes> inv (\\<^bold>g [^] (x * c)) =\n  \\<^bold>g [^] (order \\<G> * x * c) \\<otimes> inv ((\\<^bold>g [^] x) [^] c)\n\ngoal (1 subgoal):\n 1. c \\<noteq> 0 \\<Longrightarrow>\n    \\<^bold>g [^] (order \\<G> * x * c - x * c) = inv (h [^] c)", "have \"... = \\<^bold>g [^] ((order \\<G>)*x*c) \\<otimes> inv (h [^] c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<^bold>g [^] (order \\<G> * x * c) \\<otimes>\n    inv ((\\<^bold>g [^] x) [^] c) =\n    \\<^bold>g [^] (order \\<G> * x * c) \\<otimes> inv (h [^] c)", "using assms"], ["proof (prove)\nusing this:\n  h = \\<^bold>g [^] x\n  z < order \\<G>\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^] (order \\<G> * x * c) \\<otimes>\n    inv ((\\<^bold>g [^] x) [^] c) =\n    \\<^bold>g [^] (order \\<G> * x * c) \\<otimes> inv (h [^] c)", "by simp"], ["proof (state)\nthis:\n  \\<^bold>g [^] (order \\<G> * x * c) \\<otimes>\n  inv ((\\<^bold>g [^] x) [^] c) =\n  \\<^bold>g [^] (order \\<G> * x * c) \\<otimes> inv (h [^] c)\n\ngoal (1 subgoal):\n 1. c \\<noteq> 0 \\<Longrightarrow>\n    \\<^bold>g [^] (order \\<G> * x * c - x * c) = inv (h [^] c)", "also"], ["proof (state)\nthis:\n  \\<^bold>g [^] (order \\<G> * x * c) \\<otimes>\n  inv ((\\<^bold>g [^] x) [^] c) =\n  \\<^bold>g [^] (order \\<G> * x * c) \\<otimes> inv (h [^] c)\n\ngoal (1 subgoal):\n 1. c \\<noteq> 0 \\<Longrightarrow>\n    \\<^bold>g [^] (order \\<G> * x * c - x * c) = inv (h [^] c)", "have \"... = \\<one> \\<otimes> inv (h [^] c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<^bold>g [^] (order \\<G> * x * c) \\<otimes> inv (h [^] c) =\n    \\<one> \\<otimes> inv (h [^] c)", "using generator_pow_order"], ["proof (prove)\nusing this:\n  \\<^bold>g [^] order \\<G> = \\<one>\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^] (order \\<G> * x * c) \\<otimes> inv (h [^] c) =\n    \\<one> \\<otimes> inv (h [^] c)", "by (metis generator_closed mult_is_0 nat_pow_0 nat_pow_pow)"], ["proof (state)\nthis:\n  \\<^bold>g [^] (order \\<G> * x * c) \\<otimes> inv (h [^] c) =\n  \\<one> \\<otimes> inv (h [^] c)\n\ngoal (1 subgoal):\n 1. c \\<noteq> 0 \\<Longrightarrow>\n    \\<^bold>g [^] (order \\<G> * x * c - x * c) = inv (h [^] c)", "ultimately"], ["proof (chain)\npicking this:\n  \\<^bold>g [^] (order \\<G> * x * c - x * c) =\n  \\<^bold>g [^] (order \\<G> * x * c) \\<otimes> inv (h [^] c)\n  \\<^bold>g [^] (order \\<G> * x * c) \\<otimes> inv (h [^] c) =\n  \\<one> \\<otimes> inv (h [^] c)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<^bold>g [^] (order \\<G> * x * c - x * c) =\n  \\<^bold>g [^] (order \\<G> * x * c) \\<otimes> inv (h [^] c)\n  \\<^bold>g [^] (order \\<G> * x * c) \\<otimes> inv (h [^] c) =\n  \\<one> \\<otimes> inv (h [^] c)\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^] (order \\<G> * x * c - x * c) = inv (h [^] c)", "by (simp add: assms(1))"], ["proof (state)\nthis:\n  \\<^bold>g [^] (order \\<G> * x * c - x * c) = inv (h [^] c)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<^bold>g [^] (order \\<G> * x * c - x * c) = inv (h [^] c)\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    \\<^bold>g [^] (z + order \\<G> * x * c - x * c) =\n    \\<^bold>g [^] z \\<otimes> inv (h [^] c)", "then"], ["proof (chain)\npicking this:\n  \\<^bold>g [^] (order \\<G> * x * c - x * c) = inv (h [^] c)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<^bold>g [^] (order \\<G> * x * c - x * c) = inv (h [^] c)\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^] (z + order \\<G> * x * c - x * c) =\n    \\<^bold>g [^] z \\<otimes> inv (h [^] c)", "using lhs"], ["proof (prove)\nusing this:\n  \\<^bold>g [^] (order \\<G> * x * c - x * c) = inv (h [^] c)\n  \\<^bold>g [^] (z + order \\<G> * x * c - x * c) =\n  \\<^bold>g [^] z \\<otimes> \\<^bold>g [^] (order \\<G> * x * c - x * c)\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^] (z + order \\<G> * x * c - x * c) =\n    \\<^bold>g [^] z \\<otimes> inv (h [^] c)", "by simp"], ["proof (state)\nthis:\n  \\<^bold>g [^] (z + order \\<G> * x * c - x * c) =\n  \\<^bold>g [^] z \\<otimes> inv (h [^] c)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<^bold>g [^] (z + order \\<G> * x * c - x * c) =\n  \\<^bold>g [^] z \\<otimes> inv (h [^] c)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma hvzk_R_rewrite_grp:\n  fixes x c r :: nat\n  assumes \"r < order \\<G>\"\n  shows \"\\<^bold>g [^] (((x * c + order \\<G> - r) mod order \\<G> + order \\<G> * x * c - x * c) mod order \\<G>) = inv \\<^bold>g [^] r\"\n    (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<^bold>g [^]\n    (((x * c + order \\<G> - r) mod order \\<G> + order \\<G> * x * c -\n      x * c) mod\n     order \\<G>) =\n    inv \\<^bold>g [^] r", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<^bold>g [^]\n    (((x * c + order \\<G> - r) mod order \\<G> + order \\<G> * x * c -\n      x * c) mod\n     order \\<G>) =\n    inv \\<^bold>g [^] r", "have \"[(x * c + order \\<G> - r) mod order \\<G> + order \\<G> * x * c - x * c = order \\<G> - r] (mod order \\<G>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [(x * c + order \\<G> - r) mod order \\<G> + order \\<G> * x * c -\n     x * c = order \\<G> - r] (mod order \\<G>)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. [(x * c + order \\<G> - r) mod order \\<G> + order \\<G> * x * c -\n     x * c = order \\<G> - r] (mod order \\<G>)", "have \"[(x * c + order \\<G> - r) mod order \\<G> + order \\<G> * x * c - x * c  \n              = x * c + order \\<G> - r + order \\<G> * x * c - x * c] (mod order \\<G>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [(x * c + order \\<G> - r) mod order \\<G> + order \\<G> * x * c -\n     x *\n     c = x * c + order \\<G> - r + order \\<G> * x * c -\n         x * c] (mod order \\<G>)", "by (smt cong_def One_nat_def add_diff_inverse_nat cong_diff_nat less_imp_le_nat linorder_not_less mod_add_left_eq mult.assoc n_less_m_mult_n prime_gt_1_nat prime_order trans_less_add2 zero_less_diff)"], ["proof (state)\nthis:\n  [(x * c + order \\<G> - r) mod order \\<G> + order \\<G> * x * c -\n   x *\n   c = x * c + order \\<G> - r + order \\<G> * x * c - x * c] (mod order \\<G>)\n\ngoal (1 subgoal):\n 1. [(x * c + order \\<G> - r) mod order \\<G> + order \\<G> * x * c -\n     x * c = order \\<G> - r] (mod order \\<G>)", "hence \"[(x * c + order \\<G> - r) mod order \\<G> + order \\<G> * x * c - x * c  \n              =  order \\<G> - r + order \\<G> * x * c] (mod order \\<G>)\""], ["proof (prove)\nusing this:\n  [(x * c + order \\<G> - r) mod order \\<G> + order \\<G> * x * c -\n   x *\n   c = x * c + order \\<G> - r + order \\<G> * x * c - x * c] (mod order \\<G>)\n\ngoal (1 subgoal):\n 1. [(x * c + order \\<G> - r) mod order \\<G> + order \\<G> * x * c -\n     x * c = order \\<G> - r + order \\<G> * x * c] (mod order \\<G>)", "using assms"], ["proof (prove)\nusing this:\n  [(x * c + order \\<G> - r) mod order \\<G> + order \\<G> * x * c -\n   x *\n   c = x * c + order \\<G> - r + order \\<G> * x * c - x * c] (mod order \\<G>)\n  r < order \\<G>\n\ngoal (1 subgoal):\n 1. [(x * c + order \\<G> - r) mod order \\<G> + order \\<G> * x * c -\n     x * c = order \\<G> - r + order \\<G> * x * c] (mod order \\<G>)", "by auto"], ["proof (state)\nthis:\n  [(x * c + order \\<G> - r) mod order \\<G> + order \\<G> * x * c -\n   x * c = order \\<G> - r + order \\<G> * x * c] (mod order \\<G>)\n\ngoal (1 subgoal):\n 1. [(x * c + order \\<G> - r) mod order \\<G> + order \\<G> * x * c -\n     x * c = order \\<G> - r] (mod order \\<G>)", "thus ?thesis"], ["proof (prove)\nusing this:\n  [(x * c + order \\<G> - r) mod order \\<G> + order \\<G> * x * c -\n   x * c = order \\<G> - r + order \\<G> * x * c] (mod order \\<G>)\n\ngoal (1 subgoal):\n 1. [(x * c + order \\<G> - r) mod order \\<G> + order \\<G> * x * c -\n     x * c = order \\<G> - r] (mod order \\<G>)", "by (simp add: cong_def mult.assoc)"], ["proof (state)\nthis:\n  [(x * c + order \\<G> - r) mod order \\<G> + order \\<G> * x * c -\n   x * c = order \\<G> - r] (mod order \\<G>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  [(x * c + order \\<G> - r) mod order \\<G> + order \\<G> * x * c -\n   x * c = order \\<G> - r] (mod order \\<G>)\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^]\n    (((x * c + order \\<G> - r) mod order \\<G> + order \\<G> * x * c -\n      x * c) mod\n     order \\<G>) =\n    inv \\<^bold>g [^] r", "hence \"\\<^bold>g [^] ((x * c + order \\<G> - r) mod order \\<G> + order \\<G> * x * c - x * c) = \\<^bold>g [^] (order \\<G> - r)\""], ["proof (prove)\nusing this:\n  [(x * c + order \\<G> - r) mod order \\<G> + order \\<G> * x * c -\n   x * c = order \\<G> - r] (mod order \\<G>)\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^]\n    ((x * c + order \\<G> - r) mod order \\<G> + order \\<G> * x * c - x * c) =\n    \\<^bold>g [^] (order \\<G> - r)", "using finite_carrier pow_generator_eq_iff_cong"], ["proof (prove)\nusing this:\n  [(x * c + order \\<G> - r) mod order \\<G> + order \\<G> * x * c -\n   x * c = order \\<G> - r] (mod order \\<G>)\n  finite (carrier \\<G>)\n  finite (carrier \\<G>) \\<Longrightarrow>\n  (\\<^bold>g [^] ?x = \\<^bold>g [^] ?y) = [?x = ?y] (mod order \\<G>)\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^]\n    ((x * c + order \\<G> - r) mod order \\<G> + order \\<G> * x * c - x * c) =\n    \\<^bold>g [^] (order \\<G> - r)", "by blast"], ["proof (state)\nthis:\n  \\<^bold>g [^]\n  ((x * c + order \\<G> - r) mod order \\<G> + order \\<G> * x * c - x * c) =\n  \\<^bold>g [^] (order \\<G> - r)\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^]\n    (((x * c + order \\<G> - r) mod order \\<G> + order \\<G> * x * c -\n      x * c) mod\n     order \\<G>) =\n    inv \\<^bold>g [^] r", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<^bold>g [^]\n  ((x * c + order \\<G> - r) mod order \\<G> + order \\<G> * x * c - x * c) =\n  \\<^bold>g [^] (order \\<G> - r)\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^]\n    (((x * c + order \\<G> - r) mod order \\<G> + order \\<G> * x * c -\n      x * c) mod\n     order \\<G>) =\n    inv \\<^bold>g [^] r", "using neg_power_inverse"], ["proof (prove)\nusing this:\n  \\<^bold>g [^]\n  ((x * c + order \\<G> - r) mod order \\<G> + order \\<G> * x * c - x * c) =\n  \\<^bold>g [^] (order \\<G> - r)\n  \\<lbrakk>?g \\<in> carrier \\<G>; ?x < order \\<G>\\<rbrakk>\n  \\<Longrightarrow> ?g [^] (order \\<G> - ?x) = inv (?g [^] ?x)\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^]\n    (((x * c + order \\<G> - r) mod order \\<G> + order \\<G> * x * c -\n      x * c) mod\n     order \\<G>) =\n    inv \\<^bold>g [^] r", "by (simp add: assms inverse_pow_pow pow_generator_mod)"], ["proof (state)\nthis:\n  \\<^bold>g [^]\n  (((x * c + order \\<G> - r) mod order \\<G> + order \\<G> * x * c -\n    x * c) mod\n   order \\<G>) =\n  inv \\<^bold>g [^] r\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma hv_zk: \n  assumes \"(h,x) \\<in> R_DL\"\n  shows \"Schnorr_\\<Sigma>.R h x c = Schnorr_\\<Sigma>.S h c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Schnorr_\\<Sigma>.R h x c = Schnorr_\\<Sigma>.S h c", "including monad_normalisation"], ["proof (prove)\ngoal (1 subgoal):\n 1. Schnorr_\\<Sigma>.R h x c = Schnorr_\\<Sigma>.S h c", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. Schnorr_\\<Sigma>.R h x c = Schnorr_\\<Sigma>.S h c", "have \"Schnorr_\\<Sigma>.R h x c = do {\n      r \\<leftarrow> sample_uniform (order \\<G>);\n      let z = (x*c + r) mod (order \\<G>);\n      let a = \\<^bold>g [^] ((z + (order \\<G>)*x*c - x*c) mod (order \\<G>)); \n      return_spmf (a,c,z)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Schnorr_\\<Sigma>.R h x c =\n    sample_uniform (order \\<G>) \\<bind>\n    (\\<lambda>r.\n        let z = (x * c + r) mod order \\<G>;\n            a = \\<^bold>g [^]\n                ((z + order \\<G> * x * c - x * c) mod order \\<G>)\n        in return_spmf (a, c, z))", "apply(simp add: Let_def Schnorr_\\<Sigma>.R_def init_def response_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. sample_uniform (order \\<G>) \\<bind>\n    (\\<lambda>y.\n        return_spmf (\\<^bold>g [^] y, c, (x * c + y) mod order \\<G>)) =\n    sample_uniform (order \\<G>) \\<bind>\n    (\\<lambda>r.\n        return_spmf\n         (\\<^bold>g [^]\n          (((x * c + r) mod order \\<G> + order \\<G> * x * c - x * c) mod\n           order \\<G>),\n          c, (x * c + r) mod order \\<G>))", "using assms zr_rewrite R_DL_def"], ["proof (prove)\nusing this:\n  (h, x) \\<in> R_DL\n  \\<lbrakk>?z = (?x * ?c + ?r) mod order \\<G>; ?r < order \\<G>\\<rbrakk>\n  \\<Longrightarrow> (?z + order \\<G> * ?x * ?c - ?x * ?c) mod order \\<G> =\n                    ?r\n  R_DL = {(h, w). h = \\<^bold>g [^] w}\n\ngoal (1 subgoal):\n 1. sample_uniform (order \\<G>) \\<bind>\n    (\\<lambda>y.\n        return_spmf (\\<^bold>g [^] y, c, (x * c + y) mod order \\<G>)) =\n    sample_uniform (order \\<G>) \\<bind>\n    (\\<lambda>r.\n        return_spmf\n         (\\<^bold>g [^]\n          (((x * c + r) mod order \\<G> + order \\<G> * x * c - x * c) mod\n           order \\<G>),\n          c, (x * c + r) mod order \\<G>))", "by(simp cong: bind_spmf_cong_simp)"], ["proof (state)\nthis:\n  Schnorr_\\<Sigma>.R h x c =\n  sample_uniform (order \\<G>) \\<bind>\n  (\\<lambda>r.\n      let z = (x * c + r) mod order \\<G>;\n          a = \\<^bold>g [^]\n              ((z + order \\<G> * x * c - x * c) mod order \\<G>)\n      in return_spmf (a, c, z))\n\ngoal (1 subgoal):\n 1. Schnorr_\\<Sigma>.R h x c = Schnorr_\\<Sigma>.S h c", "also"], ["proof (state)\nthis:\n  Schnorr_\\<Sigma>.R h x c =\n  sample_uniform (order \\<G>) \\<bind>\n  (\\<lambda>r.\n      let z = (x * c + r) mod order \\<G>;\n          a = \\<^bold>g [^]\n              ((z + order \\<G> * x * c - x * c) mod order \\<G>)\n      in return_spmf (a, c, z))\n\ngoal (1 subgoal):\n 1. Schnorr_\\<Sigma>.R h x c = Schnorr_\\<Sigma>.S h c", "have \"... = do {\n      z \\<leftarrow> map_spmf (\\<lambda> r. (x*c + r) mod (order \\<G>)) (sample_uniform (order \\<G>));\n      let a = \\<^bold>g [^] ((z + (order \\<G>)*x*c - x*c) mod (order \\<G>)); \n      return_spmf (a,c,z)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sample_uniform (order \\<G>) \\<bind>\n    (\\<lambda>r.\n        let z = (x * c + r) mod order \\<G>;\n            a = \\<^bold>g [^]\n                ((z + order \\<G> * x * c - x * c) mod order \\<G>)\n        in return_spmf (a, c, z)) =\n    map_spmf (\\<lambda>r. (x * c + r) mod order \\<G>)\n     (sample_uniform (order \\<G>)) \\<bind>\n    (\\<lambda>z.\n        let a = \\<^bold>g [^]\n                ((z + order \\<G> * x * c - x * c) mod order \\<G>)\n        in return_spmf (a, c, z))", "by(simp add: bind_map_spmf o_def Let_def)"], ["proof (state)\nthis:\n  sample_uniform (order \\<G>) \\<bind>\n  (\\<lambda>r.\n      let z = (x * c + r) mod order \\<G>;\n          a = \\<^bold>g [^]\n              ((z + order \\<G> * x * c - x * c) mod order \\<G>)\n      in return_spmf (a, c, z)) =\n  map_spmf (\\<lambda>r. (x * c + r) mod order \\<G>)\n   (sample_uniform (order \\<G>)) \\<bind>\n  (\\<lambda>z.\n      let a = \\<^bold>g [^]\n              ((z + order \\<G> * x * c - x * c) mod order \\<G>)\n      in return_spmf (a, c, z))\n\ngoal (1 subgoal):\n 1. Schnorr_\\<Sigma>.R h x c = Schnorr_\\<Sigma>.S h c", "also"], ["proof (state)\nthis:\n  sample_uniform (order \\<G>) \\<bind>\n  (\\<lambda>r.\n      let z = (x * c + r) mod order \\<G>;\n          a = \\<^bold>g [^]\n              ((z + order \\<G> * x * c - x * c) mod order \\<G>)\n      in return_spmf (a, c, z)) =\n  map_spmf (\\<lambda>r. (x * c + r) mod order \\<G>)\n   (sample_uniform (order \\<G>)) \\<bind>\n  (\\<lambda>z.\n      let a = \\<^bold>g [^]\n              ((z + order \\<G> * x * c - x * c) mod order \\<G>)\n      in return_spmf (a, c, z))\n\ngoal (1 subgoal):\n 1. Schnorr_\\<Sigma>.R h x c = Schnorr_\\<Sigma>.S h c", "have \"... = do {\n      z \\<leftarrow>  (sample_uniform (order \\<G>));\n      let a = \\<^bold>g [^] ((z + (order \\<G>)*x*c - x*c)); \n      return_spmf (a,c,z)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_spmf (\\<lambda>r. (x * c + r) mod order \\<G>)\n     (sample_uniform (order \\<G>)) \\<bind>\n    (\\<lambda>z.\n        let a = \\<^bold>g [^]\n                ((z + order \\<G> * x * c - x * c) mod order \\<G>)\n        in return_spmf (a, c, z)) =\n    sample_uniform (order \\<G>) \\<bind>\n    (\\<lambda>z.\n        let a = \\<^bold>g [^] (z + order \\<G> * x * c - x * c)\n        in return_spmf (a, c, z))", "by(simp add: samp_uni_plus_one_time_pad pow_generator_mod)"], ["proof (state)\nthis:\n  map_spmf (\\<lambda>r. (x * c + r) mod order \\<G>)\n   (sample_uniform (order \\<G>)) \\<bind>\n  (\\<lambda>z.\n      let a = \\<^bold>g [^]\n              ((z + order \\<G> * x * c - x * c) mod order \\<G>)\n      in return_spmf (a, c, z)) =\n  sample_uniform (order \\<G>) \\<bind>\n  (\\<lambda>z.\n      let a = \\<^bold>g [^] (z + order \\<G> * x * c - x * c)\n      in return_spmf (a, c, z))\n\ngoal (1 subgoal):\n 1. Schnorr_\\<Sigma>.R h x c = Schnorr_\\<Sigma>.S h c", "also"], ["proof (state)\nthis:\n  map_spmf (\\<lambda>r. (x * c + r) mod order \\<G>)\n   (sample_uniform (order \\<G>)) \\<bind>\n  (\\<lambda>z.\n      let a = \\<^bold>g [^]\n              ((z + order \\<G> * x * c - x * c) mod order \\<G>)\n      in return_spmf (a, c, z)) =\n  sample_uniform (order \\<G>) \\<bind>\n  (\\<lambda>z.\n      let a = \\<^bold>g [^] (z + order \\<G> * x * c - x * c)\n      in return_spmf (a, c, z))\n\ngoal (1 subgoal):\n 1. Schnorr_\\<Sigma>.R h x c = Schnorr_\\<Sigma>.S h c", "have \"... = do {\n      z \\<leftarrow>  (sample_uniform (order \\<G>));\n      let a = \\<^bold>g [^] z \\<otimes> inv (h [^] c); \n      return_spmf (a,c,z)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sample_uniform (order \\<G>) \\<bind>\n    (\\<lambda>z.\n        let a = \\<^bold>g [^] (z + order \\<G> * x * c - x * c)\n        in return_spmf (a, c, z)) =\n    sample_uniform (order \\<G>) \\<bind>\n    (\\<lambda>z.\n        let a = \\<^bold>g [^] z \\<otimes> inv (h [^] c)\n        in return_spmf (a, c, z))", "using h_sub_rewrite assms R_DL_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>?h = \\<^bold>g [^] ?x; ?z < order \\<G>\\<rbrakk>\n  \\<Longrightarrow> \\<^bold>g [^] (?z + order \\<G> * ?x * ?c - ?x * ?c) =\n                    \\<^bold>g [^] ?z \\<otimes> inv (?h [^] ?c)\n  (h, x) \\<in> R_DL\n  R_DL = {(h, w). h = \\<^bold>g [^] w}\n\ngoal (1 subgoal):\n 1. sample_uniform (order \\<G>) \\<bind>\n    (\\<lambda>z.\n        let a = \\<^bold>g [^] (z + order \\<G> * x * c - x * c)\n        in return_spmf (a, c, z)) =\n    sample_uniform (order \\<G>) \\<bind>\n    (\\<lambda>z.\n        let a = \\<^bold>g [^] z \\<otimes> inv (h [^] c)\n        in return_spmf (a, c, z))", "by(simp cong: bind_spmf_cong_simp)"], ["proof (state)\nthis:\n  sample_uniform (order \\<G>) \\<bind>\n  (\\<lambda>z.\n      let a = \\<^bold>g [^] (z + order \\<G> * x * c - x * c)\n      in return_spmf (a, c, z)) =\n  sample_uniform (order \\<G>) \\<bind>\n  (\\<lambda>z.\n      let a = \\<^bold>g [^] z \\<otimes> inv (h [^] c)\n      in return_spmf (a, c, z))\n\ngoal (1 subgoal):\n 1. Schnorr_\\<Sigma>.R h x c = Schnorr_\\<Sigma>.S h c", "ultimately"], ["proof (chain)\npicking this:\n  Schnorr_\\<Sigma>.R h x c =\n  sample_uniform (order \\<G>) \\<bind>\n  (\\<lambda>z.\n      let a = \\<^bold>g [^] (z + order \\<G> * x * c - x * c)\n      in return_spmf (a, c, z))\n  sample_uniform (order \\<G>) \\<bind>\n  (\\<lambda>z.\n      let a = \\<^bold>g [^] (z + order \\<G> * x * c - x * c)\n      in return_spmf (a, c, z)) =\n  sample_uniform (order \\<G>) \\<bind>\n  (\\<lambda>z.\n      let a = \\<^bold>g [^] z \\<otimes> inv (h [^] c)\n      in return_spmf (a, c, z))", "show ?thesis"], ["proof (prove)\nusing this:\n  Schnorr_\\<Sigma>.R h x c =\n  sample_uniform (order \\<G>) \\<bind>\n  (\\<lambda>z.\n      let a = \\<^bold>g [^] (z + order \\<G> * x * c - x * c)\n      in return_spmf (a, c, z))\n  sample_uniform (order \\<G>) \\<bind>\n  (\\<lambda>z.\n      let a = \\<^bold>g [^] (z + order \\<G> * x * c - x * c)\n      in return_spmf (a, c, z)) =\n  sample_uniform (order \\<G>) \\<bind>\n  (\\<lambda>z.\n      let a = \\<^bold>g [^] z \\<otimes> inv (h [^] c)\n      in return_spmf (a, c, z))\n\ngoal (1 subgoal):\n 1. Schnorr_\\<Sigma>.R h x c = Schnorr_\\<Sigma>.S h c", "by(simp add: Schnorr_\\<Sigma>.S_def S2_def map_spmf_conv_bind_spmf)"], ["proof (state)\nthis:\n  Schnorr_\\<Sigma>.R h x c = Schnorr_\\<Sigma>.S h c\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>We can now prove that honest verifier zero knowledge holds for the Schnorr \\<open>\\<Sigma>\\<close>-protocol.\\<close>"], ["", "lemma honest_verifier_ZK: \n  shows \"Schnorr_\\<Sigma>.HVZK\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Schnorr_\\<Sigma>.HVZK", "unfolding Schnorr_\\<Sigma>.HVZK_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>e\\<in>challenge_space.\n       (\\<forall>(h, w)\\<in>R_DL.\n           Schnorr_\\<Sigma>.R h w e = Schnorr_\\<Sigma>.S h e) \\<and>\n       (\\<forall>h\\<in>valid_pub.\n           \\<forall>(a, z)\\<in>set_spmf (S2 h e). check h a e z)", "by(auto simp add: hv_zk R_DL_def S2_def check_def valid_pub_def challenge_space_def cyclic_group_assoc)"], ["", "text\\<open>It is left to prove the special soundness property. First we prove a lemma we use to rewrite a \nterm in the special soundness proof and then prove the property itself.\\<close>"], ["", "lemma ss_rewrite:\n  assumes \"e' < e\"\n    and \"e < order \\<G>\" \n    and a_mem:\"a  \\<in> carrier \\<G>\"\n    and h_mem: \"h \\<in> carrier \\<G>\" \n    and a: \"a \\<otimes> h [^] e = \\<^bold>g [^] z\" \n    and a': \"a \\<otimes> h [^] e' = \\<^bold>g [^] z'\"\n  shows  \"h = \\<^bold>g [^] ((int z - int z') * inverse ((e - e')) (order \\<G>) mod int (order \\<G>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h =\n    \\<^bold>g [^]\n    ((int z - int z') * Number_Theory_Aux.inverse (e - e') (order \\<G>) mod\n     int (order \\<G>))", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. h =\n    \\<^bold>g [^]\n    ((int z - int z') * Number_Theory_Aux.inverse (e - e') (order \\<G>) mod\n     int (order \\<G>))", "have gcd: \"gcd (nat (int e - int e') mod (order \\<G>)) (order \\<G>) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gcd (nat (int e - int e') mod order \\<G>) (order \\<G>) = 1", "using prime_field"], ["proof (prove)\nusing this:\n  \\<lbrakk>prime ?q; ?a < ?q; ?a \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> coprime ?a ?q\n\ngoal (1 subgoal):\n 1. gcd (nat (int e - int e') mod order \\<G>) (order \\<G>) = 1", "by (metis Primes.prime_nat_def assms(1) assms(2) coprime_imp_gcd_eq_1 diff_is_0_eq less_imp_diff_less \n            mod_less nat_minus_as_int not_less schnorr_base.prime_order schnorr_base_axioms)"], ["proof (state)\nthis:\n  gcd (nat (int e - int e') mod order \\<G>) (order \\<G>) = 1\n\ngoal (1 subgoal):\n 1. h =\n    \\<^bold>g [^]\n    ((int z - int z') * Number_Theory_Aux.inverse (e - e') (order \\<G>) mod\n     int (order \\<G>))", "have \"a = \\<^bold>g [^] z \\<otimes> inv (h [^] e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a = \\<^bold>g [^] z \\<otimes> inv (h [^] e)", "using a a_mem"], ["proof (prove)\nusing this:\n  a \\<otimes> h [^] e = \\<^bold>g [^] z\n  a \\<in> carrier \\<G>\n\ngoal (1 subgoal):\n 1. a = \\<^bold>g [^] z \\<otimes> inv (h [^] e)", "by (simp add: h_mem group.inv_solve_right)"], ["proof (state)\nthis:\n  a = \\<^bold>g [^] z \\<otimes> inv (h [^] e)\n\ngoal (1 subgoal):\n 1. h =\n    \\<^bold>g [^]\n    ((int z - int z') * Number_Theory_Aux.inverse (e - e') (order \\<G>) mod\n     int (order \\<G>))", "moreover"], ["proof (state)\nthis:\n  a = \\<^bold>g [^] z \\<otimes> inv (h [^] e)\n\ngoal (1 subgoal):\n 1. h =\n    \\<^bold>g [^]\n    ((int z - int z') * Number_Theory_Aux.inverse (e - e') (order \\<G>) mod\n     int (order \\<G>))", "have \"a = \\<^bold>g [^] z' \\<otimes> inv (h [^] e')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a = \\<^bold>g [^] z' \\<otimes> inv (h [^] e')", "using a' a_mem"], ["proof (prove)\nusing this:\n  a \\<otimes> h [^] e' = \\<^bold>g [^] z'\n  a \\<in> carrier \\<G>\n\ngoal (1 subgoal):\n 1. a = \\<^bold>g [^] z' \\<otimes> inv (h [^] e')", "by (simp add: h_mem group.inv_solve_right)"], ["proof (state)\nthis:\n  a = \\<^bold>g [^] z' \\<otimes> inv (h [^] e')\n\ngoal (1 subgoal):\n 1. h =\n    \\<^bold>g [^]\n    ((int z - int z') * Number_Theory_Aux.inverse (e - e') (order \\<G>) mod\n     int (order \\<G>))", "ultimately"], ["proof (chain)\npicking this:\n  a = \\<^bold>g [^] z \\<otimes> inv (h [^] e)\n  a = \\<^bold>g [^] z' \\<otimes> inv (h [^] e')", "have \"\\<^bold>g [^] z \\<otimes> h [^] e'  = \\<^bold>g [^] z' \\<otimes> h [^] e\""], ["proof (prove)\nusing this:\n  a = \\<^bold>g [^] z \\<otimes> inv (h [^] e)\n  a = \\<^bold>g [^] z' \\<otimes> inv (h [^] e')\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^] z \\<otimes> h [^] e' = \\<^bold>g [^] z' \\<otimes> h [^] e", "using h_mem"], ["proof (prove)\nusing this:\n  a = \\<^bold>g [^] z \\<otimes> inv (h [^] e)\n  a = \\<^bold>g [^] z' \\<otimes> inv (h [^] e')\n  h \\<in> carrier \\<G>\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^] z \\<otimes> h [^] e' = \\<^bold>g [^] z' \\<otimes> h [^] e", "by (metis (no_types, lifting) a a' h_mem a_mem cyclic_group_assoc cyclic_group_commute nat_pow_closed)"], ["proof (state)\nthis:\n  \\<^bold>g [^] z \\<otimes> h [^] e' = \\<^bold>g [^] z' \\<otimes> h [^] e\n\ngoal (1 subgoal):\n 1. h =\n    \\<^bold>g [^]\n    ((int z - int z') * Number_Theory_Aux.inverse (e - e') (order \\<G>) mod\n     int (order \\<G>))", "moreover"], ["proof (state)\nthis:\n  \\<^bold>g [^] z \\<otimes> h [^] e' = \\<^bold>g [^] z' \\<otimes> h [^] e\n\ngoal (1 subgoal):\n 1. h =\n    \\<^bold>g [^]\n    ((int z - int z') * Number_Theory_Aux.inverse (e - e') (order \\<G>) mod\n     int (order \\<G>))", "obtain t :: nat where  t: \"h = \\<^bold>g  [^] t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>t.\n        h = \\<^bold>g [^] t \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using h_mem generatorE"], ["proof (prove)\nusing this:\n  h \\<in> carrier \\<G>\n  \\<lbrakk>?x \\<in> carrier \\<G>;\n   \\<And>n. ?x = \\<^bold>g [^] n \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        h = \\<^bold>g [^] t \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  h = \\<^bold>g [^] t\n\ngoal (1 subgoal):\n 1. h =\n    \\<^bold>g [^]\n    ((int z - int z') * Number_Theory_Aux.inverse (e - e') (order \\<G>) mod\n     int (order \\<G>))", "ultimately"], ["proof (chain)\npicking this:\n  \\<^bold>g [^] z \\<otimes> h [^] e' = \\<^bold>g [^] z' \\<otimes> h [^] e\n  h = \\<^bold>g [^] t", "have \"\\<^bold>g [^] (z + t * e')  = \\<^bold>g [^] (z' +  t * e) \""], ["proof (prove)\nusing this:\n  \\<^bold>g [^] z \\<otimes> h [^] e' = \\<^bold>g [^] z' \\<otimes> h [^] e\n  h = \\<^bold>g [^] t\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^] (z + t * e') = \\<^bold>g [^] (z' + t * e)", "by (simp add: monoid.nat_pow_mult nat_pow_pow)"], ["proof (state)\nthis:\n  \\<^bold>g [^] (z + t * e') = \\<^bold>g [^] (z' + t * e)\n\ngoal (1 subgoal):\n 1. h =\n    \\<^bold>g [^]\n    ((int z - int z') * Number_Theory_Aux.inverse (e - e') (order \\<G>) mod\n     int (order \\<G>))", "hence \"[z + t * e' = z' +  t * e] (mod  order \\<G>)\""], ["proof (prove)\nusing this:\n  \\<^bold>g [^] (z + t * e') = \\<^bold>g [^] (z' + t * e)\n\ngoal (1 subgoal):\n 1. [z + t * e' = z' + t * e] (mod order \\<G>)", "using group_eq_pow_eq_mod order_gt_0"], ["proof (prove)\nusing this:\n  \\<^bold>g [^] (z + t * e') = \\<^bold>g [^] (z' + t * e)\n  \\<lbrakk>\\<^bold>g [^] ?a = \\<^bold>g [^] ?b; 0 < order \\<G>\\<rbrakk>\n  \\<Longrightarrow> [?a = ?b] (mod order \\<G>)\n  0 < order \\<G>\n\ngoal (1 subgoal):\n 1. [z + t * e' = z' + t * e] (mod order \\<G>)", "by blast"], ["proof (state)\nthis:\n  [z + t * e' = z' + t * e] (mod order \\<G>)\n\ngoal (1 subgoal):\n 1. h =\n    \\<^bold>g [^]\n    ((int z - int z') * Number_Theory_Aux.inverse (e - e') (order \\<G>) mod\n     int (order \\<G>))", "hence \"[int z + int t * int e' = int z' +  int t * int e] (mod  order \\<G>)\""], ["proof (prove)\nusing this:\n  [z + t * e' = z' + t * e] (mod order \\<G>)\n\ngoal (1 subgoal):\n 1. [int z + int t * int e' = int z' + int t * int e] (mod int (order \\<G>))", "using cong_int_iff"], ["proof (prove)\nusing this:\n  [z + t * e' = z' + t * e] (mod order \\<G>)\n  [int ?m = int ?q] (mod int ?n) = [?m = ?q] (mod ?n)\n\ngoal (1 subgoal):\n 1. [int z + int t * int e' = int z' + int t * int e] (mod int (order \\<G>))", "by force"], ["proof (state)\nthis:\n  [int z + int t * int e' = int z' + int t * int e] (mod int (order \\<G>))\n\ngoal (1 subgoal):\n 1. h =\n    \\<^bold>g [^]\n    ((int z - int z') * Number_Theory_Aux.inverse (e - e') (order \\<G>) mod\n     int (order \\<G>))", "hence \"[int z - int z' = int t * int e - int t * int e'] (mod  order \\<G>)\""], ["proof (prove)\nusing this:\n  [int z + int t * int e' = int z' + int t * int e] (mod int (order \\<G>))\n\ngoal (1 subgoal):\n 1. [int z - int z' = int t * int e - int t * int e'] (mod int (order \\<G>))", "by (smt cong_iff_lin)"], ["proof (state)\nthis:\n  [int z - int z' = int t * int e - int t * int e'] (mod int (order \\<G>))\n\ngoal (1 subgoal):\n 1. h =\n    \\<^bold>g [^]\n    ((int z - int z') * Number_Theory_Aux.inverse (e - e') (order \\<G>) mod\n     int (order \\<G>))", "hence \"[int z - int z' = int t * (int e - int e')] (mod  order \\<G>)\""], ["proof (prove)\nusing this:\n  [int z - int z' = int t * int e - int t * int e'] (mod int (order \\<G>))\n\ngoal (1 subgoal):\n 1. [int z - int z' = int t * (int e - int e')] (mod int (order \\<G>))", "by (simp add: \\<open>[int z - int z' = int t * int e - int t * int e'] (mod int (order \\<G>))\\<close> right_diff_distrib)"], ["proof (state)\nthis:\n  [int z - int z' = int t * (int e - int e')] (mod int (order \\<G>))\n\ngoal (1 subgoal):\n 1. h =\n    \\<^bold>g [^]\n    ((int z - int z') * Number_Theory_Aux.inverse (e - e') (order \\<G>) mod\n     int (order \\<G>))", "hence \"[int z - int z' = int t * (int e - int e')] (mod  order \\<G>)\""], ["proof (prove)\nusing this:\n  [int z - int z' = int t * (int e - int e')] (mod int (order \\<G>))\n\ngoal (1 subgoal):\n 1. [int z - int z' = int t * (int e - int e')] (mod int (order \\<G>))", "by (meson cong_diff cong_mod_left cong_mult cong_refl cong_trans)"], ["proof (state)\nthis:\n  [int z - int z' = int t * (int e - int e')] (mod int (order \\<G>))\n\ngoal (1 subgoal):\n 1. h =\n    \\<^bold>g [^]\n    ((int z - int z') * Number_Theory_Aux.inverse (e - e') (order \\<G>) mod\n     int (order \\<G>))", "hence *: \"[int z - int z' = int t * (int e - int e')] (mod  order \\<G>)\""], ["proof (prove)\nusing this:\n  [int z - int z' = int t * (int e - int e')] (mod int (order \\<G>))\n\ngoal (1 subgoal):\n 1. [int z - int z' = int t * (int e - int e')] (mod int (order \\<G>))", "using assms"], ["proof (prove)\nusing this:\n  [int z - int z' = int t * (int e - int e')] (mod int (order \\<G>))\n  e' < e\n  e < order \\<G>\n  a \\<in> carrier \\<G>\n  h \\<in> carrier \\<G>\n  a \\<otimes> h [^] e = \\<^bold>g [^] z\n  a \\<otimes> h [^] e' = \\<^bold>g [^] z'\n\ngoal (1 subgoal):\n 1. [int z - int z' = int t * (int e - int e')] (mod int (order \\<G>))", "by (simp add: int_ops(9) of_nat_diff)"], ["proof (state)\nthis:\n  [int z - int z' = int t * (int e - int e')] (mod int (order \\<G>))\n\ngoal (1 subgoal):\n 1. h =\n    \\<^bold>g [^]\n    ((int z - int z') * Number_Theory_Aux.inverse (e - e') (order \\<G>) mod\n     int (order \\<G>))", "hence \"[int z - int z' = int t * nat (int e - int e')] (mod  order \\<G>)\""], ["proof (prove)\nusing this:\n  [int z - int z' = int t * (int e - int e')] (mod int (order \\<G>))\n\ngoal (1 subgoal):\n 1. [int z -\n     int z' = int t * int (nat (int e - int e'))] (mod int (order \\<G>))", "using assms"], ["proof (prove)\nusing this:\n  [int z - int z' = int t * (int e - int e')] (mod int (order \\<G>))\n  e' < e\n  e < order \\<G>\n  a \\<in> carrier \\<G>\n  h \\<in> carrier \\<G>\n  a \\<otimes> h [^] e = \\<^bold>g [^] z\n  a \\<otimes> h [^] e' = \\<^bold>g [^] z'\n\ngoal (1 subgoal):\n 1. [int z -\n     int z' = int t * int (nat (int e - int e'))] (mod int (order \\<G>))", "by auto"], ["proof (state)\nthis:\n  [int z -\n   int z' = int t * int (nat (int e - int e'))] (mod int (order \\<G>))\n\ngoal (1 subgoal):\n 1. h =\n    \\<^bold>g [^]\n    ((int z - int z') * Number_Theory_Aux.inverse (e - e') (order \\<G>) mod\n     int (order \\<G>))", "hence **: \"[(int z - int z') * fst (bezw ((nat (int e - int e'))) (order \\<G>)) \n              = int t * (nat (int e - int e')\n                  * fst (bezw ((nat (int e - int e'))) (order \\<G>)))] (mod  order \\<G>)\""], ["proof (prove)\nusing this:\n  [int z -\n   int z' = int t * int (nat (int e - int e'))] (mod int (order \\<G>))\n\ngoal (1 subgoal):\n 1. [(int z - int z') *\n     Number_Theory_Aux.inverse (nat (int e - int e'))\n      (order\n        \\<G>) = int t *\n                (int (nat (int e - int e')) *\n                 Number_Theory_Aux.inverse (nat (int e - int e'))\n                  (order \\<G>))] (mod int (order \\<G>))", "by (smt \\<open>[int z - int z' = int t * (int e - int e')] (mod int (order \\<G>))\\<close> assms(1) assms(2)\n          cong_scalar_right int_nat_eq less_imp_of_nat_less mod_less more_arith_simps(11) nat_less_iff of_nat_0_le_iff)"], ["proof (state)\nthis:\n  [(int z - int z') *\n   Number_Theory_Aux.inverse (nat (int e - int e'))\n    (order\n      \\<G>) = int t *\n              (int (nat (int e - int e')) *\n               Number_Theory_Aux.inverse (nat (int e - int e'))\n                (order \\<G>))] (mod int (order \\<G>))\n\ngoal (1 subgoal):\n 1. h =\n    \\<^bold>g [^]\n    ((int z - int z') * Number_Theory_Aux.inverse (e - e') (order \\<G>) mod\n     int (order \\<G>))", "hence \"[(int z - int z') * fst (bezw ((nat (int e - int e'))) (order \\<G>)) = int t * 1] (mod  order \\<G>)\""], ["proof (prove)\nusing this:\n  [(int z - int z') *\n   Number_Theory_Aux.inverse (nat (int e - int e'))\n    (order\n      \\<G>) = int t *\n              (int (nat (int e - int e')) *\n               Number_Theory_Aux.inverse (nat (int e - int e'))\n                (order \\<G>))] (mod int (order \\<G>))\n\ngoal (1 subgoal):\n 1. [(int z - int z') *\n     Number_Theory_Aux.inverse (nat (int e - int e'))\n      (order \\<G>) = int t * 1] (mod int (order \\<G>))", "by (metis (no_types, hide_lams) gcd inverse assms(2) cong_scalar_left cong_trans less_imp_diff_less mod_less mult.comm_neutral nat_minus_as_int)"], ["proof (state)\nthis:\n  [(int z - int z') *\n   Number_Theory_Aux.inverse (nat (int e - int e'))\n    (order \\<G>) = int t * 1] (mod int (order \\<G>))\n\ngoal (1 subgoal):\n 1. h =\n    \\<^bold>g [^]\n    ((int z - int z') * Number_Theory_Aux.inverse (e - e') (order \\<G>) mod\n     int (order \\<G>))", "hence \"[(int z - int z') * fst (bezw ((nat (int e - int e'))) (order \\<G>)) \n              = t] (mod  order \\<G>)\""], ["proof (prove)\nusing this:\n  [(int z - int z') *\n   Number_Theory_Aux.inverse (nat (int e - int e'))\n    (order \\<G>) = int t * 1] (mod int (order \\<G>))\n\ngoal (1 subgoal):\n 1. [(int z - int z') *\n     Number_Theory_Aux.inverse (nat (int e - int e'))\n      (order \\<G>) = int t] (mod int (order \\<G>))", "by simp"], ["proof (state)\nthis:\n  [(int z - int z') *\n   Number_Theory_Aux.inverse (nat (int e - int e'))\n    (order \\<G>) = int t] (mod int (order \\<G>))\n\ngoal (1 subgoal):\n 1. h =\n    \\<^bold>g [^]\n    ((int z - int z') * Number_Theory_Aux.inverse (e - e') (order \\<G>) mod\n     int (order \\<G>))", "hence \"[ ((int z - int z') * fst (bezw ((nat (int e - int e'))) (order \\<G>)))mod order \\<G> \n              = t] (mod  order \\<G>)\""], ["proof (prove)\nusing this:\n  [(int z - int z') *\n   Number_Theory_Aux.inverse (nat (int e - int e'))\n    (order \\<G>) = int t] (mod int (order \\<G>))\n\ngoal (1 subgoal):\n 1. [(int z - int z') *\n     Number_Theory_Aux.inverse (nat (int e - int e')) (order \\<G>) mod\n     int (order \\<G>) = int t] (mod int (order \\<G>))", "using cong_mod_left"], ["proof (prove)\nusing this:\n  [(int z - int z') *\n   Number_Theory_Aux.inverse (nat (int e - int e'))\n    (order \\<G>) = int t] (mod int (order \\<G>))\n  [?b mod ?a = ?c] (mod ?a) = [?b = ?c] (mod ?a)\n\ngoal (1 subgoal):\n 1. [(int z - int z') *\n     Number_Theory_Aux.inverse (nat (int e - int e')) (order \\<G>) mod\n     int (order \\<G>) = int t] (mod int (order \\<G>))", "by blast"], ["proof (state)\nthis:\n  [(int z - int z') *\n   Number_Theory_Aux.inverse (nat (int e - int e')) (order \\<G>) mod\n   int (order \\<G>) = int t] (mod int (order \\<G>))\n\ngoal (1 subgoal):\n 1. h =\n    \\<^bold>g [^]\n    ((int z - int z') * Number_Theory_Aux.inverse (e - e') (order \\<G>) mod\n     int (order \\<G>))", "hence  **: \"[nat (((int z - int z') * fst (bezw ((nat (int e - int e'))) (order \\<G>)))mod order \\<G>)\n              = t] (mod  order \\<G>)\""], ["proof (prove)\nusing this:\n  [(int z - int z') *\n   Number_Theory_Aux.inverse (nat (int e - int e')) (order \\<G>) mod\n   int (order \\<G>) = int t] (mod int (order \\<G>))\n\ngoal (1 subgoal):\n 1. [nat ((int z - int z') *\n          Number_Theory_Aux.inverse (nat (int e - int e')) (order \\<G>) mod\n          int (order \\<G>)) = t] (mod order \\<G>)", "by (metis Euclidean_Division.pos_mod_sign cong_int_iff int_nat_eq of_nat_0_less_iff order_gt_0)"], ["proof (state)\nthis:\n  [nat ((int z - int z') *\n        Number_Theory_Aux.inverse (nat (int e - int e')) (order \\<G>) mod\n        int (order \\<G>)) = t] (mod order \\<G>)\n\ngoal (1 subgoal):\n 1. h =\n    \\<^bold>g [^]\n    ((int z - int z') * Number_Theory_Aux.inverse (e - e') (order \\<G>) mod\n     int (order \\<G>))", "hence \"\\<^bold>g [^] (nat (((int z - int z') * fst (bezw ((nat (int e - int e'))) (order \\<G>)))mod order \\<G>)) = \\<^bold>g [^] t\""], ["proof (prove)\nusing this:\n  [nat ((int z - int z') *\n        Number_Theory_Aux.inverse (nat (int e - int e')) (order \\<G>) mod\n        int (order \\<G>)) = t] (mod order \\<G>)\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^]\n    nat ((int z - int z') *\n         Number_Theory_Aux.inverse (nat (int e - int e')) (order \\<G>) mod\n         int (order \\<G>)) =\n    \\<^bold>g [^] t", "using cyclic_group.pow_generator_eq_iff_cong cyclic_group_axioms order_gt_0 order_gt_0_iff_finite"], ["proof (prove)\nusing this:\n  [nat ((int z - int z') *\n        Number_Theory_Aux.inverse (nat (int e - int e')) (order \\<G>) mod\n        int (order \\<G>)) = t] (mod order \\<G>)\n  \\<lbrakk>Cyclic_Group.cyclic_group ?G; finite (carrier ?G)\\<rbrakk>\n  \\<Longrightarrow> (\\<^bold>g\\<^bsub>?G\\<^esub> [^]\\<^bsub>?G\\<^esub> ?x =\n                     \\<^bold>g\\<^bsub>?G\\<^esub> [^]\\<^bsub>?G\\<^esub> ?y) =\n                    [?x = ?y] (mod order ?G)\n  Cyclic_Group.cyclic_group \\<G>\n  0 < order \\<G>\n  (0 < order \\<G>) = finite (carrier \\<G>)\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^]\n    nat ((int z - int z') *\n         Number_Theory_Aux.inverse (nat (int e - int e')) (order \\<G>) mod\n         int (order \\<G>)) =\n    \\<^bold>g [^] t", "by blast"], ["proof (state)\nthis:\n  \\<^bold>g [^]\n  nat ((int z - int z') *\n       Number_Theory_Aux.inverse (nat (int e - int e')) (order \\<G>) mod\n       int (order \\<G>)) =\n  \\<^bold>g [^] t\n\ngoal (1 subgoal):\n 1. h =\n    \\<^bold>g [^]\n    ((int z - int z') * Number_Theory_Aux.inverse (e - e') (order \\<G>) mod\n     int (order \\<G>))", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<^bold>g [^]\n  nat ((int z - int z') *\n       Number_Theory_Aux.inverse (nat (int e - int e')) (order \\<G>) mod\n       int (order \\<G>)) =\n  \\<^bold>g [^] t\n\ngoal (1 subgoal):\n 1. h =\n    \\<^bold>g [^]\n    ((int z - int z') * Number_Theory_Aux.inverse (e - e') (order \\<G>) mod\n     int (order \\<G>))", "using t"], ["proof (prove)\nusing this:\n  \\<^bold>g [^]\n  nat ((int z - int z') *\n       Number_Theory_Aux.inverse (nat (int e - int e')) (order \\<G>) mod\n       int (order \\<G>)) =\n  \\<^bold>g [^] t\n  h = \\<^bold>g [^] t\n\ngoal (1 subgoal):\n 1. h =\n    \\<^bold>g [^]\n    ((int z - int z') * Number_Theory_Aux.inverse (e - e') (order \\<G>) mod\n     int (order \\<G>))", "by (smt Euclidean_Division.pos_mod_sign discrete_log.order_gt_0 int_pow_def2 nat_minus_as_int of_nat_0_less_iff)"], ["proof (state)\nthis:\n  h =\n  \\<^bold>g [^]\n  ((int z - int z') * Number_Theory_Aux.inverse (e - e') (order \\<G>) mod\n   int (order \\<G>))\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>The special soundness property for the Schnorr \\<open>\\<Sigma>\\<close>-protocol.\\<close>"], ["", "lemma special_soundness:\n  shows \"Schnorr_\\<Sigma>.special_soundness\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Schnorr_\\<Sigma>.special_soundness", "unfolding Schnorr_\\<Sigma>.special_soundness_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>h e e' a z z'.\n       h \\<in> valid_pub \\<longrightarrow>\n       e \\<in> challenge_space \\<longrightarrow>\n       e' \\<in> challenge_space \\<longrightarrow>\n       e \\<noteq> e' \\<longrightarrow>\n       check h a e z \\<longrightarrow>\n       check h a e' z' \\<longrightarrow>\n       lossless_spmf (ss_adversary h (a, e, z) (a, e', z')) \\<and>\n       (\\<forall>w'\\<in>set_spmf (ss_adversary h (a, e, z) (a, e', z')).\n           (h, w') \\<in> R_DL)", "by(auto simp add: valid_pub_def ss_rewrite challenge_space_def split_def ss_adversary_def check_def R_DL_def Let_def)"], ["", "text\\<open>We are now able to prove that the Schnorr \\<open>\\<Sigma>\\<close>-protocol is a \\<open>\\<Sigma>\\<close>-protocol, the proof comes from the properties of\ncompleteness, HVZK and special soundness we have previously proven.\\<close>"], ["", "theorem sigma_protocol:\n  shows \"Schnorr_\\<Sigma>.\\<Sigma>_protocol\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Schnorr_\\<Sigma>.\\<Sigma>_protocol", "by(simp add: Schnorr_\\<Sigma>.\\<Sigma>_protocol_def completeness honest_verifier_ZK special_soundness)"], ["", "text\\<open>Having proven the \\<open>\\<Sigma>\\<close>-protocol property is satisfied we can show the commitment scheme we construct from the \nSchnorr \\<open>\\<Sigma>\\<close>-protocol has the desired properties. This result comes with very little proof effort as we can instantiate\nour general proof.\\<close>"], ["", "sublocale Schnorr_\\<Sigma>_commit: \\<Sigma>_protocols_to_commitments init response check R_DL S2 ss_adversary challenge_space valid_pub G"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sigma>_protocols_to_commitments init response check R_DL S2\n     ss_adversary challenge_space valid_pub G", "unfolding \\<Sigma>_protocols_to_commitments_def \\<Sigma>_protocols_to_commitments_axioms_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sigma>_protocols_base R_DL valid_pub \\<and>\n    (Schnorr_\\<Sigma>.\\<Sigma>_protocol \\<and>\n     (\\<forall>h w.\n         (h, w) \\<in> set_spmf G \\<longrightarrow>\n         (h, w) \\<in> R_DL)) \\<and>\n    lossless_spmf G \\<and>\n    (\\<forall>h w. lossless_spmf (init h w)) \\<and>\n    (\\<forall>r w e. lossless_spmf (response r w e))", "apply(auto simp add: \\<Sigma>_protocols_base_def)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>x b. (x, b) \\<in> R_DL \\<Longrightarrow> x \\<in> valid_pub\n 2. Schnorr_\\<Sigma>.\\<Sigma>_protocol\n 3. \\<And>h w. (h, w) \\<in> set_spmf G \\<Longrightarrow> (h, w) \\<in> R_DL\n 4. lossless_spmf G\n 5. \\<And>h w. lossless_spmf (init h w)\n 6. \\<And>r w e. lossless_spmf (response r w e)", "apply(simp add: R_DL_def valid_pub_def)"], ["proof (prove)\ngoal (5 subgoals):\n 1. Schnorr_\\<Sigma>.\\<Sigma>_protocol\n 2. \\<And>h w. (h, w) \\<in> set_spmf G \\<Longrightarrow> (h, w) \\<in> R_DL\n 3. lossless_spmf G\n 4. \\<And>h w. lossless_spmf (init h w)\n 5. \\<And>r w e. lossless_spmf (response r w e)", "apply(auto simp add: sigma_protocol lossless_G lossless_init lossless_response)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>h w. (h, w) \\<in> set_spmf G \\<Longrightarrow> (h, w) \\<in> R_DL", "by(simp add: R_DL_def G_def)"], ["", "lemma \"Schnorr_\\<Sigma>_commit.abstract_com.correct\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Schnorr_\\<Sigma>_commit.abstract_com.correct", "by(fact Schnorr_\\<Sigma>_commit.commit_correct)"], ["", "lemma \"Schnorr_\\<Sigma>_commit.abstract_com.perfect_hiding_ind_cpa \\<A>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Schnorr_\\<Sigma>_commit.abstract_com.perfect_hiding_ind_cpa \\<A>", "by(fact Schnorr_\\<Sigma>_commit.perfect_hiding)"], ["", "lemma rel_adv_eq_dis_log_adv: \n  \"Schnorr_\\<Sigma>_commit.rel_advantage \\<A> = discrete_log.advantage \\<A>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Schnorr_\\<Sigma>_commit.rel_advantage \\<A> = discrete_log.advantage \\<A>", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. Schnorr_\\<Sigma>_commit.rel_advantage \\<A> = discrete_log.advantage \\<A>", "have \"Schnorr_\\<Sigma>_commit.rel_game \\<A> = discrete_log.dis_log \\<A>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Schnorr_\\<Sigma>_commit.rel_game \\<A> = discrete_log.dis_log \\<A>", "unfolding Schnorr_\\<Sigma>_commit.rel_game_def discrete_log.dis_log_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. TRY G \\<bind>\n        (\\<lambda>(h, w).\n            \\<A> h \\<bind>\n            (\\<lambda>w'.\n                return_spmf ((h, w') \\<in> R_DL))) ELSE return_spmf False =\n    TRY sample_uniform (order \\<G>) \\<bind>\n        (\\<lambda>x.\n            let h = \\<^bold>g [^] x\n            in \\<A> h \\<bind>\n               (\\<lambda>x'.\n                   return_spmf\n                    [x = x'] (mod order \\<G>))) ELSE return_spmf False", "by(auto intro: try_spmf_cong bind_spmf_cong[OF refl] \n       simp add: G_def R_DL_def cong_less_modulus_unique_nat group_eq_pow_eq_mod finite_carrier pow_generator_eq_iff_cong)"], ["proof (state)\nthis:\n  Schnorr_\\<Sigma>_commit.rel_game \\<A> = discrete_log.dis_log \\<A>\n\ngoal (1 subgoal):\n 1. Schnorr_\\<Sigma>_commit.rel_advantage \\<A> = discrete_log.advantage \\<A>", "thus ?thesis"], ["proof (prove)\nusing this:\n  Schnorr_\\<Sigma>_commit.rel_game \\<A> = discrete_log.dis_log \\<A>\n\ngoal (1 subgoal):\n 1. Schnorr_\\<Sigma>_commit.rel_advantage \\<A> = discrete_log.advantage \\<A>", "using Schnorr_\\<Sigma>_commit.rel_advantage_def discrete_log.advantage_def"], ["proof (prove)\nusing this:\n  Schnorr_\\<Sigma>_commit.rel_game \\<A> = discrete_log.dis_log \\<A>\n  Schnorr_\\<Sigma>_commit.rel_advantage ?\\<A> \\<equiv>\n  spmf (Schnorr_\\<Sigma>_commit.rel_game ?\\<A>) True\n  discrete_log.advantage ?\\<A> \\<equiv>\n  spmf (discrete_log.dis_log ?\\<A>) True\n\ngoal (1 subgoal):\n 1. Schnorr_\\<Sigma>_commit.rel_advantage \\<A> = discrete_log.advantage \\<A>", "by simp"], ["proof (state)\nthis:\n  Schnorr_\\<Sigma>_commit.rel_advantage \\<A> = discrete_log.advantage \\<A>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bind_advantage_bound_dis_log: \n  \"Schnorr_\\<Sigma>_commit.abstract_com.bind_advantage \\<A> \\<le> discrete_log.advantage (Schnorr_\\<Sigma>_commit.adversary \\<A>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Schnorr_\\<Sigma>_commit.abstract_com.bind_advantage \\<A>\n    \\<le> discrete_log.advantage (Schnorr_\\<Sigma>_commit.adversary \\<A>)", "using Schnorr_\\<Sigma>_commit.bind_advantage rel_adv_eq_dis_log_adv"], ["proof (prove)\nusing this:\n  Schnorr_\\<Sigma>_commit.abstract_com.bind_advantage ?\\<A>\n  \\<le> Schnorr_\\<Sigma>_commit.rel_advantage\n         (Schnorr_\\<Sigma>_commit.adversary ?\\<A>)\n  Schnorr_\\<Sigma>_commit.rel_advantage ?\\<A> = discrete_log.advantage ?\\<A>\n\ngoal (1 subgoal):\n 1. Schnorr_\\<Sigma>_commit.abstract_com.bind_advantage \\<A>\n    \\<le> discrete_log.advantage (Schnorr_\\<Sigma>_commit.adversary \\<A>)", "by simp"], ["", "end"], ["", "locale schnorr_asymp = \n  fixes \\<G> :: \"nat \\<Rightarrow> 'grp cyclic_group\"\n  assumes schnorr: \"\\<And>\\<eta>. schnorr_sigma_protocol (\\<G> \\<eta>)\"\nbegin"], ["", "sublocale schnorr_sigma_protocol \"\\<G> \\<eta>\" for \\<eta>"], ["proof (prove)\ngoal (1 subgoal):\n 1. schnorr_sigma_protocol (\\<G> \\<eta>)", "by(simp add: schnorr)"], ["", "text\\<open>The \\<open>\\<Sigma>\\<close>-protocol statement comes easily in the asymptotic setting.\\<close>"], ["", "theorem sigma_protocol:\n  shows \"Schnorr_\\<Sigma>.\\<Sigma>_protocol n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Schnorr_\\<Sigma>.\\<Sigma>_protocol n", "by(simp add: sigma_protocol)"], ["", "text\\<open>We now show the statements of security for the commitment scheme in the asymptotic setting, the main difference is that\nwe are able to show the binding advantage is negligible in the security parameter.\\<close>"], ["", "lemma asymp_correct: \"Schnorr_\\<Sigma>_commit.abstract_com.correct n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Schnorr_\\<Sigma>_commit.abstract_com.correct n", "using  Schnorr_\\<Sigma>_commit.commit_correct"], ["proof (prove)\nusing this:\n  Schnorr_\\<Sigma>_commit.abstract_com.correct ?\\<eta>\n\ngoal (1 subgoal):\n 1. Schnorr_\\<Sigma>_commit.abstract_com.correct n", "by simp"], ["", "lemma asymp_perfect_hiding: \"Schnorr_\\<Sigma>_commit.abstract_com.perfect_hiding_ind_cpa n (\\<A> n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Schnorr_\\<Sigma>_commit.abstract_com.perfect_hiding_ind_cpa n (\\<A> n)", "using Schnorr_\\<Sigma>_commit.perfect_hiding"], ["proof (prove)\nusing this:\n  Schnorr_\\<Sigma>_commit.abstract_com.perfect_hiding_ind_cpa ?\\<eta> ?\\<A>\n\ngoal (1 subgoal):\n 1. Schnorr_\\<Sigma>_commit.abstract_com.perfect_hiding_ind_cpa n (\\<A> n)", "by blast"], ["", "lemma asymp_computational_binding: \n  assumes \"negligible (\\<lambda> n. discrete_log.advantage n (Schnorr_\\<Sigma>_commit.adversary n (\\<A> n)))\"\n  shows \"negligible (\\<lambda> n. Schnorr_\\<Sigma>_commit.abstract_com.bind_advantage n (\\<A> n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Negligible.negligible\n     (\\<lambda>n.\n         Schnorr_\\<Sigma>_commit.abstract_com.bind_advantage n (\\<A> n))", "using Schnorr_\\<Sigma>_commit.bind_advantage assms Schnorr_\\<Sigma>_commit.abstract_com.bind_advantage_def negligible_le bind_advantage_bound_dis_log"], ["proof (prove)\nusing this:\n  Schnorr_\\<Sigma>_commit.abstract_com.bind_advantage ?\\<eta> ?\\<A>\n  \\<le> Schnorr_\\<Sigma>_commit.rel_advantage ?\\<eta>\n         (Schnorr_\\<Sigma>_commit.adversary ?\\<eta> ?\\<A>)\n  Negligible.negligible\n   (\\<lambda>n.\n       discrete_log.advantage n\n        (Schnorr_\\<Sigma>_commit.adversary n (\\<A> n)))\n  Schnorr_\\<Sigma>_commit.abstract_com.bind_advantage ?\\<eta> ?\\<A> \\<equiv>\n  spmf (Schnorr_\\<Sigma>_commit.abstract_com.bind_game ?\\<eta> ?\\<A>) True\n  \\<lbrakk>Negligible.negligible ?g;\n   \\<And>\\<eta>. \\<bar>?f \\<eta>\\<bar> \\<le> ?g \\<eta>\\<rbrakk>\n  \\<Longrightarrow> Negligible.negligible ?f\n  Schnorr_\\<Sigma>_commit.abstract_com.bind_advantage ?\\<eta> ?\\<A>\n  \\<le> discrete_log.advantage ?\\<eta>\n         (Schnorr_\\<Sigma>_commit.adversary ?\\<eta> ?\\<A>)\n\ngoal (1 subgoal):\n 1. Negligible.negligible\n     (\\<lambda>n.\n         Schnorr_\\<Sigma>_commit.abstract_com.bind_advantage n (\\<A> n))", "by auto"], ["", "end"], ["", "end"]]}