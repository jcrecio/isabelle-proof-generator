{"file_name": "/home/qj213/afp-2021-10-22/thys/Sigma_Commit_Crypto/Sigma_Protocols.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Sigma_Commit_Crypto", "problem_names": ["lemma assumes \"x \\<in> Domain Rel\" shows \"\\<exists> w. (x,w) \\<in> Rel\"", "lemma lossless_S_raw_imp_lossless_S: \"lossless_spmf (S_raw h e) \\<longrightarrow> lossless_spmf (S h e)\"", "lemma special_soundness_alt:\n  \"special_soundness \\<longleftrightarrow>\n      (\\<forall> h a e z e' z'. e \\<in> challenge_space \\<longrightarrow> e' \\<in> challenge_space \\<longrightarrow> h \\<in> valid_pub \n          \\<longrightarrow> e \\<noteq> e' \\<longrightarrow> check h a e z \\<and> check h a e' z' \n              \\<longrightarrow> bind_spmf (\\<A>ss h (a,e,z) (a,e',z')) (\\<lambda> w'. return_spmf ((h,w') \\<in> Rel)) = return_spmf True)\"", "lemma lossless_complete_game: \n  assumes lossless_init: \"\\<forall> h w. lossless_spmf (init h w)\"\n    and lossless_response: \"\\<forall> r w e. lossless_spmf (response r w e)\"\n  shows \"lossless_spmf (completeness_game h w e)\"", "lemma complete_game_return_true:\n  assumes \"(h,w) \\<in> Rel\" \n    and \"completeness\"\n    and lossless_init: \"\\<forall> h w. lossless_spmf (init h w)\"\n    and lossless_response: \"\\<forall> r w e. lossless_spmf (response r w e)\"\n    and \"e \\<in> challenge_space\"\n  shows \"completeness_game h w e = return_spmf True\"", "lemma HVZK_unfold1:\n  assumes \"\\<Sigma>_protocol\" \n  shows \"\\<forall> h w e. (h,w) \\<in> Rel \\<longrightarrow> e \\<in> challenge_space \\<longrightarrow> R h w e = S h e\"", "lemma HVZK_unfold2:\n  assumes \"\\<Sigma>_protocol\" \n  shows \"\\<forall> h e out. e \\<in> challenge_space \\<longrightarrow> h \\<in> valid_pub \\<longrightarrow> out \\<in> set_spmf (S_raw h e) \\<longrightarrow> check h (fst out) e (snd out)\"", "lemma HVZK_unfold2_alt:\n  assumes \"\\<Sigma>_protocol\" \n  shows \"\\<forall> h a e z. e \\<in> challenge_space \\<longrightarrow> h \\<in> valid_pub \\<longrightarrow> (a,z) \\<in> set_spmf (S_raw h e) \\<longrightarrow> check h a e z\"", "lemma set_spmf_G_domain_rel [simp]: \"(h,w) \\<in> set_spmf G \\<Longrightarrow> h \\<in> Domain Rel\"", "lemma set_spmf_G_L [simp]: \"(h,w) \\<in> set_spmf G \\<Longrightarrow> h \\<in> L\"", "lemma commit_correct:\n  shows \"abstract_com.correct\"", "lemma perfect_hiding:\n  shows \"abstract_com.perfect_hiding_ind_cpa \\<A>\"", "lemma bind_advantage:\n  shows \"abstract_com.bind_advantage \\<A> \\<le> rel_advantage (adversary \\<A>)\""], "translations": [["", "lemma assumes \"x \\<in> Domain Rel\" shows \"\\<exists> w. (x,w) \\<in> Rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>w. (x, w) \\<in> Rel", "using assms"], ["proof (prove)\nusing this:\n  x \\<in> Domain Rel\n\ngoal (1 subgoal):\n 1. \\<exists>w. (x, w) \\<in> Rel", "by auto"], ["", "text\\<open>The language defined by the relation is the set of all public inputs such that there exists a witness that satisfies the relation.\\<close>"], ["", "definition \"L \\<equiv> {x. \\<exists> w. (x, w) \\<in> Rel}\""], ["", "text\\<open>The first property of \\<open>\\<Sigma>\\<close>-protocols we consider is completeness, we define a probabilistic programme \nthat runs the components of the protocol and outputs the boolean defined by the check algorithm.\\<close>"], ["", "definition completeness_game :: \"'pub_input \\<Rightarrow> 'witness \\<Rightarrow> 'challenge \\<Rightarrow> bool spmf\"\n  where \"completeness_game h w e = do {\n    (r, a) \\<leftarrow> init h w;\n    z \\<leftarrow> response r w e;\n    return_spmf (check h a e z)}\""], ["", "text\\<open>We define completeness as the probability that the completeness-game returns true for all challenges assuming the relation holds on \\<open>h\\<close> and \\<open>w\\<close>.\\<close>"], ["", "definition \"completeness \\<equiv> (\\<forall> h w e . (h,w) \\<in> Rel \\<longrightarrow> e \\<in> challenge_space \\<longrightarrow> spmf (completeness_game h w e) True = 1)\""], ["", "text\\<open>Second we consider the honest verifier zero knowledge property (HVZK). To reason about this we construct the real view of the \n\\<open>\\<Sigma>\\<close>-protocol given a challenge \\<open>e\\<close> as input.\\<close>"], ["", "definition R :: \"'pub_input \\<Rightarrow> 'witness \\<Rightarrow> 'challenge \\<Rightarrow> ('msg, 'challenge, 'response) conv_tuple spmf\"\n  where \"R h w e = do { \n    (r,a) \\<leftarrow> init h w;\n    z \\<leftarrow> response r w e;\n    return_spmf (a,e,z)}\""], ["", "definition S where \"S h e = map_spmf (\\<lambda> (a, z). (a, e, z)) (S_raw h e)\""], ["", "lemma lossless_S_raw_imp_lossless_S: \"lossless_spmf (S_raw h e) \\<longrightarrow> lossless_spmf (S h e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lossless_spmf (S_raw h e) \\<longrightarrow> lossless_spmf (S h e)", "by(simp add: S_def)"], ["", "text\\<open>The HVZK property requires that the simulator's output distribution is equal to the real views output distribution.\\<close>"], ["", "definition \"HVZK \\<equiv> (\\<forall>e \\<in> challenge_space. \n                      (\\<forall>(h, w)\\<in>Rel. R h w e = S h e)\n                        \\<and> (\\<forall>h \\<in> valid_pub. \\<forall>(a, z) \\<in> set_spmf (S_raw h e). check h a e z))\""], ["", "text\\<open>The final property to consider is that of special soundness. This says that given two valid transcripts such that the challenges \nare not equal there exists an adversary \\<open>\\<A>ss\\<close> that can output the witness.\\<close>"], ["", "definition \"special_soundness \\<equiv> (\\<forall> h e e' a z z'. h \\<in> valid_pub \\<longrightarrow> e \\<in> challenge_space \\<longrightarrow> e' \\<in> challenge_space \\<longrightarrow>  e \\<noteq> e' \n              \\<longrightarrow> check h a e z \\<longrightarrow> check h a e' z' \\<longrightarrow> (lossless_spmf (\\<A>ss h (a,e,z) (a, e', z')) \\<and> \n                  (\\<forall>w'\\<in>set_spmf (\\<A>ss h (a,e,z) (a,e',z')). (h,w') \\<in> Rel)))\""], ["", "lemma special_soundness_alt:\n  \"special_soundness \\<longleftrightarrow>\n      (\\<forall> h a e z e' z'. e \\<in> challenge_space \\<longrightarrow> e' \\<in> challenge_space \\<longrightarrow> h \\<in> valid_pub \n          \\<longrightarrow> e \\<noteq> e' \\<longrightarrow> check h a e z \\<and> check h a e' z' \n              \\<longrightarrow> bind_spmf (\\<A>ss h (a,e,z) (a,e',z')) (\\<lambda> w'. return_spmf ((h,w') \\<in> Rel)) = return_spmf True)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. special_soundness =\n    (\\<forall>h a e z e' z'.\n        e \\<in> challenge_space \\<longrightarrow>\n        e' \\<in> challenge_space \\<longrightarrow>\n        h \\<in> valid_pub \\<longrightarrow>\n        e \\<noteq> e' \\<longrightarrow>\n        check h a e z \\<and> check h a e' z' \\<longrightarrow>\n        \\<A>ss h (a, e, z) (a, e', z') \\<bind>\n        (\\<lambda>w'. return_spmf ((h, w') \\<in> Rel)) =\n        return_spmf True)", "apply(auto simp add: special_soundness_def map_spmf_conv_bind_spmf[symmetric] map_pmf_eq_return_pmf_iff in_set_spmf lossless_iff_set_pmf_None)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>h a e z e' z' y.\n       \\<lbrakk>\\<forall>h.\n                   h \\<in> valid_pub \\<longrightarrow>\n                   (\\<forall>e.\n                       e \\<in> challenge_space \\<longrightarrow>\n                       (\\<forall>e'.\n                           e' \\<in> challenge_space \\<longrightarrow>\n                           e \\<noteq> e' \\<longrightarrow>\n                           (\\<forall>a z.\n                               check h a e z \\<longrightarrow>\n                               (\\<forall>z'.\n                                   check h a e' z' \\<longrightarrow>\n                                   None\n                                   \\<notin> set_pmf\n       (\\<A>ss h (a, e, z) (a, e', z')) \\<and>\n                                   (\\<forall>w'\n       \\<in>set_spmf (\\<A>ss h (a, e, z) (a, e', z')).\n (h, w') \\<in> Rel)))));\n        e \\<in> challenge_space; e' \\<in> challenge_space;\n        h \\<in> valid_pub; e \\<noteq> e';\n        y \\<in> set_pmf (\\<A>ss h (a, e, z) (a, e', z')); check h a e z;\n        check h a e' z'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>z. y = Some z \\<and> (h, z) \\<in> Rel\n 2. \\<And>h e e' a z z'.\n       \\<lbrakk>\\<forall>h a e.\n                   e \\<in> challenge_space \\<longrightarrow>\n                   (\\<forall>z e'.\n                       e' \\<in> challenge_space \\<longrightarrow>\n                       h \\<in> valid_pub \\<longrightarrow>\n                       e \\<noteq> e' \\<longrightarrow>\n                       (\\<forall>z'.\n                           check h a e z \\<and>\n                           check h a e' z' \\<longrightarrow>\n                           (\\<forall>y\\<in>set_pmf\n      (\\<A>ss h (a, e, z) (a, e', z')).\n                               \\<exists>z.\n                                  y = Some z \\<and> (h, z) \\<in> Rel)));\n        h \\<in> valid_pub; e \\<in> challenge_space;\n        e' \\<in> challenge_space; e \\<noteq> e'; check h a e z;\n        check h a e' z';\n        None \\<in> set_pmf (\\<A>ss h (a, e, z) (a, e', z'))\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>h e e' a z z' w'.\n       \\<lbrakk>\\<forall>h a e.\n                   e \\<in> challenge_space \\<longrightarrow>\n                   (\\<forall>z e'.\n                       e' \\<in> challenge_space \\<longrightarrow>\n                       h \\<in> valid_pub \\<longrightarrow>\n                       e \\<noteq> e' \\<longrightarrow>\n                       (\\<forall>z'.\n                           check h a e z \\<and>\n                           check h a e' z' \\<longrightarrow>\n                           (\\<forall>y\\<in>set_pmf\n      (\\<A>ss h (a, e, z) (a, e', z')).\n                               \\<exists>z.\n                                  y = Some z \\<and> (h, z) \\<in> Rel)));\n        h \\<in> valid_pub; e \\<in> challenge_space;\n        e' \\<in> challenge_space; e \\<noteq> e'; check h a e z;\n        check h a e' z';\n        Some w' \\<in> set_pmf (\\<A>ss h (a, e, z) (a, e', z'))\\<rbrakk>\n       \\<Longrightarrow> (h, w') \\<in> Rel", "apply(metis Domain.DomainI in_set_spmf not_Some_eq)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>h e e' a z z'.\n       \\<lbrakk>\\<forall>h a e.\n                   e \\<in> challenge_space \\<longrightarrow>\n                   (\\<forall>z e'.\n                       e' \\<in> challenge_space \\<longrightarrow>\n                       h \\<in> valid_pub \\<longrightarrow>\n                       e \\<noteq> e' \\<longrightarrow>\n                       (\\<forall>z'.\n                           check h a e z \\<and>\n                           check h a e' z' \\<longrightarrow>\n                           (\\<forall>y\\<in>set_pmf\n      (\\<A>ss h (a, e, z) (a, e', z')).\n                               \\<exists>z.\n                                  y = Some z \\<and> (h, z) \\<in> Rel)));\n        h \\<in> valid_pub; e \\<in> challenge_space;\n        e' \\<in> challenge_space; e \\<noteq> e'; check h a e z;\n        check h a e' z';\n        None \\<in> set_pmf (\\<A>ss h (a, e, z) (a, e', z'))\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>h e e' a z z' w'.\n       \\<lbrakk>\\<forall>h a e.\n                   e \\<in> challenge_space \\<longrightarrow>\n                   (\\<forall>z e'.\n                       e' \\<in> challenge_space \\<longrightarrow>\n                       h \\<in> valid_pub \\<longrightarrow>\n                       e \\<noteq> e' \\<longrightarrow>\n                       (\\<forall>z'.\n                           check h a e z \\<and>\n                           check h a e' z' \\<longrightarrow>\n                           (\\<forall>y\\<in>set_pmf\n      (\\<A>ss h (a, e, z) (a, e', z')).\n                               \\<exists>z.\n                                  y = Some z \\<and> (h, z) \\<in> Rel)));\n        h \\<in> valid_pub; e \\<in> challenge_space;\n        e' \\<in> challenge_space; e \\<noteq> e'; check h a e z;\n        check h a e' z';\n        Some w' \\<in> set_pmf (\\<A>ss h (a, e, z) (a, e', z'))\\<rbrakk>\n       \\<Longrightarrow> (h, w') \\<in> Rel", "using Domain.intros"], ["proof (prove)\nusing this:\n  (?a, ?b) \\<in> ?r \\<Longrightarrow> ?a \\<in> Domain ?r\n\ngoal (2 subgoals):\n 1. \\<And>h e e' a z z'.\n       \\<lbrakk>\\<forall>h a e.\n                   e \\<in> challenge_space \\<longrightarrow>\n                   (\\<forall>z e'.\n                       e' \\<in> challenge_space \\<longrightarrow>\n                       h \\<in> valid_pub \\<longrightarrow>\n                       e \\<noteq> e' \\<longrightarrow>\n                       (\\<forall>z'.\n                           check h a e z \\<and>\n                           check h a e' z' \\<longrightarrow>\n                           (\\<forall>y\\<in>set_pmf\n      (\\<A>ss h (a, e, z) (a, e', z')).\n                               \\<exists>z.\n                                  y = Some z \\<and> (h, z) \\<in> Rel)));\n        h \\<in> valid_pub; e \\<in> challenge_space;\n        e' \\<in> challenge_space; e \\<noteq> e'; check h a e z;\n        check h a e' z';\n        None \\<in> set_pmf (\\<A>ss h (a, e, z) (a, e', z'))\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>h e e' a z z' w'.\n       \\<lbrakk>\\<forall>h a e.\n                   e \\<in> challenge_space \\<longrightarrow>\n                   (\\<forall>z e'.\n                       e' \\<in> challenge_space \\<longrightarrow>\n                       h \\<in> valid_pub \\<longrightarrow>\n                       e \\<noteq> e' \\<longrightarrow>\n                       (\\<forall>z'.\n                           check h a e z \\<and>\n                           check h a e' z' \\<longrightarrow>\n                           (\\<forall>y\\<in>set_pmf\n      (\\<A>ss h (a, e, z) (a, e', z')).\n                               \\<exists>z.\n                                  y = Some z \\<and> (h, z) \\<in> Rel)));\n        h \\<in> valid_pub; e \\<in> challenge_space;\n        e' \\<in> challenge_space; e \\<noteq> e'; check h a e z;\n        check h a e' z';\n        Some w' \\<in> set_pmf (\\<A>ss h (a, e, z) (a, e', z'))\\<rbrakk>\n       \\<Longrightarrow> (h, w') \\<in> Rel", "by blast +"], ["", "definition \"\\<Sigma>_protocol \\<equiv> completeness \\<and> special_soundness \\<and> HVZK\""], ["", "text\\<open>General lemmas\\<close>"], ["", "lemma lossless_complete_game: \n  assumes lossless_init: \"\\<forall> h w. lossless_spmf (init h w)\"\n    and lossless_response: \"\\<forall> r w e. lossless_spmf (response r w e)\"\n  shows \"lossless_spmf (completeness_game h w e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lossless_spmf (completeness_game h w e)", "by(simp add: completeness_game_def lossless_init lossless_response split_def)"], ["", "lemma complete_game_return_true:\n  assumes \"(h,w) \\<in> Rel\" \n    and \"completeness\"\n    and lossless_init: \"\\<forall> h w. lossless_spmf (init h w)\"\n    and lossless_response: \"\\<forall> r w e. lossless_spmf (response r w e)\"\n    and \"e \\<in> challenge_space\"\n  shows \"completeness_game h w e = return_spmf True\""], ["proof (prove)\ngoal (1 subgoal):\n 1. completeness_game h w e = return_spmf True", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. completeness_game h w e = return_spmf True", "have \"spmf (completeness_game h w e) True = spmf (return_spmf True) True\""], ["proof (prove)\ngoal (1 subgoal):\n 1. spmf (completeness_game h w e) True = spmf (return_spmf True) True", "using assms \\<Sigma>_protocol_def completeness_def"], ["proof (prove)\nusing this:\n  (h, w) \\<in> Rel\n  completeness\n  \\<forall>h w. lossless_spmf (init h w)\n  \\<forall>r w e. lossless_spmf (response r w e)\n  e \\<in> challenge_space\n  \\<Sigma>_protocol \\<equiv>\n  completeness \\<and> special_soundness \\<and> HVZK\n  completeness \\<equiv>\n  \\<forall>h w e.\n     (h, w) \\<in> Rel \\<longrightarrow>\n     e \\<in> challenge_space \\<longrightarrow>\n     spmf (completeness_game h w e) True = 1\n\ngoal (1 subgoal):\n 1. spmf (completeness_game h w e) True = spmf (return_spmf True) True", "by fastforce"], ["proof (state)\nthis:\n  spmf (completeness_game h w e) True = spmf (return_spmf True) True\n\ngoal (1 subgoal):\n 1. completeness_game h w e = return_spmf True", "then"], ["proof (chain)\npicking this:\n  spmf (completeness_game h w e) True = spmf (return_spmf True) True", "have \"completeness_game h w e = return_spmf True\""], ["proof (prove)\nusing this:\n  spmf (completeness_game h w e) True = spmf (return_spmf True) True\n\ngoal (1 subgoal):\n 1. completeness_game h w e = return_spmf True", "by (metis (full_types) lossless_complete_game lossless_init lossless_response lossless_return_spmf spmf_False_conv_True spmf_eqI)"], ["proof (state)\nthis:\n  completeness_game h w e = return_spmf True\n\ngoal (1 subgoal):\n 1. completeness_game h w e = return_spmf True", "then"], ["proof (chain)\npicking this:\n  completeness_game h w e = return_spmf True", "show ?thesis"], ["proof (prove)\nusing this:\n  completeness_game h w e = return_spmf True\n\ngoal (1 subgoal):\n 1. completeness_game h w e = return_spmf True", "by (simp add: completeness_game_def)"], ["proof (state)\nthis:\n  completeness_game h w e = return_spmf True\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma HVZK_unfold1:\n  assumes \"\\<Sigma>_protocol\" \n  shows \"\\<forall> h w e. (h,w) \\<in> Rel \\<longrightarrow> e \\<in> challenge_space \\<longrightarrow> R h w e = S h e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>h w e.\n       (h, w) \\<in> Rel \\<longrightarrow>\n       e \\<in> challenge_space \\<longrightarrow> R h w e = S h e", "using assms"], ["proof (prove)\nusing this:\n  \\<Sigma>_protocol\n\ngoal (1 subgoal):\n 1. \\<forall>h w e.\n       (h, w) \\<in> Rel \\<longrightarrow>\n       e \\<in> challenge_space \\<longrightarrow> R h w e = S h e", "by(auto simp add: \\<Sigma>_protocol_def HVZK_def)"], ["", "lemma HVZK_unfold2:\n  assumes \"\\<Sigma>_protocol\" \n  shows \"\\<forall> h e out. e \\<in> challenge_space \\<longrightarrow> h \\<in> valid_pub \\<longrightarrow> out \\<in> set_spmf (S_raw h e) \\<longrightarrow> check h (fst out) e (snd out)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>h e out.\n       e \\<in> challenge_space \\<longrightarrow>\n       h \\<in> valid_pub \\<longrightarrow>\n       out \\<in> set_spmf (S_raw h e) \\<longrightarrow>\n       check h (fst out) e (snd out)", "using assms"], ["proof (prove)\nusing this:\n  \\<Sigma>_protocol\n\ngoal (1 subgoal):\n 1. \\<forall>h e out.\n       e \\<in> challenge_space \\<longrightarrow>\n       h \\<in> valid_pub \\<longrightarrow>\n       out \\<in> set_spmf (S_raw h e) \\<longrightarrow>\n       check h (fst out) e (snd out)", "by(auto simp add: \\<Sigma>_protocol_def HVZK_def split_def)"], ["", "lemma HVZK_unfold2_alt:\n  assumes \"\\<Sigma>_protocol\" \n  shows \"\\<forall> h a e z. e \\<in> challenge_space \\<longrightarrow> h \\<in> valid_pub \\<longrightarrow> (a,z) \\<in> set_spmf (S_raw h e) \\<longrightarrow> check h a e z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>h a e z.\n       e \\<in> challenge_space \\<longrightarrow>\n       h \\<in> valid_pub \\<longrightarrow>\n       (a, z) \\<in> set_spmf (S_raw h e) \\<longrightarrow> check h a e z", "using assms"], ["proof (prove)\nusing this:\n  \\<Sigma>_protocol\n\ngoal (1 subgoal):\n 1. \\<forall>h a e z.\n       e \\<in> challenge_space \\<longrightarrow>\n       h \\<in> valid_pub \\<longrightarrow>\n       (a, z) \\<in> set_spmf (S_raw h e) \\<longrightarrow> check h a e z", "by(fastforce simp add: \\<Sigma>_protocol_def HVZK_def)"], ["", "end"], ["", "subsection\\<open>Commitments from \\<open>\\<Sigma>\\<close>-protocols\\<close>"], ["", "text\\<open>In this section we provide a general proof that \\<open>\\<Sigma>\\<close>-protocols can be used to construct commitment schemes. \nWe follow  the construction given by Damgard in \\cite{sigma_protocols}.\\<close>"], ["", "locale \\<Sigma>_protocols_to_commitments = \\<Sigma>_protocols_base init response check Rel S_raw \\<A>ss challenge_space valid_pub\n  for init :: \"'pub_input \\<Rightarrow> 'witness \\<Rightarrow> ('rand \\<times> 'msg) spmf\"\n    and response :: \"'rand \\<Rightarrow> 'witness \\<Rightarrow> 'challenge \\<Rightarrow> 'response spmf\"\n    and check :: \"'pub_input \\<Rightarrow> 'msg \\<Rightarrow> 'challenge \\<Rightarrow> 'response \\<Rightarrow> bool\"\n    and Rel :: \"('pub_input \\<times> 'witness) set\"\n    and S_raw :: \"'pub_input \\<Rightarrow> 'challenge \\<Rightarrow> ('msg, 'response) sim_out spmf\"\n    and \\<A>ss :: \"('pub_input, 'msg, 'challenge, 'response, 'witness) prover_adversary\"\n    and challenge_space :: \"'challenge set\"\n    and valid_pub :: \"'pub_input set\"\n    and G :: \"('pub_input \\<times> 'witness) spmf\" \\<comment> \\<open>generates pairs that satisfy the relation\\<close>\n    +\n  assumes \\<Sigma>_prot: \"\\<Sigma>_protocol\" \\<comment> \\<open>assume we have a \\<open>\\<Sigma>\\<close>-protocol\\<close>\n    and set_spmf_G_rel [simp]: \"(h,w) \\<in> set_spmf G \\<Longrightarrow> (h,w) \\<in> Rel\" \\<comment> \\<open>the generator has the desired property\\<close>  \n    and lossless_G: \"lossless_spmf G\"\n    and lossless_init: \"lossless_spmf (init h w)\"\n    and lossless_response: \"lossless_spmf (response r w e)\"\nbegin"], ["", "lemma set_spmf_G_domain_rel [simp]: \"(h,w) \\<in> set_spmf G \\<Longrightarrow> h \\<in> Domain Rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (h, w) \\<in> set_spmf G \\<Longrightarrow> h \\<in> Domain Rel", "using set_spmf_G_rel"], ["proof (prove)\nusing this:\n  (?h, ?w) \\<in> set_spmf G \\<Longrightarrow> (?h, ?w) \\<in> Rel\n\ngoal (1 subgoal):\n 1. (h, w) \\<in> set_spmf G \\<Longrightarrow> h \\<in> Domain Rel", "by fast"], ["", "lemma set_spmf_G_L [simp]: \"(h,w) \\<in> set_spmf G \\<Longrightarrow> h \\<in> L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (h, w) \\<in> set_spmf G \\<Longrightarrow> h \\<in> L", "by (metis mem_Collect_eq set_spmf_G_rel L_def)"], ["", "text\\<open>We define the advantage associated with the hard relation, this is used in the proof of the binding property where\nwe reduce the binding advantage to the relation advantage.\\<close>"], ["", "definition rel_game :: \"('pub_input \\<Rightarrow> 'witness spmf) \\<Rightarrow> bool spmf\"\n  where \"rel_game \\<A> = TRY do {\n    (h,w) \\<leftarrow> G;\n    w' \\<leftarrow> \\<A> h;\n    return_spmf ((h,w') \\<in> Rel)} ELSE return_spmf False\""], ["", "definition rel_advantage :: \"('pub_input \\<Rightarrow> 'witness spmf) \\<Rightarrow> real\"\n  where \"rel_advantage \\<A> \\<equiv> spmf (rel_game \\<A>) True\""], ["", "text\\<open>We now define the algorithms that define the commitment scheme constructed from a \\<open>\\<Sigma>\\<close>-protocol.\\<close>"], ["", "definition key_gen :: \"('pub_input \\<times>  ('pub_input \\<times> 'witness)) spmf\"\n  where \n   \"key_gen = do {\n    (x,w) \\<leftarrow> G;\n    return_spmf (x, (x,w))}\""], ["", "definition commit :: \"'pub_input \\<Rightarrow> 'challenge \\<Rightarrow> ('msg \\<times>  'response) spmf\"\n  where\n    \"commit x e = do {\n    (a,e,z) \\<leftarrow> S x e;\n    return_spmf (a, z)}\""], ["", "definition verify :: \"('pub_input \\<times> 'witness) \\<Rightarrow> 'challenge \\<Rightarrow> 'msg \\<Rightarrow>  'response \\<Rightarrow> bool\"\n  where \"verify x e a z = (check (fst x) a e z)\""], ["", "text\\<open>We allow the adversary to output any message, so this means the type constraint is enough\\<close>"], ["", "definition \"valid_msg m = (m \\<in> challenge_space)\""], ["", "text\\<open>Showing the construction of a commitment scheme from a \\<open>\\<Sigma>\\<close>-protocol is a  valid commitment scheme is trivial.\\<close>"], ["", "sublocale abstract_com: abstract_commitment key_gen commit verify valid_msg"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "paragraph\\<open>Correctness\\<close>"], ["", "lemma commit_correct:\n  shows \"abstract_com.correct\""], ["proof (prove)\ngoal (1 subgoal):\n 1. abstract_com.correct", "including monad_normalisation"], ["proof (prove)\ngoal (1 subgoal):\n 1. abstract_com.correct", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. abstract_com.correct", "have \"\\<forall> m \\<in> challenge_space. abstract_com.correct_game m = return_spmf True\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>m\\<in>challenge_space.\n       abstract_com.correct_game m = return_spmf True", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m.\n       m \\<in> challenge_space \\<Longrightarrow>\n       abstract_com.correct_game m = return_spmf True", "fix m"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m.\n       m \\<in> challenge_space \\<Longrightarrow>\n       abstract_com.correct_game m = return_spmf True", "assume m: \"m \\<in> challenge_space\""], ["proof (state)\nthis:\n  m \\<in> challenge_space\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       m \\<in> challenge_space \\<Longrightarrow>\n       abstract_com.correct_game m = return_spmf True", "show \"abstract_com.correct_game m = return_spmf True\""], ["proof (prove)\ngoal (1 subgoal):\n 1. abstract_com.correct_game m = return_spmf True", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. abstract_com.correct_game m = return_spmf True", "have \"abstract_com.correct_game m = do {\n      (ck, (vk1,vk2)) \\<leftarrow> key_gen;\n      (a,e,z) \\<leftarrow> S ck m;\n      return_spmf (check vk1 a m z)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. abstract_com.correct_game m =\n    key_gen \\<bind>\n    (\\<lambda>(ck, vk1, vk2).\n        S ck m \\<bind> (\\<lambda>(a, e, z). return_spmf (check vk1 a m z)))", "unfolding abstract_com.correct_game_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. key_gen \\<bind>\n    (\\<lambda>(ck, vk).\n        commit ck m \\<bind>\n        (\\<lambda>(c, d). return_spmf (verify vk m c d))) =\n    key_gen \\<bind>\n    (\\<lambda>(ck, vk1, vk2).\n        S ck m \\<bind> (\\<lambda>(a, e, z). return_spmf (check vk1 a m z)))", "by(simp add: commit_def verify_def split_def)"], ["proof (state)\nthis:\n  abstract_com.correct_game m =\n  key_gen \\<bind>\n  (\\<lambda>(ck, vk1, vk2).\n      S ck m \\<bind> (\\<lambda>(a, e, z). return_spmf (check vk1 a m z)))\n\ngoal (1 subgoal):\n 1. abstract_com.correct_game m = return_spmf True", "also"], ["proof (state)\nthis:\n  abstract_com.correct_game m =\n  key_gen \\<bind>\n  (\\<lambda>(ck, vk1, vk2).\n      S ck m \\<bind> (\\<lambda>(a, e, z). return_spmf (check vk1 a m z)))\n\ngoal (1 subgoal):\n 1. abstract_com.correct_game m = return_spmf True", "have \"... = do { \n      (x,w) \\<leftarrow> G;\n      let (ck, (vk1,vk2)) = (x,(x,w));\n      (a,e,z) \\<leftarrow> S ck m;\n      return_spmf (check vk1 a m z)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. key_gen \\<bind>\n    (\\<lambda>(ck, vk1, vk2).\n        S ck m \\<bind>\n        (\\<lambda>(a, e, z). return_spmf (check vk1 a m z))) =\n    G \\<bind>\n    (\\<lambda>(x, w).\n        let (ck, vk1, vk2) = (x, x, w)\n        in S ck m \\<bind>\n           (\\<lambda>(a, e, z). return_spmf (check vk1 a m z)))", "by(simp add: key_gen_def split_def)"], ["proof (state)\nthis:\n  key_gen \\<bind>\n  (\\<lambda>(ck, vk1, vk2).\n      S ck m \\<bind> (\\<lambda>(a, e, z). return_spmf (check vk1 a m z))) =\n  G \\<bind>\n  (\\<lambda>(x, w).\n      let (ck, vk1, vk2) = (x, x, w)\n      in S ck m \\<bind> (\\<lambda>(a, e, z). return_spmf (check vk1 a m z)))\n\ngoal (1 subgoal):\n 1. abstract_com.correct_game m = return_spmf True", "also"], ["proof (state)\nthis:\n  key_gen \\<bind>\n  (\\<lambda>(ck, vk1, vk2).\n      S ck m \\<bind> (\\<lambda>(a, e, z). return_spmf (check vk1 a m z))) =\n  G \\<bind>\n  (\\<lambda>(x, w).\n      let (ck, vk1, vk2) = (x, x, w)\n      in S ck m \\<bind> (\\<lambda>(a, e, z). return_spmf (check vk1 a m z)))\n\ngoal (1 subgoal):\n 1. abstract_com.correct_game m = return_spmf True", "have \"... = do {\n      (x,w) \\<leftarrow> G;\n      (a,e,z) \\<leftarrow> S x m;\n      return_spmf (check x a m z)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. G \\<bind>\n    (\\<lambda>(x, w).\n        let (ck, vk1, vk2) = (x, x, w)\n        in S ck m \\<bind>\n           (\\<lambda>(a, e, z). return_spmf (check vk1 a m z))) =\n    G \\<bind>\n    (\\<lambda>(x, w).\n        S x m \\<bind> (\\<lambda>(a, e, z). return_spmf (check x a m z)))", "by(simp add: Let_def)"], ["proof (state)\nthis:\n  G \\<bind>\n  (\\<lambda>(x, w).\n      let (ck, vk1, vk2) = (x, x, w)\n      in S ck m \\<bind>\n         (\\<lambda>(a, e, z). return_spmf (check vk1 a m z))) =\n  G \\<bind>\n  (\\<lambda>(x, w).\n      S x m \\<bind> (\\<lambda>(a, e, z). return_spmf (check x a m z)))\n\ngoal (1 subgoal):\n 1. abstract_com.correct_game m = return_spmf True", "also"], ["proof (state)\nthis:\n  G \\<bind>\n  (\\<lambda>(x, w).\n      let (ck, vk1, vk2) = (x, x, w)\n      in S ck m \\<bind>\n         (\\<lambda>(a, e, z). return_spmf (check vk1 a m z))) =\n  G \\<bind>\n  (\\<lambda>(x, w).\n      S x m \\<bind> (\\<lambda>(a, e, z). return_spmf (check x a m z)))\n\ngoal (1 subgoal):\n 1. abstract_com.correct_game m = return_spmf True", "have \"... = do {\n      (x,w) \\<leftarrow> G;\n      (a, e,z) \\<leftarrow> R x w m;\n      return_spmf (check x a m z)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. G \\<bind>\n    (\\<lambda>(x, w).\n        S x m \\<bind> (\\<lambda>(a, e, z). return_spmf (check x a m z))) =\n    G \\<bind>\n    (\\<lambda>(x, w).\n        R x w m \\<bind> (\\<lambda>(a, e, z). return_spmf (check x a m z)))", "using \\<Sigma>_prot HVZK_unfold1 m"], ["proof (prove)\nusing this:\n  \\<Sigma>_protocol\n  \\<Sigma>_protocol \\<Longrightarrow>\n  \\<forall>h w e.\n     (h, w) \\<in> Rel \\<longrightarrow>\n     e \\<in> challenge_space \\<longrightarrow> R h w e = S h e\n  m \\<in> challenge_space\n\ngoal (1 subgoal):\n 1. G \\<bind>\n    (\\<lambda>(x, w).\n        S x m \\<bind> (\\<lambda>(a, e, z). return_spmf (check x a m z))) =\n    G \\<bind>\n    (\\<lambda>(x, w).\n        R x w m \\<bind> (\\<lambda>(a, e, z). return_spmf (check x a m z)))", "by(intro bind_spmf_cong bind_spmf_cong[OF refl]; clarsimp?)"], ["proof (state)\nthis:\n  G \\<bind>\n  (\\<lambda>(x, w).\n      S x m \\<bind> (\\<lambda>(a, e, z). return_spmf (check x a m z))) =\n  G \\<bind>\n  (\\<lambda>(x, w).\n      R x w m \\<bind> (\\<lambda>(a, e, z). return_spmf (check x a m z)))\n\ngoal (1 subgoal):\n 1. abstract_com.correct_game m = return_spmf True", "also"], ["proof (state)\nthis:\n  G \\<bind>\n  (\\<lambda>(x, w).\n      S x m \\<bind> (\\<lambda>(a, e, z). return_spmf (check x a m z))) =\n  G \\<bind>\n  (\\<lambda>(x, w).\n      R x w m \\<bind> (\\<lambda>(a, e, z). return_spmf (check x a m z)))\n\ngoal (1 subgoal):\n 1. abstract_com.correct_game m = return_spmf True", "have \"... = do {\n      (x,w) \\<leftarrow> G;\n      (r, a) \\<leftarrow> init x w;\n      z \\<leftarrow> response r w m;\n      return_spmf (check x a m z)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. G \\<bind>\n    (\\<lambda>(x, w).\n        R x w m \\<bind> (\\<lambda>(a, e, z). return_spmf (check x a m z))) =\n    G \\<bind>\n    (\\<lambda>(x, w).\n        init x w \\<bind>\n        (\\<lambda>(r, a).\n            response r w m \\<bind>\n            (\\<lambda>z. return_spmf (check x a m z))))", "by(simp add: R_def split_def)"], ["proof (state)\nthis:\n  G \\<bind>\n  (\\<lambda>(x, w).\n      R x w m \\<bind> (\\<lambda>(a, e, z). return_spmf (check x a m z))) =\n  G \\<bind>\n  (\\<lambda>(x, w).\n      init x w \\<bind>\n      (\\<lambda>(r, a).\n          response r w m \\<bind> (\\<lambda>z. return_spmf (check x a m z))))\n\ngoal (1 subgoal):\n 1. abstract_com.correct_game m = return_spmf True", "also"], ["proof (state)\nthis:\n  G \\<bind>\n  (\\<lambda>(x, w).\n      R x w m \\<bind> (\\<lambda>(a, e, z). return_spmf (check x a m z))) =\n  G \\<bind>\n  (\\<lambda>(x, w).\n      init x w \\<bind>\n      (\\<lambda>(r, a).\n          response r w m \\<bind> (\\<lambda>z. return_spmf (check x a m z))))\n\ngoal (1 subgoal):\n 1. abstract_com.correct_game m = return_spmf True", "have \"... = do {\n      (x,w) \\<leftarrow> G;\n      return_spmf True}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. G \\<bind>\n    (\\<lambda>(x, w).\n        init x w \\<bind>\n        (\\<lambda>(r, a).\n            response r w m \\<bind>\n            (\\<lambda>z. return_spmf (check x a m z)))) =\n    G \\<bind> (\\<lambda>(x, w). return_spmf True)", "apply(intro bind_spmf_cong bind_spmf_cong[OF refl]; clarsimp?)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) \\<in> set_spmf G \\<Longrightarrow>\n       init a b \\<bind>\n       (\\<lambda>(r, aa).\n           response r b m \\<bind>\n           (\\<lambda>z. return_spmf (check a aa m z))) =\n       return_spmf True", "using complete_game_return_true lossless_init lossless_response \\<Sigma>_prot \\<Sigma>_protocol_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>(?h, ?w) \\<in> Rel; completeness;\n   \\<forall>h w. lossless_spmf (init h w);\n   \\<forall>r w e. lossless_spmf (response r w e);\n   ?e \\<in> challenge_space\\<rbrakk>\n  \\<Longrightarrow> completeness_game ?h ?w ?e = return_spmf True\n  lossless_spmf (init ?h ?w)\n  lossless_spmf (response ?r ?w ?e)\n  \\<Sigma>_protocol\n  \\<Sigma>_protocol \\<equiv>\n  completeness \\<and> special_soundness \\<and> HVZK\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) \\<in> set_spmf G \\<Longrightarrow>\n       init a b \\<bind>\n       (\\<lambda>(r, aa).\n           response r b m \\<bind>\n           (\\<lambda>z. return_spmf (check a aa m z))) =\n       return_spmf True", "by(simp add: split_def completeness_game_def \\<Sigma>_protocols_base.\\<Sigma>_protocol_def m cong: bind_spmf_cong_simp)"], ["proof (state)\nthis:\n  G \\<bind>\n  (\\<lambda>(x, w).\n      init x w \\<bind>\n      (\\<lambda>(r, a).\n          response r w m \\<bind>\n          (\\<lambda>z. return_spmf (check x a m z)))) =\n  G \\<bind> (\\<lambda>(x, w). return_spmf True)\n\ngoal (1 subgoal):\n 1. abstract_com.correct_game m = return_spmf True", "ultimately"], ["proof (chain)\npicking this:\n  abstract_com.correct_game m =\n  G \\<bind>\n  (\\<lambda>(x, w).\n      init x w \\<bind>\n      (\\<lambda>(r, a).\n          response r w m \\<bind> (\\<lambda>z. return_spmf (check x a m z))))\n  G \\<bind>\n  (\\<lambda>(x, w).\n      init x w \\<bind>\n      (\\<lambda>(r, a).\n          response r w m \\<bind>\n          (\\<lambda>z. return_spmf (check x a m z)))) =\n  G \\<bind> (\\<lambda>(x, w). return_spmf True)", "show \"abstract_com.correct_game m = return_spmf True\""], ["proof (prove)\nusing this:\n  abstract_com.correct_game m =\n  G \\<bind>\n  (\\<lambda>(x, w).\n      init x w \\<bind>\n      (\\<lambda>(r, a).\n          response r w m \\<bind> (\\<lambda>z. return_spmf (check x a m z))))\n  G \\<bind>\n  (\\<lambda>(x, w).\n      init x w \\<bind>\n      (\\<lambda>(r, a).\n          response r w m \\<bind>\n          (\\<lambda>z. return_spmf (check x a m z)))) =\n  G \\<bind> (\\<lambda>(x, w). return_spmf True)\n\ngoal (1 subgoal):\n 1. abstract_com.correct_game m = return_spmf True", "by(simp add: bind_spmf_const lossless_G lossless_weight_spmfD split_def)"], ["proof (state)\nthis:\n  abstract_com.correct_game m = return_spmf True\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  abstract_com.correct_game m = return_spmf True\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>m\\<in>challenge_space.\n     abstract_com.correct_game m = return_spmf True\n\ngoal (1 subgoal):\n 1. abstract_com.correct", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>m\\<in>challenge_space.\n     abstract_com.correct_game m = return_spmf True\n\ngoal (1 subgoal):\n 1. abstract_com.correct", "using abstract_com.correct_def abstract_com.valid_msg_set_def valid_msg_def"], ["proof (prove)\nusing this:\n  \\<forall>m\\<in>challenge_space.\n     abstract_com.correct_game m = return_spmf True\n  abstract_com.correct \\<equiv>\n  \\<forall>m.\n     valid_msg m \\<longrightarrow>\n     spmf (abstract_com.correct_game m) True = 1\n  abstract_com.valid_msg_set = Collect valid_msg\n  valid_msg ?m = (?m \\<in> challenge_space)\n\ngoal (1 subgoal):\n 1. abstract_com.correct", "by simp"], ["proof (state)\nthis:\n  abstract_com.correct\n\ngoal:\nNo subgoals!", "qed"], ["", "paragraph\\<open>The hiding property\\<close>"], ["", "text\\<open>We first show we have perfect hiding with respect to the hiding game that allows the adversary to choose\nthe messages that are committed to, this is akin to the ind-cpa game for encryption schemes.\\<close>"], ["", "lemma perfect_hiding:\n  shows \"abstract_com.perfect_hiding_ind_cpa \\<A>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. abstract_com.perfect_hiding_ind_cpa \\<A>", "including monad_normalisation"], ["proof (prove)\ngoal (1 subgoal):\n 1. abstract_com.perfect_hiding_ind_cpa \\<A>", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. abstract_com.perfect_hiding_ind_cpa \\<A>", "obtain \\<A>1 \\<A>2 where [simp]: \"\\<A> = (\\<A>1, \\<A>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>\\<A>1 \\<A>2.\n        \\<A> = (\\<A>1, \\<A>2) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases \\<A>)"], ["proof (state)\nthis:\n  \\<A> = (\\<A>1, \\<A>2)\n\ngoal (1 subgoal):\n 1. abstract_com.perfect_hiding_ind_cpa \\<A>", "have \"abstract_com.hiding_game_ind_cpa (\\<A>1, \\<A>2) = TRY do {\n    (x,w) \\<leftarrow> G;\n    ((m0, m1), \\<sigma>) \\<leftarrow> \\<A>1 (x,w);\n    _ :: unit \\<leftarrow> assert_spmf (valid_msg m0 \\<and> valid_msg m1);\n    b \\<leftarrow> coin_spmf; \n    (a,e,z) \\<leftarrow> S x (if b then m0 else m1);\n    b' \\<leftarrow> \\<A>2 a \\<sigma>;\n    return_spmf (b' = b)} ELSE coin_spmf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. abstract_com.hiding_game_ind_cpa (\\<A>1, \\<A>2) =\n    TRY G \\<bind>\n        (\\<lambda>(x, w).\n            \\<A>1 (x, w) \\<bind>\n            (\\<lambda>((m0, m1), \\<sigma>).\n                assert_spmf (valid_msg m0 \\<and> valid_msg m1) \\<bind>\n                (\\<lambda>_.\n                    coin_spmf \\<bind>\n                    (\\<lambda>b.\n                        S x (if b then m0 else m1) \\<bind>\n                        (\\<lambda>(a, e, z).\n                            \\<A>2 a \\<sigma> \\<bind>\n                            (\\<lambda>b'.\n                                return_spmf (b' = b))))))) ELSE coin_spmf", "by(simp add: abstract_com.hiding_game_ind_cpa_def commit_def; simp add: key_gen_def split_def)"], ["proof (state)\nthis:\n  abstract_com.hiding_game_ind_cpa (\\<A>1, \\<A>2) =\n  TRY G \\<bind>\n      (\\<lambda>(x, w).\n          \\<A>1 (x, w) \\<bind>\n          (\\<lambda>((m0, m1), \\<sigma>).\n              assert_spmf (valid_msg m0 \\<and> valid_msg m1) \\<bind>\n              (\\<lambda>_.\n                  coin_spmf \\<bind>\n                  (\\<lambda>b.\n                      S x (if b then m0 else m1) \\<bind>\n                      (\\<lambda>(a, e, z).\n                          \\<A>2 a \\<sigma> \\<bind>\n                          (\\<lambda>b'.\n                              return_spmf (b' = b))))))) ELSE coin_spmf\n\ngoal (1 subgoal):\n 1. abstract_com.perfect_hiding_ind_cpa \\<A>", "also"], ["proof (state)\nthis:\n  abstract_com.hiding_game_ind_cpa (\\<A>1, \\<A>2) =\n  TRY G \\<bind>\n      (\\<lambda>(x, w).\n          \\<A>1 (x, w) \\<bind>\n          (\\<lambda>((m0, m1), \\<sigma>).\n              assert_spmf (valid_msg m0 \\<and> valid_msg m1) \\<bind>\n              (\\<lambda>_.\n                  coin_spmf \\<bind>\n                  (\\<lambda>b.\n                      S x (if b then m0 else m1) \\<bind>\n                      (\\<lambda>(a, e, z).\n                          \\<A>2 a \\<sigma> \\<bind>\n                          (\\<lambda>b'.\n                              return_spmf (b' = b))))))) ELSE coin_spmf\n\ngoal (1 subgoal):\n 1. abstract_com.perfect_hiding_ind_cpa \\<A>", "have \"... = TRY do {\n    (x,w) \\<leftarrow> G;\n    ((m0, m1), \\<sigma>) \\<leftarrow> \\<A>1 (x,w);\n    _ :: unit \\<leftarrow> assert_spmf (valid_msg m0 \\<and> valid_msg m1);\n    b :: bool \\<leftarrow> coin_spmf; \n    (a,e,z) \\<leftarrow> R x w (if b then m0 else m1);\n    b' :: bool \\<leftarrow> \\<A>2 a \\<sigma>;\n    return_spmf (b' = b)} ELSE coin_spmf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. TRY G \\<bind>\n        (\\<lambda>(x, w).\n            \\<A>1 (x, w) \\<bind>\n            (\\<lambda>((m0, m1), \\<sigma>).\n                assert_spmf (valid_msg m0 \\<and> valid_msg m1) \\<bind>\n                (\\<lambda>_.\n                    coin_spmf \\<bind>\n                    (\\<lambda>b.\n                        S x (if b then m0 else m1) \\<bind>\n                        (\\<lambda>(a, e, z).\n                            \\<A>2 a \\<sigma> \\<bind>\n                            (\\<lambda>b'.\n                                return_spmf (b' = b))))))) ELSE coin_spmf =\n    TRY G \\<bind>\n        (\\<lambda>(x, w).\n            \\<A>1 (x, w) \\<bind>\n            (\\<lambda>((m0, m1), \\<sigma>).\n                assert_spmf (valid_msg m0 \\<and> valid_msg m1) \\<bind>\n                (\\<lambda>_.\n                    coin_spmf \\<bind>\n                    (\\<lambda>b.\n                        R x w (if b then m0 else m1) \\<bind>\n                        (\\<lambda>(a, e, z).\n                            \\<A>2 a \\<sigma> \\<bind>\n                            (\\<lambda>b'.\n                                return_spmf (b' = b))))))) ELSE coin_spmf", "apply(intro try_spmf_cong bind_spmf_cong[OF refl]; clarsimp?)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba bb x.\n       \\<lbrakk>(a, b) \\<in> set_spmf G;\n        ((aa, ba), bb) \\<in> set_spmf (\\<A>1 (a, b)); valid_msg aa;\n        valid_msg ba\\<rbrakk>\n       \\<Longrightarrow> (x \\<longrightarrow>\n                          S a aa \\<bind> (\\<lambda>(a, e, z). \\<A>2 a bb) =\n                          R a b aa \\<bind>\n                          (\\<lambda>(a, e, z). \\<A>2 a bb)) \\<and>\n                         (\\<not> x \\<longrightarrow>\n                          S a ba \\<bind>\n                          (\\<lambda>(a, e, z).\n                              \\<A>2 a bb \\<bind>\n                              (\\<lambda>b'. return_spmf (\\<not> b'))) =\n                          R a b ba \\<bind>\n                          (\\<lambda>(a, e, z).\n                              \\<A>2 a bb \\<bind>\n                              (\\<lambda>b'. return_spmf (\\<not> b'))))", "by(simp add: \\<Sigma>_prot  HVZK_unfold1 valid_msg_def)"], ["proof (state)\nthis:\n  TRY G \\<bind>\n      (\\<lambda>(x, w).\n          \\<A>1 (x, w) \\<bind>\n          (\\<lambda>((m0, m1), \\<sigma>).\n              assert_spmf (valid_msg m0 \\<and> valid_msg m1) \\<bind>\n              (\\<lambda>_.\n                  coin_spmf \\<bind>\n                  (\\<lambda>b.\n                      S x (if b then m0 else m1) \\<bind>\n                      (\\<lambda>(a, e, z).\n                          \\<A>2 a \\<sigma> \\<bind>\n                          (\\<lambda>b'.\n                              return_spmf (b' = b))))))) ELSE coin_spmf =\n  TRY G \\<bind>\n      (\\<lambda>(x, w).\n          \\<A>1 (x, w) \\<bind>\n          (\\<lambda>((m0, m1), \\<sigma>).\n              assert_spmf (valid_msg m0 \\<and> valid_msg m1) \\<bind>\n              (\\<lambda>_.\n                  coin_spmf \\<bind>\n                  (\\<lambda>b.\n                      R x w (if b then m0 else m1) \\<bind>\n                      (\\<lambda>(a, e, z).\n                          \\<A>2 a \\<sigma> \\<bind>\n                          (\\<lambda>b'.\n                              return_spmf (b' = b))))))) ELSE coin_spmf\n\ngoal (1 subgoal):\n 1. abstract_com.perfect_hiding_ind_cpa \\<A>", "also"], ["proof (state)\nthis:\n  TRY G \\<bind>\n      (\\<lambda>(x, w).\n          \\<A>1 (x, w) \\<bind>\n          (\\<lambda>((m0, m1), \\<sigma>).\n              assert_spmf (valid_msg m0 \\<and> valid_msg m1) \\<bind>\n              (\\<lambda>_.\n                  coin_spmf \\<bind>\n                  (\\<lambda>b.\n                      S x (if b then m0 else m1) \\<bind>\n                      (\\<lambda>(a, e, z).\n                          \\<A>2 a \\<sigma> \\<bind>\n                          (\\<lambda>b'.\n                              return_spmf (b' = b))))))) ELSE coin_spmf =\n  TRY G \\<bind>\n      (\\<lambda>(x, w).\n          \\<A>1 (x, w) \\<bind>\n          (\\<lambda>((m0, m1), \\<sigma>).\n              assert_spmf (valid_msg m0 \\<and> valid_msg m1) \\<bind>\n              (\\<lambda>_.\n                  coin_spmf \\<bind>\n                  (\\<lambda>b.\n                      R x w (if b then m0 else m1) \\<bind>\n                      (\\<lambda>(a, e, z).\n                          \\<A>2 a \\<sigma> \\<bind>\n                          (\\<lambda>b'.\n                              return_spmf (b' = b))))))) ELSE coin_spmf\n\ngoal (1 subgoal):\n 1. abstract_com.perfect_hiding_ind_cpa \\<A>", "have \"... = TRY do {\n    (x,w) \\<leftarrow> G;\n    ((m0, m1), \\<sigma>) \\<leftarrow> \\<A>1 (x,w);\n    _ :: unit \\<leftarrow> assert_spmf (valid_msg m0 \\<and> valid_msg m1);\n    b \\<leftarrow> coin_spmf; \n    (r,a) \\<leftarrow> init x w;\n    z :: 'response \\<leftarrow> response r w (if b then m0 else m1);\n    guess :: bool \\<leftarrow> \\<A>2 a \\<sigma>;\n    return_spmf(guess = b)} ELSE coin_spmf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. TRY G \\<bind>\n        (\\<lambda>(x, w).\n            \\<A>1 (x, w) \\<bind>\n            (\\<lambda>((m0, m1), \\<sigma>).\n                assert_spmf (valid_msg m0 \\<and> valid_msg m1) \\<bind>\n                (\\<lambda>_.\n                    coin_spmf \\<bind>\n                    (\\<lambda>b.\n                        R x w (if b then m0 else m1) \\<bind>\n                        (\\<lambda>(a, e, z).\n                            \\<A>2 a \\<sigma> \\<bind>\n                            (\\<lambda>b'.\n                                return_spmf (b' = b))))))) ELSE coin_spmf =\n    TRY G \\<bind>\n        (\\<lambda>(x, w).\n            \\<A>1 (x, w) \\<bind>\n            (\\<lambda>((m0, m1), \\<sigma>).\n                assert_spmf (valid_msg m0 \\<and> valid_msg m1) \\<bind>\n                (\\<lambda>_.\n                    coin_spmf \\<bind>\n                    (\\<lambda>b.\n                        init x w \\<bind>\n                        (\\<lambda>(r, a).\n                            response r w (if b then m0 else m1) \\<bind>\n                            (\\<lambda>z.\n                                \\<A>2 a \\<sigma> \\<bind>\n                                (\\<lambda>guess.\n                                    return_spmf\n                                     (guess = b)))))))) ELSE coin_spmf", "using \\<Sigma>_protocols_base.R_def"], ["proof (prove)\nusing this:\n  \\<Sigma>_protocols_base ?Rel ?valid_pub \\<Longrightarrow>\n  \\<Sigma>_protocols_base.R ?init ?response ?h ?w ?e =\n  ?init ?h ?w \\<bind>\n  (\\<lambda>(r, a).\n      ?response r ?w ?e \\<bind> (\\<lambda>z. return_spmf (a, ?e, z)))\n\ngoal (1 subgoal):\n 1. TRY G \\<bind>\n        (\\<lambda>(x, w).\n            \\<A>1 (x, w) \\<bind>\n            (\\<lambda>((m0, m1), \\<sigma>).\n                assert_spmf (valid_msg m0 \\<and> valid_msg m1) \\<bind>\n                (\\<lambda>_.\n                    coin_spmf \\<bind>\n                    (\\<lambda>b.\n                        R x w (if b then m0 else m1) \\<bind>\n                        (\\<lambda>(a, e, z).\n                            \\<A>2 a \\<sigma> \\<bind>\n                            (\\<lambda>b'.\n                                return_spmf (b' = b))))))) ELSE coin_spmf =\n    TRY G \\<bind>\n        (\\<lambda>(x, w).\n            \\<A>1 (x, w) \\<bind>\n            (\\<lambda>((m0, m1), \\<sigma>).\n                assert_spmf (valid_msg m0 \\<and> valid_msg m1) \\<bind>\n                (\\<lambda>_.\n                    coin_spmf \\<bind>\n                    (\\<lambda>b.\n                        init x w \\<bind>\n                        (\\<lambda>(r, a).\n                            response r w (if b then m0 else m1) \\<bind>\n                            (\\<lambda>z.\n                                \\<A>2 a \\<sigma> \\<bind>\n                                (\\<lambda>guess.\n                                    return_spmf\n                                     (guess = b)))))))) ELSE coin_spmf", "by(simp add: bind_map_spmf o_def R_def split_def)"], ["proof (state)\nthis:\n  TRY G \\<bind>\n      (\\<lambda>(x, w).\n          \\<A>1 (x, w) \\<bind>\n          (\\<lambda>((m0, m1), \\<sigma>).\n              assert_spmf (valid_msg m0 \\<and> valid_msg m1) \\<bind>\n              (\\<lambda>_.\n                  coin_spmf \\<bind>\n                  (\\<lambda>b.\n                      R x w (if b then m0 else m1) \\<bind>\n                      (\\<lambda>(a, e, z).\n                          \\<A>2 a \\<sigma> \\<bind>\n                          (\\<lambda>b'.\n                              return_spmf (b' = b))))))) ELSE coin_spmf =\n  TRY G \\<bind>\n      (\\<lambda>(x, w).\n          \\<A>1 (x, w) \\<bind>\n          (\\<lambda>((m0, m1), \\<sigma>).\n              assert_spmf (valid_msg m0 \\<and> valid_msg m1) \\<bind>\n              (\\<lambda>_.\n                  coin_spmf \\<bind>\n                  (\\<lambda>b.\n                      init x w \\<bind>\n                      (\\<lambda>(r, a).\n                          response r w (if b then m0 else m1) \\<bind>\n                          (\\<lambda>z.\n                              \\<A>2 a \\<sigma> \\<bind>\n                              (\\<lambda>guess.\n                                  return_spmf\n                                   (guess = b)))))))) ELSE coin_spmf\n\ngoal (1 subgoal):\n 1. abstract_com.perfect_hiding_ind_cpa \\<A>", "also"], ["proof (state)\nthis:\n  TRY G \\<bind>\n      (\\<lambda>(x, w).\n          \\<A>1 (x, w) \\<bind>\n          (\\<lambda>((m0, m1), \\<sigma>).\n              assert_spmf (valid_msg m0 \\<and> valid_msg m1) \\<bind>\n              (\\<lambda>_.\n                  coin_spmf \\<bind>\n                  (\\<lambda>b.\n                      R x w (if b then m0 else m1) \\<bind>\n                      (\\<lambda>(a, e, z).\n                          \\<A>2 a \\<sigma> \\<bind>\n                          (\\<lambda>b'.\n                              return_spmf (b' = b))))))) ELSE coin_spmf =\n  TRY G \\<bind>\n      (\\<lambda>(x, w).\n          \\<A>1 (x, w) \\<bind>\n          (\\<lambda>((m0, m1), \\<sigma>).\n              assert_spmf (valid_msg m0 \\<and> valid_msg m1) \\<bind>\n              (\\<lambda>_.\n                  coin_spmf \\<bind>\n                  (\\<lambda>b.\n                      init x w \\<bind>\n                      (\\<lambda>(r, a).\n                          response r w (if b then m0 else m1) \\<bind>\n                          (\\<lambda>z.\n                              \\<A>2 a \\<sigma> \\<bind>\n                              (\\<lambda>guess.\n                                  return_spmf\n                                   (guess = b)))))))) ELSE coin_spmf\n\ngoal (1 subgoal):\n 1. abstract_com.perfect_hiding_ind_cpa \\<A>", "have  \"... = TRY do {\n    (x,w) \\<leftarrow> G;\n    ((m0, m1), \\<sigma>) \\<leftarrow> \\<A>1 (x,w);\n    _ :: unit \\<leftarrow> assert_spmf (valid_msg m0 \\<and> valid_msg m1);\n    b \\<leftarrow> coin_spmf; \n    (r,a) \\<leftarrow> init x w;\n    guess :: bool \\<leftarrow> \\<A>2 a \\<sigma>;\n    return_spmf(guess = b)} ELSE coin_spmf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. TRY G \\<bind>\n        (\\<lambda>(x, w).\n            \\<A>1 (x, w) \\<bind>\n            (\\<lambda>((m0, m1), \\<sigma>).\n                assert_spmf (valid_msg m0 \\<and> valid_msg m1) \\<bind>\n                (\\<lambda>_.\n                    coin_spmf \\<bind>\n                    (\\<lambda>b.\n                        init x w \\<bind>\n                        (\\<lambda>(r, a).\n                            response r w (if b then m0 else m1) \\<bind>\n                            (\\<lambda>z.\n                                \\<A>2 a \\<sigma> \\<bind>\n                                (\\<lambda>guess.\n                                    return_spmf\n                                     (guess = b)))))))) ELSE coin_spmf =\n    TRY G \\<bind>\n        (\\<lambda>(x, w).\n            \\<A>1 (x, w) \\<bind>\n            (\\<lambda>((m0, m1), \\<sigma>).\n                assert_spmf (valid_msg m0 \\<and> valid_msg m1) \\<bind>\n                (\\<lambda>_.\n                    coin_spmf \\<bind>\n                    (\\<lambda>b.\n                        init x w \\<bind>\n                        (\\<lambda>(r, a).\n                            \\<A>2 a \\<sigma> \\<bind>\n                            (\\<lambda>guess.\n                                return_spmf (guess = b))))))) ELSE coin_spmf", "by(simp add: bind_spmf_const lossless_response lossless_weight_spmfD)"], ["proof (state)\nthis:\n  TRY G \\<bind>\n      (\\<lambda>(x, w).\n          \\<A>1 (x, w) \\<bind>\n          (\\<lambda>((m0, m1), \\<sigma>).\n              assert_spmf (valid_msg m0 \\<and> valid_msg m1) \\<bind>\n              (\\<lambda>_.\n                  coin_spmf \\<bind>\n                  (\\<lambda>b.\n                      init x w \\<bind>\n                      (\\<lambda>(r, a).\n                          response r w (if b then m0 else m1) \\<bind>\n                          (\\<lambda>z.\n                              \\<A>2 a \\<sigma> \\<bind>\n                              (\\<lambda>guess.\n                                  return_spmf\n                                   (guess = b)))))))) ELSE coin_spmf =\n  TRY G \\<bind>\n      (\\<lambda>(x, w).\n          \\<A>1 (x, w) \\<bind>\n          (\\<lambda>((m0, m1), \\<sigma>).\n              assert_spmf (valid_msg m0 \\<and> valid_msg m1) \\<bind>\n              (\\<lambda>_.\n                  coin_spmf \\<bind>\n                  (\\<lambda>b.\n                      init x w \\<bind>\n                      (\\<lambda>(r, a).\n                          \\<A>2 a \\<sigma> \\<bind>\n                          (\\<lambda>guess.\n                              return_spmf (guess = b))))))) ELSE coin_spmf\n\ngoal (1 subgoal):\n 1. abstract_com.perfect_hiding_ind_cpa \\<A>", "also"], ["proof (state)\nthis:\n  TRY G \\<bind>\n      (\\<lambda>(x, w).\n          \\<A>1 (x, w) \\<bind>\n          (\\<lambda>((m0, m1), \\<sigma>).\n              assert_spmf (valid_msg m0 \\<and> valid_msg m1) \\<bind>\n              (\\<lambda>_.\n                  coin_spmf \\<bind>\n                  (\\<lambda>b.\n                      init x w \\<bind>\n                      (\\<lambda>(r, a).\n                          response r w (if b then m0 else m1) \\<bind>\n                          (\\<lambda>z.\n                              \\<A>2 a \\<sigma> \\<bind>\n                              (\\<lambda>guess.\n                                  return_spmf\n                                   (guess = b)))))))) ELSE coin_spmf =\n  TRY G \\<bind>\n      (\\<lambda>(x, w).\n          \\<A>1 (x, w) \\<bind>\n          (\\<lambda>((m0, m1), \\<sigma>).\n              assert_spmf (valid_msg m0 \\<and> valid_msg m1) \\<bind>\n              (\\<lambda>_.\n                  coin_spmf \\<bind>\n                  (\\<lambda>b.\n                      init x w \\<bind>\n                      (\\<lambda>(r, a).\n                          \\<A>2 a \\<sigma> \\<bind>\n                          (\\<lambda>guess.\n                              return_spmf (guess = b))))))) ELSE coin_spmf\n\ngoal (1 subgoal):\n 1. abstract_com.perfect_hiding_ind_cpa \\<A>", "have  \"... = TRY do {\n    (x,w) \\<leftarrow> G;\n    ((m0, m1), \\<sigma>) \\<leftarrow> \\<A>1 (x,w);\n    _ :: unit \\<leftarrow> assert_spmf (valid_msg m0 \\<and> valid_msg m1);\n    (r,a) \\<leftarrow> init x w;\n    guess :: bool \\<leftarrow> \\<A>2 a \\<sigma>;\n    map_spmf( (=) guess) coin_spmf} ELSE coin_spmf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. TRY G \\<bind>\n        (\\<lambda>(x, w).\n            \\<A>1 (x, w) \\<bind>\n            (\\<lambda>((m0, m1), \\<sigma>).\n                assert_spmf (valid_msg m0 \\<and> valid_msg m1) \\<bind>\n                (\\<lambda>_.\n                    coin_spmf \\<bind>\n                    (\\<lambda>b.\n                        init x w \\<bind>\n                        (\\<lambda>(r, a).\n                            \\<A>2 a \\<sigma> \\<bind>\n                            (\\<lambda>guess.\n                                return_spmf\n                                 (guess = b))))))) ELSE coin_spmf =\n    TRY G \\<bind>\n        (\\<lambda>(x, w).\n            \\<A>1 (x, w) \\<bind>\n            (\\<lambda>((m0, m1), \\<sigma>).\n                assert_spmf (valid_msg m0 \\<and> valid_msg m1) \\<bind>\n                (\\<lambda>_.\n                    init x w \\<bind>\n                    (\\<lambda>(r, a).\n                        \\<A>2 a \\<sigma> \\<bind>\n                        (\\<lambda>guess.\n                            map_spmf ((=) guess)\n                             coin_spmf))))) ELSE coin_spmf", "apply(simp add: map_spmf_conv_bind_spmf)"], ["proof (prove)\ngoal (1 subgoal):\n 1. TRY G \\<bind>\n        (\\<lambda>(x, w).\n            \\<A>1 (x, w) \\<bind>\n            (\\<lambda>((m0, m1), \\<sigma>).\n                coin_spmf \\<bind>\n                (\\<lambda>b.\n                    assert_spmf (valid_msg m0 \\<and> valid_msg m1) \\<bind>\n                    (\\<lambda>_.\n                        init x w \\<bind>\n                        (\\<lambda>(r, a).\n                            \\<A>2 a \\<sigma> \\<bind>\n                            (\\<lambda>guess.\n                                return_spmf\n                                 (guess = b))))))) ELSE coin_spmf =\n    TRY G \\<bind>\n        (\\<lambda>(x, w).\n            \\<A>1 (x, w) \\<bind>\n            (\\<lambda>((m0, m1), \\<sigma>).\n                assert_spmf (valid_msg m0 \\<and> valid_msg m1) \\<bind>\n                (\\<lambda>_.\n                    init x w \\<bind>\n                    (\\<lambda>(r, a).\n                        coin_spmf \\<bind>\n                        (\\<lambda>x.\n                            \\<A>2 a \\<sigma> \\<bind>\n                            (\\<lambda>guess.\n                                return_spmf (guess = x))))))) ELSE coin_spmf", "by(simp add: split_def)"], ["proof (state)\nthis:\n  TRY G \\<bind>\n      (\\<lambda>(x, w).\n          \\<A>1 (x, w) \\<bind>\n          (\\<lambda>((m0, m1), \\<sigma>).\n              assert_spmf (valid_msg m0 \\<and> valid_msg m1) \\<bind>\n              (\\<lambda>_.\n                  coin_spmf \\<bind>\n                  (\\<lambda>b.\n                      init x w \\<bind>\n                      (\\<lambda>(r, a).\n                          \\<A>2 a \\<sigma> \\<bind>\n                          (\\<lambda>guess.\n                              return_spmf (guess = b))))))) ELSE coin_spmf =\n  TRY G \\<bind>\n      (\\<lambda>(x, w).\n          \\<A>1 (x, w) \\<bind>\n          (\\<lambda>((m0, m1), \\<sigma>).\n              assert_spmf (valid_msg m0 \\<and> valid_msg m1) \\<bind>\n              (\\<lambda>_.\n                  init x w \\<bind>\n                  (\\<lambda>(r, a).\n                      \\<A>2 a \\<sigma> \\<bind>\n                      (\\<lambda>guess.\n                          map_spmf ((=) guess) coin_spmf))))) ELSE coin_spmf\n\ngoal (1 subgoal):\n 1. abstract_com.perfect_hiding_ind_cpa \\<A>", "also"], ["proof (state)\nthis:\n  TRY G \\<bind>\n      (\\<lambda>(x, w).\n          \\<A>1 (x, w) \\<bind>\n          (\\<lambda>((m0, m1), \\<sigma>).\n              assert_spmf (valid_msg m0 \\<and> valid_msg m1) \\<bind>\n              (\\<lambda>_.\n                  coin_spmf \\<bind>\n                  (\\<lambda>b.\n                      init x w \\<bind>\n                      (\\<lambda>(r, a).\n                          \\<A>2 a \\<sigma> \\<bind>\n                          (\\<lambda>guess.\n                              return_spmf (guess = b))))))) ELSE coin_spmf =\n  TRY G \\<bind>\n      (\\<lambda>(x, w).\n          \\<A>1 (x, w) \\<bind>\n          (\\<lambda>((m0, m1), \\<sigma>).\n              assert_spmf (valid_msg m0 \\<and> valid_msg m1) \\<bind>\n              (\\<lambda>_.\n                  init x w \\<bind>\n                  (\\<lambda>(r, a).\n                      \\<A>2 a \\<sigma> \\<bind>\n                      (\\<lambda>guess.\n                          map_spmf ((=) guess) coin_spmf))))) ELSE coin_spmf\n\ngoal (1 subgoal):\n 1. abstract_com.perfect_hiding_ind_cpa \\<A>", "have \"... = coin_spmf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. TRY G \\<bind>\n        (\\<lambda>(x, w).\n            \\<A>1 (x, w) \\<bind>\n            (\\<lambda>((m0, m1), \\<sigma>).\n                assert_spmf (valid_msg m0 \\<and> valid_msg m1) \\<bind>\n                (\\<lambda>_.\n                    init x w \\<bind>\n                    (\\<lambda>(r, a).\n                        \\<A>2 a \\<sigma> \\<bind>\n                        (\\<lambda>guess.\n                            map_spmf ((=) guess)\n                             coin_spmf))))) ELSE coin_spmf =\n    coin_spmf", "by(auto simp add: map_eq_const_coin_spmf try_bind_spmf_lossless2' Let_def split_def bind_spmf_const scale_bind_spmf weight_spmf_le_1 scale_scale_spmf)"], ["proof (state)\nthis:\n  TRY G \\<bind>\n      (\\<lambda>(x, w).\n          \\<A>1 (x, w) \\<bind>\n          (\\<lambda>((m0, m1), \\<sigma>).\n              assert_spmf (valid_msg m0 \\<and> valid_msg m1) \\<bind>\n              (\\<lambda>_.\n                  init x w \\<bind>\n                  (\\<lambda>(r, a).\n                      \\<A>2 a \\<sigma> \\<bind>\n                      (\\<lambda>guess.\n                          map_spmf ((=) guess)\n                           coin_spmf))))) ELSE coin_spmf =\n  coin_spmf\n\ngoal (1 subgoal):\n 1. abstract_com.perfect_hiding_ind_cpa \\<A>", "ultimately"], ["proof (chain)\npicking this:\n  abstract_com.hiding_game_ind_cpa (\\<A>1, \\<A>2) =\n  TRY G \\<bind>\n      (\\<lambda>(x, w).\n          \\<A>1 (x, w) \\<bind>\n          (\\<lambda>((m0, m1), \\<sigma>).\n              assert_spmf (valid_msg m0 \\<and> valid_msg m1) \\<bind>\n              (\\<lambda>_.\n                  init x w \\<bind>\n                  (\\<lambda>(r, a).\n                      \\<A>2 a \\<sigma> \\<bind>\n                      (\\<lambda>guess.\n                          map_spmf ((=) guess) coin_spmf))))) ELSE coin_spmf\n  TRY G \\<bind>\n      (\\<lambda>(x, w).\n          \\<A>1 (x, w) \\<bind>\n          (\\<lambda>((m0, m1), \\<sigma>).\n              assert_spmf (valid_msg m0 \\<and> valid_msg m1) \\<bind>\n              (\\<lambda>_.\n                  init x w \\<bind>\n                  (\\<lambda>(r, a).\n                      \\<A>2 a \\<sigma> \\<bind>\n                      (\\<lambda>guess.\n                          map_spmf ((=) guess)\n                           coin_spmf))))) ELSE coin_spmf =\n  coin_spmf", "have \"spmf (abstract_com.hiding_game_ind_cpa \\<A>) True = 1/2\""], ["proof (prove)\nusing this:\n  abstract_com.hiding_game_ind_cpa (\\<A>1, \\<A>2) =\n  TRY G \\<bind>\n      (\\<lambda>(x, w).\n          \\<A>1 (x, w) \\<bind>\n          (\\<lambda>((m0, m1), \\<sigma>).\n              assert_spmf (valid_msg m0 \\<and> valid_msg m1) \\<bind>\n              (\\<lambda>_.\n                  init x w \\<bind>\n                  (\\<lambda>(r, a).\n                      \\<A>2 a \\<sigma> \\<bind>\n                      (\\<lambda>guess.\n                          map_spmf ((=) guess) coin_spmf))))) ELSE coin_spmf\n  TRY G \\<bind>\n      (\\<lambda>(x, w).\n          \\<A>1 (x, w) \\<bind>\n          (\\<lambda>((m0, m1), \\<sigma>).\n              assert_spmf (valid_msg m0 \\<and> valid_msg m1) \\<bind>\n              (\\<lambda>_.\n                  init x w \\<bind>\n                  (\\<lambda>(r, a).\n                      \\<A>2 a \\<sigma> \\<bind>\n                      (\\<lambda>guess.\n                          map_spmf ((=) guess)\n                           coin_spmf))))) ELSE coin_spmf =\n  coin_spmf\n\ngoal (1 subgoal):\n 1. spmf (abstract_com.hiding_game_ind_cpa \\<A>) True = 1 / 2", "by(simp add: spmf_of_set)"], ["proof (state)\nthis:\n  spmf (abstract_com.hiding_game_ind_cpa \\<A>) True = 1 / 2\n\ngoal (1 subgoal):\n 1. abstract_com.perfect_hiding_ind_cpa \\<A>", "thus ?thesis"], ["proof (prove)\nusing this:\n  spmf (abstract_com.hiding_game_ind_cpa \\<A>) True = 1 / 2\n\ngoal (1 subgoal):\n 1. abstract_com.perfect_hiding_ind_cpa \\<A>", "by (simp add: abstract_com.perfect_hiding_ind_cpa_def abstract_com.hiding_advantage_ind_cpa_def)"], ["proof (state)\nthis:\n  abstract_com.perfect_hiding_ind_cpa \\<A>\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>We reduce the security of the binding property to the relation advantage. To do this we first construct \nan adversary that interacts with the relation game. This adversary succeeds if the binding adversary succeeds.\\<close>"], ["", "definition adversary :: \"('pub_input \\<Rightarrow> ('msg \\<times> 'challenge \\<times> 'response \\<times> 'challenge \\<times> 'response) spmf) \\<Rightarrow> 'pub_input \\<Rightarrow> 'witness spmf\"\n  where \"adversary \\<A> x = do {\n    (c, e, ez, e', ez') \\<leftarrow> \\<A> x;\n    \\<A>ss x (c,e,ez) (c,e',ez')}\""], ["", "lemma bind_advantage:\n  shows \"abstract_com.bind_advantage \\<A> \\<le> rel_advantage (adversary \\<A>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. abstract_com.bind_advantage \\<A> \\<le> rel_advantage (adversary \\<A>)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. abstract_com.bind_advantage \\<A> \\<le> rel_advantage (adversary \\<A>)", "have \"abstract_com.bind_game \\<A> = TRY do {\n  (x,w) \\<leftarrow> G;\n  (c, m, d, m', d') \\<leftarrow> \\<A> x;\n  _ :: unit \\<leftarrow> assert_spmf (m \\<noteq> m' \\<and> m \\<in> challenge_space \\<and> m' \\<in> challenge_space);\n  let b = check x c m d;\n  let b' = check x c m' d';\n  _ :: unit \\<leftarrow> assert_spmf (b \\<and> b'); \n  w' \\<leftarrow> \\<A>ss x (c,m, d) (c,m', d');\n  return_spmf ((x,w') \\<in> Rel)} ELSE return_spmf False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. abstract_com.bind_game \\<A> =\n    TRY G \\<bind>\n        (\\<lambda>(x, w).\n            \\<A> x \\<bind>\n            (\\<lambda>(c, m, d, m', d').\n                assert_spmf\n                 (m \\<noteq> m' \\<and>\n                  m \\<in> challenge_space \\<and>\n                  m' \\<in> challenge_space) \\<bind>\n                (\\<lambda>_.\n                    let b = check x c m d; b' = check x c m' d'\n                    in assert_spmf (b \\<and> b') \\<bind>\n                       (\\<lambda>_.\n                           \\<A>ss x (c, m, d) (c, m', d') \\<bind>\n                           (\\<lambda>w'.\n                               return_spmf\n                                ((x, w')\n                                 \\<in> Rel)))))) ELSE return_spmf False", "unfolding abstract_com.bind_game_alt_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. TRY key_gen \\<bind>\n        (\\<lambda>(ck, vk).\n            \\<A> ck \\<bind>\n            (\\<lambda>(c, m, d, m', d').\n                assert_spmf\n                 (m \\<noteq> m' \\<and>\n                  valid_msg m \\<and> valid_msg m') \\<bind>\n                (\\<lambda>_.\n                    let b = verify vk m c d; b' = verify vk m' c d'\n                    in assert_spmf (b \\<and> b') \\<bind>\n                       (\\<lambda>_.\n                           return_spmf True)))) ELSE return_spmf False =\n    TRY G \\<bind>\n        (\\<lambda>(x, w).\n            \\<A> x \\<bind>\n            (\\<lambda>(c, m, d, m', d').\n                assert_spmf\n                 (m \\<noteq> m' \\<and>\n                  m \\<in> challenge_space \\<and>\n                  m' \\<in> challenge_space) \\<bind>\n                (\\<lambda>_.\n                    let b = check x c m d; b' = check x c m' d'\n                    in assert_spmf (b \\<and> b') \\<bind>\n                       (\\<lambda>_.\n                           \\<A>ss x (c, m, d) (c, m', d') \\<bind>\n                           (\\<lambda>w'.\n                               return_spmf\n                                ((x, w')\n                                 \\<in> Rel)))))) ELSE return_spmf False", "apply(simp add:  key_gen_def verify_def Let_def split_def valid_msg_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. TRY G \\<bind>\n        (\\<lambda>y.\n            \\<A> (fst y) \\<bind>\n            (\\<lambda>p.\n                assert_spmf\n                 (fst (snd p) \\<noteq> fst (snd (snd (snd p))) \\<and>\n                  fst (snd p) \\<in> challenge_space \\<and>\n                  fst (snd (snd (snd p))) \\<in> challenge_space) \\<bind>\n                (\\<lambda>_.\n                    assert_spmf\n                     (check (fst y) (fst p) (fst (snd p))\n                       (fst (snd (snd p))) \\<and>\n                      check (fst y) (fst p) (fst (snd (snd (snd p))))\n                       (snd (snd (snd (snd p))))) \\<bind>\n                    (\\<lambda>_.\n                        return_spmf True)))) ELSE return_spmf False =\n    TRY G \\<bind>\n        (\\<lambda>p.\n            \\<A> (fst p) \\<bind>\n            (\\<lambda>pa.\n                assert_spmf\n                 (fst (snd pa) \\<noteq> fst (snd (snd (snd pa))) \\<and>\n                  fst (snd pa) \\<in> challenge_space \\<and>\n                  fst (snd (snd (snd pa))) \\<in> challenge_space) \\<bind>\n                (\\<lambda>_.\n                    assert_spmf\n                     (check (fst p) (fst pa) (fst (snd pa))\n                       (fst (snd (snd pa))) \\<and>\n                      check (fst p) (fst pa) (fst (snd (snd (snd pa))))\n                       (snd (snd (snd (snd pa))))) \\<bind>\n                    (\\<lambda>_.\n                        \\<A>ss (fst p)\n                         (fst pa, fst (snd pa), fst (snd (snd pa)))\n                         (fst pa, snd (snd (snd pa))) \\<bind>\n                        (\\<lambda>w'.\n                            return_spmf\n                             ((fst p, w')\n                              \\<in> Rel)))))) ELSE return_spmf False", "apply(intro try_spmf_cong bind_spmf_cong[OF refl]; clarsimp?)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b aa ab ac ad ba.\n       \\<lbrakk>(a, b) \\<in> set_spmf G;\n        (aa, ab, ac, ad, ba) \\<in> set_spmf (\\<A> a); ab \\<noteq> ad;\n        check a aa ab ac; check a aa ad ba; ab \\<in> challenge_space;\n        ad \\<in> challenge_space\\<rbrakk>\n       \\<Longrightarrow> return_spmf True =\n                         \\<A>ss a (aa, ab, ac) (aa, ad, ba) \\<bind>\n                         (\\<lambda>w'. return_spmf ((a, w') \\<in> Rel))", "using special_soundness_def \\<Sigma>_prot \\<Sigma>_protocol_def special_soundness_alt special_soundness_def set_spmf_G_rel set_spmf_G_domain_rel"], ["proof (prove)\nusing this:\n  special_soundness \\<equiv>\n  \\<forall>h e e' a z z'.\n     h \\<in> valid_pub \\<longrightarrow>\n     e \\<in> challenge_space \\<longrightarrow>\n     e' \\<in> challenge_space \\<longrightarrow>\n     e \\<noteq> e' \\<longrightarrow>\n     check h a e z \\<longrightarrow>\n     check h a e' z' \\<longrightarrow>\n     lossless_spmf (\\<A>ss h (a, e, z) (a, e', z')) \\<and>\n     (\\<forall>w'\\<in>set_spmf (\\<A>ss h (a, e, z) (a, e', z')).\n         (h, w') \\<in> Rel)\n  \\<Sigma>_protocol\n  \\<Sigma>_protocol \\<equiv>\n  completeness \\<and> special_soundness \\<and> HVZK\n  special_soundness =\n  (\\<forall>h a e z e' z'.\n      e \\<in> challenge_space \\<longrightarrow>\n      e' \\<in> challenge_space \\<longrightarrow>\n      h \\<in> valid_pub \\<longrightarrow>\n      e \\<noteq> e' \\<longrightarrow>\n      check h a e z \\<and> check h a e' z' \\<longrightarrow>\n      \\<A>ss h (a, e, z) (a, e', z') \\<bind>\n      (\\<lambda>w'. return_spmf ((h, w') \\<in> Rel)) =\n      return_spmf True)\n  special_soundness \\<equiv>\n  \\<forall>h e e' a z z'.\n     h \\<in> valid_pub \\<longrightarrow>\n     e \\<in> challenge_space \\<longrightarrow>\n     e' \\<in> challenge_space \\<longrightarrow>\n     e \\<noteq> e' \\<longrightarrow>\n     check h a e z \\<longrightarrow>\n     check h a e' z' \\<longrightarrow>\n     lossless_spmf (\\<A>ss h (a, e, z) (a, e', z')) \\<and>\n     (\\<forall>w'\\<in>set_spmf (\\<A>ss h (a, e, z) (a, e', z')).\n         (h, w') \\<in> Rel)\n  (?h, ?w) \\<in> set_spmf G \\<Longrightarrow> (?h, ?w) \\<in> Rel\n  (?h, ?w) \\<in> set_spmf G \\<Longrightarrow> ?h \\<in> Domain Rel\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ab ac ad ba.\n       \\<lbrakk>(a, b) \\<in> set_spmf G;\n        (aa, ab, ac, ad, ba) \\<in> set_spmf (\\<A> a); ab \\<noteq> ad;\n        check a aa ab ac; check a aa ad ba; ab \\<in> challenge_space;\n        ad \\<in> challenge_space\\<rbrakk>\n       \\<Longrightarrow> return_spmf True =\n                         \\<A>ss a (aa, ab, ac) (aa, ad, ba) \\<bind>\n                         (\\<lambda>w'. return_spmf ((a, w') \\<in> Rel))", "by (smt basic_trans_rules(31) bind_spmf_cong domain_subset_valid_pub)"], ["proof (state)\nthis:\n  abstract_com.bind_game \\<A> =\n  TRY G \\<bind>\n      (\\<lambda>(x, w).\n          \\<A> x \\<bind>\n          (\\<lambda>(c, m, d, m', d').\n              assert_spmf\n               (m \\<noteq> m' \\<and>\n                m \\<in> challenge_space \\<and>\n                m' \\<in> challenge_space) \\<bind>\n              (\\<lambda>_.\n                  let b = check x c m d; b' = check x c m' d'\n                  in assert_spmf (b \\<and> b') \\<bind>\n                     (\\<lambda>_.\n                         \\<A>ss x (c, m, d) (c, m', d') \\<bind>\n                         (\\<lambda>w'.\n                             return_spmf\n                              ((x, w')\n                               \\<in> Rel)))))) ELSE return_spmf False\n\ngoal (1 subgoal):\n 1. abstract_com.bind_advantage \\<A> \\<le> rel_advantage (adversary \\<A>)", "hence \"abstract_com.bind_advantage \\<A> \\<le> spmf (TRY do {\n  (x,w) \\<leftarrow> G;\n  (c, m, d, m', d') \\<leftarrow> \\<A> x;\n  w' \\<leftarrow> \\<A>ss x (c,m, d) (c,m', d');\n  return_spmf ((x,w') \\<in> Rel)} ELSE return_spmf False) True\""], ["proof (prove)\nusing this:\n  abstract_com.bind_game \\<A> =\n  TRY G \\<bind>\n      (\\<lambda>(x, w).\n          \\<A> x \\<bind>\n          (\\<lambda>(c, m, d, m', d').\n              assert_spmf\n               (m \\<noteq> m' \\<and>\n                m \\<in> challenge_space \\<and>\n                m' \\<in> challenge_space) \\<bind>\n              (\\<lambda>_.\n                  let b = check x c m d; b' = check x c m' d'\n                  in assert_spmf (b \\<and> b') \\<bind>\n                     (\\<lambda>_.\n                         \\<A>ss x (c, m, d) (c, m', d') \\<bind>\n                         (\\<lambda>w'.\n                             return_spmf\n                              ((x, w')\n                               \\<in> Rel)))))) ELSE return_spmf False\n\ngoal (1 subgoal):\n 1. abstract_com.bind_advantage \\<A>\n    \\<le> spmf\n           (TRY G \\<bind>\n                (\\<lambda>(x, w).\n                    \\<A> x \\<bind>\n                    (\\<lambda>(c, m, d, m', d').\n                        \\<A>ss x (c, m, d) (c, m', d') \\<bind>\n                        (\\<lambda>w'.\n                            return_spmf\n                             ((x, w') \\<in> Rel)))) ELSE return_spmf False)\n           True", "unfolding abstract_com.bind_advantage_def"], ["proof (prove)\nusing this:\n  abstract_com.bind_game \\<A> =\n  TRY G \\<bind>\n      (\\<lambda>(x, w).\n          \\<A> x \\<bind>\n          (\\<lambda>(c, m, d, m', d').\n              assert_spmf\n               (m \\<noteq> m' \\<and>\n                m \\<in> challenge_space \\<and>\n                m' \\<in> challenge_space) \\<bind>\n              (\\<lambda>_.\n                  let b = check x c m d; b' = check x c m' d'\n                  in assert_spmf (b \\<and> b') \\<bind>\n                     (\\<lambda>_.\n                         \\<A>ss x (c, m, d) (c, m', d') \\<bind>\n                         (\\<lambda>w'.\n                             return_spmf\n                              ((x, w')\n                               \\<in> Rel)))))) ELSE return_spmf False\n\ngoal (1 subgoal):\n 1. spmf (abstract_com.bind_game \\<A>) True\n    \\<le> spmf\n           (TRY G \\<bind>\n                (\\<lambda>(x, w).\n                    \\<A> x \\<bind>\n                    (\\<lambda>(c, m, d, m', d').\n                        \\<A>ss x (c, m, d) (c, m', d') \\<bind>\n                        (\\<lambda>w'.\n                            return_spmf\n                             ((x, w') \\<in> Rel)))) ELSE return_spmf False)\n           True", "apply(simp add: spmf_try_spmf)"], ["proof (prove)\ngoal (1 subgoal):\n 1. abstract_com.bind_game \\<A> =\n    TRY G \\<bind>\n        (\\<lambda>(x, w).\n            \\<A> x \\<bind>\n            (\\<lambda>(c, m, d, m', d').\n                assert_spmf\n                 (m \\<noteq> m' \\<and>\n                  m \\<in> challenge_space \\<and>\n                  m' \\<in> challenge_space) \\<bind>\n                (\\<lambda>_.\n                    assert_spmf\n                     (check x c m d \\<and> check x c m' d') \\<bind>\n                    (\\<lambda>_.\n                        \\<A>ss x (c, m, d) (c, m', d') \\<bind>\n                        (\\<lambda>w'.\n                            return_spmf\n                             ((x, w')\n                              \\<in> Rel)))))) ELSE return_spmf\n              False \\<Longrightarrow>\n    spmf\n     (G \\<bind>\n      (\\<lambda>(x, w).\n          \\<A> x \\<bind>\n          (\\<lambda>(c, m, d, m', d').\n              assert_spmf\n               (m \\<noteq> m' \\<and>\n                m \\<in> challenge_space \\<and>\n                m' \\<in> challenge_space) \\<bind>\n              (\\<lambda>_.\n                  assert_spmf (check x c m d \\<and> check x c m' d') \\<bind>\n                  (\\<lambda>_.\n                      \\<A>ss x (c, m, d) (c, m', d') \\<bind>\n                      (\\<lambda>w'. return_spmf ((x, w') \\<in> Rel)))))))\n     True\n    \\<le> spmf\n           (G \\<bind>\n            (\\<lambda>(x, w).\n                \\<A> x \\<bind>\n                (\\<lambda>(c, m, d, m', d').\n                    \\<A>ss x (c, m, d) (c, m', d') \\<bind>\n                    (\\<lambda>w'. return_spmf ((x, w') \\<in> Rel)))))\n           True", "apply(rule ord_spmf_eq_leD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. abstract_com.bind_game \\<A> =\n    TRY G \\<bind>\n        (\\<lambda>(x, w).\n            \\<A> x \\<bind>\n            (\\<lambda>(c, m, d, m', d').\n                assert_spmf\n                 (m \\<noteq> m' \\<and>\n                  m \\<in> challenge_space \\<and>\n                  m' \\<in> challenge_space) \\<bind>\n                (\\<lambda>_.\n                    assert_spmf\n                     (check x c m d \\<and> check x c m' d') \\<bind>\n                    (\\<lambda>_.\n                        \\<A>ss x (c, m, d) (c, m', d') \\<bind>\n                        (\\<lambda>w'.\n                            return_spmf\n                             ((x, w')\n                              \\<in> Rel)))))) ELSE return_spmf\n              False \\<Longrightarrow>\n    ord_spmf (=)\n     (G \\<bind>\n      (\\<lambda>(x, w).\n          \\<A> x \\<bind>\n          (\\<lambda>(c, m, d, m', d').\n              assert_spmf\n               (m \\<noteq> m' \\<and>\n                m \\<in> challenge_space \\<and>\n                m' \\<in> challenge_space) \\<bind>\n              (\\<lambda>_.\n                  assert_spmf (check x c m d \\<and> check x c m' d') \\<bind>\n                  (\\<lambda>_.\n                      \\<A>ss x (c, m, d) (c, m', d') \\<bind>\n                      (\\<lambda>w'. return_spmf ((x, w') \\<in> Rel)))))))\n     (G \\<bind>\n      (\\<lambda>(x, w).\n          \\<A> x \\<bind>\n          (\\<lambda>(c, m, d, m', d').\n              \\<A>ss x (c, m, d) (c, m', d') \\<bind>\n              (\\<lambda>w'. return_spmf ((x, w') \\<in> Rel)))))", "apply(rule ord_spmf_bind_reflI;clarsimp)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b aa ab ac ad ba.\n       \\<lbrakk>abstract_com.bind_game \\<A> =\n                TRY G \\<bind>\n                    (\\<lambda>(x, w).\n                        \\<A> x \\<bind>\n                        (\\<lambda>(c, m, d, m', d').\n                            assert_spmf\n                             (m \\<noteq> m' \\<and>\n                              m \\<in> challenge_space \\<and>\n                              m' \\<in> challenge_space) \\<bind>\n                            (\\<lambda>_.\n                                assert_spmf\n                                 (check x c m d \\<and>\n                                  check x c m' d') \\<bind>\n                                (\\<lambda>_.\n                                    \\<A>ss x (c, m, d) (c, m', d') \\<bind>\n                                    (\\<lambda>w'.\n  return_spmf ((x, w') \\<in> Rel)))))) ELSE return_spmf False;\n        (a, b) \\<in> set_spmf G;\n        (aa, ab, ac, ad, ba) \\<in> set_spmf (\\<A> a)\\<rbrakk>\n       \\<Longrightarrow> ord_spmf (=)\n                          (assert_spmf\n                            (ab \\<noteq> ad \\<and>\n                             ab \\<in> challenge_space \\<and>\n                             ad \\<in> challenge_space) \\<bind>\n                           (\\<lambda>_.\n                               assert_spmf\n                                (check a aa ab ac \\<and>\n                                 check a aa ad ba) \\<bind>\n                               (\\<lambda>_.\n                                   \\<A>ss a (aa, ab, ac)\n                                    (aa, ad, ba) \\<bind>\n                                   (\\<lambda>w'.\n return_spmf ((a, w') \\<in> Rel)))))\n                          (\\<A>ss a (aa, ab, ac) (aa, ad, ba) \\<bind>\n                           (\\<lambda>w'. return_spmf ((a, w') \\<in> Rel)))", "by(simp add: assert_spmf_def)"], ["proof (state)\nthis:\n  abstract_com.bind_advantage \\<A>\n  \\<le> spmf\n         (TRY G \\<bind>\n              (\\<lambda>(x, w).\n                  \\<A> x \\<bind>\n                  (\\<lambda>(c, m, d, m', d').\n                      \\<A>ss x (c, m, d) (c, m', d') \\<bind>\n                      (\\<lambda>w'.\n                          return_spmf\n                           ((x, w') \\<in> Rel)))) ELSE return_spmf False)\n         True\n\ngoal (1 subgoal):\n 1. abstract_com.bind_advantage \\<A> \\<le> rel_advantage (adversary \\<A>)", "thus ?thesis"], ["proof (prove)\nusing this:\n  abstract_com.bind_advantage \\<A>\n  \\<le> spmf\n         (TRY G \\<bind>\n              (\\<lambda>(x, w).\n                  \\<A> x \\<bind>\n                  (\\<lambda>(c, m, d, m', d').\n                      \\<A>ss x (c, m, d) (c, m', d') \\<bind>\n                      (\\<lambda>w'.\n                          return_spmf\n                           ((x, w') \\<in> Rel)))) ELSE return_spmf False)\n         True\n\ngoal (1 subgoal):\n 1. abstract_com.bind_advantage \\<A> \\<le> rel_advantage (adversary \\<A>)", "by(simp add: rel_game_def adversary_def split_def rel_advantage_def)"], ["proof (state)\nthis:\n  abstract_com.bind_advantage \\<A> \\<le> rel_advantage (adversary \\<A>)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"]]}