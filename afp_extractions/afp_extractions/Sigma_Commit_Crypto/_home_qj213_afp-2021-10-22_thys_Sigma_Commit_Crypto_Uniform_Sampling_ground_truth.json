{"file_name": "/home/qj213/afp-2021-10-22/thys/Sigma_Commit_Crypto/Uniform_Sampling.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Sigma_Commit_Crypto", "problem_names": ["lemma set_spmf_sample_uniform_units [simp]:\n  \"set_spmf (sample_uniform_units q) = {..< q} - {0}\"", "lemma lossless_sample_uniform_units:\n  assumes \"(p::nat) > 1\" \n  shows \"lossless_spmf (sample_uniform_units p)\"", "lemma weight_sample_uniform_units:\n  assumes \"(p::nat) > 1\" \n  shows \"weight_spmf (sample_uniform_units p) = 1\"", "lemma one_time_pad': \n  assumes inj_on: \"inj_on f ({..<q} - {0})\" \n    and sur: \"f ` ({..<q} - {0}) = ({..<q} - {0})\"  \n  shows \"map_spmf f (sample_uniform_units q) = (sample_uniform_units q)\"\n(is \"?lhs = ?rhs\")", "lemma one_time_pad: \n  assumes inj_on: \"inj_on f {..<q}\" \n    and sur: \"f ` {..<q} = {..<q}\"  \n  shows \"map_spmf f (sample_uniform q) = (sample_uniform q)\"\n(is \"?lhs = ?rhs\")", "lemma plus_inj_eq: \n  assumes x: \"x < q\"\n    and x': \"x' < q\" \n    and map: \"((y :: nat) + x) mod q = (y + x') mod q\"  \nshows \"x = x'\"", "lemma inj_uni_samp_plus: \"inj_on  (\\<lambda>(b :: nat). (y + b) mod q ) {..<q}\"", "lemma surj_uni_samp_plus: \n  assumes inj: \"inj_on  (\\<lambda>(b :: nat). (y + b) mod q ) {..<q}\" \n  shows \"(\\<lambda>(b :: nat). (y + b) mod q) ` {..< q} =  {..< q}\"", "lemma samp_uni_plus_one_time_pad: \nshows \"map_spmf (\\<lambda>b. (y + b) mod q) (sample_uniform q) = sample_uniform q\"", "lemma mult_inj_eq: \n  assumes coprime: \"coprime x (q::nat)\" \n    and y: \"y < q\" \n    and y': \"y' < q\" \n    and map: \"x * y mod q = x * y' mod q\" \n  shows \"y = y'\"", "lemma inj_on_mult: \n  assumes coprime: \"coprime x (q::nat)\" \n  shows \"inj_on (\\<lambda> b. x*b mod q) {..<q}\"", "lemma surj_on_mult: \n  assumes coprime: \"coprime x (q::nat)\" \n    and inj: \"inj_on (\\<lambda> b. x*b mod q) {..<q}\"\n  shows \"(\\<lambda> b. x*b mod q) ` {..< q} = {..< q}\"", "lemma mult_one_time_pad: \n  assumes coprime: \"coprime x q\" \n  shows \"map_spmf (\\<lambda> b. x*b mod q) (sample_uniform q) = sample_uniform q\"", "lemma inj_on_mult':\n  assumes coprime: \"coprime x (q::nat)\" \n  shows \"inj_on (\\<lambda> b. x*b mod q) ({..<q} - {0})\"", "lemma surj_on_mult': \n  assumes coprime: \"coprime x (q::nat)\" \n    and inj: \"inj_on (\\<lambda> b. x*b mod q) ({..<q} - {0})\"\n  shows \"(\\<lambda> b. x*b mod q) ` ({..<q} - {0}) = ({..<q} - {0})\"", "lemma mult_one_time_pad':\n  assumes coprime: \"coprime x q\" \n  shows \"map_spmf (\\<lambda> b. x*b mod q) (sample_uniform_units q) = sample_uniform_units q\"", "lemma samp_uni_add_mult: \n  assumes coprime: \"coprime x (q::nat)\" \n    and x': \"x' < q\" \n    and y': \"y' < q\" \n    and map: \"(y + x * x') mod q = (y + x * y') mod q\" \n  shows \"x' = y'\"", "lemma inj_on_add_mult: \n  assumes coprime: \"coprime x (q::nat)\" \n  shows \"inj_on (\\<lambda> b. (y + x*b) mod q) {..<q}\"", "lemma surj_on_add_mult: \n  assumes coprime: \"coprime x (q::nat)\" \n    and inj: \"inj_on (\\<lambda> b. (y + x*b) mod q) {..<q}\" \n  shows \"(\\<lambda> b. (y + x*b) mod q) ` {..< q} = {..< q}\"", "lemma add_mult_one_time_pad: \n  assumes coprime: \"coprime x q\" \n  shows \"map_spmf (\\<lambda> b. (y + x*b) mod q) (sample_uniform q) = (sample_uniform q)\"", "lemma inj_on_minus: \"inj_on  (\\<lambda>(b :: nat). (y + (q - b)) mod q ) {..<q}\"", "lemma surj_on_minus: \n  assumes inj: \"inj_on  (\\<lambda>(b :: nat). (y + (q - b)) mod q ) {..<q}\" \n  shows \"(\\<lambda>(b :: nat). (y + (q - b)) mod q) ` {..< q} = {..< q}\"", "lemma samp_uni_minus_one_time_pad: \n  shows \"map_spmf(\\<lambda> b. (y + (q - b)) mod q) (sample_uniform q) = sample_uniform q\"", "lemma not_coin_spmf: \"map_spmf (\\<lambda> a. \\<not> a) coin_spmf = coin_spmf\"", "lemma xor_uni_samp: \"map_spmf(\\<lambda> b. y \\<oplus> b) (coin_spmf) = map_spmf(\\<lambda> b. b) (coin_spmf)\"\n  (is \"?lhs = ?rhs\")", "lemma ped_inv_mapping:\n  assumes \"(a::nat) < q\"\n    and \"[m \\<noteq> 0] (mod q)\"\n  shows \"map_spmf (\\<lambda> d. (d + a * (m::nat)) mod q) (sample_uniform q) = map_spmf (\\<lambda> d. (d + q * m - a * m) mod q) (sample_uniform q)\"\n(is \"?lhs = ?rhs\")"], "translations": [["", "lemma set_spmf_sample_uniform_units [simp]:\n  \"set_spmf (sample_uniform_units q) = {..< q} - {0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_spmf (sample_uniform_units q) = {..<q} - {0}", "by(simp add: sample_uniform_units_def)"], ["", "lemma lossless_sample_uniform_units:\n  assumes \"(p::nat) > 1\" \n  shows \"lossless_spmf (sample_uniform_units p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lossless_spmf (sample_uniform_units p)", "unfolding sample_uniform_units_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. lossless_spmf (spmf_of_set ({..<p} - {0}))", "using assms"], ["proof (prove)\nusing this:\n  1 < p\n\ngoal (1 subgoal):\n 1. lossless_spmf (spmf_of_set ({..<p} - {0}))", "by auto"], ["", "lemma weight_sample_uniform_units:\n  assumes \"(p::nat) > 1\" \n  shows \"weight_spmf (sample_uniform_units p) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. weight_spmf (sample_uniform_units p) = 1", "using assms lossless_sample_uniform_units"], ["proof (prove)\nusing this:\n  1 < p\n  1 < ?p \\<Longrightarrow> lossless_spmf (sample_uniform_units ?p)\n\ngoal (1 subgoal):\n 1. weight_spmf (sample_uniform_units p) = 1", "by (simp add: lossless_weight_spmfD)"], ["", "(*General lemma for mapping using sample_uniform*)"], ["", "lemma one_time_pad': \n  assumes inj_on: \"inj_on f ({..<q} - {0})\" \n    and sur: \"f ` ({..<q} - {0}) = ({..<q} - {0})\"  \n  shows \"map_spmf f (sample_uniform_units q) = (sample_uniform_units q)\"\n(is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_spmf f (sample_uniform_units q) = sample_uniform_units q", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. map_spmf f (sample_uniform_units q) = sample_uniform_units q", "have rhs: \"?rhs = spmf_of_set (({..<q} - {0}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sample_uniform_units q = spmf_of_set ({..<q} - {0})", "by(auto simp add: sample_uniform_units_def)"], ["proof (state)\nthis:\n  sample_uniform_units q = spmf_of_set ({..<q} - {0})\n\ngoal (1 subgoal):\n 1. map_spmf f (sample_uniform_units q) = sample_uniform_units q", "also"], ["proof (state)\nthis:\n  sample_uniform_units q = spmf_of_set ({..<q} - {0})\n\ngoal (1 subgoal):\n 1. map_spmf f (sample_uniform_units q) = sample_uniform_units q", "have \"map_spmf(\\<lambda>s. f s) (spmf_of_set ({..<q} - {0})) = spmf_of_set ((\\<lambda>s. f s) ` ({..<q} - {0}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_spmf f (spmf_of_set ({..<q} - {0})) =\n    spmf_of_set (f ` ({..<q} - {0}))", "by(simp add: inj_on)"], ["proof (state)\nthis:\n  map_spmf f (spmf_of_set ({..<q} - {0})) = spmf_of_set (f ` ({..<q} - {0}))\n\ngoal (1 subgoal):\n 1. map_spmf f (sample_uniform_units q) = sample_uniform_units q", "also"], ["proof (state)\nthis:\n  map_spmf f (spmf_of_set ({..<q} - {0})) = spmf_of_set (f ` ({..<q} - {0}))\n\ngoal (1 subgoal):\n 1. map_spmf f (sample_uniform_units q) = sample_uniform_units q", "have \"f ` ({..<q} - {0}) = ({..<q} - {0})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f ` ({..<q} - {0}) = {..<q} - {0}", "apply(rule endo_inj_surj)"], ["proof (prove)\ngoal (3 subgoals):\n 1. finite ({..<q} - {0})\n 2. f ` ({..<q} - {0}) \\<subseteq> {..<q} - {0}\n 3. inj_on f ({..<q} - {0})", "by(simp, simp add: sur, simp add: inj_on)"], ["proof (state)\nthis:\n  f ` ({..<q} - {0}) = {..<q} - {0}\n\ngoal (1 subgoal):\n 1. map_spmf f (sample_uniform_units q) = sample_uniform_units q", "ultimately"], ["proof (chain)\npicking this:\n  map_spmf f (sample_uniform_units q) = spmf_of_set (f ` ({..<q} - {0}))\n  f ` ({..<q} - {0}) = {..<q} - {0}", "show ?thesis"], ["proof (prove)\nusing this:\n  map_spmf f (sample_uniform_units q) = spmf_of_set (f ` ({..<q} - {0}))\n  f ` ({..<q} - {0}) = {..<q} - {0}\n\ngoal (1 subgoal):\n 1. map_spmf f (sample_uniform_units q) = sample_uniform_units q", "using rhs"], ["proof (prove)\nusing this:\n  map_spmf f (sample_uniform_units q) = spmf_of_set (f ` ({..<q} - {0}))\n  f ` ({..<q} - {0}) = {..<q} - {0}\n  sample_uniform_units q = spmf_of_set ({..<q} - {0})\n\ngoal (1 subgoal):\n 1. map_spmf f (sample_uniform_units q) = sample_uniform_units q", "by simp"], ["proof (state)\nthis:\n  map_spmf f (sample_uniform_units q) = sample_uniform_units q\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma one_time_pad: \n  assumes inj_on: \"inj_on f {..<q}\" \n    and sur: \"f ` {..<q} = {..<q}\"  \n  shows \"map_spmf f (sample_uniform q) = (sample_uniform q)\"\n(is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_spmf f (sample_uniform q) = sample_uniform q", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. map_spmf f (sample_uniform q) = sample_uniform q", "have rhs: \"?rhs = spmf_of_set ({..< q})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sample_uniform q = spmf_of_set {..<q}", "by(auto simp add: sample_uniform_def)"], ["proof (state)\nthis:\n  sample_uniform q = spmf_of_set {..<q}\n\ngoal (1 subgoal):\n 1. map_spmf f (sample_uniform q) = sample_uniform q", "also"], ["proof (state)\nthis:\n  sample_uniform q = spmf_of_set {..<q}\n\ngoal (1 subgoal):\n 1. map_spmf f (sample_uniform q) = sample_uniform q", "have \"map_spmf(\\<lambda>s. f s) (spmf_of_set {..<q}) = spmf_of_set ((\\<lambda>s. f s) ` {..<q})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_spmf f (spmf_of_set {..<q}) = spmf_of_set (f ` {..<q})", "by(simp add: inj_on)"], ["proof (state)\nthis:\n  map_spmf f (spmf_of_set {..<q}) = spmf_of_set (f ` {..<q})\n\ngoal (1 subgoal):\n 1. map_spmf f (sample_uniform q) = sample_uniform q", "also"], ["proof (state)\nthis:\n  map_spmf f (spmf_of_set {..<q}) = spmf_of_set (f ` {..<q})\n\ngoal (1 subgoal):\n 1. map_spmf f (sample_uniform q) = sample_uniform q", "have \"f ` {..<q} = {..<q}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f ` {..<q} = {..<q}", "apply(rule endo_inj_surj)"], ["proof (prove)\ngoal (3 subgoals):\n 1. finite {..<q}\n 2. f ` {..<q} \\<subseteq> {..<q}\n 3. inj_on f {..<q}", "by(simp, simp add: sur, simp add: inj_on)"], ["proof (state)\nthis:\n  f ` {..<q} = {..<q}\n\ngoal (1 subgoal):\n 1. map_spmf f (sample_uniform q) = sample_uniform q", "ultimately"], ["proof (chain)\npicking this:\n  map_spmf f (sample_uniform q) = spmf_of_set (f ` {..<q})\n  f ` {..<q} = {..<q}", "show ?thesis"], ["proof (prove)\nusing this:\n  map_spmf f (sample_uniform q) = spmf_of_set (f ` {..<q})\n  f ` {..<q} = {..<q}\n\ngoal (1 subgoal):\n 1. map_spmf f (sample_uniform q) = sample_uniform q", "using rhs"], ["proof (prove)\nusing this:\n  map_spmf f (sample_uniform q) = spmf_of_set (f ` {..<q})\n  f ` {..<q} = {..<q}\n  sample_uniform q = spmf_of_set {..<q}\n\ngoal (1 subgoal):\n 1. map_spmf f (sample_uniform q) = sample_uniform q", "by simp"], ["proof (state)\nthis:\n  map_spmf f (sample_uniform q) = sample_uniform q\n\ngoal:\nNo subgoals!", "qed"], ["", "(*(y + b)*)"], ["", "lemma plus_inj_eq: \n  assumes x: \"x < q\"\n    and x': \"x' < q\" \n    and map: \"((y :: nat) + x) mod q = (y + x') mod q\"  \nshows \"x = x'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = x'", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. x = x'", "have \"((y :: nat) + x) mod q = (y + x') mod q \\<Longrightarrow> x mod q = x' mod q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (y + x) mod q = (y + x') mod q \\<Longrightarrow> x mod q = x' mod q", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. (y + x) mod q = (y + x') mod q \\<Longrightarrow> x mod q = x' mod q", "have \"((y:: nat) + x) mod q = (y + x') mod q \\<Longrightarrow> [((y:: nat) + x) = (y + x')] (mod q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (y + x) mod q = (y + x') mod q \\<Longrightarrow>\n    [y + x = y + x'] (mod q)", "by(simp add: cong_def)"], ["proof (state)\nthis:\n  (y + x) mod q = (y + x') mod q \\<Longrightarrow> [y + x = y + x'] (mod q)\n\ngoal (1 subgoal):\n 1. (y + x) mod q = (y + x') mod q \\<Longrightarrow> x mod q = x' mod q", "moreover"], ["proof (state)\nthis:\n  (y + x) mod q = (y + x') mod q \\<Longrightarrow> [y + x = y + x'] (mod q)\n\ngoal (1 subgoal):\n 1. (y + x) mod q = (y + x') mod q \\<Longrightarrow> x mod q = x' mod q", "have \"[((y:: nat) + x) = (y + x')] (mod q) \\<Longrightarrow> [x = x'] (mod q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [y + x = y + x'] (mod q) \\<Longrightarrow> [x = x'] (mod q)", "by (simp add: cong_add_lcancel_nat)"], ["proof (state)\nthis:\n  [y + x = y + x'] (mod q) \\<Longrightarrow> [x = x'] (mod q)\n\ngoal (1 subgoal):\n 1. (y + x) mod q = (y + x') mod q \\<Longrightarrow> x mod q = x' mod q", "moreover"], ["proof (state)\nthis:\n  [y + x = y + x'] (mod q) \\<Longrightarrow> [x = x'] (mod q)\n\ngoal (1 subgoal):\n 1. (y + x) mod q = (y + x') mod q \\<Longrightarrow> x mod q = x' mod q", "have \"[x = x'] (mod q) \\<Longrightarrow> x mod q = x' mod q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [x = x'] (mod q) \\<Longrightarrow> x mod q = x' mod q", "by(simp add: cong_def)"], ["proof (state)\nthis:\n  [x = x'] (mod q) \\<Longrightarrow> x mod q = x' mod q\n\ngoal (1 subgoal):\n 1. (y + x) mod q = (y + x') mod q \\<Longrightarrow> x mod q = x' mod q", "ultimately"], ["proof (chain)\npicking this:\n  (y + x) mod q = (y + x') mod q \\<Longrightarrow> [y + x = y + x'] (mod q)\n  [y + x = y + x'] (mod q) \\<Longrightarrow> [x = x'] (mod q)\n  [x = x'] (mod q) \\<Longrightarrow> x mod q = x' mod q", "show ?thesis"], ["proof (prove)\nusing this:\n  (y + x) mod q = (y + x') mod q \\<Longrightarrow> [y + x = y + x'] (mod q)\n  [y + x = y + x'] (mod q) \\<Longrightarrow> [x = x'] (mod q)\n  [x = x'] (mod q) \\<Longrightarrow> x mod q = x' mod q\n\ngoal (1 subgoal):\n 1. x mod q = x' mod q", "by(simp add: map)"], ["proof (state)\nthis:\n  x mod q = x' mod q\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (y + x) mod q = (y + x') mod q \\<Longrightarrow> x mod q = x' mod q\n\ngoal (1 subgoal):\n 1. x = x'", "moreover"], ["proof (state)\nthis:\n  (y + x) mod q = (y + x') mod q \\<Longrightarrow> x mod q = x' mod q\n\ngoal (1 subgoal):\n 1. x = x'", "have \"x mod q = x' mod q \\<Longrightarrow> x = x'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x mod q = x' mod q \\<Longrightarrow> x = x'", "by(simp add: x x')"], ["proof (state)\nthis:\n  x mod q = x' mod q \\<Longrightarrow> x = x'\n\ngoal (1 subgoal):\n 1. x = x'", "ultimately"], ["proof (chain)\npicking this:\n  (y + x) mod q = (y + x') mod q \\<Longrightarrow> x mod q = x' mod q\n  x mod q = x' mod q \\<Longrightarrow> x = x'", "show ?thesis"], ["proof (prove)\nusing this:\n  (y + x) mod q = (y + x') mod q \\<Longrightarrow> x mod q = x' mod q\n  x mod q = x' mod q \\<Longrightarrow> x = x'\n\ngoal (1 subgoal):\n 1. x = x'", "by(simp add: map)"], ["proof (state)\nthis:\n  x = x'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma inj_uni_samp_plus: \"inj_on  (\\<lambda>(b :: nat). (y + b) mod q ) {..<q}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (\\<lambda>b. (y + b) mod q) {..<q}", "by(simp add: inj_on_def)(auto simp only: plus_inj_eq)"], ["", "lemma surj_uni_samp_plus: \n  assumes inj: \"inj_on  (\\<lambda>(b :: nat). (y + b) mod q ) {..<q}\" \n  shows \"(\\<lambda>(b :: nat). (y + b) mod q) ` {..< q} =  {..< q}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>b. (y + b) mod q) ` {..<q} = {..<q}", "apply(rule endo_inj_surj)"], ["proof (prove)\ngoal (3 subgoals):\n 1. finite {..<q}\n 2. (\\<lambda>b. (y + b) mod q) ` {..<q} \\<subseteq> {..<q}\n 3. inj_on (\\<lambda>b. (y + b) mod q) {..<q}", "using inj"], ["proof (prove)\nusing this:\n  inj_on (\\<lambda>b. (y + b) mod q) {..<q}\n\ngoal (3 subgoals):\n 1. finite {..<q}\n 2. (\\<lambda>b. (y + b) mod q) ` {..<q} \\<subseteq> {..<q}\n 3. inj_on (\\<lambda>b. (y + b) mod q) {..<q}", "by auto"], ["", "lemma samp_uni_plus_one_time_pad: \nshows \"map_spmf (\\<lambda>b. (y + b) mod q) (sample_uniform q) = sample_uniform q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_spmf (\\<lambda>b. (y + b) mod q) (sample_uniform q) =\n    sample_uniform q", "using inj_uni_samp_plus surj_uni_samp_plus one_time_pad"], ["proof (prove)\nusing this:\n  inj_on (\\<lambda>b. (?y + b) mod ?q) {..<?q}\n  inj_on (\\<lambda>b. (?y + b) mod ?q) {..<?q} \\<Longrightarrow>\n  (\\<lambda>b. (?y + b) mod ?q) ` {..<?q} = {..<?q}\n  \\<lbrakk>inj_on ?f {..<?q}; ?f ` {..<?q} = {..<?q}\\<rbrakk>\n  \\<Longrightarrow> map_spmf ?f (sample_uniform ?q) = sample_uniform ?q\n\ngoal (1 subgoal):\n 1. map_spmf (\\<lambda>b. (y + b) mod q) (sample_uniform q) =\n    sample_uniform q", "by simp"], ["", "(*x*b*)"], ["", "lemma mult_inj_eq: \n  assumes coprime: \"coprime x (q::nat)\" \n    and y: \"y < q\" \n    and y': \"y' < q\" \n    and map: \"x * y mod q = x * y' mod q\" \n  shows \"y = y'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y = y'", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. y = y'", "have \"x*y mod q = x*y' mod q \\<Longrightarrow> y mod q = y' mod q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * y mod q = x * y' mod q \\<Longrightarrow> y mod q = y' mod q", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. x * y mod q = x * y' mod q \\<Longrightarrow> y mod q = y' mod q", "have \"x*y mod q = x*y' mod q \\<Longrightarrow> [x*y = x*y'] (mod q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * y mod q = x * y' mod q \\<Longrightarrow> [x * y = x * y'] (mod q)", "by(simp add: cong_def)"], ["proof (state)\nthis:\n  x * y mod q = x * y' mod q \\<Longrightarrow> [x * y = x * y'] (mod q)\n\ngoal (1 subgoal):\n 1. x * y mod q = x * y' mod q \\<Longrightarrow> y mod q = y' mod q", "moreover"], ["proof (state)\nthis:\n  x * y mod q = x * y' mod q \\<Longrightarrow> [x * y = x * y'] (mod q)\n\ngoal (1 subgoal):\n 1. x * y mod q = x * y' mod q \\<Longrightarrow> y mod q = y' mod q", "have \"[x*y = x*y'] (mod q) = [y = y'] (mod q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [x * y = x * y'] (mod q) = [y = y'] (mod q)", "by(simp add: cong_mult_lcancel_nat coprime)"], ["proof (state)\nthis:\n  [x * y = x * y'] (mod q) = [y = y'] (mod q)\n\ngoal (1 subgoal):\n 1. x * y mod q = x * y' mod q \\<Longrightarrow> y mod q = y' mod q", "moreover"], ["proof (state)\nthis:\n  [x * y = x * y'] (mod q) = [y = y'] (mod q)\n\ngoal (1 subgoal):\n 1. x * y mod q = x * y' mod q \\<Longrightarrow> y mod q = y' mod q", "have \"[y = y'] (mod q) \\<Longrightarrow> y mod q = y' mod q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [y = y'] (mod q) \\<Longrightarrow> y mod q = y' mod q", "by(simp add: cong_def)"], ["proof (state)\nthis:\n  [y = y'] (mod q) \\<Longrightarrow> y mod q = y' mod q\n\ngoal (1 subgoal):\n 1. x * y mod q = x * y' mod q \\<Longrightarrow> y mod q = y' mod q", "ultimately"], ["proof (chain)\npicking this:\n  x * y mod q = x * y' mod q \\<Longrightarrow> [x * y = x * y'] (mod q)\n  [x * y = x * y'] (mod q) = [y = y'] (mod q)\n  [y = y'] (mod q) \\<Longrightarrow> y mod q = y' mod q", "show ?thesis"], ["proof (prove)\nusing this:\n  x * y mod q = x * y' mod q \\<Longrightarrow> [x * y = x * y'] (mod q)\n  [x * y = x * y'] (mod q) = [y = y'] (mod q)\n  [y = y'] (mod q) \\<Longrightarrow> y mod q = y' mod q\n\ngoal (1 subgoal):\n 1. y mod q = y' mod q", "by(simp add: map)"], ["proof (state)\nthis:\n  y mod q = y' mod q\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x * y mod q = x * y' mod q \\<Longrightarrow> y mod q = y' mod q\n\ngoal (1 subgoal):\n 1. y = y'", "moreover"], ["proof (state)\nthis:\n  x * y mod q = x * y' mod q \\<Longrightarrow> y mod q = y' mod q\n\ngoal (1 subgoal):\n 1. y = y'", "have \"y mod q = y' mod q \\<Longrightarrow> y = y'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y mod q = y' mod q \\<Longrightarrow> y = y'", "by(simp add: y y')"], ["proof (state)\nthis:\n  y mod q = y' mod q \\<Longrightarrow> y = y'\n\ngoal (1 subgoal):\n 1. y = y'", "ultimately"], ["proof (chain)\npicking this:\n  x * y mod q = x * y' mod q \\<Longrightarrow> y mod q = y' mod q\n  y mod q = y' mod q \\<Longrightarrow> y = y'", "show ?thesis"], ["proof (prove)\nusing this:\n  x * y mod q = x * y' mod q \\<Longrightarrow> y mod q = y' mod q\n  y mod q = y' mod q \\<Longrightarrow> y = y'\n\ngoal (1 subgoal):\n 1. y = y'", "by(simp add: map)"], ["proof (state)\nthis:\n  y = y'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma inj_on_mult: \n  assumes coprime: \"coprime x (q::nat)\" \n  shows \"inj_on (\\<lambda> b. x*b mod q) {..<q}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (\\<lambda>b. x * b mod q) {..<q}", "apply(auto simp add: inj_on_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa y.\n       \\<lbrakk>xa < q; y < q; x * xa mod q = x * y mod q\\<rbrakk>\n       \\<Longrightarrow> xa = y", "using coprime"], ["proof (prove)\nusing this:\n  coprime x q\n\ngoal (1 subgoal):\n 1. \\<And>xa y.\n       \\<lbrakk>xa < q; y < q; x * xa mod q = x * y mod q\\<rbrakk>\n       \\<Longrightarrow> xa = y", "by(simp only: mult_inj_eq)"], ["", "lemma surj_on_mult: \n  assumes coprime: \"coprime x (q::nat)\" \n    and inj: \"inj_on (\\<lambda> b. x*b mod q) {..<q}\"\n  shows \"(\\<lambda> b. x*b mod q) ` {..< q} = {..< q}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>b. x * b mod q) ` {..<q} = {..<q}", "apply(rule endo_inj_surj)"], ["proof (prove)\ngoal (3 subgoals):\n 1. finite {..<q}\n 2. (\\<lambda>b. x * b mod q) ` {..<q} \\<subseteq> {..<q}\n 3. inj_on (\\<lambda>b. x * b mod q) {..<q}", "using coprime inj"], ["proof (prove)\nusing this:\n  coprime x q\n  inj_on (\\<lambda>b. x * b mod q) {..<q}\n\ngoal (3 subgoals):\n 1. finite {..<q}\n 2. (\\<lambda>b. x * b mod q) ` {..<q} \\<subseteq> {..<q}\n 3. inj_on (\\<lambda>b. x * b mod q) {..<q}", "by auto"], ["", "lemma mult_one_time_pad: \n  assumes coprime: \"coprime x q\" \n  shows \"map_spmf (\\<lambda> b. x*b mod q) (sample_uniform q) = sample_uniform q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_spmf (\\<lambda>b. x * b mod q) (sample_uniform q) = sample_uniform q", "using inj_on_mult surj_on_mult one_time_pad coprime"], ["proof (prove)\nusing this:\n  coprime ?x ?q \\<Longrightarrow> inj_on (\\<lambda>b. ?x * b mod ?q) {..<?q}\n  \\<lbrakk>coprime ?x ?q;\n   inj_on (\\<lambda>b. ?x * b mod ?q) {..<?q}\\<rbrakk>\n  \\<Longrightarrow> (\\<lambda>b. ?x * b mod ?q) ` {..<?q} = {..<?q}\n  \\<lbrakk>inj_on ?f {..<?q}; ?f ` {..<?q} = {..<?q}\\<rbrakk>\n  \\<Longrightarrow> map_spmf ?f (sample_uniform ?q) = sample_uniform ?q\n  coprime x q\n\ngoal (1 subgoal):\n 1. map_spmf (\\<lambda>b. x * b mod q) (sample_uniform q) = sample_uniform q", "by simp"], ["", "lemma inj_on_mult':\n  assumes coprime: \"coprime x (q::nat)\" \n  shows \"inj_on (\\<lambda> b. x*b mod q) ({..<q} - {0})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (\\<lambda>b. x * b mod q) ({..<q} - {0})", "apply(auto simp add: inj_on_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa y.\n       \\<lbrakk>xa < q; 0 < xa; y < q; x * xa mod q = x * y mod q;\n        0 < y\\<rbrakk>\n       \\<Longrightarrow> xa = y", "using coprime"], ["proof (prove)\nusing this:\n  coprime x q\n\ngoal (1 subgoal):\n 1. \\<And>xa y.\n       \\<lbrakk>xa < q; 0 < xa; y < q; x * xa mod q = x * y mod q;\n        0 < y\\<rbrakk>\n       \\<Longrightarrow> xa = y", "by(simp only: mult_inj_eq)"], ["", "lemma surj_on_mult': \n  assumes coprime: \"coprime x (q::nat)\" \n    and inj: \"inj_on (\\<lambda> b. x*b mod q) ({..<q} - {0})\"\n  shows \"(\\<lambda> b. x*b mod q) ` ({..<q} - {0}) = ({..<q} - {0})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>b. x * b mod q) ` ({..<q} - {0}) = {..<q} - {0}", "proof(rule endo_inj_surj)"], ["proof (state)\ngoal (3 subgoals):\n 1. finite ({..<q} - {0})\n 2. (\\<lambda>b. x * b mod q) ` ({..<q} - {0}) \\<subseteq> {..<q} - {0}\n 3. inj_on (\\<lambda>b. x * b mod q) ({..<q} - {0})", "show \" finite ({..<q} - {0})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite ({..<q} - {0})", "by auto"], ["proof (state)\nthis:\n  finite ({..<q} - {0})\n\ngoal (2 subgoals):\n 1. (\\<lambda>b. x * b mod q) ` ({..<q} - {0}) \\<subseteq> {..<q} - {0}\n 2. inj_on (\\<lambda>b. x * b mod q) ({..<q} - {0})", "show \"(\\<lambda>b. x * b mod q) ` ({..<q} - {0}) \\<subseteq> {..<q} - {0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>b. x * b mod q) ` ({..<q} - {0}) \\<subseteq> {..<q} - {0}", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<lambda>b. x * b mod q) ` ({..<q} - {0}) \\<subseteq> {..<q} - {0}", "obtain nn :: \"nat set \\<Rightarrow> (nat \\<Rightarrow> nat) \\<Rightarrow> nat set \\<Rightarrow> nat\" where\n      \"\\<forall>x0 x1 x2. (\\<exists>v3. v3 \\<in> x2 \\<and> x1 v3 \\<notin> x0) = (nn x0 x1 x2 \\<in> x2 \\<and> x1 (nn x0 x1 x2) \\<notin> x0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>nn.\n        \\<forall>x0 x1 x2.\n           (\\<exists>v3. v3 \\<in> x2 \\<and> x1 v3 \\<notin> x0) =\n           (nn x0 x1 x2 \\<in> x2 \\<and>\n            x1 (nn x0 x1 x2) \\<notin> x0) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by moura"], ["proof (state)\nthis:\n  \\<forall>x0 x1 x2.\n     (\\<exists>v3. v3 \\<in> x2 \\<and> x1 v3 \\<notin> x0) =\n     (nn x0 x1 x2 \\<in> x2 \\<and> x1 (nn x0 x1 x2) \\<notin> x0)\n\ngoal (1 subgoal):\n 1. (\\<lambda>b. x * b mod q) ` ({..<q} - {0}) \\<subseteq> {..<q} - {0}", "hence 1: \"\\<forall>N f Na. nn Na f N \\<in> N \\<and> f (nn Na f N) \\<notin> Na \\<or> f ` N \\<subseteq> Na\""], ["proof (prove)\nusing this:\n  \\<forall>x0 x1 x2.\n     (\\<exists>v3. v3 \\<in> x2 \\<and> x1 v3 \\<notin> x0) =\n     (nn x0 x1 x2 \\<in> x2 \\<and> x1 (nn x0 x1 x2) \\<notin> x0)\n\ngoal (1 subgoal):\n 1. \\<forall>N f Na.\n       nn Na f N \\<in> N \\<and> f (nn Na f N) \\<notin> Na \\<or>\n       f ` N \\<subseteq> Na", "by (meson image_subsetI)"], ["proof (state)\nthis:\n  \\<forall>N f Na.\n     nn Na f N \\<in> N \\<and> f (nn Na f N) \\<notin> Na \\<or>\n     f ` N \\<subseteq> Na\n\ngoal (1 subgoal):\n 1. (\\<lambda>b. x * b mod q) ` ({..<q} - {0}) \\<subseteq> {..<q} - {0}", "have 2: \"x * nn ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0}) mod q \\<notin> {..<q} \\<or> x * nn ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0}) mod q \\<in> insert 0 {..<q}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * nn ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0}) mod q\n    \\<notin> {..<q} \\<or>\n    x * nn ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0}) mod q\n    \\<in> insert 0 {..<q}", "by force"], ["proof (state)\nthis:\n  x * nn ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0}) mod q\n  \\<notin> {..<q} \\<or>\n  x * nn ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0}) mod q\n  \\<in> insert 0 {..<q}\n\ngoal (1 subgoal):\n 1. (\\<lambda>b. x * b mod q) ` ({..<q} - {0}) \\<subseteq> {..<q} - {0}", "have 3: \"(x * nn ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0}) mod q \\<in> insert 0 {..<q} - {0}) = (x * nn ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0}) mod q \\<in> {..<q} - {0})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x * nn ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0}) mod q\n     \\<in> insert 0 {..<q} - {0}) =\n    (x * nn ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0}) mod q\n     \\<in> {..<q} - {0})", "by simp"], ["proof (state)\nthis:\n  (x * nn ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0}) mod q\n   \\<in> insert 0 {..<q} - {0}) =\n  (x * nn ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0}) mod q\n   \\<in> {..<q} - {0})\n\ngoal (1 subgoal):\n 1. (\\<lambda>b. x * b mod q) ` ({..<q} - {0}) \\<subseteq> {..<q} - {0}", "{"], ["proof (state)\nthis:\n  (x * nn ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0}) mod q\n   \\<in> insert 0 {..<q} - {0}) =\n  (x * nn ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0}) mod q\n   \\<in> {..<q} - {0})\n\ngoal (1 subgoal):\n 1. (\\<lambda>b. x * b mod q) ` ({..<q} - {0}) \\<subseteq> {..<q} - {0}", "assume \"x * nn ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0}) mod q = x * 0 mod q\""], ["proof (state)\nthis:\n  x * nn ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0}) mod q =\n  x * 0 mod q\n\ngoal (1 subgoal):\n 1. (\\<lambda>b. x * b mod q) ` ({..<q} - {0}) \\<subseteq> {..<q} - {0}", "hence \"(0 \\<le> q) = (0 = q) \\<or> (nn ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0}) \\<notin> {..<q} \\<or> nn ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0}) \\<in> {0}) \\<or> nn ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0}) \\<notin> {..<q} - {0} \\<or> x * nn ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0}) mod q \\<in> {..<q} - {0}\""], ["proof (prove)\nusing this:\n  x * nn ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0}) mod q =\n  x * 0 mod q\n\ngoal (1 subgoal):\n 1. (0 \\<le> q) = (0 = q) \\<or>\n    (nn ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0})\n     \\<notin> {..<q} \\<or>\n     nn ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0})\n     \\<in> {0}) \\<or>\n    nn ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0})\n    \\<notin> {..<q} - {0} \\<or>\n    x * nn ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0}) mod q\n    \\<in> {..<q} - {0}", "by (metis antisym_conv1 insertCI lessThan_iff local.coprime mult_inj_eq)"], ["proof (state)\nthis:\n  (0 \\<le> q) = (0 = q) \\<or>\n  (nn ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0})\n   \\<notin> {..<q} \\<or>\n   nn ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0})\n   \\<in> {0}) \\<or>\n  nn ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0})\n  \\<notin> {..<q} - {0} \\<or>\n  x * nn ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0}) mod q\n  \\<in> {..<q} - {0}\n\ngoal (1 subgoal):\n 1. (\\<lambda>b. x * b mod q) ` ({..<q} - {0}) \\<subseteq> {..<q} - {0}", "}"], ["proof (state)\nthis:\n  x * nn ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0}) mod q =\n  x * 0 mod q \\<Longrightarrow>\n  (0 \\<le> q) = (0 = q) \\<or>\n  (nn ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0})\n   \\<notin> {..<q} \\<or>\n   nn ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0})\n   \\<in> {0}) \\<or>\n  nn ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0})\n  \\<notin> {..<q} - {0} \\<or>\n  x * nn ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0}) mod q\n  \\<in> {..<q} - {0}\n\ngoal (1 subgoal):\n 1. (\\<lambda>b. x * b mod q) ` ({..<q} - {0}) \\<subseteq> {..<q} - {0}", "moreover"], ["proof (state)\nthis:\n  x * nn ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0}) mod q =\n  x * 0 mod q \\<Longrightarrow>\n  (0 \\<le> q) = (0 = q) \\<or>\n  (nn ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0})\n   \\<notin> {..<q} \\<or>\n   nn ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0})\n   \\<in> {0}) \\<or>\n  nn ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0})\n  \\<notin> {..<q} - {0} \\<or>\n  x * nn ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0}) mod q\n  \\<in> {..<q} - {0}\n\ngoal (1 subgoal):\n 1. (\\<lambda>b. x * b mod q) ` ({..<q} - {0}) \\<subseteq> {..<q} - {0}", "{"], ["proof (state)\nthis:\n  x * nn ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0}) mod q =\n  x * 0 mod q \\<Longrightarrow>\n  (0 \\<le> q) = (0 = q) \\<or>\n  (nn ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0})\n   \\<notin> {..<q} \\<or>\n   nn ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0})\n   \\<in> {0}) \\<or>\n  nn ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0})\n  \\<notin> {..<q} - {0} \\<or>\n  x * nn ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0}) mod q\n  \\<in> {..<q} - {0}\n\ngoal (1 subgoal):\n 1. (\\<lambda>b. x * b mod q) ` ({..<q} - {0}) \\<subseteq> {..<q} - {0}", "assume \"0 \\<noteq> x * nn ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0}) mod q\""], ["proof (state)\nthis:\n  0 \\<noteq>\n  x * nn ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0}) mod q\n\ngoal (1 subgoal):\n 1. (\\<lambda>b. x * b mod q) ` ({..<q} - {0}) \\<subseteq> {..<q} - {0}", "moreover"], ["proof (state)\nthis:\n  0 \\<noteq>\n  x * nn ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0}) mod q\n\ngoal (1 subgoal):\n 1. (\\<lambda>b. x * b mod q) ` ({..<q} - {0}) \\<subseteq> {..<q} - {0}", "{"], ["proof (state)\nthis:\n  0 \\<noteq>\n  x * nn ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0}) mod q\n\ngoal (1 subgoal):\n 1. (\\<lambda>b. x * b mod q) ` ({..<q} - {0}) \\<subseteq> {..<q} - {0}", "assume \"x * nn ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0}) mod q \\<in> insert 0 {..<q} \\<and> x * nn ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0}) mod q \\<notin> {0}\""], ["proof (state)\nthis:\n  x * nn ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0}) mod q\n  \\<in> insert 0 {..<q} \\<and>\n  x * nn ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0}) mod q\n  \\<notin> {0}\n\ngoal (1 subgoal):\n 1. (\\<lambda>b. x * b mod q) ` ({..<q} - {0}) \\<subseteq> {..<q} - {0}", "hence \"(\\<lambda>n. x * n mod q) ` ({..<q} - {0}) \\<subseteq> {..<q} - {0}\""], ["proof (prove)\nusing this:\n  x * nn ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0}) mod q\n  \\<in> insert 0 {..<q} \\<and>\n  x * nn ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0}) mod q\n  \\<notin> {0}\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. x * n mod q) ` ({..<q} - {0}) \\<subseteq> {..<q} - {0}", "using 3 1"], ["proof (prove)\nusing this:\n  x * nn ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0}) mod q\n  \\<in> insert 0 {..<q} \\<and>\n  x * nn ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0}) mod q\n  \\<notin> {0}\n  (x * nn ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0}) mod q\n   \\<in> insert 0 {..<q} - {0}) =\n  (x * nn ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0}) mod q\n   \\<in> {..<q} - {0})\n  \\<forall>N f Na.\n     nn Na f N \\<in> N \\<and> f (nn Na f N) \\<notin> Na \\<or>\n     f ` N \\<subseteq> Na\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. x * n mod q) ` ({..<q} - {0}) \\<subseteq> {..<q} - {0}", "by (meson Diff_iff)"], ["proof (state)\nthis:\n  (\\<lambda>n. x * n mod q) ` ({..<q} - {0}) \\<subseteq> {..<q} - {0}\n\ngoal (1 subgoal):\n 1. (\\<lambda>b. x * b mod q) ` ({..<q} - {0}) \\<subseteq> {..<q} - {0}", "}"], ["proof (state)\nthis:\n  x * nn ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0}) mod q\n  \\<in> insert 0 {..<q} \\<and>\n  x * nn ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0}) mod q\n  \\<notin> {0} \\<Longrightarrow>\n  (\\<lambda>n. x * n mod q) ` ({..<q} - {0}) \\<subseteq> {..<q} - {0}\n\ngoal (1 subgoal):\n 1. (\\<lambda>b. x * b mod q) ` ({..<q} - {0}) \\<subseteq> {..<q} - {0}", "ultimately"], ["proof (chain)\npicking this:\n  0 \\<noteq>\n  x * nn ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0}) mod q\n  x * nn ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0}) mod q\n  \\<in> insert 0 {..<q} \\<and>\n  x * nn ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0}) mod q\n  \\<notin> {0} \\<Longrightarrow>\n  (\\<lambda>n. x * n mod q) ` ({..<q} - {0}) \\<subseteq> {..<q} - {0}", "have \"(\\<lambda>n. x * n mod q) ` ({..<q} - {0}) \\<subseteq> {..<q} - {0} \\<or> (0 \\<le> q) = (0 = q)\""], ["proof (prove)\nusing this:\n  0 \\<noteq>\n  x * nn ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0}) mod q\n  x * nn ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0}) mod q\n  \\<in> insert 0 {..<q} \\<and>\n  x * nn ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0}) mod q\n  \\<notin> {0} \\<Longrightarrow>\n  (\\<lambda>n. x * n mod q) ` ({..<q} - {0}) \\<subseteq> {..<q} - {0}\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. x * n mod q) ` ({..<q} - {0})\n    \\<subseteq> {..<q} - {0} \\<or>\n    (0 \\<le> q) = (0 = q)", "using 2"], ["proof (prove)\nusing this:\n  0 \\<noteq>\n  x * nn ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0}) mod q\n  x * nn ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0}) mod q\n  \\<in> insert 0 {..<q} \\<and>\n  x * nn ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0}) mod q\n  \\<notin> {0} \\<Longrightarrow>\n  (\\<lambda>n. x * n mod q) ` ({..<q} - {0}) \\<subseteq> {..<q} - {0}\n  x * nn ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0}) mod q\n  \\<notin> {..<q} \\<or>\n  x * nn ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0}) mod q\n  \\<in> insert 0 {..<q}\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. x * n mod q) ` ({..<q} - {0})\n    \\<subseteq> {..<q} - {0} \\<or>\n    (0 \\<le> q) = (0 = q)", "by (metis antisym_conv1 lessThan_iff mod_less_divisor singletonD)"], ["proof (state)\nthis:\n  (\\<lambda>n. x * n mod q) ` ({..<q} - {0}) \\<subseteq> {..<q} - {0} \\<or>\n  (0 \\<le> q) = (0 = q)\n\ngoal (1 subgoal):\n 1. (\\<lambda>b. x * b mod q) ` ({..<q} - {0}) \\<subseteq> {..<q} - {0}", "}"], ["proof (state)\nthis:\n  0 \\<noteq>\n  x * nn ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0}) mod\n  q \\<Longrightarrow>\n  (\\<lambda>n. x * n mod q) ` ({..<q} - {0}) \\<subseteq> {..<q} - {0} \\<or>\n  (0 \\<le> q) = (0 = q)\n\ngoal (1 subgoal):\n 1. (\\<lambda>b. x * b mod q) ` ({..<q} - {0}) \\<subseteq> {..<q} - {0}", "ultimately"], ["proof (chain)\npicking this:\n  x * nn ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0}) mod q =\n  x * 0 mod q \\<Longrightarrow>\n  (0 \\<le> q) = (0 = q) \\<or>\n  (nn ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0})\n   \\<notin> {..<q} \\<or>\n   nn ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0})\n   \\<in> {0}) \\<or>\n  nn ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0})\n  \\<notin> {..<q} - {0} \\<or>\n  x * nn ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0}) mod q\n  \\<in> {..<q} - {0}\n  0 \\<noteq>\n  x * nn ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0}) mod\n  q \\<Longrightarrow>\n  (\\<lambda>n. x * n mod q) ` ({..<q} - {0}) \\<subseteq> {..<q} - {0} \\<or>\n  (0 \\<le> q) = (0 = q)", "have \"(\\<lambda>n. x * n mod q) ` ({..<q} - {0}) \\<subseteq> {..<q} - {0} \\<or> nn ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0}) \\<notin> {..<q} - {0} \\<or> x * nn ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0}) mod q \\<in> {..<q} - {0}\""], ["proof (prove)\nusing this:\n  x * nn ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0}) mod q =\n  x * 0 mod q \\<Longrightarrow>\n  (0 \\<le> q) = (0 = q) \\<or>\n  (nn ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0})\n   \\<notin> {..<q} \\<or>\n   nn ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0})\n   \\<in> {0}) \\<or>\n  nn ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0})\n  \\<notin> {..<q} - {0} \\<or>\n  x * nn ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0}) mod q\n  \\<in> {..<q} - {0}\n  0 \\<noteq>\n  x * nn ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0}) mod\n  q \\<Longrightarrow>\n  (\\<lambda>n. x * n mod q) ` ({..<q} - {0}) \\<subseteq> {..<q} - {0} \\<or>\n  (0 \\<le> q) = (0 = q)\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. x * n mod q) ` ({..<q} - {0})\n    \\<subseteq> {..<q} - {0} \\<or>\n    nn ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0})\n    \\<notin> {..<q} - {0} \\<or>\n    x * nn ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0}) mod q\n    \\<in> {..<q} - {0}", "by force"], ["proof (state)\nthis:\n  (\\<lambda>n. x * n mod q) ` ({..<q} - {0}) \\<subseteq> {..<q} - {0} \\<or>\n  nn ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0})\n  \\<notin> {..<q} - {0} \\<or>\n  x * nn ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0}) mod q\n  \\<in> {..<q} - {0}\n\ngoal (1 subgoal):\n 1. (\\<lambda>b. x * b mod q) ` ({..<q} - {0}) \\<subseteq> {..<q} - {0}", "thus \"(\\<lambda>n. x * n mod q) ` ({..<q} - {0}) \\<subseteq> {..<q} - {0}\""], ["proof (prove)\nusing this:\n  (\\<lambda>n. x * n mod q) ` ({..<q} - {0}) \\<subseteq> {..<q} - {0} \\<or>\n  nn ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0})\n  \\<notin> {..<q} - {0} \\<or>\n  x * nn ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0}) mod q\n  \\<in> {..<q} - {0}\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. x * n mod q) ` ({..<q} - {0}) \\<subseteq> {..<q} - {0}", "using 1"], ["proof (prove)\nusing this:\n  (\\<lambda>n. x * n mod q) ` ({..<q} - {0}) \\<subseteq> {..<q} - {0} \\<or>\n  nn ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0})\n  \\<notin> {..<q} - {0} \\<or>\n  x * nn ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0}) mod q\n  \\<in> {..<q} - {0}\n  \\<forall>N f Na.\n     nn Na f N \\<in> N \\<and> f (nn Na f N) \\<notin> Na \\<or>\n     f ` N \\<subseteq> Na\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. x * n mod q) ` ({..<q} - {0}) \\<subseteq> {..<q} - {0}", "by meson"], ["proof (state)\nthis:\n  (\\<lambda>n. x * n mod q) ` ({..<q} - {0}) \\<subseteq> {..<q} - {0}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<lambda>b. x * b mod q) ` ({..<q} - {0}) \\<subseteq> {..<q} - {0}\n\ngoal (1 subgoal):\n 1. inj_on (\\<lambda>b. x * b mod q) ({..<q} - {0})", "show \"inj_on (\\<lambda>b. x * b mod q) ({..<q} - {0})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (\\<lambda>b. x * b mod q) ({..<q} - {0})", "using inj"], ["proof (prove)\nusing this:\n  inj_on (\\<lambda>b. x * b mod q) ({..<q} - {0})\n\ngoal (1 subgoal):\n 1. inj_on (\\<lambda>b. x * b mod q) ({..<q} - {0})", "by blast"], ["proof (state)\nthis:\n  inj_on (\\<lambda>b. x * b mod q) ({..<q} - {0})\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mult_one_time_pad':\n  assumes coprime: \"coprime x q\" \n  shows \"map_spmf (\\<lambda> b. x*b mod q) (sample_uniform_units q) = sample_uniform_units q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_spmf (\\<lambda>b. x * b mod q) (sample_uniform_units q) =\n    sample_uniform_units q", "using inj_on_mult' surj_on_mult' one_time_pad' coprime"], ["proof (prove)\nusing this:\n  coprime ?x ?q \\<Longrightarrow>\n  inj_on (\\<lambda>b. ?x * b mod ?q) ({..<?q} - {0})\n  \\<lbrakk>coprime ?x ?q;\n   inj_on (\\<lambda>b. ?x * b mod ?q) ({..<?q} - {0})\\<rbrakk>\n  \\<Longrightarrow> (\\<lambda>b. ?x * b mod ?q) ` ({..<?q} - {0}) =\n                    {..<?q} - {0}\n  \\<lbrakk>inj_on ?f ({..<?q} - {0});\n   ?f ` ({..<?q} - {0}) = {..<?q} - {0}\\<rbrakk>\n  \\<Longrightarrow> map_spmf ?f (sample_uniform_units ?q) =\n                    sample_uniform_units ?q\n  coprime x q\n\ngoal (1 subgoal):\n 1. map_spmf (\\<lambda>b. x * b mod q) (sample_uniform_units q) =\n    sample_uniform_units q", "by simp"], ["", "(*y + x*b*)"], ["", "lemma samp_uni_add_mult: \n  assumes coprime: \"coprime x (q::nat)\" \n    and x': \"x' < q\" \n    and y': \"y' < q\" \n    and map: \"(y + x * x') mod q = (y + x * y') mod q\" \n  shows \"x' = y'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x' = y'", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. x' = y'", "have \"(y + x * x') mod q = (y + x * y') mod q \\<Longrightarrow> x' mod q = y' mod q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (y + x * x') mod q = (y + x * y') mod q \\<Longrightarrow>\n    x' mod q = y' mod q", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. (y + x * x') mod q = (y + x * y') mod q \\<Longrightarrow>\n    x' mod q = y' mod q", "have \"(y + x * x') mod q = (y + x * y') mod q \\<Longrightarrow> [y + x*x' = y + x *y'] (mod q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (y + x * x') mod q = (y + x * y') mod q \\<Longrightarrow>\n    [y + x * x' = y + x * y'] (mod q)", "using cong_def"], ["proof (prove)\nusing this:\n  [?b = ?c] (mod ?a) = (?b mod ?a = ?c mod ?a)\n\ngoal (1 subgoal):\n 1. (y + x * x') mod q = (y + x * y') mod q \\<Longrightarrow>\n    [y + x * x' = y + x * y'] (mod q)", "by blast"], ["proof (state)\nthis:\n  (y + x * x') mod q = (y + x * y') mod q \\<Longrightarrow>\n  [y + x * x' = y + x * y'] (mod q)\n\ngoal (1 subgoal):\n 1. (y + x * x') mod q = (y + x * y') mod q \\<Longrightarrow>\n    x' mod q = y' mod q", "moreover"], ["proof (state)\nthis:\n  (y + x * x') mod q = (y + x * y') mod q \\<Longrightarrow>\n  [y + x * x' = y + x * y'] (mod q)\n\ngoal (1 subgoal):\n 1. (y + x * x') mod q = (y + x * y') mod q \\<Longrightarrow>\n    x' mod q = y' mod q", "have \"[y + x*x' = y + x *y'] (mod q) \\<Longrightarrow> [x' = y'] (mod q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [y + x * x' = y + x * y'] (mod q) \\<Longrightarrow> [x' = y'] (mod q)", "by(simp add: cong_add_lcancel_nat)(simp add: coprime cong_mult_lcancel_nat)"], ["proof (state)\nthis:\n  [y + x * x' = y + x * y'] (mod q) \\<Longrightarrow> [x' = y'] (mod q)\n\ngoal (1 subgoal):\n 1. (y + x * x') mod q = (y + x * y') mod q \\<Longrightarrow>\n    x' mod q = y' mod q", "ultimately"], ["proof (chain)\npicking this:\n  (y + x * x') mod q = (y + x * y') mod q \\<Longrightarrow>\n  [y + x * x' = y + x * y'] (mod q)\n  [y + x * x' = y + x * y'] (mod q) \\<Longrightarrow> [x' = y'] (mod q)", "show ?thesis"], ["proof (prove)\nusing this:\n  (y + x * x') mod q = (y + x * y') mod q \\<Longrightarrow>\n  [y + x * x' = y + x * y'] (mod q)\n  [y + x * x' = y + x * y'] (mod q) \\<Longrightarrow> [x' = y'] (mod q)\n\ngoal (1 subgoal):\n 1. x' mod q = y' mod q", "by(simp add: cong_def map)"], ["proof (state)\nthis:\n  x' mod q = y' mod q\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (y + x * x') mod q = (y + x * y') mod q \\<Longrightarrow>\n  x' mod q = y' mod q\n\ngoal (1 subgoal):\n 1. x' = y'", "moreover"], ["proof (state)\nthis:\n  (y + x * x') mod q = (y + x * y') mod q \\<Longrightarrow>\n  x' mod q = y' mod q\n\ngoal (1 subgoal):\n 1. x' = y'", "have \"x' mod q = y' mod q \\<Longrightarrow> x' = y'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x' mod q = y' mod q \\<Longrightarrow> x' = y'", "by(simp add: x' y')"], ["proof (state)\nthis:\n  x' mod q = y' mod q \\<Longrightarrow> x' = y'\n\ngoal (1 subgoal):\n 1. x' = y'", "ultimately"], ["proof (chain)\npicking this:\n  (y + x * x') mod q = (y + x * y') mod q \\<Longrightarrow>\n  x' mod q = y' mod q\n  x' mod q = y' mod q \\<Longrightarrow> x' = y'", "show ?thesis"], ["proof (prove)\nusing this:\n  (y + x * x') mod q = (y + x * y') mod q \\<Longrightarrow>\n  x' mod q = y' mod q\n  x' mod q = y' mod q \\<Longrightarrow> x' = y'\n\ngoal (1 subgoal):\n 1. x' = y'", "by(simp add: map)"], ["proof (state)\nthis:\n  x' = y'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma inj_on_add_mult: \n  assumes coprime: \"coprime x (q::nat)\" \n  shows \"inj_on (\\<lambda> b. (y + x*b) mod q) {..<q}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (\\<lambda>b. (y + x * b) mod q) {..<q}", "apply(auto simp add: inj_on_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa ya.\n       \\<lbrakk>xa < q; ya < q;\n        (y + x * xa) mod q = (y + x * ya) mod q\\<rbrakk>\n       \\<Longrightarrow> xa = ya", "using coprime"], ["proof (prove)\nusing this:\n  coprime x q\n\ngoal (1 subgoal):\n 1. \\<And>xa ya.\n       \\<lbrakk>xa < q; ya < q;\n        (y + x * xa) mod q = (y + x * ya) mod q\\<rbrakk>\n       \\<Longrightarrow> xa = ya", "by(simp only: samp_uni_add_mult)"], ["", "lemma surj_on_add_mult: \n  assumes coprime: \"coprime x (q::nat)\" \n    and inj: \"inj_on (\\<lambda> b. (y + x*b) mod q) {..<q}\" \n  shows \"(\\<lambda> b. (y + x*b) mod q) ` {..< q} = {..< q}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>b. (y + x * b) mod q) ` {..<q} = {..<q}", "apply(rule endo_inj_surj)"], ["proof (prove)\ngoal (3 subgoals):\n 1. finite {..<q}\n 2. (\\<lambda>b. (y + x * b) mod q) ` {..<q} \\<subseteq> {..<q}\n 3. inj_on (\\<lambda>b. (y + x * b) mod q) {..<q}", "using coprime inj"], ["proof (prove)\nusing this:\n  coprime x q\n  inj_on (\\<lambda>b. (y + x * b) mod q) {..<q}\n\ngoal (3 subgoals):\n 1. finite {..<q}\n 2. (\\<lambda>b. (y + x * b) mod q) ` {..<q} \\<subseteq> {..<q}\n 3. inj_on (\\<lambda>b. (y + x * b) mod q) {..<q}", "by auto"], ["", "lemma add_mult_one_time_pad: \n  assumes coprime: \"coprime x q\" \n  shows \"map_spmf (\\<lambda> b. (y + x*b) mod q) (sample_uniform q) = (sample_uniform q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_spmf (\\<lambda>b. (y + x * b) mod q) (sample_uniform q) =\n    sample_uniform q", "using inj_on_add_mult surj_on_add_mult one_time_pad coprime"], ["proof (prove)\nusing this:\n  coprime ?x ?q \\<Longrightarrow>\n  inj_on (\\<lambda>b. (?y + ?x * b) mod ?q) {..<?q}\n  \\<lbrakk>coprime ?x ?q;\n   inj_on (\\<lambda>b. (?y + ?x * b) mod ?q) {..<?q}\\<rbrakk>\n  \\<Longrightarrow> (\\<lambda>b. (?y + ?x * b) mod ?q) ` {..<?q} = {..<?q}\n  \\<lbrakk>inj_on ?f {..<?q}; ?f ` {..<?q} = {..<?q}\\<rbrakk>\n  \\<Longrightarrow> map_spmf ?f (sample_uniform ?q) = sample_uniform ?q\n  coprime x q\n\ngoal (1 subgoal):\n 1. map_spmf (\\<lambda>b. (y + x * b) mod q) (sample_uniform q) =\n    sample_uniform q", "by simp"], ["", "(*(y - b) *)"], ["", "lemma inj_on_minus: \"inj_on  (\\<lambda>(b :: nat). (y + (q - b)) mod q ) {..<q}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (\\<lambda>b. (y + (q - b)) mod q) {..<q}", "proof(unfold inj_on_def; auto)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x ya.\n       \\<lbrakk>x < q; ya < q;\n        (y + q - x) mod q = (y + q - ya) mod q\\<rbrakk>\n       \\<Longrightarrow> x = ya", "fix x :: nat and y' :: nat"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x ya.\n       \\<lbrakk>x < q; ya < q;\n        (y + q - x) mod q = (y + q - ya) mod q\\<rbrakk>\n       \\<Longrightarrow> x = ya", "assume x: \"x < q\""], ["proof (state)\nthis:\n  x < q\n\ngoal (1 subgoal):\n 1. \\<And>x ya.\n       \\<lbrakk>x < q; ya < q;\n        (y + q - x) mod q = (y + q - ya) mod q\\<rbrakk>\n       \\<Longrightarrow> x = ya", "assume y': \"y' < q\""], ["proof (state)\nthis:\n  y' < q\n\ngoal (1 subgoal):\n 1. \\<And>x ya.\n       \\<lbrakk>x < q; ya < q;\n        (y + q - x) mod q = (y + q - ya) mod q\\<rbrakk>\n       \\<Longrightarrow> x = ya", "assume map: \"(y + q - x) mod q = (y + q - y') mod q\""], ["proof (state)\nthis:\n  (y + q - x) mod q = (y + q - y') mod q\n\ngoal (1 subgoal):\n 1. \\<And>x ya.\n       \\<lbrakk>x < q; ya < q;\n        (y + q - x) mod q = (y + q - ya) mod q\\<rbrakk>\n       \\<Longrightarrow> x = ya", "have \"\\<forall>n na p. \\<exists>nb. \\<forall>nc nd pa. (\\<not> (nc::nat) < nd \\<or> \\<not> pa (nc - nd) \\<or> pa 0) \\<and> (\\<not> p (0::nat) \\<or> p (n - na) \\<or> na + nb = n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n na p.\n       \\<exists>nb.\n          \\<forall>nc nd pa.\n             (\\<not> nc < nd \\<or> \\<not> pa (nc - nd) \\<or> pa 0) \\<and>\n             (\\<not> p 0 \\<or> p (n - na) \\<or> na + nb = n)", "by (metis (no_types) nat_diff_split)"], ["proof (state)\nthis:\n  \\<forall>n na p.\n     \\<exists>nb.\n        \\<forall>nc nd pa.\n           (\\<not> nc < nd \\<or> \\<not> pa (nc - nd) \\<or> pa 0) \\<and>\n           (\\<not> p 0 \\<or> p (n - na) \\<or> na + nb = n)\n\ngoal (1 subgoal):\n 1. \\<And>x ya.\n       \\<lbrakk>x < q; ya < q;\n        (y + q - x) mod q = (y + q - ya) mod q\\<rbrakk>\n       \\<Longrightarrow> x = ya", "hence \"\\<not> y < y' - q \\<and> \\<not> y < x - q\""], ["proof (prove)\nusing this:\n  \\<forall>n na p.\n     \\<exists>nb.\n        \\<forall>nc nd pa.\n           (\\<not> nc < nd \\<or> \\<not> pa (nc - nd) \\<or> pa 0) \\<and>\n           (\\<not> p 0 \\<or> p (n - na) \\<or> na + nb = n)\n\ngoal (1 subgoal):\n 1. \\<not> y < y' - q \\<and> \\<not> y < x - q", "using y' x"], ["proof (prove)\nusing this:\n  \\<forall>n na p.\n     \\<exists>nb.\n        \\<forall>nc nd pa.\n           (\\<not> nc < nd \\<or> \\<not> pa (nc - nd) \\<or> pa 0) \\<and>\n           (\\<not> p 0 \\<or> p (n - na) \\<or> na + nb = n)\n  y' < q\n  x < q\n\ngoal (1 subgoal):\n 1. \\<not> y < y' - q \\<and> \\<not> y < x - q", "by (metis add.commute less_diff_conv not_add_less2)"], ["proof (state)\nthis:\n  \\<not> y < y' - q \\<and> \\<not> y < x - q\n\ngoal (1 subgoal):\n 1. \\<And>x ya.\n       \\<lbrakk>x < q; ya < q;\n        (y + q - x) mod q = (y + q - ya) mod q\\<rbrakk>\n       \\<Longrightarrow> x = ya", "hence \"\\<exists>n. (y' + n) mod q = (n + x) mod q\""], ["proof (prove)\nusing this:\n  \\<not> y < y' - q \\<and> \\<not> y < x - q\n\ngoal (1 subgoal):\n 1. \\<exists>n. (y' + n) mod q = (n + x) mod q", "using map"], ["proof (prove)\nusing this:\n  \\<not> y < y' - q \\<and> \\<not> y < x - q\n  (y + q - x) mod q = (y + q - y') mod q\n\ngoal (1 subgoal):\n 1. \\<exists>n. (y' + n) mod q = (n + x) mod q", "by (metis add.commute add_diff_inverse_nat less_diff_conv mod_add_left_eq)"], ["proof (state)\nthis:\n  \\<exists>n. (y' + n) mod q = (n + x) mod q\n\ngoal (1 subgoal):\n 1. \\<And>x ya.\n       \\<lbrakk>x < q; ya < q;\n        (y + q - x) mod q = (y + q - ya) mod q\\<rbrakk>\n       \\<Longrightarrow> x = ya", "thus \"x = y'\""], ["proof (prove)\nusing this:\n  \\<exists>n. (y' + n) mod q = (n + x) mod q\n\ngoal (1 subgoal):\n 1. x = y'", "by (metis plus_inj_eq  x y' add.commute)"], ["proof (state)\nthis:\n  x = y'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma surj_on_minus: \n  assumes inj: \"inj_on  (\\<lambda>(b :: nat). (y + (q - b)) mod q ) {..<q}\" \n  shows \"(\\<lambda>(b :: nat). (y + (q - b)) mod q) ` {..< q} = {..< q}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>b. (y + (q - b)) mod q) ` {..<q} = {..<q}", "apply(rule endo_inj_surj)"], ["proof (prove)\ngoal (3 subgoals):\n 1. finite {..<q}\n 2. (\\<lambda>b. (y + (q - b)) mod q) ` {..<q} \\<subseteq> {..<q}\n 3. inj_on (\\<lambda>b. (y + (q - b)) mod q) {..<q}", "using inj"], ["proof (prove)\nusing this:\n  inj_on (\\<lambda>b. (y + (q - b)) mod q) {..<q}\n\ngoal (3 subgoals):\n 1. finite {..<q}\n 2. (\\<lambda>b. (y + (q - b)) mod q) ` {..<q} \\<subseteq> {..<q}\n 3. inj_on (\\<lambda>b. (y + (q - b)) mod q) {..<q}", "by auto"], ["", "lemma samp_uni_minus_one_time_pad: \n  shows \"map_spmf(\\<lambda> b. (y + (q - b)) mod q) (sample_uniform q) = sample_uniform q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_spmf (\\<lambda>b. (y + (q - b)) mod q) (sample_uniform q) =\n    sample_uniform q", "using inj_on_minus surj_on_minus one_time_pad"], ["proof (prove)\nusing this:\n  inj_on (\\<lambda>b. (?y + (?q - b)) mod ?q) {..<?q}\n  inj_on (\\<lambda>b. (?y + (?q - b)) mod ?q) {..<?q} \\<Longrightarrow>\n  (\\<lambda>b. (?y + (?q - b)) mod ?q) ` {..<?q} = {..<?q}\n  \\<lbrakk>inj_on ?f {..<?q}; ?f ` {..<?q} = {..<?q}\\<rbrakk>\n  \\<Longrightarrow> map_spmf ?f (sample_uniform ?q) = sample_uniform ?q\n\ngoal (1 subgoal):\n 1. map_spmf (\\<lambda>b. (y + (q - b)) mod q) (sample_uniform q) =\n    sample_uniform q", "by simp"], ["", "lemma not_coin_spmf: \"map_spmf (\\<lambda> a. \\<not> a) coin_spmf = coin_spmf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_spmf Not coin_spmf = coin_spmf", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. map_spmf Not coin_spmf = coin_spmf", "have \"inj_on Not {True, False}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on Not {True, False}", "by simp"], ["proof (state)\nthis:\n  inj_on Not {True, False}\n\ngoal (1 subgoal):\n 1. map_spmf Not coin_spmf = coin_spmf", "moreover"], ["proof (state)\nthis:\n  inj_on Not {True, False}\n\ngoal (1 subgoal):\n 1. map_spmf Not coin_spmf = coin_spmf", "have  \"Not ` {True, False} = {True, False}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Not ` {True, False} = {True, False}", "by auto"], ["proof (state)\nthis:\n  Not ` {True, False} = {True, False}\n\ngoal (1 subgoal):\n 1. map_spmf Not coin_spmf = coin_spmf", "ultimately"], ["proof (chain)\npicking this:\n  inj_on Not {True, False}\n  Not ` {True, False} = {True, False}", "show ?thesis"], ["proof (prove)\nusing this:\n  inj_on Not {True, False}\n  Not ` {True, False} = {True, False}\n\ngoal (1 subgoal):\n 1. map_spmf Not coin_spmf = coin_spmf", "using one_time_pad"], ["proof (prove)\nusing this:\n  inj_on Not {True, False}\n  Not ` {True, False} = {True, False}\n  \\<lbrakk>inj_on ?f {..<?q}; ?f ` {..<?q} = {..<?q}\\<rbrakk>\n  \\<Longrightarrow> map_spmf ?f (sample_uniform ?q) = sample_uniform ?q\n\ngoal (1 subgoal):\n 1. map_spmf Not coin_spmf = coin_spmf", "by (simp add: UNIV_bool)"], ["proof (state)\nthis:\n  map_spmf Not coin_spmf = coin_spmf\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma xor_uni_samp: \"map_spmf(\\<lambda> b. y \\<oplus> b) (coin_spmf) = map_spmf(\\<lambda> b. b) (coin_spmf)\"\n  (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_spmf ((\\<oplus>) y) coin_spmf = map_spmf (\\<lambda>b. b) coin_spmf", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. map_spmf ((\\<oplus>) y) coin_spmf = map_spmf (\\<lambda>b. b) coin_spmf", "have rhs: \"?rhs = spmf_of_set {True, False}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_spmf (\\<lambda>b. b) coin_spmf = spmf_of_set {True, False}", "by (simp add: UNIV_bool insert_commute)"], ["proof (state)\nthis:\n  map_spmf (\\<lambda>b. b) coin_spmf = spmf_of_set {True, False}\n\ngoal (1 subgoal):\n 1. map_spmf ((\\<oplus>) y) coin_spmf = map_spmf (\\<lambda>b. b) coin_spmf", "also"], ["proof (state)\nthis:\n  map_spmf (\\<lambda>b. b) coin_spmf = spmf_of_set {True, False}\n\ngoal (1 subgoal):\n 1. map_spmf ((\\<oplus>) y) coin_spmf = map_spmf (\\<lambda>b. b) coin_spmf", "have \"map_spmf(\\<lambda> b. y \\<oplus> b) (spmf_of_set {True, False}) = spmf_of_set((\\<lambda> b. y \\<oplus> b) ` {True, False})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_spmf ((\\<oplus>) y) (spmf_of_set {True, False}) =\n    spmf_of_set ((\\<oplus>) y ` {True, False})", "by (simp add: xor_def)"], ["proof (state)\nthis:\n  map_spmf ((\\<oplus>) y) (spmf_of_set {True, False}) =\n  spmf_of_set ((\\<oplus>) y ` {True, False})\n\ngoal (1 subgoal):\n 1. map_spmf ((\\<oplus>) y) coin_spmf = map_spmf (\\<lambda>b. b) coin_spmf", "also"], ["proof (state)\nthis:\n  map_spmf ((\\<oplus>) y) (spmf_of_set {True, False}) =\n  spmf_of_set ((\\<oplus>) y ` {True, False})\n\ngoal (1 subgoal):\n 1. map_spmf ((\\<oplus>) y) coin_spmf = map_spmf (\\<lambda>b. b) coin_spmf", "have \"(\\<lambda> b. xor y b) ` {True, False} = {True, False}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<oplus>) y ` {True, False} = {True, False}", "using xor_def"], ["proof (prove)\nusing this:\n  ?x \\<oplus> ?y = (?x \\<squnion> ?y) \\<sqinter> - (?x \\<sqinter> ?y)\n\ngoal (1 subgoal):\n 1. (\\<oplus>) y ` {True, False} = {True, False}", "by auto"], ["proof (state)\nthis:\n  (\\<oplus>) y ` {True, False} = {True, False}\n\ngoal (1 subgoal):\n 1. map_spmf ((\\<oplus>) y) coin_spmf = map_spmf (\\<lambda>b. b) coin_spmf", "finally"], ["proof (chain)\npicking this:\n  map_spmf ((\\<oplus>) y) (map_spmf (\\<lambda>b. b) coin_spmf) =\n  spmf_of_set {True, False}", "show ?thesis"], ["proof (prove)\nusing this:\n  map_spmf ((\\<oplus>) y) (map_spmf (\\<lambda>b. b) coin_spmf) =\n  spmf_of_set {True, False}\n\ngoal (1 subgoal):\n 1. map_spmf ((\\<oplus>) y) coin_spmf = map_spmf (\\<lambda>b. b) coin_spmf", "using rhs"], ["proof (prove)\nusing this:\n  map_spmf ((\\<oplus>) y) (map_spmf (\\<lambda>b. b) coin_spmf) =\n  spmf_of_set {True, False}\n  map_spmf (\\<lambda>b. b) coin_spmf = spmf_of_set {True, False}\n\ngoal (1 subgoal):\n 1. map_spmf ((\\<oplus>) y) coin_spmf = map_spmf (\\<lambda>b. b) coin_spmf", "by(simp)"], ["proof (state)\nthis:\n  map_spmf ((\\<oplus>) y) coin_spmf = map_spmf (\\<lambda>b. b) coin_spmf\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ped_inv_mapping:\n  assumes \"(a::nat) < q\"\n    and \"[m \\<noteq> 0] (mod q)\"\n  shows \"map_spmf (\\<lambda> d. (d + a * (m::nat)) mod q) (sample_uniform q) = map_spmf (\\<lambda> d. (d + q * m - a * m) mod q) (sample_uniform q)\"\n(is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_spmf (\\<lambda>d. (d + a * m) mod q) (sample_uniform q) =\n    map_spmf (\\<lambda>d. (d + q * m - a * m) mod q) (sample_uniform q)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. map_spmf (\\<lambda>d. (d + a * m) mod q) (sample_uniform q) =\n    map_spmf (\\<lambda>d. (d + q * m - a * m) mod q) (sample_uniform q)", "have ineq: \"q * m - a * m > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < q * m - a * m", "using assms gr0I"], ["proof (prove)\nusing this:\n  a < q\n  [m \\<noteq> 0] (mod q)\n  (?n = 0 \\<Longrightarrow> False) \\<Longrightarrow> 0 < ?n\n\ngoal (1 subgoal):\n 1. 0 < q * m - a * m", "by force"], ["proof (state)\nthis:\n  0 < q * m - a * m\n\ngoal (1 subgoal):\n 1. map_spmf (\\<lambda>d. (d + a * m) mod q) (sample_uniform q) =\n    map_spmf (\\<lambda>d. (d + q * m - a * m) mod q) (sample_uniform q)", "have \"?lhs = map_spmf (\\<lambda> d. (a * m + d) mod q) (sample_uniform q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_spmf (\\<lambda>d. (d + a * m) mod q) (sample_uniform q) =\n    map_spmf (\\<lambda>d. (a * m + d) mod q) (sample_uniform q)", "using add.commute"], ["proof (prove)\nusing this:\n  ?a + ?b = ?b + ?a\n\ngoal (1 subgoal):\n 1. map_spmf (\\<lambda>d. (d + a * m) mod q) (sample_uniform q) =\n    map_spmf (\\<lambda>d. (a * m + d) mod q) (sample_uniform q)", "by metis"], ["proof (state)\nthis:\n  map_spmf (\\<lambda>d. (d + a * m) mod q) (sample_uniform q) =\n  map_spmf (\\<lambda>d. (a * m + d) mod q) (sample_uniform q)\n\ngoal (1 subgoal):\n 1. map_spmf (\\<lambda>d. (d + a * m) mod q) (sample_uniform q) =\n    map_spmf (\\<lambda>d. (d + q * m - a * m) mod q) (sample_uniform q)", "also"], ["proof (state)\nthis:\n  map_spmf (\\<lambda>d. (d + a * m) mod q) (sample_uniform q) =\n  map_spmf (\\<lambda>d. (a * m + d) mod q) (sample_uniform q)\n\ngoal (1 subgoal):\n 1. map_spmf (\\<lambda>d. (d + a * m) mod q) (sample_uniform q) =\n    map_spmf (\\<lambda>d. (d + q * m - a * m) mod q) (sample_uniform q)", "have \"... = sample_uniform q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_spmf (\\<lambda>d. (a * m + d) mod q) (sample_uniform q) =\n    sample_uniform q", "using samp_uni_plus_one_time_pad"], ["proof (prove)\nusing this:\n  map_spmf (\\<lambda>b. (?y + b) mod ?q) (sample_uniform ?q) =\n  sample_uniform ?q\n\ngoal (1 subgoal):\n 1. map_spmf (\\<lambda>d. (a * m + d) mod q) (sample_uniform q) =\n    sample_uniform q", "by simp"], ["proof (state)\nthis:\n  map_spmf (\\<lambda>d. (a * m + d) mod q) (sample_uniform q) =\n  sample_uniform q\n\ngoal (1 subgoal):\n 1. map_spmf (\\<lambda>d. (d + a * m) mod q) (sample_uniform q) =\n    map_spmf (\\<lambda>d. (d + q * m - a * m) mod q) (sample_uniform q)", "also"], ["proof (state)\nthis:\n  map_spmf (\\<lambda>d. (a * m + d) mod q) (sample_uniform q) =\n  sample_uniform q\n\ngoal (1 subgoal):\n 1. map_spmf (\\<lambda>d. (d + a * m) mod q) (sample_uniform q) =\n    map_spmf (\\<lambda>d. (d + q * m - a * m) mod q) (sample_uniform q)", "have \"... = map_spmf (\\<lambda> d. ((q * m - a * m) + d) mod q) (sample_uniform q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sample_uniform q =\n    map_spmf (\\<lambda>d. (q * m - a * m + d) mod q) (sample_uniform q)", "using ineq samp_uni_plus_one_time_pad"], ["proof (prove)\nusing this:\n  0 < q * m - a * m\n  map_spmf (\\<lambda>b. (?y + b) mod ?q) (sample_uniform ?q) =\n  sample_uniform ?q\n\ngoal (1 subgoal):\n 1. sample_uniform q =\n    map_spmf (\\<lambda>d. (q * m - a * m + d) mod q) (sample_uniform q)", "by metis"], ["proof (state)\nthis:\n  sample_uniform q =\n  map_spmf (\\<lambda>d. (q * m - a * m + d) mod q) (sample_uniform q)\n\ngoal (1 subgoal):\n 1. map_spmf (\\<lambda>d. (d + a * m) mod q) (sample_uniform q) =\n    map_spmf (\\<lambda>d. (d + q * m - a * m) mod q) (sample_uniform q)", "ultimately"], ["proof (chain)\npicking this:\n  map_spmf (\\<lambda>d. (d + a * m) mod q) (sample_uniform q) =\n  sample_uniform q\n  sample_uniform q =\n  map_spmf (\\<lambda>d. (q * m - a * m + d) mod q) (sample_uniform q)", "show ?thesis"], ["proof (prove)\nusing this:\n  map_spmf (\\<lambda>d. (d + a * m) mod q) (sample_uniform q) =\n  sample_uniform q\n  sample_uniform q =\n  map_spmf (\\<lambda>d. (q * m - a * m + d) mod q) (sample_uniform q)\n\ngoal (1 subgoal):\n 1. map_spmf (\\<lambda>d. (d + a * m) mod q) (sample_uniform q) =\n    map_spmf (\\<lambda>d. (d + q * m - a * m) mod q) (sample_uniform q)", "using add.commute ineq"], ["proof (prove)\nusing this:\n  map_spmf (\\<lambda>d. (d + a * m) mod q) (sample_uniform q) =\n  sample_uniform q\n  sample_uniform q =\n  map_spmf (\\<lambda>d. (q * m - a * m + d) mod q) (sample_uniform q)\n  ?a + ?b = ?b + ?a\n  0 < q * m - a * m\n\ngoal (1 subgoal):\n 1. map_spmf (\\<lambda>d. (d + a * m) mod q) (sample_uniform q) =\n    map_spmf (\\<lambda>d. (d + q * m - a * m) mod q) (sample_uniform q)", "by (simp add: Groups.add_ac(2))"], ["proof (state)\nthis:\n  map_spmf (\\<lambda>d. (d + a * m) mod q) (sample_uniform q) =\n  map_spmf (\\<lambda>d. (d + q * m - a * m) mod q) (sample_uniform q)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}