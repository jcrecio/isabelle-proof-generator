{"file_name": "/home/qj213/afp-2021-10-22/thys/Binomial-Heaps/SkewBinomialHeap.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Binomial-Heaps", "problem_names": ["lemma ttm_children: \"tree_to_multiset t = \n  {#(val t,prio t)#} + queue_to_multiset (children t)\"", "lemma qtm_conc[simp]: \"queue_to_multiset (q@q') \n  = queue_to_multiset q + queue_to_multiset q'\"", "lemma queue_invar_simps[simp]:\n  \"queue_invar []\"\n  \"queue_invar (t#q) \\<longleftrightarrow> tree_invar t \\<and> queue_invar q\"\n  \"queue_invar (q@q') \\<longleftrightarrow> queue_invar q \\<and> queue_invar q'\"\n  \"queue_invar q \\<Longrightarrow> t\\<in>set q \\<Longrightarrow> tree_invar t\"", "lemma invar_empty[simp]:\n  \"invar []\"\n  \"tail_invar []\"", "lemma invar_tail_invar: \n  \"invar (t # bq) \\<Longrightarrow> tail_invar bq\"", "lemma link_mset[simp]: \"tree_to_multiset (link t1 t2) \n                  = tree_to_multiset t1 +tree_to_multiset t2\"", "lemma link_tree_invar: \"\\<lbrakk>tree_invar t1; tree_invar t2; rank t1 = rank t2\\<rbrakk> \\<Longrightarrow>\n  tree_invar (link t1 t2)\"", "lemma skewlink_mset[simp]: \"tree_to_multiset (skewlink e a t1 t2) \n  = {# (e,a) #} +  tree_to_multiset t1 + tree_to_multiset t2\"", "lemma skewlink_tree_invar: \"\\<lbrakk>tree_invar t1; tree_invar t2; rank t1 = rank t2\\<rbrakk> \\<Longrightarrow> \n  tree_invar (skewlink e a t1 t2)\"", "lemma rank_link: \"rank t = rank t' \\<Longrightarrow> rank (link t t') = rank t + 1\"", "lemma rank_skew_rank_invar: \"rank_skew_invar (t # bq) \\<Longrightarrow> rank_invar bq\"", "lemma rank_invar_rank_skew:\n  assumes \"rank_invar q\"\n  shows \"rank_skew_invar q\"", "lemma rank_invar_cons_up: \n  \"\\<lbrakk>rank_invar (t # bq); rank t' < rank t\\<rbrakk> \\<Longrightarrow> rank_invar (t' # t # bq)\"", "lemma rank_skew_cons_up: \n  \"\\<lbrakk>rank_invar (t # bq); rank t' \\<le> rank t\\<rbrakk> \\<Longrightarrow> rank_skew_invar (t' # t # bq)\"", "lemma rank_invar_cons_down: \"rank_invar (t # bq) \\<Longrightarrow> rank_invar bq\"", "lemma rank_invar_hd_cons: \n  \"\\<lbrakk>rank_invar bq; rank t < rank (hd bq)\\<rbrakk> \\<Longrightarrow> rank_invar (t # bq)\"", "lemma tail_invar_cons_up: \n  \"\\<lbrakk>tail_invar (t # bq); rank t' < rank t; tree_invar t'\\<rbrakk> \n  \\<Longrightarrow> tail_invar (t' # t # bq)\"", "lemma tail_invar_cons_up_invar: \n  \"\\<lbrakk>tail_invar (t # bq); rank t' \\<le> rank t; tree_invar t'\\<rbrakk> \\<Longrightarrow> invar (t' # t # bq)\"", "lemma tail_invar_cons_down: \n  \"tail_invar (t # bq) \\<Longrightarrow> tail_invar bq\"", "lemma tail_invar_app_single: \n  \"\\<lbrakk>tail_invar bq; \\<forall>t \\<in> set bq. rank t < rank t'; tree_invar t'\\<rbrakk> \n    \\<Longrightarrow> tail_invar (bq @ [t'])\"", "lemma invar_app_single: \n  \"\\<lbrakk>invar bq; \\<forall>t \\<in> set bq. rank t < rank t'; tree_invar t'\\<rbrakk> \n   \\<Longrightarrow> invar (bq @ [t'])\"", "lemma invar_children: \n  assumes \"tree_invar ((Node e a r ts)::(('e, 'a::linorder) SkewBinomialTree))\"\n  shows \"queue_invar ts\"", "lemma tree_invar_heap_ordered: \n  fixes t :: \"('e, 'a::linorder) SkewBinomialTree\"\n  assumes \"tree_invar t\"\n  shows \"heap_ordered t\"", "lemma link_length: \"size (tree_to_multiset (link t1 t2)) = \n  size (tree_to_multiset t1) + size (tree_to_multiset t2)\"", "lemma tree_rank_estimate_upper: \n  \"tree_invar (Node e a r ts) \\<Longrightarrow> \n   size (tree_to_multiset (Node e a r ts)) \\<le> (2::nat)^(Suc r) - 1\"", "lemma tree_rank_estimate_lower: \n  \"tree_invar (Node e a r ts) \\<Longrightarrow> \n   size (tree_to_multiset (Node e a r ts)) \\<ge> (2::nat)^r\"", "lemma tree_rank_height:\n  \"tree_invar (Node e a r ts) \\<Longrightarrow> height_tree (Node e a r ts) = r\"", "theorem tree_height_estimate_upper:\n  \"tree_invar t \\<Longrightarrow> \n  size (tree_to_multiset t) \\<le> (2::nat)^(Suc (height_tree t)) - 1\"", "theorem tree_height_estimate_lower:\n  \"tree_invar t \\<Longrightarrow> size (tree_to_multiset t) \\<ge> (2::nat)^(height_tree t)\"", "lemma size_mset_tree_upper: \"tree_invar t \\<Longrightarrow> \n  size (tree_to_multiset t) \\<le> (2::nat)^(Suc (rank t)) - (1::nat)\"", "lemma size_mset_tree_lower: \"tree_invar t \\<Longrightarrow> \n  size (tree_to_multiset t) \\<ge> (2::nat)^(rank t)\"", "lemma invar_butlast: \"invar (bq @ [t]) \\<Longrightarrow> invar bq\"", "lemma invar_last_max: \n  \"invar ((b#b'#bq) @ [m]) \\<Longrightarrow> \\<forall> t \\<in> set (b'#bq). rank t < rank m\"", "lemma invar_last_max': \"invar ((b#b'#bq) @ [m]) \\<Longrightarrow> rank b \\<le> rank b'\"", "lemma invar_length: \"invar bq \\<Longrightarrow> length bq \\<le> Suc (Suc (rank (last bq)))\"", "lemma size_queue_sum_list: \n  \"size (queue_to_multiset bq) = sum_list (map (size \\<circ> tree_to_multiset) bq)\"", "theorem queue_length_estimate_lower: \n  \"invar bq \\<Longrightarrow> (size (queue_to_multiset bq)) \\<ge> 2^(length bq - 1) - 1\"", "lemma empty_correct: \"q=Nil \\<longleftrightarrow> queue_to_multiset q = {#}\"", "lemma ins_mset: \n  \"\\<lbrakk>tree_invar t; queue_invar q\\<rbrakk> \\<Longrightarrow>\n   queue_to_multiset (ins t q) = tree_to_multiset t + queue_to_multiset q\"", "lemma insert_mset: \"queue_invar q \\<Longrightarrow> \n  queue_to_multiset (insert e a q) = \n  queue_to_multiset q + {# (e,a) #}\"", "lemma ins_queue_invar: \"\\<lbrakk>tree_invar t; queue_invar q\\<rbrakk> \\<Longrightarrow> queue_invar (ins t q)\"", "lemma insert_queue_invar: \"queue_invar q \\<Longrightarrow> queue_invar (insert e a q)\"", "lemma rank_ins2: \n  \"rank_invar bq \\<Longrightarrow> \n    rank t \\<le> rank (hd (ins t bq)) \n    \\<or> (rank (hd (ins t bq)) = rank (hd bq) \\<and> bq \\<noteq> [])\"", "lemma insert_rank_invar: \"rank_skew_invar q \\<Longrightarrow> rank_skew_invar (insert e a q)\"", "lemma insert_invar: \"invar q \\<Longrightarrow> invar (insert e a q)\"", "theorem insert_correct:\n  assumes I: \"invar q\"\n  shows \n  \"invar (insert e a q)\"\n  \"queue_to_multiset (insert e a q) = queue_to_multiset q + {# (e,a) #}\"", "lemma invar_uniqify: \"queue_invar q \\<Longrightarrow> queue_invar (uniqify q)\"", "lemma invar_meldUniq: \"\\<lbrakk>queue_invar q; queue_invar q'\\<rbrakk> \\<Longrightarrow> queue_invar (meldUniq q q')\"", "lemma meld_queue_invar:\n  assumes \"queue_invar q\"\n    and \"queue_invar q'\"\n  shows \"queue_invar (meld q q')\"", "lemma uniqify_mset: \"queue_invar q \\<Longrightarrow> queue_to_multiset q = queue_to_multiset (uniqify q)\"", "lemma meldUniq_mset: \"\\<lbrakk>queue_invar q; queue_invar q'\\<rbrakk> \\<Longrightarrow> \n  queue_to_multiset (meldUniq q q') = \n  queue_to_multiset q + queue_to_multiset q'\"", "lemma meld_mset:\n  \"\\<lbrakk> queue_invar q; queue_invar q' \\<rbrakk> \\<Longrightarrow>\n  queue_to_multiset (meld q q') = queue_to_multiset q + queue_to_multiset q'\"", "lemma rank_ins: \"rank_invar bq \\<Longrightarrow> rank_invar (ins t bq)\"", "lemma rank_uniqify:\n  assumes \"rank_skew_invar q\"\n  shows \"rank_invar (uniqify q)\"", "lemma rank_ins_min: \"rank_invar bq \\<Longrightarrow> rank (hd (ins t bq)) \\<ge> min (rank t) (rank (hd bq))\"", "lemma rank_invar_not_empty_hd: \"\\<lbrakk>rank_invar (t # bq); bq \\<noteq> []\\<rbrakk> \\<Longrightarrow> rank t < rank (hd bq)\"", "lemma rank_invar_meldUniq_strong: \n  \"\\<lbrakk>rank_invar bq1; rank_invar bq2\\<rbrakk> \\<Longrightarrow> \n    rank_invar (meldUniq bq1 bq2) \n    \\<and> rank (hd (meldUniq bq1 bq2)) \\<ge> min (rank (hd bq1)) (rank (hd bq2))\"", "lemma rank_meldUniq: \n  \"\\<lbrakk>rank_invar bq1; rank_invar bq2\\<rbrakk> \\<Longrightarrow> rank_invar (meldUniq bq1 bq2)\"", "lemma rank_meld: \n  \"\\<lbrakk>rank_skew_invar q1; rank_skew_invar q2\\<rbrakk> \\<Longrightarrow> rank_skew_invar (meld q1 q2)\"", "theorem meld_invar: \n  \"\\<lbrakk>invar bq1; invar bq2\\<rbrakk> \n  \\<Longrightarrow> invar (meld bq1 bq2)\"", "theorem meld_correct:\n  assumes I: \"invar q\" \"invar q'\"\n  shows \n  \"invar (meld q q')\"\n  \"queue_to_multiset (meld q q') = queue_to_multiset q + queue_to_multiset q'\"", "lemma mintree_exists: \"(bq \\<noteq> []) = (getMinTree bq \\<in> set bq)\"", "lemma treehead_in_multiset: \n  \"t \\<in> set bq \\<Longrightarrow> (val t, prio t) \\<in># (queue_to_multiset bq)\"", "lemma heap_ordered_single: \n  \"heap_ordered t = (\\<forall>x \\<in> set_mset (tree_to_multiset t). prio t \\<le> snd x)\"", "lemma getMinTree_cons: \n  \"prio (getMinTree (y # x # xs)) \\<le> prio (getMinTree (x # xs))\"", "lemma getMinTree_min_tree: \"t \\<in> set bq  \\<Longrightarrow> prio (getMinTree bq) \\<le> prio t\"", "lemma getMinTree_min_prio:\n  assumes \"queue_invar bq\"\n    and \"y \\<in> set_mset (queue_to_multiset bq)\"\n  shows \"prio (getMinTree bq) \\<le> snd y\"", "lemma findMin_mset:\n  assumes I: \"queue_invar q\"\n  assumes NE: \"q\\<noteq>Nil\"\n  shows \"findMin q \\<in># queue_to_multiset q\"\n  \"\\<forall>y\\<in>set_mset (queue_to_multiset q). snd (findMin q) \\<le> snd y\"", "theorem findMin_correct:\n  assumes I: \"invar q\"\n  assumes NE: \"q\\<noteq>Nil\"\n  shows \"findMin q \\<in># queue_to_multiset q\"\n  \"\\<forall>y\\<in>set_mset (queue_to_multiset q). snd (findMin q) \\<le> snd y\"", "lemma remove1Prio_remove1[simp]: \n  \"remove1Prio (prio (getMinTree bq)) bq = remove1 (getMinTree bq) bq\"", "lemma invar_rev[simp]: \"queue_invar (rev q) \\<longleftrightarrow> queue_invar q\"", "lemma invar_remove1: \"queue_invar q \\<Longrightarrow> queue_invar (remove1 t q)\"", "lemma mset_rev: \"queue_to_multiset (rev q) = queue_to_multiset q\"", "lemma in_set_subset: \"t \\<in> set q \\<Longrightarrow> tree_to_multiset t \\<subseteq># queue_to_multiset q\"", "lemma mset_remove1: \"t \\<in> set q \\<Longrightarrow> \n  queue_to_multiset (remove1 t q) = \n  queue_to_multiset q - tree_to_multiset t\"", "lemma invar_children':\n  assumes \"tree_invar t\"\n  shows \"queue_invar (children t)\"", "lemma invar_filter: \"queue_invar q \\<Longrightarrow> queue_invar (filter f q)\"", "lemma insertList_queue_invar: \"queue_invar q \\<Longrightarrow> queue_invar (insertList ts q)\"", "lemma deleteMin_queue_invar: \n  \"\\<lbrakk>queue_invar q; queue_to_multiset q \\<noteq> {#}\\<rbrakk> \\<Longrightarrow> \n  queue_invar (deleteMin q)\"", "lemma mset_children: \"queue_to_multiset (children t) = \n  tree_to_multiset t - {# (val t, prio t) #}\"", "lemma mset_insertList: \n  \"\\<lbrakk>\\<forall>t \\<in> set ts. rank t = 0 \\<and> children t = [] ; queue_invar q\\<rbrakk> \\<Longrightarrow> \n  queue_to_multiset (insertList ts q) = \n  queue_to_multiset ts + queue_to_multiset q\"", "lemma mset_filter: \"(queue_to_multiset [t\\<leftarrow>q . rank t = 0]) +\n  queue_to_multiset [t\\<leftarrow>q . 0 < rank t] =\n  queue_to_multiset q\"", "lemma deleteMin_mset:\n  assumes \"queue_invar q\"\n    and \"queue_to_multiset q \\<noteq> {#}\"\n  shows \"queue_to_multiset (deleteMin q) = queue_to_multiset q - {# (findMin q) #}\"", "lemma rank_insertList: \"rank_skew_invar q \\<Longrightarrow> rank_skew_invar (insertList ts q)\"", "lemma insertList_invar: \"invar q \\<Longrightarrow> invar (insertList ts q)\"", "lemma children_rank_less:\n  assumes \"tree_invar t\"\n  shows \"\\<forall>t' \\<in> set (children t). rank t' < rank t\"", "lemma strong_rev_children:\n  assumes \"tree_invar t\"\n  shows \"invar (rev [t \\<leftarrow> children t. 0 < rank t])\"", "lemma first_less: \"rank_invar (t # bq) \\<Longrightarrow> \\<forall>t' \\<in> set bq. rank t < rank t'\"", "lemma first_less_eq: \n  \"rank_skew_invar (t # bq) \\<Longrightarrow> \\<forall>t' \\<in> set bq. rank t \\<le> rank t'\"", "lemma remove1_tail_invar: \"tail_invar bq \\<Longrightarrow> tail_invar (remove1 t bq)\"", "lemma invar_cons_down: \"invar (t # bq) \\<Longrightarrow> invar bq\"", "lemma remove1_invar: \"invar bq \\<Longrightarrow> invar (remove1 t bq)\"", "lemma deleteMin_invar:\n  assumes \"invar bq\"\n    and \"bq \\<noteq> []\"\n  shows \"invar (deleteMin bq)\"", "theorem deleteMin_correct:\n  assumes I: \"invar q\"\n    and NE: \"q \\<noteq> Nil\"\n  shows \"invar (deleteMin q)\"\n    and \"queue_to_multiset (deleteMin q) = queue_to_multiset q - {#findMin q#}\"", "lemmas [simp del] = insert.simps", "lemma in_image_msetE:\n  assumes \"x\\<in>#image_mset f M\"\n  obtains y where \"y\\<in>#M\" \"x=f y\"", "lemma mset_image_fst_dep_pair_diff_split:\n  \"(\\<forall>e a. (e,a)\\<in>#M \\<longrightarrow> a=f e) \\<Longrightarrow>\n  image_mset fst (M - {#(e, f e)#}) = image_mset fst M - {#e#}\"", "lemma proj_xlate:\n  \"val t = SkewBinomialHeapStruc.val (bsmapt t)\"\n  \"prio t = SkewBinomialHeapStruc.prio (bsmapt t)\"\n  \"rank t = SkewBinomialHeapStruc.rank (bsmapt t)\"\n  \"bsmap (children t) = SkewBinomialHeapStruc.children (bsmapt t)\"\n  \"eprio (SkewBinomialHeapStruc.val (bsmapt t)) \n   = SkewBinomialHeapStruc.prio (bsmapt t)\"", "lemma link_xlate:\n  \"bsmapt (link t t') = SkewBinomialHeapStruc.link (bsmapt t) (bsmapt t')\"\n  \"bsmapt (skewlink e t t') = \n     SkewBinomialHeapStruc.skewlink e (eprio e) (bsmapt t) (bsmapt t')\"", "lemma ins_xlate:\n  \"bsmap (ins t q) = SkewBinomialHeapStruc.ins (bsmapt t) (bsmap q)\"", "lemma insert_xlate:\n  \"bsmap (insert e q) = SkewBinomialHeapStruc.insert e (eprio e) (bsmap q)\"", "lemma insert_correct:\n  assumes I: \"invar q\"\n  shows \n  \"invar (insert e q)\"\n  \"queue_to_multiset (insert e q) = queue_to_multiset q + {#(e)#}\"", "lemma uniqify_xlate:\n  \"bsmap (uniqify q) = SkewBinomialHeapStruc.uniqify (bsmap q)\"", "lemma meldUniq_xlate:\n  \"bsmap (meldUniq q q') = SkewBinomialHeapStruc.meldUniq (bsmap q) (bsmap q')\"", "lemma meld_xlate: \n  \"bsmap (meld q q') = SkewBinomialHeapStruc.meld (bsmap q) (bsmap q')\"", "lemma meld_correct:\n  assumes I: \"invar q\" \"invar q'\"\n  shows \n  \"invar (meld q q')\"\n  \"queue_to_multiset (meld q q') = queue_to_multiset q + queue_to_multiset q'\"", "lemma insertList_xlate:\n  \"bsmap (insertList q q') \n  = SkewBinomialHeapStruc.insertList (bsmap q) (bsmap q')\"", "lemma remove1Prio_xlate:\n  \"bsmap (remove1Prio a q) = SkewBinomialHeapStruc.remove1Prio a (bsmap q)\"", "lemma getMinTree_xlate:\n  \"q\\<noteq>[] \\<Longrightarrow> bsmapt (getMinTree q) = SkewBinomialHeapStruc.getMinTree (bsmap q)\"", "lemma findMin_xlate: \n  \"q\\<noteq>[] \\<Longrightarrow> findMin q = fst (SkewBinomialHeapStruc.findMin (bsmap q))\"", "lemma findMin_xlate_aux: \n  \"q\\<noteq>[] \\<Longrightarrow> (findMin q, eprio (findMin q)) = \n  (SkewBinomialHeapStruc.findMin (bsmap q))\"", "lemma bsmap_filter_xlate:\n  \"bsmap [ x\\<leftarrow>l . P (bsmapt x) ] = [ x \\<leftarrow> bsmap l. P x ]\"", "lemma bsmap_rev_xlate:\n  \"bsmap (rev q) = rev (bsmap q)\"", "lemma deleteMin_xlate:\n  \"q\\<noteq>[] \\<Longrightarrow> bsmap (deleteMin q) = SkewBinomialHeapStruc.deleteMin (bsmap q)\"", "lemma deleteMin_correct_aux:\n  assumes I: \"invar q\"\n  assumes NE: \"q\\<noteq>[]\"\n  shows \n  \"invar (deleteMin q)\"\n  \"queue_to_multiset_aux (deleteMin q) = queue_to_multiset_aux q - \n  {# (findMin q, eprio (findMin q)) #}\"", "lemma bsmap_fs_dep:\n  \"(e,a)\\<in>#SkewBinomialHeapStruc.tree_to_multiset (bsmapt t) \\<Longrightarrow> a=eprio e\"\n  \"(e,a)\\<in>#SkewBinomialHeapStruc.queue_to_multiset (bsmap q) \\<Longrightarrow> a=eprio e\"", "lemma bsmap_fs_depD:\n  \"(e,a)\\<in>#SkewBinomialHeapStruc.tree_to_multiset (bsmapt t) \n  \\<Longrightarrow> e \\<in># tree_to_multiset t \\<and> a=eprio e\"\n  \"(e,a)\\<in>#SkewBinomialHeapStruc.queue_to_multiset (bsmap q) \n  \\<Longrightarrow> e \\<in># queue_to_multiset q \\<and> a=eprio e\"", "lemma findMin_correct_aux:\n  assumes I: \"invar q\"\n  assumes NE: \"q\\<noteq>[]\"\n  shows \"(findMin q, eprio (findMin q)) \\<in># queue_to_multiset_aux q\"\n  \"\\<forall>y\\<in>set_mset (queue_to_multiset_aux q). snd (findMin q,eprio (findMin q)) \\<le> snd y\"", "lemma findMin_correct:\n  assumes I: \"invar q\"\n    and NE: \"q\\<noteq>[]\"\n  shows \"findMin q \\<in># queue_to_multiset q\"\n    and \"\\<forall>y\\<in>set_mset (queue_to_multiset q). eprio (findMin q) \\<le> eprio y\"", "lemma deleteMin_correct:\n  assumes I: \"invar q\"\n  assumes NE: \"q\\<noteq>[]\"\n  shows \n  \"invar (deleteMin q)\"\n  \"queue_to_multiset (deleteMin q) = queue_to_multiset q - \n  {# findMin q #}\"", "lemma level_m:\n  \"x\\<in>#tree_to_multiset t \\<Longrightarrow> level x < Suc (tree_level t)\"\n  \"x\\<in>#queue_to_multiset q \\<Longrightarrow> level x < Suc (queue_level q)\"", "lemma level_measure:\n  \"x \\<in> set_mset (queue_to_multiset q) \\<Longrightarrow> (x,(Element e a q))\\<in>measure level\"\n  \"x \\<in># (queue_to_multiset q) \\<Longrightarrow> (x,(Element e a q))\\<in>measure level\"", "lemma insert_correct':\n  assumes I: \"elem_invar x\"\n  shows \n  \"elem_invar (insert' e a x)\"\n  \"elem_to_mset (insert' e a x) = elem_to_mset x + {#(e,a)#}\"", "lemma meld_correct':\n  assumes I: \"elem_invar x\" \"elem_invar x'\"\n  shows \n  \"elem_invar (meld' x x')\"\n  \"elem_to_mset (meld' x x') = elem_to_mset x + elem_to_mset x'\"", "lemma findMin'_min: \n  \"\\<lbrakk>elem_invar x; y\\<in>#elem_to_mset x\\<rbrakk> \\<Longrightarrow> snd (findMin' x) \\<le> snd y\"", "lemma findMin_correct':\n  assumes I: \"elem_invar x\"\n  shows\n  \"findMin' x \\<in># elem_to_mset x\"\n  \"\\<forall>y\\<in>set_mset (elem_to_mset x). snd (findMin' x) \\<le> snd y\"", "lemma deleteMin_correct':\n  assumes I: \"elem_invar (Element e a q)\"\n  assumes NE[simp]: \"q\\<noteq>[]\"\n  shows \n    \"elem_invar (deleteMin' (Element e a q))\"\n    \"elem_to_mset (deleteMin' (Element e a q)) = \n       elem_to_mset (Element e a q) - {# findMin' (Element e a q) #}\"", "lemma [simp]: \"bs_meld x (Inl u) = x\"", "lemma [simp]: \"bs_invar bs_empty\"", "theorem bs_empty_correct: \"h=bs_empty \\<longleftrightarrow> bs_to_mset h = {#}\"", "lemma bs_mset_of_empty[simp]:\n  \"bs_to_mset bs_empty = {#}\"", "theorem bs_findMin_correct:\n  assumes I: \"bs_invar h\"\n  assumes NE: \"h\\<noteq>bs_empty\"\n  shows \"bs_findMin h \\<in># bs_to_mset h\"\n        \"\\<forall>y\\<in>set_mset (bs_to_mset h). snd (bs_findMin h) \\<le> snd y\"", "theorem bs_insert_correct:\n  assumes I: \"bs_invar h\"\n  shows \n  \"bs_invar (bs_insert e a h)\"\n  \"bs_to_mset (bs_insert e a h) = {#(e,a)#} + bs_to_mset h\"", "theorem bs_meld_correct:\n  assumes I: \"bs_invar h\" \"bs_invar h'\"\n  shows \n  \"bs_invar (bs_meld h h')\"\n  \"bs_to_mset (bs_meld h h') = bs_to_mset h + bs_to_mset h'\"", "theorem bs_deleteMin_correct:\n  assumes I: \"bs_invar h\"\n  assumes NE: \"h \\<noteq> bs_empty\"\n  shows \n  \"bs_invar (bs_deleteMin h)\"\n  \"bs_to_mset (bs_deleteMin h) = bs_to_mset h - {#bs_findMin h#}\"", "lemma Rep_SkewBinomialHeap_invar[simp]: \n  \"BsSkewBinomialHeapStruc.bs_invar (Rep_SkewBinomialHeap x)\"", "lemma [simp]: \n  \"BsSkewBinomialHeapStruc.bs_invar q \n  \\<Longrightarrow> Rep_SkewBinomialHeap (Abs_SkewBinomialHeap q) = q\"", "lemma [simp, code abstype]: \"Abs_SkewBinomialHeap (Rep_SkewBinomialHeap q) = q\"", "lemma [code abstract, simp]: \n    \"Rep_SkewBinomialHeap empty = BsSkewBinomialHeapStruc.bs_empty\"", "lemma empty_rep: \n    \"q=empty \\<longleftrightarrow> Rep_SkewBinomialHeap q = BsSkewBinomialHeapStruc.bs_empty\"", "lemma isEmpty_correct: \"isEmpty q \\<longleftrightarrow> q=empty\"", "lemma [code abstract]: \n    \"Rep_SkewBinomialHeap (insert e a q) \n    = BsSkewBinomialHeapStruc.bs_insert e a (Rep_SkewBinomialHeap q)\"", "lemma [code abstract]: \"Rep_SkewBinomialHeap (deleteMin q) =\n    (case (Rep_SkewBinomialHeap q) of Inl _ \\<Rightarrow> BsSkewBinomialHeapStruc.bs_empty |\n     _ \\<Rightarrow> BsSkewBinomialHeapStruc.bs_deleteMin (Rep_SkewBinomialHeap q))\"", "lemma [code abstract]:\n    \"Rep_SkewBinomialHeap (meld q1 q2) \n    = BsSkewBinomialHeapStruc.bs_meld (Rep_SkewBinomialHeap q1) \n                                 (Rep_SkewBinomialHeap q2)\"", "lemma empty_correct: \"to_mset q = {#} \\<longleftrightarrow> q=empty\"", "lemma to_mset_of_empty[simp]: \"to_mset empty = {#}\"", "lemma insert_correct: \"to_mset (insert e a q) =  to_mset q + {#(e,a)#}\"", "lemma findMin_correct: \n    assumes \"q\\<noteq>empty\"\n    shows \n    \"findMin q \\<in># to_mset q\"\n    \"\\<forall>y\\<in>set_mset (to_mset q). snd (findMin q) \\<le> snd y\"", "lemma deleteMin_correct:\n    assumes \"q\\<noteq>empty\"\n    shows \"to_mset (deleteMin q) = to_mset q - {# findMin q #}\"", "lemma meld_correct:\n    shows \"to_mset (meld q q') = to_mset q + to_mset q'\"", "lemmas correct = empty_correct deleteMin_correct meld_correct"], "translations": [["", "lemma ttm_children: \"tree_to_multiset t = \n  {#(val t,prio t)#} + queue_to_multiset (children t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tree_to_multiset t =\n    {#(val t, prio t)#} + queue_to_multiset (children t)", "by (cases t) auto"], ["", "(*lemma qtm_cons[simp]: \"queue_to_multiset (t#q)\n  = queue_to_multiset q + tree_to_multiset t\"\n  apply(induct q arbitrary: t)\n  apply simp\n  apply(auto simp add: union_ac)\ndone*)"], ["", "lemma qtm_conc[simp]: \"queue_to_multiset (q@q') \n  = queue_to_multiset q + queue_to_multiset q'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. queue_to_multiset (q @ q') = queue_to_multiset q + queue_to_multiset q'", "by (induct q) (auto simp add: union_ac)"], ["", "subsubsection \"Invariant\""], ["", "text \\<open>Link two trees of rank $r$ to a new tree of rank $r+1$\\<close>"], ["", "fun  link :: \"('e, 'a::linorder) SkewBinomialTree \\<Rightarrow> ('e, 'a) SkewBinomialTree \\<Rightarrow> \n  ('e, 'a) SkewBinomialTree\" where\n  \"link (Node e1 a1 r1 ts1) (Node e2 a2 r2 ts2) = \n   (if  a1\\<le>a2 \n     then (Node e1 a1 (Suc r1) ((Node e2 a2 r2 ts2)#ts1))\n     else (Node e2 a2 (Suc r2) ((Node e1 a1 r1 ts1)#ts2)))\""], ["", "text \\<open>Link two trees of rank $r$ and a new element to a new tree of \n  rank $r+1$\\<close>"], ["", "fun skewlink :: \"'e \\<Rightarrow> 'a::linorder \\<Rightarrow> ('e, 'a) SkewBinomialTree \\<Rightarrow> \n  ('e, 'a) SkewBinomialTree \\<Rightarrow> ('e, 'a) SkewBinomialTree\" where\n  \"skewlink e a t t' = (if a \\<le> (prio t) \\<and> a \\<le> (prio t')\n  then (Node e a (Suc (rank t)) [t,t'])\n  else (if (prio t) \\<le> (prio t') \n   then \n    Node (val t)  (prio t)  (Suc (rank t))  (Node e a 0 [] # t' # children t)\n   else \n    Node (val t') (prio t') (Suc (rank t')) (Node e a 0 [] # t # children t')))\""], ["", "text \\<open>\n  The invariant for trees claims that a tree labeled rank $0$ has no children, \n  and a tree labeled rank $r + 1$ is the result of an ordinary link or \n  a skew link of two trees with rank $r$.\\<close>"], ["", "function tree_invar :: \"('e, 'a::linorder) SkewBinomialTree \\<Rightarrow> bool\" where\n  \"tree_invar (Node e a 0 ts) = (ts = [])\" |\n  \"tree_invar (Node e a (Suc r) ts) = (\\<exists> e1 a1 ts1 e2 a2 ts2 e' a'. \n  tree_invar (Node e1 a1 r ts1) \\<and> tree_invar (Node e2 a2 r ts2) \\<and> \n  ((Node e a (Suc r) ts) = link (Node e1 a1 r ts1) (Node e2 a2 r ts2) \\<or> \n   (Node e a (Suc r) ts) = skewlink e' a' (Node e1 a1 r ts1) (Node e2 a2 r ts2)))\""], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>P x.\n       \\<lbrakk>\\<And>e a ts. x = Node e a 0 ts \\<Longrightarrow> P;\n        \\<And>e a r ts. x = Node e a (Suc r) ts \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P\n 2. \\<And>e a ts ea aa tsa.\n       Node e a 0 ts = Node ea aa 0 tsa \\<Longrightarrow>\n       (ts = []) = (tsa = [])\n 3. \\<And>e a ts ea aa r tsa.\n       Node e a 0 ts = Node ea aa (Suc r) tsa \\<Longrightarrow>\n       (ts = []) =\n       (\\<exists>e1 a1 ts1 e2 a2 ts2 e' a'.\n           tree_invar_sumC (Node e1 a1 r ts1) \\<and>\n           tree_invar_sumC (Node e2 a2 r ts2) \\<and>\n           (Node ea aa (Suc r) tsa =\n            link (Node e1 a1 r ts1) (Node e2 a2 r ts2) \\<or>\n            Node ea aa (Suc r) tsa =\n            skewlink e' a' (Node e1 a1 r ts1) (Node e2 a2 r ts2)))\n 4. \\<And>e a r ts ea aa ra tsa.\n       Node e a (Suc r) ts = Node ea aa (Suc ra) tsa \\<Longrightarrow>\n       (\\<exists>e1 a1 ts1 e2 a2 ts2 e' a'.\n           tree_invar_sumC (Node e1 a1 r ts1) \\<and>\n           tree_invar_sumC (Node e2 a2 r ts2) \\<and>\n           (Node e a (Suc r) ts =\n            link (Node e1 a1 r ts1) (Node e2 a2 r ts2) \\<or>\n            Node e a (Suc r) ts =\n            skewlink e' a' (Node e1 a1 r ts1) (Node e2 a2 r ts2))) =\n       (\\<exists>e1 a1 ts1 e2 a2 ts2 e' a'.\n           tree_invar_sumC (Node e1 a1 ra ts1) \\<and>\n           tree_invar_sumC (Node e2 a2 ra ts2) \\<and>\n           (Node ea aa (Suc ra) tsa =\n            link (Node e1 a1 ra ts1) (Node e2 a2 ra ts2) \\<or>\n            Node ea aa (Suc ra) tsa =\n            skewlink e' a' (Node e1 a1 ra ts1) (Node e2 a2 ra ts2)))", "by pat_completeness auto"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. Wellfounded.accp tree_invar_rel x", "apply(relation \"measure rank\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. wf (measure rank)\n 2. \\<And>e a r ts x xa xb xc xd xe xf xg.\n       (Node x xa r xb, Node e a (Suc r) ts) \\<in> measure rank\n 3. \\<And>e a r ts x xa xb xc xd xe xf xg.\n       (Node xc xd r xe, Node e a (Suc r) ts) \\<in> measure rank", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>A heap satisfies the invariant, if all contained trees satisfy the \n  invariant, the ranks of the trees in the heap are distinct, except that the\n  first two trees may have same rank, and the ranks are ordered in ascending \n  order.\\<close>"], ["", "text \\<open>First part: All trees inside the queue satisfy the invariant.\\<close>"], ["", "definition queue_invar :: \"('e, 'a::linorder) SkewBinomialQueue \\<Rightarrow> bool\" where\n  \"queue_invar q \\<equiv> (\\<forall>t \\<in> set q. tree_invar t)\""], ["", "lemma queue_invar_simps[simp]:\n  \"queue_invar []\"\n  \"queue_invar (t#q) \\<longleftrightarrow> tree_invar t \\<and> queue_invar q\"\n  \"queue_invar (q@q') \\<longleftrightarrow> queue_invar q \\<and> queue_invar q'\"\n  \"queue_invar q \\<Longrightarrow> t\\<in>set q \\<Longrightarrow> tree_invar t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (queue_invar [] &&&\n     queue_invar (t # q) = (tree_invar t \\<and> queue_invar q)) &&&\n    queue_invar (q @ q') = (queue_invar q \\<and> queue_invar q') &&&\n    (\\<lbrakk>queue_invar q; t \\<in> set q\\<rbrakk>\n     \\<Longrightarrow> tree_invar t)", "unfolding queue_invar_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>t\\<in>set []. tree_invar t &&&\n     (\\<forall>t\\<in>set (t # q). tree_invar t) =\n     (tree_invar t \\<and> (\\<forall>t\\<in>set q. tree_invar t))) &&&\n    (\\<forall>t\\<in>set (q @ q'). tree_invar t) =\n    ((\\<forall>t\\<in>set q. tree_invar t) \\<and>\n     (\\<forall>t\\<in>set q'. tree_invar t)) &&&\n    (\\<lbrakk>\\<forall>t\\<in>set q. tree_invar t; t \\<in> set q\\<rbrakk>\n     \\<Longrightarrow> tree_invar t)", "by auto"], ["", "text \\<open>Second part: The ranks of the trees in the heap are distinct, \n  except that the first two trees may have same rank, and the ranks are \n  ordered in ascending order.\\<close>"], ["", "text \\<open>For tail of queue\\<close>"], ["", "fun rank_invar :: \"('e, 'a::linorder) SkewBinomialQueue \\<Rightarrow> bool\" where\n  \"rank_invar [] = True\" |\n  \"rank_invar [t] = True\" |\n  \"rank_invar (t # t' # bq) = (rank t < rank t' \\<and> rank_invar (t' # bq))\""], ["", "text \\<open>For whole queue: First two elements may have same rank\\<close>"], ["", "fun rank_skew_invar :: \"('e, 'a::linorder) SkewBinomialQueue \\<Rightarrow> bool\" where\n  \"rank_skew_invar [] = True\" |\n  \"rank_skew_invar [t] = True\" |\n  \"rank_skew_invar (t # t' # bq) = ((rank t \\<le> rank t') \\<and> rank_invar (t' # bq))\""], ["", "definition tail_invar :: \"('e, 'a::linorder) SkewBinomialQueue \\<Rightarrow> bool\" where\n  \"tail_invar bq = (queue_invar bq \\<and> rank_invar bq)\""], ["", "definition invar :: \"('e, 'a::linorder) SkewBinomialQueue \\<Rightarrow> bool\" where\n  \"invar bq = (queue_invar bq \\<and> rank_skew_invar bq)\""], ["", "lemma invar_empty[simp]:\n  \"invar []\"\n  \"tail_invar []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invar [] &&& tail_invar []", "unfolding invar_def tail_invar_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. queue_invar [] \\<and> rank_skew_invar [] &&&\n    queue_invar [] \\<and> rank_invar []", "by auto"], ["", "lemma invar_tail_invar: \n  \"invar (t # bq) \\<Longrightarrow> tail_invar bq\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invar (t # bq) \\<Longrightarrow> tail_invar bq", "unfolding invar_def tail_invar_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. queue_invar (t # bq) \\<and> rank_skew_invar (t # bq) \\<Longrightarrow>\n    queue_invar bq \\<and> rank_invar bq", "by (cases bq) simp_all"], ["", "lemma link_mset[simp]: \"tree_to_multiset (link t1 t2) \n                  = tree_to_multiset t1 +tree_to_multiset t2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tree_to_multiset (link t1 t2) =\n    tree_to_multiset t1 + tree_to_multiset t2", "by (cases t1, cases t2, auto simp add:union_ac)"], ["", "lemma link_tree_invar: \"\\<lbrakk>tree_invar t1; tree_invar t2; rank t1 = rank t2\\<rbrakk> \\<Longrightarrow>\n  tree_invar (link t1 t2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>tree_invar t1; tree_invar t2; rank t1 = rank t2\\<rbrakk>\n    \\<Longrightarrow> tree_invar (link t1 t2)", "by (cases t1, cases t2, simp, blast)"], ["", "lemma skewlink_mset[simp]: \"tree_to_multiset (skewlink e a t1 t2) \n  = {# (e,a) #} +  tree_to_multiset t1 + tree_to_multiset t2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tree_to_multiset (skewlink e a t1 t2) =\n    {#(e, a)#} + tree_to_multiset t1 + tree_to_multiset t2", "by (cases t1, cases t2, auto simp add:union_ac)"], ["", "lemma skewlink_tree_invar: \"\\<lbrakk>tree_invar t1; tree_invar t2; rank t1 = rank t2\\<rbrakk> \\<Longrightarrow> \n  tree_invar (skewlink e a t1 t2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>tree_invar t1; tree_invar t2; rank t1 = rank t2\\<rbrakk>\n    \\<Longrightarrow> tree_invar (skewlink e a t1 t2)", "by (cases t1, cases t2, simp, blast)"], ["", "lemma rank_link: \"rank t = rank t' \\<Longrightarrow> rank (link t t') = rank t + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rank t = rank t' \\<Longrightarrow> rank (link t t') = rank t + 1", "apply (cases t)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x3 x4.\n       \\<lbrakk>rank t = rank t'; t = Node x1 x2 x3 x4\\<rbrakk>\n       \\<Longrightarrow> rank (link t t') = rank t + 1", "apply (cases t')"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x3 x4 x1a x2a x3a x4a.\n       \\<lbrakk>rank t = rank t'; t = Node x1 x2 x3 x4;\n        t' = Node x1a x2a x3a x4a\\<rbrakk>\n       \\<Longrightarrow> rank (link t t') = rank t + 1", "apply(auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma rank_skew_rank_invar: \"rank_skew_invar (t # bq) \\<Longrightarrow> rank_invar bq\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rank_skew_invar (t # bq) \\<Longrightarrow> rank_invar bq", "by (cases bq) simp_all"], ["", "lemma rank_invar_rank_skew:\n  assumes \"rank_invar q\"\n  shows \"rank_skew_invar q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rank_skew_invar q", "proof (cases q)"], ["proof (state)\ngoal (2 subgoals):\n 1. q = [] \\<Longrightarrow> rank_skew_invar q\n 2. \\<And>a list. q = a # list \\<Longrightarrow> rank_skew_invar q", "case Nil"], ["proof (state)\nthis:\n  q = []\n\ngoal (2 subgoals):\n 1. q = [] \\<Longrightarrow> rank_skew_invar q\n 2. \\<And>a list. q = a # list \\<Longrightarrow> rank_skew_invar q", "then"], ["proof (chain)\npicking this:\n  q = []", "show ?thesis"], ["proof (prove)\nusing this:\n  q = []\n\ngoal (1 subgoal):\n 1. rank_skew_invar q", "by simp"], ["proof (state)\nthis:\n  rank_skew_invar q\n\ngoal (1 subgoal):\n 1. \\<And>a list. q = a # list \\<Longrightarrow> rank_skew_invar q", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list. q = a # list \\<Longrightarrow> rank_skew_invar q", "case (Cons _ list)"], ["proof (state)\nthis:\n  q = a_ # list\n\ngoal (1 subgoal):\n 1. \\<And>a list. q = a # list \\<Longrightarrow> rank_skew_invar q", "with assms"], ["proof (chain)\npicking this:\n  rank_invar q\n  q = a_ # list", "show ?thesis"], ["proof (prove)\nusing this:\n  rank_invar q\n  q = a_ # list\n\ngoal (1 subgoal):\n 1. rank_skew_invar q", "by (cases list) simp_all"], ["proof (state)\nthis:\n  rank_skew_invar q\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rank_invar_cons_up: \n  \"\\<lbrakk>rank_invar (t # bq); rank t' < rank t\\<rbrakk> \\<Longrightarrow> rank_invar (t' # t # bq)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>rank_invar (t # bq); rank t' < rank t\\<rbrakk>\n    \\<Longrightarrow> rank_invar (t' # t # bq)", "by simp"], ["", "lemma rank_skew_cons_up: \n  \"\\<lbrakk>rank_invar (t # bq); rank t' \\<le> rank t\\<rbrakk> \\<Longrightarrow> rank_skew_invar (t' # t # bq)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>rank_invar (t # bq); rank t' \\<le> rank t\\<rbrakk>\n    \\<Longrightarrow> rank_skew_invar (t' # t # bq)", "by simp"], ["", "lemma rank_invar_cons_down: \"rank_invar (t # bq) \\<Longrightarrow> rank_invar bq\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rank_invar (t # bq) \\<Longrightarrow> rank_invar bq", "by (cases bq) simp_all"], ["", "lemma rank_invar_hd_cons: \n  \"\\<lbrakk>rank_invar bq; rank t < rank (hd bq)\\<rbrakk> \\<Longrightarrow> rank_invar (t # bq)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>rank_invar bq; rank t < rank (hd bq)\\<rbrakk>\n    \\<Longrightarrow> rank_invar (t # bq)", "apply(cases bq)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>rank_invar bq; rank t < rank (hd bq); bq = []\\<rbrakk>\n    \\<Longrightarrow> rank_invar (t # bq)\n 2. \\<And>a list.\n       \\<lbrakk>rank_invar bq; rank t < rank (hd bq); bq = a # list\\<rbrakk>\n       \\<Longrightarrow> rank_invar (t # bq)", "apply(auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma tail_invar_cons_up: \n  \"\\<lbrakk>tail_invar (t # bq); rank t' < rank t; tree_invar t'\\<rbrakk> \n  \\<Longrightarrow> tail_invar (t' # t # bq)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>tail_invar (t # bq); rank t' < rank t; tree_invar t'\\<rbrakk>\n    \\<Longrightarrow> tail_invar (t' # t # bq)", "unfolding tail_invar_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>queue_invar (t # bq) \\<and> rank_invar (t # bq);\n     rank t' < rank t; tree_invar t'\\<rbrakk>\n    \\<Longrightarrow> queue_invar (t' # t # bq) \\<and>\n                      rank_invar (t' # t # bq)", "apply (cases bq)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>queue_invar (t # bq) \\<and> rank_invar (t # bq);\n     rank t' < rank t; tree_invar t'; bq = []\\<rbrakk>\n    \\<Longrightarrow> queue_invar (t' # t # bq) \\<and>\n                      rank_invar (t' # t # bq)\n 2. \\<And>a list.\n       \\<lbrakk>queue_invar (t # bq) \\<and> rank_invar (t # bq);\n        rank t' < rank t; tree_invar t'; bq = a # list\\<rbrakk>\n       \\<Longrightarrow> queue_invar (t' # t # bq) \\<and>\n                         rank_invar (t' # t # bq)", "apply simp_all"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma tail_invar_cons_up_invar: \n  \"\\<lbrakk>tail_invar (t # bq); rank t' \\<le> rank t; tree_invar t'\\<rbrakk> \\<Longrightarrow> invar (t' # t # bq)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>tail_invar (t # bq); rank t' \\<le> rank t;\n     tree_invar t'\\<rbrakk>\n    \\<Longrightarrow> invar (t' # t # bq)", "by (cases bq) (simp_all add: invar_def tail_invar_def)"], ["", "lemma tail_invar_cons_down: \n  \"tail_invar (t # bq) \\<Longrightarrow> tail_invar bq\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tail_invar (t # bq) \\<Longrightarrow> tail_invar bq", "unfolding tail_invar_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. queue_invar (t # bq) \\<and> rank_invar (t # bq) \\<Longrightarrow>\n    queue_invar bq \\<and> rank_invar bq", "by (cases bq) simp_all"], ["", "lemma tail_invar_app_single: \n  \"\\<lbrakk>tail_invar bq; \\<forall>t \\<in> set bq. rank t < rank t'; tree_invar t'\\<rbrakk> \n    \\<Longrightarrow> tail_invar (bq @ [t'])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>tail_invar bq; \\<forall>t\\<in>set bq. rank t < rank t';\n     tree_invar t'\\<rbrakk>\n    \\<Longrightarrow> tail_invar (bq @ [t'])", "proof (induct bq)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>tail_invar []; \\<forall>t\\<in>set []. rank t < rank t';\n     tree_invar t'\\<rbrakk>\n    \\<Longrightarrow> tail_invar ([] @ [t'])\n 2. \\<And>a bq.\n       \\<lbrakk>\\<lbrakk>tail_invar bq;\n                 \\<forall>t\\<in>set bq. rank t < rank t';\n                 tree_invar t'\\<rbrakk>\n                \\<Longrightarrow> tail_invar (bq @ [t']);\n        tail_invar (a # bq); \\<forall>t\\<in>set (a # bq). rank t < rank t';\n        tree_invar t'\\<rbrakk>\n       \\<Longrightarrow> tail_invar ((a # bq) @ [t'])", "case Nil"], ["proof (state)\nthis:\n  tail_invar []\n  \\<forall>t\\<in>set []. rank t < rank t'\n  tree_invar t'\n\ngoal (2 subgoals):\n 1. \\<lbrakk>tail_invar []; \\<forall>t\\<in>set []. rank t < rank t';\n     tree_invar t'\\<rbrakk>\n    \\<Longrightarrow> tail_invar ([] @ [t'])\n 2. \\<And>a bq.\n       \\<lbrakk>\\<lbrakk>tail_invar bq;\n                 \\<forall>t\\<in>set bq. rank t < rank t';\n                 tree_invar t'\\<rbrakk>\n                \\<Longrightarrow> tail_invar (bq @ [t']);\n        tail_invar (a # bq); \\<forall>t\\<in>set (a # bq). rank t < rank t';\n        tree_invar t'\\<rbrakk>\n       \\<Longrightarrow> tail_invar ((a # bq) @ [t'])", "then"], ["proof (chain)\npicking this:\n  tail_invar []\n  \\<forall>t\\<in>set []. rank t < rank t'\n  tree_invar t'", "show ?case"], ["proof (prove)\nusing this:\n  tail_invar []\n  \\<forall>t\\<in>set []. rank t < rank t'\n  tree_invar t'\n\ngoal (1 subgoal):\n 1. tail_invar ([] @ [t'])", "by (simp add: tail_invar_def)"], ["proof (state)\nthis:\n  tail_invar ([] @ [t'])\n\ngoal (1 subgoal):\n 1. \\<And>a bq.\n       \\<lbrakk>\\<lbrakk>tail_invar bq;\n                 \\<forall>t\\<in>set bq. rank t < rank t';\n                 tree_invar t'\\<rbrakk>\n                \\<Longrightarrow> tail_invar (bq @ [t']);\n        tail_invar (a # bq); \\<forall>t\\<in>set (a # bq). rank t < rank t';\n        tree_invar t'\\<rbrakk>\n       \\<Longrightarrow> tail_invar ((a # bq) @ [t'])", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a bq.\n       \\<lbrakk>\\<lbrakk>tail_invar bq;\n                 \\<forall>t\\<in>set bq. rank t < rank t';\n                 tree_invar t'\\<rbrakk>\n                \\<Longrightarrow> tail_invar (bq @ [t']);\n        tail_invar (a # bq); \\<forall>t\\<in>set (a # bq). rank t < rank t';\n        tree_invar t'\\<rbrakk>\n       \\<Longrightarrow> tail_invar ((a # bq) @ [t'])", "case (Cons a bq)"], ["proof (state)\nthis:\n  \\<lbrakk>tail_invar bq; \\<forall>t\\<in>set bq. rank t < rank t';\n   tree_invar t'\\<rbrakk>\n  \\<Longrightarrow> tail_invar (bq @ [t'])\n  tail_invar (a # bq)\n  \\<forall>t\\<in>set (a # bq). rank t < rank t'\n  tree_invar t'\n\ngoal (1 subgoal):\n 1. \\<And>a bq.\n       \\<lbrakk>\\<lbrakk>tail_invar bq;\n                 \\<forall>t\\<in>set bq. rank t < rank t';\n                 tree_invar t'\\<rbrakk>\n                \\<Longrightarrow> tail_invar (bq @ [t']);\n        tail_invar (a # bq); \\<forall>t\\<in>set (a # bq). rank t < rank t';\n        tree_invar t'\\<rbrakk>\n       \\<Longrightarrow> tail_invar ((a # bq) @ [t'])", "from \\<open>tail_invar (a # bq)\\<close>"], ["proof (chain)\npicking this:\n  tail_invar (a # bq)", "have \"tail_invar bq\""], ["proof (prove)\nusing this:\n  tail_invar (a # bq)\n\ngoal (1 subgoal):\n 1. tail_invar bq", "by (rule tail_invar_cons_down)"], ["proof (state)\nthis:\n  tail_invar bq\n\ngoal (1 subgoal):\n 1. \\<And>a bq.\n       \\<lbrakk>\\<lbrakk>tail_invar bq;\n                 \\<forall>t\\<in>set bq. rank t < rank t';\n                 tree_invar t'\\<rbrakk>\n                \\<Longrightarrow> tail_invar (bq @ [t']);\n        tail_invar (a # bq); \\<forall>t\\<in>set (a # bq). rank t < rank t';\n        tree_invar t'\\<rbrakk>\n       \\<Longrightarrow> tail_invar ((a # bq) @ [t'])", "with Cons"], ["proof (chain)\npicking this:\n  \\<lbrakk>tail_invar bq; \\<forall>t\\<in>set bq. rank t < rank t';\n   tree_invar t'\\<rbrakk>\n  \\<Longrightarrow> tail_invar (bq @ [t'])\n  tail_invar (a # bq)\n  \\<forall>t\\<in>set (a # bq). rank t < rank t'\n  tree_invar t'\n  tail_invar bq", "have \"tail_invar (bq @ [t'])\""], ["proof (prove)\nusing this:\n  \\<lbrakk>tail_invar bq; \\<forall>t\\<in>set bq. rank t < rank t';\n   tree_invar t'\\<rbrakk>\n  \\<Longrightarrow> tail_invar (bq @ [t'])\n  tail_invar (a # bq)\n  \\<forall>t\\<in>set (a # bq). rank t < rank t'\n  tree_invar t'\n  tail_invar bq\n\ngoal (1 subgoal):\n 1. tail_invar (bq @ [t'])", "by simp"], ["proof (state)\nthis:\n  tail_invar (bq @ [t'])\n\ngoal (1 subgoal):\n 1. \\<And>a bq.\n       \\<lbrakk>\\<lbrakk>tail_invar bq;\n                 \\<forall>t\\<in>set bq. rank t < rank t';\n                 tree_invar t'\\<rbrakk>\n                \\<Longrightarrow> tail_invar (bq @ [t']);\n        tail_invar (a # bq); \\<forall>t\\<in>set (a # bq). rank t < rank t';\n        tree_invar t'\\<rbrakk>\n       \\<Longrightarrow> tail_invar ((a # bq) @ [t'])", "with Cons"], ["proof (chain)\npicking this:\n  \\<lbrakk>tail_invar bq; \\<forall>t\\<in>set bq. rank t < rank t';\n   tree_invar t'\\<rbrakk>\n  \\<Longrightarrow> tail_invar (bq @ [t'])\n  tail_invar (a # bq)\n  \\<forall>t\\<in>set (a # bq). rank t < rank t'\n  tree_invar t'\n  tail_invar (bq @ [t'])", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>tail_invar bq; \\<forall>t\\<in>set bq. rank t < rank t';\n   tree_invar t'\\<rbrakk>\n  \\<Longrightarrow> tail_invar (bq @ [t'])\n  tail_invar (a # bq)\n  \\<forall>t\\<in>set (a # bq). rank t < rank t'\n  tree_invar t'\n  tail_invar (bq @ [t'])\n\ngoal (1 subgoal):\n 1. tail_invar ((a # bq) @ [t'])", "by (cases bq) (simp_all add: tail_invar_cons_up tail_invar_def)"], ["proof (state)\nthis:\n  tail_invar ((a # bq) @ [t'])\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma invar_app_single: \n  \"\\<lbrakk>invar bq; \\<forall>t \\<in> set bq. rank t < rank t'; tree_invar t'\\<rbrakk> \n   \\<Longrightarrow> invar (bq @ [t'])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>invar bq; \\<forall>t\\<in>set bq. rank t < rank t';\n     tree_invar t'\\<rbrakk>\n    \\<Longrightarrow> invar (bq @ [t'])", "proof (induct bq)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>invar []; \\<forall>t\\<in>set []. rank t < rank t';\n     tree_invar t'\\<rbrakk>\n    \\<Longrightarrow> invar ([] @ [t'])\n 2. \\<And>a bq.\n       \\<lbrakk>\\<lbrakk>invar bq; \\<forall>t\\<in>set bq. rank t < rank t';\n                 tree_invar t'\\<rbrakk>\n                \\<Longrightarrow> invar (bq @ [t']);\n        invar (a # bq); \\<forall>t\\<in>set (a # bq). rank t < rank t';\n        tree_invar t'\\<rbrakk>\n       \\<Longrightarrow> invar ((a # bq) @ [t'])", "case Nil"], ["proof (state)\nthis:\n  invar []\n  \\<forall>t\\<in>set []. rank t < rank t'\n  tree_invar t'\n\ngoal (2 subgoals):\n 1. \\<lbrakk>invar []; \\<forall>t\\<in>set []. rank t < rank t';\n     tree_invar t'\\<rbrakk>\n    \\<Longrightarrow> invar ([] @ [t'])\n 2. \\<And>a bq.\n       \\<lbrakk>\\<lbrakk>invar bq; \\<forall>t\\<in>set bq. rank t < rank t';\n                 tree_invar t'\\<rbrakk>\n                \\<Longrightarrow> invar (bq @ [t']);\n        invar (a # bq); \\<forall>t\\<in>set (a # bq). rank t < rank t';\n        tree_invar t'\\<rbrakk>\n       \\<Longrightarrow> invar ((a # bq) @ [t'])", "then"], ["proof (chain)\npicking this:\n  invar []\n  \\<forall>t\\<in>set []. rank t < rank t'\n  tree_invar t'", "show ?case"], ["proof (prove)\nusing this:\n  invar []\n  \\<forall>t\\<in>set []. rank t < rank t'\n  tree_invar t'\n\ngoal (1 subgoal):\n 1. invar ([] @ [t'])", "by (simp add: invar_def)"], ["proof (state)\nthis:\n  invar ([] @ [t'])\n\ngoal (1 subgoal):\n 1. \\<And>a bq.\n       \\<lbrakk>\\<lbrakk>invar bq; \\<forall>t\\<in>set bq. rank t < rank t';\n                 tree_invar t'\\<rbrakk>\n                \\<Longrightarrow> invar (bq @ [t']);\n        invar (a # bq); \\<forall>t\\<in>set (a # bq). rank t < rank t';\n        tree_invar t'\\<rbrakk>\n       \\<Longrightarrow> invar ((a # bq) @ [t'])", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a bq.\n       \\<lbrakk>\\<lbrakk>invar bq; \\<forall>t\\<in>set bq. rank t < rank t';\n                 tree_invar t'\\<rbrakk>\n                \\<Longrightarrow> invar (bq @ [t']);\n        invar (a # bq); \\<forall>t\\<in>set (a # bq). rank t < rank t';\n        tree_invar t'\\<rbrakk>\n       \\<Longrightarrow> invar ((a # bq) @ [t'])", "case (Cons a bq)"], ["proof (state)\nthis:\n  \\<lbrakk>invar bq; \\<forall>t\\<in>set bq. rank t < rank t';\n   tree_invar t'\\<rbrakk>\n  \\<Longrightarrow> invar (bq @ [t'])\n  invar (a # bq)\n  \\<forall>t\\<in>set (a # bq). rank t < rank t'\n  tree_invar t'\n\ngoal (1 subgoal):\n 1. \\<And>a bq.\n       \\<lbrakk>\\<lbrakk>invar bq; \\<forall>t\\<in>set bq. rank t < rank t';\n                 tree_invar t'\\<rbrakk>\n                \\<Longrightarrow> invar (bq @ [t']);\n        invar (a # bq); \\<forall>t\\<in>set (a # bq). rank t < rank t';\n        tree_invar t'\\<rbrakk>\n       \\<Longrightarrow> invar ((a # bq) @ [t'])", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. invar ((a # bq) @ [t'])", "proof (cases bq)"], ["proof (state)\ngoal (2 subgoals):\n 1. bq = [] \\<Longrightarrow> invar ((a # bq) @ [t'])\n 2. \\<And>aa list. bq = aa # list \\<Longrightarrow> invar ((a # bq) @ [t'])", "case Nil"], ["proof (state)\nthis:\n  bq = []\n\ngoal (2 subgoals):\n 1. bq = [] \\<Longrightarrow> invar ((a # bq) @ [t'])\n 2. \\<And>aa list. bq = aa # list \\<Longrightarrow> invar ((a # bq) @ [t'])", "with Cons"], ["proof (chain)\npicking this:\n  \\<lbrakk>invar bq; \\<forall>t\\<in>set bq. rank t < rank t';\n   tree_invar t'\\<rbrakk>\n  \\<Longrightarrow> invar (bq @ [t'])\n  invar (a # bq)\n  \\<forall>t\\<in>set (a # bq). rank t < rank t'\n  tree_invar t'\n  bq = []", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>invar bq; \\<forall>t\\<in>set bq. rank t < rank t';\n   tree_invar t'\\<rbrakk>\n  \\<Longrightarrow> invar (bq @ [t'])\n  invar (a # bq)\n  \\<forall>t\\<in>set (a # bq). rank t < rank t'\n  tree_invar t'\n  bq = []\n\ngoal (1 subgoal):\n 1. invar ((a # bq) @ [t'])", "by (simp add: invar_def)"], ["proof (state)\nthis:\n  invar ((a # bq) @ [t'])\n\ngoal (1 subgoal):\n 1. \\<And>aa list. bq = aa # list \\<Longrightarrow> invar ((a # bq) @ [t'])", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa list. bq = aa # list \\<Longrightarrow> invar ((a # bq) @ [t'])", "case Cons': (Cons ta qa)"], ["proof (state)\nthis:\n  bq = ta # qa\n\ngoal (1 subgoal):\n 1. \\<And>aa list. bq = aa # list \\<Longrightarrow> invar ((a # bq) @ [t'])", "from Cons(2)"], ["proof (chain)\npicking this:\n  invar (a # bq)", "have a1: \"tail_invar bq\""], ["proof (prove)\nusing this:\n  invar (a # bq)\n\ngoal (1 subgoal):\n 1. tail_invar bq", "by (rule invar_tail_invar)"], ["proof (state)\nthis:\n  tail_invar bq\n\ngoal (1 subgoal):\n 1. \\<And>aa list. bq = aa # list \\<Longrightarrow> invar ((a # bq) @ [t'])", "from Cons(3)"], ["proof (chain)\npicking this:\n  \\<forall>t\\<in>set (a # bq). rank t < rank t'", "have a2: \"\\<forall>t\\<in>set bq. rank t < rank t'\""], ["proof (prove)\nusing this:\n  \\<forall>t\\<in>set (a # bq). rank t < rank t'\n\ngoal (1 subgoal):\n 1. \\<forall>t\\<in>set bq. rank t < rank t'", "by simp"], ["proof (state)\nthis:\n  \\<forall>t\\<in>set bq. rank t < rank t'\n\ngoal (1 subgoal):\n 1. \\<And>aa list. bq = aa # list \\<Longrightarrow> invar ((a # bq) @ [t'])", "from a1 a2 Cons(4) tail_invar_app_single[of \"bq\" \"t'\"]"], ["proof (chain)\npicking this:\n  tail_invar bq\n  \\<forall>t\\<in>set bq. rank t < rank t'\n  tree_invar t'\n  \\<lbrakk>tail_invar bq; \\<forall>t\\<in>set bq. rank t < rank t';\n   tree_invar t'\\<rbrakk>\n  \\<Longrightarrow> tail_invar (bq @ [t'])", "have \"tail_invar (bq @ [t'])\""], ["proof (prove)\nusing this:\n  tail_invar bq\n  \\<forall>t\\<in>set bq. rank t < rank t'\n  tree_invar t'\n  \\<lbrakk>tail_invar bq; \\<forall>t\\<in>set bq. rank t < rank t';\n   tree_invar t'\\<rbrakk>\n  \\<Longrightarrow> tail_invar (bq @ [t'])\n\ngoal (1 subgoal):\n 1. tail_invar (bq @ [t'])", "by simp"], ["proof (state)\nthis:\n  tail_invar (bq @ [t'])\n\ngoal (1 subgoal):\n 1. \\<And>aa list. bq = aa # list \\<Longrightarrow> invar ((a # bq) @ [t'])", "with Cons Cons'"], ["proof (chain)\npicking this:\n  \\<lbrakk>invar bq; \\<forall>t\\<in>set bq. rank t < rank t';\n   tree_invar t'\\<rbrakk>\n  \\<Longrightarrow> invar (bq @ [t'])\n  invar (a # bq)\n  \\<forall>t\\<in>set (a # bq). rank t < rank t'\n  tree_invar t'\n  bq = ta # qa\n  tail_invar (bq @ [t'])", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>invar bq; \\<forall>t\\<in>set bq. rank t < rank t';\n   tree_invar t'\\<rbrakk>\n  \\<Longrightarrow> invar (bq @ [t'])\n  invar (a # bq)\n  \\<forall>t\\<in>set (a # bq). rank t < rank t'\n  tree_invar t'\n  bq = ta # qa\n  tail_invar (bq @ [t'])\n\ngoal (1 subgoal):\n 1. invar ((a # bq) @ [t'])", "by (simp_all add: tail_invar_cons_up_invar invar_def tail_invar_def)"], ["proof (state)\nthis:\n  invar ((a # bq) @ [t'])\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  invar ((a # bq) @ [t'])\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma invar_children: \n  assumes \"tree_invar ((Node e a r ts)::(('e, 'a::linorder) SkewBinomialTree))\"\n  shows \"queue_invar ts\""], ["proof (prove)\ngoal (1 subgoal):\n 1. queue_invar ts", "using assms"], ["proof (prove)\nusing this:\n  tree_invar (Node e a r ts)\n\ngoal (1 subgoal):\n 1. queue_invar ts", "proof (induct r arbitrary: e a ts)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>e a ts.\n       tree_invar (Node e a 0 ts) \\<Longrightarrow> queue_invar ts\n 2. \\<And>r e a ts.\n       \\<lbrakk>\\<And>e a ts.\n                   tree_invar (Node e a r ts) \\<Longrightarrow>\n                   queue_invar ts;\n        tree_invar (Node e a (Suc r) ts)\\<rbrakk>\n       \\<Longrightarrow> queue_invar ts", "case 0"], ["proof (state)\nthis:\n  tree_invar (Node e a 0 ts)\n\ngoal (2 subgoals):\n 1. \\<And>e a ts.\n       tree_invar (Node e a 0 ts) \\<Longrightarrow> queue_invar ts\n 2. \\<And>r e a ts.\n       \\<lbrakk>\\<And>e a ts.\n                   tree_invar (Node e a r ts) \\<Longrightarrow>\n                   queue_invar ts;\n        tree_invar (Node e a (Suc r) ts)\\<rbrakk>\n       \\<Longrightarrow> queue_invar ts", "then"], ["proof (chain)\npicking this:\n  tree_invar (Node e a 0 ts)", "show ?case"], ["proof (prove)\nusing this:\n  tree_invar (Node e a 0 ts)\n\ngoal (1 subgoal):\n 1. queue_invar ts", "by simp"], ["proof (state)\nthis:\n  queue_invar ts\n\ngoal (1 subgoal):\n 1. \\<And>r e a ts.\n       \\<lbrakk>\\<And>e a ts.\n                   tree_invar (Node e a r ts) \\<Longrightarrow>\n                   queue_invar ts;\n        tree_invar (Node e a (Suc r) ts)\\<rbrakk>\n       \\<Longrightarrow> queue_invar ts", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>r e a ts.\n       \\<lbrakk>\\<And>e a ts.\n                   tree_invar (Node e a r ts) \\<Longrightarrow>\n                   queue_invar ts;\n        tree_invar (Node e a (Suc r) ts)\\<rbrakk>\n       \\<Longrightarrow> queue_invar ts", "case (Suc r)"], ["proof (state)\nthis:\n  tree_invar (Node ?e ?a r ?ts) \\<Longrightarrow> queue_invar ?ts\n  tree_invar (Node e a (Suc r) ts)\n\ngoal (1 subgoal):\n 1. \\<And>r e a ts.\n       \\<lbrakk>\\<And>e a ts.\n                   tree_invar (Node e a r ts) \\<Longrightarrow>\n                   queue_invar ts;\n        tree_invar (Node e a (Suc r) ts)\\<rbrakk>\n       \\<Longrightarrow> queue_invar ts", "from Suc(2)"], ["proof (chain)\npicking this:\n  tree_invar (Node e a (Suc r) ts)", "obtain e1 a1 ts1 e2 a2 ts2 e' a' where  \n    inv_t1: \"tree_invar (Node e1 a1 r ts1)\" and\n    inv_t2: \"tree_invar (Node e2 a2 r ts2)\" and\n    link_or_skew: \n    \"((Node e a (Suc r) ts) = link (Node e1 a1 r ts1) (Node e2 a2 r ts2)\n    \\<or> (Node e a (Suc r) ts) \n       = skewlink e' a' (Node e1 a1 r ts1) (Node e2 a2 r ts2))\""], ["proof (prove)\nusing this:\n  tree_invar (Node e a (Suc r) ts)\n\ngoal (1 subgoal):\n 1. (\\<And>e1 a1 ts1 e2 a2 ts2 e' a'.\n        \\<lbrakk>tree_invar (Node e1 a1 r ts1);\n         tree_invar (Node e2 a2 r ts2);\n         Node e a (Suc r) ts =\n         link (Node e1 a1 r ts1) (Node e2 a2 r ts2) \\<or>\n         Node e a (Suc r) ts =\n         skewlink e' a' (Node e1 a1 r ts1) (Node e2 a2 r ts2)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (simp only: tree_invar.simps) blast"], ["proof (state)\nthis:\n  tree_invar (Node e1 a1 r ts1)\n  tree_invar (Node e2 a2 r ts2)\n  Node e a (Suc r) ts = link (Node e1 a1 r ts1) (Node e2 a2 r ts2) \\<or>\n  Node e a (Suc r) ts = skewlink e' a' (Node e1 a1 r ts1) (Node e2 a2 r ts2)\n\ngoal (1 subgoal):\n 1. \\<And>r e a ts.\n       \\<lbrakk>\\<And>e a ts.\n                   tree_invar (Node e a r ts) \\<Longrightarrow>\n                   queue_invar ts;\n        tree_invar (Node e a (Suc r) ts)\\<rbrakk>\n       \\<Longrightarrow> queue_invar ts", "from Suc(1)[OF inv_t1] inv_t2"], ["proof (chain)\npicking this:\n  queue_invar ts1\n  tree_invar (Node e2 a2 r ts2)", "have case1: \"queue_invar ((Node e2 a2 r ts2) # ts1)\""], ["proof (prove)\nusing this:\n  queue_invar ts1\n  tree_invar (Node e2 a2 r ts2)\n\ngoal (1 subgoal):\n 1. queue_invar (Node e2 a2 r ts2 # ts1)", "by simp"], ["proof (state)\nthis:\n  queue_invar (Node e2 a2 r ts2 # ts1)\n\ngoal (1 subgoal):\n 1. \\<And>r e a ts.\n       \\<lbrakk>\\<And>e a ts.\n                   tree_invar (Node e a r ts) \\<Longrightarrow>\n                   queue_invar ts;\n        tree_invar (Node e a (Suc r) ts)\\<rbrakk>\n       \\<Longrightarrow> queue_invar ts", "from Suc(1)[OF inv_t2] inv_t1"], ["proof (chain)\npicking this:\n  queue_invar ts2\n  tree_invar (Node e1 a1 r ts1)", "have case2: \"queue_invar ((Node e1 a1 r ts1) # ts2)\""], ["proof (prove)\nusing this:\n  queue_invar ts2\n  tree_invar (Node e1 a1 r ts1)\n\ngoal (1 subgoal):\n 1. queue_invar (Node e1 a1 r ts1 # ts2)", "by simp"], ["proof (state)\nthis:\n  queue_invar (Node e1 a1 r ts1 # ts2)\n\ngoal (1 subgoal):\n 1. \\<And>r e a ts.\n       \\<lbrakk>\\<And>e a ts.\n                   tree_invar (Node e a r ts) \\<Longrightarrow>\n                   queue_invar ts;\n        tree_invar (Node e a (Suc r) ts)\\<rbrakk>\n       \\<Longrightarrow> queue_invar ts", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. queue_invar ts", "proof (cases \"(Node e a (Suc r) ts) = link (Node e1 a1 r ts1) (Node e2 a2 r ts2)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. Node e a (Suc r) ts =\n    link (Node e1 a1 r ts1) (Node e2 a2 r ts2) \\<Longrightarrow>\n    queue_invar ts\n 2. Node e a (Suc r) ts \\<noteq>\n    link (Node e1 a1 r ts1) (Node e2 a2 r ts2) \\<Longrightarrow>\n    queue_invar ts", "case True"], ["proof (state)\nthis:\n  Node e a (Suc r) ts = link (Node e1 a1 r ts1) (Node e2 a2 r ts2)\n\ngoal (2 subgoals):\n 1. Node e a (Suc r) ts =\n    link (Node e1 a1 r ts1) (Node e2 a2 r ts2) \\<Longrightarrow>\n    queue_invar ts\n 2. Node e a (Suc r) ts \\<noteq>\n    link (Node e1 a1 r ts1) (Node e2 a2 r ts2) \\<Longrightarrow>\n    queue_invar ts", "hence \"ts =\n     (if a1 \\<le> a2 \n      then (Node e2 a2 r ts2) # ts1 \n      else (Node e1 a1 r ts1) # ts2)\""], ["proof (prove)\nusing this:\n  Node e a (Suc r) ts = link (Node e1 a1 r ts1) (Node e2 a2 r ts2)\n\ngoal (1 subgoal):\n 1. ts =\n    (if a1 \\<le> a2 then Node e2 a2 r ts2 # ts1 else Node e1 a1 r ts1 # ts2)", "by auto"], ["proof (state)\nthis:\n  ts =\n  (if a1 \\<le> a2 then Node e2 a2 r ts2 # ts1 else Node e1 a1 r ts1 # ts2)\n\ngoal (2 subgoals):\n 1. Node e a (Suc r) ts =\n    link (Node e1 a1 r ts1) (Node e2 a2 r ts2) \\<Longrightarrow>\n    queue_invar ts\n 2. Node e a (Suc r) ts \\<noteq>\n    link (Node e1 a1 r ts1) (Node e2 a2 r ts2) \\<Longrightarrow>\n    queue_invar ts", "with case1 case2"], ["proof (chain)\npicking this:\n  queue_invar (Node e2 a2 r ts2 # ts1)\n  queue_invar (Node e1 a1 r ts1 # ts2)\n  ts =\n  (if a1 \\<le> a2 then Node e2 a2 r ts2 # ts1 else Node e1 a1 r ts1 # ts2)", "show ?thesis"], ["proof (prove)\nusing this:\n  queue_invar (Node e2 a2 r ts2 # ts1)\n  queue_invar (Node e1 a1 r ts1 # ts2)\n  ts =\n  (if a1 \\<le> a2 then Node e2 a2 r ts2 # ts1 else Node e1 a1 r ts1 # ts2)\n\ngoal (1 subgoal):\n 1. queue_invar ts", "by simp"], ["proof (state)\nthis:\n  queue_invar ts\n\ngoal (1 subgoal):\n 1. Node e a (Suc r) ts \\<noteq>\n    link (Node e1 a1 r ts1) (Node e2 a2 r ts2) \\<Longrightarrow>\n    queue_invar ts", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. Node e a (Suc r) ts \\<noteq>\n    link (Node e1 a1 r ts1) (Node e2 a2 r ts2) \\<Longrightarrow>\n    queue_invar ts", "case False"], ["proof (state)\nthis:\n  Node e a (Suc r) ts \\<noteq> link (Node e1 a1 r ts1) (Node e2 a2 r ts2)\n\ngoal (1 subgoal):\n 1. Node e a (Suc r) ts \\<noteq>\n    link (Node e1 a1 r ts1) (Node e2 a2 r ts2) \\<Longrightarrow>\n    queue_invar ts", "with link_or_skew"], ["proof (chain)\npicking this:\n  Node e a (Suc r) ts = link (Node e1 a1 r ts1) (Node e2 a2 r ts2) \\<or>\n  Node e a (Suc r) ts = skewlink e' a' (Node e1 a1 r ts1) (Node e2 a2 r ts2)\n  Node e a (Suc r) ts \\<noteq> link (Node e1 a1 r ts1) (Node e2 a2 r ts2)", "have \"Node e a (Suc r) ts = \n      skewlink e' a' (Node e1 a1 r ts1) (Node e2 a2 r ts2)\""], ["proof (prove)\nusing this:\n  Node e a (Suc r) ts = link (Node e1 a1 r ts1) (Node e2 a2 r ts2) \\<or>\n  Node e a (Suc r) ts = skewlink e' a' (Node e1 a1 r ts1) (Node e2 a2 r ts2)\n  Node e a (Suc r) ts \\<noteq> link (Node e1 a1 r ts1) (Node e2 a2 r ts2)\n\ngoal (1 subgoal):\n 1. Node e a (Suc r) ts =\n    skewlink e' a' (Node e1 a1 r ts1) (Node e2 a2 r ts2)", "by simp"], ["proof (state)\nthis:\n  Node e a (Suc r) ts = skewlink e' a' (Node e1 a1 r ts1) (Node e2 a2 r ts2)\n\ngoal (1 subgoal):\n 1. Node e a (Suc r) ts \\<noteq>\n    link (Node e1 a1 r ts1) (Node e2 a2 r ts2) \\<Longrightarrow>\n    queue_invar ts", "hence \"ts =\n     (if a' \\<le> a1 \\<and> a' \\<le> a2\n      then [(Node e1 a1 r ts1),(Node e2 a2 r ts2)]\n      else (if a1 \\<le> a2 \n        then (Node e' a' 0 []) # (Node e2 a2 r ts2) # ts1\n        else (Node e' a' 0 []) # (Node e1 a1 r ts1) # ts2))\""], ["proof (prove)\nusing this:\n  Node e a (Suc r) ts = skewlink e' a' (Node e1 a1 r ts1) (Node e2 a2 r ts2)\n\ngoal (1 subgoal):\n 1. ts =\n    (if a' \\<le> a1 \\<and> a' \\<le> a2\n     then [Node e1 a1 r ts1, Node e2 a2 r ts2]\n     else if a1 \\<le> a2 then Node e' a' 0 [] # Node e2 a2 r ts2 # ts1\n          else Node e' a' 0 [] # Node e1 a1 r ts1 # ts2)", "by auto"], ["proof (state)\nthis:\n  ts =\n  (if a' \\<le> a1 \\<and> a' \\<le> a2\n   then [Node e1 a1 r ts1, Node e2 a2 r ts2]\n   else if a1 \\<le> a2 then Node e' a' 0 [] # Node e2 a2 r ts2 # ts1\n        else Node e' a' 0 [] # Node e1 a1 r ts1 # ts2)\n\ngoal (1 subgoal):\n 1. Node e a (Suc r) ts \\<noteq>\n    link (Node e1 a1 r ts1) (Node e2 a2 r ts2) \\<Longrightarrow>\n    queue_invar ts", "with case1 case2"], ["proof (chain)\npicking this:\n  queue_invar (Node e2 a2 r ts2 # ts1)\n  queue_invar (Node e1 a1 r ts1 # ts2)\n  ts =\n  (if a' \\<le> a1 \\<and> a' \\<le> a2\n   then [Node e1 a1 r ts1, Node e2 a2 r ts2]\n   else if a1 \\<le> a2 then Node e' a' 0 [] # Node e2 a2 r ts2 # ts1\n        else Node e' a' 0 [] # Node e1 a1 r ts1 # ts2)", "show ?thesis"], ["proof (prove)\nusing this:\n  queue_invar (Node e2 a2 r ts2 # ts1)\n  queue_invar (Node e1 a1 r ts1 # ts2)\n  ts =\n  (if a' \\<le> a1 \\<and> a' \\<le> a2\n   then [Node e1 a1 r ts1, Node e2 a2 r ts2]\n   else if a1 \\<le> a2 then Node e' a' 0 [] # Node e2 a2 r ts2 # ts1\n        else Node e' a' 0 [] # Node e1 a1 r ts1 # ts2)\n\ngoal (1 subgoal):\n 1. queue_invar ts", "by simp"], ["proof (state)\nthis:\n  queue_invar ts\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  queue_invar ts\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \"Heap Order\""], ["", "fun heap_ordered :: \"('e, 'a::linorder) SkewBinomialTree \\<Rightarrow> bool\" where\n  \"heap_ordered (Node e a r ts) \n   = (\\<forall>x \\<in> set_mset (queue_to_multiset ts). a \\<le> snd x)\""], ["", "text \\<open>The invariant for trees implies heap order.\\<close>"], ["", "lemma tree_invar_heap_ordered: \n  fixes t :: \"('e, 'a::linorder) SkewBinomialTree\"\n  assumes \"tree_invar t\"\n  shows \"heap_ordered t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. heap_ordered t", "proof (cases t)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x3 x4. t = Node x1 x2 x3 x4 \\<Longrightarrow> heap_ordered t", "case (Node e a nat list)"], ["proof (state)\nthis:\n  t = Node e a nat list\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x3 x4. t = Node x1 x2 x3 x4 \\<Longrightarrow> heap_ordered t", "with assms"], ["proof (chain)\npicking this:\n  tree_invar t\n  t = Node e a nat list", "show ?thesis"], ["proof (prove)\nusing this:\n  tree_invar t\n  t = Node e a nat list\n\ngoal (1 subgoal):\n 1. heap_ordered t", "proof (induct nat arbitrary: t e a list)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>t e a list.\n       \\<lbrakk>tree_invar t; t = Node e a 0 list\\<rbrakk>\n       \\<Longrightarrow> heap_ordered t\n 2. \\<And>nat t e a list.\n       \\<lbrakk>\\<And>t e a list.\n                   \\<lbrakk>tree_invar t; t = Node e a nat list\\<rbrakk>\n                   \\<Longrightarrow> heap_ordered t;\n        tree_invar t; t = Node e a (Suc nat) list\\<rbrakk>\n       \\<Longrightarrow> heap_ordered t", "case 0"], ["proof (state)\nthis:\n  tree_invar t\n  t = Node e a 0 list\n\ngoal (2 subgoals):\n 1. \\<And>t e a list.\n       \\<lbrakk>tree_invar t; t = Node e a 0 list\\<rbrakk>\n       \\<Longrightarrow> heap_ordered t\n 2. \\<And>nat t e a list.\n       \\<lbrakk>\\<And>t e a list.\n                   \\<lbrakk>tree_invar t; t = Node e a nat list\\<rbrakk>\n                   \\<Longrightarrow> heap_ordered t;\n        tree_invar t; t = Node e a (Suc nat) list\\<rbrakk>\n       \\<Longrightarrow> heap_ordered t", "then"], ["proof (chain)\npicking this:\n  tree_invar t\n  t = Node e a 0 list", "show ?case"], ["proof (prove)\nusing this:\n  tree_invar t\n  t = Node e a 0 list\n\ngoal (1 subgoal):\n 1. heap_ordered t", "by simp"], ["proof (state)\nthis:\n  heap_ordered t\n\ngoal (1 subgoal):\n 1. \\<And>nat t e a list.\n       \\<lbrakk>\\<And>t e a list.\n                   \\<lbrakk>tree_invar t; t = Node e a nat list\\<rbrakk>\n                   \\<Longrightarrow> heap_ordered t;\n        tree_invar t; t = Node e a (Suc nat) list\\<rbrakk>\n       \\<Longrightarrow> heap_ordered t", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat t e a list.\n       \\<lbrakk>\\<And>t e a list.\n                   \\<lbrakk>tree_invar t; t = Node e a nat list\\<rbrakk>\n                   \\<Longrightarrow> heap_ordered t;\n        tree_invar t; t = Node e a (Suc nat) list\\<rbrakk>\n       \\<Longrightarrow> heap_ordered t", "case (Suc nat)"], ["proof (state)\nthis:\n  \\<lbrakk>tree_invar ?t; ?t = Node ?e ?a nat ?list\\<rbrakk>\n  \\<Longrightarrow> heap_ordered ?t\n  tree_invar t\n  t = Node e a (Suc nat) list\n\ngoal (1 subgoal):\n 1. \\<And>nat t e a list.\n       \\<lbrakk>\\<And>t e a list.\n                   \\<lbrakk>tree_invar t; t = Node e a nat list\\<rbrakk>\n                   \\<Longrightarrow> heap_ordered t;\n        tree_invar t; t = Node e a (Suc nat) list\\<rbrakk>\n       \\<Longrightarrow> heap_ordered t", "from Suc(2,3)"], ["proof (chain)\npicking this:\n  tree_invar t\n  t = Node e a (Suc nat) list", "obtain t1 e1 a1 ts1 t2 e2 a2 ts2 e' a' where \n      inv_t1: \"tree_invar t1\" and\n      inv_t2: \"tree_invar t2\" and \n      link_or_skew: \"t = link t1 t2 \\<or> t = skewlink e' a' t1 t2\" and \n      eq_t1[simp]: \"t1 = (Node e1 a1 nat ts1)\" and \n      eq_t2[simp]: \"t2 = (Node e2 a2 nat ts2)\""], ["proof (prove)\nusing this:\n  tree_invar t\n  t = Node e a (Suc nat) list\n\ngoal (1 subgoal):\n 1. (\\<And>t1 t2 e' a' e1 a1 ts1 e2 a2 ts2.\n        \\<lbrakk>tree_invar t1; tree_invar t2;\n         t = link t1 t2 \\<or> t = skewlink e' a' t1 t2;\n         t1 = Node e1 a1 nat ts1; t2 = Node e2 a2 nat ts2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (simp only: tree_invar.simps) blast"], ["proof (state)\nthis:\n  tree_invar t1\n  tree_invar t2\n  t = link t1 t2 \\<or> t = skewlink e' a' t1 t2\n  t1 = Node e1 a1 nat ts1\n  t2 = Node e2 a2 nat ts2\n\ngoal (1 subgoal):\n 1. \\<And>nat t e a list.\n       \\<lbrakk>\\<And>t e a list.\n                   \\<lbrakk>tree_invar t; t = Node e a nat list\\<rbrakk>\n                   \\<Longrightarrow> heap_ordered t;\n        tree_invar t; t = Node e a (Suc nat) list\\<rbrakk>\n       \\<Longrightarrow> heap_ordered t", "note heap_t1 = Suc(1)[OF inv_t1 eq_t1]"], ["proof (state)\nthis:\n  heap_ordered t1\n\ngoal (1 subgoal):\n 1. \\<And>nat t e a list.\n       \\<lbrakk>\\<And>t e a list.\n                   \\<lbrakk>tree_invar t; t = Node e a nat list\\<rbrakk>\n                   \\<Longrightarrow> heap_ordered t;\n        tree_invar t; t = Node e a (Suc nat) list\\<rbrakk>\n       \\<Longrightarrow> heap_ordered t", "note heap_t2 = Suc(1)[OF inv_t2 eq_t2]"], ["proof (state)\nthis:\n  heap_ordered t2\n\ngoal (1 subgoal):\n 1. \\<And>nat t e a list.\n       \\<lbrakk>\\<And>t e a list.\n                   \\<lbrakk>tree_invar t; t = Node e a nat list\\<rbrakk>\n                   \\<Longrightarrow> heap_ordered t;\n        tree_invar t; t = Node e a (Suc nat) list\\<rbrakk>\n       \\<Longrightarrow> heap_ordered t", "from link_or_skew heap_t1 heap_t2"], ["proof (chain)\npicking this:\n  t = link t1 t2 \\<or> t = skewlink e' a' t1 t2\n  heap_ordered t1\n  heap_ordered t2", "show ?case"], ["proof (prove)\nusing this:\n  t = link t1 t2 \\<or> t = skewlink e' a' t1 t2\n  heap_ordered t1\n  heap_ordered t2\n\ngoal (1 subgoal):\n 1. heap_ordered t", "by (cases \"t = link t1 t2\") auto"], ["proof (state)\nthis:\n  heap_ordered t\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  heap_ordered t\n\ngoal:\nNo subgoals!", "qed"], ["", "(***********************************************************)\n\n\n\n(***********************************************************)"], ["", "subsubsection \"Height and Length\""], ["", "text \\<open>\n  Although complexity of HOL-functions cannot be expressed within \n  HOL, we can express the height and length of a binomial heap.\n  By showing that both, height and length, are logarithmic in the number \n  of contained elements, we give strong evidence that our functions have\n  logarithmic complexity in the number of elements.\n\\<close>"], ["", "text \\<open>Height of a tree and queue\\<close>"], ["", "fun height_tree :: \"('e, ('a::linorder)) SkewBinomialTree \\<Rightarrow> nat\" and\n    height_queue :: \"('e, ('a::linorder)) SkewBinomialQueue \\<Rightarrow> nat\" \n  where\n  \"height_tree (Node e a r ts) = height_queue ts\" |\n  \"height_queue [] = 0\" |\n  \"height_queue (t # ts) = max (Suc (height_tree t)) (height_queue ts)\""], ["", "lemma link_length: \"size (tree_to_multiset (link t1 t2)) = \n  size (tree_to_multiset t1) + size (tree_to_multiset t2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. size (tree_to_multiset (link t1 t2)) =\n    size (tree_to_multiset t1) + size (tree_to_multiset t2)", "apply(cases t1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x3 x4.\n       t1 = Node x1 x2 x3 x4 \\<Longrightarrow>\n       size (tree_to_multiset (link t1 t2)) =\n       size (tree_to_multiset t1) + size (tree_to_multiset t2)", "apply(cases t2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x3 x4 x1a x2a x3a x4a.\n       \\<lbrakk>t1 = Node x1 x2 x3 x4; t2 = Node x1a x2a x3a x4a\\<rbrakk>\n       \\<Longrightarrow> size (tree_to_multiset (link t1 t2)) =\n                         size (tree_to_multiset t1) +\n                         size (tree_to_multiset t2)", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma tree_rank_estimate_upper: \n  \"tree_invar (Node e a r ts) \\<Longrightarrow> \n   size (tree_to_multiset (Node e a r ts)) \\<le> (2::nat)^(Suc r) - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tree_invar (Node e a r ts) \\<Longrightarrow>\n    size (tree_to_multiset (Node e a r ts)) \\<le> 2 ^ Suc r - 1", "proof (induct r arbitrary: e a ts)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>e a ts.\n       tree_invar (Node e a 0 ts) \\<Longrightarrow>\n       size (tree_to_multiset (Node e a 0 ts)) \\<le> 2 ^ Suc 0 - 1\n 2. \\<And>r e a ts.\n       \\<lbrakk>\\<And>e a ts.\n                   tree_invar (Node e a r ts) \\<Longrightarrow>\n                   size (tree_to_multiset (Node e a r ts))\n                   \\<le> 2 ^ Suc r - 1;\n        tree_invar (Node e a (Suc r) ts)\\<rbrakk>\n       \\<Longrightarrow> size (tree_to_multiset (Node e a (Suc r) ts))\n                         \\<le> 2 ^ Suc (Suc r) - 1", "case 0"], ["proof (state)\nthis:\n  tree_invar (Node e a 0 ts)\n\ngoal (2 subgoals):\n 1. \\<And>e a ts.\n       tree_invar (Node e a 0 ts) \\<Longrightarrow>\n       size (tree_to_multiset (Node e a 0 ts)) \\<le> 2 ^ Suc 0 - 1\n 2. \\<And>r e a ts.\n       \\<lbrakk>\\<And>e a ts.\n                   tree_invar (Node e a r ts) \\<Longrightarrow>\n                   size (tree_to_multiset (Node e a r ts))\n                   \\<le> 2 ^ Suc r - 1;\n        tree_invar (Node e a (Suc r) ts)\\<rbrakk>\n       \\<Longrightarrow> size (tree_to_multiset (Node e a (Suc r) ts))\n                         \\<le> 2 ^ Suc (Suc r) - 1", "then"], ["proof (chain)\npicking this:\n  tree_invar (Node e a 0 ts)", "show ?case"], ["proof (prove)\nusing this:\n  tree_invar (Node e a 0 ts)\n\ngoal (1 subgoal):\n 1. size (tree_to_multiset (Node e a 0 ts)) \\<le> 2 ^ Suc 0 - 1", "by simp"], ["proof (state)\nthis:\n  size (tree_to_multiset (Node e a 0 ts)) \\<le> 2 ^ Suc 0 - 1\n\ngoal (1 subgoal):\n 1. \\<And>r e a ts.\n       \\<lbrakk>\\<And>e a ts.\n                   tree_invar (Node e a r ts) \\<Longrightarrow>\n                   size (tree_to_multiset (Node e a r ts))\n                   \\<le> 2 ^ Suc r - 1;\n        tree_invar (Node e a (Suc r) ts)\\<rbrakk>\n       \\<Longrightarrow> size (tree_to_multiset (Node e a (Suc r) ts))\n                         \\<le> 2 ^ Suc (Suc r) - 1", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>r e a ts.\n       \\<lbrakk>\\<And>e a ts.\n                   tree_invar (Node e a r ts) \\<Longrightarrow>\n                   size (tree_to_multiset (Node e a r ts))\n                   \\<le> 2 ^ Suc r - 1;\n        tree_invar (Node e a (Suc r) ts)\\<rbrakk>\n       \\<Longrightarrow> size (tree_to_multiset (Node e a (Suc r) ts))\n                         \\<le> 2 ^ Suc (Suc r) - 1", "case (Suc r)"], ["proof (state)\nthis:\n  tree_invar (Node ?e ?a r ?ts) \\<Longrightarrow>\n  size (tree_to_multiset (Node ?e ?a r ?ts)) \\<le> 2 ^ Suc r - 1\n  tree_invar (Node e a (Suc r) ts)\n\ngoal (1 subgoal):\n 1. \\<And>r e a ts.\n       \\<lbrakk>\\<And>e a ts.\n                   tree_invar (Node e a r ts) \\<Longrightarrow>\n                   size (tree_to_multiset (Node e a r ts))\n                   \\<le> 2 ^ Suc r - 1;\n        tree_invar (Node e a (Suc r) ts)\\<rbrakk>\n       \\<Longrightarrow> size (tree_to_multiset (Node e a (Suc r) ts))\n                         \\<le> 2 ^ Suc (Suc r) - 1", "from Suc(2)"], ["proof (chain)\npicking this:\n  tree_invar (Node e a (Suc r) ts)", "obtain e1 a1 ts1 e2 a2 ts2 e' a' where\n    link:\n      \"(Node e a (Suc r) ts) = link (Node e1 a1 r ts1) (Node e2 a2 r ts2) \\<or>\n       (Node e a (Suc r) ts) = skewlink e' a' (Node e1 a1 r ts1) (Node e2 a2 r ts2)\"\n    and inv1: \"tree_invar (Node e1 a1 r ts1)\"\n    and inv2: \"tree_invar (Node e2 a2 r ts2)\""], ["proof (prove)\nusing this:\n  tree_invar (Node e a (Suc r) ts)\n\ngoal (1 subgoal):\n 1. (\\<And>e1 a1 ts1 e2 a2 ts2 e' a'.\n        \\<lbrakk>Node e a (Suc r) ts =\n                 link (Node e1 a1 r ts1) (Node e2 a2 r ts2) \\<or>\n                 Node e a (Suc r) ts =\n                 skewlink e' a' (Node e1 a1 r ts1) (Node e2 a2 r ts2);\n         tree_invar (Node e1 a1 r ts1);\n         tree_invar (Node e2 a2 r ts2)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by simp blast"], ["proof (state)\nthis:\n  Node e a (Suc r) ts = link (Node e1 a1 r ts1) (Node e2 a2 r ts2) \\<or>\n  Node e a (Suc r) ts = skewlink e' a' (Node e1 a1 r ts1) (Node e2 a2 r ts2)\n  tree_invar (Node e1 a1 r ts1)\n  tree_invar (Node e2 a2 r ts2)\n\ngoal (1 subgoal):\n 1. \\<And>r e a ts.\n       \\<lbrakk>\\<And>e a ts.\n                   tree_invar (Node e a r ts) \\<Longrightarrow>\n                   size (tree_to_multiset (Node e a r ts))\n                   \\<le> 2 ^ Suc r - 1;\n        tree_invar (Node e a (Suc r) ts)\\<rbrakk>\n       \\<Longrightarrow> size (tree_to_multiset (Node e a (Suc r) ts))\n                         \\<le> 2 ^ Suc (Suc r) - 1", "note iv1 = Suc(1)[OF inv1]"], ["proof (state)\nthis:\n  size (tree_to_multiset (Node e1 a1 r ts1)) \\<le> 2 ^ Suc r - 1\n\ngoal (1 subgoal):\n 1. \\<And>r e a ts.\n       \\<lbrakk>\\<And>e a ts.\n                   tree_invar (Node e a r ts) \\<Longrightarrow>\n                   size (tree_to_multiset (Node e a r ts))\n                   \\<le> 2 ^ Suc r - 1;\n        tree_invar (Node e a (Suc r) ts)\\<rbrakk>\n       \\<Longrightarrow> size (tree_to_multiset (Node e a (Suc r) ts))\n                         \\<le> 2 ^ Suc (Suc r) - 1", "note iv2 = Suc(1)[OF inv2]"], ["proof (state)\nthis:\n  size (tree_to_multiset (Node e2 a2 r ts2)) \\<le> 2 ^ Suc r - 1\n\ngoal (1 subgoal):\n 1. \\<And>r e a ts.\n       \\<lbrakk>\\<And>e a ts.\n                   tree_invar (Node e a r ts) \\<Longrightarrow>\n                   size (tree_to_multiset (Node e a r ts))\n                   \\<le> 2 ^ Suc r - 1;\n        tree_invar (Node e a (Suc r) ts)\\<rbrakk>\n       \\<Longrightarrow> size (tree_to_multiset (Node e a (Suc r) ts))\n                         \\<le> 2 ^ Suc (Suc r) - 1", "have \"(2::nat)^r - 1 + (2::nat)^r - 1 \\<le> (2::nat)^(Suc r) - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ r - 1 + 2 ^ r - 1 \\<le> 2 ^ Suc r - 1", "by simp"], ["proof (state)\nthis:\n  2 ^ r - 1 + 2 ^ r - 1 \\<le> 2 ^ Suc r - 1\n\ngoal (1 subgoal):\n 1. \\<And>r e a ts.\n       \\<lbrakk>\\<And>e a ts.\n                   tree_invar (Node e a r ts) \\<Longrightarrow>\n                   size (tree_to_multiset (Node e a r ts))\n                   \\<le> 2 ^ Suc r - 1;\n        tree_invar (Node e a (Suc r) ts)\\<rbrakk>\n       \\<Longrightarrow> size (tree_to_multiset (Node e a (Suc r) ts))\n                         \\<le> 2 ^ Suc (Suc r) - 1", "with link Suc"], ["proof (chain)\npicking this:\n  Node e a (Suc r) ts = link (Node e1 a1 r ts1) (Node e2 a2 r ts2) \\<or>\n  Node e a (Suc r) ts = skewlink e' a' (Node e1 a1 r ts1) (Node e2 a2 r ts2)\n  tree_invar (Node ?e ?a r ?ts) \\<Longrightarrow>\n  size (tree_to_multiset (Node ?e ?a r ?ts)) \\<le> 2 ^ Suc r - 1\n  tree_invar (Node e a (Suc r) ts)\n  2 ^ r - 1 + 2 ^ r - 1 \\<le> 2 ^ Suc r - 1", "show ?case"], ["proof (prove)\nusing this:\n  Node e a (Suc r) ts = link (Node e1 a1 r ts1) (Node e2 a2 r ts2) \\<or>\n  Node e a (Suc r) ts = skewlink e' a' (Node e1 a1 r ts1) (Node e2 a2 r ts2)\n  tree_invar (Node ?e ?a r ?ts) \\<Longrightarrow>\n  size (tree_to_multiset (Node ?e ?a r ?ts)) \\<le> 2 ^ Suc r - 1\n  tree_invar (Node e a (Suc r) ts)\n  2 ^ r - 1 + 2 ^ r - 1 \\<le> 2 ^ Suc r - 1\n\ngoal (1 subgoal):\n 1. size (tree_to_multiset (Node e a (Suc r) ts)) \\<le> 2 ^ Suc (Suc r) - 1", "apply (cases \"Node e a (Suc r) ts = link (Node e1 a1 r ts1) (Node e2 a2 r ts2)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>Node e a (Suc r) ts =\n             link (Node e1 a1 r ts1) (Node e2 a2 r ts2) \\<or>\n             Node e a (Suc r) ts =\n             skewlink e' a' (Node e1 a1 r ts1) (Node e2 a2 r ts2);\n     \\<And>e a ts.\n        tree_invar (Node e a r ts) \\<Longrightarrow>\n        size (tree_to_multiset (Node e a r ts)) \\<le> 2 ^ Suc r - 1;\n     tree_invar (Node e a (Suc r) ts);\n     2 ^ r - 1 + 2 ^ r - 1 \\<le> 2 ^ Suc r - 1;\n     Node e a (Suc r) ts =\n     link (Node e1 a1 r ts1) (Node e2 a2 r ts2)\\<rbrakk>\n    \\<Longrightarrow> size (tree_to_multiset (Node e a (Suc r) ts))\n                      \\<le> 2 ^ Suc (Suc r) - 1\n 2. \\<lbrakk>Node e a (Suc r) ts =\n             link (Node e1 a1 r ts1) (Node e2 a2 r ts2) \\<or>\n             Node e a (Suc r) ts =\n             skewlink e' a' (Node e1 a1 r ts1) (Node e2 a2 r ts2);\n     \\<And>e a ts.\n        tree_invar (Node e a r ts) \\<Longrightarrow>\n        size (tree_to_multiset (Node e a r ts)) \\<le> 2 ^ Suc r - 1;\n     tree_invar (Node e a (Suc r) ts);\n     2 ^ r - 1 + 2 ^ r - 1 \\<le> 2 ^ Suc r - 1;\n     Node e a (Suc r) ts \\<noteq>\n     link (Node e1 a1 r ts1) (Node e2 a2 r ts2)\\<rbrakk>\n    \\<Longrightarrow> size (tree_to_multiset (Node e a (Suc r) ts))\n                      \\<le> 2 ^ Suc (Suc r) - 1", "using iv1 iv2"], ["proof (prove)\nusing this:\n  size (tree_to_multiset (Node e1 a1 r ts1)) \\<le> 2 ^ Suc r - 1\n  size (tree_to_multiset (Node e2 a2 r ts2)) \\<le> 2 ^ Suc r - 1\n\ngoal (2 subgoals):\n 1. \\<lbrakk>Node e a (Suc r) ts =\n             link (Node e1 a1 r ts1) (Node e2 a2 r ts2) \\<or>\n             Node e a (Suc r) ts =\n             skewlink e' a' (Node e1 a1 r ts1) (Node e2 a2 r ts2);\n     \\<And>e a ts.\n        tree_invar (Node e a r ts) \\<Longrightarrow>\n        size (tree_to_multiset (Node e a r ts)) \\<le> 2 ^ Suc r - 1;\n     tree_invar (Node e a (Suc r) ts);\n     2 ^ r - 1 + 2 ^ r - 1 \\<le> 2 ^ Suc r - 1;\n     Node e a (Suc r) ts =\n     link (Node e1 a1 r ts1) (Node e2 a2 r ts2)\\<rbrakk>\n    \\<Longrightarrow> size (tree_to_multiset (Node e a (Suc r) ts))\n                      \\<le> 2 ^ Suc (Suc r) - 1\n 2. \\<lbrakk>Node e a (Suc r) ts =\n             link (Node e1 a1 r ts1) (Node e2 a2 r ts2) \\<or>\n             Node e a (Suc r) ts =\n             skewlink e' a' (Node e1 a1 r ts1) (Node e2 a2 r ts2);\n     \\<And>e a ts.\n        tree_invar (Node e a r ts) \\<Longrightarrow>\n        size (tree_to_multiset (Node e a r ts)) \\<le> 2 ^ Suc r - 1;\n     tree_invar (Node e a (Suc r) ts);\n     2 ^ r - 1 + 2 ^ r - 1 \\<le> 2 ^ Suc r - 1;\n     Node e a (Suc r) ts \\<noteq>\n     link (Node e1 a1 r ts1) (Node e2 a2 r ts2)\\<rbrakk>\n    \\<Longrightarrow> size (tree_to_multiset (Node e a (Suc r) ts))\n                      \\<le> 2 ^ Suc (Suc r) - 1", "apply (simp del: link.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Node e a (Suc r) ts =\n             link (Node e1 a1 r ts1) (Node e2 a2 r ts2) \\<or>\n             Node e a (Suc r) ts =\n             skewlink e' a' (Node e1 a1 r ts1) (Node e2 a2 r ts2);\n     \\<And>e a ts.\n        tree_invar (Node e a r ts) \\<Longrightarrow>\n        size (tree_to_multiset (Node e a r ts)) \\<le> 2 ^ Suc r - 1;\n     tree_invar (Node e a (Suc r) ts);\n     2 ^ r - 1 + 2 ^ r - 1 \\<le> 2 ^ Suc r - 1;\n     Node e a (Suc r) ts \\<noteq>\n     link (Node e1 a1 r ts1) (Node e2 a2 r ts2)\\<rbrakk>\n    \\<Longrightarrow> size (tree_to_multiset (Node e a (Suc r) ts))\n                      \\<le> 2 ^ Suc (Suc r) - 1", "using iv1 iv2"], ["proof (prove)\nusing this:\n  size (tree_to_multiset (Node e1 a1 r ts1)) \\<le> 2 ^ Suc r - 1\n  size (tree_to_multiset (Node e2 a2 r ts2)) \\<le> 2 ^ Suc r - 1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Node e a (Suc r) ts =\n             link (Node e1 a1 r ts1) (Node e2 a2 r ts2) \\<or>\n             Node e a (Suc r) ts =\n             skewlink e' a' (Node e1 a1 r ts1) (Node e2 a2 r ts2);\n     \\<And>e a ts.\n        tree_invar (Node e a r ts) \\<Longrightarrow>\n        size (tree_to_multiset (Node e a r ts)) \\<le> 2 ^ Suc r - 1;\n     tree_invar (Node e a (Suc r) ts);\n     2 ^ r - 1 + 2 ^ r - 1 \\<le> 2 ^ Suc r - 1;\n     Node e a (Suc r) ts \\<noteq>\n     link (Node e1 a1 r ts1) (Node e2 a2 r ts2)\\<rbrakk>\n    \\<Longrightarrow> size (tree_to_multiset (Node e a (Suc r) ts))\n                      \\<le> 2 ^ Suc (Suc r) - 1", "apply (simp del: skewlink.simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  size (tree_to_multiset (Node e a (Suc r) ts)) \\<le> 2 ^ Suc (Suc r) - 1\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma tree_rank_estimate_lower: \n  \"tree_invar (Node e a r ts) \\<Longrightarrow> \n   size (tree_to_multiset (Node e a r ts)) \\<ge> (2::nat)^r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tree_invar (Node e a r ts) \\<Longrightarrow>\n    2 ^ r \\<le> size (tree_to_multiset (Node e a r ts))", "proof (induct r arbitrary: e a ts)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>e a ts.\n       tree_invar (Node e a 0 ts) \\<Longrightarrow>\n       2 ^ 0 \\<le> size (tree_to_multiset (Node e a 0 ts))\n 2. \\<And>r e a ts.\n       \\<lbrakk>\\<And>e a ts.\n                   tree_invar (Node e a r ts) \\<Longrightarrow>\n                   2 ^ r \\<le> size (tree_to_multiset (Node e a r ts));\n        tree_invar (Node e a (Suc r) ts)\\<rbrakk>\n       \\<Longrightarrow> 2 ^ Suc r\n                         \\<le> size (tree_to_multiset (Node e a (Suc r) ts))", "case 0"], ["proof (state)\nthis:\n  tree_invar (Node e a 0 ts)\n\ngoal (2 subgoals):\n 1. \\<And>e a ts.\n       tree_invar (Node e a 0 ts) \\<Longrightarrow>\n       2 ^ 0 \\<le> size (tree_to_multiset (Node e a 0 ts))\n 2. \\<And>r e a ts.\n       \\<lbrakk>\\<And>e a ts.\n                   tree_invar (Node e a r ts) \\<Longrightarrow>\n                   2 ^ r \\<le> size (tree_to_multiset (Node e a r ts));\n        tree_invar (Node e a (Suc r) ts)\\<rbrakk>\n       \\<Longrightarrow> 2 ^ Suc r\n                         \\<le> size (tree_to_multiset (Node e a (Suc r) ts))", "then"], ["proof (chain)\npicking this:\n  tree_invar (Node e a 0 ts)", "show ?case"], ["proof (prove)\nusing this:\n  tree_invar (Node e a 0 ts)\n\ngoal (1 subgoal):\n 1. 2 ^ 0 \\<le> size (tree_to_multiset (Node e a 0 ts))", "by simp"], ["proof (state)\nthis:\n  2 ^ 0 \\<le> size (tree_to_multiset (Node e a 0 ts))\n\ngoal (1 subgoal):\n 1. \\<And>r e a ts.\n       \\<lbrakk>\\<And>e a ts.\n                   tree_invar (Node e a r ts) \\<Longrightarrow>\n                   2 ^ r \\<le> size (tree_to_multiset (Node e a r ts));\n        tree_invar (Node e a (Suc r) ts)\\<rbrakk>\n       \\<Longrightarrow> 2 ^ Suc r\n                         \\<le> size (tree_to_multiset (Node e a (Suc r) ts))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>r e a ts.\n       \\<lbrakk>\\<And>e a ts.\n                   tree_invar (Node e a r ts) \\<Longrightarrow>\n                   2 ^ r \\<le> size (tree_to_multiset (Node e a r ts));\n        tree_invar (Node e a (Suc r) ts)\\<rbrakk>\n       \\<Longrightarrow> 2 ^ Suc r\n                         \\<le> size (tree_to_multiset (Node e a (Suc r) ts))", "case (Suc r)"], ["proof (state)\nthis:\n  tree_invar (Node ?e ?a r ?ts) \\<Longrightarrow>\n  2 ^ r \\<le> size (tree_to_multiset (Node ?e ?a r ?ts))\n  tree_invar (Node e a (Suc r) ts)\n\ngoal (1 subgoal):\n 1. \\<And>r e a ts.\n       \\<lbrakk>\\<And>e a ts.\n                   tree_invar (Node e a r ts) \\<Longrightarrow>\n                   2 ^ r \\<le> size (tree_to_multiset (Node e a r ts));\n        tree_invar (Node e a (Suc r) ts)\\<rbrakk>\n       \\<Longrightarrow> 2 ^ Suc r\n                         \\<le> size (tree_to_multiset (Node e a (Suc r) ts))", "from Suc(2)"], ["proof (chain)\npicking this:\n  tree_invar (Node e a (Suc r) ts)", "obtain e1 a1 ts1 e2 a2 ts2 e' a' where\n    link:\n      \"(Node e a (Suc r) ts) = link (Node e1 a1 r ts1) (Node e2 a2 r ts2) \\<or>\n       (Node e a (Suc r) ts) = skewlink e' a' (Node e1 a1 r ts1) (Node e2 a2 r ts2)\"\n    and inv1: \"tree_invar (Node e1 a1 r ts1)\"\n    and inv2: \"tree_invar (Node e2 a2 r ts2)\""], ["proof (prove)\nusing this:\n  tree_invar (Node e a (Suc r) ts)\n\ngoal (1 subgoal):\n 1. (\\<And>e1 a1 ts1 e2 a2 ts2 e' a'.\n        \\<lbrakk>Node e a (Suc r) ts =\n                 link (Node e1 a1 r ts1) (Node e2 a2 r ts2) \\<or>\n                 Node e a (Suc r) ts =\n                 skewlink e' a' (Node e1 a1 r ts1) (Node e2 a2 r ts2);\n         tree_invar (Node e1 a1 r ts1);\n         tree_invar (Node e2 a2 r ts2)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by simp blast"], ["proof (state)\nthis:\n  Node e a (Suc r) ts = link (Node e1 a1 r ts1) (Node e2 a2 r ts2) \\<or>\n  Node e a (Suc r) ts = skewlink e' a' (Node e1 a1 r ts1) (Node e2 a2 r ts2)\n  tree_invar (Node e1 a1 r ts1)\n  tree_invar (Node e2 a2 r ts2)\n\ngoal (1 subgoal):\n 1. \\<And>r e a ts.\n       \\<lbrakk>\\<And>e a ts.\n                   tree_invar (Node e a r ts) \\<Longrightarrow>\n                   2 ^ r \\<le> size (tree_to_multiset (Node e a r ts));\n        tree_invar (Node e a (Suc r) ts)\\<rbrakk>\n       \\<Longrightarrow> 2 ^ Suc r\n                         \\<le> size (tree_to_multiset (Node e a (Suc r) ts))", "note iv1 = Suc(1)[OF inv1]"], ["proof (state)\nthis:\n  2 ^ r \\<le> size (tree_to_multiset (Node e1 a1 r ts1))\n\ngoal (1 subgoal):\n 1. \\<And>r e a ts.\n       \\<lbrakk>\\<And>e a ts.\n                   tree_invar (Node e a r ts) \\<Longrightarrow>\n                   2 ^ r \\<le> size (tree_to_multiset (Node e a r ts));\n        tree_invar (Node e a (Suc r) ts)\\<rbrakk>\n       \\<Longrightarrow> 2 ^ Suc r\n                         \\<le> size (tree_to_multiset (Node e a (Suc r) ts))", "note iv2 = Suc(1)[OF inv2]"], ["proof (state)\nthis:\n  2 ^ r \\<le> size (tree_to_multiset (Node e2 a2 r ts2))\n\ngoal (1 subgoal):\n 1. \\<And>r e a ts.\n       \\<lbrakk>\\<And>e a ts.\n                   tree_invar (Node e a r ts) \\<Longrightarrow>\n                   2 ^ r \\<le> size (tree_to_multiset (Node e a r ts));\n        tree_invar (Node e a (Suc r) ts)\\<rbrakk>\n       \\<Longrightarrow> 2 ^ Suc r\n                         \\<le> size (tree_to_multiset (Node e a (Suc r) ts))", "have \"(2::nat)^r - 1 + (2::nat)^r - 1 \\<le> (2::nat)^(Suc r) - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ r - 1 + 2 ^ r - 1 \\<le> 2 ^ Suc r - 1", "by simp"], ["proof (state)\nthis:\n  2 ^ r - 1 + 2 ^ r - 1 \\<le> 2 ^ Suc r - 1\n\ngoal (1 subgoal):\n 1. \\<And>r e a ts.\n       \\<lbrakk>\\<And>e a ts.\n                   tree_invar (Node e a r ts) \\<Longrightarrow>\n                   2 ^ r \\<le> size (tree_to_multiset (Node e a r ts));\n        tree_invar (Node e a (Suc r) ts)\\<rbrakk>\n       \\<Longrightarrow> 2 ^ Suc r\n                         \\<le> size (tree_to_multiset (Node e a (Suc r) ts))", "with link Suc"], ["proof (chain)\npicking this:\n  Node e a (Suc r) ts = link (Node e1 a1 r ts1) (Node e2 a2 r ts2) \\<or>\n  Node e a (Suc r) ts = skewlink e' a' (Node e1 a1 r ts1) (Node e2 a2 r ts2)\n  tree_invar (Node ?e ?a r ?ts) \\<Longrightarrow>\n  2 ^ r \\<le> size (tree_to_multiset (Node ?e ?a r ?ts))\n  tree_invar (Node e a (Suc r) ts)\n  2 ^ r - 1 + 2 ^ r - 1 \\<le> 2 ^ Suc r - 1", "show ?case"], ["proof (prove)\nusing this:\n  Node e a (Suc r) ts = link (Node e1 a1 r ts1) (Node e2 a2 r ts2) \\<or>\n  Node e a (Suc r) ts = skewlink e' a' (Node e1 a1 r ts1) (Node e2 a2 r ts2)\n  tree_invar (Node ?e ?a r ?ts) \\<Longrightarrow>\n  2 ^ r \\<le> size (tree_to_multiset (Node ?e ?a r ?ts))\n  tree_invar (Node e a (Suc r) ts)\n  2 ^ r - 1 + 2 ^ r - 1 \\<le> 2 ^ Suc r - 1\n\ngoal (1 subgoal):\n 1. 2 ^ Suc r \\<le> size (tree_to_multiset (Node e a (Suc r) ts))", "apply (cases \"Node e a (Suc r) ts = link (Node e1 a1 r ts1) (Node e2 a2 r ts2)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>Node e a (Suc r) ts =\n             link (Node e1 a1 r ts1) (Node e2 a2 r ts2) \\<or>\n             Node e a (Suc r) ts =\n             skewlink e' a' (Node e1 a1 r ts1) (Node e2 a2 r ts2);\n     \\<And>e a ts.\n        tree_invar (Node e a r ts) \\<Longrightarrow>\n        2 ^ r \\<le> size (tree_to_multiset (Node e a r ts));\n     tree_invar (Node e a (Suc r) ts);\n     2 ^ r - 1 + 2 ^ r - 1 \\<le> 2 ^ Suc r - 1;\n     Node e a (Suc r) ts =\n     link (Node e1 a1 r ts1) (Node e2 a2 r ts2)\\<rbrakk>\n    \\<Longrightarrow> 2 ^ Suc r\n                      \\<le> size (tree_to_multiset (Node e a (Suc r) ts))\n 2. \\<lbrakk>Node e a (Suc r) ts =\n             link (Node e1 a1 r ts1) (Node e2 a2 r ts2) \\<or>\n             Node e a (Suc r) ts =\n             skewlink e' a' (Node e1 a1 r ts1) (Node e2 a2 r ts2);\n     \\<And>e a ts.\n        tree_invar (Node e a r ts) \\<Longrightarrow>\n        2 ^ r \\<le> size (tree_to_multiset (Node e a r ts));\n     tree_invar (Node e a (Suc r) ts);\n     2 ^ r - 1 + 2 ^ r - 1 \\<le> 2 ^ Suc r - 1;\n     Node e a (Suc r) ts \\<noteq>\n     link (Node e1 a1 r ts1) (Node e2 a2 r ts2)\\<rbrakk>\n    \\<Longrightarrow> 2 ^ Suc r\n                      \\<le> size (tree_to_multiset (Node e a (Suc r) ts))", "using iv1 iv2"], ["proof (prove)\nusing this:\n  2 ^ r \\<le> size (tree_to_multiset (Node e1 a1 r ts1))\n  2 ^ r \\<le> size (tree_to_multiset (Node e2 a2 r ts2))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>Node e a (Suc r) ts =\n             link (Node e1 a1 r ts1) (Node e2 a2 r ts2) \\<or>\n             Node e a (Suc r) ts =\n             skewlink e' a' (Node e1 a1 r ts1) (Node e2 a2 r ts2);\n     \\<And>e a ts.\n        tree_invar (Node e a r ts) \\<Longrightarrow>\n        2 ^ r \\<le> size (tree_to_multiset (Node e a r ts));\n     tree_invar (Node e a (Suc r) ts);\n     2 ^ r - 1 + 2 ^ r - 1 \\<le> 2 ^ Suc r - 1;\n     Node e a (Suc r) ts =\n     link (Node e1 a1 r ts1) (Node e2 a2 r ts2)\\<rbrakk>\n    \\<Longrightarrow> 2 ^ Suc r\n                      \\<le> size (tree_to_multiset (Node e a (Suc r) ts))\n 2. \\<lbrakk>Node e a (Suc r) ts =\n             link (Node e1 a1 r ts1) (Node e2 a2 r ts2) \\<or>\n             Node e a (Suc r) ts =\n             skewlink e' a' (Node e1 a1 r ts1) (Node e2 a2 r ts2);\n     \\<And>e a ts.\n        tree_invar (Node e a r ts) \\<Longrightarrow>\n        2 ^ r \\<le> size (tree_to_multiset (Node e a r ts));\n     tree_invar (Node e a (Suc r) ts);\n     2 ^ r - 1 + 2 ^ r - 1 \\<le> 2 ^ Suc r - 1;\n     Node e a (Suc r) ts \\<noteq>\n     link (Node e1 a1 r ts1) (Node e2 a2 r ts2)\\<rbrakk>\n    \\<Longrightarrow> 2 ^ Suc r\n                      \\<le> size (tree_to_multiset (Node e a (Suc r) ts))", "apply (simp del: link.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Node e a (Suc r) ts =\n             link (Node e1 a1 r ts1) (Node e2 a2 r ts2) \\<or>\n             Node e a (Suc r) ts =\n             skewlink e' a' (Node e1 a1 r ts1) (Node e2 a2 r ts2);\n     \\<And>e a ts.\n        tree_invar (Node e a r ts) \\<Longrightarrow>\n        2 ^ r \\<le> size (tree_to_multiset (Node e a r ts));\n     tree_invar (Node e a (Suc r) ts);\n     2 ^ r - 1 + 2 ^ r - 1 \\<le> 2 ^ Suc r - 1;\n     Node e a (Suc r) ts \\<noteq>\n     link (Node e1 a1 r ts1) (Node e2 a2 r ts2)\\<rbrakk>\n    \\<Longrightarrow> 2 ^ Suc r\n                      \\<le> size (tree_to_multiset (Node e a (Suc r) ts))", "using iv1 iv2"], ["proof (prove)\nusing this:\n  2 ^ r \\<le> size (tree_to_multiset (Node e1 a1 r ts1))\n  2 ^ r \\<le> size (tree_to_multiset (Node e2 a2 r ts2))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Node e a (Suc r) ts =\n             link (Node e1 a1 r ts1) (Node e2 a2 r ts2) \\<or>\n             Node e a (Suc r) ts =\n             skewlink e' a' (Node e1 a1 r ts1) (Node e2 a2 r ts2);\n     \\<And>e a ts.\n        tree_invar (Node e a r ts) \\<Longrightarrow>\n        2 ^ r \\<le> size (tree_to_multiset (Node e a r ts));\n     tree_invar (Node e a (Suc r) ts);\n     2 ^ r - 1 + 2 ^ r - 1 \\<le> 2 ^ Suc r - 1;\n     Node e a (Suc r) ts \\<noteq>\n     link (Node e1 a1 r ts1) (Node e2 a2 r ts2)\\<rbrakk>\n    \\<Longrightarrow> 2 ^ Suc r\n                      \\<le> size (tree_to_multiset (Node e a (Suc r) ts))", "apply (simp del: skewlink.simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  2 ^ Suc r \\<le> size (tree_to_multiset (Node e a (Suc r) ts))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma tree_rank_height:\n  \"tree_invar (Node e a r ts) \\<Longrightarrow> height_tree (Node e a r ts) = r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tree_invar (Node e a r ts) \\<Longrightarrow>\n    height_tree (Node e a r ts) = r", "proof (induct r arbitrary: e a ts)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>e a ts.\n       tree_invar (Node e a 0 ts) \\<Longrightarrow>\n       height_tree (Node e a 0 ts) = 0\n 2. \\<And>r e a ts.\n       \\<lbrakk>\\<And>e a ts.\n                   tree_invar (Node e a r ts) \\<Longrightarrow>\n                   height_tree (Node e a r ts) = r;\n        tree_invar (Node e a (Suc r) ts)\\<rbrakk>\n       \\<Longrightarrow> height_tree (Node e a (Suc r) ts) = Suc r", "case 0"], ["proof (state)\nthis:\n  tree_invar (Node e a 0 ts)\n\ngoal (2 subgoals):\n 1. \\<And>e a ts.\n       tree_invar (Node e a 0 ts) \\<Longrightarrow>\n       height_tree (Node e a 0 ts) = 0\n 2. \\<And>r e a ts.\n       \\<lbrakk>\\<And>e a ts.\n                   tree_invar (Node e a r ts) \\<Longrightarrow>\n                   height_tree (Node e a r ts) = r;\n        tree_invar (Node e a (Suc r) ts)\\<rbrakk>\n       \\<Longrightarrow> height_tree (Node e a (Suc r) ts) = Suc r", "then"], ["proof (chain)\npicking this:\n  tree_invar (Node e a 0 ts)", "show ?case"], ["proof (prove)\nusing this:\n  tree_invar (Node e a 0 ts)\n\ngoal (1 subgoal):\n 1. height_tree (Node e a 0 ts) = 0", "by simp"], ["proof (state)\nthis:\n  height_tree (Node e a 0 ts) = 0\n\ngoal (1 subgoal):\n 1. \\<And>r e a ts.\n       \\<lbrakk>\\<And>e a ts.\n                   tree_invar (Node e a r ts) \\<Longrightarrow>\n                   height_tree (Node e a r ts) = r;\n        tree_invar (Node e a (Suc r) ts)\\<rbrakk>\n       \\<Longrightarrow> height_tree (Node e a (Suc r) ts) = Suc r", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>r e a ts.\n       \\<lbrakk>\\<And>e a ts.\n                   tree_invar (Node e a r ts) \\<Longrightarrow>\n                   height_tree (Node e a r ts) = r;\n        tree_invar (Node e a (Suc r) ts)\\<rbrakk>\n       \\<Longrightarrow> height_tree (Node e a (Suc r) ts) = Suc r", "case (Suc r)"], ["proof (state)\nthis:\n  tree_invar (Node ?e ?a r ?ts) \\<Longrightarrow>\n  height_tree (Node ?e ?a r ?ts) = r\n  tree_invar (Node e a (Suc r) ts)\n\ngoal (1 subgoal):\n 1. \\<And>r e a ts.\n       \\<lbrakk>\\<And>e a ts.\n                   tree_invar (Node e a r ts) \\<Longrightarrow>\n                   height_tree (Node e a r ts) = r;\n        tree_invar (Node e a (Suc r) ts)\\<rbrakk>\n       \\<Longrightarrow> height_tree (Node e a (Suc r) ts) = Suc r", "from Suc(2)"], ["proof (chain)\npicking this:\n  tree_invar (Node e a (Suc r) ts)", "obtain e1 a1 ts1 e2 a2 ts2 e' a' where\n    link:\n      \"(Node e a (Suc r) ts) = link (Node e1 a1 r ts1) (Node e2 a2 r ts2) \\<or>\n       (Node e a (Suc r) ts) = skewlink e' a' (Node e1 a1 r ts1) (Node e2 a2 r ts2)\"\n    and inv1: \"tree_invar (Node e1 a1 r ts1)\"\n    and inv2: \"tree_invar (Node e2 a2 r ts2)\""], ["proof (prove)\nusing this:\n  tree_invar (Node e a (Suc r) ts)\n\ngoal (1 subgoal):\n 1. (\\<And>e1 a1 ts1 e2 a2 ts2 e' a'.\n        \\<lbrakk>Node e a (Suc r) ts =\n                 link (Node e1 a1 r ts1) (Node e2 a2 r ts2) \\<or>\n                 Node e a (Suc r) ts =\n                 skewlink e' a' (Node e1 a1 r ts1) (Node e2 a2 r ts2);\n         tree_invar (Node e1 a1 r ts1);\n         tree_invar (Node e2 a2 r ts2)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by simp blast"], ["proof (state)\nthis:\n  Node e a (Suc r) ts = link (Node e1 a1 r ts1) (Node e2 a2 r ts2) \\<or>\n  Node e a (Suc r) ts = skewlink e' a' (Node e1 a1 r ts1) (Node e2 a2 r ts2)\n  tree_invar (Node e1 a1 r ts1)\n  tree_invar (Node e2 a2 r ts2)\n\ngoal (1 subgoal):\n 1. \\<And>r e a ts.\n       \\<lbrakk>\\<And>e a ts.\n                   tree_invar (Node e a r ts) \\<Longrightarrow>\n                   height_tree (Node e a r ts) = r;\n        tree_invar (Node e a (Suc r) ts)\\<rbrakk>\n       \\<Longrightarrow> height_tree (Node e a (Suc r) ts) = Suc r", "note iv1 = Suc(1)[OF inv1]"], ["proof (state)\nthis:\n  height_tree (Node e1 a1 r ts1) = r\n\ngoal (1 subgoal):\n 1. \\<And>r e a ts.\n       \\<lbrakk>\\<And>e a ts.\n                   tree_invar (Node e a r ts) \\<Longrightarrow>\n                   height_tree (Node e a r ts) = r;\n        tree_invar (Node e a (Suc r) ts)\\<rbrakk>\n       \\<Longrightarrow> height_tree (Node e a (Suc r) ts) = Suc r", "note iv2 = Suc(1)[OF inv2]"], ["proof (state)\nthis:\n  height_tree (Node e2 a2 r ts2) = r\n\ngoal (1 subgoal):\n 1. \\<And>r e a ts.\n       \\<lbrakk>\\<And>e a ts.\n                   tree_invar (Node e a r ts) \\<Longrightarrow>\n                   height_tree (Node e a r ts) = r;\n        tree_invar (Node e a (Suc r) ts)\\<rbrakk>\n       \\<Longrightarrow> height_tree (Node e a (Suc r) ts) = Suc r", "from Suc(2) link"], ["proof (chain)\npicking this:\n  tree_invar (Node e a (Suc r) ts)\n  Node e a (Suc r) ts = link (Node e1 a1 r ts1) (Node e2 a2 r ts2) \\<or>\n  Node e a (Suc r) ts = skewlink e' a' (Node e1 a1 r ts1) (Node e2 a2 r ts2)", "show ?case"], ["proof (prove)\nusing this:\n  tree_invar (Node e a (Suc r) ts)\n  Node e a (Suc r) ts = link (Node e1 a1 r ts1) (Node e2 a2 r ts2) \\<or>\n  Node e a (Suc r) ts = skewlink e' a' (Node e1 a1 r ts1) (Node e2 a2 r ts2)\n\ngoal (1 subgoal):\n 1. height_tree (Node e a (Suc r) ts) = Suc r", "apply (cases \"Node e a (Suc r) ts = link (Node e1 a1 r ts1) (Node e2 a2 r ts2)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>tree_invar (Node e a (Suc r) ts);\n     Node e a (Suc r) ts = link (Node e1 a1 r ts1) (Node e2 a2 r ts2) \\<or>\n     Node e a (Suc r) ts =\n     skewlink e' a' (Node e1 a1 r ts1) (Node e2 a2 r ts2);\n     Node e a (Suc r) ts =\n     link (Node e1 a1 r ts1) (Node e2 a2 r ts2)\\<rbrakk>\n    \\<Longrightarrow> height_tree (Node e a (Suc r) ts) = Suc r\n 2. \\<lbrakk>tree_invar (Node e a (Suc r) ts);\n     Node e a (Suc r) ts = link (Node e1 a1 r ts1) (Node e2 a2 r ts2) \\<or>\n     Node e a (Suc r) ts =\n     skewlink e' a' (Node e1 a1 r ts1) (Node e2 a2 r ts2);\n     Node e a (Suc r) ts \\<noteq>\n     link (Node e1 a1 r ts1) (Node e2 a2 r ts2)\\<rbrakk>\n    \\<Longrightarrow> height_tree (Node e a (Suc r) ts) = Suc r", "apply (cases \"a1 \\<le> a2\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>tree_invar (Node e a (Suc r) ts);\n     Node e a (Suc r) ts = link (Node e1 a1 r ts1) (Node e2 a2 r ts2) \\<or>\n     Node e a (Suc r) ts =\n     skewlink e' a' (Node e1 a1 r ts1) (Node e2 a2 r ts2);\n     Node e a (Suc r) ts = link (Node e1 a1 r ts1) (Node e2 a2 r ts2);\n     a1 \\<le> a2\\<rbrakk>\n    \\<Longrightarrow> height_tree (Node e a (Suc r) ts) = Suc r\n 2. \\<lbrakk>tree_invar (Node e a (Suc r) ts);\n     Node e a (Suc r) ts = link (Node e1 a1 r ts1) (Node e2 a2 r ts2) \\<or>\n     Node e a (Suc r) ts =\n     skewlink e' a' (Node e1 a1 r ts1) (Node e2 a2 r ts2);\n     Node e a (Suc r) ts = link (Node e1 a1 r ts1) (Node e2 a2 r ts2);\n     \\<not> a1 \\<le> a2\\<rbrakk>\n    \\<Longrightarrow> height_tree (Node e a (Suc r) ts) = Suc r\n 3. \\<lbrakk>tree_invar (Node e a (Suc r) ts);\n     Node e a (Suc r) ts = link (Node e1 a1 r ts1) (Node e2 a2 r ts2) \\<or>\n     Node e a (Suc r) ts =\n     skewlink e' a' (Node e1 a1 r ts1) (Node e2 a2 r ts2);\n     Node e a (Suc r) ts \\<noteq>\n     link (Node e1 a1 r ts1) (Node e2 a2 r ts2)\\<rbrakk>\n    \\<Longrightarrow> height_tree (Node e a (Suc r) ts) = Suc r", "using iv1 iv2"], ["proof (prove)\nusing this:\n  height_tree (Node e1 a1 r ts1) = r\n  height_tree (Node e2 a2 r ts2) = r\n\ngoal (3 subgoals):\n 1. \\<lbrakk>tree_invar (Node e a (Suc r) ts);\n     Node e a (Suc r) ts = link (Node e1 a1 r ts1) (Node e2 a2 r ts2) \\<or>\n     Node e a (Suc r) ts =\n     skewlink e' a' (Node e1 a1 r ts1) (Node e2 a2 r ts2);\n     Node e a (Suc r) ts = link (Node e1 a1 r ts1) (Node e2 a2 r ts2);\n     a1 \\<le> a2\\<rbrakk>\n    \\<Longrightarrow> height_tree (Node e a (Suc r) ts) = Suc r\n 2. \\<lbrakk>tree_invar (Node e a (Suc r) ts);\n     Node e a (Suc r) ts = link (Node e1 a1 r ts1) (Node e2 a2 r ts2) \\<or>\n     Node e a (Suc r) ts =\n     skewlink e' a' (Node e1 a1 r ts1) (Node e2 a2 r ts2);\n     Node e a (Suc r) ts = link (Node e1 a1 r ts1) (Node e2 a2 r ts2);\n     \\<not> a1 \\<le> a2\\<rbrakk>\n    \\<Longrightarrow> height_tree (Node e a (Suc r) ts) = Suc r\n 3. \\<lbrakk>tree_invar (Node e a (Suc r) ts);\n     Node e a (Suc r) ts = link (Node e1 a1 r ts1) (Node e2 a2 r ts2) \\<or>\n     Node e a (Suc r) ts =\n     skewlink e' a' (Node e1 a1 r ts1) (Node e2 a2 r ts2);\n     Node e a (Suc r) ts \\<noteq>\n     link (Node e1 a1 r ts1) (Node e2 a2 r ts2)\\<rbrakk>\n    \\<Longrightarrow> height_tree (Node e a (Suc r) ts) = Suc r", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>tree_invar (Node e a (Suc r) ts);\n     Node e a (Suc r) ts = link (Node e1 a1 r ts1) (Node e2 a2 r ts2) \\<or>\n     Node e a (Suc r) ts =\n     skewlink e' a' (Node e1 a1 r ts1) (Node e2 a2 r ts2);\n     Node e a (Suc r) ts = link (Node e1 a1 r ts1) (Node e2 a2 r ts2);\n     \\<not> a1 \\<le> a2\\<rbrakk>\n    \\<Longrightarrow> height_tree (Node e a (Suc r) ts) = Suc r\n 2. \\<lbrakk>tree_invar (Node e a (Suc r) ts);\n     Node e a (Suc r) ts = link (Node e1 a1 r ts1) (Node e2 a2 r ts2) \\<or>\n     Node e a (Suc r) ts =\n     skewlink e' a' (Node e1 a1 r ts1) (Node e2 a2 r ts2);\n     Node e a (Suc r) ts \\<noteq>\n     link (Node e1 a1 r ts1) (Node e2 a2 r ts2)\\<rbrakk>\n    \\<Longrightarrow> height_tree (Node e a (Suc r) ts) = Suc r", "using iv1 iv2"], ["proof (prove)\nusing this:\n  height_tree (Node e1 a1 r ts1) = r\n  height_tree (Node e2 a2 r ts2) = r\n\ngoal (2 subgoals):\n 1. \\<lbrakk>tree_invar (Node e a (Suc r) ts);\n     Node e a (Suc r) ts = link (Node e1 a1 r ts1) (Node e2 a2 r ts2) \\<or>\n     Node e a (Suc r) ts =\n     skewlink e' a' (Node e1 a1 r ts1) (Node e2 a2 r ts2);\n     Node e a (Suc r) ts = link (Node e1 a1 r ts1) (Node e2 a2 r ts2);\n     \\<not> a1 \\<le> a2\\<rbrakk>\n    \\<Longrightarrow> height_tree (Node e a (Suc r) ts) = Suc r\n 2. \\<lbrakk>tree_invar (Node e a (Suc r) ts);\n     Node e a (Suc r) ts = link (Node e1 a1 r ts1) (Node e2 a2 r ts2) \\<or>\n     Node e a (Suc r) ts =\n     skewlink e' a' (Node e1 a1 r ts1) (Node e2 a2 r ts2);\n     Node e a (Suc r) ts \\<noteq>\n     link (Node e1 a1 r ts1) (Node e2 a2 r ts2)\\<rbrakk>\n    \\<Longrightarrow> height_tree (Node e a (Suc r) ts) = Suc r", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>tree_invar (Node e a (Suc r) ts);\n     Node e a (Suc r) ts = link (Node e1 a1 r ts1) (Node e2 a2 r ts2) \\<or>\n     Node e a (Suc r) ts =\n     skewlink e' a' (Node e1 a1 r ts1) (Node e2 a2 r ts2);\n     Node e a (Suc r) ts \\<noteq>\n     link (Node e1 a1 r ts1) (Node e2 a2 r ts2)\\<rbrakk>\n    \\<Longrightarrow> height_tree (Node e a (Suc r) ts) = Suc r", "apply (cases \"a' \\<le> a1 \\<and> a' \\<le> a2\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>tree_invar (Node e a (Suc r) ts);\n     Node e a (Suc r) ts = link (Node e1 a1 r ts1) (Node e2 a2 r ts2) \\<or>\n     Node e a (Suc r) ts =\n     skewlink e' a' (Node e1 a1 r ts1) (Node e2 a2 r ts2);\n     Node e a (Suc r) ts \\<noteq>\n     link (Node e1 a1 r ts1) (Node e2 a2 r ts2);\n     a' \\<le> a1 \\<and> a' \\<le> a2\\<rbrakk>\n    \\<Longrightarrow> height_tree (Node e a (Suc r) ts) = Suc r\n 2. \\<lbrakk>tree_invar (Node e a (Suc r) ts);\n     Node e a (Suc r) ts = link (Node e1 a1 r ts1) (Node e2 a2 r ts2) \\<or>\n     Node e a (Suc r) ts =\n     skewlink e' a' (Node e1 a1 r ts1) (Node e2 a2 r ts2);\n     Node e a (Suc r) ts \\<noteq>\n     link (Node e1 a1 r ts1) (Node e2 a2 r ts2);\n     \\<not> (a' \\<le> a1 \\<and> a' \\<le> a2)\\<rbrakk>\n    \\<Longrightarrow> height_tree (Node e a (Suc r) ts) = Suc r", "apply (simp only: height_tree.simps)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>tree_invar (Node e a (Suc r) ts);\n     False \\<or>\n     Node e a (Suc r) ts =\n     skewlink e' a' (Node e1 a1 r ts1) (Node e2 a2 r ts2);\n     Node e a (Suc r) ts \\<noteq>\n     link (Node e1 a1 r ts1) (Node e2 a2 r ts2);\n     a' \\<le> a1 \\<and> a' \\<le> a2\\<rbrakk>\n    \\<Longrightarrow> height_queue ts = Suc r\n 2. \\<lbrakk>tree_invar (Node e a (Suc r) ts);\n     Node e a (Suc r) ts = link (Node e1 a1 r ts1) (Node e2 a2 r ts2) \\<or>\n     Node e a (Suc r) ts =\n     skewlink e' a' (Node e1 a1 r ts1) (Node e2 a2 r ts2);\n     Node e a (Suc r) ts \\<noteq>\n     link (Node e1 a1 r ts1) (Node e2 a2 r ts2);\n     \\<not> (a' \\<le> a1 \\<and> a' \\<le> a2)\\<rbrakk>\n    \\<Longrightarrow> height_tree (Node e a (Suc r) ts) = Suc r", "using iv1 iv2"], ["proof (prove)\nusing this:\n  height_tree (Node e1 a1 r ts1) = r\n  height_tree (Node e2 a2 r ts2) = r\n\ngoal (2 subgoals):\n 1. \\<lbrakk>tree_invar (Node e a (Suc r) ts);\n     False \\<or>\n     Node e a (Suc r) ts =\n     skewlink e' a' (Node e1 a1 r ts1) (Node e2 a2 r ts2);\n     Node e a (Suc r) ts \\<noteq>\n     link (Node e1 a1 r ts1) (Node e2 a2 r ts2);\n     a' \\<le> a1 \\<and> a' \\<le> a2\\<rbrakk>\n    \\<Longrightarrow> height_queue ts = Suc r\n 2. \\<lbrakk>tree_invar (Node e a (Suc r) ts);\n     Node e a (Suc r) ts = link (Node e1 a1 r ts1) (Node e2 a2 r ts2) \\<or>\n     Node e a (Suc r) ts =\n     skewlink e' a' (Node e1 a1 r ts1) (Node e2 a2 r ts2);\n     Node e a (Suc r) ts \\<noteq>\n     link (Node e1 a1 r ts1) (Node e2 a2 r ts2);\n     \\<not> (a' \\<le> a1 \\<and> a' \\<le> a2)\\<rbrakk>\n    \\<Longrightarrow> height_tree (Node e a (Suc r) ts) = Suc r", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>tree_invar (Node e a (Suc r) ts);\n     Node e a (Suc r) ts = link (Node e1 a1 r ts1) (Node e2 a2 r ts2) \\<or>\n     Node e a (Suc r) ts =\n     skewlink e' a' (Node e1 a1 r ts1) (Node e2 a2 r ts2);\n     Node e a (Suc r) ts \\<noteq>\n     link (Node e1 a1 r ts1) (Node e2 a2 r ts2);\n     \\<not> (a' \\<le> a1 \\<and> a' \\<le> a2)\\<rbrakk>\n    \\<Longrightarrow> height_tree (Node e a (Suc r) ts) = Suc r", "apply (cases \"a1 \\<le> a2\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>tree_invar (Node e a (Suc r) ts);\n     Node e a (Suc r) ts = link (Node e1 a1 r ts1) (Node e2 a2 r ts2) \\<or>\n     Node e a (Suc r) ts =\n     skewlink e' a' (Node e1 a1 r ts1) (Node e2 a2 r ts2);\n     Node e a (Suc r) ts \\<noteq>\n     link (Node e1 a1 r ts1) (Node e2 a2 r ts2);\n     \\<not> (a' \\<le> a1 \\<and> a' \\<le> a2); a1 \\<le> a2\\<rbrakk>\n    \\<Longrightarrow> height_tree (Node e a (Suc r) ts) = Suc r\n 2. \\<lbrakk>tree_invar (Node e a (Suc r) ts);\n     Node e a (Suc r) ts = link (Node e1 a1 r ts1) (Node e2 a2 r ts2) \\<or>\n     Node e a (Suc r) ts =\n     skewlink e' a' (Node e1 a1 r ts1) (Node e2 a2 r ts2);\n     Node e a (Suc r) ts \\<noteq>\n     link (Node e1 a1 r ts1) (Node e2 a2 r ts2);\n     \\<not> (a' \\<le> a1 \\<and> a' \\<le> a2); \\<not> a1 \\<le> a2\\<rbrakk>\n    \\<Longrightarrow> height_tree (Node e a (Suc r) ts) = Suc r", "using iv1 iv2"], ["proof (prove)\nusing this:\n  height_tree (Node e1 a1 r ts1) = r\n  height_tree (Node e2 a2 r ts2) = r\n\ngoal (2 subgoals):\n 1. \\<lbrakk>tree_invar (Node e a (Suc r) ts);\n     Node e a (Suc r) ts = link (Node e1 a1 r ts1) (Node e2 a2 r ts2) \\<or>\n     Node e a (Suc r) ts =\n     skewlink e' a' (Node e1 a1 r ts1) (Node e2 a2 r ts2);\n     Node e a (Suc r) ts \\<noteq>\n     link (Node e1 a1 r ts1) (Node e2 a2 r ts2);\n     \\<not> (a' \\<le> a1 \\<and> a' \\<le> a2); a1 \\<le> a2\\<rbrakk>\n    \\<Longrightarrow> height_tree (Node e a (Suc r) ts) = Suc r\n 2. \\<lbrakk>tree_invar (Node e a (Suc r) ts);\n     Node e a (Suc r) ts = link (Node e1 a1 r ts1) (Node e2 a2 r ts2) \\<or>\n     Node e a (Suc r) ts =\n     skewlink e' a' (Node e1 a1 r ts1) (Node e2 a2 r ts2);\n     Node e a (Suc r) ts \\<noteq>\n     link (Node e1 a1 r ts1) (Node e2 a2 r ts2);\n     \\<not> (a' \\<le> a1 \\<and> a' \\<le> a2); \\<not> a1 \\<le> a2\\<rbrakk>\n    \\<Longrightarrow> height_tree (Node e a (Suc r) ts) = Suc r", "apply (simp del: tree_invar.simps link.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>tree_invar (Node e a (Suc r) ts);\n     Node e a (Suc r) ts = link (Node e1 a1 r ts1) (Node e2 a2 r ts2) \\<or>\n     Node e a (Suc r) ts =\n     skewlink e' a' (Node e1 a1 r ts1) (Node e2 a2 r ts2);\n     Node e a (Suc r) ts \\<noteq>\n     link (Node e1 a1 r ts1) (Node e2 a2 r ts2);\n     \\<not> (a' \\<le> a1 \\<and> a' \\<le> a2); \\<not> a1 \\<le> a2\\<rbrakk>\n    \\<Longrightarrow> height_tree (Node e a (Suc r) ts) = Suc r", "using iv1 iv2"], ["proof (prove)\nusing this:\n  height_tree (Node e1 a1 r ts1) = r\n  height_tree (Node e2 a2 r ts2) = r\n\ngoal (1 subgoal):\n 1. \\<lbrakk>tree_invar (Node e a (Suc r) ts);\n     Node e a (Suc r) ts = link (Node e1 a1 r ts1) (Node e2 a2 r ts2) \\<or>\n     Node e a (Suc r) ts =\n     skewlink e' a' (Node e1 a1 r ts1) (Node e2 a2 r ts2);\n     Node e a (Suc r) ts \\<noteq>\n     link (Node e1 a1 r ts1) (Node e2 a2 r ts2);\n     \\<not> (a' \\<le> a1 \\<and> a' \\<le> a2); \\<not> a1 \\<le> a2\\<rbrakk>\n    \\<Longrightarrow> height_tree (Node e a (Suc r) ts) = Suc r", "apply (simp del: tree_invar.simps link.simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  height_tree (Node e a (Suc r) ts) = Suc r\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>A skew binomial tree of height $h$ contains at most  $2^{h+1} - 1$\n  elements\\<close>"], ["", "theorem tree_height_estimate_upper:\n  \"tree_invar t \\<Longrightarrow> \n  size (tree_to_multiset t) \\<le> (2::nat)^(Suc (height_tree t)) - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tree_invar t \\<Longrightarrow>\n    size (tree_to_multiset t) \\<le> 2 ^ Suc (height_tree t) - 1", "apply (cases t, simp only:)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x3 x4.\n       \\<lbrakk>tree_invar (Node x1 x2 x3 x4); t = Node x1 x2 x3 x4\\<rbrakk>\n       \\<Longrightarrow> size (tree_to_multiset (Node x1 x2 x3 x4))\n                         \\<le> 2 ^ Suc (height_tree (Node x1 x2 x3 x4)) - 1", "apply (frule tree_rank_estimate_upper)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x3 x4.\n       \\<lbrakk>tree_invar (Node x1 x2 x3 x4); t = Node x1 x2 x3 x4;\n        size (tree_to_multiset (Node x1 x2 x3 x4))\n        \\<le> 2 ^ Suc x3 - 1\\<rbrakk>\n       \\<Longrightarrow> size (tree_to_multiset (Node x1 x2 x3 x4))\n                         \\<le> 2 ^ Suc (height_tree (Node x1 x2 x3 x4)) - 1", "apply (frule tree_rank_height)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x3 x4.\n       \\<lbrakk>tree_invar (Node x1 x2 x3 x4); t = Node x1 x2 x3 x4;\n        size (tree_to_multiset (Node x1 x2 x3 x4)) \\<le> 2 ^ Suc x3 - 1;\n        height_tree (Node x1 x2 x3 x4) = x3\\<rbrakk>\n       \\<Longrightarrow> size (tree_to_multiset (Node x1 x2 x3 x4))\n                         \\<le> 2 ^ Suc (height_tree (Node x1 x2 x3 x4)) - 1", "apply (simp only: )"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>A skew binomial tree of height $h$ contains at least  $2^{h}$ elements\\<close>"], ["", "theorem tree_height_estimate_lower:\n  \"tree_invar t \\<Longrightarrow> size (tree_to_multiset t) \\<ge> (2::nat)^(height_tree t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tree_invar t \\<Longrightarrow>\n    2 ^ height_tree t \\<le> size (tree_to_multiset t)", "apply (cases t, simp only:)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x3 x4.\n       \\<lbrakk>tree_invar (Node x1 x2 x3 x4); t = Node x1 x2 x3 x4\\<rbrakk>\n       \\<Longrightarrow> 2 ^ height_tree (Node x1 x2 x3 x4)\n                         \\<le> size (tree_to_multiset (Node x1 x2 x3 x4))", "apply (frule tree_rank_estimate_lower)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x3 x4.\n       \\<lbrakk>tree_invar (Node x1 x2 x3 x4); t = Node x1 x2 x3 x4;\n        2 ^ x3 \\<le> size (tree_to_multiset (Node x1 x2 x3 x4))\\<rbrakk>\n       \\<Longrightarrow> 2 ^ height_tree (Node x1 x2 x3 x4)\n                         \\<le> size (tree_to_multiset (Node x1 x2 x3 x4))", "apply (frule tree_rank_height)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x3 x4.\n       \\<lbrakk>tree_invar (Node x1 x2 x3 x4); t = Node x1 x2 x3 x4;\n        2 ^ x3 \\<le> size (tree_to_multiset (Node x1 x2 x3 x4));\n        height_tree (Node x1 x2 x3 x4) = x3\\<rbrakk>\n       \\<Longrightarrow> 2 ^ height_tree (Node x1 x2 x3 x4)\n                         \\<le> size (tree_to_multiset (Node x1 x2 x3 x4))", "apply (simp only: )"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma size_mset_tree_upper: \"tree_invar t \\<Longrightarrow> \n  size (tree_to_multiset t) \\<le> (2::nat)^(Suc (rank t)) - (1::nat)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tree_invar t \\<Longrightarrow>\n    size (tree_to_multiset t) \\<le> 2 ^ Suc (rank t) - 1", "apply (cases t)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x3 x4.\n       \\<lbrakk>tree_invar t; t = Node x1 x2 x3 x4\\<rbrakk>\n       \\<Longrightarrow> size (tree_to_multiset t)\n                         \\<le> 2 ^ Suc (rank t) - 1", "by (simp only: tree_rank_estimate_upper SkewBinomialTree.sel(3))"], ["", "lemma size_mset_tree_lower: \"tree_invar t \\<Longrightarrow> \n  size (tree_to_multiset t) \\<ge> (2::nat)^(rank t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tree_invar t \\<Longrightarrow>\n    2 ^ rank t \\<le> size (tree_to_multiset t)", "apply (cases t)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x3 x4.\n       \\<lbrakk>tree_invar t; t = Node x1 x2 x3 x4\\<rbrakk>\n       \\<Longrightarrow> 2 ^ rank t \\<le> size (tree_to_multiset t)", "by (simp only: tree_rank_estimate_lower SkewBinomialTree.sel(3))"], ["", "lemma invar_butlast: \"invar (bq @ [t]) \\<Longrightarrow> invar bq\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invar (bq @ [t]) \\<Longrightarrow> invar bq", "unfolding invar_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. queue_invar (bq @ [t]) \\<and>\n    rank_skew_invar (bq @ [t]) \\<Longrightarrow>\n    queue_invar bq \\<and> rank_skew_invar bq", "apply (induct bq)"], ["proof (prove)\ngoal (2 subgoals):\n 1. queue_invar ([] @ [t]) \\<and>\n    rank_skew_invar ([] @ [t]) \\<Longrightarrow>\n    queue_invar [] \\<and> rank_skew_invar []\n 2. \\<And>a bq.\n       \\<lbrakk>queue_invar (bq @ [t]) \\<and>\n                rank_skew_invar (bq @ [t]) \\<Longrightarrow>\n                queue_invar bq \\<and> rank_skew_invar bq;\n        queue_invar ((a # bq) @ [t]) \\<and>\n        rank_skew_invar ((a # bq) @ [t])\\<rbrakk>\n       \\<Longrightarrow> queue_invar (a # bq) \\<and>\n                         rank_skew_invar (a # bq)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a bq.\n       \\<lbrakk>queue_invar (bq @ [t]) \\<and>\n                rank_skew_invar (bq @ [t]) \\<Longrightarrow>\n                queue_invar bq \\<and> rank_skew_invar bq;\n        queue_invar ((a # bq) @ [t]) \\<and>\n        rank_skew_invar ((a # bq) @ [t])\\<rbrakk>\n       \\<Longrightarrow> queue_invar (a # bq) \\<and>\n                         rank_skew_invar (a # bq)", "apply (case_tac bq)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a bq.\n       \\<lbrakk>queue_invar (bq @ [t]) \\<and>\n                rank_skew_invar (bq @ [t]) \\<Longrightarrow>\n                queue_invar bq \\<and> rank_skew_invar bq;\n        queue_invar ((a # bq) @ [t]) \\<and>\n        rank_skew_invar ((a # bq) @ [t]);\n        bq = []\\<rbrakk>\n       \\<Longrightarrow> queue_invar (a # bq) \\<and>\n                         rank_skew_invar (a # bq)\n 2. \\<And>a bq aa list.\n       \\<lbrakk>queue_invar (bq @ [t]) \\<and>\n                rank_skew_invar (bq @ [t]) \\<Longrightarrow>\n                queue_invar bq \\<and> rank_skew_invar bq;\n        queue_invar ((a # bq) @ [t]) \\<and>\n        rank_skew_invar ((a # bq) @ [t]);\n        bq = aa # list\\<rbrakk>\n       \\<Longrightarrow> queue_invar (a # bq) \\<and>\n                         rank_skew_invar (a # bq)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a bq aa list.\n       \\<lbrakk>queue_invar (bq @ [t]) \\<and>\n                rank_skew_invar (bq @ [t]) \\<Longrightarrow>\n                queue_invar bq \\<and> rank_skew_invar bq;\n        queue_invar ((a # bq) @ [t]) \\<and>\n        rank_skew_invar ((a # bq) @ [t]);\n        bq = aa # list\\<rbrakk>\n       \\<Longrightarrow> queue_invar (a # bq) \\<and>\n                         rank_skew_invar (a # bq)", "apply (case_tac list)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a bq aa list.\n       \\<lbrakk>queue_invar (bq @ [t]) \\<and>\n                rank_skew_invar (bq @ [t]) \\<Longrightarrow>\n                queue_invar bq \\<and> rank_skew_invar bq;\n        queue_invar ((a # bq) @ [t]) \\<and>\n        rank_skew_invar ((a # bq) @ [t]);\n        bq = aa # list; list = []\\<rbrakk>\n       \\<Longrightarrow> queue_invar (a # bq) \\<and>\n                         rank_skew_invar (a # bq)\n 2. \\<And>a bq aa list ab lista.\n       \\<lbrakk>queue_invar (bq @ [t]) \\<and>\n                rank_skew_invar (bq @ [t]) \\<Longrightarrow>\n                queue_invar bq \\<and> rank_skew_invar bq;\n        queue_invar ((a # bq) @ [t]) \\<and>\n        rank_skew_invar ((a # bq) @ [t]);\n        bq = aa # list; list = ab # lista\\<rbrakk>\n       \\<Longrightarrow> queue_invar (a # bq) \\<and>\n                         rank_skew_invar (a # bq)", "by simp_all"], ["", "lemma invar_last_max: \n  \"invar ((b#b'#bq) @ [m]) \\<Longrightarrow> \\<forall> t \\<in> set (b'#bq). rank t < rank m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invar ((b # b' # bq) @ [m]) \\<Longrightarrow>\n    \\<forall>t\\<in>set (b' # bq). rank t < rank m", "unfolding invar_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. queue_invar ((b # b' # bq) @ [m]) \\<and>\n    rank_skew_invar ((b # b' # bq) @ [m]) \\<Longrightarrow>\n    \\<forall>t\\<in>set (b' # bq). rank t < rank m", "apply (induct bq)"], ["proof (prove)\ngoal (2 subgoals):\n 1. queue_invar ([b, b'] @ [m]) \\<and>\n    rank_skew_invar ([b, b'] @ [m]) \\<Longrightarrow>\n    \\<forall>t\\<in>set [b']. rank t < rank m\n 2. \\<And>a bq.\n       \\<lbrakk>queue_invar ((b # b' # bq) @ [m]) \\<and>\n                rank_skew_invar ((b # b' # bq) @ [m]) \\<Longrightarrow>\n                \\<forall>t\\<in>set (b' # bq). rank t < rank m;\n        queue_invar ((b # b' # a # bq) @ [m]) \\<and>\n        rank_skew_invar ((b # b' # a # bq) @ [m])\\<rbrakk>\n       \\<Longrightarrow> \\<forall>t\\<in>set (b' # a # bq). rank t < rank m", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a bq.\n       \\<lbrakk>queue_invar ((b # b' # bq) @ [m]) \\<and>\n                rank_skew_invar ((b # b' # bq) @ [m]) \\<Longrightarrow>\n                \\<forall>t\\<in>set (b' # bq). rank t < rank m;\n        queue_invar ((b # b' # a # bq) @ [m]) \\<and>\n        rank_skew_invar ((b # b' # a # bq) @ [m])\\<rbrakk>\n       \\<Longrightarrow> \\<forall>t\\<in>set (b' # a # bq). rank t < rank m", "apply (case_tac bq)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a bq.\n       \\<lbrakk>queue_invar ((b # b' # bq) @ [m]) \\<and>\n                rank_skew_invar ((b # b' # bq) @ [m]) \\<Longrightarrow>\n                \\<forall>t\\<in>set (b' # bq). rank t < rank m;\n        queue_invar ((b # b' # a # bq) @ [m]) \\<and>\n        rank_skew_invar ((b # b' # a # bq) @ [m]);\n        bq = []\\<rbrakk>\n       \\<Longrightarrow> \\<forall>t\\<in>set (b' # a # bq). rank t < rank m\n 2. \\<And>a bq aa list.\n       \\<lbrakk>queue_invar ((b # b' # bq) @ [m]) \\<and>\n                rank_skew_invar ((b # b' # bq) @ [m]) \\<Longrightarrow>\n                \\<forall>t\\<in>set (b' # bq). rank t < rank m;\n        queue_invar ((b # b' # a # bq) @ [m]) \\<and>\n        rank_skew_invar ((b # b' # a # bq) @ [m]);\n        bq = aa # list\\<rbrakk>\n       \\<Longrightarrow> \\<forall>t\\<in>set (b' # a # bq). rank t < rank m", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a bq aa list.\n       \\<lbrakk>queue_invar ((b # b' # bq) @ [m]) \\<and>\n                rank_skew_invar ((b # b' # bq) @ [m]) \\<Longrightarrow>\n                \\<forall>t\\<in>set (b' # bq). rank t < rank m;\n        queue_invar ((b # b' # a # bq) @ [m]) \\<and>\n        rank_skew_invar ((b # b' # a # bq) @ [m]);\n        bq = aa # list\\<rbrakk>\n       \\<Longrightarrow> \\<forall>t\\<in>set (b' # a # bq). rank t < rank m", "by simp"], ["", "lemma invar_last_max': \"invar ((b#b'#bq) @ [m]) \\<Longrightarrow> rank b \\<le> rank b'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invar ((b # b' # bq) @ [m]) \\<Longrightarrow> rank b \\<le> rank b'", "unfolding invar_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. queue_invar ((b # b' # bq) @ [m]) \\<and>\n    rank_skew_invar ((b # b' # bq) @ [m]) \\<Longrightarrow>\n    rank b \\<le> rank b'", "by simp"], ["", "lemma invar_length: \"invar bq \\<Longrightarrow> length bq \\<le> Suc (Suc (rank (last bq)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invar bq \\<Longrightarrow> length bq \\<le> Suc (Suc (rank (last bq)))", "proof (induct bq rule: rev_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. invar [] \\<Longrightarrow> length [] \\<le> Suc (Suc (rank (last [])))\n 2. \\<And>x xs.\n       \\<lbrakk>invar xs \\<Longrightarrow>\n                length xs \\<le> Suc (Suc (rank (last xs)));\n        invar (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> length (xs @ [x])\n                         \\<le> Suc (Suc (rank (last (xs @ [x]))))", "case Nil"], ["proof (state)\nthis:\n  invar []\n\ngoal (2 subgoals):\n 1. invar [] \\<Longrightarrow> length [] \\<le> Suc (Suc (rank (last [])))\n 2. \\<And>x xs.\n       \\<lbrakk>invar xs \\<Longrightarrow>\n                length xs \\<le> Suc (Suc (rank (last xs)));\n        invar (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> length (xs @ [x])\n                         \\<le> Suc (Suc (rank (last (xs @ [x]))))", "thus ?case"], ["proof (prove)\nusing this:\n  invar []\n\ngoal (1 subgoal):\n 1. length [] \\<le> Suc (Suc (rank (last [])))", "by simp"], ["proof (state)\nthis:\n  length [] \\<le> Suc (Suc (rank (last [])))\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>invar xs \\<Longrightarrow>\n                length xs \\<le> Suc (Suc (rank (last xs)));\n        invar (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> length (xs @ [x])\n                         \\<le> Suc (Suc (rank (last (xs @ [x]))))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>invar xs \\<Longrightarrow>\n                length xs \\<le> Suc (Suc (rank (last xs)));\n        invar (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> length (xs @ [x])\n                         \\<le> Suc (Suc (rank (last (xs @ [x]))))", "case (snoc x xs)"], ["proof (state)\nthis:\n  invar xs \\<Longrightarrow> length xs \\<le> Suc (Suc (rank (last xs)))\n  invar (xs @ [x])\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>invar xs \\<Longrightarrow>\n                length xs \\<le> Suc (Suc (rank (last xs)));\n        invar (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> length (xs @ [x])\n                         \\<le> Suc (Suc (rank (last (xs @ [x]))))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (xs @ [x]) \\<le> Suc (Suc (rank (last (xs @ [x]))))", "proof (cases xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    length (xs @ [x]) \\<le> Suc (Suc (rank (last (xs @ [x]))))\n 2. \\<And>a list.\n       xs = a # list \\<Longrightarrow>\n       length (xs @ [x]) \\<le> Suc (Suc (rank (last (xs @ [x]))))", "case Nil"], ["proof (state)\nthis:\n  xs = []\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    length (xs @ [x]) \\<le> Suc (Suc (rank (last (xs @ [x]))))\n 2. \\<And>a list.\n       xs = a # list \\<Longrightarrow>\n       length (xs @ [x]) \\<le> Suc (Suc (rank (last (xs @ [x]))))", "thus ?thesis"], ["proof (prove)\nusing this:\n  xs = []\n\ngoal (1 subgoal):\n 1. length (xs @ [x]) \\<le> Suc (Suc (rank (last (xs @ [x]))))", "by simp"], ["proof (state)\nthis:\n  length (xs @ [x]) \\<le> Suc (Suc (rank (last (xs @ [x]))))\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       xs = a # list \\<Longrightarrow>\n       length (xs @ [x]) \\<le> Suc (Suc (rank (last (xs @ [x]))))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       xs = a # list \\<Longrightarrow>\n       length (xs @ [x]) \\<le> Suc (Suc (rank (last (xs @ [x]))))", "case [simp]: (Cons xxs xx)"], ["proof (state)\nthis:\n  xs = xxs # xx\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       xs = a # list \\<Longrightarrow>\n       length (xs @ [x]) \\<le> Suc (Suc (rank (last (xs @ [x]))))", "note Cons' = Cons"], ["proof (state)\nthis:\n  xs = xxs # xx\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       xs = a # list \\<Longrightarrow>\n       length (xs @ [x]) \\<le> Suc (Suc (rank (last (xs @ [x]))))", "thus ?thesis"], ["proof (prove)\nusing this:\n  xs = xxs # xx\n\ngoal (1 subgoal):\n 1. length (xs @ [x]) \\<le> Suc (Suc (rank (last (xs @ [x]))))", "proof (cases xx)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>xs = xxs # xx; xx = []\\<rbrakk>\n    \\<Longrightarrow> length (xs @ [x])\n                      \\<le> Suc (Suc (rank (last (xs @ [x]))))\n 2. \\<And>a list.\n       \\<lbrakk>xs = xxs # xx; xx = a # list\\<rbrakk>\n       \\<Longrightarrow> length (xs @ [x])\n                         \\<le> Suc (Suc (rank (last (xs @ [x]))))", "case Nil"], ["proof (state)\nthis:\n  xx = []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>xs = xxs # xx; xx = []\\<rbrakk>\n    \\<Longrightarrow> length (xs @ [x])\n                      \\<le> Suc (Suc (rank (last (xs @ [x]))))\n 2. \\<And>a list.\n       \\<lbrakk>xs = xxs # xx; xx = a # list\\<rbrakk>\n       \\<Longrightarrow> length (xs @ [x])\n                         \\<le> Suc (Suc (rank (last (xs @ [x]))))", "with snoc.prems Cons"], ["proof (chain)\npicking this:\n  invar (xs @ [x])\n  xs = xxs # xx\n  xx = []", "show ?thesis"], ["proof (prove)\nusing this:\n  invar (xs @ [x])\n  xs = xxs # xx\n  xx = []\n\ngoal (1 subgoal):\n 1. length (xs @ [x]) \\<le> Suc (Suc (rank (last (xs @ [x]))))", "by simp"], ["proof (state)\nthis:\n  length (xs @ [x]) \\<le> Suc (Suc (rank (last (xs @ [x]))))\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>xs = xxs # xx; xx = a # list\\<rbrakk>\n       \\<Longrightarrow> length (xs @ [x])\n                         \\<le> Suc (Suc (rank (last (xs @ [x]))))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>xs = xxs # xx; xx = a # list\\<rbrakk>\n       \\<Longrightarrow> length (xs @ [x])\n                         \\<le> Suc (Suc (rank (last (xs @ [x]))))", "case (Cons xxxs xxx)"], ["proof (state)\nthis:\n  xx = xxxs # xxx\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>xs = xxs # xx; xx = a # list\\<rbrakk>\n       \\<Longrightarrow> length (xs @ [x])\n                         \\<le> Suc (Suc (rank (last (xs @ [x]))))", "from snoc.hyps[OF invar_butlast[OF snoc.prems]]"], ["proof (chain)\npicking this:\n  length xs \\<le> Suc (Suc (rank (last xs)))", "have\n        IH: \"length xs \\<le> Suc (Suc (rank (last xs)))\""], ["proof (prove)\nusing this:\n  length xs \\<le> Suc (Suc (rank (last xs)))\n\ngoal (1 subgoal):\n 1. length xs \\<le> Suc (Suc (rank (last xs)))", "."], ["proof (state)\nthis:\n  length xs \\<le> Suc (Suc (rank (last xs)))\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>xs = xxs # xx; xx = a # list\\<rbrakk>\n       \\<Longrightarrow> length (xs @ [x])\n                         \\<le> Suc (Suc (rank (last (xs @ [x]))))", "also"], ["proof (state)\nthis:\n  length xs \\<le> Suc (Suc (rank (last xs)))\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>xs = xxs # xx; xx = a # list\\<rbrakk>\n       \\<Longrightarrow> length (xs @ [x])\n                         \\<le> Suc (Suc (rank (last (xs @ [x]))))", "from invar_last_max[OF snoc.prems[unfolded Cons' Cons]] \n                invar_last_max'[OF snoc.prems[unfolded Cons' Cons]] \n                last_in_set[of xs] Cons"], ["proof (chain)\npicking this:\n  \\<forall>t\\<in>set (xxxs # xxx). rank t < rank x\n  rank xxs \\<le> rank xxxs\n  xs \\<noteq> [] \\<Longrightarrow> last xs \\<in> set xs\n  xx = xxxs # xxx", "have\n        \"Suc (rank (last xs)) \\<le> rank (last (xs @ [x]))\""], ["proof (prove)\nusing this:\n  \\<forall>t\\<in>set (xxxs # xxx). rank t < rank x\n  rank xxs \\<le> rank xxxs\n  xs \\<noteq> [] \\<Longrightarrow> last xs \\<in> set xs\n  xx = xxxs # xxx\n\ngoal (1 subgoal):\n 1. Suc (rank (last xs)) \\<le> rank (last (xs @ [x]))", "by auto"], ["proof (state)\nthis:\n  Suc (rank (last xs)) \\<le> rank (last (xs @ [x]))\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>xs = xxs # xx; xx = a # list\\<rbrakk>\n       \\<Longrightarrow> length (xs @ [x])\n                         \\<le> Suc (Suc (rank (last (xs @ [x]))))", "finally"], ["proof (chain)\npicking this:\n  (\\<And>x y.\n      x \\<le> y \\<Longrightarrow> Suc x \\<le> Suc y) \\<Longrightarrow>\n  length xs \\<le> Suc (rank (last (xs @ [x])))", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<And>x y.\n      x \\<le> y \\<Longrightarrow> Suc x \\<le> Suc y) \\<Longrightarrow>\n  length xs \\<le> Suc (rank (last (xs @ [x])))\n\ngoal (1 subgoal):\n 1. length (xs @ [x]) \\<le> Suc (Suc (rank (last (xs @ [x]))))", "by simp"], ["proof (state)\nthis:\n  length (xs @ [x]) \\<le> Suc (Suc (rank (last (xs @ [x]))))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  length (xs @ [x]) \\<le> Suc (Suc (rank (last (xs @ [x]))))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  length (xs @ [x]) \\<le> Suc (Suc (rank (last (xs @ [x]))))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma size_queue_sum_list: \n  \"size (queue_to_multiset bq) = sum_list (map (size \\<circ> tree_to_multiset) bq)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. size (queue_to_multiset bq) =\n    sum_list (map (size \\<circ> tree_to_multiset) bq)", "by (induct bq) simp_all"], ["", "text \\<open>\n  A skew binomial heap of length $l$ contains at least $2^{l-1} - 1$ elements. \n\\<close>"], ["", "theorem queue_length_estimate_lower: \n  \"invar bq \\<Longrightarrow> (size (queue_to_multiset bq)) \\<ge> 2^(length bq - 1) - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invar bq \\<Longrightarrow>\n    2 ^ (length bq - 1) - 1 \\<le> size (queue_to_multiset bq)", "proof (induct bq rule: rev_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. invar [] \\<Longrightarrow>\n    2 ^ (length [] - 1) - 1 \\<le> size (queue_to_multiset [])\n 2. \\<And>x xs.\n       \\<lbrakk>invar xs \\<Longrightarrow>\n                2 ^ (length xs - 1) - 1 \\<le> size (queue_to_multiset xs);\n        invar (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> 2 ^ (length (xs @ [x]) - 1) - 1\n                         \\<le> size (queue_to_multiset (xs @ [x]))", "case Nil"], ["proof (state)\nthis:\n  invar []\n\ngoal (2 subgoals):\n 1. invar [] \\<Longrightarrow>\n    2 ^ (length [] - 1) - 1 \\<le> size (queue_to_multiset [])\n 2. \\<And>x xs.\n       \\<lbrakk>invar xs \\<Longrightarrow>\n                2 ^ (length xs - 1) - 1 \\<le> size (queue_to_multiset xs);\n        invar (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> 2 ^ (length (xs @ [x]) - 1) - 1\n                         \\<le> size (queue_to_multiset (xs @ [x]))", "thus ?case"], ["proof (prove)\nusing this:\n  invar []\n\ngoal (1 subgoal):\n 1. 2 ^ (length [] - 1) - 1 \\<le> size (queue_to_multiset [])", "by simp"], ["proof (state)\nthis:\n  2 ^ (length [] - 1) - 1 \\<le> size (queue_to_multiset [])\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>invar xs \\<Longrightarrow>\n                2 ^ (length xs - 1) - 1 \\<le> size (queue_to_multiset xs);\n        invar (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> 2 ^ (length (xs @ [x]) - 1) - 1\n                         \\<le> size (queue_to_multiset (xs @ [x]))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>invar xs \\<Longrightarrow>\n                2 ^ (length xs - 1) - 1 \\<le> size (queue_to_multiset xs);\n        invar (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> 2 ^ (length (xs @ [x]) - 1) - 1\n                         \\<le> size (queue_to_multiset (xs @ [x]))", "case (snoc x xs)"], ["proof (state)\nthis:\n  invar xs \\<Longrightarrow>\n  2 ^ (length xs - 1) - 1 \\<le> size (queue_to_multiset xs)\n  invar (xs @ [x])\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>invar xs \\<Longrightarrow>\n                2 ^ (length xs - 1) - 1 \\<le> size (queue_to_multiset xs);\n        invar (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> 2 ^ (length (xs @ [x]) - 1) - 1\n                         \\<le> size (queue_to_multiset (xs @ [x]))", "thus ?case"], ["proof (prove)\nusing this:\n  invar xs \\<Longrightarrow>\n  2 ^ (length xs - 1) - 1 \\<le> size (queue_to_multiset xs)\n  invar (xs @ [x])\n\ngoal (1 subgoal):\n 1. 2 ^ (length (xs @ [x]) - 1) - 1\n    \\<le> size (queue_to_multiset (xs @ [x]))", "proof (cases xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>invar xs \\<Longrightarrow>\n             2 ^ (length xs - 1) - 1 \\<le> size (queue_to_multiset xs);\n     invar (xs @ [x]); xs = []\\<rbrakk>\n    \\<Longrightarrow> 2 ^ (length (xs @ [x]) - 1) - 1\n                      \\<le> size (queue_to_multiset (xs @ [x]))\n 2. \\<And>a list.\n       \\<lbrakk>invar xs \\<Longrightarrow>\n                2 ^ (length xs - 1) - 1 \\<le> size (queue_to_multiset xs);\n        invar (xs @ [x]); xs = a # list\\<rbrakk>\n       \\<Longrightarrow> 2 ^ (length (xs @ [x]) - 1) - 1\n                         \\<le> size (queue_to_multiset (xs @ [x]))", "case Nil"], ["proof (state)\nthis:\n  xs = []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>invar xs \\<Longrightarrow>\n             2 ^ (length xs - 1) - 1 \\<le> size (queue_to_multiset xs);\n     invar (xs @ [x]); xs = []\\<rbrakk>\n    \\<Longrightarrow> 2 ^ (length (xs @ [x]) - 1) - 1\n                      \\<le> size (queue_to_multiset (xs @ [x]))\n 2. \\<And>a list.\n       \\<lbrakk>invar xs \\<Longrightarrow>\n                2 ^ (length xs - 1) - 1 \\<le> size (queue_to_multiset xs);\n        invar (xs @ [x]); xs = a # list\\<rbrakk>\n       \\<Longrightarrow> 2 ^ (length (xs @ [x]) - 1) - 1\n                         \\<le> size (queue_to_multiset (xs @ [x]))", "thus ?thesis"], ["proof (prove)\nusing this:\n  xs = []\n\ngoal (1 subgoal):\n 1. 2 ^ (length (xs @ [x]) - 1) - 1\n    \\<le> size (queue_to_multiset (xs @ [x]))", "by simp"], ["proof (state)\nthis:\n  2 ^ (length (xs @ [x]) - 1) - 1 \\<le> size (queue_to_multiset (xs @ [x]))\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>invar xs \\<Longrightarrow>\n                2 ^ (length xs - 1) - 1 \\<le> size (queue_to_multiset xs);\n        invar (xs @ [x]); xs = a # list\\<rbrakk>\n       \\<Longrightarrow> 2 ^ (length (xs @ [x]) - 1) - 1\n                         \\<le> size (queue_to_multiset (xs @ [x]))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>invar xs \\<Longrightarrow>\n                2 ^ (length xs - 1) - 1 \\<le> size (queue_to_multiset xs);\n        invar (xs @ [x]); xs = a # list\\<rbrakk>\n       \\<Longrightarrow> 2 ^ (length (xs @ [x]) - 1) - 1\n                         \\<le> size (queue_to_multiset (xs @ [x]))", "case [simp]: (Cons xx xxs)"], ["proof (state)\nthis:\n  xs = xx # xxs\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>invar xs \\<Longrightarrow>\n                2 ^ (length xs - 1) - 1 \\<le> size (queue_to_multiset xs);\n        invar (xs @ [x]); xs = a # list\\<rbrakk>\n       \\<Longrightarrow> 2 ^ (length (xs @ [x]) - 1) - 1\n                         \\<le> size (queue_to_multiset (xs @ [x]))", "from snoc.hyps[OF invar_butlast[OF snoc.prems]]"], ["proof (chain)\npicking this:\n  2 ^ (length xs - 1) - 1 \\<le> size (queue_to_multiset xs)", "have IH: \"2 ^ (length xs - 1) \\<le> Suc (size (queue_to_multiset xs))\""], ["proof (prove)\nusing this:\n  2 ^ (length xs - 1) - 1 \\<le> size (queue_to_multiset xs)\n\ngoal (1 subgoal):\n 1. 2 ^ (length xs - 1) \\<le> Suc (size (queue_to_multiset xs))", "by simp"], ["proof (state)\nthis:\n  2 ^ (length xs - 1) \\<le> Suc (size (queue_to_multiset xs))\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>invar xs \\<Longrightarrow>\n                2 ^ (length xs - 1) - 1 \\<le> size (queue_to_multiset xs);\n        invar (xs @ [x]); xs = a # list\\<rbrakk>\n       \\<Longrightarrow> 2 ^ (length (xs @ [x]) - 1) - 1\n                         \\<le> size (queue_to_multiset (xs @ [x]))", "have size_q: \n      \"size (queue_to_multiset (xs @ [x])) = \n      size (queue_to_multiset xs) + size (tree_to_multiset x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. size (queue_to_multiset (xs @ [x])) =\n    size (queue_to_multiset xs) + size (tree_to_multiset x)", "by (simp add: size_queue_sum_list)"], ["proof (state)\nthis:\n  size (queue_to_multiset (xs @ [x])) =\n  size (queue_to_multiset xs) + size (tree_to_multiset x)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>invar xs \\<Longrightarrow>\n                2 ^ (length xs - 1) - 1 \\<le> size (queue_to_multiset xs);\n        invar (xs @ [x]); xs = a # list\\<rbrakk>\n       \\<Longrightarrow> 2 ^ (length (xs @ [x]) - 1) - 1\n                         \\<le> size (queue_to_multiset (xs @ [x]))", "moreover"], ["proof (state)\nthis:\n  size (queue_to_multiset (xs @ [x])) =\n  size (queue_to_multiset xs) + size (tree_to_multiset x)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>invar xs \\<Longrightarrow>\n                2 ^ (length xs - 1) - 1 \\<le> size (queue_to_multiset xs);\n        invar (xs @ [x]); xs = a # list\\<rbrakk>\n       \\<Longrightarrow> 2 ^ (length (xs @ [x]) - 1) - 1\n                         \\<le> size (queue_to_multiset (xs @ [x]))", "from snoc.prems"], ["proof (chain)\npicking this:\n  invar (xs @ [x])", "have inv_x: \"tree_invar x\""], ["proof (prove)\nusing this:\n  invar (xs @ [x])\n\ngoal (1 subgoal):\n 1. tree_invar x", "by (simp add: invar_def)"], ["proof (state)\nthis:\n  tree_invar x\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>invar xs \\<Longrightarrow>\n                2 ^ (length xs - 1) - 1 \\<le> size (queue_to_multiset xs);\n        invar (xs @ [x]); xs = a # list\\<rbrakk>\n       \\<Longrightarrow> 2 ^ (length (xs @ [x]) - 1) - 1\n                         \\<le> size (queue_to_multiset (xs @ [x]))", "from size_mset_tree_lower[OF this]"], ["proof (chain)\npicking this:\n  2 ^ rank x \\<le> size (tree_to_multiset x)", "have \"2 ^ (rank x) \\<le> size (tree_to_multiset x)\""], ["proof (prove)\nusing this:\n  2 ^ rank x \\<le> size (tree_to_multiset x)\n\ngoal (1 subgoal):\n 1. 2 ^ rank x \\<le> size (tree_to_multiset x)", "."], ["proof (state)\nthis:\n  2 ^ rank x \\<le> size (tree_to_multiset x)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>invar xs \\<Longrightarrow>\n                2 ^ (length xs - 1) - 1 \\<le> size (queue_to_multiset xs);\n        invar (xs @ [x]); xs = a # list\\<rbrakk>\n       \\<Longrightarrow> 2 ^ (length (xs @ [x]) - 1) - 1\n                         \\<le> size (queue_to_multiset (xs @ [x]))", "ultimately"], ["proof (chain)\npicking this:\n  size (queue_to_multiset (xs @ [x])) =\n  size (queue_to_multiset xs) + size (tree_to_multiset x)\n  2 ^ rank x \\<le> size (tree_to_multiset x)", "have \n      eq: \"size (queue_to_multiset xs) + (2::nat)^(rank x) \\<le> \n      size (queue_to_multiset (xs @ [x]))\""], ["proof (prove)\nusing this:\n  size (queue_to_multiset (xs @ [x])) =\n  size (queue_to_multiset xs) + size (tree_to_multiset x)\n  2 ^ rank x \\<le> size (tree_to_multiset x)\n\ngoal (1 subgoal):\n 1. size (queue_to_multiset xs) + 2 ^ rank x\n    \\<le> size (queue_to_multiset (xs @ [x]))", "by simp"], ["proof (state)\nthis:\n  size (queue_to_multiset xs) + 2 ^ rank x\n  \\<le> size (queue_to_multiset (xs @ [x]))\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>invar xs \\<Longrightarrow>\n                2 ^ (length xs - 1) - 1 \\<le> size (queue_to_multiset xs);\n        invar (xs @ [x]); xs = a # list\\<rbrakk>\n       \\<Longrightarrow> 2 ^ (length (xs @ [x]) - 1) - 1\n                         \\<le> size (queue_to_multiset (xs @ [x]))", "from invar_length[OF snoc.prems]"], ["proof (chain)\npicking this:\n  length (xs @ [x]) \\<le> Suc (Suc (rank (last (xs @ [x]))))", "have \"length xs \\<le> (rank x + 1)\""], ["proof (prove)\nusing this:\n  length (xs @ [x]) \\<le> Suc (Suc (rank (last (xs @ [x]))))\n\ngoal (1 subgoal):\n 1. length xs \\<le> rank x + 1", "by simp"], ["proof (state)\nthis:\n  length xs \\<le> rank x + 1\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>invar xs \\<Longrightarrow>\n                2 ^ (length xs - 1) - 1 \\<le> size (queue_to_multiset xs);\n        invar (xs @ [x]); xs = a # list\\<rbrakk>\n       \\<Longrightarrow> 2 ^ (length (xs @ [x]) - 1) - 1\n                         \\<le> size (queue_to_multiset (xs @ [x]))", "hence snd: \"(2::nat) ^ (length xs - 1) \\<le> (2::nat) ^ ((rank x))\""], ["proof (prove)\nusing this:\n  length xs \\<le> rank x + 1\n\ngoal (1 subgoal):\n 1. 2 ^ (length xs - 1) \\<le> 2 ^ rank x", "by (simp del: power.simps)"], ["proof (state)\nthis:\n  2 ^ (length xs - 1) \\<le> 2 ^ rank x\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>invar xs \\<Longrightarrow>\n                2 ^ (length xs - 1) - 1 \\<le> size (queue_to_multiset xs);\n        invar (xs @ [x]); xs = a # list\\<rbrakk>\n       \\<Longrightarrow> 2 ^ (length (xs @ [x]) - 1) - 1\n                         \\<le> size (queue_to_multiset (xs @ [x]))", "have\n      \"(2::nat) ^ (length (xs @ [x]) - 1) = \n      (2::nat) ^ (length xs - 1) + (2::nat) ^ (length xs - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ (length (xs @ [x]) - 1) = 2 ^ (length xs - 1) + 2 ^ (length xs - 1)", "by auto"], ["proof (state)\nthis:\n  2 ^ (length (xs @ [x]) - 1) = 2 ^ (length xs - 1) + 2 ^ (length xs - 1)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>invar xs \\<Longrightarrow>\n                2 ^ (length xs - 1) - 1 \\<le> size (queue_to_multiset xs);\n        invar (xs @ [x]); xs = a # list\\<rbrakk>\n       \\<Longrightarrow> 2 ^ (length (xs @ [x]) - 1) - 1\n                         \\<le> size (queue_to_multiset (xs @ [x]))", "with IH"], ["proof (chain)\npicking this:\n  2 ^ (length xs - 1) \\<le> Suc (size (queue_to_multiset xs))\n  2 ^ (length (xs @ [x]) - 1) = 2 ^ (length xs - 1) + 2 ^ (length xs - 1)", "have \n      \"2 ^ (length (xs @ [x]) - 1) \\<le> \n      Suc (size (queue_to_multiset xs)) + 2 ^ (length xs - 1)\""], ["proof (prove)\nusing this:\n  2 ^ (length xs - 1) \\<le> Suc (size (queue_to_multiset xs))\n  2 ^ (length (xs @ [x]) - 1) = 2 ^ (length xs - 1) + 2 ^ (length xs - 1)\n\ngoal (1 subgoal):\n 1. 2 ^ (length (xs @ [x]) - 1)\n    \\<le> Suc (size (queue_to_multiset xs)) + 2 ^ (length xs - 1)", "by simp"], ["proof (state)\nthis:\n  2 ^ (length (xs @ [x]) - 1)\n  \\<le> Suc (size (queue_to_multiset xs)) + 2 ^ (length xs - 1)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>invar xs \\<Longrightarrow>\n                2 ^ (length xs - 1) - 1 \\<le> size (queue_to_multiset xs);\n        invar (xs @ [x]); xs = a # list\\<rbrakk>\n       \\<Longrightarrow> 2 ^ (length (xs @ [x]) - 1) - 1\n                         \\<le> size (queue_to_multiset (xs @ [x]))", "with snd"], ["proof (chain)\npicking this:\n  2 ^ (length xs - 1) \\<le> 2 ^ rank x\n  2 ^ (length (xs @ [x]) - 1)\n  \\<le> Suc (size (queue_to_multiset xs)) + 2 ^ (length xs - 1)", "have \"2 ^ (length (xs @ [x]) - 1) \\<le> \n      Suc (size (queue_to_multiset xs)) + 2 ^ rank x\""], ["proof (prove)\nusing this:\n  2 ^ (length xs - 1) \\<le> 2 ^ rank x\n  2 ^ (length (xs @ [x]) - 1)\n  \\<le> Suc (size (queue_to_multiset xs)) + 2 ^ (length xs - 1)\n\ngoal (1 subgoal):\n 1. 2 ^ (length (xs @ [x]) - 1)\n    \\<le> Suc (size (queue_to_multiset xs)) + 2 ^ rank x", "by arith"], ["proof (state)\nthis:\n  2 ^ (length (xs @ [x]) - 1)\n  \\<le> Suc (size (queue_to_multiset xs)) + 2 ^ rank x\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>invar xs \\<Longrightarrow>\n                2 ^ (length xs - 1) - 1 \\<le> size (queue_to_multiset xs);\n        invar (xs @ [x]); xs = a # list\\<rbrakk>\n       \\<Longrightarrow> 2 ^ (length (xs @ [x]) - 1) - 1\n                         \\<le> size (queue_to_multiset (xs @ [x]))", "with eq"], ["proof (chain)\npicking this:\n  size (queue_to_multiset xs) + 2 ^ rank x\n  \\<le> size (queue_to_multiset (xs @ [x]))\n  2 ^ (length (xs @ [x]) - 1)\n  \\<le> Suc (size (queue_to_multiset xs)) + 2 ^ rank x", "show ?thesis"], ["proof (prove)\nusing this:\n  size (queue_to_multiset xs) + 2 ^ rank x\n  \\<le> size (queue_to_multiset (xs @ [x]))\n  2 ^ (length (xs @ [x]) - 1)\n  \\<le> Suc (size (queue_to_multiset xs)) + 2 ^ rank x\n\ngoal (1 subgoal):\n 1. 2 ^ (length (xs @ [x]) - 1) - 1\n    \\<le> size (queue_to_multiset (xs @ [x]))", "by simp"], ["proof (state)\nthis:\n  2 ^ (length (xs @ [x]) - 1) - 1 \\<le> size (queue_to_multiset (xs @ [x]))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  2 ^ (length (xs @ [x]) - 1) - 1 \\<le> size (queue_to_multiset (xs @ [x]))\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \"Operations\""], ["", "subsubsection \"Empty Tree\""], ["", "lemma empty_correct: \"q=Nil \\<longleftrightarrow> queue_to_multiset q = {#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (q = []) = (queue_to_multiset q = {#})", "apply (cases q)"], ["proof (prove)\ngoal (2 subgoals):\n 1. q = [] \\<Longrightarrow> (q = []) = (queue_to_multiset q = {#})\n 2. \\<And>a list.\n       q = a # list \\<Longrightarrow> (q = []) = (queue_to_multiset q = {#})", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       q = a # list \\<Longrightarrow> (q = []) = (queue_to_multiset q = {#})", "apply (case_tac a)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a list x1 x2 x3 x4.\n       \\<lbrakk>q = a # list; a = Node x1 x2 x3 x4\\<rbrakk>\n       \\<Longrightarrow> (q = []) = (queue_to_multiset q = {#})", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsubsection \"Insert\""], ["", "text \\<open>Inserts a tree into the queue, such that two trees of same rank get \n  linked and are recursively inserted. This is the same definition as for \n  binomial queues and is used for melding.\\<close>"], ["", "fun ins :: \"('e, 'a::linorder) SkewBinomialTree \\<Rightarrow> ('e, 'a) SkewBinomialQueue \\<Rightarrow> \n  ('e, 'a) SkewBinomialQueue\" where\n  \"ins t [] = [t]\" |\n  \"ins t' (t # bq) =\n    (if (rank t') < (rank t) \n      then t' # t # bq \n      else (if (rank t) < (rank t')\n        then t # (ins t' bq) \n        else ins (link t' t) bq))\""], ["", "text \\<open>Insert an element with priority into a queue using skewlinks.\\<close>"], ["", "fun insert :: \"'e \\<Rightarrow> 'a::linorder \\<Rightarrow> ('e, 'a) SkewBinomialQueue \\<Rightarrow> \n  ('e, 'a) SkewBinomialQueue\" where\n  \"insert e a [] = [Node e a 0 []]\" |\n  \"insert e a [t] = [Node e a 0 [],t]\" |\n  \"insert e a (t # t' # bq) =\n    (if rank t \\<noteq> rank t' \n      then (Node e a 0 []) # t # t' # bq\n      else (skewlink e a t t') # bq)\""], ["", "lemma ins_mset: \n  \"\\<lbrakk>tree_invar t; queue_invar q\\<rbrakk> \\<Longrightarrow>\n   queue_to_multiset (ins t q) = tree_to_multiset t + queue_to_multiset q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>tree_invar t; queue_invar q\\<rbrakk>\n    \\<Longrightarrow> queue_to_multiset (ins t q) =\n                      tree_to_multiset t + queue_to_multiset q", "by (induct q arbitrary: t) (auto simp: union_ac link_tree_invar)"], ["", "lemma insert_mset: \"queue_invar q \\<Longrightarrow> \n  queue_to_multiset (insert e a q) = \n  queue_to_multiset q + {# (e,a) #}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. queue_invar q \\<Longrightarrow>\n    queue_to_multiset (local.insert e a q) =\n    queue_to_multiset q + {#(e, a)#}", "by (induct q rule: insert.induct) (auto simp add: union_ac ttm_children)"], ["", "lemma ins_queue_invar: \"\\<lbrakk>tree_invar t; queue_invar q\\<rbrakk> \\<Longrightarrow> queue_invar (ins t q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>tree_invar t; queue_invar q\\<rbrakk>\n    \\<Longrightarrow> queue_invar (ins t q)", "proof (induct q arbitrary: t)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>t.\n       \\<lbrakk>tree_invar t; queue_invar []\\<rbrakk>\n       \\<Longrightarrow> queue_invar (ins t [])\n 2. \\<And>a q t.\n       \\<lbrakk>\\<And>t.\n                   \\<lbrakk>tree_invar t; queue_invar q\\<rbrakk>\n                   \\<Longrightarrow> queue_invar (ins t q);\n        tree_invar t; queue_invar (a # q)\\<rbrakk>\n       \\<Longrightarrow> queue_invar (ins t (a # q))", "case Nil"], ["proof (state)\nthis:\n  tree_invar t\n  queue_invar []\n\ngoal (2 subgoals):\n 1. \\<And>t.\n       \\<lbrakk>tree_invar t; queue_invar []\\<rbrakk>\n       \\<Longrightarrow> queue_invar (ins t [])\n 2. \\<And>a q t.\n       \\<lbrakk>\\<And>t.\n                   \\<lbrakk>tree_invar t; queue_invar q\\<rbrakk>\n                   \\<Longrightarrow> queue_invar (ins t q);\n        tree_invar t; queue_invar (a # q)\\<rbrakk>\n       \\<Longrightarrow> queue_invar (ins t (a # q))", "then"], ["proof (chain)\npicking this:\n  tree_invar t\n  queue_invar []", "show ?case"], ["proof (prove)\nusing this:\n  tree_invar t\n  queue_invar []\n\ngoal (1 subgoal):\n 1. queue_invar (ins t [])", "by simp"], ["proof (state)\nthis:\n  queue_invar (ins t [])\n\ngoal (1 subgoal):\n 1. \\<And>a q t.\n       \\<lbrakk>\\<And>t.\n                   \\<lbrakk>tree_invar t; queue_invar q\\<rbrakk>\n                   \\<Longrightarrow> queue_invar (ins t q);\n        tree_invar t; queue_invar (a # q)\\<rbrakk>\n       \\<Longrightarrow> queue_invar (ins t (a # q))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a q t.\n       \\<lbrakk>\\<And>t.\n                   \\<lbrakk>tree_invar t; queue_invar q\\<rbrakk>\n                   \\<Longrightarrow> queue_invar (ins t q);\n        tree_invar t; queue_invar (a # q)\\<rbrakk>\n       \\<Longrightarrow> queue_invar (ins t (a # q))", "case (Cons a q)"], ["proof (state)\nthis:\n  \\<lbrakk>tree_invar ?t; queue_invar q\\<rbrakk>\n  \\<Longrightarrow> queue_invar (ins ?t q)\n  tree_invar t\n  queue_invar (a # q)\n\ngoal (1 subgoal):\n 1. \\<And>a q t.\n       \\<lbrakk>\\<And>t.\n                   \\<lbrakk>tree_invar t; queue_invar q\\<rbrakk>\n                   \\<Longrightarrow> queue_invar (ins t q);\n        tree_invar t; queue_invar (a # q)\\<rbrakk>\n       \\<Longrightarrow> queue_invar (ins t (a # q))", "note iv = Cons(1)"], ["proof (state)\nthis:\n  \\<lbrakk>tree_invar ?t; queue_invar q\\<rbrakk>\n  \\<Longrightarrow> queue_invar (ins ?t q)\n\ngoal (1 subgoal):\n 1. \\<And>a q t.\n       \\<lbrakk>\\<And>t.\n                   \\<lbrakk>tree_invar t; queue_invar q\\<rbrakk>\n                   \\<Longrightarrow> queue_invar (ins t q);\n        tree_invar t; queue_invar (a # q)\\<rbrakk>\n       \\<Longrightarrow> queue_invar (ins t (a # q))", "from Cons(2,3)"], ["proof (chain)\npicking this:\n  tree_invar t\n  queue_invar (a # q)", "show ?case"], ["proof (prove)\nusing this:\n  tree_invar t\n  queue_invar (a # q)\n\ngoal (1 subgoal):\n 1. queue_invar (ins t (a # q))", "apply (cases \"rank t < rank a\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>tree_invar t; queue_invar (a # q); rank t < rank a\\<rbrakk>\n    \\<Longrightarrow> queue_invar (ins t (a # q))\n 2. \\<lbrakk>tree_invar t; queue_invar (a # q);\n     \\<not> rank t < rank a\\<rbrakk>\n    \\<Longrightarrow> queue_invar (ins t (a # q))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>tree_invar t; queue_invar (a # q);\n     \\<not> rank t < rank a\\<rbrakk>\n    \\<Longrightarrow> queue_invar (ins t (a # q))", "apply (cases \"rank t = rank a\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>tree_invar t; queue_invar (a # q); \\<not> rank t < rank a;\n     rank t = rank a\\<rbrakk>\n    \\<Longrightarrow> queue_invar (ins t (a # q))\n 2. \\<lbrakk>tree_invar t; queue_invar (a # q); \\<not> rank t < rank a;\n     rank t \\<noteq> rank a\\<rbrakk>\n    \\<Longrightarrow> queue_invar (ins t (a # q))", "defer"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>tree_invar t; queue_invar (a # q); \\<not> rank t < rank a;\n     rank t \\<noteq> rank a\\<rbrakk>\n    \\<Longrightarrow> queue_invar (ins t (a # q))\n 2. \\<lbrakk>tree_invar t; queue_invar (a # q); \\<not> rank t < rank a;\n     rank t = rank a\\<rbrakk>\n    \\<Longrightarrow> queue_invar (ins t (a # q))", "using iv[of \"t\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>tree_invar t; queue_invar q\\<rbrakk>\n  \\<Longrightarrow> queue_invar (ins t q)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>tree_invar t; queue_invar (a # q); \\<not> rank t < rank a;\n     rank t \\<noteq> rank a\\<rbrakk>\n    \\<Longrightarrow> queue_invar (ins t (a # q))\n 2. \\<lbrakk>tree_invar t; queue_invar (a # q); \\<not> rank t < rank a;\n     rank t = rank a\\<rbrakk>\n    \\<Longrightarrow> queue_invar (ins t (a # q))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>tree_invar t; queue_invar (a # q); \\<not> rank t < rank a;\n     rank t = rank a\\<rbrakk>\n    \\<Longrightarrow> queue_invar (ins t (a # q))", "proof goal_cases"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>tree_invar t; queue_invar (a # q); \\<not> rank t < rank a;\n     rank t = rank a\\<rbrakk>\n    \\<Longrightarrow> queue_invar (ins t (a # q))", "case prems: 1"], ["proof (state)\nthis:\n  tree_invar t\n  queue_invar (a # q)\n  \\<not> rank t < rank a\n  rank t = rank a\n\ngoal (1 subgoal):\n 1. \\<lbrakk>tree_invar t; queue_invar (a # q); \\<not> rank t < rank a;\n     rank t = rank a\\<rbrakk>\n    \\<Longrightarrow> queue_invar (ins t (a # q))", "from prems(2)"], ["proof (chain)\npicking this:\n  queue_invar (a # q)", "have inv_a: \"tree_invar a\""], ["proof (prove)\nusing this:\n  queue_invar (a # q)\n\ngoal (1 subgoal):\n 1. tree_invar a", "by simp"], ["proof (state)\nthis:\n  tree_invar a\n\ngoal (1 subgoal):\n 1. \\<lbrakk>tree_invar t; queue_invar (a # q); \\<not> rank t < rank a;\n     rank t = rank a\\<rbrakk>\n    \\<Longrightarrow> queue_invar (ins t (a # q))", "from prems(2)"], ["proof (chain)\npicking this:\n  queue_invar (a # q)", "have inv_q: \"queue_invar q\""], ["proof (prove)\nusing this:\n  queue_invar (a # q)\n\ngoal (1 subgoal):\n 1. queue_invar q", "by simp"], ["proof (state)\nthis:\n  queue_invar q\n\ngoal (1 subgoal):\n 1. \\<lbrakk>tree_invar t; queue_invar (a # q); \\<not> rank t < rank a;\n     rank t = rank a\\<rbrakk>\n    \\<Longrightarrow> queue_invar (ins t (a # q))", "note inv_link = link_tree_invar[OF prems(1) inv_a prems(4)]"], ["proof (state)\nthis:\n  tree_invar (link t a)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>tree_invar t; queue_invar (a # q); \\<not> rank t < rank a;\n     rank t = rank a\\<rbrakk>\n    \\<Longrightarrow> queue_invar (ins t (a # q))", "from iv[OF inv_link inv_q] prems(4)"], ["proof (chain)\npicking this:\n  queue_invar (ins (link t a) q)\n  rank t = rank a", "show ?case"], ["proof (prove)\nusing this:\n  queue_invar (ins (link t a) q)\n  rank t = rank a\n\ngoal (1 subgoal):\n 1. queue_invar (ins t (a # q))", "by simp"], ["proof (state)\nthis:\n  queue_invar (ins t (a # q))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  queue_invar (ins t (a # q))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma insert_queue_invar: \"queue_invar q \\<Longrightarrow> queue_invar (insert e a q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. queue_invar q \\<Longrightarrow> queue_invar (local.insert e a q)", "proof (induct q rule: insert.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>e a.\n       queue_invar [] \\<Longrightarrow> queue_invar (local.insert e a [])\n 2. \\<And>e a t.\n       queue_invar [t] \\<Longrightarrow> queue_invar (local.insert e a [t])\n 3. \\<And>e a t t' bq.\n       queue_invar (t # t' # bq) \\<Longrightarrow>\n       queue_invar (local.insert e a (t # t' # bq))", "case 1"], ["proof (state)\nthis:\n  queue_invar []\n\ngoal (3 subgoals):\n 1. \\<And>e a.\n       queue_invar [] \\<Longrightarrow> queue_invar (local.insert e a [])\n 2. \\<And>e a t.\n       queue_invar [t] \\<Longrightarrow> queue_invar (local.insert e a [t])\n 3. \\<And>e a t t' bq.\n       queue_invar (t # t' # bq) \\<Longrightarrow>\n       queue_invar (local.insert e a (t # t' # bq))", "then"], ["proof (chain)\npicking this:\n  queue_invar []", "show ?case"], ["proof (prove)\nusing this:\n  queue_invar []\n\ngoal (1 subgoal):\n 1. queue_invar (local.insert e_ a_ [])", "by simp"], ["proof (state)\nthis:\n  queue_invar (local.insert e_ a_ [])\n\ngoal (2 subgoals):\n 1. \\<And>e a t.\n       queue_invar [t] \\<Longrightarrow> queue_invar (local.insert e a [t])\n 2. \\<And>e a t t' bq.\n       queue_invar (t # t' # bq) \\<Longrightarrow>\n       queue_invar (local.insert e a (t # t' # bq))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>e a t.\n       queue_invar [t] \\<Longrightarrow> queue_invar (local.insert e a [t])\n 2. \\<And>e a t t' bq.\n       queue_invar (t # t' # bq) \\<Longrightarrow>\n       queue_invar (local.insert e a (t # t' # bq))", "case 2"], ["proof (state)\nthis:\n  queue_invar [t_]\n\ngoal (2 subgoals):\n 1. \\<And>e a t.\n       queue_invar [t] \\<Longrightarrow> queue_invar (local.insert e a [t])\n 2. \\<And>e a t t' bq.\n       queue_invar (t # t' # bq) \\<Longrightarrow>\n       queue_invar (local.insert e a (t # t' # bq))", "then"], ["proof (chain)\npicking this:\n  queue_invar [t_]", "show ?case"], ["proof (prove)\nusing this:\n  queue_invar [t_]\n\ngoal (1 subgoal):\n 1. queue_invar (local.insert e_ a_ [t_])", "by simp"], ["proof (state)\nthis:\n  queue_invar (local.insert e_ a_ [t_])\n\ngoal (1 subgoal):\n 1. \\<And>e a t t' bq.\n       queue_invar (t # t' # bq) \\<Longrightarrow>\n       queue_invar (local.insert e a (t # t' # bq))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>e a t t' bq.\n       queue_invar (t # t' # bq) \\<Longrightarrow>\n       queue_invar (local.insert e a (t # t' # bq))", "case (3 e a t t' bq)"], ["proof (state)\nthis:\n  queue_invar (t # t' # bq)\n\ngoal (1 subgoal):\n 1. \\<And>e a t t' bq.\n       queue_invar (t # t' # bq) \\<Longrightarrow>\n       queue_invar (local.insert e a (t # t' # bq))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. queue_invar (local.insert e a (t # t' # bq))", "proof (cases \"rank t = rank t'\")"], ["proof (state)\ngoal (2 subgoals):\n 1. rank t = rank t' \\<Longrightarrow>\n    queue_invar (local.insert e a (t # t' # bq))\n 2. rank t \\<noteq> rank t' \\<Longrightarrow>\n    queue_invar (local.insert e a (t # t' # bq))", "case False"], ["proof (state)\nthis:\n  rank t \\<noteq> rank t'\n\ngoal (2 subgoals):\n 1. rank t = rank t' \\<Longrightarrow>\n    queue_invar (local.insert e a (t # t' # bq))\n 2. rank t \\<noteq> rank t' \\<Longrightarrow>\n    queue_invar (local.insert e a (t # t' # bq))", "with 3"], ["proof (chain)\npicking this:\n  queue_invar (t # t' # bq)\n  rank t \\<noteq> rank t'", "show ?thesis"], ["proof (prove)\nusing this:\n  queue_invar (t # t' # bq)\n  rank t \\<noteq> rank t'\n\ngoal (1 subgoal):\n 1. queue_invar (local.insert e a (t # t' # bq))", "by simp"], ["proof (state)\nthis:\n  queue_invar (local.insert e a (t # t' # bq))\n\ngoal (1 subgoal):\n 1. rank t = rank t' \\<Longrightarrow>\n    queue_invar (local.insert e a (t # t' # bq))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. rank t = rank t' \\<Longrightarrow>\n    queue_invar (local.insert e a (t # t' # bq))", "case True"], ["proof (state)\nthis:\n  rank t = rank t'\n\ngoal (1 subgoal):\n 1. rank t = rank t' \\<Longrightarrow>\n    queue_invar (local.insert e a (t # t' # bq))", "from 3"], ["proof (chain)\npicking this:\n  queue_invar (t # t' # bq)", "have inv_t: \"tree_invar t\""], ["proof (prove)\nusing this:\n  queue_invar (t # t' # bq)\n\ngoal (1 subgoal):\n 1. tree_invar t", "by simp"], ["proof (state)\nthis:\n  tree_invar t\n\ngoal (1 subgoal):\n 1. rank t = rank t' \\<Longrightarrow>\n    queue_invar (local.insert e a (t # t' # bq))", "from 3"], ["proof (chain)\npicking this:\n  queue_invar (t # t' # bq)", "have inv_t': \"tree_invar t'\""], ["proof (prove)\nusing this:\n  queue_invar (t # t' # bq)\n\ngoal (1 subgoal):\n 1. tree_invar t'", "by simp"], ["proof (state)\nthis:\n  tree_invar t'\n\ngoal (1 subgoal):\n 1. rank t = rank t' \\<Longrightarrow>\n    queue_invar (local.insert e a (t # t' # bq))", "from 3 skewlink_tree_invar[OF inv_t inv_t' True, of e a] True"], ["proof (chain)\npicking this:\n  queue_invar (t # t' # bq)\n  tree_invar (skewlink e a t t')\n  rank t = rank t'", "show ?thesis"], ["proof (prove)\nusing this:\n  queue_invar (t # t' # bq)\n  tree_invar (skewlink e a t t')\n  rank t = rank t'\n\ngoal (1 subgoal):\n 1. queue_invar (local.insert e a (t # t' # bq))", "by simp"], ["proof (state)\nthis:\n  queue_invar (local.insert e a (t # t' # bq))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  queue_invar (local.insert e a (t # t' # bq))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rank_ins2: \n  \"rank_invar bq \\<Longrightarrow> \n    rank t \\<le> rank (hd (ins t bq)) \n    \\<or> (rank (hd (ins t bq)) = rank (hd bq) \\<and> bq \\<noteq> [])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rank_invar bq \\<Longrightarrow>\n    rank t \\<le> rank (hd (ins t bq)) \\<or>\n    rank (hd (ins t bq)) = rank (hd bq) \\<and> bq \\<noteq> []", "apply (induct bq arbitrary: t)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>t.\n       rank_invar [] \\<Longrightarrow>\n       rank t \\<le> rank (hd (ins t [])) \\<or>\n       rank (hd (ins t [])) = rank (hd []) \\<and> [] \\<noteq> []\n 2. \\<And>a bq t.\n       \\<lbrakk>\\<And>t.\n                   rank_invar bq \\<Longrightarrow>\n                   rank t \\<le> rank (hd (ins t bq)) \\<or>\n                   rank (hd (ins t bq)) = rank (hd bq) \\<and>\n                   bq \\<noteq> [];\n        rank_invar (a # bq)\\<rbrakk>\n       \\<Longrightarrow> rank t \\<le> rank (hd (ins t (a # bq))) \\<or>\n                         rank (hd (ins t (a # bq))) =\n                         rank (hd (a # bq)) \\<and>\n                         a # bq \\<noteq> []", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a bq t.\n       \\<lbrakk>\\<And>t.\n                   rank_invar bq \\<Longrightarrow>\n                   rank t \\<le> rank (hd (ins t bq)) \\<or>\n                   rank (hd (ins t bq)) = rank (hd bq) \\<and>\n                   bq \\<noteq> [];\n        rank_invar (a # bq); rank t = rank a;\n        rank (hd (ins (link t a) bq)) \\<noteq> rank a\\<rbrakk>\n       \\<Longrightarrow> rank a \\<le> rank (hd (ins (link t a) bq))", "proof goal_cases"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a bq t.\n       \\<lbrakk>\\<And>t.\n                   rank_invar bq \\<Longrightarrow>\n                   rank t \\<le> rank (hd (ins t bq)) \\<or>\n                   rank (hd (ins t bq)) = rank (hd bq) \\<and>\n                   bq \\<noteq> [];\n        rank_invar (a # bq); rank t = rank a;\n        rank (hd (ins (link t a) bq)) \\<noteq> rank a\\<rbrakk>\n       \\<Longrightarrow> rank a \\<le> rank (hd (ins (link t a) bq))", "case prems: (1 a bq t)"], ["proof (state)\nthis:\n  rank_invar bq \\<Longrightarrow>\n  rank ?t \\<le> rank (hd (ins ?t bq)) \\<or>\n  rank (hd (ins ?t bq)) = rank (hd bq) \\<and> bq \\<noteq> []\n  rank_invar (a # bq)\n  rank t = rank a\n  rank (hd (ins (link t a) bq)) \\<noteq> rank a\n\ngoal (1 subgoal):\n 1. \\<And>a bq t.\n       \\<lbrakk>\\<And>t.\n                   rank_invar bq \\<Longrightarrow>\n                   rank t \\<le> rank (hd (ins t bq)) \\<or>\n                   rank (hd (ins t bq)) = rank (hd bq) \\<and>\n                   bq \\<noteq> [];\n        rank_invar (a # bq); rank t = rank a;\n        rank (hd (ins (link t a) bq)) \\<noteq> rank a\\<rbrakk>\n       \\<Longrightarrow> rank a \\<le> rank (hd (ins (link t a) bq))", "hence r: \"rank (link t a) = rank a + 1\""], ["proof (prove)\nusing this:\n  rank_invar bq \\<Longrightarrow>\n  rank ?t \\<le> rank (hd (ins ?t bq)) \\<or>\n  rank (hd (ins ?t bq)) = rank (hd bq) \\<and> bq \\<noteq> []\n  rank_invar (a # bq)\n  rank t = rank a\n  rank (hd (ins (link t a) bq)) \\<noteq> rank a\n\ngoal (1 subgoal):\n 1. rank (link t a) = rank a + 1", "by (simp add: rank_link)"], ["proof (state)\nthis:\n  rank (link t a) = rank a + 1\n\ngoal (1 subgoal):\n 1. \\<And>a bq t.\n       \\<lbrakk>\\<And>t.\n                   rank_invar bq \\<Longrightarrow>\n                   rank t \\<le> rank (hd (ins t bq)) \\<or>\n                   rank (hd (ins t bq)) = rank (hd bq) \\<and>\n                   bq \\<noteq> [];\n        rank_invar (a # bq); rank t = rank a;\n        rank (hd (ins (link t a) bq)) \\<noteq> rank a\\<rbrakk>\n       \\<Longrightarrow> rank a \\<le> rank (hd (ins (link t a) bq))", "with prems and prems(1)[of \"(link t a)\"]"], ["proof (chain)\npicking this:\n  rank_invar bq \\<Longrightarrow>\n  rank ?t \\<le> rank (hd (ins ?t bq)) \\<or>\n  rank (hd (ins ?t bq)) = rank (hd bq) \\<and> bq \\<noteq> []\n  rank_invar (a # bq)\n  rank t = rank a\n  rank (hd (ins (link t a) bq)) \\<noteq> rank a\n  rank_invar bq \\<Longrightarrow>\n  rank (link t a) \\<le> rank (hd (ins (link t a) bq)) \\<or>\n  rank (hd (ins (link t a) bq)) = rank (hd bq) \\<and> bq \\<noteq> []\n  rank (link t a) = rank a + 1", "show ?case"], ["proof (prove)\nusing this:\n  rank_invar bq \\<Longrightarrow>\n  rank ?t \\<le> rank (hd (ins ?t bq)) \\<or>\n  rank (hd (ins ?t bq)) = rank (hd bq) \\<and> bq \\<noteq> []\n  rank_invar (a # bq)\n  rank t = rank a\n  rank (hd (ins (link t a) bq)) \\<noteq> rank a\n  rank_invar bq \\<Longrightarrow>\n  rank (link t a) \\<le> rank (hd (ins (link t a) bq)) \\<or>\n  rank (hd (ins (link t a) bq)) = rank (hd bq) \\<and> bq \\<noteq> []\n  rank (link t a) = rank a + 1\n\ngoal (1 subgoal):\n 1. rank a \\<le> rank (hd (ins (link t a) bq))", "apply (cases bq)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>t.\n                rank_invar bq \\<Longrightarrow>\n                rank t \\<le> rank (hd (ins t bq)) \\<or>\n                rank (hd (ins t bq)) = rank (hd bq) \\<and> bq \\<noteq> [];\n     rank_invar (a # bq); rank t = rank a;\n     rank (hd (ins (link t a) bq)) \\<noteq> rank a;\n     rank_invar bq \\<Longrightarrow>\n     rank (link t a) \\<le> rank (hd (ins (link t a) bq)) \\<or>\n     rank (hd (ins (link t a) bq)) = rank (hd bq) \\<and> bq \\<noteq> [];\n     rank (link t a) = rank a + 1; bq = []\\<rbrakk>\n    \\<Longrightarrow> rank a \\<le> rank (hd (ins (link t a) bq))\n 2. \\<And>aa list.\n       \\<lbrakk>\\<And>t.\n                   rank_invar bq \\<Longrightarrow>\n                   rank t \\<le> rank (hd (ins t bq)) \\<or>\n                   rank (hd (ins t bq)) = rank (hd bq) \\<and>\n                   bq \\<noteq> [];\n        rank_invar (a # bq); rank t = rank a;\n        rank (hd (ins (link t a) bq)) \\<noteq> rank a;\n        rank_invar bq \\<Longrightarrow>\n        rank (link t a) \\<le> rank (hd (ins (link t a) bq)) \\<or>\n        rank (hd (ins (link t a) bq)) = rank (hd bq) \\<and> bq \\<noteq> [];\n        rank (link t a) = rank a + 1; bq = aa # list\\<rbrakk>\n       \\<Longrightarrow> rank a \\<le> rank (hd (ins (link t a) bq))", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  rank a \\<le> rank (hd (ins (link t a) bq))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma insert_rank_invar: \"rank_skew_invar q \\<Longrightarrow> rank_skew_invar (insert e a q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rank_skew_invar q \\<Longrightarrow> rank_skew_invar (local.insert e a q)", "proof (cases q, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       \\<lbrakk>rank_skew_invar q; q = aa # list\\<rbrakk>\n       \\<Longrightarrow> rank_skew_invar (local.insert e a q)", "fix t q'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       \\<lbrakk>rank_skew_invar q; q = aa # list\\<rbrakk>\n       \\<Longrightarrow> rank_skew_invar (local.insert e a q)", "assume \"rank_skew_invar q\" \"q = t # q'\""], ["proof (state)\nthis:\n  rank_skew_invar q\n  q = t # q'\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       \\<lbrakk>rank_skew_invar q; q = aa # list\\<rbrakk>\n       \\<Longrightarrow> rank_skew_invar (local.insert e a q)", "thus \"rank_skew_invar (insert e a q)\""], ["proof (prove)\nusing this:\n  rank_skew_invar q\n  q = t # q'\n\ngoal (1 subgoal):\n 1. rank_skew_invar (local.insert e a q)", "proof (cases \"q'\", (auto intro: gr0I)[1])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       \\<lbrakk>rank_skew_invar q; q = t # q'; q' = aa # list\\<rbrakk>\n       \\<Longrightarrow> rank_skew_invar (local.insert e a q)", "fix t' q''"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       \\<lbrakk>rank_skew_invar q; q = t # q'; q' = aa # list\\<rbrakk>\n       \\<Longrightarrow> rank_skew_invar (local.insert e a q)", "assume \"rank_skew_invar q\" \"q = t # q'\" \"q' = t' # q''\""], ["proof (state)\nthis:\n  rank_skew_invar q\n  q = t # q'\n  q' = t' # q''\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       \\<lbrakk>rank_skew_invar q; q = t # q'; q' = aa # list\\<rbrakk>\n       \\<Longrightarrow> rank_skew_invar (local.insert e a q)", "thus \"rank_skew_invar (insert e a q)\""], ["proof (prove)\nusing this:\n  rank_skew_invar q\n  q = t # q'\n  q' = t' # q''\n\ngoal (1 subgoal):\n 1. rank_skew_invar (local.insert e a q)", "apply(cases \"rank t = rank t'\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>rank_skew_invar q; q = t # q'; q' = t' # q'';\n     rank t = rank t'\\<rbrakk>\n    \\<Longrightarrow> rank_skew_invar (local.insert e a q)\n 2. \\<lbrakk>rank_skew_invar q; q = t # q'; q' = t' # q'';\n     rank t \\<noteq> rank t'\\<rbrakk>\n    \\<Longrightarrow> rank_skew_invar (local.insert e a q)", "defer"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>rank_skew_invar q; q = t # q'; q' = t' # q'';\n     rank t \\<noteq> rank t'\\<rbrakk>\n    \\<Longrightarrow> rank_skew_invar (local.insert e a q)\n 2. \\<lbrakk>rank_skew_invar q; q = t # q'; q' = t' # q'';\n     rank t = rank t'\\<rbrakk>\n    \\<Longrightarrow> rank_skew_invar (local.insert e a q)", "apply (auto intro: gr0I)[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>rank_skew_invar q; q = t # q'; q' = t' # q'';\n     rank t = rank t'\\<rbrakk>\n    \\<Longrightarrow> rank_skew_invar (local.insert e a q)", "apply (simp del: skewlink.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>rank_invar (t' # q''); q = t # t' # q''; q' = t' # q'';\n     rank t = rank t'\\<rbrakk>\n    \\<Longrightarrow> rank_skew_invar (skewlink e a t t' # q'')", "proof goal_cases"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>rank_invar (t' # q''); q = t # t' # q''; q' = t' # q'';\n     rank t = rank t'\\<rbrakk>\n    \\<Longrightarrow> rank_skew_invar (skewlink e a t t' # q'')", "case prems: 1"], ["proof (state)\nthis:\n  rank_invar (t' # q'')\n  q = t # t' # q''\n  q' = t' # q''\n  rank t = rank t'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>rank_invar (t' # q''); q = t # t' # q''; q' = t' # q'';\n     rank t = rank t'\\<rbrakk>\n    \\<Longrightarrow> rank_skew_invar (skewlink e a t t' # q'')", "with rank_invar_cons_down[of \"t'\" \"q'\"]"], ["proof (chain)\npicking this:\n  rank_invar (t' # q') \\<Longrightarrow> rank_invar q'\n  rank_invar (t' # q'')\n  q = t # t' # q''\n  q' = t' # q''\n  rank t = rank t'", "have \"rank_invar q'\""], ["proof (prove)\nusing this:\n  rank_invar (t' # q') \\<Longrightarrow> rank_invar q'\n  rank_invar (t' # q'')\n  q = t # t' # q''\n  q' = t' # q''\n  rank t = rank t'\n\ngoal (1 subgoal):\n 1. rank_invar q'", "by simp"], ["proof (state)\nthis:\n  rank_invar q'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>rank_invar (t' # q''); q = t # t' # q''; q' = t' # q'';\n     rank t = rank t'\\<rbrakk>\n    \\<Longrightarrow> rank_skew_invar (skewlink e a t t' # q'')", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. rank_skew_invar (skewlink e a t t' # q'')", "proof (cases q'')"], ["proof (state)\ngoal (2 subgoals):\n 1. q'' = [] \\<Longrightarrow> rank_skew_invar (skewlink e a t t' # q'')\n 2. \\<And>aa list.\n       q'' = aa # list \\<Longrightarrow>\n       rank_skew_invar (skewlink e a t t' # q'')", "case Nil"], ["proof (state)\nthis:\n  q'' = []\n\ngoal (2 subgoals):\n 1. q'' = [] \\<Longrightarrow> rank_skew_invar (skewlink e a t t' # q'')\n 2. \\<And>aa list.\n       q'' = aa # list \\<Longrightarrow>\n       rank_skew_invar (skewlink e a t t' # q'')", "then"], ["proof (chain)\npicking this:\n  q'' = []", "show ?thesis"], ["proof (prove)\nusing this:\n  q'' = []\n\ngoal (1 subgoal):\n 1. rank_skew_invar (skewlink e a t t' # q'')", "by simp"], ["proof (state)\nthis:\n  rank_skew_invar (skewlink e a t t' # q'')\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       q'' = aa # list \\<Longrightarrow>\n       rank_skew_invar (skewlink e a t t' # q'')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       q'' = aa # list \\<Longrightarrow>\n       rank_skew_invar (skewlink e a t t' # q'')", "case (Cons t'' q''')"], ["proof (state)\nthis:\n  q'' = t'' # q'''\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       q'' = aa # list \\<Longrightarrow>\n       rank_skew_invar (skewlink e a t t' # q'')", "with prems"], ["proof (chain)\npicking this:\n  rank_invar (t' # q'')\n  q = t # t' # q''\n  q' = t' # q''\n  rank t = rank t'\n  q'' = t'' # q'''", "have \"rank t' < rank t''\""], ["proof (prove)\nusing this:\n  rank_invar (t' # q'')\n  q = t # t' # q''\n  q' = t' # q''\n  rank t = rank t'\n  q'' = t'' # q'''\n\ngoal (1 subgoal):\n 1. rank t' < rank t''", "by simp"], ["proof (state)\nthis:\n  rank t' < rank t''\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       q'' = aa # list \\<Longrightarrow>\n       rank_skew_invar (skewlink e a t t' # q'')", "with prems"], ["proof (chain)\npicking this:\n  rank_invar (t' # q'')\n  q = t # t' # q''\n  q' = t' # q''\n  rank t = rank t'\n  rank t' < rank t''", "have \"rank (skewlink e a t t') \\<le> rank t''\""], ["proof (prove)\nusing this:\n  rank_invar (t' # q'')\n  q = t # t' # q''\n  q' = t' # q''\n  rank t = rank t'\n  rank t' < rank t''\n\ngoal (1 subgoal):\n 1. rank (skewlink e a t t') \\<le> rank t''", "by simp"], ["proof (state)\nthis:\n  rank (skewlink e a t t') \\<le> rank t''\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       q'' = aa # list \\<Longrightarrow>\n       rank_skew_invar (skewlink e a t t' # q'')", "with prems Cons rank_skew_cons_up[of \"t''\" \"q'''\" \"skewlink e a t t'\"]"], ["proof (chain)\npicking this:\n  rank_invar (t' # q'')\n  q = t # t' # q''\n  q' = t' # q''\n  rank t = rank t'\n  q'' = t'' # q'''\n  \\<lbrakk>rank_invar (t'' # q''');\n   rank (skewlink e a t t') \\<le> rank t''\\<rbrakk>\n  \\<Longrightarrow> rank_skew_invar (skewlink e a t t' # t'' # q''')\n  rank (skewlink e a t t') \\<le> rank t''", "show ?thesis"], ["proof (prove)\nusing this:\n  rank_invar (t' # q'')\n  q = t # t' # q''\n  q' = t' # q''\n  rank t = rank t'\n  q'' = t'' # q'''\n  \\<lbrakk>rank_invar (t'' # q''');\n   rank (skewlink e a t t') \\<le> rank t''\\<rbrakk>\n  \\<Longrightarrow> rank_skew_invar (skewlink e a t t' # t'' # q''')\n  rank (skewlink e a t t') \\<le> rank t''\n\ngoal (1 subgoal):\n 1. rank_skew_invar (skewlink e a t t' # q'')", "by simp"], ["proof (state)\nthis:\n  rank_skew_invar (skewlink e a t t' # q'')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  rank_skew_invar (skewlink e a t t' # q'')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  rank_skew_invar (local.insert e a q)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  rank_skew_invar (local.insert e a q)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma insert_invar: \"invar q \\<Longrightarrow> invar (insert e a q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invar q \\<Longrightarrow> invar (local.insert e a q)", "unfolding invar_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. queue_invar q \\<and> rank_skew_invar q \\<Longrightarrow>\n    queue_invar (local.insert e a q) \\<and>\n    rank_skew_invar (local.insert e a q)", "using insert_queue_invar[of q] insert_rank_invar[of q]"], ["proof (prove)\nusing this:\n  queue_invar q \\<Longrightarrow> queue_invar (local.insert ?e ?a q)\n  rank_skew_invar q \\<Longrightarrow> rank_skew_invar (local.insert ?e ?a q)\n\ngoal (1 subgoal):\n 1. queue_invar q \\<and> rank_skew_invar q \\<Longrightarrow>\n    queue_invar (local.insert e a q) \\<and>\n    rank_skew_invar (local.insert e a q)", "by simp"], ["", "theorem insert_correct:\n  assumes I: \"invar q\"\n  shows \n  \"invar (insert e a q)\"\n  \"queue_to_multiset (insert e a q) = queue_to_multiset q + {# (e,a) #}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invar (local.insert e a q) &&&\n    queue_to_multiset (local.insert e a q) =\n    queue_to_multiset q + {#(e, a)#}", "using insert_mset[of q] insert_invar[of q] I"], ["proof (prove)\nusing this:\n  queue_invar q \\<Longrightarrow>\n  queue_to_multiset (local.insert ?e ?a q) =\n  queue_to_multiset q + {#(?e, ?a)#}\n  invar q \\<Longrightarrow> invar (local.insert ?e ?a q)\n  invar q\n\ngoal (1 subgoal):\n 1. invar (local.insert e a q) &&&\n    queue_to_multiset (local.insert e a q) =\n    queue_to_multiset q + {#(e, a)#}", "unfolding invar_def"], ["proof (prove)\nusing this:\n  queue_invar q \\<Longrightarrow>\n  queue_to_multiset (local.insert ?e ?a q) =\n  queue_to_multiset q + {#(?e, ?a)#}\n  queue_invar q \\<and> rank_skew_invar q \\<Longrightarrow>\n  queue_invar (local.insert ?e ?a q) \\<and>\n  rank_skew_invar (local.insert ?e ?a q)\n  queue_invar q \\<and> rank_skew_invar q\n\ngoal (1 subgoal):\n 1. queue_invar (local.insert e a q) \\<and>\n    rank_skew_invar (local.insert e a q) &&&\n    queue_to_multiset (local.insert e a q) =\n    queue_to_multiset q + {#(e, a)#}", "by simp_all"], ["", "subsubsection \"meld\""], ["", "text \\<open>Remove duplicate tree ranks by inserting the first tree of the \n  queue into the rest of the queue.\\<close>"], ["", "fun uniqify \n  :: \"('e, 'a::linorder) SkewBinomialQueue \\<Rightarrow> ('e, 'a) SkewBinomialQueue\" \n  where\n  \"uniqify [] = []\" |\n  \"uniqify (t#bq) = ins t bq\""], ["", "text \\<open>Meld two uniquified queues using the same definition as for \n  binomial queues.\\<close>"], ["", "fun meldUniq \n  :: \"('e, 'a::linorder) SkewBinomialQueue \\<Rightarrow> ('e,'a) SkewBinomialQueue \\<Rightarrow>\n  ('e, 'a) SkewBinomialQueue\" where\n  \"meldUniq [] bq = bq\" |\n  \"meldUniq bq [] = bq\" |\n  \"meldUniq (t1#bq1) (t2#bq2) = (if rank t1 < rank t2 \n       then t1 # (meldUniq bq1 (t2#bq2))\n       else (if rank t2 < rank t1\n              then t2 # (meldUniq (t1#bq1) bq2)\n              else ins (link t1 t2) (meldUniq bq1 bq2)))\""], ["", "text \\<open>Meld two queues using above functions.\\<close>"], ["", "definition meld \n  :: \"('e, 'a::linorder) SkewBinomialQueue \\<Rightarrow> ('e, 'a) SkewBinomialQueue \\<Rightarrow> \n      ('e, 'a) SkewBinomialQueue\" where\n  \"meld bq1 bq2 = meldUniq (uniqify bq1) (uniqify bq2)\""], ["", "lemma invar_uniqify: \"queue_invar q \\<Longrightarrow> queue_invar (uniqify q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. queue_invar q \\<Longrightarrow> queue_invar (uniqify q)", "apply(cases q, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>queue_invar q; q = a # list\\<rbrakk>\n       \\<Longrightarrow> queue_invar (uniqify q)", "apply(auto simp add: ins_queue_invar)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma invar_meldUniq: \"\\<lbrakk>queue_invar q; queue_invar q'\\<rbrakk> \\<Longrightarrow> queue_invar (meldUniq q q')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>queue_invar q; queue_invar q'\\<rbrakk>\n    \\<Longrightarrow> queue_invar (meldUniq q q')", "proof (induct q q' rule: meldUniq.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>bq.\n       \\<lbrakk>queue_invar []; queue_invar bq\\<rbrakk>\n       \\<Longrightarrow> queue_invar (meldUniq [] bq)\n 2. \\<And>v va.\n       \\<lbrakk>queue_invar (v # va); queue_invar []\\<rbrakk>\n       \\<Longrightarrow> queue_invar (meldUniq (v # va) [])\n 3. \\<And>t1 bq1 t2 bq2.\n       \\<lbrakk>\\<lbrakk>rank t1 < rank t2; queue_invar bq1;\n                 queue_invar (t2 # bq2)\\<rbrakk>\n                \\<Longrightarrow> queue_invar (meldUniq bq1 (t2 # bq2));\n        \\<lbrakk>\\<not> rank t1 < rank t2; rank t2 < rank t1;\n         queue_invar (t1 # bq1); queue_invar bq2\\<rbrakk>\n        \\<Longrightarrow> queue_invar (meldUniq (t1 # bq1) bq2);\n        \\<lbrakk>\\<not> rank t1 < rank t2; \\<not> rank t2 < rank t1;\n         queue_invar bq1; queue_invar bq2\\<rbrakk>\n        \\<Longrightarrow> queue_invar (meldUniq bq1 bq2);\n        queue_invar (t1 # bq1); queue_invar (t2 # bq2)\\<rbrakk>\n       \\<Longrightarrow> queue_invar (meldUniq (t1 # bq1) (t2 # bq2))", "case 1"], ["proof (state)\nthis:\n  queue_invar []\n  queue_invar bq_\n\ngoal (3 subgoals):\n 1. \\<And>bq.\n       \\<lbrakk>queue_invar []; queue_invar bq\\<rbrakk>\n       \\<Longrightarrow> queue_invar (meldUniq [] bq)\n 2. \\<And>v va.\n       \\<lbrakk>queue_invar (v # va); queue_invar []\\<rbrakk>\n       \\<Longrightarrow> queue_invar (meldUniq (v # va) [])\n 3. \\<And>t1 bq1 t2 bq2.\n       \\<lbrakk>\\<lbrakk>rank t1 < rank t2; queue_invar bq1;\n                 queue_invar (t2 # bq2)\\<rbrakk>\n                \\<Longrightarrow> queue_invar (meldUniq bq1 (t2 # bq2));\n        \\<lbrakk>\\<not> rank t1 < rank t2; rank t2 < rank t1;\n         queue_invar (t1 # bq1); queue_invar bq2\\<rbrakk>\n        \\<Longrightarrow> queue_invar (meldUniq (t1 # bq1) bq2);\n        \\<lbrakk>\\<not> rank t1 < rank t2; \\<not> rank t2 < rank t1;\n         queue_invar bq1; queue_invar bq2\\<rbrakk>\n        \\<Longrightarrow> queue_invar (meldUniq bq1 bq2);\n        queue_invar (t1 # bq1); queue_invar (t2 # bq2)\\<rbrakk>\n       \\<Longrightarrow> queue_invar (meldUniq (t1 # bq1) (t2 # bq2))", "then"], ["proof (chain)\npicking this:\n  queue_invar []\n  queue_invar bq_", "show ?case"], ["proof (prove)\nusing this:\n  queue_invar []\n  queue_invar bq_\n\ngoal (1 subgoal):\n 1. queue_invar (meldUniq [] bq_)", "by simp"], ["proof (state)\nthis:\n  queue_invar (meldUniq [] bq_)\n\ngoal (2 subgoals):\n 1. \\<And>v va.\n       \\<lbrakk>queue_invar (v # va); queue_invar []\\<rbrakk>\n       \\<Longrightarrow> queue_invar (meldUniq (v # va) [])\n 2. \\<And>t1 bq1 t2 bq2.\n       \\<lbrakk>\\<lbrakk>rank t1 < rank t2; queue_invar bq1;\n                 queue_invar (t2 # bq2)\\<rbrakk>\n                \\<Longrightarrow> queue_invar (meldUniq bq1 (t2 # bq2));\n        \\<lbrakk>\\<not> rank t1 < rank t2; rank t2 < rank t1;\n         queue_invar (t1 # bq1); queue_invar bq2\\<rbrakk>\n        \\<Longrightarrow> queue_invar (meldUniq (t1 # bq1) bq2);\n        \\<lbrakk>\\<not> rank t1 < rank t2; \\<not> rank t2 < rank t1;\n         queue_invar bq1; queue_invar bq2\\<rbrakk>\n        \\<Longrightarrow> queue_invar (meldUniq bq1 bq2);\n        queue_invar (t1 # bq1); queue_invar (t2 # bq2)\\<rbrakk>\n       \\<Longrightarrow> queue_invar (meldUniq (t1 # bq1) (t2 # bq2))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>v va.\n       \\<lbrakk>queue_invar (v # va); queue_invar []\\<rbrakk>\n       \\<Longrightarrow> queue_invar (meldUniq (v # va) [])\n 2. \\<And>t1 bq1 t2 bq2.\n       \\<lbrakk>\\<lbrakk>rank t1 < rank t2; queue_invar bq1;\n                 queue_invar (t2 # bq2)\\<rbrakk>\n                \\<Longrightarrow> queue_invar (meldUniq bq1 (t2 # bq2));\n        \\<lbrakk>\\<not> rank t1 < rank t2; rank t2 < rank t1;\n         queue_invar (t1 # bq1); queue_invar bq2\\<rbrakk>\n        \\<Longrightarrow> queue_invar (meldUniq (t1 # bq1) bq2);\n        \\<lbrakk>\\<not> rank t1 < rank t2; \\<not> rank t2 < rank t1;\n         queue_invar bq1; queue_invar bq2\\<rbrakk>\n        \\<Longrightarrow> queue_invar (meldUniq bq1 bq2);\n        queue_invar (t1 # bq1); queue_invar (t2 # bq2)\\<rbrakk>\n       \\<Longrightarrow> queue_invar (meldUniq (t1 # bq1) (t2 # bq2))", "case 2"], ["proof (state)\nthis:\n  queue_invar (v_ # va_)\n  queue_invar []\n\ngoal (2 subgoals):\n 1. \\<And>v va.\n       \\<lbrakk>queue_invar (v # va); queue_invar []\\<rbrakk>\n       \\<Longrightarrow> queue_invar (meldUniq (v # va) [])\n 2. \\<And>t1 bq1 t2 bq2.\n       \\<lbrakk>\\<lbrakk>rank t1 < rank t2; queue_invar bq1;\n                 queue_invar (t2 # bq2)\\<rbrakk>\n                \\<Longrightarrow> queue_invar (meldUniq bq1 (t2 # bq2));\n        \\<lbrakk>\\<not> rank t1 < rank t2; rank t2 < rank t1;\n         queue_invar (t1 # bq1); queue_invar bq2\\<rbrakk>\n        \\<Longrightarrow> queue_invar (meldUniq (t1 # bq1) bq2);\n        \\<lbrakk>\\<not> rank t1 < rank t2; \\<not> rank t2 < rank t1;\n         queue_invar bq1; queue_invar bq2\\<rbrakk>\n        \\<Longrightarrow> queue_invar (meldUniq bq1 bq2);\n        queue_invar (t1 # bq1); queue_invar (t2 # bq2)\\<rbrakk>\n       \\<Longrightarrow> queue_invar (meldUniq (t1 # bq1) (t2 # bq2))", "then"], ["proof (chain)\npicking this:\n  queue_invar (v_ # va_)\n  queue_invar []", "show ?case"], ["proof (prove)\nusing this:\n  queue_invar (v_ # va_)\n  queue_invar []\n\ngoal (1 subgoal):\n 1. queue_invar (meldUniq (v_ # va_) [])", "by simp"], ["proof (state)\nthis:\n  queue_invar (meldUniq (v_ # va_) [])\n\ngoal (1 subgoal):\n 1. \\<And>t1 bq1 t2 bq2.\n       \\<lbrakk>\\<lbrakk>rank t1 < rank t2; queue_invar bq1;\n                 queue_invar (t2 # bq2)\\<rbrakk>\n                \\<Longrightarrow> queue_invar (meldUniq bq1 (t2 # bq2));\n        \\<lbrakk>\\<not> rank t1 < rank t2; rank t2 < rank t1;\n         queue_invar (t1 # bq1); queue_invar bq2\\<rbrakk>\n        \\<Longrightarrow> queue_invar (meldUniq (t1 # bq1) bq2);\n        \\<lbrakk>\\<not> rank t1 < rank t2; \\<not> rank t2 < rank t1;\n         queue_invar bq1; queue_invar bq2\\<rbrakk>\n        \\<Longrightarrow> queue_invar (meldUniq bq1 bq2);\n        queue_invar (t1 # bq1); queue_invar (t2 # bq2)\\<rbrakk>\n       \\<Longrightarrow> queue_invar (meldUniq (t1 # bq1) (t2 # bq2))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t1 bq1 t2 bq2.\n       \\<lbrakk>\\<lbrakk>rank t1 < rank t2; queue_invar bq1;\n                 queue_invar (t2 # bq2)\\<rbrakk>\n                \\<Longrightarrow> queue_invar (meldUniq bq1 (t2 # bq2));\n        \\<lbrakk>\\<not> rank t1 < rank t2; rank t2 < rank t1;\n         queue_invar (t1 # bq1); queue_invar bq2\\<rbrakk>\n        \\<Longrightarrow> queue_invar (meldUniq (t1 # bq1) bq2);\n        \\<lbrakk>\\<not> rank t1 < rank t2; \\<not> rank t2 < rank t1;\n         queue_invar bq1; queue_invar bq2\\<rbrakk>\n        \\<Longrightarrow> queue_invar (meldUniq bq1 bq2);\n        queue_invar (t1 # bq1); queue_invar (t2 # bq2)\\<rbrakk>\n       \\<Longrightarrow> queue_invar (meldUniq (t1 # bq1) (t2 # bq2))", "case (3 t1 bq1 t2 bq2)"], ["proof (state)\nthis:\n  \\<lbrakk>rank t1 < rank t2; queue_invar bq1;\n   queue_invar (t2 # bq2)\\<rbrakk>\n  \\<Longrightarrow> queue_invar (meldUniq bq1 (t2 # bq2))\n  \\<lbrakk>\\<not> rank t1 < rank t2; rank t2 < rank t1;\n   queue_invar (t1 # bq1); queue_invar bq2\\<rbrakk>\n  \\<Longrightarrow> queue_invar (meldUniq (t1 # bq1) bq2)\n  \\<lbrakk>\\<not> rank t1 < rank t2; \\<not> rank t2 < rank t1;\n   queue_invar bq1; queue_invar bq2\\<rbrakk>\n  \\<Longrightarrow> queue_invar (meldUniq bq1 bq2)\n  queue_invar (t1 # bq1)\n  queue_invar (t2 # bq2)\n\ngoal (1 subgoal):\n 1. \\<And>t1 bq1 t2 bq2.\n       \\<lbrakk>\\<lbrakk>rank t1 < rank t2; queue_invar bq1;\n                 queue_invar (t2 # bq2)\\<rbrakk>\n                \\<Longrightarrow> queue_invar (meldUniq bq1 (t2 # bq2));\n        \\<lbrakk>\\<not> rank t1 < rank t2; rank t2 < rank t1;\n         queue_invar (t1 # bq1); queue_invar bq2\\<rbrakk>\n        \\<Longrightarrow> queue_invar (meldUniq (t1 # bq1) bq2);\n        \\<lbrakk>\\<not> rank t1 < rank t2; \\<not> rank t2 < rank t1;\n         queue_invar bq1; queue_invar bq2\\<rbrakk>\n        \\<Longrightarrow> queue_invar (meldUniq bq1 bq2);\n        queue_invar (t1 # bq1); queue_invar (t2 # bq2)\\<rbrakk>\n       \\<Longrightarrow> queue_invar (meldUniq (t1 # bq1) (t2 # bq2))", "consider (lt) \"rank t1 < rank t2\" | (gt) \"rank t1 > rank t2\" | (eq) \"rank t1 = rank t2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>rank t1 < rank t2 \\<Longrightarrow> thesis;\n     rank t2 < rank t1 \\<Longrightarrow> thesis;\n     rank t1 = rank t2 \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by atomize_elim auto"], ["proof (state)\nthis:\n  \\<lbrakk>rank t1 < rank t2 \\<Longrightarrow> ?thesis;\n   rank t2 < rank t1 \\<Longrightarrow> ?thesis;\n   rank t1 = rank t2 \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. \\<And>t1 bq1 t2 bq2.\n       \\<lbrakk>\\<lbrakk>rank t1 < rank t2; queue_invar bq1;\n                 queue_invar (t2 # bq2)\\<rbrakk>\n                \\<Longrightarrow> queue_invar (meldUniq bq1 (t2 # bq2));\n        \\<lbrakk>\\<not> rank t1 < rank t2; rank t2 < rank t1;\n         queue_invar (t1 # bq1); queue_invar bq2\\<rbrakk>\n        \\<Longrightarrow> queue_invar (meldUniq (t1 # bq1) bq2);\n        \\<lbrakk>\\<not> rank t1 < rank t2; \\<not> rank t2 < rank t1;\n         queue_invar bq1; queue_invar bq2\\<rbrakk>\n        \\<Longrightarrow> queue_invar (meldUniq bq1 bq2);\n        queue_invar (t1 # bq1); queue_invar (t2 # bq2)\\<rbrakk>\n       \\<Longrightarrow> queue_invar (meldUniq (t1 # bq1) (t2 # bq2))", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>rank t1 < rank t2 \\<Longrightarrow> ?thesis;\n   rank t2 < rank t1 \\<Longrightarrow> ?thesis;\n   rank t1 = rank t2 \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>rank t1 < rank t2 \\<Longrightarrow> ?thesis;\n   rank t2 < rank t1 \\<Longrightarrow> ?thesis;\n   rank t1 = rank t2 \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. queue_invar (meldUniq (t1 # bq1) (t2 # bq2))", "proof cases"], ["proof (state)\ngoal (3 subgoals):\n 1. rank t1 < rank t2 \\<Longrightarrow>\n    queue_invar (meldUniq (t1 # bq1) (t2 # bq2))\n 2. rank t2 < rank t1 \\<Longrightarrow>\n    queue_invar (meldUniq (t1 # bq1) (t2 # bq2))\n 3. rank t1 = rank t2 \\<Longrightarrow>\n    queue_invar (meldUniq (t1 # bq1) (t2 # bq2))", "case t1t2: lt"], ["proof (state)\nthis:\n  rank t1 < rank t2\n\ngoal (3 subgoals):\n 1. rank t1 < rank t2 \\<Longrightarrow>\n    queue_invar (meldUniq (t1 # bq1) (t2 # bq2))\n 2. rank t2 < rank t1 \\<Longrightarrow>\n    queue_invar (meldUniq (t1 # bq1) (t2 # bq2))\n 3. rank t1 = rank t2 \\<Longrightarrow>\n    queue_invar (meldUniq (t1 # bq1) (t2 # bq2))", "from 3(4)"], ["proof (chain)\npicking this:\n  queue_invar (t1 # bq1)", "have inv_bq1: \"queue_invar bq1\""], ["proof (prove)\nusing this:\n  queue_invar (t1 # bq1)\n\ngoal (1 subgoal):\n 1. queue_invar bq1", "by simp"], ["proof (state)\nthis:\n  queue_invar bq1\n\ngoal (3 subgoals):\n 1. rank t1 < rank t2 \\<Longrightarrow>\n    queue_invar (meldUniq (t1 # bq1) (t2 # bq2))\n 2. rank t2 < rank t1 \\<Longrightarrow>\n    queue_invar (meldUniq (t1 # bq1) (t2 # bq2))\n 3. rank t1 = rank t2 \\<Longrightarrow>\n    queue_invar (meldUniq (t1 # bq1) (t2 # bq2))", "from 3(4)"], ["proof (chain)\npicking this:\n  queue_invar (t1 # bq1)", "have inv_t1: \"tree_invar t1\""], ["proof (prove)\nusing this:\n  queue_invar (t1 # bq1)\n\ngoal (1 subgoal):\n 1. tree_invar t1", "by simp"], ["proof (state)\nthis:\n  tree_invar t1\n\ngoal (3 subgoals):\n 1. rank t1 < rank t2 \\<Longrightarrow>\n    queue_invar (meldUniq (t1 # bq1) (t2 # bq2))\n 2. rank t2 < rank t1 \\<Longrightarrow>\n    queue_invar (meldUniq (t1 # bq1) (t2 # bq2))\n 3. rank t1 = rank t2 \\<Longrightarrow>\n    queue_invar (meldUniq (t1 # bq1) (t2 # bq2))", "from 3(1)[OF t1t2 inv_bq1 3(5)] inv_t1 t1t2"], ["proof (chain)\npicking this:\n  queue_invar (meldUniq bq1 (t2 # bq2))\n  tree_invar t1\n  rank t1 < rank t2", "show ?thesis"], ["proof (prove)\nusing this:\n  queue_invar (meldUniq bq1 (t2 # bq2))\n  tree_invar t1\n  rank t1 < rank t2\n\ngoal (1 subgoal):\n 1. queue_invar (meldUniq (t1 # bq1) (t2 # bq2))", "by simp"], ["proof (state)\nthis:\n  queue_invar (meldUniq (t1 # bq1) (t2 # bq2))\n\ngoal (2 subgoals):\n 1. rank t2 < rank t1 \\<Longrightarrow>\n    queue_invar (meldUniq (t1 # bq1) (t2 # bq2))\n 2. rank t1 = rank t2 \\<Longrightarrow>\n    queue_invar (meldUniq (t1 # bq1) (t2 # bq2))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. rank t2 < rank t1 \\<Longrightarrow>\n    queue_invar (meldUniq (t1 # bq1) (t2 # bq2))\n 2. rank t1 = rank t2 \\<Longrightarrow>\n    queue_invar (meldUniq (t1 # bq1) (t2 # bq2))", "case t1t2: gt"], ["proof (state)\nthis:\n  rank t2 < rank t1\n\ngoal (2 subgoals):\n 1. rank t2 < rank t1 \\<Longrightarrow>\n    queue_invar (meldUniq (t1 # bq1) (t2 # bq2))\n 2. rank t1 = rank t2 \\<Longrightarrow>\n    queue_invar (meldUniq (t1 # bq1) (t2 # bq2))", "from 3(5)"], ["proof (chain)\npicking this:\n  queue_invar (t2 # bq2)", "have inv_bq2: \"queue_invar bq2\""], ["proof (prove)\nusing this:\n  queue_invar (t2 # bq2)\n\ngoal (1 subgoal):\n 1. queue_invar bq2", "by simp"], ["proof (state)\nthis:\n  queue_invar bq2\n\ngoal (2 subgoals):\n 1. rank t2 < rank t1 \\<Longrightarrow>\n    queue_invar (meldUniq (t1 # bq1) (t2 # bq2))\n 2. rank t1 = rank t2 \\<Longrightarrow>\n    queue_invar (meldUniq (t1 # bq1) (t2 # bq2))", "from 3(5)"], ["proof (chain)\npicking this:\n  queue_invar (t2 # bq2)", "have inv_t2: \"tree_invar t2\""], ["proof (prove)\nusing this:\n  queue_invar (t2 # bq2)\n\ngoal (1 subgoal):\n 1. tree_invar t2", "by simp"], ["proof (state)\nthis:\n  tree_invar t2\n\ngoal (2 subgoals):\n 1. rank t2 < rank t1 \\<Longrightarrow>\n    queue_invar (meldUniq (t1 # bq1) (t2 # bq2))\n 2. rank t1 = rank t2 \\<Longrightarrow>\n    queue_invar (meldUniq (t1 # bq1) (t2 # bq2))", "from t1t2"], ["proof (chain)\npicking this:\n  rank t2 < rank t1", "have \"\\<not> rank t1 < rank t2\""], ["proof (prove)\nusing this:\n  rank t2 < rank t1\n\ngoal (1 subgoal):\n 1. \\<not> rank t1 < rank t2", "by simp"], ["proof (state)\nthis:\n  \\<not> rank t1 < rank t2\n\ngoal (2 subgoals):\n 1. rank t2 < rank t1 \\<Longrightarrow>\n    queue_invar (meldUniq (t1 # bq1) (t2 # bq2))\n 2. rank t1 = rank t2 \\<Longrightarrow>\n    queue_invar (meldUniq (t1 # bq1) (t2 # bq2))", "from 3(2) [OF this t1t2 3(4) inv_bq2] inv_t2 t1t2"], ["proof (chain)\npicking this:\n  queue_invar (meldUniq (t1 # bq1) bq2)\n  tree_invar t2\n  rank t2 < rank t1", "show ?thesis"], ["proof (prove)\nusing this:\n  queue_invar (meldUniq (t1 # bq1) bq2)\n  tree_invar t2\n  rank t2 < rank t1\n\ngoal (1 subgoal):\n 1. queue_invar (meldUniq (t1 # bq1) (t2 # bq2))", "by simp"], ["proof (state)\nthis:\n  queue_invar (meldUniq (t1 # bq1) (t2 # bq2))\n\ngoal (1 subgoal):\n 1. rank t1 = rank t2 \\<Longrightarrow>\n    queue_invar (meldUniq (t1 # bq1) (t2 # bq2))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. rank t1 = rank t2 \\<Longrightarrow>\n    queue_invar (meldUniq (t1 # bq1) (t2 # bq2))", "case t1t2: eq"], ["proof (state)\nthis:\n  rank t1 = rank t2\n\ngoal (1 subgoal):\n 1. rank t1 = rank t2 \\<Longrightarrow>\n    queue_invar (meldUniq (t1 # bq1) (t2 # bq2))", "from 3(4)"], ["proof (chain)\npicking this:\n  queue_invar (t1 # bq1)", "have inv_bq1: \"queue_invar bq1\""], ["proof (prove)\nusing this:\n  queue_invar (t1 # bq1)\n\ngoal (1 subgoal):\n 1. queue_invar bq1", "by simp"], ["proof (state)\nthis:\n  queue_invar bq1\n\ngoal (1 subgoal):\n 1. rank t1 = rank t2 \\<Longrightarrow>\n    queue_invar (meldUniq (t1 # bq1) (t2 # bq2))", "from 3(4)"], ["proof (chain)\npicking this:\n  queue_invar (t1 # bq1)", "have inv_t1: \"tree_invar t1\""], ["proof (prove)\nusing this:\n  queue_invar (t1 # bq1)\n\ngoal (1 subgoal):\n 1. tree_invar t1", "by simp"], ["proof (state)\nthis:\n  tree_invar t1\n\ngoal (1 subgoal):\n 1. rank t1 = rank t2 \\<Longrightarrow>\n    queue_invar (meldUniq (t1 # bq1) (t2 # bq2))", "from 3(5)"], ["proof (chain)\npicking this:\n  queue_invar (t2 # bq2)", "have inv_bq2: \"queue_invar bq2\""], ["proof (prove)\nusing this:\n  queue_invar (t2 # bq2)\n\ngoal (1 subgoal):\n 1. queue_invar bq2", "by simp"], ["proof (state)\nthis:\n  queue_invar bq2\n\ngoal (1 subgoal):\n 1. rank t1 = rank t2 \\<Longrightarrow>\n    queue_invar (meldUniq (t1 # bq1) (t2 # bq2))", "from 3(5)"], ["proof (chain)\npicking this:\n  queue_invar (t2 # bq2)", "have inv_t2: \"tree_invar t2\""], ["proof (prove)\nusing this:\n  queue_invar (t2 # bq2)\n\ngoal (1 subgoal):\n 1. tree_invar t2", "by simp"], ["proof (state)\nthis:\n  tree_invar t2\n\ngoal (1 subgoal):\n 1. rank t1 = rank t2 \\<Longrightarrow>\n    queue_invar (meldUniq (t1 # bq1) (t2 # bq2))", "note inv_link = link_tree_invar[OF inv_t1 inv_t2 t1t2]"], ["proof (state)\nthis:\n  tree_invar (link t1 t2)\n\ngoal (1 subgoal):\n 1. rank t1 = rank t2 \\<Longrightarrow>\n    queue_invar (meldUniq (t1 # bq1) (t2 # bq2))", "from t1t2"], ["proof (chain)\npicking this:\n  rank t1 = rank t2", "have \"\\<not> rank t1 < rank t2\" \"\\<not> rank t2 < rank t1\""], ["proof (prove)\nusing this:\n  rank t1 = rank t2\n\ngoal (1 subgoal):\n 1. \\<not> rank t1 < rank t2 &&& \\<not> rank t2 < rank t1", "by auto"], ["proof (state)\nthis:\n  \\<not> rank t1 < rank t2\n  \\<not> rank t2 < rank t1\n\ngoal (1 subgoal):\n 1. rank t1 = rank t2 \\<Longrightarrow>\n    queue_invar (meldUniq (t1 # bq1) (t2 # bq2))", "note inv_meld = 3(3)[OF this inv_bq1 inv_bq2]"], ["proof (state)\nthis:\n  queue_invar (meldUniq bq1 bq2)\n\ngoal (1 subgoal):\n 1. rank t1 = rank t2 \\<Longrightarrow>\n    queue_invar (meldUniq (t1 # bq1) (t2 # bq2))", "from ins_queue_invar[OF inv_link inv_meld] t1t2"], ["proof (chain)\npicking this:\n  queue_invar (ins (link t1 t2) (meldUniq bq1 bq2))\n  rank t1 = rank t2", "show ?thesis"], ["proof (prove)\nusing this:\n  queue_invar (ins (link t1 t2) (meldUniq bq1 bq2))\n  rank t1 = rank t2\n\ngoal (1 subgoal):\n 1. queue_invar (meldUniq (t1 # bq1) (t2 # bq2))", "by simp"], ["proof (state)\nthis:\n  queue_invar (meldUniq (t1 # bq1) (t2 # bq2))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  queue_invar (meldUniq (t1 # bq1) (t2 # bq2))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma meld_queue_invar:\n  assumes \"queue_invar q\"\n    and \"queue_invar q'\"\n  shows \"queue_invar (meld q q')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. queue_invar (meld q q')", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. queue_invar (meld q q')", "note inv_uniq_q = invar_uniqify[OF assms(1)]"], ["proof (state)\nthis:\n  queue_invar (uniqify q)\n\ngoal (1 subgoal):\n 1. queue_invar (meld q q')", "note inv_uniq_q' = invar_uniqify[OF assms(2)]"], ["proof (state)\nthis:\n  queue_invar (uniqify q')\n\ngoal (1 subgoal):\n 1. queue_invar (meld q q')", "note inv_meldUniq = invar_meldUniq[OF inv_uniq_q inv_uniq_q']"], ["proof (state)\nthis:\n  queue_invar (meldUniq (uniqify q) (uniqify q'))\n\ngoal (1 subgoal):\n 1. queue_invar (meld q q')", "thus ?thesis"], ["proof (prove)\nusing this:\n  queue_invar (meldUniq (uniqify q) (uniqify q'))\n\ngoal (1 subgoal):\n 1. queue_invar (meld q q')", "by (simp add: meld_def)"], ["proof (state)\nthis:\n  queue_invar (meld q q')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma uniqify_mset: \"queue_invar q \\<Longrightarrow> queue_to_multiset q = queue_to_multiset (uniqify q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. queue_invar q \\<Longrightarrow>\n    queue_to_multiset q = queue_to_multiset (uniqify q)", "apply (cases q)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>queue_invar q; q = []\\<rbrakk>\n    \\<Longrightarrow> queue_to_multiset q = queue_to_multiset (uniqify q)\n 2. \\<And>a list.\n       \\<lbrakk>queue_invar q; q = a # list\\<rbrakk>\n       \\<Longrightarrow> queue_to_multiset q = queue_to_multiset (uniqify q)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>queue_invar q; q = a # list\\<rbrakk>\n       \\<Longrightarrow> queue_to_multiset q = queue_to_multiset (uniqify q)", "apply (simp add: ins_mset)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma meldUniq_mset: \"\\<lbrakk>queue_invar q; queue_invar q'\\<rbrakk> \\<Longrightarrow> \n  queue_to_multiset (meldUniq q q') = \n  queue_to_multiset q + queue_to_multiset q'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>queue_invar q; queue_invar q'\\<rbrakk>\n    \\<Longrightarrow> queue_to_multiset (meldUniq q q') =\n                      queue_to_multiset q + queue_to_multiset q'", "by(induct q q' rule: meldUniq.induct)\n  (auto simp: ins_mset link_tree_invar invar_meldUniq union_ac)"], ["", "lemma meld_mset:\n  \"\\<lbrakk> queue_invar q; queue_invar q' \\<rbrakk> \\<Longrightarrow>\n  queue_to_multiset (meld q q') = queue_to_multiset q + queue_to_multiset q'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>queue_invar q; queue_invar q'\\<rbrakk>\n    \\<Longrightarrow> queue_to_multiset (meld q q') =\n                      queue_to_multiset q + queue_to_multiset q'", "by (simp add: meld_def meldUniq_mset invar_uniqify uniqify_mset[symmetric])"], ["", "text \\<open>Ins operation satisfies rank invariant, see binomial queues\\<close>"], ["", "lemma rank_ins: \"rank_invar bq \\<Longrightarrow> rank_invar (ins t bq)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rank_invar bq \\<Longrightarrow> rank_invar (ins t bq)", "proof (induct bq arbitrary: t)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>t. rank_invar [] \\<Longrightarrow> rank_invar (ins t [])\n 2. \\<And>a bq t.\n       \\<lbrakk>\\<And>t.\n                   rank_invar bq \\<Longrightarrow> rank_invar (ins t bq);\n        rank_invar (a # bq)\\<rbrakk>\n       \\<Longrightarrow> rank_invar (ins t (a # bq))", "case Nil"], ["proof (state)\nthis:\n  rank_invar []\n\ngoal (2 subgoals):\n 1. \\<And>t. rank_invar [] \\<Longrightarrow> rank_invar (ins t [])\n 2. \\<And>a bq t.\n       \\<lbrakk>\\<And>t.\n                   rank_invar bq \\<Longrightarrow> rank_invar (ins t bq);\n        rank_invar (a # bq)\\<rbrakk>\n       \\<Longrightarrow> rank_invar (ins t (a # bq))", "then"], ["proof (chain)\npicking this:\n  rank_invar []", "show ?case"], ["proof (prove)\nusing this:\n  rank_invar []\n\ngoal (1 subgoal):\n 1. rank_invar (ins t [])", "by simp"], ["proof (state)\nthis:\n  rank_invar (ins t [])\n\ngoal (1 subgoal):\n 1. \\<And>a bq t.\n       \\<lbrakk>\\<And>t.\n                   rank_invar bq \\<Longrightarrow> rank_invar (ins t bq);\n        rank_invar (a # bq)\\<rbrakk>\n       \\<Longrightarrow> rank_invar (ins t (a # bq))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a bq t.\n       \\<lbrakk>\\<And>t.\n                   rank_invar bq \\<Longrightarrow> rank_invar (ins t bq);\n        rank_invar (a # bq)\\<rbrakk>\n       \\<Longrightarrow> rank_invar (ins t (a # bq))", "case (Cons a bq)"], ["proof (state)\nthis:\n  rank_invar bq \\<Longrightarrow> rank_invar (ins ?t bq)\n  rank_invar (a # bq)\n\ngoal (1 subgoal):\n 1. \\<And>a bq t.\n       \\<lbrakk>\\<And>t.\n                   rank_invar bq \\<Longrightarrow> rank_invar (ins t bq);\n        rank_invar (a # bq)\\<rbrakk>\n       \\<Longrightarrow> rank_invar (ins t (a # bq))", "then"], ["proof (chain)\npicking this:\n  rank_invar bq \\<Longrightarrow> rank_invar (ins ?t bq)\n  rank_invar (a # bq)", "show ?case"], ["proof (prove)\nusing this:\n  rank_invar bq \\<Longrightarrow> rank_invar (ins ?t bq)\n  rank_invar (a # bq)\n\ngoal (1 subgoal):\n 1. rank_invar (ins t (a # bq))", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>t. rank_invar bq \\<Longrightarrow> rank_invar (ins t bq);\n     rank_invar (a # bq); rank a < rank t\\<rbrakk>\n    \\<Longrightarrow> rank_invar (a # ins t bq)\n 2. \\<lbrakk>\\<And>t. rank_invar bq \\<Longrightarrow> rank_invar (ins t bq);\n     rank_invar (a # bq); rank t = rank a\\<rbrakk>\n    \\<Longrightarrow> rank_invar (ins (link t a) bq)", "proof goal_cases"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>t. rank_invar bq \\<Longrightarrow> rank_invar (ins t bq);\n     rank_invar (a # bq); rank a < rank t\\<rbrakk>\n    \\<Longrightarrow> rank_invar (a # ins t bq)\n 2. \\<lbrakk>\\<And>t. rank_invar bq \\<Longrightarrow> rank_invar (ins t bq);\n     rank_invar (a # bq); rank t = rank a\\<rbrakk>\n    \\<Longrightarrow> rank_invar (ins (link t a) bq)", "case prems: 1"], ["proof (state)\nthis:\n  rank_invar bq \\<Longrightarrow> rank_invar (ins ?t bq)\n  rank_invar (a # bq)\n  rank a < rank t\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>t. rank_invar bq \\<Longrightarrow> rank_invar (ins t bq);\n     rank_invar (a # bq); rank a < rank t\\<rbrakk>\n    \\<Longrightarrow> rank_invar (a # ins t bq)\n 2. \\<lbrakk>\\<And>t. rank_invar bq \\<Longrightarrow> rank_invar (ins t bq);\n     rank_invar (a # bq); rank t = rank a\\<rbrakk>\n    \\<Longrightarrow> rank_invar (ins (link t a) bq)", "hence inv: \"rank_invar (ins t bq)\""], ["proof (prove)\nusing this:\n  rank_invar bq \\<Longrightarrow> rank_invar (ins ?t bq)\n  rank_invar (a # bq)\n  rank a < rank t\n\ngoal (1 subgoal):\n 1. rank_invar (ins t bq)", "by (cases bq) simp_all"], ["proof (state)\nthis:\n  rank_invar (ins t bq)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>t. rank_invar bq \\<Longrightarrow> rank_invar (ins t bq);\n     rank_invar (a # bq); rank a < rank t\\<rbrakk>\n    \\<Longrightarrow> rank_invar (a # ins t bq)\n 2. \\<lbrakk>\\<And>t. rank_invar bq \\<Longrightarrow> rank_invar (ins t bq);\n     rank_invar (a # bq); rank t = rank a\\<rbrakk>\n    \\<Longrightarrow> rank_invar (ins (link t a) bq)", "from prems"], ["proof (chain)\npicking this:\n  rank_invar bq \\<Longrightarrow> rank_invar (ins ?t bq)\n  rank_invar (a # bq)\n  rank a < rank t", "have hd: \"bq \\<noteq> [] \\<Longrightarrow> rank a < rank (hd bq)\""], ["proof (prove)\nusing this:\n  rank_invar bq \\<Longrightarrow> rank_invar (ins ?t bq)\n  rank_invar (a # bq)\n  rank a < rank t\n\ngoal (1 subgoal):\n 1. bq \\<noteq> [] \\<Longrightarrow> rank a < rank (hd bq)", "by (cases bq) auto"], ["proof (state)\nthis:\n  bq \\<noteq> [] \\<Longrightarrow> rank a < rank (hd bq)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>t. rank_invar bq \\<Longrightarrow> rank_invar (ins t bq);\n     rank_invar (a # bq); rank a < rank t\\<rbrakk>\n    \\<Longrightarrow> rank_invar (a # ins t bq)\n 2. \\<lbrakk>\\<And>t. rank_invar bq \\<Longrightarrow> rank_invar (ins t bq);\n     rank_invar (a # bq); rank t = rank a\\<rbrakk>\n    \\<Longrightarrow> rank_invar (ins (link t a) bq)", "from prems"], ["proof (chain)\npicking this:\n  rank_invar bq \\<Longrightarrow> rank_invar (ins ?t bq)\n  rank_invar (a # bq)\n  rank a < rank t", "have \"rank t \\<le> rank (hd (ins t bq)) \n                     \\<or> (rank (hd (ins t bq)) = rank (hd bq) \\<and> bq \\<noteq> [])\""], ["proof (prove)\nusing this:\n  rank_invar bq \\<Longrightarrow> rank_invar (ins ?t bq)\n  rank_invar (a # bq)\n  rank a < rank t\n\ngoal (1 subgoal):\n 1. rank t \\<le> rank (hd (ins t bq)) \\<or>\n    rank (hd (ins t bq)) = rank (hd bq) \\<and> bq \\<noteq> []", "by (metis rank_ins2 rank_invar_cons_down)"], ["proof (state)\nthis:\n  rank t \\<le> rank (hd (ins t bq)) \\<or>\n  rank (hd (ins t bq)) = rank (hd bq) \\<and> bq \\<noteq> []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>t. rank_invar bq \\<Longrightarrow> rank_invar (ins t bq);\n     rank_invar (a # bq); rank a < rank t\\<rbrakk>\n    \\<Longrightarrow> rank_invar (a # ins t bq)\n 2. \\<lbrakk>\\<And>t. rank_invar bq \\<Longrightarrow> rank_invar (ins t bq);\n     rank_invar (a # bq); rank t = rank a\\<rbrakk>\n    \\<Longrightarrow> rank_invar (ins (link t a) bq)", "with prems"], ["proof (chain)\npicking this:\n  rank_invar bq \\<Longrightarrow> rank_invar (ins ?t bq)\n  rank_invar (a # bq)\n  rank a < rank t\n  rank t \\<le> rank (hd (ins t bq)) \\<or>\n  rank (hd (ins t bq)) = rank (hd bq) \\<and> bq \\<noteq> []", "have \"rank a < rank (hd (ins t bq)) \n      \\<or> (rank (hd (ins t bq)) = rank (hd bq) \\<and> bq \\<noteq> [])\""], ["proof (prove)\nusing this:\n  rank_invar bq \\<Longrightarrow> rank_invar (ins ?t bq)\n  rank_invar (a # bq)\n  rank a < rank t\n  rank t \\<le> rank (hd (ins t bq)) \\<or>\n  rank (hd (ins t bq)) = rank (hd bq) \\<and> bq \\<noteq> []\n\ngoal (1 subgoal):\n 1. rank a < rank (hd (ins t bq)) \\<or>\n    rank (hd (ins t bq)) = rank (hd bq) \\<and> bq \\<noteq> []", "by auto"], ["proof (state)\nthis:\n  rank a < rank (hd (ins t bq)) \\<or>\n  rank (hd (ins t bq)) = rank (hd bq) \\<and> bq \\<noteq> []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>t. rank_invar bq \\<Longrightarrow> rank_invar (ins t bq);\n     rank_invar (a # bq); rank a < rank t\\<rbrakk>\n    \\<Longrightarrow> rank_invar (a # ins t bq)\n 2. \\<lbrakk>\\<And>t. rank_invar bq \\<Longrightarrow> rank_invar (ins t bq);\n     rank_invar (a # bq); rank t = rank a\\<rbrakk>\n    \\<Longrightarrow> rank_invar (ins (link t a) bq)", "with prems and inv and hd"], ["proof (chain)\npicking this:\n  rank_invar bq \\<Longrightarrow> rank_invar (ins ?t bq)\n  rank_invar (a # bq)\n  rank a < rank t\n  rank_invar (ins t bq)\n  bq \\<noteq> [] \\<Longrightarrow> rank a < rank (hd bq)\n  rank a < rank (hd (ins t bq)) \\<or>\n  rank (hd (ins t bq)) = rank (hd bq) \\<and> bq \\<noteq> []", "show ?case"], ["proof (prove)\nusing this:\n  rank_invar bq \\<Longrightarrow> rank_invar (ins ?t bq)\n  rank_invar (a # bq)\n  rank a < rank t\n  rank_invar (ins t bq)\n  bq \\<noteq> [] \\<Longrightarrow> rank a < rank (hd bq)\n  rank a < rank (hd (ins t bq)) \\<or>\n  rank (hd (ins t bq)) = rank (hd bq) \\<and> bq \\<noteq> []\n\ngoal (1 subgoal):\n 1. rank_invar (a # ins t bq)", "by (auto simp add: rank_invar_hd_cons)"], ["proof (state)\nthis:\n  rank_invar (a # ins t bq)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>t. rank_invar bq \\<Longrightarrow> rank_invar (ins t bq);\n     rank_invar (a # bq); rank t = rank a\\<rbrakk>\n    \\<Longrightarrow> rank_invar (ins (link t a) bq)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>t. rank_invar bq \\<Longrightarrow> rank_invar (ins t bq);\n     rank_invar (a # bq); rank t = rank a\\<rbrakk>\n    \\<Longrightarrow> rank_invar (ins (link t a) bq)", "case prems: 2"], ["proof (state)\nthis:\n  rank_invar bq \\<Longrightarrow> rank_invar (ins ?t bq)\n  rank_invar (a # bq)\n  rank t = rank a\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>t. rank_invar bq \\<Longrightarrow> rank_invar (ins t bq);\n     rank_invar (a # bq); rank t = rank a\\<rbrakk>\n    \\<Longrightarrow> rank_invar (ins (link t a) bq)", "hence inv: \"rank_invar bq\""], ["proof (prove)\nusing this:\n  rank_invar bq \\<Longrightarrow> rank_invar (ins ?t bq)\n  rank_invar (a # bq)\n  rank t = rank a\n\ngoal (1 subgoal):\n 1. rank_invar bq", "by (cases bq) simp_all"], ["proof (state)\nthis:\n  rank_invar bq\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>t. rank_invar bq \\<Longrightarrow> rank_invar (ins t bq);\n     rank_invar (a # bq); rank t = rank a\\<rbrakk>\n    \\<Longrightarrow> rank_invar (ins (link t a) bq)", "with prems and prems(1)[of \"(link t a)\"]"], ["proof (chain)\npicking this:\n  rank_invar bq \\<Longrightarrow> rank_invar (ins ?t bq)\n  rank_invar (a # bq)\n  rank t = rank a\n  rank_invar bq \\<Longrightarrow> rank_invar (ins (link t a) bq)\n  rank_invar bq", "show ?case"], ["proof (prove)\nusing this:\n  rank_invar bq \\<Longrightarrow> rank_invar (ins ?t bq)\n  rank_invar (a # bq)\n  rank t = rank a\n  rank_invar bq \\<Longrightarrow> rank_invar (ins (link t a) bq)\n  rank_invar bq\n\ngoal (1 subgoal):\n 1. rank_invar (ins (link t a) bq)", "by simp"], ["proof (state)\nthis:\n  rank_invar (ins (link t a) bq)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  rank_invar (ins t (a # bq))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rank_uniqify:\n  assumes \"rank_skew_invar q\"\n  shows \"rank_invar (uniqify q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rank_invar (uniqify q)", "proof (cases q)"], ["proof (state)\ngoal (2 subgoals):\n 1. q = [] \\<Longrightarrow> rank_invar (uniqify q)\n 2. \\<And>a list. q = a # list \\<Longrightarrow> rank_invar (uniqify q)", "case Nil"], ["proof (state)\nthis:\n  q = []\n\ngoal (2 subgoals):\n 1. q = [] \\<Longrightarrow> rank_invar (uniqify q)\n 2. \\<And>a list. q = a # list \\<Longrightarrow> rank_invar (uniqify q)", "then"], ["proof (chain)\npicking this:\n  q = []", "show ?thesis"], ["proof (prove)\nusing this:\n  q = []\n\ngoal (1 subgoal):\n 1. rank_invar (uniqify q)", "by simp"], ["proof (state)\nthis:\n  rank_invar (uniqify q)\n\ngoal (1 subgoal):\n 1. \\<And>a list. q = a # list \\<Longrightarrow> rank_invar (uniqify q)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list. q = a # list \\<Longrightarrow> rank_invar (uniqify q)", "case (Cons a list)"], ["proof (state)\nthis:\n  q = a # list\n\ngoal (1 subgoal):\n 1. \\<And>a list. q = a # list \\<Longrightarrow> rank_invar (uniqify q)", "with rank_skew_rank_invar[of \"a\" \"list\"] rank_ins[of \"list\" \"a\"] assms"], ["proof (chain)\npicking this:\n  rank_skew_invar (a # list) \\<Longrightarrow> rank_invar list\n  rank_invar list \\<Longrightarrow> rank_invar (ins a list)\n  rank_skew_invar q\n  q = a # list", "show ?thesis"], ["proof (prove)\nusing this:\n  rank_skew_invar (a # list) \\<Longrightarrow> rank_invar list\n  rank_invar list \\<Longrightarrow> rank_invar (ins a list)\n  rank_skew_invar q\n  q = a # list\n\ngoal (1 subgoal):\n 1. rank_invar (uniqify q)", "by simp"], ["proof (state)\nthis:\n  rank_invar (uniqify q)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rank_ins_min: \"rank_invar bq \\<Longrightarrow> rank (hd (ins t bq)) \\<ge> min (rank t) (rank (hd bq))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rank_invar bq \\<Longrightarrow>\n    min (rank t) (rank (hd bq)) \\<le> rank (hd (ins t bq))", "proof (induct bq arbitrary: t)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>t.\n       rank_invar [] \\<Longrightarrow>\n       min (rank t) (rank (hd [])) \\<le> rank (hd (ins t []))\n 2. \\<And>a bq t.\n       \\<lbrakk>\\<And>t.\n                   rank_invar bq \\<Longrightarrow>\n                   min (rank t) (rank (hd bq)) \\<le> rank (hd (ins t bq));\n        rank_invar (a # bq)\\<rbrakk>\n       \\<Longrightarrow> min (rank t) (rank (hd (a # bq)))\n                         \\<le> rank (hd (ins t (a # bq)))", "case Nil"], ["proof (state)\nthis:\n  rank_invar []\n\ngoal (2 subgoals):\n 1. \\<And>t.\n       rank_invar [] \\<Longrightarrow>\n       min (rank t) (rank (hd [])) \\<le> rank (hd (ins t []))\n 2. \\<And>a bq t.\n       \\<lbrakk>\\<And>t.\n                   rank_invar bq \\<Longrightarrow>\n                   min (rank t) (rank (hd bq)) \\<le> rank (hd (ins t bq));\n        rank_invar (a # bq)\\<rbrakk>\n       \\<Longrightarrow> min (rank t) (rank (hd (a # bq)))\n                         \\<le> rank (hd (ins t (a # bq)))", "then"], ["proof (chain)\npicking this:\n  rank_invar []", "show ?case"], ["proof (prove)\nusing this:\n  rank_invar []\n\ngoal (1 subgoal):\n 1. min (rank t) (rank (hd [])) \\<le> rank (hd (ins t []))", "by simp"], ["proof (state)\nthis:\n  min (rank t) (rank (hd [])) \\<le> rank (hd (ins t []))\n\ngoal (1 subgoal):\n 1. \\<And>a bq t.\n       \\<lbrakk>\\<And>t.\n                   rank_invar bq \\<Longrightarrow>\n                   min (rank t) (rank (hd bq)) \\<le> rank (hd (ins t bq));\n        rank_invar (a # bq)\\<rbrakk>\n       \\<Longrightarrow> min (rank t) (rank (hd (a # bq)))\n                         \\<le> rank (hd (ins t (a # bq)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a bq t.\n       \\<lbrakk>\\<And>t.\n                   rank_invar bq \\<Longrightarrow>\n                   min (rank t) (rank (hd bq)) \\<le> rank (hd (ins t bq));\n        rank_invar (a # bq)\\<rbrakk>\n       \\<Longrightarrow> min (rank t) (rank (hd (a # bq)))\n                         \\<le> rank (hd (ins t (a # bq)))", "case (Cons a bq)"], ["proof (state)\nthis:\n  rank_invar bq \\<Longrightarrow>\n  min (rank ?t) (rank (hd bq)) \\<le> rank (hd (ins ?t bq))\n  rank_invar (a # bq)\n\ngoal (1 subgoal):\n 1. \\<And>a bq t.\n       \\<lbrakk>\\<And>t.\n                   rank_invar bq \\<Longrightarrow>\n                   min (rank t) (rank (hd bq)) \\<le> rank (hd (ins t bq));\n        rank_invar (a # bq)\\<rbrakk>\n       \\<Longrightarrow> min (rank t) (rank (hd (a # bq)))\n                         \\<le> rank (hd (ins t (a # bq)))", "then"], ["proof (chain)\npicking this:\n  rank_invar bq \\<Longrightarrow>\n  min (rank ?t) (rank (hd bq)) \\<le> rank (hd (ins ?t bq))\n  rank_invar (a # bq)", "show ?case"], ["proof (prove)\nusing this:\n  rank_invar bq \\<Longrightarrow>\n  min (rank ?t) (rank (hd bq)) \\<le> rank (hd (ins ?t bq))\n  rank_invar (a # bq)\n\ngoal (1 subgoal):\n 1. min (rank t) (rank (hd (a # bq))) \\<le> rank (hd (ins t (a # bq)))", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>t.\n                rank_invar bq \\<Longrightarrow>\n                min (rank t) (rank (hd bq)) \\<le> rank (hd (ins t bq));\n     rank_invar (a # bq); rank t = rank a\\<rbrakk>\n    \\<Longrightarrow> rank a \\<le> rank (hd (ins (link t a) bq))", "proof goal_cases"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>t.\n                rank_invar bq \\<Longrightarrow>\n                min (rank t) (rank (hd bq)) \\<le> rank (hd (ins t bq));\n     rank_invar (a # bq); rank t = rank a\\<rbrakk>\n    \\<Longrightarrow> rank a \\<le> rank (hd (ins (link t a) bq))", "case prems: 1"], ["proof (state)\nthis:\n  rank_invar bq \\<Longrightarrow>\n  min (rank ?t) (rank (hd bq)) \\<le> rank (hd (ins ?t bq))\n  rank_invar (a # bq)\n  rank t = rank a\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>t.\n                rank_invar bq \\<Longrightarrow>\n                min (rank t) (rank (hd bq)) \\<le> rank (hd (ins t bq));\n     rank_invar (a # bq); rank t = rank a\\<rbrakk>\n    \\<Longrightarrow> rank a \\<le> rank (hd (ins (link t a) bq))", "hence inv: \"rank_invar bq\""], ["proof (prove)\nusing this:\n  rank_invar bq \\<Longrightarrow>\n  min (rank ?t) (rank (hd bq)) \\<le> rank (hd (ins ?t bq))\n  rank_invar (a # bq)\n  rank t = rank a\n\ngoal (1 subgoal):\n 1. rank_invar bq", "by (cases bq) simp_all"], ["proof (state)\nthis:\n  rank_invar bq\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>t.\n                rank_invar bq \\<Longrightarrow>\n                min (rank t) (rank (hd bq)) \\<le> rank (hd (ins t bq));\n     rank_invar (a # bq); rank t = rank a\\<rbrakk>\n    \\<Longrightarrow> rank a \\<le> rank (hd (ins (link t a) bq))", "from prems"], ["proof (chain)\npicking this:\n  rank_invar bq \\<Longrightarrow>\n  min (rank ?t) (rank (hd bq)) \\<le> rank (hd (ins ?t bq))\n  rank_invar (a # bq)\n  rank t = rank a", "have r: \"rank (link t a) = rank a + 1\""], ["proof (prove)\nusing this:\n  rank_invar bq \\<Longrightarrow>\n  min (rank ?t) (rank (hd bq)) \\<le> rank (hd (ins ?t bq))\n  rank_invar (a # bq)\n  rank t = rank a\n\ngoal (1 subgoal):\n 1. rank (link t a) = rank a + 1", "by (simp add: rank_link)"], ["proof (state)\nthis:\n  rank (link t a) = rank a + 1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>t.\n                rank_invar bq \\<Longrightarrow>\n                min (rank t) (rank (hd bq)) \\<le> rank (hd (ins t bq));\n     rank_invar (a # bq); rank t = rank a\\<rbrakk>\n    \\<Longrightarrow> rank a \\<le> rank (hd (ins (link t a) bq))", "with prems and inv and prems(1)[of \"(link t a)\"]"], ["proof (chain)\npicking this:\n  rank_invar bq \\<Longrightarrow>\n  min (rank ?t) (rank (hd bq)) \\<le> rank (hd (ins ?t bq))\n  rank_invar (a # bq)\n  rank t = rank a\n  rank_invar bq\n  rank_invar bq \\<Longrightarrow>\n  min (rank (link t a)) (rank (hd bq)) \\<le> rank (hd (ins (link t a) bq))\n  rank (link t a) = rank a + 1", "show ?case"], ["proof (prove)\nusing this:\n  rank_invar bq \\<Longrightarrow>\n  min (rank ?t) (rank (hd bq)) \\<le> rank (hd (ins ?t bq))\n  rank_invar (a # bq)\n  rank t = rank a\n  rank_invar bq\n  rank_invar bq \\<Longrightarrow>\n  min (rank (link t a)) (rank (hd bq)) \\<le> rank (hd (ins (link t a) bq))\n  rank (link t a) = rank a + 1\n\ngoal (1 subgoal):\n 1. rank a \\<le> rank (hd (ins (link t a) bq))", "by (cases bq) auto"], ["proof (state)\nthis:\n  rank a \\<le> rank (hd (ins (link t a) bq))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  min (rank t) (rank (hd (a # bq))) \\<le> rank (hd (ins t (a # bq)))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rank_invar_not_empty_hd: \"\\<lbrakk>rank_invar (t # bq); bq \\<noteq> []\\<rbrakk> \\<Longrightarrow> rank t < rank (hd bq)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>rank_invar (t # bq); bq \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> rank t < rank (hd bq)", "by (induct bq arbitrary: t) auto"], ["", "lemma rank_invar_meldUniq_strong: \n  \"\\<lbrakk>rank_invar bq1; rank_invar bq2\\<rbrakk> \\<Longrightarrow> \n    rank_invar (meldUniq bq1 bq2) \n    \\<and> rank (hd (meldUniq bq1 bq2)) \\<ge> min (rank (hd bq1)) (rank (hd bq2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>rank_invar bq1; rank_invar bq2\\<rbrakk>\n    \\<Longrightarrow> rank_invar (meldUniq bq1 bq2) \\<and>\n                      min (rank (hd bq1)) (rank (hd bq2))\n                      \\<le> rank (hd (meldUniq bq1 bq2))", "proof (induct bq1 bq2 rule: meldUniq.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>bq.\n       \\<lbrakk>rank_invar []; rank_invar bq\\<rbrakk>\n       \\<Longrightarrow> rank_invar (meldUniq [] bq) \\<and>\n                         min (rank (hd [])) (rank (hd bq))\n                         \\<le> rank (hd (meldUniq [] bq))\n 2. \\<And>v va.\n       \\<lbrakk>rank_invar (v # va); rank_invar []\\<rbrakk>\n       \\<Longrightarrow> rank_invar (meldUniq (v # va) []) \\<and>\n                         min (rank (hd (v # va))) (rank (hd []))\n                         \\<le> rank (hd (meldUniq (v # va) []))\n 3. \\<And>t1 bq1 t2 bq2.\n       \\<lbrakk>\\<lbrakk>rank t1 < rank t2; rank_invar bq1;\n                 rank_invar (t2 # bq2)\\<rbrakk>\n                \\<Longrightarrow> rank_invar\n                                   (meldUniq bq1 (t2 # bq2)) \\<and>\n                                  min (rank (hd bq1)) (rank (hd (t2 # bq2)))\n                                  \\<le> rank (hd (meldUniq bq1 (t2 # bq2)));\n        \\<lbrakk>\\<not> rank t1 < rank t2; rank t2 < rank t1;\n         rank_invar (t1 # bq1); rank_invar bq2\\<rbrakk>\n        \\<Longrightarrow> rank_invar (meldUniq (t1 # bq1) bq2) \\<and>\n                          min (rank (hd (t1 # bq1))) (rank (hd bq2))\n                          \\<le> rank (hd (meldUniq (t1 # bq1) bq2));\n        \\<lbrakk>\\<not> rank t1 < rank t2; \\<not> rank t2 < rank t1;\n         rank_invar bq1; rank_invar bq2\\<rbrakk>\n        \\<Longrightarrow> rank_invar (meldUniq bq1 bq2) \\<and>\n                          min (rank (hd bq1)) (rank (hd bq2))\n                          \\<le> rank (hd (meldUniq bq1 bq2));\n        rank_invar (t1 # bq1); rank_invar (t2 # bq2)\\<rbrakk>\n       \\<Longrightarrow> rank_invar (meldUniq (t1 # bq1) (t2 # bq2)) \\<and>\n                         min (rank (hd (t1 # bq1))) (rank (hd (t2 # bq2)))\n                         \\<le> rank (hd (meldUniq (t1 # bq1) (t2 # bq2)))", "case 1"], ["proof (state)\nthis:\n  rank_invar []\n  rank_invar bq_\n\ngoal (3 subgoals):\n 1. \\<And>bq.\n       \\<lbrakk>rank_invar []; rank_invar bq\\<rbrakk>\n       \\<Longrightarrow> rank_invar (meldUniq [] bq) \\<and>\n                         min (rank (hd [])) (rank (hd bq))\n                         \\<le> rank (hd (meldUniq [] bq))\n 2. \\<And>v va.\n       \\<lbrakk>rank_invar (v # va); rank_invar []\\<rbrakk>\n       \\<Longrightarrow> rank_invar (meldUniq (v # va) []) \\<and>\n                         min (rank (hd (v # va))) (rank (hd []))\n                         \\<le> rank (hd (meldUniq (v # va) []))\n 3. \\<And>t1 bq1 t2 bq2.\n       \\<lbrakk>\\<lbrakk>rank t1 < rank t2; rank_invar bq1;\n                 rank_invar (t2 # bq2)\\<rbrakk>\n                \\<Longrightarrow> rank_invar\n                                   (meldUniq bq1 (t2 # bq2)) \\<and>\n                                  min (rank (hd bq1)) (rank (hd (t2 # bq2)))\n                                  \\<le> rank (hd (meldUniq bq1 (t2 # bq2)));\n        \\<lbrakk>\\<not> rank t1 < rank t2; rank t2 < rank t1;\n         rank_invar (t1 # bq1); rank_invar bq2\\<rbrakk>\n        \\<Longrightarrow> rank_invar (meldUniq (t1 # bq1) bq2) \\<and>\n                          min (rank (hd (t1 # bq1))) (rank (hd bq2))\n                          \\<le> rank (hd (meldUniq (t1 # bq1) bq2));\n        \\<lbrakk>\\<not> rank t1 < rank t2; \\<not> rank t2 < rank t1;\n         rank_invar bq1; rank_invar bq2\\<rbrakk>\n        \\<Longrightarrow> rank_invar (meldUniq bq1 bq2) \\<and>\n                          min (rank (hd bq1)) (rank (hd bq2))\n                          \\<le> rank (hd (meldUniq bq1 bq2));\n        rank_invar (t1 # bq1); rank_invar (t2 # bq2)\\<rbrakk>\n       \\<Longrightarrow> rank_invar (meldUniq (t1 # bq1) (t2 # bq2)) \\<and>\n                         min (rank (hd (t1 # bq1))) (rank (hd (t2 # bq2)))\n                         \\<le> rank (hd (meldUniq (t1 # bq1) (t2 # bq2)))", "then"], ["proof (chain)\npicking this:\n  rank_invar []\n  rank_invar bq_", "show ?case"], ["proof (prove)\nusing this:\n  rank_invar []\n  rank_invar bq_\n\ngoal (1 subgoal):\n 1. rank_invar (meldUniq [] bq_) \\<and>\n    min (rank (hd [])) (rank (hd bq_)) \\<le> rank (hd (meldUniq [] bq_))", "by simp"], ["proof (state)\nthis:\n  rank_invar (meldUniq [] bq_) \\<and>\n  min (rank (hd [])) (rank (hd bq_)) \\<le> rank (hd (meldUniq [] bq_))\n\ngoal (2 subgoals):\n 1. \\<And>v va.\n       \\<lbrakk>rank_invar (v # va); rank_invar []\\<rbrakk>\n       \\<Longrightarrow> rank_invar (meldUniq (v # va) []) \\<and>\n                         min (rank (hd (v # va))) (rank (hd []))\n                         \\<le> rank (hd (meldUniq (v # va) []))\n 2. \\<And>t1 bq1 t2 bq2.\n       \\<lbrakk>\\<lbrakk>rank t1 < rank t2; rank_invar bq1;\n                 rank_invar (t2 # bq2)\\<rbrakk>\n                \\<Longrightarrow> rank_invar\n                                   (meldUniq bq1 (t2 # bq2)) \\<and>\n                                  min (rank (hd bq1)) (rank (hd (t2 # bq2)))\n                                  \\<le> rank (hd (meldUniq bq1 (t2 # bq2)));\n        \\<lbrakk>\\<not> rank t1 < rank t2; rank t2 < rank t1;\n         rank_invar (t1 # bq1); rank_invar bq2\\<rbrakk>\n        \\<Longrightarrow> rank_invar (meldUniq (t1 # bq1) bq2) \\<and>\n                          min (rank (hd (t1 # bq1))) (rank (hd bq2))\n                          \\<le> rank (hd (meldUniq (t1 # bq1) bq2));\n        \\<lbrakk>\\<not> rank t1 < rank t2; \\<not> rank t2 < rank t1;\n         rank_invar bq1; rank_invar bq2\\<rbrakk>\n        \\<Longrightarrow> rank_invar (meldUniq bq1 bq2) \\<and>\n                          min (rank (hd bq1)) (rank (hd bq2))\n                          \\<le> rank (hd (meldUniq bq1 bq2));\n        rank_invar (t1 # bq1); rank_invar (t2 # bq2)\\<rbrakk>\n       \\<Longrightarrow> rank_invar (meldUniq (t1 # bq1) (t2 # bq2)) \\<and>\n                         min (rank (hd (t1 # bq1))) (rank (hd (t2 # bq2)))\n                         \\<le> rank (hd (meldUniq (t1 # bq1) (t2 # bq2)))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>v va.\n       \\<lbrakk>rank_invar (v # va); rank_invar []\\<rbrakk>\n       \\<Longrightarrow> rank_invar (meldUniq (v # va) []) \\<and>\n                         min (rank (hd (v # va))) (rank (hd []))\n                         \\<le> rank (hd (meldUniq (v # va) []))\n 2. \\<And>t1 bq1 t2 bq2.\n       \\<lbrakk>\\<lbrakk>rank t1 < rank t2; rank_invar bq1;\n                 rank_invar (t2 # bq2)\\<rbrakk>\n                \\<Longrightarrow> rank_invar\n                                   (meldUniq bq1 (t2 # bq2)) \\<and>\n                                  min (rank (hd bq1)) (rank (hd (t2 # bq2)))\n                                  \\<le> rank (hd (meldUniq bq1 (t2 # bq2)));\n        \\<lbrakk>\\<not> rank t1 < rank t2; rank t2 < rank t1;\n         rank_invar (t1 # bq1); rank_invar bq2\\<rbrakk>\n        \\<Longrightarrow> rank_invar (meldUniq (t1 # bq1) bq2) \\<and>\n                          min (rank (hd (t1 # bq1))) (rank (hd bq2))\n                          \\<le> rank (hd (meldUniq (t1 # bq1) bq2));\n        \\<lbrakk>\\<not> rank t1 < rank t2; \\<not> rank t2 < rank t1;\n         rank_invar bq1; rank_invar bq2\\<rbrakk>\n        \\<Longrightarrow> rank_invar (meldUniq bq1 bq2) \\<and>\n                          min (rank (hd bq1)) (rank (hd bq2))\n                          \\<le> rank (hd (meldUniq bq1 bq2));\n        rank_invar (t1 # bq1); rank_invar (t2 # bq2)\\<rbrakk>\n       \\<Longrightarrow> rank_invar (meldUniq (t1 # bq1) (t2 # bq2)) \\<and>\n                         min (rank (hd (t1 # bq1))) (rank (hd (t2 # bq2)))\n                         \\<le> rank (hd (meldUniq (t1 # bq1) (t2 # bq2)))", "case 2"], ["proof (state)\nthis:\n  rank_invar (v_ # va_)\n  rank_invar []\n\ngoal (2 subgoals):\n 1. \\<And>v va.\n       \\<lbrakk>rank_invar (v # va); rank_invar []\\<rbrakk>\n       \\<Longrightarrow> rank_invar (meldUniq (v # va) []) \\<and>\n                         min (rank (hd (v # va))) (rank (hd []))\n                         \\<le> rank (hd (meldUniq (v # va) []))\n 2. \\<And>t1 bq1 t2 bq2.\n       \\<lbrakk>\\<lbrakk>rank t1 < rank t2; rank_invar bq1;\n                 rank_invar (t2 # bq2)\\<rbrakk>\n                \\<Longrightarrow> rank_invar\n                                   (meldUniq bq1 (t2 # bq2)) \\<and>\n                                  min (rank (hd bq1)) (rank (hd (t2 # bq2)))\n                                  \\<le> rank (hd (meldUniq bq1 (t2 # bq2)));\n        \\<lbrakk>\\<not> rank t1 < rank t2; rank t2 < rank t1;\n         rank_invar (t1 # bq1); rank_invar bq2\\<rbrakk>\n        \\<Longrightarrow> rank_invar (meldUniq (t1 # bq1) bq2) \\<and>\n                          min (rank (hd (t1 # bq1))) (rank (hd bq2))\n                          \\<le> rank (hd (meldUniq (t1 # bq1) bq2));\n        \\<lbrakk>\\<not> rank t1 < rank t2; \\<not> rank t2 < rank t1;\n         rank_invar bq1; rank_invar bq2\\<rbrakk>\n        \\<Longrightarrow> rank_invar (meldUniq bq1 bq2) \\<and>\n                          min (rank (hd bq1)) (rank (hd bq2))\n                          \\<le> rank (hd (meldUniq bq1 bq2));\n        rank_invar (t1 # bq1); rank_invar (t2 # bq2)\\<rbrakk>\n       \\<Longrightarrow> rank_invar (meldUniq (t1 # bq1) (t2 # bq2)) \\<and>\n                         min (rank (hd (t1 # bq1))) (rank (hd (t2 # bq2)))\n                         \\<le> rank (hd (meldUniq (t1 # bq1) (t2 # bq2)))", "then"], ["proof (chain)\npicking this:\n  rank_invar (v_ # va_)\n  rank_invar []", "show ?case"], ["proof (prove)\nusing this:\n  rank_invar (v_ # va_)\n  rank_invar []\n\ngoal (1 subgoal):\n 1. rank_invar (meldUniq (v_ # va_) []) \\<and>\n    min (rank (hd (v_ # va_))) (rank (hd []))\n    \\<le> rank (hd (meldUniq (v_ # va_) []))", "by simp"], ["proof (state)\nthis:\n  rank_invar (meldUniq (v_ # va_) []) \\<and>\n  min (rank (hd (v_ # va_))) (rank (hd []))\n  \\<le> rank (hd (meldUniq (v_ # va_) []))\n\ngoal (1 subgoal):\n 1. \\<And>t1 bq1 t2 bq2.\n       \\<lbrakk>\\<lbrakk>rank t1 < rank t2; rank_invar bq1;\n                 rank_invar (t2 # bq2)\\<rbrakk>\n                \\<Longrightarrow> rank_invar\n                                   (meldUniq bq1 (t2 # bq2)) \\<and>\n                                  min (rank (hd bq1)) (rank (hd (t2 # bq2)))\n                                  \\<le> rank (hd (meldUniq bq1 (t2 # bq2)));\n        \\<lbrakk>\\<not> rank t1 < rank t2; rank t2 < rank t1;\n         rank_invar (t1 # bq1); rank_invar bq2\\<rbrakk>\n        \\<Longrightarrow> rank_invar (meldUniq (t1 # bq1) bq2) \\<and>\n                          min (rank (hd (t1 # bq1))) (rank (hd bq2))\n                          \\<le> rank (hd (meldUniq (t1 # bq1) bq2));\n        \\<lbrakk>\\<not> rank t1 < rank t2; \\<not> rank t2 < rank t1;\n         rank_invar bq1; rank_invar bq2\\<rbrakk>\n        \\<Longrightarrow> rank_invar (meldUniq bq1 bq2) \\<and>\n                          min (rank (hd bq1)) (rank (hd bq2))\n                          \\<le> rank (hd (meldUniq bq1 bq2));\n        rank_invar (t1 # bq1); rank_invar (t2 # bq2)\\<rbrakk>\n       \\<Longrightarrow> rank_invar (meldUniq (t1 # bq1) (t2 # bq2)) \\<and>\n                         min (rank (hd (t1 # bq1))) (rank (hd (t2 # bq2)))\n                         \\<le> rank (hd (meldUniq (t1 # bq1) (t2 # bq2)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t1 bq1 t2 bq2.\n       \\<lbrakk>\\<lbrakk>rank t1 < rank t2; rank_invar bq1;\n                 rank_invar (t2 # bq2)\\<rbrakk>\n                \\<Longrightarrow> rank_invar\n                                   (meldUniq bq1 (t2 # bq2)) \\<and>\n                                  min (rank (hd bq1)) (rank (hd (t2 # bq2)))\n                                  \\<le> rank (hd (meldUniq bq1 (t2 # bq2)));\n        \\<lbrakk>\\<not> rank t1 < rank t2; rank t2 < rank t1;\n         rank_invar (t1 # bq1); rank_invar bq2\\<rbrakk>\n        \\<Longrightarrow> rank_invar (meldUniq (t1 # bq1) bq2) \\<and>\n                          min (rank (hd (t1 # bq1))) (rank (hd bq2))\n                          \\<le> rank (hd (meldUniq (t1 # bq1) bq2));\n        \\<lbrakk>\\<not> rank t1 < rank t2; \\<not> rank t2 < rank t1;\n         rank_invar bq1; rank_invar bq2\\<rbrakk>\n        \\<Longrightarrow> rank_invar (meldUniq bq1 bq2) \\<and>\n                          min (rank (hd bq1)) (rank (hd bq2))\n                          \\<le> rank (hd (meldUniq bq1 bq2));\n        rank_invar (t1 # bq1); rank_invar (t2 # bq2)\\<rbrakk>\n       \\<Longrightarrow> rank_invar (meldUniq (t1 # bq1) (t2 # bq2)) \\<and>\n                         min (rank (hd (t1 # bq1))) (rank (hd (t2 # bq2)))\n                         \\<le> rank (hd (meldUniq (t1 # bq1) (t2 # bq2)))", "case (3 t1 bq1 t2 bq2)"], ["proof (state)\nthis:\n  \\<lbrakk>rank t1 < rank t2; rank_invar bq1; rank_invar (t2 # bq2)\\<rbrakk>\n  \\<Longrightarrow> rank_invar (meldUniq bq1 (t2 # bq2)) \\<and>\n                    min (rank (hd bq1)) (rank (hd (t2 # bq2)))\n                    \\<le> rank (hd (meldUniq bq1 (t2 # bq2)))\n  \\<lbrakk>\\<not> rank t1 < rank t2; rank t2 < rank t1;\n   rank_invar (t1 # bq1); rank_invar bq2\\<rbrakk>\n  \\<Longrightarrow> rank_invar (meldUniq (t1 # bq1) bq2) \\<and>\n                    min (rank (hd (t1 # bq1))) (rank (hd bq2))\n                    \\<le> rank (hd (meldUniq (t1 # bq1) bq2))\n  \\<lbrakk>\\<not> rank t1 < rank t2; \\<not> rank t2 < rank t1;\n   rank_invar bq1; rank_invar bq2\\<rbrakk>\n  \\<Longrightarrow> rank_invar (meldUniq bq1 bq2) \\<and>\n                    min (rank (hd bq1)) (rank (hd bq2))\n                    \\<le> rank (hd (meldUniq bq1 bq2))\n  rank_invar (t1 # bq1)\n  rank_invar (t2 # bq2)\n\ngoal (1 subgoal):\n 1. \\<And>t1 bq1 t2 bq2.\n       \\<lbrakk>\\<lbrakk>rank t1 < rank t2; rank_invar bq1;\n                 rank_invar (t2 # bq2)\\<rbrakk>\n                \\<Longrightarrow> rank_invar\n                                   (meldUniq bq1 (t2 # bq2)) \\<and>\n                                  min (rank (hd bq1)) (rank (hd (t2 # bq2)))\n                                  \\<le> rank (hd (meldUniq bq1 (t2 # bq2)));\n        \\<lbrakk>\\<not> rank t1 < rank t2; rank t2 < rank t1;\n         rank_invar (t1 # bq1); rank_invar bq2\\<rbrakk>\n        \\<Longrightarrow> rank_invar (meldUniq (t1 # bq1) bq2) \\<and>\n                          min (rank (hd (t1 # bq1))) (rank (hd bq2))\n                          \\<le> rank (hd (meldUniq (t1 # bq1) bq2));\n        \\<lbrakk>\\<not> rank t1 < rank t2; \\<not> rank t2 < rank t1;\n         rank_invar bq1; rank_invar bq2\\<rbrakk>\n        \\<Longrightarrow> rank_invar (meldUniq bq1 bq2) \\<and>\n                          min (rank (hd bq1)) (rank (hd bq2))\n                          \\<le> rank (hd (meldUniq bq1 bq2));\n        rank_invar (t1 # bq1); rank_invar (t2 # bq2)\\<rbrakk>\n       \\<Longrightarrow> rank_invar (meldUniq (t1 # bq1) (t2 # bq2)) \\<and>\n                         min (rank (hd (t1 # bq1))) (rank (hd (t2 # bq2)))\n                         \\<le> rank (hd (meldUniq (t1 # bq1) (t2 # bq2)))", "from 3"], ["proof (chain)\npicking this:\n  \\<lbrakk>rank t1 < rank t2; rank_invar bq1; rank_invar (t2 # bq2)\\<rbrakk>\n  \\<Longrightarrow> rank_invar (meldUniq bq1 (t2 # bq2)) \\<and>\n                    min (rank (hd bq1)) (rank (hd (t2 # bq2)))\n                    \\<le> rank (hd (meldUniq bq1 (t2 # bq2)))\n  \\<lbrakk>\\<not> rank t1 < rank t2; rank t2 < rank t1;\n   rank_invar (t1 # bq1); rank_invar bq2\\<rbrakk>\n  \\<Longrightarrow> rank_invar (meldUniq (t1 # bq1) bq2) \\<and>\n                    min (rank (hd (t1 # bq1))) (rank (hd bq2))\n                    \\<le> rank (hd (meldUniq (t1 # bq1) bq2))\n  \\<lbrakk>\\<not> rank t1 < rank t2; \\<not> rank t2 < rank t1;\n   rank_invar bq1; rank_invar bq2\\<rbrakk>\n  \\<Longrightarrow> rank_invar (meldUniq bq1 bq2) \\<and>\n                    min (rank (hd bq1)) (rank (hd bq2))\n                    \\<le> rank (hd (meldUniq bq1 bq2))\n  rank_invar (t1 # bq1)\n  rank_invar (t2 # bq2)", "have inv1: \"rank_invar bq1\""], ["proof (prove)\nusing this:\n  \\<lbrakk>rank t1 < rank t2; rank_invar bq1; rank_invar (t2 # bq2)\\<rbrakk>\n  \\<Longrightarrow> rank_invar (meldUniq bq1 (t2 # bq2)) \\<and>\n                    min (rank (hd bq1)) (rank (hd (t2 # bq2)))\n                    \\<le> rank (hd (meldUniq bq1 (t2 # bq2)))\n  \\<lbrakk>\\<not> rank t1 < rank t2; rank t2 < rank t1;\n   rank_invar (t1 # bq1); rank_invar bq2\\<rbrakk>\n  \\<Longrightarrow> rank_invar (meldUniq (t1 # bq1) bq2) \\<and>\n                    min (rank (hd (t1 # bq1))) (rank (hd bq2))\n                    \\<le> rank (hd (meldUniq (t1 # bq1) bq2))\n  \\<lbrakk>\\<not> rank t1 < rank t2; \\<not> rank t2 < rank t1;\n   rank_invar bq1; rank_invar bq2\\<rbrakk>\n  \\<Longrightarrow> rank_invar (meldUniq bq1 bq2) \\<and>\n                    min (rank (hd bq1)) (rank (hd bq2))\n                    \\<le> rank (hd (meldUniq bq1 bq2))\n  rank_invar (t1 # bq1)\n  rank_invar (t2 # bq2)\n\ngoal (1 subgoal):\n 1. rank_invar bq1", "by (cases bq1) simp_all"], ["proof (state)\nthis:\n  rank_invar bq1\n\ngoal (1 subgoal):\n 1. \\<And>t1 bq1 t2 bq2.\n       \\<lbrakk>\\<lbrakk>rank t1 < rank t2; rank_invar bq1;\n                 rank_invar (t2 # bq2)\\<rbrakk>\n                \\<Longrightarrow> rank_invar\n                                   (meldUniq bq1 (t2 # bq2)) \\<and>\n                                  min (rank (hd bq1)) (rank (hd (t2 # bq2)))\n                                  \\<le> rank (hd (meldUniq bq1 (t2 # bq2)));\n        \\<lbrakk>\\<not> rank t1 < rank t2; rank t2 < rank t1;\n         rank_invar (t1 # bq1); rank_invar bq2\\<rbrakk>\n        \\<Longrightarrow> rank_invar (meldUniq (t1 # bq1) bq2) \\<and>\n                          min (rank (hd (t1 # bq1))) (rank (hd bq2))\n                          \\<le> rank (hd (meldUniq (t1 # bq1) bq2));\n        \\<lbrakk>\\<not> rank t1 < rank t2; \\<not> rank t2 < rank t1;\n         rank_invar bq1; rank_invar bq2\\<rbrakk>\n        \\<Longrightarrow> rank_invar (meldUniq bq1 bq2) \\<and>\n                          min (rank (hd bq1)) (rank (hd bq2))\n                          \\<le> rank (hd (meldUniq bq1 bq2));\n        rank_invar (t1 # bq1); rank_invar (t2 # bq2)\\<rbrakk>\n       \\<Longrightarrow> rank_invar (meldUniq (t1 # bq1) (t2 # bq2)) \\<and>\n                         min (rank (hd (t1 # bq1))) (rank (hd (t2 # bq2)))\n                         \\<le> rank (hd (meldUniq (t1 # bq1) (t2 # bq2)))", "from 3"], ["proof (chain)\npicking this:\n  \\<lbrakk>rank t1 < rank t2; rank_invar bq1; rank_invar (t2 # bq2)\\<rbrakk>\n  \\<Longrightarrow> rank_invar (meldUniq bq1 (t2 # bq2)) \\<and>\n                    min (rank (hd bq1)) (rank (hd (t2 # bq2)))\n                    \\<le> rank (hd (meldUniq bq1 (t2 # bq2)))\n  \\<lbrakk>\\<not> rank t1 < rank t2; rank t2 < rank t1;\n   rank_invar (t1 # bq1); rank_invar bq2\\<rbrakk>\n  \\<Longrightarrow> rank_invar (meldUniq (t1 # bq1) bq2) \\<and>\n                    min (rank (hd (t1 # bq1))) (rank (hd bq2))\n                    \\<le> rank (hd (meldUniq (t1 # bq1) bq2))\n  \\<lbrakk>\\<not> rank t1 < rank t2; \\<not> rank t2 < rank t1;\n   rank_invar bq1; rank_invar bq2\\<rbrakk>\n  \\<Longrightarrow> rank_invar (meldUniq bq1 bq2) \\<and>\n                    min (rank (hd bq1)) (rank (hd bq2))\n                    \\<le> rank (hd (meldUniq bq1 bq2))\n  rank_invar (t1 # bq1)\n  rank_invar (t2 # bq2)", "have inv2: \"rank_invar bq2\""], ["proof (prove)\nusing this:\n  \\<lbrakk>rank t1 < rank t2; rank_invar bq1; rank_invar (t2 # bq2)\\<rbrakk>\n  \\<Longrightarrow> rank_invar (meldUniq bq1 (t2 # bq2)) \\<and>\n                    min (rank (hd bq1)) (rank (hd (t2 # bq2)))\n                    \\<le> rank (hd (meldUniq bq1 (t2 # bq2)))\n  \\<lbrakk>\\<not> rank t1 < rank t2; rank t2 < rank t1;\n   rank_invar (t1 # bq1); rank_invar bq2\\<rbrakk>\n  \\<Longrightarrow> rank_invar (meldUniq (t1 # bq1) bq2) \\<and>\n                    min (rank (hd (t1 # bq1))) (rank (hd bq2))\n                    \\<le> rank (hd (meldUniq (t1 # bq1) bq2))\n  \\<lbrakk>\\<not> rank t1 < rank t2; \\<not> rank t2 < rank t1;\n   rank_invar bq1; rank_invar bq2\\<rbrakk>\n  \\<Longrightarrow> rank_invar (meldUniq bq1 bq2) \\<and>\n                    min (rank (hd bq1)) (rank (hd bq2))\n                    \\<le> rank (hd (meldUniq bq1 bq2))\n  rank_invar (t1 # bq1)\n  rank_invar (t2 # bq2)\n\ngoal (1 subgoal):\n 1. rank_invar bq2", "by (cases bq2) simp_all"], ["proof (state)\nthis:\n  rank_invar bq2\n\ngoal (1 subgoal):\n 1. \\<And>t1 bq1 t2 bq2.\n       \\<lbrakk>\\<lbrakk>rank t1 < rank t2; rank_invar bq1;\n                 rank_invar (t2 # bq2)\\<rbrakk>\n                \\<Longrightarrow> rank_invar\n                                   (meldUniq bq1 (t2 # bq2)) \\<and>\n                                  min (rank (hd bq1)) (rank (hd (t2 # bq2)))\n                                  \\<le> rank (hd (meldUniq bq1 (t2 # bq2)));\n        \\<lbrakk>\\<not> rank t1 < rank t2; rank t2 < rank t1;\n         rank_invar (t1 # bq1); rank_invar bq2\\<rbrakk>\n        \\<Longrightarrow> rank_invar (meldUniq (t1 # bq1) bq2) \\<and>\n                          min (rank (hd (t1 # bq1))) (rank (hd bq2))\n                          \\<le> rank (hd (meldUniq (t1 # bq1) bq2));\n        \\<lbrakk>\\<not> rank t1 < rank t2; \\<not> rank t2 < rank t1;\n         rank_invar bq1; rank_invar bq2\\<rbrakk>\n        \\<Longrightarrow> rank_invar (meldUniq bq1 bq2) \\<and>\n                          min (rank (hd bq1)) (rank (hd bq2))\n                          \\<le> rank (hd (meldUniq bq1 bq2));\n        rank_invar (t1 # bq1); rank_invar (t2 # bq2)\\<rbrakk>\n       \\<Longrightarrow> rank_invar (meldUniq (t1 # bq1) (t2 # bq2)) \\<and>\n                         min (rank (hd (t1 # bq1))) (rank (hd (t2 # bq2)))\n                         \\<le> rank (hd (meldUniq (t1 # bq1) (t2 # bq2)))", "from inv1 and inv2 and 3"], ["proof (chain)\npicking this:\n  rank_invar bq1\n  rank_invar bq2\n  \\<lbrakk>rank t1 < rank t2; rank_invar bq1; rank_invar (t2 # bq2)\\<rbrakk>\n  \\<Longrightarrow> rank_invar (meldUniq bq1 (t2 # bq2)) \\<and>\n                    min (rank (hd bq1)) (rank (hd (t2 # bq2)))\n                    \\<le> rank (hd (meldUniq bq1 (t2 # bq2)))\n  \\<lbrakk>\\<not> rank t1 < rank t2; rank t2 < rank t1;\n   rank_invar (t1 # bq1); rank_invar bq2\\<rbrakk>\n  \\<Longrightarrow> rank_invar (meldUniq (t1 # bq1) bq2) \\<and>\n                    min (rank (hd (t1 # bq1))) (rank (hd bq2))\n                    \\<le> rank (hd (meldUniq (t1 # bq1) bq2))\n  \\<lbrakk>\\<not> rank t1 < rank t2; \\<not> rank t2 < rank t1;\n   rank_invar bq1; rank_invar bq2\\<rbrakk>\n  \\<Longrightarrow> rank_invar (meldUniq bq1 bq2) \\<and>\n                    min (rank (hd bq1)) (rank (hd bq2))\n                    \\<le> rank (hd (meldUniq bq1 bq2))\n  rank_invar (t1 # bq1)\n  rank_invar (t2 # bq2)", "show ?case"], ["proof (prove)\nusing this:\n  rank_invar bq1\n  rank_invar bq2\n  \\<lbrakk>rank t1 < rank t2; rank_invar bq1; rank_invar (t2 # bq2)\\<rbrakk>\n  \\<Longrightarrow> rank_invar (meldUniq bq1 (t2 # bq2)) \\<and>\n                    min (rank (hd bq1)) (rank (hd (t2 # bq2)))\n                    \\<le> rank (hd (meldUniq bq1 (t2 # bq2)))\n  \\<lbrakk>\\<not> rank t1 < rank t2; rank t2 < rank t1;\n   rank_invar (t1 # bq1); rank_invar bq2\\<rbrakk>\n  \\<Longrightarrow> rank_invar (meldUniq (t1 # bq1) bq2) \\<and>\n                    min (rank (hd (t1 # bq1))) (rank (hd bq2))\n                    \\<le> rank (hd (meldUniq (t1 # bq1) bq2))\n  \\<lbrakk>\\<not> rank t1 < rank t2; \\<not> rank t2 < rank t1;\n   rank_invar bq1; rank_invar bq2\\<rbrakk>\n  \\<Longrightarrow> rank_invar (meldUniq bq1 bq2) \\<and>\n                    min (rank (hd bq1)) (rank (hd bq2))\n                    \\<le> rank (hd (meldUniq bq1 bq2))\n  rank_invar (t1 # bq1)\n  rank_invar (t2 # bq2)\n\ngoal (1 subgoal):\n 1. rank_invar (meldUniq (t1 # bq1) (t2 # bq2)) \\<and>\n    min (rank (hd (t1 # bq1))) (rank (hd (t2 # bq2)))\n    \\<le> rank (hd (meldUniq (t1 # bq1) (t2 # bq2)))", "apply auto"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>rank_invar bq1; rank_invar bq2; rank_invar (t1 # bq1);\n     rank_invar (t2 # bq2); rank t2 < rank t1;\n     rank_invar (meldUniq (t1 # bq1) bq2);\n     min (rank t1) (rank (hd bq2))\n     \\<le> rank (hd (meldUniq (t1 # bq1) bq2))\\<rbrakk>\n    \\<Longrightarrow> rank_invar (t2 # meldUniq (t1 # bq1) bq2)\n 2. \\<lbrakk>rank_invar bq1; rank_invar bq2; rank_invar (t1 # bq1);\n     rank_invar (t2 # bq2); rank t1 < rank t2;\n     rank_invar (meldUniq bq1 (t2 # bq2));\n     min (rank (hd bq1)) (rank t2)\n     \\<le> rank (hd (meldUniq bq1 (t2 # bq2)))\\<rbrakk>\n    \\<Longrightarrow> rank_invar (t1 # meldUniq bq1 (t2 # bq2))\n 3. \\<lbrakk>rank_invar bq1; rank_invar bq2; rank_invar (t1 # bq1);\n     rank_invar (t2 # bq2); rank t1 = rank t2;\n     rank_invar (meldUniq bq1 bq2);\n     min (rank (hd bq1)) (rank (hd bq2))\n     \\<le> rank (hd (meldUniq bq1 bq2))\\<rbrakk>\n    \\<Longrightarrow> rank_invar (ins (link t1 t2) (meldUniq bq1 bq2))\n 4. \\<lbrakk>rank_invar bq1; rank_invar bq2; rank_invar (t1 # bq1);\n     rank_invar (t2 # bq2); rank t1 = rank t2;\n     rank_invar (meldUniq bq1 bq2);\n     min (rank (hd bq1)) (rank (hd bq2))\n     \\<le> rank (hd (meldUniq bq1 bq2))\\<rbrakk>\n    \\<Longrightarrow> rank t2\n                      \\<le> rank (hd (ins (link t1 t2) (meldUniq bq1 bq2)))", "proof goal_cases"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<lbrakk>rank_invar bq1; rank_invar bq2; rank_invar (t1 # bq1);\n     rank_invar (t2 # bq2); rank t2 < rank t1;\n     rank_invar (meldUniq (t1 # bq1) bq2);\n     min (rank t1) (rank (hd bq2))\n     \\<le> rank (hd (meldUniq (t1 # bq1) bq2))\\<rbrakk>\n    \\<Longrightarrow> rank_invar (t2 # meldUniq (t1 # bq1) bq2)\n 2. \\<lbrakk>rank_invar bq1; rank_invar bq2; rank_invar (t1 # bq1);\n     rank_invar (t2 # bq2); rank t1 < rank t2;\n     rank_invar (meldUniq bq1 (t2 # bq2));\n     min (rank (hd bq1)) (rank t2)\n     \\<le> rank (hd (meldUniq bq1 (t2 # bq2)))\\<rbrakk>\n    \\<Longrightarrow> rank_invar (t1 # meldUniq bq1 (t2 # bq2))\n 3. \\<lbrakk>rank_invar bq1; rank_invar bq2; rank_invar (t1 # bq1);\n     rank_invar (t2 # bq2); rank t1 = rank t2;\n     rank_invar (meldUniq bq1 bq2);\n     min (rank (hd bq1)) (rank (hd bq2))\n     \\<le> rank (hd (meldUniq bq1 bq2))\\<rbrakk>\n    \\<Longrightarrow> rank_invar (ins (link t1 t2) (meldUniq bq1 bq2))\n 4. \\<lbrakk>rank_invar bq1; rank_invar bq2; rank_invar (t1 # bq1);\n     rank_invar (t2 # bq2); rank t1 = rank t2;\n     rank_invar (meldUniq bq1 bq2);\n     min (rank (hd bq1)) (rank (hd bq2))\n     \\<le> rank (hd (meldUniq bq1 bq2))\\<rbrakk>\n    \\<Longrightarrow> rank t2\n                      \\<le> rank (hd (ins (link t1 t2) (meldUniq bq1 bq2)))", "let ?t = \"t2\""], ["proof (state)\ngoal (4 subgoals):\n 1. \\<lbrakk>rank_invar bq1; rank_invar bq2; rank_invar (t1 # bq1);\n     rank_invar (t2 # bq2); rank t2 < rank t1;\n     rank_invar (meldUniq (t1 # bq1) bq2);\n     min (rank t1) (rank (hd bq2))\n     \\<le> rank (hd (meldUniq (t1 # bq1) bq2))\\<rbrakk>\n    \\<Longrightarrow> rank_invar (t2 # meldUniq (t1 # bq1) bq2)\n 2. \\<lbrakk>rank_invar bq1; rank_invar bq2; rank_invar (t1 # bq1);\n     rank_invar (t2 # bq2); rank t1 < rank t2;\n     rank_invar (meldUniq bq1 (t2 # bq2));\n     min (rank (hd bq1)) (rank t2)\n     \\<le> rank (hd (meldUniq bq1 (t2 # bq2)))\\<rbrakk>\n    \\<Longrightarrow> rank_invar (t1 # meldUniq bq1 (t2 # bq2))\n 3. \\<lbrakk>rank_invar bq1; rank_invar bq2; rank_invar (t1 # bq1);\n     rank_invar (t2 # bq2); rank t1 = rank t2;\n     rank_invar (meldUniq bq1 bq2);\n     min (rank (hd bq1)) (rank (hd bq2))\n     \\<le> rank (hd (meldUniq bq1 bq2))\\<rbrakk>\n    \\<Longrightarrow> rank_invar (ins (link t1 t2) (meldUniq bq1 bq2))\n 4. \\<lbrakk>rank_invar bq1; rank_invar bq2; rank_invar (t1 # bq1);\n     rank_invar (t2 # bq2); rank t1 = rank t2;\n     rank_invar (meldUniq bq1 bq2);\n     min (rank (hd bq1)) (rank (hd bq2))\n     \\<le> rank (hd (meldUniq bq1 bq2))\\<rbrakk>\n    \\<Longrightarrow> rank t2\n                      \\<le> rank (hd (ins (link t1 t2) (meldUniq bq1 bq2)))", "let ?bq = \"bq2\""], ["proof (state)\ngoal (4 subgoals):\n 1. \\<lbrakk>rank_invar bq1; rank_invar bq2; rank_invar (t1 # bq1);\n     rank_invar (t2 # bq2); rank t2 < rank t1;\n     rank_invar (meldUniq (t1 # bq1) bq2);\n     min (rank t1) (rank (hd bq2))\n     \\<le> rank (hd (meldUniq (t1 # bq1) bq2))\\<rbrakk>\n    \\<Longrightarrow> rank_invar (t2 # meldUniq (t1 # bq1) bq2)\n 2. \\<lbrakk>rank_invar bq1; rank_invar bq2; rank_invar (t1 # bq1);\n     rank_invar (t2 # bq2); rank t1 < rank t2;\n     rank_invar (meldUniq bq1 (t2 # bq2));\n     min (rank (hd bq1)) (rank t2)\n     \\<le> rank (hd (meldUniq bq1 (t2 # bq2)))\\<rbrakk>\n    \\<Longrightarrow> rank_invar (t1 # meldUniq bq1 (t2 # bq2))\n 3. \\<lbrakk>rank_invar bq1; rank_invar bq2; rank_invar (t1 # bq1);\n     rank_invar (t2 # bq2); rank t1 = rank t2;\n     rank_invar (meldUniq bq1 bq2);\n     min (rank (hd bq1)) (rank (hd bq2))\n     \\<le> rank (hd (meldUniq bq1 bq2))\\<rbrakk>\n    \\<Longrightarrow> rank_invar (ins (link t1 t2) (meldUniq bq1 bq2))\n 4. \\<lbrakk>rank_invar bq1; rank_invar bq2; rank_invar (t1 # bq1);\n     rank_invar (t2 # bq2); rank t1 = rank t2;\n     rank_invar (meldUniq bq1 bq2);\n     min (rank (hd bq1)) (rank (hd bq2))\n     \\<le> rank (hd (meldUniq bq1 bq2))\\<rbrakk>\n    \\<Longrightarrow> rank t2\n                      \\<le> rank (hd (ins (link t1 t2) (meldUniq bq1 bq2)))", "let ?meldUniq = \"rank t2 < rank (hd (meldUniq (t1 # bq1) bq2))\""], ["proof (state)\ngoal (4 subgoals):\n 1. \\<lbrakk>rank_invar bq1; rank_invar bq2; rank_invar (t1 # bq1);\n     rank_invar (t2 # bq2); rank t2 < rank t1;\n     rank_invar (meldUniq (t1 # bq1) bq2);\n     min (rank t1) (rank (hd bq2))\n     \\<le> rank (hd (meldUniq (t1 # bq1) bq2))\\<rbrakk>\n    \\<Longrightarrow> rank_invar (t2 # meldUniq (t1 # bq1) bq2)\n 2. \\<lbrakk>rank_invar bq1; rank_invar bq2; rank_invar (t1 # bq1);\n     rank_invar (t2 # bq2); rank t1 < rank t2;\n     rank_invar (meldUniq bq1 (t2 # bq2));\n     min (rank (hd bq1)) (rank t2)\n     \\<le> rank (hd (meldUniq bq1 (t2 # bq2)))\\<rbrakk>\n    \\<Longrightarrow> rank_invar (t1 # meldUniq bq1 (t2 # bq2))\n 3. \\<lbrakk>rank_invar bq1; rank_invar bq2; rank_invar (t1 # bq1);\n     rank_invar (t2 # bq2); rank t1 = rank t2;\n     rank_invar (meldUniq bq1 bq2);\n     min (rank (hd bq1)) (rank (hd bq2))\n     \\<le> rank (hd (meldUniq bq1 bq2))\\<rbrakk>\n    \\<Longrightarrow> rank_invar (ins (link t1 t2) (meldUniq bq1 bq2))\n 4. \\<lbrakk>rank_invar bq1; rank_invar bq2; rank_invar (t1 # bq1);\n     rank_invar (t2 # bq2); rank t1 = rank t2;\n     rank_invar (meldUniq bq1 bq2);\n     min (rank (hd bq1)) (rank (hd bq2))\n     \\<le> rank (hd (meldUniq bq1 bq2))\\<rbrakk>\n    \\<Longrightarrow> rank t2\n                      \\<le> rank (hd (ins (link t1 t2) (meldUniq bq1 bq2)))", "case prems: 1"], ["proof (state)\nthis:\n  rank_invar bq1\n  rank_invar bq2\n  rank_invar (t1 # bq1)\n  rank_invar (t2 # bq2)\n  rank t2 < rank t1\n  rank_invar (meldUniq (t1 # bq1) bq2)\n  min (rank t1) (rank (hd bq2)) \\<le> rank (hd (meldUniq (t1 # bq1) bq2))\n\ngoal (4 subgoals):\n 1. \\<lbrakk>rank_invar bq1; rank_invar bq2; rank_invar (t1 # bq1);\n     rank_invar (t2 # bq2); rank t2 < rank t1;\n     rank_invar (meldUniq (t1 # bq1) bq2);\n     min (rank t1) (rank (hd bq2))\n     \\<le> rank (hd (meldUniq (t1 # bq1) bq2))\\<rbrakk>\n    \\<Longrightarrow> rank_invar (t2 # meldUniq (t1 # bq1) bq2)\n 2. \\<lbrakk>rank_invar bq1; rank_invar bq2; rank_invar (t1 # bq1);\n     rank_invar (t2 # bq2); rank t1 < rank t2;\n     rank_invar (meldUniq bq1 (t2 # bq2));\n     min (rank (hd bq1)) (rank t2)\n     \\<le> rank (hd (meldUniq bq1 (t2 # bq2)))\\<rbrakk>\n    \\<Longrightarrow> rank_invar (t1 # meldUniq bq1 (t2 # bq2))\n 3. \\<lbrakk>rank_invar bq1; rank_invar bq2; rank_invar (t1 # bq1);\n     rank_invar (t2 # bq2); rank t1 = rank t2;\n     rank_invar (meldUniq bq1 bq2);\n     min (rank (hd bq1)) (rank (hd bq2))\n     \\<le> rank (hd (meldUniq bq1 bq2))\\<rbrakk>\n    \\<Longrightarrow> rank_invar (ins (link t1 t2) (meldUniq bq1 bq2))\n 4. \\<lbrakk>rank_invar bq1; rank_invar bq2; rank_invar (t1 # bq1);\n     rank_invar (t2 # bq2); rank t1 = rank t2;\n     rank_invar (meldUniq bq1 bq2);\n     min (rank (hd bq1)) (rank (hd bq2))\n     \\<le> rank (hd (meldUniq bq1 bq2))\\<rbrakk>\n    \\<Longrightarrow> rank t2\n                      \\<le> rank (hd (ins (link t1 t2) (meldUniq bq1 bq2)))", "hence \"?bq \\<noteq> [] \\<Longrightarrow> rank ?t < rank (hd ?bq)\""], ["proof (prove)\nusing this:\n  rank_invar bq1\n  rank_invar bq2\n  rank_invar (t1 # bq1)\n  rank_invar (t2 # bq2)\n  rank t2 < rank t1\n  rank_invar (meldUniq (t1 # bq1) bq2)\n  min (rank t1) (rank (hd bq2)) \\<le> rank (hd (meldUniq (t1 # bq1) bq2))\n\ngoal (1 subgoal):\n 1. bq2 \\<noteq> [] \\<Longrightarrow> rank t2 < rank (hd bq2)", "by (simp add: rank_invar_not_empty_hd)"], ["proof (state)\nthis:\n  bq2 \\<noteq> [] \\<Longrightarrow> rank t2 < rank (hd bq2)\n\ngoal (4 subgoals):\n 1. \\<lbrakk>rank_invar bq1; rank_invar bq2; rank_invar (t1 # bq1);\n     rank_invar (t2 # bq2); rank t2 < rank t1;\n     rank_invar (meldUniq (t1 # bq1) bq2);\n     min (rank t1) (rank (hd bq2))\n     \\<le> rank (hd (meldUniq (t1 # bq1) bq2))\\<rbrakk>\n    \\<Longrightarrow> rank_invar (t2 # meldUniq (t1 # bq1) bq2)\n 2. \\<lbrakk>rank_invar bq1; rank_invar bq2; rank_invar (t1 # bq1);\n     rank_invar (t2 # bq2); rank t1 < rank t2;\n     rank_invar (meldUniq bq1 (t2 # bq2));\n     min (rank (hd bq1)) (rank t2)\n     \\<le> rank (hd (meldUniq bq1 (t2 # bq2)))\\<rbrakk>\n    \\<Longrightarrow> rank_invar (t1 # meldUniq bq1 (t2 # bq2))\n 3. \\<lbrakk>rank_invar bq1; rank_invar bq2; rank_invar (t1 # bq1);\n     rank_invar (t2 # bq2); rank t1 = rank t2;\n     rank_invar (meldUniq bq1 bq2);\n     min (rank (hd bq1)) (rank (hd bq2))\n     \\<le> rank (hd (meldUniq bq1 bq2))\\<rbrakk>\n    \\<Longrightarrow> rank_invar (ins (link t1 t2) (meldUniq bq1 bq2))\n 4. \\<lbrakk>rank_invar bq1; rank_invar bq2; rank_invar (t1 # bq1);\n     rank_invar (t2 # bq2); rank t1 = rank t2;\n     rank_invar (meldUniq bq1 bq2);\n     min (rank (hd bq1)) (rank (hd bq2))\n     \\<le> rank (hd (meldUniq bq1 bq2))\\<rbrakk>\n    \\<Longrightarrow> rank t2\n                      \\<le> rank (hd (ins (link t1 t2) (meldUniq bq1 bq2)))", "with prems"], ["proof (chain)\npicking this:\n  rank_invar bq1\n  rank_invar bq2\n  rank_invar (t1 # bq1)\n  rank_invar (t2 # bq2)\n  rank t2 < rank t1\n  rank_invar (meldUniq (t1 # bq1) bq2)\n  min (rank t1) (rank (hd bq2)) \\<le> rank (hd (meldUniq (t1 # bq1) bq2))\n  bq2 \\<noteq> [] \\<Longrightarrow> rank t2 < rank (hd bq2)", "have ne: \"?bq \\<noteq> [] \\<Longrightarrow> ?meldUniq\""], ["proof (prove)\nusing this:\n  rank_invar bq1\n  rank_invar bq2\n  rank_invar (t1 # bq1)\n  rank_invar (t2 # bq2)\n  rank t2 < rank t1\n  rank_invar (meldUniq (t1 # bq1) bq2)\n  min (rank t1) (rank (hd bq2)) \\<le> rank (hd (meldUniq (t1 # bq1) bq2))\n  bq2 \\<noteq> [] \\<Longrightarrow> rank t2 < rank (hd bq2)\n\ngoal (1 subgoal):\n 1. bq2 \\<noteq> [] \\<Longrightarrow>\n    rank t2 < rank (hd (meldUniq (t1 # bq1) bq2))", "by simp"], ["proof (state)\nthis:\n  bq2 \\<noteq> [] \\<Longrightarrow>\n  rank t2 < rank (hd (meldUniq (t1 # bq1) bq2))\n\ngoal (4 subgoals):\n 1. \\<lbrakk>rank_invar bq1; rank_invar bq2; rank_invar (t1 # bq1);\n     rank_invar (t2 # bq2); rank t2 < rank t1;\n     rank_invar (meldUniq (t1 # bq1) bq2);\n     min (rank t1) (rank (hd bq2))\n     \\<le> rank (hd (meldUniq (t1 # bq1) bq2))\\<rbrakk>\n    \\<Longrightarrow> rank_invar (t2 # meldUniq (t1 # bq1) bq2)\n 2. \\<lbrakk>rank_invar bq1; rank_invar bq2; rank_invar (t1 # bq1);\n     rank_invar (t2 # bq2); rank t1 < rank t2;\n     rank_invar (meldUniq bq1 (t2 # bq2));\n     min (rank (hd bq1)) (rank t2)\n     \\<le> rank (hd (meldUniq bq1 (t2 # bq2)))\\<rbrakk>\n    \\<Longrightarrow> rank_invar (t1 # meldUniq bq1 (t2 # bq2))\n 3. \\<lbrakk>rank_invar bq1; rank_invar bq2; rank_invar (t1 # bq1);\n     rank_invar (t2 # bq2); rank t1 = rank t2;\n     rank_invar (meldUniq bq1 bq2);\n     min (rank (hd bq1)) (rank (hd bq2))\n     \\<le> rank (hd (meldUniq bq1 bq2))\\<rbrakk>\n    \\<Longrightarrow> rank_invar (ins (link t1 t2) (meldUniq bq1 bq2))\n 4. \\<lbrakk>rank_invar bq1; rank_invar bq2; rank_invar (t1 # bq1);\n     rank_invar (t2 # bq2); rank t1 = rank t2;\n     rank_invar (meldUniq bq1 bq2);\n     min (rank (hd bq1)) (rank (hd bq2))\n     \\<le> rank (hd (meldUniq bq1 bq2))\\<rbrakk>\n    \\<Longrightarrow> rank t2\n                      \\<le> rank (hd (ins (link t1 t2) (meldUniq bq1 bq2)))", "from prems"], ["proof (chain)\npicking this:\n  rank_invar bq1\n  rank_invar bq2\n  rank_invar (t1 # bq1)\n  rank_invar (t2 # bq2)\n  rank t2 < rank t1\n  rank_invar (meldUniq (t1 # bq1) bq2)\n  min (rank t1) (rank (hd bq2)) \\<le> rank (hd (meldUniq (t1 # bq1) bq2))", "have \"?bq = [] \\<Longrightarrow> ?meldUniq\""], ["proof (prove)\nusing this:\n  rank_invar bq1\n  rank_invar bq2\n  rank_invar (t1 # bq1)\n  rank_invar (t2 # bq2)\n  rank t2 < rank t1\n  rank_invar (meldUniq (t1 # bq1) bq2)\n  min (rank t1) (rank (hd bq2)) \\<le> rank (hd (meldUniq (t1 # bq1) bq2))\n\ngoal (1 subgoal):\n 1. bq2 = [] \\<Longrightarrow> rank t2 < rank (hd (meldUniq (t1 # bq1) bq2))", "by simp"], ["proof (state)\nthis:\n  bq2 = [] \\<Longrightarrow> rank t2 < rank (hd (meldUniq (t1 # bq1) bq2))\n\ngoal (4 subgoals):\n 1. \\<lbrakk>rank_invar bq1; rank_invar bq2; rank_invar (t1 # bq1);\n     rank_invar (t2 # bq2); rank t2 < rank t1;\n     rank_invar (meldUniq (t1 # bq1) bq2);\n     min (rank t1) (rank (hd bq2))\n     \\<le> rank (hd (meldUniq (t1 # bq1) bq2))\\<rbrakk>\n    \\<Longrightarrow> rank_invar (t2 # meldUniq (t1 # bq1) bq2)\n 2. \\<lbrakk>rank_invar bq1; rank_invar bq2; rank_invar (t1 # bq1);\n     rank_invar (t2 # bq2); rank t1 < rank t2;\n     rank_invar (meldUniq bq1 (t2 # bq2));\n     min (rank (hd bq1)) (rank t2)\n     \\<le> rank (hd (meldUniq bq1 (t2 # bq2)))\\<rbrakk>\n    \\<Longrightarrow> rank_invar (t1 # meldUniq bq1 (t2 # bq2))\n 3. \\<lbrakk>rank_invar bq1; rank_invar bq2; rank_invar (t1 # bq1);\n     rank_invar (t2 # bq2); rank t1 = rank t2;\n     rank_invar (meldUniq bq1 bq2);\n     min (rank (hd bq1)) (rank (hd bq2))\n     \\<le> rank (hd (meldUniq bq1 bq2))\\<rbrakk>\n    \\<Longrightarrow> rank_invar (ins (link t1 t2) (meldUniq bq1 bq2))\n 4. \\<lbrakk>rank_invar bq1; rank_invar bq2; rank_invar (t1 # bq1);\n     rank_invar (t2 # bq2); rank t1 = rank t2;\n     rank_invar (meldUniq bq1 bq2);\n     min (rank (hd bq1)) (rank (hd bq2))\n     \\<le> rank (hd (meldUniq bq1 bq2))\\<rbrakk>\n    \\<Longrightarrow> rank t2\n                      \\<le> rank (hd (ins (link t1 t2) (meldUniq bq1 bq2)))", "with ne"], ["proof (chain)\npicking this:\n  bq2 \\<noteq> [] \\<Longrightarrow>\n  rank t2 < rank (hd (meldUniq (t1 # bq1) bq2))\n  bq2 = [] \\<Longrightarrow> rank t2 < rank (hd (meldUniq (t1 # bq1) bq2))", "have \"?meldUniq\""], ["proof (prove)\nusing this:\n  bq2 \\<noteq> [] \\<Longrightarrow>\n  rank t2 < rank (hd (meldUniq (t1 # bq1) bq2))\n  bq2 = [] \\<Longrightarrow> rank t2 < rank (hd (meldUniq (t1 # bq1) bq2))\n\ngoal (1 subgoal):\n 1. rank t2 < rank (hd (meldUniq (t1 # bq1) bq2))", "by (cases \"?bq = []\")"], ["proof (state)\nthis:\n  rank t2 < rank (hd (meldUniq (t1 # bq1) bq2))\n\ngoal (4 subgoals):\n 1. \\<lbrakk>rank_invar bq1; rank_invar bq2; rank_invar (t1 # bq1);\n     rank_invar (t2 # bq2); rank t2 < rank t1;\n     rank_invar (meldUniq (t1 # bq1) bq2);\n     min (rank t1) (rank (hd bq2))\n     \\<le> rank (hd (meldUniq (t1 # bq1) bq2))\\<rbrakk>\n    \\<Longrightarrow> rank_invar (t2 # meldUniq (t1 # bq1) bq2)\n 2. \\<lbrakk>rank_invar bq1; rank_invar bq2; rank_invar (t1 # bq1);\n     rank_invar (t2 # bq2); rank t1 < rank t2;\n     rank_invar (meldUniq bq1 (t2 # bq2));\n     min (rank (hd bq1)) (rank t2)\n     \\<le> rank (hd (meldUniq bq1 (t2 # bq2)))\\<rbrakk>\n    \\<Longrightarrow> rank_invar (t1 # meldUniq bq1 (t2 # bq2))\n 3. \\<lbrakk>rank_invar bq1; rank_invar bq2; rank_invar (t1 # bq1);\n     rank_invar (t2 # bq2); rank t1 = rank t2;\n     rank_invar (meldUniq bq1 bq2);\n     min (rank (hd bq1)) (rank (hd bq2))\n     \\<le> rank (hd (meldUniq bq1 bq2))\\<rbrakk>\n    \\<Longrightarrow> rank_invar (ins (link t1 t2) (meldUniq bq1 bq2))\n 4. \\<lbrakk>rank_invar bq1; rank_invar bq2; rank_invar (t1 # bq1);\n     rank_invar (t2 # bq2); rank t1 = rank t2;\n     rank_invar (meldUniq bq1 bq2);\n     min (rank (hd bq1)) (rank (hd bq2))\n     \\<le> rank (hd (meldUniq bq1 bq2))\\<rbrakk>\n    \\<Longrightarrow> rank t2\n                      \\<le> rank (hd (ins (link t1 t2) (meldUniq bq1 bq2)))", "with prems"], ["proof (chain)\npicking this:\n  rank_invar bq1\n  rank_invar bq2\n  rank_invar (t1 # bq1)\n  rank_invar (t2 # bq2)\n  rank t2 < rank t1\n  rank_invar (meldUniq (t1 # bq1) bq2)\n  min (rank t1) (rank (hd bq2)) \\<le> rank (hd (meldUniq (t1 # bq1) bq2))\n  rank t2 < rank (hd (meldUniq (t1 # bq1) bq2))", "show ?case"], ["proof (prove)\nusing this:\n  rank_invar bq1\n  rank_invar bq2\n  rank_invar (t1 # bq1)\n  rank_invar (t2 # bq2)\n  rank t2 < rank t1\n  rank_invar (meldUniq (t1 # bq1) bq2)\n  min (rank t1) (rank (hd bq2)) \\<le> rank (hd (meldUniq (t1 # bq1) bq2))\n  rank t2 < rank (hd (meldUniq (t1 # bq1) bq2))\n\ngoal (1 subgoal):\n 1. rank_invar (t2 # meldUniq (t1 # bq1) bq2)", "by (simp add: rank_invar_hd_cons)"], ["proof (state)\nthis:\n  rank_invar (t2 # meldUniq (t1 # bq1) bq2)\n\ngoal (3 subgoals):\n 1. \\<lbrakk>rank_invar bq1; rank_invar bq2; rank_invar (t1 # bq1);\n     rank_invar (t2 # bq2); rank t1 < rank t2;\n     rank_invar (meldUniq bq1 (t2 # bq2));\n     min (rank (hd bq1)) (rank t2)\n     \\<le> rank (hd (meldUniq bq1 (t2 # bq2)))\\<rbrakk>\n    \\<Longrightarrow> rank_invar (t1 # meldUniq bq1 (t2 # bq2))\n 2. \\<lbrakk>rank_invar bq1; rank_invar bq2; rank_invar (t1 # bq1);\n     rank_invar (t2 # bq2); rank t1 = rank t2;\n     rank_invar (meldUniq bq1 bq2);\n     min (rank (hd bq1)) (rank (hd bq2))\n     \\<le> rank (hd (meldUniq bq1 bq2))\\<rbrakk>\n    \\<Longrightarrow> rank_invar (ins (link t1 t2) (meldUniq bq1 bq2))\n 3. \\<lbrakk>rank_invar bq1; rank_invar bq2; rank_invar (t1 # bq1);\n     rank_invar (t2 # bq2); rank t1 = rank t2;\n     rank_invar (meldUniq bq1 bq2);\n     min (rank (hd bq1)) (rank (hd bq2))\n     \\<le> rank (hd (meldUniq bq1 bq2))\\<rbrakk>\n    \\<Longrightarrow> rank t2\n                      \\<le> rank (hd (ins (link t1 t2) (meldUniq bq1 bq2)))", "next \\<comment> \\<open>analog\\<close>"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>rank_invar bq1; rank_invar bq2; rank_invar (t1 # bq1);\n     rank_invar (t2 # bq2); rank t1 < rank t2;\n     rank_invar (meldUniq bq1 (t2 # bq2));\n     min (rank (hd bq1)) (rank t2)\n     \\<le> rank (hd (meldUniq bq1 (t2 # bq2)))\\<rbrakk>\n    \\<Longrightarrow> rank_invar (t1 # meldUniq bq1 (t2 # bq2))\n 2. \\<lbrakk>rank_invar bq1; rank_invar bq2; rank_invar (t1 # bq1);\n     rank_invar (t2 # bq2); rank t1 = rank t2;\n     rank_invar (meldUniq bq1 bq2);\n     min (rank (hd bq1)) (rank (hd bq2))\n     \\<le> rank (hd (meldUniq bq1 bq2))\\<rbrakk>\n    \\<Longrightarrow> rank_invar (ins (link t1 t2) (meldUniq bq1 bq2))\n 3. \\<lbrakk>rank_invar bq1; rank_invar bq2; rank_invar (t1 # bq1);\n     rank_invar (t2 # bq2); rank t1 = rank t2;\n     rank_invar (meldUniq bq1 bq2);\n     min (rank (hd bq1)) (rank (hd bq2))\n     \\<le> rank (hd (meldUniq bq1 bq2))\\<rbrakk>\n    \\<Longrightarrow> rank t2\n                      \\<le> rank (hd (ins (link t1 t2) (meldUniq bq1 bq2)))", "let ?t = \"t1\""], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>rank_invar bq1; rank_invar bq2; rank_invar (t1 # bq1);\n     rank_invar (t2 # bq2); rank t1 < rank t2;\n     rank_invar (meldUniq bq1 (t2 # bq2));\n     min (rank (hd bq1)) (rank t2)\n     \\<le> rank (hd (meldUniq bq1 (t2 # bq2)))\\<rbrakk>\n    \\<Longrightarrow> rank_invar (t1 # meldUniq bq1 (t2 # bq2))\n 2. \\<lbrakk>rank_invar bq1; rank_invar bq2; rank_invar (t1 # bq1);\n     rank_invar (t2 # bq2); rank t1 = rank t2;\n     rank_invar (meldUniq bq1 bq2);\n     min (rank (hd bq1)) (rank (hd bq2))\n     \\<le> rank (hd (meldUniq bq1 bq2))\\<rbrakk>\n    \\<Longrightarrow> rank_invar (ins (link t1 t2) (meldUniq bq1 bq2))\n 3. \\<lbrakk>rank_invar bq1; rank_invar bq2; rank_invar (t1 # bq1);\n     rank_invar (t2 # bq2); rank t1 = rank t2;\n     rank_invar (meldUniq bq1 bq2);\n     min (rank (hd bq1)) (rank (hd bq2))\n     \\<le> rank (hd (meldUniq bq1 bq2))\\<rbrakk>\n    \\<Longrightarrow> rank t2\n                      \\<le> rank (hd (ins (link t1 t2) (meldUniq bq1 bq2)))", "let ?bq = \"bq1\""], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>rank_invar bq1; rank_invar bq2; rank_invar (t1 # bq1);\n     rank_invar (t2 # bq2); rank t1 < rank t2;\n     rank_invar (meldUniq bq1 (t2 # bq2));\n     min (rank (hd bq1)) (rank t2)\n     \\<le> rank (hd (meldUniq bq1 (t2 # bq2)))\\<rbrakk>\n    \\<Longrightarrow> rank_invar (t1 # meldUniq bq1 (t2 # bq2))\n 2. \\<lbrakk>rank_invar bq1; rank_invar bq2; rank_invar (t1 # bq1);\n     rank_invar (t2 # bq2); rank t1 = rank t2;\n     rank_invar (meldUniq bq1 bq2);\n     min (rank (hd bq1)) (rank (hd bq2))\n     \\<le> rank (hd (meldUniq bq1 bq2))\\<rbrakk>\n    \\<Longrightarrow> rank_invar (ins (link t1 t2) (meldUniq bq1 bq2))\n 3. \\<lbrakk>rank_invar bq1; rank_invar bq2; rank_invar (t1 # bq1);\n     rank_invar (t2 # bq2); rank t1 = rank t2;\n     rank_invar (meldUniq bq1 bq2);\n     min (rank (hd bq1)) (rank (hd bq2))\n     \\<le> rank (hd (meldUniq bq1 bq2))\\<rbrakk>\n    \\<Longrightarrow> rank t2\n                      \\<le> rank (hd (ins (link t1 t2) (meldUniq bq1 bq2)))", "let ?meldUniq = \"rank t1 < rank (hd (meldUniq bq1 (t2 # bq2)))\""], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>rank_invar bq1; rank_invar bq2; rank_invar (t1 # bq1);\n     rank_invar (t2 # bq2); rank t1 < rank t2;\n     rank_invar (meldUniq bq1 (t2 # bq2));\n     min (rank (hd bq1)) (rank t2)\n     \\<le> rank (hd (meldUniq bq1 (t2 # bq2)))\\<rbrakk>\n    \\<Longrightarrow> rank_invar (t1 # meldUniq bq1 (t2 # bq2))\n 2. \\<lbrakk>rank_invar bq1; rank_invar bq2; rank_invar (t1 # bq1);\n     rank_invar (t2 # bq2); rank t1 = rank t2;\n     rank_invar (meldUniq bq1 bq2);\n     min (rank (hd bq1)) (rank (hd bq2))\n     \\<le> rank (hd (meldUniq bq1 bq2))\\<rbrakk>\n    \\<Longrightarrow> rank_invar (ins (link t1 t2) (meldUniq bq1 bq2))\n 3. \\<lbrakk>rank_invar bq1; rank_invar bq2; rank_invar (t1 # bq1);\n     rank_invar (t2 # bq2); rank t1 = rank t2;\n     rank_invar (meldUniq bq1 bq2);\n     min (rank (hd bq1)) (rank (hd bq2))\n     \\<le> rank (hd (meldUniq bq1 bq2))\\<rbrakk>\n    \\<Longrightarrow> rank t2\n                      \\<le> rank (hd (ins (link t1 t2) (meldUniq bq1 bq2)))", "case prems: 2"], ["proof (state)\nthis:\n  rank_invar bq1\n  rank_invar bq2\n  rank_invar (t1 # bq1)\n  rank_invar (t2 # bq2)\n  rank t1 < rank t2\n  rank_invar (meldUniq bq1 (t2 # bq2))\n  min (rank (hd bq1)) (rank t2) \\<le> rank (hd (meldUniq bq1 (t2 # bq2)))\n\ngoal (3 subgoals):\n 1. \\<lbrakk>rank_invar bq1; rank_invar bq2; rank_invar (t1 # bq1);\n     rank_invar (t2 # bq2); rank t1 < rank t2;\n     rank_invar (meldUniq bq1 (t2 # bq2));\n     min (rank (hd bq1)) (rank t2)\n     \\<le> rank (hd (meldUniq bq1 (t2 # bq2)))\\<rbrakk>\n    \\<Longrightarrow> rank_invar (t1 # meldUniq bq1 (t2 # bq2))\n 2. \\<lbrakk>rank_invar bq1; rank_invar bq2; rank_invar (t1 # bq1);\n     rank_invar (t2 # bq2); rank t1 = rank t2;\n     rank_invar (meldUniq bq1 bq2);\n     min (rank (hd bq1)) (rank (hd bq2))\n     \\<le> rank (hd (meldUniq bq1 bq2))\\<rbrakk>\n    \\<Longrightarrow> rank_invar (ins (link t1 t2) (meldUniq bq1 bq2))\n 3. \\<lbrakk>rank_invar bq1; rank_invar bq2; rank_invar (t1 # bq1);\n     rank_invar (t2 # bq2); rank t1 = rank t2;\n     rank_invar (meldUniq bq1 bq2);\n     min (rank (hd bq1)) (rank (hd bq2))\n     \\<le> rank (hd (meldUniq bq1 bq2))\\<rbrakk>\n    \\<Longrightarrow> rank t2\n                      \\<le> rank (hd (ins (link t1 t2) (meldUniq bq1 bq2)))", "hence \"?bq \\<noteq> [] \\<Longrightarrow> rank ?t < rank (hd ?bq)\""], ["proof (prove)\nusing this:\n  rank_invar bq1\n  rank_invar bq2\n  rank_invar (t1 # bq1)\n  rank_invar (t2 # bq2)\n  rank t1 < rank t2\n  rank_invar (meldUniq bq1 (t2 # bq2))\n  min (rank (hd bq1)) (rank t2) \\<le> rank (hd (meldUniq bq1 (t2 # bq2)))\n\ngoal (1 subgoal):\n 1. bq1 \\<noteq> [] \\<Longrightarrow> rank t1 < rank (hd bq1)", "by (simp add: rank_invar_not_empty_hd)"], ["proof (state)\nthis:\n  bq1 \\<noteq> [] \\<Longrightarrow> rank t1 < rank (hd bq1)\n\ngoal (3 subgoals):\n 1. \\<lbrakk>rank_invar bq1; rank_invar bq2; rank_invar (t1 # bq1);\n     rank_invar (t2 # bq2); rank t1 < rank t2;\n     rank_invar (meldUniq bq1 (t2 # bq2));\n     min (rank (hd bq1)) (rank t2)\n     \\<le> rank (hd (meldUniq bq1 (t2 # bq2)))\\<rbrakk>\n    \\<Longrightarrow> rank_invar (t1 # meldUniq bq1 (t2 # bq2))\n 2. \\<lbrakk>rank_invar bq1; rank_invar bq2; rank_invar (t1 # bq1);\n     rank_invar (t2 # bq2); rank t1 = rank t2;\n     rank_invar (meldUniq bq1 bq2);\n     min (rank (hd bq1)) (rank (hd bq2))\n     \\<le> rank (hd (meldUniq bq1 bq2))\\<rbrakk>\n    \\<Longrightarrow> rank_invar (ins (link t1 t2) (meldUniq bq1 bq2))\n 3. \\<lbrakk>rank_invar bq1; rank_invar bq2; rank_invar (t1 # bq1);\n     rank_invar (t2 # bq2); rank t1 = rank t2;\n     rank_invar (meldUniq bq1 bq2);\n     min (rank (hd bq1)) (rank (hd bq2))\n     \\<le> rank (hd (meldUniq bq1 bq2))\\<rbrakk>\n    \\<Longrightarrow> rank t2\n                      \\<le> rank (hd (ins (link t1 t2) (meldUniq bq1 bq2)))", "with prems"], ["proof (chain)\npicking this:\n  rank_invar bq1\n  rank_invar bq2\n  rank_invar (t1 # bq1)\n  rank_invar (t2 # bq2)\n  rank t1 < rank t2\n  rank_invar (meldUniq bq1 (t2 # bq2))\n  min (rank (hd bq1)) (rank t2) \\<le> rank (hd (meldUniq bq1 (t2 # bq2)))\n  bq1 \\<noteq> [] \\<Longrightarrow> rank t1 < rank (hd bq1)", "have ne: \"?bq \\<noteq> [] \\<Longrightarrow> ?meldUniq\""], ["proof (prove)\nusing this:\n  rank_invar bq1\n  rank_invar bq2\n  rank_invar (t1 # bq1)\n  rank_invar (t2 # bq2)\n  rank t1 < rank t2\n  rank_invar (meldUniq bq1 (t2 # bq2))\n  min (rank (hd bq1)) (rank t2) \\<le> rank (hd (meldUniq bq1 (t2 # bq2)))\n  bq1 \\<noteq> [] \\<Longrightarrow> rank t1 < rank (hd bq1)\n\ngoal (1 subgoal):\n 1. bq1 \\<noteq> [] \\<Longrightarrow>\n    rank t1 < rank (hd (meldUniq bq1 (t2 # bq2)))", "by simp"], ["proof (state)\nthis:\n  bq1 \\<noteq> [] \\<Longrightarrow>\n  rank t1 < rank (hd (meldUniq bq1 (t2 # bq2)))\n\ngoal (3 subgoals):\n 1. \\<lbrakk>rank_invar bq1; rank_invar bq2; rank_invar (t1 # bq1);\n     rank_invar (t2 # bq2); rank t1 < rank t2;\n     rank_invar (meldUniq bq1 (t2 # bq2));\n     min (rank (hd bq1)) (rank t2)\n     \\<le> rank (hd (meldUniq bq1 (t2 # bq2)))\\<rbrakk>\n    \\<Longrightarrow> rank_invar (t1 # meldUniq bq1 (t2 # bq2))\n 2. \\<lbrakk>rank_invar bq1; rank_invar bq2; rank_invar (t1 # bq1);\n     rank_invar (t2 # bq2); rank t1 = rank t2;\n     rank_invar (meldUniq bq1 bq2);\n     min (rank (hd bq1)) (rank (hd bq2))\n     \\<le> rank (hd (meldUniq bq1 bq2))\\<rbrakk>\n    \\<Longrightarrow> rank_invar (ins (link t1 t2) (meldUniq bq1 bq2))\n 3. \\<lbrakk>rank_invar bq1; rank_invar bq2; rank_invar (t1 # bq1);\n     rank_invar (t2 # bq2); rank t1 = rank t2;\n     rank_invar (meldUniq bq1 bq2);\n     min (rank (hd bq1)) (rank (hd bq2))\n     \\<le> rank (hd (meldUniq bq1 bq2))\\<rbrakk>\n    \\<Longrightarrow> rank t2\n                      \\<le> rank (hd (ins (link t1 t2) (meldUniq bq1 bq2)))", "from prems"], ["proof (chain)\npicking this:\n  rank_invar bq1\n  rank_invar bq2\n  rank_invar (t1 # bq1)\n  rank_invar (t2 # bq2)\n  rank t1 < rank t2\n  rank_invar (meldUniq bq1 (t2 # bq2))\n  min (rank (hd bq1)) (rank t2) \\<le> rank (hd (meldUniq bq1 (t2 # bq2)))", "have \"?bq = [] \\<Longrightarrow> ?meldUniq\""], ["proof (prove)\nusing this:\n  rank_invar bq1\n  rank_invar bq2\n  rank_invar (t1 # bq1)\n  rank_invar (t2 # bq2)\n  rank t1 < rank t2\n  rank_invar (meldUniq bq1 (t2 # bq2))\n  min (rank (hd bq1)) (rank t2) \\<le> rank (hd (meldUniq bq1 (t2 # bq2)))\n\ngoal (1 subgoal):\n 1. bq1 = [] \\<Longrightarrow> rank t1 < rank (hd (meldUniq bq1 (t2 # bq2)))", "by simp"], ["proof (state)\nthis:\n  bq1 = [] \\<Longrightarrow> rank t1 < rank (hd (meldUniq bq1 (t2 # bq2)))\n\ngoal (3 subgoals):\n 1. \\<lbrakk>rank_invar bq1; rank_invar bq2; rank_invar (t1 # bq1);\n     rank_invar (t2 # bq2); rank t1 < rank t2;\n     rank_invar (meldUniq bq1 (t2 # bq2));\n     min (rank (hd bq1)) (rank t2)\n     \\<le> rank (hd (meldUniq bq1 (t2 # bq2)))\\<rbrakk>\n    \\<Longrightarrow> rank_invar (t1 # meldUniq bq1 (t2 # bq2))\n 2. \\<lbrakk>rank_invar bq1; rank_invar bq2; rank_invar (t1 # bq1);\n     rank_invar (t2 # bq2); rank t1 = rank t2;\n     rank_invar (meldUniq bq1 bq2);\n     min (rank (hd bq1)) (rank (hd bq2))\n     \\<le> rank (hd (meldUniq bq1 bq2))\\<rbrakk>\n    \\<Longrightarrow> rank_invar (ins (link t1 t2) (meldUniq bq1 bq2))\n 3. \\<lbrakk>rank_invar bq1; rank_invar bq2; rank_invar (t1 # bq1);\n     rank_invar (t2 # bq2); rank t1 = rank t2;\n     rank_invar (meldUniq bq1 bq2);\n     min (rank (hd bq1)) (rank (hd bq2))\n     \\<le> rank (hd (meldUniq bq1 bq2))\\<rbrakk>\n    \\<Longrightarrow> rank t2\n                      \\<le> rank (hd (ins (link t1 t2) (meldUniq bq1 bq2)))", "with ne"], ["proof (chain)\npicking this:\n  bq1 \\<noteq> [] \\<Longrightarrow>\n  rank t1 < rank (hd (meldUniq bq1 (t2 # bq2)))\n  bq1 = [] \\<Longrightarrow> rank t1 < rank (hd (meldUniq bq1 (t2 # bq2)))", "have \"?meldUniq\""], ["proof (prove)\nusing this:\n  bq1 \\<noteq> [] \\<Longrightarrow>\n  rank t1 < rank (hd (meldUniq bq1 (t2 # bq2)))\n  bq1 = [] \\<Longrightarrow> rank t1 < rank (hd (meldUniq bq1 (t2 # bq2)))\n\ngoal (1 subgoal):\n 1. rank t1 < rank (hd (meldUniq bq1 (t2 # bq2)))", "by (cases \"?bq = []\")"], ["proof (state)\nthis:\n  rank t1 < rank (hd (meldUniq bq1 (t2 # bq2)))\n\ngoal (3 subgoals):\n 1. \\<lbrakk>rank_invar bq1; rank_invar bq2; rank_invar (t1 # bq1);\n     rank_invar (t2 # bq2); rank t1 < rank t2;\n     rank_invar (meldUniq bq1 (t2 # bq2));\n     min (rank (hd bq1)) (rank t2)\n     \\<le> rank (hd (meldUniq bq1 (t2 # bq2)))\\<rbrakk>\n    \\<Longrightarrow> rank_invar (t1 # meldUniq bq1 (t2 # bq2))\n 2. \\<lbrakk>rank_invar bq1; rank_invar bq2; rank_invar (t1 # bq1);\n     rank_invar (t2 # bq2); rank t1 = rank t2;\n     rank_invar (meldUniq bq1 bq2);\n     min (rank (hd bq1)) (rank (hd bq2))\n     \\<le> rank (hd (meldUniq bq1 bq2))\\<rbrakk>\n    \\<Longrightarrow> rank_invar (ins (link t1 t2) (meldUniq bq1 bq2))\n 3. \\<lbrakk>rank_invar bq1; rank_invar bq2; rank_invar (t1 # bq1);\n     rank_invar (t2 # bq2); rank t1 = rank t2;\n     rank_invar (meldUniq bq1 bq2);\n     min (rank (hd bq1)) (rank (hd bq2))\n     \\<le> rank (hd (meldUniq bq1 bq2))\\<rbrakk>\n    \\<Longrightarrow> rank t2\n                      \\<le> rank (hd (ins (link t1 t2) (meldUniq bq1 bq2)))", "with prems"], ["proof (chain)\npicking this:\n  rank_invar bq1\n  rank_invar bq2\n  rank_invar (t1 # bq1)\n  rank_invar (t2 # bq2)\n  rank t1 < rank t2\n  rank_invar (meldUniq bq1 (t2 # bq2))\n  min (rank (hd bq1)) (rank t2) \\<le> rank (hd (meldUniq bq1 (t2 # bq2)))\n  rank t1 < rank (hd (meldUniq bq1 (t2 # bq2)))", "show ?case"], ["proof (prove)\nusing this:\n  rank_invar bq1\n  rank_invar bq2\n  rank_invar (t1 # bq1)\n  rank_invar (t2 # bq2)\n  rank t1 < rank t2\n  rank_invar (meldUniq bq1 (t2 # bq2))\n  min (rank (hd bq1)) (rank t2) \\<le> rank (hd (meldUniq bq1 (t2 # bq2)))\n  rank t1 < rank (hd (meldUniq bq1 (t2 # bq2)))\n\ngoal (1 subgoal):\n 1. rank_invar (t1 # meldUniq bq1 (t2 # bq2))", "by (simp add: rank_invar_hd_cons)"], ["proof (state)\nthis:\n  rank_invar (t1 # meldUniq bq1 (t2 # bq2))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>rank_invar bq1; rank_invar bq2; rank_invar (t1 # bq1);\n     rank_invar (t2 # bq2); rank t1 = rank t2;\n     rank_invar (meldUniq bq1 bq2);\n     min (rank (hd bq1)) (rank (hd bq2))\n     \\<le> rank (hd (meldUniq bq1 bq2))\\<rbrakk>\n    \\<Longrightarrow> rank_invar (ins (link t1 t2) (meldUniq bq1 bq2))\n 2. \\<lbrakk>rank_invar bq1; rank_invar bq2; rank_invar (t1 # bq1);\n     rank_invar (t2 # bq2); rank t1 = rank t2;\n     rank_invar (meldUniq bq1 bq2);\n     min (rank (hd bq1)) (rank (hd bq2))\n     \\<le> rank (hd (meldUniq bq1 bq2))\\<rbrakk>\n    \\<Longrightarrow> rank t2\n                      \\<le> rank (hd (ins (link t1 t2) (meldUniq bq1 bq2)))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>rank_invar bq1; rank_invar bq2; rank_invar (t1 # bq1);\n     rank_invar (t2 # bq2); rank t1 = rank t2;\n     rank_invar (meldUniq bq1 bq2);\n     min (rank (hd bq1)) (rank (hd bq2))\n     \\<le> rank (hd (meldUniq bq1 bq2))\\<rbrakk>\n    \\<Longrightarrow> rank_invar (ins (link t1 t2) (meldUniq bq1 bq2))\n 2. \\<lbrakk>rank_invar bq1; rank_invar bq2; rank_invar (t1 # bq1);\n     rank_invar (t2 # bq2); rank t1 = rank t2;\n     rank_invar (meldUniq bq1 bq2);\n     min (rank (hd bq1)) (rank (hd bq2))\n     \\<le> rank (hd (meldUniq bq1 bq2))\\<rbrakk>\n    \\<Longrightarrow> rank t2\n                      \\<le> rank (hd (ins (link t1 t2) (meldUniq bq1 bq2)))", "case 3"], ["proof (state)\nthis:\n  rank_invar bq1\n  rank_invar bq2\n  rank_invar (t1 # bq1)\n  rank_invar (t2 # bq2)\n  rank t1 = rank t2\n  rank_invar (meldUniq bq1 bq2)\n  min (rank (hd bq1)) (rank (hd bq2)) \\<le> rank (hd (meldUniq bq1 bq2))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>rank_invar bq1; rank_invar bq2; rank_invar (t1 # bq1);\n     rank_invar (t2 # bq2); rank t1 = rank t2;\n     rank_invar (meldUniq bq1 bq2);\n     min (rank (hd bq1)) (rank (hd bq2))\n     \\<le> rank (hd (meldUniq bq1 bq2))\\<rbrakk>\n    \\<Longrightarrow> rank_invar (ins (link t1 t2) (meldUniq bq1 bq2))\n 2. \\<lbrakk>rank_invar bq1; rank_invar bq2; rank_invar (t1 # bq1);\n     rank_invar (t2 # bq2); rank t1 = rank t2;\n     rank_invar (meldUniq bq1 bq2);\n     min (rank (hd bq1)) (rank (hd bq2))\n     \\<le> rank (hd (meldUniq bq1 bq2))\\<rbrakk>\n    \\<Longrightarrow> rank t2\n                      \\<le> rank (hd (ins (link t1 t2) (meldUniq bq1 bq2)))", "thus ?case"], ["proof (prove)\nusing this:\n  rank_invar bq1\n  rank_invar bq2\n  rank_invar (t1 # bq1)\n  rank_invar (t2 # bq2)\n  rank t1 = rank t2\n  rank_invar (meldUniq bq1 bq2)\n  min (rank (hd bq1)) (rank (hd bq2)) \\<le> rank (hd (meldUniq bq1 bq2))\n\ngoal (1 subgoal):\n 1. rank_invar (ins (link t1 t2) (meldUniq bq1 bq2))", "by (simp add: rank_ins)"], ["proof (state)\nthis:\n  rank_invar (ins (link t1 t2) (meldUniq bq1 bq2))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>rank_invar bq1; rank_invar bq2; rank_invar (t1 # bq1);\n     rank_invar (t2 # bq2); rank t1 = rank t2;\n     rank_invar (meldUniq bq1 bq2);\n     min (rank (hd bq1)) (rank (hd bq2))\n     \\<le> rank (hd (meldUniq bq1 bq2))\\<rbrakk>\n    \\<Longrightarrow> rank t2\n                      \\<le> rank (hd (ins (link t1 t2) (meldUniq bq1 bq2)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>rank_invar bq1; rank_invar bq2; rank_invar (t1 # bq1);\n     rank_invar (t2 # bq2); rank t1 = rank t2;\n     rank_invar (meldUniq bq1 bq2);\n     min (rank (hd bq1)) (rank (hd bq2))\n     \\<le> rank (hd (meldUniq bq1 bq2))\\<rbrakk>\n    \\<Longrightarrow> rank t2\n                      \\<le> rank (hd (ins (link t1 t2) (meldUniq bq1 bq2)))", "case prems: 4"], ["proof (state)\nthis:\n  rank_invar bq1\n  rank_invar bq2\n  rank_invar (t1 # bq1)\n  rank_invar (t2 # bq2)\n  rank t1 = rank t2\n  rank_invar (meldUniq bq1 bq2)\n  min (rank (hd bq1)) (rank (hd bq2)) \\<le> rank (hd (meldUniq bq1 bq2))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>rank_invar bq1; rank_invar bq2; rank_invar (t1 # bq1);\n     rank_invar (t2 # bq2); rank t1 = rank t2;\n     rank_invar (meldUniq bq1 bq2);\n     min (rank (hd bq1)) (rank (hd bq2))\n     \\<le> rank (hd (meldUniq bq1 bq2))\\<rbrakk>\n    \\<Longrightarrow> rank t2\n                      \\<le> rank (hd (ins (link t1 t2) (meldUniq bq1 bq2)))", "(* Ab hier wirds h?sslich *)"], ["proof (state)\nthis:\n  rank_invar bq1\n  rank_invar bq2\n  rank_invar (t1 # bq1)\n  rank_invar (t2 # bq2)\n  rank t1 = rank t2\n  rank_invar (meldUniq bq1 bq2)\n  min (rank (hd bq1)) (rank (hd bq2)) \\<le> rank (hd (meldUniq bq1 bq2))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>rank_invar bq1; rank_invar bq2; rank_invar (t1 # bq1);\n     rank_invar (t2 # bq2); rank t1 = rank t2;\n     rank_invar (meldUniq bq1 bq2);\n     min (rank (hd bq1)) (rank (hd bq2))\n     \\<le> rank (hd (meldUniq bq1 bq2))\\<rbrakk>\n    \\<Longrightarrow> rank t2\n                      \\<le> rank (hd (ins (link t1 t2) (meldUniq bq1 bq2)))", "then"], ["proof (chain)\npicking this:\n  rank_invar bq1\n  rank_invar bq2\n  rank_invar (t1 # bq1)\n  rank_invar (t2 # bq2)\n  rank t1 = rank t2\n  rank_invar (meldUniq bq1 bq2)\n  min (rank (hd bq1)) (rank (hd bq2)) \\<le> rank (hd (meldUniq bq1 bq2))", "have r: \"rank (link t1 t2) = rank t2 + 1\""], ["proof (prove)\nusing this:\n  rank_invar bq1\n  rank_invar bq2\n  rank_invar (t1 # bq1)\n  rank_invar (t2 # bq2)\n  rank t1 = rank t2\n  rank_invar (meldUniq bq1 bq2)\n  min (rank (hd bq1)) (rank (hd bq2)) \\<le> rank (hd (meldUniq bq1 bq2))\n\ngoal (1 subgoal):\n 1. rank (link t1 t2) = rank t2 + 1", "by (simp add: rank_link)"], ["proof (state)\nthis:\n  rank (link t1 t2) = rank t2 + 1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>rank_invar bq1; rank_invar bq2; rank_invar (t1 # bq1);\n     rank_invar (t2 # bq2); rank t1 = rank t2;\n     rank_invar (meldUniq bq1 bq2);\n     min (rank (hd bq1)) (rank (hd bq2))\n     \\<le> rank (hd (meldUniq bq1 bq2))\\<rbrakk>\n    \\<Longrightarrow> rank t2\n                      \\<le> rank (hd (ins (link t1 t2) (meldUniq bq1 bq2)))", "have m: \"meldUniq bq1 [] = bq1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. meldUniq bq1 [] = bq1", "by (cases bq1) auto"], ["proof (state)\nthis:\n  meldUniq bq1 [] = bq1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>rank_invar bq1; rank_invar bq2; rank_invar (t1 # bq1);\n     rank_invar (t2 # bq2); rank t1 = rank t2;\n     rank_invar (meldUniq bq1 bq2);\n     min (rank (hd bq1)) (rank (hd bq2))\n     \\<le> rank (hd (meldUniq bq1 bq2))\\<rbrakk>\n    \\<Longrightarrow> rank t2\n                      \\<le> rank (hd (ins (link t1 t2) (meldUniq bq1 bq2)))", "from inv1 and inv2 and prems"], ["proof (chain)\npicking this:\n  rank_invar bq1\n  rank_invar bq2\n  rank_invar bq1\n  rank_invar bq2\n  rank_invar (t1 # bq1)\n  rank_invar (t2 # bq2)\n  rank t1 = rank t2\n  rank_invar (meldUniq bq1 bq2)\n  min (rank (hd bq1)) (rank (hd bq2)) \\<le> rank (hd (meldUniq bq1 bq2))", "have \n      mm: \"min (rank (hd bq1)) (rank (hd bq2)) \\<le> rank (hd (meldUniq bq1 bq2))\""], ["proof (prove)\nusing this:\n  rank_invar bq1\n  rank_invar bq2\n  rank_invar bq1\n  rank_invar bq2\n  rank_invar (t1 # bq1)\n  rank_invar (t2 # bq2)\n  rank t1 = rank t2\n  rank_invar (meldUniq bq1 bq2)\n  min (rank (hd bq1)) (rank (hd bq2)) \\<le> rank (hd (meldUniq bq1 bq2))\n\ngoal (1 subgoal):\n 1. min (rank (hd bq1)) (rank (hd bq2)) \\<le> rank (hd (meldUniq bq1 bq2))", "by simp"], ["proof (state)\nthis:\n  min (rank (hd bq1)) (rank (hd bq2)) \\<le> rank (hd (meldUniq bq1 bq2))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>rank_invar bq1; rank_invar bq2; rank_invar (t1 # bq1);\n     rank_invar (t2 # bq2); rank t1 = rank t2;\n     rank_invar (meldUniq bq1 bq2);\n     min (rank (hd bq1)) (rank (hd bq2))\n     \\<le> rank (hd (meldUniq bq1 bq2))\\<rbrakk>\n    \\<Longrightarrow> rank t2\n                      \\<le> rank (hd (ins (link t1 t2) (meldUniq bq1 bq2)))", "from \\<open>rank_invar (t1 # bq1)\\<close>"], ["proof (chain)\npicking this:\n  rank_invar (t1 # bq1)", "have \"bq1 \\<noteq> [] \\<Longrightarrow> rank t1 < rank (hd bq1)\""], ["proof (prove)\nusing this:\n  rank_invar (t1 # bq1)\n\ngoal (1 subgoal):\n 1. bq1 \\<noteq> [] \\<Longrightarrow> rank t1 < rank (hd bq1)", "by (simp add: rank_invar_not_empty_hd)"], ["proof (state)\nthis:\n  bq1 \\<noteq> [] \\<Longrightarrow> rank t1 < rank (hd bq1)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>rank_invar bq1; rank_invar bq2; rank_invar (t1 # bq1);\n     rank_invar (t2 # bq2); rank t1 = rank t2;\n     rank_invar (meldUniq bq1 bq2);\n     min (rank (hd bq1)) (rank (hd bq2))\n     \\<le> rank (hd (meldUniq bq1 bq2))\\<rbrakk>\n    \\<Longrightarrow> rank t2\n                      \\<le> rank (hd (ins (link t1 t2) (meldUniq bq1 bq2)))", "with prems"], ["proof (chain)\npicking this:\n  rank_invar bq1\n  rank_invar bq2\n  rank_invar (t1 # bq1)\n  rank_invar (t2 # bq2)\n  rank t1 = rank t2\n  rank_invar (meldUniq bq1 bq2)\n  min (rank (hd bq1)) (rank (hd bq2)) \\<le> rank (hd (meldUniq bq1 bq2))\n  bq1 \\<noteq> [] \\<Longrightarrow> rank t1 < rank (hd bq1)", "have r1: \"bq1 \\<noteq> [] \\<Longrightarrow> rank t2 < rank (hd bq1)\""], ["proof (prove)\nusing this:\n  rank_invar bq1\n  rank_invar bq2\n  rank_invar (t1 # bq1)\n  rank_invar (t2 # bq2)\n  rank t1 = rank t2\n  rank_invar (meldUniq bq1 bq2)\n  min (rank (hd bq1)) (rank (hd bq2)) \\<le> rank (hd (meldUniq bq1 bq2))\n  bq1 \\<noteq> [] \\<Longrightarrow> rank t1 < rank (hd bq1)\n\ngoal (1 subgoal):\n 1. bq1 \\<noteq> [] \\<Longrightarrow> rank t2 < rank (hd bq1)", "by simp"], ["proof (state)\nthis:\n  bq1 \\<noteq> [] \\<Longrightarrow> rank t2 < rank (hd bq1)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>rank_invar bq1; rank_invar bq2; rank_invar (t1 # bq1);\n     rank_invar (t2 # bq2); rank t1 = rank t2;\n     rank_invar (meldUniq bq1 bq2);\n     min (rank (hd bq1)) (rank (hd bq2))\n     \\<le> rank (hd (meldUniq bq1 bq2))\\<rbrakk>\n    \\<Longrightarrow> rank t2\n                      \\<le> rank (hd (ins (link t1 t2) (meldUniq bq1 bq2)))", "from \\<open>rank_invar (t2 # bq2)\\<close>"], ["proof (chain)\npicking this:\n  rank_invar (t2 # bq2)", "have r2: \"bq2 \\<noteq> [] \\<Longrightarrow> rank t2 < rank (hd bq2)\""], ["proof (prove)\nusing this:\n  rank_invar (t2 # bq2)\n\ngoal (1 subgoal):\n 1. bq2 \\<noteq> [] \\<Longrightarrow> rank t2 < rank (hd bq2)", "by (simp add: rank_invar_not_empty_hd)"], ["proof (state)\nthis:\n  bq2 \\<noteq> [] \\<Longrightarrow> rank t2 < rank (hd bq2)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>rank_invar bq1; rank_invar bq2; rank_invar (t1 # bq1);\n     rank_invar (t2 # bq2); rank t1 = rank t2;\n     rank_invar (meldUniq bq1 bq2);\n     min (rank (hd bq1)) (rank (hd bq2))\n     \\<le> rank (hd (meldUniq bq1 bq2))\\<rbrakk>\n    \\<Longrightarrow> rank t2\n                      \\<le> rank (hd (ins (link t1 t2) (meldUniq bq1 bq2)))", "from inv1 r r1 rank_ins_min[of bq1 \"(link t1 t2)\"]"], ["proof (chain)\npicking this:\n  rank_invar bq1\n  rank (link t1 t2) = rank t2 + 1\n  bq1 \\<noteq> [] \\<Longrightarrow> rank t2 < rank (hd bq1)\n  rank_invar bq1 \\<Longrightarrow>\n  min (rank (link t1 t2)) (rank (hd bq1))\n  \\<le> rank (hd (ins (link t1 t2) bq1))", "have \n      abc1: \"bq1 \\<noteq> [] \\<Longrightarrow> rank t2 \\<le> rank (hd (ins (link t1 t2) bq1))\""], ["proof (prove)\nusing this:\n  rank_invar bq1\n  rank (link t1 t2) = rank t2 + 1\n  bq1 \\<noteq> [] \\<Longrightarrow> rank t2 < rank (hd bq1)\n  rank_invar bq1 \\<Longrightarrow>\n  min (rank (link t1 t2)) (rank (hd bq1))\n  \\<le> rank (hd (ins (link t1 t2) bq1))\n\ngoal (1 subgoal):\n 1. bq1 \\<noteq> [] \\<Longrightarrow>\n    rank t2 \\<le> rank (hd (ins (link t1 t2) bq1))", "by simp"], ["proof (state)\nthis:\n  bq1 \\<noteq> [] \\<Longrightarrow>\n  rank t2 \\<le> rank (hd (ins (link t1 t2) bq1))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>rank_invar bq1; rank_invar bq2; rank_invar (t1 # bq1);\n     rank_invar (t2 # bq2); rank t1 = rank t2;\n     rank_invar (meldUniq bq1 bq2);\n     min (rank (hd bq1)) (rank (hd bq2))\n     \\<le> rank (hd (meldUniq bq1 bq2))\\<rbrakk>\n    \\<Longrightarrow> rank t2\n                      \\<le> rank (hd (ins (link t1 t2) (meldUniq bq1 bq2)))", "from inv2 r r2 rank_ins_min[of bq2 \"(link t1 t2)\"]"], ["proof (chain)\npicking this:\n  rank_invar bq2\n  rank (link t1 t2) = rank t2 + 1\n  bq2 \\<noteq> [] \\<Longrightarrow> rank t2 < rank (hd bq2)\n  rank_invar bq2 \\<Longrightarrow>\n  min (rank (link t1 t2)) (rank (hd bq2))\n  \\<le> rank (hd (ins (link t1 t2) bq2))", "have \n      abc2: \"bq2 \\<noteq> [] \\<Longrightarrow> rank t2 \\<le> rank (hd (ins (link t1 t2) bq2))\""], ["proof (prove)\nusing this:\n  rank_invar bq2\n  rank (link t1 t2) = rank t2 + 1\n  bq2 \\<noteq> [] \\<Longrightarrow> rank t2 < rank (hd bq2)\n  rank_invar bq2 \\<Longrightarrow>\n  min (rank (link t1 t2)) (rank (hd bq2))\n  \\<le> rank (hd (ins (link t1 t2) bq2))\n\ngoal (1 subgoal):\n 1. bq2 \\<noteq> [] \\<Longrightarrow>\n    rank t2 \\<le> rank (hd (ins (link t1 t2) bq2))", "by simp"], ["proof (state)\nthis:\n  bq2 \\<noteq> [] \\<Longrightarrow>\n  rank t2 \\<le> rank (hd (ins (link t1 t2) bq2))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>rank_invar bq1; rank_invar bq2; rank_invar (t1 # bq1);\n     rank_invar (t2 # bq2); rank t1 = rank t2;\n     rank_invar (meldUniq bq1 bq2);\n     min (rank (hd bq1)) (rank (hd bq2))\n     \\<le> rank (hd (meldUniq bq1 bq2))\\<rbrakk>\n    \\<Longrightarrow> rank t2\n                      \\<le> rank (hd (ins (link t1 t2) (meldUniq bq1 bq2)))", "from r1 r2 mm"], ["proof (chain)\npicking this:\n  bq1 \\<noteq> [] \\<Longrightarrow> rank t2 < rank (hd bq1)\n  bq2 \\<noteq> [] \\<Longrightarrow> rank t2 < rank (hd bq2)\n  min (rank (hd bq1)) (rank (hd bq2)) \\<le> rank (hd (meldUniq bq1 bq2))", "have \n      \"\\<lbrakk>bq1 \\<noteq> []; bq2 \\<noteq> []\\<rbrakk> \\<Longrightarrow> rank t2 < rank (hd (meldUniq bq1 bq2))\""], ["proof (prove)\nusing this:\n  bq1 \\<noteq> [] \\<Longrightarrow> rank t2 < rank (hd bq1)\n  bq2 \\<noteq> [] \\<Longrightarrow> rank t2 < rank (hd bq2)\n  min (rank (hd bq1)) (rank (hd bq2)) \\<le> rank (hd (meldUniq bq1 bq2))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>bq1 \\<noteq> []; bq2 \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> rank t2 < rank (hd (meldUniq bq1 bq2))", "by (simp)"], ["proof (state)\nthis:\n  \\<lbrakk>bq1 \\<noteq> []; bq2 \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> rank t2 < rank (hd (meldUniq bq1 bq2))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>rank_invar bq1; rank_invar bq2; rank_invar (t1 # bq1);\n     rank_invar (t2 # bq2); rank t1 = rank t2;\n     rank_invar (meldUniq bq1 bq2);\n     min (rank (hd bq1)) (rank (hd bq2))\n     \\<le> rank (hd (meldUniq bq1 bq2))\\<rbrakk>\n    \\<Longrightarrow> rank t2\n                      \\<le> rank (hd (ins (link t1 t2) (meldUniq bq1 bq2)))", "with \\<open>rank_invar (meldUniq bq1 bq2)\\<close> r \n      rank_ins_min[of \"meldUniq bq1 bq2\" \"link t1 t2\"]"], ["proof (chain)\npicking this:\n  rank_invar (meldUniq bq1 bq2)\n  rank (link t1 t2) = rank t2 + 1\n  rank_invar (meldUniq bq1 bq2) \\<Longrightarrow>\n  min (rank (link t1 t2)) (rank (hd (meldUniq bq1 bq2)))\n  \\<le> rank (hd (ins (link t1 t2) (meldUniq bq1 bq2)))\n  \\<lbrakk>bq1 \\<noteq> []; bq2 \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> rank t2 < rank (hd (meldUniq bq1 bq2))", "have \"\\<lbrakk>bq1 \\<noteq> []; bq2 \\<noteq> []\\<rbrakk> \\<Longrightarrow> \n      rank t2 < rank (hd (ins (link t1 t2) (meldUniq bq1 bq2)))\""], ["proof (prove)\nusing this:\n  rank_invar (meldUniq bq1 bq2)\n  rank (link t1 t2) = rank t2 + 1\n  rank_invar (meldUniq bq1 bq2) \\<Longrightarrow>\n  min (rank (link t1 t2)) (rank (hd (meldUniq bq1 bq2)))\n  \\<le> rank (hd (ins (link t1 t2) (meldUniq bq1 bq2)))\n  \\<lbrakk>bq1 \\<noteq> []; bq2 \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> rank t2 < rank (hd (meldUniq bq1 bq2))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>bq1 \\<noteq> []; bq2 \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> rank t2\n                      < rank (hd (ins (link t1 t2) (meldUniq bq1 bq2)))", "by simp"], ["proof (state)\nthis:\n  \\<lbrakk>bq1 \\<noteq> []; bq2 \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> rank t2\n                    < rank (hd (ins (link t1 t2) (meldUniq bq1 bq2)))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>rank_invar bq1; rank_invar bq2; rank_invar (t1 # bq1);\n     rank_invar (t2 # bq2); rank t1 = rank t2;\n     rank_invar (meldUniq bq1 bq2);\n     min (rank (hd bq1)) (rank (hd bq2))\n     \\<le> rank (hd (meldUniq bq1 bq2))\\<rbrakk>\n    \\<Longrightarrow> rank t2\n                      \\<le> rank (hd (ins (link t1 t2) (meldUniq bq1 bq2)))", "with inv1 and inv2 and r m r1"], ["proof (chain)\npicking this:\n  rank_invar bq1\n  rank_invar bq2\n  rank (link t1 t2) = rank t2 + 1\n  meldUniq bq1 [] = bq1\n  bq1 \\<noteq> [] \\<Longrightarrow> rank t2 < rank (hd bq1)\n  \\<lbrakk>bq1 \\<noteq> []; bq2 \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> rank t2\n                    < rank (hd (ins (link t1 t2) (meldUniq bq1 bq2)))", "show ?case"], ["proof (prove)\nusing this:\n  rank_invar bq1\n  rank_invar bq2\n  rank (link t1 t2) = rank t2 + 1\n  meldUniq bq1 [] = bq1\n  bq1 \\<noteq> [] \\<Longrightarrow> rank t2 < rank (hd bq1)\n  \\<lbrakk>bq1 \\<noteq> []; bq2 \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> rank t2\n                    < rank (hd (ins (link t1 t2) (meldUniq bq1 bq2)))\n\ngoal (1 subgoal):\n 1. rank t2 \\<le> rank (hd (ins (link t1 t2) (meldUniq bq1 bq2)))", "apply(cases \"bq2 = []\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>rank_invar bq1; rank_invar bq2;\n     rank (link t1 t2) = rank t2 + 1; meldUniq bq1 [] = bq1;\n     bq1 \\<noteq> [] \\<Longrightarrow> rank t2 < rank (hd bq1);\n     \\<lbrakk>bq1 \\<noteq> []; bq2 \\<noteq> []\\<rbrakk>\n     \\<Longrightarrow> rank t2\n                       < rank (hd (ins (link t1 t2) (meldUniq bq1 bq2)));\n     bq2 = []\\<rbrakk>\n    \\<Longrightarrow> rank t2\n                      \\<le> rank (hd (ins (link t1 t2) (meldUniq bq1 bq2)))\n 2. \\<lbrakk>rank_invar bq1; rank_invar bq2;\n     rank (link t1 t2) = rank t2 + 1; meldUniq bq1 [] = bq1;\n     bq1 \\<noteq> [] \\<Longrightarrow> rank t2 < rank (hd bq1);\n     \\<lbrakk>bq1 \\<noteq> []; bq2 \\<noteq> []\\<rbrakk>\n     \\<Longrightarrow> rank t2\n                       < rank (hd (ins (link t1 t2) (meldUniq bq1 bq2)));\n     bq2 \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> rank t2\n                      \\<le> rank (hd (ins (link t1 t2) (meldUniq bq1 bq2)))", "apply(cases \"bq1 = []\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>rank_invar bq1; rank_invar bq2;\n     rank (link t1 t2) = rank t2 + 1; meldUniq bq1 [] = bq1;\n     bq1 \\<noteq> [] \\<Longrightarrow> rank t2 < rank (hd bq1);\n     \\<lbrakk>bq1 \\<noteq> []; bq2 \\<noteq> []\\<rbrakk>\n     \\<Longrightarrow> rank t2\n                       < rank (hd (ins (link t1 t2) (meldUniq bq1 bq2)));\n     bq2 = []; bq1 = []\\<rbrakk>\n    \\<Longrightarrow> rank t2\n                      \\<le> rank (hd (ins (link t1 t2) (meldUniq bq1 bq2)))\n 2. \\<lbrakk>rank_invar bq1; rank_invar bq2;\n     rank (link t1 t2) = rank t2 + 1; meldUniq bq1 [] = bq1;\n     bq1 \\<noteq> [] \\<Longrightarrow> rank t2 < rank (hd bq1);\n     \\<lbrakk>bq1 \\<noteq> []; bq2 \\<noteq> []\\<rbrakk>\n     \\<Longrightarrow> rank t2\n                       < rank (hd (ins (link t1 t2) (meldUniq bq1 bq2)));\n     bq2 = []; bq1 \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> rank t2\n                      \\<le> rank (hd (ins (link t1 t2) (meldUniq bq1 bq2)))\n 3. \\<lbrakk>rank_invar bq1; rank_invar bq2;\n     rank (link t1 t2) = rank t2 + 1; meldUniq bq1 [] = bq1;\n     bq1 \\<noteq> [] \\<Longrightarrow> rank t2 < rank (hd bq1);\n     \\<lbrakk>bq1 \\<noteq> []; bq2 \\<noteq> []\\<rbrakk>\n     \\<Longrightarrow> rank t2\n                       < rank (hd (ins (link t1 t2) (meldUniq bq1 bq2)));\n     bq2 \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> rank t2\n                      \\<le> rank (hd (ins (link t1 t2) (meldUniq bq1 bq2)))", "apply(simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>rank_invar bq1; rank_invar bq2;\n     rank (link t1 t2) = rank t2 + 1; meldUniq bq1 [] = bq1;\n     bq1 \\<noteq> [] \\<Longrightarrow> rank t2 < rank (hd bq1);\n     \\<lbrakk>bq1 \\<noteq> []; bq2 \\<noteq> []\\<rbrakk>\n     \\<Longrightarrow> rank t2\n                       < rank (hd (ins (link t1 t2) (meldUniq bq1 bq2)));\n     bq2 = []; bq1 \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> rank t2\n                      \\<le> rank (hd (ins (link t1 t2) (meldUniq bq1 bq2)))\n 2. \\<lbrakk>rank_invar bq1; rank_invar bq2;\n     rank (link t1 t2) = rank t2 + 1; meldUniq bq1 [] = bq1;\n     bq1 \\<noteq> [] \\<Longrightarrow> rank t2 < rank (hd bq1);\n     \\<lbrakk>bq1 \\<noteq> []; bq2 \\<noteq> []\\<rbrakk>\n     \\<Longrightarrow> rank t2\n                       < rank (hd (ins (link t1 t2) (meldUniq bq1 bq2)));\n     bq2 \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> rank t2\n                      \\<le> rank (hd (ins (link t1 t2) (meldUniq bq1 bq2)))", "apply(auto simp add: abc1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>rank_invar bq1; rank_invar bq2;\n     rank (link t1 t2) = Suc (rank t2); meldUniq bq1 [] = bq1;\n     bq1 \\<noteq> [] \\<Longrightarrow> rank t2 < rank (hd bq1);\n     bq1 \\<noteq> [] \\<Longrightarrow>\n     rank t2 < rank (hd (ins (link t1 t2) (meldUniq bq1 bq2)));\n     bq2 \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> rank t2\n                      \\<le> rank (hd (ins (link t1 t2) (meldUniq bq1 bq2)))", "apply(cases \"bq1 = []\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>rank_invar bq1; rank_invar bq2;\n     rank (link t1 t2) = Suc (rank t2); meldUniq bq1 [] = bq1;\n     bq1 \\<noteq> [] \\<Longrightarrow> rank t2 < rank (hd bq1);\n     bq1 \\<noteq> [] \\<Longrightarrow>\n     rank t2 < rank (hd (ins (link t1 t2) (meldUniq bq1 bq2)));\n     bq2 \\<noteq> []; bq1 = []\\<rbrakk>\n    \\<Longrightarrow> rank t2\n                      \\<le> rank (hd (ins (link t1 t2) (meldUniq bq1 bq2)))\n 2. \\<lbrakk>rank_invar bq1; rank_invar bq2;\n     rank (link t1 t2) = Suc (rank t2); meldUniq bq1 [] = bq1;\n     bq1 \\<noteq> [] \\<Longrightarrow> rank t2 < rank (hd bq1);\n     bq1 \\<noteq> [] \\<Longrightarrow>\n     rank t2 < rank (hd (ins (link t1 t2) (meldUniq bq1 bq2)));\n     bq2 \\<noteq> []; bq1 \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> rank t2\n                      \\<le> rank (hd (ins (link t1 t2) (meldUniq bq1 bq2)))", "apply(simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>rank_invar bq2; rank (link t1 t2) = Suc (rank t2);\n     bq2 \\<noteq> []; bq1 = []\\<rbrakk>\n    \\<Longrightarrow> rank t2 \\<le> rank (hd (ins (link t1 t2) bq2))\n 2. \\<lbrakk>rank_invar bq1; rank_invar bq2;\n     rank (link t1 t2) = Suc (rank t2); meldUniq bq1 [] = bq1;\n     bq1 \\<noteq> [] \\<Longrightarrow> rank t2 < rank (hd bq1);\n     bq1 \\<noteq> [] \\<Longrightarrow>\n     rank t2 < rank (hd (ins (link t1 t2) (meldUniq bq1 bq2)));\n     bq2 \\<noteq> []; bq1 \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> rank t2\n                      \\<le> rank (hd (ins (link t1 t2) (meldUniq bq1 bq2)))", "apply(auto simp add: abc2)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  rank t2 \\<le> rank (hd (ins (link t1 t2) (meldUniq bq1 bq2)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  rank_invar (meldUniq (t1 # bq1) (t2 # bq2)) \\<and>\n  min (rank (hd (t1 # bq1))) (rank (hd (t2 # bq2)))\n  \\<le> rank (hd (meldUniq (t1 # bq1) (t2 # bq2)))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rank_meldUniq: \n  \"\\<lbrakk>rank_invar bq1; rank_invar bq2\\<rbrakk> \\<Longrightarrow> rank_invar (meldUniq bq1 bq2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>rank_invar bq1; rank_invar bq2\\<rbrakk>\n    \\<Longrightarrow> rank_invar (meldUniq bq1 bq2)", "by (simp only: rank_invar_meldUniq_strong)"], ["", "lemma rank_meld: \n  \"\\<lbrakk>rank_skew_invar q1; rank_skew_invar q2\\<rbrakk> \\<Longrightarrow> rank_skew_invar (meld q1 q2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>rank_skew_invar q1; rank_skew_invar q2\\<rbrakk>\n    \\<Longrightarrow> rank_skew_invar (meld q1 q2)", "by (simp only: meld_def rank_meldUniq rank_uniqify rank_invar_rank_skew)"], ["", "theorem meld_invar: \n  \"\\<lbrakk>invar bq1; invar bq2\\<rbrakk> \n  \\<Longrightarrow> invar (meld bq1 bq2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>invar bq1; invar bq2\\<rbrakk>\n    \\<Longrightarrow> invar (meld bq1 bq2)", "by (metis meld_queue_invar rank_meld invar_def)"], ["", "theorem meld_correct:\n  assumes I: \"invar q\" \"invar q'\"\n  shows \n  \"invar (meld q q')\"\n  \"queue_to_multiset (meld q q') = queue_to_multiset q + queue_to_multiset q'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invar (meld q q') &&&\n    queue_to_multiset (meld q q') =\n    queue_to_multiset q + queue_to_multiset q'", "using meld_invar[of q q'] meld_mset[of q q'] I"], ["proof (prove)\nusing this:\n  \\<lbrakk>invar q; invar q'\\<rbrakk> \\<Longrightarrow> invar (meld q q')\n  \\<lbrakk>queue_invar q; queue_invar q'\\<rbrakk>\n  \\<Longrightarrow> queue_to_multiset (meld q q') =\n                    queue_to_multiset q + queue_to_multiset q'\n  invar q\n  invar q'\n\ngoal (1 subgoal):\n 1. invar (meld q q') &&&\n    queue_to_multiset (meld q q') =\n    queue_to_multiset q + queue_to_multiset q'", "unfolding invar_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>queue_invar q \\<and> rank_skew_invar q;\n   queue_invar q' \\<and> rank_skew_invar q'\\<rbrakk>\n  \\<Longrightarrow> queue_invar (meld q q') \\<and>\n                    rank_skew_invar (meld q q')\n  \\<lbrakk>queue_invar q; queue_invar q'\\<rbrakk>\n  \\<Longrightarrow> queue_to_multiset (meld q q') =\n                    queue_to_multiset q + queue_to_multiset q'\n  queue_invar q \\<and> rank_skew_invar q\n  queue_invar q' \\<and> rank_skew_invar q'\n\ngoal (1 subgoal):\n 1. queue_invar (meld q q') \\<and> rank_skew_invar (meld q q') &&&\n    queue_to_multiset (meld q q') =\n    queue_to_multiset q + queue_to_multiset q'", "by simp_all"], ["", "subsubsection \"Find Minimal Element\""], ["", "text \\<open>Find the tree containing the minimal element.\\<close>"], ["", "fun getMinTree :: \"('e, 'a::linorder) SkewBinomialQueue \\<Rightarrow> \n  ('e, 'a) SkewBinomialTree\" where\n  \"getMinTree [t] = t\" |\n  \"getMinTree (t#bq) =\n    (if prio t \\<le> prio (getMinTree bq)\n      then t\n      else (getMinTree bq))\""], ["", "text \\<open>Find the minimal Element in the queue.\\<close>"], ["", "definition findMin :: \"('e, 'a::linorder) SkewBinomialQueue \\<Rightarrow> ('e \\<times> 'a)\" where\n  \"findMin bq = (let min = getMinTree bq in (val min, prio min))\""], ["", "lemma mintree_exists: \"(bq \\<noteq> []) = (getMinTree bq \\<in> set bq)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (bq \\<noteq> []) = (getMinTree bq \\<in> set bq)", "proof (induct bq)"], ["proof (state)\ngoal (2 subgoals):\n 1. ([] \\<noteq> []) = (getMinTree [] \\<in> set [])\n 2. \\<And>a bq.\n       (bq \\<noteq> []) = (getMinTree bq \\<in> set bq) \\<Longrightarrow>\n       (a # bq \\<noteq> []) = (getMinTree (a # bq) \\<in> set (a # bq))", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. ([] \\<noteq> []) = (getMinTree [] \\<in> set [])\n 2. \\<And>a bq.\n       (bq \\<noteq> []) = (getMinTree bq \\<in> set bq) \\<Longrightarrow>\n       (a # bq \\<noteq> []) = (getMinTree (a # bq) \\<in> set (a # bq))", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. ([] \\<noteq> []) = (getMinTree [] \\<in> set [])", "by simp"], ["proof (state)\nthis:\n  ([] \\<noteq> []) = (getMinTree [] \\<in> set [])\n\ngoal (1 subgoal):\n 1. \\<And>a bq.\n       (bq \\<noteq> []) = (getMinTree bq \\<in> set bq) \\<Longrightarrow>\n       (a # bq \\<noteq> []) = (getMinTree (a # bq) \\<in> set (a # bq))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a bq.\n       (bq \\<noteq> []) = (getMinTree bq \\<in> set bq) \\<Longrightarrow>\n       (a # bq \\<noteq> []) = (getMinTree (a # bq) \\<in> set (a # bq))", "case (Cons _ bq)"], ["proof (state)\nthis:\n  (bq \\<noteq> []) = (getMinTree bq \\<in> set bq)\n\ngoal (1 subgoal):\n 1. \\<And>a bq.\n       (bq \\<noteq> []) = (getMinTree bq \\<in> set bq) \\<Longrightarrow>\n       (a # bq \\<noteq> []) = (getMinTree (a # bq) \\<in> set (a # bq))", "then"], ["proof (chain)\npicking this:\n  (bq \\<noteq> []) = (getMinTree bq \\<in> set bq)", "show ?case"], ["proof (prove)\nusing this:\n  (bq \\<noteq> []) = (getMinTree bq \\<in> set bq)\n\ngoal (1 subgoal):\n 1. (a_ # bq \\<noteq> []) = (getMinTree (a_ # bq) \\<in> set (a_ # bq))", "by (cases bq) simp_all"], ["proof (state)\nthis:\n  (a_ # bq \\<noteq> []) = (getMinTree (a_ # bq) \\<in> set (a_ # bq))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma treehead_in_multiset: \n  \"t \\<in> set bq \\<Longrightarrow> (val t, prio t) \\<in># (queue_to_multiset bq)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<in> set bq \\<Longrightarrow>\n    (val t, prio t) \\<in># queue_to_multiset bq", "by (induct bq, simp, cases t, auto)"], ["", "lemma heap_ordered_single: \n  \"heap_ordered t = (\\<forall>x \\<in> set_mset (tree_to_multiset t). prio t \\<le> snd x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. heap_ordered t =\n    (\\<forall>x\\<in>#tree_to_multiset t. prio t \\<le> snd x)", "by (cases t) auto"], ["", "lemma getMinTree_cons: \n  \"prio (getMinTree (y # x # xs)) \\<le> prio (getMinTree (x # xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prio (getMinTree (y # x # xs)) \\<le> prio (getMinTree (x # xs))", "by (induct xs rule: getMinTree.induct) simp_all"], ["", "lemma getMinTree_min_tree: \"t \\<in> set bq  \\<Longrightarrow> prio (getMinTree bq) \\<le> prio t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<in> set bq \\<Longrightarrow> prio (getMinTree bq) \\<le> prio t", "by (induct bq arbitrary: t rule: getMinTree.induct) (simp, fastforce, simp)"], ["", "lemma getMinTree_min_prio:\n  assumes \"queue_invar bq\"\n    and \"y \\<in> set_mset (queue_to_multiset bq)\"\n  shows \"prio (getMinTree bq) \\<le> snd y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prio (getMinTree bq) \\<le> snd y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. prio (getMinTree bq) \\<le> snd y", "from assms"], ["proof (chain)\npicking this:\n  queue_invar bq\n  y \\<in># queue_to_multiset bq", "have \"bq \\<noteq> []\""], ["proof (prove)\nusing this:\n  queue_invar bq\n  y \\<in># queue_to_multiset bq\n\ngoal (1 subgoal):\n 1. bq \\<noteq> []", "by (cases bq) simp_all"], ["proof (state)\nthis:\n  bq \\<noteq> []\n\ngoal (1 subgoal):\n 1. prio (getMinTree bq) \\<le> snd y", "with assms"], ["proof (chain)\npicking this:\n  queue_invar bq\n  y \\<in># queue_to_multiset bq\n  bq \\<noteq> []", "have \"\\<exists>t \\<in> set bq. (y \\<in> set_mset (tree_to_multiset t))\""], ["proof (prove)\nusing this:\n  queue_invar bq\n  y \\<in># queue_to_multiset bq\n  bq \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<exists>t\\<in>set bq. y \\<in># tree_to_multiset t", "proof (induct bq)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>queue_invar []; y \\<in># queue_to_multiset [];\n     [] \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t\\<in>set []. y \\<in># tree_to_multiset t\n 2. \\<And>a bq.\n       \\<lbrakk>\\<lbrakk>queue_invar bq; y \\<in># queue_to_multiset bq;\n                 bq \\<noteq> []\\<rbrakk>\n                \\<Longrightarrow> \\<exists>t\\<in>set bq.\n                                     y \\<in># tree_to_multiset t;\n        queue_invar (a # bq); y \\<in># queue_to_multiset (a # bq);\n        a # bq \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t\\<in>set (a # bq).\n                            y \\<in># tree_to_multiset t", "case Nil"], ["proof (state)\nthis:\n  queue_invar []\n  y \\<in># queue_to_multiset []\n  [] \\<noteq> []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>queue_invar []; y \\<in># queue_to_multiset [];\n     [] \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t\\<in>set []. y \\<in># tree_to_multiset t\n 2. \\<And>a bq.\n       \\<lbrakk>\\<lbrakk>queue_invar bq; y \\<in># queue_to_multiset bq;\n                 bq \\<noteq> []\\<rbrakk>\n                \\<Longrightarrow> \\<exists>t\\<in>set bq.\n                                     y \\<in># tree_to_multiset t;\n        queue_invar (a # bq); y \\<in># queue_to_multiset (a # bq);\n        a # bq \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t\\<in>set (a # bq).\n                            y \\<in># tree_to_multiset t", "then"], ["proof (chain)\npicking this:\n  queue_invar []\n  y \\<in># queue_to_multiset []\n  [] \\<noteq> []", "show ?case"], ["proof (prove)\nusing this:\n  queue_invar []\n  y \\<in># queue_to_multiset []\n  [] \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<exists>t\\<in>set []. y \\<in># tree_to_multiset t", "by simp"], ["proof (state)\nthis:\n  \\<exists>t\\<in>set []. y \\<in># tree_to_multiset t\n\ngoal (1 subgoal):\n 1. \\<And>a bq.\n       \\<lbrakk>\\<lbrakk>queue_invar bq; y \\<in># queue_to_multiset bq;\n                 bq \\<noteq> []\\<rbrakk>\n                \\<Longrightarrow> \\<exists>t\\<in>set bq.\n                                     y \\<in># tree_to_multiset t;\n        queue_invar (a # bq); y \\<in># queue_to_multiset (a # bq);\n        a # bq \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t\\<in>set (a # bq).\n                            y \\<in># tree_to_multiset t", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a bq.\n       \\<lbrakk>\\<lbrakk>queue_invar bq; y \\<in># queue_to_multiset bq;\n                 bq \\<noteq> []\\<rbrakk>\n                \\<Longrightarrow> \\<exists>t\\<in>set bq.\n                                     y \\<in># tree_to_multiset t;\n        queue_invar (a # bq); y \\<in># queue_to_multiset (a # bq);\n        a # bq \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t\\<in>set (a # bq).\n                            y \\<in># tree_to_multiset t", "case (Cons a bq)"], ["proof (state)\nthis:\n  \\<lbrakk>queue_invar bq; y \\<in># queue_to_multiset bq;\n   bq \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> \\<exists>t\\<in>set bq. y \\<in># tree_to_multiset t\n  queue_invar (a # bq)\n  y \\<in># queue_to_multiset (a # bq)\n  a # bq \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>a bq.\n       \\<lbrakk>\\<lbrakk>queue_invar bq; y \\<in># queue_to_multiset bq;\n                 bq \\<noteq> []\\<rbrakk>\n                \\<Longrightarrow> \\<exists>t\\<in>set bq.\n                                     y \\<in># tree_to_multiset t;\n        queue_invar (a # bq); y \\<in># queue_to_multiset (a # bq);\n        a # bq \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t\\<in>set (a # bq).\n                            y \\<in># tree_to_multiset t", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>queue_invar bq; y \\<in># queue_to_multiset bq;\n   bq \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> \\<exists>t\\<in>set bq. y \\<in># tree_to_multiset t\n  queue_invar (a # bq)\n  y \\<in># queue_to_multiset (a # bq)\n  a # bq \\<noteq> []", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>queue_invar bq; y \\<in># queue_to_multiset bq;\n   bq \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> \\<exists>t\\<in>set bq. y \\<in># tree_to_multiset t\n  queue_invar (a # bq)\n  y \\<in># queue_to_multiset (a # bq)\n  a # bq \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<exists>t\\<in>set (a # bq). y \\<in># tree_to_multiset t", "apply (cases \"y \\<in> set_mset (tree_to_multiset a)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<lbrakk>queue_invar bq; y \\<in># queue_to_multiset bq;\n              bq \\<noteq> []\\<rbrakk>\n             \\<Longrightarrow> \\<exists>t\\<in>set bq.\n                                  y \\<in># tree_to_multiset t;\n     queue_invar (a # bq); y \\<in># queue_to_multiset (a # bq);\n     a # bq \\<noteq> []; y \\<in># tree_to_multiset a\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t\\<in>set (a # bq).\n                         y \\<in># tree_to_multiset t\n 2. \\<lbrakk>\\<lbrakk>queue_invar bq; y \\<in># queue_to_multiset bq;\n              bq \\<noteq> []\\<rbrakk>\n             \\<Longrightarrow> \\<exists>t\\<in>set bq.\n                                  y \\<in># tree_to_multiset t;\n     queue_invar (a # bq); y \\<in># queue_to_multiset (a # bq);\n     a # bq \\<noteq> []; y \\<notin># tree_to_multiset a\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t\\<in>set (a # bq).\n                         y \\<in># tree_to_multiset t", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>queue_invar bq; y \\<in># queue_to_multiset bq;\n              bq \\<noteq> []\\<rbrakk>\n             \\<Longrightarrow> \\<exists>t\\<in>set bq.\n                                  y \\<in># tree_to_multiset t;\n     queue_invar (a # bq); y \\<in># queue_to_multiset (a # bq);\n     a # bq \\<noteq> []; y \\<notin># tree_to_multiset a\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t\\<in>set (a # bq).\n                         y \\<in># tree_to_multiset t", "apply (cases bq)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<lbrakk>queue_invar bq; y \\<in># queue_to_multiset bq;\n              bq \\<noteq> []\\<rbrakk>\n             \\<Longrightarrow> \\<exists>t\\<in>set bq.\n                                  y \\<in># tree_to_multiset t;\n     queue_invar (a # bq); y \\<in># queue_to_multiset (a # bq);\n     a # bq \\<noteq> []; y \\<notin># tree_to_multiset a; bq = []\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t\\<in>set (a # bq).\n                         y \\<in># tree_to_multiset t\n 2. \\<And>aa list.\n       \\<lbrakk>\\<lbrakk>queue_invar bq; y \\<in># queue_to_multiset bq;\n                 bq \\<noteq> []\\<rbrakk>\n                \\<Longrightarrow> \\<exists>t\\<in>set bq.\n                                     y \\<in># tree_to_multiset t;\n        queue_invar (a # bq); y \\<in># queue_to_multiset (a # bq);\n        a # bq \\<noteq> []; y \\<notin># tree_to_multiset a;\n        bq = aa # list\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t\\<in>set (a # bq).\n                            y \\<in># tree_to_multiset t", "apply simp_all"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>t\\<in>set (a # bq). y \\<in># tree_to_multiset t\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>t\\<in>set bq. y \\<in># tree_to_multiset t\n\ngoal (1 subgoal):\n 1. prio (getMinTree bq) \\<le> snd y", "from this"], ["proof (chain)\npicking this:\n  \\<exists>t\\<in>set bq. y \\<in># tree_to_multiset t", "obtain t where O: \n    \"t \\<in> set bq\"\n    \"y \\<in> set_mset ((tree_to_multiset t))\""], ["proof (prove)\nusing this:\n  \\<exists>t\\<in>set bq. y \\<in># tree_to_multiset t\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        \\<lbrakk>t \\<in> set bq; y \\<in># tree_to_multiset t\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  t \\<in> set bq\n  y \\<in># tree_to_multiset t\n\ngoal (1 subgoal):\n 1. prio (getMinTree bq) \\<le> snd y", "obtain e a r ts where [simp]: \"t = (Node e a r ts)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>e a r ts.\n        t = Node e a r ts \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases t) blast"], ["proof (state)\nthis:\n  t = Node e a r ts\n\ngoal (1 subgoal):\n 1. prio (getMinTree bq) \\<le> snd y", "from O assms(1)"], ["proof (chain)\npicking this:\n  t \\<in> set bq\n  y \\<in># tree_to_multiset t\n  queue_invar bq", "have inv: \"tree_invar t\""], ["proof (prove)\nusing this:\n  t \\<in> set bq\n  y \\<in># tree_to_multiset t\n  queue_invar bq\n\ngoal (1 subgoal):\n 1. tree_invar t", "by simp"], ["proof (state)\nthis:\n  tree_invar t\n\ngoal (1 subgoal):\n 1. prio (getMinTree bq) \\<le> snd y", "from tree_invar_heap_ordered[OF inv] heap_ordered.simps[of e a r ts] O"], ["proof (chain)\npicking this:\n  heap_ordered t\n  heap_ordered (Node e a r ts) =\n  (\\<forall>x\\<in>#queue_to_multiset ts. a \\<le> snd x)\n  t \\<in> set bq\n  y \\<in># tree_to_multiset t", "have \"prio t \\<le> snd y\""], ["proof (prove)\nusing this:\n  heap_ordered t\n  heap_ordered (Node e a r ts) =\n  (\\<forall>x\\<in>#queue_to_multiset ts. a \\<le> snd x)\n  t \\<in> set bq\n  y \\<in># tree_to_multiset t\n\ngoal (1 subgoal):\n 1. prio t \\<le> snd y", "by auto"], ["proof (state)\nthis:\n  prio t \\<le> snd y\n\ngoal (1 subgoal):\n 1. prio (getMinTree bq) \\<le> snd y", "with getMinTree_min_tree[OF O(1)]"], ["proof (chain)\npicking this:\n  prio (getMinTree bq) \\<le> prio t\n  prio t \\<le> snd y", "show ?thesis"], ["proof (prove)\nusing this:\n  prio (getMinTree bq) \\<le> prio t\n  prio t \\<le> snd y\n\ngoal (1 subgoal):\n 1. prio (getMinTree bq) \\<le> snd y", "by simp"], ["proof (state)\nthis:\n  prio (getMinTree bq) \\<le> snd y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma findMin_mset:\n  assumes I: \"queue_invar q\"\n  assumes NE: \"q\\<noteq>Nil\"\n  shows \"findMin q \\<in># queue_to_multiset q\"\n  \"\\<forall>y\\<in>set_mset (queue_to_multiset q). snd (findMin q) \\<le> snd y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. findMin q \\<in># queue_to_multiset q &&&\n    \\<forall>y\\<in>#queue_to_multiset q. snd (findMin q) \\<le> snd y", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. findMin q \\<in># queue_to_multiset q\n 2. \\<forall>y\\<in>#queue_to_multiset q. snd (findMin q) \\<le> snd y", "from NE"], ["proof (chain)\npicking this:\n  q \\<noteq> []", "have \"getMinTree q \\<in> set q\""], ["proof (prove)\nusing this:\n  q \\<noteq> []\n\ngoal (1 subgoal):\n 1. getMinTree q \\<in> set q", "by (simp only: mintree_exists)"], ["proof (state)\nthis:\n  getMinTree q \\<in> set q\n\ngoal (2 subgoals):\n 1. findMin q \\<in># queue_to_multiset q\n 2. \\<forall>y\\<in>#queue_to_multiset q. snd (findMin q) \\<le> snd y", "thus \"findMin q \\<in># queue_to_multiset q\""], ["proof (prove)\nusing this:\n  getMinTree q \\<in> set q\n\ngoal (1 subgoal):\n 1. findMin q \\<in># queue_to_multiset q", "by (simp add: treehead_in_multiset findMin_def Let_def)"], ["proof (state)\nthis:\n  findMin q \\<in># queue_to_multiset q\n\ngoal (1 subgoal):\n 1. \\<forall>y\\<in>#queue_to_multiset q. snd (findMin q) \\<le> snd y", "show \"\\<forall>y\\<in>set_mset (queue_to_multiset q). snd (findMin q) \\<le> snd y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>y\\<in>#queue_to_multiset q. snd (findMin q) \\<le> snd y", "by (simp add: getMinTree_min_prio findMin_def Let_def NE I)"], ["proof (state)\nthis:\n  \\<forall>y\\<in>#queue_to_multiset q. snd (findMin q) \\<le> snd y\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem findMin_correct:\n  assumes I: \"invar q\"\n  assumes NE: \"q\\<noteq>Nil\"\n  shows \"findMin q \\<in># queue_to_multiset q\"\n  \"\\<forall>y\\<in>set_mset (queue_to_multiset q). snd (findMin q) \\<le> snd y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. findMin q \\<in># queue_to_multiset q &&&\n    \\<forall>y\\<in>#queue_to_multiset q. snd (findMin q) \\<le> snd y", "using I NE findMin_mset"], ["proof (prove)\nusing this:\n  invar q\n  q \\<noteq> []\n  \\<lbrakk>queue_invar ?q; ?q \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> findMin ?q \\<in># queue_to_multiset ?q\n  \\<lbrakk>queue_invar ?q; ?q \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> \\<forall>y\\<in>#queue_to_multiset ?q.\n                       snd (findMin ?q) \\<le> snd y\n\ngoal (1 subgoal):\n 1. findMin q \\<in># queue_to_multiset q &&&\n    \\<forall>y\\<in>#queue_to_multiset q. snd (findMin q) \\<le> snd y", "unfolding invar_def"], ["proof (prove)\nusing this:\n  queue_invar q \\<and> rank_skew_invar q\n  q \\<noteq> []\n  \\<lbrakk>queue_invar ?q; ?q \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> findMin ?q \\<in># queue_to_multiset ?q\n  \\<lbrakk>queue_invar ?q; ?q \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> \\<forall>y\\<in>#queue_to_multiset ?q.\n                       snd (findMin ?q) \\<le> snd y\n\ngoal (1 subgoal):\n 1. findMin q \\<in># queue_to_multiset q &&&\n    \\<forall>y\\<in>#queue_to_multiset q. snd (findMin q) \\<le> snd y", "by auto"], ["", "subsubsection \"Delete Minimal Element\""], ["", "text \\<open>Insert the roots of a given queue into an other queue.\\<close>"], ["", "fun insertList :: \n  \"('e, 'a::linorder) SkewBinomialQueue \\<Rightarrow> ('e, 'a) SkewBinomialQueue \\<Rightarrow> \n   ('e, 'a) SkewBinomialQueue\" where\n  \"insertList [] tbq = tbq\" |\n  \"insertList (t#bq) tbq = insertList bq (insert (val t) (prio t) tbq)\""], ["", "text \\<open>Remove the first tree, which has the priority $a$ within his root.\\<close>"], ["", "fun remove1Prio :: \"'a \\<Rightarrow> ('e, 'a::linorder) SkewBinomialQueue \\<Rightarrow>\n  ('e, 'a) SkewBinomialQueue\" where\n  \"remove1Prio a [] = []\" |\n  \"remove1Prio a (t#bq) = \n  (if (prio t) = a then bq else t # (remove1Prio a bq))\""], ["", "lemma remove1Prio_remove1[simp]: \n  \"remove1Prio (prio (getMinTree bq)) bq = remove1 (getMinTree bq) bq\""], ["proof (prove)\ngoal (1 subgoal):\n 1. remove1Prio (prio (getMinTree bq)) bq = remove1 (getMinTree bq) bq", "proof (induct bq)"], ["proof (state)\ngoal (2 subgoals):\n 1. remove1Prio (prio (getMinTree [])) [] = remove1 (getMinTree []) []\n 2. \\<And>a bq.\n       remove1Prio (prio (getMinTree bq)) bq =\n       remove1 (getMinTree bq) bq \\<Longrightarrow>\n       remove1Prio (prio (getMinTree (a # bq))) (a # bq) =\n       remove1 (getMinTree (a # bq)) (a # bq)", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. remove1Prio (prio (getMinTree [])) [] = remove1 (getMinTree []) []\n 2. \\<And>a bq.\n       remove1Prio (prio (getMinTree bq)) bq =\n       remove1 (getMinTree bq) bq \\<Longrightarrow>\n       remove1Prio (prio (getMinTree (a # bq))) (a # bq) =\n       remove1 (getMinTree (a # bq)) (a # bq)", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. remove1Prio (prio (getMinTree [])) [] = remove1 (getMinTree []) []", "by simp"], ["proof (state)\nthis:\n  remove1Prio (prio (getMinTree [])) [] = remove1 (getMinTree []) []\n\ngoal (1 subgoal):\n 1. \\<And>a bq.\n       remove1Prio (prio (getMinTree bq)) bq =\n       remove1 (getMinTree bq) bq \\<Longrightarrow>\n       remove1Prio (prio (getMinTree (a # bq))) (a # bq) =\n       remove1 (getMinTree (a # bq)) (a # bq)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a bq.\n       remove1Prio (prio (getMinTree bq)) bq =\n       remove1 (getMinTree bq) bq \\<Longrightarrow>\n       remove1Prio (prio (getMinTree (a # bq))) (a # bq) =\n       remove1 (getMinTree (a # bq)) (a # bq)", "case (Cons t bq)"], ["proof (state)\nthis:\n  remove1Prio (prio (getMinTree bq)) bq = remove1 (getMinTree bq) bq\n\ngoal (1 subgoal):\n 1. \\<And>a bq.\n       remove1Prio (prio (getMinTree bq)) bq =\n       remove1 (getMinTree bq) bq \\<Longrightarrow>\n       remove1Prio (prio (getMinTree (a # bq))) (a # bq) =\n       remove1 (getMinTree (a # bq)) (a # bq)", "note iv = Cons"], ["proof (state)\nthis:\n  remove1Prio (prio (getMinTree bq)) bq = remove1 (getMinTree bq) bq\n\ngoal (1 subgoal):\n 1. \\<And>a bq.\n       remove1Prio (prio (getMinTree bq)) bq =\n       remove1 (getMinTree bq) bq \\<Longrightarrow>\n       remove1Prio (prio (getMinTree (a # bq))) (a # bq) =\n       remove1 (getMinTree (a # bq)) (a # bq)", "thus ?case"], ["proof (prove)\nusing this:\n  remove1Prio (prio (getMinTree bq)) bq = remove1 (getMinTree bq) bq\n\ngoal (1 subgoal):\n 1. remove1Prio (prio (getMinTree (t # bq))) (t # bq) =\n    remove1 (getMinTree (t # bq)) (t # bq)", "proof (cases \"t = getMinTree (t # bq)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>remove1Prio (prio (getMinTree bq)) bq =\n             remove1 (getMinTree bq) bq;\n     t = getMinTree (t # bq)\\<rbrakk>\n    \\<Longrightarrow> remove1Prio (prio (getMinTree (t # bq))) (t # bq) =\n                      remove1 (getMinTree (t # bq)) (t # bq)\n 2. \\<lbrakk>remove1Prio (prio (getMinTree bq)) bq =\n             remove1 (getMinTree bq) bq;\n     t \\<noteq> getMinTree (t # bq)\\<rbrakk>\n    \\<Longrightarrow> remove1Prio (prio (getMinTree (t # bq))) (t # bq) =\n                      remove1 (getMinTree (t # bq)) (t # bq)", "case True"], ["proof (state)\nthis:\n  t = getMinTree (t # bq)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>remove1Prio (prio (getMinTree bq)) bq =\n             remove1 (getMinTree bq) bq;\n     t = getMinTree (t # bq)\\<rbrakk>\n    \\<Longrightarrow> remove1Prio (prio (getMinTree (t # bq))) (t # bq) =\n                      remove1 (getMinTree (t # bq)) (t # bq)\n 2. \\<lbrakk>remove1Prio (prio (getMinTree bq)) bq =\n             remove1 (getMinTree bq) bq;\n     t \\<noteq> getMinTree (t # bq)\\<rbrakk>\n    \\<Longrightarrow> remove1Prio (prio (getMinTree (t # bq))) (t # bq) =\n                      remove1 (getMinTree (t # bq)) (t # bq)", "with iv"], ["proof (chain)\npicking this:\n  remove1Prio (prio (getMinTree bq)) bq = remove1 (getMinTree bq) bq\n  t = getMinTree (t # bq)", "show ?thesis"], ["proof (prove)\nusing this:\n  remove1Prio (prio (getMinTree bq)) bq = remove1 (getMinTree bq) bq\n  t = getMinTree (t # bq)\n\ngoal (1 subgoal):\n 1. remove1Prio (prio (getMinTree (t # bq))) (t # bq) =\n    remove1 (getMinTree (t # bq)) (t # bq)", "by simp"], ["proof (state)\nthis:\n  remove1Prio (prio (getMinTree (t # bq))) (t # bq) =\n  remove1 (getMinTree (t # bq)) (t # bq)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>remove1Prio (prio (getMinTree bq)) bq =\n             remove1 (getMinTree bq) bq;\n     t \\<noteq> getMinTree (t # bq)\\<rbrakk>\n    \\<Longrightarrow> remove1Prio (prio (getMinTree (t # bq))) (t # bq) =\n                      remove1 (getMinTree (t # bq)) (t # bq)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>remove1Prio (prio (getMinTree bq)) bq =\n             remove1 (getMinTree bq) bq;\n     t \\<noteq> getMinTree (t # bq)\\<rbrakk>\n    \\<Longrightarrow> remove1Prio (prio (getMinTree (t # bq))) (t # bq) =\n                      remove1 (getMinTree (t # bq)) (t # bq)", "case False"], ["proof (state)\nthis:\n  t \\<noteq> getMinTree (t # bq)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>remove1Prio (prio (getMinTree bq)) bq =\n             remove1 (getMinTree bq) bq;\n     t \\<noteq> getMinTree (t # bq)\\<rbrakk>\n    \\<Longrightarrow> remove1Prio (prio (getMinTree (t # bq))) (t # bq) =\n                      remove1 (getMinTree (t # bq)) (t # bq)", "hence ne: \"bq \\<noteq> []\""], ["proof (prove)\nusing this:\n  t \\<noteq> getMinTree (t # bq)\n\ngoal (1 subgoal):\n 1. bq \\<noteq> []", "by auto"], ["proof (state)\nthis:\n  bq \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<lbrakk>remove1Prio (prio (getMinTree bq)) bq =\n             remove1 (getMinTree bq) bq;\n     t \\<noteq> getMinTree (t # bq)\\<rbrakk>\n    \\<Longrightarrow> remove1Prio (prio (getMinTree (t # bq))) (t # bq) =\n                      remove1 (getMinTree (t # bq)) (t # bq)", "with False"], ["proof (chain)\npicking this:\n  t \\<noteq> getMinTree (t # bq)\n  bq \\<noteq> []", "have down: \"getMinTree (t # bq) = getMinTree bq\""], ["proof (prove)\nusing this:\n  t \\<noteq> getMinTree (t # bq)\n  bq \\<noteq> []\n\ngoal (1 subgoal):\n 1. getMinTree (t # bq) = getMinTree bq", "by (induct bq rule: getMinTree.induct) auto"], ["proof (state)\nthis:\n  getMinTree (t # bq) = getMinTree bq\n\ngoal (1 subgoal):\n 1. \\<lbrakk>remove1Prio (prio (getMinTree bq)) bq =\n             remove1 (getMinTree bq) bq;\n     t \\<noteq> getMinTree (t # bq)\\<rbrakk>\n    \\<Longrightarrow> remove1Prio (prio (getMinTree (t # bq))) (t # bq) =\n                      remove1 (getMinTree (t # bq)) (t # bq)", "from ne False"], ["proof (chain)\npicking this:\n  bq \\<noteq> []\n  t \\<noteq> getMinTree (t # bq)", "have \"prio t \\<noteq> prio (getMinTree bq)\""], ["proof (prove)\nusing this:\n  bq \\<noteq> []\n  t \\<noteq> getMinTree (t # bq)\n\ngoal (1 subgoal):\n 1. prio t \\<noteq> prio (getMinTree bq)", "by (induct bq rule: getMinTree.induct) auto"], ["proof (state)\nthis:\n  prio t \\<noteq> prio (getMinTree bq)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>remove1Prio (prio (getMinTree bq)) bq =\n             remove1 (getMinTree bq) bq;\n     t \\<noteq> getMinTree (t # bq)\\<rbrakk>\n    \\<Longrightarrow> remove1Prio (prio (getMinTree (t # bq))) (t # bq) =\n                      remove1 (getMinTree (t # bq)) (t # bq)", "with down iv False ne"], ["proof (chain)\npicking this:\n  getMinTree (t # bq) = getMinTree bq\n  remove1Prio (prio (getMinTree bq)) bq = remove1 (getMinTree bq) bq\n  t \\<noteq> getMinTree (t # bq)\n  bq \\<noteq> []\n  prio t \\<noteq> prio (getMinTree bq)", "show ?thesis"], ["proof (prove)\nusing this:\n  getMinTree (t # bq) = getMinTree bq\n  remove1Prio (prio (getMinTree bq)) bq = remove1 (getMinTree bq) bq\n  t \\<noteq> getMinTree (t # bq)\n  bq \\<noteq> []\n  prio t \\<noteq> prio (getMinTree bq)\n\ngoal (1 subgoal):\n 1. remove1Prio (prio (getMinTree (t # bq))) (t # bq) =\n    remove1 (getMinTree (t # bq)) (t # bq)", "by simp"], ["proof (state)\nthis:\n  remove1Prio (prio (getMinTree (t # bq))) (t # bq) =\n  remove1 (getMinTree (t # bq)) (t # bq)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  remove1Prio (prio (getMinTree (t # bq))) (t # bq) =\n  remove1 (getMinTree (t # bq)) (t # bq)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Return the queue without the minimal element found by findMin\\<close>"], ["", "definition deleteMin :: \"('e, 'a::linorder) SkewBinomialQueue \\<Rightarrow> \n  ('e, 'a) SkewBinomialQueue\" where\n  \"deleteMin bq = (let min = getMinTree bq in insertList\n    (filter (\\<lambda> t. rank t = 0) (children min))\n    (meld (rev (filter (\\<lambda> t. rank t > 0) (children min))) \n     (remove1Prio (prio min) bq)))\""], ["", "lemma invar_rev[simp]: \"queue_invar (rev q) \\<longleftrightarrow> queue_invar q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. queue_invar (rev q) = queue_invar q", "by (unfold queue_invar_def) simp"], ["", "lemma invar_remove1: \"queue_invar q \\<Longrightarrow> queue_invar (remove1 t q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. queue_invar q \\<Longrightarrow> queue_invar (remove1 t q)", "by (unfold queue_invar_def) (auto)"], ["", "lemma mset_rev: \"queue_to_multiset (rev q) = queue_to_multiset q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. queue_to_multiset (rev q) = queue_to_multiset q", "by (induct q) (auto simp add: union_ac)"], ["", "lemma in_set_subset: \"t \\<in> set q \\<Longrightarrow> tree_to_multiset t \\<subseteq># queue_to_multiset q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<in> set q \\<Longrightarrow>\n    tree_to_multiset t \\<subseteq># queue_to_multiset q", "proof (induct q)"], ["proof (state)\ngoal (2 subgoals):\n 1. t \\<in> set [] \\<Longrightarrow>\n    tree_to_multiset t \\<subseteq># queue_to_multiset []\n 2. \\<And>a q.\n       \\<lbrakk>t \\<in> set q \\<Longrightarrow>\n                tree_to_multiset t \\<subseteq># queue_to_multiset q;\n        t \\<in> set (a # q)\\<rbrakk>\n       \\<Longrightarrow> tree_to_multiset t \\<subseteq>#\n                         queue_to_multiset (a # q)", "case Nil"], ["proof (state)\nthis:\n  t \\<in> set []\n\ngoal (2 subgoals):\n 1. t \\<in> set [] \\<Longrightarrow>\n    tree_to_multiset t \\<subseteq># queue_to_multiset []\n 2. \\<And>a q.\n       \\<lbrakk>t \\<in> set q \\<Longrightarrow>\n                tree_to_multiset t \\<subseteq># queue_to_multiset q;\n        t \\<in> set (a # q)\\<rbrakk>\n       \\<Longrightarrow> tree_to_multiset t \\<subseteq>#\n                         queue_to_multiset (a # q)", "then"], ["proof (chain)\npicking this:\n  t \\<in> set []", "show ?case"], ["proof (prove)\nusing this:\n  t \\<in> set []\n\ngoal (1 subgoal):\n 1. tree_to_multiset t \\<subseteq># queue_to_multiset []", "by simp"], ["proof (state)\nthis:\n  tree_to_multiset t \\<subseteq># queue_to_multiset []\n\ngoal (1 subgoal):\n 1. \\<And>a q.\n       \\<lbrakk>t \\<in> set q \\<Longrightarrow>\n                tree_to_multiset t \\<subseteq># queue_to_multiset q;\n        t \\<in> set (a # q)\\<rbrakk>\n       \\<Longrightarrow> tree_to_multiset t \\<subseteq>#\n                         queue_to_multiset (a # q)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a q.\n       \\<lbrakk>t \\<in> set q \\<Longrightarrow>\n                tree_to_multiset t \\<subseteq># queue_to_multiset q;\n        t \\<in> set (a # q)\\<rbrakk>\n       \\<Longrightarrow> tree_to_multiset t \\<subseteq>#\n                         queue_to_multiset (a # q)", "case (Cons a q)"], ["proof (state)\nthis:\n  t \\<in> set q \\<Longrightarrow>\n  tree_to_multiset t \\<subseteq># queue_to_multiset q\n  t \\<in> set (a # q)\n\ngoal (1 subgoal):\n 1. \\<And>a q.\n       \\<lbrakk>t \\<in> set q \\<Longrightarrow>\n                tree_to_multiset t \\<subseteq># queue_to_multiset q;\n        t \\<in> set (a # q)\\<rbrakk>\n       \\<Longrightarrow> tree_to_multiset t \\<subseteq>#\n                         queue_to_multiset (a # q)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. tree_to_multiset t \\<subseteq># queue_to_multiset (a # q)", "proof (cases \"t = a\")"], ["proof (state)\ngoal (2 subgoals):\n 1. t = a \\<Longrightarrow>\n    tree_to_multiset t \\<subseteq># queue_to_multiset (a # q)\n 2. t \\<noteq> a \\<Longrightarrow>\n    tree_to_multiset t \\<subseteq># queue_to_multiset (a # q)", "case True"], ["proof (state)\nthis:\n  t = a\n\ngoal (2 subgoals):\n 1. t = a \\<Longrightarrow>\n    tree_to_multiset t \\<subseteq># queue_to_multiset (a # q)\n 2. t \\<noteq> a \\<Longrightarrow>\n    tree_to_multiset t \\<subseteq># queue_to_multiset (a # q)", "then"], ["proof (chain)\npicking this:\n  t = a", "show ?thesis"], ["proof (prove)\nusing this:\n  t = a\n\ngoal (1 subgoal):\n 1. tree_to_multiset t \\<subseteq># queue_to_multiset (a # q)", "by simp"], ["proof (state)\nthis:\n  tree_to_multiset t \\<subseteq># queue_to_multiset (a # q)\n\ngoal (1 subgoal):\n 1. t \\<noteq> a \\<Longrightarrow>\n    tree_to_multiset t \\<subseteq># queue_to_multiset (a # q)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. t \\<noteq> a \\<Longrightarrow>\n    tree_to_multiset t \\<subseteq># queue_to_multiset (a # q)", "case False"], ["proof (state)\nthis:\n  t \\<noteq> a\n\ngoal (1 subgoal):\n 1. t \\<noteq> a \\<Longrightarrow>\n    tree_to_multiset t \\<subseteq># queue_to_multiset (a # q)", "with Cons"], ["proof (chain)\npicking this:\n  t \\<in> set q \\<Longrightarrow>\n  tree_to_multiset t \\<subseteq># queue_to_multiset q\n  t \\<in> set (a # q)\n  t \\<noteq> a", "have t_in_q: \"t \\<in> set q\""], ["proof (prove)\nusing this:\n  t \\<in> set q \\<Longrightarrow>\n  tree_to_multiset t \\<subseteq># queue_to_multiset q\n  t \\<in> set (a # q)\n  t \\<noteq> a\n\ngoal (1 subgoal):\n 1. t \\<in> set q", "by simp"], ["proof (state)\nthis:\n  t \\<in> set q\n\ngoal (1 subgoal):\n 1. t \\<noteq> a \\<Longrightarrow>\n    tree_to_multiset t \\<subseteq># queue_to_multiset (a # q)", "have \"queue_to_multiset q \\<subseteq># queue_to_multiset (a # q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. queue_to_multiset q \\<subseteq># queue_to_multiset (a # q)", "by simp"], ["proof (state)\nthis:\n  queue_to_multiset q \\<subseteq># queue_to_multiset (a # q)\n\ngoal (1 subgoal):\n 1. t \\<noteq> a \\<Longrightarrow>\n    tree_to_multiset t \\<subseteq># queue_to_multiset (a # q)", "from subset_mset.order_trans[OF Cons(1)[OF t_in_q] this]"], ["proof (chain)\npicking this:\n  tree_to_multiset t \\<subseteq># queue_to_multiset (a # q)", "show ?thesis"], ["proof (prove)\nusing this:\n  tree_to_multiset t \\<subseteq># queue_to_multiset (a # q)\n\ngoal (1 subgoal):\n 1. tree_to_multiset t \\<subseteq># queue_to_multiset (a # q)", "."], ["proof (state)\nthis:\n  tree_to_multiset t \\<subseteq># queue_to_multiset (a # q)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  tree_to_multiset t \\<subseteq># queue_to_multiset (a # q)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mset_remove1: \"t \\<in> set q \\<Longrightarrow> \n  queue_to_multiset (remove1 t q) = \n  queue_to_multiset q - tree_to_multiset t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<in> set q \\<Longrightarrow>\n    queue_to_multiset (remove1 t q) =\n    queue_to_multiset q - tree_to_multiset t", "by (induct q) (auto simp: in_set_subset)"], ["", "lemma invar_children':\n  assumes \"tree_invar t\"\n  shows \"queue_invar (children t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. queue_invar (children t)", "proof (cases t)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x3 x4.\n       t = Node x1 x2 x3 x4 \\<Longrightarrow> queue_invar (children t)", "case (Node e a nat list)"], ["proof (state)\nthis:\n  t = Node e a nat list\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x3 x4.\n       t = Node x1 x2 x3 x4 \\<Longrightarrow> queue_invar (children t)", "with assms"], ["proof (chain)\npicking this:\n  tree_invar t\n  t = Node e a nat list", "have inv: \"tree_invar (Node e a nat list)\""], ["proof (prove)\nusing this:\n  tree_invar t\n  t = Node e a nat list\n\ngoal (1 subgoal):\n 1. tree_invar (Node e a nat list)", "by simp"], ["proof (state)\nthis:\n  tree_invar (Node e a nat list)\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x3 x4.\n       t = Node x1 x2 x3 x4 \\<Longrightarrow> queue_invar (children t)", "from Node invar_children[OF inv]"], ["proof (chain)\npicking this:\n  t = Node e a nat list\n  queue_invar list", "show ?thesis"], ["proof (prove)\nusing this:\n  t = Node e a nat list\n  queue_invar list\n\ngoal (1 subgoal):\n 1. queue_invar (children t)", "by simp"], ["proof (state)\nthis:\n  queue_invar (children t)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma invar_filter: \"queue_invar q \\<Longrightarrow> queue_invar (filter f q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. queue_invar q \\<Longrightarrow> queue_invar (filter f q)", "by (unfold queue_invar_def) simp"], ["", "lemma insertList_queue_invar: \"queue_invar q \\<Longrightarrow> queue_invar (insertList ts q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. queue_invar q \\<Longrightarrow> queue_invar (insertList ts q)", "proof (induct ts arbitrary: q)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>q. queue_invar q \\<Longrightarrow> queue_invar (insertList [] q)\n 2. \\<And>a ts q.\n       \\<lbrakk>\\<And>q.\n                   queue_invar q \\<Longrightarrow>\n                   queue_invar (insertList ts q);\n        queue_invar q\\<rbrakk>\n       \\<Longrightarrow> queue_invar (insertList (a # ts) q)", "case Nil"], ["proof (state)\nthis:\n  queue_invar q\n\ngoal (2 subgoals):\n 1. \\<And>q. queue_invar q \\<Longrightarrow> queue_invar (insertList [] q)\n 2. \\<And>a ts q.\n       \\<lbrakk>\\<And>q.\n                   queue_invar q \\<Longrightarrow>\n                   queue_invar (insertList ts q);\n        queue_invar q\\<rbrakk>\n       \\<Longrightarrow> queue_invar (insertList (a # ts) q)", "then"], ["proof (chain)\npicking this:\n  queue_invar q", "show ?case"], ["proof (prove)\nusing this:\n  queue_invar q\n\ngoal (1 subgoal):\n 1. queue_invar (insertList [] q)", "by simp"], ["proof (state)\nthis:\n  queue_invar (insertList [] q)\n\ngoal (1 subgoal):\n 1. \\<And>a ts q.\n       \\<lbrakk>\\<And>q.\n                   queue_invar q \\<Longrightarrow>\n                   queue_invar (insertList ts q);\n        queue_invar q\\<rbrakk>\n       \\<Longrightarrow> queue_invar (insertList (a # ts) q)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a ts q.\n       \\<lbrakk>\\<And>q.\n                   queue_invar q \\<Longrightarrow>\n                   queue_invar (insertList ts q);\n        queue_invar q\\<rbrakk>\n       \\<Longrightarrow> queue_invar (insertList (a # ts) q)", "case (Cons a q)"], ["proof (state)\nthis:\n  queue_invar ?q \\<Longrightarrow> queue_invar (insertList qa__ ?q)\n  queue_invar q\n\ngoal (1 subgoal):\n 1. \\<And>a ts q.\n       \\<lbrakk>\\<And>q.\n                   queue_invar q \\<Longrightarrow>\n                   queue_invar (insertList ts q);\n        queue_invar q\\<rbrakk>\n       \\<Longrightarrow> queue_invar (insertList (a # ts) q)", "note inv_insert = insert_queue_invar[OF Cons(2), of \"val a\" \"prio a\"]"], ["proof (state)\nthis:\n  queue_invar (local.insert (val a) (prio a) q)\n\ngoal (1 subgoal):\n 1. \\<And>a ts q.\n       \\<lbrakk>\\<And>q.\n                   queue_invar q \\<Longrightarrow>\n                   queue_invar (insertList ts q);\n        queue_invar q\\<rbrakk>\n       \\<Longrightarrow> queue_invar (insertList (a # ts) q)", "from Cons(1)[OF inv_insert]"], ["proof (chain)\npicking this:\n  queue_invar (insertList qa__ (local.insert (val a) (prio a) q))", "show ?case"], ["proof (prove)\nusing this:\n  queue_invar (insertList qa__ (local.insert (val a) (prio a) q))\n\ngoal (1 subgoal):\n 1. queue_invar (insertList (a # qa__) q)", "by simp"], ["proof (state)\nthis:\n  queue_invar (insertList (a # qa__) q)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma deleteMin_queue_invar: \n  \"\\<lbrakk>queue_invar q; queue_to_multiset q \\<noteq> {#}\\<rbrakk> \\<Longrightarrow> \n  queue_invar (deleteMin q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>queue_invar q; queue_to_multiset q \\<noteq> {#}\\<rbrakk>\n    \\<Longrightarrow> queue_invar (deleteMin q)", "unfolding deleteMin_def Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>queue_invar q; queue_to_multiset q \\<noteq> {#}\\<rbrakk>\n    \\<Longrightarrow> queue_invar\n                       (insertList\n                         (filter (\\<lambda>t. rank t = 0)\n                           (children (getMinTree q)))\n                         (meld\n                           (rev (filter (\\<lambda>t. 0 < rank t)\n                                  (children (getMinTree q))))\n                           (remove1Prio (prio (getMinTree q)) q)))", "proof goal_cases"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>queue_invar q; queue_to_multiset q \\<noteq> {#}\\<rbrakk>\n    \\<Longrightarrow> queue_invar\n                       (insertList\n                         (filter (\\<lambda>t. rank t = 0)\n                           (children (getMinTree q)))\n                         (meld\n                           (rev (filter (\\<lambda>t. 0 < rank t)\n                                  (children (getMinTree q))))\n                           (remove1Prio (prio (getMinTree q)) q)))", "case prems: 1"], ["proof (state)\nthis:\n  queue_invar q\n  queue_to_multiset q \\<noteq> {#}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>queue_invar q; queue_to_multiset q \\<noteq> {#}\\<rbrakk>\n    \\<Longrightarrow> queue_invar\n                       (insertList\n                         (filter (\\<lambda>t. rank t = 0)\n                           (children (getMinTree q)))\n                         (meld\n                           (rev (filter (\\<lambda>t. 0 < rank t)\n                                  (children (getMinTree q))))\n                           (remove1Prio (prio (getMinTree q)) q)))", "from prems(2)"], ["proof (chain)\npicking this:\n  queue_to_multiset q \\<noteq> {#}", "have q_ne: \"q \\<noteq> []\""], ["proof (prove)\nusing this:\n  queue_to_multiset q \\<noteq> {#}\n\ngoal (1 subgoal):\n 1. q \\<noteq> []", "by auto"], ["proof (state)\nthis:\n  q \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<lbrakk>queue_invar q; queue_to_multiset q \\<noteq> {#}\\<rbrakk>\n    \\<Longrightarrow> queue_invar\n                       (insertList\n                         (filter (\\<lambda>t. rank t = 0)\n                           (children (getMinTree q)))\n                         (meld\n                           (rev (filter (\\<lambda>t. 0 < rank t)\n                                  (children (getMinTree q))))\n                           (remove1Prio (prio (getMinTree q)) q)))", "with prems(1) mintree_exists[of q]"], ["proof (chain)\npicking this:\n  queue_invar q\n  (q \\<noteq> []) = (getMinTree q \\<in> set q)\n  q \\<noteq> []", "have inv_min: \"tree_invar (getMinTree q)\""], ["proof (prove)\nusing this:\n  queue_invar q\n  (q \\<noteq> []) = (getMinTree q \\<in> set q)\n  q \\<noteq> []\n\ngoal (1 subgoal):\n 1. tree_invar (getMinTree q)", "by simp"], ["proof (state)\nthis:\n  tree_invar (getMinTree q)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>queue_invar q; queue_to_multiset q \\<noteq> {#}\\<rbrakk>\n    \\<Longrightarrow> queue_invar\n                       (insertList\n                         (filter (\\<lambda>t. rank t = 0)\n                           (children (getMinTree q)))\n                         (meld\n                           (rev (filter (\\<lambda>t. 0 < rank t)\n                                  (children (getMinTree q))))\n                           (remove1Prio (prio (getMinTree q)) q)))", "note inv_rem = invar_remove1[OF prems(1), of \"getMinTree q\"]"], ["proof (state)\nthis:\n  queue_invar (remove1 (getMinTree q) q)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>queue_invar q; queue_to_multiset q \\<noteq> {#}\\<rbrakk>\n    \\<Longrightarrow> queue_invar\n                       (insertList\n                         (filter (\\<lambda>t. rank t = 0)\n                           (children (getMinTree q)))\n                         (meld\n                           (rev (filter (\\<lambda>t. 0 < rank t)\n                                  (children (getMinTree q))))\n                           (remove1Prio (prio (getMinTree q)) q)))", "note inv_children = invar_children'[OF inv_min]"], ["proof (state)\nthis:\n  queue_invar (children (getMinTree q))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>queue_invar q; queue_to_multiset q \\<noteq> {#}\\<rbrakk>\n    \\<Longrightarrow> queue_invar\n                       (insertList\n                         (filter (\\<lambda>t. rank t = 0)\n                           (children (getMinTree q)))\n                         (meld\n                           (rev (filter (\\<lambda>t. 0 < rank t)\n                                  (children (getMinTree q))))\n                           (remove1Prio (prio (getMinTree q)) q)))", "note inv_filter = invar_filter[OF inv_children, of \"\\<lambda>t. 0 < rank t\"]"], ["proof (state)\nthis:\n  queue_invar (filter (\\<lambda>t. 0 < rank t) (children (getMinTree q)))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>queue_invar q; queue_to_multiset q \\<noteq> {#}\\<rbrakk>\n    \\<Longrightarrow> queue_invar\n                       (insertList\n                         (filter (\\<lambda>t. rank t = 0)\n                           (children (getMinTree q)))\n                         (meld\n                           (rev (filter (\\<lambda>t. 0 < rank t)\n                                  (children (getMinTree q))))\n                           (remove1Prio (prio (getMinTree q)) q)))", "note inv_rev = iffD2[OF invar_rev inv_filter]"], ["proof (state)\nthis:\n  queue_invar\n   (rev (filter (\\<lambda>t. 0 < rank t) (children (getMinTree q))))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>queue_invar q; queue_to_multiset q \\<noteq> {#}\\<rbrakk>\n    \\<Longrightarrow> queue_invar\n                       (insertList\n                         (filter (\\<lambda>t. rank t = 0)\n                           (children (getMinTree q)))\n                         (meld\n                           (rev (filter (\\<lambda>t. 0 < rank t)\n                                  (children (getMinTree q))))\n                           (remove1Prio (prio (getMinTree q)) q)))", "note inv_meld = meld_queue_invar[OF inv_rev inv_rem]"], ["proof (state)\nthis:\n  queue_invar\n   (meld (rev (filter (\\<lambda>t. 0 < rank t) (children (getMinTree q))))\n     (remove1 (getMinTree q) q))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>queue_invar q; queue_to_multiset q \\<noteq> {#}\\<rbrakk>\n    \\<Longrightarrow> queue_invar\n                       (insertList\n                         (filter (\\<lambda>t. rank t = 0)\n                           (children (getMinTree q)))\n                         (meld\n                           (rev (filter (\\<lambda>t. 0 < rank t)\n                                  (children (getMinTree q))))\n                           (remove1Prio (prio (getMinTree q)) q)))", "note inv_ins = \n    insertList_queue_invar[OF inv_meld, \n      of \"[t\\<leftarrow>children (getMinTree q). rank t = 0]\"]"], ["proof (state)\nthis:\n  queue_invar\n   (insertList (filter (\\<lambda>t. rank t = 0) (children (getMinTree q)))\n     (meld (rev (filter (\\<lambda>t. 0 < rank t) (children (getMinTree q))))\n       (remove1 (getMinTree q) q)))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>queue_invar q; queue_to_multiset q \\<noteq> {#}\\<rbrakk>\n    \\<Longrightarrow> queue_invar\n                       (insertList\n                         (filter (\\<lambda>t. rank t = 0)\n                           (children (getMinTree q)))\n                         (meld\n                           (rev (filter (\\<lambda>t. 0 < rank t)\n                                  (children (getMinTree q))))\n                           (remove1Prio (prio (getMinTree q)) q)))", "then"], ["proof (chain)\npicking this:\n  queue_invar\n   (insertList (filter (\\<lambda>t. rank t = 0) (children (getMinTree q)))\n     (meld (rev (filter (\\<lambda>t. 0 < rank t) (children (getMinTree q))))\n       (remove1 (getMinTree q) q)))", "show ?case"], ["proof (prove)\nusing this:\n  queue_invar\n   (insertList (filter (\\<lambda>t. rank t = 0) (children (getMinTree q)))\n     (meld (rev (filter (\\<lambda>t. 0 < rank t) (children (getMinTree q))))\n       (remove1 (getMinTree q) q)))\n\ngoal (1 subgoal):\n 1. queue_invar\n     (insertList (filter (\\<lambda>t. rank t = 0) (children (getMinTree q)))\n       (meld\n         (rev (filter (\\<lambda>t. 0 < rank t) (children (getMinTree q))))\n         (remove1Prio (prio (getMinTree q)) q)))", "by simp"], ["proof (state)\nthis:\n  queue_invar\n   (insertList (filter (\\<lambda>t. rank t = 0) (children (getMinTree q)))\n     (meld (rev (filter (\\<lambda>t. 0 < rank t) (children (getMinTree q))))\n       (remove1Prio (prio (getMinTree q)) q)))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mset_children: \"queue_to_multiset (children t) = \n  tree_to_multiset t - {# (val t, prio t) #}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. queue_to_multiset (children t) =\n    tree_to_multiset t - {#(val t, prio t)#}", "by(cases t, auto)"], ["", "lemma mset_insertList: \n  \"\\<lbrakk>\\<forall>t \\<in> set ts. rank t = 0 \\<and> children t = [] ; queue_invar q\\<rbrakk> \\<Longrightarrow> \n  queue_to_multiset (insertList ts q) = \n  queue_to_multiset ts + queue_to_multiset q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>t\\<in>set ts. rank t = 0 \\<and> children t = [];\n     queue_invar q\\<rbrakk>\n    \\<Longrightarrow> queue_to_multiset (insertList ts q) =\n                      queue_to_multiset ts + queue_to_multiset q", "proof (induct ts arbitrary: q)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>q.\n       \\<lbrakk>\\<forall>t\\<in>set []. rank t = 0 \\<and> children t = [];\n        queue_invar q\\<rbrakk>\n       \\<Longrightarrow> queue_to_multiset (insertList [] q) =\n                         queue_to_multiset [] + queue_to_multiset q\n 2. \\<And>a ts q.\n       \\<lbrakk>\\<And>q.\n                   \\<lbrakk>\\<forall>t\\<in>set ts.\n                               rank t = 0 \\<and> children t = [];\n                    queue_invar q\\<rbrakk>\n                   \\<Longrightarrow> queue_to_multiset (insertList ts q) =\n                                     queue_to_multiset ts +\n                                     queue_to_multiset q;\n        \\<forall>t\\<in>set (a # ts). rank t = 0 \\<and> children t = [];\n        queue_invar q\\<rbrakk>\n       \\<Longrightarrow> queue_to_multiset (insertList (a # ts) q) =\n                         queue_to_multiset (a # ts) + queue_to_multiset q", "case Nil"], ["proof (state)\nthis:\n  \\<forall>t\\<in>set []. rank t = 0 \\<and> children t = []\n  queue_invar q\n\ngoal (2 subgoals):\n 1. \\<And>q.\n       \\<lbrakk>\\<forall>t\\<in>set []. rank t = 0 \\<and> children t = [];\n        queue_invar q\\<rbrakk>\n       \\<Longrightarrow> queue_to_multiset (insertList [] q) =\n                         queue_to_multiset [] + queue_to_multiset q\n 2. \\<And>a ts q.\n       \\<lbrakk>\\<And>q.\n                   \\<lbrakk>\\<forall>t\\<in>set ts.\n                               rank t = 0 \\<and> children t = [];\n                    queue_invar q\\<rbrakk>\n                   \\<Longrightarrow> queue_to_multiset (insertList ts q) =\n                                     queue_to_multiset ts +\n                                     queue_to_multiset q;\n        \\<forall>t\\<in>set (a # ts). rank t = 0 \\<and> children t = [];\n        queue_invar q\\<rbrakk>\n       \\<Longrightarrow> queue_to_multiset (insertList (a # ts) q) =\n                         queue_to_multiset (a # ts) + queue_to_multiset q", "then"], ["proof (chain)\npicking this:\n  \\<forall>t\\<in>set []. rank t = 0 \\<and> children t = []\n  queue_invar q", "show ?case"], ["proof (prove)\nusing this:\n  \\<forall>t\\<in>set []. rank t = 0 \\<and> children t = []\n  queue_invar q\n\ngoal (1 subgoal):\n 1. queue_to_multiset (insertList [] q) =\n    queue_to_multiset [] + queue_to_multiset q", "by simp"], ["proof (state)\nthis:\n  queue_to_multiset (insertList [] q) =\n  queue_to_multiset [] + queue_to_multiset q\n\ngoal (1 subgoal):\n 1. \\<And>a ts q.\n       \\<lbrakk>\\<And>q.\n                   \\<lbrakk>\\<forall>t\\<in>set ts.\n                               rank t = 0 \\<and> children t = [];\n                    queue_invar q\\<rbrakk>\n                   \\<Longrightarrow> queue_to_multiset (insertList ts q) =\n                                     queue_to_multiset ts +\n                                     queue_to_multiset q;\n        \\<forall>t\\<in>set (a # ts). rank t = 0 \\<and> children t = [];\n        queue_invar q\\<rbrakk>\n       \\<Longrightarrow> queue_to_multiset (insertList (a # ts) q) =\n                         queue_to_multiset (a # ts) + queue_to_multiset q", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a ts q.\n       \\<lbrakk>\\<And>q.\n                   \\<lbrakk>\\<forall>t\\<in>set ts.\n                               rank t = 0 \\<and> children t = [];\n                    queue_invar q\\<rbrakk>\n                   \\<Longrightarrow> queue_to_multiset (insertList ts q) =\n                                     queue_to_multiset ts +\n                                     queue_to_multiset q;\n        \\<forall>t\\<in>set (a # ts). rank t = 0 \\<and> children t = [];\n        queue_invar q\\<rbrakk>\n       \\<Longrightarrow> queue_to_multiset (insertList (a # ts) q) =\n                         queue_to_multiset (a # ts) + queue_to_multiset q", "case (Cons a ts)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<forall>t\\<in>set ts. rank t = 0 \\<and> children t = [];\n   queue_invar ?q\\<rbrakk>\n  \\<Longrightarrow> queue_to_multiset (insertList ts ?q) =\n                    queue_to_multiset ts + queue_to_multiset ?q\n  \\<forall>t\\<in>set (a # ts). rank t = 0 \\<and> children t = []\n  queue_invar q\n\ngoal (1 subgoal):\n 1. \\<And>a ts q.\n       \\<lbrakk>\\<And>q.\n                   \\<lbrakk>\\<forall>t\\<in>set ts.\n                               rank t = 0 \\<and> children t = [];\n                    queue_invar q\\<rbrakk>\n                   \\<Longrightarrow> queue_to_multiset (insertList ts q) =\n                                     queue_to_multiset ts +\n                                     queue_to_multiset q;\n        \\<forall>t\\<in>set (a # ts). rank t = 0 \\<and> children t = [];\n        queue_invar q\\<rbrakk>\n       \\<Longrightarrow> queue_to_multiset (insertList (a # ts) q) =\n                         queue_to_multiset (a # ts) + queue_to_multiset q", "from Cons(2)"], ["proof (chain)\npicking this:\n  \\<forall>t\\<in>set (a # ts). rank t = 0 \\<and> children t = []", "have ball_ts: \"\\<forall>t\\<in>set ts. rank t = 0 \\<and> children t = []\""], ["proof (prove)\nusing this:\n  \\<forall>t\\<in>set (a # ts). rank t = 0 \\<and> children t = []\n\ngoal (1 subgoal):\n 1. \\<forall>t\\<in>set ts. rank t = 0 \\<and> children t = []", "by simp"], ["proof (state)\nthis:\n  \\<forall>t\\<in>set ts. rank t = 0 \\<and> children t = []\n\ngoal (1 subgoal):\n 1. \\<And>a ts q.\n       \\<lbrakk>\\<And>q.\n                   \\<lbrakk>\\<forall>t\\<in>set ts.\n                               rank t = 0 \\<and> children t = [];\n                    queue_invar q\\<rbrakk>\n                   \\<Longrightarrow> queue_to_multiset (insertList ts q) =\n                                     queue_to_multiset ts +\n                                     queue_to_multiset q;\n        \\<forall>t\\<in>set (a # ts). rank t = 0 \\<and> children t = [];\n        queue_invar q\\<rbrakk>\n       \\<Longrightarrow> queue_to_multiset (insertList (a # ts) q) =\n                         queue_to_multiset (a # ts) + queue_to_multiset q", "note inv_insert = insert_queue_invar[OF Cons(3), of \"val a\" \"prio a\"]"], ["proof (state)\nthis:\n  queue_invar (local.insert (val a) (prio a) q)\n\ngoal (1 subgoal):\n 1. \\<And>a ts q.\n       \\<lbrakk>\\<And>q.\n                   \\<lbrakk>\\<forall>t\\<in>set ts.\n                               rank t = 0 \\<and> children t = [];\n                    queue_invar q\\<rbrakk>\n                   \\<Longrightarrow> queue_to_multiset (insertList ts q) =\n                                     queue_to_multiset ts +\n                                     queue_to_multiset q;\n        \\<forall>t\\<in>set (a # ts). rank t = 0 \\<and> children t = [];\n        queue_invar q\\<rbrakk>\n       \\<Longrightarrow> queue_to_multiset (insertList (a # ts) q) =\n                         queue_to_multiset (a # ts) + queue_to_multiset q", "note iv = Cons(1)[OF ball_ts inv_insert]"], ["proof (state)\nthis:\n  queue_to_multiset (insertList ts (local.insert (val a) (prio a) q)) =\n  queue_to_multiset ts + queue_to_multiset (local.insert (val a) (prio a) q)\n\ngoal (1 subgoal):\n 1. \\<And>a ts q.\n       \\<lbrakk>\\<And>q.\n                   \\<lbrakk>\\<forall>t\\<in>set ts.\n                               rank t = 0 \\<and> children t = [];\n                    queue_invar q\\<rbrakk>\n                   \\<Longrightarrow> queue_to_multiset (insertList ts q) =\n                                     queue_to_multiset ts +\n                                     queue_to_multiset q;\n        \\<forall>t\\<in>set (a # ts). rank t = 0 \\<and> children t = [];\n        queue_invar q\\<rbrakk>\n       \\<Longrightarrow> queue_to_multiset (insertList (a # ts) q) =\n                         queue_to_multiset (a # ts) + queue_to_multiset q", "from Cons(2)"], ["proof (chain)\npicking this:\n  \\<forall>t\\<in>set (a # ts). rank t = 0 \\<and> children t = []", "have mset_a: \"tree_to_multiset a = {# (val a, prio a)#}\""], ["proof (prove)\nusing this:\n  \\<forall>t\\<in>set (a # ts). rank t = 0 \\<and> children t = []\n\ngoal (1 subgoal):\n 1. tree_to_multiset a = {#(val a, prio a)#}", "by (cases a) simp"], ["proof (state)\nthis:\n  tree_to_multiset a = {#(val a, prio a)#}\n\ngoal (1 subgoal):\n 1. \\<And>a ts q.\n       \\<lbrakk>\\<And>q.\n                   \\<lbrakk>\\<forall>t\\<in>set ts.\n                               rank t = 0 \\<and> children t = [];\n                    queue_invar q\\<rbrakk>\n                   \\<Longrightarrow> queue_to_multiset (insertList ts q) =\n                                     queue_to_multiset ts +\n                                     queue_to_multiset q;\n        \\<forall>t\\<in>set (a # ts). rank t = 0 \\<and> children t = [];\n        queue_invar q\\<rbrakk>\n       \\<Longrightarrow> queue_to_multiset (insertList (a # ts) q) =\n                         queue_to_multiset (a # ts) + queue_to_multiset q", "note insert_mset[OF Cons(3), of \"val a\" \"prio a\"]"], ["proof (state)\nthis:\n  queue_to_multiset (local.insert (val a) (prio a) q) =\n  queue_to_multiset q + {#(val a, prio a)#}\n\ngoal (1 subgoal):\n 1. \\<And>a ts q.\n       \\<lbrakk>\\<And>q.\n                   \\<lbrakk>\\<forall>t\\<in>set ts.\n                               rank t = 0 \\<and> children t = [];\n                    queue_invar q\\<rbrakk>\n                   \\<Longrightarrow> queue_to_multiset (insertList ts q) =\n                                     queue_to_multiset ts +\n                                     queue_to_multiset q;\n        \\<forall>t\\<in>set (a # ts). rank t = 0 \\<and> children t = [];\n        queue_invar q\\<rbrakk>\n       \\<Longrightarrow> queue_to_multiset (insertList (a # ts) q) =\n                         queue_to_multiset (a # ts) + queue_to_multiset q", "with mset_a iv"], ["proof (chain)\npicking this:\n  tree_to_multiset a = {#(val a, prio a)#}\n  queue_to_multiset (insertList ts (local.insert (val a) (prio a) q)) =\n  queue_to_multiset ts + queue_to_multiset (local.insert (val a) (prio a) q)\n  queue_to_multiset (local.insert (val a) (prio a) q) =\n  queue_to_multiset q + {#(val a, prio a)#}", "show ?case"], ["proof (prove)\nusing this:\n  tree_to_multiset a = {#(val a, prio a)#}\n  queue_to_multiset (insertList ts (local.insert (val a) (prio a) q)) =\n  queue_to_multiset ts + queue_to_multiset (local.insert (val a) (prio a) q)\n  queue_to_multiset (local.insert (val a) (prio a) q) =\n  queue_to_multiset q + {#(val a, prio a)#}\n\ngoal (1 subgoal):\n 1. queue_to_multiset (insertList (a # ts) q) =\n    queue_to_multiset (a # ts) + queue_to_multiset q", "by (simp add: union_ac)"], ["proof (state)\nthis:\n  queue_to_multiset (insertList (a # ts) q) =\n  queue_to_multiset (a # ts) + queue_to_multiset q\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mset_filter: \"(queue_to_multiset [t\\<leftarrow>q . rank t = 0]) +\n  queue_to_multiset [t\\<leftarrow>q . 0 < rank t] =\n  queue_to_multiset q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. queue_to_multiset (filter (\\<lambda>t. rank t = 0) q) +\n    queue_to_multiset (filter (\\<lambda>t. 0 < rank t) q) =\n    queue_to_multiset q", "by (induct q) (auto simp add: union_ac)"], ["", "lemma deleteMin_mset:\n  assumes \"queue_invar q\"\n    and \"queue_to_multiset q \\<noteq> {#}\"\n  shows \"queue_to_multiset (deleteMin q) = queue_to_multiset q - {# (findMin q) #}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. queue_to_multiset (deleteMin q) = queue_to_multiset q - {#findMin q#}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. queue_to_multiset (deleteMin q) = queue_to_multiset q - {#findMin q#}", "from assms(2)"], ["proof (chain)\npicking this:\n  queue_to_multiset q \\<noteq> {#}", "have q_ne: \"q \\<noteq> []\""], ["proof (prove)\nusing this:\n  queue_to_multiset q \\<noteq> {#}\n\ngoal (1 subgoal):\n 1. q \\<noteq> []", "by auto"], ["proof (state)\nthis:\n  q \\<noteq> []\n\ngoal (1 subgoal):\n 1. queue_to_multiset (deleteMin q) = queue_to_multiset q - {#findMin q#}", "with mintree_exists[of q]"], ["proof (chain)\npicking this:\n  (q \\<noteq> []) = (getMinTree q \\<in> set q)\n  q \\<noteq> []", "have min_in_q: \"getMinTree q \\<in> set q\""], ["proof (prove)\nusing this:\n  (q \\<noteq> []) = (getMinTree q \\<in> set q)\n  q \\<noteq> []\n\ngoal (1 subgoal):\n 1. getMinTree q \\<in> set q", "by simp"], ["proof (state)\nthis:\n  getMinTree q \\<in> set q\n\ngoal (1 subgoal):\n 1. queue_to_multiset (deleteMin q) = queue_to_multiset q - {#findMin q#}", "with assms(1)"], ["proof (chain)\npicking this:\n  queue_invar q\n  getMinTree q \\<in> set q", "have inv_min: \"tree_invar (getMinTree q)\""], ["proof (prove)\nusing this:\n  queue_invar q\n  getMinTree q \\<in> set q\n\ngoal (1 subgoal):\n 1. tree_invar (getMinTree q)", "by simp"], ["proof (state)\nthis:\n  tree_invar (getMinTree q)\n\ngoal (1 subgoal):\n 1. queue_to_multiset (deleteMin q) = queue_to_multiset q - {#findMin q#}", "note inv_rem = invar_remove1[OF assms(1), of \"getMinTree q\"]"], ["proof (state)\nthis:\n  queue_invar (remove1 (getMinTree q) q)\n\ngoal (1 subgoal):\n 1. queue_to_multiset (deleteMin q) = queue_to_multiset q - {#findMin q#}", "note inv_children = invar_children'[OF inv_min]"], ["proof (state)\nthis:\n  queue_invar (children (getMinTree q))\n\ngoal (1 subgoal):\n 1. queue_to_multiset (deleteMin q) = queue_to_multiset q - {#findMin q#}", "note inv_filter = invar_filter[OF inv_children, of \"\\<lambda>t. 0 < rank t\"]"], ["proof (state)\nthis:\n  queue_invar (filter (\\<lambda>t. 0 < rank t) (children (getMinTree q)))\n\ngoal (1 subgoal):\n 1. queue_to_multiset (deleteMin q) = queue_to_multiset q - {#findMin q#}", "note inv_rev = iffD2[OF invar_rev inv_filter]"], ["proof (state)\nthis:\n  queue_invar\n   (rev (filter (\\<lambda>t. 0 < rank t) (children (getMinTree q))))\n\ngoal (1 subgoal):\n 1. queue_to_multiset (deleteMin q) = queue_to_multiset q - {#findMin q#}", "note inv_meld = meld_queue_invar[OF inv_rev inv_rem]"], ["proof (state)\nthis:\n  queue_invar\n   (meld (rev (filter (\\<lambda>t. 0 < rank t) (children (getMinTree q))))\n     (remove1 (getMinTree q) q))\n\ngoal (1 subgoal):\n 1. queue_to_multiset (deleteMin q) = queue_to_multiset q - {#findMin q#}", "note mset_rem = mset_remove1[OF min_in_q]"], ["proof (state)\nthis:\n  queue_to_multiset (remove1 (getMinTree q) q) =\n  queue_to_multiset q - tree_to_multiset (getMinTree q)\n\ngoal (1 subgoal):\n 1. queue_to_multiset (deleteMin q) = queue_to_multiset q - {#findMin q#}", "note mset_rev = mset_rev[of \"[t\\<leftarrow>children (getMinTree q). 0 < rank t]\"]"], ["proof (state)\nthis:\n  queue_to_multiset\n   (rev (filter (\\<lambda>t. 0 < rank t) (children (getMinTree q)))) =\n  queue_to_multiset\n   (filter (\\<lambda>t. 0 < rank t) (children (getMinTree q)))\n\ngoal (1 subgoal):\n 1. queue_to_multiset (deleteMin q) = queue_to_multiset q - {#findMin q#}", "note mset_meld = meld_mset[OF inv_rev inv_rem]"], ["proof (state)\nthis:\n  queue_to_multiset\n   (meld (rev (filter (\\<lambda>t. 0 < rank t) (children (getMinTree q))))\n     (remove1 (getMinTree q) q)) =\n  queue_to_multiset\n   (rev (filter (\\<lambda>t. 0 < rank t) (children (getMinTree q)))) +\n  queue_to_multiset (remove1 (getMinTree q) q)\n\ngoal (1 subgoal):\n 1. queue_to_multiset (deleteMin q) = queue_to_multiset q - {#findMin q#}", "note mset_children = mset_children[of \"getMinTree q\"]"], ["proof (state)\nthis:\n  queue_to_multiset (children (getMinTree q)) =\n  tree_to_multiset (getMinTree q) -\n  {#(val (getMinTree q), prio (getMinTree q))#}\n\ngoal (1 subgoal):\n 1. queue_to_multiset (deleteMin q) = queue_to_multiset q - {#findMin q#}", "thm mset_insertList[of \"[t\\<leftarrow>children (getMinTree q) .\n             rank t = 0]\"]"], ["proof (state)\nthis:\n  queue_to_multiset (children (getMinTree q)) =\n  tree_to_multiset (getMinTree q) -\n  {#(val (getMinTree q), prio (getMinTree q))#}\n\ngoal (1 subgoal):\n 1. queue_to_multiset (deleteMin q) = queue_to_multiset q - {#findMin q#}", "have \"\\<lbrakk>tree_invar t; rank t = 0\\<rbrakk> \\<Longrightarrow> children t = []\" for t"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>tree_invar t; rank t = 0\\<rbrakk>\n    \\<Longrightarrow> children t = []", "by (cases t) simp"], ["proof (state)\nthis:\n  \\<lbrakk>tree_invar ?t1; rank ?t1 = 0\\<rbrakk>\n  \\<Longrightarrow> children ?t1 = []\n\ngoal (1 subgoal):\n 1. queue_to_multiset (deleteMin q) = queue_to_multiset q - {#findMin q#}", "with inv_children"], ["proof (chain)\npicking this:\n  queue_invar (children (getMinTree q))\n  \\<lbrakk>tree_invar ?t1; rank ?t1 = 0\\<rbrakk>\n  \\<Longrightarrow> children ?t1 = []", "have ball_min: \"\\<forall>t\\<in>set [t\\<leftarrow>children (getMinTree q). rank t = 0]. \n    rank t = 0 \\<and> children t = []\""], ["proof (prove)\nusing this:\n  queue_invar (children (getMinTree q))\n  \\<lbrakk>tree_invar ?t1; rank ?t1 = 0\\<rbrakk>\n  \\<Longrightarrow> children ?t1 = []\n\ngoal (1 subgoal):\n 1. \\<forall>t\\<in>set (filter (\\<lambda>t. rank t = 0)\n                         (children (getMinTree q))).\n       rank t = 0 \\<and> children t = []", "by (unfold queue_invar_def) auto"], ["proof (state)\nthis:\n  \\<forall>t\\<in>set (filter (\\<lambda>t. rank t = 0)\n                       (children (getMinTree q))).\n     rank t = 0 \\<and> children t = []\n\ngoal (1 subgoal):\n 1. queue_to_multiset (deleteMin q) = queue_to_multiset q - {#findMin q#}", "note mset_insertList = mset_insertList[OF ball_min inv_meld]"], ["proof (state)\nthis:\n  queue_to_multiset\n   (insertList (filter (\\<lambda>t. rank t = 0) (children (getMinTree q)))\n     (meld (rev (filter (\\<lambda>t. 0 < rank t) (children (getMinTree q))))\n       (remove1 (getMinTree q) q))) =\n  queue_to_multiset\n   (filter (\\<lambda>t. rank t = 0) (children (getMinTree q))) +\n  queue_to_multiset\n   (meld (rev (filter (\\<lambda>t. 0 < rank t) (children (getMinTree q))))\n     (remove1 (getMinTree q) q))\n\ngoal (1 subgoal):\n 1. queue_to_multiset (deleteMin q) = queue_to_multiset q - {#findMin q#}", "note mset_filter = mset_filter[of \"children (getMinTree q)\"]"], ["proof (state)\nthis:\n  queue_to_multiset\n   (filter (\\<lambda>t. rank t = 0) (children (getMinTree q))) +\n  queue_to_multiset\n   (filter (\\<lambda>t. 0 < rank t) (children (getMinTree q))) =\n  queue_to_multiset (children (getMinTree q))\n\ngoal (1 subgoal):\n 1. queue_to_multiset (deleteMin q) = queue_to_multiset q - {#findMin q#}", "let ?Q = \"queue_to_multiset q\""], ["proof (state)\ngoal (1 subgoal):\n 1. queue_to_multiset (deleteMin q) = queue_to_multiset q - {#findMin q#}", "let ?MT = \"tree_to_multiset (getMinTree q)\""], ["proof (state)\ngoal (1 subgoal):\n 1. queue_to_multiset (deleteMin q) = queue_to_multiset q - {#findMin q#}", "from q_ne"], ["proof (chain)\npicking this:\n  q \\<noteq> []", "have head_subset_min: \n    \"{# (val (getMinTree q), prio (getMinTree q)) #} \\<subseteq># ?MT\""], ["proof (prove)\nusing this:\n  q \\<noteq> []\n\ngoal (1 subgoal):\n 1. {#(val (getMinTree q), prio (getMinTree q))#} \\<subseteq>#\n    tree_to_multiset (getMinTree q)", "by(cases \"getMinTree q\") simp"], ["proof (state)\nthis:\n  {#(val (getMinTree q), prio (getMinTree q))#} \\<subseteq>#\n  tree_to_multiset (getMinTree q)\n\ngoal (1 subgoal):\n 1. queue_to_multiset (deleteMin q) = queue_to_multiset q - {#findMin q#}", "note min_subset_q = in_set_subset[OF min_in_q]"], ["proof (state)\nthis:\n  tree_to_multiset (getMinTree q) \\<subseteq># queue_to_multiset q\n\ngoal (1 subgoal):\n 1. queue_to_multiset (deleteMin q) = queue_to_multiset q - {#findMin q#}", "from mset_insertList mset_meld mset_rev mset_rem mset_filter mset_children\n    multiset_diff_union_assoc[OF head_subset_min, of \"?Q - ?MT\"]\n    mset_subset_eq_multiset_union_diff_commute[OF min_subset_q, of \"?MT\"]"], ["proof (chain)\npicking this:\n  queue_to_multiset\n   (insertList (filter (\\<lambda>t. rank t = 0) (children (getMinTree q)))\n     (meld (rev (filter (\\<lambda>t. 0 < rank t) (children (getMinTree q))))\n       (remove1 (getMinTree q) q))) =\n  queue_to_multiset\n   (filter (\\<lambda>t. rank t = 0) (children (getMinTree q))) +\n  queue_to_multiset\n   (meld (rev (filter (\\<lambda>t. 0 < rank t) (children (getMinTree q))))\n     (remove1 (getMinTree q) q))\n  queue_to_multiset\n   (meld (rev (filter (\\<lambda>t. 0 < rank t) (children (getMinTree q))))\n     (remove1 (getMinTree q) q)) =\n  queue_to_multiset\n   (rev (filter (\\<lambda>t. 0 < rank t) (children (getMinTree q)))) +\n  queue_to_multiset (remove1 (getMinTree q) q)\n  queue_to_multiset\n   (rev (filter (\\<lambda>t. 0 < rank t) (children (getMinTree q)))) =\n  queue_to_multiset\n   (filter (\\<lambda>t. 0 < rank t) (children (getMinTree q)))\n  queue_to_multiset (remove1 (getMinTree q) q) =\n  queue_to_multiset q - tree_to_multiset (getMinTree q)\n  queue_to_multiset\n   (filter (\\<lambda>t. rank t = 0) (children (getMinTree q))) +\n  queue_to_multiset\n   (filter (\\<lambda>t. 0 < rank t) (children (getMinTree q))) =\n  queue_to_multiset (children (getMinTree q))\n  queue_to_multiset (children (getMinTree q)) =\n  tree_to_multiset (getMinTree q) -\n  {#(val (getMinTree q), prio (getMinTree q))#}\n  queue_to_multiset q - tree_to_multiset (getMinTree q) +\n  tree_to_multiset (getMinTree q) -\n  {#(val (getMinTree q), prio (getMinTree q))#} =\n  queue_to_multiset q - tree_to_multiset (getMinTree q) +\n  (tree_to_multiset (getMinTree q) -\n   {#(val (getMinTree q), prio (getMinTree q))#})\n  queue_to_multiset q - tree_to_multiset (getMinTree q) +\n  tree_to_multiset (getMinTree q) =\n  queue_to_multiset q + tree_to_multiset (getMinTree q) -\n  tree_to_multiset (getMinTree q)", "show ?thesis"], ["proof (prove)\nusing this:\n  queue_to_multiset\n   (insertList (filter (\\<lambda>t. rank t = 0) (children (getMinTree q)))\n     (meld (rev (filter (\\<lambda>t. 0 < rank t) (children (getMinTree q))))\n       (remove1 (getMinTree q) q))) =\n  queue_to_multiset\n   (filter (\\<lambda>t. rank t = 0) (children (getMinTree q))) +\n  queue_to_multiset\n   (meld (rev (filter (\\<lambda>t. 0 < rank t) (children (getMinTree q))))\n     (remove1 (getMinTree q) q))\n  queue_to_multiset\n   (meld (rev (filter (\\<lambda>t. 0 < rank t) (children (getMinTree q))))\n     (remove1 (getMinTree q) q)) =\n  queue_to_multiset\n   (rev (filter (\\<lambda>t. 0 < rank t) (children (getMinTree q)))) +\n  queue_to_multiset (remove1 (getMinTree q) q)\n  queue_to_multiset\n   (rev (filter (\\<lambda>t. 0 < rank t) (children (getMinTree q)))) =\n  queue_to_multiset\n   (filter (\\<lambda>t. 0 < rank t) (children (getMinTree q)))\n  queue_to_multiset (remove1 (getMinTree q) q) =\n  queue_to_multiset q - tree_to_multiset (getMinTree q)\n  queue_to_multiset\n   (filter (\\<lambda>t. rank t = 0) (children (getMinTree q))) +\n  queue_to_multiset\n   (filter (\\<lambda>t. 0 < rank t) (children (getMinTree q))) =\n  queue_to_multiset (children (getMinTree q))\n  queue_to_multiset (children (getMinTree q)) =\n  tree_to_multiset (getMinTree q) -\n  {#(val (getMinTree q), prio (getMinTree q))#}\n  queue_to_multiset q - tree_to_multiset (getMinTree q) +\n  tree_to_multiset (getMinTree q) -\n  {#(val (getMinTree q), prio (getMinTree q))#} =\n  queue_to_multiset q - tree_to_multiset (getMinTree q) +\n  (tree_to_multiset (getMinTree q) -\n   {#(val (getMinTree q), prio (getMinTree q))#})\n  queue_to_multiset q - tree_to_multiset (getMinTree q) +\n  tree_to_multiset (getMinTree q) =\n  queue_to_multiset q + tree_to_multiset (getMinTree q) -\n  tree_to_multiset (getMinTree q)\n\ngoal (1 subgoal):\n 1. queue_to_multiset (deleteMin q) = queue_to_multiset q - {#findMin q#}", "by (auto simp add: deleteMin_def Let_def union_ac findMin_def)"], ["proof (state)\nthis:\n  queue_to_multiset (deleteMin q) = queue_to_multiset q - {#findMin q#}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rank_insertList: \"rank_skew_invar q \\<Longrightarrow> rank_skew_invar (insertList ts q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rank_skew_invar q \\<Longrightarrow> rank_skew_invar (insertList ts q)", "by (induct ts arbitrary: q) (simp_all add: insert_rank_invar)"], ["", "lemma insertList_invar: \"invar q \\<Longrightarrow> invar (insertList ts q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invar q \\<Longrightarrow> invar (insertList ts q)", "proof (induct ts arbitrary: q)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>q. invar q \\<Longrightarrow> invar (insertList [] q)\n 2. \\<And>a ts q.\n       \\<lbrakk>\\<And>q. invar q \\<Longrightarrow> invar (insertList ts q);\n        invar q\\<rbrakk>\n       \\<Longrightarrow> invar (insertList (a # ts) q)", "case Nil"], ["proof (state)\nthis:\n  invar q\n\ngoal (2 subgoals):\n 1. \\<And>q. invar q \\<Longrightarrow> invar (insertList [] q)\n 2. \\<And>a ts q.\n       \\<lbrakk>\\<And>q. invar q \\<Longrightarrow> invar (insertList ts q);\n        invar q\\<rbrakk>\n       \\<Longrightarrow> invar (insertList (a # ts) q)", "then"], ["proof (chain)\npicking this:\n  invar q", "show ?case"], ["proof (prove)\nusing this:\n  invar q\n\ngoal (1 subgoal):\n 1. invar (insertList [] q)", "by simp"], ["proof (state)\nthis:\n  invar (insertList [] q)\n\ngoal (1 subgoal):\n 1. \\<And>a ts q.\n       \\<lbrakk>\\<And>q. invar q \\<Longrightarrow> invar (insertList ts q);\n        invar q\\<rbrakk>\n       \\<Longrightarrow> invar (insertList (a # ts) q)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a ts q.\n       \\<lbrakk>\\<And>q. invar q \\<Longrightarrow> invar (insertList ts q);\n        invar q\\<rbrakk>\n       \\<Longrightarrow> invar (insertList (a # ts) q)", "case (Cons a q)"], ["proof (state)\nthis:\n  invar ?q \\<Longrightarrow> invar (insertList qa__ ?q)\n  invar q\n\ngoal (1 subgoal):\n 1. \\<And>a ts q.\n       \\<lbrakk>\\<And>q. invar q \\<Longrightarrow> invar (insertList ts q);\n        invar q\\<rbrakk>\n       \\<Longrightarrow> invar (insertList (a # ts) q)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. invar (insertList (a # qa__) q)", "apply (unfold insertList.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. invar (insertList qa__ (local.insert (val a) (prio a) q))", "proof goal_cases"], ["proof (state)\ngoal (1 subgoal):\n 1. invar (insertList qa__ (local.insert (val a) (prio a) q))", "case 1"], ["proof (state)\nthis:\n  \n\ngoal (1 subgoal):\n 1. invar (insertList qa__ (local.insert (val a) (prio a) q))", "from Cons(2) insert_rank_invar[of \"q\" \"val a\" \"prio a\"]"], ["proof (chain)\npicking this:\n  invar q\n  rank_skew_invar q \\<Longrightarrow>\n  rank_skew_invar (local.insert (val a) (prio a) q)", "have a1: \"rank_skew_invar (insert (val a) (prio a) q)\""], ["proof (prove)\nusing this:\n  invar q\n  rank_skew_invar q \\<Longrightarrow>\n  rank_skew_invar (local.insert (val a) (prio a) q)\n\ngoal (1 subgoal):\n 1. rank_skew_invar (local.insert (val a) (prio a) q)", "by (simp add: invar_def)"], ["proof (state)\nthis:\n  rank_skew_invar (local.insert (val a) (prio a) q)\n\ngoal (1 subgoal):\n 1. invar (insertList qa__ (local.insert (val a) (prio a) q))", "from Cons(2) insert_queue_invar[of \"q\" \"val a\" \"prio a\"]"], ["proof (chain)\npicking this:\n  invar q\n  queue_invar q \\<Longrightarrow>\n  queue_invar (local.insert (val a) (prio a) q)", "have a2: \"queue_invar (insert (val a) (prio a) q)\""], ["proof (prove)\nusing this:\n  invar q\n  queue_invar q \\<Longrightarrow>\n  queue_invar (local.insert (val a) (prio a) q)\n\ngoal (1 subgoal):\n 1. queue_invar (local.insert (val a) (prio a) q)", "by (simp add: invar_def)"], ["proof (state)\nthis:\n  queue_invar (local.insert (val a) (prio a) q)\n\ngoal (1 subgoal):\n 1. invar (insertList qa__ (local.insert (val a) (prio a) q))", "from a1 a2"], ["proof (chain)\npicking this:\n  rank_skew_invar (local.insert (val a) (prio a) q)\n  queue_invar (local.insert (val a) (prio a) q)", "have \"invar (insert (val a) (prio a) q)\""], ["proof (prove)\nusing this:\n  rank_skew_invar (local.insert (val a) (prio a) q)\n  queue_invar (local.insert (val a) (prio a) q)\n\ngoal (1 subgoal):\n 1. invar (local.insert (val a) (prio a) q)", "by (simp add: invar_def)"], ["proof (state)\nthis:\n  invar (local.insert (val a) (prio a) q)\n\ngoal (1 subgoal):\n 1. invar (insertList qa__ (local.insert (val a) (prio a) q))", "with Cons(1)[of \"(insert (val a) (prio a) q)\"]"], ["proof (chain)\npicking this:\n  invar (local.insert (val a) (prio a) q) \\<Longrightarrow>\n  invar (insertList qa__ (local.insert (val a) (prio a) q))\n  invar (local.insert (val a) (prio a) q)", "show ?case"], ["proof (prove)\nusing this:\n  invar (local.insert (val a) (prio a) q) \\<Longrightarrow>\n  invar (insertList qa__ (local.insert (val a) (prio a) q))\n  invar (local.insert (val a) (prio a) q)\n\ngoal (1 subgoal):\n 1. invar (insertList qa__ (local.insert (val a) (prio a) q))", "."], ["proof (state)\nthis:\n  invar (insertList qa__ (local.insert (val a) (prio a) q))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  invar (insertList (a # qa__) q)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma children_rank_less:\n  assumes \"tree_invar t\"\n  shows \"\\<forall>t' \\<in> set (children t). rank t' < rank t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>t'\\<in>set (children t). rank t' < rank t", "proof (cases t)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x3 x4.\n       t = Node x1 x2 x3 x4 \\<Longrightarrow>\n       \\<forall>t'\\<in>set (children t). rank t' < rank t", "case (Node e a nat list)"], ["proof (state)\nthis:\n  t = Node e a nat list\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x3 x4.\n       t = Node x1 x2 x3 x4 \\<Longrightarrow>\n       \\<forall>t'\\<in>set (children t). rank t' < rank t", "with assms"], ["proof (chain)\npicking this:\n  tree_invar t\n  t = Node e a nat list", "show ?thesis"], ["proof (prove)\nusing this:\n  tree_invar t\n  t = Node e a nat list\n\ngoal (1 subgoal):\n 1. \\<forall>t'\\<in>set (children t). rank t' < rank t", "proof (induct nat arbitrary: t e a list)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>t e a list.\n       \\<lbrakk>tree_invar t; t = Node e a 0 list\\<rbrakk>\n       \\<Longrightarrow> \\<forall>t'\\<in>set (children t). rank t' < rank t\n 2. \\<And>nat t e a list.\n       \\<lbrakk>\\<And>t e a list.\n                   \\<lbrakk>tree_invar t; t = Node e a nat list\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>t'\\<in>set (children t).\n  rank t' < rank t;\n        tree_invar t; t = Node e a (Suc nat) list\\<rbrakk>\n       \\<Longrightarrow> \\<forall>t'\\<in>set (children t). rank t' < rank t", "case 0"], ["proof (state)\nthis:\n  tree_invar t\n  t = Node e a 0 list\n\ngoal (2 subgoals):\n 1. \\<And>t e a list.\n       \\<lbrakk>tree_invar t; t = Node e a 0 list\\<rbrakk>\n       \\<Longrightarrow> \\<forall>t'\\<in>set (children t). rank t' < rank t\n 2. \\<And>nat t e a list.\n       \\<lbrakk>\\<And>t e a list.\n                   \\<lbrakk>tree_invar t; t = Node e a nat list\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>t'\\<in>set (children t).\n  rank t' < rank t;\n        tree_invar t; t = Node e a (Suc nat) list\\<rbrakk>\n       \\<Longrightarrow> \\<forall>t'\\<in>set (children t). rank t' < rank t", "then"], ["proof (chain)\npicking this:\n  tree_invar t\n  t = Node e a 0 list", "show ?case"], ["proof (prove)\nusing this:\n  tree_invar t\n  t = Node e a 0 list\n\ngoal (1 subgoal):\n 1. \\<forall>t'\\<in>set (children t). rank t' < rank t", "by simp"], ["proof (state)\nthis:\n  \\<forall>t'\\<in>set (children t). rank t' < rank t\n\ngoal (1 subgoal):\n 1. \\<And>nat t e a list.\n       \\<lbrakk>\\<And>t e a list.\n                   \\<lbrakk>tree_invar t; t = Node e a nat list\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>t'\\<in>set (children t).\n  rank t' < rank t;\n        tree_invar t; t = Node e a (Suc nat) list\\<rbrakk>\n       \\<Longrightarrow> \\<forall>t'\\<in>set (children t). rank t' < rank t", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat t e a list.\n       \\<lbrakk>\\<And>t e a list.\n                   \\<lbrakk>tree_invar t; t = Node e a nat list\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>t'\\<in>set (children t).\n  rank t' < rank t;\n        tree_invar t; t = Node e a (Suc nat) list\\<rbrakk>\n       \\<Longrightarrow> \\<forall>t'\\<in>set (children t). rank t' < rank t", "case (Suc nat)"], ["proof (state)\nthis:\n  \\<lbrakk>tree_invar ?t; ?t = Node ?e ?a nat ?list\\<rbrakk>\n  \\<Longrightarrow> \\<forall>t'\\<in>set (children ?t). rank t' < rank ?t\n  tree_invar t\n  t = Node e a (Suc nat) list\n\ngoal (1 subgoal):\n 1. \\<And>nat t e a list.\n       \\<lbrakk>\\<And>t e a list.\n                   \\<lbrakk>tree_invar t; t = Node e a nat list\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>t'\\<in>set (children t).\n  rank t' < rank t;\n        tree_invar t; t = Node e a (Suc nat) list\\<rbrakk>\n       \\<Longrightarrow> \\<forall>t'\\<in>set (children t). rank t' < rank t", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>tree_invar ?t; ?t = Node ?e ?a nat ?list\\<rbrakk>\n  \\<Longrightarrow> \\<forall>t'\\<in>set (children ?t). rank t' < rank ?t\n  tree_invar t\n  t = Node e a (Suc nat) list", "obtain e1 a1 ts1 e2 a2 ts2 e' a' where \n      O: \"tree_invar (Node e1 a1 nat ts1)\"  \"tree_invar (Node e2 a2 nat ts2)\"\n      \"t = link (Node e1 a1 nat ts1) (Node e2 a2 nat ts2) \n       \\<or> t = skewlink e' a' (Node e1 a1 nat ts1) (Node e2 a2 nat ts2)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>tree_invar ?t; ?t = Node ?e ?a nat ?list\\<rbrakk>\n  \\<Longrightarrow> \\<forall>t'\\<in>set (children ?t). rank t' < rank ?t\n  tree_invar t\n  t = Node e a (Suc nat) list\n\ngoal (1 subgoal):\n 1. (\\<And>e1 a1 ts1 e2 a2 ts2 e' a'.\n        \\<lbrakk>tree_invar (Node e1 a1 nat ts1);\n         tree_invar (Node e2 a2 nat ts2);\n         t = link (Node e1 a1 nat ts1) (Node e2 a2 nat ts2) \\<or>\n         t =\n         skewlink e' a' (Node e1 a1 nat ts1) (Node e2 a2 nat ts2)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (simp only: tree_invar.simps) blast"], ["proof (state)\nthis:\n  tree_invar (Node e1 a1 nat ts1)\n  tree_invar (Node e2 a2 nat ts2)\n  t = link (Node e1 a1 nat ts1) (Node e2 a2 nat ts2) \\<or>\n  t = skewlink e' a' (Node e1 a1 nat ts1) (Node e2 a2 nat ts2)\n\ngoal (1 subgoal):\n 1. \\<And>nat t e a list.\n       \\<lbrakk>\\<And>t e a list.\n                   \\<lbrakk>tree_invar t; t = Node e a nat list\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>t'\\<in>set (children t).\n  rank t' < rank t;\n        tree_invar t; t = Node e a (Suc nat) list\\<rbrakk>\n       \\<Longrightarrow> \\<forall>t'\\<in>set (children t). rank t' < rank t", "hence ch_id:\n      \"children t = (if a1 \\<le> a2 then (Node e2 a2 nat ts2)#ts1 \n                     else (Node e1 a1 nat ts1)#ts2) \\<or>\n      children t = \n        (if a' \\<le> a1 \\<and> a' \\<le> a2 then [(Node e1 a1 nat ts1), (Node e2 a2 nat ts2)]\n         else (if a1 \\<le> a2 then (Node e' a' 0 []) # (Node e2 a2 nat ts2) # ts1\n         else (Node e' a' 0 []) # (Node e1 a1 nat ts1) # ts2))\""], ["proof (prove)\nusing this:\n  tree_invar (Node e1 a1 nat ts1)\n  tree_invar (Node e2 a2 nat ts2)\n  t = link (Node e1 a1 nat ts1) (Node e2 a2 nat ts2) \\<or>\n  t = skewlink e' a' (Node e1 a1 nat ts1) (Node e2 a2 nat ts2)\n\ngoal (1 subgoal):\n 1. children t =\n    (if a1 \\<le> a2 then Node e2 a2 nat ts2 # ts1\n     else Node e1 a1 nat ts1 # ts2) \\<or>\n    children t =\n    (if a' \\<le> a1 \\<and> a' \\<le> a2\n     then [Node e1 a1 nat ts1, Node e2 a2 nat ts2]\n     else if a1 \\<le> a2 then Node e' a' 0 [] # Node e2 a2 nat ts2 # ts1\n          else Node e' a' 0 [] # Node e1 a1 nat ts1 # ts2)", "by auto"], ["proof (state)\nthis:\n  children t =\n  (if a1 \\<le> a2 then Node e2 a2 nat ts2 # ts1\n   else Node e1 a1 nat ts1 # ts2) \\<or>\n  children t =\n  (if a' \\<le> a1 \\<and> a' \\<le> a2\n   then [Node e1 a1 nat ts1, Node e2 a2 nat ts2]\n   else if a1 \\<le> a2 then Node e' a' 0 [] # Node e2 a2 nat ts2 # ts1\n        else Node e' a' 0 [] # Node e1 a1 nat ts1 # ts2)\n\ngoal (1 subgoal):\n 1. \\<And>nat t e a list.\n       \\<lbrakk>\\<And>t e a list.\n                   \\<lbrakk>tree_invar t; t = Node e a nat list\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>t'\\<in>set (children t).\n  rank t' < rank t;\n        tree_invar t; t = Node e a (Suc nat) list\\<rbrakk>\n       \\<Longrightarrow> \\<forall>t'\\<in>set (children t). rank t' < rank t", "from O Suc(1)[of \"Node e1 a1 nat ts1\" \"e1\" \"a1\" \"ts1\"]"], ["proof (chain)\npicking this:\n  tree_invar (Node e1 a1 nat ts1)\n  tree_invar (Node e2 a2 nat ts2)\n  t = link (Node e1 a1 nat ts1) (Node e2 a2 nat ts2) \\<or>\n  t = skewlink e' a' (Node e1 a1 nat ts1) (Node e2 a2 nat ts2)\n  \\<lbrakk>tree_invar (Node e1 a1 nat ts1);\n   Node e1 a1 nat ts1 = Node e1 a1 nat ts1\\<rbrakk>\n  \\<Longrightarrow> \\<forall>t'\\<in>set (children (Node e1 a1 nat ts1)).\n                       rank t' < rank (Node e1 a1 nat ts1)", "have  p1: \"\\<forall>t'\\<in>set ((Node e2 a2 nat ts2) # ts1). rank t' < Suc nat\""], ["proof (prove)\nusing this:\n  tree_invar (Node e1 a1 nat ts1)\n  tree_invar (Node e2 a2 nat ts2)\n  t = link (Node e1 a1 nat ts1) (Node e2 a2 nat ts2) \\<or>\n  t = skewlink e' a' (Node e1 a1 nat ts1) (Node e2 a2 nat ts2)\n  \\<lbrakk>tree_invar (Node e1 a1 nat ts1);\n   Node e1 a1 nat ts1 = Node e1 a1 nat ts1\\<rbrakk>\n  \\<Longrightarrow> \\<forall>t'\\<in>set (children (Node e1 a1 nat ts1)).\n                       rank t' < rank (Node e1 a1 nat ts1)\n\ngoal (1 subgoal):\n 1. \\<forall>t'\\<in>set (Node e2 a2 nat ts2 # ts1). rank t' < Suc nat", "by auto"], ["proof (state)\nthis:\n  \\<forall>t'\\<in>set (Node e2 a2 nat ts2 # ts1). rank t' < Suc nat\n\ngoal (1 subgoal):\n 1. \\<And>nat t e a list.\n       \\<lbrakk>\\<And>t e a list.\n                   \\<lbrakk>tree_invar t; t = Node e a nat list\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>t'\\<in>set (children t).\n  rank t' < rank t;\n        tree_invar t; t = Node e a (Suc nat) list\\<rbrakk>\n       \\<Longrightarrow> \\<forall>t'\\<in>set (children t). rank t' < rank t", "from O Suc(1)[of \"Node e2 a2 nat ts2\" \"e2\" \"a2\" \"ts2\"]"], ["proof (chain)\npicking this:\n  tree_invar (Node e1 a1 nat ts1)\n  tree_invar (Node e2 a2 nat ts2)\n  t = link (Node e1 a1 nat ts1) (Node e2 a2 nat ts2) \\<or>\n  t = skewlink e' a' (Node e1 a1 nat ts1) (Node e2 a2 nat ts2)\n  \\<lbrakk>tree_invar (Node e2 a2 nat ts2);\n   Node e2 a2 nat ts2 = Node e2 a2 nat ts2\\<rbrakk>\n  \\<Longrightarrow> \\<forall>t'\\<in>set (children (Node e2 a2 nat ts2)).\n                       rank t' < rank (Node e2 a2 nat ts2)", "have p2: \"\\<forall>t'\\<in>set ((Node e1 a1 nat ts1) # ts2). rank t' < Suc nat\""], ["proof (prove)\nusing this:\n  tree_invar (Node e1 a1 nat ts1)\n  tree_invar (Node e2 a2 nat ts2)\n  t = link (Node e1 a1 nat ts1) (Node e2 a2 nat ts2) \\<or>\n  t = skewlink e' a' (Node e1 a1 nat ts1) (Node e2 a2 nat ts2)\n  \\<lbrakk>tree_invar (Node e2 a2 nat ts2);\n   Node e2 a2 nat ts2 = Node e2 a2 nat ts2\\<rbrakk>\n  \\<Longrightarrow> \\<forall>t'\\<in>set (children (Node e2 a2 nat ts2)).\n                       rank t' < rank (Node e2 a2 nat ts2)\n\ngoal (1 subgoal):\n 1. \\<forall>t'\\<in>set (Node e1 a1 nat ts1 # ts2). rank t' < Suc nat", "by auto"], ["proof (state)\nthis:\n  \\<forall>t'\\<in>set (Node e1 a1 nat ts1 # ts2). rank t' < Suc nat\n\ngoal (1 subgoal):\n 1. \\<And>nat t e a list.\n       \\<lbrakk>\\<And>t e a list.\n                   \\<lbrakk>tree_invar t; t = Node e a nat list\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>t'\\<in>set (children t).\n  rank t' < rank t;\n        tree_invar t; t = Node e a (Suc nat) list\\<rbrakk>\n       \\<Longrightarrow> \\<forall>t'\\<in>set (children t). rank t' < rank t", "from O"], ["proof (chain)\npicking this:\n  tree_invar (Node e1 a1 nat ts1)\n  tree_invar (Node e2 a2 nat ts2)\n  t = link (Node e1 a1 nat ts1) (Node e2 a2 nat ts2) \\<or>\n  t = skewlink e' a' (Node e1 a1 nat ts1) (Node e2 a2 nat ts2)", "have \n      p3: \"\\<forall>t' \\<in> set [(Node e1 a1 nat ts1), (Node e2 a2 nat ts2)]. \n                 rank t' < Suc nat\""], ["proof (prove)\nusing this:\n  tree_invar (Node e1 a1 nat ts1)\n  tree_invar (Node e2 a2 nat ts2)\n  t = link (Node e1 a1 nat ts1) (Node e2 a2 nat ts2) \\<or>\n  t = skewlink e' a' (Node e1 a1 nat ts1) (Node e2 a2 nat ts2)\n\ngoal (1 subgoal):\n 1. \\<forall>t'\\<in>set [Node e1 a1 nat ts1, Node e2 a2 nat ts2].\n       rank t' < Suc nat", "by simp"], ["proof (state)\nthis:\n  \\<forall>t'\\<in>set [Node e1 a1 nat ts1, Node e2 a2 nat ts2].\n     rank t' < Suc nat\n\ngoal (1 subgoal):\n 1. \\<And>nat t e a list.\n       \\<lbrakk>\\<And>t e a list.\n                   \\<lbrakk>tree_invar t; t = Node e a nat list\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>t'\\<in>set (children t).\n  rank t' < rank t;\n        tree_invar t; t = Node e a (Suc nat) list\\<rbrakk>\n       \\<Longrightarrow> \\<forall>t'\\<in>set (children t). rank t' < rank t", "from O Suc(1)[of \"Node e1 a1 nat ts1\" \"e1\" \"a1\" \"ts1\"]"], ["proof (chain)\npicking this:\n  tree_invar (Node e1 a1 nat ts1)\n  tree_invar (Node e2 a2 nat ts2)\n  t = link (Node e1 a1 nat ts1) (Node e2 a2 nat ts2) \\<or>\n  t = skewlink e' a' (Node e1 a1 nat ts1) (Node e2 a2 nat ts2)\n  \\<lbrakk>tree_invar (Node e1 a1 nat ts1);\n   Node e1 a1 nat ts1 = Node e1 a1 nat ts1\\<rbrakk>\n  \\<Longrightarrow> \\<forall>t'\\<in>set (children (Node e1 a1 nat ts1)).\n                       rank t' < rank (Node e1 a1 nat ts1)", "have \n      p4: \"\\<forall>t' \\<in> set ((Node e' a' 0 []) # (Node e2 a2 nat ts2) # ts1). \n                 rank t' < Suc nat\""], ["proof (prove)\nusing this:\n  tree_invar (Node e1 a1 nat ts1)\n  tree_invar (Node e2 a2 nat ts2)\n  t = link (Node e1 a1 nat ts1) (Node e2 a2 nat ts2) \\<or>\n  t = skewlink e' a' (Node e1 a1 nat ts1) (Node e2 a2 nat ts2)\n  \\<lbrakk>tree_invar (Node e1 a1 nat ts1);\n   Node e1 a1 nat ts1 = Node e1 a1 nat ts1\\<rbrakk>\n  \\<Longrightarrow> \\<forall>t'\\<in>set (children (Node e1 a1 nat ts1)).\n                       rank t' < rank (Node e1 a1 nat ts1)\n\ngoal (1 subgoal):\n 1. \\<forall>t'\\<in>set (Node e' a' 0 [] # Node e2 a2 nat ts2 # ts1).\n       rank t' < Suc nat", "by auto"], ["proof (state)\nthis:\n  \\<forall>t'\\<in>set (Node e' a' 0 [] # Node e2 a2 nat ts2 # ts1).\n     rank t' < Suc nat\n\ngoal (1 subgoal):\n 1. \\<And>nat t e a list.\n       \\<lbrakk>\\<And>t e a list.\n                   \\<lbrakk>tree_invar t; t = Node e a nat list\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>t'\\<in>set (children t).\n  rank t' < rank t;\n        tree_invar t; t = Node e a (Suc nat) list\\<rbrakk>\n       \\<Longrightarrow> \\<forall>t'\\<in>set (children t). rank t' < rank t", "from O Suc(1)[of \"Node e2 a2 nat ts2\" \"e2\" \"a2\" \"ts2\"]"], ["proof (chain)\npicking this:\n  tree_invar (Node e1 a1 nat ts1)\n  tree_invar (Node e2 a2 nat ts2)\n  t = link (Node e1 a1 nat ts1) (Node e2 a2 nat ts2) \\<or>\n  t = skewlink e' a' (Node e1 a1 nat ts1) (Node e2 a2 nat ts2)\n  \\<lbrakk>tree_invar (Node e2 a2 nat ts2);\n   Node e2 a2 nat ts2 = Node e2 a2 nat ts2\\<rbrakk>\n  \\<Longrightarrow> \\<forall>t'\\<in>set (children (Node e2 a2 nat ts2)).\n                       rank t' < rank (Node e2 a2 nat ts2)", "have p5: \n      \"\\<forall>t' \\<in> set ((Node e' a' 0 []) # (Node e1 a1 nat ts1) # ts2). \n                 rank t' < Suc nat\""], ["proof (prove)\nusing this:\n  tree_invar (Node e1 a1 nat ts1)\n  tree_invar (Node e2 a2 nat ts2)\n  t = link (Node e1 a1 nat ts1) (Node e2 a2 nat ts2) \\<or>\n  t = skewlink e' a' (Node e1 a1 nat ts1) (Node e2 a2 nat ts2)\n  \\<lbrakk>tree_invar (Node e2 a2 nat ts2);\n   Node e2 a2 nat ts2 = Node e2 a2 nat ts2\\<rbrakk>\n  \\<Longrightarrow> \\<forall>t'\\<in>set (children (Node e2 a2 nat ts2)).\n                       rank t' < rank (Node e2 a2 nat ts2)\n\ngoal (1 subgoal):\n 1. \\<forall>t'\\<in>set (Node e' a' 0 [] # Node e1 a1 nat ts1 # ts2).\n       rank t' < Suc nat", "by auto"], ["proof (state)\nthis:\n  \\<forall>t'\\<in>set (Node e' a' 0 [] # Node e1 a1 nat ts1 # ts2).\n     rank t' < Suc nat\n\ngoal (1 subgoal):\n 1. \\<And>nat t e a list.\n       \\<lbrakk>\\<And>t e a list.\n                   \\<lbrakk>tree_invar t; t = Node e a nat list\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>t'\\<in>set (children t).\n  rank t' < rank t;\n        tree_invar t; t = Node e a (Suc nat) list\\<rbrakk>\n       \\<Longrightarrow> \\<forall>t'\\<in>set (children t). rank t' < rank t", "from Suc(3) p1 p2 p3 p4 p5 ch_id"], ["proof (chain)\npicking this:\n  t = Node e a (Suc nat) list\n  \\<forall>t'\\<in>set (Node e2 a2 nat ts2 # ts1). rank t' < Suc nat\n  \\<forall>t'\\<in>set (Node e1 a1 nat ts1 # ts2). rank t' < Suc nat\n  \\<forall>t'\\<in>set [Node e1 a1 nat ts1, Node e2 a2 nat ts2].\n     rank t' < Suc nat\n  \\<forall>t'\\<in>set (Node e' a' 0 [] # Node e2 a2 nat ts2 # ts1).\n     rank t' < Suc nat\n  \\<forall>t'\\<in>set (Node e' a' 0 [] # Node e1 a1 nat ts1 # ts2).\n     rank t' < Suc nat\n  children t =\n  (if a1 \\<le> a2 then Node e2 a2 nat ts2 # ts1\n   else Node e1 a1 nat ts1 # ts2) \\<or>\n  children t =\n  (if a' \\<le> a1 \\<and> a' \\<le> a2\n   then [Node e1 a1 nat ts1, Node e2 a2 nat ts2]\n   else if a1 \\<le> a2 then Node e' a' 0 [] # Node e2 a2 nat ts2 # ts1\n        else Node e' a' 0 [] # Node e1 a1 nat ts1 # ts2)", "show ?case"], ["proof (prove)\nusing this:\n  t = Node e a (Suc nat) list\n  \\<forall>t'\\<in>set (Node e2 a2 nat ts2 # ts1). rank t' < Suc nat\n  \\<forall>t'\\<in>set (Node e1 a1 nat ts1 # ts2). rank t' < Suc nat\n  \\<forall>t'\\<in>set [Node e1 a1 nat ts1, Node e2 a2 nat ts2].\n     rank t' < Suc nat\n  \\<forall>t'\\<in>set (Node e' a' 0 [] # Node e2 a2 nat ts2 # ts1).\n     rank t' < Suc nat\n  \\<forall>t'\\<in>set (Node e' a' 0 [] # Node e1 a1 nat ts1 # ts2).\n     rank t' < Suc nat\n  children t =\n  (if a1 \\<le> a2 then Node e2 a2 nat ts2 # ts1\n   else Node e1 a1 nat ts1 # ts2) \\<or>\n  children t =\n  (if a' \\<le> a1 \\<and> a' \\<le> a2\n   then [Node e1 a1 nat ts1, Node e2 a2 nat ts2]\n   else if a1 \\<le> a2 then Node e' a' 0 [] # Node e2 a2 nat ts2 # ts1\n        else Node e' a' 0 [] # Node e1 a1 nat ts1 # ts2)\n\ngoal (1 subgoal):\n 1. \\<forall>t'\\<in>set (children t). rank t' < rank t", "by(cases \"children t = (if a1 \\<le> a2 then Node e2 a2 nat ts2 # ts1 \n                              else Node e1 a1 nat ts1 # ts2)\") simp_all"], ["proof (state)\nthis:\n  \\<forall>t'\\<in>set (children t). rank t' < rank t\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>t'\\<in>set (children t). rank t' < rank t\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma strong_rev_children:\n  assumes \"tree_invar t\"\n  shows \"invar (rev [t \\<leftarrow> children t. 0 < rank t])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invar (rev (filter (\\<lambda>t. 0 < rank t) (children t)))", "proof (cases t)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x3 x4.\n       t = Node x1 x2 x3 x4 \\<Longrightarrow>\n       invar (rev (filter (\\<lambda>t. 0 < rank t) (children t)))", "case (Node e a nat list)"], ["proof (state)\nthis:\n  t = Node e a nat list\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x3 x4.\n       t = Node x1 x2 x3 x4 \\<Longrightarrow>\n       invar (rev (filter (\\<lambda>t. 0 < rank t) (children t)))", "with assms"], ["proof (chain)\npicking this:\n  tree_invar t\n  t = Node e a nat list", "show ?thesis"], ["proof (prove)\nusing this:\n  tree_invar t\n  t = Node e a nat list\n\ngoal (1 subgoal):\n 1. invar (rev (filter (\\<lambda>t. 0 < rank t) (children t)))", "proof (induct \"nat\" arbitrary: t e a list)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>t e a list.\n       \\<lbrakk>tree_invar t; t = Node e a 0 list\\<rbrakk>\n       \\<Longrightarrow> invar\n                          (rev (filter (\\<lambda>t. 0 < rank t)\n                                 (children t)))\n 2. \\<And>nat t e a list.\n       \\<lbrakk>\\<And>t e a list.\n                   \\<lbrakk>tree_invar t; t = Node e a nat list\\<rbrakk>\n                   \\<Longrightarrow> invar\n(rev (filter (\\<lambda>t. 0 < rank t) (children t)));\n        tree_invar t; t = Node e a (Suc nat) list\\<rbrakk>\n       \\<Longrightarrow> invar\n                          (rev (filter (\\<lambda>t. 0 < rank t)\n                                 (children t)))", "case 0"], ["proof (state)\nthis:\n  tree_invar t\n  t = Node e a 0 list\n\ngoal (2 subgoals):\n 1. \\<And>t e a list.\n       \\<lbrakk>tree_invar t; t = Node e a 0 list\\<rbrakk>\n       \\<Longrightarrow> invar\n                          (rev (filter (\\<lambda>t. 0 < rank t)\n                                 (children t)))\n 2. \\<And>nat t e a list.\n       \\<lbrakk>\\<And>t e a list.\n                   \\<lbrakk>tree_invar t; t = Node e a nat list\\<rbrakk>\n                   \\<Longrightarrow> invar\n(rev (filter (\\<lambda>t. 0 < rank t) (children t)));\n        tree_invar t; t = Node e a (Suc nat) list\\<rbrakk>\n       \\<Longrightarrow> invar\n                          (rev (filter (\\<lambda>t. 0 < rank t)\n                                 (children t)))", "then"], ["proof (chain)\npicking this:\n  tree_invar t\n  t = Node e a 0 list", "show ?case"], ["proof (prove)\nusing this:\n  tree_invar t\n  t = Node e a 0 list\n\ngoal (1 subgoal):\n 1. invar (rev (filter (\\<lambda>t. 0 < rank t) (children t)))", "by (simp add: invar_def)"], ["proof (state)\nthis:\n  invar (rev (filter (\\<lambda>t. 0 < rank t) (children t)))\n\ngoal (1 subgoal):\n 1. \\<And>nat t e a list.\n       \\<lbrakk>\\<And>t e a list.\n                   \\<lbrakk>tree_invar t; t = Node e a nat list\\<rbrakk>\n                   \\<Longrightarrow> invar\n(rev (filter (\\<lambda>t. 0 < rank t) (children t)));\n        tree_invar t; t = Node e a (Suc nat) list\\<rbrakk>\n       \\<Longrightarrow> invar\n                          (rev (filter (\\<lambda>t. 0 < rank t)\n                                 (children t)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat t e a list.\n       \\<lbrakk>\\<And>t e a list.\n                   \\<lbrakk>tree_invar t; t = Node e a nat list\\<rbrakk>\n                   \\<Longrightarrow> invar\n(rev (filter (\\<lambda>t. 0 < rank t) (children t)));\n        tree_invar t; t = Node e a (Suc nat) list\\<rbrakk>\n       \\<Longrightarrow> invar\n                          (rev (filter (\\<lambda>t. 0 < rank t)\n                                 (children t)))", "case (Suc nat)"], ["proof (state)\nthis:\n  \\<lbrakk>tree_invar ?t; ?t = Node ?e ?a nat ?list\\<rbrakk>\n  \\<Longrightarrow> invar\n                     (rev (filter (\\<lambda>t. 0 < rank t) (children ?t)))\n  tree_invar t\n  t = Node e a (Suc nat) list\n\ngoal (1 subgoal):\n 1. \\<And>nat t e a list.\n       \\<lbrakk>\\<And>t e a list.\n                   \\<lbrakk>tree_invar t; t = Node e a nat list\\<rbrakk>\n                   \\<Longrightarrow> invar\n(rev (filter (\\<lambda>t. 0 < rank t) (children t)));\n        tree_invar t; t = Node e a (Suc nat) list\\<rbrakk>\n       \\<Longrightarrow> invar\n                          (rev (filter (\\<lambda>t. 0 < rank t)\n                                 (children t)))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. invar (rev (filter (\\<lambda>t. 0 < rank t) (children t)))", "proof (cases \"nat\")"], ["proof (state)\ngoal (2 subgoals):\n 1. nat = 0 \\<Longrightarrow>\n    invar (rev (filter (\\<lambda>t. 0 < rank t) (children t)))\n 2. \\<And>nat.\n       nat = Suc nat \\<Longrightarrow>\n       invar (rev (filter (\\<lambda>t. 0 < rank t) (children t)))", "case 0"], ["proof (state)\nthis:\n  nat = 0\n\ngoal (2 subgoals):\n 1. nat = 0 \\<Longrightarrow>\n    invar (rev (filter (\\<lambda>t. 0 < rank t) (children t)))\n 2. \\<And>nat.\n       nat = Suc nat \\<Longrightarrow>\n       invar (rev (filter (\\<lambda>t. 0 < rank t) (children t)))", "with Suc"], ["proof (chain)\npicking this:\n  \\<lbrakk>tree_invar ?t; ?t = Node ?e ?a nat ?list\\<rbrakk>\n  \\<Longrightarrow> invar\n                     (rev (filter (\\<lambda>t. 0 < rank t) (children ?t)))\n  tree_invar t\n  t = Node e a (Suc nat) list\n  nat = 0", "obtain e1 a1 e2 a2 e' a' where \n        O: \"tree_invar (Node e1 a1 0 [])\" \"tree_invar (Node e2 a2 0 [])\"\n        \"t = link (Node e1 a1 0 []) (Node e2 a2 0 []) \n        \\<or> t = skewlink e' a' (Node e1 a1 0 []) (Node e2 a2 0 [])\""], ["proof (prove)\nusing this:\n  \\<lbrakk>tree_invar ?t; ?t = Node ?e ?a nat ?list\\<rbrakk>\n  \\<Longrightarrow> invar\n                     (rev (filter (\\<lambda>t. 0 < rank t) (children ?t)))\n  tree_invar t\n  t = Node e a (Suc nat) list\n  nat = 0\n\ngoal (1 subgoal):\n 1. (\\<And>e1 a1 e2 a2 e' a'.\n        \\<lbrakk>tree_invar (Node e1 a1 0 []); tree_invar (Node e2 a2 0 []);\n         t = link (Node e1 a1 0 []) (Node e2 a2 0 []) \\<or>\n         t = skewlink e' a' (Node e1 a1 0 []) (Node e2 a2 0 [])\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (simp only: tree_invar.simps) blast"], ["proof (state)\nthis:\n  tree_invar (Node e1 a1 0 [])\n  tree_invar (Node e2 a2 0 [])\n  t = link (Node e1 a1 0 []) (Node e2 a2 0 []) \\<or>\n  t = skewlink e' a' (Node e1 a1 0 []) (Node e2 a2 0 [])\n\ngoal (2 subgoals):\n 1. nat = 0 \\<Longrightarrow>\n    invar (rev (filter (\\<lambda>t. 0 < rank t) (children t)))\n 2. \\<And>nat.\n       nat = Suc nat \\<Longrightarrow>\n       invar (rev (filter (\\<lambda>t. 0 < rank t) (children t)))", "hence \"[t \\<leftarrow> children t. 0 < rank t] = []\""], ["proof (prove)\nusing this:\n  tree_invar (Node e1 a1 0 [])\n  tree_invar (Node e2 a2 0 [])\n  t = link (Node e1 a1 0 []) (Node e2 a2 0 []) \\<or>\n  t = skewlink e' a' (Node e1 a1 0 []) (Node e2 a2 0 [])\n\ngoal (1 subgoal):\n 1. filter (\\<lambda>t. 0 < rank t) (children t) = []", "by auto"], ["proof (state)\nthis:\n  filter (\\<lambda>t. 0 < rank t) (children t) = []\n\ngoal (2 subgoals):\n 1. nat = 0 \\<Longrightarrow>\n    invar (rev (filter (\\<lambda>t. 0 < rank t) (children t)))\n 2. \\<And>nat.\n       nat = Suc nat \\<Longrightarrow>\n       invar (rev (filter (\\<lambda>t. 0 < rank t) (children t)))", "then"], ["proof (chain)\npicking this:\n  filter (\\<lambda>t. 0 < rank t) (children t) = []", "show ?thesis"], ["proof (prove)\nusing this:\n  filter (\\<lambda>t. 0 < rank t) (children t) = []\n\ngoal (1 subgoal):\n 1. invar (rev (filter (\\<lambda>t. 0 < rank t) (children t)))", "by (simp add: invar_def)"], ["proof (state)\nthis:\n  invar (rev (filter (\\<lambda>t. 0 < rank t) (children t)))\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       nat = Suc nat \\<Longrightarrow>\n       invar (rev (filter (\\<lambda>t. 0 < rank t) (children t)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       nat = Suc nat \\<Longrightarrow>\n       invar (rev (filter (\\<lambda>t. 0 < rank t) (children t)))", "case Suc': (Suc n)"], ["proof (state)\nthis:\n  nat = Suc n\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       nat = Suc nat \\<Longrightarrow>\n       invar (rev (filter (\\<lambda>t. 0 < rank t) (children t)))", "from Suc"], ["proof (chain)\npicking this:\n  \\<lbrakk>tree_invar ?t; ?t = Node ?e ?a nat ?list\\<rbrakk>\n  \\<Longrightarrow> invar\n                     (rev (filter (\\<lambda>t. 0 < rank t) (children ?t)))\n  tree_invar t\n  t = Node e a (Suc nat) list", "obtain e1 a1 ts1 e2 a2 ts2 e' a' where \n        O: \"tree_invar (Node e1 a1 nat ts1)\" \"tree_invar (Node e2 a2 nat ts2)\"\n        \"t = link (Node e1 a1 nat ts1) (Node e2 a2 nat ts2) \n        \\<or> t = skewlink e' a' (Node e1 a1 nat ts1) (Node e2 a2 nat ts2)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>tree_invar ?t; ?t = Node ?e ?a nat ?list\\<rbrakk>\n  \\<Longrightarrow> invar\n                     (rev (filter (\\<lambda>t. 0 < rank t) (children ?t)))\n  tree_invar t\n  t = Node e a (Suc nat) list\n\ngoal (1 subgoal):\n 1. (\\<And>e1 a1 ts1 e2 a2 ts2 e' a'.\n        \\<lbrakk>tree_invar (Node e1 a1 nat ts1);\n         tree_invar (Node e2 a2 nat ts2);\n         t = link (Node e1 a1 nat ts1) (Node e2 a2 nat ts2) \\<or>\n         t =\n         skewlink e' a' (Node e1 a1 nat ts1) (Node e2 a2 nat ts2)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (simp only: tree_invar.simps) blast"], ["proof (state)\nthis:\n  tree_invar (Node e1 a1 nat ts1)\n  tree_invar (Node e2 a2 nat ts2)\n  t = link (Node e1 a1 nat ts1) (Node e2 a2 nat ts2) \\<or>\n  t = skewlink e' a' (Node e1 a1 nat ts1) (Node e2 a2 nat ts2)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       nat = Suc nat \\<Longrightarrow>\n       invar (rev (filter (\\<lambda>t. 0 < rank t) (children t)))", "hence ch_id: \n        \"children t = (if a1 \\<le> a2 then \n          (Node e2 a2 nat ts2)#ts1 \n        else (Node e1 a1 nat ts1)#ts2) \n        \\<or> \n        children t = (if a' \\<le> a1 \\<and> a' \\<le> a2 then \n          [(Node e1 a1 nat ts1), (Node e2 a2 nat ts2)]\n        else (if a1 \\<le> a2 then \n          (Node e' a' 0 []) # (Node e2 a2 nat ts2) # ts1\n        else (Node e' a' 0 []) # (Node e1 a1 nat ts1) # ts2))\""], ["proof (prove)\nusing this:\n  tree_invar (Node e1 a1 nat ts1)\n  tree_invar (Node e2 a2 nat ts2)\n  t = link (Node e1 a1 nat ts1) (Node e2 a2 nat ts2) \\<or>\n  t = skewlink e' a' (Node e1 a1 nat ts1) (Node e2 a2 nat ts2)\n\ngoal (1 subgoal):\n 1. children t =\n    (if a1 \\<le> a2 then Node e2 a2 nat ts2 # ts1\n     else Node e1 a1 nat ts1 # ts2) \\<or>\n    children t =\n    (if a' \\<le> a1 \\<and> a' \\<le> a2\n     then [Node e1 a1 nat ts1, Node e2 a2 nat ts2]\n     else if a1 \\<le> a2 then Node e' a' 0 [] # Node e2 a2 nat ts2 # ts1\n          else Node e' a' 0 [] # Node e1 a1 nat ts1 # ts2)", "by auto"], ["proof (state)\nthis:\n  children t =\n  (if a1 \\<le> a2 then Node e2 a2 nat ts2 # ts1\n   else Node e1 a1 nat ts1 # ts2) \\<or>\n  children t =\n  (if a' \\<le> a1 \\<and> a' \\<le> a2\n   then [Node e1 a1 nat ts1, Node e2 a2 nat ts2]\n   else if a1 \\<le> a2 then Node e' a' 0 [] # Node e2 a2 nat ts2 # ts1\n        else Node e' a' 0 [] # Node e1 a1 nat ts1 # ts2)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       nat = Suc nat \\<Longrightarrow>\n       invar (rev (filter (\\<lambda>t. 0 < rank t) (children t)))", "from O Suc(1)[of \"Node e1 a1 nat ts1\" \"e1\" \"a1\" \"ts1\"]"], ["proof (chain)\npicking this:\n  tree_invar (Node e1 a1 nat ts1)\n  tree_invar (Node e2 a2 nat ts2)\n  t = link (Node e1 a1 nat ts1) (Node e2 a2 nat ts2) \\<or>\n  t = skewlink e' a' (Node e1 a1 nat ts1) (Node e2 a2 nat ts2)\n  \\<lbrakk>tree_invar (Node e1 a1 nat ts1);\n   Node e1 a1 nat ts1 = Node e1 a1 nat ts1\\<rbrakk>\n  \\<Longrightarrow> invar\n                     (rev (filter (\\<lambda>t. 0 < rank t)\n                            (children (Node e1 a1 nat ts1))))", "have \n        rev_ts1: \"invar (rev [t \\<leftarrow> ts1. 0 < rank t])\""], ["proof (prove)\nusing this:\n  tree_invar (Node e1 a1 nat ts1)\n  tree_invar (Node e2 a2 nat ts2)\n  t = link (Node e1 a1 nat ts1) (Node e2 a2 nat ts2) \\<or>\n  t = skewlink e' a' (Node e1 a1 nat ts1) (Node e2 a2 nat ts2)\n  \\<lbrakk>tree_invar (Node e1 a1 nat ts1);\n   Node e1 a1 nat ts1 = Node e1 a1 nat ts1\\<rbrakk>\n  \\<Longrightarrow> invar\n                     (rev (filter (\\<lambda>t. 0 < rank t)\n                            (children (Node e1 a1 nat ts1))))\n\ngoal (1 subgoal):\n 1. invar (rev (filter (\\<lambda>t. 0 < rank t) ts1))", "by simp"], ["proof (state)\nthis:\n  invar (rev (filter (\\<lambda>t. 0 < rank t) ts1))\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       nat = Suc nat \\<Longrightarrow>\n       invar (rev (filter (\\<lambda>t. 0 < rank t) (children t)))", "from O children_rank_less[of \"Node e1 a1 nat ts1\"]"], ["proof (chain)\npicking this:\n  tree_invar (Node e1 a1 nat ts1)\n  tree_invar (Node e2 a2 nat ts2)\n  t = link (Node e1 a1 nat ts1) (Node e2 a2 nat ts2) \\<or>\n  t = skewlink e' a' (Node e1 a1 nat ts1) (Node e2 a2 nat ts2)\n  tree_invar (Node e1 a1 nat ts1) \\<Longrightarrow>\n  \\<forall>t'\\<in>set (children (Node e1 a1 nat ts1)).\n     rank t' < rank (Node e1 a1 nat ts1)", "have\n        \"\\<forall>t\\<in>set (rev [t \\<leftarrow> ts1. 0 < rank t]). rank t < rank (Node e2 a2 nat ts2)\""], ["proof (prove)\nusing this:\n  tree_invar (Node e1 a1 nat ts1)\n  tree_invar (Node e2 a2 nat ts2)\n  t = link (Node e1 a1 nat ts1) (Node e2 a2 nat ts2) \\<or>\n  t = skewlink e' a' (Node e1 a1 nat ts1) (Node e2 a2 nat ts2)\n  tree_invar (Node e1 a1 nat ts1) \\<Longrightarrow>\n  \\<forall>t'\\<in>set (children (Node e1 a1 nat ts1)).\n     rank t' < rank (Node e1 a1 nat ts1)\n\ngoal (1 subgoal):\n 1. \\<forall>t\\<in>set (rev (filter (\\<lambda>t. 0 < rank t) ts1)).\n       rank t < rank (Node e2 a2 nat ts2)", "by simp"], ["proof (state)\nthis:\n  \\<forall>t\\<in>set (rev (filter (\\<lambda>t. 0 < rank t) ts1)).\n     rank t < rank (Node e2 a2 nat ts2)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       nat = Suc nat \\<Longrightarrow>\n       invar (rev (filter (\\<lambda>t. 0 < rank t) (children t)))", "with O rev_ts1 \n        invar_app_single[of \"rev [t \\<leftarrow> ts1. 0 < rank t]\" \n                                  \"Node e2 a2 nat ts2\"]"], ["proof (chain)\npicking this:\n  tree_invar (Node e1 a1 nat ts1)\n  tree_invar (Node e2 a2 nat ts2)\n  t = link (Node e1 a1 nat ts1) (Node e2 a2 nat ts2) \\<or>\n  t = skewlink e' a' (Node e1 a1 nat ts1) (Node e2 a2 nat ts2)\n  invar (rev (filter (\\<lambda>t. 0 < rank t) ts1))\n  \\<lbrakk>invar (rev (filter (\\<lambda>t. 0 < rank t) ts1));\n   \\<forall>t\\<in>set (rev (filter (\\<lambda>t. 0 < rank t) ts1)).\n      rank t < rank (Node e2 a2 nat ts2);\n   tree_invar (Node e2 a2 nat ts2)\\<rbrakk>\n  \\<Longrightarrow> invar\n                     (rev (filter (\\<lambda>t. 0 < rank t) ts1) @\n                      [Node e2 a2 nat ts2])\n  \\<forall>t\\<in>set (rev (filter (\\<lambda>t. 0 < rank t) ts1)).\n     rank t < rank (Node e2 a2 nat ts2)", "have \n        \"invar (rev ((Node e2 a2 nat ts2) # [t \\<leftarrow> ts1. 0 < rank t]))\""], ["proof (prove)\nusing this:\n  tree_invar (Node e1 a1 nat ts1)\n  tree_invar (Node e2 a2 nat ts2)\n  t = link (Node e1 a1 nat ts1) (Node e2 a2 nat ts2) \\<or>\n  t = skewlink e' a' (Node e1 a1 nat ts1) (Node e2 a2 nat ts2)\n  invar (rev (filter (\\<lambda>t. 0 < rank t) ts1))\n  \\<lbrakk>invar (rev (filter (\\<lambda>t. 0 < rank t) ts1));\n   \\<forall>t\\<in>set (rev (filter (\\<lambda>t. 0 < rank t) ts1)).\n      rank t < rank (Node e2 a2 nat ts2);\n   tree_invar (Node e2 a2 nat ts2)\\<rbrakk>\n  \\<Longrightarrow> invar\n                     (rev (filter (\\<lambda>t. 0 < rank t) ts1) @\n                      [Node e2 a2 nat ts2])\n  \\<forall>t\\<in>set (rev (filter (\\<lambda>t. 0 < rank t) ts1)).\n     rank t < rank (Node e2 a2 nat ts2)\n\ngoal (1 subgoal):\n 1. invar (rev (Node e2 a2 nat ts2 # filter (\\<lambda>t. 0 < rank t) ts1))", "by simp"], ["proof (state)\nthis:\n  invar (rev (Node e2 a2 nat ts2 # filter (\\<lambda>t. 0 < rank t) ts1))\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       nat = Suc nat \\<Longrightarrow>\n       invar (rev (filter (\\<lambda>t. 0 < rank t) (children t)))", "with Suc'"], ["proof (chain)\npicking this:\n  nat = Suc n\n  invar (rev (Node e2 a2 nat ts2 # filter (\\<lambda>t. 0 < rank t) ts1))", "have p1: \"invar (rev [t \\<leftarrow> ((Node e2 a2 nat ts2) # ts1). 0 < rank t])\""], ["proof (prove)\nusing this:\n  nat = Suc n\n  invar (rev (Node e2 a2 nat ts2 # filter (\\<lambda>t. 0 < rank t) ts1))\n\ngoal (1 subgoal):\n 1. invar (rev (filter (\\<lambda>t. 0 < rank t) (Node e2 a2 nat ts2 # ts1)))", "by simp"], ["proof (state)\nthis:\n  invar (rev (filter (\\<lambda>t. 0 < rank t) (Node e2 a2 nat ts2 # ts1)))\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       nat = Suc nat \\<Longrightarrow>\n       invar (rev (filter (\\<lambda>t. 0 < rank t) (children t)))", "from O Suc(1)[of \"Node e2 a2 nat ts2\" \"e2\" \"a2\" \"ts2\"]"], ["proof (chain)\npicking this:\n  tree_invar (Node e1 a1 nat ts1)\n  tree_invar (Node e2 a2 nat ts2)\n  t = link (Node e1 a1 nat ts1) (Node e2 a2 nat ts2) \\<or>\n  t = skewlink e' a' (Node e1 a1 nat ts1) (Node e2 a2 nat ts2)\n  \\<lbrakk>tree_invar (Node e2 a2 nat ts2);\n   Node e2 a2 nat ts2 = Node e2 a2 nat ts2\\<rbrakk>\n  \\<Longrightarrow> invar\n                     (rev (filter (\\<lambda>t. 0 < rank t)\n                            (children (Node e2 a2 nat ts2))))", "have rev_ts2: \"invar (rev [t \\<leftarrow> ts2. 0 < rank t])\""], ["proof (prove)\nusing this:\n  tree_invar (Node e1 a1 nat ts1)\n  tree_invar (Node e2 a2 nat ts2)\n  t = link (Node e1 a1 nat ts1) (Node e2 a2 nat ts2) \\<or>\n  t = skewlink e' a' (Node e1 a1 nat ts1) (Node e2 a2 nat ts2)\n  \\<lbrakk>tree_invar (Node e2 a2 nat ts2);\n   Node e2 a2 nat ts2 = Node e2 a2 nat ts2\\<rbrakk>\n  \\<Longrightarrow> invar\n                     (rev (filter (\\<lambda>t. 0 < rank t)\n                            (children (Node e2 a2 nat ts2))))\n\ngoal (1 subgoal):\n 1. invar (rev (filter (\\<lambda>t. 0 < rank t) ts2))", "by simp"], ["proof (state)\nthis:\n  invar (rev (filter (\\<lambda>t. 0 < rank t) ts2))\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       nat = Suc nat \\<Longrightarrow>\n       invar (rev (filter (\\<lambda>t. 0 < rank t) (children t)))", "from O children_rank_less[of \"Node e2 a2 nat ts2\"]"], ["proof (chain)\npicking this:\n  tree_invar (Node e1 a1 nat ts1)\n  tree_invar (Node e2 a2 nat ts2)\n  t = link (Node e1 a1 nat ts1) (Node e2 a2 nat ts2) \\<or>\n  t = skewlink e' a' (Node e1 a1 nat ts1) (Node e2 a2 nat ts2)\n  tree_invar (Node e2 a2 nat ts2) \\<Longrightarrow>\n  \\<forall>t'\\<in>set (children (Node e2 a2 nat ts2)).\n     rank t' < rank (Node e2 a2 nat ts2)", "have \"\\<forall>t\\<in>set (rev [t \\<leftarrow> ts2. 0 < rank t]). \n        rank t < rank (Node e1 a1 nat ts1)\""], ["proof (prove)\nusing this:\n  tree_invar (Node e1 a1 nat ts1)\n  tree_invar (Node e2 a2 nat ts2)\n  t = link (Node e1 a1 nat ts1) (Node e2 a2 nat ts2) \\<or>\n  t = skewlink e' a' (Node e1 a1 nat ts1) (Node e2 a2 nat ts2)\n  tree_invar (Node e2 a2 nat ts2) \\<Longrightarrow>\n  \\<forall>t'\\<in>set (children (Node e2 a2 nat ts2)).\n     rank t' < rank (Node e2 a2 nat ts2)\n\ngoal (1 subgoal):\n 1. \\<forall>t\\<in>set (rev (filter (\\<lambda>t. 0 < rank t) ts2)).\n       rank t < rank (Node e1 a1 nat ts1)", "by simp"], ["proof (state)\nthis:\n  \\<forall>t\\<in>set (rev (filter (\\<lambda>t. 0 < rank t) ts2)).\n     rank t < rank (Node e1 a1 nat ts1)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       nat = Suc nat \\<Longrightarrow>\n       invar (rev (filter (\\<lambda>t. 0 < rank t) (children t)))", "with O rev_ts2 invar_app_single[of \"rev [t \\<leftarrow> ts2. 0 < rank t]\" \n                                         \"Node e1 a1 nat ts1\"]"], ["proof (chain)\npicking this:\n  tree_invar (Node e1 a1 nat ts1)\n  tree_invar (Node e2 a2 nat ts2)\n  t = link (Node e1 a1 nat ts1) (Node e2 a2 nat ts2) \\<or>\n  t = skewlink e' a' (Node e1 a1 nat ts1) (Node e2 a2 nat ts2)\n  invar (rev (filter (\\<lambda>t. 0 < rank t) ts2))\n  \\<lbrakk>invar (rev (filter (\\<lambda>t. 0 < rank t) ts2));\n   \\<forall>t\\<in>set (rev (filter (\\<lambda>t. 0 < rank t) ts2)).\n      rank t < rank (Node e1 a1 nat ts1);\n   tree_invar (Node e1 a1 nat ts1)\\<rbrakk>\n  \\<Longrightarrow> invar\n                     (rev (filter (\\<lambda>t. 0 < rank t) ts2) @\n                      [Node e1 a1 nat ts1])\n  \\<forall>t\\<in>set (rev (filter (\\<lambda>t. 0 < rank t) ts2)).\n     rank t < rank (Node e1 a1 nat ts1)", "have \"invar (rev [t \\<leftarrow> ts2. 0 < rank t] @ [Node e1 a1 nat ts1])\""], ["proof (prove)\nusing this:\n  tree_invar (Node e1 a1 nat ts1)\n  tree_invar (Node e2 a2 nat ts2)\n  t = link (Node e1 a1 nat ts1) (Node e2 a2 nat ts2) \\<or>\n  t = skewlink e' a' (Node e1 a1 nat ts1) (Node e2 a2 nat ts2)\n  invar (rev (filter (\\<lambda>t. 0 < rank t) ts2))\n  \\<lbrakk>invar (rev (filter (\\<lambda>t. 0 < rank t) ts2));\n   \\<forall>t\\<in>set (rev (filter (\\<lambda>t. 0 < rank t) ts2)).\n      rank t < rank (Node e1 a1 nat ts1);\n   tree_invar (Node e1 a1 nat ts1)\\<rbrakk>\n  \\<Longrightarrow> invar\n                     (rev (filter (\\<lambda>t. 0 < rank t) ts2) @\n                      [Node e1 a1 nat ts1])\n  \\<forall>t\\<in>set (rev (filter (\\<lambda>t. 0 < rank t) ts2)).\n     rank t < rank (Node e1 a1 nat ts1)\n\ngoal (1 subgoal):\n 1. invar (rev (filter (\\<lambda>t. 0 < rank t) ts2) @ [Node e1 a1 nat ts1])", "by simp"], ["proof (state)\nthis:\n  invar (rev (filter (\\<lambda>t. 0 < rank t) ts2) @ [Node e1 a1 nat ts1])\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       nat = Suc nat \\<Longrightarrow>\n       invar (rev (filter (\\<lambda>t. 0 < rank t) (children t)))", "with Suc'"], ["proof (chain)\npicking this:\n  nat = Suc n\n  invar (rev (filter (\\<lambda>t. 0 < rank t) ts2) @ [Node e1 a1 nat ts1])", "have p2: \"invar (rev [t \\<leftarrow> ((Node e1 a1 nat ts1) # ts2). 0 < rank t])\""], ["proof (prove)\nusing this:\n  nat = Suc n\n  invar (rev (filter (\\<lambda>t. 0 < rank t) ts2) @ [Node e1 a1 nat ts1])\n\ngoal (1 subgoal):\n 1. invar (rev (filter (\\<lambda>t. 0 < rank t) (Node e1 a1 nat ts1 # ts2)))", "by simp"], ["proof (state)\nthis:\n  invar (rev (filter (\\<lambda>t. 0 < rank t) (Node e1 a1 nat ts1 # ts2)))\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       nat = Suc nat \\<Longrightarrow>\n       invar (rev (filter (\\<lambda>t. 0 < rank t) (children t)))", "from O(1-2)"], ["proof (chain)\npicking this:\n  tree_invar (Node e1 a1 nat ts1)\n  tree_invar (Node e2 a2 nat ts2)", "have p3: \"invar (rev (filter (\\<lambda> t. 0 < rank t)\n                                 [(Node e1 a1 nat ts1), (Node e2 a2 nat ts2)]))\""], ["proof (prove)\nusing this:\n  tree_invar (Node e1 a1 nat ts1)\n  tree_invar (Node e2 a2 nat ts2)\n\ngoal (1 subgoal):\n 1. invar\n     (rev (filter (\\<lambda>t. 0 < rank t)\n            [Node e1 a1 nat ts1, Node e2 a2 nat ts2]))", "by (simp add: invar_def)"], ["proof (state)\nthis:\n  invar\n   (rev (filter (\\<lambda>t. 0 < rank t)\n          [Node e1 a1 nat ts1, Node e2 a2 nat ts2]))\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       nat = Suc nat \\<Longrightarrow>\n       invar (rev (filter (\\<lambda>t. 0 < rank t) (children t)))", "from p1"], ["proof (chain)\npicking this:\n  invar (rev (filter (\\<lambda>t. 0 < rank t) (Node e2 a2 nat ts2 # ts1)))", "have p4: \"invar (rev \n           [t \\<leftarrow> ((Node e' a' 0 []) # (Node e2 a2 nat ts2) # ts1). 0 < rank t])\""], ["proof (prove)\nusing this:\n  invar (rev (filter (\\<lambda>t. 0 < rank t) (Node e2 a2 nat ts2 # ts1)))\n\ngoal (1 subgoal):\n 1. invar\n     (rev (filter (\\<lambda>t. 0 < rank t)\n            (Node e' a' 0 [] # Node e2 a2 nat ts2 # ts1)))", "by simp"], ["proof (state)\nthis:\n  invar\n   (rev (filter (\\<lambda>t. 0 < rank t)\n          (Node e' a' 0 [] # Node e2 a2 nat ts2 # ts1)))\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       nat = Suc nat \\<Longrightarrow>\n       invar (rev (filter (\\<lambda>t. 0 < rank t) (children t)))", "from p2"], ["proof (chain)\npicking this:\n  invar (rev (filter (\\<lambda>t. 0 < rank t) (Node e1 a1 nat ts1 # ts2)))", "have p5: \"invar (rev \n           [t \\<leftarrow> ((Node e' a' 0 []) # (Node e1 a1 nat ts1) # ts2). 0 < rank t])\""], ["proof (prove)\nusing this:\n  invar (rev (filter (\\<lambda>t. 0 < rank t) (Node e1 a1 nat ts1 # ts2)))\n\ngoal (1 subgoal):\n 1. invar\n     (rev (filter (\\<lambda>t. 0 < rank t)\n            (Node e' a' 0 [] # Node e1 a1 nat ts1 # ts2)))", "by simp"], ["proof (state)\nthis:\n  invar\n   (rev (filter (\\<lambda>t. 0 < rank t)\n          (Node e' a' 0 [] # Node e1 a1 nat ts1 # ts2)))\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       nat = Suc nat \\<Longrightarrow>\n       invar (rev (filter (\\<lambda>t. 0 < rank t) (children t)))", "from p1 p2 p3 p4 p5 ch_id"], ["proof (chain)\npicking this:\n  invar (rev (filter (\\<lambda>t. 0 < rank t) (Node e2 a2 nat ts2 # ts1)))\n  invar (rev (filter (\\<lambda>t. 0 < rank t) (Node e1 a1 nat ts1 # ts2)))\n  invar\n   (rev (filter (\\<lambda>t. 0 < rank t)\n          [Node e1 a1 nat ts1, Node e2 a2 nat ts2]))\n  invar\n   (rev (filter (\\<lambda>t. 0 < rank t)\n          (Node e' a' 0 [] # Node e2 a2 nat ts2 # ts1)))\n  invar\n   (rev (filter (\\<lambda>t. 0 < rank t)\n          (Node e' a' 0 [] # Node e1 a1 nat ts1 # ts2)))\n  children t =\n  (if a1 \\<le> a2 then Node e2 a2 nat ts2 # ts1\n   else Node e1 a1 nat ts1 # ts2) \\<or>\n  children t =\n  (if a' \\<le> a1 \\<and> a' \\<le> a2\n   then [Node e1 a1 nat ts1, Node e2 a2 nat ts2]\n   else if a1 \\<le> a2 then Node e' a' 0 [] # Node e2 a2 nat ts2 # ts1\n        else Node e' a' 0 [] # Node e1 a1 nat ts1 # ts2)", "show \n        \"invar (rev [t\\<leftarrow>children t . 0 < rank t])\""], ["proof (prove)\nusing this:\n  invar (rev (filter (\\<lambda>t. 0 < rank t) (Node e2 a2 nat ts2 # ts1)))\n  invar (rev (filter (\\<lambda>t. 0 < rank t) (Node e1 a1 nat ts1 # ts2)))\n  invar\n   (rev (filter (\\<lambda>t. 0 < rank t)\n          [Node e1 a1 nat ts1, Node e2 a2 nat ts2]))\n  invar\n   (rev (filter (\\<lambda>t. 0 < rank t)\n          (Node e' a' 0 [] # Node e2 a2 nat ts2 # ts1)))\n  invar\n   (rev (filter (\\<lambda>t. 0 < rank t)\n          (Node e' a' 0 [] # Node e1 a1 nat ts1 # ts2)))\n  children t =\n  (if a1 \\<le> a2 then Node e2 a2 nat ts2 # ts1\n   else Node e1 a1 nat ts1 # ts2) \\<or>\n  children t =\n  (if a' \\<le> a1 \\<and> a' \\<le> a2\n   then [Node e1 a1 nat ts1, Node e2 a2 nat ts2]\n   else if a1 \\<le> a2 then Node e' a' 0 [] # Node e2 a2 nat ts2 # ts1\n        else Node e' a' 0 [] # Node e1 a1 nat ts1 # ts2)\n\ngoal (1 subgoal):\n 1. invar (rev (filter (\\<lambda>t. 0 < rank t) (children t)))", "by (cases \"children t = (if a1 \\<le> a2 then (Node e2 a2 nat ts2)#ts1 \n                                else (Node e1 a1 nat ts1)#ts2)\") metis+"], ["proof (state)\nthis:\n  invar (rev (filter (\\<lambda>t. 0 < rank t) (children t)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  invar (rev (filter (\\<lambda>t. 0 < rank t) (children t)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  invar (rev (filter (\\<lambda>t. 0 < rank t) (children t)))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma first_less: \"rank_invar (t # bq) \\<Longrightarrow> \\<forall>t' \\<in> set bq. rank t < rank t'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rank_invar (t # bq) \\<Longrightarrow>\n    \\<forall>t'\\<in>set bq. rank t < rank t'", "apply(induct bq arbitrary: t)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>t.\n       rank_invar [t] \\<Longrightarrow>\n       \\<forall>t'\\<in>set []. rank t < rank t'\n 2. \\<And>a bq t.\n       \\<lbrakk>\\<And>t.\n                   rank_invar (t # bq) \\<Longrightarrow>\n                   \\<forall>t'\\<in>set bq. rank t < rank t';\n        rank_invar (t # a # bq)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>t'\\<in>set (a # bq). rank t < rank t'", "apply (simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a bq t.\n       \\<lbrakk>\\<And>t.\n                   rank_invar (t # bq) \\<Longrightarrow>\n                   \\<forall>t'\\<in>set bq. rank t < rank t';\n        rank_invar (t # a # bq)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>t'\\<in>set (a # bq). rank t < rank t'", "apply (metis List.set_simps(2) insert_iff not_le_imp_less \n    not_less_iff_gr_or_eq order_less_le_trans rank_invar.simps(3) \n    rank_invar_cons_down)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma first_less_eq: \n  \"rank_skew_invar (t # bq) \\<Longrightarrow> \\<forall>t' \\<in> set bq. rank t \\<le> rank t'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rank_skew_invar (t # bq) \\<Longrightarrow>\n    \\<forall>t'\\<in>set bq. rank t \\<le> rank t'", "apply(induct bq arbitrary: t)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>t.\n       rank_skew_invar [t] \\<Longrightarrow>\n       \\<forall>t'\\<in>set []. rank t \\<le> rank t'\n 2. \\<And>a bq t.\n       \\<lbrakk>\\<And>t.\n                   rank_skew_invar (t # bq) \\<Longrightarrow>\n                   \\<forall>t'\\<in>set bq. rank t \\<le> rank t';\n        rank_skew_invar (t # a # bq)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>t'\\<in>set (a # bq). rank t \\<le> rank t'", "apply (simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a bq t.\n       \\<lbrakk>\\<And>t.\n                   rank_skew_invar (t # bq) \\<Longrightarrow>\n                   \\<forall>t'\\<in>set bq. rank t \\<le> rank t';\n        rank_skew_invar (t # a # bq)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>t'\\<in>set (a # bq). rank t \\<le> rank t'", "apply (metis List.set_simps(2) insert_iff le_trans\n    rank_invar_rank_skew rank_skew_invar.simps(3) rank_skew_rank_invar)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma remove1_tail_invar: \"tail_invar bq \\<Longrightarrow> tail_invar (remove1 t bq)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tail_invar bq \\<Longrightarrow> tail_invar (remove1 t bq)", "proof (induct bq arbitrary: t)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>t. tail_invar [] \\<Longrightarrow> tail_invar (remove1 t [])\n 2. \\<And>a bq t.\n       \\<lbrakk>\\<And>t.\n                   tail_invar bq \\<Longrightarrow>\n                   tail_invar (remove1 t bq);\n        tail_invar (a # bq)\\<rbrakk>\n       \\<Longrightarrow> tail_invar (remove1 t (a # bq))", "case Nil"], ["proof (state)\nthis:\n  tail_invar []\n\ngoal (2 subgoals):\n 1. \\<And>t. tail_invar [] \\<Longrightarrow> tail_invar (remove1 t [])\n 2. \\<And>a bq t.\n       \\<lbrakk>\\<And>t.\n                   tail_invar bq \\<Longrightarrow>\n                   tail_invar (remove1 t bq);\n        tail_invar (a # bq)\\<rbrakk>\n       \\<Longrightarrow> tail_invar (remove1 t (a # bq))", "then"], ["proof (chain)\npicking this:\n  tail_invar []", "show ?case"], ["proof (prove)\nusing this:\n  tail_invar []\n\ngoal (1 subgoal):\n 1. tail_invar (remove1 t [])", "by simp"], ["proof (state)\nthis:\n  tail_invar (remove1 t [])\n\ngoal (1 subgoal):\n 1. \\<And>a bq t.\n       \\<lbrakk>\\<And>t.\n                   tail_invar bq \\<Longrightarrow>\n                   tail_invar (remove1 t bq);\n        tail_invar (a # bq)\\<rbrakk>\n       \\<Longrightarrow> tail_invar (remove1 t (a # bq))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a bq t.\n       \\<lbrakk>\\<And>t.\n                   tail_invar bq \\<Longrightarrow>\n                   tail_invar (remove1 t bq);\n        tail_invar (a # bq)\\<rbrakk>\n       \\<Longrightarrow> tail_invar (remove1 t (a # bq))", "case (Cons a bq)"], ["proof (state)\nthis:\n  tail_invar bq \\<Longrightarrow> tail_invar (remove1 ?t bq)\n  tail_invar (a # bq)\n\ngoal (1 subgoal):\n 1. \\<And>a bq t.\n       \\<lbrakk>\\<And>t.\n                   tail_invar bq \\<Longrightarrow>\n                   tail_invar (remove1 t bq);\n        tail_invar (a # bq)\\<rbrakk>\n       \\<Longrightarrow> tail_invar (remove1 t (a # bq))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. tail_invar (remove1 t (a # bq))", "proof (cases \"t = a\")"], ["proof (state)\ngoal (2 subgoals):\n 1. t = a \\<Longrightarrow> tail_invar (remove1 t (a # bq))\n 2. t \\<noteq> a \\<Longrightarrow> tail_invar (remove1 t (a # bq))", "case True"], ["proof (state)\nthis:\n  t = a\n\ngoal (2 subgoals):\n 1. t = a \\<Longrightarrow> tail_invar (remove1 t (a # bq))\n 2. t \\<noteq> a \\<Longrightarrow> tail_invar (remove1 t (a # bq))", "from Cons(2)"], ["proof (chain)\npicking this:\n  tail_invar (a # bq)", "have \"tail_invar bq\""], ["proof (prove)\nusing this:\n  tail_invar (a # bq)\n\ngoal (1 subgoal):\n 1. tail_invar bq", "by (rule tail_invar_cons_down)"], ["proof (state)\nthis:\n  tail_invar bq\n\ngoal (2 subgoals):\n 1. t = a \\<Longrightarrow> tail_invar (remove1 t (a # bq))\n 2. t \\<noteq> a \\<Longrightarrow> tail_invar (remove1 t (a # bq))", "with True"], ["proof (chain)\npicking this:\n  t = a\n  tail_invar bq", "show ?thesis"], ["proof (prove)\nusing this:\n  t = a\n  tail_invar bq\n\ngoal (1 subgoal):\n 1. tail_invar (remove1 t (a # bq))", "by simp"], ["proof (state)\nthis:\n  tail_invar (remove1 t (a # bq))\n\ngoal (1 subgoal):\n 1. t \\<noteq> a \\<Longrightarrow> tail_invar (remove1 t (a # bq))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. t \\<noteq> a \\<Longrightarrow> tail_invar (remove1 t (a # bq))", "case False"], ["proof (state)\nthis:\n  t \\<noteq> a\n\ngoal (1 subgoal):\n 1. t \\<noteq> a \\<Longrightarrow> tail_invar (remove1 t (a # bq))", "from Cons(2)"], ["proof (chain)\npicking this:\n  tail_invar (a # bq)", "have \"tail_invar bq\""], ["proof (prove)\nusing this:\n  tail_invar (a # bq)\n\ngoal (1 subgoal):\n 1. tail_invar bq", "by (rule tail_invar_cons_down)"], ["proof (state)\nthis:\n  tail_invar bq\n\ngoal (1 subgoal):\n 1. t \\<noteq> a \\<Longrightarrow> tail_invar (remove1 t (a # bq))", "with Cons(1)[of \"t\"]"], ["proof (chain)\npicking this:\n  tail_invar bq \\<Longrightarrow> tail_invar (remove1 t bq)\n  tail_invar bq", "have si1: \"tail_invar (remove1 t bq)\""], ["proof (prove)\nusing this:\n  tail_invar bq \\<Longrightarrow> tail_invar (remove1 t bq)\n  tail_invar bq\n\ngoal (1 subgoal):\n 1. tail_invar (remove1 t bq)", "."], ["proof (state)\nthis:\n  tail_invar (remove1 t bq)\n\ngoal (1 subgoal):\n 1. t \\<noteq> a \\<Longrightarrow> tail_invar (remove1 t (a # bq))", "from False"], ["proof (chain)\npicking this:\n  t \\<noteq> a", "have \"tail_invar (remove1 t (a # bq)) = tail_invar (a # (remove1 t bq))\""], ["proof (prove)\nusing this:\n  t \\<noteq> a\n\ngoal (1 subgoal):\n 1. tail_invar (remove1 t (a # bq)) = tail_invar (a # remove1 t bq)", "by simp"], ["proof (state)\nthis:\n  tail_invar (remove1 t (a # bq)) = tail_invar (a # remove1 t bq)\n\ngoal (1 subgoal):\n 1. t \\<noteq> a \\<Longrightarrow> tail_invar (remove1 t (a # bq))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. tail_invar (remove1 t (a # bq))", "proof (cases \"remove1 t bq\")"], ["proof (state)\ngoal (2 subgoals):\n 1. remove1 t bq = [] \\<Longrightarrow> tail_invar (remove1 t (a # bq))\n 2. \\<And>aa list.\n       remove1 t bq = aa # list \\<Longrightarrow>\n       tail_invar (remove1 t (a # bq))", "case Nil"], ["proof (state)\nthis:\n  remove1 t bq = []\n\ngoal (2 subgoals):\n 1. remove1 t bq = [] \\<Longrightarrow> tail_invar (remove1 t (a # bq))\n 2. \\<And>aa list.\n       remove1 t bq = aa # list \\<Longrightarrow>\n       tail_invar (remove1 t (a # bq))", "with si1 Cons(2) False"], ["proof (chain)\npicking this:\n  tail_invar (remove1 t bq)\n  tail_invar (a # bq)\n  t \\<noteq> a\n  remove1 t bq = []", "show ?thesis"], ["proof (prove)\nusing this:\n  tail_invar (remove1 t bq)\n  tail_invar (a # bq)\n  t \\<noteq> a\n  remove1 t bq = []\n\ngoal (1 subgoal):\n 1. tail_invar (remove1 t (a # bq))", "by (simp add: tail_invar_def)"], ["proof (state)\nthis:\n  tail_invar (remove1 t (a # bq))\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       remove1 t bq = aa # list \\<Longrightarrow>\n       tail_invar (remove1 t (a # bq))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       remove1 t bq = aa # list \\<Longrightarrow>\n       tail_invar (remove1 t (a # bq))", "case Cons': (Cons aa list)"], ["proof (state)\nthis:\n  remove1 t bq = aa # list\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       remove1 t bq = aa # list \\<Longrightarrow>\n       tail_invar (remove1 t (a # bq))", "from Cons(2)"], ["proof (chain)\npicking this:\n  tail_invar (a # bq)", "have \"tree_invar a\""], ["proof (prove)\nusing this:\n  tail_invar (a # bq)\n\ngoal (1 subgoal):\n 1. tree_invar a", "by (simp add: tail_invar_def)"], ["proof (state)\nthis:\n  tree_invar a\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       remove1 t bq = aa # list \\<Longrightarrow>\n       tail_invar (remove1 t (a # bq))", "from Cons(2) first_less[of \"a\" \"bq\"]"], ["proof (chain)\npicking this:\n  tail_invar (a # bq)\n  rank_invar (a # bq) \\<Longrightarrow>\n  \\<forall>t'\\<in>set bq. rank a < rank t'", "have \"\\<forall>t \\<in> set (remove1 t bq). rank a < rank t\""], ["proof (prove)\nusing this:\n  tail_invar (a # bq)\n  rank_invar (a # bq) \\<Longrightarrow>\n  \\<forall>t'\\<in>set bq. rank a < rank t'\n\ngoal (1 subgoal):\n 1. \\<forall>t\\<in>set (remove1 t bq). rank a < rank t", "by (metis notin_set_remove1 tail_invar_def)"], ["proof (state)\nthis:\n  \\<forall>t\\<in>set (remove1 t bq). rank a < rank t\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       remove1 t bq = aa # list \\<Longrightarrow>\n       tail_invar (remove1 t (a # bq))", "with Cons'"], ["proof (chain)\npicking this:\n  remove1 t bq = aa # list\n  \\<forall>t\\<in>set (remove1 t bq). rank a < rank t", "have \"rank a < rank aa\""], ["proof (prove)\nusing this:\n  remove1 t bq = aa # list\n  \\<forall>t\\<in>set (remove1 t bq). rank a < rank t\n\ngoal (1 subgoal):\n 1. rank a < rank aa", "by simp"], ["proof (state)\nthis:\n  rank a < rank aa\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       remove1 t bq = aa # list \\<Longrightarrow>\n       tail_invar (remove1 t (a # bq))", "with si1 Cons(2) False Cons' tail_invar_cons_up[of \"aa\" \"list\" \"a\"]"], ["proof (chain)\npicking this:\n  tail_invar (remove1 t bq)\n  tail_invar (a # bq)\n  t \\<noteq> a\n  remove1 t bq = aa # list\n  \\<lbrakk>tail_invar (aa # list); rank a < rank aa; tree_invar a\\<rbrakk>\n  \\<Longrightarrow> tail_invar (a # aa # list)\n  rank a < rank aa", "show ?thesis"], ["proof (prove)\nusing this:\n  tail_invar (remove1 t bq)\n  tail_invar (a # bq)\n  t \\<noteq> a\n  remove1 t bq = aa # list\n  \\<lbrakk>tail_invar (aa # list); rank a < rank aa; tree_invar a\\<rbrakk>\n  \\<Longrightarrow> tail_invar (a # aa # list)\n  rank a < rank aa\n\ngoal (1 subgoal):\n 1. tail_invar (remove1 t (a # bq))", "by (simp add: tail_invar_def)"], ["proof (state)\nthis:\n  tail_invar (remove1 t (a # bq))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  tail_invar (remove1 t (a # bq))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  tail_invar (remove1 t (a # bq))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma invar_cons_down: \"invar (t # bq) \\<Longrightarrow> invar bq\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invar (t # bq) \\<Longrightarrow> invar bq", "by (metis rank_invar_rank_skew tail_invar_def \n    invar_def invar_tail_invar)"], ["", "lemma remove1_invar: \"invar bq \\<Longrightarrow> invar (remove1 t bq)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invar bq \\<Longrightarrow> invar (remove1 t bq)", "proof (induct bq arbitrary: t)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>t. invar [] \\<Longrightarrow> invar (remove1 t [])\n 2. \\<And>a bq t.\n       \\<lbrakk>\\<And>t. invar bq \\<Longrightarrow> invar (remove1 t bq);\n        invar (a # bq)\\<rbrakk>\n       \\<Longrightarrow> invar (remove1 t (a # bq))", "case Nil"], ["proof (state)\nthis:\n  invar []\n\ngoal (2 subgoals):\n 1. \\<And>t. invar [] \\<Longrightarrow> invar (remove1 t [])\n 2. \\<And>a bq t.\n       \\<lbrakk>\\<And>t. invar bq \\<Longrightarrow> invar (remove1 t bq);\n        invar (a # bq)\\<rbrakk>\n       \\<Longrightarrow> invar (remove1 t (a # bq))", "then"], ["proof (chain)\npicking this:\n  invar []", "show ?case"], ["proof (prove)\nusing this:\n  invar []\n\ngoal (1 subgoal):\n 1. invar (remove1 t [])", "by simp"], ["proof (state)\nthis:\n  invar (remove1 t [])\n\ngoal (1 subgoal):\n 1. \\<And>a bq t.\n       \\<lbrakk>\\<And>t. invar bq \\<Longrightarrow> invar (remove1 t bq);\n        invar (a # bq)\\<rbrakk>\n       \\<Longrightarrow> invar (remove1 t (a # bq))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a bq t.\n       \\<lbrakk>\\<And>t. invar bq \\<Longrightarrow> invar (remove1 t bq);\n        invar (a # bq)\\<rbrakk>\n       \\<Longrightarrow> invar (remove1 t (a # bq))", "case (Cons a bq)"], ["proof (state)\nthis:\n  invar bq \\<Longrightarrow> invar (remove1 ?t bq)\n  invar (a # bq)\n\ngoal (1 subgoal):\n 1. \\<And>a bq t.\n       \\<lbrakk>\\<And>t. invar bq \\<Longrightarrow> invar (remove1 t bq);\n        invar (a # bq)\\<rbrakk>\n       \\<Longrightarrow> invar (remove1 t (a # bq))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. invar (remove1 t (a # bq))", "proof (cases \"t = a\")"], ["proof (state)\ngoal (2 subgoals):\n 1. t = a \\<Longrightarrow> invar (remove1 t (a # bq))\n 2. t \\<noteq> a \\<Longrightarrow> invar (remove1 t (a # bq))", "case True"], ["proof (state)\nthis:\n  t = a\n\ngoal (2 subgoals):\n 1. t = a \\<Longrightarrow> invar (remove1 t (a # bq))\n 2. t \\<noteq> a \\<Longrightarrow> invar (remove1 t (a # bq))", "from Cons(2)"], ["proof (chain)\npicking this:\n  invar (a # bq)", "have \"invar bq\""], ["proof (prove)\nusing this:\n  invar (a # bq)\n\ngoal (1 subgoal):\n 1. invar bq", "by (rule invar_cons_down)"], ["proof (state)\nthis:\n  invar bq\n\ngoal (2 subgoals):\n 1. t = a \\<Longrightarrow> invar (remove1 t (a # bq))\n 2. t \\<noteq> a \\<Longrightarrow> invar (remove1 t (a # bq))", "with True"], ["proof (chain)\npicking this:\n  t = a\n  invar bq", "show ?thesis"], ["proof (prove)\nusing this:\n  t = a\n  invar bq\n\ngoal (1 subgoal):\n 1. invar (remove1 t (a # bq))", "by simp"], ["proof (state)\nthis:\n  invar (remove1 t (a # bq))\n\ngoal (1 subgoal):\n 1. t \\<noteq> a \\<Longrightarrow> invar (remove1 t (a # bq))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. t \\<noteq> a \\<Longrightarrow> invar (remove1 t (a # bq))", "case False"], ["proof (state)\nthis:\n  t \\<noteq> a\n\ngoal (1 subgoal):\n 1. t \\<noteq> a \\<Longrightarrow> invar (remove1 t (a # bq))", "from Cons(2)"], ["proof (chain)\npicking this:\n  invar (a # bq)", "have \"invar bq\""], ["proof (prove)\nusing this:\n  invar (a # bq)\n\ngoal (1 subgoal):\n 1. invar bq", "by (rule invar_cons_down)"], ["proof (state)\nthis:\n  invar bq\n\ngoal (1 subgoal):\n 1. t \\<noteq> a \\<Longrightarrow> invar (remove1 t (a # bq))", "with Cons(1)[of \"t\"]"], ["proof (chain)\npicking this:\n  invar bq \\<Longrightarrow> invar (remove1 t bq)\n  invar bq", "have si1: \"invar (remove1 t bq)\""], ["proof (prove)\nusing this:\n  invar bq \\<Longrightarrow> invar (remove1 t bq)\n  invar bq\n\ngoal (1 subgoal):\n 1. invar (remove1 t bq)", "."], ["proof (state)\nthis:\n  invar (remove1 t bq)\n\ngoal (1 subgoal):\n 1. t \\<noteq> a \\<Longrightarrow> invar (remove1 t (a # bq))", "from False"], ["proof (chain)\npicking this:\n  t \\<noteq> a", "have \"invar (remove1 t (a # bq)) = invar (a # (remove1 t bq))\""], ["proof (prove)\nusing this:\n  t \\<noteq> a\n\ngoal (1 subgoal):\n 1. invar (remove1 t (a # bq)) = invar (a # remove1 t bq)", "by simp"], ["proof (state)\nthis:\n  invar (remove1 t (a # bq)) = invar (a # remove1 t bq)\n\ngoal (1 subgoal):\n 1. t \\<noteq> a \\<Longrightarrow> invar (remove1 t (a # bq))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. invar (remove1 t (a # bq))", "proof (cases \"remove1 t bq\")"], ["proof (state)\ngoal (2 subgoals):\n 1. remove1 t bq = [] \\<Longrightarrow> invar (remove1 t (a # bq))\n 2. \\<And>aa list.\n       remove1 t bq = aa # list \\<Longrightarrow> invar (remove1 t (a # bq))", "case Nil"], ["proof (state)\nthis:\n  remove1 t bq = []\n\ngoal (2 subgoals):\n 1. remove1 t bq = [] \\<Longrightarrow> invar (remove1 t (a # bq))\n 2. \\<And>aa list.\n       remove1 t bq = aa # list \\<Longrightarrow> invar (remove1 t (a # bq))", "with si1 Cons(2) False"], ["proof (chain)\npicking this:\n  invar (remove1 t bq)\n  invar (a # bq)\n  t \\<noteq> a\n  remove1 t bq = []", "show ?thesis"], ["proof (prove)\nusing this:\n  invar (remove1 t bq)\n  invar (a # bq)\n  t \\<noteq> a\n  remove1 t bq = []\n\ngoal (1 subgoal):\n 1. invar (remove1 t (a # bq))", "by (simp add: invar_def)"], ["proof (state)\nthis:\n  invar (remove1 t (a # bq))\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       remove1 t bq = aa # list \\<Longrightarrow> invar (remove1 t (a # bq))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       remove1 t bq = aa # list \\<Longrightarrow> invar (remove1 t (a # bq))", "case Cons': (Cons aa list)"], ["proof (state)\nthis:\n  remove1 t bq = aa # list\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       remove1 t bq = aa # list \\<Longrightarrow> invar (remove1 t (a # bq))", "from Cons(2)"], ["proof (chain)\npicking this:\n  invar (a # bq)", "have ti: \"tree_invar a\""], ["proof (prove)\nusing this:\n  invar (a # bq)\n\ngoal (1 subgoal):\n 1. tree_invar a", "by (simp add: invar_def)"], ["proof (state)\nthis:\n  tree_invar a\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       remove1 t bq = aa # list \\<Longrightarrow> invar (remove1 t (a # bq))", "from Cons(2)"], ["proof (chain)\npicking this:\n  invar (a # bq)", "have sbq: \"tail_invar bq\""], ["proof (prove)\nusing this:\n  invar (a # bq)\n\ngoal (1 subgoal):\n 1. tail_invar bq", "by (metis invar_tail_invar)"], ["proof (state)\nthis:\n  tail_invar bq\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       remove1 t bq = aa # list \\<Longrightarrow> invar (remove1 t (a # bq))", "hence srm: \"tail_invar (remove1 t bq)\""], ["proof (prove)\nusing this:\n  tail_invar bq\n\ngoal (1 subgoal):\n 1. tail_invar (remove1 t bq)", "by (metis remove1_tail_invar)"], ["proof (state)\nthis:\n  tail_invar (remove1 t bq)\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       remove1 t bq = aa # list \\<Longrightarrow> invar (remove1 t (a # bq))", "from Cons(2) first_less_eq[of \"a\" \"bq\"]"], ["proof (chain)\npicking this:\n  invar (a # bq)\n  rank_skew_invar (a # bq) \\<Longrightarrow>\n  \\<forall>t'\\<in>set bq. rank a \\<le> rank t'", "have \"\\<forall>t \\<in> set (remove1 t bq). rank a \\<le> rank t\""], ["proof (prove)\nusing this:\n  invar (a # bq)\n  rank_skew_invar (a # bq) \\<Longrightarrow>\n  \\<forall>t'\\<in>set bq. rank a \\<le> rank t'\n\ngoal (1 subgoal):\n 1. \\<forall>t\\<in>set (remove1 t bq). rank a \\<le> rank t", "by (metis notin_set_remove1 invar_def)"], ["proof (state)\nthis:\n  \\<forall>t\\<in>set (remove1 t bq). rank a \\<le> rank t\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       remove1 t bq = aa # list \\<Longrightarrow> invar (remove1 t (a # bq))", "with Cons'"], ["proof (chain)\npicking this:\n  remove1 t bq = aa # list\n  \\<forall>t\\<in>set (remove1 t bq). rank a \\<le> rank t", "have \"rank a \\<le> rank aa\""], ["proof (prove)\nusing this:\n  remove1 t bq = aa # list\n  \\<forall>t\\<in>set (remove1 t bq). rank a \\<le> rank t\n\ngoal (1 subgoal):\n 1. rank a \\<le> rank aa", "by simp"], ["proof (state)\nthis:\n  rank a \\<le> rank aa\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       remove1 t bq = aa # list \\<Longrightarrow> invar (remove1 t (a # bq))", "with si1 Cons(2) False Cons' ti srm tail_invar_cons_up_invar[of \"aa\" \"list\" \"a\"]"], ["proof (chain)\npicking this:\n  invar (remove1 t bq)\n  invar (a # bq)\n  t \\<noteq> a\n  remove1 t bq = aa # list\n  tree_invar a\n  tail_invar (remove1 t bq)\n  \\<lbrakk>tail_invar (aa # list); rank a \\<le> rank aa;\n   tree_invar a\\<rbrakk>\n  \\<Longrightarrow> invar (a # aa # list)\n  rank a \\<le> rank aa", "show ?thesis"], ["proof (prove)\nusing this:\n  invar (remove1 t bq)\n  invar (a # bq)\n  t \\<noteq> a\n  remove1 t bq = aa # list\n  tree_invar a\n  tail_invar (remove1 t bq)\n  \\<lbrakk>tail_invar (aa # list); rank a \\<le> rank aa;\n   tree_invar a\\<rbrakk>\n  \\<Longrightarrow> invar (a # aa # list)\n  rank a \\<le> rank aa\n\ngoal (1 subgoal):\n 1. invar (remove1 t (a # bq))", "by simp"], ["proof (state)\nthis:\n  invar (remove1 t (a # bq))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  invar (remove1 t (a # bq))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  invar (remove1 t (a # bq))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma deleteMin_invar:\n  assumes \"invar bq\"\n    and \"bq \\<noteq> []\"\n  shows \"invar (deleteMin bq)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invar (deleteMin bq)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. invar (deleteMin bq)", "have eq: \"invar (deleteMin bq) = \n    invar (insertList\n    (filter (\\<lambda> t. rank t = 0) (children (getMinTree bq)))\n    (meld (rev (filter (\\<lambda> t. rank t > 0) (children (getMinTree bq)))) \n          (remove1 (getMinTree bq) bq)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invar (deleteMin bq) =\n    invar\n     (insertList\n       (filter (\\<lambda>t. rank t = 0) (children (getMinTree bq)))\n       (meld\n         (rev (filter (\\<lambda>t. 0 < rank t) (children (getMinTree bq))))\n         (remove1 (getMinTree bq) bq)))", "by (simp add: deleteMin_def Let_def)"], ["proof (state)\nthis:\n  invar (deleteMin bq) =\n  invar\n   (insertList (filter (\\<lambda>t. rank t = 0) (children (getMinTree bq)))\n     (meld\n       (rev (filter (\\<lambda>t. 0 < rank t) (children (getMinTree bq))))\n       (remove1 (getMinTree bq) bq)))\n\ngoal (1 subgoal):\n 1. invar (deleteMin bq)", "from assms mintree_exists[of \"bq\"]"], ["proof (chain)\npicking this:\n  invar bq\n  bq \\<noteq> []\n  (bq \\<noteq> []) = (getMinTree bq \\<in> set bq)", "have ti: \"tree_invar (getMinTree bq)\""], ["proof (prove)\nusing this:\n  invar bq\n  bq \\<noteq> []\n  (bq \\<noteq> []) = (getMinTree bq \\<in> set bq)\n\ngoal (1 subgoal):\n 1. tree_invar (getMinTree bq)", "by (simp add: invar_def queue_invar_def del: queue_invar_simps)"], ["proof (state)\nthis:\n  tree_invar (getMinTree bq)\n\ngoal (1 subgoal):\n 1. invar (deleteMin bq)", "with strong_rev_children[of \"getMinTree bq\"]"], ["proof (chain)\npicking this:\n  tree_invar (getMinTree bq) \\<Longrightarrow>\n  invar (rev (filter (\\<lambda>t. 0 < rank t) (children (getMinTree bq))))\n  tree_invar (getMinTree bq)", "have \n    m1: \"invar (rev [t \\<leftarrow> children (getMinTree bq). 0 < rank t])\""], ["proof (prove)\nusing this:\n  tree_invar (getMinTree bq) \\<Longrightarrow>\n  invar (rev (filter (\\<lambda>t. 0 < rank t) (children (getMinTree bq))))\n  tree_invar (getMinTree bq)\n\ngoal (1 subgoal):\n 1. invar (rev (filter (\\<lambda>t. 0 < rank t) (children (getMinTree bq))))", "."], ["proof (state)\nthis:\n  invar (rev (filter (\\<lambda>t. 0 < rank t) (children (getMinTree bq))))\n\ngoal (1 subgoal):\n 1. invar (deleteMin bq)", "from remove1_invar[of \"bq\" \"getMinTree bq\"] assms(1)"], ["proof (chain)\npicking this:\n  invar bq \\<Longrightarrow> invar (remove1 (getMinTree bq) bq)\n  invar bq", "have m2: \"invar (remove1 (getMinTree bq) bq)\""], ["proof (prove)\nusing this:\n  invar bq \\<Longrightarrow> invar (remove1 (getMinTree bq) bq)\n  invar bq\n\ngoal (1 subgoal):\n 1. invar (remove1 (getMinTree bq) bq)", "."], ["proof (state)\nthis:\n  invar (remove1 (getMinTree bq) bq)\n\ngoal (1 subgoal):\n 1. invar (deleteMin bq)", "from meld_invar[of \"rev [t \\<leftarrow> children (getMinTree bq). 0 < rank t]\" \n                     \"remove1 (getMinTree bq) bq\"] m1 m2"], ["proof (chain)\npicking this:\n  \\<lbrakk>invar\n            (rev (filter (\\<lambda>t. 0 < rank t)\n                   (children (getMinTree bq))));\n   invar (remove1 (getMinTree bq) bq)\\<rbrakk>\n  \\<Longrightarrow> invar\n                     (meld\n                       (rev (filter (\\<lambda>t. 0 < rank t)\n                              (children (getMinTree bq))))\n                       (remove1 (getMinTree bq) bq))\n  invar (rev (filter (\\<lambda>t. 0 < rank t) (children (getMinTree bq))))\n  invar (remove1 (getMinTree bq) bq)", "have \"invar (meld (rev [t \\<leftarrow> children (getMinTree bq). 0 < rank t]) \n                    (remove1 (getMinTree bq) bq))\""], ["proof (prove)\nusing this:\n  \\<lbrakk>invar\n            (rev (filter (\\<lambda>t. 0 < rank t)\n                   (children (getMinTree bq))));\n   invar (remove1 (getMinTree bq) bq)\\<rbrakk>\n  \\<Longrightarrow> invar\n                     (meld\n                       (rev (filter (\\<lambda>t. 0 < rank t)\n                              (children (getMinTree bq))))\n                       (remove1 (getMinTree bq) bq))\n  invar (rev (filter (\\<lambda>t. 0 < rank t) (children (getMinTree bq))))\n  invar (remove1 (getMinTree bq) bq)\n\ngoal (1 subgoal):\n 1. invar\n     (meld\n       (rev (filter (\\<lambda>t. 0 < rank t) (children (getMinTree bq))))\n       (remove1 (getMinTree bq) bq))", "."], ["proof (state)\nthis:\n  invar\n   (meld (rev (filter (\\<lambda>t. 0 < rank t) (children (getMinTree bq))))\n     (remove1 (getMinTree bq) bq))\n\ngoal (1 subgoal):\n 1. invar (deleteMin bq)", "with insertList_invar[of \n    \"(meld (rev [t\\<leftarrow>children (getMinTree bq) . 0 < rank t]) \n           (remove1 (getMinTree bq) bq))\" \n    \"[t\\<leftarrow>children (getMinTree bq) . rank t = 0]\"]"], ["proof (chain)\npicking this:\n  invar\n   (meld (rev (filter (\\<lambda>t. 0 < rank t) (children (getMinTree bq))))\n     (remove1 (getMinTree bq) bq)) \\<Longrightarrow>\n  invar\n   (insertList (filter (\\<lambda>t. rank t = 0) (children (getMinTree bq)))\n     (meld\n       (rev (filter (\\<lambda>t. 0 < rank t) (children (getMinTree bq))))\n       (remove1 (getMinTree bq) bq)))\n  invar\n   (meld (rev (filter (\\<lambda>t. 0 < rank t) (children (getMinTree bq))))\n     (remove1 (getMinTree bq) bq))", "have \"invar\n   (insertList\n     [t\\<leftarrow>children (getMinTree bq) . rank t = 0]\n     (meld (rev [t\\<leftarrow>children (getMinTree bq) . 0 < rank t])\n       (remove1 (getMinTree bq) bq)))\""], ["proof (prove)\nusing this:\n  invar\n   (meld (rev (filter (\\<lambda>t. 0 < rank t) (children (getMinTree bq))))\n     (remove1 (getMinTree bq) bq)) \\<Longrightarrow>\n  invar\n   (insertList (filter (\\<lambda>t. rank t = 0) (children (getMinTree bq)))\n     (meld\n       (rev (filter (\\<lambda>t. 0 < rank t) (children (getMinTree bq))))\n       (remove1 (getMinTree bq) bq)))\n  invar\n   (meld (rev (filter (\\<lambda>t. 0 < rank t) (children (getMinTree bq))))\n     (remove1 (getMinTree bq) bq))\n\ngoal (1 subgoal):\n 1. invar\n     (insertList\n       (filter (\\<lambda>t. rank t = 0) (children (getMinTree bq)))\n       (meld\n         (rev (filter (\\<lambda>t. 0 < rank t) (children (getMinTree bq))))\n         (remove1 (getMinTree bq) bq)))", "."], ["proof (state)\nthis:\n  invar\n   (insertList (filter (\\<lambda>t. rank t = 0) (children (getMinTree bq)))\n     (meld\n       (rev (filter (\\<lambda>t. 0 < rank t) (children (getMinTree bq))))\n       (remove1 (getMinTree bq) bq)))\n\ngoal (1 subgoal):\n 1. invar (deleteMin bq)", "with eq"], ["proof (chain)\npicking this:\n  invar (deleteMin bq) =\n  invar\n   (insertList (filter (\\<lambda>t. rank t = 0) (children (getMinTree bq)))\n     (meld\n       (rev (filter (\\<lambda>t. 0 < rank t) (children (getMinTree bq))))\n       (remove1 (getMinTree bq) bq)))\n  invar\n   (insertList (filter (\\<lambda>t. rank t = 0) (children (getMinTree bq)))\n     (meld\n       (rev (filter (\\<lambda>t. 0 < rank t) (children (getMinTree bq))))\n       (remove1 (getMinTree bq) bq)))", "show ?thesis"], ["proof (prove)\nusing this:\n  invar (deleteMin bq) =\n  invar\n   (insertList (filter (\\<lambda>t. rank t = 0) (children (getMinTree bq)))\n     (meld\n       (rev (filter (\\<lambda>t. 0 < rank t) (children (getMinTree bq))))\n       (remove1 (getMinTree bq) bq)))\n  invar\n   (insertList (filter (\\<lambda>t. rank t = 0) (children (getMinTree bq)))\n     (meld\n       (rev (filter (\\<lambda>t. 0 < rank t) (children (getMinTree bq))))\n       (remove1 (getMinTree bq) bq)))\n\ngoal (1 subgoal):\n 1. invar (deleteMin bq)", ".."], ["proof (state)\nthis:\n  invar (deleteMin bq)\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem deleteMin_correct:\n  assumes I: \"invar q\"\n    and NE: \"q \\<noteq> Nil\"\n  shows \"invar (deleteMin q)\"\n    and \"queue_to_multiset (deleteMin q) = queue_to_multiset q - {#findMin q#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invar (deleteMin q) &&&\n    queue_to_multiset (deleteMin q) = queue_to_multiset q - {#findMin q#}", "apply (rule deleteMin_invar[OF I NE])"], ["proof (prove)\ngoal (1 subgoal):\n 1. queue_to_multiset (deleteMin q) = queue_to_multiset q - {#findMin q#}", "using deleteMin_mset[of q] I NE"], ["proof (prove)\nusing this:\n  \\<lbrakk>queue_invar q; queue_to_multiset q \\<noteq> {#}\\<rbrakk>\n  \\<Longrightarrow> queue_to_multiset (deleteMin q) =\n                    queue_to_multiset q - {#findMin q#}\n  invar q\n  q \\<noteq> []\n\ngoal (1 subgoal):\n 1. queue_to_multiset (deleteMin q) = queue_to_multiset q - {#findMin q#}", "unfolding invar_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>queue_invar q; queue_to_multiset q \\<noteq> {#}\\<rbrakk>\n  \\<Longrightarrow> queue_to_multiset (deleteMin q) =\n                    queue_to_multiset q - {#findMin q#}\n  queue_invar q \\<and> rank_skew_invar q\n  q \\<noteq> []\n\ngoal (1 subgoal):\n 1. queue_to_multiset (deleteMin q) = queue_to_multiset q - {#findMin q#}", "apply (auto simp add: empty_correct)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*\nfun foldt and foldq where\n  \"foldt f z (Node e a _ q) = f (foldq f z q) e a\" |\n  \"foldq f z [] = z\" |\n  \"foldq f z (t#q) = foldq f (foldt f z t) q\"\n\nlemma fold_plus:\n  \"foldt ((\\<lambda>m e a. m+{#(e,a)#})) zz t + z = foldt ((\\<lambda>m e a. m+{#(e,a)#})) (zz+z) t\"\n  \"foldq ((\\<lambda>m e a. m+{#(e,a)#})) zz q + z = foldq ((\\<lambda>m e a. m+{#(e,a)#})) (zz+z) q\"\n  apply (induct t and q arbitrary: zz and zz \n    rule: tree_to_multiset_queue_to_multiset.induct)\n  apply (auto simp add: union_ac)\n  apply (subst union_ac, simp)\n  done\n\n\nlemma to_mset_fold:\n  fixes t::\"('e,'a::linorder) SkewBinomialTree\" and\n        q::\"('e,'a) SkewBinomialQueue\"\n  shows\n  \"tree_to_multiset t = foldt (\\<lambda>m e a. m+{#(e,a)#}) {#} t\"\n  \"queue_to_multiset q = foldq (\\<lambda>m e a. m+{#(e,a)#}) {#} q\"\n  apply (induct t and q rule: tree_to_multiset_queue_to_multiset.induct)\n  apply (auto simp add: union_ac fold_plus)\n  done\n*)"], ["", "lemmas [simp del] = insert.simps"], ["", "end"], ["", "interpretation SkewBinomialHeapStruc: SkewBinomialHeapStruc_loc"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "subsection \"Bootstrapping\""], ["", "text \\<open>\n  In this section, we implement datastructural bootstrapping, to\n  reduce the complexity of meld-operations to $O(1)$.\n  The bootstrapping also contains a {\\em global root}, caching the\n  minimal element of the queue, and thus also reducing the complexity of\n  findMin-operations to $O(1)$.\n\n  Bootstrapping adds one more level of recursion:\n  An {\\em element} is an entry and a priority queues of elements.\n\n  In the original paper on skew binomial queues \\cite{BrOk96}, higher order \n  functors and recursive structures are used to elegantly implement bootstrapped\n  heaps on top of ordinary heaps. However, such concepts are not supported in\n  Isabelle/HOL, nor in Standard ML. Hence we have to use the \n  ,,much less clean'' \\cite{BrOk96} alternative:  \n  We manually specialize the heap datastructure, and re-implement the functions\n  on the specialized data structure.\n\n  The correctness proofs are done by defining a mapping from teh specialized to \n  the original data structure, and reusing the correctness statements of the \n  original data structure.\n\\<close>"], ["", "subsubsection \"Auxiliary\""], ["", "text \\<open>\n  We first have to state some auxiliary lemmas and functions, mainly\n  about multisets.\n\\<close>"], ["", "(* TODO: Some of these should be moved into the multiset library, they are\n  marked by *MOVE* *)"], ["", "text \\<open>Finding the preimage of an element\\<close>"], ["", "(*MOVE*)"], ["", "lemma in_image_msetE:\n  assumes \"x\\<in>#image_mset f M\"\n  obtains y where \"y\\<in>#M\" \"x=f y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<in># M; x = f y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  x \\<in># image_mset f M\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<in># M; x = f y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "apply (induct M)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>y.\n                \\<lbrakk>y \\<in># {#}; x = f y\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     x \\<in># image_mset f {#}\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<And>xa M.\n       \\<lbrakk>\\<lbrakk>\\<And>y.\n                            \\<lbrakk>y \\<in># M; x = f y\\<rbrakk>\n                            \\<Longrightarrow> thesis;\n                 x \\<in># image_mset f M\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        \\<And>y.\n           \\<lbrakk>y \\<in># add_mset xa M; x = f y\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        x \\<in># image_mset f (add_mset xa M)\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa M.\n       \\<lbrakk>\\<lbrakk>\\<And>y.\n                            \\<lbrakk>y \\<in># M; x = f y\\<rbrakk>\n                            \\<Longrightarrow> thesis;\n                 x \\<in># image_mset f M\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        \\<And>y.\n           \\<lbrakk>y \\<in># add_mset xa M; x = f y\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        x \\<in># image_mset f (add_mset xa M)\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply (force split: if_split_asm)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>Very special lemma for images multisets of pairs, where the second\n  component is a function of the first component\\<close>"], ["", "lemma mset_image_fst_dep_pair_diff_split:\n  \"(\\<forall>e a. (e,a)\\<in>#M \\<longrightarrow> a=f e) \\<Longrightarrow>\n  image_mset fst (M - {#(e, f e)#}) = image_mset fst M - {#e#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>e a.\n       (e, a) \\<in># M \\<longrightarrow> a = f e \\<Longrightarrow>\n    image_mset fst (M - {#(e, f e)#}) = image_mset fst M - {#e#}", "proof (induct M)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>e a.\n       (e, a) \\<in># {#} \\<longrightarrow> a = f e \\<Longrightarrow>\n    image_mset fst ({#} - {#(e, f e)#}) = image_mset fst {#} - {#e#}\n 2. \\<And>x M.\n       \\<lbrakk>\\<forall>e a.\n                   (e, a) \\<in># M \\<longrightarrow>\n                   a = f e \\<Longrightarrow>\n                image_mset fst (M - {#(e, f e)#}) =\n                image_mset fst M - {#e#};\n        \\<forall>e a.\n           (e, a) \\<in># add_mset x M \\<longrightarrow> a = f e\\<rbrakk>\n       \\<Longrightarrow> image_mset fst (add_mset x M - {#(e, f e)#}) =\n                         image_mset fst (add_mset x M) - {#e#}", "case empty"], ["proof (state)\nthis:\n  \\<forall>e a. (e, a) \\<in># {#} \\<longrightarrow> a = f e\n\ngoal (2 subgoals):\n 1. \\<forall>e a.\n       (e, a) \\<in># {#} \\<longrightarrow> a = f e \\<Longrightarrow>\n    image_mset fst ({#} - {#(e, f e)#}) = image_mset fst {#} - {#e#}\n 2. \\<And>x M.\n       \\<lbrakk>\\<forall>e a.\n                   (e, a) \\<in># M \\<longrightarrow>\n                   a = f e \\<Longrightarrow>\n                image_mset fst (M - {#(e, f e)#}) =\n                image_mset fst M - {#e#};\n        \\<forall>e a.\n           (e, a) \\<in># add_mset x M \\<longrightarrow> a = f e\\<rbrakk>\n       \\<Longrightarrow> image_mset fst (add_mset x M - {#(e, f e)#}) =\n                         image_mset fst (add_mset x M) - {#e#}", "thus ?case"], ["proof (prove)\nusing this:\n  \\<forall>e a. (e, a) \\<in># {#} \\<longrightarrow> a = f e\n\ngoal (1 subgoal):\n 1. image_mset fst ({#} - {#(e, f e)#}) = image_mset fst {#} - {#e#}", "by auto"], ["proof (state)\nthis:\n  image_mset fst ({#} - {#(e, f e)#}) = image_mset fst {#} - {#e#}\n\ngoal (1 subgoal):\n 1. \\<And>x M.\n       \\<lbrakk>\\<forall>e a.\n                   (e, a) \\<in># M \\<longrightarrow>\n                   a = f e \\<Longrightarrow>\n                image_mset fst (M - {#(e, f e)#}) =\n                image_mset fst M - {#e#};\n        \\<forall>e a.\n           (e, a) \\<in># add_mset x M \\<longrightarrow> a = f e\\<rbrakk>\n       \\<Longrightarrow> image_mset fst (add_mset x M - {#(e, f e)#}) =\n                         image_mset fst (add_mset x M) - {#e#}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x M.\n       \\<lbrakk>\\<forall>e a.\n                   (e, a) \\<in># M \\<longrightarrow>\n                   a = f e \\<Longrightarrow>\n                image_mset fst (M - {#(e, f e)#}) =\n                image_mset fst M - {#e#};\n        \\<forall>e a.\n           (e, a) \\<in># add_mset x M \\<longrightarrow> a = f e\\<rbrakk>\n       \\<Longrightarrow> image_mset fst (add_mset x M - {#(e, f e)#}) =\n                         image_mset fst (add_mset x M) - {#e#}", "case (add x M)"], ["proof (state)\nthis:\n  \\<forall>e a. (e, a) \\<in># M \\<longrightarrow> a = f e \\<Longrightarrow>\n  image_mset fst (M - {#(e, f e)#}) = image_mset fst M - {#e#}\n  \\<forall>e a. (e, a) \\<in># add_mset x M \\<longrightarrow> a = f e\n\ngoal (1 subgoal):\n 1. \\<And>x M.\n       \\<lbrakk>\\<forall>e a.\n                   (e, a) \\<in># M \\<longrightarrow>\n                   a = f e \\<Longrightarrow>\n                image_mset fst (M - {#(e, f e)#}) =\n                image_mset fst M - {#e#};\n        \\<forall>e a.\n           (e, a) \\<in># add_mset x M \\<longrightarrow> a = f e\\<rbrakk>\n       \\<Longrightarrow> image_mset fst (add_mset x M - {#(e, f e)#}) =\n                         image_mset fst (add_mset x M) - {#e#}", "then"], ["proof (chain)\npicking this:\n  \\<forall>e a. (e, a) \\<in># M \\<longrightarrow> a = f e \\<Longrightarrow>\n  image_mset fst (M - {#(e, f e)#}) = image_mset fst M - {#e#}\n  \\<forall>e a. (e, a) \\<in># add_mset x M \\<longrightarrow> a = f e", "obtain e' where [simp]: \"x=(e',f e')\""], ["proof (prove)\nusing this:\n  \\<forall>e a. (e, a) \\<in># M \\<longrightarrow> a = f e \\<Longrightarrow>\n  image_mset fst (M - {#(e, f e)#}) = image_mset fst M - {#e#}\n  \\<forall>e a. (e, a) \\<in># add_mset x M \\<longrightarrow> a = f e\n\ngoal (1 subgoal):\n 1. (\\<And>e'. x = (e', f e') \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "apply (cases x)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>e'. x = (e', f e') \\<Longrightarrow> thesis;\n        \\<forall>e a.\n           (e, a) \\<in># M \\<longrightarrow> a = f e \\<Longrightarrow>\n        image_mset fst (M - {#(e, f e)#}) = image_mset fst M - {#e#};\n        \\<forall>e a. (e, a) \\<in># add_mset x M \\<longrightarrow> a = f e;\n        x = (a, b)\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply (force)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  x = (e', f e')\n\ngoal (1 subgoal):\n 1. \\<And>x M.\n       \\<lbrakk>\\<forall>e a.\n                   (e, a) \\<in># M \\<longrightarrow>\n                   a = f e \\<Longrightarrow>\n                image_mset fst (M - {#(e, f e)#}) =\n                image_mset fst M - {#e#};\n        \\<forall>e a.\n           (e, a) \\<in># add_mset x M \\<longrightarrow> a = f e\\<rbrakk>\n       \\<Longrightarrow> image_mset fst (add_mset x M - {#(e, f e)#}) =\n                         image_mset fst (add_mset x M) - {#e#}", "from add.prems"], ["proof (chain)\npicking this:\n  \\<forall>e a. (e, a) \\<in># add_mset x M \\<longrightarrow> a = f e", "have \"\\<forall>e a. (e, a) \\<in># M \\<longrightarrow> a = f e\""], ["proof (prove)\nusing this:\n  \\<forall>e a. (e, a) \\<in># add_mset x M \\<longrightarrow> a = f e\n\ngoal (1 subgoal):\n 1. \\<forall>e a. (e, a) \\<in># M \\<longrightarrow> a = f e", "by simp"], ["proof (state)\nthis:\n  \\<forall>e a. (e, a) \\<in># M \\<longrightarrow> a = f e\n\ngoal (1 subgoal):\n 1. \\<And>x M.\n       \\<lbrakk>\\<forall>e a.\n                   (e, a) \\<in># M \\<longrightarrow>\n                   a = f e \\<Longrightarrow>\n                image_mset fst (M - {#(e, f e)#}) =\n                image_mset fst M - {#e#};\n        \\<forall>e a.\n           (e, a) \\<in># add_mset x M \\<longrightarrow> a = f e\\<rbrakk>\n       \\<Longrightarrow> image_mset fst (add_mset x M - {#(e, f e)#}) =\n                         image_mset fst (add_mset x M) - {#e#}", "with add.hyps"], ["proof (chain)\npicking this:\n  \\<forall>e a. (e, a) \\<in># M \\<longrightarrow> a = f e \\<Longrightarrow>\n  image_mset fst (M - {#(e, f e)#}) = image_mset fst M - {#e#}\n  \\<forall>e a. (e, a) \\<in># M \\<longrightarrow> a = f e", "have \n    IH: \"image_mset fst (M - {#(e, f e)#}) = image_mset fst M - {#e#}\""], ["proof (prove)\nusing this:\n  \\<forall>e a. (e, a) \\<in># M \\<longrightarrow> a = f e \\<Longrightarrow>\n  image_mset fst (M - {#(e, f e)#}) = image_mset fst M - {#e#}\n  \\<forall>e a. (e, a) \\<in># M \\<longrightarrow> a = f e\n\ngoal (1 subgoal):\n 1. image_mset fst (M - {#(e, f e)#}) = image_mset fst M - {#e#}", "by auto"], ["proof (state)\nthis:\n  image_mset fst (M - {#(e, f e)#}) = image_mset fst M - {#e#}\n\ngoal (1 subgoal):\n 1. \\<And>x M.\n       \\<lbrakk>\\<forall>e a.\n                   (e, a) \\<in># M \\<longrightarrow>\n                   a = f e \\<Longrightarrow>\n                image_mset fst (M - {#(e, f e)#}) =\n                image_mset fst M - {#e#};\n        \\<forall>e a.\n           (e, a) \\<in># add_mset x M \\<longrightarrow> a = f e\\<rbrakk>\n       \\<Longrightarrow> image_mset fst (add_mset x M - {#(e, f e)#}) =\n                         image_mset fst (add_mset x M) - {#e#}", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. image_mset fst (add_mset x M - {#(e, f e)#}) =\n    image_mset fst (add_mset x M) - {#e#}", "proof (cases \"e=e'\")"], ["proof (state)\ngoal (2 subgoals):\n 1. e = e' \\<Longrightarrow>\n    image_mset fst (add_mset x M - {#(e, f e)#}) =\n    image_mset fst (add_mset x M) - {#e#}\n 2. e \\<noteq> e' \\<Longrightarrow>\n    image_mset fst (add_mset x M - {#(e, f e)#}) =\n    image_mset fst (add_mset x M) - {#e#}", "case True"], ["proof (state)\nthis:\n  e = e'\n\ngoal (2 subgoals):\n 1. e = e' \\<Longrightarrow>\n    image_mset fst (add_mset x M - {#(e, f e)#}) =\n    image_mset fst (add_mset x M) - {#e#}\n 2. e \\<noteq> e' \\<Longrightarrow>\n    image_mset fst (add_mset x M - {#(e, f e)#}) =\n    image_mset fst (add_mset x M) - {#e#}", "thus ?thesis"], ["proof (prove)\nusing this:\n  e = e'\n\ngoal (1 subgoal):\n 1. image_mset fst (add_mset x M - {#(e, f e)#}) =\n    image_mset fst (add_mset x M) - {#e#}", "by (simp)"], ["proof (state)\nthis:\n  image_mset fst (add_mset x M - {#(e, f e)#}) =\n  image_mset fst (add_mset x M) - {#e#}\n\ngoal (1 subgoal):\n 1. e \\<noteq> e' \\<Longrightarrow>\n    image_mset fst (add_mset x M - {#(e, f e)#}) =\n    image_mset fst (add_mset x M) - {#e#}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. e \\<noteq> e' \\<Longrightarrow>\n    image_mset fst (add_mset x M - {#(e, f e)#}) =\n    image_mset fst (add_mset x M) - {#e#}", "case False"], ["proof (state)\nthis:\n  e \\<noteq> e'\n\ngoal (1 subgoal):\n 1. e \\<noteq> e' \\<Longrightarrow>\n    image_mset fst (add_mset x M - {#(e, f e)#}) =\n    image_mset fst (add_mset x M) - {#e#}", "thus ?thesis"], ["proof (prove)\nusing this:\n  e \\<noteq> e'\n\ngoal (1 subgoal):\n 1. image_mset fst (add_mset x M - {#(e, f e)#}) =\n    image_mset fst (add_mset x M) - {#e#}", "by (simp add: IH)"], ["proof (state)\nthis:\n  image_mset fst (add_mset x M - {#(e, f e)#}) =\n  image_mset fst (add_mset x M) - {#e#}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  image_mset fst (add_mset x M - {#(e, f e)#}) =\n  image_mset fst (add_mset x M) - {#e#}\n\ngoal:\nNo subgoals!", "qed"], ["", "locale Bootstrapped\nbegin"], ["", "subsubsection \"Datatype\""], ["", "text \\<open>We manually specialize the binomial tree to contain elements, that, in, \n  turn, may contain trees.\n  Note that we specify nodes without explicit priority,\n  as the priority is contained in the elements stored in the nodes.\n\\<close>"], ["", "datatype ('e, 'a) BsSkewBinomialTree = \n  BsNode (val: \"('e, 'a::linorder) BsSkewElem\")\n        (rank: nat) (children: \"('e , 'a) BsSkewBinomialTree list\")\nand\n('e,'a) BsSkewElem =\n  Element 'e (eprio: 'a) \"('e,'a) BsSkewBinomialTree list\""], ["", "type_synonym ('e,'a) BsSkewHeap = \"unit + ('e,'a) BsSkewElem\""], ["", "type_synonym ('e,'a) BsSkewBinomialQueue = \"('e,'a) BsSkewBinomialTree list\""], ["", "subsubsection \"Specialization Boilerplate\""], ["", "text \\<open>\n  In this section, we re-define the functions\n  on the specialized priority queues, and show there correctness.\n  This is done by defining a mapping to original priority queues,\n  and re-using the correctness lemmas proven there.\n\\<close>"], ["", "text \\<open>Mapping to original binomial trees and queues\\<close>"], ["", "fun bsmapt where\n  \"bsmapt (BsNode e r q) = SkewBinomialHeapStruc.Node e (eprio e) r (map bsmapt q)\""], ["", "abbreviation bsmap where\n  \"bsmap q == map bsmapt q\""], ["", "text \\<open>Invariant and mapping to multiset are defined via the mapping\\<close>"], ["", "abbreviation \"invar q == SkewBinomialHeapStruc.invar (bsmap q)\""], ["", "abbreviation \"queue_to_multiset q \n  == image_mset fst (SkewBinomialHeapStruc.queue_to_multiset (bsmap q))\""], ["", "abbreviation \"tree_to_multiset t\n  == image_mset fst (SkewBinomialHeapStruc.tree_to_multiset (bsmapt t))\""], ["", "abbreviation \"queue_to_multiset_aux q \n  == (SkewBinomialHeapStruc.queue_to_multiset (bsmap q))\""], ["", "text \\<open>Now starts the re-implementation of the functions\\<close>"], ["", "primrec prio :: \"('e, 'a::linorder) BsSkewBinomialTree \\<Rightarrow> 'a\" where\n  \"prio (BsNode e r ts) = eprio e\""], ["", "lemma proj_xlate:\n  \"val t = SkewBinomialHeapStruc.val (bsmapt t)\"\n  \"prio t = SkewBinomialHeapStruc.prio (bsmapt t)\"\n  \"rank t = SkewBinomialHeapStruc.rank (bsmapt t)\"\n  \"bsmap (children t) = SkewBinomialHeapStruc.children (bsmapt t)\"\n  \"eprio (SkewBinomialHeapStruc.val (bsmapt t)) \n   = SkewBinomialHeapStruc.prio (bsmapt t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (val t = SkewBinomialHeapStruc.val (bsmapt t) &&&\n     prio t = SkewBinomialHeapStruc.prio (bsmapt t)) &&&\n    rank t = SkewBinomialHeapStruc.rank (bsmapt t) &&&\n    map bsmapt (children t) = SkewBinomialHeapStruc.children (bsmapt t) &&&\n    eprio (SkewBinomialHeapStruc.val (bsmapt t)) =\n    SkewBinomialHeapStruc.prio (bsmapt t)", "apply (case_tac [!] t)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x1 x2 x3.\n       t = BsNode x1 x2 x3 \\<Longrightarrow>\n       val t = SkewBinomialHeapStruc.val (bsmapt t)\n 2. \\<And>x1 x2 x3.\n       t = BsNode x1 x2 x3 \\<Longrightarrow>\n       prio t = SkewBinomialHeapStruc.prio (bsmapt t)\n 3. \\<And>x1 x2 x3.\n       t = BsNode x1 x2 x3 \\<Longrightarrow>\n       rank t = SkewBinomialHeapStruc.rank (bsmapt t)\n 4. \\<And>x1 x2 x3.\n       t = BsNode x1 x2 x3 \\<Longrightarrow>\n       map bsmapt (children t) = SkewBinomialHeapStruc.children (bsmapt t)\n 5. \\<And>x1 x2 x3.\n       t = BsNode x1 x2 x3 \\<Longrightarrow>\n       eprio (SkewBinomialHeapStruc.val (bsmapt t)) =\n       SkewBinomialHeapStruc.prio (bsmapt t)", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "fun  link :: \"('e, 'a::linorder) BsSkewBinomialTree \n  \\<Rightarrow> ('e, 'a) BsSkewBinomialTree \\<Rightarrow> \n  ('e, 'a) BsSkewBinomialTree\" where\n  \"link (BsNode e1 r1 ts1) (BsNode e2 r2 ts2) = \n   (if  eprio e1\\<le>eprio e2 \n     then (BsNode e1 (Suc r1) ((BsNode e2 r2 ts2)#ts1))\n     else (BsNode e2 (Suc r2) ((BsNode e1 r1 ts1)#ts2)))\""], ["", "text \\<open>Link two trees of rank $r$ and a new element to a new tree of \n  rank $r+1$\\<close>"], ["", "fun skewlink :: \"('e,'a::linorder) BsSkewElem \\<Rightarrow> ('e, 'a) BsSkewBinomialTree \\<Rightarrow> \n  ('e, 'a) BsSkewBinomialTree \\<Rightarrow> ('e, 'a) BsSkewBinomialTree\" where\n  \"skewlink e t t' = (if eprio e \\<le> (prio t) \\<and> eprio e \\<le> (prio t')\n  then (BsNode e (Suc (rank t)) [t,t'])\n  else (if (prio t) \\<le> (prio t') \n   then \n    BsNode (val t) (Suc (rank t))  (BsNode e 0 [] # t' # children t)\n   else \n    BsNode (val t') (Suc (rank t')) (BsNode e 0 [] # t # children t')))\""], ["", "lemma link_xlate:\n  \"bsmapt (link t t') = SkewBinomialHeapStruc.link (bsmapt t) (bsmapt t')\"\n  \"bsmapt (skewlink e t t') = \n     SkewBinomialHeapStruc.skewlink e (eprio e) (bsmapt t) (bsmapt t')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bsmapt (link t t') =\n    SkewBinomialHeapStruc.link (bsmapt t) (bsmapt t') &&&\n    bsmapt (skewlink e t t') =\n    SkewBinomialHeapStruc.skewlink e (eprio e) (bsmapt t) (bsmapt t')", "by (case_tac [!] t, case_tac [!] t') auto"], ["", "fun ins :: \"('e, 'a::linorder) BsSkewBinomialTree \\<Rightarrow> \n  ('e, 'a) BsSkewBinomialQueue \\<Rightarrow> \n  ('e, 'a) BsSkewBinomialQueue\" where\n  \"ins t [] = [t]\" |\n  \"ins t' (t # bq) =\n    (if (rank t') < (rank t) \n      then t' # t # bq \n      else (if (rank t) < (rank t')\n        then t # (ins t' bq) \n        else ins (link t' t) bq))\""], ["", "lemma ins_xlate:\n  \"bsmap (ins t q) = SkewBinomialHeapStruc.ins (bsmapt t) (bsmap q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map bsmapt (ins t q) =\n    SkewBinomialHeapStruc.ins (bsmapt t) (map bsmapt q)", "by (induct q arbitrary: t) (auto simp add: proj_xlate link_xlate)"], ["", "text \\<open>Insert an element with priority into a queue using skewlinks.\\<close>"], ["", "fun insert :: \"('e,'a::linorder) BsSkewElem \\<Rightarrow>\n  ('e, 'a) BsSkewBinomialQueue \\<Rightarrow> \n  ('e, 'a) BsSkewBinomialQueue\" where\n  \"insert e [] = [BsNode e 0 []]\" |\n  \"insert e [t] = [BsNode e 0 [],t]\" |\n  \"insert e (t # t' # bq) =\n    (if rank t \\<noteq> rank t' \n      then (BsNode e 0 []) # t # t' # bq\n      else (skewlink e t t') # bq)\""], ["", "lemma insert_xlate:\n  \"bsmap (insert e q) = SkewBinomialHeapStruc.insert e (eprio e) (bsmap q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map bsmapt (local.insert e q) =\n    SkewBinomialHeapStruc.insert e (eprio e) (map bsmapt q)", "apply (cases \"(e,q)\" rule: insert.cases)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>ea.\n       (e, q) = (ea, []) \\<Longrightarrow>\n       map bsmapt (local.insert e q) =\n       SkewBinomialHeapStruc.insert e (eprio e) (map bsmapt q)\n 2. \\<And>ea t.\n       (e, q) = (ea, [t]) \\<Longrightarrow>\n       map bsmapt (local.insert e q) =\n       SkewBinomialHeapStruc.insert e (eprio e) (map bsmapt q)\n 3. \\<And>ea t t' bq.\n       (e, q) = (ea, t # t' # bq) \\<Longrightarrow>\n       map bsmapt (local.insert e q) =\n       SkewBinomialHeapStruc.insert e (eprio e) (map bsmapt q)", "apply (auto simp add: proj_xlate link_xlate SkewBinomialHeapStruc.insert.simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma insert_correct:\n  assumes I: \"invar q\"\n  shows \n  \"invar (insert e q)\"\n  \"queue_to_multiset (insert e q) = queue_to_multiset q + {#(e)#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SkewBinomialHeapStruc.invar (map bsmapt (local.insert e q)) &&&\n    image_mset fst\n     (SkewBinomialHeapStruc.queue_to_multiset\n       (map bsmapt (local.insert e q))) =\n    image_mset fst\n     (SkewBinomialHeapStruc.queue_to_multiset (map bsmapt q)) +\n    {#e#}", "by (simp_all add: I SkewBinomialHeapStruc.insert_correct insert_xlate)"], ["", "fun uniqify \n  :: \"('e, 'a::linorder) BsSkewBinomialQueue \\<Rightarrow> ('e, 'a) BsSkewBinomialQueue\" \n  where\n  \"uniqify [] = []\" |\n  \"uniqify (t#bq) = ins t bq\""], ["", "fun meldUniq \n  :: \"('e, 'a::linorder) BsSkewBinomialQueue \\<Rightarrow> ('e,'a) BsSkewBinomialQueue \\<Rightarrow>\n  ('e, 'a) BsSkewBinomialQueue\" where\n  \"meldUniq [] bq = bq\" |\n  \"meldUniq bq [] = bq\" |\n  \"meldUniq (t1#bq1) (t2#bq2) = (if rank t1 < rank t2 \n       then t1 # (meldUniq bq1 (t2#bq2))\n       else (if rank t2 < rank t1\n              then t2 # (meldUniq (t1#bq1) bq2)\n              else ins (link t1 t2) (meldUniq bq1 bq2)))\""], ["", "definition meld \n  :: \"('e, 'a::linorder) BsSkewBinomialQueue \\<Rightarrow> ('e, 'a) BsSkewBinomialQueue \\<Rightarrow> \n      ('e, 'a) BsSkewBinomialQueue\" where\n  \"meld bq1 bq2 = meldUniq (uniqify bq1) (uniqify bq2)\""], ["", "lemma uniqify_xlate:\n  \"bsmap (uniqify q) = SkewBinomialHeapStruc.uniqify (bsmap q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map bsmapt (uniqify q) = SkewBinomialHeapStruc.uniqify (map bsmapt q)", "by (cases q) (simp_all add: ins_xlate)"], ["", "lemma meldUniq_xlate:\n  \"bsmap (meldUniq q q') = SkewBinomialHeapStruc.meldUniq (bsmap q) (bsmap q')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map bsmapt (meldUniq q q') =\n    SkewBinomialHeapStruc.meldUniq (map bsmapt q) (map bsmapt q')", "apply (induct q q' rule: meldUniq.induct)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>bq.\n       map bsmapt (meldUniq [] bq) =\n       SkewBinomialHeapStruc.meldUniq (map bsmapt []) (map bsmapt bq)\n 2. \\<And>v va.\n       map bsmapt (meldUniq (v # va) []) =\n       SkewBinomialHeapStruc.meldUniq (map bsmapt (v # va)) (map bsmapt [])\n 3. \\<And>t1 bq1 t2 bq2.\n       \\<lbrakk>rank t1 < rank t2 \\<Longrightarrow>\n                map bsmapt (meldUniq bq1 (t2 # bq2)) =\n                SkewBinomialHeapStruc.meldUniq (map bsmapt bq1)\n                 (map bsmapt (t2 # bq2));\n        \\<lbrakk>\\<not> rank t1 < rank t2; rank t2 < rank t1\\<rbrakk>\n        \\<Longrightarrow> map bsmapt (meldUniq (t1 # bq1) bq2) =\n                          SkewBinomialHeapStruc.meldUniq\n                           (map bsmapt (t1 # bq1)) (map bsmapt bq2);\n        \\<lbrakk>\\<not> rank t1 < rank t2; \\<not> rank t2 < rank t1\\<rbrakk>\n        \\<Longrightarrow> map bsmapt (meldUniq bq1 bq2) =\n                          SkewBinomialHeapStruc.meldUniq (map bsmapt bq1)\n                           (map bsmapt bq2)\\<rbrakk>\n       \\<Longrightarrow> map bsmapt (meldUniq (t1 # bq1) (t2 # bq2)) =\n                         SkewBinomialHeapStruc.meldUniq\n                          (map bsmapt (t1 # bq1)) (map bsmapt (t2 # bq2))", "apply (auto simp add: link_xlate proj_xlate uniqify_xlate ins_xlate)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma meld_xlate: \n  \"bsmap (meld q q') = SkewBinomialHeapStruc.meld (bsmap q) (bsmap q')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map bsmapt (meld q q') =\n    SkewBinomialHeapStruc.meld (map bsmapt q) (map bsmapt q')", "by (simp add: meld_def meldUniq_xlate uniqify_xlate \n           SkewBinomialHeapStruc.meld_def)"], ["", "lemma meld_correct:\n  assumes I: \"invar q\" \"invar q'\"\n  shows \n  \"invar (meld q q')\"\n  \"queue_to_multiset (meld q q') = queue_to_multiset q + queue_to_multiset q'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SkewBinomialHeapStruc.invar (map bsmapt (meld q q')) &&&\n    image_mset fst\n     (SkewBinomialHeapStruc.queue_to_multiset (map bsmapt (meld q q'))) =\n    image_mset fst\n     (SkewBinomialHeapStruc.queue_to_multiset (map bsmapt q)) +\n    image_mset fst (SkewBinomialHeapStruc.queue_to_multiset (map bsmapt q'))", "by (simp_all add: I SkewBinomialHeapStruc.meld_correct meld_xlate)"], ["", "fun insertList :: \n  \"('e, 'a::linorder) BsSkewBinomialQueue \\<Rightarrow> ('e, 'a) BsSkewBinomialQueue \\<Rightarrow> \n   ('e, 'a) BsSkewBinomialQueue\" where\n  \"insertList [] tbq = tbq\" |\n  \"insertList (t#bq) tbq = insertList bq (insert (val t) tbq)\""], ["", "fun remove1Prio :: \"'a \\<Rightarrow> ('e, 'a::linorder) BsSkewBinomialQueue \\<Rightarrow>\n  ('e, 'a) BsSkewBinomialQueue\" where\n  \"remove1Prio a [] = []\" |\n  \"remove1Prio a (t#bq) = \n  (if (prio t) = a then bq else t # (remove1Prio a bq))\""], ["", "fun getMinTree :: \"('e, 'a::linorder) BsSkewBinomialQueue \\<Rightarrow> \n  ('e, 'a) BsSkewBinomialTree\" where\n  \"getMinTree [t] = t\" |\n  \"getMinTree (t#bq) =\n    (if prio t \\<le> prio (getMinTree bq)\n      then t\n      else (getMinTree bq))\""], ["", "definition findMin \n  :: \"('e, 'a::linorder) BsSkewBinomialQueue \\<Rightarrow> ('e,'a) BsSkewElem\" where\n  \"findMin bq = val (getMinTree bq)\""], ["", "definition deleteMin :: \"('e, 'a::linorder) BsSkewBinomialQueue \\<Rightarrow> \n  ('e, 'a) BsSkewBinomialQueue\" where\n  \"deleteMin bq = (let min = getMinTree bq in insertList\n    (filter (\\<lambda> t. rank t = 0) (children min))\n    (meld (rev (filter (\\<lambda> t. rank t > 0) (children min))) \n     (remove1Prio (prio min) bq)))\""], ["", "lemma insertList_xlate:\n  \"bsmap (insertList q q') \n  = SkewBinomialHeapStruc.insertList (bsmap q) (bsmap q')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map bsmapt (insertList q q') =\n    SkewBinomialHeapStruc.insertList (map bsmapt q) (map bsmapt q')", "apply (induct q arbitrary: q')"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>q'.\n       map bsmapt (insertList [] q') =\n       SkewBinomialHeapStruc.insertList (map bsmapt []) (map bsmapt q')\n 2. \\<And>a q q'.\n       (\\<And>q'.\n           map bsmapt (insertList q q') =\n           SkewBinomialHeapStruc.insertList (map bsmapt q)\n            (map bsmapt q')) \\<Longrightarrow>\n       map bsmapt (insertList (a # q) q') =\n       SkewBinomialHeapStruc.insertList (map bsmapt (a # q)) (map bsmapt q')", "apply (auto simp add: insert_xlate proj_xlate)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma remove1Prio_xlate:\n  \"bsmap (remove1Prio a q) = SkewBinomialHeapStruc.remove1Prio a (bsmap q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map bsmapt (remove1Prio a q) =\n    SkewBinomialHeapStruc.remove1Prio a (map bsmapt q)", "by (induct q) (auto simp add: proj_xlate)"], ["", "lemma getMinTree_xlate:\n  \"q\\<noteq>[] \\<Longrightarrow> bsmapt (getMinTree q) = SkewBinomialHeapStruc.getMinTree (bsmap q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q \\<noteq> [] \\<Longrightarrow>\n    bsmapt (getMinTree q) = SkewBinomialHeapStruc.getMinTree (map bsmapt q)", "apply (induct q)"], ["proof (prove)\ngoal (2 subgoals):\n 1. [] \\<noteq> [] \\<Longrightarrow>\n    bsmapt (getMinTree []) =\n    SkewBinomialHeapStruc.getMinTree (map bsmapt [])\n 2. \\<And>a q.\n       \\<lbrakk>q \\<noteq> [] \\<Longrightarrow>\n                bsmapt (getMinTree q) =\n                SkewBinomialHeapStruc.getMinTree (map bsmapt q);\n        a # q \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> bsmapt (getMinTree (a # q)) =\n                         SkewBinomialHeapStruc.getMinTree\n                          (map bsmapt (a # q))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a q.\n       \\<lbrakk>q \\<noteq> [] \\<Longrightarrow>\n                bsmapt (getMinTree q) =\n                SkewBinomialHeapStruc.getMinTree (map bsmapt q);\n        a # q \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> bsmapt (getMinTree (a # q)) =\n                         SkewBinomialHeapStruc.getMinTree\n                          (map bsmapt (a # q))", "apply (case_tac q)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a q.\n       \\<lbrakk>q \\<noteq> [] \\<Longrightarrow>\n                bsmapt (getMinTree q) =\n                SkewBinomialHeapStruc.getMinTree (map bsmapt q);\n        a # q \\<noteq> []; q = []\\<rbrakk>\n       \\<Longrightarrow> bsmapt (getMinTree (a # q)) =\n                         SkewBinomialHeapStruc.getMinTree\n                          (map bsmapt (a # q))\n 2. \\<And>a q aa list.\n       \\<lbrakk>q \\<noteq> [] \\<Longrightarrow>\n                bsmapt (getMinTree q) =\n                SkewBinomialHeapStruc.getMinTree (map bsmapt q);\n        a # q \\<noteq> []; q = aa # list\\<rbrakk>\n       \\<Longrightarrow> bsmapt (getMinTree (a # q)) =\n                         SkewBinomialHeapStruc.getMinTree\n                          (map bsmapt (a # q))", "apply (auto simp add: proj_xlate)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma findMin_xlate: \n  \"q\\<noteq>[] \\<Longrightarrow> findMin q = fst (SkewBinomialHeapStruc.findMin (bsmap q))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q \\<noteq> [] \\<Longrightarrow>\n    findMin q = fst (SkewBinomialHeapStruc.findMin (map bsmapt q))", "apply (unfold findMin_def SkewBinomialHeapStruc.findMin_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. q \\<noteq> [] \\<Longrightarrow>\n    val (getMinTree q) =\n    fst (let min = SkewBinomialHeapStruc.getMinTree (map bsmapt q)\n         in (SkewBinomialHeapStruc.val min, SkewBinomialHeapStruc.prio min))", "apply (simp add: proj_xlate Let_def getMinTree_xlate)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma findMin_xlate_aux: \n  \"q\\<noteq>[] \\<Longrightarrow> (findMin q, eprio (findMin q)) = \n  (SkewBinomialHeapStruc.findMin (bsmap q))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q \\<noteq> [] \\<Longrightarrow>\n    (findMin q, eprio (findMin q)) =\n    SkewBinomialHeapStruc.findMin (map bsmapt q)", "apply (unfold findMin_def SkewBinomialHeapStruc.findMin_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. q \\<noteq> [] \\<Longrightarrow>\n    (val (getMinTree q), eprio (val (getMinTree q))) =\n    (let min = SkewBinomialHeapStruc.getMinTree (map bsmapt q)\n     in (SkewBinomialHeapStruc.val min, SkewBinomialHeapStruc.prio min))", "apply (simp add: proj_xlate Let_def getMinTree_xlate)"], ["proof (prove)\ngoal (1 subgoal):\n 1. q \\<noteq> [] \\<Longrightarrow>\n    eprio\n     (SkewBinomialHeapStruc.val\n       (SkewBinomialHeapStruc.getMinTree (map bsmapt q))) =\n    SkewBinomialHeapStruc.prio\n     (SkewBinomialHeapStruc.getMinTree (map bsmapt q))", "apply (induct q)"], ["proof (prove)\ngoal (2 subgoals):\n 1. [] \\<noteq> [] \\<Longrightarrow>\n    eprio\n     (SkewBinomialHeapStruc.val\n       (SkewBinomialHeapStruc.getMinTree (map bsmapt []))) =\n    SkewBinomialHeapStruc.prio\n     (SkewBinomialHeapStruc.getMinTree (map bsmapt []))\n 2. \\<And>a q.\n       \\<lbrakk>q \\<noteq> [] \\<Longrightarrow>\n                eprio\n                 (SkewBinomialHeapStruc.val\n                   (SkewBinomialHeapStruc.getMinTree (map bsmapt q))) =\n                SkewBinomialHeapStruc.prio\n                 (SkewBinomialHeapStruc.getMinTree (map bsmapt q));\n        a # q \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> eprio\n                          (SkewBinomialHeapStruc.val\n                            (SkewBinomialHeapStruc.getMinTree\n                              (map bsmapt (a # q)))) =\n                         SkewBinomialHeapStruc.prio\n                          (SkewBinomialHeapStruc.getMinTree\n                            (map bsmapt (a # q)))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a q.\n       \\<lbrakk>q \\<noteq> [] \\<Longrightarrow>\n                eprio\n                 (SkewBinomialHeapStruc.val\n                   (SkewBinomialHeapStruc.getMinTree (map bsmapt q))) =\n                SkewBinomialHeapStruc.prio\n                 (SkewBinomialHeapStruc.getMinTree (map bsmapt q));\n        a # q \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> eprio\n                          (SkewBinomialHeapStruc.val\n                            (SkewBinomialHeapStruc.getMinTree\n                              (map bsmapt (a # q)))) =\n                         SkewBinomialHeapStruc.prio\n                          (SkewBinomialHeapStruc.getMinTree\n                            (map bsmapt (a # q)))", "apply (case_tac q)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a q.\n       \\<lbrakk>q \\<noteq> [] \\<Longrightarrow>\n                eprio\n                 (SkewBinomialHeapStruc.val\n                   (SkewBinomialHeapStruc.getMinTree (map bsmapt q))) =\n                SkewBinomialHeapStruc.prio\n                 (SkewBinomialHeapStruc.getMinTree (map bsmapt q));\n        a # q \\<noteq> []; q = []\\<rbrakk>\n       \\<Longrightarrow> eprio\n                          (SkewBinomialHeapStruc.val\n                            (SkewBinomialHeapStruc.getMinTree\n                              (map bsmapt (a # q)))) =\n                         SkewBinomialHeapStruc.prio\n                          (SkewBinomialHeapStruc.getMinTree\n                            (map bsmapt (a # q)))\n 2. \\<And>a q aa list.\n       \\<lbrakk>q \\<noteq> [] \\<Longrightarrow>\n                eprio\n                 (SkewBinomialHeapStruc.val\n                   (SkewBinomialHeapStruc.getMinTree (map bsmapt q))) =\n                SkewBinomialHeapStruc.prio\n                 (SkewBinomialHeapStruc.getMinTree (map bsmapt q));\n        a # q \\<noteq> []; q = aa # list\\<rbrakk>\n       \\<Longrightarrow> eprio\n                          (SkewBinomialHeapStruc.val\n                            (SkewBinomialHeapStruc.getMinTree\n                              (map bsmapt (a # q)))) =\n                         SkewBinomialHeapStruc.prio\n                          (SkewBinomialHeapStruc.getMinTree\n                            (map bsmapt (a # q)))", "apply (auto simp add: proj_xlate)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(* TODO: Also possible in generic formulation. Then a candidate for Misc.thy *)"], ["", "lemma bsmap_filter_xlate:\n  \"bsmap [ x\\<leftarrow>l . P (bsmapt x) ] = [ x \\<leftarrow> bsmap l. P x ]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map bsmapt (filter (\\<lambda>x. P (bsmapt x)) l) =\n    filter P (map bsmapt l)", "by (induct l) auto"], ["", "lemma bsmap_rev_xlate:\n  \"bsmap (rev q) = rev (bsmap q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map bsmapt (rev q) = rev (map bsmapt q)", "by (induct q) auto"], ["", "lemma deleteMin_xlate:\n  \"q\\<noteq>[] \\<Longrightarrow> bsmap (deleteMin q) = SkewBinomialHeapStruc.deleteMin (bsmap q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q \\<noteq> [] \\<Longrightarrow>\n    map bsmapt (deleteMin q) =\n    SkewBinomialHeapStruc.deleteMin (map bsmapt q)", "apply (simp add: \n    deleteMin_def SkewBinomialHeapStruc.deleteMin_def\n    proj_xlate getMinTree_xlate insertList_xlate meld_xlate remove1Prio_xlate\n    Let_def bsmap_rev_xlate, (subst bsmap_filter_xlate)?)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma deleteMin_correct_aux:\n  assumes I: \"invar q\"\n  assumes NE: \"q\\<noteq>[]\"\n  shows \n  \"invar (deleteMin q)\"\n  \"queue_to_multiset_aux (deleteMin q) = queue_to_multiset_aux q - \n  {# (findMin q, eprio (findMin q)) #}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SkewBinomialHeapStruc.invar (map bsmapt (deleteMin q)) &&&\n    SkewBinomialHeapStruc.queue_to_multiset (map bsmapt (deleteMin q)) =\n    SkewBinomialHeapStruc.queue_to_multiset (map bsmapt q) -\n    {#(findMin q, eprio (findMin q))#}", "apply (simp_all add:\n    I NE deleteMin_xlate findMin_xlate_aux \n    SkewBinomialHeapStruc.deleteMin_correct)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma bsmap_fs_dep:\n  \"(e,a)\\<in>#SkewBinomialHeapStruc.tree_to_multiset (bsmapt t) \\<Longrightarrow> a=eprio e\"\n  \"(e,a)\\<in>#SkewBinomialHeapStruc.queue_to_multiset (bsmap q) \\<Longrightarrow> a=eprio e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((e, a)\n     \\<in># SkewBinomialHeapStruc.tree_to_multiset\n             (bsmapt t) \\<Longrightarrow>\n     a = eprio e) &&&\n    ((e, a)\n     \\<in># SkewBinomialHeapStruc.queue_to_multiset\n             (map bsmapt q) \\<Longrightarrow>\n     a = eprio e)", "thm SkewBinomialHeapStruc.tree_to_multiset_queue_to_multiset.induct"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((e, a)\n     \\<in># SkewBinomialHeapStruc.tree_to_multiset\n             (bsmapt t) \\<Longrightarrow>\n     a = eprio e) &&&\n    ((e, a)\n     \\<in># SkewBinomialHeapStruc.queue_to_multiset\n             (map bsmapt q) \\<Longrightarrow>\n     a = eprio e)", "apply (induct \"bsmapt t\" and \"bsmap q\" arbitrary: t and q\n    rule: SkewBinomialHeapStruc.tree_to_multiset_queue_to_multiset.induct)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>ea aa r ts t.\n       \\<lbrakk>\\<And>q.\n                   \\<lbrakk>ts = map bsmapt q;\n                    (e, a)\n                    \\<in># SkewBinomialHeapStruc.queue_to_multiset\n                            (map bsmapt q)\\<rbrakk>\n                   \\<Longrightarrow> a = eprio e;\n        SkewBinomialHeapStruc.Node ea aa r ts = bsmapt t;\n        (e, a)\n        \\<in># SkewBinomialHeapStruc.tree_to_multiset (bsmapt t)\\<rbrakk>\n       \\<Longrightarrow> a = eprio e\n 2. \\<And>q.\n       \\<lbrakk>[] = map bsmapt q;\n        (e, a)\n        \\<in># SkewBinomialHeapStruc.queue_to_multiset\n                (map bsmapt q)\\<rbrakk>\n       \\<Longrightarrow> a = eprio e\n 3. \\<And>t q qa.\n       \\<lbrakk>\\<And>ta.\n                   \\<lbrakk>t = bsmapt ta;\n                    (e, a)\n                    \\<in># SkewBinomialHeapStruc.tree_to_multiset\n                            (bsmapt ta)\\<rbrakk>\n                   \\<Longrightarrow> a = eprio e;\n        \\<And>qa.\n           \\<lbrakk>q = map bsmapt qa;\n            (e, a)\n            \\<in># SkewBinomialHeapStruc.queue_to_multiset\n                    (map bsmapt qa)\\<rbrakk>\n           \\<Longrightarrow> a = eprio e;\n        t # q = map bsmapt qa;\n        (e, a)\n        \\<in># SkewBinomialHeapStruc.queue_to_multiset\n                (map bsmapt qa)\\<rbrakk>\n       \\<Longrightarrow> a = eprio e", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ea aa r ts t.\n       \\<lbrakk>\\<And>q.\n                   \\<lbrakk>ts = map bsmapt q;\n                    (e, a)\n                    \\<in># SkewBinomialHeapStruc.queue_to_multiset\n                            (map bsmapt q)\\<rbrakk>\n                   \\<Longrightarrow> a = eprio e;\n        SkewBinomialHeapStruc.Node ea aa r ts = bsmapt t;\n        (e, a)\n        \\<in># SkewBinomialHeapStruc.tree_to_multiset (bsmapt t)\\<rbrakk>\n       \\<Longrightarrow> a = eprio e", "apply (case_tac t)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ea aa r ts t x1 x2 x3.\n       \\<lbrakk>\\<And>q.\n                   \\<lbrakk>ts = map bsmapt q;\n                    (e, a)\n                    \\<in># SkewBinomialHeapStruc.queue_to_multiset\n                            (map bsmapt q)\\<rbrakk>\n                   \\<Longrightarrow> a = eprio e;\n        SkewBinomialHeapStruc.Node ea aa r ts = bsmapt t;\n        (e, a) \\<in># SkewBinomialHeapStruc.tree_to_multiset (bsmapt t);\n        t = BsNode x1 x2 x3\\<rbrakk>\n       \\<Longrightarrow> a = eprio e", "apply (auto split: if_split_asm)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma bsmap_fs_depD:\n  \"(e,a)\\<in>#SkewBinomialHeapStruc.tree_to_multiset (bsmapt t) \n  \\<Longrightarrow> e \\<in># tree_to_multiset t \\<and> a=eprio e\"\n  \"(e,a)\\<in>#SkewBinomialHeapStruc.queue_to_multiset (bsmap q) \n  \\<Longrightarrow> e \\<in># queue_to_multiset q \\<and> a=eprio e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((e, a)\n     \\<in># SkewBinomialHeapStruc.tree_to_multiset\n             (bsmapt t) \\<Longrightarrow>\n     e \\<in># image_mset fst\n               (SkewBinomialHeapStruc.tree_to_multiset (bsmapt t)) \\<and>\n     a = eprio e) &&&\n    ((e, a)\n     \\<in># SkewBinomialHeapStruc.queue_to_multiset\n             (map bsmapt q) \\<Longrightarrow>\n     e \\<in># image_mset fst\n               (SkewBinomialHeapStruc.queue_to_multiset\n                 (map bsmapt q)) \\<and>\n     a = eprio e)", "by (auto dest: bsmap_fs_dep intro!: image_eqI)"], ["", "lemma findMin_correct_aux:\n  assumes I: \"invar q\"\n  assumes NE: \"q\\<noteq>[]\"\n  shows \"(findMin q, eprio (findMin q)) \\<in># queue_to_multiset_aux q\"\n  \"\\<forall>y\\<in>set_mset (queue_to_multiset_aux q). snd (findMin q,eprio (findMin q)) \\<le> snd y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (findMin q, eprio (findMin q))\n    \\<in># SkewBinomialHeapStruc.queue_to_multiset (map bsmapt q) &&&\n    \\<forall>y\\<in>#SkewBinomialHeapStruc.queue_to_multiset (map bsmapt q).\n       snd (findMin q, eprio (findMin q)) \\<le> snd y", "apply (simp_all add:\n    I NE findMin_xlate_aux \n    SkewBinomialHeapStruc.findMin_correct)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma findMin_correct:\n  assumes I: \"invar q\"\n    and NE: \"q\\<noteq>[]\"\n  shows \"findMin q \\<in># queue_to_multiset q\"\n    and \"\\<forall>y\\<in>set_mset (queue_to_multiset q). eprio (findMin q) \\<le> eprio y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. findMin q\n    \\<in># image_mset fst\n            (SkewBinomialHeapStruc.queue_to_multiset (map bsmapt q)) &&&\n    \\<forall>y\\<in>#image_mset fst\n                     (SkewBinomialHeapStruc.queue_to_multiset\n                       (map bsmapt q)).\n       eprio (findMin q) \\<le> eprio y", "using findMin_correct_aux[OF I NE]"], ["proof (prove)\nusing this:\n  (findMin q, eprio (findMin q))\n  \\<in># SkewBinomialHeapStruc.queue_to_multiset (map bsmapt q)\n  \\<forall>y\\<in>#SkewBinomialHeapStruc.queue_to_multiset (map bsmapt q).\n     snd (findMin q, eprio (findMin q)) \\<le> snd y\n\ngoal (1 subgoal):\n 1. findMin q\n    \\<in># image_mset fst\n            (SkewBinomialHeapStruc.queue_to_multiset (map bsmapt q)) &&&\n    \\<forall>y\\<in>#image_mset fst\n                     (SkewBinomialHeapStruc.queue_to_multiset\n                       (map bsmapt q)).\n       eprio (findMin q) \\<le> eprio y", "apply simp_all"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>(findMin q, eprio (findMin q))\n             \\<in># SkewBinomialHeapStruc.queue_to_multiset (map bsmapt q);\n     \\<forall>y\\<in>#SkewBinomialHeapStruc.queue_to_multiset (map bsmapt q).\n        eprio (findMin q) \\<le> snd y\\<rbrakk>\n    \\<Longrightarrow> findMin q\n                      \\<in> fst `\n                            set_mset\n                             (SkewBinomialHeapStruc.queue_to_multiset\n                               (map bsmapt q))\n 2. \\<lbrakk>(findMin q, eprio (findMin q))\n             \\<in># SkewBinomialHeapStruc.queue_to_multiset (map bsmapt q);\n     \\<forall>y\\<in>#SkewBinomialHeapStruc.queue_to_multiset (map bsmapt q).\n        eprio (findMin q) \\<le> snd y\\<rbrakk>\n    \\<Longrightarrow> \\<forall>y\\<in>#SkewBinomialHeapStruc.queue_to_multiset\n (map bsmapt q).\n                         eprio (findMin q) \\<le> eprio (fst y)", "apply (force dest: bsmap_fs_depD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(findMin q, eprio (findMin q))\n             \\<in># SkewBinomialHeapStruc.queue_to_multiset (map bsmapt q);\n     \\<forall>y\\<in>#SkewBinomialHeapStruc.queue_to_multiset (map bsmapt q).\n        eprio (findMin q) \\<le> snd y\\<rbrakk>\n    \\<Longrightarrow> \\<forall>y\\<in>#SkewBinomialHeapStruc.queue_to_multiset\n (map bsmapt q).\n                         eprio (findMin q) \\<le> eprio (fst y)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(findMin q, eprio (findMin q))\n                \\<in># SkewBinomialHeapStruc.queue_to_multiset\n                        (map bsmapt q);\n        \\<forall>y\\<in>#SkewBinomialHeapStruc.queue_to_multiset\n                         (map bsmapt q).\n           eprio (findMin q) \\<le> snd y;\n        (a, b)\n        \\<in># SkewBinomialHeapStruc.queue_to_multiset\n                (map bsmapt q)\\<rbrakk>\n       \\<Longrightarrow> eprio (findMin q) \\<le> eprio a", "proof goal_cases"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(findMin q, eprio (findMin q))\n                \\<in># SkewBinomialHeapStruc.queue_to_multiset\n                        (map bsmapt q);\n        \\<forall>y\\<in>#SkewBinomialHeapStruc.queue_to_multiset\n                         (map bsmapt q).\n           eprio (findMin q) \\<le> snd y;\n        (a, b)\n        \\<in># SkewBinomialHeapStruc.queue_to_multiset\n                (map bsmapt q)\\<rbrakk>\n       \\<Longrightarrow> eprio (findMin q) \\<le> eprio a", "case prems: (1 a b)"], ["proof (state)\nthis:\n  (findMin q, eprio (findMin q))\n  \\<in># SkewBinomialHeapStruc.queue_to_multiset (map bsmapt q)\n  \\<forall>y\\<in>#SkewBinomialHeapStruc.queue_to_multiset (map bsmapt q).\n     eprio (findMin q) \\<le> snd y\n  (a, b) \\<in># SkewBinomialHeapStruc.queue_to_multiset (map bsmapt q)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(findMin q, eprio (findMin q))\n                \\<in># SkewBinomialHeapStruc.queue_to_multiset\n                        (map bsmapt q);\n        \\<forall>y\\<in>#SkewBinomialHeapStruc.queue_to_multiset\n                         (map bsmapt q).\n           eprio (findMin q) \\<le> snd y;\n        (a, b)\n        \\<in># SkewBinomialHeapStruc.queue_to_multiset\n                (map bsmapt q)\\<rbrakk>\n       \\<Longrightarrow> eprio (findMin q) \\<le> eprio a", "from prems(3)"], ["proof (chain)\npicking this:\n  (a, b) \\<in># SkewBinomialHeapStruc.queue_to_multiset (map bsmapt q)", "have \"(a, eprio a) \\<in># queue_to_multiset_aux q\""], ["proof (prove)\nusing this:\n  (a, b) \\<in># SkewBinomialHeapStruc.queue_to_multiset (map bsmapt q)\n\ngoal (1 subgoal):\n 1. (a, eprio a)\n    \\<in># SkewBinomialHeapStruc.queue_to_multiset (map bsmapt q)", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. (a, b)\n    \\<in># SkewBinomialHeapStruc.queue_to_multiset\n            (map bsmapt q) \\<Longrightarrow>\n    (a, eprio a)\n    \\<in># SkewBinomialHeapStruc.queue_to_multiset (map bsmapt q)", "apply (frule bsmap_fs_dep)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(a, b)\n             \\<in># SkewBinomialHeapStruc.queue_to_multiset (map bsmapt q);\n     b = eprio a\\<rbrakk>\n    \\<Longrightarrow> (a, eprio a)\n                      \\<in># SkewBinomialHeapStruc.queue_to_multiset\n                              (map bsmapt q)", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (a, eprio a) \\<in># SkewBinomialHeapStruc.queue_to_multiset (map bsmapt q)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(findMin q, eprio (findMin q))\n                \\<in># SkewBinomialHeapStruc.queue_to_multiset\n                        (map bsmapt q);\n        \\<forall>y\\<in>#SkewBinomialHeapStruc.queue_to_multiset\n                         (map bsmapt q).\n           eprio (findMin q) \\<le> snd y;\n        (a, b)\n        \\<in># SkewBinomialHeapStruc.queue_to_multiset\n                (map bsmapt q)\\<rbrakk>\n       \\<Longrightarrow> eprio (findMin q) \\<le> eprio a", "with prems(2)[rule_format, simplified]"], ["proof (chain)\npicking this:\n  ?y \\<in># SkewBinomialHeapStruc.queue_to_multiset\n             (map bsmapt q) \\<Longrightarrow>\n  eprio (findMin q) \\<le> snd ?y\n  (a, eprio a) \\<in># SkewBinomialHeapStruc.queue_to_multiset (map bsmapt q)", "show ?case"], ["proof (prove)\nusing this:\n  ?y \\<in># SkewBinomialHeapStruc.queue_to_multiset\n             (map bsmapt q) \\<Longrightarrow>\n  eprio (findMin q) \\<le> snd ?y\n  (a, eprio a) \\<in># SkewBinomialHeapStruc.queue_to_multiset (map bsmapt q)\n\ngoal (1 subgoal):\n 1. eprio (findMin q) \\<le> eprio a", "by auto"], ["proof (state)\nthis:\n  eprio (findMin q) \\<le> eprio a\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma deleteMin_correct:\n  assumes I: \"invar q\"\n  assumes NE: \"q\\<noteq>[]\"\n  shows \n  \"invar (deleteMin q)\"\n  \"queue_to_multiset (deleteMin q) = queue_to_multiset q - \n  {# findMin q #}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SkewBinomialHeapStruc.invar (map bsmapt (deleteMin q)) &&&\n    image_mset fst\n     (SkewBinomialHeapStruc.queue_to_multiset (map bsmapt (deleteMin q))) =\n    image_mset fst\n     (SkewBinomialHeapStruc.queue_to_multiset (map bsmapt q)) -\n    {#findMin q#}", "using deleteMin_correct_aux[OF I NE]"], ["proof (prove)\nusing this:\n  SkewBinomialHeapStruc.invar (map bsmapt (deleteMin q))\n  SkewBinomialHeapStruc.queue_to_multiset (map bsmapt (deleteMin q)) =\n  SkewBinomialHeapStruc.queue_to_multiset (map bsmapt q) -\n  {#(findMin q, eprio (findMin q))#}\n\ngoal (1 subgoal):\n 1. SkewBinomialHeapStruc.invar (map bsmapt (deleteMin q)) &&&\n    image_mset fst\n     (SkewBinomialHeapStruc.queue_to_multiset (map bsmapt (deleteMin q))) =\n    image_mset fst\n     (SkewBinomialHeapStruc.queue_to_multiset (map bsmapt q)) -\n    {#findMin q#}", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>SkewBinomialHeapStruc.invar (map bsmapt (deleteMin q));\n     SkewBinomialHeapStruc.queue_to_multiset (map bsmapt (deleteMin q)) =\n     SkewBinomialHeapStruc.queue_to_multiset (map bsmapt q) -\n     {#(findMin q, eprio (findMin q))#}\\<rbrakk>\n    \\<Longrightarrow> image_mset fst\n                       (SkewBinomialHeapStruc.queue_to_multiset\n                         (map bsmapt q) -\n                        {#(findMin q, eprio (findMin q))#}) =\n                      image_mset fst\n                       (SkewBinomialHeapStruc.queue_to_multiset\n                         (map bsmapt q)) -\n                      {#findMin q#}", "apply (rule mset_image_fst_dep_pair_diff_split)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>SkewBinomialHeapStruc.invar (map bsmapt (deleteMin q));\n     SkewBinomialHeapStruc.queue_to_multiset (map bsmapt (deleteMin q)) =\n     SkewBinomialHeapStruc.queue_to_multiset (map bsmapt q) -\n     {#(findMin q, eprio (findMin q))#}\\<rbrakk>\n    \\<Longrightarrow> \\<forall>e a.\n                         (e, a)\n                         \\<in># SkewBinomialHeapStruc.queue_to_multiset\n                                 (map bsmapt q) \\<longrightarrow>\n                         a = eprio e", "apply (auto dest: bsmap_fs_dep)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "declare insert.simps[simp del]"], ["", "subsubsection \"Bootstrapping: Phase 1\""], ["", "text \\<open>\n  In this section, we define the ticked versions\n  of the functions, as defined in \\cite{BrOk96}.\n  These functions work on elements, i.e. only on \n  heaps that contain at least one entry.\n  Additionally, we define an invariant for elements, and\n  a mapping to multisets of entries, and prove correct\n  the ticked functions.\n\\<close>"], ["", "primrec findMin' where \"findMin' (Element e a q) = (e,a)\""], ["", "fun meld':: \"('e,'a::linorder) BsSkewElem \\<Rightarrow> \n  ('e,'a) BsSkewElem \\<Rightarrow> ('e,'a) BsSkewElem\"\n  where \"meld' (Element e1 a1 q1) (Element e2 a2 q2) =\n  (if a1\\<le>a2 then\n    Element e1 a1 (insert (Element e2 a2 q2) q1)\n   else\n    Element e2 a2 (insert (Element e1 a1 q1) q2)\n  )\""], ["", "fun insert' where\n  \"insert' e a q = meld' (Element e a []) q\""], ["", "fun deleteMin' where\n  \"deleteMin' (Element e a q) = (\n    case (findMin q) of\n      Element ey ay q1 \\<Rightarrow>\n        Element ey ay (meld q1 (deleteMin q))\n  )\""], ["", "text \\<open>\n  Size-function for termination proofs\n\\<close>"], ["", "fun tree_level and queue_level where\n  \"tree_level (BsNode (Element _ _ qd) _ q) = \n  max (Suc (queue_level qd)) (queue_level q)\" |\n  \"queue_level [] = (0::nat)\" |\n  \"queue_level (t#q) = max (tree_level t) (queue_level q)\""], ["", "fun level where\n  \"level (Element _ _ q) = Suc (queue_level q)\""], ["", "lemma level_m:\n  \"x\\<in>#tree_to_multiset t \\<Longrightarrow> level x < Suc (tree_level t)\"\n  \"x\\<in>#queue_to_multiset q \\<Longrightarrow> level x < Suc (queue_level q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in># image_mset fst\n               (SkewBinomialHeapStruc.tree_to_multiset\n                 (bsmapt t)) \\<Longrightarrow>\n     level x < Suc (tree_level t)) &&&\n    (x \\<in># image_mset fst\n               (SkewBinomialHeapStruc.queue_to_multiset\n                 (map bsmapt q)) \\<Longrightarrow>\n     level x < Suc (queue_level q))", "apply (induct t and q rule: tree_level_queue_level.induct)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>uu_ uv_ qd uw_ q.\n       \\<lbrakk>x \\<in># image_mset fst\n                          (SkewBinomialHeapStruc.queue_to_multiset\n                            (map bsmapt qd)) \\<Longrightarrow>\n                level x < Suc (queue_level qd);\n        x \\<in># image_mset fst\n                  (SkewBinomialHeapStruc.queue_to_multiset\n                    (map bsmapt q)) \\<Longrightarrow>\n        level x < Suc (queue_level q);\n        x \\<in># image_mset fst\n                  (SkewBinomialHeapStruc.tree_to_multiset\n                    (bsmapt (BsNode (Element uu_ uv_ qd) uw_ q)))\\<rbrakk>\n       \\<Longrightarrow> level x\n                         < Suc (tree_level\n                                 (BsNode (Element uu_ uv_ qd) uw_ q))\n 2. x \\<in># image_mset fst\n              (SkewBinomialHeapStruc.queue_to_multiset\n                (map bsmapt [])) \\<Longrightarrow>\n    level x < Suc (queue_level [])\n 3. \\<And>t q.\n       \\<lbrakk>x \\<in># image_mset fst\n                          (SkewBinomialHeapStruc.tree_to_multiset\n                            (bsmapt t)) \\<Longrightarrow>\n                level x < Suc (tree_level t);\n        x \\<in># image_mset fst\n                  (SkewBinomialHeapStruc.queue_to_multiset\n                    (map bsmapt q)) \\<Longrightarrow>\n        level x < Suc (queue_level q);\n        x \\<in># image_mset fst\n                  (SkewBinomialHeapStruc.queue_to_multiset\n                    (map bsmapt (t # q)))\\<rbrakk>\n       \\<Longrightarrow> level x < Suc (queue_level (t # q))", "apply (case_tac [!] x)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>uu_ uv_ qd uw_ q x1 x2 x3.\n       \\<lbrakk>x \\<in># image_mset fst\n                          (SkewBinomialHeapStruc.queue_to_multiset\n                            (map bsmapt qd)) \\<Longrightarrow>\n                level x < Suc (queue_level qd);\n        x \\<in># image_mset fst\n                  (SkewBinomialHeapStruc.queue_to_multiset\n                    (map bsmapt q)) \\<Longrightarrow>\n        level x < Suc (queue_level q);\n        x \\<in># image_mset fst\n                  (SkewBinomialHeapStruc.tree_to_multiset\n                    (bsmapt (BsNode (Element uu_ uv_ qd) uw_ q)));\n        x = Element x1 x2 x3\\<rbrakk>\n       \\<Longrightarrow> level x\n                         < Suc (tree_level\n                                 (BsNode (Element uu_ uv_ qd) uw_ q))\n 2. \\<And>x1 x2 x3.\n       \\<lbrakk>x \\<in># image_mset fst\n                          (SkewBinomialHeapStruc.queue_to_multiset\n                            (map bsmapt []));\n        x = Element x1 x2 x3\\<rbrakk>\n       \\<Longrightarrow> level x < Suc (queue_level [])\n 3. \\<And>t q x1 x2 x3.\n       \\<lbrakk>x \\<in># image_mset fst\n                          (SkewBinomialHeapStruc.tree_to_multiset\n                            (bsmapt t)) \\<Longrightarrow>\n                level x < Suc (tree_level t);\n        x \\<in># image_mset fst\n                  (SkewBinomialHeapStruc.queue_to_multiset\n                    (map bsmapt q)) \\<Longrightarrow>\n        level x < Suc (queue_level q);\n        x \\<in># image_mset fst\n                  (SkewBinomialHeapStruc.queue_to_multiset\n                    (map bsmapt (t # q)));\n        x = Element x1 x2 x3\\<rbrakk>\n       \\<Longrightarrow> level x < Suc (queue_level (t # q))", "apply (auto simp add: less_max_iff_disj)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma level_measure:\n  \"x \\<in> set_mset (queue_to_multiset q) \\<Longrightarrow> (x,(Element e a q))\\<in>measure level\"\n  \"x \\<in># (queue_to_multiset q) \\<Longrightarrow> (x,(Element e a q))\\<in>measure level\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in># image_mset fst\n               (SkewBinomialHeapStruc.queue_to_multiset\n                 (map bsmapt q)) \\<Longrightarrow>\n     (x, Element e a q) \\<in> measure level) &&&\n    (x \\<in># image_mset fst\n               (SkewBinomialHeapStruc.queue_to_multiset\n                 (map bsmapt q)) \\<Longrightarrow>\n     (x, Element e a q) \\<in> measure level)", "apply (case_tac [!] x)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1 x2 x3.\n       \\<lbrakk>x \\<in># image_mset fst\n                          (SkewBinomialHeapStruc.queue_to_multiset\n                            (map bsmapt q));\n        x = Element x1 x2 x3\\<rbrakk>\n       \\<Longrightarrow> (x, Element e a q) \\<in> measure level\n 2. \\<And>x1 x2 x3.\n       \\<lbrakk>x \\<in># image_mset fst\n                          (SkewBinomialHeapStruc.queue_to_multiset\n                            (map bsmapt q));\n        x = Element x1 x2 x3\\<rbrakk>\n       \\<Longrightarrow> (x, Element e a q) \\<in> measure level", "apply (auto dest: level_m simp del: set_image_mset)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>\n  Invariant for elements\n\\<close>"], ["", "function elem_invar where\n  \"elem_invar (Element e a q) \\<longleftrightarrow>\n  (\\<forall>x. x\\<in># (queue_to_multiset q) \\<longrightarrow> a \\<le> eprio x \\<and> elem_invar x) \\<and> \n  invar q\""], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>P x.\n       (\\<And>e a q.\n           x = Element e a q \\<Longrightarrow> P) \\<Longrightarrow>\n       P\n 2. \\<And>e a q ea aa qa.\n       Element e a q = Element ea aa qa \\<Longrightarrow>\n       ((\\<forall>x.\n            x \\<in># image_mset fst\n                      (SkewBinomialHeapStruc.queue_to_multiset\n                        (map bsmapt q)) \\<longrightarrow>\n            a \\<le> eprio x \\<and> elem_invar_sumC x) \\<and>\n        SkewBinomialHeapStruc.invar (map bsmapt q)) =\n       ((\\<forall>x.\n            x \\<in># image_mset fst\n                      (SkewBinomialHeapStruc.queue_to_multiset\n                        (map bsmapt qa)) \\<longrightarrow>\n            aa \\<le> eprio x \\<and> elem_invar_sumC x) \\<and>\n        SkewBinomialHeapStruc.invar (map bsmapt qa))", "by pat_completeness auto"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. Wellfounded.accp elem_invar_rel x", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. wf ?R\n 2. \\<And>e a q x.\n       x \\<in># image_mset fst\n                 (SkewBinomialHeapStruc.queue_to_multiset\n                   (map bsmapt q)) \\<Longrightarrow>\n       (x, Element e a q) \\<in> ?R", "show \"wf (measure level)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf (measure level)", "by auto"], ["proof (state)\nthis:\n  wf (measure level)\n\ngoal (1 subgoal):\n 1. \\<And>e a q x.\n       x \\<in># image_mset fst\n                 (SkewBinomialHeapStruc.queue_to_multiset\n                   (map bsmapt q)) \\<Longrightarrow>\n       (x, Element e a q) \\<in> measure level", "qed (rule level_measure)"], ["", "text \\<open>\n  Abstraction to multisets\n\\<close>"], ["", "function elem_to_mset where\n  \"elem_to_mset (Element e a q) = {# (e,a) #} \n  + sum_mset (image_mset elem_to_mset (queue_to_multiset q))\""], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>P x.\n       (\\<And>e a q.\n           x = Element e a q \\<Longrightarrow> P) \\<Longrightarrow>\n       P\n 2. \\<And>e a q ea aa qa.\n       Element e a q = Element ea aa qa \\<Longrightarrow>\n       {#(e, a)#} +\n       \\<Sum>\\<^sub>#\n        (image_mset elem_to_mset_sumC\n          (image_mset fst\n            (SkewBinomialHeapStruc.queue_to_multiset (map bsmapt q)))) =\n       {#(ea, aa)#} +\n       \\<Sum>\\<^sub>#\n        (image_mset elem_to_mset_sumC\n          (image_mset fst\n            (SkewBinomialHeapStruc.queue_to_multiset (map bsmapt qa))))", "by pat_completeness auto"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. Wellfounded.accp elem_to_mset_rel x", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. wf ?R\n 2. \\<And>e a q z.\n       z \\<in># image_mset fst\n                 (SkewBinomialHeapStruc.queue_to_multiset\n                   (map bsmapt q)) \\<Longrightarrow>\n       (z, Element e a q) \\<in> ?R", "show \"wf (measure level)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf (measure level)", "by auto"], ["proof (state)\nthis:\n  wf (measure level)\n\ngoal (1 subgoal):\n 1. \\<And>e a q z.\n       z \\<in># image_mset fst\n                 (SkewBinomialHeapStruc.queue_to_multiset\n                   (map bsmapt q)) \\<Longrightarrow>\n       (z, Element e a q) \\<in> measure level", "qed (rule level_measure)"], ["", "lemma insert_correct':\n  assumes I: \"elem_invar x\"\n  shows \n  \"elem_invar (insert' e a x)\"\n  \"elem_to_mset (insert' e a x) = elem_to_mset x + {#(e,a)#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. elem_invar (insert' e a x) &&&\n    elem_to_mset (insert' e a x) = elem_to_mset x + {#(e, a)#}", "using I"], ["proof (prove)\nusing this:\n  elem_invar x\n\ngoal (1 subgoal):\n 1. elem_invar (insert' e a x) &&&\n    elem_to_mset (insert' e a x) = elem_to_mset x + {#(e, a)#}", "apply (case_tac [!] x)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1 x2 x3.\n       \\<lbrakk>elem_invar x; x = Element x1 x2 x3\\<rbrakk>\n       \\<Longrightarrow> elem_invar (insert' e a x)\n 2. \\<And>x1 x2 x3.\n       \\<lbrakk>elem_invar x; x = Element x1 x2 x3\\<rbrakk>\n       \\<Longrightarrow> elem_to_mset (insert' e a x) =\n                         elem_to_mset x + {#(e, a)#}", "apply (auto simp add: insert_correct union_ac)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma meld_correct':\n  assumes I: \"elem_invar x\" \"elem_invar x'\"\n  shows \n  \"elem_invar (meld' x x')\"\n  \"elem_to_mset (meld' x x') = elem_to_mset x + elem_to_mset x'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. elem_invar (meld' x x') &&&\n    elem_to_mset (meld' x x') = elem_to_mset x + elem_to_mset x'", "using I"], ["proof (prove)\nusing this:\n  elem_invar x\n  elem_invar x'\n\ngoal (1 subgoal):\n 1. elem_invar (meld' x x') &&&\n    elem_to_mset (meld' x x') = elem_to_mset x + elem_to_mset x'", "apply (case_tac [!] x)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1 x2 x3.\n       \\<lbrakk>elem_invar x; elem_invar x'; x = Element x1 x2 x3\\<rbrakk>\n       \\<Longrightarrow> elem_invar (meld' x x')\n 2. \\<And>x1 x2 x3.\n       \\<lbrakk>elem_invar x; elem_invar x'; x = Element x1 x2 x3\\<rbrakk>\n       \\<Longrightarrow> elem_to_mset (meld' x x') =\n                         elem_to_mset x + elem_to_mset x'", "apply (case_tac [!] x')"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1 x2 x3 x1a x2a x3a.\n       \\<lbrakk>elem_invar x; elem_invar x'; x = Element x1 x2 x3;\n        x' = Element x1a x2a x3a\\<rbrakk>\n       \\<Longrightarrow> elem_invar (meld' x x')\n 2. \\<And>x1 x2 x3 x1a x2a x3a.\n       \\<lbrakk>elem_invar x; elem_invar x'; x = Element x1 x2 x3;\n        x' = Element x1a x2a x3a\\<rbrakk>\n       \\<Longrightarrow> elem_to_mset (meld' x x') =\n                         elem_to_mset x + elem_to_mset x'", "apply (auto simp add: insert_correct union_ac)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma findMin'_min: \n  \"\\<lbrakk>elem_invar x; y\\<in>#elem_to_mset x\\<rbrakk> \\<Longrightarrow> snd (findMin' x) \\<le> snd y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>elem_invar x; y \\<in># elem_to_mset x\\<rbrakk>\n    \\<Longrightarrow> snd (findMin' x) \\<le> snd y", "proof (induct n\\<equiv>\"level x\" arbitrary: x rule: full_nat_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>m.\n                   Suc m \\<le> level x \\<longrightarrow>\n                   (\\<forall>x.\n                       m = level x \\<longrightarrow>\n                       elem_invar x \\<longrightarrow>\n                       y \\<in># elem_to_mset x \\<longrightarrow>\n                       snd (findMin' x) \\<le> snd y);\n        elem_invar x; y \\<in># elem_to_mset x\\<rbrakk>\n       \\<Longrightarrow> snd (findMin' x) \\<le> snd y", "case 1"], ["proof (state)\nthis:\n  \\<forall>m.\n     Suc m \\<le> level x \\<longrightarrow>\n     (\\<forall>x.\n         m = level x \\<longrightarrow>\n         elem_invar x \\<longrightarrow>\n         y \\<in># elem_to_mset x \\<longrightarrow>\n         snd (findMin' x) \\<le> snd y)\n  elem_invar x\n  y \\<in># elem_to_mset x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>m.\n                   Suc m \\<le> level x \\<longrightarrow>\n                   (\\<forall>x.\n                       m = level x \\<longrightarrow>\n                       elem_invar x \\<longrightarrow>\n                       y \\<in># elem_to_mset x \\<longrightarrow>\n                       snd (findMin' x) \\<le> snd y);\n        elem_invar x; y \\<in># elem_to_mset x\\<rbrakk>\n       \\<Longrightarrow> snd (findMin' x) \\<le> snd y", "note IH=\"1.hyps\"[rule_format, OF _ refl]"], ["proof (state)\nthis:\n  \\<lbrakk>Suc (level ?x) \\<le> level x; elem_invar ?x;\n   y \\<in># elem_to_mset ?x\\<rbrakk>\n  \\<Longrightarrow> snd (findMin' ?x) \\<le> snd y\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>m.\n                   Suc m \\<le> level x \\<longrightarrow>\n                   (\\<forall>x.\n                       m = level x \\<longrightarrow>\n                       elem_invar x \\<longrightarrow>\n                       y \\<in># elem_to_mset x \\<longrightarrow>\n                       snd (findMin' x) \\<le> snd y);\n        elem_invar x; y \\<in># elem_to_mset x\\<rbrakk>\n       \\<Longrightarrow> snd (findMin' x) \\<le> snd y", "note PREMS=\"1.prems\""], ["proof (state)\nthis:\n  elem_invar x\n  y \\<in># elem_to_mset x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>m.\n                   Suc m \\<le> level x \\<longrightarrow>\n                   (\\<forall>x.\n                       m = level x \\<longrightarrow>\n                       elem_invar x \\<longrightarrow>\n                       y \\<in># elem_to_mset x \\<longrightarrow>\n                       snd (findMin' x) \\<le> snd y);\n        elem_invar x; y \\<in># elem_to_mset x\\<rbrakk>\n       \\<Longrightarrow> snd (findMin' x) \\<le> snd y", "obtain e a q where [simp]: \"x=Element e a q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>e a q.\n        x = Element e a q \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases x) auto"], ["proof (state)\nthis:\n  x = Element e a q\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>m.\n                   Suc m \\<le> level x \\<longrightarrow>\n                   (\\<forall>x.\n                       m = level x \\<longrightarrow>\n                       elem_invar x \\<longrightarrow>\n                       y \\<in># elem_to_mset x \\<longrightarrow>\n                       snd (findMin' x) \\<le> snd y);\n        elem_invar x; y \\<in># elem_to_mset x\\<rbrakk>\n       \\<Longrightarrow> snd (findMin' x) \\<le> snd y", "from PREMS(2)"], ["proof (chain)\npicking this:\n  y \\<in># elem_to_mset x", "have \"y=(e,a) \\<or> \n    y\\<in>#sum_mset (image_mset elem_to_mset (queue_to_multiset q))\"\n    (is \"?C1 \\<or> ?C2\")"], ["proof (prove)\nusing this:\n  y \\<in># elem_to_mset x\n\ngoal (1 subgoal):\n 1. y = (e, a) \\<or>\n    y \\<in># \\<Sum>\\<^sub>#\n              (image_mset elem_to_mset\n                (image_mset fst\n                  (SkewBinomialHeapStruc.queue_to_multiset (map bsmapt q))))", "by (auto split: if_split_asm)"], ["proof (state)\nthis:\n  y = (e, a) \\<or>\n  y \\<in># \\<Sum>\\<^sub>#\n            (image_mset elem_to_mset\n              (image_mset fst\n                (SkewBinomialHeapStruc.queue_to_multiset (map bsmapt q))))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>m.\n                   Suc m \\<le> level x \\<longrightarrow>\n                   (\\<forall>x.\n                       m = level x \\<longrightarrow>\n                       elem_invar x \\<longrightarrow>\n                       y \\<in># elem_to_mset x \\<longrightarrow>\n                       snd (findMin' x) \\<le> snd y);\n        elem_invar x; y \\<in># elem_to_mset x\\<rbrakk>\n       \\<Longrightarrow> snd (findMin' x) \\<le> snd y", "moreover"], ["proof (state)\nthis:\n  y = (e, a) \\<or>\n  y \\<in># \\<Sum>\\<^sub>#\n            (image_mset elem_to_mset\n              (image_mset fst\n                (SkewBinomialHeapStruc.queue_to_multiset (map bsmapt q))))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>m.\n                   Suc m \\<le> level x \\<longrightarrow>\n                   (\\<forall>x.\n                       m = level x \\<longrightarrow>\n                       elem_invar x \\<longrightarrow>\n                       y \\<in># elem_to_mset x \\<longrightarrow>\n                       snd (findMin' x) \\<le> snd y);\n        elem_invar x; y \\<in># elem_to_mset x\\<rbrakk>\n       \\<Longrightarrow> snd (findMin' x) \\<le> snd y", "{"], ["proof (state)\nthis:\n  y = (e, a) \\<or>\n  y \\<in># \\<Sum>\\<^sub>#\n            (image_mset elem_to_mset\n              (image_mset fst\n                (SkewBinomialHeapStruc.queue_to_multiset (map bsmapt q))))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>m.\n                   Suc m \\<le> level x \\<longrightarrow>\n                   (\\<forall>x.\n                       m = level x \\<longrightarrow>\n                       elem_invar x \\<longrightarrow>\n                       y \\<in># elem_to_mset x \\<longrightarrow>\n                       snd (findMin' x) \\<le> snd y);\n        elem_invar x; y \\<in># elem_to_mset x\\<rbrakk>\n       \\<Longrightarrow> snd (findMin' x) \\<le> snd y", "assume \"y=(e,a)\""], ["proof (state)\nthis:\n  y = (e, a)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>m.\n                   Suc m \\<le> level x \\<longrightarrow>\n                   (\\<forall>x.\n                       m = level x \\<longrightarrow>\n                       elem_invar x \\<longrightarrow>\n                       y \\<in># elem_to_mset x \\<longrightarrow>\n                       snd (findMin' x) \\<le> snd y);\n        elem_invar x; y \\<in># elem_to_mset x\\<rbrakk>\n       \\<Longrightarrow> snd (findMin' x) \\<le> snd y", "with PREMS"], ["proof (chain)\npicking this:\n  elem_invar x\n  y \\<in># elem_to_mset x\n  y = (e, a)", "have ?case"], ["proof (prove)\nusing this:\n  elem_invar x\n  y \\<in># elem_to_mset x\n  y = (e, a)\n\ngoal (1 subgoal):\n 1. snd (findMin' x) \\<le> snd y", "by simp"], ["proof (state)\nthis:\n  snd (findMin' x) \\<le> snd y\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>m.\n                   Suc m \\<le> level x \\<longrightarrow>\n                   (\\<forall>x.\n                       m = level x \\<longrightarrow>\n                       elem_invar x \\<longrightarrow>\n                       y \\<in># elem_to_mset x \\<longrightarrow>\n                       snd (findMin' x) \\<le> snd y);\n        elem_invar x; y \\<in># elem_to_mset x\\<rbrakk>\n       \\<Longrightarrow> snd (findMin' x) \\<le> snd y", "}"], ["proof (state)\nthis:\n  y = (e, a) \\<Longrightarrow> snd (findMin' x) \\<le> snd y\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>m.\n                   Suc m \\<le> level x \\<longrightarrow>\n                   (\\<forall>x.\n                       m = level x \\<longrightarrow>\n                       elem_invar x \\<longrightarrow>\n                       y \\<in># elem_to_mset x \\<longrightarrow>\n                       snd (findMin' x) \\<le> snd y);\n        elem_invar x; y \\<in># elem_to_mset x\\<rbrakk>\n       \\<Longrightarrow> snd (findMin' x) \\<le> snd y", "moreover"], ["proof (state)\nthis:\n  y = (e, a) \\<Longrightarrow> snd (findMin' x) \\<le> snd y\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>m.\n                   Suc m \\<le> level x \\<longrightarrow>\n                   (\\<forall>x.\n                       m = level x \\<longrightarrow>\n                       elem_invar x \\<longrightarrow>\n                       y \\<in># elem_to_mset x \\<longrightarrow>\n                       snd (findMin' x) \\<le> snd y);\n        elem_invar x; y \\<in># elem_to_mset x\\<rbrakk>\n       \\<Longrightarrow> snd (findMin' x) \\<le> snd y", "{"], ["proof (state)\nthis:\n  y = (e, a) \\<Longrightarrow> snd (findMin' x) \\<le> snd y\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>m.\n                   Suc m \\<le> level x \\<longrightarrow>\n                   (\\<forall>x.\n                       m = level x \\<longrightarrow>\n                       elem_invar x \\<longrightarrow>\n                       y \\<in># elem_to_mset x \\<longrightarrow>\n                       snd (findMin' x) \\<le> snd y);\n        elem_invar x; y \\<in># elem_to_mset x\\<rbrakk>\n       \\<Longrightarrow> snd (findMin' x) \\<le> snd y", "assume ?C2"], ["proof (state)\nthis:\n  y \\<in># \\<Sum>\\<^sub>#\n            (image_mset elem_to_mset\n              (image_mset fst\n                (SkewBinomialHeapStruc.queue_to_multiset (map bsmapt q))))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>m.\n                   Suc m \\<le> level x \\<longrightarrow>\n                   (\\<forall>x.\n                       m = level x \\<longrightarrow>\n                       elem_invar x \\<longrightarrow>\n                       y \\<in># elem_to_mset x \\<longrightarrow>\n                       snd (findMin' x) \\<le> snd y);\n        elem_invar x; y \\<in># elem_to_mset x\\<rbrakk>\n       \\<Longrightarrow> snd (findMin' x) \\<le> snd y", "then"], ["proof (chain)\npicking this:\n  y \\<in># \\<Sum>\\<^sub>#\n            (image_mset elem_to_mset\n              (image_mset fst\n                (SkewBinomialHeapStruc.queue_to_multiset (map bsmapt q))))", "obtain yx where \n      A: \"yx \\<in># queue_to_multiset q\"  and\n      B: \"y \\<in># elem_to_mset yx\""], ["proof (prove)\nusing this:\n  y \\<in># \\<Sum>\\<^sub>#\n            (image_mset elem_to_mset\n              (image_mset fst\n                (SkewBinomialHeapStruc.queue_to_multiset (map bsmapt q))))\n\ngoal (1 subgoal):\n 1. (\\<And>yx.\n        \\<lbrakk>yx \\<in># image_mset fst\n                            (SkewBinomialHeapStruc.queue_to_multiset\n                              (map bsmapt q));\n         y \\<in># elem_to_mset yx\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "apply (auto elim!: in_image_msetE)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  yx \\<in># image_mset fst\n             (SkewBinomialHeapStruc.queue_to_multiset (map bsmapt q))\n  y \\<in># elem_to_mset yx\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>m.\n                   Suc m \\<le> level x \\<longrightarrow>\n                   (\\<forall>x.\n                       m = level x \\<longrightarrow>\n                       elem_invar x \\<longrightarrow>\n                       y \\<in># elem_to_mset x \\<longrightarrow>\n                       snd (findMin' x) \\<le> snd y);\n        elem_invar x; y \\<in># elem_to_mset x\\<rbrakk>\n       \\<Longrightarrow> snd (findMin' x) \\<le> snd y", "from A PREMS"], ["proof (chain)\npicking this:\n  yx \\<in># image_mset fst\n             (SkewBinomialHeapStruc.queue_to_multiset (map bsmapt q))\n  elem_invar x\n  y \\<in># elem_to_mset x", "have IYX: \"elem_invar yx\""], ["proof (prove)\nusing this:\n  yx \\<in># image_mset fst\n             (SkewBinomialHeapStruc.queue_to_multiset (map bsmapt q))\n  elem_invar x\n  y \\<in># elem_to_mset x\n\ngoal (1 subgoal):\n 1. elem_invar yx", "by auto"], ["proof (state)\nthis:\n  elem_invar yx\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>m.\n                   Suc m \\<le> level x \\<longrightarrow>\n                   (\\<forall>x.\n                       m = level x \\<longrightarrow>\n                       elem_invar x \\<longrightarrow>\n                       y \\<in># elem_to_mset x \\<longrightarrow>\n                       snd (findMin' x) \\<le> snd y);\n        elem_invar x; y \\<in># elem_to_mset x\\<rbrakk>\n       \\<Longrightarrow> snd (findMin' x) \\<le> snd y", "from PREMS(1) A"], ["proof (chain)\npicking this:\n  elem_invar x\n  yx \\<in># image_mset fst\n             (SkewBinomialHeapStruc.queue_to_multiset (map bsmapt q))", "have \"a \\<le> eprio yx\""], ["proof (prove)\nusing this:\n  elem_invar x\n  yx \\<in># image_mset fst\n             (SkewBinomialHeapStruc.queue_to_multiset (map bsmapt q))\n\ngoal (1 subgoal):\n 1. a \\<le> eprio yx", "by auto"], ["proof (state)\nthis:\n  a \\<le> eprio yx\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>m.\n                   Suc m \\<le> level x \\<longrightarrow>\n                   (\\<forall>x.\n                       m = level x \\<longrightarrow>\n                       elem_invar x \\<longrightarrow>\n                       y \\<in># elem_to_mset x \\<longrightarrow>\n                       snd (findMin' x) \\<le> snd y);\n        elem_invar x; y \\<in># elem_to_mset x\\<rbrakk>\n       \\<Longrightarrow> snd (findMin' x) \\<le> snd y", "hence \"snd (findMin' x) \\<le> snd (findMin' yx)\""], ["proof (prove)\nusing this:\n  a \\<le> eprio yx\n\ngoal (1 subgoal):\n 1. snd (findMin' x) \\<le> snd (findMin' yx)", "by (cases yx) auto"], ["proof (state)\nthis:\n  snd (findMin' x) \\<le> snd (findMin' yx)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>m.\n                   Suc m \\<le> level x \\<longrightarrow>\n                   (\\<forall>x.\n                       m = level x \\<longrightarrow>\n                       elem_invar x \\<longrightarrow>\n                       y \\<in># elem_to_mset x \\<longrightarrow>\n                       snd (findMin' x) \\<le> snd y);\n        elem_invar x; y \\<in># elem_to_mset x\\<rbrakk>\n       \\<Longrightarrow> snd (findMin' x) \\<le> snd y", "also"], ["proof (state)\nthis:\n  snd (findMin' x) \\<le> snd (findMin' yx)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>m.\n                   Suc m \\<le> level x \\<longrightarrow>\n                   (\\<forall>x.\n                       m = level x \\<longrightarrow>\n                       elem_invar x \\<longrightarrow>\n                       y \\<in># elem_to_mset x \\<longrightarrow>\n                       snd (findMin' x) \\<le> snd y);\n        elem_invar x; y \\<in># elem_to_mset x\\<rbrakk>\n       \\<Longrightarrow> snd (findMin' x) \\<le> snd y", "from IH[OF _ IYX B] level_m(2)[OF A]"], ["proof (chain)\npicking this:\n  Suc (level yx) \\<le> level x \\<Longrightarrow>\n  snd (findMin' yx) \\<le> snd y\n  level yx < Suc (queue_level q)", "have \"snd (findMin' yx) \\<le> snd y\""], ["proof (prove)\nusing this:\n  Suc (level yx) \\<le> level x \\<Longrightarrow>\n  snd (findMin' yx) \\<le> snd y\n  level yx < Suc (queue_level q)\n\ngoal (1 subgoal):\n 1. snd (findMin' yx) \\<le> snd y", "by simp"], ["proof (state)\nthis:\n  snd (findMin' yx) \\<le> snd y\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>m.\n                   Suc m \\<le> level x \\<longrightarrow>\n                   (\\<forall>x.\n                       m = level x \\<longrightarrow>\n                       elem_invar x \\<longrightarrow>\n                       y \\<in># elem_to_mset x \\<longrightarrow>\n                       snd (findMin' x) \\<le> snd y);\n        elem_invar x; y \\<in># elem_to_mset x\\<rbrakk>\n       \\<Longrightarrow> snd (findMin' x) \\<le> snd y", "finally"], ["proof (chain)\npicking this:\n  snd (findMin' x) \\<le> snd y", "have ?case"], ["proof (prove)\nusing this:\n  snd (findMin' x) \\<le> snd y\n\ngoal (1 subgoal):\n 1. snd (findMin' x) \\<le> snd y", "."], ["proof (state)\nthis:\n  snd (findMin' x) \\<le> snd y\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>m.\n                   Suc m \\<le> level x \\<longrightarrow>\n                   (\\<forall>x.\n                       m = level x \\<longrightarrow>\n                       elem_invar x \\<longrightarrow>\n                       y \\<in># elem_to_mset x \\<longrightarrow>\n                       snd (findMin' x) \\<le> snd y);\n        elem_invar x; y \\<in># elem_to_mset x\\<rbrakk>\n       \\<Longrightarrow> snd (findMin' x) \\<le> snd y", "}"], ["proof (state)\nthis:\n  y \\<in># \\<Sum>\\<^sub>#\n            (image_mset elem_to_mset\n              (image_mset fst\n                (SkewBinomialHeapStruc.queue_to_multiset\n                  (map bsmapt q)))) \\<Longrightarrow>\n  snd (findMin' x) \\<le> snd y\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>m.\n                   Suc m \\<le> level x \\<longrightarrow>\n                   (\\<forall>x.\n                       m = level x \\<longrightarrow>\n                       elem_invar x \\<longrightarrow>\n                       y \\<in># elem_to_mset x \\<longrightarrow>\n                       snd (findMin' x) \\<le> snd y);\n        elem_invar x; y \\<in># elem_to_mset x\\<rbrakk>\n       \\<Longrightarrow> snd (findMin' x) \\<le> snd y", "ultimately"], ["proof (chain)\npicking this:\n  y = (e, a) \\<or>\n  y \\<in># \\<Sum>\\<^sub>#\n            (image_mset elem_to_mset\n              (image_mset fst\n                (SkewBinomialHeapStruc.queue_to_multiset (map bsmapt q))))\n  y = (e, a) \\<Longrightarrow> snd (findMin' x) \\<le> snd y\n  y \\<in># \\<Sum>\\<^sub>#\n            (image_mset elem_to_mset\n              (image_mset fst\n                (SkewBinomialHeapStruc.queue_to_multiset\n                  (map bsmapt q)))) \\<Longrightarrow>\n  snd (findMin' x) \\<le> snd y", "show ?case"], ["proof (prove)\nusing this:\n  y = (e, a) \\<or>\n  y \\<in># \\<Sum>\\<^sub>#\n            (image_mset elem_to_mset\n              (image_mset fst\n                (SkewBinomialHeapStruc.queue_to_multiset (map bsmapt q))))\n  y = (e, a) \\<Longrightarrow> snd (findMin' x) \\<le> snd y\n  y \\<in># \\<Sum>\\<^sub>#\n            (image_mset elem_to_mset\n              (image_mset fst\n                (SkewBinomialHeapStruc.queue_to_multiset\n                  (map bsmapt q)))) \\<Longrightarrow>\n  snd (findMin' x) \\<le> snd y\n\ngoal (1 subgoal):\n 1. snd (findMin' x) \\<le> snd y", "by blast"], ["proof (state)\nthis:\n  snd (findMin' x) \\<le> snd y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma findMin_correct':\n  assumes I: \"elem_invar x\"\n  shows\n  \"findMin' x \\<in># elem_to_mset x\"\n  \"\\<forall>y\\<in>set_mset (elem_to_mset x). snd (findMin' x) \\<le> snd y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. findMin' x \\<in># elem_to_mset x &&&\n    \\<forall>y\\<in>#elem_to_mset x. snd (findMin' x) \\<le> snd y", "using I"], ["proof (prove)\nusing this:\n  elem_invar x\n\ngoal (1 subgoal):\n 1. findMin' x \\<in># elem_to_mset x &&&\n    \\<forall>y\\<in>#elem_to_mset x. snd (findMin' x) \\<le> snd y", "apply (cases x)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1 x2 x3.\n       \\<lbrakk>elem_invar x; x = Element x1 x2 x3\\<rbrakk>\n       \\<Longrightarrow> findMin' x \\<in># elem_to_mset x\n 2. \\<forall>y\\<in>#elem_to_mset x. snd (findMin' x) \\<le> snd y", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>y\\<in>#elem_to_mset x. snd (findMin' x) \\<le> snd y", "apply (simp add: findMin'_min[OF I])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma deleteMin_correct':\n  assumes I: \"elem_invar (Element e a q)\"\n  assumes NE[simp]: \"q\\<noteq>[]\"\n  shows \n    \"elem_invar (deleteMin' (Element e a q))\"\n    \"elem_to_mset (deleteMin' (Element e a q)) = \n       elem_to_mset (Element e a q) - {# findMin' (Element e a q) #}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. elem_invar (deleteMin' (Element e a q)) &&&\n    elem_to_mset (deleteMin' (Element e a q)) =\n    elem_to_mset (Element e a q) - {#findMin' (Element e a q)#}", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. elem_invar (deleteMin' (Element e a q))\n 2. elem_to_mset (deleteMin' (Element e a q)) =\n    elem_to_mset (Element e a q) - {#findMin' (Element e a q)#}", "from I"], ["proof (chain)\npicking this:\n  elem_invar (Element e a q)", "have IQ[simp]: \"invar q\""], ["proof (prove)\nusing this:\n  elem_invar (Element e a q)\n\ngoal (1 subgoal):\n 1. SkewBinomialHeapStruc.invar (map bsmapt q)", "by simp"], ["proof (state)\nthis:\n  SkewBinomialHeapStruc.invar (map bsmapt q)\n\ngoal (2 subgoals):\n 1. elem_invar (deleteMin' (Element e a q))\n 2. elem_to_mset (deleteMin' (Element e a q)) =\n    elem_to_mset (Element e a q) - {#findMin' (Element e a q)#}", "from findMin_correct[OF IQ NE]"], ["proof (chain)\npicking this:\n  findMin q\n  \\<in># image_mset fst\n          (SkewBinomialHeapStruc.queue_to_multiset (map bsmapt q))\n  \\<forall>y\\<in>#image_mset fst\n                   (SkewBinomialHeapStruc.queue_to_multiset (map bsmapt q)).\n     eprio (findMin q) \\<le> eprio y", "have\n    FMIQ: \"findMin q \\<in># queue_to_multiset q\" and\n    FMIN: \"!!y. y\\<in>#(queue_to_multiset q) \\<Longrightarrow> eprio (findMin q) \\<le> eprio y\""], ["proof (prove)\nusing this:\n  findMin q\n  \\<in># image_mset fst\n          (SkewBinomialHeapStruc.queue_to_multiset (map bsmapt q))\n  \\<forall>y\\<in>#image_mset fst\n                   (SkewBinomialHeapStruc.queue_to_multiset (map bsmapt q)).\n     eprio (findMin q) \\<le> eprio y\n\ngoal (1 subgoal):\n 1. findMin q\n    \\<in># image_mset fst\n            (SkewBinomialHeapStruc.queue_to_multiset (map bsmapt q)) &&&\n    (\\<And>y.\n        y \\<in># image_mset fst\n                  (SkewBinomialHeapStruc.queue_to_multiset\n                    (map bsmapt q)) \\<Longrightarrow>\n        eprio (findMin q) \\<le> eprio y)", "by (auto simp del: set_image_mset)"], ["proof (state)\nthis:\n  findMin q\n  \\<in># image_mset fst\n          (SkewBinomialHeapStruc.queue_to_multiset (map bsmapt q))\n  ?y \\<in># image_mset fst\n             (SkewBinomialHeapStruc.queue_to_multiset\n               (map bsmapt q)) \\<Longrightarrow>\n  eprio (findMin q) \\<le> eprio ?y\n\ngoal (2 subgoals):\n 1. elem_invar (deleteMin' (Element e a q))\n 2. elem_to_mset (deleteMin' (Element e a q)) =\n    elem_to_mset (Element e a q) - {#findMin' (Element e a q)#}", "from FMIQ I"], ["proof (chain)\npicking this:\n  findMin q\n  \\<in># image_mset fst\n          (SkewBinomialHeapStruc.queue_to_multiset (map bsmapt q))\n  elem_invar (Element e a q)", "have FMEI: \"elem_invar (findMin q)\""], ["proof (prove)\nusing this:\n  findMin q\n  \\<in># image_mset fst\n          (SkewBinomialHeapStruc.queue_to_multiset (map bsmapt q))\n  elem_invar (Element e a q)\n\ngoal (1 subgoal):\n 1. elem_invar (findMin q)", "by auto"], ["proof (state)\nthis:\n  elem_invar (findMin q)\n\ngoal (2 subgoals):\n 1. elem_invar (deleteMin' (Element e a q))\n 2. elem_to_mset (deleteMin' (Element e a q)) =\n    elem_to_mset (Element e a q) - {#findMin' (Element e a q)#}", "from I"], ["proof (chain)\npicking this:\n  elem_invar (Element e a q)", "have FEI: \"!!y. y\\<in>#(queue_to_multiset q) \\<Longrightarrow> elem_invar y\""], ["proof (prove)\nusing this:\n  elem_invar (Element e a q)\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<in># image_mset fst\n                 (SkewBinomialHeapStruc.queue_to_multiset\n                   (map bsmapt q)) \\<Longrightarrow>\n       elem_invar y", "by auto"], ["proof (state)\nthis:\n  ?y \\<in># image_mset fst\n             (SkewBinomialHeapStruc.queue_to_multiset\n               (map bsmapt q)) \\<Longrightarrow>\n  elem_invar ?y\n\ngoal (2 subgoals):\n 1. elem_invar (deleteMin' (Element e a q))\n 2. elem_to_mset (deleteMin' (Element e a q)) =\n    elem_to_mset (Element e a q) - {#findMin' (Element e a q)#}", "obtain ey ay qy where [simp]: \"findMin q = Element ey ay qy\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ey ay qy.\n        findMin q = Element ey ay qy \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases \"findMin q\") auto"], ["proof (state)\nthis:\n  findMin q = Element ey ay qy\n\ngoal (2 subgoals):\n 1. elem_invar (deleteMin' (Element e a q))\n 2. elem_to_mset (deleteMin' (Element e a q)) =\n    elem_to_mset (Element e a q) - {#findMin' (Element e a q)#}", "from FMEI"], ["proof (chain)\npicking this:\n  elem_invar (findMin q)", "have \n    IQY[simp]: \"invar qy\" and\n    AYMIN: \"!!x. x \\<in># queue_to_multiset qy \\<Longrightarrow> ay \\<le> eprio x\" and \n    QEI: \"!!x. x \\<in># queue_to_multiset qy \\<Longrightarrow> elem_invar x\""], ["proof (prove)\nusing this:\n  elem_invar (findMin q)\n\ngoal (1 subgoal):\n 1. SkewBinomialHeapStruc.invar (map bsmapt qy) &&&\n    (\\<And>x.\n        x \\<in># image_mset fst\n                  (SkewBinomialHeapStruc.queue_to_multiset\n                    (map bsmapt qy)) \\<Longrightarrow>\n        ay \\<le> eprio x) &&&\n    (\\<And>x.\n        x \\<in># image_mset fst\n                  (SkewBinomialHeapStruc.queue_to_multiset\n                    (map bsmapt qy)) \\<Longrightarrow>\n        elem_invar x)", "by auto"], ["proof (state)\nthis:\n  SkewBinomialHeapStruc.invar (map bsmapt qy)\n  ?x \\<in># image_mset fst\n             (SkewBinomialHeapStruc.queue_to_multiset\n               (map bsmapt qy)) \\<Longrightarrow>\n  ay \\<le> eprio ?x\n  ?x \\<in># image_mset fst\n             (SkewBinomialHeapStruc.queue_to_multiset\n               (map bsmapt qy)) \\<Longrightarrow>\n  elem_invar ?x\n\ngoal (2 subgoals):\n 1. elem_invar (deleteMin' (Element e a q))\n 2. elem_to_mset (deleteMin' (Element e a q)) =\n    elem_to_mset (Element e a q) - {#findMin' (Element e a q)#}", "show \"elem_invar (deleteMin' (Element e a q))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. elem_invar (deleteMin' (Element e a q))", "using AYMIN QEI FMIN FEI"], ["proof (prove)\nusing this:\n  ?x \\<in># image_mset fst\n             (SkewBinomialHeapStruc.queue_to_multiset\n               (map bsmapt qy)) \\<Longrightarrow>\n  ay \\<le> eprio ?x\n  ?x \\<in># image_mset fst\n             (SkewBinomialHeapStruc.queue_to_multiset\n               (map bsmapt qy)) \\<Longrightarrow>\n  elem_invar ?x\n  ?y \\<in># image_mset fst\n             (SkewBinomialHeapStruc.queue_to_multiset\n               (map bsmapt q)) \\<Longrightarrow>\n  eprio (findMin q) \\<le> eprio ?y\n  ?y \\<in># image_mset fst\n             (SkewBinomialHeapStruc.queue_to_multiset\n               (map bsmapt q)) \\<Longrightarrow>\n  elem_invar ?y\n\ngoal (1 subgoal):\n 1. elem_invar (deleteMin' (Element e a q))", "by (auto simp add: deleteMin_correct meld_correct in_diff_count)"], ["proof (state)\nthis:\n  elem_invar (deleteMin' (Element e a q))\n\ngoal (1 subgoal):\n 1. elem_to_mset (deleteMin' (Element e a q)) =\n    elem_to_mset (Element e a q) - {#findMin' (Element e a q)#}", "from FMIQ"], ["proof (chain)\npicking this:\n  findMin q\n  \\<in># image_mset fst\n          (SkewBinomialHeapStruc.queue_to_multiset (map bsmapt q))", "have \n    S: \"(queue_to_multiset q - {#Element ey ay qy#}) + {#Element ey ay qy#} \n    = queue_to_multiset q\""], ["proof (prove)\nusing this:\n  findMin q\n  \\<in># image_mset fst\n          (SkewBinomialHeapStruc.queue_to_multiset (map bsmapt q))\n\ngoal (1 subgoal):\n 1. image_mset fst\n     (SkewBinomialHeapStruc.queue_to_multiset (map bsmapt q)) -\n    {#Element ey ay qy#} +\n    {#Element ey ay qy#} =\n    image_mset fst (SkewBinomialHeapStruc.queue_to_multiset (map bsmapt q))", "by simp"], ["proof (state)\nthis:\n  image_mset fst (SkewBinomialHeapStruc.queue_to_multiset (map bsmapt q)) -\n  {#Element ey ay qy#} +\n  {#Element ey ay qy#} =\n  image_mset fst (SkewBinomialHeapStruc.queue_to_multiset (map bsmapt q))\n\ngoal (1 subgoal):\n 1. elem_to_mset (deleteMin' (Element e a q)) =\n    elem_to_mset (Element e a q) - {#findMin' (Element e a q)#}", "show \"elem_to_mset (deleteMin' (Element e a q)) = \n    elem_to_mset (Element e a q) - {# findMin' (Element e a q) #}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. elem_to_mset (deleteMin' (Element e a q)) =\n    elem_to_mset (Element e a q) - {#findMin' (Element e a q)#}", "apply (simp add: deleteMin_correct meld_correct)"], ["proof (prove)\ngoal (1 subgoal):\n 1. add_mset (ey, ay)\n     (\\<Sum>\\<^sub>#\n       (image_mset elem_to_mset\n         (image_mset fst\n           (SkewBinomialHeapStruc.queue_to_multiset (map bsmapt qy)))) +\n      \\<Sum>\\<^sub>#\n       (image_mset elem_to_mset\n         (image_mset fst\n           (SkewBinomialHeapStruc.queue_to_multiset (map bsmapt q)) -\n          {#Element ey ay qy#}))) =\n    \\<Sum>\\<^sub>#\n     (image_mset elem_to_mset\n       (image_mset fst\n         (SkewBinomialHeapStruc.queue_to_multiset (map bsmapt q))))", "by (subst S[symmetric], simp add: union_ac)"], ["proof (state)\nthis:\n  elem_to_mset (deleteMin' (Element e a q)) =\n  elem_to_mset (Element e a q) - {#findMin' (Element e a q)#}\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \"Bootstrapping: Phase 2\""], ["", "text \\<open>\n  In this phase, we extend the ticked versions to also work with\n  empty priority queues.\n\\<close>"], ["", "definition bs_empty where \"bs_empty \\<equiv> Inl ()\""], ["", "primrec bs_findMin where\n  \"bs_findMin (Inr x) = findMin' x\""], ["", "fun bs_meld \n  :: \"('e,'a::linorder) BsSkewHeap \\<Rightarrow> ('e,'a) BsSkewHeap \\<Rightarrow> ('e,'a) BsSkewHeap\"\n  where\n  \"bs_meld (Inl _) x = x\" |\n  \"bs_meld x (Inl _) = x\" |\n  \"bs_meld (Inr x) (Inr x') = Inr (meld' x x')\""], ["", "lemma [simp]: \"bs_meld x (Inl u) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bs_meld x (Inl u) = x", "by (cases x) auto"], ["", "primrec bs_insert \n  :: \"'e \\<Rightarrow> ('a::linorder) \\<Rightarrow> ('e,'a) BsSkewHeap \\<Rightarrow> ('e,'a) BsSkewHeap\"\n  where\n  \"bs_insert e a (Inl _) = Inr (Element e a [])\" |\n  \"bs_insert e a (Inr x) = Inr (insert' e a x)\""], ["", "fun bs_deleteMin \n  :: \"('e,'a::linorder) BsSkewHeap \\<Rightarrow> ('e,'a) BsSkewHeap\"\n  where\n  \"bs_deleteMin (Inr (Element e a [])) = Inl ()\" |\n  \"bs_deleteMin (Inr (Element e a q)) = Inr (deleteMin' (Element e a q))\""], ["", "primrec bs_invar :: \"('e,'a::linorder) BsSkewHeap \\<Rightarrow> bool\"\nwhere\n  \"bs_invar (Inl _) \\<longleftrightarrow> True\" |\n  \"bs_invar (Inr x) \\<longleftrightarrow> elem_invar x\""], ["", "lemma [simp]: \"bs_invar bs_empty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bs_invar bs_empty", "by (simp add: bs_empty_def)"], ["", "primrec bs_to_mset :: \"('e,'a::linorder) BsSkewHeap \\<Rightarrow> ('e\\<times>'a) multiset\"\nwhere\n  \"bs_to_mset (Inl _) = {#}\" |\n  \"bs_to_mset (Inr x) = elem_to_mset x\""], ["", "theorem bs_empty_correct: \"h=bs_empty \\<longleftrightarrow> bs_to_mset h = {#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (h = bs_empty) = (bs_to_mset h = {#})", "apply (unfold bs_empty_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (h = Inl ()) = (bs_to_mset h = {#})", "apply (cases h)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a. h = Inl a \\<Longrightarrow> (h = Inl ()) = (bs_to_mset h = {#})\n 2. \\<And>b. h = Inr b \\<Longrightarrow> (h = Inl ()) = (bs_to_mset h = {#})", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b. h = Inr b \\<Longrightarrow> (h = Inl ()) = (bs_to_mset h = {#})", "apply (case_tac b)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b x1 x2 x3.\n       \\<lbrakk>h = Inr b; b = Element x1 x2 x3\\<rbrakk>\n       \\<Longrightarrow> (h = Inl ()) = (bs_to_mset h = {#})", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma bs_mset_of_empty[simp]:\n  \"bs_to_mset bs_empty = {#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bs_to_mset bs_empty = {#}", "by (simp add: bs_empty_def)"], ["", "theorem bs_findMin_correct:\n  assumes I: \"bs_invar h\"\n  assumes NE: \"h\\<noteq>bs_empty\"\n  shows \"bs_findMin h \\<in># bs_to_mset h\"\n        \"\\<forall>y\\<in>set_mset (bs_to_mset h). snd (bs_findMin h) \\<le> snd y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bs_findMin h \\<in># bs_to_mset h &&&\n    \\<forall>y\\<in>#bs_to_mset h. snd (bs_findMin h) \\<le> snd y", "using I NE"], ["proof (prove)\nusing this:\n  bs_invar h\n  h \\<noteq> bs_empty\n\ngoal (1 subgoal):\n 1. bs_findMin h \\<in># bs_to_mset h &&&\n    \\<forall>y\\<in>#bs_to_mset h. snd (bs_findMin h) \\<le> snd y", "apply (case_tac [!] h)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>bs_invar h; h \\<noteq> bs_empty; h = Inl a\\<rbrakk>\n       \\<Longrightarrow> bs_findMin h \\<in># bs_to_mset h\n 2. \\<And>b.\n       \\<lbrakk>bs_invar h; h \\<noteq> bs_empty; h = Inr b\\<rbrakk>\n       \\<Longrightarrow> bs_findMin h \\<in># bs_to_mset h\n 3. \\<And>a.\n       \\<lbrakk>bs_invar h; h \\<noteq> bs_empty; h = Inl a\\<rbrakk>\n       \\<Longrightarrow> \\<forall>y\\<in>#bs_to_mset h.\n                            snd (bs_findMin h) \\<le> snd y\n 4. \\<And>b.\n       \\<lbrakk>bs_invar h; h \\<noteq> bs_empty; h = Inr b\\<rbrakk>\n       \\<Longrightarrow> \\<forall>y\\<in>#bs_to_mset h.\n                            snd (bs_findMin h) \\<le> snd y", "apply (auto simp add: bs_empty_def findMin_correct')"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "theorem bs_insert_correct:\n  assumes I: \"bs_invar h\"\n  shows \n  \"bs_invar (bs_insert e a h)\"\n  \"bs_to_mset (bs_insert e a h) = {#(e,a)#} + bs_to_mset h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bs_invar (bs_insert e a h) &&&\n    bs_to_mset (bs_insert e a h) = {#(e, a)#} + bs_to_mset h", "using I"], ["proof (prove)\nusing this:\n  bs_invar h\n\ngoal (1 subgoal):\n 1. bs_invar (bs_insert e a h) &&&\n    bs_to_mset (bs_insert e a h) = {#(e, a)#} + bs_to_mset h", "apply (case_tac [!] h)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>aa.\n       \\<lbrakk>bs_invar h; h = Inl aa\\<rbrakk>\n       \\<Longrightarrow> bs_invar (bs_insert e a h)\n 2. \\<And>b.\n       \\<lbrakk>bs_invar h; h = Inr b\\<rbrakk>\n       \\<Longrightarrow> bs_invar (bs_insert e a h)\n 3. \\<And>aa.\n       \\<lbrakk>bs_invar h; h = Inl aa\\<rbrakk>\n       \\<Longrightarrow> bs_to_mset (bs_insert e a h) =\n                         {#(e, a)#} + bs_to_mset h\n 4. \\<And>b.\n       \\<lbrakk>bs_invar h; h = Inr b\\<rbrakk>\n       \\<Longrightarrow> bs_to_mset (bs_insert e a h) =\n                         {#(e, a)#} + bs_to_mset h", "apply (simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>b.\n       \\<lbrakk>elem_invar b; h = Inr b\\<rbrakk>\n       \\<Longrightarrow> elem_invar (meld' (Element e a []) b)\n 2. \\<And>b.\n       \\<lbrakk>elem_invar b; h = Inr b\\<rbrakk>\n       \\<Longrightarrow> elem_to_mset (meld' (Element e a []) b) =\n                         add_mset (e, a) (elem_to_mset b)", "apply (auto simp add: meld_correct')"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "theorem bs_meld_correct:\n  assumes I: \"bs_invar h\" \"bs_invar h'\"\n  shows \n  \"bs_invar (bs_meld h h')\"\n  \"bs_to_mset (bs_meld h h') = bs_to_mset h + bs_to_mset h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bs_invar (bs_meld h h') &&&\n    bs_to_mset (bs_meld h h') = bs_to_mset h + bs_to_mset h'", "using I"], ["proof (prove)\nusing this:\n  bs_invar h\n  bs_invar h'\n\ngoal (1 subgoal):\n 1. bs_invar (bs_meld h h') &&&\n    bs_to_mset (bs_meld h h') = bs_to_mset h + bs_to_mset h'", "apply (case_tac [!] h, case_tac [!] h')"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>a aa.\n       \\<lbrakk>bs_invar h; bs_invar h'; h = Inl a; bs_invar h; bs_invar h';\n        h' = Inl aa\\<rbrakk>\n       \\<Longrightarrow> bs_invar (bs_meld h h')\n 2. \\<And>a b.\n       \\<lbrakk>bs_invar h; bs_invar h'; h = Inl a; bs_invar h; bs_invar h';\n        h' = Inr b\\<rbrakk>\n       \\<Longrightarrow> bs_invar (bs_meld h h')\n 3. \\<And>b a.\n       \\<lbrakk>bs_invar h; bs_invar h'; h = Inr b; bs_invar h; bs_invar h';\n        h' = Inl a\\<rbrakk>\n       \\<Longrightarrow> bs_invar (bs_meld h h')\n 4. \\<And>b ba.\n       \\<lbrakk>bs_invar h; bs_invar h'; h = Inr b; bs_invar h; bs_invar h';\n        h' = Inr ba\\<rbrakk>\n       \\<Longrightarrow> bs_invar (bs_meld h h')\n 5. \\<And>a aa.\n       \\<lbrakk>bs_invar h; bs_invar h'; h = Inl a; bs_invar h; bs_invar h';\n        h' = Inl aa\\<rbrakk>\n       \\<Longrightarrow> bs_to_mset (bs_meld h h') =\n                         bs_to_mset h + bs_to_mset h'\n 6. \\<And>a b.\n       \\<lbrakk>bs_invar h; bs_invar h'; h = Inl a; bs_invar h; bs_invar h';\n        h' = Inr b\\<rbrakk>\n       \\<Longrightarrow> bs_to_mset (bs_meld h h') =\n                         bs_to_mset h + bs_to_mset h'\n 7. \\<And>b a.\n       \\<lbrakk>bs_invar h; bs_invar h'; h = Inr b; bs_invar h; bs_invar h';\n        h' = Inl a\\<rbrakk>\n       \\<Longrightarrow> bs_to_mset (bs_meld h h') =\n                         bs_to_mset h + bs_to_mset h'\n 8. \\<And>b ba.\n       \\<lbrakk>bs_invar h; bs_invar h'; h = Inr b; bs_invar h; bs_invar h';\n        h' = Inr ba\\<rbrakk>\n       \\<Longrightarrow> bs_to_mset (bs_meld h h') =\n                         bs_to_mset h + bs_to_mset h'", "apply (auto simp add: meld_correct')"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "theorem bs_deleteMin_correct:\n  assumes I: \"bs_invar h\"\n  assumes NE: \"h \\<noteq> bs_empty\"\n  shows \n  \"bs_invar (bs_deleteMin h)\"\n  \"bs_to_mset (bs_deleteMin h) = bs_to_mset h - {#bs_findMin h#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bs_invar (bs_deleteMin h) &&&\n    bs_to_mset (bs_deleteMin h) = bs_to_mset h - {#bs_findMin h#}", "using I NE"], ["proof (prove)\nusing this:\n  bs_invar h\n  h \\<noteq> bs_empty\n\ngoal (1 subgoal):\n 1. bs_invar (bs_deleteMin h) &&&\n    bs_to_mset (bs_deleteMin h) = bs_to_mset h - {#bs_findMin h#}", "apply (case_tac [!] h)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>bs_invar h; h \\<noteq> bs_empty; h = Inl a\\<rbrakk>\n       \\<Longrightarrow> bs_invar (bs_deleteMin h)\n 2. \\<And>b.\n       \\<lbrakk>bs_invar h; h \\<noteq> bs_empty; h = Inr b\\<rbrakk>\n       \\<Longrightarrow> bs_invar (bs_deleteMin h)\n 3. \\<And>a.\n       \\<lbrakk>bs_invar h; h \\<noteq> bs_empty; h = Inl a\\<rbrakk>\n       \\<Longrightarrow> bs_to_mset (bs_deleteMin h) =\n                         bs_to_mset h - {#bs_findMin h#}\n 4. \\<And>b.\n       \\<lbrakk>bs_invar h; h \\<noteq> bs_empty; h = Inr b\\<rbrakk>\n       \\<Longrightarrow> bs_to_mset (bs_deleteMin h) =\n                         bs_to_mset h - {#bs_findMin h#}", "apply (simp_all add: bs_empty_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>b.\n       \\<lbrakk>elem_invar b; h = Inr b\\<rbrakk>\n       \\<Longrightarrow> bs_invar (bs_deleteMin (Inr b))\n 2. \\<And>b.\n       \\<lbrakk>elem_invar b; h = Inr b\\<rbrakk>\n       \\<Longrightarrow> bs_to_mset (bs_deleteMin (Inr b)) =\n                         elem_to_mset b - {#findMin' b#}", "apply (case_tac [!] b)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>b x1 x2 x3.\n       \\<lbrakk>elem_invar b; h = Inr b; b = Element x1 x2 x3\\<rbrakk>\n       \\<Longrightarrow> bs_invar (bs_deleteMin (Inr b))\n 2. \\<And>b x1 x2 x3.\n       \\<lbrakk>elem_invar b; h = Inr b; b = Element x1 x2 x3\\<rbrakk>\n       \\<Longrightarrow> bs_to_mset (bs_deleteMin (Inr b)) =\n                         elem_to_mset b - {#findMin' b#}", "apply (rename_tac [!] list)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>b x1 x2 list.\n       \\<lbrakk>elem_invar b; h = Inr b; b = Element x1 x2 list\\<rbrakk>\n       \\<Longrightarrow> bs_invar (bs_deleteMin (Inr b))\n 2. \\<And>b x1 x2 list.\n       \\<lbrakk>elem_invar b; h = Inr b; b = Element x1 x2 list\\<rbrakk>\n       \\<Longrightarrow> bs_to_mset (bs_deleteMin (Inr b)) =\n                         elem_to_mset b - {#findMin' b#}", "apply (case_tac [!] list)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>b x1 x2 list.\n       \\<lbrakk>elem_invar b; h = Inr b; b = Element x1 x2 list;\n        list = []\\<rbrakk>\n       \\<Longrightarrow> bs_invar (bs_deleteMin (Inr b))\n 2. \\<And>b x1 x2 list a lista.\n       \\<lbrakk>elem_invar b; h = Inr b; b = Element x1 x2 list;\n        list = a # lista\\<rbrakk>\n       \\<Longrightarrow> bs_invar (bs_deleteMin (Inr b))\n 3. \\<And>b x1 x2 list.\n       \\<lbrakk>elem_invar b; h = Inr b; b = Element x1 x2 list;\n        list = []\\<rbrakk>\n       \\<Longrightarrow> bs_to_mset (bs_deleteMin (Inr b)) =\n                         elem_to_mset b - {#findMin' b#}\n 4. \\<And>b x1 x2 list a lista.\n       \\<lbrakk>elem_invar b; h = Inr b; b = Element x1 x2 list;\n        list = a # lista\\<rbrakk>\n       \\<Longrightarrow> bs_to_mset (bs_deleteMin (Inr b)) =\n                         elem_to_mset b - {#findMin' b#}", "apply (simp_all del: elem_invar.simps deleteMin'.simps add: deleteMin_correct')"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "interpretation BsSkewBinomialHeapStruc: Bootstrapped"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "subsection \"Hiding the Invariant\""], ["", "subsubsection \"Datatype\""], ["", "typedef (overloaded) ('e, 'a) SkewBinomialHeap =\n  \"{q :: ('e,'a::linorder) BsSkewBinomialHeapStruc.BsSkewHeap. BsSkewBinomialHeapStruc.bs_invar q }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> {q. BsSkewBinomialHeapStruc.bs_invar q}", "apply (rule_tac x=\"BsSkewBinomialHeapStruc.bs_empty\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. BsSkewBinomialHeapStruc.bs_empty\n    \\<in> {q. BsSkewBinomialHeapStruc.bs_invar q}", "apply (auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma Rep_SkewBinomialHeap_invar[simp]: \n  \"BsSkewBinomialHeapStruc.bs_invar (Rep_SkewBinomialHeap x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. BsSkewBinomialHeapStruc.bs_invar (Rep_SkewBinomialHeap x)", "using Rep_SkewBinomialHeap"], ["proof (prove)\nusing this:\n  Rep_SkewBinomialHeap ?x \\<in> {q. BsSkewBinomialHeapStruc.bs_invar q}\n\ngoal (1 subgoal):\n 1. BsSkewBinomialHeapStruc.bs_invar (Rep_SkewBinomialHeap x)", "by (auto)"], ["", "lemma [simp]: \n  \"BsSkewBinomialHeapStruc.bs_invar q \n  \\<Longrightarrow> Rep_SkewBinomialHeap (Abs_SkewBinomialHeap q) = q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. BsSkewBinomialHeapStruc.bs_invar q \\<Longrightarrow>\n    Rep_SkewBinomialHeap (Abs_SkewBinomialHeap q) = q", "using Abs_SkewBinomialHeap_inverse"], ["proof (prove)\nusing this:\n  ?y \\<in> {q. BsSkewBinomialHeapStruc.bs_invar q} \\<Longrightarrow>\n  Rep_SkewBinomialHeap (Abs_SkewBinomialHeap ?y) = ?y\n\ngoal (1 subgoal):\n 1. BsSkewBinomialHeapStruc.bs_invar q \\<Longrightarrow>\n    Rep_SkewBinomialHeap (Abs_SkewBinomialHeap q) = q", "by auto"], ["", "lemma [simp, code abstype]: \"Abs_SkewBinomialHeap (Rep_SkewBinomialHeap q) = q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_SkewBinomialHeap (Rep_SkewBinomialHeap q) = q", "by (rule Rep_SkewBinomialHeap_inverse)"], ["", "locale SkewBinomialHeap_loc\nbegin"], ["", "subsubsection \"Operations\""], ["", "definition [code]: \n    \"to_mset t \n    == BsSkewBinomialHeapStruc.bs_to_mset (Rep_SkewBinomialHeap t)\""], ["", "definition empty where \n    \"empty == Abs_SkewBinomialHeap BsSkewBinomialHeapStruc.bs_empty\""], ["", "lemma [code abstract, simp]: \n    \"Rep_SkewBinomialHeap empty = BsSkewBinomialHeapStruc.bs_empty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_SkewBinomialHeap local.empty = BsSkewBinomialHeapStruc.bs_empty", "by (unfold empty_def) simp"], ["", "definition [code]: \n    \"isEmpty q == Rep_SkewBinomialHeap q = BsSkewBinomialHeapStruc.bs_empty\""], ["", "lemma empty_rep: \n    \"q=empty \\<longleftrightarrow> Rep_SkewBinomialHeap q = BsSkewBinomialHeapStruc.bs_empty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (q = local.empty) =\n    (Rep_SkewBinomialHeap q = BsSkewBinomialHeapStruc.bs_empty)", "apply (auto simp add: empty_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_SkewBinomialHeap q =\n    BsSkewBinomialHeapStruc.bs_empty \\<Longrightarrow>\n    q = Abs_SkewBinomialHeap BsSkewBinomialHeapStruc.bs_empty", "apply (metis Rep_SkewBinomialHeap_inverse)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma isEmpty_correct: \"isEmpty q \\<longleftrightarrow> q=empty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isEmpty q = (q = local.empty)", "by (simp add: empty_rep isEmpty_def)"], ["", "definition \n    insert \n    :: \"'e  \\<Rightarrow> ('a::linorder) \\<Rightarrow> ('e,'a) SkewBinomialHeap \n        \\<Rightarrow> ('e,'a) SkewBinomialHeap\"\n    where \"insert e a q == \n            Abs_SkewBinomialHeap (\n              BsSkewBinomialHeapStruc.bs_insert e a (Rep_SkewBinomialHeap q))\""], ["", "lemma [code abstract]: \n    \"Rep_SkewBinomialHeap (insert e a q) \n    = BsSkewBinomialHeapStruc.bs_insert e a (Rep_SkewBinomialHeap q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_SkewBinomialHeap (local.insert e a q) =\n    BsSkewBinomialHeapStruc.bs_insert e a (Rep_SkewBinomialHeap q)", "by (simp add: insert_def BsSkewBinomialHeapStruc.bs_insert_correct)"], ["", "definition [code]: \"findMin q \n    == BsSkewBinomialHeapStruc.bs_findMin (Rep_SkewBinomialHeap q)\""], ["", "definition \"deleteMin q == \n    if q=empty then empty \n    else Abs_SkewBinomialHeap (\n            BsSkewBinomialHeapStruc.bs_deleteMin (Rep_SkewBinomialHeap q))\""], ["", "text \\<open>\n    We don't use equality here, to prevent the code-generator\n    from introducing equality-class parameter for type \\<open>'a\\<close>.\n    Instead we use a case-distinction to check for emptiness.\n\\<close>"], ["", "lemma [code abstract]: \"Rep_SkewBinomialHeap (deleteMin q) =\n    (case (Rep_SkewBinomialHeap q) of Inl _ \\<Rightarrow> BsSkewBinomialHeapStruc.bs_empty |\n     _ \\<Rightarrow> BsSkewBinomialHeapStruc.bs_deleteMin (Rep_SkewBinomialHeap q))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_SkewBinomialHeap (deleteMin q) =\n    (case Rep_SkewBinomialHeap q of\n     Inl x \\<Rightarrow> BsSkewBinomialHeapStruc.bs_empty\n     | Inr b \\<Rightarrow>\n         BsSkewBinomialHeapStruc.bs_deleteMin (Rep_SkewBinomialHeap q))", "proof (cases \"(Rep_SkewBinomialHeap q)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a.\n       Rep_SkewBinomialHeap q = Inl a \\<Longrightarrow>\n       Rep_SkewBinomialHeap (deleteMin q) =\n       (case Rep_SkewBinomialHeap q of\n        Inl x \\<Rightarrow> BsSkewBinomialHeapStruc.bs_empty\n        | Inr b \\<Rightarrow>\n            BsSkewBinomialHeapStruc.bs_deleteMin (Rep_SkewBinomialHeap q))\n 2. \\<And>b.\n       Rep_SkewBinomialHeap q = Inr b \\<Longrightarrow>\n       Rep_SkewBinomialHeap (deleteMin q) =\n       (case Rep_SkewBinomialHeap q of\n        Inl x \\<Rightarrow> BsSkewBinomialHeapStruc.bs_empty\n        | Inr b \\<Rightarrow>\n            BsSkewBinomialHeapStruc.bs_deleteMin (Rep_SkewBinomialHeap q))", "case [simp]: (Inl a)"], ["proof (state)\nthis:\n  Rep_SkewBinomialHeap q = Inl a\n\ngoal (2 subgoals):\n 1. \\<And>a.\n       Rep_SkewBinomialHeap q = Inl a \\<Longrightarrow>\n       Rep_SkewBinomialHeap (deleteMin q) =\n       (case Rep_SkewBinomialHeap q of\n        Inl x \\<Rightarrow> BsSkewBinomialHeapStruc.bs_empty\n        | Inr b \\<Rightarrow>\n            BsSkewBinomialHeapStruc.bs_deleteMin (Rep_SkewBinomialHeap q))\n 2. \\<And>b.\n       Rep_SkewBinomialHeap q = Inr b \\<Longrightarrow>\n       Rep_SkewBinomialHeap (deleteMin q) =\n       (case Rep_SkewBinomialHeap q of\n        Inl x \\<Rightarrow> BsSkewBinomialHeapStruc.bs_empty\n        | Inr b \\<Rightarrow>\n            BsSkewBinomialHeapStruc.bs_deleteMin (Rep_SkewBinomialHeap q))", "hence \"(Rep_SkewBinomialHeap q) = BsSkewBinomialHeapStruc.bs_empty\""], ["proof (prove)\nusing this:\n  Rep_SkewBinomialHeap q = Inl a\n\ngoal (1 subgoal):\n 1. Rep_SkewBinomialHeap q = BsSkewBinomialHeapStruc.bs_empty", "apply (cases q)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>Rep_SkewBinomialHeap q = Inl a; q = Abs_SkewBinomialHeap y;\n        y \\<in> {q. BsSkewBinomialHeapStruc.bs_invar q}\\<rbrakk>\n       \\<Longrightarrow> Rep_SkewBinomialHeap q =\n                         BsSkewBinomialHeapStruc.bs_empty", "apply (auto simp add: BsSkewBinomialHeapStruc.bs_empty_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  Rep_SkewBinomialHeap q = BsSkewBinomialHeapStruc.bs_empty\n\ngoal (2 subgoals):\n 1. \\<And>a.\n       Rep_SkewBinomialHeap q = Inl a \\<Longrightarrow>\n       Rep_SkewBinomialHeap (deleteMin q) =\n       (case Rep_SkewBinomialHeap q of\n        Inl x \\<Rightarrow> BsSkewBinomialHeapStruc.bs_empty\n        | Inr b \\<Rightarrow>\n            BsSkewBinomialHeapStruc.bs_deleteMin (Rep_SkewBinomialHeap q))\n 2. \\<And>b.\n       Rep_SkewBinomialHeap q = Inr b \\<Longrightarrow>\n       Rep_SkewBinomialHeap (deleteMin q) =\n       (case Rep_SkewBinomialHeap q of\n        Inl x \\<Rightarrow> BsSkewBinomialHeapStruc.bs_empty\n        | Inr b \\<Rightarrow>\n            BsSkewBinomialHeapStruc.bs_deleteMin (Rep_SkewBinomialHeap q))", "thus ?thesis"], ["proof (prove)\nusing this:\n  Rep_SkewBinomialHeap q = BsSkewBinomialHeapStruc.bs_empty\n\ngoal (1 subgoal):\n 1. Rep_SkewBinomialHeap (deleteMin q) =\n    (case Rep_SkewBinomialHeap q of\n     Inl x \\<Rightarrow> BsSkewBinomialHeapStruc.bs_empty\n     | Inr b \\<Rightarrow>\n         BsSkewBinomialHeapStruc.bs_deleteMin (Rep_SkewBinomialHeap q))", "apply (auto simp add: deleteMin_def \n        BsSkewBinomialHeapStruc.bs_deleteMin_correct \n        BsSkewBinomialHeapStruc.bs_empty_correct empty_rep )"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  Rep_SkewBinomialHeap (deleteMin q) =\n  (case Rep_SkewBinomialHeap q of\n   Inl x \\<Rightarrow> BsSkewBinomialHeapStruc.bs_empty\n   | Inr b \\<Rightarrow>\n       BsSkewBinomialHeapStruc.bs_deleteMin (Rep_SkewBinomialHeap q))\n\ngoal (1 subgoal):\n 1. \\<And>b.\n       Rep_SkewBinomialHeap q = Inr b \\<Longrightarrow>\n       Rep_SkewBinomialHeap (deleteMin q) =\n       (case Rep_SkewBinomialHeap q of\n        Inl x \\<Rightarrow> BsSkewBinomialHeapStruc.bs_empty\n        | Inr b \\<Rightarrow>\n            BsSkewBinomialHeapStruc.bs_deleteMin (Rep_SkewBinomialHeap q))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>b.\n       Rep_SkewBinomialHeap q = Inr b \\<Longrightarrow>\n       Rep_SkewBinomialHeap (deleteMin q) =\n       (case Rep_SkewBinomialHeap q of\n        Inl x \\<Rightarrow> BsSkewBinomialHeapStruc.bs_empty\n        | Inr b \\<Rightarrow>\n            BsSkewBinomialHeapStruc.bs_deleteMin (Rep_SkewBinomialHeap q))", "case (Inr x)"], ["proof (state)\nthis:\n  Rep_SkewBinomialHeap q = Inr x\n\ngoal (1 subgoal):\n 1. \\<And>b.\n       Rep_SkewBinomialHeap q = Inr b \\<Longrightarrow>\n       Rep_SkewBinomialHeap (deleteMin q) =\n       (case Rep_SkewBinomialHeap q of\n        Inl x \\<Rightarrow> BsSkewBinomialHeapStruc.bs_empty\n        | Inr b \\<Rightarrow>\n            BsSkewBinomialHeapStruc.bs_deleteMin (Rep_SkewBinomialHeap q))", "hence \"(Rep_SkewBinomialHeap q) \\<noteq> BsSkewBinomialHeapStruc.bs_empty\""], ["proof (prove)\nusing this:\n  Rep_SkewBinomialHeap q = Inr x\n\ngoal (1 subgoal):\n 1. Rep_SkewBinomialHeap q \\<noteq> BsSkewBinomialHeapStruc.bs_empty", "apply (cases q)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>Rep_SkewBinomialHeap q = Inr x; q = Abs_SkewBinomialHeap y;\n        y \\<in> {q. BsSkewBinomialHeapStruc.bs_invar q}\\<rbrakk>\n       \\<Longrightarrow> Rep_SkewBinomialHeap q \\<noteq>\n                         BsSkewBinomialHeapStruc.bs_empty", "apply (auto simp add: BsSkewBinomialHeapStruc.bs_empty_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  Rep_SkewBinomialHeap q \\<noteq> BsSkewBinomialHeapStruc.bs_empty\n\ngoal (1 subgoal):\n 1. \\<And>b.\n       Rep_SkewBinomialHeap q = Inr b \\<Longrightarrow>\n       Rep_SkewBinomialHeap (deleteMin q) =\n       (case Rep_SkewBinomialHeap q of\n        Inl x \\<Rightarrow> BsSkewBinomialHeapStruc.bs_empty\n        | Inr b \\<Rightarrow>\n            BsSkewBinomialHeapStruc.bs_deleteMin (Rep_SkewBinomialHeap q))", "thus ?thesis"], ["proof (prove)\nusing this:\n  Rep_SkewBinomialHeap q \\<noteq> BsSkewBinomialHeapStruc.bs_empty\n\ngoal (1 subgoal):\n 1. Rep_SkewBinomialHeap (deleteMin q) =\n    (case Rep_SkewBinomialHeap q of\n     Inl x \\<Rightarrow> BsSkewBinomialHeapStruc.bs_empty\n     | Inr b \\<Rightarrow>\n         BsSkewBinomialHeapStruc.bs_deleteMin (Rep_SkewBinomialHeap q))", "apply (simp add: Inr)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Inr x \\<noteq> BsSkewBinomialHeapStruc.bs_empty \\<Longrightarrow>\n    Rep_SkewBinomialHeap (deleteMin q) =\n    BsSkewBinomialHeapStruc.bs_deleteMin (Inr x)", "apply (fold Inr)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_SkewBinomialHeap q \\<noteq>\n    BsSkewBinomialHeapStruc.bs_empty \\<Longrightarrow>\n    Rep_SkewBinomialHeap (deleteMin q) =\n    BsSkewBinomialHeapStruc.bs_deleteMin (Rep_SkewBinomialHeap q)", "apply (auto simp add: deleteMin_def \n        BsSkewBinomialHeapStruc.bs_deleteMin_correct \n        BsSkewBinomialHeapStruc.bs_empty_correct empty_rep )"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  Rep_SkewBinomialHeap (deleteMin q) =\n  (case Rep_SkewBinomialHeap q of\n   Inl x \\<Rightarrow> BsSkewBinomialHeapStruc.bs_empty\n   | Inr b \\<Rightarrow>\n       BsSkewBinomialHeapStruc.bs_deleteMin (Rep_SkewBinomialHeap q))\n\ngoal:\nNo subgoals!", "qed"], ["", "(*\n  lemma [code abstract]: \"Rep_SkewBinomialHeap (deleteMin q) =\n    (if (Rep_SkewBinomialHeap q = BsSkewBinomialHeapStruc.bs_empty) then BsSkewBinomialHeapStruc.bs_empty \n     else BsSkewBinomialHeapStruc.bs_deleteMin (Rep_SkewBinomialHeap q))\"\n    by (auto simp add: deleteMin_def BsSkewBinomialHeapStruc.bs_deleteMin_correct \n      BsSkewBinomialHeapStruc.bs_empty_correct empty_rep)\n*)"], ["", "definition \"meld q1 q2 == \n    Abs_SkewBinomialHeap (BsSkewBinomialHeapStruc.bs_meld \n    (Rep_SkewBinomialHeap q1) (Rep_SkewBinomialHeap q2))\""], ["", "lemma [code abstract]:\n    \"Rep_SkewBinomialHeap (meld q1 q2) \n    = BsSkewBinomialHeapStruc.bs_meld (Rep_SkewBinomialHeap q1) \n                                 (Rep_SkewBinomialHeap q2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_SkewBinomialHeap (meld q1 q2) =\n    BsSkewBinomialHeapStruc.bs_meld (Rep_SkewBinomialHeap q1)\n     (Rep_SkewBinomialHeap q2)", "by (simp add: meld_def BsSkewBinomialHeapStruc.bs_meld_correct)"], ["", "subsubsection \"Correctness\""], ["", "lemma empty_correct: \"to_mset q = {#} \\<longleftrightarrow> q=empty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (to_mset q = {#}) = (q = local.empty)", "by (simp add: to_mset_def BsSkewBinomialHeapStruc.bs_empty_correct empty_rep)"], ["", "lemma to_mset_of_empty[simp]: \"to_mset empty = {#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. to_mset local.empty = {#}", "by (simp add: empty_correct)"], ["", "lemma insert_correct: \"to_mset (insert e a q) =  to_mset q + {#(e,a)#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. to_mset (local.insert e a q) = to_mset q + {#(e, a)#}", "apply (unfold insert_def to_mset_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. BsSkewBinomialHeapStruc.bs_to_mset\n     (Rep_SkewBinomialHeap\n       (Abs_SkewBinomialHeap\n         (BsSkewBinomialHeapStruc.bs_insert e a\n           (Rep_SkewBinomialHeap q)))) =\n    BsSkewBinomialHeapStruc.bs_to_mset (Rep_SkewBinomialHeap q) + {#(e, a)#}", "apply (simp add: BsSkewBinomialHeapStruc.bs_insert_correct union_ac)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma findMin_correct: \n    assumes \"q\\<noteq>empty\"\n    shows \n    \"findMin q \\<in># to_mset q\"\n    \"\\<forall>y\\<in>set_mset (to_mset q). snd (findMin q) \\<le> snd y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. findMin q \\<in># to_mset q &&&\n    \\<forall>y\\<in>#to_mset q. snd (findMin q) \\<le> snd y", "using assms"], ["proof (prove)\nusing this:\n  q \\<noteq> local.empty\n\ngoal (1 subgoal):\n 1. findMin q \\<in># to_mset q &&&\n    \\<forall>y\\<in>#to_mset q. snd (findMin q) \\<le> snd y", "apply (unfold findMin_def to_mset_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. q \\<noteq> local.empty \\<Longrightarrow>\n    BsSkewBinomialHeapStruc.bs_findMin (Rep_SkewBinomialHeap q)\n    \\<in># BsSkewBinomialHeapStruc.bs_to_mset (Rep_SkewBinomialHeap q)\n 2. q \\<noteq> local.empty \\<Longrightarrow>\n    \\<forall>y\\<in>#BsSkewBinomialHeapStruc.bs_to_mset\n                     (Rep_SkewBinomialHeap q).\n       snd (BsSkewBinomialHeapStruc.bs_findMin (Rep_SkewBinomialHeap q))\n       \\<le> snd y", "apply (simp_all add: empty_rep BsSkewBinomialHeapStruc.bs_findMin_correct)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma deleteMin_correct:\n    assumes \"q\\<noteq>empty\"\n    shows \"to_mset (deleteMin q) = to_mset q - {# findMin q #}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. to_mset (deleteMin q) = to_mset q - {#findMin q#}", "using assms"], ["proof (prove)\nusing this:\n  q \\<noteq> local.empty\n\ngoal (1 subgoal):\n 1. to_mset (deleteMin q) = to_mset q - {#findMin q#}", "apply (unfold findMin_def deleteMin_def to_mset_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. q \\<noteq> local.empty \\<Longrightarrow>\n    BsSkewBinomialHeapStruc.bs_to_mset\n     (Rep_SkewBinomialHeap\n       (if q = local.empty then local.empty\n        else Abs_SkewBinomialHeap\n              (BsSkewBinomialHeapStruc.bs_deleteMin\n                (Rep_SkewBinomialHeap q)))) =\n    BsSkewBinomialHeapStruc.bs_to_mset (Rep_SkewBinomialHeap q) -\n    {#BsSkewBinomialHeapStruc.bs_findMin (Rep_SkewBinomialHeap q)#}", "apply (simp_all add: empty_rep BsSkewBinomialHeapStruc.bs_deleteMin_correct)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma meld_correct:\n    shows \"to_mset (meld q q') = to_mset q + to_mset q'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. to_mset (meld q q') = to_mset q + to_mset q'", "apply (unfold to_mset_def meld_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. BsSkewBinomialHeapStruc.bs_to_mset\n     (Rep_SkewBinomialHeap\n       (Abs_SkewBinomialHeap\n         (BsSkewBinomialHeapStruc.bs_meld (Rep_SkewBinomialHeap q)\n           (Rep_SkewBinomialHeap q')))) =\n    BsSkewBinomialHeapStruc.bs_to_mset (Rep_SkewBinomialHeap q) +\n    BsSkewBinomialHeapStruc.bs_to_mset (Rep_SkewBinomialHeap q')", "apply (simp_all add: BsSkewBinomialHeapStruc.bs_meld_correct)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>Correctness lemmas to be used with simplifier\\<close>"], ["", "lemmas correct = empty_correct deleteMin_correct meld_correct"], ["", "end"], ["", "interpretation SkewBinomialHeap: SkewBinomialHeap_loc"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "subsection \"Documentation\""], ["", "(*#DOC\n  fun [no_spec] SkewBinomialHeap.to_mset\n    Abstraction to multiset.\n\n  fun SkewBinomialHeap.empty\n    The empty heap. ($O(1)$)\n\n  fun SkewBinomialHeap.isEmpty\n    Checks whether heap is empty. Mainly used to work around \n    code-generation issues. ($O(1)$)\n\n  fun [long_type] SkewBinomialHeap.insert\n    Inserts element ($O(1)$)\n\n  fun SkewBinomialHeap.findMin\n    Returns a minimal element ($O(1)$)\n\n  fun [long_type] SkewBinomialHeap.deleteMin\n    Deletes {\\em the} element that is returned by {\\em find\\_min}. $O(\\log(n))$\n\n  fun [long_type] SkewBinomialHeap.meld\n    Melds two heaps ($O(1)$)\n\n*)"], ["", "text \\<open>\n   \\underline{@{term_type \"SkewBinomialHeap.to_mset\"}}\\\\\n        Abstraction to multiset.\\\\\n\n\n    \\underline{@{term_type \"SkewBinomialHeap.empty\"}}\\\\\n        The empty heap. ($O(1)$)\\\\\n    {\\bf Spec} \\<open>SkewBinomialHeap.empty_correct\\<close>:\n    @{thm [display] SkewBinomialHeap.empty_correct[no_vars]}\n\n\n    \\underline{@{term_type \"SkewBinomialHeap.isEmpty\"}}\\\\\n        Checks whether heap is empty. Mainly used to work around\n    code-generation issues. ($O(1)$)\\\\\n    {\\bf Spec} \\<open>SkewBinomialHeap.isEmpty_correct\\<close>:\n    @{thm [display] SkewBinomialHeap.isEmpty_correct[no_vars]}\n\n\n    \\underline{@{term \"SkewBinomialHeap.insert\"}}\n    @{term_type [display] \"SkewBinomialHeap.insert\"}\n        Inserts element ($O(1)$)\\\\\n    {\\bf Spec} \\<open>SkewBinomialHeap.insert_correct\\<close>:\n    @{thm [display] SkewBinomialHeap.insert_correct[no_vars]}\n\n\n    \\underline{@{term_type \"SkewBinomialHeap.findMin\"}}\\\\\n        Returns a minimal element ($O(1)$)\\\\\n    {\\bf Spec} \\<open>SkewBinomialHeap.findMin_correct\\<close>:\n    @{thm [display] SkewBinomialHeap.findMin_correct[no_vars]}\n\n\n    \\underline{@{term \"SkewBinomialHeap.deleteMin\"}}\n    @{term_type [display] \"SkewBinomialHeap.deleteMin\"}\n        Deletes {\\em the} element that is returned by {\\em find\\_min}. $O(\\log(n))$\\\\\n    {\\bf Spec} \\<open>SkewBinomialHeap.deleteMin_correct\\<close>:\n    @{thm [display] SkewBinomialHeap.deleteMin_correct[no_vars]}\n\n\n    \\underline{@{term \"SkewBinomialHeap.meld\"}}\n    @{term_type [display] \"SkewBinomialHeap.meld\"}\n        Melds two heaps ($O(1)$)\\\\\n    {\\bf Spec} \\<open>SkewBinomialHeap.meld_correct\\<close>:\n    @{thm [display] SkewBinomialHeap.meld_correct[no_vars]}\n\n\\<close>"], ["", "end"]]}