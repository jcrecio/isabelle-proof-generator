{"file_name": "/home/qj213/afp-2021-10-22/thys/Binomial-Heaps/BinomialHeap.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Binomial-Heaps", "problem_names": ["lemma qtmset_append_union[simp]: \"queue_to_multiset (q @ q') = \n  queue_to_multiset q + queue_to_multiset q'\"", "lemma qtmset_rev[simp]: \"queue_to_multiset (rev q) = queue_to_multiset q\"", "lemma queue_invar_simps[simp]:\n  \"queue_invar []\"\n  \"queue_invar (t#q) \\<longleftrightarrow> tree_invar t \\<and> queue_invar q\"\n  \"queue_invar (q@q') \\<longleftrightarrow> queue_invar q \\<and> queue_invar q'\"", "lemma mset_link[simp]: \"(tree_to_multiset (link t1 t2)) \n  = (tree_to_multiset t1) + (tree_to_multiset t2)\"", "lemma link_tree_invar: \n  \"\\<lbrakk>tree_invar t1; tree_invar t2; rank t1 = rank t2\\<rbrakk> \\<Longrightarrow> tree_invar (link t1 t2)\"", "lemma invar_children: \n  assumes \"tree_invar ((Node e a r ts)::(('e, 'a::linorder) BinomialTree))\" \n  shows \"queue_invar ts\"", "lemma invar_children': \"tree_invar t \\<Longrightarrow> queue_invar (children t)\"", "lemma rank_link: \"rank t = rank t' \\<Longrightarrow> rank (link t t') = rank t + 1\"", "lemma rank_invar_not_empty_hd: \"\\<lbrakk>rank_invar (t # bq); bq \\<noteq> []\\<rbrakk> \\<Longrightarrow> \n  rank t < rank (hd bq)\"", "lemma rank_invar_to_set: \"rank_invar (t # bq) \\<Longrightarrow> \n  \\<forall> t' \\<in> set bq. rank t < rank t'\"", "lemma set_to_rank_invar: \"\\<lbrakk>\\<forall> t' \\<in> set bq. rank t < rank t'; rank_invar bq\\<rbrakk> \n  \\<Longrightarrow>  rank_invar (t # bq)\"", "lemma rank_invar_hd_cons: \n  \"\\<lbrakk>rank_invar bq; rank t < rank (hd bq)\\<rbrakk> \\<Longrightarrow> rank_invar (t # bq)\"", "lemma rank_invar_cons: \"rank_invar (t # bq) \\<Longrightarrow> rank_invar bq\"", "lemma invar_cons_up: \n  \"\\<lbrakk>invar (t # bq); rank t' < rank t; tree_invar t'\\<rbrakk> \\<Longrightarrow> invar (t' # t # bq)\"", "lemma invar_cons_down: \"invar (t # bq) \\<Longrightarrow> invar bq\"", "lemma invar_app_single: \n  \"\\<lbrakk>invar bq; \\<forall>t \\<in> set bq. rank t < rank t'; tree_invar t'\\<rbrakk> \n   \\<Longrightarrow> invar (bq @ [t'])\"", "lemma tree_invar_heap_ordered:\n  assumes \"tree_invar t\"\n  shows \"heap_ordered t\"", "lemma link_length: \"size (tree_to_multiset (link t1 t2)) = \n  size (tree_to_multiset t1) + size (tree_to_multiset t2)\"", "lemma tree_rank_estimate:\n  \"tree_invar (Node e a r ts) \\<Longrightarrow> \n    size (tree_to_multiset (Node e a r ts)) = (2::nat)^r\"", "lemma tree_rank_height:\n  \"tree_invar (Node e a r ts) \\<Longrightarrow> height_tree (Node e a r ts) = r\"", "theorem tree_height_estimate:\n  \"tree_invar t \\<Longrightarrow> size (tree_to_multiset t) = (2::nat)^(height_tree t)\"", "lemma size_mset_tree: \"tree_invar t \\<Longrightarrow> \n  size (tree_to_multiset t) = (2::nat)^(rank t)\"", "lemma invar_butlast: \"invar (bq @ [t]) \\<Longrightarrow> invar bq\"", "lemma invar_last_max: \"invar (bq @ [m]) \\<Longrightarrow> \\<forall> t \\<in> set bq. rank t < rank m\"", "lemma invar_length: \"invar bq \\<Longrightarrow> length bq \\<le> Suc (rank (last bq))\"", "lemma size_queue_sum_list: \n  \"size (queue_to_multiset bq) = sum_list (map (size \\<circ> tree_to_multiset) bq)\"", "theorem queue_length_estimate_lower: \n  \"invar bq \\<Longrightarrow> (size (queue_to_multiset bq)) \\<ge> 2^(length bq) - 1\"", "lemma empty_correct[simp]: \n  \"invar Nil\"\n  \"queue_to_multiset Nil = {#}\"", "lemma empty_iff: \"t=Nil \\<longleftrightarrow> queue_to_multiset t = {#}\"", "lemma ins_mset:\n  \"\\<lbrakk>tree_invar t; queue_invar q\\<rbrakk> \\<Longrightarrow> queue_to_multiset (ins t q) \n   = tree_to_multiset t + queue_to_multiset q\"", "lemma insert_mset: \"queue_invar q \\<Longrightarrow>\n  queue_to_multiset (insert e a q) = queue_to_multiset q + {# (e,a) #}\"", "lemma ins_queue_invar: \"\\<lbrakk>tree_invar t; queue_invar q\\<rbrakk> \\<Longrightarrow> queue_invar (ins t q)\"", "lemma insert_queue_invar: \n  assumes \"queue_invar q\" \n  shows \"queue_invar (insert e a q)\"", "lemma  rank_ins: \"(rank_invar (t # bq) \\<Longrightarrow> \n  (rank (hd (ins t' (t # bq))) \\<ge> rank t) \\<or> \n  (rank (hd (ins t' (t # bq))) \\<ge> rank t'))\"", "lemma rank_ins2: \"rank_invar bq \\<Longrightarrow> \n  rank t \\<le> rank (hd (ins t bq)) \\<or> \n  (rank (hd (ins t bq)) = rank (hd bq) \\<and> bq \\<noteq> [])\"", "lemma rank_invar_ins: \"rank_invar bq \\<Longrightarrow> rank_invar (ins t bq)\"", "lemma rank_invar_insert: \"rank_invar bq \\<Longrightarrow> rank_invar (insert e a bq)\"", "lemma insert_correct: \n  assumes I: \"invar q\"\n  shows \n  \"invar (insert e a q)\"\n  \"queue_to_multiset (insert e a q) = queue_to_multiset q + {# (e,a) #}\"", "lemma meld_queue_invar: \n  \"\\<lbrakk>queue_invar q; queue_invar q'\\<rbrakk> \\<Longrightarrow> queue_invar (meld q q')\"", "lemma rank_ins_min: \"rank_invar bq \\<Longrightarrow> \n  rank (hd (ins t bq)) \\<ge> min (rank t) (rank (hd bq))\"", "lemma rank_invar_meld_strong: \n  \"\\<lbrakk>rank_invar bq1; rank_invar bq2\\<rbrakk> \\<Longrightarrow> rank_invar (meld bq1 bq2) \\<and> \n  rank (hd (meld bq1 bq2)) \\<ge> min (rank (hd bq1)) (rank (hd bq2))\"", "lemma rank_invar_meld: \n  \"\\<lbrakk>rank_invar bq1; rank_invar bq2\\<rbrakk> \\<Longrightarrow> rank_invar (meld bq1 bq2)\"", "lemma meld_mset: \"\\<lbrakk>queue_invar q; queue_invar q'\\<rbrakk> \\<Longrightarrow> \n  queue_to_multiset (meld q q') = \n  queue_to_multiset q + queue_to_multiset q'\"", "lemma meld_correct:\n  assumes \"invar q\" \"invar q'\" \n  shows \n  \"invar (meld q q')\"\n  \"queue_to_multiset (meld q q') = queue_to_multiset q + queue_to_multiset q'\"", "lemma mintree_exists: \"(bq \\<noteq> []) = (getMinTree bq \\<in> set bq)\"", "lemma treehead_in_multiset: \n  \"t \\<in> set bq \\<Longrightarrow> (val t, prio t) \\<in># queue_to_multiset bq\"", "lemma heap_ordered_single: \n\"heap_ordered t = (\\<forall>x \\<in> set_mset (tree_to_multiset t). prio t \\<le> snd x)\"", "lemma getMinTree_cons: \n  \"prio (getMinTree (y # x # xs)) \\<le> prio (getMinTree (x # xs))\"", "lemma getMinTree_min_tree:\n  \"t \\<in> set bq  \\<Longrightarrow> prio (getMinTree bq) \\<le> prio t\"", "lemma getMinTree_min_prio:\n  assumes \"queue_invar bq\"\n    and \"y \\<in> set_mset (queue_to_multiset bq)\"\n  shows \"prio (getMinTree bq) \\<le> snd y\"", "lemma findMin_correct:\n  assumes I: \"invar q\"\n  assumes NE: \"q \\<noteq> Nil\"\n  shows \n  \"findMin q \\<in># queue_to_multiset q\"\n  \"\\<forall>y\\<in>set_mset (queue_to_multiset q). snd (findMin q) \\<le> snd y\"", "lemma queue_invar_rev: \"queue_invar q \\<Longrightarrow> queue_invar (rev q)\"", "lemma queue_invar_remove1: \"queue_invar q \\<Longrightarrow> queue_invar (remove1 t q)\"", "lemma qtm_in_set_subset: \"t \\<in> set q \\<Longrightarrow> \n  tree_to_multiset t \\<subseteq># queue_to_multiset q\"", "lemma remove1_mset: \"t \\<in> set q \\<Longrightarrow> \n  queue_to_multiset (remove1 t q) = \n  queue_to_multiset q - tree_to_multiset t\"", "lemma remove1Prio_remove1[simp]: \n  \"remove1Prio (prio (getMinTree bq)) bq = remove1 (getMinTree bq) bq\"", "lemma deleteMin_queue_invar: \n  assumes INV: \"queue_invar q\" \n  assumes NE: \"q \\<noteq> Nil\"\n  shows \"queue_invar (deleteMin q)\"", "lemma children_rank_less: \n  assumes \"tree_invar t\"\n  shows \"\\<forall>t' \\<in> set (children t). rank t' < rank t\"", "lemma strong_rev_children:\n  assumes \"tree_invar t\"\n  shows \"invar (rev (children t))\"", "lemma first_less: \"rank_invar (t # bq) \\<Longrightarrow> \\<forall>t' \\<in> set bq. rank t < rank t'\"", "lemma strong_remove1: \"invar bq \\<Longrightarrow> invar (remove1 t bq)\"", "theorem deleteMin_invar:\n  assumes \"invar bq\"\n    and \"bq \\<noteq> []\"\n  shows \"invar (deleteMin bq)\"", "lemma children_mset: \"queue_to_multiset (children t) = \n  tree_to_multiset t - {# (val t, prio t) #}\"", "lemma deleteMin_mset:\n  assumes \"queue_invar q\"\n    and \"q \\<noteq> Nil\"\n  shows \"queue_to_multiset (deleteMin q) = queue_to_multiset q - {# (findMin q) #}\"", "lemma deleteMin_correct:\n  assumes INV: \"invar q\" \n  assumes NE: \"q \\<noteq> Nil\"\n  shows \n  \"invar (deleteMin q)\"\n  \"queue_to_multiset (deleteMin q) = queue_to_multiset q - {# (findMin q) #}\"", "lemma Rep_BinomialHeap_invar[simp]: \n  \"BinomialHeapStruc.invar (Rep_BinomialHeap x)\"", "lemma [simp]: \n  \"BinomialHeapStruc.invar q \\<Longrightarrow> Rep_BinomialHeap (Abs_BinomialHeap q) = q\"", "lemma [simp, code abstype]: \"Abs_BinomialHeap (Rep_BinomialHeap q) = q\"", "lemma [code abstract, simp]: \"Rep_BinomialHeap empty = []\"", "lemma empty_rep: \"q=empty \\<longleftrightarrow> Rep_BinomialHeap q = Nil\"", "lemma isEmpty_correct: \"isEmpty q \\<longleftrightarrow> q=empty\"", "lemma [code abstract]: \n    \"Rep_BinomialHeap (insert e a q) \n    = BinomialHeapStruc.insert e a (Rep_BinomialHeap q)\"", "lemma [code abstract]: \"Rep_BinomialHeap (deleteMin q) =\n    (case (Rep_BinomialHeap q) of [] \\<Rightarrow> [] |\n     _ \\<Rightarrow> BinomialHeapStruc.deleteMin (Rep_BinomialHeap q))\"", "lemma [code abstract]:\n    \"Rep_BinomialHeap (meld q1 q2) \n    = BinomialHeapStruc.meld (Rep_BinomialHeap q1) (Rep_BinomialHeap q2)\"", "lemma empty_correct: \"to_mset q = {#} \\<longleftrightarrow> q=empty\"", "lemma to_mset_of_empty[simp]: \"to_mset empty = {#}\"", "lemma insert_correct: \"to_mset (insert e a q) = to_mset q + {#(e,a)#}\"", "lemma findMin_correct: \n    assumes \"q\\<noteq>empty\"\n    shows \n    \"findMin q \\<in># to_mset q\"\n    \"\\<forall>y\\<in>set_mset (to_mset q). snd (findMin q) \\<le> snd y\"", "lemma deleteMin_correct:\n    assumes \"q\\<noteq>empty\"\n    shows \"to_mset (deleteMin q) = to_mset q - {# findMin q #}\"", "lemma meld_correct:\n    shows \"to_mset (meld q q') = to_mset q + to_mset q'\"", "lemmas correct = empty_correct deleteMin_correct meld_correct"], "translations": [["", "lemma qtmset_append_union[simp]: \"queue_to_multiset (q @ q') = \n  queue_to_multiset q + queue_to_multiset q'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. queue_to_multiset (q @ q') = queue_to_multiset q + queue_to_multiset q'", "apply(induct q)"], ["proof (prove)\ngoal (2 subgoals):\n 1. queue_to_multiset ([] @ q') =\n    queue_to_multiset [] + queue_to_multiset q'\n 2. \\<And>a q.\n       queue_to_multiset (q @ q') =\n       queue_to_multiset q + queue_to_multiset q' \\<Longrightarrow>\n       queue_to_multiset ((a # q) @ q') =\n       queue_to_multiset (a # q) + queue_to_multiset q'", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a q.\n       queue_to_multiset (q @ q') =\n       queue_to_multiset q + queue_to_multiset q' \\<Longrightarrow>\n       queue_to_multiset ((a # q) @ q') =\n       queue_to_multiset (a # q) + queue_to_multiset q'", "apply(simp add: union_ac)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma qtmset_rev[simp]: \"queue_to_multiset (rev q) = queue_to_multiset q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. queue_to_multiset (rev q) = queue_to_multiset q", "apply(induct q)"], ["proof (prove)\ngoal (2 subgoals):\n 1. queue_to_multiset (rev []) = queue_to_multiset []\n 2. \\<And>a q.\n       queue_to_multiset (rev q) = queue_to_multiset q \\<Longrightarrow>\n       queue_to_multiset (rev (a # q)) = queue_to_multiset (a # q)", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a q.\n       queue_to_multiset (rev q) = queue_to_multiset q \\<Longrightarrow>\n       queue_to_multiset (rev (a # q)) = queue_to_multiset (a # q)", "apply(simp add: union_ac)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsubsection \"Invariant\""], ["", "text \\<open>We first formulate the invariant for single binomial trees,\n  and then extend the invariant to binomial heaps (lists of binomial trees).\n  The invariant for trees claims that a tree labeled rank $0$ has no children,\n  and a tree labeled rank $r+1$ is the result of a link operation of\n  two rank $r$ trees.\n\\<close>"], ["", "function tree_invar :: \"('e, 'a::linorder) BinomialTree \\<Rightarrow> bool\" where\n  \"tree_invar (Node e a 0 ts) = (ts = [])\" |\n  \"tree_invar (Node e a (Suc r) ts) = \n  (\\<exists> e1 a1 ts1 e2 a2 ts2. \n    tree_invar (Node e1 a1 r ts1) \\<and> \n    tree_invar (Node e2 a2 r ts2) \\<and> \n    (Node e a (Suc r) ts) = link (Node e1 a1 r ts1) (Node e2 a2 r ts2))\""], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>P x.\n       \\<lbrakk>\\<And>e a ts. x = Node e a 0 ts \\<Longrightarrow> P;\n        \\<And>e a r ts. x = Node e a (Suc r) ts \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P\n 2. \\<And>e a ts ea aa tsa.\n       Node e a 0 ts = Node ea aa 0 tsa \\<Longrightarrow>\n       (ts = []) = (tsa = [])\n 3. \\<And>e a ts ea aa r tsa.\n       Node e a 0 ts = Node ea aa (Suc r) tsa \\<Longrightarrow>\n       (ts = []) =\n       (\\<exists>e1 a1 ts1 e2 a2 ts2.\n           tree_invar_sumC (Node e1 a1 r ts1) \\<and>\n           tree_invar_sumC (Node e2 a2 r ts2) \\<and>\n           Node ea aa (Suc r) tsa =\n           link (Node e1 a1 r ts1) (Node e2 a2 r ts2))\n 4. \\<And>e a r ts ea aa ra tsa.\n       Node e a (Suc r) ts = Node ea aa (Suc ra) tsa \\<Longrightarrow>\n       (\\<exists>e1 a1 ts1 e2 a2 ts2.\n           tree_invar_sumC (Node e1 a1 r ts1) \\<and>\n           tree_invar_sumC (Node e2 a2 r ts2) \\<and>\n           Node e a (Suc r) ts =\n           link (Node e1 a1 r ts1) (Node e2 a2 r ts2)) =\n       (\\<exists>e1 a1 ts1 e2 a2 ts2.\n           tree_invar_sumC (Node e1 a1 ra ts1) \\<and>\n           tree_invar_sumC (Node e2 a2 ra ts2) \\<and>\n           Node ea aa (Suc ra) tsa =\n           link (Node e1 a1 ra ts1) (Node e2 a2 ra ts2))", "by pat_completeness auto"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. Wellfounded.accp tree_invar_rel x", "apply(relation \"measure (\\<lambda>t. rank t)\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. wf (measure rank)\n 2. \\<And>e a r ts x xa xb xc xd xe.\n       (Node x xa r xb, Node e a (Suc r) ts) \\<in> measure rank\n 3. \\<And>e a r ts x xa xb xc xd xe.\n       (Node xc xd r xe, Node e a (Suc r) ts) \\<in> measure rank", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>A queue satisfies the invariant, iff all trees inside the queue satisfy \n  the invariant, and the queue contains only trees of distinct rank and \n  is ordered by rank\\<close>"], ["", "text \\<open>First part: All trees of the queue satisfy the tree invariant:\\<close>"], ["", "definition queue_invar :: \"('e, 'a::linorder) BinomialQueue_inv \\<Rightarrow> bool\" where\n  \"queue_invar q \\<equiv> (\\<forall>t \\<in> set q. tree_invar t)\""], ["", "text \\<open>Second part: Trees have distinct rank, and are ordered by \n  ascending rank:\\<close>"], ["", "fun rank_invar :: \"('e, 'a::linorder) BinomialQueue_inv \\<Rightarrow> bool\" where\n  \"rank_invar [] = True\" |\n  \"rank_invar [t] = True\" |\n  \"rank_invar (t # t' # bq) = (rank t < rank t' \\<and> rank_invar (t' # bq))\""], ["", "lemma queue_invar_simps[simp]:\n  \"queue_invar []\"\n  \"queue_invar (t#q) \\<longleftrightarrow> tree_invar t \\<and> queue_invar q\"\n  \"queue_invar (q@q') \\<longleftrightarrow> queue_invar q \\<and> queue_invar q'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. queue_invar [] &&&\n    queue_invar (t # q) = (tree_invar t \\<and> queue_invar q) &&&\n    queue_invar (q @ q') = (queue_invar q \\<and> queue_invar q')", "unfolding queue_invar_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>t\\<in>set []. tree_invar t &&&\n    (\\<forall>t\\<in>set (t # q). tree_invar t) =\n    (tree_invar t \\<and> (\\<forall>t\\<in>set q. tree_invar t)) &&&\n    (\\<forall>t\\<in>set (q @ q'). tree_invar t) =\n    ((\\<forall>t\\<in>set q. tree_invar t) \\<and>\n     (\\<forall>t\\<in>set q'. tree_invar t))", "by auto"], ["", "text \\<open>Invariant for binomial queues:\\<close>"], ["", "definition \"invar q == queue_invar q \\<and> rank_invar q\""], ["", "lemma mset_link[simp]: \"(tree_to_multiset (link t1 t2)) \n  = (tree_to_multiset t1) + (tree_to_multiset t2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tree_to_multiset (link t1 t2) =\n    tree_to_multiset t1 + tree_to_multiset t2", "by(cases t1, cases t2, auto simp add: union_ac)"], ["", "lemma link_tree_invar: \n  \"\\<lbrakk>tree_invar t1; tree_invar t2; rank t1 = rank t2\\<rbrakk> \\<Longrightarrow> tree_invar (link t1 t2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>tree_invar t1; tree_invar t2; rank t1 = rank t2\\<rbrakk>\n    \\<Longrightarrow> tree_invar (link t1 t2)", "by (cases t1, cases t2, simp, blast)"], ["", "lemma invar_children: \n  assumes \"tree_invar ((Node e a r ts)::(('e, 'a::linorder) BinomialTree))\" \n  shows \"queue_invar ts\""], ["proof (prove)\ngoal (1 subgoal):\n 1. queue_invar ts", "using assms"], ["proof (prove)\nusing this:\n  tree_invar (Node e a r ts)\n\ngoal (1 subgoal):\n 1. queue_invar ts", "unfolding queue_invar_def"], ["proof (prove)\nusing this:\n  tree_invar (Node e a r ts)\n\ngoal (1 subgoal):\n 1. \\<forall>t\\<in>set ts. tree_invar t", "proof(induct r arbitrary: e a ts)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>e a ts.\n       tree_invar (Node e a 0 ts) \\<Longrightarrow> Ball (set ts) tree_invar\n 2. \\<And>r e a ts.\n       \\<lbrakk>\\<And>e a ts.\n                   tree_invar (Node e a r ts) \\<Longrightarrow>\n                   Ball (set ts) tree_invar;\n        tree_invar (Node e a (Suc r) ts)\\<rbrakk>\n       \\<Longrightarrow> Ball (set ts) tree_invar", "case 0"], ["proof (state)\nthis:\n  tree_invar (Node e a 0 ts)\n\ngoal (2 subgoals):\n 1. \\<And>e a ts.\n       tree_invar (Node e a 0 ts) \\<Longrightarrow> Ball (set ts) tree_invar\n 2. \\<And>r e a ts.\n       \\<lbrakk>\\<And>e a ts.\n                   tree_invar (Node e a r ts) \\<Longrightarrow>\n                   Ball (set ts) tree_invar;\n        tree_invar (Node e a (Suc r) ts)\\<rbrakk>\n       \\<Longrightarrow> Ball (set ts) tree_invar", "then"], ["proof (chain)\npicking this:\n  tree_invar (Node e a 0 ts)", "show ?case"], ["proof (prove)\nusing this:\n  tree_invar (Node e a 0 ts)\n\ngoal (1 subgoal):\n 1. \\<forall>a\\<in>set ts. tree_invar a", "by simp"], ["proof (state)\nthis:\n  \\<forall>a\\<in>set ts. tree_invar a\n\ngoal (1 subgoal):\n 1. \\<And>r e a ts.\n       \\<lbrakk>\\<And>e a ts.\n                   tree_invar (Node e a r ts) \\<Longrightarrow>\n                   Ball (set ts) tree_invar;\n        tree_invar (Node e a (Suc r) ts)\\<rbrakk>\n       \\<Longrightarrow> Ball (set ts) tree_invar", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>r e a ts.\n       \\<lbrakk>\\<And>e a ts.\n                   tree_invar (Node e a r ts) \\<Longrightarrow>\n                   Ball (set ts) tree_invar;\n        tree_invar (Node e a (Suc r) ts)\\<rbrakk>\n       \\<Longrightarrow> Ball (set ts) tree_invar", "case (Suc r)"], ["proof (state)\nthis:\n  tree_invar (Node ?e ?a r ?ts) \\<Longrightarrow>\n  \\<forall>a\\<in>set ?ts. tree_invar a\n  tree_invar (Node e a (Suc r) ts)\n\ngoal (1 subgoal):\n 1. \\<And>r e a ts.\n       \\<lbrakk>\\<And>e a ts.\n                   tree_invar (Node e a r ts) \\<Longrightarrow>\n                   Ball (set ts) tree_invar;\n        tree_invar (Node e a (Suc r) ts)\\<rbrakk>\n       \\<Longrightarrow> Ball (set ts) tree_invar", "from Suc(2)"], ["proof (chain)\npicking this:\n  tree_invar (Node e a (Suc r) ts)", "obtain e1 a1 ts1 e2 a2 ts2 where \n    O: \"tree_invar (Node e1 a1 r ts1)\"  \"tree_invar (Node e2 a2 r ts2)\" \n    \"(Node e a (Suc r) ts) = link (Node e1 a1 r ts1) (Node e2 a2 r ts2)\""], ["proof (prove)\nusing this:\n  tree_invar (Node e a (Suc r) ts)\n\ngoal (1 subgoal):\n 1. (\\<And>e1 a1 ts1 e2 a2 ts2.\n        \\<lbrakk>tree_invar (Node e1 a1 r ts1);\n         tree_invar (Node e2 a2 r ts2);\n         Node e a (Suc r) ts =\n         link (Node e1 a1 r ts1) (Node e2 a2 r ts2)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (simp only: tree_invar.simps) blast"], ["proof (state)\nthis:\n  tree_invar (Node e1 a1 r ts1)\n  tree_invar (Node e2 a2 r ts2)\n  Node e a (Suc r) ts = link (Node e1 a1 r ts1) (Node e2 a2 r ts2)\n\ngoal (1 subgoal):\n 1. \\<And>r e a ts.\n       \\<lbrakk>\\<And>e a ts.\n                   tree_invar (Node e a r ts) \\<Longrightarrow>\n                   Ball (set ts) tree_invar;\n        tree_invar (Node e a (Suc r) ts)\\<rbrakk>\n       \\<Longrightarrow> Ball (set ts) tree_invar", "from Suc(1)[OF O(1)] O(2)"], ["proof (chain)\npicking this:\n  \\<forall>a\\<in>set ts1. tree_invar a\n  tree_invar (Node e2 a2 r ts2)", "have case1: \"queue_invar ((Node e2 a2 r ts2) # ts1)\""], ["proof (prove)\nusing this:\n  \\<forall>a\\<in>set ts1. tree_invar a\n  tree_invar (Node e2 a2 r ts2)\n\ngoal (1 subgoal):\n 1. queue_invar (Node e2 a2 r ts2 # ts1)", "unfolding queue_invar_def"], ["proof (prove)\nusing this:\n  \\<forall>a\\<in>set ts1. tree_invar a\n  tree_invar (Node e2 a2 r ts2)\n\ngoal (1 subgoal):\n 1. \\<forall>t\\<in>set (Node e2 a2 r ts2 # ts1). tree_invar t", "by simp"], ["proof (state)\nthis:\n  queue_invar (Node e2 a2 r ts2 # ts1)\n\ngoal (1 subgoal):\n 1. \\<And>r e a ts.\n       \\<lbrakk>\\<And>e a ts.\n                   tree_invar (Node e a r ts) \\<Longrightarrow>\n                   Ball (set ts) tree_invar;\n        tree_invar (Node e a (Suc r) ts)\\<rbrakk>\n       \\<Longrightarrow> Ball (set ts) tree_invar", "from Suc(1)[OF O(2)] O(1)"], ["proof (chain)\npicking this:\n  \\<forall>a\\<in>set ts2. tree_invar a\n  tree_invar (Node e1 a1 r ts1)", "have case2: \"queue_invar ((Node e1 a1 r ts1) # ts2)\""], ["proof (prove)\nusing this:\n  \\<forall>a\\<in>set ts2. tree_invar a\n  tree_invar (Node e1 a1 r ts1)\n\ngoal (1 subgoal):\n 1. queue_invar (Node e1 a1 r ts1 # ts2)", "unfolding queue_invar_def"], ["proof (prove)\nusing this:\n  \\<forall>a\\<in>set ts2. tree_invar a\n  tree_invar (Node e1 a1 r ts1)\n\ngoal (1 subgoal):\n 1. \\<forall>t\\<in>set (Node e1 a1 r ts1 # ts2). tree_invar t", "by simp"], ["proof (state)\nthis:\n  queue_invar (Node e1 a1 r ts1 # ts2)\n\ngoal (1 subgoal):\n 1. \\<And>r e a ts.\n       \\<lbrakk>\\<And>e a ts.\n                   tree_invar (Node e a r ts) \\<Longrightarrow>\n                   Ball (set ts) tree_invar;\n        tree_invar (Node e a (Suc r) ts)\\<rbrakk>\n       \\<Longrightarrow> Ball (set ts) tree_invar", "from O(3)"], ["proof (chain)\npicking this:\n  Node e a (Suc r) ts = link (Node e1 a1 r ts1) (Node e2 a2 r ts2)", "have \"ts = (if a1\\<le>a2 \n    then (Node e2 a2 r ts2) # ts1 \n    else (Node e1 a1 r ts1) # ts2)\""], ["proof (prove)\nusing this:\n  Node e a (Suc r) ts = link (Node e1 a1 r ts1) (Node e2 a2 r ts2)\n\ngoal (1 subgoal):\n 1. ts =\n    (if a1 \\<le> a2 then Node e2 a2 r ts2 # ts1 else Node e1 a1 r ts1 # ts2)", "by auto"], ["proof (state)\nthis:\n  ts =\n  (if a1 \\<le> a2 then Node e2 a2 r ts2 # ts1 else Node e1 a1 r ts1 # ts2)\n\ngoal (1 subgoal):\n 1. \\<And>r e a ts.\n       \\<lbrakk>\\<And>e a ts.\n                   tree_invar (Node e a r ts) \\<Longrightarrow>\n                   Ball (set ts) tree_invar;\n        tree_invar (Node e a (Suc r) ts)\\<rbrakk>\n       \\<Longrightarrow> Ball (set ts) tree_invar", "with case1 case2"], ["proof (chain)\npicking this:\n  queue_invar (Node e2 a2 r ts2 # ts1)\n  queue_invar (Node e1 a1 r ts1 # ts2)\n  ts =\n  (if a1 \\<le> a2 then Node e2 a2 r ts2 # ts1 else Node e1 a1 r ts1 # ts2)", "show ?case"], ["proof (prove)\nusing this:\n  queue_invar (Node e2 a2 r ts2 # ts1)\n  queue_invar (Node e1 a1 r ts1 # ts2)\n  ts =\n  (if a1 \\<le> a2 then Node e2 a2 r ts2 # ts1 else Node e1 a1 r ts1 # ts2)\n\ngoal (1 subgoal):\n 1. \\<forall>a\\<in>set ts. tree_invar a", "unfolding queue_invar_def"], ["proof (prove)\nusing this:\n  \\<forall>t\\<in>set (Node e2 a2 r ts2 # ts1). tree_invar t\n  \\<forall>t\\<in>set (Node e1 a1 r ts1 # ts2). tree_invar t\n  ts =\n  (if a1 \\<le> a2 then Node e2 a2 r ts2 # ts1 else Node e1 a1 r ts1 # ts2)\n\ngoal (1 subgoal):\n 1. \\<forall>a\\<in>set ts. tree_invar a", "by simp"], ["proof (state)\nthis:\n  \\<forall>a\\<in>set ts. tree_invar a\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma invar_children': \"tree_invar t \\<Longrightarrow> queue_invar (children t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tree_invar t \\<Longrightarrow> queue_invar (children t)", "by (cases t) (auto simp add: invar_children)"], ["", "lemma rank_link: \"rank t = rank t' \\<Longrightarrow> rank (link t t') = rank t + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rank t = rank t' \\<Longrightarrow> rank (link t t') = rank t + 1", "apply (cases t)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x3 x4.\n       \\<lbrakk>rank t = rank t'; t = Node x1 x2 x3 x4\\<rbrakk>\n       \\<Longrightarrow> rank (link t t') = rank t + 1", "apply (cases t')"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x3 x4 x1a x2a x3a x4a.\n       \\<lbrakk>rank t = rank t'; t = Node x1 x2 x3 x4;\n        t' = Node x1a x2a x3a x4a\\<rbrakk>\n       \\<Longrightarrow> rank (link t t') = rank t + 1", "apply(auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma rank_invar_not_empty_hd: \"\\<lbrakk>rank_invar (t # bq); bq \\<noteq> []\\<rbrakk> \\<Longrightarrow> \n  rank t < rank (hd bq)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>rank_invar (t # bq); bq \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> rank t < rank (hd bq)", "apply(induct bq arbitrary: t)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>t.\n       \\<lbrakk>rank_invar [t]; [] \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> rank t < rank (hd [])\n 2. \\<And>a bq t.\n       \\<lbrakk>\\<And>t.\n                   \\<lbrakk>rank_invar (t # bq); bq \\<noteq> []\\<rbrakk>\n                   \\<Longrightarrow> rank t < rank (hd bq);\n        rank_invar (t # a # bq); a # bq \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> rank t < rank (hd (a # bq))", "apply(auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma rank_invar_to_set: \"rank_invar (t # bq) \\<Longrightarrow> \n  \\<forall> t' \\<in> set bq. rank t < rank t'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rank_invar (t # bq) \\<Longrightarrow>\n    \\<forall>t'\\<in>set bq. rank t < rank t'", "apply(induct bq arbitrary: t)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>t.\n       rank_invar [t] \\<Longrightarrow>\n       \\<forall>t'\\<in>set []. rank t < rank t'\n 2. \\<And>a bq t.\n       \\<lbrakk>\\<And>t.\n                   rank_invar (t # bq) \\<Longrightarrow>\n                   \\<forall>t'\\<in>set bq. rank t < rank t';\n        rank_invar (t # a # bq)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>t'\\<in>set (a # bq). rank t < rank t'", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a bq t.\n       \\<lbrakk>\\<And>t.\n                   rank_invar (t # bq) \\<Longrightarrow>\n                   \\<forall>t'\\<in>set bq. rank t < rank t';\n        rank_invar (t # a # bq)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>t'\\<in>set (a # bq). rank t < rank t'", "apply (metis nat_less_le rank_invar.simps(3) set_ConsD xt1(7))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma set_to_rank_invar: \"\\<lbrakk>\\<forall> t' \\<in> set bq. rank t < rank t'; rank_invar bq\\<rbrakk> \n  \\<Longrightarrow>  rank_invar (t # bq)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>t'\\<in>set bq. rank t < rank t';\n     rank_invar bq\\<rbrakk>\n    \\<Longrightarrow> rank_invar (t # bq)", "apply(induct bq arbitrary: t)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>t.\n       \\<lbrakk>\\<forall>t'\\<in>set []. rank t < rank t';\n        rank_invar []\\<rbrakk>\n       \\<Longrightarrow> rank_invar [t]\n 2. \\<And>a bq t.\n       \\<lbrakk>\\<And>t.\n                   \\<lbrakk>\\<forall>t'\\<in>set bq. rank t < rank t';\n                    rank_invar bq\\<rbrakk>\n                   \\<Longrightarrow> rank_invar (t # bq);\n        \\<forall>t'\\<in>set (a # bq). rank t < rank t';\n        rank_invar (a # bq)\\<rbrakk>\n       \\<Longrightarrow> rank_invar (t # a # bq)", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a bq t.\n       \\<lbrakk>\\<And>t.\n                   \\<lbrakk>\\<forall>t'\\<in>set bq. rank t < rank t';\n                    rank_invar bq\\<rbrakk>\n                   \\<Longrightarrow> rank_invar (t # bq);\n        \\<forall>t'\\<in>set (a # bq). rank t < rank t';\n        rank_invar (a # bq)\\<rbrakk>\n       \\<Longrightarrow> rank_invar (t # a # bq)", "by (metis list.sel(1) hd_in_set list.distinct(1) rank_invar.simps(3))"], ["", "lemma rank_invar_hd_cons: \n  \"\\<lbrakk>rank_invar bq; rank t < rank (hd bq)\\<rbrakk> \\<Longrightarrow> rank_invar (t # bq)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>rank_invar bq; rank t < rank (hd bq)\\<rbrakk>\n    \\<Longrightarrow> rank_invar (t # bq)", "apply(cases bq)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>rank_invar bq; rank t < rank (hd bq); bq = []\\<rbrakk>\n    \\<Longrightarrow> rank_invar (t # bq)\n 2. \\<And>a list.\n       \\<lbrakk>rank_invar bq; rank t < rank (hd bq); bq = a # list\\<rbrakk>\n       \\<Longrightarrow> rank_invar (t # bq)", "apply(auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma rank_invar_cons: \"rank_invar (t # bq) \\<Longrightarrow> rank_invar bq\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rank_invar (t # bq) \\<Longrightarrow> rank_invar bq", "apply(cases bq)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>rank_invar (t # bq); bq = []\\<rbrakk>\n    \\<Longrightarrow> rank_invar bq\n 2. \\<And>a list.\n       \\<lbrakk>rank_invar (t # bq); bq = a # list\\<rbrakk>\n       \\<Longrightarrow> rank_invar bq", "apply(auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma invar_cons_up: \n  \"\\<lbrakk>invar (t # bq); rank t' < rank t; tree_invar t'\\<rbrakk> \\<Longrightarrow> invar (t' # t # bq)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>invar (t # bq); rank t' < rank t; tree_invar t'\\<rbrakk>\n    \\<Longrightarrow> invar (t' # t # bq)", "unfolding invar_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>queue_invar (t # bq) \\<and> rank_invar (t # bq);\n     rank t' < rank t; tree_invar t'\\<rbrakk>\n    \\<Longrightarrow> queue_invar (t' # t # bq) \\<and>\n                      rank_invar (t' # t # bq)", "by (cases bq) simp_all"], ["", "lemma invar_cons_down: \"invar (t # bq) \\<Longrightarrow> invar bq\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invar (t # bq) \\<Longrightarrow> invar bq", "unfolding invar_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. queue_invar (t # bq) \\<and> rank_invar (t # bq) \\<Longrightarrow>\n    queue_invar bq \\<and> rank_invar bq", "by (cases bq) simp_all"], ["", "lemma invar_app_single: \n  \"\\<lbrakk>invar bq; \\<forall>t \\<in> set bq. rank t < rank t'; tree_invar t'\\<rbrakk> \n   \\<Longrightarrow> invar (bq @ [t'])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>invar bq; \\<forall>t\\<in>set bq. rank t < rank t';\n     tree_invar t'\\<rbrakk>\n    \\<Longrightarrow> invar (bq @ [t'])", "proof (induct bq)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>invar []; \\<forall>t\\<in>set []. rank t < rank t';\n     tree_invar t'\\<rbrakk>\n    \\<Longrightarrow> invar ([] @ [t'])\n 2. \\<And>a bq.\n       \\<lbrakk>\\<lbrakk>invar bq; \\<forall>t\\<in>set bq. rank t < rank t';\n                 tree_invar t'\\<rbrakk>\n                \\<Longrightarrow> invar (bq @ [t']);\n        invar (a # bq); \\<forall>t\\<in>set (a # bq). rank t < rank t';\n        tree_invar t'\\<rbrakk>\n       \\<Longrightarrow> invar ((a # bq) @ [t'])", "case Nil"], ["proof (state)\nthis:\n  invar []\n  \\<forall>t\\<in>set []. rank t < rank t'\n  tree_invar t'\n\ngoal (2 subgoals):\n 1. \\<lbrakk>invar []; \\<forall>t\\<in>set []. rank t < rank t';\n     tree_invar t'\\<rbrakk>\n    \\<Longrightarrow> invar ([] @ [t'])\n 2. \\<And>a bq.\n       \\<lbrakk>\\<lbrakk>invar bq; \\<forall>t\\<in>set bq. rank t < rank t';\n                 tree_invar t'\\<rbrakk>\n                \\<Longrightarrow> invar (bq @ [t']);\n        invar (a # bq); \\<forall>t\\<in>set (a # bq). rank t < rank t';\n        tree_invar t'\\<rbrakk>\n       \\<Longrightarrow> invar ((a # bq) @ [t'])", "then"], ["proof (chain)\npicking this:\n  invar []\n  \\<forall>t\\<in>set []. rank t < rank t'\n  tree_invar t'", "show ?case"], ["proof (prove)\nusing this:\n  invar []\n  \\<forall>t\\<in>set []. rank t < rank t'\n  tree_invar t'\n\ngoal (1 subgoal):\n 1. invar ([] @ [t'])", "by (simp add: invar_def)"], ["proof (state)\nthis:\n  invar ([] @ [t'])\n\ngoal (1 subgoal):\n 1. \\<And>a bq.\n       \\<lbrakk>\\<lbrakk>invar bq; \\<forall>t\\<in>set bq. rank t < rank t';\n                 tree_invar t'\\<rbrakk>\n                \\<Longrightarrow> invar (bq @ [t']);\n        invar (a # bq); \\<forall>t\\<in>set (a # bq). rank t < rank t';\n        tree_invar t'\\<rbrakk>\n       \\<Longrightarrow> invar ((a # bq) @ [t'])", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a bq.\n       \\<lbrakk>\\<lbrakk>invar bq; \\<forall>t\\<in>set bq. rank t < rank t';\n                 tree_invar t'\\<rbrakk>\n                \\<Longrightarrow> invar (bq @ [t']);\n        invar (a # bq); \\<forall>t\\<in>set (a # bq). rank t < rank t';\n        tree_invar t'\\<rbrakk>\n       \\<Longrightarrow> invar ((a # bq) @ [t'])", "case (Cons a bq)"], ["proof (state)\nthis:\n  \\<lbrakk>invar bq; \\<forall>t\\<in>set bq. rank t < rank t';\n   tree_invar t'\\<rbrakk>\n  \\<Longrightarrow> invar (bq @ [t'])\n  invar (a # bq)\n  \\<forall>t\\<in>set (a # bq). rank t < rank t'\n  tree_invar t'\n\ngoal (1 subgoal):\n 1. \\<And>a bq.\n       \\<lbrakk>\\<lbrakk>invar bq; \\<forall>t\\<in>set bq. rank t < rank t';\n                 tree_invar t'\\<rbrakk>\n                \\<Longrightarrow> invar (bq @ [t']);\n        invar (a # bq); \\<forall>t\\<in>set (a # bq). rank t < rank t';\n        tree_invar t'\\<rbrakk>\n       \\<Longrightarrow> invar ((a # bq) @ [t'])", "from \\<open>invar (a # bq)\\<close>"], ["proof (chain)\npicking this:\n  invar (a # bq)", "have \"invar bq\""], ["proof (prove)\nusing this:\n  invar (a # bq)\n\ngoal (1 subgoal):\n 1. invar bq", "by (rule invar_cons_down)"], ["proof (state)\nthis:\n  invar bq\n\ngoal (1 subgoal):\n 1. \\<And>a bq.\n       \\<lbrakk>\\<lbrakk>invar bq; \\<forall>t\\<in>set bq. rank t < rank t';\n                 tree_invar t'\\<rbrakk>\n                \\<Longrightarrow> invar (bq @ [t']);\n        invar (a # bq); \\<forall>t\\<in>set (a # bq). rank t < rank t';\n        tree_invar t'\\<rbrakk>\n       \\<Longrightarrow> invar ((a # bq) @ [t'])", "with Cons"], ["proof (chain)\npicking this:\n  \\<lbrakk>invar bq; \\<forall>t\\<in>set bq. rank t < rank t';\n   tree_invar t'\\<rbrakk>\n  \\<Longrightarrow> invar (bq @ [t'])\n  invar (a # bq)\n  \\<forall>t\\<in>set (a # bq). rank t < rank t'\n  tree_invar t'\n  invar bq", "have \"invar (bq @ [t'])\""], ["proof (prove)\nusing this:\n  \\<lbrakk>invar bq; \\<forall>t\\<in>set bq. rank t < rank t';\n   tree_invar t'\\<rbrakk>\n  \\<Longrightarrow> invar (bq @ [t'])\n  invar (a # bq)\n  \\<forall>t\\<in>set (a # bq). rank t < rank t'\n  tree_invar t'\n  invar bq\n\ngoal (1 subgoal):\n 1. invar (bq @ [t'])", "by simp"], ["proof (state)\nthis:\n  invar (bq @ [t'])\n\ngoal (1 subgoal):\n 1. \\<And>a bq.\n       \\<lbrakk>\\<lbrakk>invar bq; \\<forall>t\\<in>set bq. rank t < rank t';\n                 tree_invar t'\\<rbrakk>\n                \\<Longrightarrow> invar (bq @ [t']);\n        invar (a # bq); \\<forall>t\\<in>set (a # bq). rank t < rank t';\n        tree_invar t'\\<rbrakk>\n       \\<Longrightarrow> invar ((a # bq) @ [t'])", "with Cons"], ["proof (chain)\npicking this:\n  \\<lbrakk>invar bq; \\<forall>t\\<in>set bq. rank t < rank t';\n   tree_invar t'\\<rbrakk>\n  \\<Longrightarrow> invar (bq @ [t'])\n  invar (a # bq)\n  \\<forall>t\\<in>set (a # bq). rank t < rank t'\n  tree_invar t'\n  invar (bq @ [t'])", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>invar bq; \\<forall>t\\<in>set bq. rank t < rank t';\n   tree_invar t'\\<rbrakk>\n  \\<Longrightarrow> invar (bq @ [t'])\n  invar (a # bq)\n  \\<forall>t\\<in>set (a # bq). rank t < rank t'\n  tree_invar t'\n  invar (bq @ [t'])\n\ngoal (1 subgoal):\n 1. invar ((a # bq) @ [t'])", "by (cases bq) (simp_all add: invar_def)"], ["proof (state)\nthis:\n  invar ((a # bq) @ [t'])\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \"Heap Ordering\""], ["", "fun heap_ordered :: \"('e, 'a::linorder) BinomialTree \\<Rightarrow> bool\" where\n  \"heap_ordered (Node e a r ts) = (\\<forall>x \\<in> set_mset(queue_to_multiset ts). a \\<le> snd x)\""], ["", "text \\<open>The invariant for trees implies heap order.\\<close>"], ["", "lemma tree_invar_heap_ordered:\n  assumes \"tree_invar t\"\n  shows \"heap_ordered t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. heap_ordered t", "proof (cases t)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x3 x4. t = Node x1 x2 x3 x4 \\<Longrightarrow> heap_ordered t", "case (Node e a nat list)"], ["proof (state)\nthis:\n  t = Node e a nat list\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x3 x4. t = Node x1 x2 x3 x4 \\<Longrightarrow> heap_ordered t", "with assms"], ["proof (chain)\npicking this:\n  tree_invar t\n  t = Node e a nat list", "show ?thesis"], ["proof (prove)\nusing this:\n  tree_invar t\n  t = Node e a nat list\n\ngoal (1 subgoal):\n 1. heap_ordered t", "proof (induct nat arbitrary: t e a list)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>t e a list.\n       \\<lbrakk>tree_invar t; t = Node e a 0 list\\<rbrakk>\n       \\<Longrightarrow> heap_ordered t\n 2. \\<And>nat t e a list.\n       \\<lbrakk>\\<And>t e a list.\n                   \\<lbrakk>tree_invar t; t = Node e a nat list\\<rbrakk>\n                   \\<Longrightarrow> heap_ordered t;\n        tree_invar t; t = Node e a (Suc nat) list\\<rbrakk>\n       \\<Longrightarrow> heap_ordered t", "case 0"], ["proof (state)\nthis:\n  tree_invar t\n  t = Node e a 0 list\n\ngoal (2 subgoals):\n 1. \\<And>t e a list.\n       \\<lbrakk>tree_invar t; t = Node e a 0 list\\<rbrakk>\n       \\<Longrightarrow> heap_ordered t\n 2. \\<And>nat t e a list.\n       \\<lbrakk>\\<And>t e a list.\n                   \\<lbrakk>tree_invar t; t = Node e a nat list\\<rbrakk>\n                   \\<Longrightarrow> heap_ordered t;\n        tree_invar t; t = Node e a (Suc nat) list\\<rbrakk>\n       \\<Longrightarrow> heap_ordered t", "then"], ["proof (chain)\npicking this:\n  tree_invar t\n  t = Node e a 0 list", "show ?case"], ["proof (prove)\nusing this:\n  tree_invar t\n  t = Node e a 0 list\n\ngoal (1 subgoal):\n 1. heap_ordered t", "by simp"], ["proof (state)\nthis:\n  heap_ordered t\n\ngoal (1 subgoal):\n 1. \\<And>nat t e a list.\n       \\<lbrakk>\\<And>t e a list.\n                   \\<lbrakk>tree_invar t; t = Node e a nat list\\<rbrakk>\n                   \\<Longrightarrow> heap_ordered t;\n        tree_invar t; t = Node e a (Suc nat) list\\<rbrakk>\n       \\<Longrightarrow> heap_ordered t", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat t e a list.\n       \\<lbrakk>\\<And>t e a list.\n                   \\<lbrakk>tree_invar t; t = Node e a nat list\\<rbrakk>\n                   \\<Longrightarrow> heap_ordered t;\n        tree_invar t; t = Node e a (Suc nat) list\\<rbrakk>\n       \\<Longrightarrow> heap_ordered t", "case (Suc nat t)"], ["proof (state)\nthis:\n  \\<lbrakk>tree_invar ?t; ?t = Node ?e ?a nat ?list\\<rbrakk>\n  \\<Longrightarrow> heap_ordered ?t\n  tree_invar t\n  t = Node e a (Suc nat) list\n\ngoal (1 subgoal):\n 1. \\<And>nat t e a list.\n       \\<lbrakk>\\<And>t e a list.\n                   \\<lbrakk>tree_invar t; t = Node e a nat list\\<rbrakk>\n                   \\<Longrightarrow> heap_ordered t;\n        tree_invar t; t = Node e a (Suc nat) list\\<rbrakk>\n       \\<Longrightarrow> heap_ordered t", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>tree_invar ?t; ?t = Node ?e ?a nat ?list\\<rbrakk>\n  \\<Longrightarrow> heap_ordered ?t\n  tree_invar t\n  t = Node e a (Suc nat) list", "obtain t1 e1 a1 ts1 t2 e2 a2 ts2 where \n      O: \"tree_invar t1\"  \"tree_invar t2\" \"t = link t1 t2\" \n      and t1[simp]: \"t1 = (Node e1 a1 nat ts1)\" \n      and t2[simp]: \"t2 = (Node e2 a2 nat ts2)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>tree_invar ?t; ?t = Node ?e ?a nat ?list\\<rbrakk>\n  \\<Longrightarrow> heap_ordered ?t\n  tree_invar t\n  t = Node e a (Suc nat) list\n\ngoal (1 subgoal):\n 1. (\\<And>t1 t2 e1 a1 ts1 e2 a2 ts2.\n        \\<lbrakk>tree_invar t1; tree_invar t2; t = link t1 t2;\n         t1 = Node e1 a1 nat ts1; t2 = Node e2 a2 nat ts2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (simp only: tree_invar.simps) blast"], ["proof (state)\nthis:\n  tree_invar t1\n  tree_invar t2\n  t = link t1 t2\n  t1 = Node e1 a1 nat ts1\n  t2 = Node e2 a2 nat ts2\n\ngoal (1 subgoal):\n 1. \\<And>nat t e a list.\n       \\<lbrakk>\\<And>t e a list.\n                   \\<lbrakk>tree_invar t; t = Node e a nat list\\<rbrakk>\n                   \\<Longrightarrow> heap_ordered t;\n        tree_invar t; t = Node e a (Suc nat) list\\<rbrakk>\n       \\<Longrightarrow> heap_ordered t", "from O(3)"], ["proof (chain)\npicking this:\n  t = link t1 t2", "have \"t = (if  a1\\<le>a2 \n      then (Node e1 a1 (Suc nat) (t2 # ts1))\n      else (Node e2 a2 (Suc nat) (t1 # ts2)))\""], ["proof (prove)\nusing this:\n  t = link t1 t2\n\ngoal (1 subgoal):\n 1. t =\n    (if a1 \\<le> a2 then Node e1 a1 (Suc nat) (t2 # ts1)\n     else Node e2 a2 (Suc nat) (t1 # ts2))", "by simp"], ["proof (state)\nthis:\n  t =\n  (if a1 \\<le> a2 then Node e1 a1 (Suc nat) (t2 # ts1)\n   else Node e2 a2 (Suc nat) (t1 # ts2))\n\ngoal (1 subgoal):\n 1. \\<And>nat t e a list.\n       \\<lbrakk>\\<And>t e a list.\n                   \\<lbrakk>tree_invar t; t = Node e a nat list\\<rbrakk>\n                   \\<Longrightarrow> heap_ordered t;\n        tree_invar t; t = Node e a (Suc nat) list\\<rbrakk>\n       \\<Longrightarrow> heap_ordered t", "with Suc(1)[OF O(1) t1] Suc(1)[OF O(2) t2]"], ["proof (chain)\npicking this:\n  heap_ordered t1\n  heap_ordered t2\n  t =\n  (if a1 \\<le> a2 then Node e1 a1 (Suc nat) (t2 # ts1)\n   else Node e2 a2 (Suc nat) (t1 # ts2))", "show ?case"], ["proof (prove)\nusing this:\n  heap_ordered t1\n  heap_ordered t2\n  t =\n  (if a1 \\<le> a2 then Node e1 a1 (Suc nat) (t2 # ts1)\n   else Node e2 a2 (Suc nat) (t1 # ts2))\n\ngoal (1 subgoal):\n 1. heap_ordered t", "by (cases \"a1 \\<le> a2\") auto"], ["proof (state)\nthis:\n  heap_ordered t\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  heap_ordered t\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \"Height and Length\""], ["", "text \\<open>\n  Although complexity of HOL-functions cannot be expressed within \n  HOL, we can express the height and length of a binomial heap.\n  By showing that both, height and length, are logarithmic in the number \n  of contained elements, we give strong evidence that our functions have\n  logarithmic complexity in the number of elements.\n\\<close>"], ["", "text \\<open>Height of a tree and queue\\<close>"], ["", "fun height_tree :: \"('e, ('a::linorder)) BinomialTree \\<Rightarrow> nat\" and\n    height_queue :: \"('e, ('a::linorder)) BinomialQueue_inv \\<Rightarrow> nat\" \n  where\n  \"height_tree (Node e a r ts) = height_queue ts\" |\n  \"height_queue [] = 0\" |\n  \"height_queue (t # ts) = max (Suc (height_tree t)) (height_queue ts)\""], ["", "lemma link_length: \"size (tree_to_multiset (link t1 t2)) = \n  size (tree_to_multiset t1) + size (tree_to_multiset t2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. size (tree_to_multiset (link t1 t2)) =\n    size (tree_to_multiset t1) + size (tree_to_multiset t2)", "apply(cases t1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x3 x4.\n       t1 = Node x1 x2 x3 x4 \\<Longrightarrow>\n       size (tree_to_multiset (link t1 t2)) =\n       size (tree_to_multiset t1) + size (tree_to_multiset t2)", "apply(cases t2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x3 x4 x1a x2a x3a x4a.\n       \\<lbrakk>t1 = Node x1 x2 x3 x4; t2 = Node x1a x2a x3a x4a\\<rbrakk>\n       \\<Longrightarrow> size (tree_to_multiset (link t1 t2)) =\n                         size (tree_to_multiset t1) +\n                         size (tree_to_multiset t2)", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma tree_rank_estimate:\n  \"tree_invar (Node e a r ts) \\<Longrightarrow> \n    size (tree_to_multiset (Node e a r ts)) = (2::nat)^r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tree_invar (Node e a r ts) \\<Longrightarrow>\n    size (tree_to_multiset (Node e a r ts)) = 2 ^ r", "proof (induct r arbitrary: e a ts)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>e a ts.\n       tree_invar (Node e a 0 ts) \\<Longrightarrow>\n       size (tree_to_multiset (Node e a 0 ts)) = 2 ^ 0\n 2. \\<And>r e a ts.\n       \\<lbrakk>\\<And>e a ts.\n                   tree_invar (Node e a r ts) \\<Longrightarrow>\n                   size (tree_to_multiset (Node e a r ts)) = 2 ^ r;\n        tree_invar (Node e a (Suc r) ts)\\<rbrakk>\n       \\<Longrightarrow> size (tree_to_multiset (Node e a (Suc r) ts)) =\n                         2 ^ Suc r", "case 0"], ["proof (state)\nthis:\n  tree_invar (Node e a 0 ts)\n\ngoal (2 subgoals):\n 1. \\<And>e a ts.\n       tree_invar (Node e a 0 ts) \\<Longrightarrow>\n       size (tree_to_multiset (Node e a 0 ts)) = 2 ^ 0\n 2. \\<And>r e a ts.\n       \\<lbrakk>\\<And>e a ts.\n                   tree_invar (Node e a r ts) \\<Longrightarrow>\n                   size (tree_to_multiset (Node e a r ts)) = 2 ^ r;\n        tree_invar (Node e a (Suc r) ts)\\<rbrakk>\n       \\<Longrightarrow> size (tree_to_multiset (Node e a (Suc r) ts)) =\n                         2 ^ Suc r", "then"], ["proof (chain)\npicking this:\n  tree_invar (Node e a 0 ts)", "show ?case"], ["proof (prove)\nusing this:\n  tree_invar (Node e a 0 ts)\n\ngoal (1 subgoal):\n 1. size (tree_to_multiset (Node e a 0 ts)) = 2 ^ 0", "by simp"], ["proof (state)\nthis:\n  size (tree_to_multiset (Node e a 0 ts)) = 2 ^ 0\n\ngoal (1 subgoal):\n 1. \\<And>r e a ts.\n       \\<lbrakk>\\<And>e a ts.\n                   tree_invar (Node e a r ts) \\<Longrightarrow>\n                   size (tree_to_multiset (Node e a r ts)) = 2 ^ r;\n        tree_invar (Node e a (Suc r) ts)\\<rbrakk>\n       \\<Longrightarrow> size (tree_to_multiset (Node e a (Suc r) ts)) =\n                         2 ^ Suc r", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>r e a ts.\n       \\<lbrakk>\\<And>e a ts.\n                   tree_invar (Node e a r ts) \\<Longrightarrow>\n                   size (tree_to_multiset (Node e a r ts)) = 2 ^ r;\n        tree_invar (Node e a (Suc r) ts)\\<rbrakk>\n       \\<Longrightarrow> size (tree_to_multiset (Node e a (Suc r) ts)) =\n                         2 ^ Suc r", "case (Suc r)"], ["proof (state)\nthis:\n  tree_invar (Node ?e ?a r ?ts) \\<Longrightarrow>\n  size (tree_to_multiset (Node ?e ?a r ?ts)) = 2 ^ r\n  tree_invar (Node e a (Suc r) ts)\n\ngoal (1 subgoal):\n 1. \\<And>r e a ts.\n       \\<lbrakk>\\<And>e a ts.\n                   tree_invar (Node e a r ts) \\<Longrightarrow>\n                   size (tree_to_multiset (Node e a r ts)) = 2 ^ r;\n        tree_invar (Node e a (Suc r) ts)\\<rbrakk>\n       \\<Longrightarrow> size (tree_to_multiset (Node e a (Suc r) ts)) =\n                         2 ^ Suc r", "from Suc(2)"], ["proof (chain)\npicking this:\n  tree_invar (Node e a (Suc r) ts)", "obtain e1 a1 ts1 e2 a2 ts2 where link:\n    \"(Node e a (Suc r) ts) = link (Node e1 a1 r ts1) (Node e2 a2 r ts2)\"\n    and inv1: \"tree_invar (Node e1 a1 r ts1) \"\n    and inv2: \"tree_invar (Node e2 a2 r ts2)\""], ["proof (prove)\nusing this:\n  tree_invar (Node e a (Suc r) ts)\n\ngoal (1 subgoal):\n 1. (\\<And>e1 a1 ts1 e2 a2 ts2.\n        \\<lbrakk>Node e a (Suc r) ts =\n                 link (Node e1 a1 r ts1) (Node e2 a2 r ts2);\n         tree_invar (Node e1 a1 r ts1);\n         tree_invar (Node e2 a2 r ts2)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by simp blast"], ["proof (state)\nthis:\n  Node e a (Suc r) ts = link (Node e1 a1 r ts1) (Node e2 a2 r ts2)\n  tree_invar (Node e1 a1 r ts1)\n  tree_invar (Node e2 a2 r ts2)\n\ngoal (1 subgoal):\n 1. \\<And>r e a ts.\n       \\<lbrakk>\\<And>e a ts.\n                   tree_invar (Node e a r ts) \\<Longrightarrow>\n                   size (tree_to_multiset (Node e a r ts)) = 2 ^ r;\n        tree_invar (Node e a (Suc r) ts)\\<rbrakk>\n       \\<Longrightarrow> size (tree_to_multiset (Node e a (Suc r) ts)) =\n                         2 ^ Suc r", "from link_length[of \"(Node e1 a1 r ts1)\" \"(Node e2 a2 r ts2)\"]\n    Suc(1)[OF inv1] Suc(1)[OF inv2] link"], ["proof (chain)\npicking this:\n  size (tree_to_multiset (link (Node e1 a1 r ts1) (Node e2 a2 r ts2))) =\n  size (tree_to_multiset (Node e1 a1 r ts1)) +\n  size (tree_to_multiset (Node e2 a2 r ts2))\n  size (tree_to_multiset (Node e1 a1 r ts1)) = 2 ^ r\n  size (tree_to_multiset (Node e2 a2 r ts2)) = 2 ^ r\n  Node e a (Suc r) ts = link (Node e1 a1 r ts1) (Node e2 a2 r ts2)", "show ?case"], ["proof (prove)\nusing this:\n  size (tree_to_multiset (link (Node e1 a1 r ts1) (Node e2 a2 r ts2))) =\n  size (tree_to_multiset (Node e1 a1 r ts1)) +\n  size (tree_to_multiset (Node e2 a2 r ts2))\n  size (tree_to_multiset (Node e1 a1 r ts1)) = 2 ^ r\n  size (tree_to_multiset (Node e2 a2 r ts2)) = 2 ^ r\n  Node e a (Suc r) ts = link (Node e1 a1 r ts1) (Node e2 a2 r ts2)\n\ngoal (1 subgoal):\n 1. size (tree_to_multiset (Node e a (Suc r) ts)) = 2 ^ Suc r", "by simp"], ["proof (state)\nthis:\n  size (tree_to_multiset (Node e a (Suc r) ts)) = 2 ^ Suc r\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma tree_rank_height:\n  \"tree_invar (Node e a r ts) \\<Longrightarrow> height_tree (Node e a r ts) = r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tree_invar (Node e a r ts) \\<Longrightarrow>\n    height_tree (Node e a r ts) = r", "proof (induct r arbitrary: e a ts)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>e a ts.\n       tree_invar (Node e a 0 ts) \\<Longrightarrow>\n       height_tree (Node e a 0 ts) = 0\n 2. \\<And>r e a ts.\n       \\<lbrakk>\\<And>e a ts.\n                   tree_invar (Node e a r ts) \\<Longrightarrow>\n                   height_tree (Node e a r ts) = r;\n        tree_invar (Node e a (Suc r) ts)\\<rbrakk>\n       \\<Longrightarrow> height_tree (Node e a (Suc r) ts) = Suc r", "case 0"], ["proof (state)\nthis:\n  tree_invar (Node e a 0 ts)\n\ngoal (2 subgoals):\n 1. \\<And>e a ts.\n       tree_invar (Node e a 0 ts) \\<Longrightarrow>\n       height_tree (Node e a 0 ts) = 0\n 2. \\<And>r e a ts.\n       \\<lbrakk>\\<And>e a ts.\n                   tree_invar (Node e a r ts) \\<Longrightarrow>\n                   height_tree (Node e a r ts) = r;\n        tree_invar (Node e a (Suc r) ts)\\<rbrakk>\n       \\<Longrightarrow> height_tree (Node e a (Suc r) ts) = Suc r", "then"], ["proof (chain)\npicking this:\n  tree_invar (Node e a 0 ts)", "show ?case"], ["proof (prove)\nusing this:\n  tree_invar (Node e a 0 ts)\n\ngoal (1 subgoal):\n 1. height_tree (Node e a 0 ts) = 0", "by simp"], ["proof (state)\nthis:\n  height_tree (Node e a 0 ts) = 0\n\ngoal (1 subgoal):\n 1. \\<And>r e a ts.\n       \\<lbrakk>\\<And>e a ts.\n                   tree_invar (Node e a r ts) \\<Longrightarrow>\n                   height_tree (Node e a r ts) = r;\n        tree_invar (Node e a (Suc r) ts)\\<rbrakk>\n       \\<Longrightarrow> height_tree (Node e a (Suc r) ts) = Suc r", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>r e a ts.\n       \\<lbrakk>\\<And>e a ts.\n                   tree_invar (Node e a r ts) \\<Longrightarrow>\n                   height_tree (Node e a r ts) = r;\n        tree_invar (Node e a (Suc r) ts)\\<rbrakk>\n       \\<Longrightarrow> height_tree (Node e a (Suc r) ts) = Suc r", "case (Suc r)"], ["proof (state)\nthis:\n  tree_invar (Node ?e ?a r ?ts) \\<Longrightarrow>\n  height_tree (Node ?e ?a r ?ts) = r\n  tree_invar (Node e a (Suc r) ts)\n\ngoal (1 subgoal):\n 1. \\<And>r e a ts.\n       \\<lbrakk>\\<And>e a ts.\n                   tree_invar (Node e a r ts) \\<Longrightarrow>\n                   height_tree (Node e a r ts) = r;\n        tree_invar (Node e a (Suc r) ts)\\<rbrakk>\n       \\<Longrightarrow> height_tree (Node e a (Suc r) ts) = Suc r", "from Suc(2)"], ["proof (chain)\npicking this:\n  tree_invar (Node e a (Suc r) ts)", "obtain e1 a1 ts1 e2 a2 ts2 where link:\n    \"(Node e a (Suc r) ts) = link (Node e1 a1 r ts1) (Node e2 a2 r ts2)\"\n    and inv1: \"tree_invar (Node e1 a1 r ts1) \"\n    and inv2: \"tree_invar (Node e2 a2 r ts2)\""], ["proof (prove)\nusing this:\n  tree_invar (Node e a (Suc r) ts)\n\ngoal (1 subgoal):\n 1. (\\<And>e1 a1 ts1 e2 a2 ts2.\n        \\<lbrakk>Node e a (Suc r) ts =\n                 link (Node e1 a1 r ts1) (Node e2 a2 r ts2);\n         tree_invar (Node e1 a1 r ts1);\n         tree_invar (Node e2 a2 r ts2)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by simp blast"], ["proof (state)\nthis:\n  Node e a (Suc r) ts = link (Node e1 a1 r ts1) (Node e2 a2 r ts2)\n  tree_invar (Node e1 a1 r ts1)\n  tree_invar (Node e2 a2 r ts2)\n\ngoal (1 subgoal):\n 1. \\<And>r e a ts.\n       \\<lbrakk>\\<And>e a ts.\n                   tree_invar (Node e a r ts) \\<Longrightarrow>\n                   height_tree (Node e a r ts) = r;\n        tree_invar (Node e a (Suc r) ts)\\<rbrakk>\n       \\<Longrightarrow> height_tree (Node e a (Suc r) ts) = Suc r", "with link Suc(1)[OF inv1] Suc(1)[OF inv2] Suc(2)"], ["proof (chain)\npicking this:\n  Node e a (Suc r) ts = link (Node e1 a1 r ts1) (Node e2 a2 r ts2)\n  height_tree (Node e1 a1 r ts1) = r\n  height_tree (Node e2 a2 r ts2) = r\n  tree_invar (Node e a (Suc r) ts)\n  Node e a (Suc r) ts = link (Node e1 a1 r ts1) (Node e2 a2 r ts2)\n  tree_invar (Node e1 a1 r ts1)\n  tree_invar (Node e2 a2 r ts2)", "show ?case"], ["proof (prove)\nusing this:\n  Node e a (Suc r) ts = link (Node e1 a1 r ts1) (Node e2 a2 r ts2)\n  height_tree (Node e1 a1 r ts1) = r\n  height_tree (Node e2 a2 r ts2) = r\n  tree_invar (Node e a (Suc r) ts)\n  Node e a (Suc r) ts = link (Node e1 a1 r ts1) (Node e2 a2 r ts2)\n  tree_invar (Node e1 a1 r ts1)\n  tree_invar (Node e2 a2 r ts2)\n\ngoal (1 subgoal):\n 1. height_tree (Node e a (Suc r) ts) = Suc r", "by (cases \"a1 \\<le> a2\") simp_all"], ["proof (state)\nthis:\n  height_tree (Node e a (Suc r) ts) = Suc r\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>A binomial tree of height $h$ contains exactly $2^{h}$ elements\\<close>"], ["", "theorem tree_height_estimate:\n  \"tree_invar t \\<Longrightarrow> size (tree_to_multiset t) = (2::nat)^(height_tree t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tree_invar t \\<Longrightarrow>\n    size (tree_to_multiset t) = 2 ^ height_tree t", "apply (cases t, simp only:)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x3 x4.\n       \\<lbrakk>tree_invar (Node x1 x2 x3 x4); t = Node x1 x2 x3 x4\\<rbrakk>\n       \\<Longrightarrow> size (tree_to_multiset (Node x1 x2 x3 x4)) =\n                         2 ^ height_tree (Node x1 x2 x3 x4)", "apply (frule tree_rank_estimate)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x3 x4.\n       \\<lbrakk>tree_invar (Node x1 x2 x3 x4); t = Node x1 x2 x3 x4;\n        size (tree_to_multiset (Node x1 x2 x3 x4)) = 2 ^ x3\\<rbrakk>\n       \\<Longrightarrow> size (tree_to_multiset (Node x1 x2 x3 x4)) =\n                         2 ^ height_tree (Node x1 x2 x3 x4)", "apply (frule tree_rank_height)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x3 x4.\n       \\<lbrakk>tree_invar (Node x1 x2 x3 x4); t = Node x1 x2 x3 x4;\n        size (tree_to_multiset (Node x1 x2 x3 x4)) = 2 ^ x3;\n        height_tree (Node x1 x2 x3 x4) = x3\\<rbrakk>\n       \\<Longrightarrow> size (tree_to_multiset (Node x1 x2 x3 x4)) =\n                         2 ^ height_tree (Node x1 x2 x3 x4)", "apply (simp only: )"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*lemma size_mset_tree_Node: \"tree_invar (Node e a r ts) \\<Longrightarrow> \n  size (tree_to_multiset (Node e a r ts)) = (2::nat)^r\"\n  apply(induct r arbitrary: e a ts, simp)\nproof -\n  case goal1\n  from goal1(2) obtain e1 a1 ts1 e2 a2 ts2 where link:\n    \"(Node e a (Suc r) ts) = link (Node e1 a1 r ts1) (Node e2 a2 r ts2)\"\n    and inv1: \"tree_invar (Node e1 a1 r ts1) \"\n    and inv2: \"tree_invar (Node e2 a2 r ts2)\" by simp blast\n  from link_length[of \"(Node e1 a1 r ts1)\" \"(Node e2 a2 r ts2)\"]\n    goal1(1)[OF inv1] goal1(1)[OF inv2] link\n  show ?case by simp\nqed*)"], ["", "lemma size_mset_tree: \"tree_invar t \\<Longrightarrow> \n  size (tree_to_multiset t) = (2::nat)^(rank t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tree_invar t \\<Longrightarrow> size (tree_to_multiset t) = 2 ^ rank t", "by (cases t) (simp only: tree_rank_estimate BinomialTree.sel(3))"], ["", "lemma invar_butlast: \"invar (bq @ [t]) \\<Longrightarrow> invar bq\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invar (bq @ [t]) \\<Longrightarrow> invar bq", "unfolding invar_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. queue_invar (bq @ [t]) \\<and> rank_invar (bq @ [t]) \\<Longrightarrow>\n    queue_invar bq \\<and> rank_invar bq", "apply (induct bq)"], ["proof (prove)\ngoal (2 subgoals):\n 1. queue_invar ([] @ [t]) \\<and> rank_invar ([] @ [t]) \\<Longrightarrow>\n    queue_invar [] \\<and> rank_invar []\n 2. \\<And>a bq.\n       \\<lbrakk>queue_invar (bq @ [t]) \\<and>\n                rank_invar (bq @ [t]) \\<Longrightarrow>\n                queue_invar bq \\<and> rank_invar bq;\n        queue_invar ((a # bq) @ [t]) \\<and>\n        rank_invar ((a # bq) @ [t])\\<rbrakk>\n       \\<Longrightarrow> queue_invar (a # bq) \\<and> rank_invar (a # bq)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a bq.\n       \\<lbrakk>queue_invar (bq @ [t]) \\<and>\n                rank_invar (bq @ [t]) \\<Longrightarrow>\n                queue_invar bq \\<and> rank_invar bq;\n        queue_invar ((a # bq) @ [t]) \\<and>\n        rank_invar ((a # bq) @ [t])\\<rbrakk>\n       \\<Longrightarrow> queue_invar (a # bq) \\<and> rank_invar (a # bq)", "apply (case_tac bq)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a bq.\n       \\<lbrakk>queue_invar (bq @ [t]) \\<and>\n                rank_invar (bq @ [t]) \\<Longrightarrow>\n                queue_invar bq \\<and> rank_invar bq;\n        queue_invar ((a # bq) @ [t]) \\<and> rank_invar ((a # bq) @ [t]);\n        bq = []\\<rbrakk>\n       \\<Longrightarrow> queue_invar (a # bq) \\<and> rank_invar (a # bq)\n 2. \\<And>a bq aa list.\n       \\<lbrakk>queue_invar (bq @ [t]) \\<and>\n                rank_invar (bq @ [t]) \\<Longrightarrow>\n                queue_invar bq \\<and> rank_invar bq;\n        queue_invar ((a # bq) @ [t]) \\<and> rank_invar ((a # bq) @ [t]);\n        bq = aa # list\\<rbrakk>\n       \\<Longrightarrow> queue_invar (a # bq) \\<and> rank_invar (a # bq)", "by (simp_all)"], ["", "lemma invar_last_max: \"invar (bq @ [m]) \\<Longrightarrow> \\<forall> t \\<in> set bq. rank t < rank m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invar (bq @ [m]) \\<Longrightarrow>\n    \\<forall>t\\<in>set bq. rank t < rank m", "unfolding invar_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. queue_invar (bq @ [m]) \\<and> rank_invar (bq @ [m]) \\<Longrightarrow>\n    \\<forall>t\\<in>set bq. rank t < rank m", "apply (induct bq)"], ["proof (prove)\ngoal (2 subgoals):\n 1. queue_invar ([] @ [m]) \\<and> rank_invar ([] @ [m]) \\<Longrightarrow>\n    \\<forall>t\\<in>set []. rank t < rank m\n 2. \\<And>a bq.\n       \\<lbrakk>queue_invar (bq @ [m]) \\<and>\n                rank_invar (bq @ [m]) \\<Longrightarrow>\n                \\<forall>t\\<in>set bq. rank t < rank m;\n        queue_invar ((a # bq) @ [m]) \\<and>\n        rank_invar ((a # bq) @ [m])\\<rbrakk>\n       \\<Longrightarrow> \\<forall>t\\<in>set (a # bq). rank t < rank m", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a bq.\n       \\<lbrakk>queue_invar (bq @ [m]) \\<and>\n                rank_invar (bq @ [m]) \\<Longrightarrow>\n                \\<forall>t\\<in>set bq. rank t < rank m;\n        queue_invar ((a # bq) @ [m]) \\<and>\n        rank_invar ((a # bq) @ [m])\\<rbrakk>\n       \\<Longrightarrow> \\<forall>t\\<in>set (a # bq). rank t < rank m", "apply (case_tac bq)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a bq.\n       \\<lbrakk>queue_invar (bq @ [m]) \\<and>\n                rank_invar (bq @ [m]) \\<Longrightarrow>\n                \\<forall>t\\<in>set bq. rank t < rank m;\n        queue_invar ((a # bq) @ [m]) \\<and> rank_invar ((a # bq) @ [m]);\n        bq = []\\<rbrakk>\n       \\<Longrightarrow> \\<forall>t\\<in>set (a # bq). rank t < rank m\n 2. \\<And>a bq aa list.\n       \\<lbrakk>queue_invar (bq @ [m]) \\<and>\n                rank_invar (bq @ [m]) \\<Longrightarrow>\n                \\<forall>t\\<in>set bq. rank t < rank m;\n        queue_invar ((a # bq) @ [m]) \\<and> rank_invar ((a # bq) @ [m]);\n        bq = aa # list\\<rbrakk>\n       \\<Longrightarrow> \\<forall>t\\<in>set (a # bq). rank t < rank m", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a bq aa list.\n       \\<lbrakk>queue_invar (bq @ [m]) \\<and>\n                rank_invar (bq @ [m]) \\<Longrightarrow>\n                \\<forall>t\\<in>set bq. rank t < rank m;\n        queue_invar ((a # bq) @ [m]) \\<and> rank_invar ((a # bq) @ [m]);\n        bq = aa # list\\<rbrakk>\n       \\<Longrightarrow> \\<forall>t\\<in>set (a # bq). rank t < rank m", "by simp"], ["", "lemma invar_length: \"invar bq \\<Longrightarrow> length bq \\<le> Suc (rank (last bq))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invar bq \\<Longrightarrow> length bq \\<le> Suc (rank (last bq))", "proof (induct bq rule: rev_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. invar [] \\<Longrightarrow> length [] \\<le> Suc (rank (last []))\n 2. \\<And>x xs.\n       \\<lbrakk>invar xs \\<Longrightarrow>\n                length xs \\<le> Suc (rank (last xs));\n        invar (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> length (xs @ [x])\n                         \\<le> Suc (rank (last (xs @ [x])))", "case Nil"], ["proof (state)\nthis:\n  invar []\n\ngoal (2 subgoals):\n 1. invar [] \\<Longrightarrow> length [] \\<le> Suc (rank (last []))\n 2. \\<And>x xs.\n       \\<lbrakk>invar xs \\<Longrightarrow>\n                length xs \\<le> Suc (rank (last xs));\n        invar (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> length (xs @ [x])\n                         \\<le> Suc (rank (last (xs @ [x])))", "thus ?case"], ["proof (prove)\nusing this:\n  invar []\n\ngoal (1 subgoal):\n 1. length [] \\<le> Suc (rank (last []))", "by simp"], ["proof (state)\nthis:\n  length [] \\<le> Suc (rank (last []))\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>invar xs \\<Longrightarrow>\n                length xs \\<le> Suc (rank (last xs));\n        invar (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> length (xs @ [x])\n                         \\<le> Suc (rank (last (xs @ [x])))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>invar xs \\<Longrightarrow>\n                length xs \\<le> Suc (rank (last xs));\n        invar (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> length (xs @ [x])\n                         \\<le> Suc (rank (last (xs @ [x])))", "case (snoc x xs)"], ["proof (state)\nthis:\n  invar xs \\<Longrightarrow> length xs \\<le> Suc (rank (last xs))\n  invar (xs @ [x])\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>invar xs \\<Longrightarrow>\n                length xs \\<le> Suc (rank (last xs));\n        invar (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> length (xs @ [x])\n                         \\<le> Suc (rank (last (xs @ [x])))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (xs @ [x]) \\<le> Suc (rank (last (xs @ [x])))", "proof (cases xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    length (xs @ [x]) \\<le> Suc (rank (last (xs @ [x])))\n 2. \\<And>a list.\n       xs = a # list \\<Longrightarrow>\n       length (xs @ [x]) \\<le> Suc (rank (last (xs @ [x])))", "case Nil"], ["proof (state)\nthis:\n  xs = []\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    length (xs @ [x]) \\<le> Suc (rank (last (xs @ [x])))\n 2. \\<And>a list.\n       xs = a # list \\<Longrightarrow>\n       length (xs @ [x]) \\<le> Suc (rank (last (xs @ [x])))", "thus ?thesis"], ["proof (prove)\nusing this:\n  xs = []\n\ngoal (1 subgoal):\n 1. length (xs @ [x]) \\<le> Suc (rank (last (xs @ [x])))", "by simp"], ["proof (state)\nthis:\n  length (xs @ [x]) \\<le> Suc (rank (last (xs @ [x])))\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       xs = a # list \\<Longrightarrow>\n       length (xs @ [x]) \\<le> Suc (rank (last (xs @ [x])))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       xs = a # list \\<Longrightarrow>\n       length (xs @ [x]) \\<le> Suc (rank (last (xs @ [x])))", "case [simp]: (Cons xxs xx)"], ["proof (state)\nthis:\n  xs = xxs # xx\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       xs = a # list \\<Longrightarrow>\n       length (xs @ [x]) \\<le> Suc (rank (last (xs @ [x])))", "from snoc.hyps[OF invar_butlast[OF snoc.prems]]"], ["proof (chain)\npicking this:\n  length xs \\<le> Suc (rank (last xs))", "have\n      IH: \"length xs \\<le> Suc (rank (last xs))\""], ["proof (prove)\nusing this:\n  length xs \\<le> Suc (rank (last xs))\n\ngoal (1 subgoal):\n 1. length xs \\<le> Suc (rank (last xs))", "."], ["proof (state)\nthis:\n  length xs \\<le> Suc (rank (last xs))\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       xs = a # list \\<Longrightarrow>\n       length (xs @ [x]) \\<le> Suc (rank (last (xs @ [x])))", "also"], ["proof (state)\nthis:\n  length xs \\<le> Suc (rank (last xs))\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       xs = a # list \\<Longrightarrow>\n       length (xs @ [x]) \\<le> Suc (rank (last (xs @ [x])))", "from invar_last_max[OF snoc.prems] last_in_set[of xs]"], ["proof (chain)\npicking this:\n  \\<forall>t\\<in>set xs. rank t < rank x\n  xs \\<noteq> [] \\<Longrightarrow> last xs \\<in> set xs", "have\n      \"Suc (rank (last xs)) \\<le> rank (last (xs @ [x]))\""], ["proof (prove)\nusing this:\n  \\<forall>t\\<in>set xs. rank t < rank x\n  xs \\<noteq> [] \\<Longrightarrow> last xs \\<in> set xs\n\ngoal (1 subgoal):\n 1. Suc (rank (last xs)) \\<le> rank (last (xs @ [x]))", "by auto"], ["proof (state)\nthis:\n  Suc (rank (last xs)) \\<le> rank (last (xs @ [x]))\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       xs = a # list \\<Longrightarrow>\n       length (xs @ [x]) \\<le> Suc (rank (last (xs @ [x])))", "finally"], ["proof (chain)\npicking this:\n  length xs \\<le> rank (last (xs @ [x]))", "show ?thesis"], ["proof (prove)\nusing this:\n  length xs \\<le> rank (last (xs @ [x]))\n\ngoal (1 subgoal):\n 1. length (xs @ [x]) \\<le> Suc (rank (last (xs @ [x])))", "by simp"], ["proof (state)\nthis:\n  length (xs @ [x]) \\<le> Suc (rank (last (xs @ [x])))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  length (xs @ [x]) \\<le> Suc (rank (last (xs @ [x])))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma size_queue_sum_list: \n  \"size (queue_to_multiset bq) = sum_list (map (size \\<circ> tree_to_multiset) bq)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. size (queue_to_multiset bq) =\n    sum_list (map (size \\<circ> tree_to_multiset) bq)", "by (induct bq) simp_all"], ["", "text \\<open>\n  A binomial heap of length $l$ contains at least $2^l - 1$ elements. \n\\<close>"], ["", "theorem queue_length_estimate_lower: \n  \"invar bq \\<Longrightarrow> (size (queue_to_multiset bq)) \\<ge> 2^(length bq) - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invar bq \\<Longrightarrow>\n    2 ^ length bq - 1 \\<le> size (queue_to_multiset bq)", "proof (induct bq rule: rev_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. invar [] \\<Longrightarrow>\n    2 ^ length [] - 1 \\<le> size (queue_to_multiset [])\n 2. \\<And>x xs.\n       \\<lbrakk>invar xs \\<Longrightarrow>\n                2 ^ length xs - 1 \\<le> size (queue_to_multiset xs);\n        invar (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> 2 ^ length (xs @ [x]) - 1\n                         \\<le> size (queue_to_multiset (xs @ [x]))", "case Nil"], ["proof (state)\nthis:\n  invar []\n\ngoal (2 subgoals):\n 1. invar [] \\<Longrightarrow>\n    2 ^ length [] - 1 \\<le> size (queue_to_multiset [])\n 2. \\<And>x xs.\n       \\<lbrakk>invar xs \\<Longrightarrow>\n                2 ^ length xs - 1 \\<le> size (queue_to_multiset xs);\n        invar (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> 2 ^ length (xs @ [x]) - 1\n                         \\<le> size (queue_to_multiset (xs @ [x]))", "thus ?case"], ["proof (prove)\nusing this:\n  invar []\n\ngoal (1 subgoal):\n 1. 2 ^ length [] - 1 \\<le> size (queue_to_multiset [])", "by simp"], ["proof (state)\nthis:\n  2 ^ length [] - 1 \\<le> size (queue_to_multiset [])\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>invar xs \\<Longrightarrow>\n                2 ^ length xs - 1 \\<le> size (queue_to_multiset xs);\n        invar (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> 2 ^ length (xs @ [x]) - 1\n                         \\<le> size (queue_to_multiset (xs @ [x]))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>invar xs \\<Longrightarrow>\n                2 ^ length xs - 1 \\<le> size (queue_to_multiset xs);\n        invar (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> 2 ^ length (xs @ [x]) - 1\n                         \\<le> size (queue_to_multiset (xs @ [x]))", "case (snoc x xs)"], ["proof (state)\nthis:\n  invar xs \\<Longrightarrow>\n  2 ^ length xs - 1 \\<le> size (queue_to_multiset xs)\n  invar (xs @ [x])\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>invar xs \\<Longrightarrow>\n                2 ^ length xs - 1 \\<le> size (queue_to_multiset xs);\n        invar (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> 2 ^ length (xs @ [x]) - 1\n                         \\<le> size (queue_to_multiset (xs @ [x]))", "from snoc.hyps[OF invar_butlast[OF snoc.prems]]"], ["proof (chain)\npicking this:\n  2 ^ length xs - 1 \\<le> size (queue_to_multiset xs)", "have IH: \"2 ^ length xs \\<le> Suc (size (queue_to_multiset xs))\""], ["proof (prove)\nusing this:\n  2 ^ length xs - 1 \\<le> size (queue_to_multiset xs)\n\ngoal (1 subgoal):\n 1. 2 ^ length xs \\<le> Suc (size (queue_to_multiset xs))", "by simp"], ["proof (state)\nthis:\n  2 ^ length xs \\<le> Suc (size (queue_to_multiset xs))\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>invar xs \\<Longrightarrow>\n                2 ^ length xs - 1 \\<le> size (queue_to_multiset xs);\n        invar (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> 2 ^ length (xs @ [x]) - 1\n                         \\<le> size (queue_to_multiset (xs @ [x]))", "have size_q: \n    \"size (queue_to_multiset (xs @ [x])) = \n    size (queue_to_multiset xs) + size (tree_to_multiset x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. size (queue_to_multiset (xs @ [x])) =\n    size (queue_to_multiset xs) + size (tree_to_multiset x)", "by (simp add: size_queue_sum_list)"], ["proof (state)\nthis:\n  size (queue_to_multiset (xs @ [x])) =\n  size (queue_to_multiset xs) + size (tree_to_multiset x)\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>invar xs \\<Longrightarrow>\n                2 ^ length xs - 1 \\<le> size (queue_to_multiset xs);\n        invar (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> 2 ^ length (xs @ [x]) - 1\n                         \\<le> size (queue_to_multiset (xs @ [x]))", "also"], ["proof (state)\nthis:\n  size (queue_to_multiset (xs @ [x])) =\n  size (queue_to_multiset xs) + size (tree_to_multiset x)\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>invar xs \\<Longrightarrow>\n                2 ^ length xs - 1 \\<le> size (queue_to_multiset xs);\n        invar (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> 2 ^ length (xs @ [x]) - 1\n                         \\<le> size (queue_to_multiset (xs @ [x]))", "from snoc.prems"], ["proof (chain)\npicking this:\n  invar (xs @ [x])", "have inv_x: \"tree_invar x\""], ["proof (prove)\nusing this:\n  invar (xs @ [x])\n\ngoal (1 subgoal):\n 1. tree_invar x", "by (simp add: invar_def)"], ["proof (state)\nthis:\n  tree_invar x\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>invar xs \\<Longrightarrow>\n                2 ^ length xs - 1 \\<le> size (queue_to_multiset xs);\n        invar (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> 2 ^ length (xs @ [x]) - 1\n                         \\<le> size (queue_to_multiset (xs @ [x]))", "hence \"size (tree_to_multiset x) = 2 ^ rank x\""], ["proof (prove)\nusing this:\n  tree_invar x\n\ngoal (1 subgoal):\n 1. size (tree_to_multiset x) = 2 ^ rank x", "by (simp add: size_mset_tree)"], ["proof (state)\nthis:\n  size (tree_to_multiset x) = 2 ^ rank x\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>invar xs \\<Longrightarrow>\n                2 ^ length xs - 1 \\<le> size (queue_to_multiset xs);\n        invar (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> 2 ^ length (xs @ [x]) - 1\n                         \\<le> size (queue_to_multiset (xs @ [x]))", "finally"], ["proof (chain)\npicking this:\n  size (queue_to_multiset (xs @ [x])) =\n  size (queue_to_multiset xs) + 2 ^ rank x", "have \n    eq: \"size (queue_to_multiset (xs @ [x])) = \n         size (queue_to_multiset xs) + (2::nat)^(rank x)\""], ["proof (prove)\nusing this:\n  size (queue_to_multiset (xs @ [x])) =\n  size (queue_to_multiset xs) + 2 ^ rank x\n\ngoal (1 subgoal):\n 1. size (queue_to_multiset (xs @ [x])) =\n    size (queue_to_multiset xs) + 2 ^ rank x", "."], ["proof (state)\nthis:\n  size (queue_to_multiset (xs @ [x])) =\n  size (queue_to_multiset xs) + 2 ^ rank x\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>invar xs \\<Longrightarrow>\n                2 ^ length xs - 1 \\<le> size (queue_to_multiset xs);\n        invar (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> 2 ^ length (xs @ [x]) - 1\n                         \\<le> size (queue_to_multiset (xs @ [x]))", "from invar_length[OF snoc.prems]"], ["proof (chain)\npicking this:\n  length (xs @ [x]) \\<le> Suc (rank (last (xs @ [x])))", "have \"length xs \\<le> rank x\""], ["proof (prove)\nusing this:\n  length (xs @ [x]) \\<le> Suc (rank (last (xs @ [x])))\n\ngoal (1 subgoal):\n 1. length xs \\<le> rank x", "by simp"], ["proof (state)\nthis:\n  length xs \\<le> rank x\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>invar xs \\<Longrightarrow>\n                2 ^ length xs - 1 \\<le> size (queue_to_multiset xs);\n        invar (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> 2 ^ length (xs @ [x]) - 1\n                         \\<le> size (queue_to_multiset (xs @ [x]))", "hence snd: \"(2::nat) ^ length xs \\<le> (2::nat) ^ rank x\""], ["proof (prove)\nusing this:\n  length xs \\<le> rank x\n\ngoal (1 subgoal):\n 1. 2 ^ length xs \\<le> 2 ^ rank x", "by simp"], ["proof (state)\nthis:\n  2 ^ length xs \\<le> 2 ^ rank x\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>invar xs \\<Longrightarrow>\n                2 ^ length xs - 1 \\<le> size (queue_to_multiset xs);\n        invar (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> 2 ^ length (xs @ [x]) - 1\n                         \\<le> size (queue_to_multiset (xs @ [x]))", "have\n    \"(2::nat) ^ length (xs @ [x]) = (2::nat) ^ (length xs) + (2::nat) ^ (length xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ length (xs @ [x]) = 2 ^ length xs + 2 ^ length xs", "by simp"], ["proof (state)\nthis:\n  2 ^ length (xs @ [x]) = 2 ^ length xs + 2 ^ length xs\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>invar xs \\<Longrightarrow>\n                2 ^ length xs - 1 \\<le> size (queue_to_multiset xs);\n        invar (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> 2 ^ length (xs @ [x]) - 1\n                         \\<le> size (queue_to_multiset (xs @ [x]))", "with IH"], ["proof (chain)\npicking this:\n  2 ^ length xs \\<le> Suc (size (queue_to_multiset xs))\n  2 ^ length (xs @ [x]) = 2 ^ length xs + 2 ^ length xs", "have \n    \"2 ^ length (xs @ [x]) \\<le> Suc (size (queue_to_multiset xs)) + 2 ^ length xs\""], ["proof (prove)\nusing this:\n  2 ^ length xs \\<le> Suc (size (queue_to_multiset xs))\n  2 ^ length (xs @ [x]) = 2 ^ length xs + 2 ^ length xs\n\ngoal (1 subgoal):\n 1. 2 ^ length (xs @ [x])\n    \\<le> Suc (size (queue_to_multiset xs)) + 2 ^ length xs", "by simp"], ["proof (state)\nthis:\n  2 ^ length (xs @ [x])\n  \\<le> Suc (size (queue_to_multiset xs)) + 2 ^ length xs\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>invar xs \\<Longrightarrow>\n                2 ^ length xs - 1 \\<le> size (queue_to_multiset xs);\n        invar (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> 2 ^ length (xs @ [x]) - 1\n                         \\<le> size (queue_to_multiset (xs @ [x]))", "with snd"], ["proof (chain)\npicking this:\n  2 ^ length xs \\<le> 2 ^ rank x\n  2 ^ length (xs @ [x])\n  \\<le> Suc (size (queue_to_multiset xs)) + 2 ^ length xs", "have \"2 ^ length (xs @ [x]) \\<le> \n    Suc (size (queue_to_multiset xs)) + 2 ^ rank x\""], ["proof (prove)\nusing this:\n  2 ^ length xs \\<le> 2 ^ rank x\n  2 ^ length (xs @ [x])\n  \\<le> Suc (size (queue_to_multiset xs)) + 2 ^ length xs\n\ngoal (1 subgoal):\n 1. 2 ^ length (xs @ [x])\n    \\<le> Suc (size (queue_to_multiset xs)) + 2 ^ rank x", "by arith"], ["proof (state)\nthis:\n  2 ^ length (xs @ [x]) \\<le> Suc (size (queue_to_multiset xs)) + 2 ^ rank x\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>invar xs \\<Longrightarrow>\n                2 ^ length xs - 1 \\<le> size (queue_to_multiset xs);\n        invar (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> 2 ^ length (xs @ [x]) - 1\n                         \\<le> size (queue_to_multiset (xs @ [x]))", "with eq"], ["proof (chain)\npicking this:\n  size (queue_to_multiset (xs @ [x])) =\n  size (queue_to_multiset xs) + 2 ^ rank x\n  2 ^ length (xs @ [x]) \\<le> Suc (size (queue_to_multiset xs)) + 2 ^ rank x", "show ?case"], ["proof (prove)\nusing this:\n  size (queue_to_multiset (xs @ [x])) =\n  size (queue_to_multiset xs) + 2 ^ rank x\n  2 ^ length (xs @ [x]) \\<le> Suc (size (queue_to_multiset xs)) + 2 ^ rank x\n\ngoal (1 subgoal):\n 1. 2 ^ length (xs @ [x]) - 1 \\<le> size (queue_to_multiset (xs @ [x]))", "by simp"], ["proof (state)\nthis:\n  2 ^ length (xs @ [x]) - 1 \\<le> size (queue_to_multiset (xs @ [x]))\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Operations\\<close>"], ["", "subsubsection \"Empty\""], ["", "lemma empty_correct[simp]: \n  \"invar Nil\"\n  \"queue_to_multiset Nil = {#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invar [] &&& queue_to_multiset [] = {#}", "by (simp_all add: invar_def)"], ["", "text \\<open>The empty multiset is represented by exactly the empty queue\\<close>"], ["", "lemma empty_iff: \"t=Nil \\<longleftrightarrow> queue_to_multiset t = {#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (t = []) = (queue_to_multiset t = {#})", "apply (cases t)"], ["proof (prove)\ngoal (2 subgoals):\n 1. t = [] \\<Longrightarrow> (t = []) = (queue_to_multiset t = {#})\n 2. \\<And>a list.\n       t = a # list \\<Longrightarrow> (t = []) = (queue_to_multiset t = {#})", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>t = a # list; tree_to_multiset a = {#};\n        queue_to_multiset list = {#}\\<rbrakk>\n       \\<Longrightarrow> False", "apply (case_tac a)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a list x1 x2 x3 x4.\n       \\<lbrakk>t = a # list; tree_to_multiset a = {#};\n        queue_to_multiset list = {#}; a = Node x1 x2 x3 x4\\<rbrakk>\n       \\<Longrightarrow> False", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsubsection \"Insert\""], ["", "text \\<open>Inserts a binomial tree into a binomial queue, such that the queue \n  does not contain two trees of same rank.\\<close>"], ["", "fun  ins :: \"('e, 'a::linorder) BinomialTree \\<Rightarrow> ('e, 'a) BinomialQueue_inv \\<Rightarrow> \n  ('e, 'a) BinomialQueue_inv\" where\n  \"ins t [] = [t]\" |\n  \"ins t' (t # bq) = (if (rank t') < (rank t) \n    then t' # t # bq \n    else (if (rank t) < (rank t') \n            then t # (ins t' bq)       \n            else ins (link t' t) bq))\""], ["", "text \\<open>Inserts an element with priority into the queue.\\<close>"], ["", "definition insert :: \"'e \\<Rightarrow> 'a::linorder \\<Rightarrow> ('e, 'a) BinomialQueue_inv \\<Rightarrow> \n  ('e, 'a) BinomialQueue_inv\" where\n  \"insert e a bq = ins (Node e a 0 []) bq\""], ["", "lemma ins_mset:\n  \"\\<lbrakk>tree_invar t; queue_invar q\\<rbrakk> \\<Longrightarrow> queue_to_multiset (ins t q) \n   = tree_to_multiset t + queue_to_multiset q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>tree_invar t; queue_invar q\\<rbrakk>\n    \\<Longrightarrow> queue_to_multiset (ins t q) =\n                      tree_to_multiset t + queue_to_multiset q", "by (induct q arbitrary: t) (auto simp: union_ac link_tree_invar)"], ["", "lemma insert_mset: \"queue_invar q \\<Longrightarrow>\n  queue_to_multiset (insert e a q) = queue_to_multiset q + {# (e,a) #}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. queue_invar q \\<Longrightarrow>\n    queue_to_multiset (local.insert e a q) =\n    queue_to_multiset q + {#(e, a)#}", "by(simp add: ins_mset union_ac insert_def)"], ["", "lemma ins_queue_invar: \"\\<lbrakk>tree_invar t; queue_invar q\\<rbrakk> \\<Longrightarrow> queue_invar (ins t q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>tree_invar t; queue_invar q\\<rbrakk>\n    \\<Longrightarrow> queue_invar (ins t q)", "proof (induct q arbitrary: t)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>t.\n       \\<lbrakk>tree_invar t; queue_invar []\\<rbrakk>\n       \\<Longrightarrow> queue_invar (ins t [])\n 2. \\<And>a q t.\n       \\<lbrakk>\\<And>t.\n                   \\<lbrakk>tree_invar t; queue_invar q\\<rbrakk>\n                   \\<Longrightarrow> queue_invar (ins t q);\n        tree_invar t; queue_invar (a # q)\\<rbrakk>\n       \\<Longrightarrow> queue_invar (ins t (a # q))", "case (Cons a q)"], ["proof (state)\nthis:\n  \\<lbrakk>tree_invar ?t; queue_invar q\\<rbrakk>\n  \\<Longrightarrow> queue_invar (ins ?t q)\n  tree_invar t\n  queue_invar (a # q)\n\ngoal (2 subgoals):\n 1. \\<And>t.\n       \\<lbrakk>tree_invar t; queue_invar []\\<rbrakk>\n       \\<Longrightarrow> queue_invar (ins t [])\n 2. \\<And>a q t.\n       \\<lbrakk>\\<And>t.\n                   \\<lbrakk>tree_invar t; queue_invar q\\<rbrakk>\n                   \\<Longrightarrow> queue_invar (ins t q);\n        tree_invar t; queue_invar (a # q)\\<rbrakk>\n       \\<Longrightarrow> queue_invar (ins t (a # q))", "note iv = Cons.hyps"], ["proof (state)\nthis:\n  \\<lbrakk>tree_invar ?t; queue_invar q\\<rbrakk>\n  \\<Longrightarrow> queue_invar (ins ?t q)\n\ngoal (2 subgoals):\n 1. \\<And>t.\n       \\<lbrakk>tree_invar t; queue_invar []\\<rbrakk>\n       \\<Longrightarrow> queue_invar (ins t [])\n 2. \\<And>a q t.\n       \\<lbrakk>\\<And>t.\n                   \\<lbrakk>tree_invar t; queue_invar q\\<rbrakk>\n                   \\<Longrightarrow> queue_invar (ins t q);\n        tree_invar t; queue_invar (a # q)\\<rbrakk>\n       \\<Longrightarrow> queue_invar (ins t (a # q))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. queue_invar (ins t (a # q))", "proof (cases \"rank t = rank a\")"], ["proof (state)\ngoal (2 subgoals):\n 1. rank t = rank a \\<Longrightarrow> queue_invar (ins t (a # q))\n 2. rank t \\<noteq> rank a \\<Longrightarrow> queue_invar (ins t (a # q))", "case [simp]: True"], ["proof (state)\nthis:\n  rank t = rank a\n\ngoal (2 subgoals):\n 1. rank t = rank a \\<Longrightarrow> queue_invar (ins t (a # q))\n 2. rank t \\<noteq> rank a \\<Longrightarrow> queue_invar (ins t (a # q))", "from Cons.prems"], ["proof (chain)\npicking this:\n  tree_invar t\n  queue_invar (a # q)", "have \n      inv_a: \"tree_invar a\" and inv_q: \"queue_invar q\""], ["proof (prove)\nusing this:\n  tree_invar t\n  queue_invar (a # q)\n\ngoal (1 subgoal):\n 1. tree_invar a &&& queue_invar q", "by (simp_all)"], ["proof (state)\nthis:\n  tree_invar a\n  queue_invar q\n\ngoal (2 subgoals):\n 1. rank t = rank a \\<Longrightarrow> queue_invar (ins t (a # q))\n 2. rank t \\<noteq> rank a \\<Longrightarrow> queue_invar (ins t (a # q))", "note inv_link = link_tree_invar[OF \\<open>tree_invar t\\<close> inv_a True]"], ["proof (state)\nthis:\n  tree_invar (link t a)\n\ngoal (2 subgoals):\n 1. rank t = rank a \\<Longrightarrow> queue_invar (ins t (a # q))\n 2. rank t \\<noteq> rank a \\<Longrightarrow> queue_invar (ins t (a # q))", "from iv[OF inv_link inv_q]"], ["proof (chain)\npicking this:\n  queue_invar (ins (link t a) q)", "show ?thesis"], ["proof (prove)\nusing this:\n  queue_invar (ins (link t a) q)\n\ngoal (1 subgoal):\n 1. queue_invar (ins t (a # q))", "by simp"], ["proof (state)\nthis:\n  queue_invar (ins t (a # q))\n\ngoal (1 subgoal):\n 1. rank t \\<noteq> rank a \\<Longrightarrow> queue_invar (ins t (a # q))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. rank t \\<noteq> rank a \\<Longrightarrow> queue_invar (ins t (a # q))", "case False"], ["proof (state)\nthis:\n  rank t \\<noteq> rank a\n\ngoal (1 subgoal):\n 1. rank t \\<noteq> rank a \\<Longrightarrow> queue_invar (ins t (a # q))", "with Cons"], ["proof (chain)\npicking this:\n  \\<lbrakk>tree_invar ?t; queue_invar q\\<rbrakk>\n  \\<Longrightarrow> queue_invar (ins ?t q)\n  tree_invar t\n  queue_invar (a # q)\n  rank t \\<noteq> rank a", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>tree_invar ?t; queue_invar q\\<rbrakk>\n  \\<Longrightarrow> queue_invar (ins ?t q)\n  tree_invar t\n  queue_invar (a # q)\n  rank t \\<noteq> rank a\n\ngoal (1 subgoal):\n 1. queue_invar (ins t (a # q))", "by auto"], ["proof (state)\nthis:\n  queue_invar (ins t (a # q))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  queue_invar (ins t (a # q))\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       \\<lbrakk>tree_invar t; queue_invar []\\<rbrakk>\n       \\<Longrightarrow> queue_invar (ins t [])", "qed simp"], ["", "lemma insert_queue_invar: \n  assumes \"queue_invar q\" \n  shows \"queue_invar (insert e a q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. queue_invar (local.insert e a q)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. queue_invar (local.insert e a q)", "have inv: \"tree_invar (Node e a 0 [])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tree_invar (Node e a 0 [])", "by simp"], ["proof (state)\nthis:\n  tree_invar (Node e a 0 [])\n\ngoal (1 subgoal):\n 1. queue_invar (local.insert e a q)", "from ins_queue_invar[OF inv assms]"], ["proof (chain)\npicking this:\n  queue_invar (ins (Node e a 0 []) q)", "show ?thesis"], ["proof (prove)\nusing this:\n  queue_invar (ins (Node e a 0 []) q)\n\ngoal (1 subgoal):\n 1. queue_invar (local.insert e a q)", "by (simp add: insert_def)"], ["proof (state)\nthis:\n  queue_invar (local.insert e a q)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma  rank_ins: \"(rank_invar (t # bq) \\<Longrightarrow> \n  (rank (hd (ins t' (t # bq))) \\<ge> rank t) \\<or> \n  (rank (hd (ins t' (t # bq))) \\<ge> rank t'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rank_invar (t # bq) \\<Longrightarrow>\n    rank t \\<le> rank (hd (ins t' (t # bq))) \\<or>\n    rank t' \\<le> rank (hd (ins t' (t # bq)))", "apply(auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>rank_invar (t # bq); rank t' = rank t\\<rbrakk>\n    \\<Longrightarrow> rank t \\<le> rank (hd (ins (link t' t) bq))", "apply(induct bq arbitrary: t t')"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>t t'.\n       \\<lbrakk>rank_invar [t]; rank t' = rank t\\<rbrakk>\n       \\<Longrightarrow> rank t \\<le> rank (hd (ins (link t' t) []))\n 2. \\<And>a bq t t'.\n       \\<lbrakk>\\<And>t t'.\n                   \\<lbrakk>rank_invar (t # bq); rank t' = rank t\\<rbrakk>\n                   \\<Longrightarrow> rank t\n                                     \\<le> rank (hd (ins (link t' t) bq));\n        rank_invar (t # a # bq); rank t' = rank t\\<rbrakk>\n       \\<Longrightarrow> rank t \\<le> rank (hd (ins (link t' t) (a # bq)))", "apply(simp add: rank_link)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a bq t t'.\n       \\<lbrakk>\\<And>t t'.\n                   \\<lbrakk>rank_invar (t # bq); rank t' = rank t\\<rbrakk>\n                   \\<Longrightarrow> rank t\n                                     \\<le> rank (hd (ins (link t' t) bq));\n        rank_invar (t # a # bq); rank t' = rank t\\<rbrakk>\n       \\<Longrightarrow> rank t \\<le> rank (hd (ins (link t' t) (a # bq)))", "proof goal_cases"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a bq t t'.\n       \\<lbrakk>\\<And>t t'.\n                   \\<lbrakk>rank_invar (t # bq); rank t' = rank t\\<rbrakk>\n                   \\<Longrightarrow> rank t\n                                     \\<le> rank (hd (ins (link t' t) bq));\n        rank_invar (t # a # bq); rank t' = rank t\\<rbrakk>\n       \\<Longrightarrow> rank t \\<le> rank (hd (ins (link t' t) (a # bq)))", "case prems: (1 a bq t t')"], ["proof (state)\nthis:\n  \\<lbrakk>rank_invar (?t # bq); rank ?t' = rank ?t\\<rbrakk>\n  \\<Longrightarrow> rank ?t \\<le> rank (hd (ins (link ?t' ?t) bq))\n  rank_invar (t # a # bq)\n  rank t' = rank t\n\ngoal (1 subgoal):\n 1. \\<And>a bq t t'.\n       \\<lbrakk>\\<And>t t'.\n                   \\<lbrakk>rank_invar (t # bq); rank t' = rank t\\<rbrakk>\n                   \\<Longrightarrow> rank t\n                                     \\<le> rank (hd (ins (link t' t) bq));\n        rank_invar (t # a # bq); rank t' = rank t\\<rbrakk>\n       \\<Longrightarrow> rank t \\<le> rank (hd (ins (link t' t) (a # bq)))", "thus ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>rank_invar (?t # bq); rank ?t' = rank ?t\\<rbrakk>\n  \\<Longrightarrow> rank ?t \\<le> rank (hd (ins (link ?t' ?t) bq))\n  rank_invar (t # a # bq)\n  rank t' = rank t\n\ngoal (1 subgoal):\n 1. rank t \\<le> rank (hd (ins (link t' t) (a # bq)))", "apply(cases \"rank (link t' t) = rank a\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>t t'.\n                \\<lbrakk>rank_invar (t # bq); rank t' = rank t\\<rbrakk>\n                \\<Longrightarrow> rank t\n                                  \\<le> rank (hd (ins (link t' t) bq));\n     rank_invar (t # a # bq); rank t' = rank t;\n     rank (link t' t) = rank a\\<rbrakk>\n    \\<Longrightarrow> rank t \\<le> rank (hd (ins (link t' t) (a # bq)))\n 2. \\<lbrakk>\\<And>t t'.\n                \\<lbrakk>rank_invar (t # bq); rank t' = rank t\\<rbrakk>\n                \\<Longrightarrow> rank t\n                                  \\<le> rank (hd (ins (link t' t) bq));\n     rank_invar (t # a # bq); rank t' = rank t;\n     rank (link t' t) \\<noteq> rank a\\<rbrakk>\n    \\<Longrightarrow> rank t \\<le> rank (hd (ins (link t' t) (a # bq)))", "apply(auto simp add: rank_link)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>t t'.\n                \\<lbrakk>rank_invar (t # bq); rank t' = rank t\\<rbrakk>\n                \\<Longrightarrow> rank t\n                                  \\<le> rank (hd (ins (link t' t) bq));\n     rank_invar (a # bq); rank t' = rank t; Suc (rank t) = rank a\\<rbrakk>\n    \\<Longrightarrow> rank t \\<le> rank (hd (ins (link (link t' t) a) bq))", "proof goal_cases"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>t t'.\n                \\<lbrakk>rank_invar (t # bq); rank t' = rank t\\<rbrakk>\n                \\<Longrightarrow> rank t\n                                  \\<le> rank (hd (ins (link t' t) bq));\n     rank_invar (a # bq); rank t' = rank t; Suc (rank t) = rank a\\<rbrakk>\n    \\<Longrightarrow> rank t \\<le> rank (hd (ins (link (link t' t) a) bq))", "case 1"], ["proof (state)\nthis:\n  \\<lbrakk>rank_invar (?t # bq); rank ?t' = rank ?t\\<rbrakk>\n  \\<Longrightarrow> rank ?t \\<le> rank (hd (ins (link ?t' ?t) bq))\n  rank_invar (a # bq)\n  rank t' = rank t\n  Suc (rank t) = rank a\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>t t'.\n                \\<lbrakk>rank_invar (t # bq); rank t' = rank t\\<rbrakk>\n                \\<Longrightarrow> rank t\n                                  \\<le> rank (hd (ins (link t' t) bq));\n     rank_invar (a # bq); rank t' = rank t; Suc (rank t) = rank a\\<rbrakk>\n    \\<Longrightarrow> rank t \\<le> rank (hd (ins (link (link t' t) a) bq))", "note * = this and \\<open>\\<And>t' t. \\<lbrakk>rank_invar (t # bq); rank t' = rank t\\<rbrakk>\n      \\<Longrightarrow> rank t \\<le> rank (hd (ins (link t' t) bq))\\<close>[of a \"(link t' t)\"]"], ["proof (state)\nthis:\n  \\<lbrakk>rank_invar (?t # bq); rank ?t' = rank ?t\\<rbrakk>\n  \\<Longrightarrow> rank ?t \\<le> rank (hd (ins (link ?t' ?t) bq))\n  rank_invar (a # bq)\n  rank t' = rank t\n  Suc (rank t) = rank a\n  \\<lbrakk>rank_invar (a # bq); rank (link t' t) = rank a\\<rbrakk>\n  \\<Longrightarrow> rank a \\<le> rank (hd (ins (link (link t' t) a) bq))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>t t'.\n                \\<lbrakk>rank_invar (t # bq); rank t' = rank t\\<rbrakk>\n                \\<Longrightarrow> rank t\n                                  \\<le> rank (hd (ins (link t' t) bq));\n     rank_invar (a # bq); rank t' = rank t; Suc (rank t) = rank a\\<rbrakk>\n    \\<Longrightarrow> rank t \\<le> rank (hd (ins (link (link t' t) a) bq))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. rank t \\<le> rank (hd (ins (link (link t' t) a) bq))", "proof (cases \"rank (hd (ins (link (link t' t) a) bq)) = rank a\")"], ["proof (state)\ngoal (2 subgoals):\n 1. rank (hd (ins (link (link t' t) a) bq)) = rank a \\<Longrightarrow>\n    rank t \\<le> rank (hd (ins (link (link t' t) a) bq))\n 2. rank (hd (ins (link (link t' t) a) bq)) \\<noteq>\n    rank a \\<Longrightarrow>\n    rank t \\<le> rank (hd (ins (link (link t' t) a) bq))", "case True"], ["proof (state)\nthis:\n  rank (hd (ins (link (link t' t) a) bq)) = rank a\n\ngoal (2 subgoals):\n 1. rank (hd (ins (link (link t' t) a) bq)) = rank a \\<Longrightarrow>\n    rank t \\<le> rank (hd (ins (link (link t' t) a) bq))\n 2. rank (hd (ins (link (link t' t) a) bq)) \\<noteq>\n    rank a \\<Longrightarrow>\n    rank t \\<le> rank (hd (ins (link (link t' t) a) bq))", "with *"], ["proof (chain)\npicking this:\n  \\<lbrakk>rank_invar (?t # bq); rank ?t' = rank ?t\\<rbrakk>\n  \\<Longrightarrow> rank ?t \\<le> rank (hd (ins (link ?t' ?t) bq))\n  rank_invar (a # bq)\n  rank t' = rank t\n  Suc (rank t) = rank a\n  rank (hd (ins (link (link t' t) a) bq)) = rank a", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>rank_invar (?t # bq); rank ?t' = rank ?t\\<rbrakk>\n  \\<Longrightarrow> rank ?t \\<le> rank (hd (ins (link ?t' ?t) bq))\n  rank_invar (a # bq)\n  rank t' = rank t\n  Suc (rank t) = rank a\n  rank (hd (ins (link (link t' t) a) bq)) = rank a\n\ngoal (1 subgoal):\n 1. rank t \\<le> rank (hd (ins (link (link t' t) a) bq))", "by simp"], ["proof (state)\nthis:\n  rank t \\<le> rank (hd (ins (link (link t' t) a) bq))\n\ngoal (1 subgoal):\n 1. rank (hd (ins (link (link t' t) a) bq)) \\<noteq>\n    rank a \\<Longrightarrow>\n    rank t \\<le> rank (hd (ins (link (link t' t) a) bq))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. rank (hd (ins (link (link t' t) a) bq)) \\<noteq>\n    rank a \\<Longrightarrow>\n    rank t \\<le> rank (hd (ins (link (link t' t) a) bq))", "case False"], ["proof (state)\nthis:\n  rank (hd (ins (link (link t' t) a) bq)) \\<noteq> rank a\n\ngoal (1 subgoal):\n 1. rank (hd (ins (link (link t' t) a) bq)) \\<noteq>\n    rank a \\<Longrightarrow>\n    rank t \\<le> rank (hd (ins (link (link t' t) a) bq))", "with *"], ["proof (chain)\npicking this:\n  \\<lbrakk>rank_invar (?t # bq); rank ?t' = rank ?t\\<rbrakk>\n  \\<Longrightarrow> rank ?t \\<le> rank (hd (ins (link ?t' ?t) bq))\n  rank_invar (a # bq)\n  rank t' = rank t\n  Suc (rank t) = rank a\n  rank (hd (ins (link (link t' t) a) bq)) \\<noteq> rank a", "have \"rank a \\<le> rank (hd (ins (link (link t' t) a) bq))\""], ["proof (prove)\nusing this:\n  \\<lbrakk>rank_invar (?t # bq); rank ?t' = rank ?t\\<rbrakk>\n  \\<Longrightarrow> rank ?t \\<le> rank (hd (ins (link ?t' ?t) bq))\n  rank_invar (a # bq)\n  rank t' = rank t\n  Suc (rank t) = rank a\n  rank (hd (ins (link (link t' t) a) bq)) \\<noteq> rank a\n\ngoal (1 subgoal):\n 1. rank a \\<le> rank (hd (ins (link (link t' t) a) bq))", "by (simp add: rank_link)"], ["proof (state)\nthis:\n  rank a \\<le> rank (hd (ins (link (link t' t) a) bq))\n\ngoal (1 subgoal):\n 1. rank (hd (ins (link (link t' t) a) bq)) \\<noteq>\n    rank a \\<Longrightarrow>\n    rank t \\<le> rank (hd (ins (link (link t' t) a) bq))", "with *"], ["proof (chain)\npicking this:\n  \\<lbrakk>rank_invar (?t # bq); rank ?t' = rank ?t\\<rbrakk>\n  \\<Longrightarrow> rank ?t \\<le> rank (hd (ins (link ?t' ?t) bq))\n  rank_invar (a # bq)\n  rank t' = rank t\n  Suc (rank t) = rank a\n  rank a \\<le> rank (hd (ins (link (link t' t) a) bq))", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>rank_invar (?t # bq); rank ?t' = rank ?t\\<rbrakk>\n  \\<Longrightarrow> rank ?t \\<le> rank (hd (ins (link ?t' ?t) bq))\n  rank_invar (a # bq)\n  rank t' = rank t\n  Suc (rank t) = rank a\n  rank a \\<le> rank (hd (ins (link (link t' t) a) bq))\n\ngoal (1 subgoal):\n 1. rank t \\<le> rank (hd (ins (link (link t' t) a) bq))", "by simp"], ["proof (state)\nthis:\n  rank t \\<le> rank (hd (ins (link (link t' t) a) bq))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  rank t \\<le> rank (hd (ins (link (link t' t) a) bq))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  rank t \\<le> rank (hd (ins (link t' t) (a # bq)))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rank_ins2: \"rank_invar bq \\<Longrightarrow> \n  rank t \\<le> rank (hd (ins t bq)) \\<or> \n  (rank (hd (ins t bq)) = rank (hd bq) \\<and> bq \\<noteq> [])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rank_invar bq \\<Longrightarrow>\n    rank t \\<le> rank (hd (ins t bq)) \\<or>\n    rank (hd (ins t bq)) = rank (hd bq) \\<and> bq \\<noteq> []", "apply(induct bq arbitrary: t)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>t.\n       rank_invar [] \\<Longrightarrow>\n       rank t \\<le> rank (hd (ins t [])) \\<or>\n       rank (hd (ins t [])) = rank (hd []) \\<and> [] \\<noteq> []\n 2. \\<And>a bq t.\n       \\<lbrakk>\\<And>t.\n                   rank_invar bq \\<Longrightarrow>\n                   rank t \\<le> rank (hd (ins t bq)) \\<or>\n                   rank (hd (ins t bq)) = rank (hd bq) \\<and>\n                   bq \\<noteq> [];\n        rank_invar (a # bq)\\<rbrakk>\n       \\<Longrightarrow> rank t \\<le> rank (hd (ins t (a # bq))) \\<or>\n                         rank (hd (ins t (a # bq))) =\n                         rank (hd (a # bq)) \\<and>\n                         a # bq \\<noteq> []", "apply(auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a bq t.\n       \\<lbrakk>\\<And>t.\n                   rank_invar bq \\<Longrightarrow>\n                   rank t \\<le> rank (hd (ins t bq)) \\<or>\n                   rank (hd (ins t bq)) = rank (hd bq) \\<and>\n                   bq \\<noteq> [];\n        rank_invar (a # bq); rank t = rank a;\n        rank (hd (ins (link t a) bq)) \\<noteq> rank a\\<rbrakk>\n       \\<Longrightarrow> rank a \\<le> rank (hd (ins (link t a) bq))", "proof goal_cases"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a bq t.\n       \\<lbrakk>\\<And>t.\n                   rank_invar bq \\<Longrightarrow>\n                   rank t \\<le> rank (hd (ins t bq)) \\<or>\n                   rank (hd (ins t bq)) = rank (hd bq) \\<and>\n                   bq \\<noteq> [];\n        rank_invar (a # bq); rank t = rank a;\n        rank (hd (ins (link t a) bq)) \\<noteq> rank a\\<rbrakk>\n       \\<Longrightarrow> rank a \\<le> rank (hd (ins (link t a) bq))", "case prems: (1 a bq t)"], ["proof (state)\nthis:\n  rank_invar bq \\<Longrightarrow>\n  rank ?t \\<le> rank (hd (ins ?t bq)) \\<or>\n  rank (hd (ins ?t bq)) = rank (hd bq) \\<and> bq \\<noteq> []\n  rank_invar (a # bq)\n  rank t = rank a\n  rank (hd (ins (link t a) bq)) \\<noteq> rank a\n\ngoal (1 subgoal):\n 1. \\<And>a bq t.\n       \\<lbrakk>\\<And>t.\n                   rank_invar bq \\<Longrightarrow>\n                   rank t \\<le> rank (hd (ins t bq)) \\<or>\n                   rank (hd (ins t bq)) = rank (hd bq) \\<and>\n                   bq \\<noteq> [];\n        rank_invar (a # bq); rank t = rank a;\n        rank (hd (ins (link t a) bq)) \\<noteq> rank a\\<rbrakk>\n       \\<Longrightarrow> rank a \\<le> rank (hd (ins (link t a) bq))", "hence r: \"rank (link t a) = rank a + 1\""], ["proof (prove)\nusing this:\n  rank_invar bq \\<Longrightarrow>\n  rank ?t \\<le> rank (hd (ins ?t bq)) \\<or>\n  rank (hd (ins ?t bq)) = rank (hd bq) \\<and> bq \\<noteq> []\n  rank_invar (a # bq)\n  rank t = rank a\n  rank (hd (ins (link t a) bq)) \\<noteq> rank a\n\ngoal (1 subgoal):\n 1. rank (link t a) = rank a + 1", "by (simp add: rank_link)"], ["proof (state)\nthis:\n  rank (link t a) = rank a + 1\n\ngoal (1 subgoal):\n 1. \\<And>a bq t.\n       \\<lbrakk>\\<And>t.\n                   rank_invar bq \\<Longrightarrow>\n                   rank t \\<le> rank (hd (ins t bq)) \\<or>\n                   rank (hd (ins t bq)) = rank (hd bq) \\<and>\n                   bq \\<noteq> [];\n        rank_invar (a # bq); rank t = rank a;\n        rank (hd (ins (link t a) bq)) \\<noteq> rank a\\<rbrakk>\n       \\<Longrightarrow> rank a \\<le> rank (hd (ins (link t a) bq))", "from prems r and prems(1)[of \"(link t a)\"]"], ["proof (chain)\npicking this:\n  rank_invar bq \\<Longrightarrow>\n  rank ?t \\<le> rank (hd (ins ?t bq)) \\<or>\n  rank (hd (ins ?t bq)) = rank (hd bq) \\<and> bq \\<noteq> []\n  rank_invar (a # bq)\n  rank t = rank a\n  rank (hd (ins (link t a) bq)) \\<noteq> rank a\n  rank (link t a) = rank a + 1\n  rank_invar bq \\<Longrightarrow>\n  rank (link t a) \\<le> rank (hd (ins (link t a) bq)) \\<or>\n  rank (hd (ins (link t a) bq)) = rank (hd bq) \\<and> bq \\<noteq> []", "show ?case"], ["proof (prove)\nusing this:\n  rank_invar bq \\<Longrightarrow>\n  rank ?t \\<le> rank (hd (ins ?t bq)) \\<or>\n  rank (hd (ins ?t bq)) = rank (hd bq) \\<and> bq \\<noteq> []\n  rank_invar (a # bq)\n  rank t = rank a\n  rank (hd (ins (link t a) bq)) \\<noteq> rank a\n  rank (link t a) = rank a + 1\n  rank_invar bq \\<Longrightarrow>\n  rank (link t a) \\<le> rank (hd (ins (link t a) bq)) \\<or>\n  rank (hd (ins (link t a) bq)) = rank (hd bq) \\<and> bq \\<noteq> []\n\ngoal (1 subgoal):\n 1. rank a \\<le> rank (hd (ins (link t a) bq))", "by (cases bq) auto"], ["proof (state)\nthis:\n  rank a \\<le> rank (hd (ins (link t a) bq))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rank_invar_ins: \"rank_invar bq \\<Longrightarrow> rank_invar (ins t bq)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rank_invar bq \\<Longrightarrow> rank_invar (ins t bq)", "apply(induct bq arbitrary: t)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>t. rank_invar [] \\<Longrightarrow> rank_invar (ins t [])\n 2. \\<And>a bq t.\n       \\<lbrakk>\\<And>t.\n                   rank_invar bq \\<Longrightarrow> rank_invar (ins t bq);\n        rank_invar (a # bq)\\<rbrakk>\n       \\<Longrightarrow> rank_invar (ins t (a # bq))", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a bq t.\n       \\<lbrakk>\\<And>t.\n                   rank_invar bq \\<Longrightarrow> rank_invar (ins t bq);\n        rank_invar (a # bq)\\<rbrakk>\n       \\<Longrightarrow> rank_invar (ins t (a # bq))", "apply(auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a bq t.\n       \\<lbrakk>\\<And>t.\n                   rank_invar bq \\<Longrightarrow> rank_invar (ins t bq);\n        rank_invar (a # bq); rank a < rank t\\<rbrakk>\n       \\<Longrightarrow> rank_invar (a # ins t bq)\n 2. \\<And>a bq t.\n       \\<lbrakk>\\<And>t.\n                   rank_invar bq \\<Longrightarrow> rank_invar (ins t bq);\n        rank_invar (a # bq); rank t = rank a\\<rbrakk>\n       \\<Longrightarrow> rank_invar (ins (link t a) bq)", "proof goal_cases"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a bq t.\n       \\<lbrakk>\\<And>t.\n                   rank_invar bq \\<Longrightarrow> rank_invar (ins t bq);\n        rank_invar (a # bq); rank a < rank t\\<rbrakk>\n       \\<Longrightarrow> rank_invar (a # ins t bq)\n 2. \\<And>a bq t.\n       \\<lbrakk>\\<And>t.\n                   rank_invar bq \\<Longrightarrow> rank_invar (ins t bq);\n        rank_invar (a # bq); rank t = rank a\\<rbrakk>\n       \\<Longrightarrow> rank_invar (ins (link t a) bq)", "case prems: (1 a bq t)"], ["proof (state)\nthis:\n  rank_invar bq \\<Longrightarrow> rank_invar (ins ?t bq)\n  rank_invar (a # bq)\n  rank a < rank t\n\ngoal (2 subgoals):\n 1. \\<And>a bq t.\n       \\<lbrakk>\\<And>t.\n                   rank_invar bq \\<Longrightarrow> rank_invar (ins t bq);\n        rank_invar (a # bq); rank a < rank t\\<rbrakk>\n       \\<Longrightarrow> rank_invar (a # ins t bq)\n 2. \\<And>a bq t.\n       \\<lbrakk>\\<And>t.\n                   rank_invar bq \\<Longrightarrow> rank_invar (ins t bq);\n        rank_invar (a # bq); rank t = rank a\\<rbrakk>\n       \\<Longrightarrow> rank_invar (ins (link t a) bq)", "hence inv: \"rank_invar (ins t bq)\""], ["proof (prove)\nusing this:\n  rank_invar bq \\<Longrightarrow> rank_invar (ins ?t bq)\n  rank_invar (a # bq)\n  rank a < rank t\n\ngoal (1 subgoal):\n 1. rank_invar (ins t bq)", "by (cases bq) simp_all"], ["proof (state)\nthis:\n  rank_invar (ins t bq)\n\ngoal (2 subgoals):\n 1. \\<And>a bq t.\n       \\<lbrakk>\\<And>t.\n                   rank_invar bq \\<Longrightarrow> rank_invar (ins t bq);\n        rank_invar (a # bq); rank a < rank t\\<rbrakk>\n       \\<Longrightarrow> rank_invar (a # ins t bq)\n 2. \\<And>a bq t.\n       \\<lbrakk>\\<And>t.\n                   rank_invar bq \\<Longrightarrow> rank_invar (ins t bq);\n        rank_invar (a # bq); rank t = rank a\\<rbrakk>\n       \\<Longrightarrow> rank_invar (ins (link t a) bq)", "from prems"], ["proof (chain)\npicking this:\n  rank_invar bq \\<Longrightarrow> rank_invar (ins ?t bq)\n  rank_invar (a # bq)\n  rank a < rank t", "have hd: \"bq \\<noteq> [] \\<Longrightarrow> rank a < rank (hd bq)\""], ["proof (prove)\nusing this:\n  rank_invar bq \\<Longrightarrow> rank_invar (ins ?t bq)\n  rank_invar (a # bq)\n  rank a < rank t\n\ngoal (1 subgoal):\n 1. bq \\<noteq> [] \\<Longrightarrow> rank a < rank (hd bq)", "by (cases bq) auto"], ["proof (state)\nthis:\n  bq \\<noteq> [] \\<Longrightarrow> rank a < rank (hd bq)\n\ngoal (2 subgoals):\n 1. \\<And>a bq t.\n       \\<lbrakk>\\<And>t.\n                   rank_invar bq \\<Longrightarrow> rank_invar (ins t bq);\n        rank_invar (a # bq); rank a < rank t\\<rbrakk>\n       \\<Longrightarrow> rank_invar (a # ins t bq)\n 2. \\<And>a bq t.\n       \\<lbrakk>\\<And>t.\n                   rank_invar bq \\<Longrightarrow> rank_invar (ins t bq);\n        rank_invar (a # bq); rank t = rank a\\<rbrakk>\n       \\<Longrightarrow> rank_invar (ins (link t a) bq)", "from prems"], ["proof (chain)\npicking this:\n  rank_invar bq \\<Longrightarrow> rank_invar (ins ?t bq)\n  rank_invar (a # bq)\n  rank a < rank t", "have \"rank t \\<le> rank (hd (ins t bq)) \\<or>\n    (rank (hd (ins t bq)) = rank (hd bq) \\<and> bq \\<noteq> [])\""], ["proof (prove)\nusing this:\n  rank_invar bq \\<Longrightarrow> rank_invar (ins ?t bq)\n  rank_invar (a # bq)\n  rank a < rank t\n\ngoal (1 subgoal):\n 1. rank t \\<le> rank (hd (ins t bq)) \\<or>\n    rank (hd (ins t bq)) = rank (hd bq) \\<and> bq \\<noteq> []", "by (simp add: rank_ins2 rank_invar_cons)"], ["proof (state)\nthis:\n  rank t \\<le> rank (hd (ins t bq)) \\<or>\n  rank (hd (ins t bq)) = rank (hd bq) \\<and> bq \\<noteq> []\n\ngoal (2 subgoals):\n 1. \\<And>a bq t.\n       \\<lbrakk>\\<And>t.\n                   rank_invar bq \\<Longrightarrow> rank_invar (ins t bq);\n        rank_invar (a # bq); rank a < rank t\\<rbrakk>\n       \\<Longrightarrow> rank_invar (a # ins t bq)\n 2. \\<And>a bq t.\n       \\<lbrakk>\\<And>t.\n                   rank_invar bq \\<Longrightarrow> rank_invar (ins t bq);\n        rank_invar (a # bq); rank t = rank a\\<rbrakk>\n       \\<Longrightarrow> rank_invar (ins (link t a) bq)", "with prems"], ["proof (chain)\npicking this:\n  rank_invar bq \\<Longrightarrow> rank_invar (ins ?t bq)\n  rank_invar (a # bq)\n  rank a < rank t\n  rank t \\<le> rank (hd (ins t bq)) \\<or>\n  rank (hd (ins t bq)) = rank (hd bq) \\<and> bq \\<noteq> []", "have \"rank a < rank (hd (ins t bq)) \\<or>\n    (rank (hd (ins t bq)) = rank (hd bq) \\<and> bq \\<noteq> [])\""], ["proof (prove)\nusing this:\n  rank_invar bq \\<Longrightarrow> rank_invar (ins ?t bq)\n  rank_invar (a # bq)\n  rank a < rank t\n  rank t \\<le> rank (hd (ins t bq)) \\<or>\n  rank (hd (ins t bq)) = rank (hd bq) \\<and> bq \\<noteq> []\n\ngoal (1 subgoal):\n 1. rank a < rank (hd (ins t bq)) \\<or>\n    rank (hd (ins t bq)) = rank (hd bq) \\<and> bq \\<noteq> []", "by auto"], ["proof (state)\nthis:\n  rank a < rank (hd (ins t bq)) \\<or>\n  rank (hd (ins t bq)) = rank (hd bq) \\<and> bq \\<noteq> []\n\ngoal (2 subgoals):\n 1. \\<And>a bq t.\n       \\<lbrakk>\\<And>t.\n                   rank_invar bq \\<Longrightarrow> rank_invar (ins t bq);\n        rank_invar (a # bq); rank a < rank t\\<rbrakk>\n       \\<Longrightarrow> rank_invar (a # ins t bq)\n 2. \\<And>a bq t.\n       \\<lbrakk>\\<And>t.\n                   rank_invar bq \\<Longrightarrow> rank_invar (ins t bq);\n        rank_invar (a # bq); rank t = rank a\\<rbrakk>\n       \\<Longrightarrow> rank_invar (ins (link t a) bq)", "with prems and inv and hd"], ["proof (chain)\npicking this:\n  rank_invar bq \\<Longrightarrow> rank_invar (ins ?t bq)\n  rank_invar (a # bq)\n  rank a < rank t\n  rank_invar (ins t bq)\n  bq \\<noteq> [] \\<Longrightarrow> rank a < rank (hd bq)\n  rank a < rank (hd (ins t bq)) \\<or>\n  rank (hd (ins t bq)) = rank (hd bq) \\<and> bq \\<noteq> []", "show ?case"], ["proof (prove)\nusing this:\n  rank_invar bq \\<Longrightarrow> rank_invar (ins ?t bq)\n  rank_invar (a # bq)\n  rank a < rank t\n  rank_invar (ins t bq)\n  bq \\<noteq> [] \\<Longrightarrow> rank a < rank (hd bq)\n  rank a < rank (hd (ins t bq)) \\<or>\n  rank (hd (ins t bq)) = rank (hd bq) \\<and> bq \\<noteq> []\n\ngoal (1 subgoal):\n 1. rank_invar (a # ins t bq)", "by (auto simp add: rank_invar_hd_cons)"], ["proof (state)\nthis:\n  rank_invar (a # ins t bq)\n\ngoal (1 subgoal):\n 1. \\<And>a bq t.\n       \\<lbrakk>\\<And>t.\n                   rank_invar bq \\<Longrightarrow> rank_invar (ins t bq);\n        rank_invar (a # bq); rank t = rank a\\<rbrakk>\n       \\<Longrightarrow> rank_invar (ins (link t a) bq)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a bq t.\n       \\<lbrakk>\\<And>t.\n                   rank_invar bq \\<Longrightarrow> rank_invar (ins t bq);\n        rank_invar (a # bq); rank t = rank a\\<rbrakk>\n       \\<Longrightarrow> rank_invar (ins (link t a) bq)", "case prems: (2 a bq t)"], ["proof (state)\nthis:\n  rank_invar bq \\<Longrightarrow> rank_invar (ins ?t bq)\n  rank_invar (a # bq)\n  rank t = rank a\n\ngoal (1 subgoal):\n 1. \\<And>a bq t.\n       \\<lbrakk>\\<And>t.\n                   rank_invar bq \\<Longrightarrow> rank_invar (ins t bq);\n        rank_invar (a # bq); rank t = rank a\\<rbrakk>\n       \\<Longrightarrow> rank_invar (ins (link t a) bq)", "hence inv: \"rank_invar bq\""], ["proof (prove)\nusing this:\n  rank_invar bq \\<Longrightarrow> rank_invar (ins ?t bq)\n  rank_invar (a # bq)\n  rank t = rank a\n\ngoal (1 subgoal):\n 1. rank_invar bq", "by (cases bq) simp_all"], ["proof (state)\nthis:\n  rank_invar bq\n\ngoal (1 subgoal):\n 1. \\<And>a bq t.\n       \\<lbrakk>\\<And>t.\n                   rank_invar bq \\<Longrightarrow> rank_invar (ins t bq);\n        rank_invar (a # bq); rank t = rank a\\<rbrakk>\n       \\<Longrightarrow> rank_invar (ins (link t a) bq)", "with prems and prems(1)[of \"(link t a)\"]"], ["proof (chain)\npicking this:\n  rank_invar bq \\<Longrightarrow> rank_invar (ins ?t bq)\n  rank_invar (a # bq)\n  rank t = rank a\n  rank_invar bq \\<Longrightarrow> rank_invar (ins (link t a) bq)\n  rank_invar bq", "show ?case"], ["proof (prove)\nusing this:\n  rank_invar bq \\<Longrightarrow> rank_invar (ins ?t bq)\n  rank_invar (a # bq)\n  rank t = rank a\n  rank_invar bq \\<Longrightarrow> rank_invar (ins (link t a) bq)\n  rank_invar bq\n\ngoal (1 subgoal):\n 1. rank_invar (ins (link t a) bq)", "by simp"], ["proof (state)\nthis:\n  rank_invar (ins (link t a) bq)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rank_invar_insert: \"rank_invar bq \\<Longrightarrow> rank_invar (insert e a bq)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rank_invar bq \\<Longrightarrow> rank_invar (local.insert e a bq)", "by (simp add: rank_invar_ins insert_def)"], ["", "lemma insert_correct: \n  assumes I: \"invar q\"\n  shows \n  \"invar (insert e a q)\"\n  \"queue_to_multiset (insert e a q) = queue_to_multiset q + {# (e,a) #}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invar (local.insert e a q) &&&\n    queue_to_multiset (local.insert e a q) =\n    queue_to_multiset q + {#(e, a)#}", "using insert_queue_invar[of q] rank_invar_insert[of q] insert_mset[of q] I"], ["proof (prove)\nusing this:\n  queue_invar q \\<Longrightarrow> queue_invar (local.insert ?e ?a q)\n  rank_invar q \\<Longrightarrow> rank_invar (local.insert ?e ?a q)\n  queue_invar q \\<Longrightarrow>\n  queue_to_multiset (local.insert ?e ?a q) =\n  queue_to_multiset q + {#(?e, ?a)#}\n  invar q\n\ngoal (1 subgoal):\n 1. invar (local.insert e a q) &&&\n    queue_to_multiset (local.insert e a q) =\n    queue_to_multiset q + {#(e, a)#}", "unfolding invar_def"], ["proof (prove)\nusing this:\n  queue_invar q \\<Longrightarrow> queue_invar (local.insert ?e ?a q)\n  rank_invar q \\<Longrightarrow> rank_invar (local.insert ?e ?a q)\n  queue_invar q \\<Longrightarrow>\n  queue_to_multiset (local.insert ?e ?a q) =\n  queue_to_multiset q + {#(?e, ?a)#}\n  queue_invar q \\<and> rank_invar q\n\ngoal (1 subgoal):\n 1. queue_invar (local.insert e a q) \\<and>\n    rank_invar (local.insert e a q) &&&\n    queue_to_multiset (local.insert e a q) =\n    queue_to_multiset q + {#(e, a)#}", "by auto"], ["", "subsubsection \"Meld\""], ["", "text \\<open>Melds two queues.\\<close>"], ["", "fun meld :: \"('e, 'a::linorder) BinomialQueue_inv \\<Rightarrow> ('e, 'a) BinomialQueue_inv\n  \\<Rightarrow> ('e, 'a) BinomialQueue_inv\" \n  where\n  \"meld [] bq = bq\" |\n  \"meld bq [] = bq\" |\n  \"meld (t1#bq1) (t2#bq2) =\n   (if (rank t1) < (rank t2) \n       then t1 # (meld bq1 (t2 # bq2))\n       else (\n         if (rank t2 < rank t1)\n            then t2 # (meld (t1 # bq1) bq2)\n            else ins (link t1 t2) (meld bq1 bq2)\n       )\n    )\""], ["", "lemma meld_queue_invar: \n  \"\\<lbrakk>queue_invar q; queue_invar q'\\<rbrakk> \\<Longrightarrow> queue_invar (meld q q')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>queue_invar q; queue_invar q'\\<rbrakk>\n    \\<Longrightarrow> queue_invar (meld q q')", "proof (induct q q' rule: meld.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>bq.\n       \\<lbrakk>queue_invar []; queue_invar bq\\<rbrakk>\n       \\<Longrightarrow> queue_invar (meld [] bq)\n 2. \\<And>v va.\n       \\<lbrakk>queue_invar (v # va); queue_invar []\\<rbrakk>\n       \\<Longrightarrow> queue_invar (meld (v # va) [])\n 3. \\<And>t1 bq1 t2 bq2.\n       \\<lbrakk>\\<lbrakk>rank t1 < rank t2; queue_invar bq1;\n                 queue_invar (t2 # bq2)\\<rbrakk>\n                \\<Longrightarrow> queue_invar (meld bq1 (t2 # bq2));\n        \\<lbrakk>\\<not> rank t1 < rank t2; rank t2 < rank t1;\n         queue_invar (t1 # bq1); queue_invar bq2\\<rbrakk>\n        \\<Longrightarrow> queue_invar (meld (t1 # bq1) bq2);\n        \\<lbrakk>\\<not> rank t1 < rank t2; \\<not> rank t2 < rank t1;\n         queue_invar bq1; queue_invar bq2\\<rbrakk>\n        \\<Longrightarrow> queue_invar (meld bq1 bq2);\n        queue_invar (t1 # bq1); queue_invar (t2 # bq2)\\<rbrakk>\n       \\<Longrightarrow> queue_invar (meld (t1 # bq1) (t2 # bq2))", "case 1"], ["proof (state)\nthis:\n  queue_invar []\n  queue_invar bq_\n\ngoal (3 subgoals):\n 1. \\<And>bq.\n       \\<lbrakk>queue_invar []; queue_invar bq\\<rbrakk>\n       \\<Longrightarrow> queue_invar (meld [] bq)\n 2. \\<And>v va.\n       \\<lbrakk>queue_invar (v # va); queue_invar []\\<rbrakk>\n       \\<Longrightarrow> queue_invar (meld (v # va) [])\n 3. \\<And>t1 bq1 t2 bq2.\n       \\<lbrakk>\\<lbrakk>rank t1 < rank t2; queue_invar bq1;\n                 queue_invar (t2 # bq2)\\<rbrakk>\n                \\<Longrightarrow> queue_invar (meld bq1 (t2 # bq2));\n        \\<lbrakk>\\<not> rank t1 < rank t2; rank t2 < rank t1;\n         queue_invar (t1 # bq1); queue_invar bq2\\<rbrakk>\n        \\<Longrightarrow> queue_invar (meld (t1 # bq1) bq2);\n        \\<lbrakk>\\<not> rank t1 < rank t2; \\<not> rank t2 < rank t1;\n         queue_invar bq1; queue_invar bq2\\<rbrakk>\n        \\<Longrightarrow> queue_invar (meld bq1 bq2);\n        queue_invar (t1 # bq1); queue_invar (t2 # bq2)\\<rbrakk>\n       \\<Longrightarrow> queue_invar (meld (t1 # bq1) (t2 # bq2))", "then"], ["proof (chain)\npicking this:\n  queue_invar []\n  queue_invar bq_", "show ?case"], ["proof (prove)\nusing this:\n  queue_invar []\n  queue_invar bq_\n\ngoal (1 subgoal):\n 1. queue_invar (meld [] bq_)", "by simp"], ["proof (state)\nthis:\n  queue_invar (meld [] bq_)\n\ngoal (2 subgoals):\n 1. \\<And>v va.\n       \\<lbrakk>queue_invar (v # va); queue_invar []\\<rbrakk>\n       \\<Longrightarrow> queue_invar (meld (v # va) [])\n 2. \\<And>t1 bq1 t2 bq2.\n       \\<lbrakk>\\<lbrakk>rank t1 < rank t2; queue_invar bq1;\n                 queue_invar (t2 # bq2)\\<rbrakk>\n                \\<Longrightarrow> queue_invar (meld bq1 (t2 # bq2));\n        \\<lbrakk>\\<not> rank t1 < rank t2; rank t2 < rank t1;\n         queue_invar (t1 # bq1); queue_invar bq2\\<rbrakk>\n        \\<Longrightarrow> queue_invar (meld (t1 # bq1) bq2);\n        \\<lbrakk>\\<not> rank t1 < rank t2; \\<not> rank t2 < rank t1;\n         queue_invar bq1; queue_invar bq2\\<rbrakk>\n        \\<Longrightarrow> queue_invar (meld bq1 bq2);\n        queue_invar (t1 # bq1); queue_invar (t2 # bq2)\\<rbrakk>\n       \\<Longrightarrow> queue_invar (meld (t1 # bq1) (t2 # bq2))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>v va.\n       \\<lbrakk>queue_invar (v # va); queue_invar []\\<rbrakk>\n       \\<Longrightarrow> queue_invar (meld (v # va) [])\n 2. \\<And>t1 bq1 t2 bq2.\n       \\<lbrakk>\\<lbrakk>rank t1 < rank t2; queue_invar bq1;\n                 queue_invar (t2 # bq2)\\<rbrakk>\n                \\<Longrightarrow> queue_invar (meld bq1 (t2 # bq2));\n        \\<lbrakk>\\<not> rank t1 < rank t2; rank t2 < rank t1;\n         queue_invar (t1 # bq1); queue_invar bq2\\<rbrakk>\n        \\<Longrightarrow> queue_invar (meld (t1 # bq1) bq2);\n        \\<lbrakk>\\<not> rank t1 < rank t2; \\<not> rank t2 < rank t1;\n         queue_invar bq1; queue_invar bq2\\<rbrakk>\n        \\<Longrightarrow> queue_invar (meld bq1 bq2);\n        queue_invar (t1 # bq1); queue_invar (t2 # bq2)\\<rbrakk>\n       \\<Longrightarrow> queue_invar (meld (t1 # bq1) (t2 # bq2))", "case 2"], ["proof (state)\nthis:\n  queue_invar (v_ # va_)\n  queue_invar []\n\ngoal (2 subgoals):\n 1. \\<And>v va.\n       \\<lbrakk>queue_invar (v # va); queue_invar []\\<rbrakk>\n       \\<Longrightarrow> queue_invar (meld (v # va) [])\n 2. \\<And>t1 bq1 t2 bq2.\n       \\<lbrakk>\\<lbrakk>rank t1 < rank t2; queue_invar bq1;\n                 queue_invar (t2 # bq2)\\<rbrakk>\n                \\<Longrightarrow> queue_invar (meld bq1 (t2 # bq2));\n        \\<lbrakk>\\<not> rank t1 < rank t2; rank t2 < rank t1;\n         queue_invar (t1 # bq1); queue_invar bq2\\<rbrakk>\n        \\<Longrightarrow> queue_invar (meld (t1 # bq1) bq2);\n        \\<lbrakk>\\<not> rank t1 < rank t2; \\<not> rank t2 < rank t1;\n         queue_invar bq1; queue_invar bq2\\<rbrakk>\n        \\<Longrightarrow> queue_invar (meld bq1 bq2);\n        queue_invar (t1 # bq1); queue_invar (t2 # bq2)\\<rbrakk>\n       \\<Longrightarrow> queue_invar (meld (t1 # bq1) (t2 # bq2))", "then"], ["proof (chain)\npicking this:\n  queue_invar (v_ # va_)\n  queue_invar []", "show ?case"], ["proof (prove)\nusing this:\n  queue_invar (v_ # va_)\n  queue_invar []\n\ngoal (1 subgoal):\n 1. queue_invar (meld (v_ # va_) [])", "by simp"], ["proof (state)\nthis:\n  queue_invar (meld (v_ # va_) [])\n\ngoal (1 subgoal):\n 1. \\<And>t1 bq1 t2 bq2.\n       \\<lbrakk>\\<lbrakk>rank t1 < rank t2; queue_invar bq1;\n                 queue_invar (t2 # bq2)\\<rbrakk>\n                \\<Longrightarrow> queue_invar (meld bq1 (t2 # bq2));\n        \\<lbrakk>\\<not> rank t1 < rank t2; rank t2 < rank t1;\n         queue_invar (t1 # bq1); queue_invar bq2\\<rbrakk>\n        \\<Longrightarrow> queue_invar (meld (t1 # bq1) bq2);\n        \\<lbrakk>\\<not> rank t1 < rank t2; \\<not> rank t2 < rank t1;\n         queue_invar bq1; queue_invar bq2\\<rbrakk>\n        \\<Longrightarrow> queue_invar (meld bq1 bq2);\n        queue_invar (t1 # bq1); queue_invar (t2 # bq2)\\<rbrakk>\n       \\<Longrightarrow> queue_invar (meld (t1 # bq1) (t2 # bq2))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t1 bq1 t2 bq2.\n       \\<lbrakk>\\<lbrakk>rank t1 < rank t2; queue_invar bq1;\n                 queue_invar (t2 # bq2)\\<rbrakk>\n                \\<Longrightarrow> queue_invar (meld bq1 (t2 # bq2));\n        \\<lbrakk>\\<not> rank t1 < rank t2; rank t2 < rank t1;\n         queue_invar (t1 # bq1); queue_invar bq2\\<rbrakk>\n        \\<Longrightarrow> queue_invar (meld (t1 # bq1) bq2);\n        \\<lbrakk>\\<not> rank t1 < rank t2; \\<not> rank t2 < rank t1;\n         queue_invar bq1; queue_invar bq2\\<rbrakk>\n        \\<Longrightarrow> queue_invar (meld bq1 bq2);\n        queue_invar (t1 # bq1); queue_invar (t2 # bq2)\\<rbrakk>\n       \\<Longrightarrow> queue_invar (meld (t1 # bq1) (t2 # bq2))", "case (3 t1 bq1 t2 bq2)"], ["proof (state)\nthis:\n  \\<lbrakk>rank t1 < rank t2; queue_invar bq1;\n   queue_invar (t2 # bq2)\\<rbrakk>\n  \\<Longrightarrow> queue_invar (meld bq1 (t2 # bq2))\n  \\<lbrakk>\\<not> rank t1 < rank t2; rank t2 < rank t1;\n   queue_invar (t1 # bq1); queue_invar bq2\\<rbrakk>\n  \\<Longrightarrow> queue_invar (meld (t1 # bq1) bq2)\n  \\<lbrakk>\\<not> rank t1 < rank t2; \\<not> rank t2 < rank t1;\n   queue_invar bq1; queue_invar bq2\\<rbrakk>\n  \\<Longrightarrow> queue_invar (meld bq1 bq2)\n  queue_invar (t1 # bq1)\n  queue_invar (t2 # bq2)\n\ngoal (1 subgoal):\n 1. \\<And>t1 bq1 t2 bq2.\n       \\<lbrakk>\\<lbrakk>rank t1 < rank t2; queue_invar bq1;\n                 queue_invar (t2 # bq2)\\<rbrakk>\n                \\<Longrightarrow> queue_invar (meld bq1 (t2 # bq2));\n        \\<lbrakk>\\<not> rank t1 < rank t2; rank t2 < rank t1;\n         queue_invar (t1 # bq1); queue_invar bq2\\<rbrakk>\n        \\<Longrightarrow> queue_invar (meld (t1 # bq1) bq2);\n        \\<lbrakk>\\<not> rank t1 < rank t2; \\<not> rank t2 < rank t1;\n         queue_invar bq1; queue_invar bq2\\<rbrakk>\n        \\<Longrightarrow> queue_invar (meld bq1 bq2);\n        queue_invar (t1 # bq1); queue_invar (t2 # bq2)\\<rbrakk>\n       \\<Longrightarrow> queue_invar (meld (t1 # bq1) (t2 # bq2))", "consider (lt) \"rank t1 < rank t2\" | (gt) \"rank t1 > rank t2\" | (eq) \"rank t1 = rank t2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>rank t1 < rank t2 \\<Longrightarrow> thesis;\n     rank t2 < rank t1 \\<Longrightarrow> thesis;\n     rank t1 = rank t2 \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by atomize_elim auto"], ["proof (state)\nthis:\n  \\<lbrakk>rank t1 < rank t2 \\<Longrightarrow> ?thesis;\n   rank t2 < rank t1 \\<Longrightarrow> ?thesis;\n   rank t1 = rank t2 \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. \\<And>t1 bq1 t2 bq2.\n       \\<lbrakk>\\<lbrakk>rank t1 < rank t2; queue_invar bq1;\n                 queue_invar (t2 # bq2)\\<rbrakk>\n                \\<Longrightarrow> queue_invar (meld bq1 (t2 # bq2));\n        \\<lbrakk>\\<not> rank t1 < rank t2; rank t2 < rank t1;\n         queue_invar (t1 # bq1); queue_invar bq2\\<rbrakk>\n        \\<Longrightarrow> queue_invar (meld (t1 # bq1) bq2);\n        \\<lbrakk>\\<not> rank t1 < rank t2; \\<not> rank t2 < rank t1;\n         queue_invar bq1; queue_invar bq2\\<rbrakk>\n        \\<Longrightarrow> queue_invar (meld bq1 bq2);\n        queue_invar (t1 # bq1); queue_invar (t2 # bq2)\\<rbrakk>\n       \\<Longrightarrow> queue_invar (meld (t1 # bq1) (t2 # bq2))", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>rank t1 < rank t2 \\<Longrightarrow> ?thesis;\n   rank t2 < rank t1 \\<Longrightarrow> ?thesis;\n   rank t1 = rank t2 \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>rank t1 < rank t2 \\<Longrightarrow> ?thesis;\n   rank t2 < rank t1 \\<Longrightarrow> ?thesis;\n   rank t1 = rank t2 \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. queue_invar (meld (t1 # bq1) (t2 # bq2))", "proof cases"], ["proof (state)\ngoal (3 subgoals):\n 1. rank t1 < rank t2 \\<Longrightarrow>\n    queue_invar (meld (t1 # bq1) (t2 # bq2))\n 2. rank t2 < rank t1 \\<Longrightarrow>\n    queue_invar (meld (t1 # bq1) (t2 # bq2))\n 3. rank t1 = rank t2 \\<Longrightarrow>\n    queue_invar (meld (t1 # bq1) (t2 # bq2))", "case lt"], ["proof (state)\nthis:\n  rank t1 < rank t2\n\ngoal (3 subgoals):\n 1. rank t1 < rank t2 \\<Longrightarrow>\n    queue_invar (meld (t1 # bq1) (t2 # bq2))\n 2. rank t2 < rank t1 \\<Longrightarrow>\n    queue_invar (meld (t1 # bq1) (t2 # bq2))\n 3. rank t1 = rank t2 \\<Longrightarrow>\n    queue_invar (meld (t1 # bq1) (t2 # bq2))", "from 3(4)"], ["proof (chain)\npicking this:\n  queue_invar (t1 # bq1)", "have inv_bq1: \"queue_invar bq1\""], ["proof (prove)\nusing this:\n  queue_invar (t1 # bq1)\n\ngoal (1 subgoal):\n 1. queue_invar bq1", "by simp"], ["proof (state)\nthis:\n  queue_invar bq1\n\ngoal (3 subgoals):\n 1. rank t1 < rank t2 \\<Longrightarrow>\n    queue_invar (meld (t1 # bq1) (t2 # bq2))\n 2. rank t2 < rank t1 \\<Longrightarrow>\n    queue_invar (meld (t1 # bq1) (t2 # bq2))\n 3. rank t1 = rank t2 \\<Longrightarrow>\n    queue_invar (meld (t1 # bq1) (t2 # bq2))", "from 3(4)"], ["proof (chain)\npicking this:\n  queue_invar (t1 # bq1)", "have inv_t1: \"tree_invar t1\""], ["proof (prove)\nusing this:\n  queue_invar (t1 # bq1)\n\ngoal (1 subgoal):\n 1. tree_invar t1", "by simp"], ["proof (state)\nthis:\n  tree_invar t1\n\ngoal (3 subgoals):\n 1. rank t1 < rank t2 \\<Longrightarrow>\n    queue_invar (meld (t1 # bq1) (t2 # bq2))\n 2. rank t2 < rank t1 \\<Longrightarrow>\n    queue_invar (meld (t1 # bq1) (t2 # bq2))\n 3. rank t1 = rank t2 \\<Longrightarrow>\n    queue_invar (meld (t1 # bq1) (t2 # bq2))", "from 3(1)[OF lt inv_bq1 3(5)] inv_t1 lt"], ["proof (chain)\npicking this:\n  queue_invar (meld bq1 (t2 # bq2))\n  tree_invar t1\n  rank t1 < rank t2", "show ?thesis"], ["proof (prove)\nusing this:\n  queue_invar (meld bq1 (t2 # bq2))\n  tree_invar t1\n  rank t1 < rank t2\n\ngoal (1 subgoal):\n 1. queue_invar (meld (t1 # bq1) (t2 # bq2))", "by simp"], ["proof (state)\nthis:\n  queue_invar (meld (t1 # bq1) (t2 # bq2))\n\ngoal (2 subgoals):\n 1. rank t2 < rank t1 \\<Longrightarrow>\n    queue_invar (meld (t1 # bq1) (t2 # bq2))\n 2. rank t1 = rank t2 \\<Longrightarrow>\n    queue_invar (meld (t1 # bq1) (t2 # bq2))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. rank t2 < rank t1 \\<Longrightarrow>\n    queue_invar (meld (t1 # bq1) (t2 # bq2))\n 2. rank t1 = rank t2 \\<Longrightarrow>\n    queue_invar (meld (t1 # bq1) (t2 # bq2))", "case gt"], ["proof (state)\nthis:\n  rank t2 < rank t1\n\ngoal (2 subgoals):\n 1. rank t2 < rank t1 \\<Longrightarrow>\n    queue_invar (meld (t1 # bq1) (t2 # bq2))\n 2. rank t1 = rank t2 \\<Longrightarrow>\n    queue_invar (meld (t1 # bq1) (t2 # bq2))", "from 3(5)"], ["proof (chain)\npicking this:\n  queue_invar (t2 # bq2)", "have inv_bq2: \"queue_invar bq2\""], ["proof (prove)\nusing this:\n  queue_invar (t2 # bq2)\n\ngoal (1 subgoal):\n 1. queue_invar bq2", "by simp"], ["proof (state)\nthis:\n  queue_invar bq2\n\ngoal (2 subgoals):\n 1. rank t2 < rank t1 \\<Longrightarrow>\n    queue_invar (meld (t1 # bq1) (t2 # bq2))\n 2. rank t1 = rank t2 \\<Longrightarrow>\n    queue_invar (meld (t1 # bq1) (t2 # bq2))", "from 3(5)"], ["proof (chain)\npicking this:\n  queue_invar (t2 # bq2)", "have inv_t2: \"tree_invar t2\""], ["proof (prove)\nusing this:\n  queue_invar (t2 # bq2)\n\ngoal (1 subgoal):\n 1. tree_invar t2", "by simp"], ["proof (state)\nthis:\n  tree_invar t2\n\ngoal (2 subgoals):\n 1. rank t2 < rank t1 \\<Longrightarrow>\n    queue_invar (meld (t1 # bq1) (t2 # bq2))\n 2. rank t1 = rank t2 \\<Longrightarrow>\n    queue_invar (meld (t1 # bq1) (t2 # bq2))", "from gt"], ["proof (chain)\npicking this:\n  rank t2 < rank t1", "have \"\\<not> rank t1 < rank t2\""], ["proof (prove)\nusing this:\n  rank t2 < rank t1\n\ngoal (1 subgoal):\n 1. \\<not> rank t1 < rank t2", "by simp"], ["proof (state)\nthis:\n  \\<not> rank t1 < rank t2\n\ngoal (2 subgoals):\n 1. rank t2 < rank t1 \\<Longrightarrow>\n    queue_invar (meld (t1 # bq1) (t2 # bq2))\n 2. rank t1 = rank t2 \\<Longrightarrow>\n    queue_invar (meld (t1 # bq1) (t2 # bq2))", "from 3(2)[OF this gt 3(4) inv_bq2] inv_t2 gt"], ["proof (chain)\npicking this:\n  queue_invar (meld (t1 # bq1) bq2)\n  tree_invar t2\n  rank t2 < rank t1", "show ?thesis"], ["proof (prove)\nusing this:\n  queue_invar (meld (t1 # bq1) bq2)\n  tree_invar t2\n  rank t2 < rank t1\n\ngoal (1 subgoal):\n 1. queue_invar (meld (t1 # bq1) (t2 # bq2))", "by simp"], ["proof (state)\nthis:\n  queue_invar (meld (t1 # bq1) (t2 # bq2))\n\ngoal (1 subgoal):\n 1. rank t1 = rank t2 \\<Longrightarrow>\n    queue_invar (meld (t1 # bq1) (t2 # bq2))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. rank t1 = rank t2 \\<Longrightarrow>\n    queue_invar (meld (t1 # bq1) (t2 # bq2))", "case eq"], ["proof (state)\nthis:\n  rank t1 = rank t2\n\ngoal (1 subgoal):\n 1. rank t1 = rank t2 \\<Longrightarrow>\n    queue_invar (meld (t1 # bq1) (t2 # bq2))", "from 3(4)"], ["proof (chain)\npicking this:\n  queue_invar (t1 # bq1)", "have inv_bq1: \"queue_invar bq1\""], ["proof (prove)\nusing this:\n  queue_invar (t1 # bq1)\n\ngoal (1 subgoal):\n 1. queue_invar bq1", "by simp"], ["proof (state)\nthis:\n  queue_invar bq1\n\ngoal (1 subgoal):\n 1. rank t1 = rank t2 \\<Longrightarrow>\n    queue_invar (meld (t1 # bq1) (t2 # bq2))", "from 3(4)"], ["proof (chain)\npicking this:\n  queue_invar (t1 # bq1)", "have inv_t1: \"tree_invar t1\""], ["proof (prove)\nusing this:\n  queue_invar (t1 # bq1)\n\ngoal (1 subgoal):\n 1. tree_invar t1", "by simp"], ["proof (state)\nthis:\n  tree_invar t1\n\ngoal (1 subgoal):\n 1. rank t1 = rank t2 \\<Longrightarrow>\n    queue_invar (meld (t1 # bq1) (t2 # bq2))", "from 3(5)"], ["proof (chain)\npicking this:\n  queue_invar (t2 # bq2)", "have inv_bq2: \"queue_invar bq2\""], ["proof (prove)\nusing this:\n  queue_invar (t2 # bq2)\n\ngoal (1 subgoal):\n 1. queue_invar bq2", "by simp"], ["proof (state)\nthis:\n  queue_invar bq2\n\ngoal (1 subgoal):\n 1. rank t1 = rank t2 \\<Longrightarrow>\n    queue_invar (meld (t1 # bq1) (t2 # bq2))", "from 3(5)"], ["proof (chain)\npicking this:\n  queue_invar (t2 # bq2)", "have inv_t2: \"tree_invar t2\""], ["proof (prove)\nusing this:\n  queue_invar (t2 # bq2)\n\ngoal (1 subgoal):\n 1. tree_invar t2", "by simp"], ["proof (state)\nthis:\n  tree_invar t2\n\ngoal (1 subgoal):\n 1. rank t1 = rank t2 \\<Longrightarrow>\n    queue_invar (meld (t1 # bq1) (t2 # bq2))", "note inv_link = link_tree_invar[OF inv_t1 inv_t2 eq]"], ["proof (state)\nthis:\n  tree_invar (link t1 t2)\n\ngoal (1 subgoal):\n 1. rank t1 = rank t2 \\<Longrightarrow>\n    queue_invar (meld (t1 # bq1) (t2 # bq2))", "from eq"], ["proof (chain)\npicking this:\n  rank t1 = rank t2", "have *: \"\\<not> rank t1 < rank t2\" \"\\<not> rank t2 < rank t1\""], ["proof (prove)\nusing this:\n  rank t1 = rank t2\n\ngoal (1 subgoal):\n 1. \\<not> rank t1 < rank t2 &&& \\<not> rank t2 < rank t1", "by simp_all"], ["proof (state)\nthis:\n  \\<not> rank t1 < rank t2\n  \\<not> rank t2 < rank t1\n\ngoal (1 subgoal):\n 1. rank t1 = rank t2 \\<Longrightarrow>\n    queue_invar (meld (t1 # bq1) (t2 # bq2))", "note inv_meld = 3(3)[OF * inv_bq1 inv_bq2]"], ["proof (state)\nthis:\n  queue_invar (meld bq1 bq2)\n\ngoal (1 subgoal):\n 1. rank t1 = rank t2 \\<Longrightarrow>\n    queue_invar (meld (t1 # bq1) (t2 # bq2))", "from ins_queue_invar[OF inv_link inv_meld] *"], ["proof (chain)\npicking this:\n  queue_invar (ins (link t1 t2) (meld bq1 bq2))\n  \\<not> rank t1 < rank t2\n  \\<not> rank t2 < rank t1", "show ?thesis"], ["proof (prove)\nusing this:\n  queue_invar (ins (link t1 t2) (meld bq1 bq2))\n  \\<not> rank t1 < rank t2\n  \\<not> rank t2 < rank t1\n\ngoal (1 subgoal):\n 1. queue_invar (meld (t1 # bq1) (t2 # bq2))", "by simp"], ["proof (state)\nthis:\n  queue_invar (meld (t1 # bq1) (t2 # bq2))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  queue_invar (meld (t1 # bq1) (t2 # bq2))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rank_ins_min: \"rank_invar bq \\<Longrightarrow> \n  rank (hd (ins t bq)) \\<ge> min (rank t) (rank (hd bq))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rank_invar bq \\<Longrightarrow>\n    min (rank t) (rank (hd bq)) \\<le> rank (hd (ins t bq))", "apply(induct bq arbitrary: t)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>t.\n       rank_invar [] \\<Longrightarrow>\n       min (rank t) (rank (hd [])) \\<le> rank (hd (ins t []))\n 2. \\<And>a bq t.\n       \\<lbrakk>\\<And>t.\n                   rank_invar bq \\<Longrightarrow>\n                   min (rank t) (rank (hd bq)) \\<le> rank (hd (ins t bq));\n        rank_invar (a # bq)\\<rbrakk>\n       \\<Longrightarrow> min (rank t) (rank (hd (a # bq)))\n                         \\<le> rank (hd (ins t (a # bq)))", "apply(auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a bq t.\n       \\<lbrakk>\\<And>t.\n                   rank_invar bq \\<Longrightarrow>\n                   min (rank t) (rank (hd bq)) \\<le> rank (hd (ins t bq));\n        rank_invar (a # bq); rank t = rank a\\<rbrakk>\n       \\<Longrightarrow> rank a \\<le> rank (hd (ins (link t a) bq))", "proof goal_cases"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a bq t.\n       \\<lbrakk>\\<And>t.\n                   rank_invar bq \\<Longrightarrow>\n                   min (rank t) (rank (hd bq)) \\<le> rank (hd (ins t bq));\n        rank_invar (a # bq); rank t = rank a\\<rbrakk>\n       \\<Longrightarrow> rank a \\<le> rank (hd (ins (link t a) bq))", "case prems: (1 a bq t)"], ["proof (state)\nthis:\n  rank_invar bq \\<Longrightarrow>\n  min (rank ?t) (rank (hd bq)) \\<le> rank (hd (ins ?t bq))\n  rank_invar (a # bq)\n  rank t = rank a\n\ngoal (1 subgoal):\n 1. \\<And>a bq t.\n       \\<lbrakk>\\<And>t.\n                   rank_invar bq \\<Longrightarrow>\n                   min (rank t) (rank (hd bq)) \\<le> rank (hd (ins t bq));\n        rank_invar (a # bq); rank t = rank a\\<rbrakk>\n       \\<Longrightarrow> rank a \\<le> rank (hd (ins (link t a) bq))", "hence inv: \"rank_invar bq\""], ["proof (prove)\nusing this:\n  rank_invar bq \\<Longrightarrow>\n  min (rank ?t) (rank (hd bq)) \\<le> rank (hd (ins ?t bq))\n  rank_invar (a # bq)\n  rank t = rank a\n\ngoal (1 subgoal):\n 1. rank_invar bq", "by (cases bq) simp_all"], ["proof (state)\nthis:\n  rank_invar bq\n\ngoal (1 subgoal):\n 1. \\<And>a bq t.\n       \\<lbrakk>\\<And>t.\n                   rank_invar bq \\<Longrightarrow>\n                   min (rank t) (rank (hd bq)) \\<le> rank (hd (ins t bq));\n        rank_invar (a # bq); rank t = rank a\\<rbrakk>\n       \\<Longrightarrow> rank a \\<le> rank (hd (ins (link t a) bq))", "from prems"], ["proof (chain)\npicking this:\n  rank_invar bq \\<Longrightarrow>\n  min (rank ?t) (rank (hd bq)) \\<le> rank (hd (ins ?t bq))\n  rank_invar (a # bq)\n  rank t = rank a", "have r: \"rank (link t a) = rank a + 1\""], ["proof (prove)\nusing this:\n  rank_invar bq \\<Longrightarrow>\n  min (rank ?t) (rank (hd bq)) \\<le> rank (hd (ins ?t bq))\n  rank_invar (a # bq)\n  rank t = rank a\n\ngoal (1 subgoal):\n 1. rank (link t a) = rank a + 1", "by (simp add: rank_link)"], ["proof (state)\nthis:\n  rank (link t a) = rank a + 1\n\ngoal (1 subgoal):\n 1. \\<And>a bq t.\n       \\<lbrakk>\\<And>t.\n                   rank_invar bq \\<Longrightarrow>\n                   min (rank t) (rank (hd bq)) \\<le> rank (hd (ins t bq));\n        rank_invar (a # bq); rank t = rank a\\<rbrakk>\n       \\<Longrightarrow> rank a \\<le> rank (hd (ins (link t a) bq))", "with prems and inv and prems(1)[of \"(link t a)\"]"], ["proof (chain)\npicking this:\n  rank_invar bq \\<Longrightarrow>\n  min (rank ?t) (rank (hd bq)) \\<le> rank (hd (ins ?t bq))\n  rank_invar (a # bq)\n  rank t = rank a\n  rank_invar bq\n  rank_invar bq \\<Longrightarrow>\n  min (rank (link t a)) (rank (hd bq)) \\<le> rank (hd (ins (link t a) bq))\n  rank (link t a) = rank a + 1", "show ?case"], ["proof (prove)\nusing this:\n  rank_invar bq \\<Longrightarrow>\n  min (rank ?t) (rank (hd bq)) \\<le> rank (hd (ins ?t bq))\n  rank_invar (a # bq)\n  rank t = rank a\n  rank_invar bq\n  rank_invar bq \\<Longrightarrow>\n  min (rank (link t a)) (rank (hd bq)) \\<le> rank (hd (ins (link t a) bq))\n  rank (link t a) = rank a + 1\n\ngoal (1 subgoal):\n 1. rank a \\<le> rank (hd (ins (link t a) bq))", "by (cases bq) auto"], ["proof (state)\nthis:\n  rank a \\<le> rank (hd (ins (link t a) bq))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rank_invar_meld_strong: \n  \"\\<lbrakk>rank_invar bq1; rank_invar bq2\\<rbrakk> \\<Longrightarrow> rank_invar (meld bq1 bq2) \\<and> \n  rank (hd (meld bq1 bq2)) \\<ge> min (rank (hd bq1)) (rank (hd bq2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>rank_invar bq1; rank_invar bq2\\<rbrakk>\n    \\<Longrightarrow> rank_invar (meld bq1 bq2) \\<and>\n                      min (rank (hd bq1)) (rank (hd bq2))\n                      \\<le> rank (hd (meld bq1 bq2))", "proof (induct bq1 bq2 rule: meld.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>bq.\n       \\<lbrakk>rank_invar []; rank_invar bq\\<rbrakk>\n       \\<Longrightarrow> rank_invar (meld [] bq) \\<and>\n                         min (rank (hd [])) (rank (hd bq))\n                         \\<le> rank (hd (meld [] bq))\n 2. \\<And>v va.\n       \\<lbrakk>rank_invar (v # va); rank_invar []\\<rbrakk>\n       \\<Longrightarrow> rank_invar (meld (v # va) []) \\<and>\n                         min (rank (hd (v # va))) (rank (hd []))\n                         \\<le> rank (hd (meld (v # va) []))\n 3. \\<And>t1 bq1 t2 bq2.\n       \\<lbrakk>\\<lbrakk>rank t1 < rank t2; rank_invar bq1;\n                 rank_invar (t2 # bq2)\\<rbrakk>\n                \\<Longrightarrow> rank_invar (meld bq1 (t2 # bq2)) \\<and>\n                                  min (rank (hd bq1)) (rank (hd (t2 # bq2)))\n                                  \\<le> rank (hd (meld bq1 (t2 # bq2)));\n        \\<lbrakk>\\<not> rank t1 < rank t2; rank t2 < rank t1;\n         rank_invar (t1 # bq1); rank_invar bq2\\<rbrakk>\n        \\<Longrightarrow> rank_invar (meld (t1 # bq1) bq2) \\<and>\n                          min (rank (hd (t1 # bq1))) (rank (hd bq2))\n                          \\<le> rank (hd (meld (t1 # bq1) bq2));\n        \\<lbrakk>\\<not> rank t1 < rank t2; \\<not> rank t2 < rank t1;\n         rank_invar bq1; rank_invar bq2\\<rbrakk>\n        \\<Longrightarrow> rank_invar (meld bq1 bq2) \\<and>\n                          min (rank (hd bq1)) (rank (hd bq2))\n                          \\<le> rank (hd (meld bq1 bq2));\n        rank_invar (t1 # bq1); rank_invar (t2 # bq2)\\<rbrakk>\n       \\<Longrightarrow> rank_invar (meld (t1 # bq1) (t2 # bq2)) \\<and>\n                         min (rank (hd (t1 # bq1))) (rank (hd (t2 # bq2)))\n                         \\<le> rank (hd (meld (t1 # bq1) (t2 # bq2)))", "case 1"], ["proof (state)\nthis:\n  rank_invar []\n  rank_invar bq_\n\ngoal (3 subgoals):\n 1. \\<And>bq.\n       \\<lbrakk>rank_invar []; rank_invar bq\\<rbrakk>\n       \\<Longrightarrow> rank_invar (meld [] bq) \\<and>\n                         min (rank (hd [])) (rank (hd bq))\n                         \\<le> rank (hd (meld [] bq))\n 2. \\<And>v va.\n       \\<lbrakk>rank_invar (v # va); rank_invar []\\<rbrakk>\n       \\<Longrightarrow> rank_invar (meld (v # va) []) \\<and>\n                         min (rank (hd (v # va))) (rank (hd []))\n                         \\<le> rank (hd (meld (v # va) []))\n 3. \\<And>t1 bq1 t2 bq2.\n       \\<lbrakk>\\<lbrakk>rank t1 < rank t2; rank_invar bq1;\n                 rank_invar (t2 # bq2)\\<rbrakk>\n                \\<Longrightarrow> rank_invar (meld bq1 (t2 # bq2)) \\<and>\n                                  min (rank (hd bq1)) (rank (hd (t2 # bq2)))\n                                  \\<le> rank (hd (meld bq1 (t2 # bq2)));\n        \\<lbrakk>\\<not> rank t1 < rank t2; rank t2 < rank t1;\n         rank_invar (t1 # bq1); rank_invar bq2\\<rbrakk>\n        \\<Longrightarrow> rank_invar (meld (t1 # bq1) bq2) \\<and>\n                          min (rank (hd (t1 # bq1))) (rank (hd bq2))\n                          \\<le> rank (hd (meld (t1 # bq1) bq2));\n        \\<lbrakk>\\<not> rank t1 < rank t2; \\<not> rank t2 < rank t1;\n         rank_invar bq1; rank_invar bq2\\<rbrakk>\n        \\<Longrightarrow> rank_invar (meld bq1 bq2) \\<and>\n                          min (rank (hd bq1)) (rank (hd bq2))\n                          \\<le> rank (hd (meld bq1 bq2));\n        rank_invar (t1 # bq1); rank_invar (t2 # bq2)\\<rbrakk>\n       \\<Longrightarrow> rank_invar (meld (t1 # bq1) (t2 # bq2)) \\<and>\n                         min (rank (hd (t1 # bq1))) (rank (hd (t2 # bq2)))\n                         \\<le> rank (hd (meld (t1 # bq1) (t2 # bq2)))", "then"], ["proof (chain)\npicking this:\n  rank_invar []\n  rank_invar bq_", "show ?case"], ["proof (prove)\nusing this:\n  rank_invar []\n  rank_invar bq_\n\ngoal (1 subgoal):\n 1. rank_invar (meld [] bq_) \\<and>\n    min (rank (hd [])) (rank (hd bq_)) \\<le> rank (hd (meld [] bq_))", "by simp"], ["proof (state)\nthis:\n  rank_invar (meld [] bq_) \\<and>\n  min (rank (hd [])) (rank (hd bq_)) \\<le> rank (hd (meld [] bq_))\n\ngoal (2 subgoals):\n 1. \\<And>v va.\n       \\<lbrakk>rank_invar (v # va); rank_invar []\\<rbrakk>\n       \\<Longrightarrow> rank_invar (meld (v # va) []) \\<and>\n                         min (rank (hd (v # va))) (rank (hd []))\n                         \\<le> rank (hd (meld (v # va) []))\n 2. \\<And>t1 bq1 t2 bq2.\n       \\<lbrakk>\\<lbrakk>rank t1 < rank t2; rank_invar bq1;\n                 rank_invar (t2 # bq2)\\<rbrakk>\n                \\<Longrightarrow> rank_invar (meld bq1 (t2 # bq2)) \\<and>\n                                  min (rank (hd bq1)) (rank (hd (t2 # bq2)))\n                                  \\<le> rank (hd (meld bq1 (t2 # bq2)));\n        \\<lbrakk>\\<not> rank t1 < rank t2; rank t2 < rank t1;\n         rank_invar (t1 # bq1); rank_invar bq2\\<rbrakk>\n        \\<Longrightarrow> rank_invar (meld (t1 # bq1) bq2) \\<and>\n                          min (rank (hd (t1 # bq1))) (rank (hd bq2))\n                          \\<le> rank (hd (meld (t1 # bq1) bq2));\n        \\<lbrakk>\\<not> rank t1 < rank t2; \\<not> rank t2 < rank t1;\n         rank_invar bq1; rank_invar bq2\\<rbrakk>\n        \\<Longrightarrow> rank_invar (meld bq1 bq2) \\<and>\n                          min (rank (hd bq1)) (rank (hd bq2))\n                          \\<le> rank (hd (meld bq1 bq2));\n        rank_invar (t1 # bq1); rank_invar (t2 # bq2)\\<rbrakk>\n       \\<Longrightarrow> rank_invar (meld (t1 # bq1) (t2 # bq2)) \\<and>\n                         min (rank (hd (t1 # bq1))) (rank (hd (t2 # bq2)))\n                         \\<le> rank (hd (meld (t1 # bq1) (t2 # bq2)))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>v va.\n       \\<lbrakk>rank_invar (v # va); rank_invar []\\<rbrakk>\n       \\<Longrightarrow> rank_invar (meld (v # va) []) \\<and>\n                         min (rank (hd (v # va))) (rank (hd []))\n                         \\<le> rank (hd (meld (v # va) []))\n 2. \\<And>t1 bq1 t2 bq2.\n       \\<lbrakk>\\<lbrakk>rank t1 < rank t2; rank_invar bq1;\n                 rank_invar (t2 # bq2)\\<rbrakk>\n                \\<Longrightarrow> rank_invar (meld bq1 (t2 # bq2)) \\<and>\n                                  min (rank (hd bq1)) (rank (hd (t2 # bq2)))\n                                  \\<le> rank (hd (meld bq1 (t2 # bq2)));\n        \\<lbrakk>\\<not> rank t1 < rank t2; rank t2 < rank t1;\n         rank_invar (t1 # bq1); rank_invar bq2\\<rbrakk>\n        \\<Longrightarrow> rank_invar (meld (t1 # bq1) bq2) \\<and>\n                          min (rank (hd (t1 # bq1))) (rank (hd bq2))\n                          \\<le> rank (hd (meld (t1 # bq1) bq2));\n        \\<lbrakk>\\<not> rank t1 < rank t2; \\<not> rank t2 < rank t1;\n         rank_invar bq1; rank_invar bq2\\<rbrakk>\n        \\<Longrightarrow> rank_invar (meld bq1 bq2) \\<and>\n                          min (rank (hd bq1)) (rank (hd bq2))\n                          \\<le> rank (hd (meld bq1 bq2));\n        rank_invar (t1 # bq1); rank_invar (t2 # bq2)\\<rbrakk>\n       \\<Longrightarrow> rank_invar (meld (t1 # bq1) (t2 # bq2)) \\<and>\n                         min (rank (hd (t1 # bq1))) (rank (hd (t2 # bq2)))\n                         \\<le> rank (hd (meld (t1 # bq1) (t2 # bq2)))", "case 2"], ["proof (state)\nthis:\n  rank_invar (v_ # va_)\n  rank_invar []\n\ngoal (2 subgoals):\n 1. \\<And>v va.\n       \\<lbrakk>rank_invar (v # va); rank_invar []\\<rbrakk>\n       \\<Longrightarrow> rank_invar (meld (v # va) []) \\<and>\n                         min (rank (hd (v # va))) (rank (hd []))\n                         \\<le> rank (hd (meld (v # va) []))\n 2. \\<And>t1 bq1 t2 bq2.\n       \\<lbrakk>\\<lbrakk>rank t1 < rank t2; rank_invar bq1;\n                 rank_invar (t2 # bq2)\\<rbrakk>\n                \\<Longrightarrow> rank_invar (meld bq1 (t2 # bq2)) \\<and>\n                                  min (rank (hd bq1)) (rank (hd (t2 # bq2)))\n                                  \\<le> rank (hd (meld bq1 (t2 # bq2)));\n        \\<lbrakk>\\<not> rank t1 < rank t2; rank t2 < rank t1;\n         rank_invar (t1 # bq1); rank_invar bq2\\<rbrakk>\n        \\<Longrightarrow> rank_invar (meld (t1 # bq1) bq2) \\<and>\n                          min (rank (hd (t1 # bq1))) (rank (hd bq2))\n                          \\<le> rank (hd (meld (t1 # bq1) bq2));\n        \\<lbrakk>\\<not> rank t1 < rank t2; \\<not> rank t2 < rank t1;\n         rank_invar bq1; rank_invar bq2\\<rbrakk>\n        \\<Longrightarrow> rank_invar (meld bq1 bq2) \\<and>\n                          min (rank (hd bq1)) (rank (hd bq2))\n                          \\<le> rank (hd (meld bq1 bq2));\n        rank_invar (t1 # bq1); rank_invar (t2 # bq2)\\<rbrakk>\n       \\<Longrightarrow> rank_invar (meld (t1 # bq1) (t2 # bq2)) \\<and>\n                         min (rank (hd (t1 # bq1))) (rank (hd (t2 # bq2)))\n                         \\<le> rank (hd (meld (t1 # bq1) (t2 # bq2)))", "then"], ["proof (chain)\npicking this:\n  rank_invar (v_ # va_)\n  rank_invar []", "show ?case"], ["proof (prove)\nusing this:\n  rank_invar (v_ # va_)\n  rank_invar []\n\ngoal (1 subgoal):\n 1. rank_invar (meld (v_ # va_) []) \\<and>\n    min (rank (hd (v_ # va_))) (rank (hd []))\n    \\<le> rank (hd (meld (v_ # va_) []))", "by simp"], ["proof (state)\nthis:\n  rank_invar (meld (v_ # va_) []) \\<and>\n  min (rank (hd (v_ # va_))) (rank (hd []))\n  \\<le> rank (hd (meld (v_ # va_) []))\n\ngoal (1 subgoal):\n 1. \\<And>t1 bq1 t2 bq2.\n       \\<lbrakk>\\<lbrakk>rank t1 < rank t2; rank_invar bq1;\n                 rank_invar (t2 # bq2)\\<rbrakk>\n                \\<Longrightarrow> rank_invar (meld bq1 (t2 # bq2)) \\<and>\n                                  min (rank (hd bq1)) (rank (hd (t2 # bq2)))\n                                  \\<le> rank (hd (meld bq1 (t2 # bq2)));\n        \\<lbrakk>\\<not> rank t1 < rank t2; rank t2 < rank t1;\n         rank_invar (t1 # bq1); rank_invar bq2\\<rbrakk>\n        \\<Longrightarrow> rank_invar (meld (t1 # bq1) bq2) \\<and>\n                          min (rank (hd (t1 # bq1))) (rank (hd bq2))\n                          \\<le> rank (hd (meld (t1 # bq1) bq2));\n        \\<lbrakk>\\<not> rank t1 < rank t2; \\<not> rank t2 < rank t1;\n         rank_invar bq1; rank_invar bq2\\<rbrakk>\n        \\<Longrightarrow> rank_invar (meld bq1 bq2) \\<and>\n                          min (rank (hd bq1)) (rank (hd bq2))\n                          \\<le> rank (hd (meld bq1 bq2));\n        rank_invar (t1 # bq1); rank_invar (t2 # bq2)\\<rbrakk>\n       \\<Longrightarrow> rank_invar (meld (t1 # bq1) (t2 # bq2)) \\<and>\n                         min (rank (hd (t1 # bq1))) (rank (hd (t2 # bq2)))\n                         \\<le> rank (hd (meld (t1 # bq1) (t2 # bq2)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t1 bq1 t2 bq2.\n       \\<lbrakk>\\<lbrakk>rank t1 < rank t2; rank_invar bq1;\n                 rank_invar (t2 # bq2)\\<rbrakk>\n                \\<Longrightarrow> rank_invar (meld bq1 (t2 # bq2)) \\<and>\n                                  min (rank (hd bq1)) (rank (hd (t2 # bq2)))\n                                  \\<le> rank (hd (meld bq1 (t2 # bq2)));\n        \\<lbrakk>\\<not> rank t1 < rank t2; rank t2 < rank t1;\n         rank_invar (t1 # bq1); rank_invar bq2\\<rbrakk>\n        \\<Longrightarrow> rank_invar (meld (t1 # bq1) bq2) \\<and>\n                          min (rank (hd (t1 # bq1))) (rank (hd bq2))\n                          \\<le> rank (hd (meld (t1 # bq1) bq2));\n        \\<lbrakk>\\<not> rank t1 < rank t2; \\<not> rank t2 < rank t1;\n         rank_invar bq1; rank_invar bq2\\<rbrakk>\n        \\<Longrightarrow> rank_invar (meld bq1 bq2) \\<and>\n                          min (rank (hd bq1)) (rank (hd bq2))\n                          \\<le> rank (hd (meld bq1 bq2));\n        rank_invar (t1 # bq1); rank_invar (t2 # bq2)\\<rbrakk>\n       \\<Longrightarrow> rank_invar (meld (t1 # bq1) (t2 # bq2)) \\<and>\n                         min (rank (hd (t1 # bq1))) (rank (hd (t2 # bq2)))\n                         \\<le> rank (hd (meld (t1 # bq1) (t2 # bq2)))", "case (3 t1 bq1 t2 bq2)"], ["proof (state)\nthis:\n  \\<lbrakk>rank t1 < rank t2; rank_invar bq1; rank_invar (t2 # bq2)\\<rbrakk>\n  \\<Longrightarrow> rank_invar (meld bq1 (t2 # bq2)) \\<and>\n                    min (rank (hd bq1)) (rank (hd (t2 # bq2)))\n                    \\<le> rank (hd (meld bq1 (t2 # bq2)))\n  \\<lbrakk>\\<not> rank t1 < rank t2; rank t2 < rank t1;\n   rank_invar (t1 # bq1); rank_invar bq2\\<rbrakk>\n  \\<Longrightarrow> rank_invar (meld (t1 # bq1) bq2) \\<and>\n                    min (rank (hd (t1 # bq1))) (rank (hd bq2))\n                    \\<le> rank (hd (meld (t1 # bq1) bq2))\n  \\<lbrakk>\\<not> rank t1 < rank t2; \\<not> rank t2 < rank t1;\n   rank_invar bq1; rank_invar bq2\\<rbrakk>\n  \\<Longrightarrow> rank_invar (meld bq1 bq2) \\<and>\n                    min (rank (hd bq1)) (rank (hd bq2))\n                    \\<le> rank (hd (meld bq1 bq2))\n  rank_invar (t1 # bq1)\n  rank_invar (t2 # bq2)\n\ngoal (1 subgoal):\n 1. \\<And>t1 bq1 t2 bq2.\n       \\<lbrakk>\\<lbrakk>rank t1 < rank t2; rank_invar bq1;\n                 rank_invar (t2 # bq2)\\<rbrakk>\n                \\<Longrightarrow> rank_invar (meld bq1 (t2 # bq2)) \\<and>\n                                  min (rank (hd bq1)) (rank (hd (t2 # bq2)))\n                                  \\<le> rank (hd (meld bq1 (t2 # bq2)));\n        \\<lbrakk>\\<not> rank t1 < rank t2; rank t2 < rank t1;\n         rank_invar (t1 # bq1); rank_invar bq2\\<rbrakk>\n        \\<Longrightarrow> rank_invar (meld (t1 # bq1) bq2) \\<and>\n                          min (rank (hd (t1 # bq1))) (rank (hd bq2))\n                          \\<le> rank (hd (meld (t1 # bq1) bq2));\n        \\<lbrakk>\\<not> rank t1 < rank t2; \\<not> rank t2 < rank t1;\n         rank_invar bq1; rank_invar bq2\\<rbrakk>\n        \\<Longrightarrow> rank_invar (meld bq1 bq2) \\<and>\n                          min (rank (hd bq1)) (rank (hd bq2))\n                          \\<le> rank (hd (meld bq1 bq2));\n        rank_invar (t1 # bq1); rank_invar (t2 # bq2)\\<rbrakk>\n       \\<Longrightarrow> rank_invar (meld (t1 # bq1) (t2 # bq2)) \\<and>\n                         min (rank (hd (t1 # bq1))) (rank (hd (t2 # bq2)))\n                         \\<le> rank (hd (meld (t1 # bq1) (t2 # bq2)))", "from 3"], ["proof (chain)\npicking this:\n  \\<lbrakk>rank t1 < rank t2; rank_invar bq1; rank_invar (t2 # bq2)\\<rbrakk>\n  \\<Longrightarrow> rank_invar (meld bq1 (t2 # bq2)) \\<and>\n                    min (rank (hd bq1)) (rank (hd (t2 # bq2)))\n                    \\<le> rank (hd (meld bq1 (t2 # bq2)))\n  \\<lbrakk>\\<not> rank t1 < rank t2; rank t2 < rank t1;\n   rank_invar (t1 # bq1); rank_invar bq2\\<rbrakk>\n  \\<Longrightarrow> rank_invar (meld (t1 # bq1) bq2) \\<and>\n                    min (rank (hd (t1 # bq1))) (rank (hd bq2))\n                    \\<le> rank (hd (meld (t1 # bq1) bq2))\n  \\<lbrakk>\\<not> rank t1 < rank t2; \\<not> rank t2 < rank t1;\n   rank_invar bq1; rank_invar bq2\\<rbrakk>\n  \\<Longrightarrow> rank_invar (meld bq1 bq2) \\<and>\n                    min (rank (hd bq1)) (rank (hd bq2))\n                    \\<le> rank (hd (meld bq1 bq2))\n  rank_invar (t1 # bq1)\n  rank_invar (t2 # bq2)", "have inv1: \"rank_invar bq1\""], ["proof (prove)\nusing this:\n  \\<lbrakk>rank t1 < rank t2; rank_invar bq1; rank_invar (t2 # bq2)\\<rbrakk>\n  \\<Longrightarrow> rank_invar (meld bq1 (t2 # bq2)) \\<and>\n                    min (rank (hd bq1)) (rank (hd (t2 # bq2)))\n                    \\<le> rank (hd (meld bq1 (t2 # bq2)))\n  \\<lbrakk>\\<not> rank t1 < rank t2; rank t2 < rank t1;\n   rank_invar (t1 # bq1); rank_invar bq2\\<rbrakk>\n  \\<Longrightarrow> rank_invar (meld (t1 # bq1) bq2) \\<and>\n                    min (rank (hd (t1 # bq1))) (rank (hd bq2))\n                    \\<le> rank (hd (meld (t1 # bq1) bq2))\n  \\<lbrakk>\\<not> rank t1 < rank t2; \\<not> rank t2 < rank t1;\n   rank_invar bq1; rank_invar bq2\\<rbrakk>\n  \\<Longrightarrow> rank_invar (meld bq1 bq2) \\<and>\n                    min (rank (hd bq1)) (rank (hd bq2))\n                    \\<le> rank (hd (meld bq1 bq2))\n  rank_invar (t1 # bq1)\n  rank_invar (t2 # bq2)\n\ngoal (1 subgoal):\n 1. rank_invar bq1", "by (cases bq1) simp_all"], ["proof (state)\nthis:\n  rank_invar bq1\n\ngoal (1 subgoal):\n 1. \\<And>t1 bq1 t2 bq2.\n       \\<lbrakk>\\<lbrakk>rank t1 < rank t2; rank_invar bq1;\n                 rank_invar (t2 # bq2)\\<rbrakk>\n                \\<Longrightarrow> rank_invar (meld bq1 (t2 # bq2)) \\<and>\n                                  min (rank (hd bq1)) (rank (hd (t2 # bq2)))\n                                  \\<le> rank (hd (meld bq1 (t2 # bq2)));\n        \\<lbrakk>\\<not> rank t1 < rank t2; rank t2 < rank t1;\n         rank_invar (t1 # bq1); rank_invar bq2\\<rbrakk>\n        \\<Longrightarrow> rank_invar (meld (t1 # bq1) bq2) \\<and>\n                          min (rank (hd (t1 # bq1))) (rank (hd bq2))\n                          \\<le> rank (hd (meld (t1 # bq1) bq2));\n        \\<lbrakk>\\<not> rank t1 < rank t2; \\<not> rank t2 < rank t1;\n         rank_invar bq1; rank_invar bq2\\<rbrakk>\n        \\<Longrightarrow> rank_invar (meld bq1 bq2) \\<and>\n                          min (rank (hd bq1)) (rank (hd bq2))\n                          \\<le> rank (hd (meld bq1 bq2));\n        rank_invar (t1 # bq1); rank_invar (t2 # bq2)\\<rbrakk>\n       \\<Longrightarrow> rank_invar (meld (t1 # bq1) (t2 # bq2)) \\<and>\n                         min (rank (hd (t1 # bq1))) (rank (hd (t2 # bq2)))\n                         \\<le> rank (hd (meld (t1 # bq1) (t2 # bq2)))", "from 3"], ["proof (chain)\npicking this:\n  \\<lbrakk>rank t1 < rank t2; rank_invar bq1; rank_invar (t2 # bq2)\\<rbrakk>\n  \\<Longrightarrow> rank_invar (meld bq1 (t2 # bq2)) \\<and>\n                    min (rank (hd bq1)) (rank (hd (t2 # bq2)))\n                    \\<le> rank (hd (meld bq1 (t2 # bq2)))\n  \\<lbrakk>\\<not> rank t1 < rank t2; rank t2 < rank t1;\n   rank_invar (t1 # bq1); rank_invar bq2\\<rbrakk>\n  \\<Longrightarrow> rank_invar (meld (t1 # bq1) bq2) \\<and>\n                    min (rank (hd (t1 # bq1))) (rank (hd bq2))\n                    \\<le> rank (hd (meld (t1 # bq1) bq2))\n  \\<lbrakk>\\<not> rank t1 < rank t2; \\<not> rank t2 < rank t1;\n   rank_invar bq1; rank_invar bq2\\<rbrakk>\n  \\<Longrightarrow> rank_invar (meld bq1 bq2) \\<and>\n                    min (rank (hd bq1)) (rank (hd bq2))\n                    \\<le> rank (hd (meld bq1 bq2))\n  rank_invar (t1 # bq1)\n  rank_invar (t2 # bq2)", "have inv2: \"rank_invar bq2\""], ["proof (prove)\nusing this:\n  \\<lbrakk>rank t1 < rank t2; rank_invar bq1; rank_invar (t2 # bq2)\\<rbrakk>\n  \\<Longrightarrow> rank_invar (meld bq1 (t2 # bq2)) \\<and>\n                    min (rank (hd bq1)) (rank (hd (t2 # bq2)))\n                    \\<le> rank (hd (meld bq1 (t2 # bq2)))\n  \\<lbrakk>\\<not> rank t1 < rank t2; rank t2 < rank t1;\n   rank_invar (t1 # bq1); rank_invar bq2\\<rbrakk>\n  \\<Longrightarrow> rank_invar (meld (t1 # bq1) bq2) \\<and>\n                    min (rank (hd (t1 # bq1))) (rank (hd bq2))\n                    \\<le> rank (hd (meld (t1 # bq1) bq2))\n  \\<lbrakk>\\<not> rank t1 < rank t2; \\<not> rank t2 < rank t1;\n   rank_invar bq1; rank_invar bq2\\<rbrakk>\n  \\<Longrightarrow> rank_invar (meld bq1 bq2) \\<and>\n                    min (rank (hd bq1)) (rank (hd bq2))\n                    \\<le> rank (hd (meld bq1 bq2))\n  rank_invar (t1 # bq1)\n  rank_invar (t2 # bq2)\n\ngoal (1 subgoal):\n 1. rank_invar bq2", "by (cases bq2) simp_all"], ["proof (state)\nthis:\n  rank_invar bq2\n\ngoal (1 subgoal):\n 1. \\<And>t1 bq1 t2 bq2.\n       \\<lbrakk>\\<lbrakk>rank t1 < rank t2; rank_invar bq1;\n                 rank_invar (t2 # bq2)\\<rbrakk>\n                \\<Longrightarrow> rank_invar (meld bq1 (t2 # bq2)) \\<and>\n                                  min (rank (hd bq1)) (rank (hd (t2 # bq2)))\n                                  \\<le> rank (hd (meld bq1 (t2 # bq2)));\n        \\<lbrakk>\\<not> rank t1 < rank t2; rank t2 < rank t1;\n         rank_invar (t1 # bq1); rank_invar bq2\\<rbrakk>\n        \\<Longrightarrow> rank_invar (meld (t1 # bq1) bq2) \\<and>\n                          min (rank (hd (t1 # bq1))) (rank (hd bq2))\n                          \\<le> rank (hd (meld (t1 # bq1) bq2));\n        \\<lbrakk>\\<not> rank t1 < rank t2; \\<not> rank t2 < rank t1;\n         rank_invar bq1; rank_invar bq2\\<rbrakk>\n        \\<Longrightarrow> rank_invar (meld bq1 bq2) \\<and>\n                          min (rank (hd bq1)) (rank (hd bq2))\n                          \\<le> rank (hd (meld bq1 bq2));\n        rank_invar (t1 # bq1); rank_invar (t2 # bq2)\\<rbrakk>\n       \\<Longrightarrow> rank_invar (meld (t1 # bq1) (t2 # bq2)) \\<and>\n                         min (rank (hd (t1 # bq1))) (rank (hd (t2 # bq2)))\n                         \\<le> rank (hd (meld (t1 # bq1) (t2 # bq2)))", "from inv1 and inv2 and 3"], ["proof (chain)\npicking this:\n  rank_invar bq1\n  rank_invar bq2\n  \\<lbrakk>rank t1 < rank t2; rank_invar bq1; rank_invar (t2 # bq2)\\<rbrakk>\n  \\<Longrightarrow> rank_invar (meld bq1 (t2 # bq2)) \\<and>\n                    min (rank (hd bq1)) (rank (hd (t2 # bq2)))\n                    \\<le> rank (hd (meld bq1 (t2 # bq2)))\n  \\<lbrakk>\\<not> rank t1 < rank t2; rank t2 < rank t1;\n   rank_invar (t1 # bq1); rank_invar bq2\\<rbrakk>\n  \\<Longrightarrow> rank_invar (meld (t1 # bq1) bq2) \\<and>\n                    min (rank (hd (t1 # bq1))) (rank (hd bq2))\n                    \\<le> rank (hd (meld (t1 # bq1) bq2))\n  \\<lbrakk>\\<not> rank t1 < rank t2; \\<not> rank t2 < rank t1;\n   rank_invar bq1; rank_invar bq2\\<rbrakk>\n  \\<Longrightarrow> rank_invar (meld bq1 bq2) \\<and>\n                    min (rank (hd bq1)) (rank (hd bq2))\n                    \\<le> rank (hd (meld bq1 bq2))\n  rank_invar (t1 # bq1)\n  rank_invar (t2 # bq2)", "show ?case"], ["proof (prove)\nusing this:\n  rank_invar bq1\n  rank_invar bq2\n  \\<lbrakk>rank t1 < rank t2; rank_invar bq1; rank_invar (t2 # bq2)\\<rbrakk>\n  \\<Longrightarrow> rank_invar (meld bq1 (t2 # bq2)) \\<and>\n                    min (rank (hd bq1)) (rank (hd (t2 # bq2)))\n                    \\<le> rank (hd (meld bq1 (t2 # bq2)))\n  \\<lbrakk>\\<not> rank t1 < rank t2; rank t2 < rank t1;\n   rank_invar (t1 # bq1); rank_invar bq2\\<rbrakk>\n  \\<Longrightarrow> rank_invar (meld (t1 # bq1) bq2) \\<and>\n                    min (rank (hd (t1 # bq1))) (rank (hd bq2))\n                    \\<le> rank (hd (meld (t1 # bq1) bq2))\n  \\<lbrakk>\\<not> rank t1 < rank t2; \\<not> rank t2 < rank t1;\n   rank_invar bq1; rank_invar bq2\\<rbrakk>\n  \\<Longrightarrow> rank_invar (meld bq1 bq2) \\<and>\n                    min (rank (hd bq1)) (rank (hd bq2))\n                    \\<le> rank (hd (meld bq1 bq2))\n  rank_invar (t1 # bq1)\n  rank_invar (t2 # bq2)\n\ngoal (1 subgoal):\n 1. rank_invar (meld (t1 # bq1) (t2 # bq2)) \\<and>\n    min (rank (hd (t1 # bq1))) (rank (hd (t2 # bq2)))\n    \\<le> rank (hd (meld (t1 # bq1) (t2 # bq2)))", "proof (auto, goal_cases)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<lbrakk>rank_invar bq1; rank_invar bq2; rank_invar (t1 # bq1);\n     rank_invar (t2 # bq2); rank t2 < rank t1;\n     rank_invar (meld (t1 # bq1) bq2);\n     min (rank t1) (rank (hd bq2))\n     \\<le> rank (hd (meld (t1 # bq1) bq2))\\<rbrakk>\n    \\<Longrightarrow> rank_invar (t2 # meld (t1 # bq1) bq2)\n 2. \\<lbrakk>rank_invar bq1; rank_invar bq2; rank_invar (t1 # bq1);\n     rank_invar (t2 # bq2); rank t1 < rank t2;\n     rank_invar (meld bq1 (t2 # bq2));\n     min (rank (hd bq1)) (rank t2)\n     \\<le> rank (hd (meld bq1 (t2 # bq2)))\\<rbrakk>\n    \\<Longrightarrow> rank_invar (t1 # meld bq1 (t2 # bq2))\n 3. \\<lbrakk>rank_invar bq1; rank_invar bq2; rank_invar (t1 # bq1);\n     rank_invar (t2 # bq2); rank t1 = rank t2; rank_invar (meld bq1 bq2);\n     min (rank (hd bq1)) (rank (hd bq2))\n     \\<le> rank (hd (meld bq1 bq2))\\<rbrakk>\n    \\<Longrightarrow> rank_invar (ins (link t1 t2) (meld bq1 bq2))\n 4. \\<lbrakk>rank_invar bq1; rank_invar bq2; rank_invar (t1 # bq1);\n     rank_invar (t2 # bq2); rank t1 = rank t2; rank_invar (meld bq1 bq2);\n     min (rank (hd bq1)) (rank (hd bq2))\n     \\<le> rank (hd (meld bq1 bq2))\\<rbrakk>\n    \\<Longrightarrow> rank t2\n                      \\<le> rank (hd (ins (link t1 t2) (meld bq1 bq2)))", "let ?t = \"t2\""], ["proof (state)\ngoal (4 subgoals):\n 1. \\<lbrakk>rank_invar bq1; rank_invar bq2; rank_invar (t1 # bq1);\n     rank_invar (t2 # bq2); rank t2 < rank t1;\n     rank_invar (meld (t1 # bq1) bq2);\n     min (rank t1) (rank (hd bq2))\n     \\<le> rank (hd (meld (t1 # bq1) bq2))\\<rbrakk>\n    \\<Longrightarrow> rank_invar (t2 # meld (t1 # bq1) bq2)\n 2. \\<lbrakk>rank_invar bq1; rank_invar bq2; rank_invar (t1 # bq1);\n     rank_invar (t2 # bq2); rank t1 < rank t2;\n     rank_invar (meld bq1 (t2 # bq2));\n     min (rank (hd bq1)) (rank t2)\n     \\<le> rank (hd (meld bq1 (t2 # bq2)))\\<rbrakk>\n    \\<Longrightarrow> rank_invar (t1 # meld bq1 (t2 # bq2))\n 3. \\<lbrakk>rank_invar bq1; rank_invar bq2; rank_invar (t1 # bq1);\n     rank_invar (t2 # bq2); rank t1 = rank t2; rank_invar (meld bq1 bq2);\n     min (rank (hd bq1)) (rank (hd bq2))\n     \\<le> rank (hd (meld bq1 bq2))\\<rbrakk>\n    \\<Longrightarrow> rank_invar (ins (link t1 t2) (meld bq1 bq2))\n 4. \\<lbrakk>rank_invar bq1; rank_invar bq2; rank_invar (t1 # bq1);\n     rank_invar (t2 # bq2); rank t1 = rank t2; rank_invar (meld bq1 bq2);\n     min (rank (hd bq1)) (rank (hd bq2))\n     \\<le> rank (hd (meld bq1 bq2))\\<rbrakk>\n    \\<Longrightarrow> rank t2\n                      \\<le> rank (hd (ins (link t1 t2) (meld bq1 bq2)))", "let ?bq = \"bq2\""], ["proof (state)\ngoal (4 subgoals):\n 1. \\<lbrakk>rank_invar bq1; rank_invar bq2; rank_invar (t1 # bq1);\n     rank_invar (t2 # bq2); rank t2 < rank t1;\n     rank_invar (meld (t1 # bq1) bq2);\n     min (rank t1) (rank (hd bq2))\n     \\<le> rank (hd (meld (t1 # bq1) bq2))\\<rbrakk>\n    \\<Longrightarrow> rank_invar (t2 # meld (t1 # bq1) bq2)\n 2. \\<lbrakk>rank_invar bq1; rank_invar bq2; rank_invar (t1 # bq1);\n     rank_invar (t2 # bq2); rank t1 < rank t2;\n     rank_invar (meld bq1 (t2 # bq2));\n     min (rank (hd bq1)) (rank t2)\n     \\<le> rank (hd (meld bq1 (t2 # bq2)))\\<rbrakk>\n    \\<Longrightarrow> rank_invar (t1 # meld bq1 (t2 # bq2))\n 3. \\<lbrakk>rank_invar bq1; rank_invar bq2; rank_invar (t1 # bq1);\n     rank_invar (t2 # bq2); rank t1 = rank t2; rank_invar (meld bq1 bq2);\n     min (rank (hd bq1)) (rank (hd bq2))\n     \\<le> rank (hd (meld bq1 bq2))\\<rbrakk>\n    \\<Longrightarrow> rank_invar (ins (link t1 t2) (meld bq1 bq2))\n 4. \\<lbrakk>rank_invar bq1; rank_invar bq2; rank_invar (t1 # bq1);\n     rank_invar (t2 # bq2); rank t1 = rank t2; rank_invar (meld bq1 bq2);\n     min (rank (hd bq1)) (rank (hd bq2))\n     \\<le> rank (hd (meld bq1 bq2))\\<rbrakk>\n    \\<Longrightarrow> rank t2\n                      \\<le> rank (hd (ins (link t1 t2) (meld bq1 bq2)))", "let ?meld = \"rank t2 < rank (hd (meld (t1 # bq1) bq2))\""], ["proof (state)\ngoal (4 subgoals):\n 1. \\<lbrakk>rank_invar bq1; rank_invar bq2; rank_invar (t1 # bq1);\n     rank_invar (t2 # bq2); rank t2 < rank t1;\n     rank_invar (meld (t1 # bq1) bq2);\n     min (rank t1) (rank (hd bq2))\n     \\<le> rank (hd (meld (t1 # bq1) bq2))\\<rbrakk>\n    \\<Longrightarrow> rank_invar (t2 # meld (t1 # bq1) bq2)\n 2. \\<lbrakk>rank_invar bq1; rank_invar bq2; rank_invar (t1 # bq1);\n     rank_invar (t2 # bq2); rank t1 < rank t2;\n     rank_invar (meld bq1 (t2 # bq2));\n     min (rank (hd bq1)) (rank t2)\n     \\<le> rank (hd (meld bq1 (t2 # bq2)))\\<rbrakk>\n    \\<Longrightarrow> rank_invar (t1 # meld bq1 (t2 # bq2))\n 3. \\<lbrakk>rank_invar bq1; rank_invar bq2; rank_invar (t1 # bq1);\n     rank_invar (t2 # bq2); rank t1 = rank t2; rank_invar (meld bq1 bq2);\n     min (rank (hd bq1)) (rank (hd bq2))\n     \\<le> rank (hd (meld bq1 bq2))\\<rbrakk>\n    \\<Longrightarrow> rank_invar (ins (link t1 t2) (meld bq1 bq2))\n 4. \\<lbrakk>rank_invar bq1; rank_invar bq2; rank_invar (t1 # bq1);\n     rank_invar (t2 # bq2); rank t1 = rank t2; rank_invar (meld bq1 bq2);\n     min (rank (hd bq1)) (rank (hd bq2))\n     \\<le> rank (hd (meld bq1 bq2))\\<rbrakk>\n    \\<Longrightarrow> rank t2\n                      \\<le> rank (hd (ins (link t1 t2) (meld bq1 bq2)))", "case prems: 1"], ["proof (state)\nthis:\n  rank_invar bq1\n  rank_invar bq2\n  rank_invar (t1 # bq1)\n  rank_invar (t2 # bq2)\n  rank t2 < rank t1\n  rank_invar (meld (t1 # bq1) bq2)\n  min (rank t1) (rank (hd bq2)) \\<le> rank (hd (meld (t1 # bq1) bq2))\n\ngoal (4 subgoals):\n 1. \\<lbrakk>rank_invar bq1; rank_invar bq2; rank_invar (t1 # bq1);\n     rank_invar (t2 # bq2); rank t2 < rank t1;\n     rank_invar (meld (t1 # bq1) bq2);\n     min (rank t1) (rank (hd bq2))\n     \\<le> rank (hd (meld (t1 # bq1) bq2))\\<rbrakk>\n    \\<Longrightarrow> rank_invar (t2 # meld (t1 # bq1) bq2)\n 2. \\<lbrakk>rank_invar bq1; rank_invar bq2; rank_invar (t1 # bq1);\n     rank_invar (t2 # bq2); rank t1 < rank t2;\n     rank_invar (meld bq1 (t2 # bq2));\n     min (rank (hd bq1)) (rank t2)\n     \\<le> rank (hd (meld bq1 (t2 # bq2)))\\<rbrakk>\n    \\<Longrightarrow> rank_invar (t1 # meld bq1 (t2 # bq2))\n 3. \\<lbrakk>rank_invar bq1; rank_invar bq2; rank_invar (t1 # bq1);\n     rank_invar (t2 # bq2); rank t1 = rank t2; rank_invar (meld bq1 bq2);\n     min (rank (hd bq1)) (rank (hd bq2))\n     \\<le> rank (hd (meld bq1 bq2))\\<rbrakk>\n    \\<Longrightarrow> rank_invar (ins (link t1 t2) (meld bq1 bq2))\n 4. \\<lbrakk>rank_invar bq1; rank_invar bq2; rank_invar (t1 # bq1);\n     rank_invar (t2 # bq2); rank t1 = rank t2; rank_invar (meld bq1 bq2);\n     min (rank (hd bq1)) (rank (hd bq2))\n     \\<le> rank (hd (meld bq1 bq2))\\<rbrakk>\n    \\<Longrightarrow> rank t2\n                      \\<le> rank (hd (ins (link t1 t2) (meld bq1 bq2)))", "hence \"?bq \\<noteq> [] \\<Longrightarrow> rank ?t < rank (hd ?bq)\""], ["proof (prove)\nusing this:\n  rank_invar bq1\n  rank_invar bq2\n  rank_invar (t1 # bq1)\n  rank_invar (t2 # bq2)\n  rank t2 < rank t1\n  rank_invar (meld (t1 # bq1) bq2)\n  min (rank t1) (rank (hd bq2)) \\<le> rank (hd (meld (t1 # bq1) bq2))\n\ngoal (1 subgoal):\n 1. bq2 \\<noteq> [] \\<Longrightarrow> rank t2 < rank (hd bq2)", "by (simp add: rank_invar_not_empty_hd)"], ["proof (state)\nthis:\n  bq2 \\<noteq> [] \\<Longrightarrow> rank t2 < rank (hd bq2)\n\ngoal (4 subgoals):\n 1. \\<lbrakk>rank_invar bq1; rank_invar bq2; rank_invar (t1 # bq1);\n     rank_invar (t2 # bq2); rank t2 < rank t1;\n     rank_invar (meld (t1 # bq1) bq2);\n     min (rank t1) (rank (hd bq2))\n     \\<le> rank (hd (meld (t1 # bq1) bq2))\\<rbrakk>\n    \\<Longrightarrow> rank_invar (t2 # meld (t1 # bq1) bq2)\n 2. \\<lbrakk>rank_invar bq1; rank_invar bq2; rank_invar (t1 # bq1);\n     rank_invar (t2 # bq2); rank t1 < rank t2;\n     rank_invar (meld bq1 (t2 # bq2));\n     min (rank (hd bq1)) (rank t2)\n     \\<le> rank (hd (meld bq1 (t2 # bq2)))\\<rbrakk>\n    \\<Longrightarrow> rank_invar (t1 # meld bq1 (t2 # bq2))\n 3. \\<lbrakk>rank_invar bq1; rank_invar bq2; rank_invar (t1 # bq1);\n     rank_invar (t2 # bq2); rank t1 = rank t2; rank_invar (meld bq1 bq2);\n     min (rank (hd bq1)) (rank (hd bq2))\n     \\<le> rank (hd (meld bq1 bq2))\\<rbrakk>\n    \\<Longrightarrow> rank_invar (ins (link t1 t2) (meld bq1 bq2))\n 4. \\<lbrakk>rank_invar bq1; rank_invar bq2; rank_invar (t1 # bq1);\n     rank_invar (t2 # bq2); rank t1 = rank t2; rank_invar (meld bq1 bq2);\n     min (rank (hd bq1)) (rank (hd bq2))\n     \\<le> rank (hd (meld bq1 bq2))\\<rbrakk>\n    \\<Longrightarrow> rank t2\n                      \\<le> rank (hd (ins (link t1 t2) (meld bq1 bq2)))", "with prems"], ["proof (chain)\npicking this:\n  rank_invar bq1\n  rank_invar bq2\n  rank_invar (t1 # bq1)\n  rank_invar (t2 # bq2)\n  rank t2 < rank t1\n  rank_invar (meld (t1 # bq1) bq2)\n  min (rank t1) (rank (hd bq2)) \\<le> rank (hd (meld (t1 # bq1) bq2))\n  bq2 \\<noteq> [] \\<Longrightarrow> rank t2 < rank (hd bq2)", "have ne: \"?bq \\<noteq> [] \\<Longrightarrow> ?meld\""], ["proof (prove)\nusing this:\n  rank_invar bq1\n  rank_invar bq2\n  rank_invar (t1 # bq1)\n  rank_invar (t2 # bq2)\n  rank t2 < rank t1\n  rank_invar (meld (t1 # bq1) bq2)\n  min (rank t1) (rank (hd bq2)) \\<le> rank (hd (meld (t1 # bq1) bq2))\n  bq2 \\<noteq> [] \\<Longrightarrow> rank t2 < rank (hd bq2)\n\ngoal (1 subgoal):\n 1. bq2 \\<noteq> [] \\<Longrightarrow>\n    rank t2 < rank (hd (meld (t1 # bq1) bq2))", "by simp"], ["proof (state)\nthis:\n  bq2 \\<noteq> [] \\<Longrightarrow>\n  rank t2 < rank (hd (meld (t1 # bq1) bq2))\n\ngoal (4 subgoals):\n 1. \\<lbrakk>rank_invar bq1; rank_invar bq2; rank_invar (t1 # bq1);\n     rank_invar (t2 # bq2); rank t2 < rank t1;\n     rank_invar (meld (t1 # bq1) bq2);\n     min (rank t1) (rank (hd bq2))\n     \\<le> rank (hd (meld (t1 # bq1) bq2))\\<rbrakk>\n    \\<Longrightarrow> rank_invar (t2 # meld (t1 # bq1) bq2)\n 2. \\<lbrakk>rank_invar bq1; rank_invar bq2; rank_invar (t1 # bq1);\n     rank_invar (t2 # bq2); rank t1 < rank t2;\n     rank_invar (meld bq1 (t2 # bq2));\n     min (rank (hd bq1)) (rank t2)\n     \\<le> rank (hd (meld bq1 (t2 # bq2)))\\<rbrakk>\n    \\<Longrightarrow> rank_invar (t1 # meld bq1 (t2 # bq2))\n 3. \\<lbrakk>rank_invar bq1; rank_invar bq2; rank_invar (t1 # bq1);\n     rank_invar (t2 # bq2); rank t1 = rank t2; rank_invar (meld bq1 bq2);\n     min (rank (hd bq1)) (rank (hd bq2))\n     \\<le> rank (hd (meld bq1 bq2))\\<rbrakk>\n    \\<Longrightarrow> rank_invar (ins (link t1 t2) (meld bq1 bq2))\n 4. \\<lbrakk>rank_invar bq1; rank_invar bq2; rank_invar (t1 # bq1);\n     rank_invar (t2 # bq2); rank t1 = rank t2; rank_invar (meld bq1 bq2);\n     min (rank (hd bq1)) (rank (hd bq2))\n     \\<le> rank (hd (meld bq1 bq2))\\<rbrakk>\n    \\<Longrightarrow> rank t2\n                      \\<le> rank (hd (ins (link t1 t2) (meld bq1 bq2)))", "from prems"], ["proof (chain)\npicking this:\n  rank_invar bq1\n  rank_invar bq2\n  rank_invar (t1 # bq1)\n  rank_invar (t2 # bq2)\n  rank t2 < rank t1\n  rank_invar (meld (t1 # bq1) bq2)\n  min (rank t1) (rank (hd bq2)) \\<le> rank (hd (meld (t1 # bq1) bq2))", "have \"?bq = [] \\<Longrightarrow> ?meld\""], ["proof (prove)\nusing this:\n  rank_invar bq1\n  rank_invar bq2\n  rank_invar (t1 # bq1)\n  rank_invar (t2 # bq2)\n  rank t2 < rank t1\n  rank_invar (meld (t1 # bq1) bq2)\n  min (rank t1) (rank (hd bq2)) \\<le> rank (hd (meld (t1 # bq1) bq2))\n\ngoal (1 subgoal):\n 1. bq2 = [] \\<Longrightarrow> rank t2 < rank (hd (meld (t1 # bq1) bq2))", "by simp"], ["proof (state)\nthis:\n  bq2 = [] \\<Longrightarrow> rank t2 < rank (hd (meld (t1 # bq1) bq2))\n\ngoal (4 subgoals):\n 1. \\<lbrakk>rank_invar bq1; rank_invar bq2; rank_invar (t1 # bq1);\n     rank_invar (t2 # bq2); rank t2 < rank t1;\n     rank_invar (meld (t1 # bq1) bq2);\n     min (rank t1) (rank (hd bq2))\n     \\<le> rank (hd (meld (t1 # bq1) bq2))\\<rbrakk>\n    \\<Longrightarrow> rank_invar (t2 # meld (t1 # bq1) bq2)\n 2. \\<lbrakk>rank_invar bq1; rank_invar bq2; rank_invar (t1 # bq1);\n     rank_invar (t2 # bq2); rank t1 < rank t2;\n     rank_invar (meld bq1 (t2 # bq2));\n     min (rank (hd bq1)) (rank t2)\n     \\<le> rank (hd (meld bq1 (t2 # bq2)))\\<rbrakk>\n    \\<Longrightarrow> rank_invar (t1 # meld bq1 (t2 # bq2))\n 3. \\<lbrakk>rank_invar bq1; rank_invar bq2; rank_invar (t1 # bq1);\n     rank_invar (t2 # bq2); rank t1 = rank t2; rank_invar (meld bq1 bq2);\n     min (rank (hd bq1)) (rank (hd bq2))\n     \\<le> rank (hd (meld bq1 bq2))\\<rbrakk>\n    \\<Longrightarrow> rank_invar (ins (link t1 t2) (meld bq1 bq2))\n 4. \\<lbrakk>rank_invar bq1; rank_invar bq2; rank_invar (t1 # bq1);\n     rank_invar (t2 # bq2); rank t1 = rank t2; rank_invar (meld bq1 bq2);\n     min (rank (hd bq1)) (rank (hd bq2))\n     \\<le> rank (hd (meld bq1 bq2))\\<rbrakk>\n    \\<Longrightarrow> rank t2\n                      \\<le> rank (hd (ins (link t1 t2) (meld bq1 bq2)))", "with ne"], ["proof (chain)\npicking this:\n  bq2 \\<noteq> [] \\<Longrightarrow>\n  rank t2 < rank (hd (meld (t1 # bq1) bq2))\n  bq2 = [] \\<Longrightarrow> rank t2 < rank (hd (meld (t1 # bq1) bq2))", "have \"?meld\""], ["proof (prove)\nusing this:\n  bq2 \\<noteq> [] \\<Longrightarrow>\n  rank t2 < rank (hd (meld (t1 # bq1) bq2))\n  bq2 = [] \\<Longrightarrow> rank t2 < rank (hd (meld (t1 # bq1) bq2))\n\ngoal (1 subgoal):\n 1. rank t2 < rank (hd (meld (t1 # bq1) bq2))", "by (cases \"?bq = []\")"], ["proof (state)\nthis:\n  rank t2 < rank (hd (meld (t1 # bq1) bq2))\n\ngoal (4 subgoals):\n 1. \\<lbrakk>rank_invar bq1; rank_invar bq2; rank_invar (t1 # bq1);\n     rank_invar (t2 # bq2); rank t2 < rank t1;\n     rank_invar (meld (t1 # bq1) bq2);\n     min (rank t1) (rank (hd bq2))\n     \\<le> rank (hd (meld (t1 # bq1) bq2))\\<rbrakk>\n    \\<Longrightarrow> rank_invar (t2 # meld (t1 # bq1) bq2)\n 2. \\<lbrakk>rank_invar bq1; rank_invar bq2; rank_invar (t1 # bq1);\n     rank_invar (t2 # bq2); rank t1 < rank t2;\n     rank_invar (meld bq1 (t2 # bq2));\n     min (rank (hd bq1)) (rank t2)\n     \\<le> rank (hd (meld bq1 (t2 # bq2)))\\<rbrakk>\n    \\<Longrightarrow> rank_invar (t1 # meld bq1 (t2 # bq2))\n 3. \\<lbrakk>rank_invar bq1; rank_invar bq2; rank_invar (t1 # bq1);\n     rank_invar (t2 # bq2); rank t1 = rank t2; rank_invar (meld bq1 bq2);\n     min (rank (hd bq1)) (rank (hd bq2))\n     \\<le> rank (hd (meld bq1 bq2))\\<rbrakk>\n    \\<Longrightarrow> rank_invar (ins (link t1 t2) (meld bq1 bq2))\n 4. \\<lbrakk>rank_invar bq1; rank_invar bq2; rank_invar (t1 # bq1);\n     rank_invar (t2 # bq2); rank t1 = rank t2; rank_invar (meld bq1 bq2);\n     min (rank (hd bq1)) (rank (hd bq2))\n     \\<le> rank (hd (meld bq1 bq2))\\<rbrakk>\n    \\<Longrightarrow> rank t2\n                      \\<le> rank (hd (ins (link t1 t2) (meld bq1 bq2)))", "with prems"], ["proof (chain)\npicking this:\n  rank_invar bq1\n  rank_invar bq2\n  rank_invar (t1 # bq1)\n  rank_invar (t2 # bq2)\n  rank t2 < rank t1\n  rank_invar (meld (t1 # bq1) bq2)\n  min (rank t1) (rank (hd bq2)) \\<le> rank (hd (meld (t1 # bq1) bq2))\n  rank t2 < rank (hd (meld (t1 # bq1) bq2))", "show ?case"], ["proof (prove)\nusing this:\n  rank_invar bq1\n  rank_invar bq2\n  rank_invar (t1 # bq1)\n  rank_invar (t2 # bq2)\n  rank t2 < rank t1\n  rank_invar (meld (t1 # bq1) bq2)\n  min (rank t1) (rank (hd bq2)) \\<le> rank (hd (meld (t1 # bq1) bq2))\n  rank t2 < rank (hd (meld (t1 # bq1) bq2))\n\ngoal (1 subgoal):\n 1. rank_invar (t2 # meld (t1 # bq1) bq2)", "by (simp add: rank_invar_hd_cons)"], ["proof (state)\nthis:\n  rank_invar (t2 # meld (t1 # bq1) bq2)\n\ngoal (3 subgoals):\n 1. \\<lbrakk>rank_invar bq1; rank_invar bq2; rank_invar (t1 # bq1);\n     rank_invar (t2 # bq2); rank t1 < rank t2;\n     rank_invar (meld bq1 (t2 # bq2));\n     min (rank (hd bq1)) (rank t2)\n     \\<le> rank (hd (meld bq1 (t2 # bq2)))\\<rbrakk>\n    \\<Longrightarrow> rank_invar (t1 # meld bq1 (t2 # bq2))\n 2. \\<lbrakk>rank_invar bq1; rank_invar bq2; rank_invar (t1 # bq1);\n     rank_invar (t2 # bq2); rank t1 = rank t2; rank_invar (meld bq1 bq2);\n     min (rank (hd bq1)) (rank (hd bq2))\n     \\<le> rank (hd (meld bq1 bq2))\\<rbrakk>\n    \\<Longrightarrow> rank_invar (ins (link t1 t2) (meld bq1 bq2))\n 3. \\<lbrakk>rank_invar bq1; rank_invar bq2; rank_invar (t1 # bq1);\n     rank_invar (t2 # bq2); rank t1 = rank t2; rank_invar (meld bq1 bq2);\n     min (rank (hd bq1)) (rank (hd bq2))\n     \\<le> rank (hd (meld bq1 bq2))\\<rbrakk>\n    \\<Longrightarrow> rank t2\n                      \\<le> rank (hd (ins (link t1 t2) (meld bq1 bq2)))", "next \\<comment> \\<open>analog\\<close>"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>rank_invar bq1; rank_invar bq2; rank_invar (t1 # bq1);\n     rank_invar (t2 # bq2); rank t1 < rank t2;\n     rank_invar (meld bq1 (t2 # bq2));\n     min (rank (hd bq1)) (rank t2)\n     \\<le> rank (hd (meld bq1 (t2 # bq2)))\\<rbrakk>\n    \\<Longrightarrow> rank_invar (t1 # meld bq1 (t2 # bq2))\n 2. \\<lbrakk>rank_invar bq1; rank_invar bq2; rank_invar (t1 # bq1);\n     rank_invar (t2 # bq2); rank t1 = rank t2; rank_invar (meld bq1 bq2);\n     min (rank (hd bq1)) (rank (hd bq2))\n     \\<le> rank (hd (meld bq1 bq2))\\<rbrakk>\n    \\<Longrightarrow> rank_invar (ins (link t1 t2) (meld bq1 bq2))\n 3. \\<lbrakk>rank_invar bq1; rank_invar bq2; rank_invar (t1 # bq1);\n     rank_invar (t2 # bq2); rank t1 = rank t2; rank_invar (meld bq1 bq2);\n     min (rank (hd bq1)) (rank (hd bq2))\n     \\<le> rank (hd (meld bq1 bq2))\\<rbrakk>\n    \\<Longrightarrow> rank t2\n                      \\<le> rank (hd (ins (link t1 t2) (meld bq1 bq2)))", "let ?t = \"t1\""], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>rank_invar bq1; rank_invar bq2; rank_invar (t1 # bq1);\n     rank_invar (t2 # bq2); rank t1 < rank t2;\n     rank_invar (meld bq1 (t2 # bq2));\n     min (rank (hd bq1)) (rank t2)\n     \\<le> rank (hd (meld bq1 (t2 # bq2)))\\<rbrakk>\n    \\<Longrightarrow> rank_invar (t1 # meld bq1 (t2 # bq2))\n 2. \\<lbrakk>rank_invar bq1; rank_invar bq2; rank_invar (t1 # bq1);\n     rank_invar (t2 # bq2); rank t1 = rank t2; rank_invar (meld bq1 bq2);\n     min (rank (hd bq1)) (rank (hd bq2))\n     \\<le> rank (hd (meld bq1 bq2))\\<rbrakk>\n    \\<Longrightarrow> rank_invar (ins (link t1 t2) (meld bq1 bq2))\n 3. \\<lbrakk>rank_invar bq1; rank_invar bq2; rank_invar (t1 # bq1);\n     rank_invar (t2 # bq2); rank t1 = rank t2; rank_invar (meld bq1 bq2);\n     min (rank (hd bq1)) (rank (hd bq2))\n     \\<le> rank (hd (meld bq1 bq2))\\<rbrakk>\n    \\<Longrightarrow> rank t2\n                      \\<le> rank (hd (ins (link t1 t2) (meld bq1 bq2)))", "let ?bq = \"bq1\""], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>rank_invar bq1; rank_invar bq2; rank_invar (t1 # bq1);\n     rank_invar (t2 # bq2); rank t1 < rank t2;\n     rank_invar (meld bq1 (t2 # bq2));\n     min (rank (hd bq1)) (rank t2)\n     \\<le> rank (hd (meld bq1 (t2 # bq2)))\\<rbrakk>\n    \\<Longrightarrow> rank_invar (t1 # meld bq1 (t2 # bq2))\n 2. \\<lbrakk>rank_invar bq1; rank_invar bq2; rank_invar (t1 # bq1);\n     rank_invar (t2 # bq2); rank t1 = rank t2; rank_invar (meld bq1 bq2);\n     min (rank (hd bq1)) (rank (hd bq2))\n     \\<le> rank (hd (meld bq1 bq2))\\<rbrakk>\n    \\<Longrightarrow> rank_invar (ins (link t1 t2) (meld bq1 bq2))\n 3. \\<lbrakk>rank_invar bq1; rank_invar bq2; rank_invar (t1 # bq1);\n     rank_invar (t2 # bq2); rank t1 = rank t2; rank_invar (meld bq1 bq2);\n     min (rank (hd bq1)) (rank (hd bq2))\n     \\<le> rank (hd (meld bq1 bq2))\\<rbrakk>\n    \\<Longrightarrow> rank t2\n                      \\<le> rank (hd (ins (link t1 t2) (meld bq1 bq2)))", "let ?meld = \"rank t1 < rank (hd (meld bq1 (t2 # bq2)))\""], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>rank_invar bq1; rank_invar bq2; rank_invar (t1 # bq1);\n     rank_invar (t2 # bq2); rank t1 < rank t2;\n     rank_invar (meld bq1 (t2 # bq2));\n     min (rank (hd bq1)) (rank t2)\n     \\<le> rank (hd (meld bq1 (t2 # bq2)))\\<rbrakk>\n    \\<Longrightarrow> rank_invar (t1 # meld bq1 (t2 # bq2))\n 2. \\<lbrakk>rank_invar bq1; rank_invar bq2; rank_invar (t1 # bq1);\n     rank_invar (t2 # bq2); rank t1 = rank t2; rank_invar (meld bq1 bq2);\n     min (rank (hd bq1)) (rank (hd bq2))\n     \\<le> rank (hd (meld bq1 bq2))\\<rbrakk>\n    \\<Longrightarrow> rank_invar (ins (link t1 t2) (meld bq1 bq2))\n 3. \\<lbrakk>rank_invar bq1; rank_invar bq2; rank_invar (t1 # bq1);\n     rank_invar (t2 # bq2); rank t1 = rank t2; rank_invar (meld bq1 bq2);\n     min (rank (hd bq1)) (rank (hd bq2))\n     \\<le> rank (hd (meld bq1 bq2))\\<rbrakk>\n    \\<Longrightarrow> rank t2\n                      \\<le> rank (hd (ins (link t1 t2) (meld bq1 bq2)))", "case prems: 2"], ["proof (state)\nthis:\n  rank_invar bq1\n  rank_invar bq2\n  rank_invar (t1 # bq1)\n  rank_invar (t2 # bq2)\n  rank t1 < rank t2\n  rank_invar (meld bq1 (t2 # bq2))\n  min (rank (hd bq1)) (rank t2) \\<le> rank (hd (meld bq1 (t2 # bq2)))\n\ngoal (3 subgoals):\n 1. \\<lbrakk>rank_invar bq1; rank_invar bq2; rank_invar (t1 # bq1);\n     rank_invar (t2 # bq2); rank t1 < rank t2;\n     rank_invar (meld bq1 (t2 # bq2));\n     min (rank (hd bq1)) (rank t2)\n     \\<le> rank (hd (meld bq1 (t2 # bq2)))\\<rbrakk>\n    \\<Longrightarrow> rank_invar (t1 # meld bq1 (t2 # bq2))\n 2. \\<lbrakk>rank_invar bq1; rank_invar bq2; rank_invar (t1 # bq1);\n     rank_invar (t2 # bq2); rank t1 = rank t2; rank_invar (meld bq1 bq2);\n     min (rank (hd bq1)) (rank (hd bq2))\n     \\<le> rank (hd (meld bq1 bq2))\\<rbrakk>\n    \\<Longrightarrow> rank_invar (ins (link t1 t2) (meld bq1 bq2))\n 3. \\<lbrakk>rank_invar bq1; rank_invar bq2; rank_invar (t1 # bq1);\n     rank_invar (t2 # bq2); rank t1 = rank t2; rank_invar (meld bq1 bq2);\n     min (rank (hd bq1)) (rank (hd bq2))\n     \\<le> rank (hd (meld bq1 bq2))\\<rbrakk>\n    \\<Longrightarrow> rank t2\n                      \\<le> rank (hd (ins (link t1 t2) (meld bq1 bq2)))", "hence \"?bq \\<noteq> [] \\<Longrightarrow> rank ?t < rank (hd ?bq)\""], ["proof (prove)\nusing this:\n  rank_invar bq1\n  rank_invar bq2\n  rank_invar (t1 # bq1)\n  rank_invar (t2 # bq2)\n  rank t1 < rank t2\n  rank_invar (meld bq1 (t2 # bq2))\n  min (rank (hd bq1)) (rank t2) \\<le> rank (hd (meld bq1 (t2 # bq2)))\n\ngoal (1 subgoal):\n 1. bq1 \\<noteq> [] \\<Longrightarrow> rank t1 < rank (hd bq1)", "by (simp add: rank_invar_not_empty_hd)"], ["proof (state)\nthis:\n  bq1 \\<noteq> [] \\<Longrightarrow> rank t1 < rank (hd bq1)\n\ngoal (3 subgoals):\n 1. \\<lbrakk>rank_invar bq1; rank_invar bq2; rank_invar (t1 # bq1);\n     rank_invar (t2 # bq2); rank t1 < rank t2;\n     rank_invar (meld bq1 (t2 # bq2));\n     min (rank (hd bq1)) (rank t2)\n     \\<le> rank (hd (meld bq1 (t2 # bq2)))\\<rbrakk>\n    \\<Longrightarrow> rank_invar (t1 # meld bq1 (t2 # bq2))\n 2. \\<lbrakk>rank_invar bq1; rank_invar bq2; rank_invar (t1 # bq1);\n     rank_invar (t2 # bq2); rank t1 = rank t2; rank_invar (meld bq1 bq2);\n     min (rank (hd bq1)) (rank (hd bq2))\n     \\<le> rank (hd (meld bq1 bq2))\\<rbrakk>\n    \\<Longrightarrow> rank_invar (ins (link t1 t2) (meld bq1 bq2))\n 3. \\<lbrakk>rank_invar bq1; rank_invar bq2; rank_invar (t1 # bq1);\n     rank_invar (t2 # bq2); rank t1 = rank t2; rank_invar (meld bq1 bq2);\n     min (rank (hd bq1)) (rank (hd bq2))\n     \\<le> rank (hd (meld bq1 bq2))\\<rbrakk>\n    \\<Longrightarrow> rank t2\n                      \\<le> rank (hd (ins (link t1 t2) (meld bq1 bq2)))", "with prems"], ["proof (chain)\npicking this:\n  rank_invar bq1\n  rank_invar bq2\n  rank_invar (t1 # bq1)\n  rank_invar (t2 # bq2)\n  rank t1 < rank t2\n  rank_invar (meld bq1 (t2 # bq2))\n  min (rank (hd bq1)) (rank t2) \\<le> rank (hd (meld bq1 (t2 # bq2)))\n  bq1 \\<noteq> [] \\<Longrightarrow> rank t1 < rank (hd bq1)", "have ne: \"?bq \\<noteq> [] \\<Longrightarrow> ?meld\""], ["proof (prove)\nusing this:\n  rank_invar bq1\n  rank_invar bq2\n  rank_invar (t1 # bq1)\n  rank_invar (t2 # bq2)\n  rank t1 < rank t2\n  rank_invar (meld bq1 (t2 # bq2))\n  min (rank (hd bq1)) (rank t2) \\<le> rank (hd (meld bq1 (t2 # bq2)))\n  bq1 \\<noteq> [] \\<Longrightarrow> rank t1 < rank (hd bq1)\n\ngoal (1 subgoal):\n 1. bq1 \\<noteq> [] \\<Longrightarrow>\n    rank t1 < rank (hd (meld bq1 (t2 # bq2)))", "by simp"], ["proof (state)\nthis:\n  bq1 \\<noteq> [] \\<Longrightarrow>\n  rank t1 < rank (hd (meld bq1 (t2 # bq2)))\n\ngoal (3 subgoals):\n 1. \\<lbrakk>rank_invar bq1; rank_invar bq2; rank_invar (t1 # bq1);\n     rank_invar (t2 # bq2); rank t1 < rank t2;\n     rank_invar (meld bq1 (t2 # bq2));\n     min (rank (hd bq1)) (rank t2)\n     \\<le> rank (hd (meld bq1 (t2 # bq2)))\\<rbrakk>\n    \\<Longrightarrow> rank_invar (t1 # meld bq1 (t2 # bq2))\n 2. \\<lbrakk>rank_invar bq1; rank_invar bq2; rank_invar (t1 # bq1);\n     rank_invar (t2 # bq2); rank t1 = rank t2; rank_invar (meld bq1 bq2);\n     min (rank (hd bq1)) (rank (hd bq2))\n     \\<le> rank (hd (meld bq1 bq2))\\<rbrakk>\n    \\<Longrightarrow> rank_invar (ins (link t1 t2) (meld bq1 bq2))\n 3. \\<lbrakk>rank_invar bq1; rank_invar bq2; rank_invar (t1 # bq1);\n     rank_invar (t2 # bq2); rank t1 = rank t2; rank_invar (meld bq1 bq2);\n     min (rank (hd bq1)) (rank (hd bq2))\n     \\<le> rank (hd (meld bq1 bq2))\\<rbrakk>\n    \\<Longrightarrow> rank t2\n                      \\<le> rank (hd (ins (link t1 t2) (meld bq1 bq2)))", "from prems"], ["proof (chain)\npicking this:\n  rank_invar bq1\n  rank_invar bq2\n  rank_invar (t1 # bq1)\n  rank_invar (t2 # bq2)\n  rank t1 < rank t2\n  rank_invar (meld bq1 (t2 # bq2))\n  min (rank (hd bq1)) (rank t2) \\<le> rank (hd (meld bq1 (t2 # bq2)))", "have \"?bq = [] \\<Longrightarrow> ?meld\""], ["proof (prove)\nusing this:\n  rank_invar bq1\n  rank_invar bq2\n  rank_invar (t1 # bq1)\n  rank_invar (t2 # bq2)\n  rank t1 < rank t2\n  rank_invar (meld bq1 (t2 # bq2))\n  min (rank (hd bq1)) (rank t2) \\<le> rank (hd (meld bq1 (t2 # bq2)))\n\ngoal (1 subgoal):\n 1. bq1 = [] \\<Longrightarrow> rank t1 < rank (hd (meld bq1 (t2 # bq2)))", "by simp"], ["proof (state)\nthis:\n  bq1 = [] \\<Longrightarrow> rank t1 < rank (hd (meld bq1 (t2 # bq2)))\n\ngoal (3 subgoals):\n 1. \\<lbrakk>rank_invar bq1; rank_invar bq2; rank_invar (t1 # bq1);\n     rank_invar (t2 # bq2); rank t1 < rank t2;\n     rank_invar (meld bq1 (t2 # bq2));\n     min (rank (hd bq1)) (rank t2)\n     \\<le> rank (hd (meld bq1 (t2 # bq2)))\\<rbrakk>\n    \\<Longrightarrow> rank_invar (t1 # meld bq1 (t2 # bq2))\n 2. \\<lbrakk>rank_invar bq1; rank_invar bq2; rank_invar (t1 # bq1);\n     rank_invar (t2 # bq2); rank t1 = rank t2; rank_invar (meld bq1 bq2);\n     min (rank (hd bq1)) (rank (hd bq2))\n     \\<le> rank (hd (meld bq1 bq2))\\<rbrakk>\n    \\<Longrightarrow> rank_invar (ins (link t1 t2) (meld bq1 bq2))\n 3. \\<lbrakk>rank_invar bq1; rank_invar bq2; rank_invar (t1 # bq1);\n     rank_invar (t2 # bq2); rank t1 = rank t2; rank_invar (meld bq1 bq2);\n     min (rank (hd bq1)) (rank (hd bq2))\n     \\<le> rank (hd (meld bq1 bq2))\\<rbrakk>\n    \\<Longrightarrow> rank t2\n                      \\<le> rank (hd (ins (link t1 t2) (meld bq1 bq2)))", "with ne"], ["proof (chain)\npicking this:\n  bq1 \\<noteq> [] \\<Longrightarrow>\n  rank t1 < rank (hd (meld bq1 (t2 # bq2)))\n  bq1 = [] \\<Longrightarrow> rank t1 < rank (hd (meld bq1 (t2 # bq2)))", "have \"?meld\""], ["proof (prove)\nusing this:\n  bq1 \\<noteq> [] \\<Longrightarrow>\n  rank t1 < rank (hd (meld bq1 (t2 # bq2)))\n  bq1 = [] \\<Longrightarrow> rank t1 < rank (hd (meld bq1 (t2 # bq2)))\n\ngoal (1 subgoal):\n 1. rank t1 < rank (hd (meld bq1 (t2 # bq2)))", "by (cases \"?bq = []\")"], ["proof (state)\nthis:\n  rank t1 < rank (hd (meld bq1 (t2 # bq2)))\n\ngoal (3 subgoals):\n 1. \\<lbrakk>rank_invar bq1; rank_invar bq2; rank_invar (t1 # bq1);\n     rank_invar (t2 # bq2); rank t1 < rank t2;\n     rank_invar (meld bq1 (t2 # bq2));\n     min (rank (hd bq1)) (rank t2)\n     \\<le> rank (hd (meld bq1 (t2 # bq2)))\\<rbrakk>\n    \\<Longrightarrow> rank_invar (t1 # meld bq1 (t2 # bq2))\n 2. \\<lbrakk>rank_invar bq1; rank_invar bq2; rank_invar (t1 # bq1);\n     rank_invar (t2 # bq2); rank t1 = rank t2; rank_invar (meld bq1 bq2);\n     min (rank (hd bq1)) (rank (hd bq2))\n     \\<le> rank (hd (meld bq1 bq2))\\<rbrakk>\n    \\<Longrightarrow> rank_invar (ins (link t1 t2) (meld bq1 bq2))\n 3. \\<lbrakk>rank_invar bq1; rank_invar bq2; rank_invar (t1 # bq1);\n     rank_invar (t2 # bq2); rank t1 = rank t2; rank_invar (meld bq1 bq2);\n     min (rank (hd bq1)) (rank (hd bq2))\n     \\<le> rank (hd (meld bq1 bq2))\\<rbrakk>\n    \\<Longrightarrow> rank t2\n                      \\<le> rank (hd (ins (link t1 t2) (meld bq1 bq2)))", "with prems"], ["proof (chain)\npicking this:\n  rank_invar bq1\n  rank_invar bq2\n  rank_invar (t1 # bq1)\n  rank_invar (t2 # bq2)\n  rank t1 < rank t2\n  rank_invar (meld bq1 (t2 # bq2))\n  min (rank (hd bq1)) (rank t2) \\<le> rank (hd (meld bq1 (t2 # bq2)))\n  rank t1 < rank (hd (meld bq1 (t2 # bq2)))", "show ?case"], ["proof (prove)\nusing this:\n  rank_invar bq1\n  rank_invar bq2\n  rank_invar (t1 # bq1)\n  rank_invar (t2 # bq2)\n  rank t1 < rank t2\n  rank_invar (meld bq1 (t2 # bq2))\n  min (rank (hd bq1)) (rank t2) \\<le> rank (hd (meld bq1 (t2 # bq2)))\n  rank t1 < rank (hd (meld bq1 (t2 # bq2)))\n\ngoal (1 subgoal):\n 1. rank_invar (t1 # meld bq1 (t2 # bq2))", "by (simp add: rank_invar_hd_cons)"], ["proof (state)\nthis:\n  rank_invar (t1 # meld bq1 (t2 # bq2))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>rank_invar bq1; rank_invar bq2; rank_invar (t1 # bq1);\n     rank_invar (t2 # bq2); rank t1 = rank t2; rank_invar (meld bq1 bq2);\n     min (rank (hd bq1)) (rank (hd bq2))\n     \\<le> rank (hd (meld bq1 bq2))\\<rbrakk>\n    \\<Longrightarrow> rank_invar (ins (link t1 t2) (meld bq1 bq2))\n 2. \\<lbrakk>rank_invar bq1; rank_invar bq2; rank_invar (t1 # bq1);\n     rank_invar (t2 # bq2); rank t1 = rank t2; rank_invar (meld bq1 bq2);\n     min (rank (hd bq1)) (rank (hd bq2))\n     \\<le> rank (hd (meld bq1 bq2))\\<rbrakk>\n    \\<Longrightarrow> rank t2\n                      \\<le> rank (hd (ins (link t1 t2) (meld bq1 bq2)))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>rank_invar bq1; rank_invar bq2; rank_invar (t1 # bq1);\n     rank_invar (t2 # bq2); rank t1 = rank t2; rank_invar (meld bq1 bq2);\n     min (rank (hd bq1)) (rank (hd bq2))\n     \\<le> rank (hd (meld bq1 bq2))\\<rbrakk>\n    \\<Longrightarrow> rank_invar (ins (link t1 t2) (meld bq1 bq2))\n 2. \\<lbrakk>rank_invar bq1; rank_invar bq2; rank_invar (t1 # bq1);\n     rank_invar (t2 # bq2); rank t1 = rank t2; rank_invar (meld bq1 bq2);\n     min (rank (hd bq1)) (rank (hd bq2))\n     \\<le> rank (hd (meld bq1 bq2))\\<rbrakk>\n    \\<Longrightarrow> rank t2\n                      \\<le> rank (hd (ins (link t1 t2) (meld bq1 bq2)))", "case 3"], ["proof (state)\nthis:\n  rank_invar bq1\n  rank_invar bq2\n  rank_invar (t1 # bq1)\n  rank_invar (t2 # bq2)\n  rank t1 = rank t2\n  rank_invar (meld bq1 bq2)\n  min (rank (hd bq1)) (rank (hd bq2)) \\<le> rank (hd (meld bq1 bq2))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>rank_invar bq1; rank_invar bq2; rank_invar (t1 # bq1);\n     rank_invar (t2 # bq2); rank t1 = rank t2; rank_invar (meld bq1 bq2);\n     min (rank (hd bq1)) (rank (hd bq2))\n     \\<le> rank (hd (meld bq1 bq2))\\<rbrakk>\n    \\<Longrightarrow> rank_invar (ins (link t1 t2) (meld bq1 bq2))\n 2. \\<lbrakk>rank_invar bq1; rank_invar bq2; rank_invar (t1 # bq1);\n     rank_invar (t2 # bq2); rank t1 = rank t2; rank_invar (meld bq1 bq2);\n     min (rank (hd bq1)) (rank (hd bq2))\n     \\<le> rank (hd (meld bq1 bq2))\\<rbrakk>\n    \\<Longrightarrow> rank t2\n                      \\<le> rank (hd (ins (link t1 t2) (meld bq1 bq2)))", "thus ?case"], ["proof (prove)\nusing this:\n  rank_invar bq1\n  rank_invar bq2\n  rank_invar (t1 # bq1)\n  rank_invar (t2 # bq2)\n  rank t1 = rank t2\n  rank_invar (meld bq1 bq2)\n  min (rank (hd bq1)) (rank (hd bq2)) \\<le> rank (hd (meld bq1 bq2))\n\ngoal (1 subgoal):\n 1. rank_invar (ins (link t1 t2) (meld bq1 bq2))", "by (simp add: rank_invar_ins)"], ["proof (state)\nthis:\n  rank_invar (ins (link t1 t2) (meld bq1 bq2))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>rank_invar bq1; rank_invar bq2; rank_invar (t1 # bq1);\n     rank_invar (t2 # bq2); rank t1 = rank t2; rank_invar (meld bq1 bq2);\n     min (rank (hd bq1)) (rank (hd bq2))\n     \\<le> rank (hd (meld bq1 bq2))\\<rbrakk>\n    \\<Longrightarrow> rank t2\n                      \\<le> rank (hd (ins (link t1 t2) (meld bq1 bq2)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>rank_invar bq1; rank_invar bq2; rank_invar (t1 # bq1);\n     rank_invar (t2 # bq2); rank t1 = rank t2; rank_invar (meld bq1 bq2);\n     min (rank (hd bq1)) (rank (hd bq2))\n     \\<le> rank (hd (meld bq1 bq2))\\<rbrakk>\n    \\<Longrightarrow> rank t2\n                      \\<le> rank (hd (ins (link t1 t2) (meld bq1 bq2)))", "case prems: 4"], ["proof (state)\nthis:\n  rank_invar bq1\n  rank_invar bq2\n  rank_invar (t1 # bq1)\n  rank_invar (t2 # bq2)\n  rank t1 = rank t2\n  rank_invar (meld bq1 bq2)\n  min (rank (hd bq1)) (rank (hd bq2)) \\<le> rank (hd (meld bq1 bq2))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>rank_invar bq1; rank_invar bq2; rank_invar (t1 # bq1);\n     rank_invar (t2 # bq2); rank t1 = rank t2; rank_invar (meld bq1 bq2);\n     min (rank (hd bq1)) (rank (hd bq2))\n     \\<le> rank (hd (meld bq1 bq2))\\<rbrakk>\n    \\<Longrightarrow> rank t2\n                      \\<le> rank (hd (ins (link t1 t2) (meld bq1 bq2)))", "(* Ab hier wirds h?sslich *)"], ["proof (state)\nthis:\n  rank_invar bq1\n  rank_invar bq2\n  rank_invar (t1 # bq1)\n  rank_invar (t2 # bq2)\n  rank t1 = rank t2\n  rank_invar (meld bq1 bq2)\n  min (rank (hd bq1)) (rank (hd bq2)) \\<le> rank (hd (meld bq1 bq2))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>rank_invar bq1; rank_invar bq2; rank_invar (t1 # bq1);\n     rank_invar (t2 # bq2); rank t1 = rank t2; rank_invar (meld bq1 bq2);\n     min (rank (hd bq1)) (rank (hd bq2))\n     \\<le> rank (hd (meld bq1 bq2))\\<rbrakk>\n    \\<Longrightarrow> rank t2\n                      \\<le> rank (hd (ins (link t1 t2) (meld bq1 bq2)))", "then"], ["proof (chain)\npicking this:\n  rank_invar bq1\n  rank_invar bq2\n  rank_invar (t1 # bq1)\n  rank_invar (t2 # bq2)\n  rank t1 = rank t2\n  rank_invar (meld bq1 bq2)\n  min (rank (hd bq1)) (rank (hd bq2)) \\<le> rank (hd (meld bq1 bq2))", "have r: \"rank (link t1 t2) = rank t2 + 1\""], ["proof (prove)\nusing this:\n  rank_invar bq1\n  rank_invar bq2\n  rank_invar (t1 # bq1)\n  rank_invar (t2 # bq2)\n  rank t1 = rank t2\n  rank_invar (meld bq1 bq2)\n  min (rank (hd bq1)) (rank (hd bq2)) \\<le> rank (hd (meld bq1 bq2))\n\ngoal (1 subgoal):\n 1. rank (link t1 t2) = rank t2 + 1", "by (simp add: rank_link)"], ["proof (state)\nthis:\n  rank (link t1 t2) = rank t2 + 1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>rank_invar bq1; rank_invar bq2; rank_invar (t1 # bq1);\n     rank_invar (t2 # bq2); rank t1 = rank t2; rank_invar (meld bq1 bq2);\n     min (rank (hd bq1)) (rank (hd bq2))\n     \\<le> rank (hd (meld bq1 bq2))\\<rbrakk>\n    \\<Longrightarrow> rank t2\n                      \\<le> rank (hd (ins (link t1 t2) (meld bq1 bq2)))", "have m: \"meld bq1 [] = bq1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. meld bq1 [] = bq1", "by (cases bq1, auto)"], ["proof (state)\nthis:\n  meld bq1 [] = bq1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>rank_invar bq1; rank_invar bq2; rank_invar (t1 # bq1);\n     rank_invar (t2 # bq2); rank t1 = rank t2; rank_invar (meld bq1 bq2);\n     min (rank (hd bq1)) (rank (hd bq2))\n     \\<le> rank (hd (meld bq1 bq2))\\<rbrakk>\n    \\<Longrightarrow> rank t2\n                      \\<le> rank (hd (ins (link t1 t2) (meld bq1 bq2)))", "from inv1 and inv2 and prems"], ["proof (chain)\npicking this:\n  rank_invar bq1\n  rank_invar bq2\n  rank_invar bq1\n  rank_invar bq2\n  rank_invar (t1 # bq1)\n  rank_invar (t2 # bq2)\n  rank t1 = rank t2\n  rank_invar (meld bq1 bq2)\n  min (rank (hd bq1)) (rank (hd bq2)) \\<le> rank (hd (meld bq1 bq2))", "have mm: \"min (rank (hd bq1)) (rank (hd bq2)) \\<le> rank (hd (meld bq1 bq2))\""], ["proof (prove)\nusing this:\n  rank_invar bq1\n  rank_invar bq2\n  rank_invar bq1\n  rank_invar bq2\n  rank_invar (t1 # bq1)\n  rank_invar (t2 # bq2)\n  rank t1 = rank t2\n  rank_invar (meld bq1 bq2)\n  min (rank (hd bq1)) (rank (hd bq2)) \\<le> rank (hd (meld bq1 bq2))\n\ngoal (1 subgoal):\n 1. min (rank (hd bq1)) (rank (hd bq2)) \\<le> rank (hd (meld bq1 bq2))", "by simp"], ["proof (state)\nthis:\n  min (rank (hd bq1)) (rank (hd bq2)) \\<le> rank (hd (meld bq1 bq2))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>rank_invar bq1; rank_invar bq2; rank_invar (t1 # bq1);\n     rank_invar (t2 # bq2); rank t1 = rank t2; rank_invar (meld bq1 bq2);\n     min (rank (hd bq1)) (rank (hd bq2))\n     \\<le> rank (hd (meld bq1 bq2))\\<rbrakk>\n    \\<Longrightarrow> rank t2\n                      \\<le> rank (hd (ins (link t1 t2) (meld bq1 bq2)))", "from \\<open>rank_invar (t1 # bq1)\\<close>"], ["proof (chain)\npicking this:\n  rank_invar (t1 # bq1)", "have \"bq1 \\<noteq> [] \\<Longrightarrow> rank t1 < rank (hd bq1)\""], ["proof (prove)\nusing this:\n  rank_invar (t1 # bq1)\n\ngoal (1 subgoal):\n 1. bq1 \\<noteq> [] \\<Longrightarrow> rank t1 < rank (hd bq1)", "by (simp add: rank_invar_not_empty_hd)"], ["proof (state)\nthis:\n  bq1 \\<noteq> [] \\<Longrightarrow> rank t1 < rank (hd bq1)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>rank_invar bq1; rank_invar bq2; rank_invar (t1 # bq1);\n     rank_invar (t2 # bq2); rank t1 = rank t2; rank_invar (meld bq1 bq2);\n     min (rank (hd bq1)) (rank (hd bq2))\n     \\<le> rank (hd (meld bq1 bq2))\\<rbrakk>\n    \\<Longrightarrow> rank t2\n                      \\<le> rank (hd (ins (link t1 t2) (meld bq1 bq2)))", "with prems"], ["proof (chain)\npicking this:\n  rank_invar bq1\n  rank_invar bq2\n  rank_invar (t1 # bq1)\n  rank_invar (t2 # bq2)\n  rank t1 = rank t2\n  rank_invar (meld bq1 bq2)\n  min (rank (hd bq1)) (rank (hd bq2)) \\<le> rank (hd (meld bq1 bq2))\n  bq1 \\<noteq> [] \\<Longrightarrow> rank t1 < rank (hd bq1)", "have r1: \"bq1 \\<noteq> [] \\<Longrightarrow> rank t2 < rank (hd bq1)\""], ["proof (prove)\nusing this:\n  rank_invar bq1\n  rank_invar bq2\n  rank_invar (t1 # bq1)\n  rank_invar (t2 # bq2)\n  rank t1 = rank t2\n  rank_invar (meld bq1 bq2)\n  min (rank (hd bq1)) (rank (hd bq2)) \\<le> rank (hd (meld bq1 bq2))\n  bq1 \\<noteq> [] \\<Longrightarrow> rank t1 < rank (hd bq1)\n\ngoal (1 subgoal):\n 1. bq1 \\<noteq> [] \\<Longrightarrow> rank t2 < rank (hd bq1)", "by simp"], ["proof (state)\nthis:\n  bq1 \\<noteq> [] \\<Longrightarrow> rank t2 < rank (hd bq1)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>rank_invar bq1; rank_invar bq2; rank_invar (t1 # bq1);\n     rank_invar (t2 # bq2); rank t1 = rank t2; rank_invar (meld bq1 bq2);\n     min (rank (hd bq1)) (rank (hd bq2))\n     \\<le> rank (hd (meld bq1 bq2))\\<rbrakk>\n    \\<Longrightarrow> rank t2\n                      \\<le> rank (hd (ins (link t1 t2) (meld bq1 bq2)))", "from \\<open>rank_invar (t2 # bq2)\\<close>"], ["proof (chain)\npicking this:\n  rank_invar (t2 # bq2)", "have r2: \"bq2 \\<noteq> [] \\<Longrightarrow> rank t2 < rank (hd bq2)\""], ["proof (prove)\nusing this:\n  rank_invar (t2 # bq2)\n\ngoal (1 subgoal):\n 1. bq2 \\<noteq> [] \\<Longrightarrow> rank t2 < rank (hd bq2)", "by (simp add: rank_invar_not_empty_hd)"], ["proof (state)\nthis:\n  bq2 \\<noteq> [] \\<Longrightarrow> rank t2 < rank (hd bq2)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>rank_invar bq1; rank_invar bq2; rank_invar (t1 # bq1);\n     rank_invar (t2 # bq2); rank t1 = rank t2; rank_invar (meld bq1 bq2);\n     min (rank (hd bq1)) (rank (hd bq2))\n     \\<le> rank (hd (meld bq1 bq2))\\<rbrakk>\n    \\<Longrightarrow> rank t2\n                      \\<le> rank (hd (ins (link t1 t2) (meld bq1 bq2)))", "from inv1 r r1 rank_ins_min[of bq1 \"(link t1 t2)\"]"], ["proof (chain)\npicking this:\n  rank_invar bq1\n  rank (link t1 t2) = rank t2 + 1\n  bq1 \\<noteq> [] \\<Longrightarrow> rank t2 < rank (hd bq1)\n  rank_invar bq1 \\<Longrightarrow>\n  min (rank (link t1 t2)) (rank (hd bq1))\n  \\<le> rank (hd (ins (link t1 t2) bq1))", "have abc1: \"bq1 \\<noteq> [] \\<Longrightarrow> rank t2 \\<le> rank (hd (ins (link t1 t2) bq1))\""], ["proof (prove)\nusing this:\n  rank_invar bq1\n  rank (link t1 t2) = rank t2 + 1\n  bq1 \\<noteq> [] \\<Longrightarrow> rank t2 < rank (hd bq1)\n  rank_invar bq1 \\<Longrightarrow>\n  min (rank (link t1 t2)) (rank (hd bq1))\n  \\<le> rank (hd (ins (link t1 t2) bq1))\n\ngoal (1 subgoal):\n 1. bq1 \\<noteq> [] \\<Longrightarrow>\n    rank t2 \\<le> rank (hd (ins (link t1 t2) bq1))", "by simp"], ["proof (state)\nthis:\n  bq1 \\<noteq> [] \\<Longrightarrow>\n  rank t2 \\<le> rank (hd (ins (link t1 t2) bq1))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>rank_invar bq1; rank_invar bq2; rank_invar (t1 # bq1);\n     rank_invar (t2 # bq2); rank t1 = rank t2; rank_invar (meld bq1 bq2);\n     min (rank (hd bq1)) (rank (hd bq2))\n     \\<le> rank (hd (meld bq1 bq2))\\<rbrakk>\n    \\<Longrightarrow> rank t2\n                      \\<le> rank (hd (ins (link t1 t2) (meld bq1 bq2)))", "from inv2 r r2 rank_ins_min[of bq2 \"(link t1 t2)\"]"], ["proof (chain)\npicking this:\n  rank_invar bq2\n  rank (link t1 t2) = rank t2 + 1\n  bq2 \\<noteq> [] \\<Longrightarrow> rank t2 < rank (hd bq2)\n  rank_invar bq2 \\<Longrightarrow>\n  min (rank (link t1 t2)) (rank (hd bq2))\n  \\<le> rank (hd (ins (link t1 t2) bq2))", "have abc2: \"bq2 \\<noteq> [] \\<Longrightarrow> rank t2 \\<le> rank (hd (ins (link t1 t2) bq2))\""], ["proof (prove)\nusing this:\n  rank_invar bq2\n  rank (link t1 t2) = rank t2 + 1\n  bq2 \\<noteq> [] \\<Longrightarrow> rank t2 < rank (hd bq2)\n  rank_invar bq2 \\<Longrightarrow>\n  min (rank (link t1 t2)) (rank (hd bq2))\n  \\<le> rank (hd (ins (link t1 t2) bq2))\n\ngoal (1 subgoal):\n 1. bq2 \\<noteq> [] \\<Longrightarrow>\n    rank t2 \\<le> rank (hd (ins (link t1 t2) bq2))", "by simp"], ["proof (state)\nthis:\n  bq2 \\<noteq> [] \\<Longrightarrow>\n  rank t2 \\<le> rank (hd (ins (link t1 t2) bq2))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>rank_invar bq1; rank_invar bq2; rank_invar (t1 # bq1);\n     rank_invar (t2 # bq2); rank t1 = rank t2; rank_invar (meld bq1 bq2);\n     min (rank (hd bq1)) (rank (hd bq2))\n     \\<le> rank (hd (meld bq1 bq2))\\<rbrakk>\n    \\<Longrightarrow> rank t2\n                      \\<le> rank (hd (ins (link t1 t2) (meld bq1 bq2)))", "from r1 r2 mm"], ["proof (chain)\npicking this:\n  bq1 \\<noteq> [] \\<Longrightarrow> rank t2 < rank (hd bq1)\n  bq2 \\<noteq> [] \\<Longrightarrow> rank t2 < rank (hd bq2)\n  min (rank (hd bq1)) (rank (hd bq2)) \\<le> rank (hd (meld bq1 bq2))", "have \n      \"\\<lbrakk>bq1 \\<noteq> []; bq2 \\<noteq> []\\<rbrakk> \\<Longrightarrow> rank t2 < rank (hd (meld bq1 bq2))\""], ["proof (prove)\nusing this:\n  bq1 \\<noteq> [] \\<Longrightarrow> rank t2 < rank (hd bq1)\n  bq2 \\<noteq> [] \\<Longrightarrow> rank t2 < rank (hd bq2)\n  min (rank (hd bq1)) (rank (hd bq2)) \\<le> rank (hd (meld bq1 bq2))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>bq1 \\<noteq> []; bq2 \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> rank t2 < rank (hd (meld bq1 bq2))", "by simp"], ["proof (state)\nthis:\n  \\<lbrakk>bq1 \\<noteq> []; bq2 \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> rank t2 < rank (hd (meld bq1 bq2))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>rank_invar bq1; rank_invar bq2; rank_invar (t1 # bq1);\n     rank_invar (t2 # bq2); rank t1 = rank t2; rank_invar (meld bq1 bq2);\n     min (rank (hd bq1)) (rank (hd bq2))\n     \\<le> rank (hd (meld bq1 bq2))\\<rbrakk>\n    \\<Longrightarrow> rank t2\n                      \\<le> rank (hd (ins (link t1 t2) (meld bq1 bq2)))", "with \\<open>rank_invar (meld bq1 bq2)\\<close> \n      r rank_ins_min[of \"meld bq1 bq2\" \"link t1 t2\"]"], ["proof (chain)\npicking this:\n  rank_invar (meld bq1 bq2)\n  rank (link t1 t2) = rank t2 + 1\n  rank_invar (meld bq1 bq2) \\<Longrightarrow>\n  min (rank (link t1 t2)) (rank (hd (meld bq1 bq2)))\n  \\<le> rank (hd (ins (link t1 t2) (meld bq1 bq2)))\n  \\<lbrakk>bq1 \\<noteq> []; bq2 \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> rank t2 < rank (hd (meld bq1 bq2))", "have \"\\<lbrakk>bq1 \\<noteq> []; bq2 \\<noteq> []\\<rbrakk> \\<Longrightarrow> \n      rank t2 < rank (hd (ins (link t1 t2) (meld bq1 bq2)))\""], ["proof (prove)\nusing this:\n  rank_invar (meld bq1 bq2)\n  rank (link t1 t2) = rank t2 + 1\n  rank_invar (meld bq1 bq2) \\<Longrightarrow>\n  min (rank (link t1 t2)) (rank (hd (meld bq1 bq2)))\n  \\<le> rank (hd (ins (link t1 t2) (meld bq1 bq2)))\n  \\<lbrakk>bq1 \\<noteq> []; bq2 \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> rank t2 < rank (hd (meld bq1 bq2))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>bq1 \\<noteq> []; bq2 \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> rank t2 < rank (hd (ins (link t1 t2) (meld bq1 bq2)))", "by simp"], ["proof (state)\nthis:\n  \\<lbrakk>bq1 \\<noteq> []; bq2 \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> rank t2 < rank (hd (ins (link t1 t2) (meld bq1 bq2)))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>rank_invar bq1; rank_invar bq2; rank_invar (t1 # bq1);\n     rank_invar (t2 # bq2); rank t1 = rank t2; rank_invar (meld bq1 bq2);\n     min (rank (hd bq1)) (rank (hd bq2))\n     \\<le> rank (hd (meld bq1 bq2))\\<rbrakk>\n    \\<Longrightarrow> rank t2\n                      \\<le> rank (hd (ins (link t1 t2) (meld bq1 bq2)))", "thm rank_ins_min[of \"meld bq1 bq2\" \"link t1 t2\"]"], ["proof (state)\nthis:\n  \\<lbrakk>bq1 \\<noteq> []; bq2 \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> rank t2 < rank (hd (ins (link t1 t2) (meld bq1 bq2)))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>rank_invar bq1; rank_invar bq2; rank_invar (t1 # bq1);\n     rank_invar (t2 # bq2); rank t1 = rank t2; rank_invar (meld bq1 bq2);\n     min (rank (hd bq1)) (rank (hd bq2))\n     \\<le> rank (hd (meld bq1 bq2))\\<rbrakk>\n    \\<Longrightarrow> rank t2\n                      \\<le> rank (hd (ins (link t1 t2) (meld bq1 bq2)))", "with inv1 and inv2 and r m r1"], ["proof (chain)\npicking this:\n  rank_invar bq1\n  rank_invar bq2\n  rank (link t1 t2) = rank t2 + 1\n  meld bq1 [] = bq1\n  bq1 \\<noteq> [] \\<Longrightarrow> rank t2 < rank (hd bq1)\n  \\<lbrakk>bq1 \\<noteq> []; bq2 \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> rank t2 < rank (hd (ins (link t1 t2) (meld bq1 bq2)))", "show ?case"], ["proof (prove)\nusing this:\n  rank_invar bq1\n  rank_invar bq2\n  rank (link t1 t2) = rank t2 + 1\n  meld bq1 [] = bq1\n  bq1 \\<noteq> [] \\<Longrightarrow> rank t2 < rank (hd bq1)\n  \\<lbrakk>bq1 \\<noteq> []; bq2 \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> rank t2 < rank (hd (ins (link t1 t2) (meld bq1 bq2)))\n\ngoal (1 subgoal):\n 1. rank t2 \\<le> rank (hd (ins (link t1 t2) (meld bq1 bq2)))", "apply(cases \"bq2 = []\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>rank_invar bq1; rank_invar bq2;\n     rank (link t1 t2) = rank t2 + 1; meld bq1 [] = bq1;\n     bq1 \\<noteq> [] \\<Longrightarrow> rank t2 < rank (hd bq1);\n     \\<lbrakk>bq1 \\<noteq> []; bq2 \\<noteq> []\\<rbrakk>\n     \\<Longrightarrow> rank t2\n                       < rank (hd (ins (link t1 t2) (meld bq1 bq2)));\n     bq2 = []\\<rbrakk>\n    \\<Longrightarrow> rank t2\n                      \\<le> rank (hd (ins (link t1 t2) (meld bq1 bq2)))\n 2. \\<lbrakk>rank_invar bq1; rank_invar bq2;\n     rank (link t1 t2) = rank t2 + 1; meld bq1 [] = bq1;\n     bq1 \\<noteq> [] \\<Longrightarrow> rank t2 < rank (hd bq1);\n     \\<lbrakk>bq1 \\<noteq> []; bq2 \\<noteq> []\\<rbrakk>\n     \\<Longrightarrow> rank t2\n                       < rank (hd (ins (link t1 t2) (meld bq1 bq2)));\n     bq2 \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> rank t2\n                      \\<le> rank (hd (ins (link t1 t2) (meld bq1 bq2)))", "apply(cases \"bq1 = []\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>rank_invar bq1; rank_invar bq2;\n     rank (link t1 t2) = rank t2 + 1; meld bq1 [] = bq1;\n     bq1 \\<noteq> [] \\<Longrightarrow> rank t2 < rank (hd bq1);\n     \\<lbrakk>bq1 \\<noteq> []; bq2 \\<noteq> []\\<rbrakk>\n     \\<Longrightarrow> rank t2\n                       < rank (hd (ins (link t1 t2) (meld bq1 bq2)));\n     bq2 = []; bq1 = []\\<rbrakk>\n    \\<Longrightarrow> rank t2\n                      \\<le> rank (hd (ins (link t1 t2) (meld bq1 bq2)))\n 2. \\<lbrakk>rank_invar bq1; rank_invar bq2;\n     rank (link t1 t2) = rank t2 + 1; meld bq1 [] = bq1;\n     bq1 \\<noteq> [] \\<Longrightarrow> rank t2 < rank (hd bq1);\n     \\<lbrakk>bq1 \\<noteq> []; bq2 \\<noteq> []\\<rbrakk>\n     \\<Longrightarrow> rank t2\n                       < rank (hd (ins (link t1 t2) (meld bq1 bq2)));\n     bq2 = []; bq1 \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> rank t2\n                      \\<le> rank (hd (ins (link t1 t2) (meld bq1 bq2)))\n 3. \\<lbrakk>rank_invar bq1; rank_invar bq2;\n     rank (link t1 t2) = rank t2 + 1; meld bq1 [] = bq1;\n     bq1 \\<noteq> [] \\<Longrightarrow> rank t2 < rank (hd bq1);\n     \\<lbrakk>bq1 \\<noteq> []; bq2 \\<noteq> []\\<rbrakk>\n     \\<Longrightarrow> rank t2\n                       < rank (hd (ins (link t1 t2) (meld bq1 bq2)));\n     bq2 \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> rank t2\n                      \\<le> rank (hd (ins (link t1 t2) (meld bq1 bq2)))", "apply(simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>rank_invar bq1; rank_invar bq2;\n     rank (link t1 t2) = rank t2 + 1; meld bq1 [] = bq1;\n     bq1 \\<noteq> [] \\<Longrightarrow> rank t2 < rank (hd bq1);\n     \\<lbrakk>bq1 \\<noteq> []; bq2 \\<noteq> []\\<rbrakk>\n     \\<Longrightarrow> rank t2\n                       < rank (hd (ins (link t1 t2) (meld bq1 bq2)));\n     bq2 = []; bq1 \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> rank t2\n                      \\<le> rank (hd (ins (link t1 t2) (meld bq1 bq2)))\n 2. \\<lbrakk>rank_invar bq1; rank_invar bq2;\n     rank (link t1 t2) = rank t2 + 1; meld bq1 [] = bq1;\n     bq1 \\<noteq> [] \\<Longrightarrow> rank t2 < rank (hd bq1);\n     \\<lbrakk>bq1 \\<noteq> []; bq2 \\<noteq> []\\<rbrakk>\n     \\<Longrightarrow> rank t2\n                       < rank (hd (ins (link t1 t2) (meld bq1 bq2)));\n     bq2 \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> rank t2\n                      \\<le> rank (hd (ins (link t1 t2) (meld bq1 bq2)))", "apply(auto simp add: abc1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>rank_invar bq1; rank_invar bq2;\n     rank (link t1 t2) = Suc (rank t2); meld bq1 [] = bq1;\n     bq1 \\<noteq> [] \\<Longrightarrow> rank t2 < rank (hd bq1);\n     bq1 \\<noteq> [] \\<Longrightarrow>\n     rank t2 < rank (hd (ins (link t1 t2) (meld bq1 bq2)));\n     bq2 \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> rank t2\n                      \\<le> rank (hd (ins (link t1 t2) (meld bq1 bq2)))", "apply(cases \"bq1 = []\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>rank_invar bq1; rank_invar bq2;\n     rank (link t1 t2) = Suc (rank t2); meld bq1 [] = bq1;\n     bq1 \\<noteq> [] \\<Longrightarrow> rank t2 < rank (hd bq1);\n     bq1 \\<noteq> [] \\<Longrightarrow>\n     rank t2 < rank (hd (ins (link t1 t2) (meld bq1 bq2)));\n     bq2 \\<noteq> []; bq1 = []\\<rbrakk>\n    \\<Longrightarrow> rank t2\n                      \\<le> rank (hd (ins (link t1 t2) (meld bq1 bq2)))\n 2. \\<lbrakk>rank_invar bq1; rank_invar bq2;\n     rank (link t1 t2) = Suc (rank t2); meld bq1 [] = bq1;\n     bq1 \\<noteq> [] \\<Longrightarrow> rank t2 < rank (hd bq1);\n     bq1 \\<noteq> [] \\<Longrightarrow>\n     rank t2 < rank (hd (ins (link t1 t2) (meld bq1 bq2)));\n     bq2 \\<noteq> []; bq1 \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> rank t2\n                      \\<le> rank (hd (ins (link t1 t2) (meld bq1 bq2)))", "apply(simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>rank_invar bq2; rank (link t1 t2) = Suc (rank t2);\n     bq2 \\<noteq> []; bq1 = []\\<rbrakk>\n    \\<Longrightarrow> rank t2 \\<le> rank (hd (ins (link t1 t2) bq2))\n 2. \\<lbrakk>rank_invar bq1; rank_invar bq2;\n     rank (link t1 t2) = Suc (rank t2); meld bq1 [] = bq1;\n     bq1 \\<noteq> [] \\<Longrightarrow> rank t2 < rank (hd bq1);\n     bq1 \\<noteq> [] \\<Longrightarrow>\n     rank t2 < rank (hd (ins (link t1 t2) (meld bq1 bq2)));\n     bq2 \\<noteq> []; bq1 \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> rank t2\n                      \\<le> rank (hd (ins (link t1 t2) (meld bq1 bq2)))", "apply(auto simp add: abc2)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  rank t2 \\<le> rank (hd (ins (link t1 t2) (meld bq1 bq2)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  rank_invar (meld (t1 # bq1) (t2 # bq2)) \\<and>\n  min (rank (hd (t1 # bq1))) (rank (hd (t2 # bq2)))\n  \\<le> rank (hd (meld (t1 # bq1) (t2 # bq2)))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rank_invar_meld: \n  \"\\<lbrakk>rank_invar bq1; rank_invar bq2\\<rbrakk> \\<Longrightarrow> rank_invar (meld bq1 bq2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>rank_invar bq1; rank_invar bq2\\<rbrakk>\n    \\<Longrightarrow> rank_invar (meld bq1 bq2)", "by (simp only: rank_invar_meld_strong)"], ["", "lemma meld_mset: \"\\<lbrakk>queue_invar q; queue_invar q'\\<rbrakk> \\<Longrightarrow> \n  queue_to_multiset (meld q q') = \n  queue_to_multiset q + queue_to_multiset q'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>queue_invar q; queue_invar q'\\<rbrakk>\n    \\<Longrightarrow> queue_to_multiset (meld q q') =\n                      queue_to_multiset q + queue_to_multiset q'", "by(induct q q' rule: meld.induct)\n  (auto simp add: link_tree_invar meld_queue_invar ins_mset union_ac)"], ["", "lemma meld_correct:\n  assumes \"invar q\" \"invar q'\" \n  shows \n  \"invar (meld q q')\"\n  \"queue_to_multiset (meld q q') = queue_to_multiset q + queue_to_multiset q'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invar (meld q q') &&&\n    queue_to_multiset (meld q q') =\n    queue_to_multiset q + queue_to_multiset q'", "using assms"], ["proof (prove)\nusing this:\n  invar q\n  invar q'\n\ngoal (1 subgoal):\n 1. invar (meld q q') &&&\n    queue_to_multiset (meld q q') =\n    queue_to_multiset q + queue_to_multiset q'", "unfolding invar_def"], ["proof (prove)\nusing this:\n  queue_invar q \\<and> rank_invar q\n  queue_invar q' \\<and> rank_invar q'\n\ngoal (1 subgoal):\n 1. queue_invar (meld q q') \\<and> rank_invar (meld q q') &&&\n    queue_to_multiset (meld q q') =\n    queue_to_multiset q + queue_to_multiset q'", "by (simp_all add: meld_queue_invar rank_invar_meld meld_mset)"], ["", "subsubsection \"Find Minimal Element\""], ["", "text \\<open>Finds the tree containing the minimal element.\\<close>"], ["", "fun getMinTree :: \"('e, 'a::linorder) BinomialQueue_inv \\<Rightarrow> \n  ('e, 'a) BinomialTree\" where\n  \"getMinTree [t] = t\" |\n  \"getMinTree (t#bq) = (if prio t \\<le> prio (getMinTree bq) \n     then t else (getMinTree bq))\""], ["", "lemma mintree_exists: \"(bq \\<noteq> []) = (getMinTree bq \\<in> set bq)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (bq \\<noteq> []) = (getMinTree bq \\<in> set bq)", "proof (induct bq)"], ["proof (state)\ngoal (2 subgoals):\n 1. ([] \\<noteq> []) = (getMinTree [] \\<in> set [])\n 2. \\<And>a bq.\n       (bq \\<noteq> []) = (getMinTree bq \\<in> set bq) \\<Longrightarrow>\n       (a # bq \\<noteq> []) = (getMinTree (a # bq) \\<in> set (a # bq))", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. ([] \\<noteq> []) = (getMinTree [] \\<in> set [])\n 2. \\<And>a bq.\n       (bq \\<noteq> []) = (getMinTree bq \\<in> set bq) \\<Longrightarrow>\n       (a # bq \\<noteq> []) = (getMinTree (a # bq) \\<in> set (a # bq))", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. ([] \\<noteq> []) = (getMinTree [] \\<in> set [])", "by simp"], ["proof (state)\nthis:\n  ([] \\<noteq> []) = (getMinTree [] \\<in> set [])\n\ngoal (1 subgoal):\n 1. \\<And>a bq.\n       (bq \\<noteq> []) = (getMinTree bq \\<in> set bq) \\<Longrightarrow>\n       (a # bq \\<noteq> []) = (getMinTree (a # bq) \\<in> set (a # bq))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a bq.\n       (bq \\<noteq> []) = (getMinTree bq \\<in> set bq) \\<Longrightarrow>\n       (a # bq \\<noteq> []) = (getMinTree (a # bq) \\<in> set (a # bq))", "case (Cons _ bq)"], ["proof (state)\nthis:\n  (bq \\<noteq> []) = (getMinTree bq \\<in> set bq)\n\ngoal (1 subgoal):\n 1. \\<And>a bq.\n       (bq \\<noteq> []) = (getMinTree bq \\<in> set bq) \\<Longrightarrow>\n       (a # bq \\<noteq> []) = (getMinTree (a # bq) \\<in> set (a # bq))", "then"], ["proof (chain)\npicking this:\n  (bq \\<noteq> []) = (getMinTree bq \\<in> set bq)", "show ?case"], ["proof (prove)\nusing this:\n  (bq \\<noteq> []) = (getMinTree bq \\<in> set bq)\n\ngoal (1 subgoal):\n 1. (a_ # bq \\<noteq> []) = (getMinTree (a_ # bq) \\<in> set (a_ # bq))", "by (cases bq) simp_all"], ["proof (state)\nthis:\n  (a_ # bq \\<noteq> []) = (getMinTree (a_ # bq) \\<in> set (a_ # bq))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma treehead_in_multiset: \n  \"t \\<in> set bq \\<Longrightarrow> (val t, prio t) \\<in># queue_to_multiset bq\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<in> set bq \\<Longrightarrow>\n    (val t, prio t) \\<in># queue_to_multiset bq", "by (induct bq, simp, cases t, auto)"], ["", "lemma heap_ordered_single: \n\"heap_ordered t = (\\<forall>x \\<in> set_mset (tree_to_multiset t). prio t \\<le> snd x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. heap_ordered t =\n    (\\<forall>x\\<in>#tree_to_multiset t. prio t \\<le> snd x)", "by (cases t) auto"], ["", "lemma getMinTree_cons: \n  \"prio (getMinTree (y # x # xs)) \\<le> prio (getMinTree (x # xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prio (getMinTree (y # x # xs)) \\<le> prio (getMinTree (x # xs))", "by (induct xs rule: getMinTree.induct) simp_all"], ["", "lemma getMinTree_min_tree:\n  \"t \\<in> set bq  \\<Longrightarrow> prio (getMinTree bq) \\<le> prio t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<in> set bq \\<Longrightarrow> prio (getMinTree bq) \\<le> prio t", "apply(induct bq arbitrary: t rule: getMinTree.induct)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>t ta.\n       ta \\<in> set [t] \\<Longrightarrow>\n       prio (getMinTree [t]) \\<le> prio ta\n 2. \\<And>t v va ta.\n       \\<lbrakk>\\<And>t.\n                   t \\<in> set (v # va) \\<Longrightarrow>\n                   prio (getMinTree (v # va)) \\<le> prio t;\n        \\<And>ta.\n           \\<lbrakk>\\<not> prio t \\<le> prio (getMinTree (v # va));\n            ta \\<in> set (v # va)\\<rbrakk>\n           \\<Longrightarrow> prio (getMinTree (v # va)) \\<le> prio ta;\n        ta \\<in> set (t # v # va)\\<rbrakk>\n       \\<Longrightarrow> prio (getMinTree (t # v # va)) \\<le> prio ta\n 3. \\<And>t.\n       t \\<in> set [] \\<Longrightarrow> prio (getMinTree []) \\<le> prio t", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>t v va ta.\n       \\<lbrakk>\\<And>t.\n                   t \\<in> set (v # va) \\<Longrightarrow>\n                   prio (getMinTree (v # va)) \\<le> prio t;\n        \\<And>ta.\n           \\<lbrakk>\\<not> prio t \\<le> prio (getMinTree (v # va));\n            ta \\<in> set (v # va)\\<rbrakk>\n           \\<Longrightarrow> prio (getMinTree (v # va)) \\<le> prio ta;\n        ta \\<in> set (t # v # va)\\<rbrakk>\n       \\<Longrightarrow> prio (getMinTree (t # v # va)) \\<le> prio ta\n 2. \\<And>t.\n       t \\<in> set [] \\<Longrightarrow> prio (getMinTree []) \\<le> prio t", "defer"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>t.\n       t \\<in> set [] \\<Longrightarrow> prio (getMinTree []) \\<le> prio t\n 2. \\<And>t v va ta.\n       \\<lbrakk>\\<And>t.\n                   t \\<in> set (v # va) \\<Longrightarrow>\n                   prio (getMinTree (v # va)) \\<le> prio t;\n        \\<And>ta.\n           \\<lbrakk>\\<not> prio t \\<le> prio (getMinTree (v # va));\n            ta \\<in> set (v # va)\\<rbrakk>\n           \\<Longrightarrow> prio (getMinTree (v # va)) \\<le> prio ta;\n        ta \\<in> set (t # v # va)\\<rbrakk>\n       \\<Longrightarrow> prio (getMinTree (t # v # va)) \\<le> prio ta", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>t v va ta.\n       \\<lbrakk>\\<And>t.\n                   t \\<in> set (v # va) \\<Longrightarrow>\n                   prio (getMinTree (v # va)) \\<le> prio t;\n        \\<And>ta.\n           \\<lbrakk>\\<not> prio t \\<le> prio (getMinTree (v # va));\n            ta \\<in> set (v # va)\\<rbrakk>\n           \\<Longrightarrow> prio (getMinTree (v # va)) \\<le> prio ta;\n        ta \\<in> set (t # v # va)\\<rbrakk>\n       \\<Longrightarrow> prio (getMinTree (t # v # va)) \\<le> prio ta", "proof goal_cases"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t v va ta.\n       \\<lbrakk>\\<And>t.\n                   t \\<in> set (v # va) \\<Longrightarrow>\n                   prio (getMinTree (v # va)) \\<le> prio t;\n        \\<And>ta.\n           \\<lbrakk>\\<not> prio t \\<le> prio (getMinTree (v # va));\n            ta \\<in> set (v # va)\\<rbrakk>\n           \\<Longrightarrow> prio (getMinTree (v # va)) \\<le> prio ta;\n        ta \\<in> set (t # v # va)\\<rbrakk>\n       \\<Longrightarrow> prio (getMinTree (t # v # va)) \\<le> prio ta", "case prems: (1 t v va ta)"], ["proof (state)\nthis:\n  ?t \\<in> set (v # va) \\<Longrightarrow>\n  prio (getMinTree (v # va)) \\<le> prio ?t\n  \\<lbrakk>\\<not> prio t \\<le> prio (getMinTree (v # va));\n   ?t \\<in> set (v # va)\\<rbrakk>\n  \\<Longrightarrow> prio (getMinTree (v # va)) \\<le> prio ?t\n  ta \\<in> set (t # v # va)\n\ngoal (1 subgoal):\n 1. \\<And>t v va ta.\n       \\<lbrakk>\\<And>t.\n                   t \\<in> set (v # va) \\<Longrightarrow>\n                   prio (getMinTree (v # va)) \\<le> prio t;\n        \\<And>ta.\n           \\<lbrakk>\\<not> prio t \\<le> prio (getMinTree (v # va));\n            ta \\<in> set (v # va)\\<rbrakk>\n           \\<Longrightarrow> prio (getMinTree (v # va)) \\<le> prio ta;\n        ta \\<in> set (t # v # va)\\<rbrakk>\n       \\<Longrightarrow> prio (getMinTree (t # v # va)) \\<le> prio ta", "thus ?case"], ["proof (prove)\nusing this:\n  ?t \\<in> set (v # va) \\<Longrightarrow>\n  prio (getMinTree (v # va)) \\<le> prio ?t\n  \\<lbrakk>\\<not> prio t \\<le> prio (getMinTree (v # va));\n   ?t \\<in> set (v # va)\\<rbrakk>\n  \\<Longrightarrow> prio (getMinTree (v # va)) \\<le> prio ?t\n  ta \\<in> set (t # v # va)\n\ngoal (1 subgoal):\n 1. prio (getMinTree (t # v # va)) \\<le> prio ta", "apply (cases \"ta = t\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>t.\n                t \\<in> set (v # va) \\<Longrightarrow>\n                prio (getMinTree (v # va)) \\<le> prio t;\n     \\<And>t.\n        \\<lbrakk>\\<not> prio t \\<le> prio (getMinTree (v # va));\n         t \\<in> set (v # va)\\<rbrakk>\n        \\<Longrightarrow> prio (getMinTree (v # va)) \\<le> prio t;\n     ta \\<in> set (t # v # va); ta = t\\<rbrakk>\n    \\<Longrightarrow> prio (getMinTree (t # v # va)) \\<le> prio ta\n 2. \\<lbrakk>\\<And>t.\n                t \\<in> set (v # va) \\<Longrightarrow>\n                prio (getMinTree (v # va)) \\<le> prio t;\n     \\<And>t.\n        \\<lbrakk>\\<not> prio t \\<le> prio (getMinTree (v # va));\n         t \\<in> set (v # va)\\<rbrakk>\n        \\<Longrightarrow> prio (getMinTree (v # va)) \\<le> prio t;\n     ta \\<in> set (t # v # va); ta \\<noteq> t\\<rbrakk>\n    \\<Longrightarrow> prio (getMinTree (t # v # va)) \\<le> prio ta", "apply auto[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>t.\n                t \\<in> set (v # va) \\<Longrightarrow>\n                prio (getMinTree (v # va)) \\<le> prio t;\n     \\<And>t.\n        \\<lbrakk>\\<not> prio t \\<le> prio (getMinTree (v # va));\n         t \\<in> set (v # va)\\<rbrakk>\n        \\<Longrightarrow> prio (getMinTree (v # va)) \\<le> prio t;\n     ta \\<in> set (t # v # va); ta \\<noteq> t\\<rbrakk>\n    \\<Longrightarrow> prio (getMinTree (t # v # va)) \\<le> prio ta", "apply (metis getMinTree_cons prems(1) prems(3) set_ConsD xt1(6))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  prio (getMinTree (t # v # va)) \\<le> prio ta\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma getMinTree_min_prio:\n  assumes \"queue_invar bq\"\n    and \"y \\<in> set_mset (queue_to_multiset bq)\"\n  shows \"prio (getMinTree bq) \\<le> snd y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prio (getMinTree bq) \\<le> snd y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. prio (getMinTree bq) \\<le> snd y", "from assms"], ["proof (chain)\npicking this:\n  queue_invar bq\n  y \\<in># queue_to_multiset bq", "have \"bq \\<noteq> []\""], ["proof (prove)\nusing this:\n  queue_invar bq\n  y \\<in># queue_to_multiset bq\n\ngoal (1 subgoal):\n 1. bq \\<noteq> []", "by (cases bq) simp_all"], ["proof (state)\nthis:\n  bq \\<noteq> []\n\ngoal (1 subgoal):\n 1. prio (getMinTree bq) \\<le> snd y", "with assms"], ["proof (chain)\npicking this:\n  queue_invar bq\n  y \\<in># queue_to_multiset bq\n  bq \\<noteq> []", "have \"\\<exists> t \\<in> set bq. (y \\<in> set_mset ((tree_to_multiset t)))\""], ["proof (prove)\nusing this:\n  queue_invar bq\n  y \\<in># queue_to_multiset bq\n  bq \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<exists>t\\<in>set bq. y \\<in># tree_to_multiset t", "proof (induct bq)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>queue_invar []; y \\<in># queue_to_multiset [];\n     [] \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t\\<in>set []. y \\<in># tree_to_multiset t\n 2. \\<And>a bq.\n       \\<lbrakk>\\<lbrakk>queue_invar bq; y \\<in># queue_to_multiset bq;\n                 bq \\<noteq> []\\<rbrakk>\n                \\<Longrightarrow> \\<exists>t\\<in>set bq.\n                                     y \\<in># tree_to_multiset t;\n        queue_invar (a # bq); y \\<in># queue_to_multiset (a # bq);\n        a # bq \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t\\<in>set (a # bq).\n                            y \\<in># tree_to_multiset t", "case Nil"], ["proof (state)\nthis:\n  queue_invar []\n  y \\<in># queue_to_multiset []\n  [] \\<noteq> []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>queue_invar []; y \\<in># queue_to_multiset [];\n     [] \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t\\<in>set []. y \\<in># tree_to_multiset t\n 2. \\<And>a bq.\n       \\<lbrakk>\\<lbrakk>queue_invar bq; y \\<in># queue_to_multiset bq;\n                 bq \\<noteq> []\\<rbrakk>\n                \\<Longrightarrow> \\<exists>t\\<in>set bq.\n                                     y \\<in># tree_to_multiset t;\n        queue_invar (a # bq); y \\<in># queue_to_multiset (a # bq);\n        a # bq \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t\\<in>set (a # bq).\n                            y \\<in># tree_to_multiset t", "then"], ["proof (chain)\npicking this:\n  queue_invar []\n  y \\<in># queue_to_multiset []\n  [] \\<noteq> []", "show ?case"], ["proof (prove)\nusing this:\n  queue_invar []\n  y \\<in># queue_to_multiset []\n  [] \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<exists>t\\<in>set []. y \\<in># tree_to_multiset t", "by simp"], ["proof (state)\nthis:\n  \\<exists>t\\<in>set []. y \\<in># tree_to_multiset t\n\ngoal (1 subgoal):\n 1. \\<And>a bq.\n       \\<lbrakk>\\<lbrakk>queue_invar bq; y \\<in># queue_to_multiset bq;\n                 bq \\<noteq> []\\<rbrakk>\n                \\<Longrightarrow> \\<exists>t\\<in>set bq.\n                                     y \\<in># tree_to_multiset t;\n        queue_invar (a # bq); y \\<in># queue_to_multiset (a # bq);\n        a # bq \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t\\<in>set (a # bq).\n                            y \\<in># tree_to_multiset t", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a bq.\n       \\<lbrakk>\\<lbrakk>queue_invar bq; y \\<in># queue_to_multiset bq;\n                 bq \\<noteq> []\\<rbrakk>\n                \\<Longrightarrow> \\<exists>t\\<in>set bq.\n                                     y \\<in># tree_to_multiset t;\n        queue_invar (a # bq); y \\<in># queue_to_multiset (a # bq);\n        a # bq \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t\\<in>set (a # bq).\n                            y \\<in># tree_to_multiset t", "case (Cons a bq)"], ["proof (state)\nthis:\n  \\<lbrakk>queue_invar bq; y \\<in># queue_to_multiset bq;\n   bq \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> \\<exists>t\\<in>set bq. y \\<in># tree_to_multiset t\n  queue_invar (a # bq)\n  y \\<in># queue_to_multiset (a # bq)\n  a # bq \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>a bq.\n       \\<lbrakk>\\<lbrakk>queue_invar bq; y \\<in># queue_to_multiset bq;\n                 bq \\<noteq> []\\<rbrakk>\n                \\<Longrightarrow> \\<exists>t\\<in>set bq.\n                                     y \\<in># tree_to_multiset t;\n        queue_invar (a # bq); y \\<in># queue_to_multiset (a # bq);\n        a # bq \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t\\<in>set (a # bq).\n                            y \\<in># tree_to_multiset t", "thus ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>queue_invar bq; y \\<in># queue_to_multiset bq;\n   bq \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> \\<exists>t\\<in>set bq. y \\<in># tree_to_multiset t\n  queue_invar (a # bq)\n  y \\<in># queue_to_multiset (a # bq)\n  a # bq \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<exists>t\\<in>set (a # bq). y \\<in># tree_to_multiset t", "apply(cases \"y \\<in> set_mset (tree_to_multiset a)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<lbrakk>queue_invar bq; y \\<in># queue_to_multiset bq;\n              bq \\<noteq> []\\<rbrakk>\n             \\<Longrightarrow> \\<exists>t\\<in>set bq.\n                                  y \\<in># tree_to_multiset t;\n     queue_invar (a # bq); y \\<in># queue_to_multiset (a # bq);\n     a # bq \\<noteq> []; y \\<in># tree_to_multiset a\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t\\<in>set (a # bq).\n                         y \\<in># tree_to_multiset t\n 2. \\<lbrakk>\\<lbrakk>queue_invar bq; y \\<in># queue_to_multiset bq;\n              bq \\<noteq> []\\<rbrakk>\n             \\<Longrightarrow> \\<exists>t\\<in>set bq.\n                                  y \\<in># tree_to_multiset t;\n     queue_invar (a # bq); y \\<in># queue_to_multiset (a # bq);\n     a # bq \\<noteq> []; y \\<notin># tree_to_multiset a\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t\\<in>set (a # bq).\n                         y \\<in># tree_to_multiset t", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>queue_invar bq; y \\<in># queue_to_multiset bq;\n              bq \\<noteq> []\\<rbrakk>\n             \\<Longrightarrow> \\<exists>t\\<in>set bq.\n                                  y \\<in># tree_to_multiset t;\n     queue_invar (a # bq); y \\<in># queue_to_multiset (a # bq);\n     a # bq \\<noteq> []; y \\<notin># tree_to_multiset a\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t\\<in>set (a # bq).\n                         y \\<in># tree_to_multiset t", "apply(cases bq)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<lbrakk>queue_invar bq; y \\<in># queue_to_multiset bq;\n              bq \\<noteq> []\\<rbrakk>\n             \\<Longrightarrow> \\<exists>t\\<in>set bq.\n                                  y \\<in># tree_to_multiset t;\n     queue_invar (a # bq); y \\<in># queue_to_multiset (a # bq);\n     a # bq \\<noteq> []; y \\<notin># tree_to_multiset a; bq = []\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t\\<in>set (a # bq).\n                         y \\<in># tree_to_multiset t\n 2. \\<And>aa list.\n       \\<lbrakk>\\<lbrakk>queue_invar bq; y \\<in># queue_to_multiset bq;\n                 bq \\<noteq> []\\<rbrakk>\n                \\<Longrightarrow> \\<exists>t\\<in>set bq.\n                                     y \\<in># tree_to_multiset t;\n        queue_invar (a # bq); y \\<in># queue_to_multiset (a # bq);\n        a # bq \\<noteq> []; y \\<notin># tree_to_multiset a;\n        bq = aa # list\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t\\<in>set (a # bq).\n                            y \\<in># tree_to_multiset t", "apply simp_all"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>t\\<in>set (a # bq). y \\<in># tree_to_multiset t\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>t\\<in>set bq. y \\<in># tree_to_multiset t\n\ngoal (1 subgoal):\n 1. prio (getMinTree bq) \\<le> snd y", "from this"], ["proof (chain)\npicking this:\n  \\<exists>t\\<in>set bq. y \\<in># tree_to_multiset t", "obtain t where O: \n    \"t \\<in> set bq\"\n    \"y \\<in> set_mset (tree_to_multiset t)\""], ["proof (prove)\nusing this:\n  \\<exists>t\\<in>set bq. y \\<in># tree_to_multiset t\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        \\<lbrakk>t \\<in> set bq; y \\<in># tree_to_multiset t\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  t \\<in> set bq\n  y \\<in># tree_to_multiset t\n\ngoal (1 subgoal):\n 1. prio (getMinTree bq) \\<le> snd y", "obtain e a r ts where [simp]: \"t = (Node e a r ts)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>e a r ts.\n        t = Node e a r ts \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases t) blast"], ["proof (state)\nthis:\n  t = Node e a r ts\n\ngoal (1 subgoal):\n 1. prio (getMinTree bq) \\<le> snd y", "from O assms(1)"], ["proof (chain)\npicking this:\n  t \\<in> set bq\n  y \\<in># tree_to_multiset t\n  queue_invar bq", "have inv: \"tree_invar t\""], ["proof (prove)\nusing this:\n  t \\<in> set bq\n  y \\<in># tree_to_multiset t\n  queue_invar bq\n\ngoal (1 subgoal):\n 1. tree_invar t", "by (simp add: queue_invar_def)"], ["proof (state)\nthis:\n  tree_invar t\n\ngoal (1 subgoal):\n 1. prio (getMinTree bq) \\<le> snd y", "from tree_invar_heap_ordered[OF inv] heap_ordered.simps[of e a r ts] O"], ["proof (chain)\npicking this:\n  heap_ordered t\n  heap_ordered (Node e a r ts) =\n  (\\<forall>x\\<in>#queue_to_multiset ts. a \\<le> snd x)\n  t \\<in> set bq\n  y \\<in># tree_to_multiset t", "have \"prio t \\<le> snd y\""], ["proof (prove)\nusing this:\n  heap_ordered t\n  heap_ordered (Node e a r ts) =\n  (\\<forall>x\\<in>#queue_to_multiset ts. a \\<le> snd x)\n  t \\<in> set bq\n  y \\<in># tree_to_multiset t\n\ngoal (1 subgoal):\n 1. prio t \\<le> snd y", "by auto"], ["proof (state)\nthis:\n  prio t \\<le> snd y\n\ngoal (1 subgoal):\n 1. prio (getMinTree bq) \\<le> snd y", "with getMinTree_min_tree[OF O(1)]"], ["proof (chain)\npicking this:\n  prio (getMinTree bq) \\<le> prio t\n  prio t \\<le> snd y", "show ?thesis"], ["proof (prove)\nusing this:\n  prio (getMinTree bq) \\<le> prio t\n  prio t \\<le> snd y\n\ngoal (1 subgoal):\n 1. prio (getMinTree bq) \\<le> snd y", "by simp"], ["proof (state)\nthis:\n  prio (getMinTree bq) \\<le> snd y\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Finds the minimal Element in the queue.\\<close>"], ["", "definition findMin :: \"('e, 'a::linorder) BinomialQueue_inv \\<Rightarrow> ('e \\<times> 'a)\" where\n  \"findMin bq = (let min = getMinTree bq in (val min, prio min))\""], ["", "lemma findMin_correct:\n  assumes I: \"invar q\"\n  assumes NE: \"q \\<noteq> Nil\"\n  shows \n  \"findMin q \\<in># queue_to_multiset q\"\n  \"\\<forall>y\\<in>set_mset (queue_to_multiset q). snd (findMin q) \\<le> snd y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. findMin q \\<in># queue_to_multiset q &&&\n    \\<forall>y\\<in>#queue_to_multiset q. snd (findMin q) \\<le> snd y", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. findMin q \\<in># queue_to_multiset q\n 2. \\<forall>y\\<in>#queue_to_multiset q. snd (findMin q) \\<le> snd y", "from NE"], ["proof (chain)\npicking this:\n  q \\<noteq> []", "have \"getMinTree q \\<in> set q\""], ["proof (prove)\nusing this:\n  q \\<noteq> []\n\ngoal (1 subgoal):\n 1. getMinTree q \\<in> set q", "by (simp only: mintree_exists)"], ["proof (state)\nthis:\n  getMinTree q \\<in> set q\n\ngoal (2 subgoals):\n 1. findMin q \\<in># queue_to_multiset q\n 2. \\<forall>y\\<in>#queue_to_multiset q. snd (findMin q) \\<le> snd y", "thus \"findMin q \\<in># queue_to_multiset q\""], ["proof (prove)\nusing this:\n  getMinTree q \\<in> set q\n\ngoal (1 subgoal):\n 1. findMin q \\<in># queue_to_multiset q", "by (simp add: treehead_in_multiset Let_def findMin_def)"], ["proof (state)\nthis:\n  findMin q \\<in># queue_to_multiset q\n\ngoal (1 subgoal):\n 1. \\<forall>y\\<in>#queue_to_multiset q. snd (findMin q) \\<le> snd y", "show \"\\<forall>y\\<in>set_mset (queue_to_multiset q). snd (findMin q) \\<le> snd y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>y\\<in>#queue_to_multiset q. snd (findMin q) \\<le> snd y", "using I[unfolded invar_def]"], ["proof (prove)\nusing this:\n  queue_invar q \\<and> rank_invar q\n\ngoal (1 subgoal):\n 1. \\<forall>y\\<in>#queue_to_multiset q. snd (findMin q) \\<le> snd y", "by (auto simp add: getMinTree_min_prio Let_def findMin_def)"], ["proof (state)\nthis:\n  \\<forall>y\\<in>#queue_to_multiset q. snd (findMin q) \\<le> snd y\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \"Delete Minimal Element\""], ["", "text \\<open>Removes the first tree, which has the priority $a$ within his root.\\<close>"], ["", "fun remove1Prio :: \"'a \\<Rightarrow> ('e, 'a::linorder) BinomialQueue_inv \\<Rightarrow>\n  ('e, 'a) BinomialQueue_inv\" where\n  \"remove1Prio a [] = []\" |\n  \"remove1Prio a (t#bq) = \n  (if (prio t) = a then bq else t # (remove1Prio a bq))\""], ["", "text \\<open>Returns the queue without the minimal element.\\<close>"], ["", "definition deleteMin :: \"('e, 'a::linorder) BinomialQueue_inv \\<Rightarrow> \n  ('e, 'a) BinomialQueue_inv\" where\n  \"deleteMin bq \\<equiv> (let min = getMinTree bq in \n                    meld (rev (children min)) \n                         (remove1Prio (prio min) bq))\""], ["", "lemma queue_invar_rev: \"queue_invar q \\<Longrightarrow> queue_invar (rev q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. queue_invar q \\<Longrightarrow> queue_invar (rev q)", "by (simp add: queue_invar_def)"], ["", "lemma queue_invar_remove1: \"queue_invar q \\<Longrightarrow> queue_invar (remove1 t q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. queue_invar q \\<Longrightarrow> queue_invar (remove1 t q)", "by (auto simp add: queue_invar_def)"], ["", "lemma qtm_in_set_subset: \"t \\<in> set q \\<Longrightarrow> \n  tree_to_multiset t \\<subseteq># queue_to_multiset q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<in> set q \\<Longrightarrow>\n    tree_to_multiset t \\<subseteq># queue_to_multiset q", "proof(induct q)"], ["proof (state)\ngoal (2 subgoals):\n 1. t \\<in> set [] \\<Longrightarrow>\n    tree_to_multiset t \\<subseteq># queue_to_multiset []\n 2. \\<And>a q.\n       \\<lbrakk>t \\<in> set q \\<Longrightarrow>\n                tree_to_multiset t \\<subseteq># queue_to_multiset q;\n        t \\<in> set (a # q)\\<rbrakk>\n       \\<Longrightarrow> tree_to_multiset t \\<subseteq>#\n                         queue_to_multiset (a # q)", "case Nil"], ["proof (state)\nthis:\n  t \\<in> set []\n\ngoal (2 subgoals):\n 1. t \\<in> set [] \\<Longrightarrow>\n    tree_to_multiset t \\<subseteq># queue_to_multiset []\n 2. \\<And>a q.\n       \\<lbrakk>t \\<in> set q \\<Longrightarrow>\n                tree_to_multiset t \\<subseteq># queue_to_multiset q;\n        t \\<in> set (a # q)\\<rbrakk>\n       \\<Longrightarrow> tree_to_multiset t \\<subseteq>#\n                         queue_to_multiset (a # q)", "then"], ["proof (chain)\npicking this:\n  t \\<in> set []", "show ?case"], ["proof (prove)\nusing this:\n  t \\<in> set []\n\ngoal (1 subgoal):\n 1. tree_to_multiset t \\<subseteq># queue_to_multiset []", "by simp"], ["proof (state)\nthis:\n  tree_to_multiset t \\<subseteq># queue_to_multiset []\n\ngoal (1 subgoal):\n 1. \\<And>a q.\n       \\<lbrakk>t \\<in> set q \\<Longrightarrow>\n                tree_to_multiset t \\<subseteq># queue_to_multiset q;\n        t \\<in> set (a # q)\\<rbrakk>\n       \\<Longrightarrow> tree_to_multiset t \\<subseteq>#\n                         queue_to_multiset (a # q)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a q.\n       \\<lbrakk>t \\<in> set q \\<Longrightarrow>\n                tree_to_multiset t \\<subseteq># queue_to_multiset q;\n        t \\<in> set (a # q)\\<rbrakk>\n       \\<Longrightarrow> tree_to_multiset t \\<subseteq>#\n                         queue_to_multiset (a # q)", "case (Cons a q)"], ["proof (state)\nthis:\n  t \\<in> set q \\<Longrightarrow>\n  tree_to_multiset t \\<subseteq># queue_to_multiset q\n  t \\<in> set (a # q)\n\ngoal (1 subgoal):\n 1. \\<And>a q.\n       \\<lbrakk>t \\<in> set q \\<Longrightarrow>\n                tree_to_multiset t \\<subseteq># queue_to_multiset q;\n        t \\<in> set (a # q)\\<rbrakk>\n       \\<Longrightarrow> tree_to_multiset t \\<subseteq>#\n                         queue_to_multiset (a # q)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. tree_to_multiset t \\<subseteq># queue_to_multiset (a # q)", "proof (cases \"t = a\")"], ["proof (state)\ngoal (2 subgoals):\n 1. t = a \\<Longrightarrow>\n    tree_to_multiset t \\<subseteq># queue_to_multiset (a # q)\n 2. t \\<noteq> a \\<Longrightarrow>\n    tree_to_multiset t \\<subseteq># queue_to_multiset (a # q)", "case True"], ["proof (state)\nthis:\n  t = a\n\ngoal (2 subgoals):\n 1. t = a \\<Longrightarrow>\n    tree_to_multiset t \\<subseteq># queue_to_multiset (a # q)\n 2. t \\<noteq> a \\<Longrightarrow>\n    tree_to_multiset t \\<subseteq># queue_to_multiset (a # q)", "then"], ["proof (chain)\npicking this:\n  t = a", "show ?thesis"], ["proof (prove)\nusing this:\n  t = a\n\ngoal (1 subgoal):\n 1. tree_to_multiset t \\<subseteq># queue_to_multiset (a # q)", "by simp"], ["proof (state)\nthis:\n  tree_to_multiset t \\<subseteq># queue_to_multiset (a # q)\n\ngoal (1 subgoal):\n 1. t \\<noteq> a \\<Longrightarrow>\n    tree_to_multiset t \\<subseteq># queue_to_multiset (a # q)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. t \\<noteq> a \\<Longrightarrow>\n    tree_to_multiset t \\<subseteq># queue_to_multiset (a # q)", "case False"], ["proof (state)\nthis:\n  t \\<noteq> a\n\ngoal (1 subgoal):\n 1. t \\<noteq> a \\<Longrightarrow>\n    tree_to_multiset t \\<subseteq># queue_to_multiset (a # q)", "with Cons"], ["proof (chain)\npicking this:\n  t \\<in> set q \\<Longrightarrow>\n  tree_to_multiset t \\<subseteq># queue_to_multiset q\n  t \\<in> set (a # q)\n  t \\<noteq> a", "have t_in_q: \"t \\<in> set q\""], ["proof (prove)\nusing this:\n  t \\<in> set q \\<Longrightarrow>\n  tree_to_multiset t \\<subseteq># queue_to_multiset q\n  t \\<in> set (a # q)\n  t \\<noteq> a\n\ngoal (1 subgoal):\n 1. t \\<in> set q", "by simp"], ["proof (state)\nthis:\n  t \\<in> set q\n\ngoal (1 subgoal):\n 1. t \\<noteq> a \\<Longrightarrow>\n    tree_to_multiset t \\<subseteq># queue_to_multiset (a # q)", "have \"queue_to_multiset q \\<subseteq># queue_to_multiset (a # q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. queue_to_multiset q \\<subseteq># queue_to_multiset (a # q)", "by simp"], ["proof (state)\nthis:\n  queue_to_multiset q \\<subseteq># queue_to_multiset (a # q)\n\ngoal (1 subgoal):\n 1. t \\<noteq> a \\<Longrightarrow>\n    tree_to_multiset t \\<subseteq># queue_to_multiset (a # q)", "from subset_mset.order_trans[OF Cons(1)[OF t_in_q] this]"], ["proof (chain)\npicking this:\n  tree_to_multiset t \\<subseteq># queue_to_multiset (a # q)", "show ?thesis"], ["proof (prove)\nusing this:\n  tree_to_multiset t \\<subseteq># queue_to_multiset (a # q)\n\ngoal (1 subgoal):\n 1. tree_to_multiset t \\<subseteq># queue_to_multiset (a # q)", "."], ["proof (state)\nthis:\n  tree_to_multiset t \\<subseteq># queue_to_multiset (a # q)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  tree_to_multiset t \\<subseteq># queue_to_multiset (a # q)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma remove1_mset: \"t \\<in> set q \\<Longrightarrow> \n  queue_to_multiset (remove1 t q) = \n  queue_to_multiset q - tree_to_multiset t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<in> set q \\<Longrightarrow>\n    queue_to_multiset (remove1 t q) =\n    queue_to_multiset q - tree_to_multiset t", "by (induct q) (auto simp: qtm_in_set_subset)"], ["", "lemma remove1Prio_remove1[simp]: \n  \"remove1Prio (prio (getMinTree bq)) bq = remove1 (getMinTree bq) bq\""], ["proof (prove)\ngoal (1 subgoal):\n 1. remove1Prio (prio (getMinTree bq)) bq = remove1 (getMinTree bq) bq", "proof (induct bq)"], ["proof (state)\ngoal (2 subgoals):\n 1. remove1Prio (prio (getMinTree [])) [] = remove1 (getMinTree []) []\n 2. \\<And>a bq.\n       remove1Prio (prio (getMinTree bq)) bq =\n       remove1 (getMinTree bq) bq \\<Longrightarrow>\n       remove1Prio (prio (getMinTree (a # bq))) (a # bq) =\n       remove1 (getMinTree (a # bq)) (a # bq)", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. remove1Prio (prio (getMinTree [])) [] = remove1 (getMinTree []) []\n 2. \\<And>a bq.\n       remove1Prio (prio (getMinTree bq)) bq =\n       remove1 (getMinTree bq) bq \\<Longrightarrow>\n       remove1Prio (prio (getMinTree (a # bq))) (a # bq) =\n       remove1 (getMinTree (a # bq)) (a # bq)", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. remove1Prio (prio (getMinTree [])) [] = remove1 (getMinTree []) []", "by simp"], ["proof (state)\nthis:\n  remove1Prio (prio (getMinTree [])) [] = remove1 (getMinTree []) []\n\ngoal (1 subgoal):\n 1. \\<And>a bq.\n       remove1Prio (prio (getMinTree bq)) bq =\n       remove1 (getMinTree bq) bq \\<Longrightarrow>\n       remove1Prio (prio (getMinTree (a # bq))) (a # bq) =\n       remove1 (getMinTree (a # bq)) (a # bq)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a bq.\n       remove1Prio (prio (getMinTree bq)) bq =\n       remove1 (getMinTree bq) bq \\<Longrightarrow>\n       remove1Prio (prio (getMinTree (a # bq))) (a # bq) =\n       remove1 (getMinTree (a # bq)) (a # bq)", "case (Cons t bq)"], ["proof (state)\nthis:\n  remove1Prio (prio (getMinTree bq)) bq = remove1 (getMinTree bq) bq\n\ngoal (1 subgoal):\n 1. \\<And>a bq.\n       remove1Prio (prio (getMinTree bq)) bq =\n       remove1 (getMinTree bq) bq \\<Longrightarrow>\n       remove1Prio (prio (getMinTree (a # bq))) (a # bq) =\n       remove1 (getMinTree (a # bq)) (a # bq)", "note iv = Cons"], ["proof (state)\nthis:\n  remove1Prio (prio (getMinTree bq)) bq = remove1 (getMinTree bq) bq\n\ngoal (1 subgoal):\n 1. \\<And>a bq.\n       remove1Prio (prio (getMinTree bq)) bq =\n       remove1 (getMinTree bq) bq \\<Longrightarrow>\n       remove1Prio (prio (getMinTree (a # bq))) (a # bq) =\n       remove1 (getMinTree (a # bq)) (a # bq)", "thus ?case"], ["proof (prove)\nusing this:\n  remove1Prio (prio (getMinTree bq)) bq = remove1 (getMinTree bq) bq\n\ngoal (1 subgoal):\n 1. remove1Prio (prio (getMinTree (t # bq))) (t # bq) =\n    remove1 (getMinTree (t # bq)) (t # bq)", "proof (cases \"t = getMinTree (t # bq)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>remove1Prio (prio (getMinTree bq)) bq =\n             remove1 (getMinTree bq) bq;\n     t = getMinTree (t # bq)\\<rbrakk>\n    \\<Longrightarrow> remove1Prio (prio (getMinTree (t # bq))) (t # bq) =\n                      remove1 (getMinTree (t # bq)) (t # bq)\n 2. \\<lbrakk>remove1Prio (prio (getMinTree bq)) bq =\n             remove1 (getMinTree bq) bq;\n     t \\<noteq> getMinTree (t # bq)\\<rbrakk>\n    \\<Longrightarrow> remove1Prio (prio (getMinTree (t # bq))) (t # bq) =\n                      remove1 (getMinTree (t # bq)) (t # bq)", "case True"], ["proof (state)\nthis:\n  t = getMinTree (t # bq)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>remove1Prio (prio (getMinTree bq)) bq =\n             remove1 (getMinTree bq) bq;\n     t = getMinTree (t # bq)\\<rbrakk>\n    \\<Longrightarrow> remove1Prio (prio (getMinTree (t # bq))) (t # bq) =\n                      remove1 (getMinTree (t # bq)) (t # bq)\n 2. \\<lbrakk>remove1Prio (prio (getMinTree bq)) bq =\n             remove1 (getMinTree bq) bq;\n     t \\<noteq> getMinTree (t # bq)\\<rbrakk>\n    \\<Longrightarrow> remove1Prio (prio (getMinTree (t # bq))) (t # bq) =\n                      remove1 (getMinTree (t # bq)) (t # bq)", "with iv"], ["proof (chain)\npicking this:\n  remove1Prio (prio (getMinTree bq)) bq = remove1 (getMinTree bq) bq\n  t = getMinTree (t # bq)", "show ?thesis"], ["proof (prove)\nusing this:\n  remove1Prio (prio (getMinTree bq)) bq = remove1 (getMinTree bq) bq\n  t = getMinTree (t # bq)\n\ngoal (1 subgoal):\n 1. remove1Prio (prio (getMinTree (t # bq))) (t # bq) =\n    remove1 (getMinTree (t # bq)) (t # bq)", "by simp"], ["proof (state)\nthis:\n  remove1Prio (prio (getMinTree (t # bq))) (t # bq) =\n  remove1 (getMinTree (t # bq)) (t # bq)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>remove1Prio (prio (getMinTree bq)) bq =\n             remove1 (getMinTree bq) bq;\n     t \\<noteq> getMinTree (t # bq)\\<rbrakk>\n    \\<Longrightarrow> remove1Prio (prio (getMinTree (t # bq))) (t # bq) =\n                      remove1 (getMinTree (t # bq)) (t # bq)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>remove1Prio (prio (getMinTree bq)) bq =\n             remove1 (getMinTree bq) bq;\n     t \\<noteq> getMinTree (t # bq)\\<rbrakk>\n    \\<Longrightarrow> remove1Prio (prio (getMinTree (t # bq))) (t # bq) =\n                      remove1 (getMinTree (t # bq)) (t # bq)", "case False"], ["proof (state)\nthis:\n  t \\<noteq> getMinTree (t # bq)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>remove1Prio (prio (getMinTree bq)) bq =\n             remove1 (getMinTree bq) bq;\n     t \\<noteq> getMinTree (t # bq)\\<rbrakk>\n    \\<Longrightarrow> remove1Prio (prio (getMinTree (t # bq))) (t # bq) =\n                      remove1 (getMinTree (t # bq)) (t # bq)", "hence ne: \"bq \\<noteq> []\""], ["proof (prove)\nusing this:\n  t \\<noteq> getMinTree (t # bq)\n\ngoal (1 subgoal):\n 1. bq \\<noteq> []", "by auto"], ["proof (state)\nthis:\n  bq \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<lbrakk>remove1Prio (prio (getMinTree bq)) bq =\n             remove1 (getMinTree bq) bq;\n     t \\<noteq> getMinTree (t # bq)\\<rbrakk>\n    \\<Longrightarrow> remove1Prio (prio (getMinTree (t # bq))) (t # bq) =\n                      remove1 (getMinTree (t # bq)) (t # bq)", "with False"], ["proof (chain)\npicking this:\n  t \\<noteq> getMinTree (t # bq)\n  bq \\<noteq> []", "have down: \"getMinTree (t # bq) = getMinTree bq\""], ["proof (prove)\nusing this:\n  t \\<noteq> getMinTree (t # bq)\n  bq \\<noteq> []\n\ngoal (1 subgoal):\n 1. getMinTree (t # bq) = getMinTree bq", "by (induct bq rule: getMinTree.induct) auto"], ["proof (state)\nthis:\n  getMinTree (t # bq) = getMinTree bq\n\ngoal (1 subgoal):\n 1. \\<lbrakk>remove1Prio (prio (getMinTree bq)) bq =\n             remove1 (getMinTree bq) bq;\n     t \\<noteq> getMinTree (t # bq)\\<rbrakk>\n    \\<Longrightarrow> remove1Prio (prio (getMinTree (t # bq))) (t # bq) =\n                      remove1 (getMinTree (t # bq)) (t # bq)", "from ne False"], ["proof (chain)\npicking this:\n  bq \\<noteq> []\n  t \\<noteq> getMinTree (t # bq)", "have \"prio t \\<noteq> prio (getMinTree bq)\""], ["proof (prove)\nusing this:\n  bq \\<noteq> []\n  t \\<noteq> getMinTree (t # bq)\n\ngoal (1 subgoal):\n 1. prio t \\<noteq> prio (getMinTree bq)", "by (induct bq rule: getMinTree.induct) auto"], ["proof (state)\nthis:\n  prio t \\<noteq> prio (getMinTree bq)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>remove1Prio (prio (getMinTree bq)) bq =\n             remove1 (getMinTree bq) bq;\n     t \\<noteq> getMinTree (t # bq)\\<rbrakk>\n    \\<Longrightarrow> remove1Prio (prio (getMinTree (t # bq))) (t # bq) =\n                      remove1 (getMinTree (t # bq)) (t # bq)", "with down iv False ne"], ["proof (chain)\npicking this:\n  getMinTree (t # bq) = getMinTree bq\n  remove1Prio (prio (getMinTree bq)) bq = remove1 (getMinTree bq) bq\n  t \\<noteq> getMinTree (t # bq)\n  bq \\<noteq> []\n  prio t \\<noteq> prio (getMinTree bq)", "show ?thesis"], ["proof (prove)\nusing this:\n  getMinTree (t # bq) = getMinTree bq\n  remove1Prio (prio (getMinTree bq)) bq = remove1 (getMinTree bq) bq\n  t \\<noteq> getMinTree (t # bq)\n  bq \\<noteq> []\n  prio t \\<noteq> prio (getMinTree bq)\n\ngoal (1 subgoal):\n 1. remove1Prio (prio (getMinTree (t # bq))) (t # bq) =\n    remove1 (getMinTree (t # bq)) (t # bq)", "by simp"], ["proof (state)\nthis:\n  remove1Prio (prio (getMinTree (t # bq))) (t # bq) =\n  remove1 (getMinTree (t # bq)) (t # bq)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  remove1Prio (prio (getMinTree (t # bq))) (t # bq) =\n  remove1 (getMinTree (t # bq)) (t # bq)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma deleteMin_queue_invar: \n  assumes INV: \"queue_invar q\" \n  assumes NE: \"q \\<noteq> Nil\"\n  shows \"queue_invar (deleteMin q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. queue_invar (deleteMin q)", "proof (cases q)"], ["proof (state)\ngoal (2 subgoals):\n 1. q = [] \\<Longrightarrow> queue_invar (deleteMin q)\n 2. \\<And>a list. q = a # list \\<Longrightarrow> queue_invar (deleteMin q)", "case Nil"], ["proof (state)\nthis:\n  q = []\n\ngoal (2 subgoals):\n 1. q = [] \\<Longrightarrow> queue_invar (deleteMin q)\n 2. \\<And>a list. q = a # list \\<Longrightarrow> queue_invar (deleteMin q)", "with assms"], ["proof (chain)\npicking this:\n  queue_invar q\n  q \\<noteq> []\n  q = []", "show ?thesis"], ["proof (prove)\nusing this:\n  queue_invar q\n  q \\<noteq> []\n  q = []\n\ngoal (1 subgoal):\n 1. queue_invar (deleteMin q)", "by simp"], ["proof (state)\nthis:\n  queue_invar (deleteMin q)\n\ngoal (1 subgoal):\n 1. \\<And>a list. q = a # list \\<Longrightarrow> queue_invar (deleteMin q)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list. q = a # list \\<Longrightarrow> queue_invar (deleteMin q)", "case Cons"], ["proof (state)\nthis:\n  q = a_ # list_\n\ngoal (1 subgoal):\n 1. \\<And>a list. q = a # list \\<Longrightarrow> queue_invar (deleteMin q)", "from NE and mintree_exists[of q] INV"], ["proof (chain)\npicking this:\n  q \\<noteq> []\n  (q \\<noteq> []) = (getMinTree q \\<in> set q)\n  queue_invar q", "have inv_min: \"tree_invar (getMinTree q)\""], ["proof (prove)\nusing this:\n  q \\<noteq> []\n  (q \\<noteq> []) = (getMinTree q \\<in> set q)\n  queue_invar q\n\ngoal (1 subgoal):\n 1. tree_invar (getMinTree q)", "by (simp add: queue_invar_def)"], ["proof (state)\nthis:\n  tree_invar (getMinTree q)\n\ngoal (1 subgoal):\n 1. \\<And>a list. q = a # list \\<Longrightarrow> queue_invar (deleteMin q)", "note inv_children = invar_children'[OF inv_min]"], ["proof (state)\nthis:\n  queue_invar (children (getMinTree q))\n\ngoal (1 subgoal):\n 1. \\<And>a list. q = a # list \\<Longrightarrow> queue_invar (deleteMin q)", "note inv_rev = queue_invar_rev[OF inv_children]"], ["proof (state)\nthis:\n  queue_invar (rev (children (getMinTree q)))\n\ngoal (1 subgoal):\n 1. \\<And>a list. q = a # list \\<Longrightarrow> queue_invar (deleteMin q)", "note inv_rem = queue_invar_remove1[OF INV, of \"getMinTree q\"]"], ["proof (state)\nthis:\n  queue_invar (remove1 (getMinTree q) q)\n\ngoal (1 subgoal):\n 1. \\<And>a list. q = a # list \\<Longrightarrow> queue_invar (deleteMin q)", "from meld_queue_invar[OF inv_rev inv_rem]"], ["proof (chain)\npicking this:\n  queue_invar\n   (meld (rev (children (getMinTree q))) (remove1 (getMinTree q) q))", "show ?thesis"], ["proof (prove)\nusing this:\n  queue_invar\n   (meld (rev (children (getMinTree q))) (remove1 (getMinTree q) q))\n\ngoal (1 subgoal):\n 1. queue_invar (deleteMin q)", "by (simp add: deleteMin_def Let_def)"], ["proof (state)\nthis:\n  queue_invar (deleteMin q)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma children_rank_less: \n  assumes \"tree_invar t\"\n  shows \"\\<forall>t' \\<in> set (children t). rank t' < rank t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>t'\\<in>set (children t). rank t' < rank t", "proof (cases t)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x3 x4.\n       t = Node x1 x2 x3 x4 \\<Longrightarrow>\n       \\<forall>t'\\<in>set (children t). rank t' < rank t", "case (Node e a nat list)"], ["proof (state)\nthis:\n  t = Node e a nat list\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x3 x4.\n       t = Node x1 x2 x3 x4 \\<Longrightarrow>\n       \\<forall>t'\\<in>set (children t). rank t' < rank t", "with assms"], ["proof (chain)\npicking this:\n  tree_invar t\n  t = Node e a nat list", "show ?thesis"], ["proof (prove)\nusing this:\n  tree_invar t\n  t = Node e a nat list\n\ngoal (1 subgoal):\n 1. \\<forall>t'\\<in>set (children t). rank t' < rank t", "proof (induct nat arbitrary: t e a list)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>t e a list.\n       \\<lbrakk>tree_invar t; t = Node e a 0 list\\<rbrakk>\n       \\<Longrightarrow> \\<forall>t'\\<in>set (children t). rank t' < rank t\n 2. \\<And>nat t e a list.\n       \\<lbrakk>\\<And>t e a list.\n                   \\<lbrakk>tree_invar t; t = Node e a nat list\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>t'\\<in>set (children t).\n  rank t' < rank t;\n        tree_invar t; t = Node e a (Suc nat) list\\<rbrakk>\n       \\<Longrightarrow> \\<forall>t'\\<in>set (children t). rank t' < rank t", "case 0"], ["proof (state)\nthis:\n  tree_invar t\n  t = Node e a 0 list\n\ngoal (2 subgoals):\n 1. \\<And>t e a list.\n       \\<lbrakk>tree_invar t; t = Node e a 0 list\\<rbrakk>\n       \\<Longrightarrow> \\<forall>t'\\<in>set (children t). rank t' < rank t\n 2. \\<And>nat t e a list.\n       \\<lbrakk>\\<And>t e a list.\n                   \\<lbrakk>tree_invar t; t = Node e a nat list\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>t'\\<in>set (children t).\n  rank t' < rank t;\n        tree_invar t; t = Node e a (Suc nat) list\\<rbrakk>\n       \\<Longrightarrow> \\<forall>t'\\<in>set (children t). rank t' < rank t", "then"], ["proof (chain)\npicking this:\n  tree_invar t\n  t = Node e a 0 list", "show ?case"], ["proof (prove)\nusing this:\n  tree_invar t\n  t = Node e a 0 list\n\ngoal (1 subgoal):\n 1. \\<forall>t'\\<in>set (children t). rank t' < rank t", "by simp"], ["proof (state)\nthis:\n  \\<forall>t'\\<in>set (children t). rank t' < rank t\n\ngoal (1 subgoal):\n 1. \\<And>nat t e a list.\n       \\<lbrakk>\\<And>t e a list.\n                   \\<lbrakk>tree_invar t; t = Node e a nat list\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>t'\\<in>set (children t).\n  rank t' < rank t;\n        tree_invar t; t = Node e a (Suc nat) list\\<rbrakk>\n       \\<Longrightarrow> \\<forall>t'\\<in>set (children t). rank t' < rank t", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat t e a list.\n       \\<lbrakk>\\<And>t e a list.\n                   \\<lbrakk>tree_invar t; t = Node e a nat list\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>t'\\<in>set (children t).\n  rank t' < rank t;\n        tree_invar t; t = Node e a (Suc nat) list\\<rbrakk>\n       \\<Longrightarrow> \\<forall>t'\\<in>set (children t). rank t' < rank t", "case (Suc nat)"], ["proof (state)\nthis:\n  \\<lbrakk>tree_invar ?t; ?t = Node ?e ?a nat ?list\\<rbrakk>\n  \\<Longrightarrow> \\<forall>t'\\<in>set (children ?t). rank t' < rank ?t\n  tree_invar t\n  t = Node e a (Suc nat) list\n\ngoal (1 subgoal):\n 1. \\<And>nat t e a list.\n       \\<lbrakk>\\<And>t e a list.\n                   \\<lbrakk>tree_invar t; t = Node e a nat list\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>t'\\<in>set (children t).\n  rank t' < rank t;\n        tree_invar t; t = Node e a (Suc nat) list\\<rbrakk>\n       \\<Longrightarrow> \\<forall>t'\\<in>set (children t). rank t' < rank t", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>tree_invar ?t; ?t = Node ?e ?a nat ?list\\<rbrakk>\n  \\<Longrightarrow> \\<forall>t'\\<in>set (children ?t). rank t' < rank ?t\n  tree_invar t\n  t = Node e a (Suc nat) list", "obtain e1 a1 ts1 e2 a2 ts2 where \n      O: \"tree_invar (Node e1 a1 nat ts1)\" \"tree_invar (Node e2 a2 nat ts2)\"\n        \"t = link (Node e1 a1 nat ts1) (Node e2 a2 nat ts2)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>tree_invar ?t; ?t = Node ?e ?a nat ?list\\<rbrakk>\n  \\<Longrightarrow> \\<forall>t'\\<in>set (children ?t). rank t' < rank ?t\n  tree_invar t\n  t = Node e a (Suc nat) list\n\ngoal (1 subgoal):\n 1. (\\<And>e1 a1 ts1 e2 a2 ts2.\n        \\<lbrakk>tree_invar (Node e1 a1 nat ts1);\n         tree_invar (Node e2 a2 nat ts2);\n         t = link (Node e1 a1 nat ts1) (Node e2 a2 nat ts2)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (simp only: tree_invar.simps) blast"], ["proof (state)\nthis:\n  tree_invar (Node e1 a1 nat ts1)\n  tree_invar (Node e2 a2 nat ts2)\n  t = link (Node e1 a1 nat ts1) (Node e2 a2 nat ts2)\n\ngoal (1 subgoal):\n 1. \\<And>nat t e a list.\n       \\<lbrakk>\\<And>t e a list.\n                   \\<lbrakk>tree_invar t; t = Node e a nat list\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>t'\\<in>set (children t).\n  rank t' < rank t;\n        tree_invar t; t = Node e a (Suc nat) list\\<rbrakk>\n       \\<Longrightarrow> \\<forall>t'\\<in>set (children t). rank t' < rank t", "hence ch_id: \"children t = \n      (if a1 \\<le> a2 then (Node e2 a2 nat ts2)#ts1 \n       else (Node e1 a1 nat ts1)#ts2)\""], ["proof (prove)\nusing this:\n  tree_invar (Node e1 a1 nat ts1)\n  tree_invar (Node e2 a2 nat ts2)\n  t = link (Node e1 a1 nat ts1) (Node e2 a2 nat ts2)\n\ngoal (1 subgoal):\n 1. children t =\n    (if a1 \\<le> a2 then Node e2 a2 nat ts2 # ts1\n     else Node e1 a1 nat ts1 # ts2)", "by simp"], ["proof (state)\nthis:\n  children t =\n  (if a1 \\<le> a2 then Node e2 a2 nat ts2 # ts1\n   else Node e1 a1 nat ts1 # ts2)\n\ngoal (1 subgoal):\n 1. \\<And>nat t e a list.\n       \\<lbrakk>\\<And>t e a list.\n                   \\<lbrakk>tree_invar t; t = Node e a nat list\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>t'\\<in>set (children t).\n  rank t' < rank t;\n        tree_invar t; t = Node e a (Suc nat) list\\<rbrakk>\n       \\<Longrightarrow> \\<forall>t'\\<in>set (children t). rank t' < rank t", "from O Suc(1)[of \"Node e1 a1 nat ts1\" \"e1\" \"a1\" \"ts1\"]"], ["proof (chain)\npicking this:\n  tree_invar (Node e1 a1 nat ts1)\n  tree_invar (Node e2 a2 nat ts2)\n  t = link (Node e1 a1 nat ts1) (Node e2 a2 nat ts2)\n  \\<lbrakk>tree_invar (Node e1 a1 nat ts1);\n   Node e1 a1 nat ts1 = Node e1 a1 nat ts1\\<rbrakk>\n  \\<Longrightarrow> \\<forall>t'\\<in>set (children (Node e1 a1 nat ts1)).\n                       rank t' < rank (Node e1 a1 nat ts1)", "have  p1: \"\\<forall>t'\\<in>set ((Node e2 a2 nat ts2) # ts1). rank t' < Suc nat\""], ["proof (prove)\nusing this:\n  tree_invar (Node e1 a1 nat ts1)\n  tree_invar (Node e2 a2 nat ts2)\n  t = link (Node e1 a1 nat ts1) (Node e2 a2 nat ts2)\n  \\<lbrakk>tree_invar (Node e1 a1 nat ts1);\n   Node e1 a1 nat ts1 = Node e1 a1 nat ts1\\<rbrakk>\n  \\<Longrightarrow> \\<forall>t'\\<in>set (children (Node e1 a1 nat ts1)).\n                       rank t' < rank (Node e1 a1 nat ts1)\n\ngoal (1 subgoal):\n 1. \\<forall>t'\\<in>set (Node e2 a2 nat ts2 # ts1). rank t' < Suc nat", "by auto"], ["proof (state)\nthis:\n  \\<forall>t'\\<in>set (Node e2 a2 nat ts2 # ts1). rank t' < Suc nat\n\ngoal (1 subgoal):\n 1. \\<And>nat t e a list.\n       \\<lbrakk>\\<And>t e a list.\n                   \\<lbrakk>tree_invar t; t = Node e a nat list\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>t'\\<in>set (children t).\n  rank t' < rank t;\n        tree_invar t; t = Node e a (Suc nat) list\\<rbrakk>\n       \\<Longrightarrow> \\<forall>t'\\<in>set (children t). rank t' < rank t", "from O Suc(1)[of \"Node e2 a2 nat ts2\" \"e2\" \"a2\" \"ts2\"]"], ["proof (chain)\npicking this:\n  tree_invar (Node e1 a1 nat ts1)\n  tree_invar (Node e2 a2 nat ts2)\n  t = link (Node e1 a1 nat ts1) (Node e2 a2 nat ts2)\n  \\<lbrakk>tree_invar (Node e2 a2 nat ts2);\n   Node e2 a2 nat ts2 = Node e2 a2 nat ts2\\<rbrakk>\n  \\<Longrightarrow> \\<forall>t'\\<in>set (children (Node e2 a2 nat ts2)).\n                       rank t' < rank (Node e2 a2 nat ts2)", "have p2: \"\\<forall>t'\\<in>set ((Node e1 a1 nat ts1) # ts2). rank t' < Suc nat\""], ["proof (prove)\nusing this:\n  tree_invar (Node e1 a1 nat ts1)\n  tree_invar (Node e2 a2 nat ts2)\n  t = link (Node e1 a1 nat ts1) (Node e2 a2 nat ts2)\n  \\<lbrakk>tree_invar (Node e2 a2 nat ts2);\n   Node e2 a2 nat ts2 = Node e2 a2 nat ts2\\<rbrakk>\n  \\<Longrightarrow> \\<forall>t'\\<in>set (children (Node e2 a2 nat ts2)).\n                       rank t' < rank (Node e2 a2 nat ts2)\n\ngoal (1 subgoal):\n 1. \\<forall>t'\\<in>set (Node e1 a1 nat ts1 # ts2). rank t' < Suc nat", "by auto"], ["proof (state)\nthis:\n  \\<forall>t'\\<in>set (Node e1 a1 nat ts1 # ts2). rank t' < Suc nat\n\ngoal (1 subgoal):\n 1. \\<And>nat t e a list.\n       \\<lbrakk>\\<And>t e a list.\n                   \\<lbrakk>tree_invar t; t = Node e a nat list\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>t'\\<in>set (children t).\n  rank t' < rank t;\n        tree_invar t; t = Node e a (Suc nat) list\\<rbrakk>\n       \\<Longrightarrow> \\<forall>t'\\<in>set (children t). rank t' < rank t", "from Suc(3) p1 p2 ch_id"], ["proof (chain)\npicking this:\n  t = Node e a (Suc nat) list\n  \\<forall>t'\\<in>set (Node e2 a2 nat ts2 # ts1). rank t' < Suc nat\n  \\<forall>t'\\<in>set (Node e1 a1 nat ts1 # ts2). rank t' < Suc nat\n  children t =\n  (if a1 \\<le> a2 then Node e2 a2 nat ts2 # ts1\n   else Node e1 a1 nat ts1 # ts2)", "show ?case"], ["proof (prove)\nusing this:\n  t = Node e a (Suc nat) list\n  \\<forall>t'\\<in>set (Node e2 a2 nat ts2 # ts1). rank t' < Suc nat\n  \\<forall>t'\\<in>set (Node e1 a1 nat ts1 # ts2). rank t' < Suc nat\n  children t =\n  (if a1 \\<le> a2 then Node e2 a2 nat ts2 # ts1\n   else Node e1 a1 nat ts1 # ts2)\n\ngoal (1 subgoal):\n 1. \\<forall>t'\\<in>set (children t). rank t' < rank t", "by simp"], ["proof (state)\nthis:\n  \\<forall>t'\\<in>set (children t). rank t' < rank t\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>t'\\<in>set (children t). rank t' < rank t\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma strong_rev_children:\n  assumes \"tree_invar t\"\n  shows \"invar (rev (children t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invar (rev (children t))", "unfolding invar_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. queue_invar (rev (children t)) \\<and> rank_invar (rev (children t))", "proof (cases t)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x3 x4.\n       t = Node x1 x2 x3 x4 \\<Longrightarrow>\n       queue_invar (rev (children t)) \\<and> rank_invar (rev (children t))", "case (Node e a nat list)"], ["proof (state)\nthis:\n  t = Node e a nat list\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x3 x4.\n       t = Node x1 x2 x3 x4 \\<Longrightarrow>\n       queue_invar (rev (children t)) \\<and> rank_invar (rev (children t))", "with assms"], ["proof (chain)\npicking this:\n  tree_invar t\n  t = Node e a nat list", "show \"queue_invar (rev (children t)) \\<and> rank_invar (rev (children t))\""], ["proof (prove)\nusing this:\n  tree_invar t\n  t = Node e a nat list\n\ngoal (1 subgoal):\n 1. queue_invar (rev (children t)) \\<and> rank_invar (rev (children t))", "proof (induct \"nat\" arbitrary: t e a list)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>t e a list.\n       \\<lbrakk>tree_invar t; t = Node e a 0 list\\<rbrakk>\n       \\<Longrightarrow> queue_invar (rev (children t)) \\<and>\n                         rank_invar (rev (children t))\n 2. \\<And>nat t e a list.\n       \\<lbrakk>\\<And>t e a list.\n                   \\<lbrakk>tree_invar t; t = Node e a nat list\\<rbrakk>\n                   \\<Longrightarrow> queue_invar (rev (children t)) \\<and>\n                                     rank_invar (rev (children t));\n        tree_invar t; t = Node e a (Suc nat) list\\<rbrakk>\n       \\<Longrightarrow> queue_invar (rev (children t)) \\<and>\n                         rank_invar (rev (children t))", "case 0"], ["proof (state)\nthis:\n  tree_invar t\n  t = Node e a 0 list\n\ngoal (2 subgoals):\n 1. \\<And>t e a list.\n       \\<lbrakk>tree_invar t; t = Node e a 0 list\\<rbrakk>\n       \\<Longrightarrow> queue_invar (rev (children t)) \\<and>\n                         rank_invar (rev (children t))\n 2. \\<And>nat t e a list.\n       \\<lbrakk>\\<And>t e a list.\n                   \\<lbrakk>tree_invar t; t = Node e a nat list\\<rbrakk>\n                   \\<Longrightarrow> queue_invar (rev (children t)) \\<and>\n                                     rank_invar (rev (children t));\n        tree_invar t; t = Node e a (Suc nat) list\\<rbrakk>\n       \\<Longrightarrow> queue_invar (rev (children t)) \\<and>\n                         rank_invar (rev (children t))", "then"], ["proof (chain)\npicking this:\n  tree_invar t\n  t = Node e a 0 list", "show ?case"], ["proof (prove)\nusing this:\n  tree_invar t\n  t = Node e a 0 list\n\ngoal (1 subgoal):\n 1. queue_invar (rev (children t)) \\<and> rank_invar (rev (children t))", "by simp"], ["proof (state)\nthis:\n  queue_invar (rev (children t)) \\<and> rank_invar (rev (children t))\n\ngoal (1 subgoal):\n 1. \\<And>nat t e a list.\n       \\<lbrakk>\\<And>t e a list.\n                   \\<lbrakk>tree_invar t; t = Node e a nat list\\<rbrakk>\n                   \\<Longrightarrow> queue_invar (rev (children t)) \\<and>\n                                     rank_invar (rev (children t));\n        tree_invar t; t = Node e a (Suc nat) list\\<rbrakk>\n       \\<Longrightarrow> queue_invar (rev (children t)) \\<and>\n                         rank_invar (rev (children t))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat t e a list.\n       \\<lbrakk>\\<And>t e a list.\n                   \\<lbrakk>tree_invar t; t = Node e a nat list\\<rbrakk>\n                   \\<Longrightarrow> queue_invar (rev (children t)) \\<and>\n                                     rank_invar (rev (children t));\n        tree_invar t; t = Node e a (Suc nat) list\\<rbrakk>\n       \\<Longrightarrow> queue_invar (rev (children t)) \\<and>\n                         rank_invar (rev (children t))", "case (Suc nat)"], ["proof (state)\nthis:\n  \\<lbrakk>tree_invar ?t; ?t = Node ?e ?a nat ?list\\<rbrakk>\n  \\<Longrightarrow> queue_invar (rev (children ?t)) \\<and>\n                    rank_invar (rev (children ?t))\n  tree_invar t\n  t = Node e a (Suc nat) list\n\ngoal (1 subgoal):\n 1. \\<And>nat t e a list.\n       \\<lbrakk>\\<And>t e a list.\n                   \\<lbrakk>tree_invar t; t = Node e a nat list\\<rbrakk>\n                   \\<Longrightarrow> queue_invar (rev (children t)) \\<and>\n                                     rank_invar (rev (children t));\n        tree_invar t; t = Node e a (Suc nat) list\\<rbrakk>\n       \\<Longrightarrow> queue_invar (rev (children t)) \\<and>\n                         rank_invar (rev (children t))", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>tree_invar ?t; ?t = Node ?e ?a nat ?list\\<rbrakk>\n  \\<Longrightarrow> queue_invar (rev (children ?t)) \\<and>\n                    rank_invar (rev (children ?t))\n  tree_invar t\n  t = Node e a (Suc nat) list", "obtain e1 a1 ts1 e2 a2 ts2 where \n      O: \"tree_invar (Node e1 a1 nat ts1)\" \"tree_invar (Node e2 a2 nat ts2)\"\n        \"t = link (Node e1 a1 nat ts1) (Node e2 a2 nat ts2)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>tree_invar ?t; ?t = Node ?e ?a nat ?list\\<rbrakk>\n  \\<Longrightarrow> queue_invar (rev (children ?t)) \\<and>\n                    rank_invar (rev (children ?t))\n  tree_invar t\n  t = Node e a (Suc nat) list\n\ngoal (1 subgoal):\n 1. (\\<And>e1 a1 ts1 e2 a2 ts2.\n        \\<lbrakk>tree_invar (Node e1 a1 nat ts1);\n         tree_invar (Node e2 a2 nat ts2);\n         t = link (Node e1 a1 nat ts1) (Node e2 a2 nat ts2)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (simp only: tree_invar.simps) blast"], ["proof (state)\nthis:\n  tree_invar (Node e1 a1 nat ts1)\n  tree_invar (Node e2 a2 nat ts2)\n  t = link (Node e1 a1 nat ts1) (Node e2 a2 nat ts2)\n\ngoal (1 subgoal):\n 1. \\<And>nat t e a list.\n       \\<lbrakk>\\<And>t e a list.\n                   \\<lbrakk>tree_invar t; t = Node e a nat list\\<rbrakk>\n                   \\<Longrightarrow> queue_invar (rev (children t)) \\<and>\n                                     rank_invar (rev (children t));\n        tree_invar t; t = Node e a (Suc nat) list\\<rbrakk>\n       \\<Longrightarrow> queue_invar (rev (children t)) \\<and>\n                         rank_invar (rev (children t))", "hence ch_id: \"children t = \n      (if a1 \\<le> a2 then (Node e2 a2 nat ts2)#ts1 \n       else (Node e1 a1 nat ts1)#ts2)\""], ["proof (prove)\nusing this:\n  tree_invar (Node e1 a1 nat ts1)\n  tree_invar (Node e2 a2 nat ts2)\n  t = link (Node e1 a1 nat ts1) (Node e2 a2 nat ts2)\n\ngoal (1 subgoal):\n 1. children t =\n    (if a1 \\<le> a2 then Node e2 a2 nat ts2 # ts1\n     else Node e1 a1 nat ts1 # ts2)", "by simp"], ["proof (state)\nthis:\n  children t =\n  (if a1 \\<le> a2 then Node e2 a2 nat ts2 # ts1\n   else Node e1 a1 nat ts1 # ts2)\n\ngoal (1 subgoal):\n 1. \\<And>nat t e a list.\n       \\<lbrakk>\\<And>t e a list.\n                   \\<lbrakk>tree_invar t; t = Node e a nat list\\<rbrakk>\n                   \\<Longrightarrow> queue_invar (rev (children t)) \\<and>\n                                     rank_invar (rev (children t));\n        tree_invar t; t = Node e a (Suc nat) list\\<rbrakk>\n       \\<Longrightarrow> queue_invar (rev (children t)) \\<and>\n                         rank_invar (rev (children t))", "from O Suc(1)[of \"Node e1 a1 nat ts1\" \"e1\" \"a1\" \"ts1\"]"], ["proof (chain)\npicking this:\n  tree_invar (Node e1 a1 nat ts1)\n  tree_invar (Node e2 a2 nat ts2)\n  t = link (Node e1 a1 nat ts1) (Node e2 a2 nat ts2)\n  \\<lbrakk>tree_invar (Node e1 a1 nat ts1);\n   Node e1 a1 nat ts1 = Node e1 a1 nat ts1\\<rbrakk>\n  \\<Longrightarrow> queue_invar (rev (children (Node e1 a1 nat ts1))) \\<and>\n                    rank_invar (rev (children (Node e1 a1 nat ts1)))", "have rev_ts1: \"invar (rev ts1)\""], ["proof (prove)\nusing this:\n  tree_invar (Node e1 a1 nat ts1)\n  tree_invar (Node e2 a2 nat ts2)\n  t = link (Node e1 a1 nat ts1) (Node e2 a2 nat ts2)\n  \\<lbrakk>tree_invar (Node e1 a1 nat ts1);\n   Node e1 a1 nat ts1 = Node e1 a1 nat ts1\\<rbrakk>\n  \\<Longrightarrow> queue_invar (rev (children (Node e1 a1 nat ts1))) \\<and>\n                    rank_invar (rev (children (Node e1 a1 nat ts1)))\n\ngoal (1 subgoal):\n 1. invar (rev ts1)", "by (simp add: invar_def)"], ["proof (state)\nthis:\n  invar (rev ts1)\n\ngoal (1 subgoal):\n 1. \\<And>nat t e a list.\n       \\<lbrakk>\\<And>t e a list.\n                   \\<lbrakk>tree_invar t; t = Node e a nat list\\<rbrakk>\n                   \\<Longrightarrow> queue_invar (rev (children t)) \\<and>\n                                     rank_invar (rev (children t));\n        tree_invar t; t = Node e a (Suc nat) list\\<rbrakk>\n       \\<Longrightarrow> queue_invar (rev (children t)) \\<and>\n                         rank_invar (rev (children t))", "from O children_rank_less[of \"Node e1 a1 nat ts1\"]"], ["proof (chain)\npicking this:\n  tree_invar (Node e1 a1 nat ts1)\n  tree_invar (Node e2 a2 nat ts2)\n  t = link (Node e1 a1 nat ts1) (Node e2 a2 nat ts2)\n  tree_invar (Node e1 a1 nat ts1) \\<Longrightarrow>\n  \\<forall>t'\\<in>set (children (Node e1 a1 nat ts1)).\n     rank t' < rank (Node e1 a1 nat ts1)", "have  \"\\<forall>t\\<in>set (rev ts1). rank t < rank (Node e2 a2 nat ts2)\""], ["proof (prove)\nusing this:\n  tree_invar (Node e1 a1 nat ts1)\n  tree_invar (Node e2 a2 nat ts2)\n  t = link (Node e1 a1 nat ts1) (Node e2 a2 nat ts2)\n  tree_invar (Node e1 a1 nat ts1) \\<Longrightarrow>\n  \\<forall>t'\\<in>set (children (Node e1 a1 nat ts1)).\n     rank t' < rank (Node e1 a1 nat ts1)\n\ngoal (1 subgoal):\n 1. \\<forall>t\\<in>set (rev ts1). rank t < rank (Node e2 a2 nat ts2)", "by simp"], ["proof (state)\nthis:\n  \\<forall>t\\<in>set (rev ts1). rank t < rank (Node e2 a2 nat ts2)\n\ngoal (1 subgoal):\n 1. \\<And>nat t e a list.\n       \\<lbrakk>\\<And>t e a list.\n                   \\<lbrakk>tree_invar t; t = Node e a nat list\\<rbrakk>\n                   \\<Longrightarrow> queue_invar (rev (children t)) \\<and>\n                                     rank_invar (rev (children t));\n        tree_invar t; t = Node e a (Suc nat) list\\<rbrakk>\n       \\<Longrightarrow> queue_invar (rev (children t)) \\<and>\n                         rank_invar (rev (children t))", "with O rev_ts1 invar_app_single[of \"rev ts1\" \"Node e2 a2 nat ts2\"]"], ["proof (chain)\npicking this:\n  tree_invar (Node e1 a1 nat ts1)\n  tree_invar (Node e2 a2 nat ts2)\n  t = link (Node e1 a1 nat ts1) (Node e2 a2 nat ts2)\n  invar (rev ts1)\n  \\<lbrakk>invar (rev ts1);\n   \\<forall>t\\<in>set (rev ts1). rank t < rank (Node e2 a2 nat ts2);\n   tree_invar (Node e2 a2 nat ts2)\\<rbrakk>\n  \\<Longrightarrow> invar (rev ts1 @ [Node e2 a2 nat ts2])\n  \\<forall>t\\<in>set (rev ts1). rank t < rank (Node e2 a2 nat ts2)", "have p1: \"invar (rev ((Node e2 a2 nat ts2) # ts1))\""], ["proof (prove)\nusing this:\n  tree_invar (Node e1 a1 nat ts1)\n  tree_invar (Node e2 a2 nat ts2)\n  t = link (Node e1 a1 nat ts1) (Node e2 a2 nat ts2)\n  invar (rev ts1)\n  \\<lbrakk>invar (rev ts1);\n   \\<forall>t\\<in>set (rev ts1). rank t < rank (Node e2 a2 nat ts2);\n   tree_invar (Node e2 a2 nat ts2)\\<rbrakk>\n  \\<Longrightarrow> invar (rev ts1 @ [Node e2 a2 nat ts2])\n  \\<forall>t\\<in>set (rev ts1). rank t < rank (Node e2 a2 nat ts2)\n\ngoal (1 subgoal):\n 1. invar (rev (Node e2 a2 nat ts2 # ts1))", "by simp"], ["proof (state)\nthis:\n  invar (rev (Node e2 a2 nat ts2 # ts1))\n\ngoal (1 subgoal):\n 1. \\<And>nat t e a list.\n       \\<lbrakk>\\<And>t e a list.\n                   \\<lbrakk>tree_invar t; t = Node e a nat list\\<rbrakk>\n                   \\<Longrightarrow> queue_invar (rev (children t)) \\<and>\n                                     rank_invar (rev (children t));\n        tree_invar t; t = Node e a (Suc nat) list\\<rbrakk>\n       \\<Longrightarrow> queue_invar (rev (children t)) \\<and>\n                         rank_invar (rev (children t))", "from O Suc(1)[of \"Node e2 a2 nat ts2\" \"e2\" \"a2\" \"ts2\"]"], ["proof (chain)\npicking this:\n  tree_invar (Node e1 a1 nat ts1)\n  tree_invar (Node e2 a2 nat ts2)\n  t = link (Node e1 a1 nat ts1) (Node e2 a2 nat ts2)\n  \\<lbrakk>tree_invar (Node e2 a2 nat ts2);\n   Node e2 a2 nat ts2 = Node e2 a2 nat ts2\\<rbrakk>\n  \\<Longrightarrow> queue_invar (rev (children (Node e2 a2 nat ts2))) \\<and>\n                    rank_invar (rev (children (Node e2 a2 nat ts2)))", "have rev_ts2: \"invar (rev ts2)\""], ["proof (prove)\nusing this:\n  tree_invar (Node e1 a1 nat ts1)\n  tree_invar (Node e2 a2 nat ts2)\n  t = link (Node e1 a1 nat ts1) (Node e2 a2 nat ts2)\n  \\<lbrakk>tree_invar (Node e2 a2 nat ts2);\n   Node e2 a2 nat ts2 = Node e2 a2 nat ts2\\<rbrakk>\n  \\<Longrightarrow> queue_invar (rev (children (Node e2 a2 nat ts2))) \\<and>\n                    rank_invar (rev (children (Node e2 a2 nat ts2)))\n\ngoal (1 subgoal):\n 1. invar (rev ts2)", "by (simp add: invar_def)"], ["proof (state)\nthis:\n  invar (rev ts2)\n\ngoal (1 subgoal):\n 1. \\<And>nat t e a list.\n       \\<lbrakk>\\<And>t e a list.\n                   \\<lbrakk>tree_invar t; t = Node e a nat list\\<rbrakk>\n                   \\<Longrightarrow> queue_invar (rev (children t)) \\<and>\n                                     rank_invar (rev (children t));\n        tree_invar t; t = Node e a (Suc nat) list\\<rbrakk>\n       \\<Longrightarrow> queue_invar (rev (children t)) \\<and>\n                         rank_invar (rev (children t))", "from O children_rank_less[of \"Node e2 a2 nat ts2\"]"], ["proof (chain)\npicking this:\n  tree_invar (Node e1 a1 nat ts1)\n  tree_invar (Node e2 a2 nat ts2)\n  t = link (Node e1 a1 nat ts1) (Node e2 a2 nat ts2)\n  tree_invar (Node e2 a2 nat ts2) \\<Longrightarrow>\n  \\<forall>t'\\<in>set (children (Node e2 a2 nat ts2)).\n     rank t' < rank (Node e2 a2 nat ts2)", "have \"\\<forall>t\\<in>set (rev ts2). rank t < rank (Node e1 a1 nat ts1)\""], ["proof (prove)\nusing this:\n  tree_invar (Node e1 a1 nat ts1)\n  tree_invar (Node e2 a2 nat ts2)\n  t = link (Node e1 a1 nat ts1) (Node e2 a2 nat ts2)\n  tree_invar (Node e2 a2 nat ts2) \\<Longrightarrow>\n  \\<forall>t'\\<in>set (children (Node e2 a2 nat ts2)).\n     rank t' < rank (Node e2 a2 nat ts2)\n\ngoal (1 subgoal):\n 1. \\<forall>t\\<in>set (rev ts2). rank t < rank (Node e1 a1 nat ts1)", "by simp"], ["proof (state)\nthis:\n  \\<forall>t\\<in>set (rev ts2). rank t < rank (Node e1 a1 nat ts1)\n\ngoal (1 subgoal):\n 1. \\<And>nat t e a list.\n       \\<lbrakk>\\<And>t e a list.\n                   \\<lbrakk>tree_invar t; t = Node e a nat list\\<rbrakk>\n                   \\<Longrightarrow> queue_invar (rev (children t)) \\<and>\n                                     rank_invar (rev (children t));\n        tree_invar t; t = Node e a (Suc nat) list\\<rbrakk>\n       \\<Longrightarrow> queue_invar (rev (children t)) \\<and>\n                         rank_invar (rev (children t))", "with O rev_ts2 invar_app_single[of \"rev ts2\" \"Node e1 a1 nat ts1\"]"], ["proof (chain)\npicking this:\n  tree_invar (Node e1 a1 nat ts1)\n  tree_invar (Node e2 a2 nat ts2)\n  t = link (Node e1 a1 nat ts1) (Node e2 a2 nat ts2)\n  invar (rev ts2)\n  \\<lbrakk>invar (rev ts2);\n   \\<forall>t\\<in>set (rev ts2). rank t < rank (Node e1 a1 nat ts1);\n   tree_invar (Node e1 a1 nat ts1)\\<rbrakk>\n  \\<Longrightarrow> invar (rev ts2 @ [Node e1 a1 nat ts1])\n  \\<forall>t\\<in>set (rev ts2). rank t < rank (Node e1 a1 nat ts1)", "have p2: \"invar (rev ((Node e1 a1 nat ts1) # ts2))\""], ["proof (prove)\nusing this:\n  tree_invar (Node e1 a1 nat ts1)\n  tree_invar (Node e2 a2 nat ts2)\n  t = link (Node e1 a1 nat ts1) (Node e2 a2 nat ts2)\n  invar (rev ts2)\n  \\<lbrakk>invar (rev ts2);\n   \\<forall>t\\<in>set (rev ts2). rank t < rank (Node e1 a1 nat ts1);\n   tree_invar (Node e1 a1 nat ts1)\\<rbrakk>\n  \\<Longrightarrow> invar (rev ts2 @ [Node e1 a1 nat ts1])\n  \\<forall>t\\<in>set (rev ts2). rank t < rank (Node e1 a1 nat ts1)\n\ngoal (1 subgoal):\n 1. invar (rev (Node e1 a1 nat ts1 # ts2))", "by simp"], ["proof (state)\nthis:\n  invar (rev (Node e1 a1 nat ts1 # ts2))\n\ngoal (1 subgoal):\n 1. \\<And>nat t e a list.\n       \\<lbrakk>\\<And>t e a list.\n                   \\<lbrakk>tree_invar t; t = Node e a nat list\\<rbrakk>\n                   \\<Longrightarrow> queue_invar (rev (children t)) \\<and>\n                                     rank_invar (rev (children t));\n        tree_invar t; t = Node e a (Suc nat) list\\<rbrakk>\n       \\<Longrightarrow> queue_invar (rev (children t)) \\<and>\n                         rank_invar (rev (children t))", "from p1 p2 ch_id"], ["proof (chain)\npicking this:\n  invar (rev (Node e2 a2 nat ts2 # ts1))\n  invar (rev (Node e1 a1 nat ts1 # ts2))\n  children t =\n  (if a1 \\<le> a2 then Node e2 a2 nat ts2 # ts1\n   else Node e1 a1 nat ts1 # ts2)", "show ?case"], ["proof (prove)\nusing this:\n  invar (rev (Node e2 a2 nat ts2 # ts1))\n  invar (rev (Node e1 a1 nat ts1 # ts2))\n  children t =\n  (if a1 \\<le> a2 then Node e2 a2 nat ts2 # ts1\n   else Node e1 a1 nat ts1 # ts2)\n\ngoal (1 subgoal):\n 1. queue_invar (rev (children t)) \\<and> rank_invar (rev (children t))", "by (simp add: invar_def)"], ["proof (state)\nthis:\n  queue_invar (rev (children t)) \\<and> rank_invar (rev (children t))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  queue_invar (rev (children t)) \\<and> rank_invar (rev (children t))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma first_less: \"rank_invar (t # bq) \\<Longrightarrow> \\<forall>t' \\<in> set bq. rank t < rank t'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rank_invar (t # bq) \\<Longrightarrow>\n    \\<forall>t'\\<in>set bq. rank t < rank t'", "apply(induct bq arbitrary: t)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>t.\n       rank_invar [t] \\<Longrightarrow>\n       \\<forall>t'\\<in>set []. rank t < rank t'\n 2. \\<And>a bq t.\n       \\<lbrakk>\\<And>t.\n                   rank_invar (t # bq) \\<Longrightarrow>\n                   \\<forall>t'\\<in>set bq. rank t < rank t';\n        rank_invar (t # a # bq)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>t'\\<in>set (a # bq). rank t < rank t'", "apply (simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a bq t.\n       \\<lbrakk>\\<And>t.\n                   rank_invar (t # bq) \\<Longrightarrow>\n                   \\<forall>t'\\<in>set bq. rank t < rank t';\n        rank_invar (t # a # bq)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>t'\\<in>set (a # bq). rank t < rank t'", "apply (metis order_le_less rank_invar.simps(3) set_ConsD xt1(7))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma strong_remove1: \"invar bq \\<Longrightarrow> invar (remove1 t bq)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invar bq \\<Longrightarrow> invar (remove1 t bq)", "proof (induct bq arbitrary: t)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>t. invar [] \\<Longrightarrow> invar (remove1 t [])\n 2. \\<And>a bq t.\n       \\<lbrakk>\\<And>t. invar bq \\<Longrightarrow> invar (remove1 t bq);\n        invar (a # bq)\\<rbrakk>\n       \\<Longrightarrow> invar (remove1 t (a # bq))", "case Nil"], ["proof (state)\nthis:\n  invar []\n\ngoal (2 subgoals):\n 1. \\<And>t. invar [] \\<Longrightarrow> invar (remove1 t [])\n 2. \\<And>a bq t.\n       \\<lbrakk>\\<And>t. invar bq \\<Longrightarrow> invar (remove1 t bq);\n        invar (a # bq)\\<rbrakk>\n       \\<Longrightarrow> invar (remove1 t (a # bq))", "then"], ["proof (chain)\npicking this:\n  invar []", "show ?case"], ["proof (prove)\nusing this:\n  invar []\n\ngoal (1 subgoal):\n 1. invar (remove1 t [])", "by simp"], ["proof (state)\nthis:\n  invar (remove1 t [])\n\ngoal (1 subgoal):\n 1. \\<And>a bq t.\n       \\<lbrakk>\\<And>t. invar bq \\<Longrightarrow> invar (remove1 t bq);\n        invar (a # bq)\\<rbrakk>\n       \\<Longrightarrow> invar (remove1 t (a # bq))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a bq t.\n       \\<lbrakk>\\<And>t. invar bq \\<Longrightarrow> invar (remove1 t bq);\n        invar (a # bq)\\<rbrakk>\n       \\<Longrightarrow> invar (remove1 t (a # bq))", "case (Cons a bq)"], ["proof (state)\nthis:\n  invar bq \\<Longrightarrow> invar (remove1 ?t bq)\n  invar (a # bq)\n\ngoal (1 subgoal):\n 1. \\<And>a bq t.\n       \\<lbrakk>\\<And>t. invar bq \\<Longrightarrow> invar (remove1 t bq);\n        invar (a # bq)\\<rbrakk>\n       \\<Longrightarrow> invar (remove1 t (a # bq))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. invar (remove1 t (a # bq))", "proof (cases \"t=a\")"], ["proof (state)\ngoal (2 subgoals):\n 1. t = a \\<Longrightarrow> invar (remove1 t (a # bq))\n 2. t \\<noteq> a \\<Longrightarrow> invar (remove1 t (a # bq))", "case True"], ["proof (state)\nthis:\n  t = a\n\ngoal (2 subgoals):\n 1. t = a \\<Longrightarrow> invar (remove1 t (a # bq))\n 2. t \\<noteq> a \\<Longrightarrow> invar (remove1 t (a # bq))", "from Cons(2)"], ["proof (chain)\npicking this:\n  invar (a # bq)", "have \"invar bq\""], ["proof (prove)\nusing this:\n  invar (a # bq)\n\ngoal (1 subgoal):\n 1. invar bq", "by (rule invar_cons_down)"], ["proof (state)\nthis:\n  invar bq\n\ngoal (2 subgoals):\n 1. t = a \\<Longrightarrow> invar (remove1 t (a # bq))\n 2. t \\<noteq> a \\<Longrightarrow> invar (remove1 t (a # bq))", "with True"], ["proof (chain)\npicking this:\n  t = a\n  invar bq", "show ?thesis"], ["proof (prove)\nusing this:\n  t = a\n  invar bq\n\ngoal (1 subgoal):\n 1. invar (remove1 t (a # bq))", "by simp"], ["proof (state)\nthis:\n  invar (remove1 t (a # bq))\n\ngoal (1 subgoal):\n 1. t \\<noteq> a \\<Longrightarrow> invar (remove1 t (a # bq))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. t \\<noteq> a \\<Longrightarrow> invar (remove1 t (a # bq))", "case False"], ["proof (state)\nthis:\n  t \\<noteq> a\n\ngoal (1 subgoal):\n 1. t \\<noteq> a \\<Longrightarrow> invar (remove1 t (a # bq))", "from Cons(2)"], ["proof (chain)\npicking this:\n  invar (a # bq)", "have \"invar bq\""], ["proof (prove)\nusing this:\n  invar (a # bq)\n\ngoal (1 subgoal):\n 1. invar bq", "by (rule invar_cons_down)"], ["proof (state)\nthis:\n  invar bq\n\ngoal (1 subgoal):\n 1. t \\<noteq> a \\<Longrightarrow> invar (remove1 t (a # bq))", "with Cons(1)[of \"t\"]"], ["proof (chain)\npicking this:\n  invar bq \\<Longrightarrow> invar (remove1 t bq)\n  invar bq", "have si1: \"invar (remove1 t bq)\""], ["proof (prove)\nusing this:\n  invar bq \\<Longrightarrow> invar (remove1 t bq)\n  invar bq\n\ngoal (1 subgoal):\n 1. invar (remove1 t bq)", "."], ["proof (state)\nthis:\n  invar (remove1 t bq)\n\ngoal (1 subgoal):\n 1. t \\<noteq> a \\<Longrightarrow> invar (remove1 t (a # bq))", "from False"], ["proof (chain)\npicking this:\n  t \\<noteq> a", "have \"invar (remove1 t (a # bq)) = invar (a # (remove1 t bq))\""], ["proof (prove)\nusing this:\n  t \\<noteq> a\n\ngoal (1 subgoal):\n 1. invar (remove1 t (a # bq)) = invar (a # remove1 t bq)", "by simp"], ["proof (state)\nthis:\n  invar (remove1 t (a # bq)) = invar (a # remove1 t bq)\n\ngoal (1 subgoal):\n 1. t \\<noteq> a \\<Longrightarrow> invar (remove1 t (a # bq))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. invar (remove1 t (a # bq))", "proof (cases \"remove1 t bq\")"], ["proof (state)\ngoal (2 subgoals):\n 1. remove1 t bq = [] \\<Longrightarrow> invar (remove1 t (a # bq))\n 2. \\<And>aa list.\n       remove1 t bq = aa # list \\<Longrightarrow> invar (remove1 t (a # bq))", "case Nil"], ["proof (state)\nthis:\n  remove1 t bq = []\n\ngoal (2 subgoals):\n 1. remove1 t bq = [] \\<Longrightarrow> invar (remove1 t (a # bq))\n 2. \\<And>aa list.\n       remove1 t bq = aa # list \\<Longrightarrow> invar (remove1 t (a # bq))", "with si1 Cons(2) False"], ["proof (chain)\npicking this:\n  invar (remove1 t bq)\n  invar (a # bq)\n  t \\<noteq> a\n  remove1 t bq = []", "show ?thesis"], ["proof (prove)\nusing this:\n  invar (remove1 t bq)\n  invar (a # bq)\n  t \\<noteq> a\n  remove1 t bq = []\n\ngoal (1 subgoal):\n 1. invar (remove1 t (a # bq))", "by (simp add: invar_def)"], ["proof (state)\nthis:\n  invar (remove1 t (a # bq))\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       remove1 t bq = aa # list \\<Longrightarrow> invar (remove1 t (a # bq))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       remove1 t bq = aa # list \\<Longrightarrow> invar (remove1 t (a # bq))", "case Cons': (Cons aa list)"], ["proof (state)\nthis:\n  remove1 t bq = aa # list\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       remove1 t bq = aa # list \\<Longrightarrow> invar (remove1 t (a # bq))", "from Cons"], ["proof (chain)\npicking this:\n  invar bq \\<Longrightarrow> invar (remove1 ?t bq)\n  invar (a # bq)", "have \"tree_invar a\""], ["proof (prove)\nusing this:\n  invar bq \\<Longrightarrow> invar (remove1 ?t bq)\n  invar (a # bq)\n\ngoal (1 subgoal):\n 1. tree_invar a", "by (simp add: invar_def)"], ["proof (state)\nthis:\n  tree_invar a\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       remove1 t bq = aa # list \\<Longrightarrow> invar (remove1 t (a # bq))", "from Cons first_less[of \"a\" \"bq\"]"], ["proof (chain)\npicking this:\n  invar bq \\<Longrightarrow> invar (remove1 ?t bq)\n  invar (a # bq)\n  rank_invar (a # bq) \\<Longrightarrow>\n  \\<forall>t'\\<in>set bq. rank a < rank t'", "have \"\\<forall>t \\<in> set (remove1 t bq). rank a < rank t\""], ["proof (prove)\nusing this:\n  invar bq \\<Longrightarrow> invar (remove1 ?t bq)\n  invar (a # bq)\n  rank_invar (a # bq) \\<Longrightarrow>\n  \\<forall>t'\\<in>set bq. rank a < rank t'\n\ngoal (1 subgoal):\n 1. \\<forall>t\\<in>set (remove1 t bq). rank a < rank t", "by (metis notin_set_remove1 invar_def)"], ["proof (state)\nthis:\n  \\<forall>t\\<in>set (remove1 t bq). rank a < rank t\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       remove1 t bq = aa # list \\<Longrightarrow> invar (remove1 t (a # bq))", "with Cons'"], ["proof (chain)\npicking this:\n  remove1 t bq = aa # list\n  \\<forall>t\\<in>set (remove1 t bq). rank a < rank t", "have \"rank a < rank aa\""], ["proof (prove)\nusing this:\n  remove1 t bq = aa # list\n  \\<forall>t\\<in>set (remove1 t bq). rank a < rank t\n\ngoal (1 subgoal):\n 1. rank a < rank aa", "by simp"], ["proof (state)\nthis:\n  rank a < rank aa\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       remove1 t bq = aa # list \\<Longrightarrow> invar (remove1 t (a # bq))", "with si1 Cons(2) False Cons' invar_cons_up[of \"aa\" \"list\" \"a\"]"], ["proof (chain)\npicking this:\n  invar (remove1 t bq)\n  invar (a # bq)\n  t \\<noteq> a\n  remove1 t bq = aa # list\n  \\<lbrakk>invar (aa # list); rank a < rank aa; tree_invar a\\<rbrakk>\n  \\<Longrightarrow> invar (a # aa # list)\n  rank a < rank aa", "show ?thesis"], ["proof (prove)\nusing this:\n  invar (remove1 t bq)\n  invar (a # bq)\n  t \\<noteq> a\n  remove1 t bq = aa # list\n  \\<lbrakk>invar (aa # list); rank a < rank aa; tree_invar a\\<rbrakk>\n  \\<Longrightarrow> invar (a # aa # list)\n  rank a < rank aa\n\ngoal (1 subgoal):\n 1. invar (remove1 t (a # bq))", "by (simp add: invar_def)"], ["proof (state)\nthis:\n  invar (remove1 t (a # bq))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  invar (remove1 t (a # bq))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  invar (remove1 t (a # bq))\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem deleteMin_invar:\n  assumes \"invar bq\"\n    and \"bq \\<noteq> []\"\n  shows \"invar (deleteMin bq)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invar (deleteMin bq)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. invar (deleteMin bq)", "have eq: \"invar (deleteMin bq) = \n    invar (meld (rev (children (getMinTree bq))) (remove1 (getMinTree bq) bq))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invar (deleteMin bq) =\n    invar\n     (meld (rev (children (getMinTree bq))) (remove1 (getMinTree bq) bq))", "by (simp add: deleteMin_def Let_def)"], ["proof (state)\nthis:\n  invar (deleteMin bq) =\n  invar (meld (rev (children (getMinTree bq))) (remove1 (getMinTree bq) bq))\n\ngoal (1 subgoal):\n 1. invar (deleteMin bq)", "from assms mintree_exists[of \"bq\"]"], ["proof (chain)\npicking this:\n  invar bq\n  bq \\<noteq> []\n  (bq \\<noteq> []) = (getMinTree bq \\<in> set bq)", "have ti: \"tree_invar (getMinTree bq)\""], ["proof (prove)\nusing this:\n  invar bq\n  bq \\<noteq> []\n  (bq \\<noteq> []) = (getMinTree bq \\<in> set bq)\n\ngoal (1 subgoal):\n 1. tree_invar (getMinTree bq)", "by (simp add: invar_def Let_def queue_invar_def)"], ["proof (state)\nthis:\n  tree_invar (getMinTree bq)\n\ngoal (1 subgoal):\n 1. invar (deleteMin bq)", "with strong_rev_children[of \"getMinTree bq\"]"], ["proof (chain)\npicking this:\n  tree_invar (getMinTree bq) \\<Longrightarrow>\n  invar (rev (children (getMinTree bq)))\n  tree_invar (getMinTree bq)", "have m1: \"invar (rev (children (getMinTree bq)))\""], ["proof (prove)\nusing this:\n  tree_invar (getMinTree bq) \\<Longrightarrow>\n  invar (rev (children (getMinTree bq)))\n  tree_invar (getMinTree bq)\n\ngoal (1 subgoal):\n 1. invar (rev (children (getMinTree bq)))", "."], ["proof (state)\nthis:\n  invar (rev (children (getMinTree bq)))\n\ngoal (1 subgoal):\n 1. invar (deleteMin bq)", "from strong_remove1[of \"bq\" \"getMinTree bq\"] assms(1)"], ["proof (chain)\npicking this:\n  invar bq \\<Longrightarrow> invar (remove1 (getMinTree bq) bq)\n  invar bq", "have m2: \"invar (remove1 (getMinTree bq) bq)\""], ["proof (prove)\nusing this:\n  invar bq \\<Longrightarrow> invar (remove1 (getMinTree bq) bq)\n  invar bq\n\ngoal (1 subgoal):\n 1. invar (remove1 (getMinTree bq) bq)", "."], ["proof (state)\nthis:\n  invar (remove1 (getMinTree bq) bq)\n\ngoal (1 subgoal):\n 1. invar (deleteMin bq)", "from meld_correct(1)[of \"rev (children (getMinTree bq))\" \n    \"remove1 (getMinTree bq) bq\"] m1 m2"], ["proof (chain)\npicking this:\n  \\<lbrakk>invar (rev (children (getMinTree bq)));\n   invar (remove1 (getMinTree bq) bq)\\<rbrakk>\n  \\<Longrightarrow> invar\n                     (meld (rev (children (getMinTree bq)))\n                       (remove1 (getMinTree bq) bq))\n  invar (rev (children (getMinTree bq)))\n  invar (remove1 (getMinTree bq) bq)", "have \"invar (meld (rev (children (getMinTree bq))) (remove1 (getMinTree bq) bq))\""], ["proof (prove)\nusing this:\n  \\<lbrakk>invar (rev (children (getMinTree bq)));\n   invar (remove1 (getMinTree bq) bq)\\<rbrakk>\n  \\<Longrightarrow> invar\n                     (meld (rev (children (getMinTree bq)))\n                       (remove1 (getMinTree bq) bq))\n  invar (rev (children (getMinTree bq)))\n  invar (remove1 (getMinTree bq) bq)\n\ngoal (1 subgoal):\n 1. invar\n     (meld (rev (children (getMinTree bq))) (remove1 (getMinTree bq) bq))", "."], ["proof (state)\nthis:\n  invar (meld (rev (children (getMinTree bq))) (remove1 (getMinTree bq) bq))\n\ngoal (1 subgoal):\n 1. invar (deleteMin bq)", "with eq"], ["proof (chain)\npicking this:\n  invar (deleteMin bq) =\n  invar (meld (rev (children (getMinTree bq))) (remove1 (getMinTree bq) bq))\n  invar (meld (rev (children (getMinTree bq))) (remove1 (getMinTree bq) bq))", "show ?thesis"], ["proof (prove)\nusing this:\n  invar (deleteMin bq) =\n  invar (meld (rev (children (getMinTree bq))) (remove1 (getMinTree bq) bq))\n  invar (meld (rev (children (getMinTree bq))) (remove1 (getMinTree bq) bq))\n\ngoal (1 subgoal):\n 1. invar (deleteMin bq)", ".."], ["proof (state)\nthis:\n  invar (deleteMin bq)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma children_mset: \"queue_to_multiset (children t) = \n  tree_to_multiset t - {# (val t, prio t) #}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. queue_to_multiset (children t) =\n    tree_to_multiset t - {#(val t, prio t)#}", "proof (cases t)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x3 x4.\n       t = Node x1 x2 x3 x4 \\<Longrightarrow>\n       queue_to_multiset (children t) =\n       tree_to_multiset t - {#(val t, prio t)#}", "case (Node e a nat list)"], ["proof (state)\nthis:\n  t = Node e a nat list\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x3 x4.\n       t = Node x1 x2 x3 x4 \\<Longrightarrow>\n       queue_to_multiset (children t) =\n       tree_to_multiset t - {#(val t, prio t)#}", "thus ?thesis"], ["proof (prove)\nusing this:\n  t = Node e a nat list\n\ngoal (1 subgoal):\n 1. queue_to_multiset (children t) =\n    tree_to_multiset t - {#(val t, prio t)#}", "by (induct list) simp_all"], ["proof (state)\nthis:\n  queue_to_multiset (children t) = tree_to_multiset t - {#(val t, prio t)#}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma deleteMin_mset:\n  assumes \"queue_invar q\"\n    and \"q \\<noteq> Nil\"\n  shows \"queue_to_multiset (deleteMin q) = queue_to_multiset q - {# (findMin q) #}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. queue_to_multiset (deleteMin q) = queue_to_multiset q - {#findMin q#}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. queue_to_multiset (deleteMin q) = queue_to_multiset q - {#findMin q#}", "from assms mintree_exists[of \"q\"]"], ["proof (chain)\npicking this:\n  queue_invar q\n  q \\<noteq> []\n  (q \\<noteq> []) = (getMinTree q \\<in> set q)", "have min_in_q: \"getMinTree q \\<in> set q\""], ["proof (prove)\nusing this:\n  queue_invar q\n  q \\<noteq> []\n  (q \\<noteq> []) = (getMinTree q \\<in> set q)\n\ngoal (1 subgoal):\n 1. getMinTree q \\<in> set q", "by auto"], ["proof (state)\nthis:\n  getMinTree q \\<in> set q\n\ngoal (1 subgoal):\n 1. queue_to_multiset (deleteMin q) = queue_to_multiset q - {#findMin q#}", "with assms(1)"], ["proof (chain)\npicking this:\n  queue_invar q\n  getMinTree q \\<in> set q", "have inv_min: \"tree_invar (getMinTree q)\""], ["proof (prove)\nusing this:\n  queue_invar q\n  getMinTree q \\<in> set q\n\ngoal (1 subgoal):\n 1. tree_invar (getMinTree q)", "by (simp add: queue_invar_def)"], ["proof (state)\nthis:\n  tree_invar (getMinTree q)\n\ngoal (1 subgoal):\n 1. queue_to_multiset (deleteMin q) = queue_to_multiset q - {#findMin q#}", "from assms(2)"], ["proof (chain)\npicking this:\n  q \\<noteq> []", "have q_ne: \"q \\<noteq> []\""], ["proof (prove)\nusing this:\n  q \\<noteq> []\n\ngoal (1 subgoal):\n 1. q \\<noteq> []", "."], ["proof (state)\nthis:\n  q \\<noteq> []\n\ngoal (1 subgoal):\n 1. queue_to_multiset (deleteMin q) = queue_to_multiset q - {#findMin q#}", "note inv_children = invar_children'[OF inv_min]"], ["proof (state)\nthis:\n  queue_invar (children (getMinTree q))\n\ngoal (1 subgoal):\n 1. queue_to_multiset (deleteMin q) = queue_to_multiset q - {#findMin q#}", "note inv_rev = queue_invar_rev[OF inv_children]"], ["proof (state)\nthis:\n  queue_invar (rev (children (getMinTree q)))\n\ngoal (1 subgoal):\n 1. queue_to_multiset (deleteMin q) = queue_to_multiset q - {#findMin q#}", "note inv_rem = queue_invar_remove1[OF assms(1), of \"getMinTree q\"]"], ["proof (state)\nthis:\n  queue_invar (remove1 (getMinTree q) q)\n\ngoal (1 subgoal):\n 1. queue_to_multiset (deleteMin q) = queue_to_multiset q - {#findMin q#}", "note m_meld = meld_mset[OF inv_rev inv_rem]"], ["proof (state)\nthis:\n  queue_to_multiset\n   (meld (rev (children (getMinTree q))) (remove1 (getMinTree q) q)) =\n  queue_to_multiset (rev (children (getMinTree q))) +\n  queue_to_multiset (remove1 (getMinTree q) q)\n\ngoal (1 subgoal):\n 1. queue_to_multiset (deleteMin q) = queue_to_multiset q - {#findMin q#}", "note m_rem = remove1_mset[OF min_in_q]"], ["proof (state)\nthis:\n  queue_to_multiset (remove1 (getMinTree q) q) =\n  queue_to_multiset q - tree_to_multiset (getMinTree q)\n\ngoal (1 subgoal):\n 1. queue_to_multiset (deleteMin q) = queue_to_multiset q - {#findMin q#}", "note m_rev = qtmset_rev[of \"children (getMinTree q)\"]"], ["proof (state)\nthis:\n  queue_to_multiset (rev (children (getMinTree q))) =\n  queue_to_multiset (children (getMinTree q))\n\ngoal (1 subgoal):\n 1. queue_to_multiset (deleteMin q) = queue_to_multiset q - {#findMin q#}", "note m_children = children_mset[of \"getMinTree q\"]"], ["proof (state)\nthis:\n  queue_to_multiset (children (getMinTree q)) =\n  tree_to_multiset (getMinTree q) -\n  {#(val (getMinTree q), prio (getMinTree q))#}\n\ngoal (1 subgoal):\n 1. queue_to_multiset (deleteMin q) = queue_to_multiset q - {#findMin q#}", "note min_subset_q = qtm_in_set_subset[OF min_in_q]"], ["proof (state)\nthis:\n  tree_to_multiset (getMinTree q) \\<subseteq># queue_to_multiset q\n\ngoal (1 subgoal):\n 1. queue_to_multiset (deleteMin q) = queue_to_multiset q - {#findMin q#}", "let ?Q = \"queue_to_multiset q\""], ["proof (state)\ngoal (1 subgoal):\n 1. queue_to_multiset (deleteMin q) = queue_to_multiset q - {#findMin q#}", "let ?MT = \"tree_to_multiset (getMinTree q)\""], ["proof (state)\ngoal (1 subgoal):\n 1. queue_to_multiset (deleteMin q) = queue_to_multiset q - {#findMin q#}", "from q_ne"], ["proof (chain)\npicking this:\n  q \\<noteq> []", "have head_subset_min: \n    \"{# (val (getMinTree q), prio (getMinTree q)) #} \\<subseteq># ?MT\""], ["proof (prove)\nusing this:\n  q \\<noteq> []\n\ngoal (1 subgoal):\n 1. {#(val (getMinTree q), prio (getMinTree q))#} \\<subseteq>#\n    tree_to_multiset (getMinTree q)", "by(cases \"getMinTree q\") simp"], ["proof (state)\nthis:\n  {#(val (getMinTree q), prio (getMinTree q))#} \\<subseteq>#\n  tree_to_multiset (getMinTree q)\n\ngoal (1 subgoal):\n 1. queue_to_multiset (deleteMin q) = queue_to_multiset q - {#findMin q#}", "let ?Q = \"queue_to_multiset q\""], ["proof (state)\ngoal (1 subgoal):\n 1. queue_to_multiset (deleteMin q) = queue_to_multiset q - {#findMin q#}", "let ?MT = \"tree_to_multiset (getMinTree q)\""], ["proof (state)\ngoal (1 subgoal):\n 1. queue_to_multiset (deleteMin q) = queue_to_multiset q - {#findMin q#}", "from m_meld m_rem m_rev m_children \n    multiset_diff_union_assoc[OF head_subset_min, of \"?Q - ?MT\"]\n    mset_subset_eq_multiset_union_diff_commute[OF min_subset_q, of \"?MT\"]"], ["proof (chain)\npicking this:\n  queue_to_multiset\n   (meld (rev (children (getMinTree q))) (remove1 (getMinTree q) q)) =\n  queue_to_multiset (rev (children (getMinTree q))) +\n  queue_to_multiset (remove1 (getMinTree q) q)\n  queue_to_multiset (remove1 (getMinTree q) q) =\n  queue_to_multiset q - tree_to_multiset (getMinTree q)\n  queue_to_multiset (rev (children (getMinTree q))) =\n  queue_to_multiset (children (getMinTree q))\n  queue_to_multiset (children (getMinTree q)) =\n  tree_to_multiset (getMinTree q) -\n  {#(val (getMinTree q), prio (getMinTree q))#}\n  queue_to_multiset q - tree_to_multiset (getMinTree q) +\n  tree_to_multiset (getMinTree q) -\n  {#(val (getMinTree q), prio (getMinTree q))#} =\n  queue_to_multiset q - tree_to_multiset (getMinTree q) +\n  (tree_to_multiset (getMinTree q) -\n   {#(val (getMinTree q), prio (getMinTree q))#})\n  queue_to_multiset q - tree_to_multiset (getMinTree q) +\n  tree_to_multiset (getMinTree q) =\n  queue_to_multiset q + tree_to_multiset (getMinTree q) -\n  tree_to_multiset (getMinTree q)", "show ?thesis"], ["proof (prove)\nusing this:\n  queue_to_multiset\n   (meld (rev (children (getMinTree q))) (remove1 (getMinTree q) q)) =\n  queue_to_multiset (rev (children (getMinTree q))) +\n  queue_to_multiset (remove1 (getMinTree q) q)\n  queue_to_multiset (remove1 (getMinTree q) q) =\n  queue_to_multiset q - tree_to_multiset (getMinTree q)\n  queue_to_multiset (rev (children (getMinTree q))) =\n  queue_to_multiset (children (getMinTree q))\n  queue_to_multiset (children (getMinTree q)) =\n  tree_to_multiset (getMinTree q) -\n  {#(val (getMinTree q), prio (getMinTree q))#}\n  queue_to_multiset q - tree_to_multiset (getMinTree q) +\n  tree_to_multiset (getMinTree q) -\n  {#(val (getMinTree q), prio (getMinTree q))#} =\n  queue_to_multiset q - tree_to_multiset (getMinTree q) +\n  (tree_to_multiset (getMinTree q) -\n   {#(val (getMinTree q), prio (getMinTree q))#})\n  queue_to_multiset q - tree_to_multiset (getMinTree q) +\n  tree_to_multiset (getMinTree q) =\n  queue_to_multiset q + tree_to_multiset (getMinTree q) -\n  tree_to_multiset (getMinTree q)\n\ngoal (1 subgoal):\n 1. queue_to_multiset (deleteMin q) = queue_to_multiset q - {#findMin q#}", "by (simp add: deleteMin_def union_ac Let_def findMin_def)"], ["proof (state)\nthis:\n  queue_to_multiset (deleteMin q) = queue_to_multiset q - {#findMin q#}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma deleteMin_correct:\n  assumes INV: \"invar q\" \n  assumes NE: \"q \\<noteq> Nil\"\n  shows \n  \"invar (deleteMin q)\"\n  \"queue_to_multiset (deleteMin q) = queue_to_multiset q - {# (findMin q) #}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invar (deleteMin q) &&&\n    queue_to_multiset (deleteMin q) = queue_to_multiset q - {#findMin q#}", "using deleteMin_invar deleteMin_mset INV NE"], ["proof (prove)\nusing this:\n  \\<lbrakk>invar ?bq; ?bq \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> invar (deleteMin ?bq)\n  \\<lbrakk>queue_invar ?q; ?q \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> queue_to_multiset (deleteMin ?q) =\n                    queue_to_multiset ?q - {#findMin ?q#}\n  invar q\n  q \\<noteq> []\n\ngoal (1 subgoal):\n 1. invar (deleteMin q) &&&\n    queue_to_multiset (deleteMin q) = queue_to_multiset q - {#findMin q#}", "unfolding invar_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>queue_invar ?bq \\<and> rank_invar ?bq; ?bq \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> queue_invar (deleteMin ?bq) \\<and>\n                    rank_invar (deleteMin ?bq)\n  \\<lbrakk>queue_invar ?q; ?q \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> queue_to_multiset (deleteMin ?q) =\n                    queue_to_multiset ?q - {#findMin ?q#}\n  queue_invar q \\<and> rank_invar q\n  q \\<noteq> []\n\ngoal (1 subgoal):\n 1. queue_invar (deleteMin q) \\<and> rank_invar (deleteMin q) &&&\n    queue_to_multiset (deleteMin q) = queue_to_multiset q - {#findMin q#}", "by auto"], ["", "end"], ["", "interpretation BinomialHeapStruc: BinomialHeapStruc_loc"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "subsection \"Hiding the Invariant\""], ["", "subsubsection \"Datatype\""], ["", "typedef (overloaded) ('e, 'a) BinomialHeap =\n  \"{q :: ('e,'a::linorder) BinomialHeapStruc.BinomialQueue_inv. BinomialHeapStruc.invar q }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> {q. BinomialHeapStruc.invar q}", "apply (rule_tac x=\"Nil\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. [] \\<in> {q. BinomialHeapStruc.invar q}", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma Rep_BinomialHeap_invar[simp]: \n  \"BinomialHeapStruc.invar (Rep_BinomialHeap x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. BinomialHeapStruc.invar (Rep_BinomialHeap x)", "using Rep_BinomialHeap"], ["proof (prove)\nusing this:\n  Rep_BinomialHeap ?x \\<in> {q. BinomialHeapStruc.invar q}\n\ngoal (1 subgoal):\n 1. BinomialHeapStruc.invar (Rep_BinomialHeap x)", "by (auto)"], ["", "lemma [simp]: \n  \"BinomialHeapStruc.invar q \\<Longrightarrow> Rep_BinomialHeap (Abs_BinomialHeap q) = q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. BinomialHeapStruc.invar q \\<Longrightarrow>\n    Rep_BinomialHeap (Abs_BinomialHeap q) = q", "using Abs_BinomialHeap_inverse"], ["proof (prove)\nusing this:\n  ?y \\<in> {q. BinomialHeapStruc.invar q} \\<Longrightarrow>\n  Rep_BinomialHeap (Abs_BinomialHeap ?y) = ?y\n\ngoal (1 subgoal):\n 1. BinomialHeapStruc.invar q \\<Longrightarrow>\n    Rep_BinomialHeap (Abs_BinomialHeap q) = q", "by auto"], ["", "lemma [simp, code abstype]: \"Abs_BinomialHeap (Rep_BinomialHeap q) = q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_BinomialHeap (Rep_BinomialHeap q) = q", "by (rule Rep_BinomialHeap_inverse)"], ["", "locale BinomialHeap_loc\nbegin"], ["", "subsubsection \"Operations\""], ["", "definition [code]: \n    \"to_mset t == BinomialHeapStruc.queue_to_multiset (Rep_BinomialHeap t)\""], ["", "definition empty where \"empty == Abs_BinomialHeap Nil\""], ["", "lemma [code abstract, simp]: \"Rep_BinomialHeap empty = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_BinomialHeap local.empty = []", "by (unfold empty_def) simp"], ["", "definition [code]: \"isEmpty q == Rep_BinomialHeap q = Nil\""], ["", "lemma empty_rep: \"q=empty \\<longleftrightarrow> Rep_BinomialHeap q = Nil\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (q = local.empty) = (Rep_BinomialHeap q = [])", "apply (auto simp add: empty_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_BinomialHeap q = [] \\<Longrightarrow> q = Abs_BinomialHeap []", "apply (metis Rep_BinomialHeap_inverse)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma isEmpty_correct: \"isEmpty q \\<longleftrightarrow> q=empty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isEmpty q = (q = local.empty)", "by (simp add: empty_rep isEmpty_def)"], ["", "definition \n    insert \n    :: \"'e  \\<Rightarrow> ('a::linorder) \\<Rightarrow> ('e,'a) BinomialHeap \\<Rightarrow> ('e,'a) BinomialHeap\"\n    where \"insert e a q == \n            Abs_BinomialHeap (BinomialHeapStruc.insert e a (Rep_BinomialHeap q))\""], ["", "lemma [code abstract]: \n    \"Rep_BinomialHeap (insert e a q) \n    = BinomialHeapStruc.insert e a (Rep_BinomialHeap q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_BinomialHeap (local.insert e a q) =\n    BinomialHeapStruc.insert e a (Rep_BinomialHeap q)", "by (simp add: insert_def BinomialHeapStruc.insert_correct)"], ["", "definition [code]: \"findMin q == BinomialHeapStruc.findMin (Rep_BinomialHeap q)\""], ["", "definition \"deleteMin q == \n    if q=empty then empty \n    else Abs_BinomialHeap (BinomialHeapStruc.deleteMin (Rep_BinomialHeap q))\""], ["", "text \\<open>\n    In this lemma, we do not use equality, but case-distinction for checking \n    non-emptyness. That prevents the code generator from introducing\n    an equality-class parameter for the entry type \\<open>'a\\<close>.\n\\<close>"], ["", "lemma [code abstract]: \"Rep_BinomialHeap (deleteMin q) =\n    (case (Rep_BinomialHeap q) of [] \\<Rightarrow> [] |\n     _ \\<Rightarrow> BinomialHeapStruc.deleteMin (Rep_BinomialHeap q))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_BinomialHeap (deleteMin q) =\n    (case Rep_BinomialHeap q of [] \\<Rightarrow> []\n     | a # list \\<Rightarrow>\n         BinomialHeapStruc.deleteMin (Rep_BinomialHeap q))", "proof (cases \"Rep_BinomialHeap q\")"], ["proof (state)\ngoal (2 subgoals):\n 1. Rep_BinomialHeap q = [] \\<Longrightarrow>\n    Rep_BinomialHeap (deleteMin q) =\n    (case Rep_BinomialHeap q of [] \\<Rightarrow> []\n     | a # list \\<Rightarrow>\n         BinomialHeapStruc.deleteMin (Rep_BinomialHeap q))\n 2. \\<And>a list.\n       Rep_BinomialHeap q = a # list \\<Longrightarrow>\n       Rep_BinomialHeap (deleteMin q) =\n       (case Rep_BinomialHeap q of [] \\<Rightarrow> []\n        | a # list \\<Rightarrow>\n            BinomialHeapStruc.deleteMin (Rep_BinomialHeap q))", "case Nil"], ["proof (state)\nthis:\n  Rep_BinomialHeap q = []\n\ngoal (2 subgoals):\n 1. Rep_BinomialHeap q = [] \\<Longrightarrow>\n    Rep_BinomialHeap (deleteMin q) =\n    (case Rep_BinomialHeap q of [] \\<Rightarrow> []\n     | a # list \\<Rightarrow>\n         BinomialHeapStruc.deleteMin (Rep_BinomialHeap q))\n 2. \\<And>a list.\n       Rep_BinomialHeap q = a # list \\<Longrightarrow>\n       Rep_BinomialHeap (deleteMin q) =\n       (case Rep_BinomialHeap q of [] \\<Rightarrow> []\n        | a # list \\<Rightarrow>\n            BinomialHeapStruc.deleteMin (Rep_BinomialHeap q))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_BinomialHeap (deleteMin q) =\n    (case Rep_BinomialHeap q of [] \\<Rightarrow> []\n     | a # list \\<Rightarrow>\n         BinomialHeapStruc.deleteMin (Rep_BinomialHeap q))", "apply (simp add: Nil)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_BinomialHeap (deleteMin q) = []", "apply (auto simp add: deleteMin_def BinomialHeapStruc.deleteMin_correct \n      BinomialHeapStruc.empty_iff empty_rep Nil)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  Rep_BinomialHeap (deleteMin q) =\n  (case Rep_BinomialHeap q of [] \\<Rightarrow> []\n   | a # list \\<Rightarrow>\n       BinomialHeapStruc.deleteMin (Rep_BinomialHeap q))\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       Rep_BinomialHeap q = a # list \\<Longrightarrow>\n       Rep_BinomialHeap (deleteMin q) =\n       (case Rep_BinomialHeap q of [] \\<Rightarrow> []\n        | a # list \\<Rightarrow>\n            BinomialHeapStruc.deleteMin (Rep_BinomialHeap q))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       Rep_BinomialHeap q = a # list \\<Longrightarrow>\n       Rep_BinomialHeap (deleteMin q) =\n       (case Rep_BinomialHeap q of [] \\<Rightarrow> []\n        | a # list \\<Rightarrow>\n            BinomialHeapStruc.deleteMin (Rep_BinomialHeap q))", "case (Cons a b)"], ["proof (state)\nthis:\n  Rep_BinomialHeap q = a # b\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       Rep_BinomialHeap q = a # list \\<Longrightarrow>\n       Rep_BinomialHeap (deleteMin q) =\n       (case Rep_BinomialHeap q of [] \\<Rightarrow> []\n        | a # list \\<Rightarrow>\n            BinomialHeapStruc.deleteMin (Rep_BinomialHeap q))", "hence NE: \"Rep_BinomialHeap q \\<noteq> []\""], ["proof (prove)\nusing this:\n  Rep_BinomialHeap q = a # b\n\ngoal (1 subgoal):\n 1. Rep_BinomialHeap q \\<noteq> []", "by auto"], ["proof (state)\nthis:\n  Rep_BinomialHeap q \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       Rep_BinomialHeap q = a # list \\<Longrightarrow>\n       Rep_BinomialHeap (deleteMin q) =\n       (case Rep_BinomialHeap q of [] \\<Rightarrow> []\n        | a # list \\<Rightarrow>\n            BinomialHeapStruc.deleteMin (Rep_BinomialHeap q))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_BinomialHeap (deleteMin q) =\n    (case Rep_BinomialHeap q of [] \\<Rightarrow> []\n     | a # list \\<Rightarrow>\n         BinomialHeapStruc.deleteMin (Rep_BinomialHeap q))", "apply (simp add: Cons)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_BinomialHeap (deleteMin q) = BinomialHeapStruc.deleteMin (a # b)", "apply (fold Cons)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_BinomialHeap (deleteMin q) =\n    BinomialHeapStruc.deleteMin (Rep_BinomialHeap q)", "using NE"], ["proof (prove)\nusing this:\n  Rep_BinomialHeap q \\<noteq> []\n\ngoal (1 subgoal):\n 1. Rep_BinomialHeap (deleteMin q) =\n    BinomialHeapStruc.deleteMin (Rep_BinomialHeap q)", "by (auto simp add: deleteMin_def BinomialHeapStruc.deleteMin_correct \n        BinomialHeapStruc.empty_iff empty_rep)"], ["proof (state)\nthis:\n  Rep_BinomialHeap (deleteMin q) =\n  (case Rep_BinomialHeap q of [] \\<Rightarrow> []\n   | a # list \\<Rightarrow>\n       BinomialHeapStruc.deleteMin (Rep_BinomialHeap q))\n\ngoal:\nNo subgoals!", "qed"], ["", "(*\n  lemma [code abstract]: \"Rep_BinomialHeap (deleteMin q) =\n    (if (Rep_BinomialHeap q = []) then [] \n     else BinomialHeapStruc.deleteMin (Rep_BinomialHeap q))\"\n    by (auto simp add: deleteMin_def BinomialHeapStruc.deleteMin_correct \n      BinomialHeapStruc.empty_iff empty_rep)\n      *)"], ["", "definition \"meld q1 q2 == \n    Abs_BinomialHeap (BinomialHeapStruc.meld (Rep_BinomialHeap q1) \n                                             (Rep_BinomialHeap q2))\""], ["", "lemma [code abstract]:\n    \"Rep_BinomialHeap (meld q1 q2) \n    = BinomialHeapStruc.meld (Rep_BinomialHeap q1) (Rep_BinomialHeap q2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_BinomialHeap (meld q1 q2) =\n    BinomialHeapStruc.meld (Rep_BinomialHeap q1) (Rep_BinomialHeap q2)", "by (simp add: meld_def BinomialHeapStruc.meld_correct)"], ["", "subsubsection \"Correctness\""], ["", "lemma empty_correct: \"to_mset q = {#} \\<longleftrightarrow> q=empty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (to_mset q = {#}) = (q = local.empty)", "by (simp add: to_mset_def BinomialHeapStruc.empty_iff empty_rep)"], ["", "lemma to_mset_of_empty[simp]: \"to_mset empty = {#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. to_mset local.empty = {#}", "by (simp add: empty_correct)"], ["", "lemma insert_correct: \"to_mset (insert e a q) = to_mset q + {#(e,a)#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. to_mset (local.insert e a q) = to_mset q + {#(e, a)#}", "apply (unfold insert_def to_mset_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. BinomialHeapStruc.queue_to_multiset\n     (Rep_BinomialHeap\n       (Abs_BinomialHeap\n         (BinomialHeapStruc.insert e a (Rep_BinomialHeap q)))) =\n    BinomialHeapStruc.queue_to_multiset (Rep_BinomialHeap q) + {#(e, a)#}", "apply (simp add: BinomialHeapStruc.insert_correct)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma findMin_correct: \n    assumes \"q\\<noteq>empty\"\n    shows \n    \"findMin q \\<in># to_mset q\"\n    \"\\<forall>y\\<in>set_mset (to_mset q). snd (findMin q) \\<le> snd y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. findMin q \\<in># to_mset q &&&\n    \\<forall>y\\<in>#to_mset q. snd (findMin q) \\<le> snd y", "using assms"], ["proof (prove)\nusing this:\n  q \\<noteq> local.empty\n\ngoal (1 subgoal):\n 1. findMin q \\<in># to_mset q &&&\n    \\<forall>y\\<in>#to_mset q. snd (findMin q) \\<le> snd y", "apply (unfold findMin_def to_mset_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. q \\<noteq> local.empty \\<Longrightarrow>\n    BinomialHeapStruc.findMin (Rep_BinomialHeap q)\n    \\<in># BinomialHeapStruc.queue_to_multiset (Rep_BinomialHeap q)\n 2. q \\<noteq> local.empty \\<Longrightarrow>\n    \\<forall>y\\<in>#BinomialHeapStruc.queue_to_multiset\n                     (Rep_BinomialHeap q).\n       snd (BinomialHeapStruc.findMin (Rep_BinomialHeap q)) \\<le> snd y", "apply (simp_all add: empty_rep BinomialHeapStruc.findMin_correct)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma deleteMin_correct:\n    assumes \"q\\<noteq>empty\"\n    shows \"to_mset (deleteMin q) = to_mset q - {# findMin q #}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. to_mset (deleteMin q) = to_mset q - {#findMin q#}", "using assms"], ["proof (prove)\nusing this:\n  q \\<noteq> local.empty\n\ngoal (1 subgoal):\n 1. to_mset (deleteMin q) = to_mset q - {#findMin q#}", "apply (unfold findMin_def deleteMin_def to_mset_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. q \\<noteq> local.empty \\<Longrightarrow>\n    BinomialHeapStruc.queue_to_multiset\n     (Rep_BinomialHeap\n       (if q = local.empty then local.empty\n        else Abs_BinomialHeap\n              (BinomialHeapStruc.deleteMin (Rep_BinomialHeap q)))) =\n    BinomialHeapStruc.queue_to_multiset (Rep_BinomialHeap q) -\n    {#BinomialHeapStruc.findMin (Rep_BinomialHeap q)#}", "apply (simp_all add: empty_rep BinomialHeapStruc.deleteMin_correct)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma meld_correct:\n    shows \"to_mset (meld q q') = to_mset q + to_mset q'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. to_mset (meld q q') = to_mset q + to_mset q'", "apply (unfold to_mset_def meld_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. BinomialHeapStruc.queue_to_multiset\n     (Rep_BinomialHeap\n       (Abs_BinomialHeap\n         (BinomialHeapStruc.meld (Rep_BinomialHeap q)\n           (Rep_BinomialHeap q')))) =\n    BinomialHeapStruc.queue_to_multiset (Rep_BinomialHeap q) +\n    BinomialHeapStruc.queue_to_multiset (Rep_BinomialHeap q')", "apply (simp_all add: BinomialHeapStruc.meld_correct)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>Correctness lemmas to be used with simplifier\\<close>"], ["", "lemmas correct = empty_correct deleteMin_correct meld_correct"], ["", "end"], ["", "interpretation BinomialHeap: BinomialHeap_loc"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "subsection \"Documentation\""], ["", "(*#DOC\n  fun [no_spec] BinomialHeap.to_mset\n    Abstraction to multiset.\n\n  fun BinomialHeap.empty\n    The empty heap. ($O(1)$)\n\n  fun BinomialHeap.isEmpty\n    Checks whether heap is empty. Mainly used to work around \n    code-generation issues. ($O(1)$)\n\n  fun BinomialHeap.insert\n    Inserts element ($O(\\log(n))$)\n\n  fun BinomialHeap.findMin\n    Returns a minimal element ($O(\\log(n))$)\n\n  fun BinomialHeap.deleteMin\n    Deletes {\\em the} element that is returned by {\\em find\\_min}\n\n  fun [long_type] BinomialHeap.meld\n    Melds two heaps ($O(\\log(n+m))$)\n\n*)"], ["", "text \\<open>\n    \\underline{@{term_type \"BinomialHeap.to_mset\"}}\\\\\n        Abstraction to multiset.\\\\\n\n\n    \\underline{@{term_type \"BinomialHeap.empty\"}}\\\\\n        The empty heap. ($O(1)$)\\\\\n    {\\bf Spec} \\<open>BinomialHeap.empty_correct\\<close>:\n    @{thm [display] BinomialHeap.empty_correct[no_vars]}\n\n\n    \\underline{@{term_type \"BinomialHeap.isEmpty\"}}\\\\\n        Checks whether heap is empty. Mainly used to work around\n    code-generation issues. ($O(1)$)\\\\\n    {\\bf Spec} \\<open>BinomialHeap.isEmpty_correct\\<close>:\n    @{thm [display] BinomialHeap.isEmpty_correct[no_vars]}\n\n\n    \\underline{@{term_type \"BinomialHeap.insert\"}}\\\\\n        Inserts element ($O(\\log(n))$)\\\\\n    {\\bf Spec} \\<open>BinomialHeap.insert_correct\\<close>:\n    @{thm [display] BinomialHeap.insert_correct[no_vars]}\n\n\n    \\underline{@{term_type \"BinomialHeap.findMin\"}}\\\\\n        Returns a minimal element ($O(\\log(n))$)\\\\\n    {\\bf Spec} \\<open>BinomialHeap.findMin_correct\\<close>:\n    @{thm [display] BinomialHeap.findMin_correct[no_vars]}\n\n\n    \\underline{@{term_type \"BinomialHeap.deleteMin\"}}\\\\\n        Deletes {\\em the} element that is returned by {\\em find\\_min}\\\\\n    {\\bf Spec} \\<open>BinomialHeap.deleteMin_correct\\<close>:\n    @{thm [display] BinomialHeap.deleteMin_correct[no_vars]}\n\n\n    \\underline{@{term \"BinomialHeap.meld\"}}\n    @{term_type [display] \"BinomialHeap.meld\"}\n        Melds two heaps ($O(\\log(n+m))$)\\\\\n    {\\bf Spec} \\<open>BinomialHeap.meld_correct\\<close>:\n    @{thm [display] BinomialHeap.meld_correct[no_vars]}\n\n\\<close>"], ["", "end"]]}