{"file_name": "/home/qj213/afp-2021-10-22/thys/Polynomial_Factorization/Explicit_Roots.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Polynomial_Factorization", "problem_names": ["lemma roots0: assumes p: \"p \\<noteq> 0\" and p0: \"degree p = 0\" \n  shows \"{x. poly p x = 0} = {}\"", "lemma roots1: fixes p :: \"'a :: field poly\"\n  assumes p1: \"degree p = 1\" \n  shows \"{x. poly p x = 0} = {roots1 p}\"", "lemma roots2: fixes p :: \"'a :: field_char_0 poly\"\n  assumes p2: \"p = [: c, b, a :]\" and a: \"a \\<noteq> 0\"\n  shows \"{x. poly p x = 0} = { - ( b / (2 * a)) + e | e. e^2 = ( b / (2 * a))^2 - c/a}\" (is \"?l = ?r\")", "lemma croots2: assumes \"degree p = 2\"\n  shows \"{x. poly p x = 0} = set (croots2 p)\"", "lemma rroots2: assumes \"degree p = 2\"\n  shows \"{x. poly p x = 0} = set (rroots2 p)\"", "lemma rat_roots2: assumes \"degree p = 2\"\n  shows \"{x. poly p x = 0} = set (rat_roots2 p)\"", "lemma croots: assumes \"p \\<noteq> 0\" \"degree p \\<le> 2\"\n  shows \"set (croots p) = {x. poly p x = 0}\"", "lemma rroots: assumes \"p \\<noteq> 0\" \"degree p \\<le> 2\"\n  shows \"set (rroots p) = {x. poly p x = 0}\""], "translations": [["", "lemma roots0: assumes p: \"p \\<noteq> 0\" and p0: \"degree p = 0\" \n  shows \"{x. poly p x = 0} = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. poly p x = (0::'a)} = {}", "using degree0_coeffs[OF p0] p"], ["proof (prove)\nusing this:\n  \\<exists>a. p = [:a:]\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. {x. poly p x = (0::'a)} = {}", "by auto"], ["", "definition roots1 :: \"'a :: field poly \\<Rightarrow> 'a\" where\n  \"roots1 p = (- coeff p 0 / coeff p 1)\""], ["", "lemma roots1: fixes p :: \"'a :: field poly\"\n  assumes p1: \"degree p = 1\" \n  shows \"{x. poly p x = 0} = {roots1 p}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. poly p x = (0::'a)} = {roots1 p}", "using degree1_coeffs[OF p1]"], ["proof (prove)\nusing this:\n  \\<exists>a b. p = [:b, a:] \\<and> a \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. {x. poly p x = (0::'a)} = {roots1 p}", "unfolding roots1_def"], ["proof (prove)\nusing this:\n  \\<exists>a b. p = [:b, a:] \\<and> a \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. {x. poly p x = (0::'a)} = {- coeff p 0 / coeff p 1}", "by (auto simp: add_eq_0_iff nonzero_neg_divide_eq_eq2)"], ["", "lemma roots2: fixes p :: \"'a :: field_char_0 poly\"\n  assumes p2: \"p = [: c, b, a :]\" and a: \"a \\<noteq> 0\"\n  shows \"{x. poly p x = 0} = { - ( b / (2 * a)) + e | e. e^2 = ( b / (2 * a))^2 - c/a}\" (is \"?l = ?r\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. poly p x = (0::'a)} =\n    {- (b / ((2::'a) * a)) + e |e.\n     e\\<^sup>2 = (b / ((2::'a) * a))\\<^sup>2 - c / a}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. {x. poly p x = (0::'a)} =\n    {- (b / ((2::'a) * a)) + e |e.\n     e\\<^sup>2 = (b / ((2::'a) * a))\\<^sup>2 - c / a}", "define b2a where \"b2a = b / (2 * a)\""], ["proof (state)\nthis:\n  b2a = b / ((2::'a) * a)\n\ngoal (1 subgoal):\n 1. {x. poly p x = (0::'a)} =\n    {- (b / ((2::'a) * a)) + e |e.\n     e\\<^sup>2 = (b / ((2::'a) * a))\\<^sup>2 - c / a}", "{"], ["proof (state)\nthis:\n  b2a = b / ((2::'a) * a)\n\ngoal (1 subgoal):\n 1. {x. poly p x = (0::'a)} =\n    {- (b / ((2::'a) * a)) + e |e.\n     e\\<^sup>2 = (b / ((2::'a) * a))\\<^sup>2 - c / a}", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. {x. poly p x = (0::'a)} =\n    {- (b / ((2::'a) * a)) + e |e.\n     e\\<^sup>2 = (b / ((2::'a) * a))\\<^sup>2 - c / a}", "have \"(x \\<in> ?l) = (x * x * a + x * b + c = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in> {x. poly p x = (0::'a)}) = (x * x * a + x * b + c = (0::'a))", "unfolding p2"], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in> {x. poly [:c, b, a:] x = (0::'a)}) =\n    (x * x * a + x * b + c = (0::'a))", "by (simp add: field_simps)"], ["proof (state)\nthis:\n  (x \\<in> {x. poly p x = (0::'a)}) = (x * x * a + x * b + c = (0::'a))\n\ngoal (1 subgoal):\n 1. {x. poly p x = (0::'a)} =\n    {- (b / ((2::'a) * a)) + e |e.\n     e\\<^sup>2 = (b / ((2::'a) * a))\\<^sup>2 - c / a}", "also"], ["proof (state)\nthis:\n  (x \\<in> {x. poly p x = (0::'a)}) = (x * x * a + x * b + c = (0::'a))\n\ngoal (1 subgoal):\n 1. {x. poly p x = (0::'a)} =\n    {- (b / ((2::'a) * a)) + e |e.\n     e\\<^sup>2 = (b / ((2::'a) * a))\\<^sup>2 - c / a}", "have \"\\<dots> = ((x * x + 2 * x * b2a) + c/a = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x * x * a + x * b + c = (0::'a)) =\n    (x * x + (2::'a) * x * b2a + c / a = (0::'a))", "using a"], ["proof (prove)\nusing this:\n  a \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. (x * x * a + x * b + c = (0::'a)) =\n    (x * x + (2::'a) * x * b2a + c / a = (0::'a))", "by (auto simp: b2a_def field_simps)"], ["proof (state)\nthis:\n  (x * x * a + x * b + c = (0::'a)) =\n  (x * x + (2::'a) * x * b2a + c / a = (0::'a))\n\ngoal (1 subgoal):\n 1. {x. poly p x = (0::'a)} =\n    {- (b / ((2::'a) * a)) + e |e.\n     e\\<^sup>2 = (b / ((2::'a) * a))\\<^sup>2 - c / a}", "also"], ["proof (state)\nthis:\n  (x * x * a + x * b + c = (0::'a)) =\n  (x * x + (2::'a) * x * b2a + c / a = (0::'a))\n\ngoal (1 subgoal):\n 1. {x. poly p x = (0::'a)} =\n    {- (b / ((2::'a) * a)) + e |e.\n     e\\<^sup>2 = (b / ((2::'a) * a))\\<^sup>2 - c / a}", "have \"x * x + 2 * x * b2a = (x * x + 2 * x * b2a + b2a^2) - b2a^2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * x + (2::'a) * x * b2a =\n    x * x + (2::'a) * x * b2a + b2a\\<^sup>2 - b2a\\<^sup>2", "by simp"], ["proof (state)\nthis:\n  x * x + (2::'a) * x * b2a =\n  x * x + (2::'a) * x * b2a + b2a\\<^sup>2 - b2a\\<^sup>2\n\ngoal (1 subgoal):\n 1. {x. poly p x = (0::'a)} =\n    {- (b / ((2::'a) * a)) + e |e.\n     e\\<^sup>2 = (b / ((2::'a) * a))\\<^sup>2 - c / a}", "also"], ["proof (state)\nthis:\n  x * x + (2::'a) * x * b2a =\n  x * x + (2::'a) * x * b2a + b2a\\<^sup>2 - b2a\\<^sup>2\n\ngoal (1 subgoal):\n 1. {x. poly p x = (0::'a)} =\n    {- (b / ((2::'a) * a)) + e |e.\n     e\\<^sup>2 = (b / ((2::'a) * a))\\<^sup>2 - c / a}", "have \"\\<dots> = (x + b2a) ^ 2 - b2a ^ 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * x + (2::'a) * x * b2a + b2a\\<^sup>2 - b2a\\<^sup>2 =\n    (x + b2a)\\<^sup>2 - b2a\\<^sup>2", "by (simp add: field_simps power2_eq_square)"], ["proof (state)\nthis:\n  x * x + (2::'a) * x * b2a + b2a\\<^sup>2 - b2a\\<^sup>2 =\n  (x + b2a)\\<^sup>2 - b2a\\<^sup>2\n\ngoal (1 subgoal):\n 1. {x. poly p x = (0::'a)} =\n    {- (b / ((2::'a) * a)) + e |e.\n     e\\<^sup>2 = (b / ((2::'a) * a))\\<^sup>2 - c / a}", "also"], ["proof (state)\nthis:\n  x * x + (2::'a) * x * b2a + b2a\\<^sup>2 - b2a\\<^sup>2 =\n  (x + b2a)\\<^sup>2 - b2a\\<^sup>2\n\ngoal (1 subgoal):\n 1. {x. poly p x = (0::'a)} =\n    {- (b / ((2::'a) * a)) + e |e.\n     e\\<^sup>2 = (b / ((2::'a) * a))\\<^sup>2 - c / a}", "have \"(\\<dots> + c / a = 0) = ((x + b2a) ^ 2 = b2a^2 - c/a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((x + b2a)\\<^sup>2 - b2a\\<^sup>2 + c / a = (0::'a)) =\n    ((x + b2a)\\<^sup>2 = b2a\\<^sup>2 - c / a)", "by algebra"], ["proof (state)\nthis:\n  ((x + b2a)\\<^sup>2 - b2a\\<^sup>2 + c / a = (0::'a)) =\n  ((x + b2a)\\<^sup>2 = b2a\\<^sup>2 - c / a)\n\ngoal (1 subgoal):\n 1. {x. poly p x = (0::'a)} =\n    {- (b / ((2::'a) * a)) + e |e.\n     e\\<^sup>2 = (b / ((2::'a) * a))\\<^sup>2 - c / a}", "also"], ["proof (state)\nthis:\n  ((x + b2a)\\<^sup>2 - b2a\\<^sup>2 + c / a = (0::'a)) =\n  ((x + b2a)\\<^sup>2 = b2a\\<^sup>2 - c / a)\n\ngoal (1 subgoal):\n 1. {x. poly p x = (0::'a)} =\n    {- (b / ((2::'a) * a)) + e |e.\n     e\\<^sup>2 = (b / ((2::'a) * a))\\<^sup>2 - c / a}", "have \"\\<dots> = (x \\<in> ?r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((x + b2a)\\<^sup>2 = b2a\\<^sup>2 - c / a) =\n    (x \\<in> {- (b / ((2::'a) * a)) + e |e.\n              e\\<^sup>2 = (b / ((2::'a) * a))\\<^sup>2 - c / a})", "unfolding b2a_def[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((x + b2a)\\<^sup>2 = b2a\\<^sup>2 - c / a) =\n    (x \\<in> {- b2a + e |e. e\\<^sup>2 = b2a\\<^sup>2 - c / a})", "by (auto simp: field_simps)"], ["proof (state)\nthis:\n  ((x + b2a)\\<^sup>2 = b2a\\<^sup>2 - c / a) =\n  (x \\<in> {- (b / ((2::'a) * a)) + e |e.\n            e\\<^sup>2 = (b / ((2::'a) * a))\\<^sup>2 - c / a})\n\ngoal (1 subgoal):\n 1. {x. poly p x = (0::'a)} =\n    {- (b / ((2::'a) * a)) + e |e.\n     e\\<^sup>2 = (b / ((2::'a) * a))\\<^sup>2 - c / a}", "finally"], ["proof (chain)\npicking this:\n  (x \\<in> {x. poly p x = (0::'a)}) =\n  (x \\<in> {- (b / ((2::'a) * a)) + e |e.\n            e\\<^sup>2 = (b / ((2::'a) * a))\\<^sup>2 - c / a})", "have \"(x \\<in> ?l) = (x \\<in> ?r)\""], ["proof (prove)\nusing this:\n  (x \\<in> {x. poly p x = (0::'a)}) =\n  (x \\<in> {- (b / ((2::'a) * a)) + e |e.\n            e\\<^sup>2 = (b / ((2::'a) * a))\\<^sup>2 - c / a})\n\ngoal (1 subgoal):\n 1. (x \\<in> {x. poly p x = (0::'a)}) =\n    (x \\<in> {- (b / ((2::'a) * a)) + e |e.\n              e\\<^sup>2 = (b / ((2::'a) * a))\\<^sup>2 - c / a})", "."], ["proof (state)\nthis:\n  (x \\<in> {x. poly p x = (0::'a)}) =\n  (x \\<in> {- (b / ((2::'a) * a)) + e |e.\n            e\\<^sup>2 = (b / ((2::'a) * a))\\<^sup>2 - c / a})\n\ngoal (1 subgoal):\n 1. {x. poly p x = (0::'a)} =\n    {- (b / ((2::'a) * a)) + e |e.\n     e\\<^sup>2 = (b / ((2::'a) * a))\\<^sup>2 - c / a}", "}"], ["proof (state)\nthis:\n  (?x2 \\<in> {x. poly p x = (0::'a)}) =\n  (?x2\n   \\<in> {- (b / ((2::'a) * a)) + e |e.\n          e\\<^sup>2 = (b / ((2::'a) * a))\\<^sup>2 - c / a})\n\ngoal (1 subgoal):\n 1. {x. poly p x = (0::'a)} =\n    {- (b / ((2::'a) * a)) + e |e.\n     e\\<^sup>2 = (b / ((2::'a) * a))\\<^sup>2 - c / a}", "thus ?thesis"], ["proof (prove)\nusing this:\n  (?x2 \\<in> {x. poly p x = (0::'a)}) =\n  (?x2\n   \\<in> {- (b / ((2::'a) * a)) + e |e.\n          e\\<^sup>2 = (b / ((2::'a) * a))\\<^sup>2 - c / a})\n\ngoal (1 subgoal):\n 1. {x. poly p x = (0::'a)} =\n    {- (b / ((2::'a) * a)) + e |e.\n     e\\<^sup>2 = (b / ((2::'a) * a))\\<^sup>2 - c / a}", "by auto"], ["proof (state)\nthis:\n  {x. poly p x = (0::'a)} =\n  {- (b / ((2::'a) * a)) + e |e.\n   e\\<^sup>2 = (b / ((2::'a) * a))\\<^sup>2 - c / a}\n\ngoal:\nNo subgoals!", "qed"], ["", "definition croots2 :: \"complex poly \\<Rightarrow> complex list\" where\n  \"croots2 p = (let a = coeff p 2; b = coeff p 1; c = coeff p 0; b2a = b / (2 * a);\n    bac = b2a^2 - c/a;\n    e = csqrt bac \n    in\n     remdups [- b2a + e, - b2a - e])\""], ["", "definition complex_rat :: \"complex \\<Rightarrow> bool\" where\n  \"complex_rat x = (Re x \\<in> \\<rat> \\<and> Im x \\<in> \\<rat>)\""], ["", "lemma croots2: assumes \"degree p = 2\"\n  shows \"{x. poly p x = 0} = set (croots2 p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. poly p x = 0} = set (croots2 p)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. {x. poly p x = 0} = set (croots2 p)", "from degree2_coeffs[OF assms]"], ["proof (chain)\npicking this:\n  \\<exists>a b c. p = [:c, b, a:] \\<and> a \\<noteq> 0", "obtain a b c \n  where p: \"p = [:c, b, a:]\" and a: \"a \\<noteq> 0\""], ["proof (prove)\nusing this:\n  \\<exists>a b c. p = [:c, b, a:] \\<and> a \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>c b a.\n        \\<lbrakk>p = [:c, b, a:]; a \\<noteq> 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  p = [:c, b, a:]\n  a \\<noteq> 0\n\ngoal (1 subgoal):\n 1. {x. poly p x = 0} = set (croots2 p)", "note main = roots2[OF p a]"], ["proof (state)\nthis:\n  {x. poly p x = 0} =\n  {- (b / (2 * a)) + e |e. e\\<^sup>2 = (b / (2 * a))\\<^sup>2 - c / a}\n\ngoal (1 subgoal):\n 1. {x. poly p x = 0} = set (croots2 p)", "have 2: \"2 = Suc (Suc 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 = Suc (Suc 0)", "by simp"], ["proof (state)\nthis:\n  2 = Suc (Suc 0)\n\ngoal (1 subgoal):\n 1. {x. poly p x = 0} = set (croots2 p)", "have coeff: \"coeff p 2 = a\" \"coeff p 1 = b\" \"coeff p 0 = c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff p 2 = a &&& coeff p 1 = b &&& coeff p 0 = c", "unfolding p"], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff [:c, b, a:] 2 = a &&&\n    coeff [:c, b, a:] 1 = b &&& coeff [:c, b, a:] 0 = c", "by (auto simp: 2)"], ["proof (state)\nthis:\n  coeff p 2 = a\n  coeff p 1 = b\n  coeff p 0 = c\n\ngoal (1 subgoal):\n 1. {x. poly p x = 0} = set (croots2 p)", "let ?b2a = \"b / (2 * a)\""], ["proof (state)\ngoal (1 subgoal):\n 1. {x. poly p x = 0} = set (croots2 p)", "define b2a where \"b2a = ?b2a\""], ["proof (state)\nthis:\n  b2a = b / (2 * a)\n\ngoal (1 subgoal):\n 1. {x. poly p x = 0} = set (croots2 p)", "let ?bac = \"b2a^2 - c/a\""], ["proof (state)\ngoal (1 subgoal):\n 1. {x. poly p x = 0} = set (croots2 p)", "define bac where \"bac = ?bac\""], ["proof (state)\nthis:\n  bac = b2a\\<^sup>2 - c / a\n\ngoal (1 subgoal):\n 1. {x. poly p x = 0} = set (croots2 p)", "have roots: \"set (croots2 p) = {- b2a + csqrt bac, - b2a - csqrt bac}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (croots2 p) = {- b2a + csqrt bac, - b2a - csqrt bac}", "unfolding croots2_def Let_def coeff b2a_def[symmetric] bac_def[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (remdups [- b2a + csqrt bac, - b2a - csqrt bac]) =\n    {- b2a + csqrt bac, - b2a - csqrt bac}", "by (auto split: if_splits)"], ["proof (state)\nthis:\n  set (croots2 p) = {- b2a + csqrt bac, - b2a - csqrt bac}\n\ngoal (1 subgoal):\n 1. {x. poly p x = 0} = set (croots2 p)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. poly p x = 0} = set (croots2 p)", "unfolding roots main b2a_def[symmetric] bac_def[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. {- b2a + e |e. e\\<^sup>2 = bac} = {- b2a + csqrt bac, - b2a - csqrt bac}", "using power2_eq_iff"], ["proof (prove)\nusing this:\n  (?x\\<^sup>2 = ?y\\<^sup>2) = (?x = ?y \\<or> ?x = - ?y)\n\ngoal (1 subgoal):\n 1. {- b2a + e |e. e\\<^sup>2 = bac} = {- b2a + csqrt bac, - b2a - csqrt bac}", "by fastforce"], ["proof (state)\nthis:\n  {x. poly p x = 0} = set (croots2 p)\n\ngoal:\nNo subgoals!", "qed"], ["", "definition rroots2 :: \"real poly \\<Rightarrow> real list\" where\n  \"rroots2 p = (let a = coeff p 2; b = coeff p 1; c = coeff p 0; b2a = b / (2 * a);\n    bac = b2a^2 - c/a\n  in if bac = 0 then [- b2a] else if bac < 0 then []\n    else let e = sqrt bac\n    in\n     [- b2a + e, - b2a - e])\""], ["", "definition rat_roots2 :: \"rat poly \\<Rightarrow> rat list\" where\n  \"rat_roots2 p = (let a = coeff p 2; b = coeff p 1; c = coeff p 0; b2a = b / (2 * a);\n    bac = b2a^2 - c/a\n  in map (\\<lambda> e. - b2a + e) (sqrt_rat bac))\""], ["", "lemma rroots2: assumes \"degree p = 2\"\n  shows \"{x. poly p x = 0} = set (rroots2 p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. poly p x = 0} = set (rroots2 p)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. {x. poly p x = 0} = set (rroots2 p)", "from degree2_coeffs[OF assms]"], ["proof (chain)\npicking this:\n  \\<exists>a b c. p = [:c, b, a:] \\<and> a \\<noteq> 0", "obtain a b c \n  where p: \"p = [:c, b, a:]\" and a: \"a \\<noteq> 0\""], ["proof (prove)\nusing this:\n  \\<exists>a b c. p = [:c, b, a:] \\<and> a \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>c b a.\n        \\<lbrakk>p = [:c, b, a:]; a \\<noteq> 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  p = [:c, b, a:]\n  a \\<noteq> 0\n\ngoal (1 subgoal):\n 1. {x. poly p x = 0} = set (rroots2 p)", "note main = roots2[OF p a]"], ["proof (state)\nthis:\n  {x. poly p x = 0} =\n  {- (b / (2 * a)) + e |e. e\\<^sup>2 = (b / (2 * a))\\<^sup>2 - c / a}\n\ngoal (1 subgoal):\n 1. {x. poly p x = 0} = set (rroots2 p)", "have 2: \"2 = Suc (Suc 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 = Suc (Suc 0)", "by simp"], ["proof (state)\nthis:\n  2 = Suc (Suc 0)\n\ngoal (1 subgoal):\n 1. {x. poly p x = 0} = set (rroots2 p)", "have coeff: \"coeff p 2 = a\" \"coeff p 1 = b\" \"coeff p 0 = c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff p 2 = a &&& coeff p 1 = b &&& coeff p 0 = c", "unfolding p"], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff [:c, b, a:] 2 = a &&&\n    coeff [:c, b, a:] 1 = b &&& coeff [:c, b, a:] 0 = c", "by (auto simp: 2)"], ["proof (state)\nthis:\n  coeff p 2 = a\n  coeff p 1 = b\n  coeff p 0 = c\n\ngoal (1 subgoal):\n 1. {x. poly p x = 0} = set (rroots2 p)", "let ?b2a = \"b / (2 * a)\""], ["proof (state)\ngoal (1 subgoal):\n 1. {x. poly p x = 0} = set (rroots2 p)", "define b2a where \"b2a = ?b2a\""], ["proof (state)\nthis:\n  b2a = b / (2 * a)\n\ngoal (1 subgoal):\n 1. {x. poly p x = 0} = set (rroots2 p)", "let ?bac = \"b2a^2 - c/a\""], ["proof (state)\ngoal (1 subgoal):\n 1. {x. poly p x = 0} = set (rroots2 p)", "define bac where \"bac = ?bac\""], ["proof (state)\nthis:\n  bac = b2a\\<^sup>2 - c / a\n\ngoal (1 subgoal):\n 1. {x. poly p x = 0} = set (rroots2 p)", "have roots: \"set (rroots2 p) = (if bac < 0 then {} else {- b2a + sqrt bac, - b2a - sqrt bac})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (rroots2 p) =\n    (if bac < 0 then {} else {- b2a + sqrt bac, - b2a - sqrt bac})", "unfolding rroots2_def Let_def coeff b2a_def[symmetric] bac_def[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (if bac = 0 then [- b2a]\n         else if bac < 0 then []\n              else [- b2a + sqrt bac, - b2a - sqrt bac]) =\n    (if bac < 0 then {} else {- b2a + sqrt bac, - b2a - sqrt bac})", "by (auto split: if_splits)"], ["proof (state)\nthis:\n  set (rroots2 p) =\n  (if bac < 0 then {} else {- b2a + sqrt bac, - b2a - sqrt bac})\n\ngoal (1 subgoal):\n 1. {x. poly p x = 0} = set (rroots2 p)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. poly p x = 0} = set (rroots2 p)", "unfolding roots main b2a_def[symmetric] bac_def[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. {- b2a + e |e. e\\<^sup>2 = bac} =\n    (if bac < 0 then {} else {- b2a + sqrt bac, - b2a - sqrt bac})", "by auto"], ["proof (state)\nthis:\n  {x. poly p x = 0} = set (rroots2 p)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rat_roots2: assumes \"degree p = 2\"\n  shows \"{x. poly p x = 0} = set (rat_roots2 p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. poly p x = 0} = set (rat_roots2 p)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. {x. poly p x = 0} = set (rat_roots2 p)", "from degree2_coeffs[OF assms]"], ["proof (chain)\npicking this:\n  \\<exists>a b c. p = [:c, b, a:] \\<and> a \\<noteq> 0", "obtain a b c \n  where p: \"p = [:c, b, a:]\" and a: \"a \\<noteq> 0\""], ["proof (prove)\nusing this:\n  \\<exists>a b c. p = [:c, b, a:] \\<and> a \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>c b a.\n        \\<lbrakk>p = [:c, b, a:]; a \\<noteq> 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  p = [:c, b, a:]\n  a \\<noteq> 0\n\ngoal (1 subgoal):\n 1. {x. poly p x = 0} = set (rat_roots2 p)", "note main = roots2[OF p a]"], ["proof (state)\nthis:\n  {x. poly p x = 0} =\n  {- (b / (2 * a)) + e |e. e\\<^sup>2 = (b / (2 * a))\\<^sup>2 - c / a}\n\ngoal (1 subgoal):\n 1. {x. poly p x = 0} = set (rat_roots2 p)", "have 2: \"2 = Suc (Suc 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 = Suc (Suc 0)", "by simp"], ["proof (state)\nthis:\n  2 = Suc (Suc 0)\n\ngoal (1 subgoal):\n 1. {x. poly p x = 0} = set (rat_roots2 p)", "have coeff: \"coeff p 2 = a\" \"coeff p 1 = b\" \"coeff p 0 = c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff p 2 = a &&& coeff p 1 = b &&& coeff p 0 = c", "unfolding p"], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff [:c, b, a:] 2 = a &&&\n    coeff [:c, b, a:] 1 = b &&& coeff [:c, b, a:] 0 = c", "by (auto simp: 2)"], ["proof (state)\nthis:\n  coeff p 2 = a\n  coeff p 1 = b\n  coeff p 0 = c\n\ngoal (1 subgoal):\n 1. {x. poly p x = 0} = set (rat_roots2 p)", "let ?b2a = \"b / (2 * a)\""], ["proof (state)\ngoal (1 subgoal):\n 1. {x. poly p x = 0} = set (rat_roots2 p)", "define b2a where \"b2a = ?b2a\""], ["proof (state)\nthis:\n  b2a = b / (2 * a)\n\ngoal (1 subgoal):\n 1. {x. poly p x = 0} = set (rat_roots2 p)", "let ?bac = \"b2a^2 - c/a\""], ["proof (state)\ngoal (1 subgoal):\n 1. {x. poly p x = 0} = set (rat_roots2 p)", "define bac where \"bac = ?bac\""], ["proof (state)\nthis:\n  bac = b2a\\<^sup>2 - c / a\n\ngoal (1 subgoal):\n 1. {x. poly p x = 0} = set (rat_roots2 p)", "have roots: \"(rat_roots2 p) = (map (\\<lambda> e. -b2a + e) (sqrt_rat bac))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_roots2 p = map ((+) (- b2a)) (sqrt_rat bac)", "unfolding rat_roots2_def Let_def coeff b2a_def[symmetric] bac_def[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. map ((+) (- b2a)) (sqrt_rat bac) = map ((+) (- b2a)) (sqrt_rat bac)", "by auto"], ["proof (state)\nthis:\n  rat_roots2 p = map ((+) (- b2a)) (sqrt_rat bac)\n\ngoal (1 subgoal):\n 1. {x. poly p x = 0} = set (rat_roots2 p)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. poly p x = 0} = set (rat_roots2 p)", "unfolding roots main b2a_def[symmetric] bac_def[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. {- b2a + e |e. e\\<^sup>2 = bac} = set (map ((+) (- b2a)) (sqrt_rat bac))", "by (auto simp: power2_eq_square)"], ["proof (state)\nthis:\n  {x. poly p x = 0} = set (rat_roots2 p)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Determinining roots of complex polynomials of degree up to 2.\\<close>"], ["", "definition croots :: \"complex poly \\<Rightarrow> complex list\" where\n  \"croots p = (if p = 0 \\<or> degree p > 2 then [] \n    else (if degree p = 0 then [] else if degree p = 1 then [roots1 p]\n    else croots2 p))\""], ["", "lemma croots: assumes \"p \\<noteq> 0\" \"degree p \\<le> 2\"\n  shows \"set (croots p) = {x. poly p x = 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (croots p) = {x. poly p x = 0}", "using assms"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  degree p \\<le> 2\n\ngoal (1 subgoal):\n 1. set (croots p) = {x. poly p x = 0}", "unfolding croots_def"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  degree p \\<le> 2\n\ngoal (1 subgoal):\n 1. set (if p = 0 \\<or> 2 < degree p then []\n         else if degree p = 0 then []\n              else if degree p = 1 then [roots1 p] else croots2 p) =\n    {x. poly p x = 0}", "using roots0[of p] roots1[of p] croots2[of p]"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  degree p \\<le> 2\n  \\<lbrakk>p \\<noteq> 0; degree p = 0\\<rbrakk>\n  \\<Longrightarrow> {x. poly p x = 0} = {}\n  degree p = 1 \\<Longrightarrow> {x. poly p x = 0} = {roots1 p}\n  degree p = 2 \\<Longrightarrow> {x. poly p x = 0} = set (croots2 p)\n\ngoal (1 subgoal):\n 1. set (if p = 0 \\<or> 2 < degree p then []\n         else if degree p = 0 then []\n              else if degree p = 1 then [roots1 p] else croots2 p) =\n    {x. poly p x = 0}", "by (auto split: if_splits)"], ["", "text \\<open>Determinining roots of real polynomials of degree up to 2.\\<close>"], ["", "definition rroots :: \"real poly \\<Rightarrow> real list\" where\n  \"rroots p = (if p = 0 \\<or> degree p > 2 then [] \n    else (if degree p = 0 then [] else if degree p = 1 then [roots1 p]\n    else rroots2 p))\""], ["", "lemma rroots: assumes \"p \\<noteq> 0\" \"degree p \\<le> 2\"\n  shows \"set (rroots p) = {x. poly p x = 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (rroots p) = {x. poly p x = 0}", "using assms"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  degree p \\<le> 2\n\ngoal (1 subgoal):\n 1. set (rroots p) = {x. poly p x = 0}", "unfolding rroots_def"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  degree p \\<le> 2\n\ngoal (1 subgoal):\n 1. set (if p = 0 \\<or> 2 < degree p then []\n         else if degree p = 0 then []\n              else if degree p = 1 then [roots1 p] else rroots2 p) =\n    {x. poly p x = 0}", "using roots0[of p] roots1[of p] rroots2[of p]"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  degree p \\<le> 2\n  \\<lbrakk>p \\<noteq> 0; degree p = 0\\<rbrakk>\n  \\<Longrightarrow> {x. poly p x = 0} = {}\n  degree p = 1 \\<Longrightarrow> {x. poly p x = 0} = {roots1 p}\n  degree p = 2 \\<Longrightarrow> {x. poly p x = 0} = set (rroots2 p)\n\ngoal (1 subgoal):\n 1. set (if p = 0 \\<or> 2 < degree p then []\n         else if degree p = 0 then []\n              else if degree p = 1 then [roots1 p] else rroots2 p) =\n    {x. poly p x = 0}", "by (auto split: if_splits)"], ["", "text \\<open>Although there is a closed form for cubic roots, \n  which is specified below, we did not yet integrate it into the\n @{const croots} and @{const rroots} algorithms.\n One obstracle is that for complex numbers, the cubic root is not\n even defined. Therefore, we also did not proof soundness of the croots3 algorithm.\\<close>"], ["", "context\n  fixes croot :: \"nat \\<Rightarrow> complex \\<Rightarrow> complex\"\nbegin"], ["", "definition croots3 :: \"complex poly \\<Rightarrow> complex \\<times> complex \\<times> complex \\<times> complex\" where\n  \"croots3 p = (let a = coeff p 3; b = coeff p 2; c = coeff p 1; d = coeff p 0; \n    \\<Delta>\\<^sub>0 = b^2 - 3 * a * c;\n    \\<Delta>\\<^sub>1 = 2 * b^3 - 9 * a * b * c + 27 * a^2 * d;\n    C = croot 3 ((\\<Delta>\\<^sub>1 + csqrt ( \\<Delta>\\<^sub>1^2 - 4 * \\<Delta>\\<^sub>0^3)) / 2);\n    u\\<^sub>1 = 1;\n    u\\<^sub>2 = (-1 + \\<i> * csqrt 3) / 2;\n    u\\<^sub>3 = (-1 - \\<i> * csqrt 3) / 2;\n    x\\<^sub>k = (\\<lambda> u. (-1 / (3 * a)) * (b + u * C + \\<Delta>\\<^sub>0 / (u * C)))\n    in\n     (x\\<^sub>k u\\<^sub>1, x\\<^sub>k u\\<^sub>2, x\\<^sub>k u\\<^sub>3, a))\""], ["", "end"], ["", "end"]]}