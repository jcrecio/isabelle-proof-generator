{"file_name": "/home/qj213/afp-2021-10-22/thys/Polynomial_Factorization/Missing_Multiset.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Polynomial_Factorization", "problem_names": ["lemma remove_nth_soundness:\n  assumes \"n < length as\"\n  shows \"mset (remove_nth n as) = mset as - {#(as!n)#}\"", "lemma multiset_subset_insert: \"{ps. ps \\<subseteq># add_mset x xs} =\n    {ps. ps \\<subseteq># xs} \\<union> add_mset x ` {ps. ps \\<subseteq># xs}\" (is \"?l = ?r\")", "lemma multiset_of_subseqs: \"mset ` set (subseqs xs) = { ps. ps \\<subseteq># mset xs}\"", "lemma remove1_mset: \"w \\<in> set vs \\<Longrightarrow> mset (remove1 w vs) + {#w#} = mset vs\"", "lemma fold_remove1_mset: \"mset ws \\<subseteq># mset vs \\<Longrightarrow> mset (fold remove1 ws vs) + mset ws = mset vs\"", "lemma subseqs_sub_mset: \"ws \\<in> set (subseqs vs) \\<Longrightarrow> mset ws \\<subseteq># mset vs\"", "lemma filter_mset_inequality: \"filter_mset f xs \\<noteq> xs \\<Longrightarrow> \\<exists> x \\<in># xs. \\<not> f x\""], "translations": [["", "lemma remove_nth_soundness:\n  assumes \"n < length as\"\n  shows \"mset (remove_nth n as) = mset as - {#(as!n)#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mset (remove_nth n as) = mset as - {#as ! n#}", "using assms"], ["proof (prove)\nusing this:\n  n < length as\n\ngoal (1 subgoal):\n 1. mset (remove_nth n as) = mset as - {#as ! n#}", "proof (induct as arbitrary: n)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n.\n       n < length [] \\<Longrightarrow>\n       mset (remove_nth n []) = mset [] - {#[] ! n#}\n 2. \\<And>a as n.\n       \\<lbrakk>\\<And>n.\n                   n < length as \\<Longrightarrow>\n                   mset (remove_nth n as) = mset as - {#as ! n#};\n        n < length (a # as)\\<rbrakk>\n       \\<Longrightarrow> mset (remove_nth n (a # as)) =\n                         mset (a # as) - {#(a # as) ! n#}", "case (Cons a as)"], ["proof (state)\nthis:\n  ?n < length as \\<Longrightarrow>\n  mset (remove_nth ?n as) = mset as - {#as ! ?n#}\n  n < length (a # as)\n\ngoal (2 subgoals):\n 1. \\<And>n.\n       n < length [] \\<Longrightarrow>\n       mset (remove_nth n []) = mset [] - {#[] ! n#}\n 2. \\<And>a as n.\n       \\<lbrakk>\\<And>n.\n                   n < length as \\<Longrightarrow>\n                   mset (remove_nth n as) = mset as - {#as ! n#};\n        n < length (a # as)\\<rbrakk>\n       \\<Longrightarrow> mset (remove_nth n (a # as)) =\n                         mset (a # as) - {#(a # as) ! n#}", "note [simp] = remove_nth_def"], ["proof (state)\nthis:\n  remove_nth ?n ?xs \\<equiv> take ?n ?xs @ drop (Suc ?n) ?xs\n\ngoal (2 subgoals):\n 1. \\<And>n.\n       n < length [] \\<Longrightarrow>\n       mset (remove_nth n []) = mset [] - {#[] ! n#}\n 2. \\<And>a as n.\n       \\<lbrakk>\\<And>n.\n                   n < length as \\<Longrightarrow>\n                   mset (remove_nth n as) = mset as - {#as ! n#};\n        n < length (a # as)\\<rbrakk>\n       \\<Longrightarrow> mset (remove_nth n (a # as)) =\n                         mset (a # as) - {#(a # as) ! n#}", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. mset (remove_nth n (a # as)) = mset (a # as) - {#(a # as) ! n#}", "proof (cases n)"], ["proof (state)\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    mset (remove_nth n (a # as)) = mset (a # as) - {#(a # as) ! n#}\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       mset (remove_nth n (a # as)) = mset (a # as) - {#(a # as) ! n#}", "case (Suc n)"], ["proof (state)\nthis:\n  na__ = Suc n\n\ngoal (2 subgoals):\n 1. na__ = 0 \\<Longrightarrow>\n    mset (remove_nth na__ (a # as)) = mset (a # as) - {#(a # as) ! na__#}\n 2. \\<And>nat.\n       na__ = Suc nat \\<Longrightarrow>\n       mset (remove_nth na__ (a # as)) = mset (a # as) - {#(a # as) ! na__#}", "with Cons"], ["proof (chain)\npicking this:\n  ?n < length as \\<Longrightarrow>\n  mset (remove_nth ?n as) = mset as - {#as ! ?n#}\n  na__ < length (a # as)\n  na__ = Suc n", "have n_bd: \"n < length as\""], ["proof (prove)\nusing this:\n  ?n < length as \\<Longrightarrow>\n  mset (remove_nth ?n as) = mset as - {#as ! ?n#}\n  na__ < length (a # as)\n  na__ = Suc n\n\ngoal (1 subgoal):\n 1. n < length as", "by auto"], ["proof (state)\nthis:\n  n < length as\n\ngoal (2 subgoals):\n 1. na__ = 0 \\<Longrightarrow>\n    mset (remove_nth na__ (a # as)) = mset (a # as) - {#(a # as) ! na__#}\n 2. \\<And>nat.\n       na__ = Suc nat \\<Longrightarrow>\n       mset (remove_nth na__ (a # as)) = mset (a # as) - {#(a # as) ! na__#}", "with Cons"], ["proof (chain)\npicking this:\n  ?n < length as \\<Longrightarrow>\n  mset (remove_nth ?n as) = mset as - {#as ! ?n#}\n  na__ < length (a # as)\n  n < length as", "have \"mset (remove_nth n as) = mset as - {#as ! n#}\""], ["proof (prove)\nusing this:\n  ?n < length as \\<Longrightarrow>\n  mset (remove_nth ?n as) = mset as - {#as ! ?n#}\n  na__ < length (a # as)\n  n < length as\n\ngoal (1 subgoal):\n 1. mset (remove_nth n as) = mset as - {#as ! n#}", "by auto"], ["proof (state)\nthis:\n  mset (remove_nth n as) = mset as - {#as ! n#}\n\ngoal (2 subgoals):\n 1. na__ = 0 \\<Longrightarrow>\n    mset (remove_nth na__ (a # as)) = mset (a # as) - {#(a # as) ! na__#}\n 2. \\<And>nat.\n       na__ = Suc nat \\<Longrightarrow>\n       mset (remove_nth na__ (a # as)) = mset (a # as) - {#(a # as) ! na__#}", "hence G: \"mset (remove_nth (Suc n) (a # as)) = mset as - {#as ! n#} + {#a#}\""], ["proof (prove)\nusing this:\n  mset (remove_nth n as) = mset as - {#as ! n#}\n\ngoal (1 subgoal):\n 1. mset (remove_nth (Suc n) (a # as)) = mset as - {#as ! n#} + {#a#}", "by simp"], ["proof (state)\nthis:\n  mset (remove_nth (Suc n) (a # as)) = mset as - {#as ! n#} + {#a#}\n\ngoal (2 subgoals):\n 1. na__ = 0 \\<Longrightarrow>\n    mset (remove_nth na__ (a # as)) = mset (a # as) - {#(a # as) ! na__#}\n 2. \\<And>nat.\n       na__ = Suc nat \\<Longrightarrow>\n       mset (remove_nth na__ (a # as)) = mset (a # as) - {#(a # as) ! na__#}", "thus ?thesis"], ["proof (prove)\nusing this:\n  mset (remove_nth (Suc n) (a # as)) = mset as - {#as ! n#} + {#a#}\n\ngoal (1 subgoal):\n 1. mset (remove_nth na__ (a # as)) = mset (a # as) - {#(a # as) ! na__#}", "proof (cases \"a = as!n\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>mset (remove_nth (Suc n) (a # as)) =\n             mset as - {#as ! n#} + {#a#};\n     a = as ! n\\<rbrakk>\n    \\<Longrightarrow> mset (remove_nth na__ (a # as)) =\n                      mset (a # as) - {#(a # as) ! na__#}\n 2. \\<lbrakk>mset (remove_nth (Suc n) (a # as)) =\n             mset as - {#as ! n#} + {#a#};\n     a \\<noteq> as ! n\\<rbrakk>\n    \\<Longrightarrow> mset (remove_nth na__ (a # as)) =\n                      mset (a # as) - {#(a # as) ! na__#}", "case True"], ["proof (state)\nthis:\n  a = as ! n\n\ngoal (2 subgoals):\n 1. \\<lbrakk>mset (remove_nth (Suc n) (a # as)) =\n             mset as - {#as ! n#} + {#a#};\n     a = as ! n\\<rbrakk>\n    \\<Longrightarrow> mset (remove_nth na__ (a # as)) =\n                      mset (a # as) - {#(a # as) ! na__#}\n 2. \\<lbrakk>mset (remove_nth (Suc n) (a # as)) =\n             mset as - {#as ! n#} + {#a#};\n     a \\<noteq> as ! n\\<rbrakk>\n    \\<Longrightarrow> mset (remove_nth na__ (a # as)) =\n                      mset (a # as) - {#(a # as) ! na__#}", "with G and Suc and insert_DiffM2[symmetric]\n        and insert_DiffM2[of _ \"{#as ! n#}\"]\n        and nth_mem_mset[of n as] and n_bd"], ["proof (chain)\npicking this:\n  mset (remove_nth (Suc n) (a # as)) = mset as - {#as ! n#} + {#a#}\n  na__ = Suc n\n  ?x \\<in># ?t \\<Longrightarrow> ?t = ?t - {#?x#} + {#?x#}\n  ?x \\<in># {#as ! n#} \\<Longrightarrow>\n  {#as ! n#} - {#?x#} + {#?x#} = {#as ! n#}\n  n < length as \\<Longrightarrow> as ! n \\<in># mset as\n  n < length as\n  a = as ! n", "show ?thesis"], ["proof (prove)\nusing this:\n  mset (remove_nth (Suc n) (a # as)) = mset as - {#as ! n#} + {#a#}\n  na__ = Suc n\n  ?x \\<in># ?t \\<Longrightarrow> ?t = ?t - {#?x#} + {#?x#}\n  ?x \\<in># {#as ! n#} \\<Longrightarrow>\n  {#as ! n#} - {#?x#} + {#?x#} = {#as ! n#}\n  n < length as \\<Longrightarrow> as ! n \\<in># mset as\n  n < length as\n  a = as ! n\n\ngoal (1 subgoal):\n 1. mset (remove_nth na__ (a # as)) = mset (a # as) - {#(a # as) ! na__#}", "by auto"], ["proof (state)\nthis:\n  mset (remove_nth na__ (a # as)) = mset (a # as) - {#(a # as) ! na__#}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>mset (remove_nth (Suc n) (a # as)) =\n             mset as - {#as ! n#} + {#a#};\n     a \\<noteq> as ! n\\<rbrakk>\n    \\<Longrightarrow> mset (remove_nth na__ (a # as)) =\n                      mset (a # as) - {#(a # as) ! na__#}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>mset (remove_nth (Suc n) (a # as)) =\n             mset as - {#as ! n#} + {#a#};\n     a \\<noteq> as ! n\\<rbrakk>\n    \\<Longrightarrow> mset (remove_nth na__ (a # as)) =\n                      mset (a # as) - {#(a # as) ! na__#}", "case False"], ["proof (state)\nthis:\n  a \\<noteq> as ! n\n\ngoal (1 subgoal):\n 1. \\<lbrakk>mset (remove_nth (Suc n) (a # as)) =\n             mset as - {#as ! n#} + {#a#};\n     a \\<noteq> as ! n\\<rbrakk>\n    \\<Longrightarrow> mset (remove_nth na__ (a # as)) =\n                      mset (a # as) - {#(a # as) ! na__#}", "from G and Suc and diff_union_swap[OF this[symmetric], symmetric]"], ["proof (chain)\npicking this:\n  mset (remove_nth (Suc n) (a # as)) = mset as - {#as ! n#} + {#a#}\n  na__ = Suc n\n  add_mset a ?M - {#as ! n#} = add_mset a (?M - {#as ! n#})", "show ?thesis"], ["proof (prove)\nusing this:\n  mset (remove_nth (Suc n) (a # as)) = mset as - {#as ! n#} + {#a#}\n  na__ = Suc n\n  add_mset a ?M - {#as ! n#} = add_mset a (?M - {#as ! n#})\n\ngoal (1 subgoal):\n 1. mset (remove_nth na__ (a # as)) = mset (a # as) - {#(a # as) ! na__#}", "by simp"], ["proof (state)\nthis:\n  mset (remove_nth na__ (a # as)) = mset (a # as) - {#(a # as) ! na__#}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  mset (remove_nth na__ (a # as)) = mset (a # as) - {#(a # as) ! na__#}\n\ngoal (1 subgoal):\n 1. na__ = 0 \\<Longrightarrow>\n    mset (remove_nth na__ (a # as)) = mset (a # as) - {#(a # as) ! na__#}", "qed auto"], ["proof (state)\nthis:\n  mset (remove_nth n (a # as)) = mset (a # as) - {#(a # as) ! n#}\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       n < length [] \\<Longrightarrow>\n       mset (remove_nth n []) = mset [] - {#[] ! n#}", "qed auto"], ["", "lemma multiset_subset_insert: \"{ps. ps \\<subseteq># add_mset x xs} =\n    {ps. ps \\<subseteq># xs} \\<union> add_mset x ` {ps. ps \\<subseteq># xs}\" (is \"?l = ?r\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. {ps. ps \\<subseteq># add_mset x xs} =\n    {ps. ps \\<subseteq># xs} \\<union> add_mset x ` {ps. ps \\<subseteq># xs}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. {ps. ps \\<subseteq># add_mset x xs} =\n    {ps. ps \\<subseteq># xs} \\<union> add_mset x ` {ps. ps \\<subseteq># xs}", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. {ps. ps \\<subseteq># add_mset x xs} =\n    {ps. ps \\<subseteq># xs} \\<union> add_mset x ` {ps. ps \\<subseteq># xs}", "fix ps"], ["proof (state)\ngoal (1 subgoal):\n 1. {ps. ps \\<subseteq># add_mset x xs} =\n    {ps. ps \\<subseteq># xs} \\<union> add_mset x ` {ps. ps \\<subseteq># xs}", "have \"(ps \\<in> ?l) = (ps \\<subseteq># xs + {# x #})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ps \\<in> {ps. ps \\<subseteq># add_mset x xs}) =\n    (ps \\<subseteq># xs + {#x#})", "by auto"], ["proof (state)\nthis:\n  (ps \\<in> {ps. ps \\<subseteq># add_mset x xs}) =\n  (ps \\<subseteq># xs + {#x#})\n\ngoal (1 subgoal):\n 1. {ps. ps \\<subseteq># add_mset x xs} =\n    {ps. ps \\<subseteq># xs} \\<union> add_mset x ` {ps. ps \\<subseteq># xs}", "also"], ["proof (state)\nthis:\n  (ps \\<in> {ps. ps \\<subseteq># add_mset x xs}) =\n  (ps \\<subseteq># xs + {#x#})\n\ngoal (1 subgoal):\n 1. {ps. ps \\<subseteq># add_mset x xs} =\n    {ps. ps \\<subseteq># xs} \\<union> add_mset x ` {ps. ps \\<subseteq># xs}", "have \"\\<dots> = (ps \\<in> ?r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ps \\<subseteq># xs + {#x#}) =\n    (ps \\<in> {ps. ps \\<subseteq># xs} \\<union>\n              add_mset x ` {ps. ps \\<subseteq># xs})", "proof (cases \"x \\<in># ps\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<in># ps \\<Longrightarrow>\n    (ps \\<subseteq># xs + {#x#}) =\n    (ps \\<in> {ps. ps \\<subseteq># xs} \\<union>\n              add_mset x ` {ps. ps \\<subseteq># xs})\n 2. x \\<notin># ps \\<Longrightarrow>\n    (ps \\<subseteq># xs + {#x#}) =\n    (ps \\<in> {ps. ps \\<subseteq># xs} \\<union>\n              add_mset x ` {ps. ps \\<subseteq># xs})", "case True"], ["proof (state)\nthis:\n  x \\<in># ps\n\ngoal (2 subgoals):\n 1. x \\<in># ps \\<Longrightarrow>\n    (ps \\<subseteq># xs + {#x#}) =\n    (ps \\<in> {ps. ps \\<subseteq># xs} \\<union>\n              add_mset x ` {ps. ps \\<subseteq># xs})\n 2. x \\<notin># ps \\<Longrightarrow>\n    (ps \\<subseteq># xs + {#x#}) =\n    (ps \\<in> {ps. ps \\<subseteq># xs} \\<union>\n              add_mset x ` {ps. ps \\<subseteq># xs})", "then"], ["proof (chain)\npicking this:\n  x \\<in># ps", "obtain qs where ps: \"ps = qs + {#x#}\""], ["proof (prove)\nusing this:\n  x \\<in># ps\n\ngoal (1 subgoal):\n 1. (\\<And>qs. ps = qs + {#x#} \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis insert_DiffM2)"], ["proof (state)\nthis:\n  ps = qs + {#x#}\n\ngoal (2 subgoals):\n 1. x \\<in># ps \\<Longrightarrow>\n    (ps \\<subseteq># xs + {#x#}) =\n    (ps \\<in> {ps. ps \\<subseteq># xs} \\<union>\n              add_mset x ` {ps. ps \\<subseteq># xs})\n 2. x \\<notin># ps \\<Longrightarrow>\n    (ps \\<subseteq># xs + {#x#}) =\n    (ps \\<in> {ps. ps \\<subseteq># xs} \\<union>\n              add_mset x ` {ps. ps \\<subseteq># xs})", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (ps \\<subseteq># xs + {#x#}) =\n    (ps \\<in> {ps. ps \\<subseteq># xs} \\<union>\n              add_mset x ` {ps. ps \\<subseteq># xs})", "unfolding ps mset_subset_eq_mono_add_right_cancel"], ["proof (prove)\ngoal (1 subgoal):\n 1. (qs \\<subseteq># xs) =\n    (qs + {#x#}\n     \\<in> {ps. ps \\<subseteq># xs} \\<union>\n           add_mset x ` {ps. ps \\<subseteq># xs})", "by (auto dest: mset_subset_eq_insertD)"], ["proof (state)\nthis:\n  (ps \\<subseteq># xs + {#x#}) =\n  (ps \\<in> {ps. ps \\<subseteq># xs} \\<union>\n            add_mset x ` {ps. ps \\<subseteq># xs})\n\ngoal (1 subgoal):\n 1. x \\<notin># ps \\<Longrightarrow>\n    (ps \\<subseteq># xs + {#x#}) =\n    (ps \\<in> {ps. ps \\<subseteq># xs} \\<union>\n              add_mset x ` {ps. ps \\<subseteq># xs})", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<notin># ps \\<Longrightarrow>\n    (ps \\<subseteq># xs + {#x#}) =\n    (ps \\<in> {ps. ps \\<subseteq># xs} \\<union>\n              add_mset x ` {ps. ps \\<subseteq># xs})", "case False"], ["proof (state)\nthis:\n  x \\<notin># ps\n\ngoal (1 subgoal):\n 1. x \\<notin># ps \\<Longrightarrow>\n    (ps \\<subseteq># xs + {#x#}) =\n    (ps \\<in> {ps. ps \\<subseteq># xs} \\<union>\n              add_mset x ` {ps. ps \\<subseteq># xs})", "hence id: \"(ps \\<subseteq># xs + {#x#}) = (ps \\<subseteq># xs)\""], ["proof (prove)\nusing this:\n  x \\<notin># ps\n\ngoal (1 subgoal):\n 1. (ps \\<subseteq># xs + {#x#}) = (ps \\<subseteq># xs)", "by (simp add: subset_mset.inf.absorb_iff2 inter_add_left1)"], ["proof (state)\nthis:\n  (ps \\<subseteq># xs + {#x#}) = (ps \\<subseteq># xs)\n\ngoal (1 subgoal):\n 1. x \\<notin># ps \\<Longrightarrow>\n    (ps \\<subseteq># xs + {#x#}) =\n    (ps \\<in> {ps. ps \\<subseteq># xs} \\<union>\n              add_mset x ` {ps. ps \\<subseteq># xs})", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (ps \\<subseteq># xs + {#x#}) =\n    (ps \\<in> {ps. ps \\<subseteq># xs} \\<union>\n              add_mset x ` {ps. ps \\<subseteq># xs})", "unfolding id"], ["proof (prove)\ngoal (1 subgoal):\n 1. (ps \\<subseteq># xs) =\n    (ps \\<in> {ps. ps \\<subseteq># xs} \\<union>\n              add_mset x ` {ps. ps \\<subseteq># xs})", "using False"], ["proof (prove)\nusing this:\n  x \\<notin># ps\n\ngoal (1 subgoal):\n 1. (ps \\<subseteq># xs) =\n    (ps \\<in> {ps. ps \\<subseteq># xs} \\<union>\n              add_mset x ` {ps. ps \\<subseteq># xs})", "by auto"], ["proof (state)\nthis:\n  (ps \\<subseteq># xs + {#x#}) =\n  (ps \\<in> {ps. ps \\<subseteq># xs} \\<union>\n            add_mset x ` {ps. ps \\<subseteq># xs})\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (ps \\<subseteq># xs + {#x#}) =\n  (ps \\<in> {ps. ps \\<subseteq># xs} \\<union>\n            add_mset x ` {ps. ps \\<subseteq># xs})\n\ngoal (1 subgoal):\n 1. {ps. ps \\<subseteq># add_mset x xs} =\n    {ps. ps \\<subseteq># xs} \\<union> add_mset x ` {ps. ps \\<subseteq># xs}", "finally"], ["proof (chain)\npicking this:\n  (ps \\<in> {ps. ps \\<subseteq># add_mset x xs}) =\n  (ps \\<in> {ps. ps \\<subseteq># xs} \\<union>\n            add_mset x ` {ps. ps \\<subseteq># xs})", "have \"(ps \\<in> ?l) = (ps \\<in> ?r)\""], ["proof (prove)\nusing this:\n  (ps \\<in> {ps. ps \\<subseteq># add_mset x xs}) =\n  (ps \\<in> {ps. ps \\<subseteq># xs} \\<union>\n            add_mset x ` {ps. ps \\<subseteq># xs})\n\ngoal (1 subgoal):\n 1. (ps \\<in> {ps. ps \\<subseteq># add_mset x xs}) =\n    (ps \\<in> {ps. ps \\<subseteq># xs} \\<union>\n              add_mset x ` {ps. ps \\<subseteq># xs})", "."], ["proof (state)\nthis:\n  (ps \\<in> {ps. ps \\<subseteq># add_mset x xs}) =\n  (ps \\<in> {ps. ps \\<subseteq># xs} \\<union>\n            add_mset x ` {ps. ps \\<subseteq># xs})\n\ngoal (1 subgoal):\n 1. {ps. ps \\<subseteq># add_mset x xs} =\n    {ps. ps \\<subseteq># xs} \\<union> add_mset x ` {ps. ps \\<subseteq># xs}", "}"], ["proof (state)\nthis:\n  (?ps2 \\<in> {ps. ps \\<subseteq># add_mset x xs}) =\n  (?ps2\n   \\<in> {ps. ps \\<subseteq># xs} \\<union>\n         add_mset x ` {ps. ps \\<subseteq># xs})\n\ngoal (1 subgoal):\n 1. {ps. ps \\<subseteq># add_mset x xs} =\n    {ps. ps \\<subseteq># xs} \\<union> add_mset x ` {ps. ps \\<subseteq># xs}", "thus ?thesis"], ["proof (prove)\nusing this:\n  (?ps2 \\<in> {ps. ps \\<subseteq># add_mset x xs}) =\n  (?ps2\n   \\<in> {ps. ps \\<subseteq># xs} \\<union>\n         add_mset x ` {ps. ps \\<subseteq># xs})\n\ngoal (1 subgoal):\n 1. {ps. ps \\<subseteq># add_mset x xs} =\n    {ps. ps \\<subseteq># xs} \\<union> add_mset x ` {ps. ps \\<subseteq># xs}", "by auto"], ["proof (state)\nthis:\n  {ps. ps \\<subseteq># add_mset x xs} =\n  {ps. ps \\<subseteq># xs} \\<union> add_mset x ` {ps. ps \\<subseteq># xs}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma multiset_of_subseqs: \"mset ` set (subseqs xs) = { ps. ps \\<subseteq># mset xs}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mset ` set (subseqs xs) = {ps. ps \\<subseteq># mset xs}", "proof (induct xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. mset ` set (subseqs []) = {ps. ps \\<subseteq># mset []}\n 2. \\<And>a xs.\n       mset ` set (subseqs xs) =\n       {ps. ps \\<subseteq># mset xs} \\<Longrightarrow>\n       mset ` set (subseqs (a # xs)) = {ps. ps \\<subseteq># mset (a # xs)}", "case (Cons x xs)"], ["proof (state)\nthis:\n  mset ` set (subseqs xs) = {ps. ps \\<subseteq># mset xs}\n\ngoal (2 subgoals):\n 1. mset ` set (subseqs []) = {ps. ps \\<subseteq># mset []}\n 2. \\<And>a xs.\n       mset ` set (subseqs xs) =\n       {ps. ps \\<subseteq># mset xs} \\<Longrightarrow>\n       mset ` set (subseqs (a # xs)) = {ps. ps \\<subseteq># mset (a # xs)}", "show ?case (is \"?l = ?r\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. mset ` set (subseqs (x # xs)) = {ps. ps \\<subseteq># mset (x # xs)}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. mset ` set (subseqs (x # xs)) = {ps. ps \\<subseteq># mset (x # xs)}", "have id: \"?r = {ps. ps \\<subseteq># mset xs} \\<union> (add_mset x) ` {ps. ps \\<subseteq># mset xs}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {ps. ps \\<subseteq># mset (x # xs)} =\n    {ps. ps \\<subseteq># mset xs} \\<union>\n    add_mset x ` {ps. ps \\<subseteq># mset xs}", "by (simp add: multiset_subset_insert)"], ["proof (state)\nthis:\n  {ps. ps \\<subseteq># mset (x # xs)} =\n  {ps. ps \\<subseteq># mset xs} \\<union>\n  add_mset x ` {ps. ps \\<subseteq># mset xs}\n\ngoal (1 subgoal):\n 1. mset ` set (subseqs (x # xs)) = {ps. ps \\<subseteq># mset (x # xs)}", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. mset ` set (subseqs (x # xs)) = {ps. ps \\<subseteq># mset (x # xs)}", "unfolding id Cons[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. mset ` set (subseqs (x # xs)) =\n    mset ` set (subseqs xs) \\<union> add_mset x ` mset ` set (subseqs xs)", "by (auto simp add: Let_def) (metis UnCI image_iff mset.simps(2))"], ["proof (state)\nthis:\n  mset ` set (subseqs (x # xs)) = {ps. ps \\<subseteq># mset (x # xs)}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  mset ` set (subseqs (x # xs)) = {ps. ps \\<subseteq># mset (x # xs)}\n\ngoal (1 subgoal):\n 1. mset ` set (subseqs []) = {ps. ps \\<subseteq># mset []}", "qed simp"], ["", "lemma remove1_mset: \"w \\<in> set vs \\<Longrightarrow> mset (remove1 w vs) + {#w#} = mset vs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w \\<in> set vs \\<Longrightarrow> mset (remove1 w vs) + {#w#} = mset vs", "by (induct vs) auto"], ["", "lemma fold_remove1_mset: \"mset ws \\<subseteq># mset vs \\<Longrightarrow> mset (fold remove1 ws vs) + mset ws = mset vs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mset ws \\<subseteq># mset vs \\<Longrightarrow>\n    mset (fold remove1 ws vs) + mset ws = mset vs", "proof (induct ws arbitrary: vs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>vs.\n       mset [] \\<subseteq># mset vs \\<Longrightarrow>\n       mset (fold remove1 [] vs) + mset [] = mset vs\n 2. \\<And>a ws vs.\n       \\<lbrakk>\\<And>vs.\n                   mset ws \\<subseteq># mset vs \\<Longrightarrow>\n                   mset (fold remove1 ws vs) + mset ws = mset vs;\n        mset (a # ws) \\<subseteq># mset vs\\<rbrakk>\n       \\<Longrightarrow> mset (fold remove1 (a # ws) vs) + mset (a # ws) =\n                         mset vs", "case (Cons w ws vs)"], ["proof (state)\nthis:\n  mset ws \\<subseteq># mset ?vs \\<Longrightarrow>\n  mset (fold remove1 ws ?vs) + mset ws = mset ?vs\n  mset (w # ws) \\<subseteq># mset vs\n\ngoal (2 subgoals):\n 1. \\<And>vs.\n       mset [] \\<subseteq># mset vs \\<Longrightarrow>\n       mset (fold remove1 [] vs) + mset [] = mset vs\n 2. \\<And>a ws vs.\n       \\<lbrakk>\\<And>vs.\n                   mset ws \\<subseteq># mset vs \\<Longrightarrow>\n                   mset (fold remove1 ws vs) + mset ws = mset vs;\n        mset (a # ws) \\<subseteq># mset vs\\<rbrakk>\n       \\<Longrightarrow> mset (fold remove1 (a # ws) vs) + mset (a # ws) =\n                         mset vs", "from Cons(2)"], ["proof (chain)\npicking this:\n  mset (w # ws) \\<subseteq># mset vs", "have \"w \\<in> set vs\""], ["proof (prove)\nusing this:\n  mset (w # ws) \\<subseteq># mset vs\n\ngoal (1 subgoal):\n 1. w \\<in> set vs", "using set_mset_mono"], ["proof (prove)\nusing this:\n  mset (w # ws) \\<subseteq># mset vs\n  ?A \\<subseteq># ?B \\<Longrightarrow> set_mset ?A \\<subseteq> set_mset ?B\n\ngoal (1 subgoal):\n 1. w \\<in> set vs", "by force"], ["proof (state)\nthis:\n  w \\<in> set vs\n\ngoal (2 subgoals):\n 1. \\<And>vs.\n       mset [] \\<subseteq># mset vs \\<Longrightarrow>\n       mset (fold remove1 [] vs) + mset [] = mset vs\n 2. \\<And>a ws vs.\n       \\<lbrakk>\\<And>vs.\n                   mset ws \\<subseteq># mset vs \\<Longrightarrow>\n                   mset (fold remove1 ws vs) + mset ws = mset vs;\n        mset (a # ws) \\<subseteq># mset vs\\<rbrakk>\n       \\<Longrightarrow> mset (fold remove1 (a # ws) vs) + mset (a # ws) =\n                         mset vs", "from remove1_mset[OF this]"], ["proof (chain)\npicking this:\n  mset (remove1 w vs) + {#w#} = mset vs", "have vs: \"mset vs = mset (remove1 w vs) + {#w#}\""], ["proof (prove)\nusing this:\n  mset (remove1 w vs) + {#w#} = mset vs\n\ngoal (1 subgoal):\n 1. mset vs = mset (remove1 w vs) + {#w#}", "by simp"], ["proof (state)\nthis:\n  mset vs = mset (remove1 w vs) + {#w#}\n\ngoal (2 subgoals):\n 1. \\<And>vs.\n       mset [] \\<subseteq># mset vs \\<Longrightarrow>\n       mset (fold remove1 [] vs) + mset [] = mset vs\n 2. \\<And>a ws vs.\n       \\<lbrakk>\\<And>vs.\n                   mset ws \\<subseteq># mset vs \\<Longrightarrow>\n                   mset (fold remove1 ws vs) + mset ws = mset vs;\n        mset (a # ws) \\<subseteq># mset vs\\<rbrakk>\n       \\<Longrightarrow> mset (fold remove1 (a # ws) vs) + mset (a # ws) =\n                         mset vs", "from Cons(2)[unfolded vs]"], ["proof (chain)\npicking this:\n  mset (w # ws) \\<subseteq># mset (remove1 w vs) + {#w#}", "have \"mset ws \\<subseteq># mset (remove1 w vs)\""], ["proof (prove)\nusing this:\n  mset (w # ws) \\<subseteq># mset (remove1 w vs) + {#w#}\n\ngoal (1 subgoal):\n 1. mset ws \\<subseteq># mset (remove1 w vs)", "by auto"], ["proof (state)\nthis:\n  mset ws \\<subseteq># mset (remove1 w vs)\n\ngoal (2 subgoals):\n 1. \\<And>vs.\n       mset [] \\<subseteq># mset vs \\<Longrightarrow>\n       mset (fold remove1 [] vs) + mset [] = mset vs\n 2. \\<And>a ws vs.\n       \\<lbrakk>\\<And>vs.\n                   mset ws \\<subseteq># mset vs \\<Longrightarrow>\n                   mset (fold remove1 ws vs) + mset ws = mset vs;\n        mset (a # ws) \\<subseteq># mset vs\\<rbrakk>\n       \\<Longrightarrow> mset (fold remove1 (a # ws) vs) + mset (a # ws) =\n                         mset vs", "from Cons(1)[OF this,symmetric]"], ["proof (chain)\npicking this:\n  mset (remove1 w vs) = mset (fold remove1 ws (remove1 w vs)) + mset ws", "show ?case"], ["proof (prove)\nusing this:\n  mset (remove1 w vs) = mset (fold remove1 ws (remove1 w vs)) + mset ws\n\ngoal (1 subgoal):\n 1. mset (fold remove1 (w # ws) vs) + mset (w # ws) = mset vs", "unfolding vs"], ["proof (prove)\nusing this:\n  mset (remove1 w vs) = mset (fold remove1 ws (remove1 w vs)) + mset ws\n\ngoal (1 subgoal):\n 1. mset (fold remove1 (w # ws) vs) + mset (w # ws) =\n    mset (remove1 w vs) + {#w#}", "by (simp add: ac_simps)"], ["proof (state)\nthis:\n  mset (fold remove1 (w # ws) vs) + mset (w # ws) = mset vs\n\ngoal (1 subgoal):\n 1. \\<And>vs.\n       mset [] \\<subseteq># mset vs \\<Longrightarrow>\n       mset (fold remove1 [] vs) + mset [] = mset vs", "qed simp"], ["", "lemma subseqs_sub_mset: \"ws \\<in> set (subseqs vs) \\<Longrightarrow> mset ws \\<subseteq># mset vs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ws \\<in> set (subseqs vs) \\<Longrightarrow> mset ws \\<subseteq># mset vs", "proof (induct vs arbitrary: ws)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ws.\n       ws \\<in> set (subseqs []) \\<Longrightarrow>\n       mset ws \\<subseteq># mset []\n 2. \\<And>a vs ws.\n       \\<lbrakk>\\<And>ws.\n                   ws \\<in> set (subseqs vs) \\<Longrightarrow>\n                   mset ws \\<subseteq># mset vs;\n        ws \\<in> set (subseqs (a # vs))\\<rbrakk>\n       \\<Longrightarrow> mset ws \\<subseteq># mset (a # vs)", "case (Cons v vs Ws)"], ["proof (state)\nthis:\n  ?ws \\<in> set (subseqs vs) \\<Longrightarrow> mset ?ws \\<subseteq># mset vs\n  Ws \\<in> set (subseqs (v # vs))\n\ngoal (2 subgoals):\n 1. \\<And>ws.\n       ws \\<in> set (subseqs []) \\<Longrightarrow>\n       mset ws \\<subseteq># mset []\n 2. \\<And>a vs ws.\n       \\<lbrakk>\\<And>ws.\n                   ws \\<in> set (subseqs vs) \\<Longrightarrow>\n                   mset ws \\<subseteq># mset vs;\n        ws \\<in> set (subseqs (a # vs))\\<rbrakk>\n       \\<Longrightarrow> mset ws \\<subseteq># mset (a # vs)", "note mem = Cons(2)"], ["proof (state)\nthis:\n  Ws \\<in> set (subseqs (v # vs))\n\ngoal (2 subgoals):\n 1. \\<And>ws.\n       ws \\<in> set (subseqs []) \\<Longrightarrow>\n       mset ws \\<subseteq># mset []\n 2. \\<And>a vs ws.\n       \\<lbrakk>\\<And>ws.\n                   ws \\<in> set (subseqs vs) \\<Longrightarrow>\n                   mset ws \\<subseteq># mset vs;\n        ws \\<in> set (subseqs (a # vs))\\<rbrakk>\n       \\<Longrightarrow> mset ws \\<subseteq># mset (a # vs)", "note IH = Cons(1)"], ["proof (state)\nthis:\n  ?ws \\<in> set (subseqs vs) \\<Longrightarrow> mset ?ws \\<subseteq># mset vs\n\ngoal (2 subgoals):\n 1. \\<And>ws.\n       ws \\<in> set (subseqs []) \\<Longrightarrow>\n       mset ws \\<subseteq># mset []\n 2. \\<And>a vs ws.\n       \\<lbrakk>\\<And>ws.\n                   ws \\<in> set (subseqs vs) \\<Longrightarrow>\n                   mset ws \\<subseteq># mset vs;\n        ws \\<in> set (subseqs (a # vs))\\<rbrakk>\n       \\<Longrightarrow> mset ws \\<subseteq># mset (a # vs)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. mset Ws \\<subseteq># mset (v # vs)", "proof (cases Ws)"], ["proof (state)\ngoal (2 subgoals):\n 1. Ws = [] \\<Longrightarrow> mset Ws \\<subseteq># mset (v # vs)\n 2. \\<And>a list.\n       Ws = a # list \\<Longrightarrow> mset Ws \\<subseteq># mset (v # vs)", "case (Cons w ws)"], ["proof (state)\nthis:\n  Ws = w # ws\n\ngoal (2 subgoals):\n 1. Ws = [] \\<Longrightarrow> mset Ws \\<subseteq># mset (v # vs)\n 2. \\<And>a list.\n       Ws = a # list \\<Longrightarrow> mset Ws \\<subseteq># mset (v # vs)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. mset Ws \\<subseteq># mset (v # vs)", "proof (cases \"v = w\")"], ["proof (state)\ngoal (2 subgoals):\n 1. v = w \\<Longrightarrow> mset Ws \\<subseteq># mset (v # vs)\n 2. v \\<noteq> w \\<Longrightarrow> mset Ws \\<subseteq># mset (v # vs)", "case True"], ["proof (state)\nthis:\n  v = w\n\ngoal (2 subgoals):\n 1. v = w \\<Longrightarrow> mset Ws \\<subseteq># mset (v # vs)\n 2. v \\<noteq> w \\<Longrightarrow> mset Ws \\<subseteq># mset (v # vs)", "from mem Cons"], ["proof (chain)\npicking this:\n  Ws \\<in> set (subseqs (v # vs))\n  Ws = w # ws", "have \"ws \\<in> set (subseqs vs)\""], ["proof (prove)\nusing this:\n  Ws \\<in> set (subseqs (v # vs))\n  Ws = w # ws\n\ngoal (1 subgoal):\n 1. ws \\<in> set (subseqs vs)", "by (auto simp: Let_def Cons_in_subseqsD[of _ ws vs])"], ["proof (state)\nthis:\n  ws \\<in> set (subseqs vs)\n\ngoal (2 subgoals):\n 1. v = w \\<Longrightarrow> mset Ws \\<subseteq># mset (v # vs)\n 2. v \\<noteq> w \\<Longrightarrow> mset Ws \\<subseteq># mset (v # vs)", "from IH[OF this]"], ["proof (chain)\npicking this:\n  mset ws \\<subseteq># mset vs", "show ?thesis"], ["proof (prove)\nusing this:\n  mset ws \\<subseteq># mset vs\n\ngoal (1 subgoal):\n 1. mset Ws \\<subseteq># mset (v # vs)", "unfolding Cons True"], ["proof (prove)\nusing this:\n  mset ws \\<subseteq># mset vs\n\ngoal (1 subgoal):\n 1. mset (w # ws) \\<subseteq># mset (w # vs)", "by simp"], ["proof (state)\nthis:\n  mset Ws \\<subseteq># mset (v # vs)\n\ngoal (1 subgoal):\n 1. v \\<noteq> w \\<Longrightarrow> mset Ws \\<subseteq># mset (v # vs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. v \\<noteq> w \\<Longrightarrow> mset Ws \\<subseteq># mset (v # vs)", "case False"], ["proof (state)\nthis:\n  v \\<noteq> w\n\ngoal (1 subgoal):\n 1. v \\<noteq> w \\<Longrightarrow> mset Ws \\<subseteq># mset (v # vs)", "with mem Cons"], ["proof (chain)\npicking this:\n  Ws \\<in> set (subseqs (v # vs))\n  Ws = w # ws\n  v \\<noteq> w", "have \"Ws \\<in> set (subseqs vs)\""], ["proof (prove)\nusing this:\n  Ws \\<in> set (subseqs (v # vs))\n  Ws = w # ws\n  v \\<noteq> w\n\ngoal (1 subgoal):\n 1. Ws \\<in> set (subseqs vs)", "by (auto simp: Let_def Cons_in_subseqsD[of _ ws vs])"], ["proof (state)\nthis:\n  Ws \\<in> set (subseqs vs)\n\ngoal (1 subgoal):\n 1. v \\<noteq> w \\<Longrightarrow> mset Ws \\<subseteq># mset (v # vs)", "note IH = mset_subset_eq_count[OF IH[OF this]]"], ["proof (state)\nthis:\n  count (mset Ws) ?a \\<le> count (mset vs) ?a\n\ngoal (1 subgoal):\n 1. v \\<noteq> w \\<Longrightarrow> mset Ws \\<subseteq># mset (v # vs)", "with IH[of v]"], ["proof (chain)\npicking this:\n  count (mset Ws) v \\<le> count (mset vs) v\n  count (mset Ws) ?a \\<le> count (mset vs) ?a", "show ?thesis"], ["proof (prove)\nusing this:\n  count (mset Ws) v \\<le> count (mset vs) v\n  count (mset Ws) ?a \\<le> count (mset vs) ?a\n\ngoal (1 subgoal):\n 1. mset Ws \\<subseteq># mset (v # vs)", "by (intro mset_subset_eqI, auto, linarith)"], ["proof (state)\nthis:\n  mset Ws \\<subseteq># mset (v # vs)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  mset Ws \\<subseteq># mset (v # vs)\n\ngoal (1 subgoal):\n 1. Ws = [] \\<Longrightarrow> mset Ws \\<subseteq># mset (v # vs)", "qed simp"], ["proof (state)\nthis:\n  mset Ws \\<subseteq># mset (v # vs)\n\ngoal (1 subgoal):\n 1. \\<And>ws.\n       ws \\<in> set (subseqs []) \\<Longrightarrow>\n       mset ws \\<subseteq># mset []", "qed simp"], ["", "lemma filter_mset_inequality: \"filter_mset f xs \\<noteq> xs \\<Longrightarrow> \\<exists> x \\<in># xs. \\<not> f x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filter_mset f xs \\<noteq> xs \\<Longrightarrow>\n    \\<exists>x\\<in>#xs. \\<not> f x", "by (induct xs, auto)"], ["", "end"]]}