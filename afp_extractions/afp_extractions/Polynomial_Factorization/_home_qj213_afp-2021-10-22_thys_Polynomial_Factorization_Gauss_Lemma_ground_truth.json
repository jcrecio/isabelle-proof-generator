{"file_name": "/home/qj213/afp-2021-10-22/thys/Polynomial_Factorization/Gauss_Lemma.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Polynomial_Factorization", "problem_names": ["lemma primitive_part_alt_def:\n  \"primitive_part p = sdiv_poly p (content p)\"", "lemma rat_to_normalized_int_poly_code[code]:\n  \"rat_to_normalized_int_poly p = (if p = 0 then (1,0) else case rat_to_int_poly p of (s,q)\n    \\<Rightarrow> let c = content q in (of_int c / of_int s, sdiv_poly q c))\"", "lemma common_denom: assumes cd: \"common_denom xs = (dd,ys)\"\n  shows \"xs = map (\\<lambda> i. of_int i / of_int dd) ys\" \"dd > 0\"\n  \"\\<And>x. x \\<in> set xs \\<Longrightarrow> rat_of_int (case quotient_of x of (n, x) \\<Rightarrow> n * dd div x) / rat_of_int dd = x\"", "lemma rat_to_int_poly: assumes \"rat_to_int_poly p = (d,q)\"\n  shows \"p = smult (inverse (of_int d)) (map_poly of_int q)\" \"d > 0\"", "lemma content_ge_0_int: \"content p \\<ge> (0 :: int)\"", "lemma abs_content_int[simp]: fixes p :: \"int poly\"\n  shows \"abs (content p) = content p\"", "lemma content_smult_int: fixes p :: \"int poly\" \n  shows \"content (smult a p) = abs a * content p\"", "lemma normalize_non_0_smult: \"\\<exists> a. (a :: 'a :: semiring_gcd) \\<noteq> 0 \\<and> smult a (primitive_part p) = p\"", "lemma rat_to_normalized_int_poly: assumes \"rat_to_normalized_int_poly p = (d,q)\"\n  shows \"p = smult d (map_poly of_int q)\" \"d > 0\" \"p \\<noteq> 0 \\<Longrightarrow> content q = 1\" \"degree q = degree p\"", "lemma content_dvd_1:\n  \"content g = 1\" if \"content f = (1 :: 'a :: semiring_gcd)\" \"g dvd f\"", "lemma dvd_smult_int: fixes c :: int assumes c: \"c \\<noteq> 0\"\n  and dvd: \"q dvd (smult c p)\"\n  shows \"primitive_part q dvd p\"", "lemma irreducible\\<^sub>d_primitive_part:\n  fixes p :: \"int poly\" (* can be relaxed but primitive_part_mult has bad type constraint *)\n  shows \"irreducible\\<^sub>d (primitive_part p) \\<longleftrightarrow> irreducible\\<^sub>d p\" (is \"?l \\<longleftrightarrow> ?r\")", "lemma irreducible\\<^sub>d_smult_int:\n  fixes c :: int assumes c: \"c \\<noteq> 0\"\n  shows \"irreducible\\<^sub>d (smult c p) = irreducible\\<^sub>d p\" (is \"?l = ?r\")", "lemma irreducible\\<^sub>d_as_irreducible:\n  fixes p :: \"int poly\"\n  shows \"irreducible\\<^sub>d p \\<longleftrightarrow> irreducible (primitive_part p)\"", "lemma rat_to_int_factor_content_1: fixes p :: \"int poly\" \n  assumes cp: \"content p = 1\"\n  and pgh: \"map_poly rat_of_int p = g * h\"\n  and g: \"rat_to_normalized_int_poly g = (r,rg)\"\n  and h: \"rat_to_normalized_int_poly h = (s,sh)\"\n  and p: \"p \\<noteq> 0\"\n  shows \"p = rg * sh\"", "lemma rat_to_int_factor_explicit: fixes p :: \"int poly\" \n  assumes pgh: \"map_poly rat_of_int p = g * h\"\n  and g: \"rat_to_normalized_int_poly g = (r,rg)\"\n  shows \"\\<exists> r. p = rg * smult (content p) r\"", "lemma rat_to_int_factor: fixes p :: \"int poly\" \n  assumes pgh: \"map_poly rat_of_int p = g * h\"\n  shows \"\\<exists> g' h'. p = g' * h' \\<and> degree g' = degree g \\<and> degree h' = degree h\"", "lemma rat_to_int_factor_normalized_int_poly: fixes p :: \"rat poly\" \n  assumes pgh: \"p = g * h\"\n  and p: \"rat_to_normalized_int_poly p = (i,ip)\"\n  shows \"\\<exists> g' h'. ip = g' * h' \\<and> degree g' = degree g\"", "lemma irreducible_smult [simp]:\n  fixes c :: \"'a :: field\"\n  shows \"irreducible (smult c p) \\<longleftrightarrow> irreducible p \\<and> c \\<noteq> 0\"", "theorem irreducible\\<^sub>d_int_rat: fixes p :: \"int poly\" \n  assumes p: \"irreducible\\<^sub>d p\"\n  shows \"irreducible\\<^sub>d (map_poly rat_of_int p)\"", "lemma dvd_content_dvd: assumes dvd: \"content f dvd content g\" \"primitive_part f dvd primitive_part g\"\n  shows \"f dvd g\"", "lemma sdiv_poly_smult: \"c \\<noteq> 0 \\<Longrightarrow> sdiv_poly (smult c f) c = f\"", "lemma primitive_part_smult_int: fixes f :: \"int poly\" shows\n  \"primitive_part (smult d f) = smult (sgn d) (primitive_part f)\"", "lemma gcd_smult_left: assumes \"c \\<noteq> 0\"\n  shows \"gcd (smult c f) g = gcd f (g :: 'b :: {field_gcd} poly)\"", "lemma gcd_smult_right: \"c \\<noteq> 0 \\<Longrightarrow> gcd f (smult c g) = gcd f (g :: 'b :: {field_gcd} poly)\"", "lemma gcd_rat_to_gcd_int: \"gcd (of_int_poly f :: rat poly) (of_int_poly g) = \n  smult (inverse (of_int (lead_coeff (gcd f g)))) (of_int_poly (gcd f g))\""], "translations": [["", "lemma primitive_part_alt_def:\n  \"primitive_part p = sdiv_poly p (content p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. primitive_part p = sdiv_poly p (content p)", "by (simp add: primitive_part_def sdiv_poly_def)"], ["", "definition common_denom :: \"rat list \\<Rightarrow> int \\<times> int list\" where\n  \"common_denom xs \\<equiv> let \n     nds = map quotient_of xs;\n     denom = list_lcm (map snd nds);\n     ints = map (\\<lambda> (n,d). n * denom div d) nds\n   in (denom, ints)\""], ["", "definition rat_to_int_poly :: \"rat poly \\<Rightarrow> int \\<times> int poly\" where\n  \"rat_to_int_poly p \\<equiv> let\n     ais = coeffs p;\n     d = fst (common_denom ais)\n   in (d, map_poly (\\<lambda> x. case quotient_of x of (p,q) \\<Rightarrow> p * d div q) p)\""], ["", "definition rat_to_normalized_int_poly :: \"rat poly \\<Rightarrow> rat \\<times> int poly\" where\n  \"rat_to_normalized_int_poly p \\<equiv> if p = 0 then (1,0) else case rat_to_int_poly p of (s,q)\n    \\<Rightarrow> (of_int (content q) / of_int s, primitive_part q)\""], ["", "lemma rat_to_normalized_int_poly_code[code]:\n  \"rat_to_normalized_int_poly p = (if p = 0 then (1,0) else case rat_to_int_poly p of (s,q)\n    \\<Rightarrow> let c = content q in (of_int c / of_int s, sdiv_poly q c))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_to_normalized_int_poly p =\n    (if p = 0 then (1, 0)\n     else case rat_to_int_poly p of\n          (s, q) \\<Rightarrow>\n            let c = content q\n            in (rat_of_int c / rat_of_int s, sdiv_poly q c))", "unfolding Let_def rat_to_normalized_int_poly_def primitive_part_alt_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if p = 0 then (1, 0)\n     else case rat_to_int_poly p of\n          (s, q) \\<Rightarrow>\n            (rat_of_int (content q) / rat_of_int s,\n             sdiv_poly q (content q))) =\n    (if p = 0 then (1, 0)\n     else case rat_to_int_poly p of\n          (s, q) \\<Rightarrow>\n            (rat_of_int (content q) / rat_of_int s,\n             sdiv_poly q (content q)))", ".."], ["", "lemma common_denom: assumes cd: \"common_denom xs = (dd,ys)\"\n  shows \"xs = map (\\<lambda> i. of_int i / of_int dd) ys\" \"dd > 0\"\n  \"\\<And>x. x \\<in> set xs \\<Longrightarrow> rat_of_int (case quotient_of x of (n, x) \\<Rightarrow> n * dd div x) / rat_of_int dd = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs = map (\\<lambda>i. rat_of_int i / rat_of_int dd) ys &&&\n    0 < dd &&&\n    (\\<And>x.\n        x \\<in> set xs \\<Longrightarrow>\n        rat_of_int\n         (case quotient_of x of (n, x) \\<Rightarrow> n * dd div x) /\n        rat_of_int dd =\n        x)", "proof -"], ["proof (state)\ngoal (3 subgoals):\n 1. xs = map (\\<lambda>i. rat_of_int i / rat_of_int dd) ys\n 2. 0 < dd\n 3. \\<And>x.\n       x \\<in> set xs \\<Longrightarrow>\n       rat_of_int\n        (case quotient_of x of (n, x) \\<Rightarrow> n * dd div x) /\n       rat_of_int dd =\n       x", "let ?nds = \"map quotient_of xs\""], ["proof (state)\ngoal (3 subgoals):\n 1. xs = map (\\<lambda>i. rat_of_int i / rat_of_int dd) ys\n 2. 0 < dd\n 3. \\<And>x.\n       x \\<in> set xs \\<Longrightarrow>\n       rat_of_int\n        (case quotient_of x of (n, x) \\<Rightarrow> n * dd div x) /\n       rat_of_int dd =\n       x", "define nds where \"nds = ?nds\""], ["proof (state)\nthis:\n  nds = map quotient_of xs\n\ngoal (3 subgoals):\n 1. xs = map (\\<lambda>i. rat_of_int i / rat_of_int dd) ys\n 2. 0 < dd\n 3. \\<And>x.\n       x \\<in> set xs \\<Longrightarrow>\n       rat_of_int\n        (case quotient_of x of (n, x) \\<Rightarrow> n * dd div x) /\n       rat_of_int dd =\n       x", "let ?denom = \"list_lcm (map snd nds)\""], ["proof (state)\ngoal (3 subgoals):\n 1. xs = map (\\<lambda>i. rat_of_int i / rat_of_int dd) ys\n 2. 0 < dd\n 3. \\<And>x.\n       x \\<in> set xs \\<Longrightarrow>\n       rat_of_int\n        (case quotient_of x of (n, x) \\<Rightarrow> n * dd div x) /\n       rat_of_int dd =\n       x", "let ?ints = \"map (\\<lambda> (n,d). n * dd div d) nds\""], ["proof (state)\ngoal (3 subgoals):\n 1. xs = map (\\<lambda>i. rat_of_int i / rat_of_int dd) ys\n 2. 0 < dd\n 3. \\<And>x.\n       x \\<in> set xs \\<Longrightarrow>\n       rat_of_int\n        (case quotient_of x of (n, x) \\<Rightarrow> n * dd div x) /\n       rat_of_int dd =\n       x", "from cd[unfolded common_denom_def Let_def]"], ["proof (chain)\npicking this:\n  (lcm_list (map snd (map quotient_of xs)),\n   map (\\<lambda>(n, y). n * lcm_list (map snd (map quotient_of xs)) div y)\n    (map quotient_of xs)) =\n  (dd, ys)", "have dd: \"dd = ?denom\" and ys: \"ys = ?ints\""], ["proof (prove)\nusing this:\n  (lcm_list (map snd (map quotient_of xs)),\n   map (\\<lambda>(n, y). n * lcm_list (map snd (map quotient_of xs)) div y)\n    (map quotient_of xs)) =\n  (dd, ys)\n\ngoal (1 subgoal):\n 1. dd = lcm_list (map snd nds) &&&\n    ys = map (\\<lambda>(n, d). n * dd div d) nds", "unfolding nds_def"], ["proof (prove)\nusing this:\n  (lcm_list (map snd (map quotient_of xs)),\n   map (\\<lambda>(n, y). n * lcm_list (map snd (map quotient_of xs)) div y)\n    (map quotient_of xs)) =\n  (dd, ys)\n\ngoal (1 subgoal):\n 1. dd = lcm_list (map snd (map quotient_of xs)) &&&\n    ys = map (\\<lambda>(n, d). n * dd div d) (map quotient_of xs)", "by auto"], ["proof (state)\nthis:\n  dd = lcm_list (map snd nds)\n  ys = map (\\<lambda>(n, d). n * dd div d) nds\n\ngoal (3 subgoals):\n 1. xs = map (\\<lambda>i. rat_of_int i / rat_of_int dd) ys\n 2. 0 < dd\n 3. \\<And>x.\n       x \\<in> set xs \\<Longrightarrow>\n       rat_of_int\n        (case quotient_of x of (n, x) \\<Rightarrow> n * dd div x) /\n       rat_of_int dd =\n       x", "show dd0: \"dd > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < dd", "unfolding dd"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < lcm_list (map snd nds)", "by (intro list_lcm_pos(3), auto simp: nds_def quotient_of_nonzero)"], ["proof (state)\nthis:\n  0 < dd\n\ngoal (2 subgoals):\n 1. xs = map (\\<lambda>i. rat_of_int i / rat_of_int dd) ys\n 2. \\<And>x.\n       x \\<in> set xs \\<Longrightarrow>\n       rat_of_int\n        (case quotient_of x of (n, x) \\<Rightarrow> n * dd div x) /\n       rat_of_int dd =\n       x", "{"], ["proof (state)\nthis:\n  0 < dd\n\ngoal (2 subgoals):\n 1. xs = map (\\<lambda>i. rat_of_int i / rat_of_int dd) ys\n 2. \\<And>x.\n       x \\<in> set xs \\<Longrightarrow>\n       rat_of_int\n        (case quotient_of x of (n, x) \\<Rightarrow> n * dd div x) /\n       rat_of_int dd =\n       x", "fix x"], ["proof (state)\ngoal (2 subgoals):\n 1. xs = map (\\<lambda>i. rat_of_int i / rat_of_int dd) ys\n 2. \\<And>x.\n       x \\<in> set xs \\<Longrightarrow>\n       rat_of_int\n        (case quotient_of x of (n, x) \\<Rightarrow> n * dd div x) /\n       rat_of_int dd =\n       x", "assume x: \"x \\<in> set xs\""], ["proof (state)\nthis:\n  x \\<in> set xs\n\ngoal (2 subgoals):\n 1. xs = map (\\<lambda>i. rat_of_int i / rat_of_int dd) ys\n 2. \\<And>x.\n       x \\<in> set xs \\<Longrightarrow>\n       rat_of_int\n        (case quotient_of x of (n, x) \\<Rightarrow> n * dd div x) /\n       rat_of_int dd =\n       x", "obtain p q where quot: \"quotient_of x = (p,q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>p q.\n        quotient_of x = (p, q) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  quotient_of x = (p, q)\n\ngoal (2 subgoals):\n 1. xs = map (\\<lambda>i. rat_of_int i / rat_of_int dd) ys\n 2. \\<And>x.\n       x \\<in> set xs \\<Longrightarrow>\n       rat_of_int\n        (case quotient_of x of (n, x) \\<Rightarrow> n * dd div x) /\n       rat_of_int dd =\n       x", "from x"], ["proof (chain)\npicking this:\n  x \\<in> set xs", "have \"(p,q) \\<in> set nds\""], ["proof (prove)\nusing this:\n  x \\<in> set xs\n\ngoal (1 subgoal):\n 1. (p, q) \\<in> set nds", "unfolding nds_def"], ["proof (prove)\nusing this:\n  x \\<in> set xs\n\ngoal (1 subgoal):\n 1. (p, q) \\<in> set (map quotient_of xs)", "using quot"], ["proof (prove)\nusing this:\n  x \\<in> set xs\n  quotient_of x = (p, q)\n\ngoal (1 subgoal):\n 1. (p, q) \\<in> set (map quotient_of xs)", "by force"], ["proof (state)\nthis:\n  (p, q) \\<in> set nds\n\ngoal (2 subgoals):\n 1. xs = map (\\<lambda>i. rat_of_int i / rat_of_int dd) ys\n 2. \\<And>x.\n       x \\<in> set xs \\<Longrightarrow>\n       rat_of_int\n        (case quotient_of x of (n, x) \\<Rightarrow> n * dd div x) /\n       rat_of_int dd =\n       x", "hence \"q \\<in> set (map snd nds)\""], ["proof (prove)\nusing this:\n  (p, q) \\<in> set nds\n\ngoal (1 subgoal):\n 1. q \\<in> set (map snd nds)", "by force"], ["proof (state)\nthis:\n  q \\<in> set (map snd nds)\n\ngoal (2 subgoals):\n 1. xs = map (\\<lambda>i. rat_of_int i / rat_of_int dd) ys\n 2. \\<And>x.\n       x \\<in> set xs \\<Longrightarrow>\n       rat_of_int\n        (case quotient_of x of (n, x) \\<Rightarrow> n * dd div x) /\n       rat_of_int dd =\n       x", "from list_lcm[OF this]"], ["proof (chain)\npicking this:\n  q dvd lcm_list (map snd nds)", "have q: \"q dvd dd\""], ["proof (prove)\nusing this:\n  q dvd lcm_list (map snd nds)\n\ngoal (1 subgoal):\n 1. q dvd dd", "unfolding dd"], ["proof (prove)\nusing this:\n  q dvd lcm_list (map snd nds)\n\ngoal (1 subgoal):\n 1. q dvd lcm_list (map snd nds)", "."], ["proof (state)\nthis:\n  q dvd dd\n\ngoal (2 subgoals):\n 1. xs = map (\\<lambda>i. rat_of_int i / rat_of_int dd) ys\n 2. \\<And>x.\n       x \\<in> set xs \\<Longrightarrow>\n       rat_of_int\n        (case quotient_of x of (n, x) \\<Rightarrow> n * dd div x) /\n       rat_of_int dd =\n       x", "show \"rat_of_int (case quotient_of x of (n, x) \\<Rightarrow> n * dd div x) / rat_of_int dd = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_of_int (case quotient_of x of (n, x) \\<Rightarrow> n * dd div x) /\n    rat_of_int dd =\n    x", "unfolding quot split"], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_of_int (p * dd div q) / rat_of_int dd = x", "unfolding quotient_of_div[OF quot]"], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_of_int (p * dd div q) / rat_of_int dd = rat_of_int p / rat_of_int q", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. rat_of_int (p * dd div q) / rat_of_int dd = rat_of_int p / rat_of_int q", "have f1: \"q * (dd div q) = dd\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q * (dd div q) = dd", "using dvd_mult_div_cancel q"], ["proof (prove)\nusing this:\n  ?a dvd ?b \\<Longrightarrow> ?a * (?b div ?a) = ?b\n  q dvd dd\n\ngoal (1 subgoal):\n 1. q * (dd div q) = dd", "by blast"], ["proof (state)\nthis:\n  q * (dd div q) = dd\n\ngoal (1 subgoal):\n 1. rat_of_int (p * dd div q) / rat_of_int dd = rat_of_int p / rat_of_int q", "have \"rat_of_int (dd div q) \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_of_int (dd div q) \\<noteq> 0", "using dd0 dvd_mult_div_cancel q"], ["proof (prove)\nusing this:\n  0 < dd\n  ?a dvd ?b \\<Longrightarrow> ?a * (?b div ?a) = ?b\n  q dvd dd\n\ngoal (1 subgoal):\n 1. rat_of_int (dd div q) \\<noteq> 0", "by fastforce"], ["proof (state)\nthis:\n  rat_of_int (dd div q) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. rat_of_int (p * dd div q) / rat_of_int dd = rat_of_int p / rat_of_int q", "thus \"rat_of_int (p * dd div q) / rat_of_int dd = rat_of_int p / rat_of_int q\""], ["proof (prove)\nusing this:\n  rat_of_int (dd div q) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. rat_of_int (p * dd div q) / rat_of_int dd = rat_of_int p / rat_of_int q", "using f1"], ["proof (prove)\nusing this:\n  rat_of_int (dd div q) \\<noteq> 0\n  q * (dd div q) = dd\n\ngoal (1 subgoal):\n 1. rat_of_int (p * dd div q) / rat_of_int dd = rat_of_int p / rat_of_int q", "by (metis (no_types) div_mult_swap mult_divide_mult_cancel_right of_int_mult q)"], ["proof (state)\nthis:\n  rat_of_int (p * dd div q) / rat_of_int dd = rat_of_int p / rat_of_int q\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  rat_of_int (case quotient_of x of (n, x) \\<Rightarrow> n * dd div x) /\n  rat_of_int dd =\n  x\n\ngoal (1 subgoal):\n 1. xs = map (\\<lambda>i. rat_of_int i / rat_of_int dd) ys", "}"], ["proof (state)\nthis:\n  ?x2 \\<in> set xs \\<Longrightarrow>\n  rat_of_int (case quotient_of ?x2 of (n, x) \\<Rightarrow> n * dd div x) /\n  rat_of_int dd =\n  ?x2\n\ngoal (1 subgoal):\n 1. xs = map (\\<lambda>i. rat_of_int i / rat_of_int dd) ys", "note main = this"], ["proof (state)\nthis:\n  ?x2 \\<in> set xs \\<Longrightarrow>\n  rat_of_int (case quotient_of ?x2 of (n, x) \\<Rightarrow> n * dd div x) /\n  rat_of_int dd =\n  ?x2\n\ngoal (1 subgoal):\n 1. xs = map (\\<lambda>i. rat_of_int i / rat_of_int dd) ys", "show \"xs = map (\\<lambda> i. of_int i / of_int dd) ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs = map (\\<lambda>i. rat_of_int i / rat_of_int dd) ys", "unfolding ys map_map o_def nds_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. xs =\n    map (\\<lambda>x.\n            rat_of_int\n             (case quotient_of x of (n, x) \\<Rightarrow> n * dd div x) /\n            rat_of_int dd)\n     xs", "by (rule sym, rule map_idI, rule main)"], ["proof (state)\nthis:\n  xs = map (\\<lambda>i. rat_of_int i / rat_of_int dd) ys\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rat_to_int_poly: assumes \"rat_to_int_poly p = (d,q)\"\n  shows \"p = smult (inverse (of_int d)) (map_poly of_int q)\" \"d > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p = smult (inverse (rat_of_int d)) (of_int_poly q) &&& 0 < d", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. p = smult (inverse (rat_of_int d)) (of_int_poly q)\n 2. 0 < d", "let ?f = \"\\<lambda> x. case quotient_of x of (pa, x) \\<Rightarrow> pa * d div x\""], ["proof (state)\ngoal (2 subgoals):\n 1. p = smult (inverse (rat_of_int d)) (of_int_poly q)\n 2. 0 < d", "define f where \"f = ?f\""], ["proof (state)\nthis:\n  f = (\\<lambda>x. case quotient_of x of (pa, x) \\<Rightarrow> pa * d div x)\n\ngoal (2 subgoals):\n 1. p = smult (inverse (rat_of_int d)) (of_int_poly q)\n 2. 0 < d", "from assms[unfolded rat_to_int_poly_def Let_def]"], ["proof (chain)\npicking this:\n  (fst (common_denom (coeffs p)),\n   map_poly\n    (\\<lambda>x.\n        case quotient_of x of\n        (pa, x) \\<Rightarrow> pa * fst (common_denom (coeffs p)) div x)\n    p) =\n  (d, q)", "obtain xs where cd: \"common_denom (coeffs p) = (d,xs)\"\n    and q: \"q = map_poly f p\""], ["proof (prove)\nusing this:\n  (fst (common_denom (coeffs p)),\n   map_poly\n    (\\<lambda>x.\n        case quotient_of x of\n        (pa, x) \\<Rightarrow> pa * fst (common_denom (coeffs p)) div x)\n    p) =\n  (d, q)\n\ngoal (1 subgoal):\n 1. (\\<And>xs.\n        \\<lbrakk>common_denom (coeffs p) = (d, xs);\n         q = map_poly f p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding f_def"], ["proof (prove)\nusing this:\n  (fst (common_denom (coeffs p)),\n   map_poly\n    (\\<lambda>x.\n        case quotient_of x of\n        (pa, x) \\<Rightarrow> pa * fst (common_denom (coeffs p)) div x)\n    p) =\n  (d, q)\n\ngoal (1 subgoal):\n 1. (\\<And>xs.\n        \\<lbrakk>common_denom (coeffs p) = (d, xs);\n         q =\n         map_poly\n          (\\<lambda>x.\n              case quotient_of x of (pa, x) \\<Rightarrow> pa * d div x)\n          p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases \"common_denom (coeffs p)\", auto)"], ["proof (state)\nthis:\n  common_denom (coeffs p) = (d, xs)\n  q = map_poly f p\n\ngoal (2 subgoals):\n 1. p = smult (inverse (rat_of_int d)) (of_int_poly q)\n 2. 0 < d", "from common_denom[OF cd]"], ["proof (chain)\npicking this:\n  coeffs p = map (\\<lambda>i. rat_of_int i / rat_of_int d) xs\n  0 < d\n  ?x \\<in> set (coeffs p) \\<Longrightarrow>\n  rat_of_int (case quotient_of ?x of (n, x) \\<Rightarrow> n * d div x) /\n  rat_of_int d =\n  ?x", "have d: \"d > 0\"  and \n    id: \"\\<And> x. x \\<in> set (coeffs p) \\<Longrightarrow> rat_of_int (f x) / rat_of_int d = x\""], ["proof (prove)\nusing this:\n  coeffs p = map (\\<lambda>i. rat_of_int i / rat_of_int d) xs\n  0 < d\n  ?x \\<in> set (coeffs p) \\<Longrightarrow>\n  rat_of_int (case quotient_of ?x of (n, x) \\<Rightarrow> n * d div x) /\n  rat_of_int d =\n  ?x\n\ngoal (1 subgoal):\n 1. 0 < d &&&\n    (\\<And>x.\n        x \\<in> set (coeffs p) \\<Longrightarrow>\n        rat_of_int (f x) / rat_of_int d = x)", "unfolding f_def"], ["proof (prove)\nusing this:\n  coeffs p = map (\\<lambda>i. rat_of_int i / rat_of_int d) xs\n  0 < d\n  ?x \\<in> set (coeffs p) \\<Longrightarrow>\n  rat_of_int (case quotient_of ?x of (n, x) \\<Rightarrow> n * d div x) /\n  rat_of_int d =\n  ?x\n\ngoal (1 subgoal):\n 1. 0 < d &&&\n    (\\<And>x.\n        x \\<in> set (coeffs p) \\<Longrightarrow>\n        rat_of_int\n         (case quotient_of x of (pa, x) \\<Rightarrow> pa * d div x) /\n        rat_of_int d =\n        x)", "by auto"], ["proof (state)\nthis:\n  0 < d\n  ?x \\<in> set (coeffs p) \\<Longrightarrow>\n  rat_of_int (f ?x) / rat_of_int d = ?x\n\ngoal (2 subgoals):\n 1. p = smult (inverse (rat_of_int d)) (of_int_poly q)\n 2. 0 < d", "have f0: \"f 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f 0 = 0", "unfolding f_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case quotient_of 0 of (pa, x) \\<Rightarrow> pa * d div x) = 0", "by auto"], ["proof (state)\nthis:\n  f 0 = 0\n\ngoal (2 subgoals):\n 1. p = smult (inverse (rat_of_int d)) (of_int_poly q)\n 2. 0 < d", "have id: \"rat_of_int (f (coeff p n)) / rat_of_int d = coeff p n\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_of_int (f (coeff p n)) / rat_of_int d = coeff p n", "using id[of \"coeff p n\"] f0 range_coeff"], ["proof (prove)\nusing this:\n  coeff p n \\<in> set (coeffs p) \\<Longrightarrow>\n  rat_of_int (f (coeff p n)) / rat_of_int d = coeff p n\n  f 0 = 0\n  range (coeff ?p) = insert (0::?'a) (set (coeffs ?p))\n\ngoal (1 subgoal):\n 1. rat_of_int (f (coeff p n)) / rat_of_int d = coeff p n", "by (cases \"coeff p n = 0\", auto)"], ["proof (state)\nthis:\n  rat_of_int (f (coeff p ?n)) / rat_of_int d = coeff p ?n\n\ngoal (2 subgoals):\n 1. p = smult (inverse (rat_of_int d)) (of_int_poly q)\n 2. 0 < d", "show \"d > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < d", "by fact"], ["proof (state)\nthis:\n  0 < d\n\ngoal (1 subgoal):\n 1. p = smult (inverse (rat_of_int d)) (of_int_poly q)", "show \"p = smult (inverse (of_int d)) (map_poly of_int q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p = smult (inverse (rat_of_int d)) (of_int_poly q)", "unfolding q smult_as_map_poly"], ["proof (prove)\ngoal (1 subgoal):\n 1. p = map_poly ((*) (inverse (rat_of_int d))) (of_int_poly (map_poly f p))", "using id f0"], ["proof (prove)\nusing this:\n  rat_of_int (f (coeff p ?n)) / rat_of_int d = coeff p ?n\n  f 0 = 0\n\ngoal (1 subgoal):\n 1. p = map_poly ((*) (inverse (rat_of_int d))) (of_int_poly (map_poly f p))", "by (intro poly_eqI, auto simp: field_simps coeff_map_poly)"], ["proof (state)\nthis:\n  p = smult (inverse (rat_of_int d)) (of_int_poly q)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma content_ge_0_int: \"content p \\<ge> (0 :: int)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> content p", "unfolding content_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> gcd_list (coeffs p)", "by (cases \"coeffs p\", auto)"], ["", "lemma abs_content_int[simp]: fixes p :: \"int poly\"\n  shows \"abs (content p) = content p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>content p\\<bar> = content p", "using content_ge_0_int[of p]"], ["proof (prove)\nusing this:\n  0 \\<le> content p\n\ngoal (1 subgoal):\n 1. \\<bar>content p\\<bar> = content p", "by auto"], ["", "lemma content_smult_int: fixes p :: \"int poly\" \n  shows \"content (smult a p) = abs a * content p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. content (smult a p) = \\<bar>a\\<bar> * content p", "by simp"], ["", "lemma normalize_non_0_smult: \"\\<exists> a. (a :: 'a :: semiring_gcd) \\<noteq> 0 \\<and> smult a (primitive_part p) = p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>a. a \\<noteq> (0::'a) \\<and> smult a (primitive_part p) = p", "by (cases \"p = 0\", rule exI[of _ 1], simp, rule exI[of _ \"content p\"], auto)"], ["", "lemma rat_to_normalized_int_poly: assumes \"rat_to_normalized_int_poly p = (d,q)\"\n  shows \"p = smult d (map_poly of_int q)\" \"d > 0\" \"p \\<noteq> 0 \\<Longrightarrow> content q = 1\" \"degree q = degree p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (p = smult d (of_int_poly q) &&& 0 < d) &&&\n    (p \\<noteq> 0 \\<Longrightarrow> content q = 1) &&& degree q = degree p", "proof -"], ["proof (state)\ngoal (4 subgoals):\n 1. p = smult d (of_int_poly q)\n 2. 0 < d\n 3. p \\<noteq> 0 \\<Longrightarrow> content q = 1\n 4. degree q = degree p", "have \"p = smult d (map_poly of_int q) \\<and> d > 0 \\<and> (p \\<noteq> 0 \\<longrightarrow> content q = 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p = smult d (of_int_poly q) \\<and>\n    0 < d \\<and> (p \\<noteq> 0 \\<longrightarrow> content q = 1)", "proof (cases \"p = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow>\n    p = smult d (of_int_poly q) \\<and>\n    0 < d \\<and> (p \\<noteq> 0 \\<longrightarrow> content q = 1)\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    p = smult d (of_int_poly q) \\<and>\n    0 < d \\<and> (p \\<noteq> 0 \\<longrightarrow> content q = 1)", "case True"], ["proof (state)\nthis:\n  p = 0\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow>\n    p = smult d (of_int_poly q) \\<and>\n    0 < d \\<and> (p \\<noteq> 0 \\<longrightarrow> content q = 1)\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    p = smult d (of_int_poly q) \\<and>\n    0 < d \\<and> (p \\<noteq> 0 \\<longrightarrow> content q = 1)", "thus ?thesis"], ["proof (prove)\nusing this:\n  p = 0\n\ngoal (1 subgoal):\n 1. p = smult d (of_int_poly q) \\<and>\n    0 < d \\<and> (p \\<noteq> 0 \\<longrightarrow> content q = 1)", "using assms"], ["proof (prove)\nusing this:\n  p = 0\n  rat_to_normalized_int_poly p = (d, q)\n\ngoal (1 subgoal):\n 1. p = smult d (of_int_poly q) \\<and>\n    0 < d \\<and> (p \\<noteq> 0 \\<longrightarrow> content q = 1)", "unfolding rat_to_normalized_int_poly_def"], ["proof (prove)\nusing this:\n  p = 0\n  (if p = 0 then (1, 0)\n   else case rat_to_int_poly p of\n        (s, q) \\<Rightarrow>\n          (rat_of_int (content q) / rat_of_int s, primitive_part q)) =\n  (d, q)\n\ngoal (1 subgoal):\n 1. p = smult d (of_int_poly q) \\<and>\n    0 < d \\<and> (p \\<noteq> 0 \\<longrightarrow> content q = 1)", "by (auto simp: eval_poly_def)"], ["proof (state)\nthis:\n  p = smult d (of_int_poly q) \\<and>\n  0 < d \\<and> (p \\<noteq> 0 \\<longrightarrow> content q = 1)\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    p = smult d (of_int_poly q) \\<and>\n    0 < d \\<and> (p \\<noteq> 0 \\<longrightarrow> content q = 1)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    p = smult d (of_int_poly q) \\<and>\n    0 < d \\<and> (p \\<noteq> 0 \\<longrightarrow> content q = 1)", "case False"], ["proof (state)\nthis:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    p = smult d (of_int_poly q) \\<and>\n    0 < d \\<and> (p \\<noteq> 0 \\<longrightarrow> content q = 1)", "hence p0: \"p \\<noteq> 0\""], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    p = smult d (of_int_poly q) \\<and>\n    0 < d \\<and> (p \\<noteq> 0 \\<longrightarrow> content q = 1)", "obtain s r where id: \"rat_to_int_poly p = (s,r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>s r.\n        rat_to_int_poly p = (s, r) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  rat_to_int_poly p = (s, r)\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    p = smult d (of_int_poly q) \\<and>\n    0 < d \\<and> (p \\<noteq> 0 \\<longrightarrow> content q = 1)", "let ?cr = \"rat_of_int (content r)\""], ["proof (state)\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    p = smult d (of_int_poly q) \\<and>\n    0 < d \\<and> (p \\<noteq> 0 \\<longrightarrow> content q = 1)", "let ?s = \"rat_of_int s\""], ["proof (state)\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    p = smult d (of_int_poly q) \\<and>\n    0 < d \\<and> (p \\<noteq> 0 \\<longrightarrow> content q = 1)", "let ?q = \"map_poly rat_of_int q\""], ["proof (state)\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    p = smult d (of_int_poly q) \\<and>\n    0 < d \\<and> (p \\<noteq> 0 \\<longrightarrow> content q = 1)", "from rat_to_int_poly[OF id]"], ["proof (chain)\npicking this:\n  p = smult (inverse (rat_of_int s)) (of_int_poly r)\n  0 < s", "have p: \"p = smult (inverse ?s) (map_poly of_int r)\"\n    and s: \"s > 0\""], ["proof (prove)\nusing this:\n  p = smult (inverse (rat_of_int s)) (of_int_poly r)\n  0 < s\n\ngoal (1 subgoal):\n 1. p = smult (inverse (rat_of_int s)) (of_int_poly r) &&& 0 < s", "by auto"], ["proof (state)\nthis:\n  p = smult (inverse (rat_of_int s)) (of_int_poly r)\n  0 < s\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    p = smult d (of_int_poly q) \\<and>\n    0 < d \\<and> (p \\<noteq> 0 \\<longrightarrow> content q = 1)", "let ?q = \"map_poly rat_of_int q\""], ["proof (state)\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    p = smult d (of_int_poly q) \\<and>\n    0 < d \\<and> (p \\<noteq> 0 \\<longrightarrow> content q = 1)", "from p0 assms[unfolded rat_to_normalized_int_poly_def id split]"], ["proof (chain)\npicking this:\n  p \\<noteq> 0\n  (if p = 0 then (1, 0)\n   else (rat_of_int (content r) / rat_of_int s, primitive_part r)) =\n  (d, q)", "have d: \"d = ?cr / ?s\" and q: \"q = primitive_part r\""], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  (if p = 0 then (1, 0)\n   else (rat_of_int (content r) / rat_of_int s, primitive_part r)) =\n  (d, q)\n\ngoal (1 subgoal):\n 1. d = rat_of_int (content r) / rat_of_int s &&& q = primitive_part r", "by auto"], ["proof (state)\nthis:\n  d = rat_of_int (content r) / rat_of_int s\n  q = primitive_part r\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    p = smult d (of_int_poly q) \\<and>\n    0 < d \\<and> (p \\<noteq> 0 \\<longrightarrow> content q = 1)", "from content_times_primitive_part[of r, folded q]"], ["proof (chain)\npicking this:\n  smult (content r) q = r", "have qr: \"smult (content r) q = r\""], ["proof (prove)\nusing this:\n  smult (content r) q = r\n\ngoal (1 subgoal):\n 1. smult (content r) q = r", "."], ["proof (state)\nthis:\n  smult (content r) q = r\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    p = smult d (of_int_poly q) \\<and>\n    0 < d \\<and> (p \\<noteq> 0 \\<longrightarrow> content q = 1)", "have \"smult d ?q = smult (?cr / ?s) ?q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. smult d (of_int_poly q) =\n    smult (rat_of_int (content r) / rat_of_int s) (of_int_poly q)", "unfolding d"], ["proof (prove)\ngoal (1 subgoal):\n 1. smult (rat_of_int (content r) / rat_of_int s) (of_int_poly q) =\n    smult (rat_of_int (content r) / rat_of_int s) (of_int_poly q)", "by simp"], ["proof (state)\nthis:\n  smult d (of_int_poly q) =\n  smult (rat_of_int (content r) / rat_of_int s) (of_int_poly q)\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    p = smult d (of_int_poly q) \\<and>\n    0 < d \\<and> (p \\<noteq> 0 \\<longrightarrow> content q = 1)", "also"], ["proof (state)\nthis:\n  smult d (of_int_poly q) =\n  smult (rat_of_int (content r) / rat_of_int s) (of_int_poly q)\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    p = smult d (of_int_poly q) \\<and>\n    0 < d \\<and> (p \\<noteq> 0 \\<longrightarrow> content q = 1)", "have \"?cr / ?s = ?cr * inverse ?s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_of_int (content r) / rat_of_int s =\n    rat_of_int (content r) * inverse (rat_of_int s)", "by (rule divide_inverse)"], ["proof (state)\nthis:\n  rat_of_int (content r) / rat_of_int s =\n  rat_of_int (content r) * inverse (rat_of_int s)\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    p = smult d (of_int_poly q) \\<and>\n    0 < d \\<and> (p \\<noteq> 0 \\<longrightarrow> content q = 1)", "also"], ["proof (state)\nthis:\n  rat_of_int (content r) / rat_of_int s =\n  rat_of_int (content r) * inverse (rat_of_int s)\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    p = smult d (of_int_poly q) \\<and>\n    0 < d \\<and> (p \\<noteq> 0 \\<longrightarrow> content q = 1)", "have \"\\<dots> = inverse ?s * ?cr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_of_int (content r) * inverse (rat_of_int s) =\n    inverse (rat_of_int s) * rat_of_int (content r)", "by simp"], ["proof (state)\nthis:\n  rat_of_int (content r) * inverse (rat_of_int s) =\n  inverse (rat_of_int s) * rat_of_int (content r)\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    p = smult d (of_int_poly q) \\<and>\n    0 < d \\<and> (p \\<noteq> 0 \\<longrightarrow> content q = 1)", "also"], ["proof (state)\nthis:\n  rat_of_int (content r) * inverse (rat_of_int s) =\n  inverse (rat_of_int s) * rat_of_int (content r)\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    p = smult d (of_int_poly q) \\<and>\n    0 < d \\<and> (p \\<noteq> 0 \\<longrightarrow> content q = 1)", "have \"smult (inverse ?s * ?cr) ?q = smult (inverse ?s) (smult ?cr ?q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. smult (inverse (rat_of_int s) * rat_of_int (content r))\n     (of_int_poly q) =\n    smult (inverse (rat_of_int s))\n     (smult (rat_of_int (content r)) (of_int_poly q))", "by simp"], ["proof (state)\nthis:\n  smult (inverse (rat_of_int s) * rat_of_int (content r)) (of_int_poly q) =\n  smult (inverse (rat_of_int s))\n   (smult (rat_of_int (content r)) (of_int_poly q))\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    p = smult d (of_int_poly q) \\<and>\n    0 < d \\<and> (p \\<noteq> 0 \\<longrightarrow> content q = 1)", "also"], ["proof (state)\nthis:\n  smult (inverse (rat_of_int s) * rat_of_int (content r)) (of_int_poly q) =\n  smult (inverse (rat_of_int s))\n   (smult (rat_of_int (content r)) (of_int_poly q))\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    p = smult d (of_int_poly q) \\<and>\n    0 < d \\<and> (p \\<noteq> 0 \\<longrightarrow> content q = 1)", "have \"smult ?cr ?q = map_poly of_int (smult (content r) q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. smult (rat_of_int (content r)) (of_int_poly q) =\n    of_int_poly (smult (content r) q)", "by (simp add: hom_distribs)"], ["proof (state)\nthis:\n  smult (rat_of_int (content r)) (of_int_poly q) =\n  of_int_poly (smult (content r) q)\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    p = smult d (of_int_poly q) \\<and>\n    0 < d \\<and> (p \\<noteq> 0 \\<longrightarrow> content q = 1)", "also"], ["proof (state)\nthis:\n  smult (rat_of_int (content r)) (of_int_poly q) =\n  of_int_poly (smult (content r) q)\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    p = smult d (of_int_poly q) \\<and>\n    0 < d \\<and> (p \\<noteq> 0 \\<longrightarrow> content q = 1)", "have \"\\<dots> = map_poly of_int r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int_poly (smult (content r) q) = of_int_poly r", "unfolding qr"], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int_poly r = of_int_poly r", ".."], ["proof (state)\nthis:\n  of_int_poly (smult (content r) q) = of_int_poly r\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    p = smult d (of_int_poly q) \\<and>\n    0 < d \\<and> (p \\<noteq> 0 \\<longrightarrow> content q = 1)", "finally"], ["proof (chain)\npicking this:\n  smult d (of_int_poly q) = smult (inverse (rat_of_int s)) (of_int_poly r)", "have pq: \"p = smult d ?q\""], ["proof (prove)\nusing this:\n  smult d (of_int_poly q) = smult (inverse (rat_of_int s)) (of_int_poly r)\n\ngoal (1 subgoal):\n 1. p = smult d (of_int_poly q)", "unfolding p"], ["proof (prove)\nusing this:\n  smult d (of_int_poly q) = smult (inverse (rat_of_int s)) (of_int_poly r)\n\ngoal (1 subgoal):\n 1. smult (inverse (rat_of_int s)) (of_int_poly r) = smult d (of_int_poly q)", "by simp"], ["proof (state)\nthis:\n  p = smult d (of_int_poly q)\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    p = smult d (of_int_poly q) \\<and>\n    0 < d \\<and> (p \\<noteq> 0 \\<longrightarrow> content q = 1)", "from p p0"], ["proof (chain)\npicking this:\n  p = smult (inverse (rat_of_int s)) (of_int_poly r)\n  p \\<noteq> 0", "have r0: \"r \\<noteq> 0\""], ["proof (prove)\nusing this:\n  p = smult (inverse (rat_of_int s)) (of_int_poly r)\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. r \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  r \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    p = smult d (of_int_poly q) \\<and>\n    0 < d \\<and> (p \\<noteq> 0 \\<longrightarrow> content q = 1)", "from content_eq_zero_iff[of r] content_ge_0_int[of r] r0"], ["proof (chain)\npicking this:\n  (content r = 0) = (r = 0)\n  0 \\<le> content r\n  r \\<noteq> 0", "have cr: \"?cr > 0\""], ["proof (prove)\nusing this:\n  (content r = 0) = (r = 0)\n  0 \\<le> content r\n  r \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 < rat_of_int (content r)", "by linarith"], ["proof (state)\nthis:\n  0 < rat_of_int (content r)\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    p = smult d (of_int_poly q) \\<and>\n    0 < d \\<and> (p \\<noteq> 0 \\<longrightarrow> content q = 1)", "with s"], ["proof (chain)\npicking this:\n  0 < s\n  0 < rat_of_int (content r)", "have d0: \"d > 0\""], ["proof (prove)\nusing this:\n  0 < s\n  0 < rat_of_int (content r)\n\ngoal (1 subgoal):\n 1. 0 < d", "unfolding d"], ["proof (prove)\nusing this:\n  0 < s\n  0 < rat_of_int (content r)\n\ngoal (1 subgoal):\n 1. 0 < rat_of_int (content r) / rat_of_int s", "by auto"], ["proof (state)\nthis:\n  0 < d\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    p = smult d (of_int_poly q) \\<and>\n    0 < d \\<and> (p \\<noteq> 0 \\<longrightarrow> content q = 1)", "from content_primitive_part[OF r0]"], ["proof (chain)\npicking this:\n  content (primitive_part r) = 1", "have cq: \"content q = 1\""], ["proof (prove)\nusing this:\n  content (primitive_part r) = 1\n\ngoal (1 subgoal):\n 1. content q = 1", "unfolding q"], ["proof (prove)\nusing this:\n  content (primitive_part r) = 1\n\ngoal (1 subgoal):\n 1. content (primitive_part r) = 1", "."], ["proof (state)\nthis:\n  content q = 1\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    p = smult d (of_int_poly q) \\<and>\n    0 < d \\<and> (p \\<noteq> 0 \\<longrightarrow> content q = 1)", "from pq d0 cq"], ["proof (chain)\npicking this:\n  p = smult d (of_int_poly q)\n  0 < d\n  content q = 1", "show ?thesis"], ["proof (prove)\nusing this:\n  p = smult d (of_int_poly q)\n  0 < d\n  content q = 1\n\ngoal (1 subgoal):\n 1. p = smult d (of_int_poly q) \\<and>\n    0 < d \\<and> (p \\<noteq> 0 \\<longrightarrow> content q = 1)", "by auto"], ["proof (state)\nthis:\n  p = smult d (of_int_poly q) \\<and>\n  0 < d \\<and> (p \\<noteq> 0 \\<longrightarrow> content q = 1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  p = smult d (of_int_poly q) \\<and>\n  0 < d \\<and> (p \\<noteq> 0 \\<longrightarrow> content q = 1)\n\ngoal (4 subgoals):\n 1. p = smult d (of_int_poly q)\n 2. 0 < d\n 3. p \\<noteq> 0 \\<Longrightarrow> content q = 1\n 4. degree q = degree p", "thus p: \"p = smult d (map_poly of_int q)\" and d: \"d > 0\" and \"p \\<noteq> 0 \\<Longrightarrow> content q = 1\""], ["proof (prove)\nusing this:\n  p = smult d (of_int_poly q) \\<and>\n  0 < d \\<and> (p \\<noteq> 0 \\<longrightarrow> content q = 1)\n\ngoal (1 subgoal):\n 1. p = smult d (of_int_poly q) &&&\n    0 < d &&& (p \\<noteq> 0 \\<Longrightarrow> content q = 1)", "by auto"], ["proof (state)\nthis:\n  p = smult d (of_int_poly q)\n  0 < d\n  p \\<noteq> 0 \\<Longrightarrow> content q = 1\n\ngoal (1 subgoal):\n 1. degree q = degree p", "show \"degree q = degree p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree q = degree p", "unfolding p smult_as_map_poly"], ["proof (prove)\ngoal (1 subgoal):\n 1. degree q = degree (map_poly ((*) d) (of_int_poly q))", "by (rule sym, subst map_poly_map_poly, force+, rule degree_map_poly, insert d, auto)"], ["proof (state)\nthis:\n  degree q = degree p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma content_dvd_1:\n  \"content g = 1\" if \"content f = (1 :: 'a :: semiring_gcd)\" \"g dvd f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. content g = (1::'a)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. content g = (1::'a)", "from \\<open>g dvd f\\<close>"], ["proof (chain)\npicking this:\n  g dvd f", "have \"content g dvd content f\""], ["proof (prove)\nusing this:\n  g dvd f\n\ngoal (1 subgoal):\n 1. content g dvd content f", "by (rule content_dvd_contentI)"], ["proof (state)\nthis:\n  content g dvd content f\n\ngoal (1 subgoal):\n 1. content g = (1::'a)", "with \\<open>content f = 1\\<close>"], ["proof (chain)\npicking this:\n  content f = (1::'a)\n  content g dvd content f", "show ?thesis"], ["proof (prove)\nusing this:\n  content f = (1::'a)\n  content g dvd content f\n\ngoal (1 subgoal):\n 1. content g = (1::'a)", "by simp"], ["proof (state)\nthis:\n  content g = (1::'a)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma dvd_smult_int: fixes c :: int assumes c: \"c \\<noteq> 0\"\n  and dvd: \"q dvd (smult c p)\"\n  shows \"primitive_part q dvd p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. primitive_part q dvd p", "proof (cases \"p = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow> primitive_part q dvd p\n 2. p \\<noteq> 0 \\<Longrightarrow> primitive_part q dvd p", "case True"], ["proof (state)\nthis:\n  p = 0\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow> primitive_part q dvd p\n 2. p \\<noteq> 0 \\<Longrightarrow> primitive_part q dvd p", "thus ?thesis"], ["proof (prove)\nusing this:\n  p = 0\n\ngoal (1 subgoal):\n 1. primitive_part q dvd p", "by auto"], ["proof (state)\nthis:\n  primitive_part q dvd p\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> primitive_part q dvd p", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> primitive_part q dvd p", "case False"], ["proof (state)\nthis:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> primitive_part q dvd p", "note p0 = this"], ["proof (state)\nthis:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> primitive_part q dvd p", "let ?cp = \"smult c p\""], ["proof (state)\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> primitive_part q dvd p", "from p0 c"], ["proof (chain)\npicking this:\n  p \\<noteq> 0\n  c \\<noteq> 0", "have cp0: \"?cp \\<noteq> 0\""], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  c \\<noteq> 0\n\ngoal (1 subgoal):\n 1. smult c p \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  smult c p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> primitive_part q dvd p", "from dvd"], ["proof (chain)\npicking this:\n  q dvd smult c p", "obtain r where prod: \"?cp = q * r\""], ["proof (prove)\nusing this:\n  q dvd smult c p\n\ngoal (1 subgoal):\n 1. (\\<And>r. smult c p = q * r \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding dvd_def"], ["proof (prove)\nusing this:\n  \\<exists>k. smult c p = q * k\n\ngoal (1 subgoal):\n 1. (\\<And>r. smult c p = q * r \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  smult c p = q * r\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> primitive_part q dvd p", "from prod cp0"], ["proof (chain)\npicking this:\n  smult c p = q * r\n  smult c p \\<noteq> 0", "have q0: \"q \\<noteq> 0\" and r0: \"r \\<noteq> 0\""], ["proof (prove)\nusing this:\n  smult c p = q * r\n  smult c p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. q \\<noteq> 0 &&& r \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  q \\<noteq> 0\n  r \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> primitive_part q dvd p", "let ?c = \"content :: int poly \\<Rightarrow> int\""], ["proof (state)\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> primitive_part q dvd p", "let ?n = \"primitive_part :: int poly \\<Rightarrow> int poly\""], ["proof (state)\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> primitive_part q dvd p", "let ?pn = \"\\<lambda> p. smult (?c p) (?n p)\""], ["proof (state)\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> primitive_part q dvd p", "have cq: \"(?c q = 0) = False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (content q = 0) = False", "using content_eq_zero_iff q0"], ["proof (prove)\nusing this:\n  (content ?p = (0::?'a)) = (?p = 0)\n  q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (content q = 0) = False", "by auto"], ["proof (state)\nthis:\n  (content q = 0) = False\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> primitive_part q dvd p", "from prod"], ["proof (chain)\npicking this:\n  smult c p = q * r", "have id1: \"?cp = ?pn q * ?pn r\""], ["proof (prove)\nusing this:\n  smult c p = q * r\n\ngoal (1 subgoal):\n 1. smult c p =\n    smult (content q) (primitive_part q) *\n    smult (content r) (primitive_part r)", "unfolding content_times_primitive_part"], ["proof (prove)\nusing this:\n  smult c p = q * r\n\ngoal (1 subgoal):\n 1. smult c p = q * r", "by simp"], ["proof (state)\nthis:\n  smult c p =\n  smult (content q) (primitive_part q) *\n  smult (content r) (primitive_part r)\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> primitive_part q dvd p", "from arg_cong[OF this, of content, unfolded content_smult_int content_mult\n    content_primitive_part[OF r0] content_primitive_part[OF q0], symmetric]\n    p0[folded content_eq_zero_iff] c"], ["proof (chain)\npicking this:\n  \\<bar>content q\\<bar> * 1 * (\\<bar>content r\\<bar> * 1) =\n  \\<bar>c\\<bar> * content p\n  content p \\<noteq> 0\n  c \\<noteq> 0", "have \"abs c dvd ?c q * ?c r\""], ["proof (prove)\nusing this:\n  \\<bar>content q\\<bar> * 1 * (\\<bar>content r\\<bar> * 1) =\n  \\<bar>c\\<bar> * content p\n  content p \\<noteq> 0\n  c \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<bar>c\\<bar> dvd content q * content r", "unfolding dvd_def"], ["proof (prove)\nusing this:\n  \\<bar>content q\\<bar> * 1 * (\\<bar>content r\\<bar> * 1) =\n  \\<bar>c\\<bar> * content p\n  content p \\<noteq> 0\n  c \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<exists>k. content q * content r = \\<bar>c\\<bar> * k", "by auto"], ["proof (state)\nthis:\n  \\<bar>c\\<bar> dvd content q * content r\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> primitive_part q dvd p", "hence \"c dvd ?c q * ?c r\""], ["proof (prove)\nusing this:\n  \\<bar>c\\<bar> dvd content q * content r\n\ngoal (1 subgoal):\n 1. c dvd content q * content r", "by auto"], ["proof (state)\nthis:\n  c dvd content q * content r\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> primitive_part q dvd p", "then"], ["proof (chain)\npicking this:\n  c dvd content q * content r", "obtain d where id: \"?c q * ?c r = c * d\""], ["proof (prove)\nusing this:\n  c dvd content q * content r\n\ngoal (1 subgoal):\n 1. (\\<And>d.\n        content q * content r = c * d \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding dvd_def"], ["proof (prove)\nusing this:\n  \\<exists>k. content q * content r = c * k\n\ngoal (1 subgoal):\n 1. (\\<And>d.\n        content q * content r = c * d \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  content q * content r = c * d\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> primitive_part q dvd p", "have \"?cp = ?pn q * ?pn r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. smult c p =\n    smult (content q) (primitive_part q) *\n    smult (content r) (primitive_part r)", "by fact"], ["proof (state)\nthis:\n  smult c p =\n  smult (content q) (primitive_part q) *\n  smult (content r) (primitive_part r)\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> primitive_part q dvd p", "also"], ["proof (state)\nthis:\n  smult c p =\n  smult (content q) (primitive_part q) *\n  smult (content r) (primitive_part r)\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> primitive_part q dvd p", "have \"\\<dots> = smult (c * d) (?n q * ?n r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. smult (content q) (primitive_part q) *\n    smult (content r) (primitive_part r) =\n    smult (c * d) (primitive_part q * primitive_part r)", "unfolding id [symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. smult (content q) (primitive_part q) *\n    smult (content r) (primitive_part r) =\n    smult (content q * content r) (primitive_part q * primitive_part r)", "by (metis content_mult content_times_primitive_part primitive_part_mult)"], ["proof (state)\nthis:\n  smult (content q) (primitive_part q) *\n  smult (content r) (primitive_part r) =\n  smult (c * d) (primitive_part q * primitive_part r)\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> primitive_part q dvd p", "finally"], ["proof (chain)\npicking this:\n  smult c p = smult (c * d) (primitive_part q * primitive_part r)", "have id: \"?cp = smult c (?n q * smult d (?n r))\""], ["proof (prove)\nusing this:\n  smult c p = smult (c * d) (primitive_part q * primitive_part r)\n\ngoal (1 subgoal):\n 1. smult c p = smult c (primitive_part q * smult d (primitive_part r))", "by (simp add: mult.commute)"], ["proof (state)\nthis:\n  smult c p = smult c (primitive_part q * smult d (primitive_part r))\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> primitive_part q dvd p", "interpret map_poly_inj_zero_hom \"(*) c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_poly_inj_zero_hom ((*) c)", "using c"], ["proof (prove)\nusing this:\n  c \\<noteq> 0\n\ngoal (1 subgoal):\n 1. map_poly_inj_zero_hom ((*) c)", "by (unfold_locales, auto)"], ["proof (state)\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> primitive_part q dvd p", "have \"p = ?n q * smult d (?n r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p = primitive_part q * smult d (primitive_part r)", "using id[unfolded smult_as_map_poly[of c]]"], ["proof (prove)\nusing this:\n  map_poly ((*) c) p =\n  map_poly ((*) c) (primitive_part q * smult d (primitive_part r))\n\ngoal (1 subgoal):\n 1. p = primitive_part q * smult d (primitive_part r)", "by auto"], ["proof (state)\nthis:\n  p = primitive_part q * smult d (primitive_part r)\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> primitive_part q dvd p", "thus dvd: \"?n q dvd p\""], ["proof (prove)\nusing this:\n  p = primitive_part q * smult d (primitive_part r)\n\ngoal (1 subgoal):\n 1. primitive_part q dvd p", "unfolding dvd_def"], ["proof (prove)\nusing this:\n  p = primitive_part q * smult d (primitive_part r)\n\ngoal (1 subgoal):\n 1. \\<exists>k. p = primitive_part q * k", "by blast"], ["proof (state)\nthis:\n  primitive_part q dvd p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma irreducible\\<^sub>d_primitive_part:\n  fixes p :: \"int poly\" (* can be relaxed but primitive_part_mult has bad type constraint *)\n  shows \"irreducible\\<^sub>d (primitive_part p) \\<longleftrightarrow> irreducible\\<^sub>d p\" (is \"?l \\<longleftrightarrow> ?r\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. irreducible\\<^sub>d (primitive_part p) = irreducible\\<^sub>d p", "proof (rule iffI, rule irreducible\\<^sub>dI)"], ["proof (state)\ngoal (3 subgoals):\n 1. irreducible\\<^sub>d (primitive_part p) \\<Longrightarrow> 0 < degree p\n 2. \\<And>q r.\n       \\<lbrakk>irreducible\\<^sub>d (primitive_part p); 0 < degree q;\n        degree q < degree p; 0 < degree r; degree r < degree p;\n        p = q * r\\<rbrakk>\n       \\<Longrightarrow> False\n 3. irreducible\\<^sub>d p \\<Longrightarrow>\n    irreducible\\<^sub>d (primitive_part p)", "assume l: ?l"], ["proof (state)\nthis:\n  irreducible\\<^sub>d (primitive_part p)\n\ngoal (3 subgoals):\n 1. irreducible\\<^sub>d (primitive_part p) \\<Longrightarrow> 0 < degree p\n 2. \\<And>q r.\n       \\<lbrakk>irreducible\\<^sub>d (primitive_part p); 0 < degree q;\n        degree q < degree p; 0 < degree r; degree r < degree p;\n        p = q * r\\<rbrakk>\n       \\<Longrightarrow> False\n 3. irreducible\\<^sub>d p \\<Longrightarrow>\n    irreducible\\<^sub>d (primitive_part p)", "show \"degree p > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < degree p", "using l"], ["proof (prove)\nusing this:\n  irreducible\\<^sub>d (primitive_part p)\n\ngoal (1 subgoal):\n 1. 0 < degree p", "by auto"], ["proof (state)\nthis:\n  0 < degree p\n\ngoal (2 subgoals):\n 1. \\<And>q r.\n       \\<lbrakk>irreducible\\<^sub>d (primitive_part p); 0 < degree q;\n        degree q < degree p; 0 < degree r; degree r < degree p;\n        p = q * r\\<rbrakk>\n       \\<Longrightarrow> False\n 2. irreducible\\<^sub>d p \\<Longrightarrow>\n    irreducible\\<^sub>d (primitive_part p)", "have dpp: \"degree (primitive_part p) = degree p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (primitive_part p) = degree p", "by simp"], ["proof (state)\nthis:\n  degree (primitive_part p) = degree p\n\ngoal (2 subgoals):\n 1. \\<And>q r.\n       \\<lbrakk>irreducible\\<^sub>d (primitive_part p); 0 < degree q;\n        degree q < degree p; 0 < degree r; degree r < degree p;\n        p = q * r\\<rbrakk>\n       \\<Longrightarrow> False\n 2. irreducible\\<^sub>d p \\<Longrightarrow>\n    irreducible\\<^sub>d (primitive_part p)", "fix q r"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>q r.\n       \\<lbrakk>irreducible\\<^sub>d (primitive_part p); 0 < degree q;\n        degree q < degree p; 0 < degree r; degree r < degree p;\n        p = q * r\\<rbrakk>\n       \\<Longrightarrow> False\n 2. irreducible\\<^sub>d p \\<Longrightarrow>\n    irreducible\\<^sub>d (primitive_part p)", "assume deg: \"degree q < degree p\" \"degree r < degree p\" and \"p = q * r\""], ["proof (state)\nthis:\n  degree q < degree p\n  degree r < degree p\n  p = q * r\n\ngoal (2 subgoals):\n 1. \\<And>q r.\n       \\<lbrakk>irreducible\\<^sub>d (primitive_part p); 0 < degree q;\n        degree q < degree p; 0 < degree r; degree r < degree p;\n        p = q * r\\<rbrakk>\n       \\<Longrightarrow> False\n 2. irreducible\\<^sub>d p \\<Longrightarrow>\n    irreducible\\<^sub>d (primitive_part p)", "then"], ["proof (chain)\npicking this:\n  degree q < degree p\n  degree r < degree p\n  p = q * r", "have pp: \"primitive_part p = primitive_part q * primitive_part r\""], ["proof (prove)\nusing this:\n  degree q < degree p\n  degree r < degree p\n  p = q * r\n\ngoal (1 subgoal):\n 1. primitive_part p = primitive_part q * primitive_part r", "by (simp add: primitive_part_mult)"], ["proof (state)\nthis:\n  primitive_part p = primitive_part q * primitive_part r\n\ngoal (2 subgoals):\n 1. \\<And>q r.\n       \\<lbrakk>irreducible\\<^sub>d (primitive_part p); 0 < degree q;\n        degree q < degree p; 0 < degree r; degree r < degree p;\n        p = q * r\\<rbrakk>\n       \\<Longrightarrow> False\n 2. irreducible\\<^sub>d p \\<Longrightarrow>\n    irreducible\\<^sub>d (primitive_part p)", "have \"\\<not> irreducible\\<^sub>d (primitive_part p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> irreducible\\<^sub>d (primitive_part p)", "apply (intro reducible\\<^sub>dI, rule exI[of _ \"primitive_part q\"], rule exI[of _ \"primitive_part r\"], unfold dpp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < degree p \\<Longrightarrow>\n    degree (primitive_part q) < degree p \\<and>\n    degree (primitive_part r) < degree p \\<and>\n    primitive_part p = primitive_part q * primitive_part r", "using deg pp"], ["proof (prove)\nusing this:\n  degree q < degree p\n  degree r < degree p\n  primitive_part p = primitive_part q * primitive_part r\n\ngoal (1 subgoal):\n 1. 0 < degree p \\<Longrightarrow>\n    degree (primitive_part q) < degree p \\<and>\n    degree (primitive_part r) < degree p \\<and>\n    primitive_part p = primitive_part q * primitive_part r", "by auto"], ["proof (state)\nthis:\n  \\<not> irreducible\\<^sub>d (primitive_part p)\n\ngoal (2 subgoals):\n 1. \\<And>q r.\n       \\<lbrakk>irreducible\\<^sub>d (primitive_part p); 0 < degree q;\n        degree q < degree p; 0 < degree r; degree r < degree p;\n        p = q * r\\<rbrakk>\n       \\<Longrightarrow> False\n 2. irreducible\\<^sub>d p \\<Longrightarrow>\n    irreducible\\<^sub>d (primitive_part p)", "with l"], ["proof (chain)\npicking this:\n  irreducible\\<^sub>d (primitive_part p)\n  \\<not> irreducible\\<^sub>d (primitive_part p)", "show False"], ["proof (prove)\nusing this:\n  irreducible\\<^sub>d (primitive_part p)\n  \\<not> irreducible\\<^sub>d (primitive_part p)\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. irreducible\\<^sub>d p \\<Longrightarrow>\n    irreducible\\<^sub>d (primitive_part p)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. irreducible\\<^sub>d p \\<Longrightarrow>\n    irreducible\\<^sub>d (primitive_part p)", "show \"?r \\<Longrightarrow> ?l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. irreducible\\<^sub>d p \\<Longrightarrow>\n    irreducible\\<^sub>d (primitive_part p)", "by (metis irreducible\\<^sub>d_smultI normalize_non_0_smult)"], ["proof (state)\nthis:\n  irreducible\\<^sub>d p \\<Longrightarrow>\n  irreducible\\<^sub>d (primitive_part p)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma irreducible\\<^sub>d_smult_int:\n  fixes c :: int assumes c: \"c \\<noteq> 0\"\n  shows \"irreducible\\<^sub>d (smult c p) = irreducible\\<^sub>d p\" (is \"?l = ?r\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. irreducible\\<^sub>d (smult c p) = irreducible\\<^sub>d p", "using irreducible\\<^sub>d_primitive_part[of \"smult c p\", unfolded primitive_part_smult] c"], ["proof (prove)\nusing this:\n  irreducible\\<^sub>d (smult (unit_factor c) (primitive_part p)) =\n  irreducible\\<^sub>d (smult c p)\n  c \\<noteq> 0\n\ngoal (1 subgoal):\n 1. irreducible\\<^sub>d (smult c p) = irreducible\\<^sub>d p", "apply (cases \"c < 0\", simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>irreducible\\<^sub>d (- primitive_part p) =\n             irreducible\\<^sub>d (smult c p);\n     c < 0\\<rbrakk>\n    \\<Longrightarrow> irreducible\\<^sub>d (smult c p) =\n                      irreducible\\<^sub>d p\n 2. \\<lbrakk>irreducible\\<^sub>d\n              (smult (unit_factor c) (primitive_part p)) =\n             irreducible\\<^sub>d (smult c p);\n     c \\<noteq> 0; \\<not> c < 0\\<rbrakk>\n    \\<Longrightarrow> irreducible\\<^sub>d (smult c p) =\n                      irreducible\\<^sub>d p", "apply (metis add.inverse_inverse add.inverse_neutral c irreducible\\<^sub>d_smultI normalize_non_0_smult smult_1_left smult_minus_left)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>irreducible\\<^sub>d\n              (smult (unit_factor c) (primitive_part p)) =\n             irreducible\\<^sub>d (smult c p);\n     c \\<noteq> 0; \\<not> c < 0\\<rbrakk>\n    \\<Longrightarrow> irreducible\\<^sub>d (smult c p) =\n                      irreducible\\<^sub>d p", "apply (simp add: irreducible\\<^sub>d_primitive_part)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma irreducible\\<^sub>d_as_irreducible:\n  fixes p :: \"int poly\"\n  shows \"irreducible\\<^sub>d p \\<longleftrightarrow> irreducible (primitive_part p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. irreducible\\<^sub>d p = irreducible (primitive_part p)", "using irreducible_primitive_connect[of \"primitive_part p\"]"], ["proof (prove)\nusing this:\n  primitive (primitive_part p) \\<Longrightarrow>\n  irreducible\\<^sub>d (primitive_part p) = irreducible (primitive_part p)\n\ngoal (1 subgoal):\n 1. irreducible\\<^sub>d p = irreducible (primitive_part p)", "by (cases \"p = 0\", auto simp: irreducible\\<^sub>d_primitive_part)"], ["", "lemma rat_to_int_factor_content_1: fixes p :: \"int poly\" \n  assumes cp: \"content p = 1\"\n  and pgh: \"map_poly rat_of_int p = g * h\"\n  and g: \"rat_to_normalized_int_poly g = (r,rg)\"\n  and h: \"rat_to_normalized_int_poly h = (s,sh)\"\n  and p: \"p \\<noteq> 0\"\n  shows \"p = rg * sh\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p = rg * sh", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. p = rg * sh", "let ?r = \"rat_of_int\""], ["proof (state)\ngoal (1 subgoal):\n 1. p = rg * sh", "let ?rp = \"map_poly ?r\""], ["proof (state)\ngoal (1 subgoal):\n 1. p = rg * sh", "from p"], ["proof (chain)\npicking this:\n  p \\<noteq> 0", "have rp0: \"?rp p \\<noteq> 0\""], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. of_int_poly p \\<noteq> 0", "by simp"], ["proof (state)\nthis:\n  of_int_poly p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p = rg * sh", "with pgh"], ["proof (chain)\npicking this:\n  of_int_poly p = g * h\n  of_int_poly p \\<noteq> 0", "have g0: \"g \\<noteq> 0\" and h0: \"h \\<noteq> 0\""], ["proof (prove)\nusing this:\n  of_int_poly p = g * h\n  of_int_poly p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. g \\<noteq> 0 &&& h \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  g \\<noteq> 0\n  h \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p = rg * sh", "from rat_to_normalized_int_poly[OF g] g0"], ["proof (chain)\npicking this:\n  g = smult r (of_int_poly rg)\n  0 < r\n  g \\<noteq> 0 \\<Longrightarrow> content rg = 1\n  degree rg = degree g\n  g \\<noteq> 0", "have r: \"r > 0\" \"r \\<noteq> 0\" and g: \"g = smult r (?rp rg)\" and crg: \"content rg = 1\""], ["proof (prove)\nusing this:\n  g = smult r (of_int_poly rg)\n  0 < r\n  g \\<noteq> 0 \\<Longrightarrow> content rg = 1\n  degree rg = degree g\n  g \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (0 < r &&& r \\<noteq> 0) &&&\n    g = smult r (of_int_poly rg) &&& content rg = 1", "by auto"], ["proof (state)\nthis:\n  0 < r\n  r \\<noteq> 0\n  g = smult r (of_int_poly rg)\n  content rg = 1\n\ngoal (1 subgoal):\n 1. p = rg * sh", "from rat_to_normalized_int_poly[OF h] h0"], ["proof (chain)\npicking this:\n  h = smult s (of_int_poly sh)\n  0 < s\n  h \\<noteq> 0 \\<Longrightarrow> content sh = 1\n  degree sh = degree h\n  h \\<noteq> 0", "have s: \"s > 0\" \"s \\<noteq> 0\" and h: \"h = smult s (?rp sh)\" and csh: \"content sh = 1\""], ["proof (prove)\nusing this:\n  h = smult s (of_int_poly sh)\n  0 < s\n  h \\<noteq> 0 \\<Longrightarrow> content sh = 1\n  degree sh = degree h\n  h \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (0 < s &&& s \\<noteq> 0) &&&\n    h = smult s (of_int_poly sh) &&& content sh = 1", "by auto"], ["proof (state)\nthis:\n  0 < s\n  s \\<noteq> 0\n  h = smult s (of_int_poly sh)\n  content sh = 1\n\ngoal (1 subgoal):\n 1. p = rg * sh", "let ?irs = \"inverse (r * s)\""], ["proof (state)\ngoal (1 subgoal):\n 1. p = rg * sh", "from r s"], ["proof (chain)\npicking this:\n  0 < r\n  r \\<noteq> 0\n  0 < s\n  s \\<noteq> 0", "have irs0: \"?irs \\<noteq> 0\""], ["proof (prove)\nusing this:\n  0 < r\n  r \\<noteq> 0\n  0 < s\n  s \\<noteq> 0\n\ngoal (1 subgoal):\n 1. inverse (r * s) \\<noteq> 0", "by (auto simp: field_simps)"], ["proof (state)\nthis:\n  inverse (r * s) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p = rg * sh", "have \"?rp (rg * sh) = ?rp rg * ?rp sh\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int_poly (rg * sh) = of_int_poly rg * of_int_poly sh", "by (simp add: hom_distribs)"], ["proof (state)\nthis:\n  of_int_poly (rg * sh) = of_int_poly rg * of_int_poly sh\n\ngoal (1 subgoal):\n 1. p = rg * sh", "also"], ["proof (state)\nthis:\n  of_int_poly (rg * sh) = of_int_poly rg * of_int_poly sh\n\ngoal (1 subgoal):\n 1. p = rg * sh", "have \"\\<dots> = smult ?irs (?rp p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int_poly rg * of_int_poly sh =\n    smult (inverse (r * s)) (of_int_poly p)", "unfolding pgh g h"], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int_poly rg * of_int_poly sh =\n    smult (inverse (r * s))\n     (smult r (of_int_poly rg) * smult s (of_int_poly sh))", "using r s"], ["proof (prove)\nusing this:\n  0 < r\n  r \\<noteq> 0\n  0 < s\n  s \\<noteq> 0\n\ngoal (1 subgoal):\n 1. of_int_poly rg * of_int_poly sh =\n    smult (inverse (r * s))\n     (smult r (of_int_poly rg) * smult s (of_int_poly sh))", "by (simp add: field_simps)"], ["proof (state)\nthis:\n  of_int_poly rg * of_int_poly sh = smult (inverse (r * s)) (of_int_poly p)\n\ngoal (1 subgoal):\n 1. p = rg * sh", "finally"], ["proof (chain)\npicking this:\n  of_int_poly (rg * sh) = smult (inverse (r * s)) (of_int_poly p)", "have id: \"?rp (rg * sh) = smult ?irs (?rp p)\""], ["proof (prove)\nusing this:\n  of_int_poly (rg * sh) = smult (inverse (r * s)) (of_int_poly p)\n\ngoal (1 subgoal):\n 1. of_int_poly (rg * sh) = smult (inverse (r * s)) (of_int_poly p)", "by auto"], ["proof (state)\nthis:\n  of_int_poly (rg * sh) = smult (inverse (r * s)) (of_int_poly p)\n\ngoal (1 subgoal):\n 1. p = rg * sh", "have rsZ: \"?irs \\<in> \\<int>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inverse (r * s) \\<in> \\<int>", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. inverse (r * s) \\<notin> \\<int> \\<Longrightarrow> False", "assume not: \"\\<not> ?irs \\<in> \\<int>\""], ["proof (state)\nthis:\n  inverse (r * s) \\<notin> \\<int>\n\ngoal (1 subgoal):\n 1. inverse (r * s) \\<notin> \\<int> \\<Longrightarrow> False", "obtain n d where irs': \"quotient_of ?irs = (n,d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>n d.\n        quotient_of (inverse (r * s)) = (n, d) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  quotient_of (inverse (r * s)) = (n, d)\n\ngoal (1 subgoal):\n 1. inverse (r * s) \\<notin> \\<int> \\<Longrightarrow> False", "from quotient_of_denom_pos[OF irs']"], ["proof (chain)\npicking this:\n  0 < d", "have \"d > 0\""], ["proof (prove)\nusing this:\n  0 < d\n\ngoal (1 subgoal):\n 1. 0 < d", "."], ["proof (state)\nthis:\n  0 < d\n\ngoal (1 subgoal):\n 1. inverse (r * s) \\<notin> \\<int> \\<Longrightarrow> False", "from not quotient_of_div[OF irs']"], ["proof (chain)\npicking this:\n  inverse (r * s) \\<notin> \\<int>\n  inverse (r * s) = rat_of_int n / rat_of_int d", "have \"d \\<noteq> 1\" \"d \\<noteq> 0\" and irs: \"?irs = ?r n / ?r d\""], ["proof (prove)\nusing this:\n  inverse (r * s) \\<notin> \\<int>\n  inverse (r * s) = rat_of_int n / rat_of_int d\n\ngoal (1 subgoal):\n 1. (d \\<noteq> 1 &&& d \\<noteq> 0) &&&\n    inverse (r * s) = rat_of_int n / rat_of_int d", "by auto"], ["proof (state)\nthis:\n  d \\<noteq> 1\n  d \\<noteq> 0\n  inverse (r * s) = rat_of_int n / rat_of_int d\n\ngoal (1 subgoal):\n 1. inverse (r * s) \\<notin> \\<int> \\<Longrightarrow> False", "with irs0"], ["proof (chain)\npicking this:\n  inverse (r * s) \\<noteq> 0\n  d \\<noteq> 1\n  d \\<noteq> 0\n  inverse (r * s) = rat_of_int n / rat_of_int d", "have n0: \"n \\<noteq> 0\""], ["proof (prove)\nusing this:\n  inverse (r * s) \\<noteq> 0\n  d \\<noteq> 1\n  d \\<noteq> 0\n  inverse (r * s) = rat_of_int n / rat_of_int d\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. inverse (r * s) \\<notin> \\<int> \\<Longrightarrow> False", "from \\<open>d > 0\\<close> \\<open>d \\<noteq> 1\\<close>"], ["proof (chain)\npicking this:\n  0 < d\n  d \\<noteq> 1", "have \"d \\<ge> 2\" and \"\\<not> d dvd 1\""], ["proof (prove)\nusing this:\n  0 < d\n  d \\<noteq> 1\n\ngoal (1 subgoal):\n 1. 2 \\<le> d &&& \\<not> is_unit d", "by auto"], ["proof (state)\nthis:\n  2 \\<le> d\n  \\<not> is_unit d\n\ngoal (1 subgoal):\n 1. inverse (r * s) \\<notin> \\<int> \\<Longrightarrow> False", "with content_iff[of d p, unfolded cp]"], ["proof (chain)\npicking this:\n  is_unit d = (\\<forall>c\\<in>set (coeffs p). d dvd c)\n  2 \\<le> d\n  \\<not> is_unit d", "obtain c where \n      c: \"c \\<in> set (coeffs p)\" and dc: \"\\<not> d dvd c\""], ["proof (prove)\nusing this:\n  is_unit d = (\\<forall>c\\<in>set (coeffs p). d dvd c)\n  2 \\<le> d\n  \\<not> is_unit d\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        \\<lbrakk>c \\<in> set (coeffs p); \\<not> d dvd c\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  c \\<in> set (coeffs p)\n  \\<not> d dvd c\n\ngoal (1 subgoal):\n 1. inverse (r * s) \\<notin> \\<int> \\<Longrightarrow> False", "from c range_coeff[of p]"], ["proof (chain)\npicking this:\n  c \\<in> set (coeffs p)\n  range (coeff p) = insert 0 (set (coeffs p))", "obtain i where \"c = coeff p i\""], ["proof (prove)\nusing this:\n  c \\<in> set (coeffs p)\n  range (coeff p) = insert 0 (set (coeffs p))\n\ngoal (1 subgoal):\n 1. (\\<And>i. c = coeff p i \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  c = coeff p i\n\ngoal (1 subgoal):\n 1. inverse (r * s) \\<notin> \\<int> \\<Longrightarrow> False", "from arg_cong[OF id, of \"\\<lambda> p. coeff p i\", \n      unfolded coeff_smult of_int_hom.coeff_map_poly_hom this[symmetric] irs]"], ["proof (chain)\npicking this:\n  rat_of_int (coeff (rg * sh) i) =\n  rat_of_int n / rat_of_int d * rat_of_int c", "have \"?r n / ?r d * ?r c \\<in> \\<int>\""], ["proof (prove)\nusing this:\n  rat_of_int (coeff (rg * sh) i) =\n  rat_of_int n / rat_of_int d * rat_of_int c\n\ngoal (1 subgoal):\n 1. rat_of_int n / rat_of_int d * rat_of_int c \\<in> \\<int>", "by (metis Ints_of_int)"], ["proof (state)\nthis:\n  rat_of_int n / rat_of_int d * rat_of_int c \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. inverse (r * s) \\<notin> \\<int> \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  rat_of_int n / rat_of_int d * rat_of_int c \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. inverse (r * s) \\<notin> \\<int> \\<Longrightarrow> False", "have \"?r n / ?r d * ?r c = ?r (n * c) / ?r d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_of_int n / rat_of_int d * rat_of_int c =\n    rat_of_int (n * c) / rat_of_int d", "by simp"], ["proof (state)\nthis:\n  rat_of_int n / rat_of_int d * rat_of_int c =\n  rat_of_int (n * c) / rat_of_int d\n\ngoal (1 subgoal):\n 1. inverse (r * s) \\<notin> \\<int> \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  rat_of_int (n * c) / rat_of_int d \\<in> \\<int>", "have inZ: \"?r (n * c) / ?r d \\<in> \\<int>\""], ["proof (prove)\nusing this:\n  rat_of_int (n * c) / rat_of_int d \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. rat_of_int (n * c) / rat_of_int d \\<in> \\<int>", "."], ["proof (state)\nthis:\n  rat_of_int (n * c) / rat_of_int d \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. inverse (r * s) \\<notin> \\<int> \\<Longrightarrow> False", "have cop: \"coprime n d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coprime n d", "by (rule quotient_of_coprime[OF irs'])"], ["proof (state)\nthis:\n  coprime n d\n\ngoal (1 subgoal):\n 1. inverse (r * s) \\<notin> \\<int> \\<Longrightarrow> False", "(* now there comes tedious reasoning that `coprime n d` `\\<not> d dvd c` ` nc / d \\<in> \\<int>` yields a \n       contradiction *)"], ["proof (state)\nthis:\n  coprime n d\n\ngoal (1 subgoal):\n 1. inverse (r * s) \\<notin> \\<int> \\<Longrightarrow> False", "define prod where \"prod = ?r (n * c) / ?r d\""], ["proof (state)\nthis:\n  prod = rat_of_int (n * c) / rat_of_int d\n\ngoal (1 subgoal):\n 1. inverse (r * s) \\<notin> \\<int> \\<Longrightarrow> False", "obtain n' d' where quot: \"quotient_of prod = (n',d')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>n' d'.\n        quotient_of prod = (n', d') \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  quotient_of prod = (n', d')\n\ngoal (1 subgoal):\n 1. inverse (r * s) \\<notin> \\<int> \\<Longrightarrow> False", "have qr: \"\\<And> x. quotient_of (?r x) = (x, 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. quotient_of (rat_of_int x) = (x, 1)", "using Rat.of_int_def quotient_of_int"], ["proof (prove)\nusing this:\n  Rat.of_int = rat_of_int\n  quotient_of (Rat.of_int ?a) = (?a, 1)\n\ngoal (1 subgoal):\n 1. \\<And>x. quotient_of (rat_of_int x) = (x, 1)", "by auto"], ["proof (state)\nthis:\n  quotient_of (rat_of_int ?x) = (?x, 1)\n\ngoal (1 subgoal):\n 1. inverse (r * s) \\<notin> \\<int> \\<Longrightarrow> False", "from quotient_of_denom_pos[OF quot]"], ["proof (chain)\npicking this:\n  0 < d'", "have \"d' > 0\""], ["proof (prove)\nusing this:\n  0 < d'\n\ngoal (1 subgoal):\n 1. 0 < d'", "."], ["proof (state)\nthis:\n  0 < d'\n\ngoal (1 subgoal):\n 1. inverse (r * s) \\<notin> \\<int> \\<Longrightarrow> False", "with quotient_of_div[OF quot] inZ[folded prod_def]"], ["proof (chain)\npicking this:\n  prod = rat_of_int n' / rat_of_int d'\n  prod \\<in> \\<int>\n  0 < d'", "have \"d' = 1\""], ["proof (prove)\nusing this:\n  prod = rat_of_int n' / rat_of_int d'\n  prod \\<in> \\<int>\n  0 < d'\n\ngoal (1 subgoal):\n 1. d' = 1", "by (metis Ints_cases Rat.of_int_def old.prod.inject quot quotient_of_int)"], ["proof (state)\nthis:\n  d' = 1\n\ngoal (1 subgoal):\n 1. inverse (r * s) \\<notin> \\<int> \\<Longrightarrow> False", "with quotient_of_div[OF quot]"], ["proof (chain)\npicking this:\n  prod = rat_of_int n' / rat_of_int d'\n  d' = 1", "have \"prod = ?r n'\""], ["proof (prove)\nusing this:\n  prod = rat_of_int n' / rat_of_int d'\n  d' = 1\n\ngoal (1 subgoal):\n 1. prod = rat_of_int n'", "by auto"], ["proof (state)\nthis:\n  prod = rat_of_int n'\n\ngoal (1 subgoal):\n 1. inverse (r * s) \\<notin> \\<int> \\<Longrightarrow> False", "from arg_cong[OF this, of quotient_of, unfolded prod_def rat_divide_code qr Let_def split]"], ["proof (chain)\npicking this:\n  Rat.normalize (n * c * 1, 1 * d) = (n', 1)", "have \"Rat.normalize (n * c, d) = (n',1)\""], ["proof (prove)\nusing this:\n  Rat.normalize (n * c * 1, 1 * d) = (n', 1)\n\ngoal (1 subgoal):\n 1. Rat.normalize (n * c, d) = (n', 1)", "by simp"], ["proof (state)\nthis:\n  Rat.normalize (n * c, d) = (n', 1)\n\ngoal (1 subgoal):\n 1. inverse (r * s) \\<notin> \\<int> \\<Longrightarrow> False", "from normalize_crossproduct[OF \\<open>d \\<noteq> 0\\<close>, of 1 \"n * c\" n', unfolded this]"], ["proof (chain)\npicking this:\n  \\<lbrakk>1 \\<noteq> 0; (n', 1) = Rat.normalize (n', 1)\\<rbrakk>\n  \\<Longrightarrow> n * c * 1 = n' * d", "have id: \"n * c = n' * d\""], ["proof (prove)\nusing this:\n  \\<lbrakk>1 \\<noteq> 0; (n', 1) = Rat.normalize (n', 1)\\<rbrakk>\n  \\<Longrightarrow> n * c * 1 = n' * d\n\ngoal (1 subgoal):\n 1. n * c = n' * d", "by auto"], ["proof (state)\nthis:\n  n * c = n' * d\n\ngoal (1 subgoal):\n 1. inverse (r * s) \\<notin> \\<int> \\<Longrightarrow> False", "from quotient_of_coprime[OF irs']"], ["proof (chain)\npicking this:\n  coprime n d", "have \"coprime n d\""], ["proof (prove)\nusing this:\n  coprime n d\n\ngoal (1 subgoal):\n 1. coprime n d", "."], ["proof (state)\nthis:\n  coprime n d\n\ngoal (1 subgoal):\n 1. inverse (r * s) \\<notin> \\<int> \\<Longrightarrow> False", "with id"], ["proof (chain)\npicking this:\n  n * c = n' * d\n  coprime n d", "have \"d dvd c\""], ["proof (prove)\nusing this:\n  n * c = n' * d\n  coprime n d\n\ngoal (1 subgoal):\n 1. d dvd c", "by (metis coprime_commute coprime_dvd_mult_right_iff dvd_triv_right)"], ["proof (state)\nthis:\n  d dvd c\n\ngoal (1 subgoal):\n 1. inverse (r * s) \\<notin> \\<int> \\<Longrightarrow> False", "with dc"], ["proof (chain)\npicking this:\n  \\<not> d dvd c\n  d dvd c", "show False"], ["proof (prove)\nusing this:\n  \\<not> d dvd c\n  d dvd c\n\ngoal (1 subgoal):\n 1. False", ".."], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  inverse (r * s) \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. p = rg * sh", "then"], ["proof (chain)\npicking this:\n  inverse (r * s) \\<in> \\<int>", "obtain irs where irs: \"?irs = ?r irs\""], ["proof (prove)\nusing this:\n  inverse (r * s) \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. (\\<And>irs.\n        inverse (r * s) = rat_of_int irs \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding Ints_def"], ["proof (prove)\nusing this:\n  inverse (r * s) \\<in> range rat_of_int\n\ngoal (1 subgoal):\n 1. (\\<And>irs.\n        inverse (r * s) = rat_of_int irs \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  inverse (r * s) = rat_of_int irs\n\ngoal (1 subgoal):\n 1. p = rg * sh", "from id[unfolded irs, folded hom_distribs, unfolded of_int_poly_hom.eq_iff]"], ["proof (chain)\npicking this:\n  rg * sh = smult irs p", "have p: \"rg * sh = smult irs p\""], ["proof (prove)\nusing this:\n  rg * sh = smult irs p\n\ngoal (1 subgoal):\n 1. rg * sh = smult irs p", "by auto"], ["proof (state)\nthis:\n  rg * sh = smult irs p\n\ngoal (1 subgoal):\n 1. p = rg * sh", "have \"content (rg * sh) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. content (rg * sh) = 1", "unfolding content_mult crg csh"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 * 1 = 1", "by auto"], ["proof (state)\nthis:\n  content (rg * sh) = 1\n\ngoal (1 subgoal):\n 1. p = rg * sh", "from this[unfolded p content_smult_int cp]"], ["proof (chain)\npicking this:\n  \\<bar>irs\\<bar> * 1 = 1", "have \"abs irs = 1\""], ["proof (prove)\nusing this:\n  \\<bar>irs\\<bar> * 1 = 1\n\ngoal (1 subgoal):\n 1. \\<bar>irs\\<bar> = 1", "by simp"], ["proof (state)\nthis:\n  \\<bar>irs\\<bar> = 1\n\ngoal (1 subgoal):\n 1. p = rg * sh", "hence \"abs ?irs = 1\""], ["proof (prove)\nusing this:\n  \\<bar>irs\\<bar> = 1\n\ngoal (1 subgoal):\n 1. \\<bar>inverse (r * s)\\<bar> = 1", "using irs"], ["proof (prove)\nusing this:\n  \\<bar>irs\\<bar> = 1\n  inverse (r * s) = rat_of_int irs\n\ngoal (1 subgoal):\n 1. \\<bar>inverse (r * s)\\<bar> = 1", "by auto"], ["proof (state)\nthis:\n  \\<bar>inverse (r * s)\\<bar> = 1\n\ngoal (1 subgoal):\n 1. p = rg * sh", "with r s"], ["proof (chain)\npicking this:\n  0 < r\n  r \\<noteq> 0\n  0 < s\n  s \\<noteq> 0\n  \\<bar>inverse (r * s)\\<bar> = 1", "have \"?irs = 1\""], ["proof (prove)\nusing this:\n  0 < r\n  r \\<noteq> 0\n  0 < s\n  s \\<noteq> 0\n  \\<bar>inverse (r * s)\\<bar> = 1\n\ngoal (1 subgoal):\n 1. inverse (r * s) = 1", "by auto"], ["proof (state)\nthis:\n  inverse (r * s) = 1\n\ngoal (1 subgoal):\n 1. p = rg * sh", "with irs"], ["proof (chain)\npicking this:\n  inverse (r * s) = rat_of_int irs\n  inverse (r * s) = 1", "have \"irs = 1\""], ["proof (prove)\nusing this:\n  inverse (r * s) = rat_of_int irs\n  inverse (r * s) = 1\n\ngoal (1 subgoal):\n 1. irs = 1", "by auto"], ["proof (state)\nthis:\n  irs = 1\n\ngoal (1 subgoal):\n 1. p = rg * sh", "with p"], ["proof (chain)\npicking this:\n  rg * sh = smult irs p\n  irs = 1", "show p: \"p = rg * sh\""], ["proof (prove)\nusing this:\n  rg * sh = smult irs p\n  irs = 1\n\ngoal (1 subgoal):\n 1. p = rg * sh", "by auto"], ["proof (state)\nthis:\n  p = rg * sh\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rat_to_int_factor_explicit: fixes p :: \"int poly\" \n  assumes pgh: \"map_poly rat_of_int p = g * h\"\n  and g: \"rat_to_normalized_int_poly g = (r,rg)\"\n  shows \"\\<exists> r. p = rg * smult (content p) r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>r. p = rg * smult (content p) r", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>r. p = rg * smult (content p) r", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>r. p = rg * smult (content p) r", "proof (cases \"p = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow> \\<exists>r. p = rg * smult (content p) r\n 2. p \\<noteq> 0 \\<Longrightarrow> \\<exists>r. p = rg * smult (content p) r", "case True"], ["proof (state)\nthis:\n  p = 0\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow> \\<exists>r. p = rg * smult (content p) r\n 2. p \\<noteq> 0 \\<Longrightarrow> \\<exists>r. p = rg * smult (content p) r", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>r. p = rg * smult (content p) r", "unfolding True"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>r. 0 = rg * smult (content 0) r", "by (rule exI[of _ 0], auto simp: degree_monom_eq)"], ["proof (state)\nthis:\n  \\<exists>r. p = rg * smult (content p) r\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> \\<exists>r. p = rg * smult (content p) r", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> \\<exists>r. p = rg * smult (content p) r", "case False"], ["proof (state)\nthis:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> \\<exists>r. p = rg * smult (content p) r", "hence p: \"p \\<noteq> 0\""], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> \\<exists>r. p = rg * smult (content p) r", "let ?r = \"rat_of_int\""], ["proof (state)\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> \\<exists>r. p = rg * smult (content p) r", "let ?rp = \"map_poly ?r\""], ["proof (state)\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> \\<exists>r. p = rg * smult (content p) r", "define q where \"q = primitive_part p\""], ["proof (state)\nthis:\n  q = primitive_part p\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> \\<exists>r. p = rg * smult (content p) r", "from content_times_primitive_part[of p, folded q_def] content_eq_zero_iff[of p] p"], ["proof (chain)\npicking this:\n  smult (content p) q = p\n  (content p = 0) = (p = 0)\n  p \\<noteq> 0", "obtain a where a: \"a \\<noteq> 0\" and pq: \"p = smult a q\" and acp: \"content p = a\""], ["proof (prove)\nusing this:\n  smult (content p) q = p\n  (content p = 0) = (p = 0)\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>a \\<noteq> 0; p = smult a q; content p = a\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  a \\<noteq> 0\n  p = smult a q\n  content p = a\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> \\<exists>r. p = rg * smult (content p) r", "from a pq p"], ["proof (chain)\npicking this:\n  a \\<noteq> 0\n  p = smult a q\n  p \\<noteq> 0", "have ra: \"?r a \\<noteq> 0\" and q0: \"q \\<noteq> 0\""], ["proof (prove)\nusing this:\n  a \\<noteq> 0\n  p = smult a q\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. rat_of_int a \\<noteq> 0 &&& q \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  rat_of_int a \\<noteq> 0\n  q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> \\<exists>r. p = rg * smult (content p) r", "from content_primitive_part[OF p, folded q_def]"], ["proof (chain)\npicking this:\n  content q = 1", "have cq: \"content q = 1\""], ["proof (prove)\nusing this:\n  content q = 1\n\ngoal (1 subgoal):\n 1. content q = 1", "by auto"], ["proof (state)\nthis:\n  content q = 1\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> \\<exists>r. p = rg * smult (content p) r", "obtain s sh where h: \"rat_to_normalized_int_poly (smult (inverse (?r a)) h) = (s,sh)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>s sh.\n        rat_to_normalized_int_poly (smult (inverse (rat_of_int a)) h) =\n        (s, sh) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  rat_to_normalized_int_poly (smult (inverse (rat_of_int a)) h) = (s, sh)\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> \\<exists>r. p = rg * smult (content p) r", "from arg_cong[OF pgh[unfolded pq], of \"smult (inverse (?r a))\"] ra"], ["proof (chain)\npicking this:\n  smult (inverse (rat_of_int a)) (of_int_poly (smult a q)) =\n  smult (inverse (rat_of_int a)) (g * h)\n  rat_of_int a \\<noteq> 0", "have \"?rp q = g * smult (inverse (?r a)) h\""], ["proof (prove)\nusing this:\n  smult (inverse (rat_of_int a)) (of_int_poly (smult a q)) =\n  smult (inverse (rat_of_int a)) (g * h)\n  rat_of_int a \\<noteq> 0\n\ngoal (1 subgoal):\n 1. of_int_poly q = g * smult (inverse (rat_of_int a)) h", "by (auto simp: hom_distribs)"], ["proof (state)\nthis:\n  of_int_poly q = g * smult (inverse (rat_of_int a)) h\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> \\<exists>r. p = rg * smult (content p) r", "from rat_to_int_factor_content_1[OF cq this g h q0]"], ["proof (chain)\npicking this:\n  q = rg * sh", "have qrs: \"q = rg * sh\""], ["proof (prove)\nusing this:\n  q = rg * sh\n\ngoal (1 subgoal):\n 1. q = rg * sh", "."], ["proof (state)\nthis:\n  q = rg * sh\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> \\<exists>r. p = rg * smult (content p) r", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>r. p = rg * smult (content p) r", "unfolding acp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>r. p = rg * smult a r", "unfolding pq qrs"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>r. smult a (rg * sh) = rg * smult a r", "by (rule exI[of _ sh], auto)"], ["proof (state)\nthis:\n  \\<exists>r. p = rg * smult (content p) r\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>r. p = rg * smult (content p) r\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rat_to_int_factor: fixes p :: \"int poly\" \n  assumes pgh: \"map_poly rat_of_int p = g * h\"\n  shows \"\\<exists> g' h'. p = g' * h' \\<and> degree g' = degree g \\<and> degree h' = degree h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>g' h'.\n       p = g' * h' \\<and> degree g' = degree g \\<and> degree h' = degree h", "proof(cases \"p = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow>\n    \\<exists>g' h'.\n       p = g' * h' \\<and> degree g' = degree g \\<and> degree h' = degree h\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>g' h'.\n       p = g' * h' \\<and> degree g' = degree g \\<and> degree h' = degree h", "case True"], ["proof (state)\nthis:\n  p = 0\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow>\n    \\<exists>g' h'.\n       p = g' * h' \\<and> degree g' = degree g \\<and> degree h' = degree h\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>g' h'.\n       p = g' * h' \\<and> degree g' = degree g \\<and> degree h' = degree h", "with pgh"], ["proof (chain)\npicking this:\n  of_int_poly p = g * h\n  p = 0", "have \"g = 0 \\<or> h = 0\""], ["proof (prove)\nusing this:\n  of_int_poly p = g * h\n  p = 0\n\ngoal (1 subgoal):\n 1. g = 0 \\<or> h = 0", "by auto"], ["proof (state)\nthis:\n  g = 0 \\<or> h = 0\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow>\n    \\<exists>g' h'.\n       p = g' * h' \\<and> degree g' = degree g \\<and> degree h' = degree h\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>g' h'.\n       p = g' * h' \\<and> degree g' = degree g \\<and> degree h' = degree h", "then"], ["proof (chain)\npicking this:\n  g = 0 \\<or> h = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  g = 0 \\<or> h = 0\n\ngoal (1 subgoal):\n 1. \\<exists>g' h'.\n       p = g' * h' \\<and> degree g' = degree g \\<and> degree h' = degree h", "by (metis True degree_0 mult_hom.hom_zero mult_zero_left rat_to_normalized_int_poly(4) surj_pair)"], ["proof (state)\nthis:\n  \\<exists>g' h'.\n     p = g' * h' \\<and> degree g' = degree g \\<and> degree h' = degree h\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>g' h'.\n       p = g' * h' \\<and> degree g' = degree g \\<and> degree h' = degree h", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>g' h'.\n       p = g' * h' \\<and> degree g' = degree g \\<and> degree h' = degree h", "case False"], ["proof (state)\nthis:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>g' h'.\n       p = g' * h' \\<and> degree g' = degree g \\<and> degree h' = degree h", "obtain r rg where ri: \"rat_to_normalized_int_poly (smult (1 / of_int (content p)) g) = (r,rg)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>r rg.\n        rat_to_normalized_int_poly (smult (1 / rat_of_int (content p)) g) =\n        (r, rg) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  rat_to_normalized_int_poly (smult (1 / rat_of_int (content p)) g) =\n  (r, rg)\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>g' h'.\n       p = g' * h' \\<and> degree g' = degree g \\<and> degree h' = degree h", "obtain q qh where ri2: \"rat_to_normalized_int_poly h = (q,qh)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>q qh.\n        rat_to_normalized_int_poly h = (q, qh) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  rat_to_normalized_int_poly h = (q, qh)\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>g' h'.\n       p = g' * h' \\<and> degree g' = degree g \\<and> degree h' = degree h", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>g' h'.\n       p = g' * h' \\<and> degree g' = degree g \\<and> degree h' = degree h", "proof (intro exI conjI)"], ["proof (state)\ngoal (3 subgoals):\n 1. p = ?g' * ?h'1\n 2. degree ?g' = degree g\n 3. degree ?h'1 = degree h", "have \"of_int_poly (primitive_part p) = smult (1 / of_int (content p)) (g * h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int_poly (primitive_part p) =\n    smult (1 / rat_of_int (content p)) (g * h)", "apply (auto simp: primitive_part_def pgh[symmetric] smult_map_poly map_poly_map_poly o_def intro!: map_poly_cong)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (coeffs p) \\<Longrightarrow>\n       rat_of_int (x div content p) = rat_of_int x / rat_of_int (content p)", "by (metis (no_types, lifting) content_dvd_coeffs div_by_0 dvd_mult_div_cancel floor_of_int nonzero_mult_div_cancel_left of_int_hom.hom_zero of_int_mult)"], ["proof (state)\nthis:\n  of_int_poly (primitive_part p) =\n  smult (1 / rat_of_int (content p)) (g * h)\n\ngoal (3 subgoals):\n 1. p = ?g' * ?h'1\n 2. degree ?g' = degree g\n 3. degree ?h'1 = degree h", "also"], ["proof (state)\nthis:\n  of_int_poly (primitive_part p) =\n  smult (1 / rat_of_int (content p)) (g * h)\n\ngoal (3 subgoals):\n 1. p = ?g' * ?h'1\n 2. degree ?g' = degree g\n 3. degree ?h'1 = degree h", "have \"\\<dots> = smult (1 / of_int (content p)) g * h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. smult (1 / rat_of_int (content p)) (g * h) =\n    smult (1 / rat_of_int (content p)) g * h", "by simp"], ["proof (state)\nthis:\n  smult (1 / rat_of_int (content p)) (g * h) =\n  smult (1 / rat_of_int (content p)) g * h\n\ngoal (3 subgoals):\n 1. p = ?g' * ?h'1\n 2. degree ?g' = degree g\n 3. degree ?h'1 = degree h", "finally"], ["proof (chain)\npicking this:\n  of_int_poly (primitive_part p) = smult (1 / rat_of_int (content p)) g * h", "have \"of_int_poly (primitive_part p) = \\<dots>\""], ["proof (prove)\nusing this:\n  of_int_poly (primitive_part p) = smult (1 / rat_of_int (content p)) g * h\n\ngoal (1 subgoal):\n 1. of_int_poly (primitive_part p) =\n    smult (1 / rat_of_int (content p)) g * h", "."], ["proof (state)\nthis:\n  of_int_poly (primitive_part p) = smult (1 / rat_of_int (content p)) g * h\n\ngoal (3 subgoals):\n 1. p = ?g' * ?h'1\n 2. degree ?g' = degree g\n 3. degree ?h'1 = degree h", "note main = rat_to_int_factor_content_1[OF _ this ri ri2, simplified, OF False]"], ["proof (state)\nthis:\n  primitive_part p = rg * qh\n\ngoal (3 subgoals):\n 1. p = ?g' * ?h'1\n 2. degree ?g' = degree g\n 3. degree ?h'1 = degree h", "show \"p = smult (content p) rg * qh\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p = smult (content p) rg * qh", "by (simp add: main[symmetric])"], ["proof (state)\nthis:\n  p = smult (content p) rg * qh\n\ngoal (2 subgoals):\n 1. degree (smult (content p) rg) = degree g\n 2. degree qh = degree h", "from ri2"], ["proof (chain)\npicking this:\n  rat_to_normalized_int_poly h = (q, qh)", "show \"degree qh = degree h\""], ["proof (prove)\nusing this:\n  rat_to_normalized_int_poly h = (q, qh)\n\ngoal (1 subgoal):\n 1. degree qh = degree h", "by (fact rat_to_normalized_int_poly)"], ["proof (state)\nthis:\n  degree qh = degree h\n\ngoal (1 subgoal):\n 1. degree (smult (content p) rg) = degree g", "from rat_to_normalized_int_poly(4)[OF ri] False"], ["proof (chain)\npicking this:\n  degree rg = degree (smult (1 / rat_of_int (content p)) g)\n  p \\<noteq> 0", "show \"degree (smult (content p) rg) = degree g\""], ["proof (prove)\nusing this:\n  degree rg = degree (smult (1 / rat_of_int (content p)) g)\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. degree (smult (content p) rg) = degree g", "by auto"], ["proof (state)\nthis:\n  degree (smult (content p) rg) = degree g\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>g' h'.\n     p = g' * h' \\<and> degree g' = degree g \\<and> degree h' = degree h\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rat_to_int_factor_normalized_int_poly: fixes p :: \"rat poly\" \n  assumes pgh: \"p = g * h\"\n  and p: \"rat_to_normalized_int_poly p = (i,ip)\"\n  shows \"\\<exists> g' h'. ip = g' * h' \\<and> degree g' = degree g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>g' h'. ip = g' * h' \\<and> degree g' = degree g", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>g' h'. ip = g' * h' \\<and> degree g' = degree g", "from rat_to_normalized_int_poly[OF p]"], ["proof (chain)\npicking this:\n  p = smult i (of_int_poly ip)\n  0 < i\n  p \\<noteq> 0 \\<Longrightarrow> content ip = 1\n  degree ip = degree p", "have p: \"p = smult i (map_poly rat_of_int ip)\" and i: \"i \\<noteq> 0\""], ["proof (prove)\nusing this:\n  p = smult i (of_int_poly ip)\n  0 < i\n  p \\<noteq> 0 \\<Longrightarrow> content ip = 1\n  degree ip = degree p\n\ngoal (1 subgoal):\n 1. p = smult i (of_int_poly ip) &&& i \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  p = smult i (of_int_poly ip)\n  i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<exists>g' h'. ip = g' * h' \\<and> degree g' = degree g", "from arg_cong[OF p, of \"smult (inverse i)\", unfolded pgh] i"], ["proof (chain)\npicking this:\n  smult (inverse i) (g * h) = smult (inverse i) (smult i (of_int_poly ip))\n  i \\<noteq> 0", "have \"map_poly rat_of_int ip = g * smult (inverse i) h\""], ["proof (prove)\nusing this:\n  smult (inverse i) (g * h) = smult (inverse i) (smult i (of_int_poly ip))\n  i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. of_int_poly ip = g * smult (inverse i) h", "by auto"], ["proof (state)\nthis:\n  of_int_poly ip = g * smult (inverse i) h\n\ngoal (1 subgoal):\n 1. \\<exists>g' h'. ip = g' * h' \\<and> degree g' = degree g", "from rat_to_int_factor[OF this]"], ["proof (chain)\npicking this:\n  \\<exists>g' h'.\n     ip = g' * h' \\<and>\n     degree g' = degree g \\<and> degree h' = degree (smult (inverse i) h)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>g' h'.\n     ip = g' * h' \\<and>\n     degree g' = degree g \\<and> degree h' = degree (smult (inverse i) h)\n\ngoal (1 subgoal):\n 1. \\<exists>g' h'. ip = g' * h' \\<and> degree g' = degree g", "by auto"], ["proof (state)\nthis:\n  \\<exists>g' h'. ip = g' * h' \\<and> degree g' = degree g\n\ngoal:\nNo subgoals!", "qed"], ["", "(* TODO: move *)"], ["", "lemma irreducible_smult [simp]:\n  fixes c :: \"'a :: field\"\n  shows \"irreducible (smult c p) \\<longleftrightarrow> irreducible p \\<and> c \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. irreducible (smult c p) = (irreducible p \\<and> c \\<noteq> (0::'a))", "using irreducible_mult_unit_left[of \"[:c:]\", simplified]"], ["proof (prove)\nusing this:\n  True\n\ngoal (1 subgoal):\n 1. irreducible (smult c p) = (irreducible p \\<and> c \\<noteq> (0::'a))", "by force"], ["", "text \\<open>A polynomial with integer coefficients is\n   irreducible over the rationals, if it is irreducible over the integers.\\<close>"], ["", "theorem irreducible\\<^sub>d_int_rat: fixes p :: \"int poly\" \n  assumes p: \"irreducible\\<^sub>d p\"\n  shows \"irreducible\\<^sub>d (map_poly rat_of_int p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. irreducible\\<^sub>d (of_int_poly p)", "proof (rule irreducible\\<^sub>dI)"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 < degree (of_int_poly p)\n 2. \\<And>q r.\n       \\<lbrakk>0 < degree q; degree q < degree (of_int_poly p);\n        0 < degree r; degree r < degree (of_int_poly p);\n        of_int_poly p = q * r\\<rbrakk>\n       \\<Longrightarrow> False", "from irreducible\\<^sub>dD[OF p]"], ["proof (chain)\npicking this:\n  0 < degree p\n  \\<lbrakk>degree ?q < degree p; degree ?r < degree p\\<rbrakk>\n  \\<Longrightarrow> p \\<noteq> ?q * ?r", "have p: \"degree p \\<noteq> 0\" and irr: \"\\<And> q r. degree q < degree p \\<Longrightarrow> degree r < degree p \\<Longrightarrow> p \\<noteq> q * r\""], ["proof (prove)\nusing this:\n  0 < degree p\n  \\<lbrakk>degree ?q < degree p; degree ?r < degree p\\<rbrakk>\n  \\<Longrightarrow> p \\<noteq> ?q * ?r\n\ngoal (1 subgoal):\n 1. degree p \\<noteq> 0 &&&\n    (\\<And>q r.\n        \\<lbrakk>degree q < degree p; degree r < degree p\\<rbrakk>\n        \\<Longrightarrow> p \\<noteq> q * r)", "by auto"], ["proof (state)\nthis:\n  degree p \\<noteq> 0\n  \\<lbrakk>degree ?q < degree p; degree ?r < degree p\\<rbrakk>\n  \\<Longrightarrow> p \\<noteq> ?q * ?r\n\ngoal (2 subgoals):\n 1. 0 < degree (of_int_poly p)\n 2. \\<And>q r.\n       \\<lbrakk>0 < degree q; degree q < degree (of_int_poly p);\n        0 < degree r; degree r < degree (of_int_poly p);\n        of_int_poly p = q * r\\<rbrakk>\n       \\<Longrightarrow> False", "let ?r = \"rat_of_int\""], ["proof (state)\ngoal (2 subgoals):\n 1. 0 < degree (of_int_poly p)\n 2. \\<And>q r.\n       \\<lbrakk>0 < degree q; degree q < degree (of_int_poly p);\n        0 < degree r; degree r < degree (of_int_poly p);\n        of_int_poly p = q * r\\<rbrakk>\n       \\<Longrightarrow> False", "let ?rp = \"map_poly ?r\""], ["proof (state)\ngoal (2 subgoals):\n 1. 0 < degree (of_int_poly p)\n 2. \\<And>q r.\n       \\<lbrakk>0 < degree q; degree q < degree (of_int_poly p);\n        0 < degree r; degree r < degree (of_int_poly p);\n        of_int_poly p = q * r\\<rbrakk>\n       \\<Longrightarrow> False", "from p"], ["proof (chain)\npicking this:\n  degree p \\<noteq> 0", "show rp: \"degree (?rp p) > 0\""], ["proof (prove)\nusing this:\n  degree p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 < degree (of_int_poly p)", "by auto"], ["proof (state)\nthis:\n  0 < degree (of_int_poly p)\n\ngoal (1 subgoal):\n 1. \\<And>q r.\n       \\<lbrakk>0 < degree q; degree q < degree (of_int_poly p);\n        0 < degree r; degree r < degree (of_int_poly p);\n        of_int_poly p = q * r\\<rbrakk>\n       \\<Longrightarrow> False", "from p"], ["proof (chain)\npicking this:\n  degree p \\<noteq> 0", "have p0: \"p \\<noteq> 0\""], ["proof (prove)\nusing this:\n  degree p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>q r.\n       \\<lbrakk>0 < degree q; degree q < degree (of_int_poly p);\n        0 < degree r; degree r < degree (of_int_poly p);\n        of_int_poly p = q * r\\<rbrakk>\n       \\<Longrightarrow> False", "fix g h :: \"rat poly\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>q r.\n       \\<lbrakk>0 < degree q; degree q < degree (of_int_poly p);\n        0 < degree r; degree r < degree (of_int_poly p);\n        of_int_poly p = q * r\\<rbrakk>\n       \\<Longrightarrow> False", "assume deg: \"degree g > 0\" \"degree g < degree (?rp p)\" \"degree h > 0\" \"degree h < degree (?rp p)\" and pgh: \"?rp p = g * h\""], ["proof (state)\nthis:\n  0 < degree g\n  degree g < degree (of_int_poly p)\n  0 < degree h\n  degree h < degree (of_int_poly p)\n  of_int_poly p = g * h\n\ngoal (1 subgoal):\n 1. \\<And>q r.\n       \\<lbrakk>0 < degree q; degree q < degree (of_int_poly p);\n        0 < degree r; degree r < degree (of_int_poly p);\n        of_int_poly p = q * r\\<rbrakk>\n       \\<Longrightarrow> False", "from rat_to_int_factor[OF pgh]"], ["proof (chain)\npicking this:\n  \\<exists>g' h'.\n     p = g' * h' \\<and> degree g' = degree g \\<and> degree h' = degree h", "obtain g' h' where p: \"p = g' * h'\" and dg: \"degree g' = degree g\" \"degree h' = degree h\""], ["proof (prove)\nusing this:\n  \\<exists>g' h'.\n     p = g' * h' \\<and> degree g' = degree g \\<and> degree h' = degree h\n\ngoal (1 subgoal):\n 1. (\\<And>g' h'.\n        \\<lbrakk>p = g' * h'; degree g' = degree g;\n         degree h' = degree h\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  p = g' * h'\n  degree g' = degree g\n  degree h' = degree h\n\ngoal (1 subgoal):\n 1. \\<And>q r.\n       \\<lbrakk>0 < degree q; degree q < degree (of_int_poly p);\n        0 < degree r; degree r < degree (of_int_poly p);\n        of_int_poly p = q * r\\<rbrakk>\n       \\<Longrightarrow> False", "from irr[of g' h'] deg[unfolded dg]"], ["proof (chain)\npicking this:\n  \\<lbrakk>degree g' < degree p; degree h' < degree p\\<rbrakk>\n  \\<Longrightarrow> p \\<noteq> g' * h'\n  0 < degree g\n  degree g < degree (of_int_poly p)\n  0 < degree h\n  degree h < degree (of_int_poly p)", "show False"], ["proof (prove)\nusing this:\n  \\<lbrakk>degree g' < degree p; degree h' < degree p\\<rbrakk>\n  \\<Longrightarrow> p \\<noteq> g' * h'\n  0 < degree g\n  degree g < degree (of_int_poly p)\n  0 < degree h\n  degree h < degree (of_int_poly p)\n\ngoal (1 subgoal):\n 1. False", "using degree_mult_eq[of g' h']"], ["proof (prove)\nusing this:\n  \\<lbrakk>degree g' < degree p; degree h' < degree p\\<rbrakk>\n  \\<Longrightarrow> p \\<noteq> g' * h'\n  0 < degree g\n  degree g < degree (of_int_poly p)\n  0 < degree h\n  degree h < degree (of_int_poly p)\n  \\<lbrakk>g' \\<noteq> 0; h' \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> degree (g' * h') = degree g' + degree h'\n\ngoal (1 subgoal):\n 1. False", "by (auto simp: p dg)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary irreducible\\<^sub>d_rat_to_normalized_int_poly: \n  assumes rp: \"rat_to_normalized_int_poly rp = (a, ip)\"\n  and ip: \"irreducible\\<^sub>d ip\"\n  shows \"irreducible\\<^sub>d rp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. irreducible\\<^sub>d rp", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. irreducible\\<^sub>d rp", "from rat_to_normalized_int_poly[OF rp]"], ["proof (chain)\npicking this:\n  rp = smult a (of_int_poly ip)\n  0 < a\n  rp \\<noteq> 0 \\<Longrightarrow> content ip = 1\n  degree ip = degree rp", "have rp: \"rp = smult a (map_poly rat_of_int ip)\" and a: \"a \\<noteq> 0\""], ["proof (prove)\nusing this:\n  rp = smult a (of_int_poly ip)\n  0 < a\n  rp \\<noteq> 0 \\<Longrightarrow> content ip = 1\n  degree ip = degree rp\n\ngoal (1 subgoal):\n 1. rp = smult a (of_int_poly ip) &&& a \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  rp = smult a (of_int_poly ip)\n  a \\<noteq> 0\n\ngoal (1 subgoal):\n 1. irreducible\\<^sub>d rp", "with irreducible\\<^sub>d_int_rat[OF ip]"], ["proof (chain)\npicking this:\n  irreducible\\<^sub>d (of_int_poly ip)\n  rp = smult a (of_int_poly ip)\n  a \\<noteq> 0", "show ?thesis"], ["proof (prove)\nusing this:\n  irreducible\\<^sub>d (of_int_poly ip)\n  rp = smult a (of_int_poly ip)\n  a \\<noteq> 0\n\ngoal (1 subgoal):\n 1. irreducible\\<^sub>d rp", "by auto"], ["proof (state)\nthis:\n  irreducible\\<^sub>d rp\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma dvd_content_dvd: assumes dvd: \"content f dvd content g\" \"primitive_part f dvd primitive_part g\"\n  shows \"f dvd g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f dvd g", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. f dvd g", "let ?cf = \"content f\""], ["proof (state)\ngoal (1 subgoal):\n 1. f dvd g", "let ?nf = \"primitive_part f\""], ["proof (state)\ngoal (1 subgoal):\n 1. f dvd g", "let ?cg = \"content g\""], ["proof (state)\ngoal (1 subgoal):\n 1. f dvd g", "let ?ng = \"primitive_part g\""], ["proof (state)\ngoal (1 subgoal):\n 1. f dvd g", "have \"f dvd g = (smult ?cf ?nf dvd smult ?cg ?ng)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f dvd g) =\n    (smult (content f) (primitive_part f) dvd\n     smult (content g) (primitive_part g))", "unfolding content_times_primitive_part"], ["proof (prove)\ngoal (1 subgoal):\n 1. (f dvd g) = (f dvd g)", "by auto"], ["proof (state)\nthis:\n  (f dvd g) =\n  (smult (content f) (primitive_part f) dvd\n   smult (content g) (primitive_part g))\n\ngoal (1 subgoal):\n 1. f dvd g", "from dvd(1)"], ["proof (chain)\npicking this:\n  content f dvd content g", "obtain ch where cg: \"?cg = ?cf * ch\""], ["proof (prove)\nusing this:\n  content f dvd content g\n\ngoal (1 subgoal):\n 1. (\\<And>ch.\n        content g = content f * ch \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding dvd_def"], ["proof (prove)\nusing this:\n  \\<exists>k. content g = content f * k\n\ngoal (1 subgoal):\n 1. (\\<And>ch.\n        content g = content f * ch \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  content g = content f * ch\n\ngoal (1 subgoal):\n 1. f dvd g", "from dvd(2)"], ["proof (chain)\npicking this:\n  primitive_part f dvd primitive_part g", "obtain nh where ng: \"?ng = ?nf * nh\""], ["proof (prove)\nusing this:\n  primitive_part f dvd primitive_part g\n\ngoal (1 subgoal):\n 1. (\\<And>nh.\n        primitive_part g = primitive_part f * nh \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding dvd_def"], ["proof (prove)\nusing this:\n  \\<exists>k. primitive_part g = primitive_part f * k\n\ngoal (1 subgoal):\n 1. (\\<And>nh.\n        primitive_part g = primitive_part f * nh \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  primitive_part g = primitive_part f * nh\n\ngoal (1 subgoal):\n 1. f dvd g", "have \"f dvd g = (smult ?cf ?nf dvd smult ?cg ?ng)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f dvd g) =\n    (smult (content f) (primitive_part f) dvd\n     smult (content g) (primitive_part g))", "unfolding content_times_primitive_part[of f] content_times_primitive_part[of g]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (f dvd g) = (f dvd g)", "by auto"], ["proof (state)\nthis:\n  (f dvd g) =\n  (smult (content f) (primitive_part f) dvd\n   smult (content g) (primitive_part g))\n\ngoal (1 subgoal):\n 1. f dvd g", "also"], ["proof (state)\nthis:\n  (f dvd g) =\n  (smult (content f) (primitive_part f) dvd\n   smult (content g) (primitive_part g))\n\ngoal (1 subgoal):\n 1. f dvd g", "have \"\\<dots> = (smult ?cf ?nf dvd smult ?cf ?nf * smult ch nh)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (smult (content f) (primitive_part f) dvd\n     smult (content g) (primitive_part g)) =\n    (smult (content f) (primitive_part f) dvd\n     smult (content f) (primitive_part f) * smult ch nh)", "unfolding cg ng"], ["proof (prove)\ngoal (1 subgoal):\n 1. (smult (content f) (primitive_part f) dvd\n     smult (content f * ch) (primitive_part f * nh)) =\n    (smult (content f) (primitive_part f) dvd\n     smult (content f) (primitive_part f) * smult ch nh)", "by (metis mult.commute mult_smult_right smult_smult)"], ["proof (state)\nthis:\n  (smult (content f) (primitive_part f) dvd\n   smult (content g) (primitive_part g)) =\n  (smult (content f) (primitive_part f) dvd\n   smult (content f) (primitive_part f) * smult ch nh)\n\ngoal (1 subgoal):\n 1. f dvd g", "also"], ["proof (state)\nthis:\n  (smult (content f) (primitive_part f) dvd\n   smult (content g) (primitive_part g)) =\n  (smult (content f) (primitive_part f) dvd\n   smult (content f) (primitive_part f) * smult ch nh)\n\ngoal (1 subgoal):\n 1. f dvd g", "have \"\\<dots>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. smult (content f) (primitive_part f) dvd\n    smult (content f) (primitive_part f) * smult ch nh", "by (rule dvd_triv_left)"], ["proof (state)\nthis:\n  smult (content f) (primitive_part f) dvd\n  smult (content f) (primitive_part f) * smult ch nh\n\ngoal (1 subgoal):\n 1. f dvd g", "finally"], ["proof (chain)\npicking this:\n  f dvd g", "show ?thesis"], ["proof (prove)\nusing this:\n  f dvd g\n\ngoal (1 subgoal):\n 1. f dvd g", "."], ["proof (state)\nthis:\n  f dvd g\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sdiv_poly_smult: \"c \\<noteq> 0 \\<Longrightarrow> sdiv_poly (smult c f) c = f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c \\<noteq> (0::'a) \\<Longrightarrow> sdiv_poly (smult c f) c = f", "by (intro poly_eqI, unfold coeff_sdiv_poly coeff_smult, auto)"], ["", "lemma primitive_part_smult_int: fixes f :: \"int poly\" shows\n  \"primitive_part (smult d f) = smult (sgn d) (primitive_part f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. primitive_part (smult d f) = smult (sgn d) (primitive_part f)", "proof (cases \"d = 0 \\<or> f = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. d = 0 \\<or> f = 0 \\<Longrightarrow>\n    primitive_part (smult d f) = smult (sgn d) (primitive_part f)\n 2. \\<not> (d = 0 \\<or> f = 0) \\<Longrightarrow>\n    primitive_part (smult d f) = smult (sgn d) (primitive_part f)", "case False"], ["proof (state)\nthis:\n  \\<not> (d = 0 \\<or> f = 0)\n\ngoal (2 subgoals):\n 1. d = 0 \\<or> f = 0 \\<Longrightarrow>\n    primitive_part (smult d f) = smult (sgn d) (primitive_part f)\n 2. \\<not> (d = 0 \\<or> f = 0) \\<Longrightarrow>\n    primitive_part (smult d f) = smult (sgn d) (primitive_part f)", "obtain cf where cf: \"content f = cf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>cf. content f = cf \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  content f = cf\n\ngoal (2 subgoals):\n 1. d = 0 \\<or> f = 0 \\<Longrightarrow>\n    primitive_part (smult d f) = smult (sgn d) (primitive_part f)\n 2. \\<not> (d = 0 \\<or> f = 0) \\<Longrightarrow>\n    primitive_part (smult d f) = smult (sgn d) (primitive_part f)", "with False"], ["proof (chain)\npicking this:\n  \\<not> (d = 0 \\<or> f = 0)\n  content f = cf", "have 0: \"d \\<noteq> 0\" \"f \\<noteq> 0\" \"cf \\<noteq> 0\""], ["proof (prove)\nusing this:\n  \\<not> (d = 0 \\<or> f = 0)\n  content f = cf\n\ngoal (1 subgoal):\n 1. d \\<noteq> 0 &&& f \\<noteq> 0 &&& cf \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  d \\<noteq> 0\n  f \\<noteq> 0\n  cf \\<noteq> 0\n\ngoal (2 subgoals):\n 1. d = 0 \\<or> f = 0 \\<Longrightarrow>\n    primitive_part (smult d f) = smult (sgn d) (primitive_part f)\n 2. \\<not> (d = 0 \\<or> f = 0) \\<Longrightarrow>\n    primitive_part (smult d f) = smult (sgn d) (primitive_part f)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. primitive_part (smult d f) = smult (sgn d) (primitive_part f)", "proof (rule poly_eqI, unfold primitive_part_alt_def coeff_sdiv_poly content_smult_int coeff_smult cf)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       d * coeff f n div (\\<bar>d\\<bar> * cf) = sgn d * (coeff f n div cf)", "fix n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       d * coeff f n div (\\<bar>d\\<bar> * cf) = sgn d * (coeff f n div cf)", "consider (pos) \"d > 0\" | (neg) \"d < 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < d \\<Longrightarrow> thesis;\n     d < 0 \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "using 0(1)"], ["proof (prove)\nusing this:\n  d \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < d \\<Longrightarrow> thesis;\n     d < 0 \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by linarith"], ["proof (state)\nthis:\n  \\<lbrakk>0 < d \\<Longrightarrow> ?thesis;\n   d < 0 \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       d * coeff f n div (\\<bar>d\\<bar> * cf) = sgn d * (coeff f n div cf)", "thus \"d * coeff f n div (\\<bar>d\\<bar> * cf) = sgn d * (coeff f n div cf)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>0 < d \\<Longrightarrow> ?thesis;\n   d < 0 \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. d * coeff f n div (\\<bar>d\\<bar> * cf) = sgn d * (coeff f n div cf)", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 < d \\<Longrightarrow>\n    d * coeff f n div (\\<bar>d\\<bar> * cf) = sgn d * (coeff f n div cf)\n 2. d < 0 \\<Longrightarrow>\n    d * coeff f n div (\\<bar>d\\<bar> * cf) = sgn d * (coeff f n div cf)", "case neg"], ["proof (state)\nthis:\n  d < 0\n\ngoal (2 subgoals):\n 1. 0 < d \\<Longrightarrow>\n    d * coeff f n div (\\<bar>d\\<bar> * cf) = sgn d * (coeff f n div cf)\n 2. d < 0 \\<Longrightarrow>\n    d * coeff f n div (\\<bar>d\\<bar> * cf) = sgn d * (coeff f n div cf)", "hence \"?thesis = (d * coeff f n div - (d * cf) = - (coeff f n div cf))\""], ["proof (prove)\nusing this:\n  d < 0\n\ngoal (1 subgoal):\n 1. (d * coeff f n div (\\<bar>d\\<bar> * cf) = sgn d * (coeff f n div cf)) =\n    (d * coeff f n div - (d * cf) = - (coeff f n div cf))", "by auto"], ["proof (state)\nthis:\n  (d * coeff f n div (\\<bar>d\\<bar> * cf) = sgn d * (coeff f n div cf)) =\n  (d * coeff f n div - (d * cf) = - (coeff f n div cf))\n\ngoal (2 subgoals):\n 1. 0 < d \\<Longrightarrow>\n    d * coeff f n div (\\<bar>d\\<bar> * cf) = sgn d * (coeff f n div cf)\n 2. d < 0 \\<Longrightarrow>\n    d * coeff f n div (\\<bar>d\\<bar> * cf) = sgn d * (coeff f n div cf)", "also"], ["proof (state)\nthis:\n  (d * coeff f n div (\\<bar>d\\<bar> * cf) = sgn d * (coeff f n div cf)) =\n  (d * coeff f n div - (d * cf) = - (coeff f n div cf))\n\ngoal (2 subgoals):\n 1. 0 < d \\<Longrightarrow>\n    d * coeff f n div (\\<bar>d\\<bar> * cf) = sgn d * (coeff f n div cf)\n 2. d < 0 \\<Longrightarrow>\n    d * coeff f n div (\\<bar>d\\<bar> * cf) = sgn d * (coeff f n div cf)", "have \"d * coeff f n div - (d * cf) = - (d * coeff f n div (d * cf))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d * coeff f n div - (d * cf) = - (d * coeff f n div (d * cf))", "by (subst dvd_div_neg, insert 0(1), auto simp: cf[symmetric])"], ["proof (state)\nthis:\n  d * coeff f n div - (d * cf) = - (d * coeff f n div (d * cf))\n\ngoal (2 subgoals):\n 1. 0 < d \\<Longrightarrow>\n    d * coeff f n div (\\<bar>d\\<bar> * cf) = sgn d * (coeff f n div cf)\n 2. d < 0 \\<Longrightarrow>\n    d * coeff f n div (\\<bar>d\\<bar> * cf) = sgn d * (coeff f n div cf)", "also"], ["proof (state)\nthis:\n  d * coeff f n div - (d * cf) = - (d * coeff f n div (d * cf))\n\ngoal (2 subgoals):\n 1. 0 < d \\<Longrightarrow>\n    d * coeff f n div (\\<bar>d\\<bar> * cf) = sgn d * (coeff f n div cf)\n 2. d < 0 \\<Longrightarrow>\n    d * coeff f n div (\\<bar>d\\<bar> * cf) = sgn d * (coeff f n div cf)", "have \"d * coeff f n div (d * cf) = coeff f n div cf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d * coeff f n div (d * cf) = coeff f n div cf", "using 0(1)"], ["proof (prove)\nusing this:\n  d \\<noteq> 0\n\ngoal (1 subgoal):\n 1. d * coeff f n div (d * cf) = coeff f n div cf", "by auto"], ["proof (state)\nthis:\n  d * coeff f n div (d * cf) = coeff f n div cf\n\ngoal (2 subgoals):\n 1. 0 < d \\<Longrightarrow>\n    d * coeff f n div (\\<bar>d\\<bar> * cf) = sgn d * (coeff f n div cf)\n 2. d < 0 \\<Longrightarrow>\n    d * coeff f n div (\\<bar>d\\<bar> * cf) = sgn d * (coeff f n div cf)", "finally"], ["proof (chain)\npicking this:\n  (d * coeff f n div (\\<bar>d\\<bar> * cf) = sgn d * (coeff f n div cf)) =\n  (- (coeff f n div cf) = - (coeff f n div cf))", "show ?thesis"], ["proof (prove)\nusing this:\n  (d * coeff f n div (\\<bar>d\\<bar> * cf) = sgn d * (coeff f n div cf)) =\n  (- (coeff f n div cf) = - (coeff f n div cf))\n\ngoal (1 subgoal):\n 1. d * coeff f n div (\\<bar>d\\<bar> * cf) = sgn d * (coeff f n div cf)", "by simp"], ["proof (state)\nthis:\n  d * coeff f n div (\\<bar>d\\<bar> * cf) = sgn d * (coeff f n div cf)\n\ngoal (1 subgoal):\n 1. 0 < d \\<Longrightarrow>\n    d * coeff f n div (\\<bar>d\\<bar> * cf) = sgn d * (coeff f n div cf)", "qed auto"], ["proof (state)\nthis:\n  d * coeff f n div (\\<bar>d\\<bar> * cf) = sgn d * (coeff f n div cf)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  primitive_part (smult d f) = smult (sgn d) (primitive_part f)\n\ngoal (1 subgoal):\n 1. d = 0 \\<or> f = 0 \\<Longrightarrow>\n    primitive_part (smult d f) = smult (sgn d) (primitive_part f)", "qed auto"], ["", "lemma gcd_smult_left: assumes \"c \\<noteq> 0\"\n  shows \"gcd (smult c f) g = gcd f (g :: 'b :: {field_gcd} poly)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gcd (smult c f) g = gcd f g", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. gcd (smult c f) g = gcd f g", "from assms"], ["proof (chain)\npicking this:\n  c \\<noteq> (0::'b)", "have \"normalize c = 1\""], ["proof (prove)\nusing this:\n  c \\<noteq> (0::'b)\n\ngoal (1 subgoal):\n 1. normalize c = (1::'b)", "by (meson dvd_field_iff is_unit_normalize)"], ["proof (state)\nthis:\n  normalize c = (1::'b)\n\ngoal (1 subgoal):\n 1. gcd (smult c f) g = gcd f g", "then"], ["proof (chain)\npicking this:\n  normalize c = (1::'b)", "show ?thesis"], ["proof (prove)\nusing this:\n  normalize c = (1::'b)\n\ngoal (1 subgoal):\n 1. gcd (smult c f) g = gcd f g", "by (metis (no_types) Polynomial.normalize_smult gcd.commute gcd.left_commute gcd_left_idem gcd_self smult_1_left)"], ["proof (state)\nthis:\n  gcd (smult c f) g = gcd f g\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma gcd_smult_right: \"c \\<noteq> 0 \\<Longrightarrow> gcd f (smult c g) = gcd f (g :: 'b :: {field_gcd} poly)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c \\<noteq> (0::'b) \\<Longrightarrow> gcd f (smult c g) = gcd f g", "using gcd_smult_left[of c g f]"], ["proof (prove)\nusing this:\n  c \\<noteq> (0::'b) \\<Longrightarrow> gcd (smult c g) f = gcd g f\n\ngoal (1 subgoal):\n 1. c \\<noteq> (0::'b) \\<Longrightarrow> gcd f (smult c g) = gcd f g", "by (simp add: gcd.commute)"], ["", "lemma gcd_rat_to_gcd_int: \"gcd (of_int_poly f :: rat poly) (of_int_poly g) = \n  smult (inverse (of_int (lead_coeff (gcd f g)))) (of_int_poly (gcd f g))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gcd (of_int_poly f) (of_int_poly g) =\n    smult (inverse (rat_of_int (lead_coeff (gcd f g))))\n     (of_int_poly (gcd f g))", "proof (cases \"f = 0 \\<and> g = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. f = 0 \\<and> g = 0 \\<Longrightarrow>\n    gcd (of_int_poly f) (of_int_poly g) =\n    smult (inverse (rat_of_int (lead_coeff (gcd f g))))\n     (of_int_poly (gcd f g))\n 2. \\<not> (f = 0 \\<and> g = 0) \\<Longrightarrow>\n    gcd (of_int_poly f) (of_int_poly g) =\n    smult (inverse (rat_of_int (lead_coeff (gcd f g))))\n     (of_int_poly (gcd f g))", "case True"], ["proof (state)\nthis:\n  f = 0 \\<and> g = 0\n\ngoal (2 subgoals):\n 1. f = 0 \\<and> g = 0 \\<Longrightarrow>\n    gcd (of_int_poly f) (of_int_poly g) =\n    smult (inverse (rat_of_int (lead_coeff (gcd f g))))\n     (of_int_poly (gcd f g))\n 2. \\<not> (f = 0 \\<and> g = 0) \\<Longrightarrow>\n    gcd (of_int_poly f) (of_int_poly g) =\n    smult (inverse (rat_of_int (lead_coeff (gcd f g))))\n     (of_int_poly (gcd f g))", "thus ?thesis"], ["proof (prove)\nusing this:\n  f = 0 \\<and> g = 0\n\ngoal (1 subgoal):\n 1. gcd (of_int_poly f) (of_int_poly g) =\n    smult (inverse (rat_of_int (lead_coeff (gcd f g))))\n     (of_int_poly (gcd f g))", "by simp"], ["proof (state)\nthis:\n  gcd (of_int_poly f) (of_int_poly g) =\n  smult (inverse (rat_of_int (lead_coeff (gcd f g))))\n   (of_int_poly (gcd f g))\n\ngoal (1 subgoal):\n 1. \\<not> (f = 0 \\<and> g = 0) \\<Longrightarrow>\n    gcd (of_int_poly f) (of_int_poly g) =\n    smult (inverse (rat_of_int (lead_coeff (gcd f g))))\n     (of_int_poly (gcd f g))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (f = 0 \\<and> g = 0) \\<Longrightarrow>\n    gcd (of_int_poly f) (of_int_poly g) =\n    smult (inverse (rat_of_int (lead_coeff (gcd f g))))\n     (of_int_poly (gcd f g))", "case False"], ["proof (state)\nthis:\n  \\<not> (f = 0 \\<and> g = 0)\n\ngoal (1 subgoal):\n 1. \\<not> (f = 0 \\<and> g = 0) \\<Longrightarrow>\n    gcd (of_int_poly f) (of_int_poly g) =\n    smult (inverse (rat_of_int (lead_coeff (gcd f g))))\n     (of_int_poly (gcd f g))", "let ?r = rat_of_int"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (f = 0 \\<and> g = 0) \\<Longrightarrow>\n    gcd (of_int_poly f) (of_int_poly g) =\n    smult (inverse (rat_of_int (lead_coeff (gcd f g))))\n     (of_int_poly (gcd f g))", "let ?rp = \"map_poly ?r\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (f = 0 \\<and> g = 0) \\<Longrightarrow>\n    gcd (of_int_poly f) (of_int_poly g) =\n    smult (inverse (rat_of_int (lead_coeff (gcd f g))))\n     (of_int_poly (gcd f g))", "from False"], ["proof (chain)\npicking this:\n  \\<not> (f = 0 \\<and> g = 0)", "have gcd0: \"gcd f g \\<noteq> 0\""], ["proof (prove)\nusing this:\n  \\<not> (f = 0 \\<and> g = 0)\n\ngoal (1 subgoal):\n 1. gcd f g \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  gcd f g \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> (f = 0 \\<and> g = 0) \\<Longrightarrow>\n    gcd (of_int_poly f) (of_int_poly g) =\n    smult (inverse (rat_of_int (lead_coeff (gcd f g))))\n     (of_int_poly (gcd f g))", "hence lc0: \"lead_coeff (gcd f g) \\<noteq> 0\""], ["proof (prove)\nusing this:\n  gcd f g \\<noteq> 0\n\ngoal (1 subgoal):\n 1. lead_coeff (gcd f g) \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  lead_coeff (gcd f g) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> (f = 0 \\<and> g = 0) \\<Longrightarrow>\n    gcd (of_int_poly f) (of_int_poly g) =\n    smult (inverse (rat_of_int (lead_coeff (gcd f g))))\n     (of_int_poly (gcd f g))", "hence inv: \"inverse (?r (lead_coeff (gcd f g))) \\<noteq> 0\""], ["proof (prove)\nusing this:\n  lead_coeff (gcd f g) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. inverse (rat_of_int (lead_coeff (gcd f g))) \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  inverse (rat_of_int (lead_coeff (gcd f g))) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> (f = 0 \\<and> g = 0) \\<Longrightarrow>\n    gcd (of_int_poly f) (of_int_poly g) =\n    smult (inverse (rat_of_int (lead_coeff (gcd f g))))\n     (of_int_poly (gcd f g))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. gcd (of_int_poly f) (of_int_poly g) =\n    smult (inverse (rat_of_int (lead_coeff (gcd f g))))\n     (of_int_poly (gcd f g))", "proof (rule sym, rule gcdI, goal_cases)"], ["proof (state)\ngoal (4 subgoals):\n 1. smult (inverse (rat_of_int (lead_coeff (gcd f g))))\n     (of_int_poly (gcd f g)) dvd\n    of_int_poly f\n 2. smult (inverse (rat_of_int (lead_coeff (gcd f g))))\n     (of_int_poly (gcd f g)) dvd\n    of_int_poly g\n 3. \\<And>d.\n       \\<lbrakk>d dvd of_int_poly f; d dvd of_int_poly g\\<rbrakk>\n       \\<Longrightarrow> d dvd\n                         smult (inverse (rat_of_int (lead_coeff (gcd f g))))\n                          (of_int_poly (gcd f g))\n 4. normalize\n     (smult (inverse (rat_of_int (lead_coeff (gcd f g))))\n       (of_int_poly (gcd f g))) =\n    smult (inverse (rat_of_int (lead_coeff (gcd f g))))\n     (of_int_poly (gcd f g))", "case 1"], ["proof (state)\nthis:\n  \n\ngoal (4 subgoals):\n 1. smult (inverse (rat_of_int (lead_coeff (gcd f g))))\n     (of_int_poly (gcd f g)) dvd\n    of_int_poly f\n 2. smult (inverse (rat_of_int (lead_coeff (gcd f g))))\n     (of_int_poly (gcd f g)) dvd\n    of_int_poly g\n 3. \\<And>d.\n       \\<lbrakk>d dvd of_int_poly f; d dvd of_int_poly g\\<rbrakk>\n       \\<Longrightarrow> d dvd\n                         smult (inverse (rat_of_int (lead_coeff (gcd f g))))\n                          (of_int_poly (gcd f g))\n 4. normalize\n     (smult (inverse (rat_of_int (lead_coeff (gcd f g))))\n       (of_int_poly (gcd f g))) =\n    smult (inverse (rat_of_int (lead_coeff (gcd f g))))\n     (of_int_poly (gcd f g))", "have \"gcd f g dvd f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gcd f g dvd f", "by auto"], ["proof (state)\nthis:\n  gcd f g dvd f\n\ngoal (4 subgoals):\n 1. smult (inverse (rat_of_int (lead_coeff (gcd f g))))\n     (of_int_poly (gcd f g)) dvd\n    of_int_poly f\n 2. smult (inverse (rat_of_int (lead_coeff (gcd f g))))\n     (of_int_poly (gcd f g)) dvd\n    of_int_poly g\n 3. \\<And>d.\n       \\<lbrakk>d dvd of_int_poly f; d dvd of_int_poly g\\<rbrakk>\n       \\<Longrightarrow> d dvd\n                         smult (inverse (rat_of_int (lead_coeff (gcd f g))))\n                          (of_int_poly (gcd f g))\n 4. normalize\n     (smult (inverse (rat_of_int (lead_coeff (gcd f g))))\n       (of_int_poly (gcd f g))) =\n    smult (inverse (rat_of_int (lead_coeff (gcd f g))))\n     (of_int_poly (gcd f g))", "then"], ["proof (chain)\npicking this:\n  gcd f g dvd f", "obtain h where f: \"f = gcd f g * h\""], ["proof (prove)\nusing this:\n  gcd f g dvd f\n\ngoal (1 subgoal):\n 1. (\\<And>h. f = gcd f g * h \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding dvd_def"], ["proof (prove)\nusing this:\n  \\<exists>k. f = gcd f g * k\n\ngoal (1 subgoal):\n 1. (\\<And>h. f = gcd f g * h \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  f = gcd f g * h\n\ngoal (4 subgoals):\n 1. smult (inverse (rat_of_int (lead_coeff (gcd f g))))\n     (of_int_poly (gcd f g)) dvd\n    of_int_poly f\n 2. smult (inverse (rat_of_int (lead_coeff (gcd f g))))\n     (of_int_poly (gcd f g)) dvd\n    of_int_poly g\n 3. \\<And>d.\n       \\<lbrakk>d dvd of_int_poly f; d dvd of_int_poly g\\<rbrakk>\n       \\<Longrightarrow> d dvd\n                         smult (inverse (rat_of_int (lead_coeff (gcd f g))))\n                          (of_int_poly (gcd f g))\n 4. normalize\n     (smult (inverse (rat_of_int (lead_coeff (gcd f g))))\n       (of_int_poly (gcd f g))) =\n    smult (inverse (rat_of_int (lead_coeff (gcd f g))))\n     (of_int_poly (gcd f g))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. smult (inverse (rat_of_int (lead_coeff (gcd f g))))\n     (of_int_poly (gcd f g)) dvd\n    of_int_poly f", "by (rule smult_dvd[OF _ inv], insert arg_cong[OF f, of ?rp], simp add: hom_distribs)"], ["proof (state)\nthis:\n  smult (inverse (rat_of_int (lead_coeff (gcd f g))))\n   (of_int_poly (gcd f g)) dvd\n  of_int_poly f\n\ngoal (3 subgoals):\n 1. smult (inverse (rat_of_int (lead_coeff (gcd f g))))\n     (of_int_poly (gcd f g)) dvd\n    of_int_poly g\n 2. \\<And>d.\n       \\<lbrakk>d dvd of_int_poly f; d dvd of_int_poly g\\<rbrakk>\n       \\<Longrightarrow> d dvd\n                         smult (inverse (rat_of_int (lead_coeff (gcd f g))))\n                          (of_int_poly (gcd f g))\n 3. normalize\n     (smult (inverse (rat_of_int (lead_coeff (gcd f g))))\n       (of_int_poly (gcd f g))) =\n    smult (inverse (rat_of_int (lead_coeff (gcd f g))))\n     (of_int_poly (gcd f g))", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. smult (inverse (rat_of_int (lead_coeff (gcd f g))))\n     (of_int_poly (gcd f g)) dvd\n    of_int_poly g\n 2. \\<And>d.\n       \\<lbrakk>d dvd of_int_poly f; d dvd of_int_poly g\\<rbrakk>\n       \\<Longrightarrow> d dvd\n                         smult (inverse (rat_of_int (lead_coeff (gcd f g))))\n                          (of_int_poly (gcd f g))\n 3. normalize\n     (smult (inverse (rat_of_int (lead_coeff (gcd f g))))\n       (of_int_poly (gcd f g))) =\n    smult (inverse (rat_of_int (lead_coeff (gcd f g))))\n     (of_int_poly (gcd f g))", "case 2"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. smult (inverse (rat_of_int (lead_coeff (gcd f g))))\n     (of_int_poly (gcd f g)) dvd\n    of_int_poly g\n 2. \\<And>d.\n       \\<lbrakk>d dvd of_int_poly f; d dvd of_int_poly g\\<rbrakk>\n       \\<Longrightarrow> d dvd\n                         smult (inverse (rat_of_int (lead_coeff (gcd f g))))\n                          (of_int_poly (gcd f g))\n 3. normalize\n     (smult (inverse (rat_of_int (lead_coeff (gcd f g))))\n       (of_int_poly (gcd f g))) =\n    smult (inverse (rat_of_int (lead_coeff (gcd f g))))\n     (of_int_poly (gcd f g))", "have \"gcd f g dvd g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gcd f g dvd g", "by auto"], ["proof (state)\nthis:\n  gcd f g dvd g\n\ngoal (3 subgoals):\n 1. smult (inverse (rat_of_int (lead_coeff (gcd f g))))\n     (of_int_poly (gcd f g)) dvd\n    of_int_poly g\n 2. \\<And>d.\n       \\<lbrakk>d dvd of_int_poly f; d dvd of_int_poly g\\<rbrakk>\n       \\<Longrightarrow> d dvd\n                         smult (inverse (rat_of_int (lead_coeff (gcd f g))))\n                          (of_int_poly (gcd f g))\n 3. normalize\n     (smult (inverse (rat_of_int (lead_coeff (gcd f g))))\n       (of_int_poly (gcd f g))) =\n    smult (inverse (rat_of_int (lead_coeff (gcd f g))))\n     (of_int_poly (gcd f g))", "then"], ["proof (chain)\npicking this:\n  gcd f g dvd g", "obtain h where g: \"g = gcd f g * h\""], ["proof (prove)\nusing this:\n  gcd f g dvd g\n\ngoal (1 subgoal):\n 1. (\\<And>h. g = gcd f g * h \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding dvd_def"], ["proof (prove)\nusing this:\n  \\<exists>k. g = gcd f g * k\n\ngoal (1 subgoal):\n 1. (\\<And>h. g = gcd f g * h \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  g = gcd f g * h\n\ngoal (3 subgoals):\n 1. smult (inverse (rat_of_int (lead_coeff (gcd f g))))\n     (of_int_poly (gcd f g)) dvd\n    of_int_poly g\n 2. \\<And>d.\n       \\<lbrakk>d dvd of_int_poly f; d dvd of_int_poly g\\<rbrakk>\n       \\<Longrightarrow> d dvd\n                         smult (inverse (rat_of_int (lead_coeff (gcd f g))))\n                          (of_int_poly (gcd f g))\n 3. normalize\n     (smult (inverse (rat_of_int (lead_coeff (gcd f g))))\n       (of_int_poly (gcd f g))) =\n    smult (inverse (rat_of_int (lead_coeff (gcd f g))))\n     (of_int_poly (gcd f g))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. smult (inverse (rat_of_int (lead_coeff (gcd f g))))\n     (of_int_poly (gcd f g)) dvd\n    of_int_poly g", "by (rule smult_dvd[OF _ inv], insert arg_cong[OF g, of ?rp], simp add: hom_distribs)"], ["proof (state)\nthis:\n  smult (inverse (rat_of_int (lead_coeff (gcd f g))))\n   (of_int_poly (gcd f g)) dvd\n  of_int_poly g\n\ngoal (2 subgoals):\n 1. \\<And>d.\n       \\<lbrakk>d dvd of_int_poly f; d dvd of_int_poly g\\<rbrakk>\n       \\<Longrightarrow> d dvd\n                         smult (inverse (rat_of_int (lead_coeff (gcd f g))))\n                          (of_int_poly (gcd f g))\n 2. normalize\n     (smult (inverse (rat_of_int (lead_coeff (gcd f g))))\n       (of_int_poly (gcd f g))) =\n    smult (inverse (rat_of_int (lead_coeff (gcd f g))))\n     (of_int_poly (gcd f g))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>d.\n       \\<lbrakk>d dvd of_int_poly f; d dvd of_int_poly g\\<rbrakk>\n       \\<Longrightarrow> d dvd\n                         smult (inverse (rat_of_int (lead_coeff (gcd f g))))\n                          (of_int_poly (gcd f g))\n 2. normalize\n     (smult (inverse (rat_of_int (lead_coeff (gcd f g))))\n       (of_int_poly (gcd f g))) =\n    smult (inverse (rat_of_int (lead_coeff (gcd f g))))\n     (of_int_poly (gcd f g))", "case (3 h)"], ["proof (state)\nthis:\n  h dvd of_int_poly f\n  h dvd of_int_poly g\n\ngoal (2 subgoals):\n 1. \\<And>d.\n       \\<lbrakk>d dvd of_int_poly f; d dvd of_int_poly g\\<rbrakk>\n       \\<Longrightarrow> d dvd\n                         smult (inverse (rat_of_int (lead_coeff (gcd f g))))\n                          (of_int_poly (gcd f g))\n 2. normalize\n     (smult (inverse (rat_of_int (lead_coeff (gcd f g))))\n       (of_int_poly (gcd f g))) =\n    smult (inverse (rat_of_int (lead_coeff (gcd f g))))\n     (of_int_poly (gcd f g))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. h dvd\n    smult (inverse (rat_of_int (lead_coeff (gcd f g))))\n     (of_int_poly (gcd f g))", "proof (rule dvd_smult)"], ["proof (state)\ngoal (1 subgoal):\n 1. h dvd of_int_poly (gcd f g)", "obtain ch ph where h: \"rat_to_normalized_int_poly h = (ch, ph)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ch ph.\n        rat_to_normalized_int_poly h = (ch, ph) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  rat_to_normalized_int_poly h = (ch, ph)\n\ngoal (1 subgoal):\n 1. h dvd of_int_poly (gcd f g)", "from 3"], ["proof (chain)\npicking this:\n  h dvd of_int_poly f\n  h dvd of_int_poly g", "obtain ff where f: \"?rp f = h * ff\""], ["proof (prove)\nusing this:\n  h dvd of_int_poly f\n  h dvd of_int_poly g\n\ngoal (1 subgoal):\n 1. (\\<And>ff.\n        of_int_poly f = h * ff \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding dvd_def"], ["proof (prove)\nusing this:\n  \\<exists>k. of_int_poly f = h * k\n  \\<exists>k. of_int_poly g = h * k\n\ngoal (1 subgoal):\n 1. (\\<And>ff.\n        of_int_poly f = h * ff \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  of_int_poly f = h * ff\n\ngoal (1 subgoal):\n 1. h dvd of_int_poly (gcd f g)", "from 3"], ["proof (chain)\npicking this:\n  h dvd of_int_poly f\n  h dvd of_int_poly g", "obtain gg where g: \"?rp g = h * gg\""], ["proof (prove)\nusing this:\n  h dvd of_int_poly f\n  h dvd of_int_poly g\n\ngoal (1 subgoal):\n 1. (\\<And>gg.\n        of_int_poly g = h * gg \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding dvd_def"], ["proof (prove)\nusing this:\n  \\<exists>k. of_int_poly f = h * k\n  \\<exists>k. of_int_poly g = h * k\n\ngoal (1 subgoal):\n 1. (\\<And>gg.\n        of_int_poly g = h * gg \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  of_int_poly g = h * gg\n\ngoal (1 subgoal):\n 1. h dvd of_int_poly (gcd f g)", "from rat_to_int_factor_explicit[OF f h]"], ["proof (chain)\npicking this:\n  \\<exists>r. f = ph * smult (content f) r", "obtain f' where f: \"f = ph * f'\""], ["proof (prove)\nusing this:\n  \\<exists>r. f = ph * smult (content f) r\n\ngoal (1 subgoal):\n 1. (\\<And>f'. f = ph * f' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  f = ph * f'\n\ngoal (1 subgoal):\n 1. h dvd of_int_poly (gcd f g)", "from rat_to_int_factor_explicit[OF g h]"], ["proof (chain)\npicking this:\n  \\<exists>r. g = ph * smult (content g) r", "obtain g' where g: \"g = ph * g'\""], ["proof (prove)\nusing this:\n  \\<exists>r. g = ph * smult (content g) r\n\ngoal (1 subgoal):\n 1. (\\<And>g'. g = ph * g' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  g = ph * g'\n\ngoal (1 subgoal):\n 1. h dvd of_int_poly (gcd f g)", "from f g"], ["proof (chain)\npicking this:\n  f = ph * f'\n  g = ph * g'", "have \"ph dvd gcd f g\""], ["proof (prove)\nusing this:\n  f = ph * f'\n  g = ph * g'\n\ngoal (1 subgoal):\n 1. ph dvd gcd f g", "by auto"], ["proof (state)\nthis:\n  ph dvd gcd f g\n\ngoal (1 subgoal):\n 1. h dvd of_int_poly (gcd f g)", "then"], ["proof (chain)\npicking this:\n  ph dvd gcd f g", "obtain gg where gcd: \"gcd f g = ph * gg\""], ["proof (prove)\nusing this:\n  ph dvd gcd f g\n\ngoal (1 subgoal):\n 1. (\\<And>gg. gcd f g = ph * gg \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding dvd_def"], ["proof (prove)\nusing this:\n  \\<exists>k. gcd f g = ph * k\n\ngoal (1 subgoal):\n 1. (\\<And>gg. gcd f g = ph * gg \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  gcd f g = ph * gg\n\ngoal (1 subgoal):\n 1. h dvd of_int_poly (gcd f g)", "note * = rat_to_normalized_int_poly[OF h]"], ["proof (state)\nthis:\n  h = smult ch (of_int_poly ph)\n  0 < ch\n  h \\<noteq> 0 \\<Longrightarrow> content ph = 1\n  degree ph = degree h\n\ngoal (1 subgoal):\n 1. h dvd of_int_poly (gcd f g)", "show \"h dvd ?rp (gcd f g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h dvd of_int_poly (gcd f g)", "unfolding gcd *(1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. smult ch (of_int_poly ph) dvd of_int_poly (ph * gg)", "by (rule smult_dvd, insert *(2), auto)"], ["proof (state)\nthis:\n  h dvd of_int_poly (gcd f g)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  h dvd\n  smult (inverse (rat_of_int (lead_coeff (gcd f g))))\n   (of_int_poly (gcd f g))\n\ngoal (1 subgoal):\n 1. normalize\n     (smult (inverse (rat_of_int (lead_coeff (gcd f g))))\n       (of_int_poly (gcd f g))) =\n    smult (inverse (rat_of_int (lead_coeff (gcd f g))))\n     (of_int_poly (gcd f g))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. normalize\n     (smult (inverse (rat_of_int (lead_coeff (gcd f g))))\n       (of_int_poly (gcd f g))) =\n    smult (inverse (rat_of_int (lead_coeff (gcd f g))))\n     (of_int_poly (gcd f g))", "case 4"], ["proof (state)\nthis:\n  \n\ngoal (1 subgoal):\n 1. normalize\n     (smult (inverse (rat_of_int (lead_coeff (gcd f g))))\n       (of_int_poly (gcd f g))) =\n    smult (inverse (rat_of_int (lead_coeff (gcd f g))))\n     (of_int_poly (gcd f g))", "have [simp]: \"[:1:] = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [:1::'a:] = 1", "by simp"], ["proof (state)\nthis:\n  [:1::?'a1:] = 1\n\ngoal (1 subgoal):\n 1. normalize\n     (smult (inverse (rat_of_int (lead_coeff (gcd f g))))\n       (of_int_poly (gcd f g))) =\n    smult (inverse (rat_of_int (lead_coeff (gcd f g))))\n     (of_int_poly (gcd f g))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. normalize\n     (smult (inverse (rat_of_int (lead_coeff (gcd f g))))\n       (of_int_poly (gcd f g))) =\n    smult (inverse (rat_of_int (lead_coeff (gcd f g))))\n     (of_int_poly (gcd f g))", "unfolding normalize_poly_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. smult (inverse (rat_of_int (lead_coeff (gcd f g))))\n     (of_int_poly (gcd f g)) div\n    [:unit_factor\n       (lead_coeff\n         (smult (inverse (rat_of_int (lead_coeff (gcd f g))))\n           (of_int_poly (gcd f g)))):] =\n    smult (inverse (rat_of_int (lead_coeff (gcd f g))))\n     (of_int_poly (gcd f g))", "by (rule poly_eqI, simp)"], ["proof (state)\nthis:\n  normalize\n   (smult (inverse (rat_of_int (lead_coeff (gcd f g))))\n     (of_int_poly (gcd f g))) =\n  smult (inverse (rat_of_int (lead_coeff (gcd f g))))\n   (of_int_poly (gcd f g))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  gcd (of_int_poly f) (of_int_poly g) =\n  smult (inverse (rat_of_int (lead_coeff (gcd f g))))\n   (of_int_poly (gcd f g))\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}