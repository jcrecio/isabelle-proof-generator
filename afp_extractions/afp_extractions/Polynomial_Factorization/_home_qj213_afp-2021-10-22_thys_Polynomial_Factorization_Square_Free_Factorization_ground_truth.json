{"file_name": "/home/qj213/afp-2021-10-22/thys/Polynomial_Factorization/Square_Free_Factorization.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Polynomial_Factorization", "problem_names": ["lemma square_freeI:  \n  assumes \"\\<And> q. degree q > 0 \\<Longrightarrow> q \\<noteq> 0 \\<Longrightarrow> q * q dvd p \\<Longrightarrow> False\"\n  and p: \"p \\<noteq> 0\"\n  shows \"square_free p\"", "lemma square_free_multD:\n  assumes sf: \"square_free (f * g)\"\n  shows \"h dvd f \\<Longrightarrow> h dvd g \\<Longrightarrow> degree h = 0\" \"square_free f\" \"square_free g\"", "lemma irreducible\\<^sub>d_square_free:\n  fixes p :: \"'a :: {comm_semiring_1, semiring_no_zero_divisors} poly\"\n  shows \"irreducible\\<^sub>d p \\<Longrightarrow> square_free p\"", "lemma square_free_factor: assumes dvd: \"a dvd p\"\n  and sf: \"square_free p\"\n  shows \"square_free a\"", "lemma square_free_prod_list_distinct: \n  assumes sf: \"square_free (prod_list us :: 'a :: idom poly)\"\n  and us: \"\\<And> u. u \\<in> set us \\<Longrightarrow> degree u > 0\"\n  shows \"distinct us\"", "lemma separable_imp_square_free:\n  assumes sep: \"separable (f :: 'a::{field, factorial_ring_gcd, semiring_gcd_mult_normalize} poly)\" \n  shows \"square_free f\"", "lemma square_free_rsquarefree: assumes f: \"square_free f\" \n  shows \"rsquarefree f\"", "lemma square_free_prodD: \n  fixes fs :: \"'a :: {field,euclidean_ring_gcd,semiring_gcd_mult_normalize} poly set\"\n  assumes sf: \"square_free (\\<Prod> fs)\"\n  and fin: \"finite fs\"\n  and f: \"f \\<in> fs\"\n  and g: \"g \\<in> fs\"\n  and fg: \"f \\<noteq> g\"\n  shows \"coprime f g\"", "lemma rsquarefree_square_free_complex: assumes \"rsquarefree (p :: complex poly)\"\n  shows \"square_free p\"", "lemma square_free_separable_main:\n  fixes f :: \"'a :: {field,factorial_ring_gcd,semiring_gcd_mult_normalize} poly\"\n  assumes \"square_free f\"\n  and sep: \"\\<not> separable f\"\n  shows \"\\<exists> g k. f = g * k \\<and> degree g \\<noteq> 0 \\<and> pderiv g = 0\"", "lemma square_free_imp_separable: fixes f :: \"'a :: {field_char_0,factorial_ring_gcd,semiring_gcd_mult_normalize} poly\"\n  assumes \"square_free f\"\n  shows \"separable f\"", "lemma square_free_iff_separable: \n  \"square_free (f :: 'a :: {field_char_0,factorial_ring_gcd,semiring_gcd_mult_normalize} poly) = separable f\"", "lemma square_free_smult: \"c \\<noteq> 0 \\<Longrightarrow> square_free (f :: 'a poly) \\<Longrightarrow> square_free (smult c f)\"", "lemma square_free_smult_iff[simp]: \"c \\<noteq> 0 \\<Longrightarrow> square_free (smult c f) = square_free (f :: 'a poly)\"", "lemma square_free_factorizationD: assumes \"square_free_factorization p (c,bs)\"\n  shows \"p = smult c (\\<Prod>(a, i)\\<in> set bs. a ^ Suc i)\"\n  \"(a,i) \\<in> set bs \\<Longrightarrow> square_free a \\<and> degree a \\<noteq> 0\"\n  \"(a,i) \\<in> set bs \\<Longrightarrow> (b,j) \\<in> set bs \\<Longrightarrow> (a,i) \\<noteq> (b,j) \\<Longrightarrow> coprime a b\"\n  \"p = 0 \\<Longrightarrow> c = 0 \\<and> bs = []\"\n  \"distinct bs\"", "lemma square_free_factorization_prod_list: assumes \"square_free_factorization p (c,bs)\"\n  shows \"p = smult c (prod_list (map (\\<lambda> (a,i). a ^ Suc i) bs))\"", "lemma yun_factorization_0[simp]: \"yun_factorization 0 = (0,[])\"", "lemma poly_exp_expand: \n  \"p = (prod (\\<lambda> (a,i). a ^ i) as) * prod (\\<lambda> (a,i). a) as\"", "lemma pderiv_exp_prod: \n  \"pderiv p = (prod (\\<lambda> (a,i). a ^ i) as * sum (\\<lambda> (a,i). \n    prod (\\<lambda> (b,j). b) (as - {(a,i)}) * smult (of_nat (Suc i)) (pderiv a)) as)\"", "lemma monic_gen: assumes \"bs \\<subseteq> as\"\n  shows \"monic (\\<Prod> (a, i) \\<in> bs. a)\"", "lemma nonzero_gen: assumes \"bs \\<subseteq> as\"\n  shows \"(\\<Prod> (a, i) \\<in> bs. a) \\<noteq> 0\"", "lemma monic_Prod: \"monic ((\\<Prod>(a, i)\\<in>as. a ^ i))\"", "lemma coprime_generic:\n  assumes bs: \"bs \\<subseteq> as\"\n  and f: \"\\<And> a i. (a,i) \\<in> bs \\<Longrightarrow> f i > 0\"\n  shows \"coprime (\\<Prod>(a, i) \\<in> bs. a)\n     (\\<Sum>(a, i)\\<in> bs. (\\<Prod>(b, j)\\<in> bs - {(a, i)} . b) * smult (of_nat (f i)) (pderiv a))\"\n  (is \"coprime ?single ?onederiv\")", "lemma pderiv_exp_gcd: \n  \"gcd p (pderiv p) = (\\<Prod>(a, i)\\<in>as. a ^ i)\" (is \"_ = ?prod\")", "lemma p_div_gcd_p_pderiv: \"p div (gcd p (pderiv p)) = (\\<Prod>(a, i)\\<in>as. a)\"", "lemma A_B_C_D: \"A n = (\\<Prod> (a, i) \\<in> as \\<inter> UNIV \\<times> {n}. a)\"\n  \"B n = (\\<Prod> (a, i) \\<in> as - UNIV \\<times> {0 ..< n}. a)\"\n  \"C n = (\\<Sum>(a, i)\\<in>as - UNIV \\<times> {0 ..< n}. \n    (\\<Prod>(b, j)\\<in>as - UNIV \\<times> {0 ..< n} - {(a, i)}. b) * smult (of_nat (Suc i - n)) (pderiv a))\"\n  \"D n = (\\<Prod> (a, i) \\<in> as \\<inter> UNIV \\<times> {n}. a) * \n    (\\<Sum> (a,i)\\<in>as - UNIV \\<times> {0 ..< Suc n}. \n      (\\<Prod>(b, j)\\<in> as - UNIV \\<times> {0 ..< Suc n} - {(a, i)}. b) * (smult (of_nat (i - n)) (pderiv a)))\"", "lemmas A = A_B_C_D(1)", "lemmas B = A_B_C_D(2)", "lemmas ABCD_simps = A.simps B.simps C.simps D.simps", "lemma prod_A: \n  \"(\\<Prod>i = 0..< n. A i ^ Suc i) = (\\<Prod>(a, i)\\<in> as \\<inter> UNIV \\<times> {0 ..< n}. a ^ Suc i)\"", "lemma prod_A_is_p_unknown: assumes \"\\<And> a i. (a,i) \\<in> as \\<Longrightarrow> i < n\"\n  shows \"p = (\\<Prod>i = 0..< n. A i ^ Suc i)\"", "lemma bound: assumes m: \"m \\<ge> bound\"\n  shows \"B m = 1\"", "lemma coprime_A_A: assumes \"i \\<noteq> j\"\n  shows \"coprime (A i) (A j)\"", "lemma A_monic: \"monic (A i)\"", "lemma A_square_free: \"square_free (A i)\"", "lemma prod_A_is_p_B_bound: assumes \"B n = 1\"\n  shows \"p = (\\<Prod>i = 0..< n. A i ^ Suc i)\"", "lemma square_free_monic_poly: \"(poly (square_free_monic_poly p) x = 0) = (poly p x = 0)\"", "lemma yun_factorization_induct: assumes base: \"\\<And> bn cn. bn = 1 \\<Longrightarrow> P bn cn\"\n  and step: \"\\<And> bn cn. bn \\<noteq> 1 \\<Longrightarrow> P (bn div (gcd bn (cn - pderiv bn))) \n    ((cn - pderiv bn) div (gcd bn (cn - pderiv bn))) \\<Longrightarrow> P bn cn\"\n  and id: \"bn = p div gcd p (pderiv p)\" \"cn = pderiv p div gcd p (pderiv p)\"\n  shows \"P bn cn\"", "lemma yun_factorization_main: assumes \"yun_factorization_main (B n) (C n) n bs = cs\"\n  \"set bs = {(A i, i) | i. i < n}\" \"distinct (map snd bs)\"\n  shows \"\\<exists> m. set cs = {(A i, i) | i. i < m} \\<and> B m = 1 \\<and> distinct (map snd cs)\"", "lemma yun_monic_factorization_res: assumes res: \"yun_monic_factorization p = bs\"\n  shows \"\\<exists> m. set bs = {(A i, i) | i. i < m \\<and> A i \\<noteq> 1} \\<and> B m = 1 \\<and> distinct (map snd bs)\"", "lemma yun_monic_factorization: assumes yun: \"yun_monic_factorization p = bs\"\n  shows \"square_free_factorization p (1,bs)\" \"(b,i) \\<in> set bs \\<Longrightarrow> monic b\" \"distinct (map snd bs)\"", "lemma monic_factorization: assumes \"monic p\"\n  shows \"\\<exists> as. monic_factorization as p\"", "lemma square_free_monic_poly:\n  assumes \"monic (p :: 'a :: {field_char_0, euclidean_ring_gcd,semiring_gcd_mult_normalize} poly)\"\n  shows \"(poly (yun_gcd.square_free_monic_poly gcd p) x = 0) = (poly p x = 0)\"", "lemma yun_factorization_induct: \n  assumes base: \"\\<And> bn cn. bn = 1 \\<Longrightarrow> P bn cn\"\n  and step: \"\\<And> bn cn. bn \\<noteq> 1 \\<Longrightarrow> P (bn div (gcd bn (cn - pderiv bn))) \n    ((cn - pderiv bn) div (gcd bn (cn - pderiv bn))) \\<Longrightarrow> P bn cn\"\n  and id: \"bn = p div gcd p (pderiv p)\" \"cn = pderiv p div gcd p (pderiv p)\"\n  and monic: \"monic (p :: 'a :: {field_char_0,euclidean_ring_gcd,semiring_gcd_mult_normalize} poly)\"\n  shows \"P bn cn\"", "lemma square_free_poly: \n  \"(poly (square_free_poly gcd p) x = 0) = (poly p x = 0)\"", "lemma yun_monic_factorization:\n  fixes p :: \"'a :: {field_char_0,euclidean_ring_gcd,semiring_gcd_mult_normalize} poly\" \n  assumes res: \"yun_gcd.yun_monic_factorization gcd p = bs\"\n  and monic: \"monic p\"\n  shows \"square_free_factorization p (1,bs)\" \"(b,i) \\<in> set bs \\<Longrightarrow> monic b\" \"distinct (map snd bs)\"", "lemma square_free_factorization_smult: assumes c: \"c \\<noteq> 0\"\n  and sf: \"square_free_factorization p (d,bs)\"\n  shows \"square_free_factorization (smult c p) (c * d, bs)\"", "lemma yun_factorization: assumes res: \"yun_factorization gcd p = c_bs\"\n  shows \"square_free_factorization p c_bs\" \"(b,i) \\<in> set (snd c_bs) \\<Longrightarrow> monic b\"", "lemma prod_list_pow_suc: \"(\\<Prod>x\\<leftarrow>bs. (x :: 'a :: comm_monoid_mult) * x ^ i) \n  = prod_list bs * prod_list bs ^ i\"", "lemma square_free_factorization_order_root_mem: \n  assumes sff: \"square_free_factorization p (c,bs)\"\n    and p: \"p \\<noteq> (0 :: 'a poly)\"\n    and ai: \"(a,i) \\<in> set bs\" and rt: \"poly a x = 0\"\n  shows \"order x p = Suc i\"", "lemma square_free_factorization_order_root_no_mem: \n  assumes sff: \"square_free_factorization p (c,bs)\"\n    and p: \"p \\<noteq> (0 :: 'a poly)\"\n    and no_root: \"\\<And> a i. (a,i) \\<in> set bs \\<Longrightarrow> poly a x \\<noteq> 0\"\n  shows \"order x p = 0\"", "lemma square_free_factorization_order_root: \n  assumes sff: \"square_free_factorization p (c,bs)\"\n    and p: \"p \\<noteq> (0 :: 'a poly)\"\n  shows \"order x p = i \\<longleftrightarrow> (i = 0 \\<and> (\\<forall> a j. (a,j) \\<in> set bs \\<longrightarrow> poly a x \\<noteq> 0) \n    \\<or> (\\<exists> a j. (a,j) \\<in> set bs \\<and> poly a x = 0 \\<and> i = Suc j))\" (is \"?l = (?r1 \\<or> ?r2)\")", "lemma square_free_factorization_root: \n  assumes sff: \"square_free_factorization p (c,bs)\"\n    and p: \"p \\<noteq> (0 :: 'a poly)\"\n  shows \"{x. poly p x = 0} = {x. \\<exists> a i. (a,i) \\<in> set bs \\<and> poly a x = 0}\"", "lemma square_free_factorizationD': fixes p :: \"'a poly\"\n  assumes sf: \"square_free_factorization p (c, bs)\"\n  shows \"p = smult c (\\<Prod>(a, i) \\<leftarrow> bs. a ^ Suc i)\"\n    and \"square_free (prod_list (map fst bs))\"\n    and \"\\<And> b i. (b,i) \\<in> set bs \\<Longrightarrow> degree b \\<noteq> 0\"\n    and \"p = 0 \\<Longrightarrow> c = 0 \\<and> bs = []\"", "lemma square_free_factorizationI': fixes p :: \"'a poly\"\n  assumes prod: \"p = smult c (\\<Prod>(a, i) \\<leftarrow> bs. a ^ Suc i)\"\n    and sf: \"square_free (prod_list (map fst bs))\"\n    and deg: \"\\<And> b i. (b,i) \\<in> set bs \\<Longrightarrow> degree b > 0\"\n    and 0: \"p = 0 \\<Longrightarrow> c = 0 \\<and> bs = []\"\n  shows \"square_free_factorization p (c, bs)\"", "lemma square_free_factorization_def': fixes p :: \"'a poly\"\n  shows \"square_free_factorization p (c,bs) \\<longleftrightarrow>\n  (p = smult c (\\<Prod>(a, i) \\<leftarrow> bs. a ^ Suc i)) \\<and>\n  (square_free (prod_list (map fst bs))) \\<and>\n  (\\<forall> b i. (b,i) \\<in> set bs \\<longrightarrow> degree b > 0) \\<and>\n  (p = 0 \\<longrightarrow> c = 0 \\<and> bs = [])\"", "lemma square_free_factorization_smult_prod_listI: fixes p :: \"'a poly\"\n  assumes sff: \"square_free_factorization p (c, bs1 @ (smult b (prod_list bs),i) # bs2)\"\n  and bs: \"\\<And> b. b \\<in> set bs \\<Longrightarrow> degree b > 0\"\n  shows \"square_free_factorization p (c * b^(Suc i), bs1 @ map (\\<lambda> b. (b,i)) bs @ bs2)\"", "lemma square_free_factorization_further_factorization: fixes p :: \"'a poly\"\n  assumes sff: \"square_free_factorization p (c, bs)\"\n  and bs: \"\\<And> b i d fs. (b,i) \\<in> set bs \\<Longrightarrow> f b = (d,fs) \n    \\<Longrightarrow> b = smult d (prod_list fs) \\<and> (\\<forall> f \\<in> set fs. degree f > 0)\"\n  and h: \"h = (\\<lambda> (b,i). case f b of (d,fs) \\<Rightarrow> (d^Suc i,map (\\<lambda> f. (f,i)) fs))\"\n  and gs: \"gs = map h bs\"\n  and d: \"d = c * prod_list (map fst gs)\"\n  and es: \"es = concat (map snd gs)\"\n  shows \"square_free_factorization p (d, es)\"", "lemma square_free_factorization_prod_listI: fixes p :: \"'a poly\"\n  assumes sff: \"square_free_factorization p (c, bs1 @ ((prod_list bs),i) # bs2)\"\n  and bs: \"\\<And> b. b \\<in> set bs \\<Longrightarrow> degree b > 0\"\n  shows \"square_free_factorization p (c, bs1 @ map (\\<lambda> b. (b,i)) bs @ bs2)\"", "lemma square_free_factorization_factorI: fixes p :: \"'a poly\"\n  assumes sff: \"square_free_factorization p (c, bs1 @ (a,i) # bs2)\"\n  and r: \"degree r \\<noteq> 0\" and s: \"degree s \\<noteq> 0\"\n  and a: \"a = r * s\"\n  shows \"square_free_factorization p (c, bs1 @ ((r,i) # (s,i) # bs2))\"", "lemma monic_square_free_irreducible_factorization: assumes mon: \"monic (f :: 'b :: field poly)\" \n  and sf: \"square_free f\"\n  shows \"\\<exists> P. finite P \\<and> f = \\<Prod>P \\<and> P \\<subseteq> {q. irreducible q \\<and> monic q}\"", "lemma monic_factorization_uniqueness:\nfixes P::\"'a poly set\"\nassumes finite_P: \"finite P\" \n  and PQ: \"\\<Prod>P = \\<Prod>Q\" \n  and P: \"P \\<subseteq> {q. irreducible\\<^sub>d q \\<and> monic q}\"\nand finite_Q: \"finite Q\" \n  and Q: \"Q \\<subseteq> {q. irreducible\\<^sub>d q \\<and> monic q}\"\nshows \"P = Q\"", "lemma (in field_hom_0') yun_factorization_main_hom:\n  defines hp: \"hp \\<equiv> map_poly hom\"\n  defines hpi: \"hpi \\<equiv> map (\\<lambda> (f,i). (hp f, i :: nat))\"\n  assumes monic: \"monic p\" and f: \"f = p div gcd p (pderiv p)\" and g: \"g = pderiv p div gcd p (pderiv p)\"\n  shows \"yun_gcd.yun_factorization_main gcd (hp f) (hp g) i (hpi as) = hpi (yun_gcd.yun_factorization_main gcd f g i as)\"", "lemma square_free_square_free_factorization: \n  \"square_free (p :: 'a :: {field,factorial_ring_gcd,semiring_gcd_mult_normalize} poly) \\<Longrightarrow> \n     degree p \\<noteq> 0 \\<Longrightarrow> square_free_factorization p (1,[(p,0)])\"", "lemma constant_square_free_factorization: \n  \"degree p = 0 \\<Longrightarrow> square_free_factorization p (coeff p 0,[])\"", "lemma (in field_hom_0') yun_monic_factorization:\n  defines hp: \"hp \\<equiv> map_poly hom\"\n  defines hpi: \"hpi \\<equiv> map (\\<lambda> (f,i). (hp f, i :: nat))\"\n  assumes monic: \"monic f\"\n  shows \"yun_gcd.yun_monic_factorization gcd (hp f) = hpi (yun_gcd.yun_monic_factorization gcd f)\"", "lemma (in field_hom_0') yun_factorization_hom:\n  defines hp: \"hp \\<equiv> map_poly hom\"\n  defines hpi: \"hpi \\<equiv> map (\\<lambda> (f,i). (hp f, i :: nat))\"\n  shows \"yun_factorization gcd (hp f) = map_prod hom hpi (yun_factorization gcd f)\"", "lemma (in field_hom_0') square_free_map_poly:\n  \"square_free (map_poly hom f) = square_free f\""], "translations": [["", "lemma square_freeI:  \n  assumes \"\\<And> q. degree q > 0 \\<Longrightarrow> q \\<noteq> 0 \\<Longrightarrow> q * q dvd p \\<Longrightarrow> False\"\n  and p: \"p \\<noteq> 0\"\n  shows \"square_free p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. square_free p", "unfolding square_free_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<and>\n    (\\<forall>q. 0 < degree q \\<longrightarrow> \\<not> q * q dvd p)", "proof (intro allI conjI[OF p] impI notI, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>q.\n       \\<lbrakk>0 < degree q; q * q dvd p\\<rbrakk> \\<Longrightarrow> False", "case (1 q)"], ["proof (state)\nthis:\n  0 < degree q\n  q * q dvd p\n\ngoal (1 subgoal):\n 1. \\<And>q.\n       \\<lbrakk>0 < degree q; q * q dvd p\\<rbrakk> \\<Longrightarrow> False", "from assms(1)[OF 1(1) _ 1(2)] 1(1)"], ["proof (chain)\npicking this:\n  q \\<noteq> 0 \\<Longrightarrow> False\n  0 < degree q", "show False"], ["proof (prove)\nusing this:\n  q \\<noteq> 0 \\<Longrightarrow> False\n  0 < degree q\n\ngoal (1 subgoal):\n 1. False", "by (cases \"q = 0\", auto)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma square_free_multD:\n  assumes sf: \"square_free (f * g)\"\n  shows \"h dvd f \\<Longrightarrow> h dvd g \\<Longrightarrow> degree h = 0\" \"square_free f\" \"square_free g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>h dvd f; h dvd g\\<rbrakk> \\<Longrightarrow> degree h = 0) &&&\n    square_free f &&& square_free g", "proof -"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>h dvd f; h dvd g\\<rbrakk> \\<Longrightarrow> degree h = 0\n 2. square_free f\n 3. square_free g", "from sf[unfolded square_free_def]"], ["proof (chain)\npicking this:\n  f * g \\<noteq> 0 \\<and>\n  (\\<forall>q. 0 < degree q \\<longrightarrow> \\<not> q * q dvd f * g)", "have 0: \"f \\<noteq> 0\" \"g \\<noteq> 0\"\n    and dvd: \"\\<And> q. q * q dvd f * g \\<Longrightarrow> degree q = 0\""], ["proof (prove)\nusing this:\n  f * g \\<noteq> 0 \\<and>\n  (\\<forall>q. 0 < degree q \\<longrightarrow> \\<not> q * q dvd f * g)\n\ngoal (1 subgoal):\n 1. (f \\<noteq> 0 &&& g \\<noteq> 0) &&&\n    (\\<And>q. q * q dvd f * g \\<Longrightarrow> degree q = 0)", "by auto"], ["proof (state)\nthis:\n  f \\<noteq> 0\n  g \\<noteq> 0\n  ?q * ?q dvd f * g \\<Longrightarrow> degree ?q = 0\n\ngoal (3 subgoals):\n 1. \\<lbrakk>h dvd f; h dvd g\\<rbrakk> \\<Longrightarrow> degree h = 0\n 2. square_free f\n 3. square_free g", "then"], ["proof (chain)\npicking this:\n  f \\<noteq> 0\n  g \\<noteq> 0\n  ?q * ?q dvd f * g \\<Longrightarrow> degree ?q = 0", "show \"square_free f\" \"square_free g\""], ["proof (prove)\nusing this:\n  f \\<noteq> 0\n  g \\<noteq> 0\n  ?q * ?q dvd f * g \\<Longrightarrow> degree ?q = 0\n\ngoal (1 subgoal):\n 1. square_free f &&& square_free g", "by (auto simp: square_free_def)"], ["proof (state)\nthis:\n  square_free f\n  square_free g\n\ngoal (1 subgoal):\n 1. \\<lbrakk>h dvd f; h dvd g\\<rbrakk> \\<Longrightarrow> degree h = 0", "assume \"h dvd f\" \"h dvd g\""], ["proof (state)\nthis:\n  h dvd f\n  h dvd g\n\ngoal (1 subgoal):\n 1. \\<lbrakk>h dvd f; h dvd g\\<rbrakk> \\<Longrightarrow> degree h = 0", "then"], ["proof (chain)\npicking this:\n  h dvd f\n  h dvd g", "have \"h * h dvd f * g\""], ["proof (prove)\nusing this:\n  h dvd f\n  h dvd g\n\ngoal (1 subgoal):\n 1. h * h dvd f * g", "by (rule mult_dvd_mono)"], ["proof (state)\nthis:\n  h * h dvd f * g\n\ngoal (1 subgoal):\n 1. \\<lbrakk>h dvd f; h dvd g\\<rbrakk> \\<Longrightarrow> degree h = 0", "from dvd[OF this]"], ["proof (chain)\npicking this:\n  degree h = 0", "show \"degree h = 0\""], ["proof (prove)\nusing this:\n  degree h = 0\n\ngoal (1 subgoal):\n 1. degree h = 0", "."], ["proof (state)\nthis:\n  degree h = 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma irreducible\\<^sub>d_square_free:\n  fixes p :: \"'a :: {comm_semiring_1, semiring_no_zero_divisors} poly\"\n  shows \"irreducible\\<^sub>d p \\<Longrightarrow> square_free p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. irreducible\\<^sub>d p \\<Longrightarrow> square_free p", "by (metis degree_0 degree_mult_eq degree_mult_eq_0 irreducible\\<^sub>dD(1) irreducible\\<^sub>dD(2) irreducible\\<^sub>d_dvd_smult irreducible\\<^sub>d_smultI less_add_same_cancel2 not_gr_zero square_free_def)"], ["", "lemma square_free_factor: assumes dvd: \"a dvd p\"\n  and sf: \"square_free p\"\n  shows \"square_free a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. square_free a", "proof (intro square_freeI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>q.\n       \\<lbrakk>0 < degree q; q \\<noteq> 0; q * q dvd a\\<rbrakk>\n       \\<Longrightarrow> False\n 2. a \\<noteq> 0", "fix q"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>q.\n       \\<lbrakk>0 < degree q; q \\<noteq> 0; q * q dvd a\\<rbrakk>\n       \\<Longrightarrow> False\n 2. a \\<noteq> 0", "assume q: \"degree q > 0\" and \"q * q dvd a\""], ["proof (state)\nthis:\n  0 < degree q\n  q * q dvd a\n\ngoal (2 subgoals):\n 1. \\<And>q.\n       \\<lbrakk>0 < degree q; q \\<noteq> 0; q * q dvd a\\<rbrakk>\n       \\<Longrightarrow> False\n 2. a \\<noteq> 0", "hence \"q * q dvd p\""], ["proof (prove)\nusing this:\n  0 < degree q\n  q * q dvd a\n\ngoal (1 subgoal):\n 1. q * q dvd p", "using dvd dvd_trans sf square_free_def"], ["proof (prove)\nusing this:\n  0 < degree q\n  q * q dvd a\n  a dvd p\n  \\<lbrakk>?a dvd ?b; ?b dvd ?c\\<rbrakk> \\<Longrightarrow> ?a dvd ?c\n  square_free p\n  square_free ?p =\n  (?p \\<noteq> 0 \\<and>\n   (\\<forall>q. 0 < degree q \\<longrightarrow> \\<not> q * q dvd ?p))\n\ngoal (1 subgoal):\n 1. q * q dvd p", "by blast"], ["proof (state)\nthis:\n  q * q dvd p\n\ngoal (2 subgoals):\n 1. \\<And>q.\n       \\<lbrakk>0 < degree q; q \\<noteq> 0; q * q dvd a\\<rbrakk>\n       \\<Longrightarrow> False\n 2. a \\<noteq> 0", "with sf[unfolded square_free_def] q"], ["proof (chain)\npicking this:\n  p \\<noteq> 0 \\<and>\n  (\\<forall>q. 0 < degree q \\<longrightarrow> \\<not> q * q dvd p)\n  0 < degree q\n  q * q dvd p", "show False"], ["proof (prove)\nusing this:\n  p \\<noteq> 0 \\<and>\n  (\\<forall>q. 0 < degree q \\<longrightarrow> \\<not> q * q dvd p)\n  0 < degree q\n  q * q dvd p\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. a \\<noteq> 0", "qed (insert dvd sf, auto simp: square_free_def)"], ["", "lemma square_free_prod_list_distinct: \n  assumes sf: \"square_free (prod_list us :: 'a :: idom poly)\"\n  and us: \"\\<And> u. u \\<in> set us \\<Longrightarrow> degree u > 0\"\n  shows \"distinct us\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct us", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> distinct us \\<Longrightarrow> False", "assume \"\\<not> distinct us\""], ["proof (state)\nthis:\n  \\<not> distinct us\n\ngoal (1 subgoal):\n 1. \\<not> distinct us \\<Longrightarrow> False", "from not_distinct_decomp[OF this]"], ["proof (chain)\npicking this:\n  \\<exists>xs ys zs y. us = xs @ [y] @ ys @ [y] @ zs", "obtain xs ys zs u where\n     \"us = xs @ u # ys @ u # zs\""], ["proof (prove)\nusing this:\n  \\<exists>xs ys zs y. us = xs @ [y] @ ys @ [y] @ zs\n\ngoal (1 subgoal):\n 1. (\\<And>xs u ys zs.\n        us = xs @ u # ys @ u # zs \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  us = xs @ u # ys @ u # zs\n\ngoal (1 subgoal):\n 1. \\<not> distinct us \\<Longrightarrow> False", "hence dvd: \"u * u dvd prod_list us\" and u: \"u \\<in> set us\""], ["proof (prove)\nusing this:\n  us = xs @ u # ys @ u # zs\n\ngoal (1 subgoal):\n 1. u * u dvd prod_list us &&& u \\<in> set us", "by auto"], ["proof (state)\nthis:\n  u * u dvd prod_list us\n  u \\<in> set us\n\ngoal (1 subgoal):\n 1. \\<not> distinct us \\<Longrightarrow> False", "from dvd us[OF u] sf"], ["proof (chain)\npicking this:\n  u * u dvd prod_list us\n  0 < degree u\n  square_free (prod_list us)", "have \"prod_list us = 0\""], ["proof (prove)\nusing this:\n  u * u dvd prod_list us\n  0 < degree u\n  square_free (prod_list us)\n\ngoal (1 subgoal):\n 1. prod_list us = 0", "unfolding square_free_def"], ["proof (prove)\nusing this:\n  u * u dvd prod_list us\n  0 < degree u\n  prod_list us \\<noteq> 0 \\<and>\n  (\\<forall>q. 0 < degree q \\<longrightarrow> \\<not> q * q dvd prod_list us)\n\ngoal (1 subgoal):\n 1. prod_list us = 0", "by auto"], ["proof (state)\nthis:\n  prod_list us = 0\n\ngoal (1 subgoal):\n 1. \\<not> distinct us \\<Longrightarrow> False", "hence \"0 \\<in> set us\""], ["proof (prove)\nusing this:\n  prod_list us = 0\n\ngoal (1 subgoal):\n 1. 0 \\<in> set us", "by (simp add: prod_list_zero_iff)"], ["proof (state)\nthis:\n  0 \\<in> set us\n\ngoal (1 subgoal):\n 1. \\<not> distinct us \\<Longrightarrow> False", "from us[OF this]"], ["proof (chain)\npicking this:\n  0 < degree 0", "show False"], ["proof (prove)\nusing this:\n  0 < degree 0\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "definition separable where \n  \"separable f = coprime f (pderiv f)\""], ["", "lemma separable_imp_square_free:\n  assumes sep: \"separable (f :: 'a::{field, factorial_ring_gcd, semiring_gcd_mult_normalize} poly)\" \n  shows \"square_free f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. square_free f", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> square_free f \\<Longrightarrow> False", "note sep = sep[unfolded separable_def]"], ["proof (state)\nthis:\n  coprime f (pderiv f)\n\ngoal (1 subgoal):\n 1. \\<not> square_free f \\<Longrightarrow> False", "from sep"], ["proof (chain)\npicking this:\n  coprime f (pderiv f)", "have f0: \"f \\<noteq> 0\""], ["proof (prove)\nusing this:\n  coprime f (pderiv f)\n\ngoal (1 subgoal):\n 1. f \\<noteq> 0", "by (cases f, auto)"], ["proof (state)\nthis:\n  f \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> square_free f \\<Longrightarrow> False", "assume \"\\<not> square_free f\""], ["proof (state)\nthis:\n  \\<not> square_free f\n\ngoal (1 subgoal):\n 1. \\<not> square_free f \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<not> square_free f", "obtain g where g: \"degree g \\<noteq> 0\" and \"g * g dvd f\""], ["proof (prove)\nusing this:\n  \\<not> square_free f\n\ngoal (1 subgoal):\n 1. (\\<And>g.\n        \\<lbrakk>degree g \\<noteq> 0; g * g dvd f\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using f0"], ["proof (prove)\nusing this:\n  \\<not> square_free f\n  f \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>g.\n        \\<lbrakk>degree g \\<noteq> 0; g * g dvd f\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding square_free_def"], ["proof (prove)\nusing this:\n  \\<not> (f \\<noteq> 0 \\<and>\n          (\\<forall>q. 0 < degree q \\<longrightarrow> \\<not> q * q dvd f))\n  f \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>g.\n        \\<lbrakk>degree g \\<noteq> 0; g * g dvd f\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  degree g \\<noteq> 0\n  g * g dvd f\n\ngoal (1 subgoal):\n 1. \\<not> square_free f \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  degree g \\<noteq> 0\n  g * g dvd f", "obtain h where f: \"f = g * (g * h)\""], ["proof (prove)\nusing this:\n  degree g \\<noteq> 0\n  g * g dvd f\n\ngoal (1 subgoal):\n 1. (\\<And>h. f = g * (g * h) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding dvd_def"], ["proof (prove)\nusing this:\n  degree g \\<noteq> 0\n  \\<exists>k. f = g * g * k\n\ngoal (1 subgoal):\n 1. (\\<And>h. f = g * (g * h) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: ac_simps)"], ["proof (state)\nthis:\n  f = g * (g * h)\n\ngoal (1 subgoal):\n 1. \\<not> square_free f \\<Longrightarrow> False", "have \"pderiv f = g * ((g * pderiv h + h * pderiv g) + h * pderiv g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pderiv f = g * (g * pderiv h + h * pderiv g + h * pderiv g)", "unfolding f pderiv_mult[of g]"], ["proof (prove)\ngoal (1 subgoal):\n 1. g * (g * pderiv h + h * pderiv g) + g * h * pderiv g =\n    g * (g * pderiv h + h * pderiv g + h * pderiv g)", "by (simp add: field_simps)"], ["proof (state)\nthis:\n  pderiv f = g * (g * pderiv h + h * pderiv g + h * pderiv g)\n\ngoal (1 subgoal):\n 1. \\<not> square_free f \\<Longrightarrow> False", "hence \"g dvd pderiv f\""], ["proof (prove)\nusing this:\n  pderiv f = g * (g * pderiv h + h * pderiv g + h * pderiv g)\n\ngoal (1 subgoal):\n 1. g dvd pderiv f", "unfolding dvd_def"], ["proof (prove)\nusing this:\n  pderiv f = g * (g * pderiv h + h * pderiv g + h * pderiv g)\n\ngoal (1 subgoal):\n 1. \\<exists>k. pderiv f = g * k", "by blast"], ["proof (state)\nthis:\n  g dvd pderiv f\n\ngoal (1 subgoal):\n 1. \\<not> square_free f \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  g dvd pderiv f\n\ngoal (1 subgoal):\n 1. \\<not> square_free f \\<Longrightarrow> False", "have \"g dvd f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g dvd f", "unfolding f dvd_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>k. g * (g * h) = g * k", "by blast"], ["proof (state)\nthis:\n  g dvd f\n\ngoal (1 subgoal):\n 1. \\<not> square_free f \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  g dvd pderiv f\n  g dvd f", "have dvd: \"g dvd (gcd f (pderiv f))\""], ["proof (prove)\nusing this:\n  g dvd pderiv f\n  g dvd f\n\ngoal (1 subgoal):\n 1. g dvd gcd f (pderiv f)", "by simp"], ["proof (state)\nthis:\n  g dvd gcd f (pderiv f)\n\ngoal (1 subgoal):\n 1. \\<not> square_free f \\<Longrightarrow> False", "have \"gcd f (pderiv f) \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gcd f (pderiv f) \\<noteq> 0", "using f0"], ["proof (prove)\nusing this:\n  f \\<noteq> 0\n\ngoal (1 subgoal):\n 1. gcd f (pderiv f) \\<noteq> 0", "by simp"], ["proof (state)\nthis:\n  gcd f (pderiv f) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> square_free f \\<Longrightarrow> False", "with g dvd"], ["proof (chain)\npicking this:\n  degree g \\<noteq> 0\n  g dvd gcd f (pderiv f)\n  gcd f (pderiv f) \\<noteq> 0", "have \"degree (gcd f (pderiv f)) \\<noteq> 0\""], ["proof (prove)\nusing this:\n  degree g \\<noteq> 0\n  g dvd gcd f (pderiv f)\n  gcd f (pderiv f) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. degree (gcd f (pderiv f)) \\<noteq> 0", "by (simp add: sep poly_dvd_1)"], ["proof (state)\nthis:\n  degree (gcd f (pderiv f)) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> square_free f \\<Longrightarrow> False", "hence \"\\<not> coprime f (pderiv f)\""], ["proof (prove)\nusing this:\n  degree (gcd f (pderiv f)) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> coprime f (pderiv f)", "by auto"], ["proof (state)\nthis:\n  \\<not> coprime f (pderiv f)\n\ngoal (1 subgoal):\n 1. \\<not> square_free f \\<Longrightarrow> False", "with sep"], ["proof (chain)\npicking this:\n  coprime f (pderiv f)\n  \\<not> coprime f (pderiv f)", "show False"], ["proof (prove)\nusing this:\n  coprime f (pderiv f)\n  \\<not> coprime f (pderiv f)\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma square_free_rsquarefree: assumes f: \"square_free f\" \n  shows \"rsquarefree f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rsquarefree f", "unfolding rsquarefree_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<noteq> 0 \\<and> (\\<forall>a. order a f = 0 \\<or> order a f = 1)", "proof (intro conjI allI)"], ["proof (state)\ngoal (2 subgoals):\n 1. f \\<noteq> 0\n 2. \\<And>a. order a f = 0 \\<or> order a f = 1", "fix x"], ["proof (state)\ngoal (2 subgoals):\n 1. f \\<noteq> 0\n 2. \\<And>a. order a f = 0 \\<or> order a f = 1", "show \"order x f = 0 \\<or> order x f = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order x f = 0 \\<or> order x f = 1", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (order x f = 0 \\<or> order x f = 1) \\<Longrightarrow> False", "assume \"\\<not> ?thesis\""], ["proof (state)\nthis:\n  \\<not> (order x f = 0 \\<or> order x f = 1)\n\ngoal (1 subgoal):\n 1. \\<not> (order x f = 0 \\<or> order x f = 1) \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<not> (order x f = 0 \\<or> order x f = 1)", "obtain n where ord: \"order x f = Suc (Suc n)\""], ["proof (prove)\nusing this:\n  \\<not> (order x f = 0 \\<or> order x f = 1)\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        order x f = Suc (Suc n) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases \"order x f\"; cases \"order x f - 1\"; auto)"], ["proof (state)\nthis:\n  order x f = Suc (Suc n)\n\ngoal (1 subgoal):\n 1. \\<not> (order x f = 0 \\<or> order x f = 1) \\<Longrightarrow> False", "define p where \"p = [:-x,1:]\""], ["proof (state)\nthis:\n  p = [:- x, 1::'a:]\n\ngoal (1 subgoal):\n 1. \\<not> (order x f = 0 \\<or> order x f = 1) \\<Longrightarrow> False", "from order_divides[of x \"Suc (Suc 0)\" f, unfolded ord]"], ["proof (chain)\npicking this:\n  ([:- x, 1::'a:] ^ Suc (Suc 0) dvd f) =\n  (f = 0 \\<or> Suc (Suc 0) \\<le> Suc (Suc n))", "have \"p * p dvd f\" \"degree p \\<noteq> 0\""], ["proof (prove)\nusing this:\n  ([:- x, 1::'a:] ^ Suc (Suc 0) dvd f) =\n  (f = 0 \\<or> Suc (Suc 0) \\<le> Suc (Suc n))\n\ngoal (1 subgoal):\n 1. p * p dvd f &&& degree p \\<noteq> 0", "unfolding p_def"], ["proof (prove)\nusing this:\n  ([:- x, 1::'a:] ^ Suc (Suc 0) dvd f) =\n  (f = 0 \\<or> Suc (Suc 0) \\<le> Suc (Suc n))\n\ngoal (1 subgoal):\n 1. [:- x, 1::'a:] * [:- x, 1::'a:] dvd f &&&\n    degree [:- x, 1::'a:] \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  p * p dvd f\n  degree p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> (order x f = 0 \\<or> order x f = 1) \\<Longrightarrow> False", "hence \"\\<not> square_free f\""], ["proof (prove)\nusing this:\n  p * p dvd f\n  degree p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> square_free f", "using f(1)"], ["proof (prove)\nusing this:\n  p * p dvd f\n  degree p \\<noteq> 0\n  square_free f\n\ngoal (1 subgoal):\n 1. \\<not> square_free f", "unfolding square_free_def"], ["proof (prove)\nusing this:\n  p * p dvd f\n  degree p \\<noteq> 0\n  f \\<noteq> 0 \\<and>\n  (\\<forall>q. 0 < degree q \\<longrightarrow> \\<not> q * q dvd f)\n\ngoal (1 subgoal):\n 1. \\<not> (f \\<noteq> 0 \\<and>\n            (\\<forall>q. 0 < degree q \\<longrightarrow> \\<not> q * q dvd f))", "by auto"], ["proof (state)\nthis:\n  \\<not> square_free f\n\ngoal (1 subgoal):\n 1. \\<not> (order x f = 0 \\<or> order x f = 1) \\<Longrightarrow> False", "with assms"], ["proof (chain)\npicking this:\n  square_free f\n  \\<not> square_free f", "show False"], ["proof (prove)\nusing this:\n  square_free f\n  \\<not> square_free f\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  order x f = 0 \\<or> order x f = 1\n\ngoal (1 subgoal):\n 1. f \\<noteq> 0", "qed (insert f, auto simp: square_free_def)"], ["", "lemma square_free_prodD: \n  fixes fs :: \"'a :: {field,euclidean_ring_gcd,semiring_gcd_mult_normalize} poly set\"\n  assumes sf: \"square_free (\\<Prod> fs)\"\n  and fin: \"finite fs\"\n  and f: \"f \\<in> fs\"\n  and g: \"g \\<in> fs\"\n  and fg: \"f \\<noteq> g\"\n  shows \"coprime f g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coprime f g", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. coprime f g", "have \"(\\<Prod> fs) = f * (\\<Prod> (fs - {f}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Prod>fs = f * \\<Prod>(fs - {f})", "by (rule prod.remove[OF fin f])"], ["proof (state)\nthis:\n  \\<Prod>fs = f * \\<Prod>(fs - {f})\n\ngoal (1 subgoal):\n 1. coprime f g", "also"], ["proof (state)\nthis:\n  \\<Prod>fs = f * \\<Prod>(fs - {f})\n\ngoal (1 subgoal):\n 1. coprime f g", "have \"(\\<Prod> (fs - {f})) = g * (\\<Prod> (fs - {f} - {g}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Prod>(fs - {f}) = g * \\<Prod>(fs - {f} - {g})", "by (rule prod.remove, insert fin g fg, auto)"], ["proof (state)\nthis:\n  \\<Prod>(fs - {f}) = g * \\<Prod>(fs - {f} - {g})\n\ngoal (1 subgoal):\n 1. coprime f g", "finally"], ["proof (chain)\npicking this:\n  \\<Prod>fs = f * (g * \\<Prod>(fs - {f} - {g}))", "obtain k where sf: \"square_free (f * g * k)\""], ["proof (prove)\nusing this:\n  \\<Prod>fs = f * (g * \\<Prod>(fs - {f} - {g}))\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        square_free (f * g * k) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using sf"], ["proof (prove)\nusing this:\n  \\<Prod>fs = f * (g * \\<Prod>(fs - {f} - {g}))\n  square_free (\\<Prod>fs)\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        square_free (f * g * k) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (simp add: ac_simps)"], ["proof (state)\nthis:\n  square_free (f * g * k)\n\ngoal (1 subgoal):\n 1. coprime f g", "from sf[unfolded square_free_def]"], ["proof (chain)\npicking this:\n  f * g * k \\<noteq> 0 \\<and>\n  (\\<forall>q. 0 < degree q \\<longrightarrow> \\<not> q * q dvd f * g * k)", "have 0: \"f \\<noteq> 0\" \"g \\<noteq> 0\" \n    and dvd: \"\\<And> q. q * q dvd f * g * k \\<Longrightarrow> degree q = 0\""], ["proof (prove)\nusing this:\n  f * g * k \\<noteq> 0 \\<and>\n  (\\<forall>q. 0 < degree q \\<longrightarrow> \\<not> q * q dvd f * g * k)\n\ngoal (1 subgoal):\n 1. (f \\<noteq> 0 &&& g \\<noteq> 0) &&&\n    (\\<And>q. q * q dvd f * g * k \\<Longrightarrow> degree q = 0)", "by auto"], ["proof (state)\nthis:\n  f \\<noteq> 0\n  g \\<noteq> 0\n  ?q * ?q dvd f * g * k \\<Longrightarrow> degree ?q = 0\n\ngoal (1 subgoal):\n 1. coprime f g", "have \"gcd f g * gcd f g dvd f * g * k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gcd f g * gcd f g dvd f * g * k", "by (simp add: mult_dvd_mono)"], ["proof (state)\nthis:\n  gcd f g * gcd f g dvd f * g * k\n\ngoal (1 subgoal):\n 1. coprime f g", "from dvd[OF this]"], ["proof (chain)\npicking this:\n  degree (gcd f g) = 0", "have \"degree (gcd f g) = 0\""], ["proof (prove)\nusing this:\n  degree (gcd f g) = 0\n\ngoal (1 subgoal):\n 1. degree (gcd f g) = 0", "."], ["proof (state)\nthis:\n  degree (gcd f g) = 0\n\ngoal (1 subgoal):\n 1. coprime f g", "moreover"], ["proof (state)\nthis:\n  degree (gcd f g) = 0\n\ngoal (1 subgoal):\n 1. coprime f g", "have \"gcd f g \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gcd f g \\<noteq> 0", "using 0"], ["proof (prove)\nusing this:\n  f \\<noteq> 0\n  g \\<noteq> 0\n\ngoal (1 subgoal):\n 1. gcd f g \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  gcd f g \\<noteq> 0\n\ngoal (1 subgoal):\n 1. coprime f g", "ultimately"], ["proof (chain)\npicking this:\n  degree (gcd f g) = 0\n  gcd f g \\<noteq> 0", "show \"coprime f g\""], ["proof (prove)\nusing this:\n  degree (gcd f g) = 0\n  gcd f g \\<noteq> 0\n\ngoal (1 subgoal):\n 1. coprime f g", "using is_unit_gcd[of f g] is_unit_iff_degree[of \"gcd f g\"]"], ["proof (prove)\nusing this:\n  degree (gcd f g) = 0\n  gcd f g \\<noteq> 0\n  is_unit (gcd f g) = coprime f g\n  gcd f g \\<noteq> 0 \\<Longrightarrow>\n  is_unit (gcd f g) = (degree (gcd f g) = 0)\n\ngoal (1 subgoal):\n 1. coprime f g", "by simp"], ["proof (state)\nthis:\n  coprime f g\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rsquarefree_square_free_complex: assumes \"rsquarefree (p :: complex poly)\"\n  shows \"square_free p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. square_free p", "proof (rule square_freeI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>q.\n       \\<lbrakk>0 < degree q; q \\<noteq> 0; q * q dvd p\\<rbrakk>\n       \\<Longrightarrow> False\n 2. p \\<noteq> 0", "fix q"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>q.\n       \\<lbrakk>0 < degree q; q \\<noteq> 0; q * q dvd p\\<rbrakk>\n       \\<Longrightarrow> False\n 2. p \\<noteq> 0", "assume d: \"degree q > 0\" and dvd: \"q * q dvd p\""], ["proof (state)\nthis:\n  0 < degree q\n  q * q dvd p\n\ngoal (2 subgoals):\n 1. \\<And>q.\n       \\<lbrakk>0 < degree q; q \\<noteq> 0; q * q dvd p\\<rbrakk>\n       \\<Longrightarrow> False\n 2. p \\<noteq> 0", "from d"], ["proof (chain)\npicking this:\n  0 < degree q", "have \"\\<not> constant (poly q)\""], ["proof (prove)\nusing this:\n  0 < degree q\n\ngoal (1 subgoal):\n 1. \\<not> constant (poly q)", "by (simp add: constant_degree)"], ["proof (state)\nthis:\n  \\<not> constant (poly q)\n\ngoal (2 subgoals):\n 1. \\<And>q.\n       \\<lbrakk>0 < degree q; q \\<noteq> 0; q * q dvd p\\<rbrakk>\n       \\<Longrightarrow> False\n 2. p \\<noteq> 0", "from fundamental_theorem_of_algebra[OF this]"], ["proof (chain)\npicking this:\n  \\<exists>z. poly q z = 0", "obtain x where \"poly q x = 0\""], ["proof (prove)\nusing this:\n  \\<exists>z. poly q z = 0\n\ngoal (1 subgoal):\n 1. (\\<And>x. poly q x = 0 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  poly q x = 0\n\ngoal (2 subgoals):\n 1. \\<And>q.\n       \\<lbrakk>0 < degree q; q \\<noteq> 0; q * q dvd p\\<rbrakk>\n       \\<Longrightarrow> False\n 2. p \\<noteq> 0", "hence \"[:-x,1:] dvd q\""], ["proof (prove)\nusing this:\n  poly q x = 0\n\ngoal (1 subgoal):\n 1. [:- x, 1:] dvd q", "by (simp add: poly_eq_0_iff_dvd)"], ["proof (state)\nthis:\n  [:- x, 1:] dvd q\n\ngoal (2 subgoals):\n 1. \\<And>q.\n       \\<lbrakk>0 < degree q; q \\<noteq> 0; q * q dvd p\\<rbrakk>\n       \\<Longrightarrow> False\n 2. p \\<noteq> 0", "then"], ["proof (chain)\npicking this:\n  [:- x, 1:] dvd q", "obtain k where q: \"q = [:-x,1:] * k\""], ["proof (prove)\nusing this:\n  [:- x, 1:] dvd q\n\ngoal (1 subgoal):\n 1. (\\<And>k. q = [:- x, 1:] * k \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding dvd_def"], ["proof (prove)\nusing this:\n  \\<exists>k. q = [:- x, 1:] * k\n\ngoal (1 subgoal):\n 1. (\\<And>k. q = [:- x, 1:] * k \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  q = [:- x, 1:] * k\n\ngoal (2 subgoals):\n 1. \\<And>q.\n       \\<lbrakk>0 < degree q; q \\<noteq> 0; q * q dvd p\\<rbrakk>\n       \\<Longrightarrow> False\n 2. p \\<noteq> 0", "from dvd"], ["proof (chain)\npicking this:\n  q * q dvd p", "obtain l where p: \"p = q * q * l\""], ["proof (prove)\nusing this:\n  q * q dvd p\n\ngoal (1 subgoal):\n 1. (\\<And>l. p = q * q * l \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding dvd_def"], ["proof (prove)\nusing this:\n  \\<exists>k. p = q * q * k\n\ngoal (1 subgoal):\n 1. (\\<And>l. p = q * q * l \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  p = q * q * l\n\ngoal (2 subgoals):\n 1. \\<And>q.\n       \\<lbrakk>0 < degree q; q \\<noteq> 0; q * q dvd p\\<rbrakk>\n       \\<Longrightarrow> False\n 2. p \\<noteq> 0", "from p[unfolded q]"], ["proof (chain)\npicking this:\n  p = [:- x, 1:] * k * ([:- x, 1:] * k) * l", "have \"p = [:-x,1:]^2 * (k * k * l)\""], ["proof (prove)\nusing this:\n  p = [:- x, 1:] * k * ([:- x, 1:] * k) * l\n\ngoal (1 subgoal):\n 1. p = [:- x, 1:]\\<^sup>2 * (k * k * l)", "by algebra"], ["proof (state)\nthis:\n  p = [:- x, 1:]\\<^sup>2 * (k * k * l)\n\ngoal (2 subgoals):\n 1. \\<And>q.\n       \\<lbrakk>0 < degree q; q \\<noteq> 0; q * q dvd p\\<rbrakk>\n       \\<Longrightarrow> False\n 2. p \\<noteq> 0", "hence \"[:-x,1:]^2 dvd p\""], ["proof (prove)\nusing this:\n  p = [:- x, 1:]\\<^sup>2 * (k * k * l)\n\ngoal (1 subgoal):\n 1. [:- x, 1:]\\<^sup>2 dvd p", "unfolding dvd_def"], ["proof (prove)\nusing this:\n  p = [:- x, 1:]\\<^sup>2 * (k * k * l)\n\ngoal (1 subgoal):\n 1. \\<exists>k. p = [:- x, 1:]\\<^sup>2 * k", "by blast"], ["proof (state)\nthis:\n  [:- x, 1:]\\<^sup>2 dvd p\n\ngoal (2 subgoals):\n 1. \\<And>q.\n       \\<lbrakk>0 < degree q; q \\<noteq> 0; q * q dvd p\\<rbrakk>\n       \\<Longrightarrow> False\n 2. p \\<noteq> 0", "from this[unfolded order_divides]"], ["proof (chain)\npicking this:\n  p = 0 \\<or> 2 \\<le> order x p", "have \"p = 0 \\<or> \\<not> order x p \\<le> 1\""], ["proof (prove)\nusing this:\n  p = 0 \\<or> 2 \\<le> order x p\n\ngoal (1 subgoal):\n 1. p = 0 \\<or> \\<not> order x p \\<le> 1", "by auto"], ["proof (state)\nthis:\n  p = 0 \\<or> \\<not> order x p \\<le> 1\n\ngoal (2 subgoals):\n 1. \\<And>q.\n       \\<lbrakk>0 < degree q; q \\<noteq> 0; q * q dvd p\\<rbrakk>\n       \\<Longrightarrow> False\n 2. p \\<noteq> 0", "thus False"], ["proof (prove)\nusing this:\n  p = 0 \\<or> \\<not> order x p \\<le> 1\n\ngoal (1 subgoal):\n 1. False", "using assms"], ["proof (prove)\nusing this:\n  p = 0 \\<or> \\<not> order x p \\<le> 1\n  rsquarefree p\n\ngoal (1 subgoal):\n 1. False", "unfolding rsquarefree_def'"], ["proof (prove)\nusing this:\n  p = 0 \\<or> \\<not> order x p \\<le> 1\n  p \\<noteq> 0 \\<and> (\\<forall>a. order a p \\<le> 1)\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0", "qed (insert assms, auto simp: rsquarefree_def)"], ["", "lemma square_free_separable_main:\n  fixes f :: \"'a :: {field,factorial_ring_gcd,semiring_gcd_mult_normalize} poly\"\n  assumes \"square_free f\"\n  and sep: \"\\<not> separable f\"\n  shows \"\\<exists> g k. f = g * k \\<and> degree g \\<noteq> 0 \\<and> pderiv g = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>g k. f = g * k \\<and> degree g \\<noteq> 0 \\<and> pderiv g = 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>g k. f = g * k \\<and> degree g \\<noteq> 0 \\<and> pderiv g = 0", "note cop = sep[unfolded separable_def]"], ["proof (state)\nthis:\n  \\<not> coprime f (pderiv f)\n\ngoal (1 subgoal):\n 1. \\<exists>g k. f = g * k \\<and> degree g \\<noteq> 0 \\<and> pderiv g = 0", "from assms"], ["proof (chain)\npicking this:\n  square_free f\n  \\<not> separable f", "have f: \"f \\<noteq> 0\""], ["proof (prove)\nusing this:\n  square_free f\n  \\<not> separable f\n\ngoal (1 subgoal):\n 1. f \\<noteq> 0", "unfolding square_free_def"], ["proof (prove)\nusing this:\n  f \\<noteq> 0 \\<and>\n  (\\<forall>q. 0 < degree q \\<longrightarrow> \\<not> q * q dvd f)\n  \\<not> separable f\n\ngoal (1 subgoal):\n 1. f \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  f \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<exists>g k. f = g * k \\<and> degree g \\<noteq> 0 \\<and> pderiv g = 0", "let ?g = \"gcd f (pderiv f)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>g k. f = g * k \\<and> degree g \\<noteq> 0 \\<and> pderiv g = 0", "define G where \"G = ?g\""], ["proof (state)\nthis:\n  G = gcd f (pderiv f)\n\ngoal (1 subgoal):\n 1. \\<exists>g k. f = g * k \\<and> degree g \\<noteq> 0 \\<and> pderiv g = 0", "from poly_gcd_monic[of f \"pderiv f\"] f"], ["proof (chain)\npicking this:\n  f \\<noteq> 0 \\<or> pderiv f \\<noteq> 0 \\<Longrightarrow>\n  monic (gcd f (pderiv f))\n  f \\<noteq> 0", "have mon: \"monic ?g\""], ["proof (prove)\nusing this:\n  f \\<noteq> 0 \\<or> pderiv f \\<noteq> 0 \\<Longrightarrow>\n  monic (gcd f (pderiv f))\n  f \\<noteq> 0\n\ngoal (1 subgoal):\n 1. monic (gcd f (pderiv f))", "by auto"], ["proof (state)\nthis:\n  monic (gcd f (pderiv f))\n\ngoal (1 subgoal):\n 1. \\<exists>g k. f = g * k \\<and> degree g \\<noteq> 0 \\<and> pderiv g = 0", "have deg: \"degree G > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < degree G", "proof (cases \"degree G\")"], ["proof (state)\ngoal (2 subgoals):\n 1. degree G = 0 \\<Longrightarrow> 0 < degree G\n 2. \\<And>nat. degree G = Suc nat \\<Longrightarrow> 0 < degree G", "case 0"], ["proof (state)\nthis:\n  degree G = 0\n\ngoal (2 subgoals):\n 1. degree G = 0 \\<Longrightarrow> 0 < degree G\n 2. \\<And>nat. degree G = Suc nat \\<Longrightarrow> 0 < degree G", "from degree0_coeffs[OF this] cop mon"], ["proof (chain)\npicking this:\n  \\<exists>a. G = [:a:]\n  \\<not> coprime f (pderiv f)\n  monic (gcd f (pderiv f))", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>a. G = [:a:]\n  \\<not> coprime f (pderiv f)\n  monic (gcd f (pderiv f))\n\ngoal (1 subgoal):\n 1. 0 < degree G", "by (auto simp: G_def coprime_iff_gcd_eq_1)"], ["proof (state)\nthis:\n  0 < degree G\n\ngoal (1 subgoal):\n 1. \\<And>nat. degree G = Suc nat \\<Longrightarrow> 0 < degree G", "qed auto"], ["proof (state)\nthis:\n  0 < degree G\n\ngoal (1 subgoal):\n 1. \\<exists>g k. f = g * k \\<and> degree g \\<noteq> 0 \\<and> pderiv g = 0", "have gf: \"G dvd f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. G dvd f", "unfolding G_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. gcd f (pderiv f) dvd f", "by auto"], ["proof (state)\nthis:\n  G dvd f\n\ngoal (1 subgoal):\n 1. \\<exists>g k. f = g * k \\<and> degree g \\<noteq> 0 \\<and> pderiv g = 0", "have gf': \"G dvd pderiv f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. G dvd pderiv f", "unfolding G_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. gcd f (pderiv f) dvd pderiv f", "by auto"], ["proof (state)\nthis:\n  G dvd pderiv f\n\ngoal (1 subgoal):\n 1. \\<exists>g k. f = g * k \\<and> degree g \\<noteq> 0 \\<and> pderiv g = 0", "from irreducible\\<^sub>d_factor[OF deg]"], ["proof (chain)\npicking this:\n  \\<exists>q r.\n     irreducible\\<^sub>d q \\<and> G = q * r \\<and> degree r < degree G", "obtain g r where g: \"irreducible g\" and G: \"G = g * r\""], ["proof (prove)\nusing this:\n  \\<exists>q r.\n     irreducible\\<^sub>d q \\<and> G = q * r \\<and> degree r < degree G\n\ngoal (1 subgoal):\n 1. (\\<And>g r.\n        \\<lbrakk>irreducible g; G = g * r\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  irreducible g\n  G = g * r\n\ngoal (1 subgoal):\n 1. \\<exists>g k. f = g * k \\<and> degree g \\<noteq> 0 \\<and> pderiv g = 0", "from gf"], ["proof (chain)\npicking this:\n  G dvd f", "have gf: \"g dvd f\""], ["proof (prove)\nusing this:\n  G dvd f\n\ngoal (1 subgoal):\n 1. g dvd f", "unfolding G"], ["proof (prove)\nusing this:\n  g * r dvd f\n\ngoal (1 subgoal):\n 1. g dvd f", "by (rule dvd_mult_left)"], ["proof (state)\nthis:\n  g dvd f\n\ngoal (1 subgoal):\n 1. \\<exists>g k. f = g * k \\<and> degree g \\<noteq> 0 \\<and> pderiv g = 0", "from gf'"], ["proof (chain)\npicking this:\n  G dvd pderiv f", "have gf': \"g dvd pderiv f\""], ["proof (prove)\nusing this:\n  G dvd pderiv f\n\ngoal (1 subgoal):\n 1. g dvd pderiv f", "unfolding G"], ["proof (prove)\nusing this:\n  g * r dvd pderiv f\n\ngoal (1 subgoal):\n 1. g dvd pderiv f", "by (rule dvd_mult_left)"], ["proof (state)\nthis:\n  g dvd pderiv f\n\ngoal (1 subgoal):\n 1. \\<exists>g k. f = g * k \\<and> degree g \\<noteq> 0 \\<and> pderiv g = 0", "have g0: \"degree g \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree g \\<noteq> 0", "using g"], ["proof (prove)\nusing this:\n  irreducible g\n\ngoal (1 subgoal):\n 1. degree g \\<noteq> 0", "unfolding irreducible\\<^sub>d_def"], ["proof (prove)\nusing this:\n  irreducible g\n\ngoal (1 subgoal):\n 1. degree g \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  degree g \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<exists>g k. f = g * k \\<and> degree g \\<noteq> 0 \\<and> pderiv g = 0", "from gf"], ["proof (chain)\npicking this:\n  g dvd f", "obtain k where fgk: \"f = g * k\""], ["proof (prove)\nusing this:\n  g dvd f\n\ngoal (1 subgoal):\n 1. (\\<And>k. f = g * k \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "unfolding dvd_def"], ["proof (prove)\nusing this:\n  \\<exists>k. f = g * k\n\ngoal (1 subgoal):\n 1. (\\<And>k. f = g * k \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  f = g * k\n\ngoal (1 subgoal):\n 1. \\<exists>g k. f = g * k \\<and> degree g \\<noteq> 0 \\<and> pderiv g = 0", "have id1: \"pderiv f = g * pderiv k + k * pderiv g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pderiv f = g * pderiv k + k * pderiv g", "unfolding fgk pderiv_mult"], ["proof (prove)\ngoal (1 subgoal):\n 1. g * pderiv k + k * pderiv g = g * pderiv k + k * pderiv g", "by simp"], ["proof (state)\nthis:\n  pderiv f = g * pderiv k + k * pderiv g\n\ngoal (1 subgoal):\n 1. \\<exists>g k. f = g * k \\<and> degree g \\<noteq> 0 \\<and> pderiv g = 0", "from gf'"], ["proof (chain)\npicking this:\n  g dvd pderiv f", "obtain h where \"pderiv f = g * h\""], ["proof (prove)\nusing this:\n  g dvd pderiv f\n\ngoal (1 subgoal):\n 1. (\\<And>h. pderiv f = g * h \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding dvd_def"], ["proof (prove)\nusing this:\n  \\<exists>k. pderiv f = g * k\n\ngoal (1 subgoal):\n 1. (\\<And>h. pderiv f = g * h \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  pderiv f = g * h\n\ngoal (1 subgoal):\n 1. \\<exists>g k. f = g * k \\<and> degree g \\<noteq> 0 \\<and> pderiv g = 0", "from id1[unfolded this]"], ["proof (chain)\npicking this:\n  g * h = g * pderiv k + k * pderiv g", "have \"k * pderiv g = g * (h - pderiv k)\""], ["proof (prove)\nusing this:\n  g * h = g * pderiv k + k * pderiv g\n\ngoal (1 subgoal):\n 1. k * pderiv g = g * (h - pderiv k)", "by (simp add: field_simps)"], ["proof (state)\nthis:\n  k * pderiv g = g * (h - pderiv k)\n\ngoal (1 subgoal):\n 1. \\<exists>g k. f = g * k \\<and> degree g \\<noteq> 0 \\<and> pderiv g = 0", "hence dvd: \"g dvd k * pderiv g\""], ["proof (prove)\nusing this:\n  k * pderiv g = g * (h - pderiv k)\n\ngoal (1 subgoal):\n 1. g dvd k * pderiv g", "unfolding dvd_def"], ["proof (prove)\nusing this:\n  k * pderiv g = g * (h - pderiv k)\n\ngoal (1 subgoal):\n 1. \\<exists>ka. k * pderiv g = g * ka", "by auto"], ["proof (state)\nthis:\n  g dvd k * pderiv g\n\ngoal (1 subgoal):\n 1. \\<exists>g k. f = g * k \\<and> degree g \\<noteq> 0 \\<and> pderiv g = 0", "{"], ["proof (state)\nthis:\n  g dvd k * pderiv g\n\ngoal (1 subgoal):\n 1. \\<exists>g k. f = g * k \\<and> degree g \\<noteq> 0 \\<and> pderiv g = 0", "assume \"g dvd k\""], ["proof (state)\nthis:\n  g dvd k\n\ngoal (1 subgoal):\n 1. \\<exists>g k. f = g * k \\<and> degree g \\<noteq> 0 \\<and> pderiv g = 0", "then"], ["proof (chain)\npicking this:\n  g dvd k", "obtain h where k: \"k = g * h\""], ["proof (prove)\nusing this:\n  g dvd k\n\ngoal (1 subgoal):\n 1. (\\<And>h. k = g * h \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "unfolding dvd_def"], ["proof (prove)\nusing this:\n  \\<exists>ka. k = g * ka\n\ngoal (1 subgoal):\n 1. (\\<And>h. k = g * h \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  k = g * h\n\ngoal (1 subgoal):\n 1. \\<exists>g k. f = g * k \\<and> degree g \\<noteq> 0 \\<and> pderiv g = 0", "with fgk"], ["proof (chain)\npicking this:\n  f = g * k\n  k = g * h", "have \"g * g dvd f\""], ["proof (prove)\nusing this:\n  f = g * k\n  k = g * h\n\ngoal (1 subgoal):\n 1. g * g dvd f", "by auto"], ["proof (state)\nthis:\n  g * g dvd f\n\ngoal (1 subgoal):\n 1. \\<exists>g k. f = g * k \\<and> degree g \\<noteq> 0 \\<and> pderiv g = 0", "with g0"], ["proof (chain)\npicking this:\n  degree g \\<noteq> 0\n  g * g dvd f", "have \"\\<not> square_free f\""], ["proof (prove)\nusing this:\n  degree g \\<noteq> 0\n  g * g dvd f\n\ngoal (1 subgoal):\n 1. \\<not> square_free f", "unfolding square_free_def"], ["proof (prove)\nusing this:\n  degree g \\<noteq> 0\n  g * g dvd f\n\ngoal (1 subgoal):\n 1. \\<not> (f \\<noteq> 0 \\<and>\n            (\\<forall>q. 0 < degree q \\<longrightarrow> \\<not> q * q dvd f))", "using f"], ["proof (prove)\nusing this:\n  degree g \\<noteq> 0\n  g * g dvd f\n  f \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> (f \\<noteq> 0 \\<and>\n            (\\<forall>q. 0 < degree q \\<longrightarrow> \\<not> q * q dvd f))", "by auto"], ["proof (state)\nthis:\n  \\<not> square_free f\n\ngoal (1 subgoal):\n 1. \\<exists>g k. f = g * k \\<and> degree g \\<noteq> 0 \\<and> pderiv g = 0", "with assms"], ["proof (chain)\npicking this:\n  square_free f\n  \\<not> separable f\n  \\<not> square_free f", "have False"], ["proof (prove)\nusing this:\n  square_free f\n  \\<not> separable f\n  \\<not> square_free f\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<exists>g k. f = g * k \\<and> degree g \\<noteq> 0 \\<and> pderiv g = 0", "}"], ["proof (state)\nthis:\n  g dvd k \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<exists>g k. f = g * k \\<and> degree g \\<noteq> 0 \\<and> pderiv g = 0", "with  g dvd"], ["proof (chain)\npicking this:\n  irreducible g\n  g dvd k * pderiv g\n  g dvd k \\<Longrightarrow> False", "have \"g dvd pderiv g\""], ["proof (prove)\nusing this:\n  irreducible g\n  g dvd k * pderiv g\n  g dvd k \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. g dvd pderiv g", "by auto"], ["proof (state)\nthis:\n  g dvd pderiv g\n\ngoal (1 subgoal):\n 1. \\<exists>g k. f = g * k \\<and> degree g \\<noteq> 0 \\<and> pderiv g = 0", "from divides_degree[OF this] degree_pderiv_le[of g] g0"], ["proof (chain)\npicking this:\n  degree g \\<le> degree (pderiv g) \\<or> pderiv g = 0\n  degree (pderiv g) \\<le> degree g - 1\n  degree g \\<noteq> 0", "have \"pderiv g = 0\""], ["proof (prove)\nusing this:\n  degree g \\<le> degree (pderiv g) \\<or> pderiv g = 0\n  degree (pderiv g) \\<le> degree g - 1\n  degree g \\<noteq> 0\n\ngoal (1 subgoal):\n 1. pderiv g = 0", "by linarith"], ["proof (state)\nthis:\n  pderiv g = 0\n\ngoal (1 subgoal):\n 1. \\<exists>g k. f = g * k \\<and> degree g \\<noteq> 0 \\<and> pderiv g = 0", "with fgk g0"], ["proof (chain)\npicking this:\n  f = g * k\n  degree g \\<noteq> 0\n  pderiv g = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  f = g * k\n  degree g \\<noteq> 0\n  pderiv g = 0\n\ngoal (1 subgoal):\n 1. \\<exists>g k. f = g * k \\<and> degree g \\<noteq> 0 \\<and> pderiv g = 0", "by auto"], ["proof (state)\nthis:\n  \\<exists>g k. f = g * k \\<and> degree g \\<noteq> 0 \\<and> pderiv g = 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma square_free_imp_separable: fixes f :: \"'a :: {field_char_0,factorial_ring_gcd,semiring_gcd_mult_normalize} poly\"\n  assumes \"square_free f\"\n  shows \"separable f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. separable f", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> separable f \\<Longrightarrow> False", "assume \"\\<not> separable f\""], ["proof (state)\nthis:\n  \\<not> separable f\n\ngoal (1 subgoal):\n 1. \\<not> separable f \\<Longrightarrow> False", "from square_free_separable_main[OF assms this]"], ["proof (chain)\npicking this:\n  \\<exists>g k. f = g * k \\<and> degree g \\<noteq> 0 \\<and> pderiv g = 0", "obtain g k where *: \"f = g * k\" \"degree g \\<noteq> 0\" \"pderiv g = 0\""], ["proof (prove)\nusing this:\n  \\<exists>g k. f = g * k \\<and> degree g \\<noteq> 0 \\<and> pderiv g = 0\n\ngoal (1 subgoal):\n 1. (\\<And>g k.\n        \\<lbrakk>f = g * k; degree g \\<noteq> 0; pderiv g = 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  f = g * k\n  degree g \\<noteq> 0\n  pderiv g = 0\n\ngoal (1 subgoal):\n 1. \\<not> separable f \\<Longrightarrow> False", "hence \"g dvd pderiv g\""], ["proof (prove)\nusing this:\n  f = g * k\n  degree g \\<noteq> 0\n  pderiv g = 0\n\ngoal (1 subgoal):\n 1. g dvd pderiv g", "by auto"], ["proof (state)\nthis:\n  g dvd pderiv g\n\ngoal (1 subgoal):\n 1. \\<not> separable f \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  g dvd pderiv g\n\ngoal (1 subgoal):\n 1. False", "unfolding dvd_pderiv_iff"], ["proof (prove)\nusing this:\n  degree g = 0\n\ngoal (1 subgoal):\n 1. False", "using *"], ["proof (prove)\nusing this:\n  degree g = 0\n  f = g * k\n  degree g \\<noteq> 0\n  pderiv g = 0\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma square_free_iff_separable: \n  \"square_free (f :: 'a :: {field_char_0,factorial_ring_gcd,semiring_gcd_mult_normalize} poly) = separable f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. square_free f = separable f", "using separable_imp_square_free[of f] square_free_imp_separable[of f]"], ["proof (prove)\nusing this:\n  separable f \\<Longrightarrow> square_free f\n  square_free f \\<Longrightarrow> separable f\n\ngoal (1 subgoal):\n 1. square_free f = separable f", "by auto"], ["", "context\n  assumes \"SORT_CONSTRAINT('a::{field,factorial_ring_gcd})\"\nbegin"], ["", "lemma square_free_smult: \"c \\<noteq> 0 \\<Longrightarrow> square_free (f :: 'a poly) \\<Longrightarrow> square_free (smult c f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>c \\<noteq> (0::'a); square_free f\\<rbrakk>\n    \\<Longrightarrow> square_free (smult c f)", "by (unfold square_free_def, insert dvd_smult_cancel[of _ c], auto)"], ["", "lemma square_free_smult_iff[simp]: \"c \\<noteq> 0 \\<Longrightarrow> square_free (smult c f) = square_free (f :: 'a poly)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c \\<noteq> (0::'a) \\<Longrightarrow>\n    square_free (smult c f) = square_free f", "using square_free_smult[of c f] square_free_smult[of \"inverse c\" \"smult c f\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>c \\<noteq> (0::'a); square_free f\\<rbrakk>\n  \\<Longrightarrow> square_free (smult c f)\n  \\<lbrakk>inverse c \\<noteq> (0::'a); square_free (smult c f)\\<rbrakk>\n  \\<Longrightarrow> square_free (smult (inverse c) (smult c f))\n\ngoal (1 subgoal):\n 1. c \\<noteq> (0::'a) \\<Longrightarrow>\n    square_free (smult c f) = square_free f", "by auto"], ["", "end"], ["", "context\n  assumes \"SORT_CONSTRAINT('a::factorial_ring_gcd)\"\nbegin"], ["", "definition square_free_factorization :: \"'a poly \\<Rightarrow> 'a \\<times> ('a poly \\<times> nat) list \\<Rightarrow> bool\" where\n  \"square_free_factorization p cbs \\<equiv> case cbs of (c,bs) \\<Rightarrow>\n    (p = smult c (\\<Prod>(a, i)\\<in> set bs. a ^ Suc i))\n  \\<and> (p = 0 \\<longrightarrow> c = 0 \\<and> bs = [])\n  \\<and> (\\<forall> a i. (a,i) \\<in> set bs \\<longrightarrow> square_free a \\<and> degree a > 0)\n  \\<and> (\\<forall> a i b j. (a,i) \\<in> set bs \\<longrightarrow> (b,j) \\<in> set bs \\<longrightarrow> (a,i) \\<noteq> (b,j) \\<longrightarrow> coprime a b)\n  \\<and> distinct bs\""], ["", "lemma square_free_factorizationD: assumes \"square_free_factorization p (c,bs)\"\n  shows \"p = smult c (\\<Prod>(a, i)\\<in> set bs. a ^ Suc i)\"\n  \"(a,i) \\<in> set bs \\<Longrightarrow> square_free a \\<and> degree a \\<noteq> 0\"\n  \"(a,i) \\<in> set bs \\<Longrightarrow> (b,j) \\<in> set bs \\<Longrightarrow> (a,i) \\<noteq> (b,j) \\<Longrightarrow> coprime a b\"\n  \"p = 0 \\<Longrightarrow> c = 0 \\<and> bs = []\"\n  \"distinct bs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (p = smult c (\\<Prod>(a, i)\\<in>set bs. a ^ Suc i) &&&\n     ((a, i) \\<in> set bs \\<Longrightarrow>\n      square_free a \\<and> degree a \\<noteq> 0)) &&&\n    (\\<lbrakk>(a, i) \\<in> set bs; (b, j) \\<in> set bs;\n      (a, i) \\<noteq> (b, j)\\<rbrakk>\n     \\<Longrightarrow> coprime a b) &&&\n    (p = 0 \\<Longrightarrow> c = (0::'a) \\<and> bs = []) &&& distinct bs", "using assms"], ["proof (prove)\nusing this:\n  local.square_free_factorization p (c, bs)\n\ngoal (1 subgoal):\n 1. (p = smult c (\\<Prod>(a, i)\\<in>set bs. a ^ Suc i) &&&\n     ((a, i) \\<in> set bs \\<Longrightarrow>\n      square_free a \\<and> degree a \\<noteq> 0)) &&&\n    (\\<lbrakk>(a, i) \\<in> set bs; (b, j) \\<in> set bs;\n      (a, i) \\<noteq> (b, j)\\<rbrakk>\n     \\<Longrightarrow> coprime a b) &&&\n    (p = 0 \\<Longrightarrow> c = (0::'a) \\<and> bs = []) &&& distinct bs", "unfolding square_free_factorization_def split"], ["proof (prove)\nusing this:\n  p = smult c (\\<Prod>(a, i)\\<in>set bs. a ^ Suc i) \\<and>\n  (p = 0 \\<longrightarrow> c = (0::'a) \\<and> bs = []) \\<and>\n  (\\<forall>a i.\n      (a, i) \\<in> set bs \\<longrightarrow>\n      square_free a \\<and> 0 < degree a) \\<and>\n  (\\<forall>a i b j.\n      (a, i) \\<in> set bs \\<longrightarrow>\n      (b, j) \\<in> set bs \\<longrightarrow>\n      (a, i) \\<noteq> (b, j) \\<longrightarrow> coprime a b) \\<and>\n  distinct bs\n\ngoal (1 subgoal):\n 1. (p = smult c (\\<Prod>(a, i)\\<in>set bs. a ^ Suc i) &&&\n     ((a, i) \\<in> set bs \\<Longrightarrow>\n      square_free a \\<and> degree a \\<noteq> 0)) &&&\n    (\\<lbrakk>(a, i) \\<in> set bs; (b, j) \\<in> set bs;\n      (a, i) \\<noteq> (b, j)\\<rbrakk>\n     \\<Longrightarrow> coprime a b) &&&\n    (p = 0 \\<Longrightarrow> c = (0::'a) \\<and> bs = []) &&& distinct bs", "by blast+"], ["", "lemma square_free_factorization_prod_list: assumes \"square_free_factorization p (c,bs)\"\n  shows \"p = smult c (prod_list (map (\\<lambda> (a,i). a ^ Suc i) bs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p = smult c (\\<Prod>(a, i)\\<leftarrow>bs. a ^ Suc i)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. p = smult c (\\<Prod>(a, i)\\<leftarrow>bs. a ^ Suc i)", "note sff = square_free_factorizationD[OF assms]"], ["proof (state)\nthis:\n  p = smult c (\\<Prod>(a, i)\\<in>set bs. a ^ Suc i)\n  (?a, ?i) \\<in> set bs \\<Longrightarrow>\n  square_free ?a \\<and> degree ?a \\<noteq> 0\n  \\<lbrakk>(?a, ?i) \\<in> set bs; (?b, ?j) \\<in> set bs;\n   (?a, ?i) \\<noteq> (?b, ?j)\\<rbrakk>\n  \\<Longrightarrow> coprime ?a ?b\n  p = 0 \\<Longrightarrow> c = (0::'a) \\<and> bs = []\n  distinct bs\n\ngoal (1 subgoal):\n 1. p = smult c (\\<Prod>(a, i)\\<leftarrow>bs. a ^ Suc i)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. p = smult c (\\<Prod>(a, i)\\<leftarrow>bs. a ^ Suc i)", "unfolding sff(1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. smult c (\\<Prod>(a, i)\\<in>set bs. a ^ Suc i) =\n    smult c (\\<Prod>(a, i)\\<leftarrow>bs. a ^ Suc i)", "by (simp add: prod.distinct_set_conv_list[OF sff(5)])"], ["proof (state)\nthis:\n  p = smult c (\\<Prod>(a, i)\\<leftarrow>bs. a ^ Suc i)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsection \\<open>Yun's factorization algorithm\\<close>"], ["", "locale yun_gcd = \n  fixes Gcd :: \"'a :: factorial_ring_gcd poly \\<Rightarrow> 'a poly \\<Rightarrow> 'a poly\"\nbegin"], ["", "partial_function (tailrec) yun_factorization_main :: \n  \"'a poly \\<Rightarrow> 'a poly \\<Rightarrow>\n    nat \\<Rightarrow> ('a poly \\<times> nat)list \\<Rightarrow> ('a poly \\<times> nat)list\" where\n  [code]: \"yun_factorization_main bn cn i sqr = (\n    if bn = 1 then sqr\n    else (\n    let \n      dn = cn - pderiv bn;\n      an = Gcd bn dn\n    in yun_factorization_main (bn div an) (dn div an) (Suc i) ((an,i) # sqr)))\""], ["", "definition yun_monic_factorization :: \"'a poly \\<Rightarrow> ('a poly \\<times> nat)list\" where\n  \"yun_monic_factorization p = (let\n    pp = pderiv p;\n    u = Gcd p pp;\n    b0 = p div u;\n    c0 = pp div u\n    in \n      (filter (\\<lambda> (a,i). a \\<noteq> 1) (yun_factorization_main b0 c0 0 [])))\""], ["", "definition square_free_monic_poly :: \"'a poly \\<Rightarrow> 'a poly\" where\n  \"square_free_monic_poly p = (p div (Gcd p (pderiv p)))\""], ["", "end"], ["", "declare yun_gcd.yun_monic_factorization_def [code]"], ["", "declare yun_gcd.yun_factorization_main.simps [code]"], ["", "declare yun_gcd.square_free_monic_poly_def [code]"], ["", "context \n  fixes Gcd :: \"'a :: {field_char_0,euclidean_ring_gcd} poly \\<Rightarrow> 'a poly \\<Rightarrow> 'a poly\"\nbegin"], ["", "interpretation yun_gcd Gcd"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "definition square_free_poly :: \"'a poly \\<Rightarrow> 'a poly\" where\n  \"square_free_poly p = (if p = 0 then 0 else \n     square_free_monic_poly (smult (inverse (coeff p (degree p))) p))\""], ["", "definition yun_factorization :: \"'a poly \\<Rightarrow> 'a \\<times> ('a poly \\<times> nat)list\" where\n  \"yun_factorization p = (if p = 0\n    then (0,[]) else (let \n      c = coeff p (degree p);\n      q = smult (inverse c) p\n    in (c, yun_monic_factorization q)))\""], ["", "lemma yun_factorization_0[simp]: \"yun_factorization 0 = (0,[])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.yun_factorization 0 = (0::'a, [])", "unfolding yun_factorization_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if 0 = 0 then (0::'a, [])\n     else let c = lead_coeff 0; q = smult (inverse c) 0\n          in (c, yun_monic_factorization q)) =\n    (0::'a, [])", "by simp"], ["", "end"], ["", "locale monic_factorization =\n  fixes as :: \"('a :: {field_char_0,euclidean_ring_gcd,semiring_gcd_mult_normalize} poly \\<times> nat) set\"\n  and p :: \"'a poly\"\n  assumes p: \"p = prod (\\<lambda> (a,i). a ^ Suc i) as\"\n  and fin: \"finite as\"\n  assumes as_distinct: \"\\<And> a i b j. (a,i) \\<in> as \\<Longrightarrow> (b,j) \\<in> as \\<Longrightarrow> (a,i) \\<noteq> (b,j) \\<Longrightarrow> a \\<noteq> b\"\n  and as_irred: \"\\<And> a i. (a,i) \\<in> as \\<Longrightarrow> irreducible\\<^sub>d a\"\n  and as_monic: \"\\<And> a i. (a,i) \\<in> as \\<Longrightarrow> monic a\"\nbegin"], ["", "lemma poly_exp_expand: \n  \"p = (prod (\\<lambda> (a,i). a ^ i) as) * prod (\\<lambda> (a,i). a) as\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p = (\\<Prod>(a, i)\\<in>as. a ^ i) * (\\<Prod>(a, i)\\<in>as. a)", "unfolding p prod.distrib[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>(a, i)\\<in>as. a ^ Suc i) =\n    (\\<Prod>x\\<in>as.\n       (case x of (x, xa) \\<Rightarrow> x ^ xa) *\n       (case x of (a, i) \\<Rightarrow> a))", "by (rule prod.cong, auto)"], ["", "lemma pderiv_exp_prod: \n  \"pderiv p = (prod (\\<lambda> (a,i). a ^ i) as * sum (\\<lambda> (a,i). \n    prod (\\<lambda> (b,j). b) (as - {(a,i)}) * smult (of_nat (Suc i)) (pderiv a)) as)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pderiv p =\n    (\\<Prod>(a, i)\\<in>as. a ^ i) *\n    (\\<Sum>(a, i)\\<in>as.\n       (\\<Prod>(b, j)\\<in>as - {(a, i)}. b) *\n       smult (of_nat (Suc i)) (pderiv a))", "unfolding p pderiv_prod sum_distrib_left"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>a\\<in>as.\n       (\\<Prod>(a, i)\\<in>as - {a}. a ^ Suc i) *\n       pderiv (case a of (a, i) \\<Rightarrow> a ^ Suc i)) =\n    (\\<Sum>n\\<in>as.\n       (\\<Prod>(x, y)\\<in>as. x ^ y) *\n       (case n of\n        (a, i) \\<Rightarrow>\n          (\\<Prod>(b, j)\\<in>as - {(a, i)}. b) *\n          smult (of_nat (Suc i)) (pderiv a)))", "proof (rule sum.cong[OF refl])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> as \\<Longrightarrow>\n       (\\<Prod>(a, i)\\<in>as - {x}. a ^ Suc i) *\n       pderiv (case x of (a, i) \\<Rightarrow> a ^ Suc i) =\n       (\\<Prod>(x, y)\\<in>as. x ^ y) *\n       (case x of\n        (a, i) \\<Rightarrow>\n          (\\<Prod>(b, j)\\<in>as - {(a, i)}. b) *\n          smult (of_nat (Suc i)) (pderiv a))", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> as \\<Longrightarrow>\n       (\\<Prod>(a, i)\\<in>as - {x}. a ^ Suc i) *\n       pderiv (case x of (a, i) \\<Rightarrow> a ^ Suc i) =\n       (\\<Prod>(x, y)\\<in>as. x ^ y) *\n       (case x of\n        (a, i) \\<Rightarrow>\n          (\\<Prod>(b, j)\\<in>as - {(a, i)}. b) *\n          smult (of_nat (Suc i)) (pderiv a))", "assume \"x \\<in> as\""], ["proof (state)\nthis:\n  x \\<in> as\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> as \\<Longrightarrow>\n       (\\<Prod>(a, i)\\<in>as - {x}. a ^ Suc i) *\n       pderiv (case x of (a, i) \\<Rightarrow> a ^ Suc i) =\n       (\\<Prod>(x, y)\\<in>as. x ^ y) *\n       (case x of\n        (a, i) \\<Rightarrow>\n          (\\<Prod>(b, j)\\<in>as - {(a, i)}. b) *\n          smult (of_nat (Suc i)) (pderiv a))", "then"], ["proof (chain)\npicking this:\n  x \\<in> as", "obtain a i where x: \"x = (a,i)\" and mem: \"(a,i) \\<in> as\""], ["proof (prove)\nusing this:\n  x \\<in> as\n\ngoal (1 subgoal):\n 1. (\\<And>a i.\n        \\<lbrakk>x = (a, i); (a, i) \\<in> as\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases x, auto)"], ["proof (state)\nthis:\n  x = (a, i)\n  (a, i) \\<in> as\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> as \\<Longrightarrow>\n       (\\<Prod>(a, i)\\<in>as - {x}. a ^ Suc i) *\n       pderiv (case x of (a, i) \\<Rightarrow> a ^ Suc i) =\n       (\\<Prod>(x, y)\\<in>as. x ^ y) *\n       (case x of\n        (a, i) \\<Rightarrow>\n          (\\<Prod>(b, j)\\<in>as - {(a, i)}. b) *\n          smult (of_nat (Suc i)) (pderiv a))", "let ?si = \"smult (of_nat (Suc i)) :: 'a poly \\<Rightarrow> 'a poly\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> as \\<Longrightarrow>\n       (\\<Prod>(a, i)\\<in>as - {x}. a ^ Suc i) *\n       pderiv (case x of (a, i) \\<Rightarrow> a ^ Suc i) =\n       (\\<Prod>(x, y)\\<in>as. x ^ y) *\n       (case x of\n        (a, i) \\<Rightarrow>\n          (\\<Prod>(b, j)\\<in>as - {(a, i)}. b) *\n          smult (of_nat (Suc i)) (pderiv a))", "show \"(\\<Prod>(a, i)\\<in>as - {x}. a ^ Suc i) * pderiv (case x of (a, i) \\<Rightarrow> a ^ Suc i) =\n         (\\<Prod>(a, i)\\<in>as. a ^ i) *\n         (case x of (a, i) \\<Rightarrow> (\\<Prod>(a, i)\\<in>as - {(a, i)}. a) * smult (of_nat (Suc i)) (pderiv a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>(a, i)\\<in>as - {x}. a ^ Suc i) *\n    pderiv (case x of (a, i) \\<Rightarrow> a ^ Suc i) =\n    (\\<Prod>(a, i)\\<in>as. a ^ i) *\n    (case x of\n     (a, i) \\<Rightarrow>\n       (\\<Prod>(a, i)\\<in>as - {(a, i)}. a) *\n       smult (of_nat (Suc i)) (pderiv a))", "unfolding x split pderiv_power_Suc"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>(a, i)\\<in>as - {(a, i)}. a ^ Suc i) *\n    (smult (of_nat (Suc i)) (a ^ i) * pderiv a) =\n    (\\<Prod>(a, i)\\<in>as. a ^ i) *\n    ((\\<Prod>(a, i)\\<in>as - {(a, i)}. a) *\n     smult (of_nat (Suc i)) (pderiv a))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Prod>(a, i)\\<in>as - {(a, i)}. a ^ Suc i) *\n    (smult (of_nat (Suc i)) (a ^ i) * pderiv a) =\n    (\\<Prod>(a, i)\\<in>as. a ^ i) *\n    ((\\<Prod>(a, i)\\<in>as - {(a, i)}. a) *\n     smult (of_nat (Suc i)) (pderiv a))", "let ?prod = \"\\<Prod>(a, i)\\<in>as - {(a, i)}. a ^ Suc i\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Prod>(a, i)\\<in>as - {(a, i)}. a ^ Suc i) *\n    (smult (of_nat (Suc i)) (a ^ i) * pderiv a) =\n    (\\<Prod>(a, i)\\<in>as. a ^ i) *\n    ((\\<Prod>(a, i)\\<in>as - {(a, i)}. a) *\n     smult (of_nat (Suc i)) (pderiv a))", "let ?l = \"?prod * (?si (a ^ i) * pderiv a)\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Prod>(a, i)\\<in>as - {(a, i)}. a ^ Suc i) *\n    (smult (of_nat (Suc i)) (a ^ i) * pderiv a) =\n    (\\<Prod>(a, i)\\<in>as. a ^ i) *\n    ((\\<Prod>(a, i)\\<in>as - {(a, i)}. a) *\n     smult (of_nat (Suc i)) (pderiv a))", "let ?r = \"(\\<Prod>(a, i)\\<in>as. a ^ i) * ((\\<Prod>(a, i)\\<in>as - {(a, i)}. a) * ?si (pderiv a))\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Prod>(a, i)\\<in>as - {(a, i)}. a ^ Suc i) *\n    (smult (of_nat (Suc i)) (a ^ i) * pderiv a) =\n    (\\<Prod>(a, i)\\<in>as. a ^ i) *\n    ((\\<Prod>(a, i)\\<in>as - {(a, i)}. a) *\n     smult (of_nat (Suc i)) (pderiv a))", "have \"?r = a ^ i * ((\\<Prod>(a, i)\\<in>as - {(a, i)}. a ^ i) * (\\<Prod>(a, i)\\<in>as - {(a, i)}. a) * ?si (pderiv a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>(a, i)\\<in>as. a ^ i) *\n    ((\\<Prod>(a, i)\\<in>as - {(a, i)}. a) *\n     smult (of_nat (Suc i)) (pderiv a)) =\n    a ^ i *\n    ((\\<Prod>(a, i)\\<in>as - {(a, i)}. a ^ i) *\n     (\\<Prod>(a, i)\\<in>as - {(a, i)}. a) *\n     smult (of_nat (Suc i)) (pderiv a))", "unfolding prod.remove[OF fin mem]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case (a, i) of (x, xa) \\<Rightarrow> x ^ xa) *\n    (\\<Prod>(x, y)\\<in>as - {(a, i)}. x ^ y) *\n    ((\\<Prod>(a, i)\\<in>as - {(a, i)}. a) *\n     smult (of_nat (Suc i)) (pderiv a)) =\n    a ^ i *\n    ((\\<Prod>(a, i)\\<in>as - {(a, i)}. a ^ i) *\n     (\\<Prod>(a, i)\\<in>as - {(a, i)}. a) *\n     smult (of_nat (Suc i)) (pderiv a))", "by (simp add: ac_simps)"], ["proof (state)\nthis:\n  (\\<Prod>(a, i)\\<in>as. a ^ i) *\n  ((\\<Prod>(a, i)\\<in>as - {(a, i)}. a) *\n   smult (of_nat (Suc i)) (pderiv a)) =\n  a ^ i *\n  ((\\<Prod>(a, i)\\<in>as - {(a, i)}. a ^ i) *\n   (\\<Prod>(a, i)\\<in>as - {(a, i)}. a) *\n   smult (of_nat (Suc i)) (pderiv a))\n\ngoal (1 subgoal):\n 1. (\\<Prod>(a, i)\\<in>as - {(a, i)}. a ^ Suc i) *\n    (smult (of_nat (Suc i)) (a ^ i) * pderiv a) =\n    (\\<Prod>(a, i)\\<in>as. a ^ i) *\n    ((\\<Prod>(a, i)\\<in>as - {(a, i)}. a) *\n     smult (of_nat (Suc i)) (pderiv a))", "also"], ["proof (state)\nthis:\n  (\\<Prod>(a, i)\\<in>as. a ^ i) *\n  ((\\<Prod>(a, i)\\<in>as - {(a, i)}. a) *\n   smult (of_nat (Suc i)) (pderiv a)) =\n  a ^ i *\n  ((\\<Prod>(a, i)\\<in>as - {(a, i)}. a ^ i) *\n   (\\<Prod>(a, i)\\<in>as - {(a, i)}. a) *\n   smult (of_nat (Suc i)) (pderiv a))\n\ngoal (1 subgoal):\n 1. (\\<Prod>(a, i)\\<in>as - {(a, i)}. a ^ Suc i) *\n    (smult (of_nat (Suc i)) (a ^ i) * pderiv a) =\n    (\\<Prod>(a, i)\\<in>as. a ^ i) *\n    ((\\<Prod>(a, i)\\<in>as - {(a, i)}. a) *\n     smult (of_nat (Suc i)) (pderiv a))", "have \"(\\<Prod>(a, i)\\<in>as - {(a, i)}. a ^ i) * (\\<Prod>(a, i)\\<in>as - {(a, i)}. a) \n      = ?prod\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>(a, i)\\<in>as - {(a, i)}. a ^ i) *\n    (\\<Prod>(a, i)\\<in>as - {(a, i)}. a) =\n    (\\<Prod>(a, i)\\<in>as - {(a, i)}. a ^ Suc i)", "unfolding prod.distrib[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>x\\<in>as - {(a, i)}.\n       (case x of (x, xa) \\<Rightarrow> x ^ xa) *\n       (case x of (a, i) \\<Rightarrow> a)) =\n    (\\<Prod>(a, i)\\<in>as - {(a, i)}. a ^ Suc i)", "by (rule prod.cong[OF refl], auto)"], ["proof (state)\nthis:\n  (\\<Prod>(a, i)\\<in>as - {(a, i)}. a ^ i) *\n  (\\<Prod>(a, i)\\<in>as - {(a, i)}. a) =\n  (\\<Prod>(a, i)\\<in>as - {(a, i)}. a ^ Suc i)\n\ngoal (1 subgoal):\n 1. (\\<Prod>(a, i)\\<in>as - {(a, i)}. a ^ Suc i) *\n    (smult (of_nat (Suc i)) (a ^ i) * pderiv a) =\n    (\\<Prod>(a, i)\\<in>as. a ^ i) *\n    ((\\<Prod>(a, i)\\<in>as - {(a, i)}. a) *\n     smult (of_nat (Suc i)) (pderiv a))", "finally"], ["proof (chain)\npicking this:\n  (\\<Prod>a\\<in>as. case a of (a, i) \\<Rightarrow> a ^ i) *\n  ((\\<Prod>a\\<in>as - {(a, i)}. case a of (a, i) \\<Rightarrow> a) *\n   smult (of_nat (Suc i)) (pderiv a)) =\n  a ^ i *\n  ((\\<Prod>(a, i)\\<in>as - {(a, i)}. a ^ Suc i) *\n   smult (of_nat (Suc i)) (pderiv a))", "show \"?l = ?r\""], ["proof (prove)\nusing this:\n  (\\<Prod>a\\<in>as. case a of (a, i) \\<Rightarrow> a ^ i) *\n  ((\\<Prod>a\\<in>as - {(a, i)}. case a of (a, i) \\<Rightarrow> a) *\n   smult (of_nat (Suc i)) (pderiv a)) =\n  a ^ i *\n  ((\\<Prod>(a, i)\\<in>as - {(a, i)}. a ^ Suc i) *\n   smult (of_nat (Suc i)) (pderiv a))\n\ngoal (1 subgoal):\n 1. (\\<Prod>(a, i)\\<in>as - {(a, i)}. a ^ Suc i) *\n    (smult (of_nat (Suc i)) (a ^ i) * pderiv a) =\n    (\\<Prod>(a, i)\\<in>as. a ^ i) *\n    ((\\<Prod>(a, i)\\<in>as - {(a, i)}. a) *\n     smult (of_nat (Suc i)) (pderiv a))", "by (simp add: ac_simps)"], ["proof (state)\nthis:\n  (\\<Prod>(a, i)\\<in>as - {(a, i)}. a ^ Suc i) *\n  (smult (of_nat (Suc i)) (a ^ i) * pderiv a) =\n  (\\<Prod>(a, i)\\<in>as. a ^ i) *\n  ((\\<Prod>(a, i)\\<in>as - {(a, i)}. a) * smult (of_nat (Suc i)) (pderiv a))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Prod>(a, i)\\<in>as - {x}. a ^ Suc i) *\n  pderiv (case x of (a, i) \\<Rightarrow> a ^ Suc i) =\n  (\\<Prod>(a, i)\\<in>as. a ^ i) *\n  (case x of\n   (a, i) \\<Rightarrow>\n     (\\<Prod>(a, i)\\<in>as - {(a, i)}. a) *\n     smult (of_nat (Suc i)) (pderiv a))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma monic_gen: assumes \"bs \\<subseteq> as\"\n  shows \"monic (\\<Prod> (a, i) \\<in> bs. a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monic (\\<Prod>(a, i)\\<in>bs. a)", "by (rule monic_prod, insert assms as_monic, auto)"], ["", "lemma nonzero_gen: assumes \"bs \\<subseteq> as\"\n  shows \"(\\<Prod> (a, i) \\<in> bs. a) \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>(a, i)\\<in>bs. a) \\<noteq> 0", "using monic_gen[OF assms]"], ["proof (prove)\nusing this:\n  monic (\\<Prod>(a, i)\\<in>bs. a)\n\ngoal (1 subgoal):\n 1. (\\<Prod>(a, i)\\<in>bs. a) \\<noteq> 0", "by auto"], ["", "lemma monic_Prod: \"monic ((\\<Prod>(a, i)\\<in>as. a ^ i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monic (\\<Prod>(a, i)\\<in>as. a ^ i)", "by (rule monic_prod, insert as_monic, auto intro: monic_power)"], ["", "lemma coprime_generic:\n  assumes bs: \"bs \\<subseteq> as\"\n  and f: \"\\<And> a i. (a,i) \\<in> bs \\<Longrightarrow> f i > 0\"\n  shows \"coprime (\\<Prod>(a, i) \\<in> bs. a)\n     (\\<Sum>(a, i)\\<in> bs. (\\<Prod>(b, j)\\<in> bs - {(a, i)} . b) * smult (of_nat (f i)) (pderiv a))\"\n  (is \"coprime ?single ?onederiv\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. coprime (\\<Prod>(a, i)\\<in>bs. a)\n     (\\<Sum>(a, i)\\<in>bs.\n        (\\<Prod>(b, j)\\<in>bs - {(a, i)}. b) *\n        smult (of_nat (f i)) (pderiv a))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. coprime (\\<Prod>(a, i)\\<in>bs. a)\n     (\\<Sum>(a, i)\\<in>bs.\n        (\\<Prod>(b, j)\\<in>bs - {(a, i)}. b) *\n        smult (of_nat (f i)) (pderiv a))", "have single: \"?single \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>(a, i)\\<in>bs. a) \\<noteq> 0", "by (rule nonzero_gen[OF bs])"], ["proof (state)\nthis:\n  (\\<Prod>(a, i)\\<in>bs. a) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. coprime (\\<Prod>(a, i)\\<in>bs. a)\n     (\\<Sum>(a, i)\\<in>bs.\n        (\\<Prod>(b, j)\\<in>bs - {(a, i)}. b) *\n        smult (of_nat (f i)) (pderiv a))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. coprime (\\<Prod>(a, i)\\<in>bs. a)\n     (\\<Sum>(a, i)\\<in>bs.\n        (\\<Prod>(b, j)\\<in>bs - {(a, i)}. b) *\n        smult (of_nat (f i)) (pderiv a))", "proof (rule gcd_eq_1_imp_coprime, rule gcdI [symmetric])"], ["proof (state)\ngoal (4 subgoals):\n 1. 1 dvd (\\<Prod>(a, i)\\<in>bs. a)\n 2. 1 dvd\n    (\\<Sum>(a, i)\\<in>bs.\n       (\\<Prod>(b, j)\\<in>bs - {(a, i)}. b) *\n       smult (of_nat (f i)) (pderiv a))\n 3. \\<And>d.\n       \\<lbrakk>d dvd (\\<Prod>(a, i)\\<in>bs. a);\n        d dvd\n        (\\<Sum>(a, i)\\<in>bs.\n           (\\<Prod>(b, j)\\<in>bs - {(a, i)}. b) *\n           smult (of_nat (f i)) (pderiv a))\\<rbrakk>\n       \\<Longrightarrow> is_unit d\n 4. normalize 1 = 1", "fix k"], ["proof (state)\ngoal (4 subgoals):\n 1. 1 dvd (\\<Prod>(a, i)\\<in>bs. a)\n 2. 1 dvd\n    (\\<Sum>(a, i)\\<in>bs.\n       (\\<Prod>(b, j)\\<in>bs - {(a, i)}. b) *\n       smult (of_nat (f i)) (pderiv a))\n 3. \\<And>d.\n       \\<lbrakk>d dvd (\\<Prod>(a, i)\\<in>bs. a);\n        d dvd\n        (\\<Sum>(a, i)\\<in>bs.\n           (\\<Prod>(b, j)\\<in>bs - {(a, i)}. b) *\n           smult (of_nat (f i)) (pderiv a))\\<rbrakk>\n       \\<Longrightarrow> is_unit d\n 4. normalize 1 = 1", "assume dvd: \"k dvd ?single\" \"k dvd ?onederiv\""], ["proof (state)\nthis:\n  k dvd (\\<Prod>(a, i)\\<in>bs. a)\n  k dvd\n  (\\<Sum>(a, i)\\<in>bs.\n     (\\<Prod>(b, j)\\<in>bs - {(a, i)}. b) * smult (of_nat (f i)) (pderiv a))\n\ngoal (4 subgoals):\n 1. 1 dvd (\\<Prod>(a, i)\\<in>bs. a)\n 2. 1 dvd\n    (\\<Sum>(a, i)\\<in>bs.\n       (\\<Prod>(b, j)\\<in>bs - {(a, i)}. b) *\n       smult (of_nat (f i)) (pderiv a))\n 3. \\<And>d.\n       \\<lbrakk>d dvd (\\<Prod>(a, i)\\<in>bs. a);\n        d dvd\n        (\\<Sum>(a, i)\\<in>bs.\n           (\\<Prod>(b, j)\\<in>bs - {(a, i)}. b) *\n           smult (of_nat (f i)) (pderiv a))\\<rbrakk>\n       \\<Longrightarrow> is_unit d\n 4. normalize 1 = 1", "note bs_monic = as_monic[OF subsetD[OF bs]]"], ["proof (state)\nthis:\n  (?a, ?i) \\<in> bs \\<Longrightarrow> monic ?a\n\ngoal (4 subgoals):\n 1. 1 dvd (\\<Prod>(a, i)\\<in>bs. a)\n 2. 1 dvd\n    (\\<Sum>(a, i)\\<in>bs.\n       (\\<Prod>(b, j)\\<in>bs - {(a, i)}. b) *\n       smult (of_nat (f i)) (pderiv a))\n 3. \\<And>d.\n       \\<lbrakk>d dvd (\\<Prod>(a, i)\\<in>bs. a);\n        d dvd\n        (\\<Sum>(a, i)\\<in>bs.\n           (\\<Prod>(b, j)\\<in>bs - {(a, i)}. b) *\n           smult (of_nat (f i)) (pderiv a))\\<rbrakk>\n       \\<Longrightarrow> is_unit d\n 4. normalize 1 = 1", "from dvd(1) single"], ["proof (chain)\npicking this:\n  k dvd (\\<Prod>(a, i)\\<in>bs. a)\n  (\\<Prod>(a, i)\\<in>bs. a) \\<noteq> 0", "have k: \"k \\<noteq> 0\""], ["proof (prove)\nusing this:\n  k dvd (\\<Prod>(a, i)\\<in>bs. a)\n  (\\<Prod>(a, i)\\<in>bs. a) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. k \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  k \\<noteq> 0\n\ngoal (4 subgoals):\n 1. 1 dvd (\\<Prod>(a, i)\\<in>bs. a)\n 2. 1 dvd\n    (\\<Sum>(a, i)\\<in>bs.\n       (\\<Prod>(b, j)\\<in>bs - {(a, i)}. b) *\n       smult (of_nat (f i)) (pderiv a))\n 3. \\<And>d.\n       \\<lbrakk>d dvd (\\<Prod>(a, i)\\<in>bs. a);\n        d dvd\n        (\\<Sum>(a, i)\\<in>bs.\n           (\\<Prod>(b, j)\\<in>bs - {(a, i)}. b) *\n           smult (of_nat (f i)) (pderiv a))\\<rbrakk>\n       \\<Longrightarrow> is_unit d\n 4. normalize 1 = 1", "show \"k dvd 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_unit k", "proof (cases \"degree k > 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 < degree k \\<Longrightarrow> is_unit k\n 2. \\<not> 0 < degree k \\<Longrightarrow> is_unit k", "case False"], ["proof (state)\nthis:\n  \\<not> 0 < degree k\n\ngoal (2 subgoals):\n 1. 0 < degree k \\<Longrightarrow> is_unit k\n 2. \\<not> 0 < degree k \\<Longrightarrow> is_unit k", "with k"], ["proof (chain)\npicking this:\n  k \\<noteq> 0\n  \\<not> 0 < degree k", "obtain c where \"k = [:c:]\""], ["proof (prove)\nusing this:\n  k \\<noteq> 0\n  \\<not> 0 < degree k\n\ngoal (1 subgoal):\n 1. (\\<And>c. k = [:c:] \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by (auto dest: degree0_coeffs)"], ["proof (state)\nthis:\n  k = [:c:]\n\ngoal (2 subgoals):\n 1. 0 < degree k \\<Longrightarrow> is_unit k\n 2. \\<not> 0 < degree k \\<Longrightarrow> is_unit k", "with k"], ["proof (chain)\npicking this:\n  k \\<noteq> 0\n  k = [:c:]", "have \"c \\<noteq> 0\""], ["proof (prove)\nusing this:\n  k \\<noteq> 0\n  k = [:c:]\n\ngoal (1 subgoal):\n 1. c \\<noteq> (0::'a)", "by auto"], ["proof (state)\nthis:\n  c \\<noteq> (0::'a)\n\ngoal (2 subgoals):\n 1. 0 < degree k \\<Longrightarrow> is_unit k\n 2. \\<not> 0 < degree k \\<Longrightarrow> is_unit k", "with \\<open>k = [:c:]\\<close>"], ["proof (chain)\npicking this:\n  k = [:c:]\n  c \\<noteq> (0::'a)", "show \"is_unit k\""], ["proof (prove)\nusing this:\n  k = [:c:]\n  c \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. is_unit k", "using dvdI [of 1 \"[:c:]\" \"[:1 / c:]\"]"], ["proof (prove)\nusing this:\n  k = [:c:]\n  c \\<noteq> (0::'a)\n  1 = [:c:] * [:(1::'a) / c:] \\<Longrightarrow> is_unit [:c:]\n\ngoal (1 subgoal):\n 1. is_unit k", "by auto"], ["proof (state)\nthis:\n  is_unit k\n\ngoal (1 subgoal):\n 1. 0 < degree k \\<Longrightarrow> is_unit k", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. 0 < degree k \\<Longrightarrow> is_unit k", "case True"], ["proof (state)\nthis:\n  0 < degree k\n\ngoal (1 subgoal):\n 1. 0 < degree k \\<Longrightarrow> is_unit k", "from irreducible\\<^sub>d_factor[OF this]"], ["proof (chain)\npicking this:\n  \\<exists>q r.\n     irreducible\\<^sub>d q \\<and> k = q * r \\<and> degree r < degree k", "obtain p q where k: \"k = p * q\" and p: \"irreducible p\""], ["proof (prove)\nusing this:\n  \\<exists>q r.\n     irreducible\\<^sub>d q \\<and> k = q * r \\<and> degree r < degree k\n\ngoal (1 subgoal):\n 1. (\\<And>p q.\n        \\<lbrakk>k = p * q; irreducible p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  k = p * q\n  irreducible p\n\ngoal (1 subgoal):\n 1. 0 < degree k \\<Longrightarrow> is_unit k", "from k dvd"], ["proof (chain)\npicking this:\n  k = p * q\n  k dvd (\\<Prod>(a, i)\\<in>bs. a)\n  k dvd\n  (\\<Sum>(a, i)\\<in>bs.\n     (\\<Prod>(b, j)\\<in>bs - {(a, i)}. b) * smult (of_nat (f i)) (pderiv a))", "have dvd: \"p dvd ?single\" \"p dvd ?onederiv\""], ["proof (prove)\nusing this:\n  k = p * q\n  k dvd (\\<Prod>(a, i)\\<in>bs. a)\n  k dvd\n  (\\<Sum>(a, i)\\<in>bs.\n     (\\<Prod>(b, j)\\<in>bs - {(a, i)}. b) * smult (of_nat (f i)) (pderiv a))\n\ngoal (1 subgoal):\n 1. p dvd (\\<Prod>(a, i)\\<in>bs. a) &&&\n    p dvd\n    (\\<Sum>(a, i)\\<in>bs.\n       (\\<Prod>(b, j)\\<in>bs - {(a, i)}. b) *\n       smult (of_nat (f i)) (pderiv a))", "unfolding dvd_def"], ["proof (prove)\nusing this:\n  k = p * q\n  \\<exists>ka. (\\<Prod>(a, i)\\<in>bs. a) = k * ka\n  \\<exists>ka.\n     (\\<Sum>(a, i)\\<in>bs.\n        (\\<Prod>(b, j)\\<in>bs - {(a, i)}. b) *\n        smult (of_nat (f i)) (pderiv a)) =\n     k * ka\n\ngoal (1 subgoal):\n 1. \\<exists>k. (\\<Prod>(a, i)\\<in>bs. a) = p * k &&&\n    \\<exists>k.\n       (\\<Sum>(a, i)\\<in>bs.\n          (\\<Prod>(b, j)\\<in>bs - {(a, i)}. b) *\n          smult (of_nat (f i)) (pderiv a)) =\n       p * k", "by auto"], ["proof (state)\nthis:\n  p dvd (\\<Prod>(a, i)\\<in>bs. a)\n  p dvd\n  (\\<Sum>(a, i)\\<in>bs.\n     (\\<Prod>(b, j)\\<in>bs - {(a, i)}. b) * smult (of_nat (f i)) (pderiv a))\n\ngoal (1 subgoal):\n 1. 0 < degree k \\<Longrightarrow> is_unit k", "from irreducible_dvd_prod[OF p dvd(1)]"], ["proof (chain)\npicking this:\n  \\<exists>a\\<in>bs. p dvd (case a of (a, i) \\<Rightarrow> a)", "obtain a i where ai: \"(a,i) \\<in> bs\" and pa: \"p dvd a\""], ["proof (prove)\nusing this:\n  \\<exists>a\\<in>bs. p dvd (case a of (a, i) \\<Rightarrow> a)\n\ngoal (1 subgoal):\n 1. (\\<And>a i.\n        \\<lbrakk>(a, i) \\<in> bs; p dvd a\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  (a, i) \\<in> bs\n  p dvd a\n\ngoal (1 subgoal):\n 1. 0 < degree k \\<Longrightarrow> is_unit k", "then"], ["proof (chain)\npicking this:\n  (a, i) \\<in> bs\n  p dvd a", "obtain q where a: \"a = p * q\""], ["proof (prove)\nusing this:\n  (a, i) \\<in> bs\n  p dvd a\n\ngoal (1 subgoal):\n 1. (\\<And>q. a = p * q \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "unfolding dvd_def"], ["proof (prove)\nusing this:\n  (a, i) \\<in> bs\n  \\<exists>k. a = p * k\n\ngoal (1 subgoal):\n 1. (\\<And>q. a = p * q \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  a = p * q\n\ngoal (1 subgoal):\n 1. 0 < degree k \\<Longrightarrow> is_unit k", "from p[unfolded irreducible\\<^sub>d_def]"], ["proof (chain)\npicking this:\n  irreducible p", "have p0: \"degree p > 0\""], ["proof (prove)\nusing this:\n  irreducible p\n\ngoal (1 subgoal):\n 1. 0 < degree p", "by auto"], ["proof (state)\nthis:\n  0 < degree p\n\ngoal (1 subgoal):\n 1. 0 < degree k \\<Longrightarrow> is_unit k", "from irreducible\\<^sub>d_dvd_smult[OF p0 as_irred pa] ai bs"], ["proof (chain)\npicking this:\n  (a, ?i1) \\<in> as \\<Longrightarrow>\n  \\<exists>c. c \\<noteq> (0::'a) \\<and> a = smult c p\n  (a, i) \\<in> bs\n  bs \\<subseteq> as", "obtain c where c: \"c \\<noteq> 0\" and ap: \"a = smult c p\""], ["proof (prove)\nusing this:\n  (a, ?i1) \\<in> as \\<Longrightarrow>\n  \\<exists>c. c \\<noteq> (0::'a) \\<and> a = smult c p\n  (a, i) \\<in> bs\n  bs \\<subseteq> as\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        \\<lbrakk>c \\<noteq> (0::'a); a = smult c p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  c \\<noteq> (0::'a)\n  a = smult c p\n\ngoal (1 subgoal):\n 1. 0 < degree k \\<Longrightarrow> is_unit k", "hence ap': \"p = smult (1/c) a\""], ["proof (prove)\nusing this:\n  c \\<noteq> (0::'a)\n  a = smult c p\n\ngoal (1 subgoal):\n 1. p = smult ((1::'a) / c) a", "by auto"], ["proof (state)\nthis:\n  p = smult ((1::'a) / c) a\n\ngoal (1 subgoal):\n 1. 0 < degree k \\<Longrightarrow> is_unit k", "let ?prod = \"\\<lambda> a i. (\\<Prod>(b, j)\\<in>bs - {(a, i)}. b) * smult (of_nat (f i)) (pderiv a)\""], ["proof (state)\ngoal (1 subgoal):\n 1. 0 < degree k \\<Longrightarrow> is_unit k", "let ?prod' = \"\\<lambda> aa ii a i. (\\<Prod>(b, j)\\<in>bs - {(a, i),(aa,ii)}. b) * smult (of_nat (f i)) (pderiv a)\""], ["proof (state)\ngoal (1 subgoal):\n 1. 0 < degree k \\<Longrightarrow> is_unit k", "define factor where \"factor = sum (\\<lambda> (b,j). ?prod' a i b j ) (bs - {(a,i)})\""], ["proof (state)\nthis:\n  factor =\n  (\\<Sum>(b, j)\\<in>bs - {(a, i)}.\n     (\\<Prod>(b, j)\\<in>bs - {(b, j), (a, i)}. b) *\n     smult (of_nat (f j)) (pderiv b))\n\ngoal (1 subgoal):\n 1. 0 < degree k \\<Longrightarrow> is_unit k", "define fac where \"fac = q * factor\""], ["proof (state)\nthis:\n  fac = q * factor\n\ngoal (1 subgoal):\n 1. 0 < degree k \\<Longrightarrow> is_unit k", "from fin finite_subset[OF bs]"], ["proof (chain)\npicking this:\n  finite as\n  finite as \\<Longrightarrow> finite bs", "have fin: \"finite bs\""], ["proof (prove)\nusing this:\n  finite as\n  finite as \\<Longrightarrow> finite bs\n\ngoal (1 subgoal):\n 1. finite bs", "by auto"], ["proof (state)\nthis:\n  finite bs\n\ngoal (1 subgoal):\n 1. 0 < degree k \\<Longrightarrow> is_unit k", "have \"?onederiv = ?prod a i + sum (\\<lambda> (b,j). ?prod b j) (bs - {(a,i)})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(a, i)\\<in>bs.\n       (\\<Prod>(b, j)\\<in>bs - {(a, i)}. b) *\n       smult (of_nat (f i)) (pderiv a)) =\n    (\\<Prod>(b, j)\\<in>bs - {(a, i)}. b) * smult (of_nat (f i)) (pderiv a) +\n    (\\<Sum>(b, j)\\<in>bs - {(a, i)}.\n       (\\<Prod>(b, j)\\<in>bs - {(b, j)}. b) *\n       smult (of_nat (f j)) (pderiv b))", "by (subst sum.remove[OF fin ai], auto)"], ["proof (state)\nthis:\n  (\\<Sum>(a, i)\\<in>bs.\n     (\\<Prod>(b, j)\\<in>bs - {(a, i)}. b) *\n     smult (of_nat (f i)) (pderiv a)) =\n  (\\<Prod>(b, j)\\<in>bs - {(a, i)}. b) * smult (of_nat (f i)) (pderiv a) +\n  (\\<Sum>(b, j)\\<in>bs - {(a, i)}.\n     (\\<Prod>(b, j)\\<in>bs - {(b, j)}. b) * smult (of_nat (f j)) (pderiv b))\n\ngoal (1 subgoal):\n 1. 0 < degree k \\<Longrightarrow> is_unit k", "also"], ["proof (state)\nthis:\n  (\\<Sum>(a, i)\\<in>bs.\n     (\\<Prod>(b, j)\\<in>bs - {(a, i)}. b) *\n     smult (of_nat (f i)) (pderiv a)) =\n  (\\<Prod>(b, j)\\<in>bs - {(a, i)}. b) * smult (of_nat (f i)) (pderiv a) +\n  (\\<Sum>(b, j)\\<in>bs - {(a, i)}.\n     (\\<Prod>(b, j)\\<in>bs - {(b, j)}. b) * smult (of_nat (f j)) (pderiv b))\n\ngoal (1 subgoal):\n 1. 0 < degree k \\<Longrightarrow> is_unit k", "have \"sum (\\<lambda> (b,j). ?prod b j) (bs - {(a,i)})\n        = a * factor\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(b, j)\\<in>bs - {(a, i)}.\n       (\\<Prod>(b, j)\\<in>bs - {(b, j)}. b) *\n       smult (of_nat (f j)) (pderiv b)) =\n    a * factor", "unfolding factor_def sum_distrib_left"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(b, j)\\<in>bs - {(a, i)}.\n       (\\<Prod>(b, j)\\<in>bs - {(b, j)}. b) *\n       smult (of_nat (f j)) (pderiv b)) =\n    (\\<Sum>n\\<in>bs - {(a, i)}.\n       a *\n       (case n of\n        (b, j) \\<Rightarrow>\n          (\\<Prod>(b, j)\\<in>bs - {(b, j), (a, i)}. b) *\n          smult (of_nat (f j)) (pderiv b)))", "proof (rule sum.cong[OF refl])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> bs - {(a, i)} \\<Longrightarrow>\n       (case x of\n        (b, j) \\<Rightarrow>\n          (\\<Prod>(b, j)\\<in>bs - {(b, j)}. b) *\n          smult (of_nat (f j)) (pderiv b)) =\n       a *\n       (case x of\n        (b, j) \\<Rightarrow>\n          (\\<Prod>(b, j)\\<in>bs - {(b, j), (a, i)}. b) *\n          smult (of_nat (f j)) (pderiv b))", "fix bj"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> bs - {(a, i)} \\<Longrightarrow>\n       (case x of\n        (b, j) \\<Rightarrow>\n          (\\<Prod>(b, j)\\<in>bs - {(b, j)}. b) *\n          smult (of_nat (f j)) (pderiv b)) =\n       a *\n       (case x of\n        (b, j) \\<Rightarrow>\n          (\\<Prod>(b, j)\\<in>bs - {(b, j), (a, i)}. b) *\n          smult (of_nat (f j)) (pderiv b))", "assume mem: \"bj \\<in> bs - {(a,i)}\""], ["proof (state)\nthis:\n  bj \\<in> bs - {(a, i)}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> bs - {(a, i)} \\<Longrightarrow>\n       (case x of\n        (b, j) \\<Rightarrow>\n          (\\<Prod>(b, j)\\<in>bs - {(b, j)}. b) *\n          smult (of_nat (f j)) (pderiv b)) =\n       a *\n       (case x of\n        (b, j) \\<Rightarrow>\n          (\\<Prod>(b, j)\\<in>bs - {(b, j), (a, i)}. b) *\n          smult (of_nat (f j)) (pderiv b))", "obtain b j where bj: \"bj = (b,j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>b j. bj = (b, j) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  bj = (b, j)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> bs - {(a, i)} \\<Longrightarrow>\n       (case x of\n        (b, j) \\<Rightarrow>\n          (\\<Prod>(b, j)\\<in>bs - {(b, j)}. b) *\n          smult (of_nat (f j)) (pderiv b)) =\n       a *\n       (case x of\n        (b, j) \\<Rightarrow>\n          (\\<Prod>(b, j)\\<in>bs - {(b, j), (a, i)}. b) *\n          smult (of_nat (f j)) (pderiv b))", "from mem bj ai"], ["proof (chain)\npicking this:\n  bj \\<in> bs - {(a, i)}\n  bj = (b, j)\n  (a, i) \\<in> bs", "have ai: \"(a,i) \\<in> bs - {(b,j)}\""], ["proof (prove)\nusing this:\n  bj \\<in> bs - {(a, i)}\n  bj = (b, j)\n  (a, i) \\<in> bs\n\ngoal (1 subgoal):\n 1. (a, i) \\<in> bs - {(b, j)}", "by auto"], ["proof (state)\nthis:\n  (a, i) \\<in> bs - {(b, j)}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> bs - {(a, i)} \\<Longrightarrow>\n       (case x of\n        (b, j) \\<Rightarrow>\n          (\\<Prod>(b, j)\\<in>bs - {(b, j)}. b) *\n          smult (of_nat (f j)) (pderiv b)) =\n       a *\n       (case x of\n        (b, j) \\<Rightarrow>\n          (\\<Prod>(b, j)\\<in>bs - {(b, j), (a, i)}. b) *\n          smult (of_nat (f j)) (pderiv b))", "have id: \"bs - {(b, j)} - {(a, i)} = bs - {(b,j),(a,i)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bs - {(b, j)} - {(a, i)} = bs - {(b, j), (a, i)}", "by auto"], ["proof (state)\nthis:\n  bs - {(b, j)} - {(a, i)} = bs - {(b, j), (a, i)}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> bs - {(a, i)} \\<Longrightarrow>\n       (case x of\n        (b, j) \\<Rightarrow>\n          (\\<Prod>(b, j)\\<in>bs - {(b, j)}. b) *\n          smult (of_nat (f j)) (pderiv b)) =\n       a *\n       (case x of\n        (b, j) \\<Rightarrow>\n          (\\<Prod>(b, j)\\<in>bs - {(b, j), (a, i)}. b) *\n          smult (of_nat (f j)) (pderiv b))", "show \"(\\<lambda> (b,j). ?prod b j) bj = a * (\\<lambda> (b,j). ?prod' a i b j) bj\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (case bj of\n     (b, j) \\<Rightarrow>\n       (\\<Prod>(b, j)\\<in>bs - {(b, j)}. b) *\n       smult (of_nat (f j)) (pderiv b)) =\n    a *\n    (case bj of\n     (b, j) \\<Rightarrow>\n       (\\<Prod>(b, j)\\<in>bs - {(b, j), (a, i)}. b) *\n       smult (of_nat (f j)) (pderiv b))", "unfolding bj split"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>(b, j)\\<in>bs - {(b, j)}. b) * smult (of_nat (f j)) (pderiv b) =\n    a *\n    ((\\<Prod>(b, j)\\<in>bs - {(b, j), (a, i)}. b) *\n     smult (of_nat (f j)) (pderiv b))", "by (subst prod.remove[OF _ ai], insert fin, auto simp: id ac_simps)"], ["proof (state)\nthis:\n  (case bj of\n   (b, j) \\<Rightarrow>\n     (\\<Prod>(b, j)\\<in>bs - {(b, j)}. b) *\n     smult (of_nat (f j)) (pderiv b)) =\n  a *\n  (case bj of\n   (b, j) \\<Rightarrow>\n     (\\<Prod>(b, j)\\<in>bs - {(b, j), (a, i)}. b) *\n     smult (of_nat (f j)) (pderiv b))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>(b, j)\\<in>bs - {(a, i)}.\n     (\\<Prod>(b, j)\\<in>bs - {(b, j)}. b) *\n     smult (of_nat (f j)) (pderiv b)) =\n  a * factor\n\ngoal (1 subgoal):\n 1. 0 < degree k \\<Longrightarrow> is_unit k", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>a\\<in>bs.\n     case a of\n     (a, i) \\<Rightarrow>\n       (\\<Prod>a\\<in>bs - {(a, i)}. case a of (b, j) \\<Rightarrow> b) *\n       smult (of_nat (f i)) (pderiv a)) =\n  (\\<Prod>a\\<in>bs - {(a, i)}. case a of (b, j) \\<Rightarrow> b) *\n  smult (of_nat (f i)) (pderiv a) +\n  a * factor", "have \"?onederiv = ?prod a i + p * fac\""], ["proof (prove)\nusing this:\n  (\\<Sum>a\\<in>bs.\n     case a of\n     (a, i) \\<Rightarrow>\n       (\\<Prod>a\\<in>bs - {(a, i)}. case a of (b, j) \\<Rightarrow> b) *\n       smult (of_nat (f i)) (pderiv a)) =\n  (\\<Prod>a\\<in>bs - {(a, i)}. case a of (b, j) \\<Rightarrow> b) *\n  smult (of_nat (f i)) (pderiv a) +\n  a * factor\n\ngoal (1 subgoal):\n 1. (\\<Sum>(a, i)\\<in>bs.\n       (\\<Prod>(b, j)\\<in>bs - {(a, i)}. b) *\n       smult (of_nat (f i)) (pderiv a)) =\n    (\\<Prod>(b, j)\\<in>bs - {(a, i)}. b) * smult (of_nat (f i)) (pderiv a) +\n    p * fac", "unfolding fac_def a"], ["proof (prove)\nusing this:\n  (\\<Sum>a\\<in>bs.\n     case a of\n     (a, i) \\<Rightarrow>\n       (\\<Prod>a\\<in>bs - {(a, i)}. case a of (b, j) \\<Rightarrow> b) *\n       smult (of_nat (f i)) (pderiv a)) =\n  (\\<Prod>a\\<in>bs - {(p * q, i)}. case a of (b, j) \\<Rightarrow> b) *\n  smult (of_nat (f i)) (pderiv (p * q)) +\n  p * q * factor\n\ngoal (1 subgoal):\n 1. (\\<Sum>(a, i)\\<in>bs.\n       (\\<Prod>(b, j)\\<in>bs - {(a, i)}. b) *\n       smult (of_nat (f i)) (pderiv a)) =\n    (\\<Prod>(b, j)\\<in>bs - {(p * q, i)}. b) *\n    smult (of_nat (f i)) (pderiv (p * q)) +\n    p * (q * factor)", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>(a, i)\\<in>bs.\n     (\\<Prod>(b, j)\\<in>bs - {(a, i)}. b) *\n     smult (of_nat (f i)) (pderiv a)) =\n  (\\<Prod>(b, j)\\<in>bs - {(a, i)}. b) * smult (of_nat (f i)) (pderiv a) +\n  p * fac\n\ngoal (1 subgoal):\n 1. 0 < degree k \\<Longrightarrow> is_unit k", "from dvd(2)[unfolded this]"], ["proof (chain)\npicking this:\n  p dvd\n  (\\<Prod>(b, j)\\<in>bs - {(a, i)}. b) * smult (of_nat (f i)) (pderiv a) +\n  p * fac", "have \"p dvd ?prod a i\""], ["proof (prove)\nusing this:\n  p dvd\n  (\\<Prod>(b, j)\\<in>bs - {(a, i)}. b) * smult (of_nat (f i)) (pderiv a) +\n  p * fac\n\ngoal (1 subgoal):\n 1. p dvd\n    (\\<Prod>(b, j)\\<in>bs - {(a, i)}. b) * smult (of_nat (f i)) (pderiv a)", "by algebra"], ["proof (state)\nthis:\n  p dvd\n  (\\<Prod>(b, j)\\<in>bs - {(a, i)}. b) * smult (of_nat (f i)) (pderiv a)\n\ngoal (1 subgoal):\n 1. 0 < degree k \\<Longrightarrow> is_unit k", "from this[unfolded field_poly_irreducible_dvd_mult[OF p]]"], ["proof (chain)\npicking this:\n  p dvd (\\<Prod>(b, j)\\<in>bs - {(a, i)}. b) \\<or>\n  p dvd smult (of_nat (f i)) (pderiv a)", "have False"], ["proof (prove)\nusing this:\n  p dvd (\\<Prod>(b, j)\\<in>bs - {(a, i)}. b) \\<or>\n  p dvd smult (of_nat (f i)) (pderiv a)\n\ngoal (1 subgoal):\n 1. False", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. p dvd (\\<Prod>(b, j)\\<in>bs - {(a, i)}. b) \\<Longrightarrow> False\n 2. p dvd smult (of_nat (f i)) (pderiv a) \\<Longrightarrow> False", "assume \"p dvd (\\<Prod>(b, j)\\<in>bs - {(a, i)}. b)\""], ["proof (state)\nthis:\n  p dvd (\\<Prod>(b, j)\\<in>bs - {(a, i)}. b)\n\ngoal (2 subgoals):\n 1. p dvd (\\<Prod>(b, j)\\<in>bs - {(a, i)}. b) \\<Longrightarrow> False\n 2. p dvd smult (of_nat (f i)) (pderiv a) \\<Longrightarrow> False", "from irreducible_dvd_prod[OF p this]"], ["proof (chain)\npicking this:\n  \\<exists>a\\<in>bs - {(a, i)}. p dvd (case a of (b, j) \\<Rightarrow> b)", "obtain b j where bj': \"(b,j) \\<in> bs - {(a,i)}\"\n          and pb: \"p dvd b\""], ["proof (prove)\nusing this:\n  \\<exists>a\\<in>bs - {(a, i)}. p dvd (case a of (b, j) \\<Rightarrow> b)\n\ngoal (1 subgoal):\n 1. (\\<And>b j.\n        \\<lbrakk>(b, j) \\<in> bs - {(a, i)}; p dvd b\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  (b, j) \\<in> bs - {(a, i)}\n  p dvd b\n\ngoal (2 subgoals):\n 1. p dvd (\\<Prod>(b, j)\\<in>bs - {(a, i)}. b) \\<Longrightarrow> False\n 2. p dvd smult (of_nat (f i)) (pderiv a) \\<Longrightarrow> False", "hence bj: \"(b,j) \\<in> bs\""], ["proof (prove)\nusing this:\n  (b, j) \\<in> bs - {(a, i)}\n  p dvd b\n\ngoal (1 subgoal):\n 1. (b, j) \\<in> bs", "by auto"], ["proof (state)\nthis:\n  (b, j) \\<in> bs\n\ngoal (2 subgoals):\n 1. p dvd (\\<Prod>(b, j)\\<in>bs - {(a, i)}. b) \\<Longrightarrow> False\n 2. p dvd smult (of_nat (f i)) (pderiv a) \\<Longrightarrow> False", "from as_irred bj bs"], ["proof (chain)\npicking this:\n  (?a, ?i) \\<in> as \\<Longrightarrow> irreducible\\<^sub>d ?a\n  (b, j) \\<in> bs\n  bs \\<subseteq> as", "have \"irreducible\\<^sub>d b\""], ["proof (prove)\nusing this:\n  (?a, ?i) \\<in> as \\<Longrightarrow> irreducible\\<^sub>d ?a\n  (b, j) \\<in> bs\n  bs \\<subseteq> as\n\ngoal (1 subgoal):\n 1. irreducible\\<^sub>d b", "by auto"], ["proof (state)\nthis:\n  irreducible\\<^sub>d b\n\ngoal (2 subgoals):\n 1. p dvd (\\<Prod>(b, j)\\<in>bs - {(a, i)}. b) \\<Longrightarrow> False\n 2. p dvd smult (of_nat (f i)) (pderiv a) \\<Longrightarrow> False", "from irreducible\\<^sub>d_dvd_smult[OF p0 this pb]"], ["proof (chain)\npicking this:\n  \\<exists>c. c \\<noteq> (0::'a) \\<and> b = smult c p", "obtain d where d: \"d \\<noteq> 0\" \n          and b: \"b = smult d p\""], ["proof (prove)\nusing this:\n  \\<exists>c. c \\<noteq> (0::'a) \\<and> b = smult c p\n\ngoal (1 subgoal):\n 1. (\\<And>d.\n        \\<lbrakk>d \\<noteq> (0::'a); b = smult d p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  d \\<noteq> (0::'a)\n  b = smult d p\n\ngoal (2 subgoals):\n 1. p dvd (\\<Prod>(b, j)\\<in>bs - {(a, i)}. b) \\<Longrightarrow> False\n 2. p dvd smult (of_nat (f i)) (pderiv a) \\<Longrightarrow> False", "with ap c"], ["proof (chain)\npicking this:\n  a = smult c p\n  c \\<noteq> (0::'a)\n  d \\<noteq> (0::'a)\n  b = smult d p", "have id: \"smult (c/d) b = a\" and deg: \"degree a = degree b\""], ["proof (prove)\nusing this:\n  a = smult c p\n  c \\<noteq> (0::'a)\n  d \\<noteq> (0::'a)\n  b = smult d p\n\ngoal (1 subgoal):\n 1. smult (c / d) b = a &&& degree a = degree b", "by auto"], ["proof (state)\nthis:\n  smult (c / d) b = a\n  degree a = degree b\n\ngoal (2 subgoals):\n 1. p dvd (\\<Prod>(b, j)\\<in>bs - {(a, i)}. b) \\<Longrightarrow> False\n 2. p dvd smult (of_nat (f i)) (pderiv a) \\<Longrightarrow> False", "from coeff_smult[of \"c/d\" b \"degree b\", unfolded id] deg bs_monic[OF ai] bs_monic[OF bj]"], ["proof (chain)\npicking this:\n  coeff a (degree b) = c / d * lead_coeff b\n  degree a = degree b\n  monic a\n  monic b", "have \"c / d = 1\""], ["proof (prove)\nusing this:\n  coeff a (degree b) = c / d * lead_coeff b\n  degree a = degree b\n  monic a\n  monic b\n\ngoal (1 subgoal):\n 1. c / d = (1::'a)", "by simp"], ["proof (state)\nthis:\n  c / d = (1::'a)\n\ngoal (2 subgoals):\n 1. p dvd (\\<Prod>(b, j)\\<in>bs - {(a, i)}. b) \\<Longrightarrow> False\n 2. p dvd smult (of_nat (f i)) (pderiv a) \\<Longrightarrow> False", "from id[unfolded this]"], ["proof (chain)\npicking this:\n  smult (1::'a) b = a", "have \"a = b\""], ["proof (prove)\nusing this:\n  smult (1::'a) b = a\n\ngoal (1 subgoal):\n 1. a = b", "by simp"], ["proof (state)\nthis:\n  a = b\n\ngoal (2 subgoals):\n 1. p dvd (\\<Prod>(b, j)\\<in>bs - {(a, i)}. b) \\<Longrightarrow> False\n 2. p dvd smult (of_nat (f i)) (pderiv a) \\<Longrightarrow> False", "with as_distinct[OF subsetD[OF bs ai] subsetD[OF bs bj]] bj'"], ["proof (chain)\npicking this:\n  (a, i) \\<noteq> (b, j) \\<Longrightarrow> a \\<noteq> b\n  (b, j) \\<in> bs - {(a, i)}\n  a = b", "show False"], ["proof (prove)\nusing this:\n  (a, i) \\<noteq> (b, j) \\<Longrightarrow> a \\<noteq> b\n  (b, j) \\<in> bs - {(a, i)}\n  a = b\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. p dvd smult (of_nat (f i)) (pderiv a) \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. p dvd smult (of_nat (f i)) (pderiv a) \\<Longrightarrow> False", "from f[OF ai]"], ["proof (chain)\npicking this:\n  0 < f i", "obtain k where fi: \"f i = Suc k\""], ["proof (prove)\nusing this:\n  0 < f i\n\ngoal (1 subgoal):\n 1. (\\<And>k. f i = Suc k \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by (cases \"f i\", auto)"], ["proof (state)\nthis:\n  f i = Suc k\n\ngoal (1 subgoal):\n 1. p dvd smult (of_nat (f i)) (pderiv a) \\<Longrightarrow> False", "assume \"p dvd smult (of_nat (f i)) (pderiv a)\""], ["proof (state)\nthis:\n  p dvd smult (of_nat (f i)) (pderiv a)\n\ngoal (1 subgoal):\n 1. p dvd smult (of_nat (f i)) (pderiv a) \\<Longrightarrow> False", "hence \"p dvd (pderiv a)\""], ["proof (prove)\nusing this:\n  p dvd smult (of_nat (f i)) (pderiv a)\n\ngoal (1 subgoal):\n 1. p dvd pderiv a", "unfolding fi"], ["proof (prove)\nusing this:\n  p dvd smult (of_nat (Suc k)) (pderiv a)\n\ngoal (1 subgoal):\n 1. p dvd pderiv a", "using dvd_smult_cancel of_nat_eq_0_iff"], ["proof (prove)\nusing this:\n  p dvd smult (of_nat (Suc k)) (pderiv a)\n  \\<lbrakk>?p dvd smult ?a ?q; ?a \\<noteq> (0::?'a)\\<rbrakk>\n  \\<Longrightarrow> ?p dvd ?q\n  (of_nat ?m = (0::?'a)) = (?m = 0)\n\ngoal (1 subgoal):\n 1. p dvd pderiv a", "by blast"], ["proof (state)\nthis:\n  p dvd pderiv a\n\ngoal (1 subgoal):\n 1. p dvd smult (of_nat (f i)) (pderiv a) \\<Longrightarrow> False", "from this[unfolded ap]"], ["proof (chain)\npicking this:\n  p dvd pderiv (smult c p)", "have \"p dvd pderiv p\""], ["proof (prove)\nusing this:\n  p dvd pderiv (smult c p)\n\ngoal (1 subgoal):\n 1. p dvd pderiv p", "using c"], ["proof (prove)\nusing this:\n  p dvd pderiv (smult c p)\n  c \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. p dvd pderiv p", "by (metis \\<open>p dvd pderiv a\\<close> ap' dvd_trans dvd_triv_right mult.left_neutral pderiv_smult smult_dvd_cancel)"], ["proof (state)\nthis:\n  p dvd pderiv p\n\ngoal (1 subgoal):\n 1. p dvd smult (of_nat (f i)) (pderiv a) \\<Longrightarrow> False", "with not_dvd_pderiv p0"], ["proof (chain)\npicking this:\n  degree ?p \\<noteq> 0 \\<Longrightarrow> \\<not> ?p dvd pderiv ?p\n  0 < degree p\n  p dvd pderiv p", "show False"], ["proof (prove)\nusing this:\n  degree ?p \\<noteq> 0 \\<Longrightarrow> \\<not> ?p dvd pderiv ?p\n  0 < degree p\n  p dvd pderiv p\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. 0 < degree k \\<Longrightarrow> is_unit k", "thus \"k dvd 1\""], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. is_unit k", "by simp"], ["proof (state)\nthis:\n  is_unit k\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  is_unit k\n\ngoal (3 subgoals):\n 1. 1 dvd (\\<Prod>(a, i)\\<in>bs. a)\n 2. 1 dvd\n    (\\<Sum>(a, i)\\<in>bs.\n       (\\<Prod>(b, j)\\<in>bs - {(a, i)}. b) *\n       smult (of_nat (f i)) (pderiv a))\n 3. normalize 1 = 1", "qed (insert \\<open>?single \\<noteq> 0\\<close>, auto)"], ["proof (state)\nthis:\n  coprime (\\<Prod>(a, i)\\<in>bs. a)\n   (\\<Sum>(a, i)\\<in>bs.\n      (\\<Prod>(b, j)\\<in>bs - {(a, i)}. b) *\n      smult (of_nat (f i)) (pderiv a))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma pderiv_exp_gcd: \n  \"gcd p (pderiv p) = (\\<Prod>(a, i)\\<in>as. a ^ i)\" (is \"_ = ?prod\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. gcd p (pderiv p) = (\\<Prod>(a, i)\\<in>as. a ^ i)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. gcd p (pderiv p) = (\\<Prod>(a, i)\\<in>as. a ^ i)", "let ?sum = \"(\\<Sum>(a, i)\\<in>as. (\\<Prod>(b, j)\\<in>as - {(a, i)}. b) * smult (of_nat (Suc i)) (pderiv a))\""], ["proof (state)\ngoal (1 subgoal):\n 1. gcd p (pderiv p) = (\\<Prod>(a, i)\\<in>as. a ^ i)", "let ?single = \"(\\<Prod>(a, i)\\<in>as. a)\""], ["proof (state)\ngoal (1 subgoal):\n 1. gcd p (pderiv p) = (\\<Prod>(a, i)\\<in>as. a ^ i)", "let ?prd = \"\\<lambda> a i. (\\<Prod>(b, j)\\<in>as - {(a, i)}. b) * smult (of_nat (Suc i)) (pderiv a)\""], ["proof (state)\ngoal (1 subgoal):\n 1. gcd p (pderiv p) = (\\<Prod>(a, i)\\<in>as. a ^ i)", "let ?onederiv = \"\\<Sum>(a, i)\\<in>as. ?prd a i\""], ["proof (state)\ngoal (1 subgoal):\n 1. gcd p (pderiv p) = (\\<Prod>(a, i)\\<in>as. a ^ i)", "have pp: \"pderiv p = ?prod * ?sum\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pderiv p =\n    (\\<Prod>(a, i)\\<in>as. a ^ i) *\n    (\\<Sum>(a, i)\\<in>as.\n       (\\<Prod>(b, j)\\<in>as - {(a, i)}. b) *\n       smult (of_nat (Suc i)) (pderiv a))", "by (rule pderiv_exp_prod)"], ["proof (state)\nthis:\n  pderiv p =\n  (\\<Prod>(a, i)\\<in>as. a ^ i) *\n  (\\<Sum>(a, i)\\<in>as.\n     (\\<Prod>(b, j)\\<in>as - {(a, i)}. b) *\n     smult (of_nat (Suc i)) (pderiv a))\n\ngoal (1 subgoal):\n 1. gcd p (pderiv p) = (\\<Prod>(a, i)\\<in>as. a ^ i)", "have p: \"p = ?prod * ?single\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p = (\\<Prod>(a, i)\\<in>as. a ^ i) * (\\<Prod>(a, i)\\<in>as. a)", "by (rule poly_exp_expand)"], ["proof (state)\nthis:\n  p = (\\<Prod>(a, i)\\<in>as. a ^ i) * (\\<Prod>(a, i)\\<in>as. a)\n\ngoal (1 subgoal):\n 1. gcd p (pderiv p) = (\\<Prod>(a, i)\\<in>as. a ^ i)", "have monic: \"monic ?prod\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monic (\\<Prod>(a, i)\\<in>as. a ^ i)", "by (rule monic_Prod)"], ["proof (state)\nthis:\n  monic (\\<Prod>(a, i)\\<in>as. a ^ i)\n\ngoal (1 subgoal):\n 1. gcd p (pderiv p) = (\\<Prod>(a, i)\\<in>as. a ^ i)", "have gcd: \"coprime ?single ?onederiv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coprime (\\<Prod>(a, i)\\<in>as. a)\n     (\\<Sum>(a, i)\\<in>as.\n        (\\<Prod>(b, j)\\<in>as - {(a, i)}. b) *\n        smult (of_nat (Suc i)) (pderiv a))", "by (rule coprime_generic, auto)"], ["proof (state)\nthis:\n  coprime (\\<Prod>(a, i)\\<in>as. a)\n   (\\<Sum>(a, i)\\<in>as.\n      (\\<Prod>(b, j)\\<in>as - {(a, i)}. b) *\n      smult (of_nat (Suc i)) (pderiv a))\n\ngoal (1 subgoal):\n 1. gcd p (pderiv p) = (\\<Prod>(a, i)\\<in>as. a ^ i)", "then"], ["proof (chain)\npicking this:\n  coprime (\\<Prod>(a, i)\\<in>as. a)\n   (\\<Sum>(a, i)\\<in>as.\n      (\\<Prod>(b, j)\\<in>as - {(a, i)}. b) *\n      smult (of_nat (Suc i)) (pderiv a))", "have gcd: \"gcd ?single ?onederiv = 1\""], ["proof (prove)\nusing this:\n  coprime (\\<Prod>(a, i)\\<in>as. a)\n   (\\<Sum>(a, i)\\<in>as.\n      (\\<Prod>(b, j)\\<in>as - {(a, i)}. b) *\n      smult (of_nat (Suc i)) (pderiv a))\n\ngoal (1 subgoal):\n 1. gcd (\\<Prod>(a, i)\\<in>as. a)\n     (\\<Sum>(a, i)\\<in>as.\n        (\\<Prod>(b, j)\\<in>as - {(a, i)}. b) *\n        smult (of_nat (Suc i)) (pderiv a)) =\n    1", "by simp"], ["proof (state)\nthis:\n  gcd (\\<Prod>(a, i)\\<in>as. a)\n   (\\<Sum>(a, i)\\<in>as.\n      (\\<Prod>(b, j)\\<in>as - {(a, i)}. b) *\n      smult (of_nat (Suc i)) (pderiv a)) =\n  1\n\ngoal (1 subgoal):\n 1. gcd p (pderiv p) = (\\<Prod>(a, i)\\<in>as. a ^ i)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. gcd p (pderiv p) = (\\<Prod>(a, i)\\<in>as. a ^ i)", "unfolding pp"], ["proof (prove)\ngoal (1 subgoal):\n 1. gcd p\n     ((\\<Prod>(x, y)\\<in>as. x ^ y) *\n      (\\<Sum>(a, i)\\<in>as.\n         (\\<Prod>(b, j)\\<in>as - {(a, i)}. b) *\n         smult (of_nat (Suc i)) (pderiv a))) =\n    (\\<Prod>(a, i)\\<in>as. a ^ i)", "unfolding p poly_gcd_monic_factor [OF monic] gcd"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>(x, y)\\<in>as. x ^ y) * 1 = (\\<Prod>(a, i)\\<in>as. a ^ i)", "by simp"], ["proof (state)\nthis:\n  gcd p (pderiv p) = (\\<Prod>(a, i)\\<in>as. a ^ i)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma p_div_gcd_p_pderiv: \"p div (gcd p (pderiv p)) = (\\<Prod>(a, i)\\<in>as. a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p div gcd p (pderiv p) = (\\<Prod>(a, i)\\<in>as. a)", "unfolding pderiv_exp_gcd"], ["proof (prove)\ngoal (1 subgoal):\n 1. p div (\\<Prod>(x, y)\\<in>as. x ^ y) = (\\<Prod>(a, i)\\<in>as. a)", "unfolding poly_exp_expand"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>(x, y)\\<in>as. x ^ y) * (\\<Prod>(a, i)\\<in>as. a) div\n    (\\<Prod>(x, y)\\<in>as. x ^ y) =\n    (\\<Prod>(a, i)\\<in>as. a)", "by (rule nonzero_mult_div_cancel_left, insert monic_Prod, auto)"], ["", "fun A B C D :: \"nat \\<Rightarrow> 'a poly\" where\n  \"A n = gcd (B n) (D n)\"\n| \"B 0 = p div (gcd p (pderiv p))\"\n| \"B (Suc n) = B n div A n\"\n| \"C 0 = pderiv p div (gcd p (pderiv p))\"\n| \"C (Suc n) = D n div A n\"\n| \"D n = C n - pderiv (B n)\""], ["", "lemma A_B_C_D: \"A n = (\\<Prod> (a, i) \\<in> as \\<inter> UNIV \\<times> {n}. a)\"\n  \"B n = (\\<Prod> (a, i) \\<in> as - UNIV \\<times> {0 ..< n}. a)\"\n  \"C n = (\\<Sum>(a, i)\\<in>as - UNIV \\<times> {0 ..< n}. \n    (\\<Prod>(b, j)\\<in>as - UNIV \\<times> {0 ..< n} - {(a, i)}. b) * smult (of_nat (Suc i - n)) (pderiv a))\"\n  \"D n = (\\<Prod> (a, i) \\<in> as \\<inter> UNIV \\<times> {n}. a) * \n    (\\<Sum> (a,i)\\<in>as - UNIV \\<times> {0 ..< Suc n}. \n      (\\<Prod>(b, j)\\<in> as - UNIV \\<times> {0 ..< Suc n} - {(a, i)}. b) * (smult (of_nat (i - n)) (pderiv a)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A n = (\\<Prod>(a, i)\\<in>as \\<inter> UNIV \\<times> {n}. a) &&&\n     B n = (\\<Prod>(a, i)\\<in>as - UNIV \\<times> {0..<n}. a)) &&&\n    C n =\n    (\\<Sum>(a, i)\\<in>as - UNIV \\<times> {0..<n}.\n       (\\<Prod>(b, j)\\<in>as - UNIV \\<times> {0..<n} - {(a, i)}. b) *\n       smult (of_nat (Suc i - n)) (pderiv a)) &&&\n    D n =\n    (\\<Prod>(a, i)\\<in>as \\<inter> UNIV \\<times> {n}. a) *\n    (\\<Sum>(a, i)\\<in>as - UNIV \\<times> {0..<Suc n}.\n       (\\<Prod>(b, j)\\<in>as - UNIV \\<times> {0..<Suc n} - {(a, i)}. b) *\n       smult (of_nat (i - n)) (pderiv a))", "proof (induct n and n and n and n rule: A_B_C_D.induct)"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>B n =\n                (\\<Prod>a\\<in>as - UNIV \\<times> {0..<n}.\n                   case a of (a, i) \\<Rightarrow> a);\n        D n =\n        (\\<Prod>a\\<in>as \\<inter> UNIV \\<times> {n}.\n           case a of (a, i) \\<Rightarrow> a) *\n        (\\<Sum>a\\<in>as - UNIV \\<times> {0..<Suc n}.\n           case a of\n           (a, i) \\<Rightarrow>\n             (\\<Prod>a\\<in>as - UNIV \\<times> {0..<Suc n} - {(a, i)}.\n                case a of (b, j) \\<Rightarrow> b) *\n             smult (of_nat (i - n)) (pderiv a))\\<rbrakk>\n       \\<Longrightarrow> A n =\n                         (\\<Prod>a\\<in>as \\<inter> UNIV \\<times> {n}.\n                            case a of (a, i) \\<Rightarrow> a)\n 2. B 0 =\n    (\\<Prod>a\\<in>as - UNIV \\<times> {0..<0}.\n       case a of (a, i) \\<Rightarrow> a)\n 3. \\<And>n.\n       \\<lbrakk>B n =\n                (\\<Prod>a\\<in>as - UNIV \\<times> {0..<n}.\n                   case a of (a, i) \\<Rightarrow> a);\n        A n =\n        (\\<Prod>a\\<in>as \\<inter> UNIV \\<times> {n}.\n           case a of (a, i) \\<Rightarrow> a)\\<rbrakk>\n       \\<Longrightarrow> B (Suc n) =\n                         (\\<Prod>a\\<in>as - UNIV \\<times> {0..<Suc n}.\n                            case a of (a, i) \\<Rightarrow> a)\n 4. C 0 =\n    (\\<Sum>a\\<in>as - UNIV \\<times> {0..<0}.\n       case a of\n       (a, i) \\<Rightarrow>\n         (\\<Prod>a\\<in>as - UNIV \\<times> {0..<0} - {(a, i)}.\n            case a of (b, j) \\<Rightarrow> b) *\n         smult (of_nat (Suc i - 0)) (pderiv a))\n 5. \\<And>n.\n       \\<lbrakk>D n =\n                (\\<Prod>a\\<in>as \\<inter> UNIV \\<times> {n}.\n                   case a of (a, i) \\<Rightarrow> a) *\n                (\\<Sum>a\\<in>as - UNIV \\<times> {0..<Suc n}.\n                   case a of\n                   (a, i) \\<Rightarrow>\n                     (\\<Prod>a\\<in>as - UNIV \\<times> {0..<Suc n} -\n                                   {(a, i)}.\n                        case a of (b, j) \\<Rightarrow> b) *\n                     smult (of_nat (i - n)) (pderiv a));\n        A n =\n        (\\<Prod>a\\<in>as \\<inter> UNIV \\<times> {n}.\n           case a of (a, i) \\<Rightarrow> a)\\<rbrakk>\n       \\<Longrightarrow> C (Suc n) =\n                         (\\<Sum>a\\<in>as - UNIV \\<times> {0..<Suc n}.\n                            case a of\n                            (a, i) \\<Rightarrow>\n                              (\\<Prod>a\n\\<in>as - UNIV \\<times> {0..<Suc n} - {(a, i)}.\n                                 case a of (b, j) \\<Rightarrow> b) *\n                              smult (of_nat (Suc i - Suc n)) (pderiv a))\n 6. \\<And>n.\n       \\<lbrakk>C n =\n                (\\<Sum>a\\<in>as - UNIV \\<times> {0..<n}.\n                   case a of\n                   (a, i) \\<Rightarrow>\n                     (\\<Prod>a\\<in>as - UNIV \\<times> {0..<n} - {(a, i)}.\n                        case a of (b, j) \\<Rightarrow> b) *\n                     smult (of_nat (Suc i - n)) (pderiv a));\n        B n =\n        (\\<Prod>a\\<in>as - UNIV \\<times> {0..<n}.\n           case a of (a, i) \\<Rightarrow> a)\\<rbrakk>\n       \\<Longrightarrow> D n =\n                         (\\<Prod>a\\<in>as \\<inter> UNIV \\<times> {n}.\n                            case a of (a, i) \\<Rightarrow> a) *\n                         (\\<Sum>a\\<in>as - UNIV \\<times> {0..<Suc n}.\n                            case a of\n                            (a, i) \\<Rightarrow>\n                              (\\<Prod>a\n\\<in>as - UNIV \\<times> {0..<Suc n} - {(a, i)}.\n                                 case a of (b, j) \\<Rightarrow> b) *\n                              smult (of_nat (i - n)) (pderiv a))", "case (1 n)"], ["proof (state)\nthis:\n  B n =\n  (\\<Prod>a\\<in>as - UNIV \\<times> {0..<n}.\n     case a of (a, i) \\<Rightarrow> a)\n  D n =\n  (\\<Prod>a\\<in>as \\<inter> UNIV \\<times> {n}.\n     case a of (a, i) \\<Rightarrow> a) *\n  (\\<Sum>a\\<in>as - UNIV \\<times> {0..<Suc n}.\n     case a of\n     (a, i) \\<Rightarrow>\n       (\\<Prod>a\\<in>as - UNIV \\<times> {0..<Suc n} - {(a, i)}.\n          case a of (b, j) \\<Rightarrow> b) *\n       smult (of_nat (i - n)) (pderiv a))\n\ngoal (6 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>B n =\n                (\\<Prod>a\\<in>as - UNIV \\<times> {0..<n}.\n                   case a of (a, i) \\<Rightarrow> a);\n        D n =\n        (\\<Prod>a\\<in>as \\<inter> UNIV \\<times> {n}.\n           case a of (a, i) \\<Rightarrow> a) *\n        (\\<Sum>a\\<in>as - UNIV \\<times> {0..<Suc n}.\n           case a of\n           (a, i) \\<Rightarrow>\n             (\\<Prod>a\\<in>as - UNIV \\<times> {0..<Suc n} - {(a, i)}.\n                case a of (b, j) \\<Rightarrow> b) *\n             smult (of_nat (i - n)) (pderiv a))\\<rbrakk>\n       \\<Longrightarrow> A n =\n                         (\\<Prod>a\\<in>as \\<inter> UNIV \\<times> {n}.\n                            case a of (a, i) \\<Rightarrow> a)\n 2. B 0 =\n    (\\<Prod>a\\<in>as - UNIV \\<times> {0..<0}.\n       case a of (a, i) \\<Rightarrow> a)\n 3. \\<And>n.\n       \\<lbrakk>B n =\n                (\\<Prod>a\\<in>as - UNIV \\<times> {0..<n}.\n                   case a of (a, i) \\<Rightarrow> a);\n        A n =\n        (\\<Prod>a\\<in>as \\<inter> UNIV \\<times> {n}.\n           case a of (a, i) \\<Rightarrow> a)\\<rbrakk>\n       \\<Longrightarrow> B (Suc n) =\n                         (\\<Prod>a\\<in>as - UNIV \\<times> {0..<Suc n}.\n                            case a of (a, i) \\<Rightarrow> a)\n 4. C 0 =\n    (\\<Sum>a\\<in>as - UNIV \\<times> {0..<0}.\n       case a of\n       (a, i) \\<Rightarrow>\n         (\\<Prod>a\\<in>as - UNIV \\<times> {0..<0} - {(a, i)}.\n            case a of (b, j) \\<Rightarrow> b) *\n         smult (of_nat (Suc i - 0)) (pderiv a))\n 5. \\<And>n.\n       \\<lbrakk>D n =\n                (\\<Prod>a\\<in>as \\<inter> UNIV \\<times> {n}.\n                   case a of (a, i) \\<Rightarrow> a) *\n                (\\<Sum>a\\<in>as - UNIV \\<times> {0..<Suc n}.\n                   case a of\n                   (a, i) \\<Rightarrow>\n                     (\\<Prod>a\\<in>as - UNIV \\<times> {0..<Suc n} -\n                                   {(a, i)}.\n                        case a of (b, j) \\<Rightarrow> b) *\n                     smult (of_nat (i - n)) (pderiv a));\n        A n =\n        (\\<Prod>a\\<in>as \\<inter> UNIV \\<times> {n}.\n           case a of (a, i) \\<Rightarrow> a)\\<rbrakk>\n       \\<Longrightarrow> C (Suc n) =\n                         (\\<Sum>a\\<in>as - UNIV \\<times> {0..<Suc n}.\n                            case a of\n                            (a, i) \\<Rightarrow>\n                              (\\<Prod>a\n\\<in>as - UNIV \\<times> {0..<Suc n} - {(a, i)}.\n                                 case a of (b, j) \\<Rightarrow> b) *\n                              smult (of_nat (Suc i - Suc n)) (pderiv a))\n 6. \\<And>n.\n       \\<lbrakk>C n =\n                (\\<Sum>a\\<in>as - UNIV \\<times> {0..<n}.\n                   case a of\n                   (a, i) \\<Rightarrow>\n                     (\\<Prod>a\\<in>as - UNIV \\<times> {0..<n} - {(a, i)}.\n                        case a of (b, j) \\<Rightarrow> b) *\n                     smult (of_nat (Suc i - n)) (pderiv a));\n        B n =\n        (\\<Prod>a\\<in>as - UNIV \\<times> {0..<n}.\n           case a of (a, i) \\<Rightarrow> a)\\<rbrakk>\n       \\<Longrightarrow> D n =\n                         (\\<Prod>a\\<in>as \\<inter> UNIV \\<times> {n}.\n                            case a of (a, i) \\<Rightarrow> a) *\n                         (\\<Sum>a\\<in>as - UNIV \\<times> {0..<Suc n}.\n                            case a of\n                            (a, i) \\<Rightarrow>\n                              (\\<Prod>a\n\\<in>as - UNIV \\<times> {0..<Suc n} - {(a, i)}.\n                                 case a of (b, j) \\<Rightarrow> b) *\n                              smult (of_nat (i - n)) (pderiv a))", "(* A *)"], ["proof (state)\nthis:\n  B n =\n  (\\<Prod>a\\<in>as - UNIV \\<times> {0..<n}.\n     case a of (a, i) \\<Rightarrow> a)\n  D n =\n  (\\<Prod>a\\<in>as \\<inter> UNIV \\<times> {n}.\n     case a of (a, i) \\<Rightarrow> a) *\n  (\\<Sum>a\\<in>as - UNIV \\<times> {0..<Suc n}.\n     case a of\n     (a, i) \\<Rightarrow>\n       (\\<Prod>a\\<in>as - UNIV \\<times> {0..<Suc n} - {(a, i)}.\n          case a of (b, j) \\<Rightarrow> b) *\n       smult (of_nat (i - n)) (pderiv a))\n\ngoal (6 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>B n =\n                (\\<Prod>a\\<in>as - UNIV \\<times> {0..<n}.\n                   case a of (a, i) \\<Rightarrow> a);\n        D n =\n        (\\<Prod>a\\<in>as \\<inter> UNIV \\<times> {n}.\n           case a of (a, i) \\<Rightarrow> a) *\n        (\\<Sum>a\\<in>as - UNIV \\<times> {0..<Suc n}.\n           case a of\n           (a, i) \\<Rightarrow>\n             (\\<Prod>a\\<in>as - UNIV \\<times> {0..<Suc n} - {(a, i)}.\n                case a of (b, j) \\<Rightarrow> b) *\n             smult (of_nat (i - n)) (pderiv a))\\<rbrakk>\n       \\<Longrightarrow> A n =\n                         (\\<Prod>a\\<in>as \\<inter> UNIV \\<times> {n}.\n                            case a of (a, i) \\<Rightarrow> a)\n 2. B 0 =\n    (\\<Prod>a\\<in>as - UNIV \\<times> {0..<0}.\n       case a of (a, i) \\<Rightarrow> a)\n 3. \\<And>n.\n       \\<lbrakk>B n =\n                (\\<Prod>a\\<in>as - UNIV \\<times> {0..<n}.\n                   case a of (a, i) \\<Rightarrow> a);\n        A n =\n        (\\<Prod>a\\<in>as \\<inter> UNIV \\<times> {n}.\n           case a of (a, i) \\<Rightarrow> a)\\<rbrakk>\n       \\<Longrightarrow> B (Suc n) =\n                         (\\<Prod>a\\<in>as - UNIV \\<times> {0..<Suc n}.\n                            case a of (a, i) \\<Rightarrow> a)\n 4. C 0 =\n    (\\<Sum>a\\<in>as - UNIV \\<times> {0..<0}.\n       case a of\n       (a, i) \\<Rightarrow>\n         (\\<Prod>a\\<in>as - UNIV \\<times> {0..<0} - {(a, i)}.\n            case a of (b, j) \\<Rightarrow> b) *\n         smult (of_nat (Suc i - 0)) (pderiv a))\n 5. \\<And>n.\n       \\<lbrakk>D n =\n                (\\<Prod>a\\<in>as \\<inter> UNIV \\<times> {n}.\n                   case a of (a, i) \\<Rightarrow> a) *\n                (\\<Sum>a\\<in>as - UNIV \\<times> {0..<Suc n}.\n                   case a of\n                   (a, i) \\<Rightarrow>\n                     (\\<Prod>a\\<in>as - UNIV \\<times> {0..<Suc n} -\n                                   {(a, i)}.\n                        case a of (b, j) \\<Rightarrow> b) *\n                     smult (of_nat (i - n)) (pderiv a));\n        A n =\n        (\\<Prod>a\\<in>as \\<inter> UNIV \\<times> {n}.\n           case a of (a, i) \\<Rightarrow> a)\\<rbrakk>\n       \\<Longrightarrow> C (Suc n) =\n                         (\\<Sum>a\\<in>as - UNIV \\<times> {0..<Suc n}.\n                            case a of\n                            (a, i) \\<Rightarrow>\n                              (\\<Prod>a\n\\<in>as - UNIV \\<times> {0..<Suc n} - {(a, i)}.\n                                 case a of (b, j) \\<Rightarrow> b) *\n                              smult (of_nat (Suc i - Suc n)) (pderiv a))\n 6. \\<And>n.\n       \\<lbrakk>C n =\n                (\\<Sum>a\\<in>as - UNIV \\<times> {0..<n}.\n                   case a of\n                   (a, i) \\<Rightarrow>\n                     (\\<Prod>a\\<in>as - UNIV \\<times> {0..<n} - {(a, i)}.\n                        case a of (b, j) \\<Rightarrow> b) *\n                     smult (of_nat (Suc i - n)) (pderiv a));\n        B n =\n        (\\<Prod>a\\<in>as - UNIV \\<times> {0..<n}.\n           case a of (a, i) \\<Rightarrow> a)\\<rbrakk>\n       \\<Longrightarrow> D n =\n                         (\\<Prod>a\\<in>as \\<inter> UNIV \\<times> {n}.\n                            case a of (a, i) \\<Rightarrow> a) *\n                         (\\<Sum>a\\<in>as - UNIV \\<times> {0..<Suc n}.\n                            case a of\n                            (a, i) \\<Rightarrow>\n                              (\\<Prod>a\n\\<in>as - UNIV \\<times> {0..<Suc n} - {(a, i)}.\n                                 case a of (b, j) \\<Rightarrow> b) *\n                              smult (of_nat (i - n)) (pderiv a))", "note Bn = 1(1)"], ["proof (state)\nthis:\n  B n =\n  (\\<Prod>a\\<in>as - UNIV \\<times> {0..<n}.\n     case a of (a, i) \\<Rightarrow> a)\n\ngoal (6 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>B n =\n                (\\<Prod>a\\<in>as - UNIV \\<times> {0..<n}.\n                   case a of (a, i) \\<Rightarrow> a);\n        D n =\n        (\\<Prod>a\\<in>as \\<inter> UNIV \\<times> {n}.\n           case a of (a, i) \\<Rightarrow> a) *\n        (\\<Sum>a\\<in>as - UNIV \\<times> {0..<Suc n}.\n           case a of\n           (a, i) \\<Rightarrow>\n             (\\<Prod>a\\<in>as - UNIV \\<times> {0..<Suc n} - {(a, i)}.\n                case a of (b, j) \\<Rightarrow> b) *\n             smult (of_nat (i - n)) (pderiv a))\\<rbrakk>\n       \\<Longrightarrow> A n =\n                         (\\<Prod>a\\<in>as \\<inter> UNIV \\<times> {n}.\n                            case a of (a, i) \\<Rightarrow> a)\n 2. B 0 =\n    (\\<Prod>a\\<in>as - UNIV \\<times> {0..<0}.\n       case a of (a, i) \\<Rightarrow> a)\n 3. \\<And>n.\n       \\<lbrakk>B n =\n                (\\<Prod>a\\<in>as - UNIV \\<times> {0..<n}.\n                   case a of (a, i) \\<Rightarrow> a);\n        A n =\n        (\\<Prod>a\\<in>as \\<inter> UNIV \\<times> {n}.\n           case a of (a, i) \\<Rightarrow> a)\\<rbrakk>\n       \\<Longrightarrow> B (Suc n) =\n                         (\\<Prod>a\\<in>as - UNIV \\<times> {0..<Suc n}.\n                            case a of (a, i) \\<Rightarrow> a)\n 4. C 0 =\n    (\\<Sum>a\\<in>as - UNIV \\<times> {0..<0}.\n       case a of\n       (a, i) \\<Rightarrow>\n         (\\<Prod>a\\<in>as - UNIV \\<times> {0..<0} - {(a, i)}.\n            case a of (b, j) \\<Rightarrow> b) *\n         smult (of_nat (Suc i - 0)) (pderiv a))\n 5. \\<And>n.\n       \\<lbrakk>D n =\n                (\\<Prod>a\\<in>as \\<inter> UNIV \\<times> {n}.\n                   case a of (a, i) \\<Rightarrow> a) *\n                (\\<Sum>a\\<in>as - UNIV \\<times> {0..<Suc n}.\n                   case a of\n                   (a, i) \\<Rightarrow>\n                     (\\<Prod>a\\<in>as - UNIV \\<times> {0..<Suc n} -\n                                   {(a, i)}.\n                        case a of (b, j) \\<Rightarrow> b) *\n                     smult (of_nat (i - n)) (pderiv a));\n        A n =\n        (\\<Prod>a\\<in>as \\<inter> UNIV \\<times> {n}.\n           case a of (a, i) \\<Rightarrow> a)\\<rbrakk>\n       \\<Longrightarrow> C (Suc n) =\n                         (\\<Sum>a\\<in>as - UNIV \\<times> {0..<Suc n}.\n                            case a of\n                            (a, i) \\<Rightarrow>\n                              (\\<Prod>a\n\\<in>as - UNIV \\<times> {0..<Suc n} - {(a, i)}.\n                                 case a of (b, j) \\<Rightarrow> b) *\n                              smult (of_nat (Suc i - Suc n)) (pderiv a))\n 6. \\<And>n.\n       \\<lbrakk>C n =\n                (\\<Sum>a\\<in>as - UNIV \\<times> {0..<n}.\n                   case a of\n                   (a, i) \\<Rightarrow>\n                     (\\<Prod>a\\<in>as - UNIV \\<times> {0..<n} - {(a, i)}.\n                        case a of (b, j) \\<Rightarrow> b) *\n                     smult (of_nat (Suc i - n)) (pderiv a));\n        B n =\n        (\\<Prod>a\\<in>as - UNIV \\<times> {0..<n}.\n           case a of (a, i) \\<Rightarrow> a)\\<rbrakk>\n       \\<Longrightarrow> D n =\n                         (\\<Prod>a\\<in>as \\<inter> UNIV \\<times> {n}.\n                            case a of (a, i) \\<Rightarrow> a) *\n                         (\\<Sum>a\\<in>as - UNIV \\<times> {0..<Suc n}.\n                            case a of\n                            (a, i) \\<Rightarrow>\n                              (\\<Prod>a\n\\<in>as - UNIV \\<times> {0..<Suc n} - {(a, i)}.\n                                 case a of (b, j) \\<Rightarrow> b) *\n                              smult (of_nat (i - n)) (pderiv a))", "note Dn = 1(2)"], ["proof (state)\nthis:\n  D n =\n  (\\<Prod>a\\<in>as \\<inter> UNIV \\<times> {n}.\n     case a of (a, i) \\<Rightarrow> a) *\n  (\\<Sum>a\\<in>as - UNIV \\<times> {0..<Suc n}.\n     case a of\n     (a, i) \\<Rightarrow>\n       (\\<Prod>a\\<in>as - UNIV \\<times> {0..<Suc n} - {(a, i)}.\n          case a of (b, j) \\<Rightarrow> b) *\n       smult (of_nat (i - n)) (pderiv a))\n\ngoal (6 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>B n =\n                (\\<Prod>a\\<in>as - UNIV \\<times> {0..<n}.\n                   case a of (a, i) \\<Rightarrow> a);\n        D n =\n        (\\<Prod>a\\<in>as \\<inter> UNIV \\<times> {n}.\n           case a of (a, i) \\<Rightarrow> a) *\n        (\\<Sum>a\\<in>as - UNIV \\<times> {0..<Suc n}.\n           case a of\n           (a, i) \\<Rightarrow>\n             (\\<Prod>a\\<in>as - UNIV \\<times> {0..<Suc n} - {(a, i)}.\n                case a of (b, j) \\<Rightarrow> b) *\n             smult (of_nat (i - n)) (pderiv a))\\<rbrakk>\n       \\<Longrightarrow> A n =\n                         (\\<Prod>a\\<in>as \\<inter> UNIV \\<times> {n}.\n                            case a of (a, i) \\<Rightarrow> a)\n 2. B 0 =\n    (\\<Prod>a\\<in>as - UNIV \\<times> {0..<0}.\n       case a of (a, i) \\<Rightarrow> a)\n 3. \\<And>n.\n       \\<lbrakk>B n =\n                (\\<Prod>a\\<in>as - UNIV \\<times> {0..<n}.\n                   case a of (a, i) \\<Rightarrow> a);\n        A n =\n        (\\<Prod>a\\<in>as \\<inter> UNIV \\<times> {n}.\n           case a of (a, i) \\<Rightarrow> a)\\<rbrakk>\n       \\<Longrightarrow> B (Suc n) =\n                         (\\<Prod>a\\<in>as - UNIV \\<times> {0..<Suc n}.\n                            case a of (a, i) \\<Rightarrow> a)\n 4. C 0 =\n    (\\<Sum>a\\<in>as - UNIV \\<times> {0..<0}.\n       case a of\n       (a, i) \\<Rightarrow>\n         (\\<Prod>a\\<in>as - UNIV \\<times> {0..<0} - {(a, i)}.\n            case a of (b, j) \\<Rightarrow> b) *\n         smult (of_nat (Suc i - 0)) (pderiv a))\n 5. \\<And>n.\n       \\<lbrakk>D n =\n                (\\<Prod>a\\<in>as \\<inter> UNIV \\<times> {n}.\n                   case a of (a, i) \\<Rightarrow> a) *\n                (\\<Sum>a\\<in>as - UNIV \\<times> {0..<Suc n}.\n                   case a of\n                   (a, i) \\<Rightarrow>\n                     (\\<Prod>a\\<in>as - UNIV \\<times> {0..<Suc n} -\n                                   {(a, i)}.\n                        case a of (b, j) \\<Rightarrow> b) *\n                     smult (of_nat (i - n)) (pderiv a));\n        A n =\n        (\\<Prod>a\\<in>as \\<inter> UNIV \\<times> {n}.\n           case a of (a, i) \\<Rightarrow> a)\\<rbrakk>\n       \\<Longrightarrow> C (Suc n) =\n                         (\\<Sum>a\\<in>as - UNIV \\<times> {0..<Suc n}.\n                            case a of\n                            (a, i) \\<Rightarrow>\n                              (\\<Prod>a\n\\<in>as - UNIV \\<times> {0..<Suc n} - {(a, i)}.\n                                 case a of (b, j) \\<Rightarrow> b) *\n                              smult (of_nat (Suc i - Suc n)) (pderiv a))\n 6. \\<And>n.\n       \\<lbrakk>C n =\n                (\\<Sum>a\\<in>as - UNIV \\<times> {0..<n}.\n                   case a of\n                   (a, i) \\<Rightarrow>\n                     (\\<Prod>a\\<in>as - UNIV \\<times> {0..<n} - {(a, i)}.\n                        case a of (b, j) \\<Rightarrow> b) *\n                     smult (of_nat (Suc i - n)) (pderiv a));\n        B n =\n        (\\<Prod>a\\<in>as - UNIV \\<times> {0..<n}.\n           case a of (a, i) \\<Rightarrow> a)\\<rbrakk>\n       \\<Longrightarrow> D n =\n                         (\\<Prod>a\\<in>as \\<inter> UNIV \\<times> {n}.\n                            case a of (a, i) \\<Rightarrow> a) *\n                         (\\<Sum>a\\<in>as - UNIV \\<times> {0..<Suc n}.\n                            case a of\n                            (a, i) \\<Rightarrow>\n                              (\\<Prod>a\n\\<in>as - UNIV \\<times> {0..<Suc n} - {(a, i)}.\n                                 case a of (b, j) \\<Rightarrow> b) *\n                              smult (of_nat (i - n)) (pderiv a))", "have \"(\\<Prod>(a, i)\\<in>as - UNIV \\<times> {0..< n}. a) = (\\<Prod>(a, i)\\<in>as \\<inter> UNIV \\<times> {n}. a) * (\\<Prod>(a, i)\\<in>as - UNIV \\<times> {0..<Suc n}. a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>(a, i)\\<in>as - UNIV \\<times> {0..<n}. a) =\n    (\\<Prod>(a, i)\\<in>as \\<inter> UNIV \\<times> {n}. a) *\n    (\\<Prod>(a, i)\\<in>as - UNIV \\<times> {0..<Suc n}. a)", "by (subst prod.union_disjoint[symmetric], auto, insert fin, auto intro: prod.cong)"], ["proof (state)\nthis:\n  (\\<Prod>(a, i)\\<in>as - UNIV \\<times> {0..<n}. a) =\n  (\\<Prod>(a, i)\\<in>as \\<inter> UNIV \\<times> {n}. a) *\n  (\\<Prod>(a, i)\\<in>as - UNIV \\<times> {0..<Suc n}. a)\n\ngoal (6 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>B n =\n                (\\<Prod>a\\<in>as - UNIV \\<times> {0..<n}.\n                   case a of (a, i) \\<Rightarrow> a);\n        D n =\n        (\\<Prod>a\\<in>as \\<inter> UNIV \\<times> {n}.\n           case a of (a, i) \\<Rightarrow> a) *\n        (\\<Sum>a\\<in>as - UNIV \\<times> {0..<Suc n}.\n           case a of\n           (a, i) \\<Rightarrow>\n             (\\<Prod>a\\<in>as - UNIV \\<times> {0..<Suc n} - {(a, i)}.\n                case a of (b, j) \\<Rightarrow> b) *\n             smult (of_nat (i - n)) (pderiv a))\\<rbrakk>\n       \\<Longrightarrow> A n =\n                         (\\<Prod>a\\<in>as \\<inter> UNIV \\<times> {n}.\n                            case a of (a, i) \\<Rightarrow> a)\n 2. B 0 =\n    (\\<Prod>a\\<in>as - UNIV \\<times> {0..<0}.\n       case a of (a, i) \\<Rightarrow> a)\n 3. \\<And>n.\n       \\<lbrakk>B n =\n                (\\<Prod>a\\<in>as - UNIV \\<times> {0..<n}.\n                   case a of (a, i) \\<Rightarrow> a);\n        A n =\n        (\\<Prod>a\\<in>as \\<inter> UNIV \\<times> {n}.\n           case a of (a, i) \\<Rightarrow> a)\\<rbrakk>\n       \\<Longrightarrow> B (Suc n) =\n                         (\\<Prod>a\\<in>as - UNIV \\<times> {0..<Suc n}.\n                            case a of (a, i) \\<Rightarrow> a)\n 4. C 0 =\n    (\\<Sum>a\\<in>as - UNIV \\<times> {0..<0}.\n       case a of\n       (a, i) \\<Rightarrow>\n         (\\<Prod>a\\<in>as - UNIV \\<times> {0..<0} - {(a, i)}.\n            case a of (b, j) \\<Rightarrow> b) *\n         smult (of_nat (Suc i - 0)) (pderiv a))\n 5. \\<And>n.\n       \\<lbrakk>D n =\n                (\\<Prod>a\\<in>as \\<inter> UNIV \\<times> {n}.\n                   case a of (a, i) \\<Rightarrow> a) *\n                (\\<Sum>a\\<in>as - UNIV \\<times> {0..<Suc n}.\n                   case a of\n                   (a, i) \\<Rightarrow>\n                     (\\<Prod>a\\<in>as - UNIV \\<times> {0..<Suc n} -\n                                   {(a, i)}.\n                        case a of (b, j) \\<Rightarrow> b) *\n                     smult (of_nat (i - n)) (pderiv a));\n        A n =\n        (\\<Prod>a\\<in>as \\<inter> UNIV \\<times> {n}.\n           case a of (a, i) \\<Rightarrow> a)\\<rbrakk>\n       \\<Longrightarrow> C (Suc n) =\n                         (\\<Sum>a\\<in>as - UNIV \\<times> {0..<Suc n}.\n                            case a of\n                            (a, i) \\<Rightarrow>\n                              (\\<Prod>a\n\\<in>as - UNIV \\<times> {0..<Suc n} - {(a, i)}.\n                                 case a of (b, j) \\<Rightarrow> b) *\n                              smult (of_nat (Suc i - Suc n)) (pderiv a))\n 6. \\<And>n.\n       \\<lbrakk>C n =\n                (\\<Sum>a\\<in>as - UNIV \\<times> {0..<n}.\n                   case a of\n                   (a, i) \\<Rightarrow>\n                     (\\<Prod>a\\<in>as - UNIV \\<times> {0..<n} - {(a, i)}.\n                        case a of (b, j) \\<Rightarrow> b) *\n                     smult (of_nat (Suc i - n)) (pderiv a));\n        B n =\n        (\\<Prod>a\\<in>as - UNIV \\<times> {0..<n}.\n           case a of (a, i) \\<Rightarrow> a)\\<rbrakk>\n       \\<Longrightarrow> D n =\n                         (\\<Prod>a\\<in>as \\<inter> UNIV \\<times> {n}.\n                            case a of (a, i) \\<Rightarrow> a) *\n                         (\\<Sum>a\\<in>as - UNIV \\<times> {0..<Suc n}.\n                            case a of\n                            (a, i) \\<Rightarrow>\n                              (\\<Prod>a\n\\<in>as - UNIV \\<times> {0..<Suc n} - {(a, i)}.\n                                 case a of (b, j) \\<Rightarrow> b) *\n                              smult (of_nat (i - n)) (pderiv a))", "note Bn' = Bn[unfolded this]"], ["proof (state)\nthis:\n  B n =\n  (\\<Prod>(a, i)\\<in>as \\<inter> UNIV \\<times> {n}. a) *\n  (\\<Prod>(a, i)\\<in>as - UNIV \\<times> {0..<Suc n}. a)\n\ngoal (6 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>B n =\n                (\\<Prod>a\\<in>as - UNIV \\<times> {0..<n}.\n                   case a of (a, i) \\<Rightarrow> a);\n        D n =\n        (\\<Prod>a\\<in>as \\<inter> UNIV \\<times> {n}.\n           case a of (a, i) \\<Rightarrow> a) *\n        (\\<Sum>a\\<in>as - UNIV \\<times> {0..<Suc n}.\n           case a of\n           (a, i) \\<Rightarrow>\n             (\\<Prod>a\\<in>as - UNIV \\<times> {0..<Suc n} - {(a, i)}.\n                case a of (b, j) \\<Rightarrow> b) *\n             smult (of_nat (i - n)) (pderiv a))\\<rbrakk>\n       \\<Longrightarrow> A n =\n                         (\\<Prod>a\\<in>as \\<inter> UNIV \\<times> {n}.\n                            case a of (a, i) \\<Rightarrow> a)\n 2. B 0 =\n    (\\<Prod>a\\<in>as - UNIV \\<times> {0..<0}.\n       case a of (a, i) \\<Rightarrow> a)\n 3. \\<And>n.\n       \\<lbrakk>B n =\n                (\\<Prod>a\\<in>as - UNIV \\<times> {0..<n}.\n                   case a of (a, i) \\<Rightarrow> a);\n        A n =\n        (\\<Prod>a\\<in>as \\<inter> UNIV \\<times> {n}.\n           case a of (a, i) \\<Rightarrow> a)\\<rbrakk>\n       \\<Longrightarrow> B (Suc n) =\n                         (\\<Prod>a\\<in>as - UNIV \\<times> {0..<Suc n}.\n                            case a of (a, i) \\<Rightarrow> a)\n 4. C 0 =\n    (\\<Sum>a\\<in>as - UNIV \\<times> {0..<0}.\n       case a of\n       (a, i) \\<Rightarrow>\n         (\\<Prod>a\\<in>as - UNIV \\<times> {0..<0} - {(a, i)}.\n            case a of (b, j) \\<Rightarrow> b) *\n         smult (of_nat (Suc i - 0)) (pderiv a))\n 5. \\<And>n.\n       \\<lbrakk>D n =\n                (\\<Prod>a\\<in>as \\<inter> UNIV \\<times> {n}.\n                   case a of (a, i) \\<Rightarrow> a) *\n                (\\<Sum>a\\<in>as - UNIV \\<times> {0..<Suc n}.\n                   case a of\n                   (a, i) \\<Rightarrow>\n                     (\\<Prod>a\\<in>as - UNIV \\<times> {0..<Suc n} -\n                                   {(a, i)}.\n                        case a of (b, j) \\<Rightarrow> b) *\n                     smult (of_nat (i - n)) (pderiv a));\n        A n =\n        (\\<Prod>a\\<in>as \\<inter> UNIV \\<times> {n}.\n           case a of (a, i) \\<Rightarrow> a)\\<rbrakk>\n       \\<Longrightarrow> C (Suc n) =\n                         (\\<Sum>a\\<in>as - UNIV \\<times> {0..<Suc n}.\n                            case a of\n                            (a, i) \\<Rightarrow>\n                              (\\<Prod>a\n\\<in>as - UNIV \\<times> {0..<Suc n} - {(a, i)}.\n                                 case a of (b, j) \\<Rightarrow> b) *\n                              smult (of_nat (Suc i - Suc n)) (pderiv a))\n 6. \\<And>n.\n       \\<lbrakk>C n =\n                (\\<Sum>a\\<in>as - UNIV \\<times> {0..<n}.\n                   case a of\n                   (a, i) \\<Rightarrow>\n                     (\\<Prod>a\\<in>as - UNIV \\<times> {0..<n} - {(a, i)}.\n                        case a of (b, j) \\<Rightarrow> b) *\n                     smult (of_nat (Suc i - n)) (pderiv a));\n        B n =\n        (\\<Prod>a\\<in>as - UNIV \\<times> {0..<n}.\n           case a of (a, i) \\<Rightarrow> a)\\<rbrakk>\n       \\<Longrightarrow> D n =\n                         (\\<Prod>a\\<in>as \\<inter> UNIV \\<times> {n}.\n                            case a of (a, i) \\<Rightarrow> a) *\n                         (\\<Sum>a\\<in>as - UNIV \\<times> {0..<Suc n}.\n                            case a of\n                            (a, i) \\<Rightarrow>\n                              (\\<Prod>a\n\\<in>as - UNIV \\<times> {0..<Suc n} - {(a, i)}.\n                                 case a of (b, j) \\<Rightarrow> b) *\n                              smult (of_nat (i - n)) (pderiv a))", "let ?an = \"(\\<Prod> (a, i) \\<in> as \\<inter> UNIV \\<times> {n}. a)\""], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>B n =\n                (\\<Prod>a\\<in>as - UNIV \\<times> {0..<n}.\n                   case a of (a, i) \\<Rightarrow> a);\n        D n =\n        (\\<Prod>a\\<in>as \\<inter> UNIV \\<times> {n}.\n           case a of (a, i) \\<Rightarrow> a) *\n        (\\<Sum>a\\<in>as - UNIV \\<times> {0..<Suc n}.\n           case a of\n           (a, i) \\<Rightarrow>\n             (\\<Prod>a\\<in>as - UNIV \\<times> {0..<Suc n} - {(a, i)}.\n                case a of (b, j) \\<Rightarrow> b) *\n             smult (of_nat (i - n)) (pderiv a))\\<rbrakk>\n       \\<Longrightarrow> A n =\n                         (\\<Prod>a\\<in>as \\<inter> UNIV \\<times> {n}.\n                            case a of (a, i) \\<Rightarrow> a)\n 2. B 0 =\n    (\\<Prod>a\\<in>as - UNIV \\<times> {0..<0}.\n       case a of (a, i) \\<Rightarrow> a)\n 3. \\<And>n.\n       \\<lbrakk>B n =\n                (\\<Prod>a\\<in>as - UNIV \\<times> {0..<n}.\n                   case a of (a, i) \\<Rightarrow> a);\n        A n =\n        (\\<Prod>a\\<in>as \\<inter> UNIV \\<times> {n}.\n           case a of (a, i) \\<Rightarrow> a)\\<rbrakk>\n       \\<Longrightarrow> B (Suc n) =\n                         (\\<Prod>a\\<in>as - UNIV \\<times> {0..<Suc n}.\n                            case a of (a, i) \\<Rightarrow> a)\n 4. C 0 =\n    (\\<Sum>a\\<in>as - UNIV \\<times> {0..<0}.\n       case a of\n       (a, i) \\<Rightarrow>\n         (\\<Prod>a\\<in>as - UNIV \\<times> {0..<0} - {(a, i)}.\n            case a of (b, j) \\<Rightarrow> b) *\n         smult (of_nat (Suc i - 0)) (pderiv a))\n 5. \\<And>n.\n       \\<lbrakk>D n =\n                (\\<Prod>a\\<in>as \\<inter> UNIV \\<times> {n}.\n                   case a of (a, i) \\<Rightarrow> a) *\n                (\\<Sum>a\\<in>as - UNIV \\<times> {0..<Suc n}.\n                   case a of\n                   (a, i) \\<Rightarrow>\n                     (\\<Prod>a\\<in>as - UNIV \\<times> {0..<Suc n} -\n                                   {(a, i)}.\n                        case a of (b, j) \\<Rightarrow> b) *\n                     smult (of_nat (i - n)) (pderiv a));\n        A n =\n        (\\<Prod>a\\<in>as \\<inter> UNIV \\<times> {n}.\n           case a of (a, i) \\<Rightarrow> a)\\<rbrakk>\n       \\<Longrightarrow> C (Suc n) =\n                         (\\<Sum>a\\<in>as - UNIV \\<times> {0..<Suc n}.\n                            case a of\n                            (a, i) \\<Rightarrow>\n                              (\\<Prod>a\n\\<in>as - UNIV \\<times> {0..<Suc n} - {(a, i)}.\n                                 case a of (b, j) \\<Rightarrow> b) *\n                              smult (of_nat (Suc i - Suc n)) (pderiv a))\n 6. \\<And>n.\n       \\<lbrakk>C n =\n                (\\<Sum>a\\<in>as - UNIV \\<times> {0..<n}.\n                   case a of\n                   (a, i) \\<Rightarrow>\n                     (\\<Prod>a\\<in>as - UNIV \\<times> {0..<n} - {(a, i)}.\n                        case a of (b, j) \\<Rightarrow> b) *\n                     smult (of_nat (Suc i - n)) (pderiv a));\n        B n =\n        (\\<Prod>a\\<in>as - UNIV \\<times> {0..<n}.\n           case a of (a, i) \\<Rightarrow> a)\\<rbrakk>\n       \\<Longrightarrow> D n =\n                         (\\<Prod>a\\<in>as \\<inter> UNIV \\<times> {n}.\n                            case a of (a, i) \\<Rightarrow> a) *\n                         (\\<Sum>a\\<in>as - UNIV \\<times> {0..<Suc n}.\n                            case a of\n                            (a, i) \\<Rightarrow>\n                              (\\<Prod>a\n\\<in>as - UNIV \\<times> {0..<Suc n} - {(a, i)}.\n                                 case a of (b, j) \\<Rightarrow> b) *\n                              smult (of_nat (i - n)) (pderiv a))", "let ?bn = \"(\\<Prod>(a, i)\\<in>as - UNIV \\<times> {0..<Suc n}. a)\""], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>B n =\n                (\\<Prod>a\\<in>as - UNIV \\<times> {0..<n}.\n                   case a of (a, i) \\<Rightarrow> a);\n        D n =\n        (\\<Prod>a\\<in>as \\<inter> UNIV \\<times> {n}.\n           case a of (a, i) \\<Rightarrow> a) *\n        (\\<Sum>a\\<in>as - UNIV \\<times> {0..<Suc n}.\n           case a of\n           (a, i) \\<Rightarrow>\n             (\\<Prod>a\\<in>as - UNIV \\<times> {0..<Suc n} - {(a, i)}.\n                case a of (b, j) \\<Rightarrow> b) *\n             smult (of_nat (i - n)) (pderiv a))\\<rbrakk>\n       \\<Longrightarrow> A n =\n                         (\\<Prod>a\\<in>as \\<inter> UNIV \\<times> {n}.\n                            case a of (a, i) \\<Rightarrow> a)\n 2. B 0 =\n    (\\<Prod>a\\<in>as - UNIV \\<times> {0..<0}.\n       case a of (a, i) \\<Rightarrow> a)\n 3. \\<And>n.\n       \\<lbrakk>B n =\n                (\\<Prod>a\\<in>as - UNIV \\<times> {0..<n}.\n                   case a of (a, i) \\<Rightarrow> a);\n        A n =\n        (\\<Prod>a\\<in>as \\<inter> UNIV \\<times> {n}.\n           case a of (a, i) \\<Rightarrow> a)\\<rbrakk>\n       \\<Longrightarrow> B (Suc n) =\n                         (\\<Prod>a\\<in>as - UNIV \\<times> {0..<Suc n}.\n                            case a of (a, i) \\<Rightarrow> a)\n 4. C 0 =\n    (\\<Sum>a\\<in>as - UNIV \\<times> {0..<0}.\n       case a of\n       (a, i) \\<Rightarrow>\n         (\\<Prod>a\\<in>as - UNIV \\<times> {0..<0} - {(a, i)}.\n            case a of (b, j) \\<Rightarrow> b) *\n         smult (of_nat (Suc i - 0)) (pderiv a))\n 5. \\<And>n.\n       \\<lbrakk>D n =\n                (\\<Prod>a\\<in>as \\<inter> UNIV \\<times> {n}.\n                   case a of (a, i) \\<Rightarrow> a) *\n                (\\<Sum>a\\<in>as - UNIV \\<times> {0..<Suc n}.\n                   case a of\n                   (a, i) \\<Rightarrow>\n                     (\\<Prod>a\\<in>as - UNIV \\<times> {0..<Suc n} -\n                                   {(a, i)}.\n                        case a of (b, j) \\<Rightarrow> b) *\n                     smult (of_nat (i - n)) (pderiv a));\n        A n =\n        (\\<Prod>a\\<in>as \\<inter> UNIV \\<times> {n}.\n           case a of (a, i) \\<Rightarrow> a)\\<rbrakk>\n       \\<Longrightarrow> C (Suc n) =\n                         (\\<Sum>a\\<in>as - UNIV \\<times> {0..<Suc n}.\n                            case a of\n                            (a, i) \\<Rightarrow>\n                              (\\<Prod>a\n\\<in>as - UNIV \\<times> {0..<Suc n} - {(a, i)}.\n                                 case a of (b, j) \\<Rightarrow> b) *\n                              smult (of_nat (Suc i - Suc n)) (pderiv a))\n 6. \\<And>n.\n       \\<lbrakk>C n =\n                (\\<Sum>a\\<in>as - UNIV \\<times> {0..<n}.\n                   case a of\n                   (a, i) \\<Rightarrow>\n                     (\\<Prod>a\\<in>as - UNIV \\<times> {0..<n} - {(a, i)}.\n                        case a of (b, j) \\<Rightarrow> b) *\n                     smult (of_nat (Suc i - n)) (pderiv a));\n        B n =\n        (\\<Prod>a\\<in>as - UNIV \\<times> {0..<n}.\n           case a of (a, i) \\<Rightarrow> a)\\<rbrakk>\n       \\<Longrightarrow> D n =\n                         (\\<Prod>a\\<in>as \\<inter> UNIV \\<times> {n}.\n                            case a of (a, i) \\<Rightarrow> a) *\n                         (\\<Sum>a\\<in>as - UNIV \\<times> {0..<Suc n}.\n                            case a of\n                            (a, i) \\<Rightarrow>\n                              (\\<Prod>a\n\\<in>as - UNIV \\<times> {0..<Suc n} - {(a, i)}.\n                                 case a of (b, j) \\<Rightarrow> b) *\n                              smult (of_nat (i - n)) (pderiv a))", "show \"A n = ?an\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A n = (\\<Prod>(a, i)\\<in>as \\<inter> UNIV \\<times> {n}. a)", "unfolding A.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. gcd (B n) (D n) = (\\<Prod>(a, i)\\<in>as \\<inter> UNIV \\<times> {n}. a)", "proof (rule gcdI[symmetric, OF _ _ _ normalize_monic[OF monic_gen]])"], ["proof (state)\ngoal (4 subgoals):\n 1. (\\<Prod>(a, i)\\<in>as \\<inter> UNIV \\<times> {n}. a) dvd B n\n 2. (\\<Prod>(a, i)\\<in>as \\<inter> UNIV \\<times> {n}. a) dvd D n\n 3. \\<And>d.\n       \\<lbrakk>d dvd B n; d dvd D n\\<rbrakk>\n       \\<Longrightarrow> d dvd\n                         (\\<Prod>(a, i)\\<in>as \\<inter> UNIV \\<times> {n}.\n                            a)\n 4. as \\<inter> UNIV \\<times> {n} \\<subseteq> as", "have monB1: \"monic (B n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monic (B n)", "unfolding Bn"], ["proof (prove)\ngoal (1 subgoal):\n 1. monic (\\<Prod>(a, i)\\<in>as - UNIV \\<times> {0..<n}. a)", "by (rule monic_gen, auto)"], ["proof (state)\nthis:\n  monic (B n)\n\ngoal (4 subgoals):\n 1. (\\<Prod>(a, i)\\<in>as \\<inter> UNIV \\<times> {n}. a) dvd B n\n 2. (\\<Prod>(a, i)\\<in>as \\<inter> UNIV \\<times> {n}. a) dvd D n\n 3. \\<And>d.\n       \\<lbrakk>d dvd B n; d dvd D n\\<rbrakk>\n       \\<Longrightarrow> d dvd\n                         (\\<Prod>(a, i)\\<in>as \\<inter> UNIV \\<times> {n}.\n                            a)\n 4. as \\<inter> UNIV \\<times> {n} \\<subseteq> as", "hence \"B n \\<noteq> 0\""], ["proof (prove)\nusing this:\n  monic (B n)\n\ngoal (1 subgoal):\n 1. B n \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  B n \\<noteq> 0\n\ngoal (4 subgoals):\n 1. (\\<Prod>(a, i)\\<in>as \\<inter> UNIV \\<times> {n}. a) dvd B n\n 2. (\\<Prod>(a, i)\\<in>as \\<inter> UNIV \\<times> {n}. a) dvd D n\n 3. \\<And>d.\n       \\<lbrakk>d dvd B n; d dvd D n\\<rbrakk>\n       \\<Longrightarrow> d dvd\n                         (\\<Prod>(a, i)\\<in>as \\<inter> UNIV \\<times> {n}.\n                            a)\n 4. as \\<inter> UNIV \\<times> {n} \\<subseteq> as", "let ?dn = \"(\\<Sum> (a,i)\\<in>as - UNIV \\<times> {0 ..< Suc n}. \n        (\\<Prod>(b, j)\\<in> as - UNIV \\<times> {0 ..< Suc n} - {(a, i)}. b) * (smult (of_nat (i - n)) (pderiv a)))\""], ["proof (state)\ngoal (4 subgoals):\n 1. (\\<Prod>(a, i)\\<in>as \\<inter> UNIV \\<times> {n}. a) dvd B n\n 2. (\\<Prod>(a, i)\\<in>as \\<inter> UNIV \\<times> {n}. a) dvd D n\n 3. \\<And>d.\n       \\<lbrakk>d dvd B n; d dvd D n\\<rbrakk>\n       \\<Longrightarrow> d dvd\n                         (\\<Prod>(a, i)\\<in>as \\<inter> UNIV \\<times> {n}.\n                            a)\n 4. as \\<inter> UNIV \\<times> {n} \\<subseteq> as", "have Dn: \"D n = ?an * ?dn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. D n =\n    (\\<Prod>(a, i)\\<in>as \\<inter> UNIV \\<times> {n}. a) *\n    (\\<Sum>(a, i)\\<in>as - UNIV \\<times> {0..<Suc n}.\n       (\\<Prod>(b, j)\\<in>as - UNIV \\<times> {0..<Suc n} - {(a, i)}. b) *\n       smult (of_nat (i - n)) (pderiv a))", "unfolding Dn"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>(a, i)\\<in>as \\<inter> UNIV \\<times> {n}. a) *\n    (\\<Sum>(a, i)\\<in>as - UNIV \\<times> {0..<Suc n}.\n       (\\<Prod>(b, j)\\<in>as - UNIV \\<times> {0..<Suc n} - {(a, i)}. b) *\n       smult (of_nat (i - n)) (pderiv a)) =\n    (\\<Prod>(a, i)\\<in>as \\<inter> UNIV \\<times> {n}. a) *\n    (\\<Sum>(a, i)\\<in>as - UNIV \\<times> {0..<Suc n}.\n       (\\<Prod>(b, j)\\<in>as - UNIV \\<times> {0..<Suc n} - {(a, i)}. b) *\n       smult (of_nat (i - n)) (pderiv a))", "by auto"], ["proof (state)\nthis:\n  D n =\n  (\\<Prod>(a, i)\\<in>as \\<inter> UNIV \\<times> {n}. a) *\n  (\\<Sum>(a, i)\\<in>as - UNIV \\<times> {0..<Suc n}.\n     (\\<Prod>(b, j)\\<in>as - UNIV \\<times> {0..<Suc n} - {(a, i)}. b) *\n     smult (of_nat (i - n)) (pderiv a))\n\ngoal (4 subgoals):\n 1. (\\<Prod>(a, i)\\<in>as \\<inter> UNIV \\<times> {n}. a) dvd B n\n 2. (\\<Prod>(a, i)\\<in>as \\<inter> UNIV \\<times> {n}. a) dvd D n\n 3. \\<And>d.\n       \\<lbrakk>d dvd B n; d dvd D n\\<rbrakk>\n       \\<Longrightarrow> d dvd\n                         (\\<Prod>(a, i)\\<in>as \\<inter> UNIV \\<times> {n}.\n                            a)\n 4. as \\<inter> UNIV \\<times> {n} \\<subseteq> as", "show dvd1: \"?an dvd B n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>(a, i)\\<in>as \\<inter> UNIV \\<times> {n}. a) dvd B n", "unfolding Bn' dvd_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>k.\n       (\\<Prod>(a, i)\\<in>as \\<inter> UNIV \\<times> {n}. a) *\n       (\\<Prod>(a, i)\\<in>as - UNIV \\<times> {0..<Suc n}. a) =\n       (\\<Prod>(a, i)\\<in>as \\<inter> UNIV \\<times> {n}. a) * k", "by blast"], ["proof (state)\nthis:\n  (\\<Prod>(a, i)\\<in>as \\<inter> UNIV \\<times> {n}. a) dvd B n\n\ngoal (3 subgoals):\n 1. (\\<Prod>(a, i)\\<in>as \\<inter> UNIV \\<times> {n}. a) dvd D n\n 2. \\<And>d.\n       \\<lbrakk>d dvd B n; d dvd D n\\<rbrakk>\n       \\<Longrightarrow> d dvd\n                         (\\<Prod>(a, i)\\<in>as \\<inter> UNIV \\<times> {n}.\n                            a)\n 3. as \\<inter> UNIV \\<times> {n} \\<subseteq> as", "show dvd2: \"?an dvd D n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>(a, i)\\<in>as \\<inter> UNIV \\<times> {n}. a) dvd D n", "unfolding Dn dvd_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>k.\n       (\\<Prod>(a, i)\\<in>as \\<inter> UNIV \\<times> {n}. a) *\n       (\\<Sum>(a, i)\\<in>as - UNIV \\<times> {0..<Suc n}.\n          (\\<Prod>(b, j)\\<in>as - UNIV \\<times> {0..<Suc n} - {(a, i)}. b) *\n          smult (of_nat (i - n)) (pderiv a)) =\n       (\\<Prod>(a, i)\\<in>as \\<inter> UNIV \\<times> {n}. a) * k", "by blast"], ["proof (state)\nthis:\n  (\\<Prod>(a, i)\\<in>as \\<inter> UNIV \\<times> {n}. a) dvd D n\n\ngoal (2 subgoals):\n 1. \\<And>d.\n       \\<lbrakk>d dvd B n; d dvd D n\\<rbrakk>\n       \\<Longrightarrow> d dvd\n                         (\\<Prod>(a, i)\\<in>as \\<inter> UNIV \\<times> {n}.\n                            a)\n 2. as \\<inter> UNIV \\<times> {n} \\<subseteq> as", "{"], ["proof (state)\nthis:\n  (\\<Prod>(a, i)\\<in>as \\<inter> UNIV \\<times> {n}. a) dvd D n\n\ngoal (2 subgoals):\n 1. \\<And>d.\n       \\<lbrakk>d dvd B n; d dvd D n\\<rbrakk>\n       \\<Longrightarrow> d dvd\n                         (\\<Prod>(a, i)\\<in>as \\<inter> UNIV \\<times> {n}.\n                            a)\n 2. as \\<inter> UNIV \\<times> {n} \\<subseteq> as", "fix k"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>d.\n       \\<lbrakk>d dvd B n; d dvd D n\\<rbrakk>\n       \\<Longrightarrow> d dvd\n                         (\\<Prod>(a, i)\\<in>as \\<inter> UNIV \\<times> {n}.\n                            a)\n 2. as \\<inter> UNIV \\<times> {n} \\<subseteq> as", "assume \"k dvd B n\" \"k dvd D n\""], ["proof (state)\nthis:\n  k dvd B n\n  k dvd D n\n\ngoal (2 subgoals):\n 1. \\<And>d.\n       \\<lbrakk>d dvd B n; d dvd D n\\<rbrakk>\n       \\<Longrightarrow> d dvd\n                         (\\<Prod>(a, i)\\<in>as \\<inter> UNIV \\<times> {n}.\n                            a)\n 2. as \\<inter> UNIV \\<times> {n} \\<subseteq> as", "from dvd_gcd_mult[OF this[unfolded Bn' Dn]]"], ["proof (chain)\npicking this:\n  k dvd\n  (\\<Prod>(a, i)\\<in>as \\<inter> UNIV \\<times> {n}. a) *\n  gcd (\\<Prod>(a, i)\\<in>as - UNIV \\<times> {0..<Suc n}. a)\n   (\\<Sum>(a, i)\\<in>as - UNIV \\<times> {0..<Suc n}.\n      (\\<Prod>(b, j)\\<in>as - UNIV \\<times> {0..<Suc n} - {(a, i)}. b) *\n      smult (of_nat (i - n)) (pderiv a))", "have \"k dvd ?an * (gcd ?bn ?dn)\""], ["proof (prove)\nusing this:\n  k dvd\n  (\\<Prod>(a, i)\\<in>as \\<inter> UNIV \\<times> {n}. a) *\n  gcd (\\<Prod>(a, i)\\<in>as - UNIV \\<times> {0..<Suc n}. a)\n   (\\<Sum>(a, i)\\<in>as - UNIV \\<times> {0..<Suc n}.\n      (\\<Prod>(b, j)\\<in>as - UNIV \\<times> {0..<Suc n} - {(a, i)}. b) *\n      smult (of_nat (i - n)) (pderiv a))\n\ngoal (1 subgoal):\n 1. k dvd\n    (\\<Prod>(a, i)\\<in>as \\<inter> UNIV \\<times> {n}. a) *\n    gcd (\\<Prod>(a, i)\\<in>as - UNIV \\<times> {0..<Suc n}. a)\n     (\\<Sum>(a, i)\\<in>as - UNIV \\<times> {0..<Suc n}.\n        (\\<Prod>(b, j)\\<in>as - UNIV \\<times> {0..<Suc n} - {(a, i)}. b) *\n        smult (of_nat (i - n)) (pderiv a))", "."], ["proof (state)\nthis:\n  k dvd\n  (\\<Prod>(a, i)\\<in>as \\<inter> UNIV \\<times> {n}. a) *\n  gcd (\\<Prod>(a, i)\\<in>as - UNIV \\<times> {0..<Suc n}. a)\n   (\\<Sum>(a, i)\\<in>as - UNIV \\<times> {0..<Suc n}.\n      (\\<Prod>(b, j)\\<in>as - UNIV \\<times> {0..<Suc n} - {(a, i)}. b) *\n      smult (of_nat (i - n)) (pderiv a))\n\ngoal (2 subgoals):\n 1. \\<And>d.\n       \\<lbrakk>d dvd B n; d dvd D n\\<rbrakk>\n       \\<Longrightarrow> d dvd\n                         (\\<Prod>(a, i)\\<in>as \\<inter> UNIV \\<times> {n}.\n                            a)\n 2. as \\<inter> UNIV \\<times> {n} \\<subseteq> as", "moreover"], ["proof (state)\nthis:\n  k dvd\n  (\\<Prod>(a, i)\\<in>as \\<inter> UNIV \\<times> {n}. a) *\n  gcd (\\<Prod>(a, i)\\<in>as - UNIV \\<times> {0..<Suc n}. a)\n   (\\<Sum>(a, i)\\<in>as - UNIV \\<times> {0..<Suc n}.\n      (\\<Prod>(b, j)\\<in>as - UNIV \\<times> {0..<Suc n} - {(a, i)}. b) *\n      smult (of_nat (i - n)) (pderiv a))\n\ngoal (2 subgoals):\n 1. \\<And>d.\n       \\<lbrakk>d dvd B n; d dvd D n\\<rbrakk>\n       \\<Longrightarrow> d dvd\n                         (\\<Prod>(a, i)\\<in>as \\<inter> UNIV \\<times> {n}.\n                            a)\n 2. as \\<inter> UNIV \\<times> {n} \\<subseteq> as", "have \"coprime ?bn ?dn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coprime (\\<Prod>(a, i)\\<in>as - UNIV \\<times> {0..<Suc n}. a)\n     (\\<Sum>(a, i)\\<in>as - UNIV \\<times> {0..<Suc n}.\n        (\\<Prod>(b, j)\\<in>as - UNIV \\<times> {0..<Suc n} - {(a, i)}. b) *\n        smult (of_nat (i - n)) (pderiv a))", "by (rule coprime_generic, auto)"], ["proof (state)\nthis:\n  coprime (\\<Prod>(a, i)\\<in>as - UNIV \\<times> {0..<Suc n}. a)\n   (\\<Sum>(a, i)\\<in>as - UNIV \\<times> {0..<Suc n}.\n      (\\<Prod>(b, j)\\<in>as - UNIV \\<times> {0..<Suc n} - {(a, i)}. b) *\n      smult (of_nat (i - n)) (pderiv a))\n\ngoal (2 subgoals):\n 1. \\<And>d.\n       \\<lbrakk>d dvd B n; d dvd D n\\<rbrakk>\n       \\<Longrightarrow> d dvd\n                         (\\<Prod>(a, i)\\<in>as \\<inter> UNIV \\<times> {n}.\n                            a)\n 2. as \\<inter> UNIV \\<times> {n} \\<subseteq> as", "ultimately"], ["proof (chain)\npicking this:\n  k dvd\n  (\\<Prod>(a, i)\\<in>as \\<inter> UNIV \\<times> {n}. a) *\n  gcd (\\<Prod>(a, i)\\<in>as - UNIV \\<times> {0..<Suc n}. a)\n   (\\<Sum>(a, i)\\<in>as - UNIV \\<times> {0..<Suc n}.\n      (\\<Prod>(b, j)\\<in>as - UNIV \\<times> {0..<Suc n} - {(a, i)}. b) *\n      smult (of_nat (i - n)) (pderiv a))\n  coprime (\\<Prod>(a, i)\\<in>as - UNIV \\<times> {0..<Suc n}. a)\n   (\\<Sum>(a, i)\\<in>as - UNIV \\<times> {0..<Suc n}.\n      (\\<Prod>(b, j)\\<in>as - UNIV \\<times> {0..<Suc n} - {(a, i)}. b) *\n      smult (of_nat (i - n)) (pderiv a))", "show \"k dvd ?an\""], ["proof (prove)\nusing this:\n  k dvd\n  (\\<Prod>(a, i)\\<in>as \\<inter> UNIV \\<times> {n}. a) *\n  gcd (\\<Prod>(a, i)\\<in>as - UNIV \\<times> {0..<Suc n}. a)\n   (\\<Sum>(a, i)\\<in>as - UNIV \\<times> {0..<Suc n}.\n      (\\<Prod>(b, j)\\<in>as - UNIV \\<times> {0..<Suc n} - {(a, i)}. b) *\n      smult (of_nat (i - n)) (pderiv a))\n  coprime (\\<Prod>(a, i)\\<in>as - UNIV \\<times> {0..<Suc n}. a)\n   (\\<Sum>(a, i)\\<in>as - UNIV \\<times> {0..<Suc n}.\n      (\\<Prod>(b, j)\\<in>as - UNIV \\<times> {0..<Suc n} - {(a, i)}. b) *\n      smult (of_nat (i - n)) (pderiv a))\n\ngoal (1 subgoal):\n 1. k dvd (\\<Prod>(a, i)\\<in>as \\<inter> UNIV \\<times> {n}. a)", "by simp"], ["proof (state)\nthis:\n  k dvd (\\<Prod>(a, i)\\<in>as \\<inter> UNIV \\<times> {n}. a)\n\ngoal (1 subgoal):\n 1. as \\<inter> UNIV \\<times> {n} \\<subseteq> as", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?k2 dvd B n; ?k2 dvd D n\\<rbrakk>\n  \\<Longrightarrow> ?k2 dvd\n                    (\\<Prod>(a, i)\\<in>as \\<inter> UNIV \\<times> {n}. a)\n\ngoal (1 subgoal):\n 1. as \\<inter> UNIV \\<times> {n} \\<subseteq> as", "qed auto"], ["proof (state)\nthis:\n  A n = (\\<Prod>(a, i)\\<in>as \\<inter> UNIV \\<times> {n}. a)\n\ngoal (5 subgoals):\n 1. B 0 =\n    (\\<Prod>a\\<in>as - UNIV \\<times> {0..<0}.\n       case a of (a, i) \\<Rightarrow> a)\n 2. \\<And>n.\n       \\<lbrakk>B n =\n                (\\<Prod>a\\<in>as - UNIV \\<times> {0..<n}.\n                   case a of (a, i) \\<Rightarrow> a);\n        A n =\n        (\\<Prod>a\\<in>as \\<inter> UNIV \\<times> {n}.\n           case a of (a, i) \\<Rightarrow> a)\\<rbrakk>\n       \\<Longrightarrow> B (Suc n) =\n                         (\\<Prod>a\\<in>as - UNIV \\<times> {0..<Suc n}.\n                            case a of (a, i) \\<Rightarrow> a)\n 3. C 0 =\n    (\\<Sum>a\\<in>as - UNIV \\<times> {0..<0}.\n       case a of\n       (a, i) \\<Rightarrow>\n         (\\<Prod>a\\<in>as - UNIV \\<times> {0..<0} - {(a, i)}.\n            case a of (b, j) \\<Rightarrow> b) *\n         smult (of_nat (Suc i - 0)) (pderiv a))\n 4. \\<And>n.\n       \\<lbrakk>D n =\n                (\\<Prod>a\\<in>as \\<inter> UNIV \\<times> {n}.\n                   case a of (a, i) \\<Rightarrow> a) *\n                (\\<Sum>a\\<in>as - UNIV \\<times> {0..<Suc n}.\n                   case a of\n                   (a, i) \\<Rightarrow>\n                     (\\<Prod>a\\<in>as - UNIV \\<times> {0..<Suc n} -\n                                   {(a, i)}.\n                        case a of (b, j) \\<Rightarrow> b) *\n                     smult (of_nat (i - n)) (pderiv a));\n        A n =\n        (\\<Prod>a\\<in>as \\<inter> UNIV \\<times> {n}.\n           case a of (a, i) \\<Rightarrow> a)\\<rbrakk>\n       \\<Longrightarrow> C (Suc n) =\n                         (\\<Sum>a\\<in>as - UNIV \\<times> {0..<Suc n}.\n                            case a of\n                            (a, i) \\<Rightarrow>\n                              (\\<Prod>a\n\\<in>as - UNIV \\<times> {0..<Suc n} - {(a, i)}.\n                                 case a of (b, j) \\<Rightarrow> b) *\n                              smult (of_nat (Suc i - Suc n)) (pderiv a))\n 5. \\<And>n.\n       \\<lbrakk>C n =\n                (\\<Sum>a\\<in>as - UNIV \\<times> {0..<n}.\n                   case a of\n                   (a, i) \\<Rightarrow>\n                     (\\<Prod>a\\<in>as - UNIV \\<times> {0..<n} - {(a, i)}.\n                        case a of (b, j) \\<Rightarrow> b) *\n                     smult (of_nat (Suc i - n)) (pderiv a));\n        B n =\n        (\\<Prod>a\\<in>as - UNIV \\<times> {0..<n}.\n           case a of (a, i) \\<Rightarrow> a)\\<rbrakk>\n       \\<Longrightarrow> D n =\n                         (\\<Prod>a\\<in>as \\<inter> UNIV \\<times> {n}.\n                            case a of (a, i) \\<Rightarrow> a) *\n                         (\\<Sum>a\\<in>as - UNIV \\<times> {0..<Suc n}.\n                            case a of\n                            (a, i) \\<Rightarrow>\n                              (\\<Prod>a\n\\<in>as - UNIV \\<times> {0..<Suc n} - {(a, i)}.\n                                 case a of (b, j) \\<Rightarrow> b) *\n                              smult (of_nat (i - n)) (pderiv a))", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. B 0 =\n    (\\<Prod>a\\<in>as - UNIV \\<times> {0..<0}.\n       case a of (a, i) \\<Rightarrow> a)\n 2. \\<And>n.\n       \\<lbrakk>B n =\n                (\\<Prod>a\\<in>as - UNIV \\<times> {0..<n}.\n                   case a of (a, i) \\<Rightarrow> a);\n        A n =\n        (\\<Prod>a\\<in>as \\<inter> UNIV \\<times> {n}.\n           case a of (a, i) \\<Rightarrow> a)\\<rbrakk>\n       \\<Longrightarrow> B (Suc n) =\n                         (\\<Prod>a\\<in>as - UNIV \\<times> {0..<Suc n}.\n                            case a of (a, i) \\<Rightarrow> a)\n 3. C 0 =\n    (\\<Sum>a\\<in>as - UNIV \\<times> {0..<0}.\n       case a of\n       (a, i) \\<Rightarrow>\n         (\\<Prod>a\\<in>as - UNIV \\<times> {0..<0} - {(a, i)}.\n            case a of (b, j) \\<Rightarrow> b) *\n         smult (of_nat (Suc i - 0)) (pderiv a))\n 4. \\<And>n.\n       \\<lbrakk>D n =\n                (\\<Prod>a\\<in>as \\<inter> UNIV \\<times> {n}.\n                   case a of (a, i) \\<Rightarrow> a) *\n                (\\<Sum>a\\<in>as - UNIV \\<times> {0..<Suc n}.\n                   case a of\n                   (a, i) \\<Rightarrow>\n                     (\\<Prod>a\\<in>as - UNIV \\<times> {0..<Suc n} -\n                                   {(a, i)}.\n                        case a of (b, j) \\<Rightarrow> b) *\n                     smult (of_nat (i - n)) (pderiv a));\n        A n =\n        (\\<Prod>a\\<in>as \\<inter> UNIV \\<times> {n}.\n           case a of (a, i) \\<Rightarrow> a)\\<rbrakk>\n       \\<Longrightarrow> C (Suc n) =\n                         (\\<Sum>a\\<in>as - UNIV \\<times> {0..<Suc n}.\n                            case a of\n                            (a, i) \\<Rightarrow>\n                              (\\<Prod>a\n\\<in>as - UNIV \\<times> {0..<Suc n} - {(a, i)}.\n                                 case a of (b, j) \\<Rightarrow> b) *\n                              smult (of_nat (Suc i - Suc n)) (pderiv a))\n 5. \\<And>n.\n       \\<lbrakk>C n =\n                (\\<Sum>a\\<in>as - UNIV \\<times> {0..<n}.\n                   case a of\n                   (a, i) \\<Rightarrow>\n                     (\\<Prod>a\\<in>as - UNIV \\<times> {0..<n} - {(a, i)}.\n                        case a of (b, j) \\<Rightarrow> b) *\n                     smult (of_nat (Suc i - n)) (pderiv a));\n        B n =\n        (\\<Prod>a\\<in>as - UNIV \\<times> {0..<n}.\n           case a of (a, i) \\<Rightarrow> a)\\<rbrakk>\n       \\<Longrightarrow> D n =\n                         (\\<Prod>a\\<in>as \\<inter> UNIV \\<times> {n}.\n                            case a of (a, i) \\<Rightarrow> a) *\n                         (\\<Sum>a\\<in>as - UNIV \\<times> {0..<Suc n}.\n                            case a of\n                            (a, i) \\<Rightarrow>\n                              (\\<Prod>a\n\\<in>as - UNIV \\<times> {0..<Suc n} - {(a, i)}.\n                                 case a of (b, j) \\<Rightarrow> b) *\n                              smult (of_nat (i - n)) (pderiv a))", "case 2"], ["proof (state)\nthis:\n  \n\ngoal (5 subgoals):\n 1. B 0 =\n    (\\<Prod>a\\<in>as - UNIV \\<times> {0..<0}.\n       case a of (a, i) \\<Rightarrow> a)\n 2. \\<And>n.\n       \\<lbrakk>B n =\n                (\\<Prod>a\\<in>as - UNIV \\<times> {0..<n}.\n                   case a of (a, i) \\<Rightarrow> a);\n        A n =\n        (\\<Prod>a\\<in>as \\<inter> UNIV \\<times> {n}.\n           case a of (a, i) \\<Rightarrow> a)\\<rbrakk>\n       \\<Longrightarrow> B (Suc n) =\n                         (\\<Prod>a\\<in>as - UNIV \\<times> {0..<Suc n}.\n                            case a of (a, i) \\<Rightarrow> a)\n 3. C 0 =\n    (\\<Sum>a\\<in>as - UNIV \\<times> {0..<0}.\n       case a of\n       (a, i) \\<Rightarrow>\n         (\\<Prod>a\\<in>as - UNIV \\<times> {0..<0} - {(a, i)}.\n            case a of (b, j) \\<Rightarrow> b) *\n         smult (of_nat (Suc i - 0)) (pderiv a))\n 4. \\<And>n.\n       \\<lbrakk>D n =\n                (\\<Prod>a\\<in>as \\<inter> UNIV \\<times> {n}.\n                   case a of (a, i) \\<Rightarrow> a) *\n                (\\<Sum>a\\<in>as - UNIV \\<times> {0..<Suc n}.\n                   case a of\n                   (a, i) \\<Rightarrow>\n                     (\\<Prod>a\\<in>as - UNIV \\<times> {0..<Suc n} -\n                                   {(a, i)}.\n                        case a of (b, j) \\<Rightarrow> b) *\n                     smult (of_nat (i - n)) (pderiv a));\n        A n =\n        (\\<Prod>a\\<in>as \\<inter> UNIV \\<times> {n}.\n           case a of (a, i) \\<Rightarrow> a)\\<rbrakk>\n       \\<Longrightarrow> C (Suc n) =\n                         (\\<Sum>a\\<in>as - UNIV \\<times> {0..<Suc n}.\n                            case a of\n                            (a, i) \\<Rightarrow>\n                              (\\<Prod>a\n\\<in>as - UNIV \\<times> {0..<Suc n} - {(a, i)}.\n                                 case a of (b, j) \\<Rightarrow> b) *\n                              smult (of_nat (Suc i - Suc n)) (pderiv a))\n 5. \\<And>n.\n       \\<lbrakk>C n =\n                (\\<Sum>a\\<in>as - UNIV \\<times> {0..<n}.\n                   case a of\n                   (a, i) \\<Rightarrow>\n                     (\\<Prod>a\\<in>as - UNIV \\<times> {0..<n} - {(a, i)}.\n                        case a of (b, j) \\<Rightarrow> b) *\n                     smult (of_nat (Suc i - n)) (pderiv a));\n        B n =\n        (\\<Prod>a\\<in>as - UNIV \\<times> {0..<n}.\n           case a of (a, i) \\<Rightarrow> a)\\<rbrakk>\n       \\<Longrightarrow> D n =\n                         (\\<Prod>a\\<in>as \\<inter> UNIV \\<times> {n}.\n                            case a of (a, i) \\<Rightarrow> a) *\n                         (\\<Sum>a\\<in>as - UNIV \\<times> {0..<Suc n}.\n                            case a of\n                            (a, i) \\<Rightarrow>\n                              (\\<Prod>a\n\\<in>as - UNIV \\<times> {0..<Suc n} - {(a, i)}.\n                                 case a of (b, j) \\<Rightarrow> b) *\n                              smult (of_nat (i - n)) (pderiv a))", "(* B 0 *)"], ["proof (state)\nthis:\n  \n\ngoal (5 subgoals):\n 1. B 0 =\n    (\\<Prod>a\\<in>as - UNIV \\<times> {0..<0}.\n       case a of (a, i) \\<Rightarrow> a)\n 2. \\<And>n.\n       \\<lbrakk>B n =\n                (\\<Prod>a\\<in>as - UNIV \\<times> {0..<n}.\n                   case a of (a, i) \\<Rightarrow> a);\n        A n =\n        (\\<Prod>a\\<in>as \\<inter> UNIV \\<times> {n}.\n           case a of (a, i) \\<Rightarrow> a)\\<rbrakk>\n       \\<Longrightarrow> B (Suc n) =\n                         (\\<Prod>a\\<in>as - UNIV \\<times> {0..<Suc n}.\n                            case a of (a, i) \\<Rightarrow> a)\n 3. C 0 =\n    (\\<Sum>a\\<in>as - UNIV \\<times> {0..<0}.\n       case a of\n       (a, i) \\<Rightarrow>\n         (\\<Prod>a\\<in>as - UNIV \\<times> {0..<0} - {(a, i)}.\n            case a of (b, j) \\<Rightarrow> b) *\n         smult (of_nat (Suc i - 0)) (pderiv a))\n 4. \\<And>n.\n       \\<lbrakk>D n =\n                (\\<Prod>a\\<in>as \\<inter> UNIV \\<times> {n}.\n                   case a of (a, i) \\<Rightarrow> a) *\n                (\\<Sum>a\\<in>as - UNIV \\<times> {0..<Suc n}.\n                   case a of\n                   (a, i) \\<Rightarrow>\n                     (\\<Prod>a\\<in>as - UNIV \\<times> {0..<Suc n} -\n                                   {(a, i)}.\n                        case a of (b, j) \\<Rightarrow> b) *\n                     smult (of_nat (i - n)) (pderiv a));\n        A n =\n        (\\<Prod>a\\<in>as \\<inter> UNIV \\<times> {n}.\n           case a of (a, i) \\<Rightarrow> a)\\<rbrakk>\n       \\<Longrightarrow> C (Suc n) =\n                         (\\<Sum>a\\<in>as - UNIV \\<times> {0..<Suc n}.\n                            case a of\n                            (a, i) \\<Rightarrow>\n                              (\\<Prod>a\n\\<in>as - UNIV \\<times> {0..<Suc n} - {(a, i)}.\n                                 case a of (b, j) \\<Rightarrow> b) *\n                              smult (of_nat (Suc i - Suc n)) (pderiv a))\n 5. \\<And>n.\n       \\<lbrakk>C n =\n                (\\<Sum>a\\<in>as - UNIV \\<times> {0..<n}.\n                   case a of\n                   (a, i) \\<Rightarrow>\n                     (\\<Prod>a\\<in>as - UNIV \\<times> {0..<n} - {(a, i)}.\n                        case a of (b, j) \\<Rightarrow> b) *\n                     smult (of_nat (Suc i - n)) (pderiv a));\n        B n =\n        (\\<Prod>a\\<in>as - UNIV \\<times> {0..<n}.\n           case a of (a, i) \\<Rightarrow> a)\\<rbrakk>\n       \\<Longrightarrow> D n =\n                         (\\<Prod>a\\<in>as \\<inter> UNIV \\<times> {n}.\n                            case a of (a, i) \\<Rightarrow> a) *\n                         (\\<Sum>a\\<in>as - UNIV \\<times> {0..<Suc n}.\n                            case a of\n                            (a, i) \\<Rightarrow>\n                              (\\<Prod>a\n\\<in>as - UNIV \\<times> {0..<Suc n} - {(a, i)}.\n                                 case a of (b, j) \\<Rightarrow> b) *\n                              smult (of_nat (i - n)) (pderiv a))", "have as: \"as - UNIV \\<times> {0..<0} = as\""], ["proof (prove)\ngoal (1 subgoal):\n 1. as - UNIV \\<times> {0..<0} = as", "by auto"], ["proof (state)\nthis:\n  as - UNIV \\<times> {0..<0} = as\n\ngoal (5 subgoals):\n 1. B 0 =\n    (\\<Prod>a\\<in>as - UNIV \\<times> {0..<0}.\n       case a of (a, i) \\<Rightarrow> a)\n 2. \\<And>n.\n       \\<lbrakk>B n =\n                (\\<Prod>a\\<in>as - UNIV \\<times> {0..<n}.\n                   case a of (a, i) \\<Rightarrow> a);\n        A n =\n        (\\<Prod>a\\<in>as \\<inter> UNIV \\<times> {n}.\n           case a of (a, i) \\<Rightarrow> a)\\<rbrakk>\n       \\<Longrightarrow> B (Suc n) =\n                         (\\<Prod>a\\<in>as - UNIV \\<times> {0..<Suc n}.\n                            case a of (a, i) \\<Rightarrow> a)\n 3. C 0 =\n    (\\<Sum>a\\<in>as - UNIV \\<times> {0..<0}.\n       case a of\n       (a, i) \\<Rightarrow>\n         (\\<Prod>a\\<in>as - UNIV \\<times> {0..<0} - {(a, i)}.\n            case a of (b, j) \\<Rightarrow> b) *\n         smult (of_nat (Suc i - 0)) (pderiv a))\n 4. \\<And>n.\n       \\<lbrakk>D n =\n                (\\<Prod>a\\<in>as \\<inter> UNIV \\<times> {n}.\n                   case a of (a, i) \\<Rightarrow> a) *\n                (\\<Sum>a\\<in>as - UNIV \\<times> {0..<Suc n}.\n                   case a of\n                   (a, i) \\<Rightarrow>\n                     (\\<Prod>a\\<in>as - UNIV \\<times> {0..<Suc n} -\n                                   {(a, i)}.\n                        case a of (b, j) \\<Rightarrow> b) *\n                     smult (of_nat (i - n)) (pderiv a));\n        A n =\n        (\\<Prod>a\\<in>as \\<inter> UNIV \\<times> {n}.\n           case a of (a, i) \\<Rightarrow> a)\\<rbrakk>\n       \\<Longrightarrow> C (Suc n) =\n                         (\\<Sum>a\\<in>as - UNIV \\<times> {0..<Suc n}.\n                            case a of\n                            (a, i) \\<Rightarrow>\n                              (\\<Prod>a\n\\<in>as - UNIV \\<times> {0..<Suc n} - {(a, i)}.\n                                 case a of (b, j) \\<Rightarrow> b) *\n                              smult (of_nat (Suc i - Suc n)) (pderiv a))\n 5. \\<And>n.\n       \\<lbrakk>C n =\n                (\\<Sum>a\\<in>as - UNIV \\<times> {0..<n}.\n                   case a of\n                   (a, i) \\<Rightarrow>\n                     (\\<Prod>a\\<in>as - UNIV \\<times> {0..<n} - {(a, i)}.\n                        case a of (b, j) \\<Rightarrow> b) *\n                     smult (of_nat (Suc i - n)) (pderiv a));\n        B n =\n        (\\<Prod>a\\<in>as - UNIV \\<times> {0..<n}.\n           case a of (a, i) \\<Rightarrow> a)\\<rbrakk>\n       \\<Longrightarrow> D n =\n                         (\\<Prod>a\\<in>as \\<inter> UNIV \\<times> {n}.\n                            case a of (a, i) \\<Rightarrow> a) *\n                         (\\<Sum>a\\<in>as - UNIV \\<times> {0..<Suc n}.\n                            case a of\n                            (a, i) \\<Rightarrow>\n                              (\\<Prod>a\n\\<in>as - UNIV \\<times> {0..<Suc n} - {(a, i)}.\n                                 case a of (b, j) \\<Rightarrow> b) *\n                              smult (of_nat (i - n)) (pderiv a))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. B 0 =\n    (\\<Prod>a\\<in>as - UNIV \\<times> {0..<0}.\n       case a of (a, i) \\<Rightarrow> a)", "unfolding B.simps as p_div_gcd_p_pderiv"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>(a, i)\\<in>as. a) =\n    (\\<Prod>a\\<in>as. case a of (a, i) \\<Rightarrow> a)", "by auto"], ["proof (state)\nthis:\n  B 0 =\n  (\\<Prod>a\\<in>as - UNIV \\<times> {0..<0}.\n     case a of (a, i) \\<Rightarrow> a)\n\ngoal (4 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>B n =\n                (\\<Prod>a\\<in>as - UNIV \\<times> {0..<n}.\n                   case a of (a, i) \\<Rightarrow> a);\n        A n =\n        (\\<Prod>a\\<in>as \\<inter> UNIV \\<times> {n}.\n           case a of (a, i) \\<Rightarrow> a)\\<rbrakk>\n       \\<Longrightarrow> B (Suc n) =\n                         (\\<Prod>a\\<in>as - UNIV \\<times> {0..<Suc n}.\n                            case a of (a, i) \\<Rightarrow> a)\n 2. C 0 =\n    (\\<Sum>a\\<in>as - UNIV \\<times> {0..<0}.\n       case a of\n       (a, i) \\<Rightarrow>\n         (\\<Prod>a\\<in>as - UNIV \\<times> {0..<0} - {(a, i)}.\n            case a of (b, j) \\<Rightarrow> b) *\n         smult (of_nat (Suc i - 0)) (pderiv a))\n 3. \\<And>n.\n       \\<lbrakk>D n =\n                (\\<Prod>a\\<in>as \\<inter> UNIV \\<times> {n}.\n                   case a of (a, i) \\<Rightarrow> a) *\n                (\\<Sum>a\\<in>as - UNIV \\<times> {0..<Suc n}.\n                   case a of\n                   (a, i) \\<Rightarrow>\n                     (\\<Prod>a\\<in>as - UNIV \\<times> {0..<Suc n} -\n                                   {(a, i)}.\n                        case a of (b, j) \\<Rightarrow> b) *\n                     smult (of_nat (i - n)) (pderiv a));\n        A n =\n        (\\<Prod>a\\<in>as \\<inter> UNIV \\<times> {n}.\n           case a of (a, i) \\<Rightarrow> a)\\<rbrakk>\n       \\<Longrightarrow> C (Suc n) =\n                         (\\<Sum>a\\<in>as - UNIV \\<times> {0..<Suc n}.\n                            case a of\n                            (a, i) \\<Rightarrow>\n                              (\\<Prod>a\n\\<in>as - UNIV \\<times> {0..<Suc n} - {(a, i)}.\n                                 case a of (b, j) \\<Rightarrow> b) *\n                              smult (of_nat (Suc i - Suc n)) (pderiv a))\n 4. \\<And>n.\n       \\<lbrakk>C n =\n                (\\<Sum>a\\<in>as - UNIV \\<times> {0..<n}.\n                   case a of\n                   (a, i) \\<Rightarrow>\n                     (\\<Prod>a\\<in>as - UNIV \\<times> {0..<n} - {(a, i)}.\n                        case a of (b, j) \\<Rightarrow> b) *\n                     smult (of_nat (Suc i - n)) (pderiv a));\n        B n =\n        (\\<Prod>a\\<in>as - UNIV \\<times> {0..<n}.\n           case a of (a, i) \\<Rightarrow> a)\\<rbrakk>\n       \\<Longrightarrow> D n =\n                         (\\<Prod>a\\<in>as \\<inter> UNIV \\<times> {n}.\n                            case a of (a, i) \\<Rightarrow> a) *\n                         (\\<Sum>a\\<in>as - UNIV \\<times> {0..<Suc n}.\n                            case a of\n                            (a, i) \\<Rightarrow>\n                              (\\<Prod>a\n\\<in>as - UNIV \\<times> {0..<Suc n} - {(a, i)}.\n                                 case a of (b, j) \\<Rightarrow> b) *\n                              smult (of_nat (i - n)) (pderiv a))", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>B n =\n                (\\<Prod>a\\<in>as - UNIV \\<times> {0..<n}.\n                   case a of (a, i) \\<Rightarrow> a);\n        A n =\n        (\\<Prod>a\\<in>as \\<inter> UNIV \\<times> {n}.\n           case a of (a, i) \\<Rightarrow> a)\\<rbrakk>\n       \\<Longrightarrow> B (Suc n) =\n                         (\\<Prod>a\\<in>as - UNIV \\<times> {0..<Suc n}.\n                            case a of (a, i) \\<Rightarrow> a)\n 2. C 0 =\n    (\\<Sum>a\\<in>as - UNIV \\<times> {0..<0}.\n       case a of\n       (a, i) \\<Rightarrow>\n         (\\<Prod>a\\<in>as - UNIV \\<times> {0..<0} - {(a, i)}.\n            case a of (b, j) \\<Rightarrow> b) *\n         smult (of_nat (Suc i - 0)) (pderiv a))\n 3. \\<And>n.\n       \\<lbrakk>D n =\n                (\\<Prod>a\\<in>as \\<inter> UNIV \\<times> {n}.\n                   case a of (a, i) \\<Rightarrow> a) *\n                (\\<Sum>a\\<in>as - UNIV \\<times> {0..<Suc n}.\n                   case a of\n                   (a, i) \\<Rightarrow>\n                     (\\<Prod>a\\<in>as - UNIV \\<times> {0..<Suc n} -\n                                   {(a, i)}.\n                        case a of (b, j) \\<Rightarrow> b) *\n                     smult (of_nat (i - n)) (pderiv a));\n        A n =\n        (\\<Prod>a\\<in>as \\<inter> UNIV \\<times> {n}.\n           case a of (a, i) \\<Rightarrow> a)\\<rbrakk>\n       \\<Longrightarrow> C (Suc n) =\n                         (\\<Sum>a\\<in>as - UNIV \\<times> {0..<Suc n}.\n                            case a of\n                            (a, i) \\<Rightarrow>\n                              (\\<Prod>a\n\\<in>as - UNIV \\<times> {0..<Suc n} - {(a, i)}.\n                                 case a of (b, j) \\<Rightarrow> b) *\n                              smult (of_nat (Suc i - Suc n)) (pderiv a))\n 4. \\<And>n.\n       \\<lbrakk>C n =\n                (\\<Sum>a\\<in>as - UNIV \\<times> {0..<n}.\n                   case a of\n                   (a, i) \\<Rightarrow>\n                     (\\<Prod>a\\<in>as - UNIV \\<times> {0..<n} - {(a, i)}.\n                        case a of (b, j) \\<Rightarrow> b) *\n                     smult (of_nat (Suc i - n)) (pderiv a));\n        B n =\n        (\\<Prod>a\\<in>as - UNIV \\<times> {0..<n}.\n           case a of (a, i) \\<Rightarrow> a)\\<rbrakk>\n       \\<Longrightarrow> D n =\n                         (\\<Prod>a\\<in>as \\<inter> UNIV \\<times> {n}.\n                            case a of (a, i) \\<Rightarrow> a) *\n                         (\\<Sum>a\\<in>as - UNIV \\<times> {0..<Suc n}.\n                            case a of\n                            (a, i) \\<Rightarrow>\n                              (\\<Prod>a\n\\<in>as - UNIV \\<times> {0..<Suc n} - {(a, i)}.\n                                 case a of (b, j) \\<Rightarrow> b) *\n                              smult (of_nat (i - n)) (pderiv a))", "case (3 n)"], ["proof (state)\nthis:\n  B n =\n  (\\<Prod>a\\<in>as - UNIV \\<times> {0..<n}.\n     case a of (a, i) \\<Rightarrow> a)\n  A n =\n  (\\<Prod>a\\<in>as \\<inter> UNIV \\<times> {n}.\n     case a of (a, i) \\<Rightarrow> a)\n\ngoal (4 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>B n =\n                (\\<Prod>a\\<in>as - UNIV \\<times> {0..<n}.\n                   case a of (a, i) \\<Rightarrow> a);\n        A n =\n        (\\<Prod>a\\<in>as \\<inter> UNIV \\<times> {n}.\n           case a of (a, i) \\<Rightarrow> a)\\<rbrakk>\n       \\<Longrightarrow> B (Suc n) =\n                         (\\<Prod>a\\<in>as - UNIV \\<times> {0..<Suc n}.\n                            case a of (a, i) \\<Rightarrow> a)\n 2. C 0 =\n    (\\<Sum>a\\<in>as - UNIV \\<times> {0..<0}.\n       case a of\n       (a, i) \\<Rightarrow>\n         (\\<Prod>a\\<in>as - UNIV \\<times> {0..<0} - {(a, i)}.\n            case a of (b, j) \\<Rightarrow> b) *\n         smult (of_nat (Suc i - 0)) (pderiv a))\n 3. \\<And>n.\n       \\<lbrakk>D n =\n                (\\<Prod>a\\<in>as \\<inter> UNIV \\<times> {n}.\n                   case a of (a, i) \\<Rightarrow> a) *\n                (\\<Sum>a\\<in>as - UNIV \\<times> {0..<Suc n}.\n                   case a of\n                   (a, i) \\<Rightarrow>\n                     (\\<Prod>a\\<in>as - UNIV \\<times> {0..<Suc n} -\n                                   {(a, i)}.\n                        case a of (b, j) \\<Rightarrow> b) *\n                     smult (of_nat (i - n)) (pderiv a));\n        A n =\n        (\\<Prod>a\\<in>as \\<inter> UNIV \\<times> {n}.\n           case a of (a, i) \\<Rightarrow> a)\\<rbrakk>\n       \\<Longrightarrow> C (Suc n) =\n                         (\\<Sum>a\\<in>as - UNIV \\<times> {0..<Suc n}.\n                            case a of\n                            (a, i) \\<Rightarrow>\n                              (\\<Prod>a\n\\<in>as - UNIV \\<times> {0..<Suc n} - {(a, i)}.\n                                 case a of (b, j) \\<Rightarrow> b) *\n                              smult (of_nat (Suc i - Suc n)) (pderiv a))\n 4. \\<And>n.\n       \\<lbrakk>C n =\n                (\\<Sum>a\\<in>as - UNIV \\<times> {0..<n}.\n                   case a of\n                   (a, i) \\<Rightarrow>\n                     (\\<Prod>a\\<in>as - UNIV \\<times> {0..<n} - {(a, i)}.\n                        case a of (b, j) \\<Rightarrow> b) *\n                     smult (of_nat (Suc i - n)) (pderiv a));\n        B n =\n        (\\<Prod>a\\<in>as - UNIV \\<times> {0..<n}.\n           case a of (a, i) \\<Rightarrow> a)\\<rbrakk>\n       \\<Longrightarrow> D n =\n                         (\\<Prod>a\\<in>as \\<inter> UNIV \\<times> {n}.\n                            case a of (a, i) \\<Rightarrow> a) *\n                         (\\<Sum>a\\<in>as - UNIV \\<times> {0..<Suc n}.\n                            case a of\n                            (a, i) \\<Rightarrow>\n                              (\\<Prod>a\n\\<in>as - UNIV \\<times> {0..<Suc n} - {(a, i)}.\n                                 case a of (b, j) \\<Rightarrow> b) *\n                              smult (of_nat (i - n)) (pderiv a))", "(* B n *)"], ["proof (state)\nthis:\n  B n =\n  (\\<Prod>a\\<in>as - UNIV \\<times> {0..<n}.\n     case a of (a, i) \\<Rightarrow> a)\n  A n =\n  (\\<Prod>a\\<in>as \\<inter> UNIV \\<times> {n}.\n     case a of (a, i) \\<Rightarrow> a)\n\ngoal (4 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>B n =\n                (\\<Prod>a\\<in>as - UNIV \\<times> {0..<n}.\n                   case a of (a, i) \\<Rightarrow> a);\n        A n =\n        (\\<Prod>a\\<in>as \\<inter> UNIV \\<times> {n}.\n           case a of (a, i) \\<Rightarrow> a)\\<rbrakk>\n       \\<Longrightarrow> B (Suc n) =\n                         (\\<Prod>a\\<in>as - UNIV \\<times> {0..<Suc n}.\n                            case a of (a, i) \\<Rightarrow> a)\n 2. C 0 =\n    (\\<Sum>a\\<in>as - UNIV \\<times> {0..<0}.\n       case a of\n       (a, i) \\<Rightarrow>\n         (\\<Prod>a\\<in>as - UNIV \\<times> {0..<0} - {(a, i)}.\n            case a of (b, j) \\<Rightarrow> b) *\n         smult (of_nat (Suc i - 0)) (pderiv a))\n 3. \\<And>n.\n       \\<lbrakk>D n =\n                (\\<Prod>a\\<in>as \\<inter> UNIV \\<times> {n}.\n                   case a of (a, i) \\<Rightarrow> a) *\n                (\\<Sum>a\\<in>as - UNIV \\<times> {0..<Suc n}.\n                   case a of\n                   (a, i) \\<Rightarrow>\n                     (\\<Prod>a\\<in>as - UNIV \\<times> {0..<Suc n} -\n                                   {(a, i)}.\n                        case a of (b, j) \\<Rightarrow> b) *\n                     smult (of_nat (i - n)) (pderiv a));\n        A n =\n        (\\<Prod>a\\<in>as \\<inter> UNIV \\<times> {n}.\n           case a of (a, i) \\<Rightarrow> a)\\<rbrakk>\n       \\<Longrightarrow> C (Suc n) =\n                         (\\<Sum>a\\<in>as - UNIV \\<times> {0..<Suc n}.\n                            case a of\n                            (a, i) \\<Rightarrow>\n                              (\\<Prod>a\n\\<in>as - UNIV \\<times> {0..<Suc n} - {(a, i)}.\n                                 case a of (b, j) \\<Rightarrow> b) *\n                              smult (of_nat (Suc i - Suc n)) (pderiv a))\n 4. \\<And>n.\n       \\<lbrakk>C n =\n                (\\<Sum>a\\<in>as - UNIV \\<times> {0..<n}.\n                   case a of\n                   (a, i) \\<Rightarrow>\n                     (\\<Prod>a\\<in>as - UNIV \\<times> {0..<n} - {(a, i)}.\n                        case a of (b, j) \\<Rightarrow> b) *\n                     smult (of_nat (Suc i - n)) (pderiv a));\n        B n =\n        (\\<Prod>a\\<in>as - UNIV \\<times> {0..<n}.\n           case a of (a, i) \\<Rightarrow> a)\\<rbrakk>\n       \\<Longrightarrow> D n =\n                         (\\<Prod>a\\<in>as \\<inter> UNIV \\<times> {n}.\n                            case a of (a, i) \\<Rightarrow> a) *\n                         (\\<Sum>a\\<in>as - UNIV \\<times> {0..<Suc n}.\n                            case a of\n                            (a, i) \\<Rightarrow>\n                              (\\<Prod>a\n\\<in>as - UNIV \\<times> {0..<Suc n} - {(a, i)}.\n                                 case a of (b, j) \\<Rightarrow> b) *\n                              smult (of_nat (i - n)) (pderiv a))", "have id: \"(\\<Prod>(a, i)\\<in>as - UNIV \\<times> {0..< n}. a) = (\\<Prod>(a, i)\\<in>as - UNIV \\<times> {0..<Suc n}. a) * (\\<Prod>(a, i)\\<in>as \\<inter> UNIV \\<times> {n}. a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>(a, i)\\<in>as - UNIV \\<times> {0..<n}. a) =\n    (\\<Prod>(a, i)\\<in>as - UNIV \\<times> {0..<Suc n}. a) *\n    (\\<Prod>(a, i)\\<in>as \\<inter> UNIV \\<times> {n}. a)", "by (subst prod.union_disjoint[symmetric], auto, insert fin, auto intro: prod.cong)"], ["proof (state)\nthis:\n  (\\<Prod>(a, i)\\<in>as - UNIV \\<times> {0..<n}. a) =\n  (\\<Prod>(a, i)\\<in>as - UNIV \\<times> {0..<Suc n}. a) *\n  (\\<Prod>(a, i)\\<in>as \\<inter> UNIV \\<times> {n}. a)\n\ngoal (4 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>B n =\n                (\\<Prod>a\\<in>as - UNIV \\<times> {0..<n}.\n                   case a of (a, i) \\<Rightarrow> a);\n        A n =\n        (\\<Prod>a\\<in>as \\<inter> UNIV \\<times> {n}.\n           case a of (a, i) \\<Rightarrow> a)\\<rbrakk>\n       \\<Longrightarrow> B (Suc n) =\n                         (\\<Prod>a\\<in>as - UNIV \\<times> {0..<Suc n}.\n                            case a of (a, i) \\<Rightarrow> a)\n 2. C 0 =\n    (\\<Sum>a\\<in>as - UNIV \\<times> {0..<0}.\n       case a of\n       (a, i) \\<Rightarrow>\n         (\\<Prod>a\\<in>as - UNIV \\<times> {0..<0} - {(a, i)}.\n            case a of (b, j) \\<Rightarrow> b) *\n         smult (of_nat (Suc i - 0)) (pderiv a))\n 3. \\<And>n.\n       \\<lbrakk>D n =\n                (\\<Prod>a\\<in>as \\<inter> UNIV \\<times> {n}.\n                   case a of (a, i) \\<Rightarrow> a) *\n                (\\<Sum>a\\<in>as - UNIV \\<times> {0..<Suc n}.\n                   case a of\n                   (a, i) \\<Rightarrow>\n                     (\\<Prod>a\\<in>as - UNIV \\<times> {0..<Suc n} -\n                                   {(a, i)}.\n                        case a of (b, j) \\<Rightarrow> b) *\n                     smult (of_nat (i - n)) (pderiv a));\n        A n =\n        (\\<Prod>a\\<in>as \\<inter> UNIV \\<times> {n}.\n           case a of (a, i) \\<Rightarrow> a)\\<rbrakk>\n       \\<Longrightarrow> C (Suc n) =\n                         (\\<Sum>a\\<in>as - UNIV \\<times> {0..<Suc n}.\n                            case a of\n                            (a, i) \\<Rightarrow>\n                              (\\<Prod>a\n\\<in>as - UNIV \\<times> {0..<Suc n} - {(a, i)}.\n                                 case a of (b, j) \\<Rightarrow> b) *\n                              smult (of_nat (Suc i - Suc n)) (pderiv a))\n 4. \\<And>n.\n       \\<lbrakk>C n =\n                (\\<Sum>a\\<in>as - UNIV \\<times> {0..<n}.\n                   case a of\n                   (a, i) \\<Rightarrow>\n                     (\\<Prod>a\\<in>as - UNIV \\<times> {0..<n} - {(a, i)}.\n                        case a of (b, j) \\<Rightarrow> b) *\n                     smult (of_nat (Suc i - n)) (pderiv a));\n        B n =\n        (\\<Prod>a\\<in>as - UNIV \\<times> {0..<n}.\n           case a of (a, i) \\<Rightarrow> a)\\<rbrakk>\n       \\<Longrightarrow> D n =\n                         (\\<Prod>a\\<in>as \\<inter> UNIV \\<times> {n}.\n                            case a of (a, i) \\<Rightarrow> a) *\n                         (\\<Sum>a\\<in>as - UNIV \\<times> {0..<Suc n}.\n                            case a of\n                            (a, i) \\<Rightarrow>\n                              (\\<Prod>a\n\\<in>as - UNIV \\<times> {0..<Suc n} - {(a, i)}.\n                                 case a of (b, j) \\<Rightarrow> b) *\n                              smult (of_nat (i - n)) (pderiv a))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. B (Suc n) =\n    (\\<Prod>a\\<in>as - UNIV \\<times> {0..<Suc n}.\n       case a of (a, i) \\<Rightarrow> a)", "unfolding B.simps 3 id"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>(a, i)\\<in>as - UNIV \\<times> {0..<Suc n}. a) *\n    (\\<Prod>(a, i)\\<in>as \\<inter> UNIV \\<times> {n}. a) div\n    (\\<Prod>(a, i)\\<in>as \\<inter> UNIV \\<times> {n}. a) =\n    (\\<Prod>a\\<in>as - UNIV \\<times> {0..<Suc n}.\n       case a of (a, i) \\<Rightarrow> a)", "by (subst nonzero_mult_div_cancel_right[OF nonzero_gen], auto)"], ["proof (state)\nthis:\n  B (Suc n) =\n  (\\<Prod>a\\<in>as - UNIV \\<times> {0..<Suc n}.\n     case a of (a, i) \\<Rightarrow> a)\n\ngoal (3 subgoals):\n 1. C 0 =\n    (\\<Sum>a\\<in>as - UNIV \\<times> {0..<0}.\n       case a of\n       (a, i) \\<Rightarrow>\n         (\\<Prod>a\\<in>as - UNIV \\<times> {0..<0} - {(a, i)}.\n            case a of (b, j) \\<Rightarrow> b) *\n         smult (of_nat (Suc i - 0)) (pderiv a))\n 2. \\<And>n.\n       \\<lbrakk>D n =\n                (\\<Prod>a\\<in>as \\<inter> UNIV \\<times> {n}.\n                   case a of (a, i) \\<Rightarrow> a) *\n                (\\<Sum>a\\<in>as - UNIV \\<times> {0..<Suc n}.\n                   case a of\n                   (a, i) \\<Rightarrow>\n                     (\\<Prod>a\\<in>as - UNIV \\<times> {0..<Suc n} -\n                                   {(a, i)}.\n                        case a of (b, j) \\<Rightarrow> b) *\n                     smult (of_nat (i - n)) (pderiv a));\n        A n =\n        (\\<Prod>a\\<in>as \\<inter> UNIV \\<times> {n}.\n           case a of (a, i) \\<Rightarrow> a)\\<rbrakk>\n       \\<Longrightarrow> C (Suc n) =\n                         (\\<Sum>a\\<in>as - UNIV \\<times> {0..<Suc n}.\n                            case a of\n                            (a, i) \\<Rightarrow>\n                              (\\<Prod>a\n\\<in>as - UNIV \\<times> {0..<Suc n} - {(a, i)}.\n                                 case a of (b, j) \\<Rightarrow> b) *\n                              smult (of_nat (Suc i - Suc n)) (pderiv a))\n 3. \\<And>n.\n       \\<lbrakk>C n =\n                (\\<Sum>a\\<in>as - UNIV \\<times> {0..<n}.\n                   case a of\n                   (a, i) \\<Rightarrow>\n                     (\\<Prod>a\\<in>as - UNIV \\<times> {0..<n} - {(a, i)}.\n                        case a of (b, j) \\<Rightarrow> b) *\n                     smult (of_nat (Suc i - n)) (pderiv a));\n        B n =\n        (\\<Prod>a\\<in>as - UNIV \\<times> {0..<n}.\n           case a of (a, i) \\<Rightarrow> a)\\<rbrakk>\n       \\<Longrightarrow> D n =\n                         (\\<Prod>a\\<in>as \\<inter> UNIV \\<times> {n}.\n                            case a of (a, i) \\<Rightarrow> a) *\n                         (\\<Sum>a\\<in>as - UNIV \\<times> {0..<Suc n}.\n                            case a of\n                            (a, i) \\<Rightarrow>\n                              (\\<Prod>a\n\\<in>as - UNIV \\<times> {0..<Suc n} - {(a, i)}.\n                                 case a of (b, j) \\<Rightarrow> b) *\n                              smult (of_nat (i - n)) (pderiv a))", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. C 0 =\n    (\\<Sum>a\\<in>as - UNIV \\<times> {0..<0}.\n       case a of\n       (a, i) \\<Rightarrow>\n         (\\<Prod>a\\<in>as - UNIV \\<times> {0..<0} - {(a, i)}.\n            case a of (b, j) \\<Rightarrow> b) *\n         smult (of_nat (Suc i - 0)) (pderiv a))\n 2. \\<And>n.\n       \\<lbrakk>D n =\n                (\\<Prod>a\\<in>as \\<inter> UNIV \\<times> {n}.\n                   case a of (a, i) \\<Rightarrow> a) *\n                (\\<Sum>a\\<in>as - UNIV \\<times> {0..<Suc n}.\n                   case a of\n                   (a, i) \\<Rightarrow>\n                     (\\<Prod>a\\<in>as - UNIV \\<times> {0..<Suc n} -\n                                   {(a, i)}.\n                        case a of (b, j) \\<Rightarrow> b) *\n                     smult (of_nat (i - n)) (pderiv a));\n        A n =\n        (\\<Prod>a\\<in>as \\<inter> UNIV \\<times> {n}.\n           case a of (a, i) \\<Rightarrow> a)\\<rbrakk>\n       \\<Longrightarrow> C (Suc n) =\n                         (\\<Sum>a\\<in>as - UNIV \\<times> {0..<Suc n}.\n                            case a of\n                            (a, i) \\<Rightarrow>\n                              (\\<Prod>a\n\\<in>as - UNIV \\<times> {0..<Suc n} - {(a, i)}.\n                                 case a of (b, j) \\<Rightarrow> b) *\n                              smult (of_nat (Suc i - Suc n)) (pderiv a))\n 3. \\<And>n.\n       \\<lbrakk>C n =\n                (\\<Sum>a\\<in>as - UNIV \\<times> {0..<n}.\n                   case a of\n                   (a, i) \\<Rightarrow>\n                     (\\<Prod>a\\<in>as - UNIV \\<times> {0..<n} - {(a, i)}.\n                        case a of (b, j) \\<Rightarrow> b) *\n                     smult (of_nat (Suc i - n)) (pderiv a));\n        B n =\n        (\\<Prod>a\\<in>as - UNIV \\<times> {0..<n}.\n           case a of (a, i) \\<Rightarrow> a)\\<rbrakk>\n       \\<Longrightarrow> D n =\n                         (\\<Prod>a\\<in>as \\<inter> UNIV \\<times> {n}.\n                            case a of (a, i) \\<Rightarrow> a) *\n                         (\\<Sum>a\\<in>as - UNIV \\<times> {0..<Suc n}.\n                            case a of\n                            (a, i) \\<Rightarrow>\n                              (\\<Prod>a\n\\<in>as - UNIV \\<times> {0..<Suc n} - {(a, i)}.\n                                 case a of (b, j) \\<Rightarrow> b) *\n                              smult (of_nat (i - n)) (pderiv a))", "case 4"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. C 0 =\n    (\\<Sum>a\\<in>as - UNIV \\<times> {0..<0}.\n       case a of\n       (a, i) \\<Rightarrow>\n         (\\<Prod>a\\<in>as - UNIV \\<times> {0..<0} - {(a, i)}.\n            case a of (b, j) \\<Rightarrow> b) *\n         smult (of_nat (Suc i - 0)) (pderiv a))\n 2. \\<And>n.\n       \\<lbrakk>D n =\n                (\\<Prod>a\\<in>as \\<inter> UNIV \\<times> {n}.\n                   case a of (a, i) \\<Rightarrow> a) *\n                (\\<Sum>a\\<in>as - UNIV \\<times> {0..<Suc n}.\n                   case a of\n                   (a, i) \\<Rightarrow>\n                     (\\<Prod>a\\<in>as - UNIV \\<times> {0..<Suc n} -\n                                   {(a, i)}.\n                        case a of (b, j) \\<Rightarrow> b) *\n                     smult (of_nat (i - n)) (pderiv a));\n        A n =\n        (\\<Prod>a\\<in>as \\<inter> UNIV \\<times> {n}.\n           case a of (a, i) \\<Rightarrow> a)\\<rbrakk>\n       \\<Longrightarrow> C (Suc n) =\n                         (\\<Sum>a\\<in>as - UNIV \\<times> {0..<Suc n}.\n                            case a of\n                            (a, i) \\<Rightarrow>\n                              (\\<Prod>a\n\\<in>as - UNIV \\<times> {0..<Suc n} - {(a, i)}.\n                                 case a of (b, j) \\<Rightarrow> b) *\n                              smult (of_nat (Suc i - Suc n)) (pderiv a))\n 3. \\<And>n.\n       \\<lbrakk>C n =\n                (\\<Sum>a\\<in>as - UNIV \\<times> {0..<n}.\n                   case a of\n                   (a, i) \\<Rightarrow>\n                     (\\<Prod>a\\<in>as - UNIV \\<times> {0..<n} - {(a, i)}.\n                        case a of (b, j) \\<Rightarrow> b) *\n                     smult (of_nat (Suc i - n)) (pderiv a));\n        B n =\n        (\\<Prod>a\\<in>as - UNIV \\<times> {0..<n}.\n           case a of (a, i) \\<Rightarrow> a)\\<rbrakk>\n       \\<Longrightarrow> D n =\n                         (\\<Prod>a\\<in>as \\<inter> UNIV \\<times> {n}.\n                            case a of (a, i) \\<Rightarrow> a) *\n                         (\\<Sum>a\\<in>as - UNIV \\<times> {0..<Suc n}.\n                            case a of\n                            (a, i) \\<Rightarrow>\n                              (\\<Prod>a\n\\<in>as - UNIV \\<times> {0..<Suc n} - {(a, i)}.\n                                 case a of (b, j) \\<Rightarrow> b) *\n                              smult (of_nat (i - n)) (pderiv a))", "(* C 0 *)"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. C 0 =\n    (\\<Sum>a\\<in>as - UNIV \\<times> {0..<0}.\n       case a of\n       (a, i) \\<Rightarrow>\n         (\\<Prod>a\\<in>as - UNIV \\<times> {0..<0} - {(a, i)}.\n            case a of (b, j) \\<Rightarrow> b) *\n         smult (of_nat (Suc i - 0)) (pderiv a))\n 2. \\<And>n.\n       \\<lbrakk>D n =\n                (\\<Prod>a\\<in>as \\<inter> UNIV \\<times> {n}.\n                   case a of (a, i) \\<Rightarrow> a) *\n                (\\<Sum>a\\<in>as - UNIV \\<times> {0..<Suc n}.\n                   case a of\n                   (a, i) \\<Rightarrow>\n                     (\\<Prod>a\\<in>as - UNIV \\<times> {0..<Suc n} -\n                                   {(a, i)}.\n                        case a of (b, j) \\<Rightarrow> b) *\n                     smult (of_nat (i - n)) (pderiv a));\n        A n =\n        (\\<Prod>a\\<in>as \\<inter> UNIV \\<times> {n}.\n           case a of (a, i) \\<Rightarrow> a)\\<rbrakk>\n       \\<Longrightarrow> C (Suc n) =\n                         (\\<Sum>a\\<in>as - UNIV \\<times> {0..<Suc n}.\n                            case a of\n                            (a, i) \\<Rightarrow>\n                              (\\<Prod>a\n\\<in>as - UNIV \\<times> {0..<Suc n} - {(a, i)}.\n                                 case a of (b, j) \\<Rightarrow> b) *\n                              smult (of_nat (Suc i - Suc n)) (pderiv a))\n 3. \\<And>n.\n       \\<lbrakk>C n =\n                (\\<Sum>a\\<in>as - UNIV \\<times> {0..<n}.\n                   case a of\n                   (a, i) \\<Rightarrow>\n                     (\\<Prod>a\\<in>as - UNIV \\<times> {0..<n} - {(a, i)}.\n                        case a of (b, j) \\<Rightarrow> b) *\n                     smult (of_nat (Suc i - n)) (pderiv a));\n        B n =\n        (\\<Prod>a\\<in>as - UNIV \\<times> {0..<n}.\n           case a of (a, i) \\<Rightarrow> a)\\<rbrakk>\n       \\<Longrightarrow> D n =\n                         (\\<Prod>a\\<in>as \\<inter> UNIV \\<times> {n}.\n                            case a of (a, i) \\<Rightarrow> a) *\n                         (\\<Sum>a\\<in>as - UNIV \\<times> {0..<Suc n}.\n                            case a of\n                            (a, i) \\<Rightarrow>\n                              (\\<Prod>a\n\\<in>as - UNIV \\<times> {0..<Suc n} - {(a, i)}.\n                                 case a of (b, j) \\<Rightarrow> b) *\n                              smult (of_nat (i - n)) (pderiv a))", "have as: \"as - UNIV \\<times> {0..<0} = as\" \"\\<And> i. Suc i - 0 = Suc i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. as - UNIV \\<times> {0..<0} = as &&& (\\<And>i. Suc i - 0 = Suc i)", "by auto"], ["proof (state)\nthis:\n  as - UNIV \\<times> {0..<0} = as\n  Suc ?i - 0 = Suc ?i\n\ngoal (3 subgoals):\n 1. C 0 =\n    (\\<Sum>a\\<in>as - UNIV \\<times> {0..<0}.\n       case a of\n       (a, i) \\<Rightarrow>\n         (\\<Prod>a\\<in>as - UNIV \\<times> {0..<0} - {(a, i)}.\n            case a of (b, j) \\<Rightarrow> b) *\n         smult (of_nat (Suc i - 0)) (pderiv a))\n 2. \\<And>n.\n       \\<lbrakk>D n =\n                (\\<Prod>a\\<in>as \\<inter> UNIV \\<times> {n}.\n                   case a of (a, i) \\<Rightarrow> a) *\n                (\\<Sum>a\\<in>as - UNIV \\<times> {0..<Suc n}.\n                   case a of\n                   (a, i) \\<Rightarrow>\n                     (\\<Prod>a\\<in>as - UNIV \\<times> {0..<Suc n} -\n                                   {(a, i)}.\n                        case a of (b, j) \\<Rightarrow> b) *\n                     smult (of_nat (i - n)) (pderiv a));\n        A n =\n        (\\<Prod>a\\<in>as \\<inter> UNIV \\<times> {n}.\n           case a of (a, i) \\<Rightarrow> a)\\<rbrakk>\n       \\<Longrightarrow> C (Suc n) =\n                         (\\<Sum>a\\<in>as - UNIV \\<times> {0..<Suc n}.\n                            case a of\n                            (a, i) \\<Rightarrow>\n                              (\\<Prod>a\n\\<in>as - UNIV \\<times> {0..<Suc n} - {(a, i)}.\n                                 case a of (b, j) \\<Rightarrow> b) *\n                              smult (of_nat (Suc i - Suc n)) (pderiv a))\n 3. \\<And>n.\n       \\<lbrakk>C n =\n                (\\<Sum>a\\<in>as - UNIV \\<times> {0..<n}.\n                   case a of\n                   (a, i) \\<Rightarrow>\n                     (\\<Prod>a\\<in>as - UNIV \\<times> {0..<n} - {(a, i)}.\n                        case a of (b, j) \\<Rightarrow> b) *\n                     smult (of_nat (Suc i - n)) (pderiv a));\n        B n =\n        (\\<Prod>a\\<in>as - UNIV \\<times> {0..<n}.\n           case a of (a, i) \\<Rightarrow> a)\\<rbrakk>\n       \\<Longrightarrow> D n =\n                         (\\<Prod>a\\<in>as \\<inter> UNIV \\<times> {n}.\n                            case a of (a, i) \\<Rightarrow> a) *\n                         (\\<Sum>a\\<in>as - UNIV \\<times> {0..<Suc n}.\n                            case a of\n                            (a, i) \\<Rightarrow>\n                              (\\<Prod>a\n\\<in>as - UNIV \\<times> {0..<Suc n} - {(a, i)}.\n                                 case a of (b, j) \\<Rightarrow> b) *\n                              smult (of_nat (i - n)) (pderiv a))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. C 0 =\n    (\\<Sum>a\\<in>as - UNIV \\<times> {0..<0}.\n       case a of\n       (a, i) \\<Rightarrow>\n         (\\<Prod>a\\<in>as - UNIV \\<times> {0..<0} - {(a, i)}.\n            case a of (b, j) \\<Rightarrow> b) *\n         smult (of_nat (Suc i - 0)) (pderiv a))", "unfolding C.simps pderiv_exp_gcd"], ["proof (prove)\ngoal (1 subgoal):\n 1. pderiv p div (\\<Prod>(x, y)\\<in>as. x ^ y) =\n    (\\<Sum>a\\<in>as - UNIV \\<times> {0..<0}.\n       case a of\n       (a, i) \\<Rightarrow>\n         (\\<Prod>a\\<in>as - UNIV \\<times> {0..<0} - {(a, i)}.\n            case a of (b, j) \\<Rightarrow> b) *\n         smult (of_nat (Suc i - 0)) (pderiv a))", "unfolding pderiv_exp_prod as"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>(x, y)\\<in>as. x ^ y) *\n    (\\<Sum>(a, i)\\<in>as.\n       (\\<Prod>(b, j)\\<in>as - {(a, i)}. b) *\n       smult (of_nat (Suc i)) (pderiv a)) div\n    (\\<Prod>(x, y)\\<in>as. x ^ y) =\n    (\\<Sum>a\\<in>as.\n       case a of\n       (a, i) \\<Rightarrow>\n         (\\<Prod>a\\<in>as - {(a, i)}. case a of (b, j) \\<Rightarrow> b) *\n         smult (of_nat (Suc i)) (pderiv a))", "by (rule nonzero_mult_div_cancel_left, insert monic_Prod, auto)"], ["proof (state)\nthis:\n  C 0 =\n  (\\<Sum>a\\<in>as - UNIV \\<times> {0..<0}.\n     case a of\n     (a, i) \\<Rightarrow>\n       (\\<Prod>a\\<in>as - UNIV \\<times> {0..<0} - {(a, i)}.\n          case a of (b, j) \\<Rightarrow> b) *\n       smult (of_nat (Suc i - 0)) (pderiv a))\n\ngoal (2 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>D n =\n                (\\<Prod>a\\<in>as \\<inter> UNIV \\<times> {n}.\n                   case a of (a, i) \\<Rightarrow> a) *\n                (\\<Sum>a\\<in>as - UNIV \\<times> {0..<Suc n}.\n                   case a of\n                   (a, i) \\<Rightarrow>\n                     (\\<Prod>a\\<in>as - UNIV \\<times> {0..<Suc n} -\n                                   {(a, i)}.\n                        case a of (b, j) \\<Rightarrow> b) *\n                     smult (of_nat (i - n)) (pderiv a));\n        A n =\n        (\\<Prod>a\\<in>as \\<inter> UNIV \\<times> {n}.\n           case a of (a, i) \\<Rightarrow> a)\\<rbrakk>\n       \\<Longrightarrow> C (Suc n) =\n                         (\\<Sum>a\\<in>as - UNIV \\<times> {0..<Suc n}.\n                            case a of\n                            (a, i) \\<Rightarrow>\n                              (\\<Prod>a\n\\<in>as - UNIV \\<times> {0..<Suc n} - {(a, i)}.\n                                 case a of (b, j) \\<Rightarrow> b) *\n                              smult (of_nat (Suc i - Suc n)) (pderiv a))\n 2. \\<And>n.\n       \\<lbrakk>C n =\n                (\\<Sum>a\\<in>as - UNIV \\<times> {0..<n}.\n                   case a of\n                   (a, i) \\<Rightarrow>\n                     (\\<Prod>a\\<in>as - UNIV \\<times> {0..<n} - {(a, i)}.\n                        case a of (b, j) \\<Rightarrow> b) *\n                     smult (of_nat (Suc i - n)) (pderiv a));\n        B n =\n        (\\<Prod>a\\<in>as - UNIV \\<times> {0..<n}.\n           case a of (a, i) \\<Rightarrow> a)\\<rbrakk>\n       \\<Longrightarrow> D n =\n                         (\\<Prod>a\\<in>as \\<inter> UNIV \\<times> {n}.\n                            case a of (a, i) \\<Rightarrow> a) *\n                         (\\<Sum>a\\<in>as - UNIV \\<times> {0..<Suc n}.\n                            case a of\n                            (a, i) \\<Rightarrow>\n                              (\\<Prod>a\n\\<in>as - UNIV \\<times> {0..<Suc n} - {(a, i)}.\n                                 case a of (b, j) \\<Rightarrow> b) *\n                              smult (of_nat (i - n)) (pderiv a))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>D n =\n                (\\<Prod>a\\<in>as \\<inter> UNIV \\<times> {n}.\n                   case a of (a, i) \\<Rightarrow> a) *\n                (\\<Sum>a\\<in>as - UNIV \\<times> {0..<Suc n}.\n                   case a of\n                   (a, i) \\<Rightarrow>\n                     (\\<Prod>a\\<in>as - UNIV \\<times> {0..<Suc n} -\n                                   {(a, i)}.\n                        case a of (b, j) \\<Rightarrow> b) *\n                     smult (of_nat (i - n)) (pderiv a));\n        A n =\n        (\\<Prod>a\\<in>as \\<inter> UNIV \\<times> {n}.\n           case a of (a, i) \\<Rightarrow> a)\\<rbrakk>\n       \\<Longrightarrow> C (Suc n) =\n                         (\\<Sum>a\\<in>as - UNIV \\<times> {0..<Suc n}.\n                            case a of\n                            (a, i) \\<Rightarrow>\n                              (\\<Prod>a\n\\<in>as - UNIV \\<times> {0..<Suc n} - {(a, i)}.\n                                 case a of (b, j) \\<Rightarrow> b) *\n                              smult (of_nat (Suc i - Suc n)) (pderiv a))\n 2. \\<And>n.\n       \\<lbrakk>C n =\n                (\\<Sum>a\\<in>as - UNIV \\<times> {0..<n}.\n                   case a of\n                   (a, i) \\<Rightarrow>\n                     (\\<Prod>a\\<in>as - UNIV \\<times> {0..<n} - {(a, i)}.\n                        case a of (b, j) \\<Rightarrow> b) *\n                     smult (of_nat (Suc i - n)) (pderiv a));\n        B n =\n        (\\<Prod>a\\<in>as - UNIV \\<times> {0..<n}.\n           case a of (a, i) \\<Rightarrow> a)\\<rbrakk>\n       \\<Longrightarrow> D n =\n                         (\\<Prod>a\\<in>as \\<inter> UNIV \\<times> {n}.\n                            case a of (a, i) \\<Rightarrow> a) *\n                         (\\<Sum>a\\<in>as - UNIV \\<times> {0..<Suc n}.\n                            case a of\n                            (a, i) \\<Rightarrow>\n                              (\\<Prod>a\n\\<in>as - UNIV \\<times> {0..<Suc n} - {(a, i)}.\n                                 case a of (b, j) \\<Rightarrow> b) *\n                              smult (of_nat (i - n)) (pderiv a))", "case (5 n)"], ["proof (state)\nthis:\n  D n =\n  (\\<Prod>a\\<in>as \\<inter> UNIV \\<times> {n}.\n     case a of (a, i) \\<Rightarrow> a) *\n  (\\<Sum>a\\<in>as - UNIV \\<times> {0..<Suc n}.\n     case a of\n     (a, i) \\<Rightarrow>\n       (\\<Prod>a\\<in>as - UNIV \\<times> {0..<Suc n} - {(a, i)}.\n          case a of (b, j) \\<Rightarrow> b) *\n       smult (of_nat (i - n)) (pderiv a))\n  A n =\n  (\\<Prod>a\\<in>as \\<inter> UNIV \\<times> {n}.\n     case a of (a, i) \\<Rightarrow> a)\n\ngoal (2 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>D n =\n                (\\<Prod>a\\<in>as \\<inter> UNIV \\<times> {n}.\n                   case a of (a, i) \\<Rightarrow> a) *\n                (\\<Sum>a\\<in>as - UNIV \\<times> {0..<Suc n}.\n                   case a of\n                   (a, i) \\<Rightarrow>\n                     (\\<Prod>a\\<in>as - UNIV \\<times> {0..<Suc n} -\n                                   {(a, i)}.\n                        case a of (b, j) \\<Rightarrow> b) *\n                     smult (of_nat (i - n)) (pderiv a));\n        A n =\n        (\\<Prod>a\\<in>as \\<inter> UNIV \\<times> {n}.\n           case a of (a, i) \\<Rightarrow> a)\\<rbrakk>\n       \\<Longrightarrow> C (Suc n) =\n                         (\\<Sum>a\\<in>as - UNIV \\<times> {0..<Suc n}.\n                            case a of\n                            (a, i) \\<Rightarrow>\n                              (\\<Prod>a\n\\<in>as - UNIV \\<times> {0..<Suc n} - {(a, i)}.\n                                 case a of (b, j) \\<Rightarrow> b) *\n                              smult (of_nat (Suc i - Suc n)) (pderiv a))\n 2. \\<And>n.\n       \\<lbrakk>C n =\n                (\\<Sum>a\\<in>as - UNIV \\<times> {0..<n}.\n                   case a of\n                   (a, i) \\<Rightarrow>\n                     (\\<Prod>a\\<in>as - UNIV \\<times> {0..<n} - {(a, i)}.\n                        case a of (b, j) \\<Rightarrow> b) *\n                     smult (of_nat (Suc i - n)) (pderiv a));\n        B n =\n        (\\<Prod>a\\<in>as - UNIV \\<times> {0..<n}.\n           case a of (a, i) \\<Rightarrow> a)\\<rbrakk>\n       \\<Longrightarrow> D n =\n                         (\\<Prod>a\\<in>as \\<inter> UNIV \\<times> {n}.\n                            case a of (a, i) \\<Rightarrow> a) *\n                         (\\<Sum>a\\<in>as - UNIV \\<times> {0..<Suc n}.\n                            case a of\n                            (a, i) \\<Rightarrow>\n                              (\\<Prod>a\n\\<in>as - UNIV \\<times> {0..<Suc n} - {(a, i)}.\n                                 case a of (b, j) \\<Rightarrow> b) *\n                              smult (of_nat (i - n)) (pderiv a))", "(* C n *)"], ["proof (state)\nthis:\n  D n =\n  (\\<Prod>a\\<in>as \\<inter> UNIV \\<times> {n}.\n     case a of (a, i) \\<Rightarrow> a) *\n  (\\<Sum>a\\<in>as - UNIV \\<times> {0..<Suc n}.\n     case a of\n     (a, i) \\<Rightarrow>\n       (\\<Prod>a\\<in>as - UNIV \\<times> {0..<Suc n} - {(a, i)}.\n          case a of (b, j) \\<Rightarrow> b) *\n       smult (of_nat (i - n)) (pderiv a))\n  A n =\n  (\\<Prod>a\\<in>as \\<inter> UNIV \\<times> {n}.\n     case a of (a, i) \\<Rightarrow> a)\n\ngoal (2 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>D n =\n                (\\<Prod>a\\<in>as \\<inter> UNIV \\<times> {n}.\n                   case a of (a, i) \\<Rightarrow> a) *\n                (\\<Sum>a\\<in>as - UNIV \\<times> {0..<Suc n}.\n                   case a of\n                   (a, i) \\<Rightarrow>\n                     (\\<Prod>a\\<in>as - UNIV \\<times> {0..<Suc n} -\n                                   {(a, i)}.\n                        case a of (b, j) \\<Rightarrow> b) *\n                     smult (of_nat (i - n)) (pderiv a));\n        A n =\n        (\\<Prod>a\\<in>as \\<inter> UNIV \\<times> {n}.\n           case a of (a, i) \\<Rightarrow> a)\\<rbrakk>\n       \\<Longrightarrow> C (Suc n) =\n                         (\\<Sum>a\\<in>as - UNIV \\<times> {0..<Suc n}.\n                            case a of\n                            (a, i) \\<Rightarrow>\n                              (\\<Prod>a\n\\<in>as - UNIV \\<times> {0..<Suc n} - {(a, i)}.\n                                 case a of (b, j) \\<Rightarrow> b) *\n                              smult (of_nat (Suc i - Suc n)) (pderiv a))\n 2. \\<And>n.\n       \\<lbrakk>C n =\n                (\\<Sum>a\\<in>as - UNIV \\<times> {0..<n}.\n                   case a of\n                   (a, i) \\<Rightarrow>\n                     (\\<Prod>a\\<in>as - UNIV \\<times> {0..<n} - {(a, i)}.\n                        case a of (b, j) \\<Rightarrow> b) *\n                     smult (of_nat (Suc i - n)) (pderiv a));\n        B n =\n        (\\<Prod>a\\<in>as - UNIV \\<times> {0..<n}.\n           case a of (a, i) \\<Rightarrow> a)\\<rbrakk>\n       \\<Longrightarrow> D n =\n                         (\\<Prod>a\\<in>as \\<inter> UNIV \\<times> {n}.\n                            case a of (a, i) \\<Rightarrow> a) *\n                         (\\<Sum>a\\<in>as - UNIV \\<times> {0..<Suc n}.\n                            case a of\n                            (a, i) \\<Rightarrow>\n                              (\\<Prod>a\n\\<in>as - UNIV \\<times> {0..<Suc n} - {(a, i)}.\n                                 case a of (b, j) \\<Rightarrow> b) *\n                              smult (of_nat (i - n)) (pderiv a))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. C (Suc n) =\n    (\\<Sum>a\\<in>as - UNIV \\<times> {0..<Suc n}.\n       case a of\n       (a, i) \\<Rightarrow>\n         (\\<Prod>a\\<in>as - UNIV \\<times> {0..<Suc n} - {(a, i)}.\n            case a of (b, j) \\<Rightarrow> b) *\n         smult (of_nat (Suc i - Suc n)) (pderiv a))", "unfolding C.simps 5"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>(a, i)\\<in>as \\<inter> UNIV \\<times> {n}. a) *\n    (\\<Sum>(a, i)\\<in>as - UNIV \\<times> {0..<Suc n}.\n       (\\<Prod>(b, j)\\<in>as - UNIV \\<times> {0..<Suc n} - {(a, i)}. b) *\n       smult (of_nat (i - n)) (pderiv a)) div\n    (\\<Prod>(a, i)\\<in>as \\<inter> UNIV \\<times> {n}. a) =\n    (\\<Sum>a\\<in>as - UNIV \\<times> {0..<Suc n}.\n       case a of\n       (a, i) \\<Rightarrow>\n         (\\<Prod>a\\<in>as - UNIV \\<times> {0..<Suc n} - {(a, i)}.\n            case a of (b, j) \\<Rightarrow> b) *\n         smult (of_nat (Suc i - Suc n)) (pderiv a))", "by (subst nonzero_mult_div_cancel_left, rule nonzero_gen, auto)"], ["proof (state)\nthis:\n  C (Suc n) =\n  (\\<Sum>a\\<in>as - UNIV \\<times> {0..<Suc n}.\n     case a of\n     (a, i) \\<Rightarrow>\n       (\\<Prod>a\\<in>as - UNIV \\<times> {0..<Suc n} - {(a, i)}.\n          case a of (b, j) \\<Rightarrow> b) *\n       smult (of_nat (Suc i - Suc n)) (pderiv a))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>C n =\n                (\\<Sum>a\\<in>as - UNIV \\<times> {0..<n}.\n                   case a of\n                   (a, i) \\<Rightarrow>\n                     (\\<Prod>a\\<in>as - UNIV \\<times> {0..<n} - {(a, i)}.\n                        case a of (b, j) \\<Rightarrow> b) *\n                     smult (of_nat (Suc i - n)) (pderiv a));\n        B n =\n        (\\<Prod>a\\<in>as - UNIV \\<times> {0..<n}.\n           case a of (a, i) \\<Rightarrow> a)\\<rbrakk>\n       \\<Longrightarrow> D n =\n                         (\\<Prod>a\\<in>as \\<inter> UNIV \\<times> {n}.\n                            case a of (a, i) \\<Rightarrow> a) *\n                         (\\<Sum>a\\<in>as - UNIV \\<times> {0..<Suc n}.\n                            case a of\n                            (a, i) \\<Rightarrow>\n                              (\\<Prod>a\n\\<in>as - UNIV \\<times> {0..<Suc n} - {(a, i)}.\n                                 case a of (b, j) \\<Rightarrow> b) *\n                              smult (of_nat (i - n)) (pderiv a))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>C n =\n                (\\<Sum>a\\<in>as - UNIV \\<times> {0..<n}.\n                   case a of\n                   (a, i) \\<Rightarrow>\n                     (\\<Prod>a\\<in>as - UNIV \\<times> {0..<n} - {(a, i)}.\n                        case a of (b, j) \\<Rightarrow> b) *\n                     smult (of_nat (Suc i - n)) (pderiv a));\n        B n =\n        (\\<Prod>a\\<in>as - UNIV \\<times> {0..<n}.\n           case a of (a, i) \\<Rightarrow> a)\\<rbrakk>\n       \\<Longrightarrow> D n =\n                         (\\<Prod>a\\<in>as \\<inter> UNIV \\<times> {n}.\n                            case a of (a, i) \\<Rightarrow> a) *\n                         (\\<Sum>a\\<in>as - UNIV \\<times> {0..<Suc n}.\n                            case a of\n                            (a, i) \\<Rightarrow>\n                              (\\<Prod>a\n\\<in>as - UNIV \\<times> {0..<Suc n} - {(a, i)}.\n                                 case a of (b, j) \\<Rightarrow> b) *\n                              smult (of_nat (i - n)) (pderiv a))", "case (6 n)"], ["proof (state)\nthis:\n  C n =\n  (\\<Sum>a\\<in>as - UNIV \\<times> {0..<n}.\n     case a of\n     (a, i) \\<Rightarrow>\n       (\\<Prod>a\\<in>as - UNIV \\<times> {0..<n} - {(a, i)}.\n          case a of (b, j) \\<Rightarrow> b) *\n       smult (of_nat (Suc i - n)) (pderiv a))\n  B n =\n  (\\<Prod>a\\<in>as - UNIV \\<times> {0..<n}.\n     case a of (a, i) \\<Rightarrow> a)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>C n =\n                (\\<Sum>a\\<in>as - UNIV \\<times> {0..<n}.\n                   case a of\n                   (a, i) \\<Rightarrow>\n                     (\\<Prod>a\\<in>as - UNIV \\<times> {0..<n} - {(a, i)}.\n                        case a of (b, j) \\<Rightarrow> b) *\n                     smult (of_nat (Suc i - n)) (pderiv a));\n        B n =\n        (\\<Prod>a\\<in>as - UNIV \\<times> {0..<n}.\n           case a of (a, i) \\<Rightarrow> a)\\<rbrakk>\n       \\<Longrightarrow> D n =\n                         (\\<Prod>a\\<in>as \\<inter> UNIV \\<times> {n}.\n                            case a of (a, i) \\<Rightarrow> a) *\n                         (\\<Sum>a\\<in>as - UNIV \\<times> {0..<Suc n}.\n                            case a of\n                            (a, i) \\<Rightarrow>\n                              (\\<Prod>a\n\\<in>as - UNIV \\<times> {0..<Suc n} - {(a, i)}.\n                                 case a of (b, j) \\<Rightarrow> b) *\n                              smult (of_nat (i - n)) (pderiv a))", "(* D n *)"], ["proof (state)\nthis:\n  C n =\n  (\\<Sum>a\\<in>as - UNIV \\<times> {0..<n}.\n     case a of\n     (a, i) \\<Rightarrow>\n       (\\<Prod>a\\<in>as - UNIV \\<times> {0..<n} - {(a, i)}.\n          case a of (b, j) \\<Rightarrow> b) *\n       smult (of_nat (Suc i - n)) (pderiv a))\n  B n =\n  (\\<Prod>a\\<in>as - UNIV \\<times> {0..<n}.\n     case a of (a, i) \\<Rightarrow> a)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>C n =\n                (\\<Sum>a\\<in>as - UNIV \\<times> {0..<n}.\n                   case a of\n                   (a, i) \\<Rightarrow>\n                     (\\<Prod>a\\<in>as - UNIV \\<times> {0..<n} - {(a, i)}.\n                        case a of (b, j) \\<Rightarrow> b) *\n                     smult (of_nat (Suc i - n)) (pderiv a));\n        B n =\n        (\\<Prod>a\\<in>as - UNIV \\<times> {0..<n}.\n           case a of (a, i) \\<Rightarrow> a)\\<rbrakk>\n       \\<Longrightarrow> D n =\n                         (\\<Prod>a\\<in>as \\<inter> UNIV \\<times> {n}.\n                            case a of (a, i) \\<Rightarrow> a) *\n                         (\\<Sum>a\\<in>as - UNIV \\<times> {0..<Suc n}.\n                            case a of\n                            (a, i) \\<Rightarrow>\n                              (\\<Prod>a\n\\<in>as - UNIV \\<times> {0..<Suc n} - {(a, i)}.\n                                 case a of (b, j) \\<Rightarrow> b) *\n                              smult (of_nat (i - n)) (pderiv a))", "let ?f = \"\\<lambda> (a,i). (\\<Prod>(b, j)\\<in>as - UNIV \\<times> {0 ..< n} - {(a, i)}. b) * (smult (of_nat (i - n)) (pderiv a))\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>C n =\n                (\\<Sum>a\\<in>as - UNIV \\<times> {0..<n}.\n                   case a of\n                   (a, i) \\<Rightarrow>\n                     (\\<Prod>a\\<in>as - UNIV \\<times> {0..<n} - {(a, i)}.\n                        case a of (b, j) \\<Rightarrow> b) *\n                     smult (of_nat (Suc i - n)) (pderiv a));\n        B n =\n        (\\<Prod>a\\<in>as - UNIV \\<times> {0..<n}.\n           case a of (a, i) \\<Rightarrow> a)\\<rbrakk>\n       \\<Longrightarrow> D n =\n                         (\\<Prod>a\\<in>as \\<inter> UNIV \\<times> {n}.\n                            case a of (a, i) \\<Rightarrow> a) *\n                         (\\<Sum>a\\<in>as - UNIV \\<times> {0..<Suc n}.\n                            case a of\n                            (a, i) \\<Rightarrow>\n                              (\\<Prod>a\n\\<in>as - UNIV \\<times> {0..<Suc n} - {(a, i)}.\n                                 case a of (b, j) \\<Rightarrow> b) *\n                              smult (of_nat (i - n)) (pderiv a))", "have \"D n = (\\<Sum> (a,i)\\<in>as - UNIV \\<times> {0 ..< n}. (\\<Prod>(b, j)\\<in>as - UNIV \\<times> {0 ..< n} - {(a, i)}. b) * \n    (smult (of_nat (Suc i - n)) (pderiv a) - pderiv a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. D n =\n    (\\<Sum>(a, i)\\<in>as - UNIV \\<times> {0..<n}.\n       (\\<Prod>(b, j)\\<in>as - UNIV \\<times> {0..<n} - {(a, i)}. b) *\n       (smult (of_nat (Suc i - n)) (pderiv a) - pderiv a))", "unfolding D.simps 6 pderiv_prod sum_subtractf[symmetric] right_diff_distrib"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>as - UNIV \\<times> {0..<n}.\n       (case x of\n        (a, i) \\<Rightarrow>\n          (\\<Prod>(b, j)\\<in>as - UNIV \\<times> {0..<n} - {(a, i)}. b) *\n          smult (of_nat (Suc i - n)) (pderiv a)) -\n       (\\<Prod>(a, i)\\<in>as - UNIV \\<times> {0..<n} - {x}. a) *\n       pderiv (case x of (a, i) \\<Rightarrow> a)) =\n    (\\<Sum>(a, i)\\<in>as - UNIV \\<times> {0..<n}.\n       (\\<Prod>(b, j)\\<in>as - UNIV \\<times> {0..<n} - {(a, i)}. b) *\n       smult (of_nat (Suc i - n)) (pderiv a) -\n       (\\<Prod>(b, j)\\<in>as - UNIV \\<times> {0..<n} - {(a, i)}. b) *\n       pderiv a)", "by (rule sum.cong, auto)"], ["proof (state)\nthis:\n  D n =\n  (\\<Sum>(a, i)\\<in>as - UNIV \\<times> {0..<n}.\n     (\\<Prod>(b, j)\\<in>as - UNIV \\<times> {0..<n} - {(a, i)}. b) *\n     (smult (of_nat (Suc i - n)) (pderiv a) - pderiv a))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>C n =\n                (\\<Sum>a\\<in>as - UNIV \\<times> {0..<n}.\n                   case a of\n                   (a, i) \\<Rightarrow>\n                     (\\<Prod>a\\<in>as - UNIV \\<times> {0..<n} - {(a, i)}.\n                        case a of (b, j) \\<Rightarrow> b) *\n                     smult (of_nat (Suc i - n)) (pderiv a));\n        B n =\n        (\\<Prod>a\\<in>as - UNIV \\<times> {0..<n}.\n           case a of (a, i) \\<Rightarrow> a)\\<rbrakk>\n       \\<Longrightarrow> D n =\n                         (\\<Prod>a\\<in>as \\<inter> UNIV \\<times> {n}.\n                            case a of (a, i) \\<Rightarrow> a) *\n                         (\\<Sum>a\\<in>as - UNIV \\<times> {0..<Suc n}.\n                            case a of\n                            (a, i) \\<Rightarrow>\n                              (\\<Prod>a\n\\<in>as - UNIV \\<times> {0..<Suc n} - {(a, i)}.\n                                 case a of (b, j) \\<Rightarrow> b) *\n                              smult (of_nat (i - n)) (pderiv a))", "also"], ["proof (state)\nthis:\n  D n =\n  (\\<Sum>(a, i)\\<in>as - UNIV \\<times> {0..<n}.\n     (\\<Prod>(b, j)\\<in>as - UNIV \\<times> {0..<n} - {(a, i)}. b) *\n     (smult (of_nat (Suc i - n)) (pderiv a) - pderiv a))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>C n =\n                (\\<Sum>a\\<in>as - UNIV \\<times> {0..<n}.\n                   case a of\n                   (a, i) \\<Rightarrow>\n                     (\\<Prod>a\\<in>as - UNIV \\<times> {0..<n} - {(a, i)}.\n                        case a of (b, j) \\<Rightarrow> b) *\n                     smult (of_nat (Suc i - n)) (pderiv a));\n        B n =\n        (\\<Prod>a\\<in>as - UNIV \\<times> {0..<n}.\n           case a of (a, i) \\<Rightarrow> a)\\<rbrakk>\n       \\<Longrightarrow> D n =\n                         (\\<Prod>a\\<in>as \\<inter> UNIV \\<times> {n}.\n                            case a of (a, i) \\<Rightarrow> a) *\n                         (\\<Sum>a\\<in>as - UNIV \\<times> {0..<Suc n}.\n                            case a of\n                            (a, i) \\<Rightarrow>\n                              (\\<Prod>a\n\\<in>as - UNIV \\<times> {0..<Suc n} - {(a, i)}.\n                                 case a of (b, j) \\<Rightarrow> b) *\n                              smult (of_nat (i - n)) (pderiv a))", "have \"\\<dots> = sum ?f (as - UNIV \\<times> {0 ..< n})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(a, i)\\<in>as - UNIV \\<times> {0..<n}.\n       (\\<Prod>(b, j)\\<in>as - UNIV \\<times> {0..<n} - {(a, i)}. b) *\n       (smult (of_nat (Suc i - n)) (pderiv a) - pderiv a)) =\n    (\\<Sum>(a, i)\\<in>as - UNIV \\<times> {0..<n}.\n       (\\<Prod>(b, j)\\<in>as - UNIV \\<times> {0..<n} - {(a, i)}. b) *\n       smult (of_nat (i - n)) (pderiv a))", "proof (rule sum.cong[OF refl])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> as - UNIV \\<times> {0..<n} \\<Longrightarrow>\n       (case x of\n        (a, i) \\<Rightarrow>\n          (\\<Prod>(b, j)\\<in>as - UNIV \\<times> {0..<n} - {(a, i)}. b) *\n          (smult (of_nat (Suc i - n)) (pderiv a) - pderiv a)) =\n       (case x of\n        (a, i) \\<Rightarrow>\n          (\\<Prod>(b, j)\\<in>as - UNIV \\<times> {0..<n} - {(a, i)}. b) *\n          smult (of_nat (i - n)) (pderiv a))", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> as - UNIV \\<times> {0..<n} \\<Longrightarrow>\n       (case x of\n        (a, i) \\<Rightarrow>\n          (\\<Prod>(b, j)\\<in>as - UNIV \\<times> {0..<n} - {(a, i)}. b) *\n          (smult (of_nat (Suc i - n)) (pderiv a) - pderiv a)) =\n       (case x of\n        (a, i) \\<Rightarrow>\n          (\\<Prod>(b, j)\\<in>as - UNIV \\<times> {0..<n} - {(a, i)}. b) *\n          smult (of_nat (i - n)) (pderiv a))", "assume \"x \\<in> as - UNIV \\<times> {0 ..< n}\""], ["proof (state)\nthis:\n  x \\<in> as - UNIV \\<times> {0..<n}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> as - UNIV \\<times> {0..<n} \\<Longrightarrow>\n       (case x of\n        (a, i) \\<Rightarrow>\n          (\\<Prod>(b, j)\\<in>as - UNIV \\<times> {0..<n} - {(a, i)}. b) *\n          (smult (of_nat (Suc i - n)) (pderiv a) - pderiv a)) =\n       (case x of\n        (a, i) \\<Rightarrow>\n          (\\<Prod>(b, j)\\<in>as - UNIV \\<times> {0..<n} - {(a, i)}. b) *\n          smult (of_nat (i - n)) (pderiv a))", "then"], ["proof (chain)\npicking this:\n  x \\<in> as - UNIV \\<times> {0..<n}", "obtain a i where x: \"x = (a,i)\" and i: \"Suc i > n\""], ["proof (prove)\nusing this:\n  x \\<in> as - UNIV \\<times> {0..<n}\n\ngoal (1 subgoal):\n 1. (\\<And>a i.\n        \\<lbrakk>x = (a, i); n < Suc i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases x, auto)"], ["proof (state)\nthis:\n  x = (a, i)\n  n < Suc i\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> as - UNIV \\<times> {0..<n} \\<Longrightarrow>\n       (case x of\n        (a, i) \\<Rightarrow>\n          (\\<Prod>(b, j)\\<in>as - UNIV \\<times> {0..<n} - {(a, i)}. b) *\n          (smult (of_nat (Suc i - n)) (pderiv a) - pderiv a)) =\n       (case x of\n        (a, i) \\<Rightarrow>\n          (\\<Prod>(b, j)\\<in>as - UNIV \\<times> {0..<n} - {(a, i)}. b) *\n          smult (of_nat (i - n)) (pderiv a))", "hence id: \"Suc i - n = Suc (i - n)\""], ["proof (prove)\nusing this:\n  x = (a, i)\n  n < Suc i\n\ngoal (1 subgoal):\n 1. Suc i - n = Suc (i - n)", "by arith"], ["proof (state)\nthis:\n  Suc i - n = Suc (i - n)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> as - UNIV \\<times> {0..<n} \\<Longrightarrow>\n       (case x of\n        (a, i) \\<Rightarrow>\n          (\\<Prod>(b, j)\\<in>as - UNIV \\<times> {0..<n} - {(a, i)}. b) *\n          (smult (of_nat (Suc i - n)) (pderiv a) - pderiv a)) =\n       (case x of\n        (a, i) \\<Rightarrow>\n          (\\<Prod>(b, j)\\<in>as - UNIV \\<times> {0..<n} - {(a, i)}. b) *\n          smult (of_nat (i - n)) (pderiv a))", "have id: \"of_nat (Suc i - n) = of_nat (i - n) + (1 :: 'a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_nat (Suc i - n) = of_nat (i - n) + (1::'a)", "unfolding id"], ["proof (prove)\ngoal (1 subgoal):\n 1. of_nat (Suc (i - n)) = of_nat (i - n) + (1::'a)", "by simp"], ["proof (state)\nthis:\n  of_nat (Suc i - n) = of_nat (i - n) + (1::'a)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> as - UNIV \\<times> {0..<n} \\<Longrightarrow>\n       (case x of\n        (a, i) \\<Rightarrow>\n          (\\<Prod>(b, j)\\<in>as - UNIV \\<times> {0..<n} - {(a, i)}. b) *\n          (smult (of_nat (Suc i - n)) (pderiv a) - pderiv a)) =\n       (case x of\n        (a, i) \\<Rightarrow>\n          (\\<Prod>(b, j)\\<in>as - UNIV \\<times> {0..<n} - {(a, i)}. b) *\n          smult (of_nat (i - n)) (pderiv a))", "have id: \"smult (of_nat (Suc i - n)) (pderiv a) - pderiv a = smult (of_nat (i - n)) (pderiv a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. smult (of_nat (Suc i - n)) (pderiv a) - pderiv a =\n    smult (of_nat (i - n)) (pderiv a)", "unfolding id smult_add_left"], ["proof (prove)\ngoal (1 subgoal):\n 1. smult (of_nat (i - n)) (pderiv a) + smult (1::'a) (pderiv a) -\n    pderiv a =\n    smult (of_nat (i - n)) (pderiv a)", "by auto"], ["proof (state)\nthis:\n  smult (of_nat (Suc i - n)) (pderiv a) - pderiv a =\n  smult (of_nat (i - n)) (pderiv a)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> as - UNIV \\<times> {0..<n} \\<Longrightarrow>\n       (case x of\n        (a, i) \\<Rightarrow>\n          (\\<Prod>(b, j)\\<in>as - UNIV \\<times> {0..<n} - {(a, i)}. b) *\n          (smult (of_nat (Suc i - n)) (pderiv a) - pderiv a)) =\n       (case x of\n        (a, i) \\<Rightarrow>\n          (\\<Prod>(b, j)\\<in>as - UNIV \\<times> {0..<n} - {(a, i)}. b) *\n          smult (of_nat (i - n)) (pderiv a))", "have cong: \"\\<And> x y z :: 'a poly. x = y \\<Longrightarrow> x * z = y * z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y z. x = y \\<Longrightarrow> x * z = y * z", "by auto"], ["proof (state)\nthis:\n  ?x = ?y \\<Longrightarrow> ?x * ?z = ?y * ?z\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> as - UNIV \\<times> {0..<n} \\<Longrightarrow>\n       (case x of\n        (a, i) \\<Rightarrow>\n          (\\<Prod>(b, j)\\<in>as - UNIV \\<times> {0..<n} - {(a, i)}. b) *\n          (smult (of_nat (Suc i - n)) (pderiv a) - pderiv a)) =\n       (case x of\n        (a, i) \\<Rightarrow>\n          (\\<Prod>(b, j)\\<in>as - UNIV \\<times> {0..<n} - {(a, i)}. b) *\n          smult (of_nat (i - n)) (pderiv a))", "show \"(case x of\n          (a, i) \\<Rightarrow>\n            (\\<Prod>(b, j)\\<in>as - UNIV \\<times> {0..<n} - {(a, i)}. b) *\n            (smult (of_nat (Suc i - n)) (pderiv a) - pderiv a)) =\n         (case x of\n          (a, i) \\<Rightarrow> (\\<Prod>(b, j)\\<in>as - UNIV \\<times> {0..<n} - {(a, i)}. b) * smult (of_nat (i - n)) (pderiv a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (case x of\n     (a, i) \\<Rightarrow>\n       (\\<Prod>(b, j)\\<in>as - UNIV \\<times> {0..<n} - {(a, i)}. b) *\n       (smult (of_nat (Suc i - n)) (pderiv a) - pderiv a)) =\n    (case x of\n     (a, i) \\<Rightarrow>\n       (\\<Prod>(b, j)\\<in>as - UNIV \\<times> {0..<n} - {(a, i)}. b) *\n       smult (of_nat (i - n)) (pderiv a))", "unfolding x split id"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>(b, j)\\<in>as - UNIV \\<times> {0..<n} - {(a, i)}. b) *\n    smult (of_nat (i - n)) (pderiv a) =\n    (\\<Prod>(b, j)\\<in>as - UNIV \\<times> {0..<n} - {(a, i)}. b) *\n    smult (of_nat (i - n)) (pderiv a)", "by (rule cong, auto)"], ["proof (state)\nthis:\n  (case x of\n   (a, i) \\<Rightarrow>\n     (\\<Prod>(b, j)\\<in>as - UNIV \\<times> {0..<n} - {(a, i)}. b) *\n     (smult (of_nat (Suc i - n)) (pderiv a) - pderiv a)) =\n  (case x of\n   (a, i) \\<Rightarrow>\n     (\\<Prod>(b, j)\\<in>as - UNIV \\<times> {0..<n} - {(a, i)}. b) *\n     smult (of_nat (i - n)) (pderiv a))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>(a, i)\\<in>as - UNIV \\<times> {0..<n}.\n     (\\<Prod>(b, j)\\<in>as - UNIV \\<times> {0..<n} - {(a, i)}. b) *\n     (smult (of_nat (Suc i - n)) (pderiv a) - pderiv a)) =\n  (\\<Sum>(a, i)\\<in>as - UNIV \\<times> {0..<n}.\n     (\\<Prod>(b, j)\\<in>as - UNIV \\<times> {0..<n} - {(a, i)}. b) *\n     smult (of_nat (i - n)) (pderiv a))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>C n =\n                (\\<Sum>a\\<in>as - UNIV \\<times> {0..<n}.\n                   case a of\n                   (a, i) \\<Rightarrow>\n                     (\\<Prod>a\\<in>as - UNIV \\<times> {0..<n} - {(a, i)}.\n                        case a of (b, j) \\<Rightarrow> b) *\n                     smult (of_nat (Suc i - n)) (pderiv a));\n        B n =\n        (\\<Prod>a\\<in>as - UNIV \\<times> {0..<n}.\n           case a of (a, i) \\<Rightarrow> a)\\<rbrakk>\n       \\<Longrightarrow> D n =\n                         (\\<Prod>a\\<in>as \\<inter> UNIV \\<times> {n}.\n                            case a of (a, i) \\<Rightarrow> a) *\n                         (\\<Sum>a\\<in>as - UNIV \\<times> {0..<Suc n}.\n                            case a of\n                            (a, i) \\<Rightarrow>\n                              (\\<Prod>a\n\\<in>as - UNIV \\<times> {0..<Suc n} - {(a, i)}.\n                                 case a of (b, j) \\<Rightarrow> b) *\n                              smult (of_nat (i - n)) (pderiv a))", "also"], ["proof (state)\nthis:\n  (\\<Sum>(a, i)\\<in>as - UNIV \\<times> {0..<n}.\n     (\\<Prod>(b, j)\\<in>as - UNIV \\<times> {0..<n} - {(a, i)}. b) *\n     (smult (of_nat (Suc i - n)) (pderiv a) - pderiv a)) =\n  (\\<Sum>(a, i)\\<in>as - UNIV \\<times> {0..<n}.\n     (\\<Prod>(b, j)\\<in>as - UNIV \\<times> {0..<n} - {(a, i)}. b) *\n     smult (of_nat (i - n)) (pderiv a))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>C n =\n                (\\<Sum>a\\<in>as - UNIV \\<times> {0..<n}.\n                   case a of\n                   (a, i) \\<Rightarrow>\n                     (\\<Prod>a\\<in>as - UNIV \\<times> {0..<n} - {(a, i)}.\n                        case a of (b, j) \\<Rightarrow> b) *\n                     smult (of_nat (Suc i - n)) (pderiv a));\n        B n =\n        (\\<Prod>a\\<in>as - UNIV \\<times> {0..<n}.\n           case a of (a, i) \\<Rightarrow> a)\\<rbrakk>\n       \\<Longrightarrow> D n =\n                         (\\<Prod>a\\<in>as \\<inter> UNIV \\<times> {n}.\n                            case a of (a, i) \\<Rightarrow> a) *\n                         (\\<Sum>a\\<in>as - UNIV \\<times> {0..<Suc n}.\n                            case a of\n                            (a, i) \\<Rightarrow>\n                              (\\<Prod>a\n\\<in>as - UNIV \\<times> {0..<Suc n} - {(a, i)}.\n                                 case a of (b, j) \\<Rightarrow> b) *\n                              smult (of_nat (i - n)) (pderiv a))", "have \"\\<dots> = sum ?f (as - UNIV \\<times> {0 ..< Suc n}) + sum ?f (as \\<inter> UNIV \\<times> {n})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(a, i)\\<in>as - UNIV \\<times> {0..<n}.\n       (\\<Prod>(b, j)\\<in>as - UNIV \\<times> {0..<n} - {(a, i)}. b) *\n       smult (of_nat (i - n)) (pderiv a)) =\n    (\\<Sum>(a, i)\\<in>as - UNIV \\<times> {0..<Suc n}.\n       (\\<Prod>(b, j)\\<in>as - UNIV \\<times> {0..<n} - {(a, i)}. b) *\n       smult (of_nat (i - n)) (pderiv a)) +\n    (\\<Sum>(a, i)\\<in>as \\<inter> UNIV \\<times> {n}.\n       (\\<Prod>(b, j)\\<in>as - UNIV \\<times> {0..<n} - {(a, i)}. b) *\n       smult (of_nat (i - n)) (pderiv a))", "by (subst sum.union_disjoint[symmetric], insert fin, auto intro: sum.cong)"], ["proof (state)\nthis:\n  (\\<Sum>(a, i)\\<in>as - UNIV \\<times> {0..<n}.\n     (\\<Prod>(b, j)\\<in>as - UNIV \\<times> {0..<n} - {(a, i)}. b) *\n     smult (of_nat (i - n)) (pderiv a)) =\n  (\\<Sum>(a, i)\\<in>as - UNIV \\<times> {0..<Suc n}.\n     (\\<Prod>(b, j)\\<in>as - UNIV \\<times> {0..<n} - {(a, i)}. b) *\n     smult (of_nat (i - n)) (pderiv a)) +\n  (\\<Sum>(a, i)\\<in>as \\<inter> UNIV \\<times> {n}.\n     (\\<Prod>(b, j)\\<in>as - UNIV \\<times> {0..<n} - {(a, i)}. b) *\n     smult (of_nat (i - n)) (pderiv a))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>C n =\n                (\\<Sum>a\\<in>as - UNIV \\<times> {0..<n}.\n                   case a of\n                   (a, i) \\<Rightarrow>\n                     (\\<Prod>a\\<in>as - UNIV \\<times> {0..<n} - {(a, i)}.\n                        case a of (b, j) \\<Rightarrow> b) *\n                     smult (of_nat (Suc i - n)) (pderiv a));\n        B n =\n        (\\<Prod>a\\<in>as - UNIV \\<times> {0..<n}.\n           case a of (a, i) \\<Rightarrow> a)\\<rbrakk>\n       \\<Longrightarrow> D n =\n                         (\\<Prod>a\\<in>as \\<inter> UNIV \\<times> {n}.\n                            case a of (a, i) \\<Rightarrow> a) *\n                         (\\<Sum>a\\<in>as - UNIV \\<times> {0..<Suc n}.\n                            case a of\n                            (a, i) \\<Rightarrow>\n                              (\\<Prod>a\n\\<in>as - UNIV \\<times> {0..<Suc n} - {(a, i)}.\n                                 case a of (b, j) \\<Rightarrow> b) *\n                              smult (of_nat (i - n)) (pderiv a))", "also"], ["proof (state)\nthis:\n  (\\<Sum>(a, i)\\<in>as - UNIV \\<times> {0..<n}.\n     (\\<Prod>(b, j)\\<in>as - UNIV \\<times> {0..<n} - {(a, i)}. b) *\n     smult (of_nat (i - n)) (pderiv a)) =\n  (\\<Sum>(a, i)\\<in>as - UNIV \\<times> {0..<Suc n}.\n     (\\<Prod>(b, j)\\<in>as - UNIV \\<times> {0..<n} - {(a, i)}. b) *\n     smult (of_nat (i - n)) (pderiv a)) +\n  (\\<Sum>(a, i)\\<in>as \\<inter> UNIV \\<times> {n}.\n     (\\<Prod>(b, j)\\<in>as - UNIV \\<times> {0..<n} - {(a, i)}. b) *\n     smult (of_nat (i - n)) (pderiv a))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>C n =\n                (\\<Sum>a\\<in>as - UNIV \\<times> {0..<n}.\n                   case a of\n                   (a, i) \\<Rightarrow>\n                     (\\<Prod>a\\<in>as - UNIV \\<times> {0..<n} - {(a, i)}.\n                        case a of (b, j) \\<Rightarrow> b) *\n                     smult (of_nat (Suc i - n)) (pderiv a));\n        B n =\n        (\\<Prod>a\\<in>as - UNIV \\<times> {0..<n}.\n           case a of (a, i) \\<Rightarrow> a)\\<rbrakk>\n       \\<Longrightarrow> D n =\n                         (\\<Prod>a\\<in>as \\<inter> UNIV \\<times> {n}.\n                            case a of (a, i) \\<Rightarrow> a) *\n                         (\\<Sum>a\\<in>as - UNIV \\<times> {0..<Suc n}.\n                            case a of\n                            (a, i) \\<Rightarrow>\n                              (\\<Prod>a\n\\<in>as - UNIV \\<times> {0..<Suc n} - {(a, i)}.\n                                 case a of (b, j) \\<Rightarrow> b) *\n                              smult (of_nat (i - n)) (pderiv a))", "have \"sum ?f (as \\<inter> UNIV \\<times> {n}) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(a, i)\\<in>as \\<inter> UNIV \\<times> {n}.\n       (\\<Prod>(b, j)\\<in>as - UNIV \\<times> {0..<n} - {(a, i)}. b) *\n       smult (of_nat (i - n)) (pderiv a)) =\n    0", "by (rule sum.neutral, auto)"], ["proof (state)\nthis:\n  (\\<Sum>(a, i)\\<in>as \\<inter> UNIV \\<times> {n}.\n     (\\<Prod>(b, j)\\<in>as - UNIV \\<times> {0..<n} - {(a, i)}. b) *\n     smult (of_nat (i - n)) (pderiv a)) =\n  0\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>C n =\n                (\\<Sum>a\\<in>as - UNIV \\<times> {0..<n}.\n                   case a of\n                   (a, i) \\<Rightarrow>\n                     (\\<Prod>a\\<in>as - UNIV \\<times> {0..<n} - {(a, i)}.\n                        case a of (b, j) \\<Rightarrow> b) *\n                     smult (of_nat (Suc i - n)) (pderiv a));\n        B n =\n        (\\<Prod>a\\<in>as - UNIV \\<times> {0..<n}.\n           case a of (a, i) \\<Rightarrow> a)\\<rbrakk>\n       \\<Longrightarrow> D n =\n                         (\\<Prod>a\\<in>as \\<inter> UNIV \\<times> {n}.\n                            case a of (a, i) \\<Rightarrow> a) *\n                         (\\<Sum>a\\<in>as - UNIV \\<times> {0..<Suc n}.\n                            case a of\n                            (a, i) \\<Rightarrow>\n                              (\\<Prod>a\n\\<in>as - UNIV \\<times> {0..<Suc n} - {(a, i)}.\n                                 case a of (b, j) \\<Rightarrow> b) *\n                              smult (of_nat (i - n)) (pderiv a))", "finally"], ["proof (chain)\npicking this:\n  D n =\n  (\\<Sum>a\\<in>as - UNIV \\<times> {0..<Suc n}.\n     case a of\n     (a, i) \\<Rightarrow>\n       (\\<Prod>a\\<in>as - UNIV \\<times> {0..<n} - {(a, i)}.\n          case a of (b, j) \\<Rightarrow> b) *\n       smult (of_nat (i - n)) (pderiv a)) +\n  0", "have id: \"D n = sum ?f (as - UNIV \\<times> {0 ..< Suc n})\""], ["proof (prove)\nusing this:\n  D n =\n  (\\<Sum>a\\<in>as - UNIV \\<times> {0..<Suc n}.\n     case a of\n     (a, i) \\<Rightarrow>\n       (\\<Prod>a\\<in>as - UNIV \\<times> {0..<n} - {(a, i)}.\n          case a of (b, j) \\<Rightarrow> b) *\n       smult (of_nat (i - n)) (pderiv a)) +\n  0\n\ngoal (1 subgoal):\n 1. D n =\n    (\\<Sum>(a, i)\\<in>as - UNIV \\<times> {0..<Suc n}.\n       (\\<Prod>(b, j)\\<in>as - UNIV \\<times> {0..<n} - {(a, i)}. b) *\n       smult (of_nat (i - n)) (pderiv a))", "by simp"], ["proof (state)\nthis:\n  D n =\n  (\\<Sum>(a, i)\\<in>as - UNIV \\<times> {0..<Suc n}.\n     (\\<Prod>(b, j)\\<in>as - UNIV \\<times> {0..<n} - {(a, i)}. b) *\n     smult (of_nat (i - n)) (pderiv a))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>C n =\n                (\\<Sum>a\\<in>as - UNIV \\<times> {0..<n}.\n                   case a of\n                   (a, i) \\<Rightarrow>\n                     (\\<Prod>a\\<in>as - UNIV \\<times> {0..<n} - {(a, i)}.\n                        case a of (b, j) \\<Rightarrow> b) *\n                     smult (of_nat (Suc i - n)) (pderiv a));\n        B n =\n        (\\<Prod>a\\<in>as - UNIV \\<times> {0..<n}.\n           case a of (a, i) \\<Rightarrow> a)\\<rbrakk>\n       \\<Longrightarrow> D n =\n                         (\\<Prod>a\\<in>as \\<inter> UNIV \\<times> {n}.\n                            case a of (a, i) \\<Rightarrow> a) *\n                         (\\<Sum>a\\<in>as - UNIV \\<times> {0..<Suc n}.\n                            case a of\n                            (a, i) \\<Rightarrow>\n                              (\\<Prod>a\n\\<in>as - UNIV \\<times> {0..<Suc n} - {(a, i)}.\n                                 case a of (b, j) \\<Rightarrow> b) *\n                              smult (of_nat (i - n)) (pderiv a))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. D n =\n    (\\<Prod>a\\<in>as \\<inter> UNIV \\<times> {n}.\n       case a of (a, i) \\<Rightarrow> a) *\n    (\\<Sum>a\\<in>as - UNIV \\<times> {0..<Suc n}.\n       case a of\n       (a, i) \\<Rightarrow>\n         (\\<Prod>a\\<in>as - UNIV \\<times> {0..<Suc n} - {(a, i)}.\n            case a of (b, j) \\<Rightarrow> b) *\n         smult (of_nat (i - n)) (pderiv a))", "unfolding id sum_distrib_left"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(a, i)\\<in>as - UNIV \\<times> {0..<Suc n}.\n       (\\<Prod>(b, j)\\<in>as - UNIV \\<times> {0..<n} - {(a, i)}. b) *\n       smult (of_nat (i - n)) (pderiv a)) =\n    (\\<Sum>n\\<in>as - UNIV \\<times> {0..<Suc n}.\n       (\\<Prod>(a, i)\\<in>as \\<inter> UNIV \\<times> {n}. a) *\n       (case n of\n        (a, i) \\<Rightarrow>\n          (\\<Prod>(b, j)\\<in>as - UNIV \\<times> {0..<Suc n} - {(a, i)}. b) *\n          smult (of_nat (i - n)) (pderiv a)))", "proof (rule sum.cong[OF refl])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> as - UNIV \\<times> {0..<Suc n} \\<Longrightarrow>\n       (case x of\n        (a, i) \\<Rightarrow>\n          (\\<Prod>(b, j)\\<in>as - UNIV \\<times> {0..<n} - {(a, i)}. b) *\n          smult (of_nat (i - n)) (pderiv a)) =\n       (\\<Prod>(a, i)\\<in>as \\<inter> UNIV \\<times> {n}. a) *\n       (case x of\n        (a, i) \\<Rightarrow>\n          (\\<Prod>(b, j)\\<in>as - UNIV \\<times> {0..<Suc n} - {(a, i)}. b) *\n          smult (of_nat (i - n)) (pderiv a))", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> as - UNIV \\<times> {0..<Suc n} \\<Longrightarrow>\n       (case x of\n        (a, i) \\<Rightarrow>\n          (\\<Prod>(b, j)\\<in>as - UNIV \\<times> {0..<n} - {(a, i)}. b) *\n          smult (of_nat (i - n)) (pderiv a)) =\n       (\\<Prod>(a, i)\\<in>as \\<inter> UNIV \\<times> {n}. a) *\n       (case x of\n        (a, i) \\<Rightarrow>\n          (\\<Prod>(b, j)\\<in>as - UNIV \\<times> {0..<Suc n} - {(a, i)}. b) *\n          smult (of_nat (i - n)) (pderiv a))", "assume mem: \"x \\<in> as - UNIV \\<times> {0 ..< Suc n}\""], ["proof (state)\nthis:\n  x \\<in> as - UNIV \\<times> {0..<Suc n}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> as - UNIV \\<times> {0..<Suc n} \\<Longrightarrow>\n       (case x of\n        (a, i) \\<Rightarrow>\n          (\\<Prod>(b, j)\\<in>as - UNIV \\<times> {0..<n} - {(a, i)}. b) *\n          smult (of_nat (i - n)) (pderiv a)) =\n       (\\<Prod>(a, i)\\<in>as \\<inter> UNIV \\<times> {n}. a) *\n       (case x of\n        (a, i) \\<Rightarrow>\n          (\\<Prod>(b, j)\\<in>as - UNIV \\<times> {0..<Suc n} - {(a, i)}. b) *\n          smult (of_nat (i - n)) (pderiv a))", "obtain a i where x: \"x = (a,i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a i. x = (a, i) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  x = (a, i)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> as - UNIV \\<times> {0..<Suc n} \\<Longrightarrow>\n       (case x of\n        (a, i) \\<Rightarrow>\n          (\\<Prod>(b, j)\\<in>as - UNIV \\<times> {0..<n} - {(a, i)}. b) *\n          smult (of_nat (i - n)) (pderiv a)) =\n       (\\<Prod>(a, i)\\<in>as \\<inter> UNIV \\<times> {n}. a) *\n       (case x of\n        (a, i) \\<Rightarrow>\n          (\\<Prod>(b, j)\\<in>as - UNIV \\<times> {0..<Suc n} - {(a, i)}. b) *\n          smult (of_nat (i - n)) (pderiv a))", "with mem"], ["proof (chain)\npicking this:\n  x \\<in> as - UNIV \\<times> {0..<Suc n}\n  x = (a, i)", "have i: \"i > n\""], ["proof (prove)\nusing this:\n  x \\<in> as - UNIV \\<times> {0..<Suc n}\n  x = (a, i)\n\ngoal (1 subgoal):\n 1. n < i", "by auto"], ["proof (state)\nthis:\n  n < i\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> as - UNIV \\<times> {0..<Suc n} \\<Longrightarrow>\n       (case x of\n        (a, i) \\<Rightarrow>\n          (\\<Prod>(b, j)\\<in>as - UNIV \\<times> {0..<n} - {(a, i)}. b) *\n          smult (of_nat (i - n)) (pderiv a)) =\n       (\\<Prod>(a, i)\\<in>as \\<inter> UNIV \\<times> {n}. a) *\n       (case x of\n        (a, i) \\<Rightarrow>\n          (\\<Prod>(b, j)\\<in>as - UNIV \\<times> {0..<Suc n} - {(a, i)}. b) *\n          smult (of_nat (i - n)) (pderiv a))", "have cong: \"\\<And> x y z v :: 'a poly. x = y * v \\<Longrightarrow> x * z = y * (v * z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y z v. x = y * v \\<Longrightarrow> x * z = y * (v * z)", "by auto"], ["proof (state)\nthis:\n  ?x = ?y * ?v \\<Longrightarrow> ?x * ?z = ?y * (?v * ?z)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> as - UNIV \\<times> {0..<Suc n} \\<Longrightarrow>\n       (case x of\n        (a, i) \\<Rightarrow>\n          (\\<Prod>(b, j)\\<in>as - UNIV \\<times> {0..<n} - {(a, i)}. b) *\n          smult (of_nat (i - n)) (pderiv a)) =\n       (\\<Prod>(a, i)\\<in>as \\<inter> UNIV \\<times> {n}. a) *\n       (case x of\n        (a, i) \\<Rightarrow>\n          (\\<Prod>(b, j)\\<in>as - UNIV \\<times> {0..<Suc n} - {(a, i)}. b) *\n          smult (of_nat (i - n)) (pderiv a))", "show \"(case x of\n          (a, i) \\<Rightarrow> (\\<Prod>(b, j)\\<in>as - UNIV \\<times> {0..<n} - {(a, i)}. b) * smult (of_nat (i - n)) (pderiv a)) =\n         (\\<Prod>(a, i)\\<in>as \\<inter> UNIV \\<times> {n}. a) *\n         (case x of (a, i) \\<Rightarrow>\n            (\\<Prod>(b, j)\\<in>as - UNIV \\<times> {0..<Suc n} - {(a, i)}. b) * smult (of_nat (i - n)) (pderiv a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (case x of\n     (a, i) \\<Rightarrow>\n       (\\<Prod>(b, j)\\<in>as - UNIV \\<times> {0..<n} - {(a, i)}. b) *\n       smult (of_nat (i - n)) (pderiv a)) =\n    (\\<Prod>(a, i)\\<in>as \\<inter> UNIV \\<times> {n}. a) *\n    (case x of\n     (a, i) \\<Rightarrow>\n       (\\<Prod>(b, j)\\<in>as - UNIV \\<times> {0..<Suc n} - {(a, i)}. b) *\n       smult (of_nat (i - n)) (pderiv a))", "unfolding x split"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>(b, j)\\<in>as - UNIV \\<times> {0..<n} - {(a, i)}. b) *\n    smult (of_nat (i - n)) (pderiv a) =\n    (\\<Prod>(a, i)\\<in>as \\<inter> UNIV \\<times> {n}. a) *\n    ((\\<Prod>(b, j)\\<in>as - UNIV \\<times> {0..<Suc n} - {(a, i)}. b) *\n     smult (of_nat (i - n)) (pderiv a))", "by (rule cong, subst prod.union_disjoint[symmetric], insert fin, (auto)[3],\n        rule prod.cong, insert i, auto)"], ["proof (state)\nthis:\n  (case x of\n   (a, i) \\<Rightarrow>\n     (\\<Prod>(b, j)\\<in>as - UNIV \\<times> {0..<n} - {(a, i)}. b) *\n     smult (of_nat (i - n)) (pderiv a)) =\n  (\\<Prod>(a, i)\\<in>as \\<inter> UNIV \\<times> {n}. a) *\n  (case x of\n   (a, i) \\<Rightarrow>\n     (\\<Prod>(b, j)\\<in>as - UNIV \\<times> {0..<Suc n} - {(a, i)}. b) *\n     smult (of_nat (i - n)) (pderiv a))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  D n =\n  (\\<Prod>a\\<in>as \\<inter> UNIV \\<times> {n}.\n     case a of (a, i) \\<Rightarrow> a) *\n  (\\<Sum>a\\<in>as - UNIV \\<times> {0..<Suc n}.\n     case a of\n     (a, i) \\<Rightarrow>\n       (\\<Prod>a\\<in>as - UNIV \\<times> {0..<Suc n} - {(a, i)}.\n          case a of (b, j) \\<Rightarrow> b) *\n       smult (of_nat (i - n)) (pderiv a))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemmas A = A_B_C_D(1)"], ["", "lemmas B = A_B_C_D(2)"], ["", "lemmas ABCD_simps = A.simps B.simps C.simps D.simps"], ["", "declare ABCD_simps[simp del]"], ["", "lemma prod_A: \n  \"(\\<Prod>i = 0..< n. A i ^ Suc i) = (\\<Prod>(a, i)\\<in> as \\<inter> UNIV \\<times> {0 ..< n}. a ^ Suc i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>i = 0..<n. A i ^ Suc i) =\n    (\\<Prod>(a, i)\\<in>as \\<inter> UNIV \\<times> {0..<n}. a ^ Suc i)", "proof (induct n)"], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<Prod>i = 0..<0. A i ^ Suc i) =\n    (\\<Prod>a\\<in>as \\<inter> UNIV \\<times> {0..<0}.\n       case a of (a, i) \\<Rightarrow> a ^ Suc i)\n 2. \\<And>n.\n       (\\<Prod>i = 0..<n. A i ^ Suc i) =\n       (\\<Prod>a\\<in>as \\<inter> UNIV \\<times> {0..<n}.\n          case a of (a, i) \\<Rightarrow> a ^ Suc i) \\<Longrightarrow>\n       (\\<Prod>i = 0..<Suc n. A i ^ Suc i) =\n       (\\<Prod>a\\<in>as \\<inter> UNIV \\<times> {0..<Suc n}.\n          case a of (a, i) \\<Rightarrow> a ^ Suc i)", "case (Suc n)"], ["proof (state)\nthis:\n  (\\<Prod>i = 0..<n. A i ^ Suc i) =\n  (\\<Prod>a\\<in>as \\<inter> UNIV \\<times> {0..<n}.\n     case a of (a, i) \\<Rightarrow> a ^ Suc i)\n\ngoal (2 subgoals):\n 1. (\\<Prod>i = 0..<0. A i ^ Suc i) =\n    (\\<Prod>a\\<in>as \\<inter> UNIV \\<times> {0..<0}.\n       case a of (a, i) \\<Rightarrow> a ^ Suc i)\n 2. \\<And>n.\n       (\\<Prod>i = 0..<n. A i ^ Suc i) =\n       (\\<Prod>a\\<in>as \\<inter> UNIV \\<times> {0..<n}.\n          case a of (a, i) \\<Rightarrow> a ^ Suc i) \\<Longrightarrow>\n       (\\<Prod>i = 0..<Suc n. A i ^ Suc i) =\n       (\\<Prod>a\\<in>as \\<inter> UNIV \\<times> {0..<Suc n}.\n          case a of (a, i) \\<Rightarrow> a ^ Suc i)", "have id: \"{0 ..< Suc n} = insert n {0 ..< n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {0..<Suc n} = insert n {0..<n}", "by auto"], ["proof (state)\nthis:\n  {0..<Suc n} = insert n {0..<n}\n\ngoal (2 subgoals):\n 1. (\\<Prod>i = 0..<0. A i ^ Suc i) =\n    (\\<Prod>a\\<in>as \\<inter> UNIV \\<times> {0..<0}.\n       case a of (a, i) \\<Rightarrow> a ^ Suc i)\n 2. \\<And>n.\n       (\\<Prod>i = 0..<n. A i ^ Suc i) =\n       (\\<Prod>a\\<in>as \\<inter> UNIV \\<times> {0..<n}.\n          case a of (a, i) \\<Rightarrow> a ^ Suc i) \\<Longrightarrow>\n       (\\<Prod>i = 0..<Suc n. A i ^ Suc i) =\n       (\\<Prod>a\\<in>as \\<inter> UNIV \\<times> {0..<Suc n}.\n          case a of (a, i) \\<Rightarrow> a ^ Suc i)", "have id2: \"as \\<inter> UNIV \\<times> {0 ..< Suc n} = as \\<inter> UNIV \\<times> {n} \\<union> as \\<inter> UNIV \\<times> {0 ..< n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. as \\<inter> UNIV \\<times> {0..<Suc n} =\n    as \\<inter> UNIV \\<times> {n} \\<union> as \\<inter> UNIV \\<times> {0..<n}", "by auto"], ["proof (state)\nthis:\n  as \\<inter> UNIV \\<times> {0..<Suc n} =\n  as \\<inter> UNIV \\<times> {n} \\<union> as \\<inter> UNIV \\<times> {0..<n}\n\ngoal (2 subgoals):\n 1. (\\<Prod>i = 0..<0. A i ^ Suc i) =\n    (\\<Prod>a\\<in>as \\<inter> UNIV \\<times> {0..<0}.\n       case a of (a, i) \\<Rightarrow> a ^ Suc i)\n 2. \\<And>n.\n       (\\<Prod>i = 0..<n. A i ^ Suc i) =\n       (\\<Prod>a\\<in>as \\<inter> UNIV \\<times> {0..<n}.\n          case a of (a, i) \\<Rightarrow> a ^ Suc i) \\<Longrightarrow>\n       (\\<Prod>i = 0..<Suc n. A i ^ Suc i) =\n       (\\<Prod>a\\<in>as \\<inter> UNIV \\<times> {0..<Suc n}.\n          case a of (a, i) \\<Rightarrow> a ^ Suc i)", "have cong: \"\\<And> x y z. x = y \\<Longrightarrow> x * z = y * z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y z. x = y \\<Longrightarrow> x * z = y * z", "by auto"], ["proof (state)\nthis:\n  ?x = ?y \\<Longrightarrow> ?x * ?z = ?y * ?z\n\ngoal (2 subgoals):\n 1. (\\<Prod>i = 0..<0. A i ^ Suc i) =\n    (\\<Prod>a\\<in>as \\<inter> UNIV \\<times> {0..<0}.\n       case a of (a, i) \\<Rightarrow> a ^ Suc i)\n 2. \\<And>n.\n       (\\<Prod>i = 0..<n. A i ^ Suc i) =\n       (\\<Prod>a\\<in>as \\<inter> UNIV \\<times> {0..<n}.\n          case a of (a, i) \\<Rightarrow> a ^ Suc i) \\<Longrightarrow>\n       (\\<Prod>i = 0..<Suc n. A i ^ Suc i) =\n       (\\<Prod>a\\<in>as \\<inter> UNIV \\<times> {0..<Suc n}.\n          case a of (a, i) \\<Rightarrow> a ^ Suc i)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>i = 0..<Suc n. A i ^ Suc i) =\n    (\\<Prod>a\\<in>as \\<inter> UNIV \\<times> {0..<Suc n}.\n       case a of (a, i) \\<Rightarrow> a ^ Suc i)", "unfolding id2"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>i = 0..<Suc n. A i ^ Suc i) =\n    (\\<Prod>a\\<in>as \\<inter> UNIV \\<times> {n} \\<union>\n                  as \\<inter> UNIV \\<times> {0..<n}.\n       case a of (a, i) \\<Rightarrow> a ^ Suc i)", "unfolding id"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>i\\<in>insert n {0..<n}. A i ^ Suc i) =\n    (\\<Prod>a\\<in>as \\<inter> UNIV \\<times> {n} \\<union>\n                  as \\<inter> UNIV \\<times> {0..<n}.\n       case a of (a, i) \\<Rightarrow> a ^ Suc i)", "proof (subst prod.insert; (subst prod.union_disjoint)?; (unfold Suc)?; \n    (unfold A, rule cong)?)"], ["proof (state)\ngoal (6 subgoals):\n 1. finite {0..<n}\n 2. n \\<notin> {0..<n}\n 3. finite (as \\<inter> UNIV \\<times> {n})\n 4. finite (as \\<inter> UNIV \\<times> {0..<n})\n 5. as \\<inter> UNIV \\<times> {n} \\<inter>\n    (as \\<inter> UNIV \\<times> {0..<n}) =\n    {}\n 6. (\\<Prod>(a, i)\\<in>as \\<inter> UNIV \\<times> {n}. a) ^ Suc n =\n    (\\<Prod>(a, i)\\<in>as \\<inter> UNIV \\<times> {n}. a ^ Suc i)", "show \"(\\<Prod>(a, i)\\<in>as \\<inter> UNIV \\<times> {n}. a) ^ Suc n = (\\<Prod>(a, i)\\<in>as \\<inter> UNIV \\<times> {n}. a ^ Suc i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>(a, i)\\<in>as \\<inter> UNIV \\<times> {n}. a) ^ Suc n =\n    (\\<Prod>(a, i)\\<in>as \\<inter> UNIV \\<times> {n}. a ^ Suc i)", "unfolding prod_power_distrib"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>x\\<in>as \\<inter> UNIV \\<times> {n}.\n       (case x of (a, i) \\<Rightarrow> a) ^ Suc n) =\n    (\\<Prod>(a, i)\\<in>as \\<inter> UNIV \\<times> {n}. a ^ Suc i)", "by (rule prod.cong, auto)"], ["proof (state)\nthis:\n  (\\<Prod>(a, i)\\<in>as \\<inter> UNIV \\<times> {n}. a) ^ Suc n =\n  (\\<Prod>(a, i)\\<in>as \\<inter> UNIV \\<times> {n}. a ^ Suc i)\n\ngoal (5 subgoals):\n 1. finite {0..<n}\n 2. n \\<notin> {0..<n}\n 3. finite (as \\<inter> UNIV \\<times> {n})\n 4. finite (as \\<inter> UNIV \\<times> {0..<n})\n 5. as \\<inter> UNIV \\<times> {n} \\<inter>\n    (as \\<inter> UNIV \\<times> {0..<n}) =\n    {}", "qed (insert fin, auto)"], ["proof (state)\nthis:\n  (\\<Prod>i = 0..<Suc n. A i ^ Suc i) =\n  (\\<Prod>a\\<in>as \\<inter> UNIV \\<times> {0..<Suc n}.\n     case a of (a, i) \\<Rightarrow> a ^ Suc i)\n\ngoal (1 subgoal):\n 1. (\\<Prod>i = 0..<0. A i ^ Suc i) =\n    (\\<Prod>a\\<in>as \\<inter> UNIV \\<times> {0..<0}.\n       case a of (a, i) \\<Rightarrow> a ^ Suc i)", "qed simp"], ["", "lemma prod_A_is_p_unknown: assumes \"\\<And> a i. (a,i) \\<in> as \\<Longrightarrow> i < n\"\n  shows \"p = (\\<Prod>i = 0..< n. A i ^ Suc i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p = (\\<Prod>i = 0..<n. A i ^ Suc i)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. p = (\\<Prod>i = 0..<n. A i ^ Suc i)", "have \"p = (\\<Prod>(a, i)\\<in>as. a ^ Suc i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p = (\\<Prod>(a, i)\\<in>as. a ^ Suc i)", "by (rule p)"], ["proof (state)\nthis:\n  p = (\\<Prod>(a, i)\\<in>as. a ^ Suc i)\n\ngoal (1 subgoal):\n 1. p = (\\<Prod>i = 0..<n. A i ^ Suc i)", "also"], ["proof (state)\nthis:\n  p = (\\<Prod>(a, i)\\<in>as. a ^ Suc i)\n\ngoal (1 subgoal):\n 1. p = (\\<Prod>i = 0..<n. A i ^ Suc i)", "have \"\\<dots> = (\\<Prod>i = 0..< n. A i ^ Suc i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>(a, i)\\<in>as. a ^ Suc i) = (\\<Prod>i = 0..<n. A i ^ Suc i)", "unfolding prod_A"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>(a, i)\\<in>as. a ^ Suc i) =\n    (\\<Prod>(a, i)\\<in>as \\<inter> UNIV \\<times> {0..<n}. a ^ Suc i)", "by (rule prod.cong, insert assms, auto)"], ["proof (state)\nthis:\n  (\\<Prod>(a, i)\\<in>as. a ^ Suc i) = (\\<Prod>i = 0..<n. A i ^ Suc i)\n\ngoal (1 subgoal):\n 1. p = (\\<Prod>i = 0..<n. A i ^ Suc i)", "finally"], ["proof (chain)\npicking this:\n  p = (\\<Prod>i = 0..<n. A i ^ Suc i)", "show ?thesis"], ["proof (prove)\nusing this:\n  p = (\\<Prod>i = 0..<n. A i ^ Suc i)\n\ngoal (1 subgoal):\n 1. p = (\\<Prod>i = 0..<n. A i ^ Suc i)", "."], ["proof (state)\nthis:\n  p = (\\<Prod>i = 0..<n. A i ^ Suc i)\n\ngoal:\nNo subgoals!", "qed"], ["", "definition bound :: nat where\n  \"bound = Suc (Max (snd ` as))\""], ["", "lemma bound: assumes m: \"m \\<ge> bound\"\n  shows \"B m = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B m = 1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. B m = 1", "let ?set = \"as - UNIV \\<times> {0..<m}\""], ["proof (state)\ngoal (1 subgoal):\n 1. B m = 1", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. B m = 1", "fix a i"], ["proof (state)\ngoal (1 subgoal):\n 1. B m = 1", "assume ai: \"(a,i) \\<in> ?set\""], ["proof (state)\nthis:\n  (a, i) \\<in> as - UNIV \\<times> {0..<m}\n\ngoal (1 subgoal):\n 1. B m = 1", "hence \"i \\<in> snd ` as\""], ["proof (prove)\nusing this:\n  (a, i) \\<in> as - UNIV \\<times> {0..<m}\n\ngoal (1 subgoal):\n 1. i \\<in> snd ` as", "by force"], ["proof (state)\nthis:\n  i \\<in> snd ` as\n\ngoal (1 subgoal):\n 1. B m = 1", "from Max_ge[OF _ this] fin"], ["proof (chain)\npicking this:\n  finite (snd ` as) \\<Longrightarrow> i \\<le> Max (snd ` as)\n  finite as", "have \"i \\<le> Max (snd ` as)\""], ["proof (prove)\nusing this:\n  finite (snd ` as) \\<Longrightarrow> i \\<le> Max (snd ` as)\n  finite as\n\ngoal (1 subgoal):\n 1. i \\<le> Max (snd ` as)", "by auto"], ["proof (state)\nthis:\n  i \\<le> Max (snd ` as)\n\ngoal (1 subgoal):\n 1. B m = 1", "with ai m[unfolded bound_def]"], ["proof (chain)\npicking this:\n  (a, i) \\<in> as - UNIV \\<times> {0..<m}\n  Suc (Max (snd ` as)) \\<le> m\n  i \\<le> Max (snd ` as)", "have False"], ["proof (prove)\nusing this:\n  (a, i) \\<in> as - UNIV \\<times> {0..<m}\n  Suc (Max (snd ` as)) \\<le> m\n  i \\<le> Max (snd ` as)\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. B m = 1", "}"], ["proof (state)\nthis:\n  (?a2, ?i2) \\<in> as - UNIV \\<times> {0..<m} \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. B m = 1", "hence id: \"?set = {}\""], ["proof (prove)\nusing this:\n  (?a2, ?i2) \\<in> as - UNIV \\<times> {0..<m} \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. as - UNIV \\<times> {0..<m} = {}", "by force"], ["proof (state)\nthis:\n  as - UNIV \\<times> {0..<m} = {}\n\ngoal (1 subgoal):\n 1. B m = 1", "show \"B m = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B m = 1", "unfolding B id"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>(a, i)\\<in>{}. a) = 1", "by simp"], ["proof (state)\nthis:\n  B m = 1\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma coprime_A_A: assumes \"i \\<noteq> j\"\n  shows \"coprime (A i) (A j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coprime (A i) (A j)", "proof (rule coprimeI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>c.\n       \\<lbrakk>c dvd A i; c dvd A j\\<rbrakk> \\<Longrightarrow> is_unit c", "fix k"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>c.\n       \\<lbrakk>c dvd A i; c dvd A j\\<rbrakk> \\<Longrightarrow> is_unit c", "assume dvd: \"k dvd A i\" \"k dvd A j\""], ["proof (state)\nthis:\n  k dvd A i\n  k dvd A j\n\ngoal (1 subgoal):\n 1. \\<And>c.\n       \\<lbrakk>c dvd A i; c dvd A j\\<rbrakk> \\<Longrightarrow> is_unit c", "have Ai: \"A i \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A i \\<noteq> 0", "unfolding A"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>(a, i)\\<in>as \\<inter> UNIV \\<times> {i}. a) \\<noteq> 0", "by (rule nonzero_gen, auto)"], ["proof (state)\nthis:\n  A i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>c.\n       \\<lbrakk>c dvd A i; c dvd A j\\<rbrakk> \\<Longrightarrow> is_unit c", "with dvd"], ["proof (chain)\npicking this:\n  k dvd A i\n  k dvd A j\n  A i \\<noteq> 0", "have k: \"k \\<noteq> 0\""], ["proof (prove)\nusing this:\n  k dvd A i\n  k dvd A j\n  A i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. k \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>c.\n       \\<lbrakk>c dvd A i; c dvd A j\\<rbrakk> \\<Longrightarrow> is_unit c", "show \"is_unit k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_unit k", "proof (cases \"degree k > 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 < degree k \\<Longrightarrow> is_unit k\n 2. \\<not> 0 < degree k \\<Longrightarrow> is_unit k", "case False"], ["proof (state)\nthis:\n  \\<not> 0 < degree k\n\ngoal (2 subgoals):\n 1. 0 < degree k \\<Longrightarrow> is_unit k\n 2. \\<not> 0 < degree k \\<Longrightarrow> is_unit k", "then"], ["proof (chain)\npicking this:\n  \\<not> 0 < degree k", "obtain c where kc: \"k = [: c :]\""], ["proof (prove)\nusing this:\n  \\<not> 0 < degree k\n\ngoal (1 subgoal):\n 1. (\\<And>c. k = [:c:] \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by (auto dest: degree0_coeffs)"], ["proof (state)\nthis:\n  k = [:c:]\n\ngoal (2 subgoals):\n 1. 0 < degree k \\<Longrightarrow> is_unit k\n 2. \\<not> 0 < degree k \\<Longrightarrow> is_unit k", "with k"], ["proof (chain)\npicking this:\n  k \\<noteq> 0\n  k = [:c:]", "have \"1 = k * [:1 / c:]\""], ["proof (prove)\nusing this:\n  k \\<noteq> 0\n  k = [:c:]\n\ngoal (1 subgoal):\n 1. 1 = k * [:(1::'a) / c:]", "by simp"], ["proof (state)\nthis:\n  1 = k * [:(1::'a) / c:]\n\ngoal (2 subgoals):\n 1. 0 < degree k \\<Longrightarrow> is_unit k\n 2. \\<not> 0 < degree k \\<Longrightarrow> is_unit k", "thus ?thesis"], ["proof (prove)\nusing this:\n  1 = k * [:(1::'a) / c:]\n\ngoal (1 subgoal):\n 1. is_unit k", "unfolding dvd_def"], ["proof (prove)\nusing this:\n  1 = k * [:(1::'a) / c:]\n\ngoal (1 subgoal):\n 1. \\<exists>ka. 1 = k * ka", "by blast"], ["proof (state)\nthis:\n  is_unit k\n\ngoal (1 subgoal):\n 1. 0 < degree k \\<Longrightarrow> is_unit k", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. 0 < degree k \\<Longrightarrow> is_unit k", "case True"], ["proof (state)\nthis:\n  0 < degree k\n\ngoal (1 subgoal):\n 1. 0 < degree k \\<Longrightarrow> is_unit k", "from irreducible_monic_factor[OF this]"], ["proof (chain)\npicking this:\n  \\<exists>q r. irreducible q \\<and> k = q * r \\<and> monic q", "obtain q r where k: \"k = q * r\" and q: \"irreducible q\" and mq: \"monic q\""], ["proof (prove)\nusing this:\n  \\<exists>q r. irreducible q \\<and> k = q * r \\<and> monic q\n\ngoal (1 subgoal):\n 1. (\\<And>q r.\n        \\<lbrakk>k = q * r; irreducible q; monic q\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  k = q * r\n  irreducible q\n  monic q\n\ngoal (1 subgoal):\n 1. 0 < degree k \\<Longrightarrow> is_unit k", "with dvd"], ["proof (chain)\npicking this:\n  k dvd A i\n  k dvd A j\n  k = q * r\n  irreducible q\n  monic q", "have dvd: \"q dvd A i\" \"q dvd A j\""], ["proof (prove)\nusing this:\n  k dvd A i\n  k dvd A j\n  k = q * r\n  irreducible q\n  monic q\n\ngoal (1 subgoal):\n 1. q dvd A i &&& q dvd A j", "unfolding dvd_def"], ["proof (prove)\nusing this:\n  \\<exists>ka. A i = k * ka\n  \\<exists>ka. A j = k * ka\n  k = q * r\n  irreducible q\n  monic q\n\ngoal (1 subgoal):\n 1. \\<exists>k. A i = q * k &&& \\<exists>k. A j = q * k", "by auto"], ["proof (state)\nthis:\n  q dvd A i\n  q dvd A j\n\ngoal (1 subgoal):\n 1. 0 < degree k \\<Longrightarrow> is_unit k", "from q"], ["proof (chain)\npicking this:\n  irreducible q", "have q0: \"degree q > 0\""], ["proof (prove)\nusing this:\n  irreducible q\n\ngoal (1 subgoal):\n 1. 0 < degree q", "unfolding irreducible\\<^sub>d_def"], ["proof (prove)\nusing this:\n  irreducible q\n\ngoal (1 subgoal):\n 1. 0 < degree q", "by auto"], ["proof (state)\nthis:\n  0 < degree q\n\ngoal (1 subgoal):\n 1. 0 < degree k \\<Longrightarrow> is_unit k", "from irreducible_dvd_prod[OF q dvd(1)[unfolded A]]"], ["proof (chain)\npicking this:\n  \\<exists>a\\<in>as \\<inter> UNIV \\<times> {i}.\n     q dvd (case a of (a, i) \\<Rightarrow> a)", "obtain a where ai: \"(a,i) \\<in> as\" and qa: \"q dvd a\""], ["proof (prove)\nusing this:\n  \\<exists>a\\<in>as \\<inter> UNIV \\<times> {i}.\n     q dvd (case a of (a, i) \\<Rightarrow> a)\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>(a, i) \\<in> as; q dvd a\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  (a, i) \\<in> as\n  q dvd a\n\ngoal (1 subgoal):\n 1. 0 < degree k \\<Longrightarrow> is_unit k", "from irreducible_dvd_prod[OF q dvd(2)[unfolded A]]"], ["proof (chain)\npicking this:\n  \\<exists>a\\<in>as \\<inter> UNIV \\<times> {j}.\n     q dvd (case a of (a, i) \\<Rightarrow> a)", "obtain b where bj: \"(b,j) \\<in> as\" and qb: \"q dvd b\""], ["proof (prove)\nusing this:\n  \\<exists>a\\<in>as \\<inter> UNIV \\<times> {j}.\n     q dvd (case a of (a, i) \\<Rightarrow> a)\n\ngoal (1 subgoal):\n 1. (\\<And>b.\n        \\<lbrakk>(b, j) \\<in> as; q dvd b\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  (b, j) \\<in> as\n  q dvd b\n\ngoal (1 subgoal):\n 1. 0 < degree k \\<Longrightarrow> is_unit k", "from as_distinct[OF ai bj] assms"], ["proof (chain)\npicking this:\n  (a, i) \\<noteq> (b, j) \\<Longrightarrow> a \\<noteq> b\n  i \\<noteq> j", "have neq: \"a \\<noteq> b\""], ["proof (prove)\nusing this:\n  (a, i) \\<noteq> (b, j) \\<Longrightarrow> a \\<noteq> b\n  i \\<noteq> j\n\ngoal (1 subgoal):\n 1. a \\<noteq> b", "by auto"], ["proof (state)\nthis:\n  a \\<noteq> b\n\ngoal (1 subgoal):\n 1. 0 < degree k \\<Longrightarrow> is_unit k", "from irreducible\\<^sub>d_dvd_smult[OF q0 as_irred[OF ai] qa]\n      irreducible\\<^sub>d_dvd_smult[OF q0 as_irred[OF bj] qb]"], ["proof (chain)\npicking this:\n  \\<exists>c. c \\<noteq> (0::'a) \\<and> a = smult c q\n  \\<exists>c. c \\<noteq> (0::'a) \\<and> b = smult c q", "obtain c d where \"c \\<noteq> 0\" \"d \\<noteq> 0\" \"a = smult c q\" \"b = smult d q\""], ["proof (prove)\nusing this:\n  \\<exists>c. c \\<noteq> (0::'a) \\<and> a = smult c q\n  \\<exists>c. c \\<noteq> (0::'a) \\<and> b = smult c q\n\ngoal (1 subgoal):\n 1. (\\<And>c d.\n        \\<lbrakk>c \\<noteq> (0::'a); d \\<noteq> (0::'a); a = smult c q;\n         b = smult d q\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  c \\<noteq> (0::'a)\n  d \\<noteq> (0::'a)\n  a = smult c q\n  b = smult d q\n\ngoal (1 subgoal):\n 1. 0 < degree k \\<Longrightarrow> is_unit k", "hence ab: \"a = smult (c / d) b\" and \"c / d \\<noteq> 0\""], ["proof (prove)\nusing this:\n  c \\<noteq> (0::'a)\n  d \\<noteq> (0::'a)\n  a = smult c q\n  b = smult d q\n\ngoal (1 subgoal):\n 1. a = smult (c / d) b &&& c / d \\<noteq> (0::'a)", "by auto"], ["proof (state)\nthis:\n  a = smult (c / d) b\n  c / d \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. 0 < degree k \\<Longrightarrow> is_unit k", "with as_monic[OF bj] as_monic[OF ai] arg_cong[OF ab, of \"\\<lambda> p. coeff p (degree p)\"]"], ["proof (chain)\npicking this:\n  monic b\n  monic a\n  lead_coeff a = lead_coeff (smult (c / d) b)\n  a = smult (c / d) b\n  c / d \\<noteq> (0::'a)", "have \"a = b\""], ["proof (prove)\nusing this:\n  monic b\n  monic a\n  lead_coeff a = lead_coeff (smult (c / d) b)\n  a = smult (c / d) b\n  c / d \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. a = b", "unfolding coeff_smult degree_smult_eq"], ["proof (prove)\nusing this:\n  monic b\n  monic a\n  lead_coeff a = c / d * coeff b (if c / d = (0::'a) then 0 else degree b)\n  a = smult (c / d) b\n  c / d \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. a = b", "by auto"], ["proof (state)\nthis:\n  a = b\n\ngoal (1 subgoal):\n 1. 0 < degree k \\<Longrightarrow> is_unit k", "with neq"], ["proof (chain)\npicking this:\n  a \\<noteq> b\n  a = b", "show ?thesis"], ["proof (prove)\nusing this:\n  a \\<noteq> b\n  a = b\n\ngoal (1 subgoal):\n 1. is_unit k", "by auto"], ["proof (state)\nthis:\n  is_unit k\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  is_unit k\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma A_monic: \"monic (A i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monic (A i)", "unfolding A"], ["proof (prove)\ngoal (1 subgoal):\n 1. monic (\\<Prod>(a, i)\\<in>as \\<inter> UNIV \\<times> {i}. a)", "by (rule monic_gen, auto)"], ["", "lemma A_square_free: \"square_free (A i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. square_free (A i)", "proof (rule square_freeI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>q.\n       \\<lbrakk>0 < degree q; q \\<noteq> 0; q * q dvd A i\\<rbrakk>\n       \\<Longrightarrow> False\n 2. A i \\<noteq> 0", "fix q k"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>q.\n       \\<lbrakk>0 < degree q; q \\<noteq> 0; q * q dvd A i\\<rbrakk>\n       \\<Longrightarrow> False\n 2. A i \\<noteq> 0", "have mon: \"monic (A i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monic (A i)", "by (rule A_monic)"], ["proof (state)\nthis:\n  monic (A i)\n\ngoal (2 subgoals):\n 1. \\<And>q.\n       \\<lbrakk>0 < degree q; q \\<noteq> 0; q * q dvd A i\\<rbrakk>\n       \\<Longrightarrow> False\n 2. A i \\<noteq> 0", "hence Ai: \"A i \\<noteq> 0\""], ["proof (prove)\nusing this:\n  monic (A i)\n\ngoal (1 subgoal):\n 1. A i \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  A i \\<noteq> 0\n\ngoal (2 subgoals):\n 1. \\<And>q.\n       \\<lbrakk>0 < degree q; q \\<noteq> 0; q * q dvd A i\\<rbrakk>\n       \\<Longrightarrow> False\n 2. A i \\<noteq> 0", "assume q: \"degree q > 0\" and dvd: \"q * q dvd A i\""], ["proof (state)\nthis:\n  0 < degree q\n  q * q dvd A i\n\ngoal (2 subgoals):\n 1. \\<And>q.\n       \\<lbrakk>0 < degree q; q \\<noteq> 0; q * q dvd A i\\<rbrakk>\n       \\<Longrightarrow> False\n 2. A i \\<noteq> 0", "from irreducible_monic_factor[OF q]"], ["proof (chain)\npicking this:\n  \\<exists>qa r. irreducible qa \\<and> q = qa * r \\<and> monic qa", "obtain r s where q: \"q = r * s\" and \n    irr: \"irreducible r\" and mr: \"monic r\""], ["proof (prove)\nusing this:\n  \\<exists>qa r. irreducible qa \\<and> q = qa * r \\<and> monic qa\n\ngoal (1 subgoal):\n 1. (\\<And>r s.\n        \\<lbrakk>q = r * s; irreducible r; monic r\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  q = r * s\n  irreducible r\n  monic r\n\ngoal (2 subgoals):\n 1. \\<And>q.\n       \\<lbrakk>0 < degree q; q \\<noteq> 0; q * q dvd A i\\<rbrakk>\n       \\<Longrightarrow> False\n 2. A i \\<noteq> 0", "from dvd[unfolded q]"], ["proof (chain)\npicking this:\n  r * s * (r * s) dvd A i", "have dvd2: \"r * r dvd A i\" and dvd1: \"r dvd A i\""], ["proof (prove)\nusing this:\n  r * s * (r * s) dvd A i\n\ngoal (1 subgoal):\n 1. r * r dvd A i &&& r dvd A i", "unfolding dvd_def"], ["proof (prove)\nusing this:\n  \\<exists>k. A i = r * s * (r * s) * k\n\ngoal (1 subgoal):\n 1. \\<exists>k. A i = r * r * k &&& \\<exists>k. A i = r * k", "by auto"], ["proof (state)\nthis:\n  r * r dvd A i\n  r dvd A i\n\ngoal (2 subgoals):\n 1. \\<And>q.\n       \\<lbrakk>0 < degree q; q \\<noteq> 0; q * q dvd A i\\<rbrakk>\n       \\<Longrightarrow> False\n 2. A i \\<noteq> 0", "from irreducible_dvd_prod[OF irr dvd1[unfolded A]]"], ["proof (chain)\npicking this:\n  \\<exists>a\\<in>as \\<inter> UNIV \\<times> {i}.\n     r dvd (case a of (a, i) \\<Rightarrow> a)", "obtain a where ai: \"(a,i) \\<in> as\" and ra: \"r dvd a\""], ["proof (prove)\nusing this:\n  \\<exists>a\\<in>as \\<inter> UNIV \\<times> {i}.\n     r dvd (case a of (a, i) \\<Rightarrow> a)\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>(a, i) \\<in> as; r dvd a\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  (a, i) \\<in> as\n  r dvd a\n\ngoal (2 subgoals):\n 1. \\<And>q.\n       \\<lbrakk>0 < degree q; q \\<noteq> 0; q * q dvd A i\\<rbrakk>\n       \\<Longrightarrow> False\n 2. A i \\<noteq> 0", "let ?rem = \"(\\<Prod>(a, i)\\<in>as \\<inter> UNIV \\<times> {i} - {(a,i)}. a)\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>q.\n       \\<lbrakk>0 < degree q; q \\<noteq> 0; q * q dvd A i\\<rbrakk>\n       \\<Longrightarrow> False\n 2. A i \\<noteq> 0", "have a: \"irreducible\\<^sub>d a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. irreducible\\<^sub>d a", "by (rule as_irred[OF ai])"], ["proof (state)\nthis:\n  irreducible\\<^sub>d a\n\ngoal (2 subgoals):\n 1. \\<And>q.\n       \\<lbrakk>0 < degree q; q \\<noteq> 0; q * q dvd A i\\<rbrakk>\n       \\<Longrightarrow> False\n 2. A i \\<noteq> 0", "from irreducible\\<^sub>d_dvd_smult[OF _ a ra] irr"], ["proof (chain)\npicking this:\n  0 < degree r \\<Longrightarrow>\n  \\<exists>c. c \\<noteq> (0::'a) \\<and> a = smult c r\n  irreducible r", "obtain c where ar: \"a = smult c r\"  and \"c \\<noteq> 0\""], ["proof (prove)\nusing this:\n  0 < degree r \\<Longrightarrow>\n  \\<exists>c. c \\<noteq> (0::'a) \\<and> a = smult c r\n  irreducible r\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        \\<lbrakk>a = smult c r; c \\<noteq> (0::'a)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  a = smult c r\n  c \\<noteq> (0::'a)\n\ngoal (2 subgoals):\n 1. \\<And>q.\n       \\<lbrakk>0 < degree q; q \\<noteq> 0; q * q dvd A i\\<rbrakk>\n       \\<Longrightarrow> False\n 2. A i \\<noteq> 0", "with mr as_monic[OF ai] arg_cong[OF ar, of \"\\<lambda> p. coeff p (degree p)\"]"], ["proof (chain)\npicking this:\n  monic r\n  monic a\n  lead_coeff a = lead_coeff (smult c r)\n  a = smult c r\n  c \\<noteq> (0::'a)", "have \"a = r\""], ["proof (prove)\nusing this:\n  monic r\n  monic a\n  lead_coeff a = lead_coeff (smult c r)\n  a = smult c r\n  c \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. a = r", "unfolding coeff_smult degree_smult_eq"], ["proof (prove)\nusing this:\n  monic r\n  monic a\n  lead_coeff a = c * coeff r (if c = (0::'a) then 0 else degree r)\n  a = smult c r\n  c \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. a = r", "by auto"], ["proof (state)\nthis:\n  a = r\n\ngoal (2 subgoals):\n 1. \\<And>q.\n       \\<lbrakk>0 < degree q; q \\<noteq> 0; q * q dvd A i\\<rbrakk>\n       \\<Longrightarrow> False\n 2. A i \\<noteq> 0", "with dvd2"], ["proof (chain)\npicking this:\n  r * r dvd A i\n  a = r", "have dvd: \"a * a dvd A i\""], ["proof (prove)\nusing this:\n  r * r dvd A i\n  a = r\n\ngoal (1 subgoal):\n 1. a * a dvd A i", "by simp"], ["proof (state)\nthis:\n  a * a dvd A i\n\ngoal (2 subgoals):\n 1. \\<And>q.\n       \\<lbrakk>0 < degree q; q \\<noteq> 0; q * q dvd A i\\<rbrakk>\n       \\<Longrightarrow> False\n 2. A i \\<noteq> 0", "have id: \"A i = a * ?rem\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A i =\n    a * (\\<Prod>(a, i)\\<in>as \\<inter> UNIV \\<times> {i} - {(a, i)}. a)", "unfolding A"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>(a, i)\\<in>as \\<inter> UNIV \\<times> {i}. a) =\n    a * (\\<Prod>(a, i)\\<in>as \\<inter> UNIV \\<times> {i} - {(a, i)}. a)", "by (subst prod.remove[of _ \"(a,i)\"], insert ai fin, auto)"], ["proof (state)\nthis:\n  A i = a * (\\<Prod>(a, i)\\<in>as \\<inter> UNIV \\<times> {i} - {(a, i)}. a)\n\ngoal (2 subgoals):\n 1. \\<And>q.\n       \\<lbrakk>0 < degree q; q \\<noteq> 0; q * q dvd A i\\<rbrakk>\n       \\<Longrightarrow> False\n 2. A i \\<noteq> 0", "with dvd"], ["proof (chain)\npicking this:\n  a * a dvd A i\n  A i = a * (\\<Prod>(a, i)\\<in>as \\<inter> UNIV \\<times> {i} - {(a, i)}. a)", "have \"a dvd ?rem\""], ["proof (prove)\nusing this:\n  a * a dvd A i\n  A i = a * (\\<Prod>(a, i)\\<in>as \\<inter> UNIV \\<times> {i} - {(a, i)}. a)\n\ngoal (1 subgoal):\n 1. a dvd (\\<Prod>(a, i)\\<in>as \\<inter> UNIV \\<times> {i} - {(a, i)}. a)", "using a id Ai"], ["proof (prove)\nusing this:\n  a * a dvd A i\n  A i = a * (\\<Prod>(a, i)\\<in>as \\<inter> UNIV \\<times> {i} - {(a, i)}. a)\n  irreducible\\<^sub>d a\n  A i = a * (\\<Prod>(a, i)\\<in>as \\<inter> UNIV \\<times> {i} - {(a, i)}. a)\n  A i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. a dvd (\\<Prod>(a, i)\\<in>as \\<inter> UNIV \\<times> {i} - {(a, i)}. a)", "by auto"], ["proof (state)\nthis:\n  a dvd (\\<Prod>(a, i)\\<in>as \\<inter> UNIV \\<times> {i} - {(a, i)}. a)\n\ngoal (2 subgoals):\n 1. \\<And>q.\n       \\<lbrakk>0 < degree q; q \\<noteq> 0; q * q dvd A i\\<rbrakk>\n       \\<Longrightarrow> False\n 2. A i \\<noteq> 0", "from irreducible_dvd_prod[OF _ this] a"], ["proof (chain)\npicking this:\n  irreducible a \\<Longrightarrow>\n  \\<exists>aa\\<in>as \\<inter> UNIV \\<times> {i} - {(a, i)}.\n     a dvd (case aa of (a, i) \\<Rightarrow> a)\n  irreducible\\<^sub>d a", "obtain b where bi: \"(b,i) \\<in> as\" \n    and neq: \"b \\<noteq> a\" and ab: \"a dvd b\""], ["proof (prove)\nusing this:\n  irreducible a \\<Longrightarrow>\n  \\<exists>aa\\<in>as \\<inter> UNIV \\<times> {i} - {(a, i)}.\n     a dvd (case aa of (a, i) \\<Rightarrow> a)\n  irreducible\\<^sub>d a\n\ngoal (1 subgoal):\n 1. (\\<And>b.\n        \\<lbrakk>(b, i) \\<in> as; b \\<noteq> a; a dvd b\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  (b, i) \\<in> as\n  b \\<noteq> a\n  a dvd b\n\ngoal (2 subgoals):\n 1. \\<And>q.\n       \\<lbrakk>0 < degree q; q \\<noteq> 0; q * q dvd A i\\<rbrakk>\n       \\<Longrightarrow> False\n 2. A i \\<noteq> 0", "from as_irred[OF bi]"], ["proof (chain)\npicking this:\n  irreducible\\<^sub>d b", "have b: \"irreducible\\<^sub>d b\""], ["proof (prove)\nusing this:\n  irreducible\\<^sub>d b\n\ngoal (1 subgoal):\n 1. irreducible\\<^sub>d b", "."], ["proof (state)\nthis:\n  irreducible\\<^sub>d b\n\ngoal (2 subgoals):\n 1. \\<And>q.\n       \\<lbrakk>0 < degree q; q \\<noteq> 0; q * q dvd A i\\<rbrakk>\n       \\<Longrightarrow> False\n 2. A i \\<noteq> 0", "from irreducible\\<^sub>d_dvd_smult[OF _ b ab] a[unfolded irreducible\\<^sub>d_def]"], ["proof (chain)\npicking this:\n  0 < degree a \\<Longrightarrow>\n  \\<exists>c. c \\<noteq> (0::'a) \\<and> b = smult c a\n  0 < degree a \\<and>\n  (\\<forall>q r.\n      degree q < degree a \\<longrightarrow>\n      degree r < degree a \\<longrightarrow> a \\<noteq> q * r)", "obtain c where \"c \\<noteq> 0\" and ba: \"b = smult c a\""], ["proof (prove)\nusing this:\n  0 < degree a \\<Longrightarrow>\n  \\<exists>c. c \\<noteq> (0::'a) \\<and> b = smult c a\n  0 < degree a \\<and>\n  (\\<forall>q r.\n      degree q < degree a \\<longrightarrow>\n      degree r < degree a \\<longrightarrow> a \\<noteq> q * r)\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        \\<lbrakk>c \\<noteq> (0::'a); b = smult c a\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  c \\<noteq> (0::'a)\n  b = smult c a\n\ngoal (2 subgoals):\n 1. \\<And>q.\n       \\<lbrakk>0 < degree q; q \\<noteq> 0; q * q dvd A i\\<rbrakk>\n       \\<Longrightarrow> False\n 2. A i \\<noteq> 0", "with as_monic[OF bi] as_monic[OF ai] arg_cong[OF ba, of \"\\<lambda> p. coeff p (degree p)\"]"], ["proof (chain)\npicking this:\n  monic b\n  monic a\n  lead_coeff b = lead_coeff (smult c a)\n  c \\<noteq> (0::'a)\n  b = smult c a", "have \"a = b\""], ["proof (prove)\nusing this:\n  monic b\n  monic a\n  lead_coeff b = lead_coeff (smult c a)\n  c \\<noteq> (0::'a)\n  b = smult c a\n\ngoal (1 subgoal):\n 1. a = b", "unfolding coeff_smult degree_smult_eq"], ["proof (prove)\nusing this:\n  monic b\n  monic a\n  lead_coeff b = c * coeff a (if c = (0::'a) then 0 else degree a)\n  c \\<noteq> (0::'a)\n  b = smult c a\n\ngoal (1 subgoal):\n 1. a = b", "by auto"], ["proof (state)\nthis:\n  a = b\n\ngoal (2 subgoals):\n 1. \\<And>q.\n       \\<lbrakk>0 < degree q; q \\<noteq> 0; q * q dvd A i\\<rbrakk>\n       \\<Longrightarrow> False\n 2. A i \\<noteq> 0", "with neq"], ["proof (chain)\npicking this:\n  b \\<noteq> a\n  a = b", "show False"], ["proof (prove)\nusing this:\n  b \\<noteq> a\n  a = b\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. A i \\<noteq> 0", "qed (insert A_monic[of i], auto)"], ["", "lemma prod_A_is_p_B_bound: assumes \"B n = 1\"\n  shows \"p = (\\<Prod>i = 0..< n. A i ^ Suc i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p = (\\<Prod>i = 0..<n. A i ^ Suc i)", "proof (rule prod_A_is_p_unknown)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a i. (a, i) \\<in> as \\<Longrightarrow> i < n", "fix a i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a i. (a, i) \\<in> as \\<Longrightarrow> i < n", "assume ai: \"(a,i) \\<in> as\""], ["proof (state)\nthis:\n  (a, i) \\<in> as\n\ngoal (1 subgoal):\n 1. \\<And>a i. (a, i) \\<in> as \\<Longrightarrow> i < n", "let ?rem = \"(\\<Prod>(a, i)\\<in>as - UNIV \\<times> {0..<n} - {(a,i)}. a)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a i. (a, i) \\<in> as \\<Longrightarrow> i < n", "have rem: \"?rem \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>(a, i)\\<in>as - UNIV \\<times> {0..<n} - {(a, i)}. a) \\<noteq> 0", "by (rule nonzero_gen, auto)"], ["proof (state)\nthis:\n  (\\<Prod>(a, i)\\<in>as - UNIV \\<times> {0..<n} - {(a, i)}. a) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>a i. (a, i) \\<in> as \\<Longrightarrow> i < n", "have \"irreducible\\<^sub>d a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. irreducible\\<^sub>d a", "using as_irred[OF ai]"], ["proof (prove)\nusing this:\n  irreducible\\<^sub>d a\n\ngoal (1 subgoal):\n 1. irreducible\\<^sub>d a", "."], ["proof (state)\nthis:\n  irreducible\\<^sub>d a\n\ngoal (1 subgoal):\n 1. \\<And>a i. (a, i) \\<in> as \\<Longrightarrow> i < n", "hence a: \"a \\<noteq> 0\" \"degree a \\<noteq> 0\""], ["proof (prove)\nusing this:\n  irreducible\\<^sub>d a\n\ngoal (1 subgoal):\n 1. a \\<noteq> 0 &&& degree a \\<noteq> 0", "unfolding irreducible\\<^sub>d_def"], ["proof (prove)\nusing this:\n  0 < degree a \\<and>\n  (\\<forall>q r.\n      degree q < degree a \\<longrightarrow>\n      degree r < degree a \\<longrightarrow> a \\<noteq> q * r)\n\ngoal (1 subgoal):\n 1. a \\<noteq> 0 &&& degree a \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  a \\<noteq> 0\n  degree a \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>a i. (a, i) \\<in> as \\<Longrightarrow> i < n", "show \"i < n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < n", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> i < n \\<Longrightarrow> False", "assume \"\\<not> ?thesis\""], ["proof (state)\nthis:\n  \\<not> i < n\n\ngoal (1 subgoal):\n 1. \\<not> i < n \\<Longrightarrow> False", "hence \"i \\<ge> n\""], ["proof (prove)\nusing this:\n  \\<not> i < n\n\ngoal (1 subgoal):\n 1. n \\<le> i", "by auto"], ["proof (state)\nthis:\n  n \\<le> i\n\ngoal (1 subgoal):\n 1. \\<not> i < n \\<Longrightarrow> False", "with ai"], ["proof (chain)\npicking this:\n  (a, i) \\<in> as\n  n \\<le> i", "have mem: \"(a,i) \\<in> as - UNIV \\<times> {0 ..< n}\""], ["proof (prove)\nusing this:\n  (a, i) \\<in> as\n  n \\<le> i\n\ngoal (1 subgoal):\n 1. (a, i) \\<in> as - UNIV \\<times> {0..<n}", "by auto"], ["proof (state)\nthis:\n  (a, i) \\<in> as - UNIV \\<times> {0..<n}\n\ngoal (1 subgoal):\n 1. \\<not> i < n \\<Longrightarrow> False", "have \"0 = degree (\\<Prod>(a, i)\\<in>as - UNIV \\<times> {0..<n}. a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 = degree (\\<Prod>(a, i)\\<in>as - UNIV \\<times> {0..<n}. a)", "using assms"], ["proof (prove)\nusing this:\n  B n = 1\n\ngoal (1 subgoal):\n 1. 0 = degree (\\<Prod>(a, i)\\<in>as - UNIV \\<times> {0..<n}. a)", "unfolding B"], ["proof (prove)\nusing this:\n  (\\<Prod>(a, i)\\<in>as - UNIV \\<times> {0..<n}. a) = 1\n\ngoal (1 subgoal):\n 1. 0 = degree (\\<Prod>(a, i)\\<in>as - UNIV \\<times> {0..<n}. a)", "by simp"], ["proof (state)\nthis:\n  0 = degree (\\<Prod>(a, i)\\<in>as - UNIV \\<times> {0..<n}. a)\n\ngoal (1 subgoal):\n 1. \\<not> i < n \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  0 = degree (\\<Prod>(a, i)\\<in>as - UNIV \\<times> {0..<n}. a)\n\ngoal (1 subgoal):\n 1. \\<not> i < n \\<Longrightarrow> False", "have \"\\<dots> = degree (a * ?rem)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (\\<Prod>(a, i)\\<in>as - UNIV \\<times> {0..<n}. a) =\n    degree\n     (a * (\\<Prod>(a, i)\\<in>as - UNIV \\<times> {0..<n} - {(a, i)}. a))", "by (subst prod.remove[OF _ mem], insert fin, auto)"], ["proof (state)\nthis:\n  degree (\\<Prod>(a, i)\\<in>as - UNIV \\<times> {0..<n}. a) =\n  degree (a * (\\<Prod>(a, i)\\<in>as - UNIV \\<times> {0..<n} - {(a, i)}. a))\n\ngoal (1 subgoal):\n 1. \\<not> i < n \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  degree (\\<Prod>(a, i)\\<in>as - UNIV \\<times> {0..<n}. a) =\n  degree (a * (\\<Prod>(a, i)\\<in>as - UNIV \\<times> {0..<n} - {(a, i)}. a))\n\ngoal (1 subgoal):\n 1. \\<not> i < n \\<Longrightarrow> False", "have \"\\<dots> = degree a + degree ?rem\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree\n     (a * (\\<Prod>(a, i)\\<in>as - UNIV \\<times> {0..<n} - {(a, i)}. a)) =\n    degree a +\n    degree (\\<Prod>(a, i)\\<in>as - UNIV \\<times> {0..<n} - {(a, i)}. a)", "by (rule degree_mult_eq[OF a(1) rem])"], ["proof (state)\nthis:\n  degree\n   (a * (\\<Prod>(a, i)\\<in>as - UNIV \\<times> {0..<n} - {(a, i)}. a)) =\n  degree a +\n  degree (\\<Prod>(a, i)\\<in>as - UNIV \\<times> {0..<n} - {(a, i)}. a)\n\ngoal (1 subgoal):\n 1. \\<not> i < n \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  0 =\n  degree a +\n  degree (\\<Prod>(a, i)\\<in>as - UNIV \\<times> {0..<n} - {(a, i)}. a)", "show False"], ["proof (prove)\nusing this:\n  0 =\n  degree a +\n  degree (\\<Prod>(a, i)\\<in>as - UNIV \\<times> {0..<n} - {(a, i)}. a)\n\ngoal (1 subgoal):\n 1. False", "using a(2)"], ["proof (prove)\nusing this:\n  0 =\n  degree a +\n  degree (\\<Prod>(a, i)\\<in>as - UNIV \\<times> {0..<n} - {(a, i)}. a)\n  degree a \\<noteq> 0\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  i < n\n\ngoal:\nNo subgoals!", "qed"], ["", "interpretation yun_gcd gcd"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma square_free_monic_poly: \"(poly (square_free_monic_poly p) x = 0) = (poly p x = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (poly (square_free_monic_poly p) x = (0::'a)) = (poly p x = (0::'a))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (poly (square_free_monic_poly p) x = (0::'a)) = (poly p x = (0::'a))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (poly (square_free_monic_poly p) x = (0::'a)) = (poly p x = (0::'a))", "unfolding square_free_monic_poly_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (poly (p div gcd p (pderiv p)) x = (0::'a)) = (poly p x = (0::'a))", "unfolding p_div_gcd_p_pderiv"], ["proof (prove)\ngoal (1 subgoal):\n 1. (poly (\\<Prod>(a, i)\\<in>as. a) x = (0::'a)) = (poly p x = (0::'a))", "unfolding p poly_prod prod_zero_iff[OF fin]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>a\\<in>as.\n        poly (case a of (a, i) \\<Rightarrow> a) x = (0::'a)) =\n    (\\<exists>a\\<in>as.\n        poly (case a of (a, i) \\<Rightarrow> a ^ Suc i) x = (0::'a))", "by force"], ["proof (state)\nthis:\n  (poly (square_free_monic_poly p) x = (0::'a)) = (poly p x = (0::'a))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma yun_factorization_induct: assumes base: \"\\<And> bn cn. bn = 1 \\<Longrightarrow> P bn cn\"\n  and step: \"\\<And> bn cn. bn \\<noteq> 1 \\<Longrightarrow> P (bn div (gcd bn (cn - pderiv bn))) \n    ((cn - pderiv bn) div (gcd bn (cn - pderiv bn))) \\<Longrightarrow> P bn cn\"\n  and id: \"bn = p div gcd p (pderiv p)\" \"cn = pderiv p div gcd p (pderiv p)\"\n  shows \"P bn cn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P bn cn", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P bn cn", "define n where \"n = (0 :: nat)\""], ["proof (state)\nthis:\n  n = 0\n\ngoal (1 subgoal):\n 1. P bn cn", "let ?m = \"\\<lambda> n. bound - n\""], ["proof (state)\ngoal (1 subgoal):\n 1. P bn cn", "have \"P (B n) (C n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P (B n) (C n)", "proof (induct n rule: wf_induct[OF wf_measure[of ?m]])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<forall>y.\n          (y, x) \\<in> measure ((-) bound) \\<longrightarrow>\n          P (B y) (C y) \\<Longrightarrow>\n       P (B x) (C x)", "case (1 n)"], ["proof (state)\nthis:\n  \\<forall>y.\n     (y, n) \\<in> measure ((-) bound) \\<longrightarrow> P (B y) (C y)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<forall>y.\n          (y, x) \\<in> measure ((-) bound) \\<longrightarrow>\n          P (B y) (C y) \\<Longrightarrow>\n       P (B x) (C x)", "note IH = 1(1)[rule_format]"], ["proof (state)\nthis:\n  (?y, n) \\<in> measure ((-) bound) \\<Longrightarrow> P (B ?y) (C ?y)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<forall>y.\n          (y, x) \\<in> measure ((-) bound) \\<longrightarrow>\n          P (B y) (C y) \\<Longrightarrow>\n       P (B x) (C x)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. P (B n) (C n)", "proof (cases \"B n = 1\")"], ["proof (state)\ngoal (2 subgoals):\n 1. B n = 1 \\<Longrightarrow> P (B n) (C n)\n 2. B n \\<noteq> 1 \\<Longrightarrow> P (B n) (C n)", "case True"], ["proof (state)\nthis:\n  B n = 1\n\ngoal (2 subgoals):\n 1. B n = 1 \\<Longrightarrow> P (B n) (C n)\n 2. B n \\<noteq> 1 \\<Longrightarrow> P (B n) (C n)", "with base"], ["proof (chain)\npicking this:\n  ?bn1 = 1 \\<Longrightarrow> P ?bn1 ?cn1\n  B n = 1", "show ?thesis"], ["proof (prove)\nusing this:\n  ?bn1 = 1 \\<Longrightarrow> P ?bn1 ?cn1\n  B n = 1\n\ngoal (1 subgoal):\n 1. P (B n) (C n)", "by auto"], ["proof (state)\nthis:\n  P (B n) (C n)\n\ngoal (1 subgoal):\n 1. B n \\<noteq> 1 \\<Longrightarrow> P (B n) (C n)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. B n \\<noteq> 1 \\<Longrightarrow> P (B n) (C n)", "case False"], ["proof (state)\nthis:\n  B n \\<noteq> 1\n\ngoal (1 subgoal):\n 1. B n \\<noteq> 1 \\<Longrightarrow> P (B n) (C n)", "note Bn = this"], ["proof (state)\nthis:\n  B n \\<noteq> 1\n\ngoal (1 subgoal):\n 1. B n \\<noteq> 1 \\<Longrightarrow> P (B n) (C n)", "with bound[of n]"], ["proof (chain)\npicking this:\n  bound \\<le> n \\<Longrightarrow> B n = 1\n  B n \\<noteq> 1", "have \"\\<not> bound \\<le> n\""], ["proof (prove)\nusing this:\n  bound \\<le> n \\<Longrightarrow> B n = 1\n  B n \\<noteq> 1\n\ngoal (1 subgoal):\n 1. \\<not> bound \\<le> n", "by auto"], ["proof (state)\nthis:\n  \\<not> bound \\<le> n\n\ngoal (1 subgoal):\n 1. B n \\<noteq> 1 \\<Longrightarrow> P (B n) (C n)", "hence \"(Suc n, n) \\<in> measure ?m\""], ["proof (prove)\nusing this:\n  \\<not> bound \\<le> n\n\ngoal (1 subgoal):\n 1. (Suc n, n) \\<in> measure ((-) bound)", "by auto"], ["proof (state)\nthis:\n  (Suc n, n) \\<in> measure ((-) bound)\n\ngoal (1 subgoal):\n 1. B n \\<noteq> 1 \\<Longrightarrow> P (B n) (C n)", "note IH = IH[OF this]"], ["proof (state)\nthis:\n  P (B (Suc n)) (C (Suc n))\n\ngoal (1 subgoal):\n 1. B n \\<noteq> 1 \\<Longrightarrow> P (B n) (C n)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. P (B n) (C n)", "by (rule step[OF Bn], insert IH, simp add: D.simps C.simps B.simps A.simps)"], ["proof (state)\nthis:\n  P (B n) (C n)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  P (B n) (C n)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  P (B n) (C n)\n\ngoal (1 subgoal):\n 1. P bn cn", "thus ?thesis"], ["proof (prove)\nusing this:\n  P (B n) (C n)\n\ngoal (1 subgoal):\n 1. P bn cn", "unfolding id n_def B.simps C.simps"], ["proof (prove)\nusing this:\n  P (p div gcd p (pderiv p)) (pderiv p div gcd p (pderiv p))\n\ngoal (1 subgoal):\n 1. P (p div gcd p (pderiv p)) (pderiv p div gcd p (pderiv p))", "."], ["proof (state)\nthis:\n  P bn cn\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma yun_factorization_main: assumes \"yun_factorization_main (B n) (C n) n bs = cs\"\n  \"set bs = {(A i, i) | i. i < n}\" \"distinct (map snd bs)\"\n  shows \"\\<exists> m. set cs = {(A i, i) | i. i < m} \\<and> B m = 1 \\<and> distinct (map snd cs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>m.\n       set cs = {(A i, i) |i. i < m} \\<and>\n       B m = 1 \\<and> distinct (map snd cs)", "using assms"], ["proof (prove)\nusing this:\n  yun_factorization_main (B n) (C n) n bs = cs\n  set bs = {(A i, i) |i. i < n}\n  distinct (map snd bs)\n\ngoal (1 subgoal):\n 1. \\<exists>m.\n       set cs = {(A i, i) |i. i < m} \\<and>\n       B m = 1 \\<and> distinct (map snd cs)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>yun_factorization_main (B n) (C n) n bs = cs;\n     set bs = {(A i, i) |i. i < n}; distinct (map snd bs)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>m.\n                         set cs = {(A i, i) |i. i < m} \\<and>\n                         B m = 1 \\<and> distinct (map snd cs)", "let ?m = \"\\<lambda> n. bound - n\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>yun_factorization_main (B n) (C n) n bs = cs;\n     set bs = {(A i, i) |i. i < n}; distinct (map snd bs)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>m.\n                         set cs = {(A i, i) |i. i < m} \\<and>\n                         B m = 1 \\<and> distinct (map snd cs)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>m.\n       set cs = {(A i, i) |i. i < m} \\<and>\n       B m = 1 \\<and> distinct (map snd cs)", "using assms"], ["proof (prove)\nusing this:\n  yun_factorization_main (B n) (C n) n bs = cs\n  set bs = {(A i, i) |i. i < n}\n  distinct (map snd bs)\n\ngoal (1 subgoal):\n 1. \\<exists>m.\n       set cs = {(A i, i) |i. i < m} \\<and>\n       B m = 1 \\<and> distinct (map snd cs)", "proof (induct n arbitrary: bs rule: wf_induct[OF wf_measure[of ?m]])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x bs.\n       \\<lbrakk>\\<forall>y.\n                   (y, x) \\<in> measure ((-) bound) \\<longrightarrow>\n                   (\\<forall>x.\n                       yun_factorization_main (B y) (C y) y x =\n                       cs \\<longrightarrow>\n                       set x = {(A i, i) |i. i < y} \\<longrightarrow>\n                       distinct (map snd x) \\<longrightarrow>\n                       (\\<exists>m.\n                           set cs = {(A i, i) |i. i < m} \\<and>\n                           B m = 1 \\<and> distinct (map snd cs)));\n        yun_factorization_main (B x) (C x) x bs = cs;\n        set bs = {(A i, i) |i. i < x}; distinct (map snd bs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            set cs = {(A i, i) |i. i < m} \\<and>\n                            B m = 1 \\<and> distinct (map snd cs)", "case (1 n)"], ["proof (state)\nthis:\n  \\<forall>y.\n     (y, n) \\<in> measure ((-) bound) \\<longrightarrow>\n     (\\<forall>x.\n         yun_factorization_main (B y) (C y) y x = cs \\<longrightarrow>\n         set x = {(A i, i) |i. i < y} \\<longrightarrow>\n         distinct (map snd x) \\<longrightarrow>\n         (\\<exists>m.\n             set cs = {(A i, i) |i. i < m} \\<and>\n             B m = 1 \\<and> distinct (map snd cs)))\n  yun_factorization_main (B n) (C n) n bs = cs\n  set bs = {(A i, i) |i. i < n}\n  distinct (map snd bs)\n\ngoal (1 subgoal):\n 1. \\<And>x bs.\n       \\<lbrakk>\\<forall>y.\n                   (y, x) \\<in> measure ((-) bound) \\<longrightarrow>\n                   (\\<forall>x.\n                       yun_factorization_main (B y) (C y) y x =\n                       cs \\<longrightarrow>\n                       set x = {(A i, i) |i. i < y} \\<longrightarrow>\n                       distinct (map snd x) \\<longrightarrow>\n                       (\\<exists>m.\n                           set cs = {(A i, i) |i. i < m} \\<and>\n                           B m = 1 \\<and> distinct (map snd cs)));\n        yun_factorization_main (B x) (C x) x bs = cs;\n        set bs = {(A i, i) |i. i < x}; distinct (map snd bs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            set cs = {(A i, i) |i. i < m} \\<and>\n                            B m = 1 \\<and> distinct (map snd cs)", "note IH = 1(1)[rule_format]"], ["proof (state)\nthis:\n  \\<lbrakk>(?y, n) \\<in> measure ((-) bound);\n   yun_factorization_main (B ?y) (C ?y) ?y ?x = cs;\n   set ?x = {(A i, i) |i. i < ?y}; distinct (map snd ?x)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>m.\n                       set cs = {(A i, i) |i. i < m} \\<and>\n                       B m = 1 \\<and> distinct (map snd cs)\n\ngoal (1 subgoal):\n 1. \\<And>x bs.\n       \\<lbrakk>\\<forall>y.\n                   (y, x) \\<in> measure ((-) bound) \\<longrightarrow>\n                   (\\<forall>x.\n                       yun_factorization_main (B y) (C y) y x =\n                       cs \\<longrightarrow>\n                       set x = {(A i, i) |i. i < y} \\<longrightarrow>\n                       distinct (map snd x) \\<longrightarrow>\n                       (\\<exists>m.\n                           set cs = {(A i, i) |i. i < m} \\<and>\n                           B m = 1 \\<and> distinct (map snd cs)));\n        yun_factorization_main (B x) (C x) x bs = cs;\n        set bs = {(A i, i) |i. i < x}; distinct (map snd bs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            set cs = {(A i, i) |i. i < m} \\<and>\n                            B m = 1 \\<and> distinct (map snd cs)", "have res: \"yun_factorization_main (B n) (C n) n bs = cs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. yun_factorization_main (B n) (C n) n bs = cs", "by fact"], ["proof (state)\nthis:\n  yun_factorization_main (B n) (C n) n bs = cs\n\ngoal (1 subgoal):\n 1. \\<And>x bs.\n       \\<lbrakk>\\<forall>y.\n                   (y, x) \\<in> measure ((-) bound) \\<longrightarrow>\n                   (\\<forall>x.\n                       yun_factorization_main (B y) (C y) y x =\n                       cs \\<longrightarrow>\n                       set x = {(A i, i) |i. i < y} \\<longrightarrow>\n                       distinct (map snd x) \\<longrightarrow>\n                       (\\<exists>m.\n                           set cs = {(A i, i) |i. i < m} \\<and>\n                           B m = 1 \\<and> distinct (map snd cs)));\n        yun_factorization_main (B x) (C x) x bs = cs;\n        set bs = {(A i, i) |i. i < x}; distinct (map snd bs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            set cs = {(A i, i) |i. i < m} \\<and>\n                            B m = 1 \\<and> distinct (map snd cs)", "note res = res[unfolded yun_factorization_main.simps[of \"B n\"]]"], ["proof (state)\nthis:\n  (if B n = 1 then bs\n   else let dn = C n - pderiv (B n); an = gcd (B n) dn\n        in yun_factorization_main (B n div an) (dn div an) (Suc n)\n            ((an, n) # bs)) =\n  cs\n\ngoal (1 subgoal):\n 1. \\<And>x bs.\n       \\<lbrakk>\\<forall>y.\n                   (y, x) \\<in> measure ((-) bound) \\<longrightarrow>\n                   (\\<forall>x.\n                       yun_factorization_main (B y) (C y) y x =\n                       cs \\<longrightarrow>\n                       set x = {(A i, i) |i. i < y} \\<longrightarrow>\n                       distinct (map snd x) \\<longrightarrow>\n                       (\\<exists>m.\n                           set cs = {(A i, i) |i. i < m} \\<and>\n                           B m = 1 \\<and> distinct (map snd cs)));\n        yun_factorization_main (B x) (C x) x bs = cs;\n        set bs = {(A i, i) |i. i < x}; distinct (map snd bs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            set cs = {(A i, i) |i. i < m} \\<and>\n                            B m = 1 \\<and> distinct (map snd cs)", "have bs: \"set bs = {(A i, i) |i. i < n}\" \"distinct (map snd bs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set bs = {(A i, i) |i. i < n} &&& distinct (map snd bs)", "by fact+"], ["proof (state)\nthis:\n  set bs = {(A i, i) |i. i < n}\n  distinct (map snd bs)\n\ngoal (1 subgoal):\n 1. \\<And>x bs.\n       \\<lbrakk>\\<forall>y.\n                   (y, x) \\<in> measure ((-) bound) \\<longrightarrow>\n                   (\\<forall>x.\n                       yun_factorization_main (B y) (C y) y x =\n                       cs \\<longrightarrow>\n                       set x = {(A i, i) |i. i < y} \\<longrightarrow>\n                       distinct (map snd x) \\<longrightarrow>\n                       (\\<exists>m.\n                           set cs = {(A i, i) |i. i < m} \\<and>\n                           B m = 1 \\<and> distinct (map snd cs)));\n        yun_factorization_main (B x) (C x) x bs = cs;\n        set bs = {(A i, i) |i. i < x}; distinct (map snd bs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            set cs = {(A i, i) |i. i < m} \\<and>\n                            B m = 1 \\<and> distinct (map snd cs)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>m.\n       set cs = {(A i, i) |i. i < m} \\<and>\n       B m = 1 \\<and> distinct (map snd cs)", "proof (cases \"B n = 1\")"], ["proof (state)\ngoal (2 subgoals):\n 1. B n = 1 \\<Longrightarrow>\n    \\<exists>m.\n       set cs = {(A i, i) |i. i < m} \\<and>\n       B m = 1 \\<and> distinct (map snd cs)\n 2. B n \\<noteq> 1 \\<Longrightarrow>\n    \\<exists>m.\n       set cs = {(A i, i) |i. i < m} \\<and>\n       B m = 1 \\<and> distinct (map snd cs)", "case True"], ["proof (state)\nthis:\n  B n = 1\n\ngoal (2 subgoals):\n 1. B n = 1 \\<Longrightarrow>\n    \\<exists>m.\n       set cs = {(A i, i) |i. i < m} \\<and>\n       B m = 1 \\<and> distinct (map snd cs)\n 2. B n \\<noteq> 1 \\<Longrightarrow>\n    \\<exists>m.\n       set cs = {(A i, i) |i. i < m} \\<and>\n       B m = 1 \\<and> distinct (map snd cs)", "with res"], ["proof (chain)\npicking this:\n  (if B n = 1 then bs\n   else let dn = C n - pderiv (B n); an = gcd (B n) dn\n        in yun_factorization_main (B n div an) (dn div an) (Suc n)\n            ((an, n) # bs)) =\n  cs\n  B n = 1", "have \"bs = cs\""], ["proof (prove)\nusing this:\n  (if B n = 1 then bs\n   else let dn = C n - pderiv (B n); an = gcd (B n) dn\n        in yun_factorization_main (B n div an) (dn div an) (Suc n)\n            ((an, n) # bs)) =\n  cs\n  B n = 1\n\ngoal (1 subgoal):\n 1. bs = cs", "by auto"], ["proof (state)\nthis:\n  bs = cs\n\ngoal (2 subgoals):\n 1. B n = 1 \\<Longrightarrow>\n    \\<exists>m.\n       set cs = {(A i, i) |i. i < m} \\<and>\n       B m = 1 \\<and> distinct (map snd cs)\n 2. B n \\<noteq> 1 \\<Longrightarrow>\n    \\<exists>m.\n       set cs = {(A i, i) |i. i < m} \\<and>\n       B m = 1 \\<and> distinct (map snd cs)", "with True bs"], ["proof (chain)\npicking this:\n  B n = 1\n  set bs = {(A i, i) |i. i < n}\n  distinct (map snd bs)\n  bs = cs", "show ?thesis"], ["proof (prove)\nusing this:\n  B n = 1\n  set bs = {(A i, i) |i. i < n}\n  distinct (map snd bs)\n  bs = cs\n\ngoal (1 subgoal):\n 1. \\<exists>m.\n       set cs = {(A i, i) |i. i < m} \\<and>\n       B m = 1 \\<and> distinct (map snd cs)", "by auto"], ["proof (state)\nthis:\n  \\<exists>m.\n     set cs = {(A i, i) |i. i < m} \\<and>\n     B m = 1 \\<and> distinct (map snd cs)\n\ngoal (1 subgoal):\n 1. B n \\<noteq> 1 \\<Longrightarrow>\n    \\<exists>m.\n       set cs = {(A i, i) |i. i < m} \\<and>\n       B m = 1 \\<and> distinct (map snd cs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. B n \\<noteq> 1 \\<Longrightarrow>\n    \\<exists>m.\n       set cs = {(A i, i) |i. i < m} \\<and>\n       B m = 1 \\<and> distinct (map snd cs)", "case False"], ["proof (state)\nthis:\n  B n \\<noteq> 1\n\ngoal (1 subgoal):\n 1. B n \\<noteq> 1 \\<Longrightarrow>\n    \\<exists>m.\n       set cs = {(A i, i) |i. i < m} \\<and>\n       B m = 1 \\<and> distinct (map snd cs)", "note Bn = this"], ["proof (state)\nthis:\n  B n \\<noteq> 1\n\ngoal (1 subgoal):\n 1. B n \\<noteq> 1 \\<Longrightarrow>\n    \\<exists>m.\n       set cs = {(A i, i) |i. i < m} \\<and>\n       B m = 1 \\<and> distinct (map snd cs)", "with bound[of n]"], ["proof (chain)\npicking this:\n  bound \\<le> n \\<Longrightarrow> B n = 1\n  B n \\<noteq> 1", "have \"\\<not> bound \\<le> n\""], ["proof (prove)\nusing this:\n  bound \\<le> n \\<Longrightarrow> B n = 1\n  B n \\<noteq> 1\n\ngoal (1 subgoal):\n 1. \\<not> bound \\<le> n", "by auto"], ["proof (state)\nthis:\n  \\<not> bound \\<le> n\n\ngoal (1 subgoal):\n 1. B n \\<noteq> 1 \\<Longrightarrow>\n    \\<exists>m.\n       set cs = {(A i, i) |i. i < m} \\<and>\n       B m = 1 \\<and> distinct (map snd cs)", "hence \"(Suc n, n) \\<in> measure ?m\""], ["proof (prove)\nusing this:\n  \\<not> bound \\<le> n\n\ngoal (1 subgoal):\n 1. (Suc n, n) \\<in> measure ((-) bound)", "by auto"], ["proof (state)\nthis:\n  (Suc n, n) \\<in> measure ((-) bound)\n\ngoal (1 subgoal):\n 1. B n \\<noteq> 1 \\<Longrightarrow>\n    \\<exists>m.\n       set cs = {(A i, i) |i. i < m} \\<and>\n       B m = 1 \\<and> distinct (map snd cs)", "note IH = IH[OF this]"], ["proof (state)\nthis:\n  \\<lbrakk>yun_factorization_main (B (Suc n)) (C (Suc n)) (Suc n) ?x = cs;\n   set ?x = {(A i, i) |i. i < Suc n}; distinct (map snd ?x)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>m.\n                       set cs = {(A i, i) |i. i < m} \\<and>\n                       B m = 1 \\<and> distinct (map snd cs)\n\ngoal (1 subgoal):\n 1. B n \\<noteq> 1 \\<Longrightarrow>\n    \\<exists>m.\n       set cs = {(A i, i) |i. i < m} \\<and>\n       B m = 1 \\<and> distinct (map snd cs)", "from Bn res[unfolded Let_def, folded D.simps C.simps B.simps A.simps]"], ["proof (chain)\npicking this:\n  B n \\<noteq> 1\n  (if B n = 1 then bs\n   else yun_factorization_main (B (Suc n)) (C (Suc n)) (Suc n)\n         ((A n, n) # bs)) =\n  cs", "have res: \"yun_factorization_main (B (Suc n)) (C (Suc n)) (Suc n) ((A n, n) # bs) = cs\""], ["proof (prove)\nusing this:\n  B n \\<noteq> 1\n  (if B n = 1 then bs\n   else yun_factorization_main (B (Suc n)) (C (Suc n)) (Suc n)\n         ((A n, n) # bs)) =\n  cs\n\ngoal (1 subgoal):\n 1. yun_factorization_main (B (Suc n)) (C (Suc n)) (Suc n) ((A n, n) # bs) =\n    cs", "by simp"], ["proof (state)\nthis:\n  yun_factorization_main (B (Suc n)) (C (Suc n)) (Suc n) ((A n, n) # bs) =\n  cs\n\ngoal (1 subgoal):\n 1. B n \\<noteq> 1 \\<Longrightarrow>\n    \\<exists>m.\n       set cs = {(A i, i) |i. i < m} \\<and>\n       B m = 1 \\<and> distinct (map snd cs)", "note IH = IH[OF this]"], ["proof (state)\nthis:\n  \\<lbrakk>set ((A n, n) # bs) = {(A i, i) |i. i < Suc n};\n   distinct (map snd ((A n, n) # bs))\\<rbrakk>\n  \\<Longrightarrow> \\<exists>m.\n                       set cs = {(A i, i) |i. i < m} \\<and>\n                       B m = 1 \\<and> distinct (map snd cs)\n\ngoal (1 subgoal):\n 1. B n \\<noteq> 1 \\<Longrightarrow>\n    \\<exists>m.\n       set cs = {(A i, i) |i. i < m} \\<and>\n       B m = 1 \\<and> distinct (map snd cs)", "{"], ["proof (state)\nthis:\n  \\<lbrakk>set ((A n, n) # bs) = {(A i, i) |i. i < Suc n};\n   distinct (map snd ((A n, n) # bs))\\<rbrakk>\n  \\<Longrightarrow> \\<exists>m.\n                       set cs = {(A i, i) |i. i < m} \\<and>\n                       B m = 1 \\<and> distinct (map snd cs)\n\ngoal (1 subgoal):\n 1. B n \\<noteq> 1 \\<Longrightarrow>\n    \\<exists>m.\n       set cs = {(A i, i) |i. i < m} \\<and>\n       B m = 1 \\<and> distinct (map snd cs)", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. B n \\<noteq> 1 \\<Longrightarrow>\n    \\<exists>m.\n       set cs = {(A i, i) |i. i < m} \\<and>\n       B m = 1 \\<and> distinct (map snd cs)", "assume \"i < Suc n\" \"\\<not> i < n\""], ["proof (state)\nthis:\n  i < Suc n\n  \\<not> i < n\n\ngoal (1 subgoal):\n 1. B n \\<noteq> 1 \\<Longrightarrow>\n    \\<exists>m.\n       set cs = {(A i, i) |i. i < m} \\<and>\n       B m = 1 \\<and> distinct (map snd cs)", "hence \"n = i\""], ["proof (prove)\nusing this:\n  i < Suc n\n  \\<not> i < n\n\ngoal (1 subgoal):\n 1. n = i", "by arith"], ["proof (state)\nthis:\n  n = i\n\ngoal (1 subgoal):\n 1. B n \\<noteq> 1 \\<Longrightarrow>\n    \\<exists>m.\n       set cs = {(A i, i) |i. i < m} \\<and>\n       B m = 1 \\<and> distinct (map snd cs)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?i3 < Suc n; \\<not> ?i3 < n\\<rbrakk> \\<Longrightarrow> n = ?i3\n\ngoal (1 subgoal):\n 1. B n \\<noteq> 1 \\<Longrightarrow>\n    \\<exists>m.\n       set cs = {(A i, i) |i. i < m} \\<and>\n       B m = 1 \\<and> distinct (map snd cs)", "note missing = this"], ["proof (state)\nthis:\n  \\<lbrakk>?i3 < Suc n; \\<not> ?i3 < n\\<rbrakk> \\<Longrightarrow> n = ?i3\n\ngoal (1 subgoal):\n 1. B n \\<noteq> 1 \\<Longrightarrow>\n    \\<exists>m.\n       set cs = {(A i, i) |i. i < m} \\<and>\n       B m = 1 \\<and> distinct (map snd cs)", "have \"set ((A n, n) # bs) = {(A i, i) |i. i < Suc n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set ((A n, n) # bs) = {(A i, i) |i. i < Suc n}", "unfolding list.simps bs"], ["proof (prove)\ngoal (1 subgoal):\n 1. insert (A n, n) {(A i, i) |i. i < n} = {(A i, i) |i. i < Suc n}", "by (auto, subst missing, auto)"], ["proof (state)\nthis:\n  set ((A n, n) # bs) = {(A i, i) |i. i < Suc n}\n\ngoal (1 subgoal):\n 1. B n \\<noteq> 1 \\<Longrightarrow>\n    \\<exists>m.\n       set cs = {(A i, i) |i. i < m} \\<and>\n       B m = 1 \\<and> distinct (map snd cs)", "note IH = IH[OF this]"], ["proof (state)\nthis:\n  distinct (map snd ((A n, n) # bs)) \\<Longrightarrow>\n  \\<exists>m.\n     set cs = {(A i, i) |i. i < m} \\<and>\n     B m = 1 \\<and> distinct (map snd cs)\n\ngoal (1 subgoal):\n 1. B n \\<noteq> 1 \\<Longrightarrow>\n    \\<exists>m.\n       set cs = {(A i, i) |i. i < m} \\<and>\n       B m = 1 \\<and> distinct (map snd cs)", "from bs"], ["proof (chain)\npicking this:\n  set bs = {(A i, i) |i. i < n}\n  distinct (map snd bs)", "have \"distinct (map snd ((A n, n) # bs))\""], ["proof (prove)\nusing this:\n  set bs = {(A i, i) |i. i < n}\n  distinct (map snd bs)\n\ngoal (1 subgoal):\n 1. distinct (map snd ((A n, n) # bs))", "by auto"], ["proof (state)\nthis:\n  distinct (map snd ((A n, n) # bs))\n\ngoal (1 subgoal):\n 1. B n \\<noteq> 1 \\<Longrightarrow>\n    \\<exists>m.\n       set cs = {(A i, i) |i. i < m} \\<and>\n       B m = 1 \\<and> distinct (map snd cs)", "note IH = IH[OF this]"], ["proof (state)\nthis:\n  \\<exists>m.\n     set cs = {(A i, i) |i. i < m} \\<and>\n     B m = 1 \\<and> distinct (map snd cs)\n\ngoal (1 subgoal):\n 1. B n \\<noteq> 1 \\<Longrightarrow>\n    \\<exists>m.\n       set cs = {(A i, i) |i. i < m} \\<and>\n       B m = 1 \\<and> distinct (map snd cs)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>m.\n       set cs = {(A i, i) |i. i < m} \\<and>\n       B m = 1 \\<and> distinct (map snd cs)", "by (rule IH)"], ["proof (state)\nthis:\n  \\<exists>m.\n     set cs = {(A i, i) |i. i < m} \\<and>\n     B m = 1 \\<and> distinct (map snd cs)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>m.\n     set cs = {(A i, i) |i. i < m} \\<and>\n     B m = 1 \\<and> distinct (map snd cs)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>m.\n     set cs = {(A i, i) |i. i < m} \\<and>\n     B m = 1 \\<and> distinct (map snd cs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma yun_monic_factorization_res: assumes res: \"yun_monic_factorization p = bs\"\n  shows \"\\<exists> m. set bs = {(A i, i) | i. i < m \\<and> A i \\<noteq> 1} \\<and> B m = 1 \\<and> distinct (map snd bs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>m.\n       set bs = {(A i, i) |i. i < m \\<and> A i \\<noteq> 1} \\<and>\n       B m = 1 \\<and> distinct (map snd bs)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>m.\n       set bs = {(A i, i) |i. i < m \\<and> A i \\<noteq> 1} \\<and>\n       B m = 1 \\<and> distinct (map snd bs)", "from res[unfolded yun_monic_factorization_def Let_def, \n    folded B.simps C.simps]"], ["proof (chain)\npicking this:\n  filter (\\<lambda>(a, i). a \\<noteq> 1)\n   (yun_factorization_main (B 0) (C 0) 0 []) =\n  bs", "obtain cs where yun: \"yun_factorization_main (B 0) (C 0) 0 [] = cs\" and bs: \"bs = filter (\\<lambda> (a,i). a \\<noteq> 1) cs\""], ["proof (prove)\nusing this:\n  filter (\\<lambda>(a, i). a \\<noteq> 1)\n   (yun_factorization_main (B 0) (C 0) 0 []) =\n  bs\n\ngoal (1 subgoal):\n 1. (\\<And>cs.\n        \\<lbrakk>yun_factorization_main (B 0) (C 0) 0 [] = cs;\n         bs = filter (\\<lambda>(a, i). a \\<noteq> 1) cs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  yun_factorization_main (B 0) (C 0) 0 [] = cs\n  bs = filter (\\<lambda>(a, i). a \\<noteq> 1) cs\n\ngoal (1 subgoal):\n 1. \\<exists>m.\n       set bs = {(A i, i) |i. i < m \\<and> A i \\<noteq> 1} \\<and>\n       B m = 1 \\<and> distinct (map snd bs)", "from yun_factorization_main[OF yun]"], ["proof (chain)\npicking this:\n  \\<lbrakk>set [] = {(A i, i) |i. i < 0}; distinct (map snd [])\\<rbrakk>\n  \\<Longrightarrow> \\<exists>m.\n                       set cs = {(A i, i) |i. i < m} \\<and>\n                       B m = 1 \\<and> distinct (map snd cs)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>set [] = {(A i, i) |i. i < 0}; distinct (map snd [])\\<rbrakk>\n  \\<Longrightarrow> \\<exists>m.\n                       set cs = {(A i, i) |i. i < m} \\<and>\n                       B m = 1 \\<and> distinct (map snd cs)\n\ngoal (1 subgoal):\n 1. \\<exists>m.\n       set bs = {(A i, i) |i. i < m \\<and> A i \\<noteq> 1} \\<and>\n       B m = 1 \\<and> distinct (map snd bs)", "unfolding bs"], ["proof (prove)\nusing this:\n  \\<lbrakk>set [] = {(A i, i) |i. i < 0}; distinct (map snd [])\\<rbrakk>\n  \\<Longrightarrow> \\<exists>m.\n                       set cs = {(A i, i) |i. i < m} \\<and>\n                       B m = 1 \\<and> distinct (map snd cs)\n\ngoal (1 subgoal):\n 1. \\<exists>m.\n       set (filter (\\<lambda>(a, i). a \\<noteq> 1) cs) =\n       {(A i, i) |i. i < m \\<and> A i \\<noteq> 1} \\<and>\n       B m = 1 \\<and>\n       distinct (map snd (filter (\\<lambda>(a, i). a \\<noteq> 1) cs))", "by (auto simp: distinct_map_filter)"], ["proof (state)\nthis:\n  \\<exists>m.\n     set bs = {(A i, i) |i. i < m \\<and> A i \\<noteq> 1} \\<and>\n     B m = 1 \\<and> distinct (map snd bs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma yun_monic_factorization: assumes yun: \"yun_monic_factorization p = bs\"\n  shows \"square_free_factorization p (1,bs)\" \"(b,i) \\<in> set bs \\<Longrightarrow> monic b\" \"distinct (map snd bs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. square_free_factorization p (1::'a, bs) &&&\n    ((b, i) \\<in> set bs \\<Longrightarrow> monic b) &&&\n    distinct (map snd bs)", "proof -"], ["proof (state)\ngoal (3 subgoals):\n 1. square_free_factorization p (1::'a, bs)\n 2. (b, i) \\<in> set bs \\<Longrightarrow> monic b\n 3. distinct (map snd bs)", "from yun_monic_factorization_res[OF yun]"], ["proof (chain)\npicking this:\n  \\<exists>m.\n     set bs = {(A i, i) |i. i < m \\<and> A i \\<noteq> 1} \\<and>\n     B m = 1 \\<and> distinct (map snd bs)", "obtain m where bs: \"set bs = {(A i, i) | i. i < m \\<and> A i \\<noteq> 1}\" and B: \"B m = 1\" \n    and dist: \"distinct (map snd bs)\""], ["proof (prove)\nusing this:\n  \\<exists>m.\n     set bs = {(A i, i) |i. i < m \\<and> A i \\<noteq> 1} \\<and>\n     B m = 1 \\<and> distinct (map snd bs)\n\ngoal (1 subgoal):\n 1. (\\<And>m.\n        \\<lbrakk>set bs = {(A i, i) |i. i < m \\<and> A i \\<noteq> 1};\n         B m = 1; distinct (map snd bs)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  set bs = {(A i, i) |i. i < m \\<and> A i \\<noteq> 1}\n  B m = 1\n  distinct (map snd bs)\n\ngoal (3 subgoals):\n 1. square_free_factorization p (1::'a, bs)\n 2. (b, i) \\<in> set bs \\<Longrightarrow> monic b\n 3. distinct (map snd bs)", "have id: \"{0 ..< m} = {i. i < m \\<and> A i = 1} \\<union> {i. i < m \\<and> A i \\<noteq> 1}\" (is \"_ = ?ignore \\<union> _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. {0..<m} =\n    {i. i < m \\<and> A i = 1} \\<union> {i. i < m \\<and> A i \\<noteq> 1}", "by auto"], ["proof (state)\nthis:\n  {0..<m} =\n  {i. i < m \\<and> A i = 1} \\<union> {i. i < m \\<and> A i \\<noteq> 1}\n\ngoal (3 subgoals):\n 1. square_free_factorization p (1::'a, bs)\n 2. (b, i) \\<in> set bs \\<Longrightarrow> monic b\n 3. distinct (map snd bs)", "have \"p = (\\<Prod>i = 0..<m. A i ^ Suc i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p = (\\<Prod>i = 0..<m. A i ^ Suc i)", "by (rule prod_A_is_p_B_bound[OF B])"], ["proof (state)\nthis:\n  p = (\\<Prod>i = 0..<m. A i ^ Suc i)\n\ngoal (3 subgoals):\n 1. square_free_factorization p (1::'a, bs)\n 2. (b, i) \\<in> set bs \\<Longrightarrow> monic b\n 3. distinct (map snd bs)", "also"], ["proof (state)\nthis:\n  p = (\\<Prod>i = 0..<m. A i ^ Suc i)\n\ngoal (3 subgoals):\n 1. square_free_factorization p (1::'a, bs)\n 2. (b, i) \\<in> set bs \\<Longrightarrow> monic b\n 3. distinct (map snd bs)", "have \"\\<dots> = prod (\\<lambda> i. A i ^ Suc i) {i. i < m \\<and> A i \\<noteq> 1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>i = 0..<m. A i ^ Suc i) =\n    (\\<Prod>i\\<in>{i. i < m \\<and> A i \\<noteq> 1}. A i ^ Suc i)", "unfolding id"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>i\\<in>{i. i < m \\<and> A i = 1} \\<union>\n                  {i. i < m \\<and> A i \\<noteq> 1}.\n       A i ^ Suc i) =\n    (\\<Prod>i\\<in>{i. i < m \\<and> A i \\<noteq> 1}. A i ^ Suc i)", "by (subst prod.union_disjoint, (force+)[3],\n    subst prod.neutral[of ?ignore], auto)"], ["proof (state)\nthis:\n  (\\<Prod>i = 0..<m. A i ^ Suc i) =\n  (\\<Prod>i\\<in>{i. i < m \\<and> A i \\<noteq> 1}. A i ^ Suc i)\n\ngoal (3 subgoals):\n 1. square_free_factorization p (1::'a, bs)\n 2. (b, i) \\<in> set bs \\<Longrightarrow> monic b\n 3. distinct (map snd bs)", "also"], ["proof (state)\nthis:\n  (\\<Prod>i = 0..<m. A i ^ Suc i) =\n  (\\<Prod>i\\<in>{i. i < m \\<and> A i \\<noteq> 1}. A i ^ Suc i)\n\ngoal (3 subgoals):\n 1. square_free_factorization p (1::'a, bs)\n 2. (b, i) \\<in> set bs \\<Longrightarrow> monic b\n 3. distinct (map snd bs)", "have \"\\<dots> = (\\<Prod>(a, i)\\<in> set bs. a ^ Suc i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>i\\<in>{i. i < m \\<and> A i \\<noteq> 1}. A i ^ Suc i) =\n    (\\<Prod>(a, i)\\<in>set bs. a ^ Suc i)", "unfolding bs"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>i\\<in>{i. i < m \\<and> A i \\<noteq> 1}. A i ^ Suc i) =\n    (\\<Prod>(a, i)\\<in>{(A i, i) |i. i < m \\<and> A i \\<noteq> 1}.\n       a ^ Suc i)", "by (rule prod.reindex_cong[of snd], auto simp: inj_on_def, force)"], ["proof (state)\nthis:\n  (\\<Prod>i\\<in>{i. i < m \\<and> A i \\<noteq> 1}. A i ^ Suc i) =\n  (\\<Prod>(a, i)\\<in>set bs. a ^ Suc i)\n\ngoal (3 subgoals):\n 1. square_free_factorization p (1::'a, bs)\n 2. (b, i) \\<in> set bs \\<Longrightarrow> monic b\n 3. distinct (map snd bs)", "finally"], ["proof (chain)\npicking this:\n  p = (\\<Prod>(a, i)\\<in>set bs. a ^ Suc i)", "have 1: \"p = (\\<Prod>(a, i)\\<in> set bs. a ^ Suc i)\""], ["proof (prove)\nusing this:\n  p = (\\<Prod>(a, i)\\<in>set bs. a ^ Suc i)\n\ngoal (1 subgoal):\n 1. p = (\\<Prod>(a, i)\\<in>set bs. a ^ Suc i)", "."], ["proof (state)\nthis:\n  p = (\\<Prod>(a, i)\\<in>set bs. a ^ Suc i)\n\ngoal (3 subgoals):\n 1. square_free_factorization p (1::'a, bs)\n 2. (b, i) \\<in> set bs \\<Longrightarrow> monic b\n 3. distinct (map snd bs)", "{"], ["proof (state)\nthis:\n  p = (\\<Prod>(a, i)\\<in>set bs. a ^ Suc i)\n\ngoal (3 subgoals):\n 1. square_free_factorization p (1::'a, bs)\n 2. (b, i) \\<in> set bs \\<Longrightarrow> monic b\n 3. distinct (map snd bs)", "fix a i"], ["proof (state)\ngoal (3 subgoals):\n 1. square_free_factorization p (1::'a, bs)\n 2. (b, i) \\<in> set bs \\<Longrightarrow> monic b\n 3. distinct (map snd bs)", "assume \"(a,i) \\<in> set bs\""], ["proof (state)\nthis:\n  (a, i) \\<in> set bs\n\ngoal (3 subgoals):\n 1. square_free_factorization p (1::'a, bs)\n 2. (b, i) \\<in> set bs \\<Longrightarrow> monic b\n 3. distinct (map snd bs)", "hence A: \"a = A i\" \"A i \\<noteq> 1\""], ["proof (prove)\nusing this:\n  (a, i) \\<in> set bs\n\ngoal (1 subgoal):\n 1. a = A i &&& A i \\<noteq> 1", "unfolding bs"], ["proof (prove)\nusing this:\n  (a, i) \\<in> {(A i, i) |i. i < m \\<and> A i \\<noteq> 1}\n\ngoal (1 subgoal):\n 1. a = A i &&& A i \\<noteq> 1", "by auto"], ["proof (state)\nthis:\n  a = A i\n  A i \\<noteq> 1\n\ngoal (3 subgoals):\n 1. square_free_factorization p (1::'a, bs)\n 2. (b, i) \\<in> set bs \\<Longrightarrow> monic b\n 3. distinct (map snd bs)", "with A_square_free[of i] A_monic[of i]"], ["proof (chain)\npicking this:\n  square_free (A i)\n  monic (A i)\n  a = A i\n  A i \\<noteq> 1", "have \"square_free a \\<and> degree a \\<noteq> 0\" \"monic a\""], ["proof (prove)\nusing this:\n  square_free (A i)\n  monic (A i)\n  a = A i\n  A i \\<noteq> 1\n\ngoal (1 subgoal):\n 1. square_free a \\<and> degree a \\<noteq> 0 &&& monic a", "by (auto simp: monic_degree_0)"], ["proof (state)\nthis:\n  square_free a \\<and> degree a \\<noteq> 0\n  monic a\n\ngoal (3 subgoals):\n 1. square_free_factorization p (1::'a, bs)\n 2. (b, i) \\<in> set bs \\<Longrightarrow> monic b\n 3. distinct (map snd bs)", "}"], ["proof (state)\nthis:\n  (?a3, ?ia3) \\<in> set bs \\<Longrightarrow>\n  square_free ?a3 \\<and> degree ?a3 \\<noteq> 0\n  (?a3, ?ia3) \\<in> set bs \\<Longrightarrow> monic ?a3\n\ngoal (3 subgoals):\n 1. square_free_factorization p (1::'a, bs)\n 2. (b, i) \\<in> set bs \\<Longrightarrow> monic b\n 3. distinct (map snd bs)", "note 2 = this"], ["proof (state)\nthis:\n  (?a3, ?ia3) \\<in> set bs \\<Longrightarrow>\n  square_free ?a3 \\<and> degree ?a3 \\<noteq> 0\n  (?a3, ?ia3) \\<in> set bs \\<Longrightarrow> monic ?a3\n\ngoal (3 subgoals):\n 1. square_free_factorization p (1::'a, bs)\n 2. (b, i) \\<in> set bs \\<Longrightarrow> monic b\n 3. distinct (map snd bs)", "{"], ["proof (state)\nthis:\n  (?a3, ?ia3) \\<in> set bs \\<Longrightarrow>\n  square_free ?a3 \\<and> degree ?a3 \\<noteq> 0\n  (?a3, ?ia3) \\<in> set bs \\<Longrightarrow> monic ?a3\n\ngoal (3 subgoals):\n 1. square_free_factorization p (1::'a, bs)\n 2. (b, i) \\<in> set bs \\<Longrightarrow> monic b\n 3. distinct (map snd bs)", "fix a i b j"], ["proof (state)\ngoal (3 subgoals):\n 1. square_free_factorization p (1::'a, bs)\n 2. (b, i) \\<in> set bs \\<Longrightarrow> monic b\n 3. distinct (map snd bs)", "assume ai: \"(a,i) \\<in> set bs\" and bj: \"(b,j) \\<in> set bs\" and neq: \"(a,i) \\<noteq> (b,j)\""], ["proof (state)\nthis:\n  (a, i) \\<in> set bs\n  (b, j) \\<in> set bs\n  (a, i) \\<noteq> (b, j)\n\ngoal (3 subgoals):\n 1. square_free_factorization p (1::'a, bs)\n 2. (b, i) \\<in> set bs \\<Longrightarrow> monic b\n 3. distinct (map snd bs)", "hence a: \"a = A i\" and b: \"b = A j\""], ["proof (prove)\nusing this:\n  (a, i) \\<in> set bs\n  (b, j) \\<in> set bs\n  (a, i) \\<noteq> (b, j)\n\ngoal (1 subgoal):\n 1. a = A i &&& b = A j", "unfolding bs"], ["proof (prove)\nusing this:\n  (a, i) \\<in> {(A i, i) |i. i < m \\<and> A i \\<noteq> 1}\n  (b, j) \\<in> {(A i, i) |i. i < m \\<and> A i \\<noteq> 1}\n  (a, i) \\<noteq> (b, j)\n\ngoal (1 subgoal):\n 1. a = A i &&& b = A j", "by auto"], ["proof (state)\nthis:\n  a = A i\n  b = A j\n\ngoal (3 subgoals):\n 1. square_free_factorization p (1::'a, bs)\n 2. (b, i) \\<in> set bs \\<Longrightarrow> monic b\n 3. distinct (map snd bs)", "from neq dist ai bj"], ["proof (chain)\npicking this:\n  (a, i) \\<noteq> (b, j)\n  distinct (map snd bs)\n  (a, i) \\<in> set bs\n  (b, j) \\<in> set bs", "have neq: \"i \\<noteq> j\""], ["proof (prove)\nusing this:\n  (a, i) \\<noteq> (b, j)\n  distinct (map snd bs)\n  (a, i) \\<in> set bs\n  (b, j) \\<in> set bs\n\ngoal (1 subgoal):\n 1. i \\<noteq> j", "using a b"], ["proof (prove)\nusing this:\n  (a, i) \\<noteq> (b, j)\n  distinct (map snd bs)\n  (a, i) \\<in> set bs\n  (b, j) \\<in> set bs\n  a = A i\n  b = A j\n\ngoal (1 subgoal):\n 1. i \\<noteq> j", "by blast"], ["proof (state)\nthis:\n  i \\<noteq> j\n\ngoal (3 subgoals):\n 1. square_free_factorization p (1::'a, bs)\n 2. (b, i) \\<in> set bs \\<Longrightarrow> monic b\n 3. distinct (map snd bs)", "from coprime_A_A [OF neq]"], ["proof (chain)\npicking this:\n  coprime (A i) (A j)", "have \"coprime a b\""], ["proof (prove)\nusing this:\n  coprime (A i) (A j)\n\ngoal (1 subgoal):\n 1. coprime a b", "unfolding a b"], ["proof (prove)\nusing this:\n  coprime (A i) (A j)\n\ngoal (1 subgoal):\n 1. coprime (A i) (A j)", "."], ["proof (state)\nthis:\n  coprime a b\n\ngoal (3 subgoals):\n 1. square_free_factorization p (1::'a, bs)\n 2. (b, i) \\<in> set bs \\<Longrightarrow> monic b\n 3. distinct (map snd bs)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>(?a3, ?ia3) \\<in> set bs; (?ba3, ?j3) \\<in> set bs;\n   (?a3, ?ia3) \\<noteq> (?ba3, ?j3)\\<rbrakk>\n  \\<Longrightarrow> coprime ?a3 ?ba3\n\ngoal (3 subgoals):\n 1. square_free_factorization p (1::'a, bs)\n 2. (b, i) \\<in> set bs \\<Longrightarrow> monic b\n 3. distinct (map snd bs)", "note 3 = this"], ["proof (state)\nthis:\n  \\<lbrakk>(?a3, ?ia3) \\<in> set bs; (?ba3, ?j3) \\<in> set bs;\n   (?a3, ?ia3) \\<noteq> (?ba3, ?j3)\\<rbrakk>\n  \\<Longrightarrow> coprime ?a3 ?ba3\n\ngoal (3 subgoals):\n 1. square_free_factorization p (1::'a, bs)\n 2. (b, i) \\<in> set bs \\<Longrightarrow> monic b\n 3. distinct (map snd bs)", "have \"monic p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monic p", "unfolding p"], ["proof (prove)\ngoal (1 subgoal):\n 1. monic (\\<Prod>(a, i)\\<in>as. a ^ Suc i)", "by (rule monic_prod, insert as_monic, auto intro: monic_power monic_mult)"], ["proof (state)\nthis:\n  monic p\n\ngoal (3 subgoals):\n 1. square_free_factorization p (1::'a, bs)\n 2. (b, i) \\<in> set bs \\<Longrightarrow> monic b\n 3. distinct (map snd bs)", "hence 4: \"p \\<noteq> 0\""], ["proof (prove)\nusing this:\n  monic p\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  p \\<noteq> 0\n\ngoal (3 subgoals):\n 1. square_free_factorization p (1::'a, bs)\n 2. (b, i) \\<in> set bs \\<Longrightarrow> monic b\n 3. distinct (map snd bs)", "from dist"], ["proof (chain)\npicking this:\n  distinct (map snd bs)", "have 5: \"distinct bs\""], ["proof (prove)\nusing this:\n  distinct (map snd bs)\n\ngoal (1 subgoal):\n 1. distinct bs", "unfolding distinct_map"], ["proof (prove)\nusing this:\n  distinct bs \\<and> inj_on snd (set bs)\n\ngoal (1 subgoal):\n 1. distinct bs", ".."], ["proof (state)\nthis:\n  distinct bs\n\ngoal (3 subgoals):\n 1. square_free_factorization p (1::'a, bs)\n 2. (b, i) \\<in> set bs \\<Longrightarrow> monic b\n 3. distinct (map snd bs)", "show \"square_free_factorization p (1,bs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. square_free_factorization p (1::'a, bs)", "unfolding square_free_factorization_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. case (1::'a, bs) of\n    (c, bs) \\<Rightarrow>\n      p = smult c (\\<Prod>(a, i)\\<in>set bs. a ^ Suc i) \\<and>\n      (p = 0 \\<longrightarrow> c = (0::'a) \\<and> bs = []) \\<and>\n      (\\<forall>a i.\n          (a, i) \\<in> set bs \\<longrightarrow>\n          square_free a \\<and> 0 < degree a) \\<and>\n      (\\<forall>a i b j.\n          (a, i) \\<in> set bs \\<longrightarrow>\n          (b, j) \\<in> set bs \\<longrightarrow>\n          (a, i) \\<noteq> (b, j) \\<longrightarrow> coprime a b) \\<and>\n      distinct bs", "using 1 2 3 4 5"], ["proof (prove)\nusing this:\n  p = (\\<Prod>(a, i)\\<in>set bs. a ^ Suc i)\n  (?a3, ?ia3) \\<in> set bs \\<Longrightarrow>\n  square_free ?a3 \\<and> degree ?a3 \\<noteq> 0\n  (?a3, ?ia3) \\<in> set bs \\<Longrightarrow> monic ?a3\n  \\<lbrakk>(?a3, ?ia3) \\<in> set bs; (?ba3, ?j3) \\<in> set bs;\n   (?a3, ?ia3) \\<noteq> (?ba3, ?j3)\\<rbrakk>\n  \\<Longrightarrow> coprime ?a3 ?ba3\n  p \\<noteq> 0\n  distinct bs\n\ngoal (1 subgoal):\n 1. case (1::'a, bs) of\n    (c, bs) \\<Rightarrow>\n      p = smult c (\\<Prod>(a, i)\\<in>set bs. a ^ Suc i) \\<and>\n      (p = 0 \\<longrightarrow> c = (0::'a) \\<and> bs = []) \\<and>\n      (\\<forall>a i.\n          (a, i) \\<in> set bs \\<longrightarrow>\n          square_free a \\<and> 0 < degree a) \\<and>\n      (\\<forall>a i b j.\n          (a, i) \\<in> set bs \\<longrightarrow>\n          (b, j) \\<in> set bs \\<longrightarrow>\n          (a, i) \\<noteq> (b, j) \\<longrightarrow> coprime a b) \\<and>\n      distinct bs", "by auto"], ["proof (state)\nthis:\n  square_free_factorization p (1::'a, bs)\n\ngoal (2 subgoals):\n 1. (b, i) \\<in> set bs \\<Longrightarrow> monic b\n 2. distinct (map snd bs)", "show \"(b,i) \\<in> set bs \\<Longrightarrow> monic b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (b, i) \\<in> set bs \\<Longrightarrow> monic b", "using 2"], ["proof (prove)\nusing this:\n  (?a3, ?ia3) \\<in> set bs \\<Longrightarrow>\n  square_free ?a3 \\<and> degree ?a3 \\<noteq> 0\n  (?a3, ?ia3) \\<in> set bs \\<Longrightarrow> monic ?a3\n\ngoal (1 subgoal):\n 1. (b, i) \\<in> set bs \\<Longrightarrow> monic b", "by auto"], ["proof (state)\nthis:\n  (b, i) \\<in> set bs \\<Longrightarrow> monic b\n\ngoal (1 subgoal):\n 1. distinct (map snd bs)", "show \"distinct (map snd bs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map snd bs)", "by fact"], ["proof (state)\nthis:\n  distinct (map snd bs)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "lemma monic_factorization: assumes \"monic p\"\n  shows \"\\<exists> as. monic_factorization as p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>as. monic_factorization as p", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>as. monic_factorization as p", "from monic_irreducible_factorization[OF assms]"], ["proof (chain)\npicking this:\n  \\<exists>as f.\n     finite as \\<and>\n     p = (\\<Prod>a\\<in>as. a ^ Suc (f a)) \\<and>\n     as \\<subseteq> {q. irreducible q \\<and> monic q}", "obtain as f where fin: \"finite as\" and p: \"p = (\\<Prod>a\\<in>as. a ^ Suc (f a))\" \n    and as: \"as \\<subseteq> {q. irreducible\\<^sub>d q \\<and> monic q}\""], ["proof (prove)\nusing this:\n  \\<exists>as f.\n     finite as \\<and>\n     p = (\\<Prod>a\\<in>as. a ^ Suc (f a)) \\<and>\n     as \\<subseteq> {q. irreducible q \\<and> monic q}\n\ngoal (1 subgoal):\n 1. (\\<And>as f.\n        \\<lbrakk>finite as; p = (\\<Prod>a\\<in>as. a ^ Suc (f a));\n         as \\<subseteq> {q. irreducible\\<^sub>d q \\<and> monic q}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  finite as\n  p = (\\<Prod>a\\<in>as. a ^ Suc (f a))\n  as \\<subseteq> {q. irreducible\\<^sub>d q \\<and> monic q}\n\ngoal (1 subgoal):\n 1. \\<exists>as. monic_factorization as p", "define cs where \"cs = {(a, f a) | a. a \\<in> as}\""], ["proof (state)\nthis:\n  cs = {(a, f a) |a. a \\<in> as}\n\ngoal (1 subgoal):\n 1. \\<exists>as. monic_factorization as p", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>as. monic_factorization as p", "proof (rule exI, standard)"], ["proof (state)\ngoal (5 subgoals):\n 1. p = (\\<Prod>(a, i)\\<in>?as. a ^ Suc i)\n 2. finite ?as\n 3. \\<And>a i b j.\n       \\<lbrakk>(a, i) \\<in> ?as; (b, j) \\<in> ?as;\n        (a, i) \\<noteq> (b, j)\\<rbrakk>\n       \\<Longrightarrow> a \\<noteq> b\n 4. \\<And>a i. (a, i) \\<in> ?as \\<Longrightarrow> irreducible\\<^sub>d a\n 5. \\<And>a i. (a, i) \\<in> ?as \\<Longrightarrow> monic a", "show \"finite cs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite cs", "unfolding cs_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {(a, f a) |a. a \\<in> as}", "using fin"], ["proof (prove)\nusing this:\n  finite as\n\ngoal (1 subgoal):\n 1. finite {(a, f a) |a. a \\<in> as}", "by auto"], ["proof (state)\nthis:\n  finite cs\n\ngoal (4 subgoals):\n 1. p = (\\<Prod>(a, i)\\<in>cs. a ^ Suc i)\n 2. \\<And>a i b j.\n       \\<lbrakk>(a, i) \\<in> cs; (b, j) \\<in> cs;\n        (a, i) \\<noteq> (b, j)\\<rbrakk>\n       \\<Longrightarrow> a \\<noteq> b\n 3. \\<And>a i. (a, i) \\<in> cs \\<Longrightarrow> irreducible\\<^sub>d a\n 4. \\<And>a i. (a, i) \\<in> cs \\<Longrightarrow> monic a", "{"], ["proof (state)\nthis:\n  finite cs\n\ngoal (4 subgoals):\n 1. p = (\\<Prod>(a, i)\\<in>cs. a ^ Suc i)\n 2. \\<And>a i b j.\n       \\<lbrakk>(a, i) \\<in> cs; (b, j) \\<in> cs;\n        (a, i) \\<noteq> (b, j)\\<rbrakk>\n       \\<Longrightarrow> a \\<noteq> b\n 3. \\<And>a i. (a, i) \\<in> cs \\<Longrightarrow> irreducible\\<^sub>d a\n 4. \\<And>a i. (a, i) \\<in> cs \\<Longrightarrow> monic a", "fix a i"], ["proof (state)\ngoal (4 subgoals):\n 1. p = (\\<Prod>(a, i)\\<in>cs. a ^ Suc i)\n 2. \\<And>a i b j.\n       \\<lbrakk>(a, i) \\<in> cs; (b, j) \\<in> cs;\n        (a, i) \\<noteq> (b, j)\\<rbrakk>\n       \\<Longrightarrow> a \\<noteq> b\n 3. \\<And>a i. (a, i) \\<in> cs \\<Longrightarrow> irreducible\\<^sub>d a\n 4. \\<And>a i. (a, i) \\<in> cs \\<Longrightarrow> monic a", "assume \"(a,i) \\<in> cs\""], ["proof (state)\nthis:\n  (a, i) \\<in> cs\n\ngoal (4 subgoals):\n 1. p = (\\<Prod>(a, i)\\<in>cs. a ^ Suc i)\n 2. \\<And>a i b j.\n       \\<lbrakk>(a, i) \\<in> cs; (b, j) \\<in> cs;\n        (a, i) \\<noteq> (b, j)\\<rbrakk>\n       \\<Longrightarrow> a \\<noteq> b\n 3. \\<And>a i. (a, i) \\<in> cs \\<Longrightarrow> irreducible\\<^sub>d a\n 4. \\<And>a i. (a, i) \\<in> cs \\<Longrightarrow> monic a", "thus \"irreducible\\<^sub>d a\" \"monic a\""], ["proof (prove)\nusing this:\n  (a, i) \\<in> cs\n\ngoal (1 subgoal):\n 1. irreducible\\<^sub>d a &&& monic a", "unfolding cs_def"], ["proof (prove)\nusing this:\n  (a, i) \\<in> {(a, f a) |a. a \\<in> as}\n\ngoal (1 subgoal):\n 1. irreducible\\<^sub>d a &&& monic a", "using as"], ["proof (prove)\nusing this:\n  (a, i) \\<in> {(a, f a) |a. a \\<in> as}\n  as \\<subseteq> {q. irreducible\\<^sub>d q \\<and> monic q}\n\ngoal (1 subgoal):\n 1. irreducible\\<^sub>d a &&& monic a", "by auto"], ["proof (state)\nthis:\n  irreducible\\<^sub>d a\n  monic a\n\ngoal (2 subgoals):\n 1. p = (\\<Prod>(a, i)\\<in>cs. a ^ Suc i)\n 2. \\<And>a i b j.\n       \\<lbrakk>(a, i) \\<in> cs; (b, j) \\<in> cs;\n        (a, i) \\<noteq> (b, j)\\<rbrakk>\n       \\<Longrightarrow> a \\<noteq> b", "}"], ["proof (state)\nthis:\n  (?a2, ?i2) \\<in> cs \\<Longrightarrow> irreducible\\<^sub>d ?a2\n  (?a2, ?i2) \\<in> cs \\<Longrightarrow> monic ?a2\n\ngoal (2 subgoals):\n 1. p = (\\<Prod>(a, i)\\<in>cs. a ^ Suc i)\n 2. \\<And>a i b j.\n       \\<lbrakk>(a, i) \\<in> cs; (b, j) \\<in> cs;\n        (a, i) \\<noteq> (b, j)\\<rbrakk>\n       \\<Longrightarrow> a \\<noteq> b", "note irr = this"], ["proof (state)\nthis:\n  (?a2, ?i2) \\<in> cs \\<Longrightarrow> irreducible\\<^sub>d ?a2\n  (?a2, ?i2) \\<in> cs \\<Longrightarrow> monic ?a2\n\ngoal (2 subgoals):\n 1. p = (\\<Prod>(a, i)\\<in>cs. a ^ Suc i)\n 2. \\<And>a i b j.\n       \\<lbrakk>(a, i) \\<in> cs; (b, j) \\<in> cs;\n        (a, i) \\<noteq> (b, j)\\<rbrakk>\n       \\<Longrightarrow> a \\<noteq> b", "show \"\\<And>a i b j. (a, i) \\<in> cs \\<Longrightarrow> (b, j) \\<in> cs \\<Longrightarrow> (a, i) \\<noteq> (b, j) \\<Longrightarrow> a \\<noteq> b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a i b j.\n       \\<lbrakk>(a, i) \\<in> cs; (b, j) \\<in> cs;\n        (a, i) \\<noteq> (b, j)\\<rbrakk>\n       \\<Longrightarrow> a \\<noteq> b", "unfolding cs_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a i b j.\n       \\<lbrakk>(a, i) \\<in> {(a, f a) |a. a \\<in> as};\n        (b, j) \\<in> {(a, f a) |a. a \\<in> as};\n        (a, i) \\<noteq> (b, j)\\<rbrakk>\n       \\<Longrightarrow> a \\<noteq> b", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>(?a, ?i) \\<in> cs; (?b, ?j) \\<in> cs;\n   (?a, ?i) \\<noteq> (?b, ?j)\\<rbrakk>\n  \\<Longrightarrow> ?a \\<noteq> ?b\n\ngoal (1 subgoal):\n 1. p = (\\<Prod>(a, i)\\<in>cs. a ^ Suc i)", "show \"p = (\\<Prod>(a, i)\\<in>cs. a ^ Suc i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p = (\\<Prod>(a, i)\\<in>cs. a ^ Suc i)", "unfolding p cs_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>a\\<in>as. a ^ Suc (f a)) =\n    (\\<Prod>(a, i)\\<in>{(a, f a) |a. a \\<in> as}. a ^ Suc i)", "by (rule prod.reindex_cong, auto, auto simp: inj_on_def)"], ["proof (state)\nthis:\n  p = (\\<Prod>(a, i)\\<in>cs. a ^ Suc i)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>as. monic_factorization as p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma square_free_monic_poly:\n  assumes \"monic (p :: 'a :: {field_char_0, euclidean_ring_gcd,semiring_gcd_mult_normalize} poly)\"\n  shows \"(poly (yun_gcd.square_free_monic_poly gcd p) x = 0) = (poly p x = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (poly (yun_gcd.square_free_monic_poly gcd p) x = (0::'a)) =\n    (poly p x = (0::'a))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (poly (yun_gcd.square_free_monic_poly gcd p) x = (0::'a)) =\n    (poly p x = (0::'a))", "from monic_factorization[OF assms]"], ["proof (chain)\npicking this:\n  \\<exists>as. monic_factorization as p", "obtain as where \"monic_factorization as p\""], ["proof (prove)\nusing this:\n  \\<exists>as. monic_factorization as p\n\ngoal (1 subgoal):\n 1. (\\<And>as.\n        monic_factorization as p \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  monic_factorization as p\n\ngoal (1 subgoal):\n 1. (poly (yun_gcd.square_free_monic_poly gcd p) x = (0::'a)) =\n    (poly p x = (0::'a))", "from monic_factorization.square_free_monic_poly[OF this]"], ["proof (chain)\npicking this:\n  (poly (yun_gcd.square_free_monic_poly gcd p) ?x = (0::'a)) =\n  (poly p ?x = (0::'a))", "show ?thesis"], ["proof (prove)\nusing this:\n  (poly (yun_gcd.square_free_monic_poly gcd p) ?x = (0::'a)) =\n  (poly p ?x = (0::'a))\n\ngoal (1 subgoal):\n 1. (poly (yun_gcd.square_free_monic_poly gcd p) x = (0::'a)) =\n    (poly p x = (0::'a))", "."], ["proof (state)\nthis:\n  (poly (yun_gcd.square_free_monic_poly gcd p) x = (0::'a)) =\n  (poly p x = (0::'a))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma yun_factorization_induct: \n  assumes base: \"\\<And> bn cn. bn = 1 \\<Longrightarrow> P bn cn\"\n  and step: \"\\<And> bn cn. bn \\<noteq> 1 \\<Longrightarrow> P (bn div (gcd bn (cn - pderiv bn))) \n    ((cn - pderiv bn) div (gcd bn (cn - pderiv bn))) \\<Longrightarrow> P bn cn\"\n  and id: \"bn = p div gcd p (pderiv p)\" \"cn = pderiv p div gcd p (pderiv p)\"\n  and monic: \"monic (p :: 'a :: {field_char_0,euclidean_ring_gcd,semiring_gcd_mult_normalize} poly)\"\n  shows \"P bn cn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P bn cn", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P bn cn", "from monic_factorization[OF monic]"], ["proof (chain)\npicking this:\n  \\<exists>as. monic_factorization as p", "obtain as where \"monic_factorization as p\""], ["proof (prove)\nusing this:\n  \\<exists>as. monic_factorization as p\n\ngoal (1 subgoal):\n 1. (\\<And>as.\n        monic_factorization as p \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  monic_factorization as p\n\ngoal (1 subgoal):\n 1. P bn cn", "from monic_factorization.yun_factorization_induct[OF this base step id]"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<And>bn cn. bn = 1 \\<Longrightarrow> ?bn1 bn cn = 1;\n   \\<And>bn cn.\n      \\<lbrakk>bn \\<noteq> 1;\n       P (?bn1 (bn div gcd bn (cn - pderiv bn))\n           ((cn - pderiv bn) div gcd bn (cn - pderiv bn)))\n        (?cn1 (bn div gcd bn (cn - pderiv bn))\n          ((cn - pderiv bn) div gcd bn (cn - pderiv bn)))\\<rbrakk>\n      \\<Longrightarrow> ?bn1 bn cn \\<noteq> 1;\n   \\<And>bn cn.\n      \\<lbrakk>bn \\<noteq> 1;\n       P (?bn1 (bn div gcd bn (cn - pderiv bn))\n           ((cn - pderiv bn) div gcd bn (cn - pderiv bn)))\n        (?cn1 (bn div gcd bn (cn - pderiv bn))\n          ((cn - pderiv bn) div gcd bn (cn - pderiv bn)))\\<rbrakk>\n      \\<Longrightarrow> P (?bn1 bn cn div\n                           gcd (?bn1 bn cn)\n                            (?cn1 bn cn - pderiv (?bn1 bn cn)))\n                         ((?cn1 bn cn - pderiv (?bn1 bn cn)) div\n                          gcd (?bn1 bn cn)\n                           (?cn1 bn cn - pderiv (?bn1 bn cn)))\\<rbrakk>\n  \\<Longrightarrow> P (?bn1 bn cn) (?cn1 bn cn)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>bn cn. bn = 1 \\<Longrightarrow> ?bn1 bn cn = 1;\n   \\<And>bn cn.\n      \\<lbrakk>bn \\<noteq> 1;\n       P (?bn1 (bn div gcd bn (cn - pderiv bn))\n           ((cn - pderiv bn) div gcd bn (cn - pderiv bn)))\n        (?cn1 (bn div gcd bn (cn - pderiv bn))\n          ((cn - pderiv bn) div gcd bn (cn - pderiv bn)))\\<rbrakk>\n      \\<Longrightarrow> ?bn1 bn cn \\<noteq> 1;\n   \\<And>bn cn.\n      \\<lbrakk>bn \\<noteq> 1;\n       P (?bn1 (bn div gcd bn (cn - pderiv bn))\n           ((cn - pderiv bn) div gcd bn (cn - pderiv bn)))\n        (?cn1 (bn div gcd bn (cn - pderiv bn))\n          ((cn - pderiv bn) div gcd bn (cn - pderiv bn)))\\<rbrakk>\n      \\<Longrightarrow> P (?bn1 bn cn div\n                           gcd (?bn1 bn cn)\n                            (?cn1 bn cn - pderiv (?bn1 bn cn)))\n                         ((?cn1 bn cn - pderiv (?bn1 bn cn)) div\n                          gcd (?bn1 bn cn)\n                           (?cn1 bn cn - pderiv (?bn1 bn cn)))\\<rbrakk>\n  \\<Longrightarrow> P (?bn1 bn cn) (?cn1 bn cn)\n\ngoal (1 subgoal):\n 1. P bn cn", "."], ["proof (state)\nthis:\n  P bn cn\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma square_free_poly: \n  \"(poly (square_free_poly gcd p) x = 0) = (poly p x = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (poly (square_free_poly gcd p) x = (0::'a)) = (poly p x = (0::'a))", "proof (cases \"p = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow>\n    (poly (square_free_poly gcd p) x = (0::'a)) = (poly p x = (0::'a))\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    (poly (square_free_poly gcd p) x = (0::'a)) = (poly p x = (0::'a))", "case True"], ["proof (state)\nthis:\n  p = 0\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow>\n    (poly (square_free_poly gcd p) x = (0::'a)) = (poly p x = (0::'a))\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    (poly (square_free_poly gcd p) x = (0::'a)) = (poly p x = (0::'a))", "thus ?thesis"], ["proof (prove)\nusing this:\n  p = 0\n\ngoal (1 subgoal):\n 1. (poly (square_free_poly gcd p) x = (0::'a)) = (poly p x = (0::'a))", "unfolding square_free_poly_def"], ["proof (prove)\nusing this:\n  p = 0\n\ngoal (1 subgoal):\n 1. (poly\n      (if p = 0 then 0\n       else yun_gcd.square_free_monic_poly gcd\n             (smult (inverse (lead_coeff p)) p))\n      x =\n     (0::'a)) =\n    (poly p x = (0::'a))", "by auto"], ["proof (state)\nthis:\n  (poly (square_free_poly gcd p) x = (0::'a)) = (poly p x = (0::'a))\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    (poly (square_free_poly gcd p) x = (0::'a)) = (poly p x = (0::'a))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    (poly (square_free_poly gcd p) x = (0::'a)) = (poly p x = (0::'a))", "case False"], ["proof (state)\nthis:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    (poly (square_free_poly gcd p) x = (0::'a)) = (poly p x = (0::'a))", "let ?c = \"coeff p (degree p)\""], ["proof (state)\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    (poly (square_free_poly gcd p) x = (0::'a)) = (poly p x = (0::'a))", "let ?ic = \"inverse ?c\""], ["proof (state)\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    (poly (square_free_poly gcd p) x = (0::'a)) = (poly p x = (0::'a))", "have id: \"square_free_poly gcd p = yun_gcd.square_free_monic_poly gcd (smult ?ic p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. square_free_poly gcd p =\n    yun_gcd.square_free_monic_poly gcd (smult (inverse (lead_coeff p)) p)", "unfolding square_free_poly_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if p = 0 then 0\n     else yun_gcd.square_free_monic_poly gcd\n           (smult (inverse (lead_coeff p)) p)) =\n    yun_gcd.square_free_monic_poly gcd (smult (inverse (lead_coeff p)) p)", "using False"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (if p = 0 then 0\n     else yun_gcd.square_free_monic_poly gcd\n           (smult (inverse (lead_coeff p)) p)) =\n    yun_gcd.square_free_monic_poly gcd (smult (inverse (lead_coeff p)) p)", "by auto"], ["proof (state)\nthis:\n  square_free_poly gcd p =\n  yun_gcd.square_free_monic_poly gcd (smult (inverse (lead_coeff p)) p)\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    (poly (square_free_poly gcd p) x = (0::'a)) = (poly p x = (0::'a))", "from False"], ["proof (chain)\npicking this:\n  p \\<noteq> 0", "have mon: \"monic (smult ?ic p)\" and ic: \"?ic \\<noteq> 0\""], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. monic (smult (inverse (lead_coeff p)) p) &&&\n    inverse (lead_coeff p) \\<noteq> (0::'a)", "by auto"], ["proof (state)\nthis:\n  monic (smult (inverse (lead_coeff p)) p)\n  inverse (lead_coeff p) \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    (poly (square_free_poly gcd p) x = (0::'a)) = (poly p x = (0::'a))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (poly (square_free_poly gcd p) x = (0::'a)) = (poly p x = (0::'a))", "unfolding id square_free_monic_poly[OF mon]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (poly (smult (inverse (lead_coeff p)) p) x = (0::'a)) =\n    (poly p x = (0::'a))", "using ic"], ["proof (prove)\nusing this:\n  inverse (lead_coeff p) \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. (poly (smult (inverse (lead_coeff p)) p) x = (0::'a)) =\n    (poly p x = (0::'a))", "by simp"], ["proof (state)\nthis:\n  (poly (square_free_poly gcd p) x = (0::'a)) = (poly p x = (0::'a))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma yun_monic_factorization:\n  fixes p :: \"'a :: {field_char_0,euclidean_ring_gcd,semiring_gcd_mult_normalize} poly\" \n  assumes res: \"yun_gcd.yun_monic_factorization gcd p = bs\"\n  and monic: \"monic p\"\n  shows \"square_free_factorization p (1,bs)\" \"(b,i) \\<in> set bs \\<Longrightarrow> monic b\" \"distinct (map snd bs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. square_free_factorization p (1::'a, bs) &&&\n    ((b, i) \\<in> set bs \\<Longrightarrow> monic b) &&&\n    distinct (map snd bs)", "proof -"], ["proof (state)\ngoal (3 subgoals):\n 1. square_free_factorization p (1::'a, bs)\n 2. (b, i) \\<in> set bs \\<Longrightarrow> monic b\n 3. distinct (map snd bs)", "from monic_factorization[OF monic]"], ["proof (chain)\npicking this:\n  \\<exists>as. monic_factorization as p", "obtain as where \"monic_factorization as p\""], ["proof (prove)\nusing this:\n  \\<exists>as. monic_factorization as p\n\ngoal (1 subgoal):\n 1. (\\<And>as.\n        monic_factorization as p \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  monic_factorization as p\n\ngoal (3 subgoals):\n 1. square_free_factorization p (1::'a, bs)\n 2. (b, i) \\<in> set bs \\<Longrightarrow> monic b\n 3. distinct (map snd bs)", "from \"monic_factorization.yun_monic_factorization\"[OF this res]"], ["proof (chain)\npicking this:\n  square_free_factorization p (1::'a, bs)\n  (?b, ?i) \\<in> set bs \\<Longrightarrow> monic ?b\n  distinct (map snd bs)", "show \"square_free_factorization p (1,bs)\" \"(b,i) \\<in> set bs \\<Longrightarrow> monic b\" \"distinct (map snd bs)\""], ["proof (prove)\nusing this:\n  square_free_factorization p (1::'a, bs)\n  (?b, ?i) \\<in> set bs \\<Longrightarrow> monic ?b\n  distinct (map snd bs)\n\ngoal (1 subgoal):\n 1. square_free_factorization p (1::'a, bs) &&&\n    ((b, i) \\<in> set bs \\<Longrightarrow> monic b) &&&\n    distinct (map snd bs)", "by auto"], ["proof (state)\nthis:\n  square_free_factorization p (1::'a, bs)\n  (b, i) \\<in> set bs \\<Longrightarrow> monic b\n  distinct (map snd bs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma square_free_factorization_smult: assumes c: \"c \\<noteq> 0\"\n  and sf: \"square_free_factorization p (d,bs)\"\n  shows \"square_free_factorization (smult c p) (c * d, bs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. square_free_factorization (smult c p) (c * d, bs)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. square_free_factorization (smult c p) (c * d, bs)", "from sf[unfolded square_free_factorization_def split]"], ["proof (chain)\npicking this:\n  p = smult d (\\<Prod>(a, i)\\<in>set bs. a ^ Suc i) \\<and>\n  (p = 0 \\<longrightarrow> d = (0::'a) \\<and> bs = []) \\<and>\n  (\\<forall>a i.\n      (a, i) \\<in> set bs \\<longrightarrow>\n      square_free a \\<and> 0 < degree a) \\<and>\n  (\\<forall>a i b j.\n      (a, i) \\<in> set bs \\<longrightarrow>\n      (b, j) \\<in> set bs \\<longrightarrow>\n      (a, i) \\<noteq> (b, j) \\<longrightarrow> coprime a b) \\<and>\n  distinct bs", "have p: \"p = smult d (\\<Prod>(a, i)\\<in>set bs. a ^ Suc i)\"\n    and eq: \"p = 0 \\<longrightarrow> d = 0 \\<and> bs = []\""], ["proof (prove)\nusing this:\n  p = smult d (\\<Prod>(a, i)\\<in>set bs. a ^ Suc i) \\<and>\n  (p = 0 \\<longrightarrow> d = (0::'a) \\<and> bs = []) \\<and>\n  (\\<forall>a i.\n      (a, i) \\<in> set bs \\<longrightarrow>\n      square_free a \\<and> 0 < degree a) \\<and>\n  (\\<forall>a i b j.\n      (a, i) \\<in> set bs \\<longrightarrow>\n      (b, j) \\<in> set bs \\<longrightarrow>\n      (a, i) \\<noteq> (b, j) \\<longrightarrow> coprime a b) \\<and>\n  distinct bs\n\ngoal (1 subgoal):\n 1. p = smult d (\\<Prod>(a, i)\\<in>set bs. a ^ Suc i) &&&\n    p = 0 \\<longrightarrow> d = (0::'a) \\<and> bs = []", "by blast+"], ["proof (state)\nthis:\n  p = smult d (\\<Prod>(a, i)\\<in>set bs. a ^ Suc i)\n  p = 0 \\<longrightarrow> d = (0::'a) \\<and> bs = []\n\ngoal (1 subgoal):\n 1. square_free_factorization (smult c p) (c * d, bs)", "from eq c"], ["proof (chain)\npicking this:\n  p = 0 \\<longrightarrow> d = (0::'a) \\<and> bs = []\n  c \\<noteq> (0::'a)", "have eq: \"smult c p = 0 \\<longrightarrow> c * d = 0 \\<and> bs = []\""], ["proof (prove)\nusing this:\n  p = 0 \\<longrightarrow> d = (0::'a) \\<and> bs = []\n  c \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. smult c p = 0 \\<longrightarrow> c * d = (0::'a) \\<and> bs = []", "by auto"], ["proof (state)\nthis:\n  smult c p = 0 \\<longrightarrow> c * d = (0::'a) \\<and> bs = []\n\ngoal (1 subgoal):\n 1. square_free_factorization (smult c p) (c * d, bs)", "from p"], ["proof (chain)\npicking this:\n  p = smult d (\\<Prod>(a, i)\\<in>set bs. a ^ Suc i)", "have p: \"smult c p = smult (c * d) (\\<Prod>(a, i)\\<in>set bs. a ^ Suc i)\""], ["proof (prove)\nusing this:\n  p = smult d (\\<Prod>(a, i)\\<in>set bs. a ^ Suc i)\n\ngoal (1 subgoal):\n 1. smult c p = smult (c * d) (\\<Prod>(a, i)\\<in>set bs. a ^ Suc i)", "by auto"], ["proof (state)\nthis:\n  smult c p = smult (c * d) (\\<Prod>(a, i)\\<in>set bs. a ^ Suc i)\n\ngoal (1 subgoal):\n 1. square_free_factorization (smult c p) (c * d, bs)", "from eq p sf"], ["proof (chain)\npicking this:\n  smult c p = 0 \\<longrightarrow> c * d = (0::'a) \\<and> bs = []\n  smult c p = smult (c * d) (\\<Prod>(a, i)\\<in>set bs. a ^ Suc i)\n  square_free_factorization p (d, bs)", "show ?thesis"], ["proof (prove)\nusing this:\n  smult c p = 0 \\<longrightarrow> c * d = (0::'a) \\<and> bs = []\n  smult c p = smult (c * d) (\\<Prod>(a, i)\\<in>set bs. a ^ Suc i)\n  square_free_factorization p (d, bs)\n\ngoal (1 subgoal):\n 1. square_free_factorization (smult c p) (c * d, bs)", "unfolding square_free_factorization_def"], ["proof (prove)\nusing this:\n  smult c p = 0 \\<longrightarrow> c * d = (0::'a) \\<and> bs = []\n  smult c p = smult (c * d) (\\<Prod>(a, i)\\<in>set bs. a ^ Suc i)\n  case (d, bs) of\n  (c, bs) \\<Rightarrow>\n    p = smult c (\\<Prod>(a, i)\\<in>set bs. a ^ Suc i) \\<and>\n    (p = 0 \\<longrightarrow> c = (0::'a) \\<and> bs = []) \\<and>\n    (\\<forall>a i.\n        (a, i) \\<in> set bs \\<longrightarrow>\n        square_free a \\<and> 0 < degree a) \\<and>\n    (\\<forall>a i b j.\n        (a, i) \\<in> set bs \\<longrightarrow>\n        (b, j) \\<in> set bs \\<longrightarrow>\n        (a, i) \\<noteq> (b, j) \\<longrightarrow> coprime a b) \\<and>\n    distinct bs\n\ngoal (1 subgoal):\n 1. case (c * d, bs) of\n    (ca, bs) \\<Rightarrow>\n      smult c p = smult ca (\\<Prod>(a, i)\\<in>set bs. a ^ Suc i) \\<and>\n      (smult c p = 0 \\<longrightarrow> ca = (0::'a) \\<and> bs = []) \\<and>\n      (\\<forall>a i.\n          (a, i) \\<in> set bs \\<longrightarrow>\n          square_free a \\<and> 0 < degree a) \\<and>\n      (\\<forall>a i b j.\n          (a, i) \\<in> set bs \\<longrightarrow>\n          (b, j) \\<in> set bs \\<longrightarrow>\n          (a, i) \\<noteq> (b, j) \\<longrightarrow> coprime a b) \\<and>\n      distinct bs", "by blast"], ["proof (state)\nthis:\n  square_free_factorization (smult c p) (c * d, bs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma yun_factorization: assumes res: \"yun_factorization gcd p = c_bs\"\n  shows \"square_free_factorization p c_bs\" \"(b,i) \\<in> set (snd c_bs) \\<Longrightarrow> monic b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. square_free_factorization p c_bs &&&\n    ((b, i) \\<in> set (snd c_bs) \\<Longrightarrow> monic b)", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. square_free_factorization p c_bs\n 2. (b, i) \\<in> set (snd c_bs) \\<Longrightarrow> monic b", "interpret yun_gcd gcd"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["proof (state)\ngoal (2 subgoals):\n 1. square_free_factorization p c_bs\n 2. (b, i) \\<in> set (snd c_bs) \\<Longrightarrow> monic b", "note res = res[unfolded yun_factorization_def Let_def]"], ["proof (state)\nthis:\n  (if p = 0 then (0::'a, [])\n   else (lead_coeff p,\n         yun_monic_factorization (smult (inverse (lead_coeff p)) p))) =\n  c_bs\n\ngoal (2 subgoals):\n 1. square_free_factorization p c_bs\n 2. (b, i) \\<in> set (snd c_bs) \\<Longrightarrow> monic b", "have \"square_free_factorization p c_bs \\<and> ((b,i) \\<in> set (snd c_bs) \\<longrightarrow> monic b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. square_free_factorization p c_bs \\<and>\n    ((b, i) \\<in> set (snd c_bs) \\<longrightarrow> monic b)", "proof (cases \"p = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow>\n    square_free_factorization p c_bs \\<and>\n    ((b, i) \\<in> set (snd c_bs) \\<longrightarrow> monic b)\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    square_free_factorization p c_bs \\<and>\n    ((b, i) \\<in> set (snd c_bs) \\<longrightarrow> monic b)", "case True"], ["proof (state)\nthis:\n  p = 0\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow>\n    square_free_factorization p c_bs \\<and>\n    ((b, i) \\<in> set (snd c_bs) \\<longrightarrow> monic b)\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    square_free_factorization p c_bs \\<and>\n    ((b, i) \\<in> set (snd c_bs) \\<longrightarrow> monic b)", "with res"], ["proof (chain)\npicking this:\n  (if p = 0 then (0::'a, [])\n   else (lead_coeff p,\n         yun_monic_factorization (smult (inverse (lead_coeff p)) p))) =\n  c_bs\n  p = 0", "have \"c_bs = (0, [])\""], ["proof (prove)\nusing this:\n  (if p = 0 then (0::'a, [])\n   else (lead_coeff p,\n         yun_monic_factorization (smult (inverse (lead_coeff p)) p))) =\n  c_bs\n  p = 0\n\ngoal (1 subgoal):\n 1. c_bs = (0::'a, [])", "by auto"], ["proof (state)\nthis:\n  c_bs = (0::'a, [])\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow>\n    square_free_factorization p c_bs \\<and>\n    ((b, i) \\<in> set (snd c_bs) \\<longrightarrow> monic b)\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    square_free_factorization p c_bs \\<and>\n    ((b, i) \\<in> set (snd c_bs) \\<longrightarrow> monic b)", "thus ?thesis"], ["proof (prove)\nusing this:\n  c_bs = (0::'a, [])\n\ngoal (1 subgoal):\n 1. square_free_factorization p c_bs \\<and>\n    ((b, i) \\<in> set (snd c_bs) \\<longrightarrow> monic b)", "unfolding True"], ["proof (prove)\nusing this:\n  c_bs = (0::'a, [])\n\ngoal (1 subgoal):\n 1. square_free_factorization 0 c_bs \\<and>\n    ((b, i) \\<in> set (snd c_bs) \\<longrightarrow> monic b)", "by (auto simp: square_free_factorization_def)"], ["proof (state)\nthis:\n  square_free_factorization p c_bs \\<and>\n  ((b, i) \\<in> set (snd c_bs) \\<longrightarrow> monic b)\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    square_free_factorization p c_bs \\<and>\n    ((b, i) \\<in> set (snd c_bs) \\<longrightarrow> monic b)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    square_free_factorization p c_bs \\<and>\n    ((b, i) \\<in> set (snd c_bs) \\<longrightarrow> monic b)", "case False"], ["proof (state)\nthis:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    square_free_factorization p c_bs \\<and>\n    ((b, i) \\<in> set (snd c_bs) \\<longrightarrow> monic b)", "let ?c = \"coeff p (degree p)\""], ["proof (state)\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    square_free_factorization p c_bs \\<and>\n    ((b, i) \\<in> set (snd c_bs) \\<longrightarrow> monic b)", "let ?ic = \"inverse ?c\""], ["proof (state)\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    square_free_factorization p c_bs \\<and>\n    ((b, i) \\<in> set (snd c_bs) \\<longrightarrow> monic b)", "obtain c bs where cbs: \"c_bs = (c,bs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>c bs. c_bs = (c, bs) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  c_bs = (c, bs)\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    square_free_factorization p c_bs \\<and>\n    ((b, i) \\<in> set (snd c_bs) \\<longrightarrow> monic b)", "with False res"], ["proof (chain)\npicking this:\n  p \\<noteq> 0\n  (if p = 0 then (0::'a, [])\n   else (lead_coeff p,\n         yun_monic_factorization (smult (inverse (lead_coeff p)) p))) =\n  c_bs\n  c_bs = (c, bs)", "have c: \"c = ?c\" \"?c \\<noteq> 0\" and fact: \"yun_monic_factorization (smult ?ic p) = bs\""], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  (if p = 0 then (0::'a, [])\n   else (lead_coeff p,\n         yun_monic_factorization (smult (inverse (lead_coeff p)) p))) =\n  c_bs\n  c_bs = (c, bs)\n\ngoal (1 subgoal):\n 1. (c = lead_coeff p &&& lead_coeff p \\<noteq> (0::'a)) &&&\n    yun_monic_factorization (smult (inverse (lead_coeff p)) p) = bs", "by auto"], ["proof (state)\nthis:\n  c = lead_coeff p\n  lead_coeff p \\<noteq> (0::'a)\n  yun_monic_factorization (smult (inverse (lead_coeff p)) p) = bs\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    square_free_factorization p c_bs \\<and>\n    ((b, i) \\<in> set (snd c_bs) \\<longrightarrow> monic b)", "from False"], ["proof (chain)\npicking this:\n  p \\<noteq> 0", "have mon: \"monic (smult ?ic p)\""], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. monic (smult (inverse (lead_coeff p)) p)", "by auto"], ["proof (state)\nthis:\n  monic (smult (inverse (lead_coeff p)) p)\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    square_free_factorization p c_bs \\<and>\n    ((b, i) \\<in> set (snd c_bs) \\<longrightarrow> monic b)", "from yun_monic_factorization[OF fact mon]"], ["proof (chain)\npicking this:\n  square_free_factorization (smult (inverse (lead_coeff p)) p) (1::'a, bs)\n  (?b, ?i) \\<in> set bs \\<Longrightarrow> monic ?b\n  distinct (map snd bs)", "have sff: \"square_free_factorization (smult ?ic p) (1, bs)\" \"(b, i) \\<in> set bs \\<Longrightarrow> monic b\""], ["proof (prove)\nusing this:\n  square_free_factorization (smult (inverse (lead_coeff p)) p) (1::'a, bs)\n  (?b, ?i) \\<in> set bs \\<Longrightarrow> monic ?b\n  distinct (map snd bs)\n\ngoal (1 subgoal):\n 1. square_free_factorization (smult (inverse (lead_coeff p)) p)\n     (1::'a, bs) &&&\n    ((b, i) \\<in> set bs \\<Longrightarrow> monic b)", "by auto"], ["proof (state)\nthis:\n  square_free_factorization (smult (inverse (lead_coeff p)) p) (1::'a, bs)\n  (b, i) \\<in> set bs \\<Longrightarrow> monic b\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    square_free_factorization p c_bs \\<and>\n    ((b, i) \\<in> set (snd c_bs) \\<longrightarrow> monic b)", "have id: \"smult ?c (smult ?ic p) = p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. smult (lead_coeff p) (smult (inverse (lead_coeff p)) p) = p", "using False"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. smult (lead_coeff p) (smult (inverse (lead_coeff p)) p) = p", "by auto"], ["proof (state)\nthis:\n  smult (lead_coeff p) (smult (inverse (lead_coeff p)) p) = p\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    square_free_factorization p c_bs \\<and>\n    ((b, i) \\<in> set (snd c_bs) \\<longrightarrow> monic b)", "from square_free_factorization_smult[OF c(2) sff(1), unfolded id] sff"], ["proof (chain)\npicking this:\n  square_free_factorization p (lead_coeff p * (1::'a), bs)\n  square_free_factorization (smult (inverse (lead_coeff p)) p) (1::'a, bs)\n  (b, i) \\<in> set bs \\<Longrightarrow> monic b", "show ?thesis"], ["proof (prove)\nusing this:\n  square_free_factorization p (lead_coeff p * (1::'a), bs)\n  square_free_factorization (smult (inverse (lead_coeff p)) p) (1::'a, bs)\n  (b, i) \\<in> set bs \\<Longrightarrow> monic b\n\ngoal (1 subgoal):\n 1. square_free_factorization p c_bs \\<and>\n    ((b, i) \\<in> set (snd c_bs) \\<longrightarrow> monic b)", "unfolding cbs c"], ["proof (prove)\nusing this:\n  square_free_factorization p (lead_coeff p * (1::'a), bs)\n  square_free_factorization (smult (inverse (lead_coeff p)) p) (1::'a, bs)\n  (b, i) \\<in> set bs \\<Longrightarrow> monic b\n\ngoal (1 subgoal):\n 1. square_free_factorization p (lead_coeff p, bs) \\<and>\n    ((b, i) \\<in> set (snd (lead_coeff p, bs)) \\<longrightarrow> monic b)", "by simp"], ["proof (state)\nthis:\n  square_free_factorization p c_bs \\<and>\n  ((b, i) \\<in> set (snd c_bs) \\<longrightarrow> monic b)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  square_free_factorization p c_bs \\<and>\n  ((b, i) \\<in> set (snd c_bs) \\<longrightarrow> monic b)\n\ngoal (2 subgoals):\n 1. square_free_factorization p c_bs\n 2. (b, i) \\<in> set (snd c_bs) \\<Longrightarrow> monic b", "thus \"square_free_factorization p c_bs\" \"(b,i) \\<in> set (snd c_bs) \\<Longrightarrow> monic b\""], ["proof (prove)\nusing this:\n  square_free_factorization p c_bs \\<and>\n  ((b, i) \\<in> set (snd c_bs) \\<longrightarrow> monic b)\n\ngoal (1 subgoal):\n 1. square_free_factorization p c_bs &&&\n    ((b, i) \\<in> set (snd c_bs) \\<Longrightarrow> monic b)", "by blast+"], ["proof (state)\nthis:\n  square_free_factorization p c_bs\n  (b, i) \\<in> set (snd c_bs) \\<Longrightarrow> monic b\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma prod_list_pow_suc: \"(\\<Prod>x\\<leftarrow>bs. (x :: 'a :: comm_monoid_mult) * x ^ i) \n  = prod_list bs * prod_list bs ^ i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>x\\<leftarrow>bs. x * x ^ i) = prod_list bs * prod_list bs ^ i", "by (induct bs, auto simp: field_simps)"], ["", "declare irreducible_linear_field_poly[intro!]"], ["", "context \n  assumes \"SORT_CONSTRAINT('a :: {field, factorial_ring_gcd,semiring_gcd_mult_normalize})\" \nbegin"], ["", "lemma square_free_factorization_order_root_mem: \n  assumes sff: \"square_free_factorization p (c,bs)\"\n    and p: \"p \\<noteq> (0 :: 'a poly)\"\n    and ai: \"(a,i) \\<in> set bs\" and rt: \"poly a x = 0\"\n  shows \"order x p = Suc i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order x p = Suc i", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. order x p = Suc i", "note sff = square_free_factorizationD[OF sff]"], ["proof (state)\nthis:\n  p = smult c (\\<Prod>(a, i)\\<in>set bs. a ^ Suc i)\n  (?a, ?i) \\<in> set bs \\<Longrightarrow>\n  square_free ?a \\<and> degree ?a \\<noteq> 0\n  \\<lbrakk>(?a, ?i) \\<in> set bs; (?b, ?j) \\<in> set bs;\n   (?a, ?i) \\<noteq> (?b, ?j)\\<rbrakk>\n  \\<Longrightarrow> coprime ?a ?b\n  p = 0 \\<Longrightarrow> c = (0::'a) \\<and> bs = []\n  distinct bs\n\ngoal (1 subgoal):\n 1. order x p = Suc i", "let ?prod = \"(\\<Prod>(a, i)\\<in>set bs. a ^ Suc i)\""], ["proof (state)\ngoal (1 subgoal):\n 1. order x p = Suc i", "from sff"], ["proof (chain)\npicking this:\n  p = smult c (\\<Prod>(a, i)\\<in>set bs. a ^ Suc i)\n  (?a, ?i) \\<in> set bs \\<Longrightarrow>\n  square_free ?a \\<and> degree ?a \\<noteq> 0\n  \\<lbrakk>(?a, ?i) \\<in> set bs; (?b, ?j) \\<in> set bs;\n   (?a, ?i) \\<noteq> (?b, ?j)\\<rbrakk>\n  \\<Longrightarrow> coprime ?a ?b\n  p = 0 \\<Longrightarrow> c = (0::'a) \\<and> bs = []\n  distinct bs", "have pf: \"p = smult c ?prod\""], ["proof (prove)\nusing this:\n  p = smult c (\\<Prod>(a, i)\\<in>set bs. a ^ Suc i)\n  (?a, ?i) \\<in> set bs \\<Longrightarrow>\n  square_free ?a \\<and> degree ?a \\<noteq> 0\n  \\<lbrakk>(?a, ?i) \\<in> set bs; (?b, ?j) \\<in> set bs;\n   (?a, ?i) \\<noteq> (?b, ?j)\\<rbrakk>\n  \\<Longrightarrow> coprime ?a ?b\n  p = 0 \\<Longrightarrow> c = (0::'a) \\<and> bs = []\n  distinct bs\n\ngoal (1 subgoal):\n 1. p = smult c (\\<Prod>(a, i)\\<in>set bs. a ^ Suc i)", "by blast"], ["proof (state)\nthis:\n  p = smult c (\\<Prod>(a, i)\\<in>set bs. a ^ Suc i)\n\ngoal (1 subgoal):\n 1. order x p = Suc i", "with p"], ["proof (chain)\npicking this:\n  p \\<noteq> 0\n  p = smult c (\\<Prod>(a, i)\\<in>set bs. a ^ Suc i)", "have c: \"c \\<noteq> 0\""], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  p = smult c (\\<Prod>(a, i)\\<in>set bs. a ^ Suc i)\n\ngoal (1 subgoal):\n 1. c \\<noteq> (0::'a)", "by auto"], ["proof (state)\nthis:\n  c \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. order x p = Suc i", "have ord: \"order x p = order x ?prod\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order x p = order x (\\<Prod>(a, i)\\<in>set bs. a ^ Suc i)", "unfolding pf"], ["proof (prove)\ngoal (1 subgoal):\n 1. order x (smult c (\\<Prod>(a, i)\\<in>set bs. a ^ Suc i)) =\n    order x (\\<Prod>(a, i)\\<in>set bs. a ^ Suc i)", "using order_smult[OF c]"], ["proof (prove)\nusing this:\n  order ?x (smult c ?p) = order ?x ?p\n\ngoal (1 subgoal):\n 1. order x (smult c (\\<Prod>(a, i)\\<in>set bs. a ^ Suc i)) =\n    order x (\\<Prod>(a, i)\\<in>set bs. a ^ Suc i)", "by auto"], ["proof (state)\nthis:\n  order x p = order x (\\<Prod>(a, i)\\<in>set bs. a ^ Suc i)\n\ngoal (1 subgoal):\n 1. order x p = Suc i", "define q where \"q = [: -x, 1 :]\""], ["proof (state)\nthis:\n  q = [:- x, 1::'a:]\n\ngoal (1 subgoal):\n 1. order x p = Suc i", "have q0: \"q \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q \\<noteq> 0", "unfolding q_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. [:- x, 1::'a:] \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. order x p = Suc i", "have iq: \"irreducible q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. irreducible q", "by (auto simp: q_def)"], ["proof (state)\nthis:\n  irreducible q\n\ngoal (1 subgoal):\n 1. order x p = Suc i", "from rt"], ["proof (chain)\npicking this:\n  poly a x = (0::'a)", "have qa: \"q dvd a\""], ["proof (prove)\nusing this:\n  poly a x = (0::'a)\n\ngoal (1 subgoal):\n 1. q dvd a", "unfolding q_def poly_eq_0_iff_dvd"], ["proof (prove)\nusing this:\n  [:- x, 1::'a:] dvd a\n\ngoal (1 subgoal):\n 1. [:- x, 1::'a:] dvd a", "."], ["proof (state)\nthis:\n  q dvd a\n\ngoal (1 subgoal):\n 1. order x p = Suc i", "then"], ["proof (chain)\npicking this:\n  q dvd a", "obtain b where aqb: \"a = q * b\""], ["proof (prove)\nusing this:\n  q dvd a\n\ngoal (1 subgoal):\n 1. (\\<And>b. a = q * b \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "unfolding dvd_def"], ["proof (prove)\nusing this:\n  \\<exists>k. a = q * k\n\ngoal (1 subgoal):\n 1. (\\<And>b. a = q * b \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  a = q * b\n\ngoal (1 subgoal):\n 1. order x p = Suc i", "from sff(2)[OF ai]"], ["proof (chain)\npicking this:\n  square_free a \\<and> degree a \\<noteq> 0", "have sq: \"square_free a\" and mon: \"degree a \\<noteq> 0\""], ["proof (prove)\nusing this:\n  square_free a \\<and> degree a \\<noteq> 0\n\ngoal (1 subgoal):\n 1. square_free a &&& degree a \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  square_free a\n  degree a \\<noteq> 0\n\ngoal (1 subgoal):\n 1. order x p = Suc i", "let ?rem = \"(\\<Prod>(a, i)\\<in>set bs - {(a,i)}. a ^ Suc i)\""], ["proof (state)\ngoal (1 subgoal):\n 1. order x p = Suc i", "have p0: \"?prod \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>(a, i)\\<in>set bs. a ^ Suc i) \\<noteq> 0", "using p pf"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  p = smult c (\\<Prod>(a, i)\\<in>set bs. a ^ Suc i)\n\ngoal (1 subgoal):\n 1. (\\<Prod>(a, i)\\<in>set bs. a ^ Suc i) \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  (\\<Prod>(a, i)\\<in>set bs. a ^ Suc i) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. order x p = Suc i", "have \"?prod = a ^ Suc i * ?rem\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>(a, i)\\<in>set bs. a ^ Suc i) =\n    a ^ Suc i * (\\<Prod>(a, i)\\<in>set bs - {(a, i)}. a ^ Suc i)", "by (subst prod.remove[OF _ ai], auto)"], ["proof (state)\nthis:\n  (\\<Prod>(a, i)\\<in>set bs. a ^ Suc i) =\n  a ^ Suc i * (\\<Prod>(a, i)\\<in>set bs - {(a, i)}. a ^ Suc i)\n\ngoal (1 subgoal):\n 1. order x p = Suc i", "also"], ["proof (state)\nthis:\n  (\\<Prod>(a, i)\\<in>set bs. a ^ Suc i) =\n  a ^ Suc i * (\\<Prod>(a, i)\\<in>set bs - {(a, i)}. a ^ Suc i)\n\ngoal (1 subgoal):\n 1. order x p = Suc i", "have \"a ^ Suc i = q ^ Suc i * b ^ Suc i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a ^ Suc i = q ^ Suc i * b ^ Suc i", "unfolding aqb"], ["proof (prove)\ngoal (1 subgoal):\n 1. (q * b) ^ Suc i = q ^ Suc i * b ^ Suc i", "by (simp add: field_simps)"], ["proof (state)\nthis:\n  a ^ Suc i = q ^ Suc i * b ^ Suc i\n\ngoal (1 subgoal):\n 1. order x p = Suc i", "finally"], ["proof (chain)\npicking this:\n  (\\<Prod>a\\<in>set bs. case a of (a, i) \\<Rightarrow> a ^ Suc i) =\n  q ^ Suc i * b ^ Suc i *\n  (\\<Prod>a\\<in>set bs - {(a, i)}. case a of (a, i) \\<Rightarrow> a ^ Suc i)", "have id: \"?prod = q ^ Suc i * (b ^ Suc i * ?rem)\""], ["proof (prove)\nusing this:\n  (\\<Prod>a\\<in>set bs. case a of (a, i) \\<Rightarrow> a ^ Suc i) =\n  q ^ Suc i * b ^ Suc i *\n  (\\<Prod>a\\<in>set bs - {(a, i)}. case a of (a, i) \\<Rightarrow> a ^ Suc i)\n\ngoal (1 subgoal):\n 1. (\\<Prod>(a, i)\\<in>set bs. a ^ Suc i) =\n    q ^ Suc i *\n    (b ^ Suc i * (\\<Prod>(a, i)\\<in>set bs - {(a, i)}. a ^ Suc i))", "by simp"], ["proof (state)\nthis:\n  (\\<Prod>(a, i)\\<in>set bs. a ^ Suc i) =\n  q ^ Suc i * (b ^ Suc i * (\\<Prod>(a, i)\\<in>set bs - {(a, i)}. a ^ Suc i))\n\ngoal (1 subgoal):\n 1. order x p = Suc i", "hence dvd: \"q ^ Suc i dvd ?prod\""], ["proof (prove)\nusing this:\n  (\\<Prod>(a, i)\\<in>set bs. a ^ Suc i) =\n  q ^ Suc i * (b ^ Suc i * (\\<Prod>(a, i)\\<in>set bs - {(a, i)}. a ^ Suc i))\n\ngoal (1 subgoal):\n 1. q ^ Suc i dvd (\\<Prod>(a, i)\\<in>set bs. a ^ Suc i)", "by auto"], ["proof (state)\nthis:\n  q ^ Suc i dvd (\\<Prod>(a, i)\\<in>set bs. a ^ Suc i)\n\ngoal (1 subgoal):\n 1. order x p = Suc i", "{"], ["proof (state)\nthis:\n  q ^ Suc i dvd (\\<Prod>(a, i)\\<in>set bs. a ^ Suc i)\n\ngoal (1 subgoal):\n 1. order x p = Suc i", "assume \"q ^ Suc (Suc i) dvd ?prod\""], ["proof (state)\nthis:\n  q ^ Suc (Suc i) dvd (\\<Prod>(a, i)\\<in>set bs. a ^ Suc i)\n\ngoal (1 subgoal):\n 1. order x p = Suc i", "hence \"q dvd ?prod div q ^ Suc i\""], ["proof (prove)\nusing this:\n  q ^ Suc (Suc i) dvd (\\<Prod>(a, i)\\<in>set bs. a ^ Suc i)\n\ngoal (1 subgoal):\n 1. q dvd (\\<Prod>(a, i)\\<in>set bs. a ^ Suc i) div q ^ Suc i", "by (metis dvd dvd_0_left_iff dvd_div_iff_mult p0 power_Suc)"], ["proof (state)\nthis:\n  q dvd (\\<Prod>(a, i)\\<in>set bs. a ^ Suc i) div q ^ Suc i\n\ngoal (1 subgoal):\n 1. order x p = Suc i", "also"], ["proof (state)\nthis:\n  q dvd (\\<Prod>(a, i)\\<in>set bs. a ^ Suc i) div q ^ Suc i\n\ngoal (1 subgoal):\n 1. order x p = Suc i", "have \"?prod div q ^ Suc i = b ^ Suc i * ?rem\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>(a, i)\\<in>set bs. a ^ Suc i) div q ^ Suc i =\n    b ^ Suc i * (\\<Prod>(a, i)\\<in>set bs - {(a, i)}. a ^ Suc i)", "unfolding id"], ["proof (prove)\ngoal (1 subgoal):\n 1. q ^ Suc i *\n    (b ^ Suc i * (\\<Prod>(a, i)\\<in>set bs - {(a, i)}. a ^ Suc i)) div\n    q ^ Suc i =\n    b ^ Suc i * (\\<Prod>(a, i)\\<in>set bs - {(a, i)}. a ^ Suc i)", "by (rule nonzero_mult_div_cancel_left, insert q0, auto)"], ["proof (state)\nthis:\n  (\\<Prod>(a, i)\\<in>set bs. a ^ Suc i) div q ^ Suc i =\n  b ^ Suc i * (\\<Prod>(a, i)\\<in>set bs - {(a, i)}. a ^ Suc i)\n\ngoal (1 subgoal):\n 1. order x p = Suc i", "finally"], ["proof (chain)\npicking this:\n  q dvd b ^ Suc i * (\\<Prod>(a, i)\\<in>set bs - {(a, i)}. a ^ Suc i)", "have \"q dvd b \\<or> q dvd ?rem\""], ["proof (prove)\nusing this:\n  q dvd b ^ Suc i * (\\<Prod>(a, i)\\<in>set bs - {(a, i)}. a ^ Suc i)\n\ngoal (1 subgoal):\n 1. q dvd b \\<or> q dvd (\\<Prod>(a, i)\\<in>set bs - {(a, i)}. a ^ Suc i)", "using iq irreducible_dvd_pow[OF iq]"], ["proof (prove)\nusing this:\n  q dvd b ^ Suc i * (\\<Prod>(a, i)\\<in>set bs - {(a, i)}. a ^ Suc i)\n  irreducible q\n  q dvd ?q ^ ?n \\<Longrightarrow> q dvd ?q\n\ngoal (1 subgoal):\n 1. q dvd b \\<or> q dvd (\\<Prod>(a, i)\\<in>set bs - {(a, i)}. a ^ Suc i)", "by auto"], ["proof (state)\nthis:\n  q dvd b \\<or> q dvd (\\<Prod>(a, i)\\<in>set bs - {(a, i)}. a ^ Suc i)\n\ngoal (1 subgoal):\n 1. order x p = Suc i", "hence False"], ["proof (prove)\nusing this:\n  q dvd b \\<or> q dvd (\\<Prod>(a, i)\\<in>set bs - {(a, i)}. a ^ Suc i)\n\ngoal (1 subgoal):\n 1. False", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. q dvd b \\<Longrightarrow> False\n 2. q dvd (\\<Prod>(a, i)\\<in>set bs - {(a, i)}. a ^ Suc i) \\<Longrightarrow>\n    False", "assume \"q dvd b\""], ["proof (state)\nthis:\n  q dvd b\n\ngoal (2 subgoals):\n 1. q dvd b \\<Longrightarrow> False\n 2. q dvd (\\<Prod>(a, i)\\<in>set bs - {(a, i)}. a ^ Suc i) \\<Longrightarrow>\n    False", "with aqb"], ["proof (chain)\npicking this:\n  a = q * b\n  q dvd b", "have \"q * q dvd a\""], ["proof (prove)\nusing this:\n  a = q * b\n  q dvd b\n\ngoal (1 subgoal):\n 1. q * q dvd a", "by auto"], ["proof (state)\nthis:\n  q * q dvd a\n\ngoal (2 subgoals):\n 1. q dvd b \\<Longrightarrow> False\n 2. q dvd (\\<Prod>(a, i)\\<in>set bs - {(a, i)}. a ^ Suc i) \\<Longrightarrow>\n    False", "with sq[unfolded square_free_def] mon iq"], ["proof (chain)\npicking this:\n  a \\<noteq> 0 \\<and>\n  (\\<forall>q. 0 < degree q \\<longrightarrow> \\<not> q * q dvd a)\n  degree a \\<noteq> 0\n  irreducible q\n  q * q dvd a", "show False"], ["proof (prove)\nusing this:\n  a \\<noteq> 0 \\<and>\n  (\\<forall>q. 0 < degree q \\<longrightarrow> \\<not> q * q dvd a)\n  degree a \\<noteq> 0\n  irreducible q\n  q * q dvd a\n\ngoal (1 subgoal):\n 1. False", "unfolding irreducible\\<^sub>d_def"], ["proof (prove)\nusing this:\n  a \\<noteq> 0 \\<and>\n  (\\<forall>q. 0 < degree q \\<longrightarrow> \\<not> q * q dvd a)\n  degree a \\<noteq> 0\n  irreducible q\n  q * q dvd a\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. q dvd (\\<Prod>(a, i)\\<in>set bs - {(a, i)}. a ^ Suc i) \\<Longrightarrow>\n    False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. q dvd (\\<Prod>(a, i)\\<in>set bs - {(a, i)}. a ^ Suc i) \\<Longrightarrow>\n    False", "assume \"q dvd ?rem\""], ["proof (state)\nthis:\n  q dvd (\\<Prod>(a, i)\\<in>set bs - {(a, i)}. a ^ Suc i)\n\ngoal (1 subgoal):\n 1. q dvd (\\<Prod>(a, i)\\<in>set bs - {(a, i)}. a ^ Suc i) \\<Longrightarrow>\n    False", "from irreducible_dvd_prod[OF iq this]"], ["proof (chain)\npicking this:\n  \\<exists>a\\<in>set bs - {(a, i)}.\n     q dvd (case a of (a, i) \\<Rightarrow> a ^ Suc i)", "obtain b j where bj: \"(b,j) \\<in> set bs\" and neq: \"(a,i) \\<noteq> (b,j)\" and dvd: \"q dvd b ^ Suc j\""], ["proof (prove)\nusing this:\n  \\<exists>a\\<in>set bs - {(a, i)}.\n     q dvd (case a of (a, i) \\<Rightarrow> a ^ Suc i)\n\ngoal (1 subgoal):\n 1. (\\<And>b j.\n        \\<lbrakk>(b, j) \\<in> set bs; (a, i) \\<noteq> (b, j);\n         q dvd b ^ Suc j\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  (b, j) \\<in> set bs\n  (a, i) \\<noteq> (b, j)\n  q dvd b ^ Suc j\n\ngoal (1 subgoal):\n 1. q dvd (\\<Prod>(a, i)\\<in>set bs - {(a, i)}. a ^ Suc i) \\<Longrightarrow>\n    False", "from irreducible_dvd_pow[OF iq dvd]"], ["proof (chain)\npicking this:\n  q dvd b", "have qb: \"q dvd b\""], ["proof (prove)\nusing this:\n  q dvd b\n\ngoal (1 subgoal):\n 1. q dvd b", "."], ["proof (state)\nthis:\n  q dvd b\n\ngoal (1 subgoal):\n 1. q dvd (\\<Prod>(a, i)\\<in>set bs - {(a, i)}. a ^ Suc i) \\<Longrightarrow>\n    False", "from sff(3)[OF ai bj neq]"], ["proof (chain)\npicking this:\n  coprime a b", "have gcd: \"coprime a b\""], ["proof (prove)\nusing this:\n  coprime a b\n\ngoal (1 subgoal):\n 1. coprime a b", "."], ["proof (state)\nthis:\n  coprime a b\n\ngoal (1 subgoal):\n 1. q dvd (\\<Prod>(a, i)\\<in>set bs - {(a, i)}. a ^ Suc i) \\<Longrightarrow>\n    False", "from qb qa"], ["proof (chain)\npicking this:\n  q dvd b\n  q dvd a", "have \"q dvd gcd a b\""], ["proof (prove)\nusing this:\n  q dvd b\n  q dvd a\n\ngoal (1 subgoal):\n 1. q dvd gcd a b", "by simp"], ["proof (state)\nthis:\n  q dvd gcd a b\n\ngoal (1 subgoal):\n 1. q dvd (\\<Prod>(a, i)\\<in>set bs - {(a, i)}. a ^ Suc i) \\<Longrightarrow>\n    False", "from dvd_imp_degree_le[OF this[unfolded gcd]] iq q0"], ["proof (chain)\npicking this:\n  gcd a b \\<noteq> 0 \\<Longrightarrow> degree q \\<le> degree (gcd a b)\n  irreducible q\n  q \\<noteq> 0", "show False"], ["proof (prove)\nusing this:\n  gcd a b \\<noteq> 0 \\<Longrightarrow> degree q \\<le> degree (gcd a b)\n  irreducible q\n  q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. False", "using gcd"], ["proof (prove)\nusing this:\n  gcd a b \\<noteq> 0 \\<Longrightarrow> degree q \\<le> degree (gcd a b)\n  irreducible q\n  q \\<noteq> 0\n  coprime a b\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. order x p = Suc i", "}"], ["proof (state)\nthis:\n  q ^ Suc (Suc i) dvd\n  (\\<Prod>(a, i)\\<in>set bs. a ^ Suc i) \\<Longrightarrow>\n  False\n\ngoal (1 subgoal):\n 1. order x p = Suc i", "hence ndvd: \"\\<not> q ^ Suc (Suc i) dvd ?prod\""], ["proof (prove)\nusing this:\n  q ^ Suc (Suc i) dvd\n  (\\<Prod>(a, i)\\<in>set bs. a ^ Suc i) \\<Longrightarrow>\n  False\n\ngoal (1 subgoal):\n 1. \\<not> q ^ Suc (Suc i) dvd (\\<Prod>(a, i)\\<in>set bs. a ^ Suc i)", "by blast"], ["proof (state)\nthis:\n  \\<not> q ^ Suc (Suc i) dvd (\\<Prod>(a, i)\\<in>set bs. a ^ Suc i)\n\ngoal (1 subgoal):\n 1. order x p = Suc i", "with dvd"], ["proof (chain)\npicking this:\n  q ^ Suc i dvd (\\<Prod>(a, i)\\<in>set bs. a ^ Suc i)\n  \\<not> q ^ Suc (Suc i) dvd (\\<Prod>(a, i)\\<in>set bs. a ^ Suc i)", "have \"order x ?prod = Suc i\""], ["proof (prove)\nusing this:\n  q ^ Suc i dvd (\\<Prod>(a, i)\\<in>set bs. a ^ Suc i)\n  \\<not> q ^ Suc (Suc i) dvd (\\<Prod>(a, i)\\<in>set bs. a ^ Suc i)\n\ngoal (1 subgoal):\n 1. order x (\\<Prod>(a, i)\\<in>set bs. a ^ Suc i) = Suc i", "unfolding q_def"], ["proof (prove)\nusing this:\n  [:- x, 1::'a:] ^ Suc i dvd (\\<Prod>(a, i)\\<in>set bs. a ^ Suc i)\n  \\<not> [:- x, 1::'a:] ^ Suc (Suc i) dvd\n         (\\<Prod>(a, i)\\<in>set bs. a ^ Suc i)\n\ngoal (1 subgoal):\n 1. order x (\\<Prod>(a, i)\\<in>set bs. a ^ Suc i) = Suc i", "by (metis order_unique_lemma)"], ["proof (state)\nthis:\n  order x (\\<Prod>(a, i)\\<in>set bs. a ^ Suc i) = Suc i\n\ngoal (1 subgoal):\n 1. order x p = Suc i", "thus ?thesis"], ["proof (prove)\nusing this:\n  order x (\\<Prod>(a, i)\\<in>set bs. a ^ Suc i) = Suc i\n\ngoal (1 subgoal):\n 1. order x p = Suc i", "unfolding ord"], ["proof (prove)\nusing this:\n  order x (\\<Prod>(a, i)\\<in>set bs. a ^ Suc i) = Suc i\n\ngoal (1 subgoal):\n 1. order x (\\<Prod>(a, i)\\<in>set bs. a ^ Suc i) = Suc i", "."], ["proof (state)\nthis:\n  order x p = Suc i\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma square_free_factorization_order_root_no_mem: \n  assumes sff: \"square_free_factorization p (c,bs)\"\n    and p: \"p \\<noteq> (0 :: 'a poly)\"\n    and no_root: \"\\<And> a i. (a,i) \\<in> set bs \\<Longrightarrow> poly a x \\<noteq> 0\"\n  shows \"order x p = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order x p = 0", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. order x p \\<noteq> 0 \\<Longrightarrow> False", "assume o0: \"order x p \\<noteq> 0\""], ["proof (state)\nthis:\n  order x p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. order x p \\<noteq> 0 \\<Longrightarrow> False", "with order_root[of p x] p"], ["proof (chain)\npicking this:\n  (poly p x = (0::'a)) = (p = 0 \\<or> order x p \\<noteq> 0)\n  p \\<noteq> 0\n  order x p \\<noteq> 0", "have 0: \"poly p x = 0\""], ["proof (prove)\nusing this:\n  (poly p x = (0::'a)) = (p = 0 \\<or> order x p \\<noteq> 0)\n  p \\<noteq> 0\n  order x p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. poly p x = (0::'a)", "by auto"], ["proof (state)\nthis:\n  poly p x = (0::'a)\n\ngoal (1 subgoal):\n 1. order x p \\<noteq> 0 \\<Longrightarrow> False", "note sff = square_free_factorizationD[OF sff]"], ["proof (state)\nthis:\n  p = smult c (\\<Prod>(a, i)\\<in>set bs. a ^ Suc i)\n  (?a, ?i) \\<in> set bs \\<Longrightarrow>\n  square_free ?a \\<and> degree ?a \\<noteq> 0\n  \\<lbrakk>(?a, ?i) \\<in> set bs; (?b, ?j) \\<in> set bs;\n   (?a, ?i) \\<noteq> (?b, ?j)\\<rbrakk>\n  \\<Longrightarrow> coprime ?a ?b\n  p = 0 \\<Longrightarrow> c = (0::'a) \\<and> bs = []\n  distinct bs\n\ngoal (1 subgoal):\n 1. order x p \\<noteq> 0 \\<Longrightarrow> False", "let ?prod = \"(\\<Prod>(a, i)\\<in>set bs. a ^ Suc i)\""], ["proof (state)\ngoal (1 subgoal):\n 1. order x p \\<noteq> 0 \\<Longrightarrow> False", "from sff"], ["proof (chain)\npicking this:\n  p = smult c (\\<Prod>(a, i)\\<in>set bs. a ^ Suc i)\n  (?a, ?i) \\<in> set bs \\<Longrightarrow>\n  square_free ?a \\<and> degree ?a \\<noteq> 0\n  \\<lbrakk>(?a, ?i) \\<in> set bs; (?b, ?j) \\<in> set bs;\n   (?a, ?i) \\<noteq> (?b, ?j)\\<rbrakk>\n  \\<Longrightarrow> coprime ?a ?b\n  p = 0 \\<Longrightarrow> c = (0::'a) \\<and> bs = []\n  distinct bs", "have pf: \"p = smult c ?prod\""], ["proof (prove)\nusing this:\n  p = smult c (\\<Prod>(a, i)\\<in>set bs. a ^ Suc i)\n  (?a, ?i) \\<in> set bs \\<Longrightarrow>\n  square_free ?a \\<and> degree ?a \\<noteq> 0\n  \\<lbrakk>(?a, ?i) \\<in> set bs; (?b, ?j) \\<in> set bs;\n   (?a, ?i) \\<noteq> (?b, ?j)\\<rbrakk>\n  \\<Longrightarrow> coprime ?a ?b\n  p = 0 \\<Longrightarrow> c = (0::'a) \\<and> bs = []\n  distinct bs\n\ngoal (1 subgoal):\n 1. p = smult c (\\<Prod>(a, i)\\<in>set bs. a ^ Suc i)", "by blast"], ["proof (state)\nthis:\n  p = smult c (\\<Prod>(a, i)\\<in>set bs. a ^ Suc i)\n\ngoal (1 subgoal):\n 1. order x p \\<noteq> 0 \\<Longrightarrow> False", "with p"], ["proof (chain)\npicking this:\n  p \\<noteq> 0\n  p = smult c (\\<Prod>(a, i)\\<in>set bs. a ^ Suc i)", "have c: \"c \\<noteq> 0\""], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  p = smult c (\\<Prod>(a, i)\\<in>set bs. a ^ Suc i)\n\ngoal (1 subgoal):\n 1. c \\<noteq> (0::'a)", "by auto"], ["proof (state)\nthis:\n  c \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. order x p \\<noteq> 0 \\<Longrightarrow> False", "with 0"], ["proof (chain)\npicking this:\n  poly p x = (0::'a)\n  c \\<noteq> (0::'a)", "have 0: \"poly ?prod x = 0\""], ["proof (prove)\nusing this:\n  poly p x = (0::'a)\n  c \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. poly (\\<Prod>(a, i)\\<in>set bs. a ^ Suc i) x = (0::'a)", "unfolding pf"], ["proof (prove)\nusing this:\n  poly (smult c (\\<Prod>(a, i)\\<in>set bs. a ^ Suc i)) x = (0::'a)\n  c \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. poly (\\<Prod>(a, i)\\<in>set bs. a ^ Suc i) x = (0::'a)", "by auto"], ["proof (state)\nthis:\n  poly (\\<Prod>(a, i)\\<in>set bs. a ^ Suc i) x = (0::'a)\n\ngoal (1 subgoal):\n 1. order x p \\<noteq> 0 \\<Longrightarrow> False", "define q where \"q = [: -x, 1 :]\""], ["proof (state)\nthis:\n  q = [:- x, 1::'a:]\n\ngoal (1 subgoal):\n 1. order x p \\<noteq> 0 \\<Longrightarrow> False", "from 0"], ["proof (chain)\npicking this:\n  poly (\\<Prod>(a, i)\\<in>set bs. a ^ Suc i) x = (0::'a)", "have dvd: \"q dvd ?prod\""], ["proof (prove)\nusing this:\n  poly (\\<Prod>(a, i)\\<in>set bs. a ^ Suc i) x = (0::'a)\n\ngoal (1 subgoal):\n 1. q dvd (\\<Prod>(a, i)\\<in>set bs. a ^ Suc i)", "unfolding poly_eq_0_iff_dvd"], ["proof (prove)\nusing this:\n  [:- x, 1::'a:] dvd (\\<Prod>(a, i)\\<in>set bs. a ^ Suc i)\n\ngoal (1 subgoal):\n 1. q dvd (\\<Prod>(a, i)\\<in>set bs. a ^ Suc i)", "by (simp add: q_def)"], ["proof (state)\nthis:\n  q dvd (\\<Prod>(a, i)\\<in>set bs. a ^ Suc i)\n\ngoal (1 subgoal):\n 1. order x p \\<noteq> 0 \\<Longrightarrow> False", "have q0: \"q \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q \\<noteq> 0", "unfolding q_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. [:- x, 1::'a:] \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. order x p \\<noteq> 0 \\<Longrightarrow> False", "have iq: \"irreducible q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. irreducible q", "by (unfold q_def, auto intro:)"], ["proof (state)\nthis:\n  irreducible q\n\ngoal (1 subgoal):\n 1. order x p \\<noteq> 0 \\<Longrightarrow> False", "from irreducible_dvd_prod[OF iq dvd]"], ["proof (chain)\npicking this:\n  \\<exists>a\\<in>set bs. q dvd (case a of (a, i) \\<Rightarrow> a ^ Suc i)", "obtain a i where ai: \"(a,i) \\<in> set bs\" and dvd: \"q dvd a ^ Suc i\""], ["proof (prove)\nusing this:\n  \\<exists>a\\<in>set bs. q dvd (case a of (a, i) \\<Rightarrow> a ^ Suc i)\n\ngoal (1 subgoal):\n 1. (\\<And>a i.\n        \\<lbrakk>(a, i) \\<in> set bs; q dvd a ^ Suc i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  (a, i) \\<in> set bs\n  q dvd a ^ Suc i\n\ngoal (1 subgoal):\n 1. order x p \\<noteq> 0 \\<Longrightarrow> False", "from irreducible_dvd_pow[OF iq dvd]"], ["proof (chain)\npicking this:\n  q dvd a", "have dvd: \"q dvd a\""], ["proof (prove)\nusing this:\n  q dvd a\n\ngoal (1 subgoal):\n 1. q dvd a", "."], ["proof (state)\nthis:\n  q dvd a\n\ngoal (1 subgoal):\n 1. order x p \\<noteq> 0 \\<Longrightarrow> False", "hence \"poly a x = 0\""], ["proof (prove)\nusing this:\n  q dvd a\n\ngoal (1 subgoal):\n 1. poly a x = (0::'a)", "unfolding q_def"], ["proof (prove)\nusing this:\n  [:- x, 1::'a:] dvd a\n\ngoal (1 subgoal):\n 1. poly a x = (0::'a)", "by (simp add: poly_eq_0_iff_dvd q_def)"], ["proof (state)\nthis:\n  poly a x = (0::'a)\n\ngoal (1 subgoal):\n 1. order x p \\<noteq> 0 \\<Longrightarrow> False", "with no_root[OF ai]"], ["proof (chain)\npicking this:\n  poly a x \\<noteq> (0::'a)\n  poly a x = (0::'a)", "show False"], ["proof (prove)\nusing this:\n  poly a x \\<noteq> (0::'a)\n  poly a x = (0::'a)\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma square_free_factorization_order_root: \n  assumes sff: \"square_free_factorization p (c,bs)\"\n    and p: \"p \\<noteq> (0 :: 'a poly)\"\n  shows \"order x p = i \\<longleftrightarrow> (i = 0 \\<and> (\\<forall> a j. (a,j) \\<in> set bs \\<longrightarrow> poly a x \\<noteq> 0) \n    \\<or> (\\<exists> a j. (a,j) \\<in> set bs \\<and> poly a x = 0 \\<and> i = Suc j))\" (is \"?l = (?r1 \\<or> ?r2)\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (order x p = i) =\n    (i = 0 \\<and>\n     (\\<forall>a j.\n         (a, j) \\<in> set bs \\<longrightarrow>\n         poly a x \\<noteq> (0::'a)) \\<or>\n     (\\<exists>a j.\n         (a, j) \\<in> set bs \\<and> poly a x = (0::'a) \\<and> i = Suc j))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (order x p = i) =\n    (i = 0 \\<and>\n     (\\<forall>a j.\n         (a, j) \\<in> set bs \\<longrightarrow>\n         poly a x \\<noteq> (0::'a)) \\<or>\n     (\\<exists>a j.\n         (a, j) \\<in> set bs \\<and> poly a x = (0::'a) \\<and> i = Suc j))", "note mem = square_free_factorization_order_root_mem[OF sff p]"], ["proof (state)\nthis:\n  \\<lbrakk>(?a, ?i) \\<in> set bs; poly ?a ?x = (0::'a)\\<rbrakk>\n  \\<Longrightarrow> order ?x p = Suc ?i\n\ngoal (1 subgoal):\n 1. (order x p = i) =\n    (i = 0 \\<and>\n     (\\<forall>a j.\n         (a, j) \\<in> set bs \\<longrightarrow>\n         poly a x \\<noteq> (0::'a)) \\<or>\n     (\\<exists>a j.\n         (a, j) \\<in> set bs \\<and> poly a x = (0::'a) \\<and> i = Suc j))", "note no_mem = square_free_factorization_order_root_no_mem[OF sff p]"], ["proof (state)\nthis:\n  (\\<And>a i.\n      (a, i) \\<in> set bs \\<Longrightarrow>\n      poly a ?x \\<noteq> (0::'a)) \\<Longrightarrow>\n  order ?x p = 0\n\ngoal (1 subgoal):\n 1. (order x p = i) =\n    (i = 0 \\<and>\n     (\\<forall>a j.\n         (a, j) \\<in> set bs \\<longrightarrow>\n         poly a x \\<noteq> (0::'a)) \\<or>\n     (\\<exists>a j.\n         (a, j) \\<in> set bs \\<and> poly a x = (0::'a) \\<and> i = Suc j))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (order x p = i) =\n    (i = 0 \\<and>\n     (\\<forall>a j.\n         (a, j) \\<in> set bs \\<longrightarrow>\n         poly a x \\<noteq> (0::'a)) \\<or>\n     (\\<exists>a j.\n         (a, j) \\<in> set bs \\<and> poly a x = (0::'a) \\<and> i = Suc j))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. order x p = i \\<Longrightarrow>\n    i = 0 \\<and>\n    (\\<forall>a j.\n        (a, j) \\<in> set bs \\<longrightarrow>\n        poly a x \\<noteq> (0::'a)) \\<or>\n    (\\<exists>a j.\n        (a, j) \\<in> set bs \\<and> poly a x = (0::'a) \\<and> i = Suc j)\n 2. i = 0 \\<and>\n    (\\<forall>a j.\n        (a, j) \\<in> set bs \\<longrightarrow>\n        poly a x \\<noteq> (0::'a)) \\<or>\n    (\\<exists>a j.\n        (a, j) \\<in> set bs \\<and>\n        poly a x = (0::'a) \\<and> i = Suc j) \\<Longrightarrow>\n    order x p = i", "assume \"?r1 \\<or> ?r2\""], ["proof (state)\nthis:\n  i = 0 \\<and>\n  (\\<forall>a j.\n      (a, j) \\<in> set bs \\<longrightarrow> poly a x \\<noteq> (0::'a)) \\<or>\n  (\\<exists>a j.\n      (a, j) \\<in> set bs \\<and> poly a x = (0::'a) \\<and> i = Suc j)\n\ngoal (2 subgoals):\n 1. order x p = i \\<Longrightarrow>\n    i = 0 \\<and>\n    (\\<forall>a j.\n        (a, j) \\<in> set bs \\<longrightarrow>\n        poly a x \\<noteq> (0::'a)) \\<or>\n    (\\<exists>a j.\n        (a, j) \\<in> set bs \\<and> poly a x = (0::'a) \\<and> i = Suc j)\n 2. i = 0 \\<and>\n    (\\<forall>a j.\n        (a, j) \\<in> set bs \\<longrightarrow>\n        poly a x \\<noteq> (0::'a)) \\<or>\n    (\\<exists>a j.\n        (a, j) \\<in> set bs \\<and>\n        poly a x = (0::'a) \\<and> i = Suc j) \\<Longrightarrow>\n    order x p = i", "thus ?l"], ["proof (prove)\nusing this:\n  i = 0 \\<and>\n  (\\<forall>a j.\n      (a, j) \\<in> set bs \\<longrightarrow> poly a x \\<noteq> (0::'a)) \\<or>\n  (\\<exists>a j.\n      (a, j) \\<in> set bs \\<and> poly a x = (0::'a) \\<and> i = Suc j)\n\ngoal (1 subgoal):\n 1. order x p = i", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. i = 0 \\<and>\n    (\\<forall>a j.\n        (a, j) \\<in> set bs \\<longrightarrow>\n        poly a x \\<noteq> (0::'a)) \\<Longrightarrow>\n    order x p = i\n 2. \\<exists>a j.\n       (a, j) \\<in> set bs \\<and>\n       poly a x = (0::'a) \\<and> i = Suc j \\<Longrightarrow>\n    order x p = i", "assume ?r2"], ["proof (state)\nthis:\n  \\<exists>a j.\n     (a, j) \\<in> set bs \\<and> poly a x = (0::'a) \\<and> i = Suc j\n\ngoal (2 subgoals):\n 1. i = 0 \\<and>\n    (\\<forall>a j.\n        (a, j) \\<in> set bs \\<longrightarrow>\n        poly a x \\<noteq> (0::'a)) \\<Longrightarrow>\n    order x p = i\n 2. \\<exists>a j.\n       (a, j) \\<in> set bs \\<and>\n       poly a x = (0::'a) \\<and> i = Suc j \\<Longrightarrow>\n    order x p = i", "then"], ["proof (chain)\npicking this:\n  \\<exists>a j.\n     (a, j) \\<in> set bs \\<and> poly a x = (0::'a) \\<and> i = Suc j", "obtain a j where aj: \"(a,j) \\<in> set bs\" \"poly a x = 0\" and i: \"i = Suc j\""], ["proof (prove)\nusing this:\n  \\<exists>a j.\n     (a, j) \\<in> set bs \\<and> poly a x = (0::'a) \\<and> i = Suc j\n\ngoal (1 subgoal):\n 1. (\\<And>a j.\n        \\<lbrakk>(a, j) \\<in> set bs; poly a x = (0::'a); i = Suc j\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  (a, j) \\<in> set bs\n  poly a x = (0::'a)\n  i = Suc j\n\ngoal (2 subgoals):\n 1. i = 0 \\<and>\n    (\\<forall>a j.\n        (a, j) \\<in> set bs \\<longrightarrow>\n        poly a x \\<noteq> (0::'a)) \\<Longrightarrow>\n    order x p = i\n 2. \\<exists>a j.\n       (a, j) \\<in> set bs \\<and>\n       poly a x = (0::'a) \\<and> i = Suc j \\<Longrightarrow>\n    order x p = i", "from mem[OF aj] i"], ["proof (chain)\npicking this:\n  order x p = Suc j\n  i = Suc j", "show ?l"], ["proof (prove)\nusing this:\n  order x p = Suc j\n  i = Suc j\n\ngoal (1 subgoal):\n 1. order x p = i", "by simp"], ["proof (state)\nthis:\n  order x p = i\n\ngoal (1 subgoal):\n 1. i = 0 \\<and>\n    (\\<forall>a j.\n        (a, j) \\<in> set bs \\<longrightarrow>\n        poly a x \\<noteq> (0::'a)) \\<Longrightarrow>\n    order x p = i", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. i = 0 \\<and>\n    (\\<forall>a j.\n        (a, j) \\<in> set bs \\<longrightarrow>\n        poly a x \\<noteq> (0::'a)) \\<Longrightarrow>\n    order x p = i", "assume ?r1"], ["proof (state)\nthis:\n  i = 0 \\<and>\n  (\\<forall>a j.\n      (a, j) \\<in> set bs \\<longrightarrow> poly a x \\<noteq> (0::'a))\n\ngoal (1 subgoal):\n 1. i = 0 \\<and>\n    (\\<forall>a j.\n        (a, j) \\<in> set bs \\<longrightarrow>\n        poly a x \\<noteq> (0::'a)) \\<Longrightarrow>\n    order x p = i", "with no_mem[of x]"], ["proof (chain)\npicking this:\n  (\\<And>a i.\n      (a, i) \\<in> set bs \\<Longrightarrow>\n      poly a x \\<noteq> (0::'a)) \\<Longrightarrow>\n  order x p = 0\n  i = 0 \\<and>\n  (\\<forall>a j.\n      (a, j) \\<in> set bs \\<longrightarrow> poly a x \\<noteq> (0::'a))", "show ?l"], ["proof (prove)\nusing this:\n  (\\<And>a i.\n      (a, i) \\<in> set bs \\<Longrightarrow>\n      poly a x \\<noteq> (0::'a)) \\<Longrightarrow>\n  order x p = 0\n  i = 0 \\<and>\n  (\\<forall>a j.\n      (a, j) \\<in> set bs \\<longrightarrow> poly a x \\<noteq> (0::'a))\n\ngoal (1 subgoal):\n 1. order x p = i", "by auto"], ["proof (state)\nthis:\n  order x p = i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  order x p = i\n\ngoal (1 subgoal):\n 1. order x p = i \\<Longrightarrow>\n    i = 0 \\<and>\n    (\\<forall>a j.\n        (a, j) \\<in> set bs \\<longrightarrow>\n        poly a x \\<noteq> (0::'a)) \\<or>\n    (\\<exists>a j.\n        (a, j) \\<in> set bs \\<and> poly a x = (0::'a) \\<and> i = Suc j)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. order x p = i \\<Longrightarrow>\n    i = 0 \\<and>\n    (\\<forall>a j.\n        (a, j) \\<in> set bs \\<longrightarrow>\n        poly a x \\<noteq> (0::'a)) \\<or>\n    (\\<exists>a j.\n        (a, j) \\<in> set bs \\<and> poly a x = (0::'a) \\<and> i = Suc j)", "assume ?l"], ["proof (state)\nthis:\n  order x p = i\n\ngoal (1 subgoal):\n 1. order x p = i \\<Longrightarrow>\n    i = 0 \\<and>\n    (\\<forall>a j.\n        (a, j) \\<in> set bs \\<longrightarrow>\n        poly a x \\<noteq> (0::'a)) \\<or>\n    (\\<exists>a j.\n        (a, j) \\<in> set bs \\<and> poly a x = (0::'a) \\<and> i = Suc j)", "show \"?r1 \\<or> ?r2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i = 0 \\<and>\n    (\\<forall>a j.\n        (a, j) \\<in> set bs \\<longrightarrow>\n        poly a x \\<noteq> (0::'a)) \\<or>\n    (\\<exists>a j.\n        (a, j) \\<in> set bs \\<and> poly a x = (0::'a) \\<and> i = Suc j)", "proof (cases \"\\<exists>a j. (a, j) \\<in> set bs \\<and> poly a x = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>a j.\n       (a, j) \\<in> set bs \\<and> poly a x = (0::'a) \\<Longrightarrow>\n    i = 0 \\<and>\n    (\\<forall>a j.\n        (a, j) \\<in> set bs \\<longrightarrow>\n        poly a x \\<noteq> (0::'a)) \\<or>\n    (\\<exists>a j.\n        (a, j) \\<in> set bs \\<and> poly a x = (0::'a) \\<and> i = Suc j)\n 2. \\<nexists>a j.\n       (a, j) \\<in> set bs \\<and> poly a x = (0::'a) \\<Longrightarrow>\n    i = 0 \\<and>\n    (\\<forall>a j.\n        (a, j) \\<in> set bs \\<longrightarrow>\n        poly a x \\<noteq> (0::'a)) \\<or>\n    (\\<exists>a j.\n        (a, j) \\<in> set bs \\<and> poly a x = (0::'a) \\<and> i = Suc j)", "case True"], ["proof (state)\nthis:\n  \\<exists>a j. (a, j) \\<in> set bs \\<and> poly a x = (0::'a)\n\ngoal (2 subgoals):\n 1. \\<exists>a j.\n       (a, j) \\<in> set bs \\<and> poly a x = (0::'a) \\<Longrightarrow>\n    i = 0 \\<and>\n    (\\<forall>a j.\n        (a, j) \\<in> set bs \\<longrightarrow>\n        poly a x \\<noteq> (0::'a)) \\<or>\n    (\\<exists>a j.\n        (a, j) \\<in> set bs \\<and> poly a x = (0::'a) \\<and> i = Suc j)\n 2. \\<nexists>a j.\n       (a, j) \\<in> set bs \\<and> poly a x = (0::'a) \\<Longrightarrow>\n    i = 0 \\<and>\n    (\\<forall>a j.\n        (a, j) \\<in> set bs \\<longrightarrow>\n        poly a x \\<noteq> (0::'a)) \\<or>\n    (\\<exists>a j.\n        (a, j) \\<in> set bs \\<and> poly a x = (0::'a) \\<and> i = Suc j)", "then"], ["proof (chain)\npicking this:\n  \\<exists>a j. (a, j) \\<in> set bs \\<and> poly a x = (0::'a)", "obtain a j where \"(a, j) \\<in> set bs\" \"poly a x = 0\""], ["proof (prove)\nusing this:\n  \\<exists>a j. (a, j) \\<in> set bs \\<and> poly a x = (0::'a)\n\ngoal (1 subgoal):\n 1. (\\<And>a j.\n        \\<lbrakk>(a, j) \\<in> set bs; poly a x = (0::'a)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  (a, j) \\<in> set bs\n  poly a x = (0::'a)\n\ngoal (2 subgoals):\n 1. \\<exists>a j.\n       (a, j) \\<in> set bs \\<and> poly a x = (0::'a) \\<Longrightarrow>\n    i = 0 \\<and>\n    (\\<forall>a j.\n        (a, j) \\<in> set bs \\<longrightarrow>\n        poly a x \\<noteq> (0::'a)) \\<or>\n    (\\<exists>a j.\n        (a, j) \\<in> set bs \\<and> poly a x = (0::'a) \\<and> i = Suc j)\n 2. \\<nexists>a j.\n       (a, j) \\<in> set bs \\<and> poly a x = (0::'a) \\<Longrightarrow>\n    i = 0 \\<and>\n    (\\<forall>a j.\n        (a, j) \\<in> set bs \\<longrightarrow>\n        poly a x \\<noteq> (0::'a)) \\<or>\n    (\\<exists>a j.\n        (a, j) \\<in> set bs \\<and> poly a x = (0::'a) \\<and> i = Suc j)", "with mem[OF this] \\<open>?l\\<close>"], ["proof (chain)\npicking this:\n  order x p = Suc j\n  order x p = i\n  (a, j) \\<in> set bs\n  poly a x = (0::'a)", "have ?r2"], ["proof (prove)\nusing this:\n  order x p = Suc j\n  order x p = i\n  (a, j) \\<in> set bs\n  poly a x = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<exists>a j.\n       (a, j) \\<in> set bs \\<and> poly a x = (0::'a) \\<and> i = Suc j", "by auto"], ["proof (state)\nthis:\n  \\<exists>a j.\n     (a, j) \\<in> set bs \\<and> poly a x = (0::'a) \\<and> i = Suc j\n\ngoal (2 subgoals):\n 1. \\<exists>a j.\n       (a, j) \\<in> set bs \\<and> poly a x = (0::'a) \\<Longrightarrow>\n    i = 0 \\<and>\n    (\\<forall>a j.\n        (a, j) \\<in> set bs \\<longrightarrow>\n        poly a x \\<noteq> (0::'a)) \\<or>\n    (\\<exists>a j.\n        (a, j) \\<in> set bs \\<and> poly a x = (0::'a) \\<and> i = Suc j)\n 2. \\<nexists>a j.\n       (a, j) \\<in> set bs \\<and> poly a x = (0::'a) \\<Longrightarrow>\n    i = 0 \\<and>\n    (\\<forall>a j.\n        (a, j) \\<in> set bs \\<longrightarrow>\n        poly a x \\<noteq> (0::'a)) \\<or>\n    (\\<exists>a j.\n        (a, j) \\<in> set bs \\<and> poly a x = (0::'a) \\<and> i = Suc j)", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>a j.\n     (a, j) \\<in> set bs \\<and> poly a x = (0::'a) \\<and> i = Suc j\n\ngoal (1 subgoal):\n 1. i = 0 \\<and>\n    (\\<forall>a j.\n        (a, j) \\<in> set bs \\<longrightarrow>\n        poly a x \\<noteq> (0::'a)) \\<or>\n    (\\<exists>a j.\n        (a, j) \\<in> set bs \\<and> poly a x = (0::'a) \\<and> i = Suc j)", ".."], ["proof (state)\nthis:\n  i = 0 \\<and>\n  (\\<forall>a j.\n      (a, j) \\<in> set bs \\<longrightarrow> poly a x \\<noteq> (0::'a)) \\<or>\n  (\\<exists>a j.\n      (a, j) \\<in> set bs \\<and> poly a x = (0::'a) \\<and> i = Suc j)\n\ngoal (1 subgoal):\n 1. \\<nexists>a j.\n       (a, j) \\<in> set bs \\<and> poly a x = (0::'a) \\<Longrightarrow>\n    i = 0 \\<and>\n    (\\<forall>a j.\n        (a, j) \\<in> set bs \\<longrightarrow>\n        poly a x \\<noteq> (0::'a)) \\<or>\n    (\\<exists>a j.\n        (a, j) \\<in> set bs \\<and> poly a x = (0::'a) \\<and> i = Suc j)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<nexists>a j.\n       (a, j) \\<in> set bs \\<and> poly a x = (0::'a) \\<Longrightarrow>\n    i = 0 \\<and>\n    (\\<forall>a j.\n        (a, j) \\<in> set bs \\<longrightarrow>\n        poly a x \\<noteq> (0::'a)) \\<or>\n    (\\<exists>a j.\n        (a, j) \\<in> set bs \\<and> poly a x = (0::'a) \\<and> i = Suc j)", "case False"], ["proof (state)\nthis:\n  \\<nexists>a j. (a, j) \\<in> set bs \\<and> poly a x = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<nexists>a j.\n       (a, j) \\<in> set bs \\<and> poly a x = (0::'a) \\<Longrightarrow>\n    i = 0 \\<and>\n    (\\<forall>a j.\n        (a, j) \\<in> set bs \\<longrightarrow>\n        poly a x \\<noteq> (0::'a)) \\<or>\n    (\\<exists>a j.\n        (a, j) \\<in> set bs \\<and> poly a x = (0::'a) \\<and> i = Suc j)", "with no_mem[of x] \\<open>?l\\<close>"], ["proof (chain)\npicking this:\n  (\\<And>a i.\n      (a, i) \\<in> set bs \\<Longrightarrow>\n      poly a x \\<noteq> (0::'a)) \\<Longrightarrow>\n  order x p = 0\n  order x p = i\n  \\<nexists>a j. (a, j) \\<in> set bs \\<and> poly a x = (0::'a)", "have ?r1"], ["proof (prove)\nusing this:\n  (\\<And>a i.\n      (a, i) \\<in> set bs \\<Longrightarrow>\n      poly a x \\<noteq> (0::'a)) \\<Longrightarrow>\n  order x p = 0\n  order x p = i\n  \\<nexists>a j. (a, j) \\<in> set bs \\<and> poly a x = (0::'a)\n\ngoal (1 subgoal):\n 1. i = 0 \\<and>\n    (\\<forall>a j.\n        (a, j) \\<in> set bs \\<longrightarrow> poly a x \\<noteq> (0::'a))", "by auto"], ["proof (state)\nthis:\n  i = 0 \\<and>\n  (\\<forall>a j.\n      (a, j) \\<in> set bs \\<longrightarrow> poly a x \\<noteq> (0::'a))\n\ngoal (1 subgoal):\n 1. \\<nexists>a j.\n       (a, j) \\<in> set bs \\<and> poly a x = (0::'a) \\<Longrightarrow>\n    i = 0 \\<and>\n    (\\<forall>a j.\n        (a, j) \\<in> set bs \\<longrightarrow>\n        poly a x \\<noteq> (0::'a)) \\<or>\n    (\\<exists>a j.\n        (a, j) \\<in> set bs \\<and> poly a x = (0::'a) \\<and> i = Suc j)", "thus ?thesis"], ["proof (prove)\nusing this:\n  i = 0 \\<and>\n  (\\<forall>a j.\n      (a, j) \\<in> set bs \\<longrightarrow> poly a x \\<noteq> (0::'a))\n\ngoal (1 subgoal):\n 1. i = 0 \\<and>\n    (\\<forall>a j.\n        (a, j) \\<in> set bs \\<longrightarrow>\n        poly a x \\<noteq> (0::'a)) \\<or>\n    (\\<exists>a j.\n        (a, j) \\<in> set bs \\<and> poly a x = (0::'a) \\<and> i = Suc j)", ".."], ["proof (state)\nthis:\n  i = 0 \\<and>\n  (\\<forall>a j.\n      (a, j) \\<in> set bs \\<longrightarrow> poly a x \\<noteq> (0::'a)) \\<or>\n  (\\<exists>a j.\n      (a, j) \\<in> set bs \\<and> poly a x = (0::'a) \\<and> i = Suc j)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  i = 0 \\<and>\n  (\\<forall>a j.\n      (a, j) \\<in> set bs \\<longrightarrow> poly a x \\<noteq> (0::'a)) \\<or>\n  (\\<exists>a j.\n      (a, j) \\<in> set bs \\<and> poly a x = (0::'a) \\<and> i = Suc j)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (order x p = i) =\n  (i = 0 \\<and>\n   (\\<forall>a j.\n       (a, j) \\<in> set bs \\<longrightarrow>\n       poly a x \\<noteq> (0::'a)) \\<or>\n   (\\<exists>a j.\n       (a, j) \\<in> set bs \\<and> poly a x = (0::'a) \\<and> i = Suc j))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma square_free_factorization_root: \n  assumes sff: \"square_free_factorization p (c,bs)\"\n    and p: \"p \\<noteq> (0 :: 'a poly)\"\n  shows \"{x. poly p x = 0} = {x. \\<exists> a i. (a,i) \\<in> set bs \\<and> poly a x = 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. poly p x = (0::'a)} =\n    {x. \\<exists>a i. (a, i) \\<in> set bs \\<and> poly a x = (0::'a)}", "using square_free_factorization_order_root[OF sff p] p"], ["proof (prove)\nusing this:\n  (order ?x p = ?i) =\n  (?i = 0 \\<and>\n   (\\<forall>a j.\n       (a, j) \\<in> set bs \\<longrightarrow>\n       poly a ?x \\<noteq> (0::'a)) \\<or>\n   (\\<exists>a j.\n       (a, j) \\<in> set bs \\<and> poly a ?x = (0::'a) \\<and> ?i = Suc j))\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. {x. poly p x = (0::'a)} =\n    {x. \\<exists>a i. (a, i) \\<in> set bs \\<and> poly a x = (0::'a)}", "unfolding order_root"], ["proof (prove)\nusing this:\n  (order ?x p = ?i) =\n  (?i = 0 \\<and>\n   (\\<forall>a j.\n       (a, j) \\<in> set bs \\<longrightarrow>\n       \\<not> (a = 0 \\<or> order ?x a \\<noteq> 0)) \\<or>\n   (\\<exists>a j.\n       (a, j) \\<in> set bs \\<and>\n       (a = 0 \\<or> order ?x a \\<noteq> 0) \\<and> ?i = Suc j))\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. {x. p = 0 \\<or> order x p \\<noteq> 0} =\n    {x. \\<exists>a i.\n           (a, i) \\<in> set bs \\<and> (a = 0 \\<or> order x a \\<noteq> 0)}", "by auto"], ["", "lemma square_free_factorizationD': fixes p :: \"'a poly\"\n  assumes sf: \"square_free_factorization p (c, bs)\"\n  shows \"p = smult c (\\<Prod>(a, i) \\<leftarrow> bs. a ^ Suc i)\"\n    and \"square_free (prod_list (map fst bs))\"\n    and \"\\<And> b i. (b,i) \\<in> set bs \\<Longrightarrow> degree b \\<noteq> 0\"\n    and \"p = 0 \\<Longrightarrow> c = 0 \\<and> bs = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (p = smult c (\\<Prod>(a, i)\\<leftarrow>bs. a ^ Suc i) &&&\n     square_free (prod_list (map fst bs))) &&&\n    (\\<And>b i.\n        (b, i) \\<in> set bs \\<Longrightarrow> degree b \\<noteq> 0) &&&\n    (p = 0 \\<Longrightarrow> c = (0::'a) \\<and> bs = [])", "proof -"], ["proof (state)\ngoal (4 subgoals):\n 1. p = smult c (\\<Prod>(a, i)\\<leftarrow>bs. a ^ Suc i)\n 2. square_free (prod_list (map fst bs))\n 3. \\<And>b i. (b, i) \\<in> set bs \\<Longrightarrow> degree b \\<noteq> 0\n 4. p = 0 \\<Longrightarrow> c = (0::'a) \\<and> bs = []", "note sf = square_free_factorizationD[OF sf]"], ["proof (state)\nthis:\n  p = smult c (\\<Prod>(a, i)\\<in>set bs. a ^ Suc i)\n  (?a, ?i) \\<in> set bs \\<Longrightarrow>\n  square_free ?a \\<and> degree ?a \\<noteq> 0\n  \\<lbrakk>(?a, ?i) \\<in> set bs; (?b, ?j) \\<in> set bs;\n   (?a, ?i) \\<noteq> (?b, ?j)\\<rbrakk>\n  \\<Longrightarrow> coprime ?a ?b\n  p = 0 \\<Longrightarrow> c = (0::'a) \\<and> bs = []\n  distinct bs\n\ngoal (4 subgoals):\n 1. p = smult c (\\<Prod>(a, i)\\<leftarrow>bs. a ^ Suc i)\n 2. square_free (prod_list (map fst bs))\n 3. \\<And>b i. (b, i) \\<in> set bs \\<Longrightarrow> degree b \\<noteq> 0\n 4. p = 0 \\<Longrightarrow> c = (0::'a) \\<and> bs = []", "show \"p = smult c (\\<Prod>(a, i) \\<leftarrow> bs. a ^ Suc i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p = smult c (\\<Prod>(a, i)\\<leftarrow>bs. a ^ Suc i)", "unfolding sf(1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. smult c (\\<Prod>(a, i)\\<in>set bs. a ^ Suc i) =\n    smult c (\\<Prod>(a, i)\\<leftarrow>bs. a ^ Suc i)", "using sf(5)"], ["proof (prove)\nusing this:\n  distinct bs\n\ngoal (1 subgoal):\n 1. smult c (\\<Prod>(a, i)\\<in>set bs. a ^ Suc i) =\n    smult c (\\<Prod>(a, i)\\<leftarrow>bs. a ^ Suc i)", "by (simp add: prod.distinct_set_conv_list)"], ["proof (state)\nthis:\n  p = smult c (\\<Prod>(a, i)\\<leftarrow>bs. a ^ Suc i)\n\ngoal (3 subgoals):\n 1. square_free (prod_list (map fst bs))\n 2. \\<And>b i. (b, i) \\<in> set bs \\<Longrightarrow> degree b \\<noteq> 0\n 3. p = 0 \\<Longrightarrow> c = (0::'a) \\<and> bs = []", "show bs: \"\\<And> b i. (b,i) \\<in> set bs \\<Longrightarrow> degree b \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b i. (b, i) \\<in> set bs \\<Longrightarrow> degree b \\<noteq> 0", "using sf(2)"], ["proof (prove)\nusing this:\n  (?a, ?i) \\<in> set bs \\<Longrightarrow>\n  square_free ?a \\<and> degree ?a \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>b i. (b, i) \\<in> set bs \\<Longrightarrow> degree b \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  (?b, ?i) \\<in> set bs \\<Longrightarrow> degree ?b \\<noteq> 0\n\ngoal (2 subgoals):\n 1. square_free (prod_list (map fst bs))\n 2. p = 0 \\<Longrightarrow> c = (0::'a) \\<and> bs = []", "show \"p = 0 \\<Longrightarrow> c = 0 \\<and> bs = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p = 0 \\<Longrightarrow> c = (0::'a) \\<and> bs = []", "using sf(4)"], ["proof (prove)\nusing this:\n  p = 0 \\<Longrightarrow> c = (0::'a) \\<and> bs = []\n\ngoal (1 subgoal):\n 1. p = 0 \\<Longrightarrow> c = (0::'a) \\<and> bs = []", "."], ["proof (state)\nthis:\n  p = 0 \\<Longrightarrow> c = (0::'a) \\<and> bs = []\n\ngoal (1 subgoal):\n 1. square_free (prod_list (map fst bs))", "show \"square_free (prod_list (map fst bs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. square_free (prod_list (map fst bs))", "proof (rule square_freeI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>q.\n       \\<lbrakk>0 < degree q; q \\<noteq> 0;\n        q * q dvd prod_list (map fst bs)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. prod_list (map fst bs) \\<noteq> 0", "from bs"], ["proof (chain)\npicking this:\n  (?b, ?i) \\<in> set bs \\<Longrightarrow> degree ?b \\<noteq> 0", "have \"\\<And> b. b \\<in> set (map fst bs) \\<Longrightarrow> b \\<noteq> 0\""], ["proof (prove)\nusing this:\n  (?b, ?i) \\<in> set bs \\<Longrightarrow> degree ?b \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>b. b \\<in> set (map fst bs) \\<Longrightarrow> b \\<noteq> 0", "by fastforce"], ["proof (state)\nthis:\n  ?b \\<in> set (map fst bs) \\<Longrightarrow> ?b \\<noteq> 0\n\ngoal (2 subgoals):\n 1. \\<And>q.\n       \\<lbrakk>0 < degree q; q \\<noteq> 0;\n        q * q dvd prod_list (map fst bs)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. prod_list (map fst bs) \\<noteq> 0", "thus \"prod_list (map fst bs) \\<noteq> 0\""], ["proof (prove)\nusing this:\n  ?b \\<in> set (map fst bs) \\<Longrightarrow> ?b \\<noteq> 0\n\ngoal (1 subgoal):\n 1. prod_list (map fst bs) \\<noteq> 0", "unfolding prod_list_zero_iff"], ["proof (prove)\nusing this:\n  ?b \\<in> set (map fst bs) \\<Longrightarrow> ?b \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 \\<notin> set (map fst bs)", "by auto"], ["proof (state)\nthis:\n  prod_list (map fst bs) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>q.\n       \\<lbrakk>0 < degree q; q \\<noteq> 0;\n        q * q dvd prod_list (map fst bs)\\<rbrakk>\n       \\<Longrightarrow> False", "fix q"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>q.\n       \\<lbrakk>0 < degree q; q \\<noteq> 0;\n        q * q dvd prod_list (map fst bs)\\<rbrakk>\n       \\<Longrightarrow> False", "assume \"degree q > 0\" \"q * q dvd prod_list (map fst bs)\""], ["proof (state)\nthis:\n  0 < degree q\n  q * q dvd prod_list (map fst bs)\n\ngoal (1 subgoal):\n 1. \\<And>q.\n       \\<lbrakk>0 < degree q; q \\<noteq> 0;\n        q * q dvd prod_list (map fst bs)\\<rbrakk>\n       \\<Longrightarrow> False", "from irreducible\\<^sub>d_factor[OF this(1)] this(2)"], ["proof (chain)\npicking this:\n  \\<exists>qa r.\n     irreducible\\<^sub>d qa \\<and> q = qa * r \\<and> degree r < degree q\n  q * q dvd prod_list (map fst bs)", "obtain q where \n      irr: \"irreducible q\" and dvd: \"q * q dvd prod_list (map fst bs)\""], ["proof (prove)\nusing this:\n  \\<exists>qa r.\n     irreducible\\<^sub>d qa \\<and> q = qa * r \\<and> degree r < degree q\n  q * q dvd prod_list (map fst bs)\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        \\<lbrakk>irreducible q; q * q dvd prod_list (map fst bs)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding dvd_def"], ["proof (prove)\nusing this:\n  \\<exists>qa r.\n     irreducible\\<^sub>d qa \\<and> q = qa * r \\<and> degree r < degree q\n  \\<exists>k. prod_list (map fst bs) = q * q * k\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        \\<lbrakk>irreducible q;\n         \\<exists>k. prod_list (map fst bs) = q * q * k\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  irreducible q\n  q * q dvd prod_list (map fst bs)\n\ngoal (1 subgoal):\n 1. \\<And>q.\n       \\<lbrakk>0 < degree q; q \\<noteq> 0;\n        q * q dvd prod_list (map fst bs)\\<rbrakk>\n       \\<Longrightarrow> False", "hence dvd': \"q dvd prod_list (map fst bs)\""], ["proof (prove)\nusing this:\n  irreducible q\n  q * q dvd prod_list (map fst bs)\n\ngoal (1 subgoal):\n 1. q dvd prod_list (map fst bs)", "unfolding dvd_def"], ["proof (prove)\nusing this:\n  irreducible q\n  \\<exists>k. prod_list (map fst bs) = q * q * k\n\ngoal (1 subgoal):\n 1. \\<exists>k. prod_list (map fst bs) = q * k", "by auto"], ["proof (state)\nthis:\n  q dvd prod_list (map fst bs)\n\ngoal (1 subgoal):\n 1. \\<And>q.\n       \\<lbrakk>0 < degree q; q \\<noteq> 0;\n        q * q dvd prod_list (map fst bs)\\<rbrakk>\n       \\<Longrightarrow> False", "from irreducible_dvd_prod_list[OF irr dvd']"], ["proof (chain)\npicking this:\n  Bex (set (map fst bs)) ((dvd) q)", "obtain b i where \n      mem: \"(b,i) \\<in> set bs\" and dvd1: \"q dvd b\""], ["proof (prove)\nusing this:\n  Bex (set (map fst bs)) ((dvd) q)\n\ngoal (1 subgoal):\n 1. (\\<And>b i.\n        \\<lbrakk>(b, i) \\<in> set bs; q dvd b\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  (b, i) \\<in> set bs\n  q dvd b\n\ngoal (1 subgoal):\n 1. \\<And>q.\n       \\<lbrakk>0 < degree q; q \\<noteq> 0;\n        q * q dvd prod_list (map fst bs)\\<rbrakk>\n       \\<Longrightarrow> False", "from dvd1"], ["proof (chain)\npicking this:\n  q dvd b", "obtain k where b: \"b = q * k\""], ["proof (prove)\nusing this:\n  q dvd b\n\ngoal (1 subgoal):\n 1. (\\<And>k. b = q * k \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "unfolding dvd_def"], ["proof (prove)\nusing this:\n  \\<exists>k. b = q * k\n\ngoal (1 subgoal):\n 1. (\\<And>k. b = q * k \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  b = q * k\n\ngoal (1 subgoal):\n 1. \\<And>q.\n       \\<lbrakk>0 < degree q; q \\<noteq> 0;\n        q * q dvd prod_list (map fst bs)\\<rbrakk>\n       \\<Longrightarrow> False", "from split_list[OF mem] b"], ["proof (chain)\npicking this:\n  \\<exists>ys zs. bs = ys @ (b, i) # zs\n  b = q * k", "obtain bs1 bs2 where bs: \"bs = bs1 @ (b, i) # bs2\""], ["proof (prove)\nusing this:\n  \\<exists>ys zs. bs = ys @ (b, i) # zs\n  b = q * k\n\ngoal (1 subgoal):\n 1. (\\<And>bs1 bs2.\n        bs = bs1 @ (b, i) # bs2 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  bs = bs1 @ (b, i) # bs2\n\ngoal (1 subgoal):\n 1. \\<And>q.\n       \\<lbrakk>0 < degree q; q \\<noteq> 0;\n        q * q dvd prod_list (map fst bs)\\<rbrakk>\n       \\<Longrightarrow> False", "from irr"], ["proof (chain)\npicking this:\n  irreducible q", "have q0: \"q \\<noteq> 0\" and dq: \"degree q > 0\""], ["proof (prove)\nusing this:\n  irreducible q\n\ngoal (1 subgoal):\n 1. q \\<noteq> 0 &&& 0 < degree q", "unfolding irreducible\\<^sub>d_def"], ["proof (prove)\nusing this:\n  irreducible q\n\ngoal (1 subgoal):\n 1. q \\<noteq> 0 &&& 0 < degree q", "by auto"], ["proof (state)\nthis:\n  q \\<noteq> 0\n  0 < degree q\n\ngoal (1 subgoal):\n 1. \\<And>q.\n       \\<lbrakk>0 < degree q; q \\<noteq> 0;\n        q * q dvd prod_list (map fst bs)\\<rbrakk>\n       \\<Longrightarrow> False", "from sf(2)[OF mem, unfolded b]"], ["proof (chain)\npicking this:\n  square_free (q * k) \\<and> degree (q * k) \\<noteq> 0", "have \"square_free (q * k)\""], ["proof (prove)\nusing this:\n  square_free (q * k) \\<and> degree (q * k) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. square_free (q * k)", "by auto"], ["proof (state)\nthis:\n  square_free (q * k)\n\ngoal (1 subgoal):\n 1. \\<And>q.\n       \\<lbrakk>0 < degree q; q \\<noteq> 0;\n        q * q dvd prod_list (map fst bs)\\<rbrakk>\n       \\<Longrightarrow> False", "from this[unfolded square_free_def, THEN conjunct2, rule_format, OF dq]"], ["proof (chain)\npicking this:\n  \\<not> q * q dvd q * k", "have qk: \"\\<not> q dvd k\""], ["proof (prove)\nusing this:\n  \\<not> q * q dvd q * k\n\ngoal (1 subgoal):\n 1. \\<not> q dvd k", "by simp"], ["proof (state)\nthis:\n  \\<not> q dvd k\n\ngoal (1 subgoal):\n 1. \\<And>q.\n       \\<lbrakk>0 < degree q; q \\<noteq> 0;\n        q * q dvd prod_list (map fst bs)\\<rbrakk>\n       \\<Longrightarrow> False", "from dvd[unfolded bs b]"], ["proof (chain)\npicking this:\n  q * q dvd prod_list (map fst (bs1 @ (q * k, i) # bs2))", "have \"q * q dvd q * (k * prod_list (map fst (bs1 @ bs2)))\""], ["proof (prove)\nusing this:\n  q * q dvd prod_list (map fst (bs1 @ (q * k, i) # bs2))\n\ngoal (1 subgoal):\n 1. q * q dvd q * (k * prod_list (map fst (bs1 @ bs2)))", "by (auto simp: ac_simps)"], ["proof (state)\nthis:\n  q * q dvd q * (k * prod_list (map fst (bs1 @ bs2)))\n\ngoal (1 subgoal):\n 1. \\<And>q.\n       \\<lbrakk>0 < degree q; q \\<noteq> 0;\n        q * q dvd prod_list (map fst bs)\\<rbrakk>\n       \\<Longrightarrow> False", "with q0"], ["proof (chain)\npicking this:\n  q \\<noteq> 0\n  q * q dvd q * (k * prod_list (map fst (bs1 @ bs2)))", "have \"q dvd k * prod_list (map fst (bs1 @ bs2))\""], ["proof (prove)\nusing this:\n  q \\<noteq> 0\n  q * q dvd q * (k * prod_list (map fst (bs1 @ bs2)))\n\ngoal (1 subgoal):\n 1. q dvd k * prod_list (map fst (bs1 @ bs2))", "by auto"], ["proof (state)\nthis:\n  q dvd k * prod_list (map fst (bs1 @ bs2))\n\ngoal (1 subgoal):\n 1. \\<And>q.\n       \\<lbrakk>0 < degree q; q \\<noteq> 0;\n        q * q dvd prod_list (map fst bs)\\<rbrakk>\n       \\<Longrightarrow> False", "with irr qk"], ["proof (chain)\npicking this:\n  irreducible q\n  \\<not> q dvd k\n  q dvd k * prod_list (map fst (bs1 @ bs2))", "have \"q dvd prod_list (map fst (bs1 @ bs2))\""], ["proof (prove)\nusing this:\n  irreducible q\n  \\<not> q dvd k\n  q dvd k * prod_list (map fst (bs1 @ bs2))\n\ngoal (1 subgoal):\n 1. q dvd prod_list (map fst (bs1 @ bs2))", "by auto"], ["proof (state)\nthis:\n  q dvd prod_list (map fst (bs1 @ bs2))\n\ngoal (1 subgoal):\n 1. \\<And>q.\n       \\<lbrakk>0 < degree q; q \\<noteq> 0;\n        q * q dvd prod_list (map fst bs)\\<rbrakk>\n       \\<Longrightarrow> False", "from irreducible_dvd_prod_list[OF irr this]"], ["proof (chain)\npicking this:\n  Bex (set (map fst (bs1 @ bs2))) ((dvd) q)", "obtain b' i' where \n      mem': \"(b',i') \\<in> set (bs1 @ bs2)\" and dvd2: \"q dvd b'\""], ["proof (prove)\nusing this:\n  Bex (set (map fst (bs1 @ bs2))) ((dvd) q)\n\ngoal (1 subgoal):\n 1. (\\<And>b' i'.\n        \\<lbrakk>(b', i') \\<in> set (bs1 @ bs2); q dvd b'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  (b', i') \\<in> set (bs1 @ bs2)\n  q dvd b'\n\ngoal (1 subgoal):\n 1. \\<And>q.\n       \\<lbrakk>0 < degree q; q \\<noteq> 0;\n        q * q dvd prod_list (map fst bs)\\<rbrakk>\n       \\<Longrightarrow> False", "from dvd1 dvd2"], ["proof (chain)\npicking this:\n  q dvd b\n  q dvd b'", "have \"q dvd gcd b b'\""], ["proof (prove)\nusing this:\n  q dvd b\n  q dvd b'\n\ngoal (1 subgoal):\n 1. q dvd gcd b b'", "by auto"], ["proof (state)\nthis:\n  q dvd gcd b b'\n\ngoal (1 subgoal):\n 1. \\<And>q.\n       \\<lbrakk>0 < degree q; q \\<noteq> 0;\n        q * q dvd prod_list (map fst bs)\\<rbrakk>\n       \\<Longrightarrow> False", "with dq is_unit_iff_degree[OF q0]"], ["proof (chain)\npicking this:\n  0 < degree q\n  is_unit q = (degree q = 0)\n  q dvd gcd b b'", "have cop: \"\\<not> coprime b b'\""], ["proof (prove)\nusing this:\n  0 < degree q\n  is_unit q = (degree q = 0)\n  q dvd gcd b b'\n\ngoal (1 subgoal):\n 1. \\<not> coprime b b'", "by force"], ["proof (state)\nthis:\n  \\<not> coprime b b'\n\ngoal (1 subgoal):\n 1. \\<And>q.\n       \\<lbrakk>0 < degree q; q \\<noteq> 0;\n        q * q dvd prod_list (map fst bs)\\<rbrakk>\n       \\<Longrightarrow> False", "from mem'"], ["proof (chain)\npicking this:\n  (b', i') \\<in> set (bs1 @ bs2)", "have \"(b',i') \\<in> set bs\""], ["proof (prove)\nusing this:\n  (b', i') \\<in> set (bs1 @ bs2)\n\ngoal (1 subgoal):\n 1. (b', i') \\<in> set bs", "unfolding bs"], ["proof (prove)\nusing this:\n  (b', i') \\<in> set (bs1 @ bs2)\n\ngoal (1 subgoal):\n 1. (b', i') \\<in> set (bs1 @ (b, i) # bs2)", "by auto"], ["proof (state)\nthis:\n  (b', i') \\<in> set bs\n\ngoal (1 subgoal):\n 1. \\<And>q.\n       \\<lbrakk>0 < degree q; q \\<noteq> 0;\n        q * q dvd prod_list (map fst bs)\\<rbrakk>\n       \\<Longrightarrow> False", "from sf(3)[OF mem this] cop"], ["proof (chain)\npicking this:\n  (b, i) \\<noteq> (b', i') \\<Longrightarrow> coprime b b'\n  \\<not> coprime b b'", "have b': \"(b',i') = (b,i)\""], ["proof (prove)\nusing this:\n  (b, i) \\<noteq> (b', i') \\<Longrightarrow> coprime b b'\n  \\<not> coprime b b'\n\ngoal (1 subgoal):\n 1. (b', i') = (b, i)", "by (auto simp add: coprime_iff_gcd_eq_1)"], ["proof (state)\nthis:\n  (b', i') = (b, i)\n\ngoal (1 subgoal):\n 1. \\<And>q.\n       \\<lbrakk>0 < degree q; q \\<noteq> 0;\n        q * q dvd prod_list (map fst bs)\\<rbrakk>\n       \\<Longrightarrow> False", "with mem' sf(5)[unfolded bs]"], ["proof (chain)\npicking this:\n  (b', i') \\<in> set (bs1 @ bs2)\n  distinct (bs1 @ (b, i) # bs2)\n  (b', i') = (b, i)", "show False"], ["proof (prove)\nusing this:\n  (b', i') \\<in> set (bs1 @ bs2)\n  distinct (bs1 @ (b, i) # bs2)\n  (b', i') = (b, i)\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  square_free (prod_list (map fst bs))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma square_free_factorizationI': fixes p :: \"'a poly\"\n  assumes prod: \"p = smult c (\\<Prod>(a, i) \\<leftarrow> bs. a ^ Suc i)\"\n    and sf: \"square_free (prod_list (map fst bs))\"\n    and deg: \"\\<And> b i. (b,i) \\<in> set bs \\<Longrightarrow> degree b > 0\"\n    and 0: \"p = 0 \\<Longrightarrow> c = 0 \\<and> bs = []\"\n  shows \"square_free_factorization p (c, bs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. square_free_factorization p (c, bs)", "unfolding square_free_factorization_def split"], ["proof (prove)\ngoal (1 subgoal):\n 1. p = smult c (\\<Prod>(a, i)\\<in>set bs. a ^ Suc i) \\<and>\n    (p = 0 \\<longrightarrow> c = (0::'a) \\<and> bs = []) \\<and>\n    (\\<forall>a i.\n        (a, i) \\<in> set bs \\<longrightarrow>\n        square_free a \\<and> 0 < degree a) \\<and>\n    (\\<forall>a i b j.\n        (a, i) \\<in> set bs \\<longrightarrow>\n        (b, j) \\<in> set bs \\<longrightarrow>\n        (a, i) \\<noteq> (b, j) \\<longrightarrow> coprime a b) \\<and>\n    distinct bs", "proof (intro conjI impI allI)"], ["proof (state)\ngoal (7 subgoals):\n 1. p = smult c (\\<Prod>(a, i)\\<in>set bs. a ^ Suc i)\n 2. p = 0 \\<Longrightarrow> c = (0::'a)\n 3. p = 0 \\<Longrightarrow> bs = []\n 4. \\<And>a i. (a, i) \\<in> set bs \\<Longrightarrow> square_free a\n 5. \\<And>a i. (a, i) \\<in> set bs \\<Longrightarrow> 0 < degree a\n 6. \\<And>a i b j.\n       \\<lbrakk>(a, i) \\<in> set bs; (b, j) \\<in> set bs;\n        (a, i) \\<noteq> (b, j)\\<rbrakk>\n       \\<Longrightarrow> coprime a b\n 7. distinct bs", "show \"p = 0 \\<Longrightarrow> c = 0\" \"p = 0 \\<Longrightarrow> bs = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (p = 0 \\<Longrightarrow> c = (0::'a)) &&&\n    (p = 0 \\<Longrightarrow> bs = [])", "using 0"], ["proof (prove)\nusing this:\n  p = 0 \\<Longrightarrow> c = (0::'a) \\<and> bs = []\n\ngoal (1 subgoal):\n 1. (p = 0 \\<Longrightarrow> c = (0::'a)) &&&\n    (p = 0 \\<Longrightarrow> bs = [])", "by auto"], ["proof (state)\nthis:\n  p = 0 \\<Longrightarrow> c = (0::'a)\n  p = 0 \\<Longrightarrow> bs = []\n\ngoal (5 subgoals):\n 1. p = smult c (\\<Prod>(a, i)\\<in>set bs. a ^ Suc i)\n 2. \\<And>a i. (a, i) \\<in> set bs \\<Longrightarrow> square_free a\n 3. \\<And>a i. (a, i) \\<in> set bs \\<Longrightarrow> 0 < degree a\n 4. \\<And>a i b j.\n       \\<lbrakk>(a, i) \\<in> set bs; (b, j) \\<in> set bs;\n        (a, i) \\<noteq> (b, j)\\<rbrakk>\n       \\<Longrightarrow> coprime a b\n 5. distinct bs", "{"], ["proof (state)\nthis:\n  p = 0 \\<Longrightarrow> c = (0::'a)\n  p = 0 \\<Longrightarrow> bs = []\n\ngoal (5 subgoals):\n 1. p = smult c (\\<Prod>(a, i)\\<in>set bs. a ^ Suc i)\n 2. \\<And>a i. (a, i) \\<in> set bs \\<Longrightarrow> square_free a\n 3. \\<And>a i. (a, i) \\<in> set bs \\<Longrightarrow> 0 < degree a\n 4. \\<And>a i b j.\n       \\<lbrakk>(a, i) \\<in> set bs; (b, j) \\<in> set bs;\n        (a, i) \\<noteq> (b, j)\\<rbrakk>\n       \\<Longrightarrow> coprime a b\n 5. distinct bs", "fix b i"], ["proof (state)\ngoal (5 subgoals):\n 1. p = smult c (\\<Prod>(a, i)\\<in>set bs. a ^ Suc i)\n 2. \\<And>a i. (a, i) \\<in> set bs \\<Longrightarrow> square_free a\n 3. \\<And>a i. (a, i) \\<in> set bs \\<Longrightarrow> 0 < degree a\n 4. \\<And>a i b j.\n       \\<lbrakk>(a, i) \\<in> set bs; (b, j) \\<in> set bs;\n        (a, i) \\<noteq> (b, j)\\<rbrakk>\n       \\<Longrightarrow> coprime a b\n 5. distinct bs", "assume bi: \"(b,i) \\<in> set bs\""], ["proof (state)\nthis:\n  (b, i) \\<in> set bs\n\ngoal (5 subgoals):\n 1. p = smult c (\\<Prod>(a, i)\\<in>set bs. a ^ Suc i)\n 2. \\<And>a i. (a, i) \\<in> set bs \\<Longrightarrow> square_free a\n 3. \\<And>a i. (a, i) \\<in> set bs \\<Longrightarrow> 0 < degree a\n 4. \\<And>a i b j.\n       \\<lbrakk>(a, i) \\<in> set bs; (b, j) \\<in> set bs;\n        (a, i) \\<noteq> (b, j)\\<rbrakk>\n       \\<Longrightarrow> coprime a b\n 5. distinct bs", "from deg[OF this]"], ["proof (chain)\npicking this:\n  0 < degree b", "show \"degree b > 0\""], ["proof (prove)\nusing this:\n  0 < degree b\n\ngoal (1 subgoal):\n 1. 0 < degree b", "."], ["proof (state)\nthis:\n  0 < degree b\n\ngoal (4 subgoals):\n 1. p = smult c (\\<Prod>(a, i)\\<in>set bs. a ^ Suc i)\n 2. \\<And>a i. (a, i) \\<in> set bs \\<Longrightarrow> square_free a\n 3. \\<And>a i b j.\n       \\<lbrakk>(a, i) \\<in> set bs; (b, j) \\<in> set bs;\n        (a, i) \\<noteq> (b, j)\\<rbrakk>\n       \\<Longrightarrow> coprime a b\n 4. distinct bs", "have \"b dvd prod_list (map fst bs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b dvd prod_list (map fst bs)", "by (intro prod_list_dvd, insert bi, force)"], ["proof (state)\nthis:\n  b dvd prod_list (map fst bs)\n\ngoal (4 subgoals):\n 1. p = smult c (\\<Prod>(a, i)\\<in>set bs. a ^ Suc i)\n 2. \\<And>a i. (a, i) \\<in> set bs \\<Longrightarrow> square_free a\n 3. \\<And>a i b j.\n       \\<lbrakk>(a, i) \\<in> set bs; (b, j) \\<in> set bs;\n        (a, i) \\<noteq> (b, j)\\<rbrakk>\n       \\<Longrightarrow> coprime a b\n 4. distinct bs", "from square_free_factor[OF this sf]"], ["proof (chain)\npicking this:\n  square_free b", "show \"square_free b\""], ["proof (prove)\nusing this:\n  square_free b\n\ngoal (1 subgoal):\n 1. square_free b", "."], ["proof (state)\nthis:\n  square_free b\n\ngoal (3 subgoals):\n 1. p = smult c (\\<Prod>(a, i)\\<in>set bs. a ^ Suc i)\n 2. \\<And>a i b j.\n       \\<lbrakk>(a, i) \\<in> set bs; (b, j) \\<in> set bs;\n        (a, i) \\<noteq> (b, j)\\<rbrakk>\n       \\<Longrightarrow> coprime a b\n 3. distinct bs", "}"], ["proof (state)\nthis:\n  (?b2, ?i2) \\<in> set bs \\<Longrightarrow> square_free ?b2\n\ngoal (3 subgoals):\n 1. p = smult c (\\<Prod>(a, i)\\<in>set bs. a ^ Suc i)\n 2. \\<And>a i b j.\n       \\<lbrakk>(a, i) \\<in> set bs; (b, j) \\<in> set bs;\n        (a, i) \\<noteq> (b, j)\\<rbrakk>\n       \\<Longrightarrow> coprime a b\n 3. distinct bs", "show dist: \"distinct bs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct bs", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> distinct bs \\<Longrightarrow> False", "assume \"\\<not> ?thesis\""], ["proof (state)\nthis:\n  \\<not> distinct bs\n\ngoal (1 subgoal):\n 1. \\<not> distinct bs \\<Longrightarrow> False", "from not_distinct_decomp[OF this]"], ["proof (chain)\npicking this:\n  \\<exists>xs ys zs y. bs = xs @ [y] @ ys @ [y] @ zs", "obtain bs1 bs2 bs3 b i where\n      bs: \"bs = bs1 @ [(b,i)] @ bs2 @ [(b,i)] @ bs3\""], ["proof (prove)\nusing this:\n  \\<exists>xs ys zs y. bs = xs @ [y] @ ys @ [y] @ zs\n\ngoal (1 subgoal):\n 1. (\\<And>bs1 b i bs2 bs3.\n        bs = bs1 @ [(b, i)] @ bs2 @ [(b, i)] @ bs3 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  bs = bs1 @ [(b, i)] @ bs2 @ [(b, i)] @ bs3\n\ngoal (1 subgoal):\n 1. \\<not> distinct bs \\<Longrightarrow> False", "hence \"b * b dvd prod_list (map fst bs)\""], ["proof (prove)\nusing this:\n  bs = bs1 @ [(b, i)] @ bs2 @ [(b, i)] @ bs3\n\ngoal (1 subgoal):\n 1. b * b dvd prod_list (map fst bs)", "by auto"], ["proof (state)\nthis:\n  b * b dvd prod_list (map fst bs)\n\ngoal (1 subgoal):\n 1. \\<not> distinct bs \\<Longrightarrow> False", "with sf[unfolded square_free_def, THEN conjunct2, rule_format, of b]"], ["proof (chain)\npicking this:\n  0 < degree b \\<Longrightarrow> \\<not> b * b dvd prod_list (map fst bs)\n  b * b dvd prod_list (map fst bs)", "have db: \"degree b = 0\""], ["proof (prove)\nusing this:\n  0 < degree b \\<Longrightarrow> \\<not> b * b dvd prod_list (map fst bs)\n  b * b dvd prod_list (map fst bs)\n\ngoal (1 subgoal):\n 1. degree b = 0", "by auto"], ["proof (state)\nthis:\n  degree b = 0\n\ngoal (1 subgoal):\n 1. \\<not> distinct bs \\<Longrightarrow> False", "from bs"], ["proof (chain)\npicking this:\n  bs = bs1 @ [(b, i)] @ bs2 @ [(b, i)] @ bs3", "have \"(b,i) \\<in> set bs\""], ["proof (prove)\nusing this:\n  bs = bs1 @ [(b, i)] @ bs2 @ [(b, i)] @ bs3\n\ngoal (1 subgoal):\n 1. (b, i) \\<in> set bs", "by auto"], ["proof (state)\nthis:\n  (b, i) \\<in> set bs\n\ngoal (1 subgoal):\n 1. \\<not> distinct bs \\<Longrightarrow> False", "from deg[OF this] db"], ["proof (chain)\npicking this:\n  0 < degree b\n  degree b = 0", "show False"], ["proof (prove)\nusing this:\n  0 < degree b\n  degree b = 0\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  distinct bs\n\ngoal (2 subgoals):\n 1. p = smult c (\\<Prod>(a, i)\\<in>set bs. a ^ Suc i)\n 2. \\<And>a i b j.\n       \\<lbrakk>(a, i) \\<in> set bs; (b, j) \\<in> set bs;\n        (a, i) \\<noteq> (b, j)\\<rbrakk>\n       \\<Longrightarrow> coprime a b", "show \"p = smult c (\\<Prod>(a, i)\\<in>set bs. a ^ Suc i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p = smult c (\\<Prod>(a, i)\\<in>set bs. a ^ Suc i)", "unfolding prod"], ["proof (prove)\ngoal (1 subgoal):\n 1. smult c (\\<Prod>(a, i)\\<leftarrow>bs. a ^ Suc i) =\n    smult c (\\<Prod>(a, i)\\<in>set bs. a ^ Suc i)", "using dist"], ["proof (prove)\nusing this:\n  distinct bs\n\ngoal (1 subgoal):\n 1. smult c (\\<Prod>(a, i)\\<leftarrow>bs. a ^ Suc i) =\n    smult c (\\<Prod>(a, i)\\<in>set bs. a ^ Suc i)", "by (simp add: prod.distinct_set_conv_list)"], ["proof (state)\nthis:\n  p = smult c (\\<Prod>(a, i)\\<in>set bs. a ^ Suc i)\n\ngoal (1 subgoal):\n 1. \\<And>a i b j.\n       \\<lbrakk>(a, i) \\<in> set bs; (b, j) \\<in> set bs;\n        (a, i) \\<noteq> (b, j)\\<rbrakk>\n       \\<Longrightarrow> coprime a b", "{"], ["proof (state)\nthis:\n  p = smult c (\\<Prod>(a, i)\\<in>set bs. a ^ Suc i)\n\ngoal (1 subgoal):\n 1. \\<And>a i b j.\n       \\<lbrakk>(a, i) \\<in> set bs; (b, j) \\<in> set bs;\n        (a, i) \\<noteq> (b, j)\\<rbrakk>\n       \\<Longrightarrow> coprime a b", "fix a i b j"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a i b j.\n       \\<lbrakk>(a, i) \\<in> set bs; (b, j) \\<in> set bs;\n        (a, i) \\<noteq> (b, j)\\<rbrakk>\n       \\<Longrightarrow> coprime a b", "assume ai: \"(a, i) \\<in> set bs\" and bj: \"(b, j) \\<in> set bs\" and diff: \"(a, i) \\<noteq> (b, j)\""], ["proof (state)\nthis:\n  (a, i) \\<in> set bs\n  (b, j) \\<in> set bs\n  (a, i) \\<noteq> (b, j)\n\ngoal (1 subgoal):\n 1. \\<And>a i b j.\n       \\<lbrakk>(a, i) \\<in> set bs; (b, j) \\<in> set bs;\n        (a, i) \\<noteq> (b, j)\\<rbrakk>\n       \\<Longrightarrow> coprime a b", "from split_list[OF ai]"], ["proof (chain)\npicking this:\n  \\<exists>ys zs. bs = ys @ (a, i) # zs", "obtain bs1 bs2 where bs: \"bs = bs1 @ (a,i) # bs2\""], ["proof (prove)\nusing this:\n  \\<exists>ys zs. bs = ys @ (a, i) # zs\n\ngoal (1 subgoal):\n 1. (\\<And>bs1 bs2.\n        bs = bs1 @ (a, i) # bs2 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  bs = bs1 @ (a, i) # bs2\n\ngoal (1 subgoal):\n 1. \\<And>a i b j.\n       \\<lbrakk>(a, i) \\<in> set bs; (b, j) \\<in> set bs;\n        (a, i) \\<noteq> (b, j)\\<rbrakk>\n       \\<Longrightarrow> coprime a b", "with bj diff"], ["proof (chain)\npicking this:\n  (b, j) \\<in> set bs\n  (a, i) \\<noteq> (b, j)\n  bs = bs1 @ (a, i) # bs2", "have \"(b,j) \\<in> set (bs1 @ bs2)\""], ["proof (prove)\nusing this:\n  (b, j) \\<in> set bs\n  (a, i) \\<noteq> (b, j)\n  bs = bs1 @ (a, i) # bs2\n\ngoal (1 subgoal):\n 1. (b, j) \\<in> set (bs1 @ bs2)", "by auto"], ["proof (state)\nthis:\n  (b, j) \\<in> set (bs1 @ bs2)\n\ngoal (1 subgoal):\n 1. \\<And>a i b j.\n       \\<lbrakk>(a, i) \\<in> set bs; (b, j) \\<in> set bs;\n        (a, i) \\<noteq> (b, j)\\<rbrakk>\n       \\<Longrightarrow> coprime a b", "from split_list[OF this]"], ["proof (chain)\npicking this:\n  \\<exists>ys zs. bs1 @ bs2 = ys @ (b, j) # zs", "obtain cs1 cs2 where cs: \"bs1 @ bs2 = cs1 @ (b,j) # cs2\""], ["proof (prove)\nusing this:\n  \\<exists>ys zs. bs1 @ bs2 = ys @ (b, j) # zs\n\ngoal (1 subgoal):\n 1. (\\<And>cs1 cs2.\n        bs1 @ bs2 = cs1 @ (b, j) # cs2 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  bs1 @ bs2 = cs1 @ (b, j) # cs2\n\ngoal (1 subgoal):\n 1. \\<And>a i b j.\n       \\<lbrakk>(a, i) \\<in> set bs; (b, j) \\<in> set bs;\n        (a, i) \\<noteq> (b, j)\\<rbrakk>\n       \\<Longrightarrow> coprime a b", "have \"prod_list (map fst bs) = a * prod_list (map fst (bs1 @ bs2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod_list (map fst bs) = a * prod_list (map fst (bs1 @ bs2))", "unfolding bs"], ["proof (prove)\ngoal (1 subgoal):\n 1. prod_list (map fst (bs1 @ (a, i) # bs2)) =\n    a * prod_list (map fst (bs1 @ bs2))", "by simp"], ["proof (state)\nthis:\n  prod_list (map fst bs) = a * prod_list (map fst (bs1 @ bs2))\n\ngoal (1 subgoal):\n 1. \\<And>a i b j.\n       \\<lbrakk>(a, i) \\<in> set bs; (b, j) \\<in> set bs;\n        (a, i) \\<noteq> (b, j)\\<rbrakk>\n       \\<Longrightarrow> coprime a b", "also"], ["proof (state)\nthis:\n  prod_list (map fst bs) = a * prod_list (map fst (bs1 @ bs2))\n\ngoal (1 subgoal):\n 1. \\<And>a i b j.\n       \\<lbrakk>(a, i) \\<in> set bs; (b, j) \\<in> set bs;\n        (a, i) \\<noteq> (b, j)\\<rbrakk>\n       \\<Longrightarrow> coprime a b", "have \"\\<dots> = a * b * prod_list (map fst (cs1 @ cs2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a * prod_list (map fst (bs1 @ bs2)) =\n    a * b * prod_list (map fst (cs1 @ cs2))", "unfolding cs"], ["proof (prove)\ngoal (1 subgoal):\n 1. a * prod_list (map fst (cs1 @ (b, j) # cs2)) =\n    a * b * prod_list (map fst (cs1 @ cs2))", "by simp"], ["proof (state)\nthis:\n  a * prod_list (map fst (bs1 @ bs2)) =\n  a * b * prod_list (map fst (cs1 @ cs2))\n\ngoal (1 subgoal):\n 1. \\<And>a i b j.\n       \\<lbrakk>(a, i) \\<in> set bs; (b, j) \\<in> set bs;\n        (a, i) \\<noteq> (b, j)\\<rbrakk>\n       \\<Longrightarrow> coprime a b", "finally"], ["proof (chain)\npicking this:\n  prod_list (map fst bs) = a * b * prod_list (map fst (cs1 @ cs2))", "obtain c where lp: \"prod_list (map fst bs) = a * b * c\""], ["proof (prove)\nusing this:\n  prod_list (map fst bs) = a * b * prod_list (map fst (cs1 @ cs2))\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        prod_list (map fst bs) = a * b * c \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  prod_list (map fst bs) = a * b * c\n\ngoal (1 subgoal):\n 1. \\<And>a i b j.\n       \\<lbrakk>(a, i) \\<in> set bs; (b, j) \\<in> set bs;\n        (a, i) \\<noteq> (b, j)\\<rbrakk>\n       \\<Longrightarrow> coprime a b", "from deg[OF ai]"], ["proof (chain)\npicking this:\n  0 < degree a", "have 0: \"gcd a b \\<noteq> 0\""], ["proof (prove)\nusing this:\n  0 < degree a\n\ngoal (1 subgoal):\n 1. gcd a b \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  gcd a b \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>a i b j.\n       \\<lbrakk>(a, i) \\<in> set bs; (b, j) \\<in> set bs;\n        (a, i) \\<noteq> (b, j)\\<rbrakk>\n       \\<Longrightarrow> coprime a b", "have gcd: \"gcd a b * gcd a b dvd prod_list (map fst bs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gcd a b * gcd a b dvd prod_list (map fst bs)", "unfolding lp"], ["proof (prove)\ngoal (1 subgoal):\n 1. gcd a b * gcd a b dvd a * b * c", "by (simp add: mult_dvd_mono)"], ["proof (state)\nthis:\n  gcd a b * gcd a b dvd prod_list (map fst bs)\n\ngoal (1 subgoal):\n 1. \\<And>a i b j.\n       \\<lbrakk>(a, i) \\<in> set bs; (b, j) \\<in> set bs;\n        (a, i) \\<noteq> (b, j)\\<rbrakk>\n       \\<Longrightarrow> coprime a b", "{"], ["proof (state)\nthis:\n  gcd a b * gcd a b dvd prod_list (map fst bs)\n\ngoal (1 subgoal):\n 1. \\<And>a i b j.\n       \\<lbrakk>(a, i) \\<in> set bs; (b, j) \\<in> set bs;\n        (a, i) \\<noteq> (b, j)\\<rbrakk>\n       \\<Longrightarrow> coprime a b", "assume \"degree (gcd a b) > 0\""], ["proof (state)\nthis:\n  0 < degree (gcd a b)\n\ngoal (1 subgoal):\n 1. \\<And>a i b j.\n       \\<lbrakk>(a, i) \\<in> set bs; (b, j) \\<in> set bs;\n        (a, i) \\<noteq> (b, j)\\<rbrakk>\n       \\<Longrightarrow> coprime a b", "from sf[unfolded square_free_def, THEN conjunct2, rule_format, OF this] gcd"], ["proof (chain)\npicking this:\n  \\<not> gcd a b * gcd a b dvd prod_list (map fst bs)\n  gcd a b * gcd a b dvd prod_list (map fst bs)", "have False"], ["proof (prove)\nusing this:\n  \\<not> gcd a b * gcd a b dvd prod_list (map fst bs)\n  gcd a b * gcd a b dvd prod_list (map fst bs)\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<And>a i b j.\n       \\<lbrakk>(a, i) \\<in> set bs; (b, j) \\<in> set bs;\n        (a, i) \\<noteq> (b, j)\\<rbrakk>\n       \\<Longrightarrow> coprime a b", "}"], ["proof (state)\nthis:\n  0 < degree (gcd a b) \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<And>a i b j.\n       \\<lbrakk>(a, i) \\<in> set bs; (b, j) \\<in> set bs;\n        (a, i) \\<noteq> (b, j)\\<rbrakk>\n       \\<Longrightarrow> coprime a b", "hence \"degree (gcd a b) = 0\""], ["proof (prove)\nusing this:\n  0 < degree (gcd a b) \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. degree (gcd a b) = 0", "by auto"], ["proof (state)\nthis:\n  degree (gcd a b) = 0\n\ngoal (1 subgoal):\n 1. \\<And>a i b j.\n       \\<lbrakk>(a, i) \\<in> set bs; (b, j) \\<in> set bs;\n        (a, i) \\<noteq> (b, j)\\<rbrakk>\n       \\<Longrightarrow> coprime a b", "with 0"], ["proof (chain)\npicking this:\n  gcd a b \\<noteq> 0\n  degree (gcd a b) = 0", "show \"coprime a b\""], ["proof (prove)\nusing this:\n  gcd a b \\<noteq> 0\n  degree (gcd a b) = 0\n\ngoal (1 subgoal):\n 1. coprime a b", "using is_unit_gcd is_unit_iff_degree"], ["proof (prove)\nusing this:\n  gcd a b \\<noteq> 0\n  degree (gcd a b) = 0\n  is_unit (gcd ?a ?b) = coprime ?a ?b\n  ?p \\<noteq> 0 \\<Longrightarrow> is_unit ?p = (degree ?p = 0)\n\ngoal (1 subgoal):\n 1. coprime a b", "by blast"], ["proof (state)\nthis:\n  coprime a b\n\ngoal:\nNo subgoals!", "}"], ["proof (state)\nthis:\n  \\<lbrakk>(?a2, ?i2) \\<in> set bs; (?b2, ?j2) \\<in> set bs;\n   (?a2, ?i2) \\<noteq> (?b2, ?j2)\\<rbrakk>\n  \\<Longrightarrow> coprime ?a2 ?b2\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma square_free_factorization_def': fixes p :: \"'a poly\"\n  shows \"square_free_factorization p (c,bs) \\<longleftrightarrow>\n  (p = smult c (\\<Prod>(a, i) \\<leftarrow> bs. a ^ Suc i)) \\<and>\n  (square_free (prod_list (map fst bs))) \\<and>\n  (\\<forall> b i. (b,i) \\<in> set bs \\<longrightarrow> degree b > 0) \\<and>\n  (p = 0 \\<longrightarrow> c = 0 \\<and> bs = [])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. square_free_factorization p (c, bs) =\n    (p = smult c (\\<Prod>(a, i)\\<leftarrow>bs. a ^ Suc i) \\<and>\n     square_free (prod_list (map fst bs)) \\<and>\n     (\\<forall>b i.\n         (b, i) \\<in> set bs \\<longrightarrow> 0 < degree b) \\<and>\n     (p = 0 \\<longrightarrow> c = (0::'a) \\<and> bs = []))", "using square_free_factorizationD'[of p c bs]\n  square_free_factorizationI'[of p c bs]"], ["proof (prove)\nusing this:\n  square_free_factorization p (c, bs) \\<Longrightarrow>\n  p = smult c (\\<Prod>(a, i)\\<leftarrow>bs. a ^ Suc i)\n  square_free_factorization p (c, bs) \\<Longrightarrow>\n  square_free (prod_list (map fst bs))\n  \\<lbrakk>square_free_factorization p (c, bs);\n   (?b, ?i) \\<in> set bs\\<rbrakk>\n  \\<Longrightarrow> degree ?b \\<noteq> 0\n  \\<lbrakk>square_free_factorization p (c, bs); p = 0\\<rbrakk>\n  \\<Longrightarrow> c = (0::'a) \\<and> bs = []\n  \\<lbrakk>p = smult c (\\<Prod>(a, i)\\<leftarrow>bs. a ^ Suc i);\n   square_free (prod_list (map fst bs));\n   \\<And>b i. (b, i) \\<in> set bs \\<Longrightarrow> 0 < degree b;\n   p = 0 \\<Longrightarrow> c = (0::'a) \\<and> bs = []\\<rbrakk>\n  \\<Longrightarrow> square_free_factorization p (c, bs)\n\ngoal (1 subgoal):\n 1. square_free_factorization p (c, bs) =\n    (p = smult c (\\<Prod>(a, i)\\<leftarrow>bs. a ^ Suc i) \\<and>\n     square_free (prod_list (map fst bs)) \\<and>\n     (\\<forall>b i.\n         (b, i) \\<in> set bs \\<longrightarrow> 0 < degree b) \\<and>\n     (p = 0 \\<longrightarrow> c = (0::'a) \\<and> bs = []))", "by blast"], ["", "lemma square_free_factorization_smult_prod_listI: fixes p :: \"'a poly\"\n  assumes sff: \"square_free_factorization p (c, bs1 @ (smult b (prod_list bs),i) # bs2)\"\n  and bs: \"\\<And> b. b \\<in> set bs \\<Longrightarrow> degree b > 0\"\n  shows \"square_free_factorization p (c * b^(Suc i), bs1 @ map (\\<lambda> b. (b,i)) bs @ bs2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. square_free_factorization p\n     (c * b ^ Suc i, bs1 @ map (\\<lambda>b. (b, i)) bs @ bs2)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. square_free_factorization p\n     (c * b ^ Suc i, bs1 @ map (\\<lambda>b. (b, i)) bs @ bs2)", "from square_free_factorizationD'(3)[OF sff, of \"smult b (prod_list bs)\" i]"], ["proof (chain)\npicking this:\n  (smult b (prod_list bs), i)\n  \\<in> set (bs1 @ (smult b (prod_list bs), i) # bs2) \\<Longrightarrow>\n  degree (smult b (prod_list bs)) \\<noteq> 0", "have b: \"b \\<noteq> 0\""], ["proof (prove)\nusing this:\n  (smult b (prod_list bs), i)\n  \\<in> set (bs1 @ (smult b (prod_list bs), i) # bs2) \\<Longrightarrow>\n  degree (smult b (prod_list bs)) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. b \\<noteq> (0::'a)", "by auto"], ["proof (state)\nthis:\n  b \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. square_free_factorization p\n     (c * b ^ Suc i, bs1 @ map (\\<lambda>b. (b, i)) bs @ bs2)", "note sff = square_free_factorizationD'[OF sff]"], ["proof (state)\nthis:\n  p =\n  smult c\n   (\\<Prod>(a,\n       i)\\<leftarrow>bs1 @ (smult b (prod_list bs), i) # bs2. a ^ Suc i)\n  square_free\n   (prod_list (map fst (bs1 @ (smult b (prod_list bs), i) # bs2)))\n  (?b, ?i)\n  \\<in> set (bs1 @ (smult b (prod_list bs), i) # bs2) \\<Longrightarrow>\n  degree ?b \\<noteq> 0\n  p = 0 \\<Longrightarrow>\n  c = (0::'a) \\<and> bs1 @ (smult b (prod_list bs), i) # bs2 = []\n\ngoal (1 subgoal):\n 1. square_free_factorization p\n     (c * b ^ Suc i, bs1 @ map (\\<lambda>b. (b, i)) bs @ bs2)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. square_free_factorization p\n     (c * b ^ Suc i, bs1 @ map (\\<lambda>b. (b, i)) bs @ bs2)", "proof (intro square_free_factorizationI', goal_cases)"], ["proof (state)\ngoal (4 subgoals):\n 1. p =\n    smult (c * b ^ Suc i)\n     (\\<Prod>(a,\n         i)\\<leftarrow>bs1 @ map (\\<lambda>b. (b, i)) bs @ bs2. a ^ Suc i)\n 2. square_free\n     (prod_list (map fst (bs1 @ map (\\<lambda>b. (b, i)) bs @ bs2)))\n 3. \\<And>b ia.\n       (b, ia)\n       \\<in> set (bs1 @ map (\\<lambda>b. (b, i)) bs @ bs2) \\<Longrightarrow>\n       0 < degree b\n 4. p = 0 \\<Longrightarrow>\n    c * b ^ Suc i = (0::'a) \\<and>\n    bs1 @ map (\\<lambda>b. (b, i)) bs @ bs2 = []", "case 1"], ["proof (state)\nthis:\n  \n\ngoal (4 subgoals):\n 1. p =\n    smult (c * b ^ Suc i)\n     (\\<Prod>(a,\n         i)\\<leftarrow>bs1 @ map (\\<lambda>b. (b, i)) bs @ bs2. a ^ Suc i)\n 2. square_free\n     (prod_list (map fst (bs1 @ map (\\<lambda>b. (b, i)) bs @ bs2)))\n 3. \\<And>b ia.\n       (b, ia)\n       \\<in> set (bs1 @ map (\\<lambda>b. (b, i)) bs @ bs2) \\<Longrightarrow>\n       0 < degree b\n 4. p = 0 \\<Longrightarrow>\n    c * b ^ Suc i = (0::'a) \\<and>\n    bs1 @ map (\\<lambda>b. (b, i)) bs @ bs2 = []", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. p =\n    smult (c * b ^ Suc i)\n     (\\<Prod>(a,\n         i)\\<leftarrow>bs1 @ map (\\<lambda>b. (b, i)) bs @ bs2. a ^ Suc i)", "unfolding sff(1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. smult c\n     (\\<Prod>(a,\n         i)\\<leftarrow>bs1 @ (smult b (prod_list bs), i) # bs2. a ^ Suc i) =\n    smult (c * b ^ Suc i)\n     (\\<Prod>(a,\n         i)\\<leftarrow>bs1 @ map (\\<lambda>b. (b, i)) bs @ bs2. a ^ Suc i)", "by (simp add: o_def field_simps smult_power prod_list_pow_suc)"], ["proof (state)\nthis:\n  p =\n  smult (c * b ^ Suc i)\n   (\\<Prod>(a,\n       i)\\<leftarrow>bs1 @ map (\\<lambda>b. (b, i)) bs @ bs2. a ^ Suc i)\n\ngoal (3 subgoals):\n 1. square_free\n     (prod_list (map fst (bs1 @ map (\\<lambda>b. (b, i)) bs @ bs2)))\n 2. \\<And>b ia.\n       (b, ia)\n       \\<in> set (bs1 @ map (\\<lambda>b. (b, i)) bs @ bs2) \\<Longrightarrow>\n       0 < degree b\n 3. p = 0 \\<Longrightarrow>\n    c * b ^ Suc i = (0::'a) \\<and>\n    bs1 @ map (\\<lambda>b. (b, i)) bs @ bs2 = []", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. square_free\n     (prod_list (map fst (bs1 @ map (\\<lambda>b. (b, i)) bs @ bs2)))\n 2. \\<And>b ia.\n       (b, ia)\n       \\<in> set (bs1 @ map (\\<lambda>b. (b, i)) bs @ bs2) \\<Longrightarrow>\n       0 < degree b\n 3. p = 0 \\<Longrightarrow>\n    c * b ^ Suc i = (0::'a) \\<and>\n    bs1 @ map (\\<lambda>b. (b, i)) bs @ bs2 = []", "case 2"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. square_free\n     (prod_list (map fst (bs1 @ map (\\<lambda>b. (b, i)) bs @ bs2)))\n 2. \\<And>b ia.\n       (b, ia)\n       \\<in> set (bs1 @ map (\\<lambda>b. (b, i)) bs @ bs2) \\<Longrightarrow>\n       0 < degree b\n 3. p = 0 \\<Longrightarrow>\n    c * b ^ Suc i = (0::'a) \\<and>\n    bs1 @ map (\\<lambda>b. (b, i)) bs @ bs2 = []", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. square_free\n     (prod_list (map fst (bs1 @ map (\\<lambda>b. (b, i)) bs @ bs2)))", "using sff(2)"], ["proof (prove)\nusing this:\n  square_free\n   (prod_list (map fst (bs1 @ (smult b (prod_list bs), i) # bs2)))\n\ngoal (1 subgoal):\n 1. square_free\n     (prod_list (map fst (bs1 @ map (\\<lambda>b. (b, i)) bs @ bs2)))", "by (simp add: ac_simps o_def square_free_smult_iff[OF b])"], ["proof (state)\nthis:\n  square_free\n   (prod_list (map fst (bs1 @ map (\\<lambda>b. (b, i)) bs @ bs2)))\n\ngoal (2 subgoals):\n 1. \\<And>b ia.\n       (b, ia)\n       \\<in> set (bs1 @ map (\\<lambda>b. (b, i)) bs @ bs2) \\<Longrightarrow>\n       0 < degree b\n 2. p = 0 \\<Longrightarrow>\n    c * b ^ Suc i = (0::'a) \\<and>\n    bs1 @ map (\\<lambda>b. (b, i)) bs @ bs2 = []", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>b ia.\n       (b, ia)\n       \\<in> set (bs1 @ map (\\<lambda>b. (b, i)) bs @ bs2) \\<Longrightarrow>\n       0 < degree b\n 2. p = 0 \\<Longrightarrow>\n    c * b ^ Suc i = (0::'a) \\<and>\n    bs1 @ map (\\<lambda>b. (b, i)) bs @ bs2 = []", "case 3"], ["proof (state)\nthis:\n  (b_, i_) \\<in> set (bs1 @ map (\\<lambda>b. (b, i)) bs @ bs2)\n\ngoal (2 subgoals):\n 1. \\<And>b ia.\n       (b, ia)\n       \\<in> set (bs1 @ map (\\<lambda>b. (b, i)) bs @ bs2) \\<Longrightarrow>\n       0 < degree b\n 2. p = 0 \\<Longrightarrow>\n    c * b ^ Suc i = (0::'a) \\<and>\n    bs1 @ map (\\<lambda>b. (b, i)) bs @ bs2 = []", "with sff(3) bs"], ["proof (chain)\npicking this:\n  (?b, ?i)\n  \\<in> set (bs1 @ (smult b (prod_list bs), i) # bs2) \\<Longrightarrow>\n  degree ?b \\<noteq> 0\n  ?b \\<in> set bs \\<Longrightarrow> 0 < degree ?b\n  (b_, i_) \\<in> set (bs1 @ map (\\<lambda>b. (b, i)) bs @ bs2)", "show ?case"], ["proof (prove)\nusing this:\n  (?b, ?i)\n  \\<in> set (bs1 @ (smult b (prod_list bs), i) # bs2) \\<Longrightarrow>\n  degree ?b \\<noteq> 0\n  ?b \\<in> set bs \\<Longrightarrow> 0 < degree ?b\n  (b_, i_) \\<in> set (bs1 @ map (\\<lambda>b. (b, i)) bs @ bs2)\n\ngoal (1 subgoal):\n 1. 0 < degree b_", "by auto"], ["proof (state)\nthis:\n  0 < degree b_\n\ngoal (1 subgoal):\n 1. p = 0 \\<Longrightarrow>\n    c * b ^ Suc i = (0::'a) \\<and>\n    bs1 @ map (\\<lambda>b. (b, i)) bs @ bs2 = []", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. p = 0 \\<Longrightarrow>\n    c * b ^ Suc i = (0::'a) \\<and>\n    bs1 @ map (\\<lambda>b. (b, i)) bs @ bs2 = []", "case 4"], ["proof (state)\nthis:\n  p = 0\n\ngoal (1 subgoal):\n 1. p = 0 \\<Longrightarrow>\n    c * b ^ Suc i = (0::'a) \\<and>\n    bs1 @ map (\\<lambda>b. (b, i)) bs @ bs2 = []", "from sff(4)[OF this]"], ["proof (chain)\npicking this:\n  c = (0::'a) \\<and> bs1 @ (smult b (prod_list bs), i) # bs2 = []", "show ?case"], ["proof (prove)\nusing this:\n  c = (0::'a) \\<and> bs1 @ (smult b (prod_list bs), i) # bs2 = []\n\ngoal (1 subgoal):\n 1. c * b ^ Suc i = (0::'a) \\<and>\n    bs1 @ map (\\<lambda>b. (b, i)) bs @ bs2 = []", "by simp"], ["proof (state)\nthis:\n  c * b ^ Suc i = (0::'a) \\<and>\n  bs1 @ map (\\<lambda>b. (b, i)) bs @ bs2 = []\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  square_free_factorization p\n   (c * b ^ Suc i, bs1 @ map (\\<lambda>b. (b, i)) bs @ bs2)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma square_free_factorization_further_factorization: fixes p :: \"'a poly\"\n  assumes sff: \"square_free_factorization p (c, bs)\"\n  and bs: \"\\<And> b i d fs. (b,i) \\<in> set bs \\<Longrightarrow> f b = (d,fs) \n    \\<Longrightarrow> b = smult d (prod_list fs) \\<and> (\\<forall> f \\<in> set fs. degree f > 0)\"\n  and h: \"h = (\\<lambda> (b,i). case f b of (d,fs) \\<Rightarrow> (d^Suc i,map (\\<lambda> f. (f,i)) fs))\"\n  and gs: \"gs = map h bs\"\n  and d: \"d = c * prod_list (map fst gs)\"\n  and es: \"es = concat (map snd gs)\"\n  shows \"square_free_factorization p (d, es)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. square_free_factorization p (d, es)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. square_free_factorization p (d, es)", "note sff = square_free_factorizationD'[OF sff]"], ["proof (state)\nthis:\n  p = smult c (\\<Prod>(a, i)\\<leftarrow>bs. a ^ Suc i)\n  square_free (prod_list (map fst bs))\n  (?b, ?i) \\<in> set bs \\<Longrightarrow> degree ?b \\<noteq> 0\n  p = 0 \\<Longrightarrow> c = (0::'a) \\<and> bs = []\n\ngoal (1 subgoal):\n 1. square_free_factorization p (d, es)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. square_free_factorization p (d, es)", "proof (rule square_free_factorizationI')"], ["proof (state)\ngoal (4 subgoals):\n 1. p = smult d (\\<Prod>(a, i)\\<leftarrow>es. a ^ Suc i)\n 2. square_free (prod_list (map fst es))\n 3. \\<And>b i. (b, i) \\<in> set es \\<Longrightarrow> 0 < degree b\n 4. p = 0 \\<Longrightarrow> d = (0::'a) \\<and> es = []", "assume \"p = 0\""], ["proof (state)\nthis:\n  p = 0\n\ngoal (4 subgoals):\n 1. p = smult d (\\<Prod>(a, i)\\<leftarrow>es. a ^ Suc i)\n 2. square_free (prod_list (map fst es))\n 3. \\<And>b i. (b, i) \\<in> set es \\<Longrightarrow> 0 < degree b\n 4. p = 0 \\<Longrightarrow> d = (0::'a) \\<and> es = []", "from sff(4)[OF this]"], ["proof (chain)\npicking this:\n  c = (0::'a) \\<and> bs = []", "show \"d = 0 \\<and> es = []\""], ["proof (prove)\nusing this:\n  c = (0::'a) \\<and> bs = []\n\ngoal (1 subgoal):\n 1. d = (0::'a) \\<and> es = []", "unfolding d es gs"], ["proof (prove)\nusing this:\n  c = (0::'a) \\<and> bs = []\n\ngoal (1 subgoal):\n 1. c * prod_list (map fst (map h bs)) = (0::'a) \\<and>\n    concat (map snd (map h bs)) = []", "by auto"], ["proof (state)\nthis:\n  d = (0::'a) \\<and> es = []\n\ngoal (3 subgoals):\n 1. p = smult d (\\<Prod>(a, i)\\<leftarrow>es. a ^ Suc i)\n 2. square_free (prod_list (map fst es))\n 3. \\<And>b i. (b, i) \\<in> set es \\<Longrightarrow> 0 < degree b", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. p = smult d (\\<Prod>(a, i)\\<leftarrow>es. a ^ Suc i)\n 2. square_free (prod_list (map fst es))\n 3. \\<And>b i. (b, i) \\<in> set es \\<Longrightarrow> 0 < degree b", "have id: \"(\\<Prod>(a, i)\\<leftarrow>bs. a * a ^ i) = smult (prod_list (map fst gs)) (\\<Prod>(a, i)\\<leftarrow>es. a * a ^ i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>(a, i)\\<leftarrow>bs. a * a ^ i) =\n    smult (prod_list (map fst gs)) (\\<Prod>(a, i)\\<leftarrow>es. a * a ^ i)", "unfolding es gs h map_map o_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>(a, i)\\<leftarrow>bs. a * a ^ i) =\n    smult\n     (\\<Prod>x\\<leftarrow>bs. fst (case x of\n                                   (b, i) \\<Rightarrow>\n                                     case f b of\n                                     (d, fs) \\<Rightarrow>\n (d ^ Suc i, map (\\<lambda>f. (f, i)) fs)))\n     (\\<Prod>(a,\n         i)\\<leftarrow>concat\n                        (map (\\<lambda>x.\n                                 snd (case x of\n(b, i) \\<Rightarrow>\n  case f b of\n  (d, fs) \\<Rightarrow> (d ^ Suc i, map (\\<lambda>f. (f, i)) fs)))\n                          bs). a * a ^ i)", "using bs"], ["proof (prove)\nusing this:\n  \\<lbrakk>(?b, ?i) \\<in> set bs; f ?b = (?d, ?fs)\\<rbrakk>\n  \\<Longrightarrow> ?b = smult ?d (prod_list ?fs) \\<and>\n                    (\\<forall>f\\<in>set ?fs. 0 < degree f)\n\ngoal (1 subgoal):\n 1. (\\<Prod>(a, i)\\<leftarrow>bs. a * a ^ i) =\n    smult\n     (\\<Prod>x\\<leftarrow>bs. fst (case x of\n                                   (b, i) \\<Rightarrow>\n                                     case f b of\n                                     (d, fs) \\<Rightarrow>\n (d ^ Suc i, map (\\<lambda>f. (f, i)) fs)))\n     (\\<Prod>(a,\n         i)\\<leftarrow>concat\n                        (map (\\<lambda>x.\n                                 snd (case x of\n(b, i) \\<Rightarrow>\n  case f b of\n  (d, fs) \\<Rightarrow> (d ^ Suc i, map (\\<lambda>f. (f, i)) fs)))\n                          bs). a * a ^ i)", "proof (induct bs)"], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<And>b i d fs.\n        \\<lbrakk>(b, i) \\<in> set []; f b = (d, fs)\\<rbrakk>\n        \\<Longrightarrow> b = smult d (prod_list fs) \\<and>\n                          (\\<forall>f\\<in>set fs.\n                              0 < degree f)) \\<Longrightarrow>\n    (\\<Prod>(a, i)\\<leftarrow>[]. a * a ^ i) =\n    smult\n     (\\<Prod>x\\<leftarrow>[]. fst (case x of\n                                   (b, i) \\<Rightarrow>\n                                     case f b of\n                                     (d, fs) \\<Rightarrow>\n (d ^ Suc i, map (\\<lambda>f. (f, i)) fs)))\n     (\\<Prod>(a,\n         i)\\<leftarrow>concat\n                        (map (\\<lambda>x.\n                                 snd (case x of\n(b, i) \\<Rightarrow>\n  case f b of\n  (d, fs) \\<Rightarrow> (d ^ Suc i, map (\\<lambda>f. (f, i)) fs)))\n                          []). a * a ^ i)\n 2. \\<And>a bs.\n       \\<lbrakk>(\\<And>b i d fs.\n                    \\<lbrakk>(b, i) \\<in> set bs; f b = (d, fs)\\<rbrakk>\n                    \\<Longrightarrow> b = smult d (prod_list fs) \\<and>\n(\\<forall>f\\<in>set fs. 0 < degree f)) \\<Longrightarrow>\n                (\\<Prod>(a, i)\\<leftarrow>bs. a * a ^ i) =\n                smult\n                 (\\<Prod>x\\<leftarrow>bs. fst\n     (case x of\n      (b, i) \\<Rightarrow>\n        case f b of\n        (d, fs) \\<Rightarrow> (d ^ Suc i, map (\\<lambda>f. (f, i)) fs)))\n                 (\\<Prod>(a,\n                     i)\\<leftarrow>concat\n                                    (map\n(\\<lambda>x.\n    snd (case x of\n         (b, i) \\<Rightarrow>\n           case f b of\n           (d, fs) \\<Rightarrow> (d ^ Suc i, map (\\<lambda>f. (f, i)) fs)))\nbs). a * a ^ i);\n        \\<And>b i d fs.\n           \\<lbrakk>(b, i) \\<in> set (a # bs); f b = (d, fs)\\<rbrakk>\n           \\<Longrightarrow> b = smult d (prod_list fs) \\<and>\n                             (\\<forall>f\\<in>set fs. 0 < degree f)\\<rbrakk>\n       \\<Longrightarrow> (\\<Prod>(a, i)\\<leftarrow>a # bs. a * a ^ i) =\n                         smult\n                          (\\<Prod>x\\<leftarrow>a #\n         bs. fst (case x of\n                  (b, i) \\<Rightarrow>\n                    case f b of\n                    (d, fs) \\<Rightarrow>\n                      (d ^ Suc i, map (\\<lambda>f. (f, i)) fs)))\n                          (\\<Prod>(a,\n                              i)\\<leftarrow>concat\n       (map (\\<lambda>x.\n                snd (case x of\n                     (b, i) \\<Rightarrow>\n                       case f b of\n                       (d, fs) \\<Rightarrow>\n                         (d ^ Suc i, map (\\<lambda>f. (f, i)) fs)))\n         (a # bs)). a * a ^ i)", "case (Cons bi bs)"], ["proof (state)\nthis:\n  (\\<And>b i d fs.\n      \\<lbrakk>(b, i) \\<in> set bs; f b = (d, fs)\\<rbrakk>\n      \\<Longrightarrow> b = smult d (prod_list fs) \\<and>\n                        (\\<forall>f\\<in>set fs.\n                            0 < degree f)) \\<Longrightarrow>\n  (\\<Prod>a\\<leftarrow>bs. case a of (a, i) \\<Rightarrow> a * a ^ i) =\n  smult\n   (\\<Prod>x\\<leftarrow>bs. fst (case x of\n                                 (b, i) \\<Rightarrow>\n                                   case f b of\n                                   (d, fs) \\<Rightarrow>\n                                     (d ^ Suc i,\nmap (\\<lambda>f. (f, i)) fs)))\n   (\\<Prod>a\\<leftarrow>concat\n                         (map (\\<lambda>x.\n                                  snd (case x of\n (b, i) \\<Rightarrow>\n   case f b of\n   (d, fs) \\<Rightarrow> (d ^ Suc i, map (\\<lambda>f. (f, i)) fs)))\n                           bs). case a of (a, i) \\<Rightarrow> a * a ^ i)\n  \\<lbrakk>(?b, ?i) \\<in> set (bi # bs); f ?b = (?d, ?fs)\\<rbrakk>\n  \\<Longrightarrow> ?b = smult ?d (prod_list ?fs) \\<and>\n                    (\\<forall>f\\<in>set ?fs. 0 < degree f)\n\ngoal (2 subgoals):\n 1. (\\<And>b i d fs.\n        \\<lbrakk>(b, i) \\<in> set []; f b = (d, fs)\\<rbrakk>\n        \\<Longrightarrow> b = smult d (prod_list fs) \\<and>\n                          (\\<forall>f\\<in>set fs.\n                              0 < degree f)) \\<Longrightarrow>\n    (\\<Prod>(a, i)\\<leftarrow>[]. a * a ^ i) =\n    smult\n     (\\<Prod>x\\<leftarrow>[]. fst (case x of\n                                   (b, i) \\<Rightarrow>\n                                     case f b of\n                                     (d, fs) \\<Rightarrow>\n (d ^ Suc i, map (\\<lambda>f. (f, i)) fs)))\n     (\\<Prod>(a,\n         i)\\<leftarrow>concat\n                        (map (\\<lambda>x.\n                                 snd (case x of\n(b, i) \\<Rightarrow>\n  case f b of\n  (d, fs) \\<Rightarrow> (d ^ Suc i, map (\\<lambda>f. (f, i)) fs)))\n                          []). a * a ^ i)\n 2. \\<And>a bs.\n       \\<lbrakk>(\\<And>b i d fs.\n                    \\<lbrakk>(b, i) \\<in> set bs; f b = (d, fs)\\<rbrakk>\n                    \\<Longrightarrow> b = smult d (prod_list fs) \\<and>\n(\\<forall>f\\<in>set fs. 0 < degree f)) \\<Longrightarrow>\n                (\\<Prod>(a, i)\\<leftarrow>bs. a * a ^ i) =\n                smult\n                 (\\<Prod>x\\<leftarrow>bs. fst\n     (case x of\n      (b, i) \\<Rightarrow>\n        case f b of\n        (d, fs) \\<Rightarrow> (d ^ Suc i, map (\\<lambda>f. (f, i)) fs)))\n                 (\\<Prod>(a,\n                     i)\\<leftarrow>concat\n                                    (map\n(\\<lambda>x.\n    snd (case x of\n         (b, i) \\<Rightarrow>\n           case f b of\n           (d, fs) \\<Rightarrow> (d ^ Suc i, map (\\<lambda>f. (f, i)) fs)))\nbs). a * a ^ i);\n        \\<And>b i d fs.\n           \\<lbrakk>(b, i) \\<in> set (a # bs); f b = (d, fs)\\<rbrakk>\n           \\<Longrightarrow> b = smult d (prod_list fs) \\<and>\n                             (\\<forall>f\\<in>set fs. 0 < degree f)\\<rbrakk>\n       \\<Longrightarrow> (\\<Prod>(a, i)\\<leftarrow>a # bs. a * a ^ i) =\n                         smult\n                          (\\<Prod>x\\<leftarrow>a #\n         bs. fst (case x of\n                  (b, i) \\<Rightarrow>\n                    case f b of\n                    (d, fs) \\<Rightarrow>\n                      (d ^ Suc i, map (\\<lambda>f. (f, i)) fs)))\n                          (\\<Prod>(a,\n                              i)\\<leftarrow>concat\n       (map (\\<lambda>x.\n                snd (case x of\n                     (b, i) \\<Rightarrow>\n                       case f b of\n                       (d, fs) \\<Rightarrow>\n                         (d ^ Suc i, map (\\<lambda>f. (f, i)) fs)))\n         (a # bs)). a * a ^ i)", "obtain b i where bi: \"bi = (b,i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>b i. bi = (b, i) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  bi = (b, i)\n\ngoal (2 subgoals):\n 1. (\\<And>b i d fs.\n        \\<lbrakk>(b, i) \\<in> set []; f b = (d, fs)\\<rbrakk>\n        \\<Longrightarrow> b = smult d (prod_list fs) \\<and>\n                          (\\<forall>f\\<in>set fs.\n                              0 < degree f)) \\<Longrightarrow>\n    (\\<Prod>(a, i)\\<leftarrow>[]. a * a ^ i) =\n    smult\n     (\\<Prod>x\\<leftarrow>[]. fst (case x of\n                                   (b, i) \\<Rightarrow>\n                                     case f b of\n                                     (d, fs) \\<Rightarrow>\n (d ^ Suc i, map (\\<lambda>f. (f, i)) fs)))\n     (\\<Prod>(a,\n         i)\\<leftarrow>concat\n                        (map (\\<lambda>x.\n                                 snd (case x of\n(b, i) \\<Rightarrow>\n  case f b of\n  (d, fs) \\<Rightarrow> (d ^ Suc i, map (\\<lambda>f. (f, i)) fs)))\n                          []). a * a ^ i)\n 2. \\<And>a bs.\n       \\<lbrakk>(\\<And>b i d fs.\n                    \\<lbrakk>(b, i) \\<in> set bs; f b = (d, fs)\\<rbrakk>\n                    \\<Longrightarrow> b = smult d (prod_list fs) \\<and>\n(\\<forall>f\\<in>set fs. 0 < degree f)) \\<Longrightarrow>\n                (\\<Prod>(a, i)\\<leftarrow>bs. a * a ^ i) =\n                smult\n                 (\\<Prod>x\\<leftarrow>bs. fst\n     (case x of\n      (b, i) \\<Rightarrow>\n        case f b of\n        (d, fs) \\<Rightarrow> (d ^ Suc i, map (\\<lambda>f. (f, i)) fs)))\n                 (\\<Prod>(a,\n                     i)\\<leftarrow>concat\n                                    (map\n(\\<lambda>x.\n    snd (case x of\n         (b, i) \\<Rightarrow>\n           case f b of\n           (d, fs) \\<Rightarrow> (d ^ Suc i, map (\\<lambda>f. (f, i)) fs)))\nbs). a * a ^ i);\n        \\<And>b i d fs.\n           \\<lbrakk>(b, i) \\<in> set (a # bs); f b = (d, fs)\\<rbrakk>\n           \\<Longrightarrow> b = smult d (prod_list fs) \\<and>\n                             (\\<forall>f\\<in>set fs. 0 < degree f)\\<rbrakk>\n       \\<Longrightarrow> (\\<Prod>(a, i)\\<leftarrow>a # bs. a * a ^ i) =\n                         smult\n                          (\\<Prod>x\\<leftarrow>a #\n         bs. fst (case x of\n                  (b, i) \\<Rightarrow>\n                    case f b of\n                    (d, fs) \\<Rightarrow>\n                      (d ^ Suc i, map (\\<lambda>f. (f, i)) fs)))\n                          (\\<Prod>(a,\n                              i)\\<leftarrow>concat\n       (map (\\<lambda>x.\n                snd (case x of\n                     (b, i) \\<Rightarrow>\n                       case f b of\n                       (d, fs) \\<Rightarrow>\n                         (d ^ Suc i, map (\\<lambda>f. (f, i)) fs)))\n         (a # bs)). a * a ^ i)", "obtain d fs where f: \"f b = (d,fs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>d fs. f b = (d, fs) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  f b = (d, fs)\n\ngoal (2 subgoals):\n 1. (\\<And>b i d fs.\n        \\<lbrakk>(b, i) \\<in> set []; f b = (d, fs)\\<rbrakk>\n        \\<Longrightarrow> b = smult d (prod_list fs) \\<and>\n                          (\\<forall>f\\<in>set fs.\n                              0 < degree f)) \\<Longrightarrow>\n    (\\<Prod>(a, i)\\<leftarrow>[]. a * a ^ i) =\n    smult\n     (\\<Prod>x\\<leftarrow>[]. fst (case x of\n                                   (b, i) \\<Rightarrow>\n                                     case f b of\n                                     (d, fs) \\<Rightarrow>\n (d ^ Suc i, map (\\<lambda>f. (f, i)) fs)))\n     (\\<Prod>(a,\n         i)\\<leftarrow>concat\n                        (map (\\<lambda>x.\n                                 snd (case x of\n(b, i) \\<Rightarrow>\n  case f b of\n  (d, fs) \\<Rightarrow> (d ^ Suc i, map (\\<lambda>f. (f, i)) fs)))\n                          []). a * a ^ i)\n 2. \\<And>a bs.\n       \\<lbrakk>(\\<And>b i d fs.\n                    \\<lbrakk>(b, i) \\<in> set bs; f b = (d, fs)\\<rbrakk>\n                    \\<Longrightarrow> b = smult d (prod_list fs) \\<and>\n(\\<forall>f\\<in>set fs. 0 < degree f)) \\<Longrightarrow>\n                (\\<Prod>(a, i)\\<leftarrow>bs. a * a ^ i) =\n                smult\n                 (\\<Prod>x\\<leftarrow>bs. fst\n     (case x of\n      (b, i) \\<Rightarrow>\n        case f b of\n        (d, fs) \\<Rightarrow> (d ^ Suc i, map (\\<lambda>f. (f, i)) fs)))\n                 (\\<Prod>(a,\n                     i)\\<leftarrow>concat\n                                    (map\n(\\<lambda>x.\n    snd (case x of\n         (b, i) \\<Rightarrow>\n           case f b of\n           (d, fs) \\<Rightarrow> (d ^ Suc i, map (\\<lambda>f. (f, i)) fs)))\nbs). a * a ^ i);\n        \\<And>b i d fs.\n           \\<lbrakk>(b, i) \\<in> set (a # bs); f b = (d, fs)\\<rbrakk>\n           \\<Longrightarrow> b = smult d (prod_list fs) \\<and>\n                             (\\<forall>f\\<in>set fs. 0 < degree f)\\<rbrakk>\n       \\<Longrightarrow> (\\<Prod>(a, i)\\<leftarrow>a # bs. a * a ^ i) =\n                         smult\n                          (\\<Prod>x\\<leftarrow>a #\n         bs. fst (case x of\n                  (b, i) \\<Rightarrow>\n                    case f b of\n                    (d, fs) \\<Rightarrow>\n                      (d ^ Suc i, map (\\<lambda>f. (f, i)) fs)))\n                          (\\<Prod>(a,\n                              i)\\<leftarrow>concat\n       (map (\\<lambda>x.\n                snd (case x of\n                     (b, i) \\<Rightarrow>\n                       case f b of\n                       (d, fs) \\<Rightarrow>\n                         (d ^ Suc i, map (\\<lambda>f. (f, i)) fs)))\n         (a # bs)). a * a ^ i)", "from Cons(2)[OF _ f, of i]"], ["proof (chain)\npicking this:\n  (b, i) \\<in> set (bi # bs) \\<Longrightarrow>\n  b = smult d (prod_list fs) \\<and> (\\<forall>f\\<in>set fs. 0 < degree f)", "have b: \"b = smult d (prod_list fs)\""], ["proof (prove)\nusing this:\n  (b, i) \\<in> set (bi # bs) \\<Longrightarrow>\n  b = smult d (prod_list fs) \\<and> (\\<forall>f\\<in>set fs. 0 < degree f)\n\ngoal (1 subgoal):\n 1. b = smult d (prod_list fs)", "unfolding bi"], ["proof (prove)\nusing this:\n  (b, i) \\<in> set ((b, i) # bs) \\<Longrightarrow>\n  b = smult d (prod_list fs) \\<and> (\\<forall>f\\<in>set fs. 0 < degree f)\n\ngoal (1 subgoal):\n 1. b = smult d (prod_list fs)", "by auto"], ["proof (state)\nthis:\n  b = smult d (prod_list fs)\n\ngoal (2 subgoals):\n 1. (\\<And>b i d fs.\n        \\<lbrakk>(b, i) \\<in> set []; f b = (d, fs)\\<rbrakk>\n        \\<Longrightarrow> b = smult d (prod_list fs) \\<and>\n                          (\\<forall>f\\<in>set fs.\n                              0 < degree f)) \\<Longrightarrow>\n    (\\<Prod>(a, i)\\<leftarrow>[]. a * a ^ i) =\n    smult\n     (\\<Prod>x\\<leftarrow>[]. fst (case x of\n                                   (b, i) \\<Rightarrow>\n                                     case f b of\n                                     (d, fs) \\<Rightarrow>\n (d ^ Suc i, map (\\<lambda>f. (f, i)) fs)))\n     (\\<Prod>(a,\n         i)\\<leftarrow>concat\n                        (map (\\<lambda>x.\n                                 snd (case x of\n(b, i) \\<Rightarrow>\n  case f b of\n  (d, fs) \\<Rightarrow> (d ^ Suc i, map (\\<lambda>f. (f, i)) fs)))\n                          []). a * a ^ i)\n 2. \\<And>a bs.\n       \\<lbrakk>(\\<And>b i d fs.\n                    \\<lbrakk>(b, i) \\<in> set bs; f b = (d, fs)\\<rbrakk>\n                    \\<Longrightarrow> b = smult d (prod_list fs) \\<and>\n(\\<forall>f\\<in>set fs. 0 < degree f)) \\<Longrightarrow>\n                (\\<Prod>(a, i)\\<leftarrow>bs. a * a ^ i) =\n                smult\n                 (\\<Prod>x\\<leftarrow>bs. fst\n     (case x of\n      (b, i) \\<Rightarrow>\n        case f b of\n        (d, fs) \\<Rightarrow> (d ^ Suc i, map (\\<lambda>f. (f, i)) fs)))\n                 (\\<Prod>(a,\n                     i)\\<leftarrow>concat\n                                    (map\n(\\<lambda>x.\n    snd (case x of\n         (b, i) \\<Rightarrow>\n           case f b of\n           (d, fs) \\<Rightarrow> (d ^ Suc i, map (\\<lambda>f. (f, i)) fs)))\nbs). a * a ^ i);\n        \\<And>b i d fs.\n           \\<lbrakk>(b, i) \\<in> set (a # bs); f b = (d, fs)\\<rbrakk>\n           \\<Longrightarrow> b = smult d (prod_list fs) \\<and>\n                             (\\<forall>f\\<in>set fs. 0 < degree f)\\<rbrakk>\n       \\<Longrightarrow> (\\<Prod>(a, i)\\<leftarrow>a # bs. a * a ^ i) =\n                         smult\n                          (\\<Prod>x\\<leftarrow>a #\n         bs. fst (case x of\n                  (b, i) \\<Rightarrow>\n                    case f b of\n                    (d, fs) \\<Rightarrow>\n                      (d ^ Suc i, map (\\<lambda>f. (f, i)) fs)))\n                          (\\<Prod>(a,\n                              i)\\<leftarrow>concat\n       (map (\\<lambda>x.\n                snd (case x of\n                     (b, i) \\<Rightarrow>\n                       case f b of\n                       (d, fs) \\<Rightarrow>\n                         (d ^ Suc i, map (\\<lambda>f. (f, i)) fs)))\n         (a # bs)). a * a ^ i)", "note IH = Cons(1)[OF Cons(2), of \"\\<lambda> _ i _ _ . i\"]"], ["proof (state)\nthis:\n  \\<lbrakk>\\<And>b i d fs.\n              \\<lbrakk>(b, i) \\<in> set bs; f b = (d, fs)\\<rbrakk>\n              \\<Longrightarrow> (b, i) \\<in> set (bi # bs);\n   \\<And>b i d fs.\n      \\<lbrakk>(b, i) \\<in> set bs; f b = (d, fs)\\<rbrakk>\n      \\<Longrightarrow> f b = (d, fs)\\<rbrakk>\n  \\<Longrightarrow> (\\<Prod>a\\<leftarrow>bs. case a of\n       (a, i) \\<Rightarrow> a * a ^ i) =\n                    smult\n                     (\\<Prod>x\\<leftarrow>bs. fst\n         (case x of\n          (b, i) \\<Rightarrow>\n            case f b of\n            (d, fs) \\<Rightarrow> (d ^ Suc i, map (\\<lambda>f. (f, i)) fs)))\n                     (\\<Prod>a\\<leftarrow>concat\n     (map (\\<lambda>x.\n              snd (case x of\n                   (b, i) \\<Rightarrow>\n                     case f b of\n                     (d, fs) \\<Rightarrow>\n                       (d ^ Suc i, map (\\<lambda>f. (f, i)) fs)))\n       bs). case a of (a, i) \\<Rightarrow> a * a ^ i)\n\ngoal (2 subgoals):\n 1. (\\<And>b i d fs.\n        \\<lbrakk>(b, i) \\<in> set []; f b = (d, fs)\\<rbrakk>\n        \\<Longrightarrow> b = smult d (prod_list fs) \\<and>\n                          (\\<forall>f\\<in>set fs.\n                              0 < degree f)) \\<Longrightarrow>\n    (\\<Prod>(a, i)\\<leftarrow>[]. a * a ^ i) =\n    smult\n     (\\<Prod>x\\<leftarrow>[]. fst (case x of\n                                   (b, i) \\<Rightarrow>\n                                     case f b of\n                                     (d, fs) \\<Rightarrow>\n (d ^ Suc i, map (\\<lambda>f. (f, i)) fs)))\n     (\\<Prod>(a,\n         i)\\<leftarrow>concat\n                        (map (\\<lambda>x.\n                                 snd (case x of\n(b, i) \\<Rightarrow>\n  case f b of\n  (d, fs) \\<Rightarrow> (d ^ Suc i, map (\\<lambda>f. (f, i)) fs)))\n                          []). a * a ^ i)\n 2. \\<And>a bs.\n       \\<lbrakk>(\\<And>b i d fs.\n                    \\<lbrakk>(b, i) \\<in> set bs; f b = (d, fs)\\<rbrakk>\n                    \\<Longrightarrow> b = smult d (prod_list fs) \\<and>\n(\\<forall>f\\<in>set fs. 0 < degree f)) \\<Longrightarrow>\n                (\\<Prod>(a, i)\\<leftarrow>bs. a * a ^ i) =\n                smult\n                 (\\<Prod>x\\<leftarrow>bs. fst\n     (case x of\n      (b, i) \\<Rightarrow>\n        case f b of\n        (d, fs) \\<Rightarrow> (d ^ Suc i, map (\\<lambda>f. (f, i)) fs)))\n                 (\\<Prod>(a,\n                     i)\\<leftarrow>concat\n                                    (map\n(\\<lambda>x.\n    snd (case x of\n         (b, i) \\<Rightarrow>\n           case f b of\n           (d, fs) \\<Rightarrow> (d ^ Suc i, map (\\<lambda>f. (f, i)) fs)))\nbs). a * a ^ i);\n        \\<And>b i d fs.\n           \\<lbrakk>(b, i) \\<in> set (a # bs); f b = (d, fs)\\<rbrakk>\n           \\<Longrightarrow> b = smult d (prod_list fs) \\<and>\n                             (\\<forall>f\\<in>set fs. 0 < degree f)\\<rbrakk>\n       \\<Longrightarrow> (\\<Prod>(a, i)\\<leftarrow>a # bs. a * a ^ i) =\n                         smult\n                          (\\<Prod>x\\<leftarrow>a #\n         bs. fst (case x of\n                  (b, i) \\<Rightarrow>\n                    case f b of\n                    (d, fs) \\<Rightarrow>\n                      (d ^ Suc i, map (\\<lambda>f. (f, i)) fs)))\n                          (\\<Prod>(a,\n                              i)\\<leftarrow>concat\n       (map (\\<lambda>x.\n                snd (case x of\n                     (b, i) \\<Rightarrow>\n                       case f b of\n                       (d, fs) \\<Rightarrow>\n                         (d ^ Suc i, map (\\<lambda>f. (f, i)) fs)))\n         (a # bs)). a * a ^ i)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>a\\<leftarrow>bi #\n                         bs. case a of (a, i) \\<Rightarrow> a * a ^ i) =\n    smult\n     (\\<Prod>x\\<leftarrow>bi #\n                          bs. fst (case x of\n                                   (b, i) \\<Rightarrow>\n                                     case f b of\n                                     (d, fs) \\<Rightarrow>\n (d ^ Suc i, map (\\<lambda>f. (f, i)) fs)))\n     (\\<Prod>a\\<leftarrow>concat\n                           (map (\\<lambda>x.\n                                    snd (case x of\n   (b, i) \\<Rightarrow>\n     case f b of\n     (d, fs) \\<Rightarrow> (d ^ Suc i, map (\\<lambda>f. (f, i)) fs)))\n                             (bi #\n                              bs)). case a of\n                                    (a, i) \\<Rightarrow> a * a ^ i)", "unfolding bi"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>a\\<leftarrow>(b, i) #\n                         bs. case a of (a, i) \\<Rightarrow> a * a ^ i) =\n    smult\n     (\\<Prod>x\\<leftarrow>(b, i) #\n                          bs. fst (case x of\n                                   (b, i) \\<Rightarrow>\n                                     case f b of\n                                     (d, fs) \\<Rightarrow>\n (d ^ Suc i, map (\\<lambda>f. (f, i)) fs)))\n     (\\<Prod>a\\<leftarrow>concat\n                           (map (\\<lambda>x.\n                                    snd (case x of\n   (b, i) \\<Rightarrow>\n     case f b of\n     (d, fs) \\<Rightarrow> (d ^ Suc i, map (\\<lambda>f. (f, i)) fs)))\n                             ((b, i) #\n                              bs)). case a of\n                                    (a, i) \\<Rightarrow> a * a ^ i)", "by (simp add: f o_def, simp add: b ac_simps, subst IH, \n          auto simp: smult_power prod_list_pow_suc ac_simps)"], ["proof (state)\nthis:\n  (\\<Prod>a\\<leftarrow>bi # bs. case a of (a, i) \\<Rightarrow> a * a ^ i) =\n  smult\n   (\\<Prod>x\\<leftarrow>bi #\n                        bs. fst (case x of\n                                 (b, i) \\<Rightarrow>\n                                   case f b of\n                                   (d, fs) \\<Rightarrow>\n                                     (d ^ Suc i,\nmap (\\<lambda>f. (f, i)) fs)))\n   (\\<Prod>a\\<leftarrow>concat\n                         (map (\\<lambda>x.\n                                  snd (case x of\n (b, i) \\<Rightarrow>\n   case f b of\n   (d, fs) \\<Rightarrow> (d ^ Suc i, map (\\<lambda>f. (f, i)) fs)))\n                           (bi #\n                            bs)). case a of (a, i) \\<Rightarrow> a * a ^ i)\n\ngoal (1 subgoal):\n 1. (\\<And>b i d fs.\n        \\<lbrakk>(b, i) \\<in> set []; f b = (d, fs)\\<rbrakk>\n        \\<Longrightarrow> b = smult d (prod_list fs) \\<and>\n                          (\\<forall>f\\<in>set fs.\n                              0 < degree f)) \\<Longrightarrow>\n    (\\<Prod>(a, i)\\<leftarrow>[]. a * a ^ i) =\n    smult\n     (\\<Prod>x\\<leftarrow>[]. fst (case x of\n                                   (b, i) \\<Rightarrow>\n                                     case f b of\n                                     (d, fs) \\<Rightarrow>\n (d ^ Suc i, map (\\<lambda>f. (f, i)) fs)))\n     (\\<Prod>(a,\n         i)\\<leftarrow>concat\n                        (map (\\<lambda>x.\n                                 snd (case x of\n(b, i) \\<Rightarrow>\n  case f b of\n  (d, fs) \\<Rightarrow> (d ^ Suc i, map (\\<lambda>f. (f, i)) fs)))\n                          []). a * a ^ i)", "qed simp"], ["proof (state)\nthis:\n  (\\<Prod>(a, i)\\<leftarrow>bs. a * a ^ i) =\n  smult (prod_list (map fst gs)) (\\<Prod>(a, i)\\<leftarrow>es. a * a ^ i)\n\ngoal (3 subgoals):\n 1. p = smult d (\\<Prod>(a, i)\\<leftarrow>es. a ^ Suc i)\n 2. square_free (prod_list (map fst es))\n 3. \\<And>b i. (b, i) \\<in> set es \\<Longrightarrow> 0 < degree b", "show \"p = smult d (\\<Prod>(a, i)\\<leftarrow>es. a ^ Suc i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p = smult d (\\<Prod>(a, i)\\<leftarrow>es. a ^ Suc i)", "unfolding sff(1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. smult c (\\<Prod>(a, i)\\<leftarrow>bs. a ^ Suc i) =\n    smult d (\\<Prod>(a, i)\\<leftarrow>es. a ^ Suc i)", "using id"], ["proof (prove)\nusing this:\n  (\\<Prod>(a, i)\\<leftarrow>bs. a * a ^ i) =\n  smult (prod_list (map fst gs)) (\\<Prod>(a, i)\\<leftarrow>es. a * a ^ i)\n\ngoal (1 subgoal):\n 1. smult c (\\<Prod>(a, i)\\<leftarrow>bs. a ^ Suc i) =\n    smult d (\\<Prod>(a, i)\\<leftarrow>es. a ^ Suc i)", "by (simp add: d)"], ["proof (state)\nthis:\n  p = smult d (\\<Prod>(a, i)\\<leftarrow>es. a ^ Suc i)\n\ngoal (2 subgoals):\n 1. square_free (prod_list (map fst es))\n 2. \\<And>b i. (b, i) \\<in> set es \\<Longrightarrow> 0 < degree b", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. square_free (prod_list (map fst es))\n 2. \\<And>b i. (b, i) \\<in> set es \\<Longrightarrow> 0 < degree b", "fix fi i"], ["proof (state)\ngoal (2 subgoals):\n 1. square_free (prod_list (map fst es))\n 2. \\<And>b i. (b, i) \\<in> set es \\<Longrightarrow> 0 < degree b", "assume fi: \"(fi, i) \\<in> set es\""], ["proof (state)\nthis:\n  (fi, i) \\<in> set es\n\ngoal (2 subgoals):\n 1. square_free (prod_list (map fst es))\n 2. \\<And>b i. (b, i) \\<in> set es \\<Longrightarrow> 0 < degree b", "from this[unfolded es]"], ["proof (chain)\npicking this:\n  (fi, i) \\<in> set (concat (map snd gs))", "obtain G where G: \"G \\<in> snd ` set gs\" and fi: \"(fi,i) \\<in> set G\""], ["proof (prove)\nusing this:\n  (fi, i) \\<in> set (concat (map snd gs))\n\ngoal (1 subgoal):\n 1. (\\<And>G.\n        \\<lbrakk>G \\<in> snd ` set gs; (fi, i) \\<in> set G\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  G \\<in> snd ` set gs\n  (fi, i) \\<in> set G\n\ngoal (2 subgoals):\n 1. square_free (prod_list (map fst es))\n 2. \\<And>b i. (b, i) \\<in> set es \\<Longrightarrow> 0 < degree b", "from G[unfolded gs]"], ["proof (chain)\npicking this:\n  G \\<in> snd ` set (map h bs)", "obtain b i where bi: \"(b,i) \\<in> set bs\" \n      and G: \"G = snd (h (b,i))\""], ["proof (prove)\nusing this:\n  G \\<in> snd ` set (map h bs)\n\ngoal (1 subgoal):\n 1. (\\<And>b i.\n        \\<lbrakk>(b, i) \\<in> set bs; G = snd (h (b, i))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  (b, i) \\<in> set bs\n  G = snd (h (b, i))\n\ngoal (2 subgoals):\n 1. square_free (prod_list (map fst es))\n 2. \\<And>b i. (b, i) \\<in> set es \\<Longrightarrow> 0 < degree b", "obtain d fs where f: \"f b = (d,fs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>d fs. f b = (d, fs) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  f b = (d, fs)\n\ngoal (2 subgoals):\n 1. square_free (prod_list (map fst es))\n 2. \\<And>b i. (b, i) \\<in> set es \\<Longrightarrow> 0 < degree b", "show \"degree fi > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < degree fi", "by (rule bs[THEN conjunct2, rule_format, OF bi f], insert fi G f, unfold h, auto)"], ["proof (state)\nthis:\n  0 < degree fi\n\ngoal (1 subgoal):\n 1. square_free (prod_list (map fst es))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. square_free (prod_list (map fst es))", "have id: \"\\<exists> c. prod_list (map fst bs) = smult c (prod_list (map fst es))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>c. prod_list (map fst bs) = smult c (prod_list (map fst es))", "unfolding es gs map_map o_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>c.\n       prod_list (map fst bs) =\n       smult c\n        (prod_list (map fst (concat (map (\\<lambda>x. snd (h x)) bs))))", "using bs"], ["proof (prove)\nusing this:\n  \\<lbrakk>(?b, ?i) \\<in> set bs; f ?b = (?d, ?fs)\\<rbrakk>\n  \\<Longrightarrow> ?b = smult ?d (prod_list ?fs) \\<and>\n                    (\\<forall>f\\<in>set ?fs. 0 < degree f)\n\ngoal (1 subgoal):\n 1. \\<exists>c.\n       prod_list (map fst bs) =\n       smult c\n        (prod_list (map fst (concat (map (\\<lambda>x. snd (h x)) bs))))", "proof (induct bs)"], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<And>b i d fs.\n        \\<lbrakk>(b, i) \\<in> set []; f b = (d, fs)\\<rbrakk>\n        \\<Longrightarrow> b = smult d (prod_list fs) \\<and>\n                          (\\<forall>f\\<in>set fs.\n                              0 < degree f)) \\<Longrightarrow>\n    \\<exists>c.\n       prod_list (map fst []) =\n       smult c\n        (prod_list (map fst (concat (map (\\<lambda>x. snd (h x)) []))))\n 2. \\<And>a bs.\n       \\<lbrakk>(\\<And>b i d fs.\n                    \\<lbrakk>(b, i) \\<in> set bs; f b = (d, fs)\\<rbrakk>\n                    \\<Longrightarrow> b = smult d (prod_list fs) \\<and>\n(\\<forall>f\\<in>set fs. 0 < degree f)) \\<Longrightarrow>\n                \\<exists>c.\n                   prod_list (map fst bs) =\n                   smult c\n                    (prod_list\n                      (map fst (concat (map (\\<lambda>x. snd (h x)) bs))));\n        \\<And>b i d fs.\n           \\<lbrakk>(b, i) \\<in> set (a # bs); f b = (d, fs)\\<rbrakk>\n           \\<Longrightarrow> b = smult d (prod_list fs) \\<and>\n                             (\\<forall>f\\<in>set fs. 0 < degree f)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c.\n                            prod_list (map fst (a # bs)) =\n                            smult c\n                             (prod_list\n                               (map fst\n                                 (concat\n                                   (map (\\<lambda>x. snd (h x)) (a # bs)))))", "case (Cons bi bs)"], ["proof (state)\nthis:\n  (\\<And>b i d fs.\n      \\<lbrakk>(b, i) \\<in> set bs; f b = (d, fs)\\<rbrakk>\n      \\<Longrightarrow> b = smult d (prod_list fs) \\<and>\n                        (\\<forall>f\\<in>set fs.\n                            0 < degree f)) \\<Longrightarrow>\n  \\<exists>c.\n     prod_list (map fst bs) =\n     smult c (prod_list (map fst (concat (map (\\<lambda>x. snd (h x)) bs))))\n  \\<lbrakk>(?b, ?i) \\<in> set (bi # bs); f ?b = (?d, ?fs)\\<rbrakk>\n  \\<Longrightarrow> ?b = smult ?d (prod_list ?fs) \\<and>\n                    (\\<forall>f\\<in>set ?fs. 0 < degree f)\n\ngoal (2 subgoals):\n 1. (\\<And>b i d fs.\n        \\<lbrakk>(b, i) \\<in> set []; f b = (d, fs)\\<rbrakk>\n        \\<Longrightarrow> b = smult d (prod_list fs) \\<and>\n                          (\\<forall>f\\<in>set fs.\n                              0 < degree f)) \\<Longrightarrow>\n    \\<exists>c.\n       prod_list (map fst []) =\n       smult c\n        (prod_list (map fst (concat (map (\\<lambda>x. snd (h x)) []))))\n 2. \\<And>a bs.\n       \\<lbrakk>(\\<And>b i d fs.\n                    \\<lbrakk>(b, i) \\<in> set bs; f b = (d, fs)\\<rbrakk>\n                    \\<Longrightarrow> b = smult d (prod_list fs) \\<and>\n(\\<forall>f\\<in>set fs. 0 < degree f)) \\<Longrightarrow>\n                \\<exists>c.\n                   prod_list (map fst bs) =\n                   smult c\n                    (prod_list\n                      (map fst (concat (map (\\<lambda>x. snd (h x)) bs))));\n        \\<And>b i d fs.\n           \\<lbrakk>(b, i) \\<in> set (a # bs); f b = (d, fs)\\<rbrakk>\n           \\<Longrightarrow> b = smult d (prod_list fs) \\<and>\n                             (\\<forall>f\\<in>set fs. 0 < degree f)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c.\n                            prod_list (map fst (a # bs)) =\n                            smult c\n                             (prod_list\n                               (map fst\n                                 (concat\n                                   (map (\\<lambda>x. snd (h x)) (a # bs)))))", "obtain b i where bi: \"bi = (b,i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>b i. bi = (b, i) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  bi = (b, i)\n\ngoal (2 subgoals):\n 1. (\\<And>b i d fs.\n        \\<lbrakk>(b, i) \\<in> set []; f b = (d, fs)\\<rbrakk>\n        \\<Longrightarrow> b = smult d (prod_list fs) \\<and>\n                          (\\<forall>f\\<in>set fs.\n                              0 < degree f)) \\<Longrightarrow>\n    \\<exists>c.\n       prod_list (map fst []) =\n       smult c\n        (prod_list (map fst (concat (map (\\<lambda>x. snd (h x)) []))))\n 2. \\<And>a bs.\n       \\<lbrakk>(\\<And>b i d fs.\n                    \\<lbrakk>(b, i) \\<in> set bs; f b = (d, fs)\\<rbrakk>\n                    \\<Longrightarrow> b = smult d (prod_list fs) \\<and>\n(\\<forall>f\\<in>set fs. 0 < degree f)) \\<Longrightarrow>\n                \\<exists>c.\n                   prod_list (map fst bs) =\n                   smult c\n                    (prod_list\n                      (map fst (concat (map (\\<lambda>x. snd (h x)) bs))));\n        \\<And>b i d fs.\n           \\<lbrakk>(b, i) \\<in> set (a # bs); f b = (d, fs)\\<rbrakk>\n           \\<Longrightarrow> b = smult d (prod_list fs) \\<and>\n                             (\\<forall>f\\<in>set fs. 0 < degree f)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c.\n                            prod_list (map fst (a # bs)) =\n                            smult c\n                             (prod_list\n                               (map fst\n                                 (concat\n                                   (map (\\<lambda>x. snd (h x)) (a # bs)))))", "obtain d fs where f: \"f b = (d,fs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>d fs. f b = (d, fs) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  f b = (d, fs)\n\ngoal (2 subgoals):\n 1. (\\<And>b i d fs.\n        \\<lbrakk>(b, i) \\<in> set []; f b = (d, fs)\\<rbrakk>\n        \\<Longrightarrow> b = smult d (prod_list fs) \\<and>\n                          (\\<forall>f\\<in>set fs.\n                              0 < degree f)) \\<Longrightarrow>\n    \\<exists>c.\n       prod_list (map fst []) =\n       smult c\n        (prod_list (map fst (concat (map (\\<lambda>x. snd (h x)) []))))\n 2. \\<And>a bs.\n       \\<lbrakk>(\\<And>b i d fs.\n                    \\<lbrakk>(b, i) \\<in> set bs; f b = (d, fs)\\<rbrakk>\n                    \\<Longrightarrow> b = smult d (prod_list fs) \\<and>\n(\\<forall>f\\<in>set fs. 0 < degree f)) \\<Longrightarrow>\n                \\<exists>c.\n                   prod_list (map fst bs) =\n                   smult c\n                    (prod_list\n                      (map fst (concat (map (\\<lambda>x. snd (h x)) bs))));\n        \\<And>b i d fs.\n           \\<lbrakk>(b, i) \\<in> set (a # bs); f b = (d, fs)\\<rbrakk>\n           \\<Longrightarrow> b = smult d (prod_list fs) \\<and>\n                             (\\<forall>f\\<in>set fs. 0 < degree f)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c.\n                            prod_list (map fst (a # bs)) =\n                            smult c\n                             (prod_list\n                               (map fst\n                                 (concat\n                                   (map (\\<lambda>x. snd (h x)) (a # bs)))))", "from Cons(2)[OF _ f, of i]"], ["proof (chain)\npicking this:\n  (b, i) \\<in> set (bi # bs) \\<Longrightarrow>\n  b = smult d (prod_list fs) \\<and> (\\<forall>f\\<in>set fs. 0 < degree f)", "have b: \"b = smult d (prod_list fs)\""], ["proof (prove)\nusing this:\n  (b, i) \\<in> set (bi # bs) \\<Longrightarrow>\n  b = smult d (prod_list fs) \\<and> (\\<forall>f\\<in>set fs. 0 < degree f)\n\ngoal (1 subgoal):\n 1. b = smult d (prod_list fs)", "unfolding bi"], ["proof (prove)\nusing this:\n  (b, i) \\<in> set ((b, i) # bs) \\<Longrightarrow>\n  b = smult d (prod_list fs) \\<and> (\\<forall>f\\<in>set fs. 0 < degree f)\n\ngoal (1 subgoal):\n 1. b = smult d (prod_list fs)", "by auto"], ["proof (state)\nthis:\n  b = smult d (prod_list fs)\n\ngoal (2 subgoals):\n 1. (\\<And>b i d fs.\n        \\<lbrakk>(b, i) \\<in> set []; f b = (d, fs)\\<rbrakk>\n        \\<Longrightarrow> b = smult d (prod_list fs) \\<and>\n                          (\\<forall>f\\<in>set fs.\n                              0 < degree f)) \\<Longrightarrow>\n    \\<exists>c.\n       prod_list (map fst []) =\n       smult c\n        (prod_list (map fst (concat (map (\\<lambda>x. snd (h x)) []))))\n 2. \\<And>a bs.\n       \\<lbrakk>(\\<And>b i d fs.\n                    \\<lbrakk>(b, i) \\<in> set bs; f b = (d, fs)\\<rbrakk>\n                    \\<Longrightarrow> b = smult d (prod_list fs) \\<and>\n(\\<forall>f\\<in>set fs. 0 < degree f)) \\<Longrightarrow>\n                \\<exists>c.\n                   prod_list (map fst bs) =\n                   smult c\n                    (prod_list\n                      (map fst (concat (map (\\<lambda>x. snd (h x)) bs))));\n        \\<And>b i d fs.\n           \\<lbrakk>(b, i) \\<in> set (a # bs); f b = (d, fs)\\<rbrakk>\n           \\<Longrightarrow> b = smult d (prod_list fs) \\<and>\n                             (\\<forall>f\\<in>set fs. 0 < degree f)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c.\n                            prod_list (map fst (a # bs)) =\n                            smult c\n                             (prod_list\n                               (map fst\n                                 (concat\n                                   (map (\\<lambda>x. snd (h x)) (a # bs)))))", "have \"\\<exists>c. prod_list (map fst bs) = smult c (prod_list (map fst (concat (map (\\<lambda>x. snd (h x)) bs))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>c.\n       prod_list (map fst bs) =\n       smult c\n        (prod_list (map fst (concat (map (\\<lambda>x. snd (h x)) bs))))", "by (rule Cons(1), rule Cons(2), auto)"], ["proof (state)\nthis:\n  \\<exists>c.\n     prod_list (map fst bs) =\n     smult c (prod_list (map fst (concat (map (\\<lambda>x. snd (h x)) bs))))\n\ngoal (2 subgoals):\n 1. (\\<And>b i d fs.\n        \\<lbrakk>(b, i) \\<in> set []; f b = (d, fs)\\<rbrakk>\n        \\<Longrightarrow> b = smult d (prod_list fs) \\<and>\n                          (\\<forall>f\\<in>set fs.\n                              0 < degree f)) \\<Longrightarrow>\n    \\<exists>c.\n       prod_list (map fst []) =\n       smult c\n        (prod_list (map fst (concat (map (\\<lambda>x. snd (h x)) []))))\n 2. \\<And>a bs.\n       \\<lbrakk>(\\<And>b i d fs.\n                    \\<lbrakk>(b, i) \\<in> set bs; f b = (d, fs)\\<rbrakk>\n                    \\<Longrightarrow> b = smult d (prod_list fs) \\<and>\n(\\<forall>f\\<in>set fs. 0 < degree f)) \\<Longrightarrow>\n                \\<exists>c.\n                   prod_list (map fst bs) =\n                   smult c\n                    (prod_list\n                      (map fst (concat (map (\\<lambda>x. snd (h x)) bs))));\n        \\<And>b i d fs.\n           \\<lbrakk>(b, i) \\<in> set (a # bs); f b = (d, fs)\\<rbrakk>\n           \\<Longrightarrow> b = smult d (prod_list fs) \\<and>\n                             (\\<forall>f\\<in>set fs. 0 < degree f)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c.\n                            prod_list (map fst (a # bs)) =\n                            smult c\n                             (prod_list\n                               (map fst\n                                 (concat\n                                   (map (\\<lambda>x. snd (h x)) (a # bs)))))", "then"], ["proof (chain)\npicking this:\n  \\<exists>c.\n     prod_list (map fst bs) =\n     smult c (prod_list (map fst (concat (map (\\<lambda>x. snd (h x)) bs))))", "obtain c where \n        IH: \"prod_list (map fst bs) = smult c (prod_list (map fst (concat (map (\\<lambda>x. snd (h x)) bs))))\""], ["proof (prove)\nusing this:\n  \\<exists>c.\n     prod_list (map fst bs) =\n     smult c (prod_list (map fst (concat (map (\\<lambda>x. snd (h x)) bs))))\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        prod_list (map fst bs) =\n        smult c\n         (prod_list\n           (map fst\n             (concat (map (\\<lambda>x. snd (h x)) bs)))) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  prod_list (map fst bs) =\n  smult c (prod_list (map fst (concat (map (\\<lambda>x. snd (h x)) bs))))\n\ngoal (2 subgoals):\n 1. (\\<And>b i d fs.\n        \\<lbrakk>(b, i) \\<in> set []; f b = (d, fs)\\<rbrakk>\n        \\<Longrightarrow> b = smult d (prod_list fs) \\<and>\n                          (\\<forall>f\\<in>set fs.\n                              0 < degree f)) \\<Longrightarrow>\n    \\<exists>c.\n       prod_list (map fst []) =\n       smult c\n        (prod_list (map fst (concat (map (\\<lambda>x. snd (h x)) []))))\n 2. \\<And>a bs.\n       \\<lbrakk>(\\<And>b i d fs.\n                    \\<lbrakk>(b, i) \\<in> set bs; f b = (d, fs)\\<rbrakk>\n                    \\<Longrightarrow> b = smult d (prod_list fs) \\<and>\n(\\<forall>f\\<in>set fs. 0 < degree f)) \\<Longrightarrow>\n                \\<exists>c.\n                   prod_list (map fst bs) =\n                   smult c\n                    (prod_list\n                      (map fst (concat (map (\\<lambda>x. snd (h x)) bs))));\n        \\<And>b i d fs.\n           \\<lbrakk>(b, i) \\<in> set (a # bs); f b = (d, fs)\\<rbrakk>\n           \\<Longrightarrow> b = smult d (prod_list fs) \\<and>\n                             (\\<forall>f\\<in>set fs. 0 < degree f)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c.\n                            prod_list (map fst (a # bs)) =\n                            smult c\n                             (prod_list\n                               (map fst\n                                 (concat\n                                   (map (\\<lambda>x. snd (h x)) (a # bs)))))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>c.\n       prod_list (map fst (bi # bs)) =\n       smult c\n        (prod_list\n          (map fst (concat (map (\\<lambda>x. snd (h x)) (bi # bs)))))", "unfolding bi"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>c.\n       prod_list (map fst ((b, i) # bs)) =\n       smult c\n        (prod_list\n          (map fst (concat (map (\\<lambda>x. snd (h x)) ((b, i) # bs)))))", "by (intro exI[of _ \"c * d\"], auto simp: b IH, auto simp: h f[unfolded b] o_def)"], ["proof (state)\nthis:\n  \\<exists>c.\n     prod_list (map fst (bi # bs)) =\n     smult c\n      (prod_list (map fst (concat (map (\\<lambda>x. snd (h x)) (bi # bs)))))\n\ngoal (1 subgoal):\n 1. (\\<And>b i d fs.\n        \\<lbrakk>(b, i) \\<in> set []; f b = (d, fs)\\<rbrakk>\n        \\<Longrightarrow> b = smult d (prod_list fs) \\<and>\n                          (\\<forall>f\\<in>set fs.\n                              0 < degree f)) \\<Longrightarrow>\n    \\<exists>c.\n       prod_list (map fst []) =\n       smult c\n        (prod_list (map fst (concat (map (\\<lambda>x. snd (h x)) []))))", "qed (intro exI[of _ 1], auto)"], ["proof (state)\nthis:\n  \\<exists>c. prod_list (map fst bs) = smult c (prod_list (map fst es))\n\ngoal (1 subgoal):\n 1. square_free (prod_list (map fst es))", "then"], ["proof (chain)\npicking this:\n  \\<exists>c. prod_list (map fst bs) = smult c (prod_list (map fst es))", "obtain c where \"prod_list (map fst bs) = smult c (prod_list (map fst es))\""], ["proof (prove)\nusing this:\n  \\<exists>c. prod_list (map fst bs) = smult c (prod_list (map fst es))\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        prod_list (map fst bs) =\n        smult c (prod_list (map fst es)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  prod_list (map fst bs) = smult c (prod_list (map fst es))\n\ngoal (1 subgoal):\n 1. square_free (prod_list (map fst es))", "from sff(2)[unfolded this]"], ["proof (chain)\npicking this:\n  square_free (smult c (prod_list (map fst es)))", "show \"square_free (prod_list (map fst es))\""], ["proof (prove)\nusing this:\n  square_free (smult c (prod_list (map fst es)))\n\ngoal (1 subgoal):\n 1. square_free (prod_list (map fst es))", "by (metis smult_eq_0_iff square_free_def square_free_smult_iff)"], ["proof (state)\nthis:\n  square_free (prod_list (map fst es))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  square_free_factorization p (d, es)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma square_free_factorization_prod_listI: fixes p :: \"'a poly\"\n  assumes sff: \"square_free_factorization p (c, bs1 @ ((prod_list bs),i) # bs2)\"\n  and bs: \"\\<And> b. b \\<in> set bs \\<Longrightarrow> degree b > 0\"\n  shows \"square_free_factorization p (c, bs1 @ map (\\<lambda> b. (b,i)) bs @ bs2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. square_free_factorization p (c, bs1 @ map (\\<lambda>b. (b, i)) bs @ bs2)", "using square_free_factorization_smult_prod_listI[of p c bs1 1 bs i bs2] sff bs"], ["proof (prove)\nusing this:\n  \\<lbrakk>square_free_factorization p\n            (c, bs1 @ (smult (1::'a) (prod_list bs), i) # bs2);\n   \\<And>b. b \\<in> set bs \\<Longrightarrow> 0 < degree b\\<rbrakk>\n  \\<Longrightarrow> square_free_factorization p\n                     (c * (1::'a) ^ Suc i,\n                      bs1 @ map (\\<lambda>b. (b, i)) bs @ bs2)\n  square_free_factorization p (c, bs1 @ (prod_list bs, i) # bs2)\n  ?b \\<in> set bs \\<Longrightarrow> 0 < degree ?b\n\ngoal (1 subgoal):\n 1. square_free_factorization p (c, bs1 @ map (\\<lambda>b. (b, i)) bs @ bs2)", "by auto"], ["", "lemma square_free_factorization_factorI: fixes p :: \"'a poly\"\n  assumes sff: \"square_free_factorization p (c, bs1 @ (a,i) # bs2)\"\n  and r: \"degree r \\<noteq> 0\" and s: \"degree s \\<noteq> 0\"\n  and a: \"a = r * s\"\n  shows \"square_free_factorization p (c, bs1 @ ((r,i) # (s,i) # bs2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. square_free_factorization p (c, bs1 @ (r, i) # (s, i) # bs2)", "using square_free_factorization_prod_listI[of p c bs1 \"[r,s]\" i bs2] sff r s a"], ["proof (prove)\nusing this:\n  \\<lbrakk>square_free_factorization p\n            (c, bs1 @ (prod_list [r, s], i) # bs2);\n   \\<And>b. b \\<in> set [r, s] \\<Longrightarrow> 0 < degree b\\<rbrakk>\n  \\<Longrightarrow> square_free_factorization p\n                     (c, bs1 @ map (\\<lambda>b. (b, i)) [r, s] @ bs2)\n  square_free_factorization p (c, bs1 @ (a, i) # bs2)\n  degree r \\<noteq> 0\n  degree s \\<noteq> 0\n  a = r * s\n\ngoal (1 subgoal):\n 1. square_free_factorization p (c, bs1 @ (r, i) # (s, i) # bs2)", "by auto"], ["", "end"], ["", "lemma monic_square_free_irreducible_factorization: assumes mon: \"monic (f :: 'b :: field poly)\" \n  and sf: \"square_free f\"\n  shows \"\\<exists> P. finite P \\<and> f = \\<Prod>P \\<and> P \\<subseteq> {q. irreducible q \\<and> monic q}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>P.\n       finite P \\<and>\n       f = \\<Prod>P \\<and> P \\<subseteq> {q. irreducible q \\<and> monic q}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>P.\n       finite P \\<and>\n       f = \\<Prod>P \\<and> P \\<subseteq> {q. irreducible q \\<and> monic q}", "from mon"], ["proof (chain)\npicking this:\n  monic f", "have f0: \"f \\<noteq> 0\""], ["proof (prove)\nusing this:\n  monic f\n\ngoal (1 subgoal):\n 1. f \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  f \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<exists>P.\n       finite P \\<and>\n       f = \\<Prod>P \\<and> P \\<subseteq> {q. irreducible q \\<and> monic q}", "from monic_irreducible_factorization[OF assms(1)]"], ["proof (chain)\npicking this:\n  \\<exists>as fa.\n     finite as \\<and>\n     f = (\\<Prod>a\\<in>as. a ^ Suc (fa a)) \\<and>\n     as \\<subseteq> {q. irreducible q \\<and> monic q}", "obtain P n where\n    P: \"finite P\" \"P \\<subseteq> {q. irreducible\\<^sub>d q \\<and> monic q}\" and f: \"f = (\\<Prod>a\\<in>P. a ^ Suc (n a))\""], ["proof (prove)\nusing this:\n  \\<exists>as fa.\n     finite as \\<and>\n     f = (\\<Prod>a\\<in>as. a ^ Suc (fa a)) \\<and>\n     as \\<subseteq> {q. irreducible q \\<and> monic q}\n\ngoal (1 subgoal):\n 1. (\\<And>P n.\n        \\<lbrakk>finite P;\n         P \\<subseteq> {q. irreducible\\<^sub>d q \\<and> monic q};\n         f = (\\<Prod>a\\<in>P. a ^ Suc (n a))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  finite P\n  P \\<subseteq> {q. irreducible\\<^sub>d q \\<and> monic q}\n  f = (\\<Prod>a\\<in>P. a ^ Suc (n a))\n\ngoal (1 subgoal):\n 1. \\<exists>P.\n       finite P \\<and>\n       f = \\<Prod>P \\<and> P \\<subseteq> {q. irreducible q \\<and> monic q}", "have *: \"\\<forall> a \\<in> P. n a = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a\\<in>P. n a = 0", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>a\\<in>P. n a = 0) \\<Longrightarrow> False", "assume \"\\<not> ?thesis\""], ["proof (state)\nthis:\n  \\<not> (\\<forall>a\\<in>P. n a = 0)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>a\\<in>P. n a = 0) \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<not> (\\<forall>a\\<in>P. n a = 0)", "obtain a where a: \"a \\<in> P\" and n: \"n a \\<noteq> 0\""], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>a\\<in>P. n a = 0)\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>a \\<in> P; n a \\<noteq> 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  a \\<in> P\n  n a \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>a\\<in>P. n a = 0) \\<Longrightarrow> False", "have \"f = a ^ (Suc (n a)) * (\\<Prod>b\\<in>P - {a}. b ^ Suc (n b))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f = a ^ Suc (n a) * (\\<Prod>b\\<in>P - {a}. b ^ Suc (n b))", "unfolding f"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>a\\<in>P. a ^ Suc (n a)) =\n    a ^ Suc (n a) * (\\<Prod>b\\<in>P - {a}. b ^ Suc (n b))", "by (rule prod.remove[OF P(1) a])"], ["proof (state)\nthis:\n  f = a ^ Suc (n a) * (\\<Prod>b\\<in>P - {a}. b ^ Suc (n b))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>a\\<in>P. n a = 0) \\<Longrightarrow> False", "with n"], ["proof (chain)\npicking this:\n  n a \\<noteq> 0\n  f = a ^ Suc (n a) * (\\<Prod>b\\<in>P - {a}. b ^ Suc (n b))", "have \"a * a dvd f\""], ["proof (prove)\nusing this:\n  n a \\<noteq> 0\n  f = a ^ Suc (n a) * (\\<Prod>b\\<in>P - {a}. b ^ Suc (n b))\n\ngoal (1 subgoal):\n 1. a * a dvd f", "by (cases \"n a\", auto)"], ["proof (state)\nthis:\n  a * a dvd f\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>a\\<in>P. n a = 0) \\<Longrightarrow> False", "with sf[unfolded square_free_def] f0"], ["proof (chain)\npicking this:\n  f \\<noteq> 0 \\<and>\n  (\\<forall>q. 0 < degree q \\<longrightarrow> \\<not> q * q dvd f)\n  f \\<noteq> 0\n  a * a dvd f", "have \"degree a = 0\""], ["proof (prove)\nusing this:\n  f \\<noteq> 0 \\<and>\n  (\\<forall>q. 0 < degree q \\<longrightarrow> \\<not> q * q dvd f)\n  f \\<noteq> 0\n  a * a dvd f\n\ngoal (1 subgoal):\n 1. degree a = 0", "by auto"], ["proof (state)\nthis:\n  degree a = 0\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>a\\<in>P. n a = 0) \\<Longrightarrow> False", "with a P(2)[unfolded irreducible\\<^sub>d_def]"], ["proof (chain)\npicking this:\n  a \\<in> P\n  P \\<subseteq> {q. (0 < degree q \\<and>\n                     (\\<forall>qa r.\n                         degree qa < degree q \\<longrightarrow>\n                         degree r < degree q \\<longrightarrow>\n                         q \\<noteq> qa * r)) \\<and>\n                    monic q}\n  degree a = 0", "show False"], ["proof (prove)\nusing this:\n  a \\<in> P\n  P \\<subseteq> {q. (0 < degree q \\<and>\n                     (\\<forall>qa r.\n                         degree qa < degree q \\<longrightarrow>\n                         degree r < degree q \\<longrightarrow>\n                         q \\<noteq> qa * r)) \\<and>\n                    monic q}\n  degree a = 0\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>a\\<in>P. n a = 0\n\ngoal (1 subgoal):\n 1. \\<exists>P.\n       finite P \\<and>\n       f = \\<Prod>P \\<and> P \\<subseteq> {q. irreducible q \\<and> monic q}", "have \"f = \\<Prod> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f = \\<Prod>P", "unfolding f"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>a\\<in>P. a ^ Suc (n a)) = \\<Prod>P", "by (rule prod.cong[OF refl], insert *, auto)"], ["proof (state)\nthis:\n  f = \\<Prod>P\n\ngoal (1 subgoal):\n 1. \\<exists>P.\n       finite P \\<and>\n       f = \\<Prod>P \\<and> P \\<subseteq> {q. irreducible q \\<and> monic q}", "with P"], ["proof (chain)\npicking this:\n  finite P\n  P \\<subseteq> {q. irreducible\\<^sub>d q \\<and> monic q}\n  f = \\<Prod>P", "show ?thesis"], ["proof (prove)\nusing this:\n  finite P\n  P \\<subseteq> {q. irreducible\\<^sub>d q \\<and> monic q}\n  f = \\<Prod>P\n\ngoal (1 subgoal):\n 1. \\<exists>P.\n       finite P \\<and>\n       f = \\<Prod>P \\<and> P \\<subseteq> {q. irreducible q \\<and> monic q}", "by auto"], ["proof (state)\nthis:\n  \\<exists>P.\n     finite P \\<and>\n     f = \\<Prod>P \\<and> P \\<subseteq> {q. irreducible q \\<and> monic q}\n\ngoal:\nNo subgoals!", "qed"], ["", "context \n  assumes \"SORT_CONSTRAINT('a :: {field, factorial_ring_gcd})\" \nbegin"], ["", "lemma monic_factorization_uniqueness:\nfixes P::\"'a poly set\"\nassumes finite_P: \"finite P\" \n  and PQ: \"\\<Prod>P = \\<Prod>Q\" \n  and P: \"P \\<subseteq> {q. irreducible\\<^sub>d q \\<and> monic q}\"\nand finite_Q: \"finite Q\" \n  and Q: \"Q \\<subseteq> {q. irreducible\\<^sub>d q \\<and> monic q}\"\nshows \"P = Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P = Q", "proof (rule; rule subsetI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> P \\<Longrightarrow> x \\<in> Q\n 2. \\<And>x. x \\<in> Q \\<Longrightarrow> x \\<in> P", "fix x"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> P \\<Longrightarrow> x \\<in> Q\n 2. \\<And>x. x \\<in> Q \\<Longrightarrow> x \\<in> P", "assume x: \"x \\<in> P\""], ["proof (state)\nthis:\n  x \\<in> P\n\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> P \\<Longrightarrow> x \\<in> Q\n 2. \\<And>x. x \\<in> Q \\<Longrightarrow> x \\<in> P", "have irr_x: \"irreducible x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. irreducible x", "using x P"], ["proof (prove)\nusing this:\n  x \\<in> P\n  P \\<subseteq> {q. irreducible\\<^sub>d q \\<and> monic q}\n\ngoal (1 subgoal):\n 1. irreducible x", "by auto"], ["proof (state)\nthis:\n  irreducible x\n\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> P \\<Longrightarrow> x \\<in> Q\n 2. \\<And>x. x \\<in> Q \\<Longrightarrow> x \\<in> P", "then"], ["proof (chain)\npicking this:\n  irreducible x", "have \"\\<exists>a\\<in>Q. x dvd id a\""], ["proof (prove)\nusing this:\n  irreducible x\n\ngoal (1 subgoal):\n 1. \\<exists>a\\<in>Q. x dvd id a", "proof (rule irreducible_dvd_prod)"], ["proof (state)\ngoal (1 subgoal):\n 1. x dvd prod id Q", "show \"x dvd prod id Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x dvd prod id Q", "using PQ x"], ["proof (prove)\nusing this:\n  \\<Prod>P = \\<Prod>Q\n  x \\<in> P\n\ngoal (1 subgoal):\n 1. x dvd prod id Q", "by (metis dvd_refl dvd_prod finite_P id_apply prod.cong)"], ["proof (state)\nthis:\n  x dvd prod id Q\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>a\\<in>Q. x dvd id a\n\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> P \\<Longrightarrow> x \\<in> Q\n 2. \\<And>x. x \\<in> Q \\<Longrightarrow> x \\<in> P", "from this"], ["proof (chain)\npicking this:\n  \\<exists>a\\<in>Q. x dvd id a", "obtain a where a: \"a\\<in>Q\" and x_dvd_a: \"x dvd a\""], ["proof (prove)\nusing this:\n  \\<exists>a\\<in>Q. x dvd id a\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>a \\<in> Q; x dvd a\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding id_def"], ["proof (prove)\nusing this:\n  \\<exists>a\\<in>Q. x dvd a\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>a \\<in> Q; x dvd a\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  a \\<in> Q\n  x dvd a\n\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> P \\<Longrightarrow> x \\<in> Q\n 2. \\<And>x. x \\<in> Q \\<Longrightarrow> x \\<in> P", "have \"x=a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = a", "using x P a Q irreducible\\<^sub>d_dvd_eq[OF _ _ x_dvd_a]"], ["proof (prove)\nusing this:\n  x \\<in> P\n  P \\<subseteq> {q. irreducible\\<^sub>d q \\<and> monic q}\n  a \\<in> Q\n  Q \\<subseteq> {q. irreducible\\<^sub>d q \\<and> monic q}\n  \\<lbrakk>irreducible\\<^sub>d x; irreducible\\<^sub>d a; monic x;\n   monic a\\<rbrakk>\n  \\<Longrightarrow> x = a\n\ngoal (1 subgoal):\n 1. x = a", "by fast"], ["proof (state)\nthis:\n  x = a\n\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> P \\<Longrightarrow> x \\<in> Q\n 2. \\<And>x. x \\<in> Q \\<Longrightarrow> x \\<in> P", "thus \"x \\<in> Q\""], ["proof (prove)\nusing this:\n  x = a\n\ngoal (1 subgoal):\n 1. x \\<in> Q", "using a"], ["proof (prove)\nusing this:\n  x = a\n  a \\<in> Q\n\ngoal (1 subgoal):\n 1. x \\<in> Q", "by simp"], ["proof (state)\nthis:\n  x \\<in> Q\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> Q \\<Longrightarrow> x \\<in> P", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> Q \\<Longrightarrow> x \\<in> P", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> Q \\<Longrightarrow> x \\<in> P", "assume x: \"x \\<in> Q\""], ["proof (state)\nthis:\n  x \\<in> Q\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> Q \\<Longrightarrow> x \\<in> P", "have irr_x: \"irreducible x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. irreducible x", "using x Q"], ["proof (prove)\nusing this:\n  x \\<in> Q\n  Q \\<subseteq> {q. irreducible\\<^sub>d q \\<and> monic q}\n\ngoal (1 subgoal):\n 1. irreducible x", "by auto"], ["proof (state)\nthis:\n  irreducible x\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> Q \\<Longrightarrow> x \\<in> P", "then"], ["proof (chain)\npicking this:\n  irreducible x", "have \"\\<exists>a\\<in>P. x dvd id a\""], ["proof (prove)\nusing this:\n  irreducible x\n\ngoal (1 subgoal):\n 1. \\<exists>a\\<in>P. x dvd id a", "proof (rule irreducible_dvd_prod)"], ["proof (state)\ngoal (1 subgoal):\n 1. x dvd prod id P", "show \"x dvd prod id P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x dvd prod id P", "using PQ x"], ["proof (prove)\nusing this:\n  \\<Prod>P = \\<Prod>Q\n  x \\<in> Q\n\ngoal (1 subgoal):\n 1. x dvd prod id P", "by (metis dvd_refl dvd_prod finite_Q id_apply prod.cong)"], ["proof (state)\nthis:\n  x dvd prod id P\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>a\\<in>P. x dvd id a\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> Q \\<Longrightarrow> x \\<in> P", "from this"], ["proof (chain)\npicking this:\n  \\<exists>a\\<in>P. x dvd id a", "obtain a where a: \"a\\<in>P\" and x_dvd_a: \"x dvd a\""], ["proof (prove)\nusing this:\n  \\<exists>a\\<in>P. x dvd id a\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>a \\<in> P; x dvd a\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding id_def"], ["proof (prove)\nusing this:\n  \\<exists>a\\<in>P. x dvd a\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>a \\<in> P; x dvd a\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  a \\<in> P\n  x dvd a\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> Q \\<Longrightarrow> x \\<in> P", "have \"x=a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = a", "using x P a Q irreducible\\<^sub>d_dvd_eq[OF _ _ x_dvd_a]"], ["proof (prove)\nusing this:\n  x \\<in> Q\n  P \\<subseteq> {q. irreducible\\<^sub>d q \\<and> monic q}\n  a \\<in> P\n  Q \\<subseteq> {q. irreducible\\<^sub>d q \\<and> monic q}\n  \\<lbrakk>irreducible\\<^sub>d x; irreducible\\<^sub>d a; monic x;\n   monic a\\<rbrakk>\n  \\<Longrightarrow> x = a\n\ngoal (1 subgoal):\n 1. x = a", "by fast"], ["proof (state)\nthis:\n  x = a\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> Q \\<Longrightarrow> x \\<in> P", "thus \"x \\<in> P\""], ["proof (prove)\nusing this:\n  x = a\n\ngoal (1 subgoal):\n 1. x \\<in> P", "using a"], ["proof (prove)\nusing this:\n  x = a\n  a \\<in> P\n\ngoal (1 subgoal):\n 1. x \\<in> P", "by simp"], ["proof (state)\nthis:\n  x \\<in> P\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsection \\<open>Yun factorization and homomorphisms\\<close>"], ["", "locale field_hom_0' = field_hom hom\n  for hom :: \"'a :: {field_char_0,field_gcd} \\<Rightarrow>\n              'b :: {field_char_0,field_gcd}\"\nbegin"], ["", "sublocale field_hom'"], ["proof (prove)\ngoal (1 subgoal):\n 1. field_hom' hom", ".."], ["", "end"], ["", "lemma (in field_hom_0') yun_factorization_main_hom:\n  defines hp: \"hp \\<equiv> map_poly hom\"\n  defines hpi: \"hpi \\<equiv> map (\\<lambda> (f,i). (hp f, i :: nat))\"\n  assumes monic: \"monic p\" and f: \"f = p div gcd p (pderiv p)\" and g: \"g = pderiv p div gcd p (pderiv p)\"\n  shows \"yun_gcd.yun_factorization_main gcd (hp f) (hp g) i (hpi as) = hpi (yun_gcd.yun_factorization_main gcd f g i as)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. yun_gcd.yun_factorization_main gcd (hp f) (hp g) i (hpi as) =\n    hpi (yun_gcd.yun_factorization_main gcd f g i as)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. yun_gcd.yun_factorization_main gcd (hp f) (hp g) i (hpi as) =\n    hpi (yun_gcd.yun_factorization_main gcd f g i as)", "let ?P = \"\\<lambda> f g. \\<forall> i as. yun_gcd.yun_factorization_main gcd (hp f) (hp g) i (hpi as) = hpi (yun_gcd.yun_factorization_main gcd f g i as)\""], ["proof (state)\ngoal (1 subgoal):\n 1. yun_gcd.yun_factorization_main gcd (hp f) (hp g) i (hpi as) =\n    hpi (yun_gcd.yun_factorization_main gcd f g i as)", "note ind = yun_factorization_induct[OF _ _ f g monic, of ?P, rule_format]"], ["proof (state)\nthis:\n  \\<lbrakk>\\<And>bn cn i as.\n              bn = 1 \\<Longrightarrow>\n              yun_gcd.yun_factorization_main gcd (hp bn) (hp cn) i\n               (hpi as) =\n              hpi (yun_gcd.yun_factorization_main gcd bn cn i as);\n   \\<And>bn cn i as.\n      \\<lbrakk>bn \\<noteq> 1;\n       \\<And>i as.\n          yun_gcd.yun_factorization_main gcd\n           (hp (bn div gcd bn (cn - pderiv bn)))\n           (hp ((cn - pderiv bn) div gcd bn (cn - pderiv bn))) i (hpi as) =\n          hpi (yun_gcd.yun_factorization_main gcd\n                (bn div gcd bn (cn - pderiv bn))\n                ((cn - pderiv bn) div gcd bn (cn - pderiv bn)) i\n                as)\\<rbrakk>\n      \\<Longrightarrow> yun_gcd.yun_factorization_main gcd (hp bn) (hp cn) i\n                         (hpi as) =\n                        hpi (yun_gcd.yun_factorization_main gcd bn cn i\n                              as)\\<rbrakk>\n  \\<Longrightarrow> yun_gcd.yun_factorization_main gcd (hp f) (hp g) ?i\n                     (hpi ?as) =\n                    hpi (yun_gcd.yun_factorization_main gcd f g ?i ?as)\n\ngoal (1 subgoal):\n 1. yun_gcd.yun_factorization_main gcd (hp f) (hp g) i (hpi as) =\n    hpi (yun_gcd.yun_factorization_main gcd f g i as)", "interpret map_poly_hom: map_poly_inj_comm_ring_hom"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_poly_inj_comm_ring_hom hom", ".."], ["proof (state)\ngoal (1 subgoal):\n 1. yun_gcd.yun_factorization_main gcd (hp f) (hp g) i (hpi as) =\n    hpi (yun_gcd.yun_factorization_main gcd f g i as)", "interpret p: inj_comm_ring_hom hp"], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_comm_ring_hom hp", "unfolding hp"], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_comm_ring_hom (map_poly hom)", ".."], ["proof (state)\ngoal (1 subgoal):\n 1. yun_gcd.yun_factorization_main gcd (hp f) (hp g) i (hpi as) =\n    hpi (yun_gcd.yun_factorization_main gcd f g i as)", "note homs = map_poly_gcd[folded hp] \n      map_poly_pderiv[folded hp] \n      p.hom_minus \n      map_poly_div[folded hp]"], ["proof (state)\nthis:\n  hp (gcd ?p ?q) = gcd (hp ?p) (hp ?q)\n  hp (pderiv ?p) = pderiv (hp ?p)\n  hp (?x - ?y) = hp ?x - hp ?y\n  hp (?p div ?q) = hp ?p div hp ?q\n\ngoal (1 subgoal):\n 1. yun_gcd.yun_factorization_main gcd (hp f) (hp g) i (hpi as) =\n    hpi (yun_gcd.yun_factorization_main gcd f g i as)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. yun_gcd.yun_factorization_main gcd (hp f) (hp g) i (hpi as) =\n    hpi (yun_gcd.yun_factorization_main gcd f g i as)", "proof (induct rule: ind)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>bn cn i as.\n       bn = 1 \\<Longrightarrow>\n       yun_gcd.yun_factorization_main gcd (hp bn) (hp cn) i (hpi as) =\n       hpi (yun_gcd.yun_factorization_main gcd bn cn i as)\n 2. \\<And>bn cn i as.\n       \\<lbrakk>bn \\<noteq> 1;\n        \\<And>i as.\n           yun_gcd.yun_factorization_main gcd\n            (hp (bn div gcd bn (cn - pderiv bn)))\n            (hp ((cn - pderiv bn) div gcd bn (cn - pderiv bn))) i (hpi as) =\n           hpi (yun_gcd.yun_factorization_main gcd\n                 (bn div gcd bn (cn - pderiv bn))\n                 ((cn - pderiv bn) div gcd bn (cn - pderiv bn)) i\n                 as)\\<rbrakk>\n       \\<Longrightarrow> yun_gcd.yun_factorization_main gcd (hp bn) (hp cn)\n                          i (hpi as) =\n                         hpi (yun_gcd.yun_factorization_main gcd bn cn i as)", "case (1 f g i as)"], ["proof (state)\nthis:\n  f = 1\n\ngoal (2 subgoals):\n 1. \\<And>bn cn i as.\n       bn = 1 \\<Longrightarrow>\n       yun_gcd.yun_factorization_main gcd (hp bn) (hp cn) i (hpi as) =\n       hpi (yun_gcd.yun_factorization_main gcd bn cn i as)\n 2. \\<And>bn cn i as.\n       \\<lbrakk>bn \\<noteq> 1;\n        \\<And>i as.\n           yun_gcd.yun_factorization_main gcd\n            (hp (bn div gcd bn (cn - pderiv bn)))\n            (hp ((cn - pderiv bn) div gcd bn (cn - pderiv bn))) i (hpi as) =\n           hpi (yun_gcd.yun_factorization_main gcd\n                 (bn div gcd bn (cn - pderiv bn))\n                 ((cn - pderiv bn) div gcd bn (cn - pderiv bn)) i\n                 as)\\<rbrakk>\n       \\<Longrightarrow> yun_gcd.yun_factorization_main gcd (hp bn) (hp cn)\n                          i (hpi as) =\n                         hpi (yun_gcd.yun_factorization_main gcd bn cn i as)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. yun_gcd.yun_factorization_main gcd (hp f) (hp g) i (hpi as) =\n    hpi (yun_gcd.yun_factorization_main gcd f g i as)", "unfolding yun_gcd.yun_factorization_main.simps[of _ \"hp f\"] yun_gcd.yun_factorization_main.simps[of _ f]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if hp f = 1 then hpi as\n     else let dn = hp g - pderiv (hp f); an = gcd (hp f) dn\n          in yun_gcd.yun_factorization_main gcd (hp f div an) (dn div an)\n              (Suc i) ((an, i) # hpi as)) =\n    hpi (if f = 1 then as\n         else let dn = g - pderiv f; an = gcd f dn\n              in yun_gcd.yun_factorization_main gcd (f div an) (dn div an)\n                  (Suc i) ((an, i) # as))", "unfolding 1"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if hp 1 = 1 then hpi as\n     else let dn = hp g - pderiv (hp 1); an = gcd (hp 1) dn\n          in yun_gcd.yun_factorization_main gcd (hp 1 div an) (dn div an)\n              (Suc i) ((an, i) # hpi as)) =\n    hpi (if 1 = 1 then as\n         else let dn = g - pderiv 1; an = gcd 1 dn\n              in yun_gcd.yun_factorization_main gcd (1 div an) (dn div an)\n                  (Suc i) ((an, i) # as))", "by simp"], ["proof (state)\nthis:\n  yun_gcd.yun_factorization_main gcd (hp f) (hp g) i (hpi as) =\n  hpi (yun_gcd.yun_factorization_main gcd f g i as)\n\ngoal (1 subgoal):\n 1. \\<And>bn cn i as.\n       \\<lbrakk>bn \\<noteq> 1;\n        \\<And>i as.\n           yun_gcd.yun_factorization_main gcd\n            (hp (bn div gcd bn (cn - pderiv bn)))\n            (hp ((cn - pderiv bn) div gcd bn (cn - pderiv bn))) i (hpi as) =\n           hpi (yun_gcd.yun_factorization_main gcd\n                 (bn div gcd bn (cn - pderiv bn))\n                 ((cn - pderiv bn) div gcd bn (cn - pderiv bn)) i\n                 as)\\<rbrakk>\n       \\<Longrightarrow> yun_gcd.yun_factorization_main gcd (hp bn) (hp cn)\n                          i (hpi as) =\n                         hpi (yun_gcd.yun_factorization_main gcd bn cn i as)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>bn cn i as.\n       \\<lbrakk>bn \\<noteq> 1;\n        \\<And>i as.\n           yun_gcd.yun_factorization_main gcd\n            (hp (bn div gcd bn (cn - pderiv bn)))\n            (hp ((cn - pderiv bn) div gcd bn (cn - pderiv bn))) i (hpi as) =\n           hpi (yun_gcd.yun_factorization_main gcd\n                 (bn div gcd bn (cn - pderiv bn))\n                 ((cn - pderiv bn) div gcd bn (cn - pderiv bn)) i\n                 as)\\<rbrakk>\n       \\<Longrightarrow> yun_gcd.yun_factorization_main gcd (hp bn) (hp cn)\n                          i (hpi as) =\n                         hpi (yun_gcd.yun_factorization_main gcd bn cn i as)", "case (2 f g i as)"], ["proof (state)\nthis:\n  f \\<noteq> 1\n  yun_gcd.yun_factorization_main gcd (hp (f div gcd f (g - pderiv f)))\n   (hp ((g - pderiv f) div gcd f (g - pderiv f))) ?i (hpi ?as) =\n  hpi (yun_gcd.yun_factorization_main gcd (f div gcd f (g - pderiv f))\n        ((g - pderiv f) div gcd f (g - pderiv f)) ?i ?as)\n\ngoal (1 subgoal):\n 1. \\<And>bn cn i as.\n       \\<lbrakk>bn \\<noteq> 1;\n        \\<And>i as.\n           yun_gcd.yun_factorization_main gcd\n            (hp (bn div gcd bn (cn - pderiv bn)))\n            (hp ((cn - pderiv bn) div gcd bn (cn - pderiv bn))) i (hpi as) =\n           hpi (yun_gcd.yun_factorization_main gcd\n                 (bn div gcd bn (cn - pderiv bn))\n                 ((cn - pderiv bn) div gcd bn (cn - pderiv bn)) i\n                 as)\\<rbrakk>\n       \\<Longrightarrow> yun_gcd.yun_factorization_main gcd (hp bn) (hp cn)\n                          i (hpi as) =\n                         hpi (yun_gcd.yun_factorization_main gcd bn cn i as)", "have id: \"\\<And> f i fis. hpi ((f,i) # fis) = (hp f, i) # hpi fis\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f i fis. hpi ((f, i) # fis) = (hp f, i) # hpi fis", "unfolding hpi"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f i fis.\n       map (\\<lambda>(f, i). (hp f, i)) ((f, i) # fis) =\n       (hp f, i) # map (\\<lambda>(f, i). (hp f, i)) fis", "by auto"], ["proof (state)\nthis:\n  hpi ((?f, ?i) # ?fis) = (hp ?f, ?i) # hpi ?fis\n\ngoal (1 subgoal):\n 1. \\<And>bn cn i as.\n       \\<lbrakk>bn \\<noteq> 1;\n        \\<And>i as.\n           yun_gcd.yun_factorization_main gcd\n            (hp (bn div gcd bn (cn - pderiv bn)))\n            (hp ((cn - pderiv bn) div gcd bn (cn - pderiv bn))) i (hpi as) =\n           hpi (yun_gcd.yun_factorization_main gcd\n                 (bn div gcd bn (cn - pderiv bn))\n                 ((cn - pderiv bn) div gcd bn (cn - pderiv bn)) i\n                 as)\\<rbrakk>\n       \\<Longrightarrow> yun_gcd.yun_factorization_main gcd (hp bn) (hp cn)\n                          i (hpi as) =\n                         hpi (yun_gcd.yun_factorization_main gcd bn cn i as)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. yun_gcd.yun_factorization_main gcd (hp f) (hp g) i (hpi as) =\n    hpi (yun_gcd.yun_factorization_main gcd f g i as)", "unfolding yun_gcd.yun_factorization_main.simps[of _ \"hp f\"] yun_gcd.yun_factorization_main.simps[of _ f]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if hp f = 1 then hpi as\n     else let dn = hp g - pderiv (hp f); an = gcd (hp f) dn\n          in yun_gcd.yun_factorization_main gcd (hp f div an) (dn div an)\n              (Suc i) ((an, i) # hpi as)) =\n    hpi (if f = 1 then as\n         else let dn = g - pderiv f; an = gcd f dn\n              in yun_gcd.yun_factorization_main gcd (f div an) (dn div an)\n                  (Suc i) ((an, i) # as))", "unfolding \"p.hom_1_iff\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if f = 1 then hpi as\n     else let dn = hp g - pderiv (hp f); an = gcd (hp f) dn\n          in yun_gcd.yun_factorization_main gcd (hp f div an) (dn div an)\n              (Suc i) ((an, i) # hpi as)) =\n    hpi (if f = 1 then as\n         else let dn = g - pderiv f; an = gcd f dn\n              in yun_gcd.yun_factorization_main gcd (f div an) (dn div an)\n                  (Suc i) ((an, i) # as))", "unfolding Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if f = 1 then hpi as\n     else yun_gcd.yun_factorization_main gcd\n           (hp f div gcd (hp f) (hp g - pderiv (hp f)))\n           ((hp g - pderiv (hp f)) div gcd (hp f) (hp g - pderiv (hp f)))\n           (Suc i) ((gcd (hp f) (hp g - pderiv (hp f)), i) # hpi as)) =\n    hpi (if f = 1 then as\n         else yun_gcd.yun_factorization_main gcd\n               (f div gcd f (g - pderiv f))\n               ((g - pderiv f) div gcd f (g - pderiv f)) (Suc i)\n               ((gcd f (g - pderiv f), i) # as))", "unfolding homs[symmetric] id[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if f = 1 then hpi as\n     else yun_gcd.yun_factorization_main gcd\n           (hp (f div gcd f (g - pderiv f)))\n           (hp ((g - pderiv f) div gcd f (g - pderiv f))) (Suc i)\n           (hpi ((gcd f (g - pderiv f), i) # as))) =\n    hpi (if f = 1 then as\n         else yun_gcd.yun_factorization_main gcd\n               (f div gcd f (g - pderiv f))\n               ((g - pderiv f) div gcd f (g - pderiv f)) (Suc i)\n               ((gcd f (g - pderiv f), i) # as))", "unfolding 2(2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if f = 1 then hpi as\n     else hpi (yun_gcd.yun_factorization_main gcd\n                (f div gcd f (g - pderiv f))\n                ((g - pderiv f) div gcd f (g - pderiv f)) (Suc i)\n                ((gcd f (g - pderiv f), i) # as))) =\n    hpi (if f = 1 then as\n         else yun_gcd.yun_factorization_main gcd\n               (f div gcd f (g - pderiv f))\n               ((g - pderiv f) div gcd f (g - pderiv f)) (Suc i)\n               ((gcd f (g - pderiv f), i) # as))", "by simp"], ["proof (state)\nthis:\n  yun_gcd.yun_factorization_main gcd (hp f) (hp g) i (hpi as) =\n  hpi (yun_gcd.yun_factorization_main gcd f g i as)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  yun_gcd.yun_factorization_main gcd (hp f) (hp g) i (hpi as) =\n  hpi (yun_gcd.yun_factorization_main gcd f g i as)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma square_free_square_free_factorization: \n  \"square_free (p :: 'a :: {field,factorial_ring_gcd,semiring_gcd_mult_normalize} poly) \\<Longrightarrow> \n     degree p \\<noteq> 0 \\<Longrightarrow> square_free_factorization p (1,[(p,0)])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>square_free p; degree p \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> square_free_factorization p (1::'a, [(p, 0)])", "by (intro square_free_factorizationI', auto)"], ["", "lemma constant_square_free_factorization: \n  \"degree p = 0 \\<Longrightarrow> square_free_factorization p (coeff p 0,[])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree p = 0 \\<Longrightarrow>\n    square_free_factorization p (coeff p 0, [])", "by (drule degree0_coeffs [of p]) (auto simp: square_free_factorization_def)"], ["", "lemma (in field_hom_0') yun_monic_factorization:\n  defines hp: \"hp \\<equiv> map_poly hom\"\n  defines hpi: \"hpi \\<equiv> map (\\<lambda> (f,i). (hp f, i :: nat))\"\n  assumes monic: \"monic f\"\n  shows \"yun_gcd.yun_monic_factorization gcd (hp f) = hpi (yun_gcd.yun_monic_factorization gcd f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. yun_gcd.yun_monic_factorization gcd (hp f) =\n    hpi (yun_gcd.yun_monic_factorization gcd f)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. yun_gcd.yun_monic_factorization gcd (hp f) =\n    hpi (yun_gcd.yun_monic_factorization gcd f)", "interpret map_poly_hom: map_poly_inj_comm_ring_hom"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_poly_inj_comm_ring_hom hom", ".."], ["proof (state)\ngoal (1 subgoal):\n 1. yun_gcd.yun_monic_factorization gcd (hp f) =\n    hpi (yun_gcd.yun_monic_factorization gcd f)", "interpret p: inj_ring_hom hp"], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_ring_hom hp", "unfolding hp"], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_ring_hom (map_poly hom)", ".."], ["proof (state)\ngoal (1 subgoal):\n 1. yun_gcd.yun_monic_factorization gcd (hp f) =\n    hpi (yun_gcd.yun_monic_factorization gcd f)", "have hpiN: \"hpi [] = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hpi [] = []", "unfolding hpi"], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>(f, i). (hp f, i)) [] = []", "by simp"], ["proof (state)\nthis:\n  hpi [] = []\n\ngoal (1 subgoal):\n 1. yun_gcd.yun_monic_factorization gcd (hp f) =\n    hpi (yun_gcd.yun_monic_factorization gcd f)", "obtain res where \"res = \n    yun_gcd.yun_factorization_main gcd (f div gcd f (pderiv f)) (pderiv f div gcd f (pderiv f)) 0 []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>res.\n        res =\n        yun_gcd.yun_factorization_main gcd (f div gcd f (pderiv f))\n         (pderiv f div gcd f (pderiv f)) 0 [] \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  res =\n  yun_gcd.yun_factorization_main gcd (f div gcd f (pderiv f))\n   (pderiv f div gcd f (pderiv f)) 0 []\n\ngoal (1 subgoal):\n 1. yun_gcd.yun_monic_factorization gcd (hp f) =\n    hpi (yun_gcd.yun_monic_factorization gcd f)", "note homs = map_poly_gcd[folded hp] \n      map_poly_pderiv[folded hp] \n      p.hom_minus \n      map_poly_div[folded hp]\n      yun_factorization_main_hom[folded hp, folded hpi, symmetric, OF monic refl refl, of _ Nil, unfolded hpiN]\n      this"], ["proof (state)\nthis:\n  hp (gcd ?p ?q) = gcd (hp ?p) (hp ?q)\n  hp (pderiv ?p) = pderiv (hp ?p)\n  hp (?x - ?y) = hp ?x - hp ?y\n  hp (?p div ?q) = hp ?p div hp ?q\n  hpi (yun_gcd.yun_factorization_main gcd (f div gcd f (pderiv f))\n        (pderiv f div gcd f (pderiv f)) ?i []) =\n  yun_gcd.yun_factorization_main gcd (hp (f div gcd f (pderiv f)))\n   (hp (pderiv f div gcd f (pderiv f))) ?i []\n  res =\n  yun_gcd.yun_factorization_main gcd (f div gcd f (pderiv f))\n   (pderiv f div gcd f (pderiv f)) 0 []\n\ngoal (1 subgoal):\n 1. yun_gcd.yun_monic_factorization gcd (hp f) =\n    hpi (yun_gcd.yun_monic_factorization gcd f)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. yun_gcd.yun_monic_factorization gcd (hp f) =\n    hpi (yun_gcd.yun_monic_factorization gcd f)", "unfolding yun_gcd.yun_monic_factorization_def Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. filter (\\<lambda>(a, i). a \\<noteq> 1)\n     (yun_gcd.yun_factorization_main gcd\n       (hp f div gcd (hp f) (pderiv (hp f)))\n       (pderiv (hp f) div gcd (hp f) (pderiv (hp f))) 0 []) =\n    hpi (filter (\\<lambda>(a, i). a \\<noteq> 1)\n          (yun_gcd.yun_factorization_main gcd (f div gcd f (pderiv f))\n            (pderiv f div gcd f (pderiv f)) 0 []))", "unfolding homs[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. filter (\\<lambda>(a, i). a \\<noteq> 1) (hpi res) =\n    hpi (filter (\\<lambda>(a, i). a \\<noteq> 1) res)", "unfolding hpi"], ["proof (prove)\ngoal (1 subgoal):\n 1. filter (\\<lambda>(a, i). a \\<noteq> 1)\n     (map (\\<lambda>(f, i). (hp f, i)) res) =\n    map (\\<lambda>(f, i). (hp f, i))\n     (filter (\\<lambda>(a, i). a \\<noteq> 1) res)", "by (induct res, auto)"], ["proof (state)\nthis:\n  yun_gcd.yun_monic_factorization gcd (hp f) =\n  hpi (yun_gcd.yun_monic_factorization gcd f)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in field_hom_0') yun_factorization_hom:\n  defines hp: \"hp \\<equiv> map_poly hom\"\n  defines hpi: \"hpi \\<equiv> map (\\<lambda> (f,i). (hp f, i :: nat))\"\n  shows \"yun_factorization gcd (hp f) = map_prod hom hpi (yun_factorization gcd f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. yun_factorization gcd (hp f) =\n    map_prod hom hpi (yun_factorization gcd f)", "using yun_monic_factorization[of \"smult (inverse (coeff f (degree f))) f\"]"], ["proof (prove)\nusing this:\n  monic (smult (inverse (lead_coeff f)) f) \\<Longrightarrow>\n  yun_gcd.yun_monic_factorization gcd\n   (map_poly hom (smult (inverse (lead_coeff f)) f)) =\n  map (\\<lambda>(f, i). (map_poly hom f, i))\n   (yun_gcd.yun_monic_factorization gcd (smult (inverse (lead_coeff f)) f))\n\ngoal (1 subgoal):\n 1. yun_factorization gcd (hp f) =\n    map_prod hom hpi (yun_factorization gcd f)", "unfolding yun_factorization_def Let_def hp hpi"], ["proof (prove)\nusing this:\n  monic (smult (inverse (lead_coeff f)) f) \\<Longrightarrow>\n  yun_gcd.yun_monic_factorization gcd\n   (map_poly hom (smult (inverse (lead_coeff f)) f)) =\n  map (\\<lambda>(f, i). (map_poly hom f, i))\n   (yun_gcd.yun_monic_factorization gcd (smult (inverse (lead_coeff f)) f))\n\ngoal (1 subgoal):\n 1. (if map_poly hom f = 0 then (0::'b, [])\n     else (lead_coeff (map_poly hom f),\n           yun_gcd.yun_monic_factorization gcd\n            (smult (inverse (lead_coeff (map_poly hom f)))\n              (map_poly hom f)))) =\n    map_prod hom (map (\\<lambda>(f, i). (map_poly hom f, i)))\n     (if f = 0 then (0::'a, [])\n      else (lead_coeff f,\n            yun_gcd.yun_monic_factorization gcd\n             (smult (inverse (lead_coeff f)) f)))", "by (auto simp: hom_distribs)"], ["", "lemma (in field_hom_0') square_free_map_poly:\n  \"square_free (map_poly hom f) = square_free f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. square_free (map_poly hom f) = square_free f", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. square_free (map_poly hom f) = square_free f", "interpret map_poly_hom: map_poly_inj_comm_ring_hom"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_poly_inj_comm_ring_hom hom", ".."], ["proof (state)\ngoal (1 subgoal):\n 1. square_free (map_poly hom f) = square_free f", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. square_free (map_poly hom f) = square_free f", "unfolding square_free_iff_separable separable_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. coprime (map_poly hom f) (pderiv (map_poly hom f)) =\n    coprime f (pderiv f)", "by (simp only: hom_distribs [symmetric] (*fold doesn't work!*))\n      (simp add: coprime_iff_gcd_eq_1 map_poly_gcd [symmetric])"], ["proof (state)\nthis:\n  square_free (map_poly hom f) = square_free f\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}