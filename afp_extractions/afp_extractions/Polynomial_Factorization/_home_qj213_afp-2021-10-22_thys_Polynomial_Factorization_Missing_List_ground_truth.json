{"file_name": "/home/qj213/afp-2021-10-22/thys/Polynomial_Factorization/Missing_List.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Polynomial_Factorization", "problem_names": ["lemma concat_lists_listset: \"set (concat_lists xs) = listset (map set xs)\"", "lemma sum_list_concat: \"sum_list (concat ls) = sum_list (map sum_list ls)\"", "lemma listset: \"listset xs = { ys. length ys = length xs \\<and> (\\<forall> i < length xs. ys ! i \\<in> xs ! i)}\"", "lemma set_concat_lists[simp]: \"set (concat_lists xs) = {as. length as = length xs \\<and> (\\<forall>i<length xs. as ! i \\<in> set (xs ! i))}\"", "lemma find_map_filter_Some: \"find_map_filter f p as = Some b \\<Longrightarrow> p b \\<and> b \\<in> f ` set as\"", "lemma find_map_filter_None: \"find_map_filter f p as = None \\<Longrightarrow> \\<forall> b \\<in> f ` set as. \\<not> p b\"", "lemma remdups_adj_sorted_distinct[simp]: \"sorted xs \\<Longrightarrow> distinct (remdups_adj xs)\"", "lemma subseqs_length_simple:\n  assumes \"b \\<in> set (subseqs xs)\" shows \"length b \\<le> length xs\"", "lemma subseqs_length_simple_False:\n  assumes \"b \\<in> set (subseqs xs)\" \" length xs < length b\" shows False", "lemma empty_subseqs[simp]: \"[] \\<in> set (subseqs xs)\"", "lemma full_list_subseqs: \"{ys. ys \\<in> set (subseqs xs) \\<and> length ys = length xs} = {xs}\"", "lemma nth_concat_split: assumes \"i < length (concat xs)\" \n  shows \"\\<exists> j k. j < length xs \\<and> k < length (xs ! j) \\<and> concat xs ! i = xs ! j ! k\"", "lemma nth_concat_diff: assumes \"i1 < length (concat xs)\" \"i2 < length (concat xs)\" \"i1 \\<noteq> i2\"\n  shows \"\\<exists> j1 k1 j2 k2. (j1,k1) \\<noteq> (j2,k2) \\<and> j1 < length xs \\<and> j2 < length xs\n    \\<and> k1 < length (xs ! j1) \\<and> k2 < length (xs ! j2) \n    \\<and> concat xs ! i1 = xs ! j1 ! k1 \\<and> concat xs ! i2 = xs ! j2 ! k2\"", "lemma list_all2_map_map: \"(\\<And> x. x \\<in> set xs \\<Longrightarrow> R (f x) (g x)) \\<Longrightarrow> list_all2 R (map f xs) (map g xs)\"", "lemma is_partition_alt: \"is_partition = is_partition_alt\"", "lemma is_partition_Nil:\n  \"is_partition [] = True\"", "lemma is_partition_Cons:\n  \"is_partition (x#xs) \\<longleftrightarrow> is_partition xs \\<and> x \\<inter> \\<Union>(set xs) = {}\" (is \"?l = ?r\")", "lemma is_partition_sublist:\n  assumes \"is_partition (us @ xs @ ys @ zs @ vs)\" \n  shows \"is_partition (xs @ zs)\"", "lemma is_partition_inj_map:\n  assumes \"is_partition xs\"\n  and \"inj_on f (\\<Union>x \\<in> set xs. x)\"\n  shows \"is_partition (map ((`) f) xs)\"", "lemma is_partition_code[code]: \"is_partition as = (is_partition_impl as \\<noteq> None)\"", "lemma case_prod_partition:\n  \"case_prod f (partition p xs) = f (filter p xs) (filter (Not \\<circ> p) xs)\"", "lemmas map_id[simp] = list.map_id", "lemma fun_merge: assumes \n      i: \"i < length as\"\n  and a: \"a \\<in> as ! i\"\n  and ident: \"\\<And> i j a. i < length as \\<Longrightarrow> j < length as \\<Longrightarrow> a \\<in> as ! i \\<Longrightarrow> a \\<in> as ! j \\<Longrightarrow> (fs ! i) a = (fs ! j) a\"\n  shows \"fun_merge fs as a = (fs ! i) a\"", "lemma fun_merge_part: assumes \n      part: \"is_partition as\"\n  and i: \"i < length as\"\n  and a: \"a \\<in> as ! i\"\n  shows \"fun_merge fs as a = (fs ! i) a\"", "lemma map_nth_conv: \"map f ss = map g ts \\<Longrightarrow> \\<forall>i < length ss. f(ss!i) = g(ts!i)\"", "lemma distinct_take_drop:\n  assumes dist: \"distinct vs\" and len: \"i < length vs\" shows \"distinct(take i vs @ drop (Suc i) vs)\" (is \"distinct(?xs@?ys)\")", "lemma map_nth_eq_conv:\n  assumes len: \"length xs = length ys\"\n  shows \"(map f xs = ys) = (\\<forall>i<length ys. f (xs ! i) = ys ! i)\" (is \"?l = ?r\")", "lemma map_upt_len_conv: \n  \"map (\\<lambda> i . f (xs!i)) [0..<length xs] = map f xs\"", "lemma map_upt_add':\n  \"map f [a..<a+b] = map (\\<lambda> i. f (a + i)) [0..<b]\"", "lemma set_generate_lists[simp]: \"set (generate_lists n xs) = {as. length as = n \\<and> set as \\<subseteq> set xs}\"", "lemma nth_append_take:\n  assumes \"i \\<le> length xs\" shows \"(take i xs @ y#ys)!i = y\"", "lemma nth_append_take_is_nth_conv:\n  assumes \"i < j\" and \"j \\<le> length xs\" shows \"(take j xs @ ys)!i = xs!i\"", "lemma nth_append_drop_is_nth_conv:\n  assumes \"j < i\" and \"j \\<le> length xs\" and \"i \\<le> length xs\"\n  shows \"(take j xs @ y # drop (Suc j) xs)!i = xs!i\"", "lemma nth_append_take_drop_is_nth_conv: \n assumes \"i \\<le> length xs\" and \"j \\<le> length xs\" and \"i \\<noteq> j\" \n shows \"(take j xs @ y # drop (Suc j) xs)!i = xs!i\"", "lemma take_drop_imp_nth: \"\\<lbrakk>take i ss @ x # drop (Suc i) ss = ss\\<rbrakk> \\<Longrightarrow> x = ss!i\"", "lemma take_drop_update_first: assumes \"j < length ds\" and \"length cs = length ds\"\n  shows \"(take j ds @ drop j cs)[j := ds ! j] = take (Suc j) ds @ drop (Suc j) cs\"", "lemma take_drop_update_second: assumes \"j < length ds\" and \"length cs = length ds\"\n  shows \"(take j ds @ drop j cs)[j := cs ! j] = take j ds @ drop j cs\"", "lemma nth_take_prefix:\n \"length ys \\<le> length xs \\<Longrightarrow> \\<forall>i < length ys. xs!i = ys!i \\<Longrightarrow> take (length ys) xs = ys\"", "lemma take_upt_idx:\n  assumes i: \"i < length ls\"\n  shows \"take i ls = [ ls ! j . j \\<leftarrow> [0..<i]]\"", "lemma distinct_eq_append: \"distinct_eq eq (xs @ ys) = (distinct_eq eq xs \\<and> distinct_eq eq ys \\<and> (\\<forall> x \\<in> set xs. \\<forall> y \\<in> set ys. \\<not> (eq y x)))\"", "lemma append_Cons_nth_left:\n  assumes \"i < length xs\"\n  shows \"(xs @ u # ys) ! i = xs ! i\"", "lemma append_Cons_nth_middle:\n  assumes \"i = length xs\"\n  shows \"(xs @ y # zs) ! i = y\"", "lemma append_Cons_nth_right:\n  assumes \"i > length xs\"\n  shows \"(xs @ u # ys) ! i = (xs @ z # ys) ! i\"", "lemma append_Cons_nth_not_middle:\n  assumes \"i \\<noteq> length xs\"\n  shows \"(xs @ u # ys) ! i = (xs @ z # ys) ! i\"", "lemmas append_Cons_nth = append_Cons_nth_middle append_Cons_nth_not_middle", "lemma concat_all_nth:\n  assumes \"length xs = length ys\"\n    and \"\\<And>i. i < length xs \\<Longrightarrow> length (xs ! i) = length (ys ! i)\"\n    and \"\\<And>i j. i < length xs \\<Longrightarrow> j < length (xs ! i) \\<Longrightarrow> P (xs ! i ! j) (ys ! i ! j)\"\n  shows \"\\<forall>k<length (concat xs). P (concat xs ! k) (concat ys ! k)\"", "lemma eq_length_concat_nth:\n  assumes \"length xs = length ys\"\n    and \"\\<And>i. i < length xs \\<Longrightarrow> length (xs ! i) = length (ys ! i)\"\n  shows \"length (concat xs) = length (concat ys)\"", "lemma set_list_union[simp]: \"set (list_union xs ys) = set xs \\<union> set ys\"", "lemma set_list_inter[simp]:\n  \"set (list_inter xs ys) = set xs \\<inter> set ys\"", "lemma set_list_diff[simp]:\n  \"set (list_diff xs ys) = set xs - set ys\"", "lemma nth_drop_0: \"0 < length ss \\<Longrightarrow> (ss!0)#drop (Suc 0) ss = ss\"", "lemma set_foldr_remdups_set_map_conv[simp]:\n  \"set (foldr (\\<lambda>x xs. remdups (f x @ xs)) xs []) = \\<Union>(set (map (set \\<circ> f) xs))\"", "lemma subset_set_code[code_unfold]: \"set xs \\<subseteq> set ys \\<longleftrightarrow> list_all (\\<lambda>x. x \\<in> set ys) xs\"", "lemma [simp]: \"set (union_list_sorted xs ys) = set xs \\<union> set ys\"", "lemma set_subtract_list_sorted[simp]: \"sorted xs \\<Longrightarrow> sorted ys \\<Longrightarrow>\n  set (subtract_list_sorted xs ys) = set xs - set ys\"", "lemma subset_subtract_listed_sorted: \"set (subtract_list_sorted xs ys) \\<subseteq> set xs\"", "lemma set_subtract_list_distinct[simp]: \"distinct xs \\<Longrightarrow> distinct (subtract_list_sorted xs ys)\"", "lemma remdups_sort[simp]: \"sorted (remdups_sort xs)\" \"set (remdups_sort xs) = set xs\"\n  \"distinct (remdups_sort xs)\"", "lemma max_list_mono: assumes \"\\<And> x. x \\<in> set xs - set ys \\<Longrightarrow> \\<exists> y. y \\<in> set ys \\<and> x \\<le> y\"\n  shows \"max_list xs \\<le> max_list ys\"", "lemma min_list: \"(x :: 'a :: linorder) \\<in> set xs \\<Longrightarrow> min_list xs \\<le> x\"", "lemma min_list_Cons:\n  assumes xy: \"x \\<le> y\"\n    and len: \"length xs = length ys\"\n    and xsys: \"min_list xs \\<le> min_list ys\"\n  shows \"min_list (x # xs) \\<le> min_list (y # ys)\"", "lemma min_list_nth:\n  assumes \"length xs = length ys\"\n    and \"\\<And>i. i < length ys \\<Longrightarrow> xs ! i \\<le> ys ! i\"\n  shows \"min_list xs \\<le> min_list ys\"", "lemma min_list_ex:\n  assumes \"xs \\<noteq> []\" shows \"\\<exists>x\\<in>set xs. min_list xs = x\"", "lemma min_list_subset:\n  assumes subset: \"set ys \\<subseteq> set xs\" and mem: \"min_list xs \\<in> set ys\"\n  shows \"min_list xs = min_list ys\"", "lemma permut_aux_sound:\n  assumes \"i < length as\"\n  shows \"permut_aux as f bs ! i = bs ! (f i)\"", "lemma permut_sound:\n  assumes \"i < length as\"\n  shows \"permut as f ! i = as ! (f i)\"", "lemma permut_aux_length:\n  assumes \"bij_betw f {..<length as} {..<length bs}\"\n  shows \"length (permut_aux as f bs) = length as\"", "lemma permut_length:\n  assumes \"bij_betw f {..< length as} {..< length as}\"\n  shows \"length (permut as f) = length as\"", "lemma foldl_assoc:\n  fixes b :: \"('a \\<Rightarrow> 'a) \\<Rightarrow> ('a \\<Rightarrow> 'a) \\<Rightarrow> 'a \\<Rightarrow> 'a\" (infixl \"\\<cdot>\" 55)\n  assumes \"\\<And>f g h. f \\<cdot> (g \\<cdot> h) = f \\<cdot> g \\<cdot> h\"\n  shows \"foldl (\\<cdot>) (x \\<cdot> y) zs = x \\<cdot> foldl (\\<cdot>) y zs\"", "lemma foldr_assoc:\n  assumes \"\\<And>f g h. b (b f g) h = b f (b g h)\"\n  shows \"foldr b xs (b y z) = b (foldr b xs y) z\"", "lemma foldl_foldr_o_id:\n  \"foldl (\\<circ>) id fs = foldr (\\<circ>) fs id\"", "lemma foldr_o_o_id[simp]:\n  \"foldr ((\\<circ>) \\<circ> f) xs id a = foldr f xs a\"", "lemma Ex_list_of_length_P:\n  assumes \"\\<forall>i<n. \\<exists>x. P x i\"\n  shows \"\\<exists>xs. length xs = n \\<and> (\\<forall>i<n. P (xs ! i) i)\"", "lemma ex_set_conv_ex_nth: \"(\\<exists>x\\<in>set xs. P x) = (\\<exists>i<length xs. P (xs ! i))\"", "lemma map_eq_set_zipD [dest]:\n  assumes \"map f xs = map f ys\"\n    and \"(x, y) \\<in> set (zip xs ys)\"\n  shows \"f x = f y\"", "lemma span[simp]: \"span P xs = (takeWhile P xs, dropWhile P xs)\"", "lemma parallel_list_update: assumes \n  one_update: \"\\<And> xs i y. length xs = n \\<Longrightarrow> i < n \\<Longrightarrow> r (xs ! i) y \\<Longrightarrow> p xs \\<Longrightarrow> p (xs[i := y])\"\n  and init: \"length xs = n\" \"p xs\"\n  and rel: \"length ys = n\" \"\\<And> i. i < n \\<Longrightarrow> r (xs ! i) (ys ! i)\"\n  shows \"p ys\"", "lemma nth_concat_two_lists: \n  \"i < length (concat (xs :: 'a list list)) \\<Longrightarrow> length (ys :: 'b list list) = length xs \n  \\<Longrightarrow> (\\<And> i. i < length xs \\<Longrightarrow> length (ys ! i) = length (xs ! i))\n  \\<Longrightarrow> \\<exists> j k. j < length xs \\<and> k < length (xs ! j) \\<and> (concat xs) ! i = xs ! j ! k \\<and>\n     (concat ys) ! i = ys ! j ! k\"", "lemma remdups_gen_subset: \"set (remdups_gen f xs) \\<subseteq> set xs\"", "lemma remdups_gen_elem_imp_elem: \"x \\<in> set (remdups_gen f xs) \\<Longrightarrow> x \\<in> set xs\"", "lemma elem_imp_remdups_gen_elem: \"x \\<in> set xs \\<Longrightarrow> \\<exists> y \\<in> set (remdups_gen f xs). f x = f y\"", "lemma take_nth_drop_concat:\n  assumes \"i < length xss\" and \"xss ! i = ys\"\n    and \"j < length ys\" and \"ys ! j = z\"\n  shows \"\\<exists>k < length (concat xss).\n    take k (concat xss) = concat (take i xss) @ take j ys \\<and>\n    concat xss ! k = xss ! i ! j \\<and>\n    drop (Suc k) (concat xss) = drop (Suc j) ys @ concat (drop (Suc i) xss)\"", "lemma concat_map_empty [simp]:\n  \"concat (map (\\<lambda>_. []) xs) = []\"", "lemma map_upt_len_same_len_conv:\n  assumes \"length xs = length ys\"\n  shows \"map (\\<lambda>i. f (xs ! i)) [0 ..< length ys] = map f xs\"", "lemma concat_map_concat [simp]:\n  \"concat (map concat xs) = concat (concat xs)\"", "lemma concat_concat_map:\n  \"concat (concat (map f xs)) = concat (map (concat \\<circ> f) xs)\"", "lemma UN_upt_len_conv [simp]:\n  \"length xs = n \\<Longrightarrow> (\\<Union>i \\<in> {0 ..< n}. f (xs ! i)) = \\<Union>(set (map f xs))\"", "lemma Ball_at_Least0LessThan_conv [simp]:\n  \"length xs = n \\<Longrightarrow>\n    (\\<forall>i \\<in> {0 ..< n}. P (xs ! i)) \\<longleftrightarrow> (\\<forall>x \\<in> set xs. P x)\"", "lemma sum_list_replicate_length [simp]:\n  \"sum_list (replicate (length xs) (Suc 0)) = length xs\"", "lemma list_all2_in_set2:\n  assumes \"list_all2 P xs ys\" and \"y \\<in> set ys\"\n  obtains x where \"x \\<in> set xs\" and \"P x y\"", "lemma map_eq_conv':\n  \"map f xs = map g ys \\<longleftrightarrow> length xs = length ys \\<and> (\\<forall>i < length xs. f (xs ! i) = g (ys ! i))\"", "lemma list_3_cases[case_names Nil 1 2]:\n  assumes \"xs = [] \\<Longrightarrow> P\"\n      and \"\\<And>x. xs = [x] \\<Longrightarrow> P\"\n      and \"\\<And>x y ys. xs = x#y#ys \\<Longrightarrow> P\"\n  shows P", "lemma list_4_cases[case_names Nil 1 2 3]:\n  assumes \"xs = [] \\<Longrightarrow> P\"\n      and \"\\<And>x. xs = [x] \\<Longrightarrow> P\"\n      and \"\\<And>x y. xs = [x,y] \\<Longrightarrow> P\"\n      and \"\\<And>x y z zs. xs = x # y # z # zs \\<Longrightarrow> P\"\n  shows P", "lemma foldr_append2 [simp]:\n  \"foldr ((@) \\<circ> f) xs (ys @ zs) = foldr ((@) \\<circ> f) xs ys @ zs\"", "lemma foldr_append2_Nil [simp]:\n  \"foldr ((@) \\<circ> f) xs [] @ zs = foldr ((@) \\<circ> f) xs zs\"", "lemma UNION_set_zip:\n  \"(\\<Union>x \\<in> set (zip [0..<length xs] (map f xs)). g x) = (\\<Union>i < length xs. g (i, f (xs ! i)))\"", "lemma zip_fst: \"p \\<in> set (zip as bs) \\<Longrightarrow> fst p \\<in> set as\"", "lemma zip_snd: \"p \\<in> set (zip as bs) \\<Longrightarrow> snd p \\<in> set bs\"", "lemma zip_size_aux: \"size_list (size o snd) (zip ts ls) \\<le> (size_list size ls)\"", "lemma remove_nth_len:\n  assumes i: \"i < length xs\"\n  shows \"length xs = Suc (length (remove_nth i xs))\"", "lemma remove_nth_length :\n  assumes n_bd: \"n < length xs\"\n  shows \"length (remove_nth n xs) = length xs - 1\"", "lemma remove_nth_id : \"length xs \\<le> n \\<Longrightarrow> remove_nth n xs = xs\"", "lemma remove_nth_sound_l :\n  assumes p_ub: \"p < n\"\n  shows \"(remove_nth n xs) ! p = xs ! p\"", "lemma remove_nth_sound_r :\n  assumes \"n \\<le> p\" and \"p < length xs\"\n  shows \"(remove_nth n xs) ! p = xs ! (Suc p)\"", "lemma nth_remove_nth_conv:\n  assumes \"i < length (remove_nth n xs)\"\n  shows \"remove_nth n xs ! i = xs ! (if i < n then i else Suc i)\"", "lemma remove_nth_P_compat :\n  assumes aslbs: \"length as = length bs\"\n  and Pab: \"\\<forall>i. i < length as \\<longrightarrow> P (as ! i) (bs ! i)\"\n  shows \"\\<forall>i. i < length (remove_nth p as) \\<longrightarrow> P (remove_nth p as ! i) (remove_nth p bs ! i)\"", "lemma adjust_idx_rev1: \"adjust_idx_rev i (adjust_idx i j) = j\"", "lemma adjust_idx_rev2:\n  assumes \"j \\<noteq> i\" shows \"adjust_idx i (adjust_idx_rev i j) = j\"", "lemma adjust_idx_i:\n  \"adjust_idx i j \\<noteq> i\"", "lemma adjust_idx_nth:\n  assumes i: \"i < length xs\"\n  shows \"remove_nth i xs ! j = xs ! adjust_idx i j\" (is \"?l = ?r\")", "lemma adjust_idx_rev_nth:\n  assumes i: \"i < length xs\"\n    and ji: \"j \\<noteq> i\"\n  shows \"remove_nth i xs ! adjust_idx_rev i j = xs ! j\" (is \"?l = ?r\")", "lemma adjust_idx_length:\n  assumes i: \"i < length xs\"\n    and j: \"j < length (remove_nth i xs)\"\n  shows \"adjust_idx i j < length xs\"", "lemma adjust_idx_rev_length:\n  assumes \"i < length xs\"\n    and \"j < length xs\"\n    and \"j \\<noteq> i\"\n  shows \"adjust_idx_rev i j < length (remove_nth i xs)\"", "lemma P_as_bs_extend:\n  assumes lab: \"length as = length bs\"\n  and lcd: \"length cs = length ds\"\n  and nsab: \"\\<forall>i. i < length bs \\<longrightarrow> P (as ! i) (bs ! i)\"\n  and nscd: \"\\<forall>i. i < length ds \\<longrightarrow> P (cs ! i) (ds ! i)\"\n  shows \"\\<forall>i. i < length (bs @ ds) \\<longrightarrow> P ((as @ cs) ! i) ((bs @ ds) ! i)\"", "lemma filter2_length:\n  \"length (fst (filter2 P as bs)) \\<equiv> length (snd (filter2 P as bs))\"", "lemma filter2_sound: \"\\<forall>i. i < length (fst (filter2 P as bs)) \\<longrightarrow> P (fst (filter2 P as bs) ! i) (snd (filter2 P as bs) ! i)\"", "lemma partition2_sound_P: \"\\<forall>i. i < length (fst (fst (partition2 P as bs))) \\<longrightarrow>\n  P (fst (fst (partition2 P as bs)) ! i) (snd (fst (partition2 P as bs)) ! i)\"", "lemma partition2_sound_nP: \"\\<forall>i. i < length (fst (snd (partition2 P as bs))) \\<longrightarrow>\n  \\<not> P (fst (snd (partition2 P as bs)) ! i) (snd (snd (partition2 P as bs)) ! i)\"", "lemma mem_idx_sound_output:\n  assumes \"mem_idx x as = Some i\"\n  shows \"i < length as \\<and> as ! i = x\"", "lemma mem_idx_sound_output2:\n  assumes \"mem_idx x as = Some i\"\n  shows \"\\<forall>j. j < i \\<longrightarrow> as ! j \\<noteq> x\"", "lemma mem_idx_sound:\n \"(x \\<in> set as) = (\\<exists>i. mem_idx x as = Some i)\"", "lemma mem_idx_sound2:\n  \"(x \\<notin> set as) = (mem_idx x as = None)\"", "lemma sum_list_replicate_mono: assumes \"w1 \\<le> (w2 :: nat)\"\n  shows \"sum_list (replicate n w1) \\<le> sum_list (replicate n w2)\"", "lemma all_gt_0_sum_list_map:\n  assumes *: \"\\<And>x. f x > (0::nat)\"\n    and x: \"x \\<in> set xs\" and len: \"1 < length xs\"\n  shows \"f x < (\\<Sum>x\\<leftarrow>xs. f x)\"", "lemma finite_distinct: \"finite { xs . distinct xs \\<and> set xs = X}\" (is \"finite (?S X)\")", "lemma finite_distinct_subset:\n  assumes \"finite X\"\n  shows \"finite { xs . distinct xs \\<and> set xs \\<subseteq> X}\" (is \"finite (?S X)\")", "lemma map_of_filter:\n  assumes \"P x\"\n  shows \"map_of [(x',y) \\<leftarrow> ys. P x'] x = map_of ys x\"", "lemma set_subset_insertI: \"set xs \\<subseteq> set (List.insert x xs)\"", "lemma set_removeAll_subset: \"set (removeAll x xs) \\<subseteq> set xs\"", "lemma map_of_append_Some:\n  \"map_of xs y = Some z \\<Longrightarrow> map_of (xs @ ys) y = Some z\"", "lemma map_of_append_None:\n  \"map_of xs y = None \\<Longrightarrow> map_of (xs @ ys) y = map_of ys y\""], "translations": [["", "lemma concat_lists_listset: \"set (concat_lists xs) = listset (map set xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (concat_lists xs) = listset (map set xs)", "by (induct xs, auto simp: set_Cons_def)"], ["", "lemma sum_list_concat: \"sum_list (concat ls) = sum_list (map sum_list ls)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list (concat ls) = sum_list (map sum_list ls)", "by (induct ls, auto)"], ["", "(* TODO: move to src/HOL/List *)"], ["", "lemma listset: \"listset xs = { ys. length ys = length xs \\<and> (\\<forall> i < length xs. ys ! i \\<in> xs ! i)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. listset xs =\n    {ys.\n     length ys = length xs \\<and>\n     (\\<forall>i<length xs. ys ! i \\<in> xs ! i)}", "proof (induct xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. listset [] =\n    {ys.\n     length ys = length [] \\<and>\n     (\\<forall>i<length []. ys ! i \\<in> [] ! i)}\n 2. \\<And>a xs.\n       listset xs =\n       {ys.\n        length ys = length xs \\<and>\n        (\\<forall>i<length xs. ys ! i \\<in> xs ! i)} \\<Longrightarrow>\n       listset (a # xs) =\n       {ys.\n        length ys = length (a # xs) \\<and>\n        (\\<forall>i<length (a # xs). ys ! i \\<in> (a # xs) ! i)}", "case (Cons x xs)"], ["proof (state)\nthis:\n  listset xs =\n  {ys.\n   length ys = length xs \\<and> (\\<forall>i<length xs. ys ! i \\<in> xs ! i)}\n\ngoal (2 subgoals):\n 1. listset [] =\n    {ys.\n     length ys = length [] \\<and>\n     (\\<forall>i<length []. ys ! i \\<in> [] ! i)}\n 2. \\<And>a xs.\n       listset xs =\n       {ys.\n        length ys = length xs \\<and>\n        (\\<forall>i<length xs. ys ! i \\<in> xs ! i)} \\<Longrightarrow>\n       listset (a # xs) =\n       {ys.\n        length ys = length (a # xs) \\<and>\n        (\\<forall>i<length (a # xs). ys ! i \\<in> (a # xs) ! i)}", "let ?n = \"length xs\""], ["proof (state)\ngoal (2 subgoals):\n 1. listset [] =\n    {ys.\n     length ys = length [] \\<and>\n     (\\<forall>i<length []. ys ! i \\<in> [] ! i)}\n 2. \\<And>a xs.\n       listset xs =\n       {ys.\n        length ys = length xs \\<and>\n        (\\<forall>i<length xs. ys ! i \\<in> xs ! i)} \\<Longrightarrow>\n       listset (a # xs) =\n       {ys.\n        length ys = length (a # xs) \\<and>\n        (\\<forall>i<length (a # xs). ys ! i \\<in> (a # xs) ! i)}", "from Cons"], ["proof (chain)\npicking this:\n  listset xs =\n  {ys.\n   length ys = length xs \\<and> (\\<forall>i<length xs. ys ! i \\<in> xs ! i)}", "have \"?case = (set_Cons x {ys. length ys = ?n \\<and> (\\<forall>i < ?n. ys ! i \\<in> xs ! i)} =\n    {ys. length ys = Suc ?n \\<and> ys ! 0 \\<in> x \\<and> (\\<forall>i < ?n. ys ! Suc i \\<in> xs ! i)})\" \n    (is \"_ = (?L = ?R)\")"], ["proof (prove)\nusing this:\n  listset xs =\n  {ys.\n   length ys = length xs \\<and> (\\<forall>i<length xs. ys ! i \\<in> xs ! i)}\n\ngoal (1 subgoal):\n 1. (listset (x # xs) =\n     {ys.\n      length ys = length (x # xs) \\<and>\n      (\\<forall>i<length (x # xs). ys ! i \\<in> (x # xs) ! i)}) =\n    (set_Cons x\n      {ys.\n       length ys = length xs \\<and>\n       (\\<forall>i<length xs. ys ! i \\<in> xs ! i)} =\n     {ys.\n      length ys = Suc (length xs) \\<and>\n      ys ! 0 \\<in> x \\<and>\n      (\\<forall>i<length xs. ys ! Suc i \\<in> xs ! i)})", "by (auto simp: all_Suc_conv)"], ["proof (state)\nthis:\n  (listset (x # xs) =\n   {ys.\n    length ys = length (x # xs) \\<and>\n    (\\<forall>i<length (x # xs). ys ! i \\<in> (x # xs) ! i)}) =\n  (set_Cons x\n    {ys.\n     length ys = length xs \\<and>\n     (\\<forall>i<length xs. ys ! i \\<in> xs ! i)} =\n   {ys.\n    length ys = Suc (length xs) \\<and>\n    ys ! 0 \\<in> x \\<and> (\\<forall>i<length xs. ys ! Suc i \\<in> xs ! i)})\n\ngoal (2 subgoals):\n 1. listset [] =\n    {ys.\n     length ys = length [] \\<and>\n     (\\<forall>i<length []. ys ! i \\<in> [] ! i)}\n 2. \\<And>a xs.\n       listset xs =\n       {ys.\n        length ys = length xs \\<and>\n        (\\<forall>i<length xs. ys ! i \\<in> xs ! i)} \\<Longrightarrow>\n       listset (a # xs) =\n       {ys.\n        length ys = length (a # xs) \\<and>\n        (\\<forall>i<length (a # xs). ys ! i \\<in> (a # xs) ! i)}", "also"], ["proof (state)\nthis:\n  (listset (x # xs) =\n   {ys.\n    length ys = length (x # xs) \\<and>\n    (\\<forall>i<length (x # xs). ys ! i \\<in> (x # xs) ! i)}) =\n  (set_Cons x\n    {ys.\n     length ys = length xs \\<and>\n     (\\<forall>i<length xs. ys ! i \\<in> xs ! i)} =\n   {ys.\n    length ys = Suc (length xs) \\<and>\n    ys ! 0 \\<in> x \\<and> (\\<forall>i<length xs. ys ! Suc i \\<in> xs ! i)})\n\ngoal (2 subgoals):\n 1. listset [] =\n    {ys.\n     length ys = length [] \\<and>\n     (\\<forall>i<length []. ys ! i \\<in> [] ! i)}\n 2. \\<And>a xs.\n       listset xs =\n       {ys.\n        length ys = length xs \\<and>\n        (\\<forall>i<length xs. ys ! i \\<in> xs ! i)} \\<Longrightarrow>\n       listset (a # xs) =\n       {ys.\n        length ys = length (a # xs) \\<and>\n        (\\<forall>i<length (a # xs). ys ! i \\<in> (a # xs) ! i)}", "have \"?L = ?R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_Cons x\n     {ys.\n      length ys = length xs \\<and>\n      (\\<forall>i<length xs. ys ! i \\<in> xs ! i)} =\n    {ys.\n     length ys = Suc (length xs) \\<and>\n     ys ! 0 \\<in> x \\<and> (\\<forall>i<length xs. ys ! Suc i \\<in> xs ! i)}", "by (auto simp: set_Cons_def, case_tac xa, auto)"], ["proof (state)\nthis:\n  set_Cons x\n   {ys.\n    length ys = length xs \\<and>\n    (\\<forall>i<length xs. ys ! i \\<in> xs ! i)} =\n  {ys.\n   length ys = Suc (length xs) \\<and>\n   ys ! 0 \\<in> x \\<and> (\\<forall>i<length xs. ys ! Suc i \\<in> xs ! i)}\n\ngoal (2 subgoals):\n 1. listset [] =\n    {ys.\n     length ys = length [] \\<and>\n     (\\<forall>i<length []. ys ! i \\<in> [] ! i)}\n 2. \\<And>a xs.\n       listset xs =\n       {ys.\n        length ys = length xs \\<and>\n        (\\<forall>i<length xs. ys ! i \\<in> xs ! i)} \\<Longrightarrow>\n       listset (a # xs) =\n       {ys.\n        length ys = length (a # xs) \\<and>\n        (\\<forall>i<length (a # xs). ys ! i \\<in> (a # xs) ! i)}", "finally"], ["proof (chain)\npicking this:\n  (listset (x # xs) =\n   {ys.\n    length ys = length (x # xs) \\<and>\n    (\\<forall>i<length (x # xs). ys ! i \\<in> (x # xs) ! i)}) =\n  ({ys.\n    length ys = Suc (length xs) \\<and>\n    ys ! 0 \\<in> x \\<and> (\\<forall>i<length xs. ys ! Suc i \\<in> xs ! i)} =\n   {ys.\n    length ys = Suc (length xs) \\<and>\n    ys ! 0 \\<in> x \\<and> (\\<forall>i<length xs. ys ! Suc i \\<in> xs ! i)})", "show ?case"], ["proof (prove)\nusing this:\n  (listset (x # xs) =\n   {ys.\n    length ys = length (x # xs) \\<and>\n    (\\<forall>i<length (x # xs). ys ! i \\<in> (x # xs) ! i)}) =\n  ({ys.\n    length ys = Suc (length xs) \\<and>\n    ys ! 0 \\<in> x \\<and> (\\<forall>i<length xs. ys ! Suc i \\<in> xs ! i)} =\n   {ys.\n    length ys = Suc (length xs) \\<and>\n    ys ! 0 \\<in> x \\<and> (\\<forall>i<length xs. ys ! Suc i \\<in> xs ! i)})\n\ngoal (1 subgoal):\n 1. listset (x # xs) =\n    {ys.\n     length ys = length (x # xs) \\<and>\n     (\\<forall>i<length (x # xs). ys ! i \\<in> (x # xs) ! i)}", "by simp"], ["proof (state)\nthis:\n  listset (x # xs) =\n  {ys.\n   length ys = length (x # xs) \\<and>\n   (\\<forall>i<length (x # xs). ys ! i \\<in> (x # xs) ! i)}\n\ngoal (1 subgoal):\n 1. listset [] =\n    {ys.\n     length ys = length [] \\<and>\n     (\\<forall>i<length []. ys ! i \\<in> [] ! i)}", "qed auto"], ["", "lemma set_concat_lists[simp]: \"set (concat_lists xs) = {as. length as = length xs \\<and> (\\<forall>i<length xs. as ! i \\<in> set (xs ! i))}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (concat_lists xs) =\n    {as.\n     length as = length xs \\<and>\n     (\\<forall>i<length xs. as ! i \\<in> set (xs ! i))}", "unfolding concat_lists_listset listset"], ["proof (prove)\ngoal (1 subgoal):\n 1. {ys.\n     length ys = length (map set xs) \\<and>\n     (\\<forall>i<length (map set xs). ys ! i \\<in> map set xs ! i)} =\n    {as.\n     length as = length xs \\<and>\n     (\\<forall>i<length xs. as ! i \\<in> set (xs ! i))}", "by simp"], ["", "declare concat_lists.simps[simp del]"], ["", "fun find_map_filter :: \"('a \\<Rightarrow> 'b) \\<Rightarrow> ('b \\<Rightarrow> bool) \\<Rightarrow> 'a list \\<Rightarrow> 'b option\" where\n  \"find_map_filter f p [] = None\"\n| \"find_map_filter f p (a # as) = (let b = f a in if p b then Some b else find_map_filter f p as)\""], ["", "lemma find_map_filter_Some: \"find_map_filter f p as = Some b \\<Longrightarrow> p b \\<and> b \\<in> f ` set as\""], ["proof (prove)\ngoal (1 subgoal):\n 1. find_map_filter f p as = Some b \\<Longrightarrow>\n    p b \\<and> b \\<in> f ` set as", "by (induct f p as rule: find_map_filter.induct, auto simp: Let_def split: if_splits)"], ["", "lemma find_map_filter_None: \"find_map_filter f p as = None \\<Longrightarrow> \\<forall> b \\<in> f ` set as. \\<not> p b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. find_map_filter f p as = None \\<Longrightarrow>\n    \\<forall>b\\<in>f ` set as. \\<not> p b", "by (induct f p as rule: find_map_filter.induct, auto simp: Let_def split: if_splits)"], ["", "lemma remdups_adj_sorted_distinct[simp]: \"sorted xs \\<Longrightarrow> distinct (remdups_adj xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted xs \\<Longrightarrow> distinct (remdups_adj xs)", "by (induct xs rule: remdups_adj.induct) (auto)"], ["", "lemma subseqs_length_simple:\n  assumes \"b \\<in> set (subseqs xs)\" shows \"length b \\<le> length xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length b \\<le> length xs", "using assms"], ["proof (prove)\nusing this:\n  b \\<in> set (subseqs xs)\n\ngoal (1 subgoal):\n 1. length b \\<le> length xs", "by(induct xs arbitrary:b;auto simp:Let_def Suc_leD)"], ["", "lemma subseqs_length_simple_False:\n  assumes \"b \\<in> set (subseqs xs)\" \" length xs < length b\" shows False"], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "using assms subseqs_length_simple"], ["proof (prove)\nusing this:\n  b \\<in> set (subseqs xs)\n  length xs < length b\n  ?b \\<in> set (subseqs ?xs) \\<Longrightarrow> length ?b \\<le> length ?xs\n\ngoal (1 subgoal):\n 1. False", "by fastforce"], ["", "lemma empty_subseqs[simp]: \"[] \\<in> set (subseqs xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [] \\<in> set (subseqs xs)", "by (induct xs, auto simp: Let_def)"], ["", "lemma full_list_subseqs: \"{ys. ys \\<in> set (subseqs xs) \\<and> length ys = length xs} = {xs}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {ys \\<in> set (subseqs xs). length ys = length xs} = {xs}", "proof (induct xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. {ys \\<in> set (subseqs []). length ys = length []} = {[]}\n 2. \\<And>a xs.\n       {ys \\<in> set (subseqs xs). length ys = length xs} =\n       {xs} \\<Longrightarrow>\n       {ys \\<in> set (subseqs (a # xs)). length ys = length (a # xs)} =\n       {a # xs}", "case (Cons x xs)"], ["proof (state)\nthis:\n  {ys \\<in> set (subseqs xs). length ys = length xs} = {xs}\n\ngoal (2 subgoals):\n 1. {ys \\<in> set (subseqs []). length ys = length []} = {[]}\n 2. \\<And>a xs.\n       {ys \\<in> set (subseqs xs). length ys = length xs} =\n       {xs} \\<Longrightarrow>\n       {ys \\<in> set (subseqs (a # xs)). length ys = length (a # xs)} =\n       {a # xs}", "have \"?case = ({ys \\<in> (#) x ` set (subseqs xs) \\<union> set (subseqs xs). \n    length ys = Suc (length xs)} = (#) x ` {xs})\" (is \"_ = (?l = ?r)\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. ({ys \\<in> set (subseqs (x # xs)). length ys = length (x # xs)} =\n     {x # xs}) =\n    ({ys \\<in> (#) x ` set (subseqs xs) \\<union> set (subseqs xs).\n      length ys = Suc (length xs)} =\n     (#) x ` {xs})", "by (auto simp: Let_def)"], ["proof (state)\nthis:\n  ({ys \\<in> set (subseqs (x # xs)). length ys = length (x # xs)} =\n   {x # xs}) =\n  ({ys \\<in> (#) x ` set (subseqs xs) \\<union> set (subseqs xs).\n    length ys = Suc (length xs)} =\n   (#) x ` {xs})\n\ngoal (2 subgoals):\n 1. {ys \\<in> set (subseqs []). length ys = length []} = {[]}\n 2. \\<And>a xs.\n       {ys \\<in> set (subseqs xs). length ys = length xs} =\n       {xs} \\<Longrightarrow>\n       {ys \\<in> set (subseqs (a # xs)). length ys = length (a # xs)} =\n       {a # xs}", "also"], ["proof (state)\nthis:\n  ({ys \\<in> set (subseqs (x # xs)). length ys = length (x # xs)} =\n   {x # xs}) =\n  ({ys \\<in> (#) x ` set (subseqs xs) \\<union> set (subseqs xs).\n    length ys = Suc (length xs)} =\n   (#) x ` {xs})\n\ngoal (2 subgoals):\n 1. {ys \\<in> set (subseqs []). length ys = length []} = {[]}\n 2. \\<And>a xs.\n       {ys \\<in> set (subseqs xs). length ys = length xs} =\n       {xs} \\<Longrightarrow>\n       {ys \\<in> set (subseqs (a # xs)). length ys = length (a # xs)} =\n       {a # xs}", "have \"?l = {ys \\<in> (#) x ` set (subseqs xs). length ys = Suc (length xs)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {ys \\<in> (#) x ` set (subseqs xs) \\<union> set (subseqs xs).\n     length ys = Suc (length xs)} =\n    {ys \\<in> (#) x ` set (subseqs xs). length ys = Suc (length xs)}", "using length_subseqs[of xs]"], ["proof (prove)\nusing this:\n  length (subseqs xs) = 2 ^ length xs\n\ngoal (1 subgoal):\n 1. {ys \\<in> (#) x ` set (subseqs xs) \\<union> set (subseqs xs).\n     length ys = Suc (length xs)} =\n    {ys \\<in> (#) x ` set (subseqs xs). length ys = Suc (length xs)}", "using subseqs_length_simple_False"], ["proof (prove)\nusing this:\n  length (subseqs xs) = 2 ^ length xs\n  \\<lbrakk>?b \\<in> set (subseqs ?xs); length ?xs < length ?b\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. {ys \\<in> (#) x ` set (subseqs xs) \\<union> set (subseqs xs).\n     length ys = Suc (length xs)} =\n    {ys \\<in> (#) x ` set (subseqs xs). length ys = Suc (length xs)}", "by force"], ["proof (state)\nthis:\n  {ys \\<in> (#) x ` set (subseqs xs) \\<union> set (subseqs xs).\n   length ys = Suc (length xs)} =\n  {ys \\<in> (#) x ` set (subseqs xs). length ys = Suc (length xs)}\n\ngoal (2 subgoals):\n 1. {ys \\<in> set (subseqs []). length ys = length []} = {[]}\n 2. \\<And>a xs.\n       {ys \\<in> set (subseqs xs). length ys = length xs} =\n       {xs} \\<Longrightarrow>\n       {ys \\<in> set (subseqs (a # xs)). length ys = length (a # xs)} =\n       {a # xs}", "also"], ["proof (state)\nthis:\n  {ys \\<in> (#) x ` set (subseqs xs) \\<union> set (subseqs xs).\n   length ys = Suc (length xs)} =\n  {ys \\<in> (#) x ` set (subseqs xs). length ys = Suc (length xs)}\n\ngoal (2 subgoals):\n 1. {ys \\<in> set (subseqs []). length ys = length []} = {[]}\n 2. \\<And>a xs.\n       {ys \\<in> set (subseqs xs). length ys = length xs} =\n       {xs} \\<Longrightarrow>\n       {ys \\<in> set (subseqs (a # xs)). length ys = length (a # xs)} =\n       {a # xs}", "have \"\\<dots> = (#) x ` {ys \\<in> set (subseqs xs). length ys = length xs}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {ys \\<in> (#) x ` set (subseqs xs). length ys = Suc (length xs)} =\n    (#) x ` {ys \\<in> set (subseqs xs). length ys = length xs}", "by auto"], ["proof (state)\nthis:\n  {ys \\<in> (#) x ` set (subseqs xs). length ys = Suc (length xs)} =\n  (#) x ` {ys \\<in> set (subseqs xs). length ys = length xs}\n\ngoal (2 subgoals):\n 1. {ys \\<in> set (subseqs []). length ys = length []} = {[]}\n 2. \\<And>a xs.\n       {ys \\<in> set (subseqs xs). length ys = length xs} =\n       {xs} \\<Longrightarrow>\n       {ys \\<in> set (subseqs (a # xs)). length ys = length (a # xs)} =\n       {a # xs}", "also"], ["proof (state)\nthis:\n  {ys \\<in> (#) x ` set (subseqs xs). length ys = Suc (length xs)} =\n  (#) x ` {ys \\<in> set (subseqs xs). length ys = length xs}\n\ngoal (2 subgoals):\n 1. {ys \\<in> set (subseqs []). length ys = length []} = {[]}\n 2. \\<And>a xs.\n       {ys \\<in> set (subseqs xs). length ys = length xs} =\n       {xs} \\<Longrightarrow>\n       {ys \\<in> set (subseqs (a # xs)). length ys = length (a # xs)} =\n       {a # xs}", "have \"\\<dots> = (#) x ` {xs}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (#) x ` {ys \\<in> set (subseqs xs). length ys = length xs} =\n    (#) x ` {xs}", "unfolding Cons"], ["proof (prove)\ngoal (1 subgoal):\n 1. (#) x ` {xs} = (#) x ` {xs}", "by auto"], ["proof (state)\nthis:\n  (#) x ` {ys \\<in> set (subseqs xs). length ys = length xs} = (#) x ` {xs}\n\ngoal (2 subgoals):\n 1. {ys \\<in> set (subseqs []). length ys = length []} = {[]}\n 2. \\<And>a xs.\n       {ys \\<in> set (subseqs xs). length ys = length xs} =\n       {xs} \\<Longrightarrow>\n       {ys \\<in> set (subseqs (a # xs)). length ys = length (a # xs)} =\n       {a # xs}", "finally"], ["proof (chain)\npicking this:\n  ({ys \\<in> set (subseqs (x # xs)). length ys = length (x # xs)} =\n   {x # xs}) =\n  ((#) x ` {xs} = (#) x ` {xs})", "show ?case"], ["proof (prove)\nusing this:\n  ({ys \\<in> set (subseqs (x # xs)). length ys = length (x # xs)} =\n   {x # xs}) =\n  ((#) x ` {xs} = (#) x ` {xs})\n\ngoal (1 subgoal):\n 1. {ys \\<in> set (subseqs (x # xs)). length ys = length (x # xs)} =\n    {x # xs}", "by simp"], ["proof (state)\nthis:\n  {ys \\<in> set (subseqs (x # xs)). length ys = length (x # xs)} = {x # xs}\n\ngoal (1 subgoal):\n 1. {ys \\<in> set (subseqs []). length ys = length []} = {[]}", "qed simp"], ["", "lemma nth_concat_split: assumes \"i < length (concat xs)\" \n  shows \"\\<exists> j k. j < length xs \\<and> k < length (xs ! j) \\<and> concat xs ! i = xs ! j ! k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>j k.\n       j < length xs \\<and>\n       k < length (xs ! j) \\<and> concat xs ! i = xs ! j ! k", "using assms"], ["proof (prove)\nusing this:\n  i < length (concat xs)\n\ngoal (1 subgoal):\n 1. \\<exists>j k.\n       j < length xs \\<and>\n       k < length (xs ! j) \\<and> concat xs ! i = xs ! j ! k", "proof (induct xs arbitrary: i)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < length (concat []) \\<Longrightarrow>\n       \\<exists>j k.\n          j < length [] \\<and>\n          k < length ([] ! j) \\<and> concat [] ! i = [] ! j ! k\n 2. \\<And>a xs i.\n       \\<lbrakk>\\<And>i.\n                   i < length (concat xs) \\<Longrightarrow>\n                   \\<exists>j k.\n                      j < length xs \\<and>\n                      k < length (xs ! j) \\<and> concat xs ! i = xs ! j ! k;\n        i < length (concat (a # xs))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j k.\n                            j < length (a # xs) \\<and>\n                            k < length ((a # xs) ! j) \\<and>\n                            concat (a # xs) ! i = (a # xs) ! j ! k", "case (Cons x xs i)"], ["proof (state)\nthis:\n  ?i < length (concat xs) \\<Longrightarrow>\n  \\<exists>j k.\n     j < length xs \\<and>\n     k < length (xs ! j) \\<and> concat xs ! ?i = xs ! j ! k\n  i < length (concat (x # xs))\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < length (concat []) \\<Longrightarrow>\n       \\<exists>j k.\n          j < length [] \\<and>\n          k < length ([] ! j) \\<and> concat [] ! i = [] ! j ! k\n 2. \\<And>a xs i.\n       \\<lbrakk>\\<And>i.\n                   i < length (concat xs) \\<Longrightarrow>\n                   \\<exists>j k.\n                      j < length xs \\<and>\n                      k < length (xs ! j) \\<and> concat xs ! i = xs ! j ! k;\n        i < length (concat (a # xs))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j k.\n                            j < length (a # xs) \\<and>\n                            k < length ((a # xs) ! j) \\<and>\n                            concat (a # xs) ! i = (a # xs) ! j ! k", "define I where \"I = i - length x\""], ["proof (state)\nthis:\n  I = i - length x\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < length (concat []) \\<Longrightarrow>\n       \\<exists>j k.\n          j < length [] \\<and>\n          k < length ([] ! j) \\<and> concat [] ! i = [] ! j ! k\n 2. \\<And>a xs i.\n       \\<lbrakk>\\<And>i.\n                   i < length (concat xs) \\<Longrightarrow>\n                   \\<exists>j k.\n                      j < length xs \\<and>\n                      k < length (xs ! j) \\<and> concat xs ! i = xs ! j ! k;\n        i < length (concat (a # xs))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j k.\n                            j < length (a # xs) \\<and>\n                            k < length ((a # xs) ! j) \\<and>\n                            concat (a # xs) ! i = (a # xs) ! j ! k", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>j k.\n       j < length (x # xs) \\<and>\n       k < length ((x # xs) ! j) \\<and>\n       concat (x # xs) ! i = (x # xs) ! j ! k", "proof (cases \"i < length x\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i < length x \\<Longrightarrow>\n    \\<exists>j k.\n       j < length (x # xs) \\<and>\n       k < length ((x # xs) ! j) \\<and>\n       concat (x # xs) ! i = (x # xs) ! j ! k\n 2. \\<not> i < length x \\<Longrightarrow>\n    \\<exists>j k.\n       j < length (x # xs) \\<and>\n       k < length ((x # xs) ! j) \\<and>\n       concat (x # xs) ! i = (x # xs) ! j ! k", "case True"], ["proof (state)\nthis:\n  i < length x\n\ngoal (2 subgoals):\n 1. i < length x \\<Longrightarrow>\n    \\<exists>j k.\n       j < length (x # xs) \\<and>\n       k < length ((x # xs) ! j) \\<and>\n       concat (x # xs) ! i = (x # xs) ! j ! k\n 2. \\<not> i < length x \\<Longrightarrow>\n    \\<exists>j k.\n       j < length (x # xs) \\<and>\n       k < length ((x # xs) ! j) \\<and>\n       concat (x # xs) ! i = (x # xs) ! j ! k", "note l = this"], ["proof (state)\nthis:\n  i < length x\n\ngoal (2 subgoals):\n 1. i < length x \\<Longrightarrow>\n    \\<exists>j k.\n       j < length (x # xs) \\<and>\n       k < length ((x # xs) ! j) \\<and>\n       concat (x # xs) ! i = (x # xs) ! j ! k\n 2. \\<not> i < length x \\<Longrightarrow>\n    \\<exists>j k.\n       j < length (x # xs) \\<and>\n       k < length ((x # xs) ! j) \\<and>\n       concat (x # xs) ! i = (x # xs) ! j ! k", "hence i: \"concat (Cons x xs) ! i = x ! i\""], ["proof (prove)\nusing this:\n  i < length x\n\ngoal (1 subgoal):\n 1. concat (x # xs) ! i = x ! i", "by (auto simp: nth_append)"], ["proof (state)\nthis:\n  concat (x # xs) ! i = x ! i\n\ngoal (2 subgoals):\n 1. i < length x \\<Longrightarrow>\n    \\<exists>j k.\n       j < length (x # xs) \\<and>\n       k < length ((x # xs) ! j) \\<and>\n       concat (x # xs) ! i = (x # xs) ! j ! k\n 2. \\<not> i < length x \\<Longrightarrow>\n    \\<exists>j k.\n       j < length (x # xs) \\<and>\n       k < length ((x # xs) ! j) \\<and>\n       concat (x # xs) ! i = (x # xs) ! j ! k", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>j k.\n       j < length (x # xs) \\<and>\n       k < length ((x # xs) ! j) \\<and>\n       concat (x # xs) ! i = (x # xs) ! j ! k", "unfolding i"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>j k.\n       j < length (x # xs) \\<and>\n       k < length ((x # xs) ! j) \\<and> x ! i = (x # xs) ! j ! k", "by (rule exI[of _ 0], rule exI[of _ i], insert Cons l, auto)"], ["proof (state)\nthis:\n  \\<exists>j k.\n     j < length (x # xs) \\<and>\n     k < length ((x # xs) ! j) \\<and> concat (x # xs) ! i = (x # xs) ! j ! k\n\ngoal (1 subgoal):\n 1. \\<not> i < length x \\<Longrightarrow>\n    \\<exists>j k.\n       j < length (x # xs) \\<and>\n       k < length ((x # xs) ! j) \\<and>\n       concat (x # xs) ! i = (x # xs) ! j ! k", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> i < length x \\<Longrightarrow>\n    \\<exists>j k.\n       j < length (x # xs) \\<and>\n       k < length ((x # xs) ! j) \\<and>\n       concat (x # xs) ! i = (x # xs) ! j ! k", "case False"], ["proof (state)\nthis:\n  \\<not> i < length x\n\ngoal (1 subgoal):\n 1. \\<not> i < length x \\<Longrightarrow>\n    \\<exists>j k.\n       j < length (x # xs) \\<and>\n       k < length ((x # xs) ! j) \\<and>\n       concat (x # xs) ! i = (x # xs) ! j ! k", "note l = this"], ["proof (state)\nthis:\n  \\<not> i < length x\n\ngoal (1 subgoal):\n 1. \\<not> i < length x \\<Longrightarrow>\n    \\<exists>j k.\n       j < length (x # xs) \\<and>\n       k < length ((x # xs) ! j) \\<and>\n       concat (x # xs) ! i = (x # xs) ! j ! k", "from l Cons(2)"], ["proof (chain)\npicking this:\n  \\<not> i < length x\n  i < length (concat (x # xs))", "have i: \"i = length x + I\" \"I < length (concat xs)\""], ["proof (prove)\nusing this:\n  \\<not> i < length x\n  i < length (concat (x # xs))\n\ngoal (1 subgoal):\n 1. i = length x + I &&& I < length (concat xs)", "unfolding I_def"], ["proof (prove)\nusing this:\n  \\<not> i < length x\n  i < length (concat (x # xs))\n\ngoal (1 subgoal):\n 1. i = length x + (i - length x) &&& i - length x < length (concat xs)", "by auto"], ["proof (state)\nthis:\n  i = length x + I\n  I < length (concat xs)\n\ngoal (1 subgoal):\n 1. \\<not> i < length x \\<Longrightarrow>\n    \\<exists>j k.\n       j < length (x # xs) \\<and>\n       k < length ((x # xs) ! j) \\<and>\n       concat (x # xs) ! i = (x # xs) ! j ! k", "hence iI: \"concat (Cons x xs) ! i = concat xs ! I\""], ["proof (prove)\nusing this:\n  i = length x + I\n  I < length (concat xs)\n\ngoal (1 subgoal):\n 1. concat (x # xs) ! i = concat xs ! I", "by (auto simp: nth_append)"], ["proof (state)\nthis:\n  concat (x # xs) ! i = concat xs ! I\n\ngoal (1 subgoal):\n 1. \\<not> i < length x \\<Longrightarrow>\n    \\<exists>j k.\n       j < length (x # xs) \\<and>\n       k < length ((x # xs) ! j) \\<and>\n       concat (x # xs) ! i = (x # xs) ! j ! k", "from Cons(1)[OF i(2)]"], ["proof (chain)\npicking this:\n  \\<exists>j k.\n     j < length xs \\<and>\n     k < length (xs ! j) \\<and> concat xs ! I = xs ! j ! k", "obtain j k where\n      IH: \"j < length xs \\<and> k < length (xs ! j) \\<and> concat xs ! I = xs ! j ! k\""], ["proof (prove)\nusing this:\n  \\<exists>j k.\n     j < length xs \\<and>\n     k < length (xs ! j) \\<and> concat xs ! I = xs ! j ! k\n\ngoal (1 subgoal):\n 1. (\\<And>j k.\n        j < length xs \\<and>\n        k < length (xs ! j) \\<and>\n        concat xs ! I = xs ! j ! k \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  j < length xs \\<and> k < length (xs ! j) \\<and> concat xs ! I = xs ! j ! k\n\ngoal (1 subgoal):\n 1. \\<not> i < length x \\<Longrightarrow>\n    \\<exists>j k.\n       j < length (x # xs) \\<and>\n       k < length ((x # xs) ! j) \\<and>\n       concat (x # xs) ! i = (x # xs) ! j ! k", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>j k.\n       j < length (x # xs) \\<and>\n       k < length ((x # xs) ! j) \\<and>\n       concat (x # xs) ! i = (x # xs) ! j ! k", "unfolding iI"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>j k.\n       j < length (x # xs) \\<and>\n       k < length ((x # xs) ! j) \\<and> concat xs ! I = (x # xs) ! j ! k", "by (rule exI[of _ \"Suc j\"], rule exI[of _ k], insert IH, auto)"], ["proof (state)\nthis:\n  \\<exists>j k.\n     j < length (x # xs) \\<and>\n     k < length ((x # xs) ! j) \\<and> concat (x # xs) ! i = (x # xs) ! j ! k\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>j k.\n     j < length (x # xs) \\<and>\n     k < length ((x # xs) ! j) \\<and> concat (x # xs) ! i = (x # xs) ! j ! k\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length (concat []) \\<Longrightarrow>\n       \\<exists>j k.\n          j < length [] \\<and>\n          k < length ([] ! j) \\<and> concat [] ! i = [] ! j ! k", "qed simp"], ["", "lemma nth_concat_diff: assumes \"i1 < length (concat xs)\" \"i2 < length (concat xs)\" \"i1 \\<noteq> i2\"\n  shows \"\\<exists> j1 k1 j2 k2. (j1,k1) \\<noteq> (j2,k2) \\<and> j1 < length xs \\<and> j2 < length xs\n    \\<and> k1 < length (xs ! j1) \\<and> k2 < length (xs ! j2) \n    \\<and> concat xs ! i1 = xs ! j1 ! k1 \\<and> concat xs ! i2 = xs ! j2 ! k2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>j1 k1 j2 k2.\n       (j1, k1) \\<noteq> (j2, k2) \\<and>\n       j1 < length xs \\<and>\n       j2 < length xs \\<and>\n       k1 < length (xs ! j1) \\<and>\n       k2 < length (xs ! j2) \\<and>\n       concat xs ! i1 = xs ! j1 ! k1 \\<and> concat xs ! i2 = xs ! j2 ! k2", "using assms"], ["proof (prove)\nusing this:\n  i1 < length (concat xs)\n  i2 < length (concat xs)\n  i1 \\<noteq> i2\n\ngoal (1 subgoal):\n 1. \\<exists>j1 k1 j2 k2.\n       (j1, k1) \\<noteq> (j2, k2) \\<and>\n       j1 < length xs \\<and>\n       j2 < length xs \\<and>\n       k1 < length (xs ! j1) \\<and>\n       k2 < length (xs ! j2) \\<and>\n       concat xs ! i1 = xs ! j1 ! k1 \\<and> concat xs ! i2 = xs ! j2 ! k2", "proof (induct xs arbitrary: i1 i2)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i1 i2.\n       \\<lbrakk>i1 < length (concat []); i2 < length (concat []);\n        i1 \\<noteq> i2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j1 k1 j2 k2.\n                            (j1, k1) \\<noteq> (j2, k2) \\<and>\n                            j1 < length [] \\<and>\n                            j2 < length [] \\<and>\n                            k1 < length ([] ! j1) \\<and>\n                            k2 < length ([] ! j2) \\<and>\n                            concat [] ! i1 = [] ! j1 ! k1 \\<and>\n                            concat [] ! i2 = [] ! j2 ! k2\n 2. \\<And>a xs i1 i2.\n       \\<lbrakk>\\<And>i1 i2.\n                   \\<lbrakk>i1 < length (concat xs);\n                    i2 < length (concat xs); i1 \\<noteq> i2\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>j1 k1 j2 k2.\n  (j1, k1) \\<noteq> (j2, k2) \\<and>\n  j1 < length xs \\<and>\n  j2 < length xs \\<and>\n  k1 < length (xs ! j1) \\<and>\n  k2 < length (xs ! j2) \\<and>\n  concat xs ! i1 = xs ! j1 ! k1 \\<and> concat xs ! i2 = xs ! j2 ! k2;\n        i1 < length (concat (a # xs)); i2 < length (concat (a # xs));\n        i1 \\<noteq> i2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j1 k1 j2 k2.\n                            (j1, k1) \\<noteq> (j2, k2) \\<and>\n                            j1 < length (a # xs) \\<and>\n                            j2 < length (a # xs) \\<and>\n                            k1 < length ((a # xs) ! j1) \\<and>\n                            k2 < length ((a # xs) ! j2) \\<and>\n                            concat (a # xs) ! i1 = (a # xs) ! j1 ! k1 \\<and>\n                            concat (a # xs) ! i2 = (a # xs) ! j2 ! k2", "case (Cons x xs)"], ["proof (state)\nthis:\n  \\<lbrakk>?i1.0 < length (concat xs); ?i2.0 < length (concat xs);\n   ?i1.0 \\<noteq> ?i2.0\\<rbrakk>\n  \\<Longrightarrow> \\<exists>j1 k1 j2 k2.\n                       (j1, k1) \\<noteq> (j2, k2) \\<and>\n                       j1 < length xs \\<and>\n                       j2 < length xs \\<and>\n                       k1 < length (xs ! j1) \\<and>\n                       k2 < length (xs ! j2) \\<and>\n                       concat xs ! ?i1.0 = xs ! j1 ! k1 \\<and>\n                       concat xs ! ?i2.0 = xs ! j2 ! k2\n  i1 < length (concat (x # xs))\n  i2 < length (concat (x # xs))\n  i1 \\<noteq> i2\n\ngoal (2 subgoals):\n 1. \\<And>i1 i2.\n       \\<lbrakk>i1 < length (concat []); i2 < length (concat []);\n        i1 \\<noteq> i2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j1 k1 j2 k2.\n                            (j1, k1) \\<noteq> (j2, k2) \\<and>\n                            j1 < length [] \\<and>\n                            j2 < length [] \\<and>\n                            k1 < length ([] ! j1) \\<and>\n                            k2 < length ([] ! j2) \\<and>\n                            concat [] ! i1 = [] ! j1 ! k1 \\<and>\n                            concat [] ! i2 = [] ! j2 ! k2\n 2. \\<And>a xs i1 i2.\n       \\<lbrakk>\\<And>i1 i2.\n                   \\<lbrakk>i1 < length (concat xs);\n                    i2 < length (concat xs); i1 \\<noteq> i2\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>j1 k1 j2 k2.\n  (j1, k1) \\<noteq> (j2, k2) \\<and>\n  j1 < length xs \\<and>\n  j2 < length xs \\<and>\n  k1 < length (xs ! j1) \\<and>\n  k2 < length (xs ! j2) \\<and>\n  concat xs ! i1 = xs ! j1 ! k1 \\<and> concat xs ! i2 = xs ! j2 ! k2;\n        i1 < length (concat (a # xs)); i2 < length (concat (a # xs));\n        i1 \\<noteq> i2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j1 k1 j2 k2.\n                            (j1, k1) \\<noteq> (j2, k2) \\<and>\n                            j1 < length (a # xs) \\<and>\n                            j2 < length (a # xs) \\<and>\n                            k1 < length ((a # xs) ! j1) \\<and>\n                            k2 < length ((a # xs) ! j2) \\<and>\n                            concat (a # xs) ! i1 = (a # xs) ! j1 ! k1 \\<and>\n                            concat (a # xs) ! i2 = (a # xs) ! j2 ! k2", "define I1 where \"I1 = i1 - length x\""], ["proof (state)\nthis:\n  I1 = i1 - length x\n\ngoal (2 subgoals):\n 1. \\<And>i1 i2.\n       \\<lbrakk>i1 < length (concat []); i2 < length (concat []);\n        i1 \\<noteq> i2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j1 k1 j2 k2.\n                            (j1, k1) \\<noteq> (j2, k2) \\<and>\n                            j1 < length [] \\<and>\n                            j2 < length [] \\<and>\n                            k1 < length ([] ! j1) \\<and>\n                            k2 < length ([] ! j2) \\<and>\n                            concat [] ! i1 = [] ! j1 ! k1 \\<and>\n                            concat [] ! i2 = [] ! j2 ! k2\n 2. \\<And>a xs i1 i2.\n       \\<lbrakk>\\<And>i1 i2.\n                   \\<lbrakk>i1 < length (concat xs);\n                    i2 < length (concat xs); i1 \\<noteq> i2\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>j1 k1 j2 k2.\n  (j1, k1) \\<noteq> (j2, k2) \\<and>\n  j1 < length xs \\<and>\n  j2 < length xs \\<and>\n  k1 < length (xs ! j1) \\<and>\n  k2 < length (xs ! j2) \\<and>\n  concat xs ! i1 = xs ! j1 ! k1 \\<and> concat xs ! i2 = xs ! j2 ! k2;\n        i1 < length (concat (a # xs)); i2 < length (concat (a # xs));\n        i1 \\<noteq> i2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j1 k1 j2 k2.\n                            (j1, k1) \\<noteq> (j2, k2) \\<and>\n                            j1 < length (a # xs) \\<and>\n                            j2 < length (a # xs) \\<and>\n                            k1 < length ((a # xs) ! j1) \\<and>\n                            k2 < length ((a # xs) ! j2) \\<and>\n                            concat (a # xs) ! i1 = (a # xs) ! j1 ! k1 \\<and>\n                            concat (a # xs) ! i2 = (a # xs) ! j2 ! k2", "define I2 where \"I2 = i2 - length x\""], ["proof (state)\nthis:\n  I2 = i2 - length x\n\ngoal (2 subgoals):\n 1. \\<And>i1 i2.\n       \\<lbrakk>i1 < length (concat []); i2 < length (concat []);\n        i1 \\<noteq> i2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j1 k1 j2 k2.\n                            (j1, k1) \\<noteq> (j2, k2) \\<and>\n                            j1 < length [] \\<and>\n                            j2 < length [] \\<and>\n                            k1 < length ([] ! j1) \\<and>\n                            k2 < length ([] ! j2) \\<and>\n                            concat [] ! i1 = [] ! j1 ! k1 \\<and>\n                            concat [] ! i2 = [] ! j2 ! k2\n 2. \\<And>a xs i1 i2.\n       \\<lbrakk>\\<And>i1 i2.\n                   \\<lbrakk>i1 < length (concat xs);\n                    i2 < length (concat xs); i1 \\<noteq> i2\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>j1 k1 j2 k2.\n  (j1, k1) \\<noteq> (j2, k2) \\<and>\n  j1 < length xs \\<and>\n  j2 < length xs \\<and>\n  k1 < length (xs ! j1) \\<and>\n  k2 < length (xs ! j2) \\<and>\n  concat xs ! i1 = xs ! j1 ! k1 \\<and> concat xs ! i2 = xs ! j2 ! k2;\n        i1 < length (concat (a # xs)); i2 < length (concat (a # xs));\n        i1 \\<noteq> i2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j1 k1 j2 k2.\n                            (j1, k1) \\<noteq> (j2, k2) \\<and>\n                            j1 < length (a # xs) \\<and>\n                            j2 < length (a # xs) \\<and>\n                            k1 < length ((a # xs) ! j1) \\<and>\n                            k2 < length ((a # xs) ! j2) \\<and>\n                            concat (a # xs) ! i1 = (a # xs) ! j1 ! k1 \\<and>\n                            concat (a # xs) ! i2 = (a # xs) ! j2 ! k2", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>j1 k1 j2 k2.\n       (j1, k1) \\<noteq> (j2, k2) \\<and>\n       j1 < length (x # xs) \\<and>\n       j2 < length (x # xs) \\<and>\n       k1 < length ((x # xs) ! j1) \\<and>\n       k2 < length ((x # xs) ! j2) \\<and>\n       concat (x # xs) ! i1 = (x # xs) ! j1 ! k1 \\<and>\n       concat (x # xs) ! i2 = (x # xs) ! j2 ! k2", "proof (cases \"i1 < length x\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i1 < length x \\<Longrightarrow>\n    \\<exists>j1 k1 j2 k2.\n       (j1, k1) \\<noteq> (j2, k2) \\<and>\n       j1 < length (x # xs) \\<and>\n       j2 < length (x # xs) \\<and>\n       k1 < length ((x # xs) ! j1) \\<and>\n       k2 < length ((x # xs) ! j2) \\<and>\n       concat (x # xs) ! i1 = (x # xs) ! j1 ! k1 \\<and>\n       concat (x # xs) ! i2 = (x # xs) ! j2 ! k2\n 2. \\<not> i1 < length x \\<Longrightarrow>\n    \\<exists>j1 k1 j2 k2.\n       (j1, k1) \\<noteq> (j2, k2) \\<and>\n       j1 < length (x # xs) \\<and>\n       j2 < length (x # xs) \\<and>\n       k1 < length ((x # xs) ! j1) \\<and>\n       k2 < length ((x # xs) ! j2) \\<and>\n       concat (x # xs) ! i1 = (x # xs) ! j1 ! k1 \\<and>\n       concat (x # xs) ! i2 = (x # xs) ! j2 ! k2", "case True"], ["proof (state)\nthis:\n  i1 < length x\n\ngoal (2 subgoals):\n 1. i1 < length x \\<Longrightarrow>\n    \\<exists>j1 k1 j2 k2.\n       (j1, k1) \\<noteq> (j2, k2) \\<and>\n       j1 < length (x # xs) \\<and>\n       j2 < length (x # xs) \\<and>\n       k1 < length ((x # xs) ! j1) \\<and>\n       k2 < length ((x # xs) ! j2) \\<and>\n       concat (x # xs) ! i1 = (x # xs) ! j1 ! k1 \\<and>\n       concat (x # xs) ! i2 = (x # xs) ! j2 ! k2\n 2. \\<not> i1 < length x \\<Longrightarrow>\n    \\<exists>j1 k1 j2 k2.\n       (j1, k1) \\<noteq> (j2, k2) \\<and>\n       j1 < length (x # xs) \\<and>\n       j2 < length (x # xs) \\<and>\n       k1 < length ((x # xs) ! j1) \\<and>\n       k2 < length ((x # xs) ! j2) \\<and>\n       concat (x # xs) ! i1 = (x # xs) ! j1 ! k1 \\<and>\n       concat (x # xs) ! i2 = (x # xs) ! j2 ! k2", "note l1 = this"], ["proof (state)\nthis:\n  i1 < length x\n\ngoal (2 subgoals):\n 1. i1 < length x \\<Longrightarrow>\n    \\<exists>j1 k1 j2 k2.\n       (j1, k1) \\<noteq> (j2, k2) \\<and>\n       j1 < length (x # xs) \\<and>\n       j2 < length (x # xs) \\<and>\n       k1 < length ((x # xs) ! j1) \\<and>\n       k2 < length ((x # xs) ! j2) \\<and>\n       concat (x # xs) ! i1 = (x # xs) ! j1 ! k1 \\<and>\n       concat (x # xs) ! i2 = (x # xs) ! j2 ! k2\n 2. \\<not> i1 < length x \\<Longrightarrow>\n    \\<exists>j1 k1 j2 k2.\n       (j1, k1) \\<noteq> (j2, k2) \\<and>\n       j1 < length (x # xs) \\<and>\n       j2 < length (x # xs) \\<and>\n       k1 < length ((x # xs) ! j1) \\<and>\n       k2 < length ((x # xs) ! j2) \\<and>\n       concat (x # xs) ! i1 = (x # xs) ! j1 ! k1 \\<and>\n       concat (x # xs) ! i2 = (x # xs) ! j2 ! k2", "hence i1: \"concat (Cons x xs) ! i1 = x ! i1\""], ["proof (prove)\nusing this:\n  i1 < length x\n\ngoal (1 subgoal):\n 1. concat (x # xs) ! i1 = x ! i1", "by (auto simp: nth_append)"], ["proof (state)\nthis:\n  concat (x # xs) ! i1 = x ! i1\n\ngoal (2 subgoals):\n 1. i1 < length x \\<Longrightarrow>\n    \\<exists>j1 k1 j2 k2.\n       (j1, k1) \\<noteq> (j2, k2) \\<and>\n       j1 < length (x # xs) \\<and>\n       j2 < length (x # xs) \\<and>\n       k1 < length ((x # xs) ! j1) \\<and>\n       k2 < length ((x # xs) ! j2) \\<and>\n       concat (x # xs) ! i1 = (x # xs) ! j1 ! k1 \\<and>\n       concat (x # xs) ! i2 = (x # xs) ! j2 ! k2\n 2. \\<not> i1 < length x \\<Longrightarrow>\n    \\<exists>j1 k1 j2 k2.\n       (j1, k1) \\<noteq> (j2, k2) \\<and>\n       j1 < length (x # xs) \\<and>\n       j2 < length (x # xs) \\<and>\n       k1 < length ((x # xs) ! j1) \\<and>\n       k2 < length ((x # xs) ! j2) \\<and>\n       concat (x # xs) ! i1 = (x # xs) ! j1 ! k1 \\<and>\n       concat (x # xs) ! i2 = (x # xs) ! j2 ! k2", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>j1 k1 j2 k2.\n       (j1, k1) \\<noteq> (j2, k2) \\<and>\n       j1 < length (x # xs) \\<and>\n       j2 < length (x # xs) \\<and>\n       k1 < length ((x # xs) ! j1) \\<and>\n       k2 < length ((x # xs) ! j2) \\<and>\n       concat (x # xs) ! i1 = (x # xs) ! j1 ! k1 \\<and>\n       concat (x # xs) ! i2 = (x # xs) ! j2 ! k2", "proof (cases \"i2 < length x\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i2 < length x \\<Longrightarrow>\n    \\<exists>j1 k1 j2 k2.\n       (j1, k1) \\<noteq> (j2, k2) \\<and>\n       j1 < length (x # xs) \\<and>\n       j2 < length (x # xs) \\<and>\n       k1 < length ((x # xs) ! j1) \\<and>\n       k2 < length ((x # xs) ! j2) \\<and>\n       concat (x # xs) ! i1 = (x # xs) ! j1 ! k1 \\<and>\n       concat (x # xs) ! i2 = (x # xs) ! j2 ! k2\n 2. \\<not> i2 < length x \\<Longrightarrow>\n    \\<exists>j1 k1 j2 k2.\n       (j1, k1) \\<noteq> (j2, k2) \\<and>\n       j1 < length (x # xs) \\<and>\n       j2 < length (x # xs) \\<and>\n       k1 < length ((x # xs) ! j1) \\<and>\n       k2 < length ((x # xs) ! j2) \\<and>\n       concat (x # xs) ! i1 = (x # xs) ! j1 ! k1 \\<and>\n       concat (x # xs) ! i2 = (x # xs) ! j2 ! k2", "case True"], ["proof (state)\nthis:\n  i2 < length x\n\ngoal (2 subgoals):\n 1. i2 < length x \\<Longrightarrow>\n    \\<exists>j1 k1 j2 k2.\n       (j1, k1) \\<noteq> (j2, k2) \\<and>\n       j1 < length (x # xs) \\<and>\n       j2 < length (x # xs) \\<and>\n       k1 < length ((x # xs) ! j1) \\<and>\n       k2 < length ((x # xs) ! j2) \\<and>\n       concat (x # xs) ! i1 = (x # xs) ! j1 ! k1 \\<and>\n       concat (x # xs) ! i2 = (x # xs) ! j2 ! k2\n 2. \\<not> i2 < length x \\<Longrightarrow>\n    \\<exists>j1 k1 j2 k2.\n       (j1, k1) \\<noteq> (j2, k2) \\<and>\n       j1 < length (x # xs) \\<and>\n       j2 < length (x # xs) \\<and>\n       k1 < length ((x # xs) ! j1) \\<and>\n       k2 < length ((x # xs) ! j2) \\<and>\n       concat (x # xs) ! i1 = (x # xs) ! j1 ! k1 \\<and>\n       concat (x # xs) ! i2 = (x # xs) ! j2 ! k2", "note l2 = this"], ["proof (state)\nthis:\n  i2 < length x\n\ngoal (2 subgoals):\n 1. i2 < length x \\<Longrightarrow>\n    \\<exists>j1 k1 j2 k2.\n       (j1, k1) \\<noteq> (j2, k2) \\<and>\n       j1 < length (x # xs) \\<and>\n       j2 < length (x # xs) \\<and>\n       k1 < length ((x # xs) ! j1) \\<and>\n       k2 < length ((x # xs) ! j2) \\<and>\n       concat (x # xs) ! i1 = (x # xs) ! j1 ! k1 \\<and>\n       concat (x # xs) ! i2 = (x # xs) ! j2 ! k2\n 2. \\<not> i2 < length x \\<Longrightarrow>\n    \\<exists>j1 k1 j2 k2.\n       (j1, k1) \\<noteq> (j2, k2) \\<and>\n       j1 < length (x # xs) \\<and>\n       j2 < length (x # xs) \\<and>\n       k1 < length ((x # xs) ! j1) \\<and>\n       k2 < length ((x # xs) ! j2) \\<and>\n       concat (x # xs) ! i1 = (x # xs) ! j1 ! k1 \\<and>\n       concat (x # xs) ! i2 = (x # xs) ! j2 ! k2", "hence i2: \"concat (Cons x xs) ! i2 = x ! i2\""], ["proof (prove)\nusing this:\n  i2 < length x\n\ngoal (1 subgoal):\n 1. concat (x # xs) ! i2 = x ! i2", "by (auto simp: nth_append)"], ["proof (state)\nthis:\n  concat (x # xs) ! i2 = x ! i2\n\ngoal (2 subgoals):\n 1. i2 < length x \\<Longrightarrow>\n    \\<exists>j1 k1 j2 k2.\n       (j1, k1) \\<noteq> (j2, k2) \\<and>\n       j1 < length (x # xs) \\<and>\n       j2 < length (x # xs) \\<and>\n       k1 < length ((x # xs) ! j1) \\<and>\n       k2 < length ((x # xs) ! j2) \\<and>\n       concat (x # xs) ! i1 = (x # xs) ! j1 ! k1 \\<and>\n       concat (x # xs) ! i2 = (x # xs) ! j2 ! k2\n 2. \\<not> i2 < length x \\<Longrightarrow>\n    \\<exists>j1 k1 j2 k2.\n       (j1, k1) \\<noteq> (j2, k2) \\<and>\n       j1 < length (x # xs) \\<and>\n       j2 < length (x # xs) \\<and>\n       k1 < length ((x # xs) ! j1) \\<and>\n       k2 < length ((x # xs) ! j2) \\<and>\n       concat (x # xs) ! i1 = (x # xs) ! j1 ! k1 \\<and>\n       concat (x # xs) ! i2 = (x # xs) ! j2 ! k2", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>j1 k1 j2 k2.\n       (j1, k1) \\<noteq> (j2, k2) \\<and>\n       j1 < length (x # xs) \\<and>\n       j2 < length (x # xs) \\<and>\n       k1 < length ((x # xs) ! j1) \\<and>\n       k2 < length ((x # xs) ! j2) \\<and>\n       concat (x # xs) ! i1 = (x # xs) ! j1 ! k1 \\<and>\n       concat (x # xs) ! i2 = (x # xs) ! j2 ! k2", "unfolding i1 i2"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>j1 k1 j2 k2.\n       (j1, k1) \\<noteq> (j2, k2) \\<and>\n       j1 < length (x # xs) \\<and>\n       j2 < length (x # xs) \\<and>\n       k1 < length ((x # xs) ! j1) \\<and>\n       k2 < length ((x # xs) ! j2) \\<and>\n       x ! i1 = (x # xs) ! j1 ! k1 \\<and> x ! i2 = (x # xs) ! j2 ! k2", "by (rule exI[of _ 0], rule exI[of _ i1], rule exI[of _ 0], rule exI[of _ i2], \n         insert Cons(4) l1 l2, auto)"], ["proof (state)\nthis:\n  \\<exists>j1 k1 j2 k2.\n     (j1, k1) \\<noteq> (j2, k2) \\<and>\n     j1 < length (x # xs) \\<and>\n     j2 < length (x # xs) \\<and>\n     k1 < length ((x # xs) ! j1) \\<and>\n     k2 < length ((x # xs) ! j2) \\<and>\n     concat (x # xs) ! i1 = (x # xs) ! j1 ! k1 \\<and>\n     concat (x # xs) ! i2 = (x # xs) ! j2 ! k2\n\ngoal (1 subgoal):\n 1. \\<not> i2 < length x \\<Longrightarrow>\n    \\<exists>j1 k1 j2 k2.\n       (j1, k1) \\<noteq> (j2, k2) \\<and>\n       j1 < length (x # xs) \\<and>\n       j2 < length (x # xs) \\<and>\n       k1 < length ((x # xs) ! j1) \\<and>\n       k2 < length ((x # xs) ! j2) \\<and>\n       concat (x # xs) ! i1 = (x # xs) ! j1 ! k1 \\<and>\n       concat (x # xs) ! i2 = (x # xs) ! j2 ! k2", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> i2 < length x \\<Longrightarrow>\n    \\<exists>j1 k1 j2 k2.\n       (j1, k1) \\<noteq> (j2, k2) \\<and>\n       j1 < length (x # xs) \\<and>\n       j2 < length (x # xs) \\<and>\n       k1 < length ((x # xs) ! j1) \\<and>\n       k2 < length ((x # xs) ! j2) \\<and>\n       concat (x # xs) ! i1 = (x # xs) ! j1 ! k1 \\<and>\n       concat (x # xs) ! i2 = (x # xs) ! j2 ! k2", "case False"], ["proof (state)\nthis:\n  \\<not> i2 < length x\n\ngoal (1 subgoal):\n 1. \\<not> i2 < length x \\<Longrightarrow>\n    \\<exists>j1 k1 j2 k2.\n       (j1, k1) \\<noteq> (j2, k2) \\<and>\n       j1 < length (x # xs) \\<and>\n       j2 < length (x # xs) \\<and>\n       k1 < length ((x # xs) ! j1) \\<and>\n       k2 < length ((x # xs) ! j2) \\<and>\n       concat (x # xs) ! i1 = (x # xs) ! j1 ! k1 \\<and>\n       concat (x # xs) ! i2 = (x # xs) ! j2 ! k2", "note l2 = this"], ["proof (state)\nthis:\n  \\<not> i2 < length x\n\ngoal (1 subgoal):\n 1. \\<not> i2 < length x \\<Longrightarrow>\n    \\<exists>j1 k1 j2 k2.\n       (j1, k1) \\<noteq> (j2, k2) \\<and>\n       j1 < length (x # xs) \\<and>\n       j2 < length (x # xs) \\<and>\n       k1 < length ((x # xs) ! j1) \\<and>\n       k2 < length ((x # xs) ! j2) \\<and>\n       concat (x # xs) ! i1 = (x # xs) ! j1 ! k1 \\<and>\n       concat (x # xs) ! i2 = (x # xs) ! j2 ! k2", "from l2 Cons(3)"], ["proof (chain)\npicking this:\n  \\<not> i2 < length x\n  i2 < length (concat (x # xs))", "have i22: \"i2 = length x + I2\" \"I2 < length (concat xs)\""], ["proof (prove)\nusing this:\n  \\<not> i2 < length x\n  i2 < length (concat (x # xs))\n\ngoal (1 subgoal):\n 1. i2 = length x + I2 &&& I2 < length (concat xs)", "unfolding I2_def"], ["proof (prove)\nusing this:\n  \\<not> i2 < length x\n  i2 < length (concat (x # xs))\n\ngoal (1 subgoal):\n 1. i2 = length x + (i2 - length x) &&& i2 - length x < length (concat xs)", "by auto"], ["proof (state)\nthis:\n  i2 = length x + I2\n  I2 < length (concat xs)\n\ngoal (1 subgoal):\n 1. \\<not> i2 < length x \\<Longrightarrow>\n    \\<exists>j1 k1 j2 k2.\n       (j1, k1) \\<noteq> (j2, k2) \\<and>\n       j1 < length (x # xs) \\<and>\n       j2 < length (x # xs) \\<and>\n       k1 < length ((x # xs) ! j1) \\<and>\n       k2 < length ((x # xs) ! j2) \\<and>\n       concat (x # xs) ! i1 = (x # xs) ! j1 ! k1 \\<and>\n       concat (x # xs) ! i2 = (x # xs) ! j2 ! k2", "hence i2: \"concat (Cons x xs) ! i2 = concat xs ! I2\""], ["proof (prove)\nusing this:\n  i2 = length x + I2\n  I2 < length (concat xs)\n\ngoal (1 subgoal):\n 1. concat (x # xs) ! i2 = concat xs ! I2", "by (auto simp: nth_append)"], ["proof (state)\nthis:\n  concat (x # xs) ! i2 = concat xs ! I2\n\ngoal (1 subgoal):\n 1. \\<not> i2 < length x \\<Longrightarrow>\n    \\<exists>j1 k1 j2 k2.\n       (j1, k1) \\<noteq> (j2, k2) \\<and>\n       j1 < length (x # xs) \\<and>\n       j2 < length (x # xs) \\<and>\n       k1 < length ((x # xs) ! j1) \\<and>\n       k2 < length ((x # xs) ! j2) \\<and>\n       concat (x # xs) ! i1 = (x # xs) ! j1 ! k1 \\<and>\n       concat (x # xs) ! i2 = (x # xs) ! j2 ! k2", "from nth_concat_split[OF i22(2)]"], ["proof (chain)\npicking this:\n  \\<exists>j k.\n     j < length xs \\<and>\n     k < length (xs ! j) \\<and> concat xs ! I2 = xs ! j ! k", "obtain j2 k2 where\n        *: \"j2 < length xs \\<and> k2 < length (xs ! j2) \\<and> concat xs ! I2 = xs ! j2 ! k2\""], ["proof (prove)\nusing this:\n  \\<exists>j k.\n     j < length xs \\<and>\n     k < length (xs ! j) \\<and> concat xs ! I2 = xs ! j ! k\n\ngoal (1 subgoal):\n 1. (\\<And>j2 k2.\n        j2 < length xs \\<and>\n        k2 < length (xs ! j2) \\<and>\n        concat xs ! I2 = xs ! j2 ! k2 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  j2 < length xs \\<and>\n  k2 < length (xs ! j2) \\<and> concat xs ! I2 = xs ! j2 ! k2\n\ngoal (1 subgoal):\n 1. \\<not> i2 < length x \\<Longrightarrow>\n    \\<exists>j1 k1 j2 k2.\n       (j1, k1) \\<noteq> (j2, k2) \\<and>\n       j1 < length (x # xs) \\<and>\n       j2 < length (x # xs) \\<and>\n       k1 < length ((x # xs) ! j1) \\<and>\n       k2 < length ((x # xs) ! j2) \\<and>\n       concat (x # xs) ! i1 = (x # xs) ! j1 ! k1 \\<and>\n       concat (x # xs) ! i2 = (x # xs) ! j2 ! k2", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>j1 k1 j2 k2.\n       (j1, k1) \\<noteq> (j2, k2) \\<and>\n       j1 < length (x # xs) \\<and>\n       j2 < length (x # xs) \\<and>\n       k1 < length ((x # xs) ! j1) \\<and>\n       k2 < length ((x # xs) ! j2) \\<and>\n       concat (x # xs) ! i1 = (x # xs) ! j1 ! k1 \\<and>\n       concat (x # xs) ! i2 = (x # xs) ! j2 ! k2", "unfolding i1 i2"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>j1 k1 j2 k2.\n       (j1, k1) \\<noteq> (j2, k2) \\<and>\n       j1 < length (x # xs) \\<and>\n       j2 < length (x # xs) \\<and>\n       k1 < length ((x # xs) ! j1) \\<and>\n       k2 < length ((x # xs) ! j2) \\<and>\n       x ! i1 = (x # xs) ! j1 ! k1 \\<and>\n       concat xs ! I2 = (x # xs) ! j2 ! k2", "by (rule exI[of _ 0], rule exI[of _ i1], rule exI[of _ \"Suc j2\"], rule exI[of _ k2],\n         insert * l1, auto)"], ["proof (state)\nthis:\n  \\<exists>j1 k1 j2 k2.\n     (j1, k1) \\<noteq> (j2, k2) \\<and>\n     j1 < length (x # xs) \\<and>\n     j2 < length (x # xs) \\<and>\n     k1 < length ((x # xs) ! j1) \\<and>\n     k2 < length ((x # xs) ! j2) \\<and>\n     concat (x # xs) ! i1 = (x # xs) ! j1 ! k1 \\<and>\n     concat (x # xs) ! i2 = (x # xs) ! j2 ! k2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>j1 k1 j2 k2.\n     (j1, k1) \\<noteq> (j2, k2) \\<and>\n     j1 < length (x # xs) \\<and>\n     j2 < length (x # xs) \\<and>\n     k1 < length ((x # xs) ! j1) \\<and>\n     k2 < length ((x # xs) ! j2) \\<and>\n     concat (x # xs) ! i1 = (x # xs) ! j1 ! k1 \\<and>\n     concat (x # xs) ! i2 = (x # xs) ! j2 ! k2\n\ngoal (1 subgoal):\n 1. \\<not> i1 < length x \\<Longrightarrow>\n    \\<exists>j1 k1 j2 k2.\n       (j1, k1) \\<noteq> (j2, k2) \\<and>\n       j1 < length (x # xs) \\<and>\n       j2 < length (x # xs) \\<and>\n       k1 < length ((x # xs) ! j1) \\<and>\n       k2 < length ((x # xs) ! j2) \\<and>\n       concat (x # xs) ! i1 = (x # xs) ! j1 ! k1 \\<and>\n       concat (x # xs) ! i2 = (x # xs) ! j2 ! k2", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> i1 < length x \\<Longrightarrow>\n    \\<exists>j1 k1 j2 k2.\n       (j1, k1) \\<noteq> (j2, k2) \\<and>\n       j1 < length (x # xs) \\<and>\n       j2 < length (x # xs) \\<and>\n       k1 < length ((x # xs) ! j1) \\<and>\n       k2 < length ((x # xs) ! j2) \\<and>\n       concat (x # xs) ! i1 = (x # xs) ! j1 ! k1 \\<and>\n       concat (x # xs) ! i2 = (x # xs) ! j2 ! k2", "case False"], ["proof (state)\nthis:\n  \\<not> i1 < length x\n\ngoal (1 subgoal):\n 1. \\<not> i1 < length x \\<Longrightarrow>\n    \\<exists>j1 k1 j2 k2.\n       (j1, k1) \\<noteq> (j2, k2) \\<and>\n       j1 < length (x # xs) \\<and>\n       j2 < length (x # xs) \\<and>\n       k1 < length ((x # xs) ! j1) \\<and>\n       k2 < length ((x # xs) ! j2) \\<and>\n       concat (x # xs) ! i1 = (x # xs) ! j1 ! k1 \\<and>\n       concat (x # xs) ! i2 = (x # xs) ! j2 ! k2", "note l1 = this"], ["proof (state)\nthis:\n  \\<not> i1 < length x\n\ngoal (1 subgoal):\n 1. \\<not> i1 < length x \\<Longrightarrow>\n    \\<exists>j1 k1 j2 k2.\n       (j1, k1) \\<noteq> (j2, k2) \\<and>\n       j1 < length (x # xs) \\<and>\n       j2 < length (x # xs) \\<and>\n       k1 < length ((x # xs) ! j1) \\<and>\n       k2 < length ((x # xs) ! j2) \\<and>\n       concat (x # xs) ! i1 = (x # xs) ! j1 ! k1 \\<and>\n       concat (x # xs) ! i2 = (x # xs) ! j2 ! k2", "from l1 Cons(2)"], ["proof (chain)\npicking this:\n  \\<not> i1 < length x\n  i1 < length (concat (x # xs))", "have i11: \"i1 = length x + I1\" \"I1 < length (concat xs)\""], ["proof (prove)\nusing this:\n  \\<not> i1 < length x\n  i1 < length (concat (x # xs))\n\ngoal (1 subgoal):\n 1. i1 = length x + I1 &&& I1 < length (concat xs)", "unfolding I1_def"], ["proof (prove)\nusing this:\n  \\<not> i1 < length x\n  i1 < length (concat (x # xs))\n\ngoal (1 subgoal):\n 1. i1 = length x + (i1 - length x) &&& i1 - length x < length (concat xs)", "by auto"], ["proof (state)\nthis:\n  i1 = length x + I1\n  I1 < length (concat xs)\n\ngoal (1 subgoal):\n 1. \\<not> i1 < length x \\<Longrightarrow>\n    \\<exists>j1 k1 j2 k2.\n       (j1, k1) \\<noteq> (j2, k2) \\<and>\n       j1 < length (x # xs) \\<and>\n       j2 < length (x # xs) \\<and>\n       k1 < length ((x # xs) ! j1) \\<and>\n       k2 < length ((x # xs) ! j2) \\<and>\n       concat (x # xs) ! i1 = (x # xs) ! j1 ! k1 \\<and>\n       concat (x # xs) ! i2 = (x # xs) ! j2 ! k2", "hence i1: \"concat (Cons x xs) ! i1 = concat xs ! I1\""], ["proof (prove)\nusing this:\n  i1 = length x + I1\n  I1 < length (concat xs)\n\ngoal (1 subgoal):\n 1. concat (x # xs) ! i1 = concat xs ! I1", "by (auto simp: nth_append)"], ["proof (state)\nthis:\n  concat (x # xs) ! i1 = concat xs ! I1\n\ngoal (1 subgoal):\n 1. \\<not> i1 < length x \\<Longrightarrow>\n    \\<exists>j1 k1 j2 k2.\n       (j1, k1) \\<noteq> (j2, k2) \\<and>\n       j1 < length (x # xs) \\<and>\n       j2 < length (x # xs) \\<and>\n       k1 < length ((x # xs) ! j1) \\<and>\n       k2 < length ((x # xs) ! j2) \\<and>\n       concat (x # xs) ! i1 = (x # xs) ! j1 ! k1 \\<and>\n       concat (x # xs) ! i2 = (x # xs) ! j2 ! k2", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>j1 k1 j2 k2.\n       (j1, k1) \\<noteq> (j2, k2) \\<and>\n       j1 < length (x # xs) \\<and>\n       j2 < length (x # xs) \\<and>\n       k1 < length ((x # xs) ! j1) \\<and>\n       k2 < length ((x # xs) ! j2) \\<and>\n       concat (x # xs) ! i1 = (x # xs) ! j1 ! k1 \\<and>\n       concat (x # xs) ! i2 = (x # xs) ! j2 ! k2", "proof (cases \"i2 < length x\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i2 < length x \\<Longrightarrow>\n    \\<exists>j1 k1 j2 k2.\n       (j1, k1) \\<noteq> (j2, k2) \\<and>\n       j1 < length (x # xs) \\<and>\n       j2 < length (x # xs) \\<and>\n       k1 < length ((x # xs) ! j1) \\<and>\n       k2 < length ((x # xs) ! j2) \\<and>\n       concat (x # xs) ! i1 = (x # xs) ! j1 ! k1 \\<and>\n       concat (x # xs) ! i2 = (x # xs) ! j2 ! k2\n 2. \\<not> i2 < length x \\<Longrightarrow>\n    \\<exists>j1 k1 j2 k2.\n       (j1, k1) \\<noteq> (j2, k2) \\<and>\n       j1 < length (x # xs) \\<and>\n       j2 < length (x # xs) \\<and>\n       k1 < length ((x # xs) ! j1) \\<and>\n       k2 < length ((x # xs) ! j2) \\<and>\n       concat (x # xs) ! i1 = (x # xs) ! j1 ! k1 \\<and>\n       concat (x # xs) ! i2 = (x # xs) ! j2 ! k2", "case False"], ["proof (state)\nthis:\n  \\<not> i2 < length x\n\ngoal (2 subgoals):\n 1. i2 < length x \\<Longrightarrow>\n    \\<exists>j1 k1 j2 k2.\n       (j1, k1) \\<noteq> (j2, k2) \\<and>\n       j1 < length (x # xs) \\<and>\n       j2 < length (x # xs) \\<and>\n       k1 < length ((x # xs) ! j1) \\<and>\n       k2 < length ((x # xs) ! j2) \\<and>\n       concat (x # xs) ! i1 = (x # xs) ! j1 ! k1 \\<and>\n       concat (x # xs) ! i2 = (x # xs) ! j2 ! k2\n 2. \\<not> i2 < length x \\<Longrightarrow>\n    \\<exists>j1 k1 j2 k2.\n       (j1, k1) \\<noteq> (j2, k2) \\<and>\n       j1 < length (x # xs) \\<and>\n       j2 < length (x # xs) \\<and>\n       k1 < length ((x # xs) ! j1) \\<and>\n       k2 < length ((x # xs) ! j2) \\<and>\n       concat (x # xs) ! i1 = (x # xs) ! j1 ! k1 \\<and>\n       concat (x # xs) ! i2 = (x # xs) ! j2 ! k2", "note l2 = this"], ["proof (state)\nthis:\n  \\<not> i2 < length x\n\ngoal (2 subgoals):\n 1. i2 < length x \\<Longrightarrow>\n    \\<exists>j1 k1 j2 k2.\n       (j1, k1) \\<noteq> (j2, k2) \\<and>\n       j1 < length (x # xs) \\<and>\n       j2 < length (x # xs) \\<and>\n       k1 < length ((x # xs) ! j1) \\<and>\n       k2 < length ((x # xs) ! j2) \\<and>\n       concat (x # xs) ! i1 = (x # xs) ! j1 ! k1 \\<and>\n       concat (x # xs) ! i2 = (x # xs) ! j2 ! k2\n 2. \\<not> i2 < length x \\<Longrightarrow>\n    \\<exists>j1 k1 j2 k2.\n       (j1, k1) \\<noteq> (j2, k2) \\<and>\n       j1 < length (x # xs) \\<and>\n       j2 < length (x # xs) \\<and>\n       k1 < length ((x # xs) ! j1) \\<and>\n       k2 < length ((x # xs) ! j2) \\<and>\n       concat (x # xs) ! i1 = (x # xs) ! j1 ! k1 \\<and>\n       concat (x # xs) ! i2 = (x # xs) ! j2 ! k2", "from l2 Cons(3)"], ["proof (chain)\npicking this:\n  \\<not> i2 < length x\n  i2 < length (concat (x # xs))", "have i22: \"i2 = length x + I2\" \"I2 < length (concat xs)\""], ["proof (prove)\nusing this:\n  \\<not> i2 < length x\n  i2 < length (concat (x # xs))\n\ngoal (1 subgoal):\n 1. i2 = length x + I2 &&& I2 < length (concat xs)", "unfolding I2_def"], ["proof (prove)\nusing this:\n  \\<not> i2 < length x\n  i2 < length (concat (x # xs))\n\ngoal (1 subgoal):\n 1. i2 = length x + (i2 - length x) &&& i2 - length x < length (concat xs)", "by auto"], ["proof (state)\nthis:\n  i2 = length x + I2\n  I2 < length (concat xs)\n\ngoal (2 subgoals):\n 1. i2 < length x \\<Longrightarrow>\n    \\<exists>j1 k1 j2 k2.\n       (j1, k1) \\<noteq> (j2, k2) \\<and>\n       j1 < length (x # xs) \\<and>\n       j2 < length (x # xs) \\<and>\n       k1 < length ((x # xs) ! j1) \\<and>\n       k2 < length ((x # xs) ! j2) \\<and>\n       concat (x # xs) ! i1 = (x # xs) ! j1 ! k1 \\<and>\n       concat (x # xs) ! i2 = (x # xs) ! j2 ! k2\n 2. \\<not> i2 < length x \\<Longrightarrow>\n    \\<exists>j1 k1 j2 k2.\n       (j1, k1) \\<noteq> (j2, k2) \\<and>\n       j1 < length (x # xs) \\<and>\n       j2 < length (x # xs) \\<and>\n       k1 < length ((x # xs) ! j1) \\<and>\n       k2 < length ((x # xs) ! j2) \\<and>\n       concat (x # xs) ! i1 = (x # xs) ! j1 ! k1 \\<and>\n       concat (x # xs) ! i2 = (x # xs) ! j2 ! k2", "hence i2: \"concat (Cons x xs) ! i2 = concat xs ! I2\""], ["proof (prove)\nusing this:\n  i2 = length x + I2\n  I2 < length (concat xs)\n\ngoal (1 subgoal):\n 1. concat (x # xs) ! i2 = concat xs ! I2", "by (auto simp: nth_append)"], ["proof (state)\nthis:\n  concat (x # xs) ! i2 = concat xs ! I2\n\ngoal (2 subgoals):\n 1. i2 < length x \\<Longrightarrow>\n    \\<exists>j1 k1 j2 k2.\n       (j1, k1) \\<noteq> (j2, k2) \\<and>\n       j1 < length (x # xs) \\<and>\n       j2 < length (x # xs) \\<and>\n       k1 < length ((x # xs) ! j1) \\<and>\n       k2 < length ((x # xs) ! j2) \\<and>\n       concat (x # xs) ! i1 = (x # xs) ! j1 ! k1 \\<and>\n       concat (x # xs) ! i2 = (x # xs) ! j2 ! k2\n 2. \\<not> i2 < length x \\<Longrightarrow>\n    \\<exists>j1 k1 j2 k2.\n       (j1, k1) \\<noteq> (j2, k2) \\<and>\n       j1 < length (x # xs) \\<and>\n       j2 < length (x # xs) \\<and>\n       k1 < length ((x # xs) ! j1) \\<and>\n       k2 < length ((x # xs) ! j2) \\<and>\n       concat (x # xs) ! i1 = (x # xs) ! j1 ! k1 \\<and>\n       concat (x # xs) ! i2 = (x # xs) ! j2 ! k2", "from Cons(4) i11 i22"], ["proof (chain)\npicking this:\n  i1 \\<noteq> i2\n  i1 = length x + I1\n  I1 < length (concat xs)\n  i2 = length x + I2\n  I2 < length (concat xs)", "have diff: \"I1 \\<noteq> I2\""], ["proof (prove)\nusing this:\n  i1 \\<noteq> i2\n  i1 = length x + I1\n  I1 < length (concat xs)\n  i2 = length x + I2\n  I2 < length (concat xs)\n\ngoal (1 subgoal):\n 1. I1 \\<noteq> I2", "by auto"], ["proof (state)\nthis:\n  I1 \\<noteq> I2\n\ngoal (2 subgoals):\n 1. i2 < length x \\<Longrightarrow>\n    \\<exists>j1 k1 j2 k2.\n       (j1, k1) \\<noteq> (j2, k2) \\<and>\n       j1 < length (x # xs) \\<and>\n       j2 < length (x # xs) \\<and>\n       k1 < length ((x # xs) ! j1) \\<and>\n       k2 < length ((x # xs) ! j2) \\<and>\n       concat (x # xs) ! i1 = (x # xs) ! j1 ! k1 \\<and>\n       concat (x # xs) ! i2 = (x # xs) ! j2 ! k2\n 2. \\<not> i2 < length x \\<Longrightarrow>\n    \\<exists>j1 k1 j2 k2.\n       (j1, k1) \\<noteq> (j2, k2) \\<and>\n       j1 < length (x # xs) \\<and>\n       j2 < length (x # xs) \\<and>\n       k1 < length ((x # xs) ! j1) \\<and>\n       k2 < length ((x # xs) ! j2) \\<and>\n       concat (x # xs) ! i1 = (x # xs) ! j1 ! k1 \\<and>\n       concat (x # xs) ! i2 = (x # xs) ! j2 ! k2", "from Cons(1)[OF i11(2) i22(2) diff]"], ["proof (chain)\npicking this:\n  \\<exists>j1 k1 j2 k2.\n     (j1, k1) \\<noteq> (j2, k2) \\<and>\n     j1 < length xs \\<and>\n     j2 < length xs \\<and>\n     k1 < length (xs ! j1) \\<and>\n     k2 < length (xs ! j2) \\<and>\n     concat xs ! I1 = xs ! j1 ! k1 \\<and> concat xs ! I2 = xs ! j2 ! k2", "obtain j1 k1 j2 k2\n        where IH: \"(j1,k1) \\<noteq> (j2,k2) \\<and> j1 < length xs \\<and> j2 < length xs\n        \\<and> k1 < length (xs ! j1) \\<and> k2 < length (xs ! j2) \n        \\<and> concat xs ! I1 = xs ! j1 ! k1 \\<and> concat xs ! I2 = xs ! j2 ! k2\""], ["proof (prove)\nusing this:\n  \\<exists>j1 k1 j2 k2.\n     (j1, k1) \\<noteq> (j2, k2) \\<and>\n     j1 < length xs \\<and>\n     j2 < length xs \\<and>\n     k1 < length (xs ! j1) \\<and>\n     k2 < length (xs ! j2) \\<and>\n     concat xs ! I1 = xs ! j1 ! k1 \\<and> concat xs ! I2 = xs ! j2 ! k2\n\ngoal (1 subgoal):\n 1. (\\<And>j1 k1 j2 k2.\n        (j1, k1) \\<noteq> (j2, k2) \\<and>\n        j1 < length xs \\<and>\n        j2 < length xs \\<and>\n        k1 < length (xs ! j1) \\<and>\n        k2 < length (xs ! j2) \\<and>\n        concat xs ! I1 = xs ! j1 ! k1 \\<and>\n        concat xs ! I2 = xs ! j2 ! k2 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  (j1, k1) \\<noteq> (j2, k2) \\<and>\n  j1 < length xs \\<and>\n  j2 < length xs \\<and>\n  k1 < length (xs ! j1) \\<and>\n  k2 < length (xs ! j2) \\<and>\n  concat xs ! I1 = xs ! j1 ! k1 \\<and> concat xs ! I2 = xs ! j2 ! k2\n\ngoal (2 subgoals):\n 1. i2 < length x \\<Longrightarrow>\n    \\<exists>j1 k1 j2 k2.\n       (j1, k1) \\<noteq> (j2, k2) \\<and>\n       j1 < length (x # xs) \\<and>\n       j2 < length (x # xs) \\<and>\n       k1 < length ((x # xs) ! j1) \\<and>\n       k2 < length ((x # xs) ! j2) \\<and>\n       concat (x # xs) ! i1 = (x # xs) ! j1 ! k1 \\<and>\n       concat (x # xs) ! i2 = (x # xs) ! j2 ! k2\n 2. \\<not> i2 < length x \\<Longrightarrow>\n    \\<exists>j1 k1 j2 k2.\n       (j1, k1) \\<noteq> (j2, k2) \\<and>\n       j1 < length (x # xs) \\<and>\n       j2 < length (x # xs) \\<and>\n       k1 < length ((x # xs) ! j1) \\<and>\n       k2 < length ((x # xs) ! j2) \\<and>\n       concat (x # xs) ! i1 = (x # xs) ! j1 ! k1 \\<and>\n       concat (x # xs) ! i2 = (x # xs) ! j2 ! k2", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>j1 k1 j2 k2.\n       (j1, k1) \\<noteq> (j2, k2) \\<and>\n       j1 < length (x # xs) \\<and>\n       j2 < length (x # xs) \\<and>\n       k1 < length ((x # xs) ! j1) \\<and>\n       k2 < length ((x # xs) ! j2) \\<and>\n       concat (x # xs) ! i1 = (x # xs) ! j1 ! k1 \\<and>\n       concat (x # xs) ! i2 = (x # xs) ! j2 ! k2", "unfolding i1 i2"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>j1 k1 j2 k2.\n       (j1, k1) \\<noteq> (j2, k2) \\<and>\n       j1 < length (x # xs) \\<and>\n       j2 < length (x # xs) \\<and>\n       k1 < length ((x # xs) ! j1) \\<and>\n       k2 < length ((x # xs) ! j2) \\<and>\n       concat xs ! I1 = (x # xs) ! j1 ! k1 \\<and>\n       concat xs ! I2 = (x # xs) ! j2 ! k2", "by (rule exI[of _ \"Suc j1\"], rule exI[of _ k1], rule exI[of _ \"Suc j2\"], rule exI[of _ k2],\n        insert IH, auto)"], ["proof (state)\nthis:\n  \\<exists>j1 k1 j2 k2.\n     (j1, k1) \\<noteq> (j2, k2) \\<and>\n     j1 < length (x # xs) \\<and>\n     j2 < length (x # xs) \\<and>\n     k1 < length ((x # xs) ! j1) \\<and>\n     k2 < length ((x # xs) ! j2) \\<and>\n     concat (x # xs) ! i1 = (x # xs) ! j1 ! k1 \\<and>\n     concat (x # xs) ! i2 = (x # xs) ! j2 ! k2\n\ngoal (1 subgoal):\n 1. i2 < length x \\<Longrightarrow>\n    \\<exists>j1 k1 j2 k2.\n       (j1, k1) \\<noteq> (j2, k2) \\<and>\n       j1 < length (x # xs) \\<and>\n       j2 < length (x # xs) \\<and>\n       k1 < length ((x # xs) ! j1) \\<and>\n       k2 < length ((x # xs) ! j2) \\<and>\n       concat (x # xs) ! i1 = (x # xs) ! j1 ! k1 \\<and>\n       concat (x # xs) ! i2 = (x # xs) ! j2 ! k2", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. i2 < length x \\<Longrightarrow>\n    \\<exists>j1 k1 j2 k2.\n       (j1, k1) \\<noteq> (j2, k2) \\<and>\n       j1 < length (x # xs) \\<and>\n       j2 < length (x # xs) \\<and>\n       k1 < length ((x # xs) ! j1) \\<and>\n       k2 < length ((x # xs) ! j2) \\<and>\n       concat (x # xs) ! i1 = (x # xs) ! j1 ! k1 \\<and>\n       concat (x # xs) ! i2 = (x # xs) ! j2 ! k2", "case True"], ["proof (state)\nthis:\n  i2 < length x\n\ngoal (1 subgoal):\n 1. i2 < length x \\<Longrightarrow>\n    \\<exists>j1 k1 j2 k2.\n       (j1, k1) \\<noteq> (j2, k2) \\<and>\n       j1 < length (x # xs) \\<and>\n       j2 < length (x # xs) \\<and>\n       k1 < length ((x # xs) ! j1) \\<and>\n       k2 < length ((x # xs) ! j2) \\<and>\n       concat (x # xs) ! i1 = (x # xs) ! j1 ! k1 \\<and>\n       concat (x # xs) ! i2 = (x # xs) ! j2 ! k2", "note l2 = this"], ["proof (state)\nthis:\n  i2 < length x\n\ngoal (1 subgoal):\n 1. i2 < length x \\<Longrightarrow>\n    \\<exists>j1 k1 j2 k2.\n       (j1, k1) \\<noteq> (j2, k2) \\<and>\n       j1 < length (x # xs) \\<and>\n       j2 < length (x # xs) \\<and>\n       k1 < length ((x # xs) ! j1) \\<and>\n       k2 < length ((x # xs) ! j2) \\<and>\n       concat (x # xs) ! i1 = (x # xs) ! j1 ! k1 \\<and>\n       concat (x # xs) ! i2 = (x # xs) ! j2 ! k2", "hence i2: \"concat (Cons x xs) ! i2 = x ! i2\""], ["proof (prove)\nusing this:\n  i2 < length x\n\ngoal (1 subgoal):\n 1. concat (x # xs) ! i2 = x ! i2", "by (auto simp: nth_append)"], ["proof (state)\nthis:\n  concat (x # xs) ! i2 = x ! i2\n\ngoal (1 subgoal):\n 1. i2 < length x \\<Longrightarrow>\n    \\<exists>j1 k1 j2 k2.\n       (j1, k1) \\<noteq> (j2, k2) \\<and>\n       j1 < length (x # xs) \\<and>\n       j2 < length (x # xs) \\<and>\n       k1 < length ((x # xs) ! j1) \\<and>\n       k2 < length ((x # xs) ! j2) \\<and>\n       concat (x # xs) ! i1 = (x # xs) ! j1 ! k1 \\<and>\n       concat (x # xs) ! i2 = (x # xs) ! j2 ! k2", "from nth_concat_split[OF i11(2)]"], ["proof (chain)\npicking this:\n  \\<exists>j k.\n     j < length xs \\<and>\n     k < length (xs ! j) \\<and> concat xs ! I1 = xs ! j ! k", "obtain j1 k1 where\n        *: \"j1 < length xs \\<and> k1 < length (xs ! j1) \\<and> concat xs ! I1 = xs ! j1 ! k1\""], ["proof (prove)\nusing this:\n  \\<exists>j k.\n     j < length xs \\<and>\n     k < length (xs ! j) \\<and> concat xs ! I1 = xs ! j ! k\n\ngoal (1 subgoal):\n 1. (\\<And>j1 k1.\n        j1 < length xs \\<and>\n        k1 < length (xs ! j1) \\<and>\n        concat xs ! I1 = xs ! j1 ! k1 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  j1 < length xs \\<and>\n  k1 < length (xs ! j1) \\<and> concat xs ! I1 = xs ! j1 ! k1\n\ngoal (1 subgoal):\n 1. i2 < length x \\<Longrightarrow>\n    \\<exists>j1 k1 j2 k2.\n       (j1, k1) \\<noteq> (j2, k2) \\<and>\n       j1 < length (x # xs) \\<and>\n       j2 < length (x # xs) \\<and>\n       k1 < length ((x # xs) ! j1) \\<and>\n       k2 < length ((x # xs) ! j2) \\<and>\n       concat (x # xs) ! i1 = (x # xs) ! j1 ! k1 \\<and>\n       concat (x # xs) ! i2 = (x # xs) ! j2 ! k2", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>j1 k1 j2 k2.\n       (j1, k1) \\<noteq> (j2, k2) \\<and>\n       j1 < length (x # xs) \\<and>\n       j2 < length (x # xs) \\<and>\n       k1 < length ((x # xs) ! j1) \\<and>\n       k2 < length ((x # xs) ! j2) \\<and>\n       concat (x # xs) ! i1 = (x # xs) ! j1 ! k1 \\<and>\n       concat (x # xs) ! i2 = (x # xs) ! j2 ! k2", "unfolding i1 i2"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>j1 k1 j2 k2.\n       (j1, k1) \\<noteq> (j2, k2) \\<and>\n       j1 < length (x # xs) \\<and>\n       j2 < length (x # xs) \\<and>\n       k1 < length ((x # xs) ! j1) \\<and>\n       k2 < length ((x # xs) ! j2) \\<and>\n       concat xs ! I1 = (x # xs) ! j1 ! k1 \\<and>\n       x ! i2 = (x # xs) ! j2 ! k2", "by (rule exI[of _ \"Suc j1\"], rule exI[of _ k1], rule exI[of _ 0], rule exI[of _ i2],\n         insert * l2, auto)"], ["proof (state)\nthis:\n  \\<exists>j1 k1 j2 k2.\n     (j1, k1) \\<noteq> (j2, k2) \\<and>\n     j1 < length (x # xs) \\<and>\n     j2 < length (x # xs) \\<and>\n     k1 < length ((x # xs) ! j1) \\<and>\n     k2 < length ((x # xs) ! j2) \\<and>\n     concat (x # xs) ! i1 = (x # xs) ! j1 ! k1 \\<and>\n     concat (x # xs) ! i2 = (x # xs) ! j2 ! k2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>j1 k1 j2 k2.\n     (j1, k1) \\<noteq> (j2, k2) \\<and>\n     j1 < length (x # xs) \\<and>\n     j2 < length (x # xs) \\<and>\n     k1 < length ((x # xs) ! j1) \\<and>\n     k2 < length ((x # xs) ! j2) \\<and>\n     concat (x # xs) ! i1 = (x # xs) ! j1 ! k1 \\<and>\n     concat (x # xs) ! i2 = (x # xs) ! j2 ! k2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>j1 k1 j2 k2.\n     (j1, k1) \\<noteq> (j2, k2) \\<and>\n     j1 < length (x # xs) \\<and>\n     j2 < length (x # xs) \\<and>\n     k1 < length ((x # xs) ! j1) \\<and>\n     k2 < length ((x # xs) ! j2) \\<and>\n     concat (x # xs) ! i1 = (x # xs) ! j1 ! k1 \\<and>\n     concat (x # xs) ! i2 = (x # xs) ! j2 ! k2\n\ngoal (1 subgoal):\n 1. \\<And>i1 i2.\n       \\<lbrakk>i1 < length (concat []); i2 < length (concat []);\n        i1 \\<noteq> i2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j1 k1 j2 k2.\n                            (j1, k1) \\<noteq> (j2, k2) \\<and>\n                            j1 < length [] \\<and>\n                            j2 < length [] \\<and>\n                            k1 < length ([] ! j1) \\<and>\n                            k2 < length ([] ! j2) \\<and>\n                            concat [] ! i1 = [] ! j1 ! k1 \\<and>\n                            concat [] ! i2 = [] ! j2 ! k2", "qed auto"], ["", "lemma list_all2_map_map: \"(\\<And> x. x \\<in> set xs \\<Longrightarrow> R (f x) (g x)) \\<Longrightarrow> list_all2 R (map f xs) (map g xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x.\n        x \\<in> set xs \\<Longrightarrow> R (f x) (g x)) \\<Longrightarrow>\n    list_all2 R (map f xs) (map g xs)", "by (induct xs, auto)"], ["", "subsection \\<open>Partitions\\<close>"], ["", "text \\<open>Check whether a list of sets forms a partition, i.e.,\nwhether the sets are pairwise disjoint.\\<close>"], ["", "definition is_partition :: \"('a set) list \\<Rightarrow> bool\" where\n  \"is_partition cs \\<longleftrightarrow> (\\<forall>j<length cs. \\<forall>i<j. cs ! i \\<inter> cs ! j = {})\""], ["", "(* and an equivalent but more symmetric version *)"], ["", "definition is_partition_alt :: \"('a set) list \\<Rightarrow> bool\" where\n  \"is_partition_alt cs \\<longleftrightarrow> (\\<forall> i j. i < length cs \\<and> j < length cs \\<and> i \\<noteq> j \\<longrightarrow> cs!i \\<inter> cs!j = {})\""], ["", "lemma is_partition_alt: \"is_partition = is_partition_alt\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_partition = is_partition_alt", "proof (intro ext)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. is_partition x = is_partition_alt x", "fix cs :: \"'a set list\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. is_partition x = is_partition_alt x", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. is_partition x = is_partition_alt x", "assume \"is_partition_alt cs\""], ["proof (state)\nthis:\n  is_partition_alt cs\n\ngoal (1 subgoal):\n 1. \\<And>x. is_partition x = is_partition_alt x", "hence \"is_partition cs\""], ["proof (prove)\nusing this:\n  is_partition_alt cs\n\ngoal (1 subgoal):\n 1. is_partition cs", "unfolding is_partition_def is_partition_alt_def"], ["proof (prove)\nusing this:\n  \\<forall>i j.\n     i < length cs \\<and>\n     j < length cs \\<and> i \\<noteq> j \\<longrightarrow>\n     cs ! i \\<inter> cs ! j = {}\n\ngoal (1 subgoal):\n 1. \\<forall>j<length cs. \\<forall>i<j. cs ! i \\<inter> cs ! j = {}", "by auto"], ["proof (state)\nthis:\n  is_partition cs\n\ngoal (1 subgoal):\n 1. \\<And>x. is_partition x = is_partition_alt x", "}"], ["proof (state)\nthis:\n  is_partition_alt cs \\<Longrightarrow> is_partition cs\n\ngoal (1 subgoal):\n 1. \\<And>x. is_partition x = is_partition_alt x", "moreover"], ["proof (state)\nthis:\n  is_partition_alt cs \\<Longrightarrow> is_partition cs\n\ngoal (1 subgoal):\n 1. \\<And>x. is_partition x = is_partition_alt x", "{"], ["proof (state)\nthis:\n  is_partition_alt cs \\<Longrightarrow> is_partition cs\n\ngoal (1 subgoal):\n 1. \\<And>x. is_partition x = is_partition_alt x", "assume part: \"is_partition cs\""], ["proof (state)\nthis:\n  is_partition cs\n\ngoal (1 subgoal):\n 1. \\<And>x. is_partition x = is_partition_alt x", "have \"is_partition_alt cs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_partition_alt cs", "unfolding is_partition_alt_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i j.\n       i < length cs \\<and>\n       j < length cs \\<and> i \\<noteq> j \\<longrightarrow>\n       cs ! i \\<inter> cs ! j = {}", "proof (intro allI impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       i < length cs \\<and>\n       j < length cs \\<and> i \\<noteq> j \\<Longrightarrow>\n       cs ! i \\<inter> cs ! j = {}", "fix i j"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       i < length cs \\<and>\n       j < length cs \\<and> i \\<noteq> j \\<Longrightarrow>\n       cs ! i \\<inter> cs ! j = {}", "assume \"i < length cs \\<and> j < length cs \\<and> i \\<noteq> j\""], ["proof (state)\nthis:\n  i < length cs \\<and> j < length cs \\<and> i \\<noteq> j\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       i < length cs \\<and>\n       j < length cs \\<and> i \\<noteq> j \\<Longrightarrow>\n       cs ! i \\<inter> cs ! j = {}", "with part"], ["proof (chain)\npicking this:\n  is_partition cs\n  i < length cs \\<and> j < length cs \\<and> i \\<noteq> j", "show \"cs ! i \\<inter> cs ! j = {}\""], ["proof (prove)\nusing this:\n  is_partition cs\n  i < length cs \\<and> j < length cs \\<and> i \\<noteq> j\n\ngoal (1 subgoal):\n 1. cs ! i \\<inter> cs ! j = {}", "unfolding is_partition_def"], ["proof (prove)\nusing this:\n  \\<forall>j<length cs. \\<forall>i<j. cs ! i \\<inter> cs ! j = {}\n  i < length cs \\<and> j < length cs \\<and> i \\<noteq> j\n\ngoal (1 subgoal):\n 1. cs ! i \\<inter> cs ! j = {}", "by (cases \"i < j\", simp, cases \"j < i\", force, simp)"], ["proof (state)\nthis:\n  cs ! i \\<inter> cs ! j = {}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  is_partition_alt cs\n\ngoal (1 subgoal):\n 1. \\<And>x. is_partition x = is_partition_alt x", "}"], ["proof (state)\nthis:\n  is_partition cs \\<Longrightarrow> is_partition_alt cs\n\ngoal (1 subgoal):\n 1. \\<And>x. is_partition x = is_partition_alt x", "ultimately"], ["proof (chain)\npicking this:\n  is_partition_alt cs \\<Longrightarrow> is_partition cs\n  is_partition cs \\<Longrightarrow> is_partition_alt cs", "show \"is_partition cs = is_partition_alt cs\""], ["proof (prove)\nusing this:\n  is_partition_alt cs \\<Longrightarrow> is_partition cs\n  is_partition cs \\<Longrightarrow> is_partition_alt cs\n\ngoal (1 subgoal):\n 1. is_partition cs = is_partition_alt cs", "by auto"], ["proof (state)\nthis:\n  is_partition cs = is_partition_alt cs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma is_partition_Nil:\n  \"is_partition [] = True\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_partition [] = True", "unfolding is_partition_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>j<length []. \\<forall>i<j. [] ! i \\<inter> [] ! j = {}) = True", "by auto"], ["", "lemma is_partition_Cons:\n  \"is_partition (x#xs) \\<longleftrightarrow> is_partition xs \\<and> x \\<inter> \\<Union>(set xs) = {}\" (is \"?l = ?r\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_partition (x # xs) =\n    (is_partition xs \\<and> x \\<inter> \\<Union> (set xs) = {})", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. is_partition (x # xs) \\<Longrightarrow>\n    is_partition xs \\<and> x \\<inter> \\<Union> (set xs) = {}\n 2. is_partition xs \\<and>\n    x \\<inter> \\<Union> (set xs) = {} \\<Longrightarrow>\n    is_partition (x # xs)", "assume ?l"], ["proof (state)\nthis:\n  is_partition (x # xs)\n\ngoal (2 subgoals):\n 1. is_partition (x # xs) \\<Longrightarrow>\n    is_partition xs \\<and> x \\<inter> \\<Union> (set xs) = {}\n 2. is_partition xs \\<and>\n    x \\<inter> \\<Union> (set xs) = {} \\<Longrightarrow>\n    is_partition (x # xs)", "have one: \"is_partition xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_partition xs", "proof (unfold is_partition_def, intro allI impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j i.\n       \\<lbrakk>j < length xs; i < j\\<rbrakk>\n       \\<Longrightarrow> xs ! i \\<inter> xs ! j = {}", "fix j i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j i.\n       \\<lbrakk>j < length xs; i < j\\<rbrakk>\n       \\<Longrightarrow> xs ! i \\<inter> xs ! j = {}", "assume \"j < length xs\" and \"i < j\""], ["proof (state)\nthis:\n  j < length xs\n  i < j\n\ngoal (1 subgoal):\n 1. \\<And>j i.\n       \\<lbrakk>j < length xs; i < j\\<rbrakk>\n       \\<Longrightarrow> xs ! i \\<inter> xs ! j = {}", "hence \"Suc j < length(x#xs)\" and \"Suc i < Suc j\""], ["proof (prove)\nusing this:\n  j < length xs\n  i < j\n\ngoal (1 subgoal):\n 1. Suc j < length (x # xs) &&& Suc i < Suc j", "by auto"], ["proof (state)\nthis:\n  Suc j < length (x # xs)\n  Suc i < Suc j\n\ngoal (1 subgoal):\n 1. \\<And>j i.\n       \\<lbrakk>j < length xs; i < j\\<rbrakk>\n       \\<Longrightarrow> xs ! i \\<inter> xs ! j = {}", "from \\<open>?l\\<close>[unfolded is_partition_def,THEN spec,THEN mp,THEN spec,THEN mp,OF this]"], ["proof (chain)\npicking this:\n  (x # xs) ! Suc i \\<inter> (x # xs) ! Suc j = {}", "have \"(x#xs)!(Suc i) \\<inter> (x#xs)!(Suc j) = {}\""], ["proof (prove)\nusing this:\n  (x # xs) ! Suc i \\<inter> (x # xs) ! Suc j = {}\n\ngoal (1 subgoal):\n 1. (x # xs) ! Suc i \\<inter> (x # xs) ! Suc j = {}", "."], ["proof (state)\nthis:\n  (x # xs) ! Suc i \\<inter> (x # xs) ! Suc j = {}\n\ngoal (1 subgoal):\n 1. \\<And>j i.\n       \\<lbrakk>j < length xs; i < j\\<rbrakk>\n       \\<Longrightarrow> xs ! i \\<inter> xs ! j = {}", "thus \"xs!i \\<inter> xs!j = {}\""], ["proof (prove)\nusing this:\n  (x # xs) ! Suc i \\<inter> (x # xs) ! Suc j = {}\n\ngoal (1 subgoal):\n 1. xs ! i \\<inter> xs ! j = {}", "by simp"], ["proof (state)\nthis:\n  xs ! i \\<inter> xs ! j = {}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  is_partition xs\n\ngoal (2 subgoals):\n 1. is_partition (x # xs) \\<Longrightarrow>\n    is_partition xs \\<and> x \\<inter> \\<Union> (set xs) = {}\n 2. is_partition xs \\<and>\n    x \\<inter> \\<Union> (set xs) = {} \\<Longrightarrow>\n    is_partition (x # xs)", "have two: \"x \\<inter> \\<Union>(set xs) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<inter> \\<Union> (set xs) = {}", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<inter> \\<Union> (set xs) \\<noteq> {} \\<Longrightarrow> False", "assume \"x \\<inter> \\<Union>(set xs) \\<noteq> {}\""], ["proof (state)\nthis:\n  x \\<inter> \\<Union> (set xs) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. x \\<inter> \\<Union> (set xs) \\<noteq> {} \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  x \\<inter> \\<Union> (set xs) \\<noteq> {}", "obtain y where \"y \\<in> x\" and \"y \\<in> \\<Union>(set xs)\""], ["proof (prove)\nusing this:\n  x \\<inter> \\<Union> (set xs) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<in> x; y \\<in> \\<Union> (set xs)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  y \\<in> x\n  y \\<in> \\<Union> (set xs)\n\ngoal (1 subgoal):\n 1. x \\<inter> \\<Union> (set xs) \\<noteq> {} \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  y \\<in> x\n  y \\<in> \\<Union> (set xs)", "obtain z where \"z \\<in> set xs\" and \"y \\<in> z\""], ["proof (prove)\nusing this:\n  y \\<in> x\n  y \\<in> \\<Union> (set xs)\n\ngoal (1 subgoal):\n 1. (\\<And>z.\n        \\<lbrakk>z \\<in> set xs; y \\<in> z\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  z \\<in> set xs\n  y \\<in> z\n\ngoal (1 subgoal):\n 1. x \\<inter> \\<Union> (set xs) \\<noteq> {} \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  z \\<in> set xs\n  y \\<in> z", "obtain i where \"i < length xs\" and \"xs!i = z\""], ["proof (prove)\nusing this:\n  z \\<in> set xs\n  y \\<in> z\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>i < length xs; xs ! i = z\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using in_set_conv_nth[of z xs]"], ["proof (prove)\nusing this:\n  z \\<in> set xs\n  y \\<in> z\n  (z \\<in> set xs) = (\\<exists>i<length xs. xs ! i = z)\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>i < length xs; xs ! i = z\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  i < length xs\n  xs ! i = z\n\ngoal (1 subgoal):\n 1. x \\<inter> \\<Union> (set xs) \\<noteq> {} \\<Longrightarrow> False", "with \\<open>y \\<in> z\\<close>"], ["proof (chain)\npicking this:\n  y \\<in> z\n  i < length xs\n  xs ! i = z", "have \"y \\<in> (x#xs)!Suc i\""], ["proof (prove)\nusing this:\n  y \\<in> z\n  i < length xs\n  xs ! i = z\n\ngoal (1 subgoal):\n 1. y \\<in> (x # xs) ! Suc i", "by auto"], ["proof (state)\nthis:\n  y \\<in> (x # xs) ! Suc i\n\ngoal (1 subgoal):\n 1. x \\<inter> \\<Union> (set xs) \\<noteq> {} \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  y \\<in> (x # xs) ! Suc i\n\ngoal (1 subgoal):\n 1. x \\<inter> \\<Union> (set xs) \\<noteq> {} \\<Longrightarrow> False", "with \\<open>y \\<in> x\\<close>"], ["proof (chain)\npicking this:\n  y \\<in> x\n  y \\<in> (x # xs) ! Suc i", "have \"y \\<in> (x#xs)!0\""], ["proof (prove)\nusing this:\n  y \\<in> x\n  y \\<in> (x # xs) ! Suc i\n\ngoal (1 subgoal):\n 1. y \\<in> (x # xs) ! 0", "by simp"], ["proof (state)\nthis:\n  y \\<in> (x # xs) ! 0\n\ngoal (1 subgoal):\n 1. x \\<inter> \\<Union> (set xs) \\<noteq> {} \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  y \\<in> (x # xs) ! Suc i\n  y \\<in> (x # xs) ! 0", "have \"(x#xs)!0 \\<inter> (x#xs)!Suc i \\<noteq> {}\""], ["proof (prove)\nusing this:\n  y \\<in> (x # xs) ! Suc i\n  y \\<in> (x # xs) ! 0\n\ngoal (1 subgoal):\n 1. (x # xs) ! 0 \\<inter> (x # xs) ! Suc i \\<noteq> {}", "by auto"], ["proof (state)\nthis:\n  (x # xs) ! 0 \\<inter> (x # xs) ! Suc i \\<noteq> {}\n\ngoal (1 subgoal):\n 1. x \\<inter> \\<Union> (set xs) \\<noteq> {} \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  (x # xs) ! 0 \\<inter> (x # xs) ! Suc i \\<noteq> {}\n\ngoal (1 subgoal):\n 1. x \\<inter> \\<Union> (set xs) \\<noteq> {} \\<Longrightarrow> False", "from \\<open>i < length xs\\<close>"], ["proof (chain)\npicking this:\n  i < length xs", "have \"Suc i < length(x#xs)\""], ["proof (prove)\nusing this:\n  i < length xs\n\ngoal (1 subgoal):\n 1. Suc i < length (x # xs)", "by simp"], ["proof (state)\nthis:\n  Suc i < length (x # xs)\n\ngoal (1 subgoal):\n 1. x \\<inter> \\<Union> (set xs) \\<noteq> {} \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  (x # xs) ! 0 \\<inter> (x # xs) ! Suc i \\<noteq> {}\n  Suc i < length (x # xs)", "show False"], ["proof (prove)\nusing this:\n  (x # xs) ! 0 \\<inter> (x # xs) ! Suc i \\<noteq> {}\n  Suc i < length (x # xs)\n\ngoal (1 subgoal):\n 1. False", "using \\<open>?l\\<close>[unfolded is_partition_def]"], ["proof (prove)\nusing this:\n  (x # xs) ! 0 \\<inter> (x # xs) ! Suc i \\<noteq> {}\n  Suc i < length (x # xs)\n  \\<forall>j<length (x # xs).\n     \\<forall>i<j. (x # xs) ! i \\<inter> (x # xs) ! j = {}\n\ngoal (1 subgoal):\n 1. False", "by best"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x \\<inter> \\<Union> (set xs) = {}\n\ngoal (2 subgoals):\n 1. is_partition (x # xs) \\<Longrightarrow>\n    is_partition xs \\<and> x \\<inter> \\<Union> (set xs) = {}\n 2. is_partition xs \\<and>\n    x \\<inter> \\<Union> (set xs) = {} \\<Longrightarrow>\n    is_partition (x # xs)", "from one two"], ["proof (chain)\npicking this:\n  is_partition xs\n  x \\<inter> \\<Union> (set xs) = {}", "show ?r"], ["proof (prove)\nusing this:\n  is_partition xs\n  x \\<inter> \\<Union> (set xs) = {}\n\ngoal (1 subgoal):\n 1. is_partition xs \\<and> x \\<inter> \\<Union> (set xs) = {}", ".."], ["proof (state)\nthis:\n  is_partition xs \\<and> x \\<inter> \\<Union> (set xs) = {}\n\ngoal (1 subgoal):\n 1. is_partition xs \\<and>\n    x \\<inter> \\<Union> (set xs) = {} \\<Longrightarrow>\n    is_partition (x # xs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. is_partition xs \\<and>\n    x \\<inter> \\<Union> (set xs) = {} \\<Longrightarrow>\n    is_partition (x # xs)", "assume ?r"], ["proof (state)\nthis:\n  is_partition xs \\<and> x \\<inter> \\<Union> (set xs) = {}\n\ngoal (1 subgoal):\n 1. is_partition xs \\<and>\n    x \\<inter> \\<Union> (set xs) = {} \\<Longrightarrow>\n    is_partition (x # xs)", "show ?l"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_partition (x # xs)", "proof (unfold is_partition_def, intro allI impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j i.\n       \\<lbrakk>j < length (x # xs); i < j\\<rbrakk>\n       \\<Longrightarrow> (x # xs) ! i \\<inter> (x # xs) ! j = {}", "fix j i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j i.\n       \\<lbrakk>j < length (x # xs); i < j\\<rbrakk>\n       \\<Longrightarrow> (x # xs) ! i \\<inter> (x # xs) ! j = {}", "assume j: \"j < length (x # xs)\""], ["proof (state)\nthis:\n  j < length (x # xs)\n\ngoal (1 subgoal):\n 1. \\<And>j i.\n       \\<lbrakk>j < length (x # xs); i < j\\<rbrakk>\n       \\<Longrightarrow> (x # xs) ! i \\<inter> (x # xs) ! j = {}", "assume i: \"i < j\""], ["proof (state)\nthis:\n  i < j\n\ngoal (1 subgoal):\n 1. \\<And>j i.\n       \\<lbrakk>j < length (x # xs); i < j\\<rbrakk>\n       \\<Longrightarrow> (x # xs) ! i \\<inter> (x # xs) ! j = {}", "from i"], ["proof (chain)\npicking this:\n  i < j", "obtain j' where j': \"j = Suc j'\""], ["proof (prove)\nusing this:\n  i < j\n\ngoal (1 subgoal):\n 1. (\\<And>j'. j = Suc j' \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by (cases j, auto)"], ["proof (state)\nthis:\n  j = Suc j'\n\ngoal (1 subgoal):\n 1. \\<And>j i.\n       \\<lbrakk>j < length (x # xs); i < j\\<rbrakk>\n       \\<Longrightarrow> (x # xs) ! i \\<inter> (x # xs) ! j = {}", "with j"], ["proof (chain)\npicking this:\n  j < length (x # xs)\n  j = Suc j'", "have j'len: \"j' < length xs\" and j'elem: \"(x # xs) ! j = xs ! j'\""], ["proof (prove)\nusing this:\n  j < length (x # xs)\n  j = Suc j'\n\ngoal (1 subgoal):\n 1. j' < length xs &&& (x # xs) ! j = xs ! j'", "by auto"], ["proof (state)\nthis:\n  j' < length xs\n  (x # xs) ! j = xs ! j'\n\ngoal (1 subgoal):\n 1. \\<And>j i.\n       \\<lbrakk>j < length (x # xs); i < j\\<rbrakk>\n       \\<Longrightarrow> (x # xs) ! i \\<inter> (x # xs) ! j = {}", "show \"(x # xs) ! i \\<inter> (x # xs) ! j = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x # xs) ! i \\<inter> (x # xs) ! j = {}", "proof (cases i)"], ["proof (state)\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow> (x # xs) ! i \\<inter> (x # xs) ! j = {}\n 2. \\<And>nat.\n       i = Suc nat \\<Longrightarrow> (x # xs) ! i \\<inter> (x # xs) ! j = {}", "case 0"], ["proof (state)\nthis:\n  i = 0\n\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow> (x # xs) ! i \\<inter> (x # xs) ! j = {}\n 2. \\<And>nat.\n       i = Suc nat \\<Longrightarrow> (x # xs) ! i \\<inter> (x # xs) ! j = {}", "with j'elem"], ["proof (chain)\npicking this:\n  (x # xs) ! j = xs ! j'\n  i = 0", "have \"(x # xs) ! i \\<inter> (x # xs) ! j = x \\<inter> xs ! j'\""], ["proof (prove)\nusing this:\n  (x # xs) ! j = xs ! j'\n  i = 0\n\ngoal (1 subgoal):\n 1. (x # xs) ! i \\<inter> (x # xs) ! j = x \\<inter> xs ! j'", "by auto"], ["proof (state)\nthis:\n  (x # xs) ! i \\<inter> (x # xs) ! j = x \\<inter> xs ! j'\n\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow> (x # xs) ! i \\<inter> (x # xs) ! j = {}\n 2. \\<And>nat.\n       i = Suc nat \\<Longrightarrow> (x # xs) ! i \\<inter> (x # xs) ! j = {}", "also"], ["proof (state)\nthis:\n  (x # xs) ! i \\<inter> (x # xs) ! j = x \\<inter> xs ! j'\n\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow> (x # xs) ! i \\<inter> (x # xs) ! j = {}\n 2. \\<And>nat.\n       i = Suc nat \\<Longrightarrow> (x # xs) ! i \\<inter> (x # xs) ! j = {}", "have \"\\<dots> \\<subseteq> x \\<inter> \\<Union>(set xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<inter> xs ! j' \\<subseteq> x \\<inter> \\<Union> (set xs)", "using j'len"], ["proof (prove)\nusing this:\n  j' < length xs\n\ngoal (1 subgoal):\n 1. x \\<inter> xs ! j' \\<subseteq> x \\<inter> \\<Union> (set xs)", "by force"], ["proof (state)\nthis:\n  x \\<inter> xs ! j' \\<subseteq> x \\<inter> \\<Union> (set xs)\n\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow> (x # xs) ! i \\<inter> (x # xs) ! j = {}\n 2. \\<And>nat.\n       i = Suc nat \\<Longrightarrow> (x # xs) ! i \\<inter> (x # xs) ! j = {}", "finally"], ["proof (chain)\npicking this:\n  (x # xs) ! i \\<inter> (x # xs) ! j\n  \\<subseteq> x \\<inter> \\<Union> (set xs)", "show ?thesis"], ["proof (prove)\nusing this:\n  (x # xs) ! i \\<inter> (x # xs) ! j\n  \\<subseteq> x \\<inter> \\<Union> (set xs)\n\ngoal (1 subgoal):\n 1. (x # xs) ! i \\<inter> (x # xs) ! j = {}", "using \\<open>?r\\<close>"], ["proof (prove)\nusing this:\n  (x # xs) ! i \\<inter> (x # xs) ! j\n  \\<subseteq> x \\<inter> \\<Union> (set xs)\n  is_partition xs \\<and> x \\<inter> \\<Union> (set xs) = {}\n\ngoal (1 subgoal):\n 1. (x # xs) ! i \\<inter> (x # xs) ! j = {}", "by auto"], ["proof (state)\nthis:\n  (x # xs) ! i \\<inter> (x # xs) ! j = {}\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       i = Suc nat \\<Longrightarrow> (x # xs) ! i \\<inter> (x # xs) ! j = {}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       i = Suc nat \\<Longrightarrow> (x # xs) ! i \\<inter> (x # xs) ! j = {}", "case (Suc i')"], ["proof (state)\nthis:\n  i = Suc i'\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       i = Suc nat \\<Longrightarrow> (x # xs) ! i \\<inter> (x # xs) ! j = {}", "with i j'"], ["proof (chain)\npicking this:\n  i < j\n  j = Suc j'\n  i = Suc i'", "have i'j': \"i' < j'\""], ["proof (prove)\nusing this:\n  i < j\n  j = Suc j'\n  i = Suc i'\n\ngoal (1 subgoal):\n 1. i' < j'", "by auto"], ["proof (state)\nthis:\n  i' < j'\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       i = Suc nat \\<Longrightarrow> (x # xs) ! i \\<inter> (x # xs) ! j = {}", "from Suc j'"], ["proof (chain)\npicking this:\n  i = Suc i'\n  j = Suc j'", "have \"(x # xs) ! i \\<inter> (x # xs) ! j = xs ! i' \\<inter> xs ! j'\""], ["proof (prove)\nusing this:\n  i = Suc i'\n  j = Suc j'\n\ngoal (1 subgoal):\n 1. (x # xs) ! i \\<inter> (x # xs) ! j = xs ! i' \\<inter> xs ! j'", "by auto"], ["proof (state)\nthis:\n  (x # xs) ! i \\<inter> (x # xs) ! j = xs ! i' \\<inter> xs ! j'\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       i = Suc nat \\<Longrightarrow> (x # xs) ! i \\<inter> (x # xs) ! j = {}", "with \\<open>?r\\<close> i'j' j'len"], ["proof (chain)\npicking this:\n  is_partition xs \\<and> x \\<inter> \\<Union> (set xs) = {}\n  i' < j'\n  j' < length xs\n  (x # xs) ! i \\<inter> (x # xs) ! j = xs ! i' \\<inter> xs ! j'", "show ?thesis"], ["proof (prove)\nusing this:\n  is_partition xs \\<and> x \\<inter> \\<Union> (set xs) = {}\n  i' < j'\n  j' < length xs\n  (x # xs) ! i \\<inter> (x # xs) ! j = xs ! i' \\<inter> xs ! j'\n\ngoal (1 subgoal):\n 1. (x # xs) ! i \\<inter> (x # xs) ! j = {}", "unfolding is_partition_def"], ["proof (prove)\nusing this:\n  (\\<forall>j<length xs. \\<forall>i<j. xs ! i \\<inter> xs ! j = {}) \\<and>\n  x \\<inter> \\<Union> (set xs) = {}\n  i' < j'\n  j' < length xs\n  (x # xs) ! i \\<inter> (x # xs) ! j = xs ! i' \\<inter> xs ! j'\n\ngoal (1 subgoal):\n 1. (x # xs) ! i \\<inter> (x # xs) ! j = {}", "by auto"], ["proof (state)\nthis:\n  (x # xs) ! i \\<inter> (x # xs) ! j = {}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (x # xs) ! i \\<inter> (x # xs) ! j = {}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  is_partition (x # xs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma is_partition_sublist:\n  assumes \"is_partition (us @ xs @ ys @ zs @ vs)\" \n  shows \"is_partition (xs @ zs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_partition (xs @ zs)", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> is_partition (xs @ zs) \\<Longrightarrow> False", "assume \"\\<not> is_partition (xs @ zs)\""], ["proof (state)\nthis:\n  \\<not> is_partition (xs @ zs)\n\ngoal (1 subgoal):\n 1. \\<not> is_partition (xs @ zs) \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<not> is_partition (xs @ zs)", "obtain i j where j:\"j < length (xs @ zs)\" and i:\"i < j\" and *:\"(xs @ zs) ! i \\<inter> (xs @ zs) ! j \\<noteq> {}\""], ["proof (prove)\nusing this:\n  \\<not> is_partition (xs @ zs)\n\ngoal (1 subgoal):\n 1. (\\<And>j i.\n        \\<lbrakk>j < length (xs @ zs); i < j;\n         (xs @ zs) ! i \\<inter> (xs @ zs) ! j \\<noteq> {}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding is_partition_def"], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>j<length (xs @ zs).\n             \\<forall>i<j. (xs @ zs) ! i \\<inter> (xs @ zs) ! j = {})\n\ngoal (1 subgoal):\n 1. (\\<And>j i.\n        \\<lbrakk>j < length (xs @ zs); i < j;\n         (xs @ zs) ! i \\<inter> (xs @ zs) ! j \\<noteq> {}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  j < length (xs @ zs)\n  i < j\n  (xs @ zs) ! i \\<inter> (xs @ zs) ! j \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<not> is_partition (xs @ zs) \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  j < length (xs @ zs)\n  i < j\n  (xs @ zs) ! i \\<inter> (xs @ zs) ! j \\<noteq> {}", "show False"], ["proof (prove)\nusing this:\n  j < length (xs @ zs)\n  i < j\n  (xs @ zs) ! i \\<inter> (xs @ zs) ! j \\<noteq> {}\n\ngoal (1 subgoal):\n 1. False", "proof (cases \"j < length xs\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>j < length (xs @ zs); i < j;\n     (xs @ zs) ! i \\<inter> (xs @ zs) ! j \\<noteq> {};\n     j < length xs\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>j < length (xs @ zs); i < j;\n     (xs @ zs) ! i \\<inter> (xs @ zs) ! j \\<noteq> {};\n     \\<not> j < length xs\\<rbrakk>\n    \\<Longrightarrow> False", "case True"], ["proof (state)\nthis:\n  j < length xs\n\ngoal (2 subgoals):\n 1. \\<lbrakk>j < length (xs @ zs); i < j;\n     (xs @ zs) ! i \\<inter> (xs @ zs) ! j \\<noteq> {};\n     j < length xs\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>j < length (xs @ zs); i < j;\n     (xs @ zs) ! i \\<inter> (xs @ zs) ! j \\<noteq> {};\n     \\<not> j < length xs\\<rbrakk>\n    \\<Longrightarrow> False", "let ?m = \"j + length us\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>j < length (xs @ zs); i < j;\n     (xs @ zs) ! i \\<inter> (xs @ zs) ! j \\<noteq> {};\n     j < length xs\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>j < length (xs @ zs); i < j;\n     (xs @ zs) ! i \\<inter> (xs @ zs) ! j \\<noteq> {};\n     \\<not> j < length xs\\<rbrakk>\n    \\<Longrightarrow> False", "let ?n = \"i + length us\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>j < length (xs @ zs); i < j;\n     (xs @ zs) ! i \\<inter> (xs @ zs) ! j \\<noteq> {};\n     j < length xs\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>j < length (xs @ zs); i < j;\n     (xs @ zs) ! i \\<inter> (xs @ zs) ! j \\<noteq> {};\n     \\<not> j < length xs\\<rbrakk>\n    \\<Longrightarrow> False", "from True"], ["proof (chain)\npicking this:\n  j < length xs", "have \"?m < length (us @ xs @ ys @ zs @ vs)\""], ["proof (prove)\nusing this:\n  j < length xs\n\ngoal (1 subgoal):\n 1. j + length us < length (us @ xs @ ys @ zs @ vs)", "by auto"], ["proof (state)\nthis:\n  j + length us < length (us @ xs @ ys @ zs @ vs)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>j < length (xs @ zs); i < j;\n     (xs @ zs) ! i \\<inter> (xs @ zs) ! j \\<noteq> {};\n     j < length xs\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>j < length (xs @ zs); i < j;\n     (xs @ zs) ! i \\<inter> (xs @ zs) ! j \\<noteq> {};\n     \\<not> j < length xs\\<rbrakk>\n    \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  j + length us < length (us @ xs @ ys @ zs @ vs)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>j < length (xs @ zs); i < j;\n     (xs @ zs) ! i \\<inter> (xs @ zs) ! j \\<noteq> {};\n     j < length xs\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>j < length (xs @ zs); i < j;\n     (xs @ zs) ! i \\<inter> (xs @ zs) ! j \\<noteq> {};\n     \\<not> j < length xs\\<rbrakk>\n    \\<Longrightarrow> False", "from i"], ["proof (chain)\npicking this:\n  i < j", "have \"?n < ?m\""], ["proof (prove)\nusing this:\n  i < j\n\ngoal (1 subgoal):\n 1. i + length us < j + length us", "by auto"], ["proof (state)\nthis:\n  i + length us < j + length us\n\ngoal (2 subgoals):\n 1. \\<lbrakk>j < length (xs @ zs); i < j;\n     (xs @ zs) ! i \\<inter> (xs @ zs) ! j \\<noteq> {};\n     j < length xs\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>j < length (xs @ zs); i < j;\n     (xs @ zs) ! i \\<inter> (xs @ zs) ! j \\<noteq> {};\n     \\<not> j < length xs\\<rbrakk>\n    \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  i + length us < j + length us\n\ngoal (2 subgoals):\n 1. \\<lbrakk>j < length (xs @ zs); i < j;\n     (xs @ zs) ! i \\<inter> (xs @ zs) ! j \\<noteq> {};\n     j < length xs\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>j < length (xs @ zs); i < j;\n     (xs @ zs) ! i \\<inter> (xs @ zs) ! j \\<noteq> {};\n     \\<not> j < length xs\\<rbrakk>\n    \\<Longrightarrow> False", "have \"(us @ xs @ ys @ zs @ vs) ! ?n \\<inter> (us @ xs @ ys @ zs @ vs) ! ?m \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (us @ xs @ ys @ zs @ vs) ! (i + length us) \\<inter>\n    (us @ xs @ ys @ zs @ vs) ! (j + length us) \\<noteq>\n    {}", "using i True * nth_append"], ["proof (prove)\nusing this:\n  i < j\n  j < length xs\n  (xs @ zs) ! i \\<inter> (xs @ zs) ! j \\<noteq> {}\n  (?xs @ ?ys) ! ?n =\n  (if ?n < length ?xs then ?xs ! ?n else ?ys ! (?n - length ?xs))\n\ngoal (1 subgoal):\n 1. (us @ xs @ ys @ zs @ vs) ! (i + length us) \\<inter>\n    (us @ xs @ ys @ zs @ vs) ! (j + length us) \\<noteq>\n    {}", "by (metis (no_types, lifting) add_diff_cancel_right' not_add_less2 order.strict_trans)"], ["proof (state)\nthis:\n  (us @ xs @ ys @ zs @ vs) ! (i + length us) \\<inter>\n  (us @ xs @ ys @ zs @ vs) ! (j + length us) \\<noteq>\n  {}\n\ngoal (2 subgoals):\n 1. \\<lbrakk>j < length (xs @ zs); i < j;\n     (xs @ zs) ! i \\<inter> (xs @ zs) ! j \\<noteq> {};\n     j < length xs\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>j < length (xs @ zs); i < j;\n     (xs @ zs) ! i \\<inter> (xs @ zs) ! j \\<noteq> {};\n     \\<not> j < length xs\\<rbrakk>\n    \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  j + length us < length (us @ xs @ ys @ zs @ vs)\n  i + length us < j + length us\n  (us @ xs @ ys @ zs @ vs) ! (i + length us) \\<inter>\n  (us @ xs @ ys @ zs @ vs) ! (j + length us) \\<noteq>\n  {}", "show False"], ["proof (prove)\nusing this:\n  j + length us < length (us @ xs @ ys @ zs @ vs)\n  i + length us < j + length us\n  (us @ xs @ ys @ zs @ vs) ! (i + length us) \\<inter>\n  (us @ xs @ ys @ zs @ vs) ! (j + length us) \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. False", "using assms"], ["proof (prove)\nusing this:\n  j + length us < length (us @ xs @ ys @ zs @ vs)\n  i + length us < j + length us\n  (us @ xs @ ys @ zs @ vs) ! (i + length us) \\<inter>\n  (us @ xs @ ys @ zs @ vs) ! (j + length us) \\<noteq>\n  {}\n  is_partition (us @ xs @ ys @ zs @ vs)\n\ngoal (1 subgoal):\n 1. False", "unfolding is_partition_def"], ["proof (prove)\nusing this:\n  j + length us < length (us @ xs @ ys @ zs @ vs)\n  i + length us < j + length us\n  (us @ xs @ ys @ zs @ vs) ! (i + length us) \\<inter>\n  (us @ xs @ ys @ zs @ vs) ! (j + length us) \\<noteq>\n  {}\n  \\<forall>j<length (us @ xs @ ys @ zs @ vs).\n     \\<forall>i<j.\n        (us @ xs @ ys @ zs @ vs) ! i \\<inter> (us @ xs @ ys @ zs @ vs) ! j =\n        {}\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<lbrakk>j < length (xs @ zs); i < j;\n     (xs @ zs) ! i \\<inter> (xs @ zs) ! j \\<noteq> {};\n     \\<not> j < length xs\\<rbrakk>\n    \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>j < length (xs @ zs); i < j;\n     (xs @ zs) ! i \\<inter> (xs @ zs) ! j \\<noteq> {};\n     \\<not> j < length xs\\<rbrakk>\n    \\<Longrightarrow> False", "case False"], ["proof (state)\nthis:\n  \\<not> j < length xs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>j < length (xs @ zs); i < j;\n     (xs @ zs) ! i \\<inter> (xs @ zs) ! j \\<noteq> {};\n     \\<not> j < length xs\\<rbrakk>\n    \\<Longrightarrow> False", "let ?m = \"j + length us + length ys\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>j < length (xs @ zs); i < j;\n     (xs @ zs) ! i \\<inter> (xs @ zs) ! j \\<noteq> {};\n     \\<not> j < length xs\\<rbrakk>\n    \\<Longrightarrow> False", "from j"], ["proof (chain)\npicking this:\n  j < length (xs @ zs)", "have m:\"?m < length (us @ xs @ ys @ zs @ vs)\""], ["proof (prove)\nusing this:\n  j < length (xs @ zs)\n\ngoal (1 subgoal):\n 1. j + length us + length ys < length (us @ xs @ ys @ zs @ vs)", "by auto"], ["proof (state)\nthis:\n  j + length us + length ys < length (us @ xs @ ys @ zs @ vs)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>j < length (xs @ zs); i < j;\n     (xs @ zs) ! i \\<inter> (xs @ zs) ! j \\<noteq> {};\n     \\<not> j < length xs\\<rbrakk>\n    \\<Longrightarrow> False", "have mj:\"(us @ (xs @ ys @ zs @ vs)) ! ?m = (xs @ zs) ! j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (us @ xs @ ys @ zs @ vs) ! (j + length us + length ys) = (xs @ zs) ! j", "unfolding nth_append"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if j + length us + length ys < length us\n     then us ! (j + length us + length ys)\n     else if j + length us + length ys - length us < length xs\n          then xs ! (j + length us + length ys - length us)\n          else if j + length us + length ys - length us - length xs\n                  < length ys\n               then ys ! (j + length us + length ys - length us - length xs)\n               else if j + length us + length ys - length us - length xs -\n                       length ys\n                       < length zs\n                    then zs !\n                         (j + length us + length ys - length us -\n                          length xs -\n                          length ys)\n                    else vs !\n                         (j + length us + length ys - length us -\n                          length xs -\n                          length ys -\n                          length zs)) =\n    (if j < length xs then xs ! j else zs ! (j - length xs))", "using False j"], ["proof (prove)\nusing this:\n  \\<not> j < length xs\n  j < length (xs @ zs)\n\ngoal (1 subgoal):\n 1. (if j + length us + length ys < length us\n     then us ! (j + length us + length ys)\n     else if j + length us + length ys - length us < length xs\n          then xs ! (j + length us + length ys - length us)\n          else if j + length us + length ys - length us - length xs\n                  < length ys\n               then ys ! (j + length us + length ys - length us - length xs)\n               else if j + length us + length ys - length us - length xs -\n                       length ys\n                       < length zs\n                    then zs !\n                         (j + length us + length ys - length us -\n                          length xs -\n                          length ys)\n                    else vs !\n                         (j + length us + length ys - length us -\n                          length xs -\n                          length ys -\n                          length zs)) =\n    (if j < length xs then xs ! j else zs ! (j - length xs))", "by auto"], ["proof (state)\nthis:\n  (us @ xs @ ys @ zs @ vs) ! (j + length us + length ys) = (xs @ zs) ! j\n\ngoal (1 subgoal):\n 1. \\<lbrakk>j < length (xs @ zs); i < j;\n     (xs @ zs) ! i \\<inter> (xs @ zs) ! j \\<noteq> {};\n     \\<not> j < length xs\\<rbrakk>\n    \\<Longrightarrow> False", "show False"], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof (cases \"i < length xs\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i < length xs \\<Longrightarrow> False\n 2. \\<not> i < length xs \\<Longrightarrow> False", "case True"], ["proof (state)\nthis:\n  i < length xs\n\ngoal (2 subgoals):\n 1. i < length xs \\<Longrightarrow> False\n 2. \\<not> i < length xs \\<Longrightarrow> False", "let ?n = \"i + length us\""], ["proof (state)\ngoal (2 subgoals):\n 1. i < length xs \\<Longrightarrow> False\n 2. \\<not> i < length xs \\<Longrightarrow> False", "from i"], ["proof (chain)\npicking this:\n  i < j", "have \"?n < ?m\""], ["proof (prove)\nusing this:\n  i < j\n\ngoal (1 subgoal):\n 1. i + length us < j + length us + length ys", "by auto"], ["proof (state)\nthis:\n  i + length us < j + length us + length ys\n\ngoal (2 subgoals):\n 1. i < length xs \\<Longrightarrow> False\n 2. \\<not> i < length xs \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  i + length us < j + length us + length ys\n\ngoal (2 subgoals):\n 1. i < length xs \\<Longrightarrow> False\n 2. \\<not> i < length xs \\<Longrightarrow> False", "have \"(us @ xs @ ys @ zs @ vs) ! ?n = (xs @ zs) ! i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (us @ xs @ ys @ zs @ vs) ! (i + length us) = (xs @ zs) ! i", "by (simp add: True nth_append)"], ["proof (state)\nthis:\n  (us @ xs @ ys @ zs @ vs) ! (i + length us) = (xs @ zs) ! i\n\ngoal (2 subgoals):\n 1. i < length xs \\<Longrightarrow> False\n 2. \\<not> i < length xs \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  i + length us < j + length us + length ys\n  (us @ xs @ ys @ zs @ vs) ! (i + length us) = (xs @ zs) ! i", "show False"], ["proof (prove)\nusing this:\n  i + length us < j + length us + length ys\n  (us @ xs @ ys @ zs @ vs) ! (i + length us) = (xs @ zs) ! i\n\ngoal (1 subgoal):\n 1. False", "using * m assms mj"], ["proof (prove)\nusing this:\n  i + length us < j + length us + length ys\n  (us @ xs @ ys @ zs @ vs) ! (i + length us) = (xs @ zs) ! i\n  (xs @ zs) ! i \\<inter> (xs @ zs) ! j \\<noteq> {}\n  j + length us + length ys < length (us @ xs @ ys @ zs @ vs)\n  is_partition (us @ xs @ ys @ zs @ vs)\n  (us @ xs @ ys @ zs @ vs) ! (j + length us + length ys) = (xs @ zs) ! j\n\ngoal (1 subgoal):\n 1. False", "unfolding is_partition_def"], ["proof (prove)\nusing this:\n  i + length us < j + length us + length ys\n  (us @ xs @ ys @ zs @ vs) ! (i + length us) = (xs @ zs) ! i\n  (xs @ zs) ! i \\<inter> (xs @ zs) ! j \\<noteq> {}\n  j + length us + length ys < length (us @ xs @ ys @ zs @ vs)\n  \\<forall>j<length (us @ xs @ ys @ zs @ vs).\n     \\<forall>i<j.\n        (us @ xs @ ys @ zs @ vs) ! i \\<inter> (us @ xs @ ys @ zs @ vs) ! j =\n        {}\n  (us @ xs @ ys @ zs @ vs) ! (j + length us + length ys) = (xs @ zs) ! j\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<not> i < length xs \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> i < length xs \\<Longrightarrow> False", "case False"], ["proof (state)\nthis:\n  \\<not> i < length xs\n\ngoal (1 subgoal):\n 1. \\<not> i < length xs \\<Longrightarrow> False", "let ?n = \"i + length us + length ys\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> i < length xs \\<Longrightarrow> False", "from i"], ["proof (chain)\npicking this:\n  i < j", "have i:\"?n < ?m\""], ["proof (prove)\nusing this:\n  i < j\n\ngoal (1 subgoal):\n 1. i + length us + length ys < j + length us + length ys", "by auto"], ["proof (state)\nthis:\n  i + length us + length ys < j + length us + length ys\n\ngoal (1 subgoal):\n 1. \\<not> i < length xs \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  i + length us + length ys < j + length us + length ys\n\ngoal (1 subgoal):\n 1. \\<not> i < length xs \\<Longrightarrow> False", "have \"(us @ xs @ ys @ zs @ vs) ! ?n = (xs @ zs) ! i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (us @ xs @ ys @ zs @ vs) ! (i + length us + length ys) = (xs @ zs) ! i", "unfolding nth_append"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if i + length us + length ys < length us\n     then us ! (i + length us + length ys)\n     else if i + length us + length ys - length us < length xs\n          then xs ! (i + length us + length ys - length us)\n          else if i + length us + length ys - length us - length xs\n                  < length ys\n               then ys ! (i + length us + length ys - length us - length xs)\n               else if i + length us + length ys - length us - length xs -\n                       length ys\n                       < length zs\n                    then zs !\n                         (i + length us + length ys - length us -\n                          length xs -\n                          length ys)\n                    else vs !\n                         (i + length us + length ys - length us -\n                          length xs -\n                          length ys -\n                          length zs)) =\n    (if i < length xs then xs ! i else zs ! (i - length xs))", "using False i j less_diff_conv2"], ["proof (prove)\nusing this:\n  \\<not> i < length xs\n  i + length us + length ys < j + length us + length ys\n  j < length (xs @ zs)\n  ?k \\<le> ?j \\<Longrightarrow> (?j - ?k < ?i) = (?j < ?i + ?k)\n\ngoal (1 subgoal):\n 1. (if i + length us + length ys < length us\n     then us ! (i + length us + length ys)\n     else if i + length us + length ys - length us < length xs\n          then xs ! (i + length us + length ys - length us)\n          else if i + length us + length ys - length us - length xs\n                  < length ys\n               then ys ! (i + length us + length ys - length us - length xs)\n               else if i + length us + length ys - length us - length xs -\n                       length ys\n                       < length zs\n                    then zs !\n                         (i + length us + length ys - length us -\n                          length xs -\n                          length ys)\n                    else vs !\n                         (i + length us + length ys - length us -\n                          length xs -\n                          length ys -\n                          length zs)) =\n    (if i < length xs then xs ! i else zs ! (i - length xs))", "by auto"], ["proof (state)\nthis:\n  (us @ xs @ ys @ zs @ vs) ! (i + length us + length ys) = (xs @ zs) ! i\n\ngoal (1 subgoal):\n 1. \\<not> i < length xs \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  i + length us + length ys < j + length us + length ys\n  (us @ xs @ ys @ zs @ vs) ! (i + length us + length ys) = (xs @ zs) ! i", "show False"], ["proof (prove)\nusing this:\n  i + length us + length ys < j + length us + length ys\n  (us @ xs @ ys @ zs @ vs) ! (i + length us + length ys) = (xs @ zs) ! i\n\ngoal (1 subgoal):\n 1. False", "using * m assms mj"], ["proof (prove)\nusing this:\n  i + length us + length ys < j + length us + length ys\n  (us @ xs @ ys @ zs @ vs) ! (i + length us + length ys) = (xs @ zs) ! i\n  (xs @ zs) ! i \\<inter> (xs @ zs) ! j \\<noteq> {}\n  j + length us + length ys < length (us @ xs @ ys @ zs @ vs)\n  is_partition (us @ xs @ ys @ zs @ vs)\n  (us @ xs @ ys @ zs @ vs) ! (j + length us + length ys) = (xs @ zs) ! j\n\ngoal (1 subgoal):\n 1. False", "unfolding is_partition_def"], ["proof (prove)\nusing this:\n  i + length us + length ys < j + length us + length ys\n  (us @ xs @ ys @ zs @ vs) ! (i + length us + length ys) = (xs @ zs) ! i\n  (xs @ zs) ! i \\<inter> (xs @ zs) ! j \\<noteq> {}\n  j + length us + length ys < length (us @ xs @ ys @ zs @ vs)\n  \\<forall>j<length (us @ xs @ ys @ zs @ vs).\n     \\<forall>i<j.\n        (us @ xs @ ys @ zs @ vs) ! i \\<inter> (us @ xs @ ys @ zs @ vs) ! j =\n        {}\n  (us @ xs @ ys @ zs @ vs) ! (j + length us + length ys) = (xs @ zs) ! j\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma is_partition_inj_map:\n  assumes \"is_partition xs\"\n  and \"inj_on f (\\<Union>x \\<in> set xs. x)\"\n  shows \"is_partition (map ((`) f) xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_partition (map ((`) f) xs)", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> is_partition (map ((`) f) xs) \\<Longrightarrow> False", "assume \"\\<not> is_partition (map ((`) f) xs)\""], ["proof (state)\nthis:\n  \\<not> is_partition (map ((`) f) xs)\n\ngoal (1 subgoal):\n 1. \\<not> is_partition (map ((`) f) xs) \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<not> is_partition (map ((`) f) xs)", "obtain i j where neq:\"i \\<noteq> j\" \n    and i:\"i < length (map ((`) f) xs)\" and j:\"j < length (map ((`) f) xs)\"\n    and \"map ((`) f) xs ! i \\<inter> map ((`) f) xs ! j \\<noteq> {}\""], ["proof (prove)\nusing this:\n  \\<not> is_partition (map ((`) f) xs)\n\ngoal (1 subgoal):\n 1. (\\<And>i j.\n        \\<lbrakk>i \\<noteq> j; i < length (map ((`) f) xs);\n         j < length (map ((`) f) xs);\n         map ((`) f) xs ! i \\<inter> map ((`) f) xs ! j \\<noteq> {}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding is_partition_alt is_partition_alt_def"], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>i j.\n             i < length (map ((`) f) xs) \\<and>\n             j < length (map ((`) f) xs) \\<and>\n             i \\<noteq> j \\<longrightarrow>\n             map ((`) f) xs ! i \\<inter> map ((`) f) xs ! j = {})\n\ngoal (1 subgoal):\n 1. (\\<And>i j.\n        \\<lbrakk>i \\<noteq> j; i < length (map ((`) f) xs);\n         j < length (map ((`) f) xs);\n         map ((`) f) xs ! i \\<inter> map ((`) f) xs ! j \\<noteq> {}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  i \\<noteq> j\n  i < length (map ((`) f) xs)\n  j < length (map ((`) f) xs)\n  map ((`) f) xs ! i \\<inter> map ((`) f) xs ! j \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<not> is_partition (map ((`) f) xs) \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  i \\<noteq> j\n  i < length (map ((`) f) xs)\n  j < length (map ((`) f) xs)\n  map ((`) f) xs ! i \\<inter> map ((`) f) xs ! j \\<noteq> {}", "obtain x where \"x \\<in> map ((`) f) xs ! i\" and \"x \\<in> map ((`) f) xs ! j\""], ["proof (prove)\nusing this:\n  i \\<noteq> j\n  i < length (map ((`) f) xs)\n  j < length (map ((`) f) xs)\n  map ((`) f) xs ! i \\<inter> map ((`) f) xs ! j \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>x \\<in> map ((`) f) xs ! i;\n         x \\<in> map ((`) f) xs ! j\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  x \\<in> map ((`) f) xs ! i\n  x \\<in> map ((`) f) xs ! j\n\ngoal (1 subgoal):\n 1. \\<not> is_partition (map ((`) f) xs) \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  x \\<in> map ((`) f) xs ! i\n  x \\<in> map ((`) f) xs ! j", "obtain y z where yi:\"y \\<in> xs ! i\" and yx:\"f y = x\" and zj:\"z \\<in> xs ! j\" and zx:\"f z = x\""], ["proof (prove)\nusing this:\n  x \\<in> map ((`) f) xs ! i\n  x \\<in> map ((`) f) xs ! j\n\ngoal (1 subgoal):\n 1. (\\<And>y z.\n        \\<lbrakk>y \\<in> xs ! i; f y = x; z \\<in> xs ! j; f z = x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using i j"], ["proof (prove)\nusing this:\n  x \\<in> map ((`) f) xs ! i\n  x \\<in> map ((`) f) xs ! j\n  i < length (map ((`) f) xs)\n  j < length (map ((`) f) xs)\n\ngoal (1 subgoal):\n 1. (\\<And>y z.\n        \\<lbrakk>y \\<in> xs ! i; f y = x; z \\<in> xs ! j; f z = x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  y \\<in> xs ! i\n  f y = x\n  z \\<in> xs ! j\n  f z = x\n\ngoal (1 subgoal):\n 1. \\<not> is_partition (map ((`) f) xs) \\<Longrightarrow> False", "show False"], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof (cases \"y = z\")"], ["proof (state)\ngoal (2 subgoals):\n 1. y = z \\<Longrightarrow> False\n 2. y \\<noteq> z \\<Longrightarrow> False", "case True"], ["proof (state)\nthis:\n  y = z\n\ngoal (2 subgoals):\n 1. y = z \\<Longrightarrow> False\n 2. y \\<noteq> z \\<Longrightarrow> False", "with zj yi neq assms(1) i j"], ["proof (chain)\npicking this:\n  z \\<in> xs ! j\n  y \\<in> xs ! i\n  i \\<noteq> j\n  is_partition xs\n  i < length (map ((`) f) xs)\n  j < length (map ((`) f) xs)\n  y = z", "show ?thesis"], ["proof (prove)\nusing this:\n  z \\<in> xs ! j\n  y \\<in> xs ! i\n  i \\<noteq> j\n  is_partition xs\n  i < length (map ((`) f) xs)\n  j < length (map ((`) f) xs)\n  y = z\n\ngoal (1 subgoal):\n 1. False", "by (auto simp: is_partition_alt is_partition_alt_def)"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. y \\<noteq> z \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. y \\<noteq> z \\<Longrightarrow> False", "case False"], ["proof (state)\nthis:\n  y \\<noteq> z\n\ngoal (1 subgoal):\n 1. y \\<noteq> z \\<Longrightarrow> False", "have \"y \\<in> (\\<Union>x \\<in> set xs. x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<in> (\\<Union>x\\<in>set xs. x)", "using yi i"], ["proof (prove)\nusing this:\n  y \\<in> xs ! i\n  i < length (map ((`) f) xs)\n\ngoal (1 subgoal):\n 1. y \\<in> (\\<Union>x\\<in>set xs. x)", "by force"], ["proof (state)\nthis:\n  y \\<in> (\\<Union>x\\<in>set xs. x)\n\ngoal (1 subgoal):\n 1. y \\<noteq> z \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  y \\<in> (\\<Union>x\\<in>set xs. x)\n\ngoal (1 subgoal):\n 1. y \\<noteq> z \\<Longrightarrow> False", "have \"z \\<in> (\\<Union>x \\<in> set xs. x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z \\<in> (\\<Union>x\\<in>set xs. x)", "using zj j"], ["proof (prove)\nusing this:\n  z \\<in> xs ! j\n  j < length (map ((`) f) xs)\n\ngoal (1 subgoal):\n 1. z \\<in> (\\<Union>x\\<in>set xs. x)", "by force"], ["proof (state)\nthis:\n  z \\<in> (\\<Union>x\\<in>set xs. x)\n\ngoal (1 subgoal):\n 1. y \\<noteq> z \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  y \\<in> (\\<Union>x\\<in>set xs. x)\n  z \\<in> (\\<Union>x\\<in>set xs. x)", "show ?thesis"], ["proof (prove)\nusing this:\n  y \\<in> (\\<Union>x\\<in>set xs. x)\n  z \\<in> (\\<Union>x\\<in>set xs. x)\n\ngoal (1 subgoal):\n 1. False", "using assms(2) inj_on_def[of f \"(\\<Union>x\\<in>set xs. x)\"] False zx yx"], ["proof (prove)\nusing this:\n  y \\<in> (\\<Union>x\\<in>set xs. x)\n  z \\<in> (\\<Union>x\\<in>set xs. x)\n  inj_on f (\\<Union>x\\<in>set xs. x)\n  inj_on f (\\<Union>x\\<in>set xs. x) =\n  (\\<forall>x\\<in>\\<Union>x\\<in>set xs. x.\n      \\<forall>y\\<in>\\<Union>x\\<in>set xs. x.\n         f x = f y \\<longrightarrow> x = y)\n  y \\<noteq> z\n  f z = x\n  f y = x\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "context\nbegin"], ["", "private"], ["", "fun is_partition_impl :: \"'a set list \\<Rightarrow> 'a set option\" where\n  \"is_partition_impl [] = Some {}\"\n| \"is_partition_impl (as # rest) = do {\n      all \\<leftarrow> is_partition_impl rest;\n      if as \\<inter> all = {} then Some (all \\<union> as) else None\n    }\""], ["", "lemma is_partition_code[code]: \"is_partition as = (is_partition_impl as \\<noteq> None)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_partition as = (is_partition_impl as \\<noteq> None)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. is_partition as = (is_partition_impl as \\<noteq> None)", "note [simp] = is_partition_Cons is_partition_Nil"], ["proof (state)\nthis:\n  is_partition (?x # ?xs) =\n  (is_partition ?xs \\<and> ?x \\<inter> \\<Union> (set ?xs) = {})\n  is_partition [] = True\n\ngoal (1 subgoal):\n 1. is_partition as = (is_partition_impl as \\<noteq> None)", "have \"\\<And> bs. (is_partition as = (is_partition_impl as \\<noteq> None)) \\<and>\n    (is_partition_impl as = Some bs \\<longrightarrow> bs = \\<Union> (set as))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>bs.\n       is_partition as = (is_partition_impl as \\<noteq> None) \\<and>\n       (is_partition_impl as = Some bs \\<longrightarrow>\n        bs = \\<Union> (set as))", "proof (induct as)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>bs.\n       is_partition [] = (is_partition_impl [] \\<noteq> None) \\<and>\n       (is_partition_impl [] = Some bs \\<longrightarrow>\n        bs = \\<Union> (set []))\n 2. \\<And>a as bs.\n       (\\<And>bs.\n           is_partition as = (is_partition_impl as \\<noteq> None) \\<and>\n           (is_partition_impl as = Some bs \\<longrightarrow>\n            bs = \\<Union> (set as))) \\<Longrightarrow>\n       is_partition (a # as) =\n       (is_partition_impl (a # as) \\<noteq> None) \\<and>\n       (is_partition_impl (a # as) = Some bs \\<longrightarrow>\n        bs = \\<Union> (set (a # as)))", "case (Cons as rest bs)"], ["proof (state)\nthis:\n  is_partition rest = (is_partition_impl rest \\<noteq> None) \\<and>\n  (is_partition_impl rest = Some ?bs \\<longrightarrow>\n   ?bs = \\<Union> (set rest))\n\ngoal (2 subgoals):\n 1. \\<And>bs.\n       is_partition [] = (is_partition_impl [] \\<noteq> None) \\<and>\n       (is_partition_impl [] = Some bs \\<longrightarrow>\n        bs = \\<Union> (set []))\n 2. \\<And>a as bs.\n       (\\<And>bs.\n           is_partition as = (is_partition_impl as \\<noteq> None) \\<and>\n           (is_partition_impl as = Some bs \\<longrightarrow>\n            bs = \\<Union> (set as))) \\<Longrightarrow>\n       is_partition (a # as) =\n       (is_partition_impl (a # as) \\<noteq> None) \\<and>\n       (is_partition_impl (a # as) = Some bs \\<longrightarrow>\n        bs = \\<Union> (set (a # as)))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_partition (as # rest) =\n    (is_partition_impl (as # rest) \\<noteq> None) \\<and>\n    (is_partition_impl (as # rest) = Some bs \\<longrightarrow>\n     bs = \\<Union> (set (as # rest)))", "proof (cases \"is_partition rest\")"], ["proof (state)\ngoal (2 subgoals):\n 1. is_partition rest \\<Longrightarrow>\n    is_partition (as # rest) =\n    (is_partition_impl (as # rest) \\<noteq> None) \\<and>\n    (is_partition_impl (as # rest) = Some bs \\<longrightarrow>\n     bs = \\<Union> (set (as # rest)))\n 2. \\<not> is_partition rest \\<Longrightarrow>\n    is_partition (as # rest) =\n    (is_partition_impl (as # rest) \\<noteq> None) \\<and>\n    (is_partition_impl (as # rest) = Some bs \\<longrightarrow>\n     bs = \\<Union> (set (as # rest)))", "case False"], ["proof (state)\nthis:\n  \\<not> is_partition rest\n\ngoal (2 subgoals):\n 1. is_partition rest \\<Longrightarrow>\n    is_partition (as # rest) =\n    (is_partition_impl (as # rest) \\<noteq> None) \\<and>\n    (is_partition_impl (as # rest) = Some bs \\<longrightarrow>\n     bs = \\<Union> (set (as # rest)))\n 2. \\<not> is_partition rest \\<Longrightarrow>\n    is_partition (as # rest) =\n    (is_partition_impl (as # rest) \\<noteq> None) \\<and>\n    (is_partition_impl (as # rest) = Some bs \\<longrightarrow>\n     bs = \\<Union> (set (as # rest)))", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> is_partition rest\n\ngoal (1 subgoal):\n 1. is_partition (as # rest) =\n    (is_partition_impl (as # rest) \\<noteq> None) \\<and>\n    (is_partition_impl (as # rest) = Some bs \\<longrightarrow>\n     bs = \\<Union> (set (as # rest)))", "using Cons"], ["proof (prove)\nusing this:\n  \\<not> is_partition rest\n  is_partition rest = (is_partition_impl rest \\<noteq> None) \\<and>\n  (is_partition_impl rest = Some ?bs \\<longrightarrow>\n   ?bs = \\<Union> (set rest))\n\ngoal (1 subgoal):\n 1. is_partition (as # rest) =\n    (is_partition_impl (as # rest) \\<noteq> None) \\<and>\n    (is_partition_impl (as # rest) = Some bs \\<longrightarrow>\n     bs = \\<Union> (set (as # rest)))", "by auto"], ["proof (state)\nthis:\n  is_partition (as # rest) =\n  (is_partition_impl (as # rest) \\<noteq> None) \\<and>\n  (is_partition_impl (as # rest) = Some bs \\<longrightarrow>\n   bs = \\<Union> (set (as # rest)))\n\ngoal (1 subgoal):\n 1. is_partition rest \\<Longrightarrow>\n    is_partition (as # rest) =\n    (is_partition_impl (as # rest) \\<noteq> None) \\<and>\n    (is_partition_impl (as # rest) = Some bs \\<longrightarrow>\n     bs = \\<Union> (set (as # rest)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. is_partition rest \\<Longrightarrow>\n    is_partition (as # rest) =\n    (is_partition_impl (as # rest) \\<noteq> None) \\<and>\n    (is_partition_impl (as # rest) = Some bs \\<longrightarrow>\n     bs = \\<Union> (set (as # rest)))", "case True"], ["proof (state)\nthis:\n  is_partition rest\n\ngoal (1 subgoal):\n 1. is_partition rest \\<Longrightarrow>\n    is_partition (as # rest) =\n    (is_partition_impl (as # rest) \\<noteq> None) \\<and>\n    (is_partition_impl (as # rest) = Some bs \\<longrightarrow>\n     bs = \\<Union> (set (as # rest)))", "with Cons"], ["proof (chain)\npicking this:\n  is_partition rest = (is_partition_impl rest \\<noteq> None) \\<and>\n  (is_partition_impl rest = Some ?bs \\<longrightarrow>\n   ?bs = \\<Union> (set rest))\n  is_partition rest", "obtain c where rest: \"is_partition_impl rest = Some c\""], ["proof (prove)\nusing this:\n  is_partition rest = (is_partition_impl rest \\<noteq> None) \\<and>\n  (is_partition_impl rest = Some ?bs \\<longrightarrow>\n   ?bs = \\<Union> (set rest))\n  is_partition rest\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        is_partition_impl rest = Some c \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases \"is_partition_impl rest\", auto)"], ["proof (state)\nthis:\n  is_partition_impl rest = Some c\n\ngoal (1 subgoal):\n 1. is_partition rest \\<Longrightarrow>\n    is_partition (as # rest) =\n    (is_partition_impl (as # rest) \\<noteq> None) \\<and>\n    (is_partition_impl (as # rest) = Some bs \\<longrightarrow>\n     bs = \\<Union> (set (as # rest)))", "with Cons True"], ["proof (chain)\npicking this:\n  is_partition rest = (is_partition_impl rest \\<noteq> None) \\<and>\n  (is_partition_impl rest = Some ?bs \\<longrightarrow>\n   ?bs = \\<Union> (set rest))\n  is_partition rest\n  is_partition_impl rest = Some c", "show ?thesis"], ["proof (prove)\nusing this:\n  is_partition rest = (is_partition_impl rest \\<noteq> None) \\<and>\n  (is_partition_impl rest = Some ?bs \\<longrightarrow>\n   ?bs = \\<Union> (set rest))\n  is_partition rest\n  is_partition_impl rest = Some c\n\ngoal (1 subgoal):\n 1. is_partition (as # rest) =\n    (is_partition_impl (as # rest) \\<noteq> None) \\<and>\n    (is_partition_impl (as # rest) = Some bs \\<longrightarrow>\n     bs = \\<Union> (set (as # rest)))", "by auto"], ["proof (state)\nthis:\n  is_partition (as # rest) =\n  (is_partition_impl (as # rest) \\<noteq> None) \\<and>\n  (is_partition_impl (as # rest) = Some bs \\<longrightarrow>\n   bs = \\<Union> (set (as # rest)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  is_partition (as # rest) =\n  (is_partition_impl (as # rest) \\<noteq> None) \\<and>\n  (is_partition_impl (as # rest) = Some bs \\<longrightarrow>\n   bs = \\<Union> (set (as # rest)))\n\ngoal (1 subgoal):\n 1. \\<And>bs.\n       is_partition [] = (is_partition_impl [] \\<noteq> None) \\<and>\n       (is_partition_impl [] = Some bs \\<longrightarrow>\n        bs = \\<Union> (set []))", "qed auto"], ["proof (state)\nthis:\n  is_partition as = (is_partition_impl as \\<noteq> None) \\<and>\n  (is_partition_impl as = Some ?bs \\<longrightarrow>\n   ?bs = \\<Union> (set as))\n\ngoal (1 subgoal):\n 1. is_partition as = (is_partition_impl as \\<noteq> None)", "thus ?thesis"], ["proof (prove)\nusing this:\n  is_partition as = (is_partition_impl as \\<noteq> None) \\<and>\n  (is_partition_impl as = Some ?bs \\<longrightarrow>\n   ?bs = \\<Union> (set as))\n\ngoal (1 subgoal):\n 1. is_partition as = (is_partition_impl as \\<noteq> None)", "by blast"], ["proof (state)\nthis:\n  is_partition as = (is_partition_impl as \\<noteq> None)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "lemma case_prod_partition:\n  \"case_prod f (partition p xs) = f (filter p xs) (filter (Not \\<circ> p) xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (case partition p xs of (x, xa) \\<Rightarrow> f x xa) =\n    f (filter p xs) (filter (Not \\<circ> p) xs)", "by simp"], ["", "lemmas map_id[simp] = list.map_id"], ["", "subsection \\<open>merging functions\\<close>"], ["", "definition fun_merge :: \"('a \\<Rightarrow> 'b)list \\<Rightarrow> 'a set list \\<Rightarrow> 'a \\<Rightarrow> 'b\"\n  where \"fun_merge fs as a \\<equiv> (fs ! (LEAST i. i < length as \\<and> a \\<in> as ! i)) a\""], ["", "lemma fun_merge: assumes \n      i: \"i < length as\"\n  and a: \"a \\<in> as ! i\"\n  and ident: \"\\<And> i j a. i < length as \\<Longrightarrow> j < length as \\<Longrightarrow> a \\<in> as ! i \\<Longrightarrow> a \\<in> as ! j \\<Longrightarrow> (fs ! i) a = (fs ! j) a\"\n  shows \"fun_merge fs as a = (fs ! i) a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fun_merge fs as a = (fs ! i) a", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. fun_merge fs as a = (fs ! i) a", "let ?p = \"\\<lambda> i. i < length as \\<and> a \\<in> as ! i\""], ["proof (state)\ngoal (1 subgoal):\n 1. fun_merge fs as a = (fs ! i) a", "let ?l = \"LEAST i. ?p i\""], ["proof (state)\ngoal (1 subgoal):\n 1. fun_merge fs as a = (fs ! i) a", "have p: \"?p ?l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST i. i < length as \\<and> a \\<in> as ! i) < length as \\<and>\n    a \\<in> as ! (LEAST i. i < length as \\<and> a \\<in> as ! i)", "by (rule LeastI, insert i a, auto)"], ["proof (state)\nthis:\n  (LEAST i. i < length as \\<and> a \\<in> as ! i) < length as \\<and>\n  a \\<in> as ! (LEAST i. i < length as \\<and> a \\<in> as ! i)\n\ngoal (1 subgoal):\n 1. fun_merge fs as a = (fs ! i) a", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. fun_merge fs as a = (fs ! i) a", "unfolding fun_merge_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (fs ! (LEAST i. i < length as \\<and> a \\<in> as ! i)) a = (fs ! i) a", "by (rule ident[OF _ i _ a], insert p, auto)"], ["proof (state)\nthis:\n  fun_merge fs as a = (fs ! i) a\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma fun_merge_part: assumes \n      part: \"is_partition as\"\n  and i: \"i < length as\"\n  and a: \"a \\<in> as ! i\"\n  shows \"fun_merge fs as a = (fs ! i) a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fun_merge fs as a = (fs ! i) a", "proof(rule fun_merge[OF i a])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j a.\n       \\<lbrakk>i < length as; j < length as; a \\<in> as ! i;\n        a \\<in> as ! j\\<rbrakk>\n       \\<Longrightarrow> (fs ! i) a = (fs ! j) a", "fix i j a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j a.\n       \\<lbrakk>i < length as; j < length as; a \\<in> as ! i;\n        a \\<in> as ! j\\<rbrakk>\n       \\<Longrightarrow> (fs ! i) a = (fs ! j) a", "assume \"i < length as\" and \"j < length as\" and \"a \\<in> as ! i\" and \"a \\<in> as ! j\""], ["proof (state)\nthis:\n  i < length as\n  j < length as\n  a \\<in> as ! i\n  a \\<in> as ! j\n\ngoal (1 subgoal):\n 1. \\<And>i j a.\n       \\<lbrakk>i < length as; j < length as; a \\<in> as ! i;\n        a \\<in> as ! j\\<rbrakk>\n       \\<Longrightarrow> (fs ! i) a = (fs ! j) a", "hence \"i = j\""], ["proof (prove)\nusing this:\n  i < length as\n  j < length as\n  a \\<in> as ! i\n  a \\<in> as ! j\n\ngoal (1 subgoal):\n 1. i = j", "using part[unfolded is_partition_alt is_partition_alt_def]"], ["proof (prove)\nusing this:\n  i < length as\n  j < length as\n  a \\<in> as ! i\n  a \\<in> as ! j\n  \\<forall>i j.\n     i < length as \\<and>\n     j < length as \\<and> i \\<noteq> j \\<longrightarrow>\n     as ! i \\<inter> as ! j = {}\n\ngoal (1 subgoal):\n 1. i = j", "by (cases \"i = j\", auto)"], ["proof (state)\nthis:\n  i = j\n\ngoal (1 subgoal):\n 1. \\<And>i j a.\n       \\<lbrakk>i < length as; j < length as; a \\<in> as ! i;\n        a \\<in> as ! j\\<rbrakk>\n       \\<Longrightarrow> (fs ! i) a = (fs ! j) a", "thus \"(fs ! i) a = (fs ! j) a\""], ["proof (prove)\nusing this:\n  i = j\n\ngoal (1 subgoal):\n 1. (fs ! i) a = (fs ! j) a", "by simp"], ["proof (state)\nthis:\n  (fs ! i) a = (fs ! j) a\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma map_nth_conv: \"map f ss = map g ts \\<Longrightarrow> \\<forall>i < length ss. f(ss!i) = g(ts!i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map f ss = map g ts \\<Longrightarrow>\n    \\<forall>i<length ss. f (ss ! i) = g (ts ! i)", "proof (intro allI impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>map f ss = map g ts; i < length ss\\<rbrakk>\n       \\<Longrightarrow> f (ss ! i) = g (ts ! i)", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>map f ss = map g ts; i < length ss\\<rbrakk>\n       \\<Longrightarrow> f (ss ! i) = g (ts ! i)", "show \"map f ss = map g ts \\<Longrightarrow> i < length ss \\<Longrightarrow> f(ss!i) = g(ts!i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>map f ss = map g ts; i < length ss\\<rbrakk>\n    \\<Longrightarrow> f (ss ! i) = g (ts ! i)", "proof (induct ss arbitrary: i ts)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i ts.\n       \\<lbrakk>map f [] = map g ts; i < length []\\<rbrakk>\n       \\<Longrightarrow> f ([] ! i) = g (ts ! i)\n 2. \\<And>a ss i ts.\n       \\<lbrakk>\\<And>i ts.\n                   \\<lbrakk>map f ss = map g ts; i < length ss\\<rbrakk>\n                   \\<Longrightarrow> f (ss ! i) = g (ts ! i);\n        map f (a # ss) = map g ts; i < length (a # ss)\\<rbrakk>\n       \\<Longrightarrow> f ((a # ss) ! i) = g (ts ! i)", "case Nil"], ["proof (state)\nthis:\n  map f [] = map g ts\n  i < length []\n\ngoal (2 subgoals):\n 1. \\<And>i ts.\n       \\<lbrakk>map f [] = map g ts; i < length []\\<rbrakk>\n       \\<Longrightarrow> f ([] ! i) = g (ts ! i)\n 2. \\<And>a ss i ts.\n       \\<lbrakk>\\<And>i ts.\n                   \\<lbrakk>map f ss = map g ts; i < length ss\\<rbrakk>\n                   \\<Longrightarrow> f (ss ! i) = g (ts ! i);\n        map f (a # ss) = map g ts; i < length (a # ss)\\<rbrakk>\n       \\<Longrightarrow> f ((a # ss) ! i) = g (ts ! i)", "thus ?case"], ["proof (prove)\nusing this:\n  map f [] = map g ts\n  i < length []\n\ngoal (1 subgoal):\n 1. f ([] ! i) = g (ts ! i)", "by (induct ts) auto"], ["proof (state)\nthis:\n  f ([] ! i) = g (ts ! i)\n\ngoal (1 subgoal):\n 1. \\<And>a ss i ts.\n       \\<lbrakk>\\<And>i ts.\n                   \\<lbrakk>map f ss = map g ts; i < length ss\\<rbrakk>\n                   \\<Longrightarrow> f (ss ! i) = g (ts ! i);\n        map f (a # ss) = map g ts; i < length (a # ss)\\<rbrakk>\n       \\<Longrightarrow> f ((a # ss) ! i) = g (ts ! i)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a ss i ts.\n       \\<lbrakk>\\<And>i ts.\n                   \\<lbrakk>map f ss = map g ts; i < length ss\\<rbrakk>\n                   \\<Longrightarrow> f (ss ! i) = g (ts ! i);\n        map f (a # ss) = map g ts; i < length (a # ss)\\<rbrakk>\n       \\<Longrightarrow> f ((a # ss) ! i) = g (ts ! i)", "case (Cons s ss)"], ["proof (state)\nthis:\n  \\<lbrakk>map f ss = map g ?ts; ?i < length ss\\<rbrakk>\n  \\<Longrightarrow> f (ss ! ?i) = g (?ts ! ?i)\n  map f (s # ss) = map g ts\n  i < length (s # ss)\n\ngoal (1 subgoal):\n 1. \\<And>a ss i ts.\n       \\<lbrakk>\\<And>i ts.\n                   \\<lbrakk>map f ss = map g ts; i < length ss\\<rbrakk>\n                   \\<Longrightarrow> f (ss ! i) = g (ts ! i);\n        map f (a # ss) = map g ts; i < length (a # ss)\\<rbrakk>\n       \\<Longrightarrow> f ((a # ss) ! i) = g (ts ! i)", "thus ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>map f ss = map g ?ts; ?i < length ss\\<rbrakk>\n  \\<Longrightarrow> f (ss ! ?i) = g (?ts ! ?i)\n  map f (s # ss) = map g ts\n  i < length (s # ss)\n\ngoal (1 subgoal):\n 1. f ((s # ss) ! i) = g (ts ! i)", "by (induct ts, simp, (cases i, auto))"], ["proof (state)\nthis:\n  f ((s # ss) ! i) = g (ts ! i)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>map f ss = map g ts; i < length ss\\<rbrakk>\n  \\<Longrightarrow> f (ss ! i) = g (ts ! i)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma distinct_take_drop:\n  assumes dist: \"distinct vs\" and len: \"i < length vs\" shows \"distinct(take i vs @ drop (Suc i) vs)\" (is \"distinct(?xs@?ys)\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (take i vs @ drop (Suc i) vs)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. distinct (take i vs @ drop (Suc i) vs)", "from id_take_nth_drop[OF len]"], ["proof (chain)\npicking this:\n  vs = take i vs @ vs ! i # drop (Suc i) vs", "have vs[symmetric]: \"vs = ?xs @ vs!i # ?ys\""], ["proof (prove)\nusing this:\n  vs = take i vs @ vs ! i # drop (Suc i) vs\n\ngoal (1 subgoal):\n 1. vs = take i vs @ vs ! i # drop (Suc i) vs", "."], ["proof (state)\nthis:\n  take i vs @ vs ! i # drop (Suc i) vs = vs\n\ngoal (1 subgoal):\n 1. distinct (take i vs @ drop (Suc i) vs)", "with dist"], ["proof (chain)\npicking this:\n  distinct vs\n  take i vs @ vs ! i # drop (Suc i) vs = vs", "have \"distinct ?xs\" and \"distinct(vs!i#?ys)\" and \"set ?xs \\<inter> set(vs!i#?ys) = {}\""], ["proof (prove)\nusing this:\n  distinct vs\n  take i vs @ vs ! i # drop (Suc i) vs = vs\n\ngoal (1 subgoal):\n 1. distinct (take i vs) &&&\n    distinct (vs ! i # drop (Suc i) vs) &&&\n    set (take i vs) \\<inter> set (vs ! i # drop (Suc i) vs) = {}", "using distinct_append[of ?xs \"vs!i#?ys\"]"], ["proof (prove)\nusing this:\n  distinct vs\n  take i vs @ vs ! i # drop (Suc i) vs = vs\n  distinct (take i vs @ vs ! i # drop (Suc i) vs) =\n  (distinct (take i vs) \\<and>\n   distinct (vs ! i # drop (Suc i) vs) \\<and>\n   set (take i vs) \\<inter> set (vs ! i # drop (Suc i) vs) = {})\n\ngoal (1 subgoal):\n 1. distinct (take i vs) &&&\n    distinct (vs ! i # drop (Suc i) vs) &&&\n    set (take i vs) \\<inter> set (vs ! i # drop (Suc i) vs) = {}", "by auto"], ["proof (state)\nthis:\n  distinct (take i vs)\n  distinct (vs ! i # drop (Suc i) vs)\n  set (take i vs) \\<inter> set (vs ! i # drop (Suc i) vs) = {}\n\ngoal (1 subgoal):\n 1. distinct (take i vs @ drop (Suc i) vs)", "hence \"distinct ?ys\" and \"set ?xs \\<inter> set ?ys = {}\""], ["proof (prove)\nusing this:\n  distinct (take i vs)\n  distinct (vs ! i # drop (Suc i) vs)\n  set (take i vs) \\<inter> set (vs ! i # drop (Suc i) vs) = {}\n\ngoal (1 subgoal):\n 1. distinct (drop (Suc i) vs) &&&\n    set (take i vs) \\<inter> set (drop (Suc i) vs) = {}", "by auto"], ["proof (state)\nthis:\n  distinct (drop (Suc i) vs)\n  set (take i vs) \\<inter> set (drop (Suc i) vs) = {}\n\ngoal (1 subgoal):\n 1. distinct (take i vs @ drop (Suc i) vs)", "with \\<open>distinct ?xs\\<close>"], ["proof (chain)\npicking this:\n  distinct (take i vs)\n  distinct (drop (Suc i) vs)\n  set (take i vs) \\<inter> set (drop (Suc i) vs) = {}", "show ?thesis"], ["proof (prove)\nusing this:\n  distinct (take i vs)\n  distinct (drop (Suc i) vs)\n  set (take i vs) \\<inter> set (drop (Suc i) vs) = {}\n\ngoal (1 subgoal):\n 1. distinct (take i vs @ drop (Suc i) vs)", "using distinct_append[of ?xs ?ys] vs"], ["proof (prove)\nusing this:\n  distinct (take i vs)\n  distinct (drop (Suc i) vs)\n  set (take i vs) \\<inter> set (drop (Suc i) vs) = {}\n  distinct (take i vs @ drop (Suc i) vs) =\n  (distinct (take i vs) \\<and>\n   distinct (drop (Suc i) vs) \\<and>\n   set (take i vs) \\<inter> set (drop (Suc i) vs) = {})\n  take i vs @ vs ! i # drop (Suc i) vs = vs\n\ngoal (1 subgoal):\n 1. distinct (take i vs @ drop (Suc i) vs)", "by simp"], ["proof (state)\nthis:\n  distinct (take i vs @ drop (Suc i) vs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma map_nth_eq_conv:\n  assumes len: \"length xs = length ys\"\n  shows \"(map f xs = ys) = (\\<forall>i<length ys. f (xs ! i) = ys ! i)\" (is \"?l = ?r\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (map f xs = ys) = (\\<forall>i<length ys. f (xs ! i) = ys ! i)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (map f xs = ys) = (\\<forall>i<length ys. f (xs ! i) = ys ! i)", "have \"(map f xs = ys) = (map f xs = map id ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (map f xs = ys) = (map f xs = map id ys)", "by auto"], ["proof (state)\nthis:\n  (map f xs = ys) = (map f xs = map id ys)\n\ngoal (1 subgoal):\n 1. (map f xs = ys) = (\\<forall>i<length ys. f (xs ! i) = ys ! i)", "also"], ["proof (state)\nthis:\n  (map f xs = ys) = (map f xs = map id ys)\n\ngoal (1 subgoal):\n 1. (map f xs = ys) = (\\<forall>i<length ys. f (xs ! i) = ys ! i)", "have \"... = (\\<forall> i < length ys. f (xs ! i) = id (ys ! i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (map f xs = map id ys) =\n    (\\<forall>i<length ys. f (xs ! i) = id (ys ! i))", "using map_nth_conv[of f xs id ys] nth_map_conv[OF len, of f id]"], ["proof (prove)\nusing this:\n  map f xs = map id ys \\<Longrightarrow>\n  \\<forall>i<length xs. f (xs ! i) = id (ys ! i)\n  \\<forall>i<length xs. f (xs ! i) = id (ys ! i) \\<Longrightarrow>\n  map f xs = map id ys\n\ngoal (1 subgoal):\n 1. (map f xs = map id ys) =\n    (\\<forall>i<length ys. f (xs ! i) = id (ys ! i))", "unfolding len"], ["proof (prove)\nusing this:\n  map f xs = map id ys \\<Longrightarrow>\n  \\<forall>i<length ys. f (xs ! i) = id (ys ! i)\n  \\<forall>i<length ys. f (xs ! i) = id (ys ! i) \\<Longrightarrow>\n  map f xs = map id ys\n\ngoal (1 subgoal):\n 1. (map f xs = map id ys) =\n    (\\<forall>i<length ys. f (xs ! i) = id (ys ! i))", "by blast"], ["proof (state)\nthis:\n  (map f xs = map id ys) = (\\<forall>i<length ys. f (xs ! i) = id (ys ! i))\n\ngoal (1 subgoal):\n 1. (map f xs = ys) = (\\<forall>i<length ys. f (xs ! i) = ys ! i)", "finally"], ["proof (chain)\npicking this:\n  (map f xs = ys) = (\\<forall>i<length ys. f (xs ! i) = id (ys ! i))", "show ?thesis"], ["proof (prove)\nusing this:\n  (map f xs = ys) = (\\<forall>i<length ys. f (xs ! i) = id (ys ! i))\n\ngoal (1 subgoal):\n 1. (map f xs = ys) = (\\<forall>i<length ys. f (xs ! i) = ys ! i)", "by auto"], ["proof (state)\nthis:\n  (map f xs = ys) = (\\<forall>i<length ys. f (xs ! i) = ys ! i)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma map_upt_len_conv: \n  \"map (\\<lambda> i . f (xs!i)) [0..<length xs] = map f xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>i. f (xs ! i)) [0..<length xs] = map f xs", "by (rule nth_equalityI, auto)"], ["", "lemma map_upt_add':\n  \"map f [a..<a+b] = map (\\<lambda> i. f (a + i)) [0..<b]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map f [a..<a + b] = map (\\<lambda>i. f (a + i)) [0..<b]", "by (induct b, auto)"], ["", "definition generate_lists :: \"nat \\<Rightarrow> 'a list \\<Rightarrow> 'a list list\"\n  where \"generate_lists n xs \\<equiv> concat_lists (map (\\<lambda> _. xs) [0 ..< n])\""], ["", "lemma set_generate_lists[simp]: \"set (generate_lists n xs) = {as. length as = n \\<and> set as \\<subseteq> set xs}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (generate_lists n xs) =\n    {as. length as = n \\<and> set as \\<subseteq> set xs}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. set (generate_lists n xs) =\n    {as. length as = n \\<and> set as \\<subseteq> set xs}", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. set (generate_lists n xs) =\n    {as. length as = n \\<and> set as \\<subseteq> set xs}", "fix as"], ["proof (state)\ngoal (1 subgoal):\n 1. set (generate_lists n xs) =\n    {as. length as = n \\<and> set as \\<subseteq> set xs}", "have \"(length as = n \\<and> (\\<forall>i<n. as ! i \\<in> set xs)) = (length as = n \\<and> set as \\<subseteq> set xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (length as = n \\<and> (\\<forall>i<n. as ! i \\<in> set xs)) =\n    (length as = n \\<and> set as \\<subseteq> set xs)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (length as = n \\<and> (\\<forall>i<n. as ! i \\<in> set xs)) =\n    (length as = n \\<and> set as \\<subseteq> set xs)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. (length as = n \\<and> (\\<forall>i<n. as ! i \\<in> set xs)) =\n    (length as = n \\<and> set as \\<subseteq> set xs)", "assume \"length as = n\""], ["proof (state)\nthis:\n  length as = n\n\ngoal (1 subgoal):\n 1. (length as = n \\<and> (\\<forall>i<n. as ! i \\<in> set xs)) =\n    (length as = n \\<and> set as \\<subseteq> set xs)", "hence n: \"n = length as\""], ["proof (prove)\nusing this:\n  length as = n\n\ngoal (1 subgoal):\n 1. n = length as", "by auto"], ["proof (state)\nthis:\n  n = length as\n\ngoal (1 subgoal):\n 1. (length as = n \\<and> (\\<forall>i<n. as ! i \\<in> set xs)) =\n    (length as = n \\<and> set as \\<subseteq> set xs)", "have \"(\\<forall>i<n. as ! i \\<in> set xs) = (set as \\<subseteq> set xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>i<n. as ! i \\<in> set xs) = (set as \\<subseteq> set xs)", "unfolding n"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>i<length as. as ! i \\<in> set xs) =\n    (set as \\<subseteq> set xs)", "unfolding all_set_conv_all_nth[of as \"\\<lambda> x. x \\<in> set xs\", symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x\\<in>set as. x \\<in> set xs) = (set as \\<subseteq> set xs)", "by auto"], ["proof (state)\nthis:\n  (\\<forall>i<n. as ! i \\<in> set xs) = (set as \\<subseteq> set xs)\n\ngoal (1 subgoal):\n 1. (length as = n \\<and> (\\<forall>i<n. as ! i \\<in> set xs)) =\n    (length as = n \\<and> set as \\<subseteq> set xs)", "}"], ["proof (state)\nthis:\n  length as = n \\<Longrightarrow>\n  (\\<forall>i<n. as ! i \\<in> set xs) = (set as \\<subseteq> set xs)\n\ngoal (1 subgoal):\n 1. (length as = n \\<and> (\\<forall>i<n. as ! i \\<in> set xs)) =\n    (length as = n \\<and> set as \\<subseteq> set xs)", "thus ?thesis"], ["proof (prove)\nusing this:\n  length as = n \\<Longrightarrow>\n  (\\<forall>i<n. as ! i \\<in> set xs) = (set as \\<subseteq> set xs)\n\ngoal (1 subgoal):\n 1. (length as = n \\<and> (\\<forall>i<n. as ! i \\<in> set xs)) =\n    (length as = n \\<and> set as \\<subseteq> set xs)", "by auto"], ["proof (state)\nthis:\n  (length as = n \\<and> (\\<forall>i<n. as ! i \\<in> set xs)) =\n  (length as = n \\<and> set as \\<subseteq> set xs)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (length as = n \\<and> (\\<forall>i<n. as ! i \\<in> set xs)) =\n  (length as = n \\<and> set as \\<subseteq> set xs)\n\ngoal (1 subgoal):\n 1. set (generate_lists n xs) =\n    {as. length as = n \\<and> set as \\<subseteq> set xs}", "}"], ["proof (state)\nthis:\n  (length ?as2 = n \\<and> (\\<forall>i<n. ?as2 ! i \\<in> set xs)) =\n  (length ?as2 = n \\<and> set ?as2 \\<subseteq> set xs)\n\ngoal (1 subgoal):\n 1. set (generate_lists n xs) =\n    {as. length as = n \\<and> set as \\<subseteq> set xs}", "thus ?thesis"], ["proof (prove)\nusing this:\n  (length ?as2 = n \\<and> (\\<forall>i<n. ?as2 ! i \\<in> set xs)) =\n  (length ?as2 = n \\<and> set ?as2 \\<subseteq> set xs)\n\ngoal (1 subgoal):\n 1. set (generate_lists n xs) =\n    {as. length as = n \\<and> set as \\<subseteq> set xs}", "unfolding generate_lists_def"], ["proof (prove)\nusing this:\n  (length ?as2 = n \\<and> (\\<forall>i<n. ?as2 ! i \\<in> set xs)) =\n  (length ?as2 = n \\<and> set ?as2 \\<subseteq> set xs)\n\ngoal (1 subgoal):\n 1. set (concat_lists (map (\\<lambda>_. xs) [0..<n])) =\n    {as. length as = n \\<and> set as \\<subseteq> set xs}", "unfolding set_concat_lists"], ["proof (prove)\nusing this:\n  (length ?as2 = n \\<and> (\\<forall>i<n. ?as2 ! i \\<in> set xs)) =\n  (length ?as2 = n \\<and> set ?as2 \\<subseteq> set xs)\n\ngoal (1 subgoal):\n 1. {as.\n     length as = length (map (\\<lambda>_. xs) [0..<n]) \\<and>\n     (\\<forall>i<length (map (\\<lambda>_. xs) [0..<n]).\n         as ! i \\<in> set (map (\\<lambda>_. xs) [0..<n] ! i))} =\n    {as. length as = n \\<and> set as \\<subseteq> set xs}", "by auto"], ["proof (state)\nthis:\n  set (generate_lists n xs) =\n  {as. length as = n \\<and> set as \\<subseteq> set xs}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma nth_append_take:\n  assumes \"i \\<le> length xs\" shows \"(take i xs @ y#ys)!i = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (take i xs @ y # ys) ! i = y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (take i xs @ y # ys) ! i = y", "from assms"], ["proof (chain)\npicking this:\n  i \\<le> length xs", "have a: \"length(take i xs) = i\""], ["proof (prove)\nusing this:\n  i \\<le> length xs\n\ngoal (1 subgoal):\n 1. length (take i xs) = i", "by simp"], ["proof (state)\nthis:\n  length (take i xs) = i\n\ngoal (1 subgoal):\n 1. (take i xs @ y # ys) ! i = y", "have \"(take i xs @ y#ys)!(length(take i xs)) = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (take i xs @ y # ys) ! length (take i xs) = y", "by (rule nth_append_length)"], ["proof (state)\nthis:\n  (take i xs @ y # ys) ! length (take i xs) = y\n\ngoal (1 subgoal):\n 1. (take i xs @ y # ys) ! i = y", "thus ?thesis"], ["proof (prove)\nusing this:\n  (take i xs @ y # ys) ! length (take i xs) = y\n\ngoal (1 subgoal):\n 1. (take i xs @ y # ys) ! i = y", "unfolding a"], ["proof (prove)\nusing this:\n  (take i xs @ y # ys) ! i = y\n\ngoal (1 subgoal):\n 1. (take i xs @ y # ys) ! i = y", "."], ["proof (state)\nthis:\n  (take i xs @ y # ys) ! i = y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma nth_append_take_is_nth_conv:\n  assumes \"i < j\" and \"j \\<le> length xs\" shows \"(take j xs @ ys)!i = xs!i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (take j xs @ ys) ! i = xs ! i", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (take j xs @ ys) ! i = xs ! i", "from assms"], ["proof (chain)\npicking this:\n  i < j\n  j \\<le> length xs", "have \"i < length(take j xs)\""], ["proof (prove)\nusing this:\n  i < j\n  j \\<le> length xs\n\ngoal (1 subgoal):\n 1. i < length (take j xs)", "by simp"], ["proof (state)\nthis:\n  i < length (take j xs)\n\ngoal (1 subgoal):\n 1. (take j xs @ ys) ! i = xs ! i", "hence \"(take j xs @ ys)!i = take j xs ! i\""], ["proof (prove)\nusing this:\n  i < length (take j xs)\n\ngoal (1 subgoal):\n 1. (take j xs @ ys) ! i = take j xs ! i", "unfolding nth_append"], ["proof (prove)\nusing this:\n  i < length (take j xs)\n\ngoal (1 subgoal):\n 1. (if i < length (take j xs) then take j xs ! i\n     else ys ! (i - length (take j xs))) =\n    take j xs ! i", "by simp"], ["proof (state)\nthis:\n  (take j xs @ ys) ! i = take j xs ! i\n\ngoal (1 subgoal):\n 1. (take j xs @ ys) ! i = xs ! i", "thus ?thesis"], ["proof (prove)\nusing this:\n  (take j xs @ ys) ! i = take j xs ! i\n\ngoal (1 subgoal):\n 1. (take j xs @ ys) ! i = xs ! i", "unfolding nth_take[OF assms(1)]"], ["proof (prove)\nusing this:\n  (take j xs @ ys) ! i = xs ! i\n\ngoal (1 subgoal):\n 1. (take j xs @ ys) ! i = xs ! i", "."], ["proof (state)\nthis:\n  (take j xs @ ys) ! i = xs ! i\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma nth_append_drop_is_nth_conv:\n  assumes \"j < i\" and \"j \\<le> length xs\" and \"i \\<le> length xs\"\n  shows \"(take j xs @ y # drop (Suc j) xs)!i = xs!i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (take j xs @ y # drop (Suc j) xs) ! i = xs ! i", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (take j xs @ y # drop (Suc j) xs) ! i = xs ! i", "from \\<open>j < i\\<close>"], ["proof (chain)\npicking this:\n  j < i", "obtain n where ij: \"Suc(j + n) = i\""], ["proof (prove)\nusing this:\n  j < i\n\ngoal (1 subgoal):\n 1. (\\<And>n. Suc (j + n) = i \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using less_imp_Suc_add"], ["proof (prove)\nusing this:\n  j < i\n  ?m < ?n \\<Longrightarrow> \\<exists>k. ?n = Suc (?m + k)\n\ngoal (1 subgoal):\n 1. (\\<And>n. Suc (j + n) = i \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  Suc (j + n) = i\n\ngoal (1 subgoal):\n 1. (take j xs @ y # drop (Suc j) xs) ! i = xs ! i", "with assms"], ["proof (chain)\npicking this:\n  j < i\n  j \\<le> length xs\n  i \\<le> length xs\n  Suc (j + n) = i", "have i: \"i = length(take j xs) + Suc n\""], ["proof (prove)\nusing this:\n  j < i\n  j \\<le> length xs\n  i \\<le> length xs\n  Suc (j + n) = i\n\ngoal (1 subgoal):\n 1. i = length (take j xs) + Suc n", "by auto"], ["proof (state)\nthis:\n  i = length (take j xs) + Suc n\n\ngoal (1 subgoal):\n 1. (take j xs @ y # drop (Suc j) xs) ! i = xs ! i", "have len: \"Suc j + n \\<le> length xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc j + n \\<le> length xs", "using assms i"], ["proof (prove)\nusing this:\n  j < i\n  j \\<le> length xs\n  i \\<le> length xs\n  i = length (take j xs) + Suc n\n\ngoal (1 subgoal):\n 1. Suc j + n \\<le> length xs", "by auto"], ["proof (state)\nthis:\n  Suc j + n \\<le> length xs\n\ngoal (1 subgoal):\n 1. (take j xs @ y # drop (Suc j) xs) ! i = xs ! i", "have \"(take j xs @ y # drop (Suc j) xs)!i =\n    (y # drop (Suc j) xs)!(i - length(take j xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (take j xs @ y # drop (Suc j) xs) ! i =\n    (y # drop (Suc j) xs) ! (i - length (take j xs))", "unfolding nth_append i"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if length (take j xs) + Suc n < length (take j xs)\n     then take j xs ! (length (take j xs) + Suc n)\n     else (y # drop (Suc j) xs) !\n          (length (take j xs) + Suc n - length (take j xs))) =\n    (y # drop (Suc j) xs) !\n    (length (take j xs) + Suc n - length (take j xs))", "by auto"], ["proof (state)\nthis:\n  (take j xs @ y # drop (Suc j) xs) ! i =\n  (y # drop (Suc j) xs) ! (i - length (take j xs))\n\ngoal (1 subgoal):\n 1. (take j xs @ y # drop (Suc j) xs) ! i = xs ! i", "also"], ["proof (state)\nthis:\n  (take j xs @ y # drop (Suc j) xs) ! i =\n  (y # drop (Suc j) xs) ! (i - length (take j xs))\n\ngoal (1 subgoal):\n 1. (take j xs @ y # drop (Suc j) xs) ! i = xs ! i", "have \"\\<dots> = (y # drop (Suc j) xs)!(Suc n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (y # drop (Suc j) xs) ! (i - length (take j xs)) =\n    (y # drop (Suc j) xs) ! Suc n", "unfolding i"], ["proof (prove)\ngoal (1 subgoal):\n 1. (y # drop (Suc j) xs) !\n    (length (take j xs) + Suc n - length (take j xs)) =\n    (y # drop (Suc j) xs) ! Suc n", "by simp"], ["proof (state)\nthis:\n  (y # drop (Suc j) xs) ! (i - length (take j xs)) =\n  (y # drop (Suc j) xs) ! Suc n\n\ngoal (1 subgoal):\n 1. (take j xs @ y # drop (Suc j) xs) ! i = xs ! i", "also"], ["proof (state)\nthis:\n  (y # drop (Suc j) xs) ! (i - length (take j xs)) =\n  (y # drop (Suc j) xs) ! Suc n\n\ngoal (1 subgoal):\n 1. (take j xs @ y # drop (Suc j) xs) ! i = xs ! i", "have \"\\<dots> = (drop (Suc j) xs)!n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (y # drop (Suc j) xs) ! Suc n = drop (Suc j) xs ! n", "by simp"], ["proof (state)\nthis:\n  (y # drop (Suc j) xs) ! Suc n = drop (Suc j) xs ! n\n\ngoal (1 subgoal):\n 1. (take j xs @ y # drop (Suc j) xs) ! i = xs ! i", "finally"], ["proof (chain)\npicking this:\n  (take j xs @ y # drop (Suc j) xs) ! i = drop (Suc j) xs ! n", "show ?thesis"], ["proof (prove)\nusing this:\n  (take j xs @ y # drop (Suc j) xs) ! i = drop (Suc j) xs ! n\n\ngoal (1 subgoal):\n 1. (take j xs @ y # drop (Suc j) xs) ! i = xs ! i", "using ij len"], ["proof (prove)\nusing this:\n  (take j xs @ y # drop (Suc j) xs) ! i = drop (Suc j) xs ! n\n  Suc (j + n) = i\n  Suc j + n \\<le> length xs\n\ngoal (1 subgoal):\n 1. (take j xs @ y # drop (Suc j) xs) ! i = xs ! i", "by simp"], ["proof (state)\nthis:\n  (take j xs @ y # drop (Suc j) xs) ! i = xs ! i\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma nth_append_take_drop_is_nth_conv: \n assumes \"i \\<le> length xs\" and \"j \\<le> length xs\" and \"i \\<noteq> j\" \n shows \"(take j xs @ y # drop (Suc j) xs)!i = xs!i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (take j xs @ y # drop (Suc j) xs) ! i = xs ! i", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (take j xs @ y # drop (Suc j) xs) ! i = xs ! i", "from assms"], ["proof (chain)\npicking this:\n  i \\<le> length xs\n  j \\<le> length xs\n  i \\<noteq> j", "have \"i < j \\<or> i > j\""], ["proof (prove)\nusing this:\n  i \\<le> length xs\n  j \\<le> length xs\n  i \\<noteq> j\n\ngoal (1 subgoal):\n 1. i < j \\<or> j < i", "by auto"], ["proof (state)\nthis:\n  i < j \\<or> j < i\n\ngoal (1 subgoal):\n 1. (take j xs @ y # drop (Suc j) xs) ! i = xs ! i", "thus ?thesis"], ["proof (prove)\nusing this:\n  i < j \\<or> j < i\n\ngoal (1 subgoal):\n 1. (take j xs @ y # drop (Suc j) xs) ! i = xs ! i", "using assms"], ["proof (prove)\nusing this:\n  i < j \\<or> j < i\n  i \\<le> length xs\n  j \\<le> length xs\n  i \\<noteq> j\n\ngoal (1 subgoal):\n 1. (take j xs @ y # drop (Suc j) xs) ! i = xs ! i", "by (auto simp: nth_append_take_is_nth_conv nth_append_drop_is_nth_conv)"], ["proof (state)\nthis:\n  (take j xs @ y # drop (Suc j) xs) ! i = xs ! i\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma take_drop_imp_nth: \"\\<lbrakk>take i ss @ x # drop (Suc i) ss = ss\\<rbrakk> \\<Longrightarrow> x = ss!i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. take i ss @ x # drop (Suc i) ss = ss \\<Longrightarrow> x = ss ! i", "proof (induct ss arbitrary: i)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i.\n       take i [] @ x # drop (Suc i) [] = [] \\<Longrightarrow> x = [] ! i\n 2. \\<And>a ss i.\n       \\<lbrakk>\\<And>i.\n                   take i ss @ x # drop (Suc i) ss = ss \\<Longrightarrow>\n                   x = ss ! i;\n        take i (a # ss) @ x # drop (Suc i) (a # ss) = a # ss\\<rbrakk>\n       \\<Longrightarrow> x = (a # ss) ! i", "case (Cons s ss)"], ["proof (state)\nthis:\n  take ?i ss @ x # drop (Suc ?i) ss = ss \\<Longrightarrow> x = ss ! ?i\n  take i (s # ss) @ x # drop (Suc i) (s # ss) = s # ss\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       take i [] @ x # drop (Suc i) [] = [] \\<Longrightarrow> x = [] ! i\n 2. \\<And>a ss i.\n       \\<lbrakk>\\<And>i.\n                   take i ss @ x # drop (Suc i) ss = ss \\<Longrightarrow>\n                   x = ss ! i;\n        take i (a # ss) @ x # drop (Suc i) (a # ss) = a # ss\\<rbrakk>\n       \\<Longrightarrow> x = (a # ss) ! i", "from \\<open>take i (s#ss) @ x # drop (Suc i) (s#ss) = (s#ss)\\<close>"], ["proof (chain)\npicking this:\n  take i (s # ss) @ x # drop (Suc i) (s # ss) = s # ss", "show ?case"], ["proof (prove)\nusing this:\n  take i (s # ss) @ x # drop (Suc i) (s # ss) = s # ss\n\ngoal (1 subgoal):\n 1. x = (s # ss) ! i", "proof (induct i)"], ["proof (state)\ngoal (2 subgoals):\n 1. take 0 (s # ss) @ x # drop (Suc 0) (s # ss) = s # ss \\<Longrightarrow>\n    x = (s # ss) ! 0\n 2. \\<And>i.\n       \\<lbrakk>take i (s # ss) @ x # drop (Suc i) (s # ss) =\n                s # ss \\<Longrightarrow>\n                x = (s # ss) ! i;\n        take (Suc i) (s # ss) @ x # drop (Suc (Suc i)) (s # ss) =\n        s # ss\\<rbrakk>\n       \\<Longrightarrow> x = (s # ss) ! Suc i", "case (Suc i)"], ["proof (state)\nthis:\n  take i (s # ss) @ x # drop (Suc i) (s # ss) = s # ss \\<Longrightarrow>\n  x = (s # ss) ! i\n  take (Suc i) (s # ss) @ x # drop (Suc (Suc i)) (s # ss) = s # ss\n\ngoal (2 subgoals):\n 1. take 0 (s # ss) @ x # drop (Suc 0) (s # ss) = s # ss \\<Longrightarrow>\n    x = (s # ss) ! 0\n 2. \\<And>i.\n       \\<lbrakk>take i (s # ss) @ x # drop (Suc i) (s # ss) =\n                s # ss \\<Longrightarrow>\n                x = (s # ss) ! i;\n        take (Suc i) (s # ss) @ x # drop (Suc (Suc i)) (s # ss) =\n        s # ss\\<rbrakk>\n       \\<Longrightarrow> x = (s # ss) ! Suc i", "from Cons"], ["proof (chain)\npicking this:\n  take ?i ss @ x # drop (Suc ?i) ss = ss \\<Longrightarrow> x = ss ! ?i\n  take ia__ (s # ss) @ x # drop (Suc ia__) (s # ss) = s # ss", "have IH: \"take i ss @ x # drop (Suc i) ss = ss \\<Longrightarrow> x = ss!i\""], ["proof (prove)\nusing this:\n  take ?i ss @ x # drop (Suc ?i) ss = ss \\<Longrightarrow> x = ss ! ?i\n  take ia__ (s # ss) @ x # drop (Suc ia__) (s # ss) = s # ss\n\ngoal (1 subgoal):\n 1. take i ss @ x # drop (Suc i) ss = ss \\<Longrightarrow> x = ss ! i", "by auto"], ["proof (state)\nthis:\n  take i ss @ x # drop (Suc i) ss = ss \\<Longrightarrow> x = ss ! i\n\ngoal (2 subgoals):\n 1. take 0 (s # ss) @ x # drop (Suc 0) (s # ss) = s # ss \\<Longrightarrow>\n    x = (s # ss) ! 0\n 2. \\<And>i.\n       \\<lbrakk>take i (s # ss) @ x # drop (Suc i) (s # ss) =\n                s # ss \\<Longrightarrow>\n                x = (s # ss) ! i;\n        take (Suc i) (s # ss) @ x # drop (Suc (Suc i)) (s # ss) =\n        s # ss\\<rbrakk>\n       \\<Longrightarrow> x = (s # ss) ! Suc i", "from Suc"], ["proof (chain)\npicking this:\n  take i (s # ss) @ x # drop (Suc i) (s # ss) = s # ss \\<Longrightarrow>\n  x = (s # ss) ! i\n  take (Suc i) (s # ss) @ x # drop (Suc (Suc i)) (s # ss) = s # ss", "have \"take i ss @ x # drop (Suc i) ss = ss\""], ["proof (prove)\nusing this:\n  take i (s # ss) @ x # drop (Suc i) (s # ss) = s # ss \\<Longrightarrow>\n  x = (s # ss) ! i\n  take (Suc i) (s # ss) @ x # drop (Suc (Suc i)) (s # ss) = s # ss\n\ngoal (1 subgoal):\n 1. take i ss @ x # drop (Suc i) ss = ss", "by auto"], ["proof (state)\nthis:\n  take i ss @ x # drop (Suc i) ss = ss\n\ngoal (2 subgoals):\n 1. take 0 (s # ss) @ x # drop (Suc 0) (s # ss) = s # ss \\<Longrightarrow>\n    x = (s # ss) ! 0\n 2. \\<And>i.\n       \\<lbrakk>take i (s # ss) @ x # drop (Suc i) (s # ss) =\n                s # ss \\<Longrightarrow>\n                x = (s # ss) ! i;\n        take (Suc i) (s # ss) @ x # drop (Suc (Suc i)) (s # ss) =\n        s # ss\\<rbrakk>\n       \\<Longrightarrow> x = (s # ss) ! Suc i", "with IH"], ["proof (chain)\npicking this:\n  take i ss @ x # drop (Suc i) ss = ss \\<Longrightarrow> x = ss ! i\n  take i ss @ x # drop (Suc i) ss = ss", "show ?case"], ["proof (prove)\nusing this:\n  take i ss @ x # drop (Suc i) ss = ss \\<Longrightarrow> x = ss ! i\n  take i ss @ x # drop (Suc i) ss = ss\n\ngoal (1 subgoal):\n 1. x = (s # ss) ! Suc i", "by auto"], ["proof (state)\nthis:\n  x = (s # ss) ! Suc i\n\ngoal (1 subgoal):\n 1. take 0 (s # ss) @ x # drop (Suc 0) (s # ss) = s # ss \\<Longrightarrow>\n    x = (s # ss) ! 0", "qed auto"], ["proof (state)\nthis:\n  x = (s # ss) ! i\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       take i [] @ x # drop (Suc i) [] = [] \\<Longrightarrow> x = [] ! i", "qed auto"], ["", "lemma take_drop_update_first: assumes \"j < length ds\" and \"length cs = length ds\"\n  shows \"(take j ds @ drop j cs)[j := ds ! j] = take (Suc j) ds @ drop (Suc j) cs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (take j ds @ drop j cs)[j := ds ! j] = take (Suc j) ds @ drop (Suc j) cs", "using assms"], ["proof (prove)\nusing this:\n  j < length ds\n  length cs = length ds\n\ngoal (1 subgoal):\n 1. (take j ds @ drop j cs)[j := ds ! j] = take (Suc j) ds @ drop (Suc j) cs", "proof (induct j arbitrary: ds cs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ds cs.\n       \\<lbrakk>0 < length ds; length cs = length ds\\<rbrakk>\n       \\<Longrightarrow> (take 0 ds @ drop 0 cs)[0 := ds ! 0] =\n                         take (Suc 0) ds @ drop (Suc 0) cs\n 2. \\<And>j ds cs.\n       \\<lbrakk>\\<And>ds cs.\n                   \\<lbrakk>j < length ds; length cs = length ds\\<rbrakk>\n                   \\<Longrightarrow> (take j ds @ drop j cs)[j := ds ! j] =\n                                     take (Suc j) ds @ drop (Suc j) cs;\n        Suc j < length ds; length cs = length ds\\<rbrakk>\n       \\<Longrightarrow> (take (Suc j) ds @ drop (Suc j) cs)\n                         [Suc j := ds ! Suc j] =\n                         take (Suc (Suc j)) ds @ drop (Suc (Suc j)) cs", "case 0"], ["proof (state)\nthis:\n  0 < length ds\n  length cs = length ds\n\ngoal (2 subgoals):\n 1. \\<And>ds cs.\n       \\<lbrakk>0 < length ds; length cs = length ds\\<rbrakk>\n       \\<Longrightarrow> (take 0 ds @ drop 0 cs)[0 := ds ! 0] =\n                         take (Suc 0) ds @ drop (Suc 0) cs\n 2. \\<And>j ds cs.\n       \\<lbrakk>\\<And>ds cs.\n                   \\<lbrakk>j < length ds; length cs = length ds\\<rbrakk>\n                   \\<Longrightarrow> (take j ds @ drop j cs)[j := ds ! j] =\n                                     take (Suc j) ds @ drop (Suc j) cs;\n        Suc j < length ds; length cs = length ds\\<rbrakk>\n       \\<Longrightarrow> (take (Suc j) ds @ drop (Suc j) cs)\n                         [Suc j := ds ! Suc j] =\n                         take (Suc (Suc j)) ds @ drop (Suc (Suc j)) cs", "then"], ["proof (chain)\npicking this:\n  0 < length ds\n  length cs = length ds", "obtain d dds c ccs where ds: \"ds = d # dds\" and cs: \"cs = c # ccs\""], ["proof (prove)\nusing this:\n  0 < length ds\n  length cs = length ds\n\ngoal (1 subgoal):\n 1. (\\<And>d dds c ccs.\n        \\<lbrakk>ds = d # dds; cs = c # ccs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases ds, simp, cases cs, auto)"], ["proof (state)\nthis:\n  ds = d # dds\n  cs = c # ccs\n\ngoal (2 subgoals):\n 1. \\<And>ds cs.\n       \\<lbrakk>0 < length ds; length cs = length ds\\<rbrakk>\n       \\<Longrightarrow> (take 0 ds @ drop 0 cs)[0 := ds ! 0] =\n                         take (Suc 0) ds @ drop (Suc 0) cs\n 2. \\<And>j ds cs.\n       \\<lbrakk>\\<And>ds cs.\n                   \\<lbrakk>j < length ds; length cs = length ds\\<rbrakk>\n                   \\<Longrightarrow> (take j ds @ drop j cs)[j := ds ! j] =\n                                     take (Suc j) ds @ drop (Suc j) cs;\n        Suc j < length ds; length cs = length ds\\<rbrakk>\n       \\<Longrightarrow> (take (Suc j) ds @ drop (Suc j) cs)\n                         [Suc j := ds ! Suc j] =\n                         take (Suc (Suc j)) ds @ drop (Suc (Suc j)) cs", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (take 0 ds @ drop 0 cs)[0 := ds ! 0] = take (Suc 0) ds @ drop (Suc 0) cs", "unfolding ds cs"], ["proof (prove)\ngoal (1 subgoal):\n 1. (take 0 (d # dds) @ drop 0 (c # ccs))[0 := (d # dds) ! 0] =\n    take (Suc 0) (d # dds) @ drop (Suc 0) (c # ccs)", "by auto"], ["proof (state)\nthis:\n  (take 0 ds @ drop 0 cs)[0 := ds ! 0] = take (Suc 0) ds @ drop (Suc 0) cs\n\ngoal (1 subgoal):\n 1. \\<And>j ds cs.\n       \\<lbrakk>\\<And>ds cs.\n                   \\<lbrakk>j < length ds; length cs = length ds\\<rbrakk>\n                   \\<Longrightarrow> (take j ds @ drop j cs)[j := ds ! j] =\n                                     take (Suc j) ds @ drop (Suc j) cs;\n        Suc j < length ds; length cs = length ds\\<rbrakk>\n       \\<Longrightarrow> (take (Suc j) ds @ drop (Suc j) cs)\n                         [Suc j := ds ! Suc j] =\n                         take (Suc (Suc j)) ds @ drop (Suc (Suc j)) cs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j ds cs.\n       \\<lbrakk>\\<And>ds cs.\n                   \\<lbrakk>j < length ds; length cs = length ds\\<rbrakk>\n                   \\<Longrightarrow> (take j ds @ drop j cs)[j := ds ! j] =\n                                     take (Suc j) ds @ drop (Suc j) cs;\n        Suc j < length ds; length cs = length ds\\<rbrakk>\n       \\<Longrightarrow> (take (Suc j) ds @ drop (Suc j) cs)\n                         [Suc j := ds ! Suc j] =\n                         take (Suc (Suc j)) ds @ drop (Suc (Suc j)) cs", "case (Suc j)"], ["proof (state)\nthis:\n  \\<lbrakk>j < length ?ds; length ?cs = length ?ds\\<rbrakk>\n  \\<Longrightarrow> (take j ?ds @ drop j ?cs)[j := ?ds ! j] =\n                    take (Suc j) ?ds @ drop (Suc j) ?cs\n  Suc j < length ds\n  length cs = length ds\n\ngoal (1 subgoal):\n 1. \\<And>j ds cs.\n       \\<lbrakk>\\<And>ds cs.\n                   \\<lbrakk>j < length ds; length cs = length ds\\<rbrakk>\n                   \\<Longrightarrow> (take j ds @ drop j cs)[j := ds ! j] =\n                                     take (Suc j) ds @ drop (Suc j) cs;\n        Suc j < length ds; length cs = length ds\\<rbrakk>\n       \\<Longrightarrow> (take (Suc j) ds @ drop (Suc j) cs)\n                         [Suc j := ds ! Suc j] =\n                         take (Suc (Suc j)) ds @ drop (Suc (Suc j)) cs", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>j < length ?ds; length ?cs = length ?ds\\<rbrakk>\n  \\<Longrightarrow> (take j ?ds @ drop j ?cs)[j := ?ds ! j] =\n                    take (Suc j) ?ds @ drop (Suc j) ?cs\n  Suc j < length ds\n  length cs = length ds", "obtain d dds c ccs where ds: \"ds = d # dds\" and cs: \"cs = c # ccs\""], ["proof (prove)\nusing this:\n  \\<lbrakk>j < length ?ds; length ?cs = length ?ds\\<rbrakk>\n  \\<Longrightarrow> (take j ?ds @ drop j ?cs)[j := ?ds ! j] =\n                    take (Suc j) ?ds @ drop (Suc j) ?cs\n  Suc j < length ds\n  length cs = length ds\n\ngoal (1 subgoal):\n 1. (\\<And>d dds c ccs.\n        \\<lbrakk>ds = d # dds; cs = c # ccs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases ds, simp, cases cs, auto)"], ["proof (state)\nthis:\n  ds = d # dds\n  cs = c # ccs\n\ngoal (1 subgoal):\n 1. \\<And>j ds cs.\n       \\<lbrakk>\\<And>ds cs.\n                   \\<lbrakk>j < length ds; length cs = length ds\\<rbrakk>\n                   \\<Longrightarrow> (take j ds @ drop j cs)[j := ds ! j] =\n                                     take (Suc j) ds @ drop (Suc j) cs;\n        Suc j < length ds; length cs = length ds\\<rbrakk>\n       \\<Longrightarrow> (take (Suc j) ds @ drop (Suc j) cs)\n                         [Suc j := ds ! Suc j] =\n                         take (Suc (Suc j)) ds @ drop (Suc (Suc j)) cs", "from Suc(1)[of dds ccs] Suc(2) Suc(3)"], ["proof (chain)\npicking this:\n  \\<lbrakk>j < length dds; length ccs = length dds\\<rbrakk>\n  \\<Longrightarrow> (take j dds @ drop j ccs)[j := dds ! j] =\n                    take (Suc j) dds @ drop (Suc j) ccs\n  Suc j < length ds\n  length cs = length ds", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>j < length dds; length ccs = length dds\\<rbrakk>\n  \\<Longrightarrow> (take j dds @ drop j ccs)[j := dds ! j] =\n                    take (Suc j) dds @ drop (Suc j) ccs\n  Suc j < length ds\n  length cs = length ds\n\ngoal (1 subgoal):\n 1. (take (Suc j) ds @ drop (Suc j) cs)[Suc j := ds ! Suc j] =\n    take (Suc (Suc j)) ds @ drop (Suc (Suc j)) cs", "unfolding ds cs"], ["proof (prove)\nusing this:\n  \\<lbrakk>j < length dds; length ccs = length dds\\<rbrakk>\n  \\<Longrightarrow> (take j dds @ drop j ccs)[j := dds ! j] =\n                    take (Suc j) dds @ drop (Suc j) ccs\n  Suc j < length (d # dds)\n  length (c # ccs) = length (d # dds)\n\ngoal (1 subgoal):\n 1. (take (Suc j) (d # dds) @ drop (Suc j) (c # ccs))\n    [Suc j := (d # dds) ! Suc j] =\n    take (Suc (Suc j)) (d # dds) @ drop (Suc (Suc j)) (c # ccs)", "by auto"], ["proof (state)\nthis:\n  (take (Suc j) ds @ drop (Suc j) cs)[Suc j := ds ! Suc j] =\n  take (Suc (Suc j)) ds @ drop (Suc (Suc j)) cs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma take_drop_update_second: assumes \"j < length ds\" and \"length cs = length ds\"\n  shows \"(take j ds @ drop j cs)[j := cs ! j] = take j ds @ drop j cs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (take j ds @ drop j cs)[j := cs ! j] = take j ds @ drop j cs", "using assms"], ["proof (prove)\nusing this:\n  j < length ds\n  length cs = length ds\n\ngoal (1 subgoal):\n 1. (take j ds @ drop j cs)[j := cs ! j] = take j ds @ drop j cs", "proof (induct j arbitrary: ds cs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ds cs.\n       \\<lbrakk>0 < length ds; length cs = length ds\\<rbrakk>\n       \\<Longrightarrow> (take 0 ds @ drop 0 cs)[0 := cs ! 0] =\n                         take 0 ds @ drop 0 cs\n 2. \\<And>j ds cs.\n       \\<lbrakk>\\<And>ds cs.\n                   \\<lbrakk>j < length ds; length cs = length ds\\<rbrakk>\n                   \\<Longrightarrow> (take j ds @ drop j cs)[j := cs ! j] =\n                                     take j ds @ drop j cs;\n        Suc j < length ds; length cs = length ds\\<rbrakk>\n       \\<Longrightarrow> (take (Suc j) ds @ drop (Suc j) cs)\n                         [Suc j := cs ! Suc j] =\n                         take (Suc j) ds @ drop (Suc j) cs", "case 0"], ["proof (state)\nthis:\n  0 < length ds\n  length cs = length ds\n\ngoal (2 subgoals):\n 1. \\<And>ds cs.\n       \\<lbrakk>0 < length ds; length cs = length ds\\<rbrakk>\n       \\<Longrightarrow> (take 0 ds @ drop 0 cs)[0 := cs ! 0] =\n                         take 0 ds @ drop 0 cs\n 2. \\<And>j ds cs.\n       \\<lbrakk>\\<And>ds cs.\n                   \\<lbrakk>j < length ds; length cs = length ds\\<rbrakk>\n                   \\<Longrightarrow> (take j ds @ drop j cs)[j := cs ! j] =\n                                     take j ds @ drop j cs;\n        Suc j < length ds; length cs = length ds\\<rbrakk>\n       \\<Longrightarrow> (take (Suc j) ds @ drop (Suc j) cs)\n                         [Suc j := cs ! Suc j] =\n                         take (Suc j) ds @ drop (Suc j) cs", "then"], ["proof (chain)\npicking this:\n  0 < length ds\n  length cs = length ds", "obtain d dds c ccs where ds: \"ds = d # dds\" and cs: \"cs = c # ccs\""], ["proof (prove)\nusing this:\n  0 < length ds\n  length cs = length ds\n\ngoal (1 subgoal):\n 1. (\\<And>d dds c ccs.\n        \\<lbrakk>ds = d # dds; cs = c # ccs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases ds, simp, cases cs, auto)"], ["proof (state)\nthis:\n  ds = d # dds\n  cs = c # ccs\n\ngoal (2 subgoals):\n 1. \\<And>ds cs.\n       \\<lbrakk>0 < length ds; length cs = length ds\\<rbrakk>\n       \\<Longrightarrow> (take 0 ds @ drop 0 cs)[0 := cs ! 0] =\n                         take 0 ds @ drop 0 cs\n 2. \\<And>j ds cs.\n       \\<lbrakk>\\<And>ds cs.\n                   \\<lbrakk>j < length ds; length cs = length ds\\<rbrakk>\n                   \\<Longrightarrow> (take j ds @ drop j cs)[j := cs ! j] =\n                                     take j ds @ drop j cs;\n        Suc j < length ds; length cs = length ds\\<rbrakk>\n       \\<Longrightarrow> (take (Suc j) ds @ drop (Suc j) cs)\n                         [Suc j := cs ! Suc j] =\n                         take (Suc j) ds @ drop (Suc j) cs", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (take 0 ds @ drop 0 cs)[0 := cs ! 0] = take 0 ds @ drop 0 cs", "unfolding ds cs"], ["proof (prove)\ngoal (1 subgoal):\n 1. (take 0 (d # dds) @ drop 0 (c # ccs))[0 := (c # ccs) ! 0] =\n    take 0 (d # dds) @ drop 0 (c # ccs)", "by auto"], ["proof (state)\nthis:\n  (take 0 ds @ drop 0 cs)[0 := cs ! 0] = take 0 ds @ drop 0 cs\n\ngoal (1 subgoal):\n 1. \\<And>j ds cs.\n       \\<lbrakk>\\<And>ds cs.\n                   \\<lbrakk>j < length ds; length cs = length ds\\<rbrakk>\n                   \\<Longrightarrow> (take j ds @ drop j cs)[j := cs ! j] =\n                                     take j ds @ drop j cs;\n        Suc j < length ds; length cs = length ds\\<rbrakk>\n       \\<Longrightarrow> (take (Suc j) ds @ drop (Suc j) cs)\n                         [Suc j := cs ! Suc j] =\n                         take (Suc j) ds @ drop (Suc j) cs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j ds cs.\n       \\<lbrakk>\\<And>ds cs.\n                   \\<lbrakk>j < length ds; length cs = length ds\\<rbrakk>\n                   \\<Longrightarrow> (take j ds @ drop j cs)[j := cs ! j] =\n                                     take j ds @ drop j cs;\n        Suc j < length ds; length cs = length ds\\<rbrakk>\n       \\<Longrightarrow> (take (Suc j) ds @ drop (Suc j) cs)\n                         [Suc j := cs ! Suc j] =\n                         take (Suc j) ds @ drop (Suc j) cs", "case (Suc j)"], ["proof (state)\nthis:\n  \\<lbrakk>j < length ?ds; length ?cs = length ?ds\\<rbrakk>\n  \\<Longrightarrow> (take j ?ds @ drop j ?cs)[j := ?cs ! j] =\n                    take j ?ds @ drop j ?cs\n  Suc j < length ds\n  length cs = length ds\n\ngoal (1 subgoal):\n 1. \\<And>j ds cs.\n       \\<lbrakk>\\<And>ds cs.\n                   \\<lbrakk>j < length ds; length cs = length ds\\<rbrakk>\n                   \\<Longrightarrow> (take j ds @ drop j cs)[j := cs ! j] =\n                                     take j ds @ drop j cs;\n        Suc j < length ds; length cs = length ds\\<rbrakk>\n       \\<Longrightarrow> (take (Suc j) ds @ drop (Suc j) cs)\n                         [Suc j := cs ! Suc j] =\n                         take (Suc j) ds @ drop (Suc j) cs", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>j < length ?ds; length ?cs = length ?ds\\<rbrakk>\n  \\<Longrightarrow> (take j ?ds @ drop j ?cs)[j := ?cs ! j] =\n                    take j ?ds @ drop j ?cs\n  Suc j < length ds\n  length cs = length ds", "obtain d dds c ccs where ds: \"ds = d # dds\" and cs: \"cs = c # ccs\""], ["proof (prove)\nusing this:\n  \\<lbrakk>j < length ?ds; length ?cs = length ?ds\\<rbrakk>\n  \\<Longrightarrow> (take j ?ds @ drop j ?cs)[j := ?cs ! j] =\n                    take j ?ds @ drop j ?cs\n  Suc j < length ds\n  length cs = length ds\n\ngoal (1 subgoal):\n 1. (\\<And>d dds c ccs.\n        \\<lbrakk>ds = d # dds; cs = c # ccs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases ds, simp, cases cs, auto)"], ["proof (state)\nthis:\n  ds = d # dds\n  cs = c # ccs\n\ngoal (1 subgoal):\n 1. \\<And>j ds cs.\n       \\<lbrakk>\\<And>ds cs.\n                   \\<lbrakk>j < length ds; length cs = length ds\\<rbrakk>\n                   \\<Longrightarrow> (take j ds @ drop j cs)[j := cs ! j] =\n                                     take j ds @ drop j cs;\n        Suc j < length ds; length cs = length ds\\<rbrakk>\n       \\<Longrightarrow> (take (Suc j) ds @ drop (Suc j) cs)\n                         [Suc j := cs ! Suc j] =\n                         take (Suc j) ds @ drop (Suc j) cs", "from Suc(1)[of dds ccs] Suc(2) Suc(3)"], ["proof (chain)\npicking this:\n  \\<lbrakk>j < length dds; length ccs = length dds\\<rbrakk>\n  \\<Longrightarrow> (take j dds @ drop j ccs)[j := ccs ! j] =\n                    take j dds @ drop j ccs\n  Suc j < length ds\n  length cs = length ds", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>j < length dds; length ccs = length dds\\<rbrakk>\n  \\<Longrightarrow> (take j dds @ drop j ccs)[j := ccs ! j] =\n                    take j dds @ drop j ccs\n  Suc j < length ds\n  length cs = length ds\n\ngoal (1 subgoal):\n 1. (take (Suc j) ds @ drop (Suc j) cs)[Suc j := cs ! Suc j] =\n    take (Suc j) ds @ drop (Suc j) cs", "unfolding ds cs"], ["proof (prove)\nusing this:\n  \\<lbrakk>j < length dds; length ccs = length dds\\<rbrakk>\n  \\<Longrightarrow> (take j dds @ drop j ccs)[j := ccs ! j] =\n                    take j dds @ drop j ccs\n  Suc j < length (d # dds)\n  length (c # ccs) = length (d # dds)\n\ngoal (1 subgoal):\n 1. (take (Suc j) (d # dds) @ drop (Suc j) (c # ccs))\n    [Suc j := (c # ccs) ! Suc j] =\n    take (Suc j) (d # dds) @ drop (Suc j) (c # ccs)", "by auto"], ["proof (state)\nthis:\n  (take (Suc j) ds @ drop (Suc j) cs)[Suc j := cs ! Suc j] =\n  take (Suc j) ds @ drop (Suc j) cs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma nth_take_prefix:\n \"length ys \\<le> length xs \\<Longrightarrow> \\<forall>i < length ys. xs!i = ys!i \\<Longrightarrow> take (length ys) xs = ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length ys \\<le> length xs;\n     \\<forall>i<length ys. xs ! i = ys ! i\\<rbrakk>\n    \\<Longrightarrow> take (length ys) xs = ys", "proof (induct xs ys rule: list_induct2')"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<lbrakk>length [] \\<le> length [];\n     \\<forall>i<length []. [] ! i = [] ! i\\<rbrakk>\n    \\<Longrightarrow> take (length []) [] = []\n 2. \\<And>x xs.\n       \\<lbrakk>length [] \\<le> length (x # xs);\n        \\<forall>i<length []. (x # xs) ! i = [] ! i\\<rbrakk>\n       \\<Longrightarrow> take (length []) (x # xs) = []\n 3. \\<And>y ys.\n       \\<lbrakk>length (y # ys) \\<le> length [];\n        \\<forall>i<length (y # ys). [] ! i = (y # ys) ! i\\<rbrakk>\n       \\<Longrightarrow> take (length (y # ys)) [] = y # ys\n 4. \\<And>x xs y ys.\n       \\<lbrakk>\\<lbrakk>length ys \\<le> length xs;\n                 \\<forall>i<length ys. xs ! i = ys ! i\\<rbrakk>\n                \\<Longrightarrow> take (length ys) xs = ys;\n        length (y # ys) \\<le> length (x # xs);\n        \\<forall>i<length (y # ys). (x # xs) ! i = (y # ys) ! i\\<rbrakk>\n       \\<Longrightarrow> take (length (y # ys)) (x # xs) = y # ys", "case (4 x xs y ys)"], ["proof (state)\nthis:\n  \\<lbrakk>length ys \\<le> length xs;\n   \\<forall>i<length ys. xs ! i = ys ! i\\<rbrakk>\n  \\<Longrightarrow> take (length ys) xs = ys\n  length (y # ys) \\<le> length (x # xs)\n  \\<forall>i<length (y # ys). (x # xs) ! i = (y # ys) ! i\n\ngoal (4 subgoals):\n 1. \\<lbrakk>length [] \\<le> length [];\n     \\<forall>i<length []. [] ! i = [] ! i\\<rbrakk>\n    \\<Longrightarrow> take (length []) [] = []\n 2. \\<And>x xs.\n       \\<lbrakk>length [] \\<le> length (x # xs);\n        \\<forall>i<length []. (x # xs) ! i = [] ! i\\<rbrakk>\n       \\<Longrightarrow> take (length []) (x # xs) = []\n 3. \\<And>y ys.\n       \\<lbrakk>length (y # ys) \\<le> length [];\n        \\<forall>i<length (y # ys). [] ! i = (y # ys) ! i\\<rbrakk>\n       \\<Longrightarrow> take (length (y # ys)) [] = y # ys\n 4. \\<And>x xs y ys.\n       \\<lbrakk>\\<lbrakk>length ys \\<le> length xs;\n                 \\<forall>i<length ys. xs ! i = ys ! i\\<rbrakk>\n                \\<Longrightarrow> take (length ys) xs = ys;\n        length (y # ys) \\<le> length (x # xs);\n        \\<forall>i<length (y # ys). (x # xs) ! i = (y # ys) ! i\\<rbrakk>\n       \\<Longrightarrow> take (length (y # ys)) (x # xs) = y # ys", "have \"take (length ys) xs = ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. take (length ys) xs = ys", "by (rule 4(1), insert 4(2-3), auto)"], ["proof (state)\nthis:\n  take (length ys) xs = ys\n\ngoal (4 subgoals):\n 1. \\<lbrakk>length [] \\<le> length [];\n     \\<forall>i<length []. [] ! i = [] ! i\\<rbrakk>\n    \\<Longrightarrow> take (length []) [] = []\n 2. \\<And>x xs.\n       \\<lbrakk>length [] \\<le> length (x # xs);\n        \\<forall>i<length []. (x # xs) ! i = [] ! i\\<rbrakk>\n       \\<Longrightarrow> take (length []) (x # xs) = []\n 3. \\<And>y ys.\n       \\<lbrakk>length (y # ys) \\<le> length [];\n        \\<forall>i<length (y # ys). [] ! i = (y # ys) ! i\\<rbrakk>\n       \\<Longrightarrow> take (length (y # ys)) [] = y # ys\n 4. \\<And>x xs y ys.\n       \\<lbrakk>\\<lbrakk>length ys \\<le> length xs;\n                 \\<forall>i<length ys. xs ! i = ys ! i\\<rbrakk>\n                \\<Longrightarrow> take (length ys) xs = ys;\n        length (y # ys) \\<le> length (x # xs);\n        \\<forall>i<length (y # ys). (x # xs) ! i = (y # ys) ! i\\<rbrakk>\n       \\<Longrightarrow> take (length (y # ys)) (x # xs) = y # ys", "moreover"], ["proof (state)\nthis:\n  take (length ys) xs = ys\n\ngoal (4 subgoals):\n 1. \\<lbrakk>length [] \\<le> length [];\n     \\<forall>i<length []. [] ! i = [] ! i\\<rbrakk>\n    \\<Longrightarrow> take (length []) [] = []\n 2. \\<And>x xs.\n       \\<lbrakk>length [] \\<le> length (x # xs);\n        \\<forall>i<length []. (x # xs) ! i = [] ! i\\<rbrakk>\n       \\<Longrightarrow> take (length []) (x # xs) = []\n 3. \\<And>y ys.\n       \\<lbrakk>length (y # ys) \\<le> length [];\n        \\<forall>i<length (y # ys). [] ! i = (y # ys) ! i\\<rbrakk>\n       \\<Longrightarrow> take (length (y # ys)) [] = y # ys\n 4. \\<And>x xs y ys.\n       \\<lbrakk>\\<lbrakk>length ys \\<le> length xs;\n                 \\<forall>i<length ys. xs ! i = ys ! i\\<rbrakk>\n                \\<Longrightarrow> take (length ys) xs = ys;\n        length (y # ys) \\<le> length (x # xs);\n        \\<forall>i<length (y # ys). (x # xs) ! i = (y # ys) ! i\\<rbrakk>\n       \\<Longrightarrow> take (length (y # ys)) (x # xs) = y # ys", "from 4(3)"], ["proof (chain)\npicking this:\n  \\<forall>i<length (y # ys). (x # xs) ! i = (y # ys) ! i", "have \"x = y\""], ["proof (prove)\nusing this:\n  \\<forall>i<length (y # ys). (x # xs) ! i = (y # ys) ! i\n\ngoal (1 subgoal):\n 1. x = y", "by auto"], ["proof (state)\nthis:\n  x = y\n\ngoal (4 subgoals):\n 1. \\<lbrakk>length [] \\<le> length [];\n     \\<forall>i<length []. [] ! i = [] ! i\\<rbrakk>\n    \\<Longrightarrow> take (length []) [] = []\n 2. \\<And>x xs.\n       \\<lbrakk>length [] \\<le> length (x # xs);\n        \\<forall>i<length []. (x # xs) ! i = [] ! i\\<rbrakk>\n       \\<Longrightarrow> take (length []) (x # xs) = []\n 3. \\<And>y ys.\n       \\<lbrakk>length (y # ys) \\<le> length [];\n        \\<forall>i<length (y # ys). [] ! i = (y # ys) ! i\\<rbrakk>\n       \\<Longrightarrow> take (length (y # ys)) [] = y # ys\n 4. \\<And>x xs y ys.\n       \\<lbrakk>\\<lbrakk>length ys \\<le> length xs;\n                 \\<forall>i<length ys. xs ! i = ys ! i\\<rbrakk>\n                \\<Longrightarrow> take (length ys) xs = ys;\n        length (y # ys) \\<le> length (x # xs);\n        \\<forall>i<length (y # ys). (x # xs) ! i = (y # ys) ! i\\<rbrakk>\n       \\<Longrightarrow> take (length (y # ys)) (x # xs) = y # ys", "ultimately"], ["proof (chain)\npicking this:\n  take (length ys) xs = ys\n  x = y", "show ?case"], ["proof (prove)\nusing this:\n  take (length ys) xs = ys\n  x = y\n\ngoal (1 subgoal):\n 1. take (length (y # ys)) (x # xs) = y # ys", "by auto"], ["proof (state)\nthis:\n  take (length (y # ys)) (x # xs) = y # ys\n\ngoal (3 subgoals):\n 1. \\<lbrakk>length [] \\<le> length [];\n     \\<forall>i<length []. [] ! i = [] ! i\\<rbrakk>\n    \\<Longrightarrow> take (length []) [] = []\n 2. \\<And>x xs.\n       \\<lbrakk>length [] \\<le> length (x # xs);\n        \\<forall>i<length []. (x # xs) ! i = [] ! i\\<rbrakk>\n       \\<Longrightarrow> take (length []) (x # xs) = []\n 3. \\<And>y ys.\n       \\<lbrakk>length (y # ys) \\<le> length [];\n        \\<forall>i<length (y # ys). [] ! i = (y # ys) ! i\\<rbrakk>\n       \\<Longrightarrow> take (length (y # ys)) [] = y # ys", "qed auto"], ["", "lemma take_upt_idx:\n  assumes i: \"i < length ls\"\n  shows \"take i ls = [ ls ! j . j \\<leftarrow> [0..<i]]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. take i ls = map ((!) ls) [0..<i]", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. take i ls = map ((!) ls) [0..<i]", "have e: \"0 + i \\<le> i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 + i \\<le> i", "by auto"], ["proof (state)\nthis:\n  0 + i \\<le> i\n\ngoal (1 subgoal):\n 1. take i ls = map ((!) ls) [0..<i]", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. take i ls = map ((!) ls) [0..<i]", "using take_upt[OF e] take_map map_nth"], ["proof (prove)\nusing this:\n  take i [0..<i] = [0..<0 + i]\n  take ?n (map ?f ?xs) = map ?f (take ?n ?xs)\n  map ((!) ?xs) [0..<length ?xs] = ?xs\n\ngoal (1 subgoal):\n 1. take i ls = map ((!) ls) [0..<i]", "by (metis (hide_lams, no_types) add.left_neutral i nat_less_le take_upt)"], ["proof (state)\nthis:\n  take i ls = map ((!) ls) [0..<i]\n\ngoal:\nNo subgoals!", "qed"], ["", "fun distinct_eq :: \"('a \\<Rightarrow> 'a \\<Rightarrow> bool) \\<Rightarrow> 'a list \\<Rightarrow> bool\" where\n  \"distinct_eq _ [] = True\"\n| \"distinct_eq eq (x # xs) = ((\\<forall> y \\<in> set xs. \\<not> (eq y x)) \\<and> distinct_eq eq xs)\""], ["", "lemma distinct_eq_append: \"distinct_eq eq (xs @ ys) = (distinct_eq eq xs \\<and> distinct_eq eq ys \\<and> (\\<forall> x \\<in> set xs. \\<forall> y \\<in> set ys. \\<not> (eq y x)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct_eq eq (xs @ ys) =\n    (distinct_eq eq xs \\<and>\n     distinct_eq eq ys \\<and>\n     (\\<forall>x\\<in>set xs. \\<forall>y\\<in>set ys. \\<not> eq y x))", "by (induct xs, auto)"], ["", "lemma append_Cons_nth_left:\n  assumes \"i < length xs\"\n  shows \"(xs @ u # ys) ! i = xs ! i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (xs @ u # ys) ! i = xs ! i", "using assms nth_append[of xs _ i]"], ["proof (prove)\nusing this:\n  i < length xs\n  (xs @ ?ys) ! i = (if i < length xs then xs ! i else ?ys ! (i - length xs))\n\ngoal (1 subgoal):\n 1. (xs @ u # ys) ! i = xs ! i", "by simp"], ["", "lemma append_Cons_nth_middle:\n  assumes \"i = length xs\"\n  shows \"(xs @ y # zs) ! i = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (xs @ y # zs) ! i = y", "using assms"], ["proof (prove)\nusing this:\n  i = length xs\n\ngoal (1 subgoal):\n 1. (xs @ y # zs) ! i = y", "by auto"], ["", "lemma append_Cons_nth_right:\n  assumes \"i > length xs\"\n  shows \"(xs @ u # ys) ! i = (xs @ z # ys) ! i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (xs @ u # ys) ! i = (xs @ z # ys) ! i", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (xs @ u # ys) ! i = (xs @ z # ys) ! i", "from assms"], ["proof (chain)\npicking this:\n  length xs < i", "have \"i - length xs > 0\""], ["proof (prove)\nusing this:\n  length xs < i\n\ngoal (1 subgoal):\n 1. 0 < i - length xs", "by auto"], ["proof (state)\nthis:\n  0 < i - length xs\n\ngoal (1 subgoal):\n 1. (xs @ u # ys) ! i = (xs @ z # ys) ! i", "then"], ["proof (chain)\npicking this:\n  0 < i - length xs", "obtain j where j: \"i - length xs = Suc j\""], ["proof (prove)\nusing this:\n  0 < i - length xs\n\ngoal (1 subgoal):\n 1. (\\<And>j.\n        i - length xs = Suc j \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases \"i - length xs\", auto)"], ["proof (state)\nthis:\n  i - length xs = Suc j\n\ngoal (1 subgoal):\n 1. (xs @ u # ys) ! i = (xs @ z # ys) ! i", "thus ?thesis"], ["proof (prove)\nusing this:\n  i - length xs = Suc j\n\ngoal (1 subgoal):\n 1. (xs @ u # ys) ! i = (xs @ z # ys) ! i", "by (simp add: nth_append)"], ["proof (state)\nthis:\n  (xs @ u # ys) ! i = (xs @ z # ys) ! i\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma append_Cons_nth_not_middle:\n  assumes \"i \\<noteq> length xs\"\n  shows \"(xs @ u # ys) ! i = (xs @ z # ys) ! i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (xs @ u # ys) ! i = (xs @ z # ys) ! i", "proof (cases \"i < length xs\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i < length xs \\<Longrightarrow> (xs @ u # ys) ! i = (xs @ z # ys) ! i\n 2. \\<not> i < length xs \\<Longrightarrow>\n    (xs @ u # ys) ! i = (xs @ z # ys) ! i", "case True"], ["proof (state)\nthis:\n  i < length xs\n\ngoal (2 subgoals):\n 1. i < length xs \\<Longrightarrow> (xs @ u # ys) ! i = (xs @ z # ys) ! i\n 2. \\<not> i < length xs \\<Longrightarrow>\n    (xs @ u # ys) ! i = (xs @ z # ys) ! i", "thus ?thesis"], ["proof (prove)\nusing this:\n  i < length xs\n\ngoal (1 subgoal):\n 1. (xs @ u # ys) ! i = (xs @ z # ys) ! i", "by (simp add: append_Cons_nth_left)"], ["proof (state)\nthis:\n  (xs @ u # ys) ! i = (xs @ z # ys) ! i\n\ngoal (1 subgoal):\n 1. \\<not> i < length xs \\<Longrightarrow>\n    (xs @ u # ys) ! i = (xs @ z # ys) ! i", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> i < length xs \\<Longrightarrow>\n    (xs @ u # ys) ! i = (xs @ z # ys) ! i", "case False"], ["proof (state)\nthis:\n  \\<not> i < length xs\n\ngoal (1 subgoal):\n 1. \\<not> i < length xs \\<Longrightarrow>\n    (xs @ u # ys) ! i = (xs @ z # ys) ! i", "with assms"], ["proof (chain)\npicking this:\n  i \\<noteq> length xs\n  \\<not> i < length xs", "have \"i > length xs\""], ["proof (prove)\nusing this:\n  i \\<noteq> length xs\n  \\<not> i < length xs\n\ngoal (1 subgoal):\n 1. length xs < i", "by arith"], ["proof (state)\nthis:\n  length xs < i\n\ngoal (1 subgoal):\n 1. \\<not> i < length xs \\<Longrightarrow>\n    (xs @ u # ys) ! i = (xs @ z # ys) ! i", "thus ?thesis"], ["proof (prove)\nusing this:\n  length xs < i\n\ngoal (1 subgoal):\n 1. (xs @ u # ys) ! i = (xs @ z # ys) ! i", "by (rule append_Cons_nth_right)"], ["proof (state)\nthis:\n  (xs @ u # ys) ! i = (xs @ z # ys) ! i\n\ngoal:\nNo subgoals!", "qed"], ["", "lemmas append_Cons_nth = append_Cons_nth_middle append_Cons_nth_not_middle"], ["", "lemma concat_all_nth:\n  assumes \"length xs = length ys\"\n    and \"\\<And>i. i < length xs \\<Longrightarrow> length (xs ! i) = length (ys ! i)\"\n    and \"\\<And>i j. i < length xs \\<Longrightarrow> j < length (xs ! i) \\<Longrightarrow> P (xs ! i ! j) (ys ! i ! j)\"\n  shows \"\\<forall>k<length (concat xs). P (concat xs ! k) (concat ys ! k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>k<length (concat xs). P (concat xs ! k) (concat ys ! k)", "using assms"], ["proof (prove)\nusing this:\n  length xs = length ys\n  ?i < length xs \\<Longrightarrow> length (xs ! ?i) = length (ys ! ?i)\n  \\<lbrakk>?i < length xs; ?j < length (xs ! ?i)\\<rbrakk>\n  \\<Longrightarrow> P (xs ! ?i ! ?j) (ys ! ?i ! ?j)\n\ngoal (1 subgoal):\n 1. \\<forall>k<length (concat xs). P (concat xs ! k) (concat ys ! k)", "proof (induct xs ys rule: list_induct2)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>i.\n                i < length [] \\<Longrightarrow>\n                length ([] ! i) = length ([] ! i);\n     \\<And>i j.\n        \\<lbrakk>i < length []; j < length ([] ! i)\\<rbrakk>\n        \\<Longrightarrow> P ([] ! i ! j) ([] ! i ! j)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>k<length (concat []).\n                         P (concat [] ! k) (concat [] ! k)\n 2. \\<And>x xs y ys.\n       \\<lbrakk>length xs = length ys;\n        \\<lbrakk>\\<And>i.\n                    i < length xs \\<Longrightarrow>\n                    length (xs ! i) = length (ys ! i);\n         \\<And>i j.\n            \\<lbrakk>i < length xs; j < length (xs ! i)\\<rbrakk>\n            \\<Longrightarrow> P (xs ! i ! j) (ys ! i ! j)\\<rbrakk>\n        \\<Longrightarrow> \\<forall>k<length (concat xs).\n                             P (concat xs ! k) (concat ys ! k);\n        \\<And>i.\n           i < length (x # xs) \\<Longrightarrow>\n           length ((x # xs) ! i) = length ((y # ys) ! i);\n        \\<And>i j.\n           \\<lbrakk>i < length (x # xs); j < length ((x # xs) ! i)\\<rbrakk>\n           \\<Longrightarrow> P ((x # xs) ! i ! j)\n                              ((y # ys) ! i ! j)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>k<length (concat (x # xs)).\n                            P (concat (x # xs) ! k) (concat (y # ys) ! k)", "case (Cons x xs y ys)"], ["proof (state)\nthis:\n  length xs = length ys\n  \\<lbrakk>\\<And>i.\n              i < length xs \\<Longrightarrow>\n              length (xs ! i) = length (ys ! i);\n   \\<And>i j.\n      \\<lbrakk>i < length xs; j < length (xs ! i)\\<rbrakk>\n      \\<Longrightarrow> P (xs ! i ! j) (ys ! i ! j)\\<rbrakk>\n  \\<Longrightarrow> \\<forall>k<length (concat xs).\n                       P (concat xs ! k) (concat ys ! k)\n  ?i < length (x # xs) \\<Longrightarrow>\n  length ((x # xs) ! ?i) = length ((y # ys) ! ?i)\n  \\<lbrakk>?i < length (x # xs); ?j < length ((x # xs) ! ?i)\\<rbrakk>\n  \\<Longrightarrow> P ((x # xs) ! ?i ! ?j) ((y # ys) ! ?i ! ?j)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>i.\n                i < length [] \\<Longrightarrow>\n                length ([] ! i) = length ([] ! i);\n     \\<And>i j.\n        \\<lbrakk>i < length []; j < length ([] ! i)\\<rbrakk>\n        \\<Longrightarrow> P ([] ! i ! j) ([] ! i ! j)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>k<length (concat []).\n                         P (concat [] ! k) (concat [] ! k)\n 2. \\<And>x xs y ys.\n       \\<lbrakk>length xs = length ys;\n        \\<lbrakk>\\<And>i.\n                    i < length xs \\<Longrightarrow>\n                    length (xs ! i) = length (ys ! i);\n         \\<And>i j.\n            \\<lbrakk>i < length xs; j < length (xs ! i)\\<rbrakk>\n            \\<Longrightarrow> P (xs ! i ! j) (ys ! i ! j)\\<rbrakk>\n        \\<Longrightarrow> \\<forall>k<length (concat xs).\n                             P (concat xs ! k) (concat ys ! k);\n        \\<And>i.\n           i < length (x # xs) \\<Longrightarrow>\n           length ((x # xs) ! i) = length ((y # ys) ! i);\n        \\<And>i j.\n           \\<lbrakk>i < length (x # xs); j < length ((x # xs) ! i)\\<rbrakk>\n           \\<Longrightarrow> P ((x # xs) ! i ! j)\n                              ((y # ys) ! i ! j)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>k<length (concat (x # xs)).\n                            P (concat (x # xs) ! k) (concat (y # ys) ! k)", "from Cons(3)[of 0]"], ["proof (chain)\npicking this:\n  0 < length (x # xs) \\<Longrightarrow>\n  length ((x # xs) ! 0) = length ((y # ys) ! 0)", "have xy: \"length x = length y\""], ["proof (prove)\nusing this:\n  0 < length (x # xs) \\<Longrightarrow>\n  length ((x # xs) ! 0) = length ((y # ys) ! 0)\n\ngoal (1 subgoal):\n 1. length x = length y", "by simp"], ["proof (state)\nthis:\n  length x = length y\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>i.\n                i < length [] \\<Longrightarrow>\n                length ([] ! i) = length ([] ! i);\n     \\<And>i j.\n        \\<lbrakk>i < length []; j < length ([] ! i)\\<rbrakk>\n        \\<Longrightarrow> P ([] ! i ! j) ([] ! i ! j)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>k<length (concat []).\n                         P (concat [] ! k) (concat [] ! k)\n 2. \\<And>x xs y ys.\n       \\<lbrakk>length xs = length ys;\n        \\<lbrakk>\\<And>i.\n                    i < length xs \\<Longrightarrow>\n                    length (xs ! i) = length (ys ! i);\n         \\<And>i j.\n            \\<lbrakk>i < length xs; j < length (xs ! i)\\<rbrakk>\n            \\<Longrightarrow> P (xs ! i ! j) (ys ! i ! j)\\<rbrakk>\n        \\<Longrightarrow> \\<forall>k<length (concat xs).\n                             P (concat xs ! k) (concat ys ! k);\n        \\<And>i.\n           i < length (x # xs) \\<Longrightarrow>\n           length ((x # xs) ! i) = length ((y # ys) ! i);\n        \\<And>i j.\n           \\<lbrakk>i < length (x # xs); j < length ((x # xs) ! i)\\<rbrakk>\n           \\<Longrightarrow> P ((x # xs) ! i ! j)\n                              ((y # ys) ! i ! j)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>k<length (concat (x # xs)).\n                            P (concat (x # xs) ! k) (concat (y # ys) ! k)", "from Cons(4)[of 0] xy"], ["proof (chain)\npicking this:\n  \\<lbrakk>0 < length (x # xs); ?j < length ((x # xs) ! 0)\\<rbrakk>\n  \\<Longrightarrow> P ((x # xs) ! 0 ! ?j) ((y # ys) ! 0 ! ?j)\n  length x = length y", "have pxy: \"\\<And> j. j < length x \\<Longrightarrow> P (x ! j) (y ! j)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>0 < length (x # xs); ?j < length ((x # xs) ! 0)\\<rbrakk>\n  \\<Longrightarrow> P ((x # xs) ! 0 ! ?j) ((y # ys) ! 0 ! ?j)\n  length x = length y\n\ngoal (1 subgoal):\n 1. \\<And>j. j < length x \\<Longrightarrow> P (x ! j) (y ! j)", "by auto"], ["proof (state)\nthis:\n  ?j < length x \\<Longrightarrow> P (x ! ?j) (y ! ?j)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>i.\n                i < length [] \\<Longrightarrow>\n                length ([] ! i) = length ([] ! i);\n     \\<And>i j.\n        \\<lbrakk>i < length []; j < length ([] ! i)\\<rbrakk>\n        \\<Longrightarrow> P ([] ! i ! j) ([] ! i ! j)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>k<length (concat []).\n                         P (concat [] ! k) (concat [] ! k)\n 2. \\<And>x xs y ys.\n       \\<lbrakk>length xs = length ys;\n        \\<lbrakk>\\<And>i.\n                    i < length xs \\<Longrightarrow>\n                    length (xs ! i) = length (ys ! i);\n         \\<And>i j.\n            \\<lbrakk>i < length xs; j < length (xs ! i)\\<rbrakk>\n            \\<Longrightarrow> P (xs ! i ! j) (ys ! i ! j)\\<rbrakk>\n        \\<Longrightarrow> \\<forall>k<length (concat xs).\n                             P (concat xs ! k) (concat ys ! k);\n        \\<And>i.\n           i < length (x # xs) \\<Longrightarrow>\n           length ((x # xs) ! i) = length ((y # ys) ! i);\n        \\<And>i j.\n           \\<lbrakk>i < length (x # xs); j < length ((x # xs) ! i)\\<rbrakk>\n           \\<Longrightarrow> P ((x # xs) ! i ! j)\n                              ((y # ys) ! i ! j)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>k<length (concat (x # xs)).\n                            P (concat (x # xs) ! k) (concat (y # ys) ! k)", "{"], ["proof (state)\nthis:\n  ?j < length x \\<Longrightarrow> P (x ! ?j) (y ! ?j)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>i.\n                i < length [] \\<Longrightarrow>\n                length ([] ! i) = length ([] ! i);\n     \\<And>i j.\n        \\<lbrakk>i < length []; j < length ([] ! i)\\<rbrakk>\n        \\<Longrightarrow> P ([] ! i ! j) ([] ! i ! j)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>k<length (concat []).\n                         P (concat [] ! k) (concat [] ! k)\n 2. \\<And>x xs y ys.\n       \\<lbrakk>length xs = length ys;\n        \\<lbrakk>\\<And>i.\n                    i < length xs \\<Longrightarrow>\n                    length (xs ! i) = length (ys ! i);\n         \\<And>i j.\n            \\<lbrakk>i < length xs; j < length (xs ! i)\\<rbrakk>\n            \\<Longrightarrow> P (xs ! i ! j) (ys ! i ! j)\\<rbrakk>\n        \\<Longrightarrow> \\<forall>k<length (concat xs).\n                             P (concat xs ! k) (concat ys ! k);\n        \\<And>i.\n           i < length (x # xs) \\<Longrightarrow>\n           length ((x # xs) ! i) = length ((y # ys) ! i);\n        \\<And>i j.\n           \\<lbrakk>i < length (x # xs); j < length ((x # xs) ! i)\\<rbrakk>\n           \\<Longrightarrow> P ((x # xs) ! i ! j)\n                              ((y # ys) ! i ! j)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>k<length (concat (x # xs)).\n                            P (concat (x # xs) ! k) (concat (y # ys) ! k)", "fix i"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>i.\n                i < length [] \\<Longrightarrow>\n                length ([] ! i) = length ([] ! i);\n     \\<And>i j.\n        \\<lbrakk>i < length []; j < length ([] ! i)\\<rbrakk>\n        \\<Longrightarrow> P ([] ! i ! j) ([] ! i ! j)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>k<length (concat []).\n                         P (concat [] ! k) (concat [] ! k)\n 2. \\<And>x xs y ys.\n       \\<lbrakk>length xs = length ys;\n        \\<lbrakk>\\<And>i.\n                    i < length xs \\<Longrightarrow>\n                    length (xs ! i) = length (ys ! i);\n         \\<And>i j.\n            \\<lbrakk>i < length xs; j < length (xs ! i)\\<rbrakk>\n            \\<Longrightarrow> P (xs ! i ! j) (ys ! i ! j)\\<rbrakk>\n        \\<Longrightarrow> \\<forall>k<length (concat xs).\n                             P (concat xs ! k) (concat ys ! k);\n        \\<And>i.\n           i < length (x # xs) \\<Longrightarrow>\n           length ((x # xs) ! i) = length ((y # ys) ! i);\n        \\<And>i j.\n           \\<lbrakk>i < length (x # xs); j < length ((x # xs) ! i)\\<rbrakk>\n           \\<Longrightarrow> P ((x # xs) ! i ! j)\n                              ((y # ys) ! i ! j)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>k<length (concat (x # xs)).\n                            P (concat (x # xs) ! k) (concat (y # ys) ! k)", "assume i: \"i < length xs\""], ["proof (state)\nthis:\n  i < length xs\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>i.\n                i < length [] \\<Longrightarrow>\n                length ([] ! i) = length ([] ! i);\n     \\<And>i j.\n        \\<lbrakk>i < length []; j < length ([] ! i)\\<rbrakk>\n        \\<Longrightarrow> P ([] ! i ! j) ([] ! i ! j)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>k<length (concat []).\n                         P (concat [] ! k) (concat [] ! k)\n 2. \\<And>x xs y ys.\n       \\<lbrakk>length xs = length ys;\n        \\<lbrakk>\\<And>i.\n                    i < length xs \\<Longrightarrow>\n                    length (xs ! i) = length (ys ! i);\n         \\<And>i j.\n            \\<lbrakk>i < length xs; j < length (xs ! i)\\<rbrakk>\n            \\<Longrightarrow> P (xs ! i ! j) (ys ! i ! j)\\<rbrakk>\n        \\<Longrightarrow> \\<forall>k<length (concat xs).\n                             P (concat xs ! k) (concat ys ! k);\n        \\<And>i.\n           i < length (x # xs) \\<Longrightarrow>\n           length ((x # xs) ! i) = length ((y # ys) ! i);\n        \\<And>i j.\n           \\<lbrakk>i < length (x # xs); j < length ((x # xs) ! i)\\<rbrakk>\n           \\<Longrightarrow> P ((x # xs) ! i ! j)\n                              ((y # ys) ! i ! j)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>k<length (concat (x # xs)).\n                            P (concat (x # xs) ! k) (concat (y # ys) ! k)", "with Cons(3)[of \"Suc i\"]"], ["proof (chain)\npicking this:\n  Suc i < length (x # xs) \\<Longrightarrow>\n  length ((x # xs) ! Suc i) = length ((y # ys) ! Suc i)\n  i < length xs", "have len: \"length (xs ! i) = length (ys ! i)\""], ["proof (prove)\nusing this:\n  Suc i < length (x # xs) \\<Longrightarrow>\n  length ((x # xs) ! Suc i) = length ((y # ys) ! Suc i)\n  i < length xs\n\ngoal (1 subgoal):\n 1. length (xs ! i) = length (ys ! i)", "by simp"], ["proof (state)\nthis:\n  length (xs ! i) = length (ys ! i)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>i.\n                i < length [] \\<Longrightarrow>\n                length ([] ! i) = length ([] ! i);\n     \\<And>i j.\n        \\<lbrakk>i < length []; j < length ([] ! i)\\<rbrakk>\n        \\<Longrightarrow> P ([] ! i ! j) ([] ! i ! j)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>k<length (concat []).\n                         P (concat [] ! k) (concat [] ! k)\n 2. \\<And>x xs y ys.\n       \\<lbrakk>length xs = length ys;\n        \\<lbrakk>\\<And>i.\n                    i < length xs \\<Longrightarrow>\n                    length (xs ! i) = length (ys ! i);\n         \\<And>i j.\n            \\<lbrakk>i < length xs; j < length (xs ! i)\\<rbrakk>\n            \\<Longrightarrow> P (xs ! i ! j) (ys ! i ! j)\\<rbrakk>\n        \\<Longrightarrow> \\<forall>k<length (concat xs).\n                             P (concat xs ! k) (concat ys ! k);\n        \\<And>i.\n           i < length (x # xs) \\<Longrightarrow>\n           length ((x # xs) ! i) = length ((y # ys) ! i);\n        \\<And>i j.\n           \\<lbrakk>i < length (x # xs); j < length ((x # xs) ! i)\\<rbrakk>\n           \\<Longrightarrow> P ((x # xs) ! i ! j)\n                              ((y # ys) ! i ! j)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>k<length (concat (x # xs)).\n                            P (concat (x # xs) ! k) (concat (y # ys) ! k)", "from Cons(4)[of \"Suc i\"] i"], ["proof (chain)\npicking this:\n  \\<lbrakk>Suc i < length (x # xs); ?j < length ((x # xs) ! Suc i)\\<rbrakk>\n  \\<Longrightarrow> P ((x # xs) ! Suc i ! ?j) ((y # ys) ! Suc i ! ?j)\n  i < length xs", "have \"\\<And> j. j < length (xs ! i) \\<Longrightarrow> P (xs ! i ! j) (ys ! i ! j)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>Suc i < length (x # xs); ?j < length ((x # xs) ! Suc i)\\<rbrakk>\n  \\<Longrightarrow> P ((x # xs) ! Suc i ! ?j) ((y # ys) ! Suc i ! ?j)\n  i < length xs\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       j < length (xs ! i) \\<Longrightarrow> P (xs ! i ! j) (ys ! i ! j)", "by auto"], ["proof (state)\nthis:\n  ?j < length (xs ! i) \\<Longrightarrow> P (xs ! i ! ?j) (ys ! i ! ?j)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>i.\n                i < length [] \\<Longrightarrow>\n                length ([] ! i) = length ([] ! i);\n     \\<And>i j.\n        \\<lbrakk>i < length []; j < length ([] ! i)\\<rbrakk>\n        \\<Longrightarrow> P ([] ! i ! j) ([] ! i ! j)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>k<length (concat []).\n                         P (concat [] ! k) (concat [] ! k)\n 2. \\<And>x xs y ys.\n       \\<lbrakk>length xs = length ys;\n        \\<lbrakk>\\<And>i.\n                    i < length xs \\<Longrightarrow>\n                    length (xs ! i) = length (ys ! i);\n         \\<And>i j.\n            \\<lbrakk>i < length xs; j < length (xs ! i)\\<rbrakk>\n            \\<Longrightarrow> P (xs ! i ! j) (ys ! i ! j)\\<rbrakk>\n        \\<Longrightarrow> \\<forall>k<length (concat xs).\n                             P (concat xs ! k) (concat ys ! k);\n        \\<And>i.\n           i < length (x # xs) \\<Longrightarrow>\n           length ((x # xs) ! i) = length ((y # ys) ! i);\n        \\<And>i j.\n           \\<lbrakk>i < length (x # xs); j < length ((x # xs) ! i)\\<rbrakk>\n           \\<Longrightarrow> P ((x # xs) ! i ! j)\n                              ((y # ys) ! i ! j)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>k<length (concat (x # xs)).\n                            P (concat (x # xs) ! k) (concat (y # ys) ! k)", "note len and this"], ["proof (state)\nthis:\n  length (xs ! i) = length (ys ! i)\n  ?j < length (xs ! i) \\<Longrightarrow> P (xs ! i ! ?j) (ys ! i ! ?j)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>i.\n                i < length [] \\<Longrightarrow>\n                length ([] ! i) = length ([] ! i);\n     \\<And>i j.\n        \\<lbrakk>i < length []; j < length ([] ! i)\\<rbrakk>\n        \\<Longrightarrow> P ([] ! i ! j) ([] ! i ! j)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>k<length (concat []).\n                         P (concat [] ! k) (concat [] ! k)\n 2. \\<And>x xs y ys.\n       \\<lbrakk>length xs = length ys;\n        \\<lbrakk>\\<And>i.\n                    i < length xs \\<Longrightarrow>\n                    length (xs ! i) = length (ys ! i);\n         \\<And>i j.\n            \\<lbrakk>i < length xs; j < length (xs ! i)\\<rbrakk>\n            \\<Longrightarrow> P (xs ! i ! j) (ys ! i ! j)\\<rbrakk>\n        \\<Longrightarrow> \\<forall>k<length (concat xs).\n                             P (concat xs ! k) (concat ys ! k);\n        \\<And>i.\n           i < length (x # xs) \\<Longrightarrow>\n           length ((x # xs) ! i) = length ((y # ys) ! i);\n        \\<And>i j.\n           \\<lbrakk>i < length (x # xs); j < length ((x # xs) ! i)\\<rbrakk>\n           \\<Longrightarrow> P ((x # xs) ! i ! j)\n                              ((y # ys) ! i ! j)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>k<length (concat (x # xs)).\n                            P (concat (x # xs) ! k) (concat (y # ys) ! k)", "}"], ["proof (state)\nthis:\n  ?i3 < length xs \\<Longrightarrow> length (xs ! ?i3) = length (ys ! ?i3)\n  \\<lbrakk>?i3 < length xs; ?j < length (xs ! ?i3)\\<rbrakk>\n  \\<Longrightarrow> P (xs ! ?i3 ! ?j) (ys ! ?i3 ! ?j)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>i.\n                i < length [] \\<Longrightarrow>\n                length ([] ! i) = length ([] ! i);\n     \\<And>i j.\n        \\<lbrakk>i < length []; j < length ([] ! i)\\<rbrakk>\n        \\<Longrightarrow> P ([] ! i ! j) ([] ! i ! j)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>k<length (concat []).\n                         P (concat [] ! k) (concat [] ! k)\n 2. \\<And>x xs y ys.\n       \\<lbrakk>length xs = length ys;\n        \\<lbrakk>\\<And>i.\n                    i < length xs \\<Longrightarrow>\n                    length (xs ! i) = length (ys ! i);\n         \\<And>i j.\n            \\<lbrakk>i < length xs; j < length (xs ! i)\\<rbrakk>\n            \\<Longrightarrow> P (xs ! i ! j) (ys ! i ! j)\\<rbrakk>\n        \\<Longrightarrow> \\<forall>k<length (concat xs).\n                             P (concat xs ! k) (concat ys ! k);\n        \\<And>i.\n           i < length (x # xs) \\<Longrightarrow>\n           length ((x # xs) ! i) = length ((y # ys) ! i);\n        \\<And>i j.\n           \\<lbrakk>i < length (x # xs); j < length ((x # xs) ! i)\\<rbrakk>\n           \\<Longrightarrow> P ((x # xs) ! i ! j)\n                              ((y # ys) ! i ! j)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>k<length (concat (x # xs)).\n                            P (concat (x # xs) ! k) (concat (y # ys) ! k)", "from Cons(2)[OF this]"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<And>i. i < length xs \\<Longrightarrow> i < length xs;\n   \\<And>i j.\n      \\<lbrakk>i < length xs; j < length (xs ! i)\\<rbrakk>\n      \\<Longrightarrow> i < length xs;\n   \\<And>i j.\n      \\<lbrakk>i < length xs; j < length (xs ! i)\\<rbrakk>\n      \\<Longrightarrow> j < length (xs ! i)\\<rbrakk>\n  \\<Longrightarrow> \\<forall>k<length (concat xs).\n                       P (concat xs ! k) (concat ys ! k)", "have ind: \"\\<And> k. k < length (concat xs) \\<Longrightarrow> P (concat xs ! k) (concat ys ! k)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>i. i < length xs \\<Longrightarrow> i < length xs;\n   \\<And>i j.\n      \\<lbrakk>i < length xs; j < length (xs ! i)\\<rbrakk>\n      \\<Longrightarrow> i < length xs;\n   \\<And>i j.\n      \\<lbrakk>i < length xs; j < length (xs ! i)\\<rbrakk>\n      \\<Longrightarrow> j < length (xs ! i)\\<rbrakk>\n  \\<Longrightarrow> \\<forall>k<length (concat xs).\n                       P (concat xs ! k) (concat ys ! k)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       k < length (concat xs) \\<Longrightarrow>\n       P (concat xs ! k) (concat ys ! k)", "by auto"], ["proof (state)\nthis:\n  ?k < length (concat xs) \\<Longrightarrow>\n  P (concat xs ! ?k) (concat ys ! ?k)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>i.\n                i < length [] \\<Longrightarrow>\n                length ([] ! i) = length ([] ! i);\n     \\<And>i j.\n        \\<lbrakk>i < length []; j < length ([] ! i)\\<rbrakk>\n        \\<Longrightarrow> P ([] ! i ! j) ([] ! i ! j)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>k<length (concat []).\n                         P (concat [] ! k) (concat [] ! k)\n 2. \\<And>x xs y ys.\n       \\<lbrakk>length xs = length ys;\n        \\<lbrakk>\\<And>i.\n                    i < length xs \\<Longrightarrow>\n                    length (xs ! i) = length (ys ! i);\n         \\<And>i j.\n            \\<lbrakk>i < length xs; j < length (xs ! i)\\<rbrakk>\n            \\<Longrightarrow> P (xs ! i ! j) (ys ! i ! j)\\<rbrakk>\n        \\<Longrightarrow> \\<forall>k<length (concat xs).\n                             P (concat xs ! k) (concat ys ! k);\n        \\<And>i.\n           i < length (x # xs) \\<Longrightarrow>\n           length ((x # xs) ! i) = length ((y # ys) ! i);\n        \\<And>i j.\n           \\<lbrakk>i < length (x # xs); j < length ((x # xs) ! i)\\<rbrakk>\n           \\<Longrightarrow> P ((x # xs) ! i ! j)\n                              ((y # ys) ! i ! j)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>k<length (concat (x # xs)).\n                            P (concat (x # xs) ! k) (concat (y # ys) ! k)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>k<length (concat (x # xs)).\n       P (concat (x # xs) ! k) (concat (y # ys) ! k)", "unfolding concat.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>k<length (x @ concat xs).\n       P ((x @ concat xs) ! k) ((y @ concat ys) ! k)", "proof (intro allI impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k.\n       k < length (x @ concat xs) \\<Longrightarrow>\n       P ((x @ concat xs) ! k) ((y @ concat ys) ! k)", "fix k"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k.\n       k < length (x @ concat xs) \\<Longrightarrow>\n       P ((x @ concat xs) ! k) ((y @ concat ys) ! k)", "assume k: \"k < length (x @ concat xs)\""], ["proof (state)\nthis:\n  k < length (x @ concat xs)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       k < length (x @ concat xs) \\<Longrightarrow>\n       P ((x @ concat xs) ! k) ((y @ concat ys) ! k)", "show \"P ((x @ concat xs) ! k) ((y @ concat ys) ! k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P ((x @ concat xs) ! k) ((y @ concat ys) ! k)", "proof (cases \"k < length x\")"], ["proof (state)\ngoal (2 subgoals):\n 1. k < length x \\<Longrightarrow>\n    P ((x @ concat xs) ! k) ((y @ concat ys) ! k)\n 2. \\<not> k < length x \\<Longrightarrow>\n    P ((x @ concat xs) ! k) ((y @ concat ys) ! k)", "case True"], ["proof (state)\nthis:\n  k < length x\n\ngoal (2 subgoals):\n 1. k < length x \\<Longrightarrow>\n    P ((x @ concat xs) ! k) ((y @ concat ys) ! k)\n 2. \\<not> k < length x \\<Longrightarrow>\n    P ((x @ concat xs) ! k) ((y @ concat ys) ! k)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. P ((x @ concat xs) ! k) ((y @ concat ys) ! k)", "unfolding nth_append"], ["proof (prove)\ngoal (1 subgoal):\n 1. P (if k < length x then x ! k else concat xs ! (k - length x))\n     (if k < length y then y ! k else concat ys ! (k - length y))", "using True xy pxy[OF True]"], ["proof (prove)\nusing this:\n  k < length x\n  length x = length y\n  P (x ! k) (y ! k)\n\ngoal (1 subgoal):\n 1. P (if k < length x then x ! k else concat xs ! (k - length x))\n     (if k < length y then y ! k else concat ys ! (k - length y))", "by simp"], ["proof (state)\nthis:\n  P ((x @ concat xs) ! k) ((y @ concat ys) ! k)\n\ngoal (1 subgoal):\n 1. \\<not> k < length x \\<Longrightarrow>\n    P ((x @ concat xs) ! k) ((y @ concat ys) ! k)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> k < length x \\<Longrightarrow>\n    P ((x @ concat xs) ! k) ((y @ concat ys) ! k)", "case False"], ["proof (state)\nthis:\n  \\<not> k < length x\n\ngoal (1 subgoal):\n 1. \\<not> k < length x \\<Longrightarrow>\n    P ((x @ concat xs) ! k) ((y @ concat ys) ! k)", "with k"], ["proof (chain)\npicking this:\n  k < length (x @ concat xs)\n  \\<not> k < length x", "have \"k - (length x) < length (concat xs)\""], ["proof (prove)\nusing this:\n  k < length (x @ concat xs)\n  \\<not> k < length x\n\ngoal (1 subgoal):\n 1. k - length x < length (concat xs)", "by auto"], ["proof (state)\nthis:\n  k - length x < length (concat xs)\n\ngoal (1 subgoal):\n 1. \\<not> k < length x \\<Longrightarrow>\n    P ((x @ concat xs) ! k) ((y @ concat ys) ! k)", "then"], ["proof (chain)\npicking this:\n  k - length x < length (concat xs)", "obtain n where n: \"k - length x = n\" and nxs: \"n < length (concat xs)\""], ["proof (prove)\nusing this:\n  k - length x < length (concat xs)\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        \\<lbrakk>k - length x = n; n < length (concat xs)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  k - length x = n\n  n < length (concat xs)\n\ngoal (1 subgoal):\n 1. \\<not> k < length x \\<Longrightarrow>\n    P ((x @ concat xs) ! k) ((y @ concat ys) ! k)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. P ((x @ concat xs) ! k) ((y @ concat ys) ! k)", "unfolding nth_append n n[unfolded xy]"], ["proof (prove)\ngoal (1 subgoal):\n 1. P (if k < length x then x ! k else concat xs ! n)\n     (if k < length y then y ! k else concat ys ! n)", "using False xy ind[OF nxs]"], ["proof (prove)\nusing this:\n  \\<not> k < length x\n  length x = length y\n  P (concat xs ! n) (concat ys ! n)\n\ngoal (1 subgoal):\n 1. P (if k < length x then x ! k else concat xs ! n)\n     (if k < length y then y ! k else concat ys ! n)", "by auto"], ["proof (state)\nthis:\n  P ((x @ concat xs) ! k) ((y @ concat ys) ! k)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  P ((x @ concat xs) ! k) ((y @ concat ys) ! k)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>k<length (concat (x # xs)).\n     P (concat (x # xs) ! k) (concat (y # ys) ! k)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>i.\n                i < length [] \\<Longrightarrow>\n                length ([] ! i) = length ([] ! i);\n     \\<And>i j.\n        \\<lbrakk>i < length []; j < length ([] ! i)\\<rbrakk>\n        \\<Longrightarrow> P ([] ! i ! j) ([] ! i ! j)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>k<length (concat []).\n                         P (concat [] ! k) (concat [] ! k)", "qed auto"], ["", "lemma eq_length_concat_nth:\n  assumes \"length xs = length ys\"\n    and \"\\<And>i. i < length xs \\<Longrightarrow> length (xs ! i) = length (ys ! i)\"\n  shows \"length (concat xs) = length (concat ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (concat xs) = length (concat ys)", "using assms"], ["proof (prove)\nusing this:\n  length xs = length ys\n  ?i < length xs \\<Longrightarrow> length (xs ! ?i) = length (ys ! ?i)\n\ngoal (1 subgoal):\n 1. length (concat xs) = length (concat ys)", "proof (induct xs ys rule: list_induct2)"], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<And>i.\n        i < length [] \\<Longrightarrow>\n        length ([] ! i) = length ([] ! i)) \\<Longrightarrow>\n    length (concat []) = length (concat [])\n 2. \\<And>x xs y ys.\n       \\<lbrakk>length xs = length ys;\n        (\\<And>i.\n            i < length xs \\<Longrightarrow>\n            length (xs ! i) = length (ys ! i)) \\<Longrightarrow>\n        length (concat xs) = length (concat ys);\n        \\<And>i.\n           i < length (x # xs) \\<Longrightarrow>\n           length ((x # xs) ! i) = length ((y # ys) ! i)\\<rbrakk>\n       \\<Longrightarrow> length (concat (x # xs)) = length (concat (y # ys))", "case (Cons x xs y ys)"], ["proof (state)\nthis:\n  length xs = length ys\n  (\\<And>i.\n      i < length xs \\<Longrightarrow>\n      length (xs ! i) = length (ys ! i)) \\<Longrightarrow>\n  length (concat xs) = length (concat ys)\n  ?i < length (x # xs) \\<Longrightarrow>\n  length ((x # xs) ! ?i) = length ((y # ys) ! ?i)\n\ngoal (2 subgoals):\n 1. (\\<And>i.\n        i < length [] \\<Longrightarrow>\n        length ([] ! i) = length ([] ! i)) \\<Longrightarrow>\n    length (concat []) = length (concat [])\n 2. \\<And>x xs y ys.\n       \\<lbrakk>length xs = length ys;\n        (\\<And>i.\n            i < length xs \\<Longrightarrow>\n            length (xs ! i) = length (ys ! i)) \\<Longrightarrow>\n        length (concat xs) = length (concat ys);\n        \\<And>i.\n           i < length (x # xs) \\<Longrightarrow>\n           length ((x # xs) ! i) = length ((y # ys) ! i)\\<rbrakk>\n       \\<Longrightarrow> length (concat (x # xs)) = length (concat (y # ys))", "from Cons(3)[of 0]"], ["proof (chain)\npicking this:\n  0 < length (x # xs) \\<Longrightarrow>\n  length ((x # xs) ! 0) = length ((y # ys) ! 0)", "have xy: \"length x = length y\""], ["proof (prove)\nusing this:\n  0 < length (x # xs) \\<Longrightarrow>\n  length ((x # xs) ! 0) = length ((y # ys) ! 0)\n\ngoal (1 subgoal):\n 1. length x = length y", "by simp"], ["proof (state)\nthis:\n  length x = length y\n\ngoal (2 subgoals):\n 1. (\\<And>i.\n        i < length [] \\<Longrightarrow>\n        length ([] ! i) = length ([] ! i)) \\<Longrightarrow>\n    length (concat []) = length (concat [])\n 2. \\<And>x xs y ys.\n       \\<lbrakk>length xs = length ys;\n        (\\<And>i.\n            i < length xs \\<Longrightarrow>\n            length (xs ! i) = length (ys ! i)) \\<Longrightarrow>\n        length (concat xs) = length (concat ys);\n        \\<And>i.\n           i < length (x # xs) \\<Longrightarrow>\n           length ((x # xs) ! i) = length ((y # ys) ! i)\\<rbrakk>\n       \\<Longrightarrow> length (concat (x # xs)) = length (concat (y # ys))", "{"], ["proof (state)\nthis:\n  length x = length y\n\ngoal (2 subgoals):\n 1. (\\<And>i.\n        i < length [] \\<Longrightarrow>\n        length ([] ! i) = length ([] ! i)) \\<Longrightarrow>\n    length (concat []) = length (concat [])\n 2. \\<And>x xs y ys.\n       \\<lbrakk>length xs = length ys;\n        (\\<And>i.\n            i < length xs \\<Longrightarrow>\n            length (xs ! i) = length (ys ! i)) \\<Longrightarrow>\n        length (concat xs) = length (concat ys);\n        \\<And>i.\n           i < length (x # xs) \\<Longrightarrow>\n           length ((x # xs) ! i) = length ((y # ys) ! i)\\<rbrakk>\n       \\<Longrightarrow> length (concat (x # xs)) = length (concat (y # ys))", "fix i"], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<And>i.\n        i < length [] \\<Longrightarrow>\n        length ([] ! i) = length ([] ! i)) \\<Longrightarrow>\n    length (concat []) = length (concat [])\n 2. \\<And>x xs y ys.\n       \\<lbrakk>length xs = length ys;\n        (\\<And>i.\n            i < length xs \\<Longrightarrow>\n            length (xs ! i) = length (ys ! i)) \\<Longrightarrow>\n        length (concat xs) = length (concat ys);\n        \\<And>i.\n           i < length (x # xs) \\<Longrightarrow>\n           length ((x # xs) ! i) = length ((y # ys) ! i)\\<rbrakk>\n       \\<Longrightarrow> length (concat (x # xs)) = length (concat (y # ys))", "assume \"i < length xs\""], ["proof (state)\nthis:\n  i < length xs\n\ngoal (2 subgoals):\n 1. (\\<And>i.\n        i < length [] \\<Longrightarrow>\n        length ([] ! i) = length ([] ! i)) \\<Longrightarrow>\n    length (concat []) = length (concat [])\n 2. \\<And>x xs y ys.\n       \\<lbrakk>length xs = length ys;\n        (\\<And>i.\n            i < length xs \\<Longrightarrow>\n            length (xs ! i) = length (ys ! i)) \\<Longrightarrow>\n        length (concat xs) = length (concat ys);\n        \\<And>i.\n           i < length (x # xs) \\<Longrightarrow>\n           length ((x # xs) ! i) = length ((y # ys) ! i)\\<rbrakk>\n       \\<Longrightarrow> length (concat (x # xs)) = length (concat (y # ys))", "with Cons(3)[of \"Suc i\"]"], ["proof (chain)\npicking this:\n  Suc i < length (x # xs) \\<Longrightarrow>\n  length ((x # xs) ! Suc i) = length ((y # ys) ! Suc i)\n  i < length xs", "have \"length (xs ! i) = length (ys ! i)\""], ["proof (prove)\nusing this:\n  Suc i < length (x # xs) \\<Longrightarrow>\n  length ((x # xs) ! Suc i) = length ((y # ys) ! Suc i)\n  i < length xs\n\ngoal (1 subgoal):\n 1. length (xs ! i) = length (ys ! i)", "by simp"], ["proof (state)\nthis:\n  length (xs ! i) = length (ys ! i)\n\ngoal (2 subgoals):\n 1. (\\<And>i.\n        i < length [] \\<Longrightarrow>\n        length ([] ! i) = length ([] ! i)) \\<Longrightarrow>\n    length (concat []) = length (concat [])\n 2. \\<And>x xs y ys.\n       \\<lbrakk>length xs = length ys;\n        (\\<And>i.\n            i < length xs \\<Longrightarrow>\n            length (xs ! i) = length (ys ! i)) \\<Longrightarrow>\n        length (concat xs) = length (concat ys);\n        \\<And>i.\n           i < length (x # xs) \\<Longrightarrow>\n           length ((x # xs) ! i) = length ((y # ys) ! i)\\<rbrakk>\n       \\<Longrightarrow> length (concat (x # xs)) = length (concat (y # ys))", "}"], ["proof (state)\nthis:\n  ?i2 < length xs \\<Longrightarrow> length (xs ! ?i2) = length (ys ! ?i2)\n\ngoal (2 subgoals):\n 1. (\\<And>i.\n        i < length [] \\<Longrightarrow>\n        length ([] ! i) = length ([] ! i)) \\<Longrightarrow>\n    length (concat []) = length (concat [])\n 2. \\<And>x xs y ys.\n       \\<lbrakk>length xs = length ys;\n        (\\<And>i.\n            i < length xs \\<Longrightarrow>\n            length (xs ! i) = length (ys ! i)) \\<Longrightarrow>\n        length (concat xs) = length (concat ys);\n        \\<And>i.\n           i < length (x # xs) \\<Longrightarrow>\n           length ((x # xs) ! i) = length ((y # ys) ! i)\\<rbrakk>\n       \\<Longrightarrow> length (concat (x # xs)) = length (concat (y # ys))", "from Cons(2)[OF this]"], ["proof (chain)\npicking this:\n  (\\<And>i. i < length xs \\<Longrightarrow> i < length xs) \\<Longrightarrow>\n  length (concat xs) = length (concat ys)", "have ind: \"length (concat xs) = length (concat ys)\""], ["proof (prove)\nusing this:\n  (\\<And>i. i < length xs \\<Longrightarrow> i < length xs) \\<Longrightarrow>\n  length (concat xs) = length (concat ys)\n\ngoal (1 subgoal):\n 1. length (concat xs) = length (concat ys)", "by simp"], ["proof (state)\nthis:\n  length (concat xs) = length (concat ys)\n\ngoal (2 subgoals):\n 1. (\\<And>i.\n        i < length [] \\<Longrightarrow>\n        length ([] ! i) = length ([] ! i)) \\<Longrightarrow>\n    length (concat []) = length (concat [])\n 2. \\<And>x xs y ys.\n       \\<lbrakk>length xs = length ys;\n        (\\<And>i.\n            i < length xs \\<Longrightarrow>\n            length (xs ! i) = length (ys ! i)) \\<Longrightarrow>\n        length (concat xs) = length (concat ys);\n        \\<And>i.\n           i < length (x # xs) \\<Longrightarrow>\n           length ((x # xs) ! i) = length ((y # ys) ! i)\\<rbrakk>\n       \\<Longrightarrow> length (concat (x # xs)) = length (concat (y # ys))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (concat (x # xs)) = length (concat (y # ys))", "using xy ind"], ["proof (prove)\nusing this:\n  length x = length y\n  length (concat xs) = length (concat ys)\n\ngoal (1 subgoal):\n 1. length (concat (x # xs)) = length (concat (y # ys))", "by auto"], ["proof (state)\nthis:\n  length (concat (x # xs)) = length (concat (y # ys))\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        i < length [] \\<Longrightarrow>\n        length ([] ! i) = length ([] ! i)) \\<Longrightarrow>\n    length (concat []) = length (concat [])", "qed auto"], ["", "primrec\n  list_union :: \"'a list \\<Rightarrow> 'a list \\<Rightarrow> 'a list\"\nwhere\n  \"list_union [] ys = ys\"\n| \"list_union (x # xs) ys = (let zs = list_union xs ys in if x \\<in> set zs then zs else x # zs)\""], ["", "lemma set_list_union[simp]: \"set (list_union xs ys) = set xs \\<union> set ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (list_union xs ys) = set xs \\<union> set ys", "proof (induct xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. set (list_union [] ys) = set [] \\<union> set ys\n 2. \\<And>a xs.\n       set (list_union xs ys) = set xs \\<union> set ys \\<Longrightarrow>\n       set (list_union (a # xs) ys) = set (a # xs) \\<union> set ys", "case (Cons x xs)"], ["proof (state)\nthis:\n  set (list_union xs ys) = set xs \\<union> set ys\n\ngoal (2 subgoals):\n 1. set (list_union [] ys) = set [] \\<union> set ys\n 2. \\<And>a xs.\n       set (list_union xs ys) = set xs \\<union> set ys \\<Longrightarrow>\n       set (list_union (a # xs) ys) = set (a # xs) \\<union> set ys", "thus ?case"], ["proof (prove)\nusing this:\n  set (list_union xs ys) = set xs \\<union> set ys\n\ngoal (1 subgoal):\n 1. set (list_union (x # xs) ys) = set (x # xs) \\<union> set ys", "by (cases \"x \\<in> set (list_union xs ys)\") (auto)"], ["proof (state)\nthis:\n  set (list_union (x # xs) ys) = set (x # xs) \\<union> set ys\n\ngoal (1 subgoal):\n 1. set (list_union [] ys) = set [] \\<union> set ys", "qed simp"], ["", "declare list_union.simps[simp del]"], ["", "(*Why was list_inter thrown out of List.thy?*)"], ["", "fun list_inter :: \"'a list \\<Rightarrow> 'a list \\<Rightarrow> 'a list\" where\n  \"list_inter [] bs = []\"\n| \"list_inter (a#as) bs =\n    (if a \\<in> set bs then a # list_inter as bs else list_inter as bs)\""], ["", "lemma set_list_inter[simp]:\n  \"set (list_inter xs ys) = set xs \\<inter> set ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (list_inter xs ys) = set xs \\<inter> set ys", "by (induct rule: list_inter.induct) simp_all"], ["", "declare list_inter.simps[simp del]"], ["", "primrec list_diff :: \"'a list \\<Rightarrow> 'a list \\<Rightarrow> 'a list\" where\n  \"list_diff [] ys = []\"\n| \"list_diff (x # xs) ys = (let zs = list_diff xs ys in if x \\<in> set ys then zs else x # zs)\""], ["", "lemma set_list_diff[simp]:\n  \"set (list_diff xs ys) = set xs - set ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (list_diff xs ys) = set xs - set ys", "proof (induct xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. set (list_diff [] ys) = set [] - set ys\n 2. \\<And>a xs.\n       set (list_diff xs ys) = set xs - set ys \\<Longrightarrow>\n       set (list_diff (a # xs) ys) = set (a # xs) - set ys", "case (Cons x xs)"], ["proof (state)\nthis:\n  set (list_diff xs ys) = set xs - set ys\n\ngoal (2 subgoals):\n 1. set (list_diff [] ys) = set [] - set ys\n 2. \\<And>a xs.\n       set (list_diff xs ys) = set xs - set ys \\<Longrightarrow>\n       set (list_diff (a # xs) ys) = set (a # xs) - set ys", "thus ?case"], ["proof (prove)\nusing this:\n  set (list_diff xs ys) = set xs - set ys\n\ngoal (1 subgoal):\n 1. set (list_diff (x # xs) ys) = set (x # xs) - set ys", "by (cases \"x \\<in> set ys\") (auto)"], ["proof (state)\nthis:\n  set (list_diff (x # xs) ys) = set (x # xs) - set ys\n\ngoal (1 subgoal):\n 1. set (list_diff [] ys) = set [] - set ys", "qed simp"], ["", "declare list_diff.simps[simp del]"], ["", "lemma nth_drop_0: \"0 < length ss \\<Longrightarrow> (ss!0)#drop (Suc 0) ss = ss\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < length ss \\<Longrightarrow> ss ! 0 # drop (Suc 0) ss = ss", "by (induct ss) auto"], ["", "lemma set_foldr_remdups_set_map_conv[simp]:\n  \"set (foldr (\\<lambda>x xs. remdups (f x @ xs)) xs []) = \\<Union>(set (map (set \\<circ> f) xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (foldr (\\<lambda>x xs. remdups (f x @ xs)) xs []) =\n    \\<Union> (set (map (set \\<circ> f) xs))", "by (induct xs) auto"], ["", "lemma subset_set_code[code_unfold]: \"set xs \\<subseteq> set ys \\<longleftrightarrow> list_all (\\<lambda>x. x \\<in> set ys) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (set xs \\<subseteq> set ys) = list_all (\\<lambda>x. x \\<in> set ys) xs", "unfolding list_all_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. (set xs \\<subseteq> set ys) = (\\<forall>x\\<in>set xs. x \\<in> set ys)", "by auto"], ["", "fun union_list_sorted where\n  \"union_list_sorted (x # xs) (y # ys) = \n   (if x = y then x # union_list_sorted xs ys \n    else if x < y then x # union_list_sorted xs (y # ys)\n    else y # union_list_sorted (x # xs) ys)\"\n| \"union_list_sorted [] ys = ys\"\n| \"union_list_sorted xs [] = xs\""], ["", "lemma [simp]: \"set (union_list_sorted xs ys) = set xs \\<union> set ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (union_list_sorted xs ys) = set xs \\<union> set ys", "by (induct xs ys rule: union_list_sorted.induct, auto)"], ["", "fun subtract_list_sorted :: \"('a :: linorder) list \\<Rightarrow> 'a list \\<Rightarrow> 'a list\" where\n  \"subtract_list_sorted (x # xs) (y # ys) = \n   (if x = y then subtract_list_sorted xs (y # ys) \n    else if x < y then x # subtract_list_sorted xs (y # ys)\n    else subtract_list_sorted (x # xs) ys)\"\n| \"subtract_list_sorted [] ys = []\"\n| \"subtract_list_sorted xs [] = xs\""], ["", "lemma set_subtract_list_sorted[simp]: \"sorted xs \\<Longrightarrow> sorted ys \\<Longrightarrow>\n  set (subtract_list_sorted xs ys) = set xs - set ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sorted xs; sorted ys\\<rbrakk>\n    \\<Longrightarrow> set (subtract_list_sorted xs ys) = set xs - set ys", "proof (induct xs ys rule: subtract_list_sorted.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x xs y ys.\n       \\<lbrakk>\\<lbrakk>x = y; sorted xs; sorted (y # ys)\\<rbrakk>\n                \\<Longrightarrow> set (subtract_list_sorted xs (y # ys)) =\n                                  set xs - set (y # ys);\n        \\<lbrakk>x \\<noteq> y; x < y; sorted xs; sorted (y # ys)\\<rbrakk>\n        \\<Longrightarrow> set (subtract_list_sorted xs (y # ys)) =\n                          set xs - set (y # ys);\n        \\<lbrakk>x \\<noteq> y; \\<not> x < y; sorted (x # xs);\n         sorted ys\\<rbrakk>\n        \\<Longrightarrow> set (subtract_list_sorted (x # xs) ys) =\n                          set (x # xs) - set ys;\n        sorted (x # xs); sorted (y # ys)\\<rbrakk>\n       \\<Longrightarrow> set (subtract_list_sorted (x # xs) (y # ys)) =\n                         set (x # xs) - set (y # ys)\n 2. \\<And>ys.\n       \\<lbrakk>sorted []; sorted ys\\<rbrakk>\n       \\<Longrightarrow> set (subtract_list_sorted [] ys) = set [] - set ys\n 3. \\<And>v va.\n       \\<lbrakk>sorted (v # va); sorted []\\<rbrakk>\n       \\<Longrightarrow> set (subtract_list_sorted (v # va) []) =\n                         set (v # va) - set []", "case (1 x xs y ys)"], ["proof (state)\nthis:\n  \\<lbrakk>x = y; sorted xs; sorted (y # ys)\\<rbrakk>\n  \\<Longrightarrow> set (subtract_list_sorted xs (y # ys)) =\n                    set xs - set (y # ys)\n  \\<lbrakk>x \\<noteq> y; x < y; sorted xs; sorted (y # ys)\\<rbrakk>\n  \\<Longrightarrow> set (subtract_list_sorted xs (y # ys)) =\n                    set xs - set (y # ys)\n  \\<lbrakk>x \\<noteq> y; \\<not> x < y; sorted (x # xs); sorted ys\\<rbrakk>\n  \\<Longrightarrow> set (subtract_list_sorted (x # xs) ys) =\n                    set (x # xs) - set ys\n  sorted (x # xs)\n  sorted (y # ys)\n\ngoal (3 subgoals):\n 1. \\<And>x xs y ys.\n       \\<lbrakk>\\<lbrakk>x = y; sorted xs; sorted (y # ys)\\<rbrakk>\n                \\<Longrightarrow> set (subtract_list_sorted xs (y # ys)) =\n                                  set xs - set (y # ys);\n        \\<lbrakk>x \\<noteq> y; x < y; sorted xs; sorted (y # ys)\\<rbrakk>\n        \\<Longrightarrow> set (subtract_list_sorted xs (y # ys)) =\n                          set xs - set (y # ys);\n        \\<lbrakk>x \\<noteq> y; \\<not> x < y; sorted (x # xs);\n         sorted ys\\<rbrakk>\n        \\<Longrightarrow> set (subtract_list_sorted (x # xs) ys) =\n                          set (x # xs) - set ys;\n        sorted (x # xs); sorted (y # ys)\\<rbrakk>\n       \\<Longrightarrow> set (subtract_list_sorted (x # xs) (y # ys)) =\n                         set (x # xs) - set (y # ys)\n 2. \\<And>ys.\n       \\<lbrakk>sorted []; sorted ys\\<rbrakk>\n       \\<Longrightarrow> set (subtract_list_sorted [] ys) = set [] - set ys\n 3. \\<And>v va.\n       \\<lbrakk>sorted (v # va); sorted []\\<rbrakk>\n       \\<Longrightarrow> set (subtract_list_sorted (v # va) []) =\n                         set (v # va) - set []", "have xxs: \"sorted (x # xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted (x # xs)", "by fact"], ["proof (state)\nthis:\n  sorted (x # xs)\n\ngoal (3 subgoals):\n 1. \\<And>x xs y ys.\n       \\<lbrakk>\\<lbrakk>x = y; sorted xs; sorted (y # ys)\\<rbrakk>\n                \\<Longrightarrow> set (subtract_list_sorted xs (y # ys)) =\n                                  set xs - set (y # ys);\n        \\<lbrakk>x \\<noteq> y; x < y; sorted xs; sorted (y # ys)\\<rbrakk>\n        \\<Longrightarrow> set (subtract_list_sorted xs (y # ys)) =\n                          set xs - set (y # ys);\n        \\<lbrakk>x \\<noteq> y; \\<not> x < y; sorted (x # xs);\n         sorted ys\\<rbrakk>\n        \\<Longrightarrow> set (subtract_list_sorted (x # xs) ys) =\n                          set (x # xs) - set ys;\n        sorted (x # xs); sorted (y # ys)\\<rbrakk>\n       \\<Longrightarrow> set (subtract_list_sorted (x # xs) (y # ys)) =\n                         set (x # xs) - set (y # ys)\n 2. \\<And>ys.\n       \\<lbrakk>sorted []; sorted ys\\<rbrakk>\n       \\<Longrightarrow> set (subtract_list_sorted [] ys) = set [] - set ys\n 3. \\<And>v va.\n       \\<lbrakk>sorted (v # va); sorted []\\<rbrakk>\n       \\<Longrightarrow> set (subtract_list_sorted (v # va) []) =\n                         set (v # va) - set []", "have yys: \"sorted (y # ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted (y # ys)", "by fact"], ["proof (state)\nthis:\n  sorted (y # ys)\n\ngoal (3 subgoals):\n 1. \\<And>x xs y ys.\n       \\<lbrakk>\\<lbrakk>x = y; sorted xs; sorted (y # ys)\\<rbrakk>\n                \\<Longrightarrow> set (subtract_list_sorted xs (y # ys)) =\n                                  set xs - set (y # ys);\n        \\<lbrakk>x \\<noteq> y; x < y; sorted xs; sorted (y # ys)\\<rbrakk>\n        \\<Longrightarrow> set (subtract_list_sorted xs (y # ys)) =\n                          set xs - set (y # ys);\n        \\<lbrakk>x \\<noteq> y; \\<not> x < y; sorted (x # xs);\n         sorted ys\\<rbrakk>\n        \\<Longrightarrow> set (subtract_list_sorted (x # xs) ys) =\n                          set (x # xs) - set ys;\n        sorted (x # xs); sorted (y # ys)\\<rbrakk>\n       \\<Longrightarrow> set (subtract_list_sorted (x # xs) (y # ys)) =\n                         set (x # xs) - set (y # ys)\n 2. \\<And>ys.\n       \\<lbrakk>sorted []; sorted ys\\<rbrakk>\n       \\<Longrightarrow> set (subtract_list_sorted [] ys) = set [] - set ys\n 3. \\<And>v va.\n       \\<lbrakk>sorted (v # va); sorted []\\<rbrakk>\n       \\<Longrightarrow> set (subtract_list_sorted (v # va) []) =\n                         set (v # va) - set []", "have xs: \"sorted xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted xs", "using xxs"], ["proof (prove)\nusing this:\n  sorted (x # xs)\n\ngoal (1 subgoal):\n 1. sorted xs", "by (simp)"], ["proof (state)\nthis:\n  sorted xs\n\ngoal (3 subgoals):\n 1. \\<And>x xs y ys.\n       \\<lbrakk>\\<lbrakk>x = y; sorted xs; sorted (y # ys)\\<rbrakk>\n                \\<Longrightarrow> set (subtract_list_sorted xs (y # ys)) =\n                                  set xs - set (y # ys);\n        \\<lbrakk>x \\<noteq> y; x < y; sorted xs; sorted (y # ys)\\<rbrakk>\n        \\<Longrightarrow> set (subtract_list_sorted xs (y # ys)) =\n                          set xs - set (y # ys);\n        \\<lbrakk>x \\<noteq> y; \\<not> x < y; sorted (x # xs);\n         sorted ys\\<rbrakk>\n        \\<Longrightarrow> set (subtract_list_sorted (x # xs) ys) =\n                          set (x # xs) - set ys;\n        sorted (x # xs); sorted (y # ys)\\<rbrakk>\n       \\<Longrightarrow> set (subtract_list_sorted (x # xs) (y # ys)) =\n                         set (x # xs) - set (y # ys)\n 2. \\<And>ys.\n       \\<lbrakk>sorted []; sorted ys\\<rbrakk>\n       \\<Longrightarrow> set (subtract_list_sorted [] ys) = set [] - set ys\n 3. \\<And>v va.\n       \\<lbrakk>sorted (v # va); sorted []\\<rbrakk>\n       \\<Longrightarrow> set (subtract_list_sorted (v # va) []) =\n                         set (v # va) - set []", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (subtract_list_sorted (x # xs) (y # ys)) =\n    set (x # xs) - set (y # ys)", "proof (cases \"x = y\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x = y \\<Longrightarrow>\n    set (subtract_list_sorted (x # xs) (y # ys)) =\n    set (x # xs) - set (y # ys)\n 2. x \\<noteq> y \\<Longrightarrow>\n    set (subtract_list_sorted (x # xs) (y # ys)) =\n    set (x # xs) - set (y # ys)", "case True"], ["proof (state)\nthis:\n  x = y\n\ngoal (2 subgoals):\n 1. x = y \\<Longrightarrow>\n    set (subtract_list_sorted (x # xs) (y # ys)) =\n    set (x # xs) - set (y # ys)\n 2. x \\<noteq> y \\<Longrightarrow>\n    set (subtract_list_sorted (x # xs) (y # ys)) =\n    set (x # xs) - set (y # ys)", "thus ?thesis"], ["proof (prove)\nusing this:\n  x = y\n\ngoal (1 subgoal):\n 1. set (subtract_list_sorted (x # xs) (y # ys)) =\n    set (x # xs) - set (y # ys)", "using 1(1)[OF True xs yys]"], ["proof (prove)\nusing this:\n  x = y\n  set (subtract_list_sorted xs (y # ys)) = set xs - set (y # ys)\n\ngoal (1 subgoal):\n 1. set (subtract_list_sorted (x # xs) (y # ys)) =\n    set (x # xs) - set (y # ys)", "by auto"], ["proof (state)\nthis:\n  set (subtract_list_sorted (x # xs) (y # ys)) = set (x # xs) - set (y # ys)\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow>\n    set (subtract_list_sorted (x # xs) (y # ys)) =\n    set (x # xs) - set (y # ys)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow>\n    set (subtract_list_sorted (x # xs) (y # ys)) =\n    set (x # xs) - set (y # ys)", "case False"], ["proof (state)\nthis:\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow>\n    set (subtract_list_sorted (x # xs) (y # ys)) =\n    set (x # xs) - set (y # ys)", "note neq = this"], ["proof (state)\nthis:\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow>\n    set (subtract_list_sorted (x # xs) (y # ys)) =\n    set (x # xs) - set (y # ys)", "note IH = 1(2-3)[OF this]"], ["proof (state)\nthis:\n  \\<lbrakk>x < y; sorted xs; sorted (y # ys)\\<rbrakk>\n  \\<Longrightarrow> set (subtract_list_sorted xs (y # ys)) =\n                    set xs - set (y # ys)\n  \\<lbrakk>\\<not> x < y; sorted (x # xs); sorted ys\\<rbrakk>\n  \\<Longrightarrow> set (subtract_list_sorted (x # xs) ys) =\n                    set (x # xs) - set ys\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow>\n    set (subtract_list_sorted (x # xs) (y # ys)) =\n    set (x # xs) - set (y # ys)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (subtract_list_sorted (x # xs) (y # ys)) =\n    set (x # xs) - set (y # ys)", "by (cases \"x < y\", insert IH xxs yys False, auto)"], ["proof (state)\nthis:\n  set (subtract_list_sorted (x # xs) (y # ys)) = set (x # xs) - set (y # ys)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  set (subtract_list_sorted (x # xs) (y # ys)) = set (x # xs) - set (y # ys)\n\ngoal (2 subgoals):\n 1. \\<And>ys.\n       \\<lbrakk>sorted []; sorted ys\\<rbrakk>\n       \\<Longrightarrow> set (subtract_list_sorted [] ys) = set [] - set ys\n 2. \\<And>v va.\n       \\<lbrakk>sorted (v # va); sorted []\\<rbrakk>\n       \\<Longrightarrow> set (subtract_list_sorted (v # va) []) =\n                         set (v # va) - set []", "qed auto"], ["", "lemma subset_subtract_listed_sorted: \"set (subtract_list_sorted xs ys) \\<subseteq> set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (subtract_list_sorted xs ys) \\<subseteq> set xs", "by (induct xs ys rule: subtract_list_sorted.induct, auto)"], ["", "lemma set_subtract_list_distinct[simp]: \"distinct xs \\<Longrightarrow> distinct (subtract_list_sorted xs ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct xs \\<Longrightarrow> distinct (subtract_list_sorted xs ys)", "by (induct xs ys rule: subtract_list_sorted.induct, insert subset_subtract_listed_sorted, auto)"], ["", "definition \"remdups_sort xs = remdups_adj (sort xs)\""], ["", "lemma remdups_sort[simp]: \"sorted (remdups_sort xs)\" \"set (remdups_sort xs) = set xs\"\n  \"distinct (remdups_sort xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted (remdups_sort xs) &&&\n    set (remdups_sort xs) = set xs &&& distinct (remdups_sort xs)", "by (simp_all add: remdups_sort_def)"], ["", "text \\<open>maximum and minimum\\<close>"], ["", "lemma max_list_mono: assumes \"\\<And> x. x \\<in> set xs - set ys \\<Longrightarrow> \\<exists> y. y \\<in> set ys \\<and> x \\<le> y\"\n  shows \"max_list xs \\<le> max_list ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. max_list xs \\<le> max_list ys", "using assms"], ["proof (prove)\nusing this:\n  ?x \\<in> set xs - set ys \\<Longrightarrow>\n  \\<exists>y. y \\<in> set ys \\<and> ?x \\<le> y\n\ngoal (1 subgoal):\n 1. max_list xs \\<le> max_list ys", "proof (induct xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<And>x.\n        x \\<in> set [] - set ys \\<Longrightarrow>\n        \\<exists>y. y \\<in> set ys \\<and> x \\<le> y) \\<Longrightarrow>\n    max_list [] \\<le> max_list ys\n 2. \\<And>a xs.\n       \\<lbrakk>(\\<And>x.\n                    x \\<in> set xs - set ys \\<Longrightarrow>\n                    \\<exists>y.\n                       y \\<in> set ys \\<and> x \\<le> y) \\<Longrightarrow>\n                max_list xs \\<le> max_list ys;\n        \\<And>x.\n           x \\<in> set (a # xs) - set ys \\<Longrightarrow>\n           \\<exists>y. y \\<in> set ys \\<and> x \\<le> y\\<rbrakk>\n       \\<Longrightarrow> max_list (a # xs) \\<le> max_list ys", "case (Cons x xs)"], ["proof (state)\nthis:\n  (\\<And>x.\n      x \\<in> set xs - set ys \\<Longrightarrow>\n      \\<exists>y. y \\<in> set ys \\<and> x \\<le> y) \\<Longrightarrow>\n  max_list xs \\<le> max_list ys\n  ?x \\<in> set (x # xs) - set ys \\<Longrightarrow>\n  \\<exists>y. y \\<in> set ys \\<and> ?x \\<le> y\n\ngoal (2 subgoals):\n 1. (\\<And>x.\n        x \\<in> set [] - set ys \\<Longrightarrow>\n        \\<exists>y. y \\<in> set ys \\<and> x \\<le> y) \\<Longrightarrow>\n    max_list [] \\<le> max_list ys\n 2. \\<And>a xs.\n       \\<lbrakk>(\\<And>x.\n                    x \\<in> set xs - set ys \\<Longrightarrow>\n                    \\<exists>y.\n                       y \\<in> set ys \\<and> x \\<le> y) \\<Longrightarrow>\n                max_list xs \\<le> max_list ys;\n        \\<And>x.\n           x \\<in> set (a # xs) - set ys \\<Longrightarrow>\n           \\<exists>y. y \\<in> set ys \\<and> x \\<le> y\\<rbrakk>\n       \\<Longrightarrow> max_list (a # xs) \\<le> max_list ys", "have \"x \\<le> max_list ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> max_list ys", "proof (cases \"x \\<in> set ys\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<in> set ys \\<Longrightarrow> x \\<le> max_list ys\n 2. x \\<notin> set ys \\<Longrightarrow> x \\<le> max_list ys", "case True"], ["proof (state)\nthis:\n  x \\<in> set ys\n\ngoal (2 subgoals):\n 1. x \\<in> set ys \\<Longrightarrow> x \\<le> max_list ys\n 2. x \\<notin> set ys \\<Longrightarrow> x \\<le> max_list ys", "from max_list[OF this]"], ["proof (chain)\npicking this:\n  x \\<le> max_list ys", "show ?thesis"], ["proof (prove)\nusing this:\n  x \\<le> max_list ys\n\ngoal (1 subgoal):\n 1. x \\<le> max_list ys", "."], ["proof (state)\nthis:\n  x \\<le> max_list ys\n\ngoal (1 subgoal):\n 1. x \\<notin> set ys \\<Longrightarrow> x \\<le> max_list ys", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<notin> set ys \\<Longrightarrow> x \\<le> max_list ys", "case False"], ["proof (state)\nthis:\n  x \\<notin> set ys\n\ngoal (1 subgoal):\n 1. x \\<notin> set ys \\<Longrightarrow> x \\<le> max_list ys", "with Cons(2)[of x]"], ["proof (chain)\npicking this:\n  x \\<in> set (x # xs) - set ys \\<Longrightarrow>\n  \\<exists>y. y \\<in> set ys \\<and> x \\<le> y\n  x \\<notin> set ys", "obtain y where y: \"y \\<in> set ys\"\n      and xy: \"x \\<le> y\""], ["proof (prove)\nusing this:\n  x \\<in> set (x # xs) - set ys \\<Longrightarrow>\n  \\<exists>y. y \\<in> set ys \\<and> x \\<le> y\n  x \\<notin> set ys\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<in> set ys; x \\<le> y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  y \\<in> set ys\n  x \\<le> y\n\ngoal (1 subgoal):\n 1. x \\<notin> set ys \\<Longrightarrow> x \\<le> max_list ys", "from xy max_list[OF y]"], ["proof (chain)\npicking this:\n  x \\<le> y\n  y \\<le> max_list ys", "show ?thesis"], ["proof (prove)\nusing this:\n  x \\<le> y\n  y \\<le> max_list ys\n\ngoal (1 subgoal):\n 1. x \\<le> max_list ys", "by arith"], ["proof (state)\nthis:\n  x \\<le> max_list ys\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x \\<le> max_list ys\n\ngoal (2 subgoals):\n 1. (\\<And>x.\n        x \\<in> set [] - set ys \\<Longrightarrow>\n        \\<exists>y. y \\<in> set ys \\<and> x \\<le> y) \\<Longrightarrow>\n    max_list [] \\<le> max_list ys\n 2. \\<And>a xs.\n       \\<lbrakk>(\\<And>x.\n                    x \\<in> set xs - set ys \\<Longrightarrow>\n                    \\<exists>y.\n                       y \\<in> set ys \\<and> x \\<le> y) \\<Longrightarrow>\n                max_list xs \\<le> max_list ys;\n        \\<And>x.\n           x \\<in> set (a # xs) - set ys \\<Longrightarrow>\n           \\<exists>y. y \\<in> set ys \\<and> x \\<le> y\\<rbrakk>\n       \\<Longrightarrow> max_list (a # xs) \\<le> max_list ys", "moreover"], ["proof (state)\nthis:\n  x \\<le> max_list ys\n\ngoal (2 subgoals):\n 1. (\\<And>x.\n        x \\<in> set [] - set ys \\<Longrightarrow>\n        \\<exists>y. y \\<in> set ys \\<and> x \\<le> y) \\<Longrightarrow>\n    max_list [] \\<le> max_list ys\n 2. \\<And>a xs.\n       \\<lbrakk>(\\<And>x.\n                    x \\<in> set xs - set ys \\<Longrightarrow>\n                    \\<exists>y.\n                       y \\<in> set ys \\<and> x \\<le> y) \\<Longrightarrow>\n                max_list xs \\<le> max_list ys;\n        \\<And>x.\n           x \\<in> set (a # xs) - set ys \\<Longrightarrow>\n           \\<exists>y. y \\<in> set ys \\<and> x \\<le> y\\<rbrakk>\n       \\<Longrightarrow> max_list (a # xs) \\<le> max_list ys", "have \"max_list xs \\<le> max_list ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. max_list xs \\<le> max_list ys", "by (rule Cons(1)[OF Cons(2)], auto)"], ["proof (state)\nthis:\n  max_list xs \\<le> max_list ys\n\ngoal (2 subgoals):\n 1. (\\<And>x.\n        x \\<in> set [] - set ys \\<Longrightarrow>\n        \\<exists>y. y \\<in> set ys \\<and> x \\<le> y) \\<Longrightarrow>\n    max_list [] \\<le> max_list ys\n 2. \\<And>a xs.\n       \\<lbrakk>(\\<And>x.\n                    x \\<in> set xs - set ys \\<Longrightarrow>\n                    \\<exists>y.\n                       y \\<in> set ys \\<and> x \\<le> y) \\<Longrightarrow>\n                max_list xs \\<le> max_list ys;\n        \\<And>x.\n           x \\<in> set (a # xs) - set ys \\<Longrightarrow>\n           \\<exists>y. y \\<in> set ys \\<and> x \\<le> y\\<rbrakk>\n       \\<Longrightarrow> max_list (a # xs) \\<le> max_list ys", "ultimately"], ["proof (chain)\npicking this:\n  x \\<le> max_list ys\n  max_list xs \\<le> max_list ys", "show ?case"], ["proof (prove)\nusing this:\n  x \\<le> max_list ys\n  max_list xs \\<le> max_list ys\n\ngoal (1 subgoal):\n 1. max_list (x # xs) \\<le> max_list ys", "by auto"], ["proof (state)\nthis:\n  max_list (x # xs) \\<le> max_list ys\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        x \\<in> set [] - set ys \\<Longrightarrow>\n        \\<exists>y. y \\<in> set ys \\<and> x \\<le> y) \\<Longrightarrow>\n    max_list [] \\<le> max_list ys", "qed auto"], ["", "fun min_list :: \"('a :: linorder) list \\<Rightarrow> 'a\" where\n  \"min_list [x] = x\"\n| \"min_list (x # xs) = min x (min_list xs)\""], ["", "lemma min_list: \"(x :: 'a :: linorder) \\<in> set xs \\<Longrightarrow> min_list xs \\<le> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> set xs \\<Longrightarrow> Missing_List.min_list xs \\<le> x", "proof (induct xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<in> set [] \\<Longrightarrow> Missing_List.min_list [] \\<le> x\n 2. \\<And>a xs.\n       \\<lbrakk>x \\<in> set xs \\<Longrightarrow>\n                Missing_List.min_list xs \\<le> x;\n        x \\<in> set (a # xs)\\<rbrakk>\n       \\<Longrightarrow> Missing_List.min_list (a # xs) \\<le> x", "case oCons : (Cons y ys)"], ["proof (state)\nthis:\n  x \\<in> set ys \\<Longrightarrow> Missing_List.min_list ys \\<le> x\n  x \\<in> set (y # ys)\n\ngoal (2 subgoals):\n 1. x \\<in> set [] \\<Longrightarrow> Missing_List.min_list [] \\<le> x\n 2. \\<And>a xs.\n       \\<lbrakk>x \\<in> set xs \\<Longrightarrow>\n                Missing_List.min_list xs \\<le> x;\n        x \\<in> set (a # xs)\\<rbrakk>\n       \\<Longrightarrow> Missing_List.min_list (a # xs) \\<le> x", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. Missing_List.min_list (y # ys) \\<le> x", "proof (cases ys)"], ["proof (state)\ngoal (2 subgoals):\n 1. ys = [] \\<Longrightarrow> Missing_List.min_list (y # ys) \\<le> x\n 2. \\<And>a list.\n       ys = a # list \\<Longrightarrow>\n       Missing_List.min_list (y # ys) \\<le> x", "case Nil"], ["proof (state)\nthis:\n  ys = []\n\ngoal (2 subgoals):\n 1. ys = [] \\<Longrightarrow> Missing_List.min_list (y # ys) \\<le> x\n 2. \\<And>a list.\n       ys = a # list \\<Longrightarrow>\n       Missing_List.min_list (y # ys) \\<le> x", "thus ?thesis"], ["proof (prove)\nusing this:\n  ys = []\n\ngoal (1 subgoal):\n 1. Missing_List.min_list (y # ys) \\<le> x", "using oCons"], ["proof (prove)\nusing this:\n  ys = []\n  x \\<in> set ys \\<Longrightarrow> Missing_List.min_list ys \\<le> x\n  x \\<in> set (y # ys)\n\ngoal (1 subgoal):\n 1. Missing_List.min_list (y # ys) \\<le> x", "by auto"], ["proof (state)\nthis:\n  Missing_List.min_list (y # ys) \\<le> x\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ys = a # list \\<Longrightarrow>\n       Missing_List.min_list (y # ys) \\<le> x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ys = a # list \\<Longrightarrow>\n       Missing_List.min_list (y # ys) \\<le> x", "case (Cons z zs)"], ["proof (state)\nthis:\n  ys = z # zs\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ys = a # list \\<Longrightarrow>\n       Missing_List.min_list (y # ys) \\<le> x", "hence id: \"min_list (y # ys) = min y (min_list ys)\""], ["proof (prove)\nusing this:\n  ys = z # zs\n\ngoal (1 subgoal):\n 1. Missing_List.min_list (y # ys) = min y (Missing_List.min_list ys)", "by auto"], ["proof (state)\nthis:\n  Missing_List.min_list (y # ys) = min y (Missing_List.min_list ys)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ys = a # list \\<Longrightarrow>\n       Missing_List.min_list (y # ys) \\<le> x", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. Missing_List.min_list (y # ys) \\<le> x", "proof (cases \"x = y\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x = y \\<Longrightarrow> Missing_List.min_list (y # ys) \\<le> x\n 2. x \\<noteq> y \\<Longrightarrow> Missing_List.min_list (y # ys) \\<le> x", "case True"], ["proof (state)\nthis:\n  x = y\n\ngoal (2 subgoals):\n 1. x = y \\<Longrightarrow> Missing_List.min_list (y # ys) \\<le> x\n 2. x \\<noteq> y \\<Longrightarrow> Missing_List.min_list (y # ys) \\<le> x", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. Missing_List.min_list (y # ys) \\<le> x", "unfolding id True"], ["proof (prove)\ngoal (1 subgoal):\n 1. min y (Missing_List.min_list ys) \\<le> y", "by auto"], ["proof (state)\nthis:\n  Missing_List.min_list (y # ys) \\<le> x\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> Missing_List.min_list (y # ys) \\<le> x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> Missing_List.min_list (y # ys) \\<le> x", "case False"], ["proof (state)\nthis:\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> Missing_List.min_list (y # ys) \\<le> x", "have \"min y (min_list ys) \\<le> min_list ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. min y (Missing_List.min_list ys) \\<le> Missing_List.min_list ys", "by auto"], ["proof (state)\nthis:\n  min y (Missing_List.min_list ys) \\<le> Missing_List.min_list ys\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> Missing_List.min_list (y # ys) \\<le> x", "also"], ["proof (state)\nthis:\n  min y (Missing_List.min_list ys) \\<le> Missing_List.min_list ys\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> Missing_List.min_list (y # ys) \\<le> x", "have \"... \\<le> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Missing_List.min_list ys \\<le> x", "using oCons False"], ["proof (prove)\nusing this:\n  x \\<in> set ys \\<Longrightarrow> Missing_List.min_list ys \\<le> x\n  x \\<in> set (y # ys)\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. Missing_List.min_list ys \\<le> x", "by auto"], ["proof (state)\nthis:\n  Missing_List.min_list ys \\<le> x\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> Missing_List.min_list (y # ys) \\<le> x", "finally"], ["proof (chain)\npicking this:\n  min y (Missing_List.min_list ys) \\<le> x", "show ?thesis"], ["proof (prove)\nusing this:\n  min y (Missing_List.min_list ys) \\<le> x\n\ngoal (1 subgoal):\n 1. Missing_List.min_list (y # ys) \\<le> x", "unfolding id"], ["proof (prove)\nusing this:\n  min y (Missing_List.min_list ys) \\<le> x\n\ngoal (1 subgoal):\n 1. min y (Missing_List.min_list ys) \\<le> x", "."], ["proof (state)\nthis:\n  Missing_List.min_list (y # ys) \\<le> x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Missing_List.min_list (y # ys) \\<le> x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Missing_List.min_list (y # ys) \\<le> x\n\ngoal (1 subgoal):\n 1. x \\<in> set [] \\<Longrightarrow> Missing_List.min_list [] \\<le> x", "qed simp"], ["", "lemma min_list_Cons:\n  assumes xy: \"x \\<le> y\"\n    and len: \"length xs = length ys\"\n    and xsys: \"min_list xs \\<le> min_list ys\"\n  shows \"min_list (x # xs) \\<le> min_list (y # ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Missing_List.min_list (x # xs) \\<le> Missing_List.min_list (y # ys)", "proof (cases xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    Missing_List.min_list (x # xs) \\<le> Missing_List.min_list (y # ys)\n 2. \\<And>a list.\n       xs = a # list \\<Longrightarrow>\n       Missing_List.min_list (x # xs) \\<le> Missing_List.min_list (y # ys)", "case Nil"], ["proof (state)\nthis:\n  xs = []\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    Missing_List.min_list (x # xs) \\<le> Missing_List.min_list (y # ys)\n 2. \\<And>a list.\n       xs = a # list \\<Longrightarrow>\n       Missing_List.min_list (x # xs) \\<le> Missing_List.min_list (y # ys)", "with len"], ["proof (chain)\npicking this:\n  length xs = length ys\n  xs = []", "have ys: \"ys = []\""], ["proof (prove)\nusing this:\n  length xs = length ys\n  xs = []\n\ngoal (1 subgoal):\n 1. ys = []", "by simp"], ["proof (state)\nthis:\n  ys = []\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    Missing_List.min_list (x # xs) \\<le> Missing_List.min_list (y # ys)\n 2. \\<And>a list.\n       xs = a # list \\<Longrightarrow>\n       Missing_List.min_list (x # xs) \\<le> Missing_List.min_list (y # ys)", "with xy Nil"], ["proof (chain)\npicking this:\n  x \\<le> y\n  xs = []\n  ys = []", "show ?thesis"], ["proof (prove)\nusing this:\n  x \\<le> y\n  xs = []\n  ys = []\n\ngoal (1 subgoal):\n 1. Missing_List.min_list (x # xs) \\<le> Missing_List.min_list (y # ys)", "by simp"], ["proof (state)\nthis:\n  Missing_List.min_list (x # xs) \\<le> Missing_List.min_list (y # ys)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       xs = a # list \\<Longrightarrow>\n       Missing_List.min_list (x # xs) \\<le> Missing_List.min_list (y # ys)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       xs = a # list \\<Longrightarrow>\n       Missing_List.min_list (x # xs) \\<le> Missing_List.min_list (y # ys)", "case (Cons x' xs')"], ["proof (state)\nthis:\n  xs = x' # xs'\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       xs = a # list \\<Longrightarrow>\n       Missing_List.min_list (x # xs) \\<le> Missing_List.min_list (y # ys)", "with len"], ["proof (chain)\npicking this:\n  length xs = length ys\n  xs = x' # xs'", "obtain y' ys' where ys: \"ys = y' # ys'\""], ["proof (prove)\nusing this:\n  length xs = length ys\n  xs = x' # xs'\n\ngoal (1 subgoal):\n 1. (\\<And>y' ys'. ys = y' # ys' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases ys, auto)"], ["proof (state)\nthis:\n  ys = y' # ys'\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       xs = a # list \\<Longrightarrow>\n       Missing_List.min_list (x # xs) \\<le> Missing_List.min_list (y # ys)", "from Cons"], ["proof (chain)\npicking this:\n  xs = x' # xs'", "have one: \"min_list (x # xs) = min x (min_list xs)\""], ["proof (prove)\nusing this:\n  xs = x' # xs'\n\ngoal (1 subgoal):\n 1. Missing_List.min_list (x # xs) = min x (Missing_List.min_list xs)", "by auto"], ["proof (state)\nthis:\n  Missing_List.min_list (x # xs) = min x (Missing_List.min_list xs)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       xs = a # list \\<Longrightarrow>\n       Missing_List.min_list (x # xs) \\<le> Missing_List.min_list (y # ys)", "from ys"], ["proof (chain)\npicking this:\n  ys = y' # ys'", "have two: \"min_list (y # ys) = min y (min_list ys)\""], ["proof (prove)\nusing this:\n  ys = y' # ys'\n\ngoal (1 subgoal):\n 1. Missing_List.min_list (y # ys) = min y (Missing_List.min_list ys)", "by auto"], ["proof (state)\nthis:\n  Missing_List.min_list (y # ys) = min y (Missing_List.min_list ys)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       xs = a # list \\<Longrightarrow>\n       Missing_List.min_list (x # xs) \\<le> Missing_List.min_list (y # ys)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. Missing_List.min_list (x # xs) \\<le> Missing_List.min_list (y # ys)", "unfolding one two"], ["proof (prove)\ngoal (1 subgoal):\n 1. min x (Missing_List.min_list xs) \\<le> min y (Missing_List.min_list ys)", "using xy xsys"], ["proof (prove)\nusing this:\n  x \\<le> y\n  Missing_List.min_list xs \\<le> Missing_List.min_list ys\n\ngoal (1 subgoal):\n 1. min x (Missing_List.min_list xs) \\<le> min y (Missing_List.min_list ys)", "unfolding  min_def"], ["proof (prove)\nusing this:\n  x \\<le> y\n  Missing_List.min_list xs \\<le> Missing_List.min_list ys\n\ngoal (1 subgoal):\n 1. (if x \\<le> Missing_List.min_list xs then x\n     else Missing_List.min_list xs)\n    \\<le> (if y \\<le> Missing_List.min_list ys then y\n           else Missing_List.min_list ys)", "by auto"], ["proof (state)\nthis:\n  Missing_List.min_list (x # xs) \\<le> Missing_List.min_list (y # ys)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma min_list_nth:\n  assumes \"length xs = length ys\"\n    and \"\\<And>i. i < length ys \\<Longrightarrow> xs ! i \\<le> ys ! i\"\n  shows \"min_list xs \\<le> min_list ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Missing_List.min_list xs \\<le> Missing_List.min_list ys", "using assms"], ["proof (prove)\nusing this:\n  length xs = length ys\n  ?i < length ys \\<Longrightarrow> xs ! ?i \\<le> ys ! ?i\n\ngoal (1 subgoal):\n 1. Missing_List.min_list xs \\<le> Missing_List.min_list ys", "proof (induct xs arbitrary: ys)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ys.\n       \\<lbrakk>length [] = length ys;\n        \\<And>i.\n           i < length ys \\<Longrightarrow> [] ! i \\<le> ys ! i\\<rbrakk>\n       \\<Longrightarrow> Missing_List.min_list []\n                         \\<le> Missing_List.min_list ys\n 2. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   \\<lbrakk>length xs = length ys;\n                    \\<And>i.\n                       i < length ys \\<Longrightarrow>\n                       xs ! i \\<le> ys ! i\\<rbrakk>\n                   \\<Longrightarrow> Missing_List.min_list xs\n                                     \\<le> Missing_List.min_list ys;\n        length (a # xs) = length ys;\n        \\<And>i.\n           i < length ys \\<Longrightarrow>\n           (a # xs) ! i \\<le> ys ! i\\<rbrakk>\n       \\<Longrightarrow> Missing_List.min_list (a # xs)\n                         \\<le> Missing_List.min_list ys", "case (Cons x xs zs)"], ["proof (state)\nthis:\n  \\<lbrakk>length xs = length ?ys;\n   \\<And>i. i < length ?ys \\<Longrightarrow> xs ! i \\<le> ?ys ! i\\<rbrakk>\n  \\<Longrightarrow> Missing_List.min_list xs \\<le> Missing_List.min_list ?ys\n  length (x # xs) = length zs\n  ?i < length zs \\<Longrightarrow> (x # xs) ! ?i \\<le> zs ! ?i\n\ngoal (2 subgoals):\n 1. \\<And>ys.\n       \\<lbrakk>length [] = length ys;\n        \\<And>i.\n           i < length ys \\<Longrightarrow> [] ! i \\<le> ys ! i\\<rbrakk>\n       \\<Longrightarrow> Missing_List.min_list []\n                         \\<le> Missing_List.min_list ys\n 2. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   \\<lbrakk>length xs = length ys;\n                    \\<And>i.\n                       i < length ys \\<Longrightarrow>\n                       xs ! i \\<le> ys ! i\\<rbrakk>\n                   \\<Longrightarrow> Missing_List.min_list xs\n                                     \\<le> Missing_List.min_list ys;\n        length (a # xs) = length ys;\n        \\<And>i.\n           i < length ys \\<Longrightarrow>\n           (a # xs) ! i \\<le> ys ! i\\<rbrakk>\n       \\<Longrightarrow> Missing_List.min_list (a # xs)\n                         \\<le> Missing_List.min_list ys", "from Cons(2)"], ["proof (chain)\npicking this:\n  length (x # xs) = length zs", "obtain y ys where zs: \"zs = y # ys\""], ["proof (prove)\nusing this:\n  length (x # xs) = length zs\n\ngoal (1 subgoal):\n 1. (\\<And>y ys. zs = y # ys \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases zs, auto)"], ["proof (state)\nthis:\n  zs = y # ys\n\ngoal (2 subgoals):\n 1. \\<And>ys.\n       \\<lbrakk>length [] = length ys;\n        \\<And>i.\n           i < length ys \\<Longrightarrow> [] ! i \\<le> ys ! i\\<rbrakk>\n       \\<Longrightarrow> Missing_List.min_list []\n                         \\<le> Missing_List.min_list ys\n 2. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   \\<lbrakk>length xs = length ys;\n                    \\<And>i.\n                       i < length ys \\<Longrightarrow>\n                       xs ! i \\<le> ys ! i\\<rbrakk>\n                   \\<Longrightarrow> Missing_List.min_list xs\n                                     \\<le> Missing_List.min_list ys;\n        length (a # xs) = length ys;\n        \\<And>i.\n           i < length ys \\<Longrightarrow>\n           (a # xs) ! i \\<le> ys ! i\\<rbrakk>\n       \\<Longrightarrow> Missing_List.min_list (a # xs)\n                         \\<le> Missing_List.min_list ys", "note Cons = Cons[unfolded zs]"], ["proof (state)\nthis:\n  \\<lbrakk>length xs = length ?ys;\n   \\<And>i. i < length ?ys \\<Longrightarrow> xs ! i \\<le> ?ys ! i\\<rbrakk>\n  \\<Longrightarrow> Missing_List.min_list xs \\<le> Missing_List.min_list ?ys\n  length (x # xs) = length (y # ys)\n  ?i < length (y # ys) \\<Longrightarrow> (x # xs) ! ?i \\<le> (y # ys) ! ?i\n\ngoal (2 subgoals):\n 1. \\<And>ys.\n       \\<lbrakk>length [] = length ys;\n        \\<And>i.\n           i < length ys \\<Longrightarrow> [] ! i \\<le> ys ! i\\<rbrakk>\n       \\<Longrightarrow> Missing_List.min_list []\n                         \\<le> Missing_List.min_list ys\n 2. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   \\<lbrakk>length xs = length ys;\n                    \\<And>i.\n                       i < length ys \\<Longrightarrow>\n                       xs ! i \\<le> ys ! i\\<rbrakk>\n                   \\<Longrightarrow> Missing_List.min_list xs\n                                     \\<le> Missing_List.min_list ys;\n        length (a # xs) = length ys;\n        \\<And>i.\n           i < length ys \\<Longrightarrow>\n           (a # xs) ! i \\<le> ys ! i\\<rbrakk>\n       \\<Longrightarrow> Missing_List.min_list (a # xs)\n                         \\<le> Missing_List.min_list ys", "from Cons(2)"], ["proof (chain)\npicking this:\n  length (x # xs) = length (y # ys)", "have len: \"length xs = length ys\""], ["proof (prove)\nusing this:\n  length (x # xs) = length (y # ys)\n\ngoal (1 subgoal):\n 1. length xs = length ys", "by simp"], ["proof (state)\nthis:\n  length xs = length ys\n\ngoal (2 subgoals):\n 1. \\<And>ys.\n       \\<lbrakk>length [] = length ys;\n        \\<And>i.\n           i < length ys \\<Longrightarrow> [] ! i \\<le> ys ! i\\<rbrakk>\n       \\<Longrightarrow> Missing_List.min_list []\n                         \\<le> Missing_List.min_list ys\n 2. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   \\<lbrakk>length xs = length ys;\n                    \\<And>i.\n                       i < length ys \\<Longrightarrow>\n                       xs ! i \\<le> ys ! i\\<rbrakk>\n                   \\<Longrightarrow> Missing_List.min_list xs\n                                     \\<le> Missing_List.min_list ys;\n        length (a # xs) = length ys;\n        \\<And>i.\n           i < length ys \\<Longrightarrow>\n           (a # xs) ! i \\<le> ys ! i\\<rbrakk>\n       \\<Longrightarrow> Missing_List.min_list (a # xs)\n                         \\<le> Missing_List.min_list ys", "from Cons(3)[of 0]"], ["proof (chain)\npicking this:\n  0 < length (y # ys) \\<Longrightarrow> (x # xs) ! 0 \\<le> (y # ys) ! 0", "have xy: \"x \\<le> y\""], ["proof (prove)\nusing this:\n  0 < length (y # ys) \\<Longrightarrow> (x # xs) ! 0 \\<le> (y # ys) ! 0\n\ngoal (1 subgoal):\n 1. x \\<le> y", "by simp"], ["proof (state)\nthis:\n  x \\<le> y\n\ngoal (2 subgoals):\n 1. \\<And>ys.\n       \\<lbrakk>length [] = length ys;\n        \\<And>i.\n           i < length ys \\<Longrightarrow> [] ! i \\<le> ys ! i\\<rbrakk>\n       \\<Longrightarrow> Missing_List.min_list []\n                         \\<le> Missing_List.min_list ys\n 2. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   \\<lbrakk>length xs = length ys;\n                    \\<And>i.\n                       i < length ys \\<Longrightarrow>\n                       xs ! i \\<le> ys ! i\\<rbrakk>\n                   \\<Longrightarrow> Missing_List.min_list xs\n                                     \\<le> Missing_List.min_list ys;\n        length (a # xs) = length ys;\n        \\<And>i.\n           i < length ys \\<Longrightarrow>\n           (a # xs) ! i \\<le> ys ! i\\<rbrakk>\n       \\<Longrightarrow> Missing_List.min_list (a # xs)\n                         \\<le> Missing_List.min_list ys", "{"], ["proof (state)\nthis:\n  x \\<le> y\n\ngoal (2 subgoals):\n 1. \\<And>ys.\n       \\<lbrakk>length [] = length ys;\n        \\<And>i.\n           i < length ys \\<Longrightarrow> [] ! i \\<le> ys ! i\\<rbrakk>\n       \\<Longrightarrow> Missing_List.min_list []\n                         \\<le> Missing_List.min_list ys\n 2. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   \\<lbrakk>length xs = length ys;\n                    \\<And>i.\n                       i < length ys \\<Longrightarrow>\n                       xs ! i \\<le> ys ! i\\<rbrakk>\n                   \\<Longrightarrow> Missing_List.min_list xs\n                                     \\<le> Missing_List.min_list ys;\n        length (a # xs) = length ys;\n        \\<And>i.\n           i < length ys \\<Longrightarrow>\n           (a # xs) ! i \\<le> ys ! i\\<rbrakk>\n       \\<Longrightarrow> Missing_List.min_list (a # xs)\n                         \\<le> Missing_List.min_list ys", "fix i"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ys.\n       \\<lbrakk>length [] = length ys;\n        \\<And>i.\n           i < length ys \\<Longrightarrow> [] ! i \\<le> ys ! i\\<rbrakk>\n       \\<Longrightarrow> Missing_List.min_list []\n                         \\<le> Missing_List.min_list ys\n 2. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   \\<lbrakk>length xs = length ys;\n                    \\<And>i.\n                       i < length ys \\<Longrightarrow>\n                       xs ! i \\<le> ys ! i\\<rbrakk>\n                   \\<Longrightarrow> Missing_List.min_list xs\n                                     \\<le> Missing_List.min_list ys;\n        length (a # xs) = length ys;\n        \\<And>i.\n           i < length ys \\<Longrightarrow>\n           (a # xs) ! i \\<le> ys ! i\\<rbrakk>\n       \\<Longrightarrow> Missing_List.min_list (a # xs)\n                         \\<le> Missing_List.min_list ys", "assume \"i < length xs\""], ["proof (state)\nthis:\n  i < length xs\n\ngoal (2 subgoals):\n 1. \\<And>ys.\n       \\<lbrakk>length [] = length ys;\n        \\<And>i.\n           i < length ys \\<Longrightarrow> [] ! i \\<le> ys ! i\\<rbrakk>\n       \\<Longrightarrow> Missing_List.min_list []\n                         \\<le> Missing_List.min_list ys\n 2. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   \\<lbrakk>length xs = length ys;\n                    \\<And>i.\n                       i < length ys \\<Longrightarrow>\n                       xs ! i \\<le> ys ! i\\<rbrakk>\n                   \\<Longrightarrow> Missing_List.min_list xs\n                                     \\<le> Missing_List.min_list ys;\n        length (a # xs) = length ys;\n        \\<And>i.\n           i < length ys \\<Longrightarrow>\n           (a # xs) ! i \\<le> ys ! i\\<rbrakk>\n       \\<Longrightarrow> Missing_List.min_list (a # xs)\n                         \\<le> Missing_List.min_list ys", "with Cons(3)[of \"Suc i\"] Cons(2)"], ["proof (chain)\npicking this:\n  Suc i < length (y # ys) \\<Longrightarrow>\n  (x # xs) ! Suc i \\<le> (y # ys) ! Suc i\n  length (x # xs) = length (y # ys)\n  i < length xs", "have \"xs ! i \\<le> ys ! i\""], ["proof (prove)\nusing this:\n  Suc i < length (y # ys) \\<Longrightarrow>\n  (x # xs) ! Suc i \\<le> (y # ys) ! Suc i\n  length (x # xs) = length (y # ys)\n  i < length xs\n\ngoal (1 subgoal):\n 1. xs ! i \\<le> ys ! i", "by simp"], ["proof (state)\nthis:\n  xs ! i \\<le> ys ! i\n\ngoal (2 subgoals):\n 1. \\<And>ys.\n       \\<lbrakk>length [] = length ys;\n        \\<And>i.\n           i < length ys \\<Longrightarrow> [] ! i \\<le> ys ! i\\<rbrakk>\n       \\<Longrightarrow> Missing_List.min_list []\n                         \\<le> Missing_List.min_list ys\n 2. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   \\<lbrakk>length xs = length ys;\n                    \\<And>i.\n                       i < length ys \\<Longrightarrow>\n                       xs ! i \\<le> ys ! i\\<rbrakk>\n                   \\<Longrightarrow> Missing_List.min_list xs\n                                     \\<le> Missing_List.min_list ys;\n        length (a # xs) = length ys;\n        \\<And>i.\n           i < length ys \\<Longrightarrow>\n           (a # xs) ! i \\<le> ys ! i\\<rbrakk>\n       \\<Longrightarrow> Missing_List.min_list (a # xs)\n                         \\<le> Missing_List.min_list ys", "}"], ["proof (state)\nthis:\n  ?i2 < length xs \\<Longrightarrow> xs ! ?i2 \\<le> ys ! ?i2\n\ngoal (2 subgoals):\n 1. \\<And>ys.\n       \\<lbrakk>length [] = length ys;\n        \\<And>i.\n           i < length ys \\<Longrightarrow> [] ! i \\<le> ys ! i\\<rbrakk>\n       \\<Longrightarrow> Missing_List.min_list []\n                         \\<le> Missing_List.min_list ys\n 2. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   \\<lbrakk>length xs = length ys;\n                    \\<And>i.\n                       i < length ys \\<Longrightarrow>\n                       xs ! i \\<le> ys ! i\\<rbrakk>\n                   \\<Longrightarrow> Missing_List.min_list xs\n                                     \\<le> Missing_List.min_list ys;\n        length (a # xs) = length ys;\n        \\<And>i.\n           i < length ys \\<Longrightarrow>\n           (a # xs) ! i \\<le> ys ! i\\<rbrakk>\n       \\<Longrightarrow> Missing_List.min_list (a # xs)\n                         \\<le> Missing_List.min_list ys", "from Cons(1)[OF len this] Cons(2)"], ["proof (chain)\npicking this:\n  (\\<And>i. i < length ys \\<Longrightarrow> i < length xs) \\<Longrightarrow>\n  Missing_List.min_list xs \\<le> Missing_List.min_list ys\n  length (x # xs) = length (y # ys)", "have ind: \"min_list xs \\<le> min_list ys\""], ["proof (prove)\nusing this:\n  (\\<And>i. i < length ys \\<Longrightarrow> i < length xs) \\<Longrightarrow>\n  Missing_List.min_list xs \\<le> Missing_List.min_list ys\n  length (x # xs) = length (y # ys)\n\ngoal (1 subgoal):\n 1. Missing_List.min_list xs \\<le> Missing_List.min_list ys", "by simp"], ["proof (state)\nthis:\n  Missing_List.min_list xs \\<le> Missing_List.min_list ys\n\ngoal (2 subgoals):\n 1. \\<And>ys.\n       \\<lbrakk>length [] = length ys;\n        \\<And>i.\n           i < length ys \\<Longrightarrow> [] ! i \\<le> ys ! i\\<rbrakk>\n       \\<Longrightarrow> Missing_List.min_list []\n                         \\<le> Missing_List.min_list ys\n 2. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   \\<lbrakk>length xs = length ys;\n                    \\<And>i.\n                       i < length ys \\<Longrightarrow>\n                       xs ! i \\<le> ys ! i\\<rbrakk>\n                   \\<Longrightarrow> Missing_List.min_list xs\n                                     \\<le> Missing_List.min_list ys;\n        length (a # xs) = length ys;\n        \\<And>i.\n           i < length ys \\<Longrightarrow>\n           (a # xs) ! i \\<le> ys ! i\\<rbrakk>\n       \\<Longrightarrow> Missing_List.min_list (a # xs)\n                         \\<le> Missing_List.min_list ys", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. Missing_List.min_list (x # xs) \\<le> Missing_List.min_list zs", "unfolding zs"], ["proof (prove)\ngoal (1 subgoal):\n 1. Missing_List.min_list (x # xs) \\<le> Missing_List.min_list (y # ys)", "by (rule min_list_Cons[OF xy len ind])"], ["proof (state)\nthis:\n  Missing_List.min_list (x # xs) \\<le> Missing_List.min_list zs\n\ngoal (1 subgoal):\n 1. \\<And>ys.\n       \\<lbrakk>length [] = length ys;\n        \\<And>i.\n           i < length ys \\<Longrightarrow> [] ! i \\<le> ys ! i\\<rbrakk>\n       \\<Longrightarrow> Missing_List.min_list []\n                         \\<le> Missing_List.min_list ys", "qed auto"], ["", "lemma min_list_ex:\n  assumes \"xs \\<noteq> []\" shows \"\\<exists>x\\<in>set xs. min_list xs = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>set xs. Missing_List.min_list xs = x", "using assms"], ["proof (prove)\nusing this:\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>set xs. Missing_List.min_list xs = x", "proof (induct xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. [] \\<noteq> [] \\<Longrightarrow>\n    Bex (set []) ((=) (Missing_List.min_list []))\n 2. \\<And>a xs.\n       \\<lbrakk>xs \\<noteq> [] \\<Longrightarrow>\n                Bex (set xs) ((=) (Missing_List.min_list xs));\n        a # xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> Bex (set (a # xs))\n                          ((=) (Missing_List.min_list (a # xs)))", "case oCons : (Cons x xs)"], ["proof (state)\nthis:\n  xs \\<noteq> [] \\<Longrightarrow>\n  \\<exists>a\\<in>set xs. Missing_List.min_list xs = a\n  x # xs \\<noteq> []\n\ngoal (2 subgoals):\n 1. [] \\<noteq> [] \\<Longrightarrow>\n    Bex (set []) ((=) (Missing_List.min_list []))\n 2. \\<And>a xs.\n       \\<lbrakk>xs \\<noteq> [] \\<Longrightarrow>\n                Bex (set xs) ((=) (Missing_List.min_list xs));\n        a # xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> Bex (set (a # xs))\n                          ((=) (Missing_List.min_list (a # xs)))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>a\\<in>set (x # xs). Missing_List.min_list (x # xs) = a", "proof (cases xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    \\<exists>a\\<in>set (x # xs). Missing_List.min_list (x # xs) = a\n 2. \\<And>a list.\n       xs = a # list \\<Longrightarrow>\n       \\<exists>a\\<in>set (x # xs). Missing_List.min_list (x # xs) = a", "case (Cons y ys)"], ["proof (state)\nthis:\n  xs = y # ys\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    \\<exists>a\\<in>set (x # xs). Missing_List.min_list (x # xs) = a\n 2. \\<And>a list.\n       xs = a # list \\<Longrightarrow>\n       \\<exists>a\\<in>set (x # xs). Missing_List.min_list (x # xs) = a", "hence id: \"min_list (x # xs) = min x (min_list xs)\" and nNil: \"xs \\<noteq> []\""], ["proof (prove)\nusing this:\n  xs = y # ys\n\ngoal (1 subgoal):\n 1. Missing_List.min_list (x # xs) = min x (Missing_List.min_list xs) &&&\n    xs \\<noteq> []", "by auto"], ["proof (state)\nthis:\n  Missing_List.min_list (x # xs) = min x (Missing_List.min_list xs)\n  xs \\<noteq> []\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    \\<exists>a\\<in>set (x # xs). Missing_List.min_list (x # xs) = a\n 2. \\<And>a list.\n       xs = a # list \\<Longrightarrow>\n       \\<exists>a\\<in>set (x # xs). Missing_List.min_list (x # xs) = a", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>a\\<in>set (x # xs). Missing_List.min_list (x # xs) = a", "proof (cases \"x \\<le> min_list xs\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<le> Missing_List.min_list xs \\<Longrightarrow>\n    \\<exists>a\\<in>set (x # xs). Missing_List.min_list (x # xs) = a\n 2. \\<not> x \\<le> Missing_List.min_list xs \\<Longrightarrow>\n    \\<exists>a\\<in>set (x # xs). Missing_List.min_list (x # xs) = a", "case True"], ["proof (state)\nthis:\n  x \\<le> Missing_List.min_list xs\n\ngoal (2 subgoals):\n 1. x \\<le> Missing_List.min_list xs \\<Longrightarrow>\n    \\<exists>a\\<in>set (x # xs). Missing_List.min_list (x # xs) = a\n 2. \\<not> x \\<le> Missing_List.min_list xs \\<Longrightarrow>\n    \\<exists>a\\<in>set (x # xs). Missing_List.min_list (x # xs) = a", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>a\\<in>set (x # xs). Missing_List.min_list (x # xs) = a", "unfolding id"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>a\\<in>set (x # xs). min x (Missing_List.min_list xs) = a", "by (rule bexI[of _ x], insert True, auto simp: min_def)"], ["proof (state)\nthis:\n  \\<exists>a\\<in>set (x # xs). Missing_List.min_list (x # xs) = a\n\ngoal (1 subgoal):\n 1. \\<not> x \\<le> Missing_List.min_list xs \\<Longrightarrow>\n    \\<exists>a\\<in>set (x # xs). Missing_List.min_list (x # xs) = a", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> x \\<le> Missing_List.min_list xs \\<Longrightarrow>\n    \\<exists>a\\<in>set (x # xs). Missing_List.min_list (x # xs) = a", "case False"], ["proof (state)\nthis:\n  \\<not> x \\<le> Missing_List.min_list xs\n\ngoal (1 subgoal):\n 1. \\<not> x \\<le> Missing_List.min_list xs \\<Longrightarrow>\n    \\<exists>a\\<in>set (x # xs). Missing_List.min_list (x # xs) = a", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>a\\<in>set (x # xs). Missing_List.min_list (x # xs) = a", "unfolding id min_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>a\\<in>set (x # xs).\n       (if x \\<le> Missing_List.min_list xs then x\n        else Missing_List.min_list xs) =\n       a", "using oCons(1)[OF nNil] False"], ["proof (prove)\nusing this:\n  \\<exists>a\\<in>set xs. Missing_List.min_list xs = a\n  \\<not> x \\<le> Missing_List.min_list xs\n\ngoal (1 subgoal):\n 1. \\<exists>a\\<in>set (x # xs).\n       (if x \\<le> Missing_List.min_list xs then x\n        else Missing_List.min_list xs) =\n       a", "by auto"], ["proof (state)\nthis:\n  \\<exists>a\\<in>set (x # xs). Missing_List.min_list (x # xs) = a\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>a\\<in>set (x # xs). Missing_List.min_list (x # xs) = a\n\ngoal (1 subgoal):\n 1. xs = [] \\<Longrightarrow>\n    \\<exists>a\\<in>set (x # xs). Missing_List.min_list (x # xs) = a", "qed auto"], ["proof (state)\nthis:\n  \\<exists>a\\<in>set (x # xs). Missing_List.min_list (x # xs) = a\n\ngoal (1 subgoal):\n 1. [] \\<noteq> [] \\<Longrightarrow>\n    Bex (set []) ((=) (Missing_List.min_list []))", "qed auto"], ["", "lemma min_list_subset:\n  assumes subset: \"set ys \\<subseteq> set xs\" and mem: \"min_list xs \\<in> set ys\"\n  shows \"min_list xs = min_list ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Missing_List.min_list xs = Missing_List.min_list ys", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Missing_List.min_list xs = Missing_List.min_list ys", "from subset mem"], ["proof (chain)\npicking this:\n  set ys \\<subseteq> set xs\n  Missing_List.min_list xs \\<in> set ys", "have \"xs \\<noteq> []\""], ["proof (prove)\nusing this:\n  set ys \\<subseteq> set xs\n  Missing_List.min_list xs \\<in> set ys\n\ngoal (1 subgoal):\n 1. xs \\<noteq> []", "by auto"], ["proof (state)\nthis:\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. Missing_List.min_list xs = Missing_List.min_list ys", "from min_list_ex[OF this]"], ["proof (chain)\npicking this:\n  \\<exists>x\\<in>set xs. Missing_List.min_list xs = x", "obtain x where x: \"x \\<in> set xs\" and mx: \"min_list xs = x\""], ["proof (prove)\nusing this:\n  \\<exists>x\\<in>set xs. Missing_List.min_list xs = x\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>x \\<in> set xs; Missing_List.min_list xs = x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  x \\<in> set xs\n  Missing_List.min_list xs = x\n\ngoal (1 subgoal):\n 1. Missing_List.min_list xs = Missing_List.min_list ys", "from min_list[OF mem]"], ["proof (chain)\npicking this:\n  Missing_List.min_list ys \\<le> Missing_List.min_list xs", "have two: \"min_list ys \\<le> min_list xs\""], ["proof (prove)\nusing this:\n  Missing_List.min_list ys \\<le> Missing_List.min_list xs\n\ngoal (1 subgoal):\n 1. Missing_List.min_list ys \\<le> Missing_List.min_list xs", "by auto"], ["proof (state)\nthis:\n  Missing_List.min_list ys \\<le> Missing_List.min_list xs\n\ngoal (1 subgoal):\n 1. Missing_List.min_list xs = Missing_List.min_list ys", "from mem"], ["proof (chain)\npicking this:\n  Missing_List.min_list xs \\<in> set ys", "have \"ys \\<noteq> []\""], ["proof (prove)\nusing this:\n  Missing_List.min_list xs \\<in> set ys\n\ngoal (1 subgoal):\n 1. ys \\<noteq> []", "by auto"], ["proof (state)\nthis:\n  ys \\<noteq> []\n\ngoal (1 subgoal):\n 1. Missing_List.min_list xs = Missing_List.min_list ys", "from min_list_ex[OF this]"], ["proof (chain)\npicking this:\n  \\<exists>x\\<in>set ys. Missing_List.min_list ys = x", "obtain y where y: \"y \\<in> set ys\" and my: \"min_list ys = y\""], ["proof (prove)\nusing this:\n  \\<exists>x\\<in>set ys. Missing_List.min_list ys = x\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<in> set ys; Missing_List.min_list ys = y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  y \\<in> set ys\n  Missing_List.min_list ys = y\n\ngoal (1 subgoal):\n 1. Missing_List.min_list xs = Missing_List.min_list ys", "from y subset"], ["proof (chain)\npicking this:\n  y \\<in> set ys\n  set ys \\<subseteq> set xs", "have \"y \\<in> set xs\""], ["proof (prove)\nusing this:\n  y \\<in> set ys\n  set ys \\<subseteq> set xs\n\ngoal (1 subgoal):\n 1. y \\<in> set xs", "by auto"], ["proof (state)\nthis:\n  y \\<in> set xs\n\ngoal (1 subgoal):\n 1. Missing_List.min_list xs = Missing_List.min_list ys", "from min_list[OF this]"], ["proof (chain)\npicking this:\n  Missing_List.min_list xs \\<le> y", "have one: \"min_list xs \\<le> y\""], ["proof (prove)\nusing this:\n  Missing_List.min_list xs \\<le> y\n\ngoal (1 subgoal):\n 1. Missing_List.min_list xs \\<le> y", "by auto"], ["proof (state)\nthis:\n  Missing_List.min_list xs \\<le> y\n\ngoal (1 subgoal):\n 1. Missing_List.min_list xs = Missing_List.min_list ys", "from one two"], ["proof (chain)\npicking this:\n  Missing_List.min_list xs \\<le> y\n  Missing_List.min_list ys \\<le> Missing_List.min_list xs", "show ?thesis"], ["proof (prove)\nusing this:\n  Missing_List.min_list xs \\<le> y\n  Missing_List.min_list ys \\<le> Missing_List.min_list xs\n\ngoal (1 subgoal):\n 1. Missing_List.min_list xs = Missing_List.min_list ys", "unfolding mx my"], ["proof (prove)\nusing this:\n  x \\<le> y\n  y \\<le> x\n\ngoal (1 subgoal):\n 1. x = y", "by auto"], ["proof (state)\nthis:\n  Missing_List.min_list xs = Missing_List.min_list ys\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>Apply a permutation to a list.\\<close>"], ["", "primrec permut_aux :: \"'a list \\<Rightarrow> (nat \\<Rightarrow> nat) \\<Rightarrow> 'a list \\<Rightarrow> 'a list\" where\n  \"permut_aux [] _ _ = []\" |\n  \"permut_aux (a # as) f bs = (bs ! f 0) # (permut_aux as (\\<lambda>n. f (Suc n)) bs)\""], ["", "definition permut :: \"'a list \\<Rightarrow> (nat \\<Rightarrow> nat) \\<Rightarrow> 'a list\" where\n  \"permut as f = permut_aux as f as\""], ["", "declare permut_def[simp]"], ["", "lemma permut_aux_sound:\n  assumes \"i < length as\"\n  shows \"permut_aux as f bs ! i = bs ! (f i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. permut_aux as f bs ! i = bs ! f i", "using assms"], ["proof (prove)\nusing this:\n  i < length as\n\ngoal (1 subgoal):\n 1. permut_aux as f bs ! i = bs ! f i", "proof (induct as arbitrary: i f bs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i f bs.\n       i < length [] \\<Longrightarrow> permut_aux [] f bs ! i = bs ! f i\n 2. \\<And>a as i f bs.\n       \\<lbrakk>\\<And>i f bs.\n                   i < length as \\<Longrightarrow>\n                   permut_aux as f bs ! i = bs ! f i;\n        i < length (a # as)\\<rbrakk>\n       \\<Longrightarrow> permut_aux (a # as) f bs ! i = bs ! f i", "case (Cons x xs)"], ["proof (state)\nthis:\n  ?i < length xs \\<Longrightarrow> permut_aux xs ?f ?bs ! ?i = ?bs ! ?f ?i\n  i < length (x # xs)\n\ngoal (2 subgoals):\n 1. \\<And>i f bs.\n       i < length [] \\<Longrightarrow> permut_aux [] f bs ! i = bs ! f i\n 2. \\<And>a as i f bs.\n       \\<lbrakk>\\<And>i f bs.\n                   i < length as \\<Longrightarrow>\n                   permut_aux as f bs ! i = bs ! f i;\n        i < length (a # as)\\<rbrakk>\n       \\<Longrightarrow> permut_aux (a # as) f bs ! i = bs ! f i", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. permut_aux (x # xs) f bs ! i = bs ! f i", "proof (cases i)"], ["proof (state)\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow> permut_aux (x # xs) f bs ! i = bs ! f i\n 2. \\<And>nat.\n       i = Suc nat \\<Longrightarrow> permut_aux (x # xs) f bs ! i = bs ! f i", "case (Suc j)"], ["proof (state)\nthis:\n  i = Suc j\n\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow> permut_aux (x # xs) f bs ! i = bs ! f i\n 2. \\<And>nat.\n       i = Suc nat \\<Longrightarrow> permut_aux (x # xs) f bs ! i = bs ! f i", "with Cons(2)"], ["proof (chain)\npicking this:\n  i < length (x # xs)\n  i = Suc j", "have \"j < length xs\""], ["proof (prove)\nusing this:\n  i < length (x # xs)\n  i = Suc j\n\ngoal (1 subgoal):\n 1. j < length xs", "by simp"], ["proof (state)\nthis:\n  j < length xs\n\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow> permut_aux (x # xs) f bs ! i = bs ! f i\n 2. \\<And>nat.\n       i = Suc nat \\<Longrightarrow> permut_aux (x # xs) f bs ! i = bs ! f i", "from Cons(1)[OF this] and Suc"], ["proof (chain)\npicking this:\n  permut_aux xs ?f ?bs ! j = ?bs ! ?f j\n  i = Suc j", "show ?thesis"], ["proof (prove)\nusing this:\n  permut_aux xs ?f ?bs ! j = ?bs ! ?f j\n  i = Suc j\n\ngoal (1 subgoal):\n 1. permut_aux (x # xs) f bs ! i = bs ! f i", "by simp"], ["proof (state)\nthis:\n  permut_aux (x # xs) f bs ! i = bs ! f i\n\ngoal (1 subgoal):\n 1. i = 0 \\<Longrightarrow> permut_aux (x # xs) f bs ! i = bs ! f i", "qed simp"], ["proof (state)\nthis:\n  permut_aux (x # xs) f bs ! i = bs ! f i\n\ngoal (1 subgoal):\n 1. \\<And>i f bs.\n       i < length [] \\<Longrightarrow> permut_aux [] f bs ! i = bs ! f i", "qed simp"], ["", "lemma permut_sound:\n  assumes \"i < length as\"\n  shows \"permut as f ! i = as ! (f i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. permut as f ! i = as ! f i", "using assms and permut_aux_sound"], ["proof (prove)\nusing this:\n  i < length as\n  ?i < length ?as \\<Longrightarrow> permut_aux ?as ?f ?bs ! ?i = ?bs ! ?f ?i\n\ngoal (1 subgoal):\n 1. permut as f ! i = as ! f i", "by simp"], ["", "lemma permut_aux_length:\n  assumes \"bij_betw f {..<length as} {..<length bs}\"\n  shows \"length (permut_aux as f bs) = length as\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (permut_aux as f bs) = length as", "by (induct as arbitrary: f bs, simp_all)"], ["", "lemma permut_length:\n  assumes \"bij_betw f {..< length as} {..< length as}\"\n  shows \"length (permut as f) = length as\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (permut as f) = length as", "using permut_aux_length[OF assms]"], ["proof (prove)\nusing this:\n  length (permut_aux as f as) = length as\n\ngoal (1 subgoal):\n 1. length (permut as f) = length as", "by simp"], ["", "declare permut_def[simp del]"], ["", "lemma foldl_assoc:\n  fixes b :: \"('a \\<Rightarrow> 'a) \\<Rightarrow> ('a \\<Rightarrow> 'a) \\<Rightarrow> 'a \\<Rightarrow> 'a\" (infixl \"\\<cdot>\" 55)\n  assumes \"\\<And>f g h. f \\<cdot> (g \\<cdot> h) = f \\<cdot> g \\<cdot> h\"\n  shows \"foldl (\\<cdot>) (x \\<cdot> y) zs = x \\<cdot> foldl (\\<cdot>) y zs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl (\\<cdot>) (x \\<cdot> y) zs = x \\<cdot> foldl (\\<cdot>) y zs", "using assms[symmetric]"], ["proof (prove)\nusing this:\n  ?f \\<cdot> ?g \\<cdot> ?h = ?f \\<cdot> (?g \\<cdot> ?h)\n\ngoal (1 subgoal):\n 1. foldl (\\<cdot>) (x \\<cdot> y) zs = x \\<cdot> foldl (\\<cdot>) y zs", "by (induct zs arbitrary: y) simp_all"], ["", "lemma foldr_assoc:\n  assumes \"\\<And>f g h. b (b f g) h = b f (b g h)\"\n  shows \"foldr b xs (b y z) = b (foldr b xs y) z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldr b xs (b y z) = b (foldr b xs y) z", "using assms"], ["proof (prove)\nusing this:\n  b (b ?f ?g) ?h = b ?f (b ?g ?h)\n\ngoal (1 subgoal):\n 1. foldr b xs (b y z) = b (foldr b xs y) z", "by (induct xs) simp_all"], ["", "lemma foldl_foldr_o_id:\n  \"foldl (\\<circ>) id fs = foldr (\\<circ>) fs id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl (\\<circ>) id fs = foldr (\\<circ>) fs id", "proof (induct fs)"], ["proof (state)\ngoal (2 subgoals):\n 1. foldl (\\<circ>) id [] = foldr (\\<circ>) [] id\n 2. \\<And>a fs.\n       foldl (\\<circ>) id fs = foldr (\\<circ>) fs id \\<Longrightarrow>\n       foldl (\\<circ>) id (a # fs) = foldr (\\<circ>) (a # fs) id", "case (Cons f fs)"], ["proof (state)\nthis:\n  foldl (\\<circ>) id fs = foldr (\\<circ>) fs id\n\ngoal (2 subgoals):\n 1. foldl (\\<circ>) id [] = foldr (\\<circ>) [] id\n 2. \\<And>a fs.\n       foldl (\\<circ>) id fs = foldr (\\<circ>) fs id \\<Longrightarrow>\n       foldl (\\<circ>) id (a # fs) = foldr (\\<circ>) (a # fs) id", "have \"id \\<circ> f = f \\<circ> id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. id \\<circ> f = f \\<circ> id", "by simp"], ["proof (state)\nthis:\n  id \\<circ> f = f \\<circ> id\n\ngoal (2 subgoals):\n 1. foldl (\\<circ>) id [] = foldr (\\<circ>) [] id\n 2. \\<And>a fs.\n       foldl (\\<circ>) id fs = foldr (\\<circ>) fs id \\<Longrightarrow>\n       foldl (\\<circ>) id (a # fs) = foldr (\\<circ>) (a # fs) id", "with Cons [symmetric]"], ["proof (chain)\npicking this:\n  foldr (\\<circ>) fs id = foldl (\\<circ>) id fs\n  id \\<circ> f = f \\<circ> id", "show ?case"], ["proof (prove)\nusing this:\n  foldr (\\<circ>) fs id = foldl (\\<circ>) id fs\n  id \\<circ> f = f \\<circ> id\n\ngoal (1 subgoal):\n 1. foldl (\\<circ>) id (f # fs) = foldr (\\<circ>) (f # fs) id", "by (simp only: foldl_Cons foldr_Cons o_apply [of _ _ id] foldl_assoc o_assoc)"], ["proof (state)\nthis:\n  foldl (\\<circ>) id (f # fs) = foldr (\\<circ>) (f # fs) id\n\ngoal (1 subgoal):\n 1. foldl (\\<circ>) id [] = foldr (\\<circ>) [] id", "qed simp"], ["", "lemma foldr_o_o_id[simp]:\n  \"foldr ((\\<circ>) \\<circ> f) xs id a = foldr f xs a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldr ((\\<circ>) \\<circ> f) xs id a = foldr f xs a", "by (induct xs) simp_all"], ["", "lemma Ex_list_of_length_P:\n  assumes \"\\<forall>i<n. \\<exists>x. P x i\"\n  shows \"\\<exists>xs. length xs = n \\<and> (\\<forall>i<n. P (xs ! i) i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>xs. length xs = n \\<and> (\\<forall>i<n. P (xs ! i) i)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>xs. length xs = n \\<and> (\\<forall>i<n. P (xs ! i) i)", "from assms"], ["proof (chain)\npicking this:\n  \\<forall>i<n. \\<exists>x. P x i", "have \"\\<forall> i. \\<exists> x. i < n \\<longrightarrow> P x i\""], ["proof (prove)\nusing this:\n  \\<forall>i<n. \\<exists>x. P x i\n\ngoal (1 subgoal):\n 1. \\<forall>i. \\<exists>x. i < n \\<longrightarrow> P x i", "by simp"], ["proof (state)\nthis:\n  \\<forall>i. \\<exists>x. i < n \\<longrightarrow> P x i\n\ngoal (1 subgoal):\n 1. \\<exists>xs. length xs = n \\<and> (\\<forall>i<n. P (xs ! i) i)", "from choice[OF this]"], ["proof (chain)\npicking this:\n  \\<exists>f. \\<forall>x<n. P (f x) x", "obtain xs where xs: \"\\<And> i. i < n \\<Longrightarrow> P (xs i) i\""], ["proof (prove)\nusing this:\n  \\<exists>f. \\<forall>x<n. P (f x) x\n\ngoal (1 subgoal):\n 1. (\\<And>xs.\n        (\\<And>i. i < n \\<Longrightarrow> P (xs i) i) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  ?i < n \\<Longrightarrow> P (xs ?i) ?i\n\ngoal (1 subgoal):\n 1. \\<exists>xs. length xs = n \\<and> (\\<forall>i<n. P (xs ! i) i)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>xs. length xs = n \\<and> (\\<forall>i<n. P (xs ! i) i)", "by (rule exI[of _ \"map xs [0 ..< n]\"], insert xs, auto)"], ["proof (state)\nthis:\n  \\<exists>xs. length xs = n \\<and> (\\<forall>i<n. P (xs ! i) i)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ex_set_conv_ex_nth: \"(\\<exists>x\\<in>set xs. P x) = (\\<exists>i<length xs. P (xs ! i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>x\\<in>set xs. P x) = (\\<exists>i<length xs. P (xs ! i))", "using in_set_conv_nth[of _ xs]"], ["proof (prove)\nusing this:\n  (?x \\<in> set xs) = (\\<exists>i<length xs. xs ! i = ?x)\n\ngoal (1 subgoal):\n 1. (\\<exists>x\\<in>set xs. P x) = (\\<exists>i<length xs. P (xs ! i))", "by force"], ["", "lemma map_eq_set_zipD [dest]:\n  assumes \"map f xs = map f ys\"\n    and \"(x, y) \\<in> set (zip xs ys)\"\n  shows \"f x = f y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f x = f y", "using assms"], ["proof (prove)\nusing this:\n  map f xs = map f ys\n  (x, y) \\<in> set (zip xs ys)\n\ngoal (1 subgoal):\n 1. f x = f y", "proof (induct xs arbitrary: ys)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ys.\n       \\<lbrakk>map f [] = map f ys; (x, y) \\<in> set (zip [] ys)\\<rbrakk>\n       \\<Longrightarrow> f x = f y\n 2. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   \\<lbrakk>map f xs = map f ys;\n                    (x, y) \\<in> set (zip xs ys)\\<rbrakk>\n                   \\<Longrightarrow> f x = f y;\n        map f (a # xs) = map f ys;\n        (x, y) \\<in> set (zip (a # xs) ys)\\<rbrakk>\n       \\<Longrightarrow> f x = f y", "case (Cons x xs)"], ["proof (state)\nthis:\n  \\<lbrakk>map f xs = map f ?ys; (x, y) \\<in> set (zip xs ?ys)\\<rbrakk>\n  \\<Longrightarrow> f x = f y\n  map f (x # xs) = map f ys\n  (x, y) \\<in> set (zip (x # xs) ys)\n\ngoal (2 subgoals):\n 1. \\<And>ys.\n       \\<lbrakk>map f [] = map f ys; (x, y) \\<in> set (zip [] ys)\\<rbrakk>\n       \\<Longrightarrow> f x = f y\n 2. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   \\<lbrakk>map f xs = map f ys;\n                    (x, y) \\<in> set (zip xs ys)\\<rbrakk>\n                   \\<Longrightarrow> f x = f y;\n        map f (a # xs) = map f ys;\n        (x, y) \\<in> set (zip (a # xs) ys)\\<rbrakk>\n       \\<Longrightarrow> f x = f y", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>map f xs = map f ?ys; (x, y) \\<in> set (zip xs ?ys)\\<rbrakk>\n  \\<Longrightarrow> f x = f y\n  map f (x # xs) = map f ys\n  (x, y) \\<in> set (zip (x # xs) ys)", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>map f xs = map f ?ys; (x, y) \\<in> set (zip xs ?ys)\\<rbrakk>\n  \\<Longrightarrow> f x = f y\n  map f (x # xs) = map f ys\n  (x, y) \\<in> set (zip (x # xs) ys)\n\ngoal (1 subgoal):\n 1. f x = f y", "by (cases ys) auto"], ["proof (state)\nthis:\n  f x = f y\n\ngoal (1 subgoal):\n 1. \\<And>ys.\n       \\<lbrakk>map f [] = map f ys; (x, y) \\<in> set (zip [] ys)\\<rbrakk>\n       \\<Longrightarrow> f x = f y", "qed simp"], ["", "fun span :: \"('a \\<Rightarrow> bool) \\<Rightarrow> 'a list \\<Rightarrow> 'a list \\<times> 'a list\" where\n  \"span P (x # xs) =\n    (if P x then let (ys, zs) = span P xs in (x # ys, zs)\n    else ([], x # xs))\" |\n  \"span _ [] = ([], [])\""], ["", "lemma span[simp]: \"span P xs = (takeWhile P xs, dropWhile P xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. span P xs = (takeWhile P xs, dropWhile P xs)", "by (induct xs, auto)"], ["", "declare span.simps[simp del]"], ["", "lemma parallel_list_update: assumes \n  one_update: \"\\<And> xs i y. length xs = n \\<Longrightarrow> i < n \\<Longrightarrow> r (xs ! i) y \\<Longrightarrow> p xs \\<Longrightarrow> p (xs[i := y])\"\n  and init: \"length xs = n\" \"p xs\"\n  and rel: \"length ys = n\" \"\\<And> i. i < n \\<Longrightarrow> r (xs ! i) (ys ! i)\"\n  shows \"p ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p ys", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. p ys", "note len = rel(1) init(1)"], ["proof (state)\nthis:\n  length ys = n\n  length xs = n\n\ngoal (1 subgoal):\n 1. p ys", "{"], ["proof (state)\nthis:\n  length ys = n\n  length xs = n\n\ngoal (1 subgoal):\n 1. p ys", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. p ys", "assume \"i \\<le> n\""], ["proof (state)\nthis:\n  i \\<le> n\n\ngoal (1 subgoal):\n 1. p ys", "hence \"p (take i ys @ drop i xs)\""], ["proof (prove)\nusing this:\n  i \\<le> n\n\ngoal (1 subgoal):\n 1. p (take i ys @ drop i xs)", "proof (induct i)"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 \\<le> n \\<Longrightarrow> p (take 0 ys @ drop 0 xs)\n 2. \\<And>i.\n       \\<lbrakk>i \\<le> n \\<Longrightarrow> p (take i ys @ drop i xs);\n        Suc i \\<le> n\\<rbrakk>\n       \\<Longrightarrow> p (take (Suc i) ys @ drop (Suc i) xs)", "case 0"], ["proof (state)\nthis:\n  0 \\<le> n\n\ngoal (2 subgoals):\n 1. 0 \\<le> n \\<Longrightarrow> p (take 0 ys @ drop 0 xs)\n 2. \\<And>i.\n       \\<lbrakk>i \\<le> n \\<Longrightarrow> p (take i ys @ drop i xs);\n        Suc i \\<le> n\\<rbrakk>\n       \\<Longrightarrow> p (take (Suc i) ys @ drop (Suc i) xs)", "with init"], ["proof (chain)\npicking this:\n  length xs = n\n  p xs\n  0 \\<le> n", "show ?case"], ["proof (prove)\nusing this:\n  length xs = n\n  p xs\n  0 \\<le> n\n\ngoal (1 subgoal):\n 1. p (take 0 ys @ drop 0 xs)", "by simp"], ["proof (state)\nthis:\n  p (take 0 ys @ drop 0 xs)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i \\<le> n \\<Longrightarrow> p (take i ys @ drop i xs);\n        Suc i \\<le> n\\<rbrakk>\n       \\<Longrightarrow> p (take (Suc i) ys @ drop (Suc i) xs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i \\<le> n \\<Longrightarrow> p (take i ys @ drop i xs);\n        Suc i \\<le> n\\<rbrakk>\n       \\<Longrightarrow> p (take (Suc i) ys @ drop (Suc i) xs)", "case (Suc i)"], ["proof (state)\nthis:\n  i \\<le> n \\<Longrightarrow> p (take i ys @ drop i xs)\n  Suc i \\<le> n\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i \\<le> n \\<Longrightarrow> p (take i ys @ drop i xs);\n        Suc i \\<le> n\\<rbrakk>\n       \\<Longrightarrow> p (take (Suc i) ys @ drop (Suc i) xs)", "hence IH: \"p (take i ys @ drop i xs)\""], ["proof (prove)\nusing this:\n  i \\<le> n \\<Longrightarrow> p (take i ys @ drop i xs)\n  Suc i \\<le> n\n\ngoal (1 subgoal):\n 1. p (take i ys @ drop i xs)", "by simp"], ["proof (state)\nthis:\n  p (take i ys @ drop i xs)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i \\<le> n \\<Longrightarrow> p (take i ys @ drop i xs);\n        Suc i \\<le> n\\<rbrakk>\n       \\<Longrightarrow> p (take (Suc i) ys @ drop (Suc i) xs)", "from Suc"], ["proof (chain)\npicking this:\n  i \\<le> n \\<Longrightarrow> p (take i ys @ drop i xs)\n  Suc i \\<le> n", "have i: \"i < n\""], ["proof (prove)\nusing this:\n  i \\<le> n \\<Longrightarrow> p (take i ys @ drop i xs)\n  Suc i \\<le> n\n\ngoal (1 subgoal):\n 1. i < n", "by simp"], ["proof (state)\nthis:\n  i < n\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i \\<le> n \\<Longrightarrow> p (take i ys @ drop i xs);\n        Suc i \\<le> n\\<rbrakk>\n       \\<Longrightarrow> p (take (Suc i) ys @ drop (Suc i) xs)", "let ?xs = \"(take i ys @ drop i xs)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i \\<le> n \\<Longrightarrow> p (take i ys @ drop i xs);\n        Suc i \\<le> n\\<rbrakk>\n       \\<Longrightarrow> p (take (Suc i) ys @ drop (Suc i) xs)", "have \"length ?xs = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (take i ys @ drop i xs) = n", "using i len"], ["proof (prove)\nusing this:\n  i < n\n  length ys = n\n  length xs = n\n\ngoal (1 subgoal):\n 1. length (take i ys @ drop i xs) = n", "by simp"], ["proof (state)\nthis:\n  length (take i ys @ drop i xs) = n\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i \\<le> n \\<Longrightarrow> p (take i ys @ drop i xs);\n        Suc i \\<le> n\\<rbrakk>\n       \\<Longrightarrow> p (take (Suc i) ys @ drop (Suc i) xs)", "from one_update[OF this i _ IH, of \"ys ! i\"] rel(2)[OF i] i len"], ["proof (chain)\npicking this:\n  r ((take i ys @ drop i xs) ! i) (ys ! i) \\<Longrightarrow>\n  p ((take i ys @ drop i xs)[i := ys ! i])\n  r (xs ! i) (ys ! i)\n  i < n\n  length ys = n\n  length xs = n", "show ?case"], ["proof (prove)\nusing this:\n  r ((take i ys @ drop i xs) ! i) (ys ! i) \\<Longrightarrow>\n  p ((take i ys @ drop i xs)[i := ys ! i])\n  r (xs ! i) (ys ! i)\n  i < n\n  length ys = n\n  length xs = n\n\ngoal (1 subgoal):\n 1. p (take (Suc i) ys @ drop (Suc i) xs)", "by (simp add: nth_append take_drop_update_first)"], ["proof (state)\nthis:\n  p (take (Suc i) ys @ drop (Suc i) xs)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  p (take i ys @ drop i xs)\n\ngoal (1 subgoal):\n 1. p ys", "}"], ["proof (state)\nthis:\n  ?i2 \\<le> n \\<Longrightarrow> p (take ?i2 ys @ drop ?i2 xs)\n\ngoal (1 subgoal):\n 1. p ys", "from this[of n]"], ["proof (chain)\npicking this:\n  n \\<le> n \\<Longrightarrow> p (take n ys @ drop n xs)", "show ?thesis"], ["proof (prove)\nusing this:\n  n \\<le> n \\<Longrightarrow> p (take n ys @ drop n xs)\n\ngoal (1 subgoal):\n 1. p ys", "using len"], ["proof (prove)\nusing this:\n  n \\<le> n \\<Longrightarrow> p (take n ys @ drop n xs)\n  length ys = n\n  length xs = n\n\ngoal (1 subgoal):\n 1. p ys", "by auto"], ["proof (state)\nthis:\n  p ys\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma nth_concat_two_lists: \n  \"i < length (concat (xs :: 'a list list)) \\<Longrightarrow> length (ys :: 'b list list) = length xs \n  \\<Longrightarrow> (\\<And> i. i < length xs \\<Longrightarrow> length (ys ! i) = length (xs ! i))\n  \\<Longrightarrow> \\<exists> j k. j < length xs \\<and> k < length (xs ! j) \\<and> (concat xs) ! i = xs ! j ! k \\<and>\n     (concat ys) ! i = ys ! j ! k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < length (concat xs); length ys = length xs;\n     \\<And>i.\n        i < length xs \\<Longrightarrow>\n        length (ys ! i) = length (xs ! i)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>j k.\n                         j < length xs \\<and>\n                         k < length (xs ! j) \\<and>\n                         concat xs ! i = xs ! j ! k \\<and>\n                         concat ys ! i = ys ! j ! k", "proof (induct xs arbitrary: i ys)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i ys.\n       \\<lbrakk>i < length (concat []); length ys = length [];\n        \\<And>i.\n           i < length [] \\<Longrightarrow>\n           length (ys ! i) = length ([] ! i)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j k.\n                            j < length [] \\<and>\n                            k < length ([] ! j) \\<and>\n                            concat [] ! i = [] ! j ! k \\<and>\n                            concat ys ! i = ys ! j ! k\n 2. \\<And>a xs i ys.\n       \\<lbrakk>\\<And>i ys.\n                   \\<lbrakk>i < length (concat xs); length ys = length xs;\n                    \\<And>i.\n                       i < length xs \\<Longrightarrow>\n                       length (ys ! i) = length (xs ! i)\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>j k.\n  j < length xs \\<and>\n  k < length (xs ! j) \\<and>\n  concat xs ! i = xs ! j ! k \\<and> concat ys ! i = ys ! j ! k;\n        i < length (concat (a # xs)); length ys = length (a # xs);\n        \\<And>i.\n           i < length (a # xs) \\<Longrightarrow>\n           length (ys ! i) = length ((a # xs) ! i)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j k.\n                            j < length (a # xs) \\<and>\n                            k < length ((a # xs) ! j) \\<and>\n                            concat (a # xs) ! i = (a # xs) ! j ! k \\<and>\n                            concat ys ! i = ys ! j ! k", "case (Cons x xs i yys)"], ["proof (state)\nthis:\n  \\<lbrakk>?i < length (concat xs); length ?ys = length xs;\n   \\<And>i.\n      i < length xs \\<Longrightarrow>\n      length (?ys ! i) = length (xs ! i)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>j k.\n                       j < length xs \\<and>\n                       k < length (xs ! j) \\<and>\n                       concat xs ! ?i = xs ! j ! k \\<and>\n                       concat ?ys ! ?i = ?ys ! j ! k\n  i < length (concat (x # xs))\n  length yys = length (x # xs)\n  ?i < length (x # xs) \\<Longrightarrow>\n  length (yys ! ?i) = length ((x # xs) ! ?i)\n\ngoal (2 subgoals):\n 1. \\<And>i ys.\n       \\<lbrakk>i < length (concat []); length ys = length [];\n        \\<And>i.\n           i < length [] \\<Longrightarrow>\n           length (ys ! i) = length ([] ! i)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j k.\n                            j < length [] \\<and>\n                            k < length ([] ! j) \\<and>\n                            concat [] ! i = [] ! j ! k \\<and>\n                            concat ys ! i = ys ! j ! k\n 2. \\<And>a xs i ys.\n       \\<lbrakk>\\<And>i ys.\n                   \\<lbrakk>i < length (concat xs); length ys = length xs;\n                    \\<And>i.\n                       i < length xs \\<Longrightarrow>\n                       length (ys ! i) = length (xs ! i)\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>j k.\n  j < length xs \\<and>\n  k < length (xs ! j) \\<and>\n  concat xs ! i = xs ! j ! k \\<and> concat ys ! i = ys ! j ! k;\n        i < length (concat (a # xs)); length ys = length (a # xs);\n        \\<And>i.\n           i < length (a # xs) \\<Longrightarrow>\n           length (ys ! i) = length ((a # xs) ! i)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j k.\n                            j < length (a # xs) \\<and>\n                            k < length ((a # xs) ! j) \\<and>\n                            concat (a # xs) ! i = (a # xs) ! j ! k \\<and>\n                            concat ys ! i = ys ! j ! k", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>?i < length (concat xs); length ?ys = length xs;\n   \\<And>i.\n      i < length xs \\<Longrightarrow>\n      length (?ys ! i) = length (xs ! i)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>j k.\n                       j < length xs \\<and>\n                       k < length (xs ! j) \\<and>\n                       concat xs ! ?i = xs ! j ! k \\<and>\n                       concat ?ys ! ?i = ?ys ! j ! k\n  i < length (concat (x # xs))\n  length yys = length (x # xs)\n  ?i < length (x # xs) \\<Longrightarrow>\n  length (yys ! ?i) = length ((x # xs) ! ?i)", "obtain y ys where yys: \"yys = y # ys\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?i < length (concat xs); length ?ys = length xs;\n   \\<And>i.\n      i < length xs \\<Longrightarrow>\n      length (?ys ! i) = length (xs ! i)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>j k.\n                       j < length xs \\<and>\n                       k < length (xs ! j) \\<and>\n                       concat xs ! ?i = xs ! j ! k \\<and>\n                       concat ?ys ! ?i = ?ys ! j ! k\n  i < length (concat (x # xs))\n  length yys = length (x # xs)\n  ?i < length (x # xs) \\<Longrightarrow>\n  length (yys ! ?i) = length ((x # xs) ! ?i)\n\ngoal (1 subgoal):\n 1. (\\<And>y ys. yys = y # ys \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases yys, auto)"], ["proof (state)\nthis:\n  yys = y # ys\n\ngoal (2 subgoals):\n 1. \\<And>i ys.\n       \\<lbrakk>i < length (concat []); length ys = length [];\n        \\<And>i.\n           i < length [] \\<Longrightarrow>\n           length (ys ! i) = length ([] ! i)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j k.\n                            j < length [] \\<and>\n                            k < length ([] ! j) \\<and>\n                            concat [] ! i = [] ! j ! k \\<and>\n                            concat ys ! i = ys ! j ! k\n 2. \\<And>a xs i ys.\n       \\<lbrakk>\\<And>i ys.\n                   \\<lbrakk>i < length (concat xs); length ys = length xs;\n                    \\<And>i.\n                       i < length xs \\<Longrightarrow>\n                       length (ys ! i) = length (xs ! i)\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>j k.\n  j < length xs \\<and>\n  k < length (xs ! j) \\<and>\n  concat xs ! i = xs ! j ! k \\<and> concat ys ! i = ys ! j ! k;\n        i < length (concat (a # xs)); length ys = length (a # xs);\n        \\<And>i.\n           i < length (a # xs) \\<Longrightarrow>\n           length (ys ! i) = length ((a # xs) ! i)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j k.\n                            j < length (a # xs) \\<and>\n                            k < length ((a # xs) ! j) \\<and>\n                            concat (a # xs) ! i = (a # xs) ! j ! k \\<and>\n                            concat ys ! i = ys ! j ! k", "note Cons = Cons[unfolded yys]"], ["proof (state)\nthis:\n  \\<lbrakk>?i < length (concat xs); length ?ys = length xs;\n   \\<And>i.\n      i < length xs \\<Longrightarrow>\n      length (?ys ! i) = length (xs ! i)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>j k.\n                       j < length xs \\<and>\n                       k < length (xs ! j) \\<and>\n                       concat xs ! ?i = xs ! j ! k \\<and>\n                       concat ?ys ! ?i = ?ys ! j ! k\n  i < length (concat (x # xs))\n  length (y # ys) = length (x # xs)\n  ?i < length (x # xs) \\<Longrightarrow>\n  length ((y # ys) ! ?i) = length ((x # xs) ! ?i)\n\ngoal (2 subgoals):\n 1. \\<And>i ys.\n       \\<lbrakk>i < length (concat []); length ys = length [];\n        \\<And>i.\n           i < length [] \\<Longrightarrow>\n           length (ys ! i) = length ([] ! i)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j k.\n                            j < length [] \\<and>\n                            k < length ([] ! j) \\<and>\n                            concat [] ! i = [] ! j ! k \\<and>\n                            concat ys ! i = ys ! j ! k\n 2. \\<And>a xs i ys.\n       \\<lbrakk>\\<And>i ys.\n                   \\<lbrakk>i < length (concat xs); length ys = length xs;\n                    \\<And>i.\n                       i < length xs \\<Longrightarrow>\n                       length (ys ! i) = length (xs ! i)\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>j k.\n  j < length xs \\<and>\n  k < length (xs ! j) \\<and>\n  concat xs ! i = xs ! j ! k \\<and> concat ys ! i = ys ! j ! k;\n        i < length (concat (a # xs)); length ys = length (a # xs);\n        \\<And>i.\n           i < length (a # xs) \\<Longrightarrow>\n           length (ys ! i) = length ((a # xs) ! i)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j k.\n                            j < length (a # xs) \\<and>\n                            k < length ((a # xs) ! j) \\<and>\n                            concat (a # xs) ! i = (a # xs) ! j ! k \\<and>\n                            concat ys ! i = ys ! j ! k", "from Cons(4)[of 0]"], ["proof (chain)\npicking this:\n  0 < length (x # xs) \\<Longrightarrow>\n  length ((y # ys) ! 0) = length ((x # xs) ! 0)", "have [simp]: \"length y = length x\""], ["proof (prove)\nusing this:\n  0 < length (x # xs) \\<Longrightarrow>\n  length ((y # ys) ! 0) = length ((x # xs) ! 0)\n\ngoal (1 subgoal):\n 1. length y = length x", "by simp"], ["proof (state)\nthis:\n  length y = length x\n\ngoal (2 subgoals):\n 1. \\<And>i ys.\n       \\<lbrakk>i < length (concat []); length ys = length [];\n        \\<And>i.\n           i < length [] \\<Longrightarrow>\n           length (ys ! i) = length ([] ! i)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j k.\n                            j < length [] \\<and>\n                            k < length ([] ! j) \\<and>\n                            concat [] ! i = [] ! j ! k \\<and>\n                            concat ys ! i = ys ! j ! k\n 2. \\<And>a xs i ys.\n       \\<lbrakk>\\<And>i ys.\n                   \\<lbrakk>i < length (concat xs); length ys = length xs;\n                    \\<And>i.\n                       i < length xs \\<Longrightarrow>\n                       length (ys ! i) = length (xs ! i)\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>j k.\n  j < length xs \\<and>\n  k < length (xs ! j) \\<and>\n  concat xs ! i = xs ! j ! k \\<and> concat ys ! i = ys ! j ! k;\n        i < length (concat (a # xs)); length ys = length (a # xs);\n        \\<And>i.\n           i < length (a # xs) \\<Longrightarrow>\n           length (ys ! i) = length ((a # xs) ! i)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j k.\n                            j < length (a # xs) \\<and>\n                            k < length ((a # xs) ! j) \\<and>\n                            concat (a # xs) ! i = (a # xs) ! j ! k \\<and>\n                            concat ys ! i = ys ! j ! k", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>j k.\n       j < length (x # xs) \\<and>\n       k < length ((x # xs) ! j) \\<and>\n       concat (x # xs) ! i = (x # xs) ! j ! k \\<and>\n       concat yys ! i = yys ! j ! k", "proof (cases \"i < length x\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i < length x \\<Longrightarrow>\n    \\<exists>j k.\n       j < length (x # xs) \\<and>\n       k < length ((x # xs) ! j) \\<and>\n       concat (x # xs) ! i = (x # xs) ! j ! k \\<and>\n       concat yys ! i = yys ! j ! k\n 2. \\<not> i < length x \\<Longrightarrow>\n    \\<exists>j k.\n       j < length (x # xs) \\<and>\n       k < length ((x # xs) ! j) \\<and>\n       concat (x # xs) ! i = (x # xs) ! j ! k \\<and>\n       concat yys ! i = yys ! j ! k", "case True"], ["proof (state)\nthis:\n  i < length x\n\ngoal (2 subgoals):\n 1. i < length x \\<Longrightarrow>\n    \\<exists>j k.\n       j < length (x # xs) \\<and>\n       k < length ((x # xs) ! j) \\<and>\n       concat (x # xs) ! i = (x # xs) ! j ! k \\<and>\n       concat yys ! i = yys ! j ! k\n 2. \\<not> i < length x \\<Longrightarrow>\n    \\<exists>j k.\n       j < length (x # xs) \\<and>\n       k < length ((x # xs) ! j) \\<and>\n       concat (x # xs) ! i = (x # xs) ! j ! k \\<and>\n       concat yys ! i = yys ! j ! k", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>j k.\n       j < length (x # xs) \\<and>\n       k < length ((x # xs) ! j) \\<and>\n       concat (x # xs) ! i = (x # xs) ! j ! k \\<and>\n       concat yys ! i = yys ! j ! k", "unfolding yys"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>j k.\n       j < length (x # xs) \\<and>\n       k < length ((x # xs) ! j) \\<and>\n       concat (x # xs) ! i = (x # xs) ! j ! k \\<and>\n       concat (y # ys) ! i = (y # ys) ! j ! k", "by (rule exI[of _ 0], rule exI[of _ i], insert True Cons(2-4), auto simp: nth_append)"], ["proof (state)\nthis:\n  \\<exists>j k.\n     j < length (x # xs) \\<and>\n     k < length ((x # xs) ! j) \\<and>\n     concat (x # xs) ! i = (x # xs) ! j ! k \\<and>\n     concat yys ! i = yys ! j ! k\n\ngoal (1 subgoal):\n 1. \\<not> i < length x \\<Longrightarrow>\n    \\<exists>j k.\n       j < length (x # xs) \\<and>\n       k < length ((x # xs) ! j) \\<and>\n       concat (x # xs) ! i = (x # xs) ! j ! k \\<and>\n       concat yys ! i = yys ! j ! k", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> i < length x \\<Longrightarrow>\n    \\<exists>j k.\n       j < length (x # xs) \\<and>\n       k < length ((x # xs) ! j) \\<and>\n       concat (x # xs) ! i = (x # xs) ! j ! k \\<and>\n       concat yys ! i = yys ! j ! k", "case False"], ["proof (state)\nthis:\n  \\<not> i < length x\n\ngoal (1 subgoal):\n 1. \\<not> i < length x \\<Longrightarrow>\n    \\<exists>j k.\n       j < length (x # xs) \\<and>\n       k < length ((x # xs) ! j) \\<and>\n       concat (x # xs) ! i = (x # xs) ! j ! k \\<and>\n       concat yys ! i = yys ! j ! k", "let ?i = \"i - length x\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> i < length x \\<Longrightarrow>\n    \\<exists>j k.\n       j < length (x # xs) \\<and>\n       k < length ((x # xs) ! j) \\<and>\n       concat (x # xs) ! i = (x # xs) ! j ! k \\<and>\n       concat yys ! i = yys ! j ! k", "from False Cons(2-3)"], ["proof (chain)\npicking this:\n  \\<not> i < length x\n  i < length (concat (x # xs))\n  length (y # ys) = length (x # xs)", "have \"?i < length (concat xs)\" \"length ys = length xs\""], ["proof (prove)\nusing this:\n  \\<not> i < length x\n  i < length (concat (x # xs))\n  length (y # ys) = length (x # xs)\n\ngoal (1 subgoal):\n 1. i - length x < length (concat xs) &&& length ys = length xs", "by auto"], ["proof (state)\nthis:\n  i - length x < length (concat xs)\n  length ys = length xs\n\ngoal (1 subgoal):\n 1. \\<not> i < length x \\<Longrightarrow>\n    \\<exists>j k.\n       j < length (x # xs) \\<and>\n       k < length ((x # xs) ! j) \\<and>\n       concat (x # xs) ! i = (x # xs) ! j ! k \\<and>\n       concat yys ! i = yys ! j ! k", "note IH = Cons(1)[OF this]"], ["proof (state)\nthis:\n  (\\<And>i.\n      i < length xs \\<Longrightarrow>\n      length (ys ! i) = length (xs ! i)) \\<Longrightarrow>\n  \\<exists>j k.\n     j < length xs \\<and>\n     k < length (xs ! j) \\<and>\n     concat xs ! (i - length x) = xs ! j ! k \\<and>\n     concat ys ! (i - length x) = ys ! j ! k\n\ngoal (1 subgoal):\n 1. \\<not> i < length x \\<Longrightarrow>\n    \\<exists>j k.\n       j < length (x # xs) \\<and>\n       k < length ((x # xs) ! j) \\<and>\n       concat (x # xs) ! i = (x # xs) ! j ! k \\<and>\n       concat yys ! i = yys ! j ! k", "{"], ["proof (state)\nthis:\n  (\\<And>i.\n      i < length xs \\<Longrightarrow>\n      length (ys ! i) = length (xs ! i)) \\<Longrightarrow>\n  \\<exists>j k.\n     j < length xs \\<and>\n     k < length (xs ! j) \\<and>\n     concat xs ! (i - length x) = xs ! j ! k \\<and>\n     concat ys ! (i - length x) = ys ! j ! k\n\ngoal (1 subgoal):\n 1. \\<not> i < length x \\<Longrightarrow>\n    \\<exists>j k.\n       j < length (x # xs) \\<and>\n       k < length ((x # xs) ! j) \\<and>\n       concat (x # xs) ! i = (x # xs) ! j ! k \\<and>\n       concat yys ! i = yys ! j ! k", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> ia__ < length x \\<Longrightarrow>\n    \\<exists>j k.\n       j < length (x # xs) \\<and>\n       k < length ((x # xs) ! j) \\<and>\n       concat (x # xs) ! ia__ = (x # xs) ! j ! k \\<and>\n       concat yys ! ia__ = yys ! j ! k", "assume \"i < length xs\""], ["proof (state)\nthis:\n  i < length xs\n\ngoal (1 subgoal):\n 1. \\<not> ia__ < length x \\<Longrightarrow>\n    \\<exists>j k.\n       j < length (x # xs) \\<and>\n       k < length ((x # xs) ! j) \\<and>\n       concat (x # xs) ! ia__ = (x # xs) ! j ! k \\<and>\n       concat yys ! ia__ = yys ! j ! k", "with Cons(4)[of \"Suc i\"]"], ["proof (chain)\npicking this:\n  Suc i < length (x # xs) \\<Longrightarrow>\n  length ((y # ys) ! Suc i) = length ((x # xs) ! Suc i)\n  i < length xs", "have \"length (ys ! i) = length (xs ! i)\""], ["proof (prove)\nusing this:\n  Suc i < length (x # xs) \\<Longrightarrow>\n  length ((y # ys) ! Suc i) = length ((x # xs) ! Suc i)\n  i < length xs\n\ngoal (1 subgoal):\n 1. length (ys ! i) = length (xs ! i)", "by simp"], ["proof (state)\nthis:\n  length (ys ! i) = length (xs ! i)\n\ngoal (1 subgoal):\n 1. \\<not> ia__ < length x \\<Longrightarrow>\n    \\<exists>j k.\n       j < length (x # xs) \\<and>\n       k < length ((x # xs) ! j) \\<and>\n       concat (x # xs) ! ia__ = (x # xs) ! j ! k \\<and>\n       concat yys ! ia__ = yys ! j ! k", "}"], ["proof (state)\nthis:\n  ?ib2 < length xs \\<Longrightarrow> length (ys ! ?ib2) = length (xs ! ?ib2)\n\ngoal (1 subgoal):\n 1. \\<not> i < length x \\<Longrightarrow>\n    \\<exists>j k.\n       j < length (x # xs) \\<and>\n       k < length ((x # xs) ! j) \\<and>\n       concat (x # xs) ! i = (x # xs) ! j ! k \\<and>\n       concat yys ! i = yys ! j ! k", "from IH[OF this]"], ["proof (chain)\npicking this:\n  (\\<And>i. i < length xs \\<Longrightarrow> i < length xs) \\<Longrightarrow>\n  \\<exists>j k.\n     j < length xs \\<and>\n     k < length (xs ! j) \\<and>\n     concat xs ! (i - length x) = xs ! j ! k \\<and>\n     concat ys ! (i - length x) = ys ! j ! k", "obtain j k where IH1: \"j < length xs\" \"k < length (xs ! j)\" \n      \"concat xs ! ?i = xs ! j ! k\"\n      \"concat ys ! ?i = ys ! j ! k\""], ["proof (prove)\nusing this:\n  (\\<And>i. i < length xs \\<Longrightarrow> i < length xs) \\<Longrightarrow>\n  \\<exists>j k.\n     j < length xs \\<and>\n     k < length (xs ! j) \\<and>\n     concat xs ! (i - length x) = xs ! j ! k \\<and>\n     concat ys ! (i - length x) = ys ! j ! k\n\ngoal (1 subgoal):\n 1. (\\<And>j k.\n        \\<lbrakk>j < length xs; k < length (xs ! j);\n         concat xs ! (i - length x) = xs ! j ! k;\n         concat ys ! (i - length x) = ys ! j ! k\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  j < length xs\n  k < length (xs ! j)\n  concat xs ! (i - length x) = xs ! j ! k\n  concat ys ! (i - length x) = ys ! j ! k\n\ngoal (1 subgoal):\n 1. \\<not> i < length x \\<Longrightarrow>\n    \\<exists>j k.\n       j < length (x # xs) \\<and>\n       k < length ((x # xs) ! j) \\<and>\n       concat (x # xs) ! i = (x # xs) ! j ! k \\<and>\n       concat yys ! i = yys ! j ! k", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>j k.\n       j < length (x # xs) \\<and>\n       k < length ((x # xs) ! j) \\<and>\n       concat (x # xs) ! i = (x # xs) ! j ! k \\<and>\n       concat yys ! i = yys ! j ! k", "unfolding yys"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>j k.\n       j < length (x # xs) \\<and>\n       k < length ((x # xs) ! j) \\<and>\n       concat (x # xs) ! i = (x # xs) ! j ! k \\<and>\n       concat (y # ys) ! i = (y # ys) ! j ! k", "by (rule exI[of _ \"Suc j\"], rule exI[of _ k], insert IH1 False, auto simp: nth_append)"], ["proof (state)\nthis:\n  \\<exists>j k.\n     j < length (x # xs) \\<and>\n     k < length ((x # xs) ! j) \\<and>\n     concat (x # xs) ! i = (x # xs) ! j ! k \\<and>\n     concat yys ! i = yys ! j ! k\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>j k.\n     j < length (x # xs) \\<and>\n     k < length ((x # xs) ! j) \\<and>\n     concat (x # xs) ! i = (x # xs) ! j ! k \\<and>\n     concat yys ! i = yys ! j ! k\n\ngoal (1 subgoal):\n 1. \\<And>i ys.\n       \\<lbrakk>i < length (concat []); length ys = length [];\n        \\<And>i.\n           i < length [] \\<Longrightarrow>\n           length (ys ! i) = length ([] ! i)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j k.\n                            j < length [] \\<and>\n                            k < length ([] ! j) \\<and>\n                            concat [] ! i = [] ! j ! k \\<and>\n                            concat ys ! i = ys ! j ! k", "qed simp"], ["", "text \\<open>Removing duplicates w.r.t. some function.\\<close>"], ["", "fun remdups_gen :: \"('a \\<Rightarrow> 'b) \\<Rightarrow> 'a list \\<Rightarrow> 'a list\" where\n  \"remdups_gen f [] = []\"\n| \"remdups_gen f (x # xs) = x # remdups_gen f [y <- xs. \\<not> f x = f y]\""], ["", "lemma remdups_gen_subset: \"set (remdups_gen f xs) \\<subseteq> set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (remdups_gen f xs) \\<subseteq> set xs", "by (induct f xs rule: remdups_gen.induct, auto)"], ["", "lemma remdups_gen_elem_imp_elem: \"x \\<in> set (remdups_gen f xs) \\<Longrightarrow> x \\<in> set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> set (remdups_gen f xs) \\<Longrightarrow> x \\<in> set xs", "using remdups_gen_subset[of f xs]"], ["proof (prove)\nusing this:\n  set (remdups_gen f xs) \\<subseteq> set xs\n\ngoal (1 subgoal):\n 1. x \\<in> set (remdups_gen f xs) \\<Longrightarrow> x \\<in> set xs", "by blast"], ["", "lemma elem_imp_remdups_gen_elem: \"x \\<in> set xs \\<Longrightarrow> \\<exists> y \\<in> set (remdups_gen f xs). f x = f y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> set xs \\<Longrightarrow>\n    \\<exists>y\\<in>set (remdups_gen f xs). f x = f y", "proof (induct f xs rule: remdups_gen.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>f.\n       x \\<in> set [] \\<Longrightarrow>\n       \\<exists>y\\<in>set (remdups_gen f []). f x = f y\n 2. \\<And>f xa xs.\n       \\<lbrakk>x \\<in> set (filter (\\<lambda>y. f xa \\<noteq> f y)\n                              xs) \\<Longrightarrow>\n                \\<exists>y\\<in>set (remdups_gen f\n                                     (filter (\\<lambda>y. f xa \\<noteq> f y)\n xs)).\n                   f x = f y;\n        x \\<in> set (xa # xs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y\\<in>set (remdups_gen f (xa # xs)).\n                            f x = f y", "case (2 f z zs)"], ["proof (state)\nthis:\n  x \\<in> set (filter (\\<lambda>y. f z \\<noteq> f y) zs) \\<Longrightarrow>\n  \\<exists>y\\<in>set (remdups_gen f\n                       (filter (\\<lambda>y. f z \\<noteq> f y) zs)).\n     f x = f y\n  x \\<in> set (z # zs)\n\ngoal (2 subgoals):\n 1. \\<And>f.\n       x \\<in> set [] \\<Longrightarrow>\n       \\<exists>y\\<in>set (remdups_gen f []). f x = f y\n 2. \\<And>f xa xs.\n       \\<lbrakk>x \\<in> set (filter (\\<lambda>y. f xa \\<noteq> f y)\n                              xs) \\<Longrightarrow>\n                \\<exists>y\\<in>set (remdups_gen f\n                                     (filter (\\<lambda>y. f xa \\<noteq> f y)\n xs)).\n                   f x = f y;\n        x \\<in> set (xa # xs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y\\<in>set (remdups_gen f (xa # xs)).\n                            f x = f y", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>y\\<in>set (remdups_gen f (z # zs)). f x = f y", "proof (cases \"f x = f z\")"], ["proof (state)\ngoal (2 subgoals):\n 1. f x = f z \\<Longrightarrow>\n    \\<exists>y\\<in>set (remdups_gen f (z # zs)). f x = f y\n 2. f x \\<noteq> f z \\<Longrightarrow>\n    \\<exists>y\\<in>set (remdups_gen f (z # zs)). f x = f y", "case False"], ["proof (state)\nthis:\n  f x \\<noteq> f z\n\ngoal (2 subgoals):\n 1. f x = f z \\<Longrightarrow>\n    \\<exists>y\\<in>set (remdups_gen f (z # zs)). f x = f y\n 2. f x \\<noteq> f z \\<Longrightarrow>\n    \\<exists>y\\<in>set (remdups_gen f (z # zs)). f x = f y", "with 2(2)"], ["proof (chain)\npicking this:\n  x \\<in> set (z # zs)\n  f x \\<noteq> f z", "have \"x \\<in> set [y\\<leftarrow>zs . f z \\<noteq> f y]\""], ["proof (prove)\nusing this:\n  x \\<in> set (z # zs)\n  f x \\<noteq> f z\n\ngoal (1 subgoal):\n 1. x \\<in> set (filter (\\<lambda>y. f z \\<noteq> f y) zs)", "by auto"], ["proof (state)\nthis:\n  x \\<in> set (filter (\\<lambda>y. f z \\<noteq> f y) zs)\n\ngoal (2 subgoals):\n 1. f x = f z \\<Longrightarrow>\n    \\<exists>y\\<in>set (remdups_gen f (z # zs)). f x = f y\n 2. f x \\<noteq> f z \\<Longrightarrow>\n    \\<exists>y\\<in>set (remdups_gen f (z # zs)). f x = f y", "from 2(1)[OF this]"], ["proof (chain)\npicking this:\n  \\<exists>y\\<in>set (remdups_gen f\n                       (filter (\\<lambda>y. f z \\<noteq> f y) zs)).\n     f x = f y", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>y\\<in>set (remdups_gen f\n                       (filter (\\<lambda>y. f z \\<noteq> f y) zs)).\n     f x = f y\n\ngoal (1 subgoal):\n 1. \\<exists>y\\<in>set (remdups_gen f (z # zs)). f x = f y", "by auto"], ["proof (state)\nthis:\n  \\<exists>y\\<in>set (remdups_gen f (z # zs)). f x = f y\n\ngoal (1 subgoal):\n 1. f x = f z \\<Longrightarrow>\n    \\<exists>y\\<in>set (remdups_gen f (z # zs)). f x = f y", "qed auto"], ["proof (state)\nthis:\n  \\<exists>y\\<in>set (remdups_gen f (z # zs)). f x = f y\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       x \\<in> set [] \\<Longrightarrow>\n       \\<exists>y\\<in>set (remdups_gen f []). f x = f y", "qed auto"], ["", "lemma take_nth_drop_concat:\n  assumes \"i < length xss\" and \"xss ! i = ys\"\n    and \"j < length ys\" and \"ys ! j = z\"\n  shows \"\\<exists>k < length (concat xss).\n    take k (concat xss) = concat (take i xss) @ take j ys \\<and>\n    concat xss ! k = xss ! i ! j \\<and>\n    drop (Suc k) (concat xss) = drop (Suc j) ys @ concat (drop (Suc i) xss)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>k<length (concat xss).\n       take k (concat xss) = concat (take i xss) @ take j ys \\<and>\n       concat xss ! k = xss ! i ! j \\<and>\n       drop (Suc k) (concat xss) =\n       drop (Suc j) ys @ concat (drop (Suc i) xss)", "using assms(1, 2)"], ["proof (prove)\nusing this:\n  i < length xss\n  xss ! i = ys\n\ngoal (1 subgoal):\n 1. \\<exists>k<length (concat xss).\n       take k (concat xss) = concat (take i xss) @ take j ys \\<and>\n       concat xss ! k = xss ! i ! j \\<and>\n       drop (Suc k) (concat xss) =\n       drop (Suc j) ys @ concat (drop (Suc i) xss)", "proof (induct xss arbitrary: i rule: List.rev_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>i < length []; [] ! i = ys\\<rbrakk>\n       \\<Longrightarrow> \\<exists>k<length (concat []).\n                            take k (concat []) =\n                            concat (take i []) @ take j ys \\<and>\n                            concat [] ! k = [] ! i ! j \\<and>\n                            drop (Suc k) (concat []) =\n                            drop (Suc j) ys @ concat (drop (Suc i) [])\n 2. \\<And>x xs i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>i < length xs; xs ! i = ys\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>k<length (concat xs).\n  take k (concat xs) = concat (take i xs) @ take j ys \\<and>\n  concat xs ! k = xs ! i ! j \\<and>\n  drop (Suc k) (concat xs) = drop (Suc j) ys @ concat (drop (Suc i) xs);\n        i < length (xs @ [x]); (xs @ [x]) ! i = ys\\<rbrakk>\n       \\<Longrightarrow> \\<exists>k<length (concat (xs @ [x])).\n                            take k (concat (xs @ [x])) =\n                            concat (take i (xs @ [x])) @ take j ys \\<and>\n                            concat (xs @ [x]) ! k =\n                            (xs @ [x]) ! i ! j \\<and>\n                            drop (Suc k) (concat (xs @ [x])) =\n                            drop (Suc j) ys @\n                            concat (drop (Suc i) (xs @ [x]))", "case (snoc xs xss)"], ["proof (state)\nthis:\n  \\<lbrakk>?i < length xss; xss ! ?i = ys\\<rbrakk>\n  \\<Longrightarrow> \\<exists>k<length (concat xss).\n                       take k (concat xss) =\n                       concat (take ?i xss) @ take j ys \\<and>\n                       concat xss ! k = xss ! ?i ! j \\<and>\n                       drop (Suc k) (concat xss) =\n                       drop (Suc j) ys @ concat (drop (Suc ?i) xss)\n  i < length (xss @ [xs])\n  (xss @ [xs]) ! i = ys\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>i < length []; [] ! i = ys\\<rbrakk>\n       \\<Longrightarrow> \\<exists>k<length (concat []).\n                            take k (concat []) =\n                            concat (take i []) @ take j ys \\<and>\n                            concat [] ! k = [] ! i ! j \\<and>\n                            drop (Suc k) (concat []) =\n                            drop (Suc j) ys @ concat (drop (Suc i) [])\n 2. \\<And>x xs i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>i < length xs; xs ! i = ys\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>k<length (concat xs).\n  take k (concat xs) = concat (take i xs) @ take j ys \\<and>\n  concat xs ! k = xs ! i ! j \\<and>\n  drop (Suc k) (concat xs) = drop (Suc j) ys @ concat (drop (Suc i) xs);\n        i < length (xs @ [x]); (xs @ [x]) ! i = ys\\<rbrakk>\n       \\<Longrightarrow> \\<exists>k<length (concat (xs @ [x])).\n                            take k (concat (xs @ [x])) =\n                            concat (take i (xs @ [x])) @ take j ys \\<and>\n                            concat (xs @ [x]) ! k =\n                            (xs @ [x]) ! i ! j \\<and>\n                            drop (Suc k) (concat (xs @ [x])) =\n                            drop (Suc j) ys @\n                            concat (drop (Suc i) (xs @ [x]))", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>?i < length xss; xss ! ?i = ys\\<rbrakk>\n  \\<Longrightarrow> \\<exists>k<length (concat xss).\n                       take k (concat xss) =\n                       concat (take ?i xss) @ take j ys \\<and>\n                       concat xss ! k = xss ! ?i ! j \\<and>\n                       drop (Suc k) (concat xss) =\n                       drop (Suc j) ys @ concat (drop (Suc ?i) xss)\n  i < length (xss @ [xs])\n  (xss @ [xs]) ! i = ys", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>?i < length xss; xss ! ?i = ys\\<rbrakk>\n  \\<Longrightarrow> \\<exists>k<length (concat xss).\n                       take k (concat xss) =\n                       concat (take ?i xss) @ take j ys \\<and>\n                       concat xss ! k = xss ! ?i ! j \\<and>\n                       drop (Suc k) (concat xss) =\n                       drop (Suc j) ys @ concat (drop (Suc ?i) xss)\n  i < length (xss @ [xs])\n  (xss @ [xs]) ! i = ys\n\ngoal (1 subgoal):\n 1. \\<exists>k<length (concat (xss @ [xs])).\n       take k (concat (xss @ [xs])) =\n       concat (take i (xss @ [xs])) @ take j ys \\<and>\n       concat (xss @ [xs]) ! k = (xss @ [xs]) ! i ! j \\<and>\n       drop (Suc k) (concat (xss @ [xs])) =\n       drop (Suc j) ys @ concat (drop (Suc i) (xss @ [xs]))", "using assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>?i < length xss; xss ! ?i = ys\\<rbrakk>\n  \\<Longrightarrow> \\<exists>k<length (concat xss).\n                       take k (concat xss) =\n                       concat (take ?i xss) @ take j ys \\<and>\n                       concat xss ! k = xss ! ?i ! j \\<and>\n                       drop (Suc k) (concat xss) =\n                       drop (Suc j) ys @ concat (drop (Suc ?i) xss)\n  i < length (xss @ [xs])\n  (xss @ [xs]) ! i = ys\n  i < length xss\n  xss ! i = ys\n  j < length ys\n  ys ! j = z\n\ngoal (1 subgoal):\n 1. \\<exists>k<length (concat (xss @ [xs])).\n       take k (concat (xss @ [xs])) =\n       concat (take i (xss @ [xs])) @ take j ys \\<and>\n       concat (xss @ [xs]) ! k = (xss @ [xs]) ! i ! j \\<and>\n       drop (Suc k) (concat (xss @ [xs])) =\n       drop (Suc j) ys @ concat (drop (Suc i) (xss @ [xs]))", "by (cases \"i < length xss\") (auto simp: nth_append)"], ["proof (state)\nthis:\n  \\<exists>k<length (concat (xss @ [xs])).\n     take k (concat (xss @ [xs])) =\n     concat (take i (xss @ [xs])) @ take j ys \\<and>\n     concat (xss @ [xs]) ! k = (xss @ [xs]) ! i ! j \\<and>\n     drop (Suc k) (concat (xss @ [xs])) =\n     drop (Suc j) ys @ concat (drop (Suc i) (xss @ [xs]))\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i < length []; [] ! i = ys\\<rbrakk>\n       \\<Longrightarrow> \\<exists>k<length (concat []).\n                            take k (concat []) =\n                            concat (take i []) @ take j ys \\<and>\n                            concat [] ! k = [] ! i ! j \\<and>\n                            drop (Suc k) (concat []) =\n                            drop (Suc j) ys @ concat (drop (Suc i) [])", "qed simp"], ["", "lemma concat_map_empty [simp]:\n  \"concat (map (\\<lambda>_. []) xs) = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. concat (map (\\<lambda>_. []) xs) = []", "by simp"], ["", "lemma map_upt_len_same_len_conv:\n  assumes \"length xs = length ys\"\n  shows \"map (\\<lambda>i. f (xs ! i)) [0 ..< length ys] = map f xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>i. f (xs ! i)) [0..<length ys] = map f xs", "unfolding assms [symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>i. f (xs ! i)) [0..<length xs] = map f xs", "by (rule map_upt_len_conv)"], ["", "lemma concat_map_concat [simp]:\n  \"concat (map concat xs) = concat (concat xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. concat (map concat xs) = concat (concat xs)", "by (induct xs) simp_all"], ["", "lemma concat_concat_map:\n  \"concat (concat (map f xs)) = concat (map (concat \\<circ> f) xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. concat (concat (map f xs)) = concat (map (concat \\<circ> f) xs)", "by (induct xs) simp_all"], ["", "lemma UN_upt_len_conv [simp]:\n  \"length xs = n \\<Longrightarrow> (\\<Union>i \\<in> {0 ..< n}. f (xs ! i)) = \\<Union>(set (map f xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length xs = n \\<Longrightarrow>\n    (\\<Union>i\\<in>{0..<n}. f (xs ! i)) = \\<Union> (set (map f xs))", "by (force simp: in_set_conv_nth)"], ["", "lemma Ball_at_Least0LessThan_conv [simp]:\n  \"length xs = n \\<Longrightarrow>\n    (\\<forall>i \\<in> {0 ..< n}. P (xs ! i)) \\<longleftrightarrow> (\\<forall>x \\<in> set xs. P x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length xs = n \\<Longrightarrow>\n    (\\<forall>i\\<in>{0..<n}. P (xs ! i)) = (\\<forall>x\\<in>set xs. P x)", "by (metis atLeast0LessThan in_set_conv_nth lessThan_iff)"], ["", "lemma sum_list_replicate_length [simp]:\n  \"sum_list (replicate (length xs) (Suc 0)) = length xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list (replicate (length xs) (Suc 0)) = length xs", "by (induct xs) simp_all"], ["", "lemma list_all2_in_set2:\n  assumes \"list_all2 P xs ys\" and \"y \\<in> set ys\"\n  obtains x where \"x \\<in> set xs\" and \"P x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>x \\<in> set xs; P x y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  list_all2 P xs ys\n  y \\<in> set ys\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>x \\<in> set xs; P x y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (induct) auto"], ["", "lemma map_eq_conv':\n  \"map f xs = map g ys \\<longleftrightarrow> length xs = length ys \\<and> (\\<forall>i < length xs. f (xs ! i) = g (ys ! i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (map f xs = map g ys) =\n    (length xs = length ys \\<and>\n     (\\<forall>i<length xs. f (xs ! i) = g (ys ! i)))", "by (auto dest: map_eq_imp_length_eq map_nth_conv simp: nth_map_conv)"], ["", "lemma list_3_cases[case_names Nil 1 2]:\n  assumes \"xs = [] \\<Longrightarrow> P\"\n      and \"\\<And>x. xs = [x] \\<Longrightarrow> P\"\n      and \"\\<And>x y ys. xs = x#y#ys \\<Longrightarrow> P\"\n  shows P"], ["proof (prove)\ngoal (1 subgoal):\n 1. P", "using assms"], ["proof (prove)\nusing this:\n  xs = [] \\<Longrightarrow> P\n  xs = [?x] \\<Longrightarrow> P\n  xs = ?x # ?y # ?ys \\<Longrightarrow> P\n\ngoal (1 subgoal):\n 1. P", "by (cases xs; cases \"tl xs\", auto)"], ["", "lemma list_4_cases[case_names Nil 1 2 3]:\n  assumes \"xs = [] \\<Longrightarrow> P\"\n      and \"\\<And>x. xs = [x] \\<Longrightarrow> P\"\n      and \"\\<And>x y. xs = [x,y] \\<Longrightarrow> P\"\n      and \"\\<And>x y z zs. xs = x # y # z # zs \\<Longrightarrow> P\"\n  shows P"], ["proof (prove)\ngoal (1 subgoal):\n 1. P", "using assms"], ["proof (prove)\nusing this:\n  xs = [] \\<Longrightarrow> P\n  xs = [?x] \\<Longrightarrow> P\n  xs = [?x, ?y] \\<Longrightarrow> P\n  xs = ?x # ?y # ?z # ?zs \\<Longrightarrow> P\n\ngoal (1 subgoal):\n 1. P", "by (cases xs; cases \"tl xs\"; cases \"tl (tl xs)\", auto)"], ["", "lemma foldr_append2 [simp]:\n  \"foldr ((@) \\<circ> f) xs (ys @ zs) = foldr ((@) \\<circ> f) xs ys @ zs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldr ((@) \\<circ> f) xs (ys @ zs) = foldr ((@) \\<circ> f) xs ys @ zs", "by (induct xs) simp_all"], ["", "lemma foldr_append2_Nil [simp]:\n  \"foldr ((@) \\<circ> f) xs [] @ zs = foldr ((@) \\<circ> f) xs zs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldr ((@) \\<circ> f) xs [] @ zs = foldr ((@) \\<circ> f) xs zs", "unfolding foldr_append2 [symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. foldr ((@) \\<circ> f) xs ([] @ zs) = foldr ((@) \\<circ> f) xs zs", "by simp"], ["", "lemma UNION_set_zip:\n  \"(\\<Union>x \\<in> set (zip [0..<length xs] (map f xs)). g x) = (\\<Union>i < length xs. g (i, f (xs ! i)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> (g ` set (zip [0..<length xs] (map f xs))) =\n    (\\<Union>i<length xs. g (i, f (xs ! i)))", "by (auto simp: set_conv_nth)"], ["", "lemma zip_fst: \"p \\<in> set (zip as bs) \\<Longrightarrow> fst p \\<in> set as\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<in> set (zip as bs) \\<Longrightarrow> fst p \\<in> set as", "by (cases p, rule set_zip_leftD, simp)"], ["", "lemma zip_snd: \"p \\<in> set (zip as bs) \\<Longrightarrow> snd p \\<in> set bs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<in> set (zip as bs) \\<Longrightarrow> snd p \\<in> set bs", "by (cases p, rule set_zip_rightD, simp)"], ["", "lemma zip_size_aux: \"size_list (size o snd) (zip ts ls) \\<le> (size_list size ls)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. size_list (size \\<circ> snd) (zip ts ls) \\<le> size_list size ls", "proof (induct ls arbitrary: ts)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ts.\n       size_list (size \\<circ> snd) (zip ts []) \\<le> size_list size []\n 2. \\<And>a ls ts.\n       (\\<And>ts.\n           size_list (size \\<circ> snd) (zip ts ls)\n           \\<le> size_list size ls) \\<Longrightarrow>\n       size_list (size \\<circ> snd) (zip ts (a # ls))\n       \\<le> size_list size (a # ls)", "case (Cons l ls ts)"], ["proof (state)\nthis:\n  size_list (size \\<circ> snd) (zip ?ts ls) \\<le> size_list size ls\n\ngoal (2 subgoals):\n 1. \\<And>ts.\n       size_list (size \\<circ> snd) (zip ts []) \\<le> size_list size []\n 2. \\<And>a ls ts.\n       (\\<And>ts.\n           size_list (size \\<circ> snd) (zip ts ls)\n           \\<le> size_list size ls) \\<Longrightarrow>\n       size_list (size \\<circ> snd) (zip ts (a # ls))\n       \\<le> size_list size (a # ls)", "thus ?case"], ["proof (prove)\nusing this:\n  size_list (size \\<circ> snd) (zip ?ts ls) \\<le> size_list size ls\n\ngoal (1 subgoal):\n 1. size_list (size \\<circ> snd) (zip ts (l # ls))\n    \\<le> size_list size (l # ls)", "by (cases ts, auto)"], ["proof (state)\nthis:\n  size_list (size \\<circ> snd) (zip ts (l # ls))\n  \\<le> size_list size (l # ls)\n\ngoal (1 subgoal):\n 1. \\<And>ts.\n       size_list (size \\<circ> snd) (zip ts []) \\<le> size_list size []", "qed auto"], ["", "text\\<open>We definie the function that remove the nth element of\na list. It uses take and drop and the soundness is therefore not\ntoo hard to prove thanks to the already existing lemmas.\\<close>"], ["", "definition remove_nth :: \"nat \\<Rightarrow> 'a list \\<Rightarrow> 'a list\" where\n  \"remove_nth n xs \\<equiv> (take n xs) @ (drop (Suc n) xs)\""], ["", "declare remove_nth_def[simp]"], ["", "lemma remove_nth_len:\n  assumes i: \"i < length xs\"\n  shows \"length xs = Suc (length (remove_nth i xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length xs = Suc (length (remove_nth i xs))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. length xs = Suc (length (remove_nth i xs))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. length xs = Suc (length (remove_nth i xs))", "unfolding arg_cong[where f = \"length\", OF id_take_nth_drop[OF i]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (take i xs @ xs ! i # drop (Suc i) xs) =\n    Suc (length (remove_nth i xs))", "unfolding remove_nth_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (take i xs @ xs ! i # drop (Suc i) xs) =\n    Suc (length (take i xs @ drop (Suc i) xs))", "by simp"], ["proof (state)\nthis:\n  length xs = Suc (length (remove_nth i xs))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma remove_nth_length :\n  assumes n_bd: \"n < length xs\"\n  shows \"length (remove_nth n xs) = length xs - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (remove_nth n xs) = length xs - 1", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. length (remove_nth n xs) = length xs - 1", "from length_take"], ["proof (chain)\npicking this:\n  length (take ?n ?xs) = min (length ?xs) ?n", "have ll:\"n < length xs \\<longrightarrow> length (take n xs) = n\""], ["proof (prove)\nusing this:\n  length (take ?n ?xs) = min (length ?xs) ?n\n\ngoal (1 subgoal):\n 1. n < length xs \\<longrightarrow> length (take n xs) = n", "by auto"], ["proof (state)\nthis:\n  n < length xs \\<longrightarrow> length (take n xs) = n\n\ngoal (1 subgoal):\n 1. length (remove_nth n xs) = length xs - 1", "from length_drop"], ["proof (chain)\npicking this:\n  length (drop ?n ?xs) = length ?xs - ?n", "have lr: \"length (drop (Suc n) xs) = length xs - (Suc n)\""], ["proof (prove)\nusing this:\n  length (drop ?n ?xs) = length ?xs - ?n\n\ngoal (1 subgoal):\n 1. length (drop (Suc n) xs) = length xs - Suc n", "by simp"], ["proof (state)\nthis:\n  length (drop (Suc n) xs) = length xs - Suc n\n\ngoal (1 subgoal):\n 1. length (remove_nth n xs) = length xs - 1", "from ll and lr and length_append and n_bd"], ["proof (chain)\npicking this:\n  n < length xs \\<longrightarrow> length (take n xs) = n\n  length (drop (Suc n) xs) = length xs - Suc n\n  length (?xs @ ?ys) = length ?xs + length ?ys\n  n < length xs", "show ?thesis"], ["proof (prove)\nusing this:\n  n < length xs \\<longrightarrow> length (take n xs) = n\n  length (drop (Suc n) xs) = length xs - Suc n\n  length (?xs @ ?ys) = length ?xs + length ?ys\n  n < length xs\n\ngoal (1 subgoal):\n 1. length (remove_nth n xs) = length xs - 1", "by auto"], ["proof (state)\nthis:\n  length (remove_nth n xs) = length xs - 1\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma remove_nth_id : \"length xs \\<le> n \\<Longrightarrow> remove_nth n xs = xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length xs \\<le> n \\<Longrightarrow> remove_nth n xs = xs", "using take_all drop_all append_Nil2"], ["proof (prove)\nusing this:\n  length ?xs \\<le> ?n \\<Longrightarrow> take ?n ?xs = ?xs\n  length ?xs \\<le> ?n \\<Longrightarrow> drop ?n ?xs = []\n  ?xs @ [] = ?xs\n\ngoal (1 subgoal):\n 1. length xs \\<le> n \\<Longrightarrow> remove_nth n xs = xs", "by simp"], ["", "lemma remove_nth_sound_l :\n  assumes p_ub: \"p < n\"\n  shows \"(remove_nth n xs) ! p = xs ! p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. remove_nth n xs ! p = xs ! p", "proof (cases \"n < length xs\")"], ["proof (state)\ngoal (2 subgoals):\n 1. n < length xs \\<Longrightarrow> remove_nth n xs ! p = xs ! p\n 2. \\<not> n < length xs \\<Longrightarrow> remove_nth n xs ! p = xs ! p", "case True"], ["proof (state)\nthis:\n  n < length xs\n\ngoal (2 subgoals):\n 1. n < length xs \\<Longrightarrow> remove_nth n xs ! p = xs ! p\n 2. \\<not> n < length xs \\<Longrightarrow> remove_nth n xs ! p = xs ! p", "from length_take and True"], ["proof (chain)\npicking this:\n  length (take ?n ?xs) = min (length ?xs) ?n\n  n < length xs", "have ltk: \"length (take n xs) = n\""], ["proof (prove)\nusing this:\n  length (take ?n ?xs) = min (length ?xs) ?n\n  n < length xs\n\ngoal (1 subgoal):\n 1. length (take n xs) = n", "by simp"], ["proof (state)\nthis:\n  length (take n xs) = n\n\ngoal (2 subgoals):\n 1. n < length xs \\<Longrightarrow> remove_nth n xs ! p = xs ! p\n 2. \\<not> n < length xs \\<Longrightarrow> remove_nth n xs ! p = xs ! p", "{"], ["proof (state)\nthis:\n  length (take n xs) = n\n\ngoal (2 subgoals):\n 1. n < length xs \\<Longrightarrow> remove_nth n xs ! p = xs ! p\n 2. \\<not> n < length xs \\<Longrightarrow> remove_nth n xs ! p = xs ! p", "assume pltn: \"p < n\""], ["proof (state)\nthis:\n  p < n\n\ngoal (2 subgoals):\n 1. n < length xs \\<Longrightarrow> remove_nth n xs ! p = xs ! p\n 2. \\<not> n < length xs \\<Longrightarrow> remove_nth n xs ! p = xs ! p", "from this and ltk"], ["proof (chain)\npicking this:\n  p < n\n  length (take n xs) = n", "have plttk: \"p < length (take n xs)\""], ["proof (prove)\nusing this:\n  p < n\n  length (take n xs) = n\n\ngoal (1 subgoal):\n 1. p < length (take n xs)", "by simp"], ["proof (state)\nthis:\n  p < length (take n xs)\n\ngoal (2 subgoals):\n 1. n < length xs \\<Longrightarrow> remove_nth n xs ! p = xs ! p\n 2. \\<not> n < length xs \\<Longrightarrow> remove_nth n xs ! p = xs ! p", "with nth_append[of \"take n xs\" _ p]"], ["proof (chain)\npicking this:\n  (take n xs @ ?ys) ! p =\n  (if p < length (take n xs) then take n xs ! p\n   else ?ys ! (p - length (take n xs)))\n  p < length (take n xs)", "have \"((take n xs) @ (drop (Suc n) xs)) ! p = take n xs ! p\""], ["proof (prove)\nusing this:\n  (take n xs @ ?ys) ! p =\n  (if p < length (take n xs) then take n xs ! p\n   else ?ys ! (p - length (take n xs)))\n  p < length (take n xs)\n\ngoal (1 subgoal):\n 1. (take n xs @ drop (Suc n) xs) ! p = take n xs ! p", "by auto"], ["proof (state)\nthis:\n  (take n xs @ drop (Suc n) xs) ! p = take n xs ! p\n\ngoal (2 subgoals):\n 1. n < length xs \\<Longrightarrow> remove_nth n xs ! p = xs ! p\n 2. \\<not> n < length xs \\<Longrightarrow> remove_nth n xs ! p = xs ! p", "with pltn and nth_take"], ["proof (chain)\npicking this:\n  p < n\n  ?i < ?n \\<Longrightarrow> take ?n ?xs ! ?i = ?xs ! ?i\n  (take n xs @ drop (Suc n) xs) ! p = take n xs ! p", "have \"((take n xs) @ (drop (Suc n) xs)) ! p =  xs ! p\""], ["proof (prove)\nusing this:\n  p < n\n  ?i < ?n \\<Longrightarrow> take ?n ?xs ! ?i = ?xs ! ?i\n  (take n xs @ drop (Suc n) xs) ! p = take n xs ! p\n\ngoal (1 subgoal):\n 1. (take n xs @ drop (Suc n) xs) ! p = xs ! p", "by simp"], ["proof (state)\nthis:\n  (take n xs @ drop (Suc n) xs) ! p = xs ! p\n\ngoal (2 subgoals):\n 1. n < length xs \\<Longrightarrow> remove_nth n xs ! p = xs ! p\n 2. \\<not> n < length xs \\<Longrightarrow> remove_nth n xs ! p = xs ! p", "}"], ["proof (state)\nthis:\n  p < n \\<Longrightarrow> (take n xs @ drop (Suc n) xs) ! p = xs ! p\n\ngoal (2 subgoals):\n 1. n < length xs \\<Longrightarrow> remove_nth n xs ! p = xs ! p\n 2. \\<not> n < length xs \\<Longrightarrow> remove_nth n xs ! p = xs ! p", "from this and ltk and p_ub"], ["proof (chain)\npicking this:\n  p < n \\<Longrightarrow> (take n xs @ drop (Suc n) xs) ! p = xs ! p\n  length (take n xs) = n\n  p < n", "show ?thesis"], ["proof (prove)\nusing this:\n  p < n \\<Longrightarrow> (take n xs @ drop (Suc n) xs) ! p = xs ! p\n  length (take n xs) = n\n  p < n\n\ngoal (1 subgoal):\n 1. remove_nth n xs ! p = xs ! p", "by simp"], ["proof (state)\nthis:\n  remove_nth n xs ! p = xs ! p\n\ngoal (1 subgoal):\n 1. \\<not> n < length xs \\<Longrightarrow> remove_nth n xs ! p = xs ! p", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> n < length xs \\<Longrightarrow> remove_nth n xs ! p = xs ! p", "case False"], ["proof (state)\nthis:\n  \\<not> n < length xs\n\ngoal (1 subgoal):\n 1. \\<not> n < length xs \\<Longrightarrow> remove_nth n xs ! p = xs ! p", "hence \"length xs \\<le> n\""], ["proof (prove)\nusing this:\n  \\<not> n < length xs\n\ngoal (1 subgoal):\n 1. length xs \\<le> n", "by arith"], ["proof (state)\nthis:\n  length xs \\<le> n\n\ngoal (1 subgoal):\n 1. \\<not> n < length xs \\<Longrightarrow> remove_nth n xs ! p = xs ! p", "with remove_nth_id"], ["proof (chain)\npicking this:\n  length ?xs \\<le> ?n \\<Longrightarrow> remove_nth ?n ?xs = ?xs\n  length xs \\<le> n", "show ?thesis"], ["proof (prove)\nusing this:\n  length ?xs \\<le> ?n \\<Longrightarrow> remove_nth ?n ?xs = ?xs\n  length xs \\<le> n\n\ngoal (1 subgoal):\n 1. remove_nth n xs ! p = xs ! p", "by force"], ["proof (state)\nthis:\n  remove_nth n xs ! p = xs ! p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma remove_nth_sound_r :\n  assumes \"n \\<le> p\" and \"p < length xs\"\n  shows \"(remove_nth n xs) ! p = xs ! (Suc p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. remove_nth n xs ! p = xs ! Suc p", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. remove_nth n xs ! p = xs ! Suc p", "from \\<open>n \\<le> p\\<close> and \\<open>p < length xs\\<close>"], ["proof (chain)\npicking this:\n  n \\<le> p\n  p < length xs", "have n_ub: \"n < length xs\""], ["proof (prove)\nusing this:\n  n \\<le> p\n  p < length xs\n\ngoal (1 subgoal):\n 1. n < length xs", "by arith"], ["proof (state)\nthis:\n  n < length xs\n\ngoal (1 subgoal):\n 1. remove_nth n xs ! p = xs ! Suc p", "from length_take and n_ub"], ["proof (chain)\npicking this:\n  length (take ?n ?xs) = min (length ?xs) ?n\n  n < length xs", "have ltk: \"length (take n xs) = n\""], ["proof (prove)\nusing this:\n  length (take ?n ?xs) = min (length ?xs) ?n\n  n < length xs\n\ngoal (1 subgoal):\n 1. length (take n xs) = n", "by simp"], ["proof (state)\nthis:\n  length (take n xs) = n\n\ngoal (1 subgoal):\n 1. remove_nth n xs ! p = xs ! Suc p", "from \\<open>n \\<le> p\\<close> and ltk and nth_append[of \"take n xs\" _ p]"], ["proof (chain)\npicking this:\n  n \\<le> p\n  length (take n xs) = n\n  (take n xs @ ?ys) ! p =\n  (if p < length (take n xs) then take n xs ! p\n   else ?ys ! (p - length (take n xs)))", "have Hrew: \"((take n xs) @ (drop (Suc n) xs)) ! p = drop (Suc n) xs ! (p - n)\""], ["proof (prove)\nusing this:\n  n \\<le> p\n  length (take n xs) = n\n  (take n xs @ ?ys) ! p =\n  (if p < length (take n xs) then take n xs ! p\n   else ?ys ! (p - length (take n xs)))\n\ngoal (1 subgoal):\n 1. (take n xs @ drop (Suc n) xs) ! p = drop (Suc n) xs ! (p - n)", "by auto"], ["proof (state)\nthis:\n  (take n xs @ drop (Suc n) xs) ! p = drop (Suc n) xs ! (p - n)\n\ngoal (1 subgoal):\n 1. remove_nth n xs ! p = xs ! Suc p", "from \\<open>n \\<le> p\\<close>"], ["proof (chain)\npicking this:\n  n \\<le> p", "have idx: \"Suc n + (p - n) = Suc p\""], ["proof (prove)\nusing this:\n  n \\<le> p\n\ngoal (1 subgoal):\n 1. Suc n + (p - n) = Suc p", "by arith"], ["proof (state)\nthis:\n  Suc n + (p - n) = Suc p\n\ngoal (1 subgoal):\n 1. remove_nth n xs ! p = xs ! Suc p", "from \\<open>p < length xs\\<close>"], ["proof (chain)\npicking this:\n  p < length xs", "have Sp_ub: \"Suc p \\<le> length xs\""], ["proof (prove)\nusing this:\n  p < length xs\n\ngoal (1 subgoal):\n 1. Suc p \\<le> length xs", "by arith"], ["proof (state)\nthis:\n  Suc p \\<le> length xs\n\ngoal (1 subgoal):\n 1. remove_nth n xs ! p = xs ! Suc p", "from idx and Sp_ub and nth_drop"], ["proof (chain)\npicking this:\n  Suc n + (p - n) = Suc p\n  Suc p \\<le> length xs\n  ?n \\<le> length ?xs \\<Longrightarrow> drop ?n ?xs ! ?i = ?xs ! (?n + ?i)", "have Hrew': \"drop (Suc n) xs ! (p - n) = xs ! (Suc p)\""], ["proof (prove)\nusing this:\n  Suc n + (p - n) = Suc p\n  Suc p \\<le> length xs\n  ?n \\<le> length ?xs \\<Longrightarrow> drop ?n ?xs ! ?i = ?xs ! (?n + ?i)\n\ngoal (1 subgoal):\n 1. drop (Suc n) xs ! (p - n) = xs ! Suc p", "by simp"], ["proof (state)\nthis:\n  drop (Suc n) xs ! (p - n) = xs ! Suc p\n\ngoal (1 subgoal):\n 1. remove_nth n xs ! p = xs ! Suc p", "from Hrew and Hrew'"], ["proof (chain)\npicking this:\n  (take n xs @ drop (Suc n) xs) ! p = drop (Suc n) xs ! (p - n)\n  drop (Suc n) xs ! (p - n) = xs ! Suc p", "show ?thesis"], ["proof (prove)\nusing this:\n  (take n xs @ drop (Suc n) xs) ! p = drop (Suc n) xs ! (p - n)\n  drop (Suc n) xs ! (p - n) = xs ! Suc p\n\ngoal (1 subgoal):\n 1. remove_nth n xs ! p = xs ! Suc p", "by simp"], ["proof (state)\nthis:\n  remove_nth n xs ! p = xs ! Suc p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma nth_remove_nth_conv:\n  assumes \"i < length (remove_nth n xs)\"\n  shows \"remove_nth n xs ! i = xs ! (if i < n then i else Suc i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. remove_nth n xs ! i = xs ! (if i < n then i else Suc i)", "using assms remove_nth_sound_l remove_nth_sound_r[of n i xs]"], ["proof (prove)\nusing this:\n  i < length (remove_nth n xs)\n  ?p < ?n \\<Longrightarrow> remove_nth ?n ?xs ! ?p = ?xs ! ?p\n  \\<lbrakk>n \\<le> i; i < length xs\\<rbrakk>\n  \\<Longrightarrow> remove_nth n xs ! i = xs ! Suc i\n\ngoal (1 subgoal):\n 1. remove_nth n xs ! i = xs ! (if i < n then i else Suc i)", "by auto"], ["", "lemma remove_nth_P_compat :\n  assumes aslbs: \"length as = length bs\"\n  and Pab: \"\\<forall>i. i < length as \\<longrightarrow> P (as ! i) (bs ! i)\"\n  shows \"\\<forall>i. i < length (remove_nth p as) \\<longrightarrow> P (remove_nth p as ! i) (remove_nth p bs ! i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i<length (remove_nth p as).\n       P (remove_nth p as ! i) (remove_nth p bs ! i)", "proof (cases \"p < length as\")"], ["proof (state)\ngoal (2 subgoals):\n 1. p < length as \\<Longrightarrow>\n    \\<forall>i<length (remove_nth p as).\n       P (remove_nth p as ! i) (remove_nth p bs ! i)\n 2. \\<not> p < length as \\<Longrightarrow>\n    \\<forall>i<length (remove_nth p as).\n       P (remove_nth p as ! i) (remove_nth p bs ! i)", "case True"], ["proof (state)\nthis:\n  p < length as\n\ngoal (2 subgoals):\n 1. p < length as \\<Longrightarrow>\n    \\<forall>i<length (remove_nth p as).\n       P (remove_nth p as ! i) (remove_nth p bs ! i)\n 2. \\<not> p < length as \\<Longrightarrow>\n    \\<forall>i<length (remove_nth p as).\n       P (remove_nth p as ! i) (remove_nth p bs ! i)", "hence p_ub: \"p < length as\""], ["proof (prove)\nusing this:\n  p < length as\n\ngoal (1 subgoal):\n 1. p < length as", "by assumption"], ["proof (state)\nthis:\n  p < length as\n\ngoal (2 subgoals):\n 1. p < length as \\<Longrightarrow>\n    \\<forall>i<length (remove_nth p as).\n       P (remove_nth p as ! i) (remove_nth p bs ! i)\n 2. \\<not> p < length as \\<Longrightarrow>\n    \\<forall>i<length (remove_nth p as).\n       P (remove_nth p as ! i) (remove_nth p bs ! i)", "with remove_nth_length"], ["proof (chain)\npicking this:\n  ?n < length ?xs \\<Longrightarrow>\n  length (remove_nth ?n ?xs) = length ?xs - 1\n  p < length as", "have lr_ub: \"length (remove_nth p as) = length as - 1\""], ["proof (prove)\nusing this:\n  ?n < length ?xs \\<Longrightarrow>\n  length (remove_nth ?n ?xs) = length ?xs - 1\n  p < length as\n\ngoal (1 subgoal):\n 1. length (remove_nth p as) = length as - 1", "by auto"], ["proof (state)\nthis:\n  length (remove_nth p as) = length as - 1\n\ngoal (2 subgoals):\n 1. p < length as \\<Longrightarrow>\n    \\<forall>i<length (remove_nth p as).\n       P (remove_nth p as ! i) (remove_nth p bs ! i)\n 2. \\<not> p < length as \\<Longrightarrow>\n    \\<forall>i<length (remove_nth p as).\n       P (remove_nth p as ! i) (remove_nth p bs ! i)", "{"], ["proof (state)\nthis:\n  length (remove_nth p as) = length as - 1\n\ngoal (2 subgoals):\n 1. p < length as \\<Longrightarrow>\n    \\<forall>i<length (remove_nth p as).\n       P (remove_nth p as ! i) (remove_nth p bs ! i)\n 2. \\<not> p < length as \\<Longrightarrow>\n    \\<forall>i<length (remove_nth p as).\n       P (remove_nth p as ! i) (remove_nth p bs ! i)", "fix i"], ["proof (state)\ngoal (2 subgoals):\n 1. p < length as \\<Longrightarrow>\n    \\<forall>i<length (remove_nth p as).\n       P (remove_nth p as ! i) (remove_nth p bs ! i)\n 2. \\<not> p < length as \\<Longrightarrow>\n    \\<forall>i<length (remove_nth p as).\n       P (remove_nth p as ! i) (remove_nth p bs ! i)", "assume i_ub: \"i < length (remove_nth p as)\""], ["proof (state)\nthis:\n  i < length (remove_nth p as)\n\ngoal (2 subgoals):\n 1. p < length as \\<Longrightarrow>\n    \\<forall>i<length (remove_nth p as).\n       P (remove_nth p as ! i) (remove_nth p bs ! i)\n 2. \\<not> p < length as \\<Longrightarrow>\n    \\<forall>i<length (remove_nth p as).\n       P (remove_nth p as ! i) (remove_nth p bs ! i)", "have \"P (remove_nth p as ! i) (remove_nth p bs ! i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P (remove_nth p as ! i) (remove_nth p bs ! i)", "proof (cases \"i < p\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i < p \\<Longrightarrow> P (remove_nth p as ! i) (remove_nth p bs ! i)\n 2. \\<not> i < p \\<Longrightarrow>\n    P (remove_nth p as ! i) (remove_nth p bs ! i)", "case True"], ["proof (state)\nthis:\n  i < p\n\ngoal (2 subgoals):\n 1. i < p \\<Longrightarrow> P (remove_nth p as ! i) (remove_nth p bs ! i)\n 2. \\<not> i < p \\<Longrightarrow>\n    P (remove_nth p as ! i) (remove_nth p bs ! i)", "from i_ub and lr_ub"], ["proof (chain)\npicking this:\n  i < length (remove_nth p as)\n  length (remove_nth p as) = length as - 1", "have i_ub2: \"i < length as\""], ["proof (prove)\nusing this:\n  i < length (remove_nth p as)\n  length (remove_nth p as) = length as - 1\n\ngoal (1 subgoal):\n 1. i < length as", "by arith"], ["proof (state)\nthis:\n  i < length as\n\ngoal (2 subgoals):\n 1. i < p \\<Longrightarrow> P (remove_nth p as ! i) (remove_nth p bs ! i)\n 2. \\<not> i < p \\<Longrightarrow>\n    P (remove_nth p as ! i) (remove_nth p bs ! i)", "from i_ub2 and Pab"], ["proof (chain)\npicking this:\n  i < length as\n  \\<forall>i<length as. P (as ! i) (bs ! i)", "have P: \"P (as ! i) (bs ! i)\""], ["proof (prove)\nusing this:\n  i < length as\n  \\<forall>i<length as. P (as ! i) (bs ! i)\n\ngoal (1 subgoal):\n 1. P (as ! i) (bs ! i)", "by blast"], ["proof (state)\nthis:\n  P (as ! i) (bs ! i)\n\ngoal (2 subgoals):\n 1. i < p \\<Longrightarrow> P (remove_nth p as ! i) (remove_nth p bs ! i)\n 2. \\<not> i < p \\<Longrightarrow>\n    P (remove_nth p as ! i) (remove_nth p bs ! i)", "from P and remove_nth_sound_l[OF True, of as] and remove_nth_sound_l[OF True, of bs]"], ["proof (chain)\npicking this:\n  P (as ! i) (bs ! i)\n  remove_nth p as ! i = as ! i\n  remove_nth p bs ! i = bs ! i", "show ?thesis"], ["proof (prove)\nusing this:\n  P (as ! i) (bs ! i)\n  remove_nth p as ! i = as ! i\n  remove_nth p bs ! i = bs ! i\n\ngoal (1 subgoal):\n 1. P (remove_nth p as ! i) (remove_nth p bs ! i)", "by simp"], ["proof (state)\nthis:\n  P (remove_nth p as ! i) (remove_nth p bs ! i)\n\ngoal (1 subgoal):\n 1. \\<not> i < p \\<Longrightarrow>\n    P (remove_nth p as ! i) (remove_nth p bs ! i)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> i < p \\<Longrightarrow>\n    P (remove_nth p as ! i) (remove_nth p bs ! i)", "case False"], ["proof (state)\nthis:\n  \\<not> i < p\n\ngoal (1 subgoal):\n 1. \\<not> i < p \\<Longrightarrow>\n    P (remove_nth p as ! i) (remove_nth p bs ! i)", "hence p_ub2: \"p \\<le> i\""], ["proof (prove)\nusing this:\n  \\<not> i < p\n\ngoal (1 subgoal):\n 1. p \\<le> i", "by arith"], ["proof (state)\nthis:\n  p \\<le> i\n\ngoal (1 subgoal):\n 1. \\<not> i < p \\<Longrightarrow>\n    P (remove_nth p as ! i) (remove_nth p bs ! i)", "from i_ub and lr_ub"], ["proof (chain)\npicking this:\n  i < length (remove_nth p as)\n  length (remove_nth p as) = length as - 1", "have Si_ub: \"Suc i < length as\""], ["proof (prove)\nusing this:\n  i < length (remove_nth p as)\n  length (remove_nth p as) = length as - 1\n\ngoal (1 subgoal):\n 1. Suc i < length as", "by arith"], ["proof (state)\nthis:\n  Suc i < length as\n\ngoal (1 subgoal):\n 1. \\<not> i < p \\<Longrightarrow>\n    P (remove_nth p as ! i) (remove_nth p bs ! i)", "with Pab"], ["proof (chain)\npicking this:\n  \\<forall>i<length as. P (as ! i) (bs ! i)\n  Suc i < length as", "have P: \"P (as ! Suc i) (bs ! Suc i)\""], ["proof (prove)\nusing this:\n  \\<forall>i<length as. P (as ! i) (bs ! i)\n  Suc i < length as\n\ngoal (1 subgoal):\n 1. P (as ! Suc i) (bs ! Suc i)", "by blast"], ["proof (state)\nthis:\n  P (as ! Suc i) (bs ! Suc i)\n\ngoal (1 subgoal):\n 1. \\<not> i < p \\<Longrightarrow>\n    P (remove_nth p as ! i) (remove_nth p bs ! i)", "from i_ub and lr_ub"], ["proof (chain)\npicking this:\n  i < length (remove_nth p as)\n  length (remove_nth p as) = length as - 1", "have i_uba: \"i < length as\""], ["proof (prove)\nusing this:\n  i < length (remove_nth p as)\n  length (remove_nth p as) = length as - 1\n\ngoal (1 subgoal):\n 1. i < length as", "by arith"], ["proof (state)\nthis:\n  i < length as\n\ngoal (1 subgoal):\n 1. \\<not> i < p \\<Longrightarrow>\n    P (remove_nth p as ! i) (remove_nth p bs ! i)", "from i_uba and aslbs"], ["proof (chain)\npicking this:\n  i < length as\n  length as = length bs", "have i_ubb: \"i < length bs\""], ["proof (prove)\nusing this:\n  i < length as\n  length as = length bs\n\ngoal (1 subgoal):\n 1. i < length bs", "by simp"], ["proof (state)\nthis:\n  i < length bs\n\ngoal (1 subgoal):\n 1. \\<not> i < p \\<Longrightarrow>\n    P (remove_nth p as ! i) (remove_nth p bs ! i)", "from P and p_ub and aslbs and remove_nth_sound_r[OF p_ub2 i_uba]\n       and remove_nth_sound_r[OF p_ub2 i_ubb]"], ["proof (chain)\npicking this:\n  P (as ! Suc i) (bs ! Suc i)\n  p < length as\n  length as = length bs\n  remove_nth p as ! i = as ! Suc i\n  remove_nth p bs ! i = bs ! Suc i", "show ?thesis"], ["proof (prove)\nusing this:\n  P (as ! Suc i) (bs ! Suc i)\n  p < length as\n  length as = length bs\n  remove_nth p as ! i = as ! Suc i\n  remove_nth p bs ! i = bs ! Suc i\n\ngoal (1 subgoal):\n 1. P (remove_nth p as ! i) (remove_nth p bs ! i)", "by auto"], ["proof (state)\nthis:\n  P (remove_nth p as ! i) (remove_nth p bs ! i)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  P (remove_nth p as ! i) (remove_nth p bs ! i)\n\ngoal (2 subgoals):\n 1. p < length as \\<Longrightarrow>\n    \\<forall>i<length (remove_nth p as).\n       P (remove_nth p as ! i) (remove_nth p bs ! i)\n 2. \\<not> p < length as \\<Longrightarrow>\n    \\<forall>i<length (remove_nth p as).\n       P (remove_nth p as ! i) (remove_nth p bs ! i)", "}"], ["proof (state)\nthis:\n  ?i2 < length (remove_nth p as) \\<Longrightarrow>\n  P (remove_nth p as ! ?i2) (remove_nth p bs ! ?i2)\n\ngoal (2 subgoals):\n 1. p < length as \\<Longrightarrow>\n    \\<forall>i<length (remove_nth p as).\n       P (remove_nth p as ! i) (remove_nth p bs ! i)\n 2. \\<not> p < length as \\<Longrightarrow>\n    \\<forall>i<length (remove_nth p as).\n       P (remove_nth p as ! i) (remove_nth p bs ! i)", "thus ?thesis"], ["proof (prove)\nusing this:\n  ?i2 < length (remove_nth p as) \\<Longrightarrow>\n  P (remove_nth p as ! ?i2) (remove_nth p bs ! ?i2)\n\ngoal (1 subgoal):\n 1. \\<forall>i<length (remove_nth p as).\n       P (remove_nth p as ! i) (remove_nth p bs ! i)", "by simp"], ["proof (state)\nthis:\n  \\<forall>i<length (remove_nth p as).\n     P (remove_nth p as ! i) (remove_nth p bs ! i)\n\ngoal (1 subgoal):\n 1. \\<not> p < length as \\<Longrightarrow>\n    \\<forall>i<length (remove_nth p as).\n       P (remove_nth p as ! i) (remove_nth p bs ! i)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> p < length as \\<Longrightarrow>\n    \\<forall>i<length (remove_nth p as).\n       P (remove_nth p as ! i) (remove_nth p bs ! i)", "case False"], ["proof (state)\nthis:\n  \\<not> p < length as\n\ngoal (1 subgoal):\n 1. \\<not> p < length as \\<Longrightarrow>\n    \\<forall>i<length (remove_nth p as).\n       P (remove_nth p as ! i) (remove_nth p bs ! i)", "hence p_lba: \"length as \\<le> p\""], ["proof (prove)\nusing this:\n  \\<not> p < length as\n\ngoal (1 subgoal):\n 1. length as \\<le> p", "by arith"], ["proof (state)\nthis:\n  length as \\<le> p\n\ngoal (1 subgoal):\n 1. \\<not> p < length as \\<Longrightarrow>\n    \\<forall>i<length (remove_nth p as).\n       P (remove_nth p as ! i) (remove_nth p bs ! i)", "with aslbs"], ["proof (chain)\npicking this:\n  length as = length bs\n  length as \\<le> p", "have p_lbb: \"length bs \\<le> p\""], ["proof (prove)\nusing this:\n  length as = length bs\n  length as \\<le> p\n\ngoal (1 subgoal):\n 1. length bs \\<le> p", "by simp"], ["proof (state)\nthis:\n  length bs \\<le> p\n\ngoal (1 subgoal):\n 1. \\<not> p < length as \\<Longrightarrow>\n    \\<forall>i<length (remove_nth p as).\n       P (remove_nth p as ! i) (remove_nth p bs ! i)", "from remove_nth_id[OF p_lba] and remove_nth_id[OF p_lbb] and Pab"], ["proof (chain)\npicking this:\n  remove_nth p as = as\n  remove_nth p bs = bs\n  \\<forall>i<length as. P (as ! i) (bs ! i)", "show ?thesis"], ["proof (prove)\nusing this:\n  remove_nth p as = as\n  remove_nth p bs = bs\n  \\<forall>i<length as. P (as ! i) (bs ! i)\n\ngoal (1 subgoal):\n 1. \\<forall>i<length (remove_nth p as).\n       P (remove_nth p as ! i) (remove_nth p bs ! i)", "by simp"], ["proof (state)\nthis:\n  \\<forall>i<length (remove_nth p as).\n     P (remove_nth p as ! i) (remove_nth p bs ! i)\n\ngoal:\nNo subgoals!", "qed"], ["", "declare remove_nth_def[simp del]"], ["", "definition adjust_idx :: \"nat \\<Rightarrow> nat \\<Rightarrow> nat\" where\n  \"adjust_idx i j \\<equiv> (if j < i then j else (Suc j))\""], ["", "definition adjust_idx_rev :: \"nat \\<Rightarrow> nat \\<Rightarrow> nat\" where\n  \"adjust_idx_rev i j \\<equiv> (if j < i then j else j - Suc 0)\""], ["", "lemma adjust_idx_rev1: \"adjust_idx_rev i (adjust_idx i j) = j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adjust_idx_rev i (adjust_idx i j) = j", "unfolding adjust_idx_def adjust_idx_rev_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if (if j < i then j else Suc j) < i then if j < i then j else Suc j\n     else (if j < i then j else Suc j) - Suc 0) =\n    j", "by (cases \"i < j\", auto)"], ["", "lemma adjust_idx_rev2:\n  assumes \"j \\<noteq> i\" shows \"adjust_idx i (adjust_idx_rev i j) = j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adjust_idx i (adjust_idx_rev i j) = j", "unfolding adjust_idx_def adjust_idx_rev_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if (if j < i then j else j - Suc 0) < i\n     then if j < i then j else j - Suc 0\n     else Suc (if j < i then j else j - Suc 0)) =\n    j", "using assms"], ["proof (prove)\nusing this:\n  j \\<noteq> i\n\ngoal (1 subgoal):\n 1. (if (if j < i then j else j - Suc 0) < i\n     then if j < i then j else j - Suc 0\n     else Suc (if j < i then j else j - Suc 0)) =\n    j", "by (cases \"i < j\", auto)"], ["", "lemma adjust_idx_i:\n  \"adjust_idx i j \\<noteq> i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adjust_idx i j \\<noteq> i", "unfolding adjust_idx_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if j < i then j else Suc j) \\<noteq> i", "by (cases \"j < i\", auto)"], ["", "lemma adjust_idx_nth:\n  assumes i: \"i < length xs\"\n  shows \"remove_nth i xs ! j = xs ! adjust_idx i j\" (is \"?l = ?r\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. remove_nth i xs ! j = xs ! adjust_idx i j", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. remove_nth i xs ! j = xs ! adjust_idx i j", "let ?j = \"adjust_idx i j\""], ["proof (state)\ngoal (1 subgoal):\n 1. remove_nth i xs ! j = xs ! adjust_idx i j", "from i"], ["proof (chain)\npicking this:\n  i < length xs", "have ltake: \"length (take i xs) = i\""], ["proof (prove)\nusing this:\n  i < length xs\n\ngoal (1 subgoal):\n 1. length (take i xs) = i", "by simp"], ["proof (state)\nthis:\n  length (take i xs) = i\n\ngoal (1 subgoal):\n 1. remove_nth i xs ! j = xs ! adjust_idx i j", "note nth_xs = arg_cong[where f = \"\\<lambda> xs. xs ! ?j\", OF id_take_nth_drop[OF i], unfolded nth_append ltake]"], ["proof (state)\nthis:\n  xs ! adjust_idx i j =\n  (if adjust_idx i j < i then take i xs ! adjust_idx i j\n   else (xs ! i # drop (Suc i) xs) ! (adjust_idx i j - i))\n\ngoal (1 subgoal):\n 1. remove_nth i xs ! j = xs ! adjust_idx i j", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. remove_nth i xs ! j = xs ! adjust_idx i j", "proof (cases \"j < i\")"], ["proof (state)\ngoal (2 subgoals):\n 1. j < i \\<Longrightarrow> remove_nth i xs ! j = xs ! adjust_idx i j\n 2. \\<not> j < i \\<Longrightarrow> remove_nth i xs ! j = xs ! adjust_idx i j", "case True"], ["proof (state)\nthis:\n  j < i\n\ngoal (2 subgoals):\n 1. j < i \\<Longrightarrow> remove_nth i xs ! j = xs ! adjust_idx i j\n 2. \\<not> j < i \\<Longrightarrow> remove_nth i xs ! j = xs ! adjust_idx i j", "hence j: \"?j = j\""], ["proof (prove)\nusing this:\n  j < i\n\ngoal (1 subgoal):\n 1. adjust_idx i j = j", "unfolding adjust_idx_def"], ["proof (prove)\nusing this:\n  j < i\n\ngoal (1 subgoal):\n 1. (if j < i then j else Suc j) = j", "by simp"], ["proof (state)\nthis:\n  adjust_idx i j = j\n\ngoal (2 subgoals):\n 1. j < i \\<Longrightarrow> remove_nth i xs ! j = xs ! adjust_idx i j\n 2. \\<not> j < i \\<Longrightarrow> remove_nth i xs ! j = xs ! adjust_idx i j", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. remove_nth i xs ! j = xs ! adjust_idx i j", "unfolding nth_xs"], ["proof (prove)\ngoal (1 subgoal):\n 1. remove_nth i xs ! j =\n    (if adjust_idx i j < i then take i xs ! adjust_idx i j\n     else (xs ! i # drop (Suc i) xs) ! (adjust_idx i j - i))", "unfolding j remove_nth_def nth_append ltake"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if j < i then take i xs ! j else drop (Suc i) xs ! (j - i)) =\n    (if j < i then take i xs ! j else (xs ! i # drop (Suc i) xs) ! (j - i))", "using True"], ["proof (prove)\nusing this:\n  j < i\n\ngoal (1 subgoal):\n 1. (if j < i then take i xs ! j else drop (Suc i) xs ! (j - i)) =\n    (if j < i then take i xs ! j else (xs ! i # drop (Suc i) xs) ! (j - i))", "by simp"], ["proof (state)\nthis:\n  remove_nth i xs ! j = xs ! adjust_idx i j\n\ngoal (1 subgoal):\n 1. \\<not> j < i \\<Longrightarrow> remove_nth i xs ! j = xs ! adjust_idx i j", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> j < i \\<Longrightarrow> remove_nth i xs ! j = xs ! adjust_idx i j", "case False"], ["proof (state)\nthis:\n  \\<not> j < i\n\ngoal (1 subgoal):\n 1. \\<not> j < i \\<Longrightarrow> remove_nth i xs ! j = xs ! adjust_idx i j", "hence j: \"?j = Suc j\""], ["proof (prove)\nusing this:\n  \\<not> j < i\n\ngoal (1 subgoal):\n 1. adjust_idx i j = Suc j", "unfolding adjust_idx_def"], ["proof (prove)\nusing this:\n  \\<not> j < i\n\ngoal (1 subgoal):\n 1. (if j < i then j else Suc j) = Suc j", "by simp"], ["proof (state)\nthis:\n  adjust_idx i j = Suc j\n\ngoal (1 subgoal):\n 1. \\<not> j < i \\<Longrightarrow> remove_nth i xs ! j = xs ! adjust_idx i j", "from i"], ["proof (chain)\npicking this:\n  i < length xs", "have lxs: \"min (length xs) i = i\""], ["proof (prove)\nusing this:\n  i < length xs\n\ngoal (1 subgoal):\n 1. min (length xs) i = i", "by simp"], ["proof (state)\nthis:\n  min (length xs) i = i\n\ngoal (1 subgoal):\n 1. \\<not> j < i \\<Longrightarrow> remove_nth i xs ! j = xs ! adjust_idx i j", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. remove_nth i xs ! j = xs ! adjust_idx i j", "unfolding nth_xs"], ["proof (prove)\ngoal (1 subgoal):\n 1. remove_nth i xs ! j =\n    (if adjust_idx i j < i then take i xs ! adjust_idx i j\n     else (xs ! i # drop (Suc i) xs) ! (adjust_idx i j - i))", "unfolding j remove_nth_def nth_append"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if j < length (take i xs) then take i xs ! j\n     else drop (Suc i) xs ! (j - length (take i xs))) =\n    (if Suc j < i then take i xs ! Suc j\n     else (xs ! i # drop (Suc i) xs) ! (Suc j - i))", "using False"], ["proof (prove)\nusing this:\n  \\<not> j < i\n\ngoal (1 subgoal):\n 1. (if j < length (take i xs) then take i xs ! j\n     else drop (Suc i) xs ! (j - length (take i xs))) =\n    (if Suc j < i then take i xs ! Suc j\n     else (xs ! i # drop (Suc i) xs) ! (Suc j - i))", "by (simp add: lxs)"], ["proof (state)\nthis:\n  remove_nth i xs ! j = xs ! adjust_idx i j\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  remove_nth i xs ! j = xs ! adjust_idx i j\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma adjust_idx_rev_nth:\n  assumes i: \"i < length xs\"\n    and ji: \"j \\<noteq> i\"\n  shows \"remove_nth i xs ! adjust_idx_rev i j = xs ! j\" (is \"?l = ?r\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. remove_nth i xs ! adjust_idx_rev i j = xs ! j", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. remove_nth i xs ! adjust_idx_rev i j = xs ! j", "let ?j = \"adjust_idx_rev i j\""], ["proof (state)\ngoal (1 subgoal):\n 1. remove_nth i xs ! adjust_idx_rev i j = xs ! j", "from i"], ["proof (chain)\npicking this:\n  i < length xs", "have ltake: \"length (take i xs) = i\""], ["proof (prove)\nusing this:\n  i < length xs\n\ngoal (1 subgoal):\n 1. length (take i xs) = i", "by simp"], ["proof (state)\nthis:\n  length (take i xs) = i\n\ngoal (1 subgoal):\n 1. remove_nth i xs ! adjust_idx_rev i j = xs ! j", "note nth_xs = arg_cong[where f = \"\\<lambda> xs. xs ! j\", OF id_take_nth_drop[OF i], unfolded nth_append ltake]"], ["proof (state)\nthis:\n  xs ! j =\n  (if j < i then take i xs ! j else (xs ! i # drop (Suc i) xs) ! (j - i))\n\ngoal (1 subgoal):\n 1. remove_nth i xs ! adjust_idx_rev i j = xs ! j", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. remove_nth i xs ! adjust_idx_rev i j = xs ! j", "proof (cases \"j < i\")"], ["proof (state)\ngoal (2 subgoals):\n 1. j < i \\<Longrightarrow> remove_nth i xs ! adjust_idx_rev i j = xs ! j\n 2. \\<not> j < i \\<Longrightarrow>\n    remove_nth i xs ! adjust_idx_rev i j = xs ! j", "case True"], ["proof (state)\nthis:\n  j < i\n\ngoal (2 subgoals):\n 1. j < i \\<Longrightarrow> remove_nth i xs ! adjust_idx_rev i j = xs ! j\n 2. \\<not> j < i \\<Longrightarrow>\n    remove_nth i xs ! adjust_idx_rev i j = xs ! j", "hence j: \"?j = j\""], ["proof (prove)\nusing this:\n  j < i\n\ngoal (1 subgoal):\n 1. adjust_idx_rev i j = j", "unfolding adjust_idx_rev_def"], ["proof (prove)\nusing this:\n  j < i\n\ngoal (1 subgoal):\n 1. (if j < i then j else j - Suc 0) = j", "by simp"], ["proof (state)\nthis:\n  adjust_idx_rev i j = j\n\ngoal (2 subgoals):\n 1. j < i \\<Longrightarrow> remove_nth i xs ! adjust_idx_rev i j = xs ! j\n 2. \\<not> j < i \\<Longrightarrow>\n    remove_nth i xs ! adjust_idx_rev i j = xs ! j", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. remove_nth i xs ! adjust_idx_rev i j = xs ! j", "unfolding nth_xs"], ["proof (prove)\ngoal (1 subgoal):\n 1. remove_nth i xs ! adjust_idx_rev i j =\n    (if j < i then take i xs ! j else (xs ! i # drop (Suc i) xs) ! (j - i))", "unfolding j remove_nth_def nth_append ltake"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if j < i then take i xs ! j else drop (Suc i) xs ! (j - i)) =\n    (if j < i then take i xs ! j else (xs ! i # drop (Suc i) xs) ! (j - i))", "using True"], ["proof (prove)\nusing this:\n  j < i\n\ngoal (1 subgoal):\n 1. (if j < i then take i xs ! j else drop (Suc i) xs ! (j - i)) =\n    (if j < i then take i xs ! j else (xs ! i # drop (Suc i) xs) ! (j - i))", "by simp"], ["proof (state)\nthis:\n  remove_nth i xs ! adjust_idx_rev i j = xs ! j\n\ngoal (1 subgoal):\n 1. \\<not> j < i \\<Longrightarrow>\n    remove_nth i xs ! adjust_idx_rev i j = xs ! j", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> j < i \\<Longrightarrow>\n    remove_nth i xs ! adjust_idx_rev i j = xs ! j", "case False"], ["proof (state)\nthis:\n  \\<not> j < i\n\ngoal (1 subgoal):\n 1. \\<not> j < i \\<Longrightarrow>\n    remove_nth i xs ! adjust_idx_rev i j = xs ! j", "with ji"], ["proof (chain)\npicking this:\n  j \\<noteq> i\n  \\<not> j < i", "have ji: \"j > i\""], ["proof (prove)\nusing this:\n  j \\<noteq> i\n  \\<not> j < i\n\ngoal (1 subgoal):\n 1. i < j", "by auto"], ["proof (state)\nthis:\n  i < j\n\ngoal (1 subgoal):\n 1. \\<not> j < i \\<Longrightarrow>\n    remove_nth i xs ! adjust_idx_rev i j = xs ! j", "hence j: \"?j = j - Suc 0\""], ["proof (prove)\nusing this:\n  i < j\n\ngoal (1 subgoal):\n 1. adjust_idx_rev i j = j - Suc 0", "unfolding adjust_idx_rev_def"], ["proof (prove)\nusing this:\n  i < j\n\ngoal (1 subgoal):\n 1. (if j < i then j else j - Suc 0) = j - Suc 0", "by simp"], ["proof (state)\nthis:\n  adjust_idx_rev i j = j - Suc 0\n\ngoal (1 subgoal):\n 1. \\<not> j < i \\<Longrightarrow>\n    remove_nth i xs ! adjust_idx_rev i j = xs ! j", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. remove_nth i xs ! adjust_idx_rev i j = xs ! j", "unfolding nth_xs"], ["proof (prove)\ngoal (1 subgoal):\n 1. remove_nth i xs ! adjust_idx_rev i j =\n    (if j < i then take i xs ! j else (xs ! i # drop (Suc i) xs) ! (j - i))", "unfolding j remove_nth_def nth_append ltake"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if j - Suc 0 < i then take i xs ! (j - Suc 0)\n     else drop (Suc i) xs ! (j - Suc 0 - i)) =\n    (if j < i then take i xs ! j else (xs ! i # drop (Suc i) xs) ! (j - i))", "using ji"], ["proof (prove)\nusing this:\n  i < j\n\ngoal (1 subgoal):\n 1. (if j - Suc 0 < i then take i xs ! (j - Suc 0)\n     else drop (Suc i) xs ! (j - Suc 0 - i)) =\n    (if j < i then take i xs ! j else (xs ! i # drop (Suc i) xs) ! (j - i))", "by auto"], ["proof (state)\nthis:\n  remove_nth i xs ! adjust_idx_rev i j = xs ! j\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  remove_nth i xs ! adjust_idx_rev i j = xs ! j\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma adjust_idx_length:\n  assumes i: \"i < length xs\"\n    and j: \"j < length (remove_nth i xs)\"\n  shows \"adjust_idx i j < length xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adjust_idx i j < length xs", "using j"], ["proof (prove)\nusing this:\n  j < length (remove_nth i xs)\n\ngoal (1 subgoal):\n 1. adjust_idx i j < length xs", "unfolding remove_nth_len[OF i] adjust_idx_def"], ["proof (prove)\nusing this:\n  j < length (remove_nth i xs)\n\ngoal (1 subgoal):\n 1. (if j < i then j else Suc j) < Suc (length (remove_nth i xs))", "by (cases \"j < i\", auto)"], ["", "lemma adjust_idx_rev_length:\n  assumes \"i < length xs\"\n    and \"j < length xs\"\n    and \"j \\<noteq> i\"\n  shows \"adjust_idx_rev i j < length (remove_nth i xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adjust_idx_rev i j < length (remove_nth i xs)", "using assms"], ["proof (prove)\nusing this:\n  i < length xs\n  j < length xs\n  j \\<noteq> i\n\ngoal (1 subgoal):\n 1. adjust_idx_rev i j < length (remove_nth i xs)", "by (cases \"j < i\") (simp_all add: adjust_idx_rev_def remove_nth_len[OF assms(1)])"], ["", "text\\<open>If a binary relation holds on two couples of lists, then it holds on\nthe concatenation of the two couples.\\<close>"], ["", "lemma P_as_bs_extend:\n  assumes lab: \"length as = length bs\"\n  and lcd: \"length cs = length ds\"\n  and nsab: \"\\<forall>i. i < length bs \\<longrightarrow> P (as ! i) (bs ! i)\"\n  and nscd: \"\\<forall>i. i < length ds \\<longrightarrow> P (cs ! i) (ds ! i)\"\n  shows \"\\<forall>i. i < length (bs @ ds) \\<longrightarrow> P ((as @ cs) ! i) ((bs @ ds) ! i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i<length (bs @ ds). P ((as @ cs) ! i) ((bs @ ds) ! i)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>i<length (bs @ ds). P ((as @ cs) ! i) ((bs @ ds) ! i)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>i<length (bs @ ds). P ((as @ cs) ! i) ((bs @ ds) ! i)", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>i<length (bs @ ds). P ((as @ cs) ! i) ((bs @ ds) ! i)", "assume i_bd: \"i < length (bs @ ds)\""], ["proof (state)\nthis:\n  i < length (bs @ ds)\n\ngoal (1 subgoal):\n 1. \\<forall>i<length (bs @ ds). P ((as @ cs) ! i) ((bs @ ds) ! i)", "have \"P ((as @ cs) ! i) ((bs @ ds) ! i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P ((as @ cs) ! i) ((bs @ ds) ! i)", "proof (cases \"i < length as\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i < length as \\<Longrightarrow> P ((as @ cs) ! i) ((bs @ ds) ! i)\n 2. \\<not> i < length as \\<Longrightarrow> P ((as @ cs) ! i) ((bs @ ds) ! i)", "case True"], ["proof (state)\nthis:\n  i < length as\n\ngoal (2 subgoals):\n 1. i < length as \\<Longrightarrow> P ((as @ cs) ! i) ((bs @ ds) ! i)\n 2. \\<not> i < length as \\<Longrightarrow> P ((as @ cs) ! i) ((bs @ ds) ! i)", "with nth_append and nsab and lab"], ["proof (chain)\npicking this:\n  (?xs @ ?ys) ! ?n =\n  (if ?n < length ?xs then ?xs ! ?n else ?ys ! (?n - length ?xs))\n  \\<forall>i<length bs. P (as ! i) (bs ! i)\n  length as = length bs\n  i < length as", "show ?thesis"], ["proof (prove)\nusing this:\n  (?xs @ ?ys) ! ?n =\n  (if ?n < length ?xs then ?xs ! ?n else ?ys ! (?n - length ?xs))\n  \\<forall>i<length bs. P (as ! i) (bs ! i)\n  length as = length bs\n  i < length as\n\ngoal (1 subgoal):\n 1. P ((as @ cs) ! i) ((bs @ ds) ! i)", "by metis"], ["proof (state)\nthis:\n  P ((as @ cs) ! i) ((bs @ ds) ! i)\n\ngoal (1 subgoal):\n 1. \\<not> i < length as \\<Longrightarrow> P ((as @ cs) ! i) ((bs @ ds) ! i)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> i < length as \\<Longrightarrow> P ((as @ cs) ! i) ((bs @ ds) ! i)", "case False"], ["proof (state)\nthis:\n  \\<not> i < length as\n\ngoal (1 subgoal):\n 1. \\<not> i < length as \\<Longrightarrow> P ((as @ cs) ! i) ((bs @ ds) ! i)", "with lab and lcd and i_bd and length_append[of bs ds]"], ["proof (chain)\npicking this:\n  length as = length bs\n  length cs = length ds\n  i < length (bs @ ds)\n  length (bs @ ds) = length bs + length ds\n  \\<not> i < length as", "have \"(i - length as) < length cs\""], ["proof (prove)\nusing this:\n  length as = length bs\n  length cs = length ds\n  i < length (bs @ ds)\n  length (bs @ ds) = length bs + length ds\n  \\<not> i < length as\n\ngoal (1 subgoal):\n 1. i - length as < length cs", "by arith"], ["proof (state)\nthis:\n  i - length as < length cs\n\ngoal (1 subgoal):\n 1. \\<not> i < length as \\<Longrightarrow> P ((as @ cs) ! i) ((bs @ ds) ! i)", "with False and nth_append[of _ _ i] and lab and lcd\n       and nscd[rule_format]"], ["proof (chain)\npicking this:\n  \\<not> i < length as\n  (?xs @ ?ys) ! i =\n  (if i < length ?xs then ?xs ! i else ?ys ! (i - length ?xs))\n  length as = length bs\n  length cs = length ds\n  ?i < length ds \\<Longrightarrow> P (cs ! ?i) (ds ! ?i)\n  i - length as < length cs", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> i < length as\n  (?xs @ ?ys) ! i =\n  (if i < length ?xs then ?xs ! i else ?ys ! (i - length ?xs))\n  length as = length bs\n  length cs = length ds\n  ?i < length ds \\<Longrightarrow> P (cs ! ?i) (ds ! ?i)\n  i - length as < length cs\n\ngoal (1 subgoal):\n 1. P ((as @ cs) ! i) ((bs @ ds) ! i)", "by metis"], ["proof (state)\nthis:\n  P ((as @ cs) ! i) ((bs @ ds) ! i)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  P ((as @ cs) ! i) ((bs @ ds) ! i)\n\ngoal (1 subgoal):\n 1. \\<forall>i<length (bs @ ds). P ((as @ cs) ! i) ((bs @ ds) ! i)", "}"], ["proof (state)\nthis:\n  ?i2 < length (bs @ ds) \\<Longrightarrow>\n  P ((as @ cs) ! ?i2) ((bs @ ds) ! ?i2)\n\ngoal (1 subgoal):\n 1. \\<forall>i<length (bs @ ds). P ((as @ cs) ! i) ((bs @ ds) ! i)", "thus ?thesis"], ["proof (prove)\nusing this:\n  ?i2 < length (bs @ ds) \\<Longrightarrow>\n  P ((as @ cs) ! ?i2) ((bs @ ds) ! ?i2)\n\ngoal (1 subgoal):\n 1. \\<forall>i<length (bs @ ds). P ((as @ cs) ! i) ((bs @ ds) ! i)", "by clarify"], ["proof (state)\nthis:\n  \\<forall>i<length (bs @ ds). P ((as @ cs) ! i) ((bs @ ds) ! i)\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>Extension of filter and partition to binary relations.\\<close>"], ["", "fun filter2 :: \"('a \\<Rightarrow> 'b \\<Rightarrow> bool) \\<Rightarrow> 'a list \\<Rightarrow> 'b list \\<Rightarrow> ('a list \\<times> 'b list)\" where\n  \"filter2 P [] _ = ([], [])\" |\n  \"filter2 P _ [] = ([], [])\" |\n  \"filter2 P (a # as) (b # bs) = (if P a b\n        then (a # fst (filter2 P as bs), b # snd (filter2 P as bs))\n        else filter2 P as bs)\""], ["", "lemma filter2_length:\n  \"length (fst (filter2 P as bs)) \\<equiv> length (snd (filter2 P as bs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (fst (filter2 P as bs)) \\<equiv> length (snd (filter2 P as bs))", "proof (induct as arbitrary: bs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>bs.\n       length (fst (filter2 P [] bs)) = length (snd (filter2 P [] bs))\n 2. \\<And>a as bs.\n       (\\<And>bs.\n           length (fst (filter2 P as bs)) =\n           length (snd (filter2 P as bs))) \\<Longrightarrow>\n       length (fst (filter2 P (a # as) bs)) =\n       length (snd (filter2 P (a # as) bs))", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>bs.\n       length (fst (filter2 P [] bs)) = length (snd (filter2 P [] bs))\n 2. \\<And>a as bs.\n       (\\<And>bs.\n           length (fst (filter2 P as bs)) =\n           length (snd (filter2 P as bs))) \\<Longrightarrow>\n       length (fst (filter2 P (a # as) bs)) =\n       length (snd (filter2 P (a # as) bs))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (fst (filter2 P [] bs)) = length (snd (filter2 P [] bs))", "by simp"], ["proof (state)\nthis:\n  length (fst (filter2 P [] bs)) = length (snd (filter2 P [] bs))\n\ngoal (1 subgoal):\n 1. \\<And>a as bs.\n       (\\<And>bs.\n           length (fst (filter2 P as bs)) =\n           length (snd (filter2 P as bs))) \\<Longrightarrow>\n       length (fst (filter2 P (a # as) bs)) =\n       length (snd (filter2 P (a # as) bs))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a as bs.\n       (\\<And>bs.\n           length (fst (filter2 P as bs)) =\n           length (snd (filter2 P as bs))) \\<Longrightarrow>\n       length (fst (filter2 P (a # as) bs)) =\n       length (snd (filter2 P (a # as) bs))", "case (Cons a as)"], ["proof (state)\nthis:\n  length (fst (filter2 P as ?bs)) = length (snd (filter2 P as ?bs))\n\ngoal (1 subgoal):\n 1. \\<And>a as bs.\n       (\\<And>bs.\n           length (fst (filter2 P as bs)) =\n           length (snd (filter2 P as bs))) \\<Longrightarrow>\n       length (fst (filter2 P (a # as) bs)) =\n       length (snd (filter2 P (a # as) bs))", "note IH = this"], ["proof (state)\nthis:\n  length (fst (filter2 P as ?bs)) = length (snd (filter2 P as ?bs))\n\ngoal (1 subgoal):\n 1. \\<And>a as bs.\n       (\\<And>bs.\n           length (fst (filter2 P as bs)) =\n           length (snd (filter2 P as bs))) \\<Longrightarrow>\n       length (fst (filter2 P (a # as) bs)) =\n       length (snd (filter2 P (a # as) bs))", "thus ?case"], ["proof (prove)\nusing this:\n  length (fst (filter2 P as ?bs)) = length (snd (filter2 P as ?bs))\n\ngoal (1 subgoal):\n 1. length (fst (filter2 P (a # as) bs)) =\n    length (snd (filter2 P (a # as) bs))", "proof (cases bs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>bs.\n                length (fst (filter2 P as bs)) =\n                length (snd (filter2 P as bs));\n     bs = []\\<rbrakk>\n    \\<Longrightarrow> length (fst (filter2 P (a # as) bs)) =\n                      length (snd (filter2 P (a # as) bs))\n 2. \\<And>aa list.\n       \\<lbrakk>\\<And>bs.\n                   length (fst (filter2 P as bs)) =\n                   length (snd (filter2 P as bs));\n        bs = aa # list\\<rbrakk>\n       \\<Longrightarrow> length (fst (filter2 P (a # as) bs)) =\n                         length (snd (filter2 P (a # as) bs))", "case Nil"], ["proof (state)\nthis:\n  bs = []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>bs.\n                length (fst (filter2 P as bs)) =\n                length (snd (filter2 P as bs));\n     bs = []\\<rbrakk>\n    \\<Longrightarrow> length (fst (filter2 P (a # as) bs)) =\n                      length (snd (filter2 P (a # as) bs))\n 2. \\<And>aa list.\n       \\<lbrakk>\\<And>bs.\n                   length (fst (filter2 P as bs)) =\n                   length (snd (filter2 P as bs));\n        bs = aa # list\\<rbrakk>\n       \\<Longrightarrow> length (fst (filter2 P (a # as) bs)) =\n                         length (snd (filter2 P (a # as) bs))", "thus ?thesis"], ["proof (prove)\nusing this:\n  bs = []\n\ngoal (1 subgoal):\n 1. length (fst (filter2 P (a # as) bs)) =\n    length (snd (filter2 P (a # as) bs))", "by simp"], ["proof (state)\nthis:\n  length (fst (filter2 P (a # as) bs)) =\n  length (snd (filter2 P (a # as) bs))\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       \\<lbrakk>\\<And>bs.\n                   length (fst (filter2 P as bs)) =\n                   length (snd (filter2 P as bs));\n        bs = aa # list\\<rbrakk>\n       \\<Longrightarrow> length (fst (filter2 P (a # as) bs)) =\n                         length (snd (filter2 P (a # as) bs))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       \\<lbrakk>\\<And>bs.\n                   length (fst (filter2 P as bs)) =\n                   length (snd (filter2 P as bs));\n        bs = aa # list\\<rbrakk>\n       \\<Longrightarrow> length (fst (filter2 P (a # as) bs)) =\n                         length (snd (filter2 P (a # as) bs))", "case (Cons b bs)"], ["proof (state)\nthis:\n  bsa__ = b # bs\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       \\<lbrakk>\\<And>bs.\n                   length (fst (filter2 P as bs)) =\n                   length (snd (filter2 P as bs));\n        bsa__ = aa # list\\<rbrakk>\n       \\<Longrightarrow> length (fst (filter2 P (a # as) bsa__)) =\n                         length (snd (filter2 P (a # as) bsa__))", "thus ?thesis"], ["proof (prove)\nusing this:\n  bsa__ = b # bs\n\ngoal (1 subgoal):\n 1. length (fst (filter2 P (a # as) bsa__)) =\n    length (snd (filter2 P (a # as) bsa__))", "proof (cases \"P a b\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>bsa__ = b # bs; P a b\\<rbrakk>\n    \\<Longrightarrow> length (fst (filter2 P (a # as) bsa__)) =\n                      length (snd (filter2 P (a # as) bsa__))\n 2. \\<lbrakk>bsa__ = b # bs; \\<not> P a b\\<rbrakk>\n    \\<Longrightarrow> length (fst (filter2 P (a # as) bsa__)) =\n                      length (snd (filter2 P (a # as) bsa__))", "case True"], ["proof (state)\nthis:\n  P a b\n\ngoal (2 subgoals):\n 1. \\<lbrakk>bsa__ = b # bs; P a b\\<rbrakk>\n    \\<Longrightarrow> length (fst (filter2 P (a # as) bsa__)) =\n                      length (snd (filter2 P (a # as) bsa__))\n 2. \\<lbrakk>bsa__ = b # bs; \\<not> P a b\\<rbrakk>\n    \\<Longrightarrow> length (fst (filter2 P (a # as) bsa__)) =\n                      length (snd (filter2 P (a # as) bsa__))", "with Cons and IH"], ["proof (chain)\npicking this:\n  bsa__ = b # bs\n  length (fst (filter2 P as ?bs)) = length (snd (filter2 P as ?bs))\n  P a b", "show ?thesis"], ["proof (prove)\nusing this:\n  bsa__ = b # bs\n  length (fst (filter2 P as ?bs)) = length (snd (filter2 P as ?bs))\n  P a b\n\ngoal (1 subgoal):\n 1. length (fst (filter2 P (a # as) bsa__)) =\n    length (snd (filter2 P (a # as) bsa__))", "by simp"], ["proof (state)\nthis:\n  length (fst (filter2 P (a # as) bsa__)) =\n  length (snd (filter2 P (a # as) bsa__))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>bsa__ = b # bs; \\<not> P a b\\<rbrakk>\n    \\<Longrightarrow> length (fst (filter2 P (a # as) bsa__)) =\n                      length (snd (filter2 P (a # as) bsa__))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>bsa__ = b # bs; \\<not> P a b\\<rbrakk>\n    \\<Longrightarrow> length (fst (filter2 P (a # as) bsa__)) =\n                      length (snd (filter2 P (a # as) bsa__))", "case False"], ["proof (state)\nthis:\n  \\<not> P a b\n\ngoal (1 subgoal):\n 1. \\<lbrakk>bsa__ = b # bs; \\<not> P a b\\<rbrakk>\n    \\<Longrightarrow> length (fst (filter2 P (a # as) bsa__)) =\n                      length (snd (filter2 P (a # as) bsa__))", "with Cons and IH"], ["proof (chain)\npicking this:\n  bsa__ = b # bs\n  length (fst (filter2 P as ?bs)) = length (snd (filter2 P as ?bs))\n  \\<not> P a b", "show ?thesis"], ["proof (prove)\nusing this:\n  bsa__ = b # bs\n  length (fst (filter2 P as ?bs)) = length (snd (filter2 P as ?bs))\n  \\<not> P a b\n\ngoal (1 subgoal):\n 1. length (fst (filter2 P (a # as) bsa__)) =\n    length (snd (filter2 P (a # as) bsa__))", "by simp"], ["proof (state)\nthis:\n  length (fst (filter2 P (a # as) bsa__)) =\n  length (snd (filter2 P (a # as) bsa__))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  length (fst (filter2 P (a # as) bsa__)) =\n  length (snd (filter2 P (a # as) bsa__))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  length (fst (filter2 P (a # as) bs)) =\n  length (snd (filter2 P (a # as) bs))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma filter2_sound: \"\\<forall>i. i < length (fst (filter2 P as bs)) \\<longrightarrow> P (fst (filter2 P as bs) ! i) (snd (filter2 P as bs) ! i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i<length (fst (filter2 P as bs)).\n       P (fst (filter2 P as bs) ! i) (snd (filter2 P as bs) ! i)", "proof (induct as arbitrary: bs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>bs.\n       \\<forall>i<length (fst (filter2 P [] bs)).\n          P (fst (filter2 P [] bs) ! i) (snd (filter2 P [] bs) ! i)\n 2. \\<And>a as bs.\n       (\\<And>bs.\n           \\<forall>i<length (fst (filter2 P as bs)).\n              P (fst (filter2 P as bs) ! i)\n               (snd (filter2 P as bs) ! i)) \\<Longrightarrow>\n       \\<forall>i<length (fst (filter2 P (a # as) bs)).\n          P (fst (filter2 P (a # as) bs) ! i)\n           (snd (filter2 P (a # as) bs) ! i)", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>bs.\n       \\<forall>i<length (fst (filter2 P [] bs)).\n          P (fst (filter2 P [] bs) ! i) (snd (filter2 P [] bs) ! i)\n 2. \\<And>a as bs.\n       (\\<And>bs.\n           \\<forall>i<length (fst (filter2 P as bs)).\n              P (fst (filter2 P as bs) ! i)\n               (snd (filter2 P as bs) ! i)) \\<Longrightarrow>\n       \\<forall>i<length (fst (filter2 P (a # as) bs)).\n          P (fst (filter2 P (a # as) bs) ! i)\n           (snd (filter2 P (a # as) bs) ! i)", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i<length (fst (filter2 P [] bs)).\n       P (fst (filter2 P [] bs) ! i) (snd (filter2 P [] bs) ! i)", "by simp"], ["proof (state)\nthis:\n  \\<forall>i<length (fst (filter2 P [] bs)).\n     P (fst (filter2 P [] bs) ! i) (snd (filter2 P [] bs) ! i)\n\ngoal (1 subgoal):\n 1. \\<And>a as bs.\n       (\\<And>bs.\n           \\<forall>i<length (fst (filter2 P as bs)).\n              P (fst (filter2 P as bs) ! i)\n               (snd (filter2 P as bs) ! i)) \\<Longrightarrow>\n       \\<forall>i<length (fst (filter2 P (a # as) bs)).\n          P (fst (filter2 P (a # as) bs) ! i)\n           (snd (filter2 P (a # as) bs) ! i)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a as bs.\n       (\\<And>bs.\n           \\<forall>i<length (fst (filter2 P as bs)).\n              P (fst (filter2 P as bs) ! i)\n               (snd (filter2 P as bs) ! i)) \\<Longrightarrow>\n       \\<forall>i<length (fst (filter2 P (a # as) bs)).\n          P (fst (filter2 P (a # as) bs) ! i)\n           (snd (filter2 P (a # as) bs) ! i)", "case (Cons a as)"], ["proof (state)\nthis:\n  \\<forall>i<length (fst (filter2 P as ?bs)).\n     P (fst (filter2 P as ?bs) ! i) (snd (filter2 P as ?bs) ! i)\n\ngoal (1 subgoal):\n 1. \\<And>a as bs.\n       (\\<And>bs.\n           \\<forall>i<length (fst (filter2 P as bs)).\n              P (fst (filter2 P as bs) ! i)\n               (snd (filter2 P as bs) ! i)) \\<Longrightarrow>\n       \\<forall>i<length (fst (filter2 P (a # as) bs)).\n          P (fst (filter2 P (a # as) bs) ! i)\n           (snd (filter2 P (a # as) bs) ! i)", "note IH = this"], ["proof (state)\nthis:\n  \\<forall>i<length (fst (filter2 P as ?bs)).\n     P (fst (filter2 P as ?bs) ! i) (snd (filter2 P as ?bs) ! i)\n\ngoal (1 subgoal):\n 1. \\<And>a as bs.\n       (\\<And>bs.\n           \\<forall>i<length (fst (filter2 P as bs)).\n              P (fst (filter2 P as bs) ! i)\n               (snd (filter2 P as bs) ! i)) \\<Longrightarrow>\n       \\<forall>i<length (fst (filter2 P (a # as) bs)).\n          P (fst (filter2 P (a # as) bs) ! i)\n           (snd (filter2 P (a # as) bs) ! i)", "thus ?case"], ["proof (prove)\nusing this:\n  \\<forall>i<length (fst (filter2 P as ?bs)).\n     P (fst (filter2 P as ?bs) ! i) (snd (filter2 P as ?bs) ! i)\n\ngoal (1 subgoal):\n 1. \\<forall>i<length (fst (filter2 P (a # as) bs)).\n       P (fst (filter2 P (a # as) bs) ! i) (snd (filter2 P (a # as) bs) ! i)", "proof (cases bs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>bs.\n                \\<forall>i<length (fst (filter2 P as bs)).\n                   P (fst (filter2 P as bs) ! i)\n                    (snd (filter2 P as bs) ! i);\n     bs = []\\<rbrakk>\n    \\<Longrightarrow> \\<forall>i<length (fst (filter2 P (a # as) bs)).\n                         P (fst (filter2 P (a # as) bs) ! i)\n                          (snd (filter2 P (a # as) bs) ! i)\n 2. \\<And>aa list.\n       \\<lbrakk>\\<And>bs.\n                   \\<forall>i<length (fst (filter2 P as bs)).\n                      P (fst (filter2 P as bs) ! i)\n                       (snd (filter2 P as bs) ! i);\n        bs = aa # list\\<rbrakk>\n       \\<Longrightarrow> \\<forall>i<length (fst (filter2 P (a # as) bs)).\n                            P (fst (filter2 P (a # as) bs) ! i)\n                             (snd (filter2 P (a # as) bs) ! i)", "case Nil"], ["proof (state)\nthis:\n  bs = []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>bs.\n                \\<forall>i<length (fst (filter2 P as bs)).\n                   P (fst (filter2 P as bs) ! i)\n                    (snd (filter2 P as bs) ! i);\n     bs = []\\<rbrakk>\n    \\<Longrightarrow> \\<forall>i<length (fst (filter2 P (a # as) bs)).\n                         P (fst (filter2 P (a # as) bs) ! i)\n                          (snd (filter2 P (a # as) bs) ! i)\n 2. \\<And>aa list.\n       \\<lbrakk>\\<And>bs.\n                   \\<forall>i<length (fst (filter2 P as bs)).\n                      P (fst (filter2 P as bs) ! i)\n                       (snd (filter2 P as bs) ! i);\n        bs = aa # list\\<rbrakk>\n       \\<Longrightarrow> \\<forall>i<length (fst (filter2 P (a # as) bs)).\n                            P (fst (filter2 P (a # as) bs) ! i)\n                             (snd (filter2 P (a # as) bs) ! i)", "thus ?thesis"], ["proof (prove)\nusing this:\n  bs = []\n\ngoal (1 subgoal):\n 1. \\<forall>i<length (fst (filter2 P (a # as) bs)).\n       P (fst (filter2 P (a # as) bs) ! i) (snd (filter2 P (a # as) bs) ! i)", "by simp"], ["proof (state)\nthis:\n  \\<forall>i<length (fst (filter2 P (a # as) bs)).\n     P (fst (filter2 P (a # as) bs) ! i) (snd (filter2 P (a # as) bs) ! i)\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       \\<lbrakk>\\<And>bs.\n                   \\<forall>i<length (fst (filter2 P as bs)).\n                      P (fst (filter2 P as bs) ! i)\n                       (snd (filter2 P as bs) ! i);\n        bs = aa # list\\<rbrakk>\n       \\<Longrightarrow> \\<forall>i<length (fst (filter2 P (a # as) bs)).\n                            P (fst (filter2 P (a # as) bs) ! i)\n                             (snd (filter2 P (a # as) bs) ! i)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       \\<lbrakk>\\<And>bs.\n                   \\<forall>i<length (fst (filter2 P as bs)).\n                      P (fst (filter2 P as bs) ! i)\n                       (snd (filter2 P as bs) ! i);\n        bs = aa # list\\<rbrakk>\n       \\<Longrightarrow> \\<forall>i<length (fst (filter2 P (a # as) bs)).\n                            P (fst (filter2 P (a # as) bs) ! i)\n                             (snd (filter2 P (a # as) bs) ! i)", "case (Cons b bs)"], ["proof (state)\nthis:\n  bsa__ = b # bs\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       \\<lbrakk>\\<And>bs.\n                   \\<forall>i<length (fst (filter2 P as bs)).\n                      P (fst (filter2 P as bs) ! i)\n                       (snd (filter2 P as bs) ! i);\n        bsa__ = aa # list\\<rbrakk>\n       \\<Longrightarrow> \\<forall>i<length (fst (filter2 P (a # as) bsa__)).\n                            P (fst (filter2 P (a # as) bsa__) ! i)\n                             (snd (filter2 P (a # as) bsa__) ! i)", "thus ?thesis"], ["proof (prove)\nusing this:\n  bsa__ = b # bs\n\ngoal (1 subgoal):\n 1. \\<forall>i<length (fst (filter2 P (a # as) bsa__)).\n       P (fst (filter2 P (a # as) bsa__) ! i)\n        (snd (filter2 P (a # as) bsa__) ! i)", "proof (cases \"P a b\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>bsa__ = b # bs; P a b\\<rbrakk>\n    \\<Longrightarrow> \\<forall>i<length (fst (filter2 P (a # as) bsa__)).\n                         P (fst (filter2 P (a # as) bsa__) ! i)\n                          (snd (filter2 P (a # as) bsa__) ! i)\n 2. \\<lbrakk>bsa__ = b # bs; \\<not> P a b\\<rbrakk>\n    \\<Longrightarrow> \\<forall>i<length (fst (filter2 P (a # as) bsa__)).\n                         P (fst (filter2 P (a # as) bsa__) ! i)\n                          (snd (filter2 P (a # as) bsa__) ! i)", "case False"], ["proof (state)\nthis:\n  \\<not> P a b\n\ngoal (2 subgoals):\n 1. \\<lbrakk>bsa__ = b # bs; P a b\\<rbrakk>\n    \\<Longrightarrow> \\<forall>i<length (fst (filter2 P (a # as) bsa__)).\n                         P (fst (filter2 P (a # as) bsa__) ! i)\n                          (snd (filter2 P (a # as) bsa__) ! i)\n 2. \\<lbrakk>bsa__ = b # bs; \\<not> P a b\\<rbrakk>\n    \\<Longrightarrow> \\<forall>i<length (fst (filter2 P (a # as) bsa__)).\n                         P (fst (filter2 P (a # as) bsa__) ! i)\n                          (snd (filter2 P (a # as) bsa__) ! i)", "with Cons and IH"], ["proof (chain)\npicking this:\n  bsa__ = b # bs\n  \\<forall>i<length (fst (filter2 P as ?bs)).\n     P (fst (filter2 P as ?bs) ! i) (snd (filter2 P as ?bs) ! i)\n  \\<not> P a b", "show ?thesis"], ["proof (prove)\nusing this:\n  bsa__ = b # bs\n  \\<forall>i<length (fst (filter2 P as ?bs)).\n     P (fst (filter2 P as ?bs) ! i) (snd (filter2 P as ?bs) ! i)\n  \\<not> P a b\n\ngoal (1 subgoal):\n 1. \\<forall>i<length (fst (filter2 P (a # as) bsa__)).\n       P (fst (filter2 P (a # as) bsa__) ! i)\n        (snd (filter2 P (a # as) bsa__) ! i)", "by simp"], ["proof (state)\nthis:\n  \\<forall>i<length (fst (filter2 P (a # as) bsa__)).\n     P (fst (filter2 P (a # as) bsa__) ! i)\n      (snd (filter2 P (a # as) bsa__) ! i)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>bsa__ = b # bs; P a b\\<rbrakk>\n    \\<Longrightarrow> \\<forall>i<length (fst (filter2 P (a # as) bsa__)).\n                         P (fst (filter2 P (a # as) bsa__) ! i)\n                          (snd (filter2 P (a # as) bsa__) ! i)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>bsa__ = b # bs; P a b\\<rbrakk>\n    \\<Longrightarrow> \\<forall>i<length (fst (filter2 P (a # as) bsa__)).\n                         P (fst (filter2 P (a # as) bsa__) ! i)\n                          (snd (filter2 P (a # as) bsa__) ! i)", "case True"], ["proof (state)\nthis:\n  P a b\n\ngoal (1 subgoal):\n 1. \\<lbrakk>bsa__ = b # bs; P a b\\<rbrakk>\n    \\<Longrightarrow> \\<forall>i<length (fst (filter2 P (a # as) bsa__)).\n                         P (fst (filter2 P (a # as) bsa__) ! i)\n                          (snd (filter2 P (a # as) bsa__) ! i)", "{"], ["proof (state)\nthis:\n  P a b\n\ngoal (1 subgoal):\n 1. \\<lbrakk>bsa__ = b # bs; P a b\\<rbrakk>\n    \\<Longrightarrow> \\<forall>i<length (fst (filter2 P (a # as) bsa__)).\n                         P (fst (filter2 P (a # as) bsa__) ! i)\n                          (snd (filter2 P (a # as) bsa__) ! i)", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>bsa__ = b # bs; P a b\\<rbrakk>\n    \\<Longrightarrow> \\<forall>i<length (fst (filter2 P (a # as) bsa__)).\n                         P (fst (filter2 P (a # as) bsa__) ! i)\n                          (snd (filter2 P (a # as) bsa__) ! i)", "assume i_bd: \"i < length (fst (filter2 P (a # as) (b # bs)))\""], ["proof (state)\nthis:\n  i < length (fst (filter2 P (a # as) (b # bs)))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>bsa__ = b # bs; P a b\\<rbrakk>\n    \\<Longrightarrow> \\<forall>i<length (fst (filter2 P (a # as) bsa__)).\n                         P (fst (filter2 P (a # as) bsa__) ! i)\n                          (snd (filter2 P (a # as) bsa__) ! i)", "have \"P (fst (filter2 P (a # as) (b # bs)) ! i) (snd (filter2 P (a # as) (b # bs)) ! i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P (fst (filter2 P (a # as) (b # bs)) ! i)\n     (snd (filter2 P (a # as) (b # bs)) ! i)", "proof (cases i)"], ["proof (state)\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow>\n    P (fst (filter2 P (a # as) (b # bs)) ! i)\n     (snd (filter2 P (a # as) (b # bs)) ! i)\n 2. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       P (fst (filter2 P (a # as) (b # bs)) ! i)\n        (snd (filter2 P (a # as) (b # bs)) ! i)", "case 0"], ["proof (state)\nthis:\n  i = 0\n\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow>\n    P (fst (filter2 P (a # as) (b # bs)) ! i)\n     (snd (filter2 P (a # as) (b # bs)) ! i)\n 2. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       P (fst (filter2 P (a # as) (b # bs)) ! i)\n        (snd (filter2 P (a # as) (b # bs)) ! i)", "with True"], ["proof (chain)\npicking this:\n  P a b\n  i = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  P a b\n  i = 0\n\ngoal (1 subgoal):\n 1. P (fst (filter2 P (a # as) (b # bs)) ! i)\n     (snd (filter2 P (a # as) (b # bs)) ! i)", "by simp"], ["proof (state)\nthis:\n  P (fst (filter2 P (a # as) (b # bs)) ! i)\n   (snd (filter2 P (a # as) (b # bs)) ! i)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       P (fst (filter2 P (a # as) (b # bs)) ! i)\n        (snd (filter2 P (a # as) (b # bs)) ! i)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       P (fst (filter2 P (a # as) (b # bs)) ! i)\n        (snd (filter2 P (a # as) (b # bs)) ! i)", "case (Suc j)"], ["proof (state)\nthis:\n  i = Suc j\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       P (fst (filter2 P (a # as) (b # bs)) ! i)\n        (snd (filter2 P (a # as) (b # bs)) ! i)", "with i_bd and True"], ["proof (chain)\npicking this:\n  i < length (fst (filter2 P (a # as) (b # bs)))\n  P a b\n  i = Suc j", "have \"j < length (fst (filter2 P as bs))\""], ["proof (prove)\nusing this:\n  i < length (fst (filter2 P (a # as) (b # bs)))\n  P a b\n  i = Suc j\n\ngoal (1 subgoal):\n 1. j < length (fst (filter2 P as bs))", "by auto"], ["proof (state)\nthis:\n  j < length (fst (filter2 P as bs))\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       P (fst (filter2 P (a # as) (b # bs)) ! i)\n        (snd (filter2 P (a # as) (b # bs)) ! i)", "with Suc and IH and True"], ["proof (chain)\npicking this:\n  i = Suc j\n  \\<forall>i<length (fst (filter2 P as ?bs)).\n     P (fst (filter2 P as ?bs) ! i) (snd (filter2 P as ?bs) ! i)\n  P a b\n  j < length (fst (filter2 P as bs))", "show ?thesis"], ["proof (prove)\nusing this:\n  i = Suc j\n  \\<forall>i<length (fst (filter2 P as ?bs)).\n     P (fst (filter2 P as ?bs) ! i) (snd (filter2 P as ?bs) ! i)\n  P a b\n  j < length (fst (filter2 P as bs))\n\ngoal (1 subgoal):\n 1. P (fst (filter2 P (a # as) (b # bs)) ! i)\n     (snd (filter2 P (a # as) (b # bs)) ! i)", "by simp"], ["proof (state)\nthis:\n  P (fst (filter2 P (a # as) (b # bs)) ! i)\n   (snd (filter2 P (a # as) (b # bs)) ! i)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  P (fst (filter2 P (a # as) (b # bs)) ! i)\n   (snd (filter2 P (a # as) (b # bs)) ! i)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>bsa__ = b # bs; P a b\\<rbrakk>\n    \\<Longrightarrow> \\<forall>i<length (fst (filter2 P (a # as) bsa__)).\n                         P (fst (filter2 P (a # as) bsa__) ! i)\n                          (snd (filter2 P (a # as) bsa__) ! i)", "}"], ["proof (state)\nthis:\n  ?i2 < length (fst (filter2 P (a # as) (b # bs))) \\<Longrightarrow>\n  P (fst (filter2 P (a # as) (b # bs)) ! ?i2)\n   (snd (filter2 P (a # as) (b # bs)) ! ?i2)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>bsa__ = b # bs; P a b\\<rbrakk>\n    \\<Longrightarrow> \\<forall>i<length (fst (filter2 P (a # as) bsa__)).\n                         P (fst (filter2 P (a # as) bsa__) ! i)\n                          (snd (filter2 P (a # as) bsa__) ! i)", "with Cons"], ["proof (chain)\npicking this:\n  bsa__ = b # bs\n  ?i2 < length (fst (filter2 P (a # as) (b # bs))) \\<Longrightarrow>\n  P (fst (filter2 P (a # as) (b # bs)) ! ?i2)\n   (snd (filter2 P (a # as) (b # bs)) ! ?i2)", "show ?thesis"], ["proof (prove)\nusing this:\n  bsa__ = b # bs\n  ?i2 < length (fst (filter2 P (a # as) (b # bs))) \\<Longrightarrow>\n  P (fst (filter2 P (a # as) (b # bs)) ! ?i2)\n   (snd (filter2 P (a # as) (b # bs)) ! ?i2)\n\ngoal (1 subgoal):\n 1. \\<forall>i<length (fst (filter2 P (a # as) bsa__)).\n       P (fst (filter2 P (a # as) bsa__) ! i)\n        (snd (filter2 P (a # as) bsa__) ! i)", "by simp"], ["proof (state)\nthis:\n  \\<forall>i<length (fst (filter2 P (a # as) bsa__)).\n     P (fst (filter2 P (a # as) bsa__) ! i)\n      (snd (filter2 P (a # as) bsa__) ! i)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>i<length (fst (filter2 P (a # as) bsa__)).\n     P (fst (filter2 P (a # as) bsa__) ! i)\n      (snd (filter2 P (a # as) bsa__) ! i)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>i<length (fst (filter2 P (a # as) bs)).\n     P (fst (filter2 P (a # as) bs) ! i) (snd (filter2 P (a # as) bs) ! i)\n\ngoal:\nNo subgoals!", "qed"], ["", "definition partition2 :: \"('a \\<Rightarrow> 'b \\<Rightarrow> bool) \\<Rightarrow> 'a list \\<Rightarrow> 'b list \\<Rightarrow> ('a list \\<times> 'b list) \\<times> ('a list \\<times> 'b list)\" where\n  \"partition2 P as bs \\<equiv> ((filter2 P as bs) , (filter2 (\\<lambda>a b. \\<not> (P a b)) as bs))\""], ["", "lemma partition2_sound_P: \"\\<forall>i. i < length (fst (fst (partition2 P as bs))) \\<longrightarrow>\n  P (fst (fst (partition2 P as bs)) ! i) (snd (fst (partition2 P as bs)) ! i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i<length (fst (fst (partition2 P as bs))).\n       P (fst (fst (partition2 P as bs)) ! i)\n        (snd (fst (partition2 P as bs)) ! i)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>i<length (fst (fst (partition2 P as bs))).\n       P (fst (fst (partition2 P as bs)) ! i)\n        (snd (fst (partition2 P as bs)) ! i)", "from filter2_sound"], ["proof (chain)\npicking this:\n  \\<forall>i<length (fst (filter2 ?P ?as ?bs)).\n     ?P (fst (filter2 ?P ?as ?bs) ! i) (snd (filter2 ?P ?as ?bs) ! i)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>i<length (fst (filter2 ?P ?as ?bs)).\n     ?P (fst (filter2 ?P ?as ?bs) ! i) (snd (filter2 ?P ?as ?bs) ! i)\n\ngoal (1 subgoal):\n 1. \\<forall>i<length (fst (fst (partition2 P as bs))).\n       P (fst (fst (partition2 P as bs)) ! i)\n        (snd (fst (partition2 P as bs)) ! i)", "unfolding partition2_def"], ["proof (prove)\nusing this:\n  \\<forall>i<length (fst (filter2 ?P ?as ?bs)).\n     ?P (fst (filter2 ?P ?as ?bs) ! i) (snd (filter2 ?P ?as ?bs) ! i)\n\ngoal (1 subgoal):\n 1. \\<forall>i<length\n                (fst (fst (filter2 P as bs,\n                           filter2 (\\<lambda>a b. \\<not> P a b) as bs))).\n       P (fst (fst (filter2 P as bs,\n                    filter2 (\\<lambda>a b. \\<not> P a b) as bs)) !\n          i)\n        (snd (fst (filter2 P as bs,\n                   filter2 (\\<lambda>a b. \\<not> P a b) as bs)) !\n         i)", "by simp"], ["proof (state)\nthis:\n  \\<forall>i<length (fst (fst (partition2 P as bs))).\n     P (fst (fst (partition2 P as bs)) ! i)\n      (snd (fst (partition2 P as bs)) ! i)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma partition2_sound_nP: \"\\<forall>i. i < length (fst (snd (partition2 P as bs))) \\<longrightarrow>\n  \\<not> P (fst (snd (partition2 P as bs)) ! i) (snd (snd (partition2 P as bs)) ! i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i<length (fst (snd (partition2 P as bs))).\n       \\<not> P (fst (snd (partition2 P as bs)) ! i)\n               (snd (snd (partition2 P as bs)) ! i)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>i<length (fst (snd (partition2 P as bs))).\n       \\<not> P (fst (snd (partition2 P as bs)) ! i)\n               (snd (snd (partition2 P as bs)) ! i)", "from filter2_sound"], ["proof (chain)\npicking this:\n  \\<forall>i<length (fst (filter2 ?P ?as ?bs)).\n     ?P (fst (filter2 ?P ?as ?bs) ! i) (snd (filter2 ?P ?as ?bs) ! i)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>i<length (fst (filter2 ?P ?as ?bs)).\n     ?P (fst (filter2 ?P ?as ?bs) ! i) (snd (filter2 ?P ?as ?bs) ! i)\n\ngoal (1 subgoal):\n 1. \\<forall>i<length (fst (snd (partition2 P as bs))).\n       \\<not> P (fst (snd (partition2 P as bs)) ! i)\n               (snd (snd (partition2 P as bs)) ! i)", "unfolding partition2_def"], ["proof (prove)\nusing this:\n  \\<forall>i<length (fst (filter2 ?P ?as ?bs)).\n     ?P (fst (filter2 ?P ?as ?bs) ! i) (snd (filter2 ?P ?as ?bs) ! i)\n\ngoal (1 subgoal):\n 1. \\<forall>i<length\n                (fst (snd (filter2 P as bs,\n                           filter2 (\\<lambda>a b. \\<not> P a b) as bs))).\n       \\<not> P (fst (snd (filter2 P as bs,\n                           filter2 (\\<lambda>a b. \\<not> P a b) as bs)) !\n                 i)\n               (snd (snd (filter2 P as bs,\n                          filter2 (\\<lambda>a b. \\<not> P a b) as bs)) !\n                i)", "by simp"], ["proof (state)\nthis:\n  \\<forall>i<length (fst (snd (partition2 P as bs))).\n     \\<not> P (fst (snd (partition2 P as bs)) ! i)\n             (snd (snd (partition2 P as bs)) ! i)\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>Membership decision function that actually returns the\nvalue of the index where the value can be found.\\<close>"], ["", "fun mem_idx :: \"'a \\<Rightarrow> 'a list \\<Rightarrow> nat Option.option\" where\n  \"mem_idx _ []       = None\" |\n  \"mem_idx x (a # as) = (if x = a then Some 0 else map_option Suc (mem_idx x as))\""], ["", "lemma mem_idx_sound_output:\n  assumes \"mem_idx x as = Some i\"\n  shows \"i < length as \\<and> as ! i = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < length as \\<and> as ! i = x", "using assms"], ["proof (prove)\nusing this:\n  mem_idx x as = Some i\n\ngoal (1 subgoal):\n 1. i < length as \\<and> as ! i = x", "proof (induct as arbitrary: i)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i.\n       mem_idx x [] = Some i \\<Longrightarrow>\n       i < length [] \\<and> [] ! i = x\n 2. \\<And>a as i.\n       \\<lbrakk>\\<And>i.\n                   mem_idx x as = Some i \\<Longrightarrow>\n                   i < length as \\<and> as ! i = x;\n        mem_idx x (a # as) = Some i\\<rbrakk>\n       \\<Longrightarrow> i < length (a # as) \\<and> (a # as) ! i = x", "case Nil"], ["proof (state)\nthis:\n  mem_idx x [] = Some i\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       mem_idx x [] = Some i \\<Longrightarrow>\n       i < length [] \\<and> [] ! i = x\n 2. \\<And>a as i.\n       \\<lbrakk>\\<And>i.\n                   mem_idx x as = Some i \\<Longrightarrow>\n                   i < length as \\<and> as ! i = x;\n        mem_idx x (a # as) = Some i\\<rbrakk>\n       \\<Longrightarrow> i < length (a # as) \\<and> (a # as) ! i = x", "thus ?case"], ["proof (prove)\nusing this:\n  mem_idx x [] = Some i\n\ngoal (1 subgoal):\n 1. i < length [] \\<and> [] ! i = x", "by simp"], ["proof (state)\nthis:\n  i < length [] \\<and> [] ! i = x\n\ngoal (1 subgoal):\n 1. \\<And>a as i.\n       \\<lbrakk>\\<And>i.\n                   mem_idx x as = Some i \\<Longrightarrow>\n                   i < length as \\<and> as ! i = x;\n        mem_idx x (a # as) = Some i\\<rbrakk>\n       \\<Longrightarrow> i < length (a # as) \\<and> (a # as) ! i = x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a as i.\n       \\<lbrakk>\\<And>i.\n                   mem_idx x as = Some i \\<Longrightarrow>\n                   i < length as \\<and> as ! i = x;\n        mem_idx x (a # as) = Some i\\<rbrakk>\n       \\<Longrightarrow> i < length (a # as) \\<and> (a # as) ! i = x", "case (Cons a as)"], ["proof (state)\nthis:\n  mem_idx x as = Some ?i \\<Longrightarrow> ?i < length as \\<and> as ! ?i = x\n  mem_idx x (a # as) = Some i\n\ngoal (1 subgoal):\n 1. \\<And>a as i.\n       \\<lbrakk>\\<And>i.\n                   mem_idx x as = Some i \\<Longrightarrow>\n                   i < length as \\<and> as ! i = x;\n        mem_idx x (a # as) = Some i\\<rbrakk>\n       \\<Longrightarrow> i < length (a # as) \\<and> (a # as) ! i = x", "note IH = this"], ["proof (state)\nthis:\n  mem_idx x as = Some ?i \\<Longrightarrow> ?i < length as \\<and> as ! ?i = x\n  mem_idx x (a # as) = Some i\n\ngoal (1 subgoal):\n 1. \\<And>a as i.\n       \\<lbrakk>\\<And>i.\n                   mem_idx x as = Some i \\<Longrightarrow>\n                   i < length as \\<and> as ! i = x;\n        mem_idx x (a # as) = Some i\\<rbrakk>\n       \\<Longrightarrow> i < length (a # as) \\<and> (a # as) ! i = x", "thus ?case"], ["proof (prove)\nusing this:\n  mem_idx x as = Some ?i \\<Longrightarrow> ?i < length as \\<and> as ! ?i = x\n  mem_idx x (a # as) = Some i\n\ngoal (1 subgoal):\n 1. i < length (a # as) \\<and> (a # as) ! i = x", "proof (cases \"x = a\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>i.\n                mem_idx x as = Some i \\<Longrightarrow>\n                i < length as \\<and> as ! i = x;\n     mem_idx x (a # as) = Some i; x = a\\<rbrakk>\n    \\<Longrightarrow> i < length (a # as) \\<and> (a # as) ! i = x\n 2. \\<lbrakk>\\<And>i.\n                mem_idx x as = Some i \\<Longrightarrow>\n                i < length as \\<and> as ! i = x;\n     mem_idx x (a # as) = Some i; x \\<noteq> a\\<rbrakk>\n    \\<Longrightarrow> i < length (a # as) \\<and> (a # as) ! i = x", "case True"], ["proof (state)\nthis:\n  x = a\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>i.\n                mem_idx x as = Some i \\<Longrightarrow>\n                i < length as \\<and> as ! i = x;\n     mem_idx x (a # as) = Some i; x = a\\<rbrakk>\n    \\<Longrightarrow> i < length (a # as) \\<and> (a # as) ! i = x\n 2. \\<lbrakk>\\<And>i.\n                mem_idx x as = Some i \\<Longrightarrow>\n                i < length as \\<and> as ! i = x;\n     mem_idx x (a # as) = Some i; x \\<noteq> a\\<rbrakk>\n    \\<Longrightarrow> i < length (a # as) \\<and> (a # as) ! i = x", "with IH(2)"], ["proof (chain)\npicking this:\n  mem_idx x (a # as) = Some i\n  x = a", "show ?thesis"], ["proof (prove)\nusing this:\n  mem_idx x (a # as) = Some i\n  x = a\n\ngoal (1 subgoal):\n 1. i < length (a # as) \\<and> (a # as) ! i = x", "by simp"], ["proof (state)\nthis:\n  i < length (a # as) \\<and> (a # as) ! i = x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>i.\n                mem_idx x as = Some i \\<Longrightarrow>\n                i < length as \\<and> as ! i = x;\n     mem_idx x (a # as) = Some i; x \\<noteq> a\\<rbrakk>\n    \\<Longrightarrow> i < length (a # as) \\<and> (a # as) ! i = x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>i.\n                mem_idx x as = Some i \\<Longrightarrow>\n                i < length as \\<and> as ! i = x;\n     mem_idx x (a # as) = Some i; x \\<noteq> a\\<rbrakk>\n    \\<Longrightarrow> i < length (a # as) \\<and> (a # as) ! i = x", "case False"], ["proof (state)\nthis:\n  x \\<noteq> a\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>i.\n                mem_idx x as = Some i \\<Longrightarrow>\n                i < length as \\<and> as ! i = x;\n     mem_idx x (a # as) = Some i; x \\<noteq> a\\<rbrakk>\n    \\<Longrightarrow> i < length (a # as) \\<and> (a # as) ! i = x", "note neq_x_a = this"], ["proof (state)\nthis:\n  x \\<noteq> a\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>i.\n                mem_idx x as = Some i \\<Longrightarrow>\n                i < length as \\<and> as ! i = x;\n     mem_idx x (a # as) = Some i; x \\<noteq> a\\<rbrakk>\n    \\<Longrightarrow> i < length (a # as) \\<and> (a # as) ! i = x", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. i < length (a # as) \\<and> (a # as) ! i = x", "proof (cases \"mem_idx x as\")"], ["proof (state)\ngoal (2 subgoals):\n 1. mem_idx x as = None \\<Longrightarrow>\n    i < length (a # as) \\<and> (a # as) ! i = x\n 2. \\<And>aa.\n       mem_idx x as = Some aa \\<Longrightarrow>\n       i < length (a # as) \\<and> (a # as) ! i = x", "case None"], ["proof (state)\nthis:\n  mem_idx x as = None\n\ngoal (2 subgoals):\n 1. mem_idx x as = None \\<Longrightarrow>\n    i < length (a # as) \\<and> (a # as) ! i = x\n 2. \\<And>aa.\n       mem_idx x as = Some aa \\<Longrightarrow>\n       i < length (a # as) \\<and> (a # as) ! i = x", "with IH(2) and neq_x_a"], ["proof (chain)\npicking this:\n  mem_idx x (a # as) = Some i\n  x \\<noteq> a\n  mem_idx x as = None", "show ?thesis"], ["proof (prove)\nusing this:\n  mem_idx x (a # as) = Some i\n  x \\<noteq> a\n  mem_idx x as = None\n\ngoal (1 subgoal):\n 1. i < length (a # as) \\<and> (a # as) ! i = x", "by simp"], ["proof (state)\nthis:\n  i < length (a # as) \\<and> (a # as) ! i = x\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       mem_idx x as = Some aa \\<Longrightarrow>\n       i < length (a # as) \\<and> (a # as) ! i = x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa.\n       mem_idx x as = Some aa \\<Longrightarrow>\n       i < length (a # as) \\<and> (a # as) ! i = x", "case (Some j)"], ["proof (state)\nthis:\n  mem_idx x as = Some j\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       mem_idx x as = Some aa \\<Longrightarrow>\n       i < length (a # as) \\<and> (a # as) ! i = x", "with IH(2) and neq_x_a"], ["proof (chain)\npicking this:\n  mem_idx x (a # as) = Some i\n  x \\<noteq> a\n  mem_idx x as = Some j", "have \"i = Suc j\""], ["proof (prove)\nusing this:\n  mem_idx x (a # as) = Some i\n  x \\<noteq> a\n  mem_idx x as = Some j\n\ngoal (1 subgoal):\n 1. i = Suc j", "by simp"], ["proof (state)\nthis:\n  i = Suc j\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       mem_idx x as = Some aa \\<Longrightarrow>\n       i < length (a # as) \\<and> (a # as) ! i = x", "with IH(1) and Some"], ["proof (chain)\npicking this:\n  mem_idx x as = Some ?i \\<Longrightarrow> ?i < length as \\<and> as ! ?i = x\n  mem_idx x as = Some j\n  i = Suc j", "show ?thesis"], ["proof (prove)\nusing this:\n  mem_idx x as = Some ?i \\<Longrightarrow> ?i < length as \\<and> as ! ?i = x\n  mem_idx x as = Some j\n  i = Suc j\n\ngoal (1 subgoal):\n 1. i < length (a # as) \\<and> (a # as) ! i = x", "by simp"], ["proof (state)\nthis:\n  i < length (a # as) \\<and> (a # as) ! i = x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  i < length (a # as) \\<and> (a # as) ! i = x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  i < length (a # as) \\<and> (a # as) ! i = x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mem_idx_sound_output2:\n  assumes \"mem_idx x as = Some i\"\n  shows \"\\<forall>j. j < i \\<longrightarrow> as ! j \\<noteq> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>j<i. as ! j \\<noteq> x", "using assms"], ["proof (prove)\nusing this:\n  mem_idx x as = Some i\n\ngoal (1 subgoal):\n 1. \\<forall>j<i. as ! j \\<noteq> x", "proof (induct as arbitrary: i)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i.\n       mem_idx x [] = Some i \\<Longrightarrow>\n       \\<forall>j<i. [] ! j \\<noteq> x\n 2. \\<And>a as i.\n       \\<lbrakk>\\<And>i.\n                   mem_idx x as = Some i \\<Longrightarrow>\n                   \\<forall>j<i. as ! j \\<noteq> x;\n        mem_idx x (a # as) = Some i\\<rbrakk>\n       \\<Longrightarrow> \\<forall>j<i. (a # as) ! j \\<noteq> x", "case Nil"], ["proof (state)\nthis:\n  mem_idx x [] = Some i\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       mem_idx x [] = Some i \\<Longrightarrow>\n       \\<forall>j<i. [] ! j \\<noteq> x\n 2. \\<And>a as i.\n       \\<lbrakk>\\<And>i.\n                   mem_idx x as = Some i \\<Longrightarrow>\n                   \\<forall>j<i. as ! j \\<noteq> x;\n        mem_idx x (a # as) = Some i\\<rbrakk>\n       \\<Longrightarrow> \\<forall>j<i. (a # as) ! j \\<noteq> x", "thus ?case"], ["proof (prove)\nusing this:\n  mem_idx x [] = Some i\n\ngoal (1 subgoal):\n 1. \\<forall>j<i. [] ! j \\<noteq> x", "by simp"], ["proof (state)\nthis:\n  \\<forall>j<i. [] ! j \\<noteq> x\n\ngoal (1 subgoal):\n 1. \\<And>a as i.\n       \\<lbrakk>\\<And>i.\n                   mem_idx x as = Some i \\<Longrightarrow>\n                   \\<forall>j<i. as ! j \\<noteq> x;\n        mem_idx x (a # as) = Some i\\<rbrakk>\n       \\<Longrightarrow> \\<forall>j<i. (a # as) ! j \\<noteq> x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a as i.\n       \\<lbrakk>\\<And>i.\n                   mem_idx x as = Some i \\<Longrightarrow>\n                   \\<forall>j<i. as ! j \\<noteq> x;\n        mem_idx x (a # as) = Some i\\<rbrakk>\n       \\<Longrightarrow> \\<forall>j<i. (a # as) ! j \\<noteq> x", "case (Cons a as)"], ["proof (state)\nthis:\n  mem_idx x as = Some ?i \\<Longrightarrow> \\<forall>j<?i. as ! j \\<noteq> x\n  mem_idx x (a # as) = Some i\n\ngoal (1 subgoal):\n 1. \\<And>a as i.\n       \\<lbrakk>\\<And>i.\n                   mem_idx x as = Some i \\<Longrightarrow>\n                   \\<forall>j<i. as ! j \\<noteq> x;\n        mem_idx x (a # as) = Some i\\<rbrakk>\n       \\<Longrightarrow> \\<forall>j<i. (a # as) ! j \\<noteq> x", "note IH = this"], ["proof (state)\nthis:\n  mem_idx x as = Some ?i \\<Longrightarrow> \\<forall>j<?i. as ! j \\<noteq> x\n  mem_idx x (a # as) = Some i\n\ngoal (1 subgoal):\n 1. \\<And>a as i.\n       \\<lbrakk>\\<And>i.\n                   mem_idx x as = Some i \\<Longrightarrow>\n                   \\<forall>j<i. as ! j \\<noteq> x;\n        mem_idx x (a # as) = Some i\\<rbrakk>\n       \\<Longrightarrow> \\<forall>j<i. (a # as) ! j \\<noteq> x", "thus ?case"], ["proof (prove)\nusing this:\n  mem_idx x as = Some ?i \\<Longrightarrow> \\<forall>j<?i. as ! j \\<noteq> x\n  mem_idx x (a # as) = Some i\n\ngoal (1 subgoal):\n 1. \\<forall>j<i. (a # as) ! j \\<noteq> x", "proof (cases \"x = a\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>i.\n                mem_idx x as = Some i \\<Longrightarrow>\n                \\<forall>j<i. as ! j \\<noteq> x;\n     mem_idx x (a # as) = Some i; x = a\\<rbrakk>\n    \\<Longrightarrow> \\<forall>j<i. (a # as) ! j \\<noteq> x\n 2. \\<lbrakk>\\<And>i.\n                mem_idx x as = Some i \\<Longrightarrow>\n                \\<forall>j<i. as ! j \\<noteq> x;\n     mem_idx x (a # as) = Some i; x \\<noteq> a\\<rbrakk>\n    \\<Longrightarrow> \\<forall>j<i. (a # as) ! j \\<noteq> x", "case True"], ["proof (state)\nthis:\n  x = a\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>i.\n                mem_idx x as = Some i \\<Longrightarrow>\n                \\<forall>j<i. as ! j \\<noteq> x;\n     mem_idx x (a # as) = Some i; x = a\\<rbrakk>\n    \\<Longrightarrow> \\<forall>j<i. (a # as) ! j \\<noteq> x\n 2. \\<lbrakk>\\<And>i.\n                mem_idx x as = Some i \\<Longrightarrow>\n                \\<forall>j<i. as ! j \\<noteq> x;\n     mem_idx x (a # as) = Some i; x \\<noteq> a\\<rbrakk>\n    \\<Longrightarrow> \\<forall>j<i. (a # as) ! j \\<noteq> x", "with IH"], ["proof (chain)\npicking this:\n  mem_idx x as = Some ?i \\<Longrightarrow> \\<forall>j<?i. as ! j \\<noteq> x\n  mem_idx x (a # as) = Some i\n  x = a", "show ?thesis"], ["proof (prove)\nusing this:\n  mem_idx x as = Some ?i \\<Longrightarrow> \\<forall>j<?i. as ! j \\<noteq> x\n  mem_idx x (a # as) = Some i\n  x = a\n\ngoal (1 subgoal):\n 1. \\<forall>j<i. (a # as) ! j \\<noteq> x", "by simp"], ["proof (state)\nthis:\n  \\<forall>j<i. (a # as) ! j \\<noteq> x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>i.\n                mem_idx x as = Some i \\<Longrightarrow>\n                \\<forall>j<i. as ! j \\<noteq> x;\n     mem_idx x (a # as) = Some i; x \\<noteq> a\\<rbrakk>\n    \\<Longrightarrow> \\<forall>j<i. (a # as) ! j \\<noteq> x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>i.\n                mem_idx x as = Some i \\<Longrightarrow>\n                \\<forall>j<i. as ! j \\<noteq> x;\n     mem_idx x (a # as) = Some i; x \\<noteq> a\\<rbrakk>\n    \\<Longrightarrow> \\<forall>j<i. (a # as) ! j \\<noteq> x", "case False"], ["proof (state)\nthis:\n  x \\<noteq> a\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>i.\n                mem_idx x as = Some i \\<Longrightarrow>\n                \\<forall>j<i. as ! j \\<noteq> x;\n     mem_idx x (a # as) = Some i; x \\<noteq> a\\<rbrakk>\n    \\<Longrightarrow> \\<forall>j<i. (a # as) ! j \\<noteq> x", "note neq_x_a = this"], ["proof (state)\nthis:\n  x \\<noteq> a\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>i.\n                mem_idx x as = Some i \\<Longrightarrow>\n                \\<forall>j<i. as ! j \\<noteq> x;\n     mem_idx x (a # as) = Some i; x \\<noteq> a\\<rbrakk>\n    \\<Longrightarrow> \\<forall>j<i. (a # as) ! j \\<noteq> x", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>j<i. (a # as) ! j \\<noteq> x", "proof (cases \"mem_idx x as\")"], ["proof (state)\ngoal (2 subgoals):\n 1. mem_idx x as = None \\<Longrightarrow>\n    \\<forall>j<i. (a # as) ! j \\<noteq> x\n 2. \\<And>aa.\n       mem_idx x as = Some aa \\<Longrightarrow>\n       \\<forall>j<i. (a # as) ! j \\<noteq> x", "case None"], ["proof (state)\nthis:\n  mem_idx x as = None\n\ngoal (2 subgoals):\n 1. mem_idx x as = None \\<Longrightarrow>\n    \\<forall>j<i. (a # as) ! j \\<noteq> x\n 2. \\<And>aa.\n       mem_idx x as = Some aa \\<Longrightarrow>\n       \\<forall>j<i. (a # as) ! j \\<noteq> x", "with IH(2) and neq_x_a"], ["proof (chain)\npicking this:\n  mem_idx x (a # as) = Some i\n  x \\<noteq> a\n  mem_idx x as = None", "show ?thesis"], ["proof (prove)\nusing this:\n  mem_idx x (a # as) = Some i\n  x \\<noteq> a\n  mem_idx x as = None\n\ngoal (1 subgoal):\n 1. \\<forall>j<i. (a # as) ! j \\<noteq> x", "by simp"], ["proof (state)\nthis:\n  \\<forall>j<i. (a # as) ! j \\<noteq> x\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       mem_idx x as = Some aa \\<Longrightarrow>\n       \\<forall>j<i. (a # as) ! j \\<noteq> x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa.\n       mem_idx x as = Some aa \\<Longrightarrow>\n       \\<forall>j<i. (a # as) ! j \\<noteq> x", "case (Some j)"], ["proof (state)\nthis:\n  mem_idx x as = Some j\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       mem_idx x as = Some aa \\<Longrightarrow>\n       \\<forall>j<i. (a # as) ! j \\<noteq> x", "with IH(2) and neq_x_a"], ["proof (chain)\npicking this:\n  mem_idx x (a # as) = Some i\n  x \\<noteq> a\n  mem_idx x as = Some j", "have eq_i_Sj: \"i = Suc j\""], ["proof (prove)\nusing this:\n  mem_idx x (a # as) = Some i\n  x \\<noteq> a\n  mem_idx x as = Some j\n\ngoal (1 subgoal):\n 1. i = Suc j", "by simp"], ["proof (state)\nthis:\n  i = Suc j\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       mem_idx x as = Some aa \\<Longrightarrow>\n       \\<forall>j<i. (a # as) ! j \\<noteq> x", "{"], ["proof (state)\nthis:\n  i = Suc j\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       mem_idx x as = Some aa \\<Longrightarrow>\n       \\<forall>j<i. (a # as) ! j \\<noteq> x", "fix k"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa.\n       mem_idx x as = Some aa \\<Longrightarrow>\n       \\<forall>j<i. (a # as) ! j \\<noteq> x", "assume k_bd: \"k < i\""], ["proof (state)\nthis:\n  k < i\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       mem_idx x as = Some aa \\<Longrightarrow>\n       \\<forall>j<i. (a # as) ! j \\<noteq> x", "have \"(a # as) ! k \\<noteq> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a # as) ! k \\<noteq> x", "proof (cases k)"], ["proof (state)\ngoal (2 subgoals):\n 1. k = 0 \\<Longrightarrow> (a # as) ! k \\<noteq> x\n 2. \\<And>nat. k = Suc nat \\<Longrightarrow> (a # as) ! k \\<noteq> x", "case 0"], ["proof (state)\nthis:\n  k = 0\n\ngoal (2 subgoals):\n 1. k = 0 \\<Longrightarrow> (a # as) ! k \\<noteq> x\n 2. \\<And>nat. k = Suc nat \\<Longrightarrow> (a # as) ! k \\<noteq> x", "with neq_x_a"], ["proof (chain)\npicking this:\n  x \\<noteq> a\n  k = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  x \\<noteq> a\n  k = 0\n\ngoal (1 subgoal):\n 1. (a # as) ! k \\<noteq> x", "by simp"], ["proof (state)\nthis:\n  (a # as) ! k \\<noteq> x\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> (a # as) ! k \\<noteq> x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> (a # as) ! k \\<noteq> x", "case (Suc l)"], ["proof (state)\nthis:\n  k = Suc l\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> (a # as) ! k \\<noteq> x", "with k_bd and eq_i_Sj"], ["proof (chain)\npicking this:\n  k < i\n  i = Suc j\n  k = Suc l", "have l_bd: \"l < j\""], ["proof (prove)\nusing this:\n  k < i\n  i = Suc j\n  k = Suc l\n\ngoal (1 subgoal):\n 1. l < j", "by arith"], ["proof (state)\nthis:\n  l < j\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> (a # as) ! k \\<noteq> x", "with IH(1) and Some"], ["proof (chain)\npicking this:\n  mem_idx x as = Some ?i \\<Longrightarrow> \\<forall>j<?i. as ! j \\<noteq> x\n  mem_idx x as = Some j\n  l < j", "have \"as ! l \\<noteq> x\""], ["proof (prove)\nusing this:\n  mem_idx x as = Some ?i \\<Longrightarrow> \\<forall>j<?i. as ! j \\<noteq> x\n  mem_idx x as = Some j\n  l < j\n\ngoal (1 subgoal):\n 1. as ! l \\<noteq> x", "by simp"], ["proof (state)\nthis:\n  as ! l \\<noteq> x\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> (a # as) ! k \\<noteq> x", "with Suc"], ["proof (chain)\npicking this:\n  k = Suc l\n  as ! l \\<noteq> x", "show ?thesis"], ["proof (prove)\nusing this:\n  k = Suc l\n  as ! l \\<noteq> x\n\ngoal (1 subgoal):\n 1. (a # as) ! k \\<noteq> x", "by simp"], ["proof (state)\nthis:\n  (a # as) ! k \\<noteq> x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (a # as) ! k \\<noteq> x\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       mem_idx x as = Some aa \\<Longrightarrow>\n       \\<forall>j<i. (a # as) ! j \\<noteq> x", "}"], ["proof (state)\nthis:\n  ?k2 < i \\<Longrightarrow> (a # as) ! ?k2 \\<noteq> x\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       mem_idx x as = Some aa \\<Longrightarrow>\n       \\<forall>j<i. (a # as) ! j \\<noteq> x", "thus ?thesis"], ["proof (prove)\nusing this:\n  ?k2 < i \\<Longrightarrow> (a # as) ! ?k2 \\<noteq> x\n\ngoal (1 subgoal):\n 1. \\<forall>j<i. (a # as) ! j \\<noteq> x", "by simp"], ["proof (state)\nthis:\n  \\<forall>j<i. (a # as) ! j \\<noteq> x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>j<i. (a # as) ! j \\<noteq> x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>j<i. (a # as) ! j \\<noteq> x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mem_idx_sound:\n \"(x \\<in> set as) = (\\<exists>i. mem_idx x as = Some i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in> set as) = (\\<exists>i. mem_idx x as = Some i)", "proof (induct as)"], ["proof (state)\ngoal (2 subgoals):\n 1. (x \\<in> set []) = (\\<exists>i. mem_idx x [] = Some i)\n 2. \\<And>a as.\n       (x \\<in> set as) =\n       (\\<exists>i. mem_idx x as = Some i) \\<Longrightarrow>\n       (x \\<in> set (a # as)) = (\\<exists>i. mem_idx x (a # as) = Some i)", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. (x \\<in> set []) = (\\<exists>i. mem_idx x [] = Some i)\n 2. \\<And>a as.\n       (x \\<in> set as) =\n       (\\<exists>i. mem_idx x as = Some i) \\<Longrightarrow>\n       (x \\<in> set (a # as)) = (\\<exists>i. mem_idx x (a # as) = Some i)", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in> set []) = (\\<exists>i. mem_idx x [] = Some i)", "by simp"], ["proof (state)\nthis:\n  (x \\<in> set []) = (\\<exists>i. mem_idx x [] = Some i)\n\ngoal (1 subgoal):\n 1. \\<And>a as.\n       (x \\<in> set as) =\n       (\\<exists>i. mem_idx x as = Some i) \\<Longrightarrow>\n       (x \\<in> set (a # as)) = (\\<exists>i. mem_idx x (a # as) = Some i)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a as.\n       (x \\<in> set as) =\n       (\\<exists>i. mem_idx x as = Some i) \\<Longrightarrow>\n       (x \\<in> set (a # as)) = (\\<exists>i. mem_idx x (a # as) = Some i)", "case (Cons a as)"], ["proof (state)\nthis:\n  (x \\<in> set as) = (\\<exists>i. mem_idx x as = Some i)\n\ngoal (1 subgoal):\n 1. \\<And>a as.\n       (x \\<in> set as) =\n       (\\<exists>i. mem_idx x as = Some i) \\<Longrightarrow>\n       (x \\<in> set (a # as)) = (\\<exists>i. mem_idx x (a # as) = Some i)", "note IH = this"], ["proof (state)\nthis:\n  (x \\<in> set as) = (\\<exists>i. mem_idx x as = Some i)\n\ngoal (1 subgoal):\n 1. \\<And>a as.\n       (x \\<in> set as) =\n       (\\<exists>i. mem_idx x as = Some i) \\<Longrightarrow>\n       (x \\<in> set (a # as)) = (\\<exists>i. mem_idx x (a # as) = Some i)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in> set (a # as)) = (\\<exists>i. mem_idx x (a # as) = Some i)", "proof (cases \"x = a\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x = a \\<Longrightarrow>\n    (x \\<in> set (a # as)) = (\\<exists>i. mem_idx x (a # as) = Some i)\n 2. x \\<noteq> a \\<Longrightarrow>\n    (x \\<in> set (a # as)) = (\\<exists>i. mem_idx x (a # as) = Some i)", "case True"], ["proof (state)\nthis:\n  x = a\n\ngoal (2 subgoals):\n 1. x = a \\<Longrightarrow>\n    (x \\<in> set (a # as)) = (\\<exists>i. mem_idx x (a # as) = Some i)\n 2. x \\<noteq> a \\<Longrightarrow>\n    (x \\<in> set (a # as)) = (\\<exists>i. mem_idx x (a # as) = Some i)", "thus ?thesis"], ["proof (prove)\nusing this:\n  x = a\n\ngoal (1 subgoal):\n 1. (x \\<in> set (a # as)) = (\\<exists>i. mem_idx x (a # as) = Some i)", "by simp"], ["proof (state)\nthis:\n  (x \\<in> set (a # as)) = (\\<exists>i. mem_idx x (a # as) = Some i)\n\ngoal (1 subgoal):\n 1. x \\<noteq> a \\<Longrightarrow>\n    (x \\<in> set (a # as)) = (\\<exists>i. mem_idx x (a # as) = Some i)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<noteq> a \\<Longrightarrow>\n    (x \\<in> set (a # as)) = (\\<exists>i. mem_idx x (a # as) = Some i)", "case False"], ["proof (state)\nthis:\n  x \\<noteq> a\n\ngoal (1 subgoal):\n 1. x \\<noteq> a \\<Longrightarrow>\n    (x \\<in> set (a # as)) = (\\<exists>i. mem_idx x (a # as) = Some i)", "{"], ["proof (state)\nthis:\n  x \\<noteq> a\n\ngoal (1 subgoal):\n 1. x \\<noteq> a \\<Longrightarrow>\n    (x \\<in> set (a # as)) = (\\<exists>i. mem_idx x (a # as) = Some i)", "assume \"x \\<in> set (a # as)\""], ["proof (state)\nthis:\n  x \\<in> set (a # as)\n\ngoal (1 subgoal):\n 1. x \\<noteq> a \\<Longrightarrow>\n    (x \\<in> set (a # as)) = (\\<exists>i. mem_idx x (a # as) = Some i)", "with False"], ["proof (chain)\npicking this:\n  x \\<noteq> a\n  x \\<in> set (a # as)", "have \"x \\<in> set as\""], ["proof (prove)\nusing this:\n  x \\<noteq> a\n  x \\<in> set (a # as)\n\ngoal (1 subgoal):\n 1. x \\<in> set as", "by simp"], ["proof (state)\nthis:\n  x \\<in> set as\n\ngoal (1 subgoal):\n 1. x \\<noteq> a \\<Longrightarrow>\n    (x \\<in> set (a # as)) = (\\<exists>i. mem_idx x (a # as) = Some i)", "with IH"], ["proof (chain)\npicking this:\n  (x \\<in> set as) = (\\<exists>i. mem_idx x as = Some i)\n  x \\<in> set as", "obtain i where Some_i: \"mem_idx x as = Some i\""], ["proof (prove)\nusing this:\n  (x \\<in> set as) = (\\<exists>i. mem_idx x as = Some i)\n  x \\<in> set as\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        mem_idx x as = Some i \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  mem_idx x as = Some i\n\ngoal (1 subgoal):\n 1. x \\<noteq> a \\<Longrightarrow>\n    (x \\<in> set (a # as)) = (\\<exists>i. mem_idx x (a # as) = Some i)", "with False"], ["proof (chain)\npicking this:\n  x \\<noteq> a\n  mem_idx x as = Some i", "have \"mem_idx x (a # as) = Some (Suc i)\""], ["proof (prove)\nusing this:\n  x \\<noteq> a\n  mem_idx x as = Some i\n\ngoal (1 subgoal):\n 1. mem_idx x (a # as) = Some (Suc i)", "by simp"], ["proof (state)\nthis:\n  mem_idx x (a # as) = Some (Suc i)\n\ngoal (1 subgoal):\n 1. x \\<noteq> a \\<Longrightarrow>\n    (x \\<in> set (a # as)) = (\\<exists>i. mem_idx x (a # as) = Some i)", "hence \"\\<exists>i. mem_idx x (a # as) = Some i\""], ["proof (prove)\nusing this:\n  mem_idx x (a # as) = Some (Suc i)\n\ngoal (1 subgoal):\n 1. \\<exists>i. mem_idx x (a # as) = Some i", "by simp"], ["proof (state)\nthis:\n  \\<exists>i. mem_idx x (a # as) = Some i\n\ngoal (1 subgoal):\n 1. x \\<noteq> a \\<Longrightarrow>\n    (x \\<in> set (a # as)) = (\\<exists>i. mem_idx x (a # as) = Some i)", "}"], ["proof (state)\nthis:\n  x \\<in> set (a # as) \\<Longrightarrow>\n  \\<exists>i. mem_idx x (a # as) = Some i\n\ngoal (1 subgoal):\n 1. x \\<noteq> a \\<Longrightarrow>\n    (x \\<in> set (a # as)) = (\\<exists>i. mem_idx x (a # as) = Some i)", "moreover"], ["proof (state)\nthis:\n  x \\<in> set (a # as) \\<Longrightarrow>\n  \\<exists>i. mem_idx x (a # as) = Some i\n\ngoal (1 subgoal):\n 1. x \\<noteq> a \\<Longrightarrow>\n    (x \\<in> set (a # as)) = (\\<exists>i. mem_idx x (a # as) = Some i)", "{"], ["proof (state)\nthis:\n  x \\<in> set (a # as) \\<Longrightarrow>\n  \\<exists>i. mem_idx x (a # as) = Some i\n\ngoal (1 subgoal):\n 1. x \\<noteq> a \\<Longrightarrow>\n    (x \\<in> set (a # as)) = (\\<exists>i. mem_idx x (a # as) = Some i)", "assume \"\\<exists>i. mem_idx x (a # as) = Some i\""], ["proof (state)\nthis:\n  \\<exists>i. mem_idx x (a # as) = Some i\n\ngoal (1 subgoal):\n 1. x \\<noteq> a \\<Longrightarrow>\n    (x \\<in> set (a # as)) = (\\<exists>i. mem_idx x (a # as) = Some i)", "then"], ["proof (chain)\npicking this:\n  \\<exists>i. mem_idx x (a # as) = Some i", "obtain i where Some_i: \"mem_idx x (a # as) = Some i\""], ["proof (prove)\nusing this:\n  \\<exists>i. mem_idx x (a # as) = Some i\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        mem_idx x (a # as) = Some i \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by fast"], ["proof (state)\nthis:\n  mem_idx x (a # as) = Some i\n\ngoal (1 subgoal):\n 1. x \\<noteq> a \\<Longrightarrow>\n    (x \\<in> set (a # as)) = (\\<exists>i. mem_idx x (a # as) = Some i)", "have \"x \\<in> set as\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> set as", "proof (cases i)"], ["proof (state)\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow> x \\<in> set as\n 2. \\<And>nat. i = Suc nat \\<Longrightarrow> x \\<in> set as", "case 0"], ["proof (state)\nthis:\n  i = 0\n\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow> x \\<in> set as\n 2. \\<And>nat. i = Suc nat \\<Longrightarrow> x \\<in> set as", "with mem_idx_sound_output[OF Some_i] and False"], ["proof (chain)\npicking this:\n  i < length (a # as) \\<and> (a # as) ! i = x\n  x \\<noteq> a\n  i = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  i < length (a # as) \\<and> (a # as) ! i = x\n  x \\<noteq> a\n  i = 0\n\ngoal (1 subgoal):\n 1. x \\<in> set as", "by simp"], ["proof (state)\nthis:\n  x \\<in> set as\n\ngoal (1 subgoal):\n 1. \\<And>nat. i = Suc nat \\<Longrightarrow> x \\<in> set as", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat. i = Suc nat \\<Longrightarrow> x \\<in> set as", "case (Suc j)"], ["proof (state)\nthis:\n  i = Suc j\n\ngoal (1 subgoal):\n 1. \\<And>nat. i = Suc nat \\<Longrightarrow> x \\<in> set as", "with Some_i and False"], ["proof (chain)\npicking this:\n  mem_idx x (a # as) = Some i\n  x \\<noteq> a\n  i = Suc j", "have \"mem_idx x as = Some j\""], ["proof (prove)\nusing this:\n  mem_idx x (a # as) = Some i\n  x \\<noteq> a\n  i = Suc j\n\ngoal (1 subgoal):\n 1. mem_idx x as = Some j", "by simp"], ["proof (state)\nthis:\n  mem_idx x as = Some j\n\ngoal (1 subgoal):\n 1. \\<And>nat. i = Suc nat \\<Longrightarrow> x \\<in> set as", "hence \"\\<exists>i. mem_idx x as = Some i\""], ["proof (prove)\nusing this:\n  mem_idx x as = Some j\n\ngoal (1 subgoal):\n 1. \\<exists>i. mem_idx x as = Some i", "by simp"], ["proof (state)\nthis:\n  \\<exists>i. mem_idx x as = Some i\n\ngoal (1 subgoal):\n 1. \\<And>nat. i = Suc nat \\<Longrightarrow> x \\<in> set as", "with IH"], ["proof (chain)\npicking this:\n  (x \\<in> set as) = (\\<exists>i. mem_idx x as = Some i)\n  \\<exists>i. mem_idx x as = Some i", "show ?thesis"], ["proof (prove)\nusing this:\n  (x \\<in> set as) = (\\<exists>i. mem_idx x as = Some i)\n  \\<exists>i. mem_idx x as = Some i\n\ngoal (1 subgoal):\n 1. x \\<in> set as", "by simp"], ["proof (state)\nthis:\n  x \\<in> set as\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x \\<in> set as\n\ngoal (1 subgoal):\n 1. x \\<noteq> a \\<Longrightarrow>\n    (x \\<in> set (a # as)) = (\\<exists>i. mem_idx x (a # as) = Some i)", "hence \"x \\<in> set (a # as)\""], ["proof (prove)\nusing this:\n  x \\<in> set as\n\ngoal (1 subgoal):\n 1. x \\<in> set (a # as)", "by simp"], ["proof (state)\nthis:\n  x \\<in> set (a # as)\n\ngoal (1 subgoal):\n 1. x \\<noteq> a \\<Longrightarrow>\n    (x \\<in> set (a # as)) = (\\<exists>i. mem_idx x (a # as) = Some i)", "}"], ["proof (state)\nthis:\n  \\<exists>i. mem_idx x (a # as) = Some i \\<Longrightarrow>\n  x \\<in> set (a # as)\n\ngoal (1 subgoal):\n 1. x \\<noteq> a \\<Longrightarrow>\n    (x \\<in> set (a # as)) = (\\<exists>i. mem_idx x (a # as) = Some i)", "ultimately"], ["proof (chain)\npicking this:\n  x \\<in> set (a # as) \\<Longrightarrow>\n  \\<exists>i. mem_idx x (a # as) = Some i\n  \\<exists>i. mem_idx x (a # as) = Some i \\<Longrightarrow>\n  x \\<in> set (a # as)", "show ?thesis"], ["proof (prove)\nusing this:\n  x \\<in> set (a # as) \\<Longrightarrow>\n  \\<exists>i. mem_idx x (a # as) = Some i\n  \\<exists>i. mem_idx x (a # as) = Some i \\<Longrightarrow>\n  x \\<in> set (a # as)\n\ngoal (1 subgoal):\n 1. (x \\<in> set (a # as)) = (\\<exists>i. mem_idx x (a # as) = Some i)", "by fast"], ["proof (state)\nthis:\n  (x \\<in> set (a # as)) = (\\<exists>i. mem_idx x (a # as) = Some i)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (x \\<in> set (a # as)) = (\\<exists>i. mem_idx x (a # as) = Some i)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mem_idx_sound2:\n  \"(x \\<notin> set as) = (mem_idx x as = None)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<notin> set as) = (mem_idx x as = None)", "unfolding mem_idx_sound"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<nexists>i. mem_idx x as = Some i) = (mem_idx x as = None)", "by auto"], ["", "lemma sum_list_replicate_mono: assumes \"w1 \\<le> (w2 :: nat)\"\n  shows \"sum_list (replicate n w1) \\<le> sum_list (replicate n w2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list (replicate n w1) \\<le> sum_list (replicate n w2)", "proof (induct n)"], ["proof (state)\ngoal (2 subgoals):\n 1. sum_list (replicate 0 w1) \\<le> sum_list (replicate 0 w2)\n 2. \\<And>n.\n       sum_list (replicate n w1)\n       \\<le> sum_list (replicate n w2) \\<Longrightarrow>\n       sum_list (replicate (Suc n) w1) \\<le> sum_list (replicate (Suc n) w2)", "case (Suc n)"], ["proof (state)\nthis:\n  sum_list (replicate n w1) \\<le> sum_list (replicate n w2)\n\ngoal (2 subgoals):\n 1. sum_list (replicate 0 w1) \\<le> sum_list (replicate 0 w2)\n 2. \\<And>n.\n       sum_list (replicate n w1)\n       \\<le> sum_list (replicate n w2) \\<Longrightarrow>\n       sum_list (replicate (Suc n) w1) \\<le> sum_list (replicate (Suc n) w2)", "thus ?case"], ["proof (prove)\nusing this:\n  sum_list (replicate n w1) \\<le> sum_list (replicate n w2)\n\ngoal (1 subgoal):\n 1. sum_list (replicate (Suc n) w1) \\<le> sum_list (replicate (Suc n) w2)", "using \\<open>w1 \\<le> w2\\<close>"], ["proof (prove)\nusing this:\n  sum_list (replicate n w1) \\<le> sum_list (replicate n w2)\n  w1 \\<le> w2\n\ngoal (1 subgoal):\n 1. sum_list (replicate (Suc n) w1) \\<le> sum_list (replicate (Suc n) w2)", "by auto"], ["proof (state)\nthis:\n  sum_list (replicate (Suc n) w1) \\<le> sum_list (replicate (Suc n) w2)\n\ngoal (1 subgoal):\n 1. sum_list (replicate 0 w1) \\<le> sum_list (replicate 0 w2)", "qed simp"], ["", "lemma all_gt_0_sum_list_map:\n  assumes *: \"\\<And>x. f x > (0::nat)\"\n    and x: \"x \\<in> set xs\" and len: \"1 < length xs\"\n  shows \"f x < (\\<Sum>x\\<leftarrow>xs. f x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f x < sum_list (map f xs)", "using x len"], ["proof (prove)\nusing this:\n  x \\<in> set xs\n  1 < length xs\n\ngoal (1 subgoal):\n 1. f x < sum_list (map f xs)", "proof (induct xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<in> set []; 1 < length []\\<rbrakk>\n    \\<Longrightarrow> f x < sum_list (map f [])\n 2. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>x \\<in> set xs; 1 < length xs\\<rbrakk>\n                \\<Longrightarrow> f x < sum_list (map f xs);\n        x \\<in> set (a # xs); 1 < length (a # xs)\\<rbrakk>\n       \\<Longrightarrow> f x < sum_list (map f (a # xs))", "case (Cons y xs)"], ["proof (state)\nthis:\n  \\<lbrakk>x \\<in> set xs; 1 < length xs\\<rbrakk>\n  \\<Longrightarrow> f x < sum_list (map f xs)\n  x \\<in> set (y # xs)\n  1 < length (y # xs)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<in> set []; 1 < length []\\<rbrakk>\n    \\<Longrightarrow> f x < sum_list (map f [])\n 2. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>x \\<in> set xs; 1 < length xs\\<rbrakk>\n                \\<Longrightarrow> f x < sum_list (map f xs);\n        x \\<in> set (a # xs); 1 < length (a # xs)\\<rbrakk>\n       \\<Longrightarrow> f x < sum_list (map f (a # xs))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. f x < sum_list (map f (y # xs))", "proof (cases \"y = x\")"], ["proof (state)\ngoal (2 subgoals):\n 1. y = x \\<Longrightarrow> f x < sum_list (map f (y # xs))\n 2. y \\<noteq> x \\<Longrightarrow> f x < sum_list (map f (y # xs))", "case True"], ["proof (state)\nthis:\n  y = x\n\ngoal (2 subgoals):\n 1. y = x \\<Longrightarrow> f x < sum_list (map f (y # xs))\n 2. y \\<noteq> x \\<Longrightarrow> f x < sum_list (map f (y # xs))", "with *[of \"hd xs\"] Cons(3)"], ["proof (chain)\npicking this:\n  0 < f (hd xs)\n  1 < length (y # xs)\n  y = x", "show ?thesis"], ["proof (prove)\nusing this:\n  0 < f (hd xs)\n  1 < length (y # xs)\n  y = x\n\ngoal (1 subgoal):\n 1. f x < sum_list (map f (y # xs))", "by (cases xs, auto)"], ["proof (state)\nthis:\n  f x < sum_list (map f (y # xs))\n\ngoal (1 subgoal):\n 1. y \\<noteq> x \\<Longrightarrow> f x < sum_list (map f (y # xs))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. y \\<noteq> x \\<Longrightarrow> f x < sum_list (map f (y # xs))", "case False"], ["proof (state)\nthis:\n  y \\<noteq> x\n\ngoal (1 subgoal):\n 1. y \\<noteq> x \\<Longrightarrow> f x < sum_list (map f (y # xs))", "with Cons(2)"], ["proof (chain)\npicking this:\n  x \\<in> set (y # xs)\n  y \\<noteq> x", "have x: \"x \\<in> set xs\""], ["proof (prove)\nusing this:\n  x \\<in> set (y # xs)\n  y \\<noteq> x\n\ngoal (1 subgoal):\n 1. x \\<in> set xs", "by auto"], ["proof (state)\nthis:\n  x \\<in> set xs\n\ngoal (1 subgoal):\n 1. y \\<noteq> x \\<Longrightarrow> f x < sum_list (map f (y # xs))", "then"], ["proof (chain)\npicking this:\n  x \\<in> set xs", "obtain z zs where xs: \"xs = z # zs\""], ["proof (prove)\nusing this:\n  x \\<in> set xs\n\ngoal (1 subgoal):\n 1. (\\<And>z zs. xs = z # zs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases xs, auto)"], ["proof (state)\nthis:\n  xs = z # zs\n\ngoal (1 subgoal):\n 1. y \\<noteq> x \\<Longrightarrow> f x < sum_list (map f (y # xs))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. f x < sum_list (map f (y # xs))", "proof (cases \"length zs\")"], ["proof (state)\ngoal (2 subgoals):\n 1. length zs = 0 \\<Longrightarrow> f x < sum_list (map f (y # xs))\n 2. \\<And>nat.\n       length zs = Suc nat \\<Longrightarrow> f x < sum_list (map f (y # xs))", "case 0"], ["proof (state)\nthis:\n  length zs = 0\n\ngoal (2 subgoals):\n 1. length zs = 0 \\<Longrightarrow> f x < sum_list (map f (y # xs))\n 2. \\<And>nat.\n       length zs = Suc nat \\<Longrightarrow> f x < sum_list (map f (y # xs))", "with x xs *[of y]"], ["proof (chain)\npicking this:\n  x \\<in> set xs\n  xs = z # zs\n  0 < f y\n  length zs = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  x \\<in> set xs\n  xs = z # zs\n  0 < f y\n  length zs = 0\n\ngoal (1 subgoal):\n 1. f x < sum_list (map f (y # xs))", "by auto"], ["proof (state)\nthis:\n  f x < sum_list (map f (y # xs))\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       length zs = Suc nat \\<Longrightarrow> f x < sum_list (map f (y # xs))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       length zs = Suc nat \\<Longrightarrow> f x < sum_list (map f (y # xs))", "case (Suc n)"], ["proof (state)\nthis:\n  length zs = Suc n\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       length zs = Suc nat \\<Longrightarrow> f x < sum_list (map f (y # xs))", "with xs"], ["proof (chain)\npicking this:\n  xs = z # zs\n  length zs = Suc n", "have \"1 < length xs\""], ["proof (prove)\nusing this:\n  xs = z # zs\n  length zs = Suc n\n\ngoal (1 subgoal):\n 1. 1 < length xs", "by auto"], ["proof (state)\nthis:\n  1 < length xs\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       length zs = Suc nat \\<Longrightarrow> f x < sum_list (map f (y # xs))", "from Cons(1)[OF x this]"], ["proof (chain)\npicking this:\n  f x < sum_list (map f xs)", "show ?thesis"], ["proof (prove)\nusing this:\n  f x < sum_list (map f xs)\n\ngoal (1 subgoal):\n 1. f x < sum_list (map f (y # xs))", "by simp"], ["proof (state)\nthis:\n  f x < sum_list (map f (y # xs))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  f x < sum_list (map f (y # xs))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  f x < sum_list (map f (y # xs))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> set []; 1 < length []\\<rbrakk>\n    \\<Longrightarrow> f x < sum_list (map f [])", "qed simp"], ["", "lemma finite_distinct: \"finite { xs . distinct xs \\<and> set xs = X}\" (is \"finite (?S X)\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {xs. distinct xs \\<and> set xs = X}", "proof (cases \"finite X\")"], ["proof (state)\ngoal (2 subgoals):\n 1. finite X \\<Longrightarrow> finite {xs. distinct xs \\<and> set xs = X}\n 2. infinite X \\<Longrightarrow> finite {xs. distinct xs \\<and> set xs = X}", "case False"], ["proof (state)\nthis:\n  infinite X\n\ngoal (2 subgoals):\n 1. finite X \\<Longrightarrow> finite {xs. distinct xs \\<and> set xs = X}\n 2. infinite X \\<Longrightarrow> finite {xs. distinct xs \\<and> set xs = X}", "with finite_set"], ["proof (chain)\npicking this:\n  finite (set ?xs)\n  infinite X", "have id: \"?S X = {}\""], ["proof (prove)\nusing this:\n  finite (set ?xs)\n  infinite X\n\ngoal (1 subgoal):\n 1. {xs. distinct xs \\<and> set xs = X} = {}", "by auto"], ["proof (state)\nthis:\n  {xs. distinct xs \\<and> set xs = X} = {}\n\ngoal (2 subgoals):\n 1. finite X \\<Longrightarrow> finite {xs. distinct xs \\<and> set xs = X}\n 2. infinite X \\<Longrightarrow> finite {xs. distinct xs \\<and> set xs = X}", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {xs. distinct xs \\<and> set xs = X}", "unfolding id"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {}", "by auto"], ["proof (state)\nthis:\n  finite {xs. distinct xs \\<and> set xs = X}\n\ngoal (1 subgoal):\n 1. finite X \\<Longrightarrow> finite {xs. distinct xs \\<and> set xs = X}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. finite X \\<Longrightarrow> finite {xs. distinct xs \\<and> set xs = X}", "case True"], ["proof (state)\nthis:\n  finite X\n\ngoal (1 subgoal):\n 1. finite X \\<Longrightarrow> finite {xs. distinct xs \\<and> set xs = X}", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {xs. distinct xs \\<and> set xs = X}", "proof (induct rule: finite_induct[OF True])"], ["proof (state)\ngoal (2 subgoals):\n 1. finite {xs. distinct xs \\<and> set xs = {}}\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        finite {xs. distinct xs \\<and> set xs = F}\\<rbrakk>\n       \\<Longrightarrow> finite {xs. distinct xs \\<and> set xs = insert x F}", "case (2 x X)"], ["proof (state)\nthis:\n  finite X\n  x \\<notin> X\n  finite {xs. distinct xs \\<and> set xs = X}\n\ngoal (2 subgoals):\n 1. finite {xs. distinct xs \\<and> set xs = {}}\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        finite {xs. distinct xs \\<and> set xs = F}\\<rbrakk>\n       \\<Longrightarrow> finite {xs. distinct xs \\<and> set xs = insert x F}", "let ?L = \"{0..< card (insert x X)} \\<times> ?S X\""], ["proof (state)\ngoal (2 subgoals):\n 1. finite {xs. distinct xs \\<and> set xs = {}}\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        finite {xs. distinct xs \\<and> set xs = F}\\<rbrakk>\n       \\<Longrightarrow> finite {xs. distinct xs \\<and> set xs = insert x F}", "from 2(3)"], ["proof (chain)\npicking this:\n  finite {xs. distinct xs \\<and> set xs = X}", "have fin: \"finite ?L\""], ["proof (prove)\nusing this:\n  finite {xs. distinct xs \\<and> set xs = X}\n\ngoal (1 subgoal):\n 1. finite\n     ({0..<card (insert x X)} \\<times> {xs. distinct xs \\<and> set xs = X})", "by auto"], ["proof (state)\nthis:\n  finite\n   ({0..<card (insert x X)} \\<times> {xs. distinct xs \\<and> set xs = X})\n\ngoal (2 subgoals):\n 1. finite {xs. distinct xs \\<and> set xs = {}}\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        finite {xs. distinct xs \\<and> set xs = F}\\<rbrakk>\n       \\<Longrightarrow> finite {xs. distinct xs \\<and> set xs = insert x F}", "let ?f = \"\\<lambda> (i,xs). take i xs @ x # drop i xs\""], ["proof (state)\ngoal (2 subgoals):\n 1. finite {xs. distinct xs \\<and> set xs = {}}\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        finite {xs. distinct xs \\<and> set xs = F}\\<rbrakk>\n       \\<Longrightarrow> finite {xs. distinct xs \\<and> set xs = insert x F}", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {xs. distinct xs \\<and> set xs = insert x X}", "proof (rule finite_surj[OF fin, of _ ?f], rule)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> {xs.\n                 distinct xs \\<and> set xs = insert x X} \\<Longrightarrow>\n       xa \\<in> (\\<lambda>(i, xs). take i xs @ x # drop i xs) `\n                ({0..<card (insert x X)} \\<times>\n                 {xs. distinct xs \\<and> set xs = X})", "fix xs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> {xs.\n                 distinct xs \\<and> set xs = insert x X} \\<Longrightarrow>\n       xa \\<in> (\\<lambda>(i, xs). take i xs @ x # drop i xs) `\n                ({0..<card (insert x X)} \\<times>\n                 {xs. distinct xs \\<and> set xs = X})", "assume \"xs \\<in> ?S (insert x X)\""], ["proof (state)\nthis:\n  xs \\<in> {xs. distinct xs \\<and> set xs = insert x X}\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> {xs.\n                 distinct xs \\<and> set xs = insert x X} \\<Longrightarrow>\n       xa \\<in> (\\<lambda>(i, xs). take i xs @ x # drop i xs) `\n                ({0..<card (insert x X)} \\<times>\n                 {xs. distinct xs \\<and> set xs = X})", "hence dis: \"distinct xs\" and set: \"set xs = insert x X\""], ["proof (prove)\nusing this:\n  xs \\<in> {xs. distinct xs \\<and> set xs = insert x X}\n\ngoal (1 subgoal):\n 1. distinct xs &&& set xs = insert x X", "by auto"], ["proof (state)\nthis:\n  distinct xs\n  set xs = insert x X\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> {xs.\n                 distinct xs \\<and> set xs = insert x X} \\<Longrightarrow>\n       xa \\<in> (\\<lambda>(i, xs). take i xs @ x # drop i xs) `\n                ({0..<card (insert x X)} \\<times>\n                 {xs. distinct xs \\<and> set xs = X})", "from distinct_card[OF dis]"], ["proof (chain)\npicking this:\n  card (set xs) = length xs", "have len: \"length xs = card (set xs)\""], ["proof (prove)\nusing this:\n  card (set xs) = length xs\n\ngoal (1 subgoal):\n 1. length xs = card (set xs)", "by auto"], ["proof (state)\nthis:\n  length xs = card (set xs)\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> {xs.\n                 distinct xs \\<and> set xs = insert x X} \\<Longrightarrow>\n       xa \\<in> (\\<lambda>(i, xs). take i xs @ x # drop i xs) `\n                ({0..<card (insert x X)} \\<times>\n                 {xs. distinct xs \\<and> set xs = X})", "from set[unfolded set_conv_nth]"], ["proof (chain)\npicking this:\n  {xs ! i |i. i < length xs} = insert x X", "obtain i where x: \"x = xs ! i\" and i: \"i < length xs\""], ["proof (prove)\nusing this:\n  {xs ! i |i. i < length xs} = insert x X\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>x = xs ! i; i < length xs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  x = xs ! i\n  i < length xs\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> {xs.\n                 distinct xs \\<and> set xs = insert x X} \\<Longrightarrow>\n       xa \\<in> (\\<lambda>(i, xs). take i xs @ x # drop i xs) `\n                ({0..<card (insert x X)} \\<times>\n                 {xs. distinct xs \\<and> set xs = X})", "from i"], ["proof (chain)\npicking this:\n  i < length xs", "have min: \"min (length xs) i = i\""], ["proof (prove)\nusing this:\n  i < length xs\n\ngoal (1 subgoal):\n 1. min (length xs) i = i", "by simp"], ["proof (state)\nthis:\n  min (length xs) i = i\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> {xs.\n                 distinct xs \\<and> set xs = insert x X} \\<Longrightarrow>\n       xa \\<in> (\\<lambda>(i, xs). take i xs @ x # drop i xs) `\n                ({0..<card (insert x X)} \\<times>\n                 {xs. distinct xs \\<and> set xs = X})", "let ?ys = \"take i xs @ drop (Suc i) xs\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> {xs.\n                 distinct xs \\<and> set xs = insert x X} \\<Longrightarrow>\n       xa \\<in> (\\<lambda>(i, xs). take i xs @ x # drop i xs) `\n                ({0..<card (insert x X)} \\<times>\n                 {xs. distinct xs \\<and> set xs = X})", "from id_take_nth_drop[OF i]"], ["proof (chain)\npicking this:\n  xs = take i xs @ xs ! i # drop (Suc i) xs", "have xsi: \"xs = take i xs @ xs ! i # drop (Suc i) xs\""], ["proof (prove)\nusing this:\n  xs = take i xs @ xs ! i # drop (Suc i) xs\n\ngoal (1 subgoal):\n 1. xs = take i xs @ xs ! i # drop (Suc i) xs", "."], ["proof (state)\nthis:\n  xs = take i xs @ xs ! i # drop (Suc i) xs\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> {xs.\n                 distinct xs \\<and> set xs = insert x X} \\<Longrightarrow>\n       xa \\<in> (\\<lambda>(i, xs). take i xs @ x # drop i xs) `\n                ({0..<card (insert x X)} \\<times>\n                 {xs. distinct xs \\<and> set xs = X})", "also"], ["proof (state)\nthis:\n  xs = take i xs @ xs ! i # drop (Suc i) xs\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> {xs.\n                 distinct xs \\<and> set xs = insert x X} \\<Longrightarrow>\n       xa \\<in> (\\<lambda>(i, xs). take i xs @ x # drop i xs) `\n                ({0..<card (insert x X)} \\<times>\n                 {xs. distinct xs \\<and> set xs = X})", "have \"... = ?f (i,?ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. take i xs @ xs ! i # drop (Suc i) xs =\n    (case (i, take i xs @ drop (Suc i) xs) of\n     (i, xs) \\<Rightarrow> take i xs @ x # drop i xs)", "unfolding split"], ["proof (prove)\ngoal (1 subgoal):\n 1. take i xs @ xs ! i # drop (Suc i) xs =\n    take i (take i xs @ drop (Suc i) xs) @\n    x # drop i (take i xs @ drop (Suc i) xs)", "by (simp add: min x)"], ["proof (state)\nthis:\n  take i xs @ xs ! i # drop (Suc i) xs =\n  (case (i, take i xs @ drop (Suc i) xs) of\n   (i, xs) \\<Rightarrow> take i xs @ x # drop i xs)\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> {xs.\n                 distinct xs \\<and> set xs = insert x X} \\<Longrightarrow>\n       xa \\<in> (\\<lambda>(i, xs). take i xs @ x # drop i xs) `\n                ({0..<card (insert x X)} \\<times>\n                 {xs. distinct xs \\<and> set xs = X})", "finally"], ["proof (chain)\npicking this:\n  xs =\n  (case (i, take i xs @ drop (Suc i) xs) of\n   (i, xs) \\<Rightarrow> take i xs @ x # drop i xs)", "have xs: \"xs = ?f (i,?ys)\""], ["proof (prove)\nusing this:\n  xs =\n  (case (i, take i xs @ drop (Suc i) xs) of\n   (i, xs) \\<Rightarrow> take i xs @ x # drop i xs)\n\ngoal (1 subgoal):\n 1. xs =\n    (case (i, take i xs @ drop (Suc i) xs) of\n     (i, xs) \\<Rightarrow> take i xs @ x # drop i xs)", "."], ["proof (state)\nthis:\n  xs =\n  (case (i, take i xs @ drop (Suc i) xs) of\n   (i, xs) \\<Rightarrow> take i xs @ x # drop i xs)\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> {xs.\n                 distinct xs \\<and> set xs = insert x X} \\<Longrightarrow>\n       xa \\<in> (\\<lambda>(i, xs). take i xs @ x # drop i xs) `\n                ({0..<card (insert x X)} \\<times>\n                 {xs. distinct xs \\<and> set xs = X})", "show \"xs \\<in> ?f ` ?L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<in> (\\<lambda>(i, xs). take i xs @ x # drop i xs) `\n             ({0..<card (insert x X)} \\<times>\n              {xs. distinct xs \\<and> set xs = X})", "proof (rule image_eqI, rule xs, rule SigmaI)"], ["proof (state)\ngoal (2 subgoals):\n 1. i \\<in> {0..<card (insert x X)}\n 2. take i xs @ drop (Suc i) xs \\<in> {xs. distinct xs \\<and> set xs = X}", "show \"i \\<in> {0..<card (insert x X)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<in> {0..<card (insert x X)}", "using i[unfolded len] set[symmetric]"], ["proof (prove)\nusing this:\n  i < card (set xs)\n  insert x X = set xs\n\ngoal (1 subgoal):\n 1. i \\<in> {0..<card (insert x X)}", "by simp"], ["proof (state)\nthis:\n  i \\<in> {0..<card (insert x X)}\n\ngoal (1 subgoal):\n 1. take i xs @ drop (Suc i) xs \\<in> {xs. distinct xs \\<and> set xs = X}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. take i xs @ drop (Suc i) xs \\<in> {xs. distinct xs \\<and> set xs = X}", "from dis xsi"], ["proof (chain)\npicking this:\n  distinct xs\n  xs = take i xs @ xs ! i # drop (Suc i) xs", "have disxsi: \"distinct (take i xs @ xs ! i # drop (Suc i) xs)\""], ["proof (prove)\nusing this:\n  distinct xs\n  xs = take i xs @ xs ! i # drop (Suc i) xs\n\ngoal (1 subgoal):\n 1. distinct (take i xs @ xs ! i # drop (Suc i) xs)", "by simp"], ["proof (state)\nthis:\n  distinct (take i xs @ xs ! i # drop (Suc i) xs)\n\ngoal (1 subgoal):\n 1. take i xs @ drop (Suc i) xs \\<in> {xs. distinct xs \\<and> set xs = X}", "note disxsi = disxsi[unfolded distinct_append x[symmetric]]"], ["proof (state)\nthis:\n  distinct (take i xs) \\<and>\n  distinct (x # drop (Suc i) xs) \\<and>\n  set (take i xs) \\<inter> set (x # drop (Suc i) xs) = {}\n\ngoal (1 subgoal):\n 1. take i xs @ drop (Suc i) xs \\<in> {xs. distinct xs \\<and> set xs = X}", "have xys: \"x \\<notin> set ?ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> set (take i xs @ drop (Suc i) xs)", "using disxsi"], ["proof (prove)\nusing this:\n  distinct (take i xs) \\<and>\n  distinct (x # drop (Suc i) xs) \\<and>\n  set (take i xs) \\<inter> set (x # drop (Suc i) xs) = {}\n\ngoal (1 subgoal):\n 1. x \\<notin> set (take i xs @ drop (Suc i) xs)", "by auto"], ["proof (state)\nthis:\n  x \\<notin> set (take i xs @ drop (Suc i) xs)\n\ngoal (1 subgoal):\n 1. take i xs @ drop (Suc i) xs \\<in> {xs. distinct xs \\<and> set xs = X}", "from distinct_take_drop[OF dis i]"], ["proof (chain)\npicking this:\n  distinct (take i xs @ drop (Suc i) xs)", "have disys: \"distinct ?ys\""], ["proof (prove)\nusing this:\n  distinct (take i xs @ drop (Suc i) xs)\n\ngoal (1 subgoal):\n 1. distinct (take i xs @ drop (Suc i) xs)", "."], ["proof (state)\nthis:\n  distinct (take i xs @ drop (Suc i) xs)\n\ngoal (1 subgoal):\n 1. take i xs @ drop (Suc i) xs \\<in> {xs. distinct xs \\<and> set xs = X}", "have \"insert x (set ?ys) = set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert x (set (take i xs @ drop (Suc i) xs)) = set xs", "unfolding arg_cong[OF xsi, of set] x"], ["proof (prove)\ngoal (1 subgoal):\n 1. insert (xs ! i) (set (take i xs @ drop (Suc i) xs)) =\n    set (take i xs @ xs ! i # drop (Suc i) xs)", "by simp"], ["proof (state)\nthis:\n  insert x (set (take i xs @ drop (Suc i) xs)) = set xs\n\ngoal (1 subgoal):\n 1. take i xs @ drop (Suc i) xs \\<in> {xs. distinct xs \\<and> set xs = X}", "hence \"insert x (set ?ys) = insert x X\""], ["proof (prove)\nusing this:\n  insert x (set (take i xs @ drop (Suc i) xs)) = set xs\n\ngoal (1 subgoal):\n 1. insert x (set (take i xs @ drop (Suc i) xs)) = insert x X", "unfolding set"], ["proof (prove)\nusing this:\n  insert x (set (take i xs @ drop (Suc i) xs)) = insert x X\n\ngoal (1 subgoal):\n 1. insert x (set (take i xs @ drop (Suc i) xs)) = insert x X", "by simp"], ["proof (state)\nthis:\n  insert x (set (take i xs @ drop (Suc i) xs)) = insert x X\n\ngoal (1 subgoal):\n 1. take i xs @ drop (Suc i) xs \\<in> {xs. distinct xs \\<and> set xs = X}", "from this[unfolded insert_eq_iff[OF xys 2(2)]]"], ["proof (chain)\npicking this:\n  if x = x then set (take i xs @ drop (Suc i) xs) = X\n  else \\<exists>C.\n          set (take i xs @ drop (Suc i) xs) = insert x C \\<and>\n          x \\<notin> C \\<and> X = insert x C \\<and> x \\<notin> C", "show \"?ys \\<in> ?S X\""], ["proof (prove)\nusing this:\n  if x = x then set (take i xs @ drop (Suc i) xs) = X\n  else \\<exists>C.\n          set (take i xs @ drop (Suc i) xs) = insert x C \\<and>\n          x \\<notin> C \\<and> X = insert x C \\<and> x \\<notin> C\n\ngoal (1 subgoal):\n 1. take i xs @ drop (Suc i) xs \\<in> {xs. distinct xs \\<and> set xs = X}", "using disys"], ["proof (prove)\nusing this:\n  if x = x then set (take i xs @ drop (Suc i) xs) = X\n  else \\<exists>C.\n          set (take i xs @ drop (Suc i) xs) = insert x C \\<and>\n          x \\<notin> C \\<and> X = insert x C \\<and> x \\<notin> C\n  distinct (take i xs @ drop (Suc i) xs)\n\ngoal (1 subgoal):\n 1. take i xs @ drop (Suc i) xs \\<in> {xs. distinct xs \\<and> set xs = X}", "by auto"], ["proof (state)\nthis:\n  take i xs @ drop (Suc i) xs \\<in> {xs. distinct xs \\<and> set xs = X}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  xs \\<in> (\\<lambda>(i, xs). take i xs @ x # drop i xs) `\n           ({0..<card (insert x X)} \\<times>\n            {xs. distinct xs \\<and> set xs = X})\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  finite {xs. distinct xs \\<and> set xs = insert x X}\n\ngoal (1 subgoal):\n 1. finite {xs. distinct xs \\<and> set xs = {}}", "qed simp"], ["proof (state)\nthis:\n  finite {xs. distinct xs \\<and> set xs = X}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma finite_distinct_subset:\n  assumes \"finite X\"\n  shows \"finite { xs . distinct xs \\<and> set xs \\<subseteq> X}\" (is \"finite (?S X)\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {xs. distinct xs \\<and> set xs \\<subseteq> X}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite {xs. distinct xs \\<and> set xs \\<subseteq> X}", "let ?X = \"{ { xs. distinct xs \\<and> set xs = Y} | Y. Y \\<subseteq> X}\""], ["proof (state)\ngoal (1 subgoal):\n 1. finite {xs. distinct xs \\<and> set xs \\<subseteq> X}", "have id: \"?S X = \\<Union> ?X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {xs. distinct xs \\<and> set xs \\<subseteq> X} =\n    \\<Union> {{xs. distinct xs \\<and> set xs = Y} |Y. Y \\<subseteq> X}", "by blast"], ["proof (state)\nthis:\n  {xs. distinct xs \\<and> set xs \\<subseteq> X} =\n  \\<Union> {{xs. distinct xs \\<and> set xs = Y} |Y. Y \\<subseteq> X}\n\ngoal (1 subgoal):\n 1. finite {xs. distinct xs \\<and> set xs \\<subseteq> X}", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {xs. distinct xs \\<and> set xs \\<subseteq> X}", "unfolding id"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     (\\<Union> {{xs. distinct xs \\<and> set xs = Y} |Y. Y \\<subseteq> X})", "proof (rule finite_Union)"], ["proof (state)\ngoal (2 subgoals):\n 1. finite {{xs. distinct xs \\<and> set xs = Y} |Y. Y \\<subseteq> X}\n 2. \\<And>M.\n       M \\<in> {{xs. distinct xs \\<and> set xs = Y} |Y.\n                Y \\<subseteq> X} \\<Longrightarrow>\n       finite M", "show \"finite ?X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {{xs. distinct xs \\<and> set xs = Y} |Y. Y \\<subseteq> X}", "using assms"], ["proof (prove)\nusing this:\n  finite X\n\ngoal (1 subgoal):\n 1. finite {{xs. distinct xs \\<and> set xs = Y} |Y. Y \\<subseteq> X}", "by auto"], ["proof (state)\nthis:\n  finite {{xs. distinct xs \\<and> set xs = Y} |Y. Y \\<subseteq> X}\n\ngoal (1 subgoal):\n 1. \\<And>M.\n       M \\<in> {{xs. distinct xs \\<and> set xs = Y} |Y.\n                Y \\<subseteq> X} \\<Longrightarrow>\n       finite M", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>M.\n       M \\<in> {{xs. distinct xs \\<and> set xs = Y} |Y.\n                Y \\<subseteq> X} \\<Longrightarrow>\n       finite M", "fix M"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>M.\n       M \\<in> {{xs. distinct xs \\<and> set xs = Y} |Y.\n                Y \\<subseteq> X} \\<Longrightarrow>\n       finite M", "assume \"M \\<in> ?X\""], ["proof (state)\nthis:\n  M \\<in> {{xs. distinct xs \\<and> set xs = Y} |Y. Y \\<subseteq> X}\n\ngoal (1 subgoal):\n 1. \\<And>M.\n       M \\<in> {{xs. distinct xs \\<and> set xs = Y} |Y.\n                Y \\<subseteq> X} \\<Longrightarrow>\n       finite M", "with finite_distinct"], ["proof (chain)\npicking this:\n  finite {xs. distinct xs \\<and> set xs = ?X}\n  M \\<in> {{xs. distinct xs \\<and> set xs = Y} |Y. Y \\<subseteq> X}", "show \"finite M\""], ["proof (prove)\nusing this:\n  finite {xs. distinct xs \\<and> set xs = ?X}\n  M \\<in> {{xs. distinct xs \\<and> set xs = Y} |Y. Y \\<subseteq> X}\n\ngoal (1 subgoal):\n 1. finite M", "by auto"], ["proof (state)\nthis:\n  finite M\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  finite {xs. distinct xs \\<and> set xs \\<subseteq> X}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma map_of_filter:\n  assumes \"P x\"\n  shows \"map_of [(x',y) \\<leftarrow> ys. P x'] x = map_of ys x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_of (filter (\\<lambda>(x', y). P x') ys) x = map_of ys x", "proof (induct ys)"], ["proof (state)\ngoal (2 subgoals):\n 1. map_of (filter (\\<lambda>a. case a of (x', y) \\<Rightarrow> P x') [])\n     x =\n    map_of [] x\n 2. \\<And>a ys.\n       map_of (filter (\\<lambda>a. case a of (x', y) \\<Rightarrow> P x') ys)\n        x =\n       map_of ys x \\<Longrightarrow>\n       map_of\n        (filter (\\<lambda>a. case a of (x', y) \\<Rightarrow> P x') (a # ys))\n        x =\n       map_of (a # ys) x", "case (Cons xy ys)"], ["proof (state)\nthis:\n  map_of (filter (\\<lambda>a. case a of (x', y) \\<Rightarrow> P x') ys) x =\n  map_of ys x\n\ngoal (2 subgoals):\n 1. map_of (filter (\\<lambda>a. case a of (x', y) \\<Rightarrow> P x') [])\n     x =\n    map_of [] x\n 2. \\<And>a ys.\n       map_of (filter (\\<lambda>a. case a of (x', y) \\<Rightarrow> P x') ys)\n        x =\n       map_of ys x \\<Longrightarrow>\n       map_of\n        (filter (\\<lambda>a. case a of (x', y) \\<Rightarrow> P x') (a # ys))\n        x =\n       map_of (a # ys) x", "obtain x' y where xy: \"xy = (x',y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x' y. xy = (x', y) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  xy = (x', y)\n\ngoal (2 subgoals):\n 1. map_of (filter (\\<lambda>a. case a of (x', y) \\<Rightarrow> P x') [])\n     x =\n    map_of [] x\n 2. \\<And>a ys.\n       map_of (filter (\\<lambda>a. case a of (x', y) \\<Rightarrow> P x') ys)\n        x =\n       map_of ys x \\<Longrightarrow>\n       map_of\n        (filter (\\<lambda>a. case a of (x', y) \\<Rightarrow> P x') (a # ys))\n        x =\n       map_of (a # ys) x", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_of\n     (filter (\\<lambda>a. case a of (x', y) \\<Rightarrow> P x') (xy # ys))\n     x =\n    map_of (xy # ys) x", "by (cases \"x' = x\", insert assms xy Cons, auto)"], ["proof (state)\nthis:\n  map_of\n   (filter (\\<lambda>a. case a of (x', y) \\<Rightarrow> P x') (xy # ys)) x =\n  map_of (xy # ys) x\n\ngoal (1 subgoal):\n 1. map_of (filter (\\<lambda>a. case a of (x', y) \\<Rightarrow> P x') [])\n     x =\n    map_of [] x", "qed simp"], ["", "lemma set_subset_insertI: \"set xs \\<subseteq> set (List.insert x xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set xs \\<subseteq> set (List.insert x xs)", "by auto"], ["", "lemma set_removeAll_subset: \"set (removeAll x xs) \\<subseteq> set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (removeAll x xs) \\<subseteq> set xs", "by auto"], ["", "lemma map_of_append_Some:\n  \"map_of xs y = Some z \\<Longrightarrow> map_of (xs @ ys) y = Some z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_of xs y = Some z \\<Longrightarrow> map_of (xs @ ys) y = Some z", "by (induction xs) auto"], ["", "lemma map_of_append_None:\n  \"map_of xs y = None \\<Longrightarrow> map_of (xs @ ys) y = map_of ys y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_of xs y = None \\<Longrightarrow> map_of (xs @ ys) y = map_of ys y", "by (induction xs) auto"], ["", "end"]]}