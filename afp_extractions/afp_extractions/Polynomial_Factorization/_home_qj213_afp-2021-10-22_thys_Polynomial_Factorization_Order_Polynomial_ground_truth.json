{"file_name": "/home/qj213/afp-2021-10-22/thys/Polynomial_Factorization/Order_Polynomial.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Polynomial_Factorization", "problem_names": ["lemma order_linear[simp]: \"order a [:- a, 1:] = Suc 0\"", "lemma linear_power_nonzero: \"[: a, 1 :] ^ n \\<noteq> 0\"", "lemma order_linear_power': \"order a ([: b, 1:]^Suc n) = (if b = -a then Suc n else 0)\"", "lemma order_linear_power: \"order a ([: b, 1:]^n) = (if b = -a then n else 0)\"", "lemma order_linear': \"order a [: b, 1:] = (if b = -a then 1 else 0)\"", "lemma degree_div_less:\n  assumes p: \"(p::'a::field poly) \\<noteq> 0\" and dvd: \"r dvd p\" and deg: \"degree r \\<noteq> 0\" \n  shows \"degree (p div r) < degree p\"", "lemma order_sum_degree: assumes \"p \\<noteq> 0\"\n  shows \"sum (\\<lambda> a. order a p) { a. poly p a = 0 } \\<le> degree p\"", "lemma order_code[code]: \"order (a::'a::idom_divide) p = \n  (if p = 0 then Code.abort (STR ''order of polynomial 0 undefined'') (\\<lambda> _. order a p) \n   else if poly p a \\<noteq> 0 then 0 else Suc (order a (p div [: -a, 1 :])))\""], "translations": [["", "lemma order_linear[simp]: \"order a [:- a, 1:] = Suc 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order a [:- a, 1::'a:] = Suc 0", "unfolding order_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST n. \\<not> [:- a, 1::'a:] ^ Suc n dvd [:- a, 1::'a:]) = Suc 0", "proof (rule Least_equality, intro notI)"], ["proof (state)\ngoal (2 subgoals):\n 1. [:- a, 1::'a:] ^ Suc (Suc 0) dvd [:- a, 1::'a:] \\<Longrightarrow> False\n 2. \\<And>y.\n       \\<not> [:- a, 1::'a:] ^ Suc y dvd [:- a, 1::'a:] \\<Longrightarrow>\n       Suc 0 \\<le> y", "assume \"[:- a, 1:] ^ Suc (Suc 0) dvd [:- a, 1:]\""], ["proof (state)\nthis:\n  [:- a, 1::'a:] ^ Suc (Suc 0) dvd [:- a, 1::'a:]\n\ngoal (2 subgoals):\n 1. [:- a, 1::'a:] ^ Suc (Suc 0) dvd [:- a, 1::'a:] \\<Longrightarrow> False\n 2. \\<And>y.\n       \\<not> [:- a, 1::'a:] ^ Suc y dvd [:- a, 1::'a:] \\<Longrightarrow>\n       Suc 0 \\<le> y", "from dvd_imp_degree_le[OF this]"], ["proof (chain)\npicking this:\n  [:- a, 1::'a:] \\<noteq> 0 \\<Longrightarrow>\n  degree ([:- a, 1::'a:] ^ Suc (Suc 0)) \\<le> degree [:- a, 1::'a:]", "show False"], ["proof (prove)\nusing this:\n  [:- a, 1::'a:] \\<noteq> 0 \\<Longrightarrow>\n  degree ([:- a, 1::'a:] ^ Suc (Suc 0)) \\<le> degree [:- a, 1::'a:]\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<not> [:- a, 1::'a:] ^ Suc y dvd [:- a, 1::'a:] \\<Longrightarrow>\n       Suc 0 \\<le> y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<not> [:- a, 1::'a:] ^ Suc y dvd [:- a, 1::'a:] \\<Longrightarrow>\n       Suc 0 \\<le> y", "fix n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<not> [:- a, 1::'a:] ^ Suc y dvd [:- a, 1::'a:] \\<Longrightarrow>\n       Suc 0 \\<le> y", "assume *: \"\\<not> [:- a, 1:] ^ Suc n dvd [:- a, 1:]\""], ["proof (state)\nthis:\n  \\<not> [:- a, 1::'a:] ^ Suc n dvd [:- a, 1::'a:]\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<not> [:- a, 1::'a:] ^ Suc y dvd [:- a, 1::'a:] \\<Longrightarrow>\n       Suc 0 \\<le> y", "thus \"Suc 0 \\<le> n\""], ["proof (prove)\nusing this:\n  \\<not> [:- a, 1::'a:] ^ Suc n dvd [:- a, 1::'a:]\n\ngoal (1 subgoal):\n 1. Suc 0 \\<le> n", "by (cases n, auto)"], ["proof (state)\nthis:\n  Suc 0 \\<le> n\n\ngoal:\nNo subgoals!", "qed"], ["", "declare order_power_n_n[simp]"], ["", "lemma linear_power_nonzero: \"[: a, 1 :] ^ n \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [:a, 1::'a:] ^ n \\<noteq> 0", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. [:a, 1::'a:] ^ n = 0 \\<Longrightarrow> False", "assume \"[: a, 1 :]^n = 0\""], ["proof (state)\nthis:\n  [:a, 1::'a:] ^ n = 0\n\ngoal (1 subgoal):\n 1. [:a, 1::'a:] ^ n = 0 \\<Longrightarrow> False", "with arg_cong[OF this, of degree, unfolded degree_linear_power]"], ["proof (chain)\npicking this:\n  n = degree 0\n  [:a, 1::'a:] ^ n = 0", "show False"], ["proof (prove)\nusing this:\n  n = degree 0\n  [:a, 1::'a:] ^ n = 0\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma order_linear_power': \"order a ([: b, 1:]^Suc n) = (if b = -a then Suc n else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order a ([:b, 1::'a:] ^ Suc n) = (if b = - a then Suc n else 0)", "proof (cases \"b = -a\")"], ["proof (state)\ngoal (2 subgoals):\n 1. b = - a \\<Longrightarrow>\n    order a ([:b, 1::'a:] ^ Suc n) = (if b = - a then Suc n else 0)\n 2. b \\<noteq> - a \\<Longrightarrow>\n    order a ([:b, 1::'a:] ^ Suc n) = (if b = - a then Suc n else 0)", "case True"], ["proof (state)\nthis:\n  b = - a\n\ngoal (2 subgoals):\n 1. b = - a \\<Longrightarrow>\n    order a ([:b, 1::'a:] ^ Suc n) = (if b = - a then Suc n else 0)\n 2. b \\<noteq> - a \\<Longrightarrow>\n    order a ([:b, 1::'a:] ^ Suc n) = (if b = - a then Suc n else 0)", "thus ?thesis"], ["proof (prove)\nusing this:\n  b = - a\n\ngoal (1 subgoal):\n 1. order a ([:b, 1::'a:] ^ Suc n) = (if b = - a then Suc n else 0)", "unfolding True order_power_n_n"], ["proof (prove)\nusing this:\n  - a = - a\n\ngoal (1 subgoal):\n 1. Suc n = (if - a = - a then Suc n else 0)", "by simp"], ["proof (state)\nthis:\n  order a ([:b, 1::'a:] ^ Suc n) = (if b = - a then Suc n else 0)\n\ngoal (1 subgoal):\n 1. b \\<noteq> - a \\<Longrightarrow>\n    order a ([:b, 1::'a:] ^ Suc n) = (if b = - a then Suc n else 0)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. b \\<noteq> - a \\<Longrightarrow>\n    order a ([:b, 1::'a:] ^ Suc n) = (if b = - a then Suc n else 0)", "case False"], ["proof (state)\nthis:\n  b \\<noteq> - a\n\ngoal (1 subgoal):\n 1. b \\<noteq> - a \\<Longrightarrow>\n    order a ([:b, 1::'a:] ^ Suc n) = (if b = - a then Suc n else 0)", "let ?p = \"[: b, 1:]^Suc n\""], ["proof (state)\ngoal (1 subgoal):\n 1. b \\<noteq> - a \\<Longrightarrow>\n    order a ([:b, 1::'a:] ^ Suc n) = (if b = - a then Suc n else 0)", "from linear_power_nonzero"], ["proof (chain)\npicking this:\n  [:?a, 1::?'a:] ^ ?n \\<noteq> 0", "have \"?p \\<noteq> 0\""], ["proof (prove)\nusing this:\n  [:?a, 1::?'a:] ^ ?n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. [:b, 1::'a:] ^ Suc n \\<noteq> 0", "."], ["proof (state)\nthis:\n  [:b, 1::'a:] ^ Suc n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. b \\<noteq> - a \\<Longrightarrow>\n    order a ([:b, 1::'a:] ^ Suc n) = (if b = - a then Suc n else 0)", "have p: \"?p = (\\<Prod>a\\<leftarrow> replicate (Suc n) b. [:a, 1:])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [:b, 1::'a:] ^ Suc n =\n    (\\<Prod>a\\<leftarrow>replicate (Suc n) b. [:a, 1::'a:])", "by auto"], ["proof (state)\nthis:\n  [:b, 1::'a:] ^ Suc n =\n  (\\<Prod>a\\<leftarrow>replicate (Suc n) b. [:a, 1::'a:])\n\ngoal (1 subgoal):\n 1. b \\<noteq> - a \\<Longrightarrow>\n    order a ([:b, 1::'a:] ^ Suc n) = (if b = - a then Suc n else 0)", "{"], ["proof (state)\nthis:\n  [:b, 1::'a:] ^ Suc n =\n  (\\<Prod>a\\<leftarrow>replicate (Suc n) b. [:a, 1::'a:])\n\ngoal (1 subgoal):\n 1. b \\<noteq> - a \\<Longrightarrow>\n    order a ([:b, 1::'a:] ^ Suc n) = (if b = - a then Suc n else 0)", "assume \"order a ?p \\<noteq> 0\""], ["proof (state)\nthis:\n  order a ([:b, 1::'a:] ^ Suc n) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. b \\<noteq> - a \\<Longrightarrow>\n    order a ([:b, 1::'a:] ^ Suc n) = (if b = - a then Suc n else 0)", "then"], ["proof (chain)\npicking this:\n  order a ([:b, 1::'a:] ^ Suc n) \\<noteq> 0", "obtain m where ord: \"order a ?p = Suc m\""], ["proof (prove)\nusing this:\n  order a ([:b, 1::'a:] ^ Suc n) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>m.\n        order a ([:b, 1::'a:] ^ Suc n) = Suc m \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases \"order a ?p\", auto)"], ["proof (state)\nthis:\n  order a ([:b, 1::'a:] ^ Suc n) = Suc m\n\ngoal (1 subgoal):\n 1. b \\<noteq> - a \\<Longrightarrow>\n    order a ([:b, 1::'a:] ^ Suc n) = (if b = - a then Suc n else 0)", "from order[OF \\<open>?p \\<noteq> 0\\<close>, of a, unfolded ord]"], ["proof (chain)\npicking this:\n  [:- a, 1::'a:] ^ Suc m dvd [:b, 1::'a:] ^ Suc n \\<and>\n  \\<not> [:- a, 1::'a:] ^ Suc (Suc m) dvd [:b, 1::'a:] ^ Suc n", "have dvd: \"[:- a, 1:] ^ Suc m dvd ?p\""], ["proof (prove)\nusing this:\n  [:- a, 1::'a:] ^ Suc m dvd [:b, 1::'a:] ^ Suc n \\<and>\n  \\<not> [:- a, 1::'a:] ^ Suc (Suc m) dvd [:b, 1::'a:] ^ Suc n\n\ngoal (1 subgoal):\n 1. [:- a, 1::'a:] ^ Suc m dvd [:b, 1::'a:] ^ Suc n", "by auto"], ["proof (state)\nthis:\n  [:- a, 1::'a:] ^ Suc m dvd [:b, 1::'a:] ^ Suc n\n\ngoal (1 subgoal):\n 1. b \\<noteq> - a \\<Longrightarrow>\n    order a ([:b, 1::'a:] ^ Suc n) = (if b = - a then Suc n else 0)", "from poly_linear_exp_linear_factors[OF dvd[unfolded p]] False"], ["proof (chain)\npicking this:\n  Suc m \\<le> length (filter ((=) (- a)) (replicate (Suc n) b))\n  b \\<noteq> - a", "have False"], ["proof (prove)\nusing this:\n  Suc m \\<le> length (filter ((=) (- a)) (replicate (Suc n) b))\n  b \\<noteq> - a\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. b \\<noteq> - a \\<Longrightarrow>\n    order a ([:b, 1::'a:] ^ Suc n) = (if b = - a then Suc n else 0)", "}"], ["proof (state)\nthis:\n  order a ([:b, 1::'a:] ^ Suc n) \\<noteq> 0 \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. b \\<noteq> - a \\<Longrightarrow>\n    order a ([:b, 1::'a:] ^ Suc n) = (if b = - a then Suc n else 0)", "hence \"order a ?p = 0\""], ["proof (prove)\nusing this:\n  order a ([:b, 1::'a:] ^ Suc n) \\<noteq> 0 \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. order a ([:b, 1::'a:] ^ Suc n) = 0", "by auto"], ["proof (state)\nthis:\n  order a ([:b, 1::'a:] ^ Suc n) = 0\n\ngoal (1 subgoal):\n 1. b \\<noteq> - a \\<Longrightarrow>\n    order a ([:b, 1::'a:] ^ Suc n) = (if b = - a then Suc n else 0)", "with False"], ["proof (chain)\npicking this:\n  b \\<noteq> - a\n  order a ([:b, 1::'a:] ^ Suc n) = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  b \\<noteq> - a\n  order a ([:b, 1::'a:] ^ Suc n) = 0\n\ngoal (1 subgoal):\n 1. order a ([:b, 1::'a:] ^ Suc n) = (if b = - a then Suc n else 0)", "by simp"], ["proof (state)\nthis:\n  order a ([:b, 1::'a:] ^ Suc n) = (if b = - a then Suc n else 0)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma order_linear_power: \"order a ([: b, 1:]^n) = (if b = -a then n else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order a ([:b, 1::'a:] ^ n) = (if b = - a then n else 0)", "proof (cases n)"], ["proof (state)\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    order a ([:b, 1::'a:] ^ n) = (if b = - a then n else 0)\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       order a ([:b, 1::'a:] ^ n) = (if b = - a then n else 0)", "case (Suc m)"], ["proof (state)\nthis:\n  n = Suc m\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    order a ([:b, 1::'a:] ^ n) = (if b = - a then n else 0)\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       order a ([:b, 1::'a:] ^ n) = (if b = - a then n else 0)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. order a ([:b, 1::'a:] ^ n) = (if b = - a then n else 0)", "unfolding Suc order_linear_power'"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if b = - a then Suc m else 0) = (if b = - a then Suc m else 0)", "by simp"], ["proof (state)\nthis:\n  order a ([:b, 1::'a:] ^ n) = (if b = - a then n else 0)\n\ngoal (1 subgoal):\n 1. n = 0 \\<Longrightarrow>\n    order a ([:b, 1::'a:] ^ n) = (if b = - a then n else 0)", "qed simp"], ["", "lemma order_linear': \"order a [: b, 1:] = (if b = -a then 1 else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order a [:b, 1::'a:] = (if b = - a then 1 else 0)", "using order_linear_power'[of a b 0]"], ["proof (prove)\nusing this:\n  order a ([:b, 1::'a:] ^ Suc 0) = (if b = - a then Suc 0 else 0)\n\ngoal (1 subgoal):\n 1. order a [:b, 1::'a:] = (if b = - a then 1 else 0)", "by simp"], ["", "lemma degree_div_less:\n  assumes p: \"(p::'a::field poly) \\<noteq> 0\" and dvd: \"r dvd p\" and deg: \"degree r \\<noteq> 0\" \n  shows \"degree (p div r) < degree p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (p div r) < degree p", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. degree (p div r) < degree p", "from dvd"], ["proof (chain)\npicking this:\n  r dvd p", "obtain q where prq: \"p = r * q\""], ["proof (prove)\nusing this:\n  r dvd p\n\ngoal (1 subgoal):\n 1. (\\<And>q. p = r * q \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "unfolding dvd_def"], ["proof (prove)\nusing this:\n  \\<exists>k. p = r * k\n\ngoal (1 subgoal):\n 1. (\\<And>q. p = r * q \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  p = r * q\n\ngoal (1 subgoal):\n 1. degree (p div r) < degree p", "have \"degree p = degree r + degree q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree p = degree r + degree q", "unfolding prq"], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (r * q) = degree r + degree q", "by (rule degree_mult_eq, insert p prq, auto)"], ["proof (state)\nthis:\n  degree p = degree r + degree q\n\ngoal (1 subgoal):\n 1. degree (p div r) < degree p", "with deg"], ["proof (chain)\npicking this:\n  degree r \\<noteq> 0\n  degree p = degree r + degree q", "have deg: \"degree q < degree p\""], ["proof (prove)\nusing this:\n  degree r \\<noteq> 0\n  degree p = degree r + degree q\n\ngoal (1 subgoal):\n 1. degree q < degree p", "by auto"], ["proof (state)\nthis:\n  degree q < degree p\n\ngoal (1 subgoal):\n 1. degree (p div r) < degree p", "from prq"], ["proof (chain)\npicking this:\n  p = r * q", "have \"q = p div r\""], ["proof (prove)\nusing this:\n  p = r * q\n\ngoal (1 subgoal):\n 1. q = p div r", "using deg p"], ["proof (prove)\nusing this:\n  p = r * q\n  degree q < degree p\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. q = p div r", "by auto"], ["proof (state)\nthis:\n  q = p div r\n\ngoal (1 subgoal):\n 1. degree (p div r) < degree p", "with deg"], ["proof (chain)\npicking this:\n  degree q < degree p\n  q = p div r", "show ?thesis"], ["proof (prove)\nusing this:\n  degree q < degree p\n  q = p div r\n\ngoal (1 subgoal):\n 1. degree (p div r) < degree p", "by auto"], ["proof (state)\nthis:\n  degree (p div r) < degree p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma order_sum_degree: assumes \"p \\<noteq> 0\"\n  shows \"sum (\\<lambda> a. order a p) { a. poly p a = 0 } \\<le> degree p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>a | poly p a = (0::'a). order a p) \\<le> degree p", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>a | poly p a = (0::'a). order a p) \\<le> degree p", "define n where \"n = degree p\""], ["proof (state)\nthis:\n  n = degree p\n\ngoal (1 subgoal):\n 1. (\\<Sum>a | poly p a = (0::'a). order a p) \\<le> degree p", "have \"degree p \\<le> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree p \\<le> n", "unfolding n_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. degree p \\<le> degree p", "by auto"], ["proof (state)\nthis:\n  degree p \\<le> n\n\ngoal (1 subgoal):\n 1. (\\<Sum>a | poly p a = (0::'a). order a p) \\<le> degree p", "thus ?thesis"], ["proof (prove)\nusing this:\n  degree p \\<le> n\n\ngoal (1 subgoal):\n 1. (\\<Sum>a | poly p a = (0::'a). order a p) \\<le> degree p", "using \\<open>p \\<noteq> 0\\<close>"], ["proof (prove)\nusing this:\n  degree p \\<le> n\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<Sum>a | poly p a = (0::'a). order a p) \\<le> degree p", "proof (induct n arbitrary: p)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>degree p \\<le> 0; p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>a | poly p a = (0::'a). order a p)\n                         \\<le> degree p\n 2. \\<And>n p.\n       \\<lbrakk>\\<And>p.\n                   \\<lbrakk>degree p \\<le> n; p \\<noteq> 0\\<rbrakk>\n                   \\<Longrightarrow> (\\<Sum>a | poly p a = (0::'a).\n  order a p)\n                                     \\<le> degree p;\n        degree p \\<le> Suc n; p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>a | poly p a = (0::'a). order a p)\n                         \\<le> degree p", "case (0 p)"], ["proof (state)\nthis:\n  degree p \\<le> 0\n  p \\<noteq> 0\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>degree p \\<le> 0; p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>a | poly p a = (0::'a). order a p)\n                         \\<le> degree p\n 2. \\<And>n p.\n       \\<lbrakk>\\<And>p.\n                   \\<lbrakk>degree p \\<le> n; p \\<noteq> 0\\<rbrakk>\n                   \\<Longrightarrow> (\\<Sum>a | poly p a = (0::'a).\n  order a p)\n                                     \\<le> degree p;\n        degree p \\<le> Suc n; p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>a | poly p a = (0::'a). order a p)\n                         \\<le> degree p", "define a where \"a = coeff p 0\""], ["proof (state)\nthis:\n  a = coeff p 0\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>degree p \\<le> 0; p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>a | poly p a = (0::'a). order a p)\n                         \\<le> degree p\n 2. \\<And>n p.\n       \\<lbrakk>\\<And>p.\n                   \\<lbrakk>degree p \\<le> n; p \\<noteq> 0\\<rbrakk>\n                   \\<Longrightarrow> (\\<Sum>a | poly p a = (0::'a).\n  order a p)\n                                     \\<le> degree p;\n        degree p \\<le> Suc n; p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>a | poly p a = (0::'a). order a p)\n                         \\<le> degree p", "from 0"], ["proof (chain)\npicking this:\n  degree p \\<le> 0\n  p \\<noteq> 0", "have \"degree p = 0\""], ["proof (prove)\nusing this:\n  degree p \\<le> 0\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. degree p = 0", "by auto"], ["proof (state)\nthis:\n  degree p = 0\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>degree p \\<le> 0; p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>a | poly p a = (0::'a). order a p)\n                         \\<le> degree p\n 2. \\<And>n p.\n       \\<lbrakk>\\<And>p.\n                   \\<lbrakk>degree p \\<le> n; p \\<noteq> 0\\<rbrakk>\n                   \\<Longrightarrow> (\\<Sum>a | poly p a = (0::'a).\n  order a p)\n                                     \\<le> degree p;\n        degree p \\<le> Suc n; p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>a | poly p a = (0::'a). order a p)\n                         \\<le> degree p", "hence p: \"p = [: a :]\""], ["proof (prove)\nusing this:\n  degree p = 0\n\ngoal (1 subgoal):\n 1. p = [:a:]", "unfolding a_def"], ["proof (prove)\nusing this:\n  degree p = 0\n\ngoal (1 subgoal):\n 1. p = [:coeff p 0:]", "by (metis degree_0_id)"], ["proof (state)\nthis:\n  p = [:a:]\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>degree p \\<le> 0; p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>a | poly p a = (0::'a). order a p)\n                         \\<le> degree p\n 2. \\<And>n p.\n       \\<lbrakk>\\<And>p.\n                   \\<lbrakk>degree p \\<le> n; p \\<noteq> 0\\<rbrakk>\n                   \\<Longrightarrow> (\\<Sum>a | poly p a = (0::'a).\n  order a p)\n                                     \\<le> degree p;\n        degree p \\<le> Suc n; p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>a | poly p a = (0::'a). order a p)\n                         \\<le> degree p", "with 0"], ["proof (chain)\npicking this:\n  degree p \\<le> 0\n  p \\<noteq> 0\n  p = [:a:]", "have \"a \\<noteq> 0\""], ["proof (prove)\nusing this:\n  degree p \\<le> 0\n  p \\<noteq> 0\n  p = [:a:]\n\ngoal (1 subgoal):\n 1. a \\<noteq> (0::'a)", "by auto"], ["proof (state)\nthis:\n  a \\<noteq> (0::'a)\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>degree p \\<le> 0; p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>a | poly p a = (0::'a). order a p)\n                         \\<le> degree p\n 2. \\<And>n p.\n       \\<lbrakk>\\<And>p.\n                   \\<lbrakk>degree p \\<le> n; p \\<noteq> 0\\<rbrakk>\n                   \\<Longrightarrow> (\\<Sum>a | poly p a = (0::'a).\n  order a p)\n                                     \\<le> degree p;\n        degree p \\<le> Suc n; p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>a | poly p a = (0::'a). order a p)\n                         \\<le> degree p", "thus ?case"], ["proof (prove)\nusing this:\n  a \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. (\\<Sum>a | poly p a = (0::'a). order a p) \\<le> degree p", "unfolding p"], ["proof (prove)\nusing this:\n  a \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. (\\<Sum>a | poly [:a:] a = (0::'a). order a [:a:]) \\<le> degree [:a:]", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>a | poly p a = (0::'a). order a p) \\<le> degree p\n\ngoal (1 subgoal):\n 1. \\<And>n p.\n       \\<lbrakk>\\<And>p.\n                   \\<lbrakk>degree p \\<le> n; p \\<noteq> 0\\<rbrakk>\n                   \\<Longrightarrow> (\\<Sum>a | poly p a = (0::'a).\n  order a p)\n                                     \\<le> degree p;\n        degree p \\<le> Suc n; p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>a | poly p a = (0::'a). order a p)\n                         \\<le> degree p", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n p.\n       \\<lbrakk>\\<And>p.\n                   \\<lbrakk>degree p \\<le> n; p \\<noteq> 0\\<rbrakk>\n                   \\<Longrightarrow> (\\<Sum>a | poly p a = (0::'a).\n  order a p)\n                                     \\<le> degree p;\n        degree p \\<le> Suc n; p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>a | poly p a = (0::'a). order a p)\n                         \\<le> degree p", "case (Suc m p)"], ["proof (state)\nthis:\n  \\<lbrakk>degree ?p \\<le> m; ?p \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> (\\<Sum>a | poly ?p a = (0::'a). order a ?p)\n                    \\<le> degree ?p\n  degree p \\<le> Suc m\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>n p.\n       \\<lbrakk>\\<And>p.\n                   \\<lbrakk>degree p \\<le> n; p \\<noteq> 0\\<rbrakk>\n                   \\<Longrightarrow> (\\<Sum>a | poly p a = (0::'a).\n  order a p)\n                                     \\<le> degree p;\n        degree p \\<le> Suc n; p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>a | poly p a = (0::'a). order a p)\n                         \\<le> degree p", "note order = order[OF \\<open>p \\<noteq> 0\\<close>]"], ["proof (state)\nthis:\n  [:- ?a, 1::'a:] ^ order ?a p dvd p \\<and>\n  \\<not> [:- ?a, 1::'a:] ^ Suc (order ?a p) dvd p\n\ngoal (1 subgoal):\n 1. \\<And>n p.\n       \\<lbrakk>\\<And>p.\n                   \\<lbrakk>degree p \\<le> n; p \\<noteq> 0\\<rbrakk>\n                   \\<Longrightarrow> (\\<Sum>a | poly p a = (0::'a).\n  order a p)\n                                     \\<le> degree p;\n        degree p \\<le> Suc n; p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>a | poly p a = (0::'a). order a p)\n                         \\<le> degree p", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>a | poly p a = (0::'a). order a p) \\<le> degree p", "proof (cases \"\\<exists> a. poly p a = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>a. poly p a = (0::'a) \\<Longrightarrow>\n    (\\<Sum>a | poly p a = (0::'a). order a p) \\<le> degree p\n 2. \\<nexists>a. poly p a = (0::'a) \\<Longrightarrow>\n    (\\<Sum>a | poly p a = (0::'a). order a p) \\<le> degree p", "case True"], ["proof (state)\nthis:\n  \\<exists>a. poly p a = (0::'a)\n\ngoal (2 subgoals):\n 1. \\<exists>a. poly p a = (0::'a) \\<Longrightarrow>\n    (\\<Sum>a | poly p a = (0::'a). order a p) \\<le> degree p\n 2. \\<nexists>a. poly p a = (0::'a) \\<Longrightarrow>\n    (\\<Sum>a | poly p a = (0::'a). order a p) \\<le> degree p", "then"], ["proof (chain)\npicking this:\n  \\<exists>a. poly p a = (0::'a)", "obtain a where root: \"poly p a = 0\""], ["proof (prove)\nusing this:\n  \\<exists>a. poly p a = (0::'a)\n\ngoal (1 subgoal):\n 1. (\\<And>a. poly p a = (0::'a) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  poly p a = (0::'a)\n\ngoal (2 subgoals):\n 1. \\<exists>a. poly p a = (0::'a) \\<Longrightarrow>\n    (\\<Sum>a | poly p a = (0::'a). order a p) \\<le> degree p\n 2. \\<nexists>a. poly p a = (0::'a) \\<Longrightarrow>\n    (\\<Sum>a | poly p a = (0::'a). order a p) \\<le> degree p", "with order_root[of p a] Suc"], ["proof (chain)\npicking this:\n  (poly p a = (0::'a)) = (p = 0 \\<or> order a p \\<noteq> 0)\n  \\<lbrakk>degree ?p \\<le> m; ?p \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> (\\<Sum>a | poly ?p a = (0::'a). order a ?p)\n                    \\<le> degree ?p\n  degree p \\<le> Suc m\n  p \\<noteq> 0\n  poly p a = (0::'a)", "obtain n where orda: \"order a p = Suc n\""], ["proof (prove)\nusing this:\n  (poly p a = (0::'a)) = (p = 0 \\<or> order a p \\<noteq> 0)\n  \\<lbrakk>degree ?p \\<le> m; ?p \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> (\\<Sum>a | poly ?p a = (0::'a). order a ?p)\n                    \\<le> degree ?p\n  degree p \\<le> Suc m\n  p \\<noteq> 0\n  poly p a = (0::'a)\n\ngoal (1 subgoal):\n 1. (\\<And>n. order a p = Suc n \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases \"order a p\", auto)"], ["proof (state)\nthis:\n  order a p = Suc n\n\ngoal (2 subgoals):\n 1. \\<exists>a. poly p a = (0::'a) \\<Longrightarrow>\n    (\\<Sum>a | poly p a = (0::'a). order a p) \\<le> degree p\n 2. \\<nexists>a. poly p a = (0::'a) \\<Longrightarrow>\n    (\\<Sum>a | poly p a = (0::'a). order a p) \\<le> degree p", "let ?a = \"[: -a, 1 :] ^ Suc n\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>a. poly p a = (0::'a) \\<Longrightarrow>\n    (\\<Sum>a | poly p a = (0::'a). order a p) \\<le> degree p\n 2. \\<nexists>a. poly p a = (0::'a) \\<Longrightarrow>\n    (\\<Sum>a | poly p a = (0::'a). order a p) \\<le> degree p", "from order_decomp[OF \\<open>p \\<noteq> 0\\<close>, of a, unfolded orda]"], ["proof (chain)\npicking this:\n  \\<exists>q.\n     p = [:- a, 1::'a:] ^ Suc n * q \\<and> \\<not> [:- a, 1::'a:] dvd q", "obtain q where p: \"p = ?a * q\" and ndvd: \"\\<not> [:- a, 1:] dvd q\""], ["proof (prove)\nusing this:\n  \\<exists>q.\n     p = [:- a, 1::'a:] ^ Suc n * q \\<and> \\<not> [:- a, 1::'a:] dvd q\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        \\<lbrakk>p = [:- a, 1::'a:] ^ Suc n * q;\n         \\<not> [:- a, 1::'a:] dvd q\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  p = [:- a, 1::'a:] ^ Suc n * q\n  \\<not> [:- a, 1::'a:] dvd q\n\ngoal (2 subgoals):\n 1. \\<exists>a. poly p a = (0::'a) \\<Longrightarrow>\n    (\\<Sum>a | poly p a = (0::'a). order a p) \\<le> degree p\n 2. \\<nexists>a. poly p a = (0::'a) \\<Longrightarrow>\n    (\\<Sum>a | poly p a = (0::'a). order a p) \\<le> degree p", "from \\<open>p \\<noteq> 0\\<close>[unfolded p]"], ["proof (chain)\npicking this:\n  [:- a, 1::'a:] ^ Suc n * q \\<noteq> 0", "have nz: \"?a \\<noteq> 0\" \"q \\<noteq> 0\""], ["proof (prove)\nusing this:\n  [:- a, 1::'a:] ^ Suc n * q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. [:- a, 1::'a:] ^ Suc n \\<noteq> 0 &&& q \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  [:- a, 1::'a:] ^ Suc n \\<noteq> 0\n  q \\<noteq> 0\n\ngoal (2 subgoals):\n 1. \\<exists>a. poly p a = (0::'a) \\<Longrightarrow>\n    (\\<Sum>a | poly p a = (0::'a). order a p) \\<le> degree p\n 2. \\<nexists>a. poly p a = (0::'a) \\<Longrightarrow>\n    (\\<Sum>a | poly p a = (0::'a). order a p) \\<le> degree p", "hence deg: \"degree p = degree ?a + degree q\""], ["proof (prove)\nusing this:\n  [:- a, 1::'a:] ^ Suc n \\<noteq> 0\n  q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. degree p = degree ([:- a, 1::'a:] ^ Suc n) + degree q", "unfolding p"], ["proof (prove)\nusing this:\n  [:- a, 1::'a:] ^ Suc n \\<noteq> 0\n  q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. degree ([:- a, 1::'a:] ^ Suc n * q) =\n    degree ([:- a, 1::'a:] ^ Suc n) + degree q", "by (subst degree_mult_eq, auto)"], ["proof (state)\nthis:\n  degree p = degree ([:- a, 1::'a:] ^ Suc n) + degree q\n\ngoal (2 subgoals):\n 1. \\<exists>a. poly p a = (0::'a) \\<Longrightarrow>\n    (\\<Sum>a | poly p a = (0::'a). order a p) \\<le> degree p\n 2. \\<nexists>a. poly p a = (0::'a) \\<Longrightarrow>\n    (\\<Sum>a | poly p a = (0::'a). order a p) \\<le> degree p", "have ord: \"\\<And> a. order a p = order a ?a + order a q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa. order aa p = order aa ([:- a, 1::'a:] ^ Suc n) + order aa q", "unfolding p"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa.\n       order aa ([:- a, 1::'a:] ^ Suc n * q) =\n       order aa ([:- a, 1::'a:] ^ Suc n) + order aa q", "by (subst order_mult, insert nz, auto)"], ["proof (state)\nthis:\n  order ?a p = order ?a ([:- a, 1::'a:] ^ Suc n) + order ?a q\n\ngoal (2 subgoals):\n 1. \\<exists>a. poly p a = (0::'a) \\<Longrightarrow>\n    (\\<Sum>a | poly p a = (0::'a). order a p) \\<le> degree p\n 2. \\<nexists>a. poly p a = (0::'a) \\<Longrightarrow>\n    (\\<Sum>a | poly p a = (0::'a). order a p) \\<le> degree p", "have roots: \"{ a. poly p a = 0 } = insert a ({ a. poly q a = 0} - {a})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {a. poly p a = (0::'a)} = insert a ({a. poly q a = (0::'a)} - {a})", "using root"], ["proof (prove)\nusing this:\n  poly p a = (0::'a)\n\ngoal (1 subgoal):\n 1. {a. poly p a = (0::'a)} = insert a ({a. poly q a = (0::'a)} - {a})", "unfolding p poly_mult"], ["proof (prove)\nusing this:\n  poly ([:- a, 1::'a:] ^ Suc n) a * poly q a = (0::'a)\n\ngoal (1 subgoal):\n 1. {aa. poly ([:- a, 1::'a:] ^ Suc n) aa * poly q aa = (0::'a)} =\n    insert a ({a. poly q a = (0::'a)} - {a})", "by auto"], ["proof (state)\nthis:\n  {a. poly p a = (0::'a)} = insert a ({a. poly q a = (0::'a)} - {a})\n\ngoal (2 subgoals):\n 1. \\<exists>a. poly p a = (0::'a) \\<Longrightarrow>\n    (\\<Sum>a | poly p a = (0::'a). order a p) \\<le> degree p\n 2. \\<nexists>a. poly p a = (0::'a) \\<Longrightarrow>\n    (\\<Sum>a | poly p a = (0::'a). order a p) \\<le> degree p", "have fin: \"finite {a. poly q a = 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {a. poly q a = (0::'a)}", "by (rule poly_roots_finite[OF \\<open>q \\<noteq> 0\\<close>])"], ["proof (state)\nthis:\n  finite {a. poly q a = (0::'a)}\n\ngoal (2 subgoals):\n 1. \\<exists>a. poly p a = (0::'a) \\<Longrightarrow>\n    (\\<Sum>a | poly p a = (0::'a). order a p) \\<le> degree p\n 2. \\<nexists>a. poly p a = (0::'a) \\<Longrightarrow>\n    (\\<Sum>a | poly p a = (0::'a). order a p) \\<le> degree p", "have \"Suc n = order a p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc n = order a p", "using orda"], ["proof (prove)\nusing this:\n  order a p = Suc n\n\ngoal (1 subgoal):\n 1. Suc n = order a p", "by simp"], ["proof (state)\nthis:\n  Suc n = order a p\n\ngoal (2 subgoals):\n 1. \\<exists>a. poly p a = (0::'a) \\<Longrightarrow>\n    (\\<Sum>a | poly p a = (0::'a). order a p) \\<le> degree p\n 2. \\<nexists>a. poly p a = (0::'a) \\<Longrightarrow>\n    (\\<Sum>a | poly p a = (0::'a). order a p) \\<le> degree p", "also"], ["proof (state)\nthis:\n  Suc n = order a p\n\ngoal (2 subgoals):\n 1. \\<exists>a. poly p a = (0::'a) \\<Longrightarrow>\n    (\\<Sum>a | poly p a = (0::'a). order a p) \\<le> degree p\n 2. \\<nexists>a. poly p a = (0::'a) \\<Longrightarrow>\n    (\\<Sum>a | poly p a = (0::'a). order a p) \\<le> degree p", "have \"\\<dots> = Suc n + order a q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order a p = Suc n + order a q", "unfolding ord order_linear_power'"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if - a = - a then Suc n else 0) + order a q = Suc n + order a q", "by simp"], ["proof (state)\nthis:\n  order a p = Suc n + order a q\n\ngoal (2 subgoals):\n 1. \\<exists>a. poly p a = (0::'a) \\<Longrightarrow>\n    (\\<Sum>a | poly p a = (0::'a). order a p) \\<le> degree p\n 2. \\<nexists>a. poly p a = (0::'a) \\<Longrightarrow>\n    (\\<Sum>a | poly p a = (0::'a). order a p) \\<le> degree p", "finally"], ["proof (chain)\npicking this:\n  Suc n = Suc n + order a q", "have \"order a q = 0\""], ["proof (prove)\nusing this:\n  Suc n = Suc n + order a q\n\ngoal (1 subgoal):\n 1. order a q = 0", "by auto"], ["proof (state)\nthis:\n  order a q = 0\n\ngoal (2 subgoals):\n 1. \\<exists>a. poly p a = (0::'a) \\<Longrightarrow>\n    (\\<Sum>a | poly p a = (0::'a). order a p) \\<le> degree p\n 2. \\<nexists>a. poly p a = (0::'a) \\<Longrightarrow>\n    (\\<Sum>a | poly p a = (0::'a). order a p) \\<le> degree p", "with order_root[of q a] \\<open>q \\<noteq> 0\\<close>"], ["proof (chain)\npicking this:\n  (poly q a = (0::'a)) = (q = 0 \\<or> order a q \\<noteq> 0)\n  q \\<noteq> 0\n  order a q = 0", "have qa: \"poly q a \\<noteq> 0\""], ["proof (prove)\nusing this:\n  (poly q a = (0::'a)) = (q = 0 \\<or> order a q \\<noteq> 0)\n  q \\<noteq> 0\n  order a q = 0\n\ngoal (1 subgoal):\n 1. poly q a \\<noteq> (0::'a)", "by auto"], ["proof (state)\nthis:\n  poly q a \\<noteq> (0::'a)\n\ngoal (2 subgoals):\n 1. \\<exists>a. poly p a = (0::'a) \\<Longrightarrow>\n    (\\<Sum>a | poly p a = (0::'a). order a p) \\<le> degree p\n 2. \\<nexists>a. poly p a = (0::'a) \\<Longrightarrow>\n    (\\<Sum>a | poly p a = (0::'a). order a p) \\<le> degree p", "have \"(\\<Sum>a\\<in>{a. poly q a = 0} - {a}. order a p) = (\\<Sum>a\\<in>{a. poly q a = 0} - {a}. order a q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>a\\<in>{a. poly q a = (0::'a)} - {a}. order a p) =\n    (\\<Sum>a\\<in>{a. poly q a = (0::'a)} - {a}. order a q)", "proof (rule sum.cong[OF refl])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {a. poly q a = (0::'a)} - {a} \\<Longrightarrow>\n       order x p = order x q", "fix b"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {a. poly q a = (0::'a)} - {a} \\<Longrightarrow>\n       order x p = order x q", "assume \"b \\<in> {a. poly q a = 0} - {a}\""], ["proof (state)\nthis:\n  b \\<in> {a. poly q a = (0::'a)} - {a}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {a. poly q a = (0::'a)} - {a} \\<Longrightarrow>\n       order x p = order x q", "hence \"b \\<noteq> a\""], ["proof (prove)\nusing this:\n  b \\<in> {a. poly q a = (0::'a)} - {a}\n\ngoal (1 subgoal):\n 1. b \\<noteq> a", "by auto"], ["proof (state)\nthis:\n  b \\<noteq> a\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {a. poly q a = (0::'a)} - {a} \\<Longrightarrow>\n       order x p = order x q", "hence \"order b ?a = 0\""], ["proof (prove)\nusing this:\n  b \\<noteq> a\n\ngoal (1 subgoal):\n 1. order b ([:- a, 1::'a:] ^ Suc n) = 0", "unfolding order_linear_power'"], ["proof (prove)\nusing this:\n  b \\<noteq> a\n\ngoal (1 subgoal):\n 1. (if - a = - b then Suc n else 0) = 0", "by simp"], ["proof (state)\nthis:\n  order b ([:- a, 1::'a:] ^ Suc n) = 0\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {a. poly q a = (0::'a)} - {a} \\<Longrightarrow>\n       order x p = order x q", "thus \"order b p = order b q\""], ["proof (prove)\nusing this:\n  order b ([:- a, 1::'a:] ^ Suc n) = 0\n\ngoal (1 subgoal):\n 1. order b p = order b q", "unfolding ord"], ["proof (prove)\nusing this:\n  order b ([:- a, 1::'a:] ^ Suc n) = 0\n\ngoal (1 subgoal):\n 1. order b ([:- a, 1::'a:] ^ Suc n) + order b q = order b q", "by simp"], ["proof (state)\nthis:\n  order b p = order b q\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>a\\<in>{a. poly q a = (0::'a)} - {a}. order a p) =\n  (\\<Sum>a\\<in>{a. poly q a = (0::'a)} - {a}. order a q)\n\ngoal (2 subgoals):\n 1. \\<exists>a. poly p a = (0::'a) \\<Longrightarrow>\n    (\\<Sum>a | poly p a = (0::'a). order a p) \\<le> degree p\n 2. \\<nexists>a. poly p a = (0::'a) \\<Longrightarrow>\n    (\\<Sum>a | poly p a = (0::'a). order a p) \\<le> degree p", "also"], ["proof (state)\nthis:\n  (\\<Sum>a\\<in>{a. poly q a = (0::'a)} - {a}. order a p) =\n  (\\<Sum>a\\<in>{a. poly q a = (0::'a)} - {a}. order a q)\n\ngoal (2 subgoals):\n 1. \\<exists>a. poly p a = (0::'a) \\<Longrightarrow>\n    (\\<Sum>a | poly p a = (0::'a). order a p) \\<le> degree p\n 2. \\<nexists>a. poly p a = (0::'a) \\<Longrightarrow>\n    (\\<Sum>a | poly p a = (0::'a). order a p) \\<le> degree p", "have \"\\<dots> = (\\<Sum>a\\<in>{a. poly q a = 0}. order a q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>a\\<in>{a. poly q a = (0::'a)} - {a}. order a q) =\n    (\\<Sum>a | poly q a = (0::'a). order a q)", "using qa"], ["proof (prove)\nusing this:\n  poly q a \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. (\\<Sum>a\\<in>{a. poly q a = (0::'a)} - {a}. order a q) =\n    (\\<Sum>a | poly q a = (0::'a). order a q)", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>a\\<in>{a. poly q a = (0::'a)} - {a}. order a q) =\n  (\\<Sum>a | poly q a = (0::'a). order a q)\n\ngoal (2 subgoals):\n 1. \\<exists>a. poly p a = (0::'a) \\<Longrightarrow>\n    (\\<Sum>a | poly p a = (0::'a). order a p) \\<le> degree p\n 2. \\<nexists>a. poly p a = (0::'a) \\<Longrightarrow>\n    (\\<Sum>a | poly p a = (0::'a). order a p) \\<le> degree p", "also"], ["proof (state)\nthis:\n  (\\<Sum>a\\<in>{a. poly q a = (0::'a)} - {a}. order a q) =\n  (\\<Sum>a | poly q a = (0::'a). order a q)\n\ngoal (2 subgoals):\n 1. \\<exists>a. poly p a = (0::'a) \\<Longrightarrow>\n    (\\<Sum>a | poly p a = (0::'a). order a p) \\<le> degree p\n 2. \\<nexists>a. poly p a = (0::'a) \\<Longrightarrow>\n    (\\<Sum>a | poly p a = (0::'a). order a p) \\<le> degree p", "have \"\\<dots> \\<le> degree q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>a | poly q a = (0::'a). order a q) \\<le> degree q", "by (rule Suc(1)[OF _ \\<open>q \\<noteq> 0\\<close>], \n        insert deg[unfolded degree_linear_power] Suc(2), auto)"], ["proof (state)\nthis:\n  (\\<Sum>a | poly q a = (0::'a). order a q) \\<le> degree q\n\ngoal (2 subgoals):\n 1. \\<exists>a. poly p a = (0::'a) \\<Longrightarrow>\n    (\\<Sum>a | poly p a = (0::'a). order a p) \\<le> degree p\n 2. \\<nexists>a. poly p a = (0::'a) \\<Longrightarrow>\n    (\\<Sum>a | poly p a = (0::'a). order a p) \\<le> degree p", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>a\\<in>{a. poly q a = (0::'a)} - {a}. order a p) \\<le> degree q", "have \"(\\<Sum>a\\<in>{a. poly q a = 0} - {a}. order a p) \\<le> degree q\""], ["proof (prove)\nusing this:\n  (\\<Sum>a\\<in>{a. poly q a = (0::'a)} - {a}. order a p) \\<le> degree q\n\ngoal (1 subgoal):\n 1. (\\<Sum>a\\<in>{a. poly q a = (0::'a)} - {a}. order a p) \\<le> degree q", "."], ["proof (state)\nthis:\n  (\\<Sum>a\\<in>{a. poly q a = (0::'a)} - {a}. order a p) \\<le> degree q\n\ngoal (2 subgoals):\n 1. \\<exists>a. poly p a = (0::'a) \\<Longrightarrow>\n    (\\<Sum>a | poly p a = (0::'a). order a p) \\<le> degree p\n 2. \\<nexists>a. poly p a = (0::'a) \\<Longrightarrow>\n    (\\<Sum>a | poly p a = (0::'a). order a p) \\<le> degree p", "thus ?thesis"], ["proof (prove)\nusing this:\n  (\\<Sum>a\\<in>{a. poly q a = (0::'a)} - {a}. order a p) \\<le> degree q\n\ngoal (1 subgoal):\n 1. (\\<Sum>a | poly p a = (0::'a). order a p) \\<le> degree p", "unfolding roots deg"], ["proof (prove)\nusing this:\n  (\\<Sum>a\\<in>{a. poly q a = (0::'a)} - {a}. order a p) \\<le> degree q\n\ngoal (1 subgoal):\n 1. (\\<Sum>a\\<in>insert a ({a. poly q a = (0::'a)} - {a}). order a p)\n    \\<le> degree ([:- a, 1::'a:] ^ Suc n) + degree q", "using fin"], ["proof (prove)\nusing this:\n  (\\<Sum>a\\<in>{a. poly q a = (0::'a)} - {a}. order a p) \\<le> degree q\n  finite {a. poly q a = (0::'a)}\n\ngoal (1 subgoal):\n 1. (\\<Sum>a\\<in>insert a ({a. poly q a = (0::'a)} - {a}). order a p)\n    \\<le> degree ([:- a, 1::'a:] ^ Suc n) + degree q", "by (subst sum.insert, simp_all only: degree_linear_power, auto simp: orda)"], ["proof (state)\nthis:\n  (\\<Sum>a | poly p a = (0::'a). order a p) \\<le> degree p\n\ngoal (1 subgoal):\n 1. \\<nexists>a. poly p a = (0::'a) \\<Longrightarrow>\n    (\\<Sum>a | poly p a = (0::'a). order a p) \\<le> degree p", "qed auto"], ["proof (state)\nthis:\n  (\\<Sum>a | poly p a = (0::'a). order a p) \\<le> degree p\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>a | poly p a = (0::'a). order a p) \\<le> degree p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma order_code[code]: \"order (a::'a::idom_divide) p = \n  (if p = 0 then Code.abort (STR ''order of polynomial 0 undefined'') (\\<lambda> _. order a p) \n   else if poly p a \\<noteq> 0 then 0 else Suc (order a (p div [: -a, 1 :])))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order a p =\n    (if p = 0\n     then Code.abort STR ''order of polynomial 0 undefined''\n           (\\<lambda>_. order a p)\n     else if poly p a \\<noteq> (0::'a) then 0\n          else Suc (order a (p div [:- a, 1::'a:])))", "proof (cases \"p = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow>\n    order a p =\n    (if p = 0\n     then Code.abort STR ''order of polynomial 0 undefined''\n           (\\<lambda>_. order a p)\n     else if poly p a \\<noteq> (0::'a) then 0\n          else Suc (order a (p div [:- a, 1::'a:])))\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    order a p =\n    (if p = 0\n     then Code.abort STR ''order of polynomial 0 undefined''\n           (\\<lambda>_. order a p)\n     else if poly p a \\<noteq> (0::'a) then 0\n          else Suc (order a (p div [:- a, 1::'a:])))", "case False"], ["proof (state)\nthis:\n  p \\<noteq> 0\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow>\n    order a p =\n    (if p = 0\n     then Code.abort STR ''order of polynomial 0 undefined''\n           (\\<lambda>_. order a p)\n     else if poly p a \\<noteq> (0::'a) then 0\n          else Suc (order a (p div [:- a, 1::'a:])))\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    order a p =\n    (if p = 0\n     then Code.abort STR ''order of polynomial 0 undefined''\n           (\\<lambda>_. order a p)\n     else if poly p a \\<noteq> (0::'a) then 0\n          else Suc (order a (p div [:- a, 1::'a:])))", "note p = this"], ["proof (state)\nthis:\n  p \\<noteq> 0\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow>\n    order a p =\n    (if p = 0\n     then Code.abort STR ''order of polynomial 0 undefined''\n           (\\<lambda>_. order a p)\n     else if poly p a \\<noteq> (0::'a) then 0\n          else Suc (order a (p div [:- a, 1::'a:])))\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    order a p =\n    (if p = 0\n     then Code.abort STR ''order of polynomial 0 undefined''\n           (\\<lambda>_. order a p)\n     else if poly p a \\<noteq> (0::'a) then 0\n          else Suc (order a (p div [:- a, 1::'a:])))", "note order = order[OF p]"], ["proof (state)\nthis:\n  [:- ?a, 1::'a:] ^ order ?a p dvd p \\<and>\n  \\<not> [:- ?a, 1::'a:] ^ Suc (order ?a p) dvd p\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow>\n    order a p =\n    (if p = 0\n     then Code.abort STR ''order of polynomial 0 undefined''\n           (\\<lambda>_. order a p)\n     else if poly p a \\<noteq> (0::'a) then 0\n          else Suc (order a (p div [:- a, 1::'a:])))\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    order a p =\n    (if p = 0\n     then Code.abort STR ''order of polynomial 0 undefined''\n           (\\<lambda>_. order a p)\n     else if poly p a \\<noteq> (0::'a) then 0\n          else Suc (order a (p div [:- a, 1::'a:])))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. order a p =\n    (if p = 0\n     then Code.abort STR ''order of polynomial 0 undefined''\n           (\\<lambda>_. order a p)\n     else if poly p a \\<noteq> (0::'a) then 0\n          else Suc (order a (p div [:- a, 1::'a:])))", "proof (cases \"poly p a = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. poly p a = (0::'a) \\<Longrightarrow>\n    order a p =\n    (if p = 0\n     then Code.abort STR ''order of polynomial 0 undefined''\n           (\\<lambda>_. order a p)\n     else if poly p a \\<noteq> (0::'a) then 0\n          else Suc (order a (p div [:- a, 1::'a:])))\n 2. poly p a \\<noteq> (0::'a) \\<Longrightarrow>\n    order a p =\n    (if p = 0\n     then Code.abort STR ''order of polynomial 0 undefined''\n           (\\<lambda>_. order a p)\n     else if poly p a \\<noteq> (0::'a) then 0\n          else Suc (order a (p div [:- a, 1::'a:])))", "case True"], ["proof (state)\nthis:\n  poly p a = (0::'a)\n\ngoal (2 subgoals):\n 1. poly p a = (0::'a) \\<Longrightarrow>\n    order a p =\n    (if p = 0\n     then Code.abort STR ''order of polynomial 0 undefined''\n           (\\<lambda>_. order a p)\n     else if poly p a \\<noteq> (0::'a) then 0\n          else Suc (order a (p div [:- a, 1::'a:])))\n 2. poly p a \\<noteq> (0::'a) \\<Longrightarrow>\n    order a p =\n    (if p = 0\n     then Code.abort STR ''order of polynomial 0 undefined''\n           (\\<lambda>_. order a p)\n     else if poly p a \\<noteq> (0::'a) then 0\n          else Suc (order a (p div [:- a, 1::'a:])))", "with order_root[of p a] p"], ["proof (chain)\npicking this:\n  (poly p a = (0::'a)) = (p = 0 \\<or> order a p \\<noteq> 0)\n  p \\<noteq> 0\n  poly p a = (0::'a)", "obtain n where ord: \"order a p = Suc n\""], ["proof (prove)\nusing this:\n  (poly p a = (0::'a)) = (p = 0 \\<or> order a p \\<noteq> 0)\n  p \\<noteq> 0\n  poly p a = (0::'a)\n\ngoal (1 subgoal):\n 1. (\\<And>n. order a p = Suc n \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases \"order a p\", auto)"], ["proof (state)\nthis:\n  order a p = Suc n\n\ngoal (2 subgoals):\n 1. poly p a = (0::'a) \\<Longrightarrow>\n    order a p =\n    (if p = 0\n     then Code.abort STR ''order of polynomial 0 undefined''\n           (\\<lambda>_. order a p)\n     else if poly p a \\<noteq> (0::'a) then 0\n          else Suc (order a (p div [:- a, 1::'a:])))\n 2. poly p a \\<noteq> (0::'a) \\<Longrightarrow>\n    order a p =\n    (if p = 0\n     then Code.abort STR ''order of polynomial 0 undefined''\n           (\\<lambda>_. order a p)\n     else if poly p a \\<noteq> (0::'a) then 0\n          else Suc (order a (p div [:- a, 1::'a:])))", "from this(1)"], ["proof (chain)\npicking this:\n  order a p = Suc n", "have \"[: -a, 1 :] dvd p\""], ["proof (prove)\nusing this:\n  order a p = Suc n\n\ngoal (1 subgoal):\n 1. [:- a, 1::'a:] dvd p", "using True poly_eq_0_iff_dvd"], ["proof (prove)\nusing this:\n  order a p = Suc n\n  poly p a = (0::'a)\n  (poly ?p ?c = (0::?'a)) = ([:- ?c, 1::?'a:] dvd ?p)\n\ngoal (1 subgoal):\n 1. [:- a, 1::'a:] dvd p", "by blast"], ["proof (state)\nthis:\n  [:- a, 1::'a:] dvd p\n\ngoal (2 subgoals):\n 1. poly p a = (0::'a) \\<Longrightarrow>\n    order a p =\n    (if p = 0\n     then Code.abort STR ''order of polynomial 0 undefined''\n           (\\<lambda>_. order a p)\n     else if poly p a \\<noteq> (0::'a) then 0\n          else Suc (order a (p div [:- a, 1::'a:])))\n 2. poly p a \\<noteq> (0::'a) \\<Longrightarrow>\n    order a p =\n    (if p = 0\n     then Code.abort STR ''order of polynomial 0 undefined''\n           (\\<lambda>_. order a p)\n     else if poly p a \\<noteq> (0::'a) then 0\n          else Suc (order a (p div [:- a, 1::'a:])))", "then"], ["proof (chain)\npicking this:\n  [:- a, 1::'a:] dvd p", "obtain q where p: \"p = [: -a, 1 :] * q\""], ["proof (prove)\nusing this:\n  [:- a, 1::'a:] dvd p\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        p = [:- a, 1::'a:] * q \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding dvd_def"], ["proof (prove)\nusing this:\n  \\<exists>k. p = [:- a, 1::'a:] * k\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        p = [:- a, 1::'a:] * q \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  p = [:- a, 1::'a:] * q\n\ngoal (2 subgoals):\n 1. poly p a = (0::'a) \\<Longrightarrow>\n    order a p =\n    (if p = 0\n     then Code.abort STR ''order of polynomial 0 undefined''\n           (\\<lambda>_. order a p)\n     else if poly p a \\<noteq> (0::'a) then 0\n          else Suc (order a (p div [:- a, 1::'a:])))\n 2. poly p a \\<noteq> (0::'a) \\<Longrightarrow>\n    order a p =\n    (if p = 0\n     then Code.abort STR ''order of polynomial 0 undefined''\n           (\\<lambda>_. order a p)\n     else if poly p a \\<noteq> (0::'a) then 0\n          else Suc (order a (p div [:- a, 1::'a:])))", "have ord: \"order a p = order a [: -a, 1 :] + order a q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order a p = order a [:- a, 1::'a:] + order a q", "using p False order_mult[of \"[: -a, 1 :]\" q]"], ["proof (prove)\nusing this:\n  p = [:- a, 1::'a:] * q\n  p \\<noteq> 0\n  [:- a, 1::'a:] * q \\<noteq> 0 \\<Longrightarrow>\n  order ?a ([:- a, 1::'a:] * q) = order ?a [:- a, 1::'a:] + order ?a q\n\ngoal (1 subgoal):\n 1. order a p = order a [:- a, 1::'a:] + order a q", "by auto"], ["proof (state)\nthis:\n  order a p = order a [:- a, 1::'a:] + order a q\n\ngoal (2 subgoals):\n 1. poly p a = (0::'a) \\<Longrightarrow>\n    order a p =\n    (if p = 0\n     then Code.abort STR ''order of polynomial 0 undefined''\n           (\\<lambda>_. order a p)\n     else if poly p a \\<noteq> (0::'a) then 0\n          else Suc (order a (p div [:- a, 1::'a:])))\n 2. poly p a \\<noteq> (0::'a) \\<Longrightarrow>\n    order a p =\n    (if p = 0\n     then Code.abort STR ''order of polynomial 0 undefined''\n           (\\<lambda>_. order a p)\n     else if poly p a \\<noteq> (0::'a) then 0\n          else Suc (order a (p div [:- a, 1::'a:])))", "have q: \"p div [: -a, 1 :] = q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p div [:- a, 1::'a:] = q", "using False p"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  p = [:- a, 1::'a:] * q\n\ngoal (1 subgoal):\n 1. p div [:- a, 1::'a:] = q", "by (metis mult_zero_left nonzero_mult_div_cancel_left)"], ["proof (state)\nthis:\n  p div [:- a, 1::'a:] = q\n\ngoal (2 subgoals):\n 1. poly p a = (0::'a) \\<Longrightarrow>\n    order a p =\n    (if p = 0\n     then Code.abort STR ''order of polynomial 0 undefined''\n           (\\<lambda>_. order a p)\n     else if poly p a \\<noteq> (0::'a) then 0\n          else Suc (order a (p div [:- a, 1::'a:])))\n 2. poly p a \\<noteq> (0::'a) \\<Longrightarrow>\n    order a p =\n    (if p = 0\n     then Code.abort STR ''order of polynomial 0 undefined''\n           (\\<lambda>_. order a p)\n     else if poly p a \\<noteq> (0::'a) then 0\n          else Suc (order a (p div [:- a, 1::'a:])))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. order a p =\n    (if p = 0\n     then Code.abort STR ''order of polynomial 0 undefined''\n           (\\<lambda>_. order a p)\n     else if poly p a \\<noteq> (0::'a) then 0\n          else Suc (order a (p div [:- a, 1::'a:])))", "unfolding ord q"], ["proof (prove)\ngoal (1 subgoal):\n 1. order a [:- a, 1::'a:] + order a q =\n    (if p = 0\n     then Code.abort STR ''order of polynomial 0 undefined''\n           (\\<lambda>_. order a [:- a, 1::'a:] + order a q)\n     else if poly p a \\<noteq> (0::'a) then 0 else Suc (order a q))", "using False True"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  poly p a = (0::'a)\n\ngoal (1 subgoal):\n 1. order a [:- a, 1::'a:] + order a q =\n    (if p = 0\n     then Code.abort STR ''order of polynomial 0 undefined''\n           (\\<lambda>_. order a [:- a, 1::'a:] + order a q)\n     else if poly p a \\<noteq> (0::'a) then 0 else Suc (order a q))", "by auto"], ["proof (state)\nthis:\n  order a p =\n  (if p = 0\n   then Code.abort STR ''order of polynomial 0 undefined''\n         (\\<lambda>_. order a p)\n   else if poly p a \\<noteq> (0::'a) then 0\n        else Suc (order a (p div [:- a, 1::'a:])))\n\ngoal (1 subgoal):\n 1. poly p a \\<noteq> (0::'a) \\<Longrightarrow>\n    order a p =\n    (if p = 0\n     then Code.abort STR ''order of polynomial 0 undefined''\n           (\\<lambda>_. order a p)\n     else if poly p a \\<noteq> (0::'a) then 0\n          else Suc (order a (p div [:- a, 1::'a:])))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. poly p a \\<noteq> (0::'a) \\<Longrightarrow>\n    order a p =\n    (if p = 0\n     then Code.abort STR ''order of polynomial 0 undefined''\n           (\\<lambda>_. order a p)\n     else if poly p a \\<noteq> (0::'a) then 0\n          else Suc (order a (p div [:- a, 1::'a:])))", "case False"], ["proof (state)\nthis:\n  poly p a \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. poly p a \\<noteq> (0::'a) \\<Longrightarrow>\n    order a p =\n    (if p = 0\n     then Code.abort STR ''order of polynomial 0 undefined''\n           (\\<lambda>_. order a p)\n     else if poly p a \\<noteq> (0::'a) then 0\n          else Suc (order a (p div [:- a, 1::'a:])))", "with order_root[of p a] p"], ["proof (chain)\npicking this:\n  (poly p a = (0::'a)) = (p = 0 \\<or> order a p \\<noteq> 0)\n  p \\<noteq> 0\n  poly p a \\<noteq> (0::'a)", "show ?thesis"], ["proof (prove)\nusing this:\n  (poly p a = (0::'a)) = (p = 0 \\<or> order a p \\<noteq> 0)\n  p \\<noteq> 0\n  poly p a \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. order a p =\n    (if p = 0\n     then Code.abort STR ''order of polynomial 0 undefined''\n           (\\<lambda>_. order a p)\n     else if poly p a \\<noteq> (0::'a) then 0\n          else Suc (order a (p div [:- a, 1::'a:])))", "by auto"], ["proof (state)\nthis:\n  order a p =\n  (if p = 0\n   then Code.abort STR ''order of polynomial 0 undefined''\n         (\\<lambda>_. order a p)\n   else if poly p a \\<noteq> (0::'a) then 0\n        else Suc (order a (p div [:- a, 1::'a:])))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  order a p =\n  (if p = 0\n   then Code.abort STR ''order of polynomial 0 undefined''\n         (\\<lambda>_. order a p)\n   else if poly p a \\<noteq> (0::'a) then 0\n        else Suc (order a (p div [:- a, 1::'a:])))\n\ngoal (1 subgoal):\n 1. p = 0 \\<Longrightarrow>\n    order a p =\n    (if p = 0\n     then Code.abort STR ''order of polynomial 0 undefined''\n           (\\<lambda>_. order a p)\n     else if poly p a \\<noteq> (0::'a) then 0\n          else Suc (order a (p div [:- a, 1::'a:])))", "qed auto"], ["", "end"]]}