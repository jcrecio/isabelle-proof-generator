{"file_name": "/home/qj213/afp-2021-10-22/thys/Polynomial_Factorization/Kronecker_Factorization.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Polynomial_Factorization", "problem_names": ["lemma kronecker_samples_0: \"0 \\<in> set (kronecker_samples n)\"", "lemma divisors_nat_copy[simp]: \"divisors_nat_copy = divisors_nat\"", "lemma memo_divisors_nat[code_unfold]: \"divisors_nat = memo_divisors_nat\"", "lemma rat_to_int_poly_of_int: assumes rp: \"rat_to_int_poly (map_poly of_int p) = (c,q)\"\n  shows \"c = 1\" \"q = p\"", "lemma rat_to_normalized_int_poly_of_int: assumes \"rat_to_normalized_int_poly (map_poly of_int p) = (c,q)\"\n  shows \"c \\<in> \\<int>\" \"p \\<noteq> 0 \\<Longrightarrow> c = of_int (content p) \\<and> q = primitive_part p\"", "lemma dvd_poly_int_content_1: assumes c_x: \"content x = 1\"\n  shows \"(x dvd y) = (map_poly rat_of_int x dvd map_poly of_int y)\"", "lemma content_x_minus_const_int[simp]: \"content [: c, 1 :] = (1 :: int)\"", "lemma length_upto_add_nat[simp]: \"length [a .. a + int n] = Suc n\"", "lemma kronecker_samples: \"distinct (kronecker_samples n)\" \"length (kronecker_samples n) = Suc n\"", "lemma dvd_int_poly_non_0_degree_1[simp]: \"degree q \\<ge> 1 \\<Longrightarrow> dvd_int_poly_non_0 q p = (q dvd p)\"", "lemma kronecker_factorization_main_sound: assumes some: \"kronecker_factorization_main df dp bnd p = Some q\"\n  and bnd: \"degree p \\<ge> 2 \\<Longrightarrow> bnd \\<ge> 1\"\n  shows \"degree q \\<ge> 1\" \"degree q \\<le> bnd\" \"q dvd p\"", "lemma kronecker_factorization_rat_main_sound: assumes \n  some: \"kronecker_factorization_rat_main df dp bnd p = Some q\"\n  and bnd: \"degree p \\<ge> 2 \\<Longrightarrow> bnd \\<ge> 1\"\n  shows \"degree q \\<ge> 1\" \"degree q \\<le> bnd\" \"q dvd p\"", "lemma kronecker_factorization_main_complete: assumes \n  none: \"kronecker_factorization_main df dp bnd p = None\"\n  and dp: \"degree p \\<ge> 2\"\n  shows \"\\<not> (\\<exists> q. 1 \\<le> degree q \\<and> degree q \\<le> bnd \\<and> q dvd p)\"", "lemma kronecker_factorization_rat_main_complete: assumes \n  none: \"kronecker_factorization_rat_main df dp bnd p = None\"\n  and dp: \"degree p \\<ge> 2\"\n  shows \"\\<not> (\\<exists> q. 1 \\<le> degree q \\<and> degree q \\<le> bnd \\<and> q dvd p)\"", "lemma kronecker_factorization:\n  \"kronecker_factorization p = Some q \\<Longrightarrow> \n    degree q \\<ge> 1 \\<and> degree q < degree p \\<and> q dvd p\"\n  \"kronecker_factorization p = None \\<Longrightarrow> degree p \\<ge> 1 \\<Longrightarrow> irreducible\\<^sub>d p\"", "lemma kronecker_factorization_rat:\n  \"kronecker_factorization_rat p = Some q \\<Longrightarrow> \n    degree q \\<ge> 1 \\<and> degree q < degree p \\<and> q dvd p\"\n  \"kronecker_factorization_rat p = None \\<Longrightarrow> degree p \\<ge> 1 \\<Longrightarrow> irreducible\\<^sub>d p\""], "translations": [["", "lemma kronecker_samples_0: \"0 \\<in> set (kronecker_samples n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<in> set (kronecker_samples n)", "unfolding kronecker_samples_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<in> set (let min = - int (n div 2) in [min..min + int n])", "by auto"], ["", "text \\<open>Since 0 is always a samples value, we make a case analysis: \n   we only take positive divisors of $p(0)$, and consider all divisors for other $p(j)$.\\<close>"], ["", "definition kronecker_factorization_main :: \"int poly \\<Rightarrow> int poly option\" where\n  \"kronecker_factorization_main p \\<equiv> if degree p \\<le> 1 then None else let \n     p = primitive_part p;\n     js = kronecker_samples bnd;\n     cjs = map (\\<lambda> j. (poly p j, j)) js\n   in (case map_of cjs 0 of \n     Some j \\<Rightarrow> Some ([:- j, 1 :])\n   | None \\<Rightarrow> let djs = map (\\<lambda> (v,j). map (Pair j) (if j = 0 then dp v else df v)) cjs in \n     map_option the (find_map_filter newton_interpolation_poly_int\n     (\\<lambda> go. case go of None \\<Rightarrow> False | Some g \\<Rightarrow> dvd_int_poly_non_0 g p \\<and> degree g \\<ge> 1) \n       (concat_lists djs)))\""], ["", "definition kronecker_factorization_rat_main :: \"rat poly \\<Rightarrow> rat poly option\" where\n  \"kronecker_factorization_rat_main p \\<equiv> map_option (map_poly of_int) \n     (kronecker_factorization_main (snd (rat_to_normalized_int_poly p)))\""], ["", "end"], ["", "definition kronecker_factorization :: \"int poly \\<Rightarrow> int poly option\" where\n  \"kronecker_factorization p = \n     kronecker_factorization_main divisors_int divisors_int_pos (degree p div 2) p\""], ["", "definition kronecker_factorization_rat :: \"rat poly \\<Rightarrow> rat poly option\" where\n  \"kronecker_factorization_rat p = \n     kronecker_factorization_rat_main divisors_int divisors_int_pos (degree p div 2) p\""], ["", "subsection \\<open>Code setup for divisors\\<close>"], ["", "definition \"divisors_nat_copy n \\<equiv> if n = 0 then [] else remdups_adj (sort (map prod_list (subseqs (prime_factorization_nat n))))\""], ["", "lemma divisors_nat_copy[simp]: \"divisors_nat_copy = divisors_nat\""], ["proof (prove)\ngoal (1 subgoal):\n 1. divisors_nat_copy = divisors_nat", "unfolding divisors_nat_def[abs_def] divisors_nat_copy_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n.\n        if n = 0 then []\n        else remdups_adj\n              (sort\n                (map prod_list (subseqs (prime_factorization_nat n))))) =\n    (\\<lambda>n.\n        if n = 0 then []\n        else remdups_adj\n              (sort (map prod_list (subseqs (prime_factorization_nat n)))))", ".."], ["", "definition \"memo_divisors_nat \\<equiv> memo_nat 0 100 divisors_nat_copy\""], ["", "lemma memo_divisors_nat[code_unfold]: \"divisors_nat = memo_divisors_nat\""], ["proof (prove)\ngoal (1 subgoal):\n 1. divisors_nat = memo_divisors_nat", "unfolding memo_divisors_nat_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. divisors_nat = memo_nat 0 100 divisors_nat_copy", "by simp"], ["", "subsection \\<open>Proofs\\<close>"], ["", "context\nbegin"], ["", "lemma rat_to_int_poly_of_int: assumes rp: \"rat_to_int_poly (map_poly of_int p) = (c,q)\"\n  shows \"c = 1\" \"q = p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c = 1 &&& q = p", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. c = 1\n 2. q = p", "define xs where \"xs = map (snd \\<circ> quotient_of) (coeffs (map_poly rat_of_int p))\""], ["proof (state)\nthis:\n  xs = map (snd \\<circ> quotient_of) (coeffs (of_int_poly p))\n\ngoal (2 subgoals):\n 1. c = 1\n 2. q = p", "have xs: \"set xs \\<subseteq> {1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set xs \\<subseteq> {1}", "unfolding xs_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (map (snd \\<circ> quotient_of) (coeffs (of_int_poly p)))\n    \\<subseteq> {1}", "by auto"], ["proof (state)\nthis:\n  set xs \\<subseteq> {1}\n\ngoal (2 subgoals):\n 1. c = 1\n 2. q = p", "from assms[unfolded rat_to_int_poly_def Let_def]"], ["proof (chain)\npicking this:\n  (fst (common_denom (coeffs (of_int_poly p))),\n   map_poly\n    (\\<lambda>x.\n        case quotient_of x of\n        (pa, x) \\<Rightarrow>\n          pa * fst (common_denom (coeffs (of_int_poly p))) div x)\n    (of_int_poly p)) =\n  (c, q)", "have c: \"c = fst (common_denom (coeffs (map_poly rat_of_int p)))\""], ["proof (prove)\nusing this:\n  (fst (common_denom (coeffs (of_int_poly p))),\n   map_poly\n    (\\<lambda>x.\n        case quotient_of x of\n        (pa, x) \\<Rightarrow>\n          pa * fst (common_denom (coeffs (of_int_poly p))) div x)\n    (of_int_poly p)) =\n  (c, q)\n\ngoal (1 subgoal):\n 1. c = fst (common_denom (coeffs (of_int_poly p)))", "by auto"], ["proof (state)\nthis:\n  c = fst (common_denom (coeffs (of_int_poly p)))\n\ngoal (2 subgoals):\n 1. c = 1\n 2. q = p", "also"], ["proof (state)\nthis:\n  c = fst (common_denom (coeffs (of_int_poly p)))\n\ngoal (2 subgoals):\n 1. c = 1\n 2. q = p", "have \"\\<dots> = list_lcm xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (common_denom (coeffs (of_int_poly p))) = lcm_list xs", "unfolding common_denom_def Let_def xs_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (lcm_list (map snd (map quotient_of (coeffs (of_int_poly p)))),\n         map (\\<lambda>(n, y).\n                 n *\n                 lcm_list\n                  (map snd (map quotient_of (coeffs (of_int_poly p)))) div\n                 y)\n          (map quotient_of (coeffs (of_int_poly p)))) =\n    lcm_list (map (snd \\<circ> quotient_of) (coeffs (of_int_poly p)))", "by (simp add: o_assoc)"], ["proof (state)\nthis:\n  fst (common_denom (coeffs (of_int_poly p))) = lcm_list xs\n\ngoal (2 subgoals):\n 1. c = 1\n 2. q = p", "also"], ["proof (state)\nthis:\n  fst (common_denom (coeffs (of_int_poly p))) = lcm_list xs\n\ngoal (2 subgoals):\n 1. c = 1\n 2. q = p", "have \"\\<dots> = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lcm_list xs = 1", "using xs"], ["proof (prove)\nusing this:\n  set xs \\<subseteq> {1}\n\ngoal (1 subgoal):\n 1. lcm_list xs = 1", "by (induct xs, auto)"], ["proof (state)\nthis:\n  lcm_list xs = 1\n\ngoal (2 subgoals):\n 1. c = 1\n 2. q = p", "finally"], ["proof (chain)\npicking this:\n  c = 1", "show c: \"c = 1\""], ["proof (prove)\nusing this:\n  c = 1\n\ngoal (1 subgoal):\n 1. c = 1", "by auto"], ["proof (state)\nthis:\n  c = 1\n\ngoal (1 subgoal):\n 1. q = p", "from rat_to_int_poly[OF rp, unfolded c]"], ["proof (chain)\npicking this:\n  of_int_poly p = smult (inverse (rat_of_int 1)) (of_int_poly q)\n  0 < 1", "show \"q = p\""], ["proof (prove)\nusing this:\n  of_int_poly p = smult (inverse (rat_of_int 1)) (of_int_poly q)\n  0 < 1\n\ngoal (1 subgoal):\n 1. q = p", "by auto"], ["proof (state)\nthis:\n  q = p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rat_to_normalized_int_poly_of_int: assumes \"rat_to_normalized_int_poly (map_poly of_int p) = (c,q)\"\n  shows \"c \\<in> \\<int>\" \"p \\<noteq> 0 \\<Longrightarrow> c = of_int (content p) \\<and> q = primitive_part p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c \\<in> \\<int> &&&\n    (p \\<noteq> 0 \\<Longrightarrow>\n     c = rat_of_int (content p) \\<and> q = primitive_part p)", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. c \\<in> \\<int>\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    c = rat_of_int (content p) \\<and> q = primitive_part p", "obtain d r where ri: \"rat_to_int_poly (map_poly rat_of_int p) = (d,r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>d r.\n        rat_to_int_poly (of_int_poly p) = (d, r) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  rat_to_int_poly (of_int_poly p) = (d, r)\n\ngoal (2 subgoals):\n 1. c \\<in> \\<int>\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    c = rat_of_int (content p) \\<and> q = primitive_part p", "from rat_to_int_poly_of_int[OF ri]\n    assms[unfolded rat_to_normalized_int_poly_def ri split]"], ["proof (chain)\npicking this:\n  d = 1\n  r = p\n  (if of_int_poly p = 0 then (1, 0)\n   else (rat_of_int (content r) / rat_of_int d, primitive_part r)) =\n  (c, q)", "show \"c \\<in> \\<int>\" \"p \\<noteq> 0 \\<Longrightarrow> c = of_int (content p) \\<and> q = primitive_part p\""], ["proof (prove)\nusing this:\n  d = 1\n  r = p\n  (if of_int_poly p = 0 then (1, 0)\n   else (rat_of_int (content r) / rat_of_int d, primitive_part r)) =\n  (c, q)\n\ngoal (1 subgoal):\n 1. c \\<in> \\<int> &&&\n    (p \\<noteq> 0 \\<Longrightarrow>\n     c = rat_of_int (content p) \\<and> q = primitive_part p)", "by (auto split: if_splits)"], ["proof (state)\nthis:\n  c \\<in> \\<int>\n  p \\<noteq> 0 \\<Longrightarrow>\n  c = rat_of_int (content p) \\<and> q = primitive_part p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma dvd_poly_int_content_1: assumes c_x: \"content x = 1\"\n  shows \"(x dvd y) = (map_poly rat_of_int x dvd map_poly of_int y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x dvd y) = (of_int_poly x dvd of_int_poly y)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (x dvd y) = (of_int_poly x dvd of_int_poly y)", "let ?r = \"rat_of_int\""], ["proof (state)\ngoal (1 subgoal):\n 1. (x dvd y) = (of_int_poly x dvd of_int_poly y)", "let ?rp = \"map_poly ?r\""], ["proof (state)\ngoal (1 subgoal):\n 1. (x dvd y) = (of_int_poly x dvd of_int_poly y)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (x dvd y) = (of_int_poly x dvd of_int_poly y)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. x dvd y \\<Longrightarrow> of_int_poly x dvd of_int_poly y\n 2. of_int_poly x dvd of_int_poly y \\<Longrightarrow> x dvd y", "assume \"x dvd y\""], ["proof (state)\nthis:\n  x dvd y\n\ngoal (2 subgoals):\n 1. x dvd y \\<Longrightarrow> of_int_poly x dvd of_int_poly y\n 2. of_int_poly x dvd of_int_poly y \\<Longrightarrow> x dvd y", "then"], ["proof (chain)\npicking this:\n  x dvd y", "obtain z where \"y = x * z\""], ["proof (prove)\nusing this:\n  x dvd y\n\ngoal (1 subgoal):\n 1. (\\<And>z. y = x * z \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "unfolding dvd_def"], ["proof (prove)\nusing this:\n  \\<exists>k. y = x * k\n\ngoal (1 subgoal):\n 1. (\\<And>z. y = x * z \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  y = x * z\n\ngoal (2 subgoals):\n 1. x dvd y \\<Longrightarrow> of_int_poly x dvd of_int_poly y\n 2. of_int_poly x dvd of_int_poly y \\<Longrightarrow> x dvd y", "from arg_cong[OF this, of ?rp]"], ["proof (chain)\npicking this:\n  of_int_poly y = of_int_poly (x * z)", "show \"?rp x dvd ?rp y\""], ["proof (prove)\nusing this:\n  of_int_poly y = of_int_poly (x * z)\n\ngoal (1 subgoal):\n 1. of_int_poly x dvd of_int_poly y", "by auto"], ["proof (state)\nthis:\n  of_int_poly x dvd of_int_poly y\n\ngoal (1 subgoal):\n 1. of_int_poly x dvd of_int_poly y \\<Longrightarrow> x dvd y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. of_int_poly x dvd of_int_poly y \\<Longrightarrow> x dvd y", "assume dvd: \"?rp x dvd ?rp y\""], ["proof (state)\nthis:\n  of_int_poly x dvd of_int_poly y\n\ngoal (1 subgoal):\n 1. of_int_poly x dvd of_int_poly y \\<Longrightarrow> x dvd y", "show \"x dvd y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x dvd y", "proof (cases \"y = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. y = 0 \\<Longrightarrow> x dvd y\n 2. y \\<noteq> 0 \\<Longrightarrow> x dvd y", "case True"], ["proof (state)\nthis:\n  y = 0\n\ngoal (2 subgoals):\n 1. y = 0 \\<Longrightarrow> x dvd y\n 2. y \\<noteq> 0 \\<Longrightarrow> x dvd y", "thus ?thesis"], ["proof (prove)\nusing this:\n  y = 0\n\ngoal (1 subgoal):\n 1. x dvd y", "by auto"], ["proof (state)\nthis:\n  x dvd y\n\ngoal (1 subgoal):\n 1. y \\<noteq> 0 \\<Longrightarrow> x dvd y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. y \\<noteq> 0 \\<Longrightarrow> x dvd y", "case False"], ["proof (state)\nthis:\n  y \\<noteq> 0\n\ngoal (1 subgoal):\n 1. y \\<noteq> 0 \\<Longrightarrow> x dvd y", "note y0 = this"], ["proof (state)\nthis:\n  y \\<noteq> 0\n\ngoal (1 subgoal):\n 1. y \\<noteq> 0 \\<Longrightarrow> x dvd y", "hence \"?rp y \\<noteq> 0\""], ["proof (prove)\nusing this:\n  y \\<noteq> 0\n\ngoal (1 subgoal):\n 1. of_int_poly y \\<noteq> 0", "by simp"], ["proof (state)\nthis:\n  of_int_poly y \\<noteq> 0\n\ngoal (1 subgoal):\n 1. y \\<noteq> 0 \\<Longrightarrow> x dvd y", "hence rx0: \"?rp x \\<noteq> 0\""], ["proof (prove)\nusing this:\n  of_int_poly y \\<noteq> 0\n\ngoal (1 subgoal):\n 1. of_int_poly x \\<noteq> 0", "using dvd"], ["proof (prove)\nusing this:\n  of_int_poly y \\<noteq> 0\n  of_int_poly x dvd of_int_poly y\n\ngoal (1 subgoal):\n 1. of_int_poly x \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  of_int_poly x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. y \\<noteq> 0 \\<Longrightarrow> x dvd y", "hence x0: \"x \\<noteq> 0\""], ["proof (prove)\nusing this:\n  of_int_poly x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0", "by simp"], ["proof (state)\nthis:\n  x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. y \\<noteq> 0 \\<Longrightarrow> x dvd y", "from dvd"], ["proof (chain)\npicking this:\n  of_int_poly x dvd of_int_poly y", "obtain z where prod: \"?rp y = ?rp x * z\""], ["proof (prove)\nusing this:\n  of_int_poly x dvd of_int_poly y\n\ngoal (1 subgoal):\n 1. (\\<And>z.\n        of_int_poly y = of_int_poly x * z \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding dvd_def"], ["proof (prove)\nusing this:\n  \\<exists>k. of_int_poly y = of_int_poly x * k\n\ngoal (1 subgoal):\n 1. (\\<And>z.\n        of_int_poly y = of_int_poly x * z \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  of_int_poly y = of_int_poly x * z\n\ngoal (1 subgoal):\n 1. y \\<noteq> 0 \\<Longrightarrow> x dvd y", "obtain cx xx where x: \"rat_to_normalized_int_poly (?rp x) = (cx, xx)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>cx xx.\n        rat_to_normalized_int_poly (of_int_poly x) =\n        (cx, xx) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  rat_to_normalized_int_poly (of_int_poly x) = (cx, xx)\n\ngoal (1 subgoal):\n 1. y \\<noteq> 0 \\<Longrightarrow> x dvd y", "from rat_to_int_factor_explicit[OF prod x]"], ["proof (chain)\npicking this:\n  \\<exists>r. y = xx * smult (content y) r", "obtain z where y: \"y = xx * smult (content y) z\""], ["proof (prove)\nusing this:\n  \\<exists>r. y = xx * smult (content y) r\n\ngoal (1 subgoal):\n 1. (\\<And>z.\n        y = xx * smult (content y) z \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  y = xx * smult (content y) z\n\ngoal (1 subgoal):\n 1. y \\<noteq> 0 \\<Longrightarrow> x dvd y", "from rat_to_normalized_int_poly[OF x] rx0"], ["proof (chain)\npicking this:\n  of_int_poly x = smult cx (of_int_poly xx)\n  0 < cx\n  of_int_poly x \\<noteq> 0 \\<Longrightarrow> content xx = 1\n  degree xx = degree (of_int_poly x)\n  of_int_poly x \\<noteq> 0", "have xx: \"?rp x = smult cx (?rp xx)\" \n        and cxx: \"content xx = 1\" and cx0: \"cx > 0\""], ["proof (prove)\nusing this:\n  of_int_poly x = smult cx (of_int_poly xx)\n  0 < cx\n  of_int_poly x \\<noteq> 0 \\<Longrightarrow> content xx = 1\n  degree xx = degree (of_int_poly x)\n  of_int_poly x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. of_int_poly x = smult cx (of_int_poly xx) &&& content xx = 1 &&& 0 < cx", "by auto"], ["proof (state)\nthis:\n  of_int_poly x = smult cx (of_int_poly xx)\n  content xx = 1\n  0 < cx\n\ngoal (1 subgoal):\n 1. y \\<noteq> 0 \\<Longrightarrow> x dvd y", "obtain cn cd where quot: \"quotient_of cx = (cn,cd)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>cn cd.\n        quotient_of cx = (cn, cd) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  quotient_of cx = (cn, cd)\n\ngoal (1 subgoal):\n 1. y \\<noteq> 0 \\<Longrightarrow> x dvd y", "from quotient_of_div[OF quot]"], ["proof (chain)\npicking this:\n  cx = rat_of_int cn / rat_of_int cd", "have cx: \"cx = ?r cn / ?r cd\""], ["proof (prove)\nusing this:\n  cx = rat_of_int cn / rat_of_int cd\n\ngoal (1 subgoal):\n 1. cx = rat_of_int cn / rat_of_int cd", "by auto"], ["proof (state)\nthis:\n  cx = rat_of_int cn / rat_of_int cd\n\ngoal (1 subgoal):\n 1. y \\<noteq> 0 \\<Longrightarrow> x dvd y", "from quotient_of_denom_pos[OF quot]"], ["proof (chain)\npicking this:\n  0 < cd", "have cd0: \"cd > 0\""], ["proof (prove)\nusing this:\n  0 < cd\n\ngoal (1 subgoal):\n 1. 0 < cd", "by auto"], ["proof (state)\nthis:\n  0 < cd\n\ngoal (1 subgoal):\n 1. y \\<noteq> 0 \\<Longrightarrow> x dvd y", "with cx cx0"], ["proof (chain)\npicking this:\n  cx = rat_of_int cn / rat_of_int cd\n  0 < cx\n  0 < cd", "have cn0: \"cn > 0\""], ["proof (prove)\nusing this:\n  cx = rat_of_int cn / rat_of_int cd\n  0 < cx\n  0 < cd\n\ngoal (1 subgoal):\n 1. 0 < cn", "by (simp add: zero_less_divide_iff)"], ["proof (state)\nthis:\n  0 < cn\n\ngoal (1 subgoal):\n 1. y \\<noteq> 0 \\<Longrightarrow> x dvd y", "from arg_cong[OF xx, of \"smult (?r cd)\"]"], ["proof (chain)\npicking this:\n  smult (rat_of_int cd) (of_int_poly x) =\n  smult (rat_of_int cd) (smult cx (of_int_poly xx))", "have \"smult (?r cd) (?rp x) = smult (?r cn) (?rp xx)\""], ["proof (prove)\nusing this:\n  smult (rat_of_int cd) (of_int_poly x) =\n  smult (rat_of_int cd) (smult cx (of_int_poly xx))\n\ngoal (1 subgoal):\n 1. smult (rat_of_int cd) (of_int_poly x) =\n    smult (rat_of_int cn) (of_int_poly xx)", "unfolding cx"], ["proof (prove)\nusing this:\n  smult (rat_of_int cd) (of_int_poly x) =\n  smult (rat_of_int cd)\n   (smult (rat_of_int cn / rat_of_int cd) (of_int_poly xx))\n\ngoal (1 subgoal):\n 1. smult (rat_of_int cd) (of_int_poly x) =\n    smult (rat_of_int cn) (of_int_poly xx)", "using cd0"], ["proof (prove)\nusing this:\n  smult (rat_of_int cd) (of_int_poly x) =\n  smult (rat_of_int cd)\n   (smult (rat_of_int cn / rat_of_int cd) (of_int_poly xx))\n  0 < cd\n\ngoal (1 subgoal):\n 1. smult (rat_of_int cd) (of_int_poly x) =\n    smult (rat_of_int cn) (of_int_poly xx)", "by (auto simp: field_simps)"], ["proof (state)\nthis:\n  smult (rat_of_int cd) (of_int_poly x) =\n  smult (rat_of_int cn) (of_int_poly xx)\n\ngoal (1 subgoal):\n 1. y \\<noteq> 0 \\<Longrightarrow> x dvd y", "from this"], ["proof (chain)\npicking this:\n  smult (rat_of_int cd) (of_int_poly x) =\n  smult (rat_of_int cn) (of_int_poly xx)", "have id: \"smult cd x = smult cn xx\""], ["proof (prove)\nusing this:\n  smult (rat_of_int cd) (of_int_poly x) =\n  smult (rat_of_int cn) (of_int_poly xx)\n\ngoal (1 subgoal):\n 1. smult cd x = smult cn xx", "by (fold hom_distribs, unfold of_int_poly_hom.eq_iff)"], ["proof (state)\nthis:\n  smult cd x = smult cn xx\n\ngoal (1 subgoal):\n 1. y \\<noteq> 0 \\<Longrightarrow> x dvd y", "from arg_cong[OF this, of content, unfolded content_smult_int cxx] cn0 cd0"], ["proof (chain)\npicking this:\n  \\<bar>cd\\<bar> * content x = \\<bar>cn\\<bar> * 1\n  0 < cn\n  0 < cd", "have cn: \"cn = cd * content x\""], ["proof (prove)\nusing this:\n  \\<bar>cd\\<bar> * content x = \\<bar>cn\\<bar> * 1\n  0 < cn\n  0 < cd\n\ngoal (1 subgoal):\n 1. cn = cd * content x", "by auto"], ["proof (state)\nthis:\n  cn = cd * content x\n\ngoal (1 subgoal):\n 1. y \\<noteq> 0 \\<Longrightarrow> x dvd y", "from quotient_of_coprime[OF quot, unfolded cn] cd0"], ["proof (chain)\npicking this:\n  coprime (cd * content x) cd\n  0 < cd", "have \"cd = 1\""], ["proof (prove)\nusing this:\n  coprime (cd * content x) cd\n  0 < cd\n\ngoal (1 subgoal):\n 1. cd = 1", "by auto"], ["proof (state)\nthis:\n  cd = 1\n\ngoal (1 subgoal):\n 1. y \\<noteq> 0 \\<Longrightarrow> x dvd y", "with cx"], ["proof (chain)\npicking this:\n  cx = rat_of_int cn / rat_of_int cd\n  cd = 1", "have cx: \"cx = ?r cn\""], ["proof (prove)\nusing this:\n  cx = rat_of_int cn / rat_of_int cd\n  cd = 1\n\ngoal (1 subgoal):\n 1. cx = rat_of_int cn", "by auto"], ["proof (state)\nthis:\n  cx = rat_of_int cn\n\ngoal (1 subgoal):\n 1. y \\<noteq> 0 \\<Longrightarrow> x dvd y", "from xx[unfolded this]"], ["proof (chain)\npicking this:\n  of_int_poly x = smult (rat_of_int cn) (of_int_poly xx)", "have x: \"x = smult cn xx\""], ["proof (prove)\nusing this:\n  of_int_poly x = smult (rat_of_int cn) (of_int_poly xx)\n\ngoal (1 subgoal):\n 1. x = smult cn xx", "by (fold hom_distribs, simp)"], ["proof (state)\nthis:\n  x = smult cn xx\n\ngoal (1 subgoal):\n 1. y \\<noteq> 0 \\<Longrightarrow> x dvd y", "from arg_cong[OF this, of content, unfolded content_smult_int c_x cxx] cn0"], ["proof (chain)\npicking this:\n  1 = \\<bar>cn\\<bar> * 1\n  0 < cn", "have \"cn = 1\""], ["proof (prove)\nusing this:\n  1 = \\<bar>cn\\<bar> * 1\n  0 < cn\n\ngoal (1 subgoal):\n 1. cn = 1", "by auto"], ["proof (state)\nthis:\n  cn = 1\n\ngoal (1 subgoal):\n 1. y \\<noteq> 0 \\<Longrightarrow> x dvd y", "with x"], ["proof (chain)\npicking this:\n  x = smult cn xx\n  cn = 1", "have xx: \"xx = x\""], ["proof (prove)\nusing this:\n  x = smult cn xx\n  cn = 1\n\ngoal (1 subgoal):\n 1. xx = x", "by auto"], ["proof (state)\nthis:\n  xx = x\n\ngoal (1 subgoal):\n 1. y \\<noteq> 0 \\<Longrightarrow> x dvd y", "show \"x dvd y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x dvd y", "using y[unfolded xx]"], ["proof (prove)\nusing this:\n  y = x * smult (content y) z\n\ngoal (1 subgoal):\n 1. x dvd y", "unfolding dvd_def"], ["proof (prove)\nusing this:\n  y = x * smult (content y) z\n\ngoal (1 subgoal):\n 1. \\<exists>k. y = x * k", "by blast"], ["proof (state)\nthis:\n  x dvd y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x dvd y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (x dvd y) = (of_int_poly x dvd of_int_poly y)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma content_x_minus_const_int[simp]: \"content [: c, 1 :] = (1 :: int)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. content [:c, 1:] = 1", "unfolding content_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. gcd_list (coeffs [:c, 1:]) = 1", "by auto"], ["", "lemma length_upto_add_nat[simp]: \"length [a .. a + int n] = Suc n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length [a..a + int n] = Suc n", "proof (induct n arbitrary: a)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a. length [a..a + int 0] = Suc 0\n 2. \\<And>n a.\n       (\\<And>a. length [a..a + int n] = Suc n) \\<Longrightarrow>\n       length [a..a + int (Suc n)] = Suc (Suc n)", "case (0 a)"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>a. length [a..a + int 0] = Suc 0\n 2. \\<And>n a.\n       (\\<And>a. length [a..a + int n] = Suc n) \\<Longrightarrow>\n       length [a..a + int (Suc n)] = Suc (Suc n)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. length [a..a + int 0] = Suc 0", "using upto.simps[of a a]"], ["proof (prove)\nusing this:\n  [a..a] = (if a \\<le> a then a # [a + 1..a] else [])\n\ngoal (1 subgoal):\n 1. length [a..a + int 0] = Suc 0", "by auto"], ["proof (state)\nthis:\n  length [a..a + int 0] = Suc 0\n\ngoal (1 subgoal):\n 1. \\<And>n a.\n       (\\<And>a. length [a..a + int n] = Suc n) \\<Longrightarrow>\n       length [a..a + int (Suc n)] = Suc (Suc n)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n a.\n       (\\<And>a. length [a..a + int n] = Suc n) \\<Longrightarrow>\n       length [a..a + int (Suc n)] = Suc (Suc n)", "case (Suc n a)"], ["proof (state)\nthis:\n  length [?a..?a + int n] = Suc n\n\ngoal (1 subgoal):\n 1. \\<And>n a.\n       (\\<And>a. length [a..a + int n] = Suc n) \\<Longrightarrow>\n       length [a..a + int (Suc n)] = Suc (Suc n)", "from Suc[of \"a + 1\"]"], ["proof (chain)\npicking this:\n  length [a + 1..a + 1 + int n] = Suc n", "show ?case"], ["proof (prove)\nusing this:\n  length [a + 1..a + 1 + int n] = Suc n\n\ngoal (1 subgoal):\n 1. length [a..a + int (Suc n)] = Suc (Suc n)", "using upto.simps[of a \"a + int (Suc n)\"]"], ["proof (prove)\nusing this:\n  length [a + 1..a + 1 + int n] = Suc n\n  [a..a + int (Suc n)] =\n  (if a \\<le> a + int (Suc n) then a # [a + 1..a + int (Suc n)] else [])\n\ngoal (1 subgoal):\n 1. length [a..a + int (Suc n)] = Suc (Suc n)", "by (auto simp: ac_simps)"], ["proof (state)\nthis:\n  length [a..a + int (Suc n)] = Suc (Suc n)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma kronecker_samples: \"distinct (kronecker_samples n)\" \"length (kronecker_samples n) = Suc n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (kronecker_samples n) &&& length (kronecker_samples n) = Suc n", "unfolding kronecker_samples_def Let_def length_upto_add_nat"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct [- int (n div 2)..- int (n div 2) + int n] &&& Suc n = Suc n", "by auto"], ["", "lemma dvd_int_poly_non_0_degree_1[simp]: \"degree q \\<ge> 1 \\<Longrightarrow> dvd_int_poly_non_0 q p = (q dvd p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 \\<le> degree q \\<Longrightarrow> dvd_int_poly_non_0 q p = (q dvd p)", "by (intro dvd_int_poly_non_0, auto)"], ["", "context fixes df dp :: \"int \\<Rightarrow> int list\"\n  and bnd :: nat\nbegin"], ["", "lemma kronecker_factorization_main_sound: assumes some: \"kronecker_factorization_main df dp bnd p = Some q\"\n  and bnd: \"degree p \\<ge> 2 \\<Longrightarrow> bnd \\<ge> 1\"\n  shows \"degree q \\<ge> 1\" \"degree q \\<le> bnd\" \"q dvd p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 \\<le> degree q &&& degree q \\<le> bnd &&& q dvd p", "proof -"], ["proof (state)\ngoal (3 subgoals):\n 1. 1 \\<le> degree q\n 2. degree q \\<le> bnd\n 3. q dvd p", "let ?r = \"rat_of_int\""], ["proof (state)\ngoal (3 subgoals):\n 1. 1 \\<le> degree q\n 2. degree q \\<le> bnd\n 3. q dvd p", "let ?rp = \"map_poly ?r\""], ["proof (state)\ngoal (3 subgoals):\n 1. 1 \\<le> degree q\n 2. degree q \\<le> bnd\n 3. q dvd p", "note res = some[unfolded kronecker_factorization_main_def Let_def]"], ["proof (state)\nthis:\n  (if degree p \\<le> 1 then None\n   else case map_of\n              (map (\\<lambda>j. (poly (primitive_part p) j, j))\n                (kronecker_samples bnd))\n              0 of\n        None \\<Rightarrow>\n          map_option the\n           (find_map_filter newton_interpolation_poly_int\n             (case_option False\n               (\\<lambda>g.\n                   dvd_int_poly_non_0 g (primitive_part p) \\<and>\n                   1 \\<le> degree g))\n             (concat_lists\n               (map (\\<lambda>(v, j).\n                        map (Pair j) (if j = 0 then dp v else df v))\n                 (map (\\<lambda>j. (poly (primitive_part p) j, j))\n                   (kronecker_samples bnd)))))\n        | Some j \\<Rightarrow> Some [:- j, 1:]) =\n  Some q\n\ngoal (3 subgoals):\n 1. 1 \\<le> degree q\n 2. degree q \\<le> bnd\n 3. q dvd p", "from res"], ["proof (chain)\npicking this:\n  (if degree p \\<le> 1 then None\n   else case map_of\n              (map (\\<lambda>j. (poly (primitive_part p) j, j))\n                (kronecker_samples bnd))\n              0 of\n        None \\<Rightarrow>\n          map_option the\n           (find_map_filter newton_interpolation_poly_int\n             (case_option False\n               (\\<lambda>g.\n                   dvd_int_poly_non_0 g (primitive_part p) \\<and>\n                   1 \\<le> degree g))\n             (concat_lists\n               (map (\\<lambda>(v, j).\n                        map (Pair j) (if j = 0 then dp v else df v))\n                 (map (\\<lambda>j. (poly (primitive_part p) j, j))\n                   (kronecker_samples bnd)))))\n        | Some j \\<Rightarrow> Some [:- j, 1:]) =\n  Some q", "have dp: \"degree p \\<ge> 2\" and \"(degree p \\<le> 1) = False\""], ["proof (prove)\nusing this:\n  (if degree p \\<le> 1 then None\n   else case map_of\n              (map (\\<lambda>j. (poly (primitive_part p) j, j))\n                (kronecker_samples bnd))\n              0 of\n        None \\<Rightarrow>\n          map_option the\n           (find_map_filter newton_interpolation_poly_int\n             (case_option False\n               (\\<lambda>g.\n                   dvd_int_poly_non_0 g (primitive_part p) \\<and>\n                   1 \\<le> degree g))\n             (concat_lists\n               (map (\\<lambda>(v, j).\n                        map (Pair j) (if j = 0 then dp v else df v))\n                 (map (\\<lambda>j. (poly (primitive_part p) j, j))\n                   (kronecker_samples bnd)))))\n        | Some j \\<Rightarrow> Some [:- j, 1:]) =\n  Some q\n\ngoal (1 subgoal):\n 1. 2 \\<le> degree p &&& (degree p \\<le> 1) = False", "by (auto split: if_splits)"], ["proof (state)\nthis:\n  2 \\<le> degree p\n  (degree p \\<le> 1) = False\n\ngoal (3 subgoals):\n 1. 1 \\<le> degree q\n 2. degree q \\<le> bnd\n 3. q dvd p", "note res = res[unfolded this if_False]"], ["proof (state)\nthis:\n  (case map_of\n         (map (\\<lambda>j. (poly (primitive_part p) j, j))\n           (kronecker_samples bnd))\n         0 of\n   None \\<Rightarrow>\n     map_option the\n      (find_map_filter newton_interpolation_poly_int\n        (case_option False\n          (\\<lambda>g.\n              dvd_int_poly_non_0 g (primitive_part p) \\<and>\n              1 \\<le> degree g))\n        (concat_lists\n          (map (\\<lambda>(v, j).\n                   map (Pair j) (if j = 0 then dp v else df v))\n            (map (\\<lambda>j. (poly (primitive_part p) j, j))\n              (kronecker_samples bnd)))))\n   | Some j \\<Rightarrow> Some [:- j, 1:]) =\n  Some q\n\ngoal (3 subgoals):\n 1. 1 \\<le> degree q\n 2. degree q \\<le> bnd\n 3. q dvd p", "note bnd = bnd[OF dp]"], ["proof (state)\nthis:\n  1 \\<le> bnd\n\ngoal (3 subgoals):\n 1. 1 \\<le> degree q\n 2. degree q \\<le> bnd\n 3. q dvd p", "define P where \"P = primitive_part p\""], ["proof (state)\nthis:\n  P = primitive_part p\n\ngoal (3 subgoals):\n 1. 1 \\<le> degree q\n 2. degree q \\<le> bnd\n 3. q dvd p", "have degP: \"degree P = degree p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree P = degree p", "unfolding P_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (primitive_part p) = degree p", "by simp"], ["proof (state)\nthis:\n  degree P = degree p\n\ngoal (3 subgoals):\n 1. 1 \\<le> degree q\n 2. degree q \\<le> bnd\n 3. q dvd p", "define js where \"js = kronecker_samples bnd\""], ["proof (state)\nthis:\n  js = kronecker_samples bnd\n\ngoal (3 subgoals):\n 1. 1 \\<le> degree q\n 2. degree q \\<le> bnd\n 3. q dvd p", "define filt where \"filt = (case_option False (\\<lambda>g. dvd_int_poly_non_0 g P \\<and> 1 \\<le> degree g))\""], ["proof (state)\nthis:\n  filt =\n  case_option False\n   (\\<lambda>g. dvd_int_poly_non_0 g P \\<and> 1 \\<le> degree g)\n\ngoal (3 subgoals):\n 1. 1 \\<le> degree q\n 2. degree q \\<le> bnd\n 3. q dvd p", "define tests where \"tests = concat_lists (map (\\<lambda>(v, j). map (Pair j) (if j = 0 then dp v else df v)) (map (\\<lambda>j. (poly P j, j)) js))\""], ["proof (state)\nthis:\n  tests =\n  concat_lists\n   (map (\\<lambda>(v, j). map (Pair j) (if j = 0 then dp v else df v))\n     (map (\\<lambda>j. (poly P j, j)) js))\n\ngoal (3 subgoals):\n 1. 1 \\<le> degree q\n 2. degree q \\<le> bnd\n 3. q dvd p", "note res = res[folded P_def, folded js_def filt_def, folded tests_def]"], ["proof (state)\nthis:\n  (case map_of (map (\\<lambda>j. (poly P j, j)) js) 0 of\n   None \\<Rightarrow>\n     map_option the\n      (find_map_filter newton_interpolation_poly_int filt tests)\n   | Some j \\<Rightarrow> Some [:- j, 1:]) =\n  Some q\n\ngoal (3 subgoals):\n 1. 1 \\<le> degree q\n 2. degree q \\<le> bnd\n 3. q dvd p", "let ?zero = \"map (\\<lambda>j. (poly P j, j)) js\""], ["proof (state)\ngoal (3 subgoals):\n 1. 1 \\<le> degree q\n 2. degree q \\<le> bnd\n 3. q dvd p", "from res"], ["proof (chain)\npicking this:\n  (case map_of (map (\\<lambda>j. (poly P j, j)) js) 0 of\n   None \\<Rightarrow>\n     map_option the\n      (find_map_filter newton_interpolation_poly_int filt tests)\n   | Some j \\<Rightarrow> Some [:- j, 1:]) =\n  Some q", "have res: \"(case map_of ?zero 0 of\n     None \\<Rightarrow> map_option the (find_map_filter newton_interpolation_poly_int filt tests) | Some j \\<Rightarrow> Some [:- j, 1:]) =\n     Some q\""], ["proof (prove)\nusing this:\n  (case map_of (map (\\<lambda>j. (poly P j, j)) js) 0 of\n   None \\<Rightarrow>\n     map_option the\n      (find_map_filter newton_interpolation_poly_int filt tests)\n   | Some j \\<Rightarrow> Some [:- j, 1:]) =\n  Some q\n\ngoal (1 subgoal):\n 1. (case map_of (map (\\<lambda>j. (poly P j, j)) js) 0 of\n     None \\<Rightarrow>\n       map_option the\n        (find_map_filter newton_interpolation_poly_int filt tests)\n     | Some j \\<Rightarrow> Some [:- j, 1:]) =\n    Some q", "by auto"], ["proof (state)\nthis:\n  (case map_of (map (\\<lambda>j. (poly P j, j)) js) 0 of\n   None \\<Rightarrow>\n     map_option the\n      (find_map_filter newton_interpolation_poly_int filt tests)\n   | Some j \\<Rightarrow> Some [:- j, 1:]) =\n  Some q\n\ngoal (3 subgoals):\n 1. 1 \\<le> degree q\n 2. degree q \\<le> bnd\n 3. q dvd p", "have \"degree q \\<ge> 1 \\<and> degree q \\<le> bnd \\<and> q dvd P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 \\<le> degree q \\<and> degree q \\<le> bnd \\<and> q dvd P", "proof (cases \"map_of ?zero 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. map_of (map (\\<lambda>j. (poly P j, j)) js) 0 = None \\<Longrightarrow>\n    1 \\<le> degree q \\<and> degree q \\<le> bnd \\<and> q dvd P\n 2. \\<And>a.\n       map_of (map (\\<lambda>j. (poly P j, j)) js) 0 =\n       Some a \\<Longrightarrow>\n       1 \\<le> degree q \\<and> degree q \\<le> bnd \\<and> q dvd P", "case (Some j)"], ["proof (state)\nthis:\n  map_of (map (\\<lambda>j. (poly P j, j)) js) 0 = Some j\n\ngoal (2 subgoals):\n 1. map_of (map (\\<lambda>j. (poly P j, j)) js) 0 = None \\<Longrightarrow>\n    1 \\<le> degree q \\<and> degree q \\<le> bnd \\<and> q dvd P\n 2. \\<And>a.\n       map_of (map (\\<lambda>j. (poly P j, j)) js) 0 =\n       Some a \\<Longrightarrow>\n       1 \\<le> degree q \\<and> degree q \\<le> bnd \\<and> q dvd P", "with res"], ["proof (chain)\npicking this:\n  (case map_of (map (\\<lambda>j. (poly P j, j)) js) 0 of\n   None \\<Rightarrow>\n     map_option the\n      (find_map_filter newton_interpolation_poly_int filt tests)\n   | Some j \\<Rightarrow> Some [:- j, 1:]) =\n  Some q\n  map_of (map (\\<lambda>j. (poly P j, j)) js) 0 = Some j", "have q: \"q = [: - j, 1 :]\""], ["proof (prove)\nusing this:\n  (case map_of (map (\\<lambda>j. (poly P j, j)) js) 0 of\n   None \\<Rightarrow>\n     map_option the\n      (find_map_filter newton_interpolation_poly_int filt tests)\n   | Some j \\<Rightarrow> Some [:- j, 1:]) =\n  Some q\n  map_of (map (\\<lambda>j. (poly P j, j)) js) 0 = Some j\n\ngoal (1 subgoal):\n 1. q = [:- j, 1:]", "by auto"], ["proof (state)\nthis:\n  q = [:- j, 1:]\n\ngoal (2 subgoals):\n 1. map_of (map (\\<lambda>j. (poly P j, j)) js) 0 = None \\<Longrightarrow>\n    1 \\<le> degree q \\<and> degree q \\<le> bnd \\<and> q dvd P\n 2. \\<And>a.\n       map_of (map (\\<lambda>j. (poly P j, j)) js) 0 =\n       Some a \\<Longrightarrow>\n       1 \\<le> degree q \\<and> degree q \\<le> bnd \\<and> q dvd P", "from map_of_SomeD[OF Some]"], ["proof (chain)\npicking this:\n  (0, j) \\<in> set (map (\\<lambda>j. (poly P j, j)) js)", "have 0: \"poly P j = 0\""], ["proof (prove)\nusing this:\n  (0, j) \\<in> set (map (\\<lambda>j. (poly P j, j)) js)\n\ngoal (1 subgoal):\n 1. poly P j = 0", "by auto"], ["proof (state)\nthis:\n  poly P j = 0\n\ngoal (2 subgoals):\n 1. map_of (map (\\<lambda>j. (poly P j, j)) js) 0 = None \\<Longrightarrow>\n    1 \\<le> degree q \\<and> degree q \\<le> bnd \\<and> q dvd P\n 2. \\<And>a.\n       map_of (map (\\<lambda>j. (poly P j, j)) js) 0 =\n       Some a \\<Longrightarrow>\n       1 \\<le> degree q \\<and> degree q \\<le> bnd \\<and> q dvd P", "hence \"poly (?rp P) (?r j) = 0\""], ["proof (prove)\nusing this:\n  poly P j = 0\n\ngoal (1 subgoal):\n 1. poly (of_int_poly P) (rat_of_int j) = 0", "by simp"], ["proof (state)\nthis:\n  poly (of_int_poly P) (rat_of_int j) = 0\n\ngoal (2 subgoals):\n 1. map_of (map (\\<lambda>j. (poly P j, j)) js) 0 = None \\<Longrightarrow>\n    1 \\<le> degree q \\<and> degree q \\<le> bnd \\<and> q dvd P\n 2. \\<And>a.\n       map_of (map (\\<lambda>j. (poly P j, j)) js) 0 =\n       Some a \\<Longrightarrow>\n       1 \\<le> degree q \\<and> degree q \\<le> bnd \\<and> q dvd P", "hence \"[: - ?r j, 1 :] dvd ?rp P\""], ["proof (prove)\nusing this:\n  poly (of_int_poly P) (rat_of_int j) = 0\n\ngoal (1 subgoal):\n 1. [:- rat_of_int j, 1:] dvd of_int_poly P", "using poly_eq_0_iff_dvd"], ["proof (prove)\nusing this:\n  poly (of_int_poly P) (rat_of_int j) = 0\n  (poly ?p ?c = (0::?'a)) = ([:- ?c, 1::?'a:] dvd ?p)\n\ngoal (1 subgoal):\n 1. [:- rat_of_int j, 1:] dvd of_int_poly P", "by blast"], ["proof (state)\nthis:\n  [:- rat_of_int j, 1:] dvd of_int_poly P\n\ngoal (2 subgoals):\n 1. map_of (map (\\<lambda>j. (poly P j, j)) js) 0 = None \\<Longrightarrow>\n    1 \\<le> degree q \\<and> degree q \\<le> bnd \\<and> q dvd P\n 2. \\<And>a.\n       map_of (map (\\<lambda>j. (poly P j, j)) js) 0 =\n       Some a \\<Longrightarrow>\n       1 \\<le> degree q \\<and> degree q \\<le> bnd \\<and> q dvd P", "also"], ["proof (state)\nthis:\n  [:- rat_of_int j, 1:] dvd of_int_poly P\n\ngoal (2 subgoals):\n 1. map_of (map (\\<lambda>j. (poly P j, j)) js) 0 = None \\<Longrightarrow>\n    1 \\<le> degree q \\<and> degree q \\<le> bnd \\<and> q dvd P\n 2. \\<And>a.\n       map_of (map (\\<lambda>j. (poly P j, j)) js) 0 =\n       Some a \\<Longrightarrow>\n       1 \\<le> degree q \\<and> degree q \\<le> bnd \\<and> q dvd P", "have \"[: - ?r j, 1 :] = ?rp q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [:- rat_of_int j, 1:] = of_int_poly q", "unfolding q"], ["proof (prove)\ngoal (1 subgoal):\n 1. [:- rat_of_int j, 1:] = of_int_poly [:- j, 1:]", "by simp"], ["proof (state)\nthis:\n  [:- rat_of_int j, 1:] = of_int_poly q\n\ngoal (2 subgoals):\n 1. map_of (map (\\<lambda>j. (poly P j, j)) js) 0 = None \\<Longrightarrow>\n    1 \\<le> degree q \\<and> degree q \\<le> bnd \\<and> q dvd P\n 2. \\<And>a.\n       map_of (map (\\<lambda>j. (poly P j, j)) js) 0 =\n       Some a \\<Longrightarrow>\n       1 \\<le> degree q \\<and> degree q \\<le> bnd \\<and> q dvd P", "finally"], ["proof (chain)\npicking this:\n  of_int_poly q dvd of_int_poly P", "have dvd: \"?rp q dvd ?rp P\""], ["proof (prove)\nusing this:\n  of_int_poly q dvd of_int_poly P\n\ngoal (1 subgoal):\n 1. of_int_poly q dvd of_int_poly P", "."], ["proof (state)\nthis:\n  of_int_poly q dvd of_int_poly P\n\ngoal (2 subgoals):\n 1. map_of (map (\\<lambda>j. (poly P j, j)) js) 0 = None \\<Longrightarrow>\n    1 \\<le> degree q \\<and> degree q \\<le> bnd \\<and> q dvd P\n 2. \\<And>a.\n       map_of (map (\\<lambda>j. (poly P j, j)) js) 0 =\n       Some a \\<Longrightarrow>\n       1 \\<le> degree q \\<and> degree q \\<le> bnd \\<and> q dvd P", "have \"q dvd P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q dvd P", "by (subst dvd_poly_int_content_1, insert dvd q, auto)"], ["proof (state)\nthis:\n  q dvd P\n\ngoal (2 subgoals):\n 1. map_of (map (\\<lambda>j. (poly P j, j)) js) 0 = None \\<Longrightarrow>\n    1 \\<le> degree q \\<and> degree q \\<le> bnd \\<and> q dvd P\n 2. \\<And>a.\n       map_of (map (\\<lambda>j. (poly P j, j)) js) 0 =\n       Some a \\<Longrightarrow>\n       1 \\<le> degree q \\<and> degree q \\<le> bnd \\<and> q dvd P", "with q dp bnd"], ["proof (chain)\npicking this:\n  q = [:- j, 1:]\n  2 \\<le> degree p\n  1 \\<le> bnd\n  q dvd P", "show ?thesis"], ["proof (prove)\nusing this:\n  q = [:- j, 1:]\n  2 \\<le> degree p\n  1 \\<le> bnd\n  q dvd P\n\ngoal (1 subgoal):\n 1. 1 \\<le> degree q \\<and> degree q \\<le> bnd \\<and> q dvd P", "by auto"], ["proof (state)\nthis:\n  1 \\<le> degree q \\<and> degree q \\<le> bnd \\<and> q dvd P\n\ngoal (1 subgoal):\n 1. map_of (map (\\<lambda>j. (poly P j, j)) js) 0 = None \\<Longrightarrow>\n    1 \\<le> degree q \\<and> degree q \\<le> bnd \\<and> q dvd P", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. map_of (map (\\<lambda>j. (poly P j, j)) js) 0 = None \\<Longrightarrow>\n    1 \\<le> degree q \\<and> degree q \\<le> bnd \\<and> q dvd P", "case None"], ["proof (state)\nthis:\n  map_of (map (\\<lambda>j. (poly P j, j)) js) 0 = None\n\ngoal (1 subgoal):\n 1. map_of (map (\\<lambda>j. (poly P j, j)) js) 0 = None \\<Longrightarrow>\n    1 \\<le> degree q \\<and> degree q \\<le> bnd \\<and> q dvd P", "from res[unfolded None]"], ["proof (chain)\npicking this:\n  (case None of\n   None \\<Rightarrow>\n     map_option the\n      (find_map_filter newton_interpolation_poly_int filt tests)\n   | Some j \\<Rightarrow> Some [:- j, 1:]) =\n  Some q", "have res: \"map_option the (find_map_filter newton_interpolation_poly_int filt tests) = Some q\""], ["proof (prove)\nusing this:\n  (case None of\n   None \\<Rightarrow>\n     map_option the\n      (find_map_filter newton_interpolation_poly_int filt tests)\n   | Some j \\<Rightarrow> Some [:- j, 1:]) =\n  Some q\n\ngoal (1 subgoal):\n 1. map_option the\n     (find_map_filter newton_interpolation_poly_int filt tests) =\n    Some q", "by auto"], ["proof (state)\nthis:\n  map_option the\n   (find_map_filter newton_interpolation_poly_int filt tests) =\n  Some q\n\ngoal (1 subgoal):\n 1. map_of (map (\\<lambda>j. (poly P j, j)) js) 0 = None \\<Longrightarrow>\n    1 \\<le> degree q \\<and> degree q \\<le> bnd \\<and> q dvd P", "then"], ["proof (chain)\npicking this:\n  map_option the\n   (find_map_filter newton_interpolation_poly_int filt tests) =\n  Some q", "obtain qq where \n      res: \"find_map_filter newton_interpolation_poly_int filt tests = Some qq\" and q: \"q = the qq\""], ["proof (prove)\nusing this:\n  map_option the\n   (find_map_filter newton_interpolation_poly_int filt tests) =\n  Some q\n\ngoal (1 subgoal):\n 1. (\\<And>qq.\n        \\<lbrakk>find_map_filter newton_interpolation_poly_int filt tests =\n                 Some qq;\n         q = the qq\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto split: option.splits)"], ["proof (state)\nthis:\n  find_map_filter newton_interpolation_poly_int filt tests = Some qq\n  q = the qq\n\ngoal (1 subgoal):\n 1. map_of (map (\\<lambda>j. (poly P j, j)) js) 0 = None \\<Longrightarrow>\n    1 \\<le> degree q \\<and> degree q \\<le> bnd \\<and> q dvd P", "from find_map_filter_Some[OF res]"], ["proof (chain)\npicking this:\n  filt qq \\<and> qq \\<in> newton_interpolation_poly_int ` set tests", "have filt: \"filt qq\" and tests: \"qq \\<in> newton_interpolation_poly_int ` set tests\""], ["proof (prove)\nusing this:\n  filt qq \\<and> qq \\<in> newton_interpolation_poly_int ` set tests\n\ngoal (1 subgoal):\n 1. filt qq &&& qq \\<in> newton_interpolation_poly_int ` set tests", "by auto"], ["proof (state)\nthis:\n  filt qq\n  qq \\<in> newton_interpolation_poly_int ` set tests\n\ngoal (1 subgoal):\n 1. map_of (map (\\<lambda>j. (poly P j, j)) js) 0 = None \\<Longrightarrow>\n    1 \\<le> degree q \\<and> degree q \\<le> bnd \\<and> q dvd P", "from filt[unfolded filt_def] q"], ["proof (chain)\npicking this:\n  case qq of None \\<Rightarrow> False\n  | Some g \\<Rightarrow> dvd_int_poly_non_0 g P \\<and> 1 \\<le> degree g\n  q = the qq", "obtain g where dvd: \"g dvd P\" and dg: \"1 \\<le> degree g\" and qq: \"qq = Some g\""], ["proof (prove)\nusing this:\n  case qq of None \\<Rightarrow> False\n  | Some g \\<Rightarrow> dvd_int_poly_non_0 g P \\<and> 1 \\<le> degree g\n  q = the qq\n\ngoal (1 subgoal):\n 1. (\\<And>g.\n        \\<lbrakk>g dvd P; 1 \\<le> degree g; qq = Some g\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases qq, auto)"], ["proof (state)\nthis:\n  g dvd P\n  1 \\<le> degree g\n  qq = Some g\n\ngoal (1 subgoal):\n 1. map_of (map (\\<lambda>j. (poly P j, j)) js) 0 = None \\<Longrightarrow>\n    1 \\<le> degree q \\<and> degree q \\<le> bnd \\<and> q dvd P", "from q qq"], ["proof (chain)\npicking this:\n  q = the qq\n  qq = Some g", "have gq: \"g = q\""], ["proof (prove)\nusing this:\n  q = the qq\n  qq = Some g\n\ngoal (1 subgoal):\n 1. g = q", "by auto"], ["proof (state)\nthis:\n  g = q\n\ngoal (1 subgoal):\n 1. map_of (map (\\<lambda>j. (poly P j, j)) js) 0 = None \\<Longrightarrow>\n    1 \\<le> degree q \\<and> degree q \\<le> bnd \\<and> q dvd P", "from tests"], ["proof (chain)\npicking this:\n  qq \\<in> newton_interpolation_poly_int ` set tests", "obtain t where t: \"t \\<in> set tests\" and l: \"newton_interpolation_poly_int t = Some g\""], ["proof (prove)\nusing this:\n  qq \\<in> newton_interpolation_poly_int ` set tests\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        \\<lbrakk>t \\<in> set tests;\n         newton_interpolation_poly_int t = Some g\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding qq"], ["proof (prove)\nusing this:\n  Some g \\<in> newton_interpolation_poly_int ` set tests\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        \\<lbrakk>t \\<in> set tests;\n         newton_interpolation_poly_int t = Some g\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  t \\<in> set tests\n  newton_interpolation_poly_int t = Some g\n\ngoal (1 subgoal):\n 1. map_of (map (\\<lambda>j. (poly P j, j)) js) 0 = None \\<Longrightarrow>\n    1 \\<le> degree q \\<and> degree q \\<le> bnd \\<and> q dvd P", "from t[unfolded tests_def]"], ["proof (chain)\npicking this:\n  t \\<in> set (concat_lists\n                (map (\\<lambda>(v, j).\n                         map (Pair j) (if j = 0 then dp v else df v))\n                  (map (\\<lambda>j. (poly P j, j)) js)))", "have lent: \"length t = length js\" and \"\\<And> i. i < length js \\<Longrightarrow> map fst t ! i = js ! i\""], ["proof (prove)\nusing this:\n  t \\<in> set (concat_lists\n                (map (\\<lambda>(v, j).\n                         map (Pair j) (if j = 0 then dp v else df v))\n                  (map (\\<lambda>j. (poly P j, j)) js)))\n\ngoal (1 subgoal):\n 1. length t = length js &&&\n    (\\<And>i. i < length js \\<Longrightarrow> map fst t ! i = js ! i)", "by auto"], ["proof (state)\nthis:\n  length t = length js\n  ?i < length js \\<Longrightarrow> map fst t ! ?i = js ! ?i\n\ngoal (1 subgoal):\n 1. map_of (map (\\<lambda>j. (poly P j, j)) js) 0 = None \\<Longrightarrow>\n    1 \\<le> degree q \\<and> degree q \\<le> bnd \\<and> q dvd P", "hence id: \"map fst t = js\""], ["proof (prove)\nusing this:\n  length t = length js\n  ?i < length js \\<Longrightarrow> map fst t ! ?i = js ! ?i\n\ngoal (1 subgoal):\n 1. map fst t = js", "by (intro nth_equalityI, auto)"], ["proof (state)\nthis:\n  map fst t = js\n\ngoal (1 subgoal):\n 1. map_of (map (\\<lambda>j. (poly P j, j)) js) 0 = None \\<Longrightarrow>\n    1 \\<le> degree q \\<and> degree q \\<le> bnd \\<and> q dvd P", "have dist: \"distinct js\" and lenj: \"length js = Suc bnd\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct js &&& length js = Suc bnd", "unfolding js_def degP"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (kronecker_samples bnd) &&&\n    length (kronecker_samples bnd) = Suc bnd", "using kronecker_samples"], ["proof (prove)\nusing this:\n  distinct (kronecker_samples ?n)\n  length (kronecker_samples ?n) = Suc ?n\n\ngoal (1 subgoal):\n 1. distinct (kronecker_samples bnd) &&&\n    length (kronecker_samples bnd) = Suc bnd", "by auto"], ["proof (state)\nthis:\n  distinct js\n  length js = Suc bnd\n\ngoal (1 subgoal):\n 1. map_of (map (\\<lambda>j. (poly P j, j)) js) 0 = None \\<Longrightarrow>\n    1 \\<le> degree q \\<and> degree q \\<le> bnd \\<and> q dvd P", "from newton_interpolation_poly_int_Some[OF dist[folded id] l, unfolded lent lenj]"], ["proof (chain)\npicking this:\n  (?x, ?y) \\<in> set t \\<Longrightarrow> poly g ?x = ?y\n  degree g \\<le> Suc bnd - 1", "have \"degree g \\<le> bnd\""], ["proof (prove)\nusing this:\n  (?x, ?y) \\<in> set t \\<Longrightarrow> poly g ?x = ?y\n  degree g \\<le> Suc bnd - 1\n\ngoal (1 subgoal):\n 1. degree g \\<le> bnd", "by auto"], ["proof (state)\nthis:\n  degree g \\<le> bnd\n\ngoal (1 subgoal):\n 1. map_of (map (\\<lambda>j. (poly P j, j)) js) 0 = None \\<Longrightarrow>\n    1 \\<le> degree q \\<and> degree q \\<le> bnd \\<and> q dvd P", "with dvd dg"], ["proof (chain)\npicking this:\n  g dvd P\n  1 \\<le> degree g\n  degree g \\<le> bnd", "show ?thesis"], ["proof (prove)\nusing this:\n  g dvd P\n  1 \\<le> degree g\n  degree g \\<le> bnd\n\ngoal (1 subgoal):\n 1. 1 \\<le> degree q \\<and> degree q \\<le> bnd \\<and> q dvd P", "unfolding gq"], ["proof (prove)\nusing this:\n  q dvd P\n  1 \\<le> degree q\n  degree q \\<le> bnd\n\ngoal (1 subgoal):\n 1. 1 \\<le> degree q \\<and> degree q \\<le> bnd \\<and> q dvd P", "by auto"], ["proof (state)\nthis:\n  1 \\<le> degree q \\<and> degree q \\<le> bnd \\<and> q dvd P\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  1 \\<le> degree q \\<and> degree q \\<le> bnd \\<and> q dvd P\n\ngoal (3 subgoals):\n 1. 1 \\<le> degree q\n 2. degree q \\<le> bnd\n 3. q dvd p", "note main = this"], ["proof (state)\nthis:\n  1 \\<le> degree q \\<and> degree q \\<le> bnd \\<and> q dvd P\n\ngoal (3 subgoals):\n 1. 1 \\<le> degree q\n 2. degree q \\<le> bnd\n 3. q dvd p", "thus \"degree q \\<ge> 1\" \"degree q \\<le> bnd\""], ["proof (prove)\nusing this:\n  1 \\<le> degree q \\<and> degree q \\<le> bnd \\<and> q dvd P\n\ngoal (1 subgoal):\n 1. 1 \\<le> degree q &&& degree q \\<le> bnd", "by auto"], ["proof (state)\nthis:\n  1 \\<le> degree q\n  degree q \\<le> bnd\n\ngoal (1 subgoal):\n 1. q dvd p", "from content_times_primitive_part[of p]"], ["proof (chain)\npicking this:\n  smult (content p) (primitive_part p) = p", "have \"p = smult (content p) P\""], ["proof (prove)\nusing this:\n  smult (content p) (primitive_part p) = p\n\ngoal (1 subgoal):\n 1. p = smult (content p) P", "unfolding P_def"], ["proof (prove)\nusing this:\n  smult (content p) (primitive_part p) = p\n\ngoal (1 subgoal):\n 1. p = smult (content p) (primitive_part p)", "by auto"], ["proof (state)\nthis:\n  p = smult (content p) P\n\ngoal (1 subgoal):\n 1. q dvd p", "with main"], ["proof (chain)\npicking this:\n  1 \\<le> degree q \\<and> degree q \\<le> bnd \\<and> q dvd P\n  p = smult (content p) P", "show \"q dvd p\""], ["proof (prove)\nusing this:\n  1 \\<le> degree q \\<and> degree q \\<le> bnd \\<and> q dvd P\n  p = smult (content p) P\n\ngoal (1 subgoal):\n 1. q dvd p", "by (metis dvd_smult)"], ["proof (state)\nthis:\n  q dvd p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma kronecker_factorization_rat_main_sound: assumes \n  some: \"kronecker_factorization_rat_main df dp bnd p = Some q\"\n  and bnd: \"degree p \\<ge> 2 \\<Longrightarrow> bnd \\<ge> 1\"\n  shows \"degree q \\<ge> 1\" \"degree q \\<le> bnd\" \"q dvd p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 \\<le> degree q &&& degree q \\<le> bnd &&& q dvd p", "proof -"], ["proof (state)\ngoal (3 subgoals):\n 1. 1 \\<le> degree q\n 2. degree q \\<le> bnd\n 3. q dvd p", "let ?r = \"rat_of_int\""], ["proof (state)\ngoal (3 subgoals):\n 1. 1 \\<le> degree q\n 2. degree q \\<le> bnd\n 3. q dvd p", "let ?rp = \"map_poly ?r\""], ["proof (state)\ngoal (3 subgoals):\n 1. 1 \\<le> degree q\n 2. degree q \\<le> bnd\n 3. q dvd p", "let ?p = \"rat_to_normalized_int_poly p\""], ["proof (state)\ngoal (3 subgoals):\n 1. 1 \\<le> degree q\n 2. degree q \\<le> bnd\n 3. q dvd p", "obtain a P where rp: \"?p = (a,P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a P.\n        rat_to_normalized_int_poly p = (a, P) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  rat_to_normalized_int_poly p = (a, P)\n\ngoal (3 subgoals):\n 1. 1 \\<le> degree q\n 2. degree q \\<le> bnd\n 3. q dvd p", "from rat_to_normalized_int_poly[OF this]"], ["proof (chain)\npicking this:\n  p = smult a (of_int_poly P)\n  0 < a\n  p \\<noteq> 0 \\<Longrightarrow> content P = 1\n  degree P = degree p", "have p: \"p = smult a (?rp P)\" and a: \"a \\<noteq> 0\" \n    and deg: \"degree P = degree p\""], ["proof (prove)\nusing this:\n  p = smult a (of_int_poly P)\n  0 < a\n  p \\<noteq> 0 \\<Longrightarrow> content P = 1\n  degree P = degree p\n\ngoal (1 subgoal):\n 1. p = smult a (of_int_poly P) &&& a \\<noteq> 0 &&& degree P = degree p", "by auto"], ["proof (state)\nthis:\n  p = smult a (of_int_poly P)\n  a \\<noteq> 0\n  degree P = degree p\n\ngoal (3 subgoals):\n 1. 1 \\<le> degree q\n 2. degree q \\<le> bnd\n 3. q dvd p", "from some[unfolded kronecker_factorization_rat_main_def rp]"], ["proof (chain)\npicking this:\n  map_option of_int_poly\n   (kronecker_factorization_main df dp bnd (snd (a, P))) =\n  Some q", "obtain Q where some: \"kronecker_factorization_main df dp bnd P = Some Q\" and q: \"q = ?rp Q\""], ["proof (prove)\nusing this:\n  map_option of_int_poly\n   (kronecker_factorization_main df dp bnd (snd (a, P))) =\n  Some q\n\ngoal (1 subgoal):\n 1. (\\<And>Q.\n        \\<lbrakk>kronecker_factorization_main df dp bnd P = Some Q;\n         q = of_int_poly Q\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  kronecker_factorization_main df dp bnd P = Some Q\n  q = of_int_poly Q\n\ngoal (3 subgoals):\n 1. 1 \\<le> degree q\n 2. degree q \\<le> bnd\n 3. q dvd p", "from kronecker_factorization_main_sound[OF some bnd]"], ["proof (chain)\npicking this:\n  (2 \\<le> degree P \\<Longrightarrow> 2 \\<le> degree p) \\<Longrightarrow>\n  1 \\<le> degree Q\n  (2 \\<le> degree P \\<Longrightarrow> 2 \\<le> degree p) \\<Longrightarrow>\n  degree Q \\<le> bnd\n  (2 \\<le> degree P \\<Longrightarrow> 2 \\<le> degree p) \\<Longrightarrow>\n  Q dvd P", "have dQ: \"1 \\<le> degree Q\" \n    \"degree Q \\<le> bnd\"\n    and dvd: \"Q dvd P\""], ["proof (prove)\nusing this:\n  (2 \\<le> degree P \\<Longrightarrow> 2 \\<le> degree p) \\<Longrightarrow>\n  1 \\<le> degree Q\n  (2 \\<le> degree P \\<Longrightarrow> 2 \\<le> degree p) \\<Longrightarrow>\n  degree Q \\<le> bnd\n  (2 \\<le> degree P \\<Longrightarrow> 2 \\<le> degree p) \\<Longrightarrow>\n  Q dvd P\n\ngoal (1 subgoal):\n 1. (1 \\<le> degree Q &&& degree Q \\<le> bnd) &&& Q dvd P", "unfolding deg"], ["proof (prove)\nusing this:\n  (2 \\<le> degree p \\<Longrightarrow> 2 \\<le> degree p) \\<Longrightarrow>\n  1 \\<le> degree Q\n  (2 \\<le> degree p \\<Longrightarrow> 2 \\<le> degree p) \\<Longrightarrow>\n  degree Q \\<le> bnd\n  (2 \\<le> degree p \\<Longrightarrow> 2 \\<le> degree p) \\<Longrightarrow>\n  Q dvd P\n\ngoal (1 subgoal):\n 1. (1 \\<le> degree Q &&& degree Q \\<le> bnd) &&& Q dvd P", "by auto"], ["proof (state)\nthis:\n  1 \\<le> degree Q\n  degree Q \\<le> bnd\n  Q dvd P\n\ngoal (3 subgoals):\n 1. 1 \\<le> degree q\n 2. degree q \\<le> bnd\n 3. q dvd p", "from dvd"], ["proof (chain)\npicking this:\n  Q dvd P", "obtain R where PQR: \"P = Q * R\""], ["proof (prove)\nusing this:\n  Q dvd P\n\ngoal (1 subgoal):\n 1. (\\<And>R. P = Q * R \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "unfolding dvd_def"], ["proof (prove)\nusing this:\n  \\<exists>k. P = Q * k\n\ngoal (1 subgoal):\n 1. (\\<And>R. P = Q * R \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  P = Q * R\n\ngoal (3 subgoals):\n 1. 1 \\<le> degree q\n 2. degree q \\<le> bnd\n 3. q dvd p", "from p[unfolded arg_cong[OF this, of ?rp]]"], ["proof (chain)\npicking this:\n  p = smult a (of_int_poly (Q * R))", "have \"p = q * smult a (?rp R)\""], ["proof (prove)\nusing this:\n  p = smult a (of_int_poly (Q * R))\n\ngoal (1 subgoal):\n 1. p = q * smult a (of_int_poly R)", "unfolding q"], ["proof (prove)\nusing this:\n  p = smult a (of_int_poly (Q * R))\n\ngoal (1 subgoal):\n 1. p = of_int_poly Q * smult a (of_int_poly R)", "by (auto simp: hom_distribs)"], ["proof (state)\nthis:\n  p = q * smult a (of_int_poly R)\n\ngoal (3 subgoals):\n 1. 1 \\<le> degree q\n 2. degree q \\<le> bnd\n 3. q dvd p", "thus \"q dvd p\""], ["proof (prove)\nusing this:\n  p = q * smult a (of_int_poly R)\n\ngoal (1 subgoal):\n 1. q dvd p", "unfolding dvd_def"], ["proof (prove)\nusing this:\n  p = q * smult a (of_int_poly R)\n\ngoal (1 subgoal):\n 1. \\<exists>k. p = q * k", "by blast"], ["proof (state)\nthis:\n  q dvd p\n\ngoal (2 subgoals):\n 1. 1 \\<le> degree q\n 2. degree q \\<le> bnd", "from q dQ"], ["proof (chain)\npicking this:\n  q = of_int_poly Q\n  1 \\<le> degree Q\n  degree Q \\<le> bnd", "show \"degree q \\<ge> 1\" \"degree q \\<le> bnd\""], ["proof (prove)\nusing this:\n  q = of_int_poly Q\n  1 \\<le> degree Q\n  degree Q \\<le> bnd\n\ngoal (1 subgoal):\n 1. 1 \\<le> degree q &&& degree q \\<le> bnd", "by auto"], ["proof (state)\nthis:\n  1 \\<le> degree q\n  degree q \\<le> bnd\n\ngoal:\nNo subgoals!", "qed"], ["", "context\n  assumes df: \"divisors_fun df\" and dpf: \"divisors_pos_fun dp\"\nbegin"], ["", "lemma kronecker_factorization_main_complete: assumes \n  none: \"kronecker_factorization_main df dp bnd p = None\"\n  and dp: \"degree p \\<ge> 2\"\n  shows \"\\<not> (\\<exists> q. 1 \\<le> degree q \\<and> degree q \\<le> bnd \\<and> q dvd p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nexists>q. 1 \\<le> degree q \\<and> degree q \\<le> bnd \\<and> q dvd p", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<nexists>q. 1 \\<le> degree q \\<and> degree q \\<le> bnd \\<and> q dvd p", "let ?r = \"rat_of_int\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<nexists>q. 1 \\<le> degree q \\<and> degree q \\<le> bnd \\<and> q dvd p", "let ?rp = \"map_poly ?r\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<nexists>q. 1 \\<le> degree q \\<and> degree q \\<le> bnd \\<and> q dvd p", "from dp"], ["proof (chain)\npicking this:\n  2 \\<le> degree p", "have \"(degree p \\<le> 1) = False\""], ["proof (prove)\nusing this:\n  2 \\<le> degree p\n\ngoal (1 subgoal):\n 1. (degree p \\<le> 1) = False", "by auto"], ["proof (state)\nthis:\n  (degree p \\<le> 1) = False\n\ngoal (1 subgoal):\n 1. \\<nexists>q. 1 \\<le> degree q \\<and> degree q \\<le> bnd \\<and> q dvd p", "note res = none[unfolded kronecker_factorization_main_def Let_def this if_False]"], ["proof (state)\nthis:\n  (case map_of\n         (map (\\<lambda>j. (poly (primitive_part p) j, j))\n           (kronecker_samples bnd))\n         0 of\n   None \\<Rightarrow>\n     map_option the\n      (find_map_filter newton_interpolation_poly_int\n        (case_option False\n          (\\<lambda>g.\n              dvd_int_poly_non_0 g (primitive_part p) \\<and>\n              1 \\<le> degree g))\n        (concat_lists\n          (map (\\<lambda>(v, j).\n                   map (Pair j) (if j = 0 then dp v else df v))\n            (map (\\<lambda>j. (poly (primitive_part p) j, j))\n              (kronecker_samples bnd)))))\n   | Some j \\<Rightarrow> Some [:- j, 1:]) =\n  None\n\ngoal (1 subgoal):\n 1. \\<nexists>q. 1 \\<le> degree q \\<and> degree q \\<le> bnd \\<and> q dvd p", "define P where \"P = primitive_part p\""], ["proof (state)\nthis:\n  P = primitive_part p\n\ngoal (1 subgoal):\n 1. \\<nexists>q. 1 \\<le> degree q \\<and> degree q \\<le> bnd \\<and> q dvd p", "have degP: \"degree P = degree p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree P = degree p", "unfolding P_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (primitive_part p) = degree p", "by simp"], ["proof (state)\nthis:\n  degree P = degree p\n\ngoal (1 subgoal):\n 1. \\<nexists>q. 1 \\<le> degree q \\<and> degree q \\<le> bnd \\<and> q dvd p", "define js where \"js = kronecker_samples bnd\""], ["proof (state)\nthis:\n  js = kronecker_samples bnd\n\ngoal (1 subgoal):\n 1. \\<nexists>q. 1 \\<le> degree q \\<and> degree q \\<le> bnd \\<and> q dvd p", "define filt where \"filt = (case_option False (\\<lambda>g. dvd_int_poly_non_0 g P \\<and> 1 \\<le> degree g))\""], ["proof (state)\nthis:\n  filt =\n  case_option False\n   (\\<lambda>g. dvd_int_poly_non_0 g P \\<and> 1 \\<le> degree g)\n\ngoal (1 subgoal):\n 1. \\<nexists>q. 1 \\<le> degree q \\<and> degree q \\<le> bnd \\<and> q dvd p", "define tests where \"tests = concat_lists (map (\\<lambda>(v, j). map (Pair j) (if j = 0 then dp v else df v)) (map (\\<lambda>j. (poly P j, j)) js))\""], ["proof (state)\nthis:\n  tests =\n  concat_lists\n   (map (\\<lambda>(v, j). map (Pair j) (if j = 0 then dp v else df v))\n     (map (\\<lambda>j. (poly P j, j)) js))\n\ngoal (1 subgoal):\n 1. \\<nexists>q. 1 \\<le> degree q \\<and> degree q \\<le> bnd \\<and> q dvd p", "note res = res[folded P_def, folded js_def filt_def, folded tests_def]"], ["proof (state)\nthis:\n  (case map_of (map (\\<lambda>j. (poly P j, j)) js) 0 of\n   None \\<Rightarrow>\n     map_option the\n      (find_map_filter newton_interpolation_poly_int filt tests)\n   | Some j \\<Rightarrow> Some [:- j, 1:]) =\n  None\n\ngoal (1 subgoal):\n 1. \\<nexists>q. 1 \\<le> degree q \\<and> degree q \\<le> bnd \\<and> q dvd p", "let ?zero = \"map (\\<lambda>j. (poly P j, j)) js\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<nexists>q. 1 \\<le> degree q \\<and> degree q \\<le> bnd \\<and> q dvd p", "from res"], ["proof (chain)\npicking this:\n  (case map_of (map (\\<lambda>j. (poly P j, j)) js) 0 of\n   None \\<Rightarrow>\n     map_option the\n      (find_map_filter newton_interpolation_poly_int filt tests)\n   | Some j \\<Rightarrow> Some [:- j, 1:]) =\n  None", "have res: \"(case map_of ?zero 0 of\n     None \\<Rightarrow> map_option the (find_map_filter newton_interpolation_poly_int filt tests) | Some j \\<Rightarrow> Some [:- j, 1:]) =\n     None\""], ["proof (prove)\nusing this:\n  (case map_of (map (\\<lambda>j. (poly P j, j)) js) 0 of\n   None \\<Rightarrow>\n     map_option the\n      (find_map_filter newton_interpolation_poly_int filt tests)\n   | Some j \\<Rightarrow> Some [:- j, 1:]) =\n  None\n\ngoal (1 subgoal):\n 1. (case map_of (map (\\<lambda>j. (poly P j, j)) js) 0 of\n     None \\<Rightarrow>\n       map_option the\n        (find_map_filter newton_interpolation_poly_int filt tests)\n     | Some j \\<Rightarrow> Some [:- j, 1:]) =\n    None", "by auto"], ["proof (state)\nthis:\n  (case map_of (map (\\<lambda>j. (poly P j, j)) js) 0 of\n   None \\<Rightarrow>\n     map_option the\n      (find_map_filter newton_interpolation_poly_int filt tests)\n   | Some j \\<Rightarrow> Some [:- j, 1:]) =\n  None\n\ngoal (1 subgoal):\n 1. \\<nexists>q. 1 \\<le> degree q \\<and> degree q \\<le> bnd \\<and> q dvd p", "hence zero: \"map_of ?zero 0 = None\""], ["proof (prove)\nusing this:\n  (case map_of (map (\\<lambda>j. (poly P j, j)) js) 0 of\n   None \\<Rightarrow>\n     map_option the\n      (find_map_filter newton_interpolation_poly_int filt tests)\n   | Some j \\<Rightarrow> Some [:- j, 1:]) =\n  None\n\ngoal (1 subgoal):\n 1. map_of (map (\\<lambda>j. (poly P j, j)) js) 0 = None", "by (auto split: option.splits)"], ["proof (state)\nthis:\n  map_of (map (\\<lambda>j. (poly P j, j)) js) 0 = None\n\ngoal (1 subgoal):\n 1. \\<nexists>q. 1 \\<le> degree q \\<and> degree q \\<le> bnd \\<and> q dvd p", "with res"], ["proof (chain)\npicking this:\n  (case map_of (map (\\<lambda>j. (poly P j, j)) js) 0 of\n   None \\<Rightarrow>\n     map_option the\n      (find_map_filter newton_interpolation_poly_int filt tests)\n   | Some j \\<Rightarrow> Some [:- j, 1:]) =\n  None\n  map_of (map (\\<lambda>j. (poly P j, j)) js) 0 = None", "have res: \"find_map_filter newton_interpolation_poly_int filt tests = None\""], ["proof (prove)\nusing this:\n  (case map_of (map (\\<lambda>j. (poly P j, j)) js) 0 of\n   None \\<Rightarrow>\n     map_option the\n      (find_map_filter newton_interpolation_poly_int filt tests)\n   | Some j \\<Rightarrow> Some [:- j, 1:]) =\n  None\n  map_of (map (\\<lambda>j. (poly P j, j)) js) 0 = None\n\ngoal (1 subgoal):\n 1. find_map_filter newton_interpolation_poly_int filt tests = None", "by auto"], ["proof (state)\nthis:\n  find_map_filter newton_interpolation_poly_int filt tests = None\n\ngoal (1 subgoal):\n 1. \\<nexists>q. 1 \\<le> degree q \\<and> degree q \\<le> bnd \\<and> q dvd p", "{"], ["proof (state)\nthis:\n  find_map_filter newton_interpolation_poly_int filt tests = None\n\ngoal (1 subgoal):\n 1. \\<nexists>q. 1 \\<le> degree q \\<and> degree q \\<le> bnd \\<and> q dvd p", "fix qq"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<nexists>q. 1 \\<le> degree q \\<and> degree q \\<le> bnd \\<and> q dvd p", "assume qq: \"1 \\<le> degree qq\" \"degree qq \\<le> bnd\" and dvd: \"qq dvd p\""], ["proof (state)\nthis:\n  1 \\<le> degree qq\n  degree qq \\<le> bnd\n  qq dvd p\n\ngoal (1 subgoal):\n 1. \\<nexists>q. 1 \\<le> degree q \\<and> degree q \\<le> bnd \\<and> q dvd p", "define q' where \"q' = primitive_part qq\""], ["proof (state)\nthis:\n  q' = primitive_part qq\n\ngoal (1 subgoal):\n 1. \\<nexists>q. 1 \\<le> degree q \\<and> degree q \\<le> bnd \\<and> q dvd p", "define q where \"q = (if poly q' 0 > 0 then q' else -q')\""], ["proof (state)\nthis:\n  q = (if 0 < poly q' 0 then q' else - q')\n\ngoal (1 subgoal):\n 1. \\<nexists>q. 1 \\<le> degree q \\<and> degree q \\<le> bnd \\<and> q dvd p", "from qq"], ["proof (chain)\npicking this:\n  1 \\<le> degree qq\n  degree qq \\<le> bnd", "have q': \"1 \\<le> degree q'\" \"degree q' \\<le> bnd\""], ["proof (prove)\nusing this:\n  1 \\<le> degree qq\n  degree qq \\<le> bnd\n\ngoal (1 subgoal):\n 1. 1 \\<le> degree q' &&& degree q' \\<le> bnd", "unfolding q'_def"], ["proof (prove)\nusing this:\n  1 \\<le> degree qq\n  degree qq \\<le> bnd\n\ngoal (1 subgoal):\n 1. 1 \\<le> degree (primitive_part qq) &&&\n    degree (primitive_part qq) \\<le> bnd", "by auto"], ["proof (state)\nthis:\n  1 \\<le> degree q'\n  degree q' \\<le> bnd\n\ngoal (1 subgoal):\n 1. \\<nexists>q. 1 \\<le> degree q \\<and> degree q \\<le> bnd \\<and> q dvd p", "hence q: \"1 \\<le> degree q\" \"degree q \\<le> bnd\""], ["proof (prove)\nusing this:\n  1 \\<le> degree q'\n  degree q' \\<le> bnd\n\ngoal (1 subgoal):\n 1. 1 \\<le> degree q &&& degree q \\<le> bnd", "unfolding q_def"], ["proof (prove)\nusing this:\n  1 \\<le> degree q'\n  degree q' \\<le> bnd\n\ngoal (1 subgoal):\n 1. 1 \\<le> degree (if 0 < poly q' 0 then q' else - q') &&&\n    degree (if 0 < poly q' 0 then q' else - q') \\<le> bnd", "by auto"], ["proof (state)\nthis:\n  1 \\<le> degree q\n  degree q \\<le> bnd\n\ngoal (1 subgoal):\n 1. \\<nexists>q. 1 \\<le> degree q \\<and> degree q \\<le> bnd \\<and> q dvd p", "from dvd"], ["proof (chain)\npicking this:\n  qq dvd p", "have \"qq dvd (smult (content p) P)\""], ["proof (prove)\nusing this:\n  qq dvd p\n\ngoal (1 subgoal):\n 1. qq dvd smult (content p) P", "using content_times_primitive_part[of p]"], ["proof (prove)\nusing this:\n  qq dvd p\n  smult (content p) (primitive_part p) = p\n\ngoal (1 subgoal):\n 1. qq dvd smult (content p) P", "unfolding P_def"], ["proof (prove)\nusing this:\n  qq dvd p\n  smult (content p) (primitive_part p) = p\n\ngoal (1 subgoal):\n 1. qq dvd smult (content p) (primitive_part p)", "by simp"], ["proof (state)\nthis:\n  qq dvd smult (content p) P\n\ngoal (1 subgoal):\n 1. \\<nexists>q. 1 \\<le> degree q \\<and> degree q \\<le> bnd \\<and> q dvd p", "from dvd_smult_int[OF _ this] dp"], ["proof (chain)\npicking this:\n  content p \\<noteq> 0 \\<Longrightarrow> primitive_part qq dvd P\n  2 \\<le> degree p", "have \"q' dvd P\""], ["proof (prove)\nusing this:\n  content p \\<noteq> 0 \\<Longrightarrow> primitive_part qq dvd P\n  2 \\<le> degree p\n\ngoal (1 subgoal):\n 1. q' dvd P", "unfolding q'_def"], ["proof (prove)\nusing this:\n  content p \\<noteq> 0 \\<Longrightarrow> primitive_part qq dvd P\n  2 \\<le> degree p\n\ngoal (1 subgoal):\n 1. primitive_part qq dvd P", "by force"], ["proof (state)\nthis:\n  q' dvd P\n\ngoal (1 subgoal):\n 1. \\<nexists>q. 1 \\<le> degree q \\<and> degree q \\<le> bnd \\<and> q dvd p", "hence dvd: \"q dvd P\""], ["proof (prove)\nusing this:\n  q' dvd P\n\ngoal (1 subgoal):\n 1. q dvd P", "unfolding q_def"], ["proof (prove)\nusing this:\n  q' dvd P\n\ngoal (1 subgoal):\n 1. (if 0 < poly q' 0 then q' else - q') dvd P", "by auto"], ["proof (state)\nthis:\n  q dvd P\n\ngoal (1 subgoal):\n 1. \\<nexists>q. 1 \\<le> degree q \\<and> degree q \\<le> bnd \\<and> q dvd p", "then"], ["proof (chain)\npicking this:\n  q dvd P", "obtain r where P: \"P = q * r\""], ["proof (prove)\nusing this:\n  q dvd P\n\ngoal (1 subgoal):\n 1. (\\<And>r. P = q * r \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "unfolding dvd_def"], ["proof (prove)\nusing this:\n  \\<exists>k. P = q * k\n\ngoal (1 subgoal):\n 1. (\\<And>r. P = q * r \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  P = q * r\n\ngoal (1 subgoal):\n 1. \\<nexists>q. 1 \\<le> degree q \\<and> degree q \\<le> bnd \\<and> q dvd p", "{"], ["proof (state)\nthis:\n  P = q * r\n\ngoal (1 subgoal):\n 1. \\<nexists>q. 1 \\<le> degree q \\<and> degree q \\<le> bnd \\<and> q dvd p", "fix j"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<nexists>q. 1 \\<le> degree q \\<and> degree q \\<le> bnd \\<and> q dvd p", "assume j: \"j \\<in> set js\""], ["proof (state)\nthis:\n  j \\<in> set js\n\ngoal (1 subgoal):\n 1. \\<nexists>q. 1 \\<le> degree q \\<and> degree q \\<le> bnd \\<and> q dvd p", "from P"], ["proof (chain)\npicking this:\n  P = q * r", "have id: \"poly P j = poly q j * poly r j\""], ["proof (prove)\nusing this:\n  P = q * r\n\ngoal (1 subgoal):\n 1. poly P j = poly q j * poly r j", "by auto"], ["proof (state)\nthis:\n  poly P j = poly q j * poly r j\n\ngoal (1 subgoal):\n 1. \\<nexists>q. 1 \\<le> degree q \\<and> degree q \\<le> bnd \\<and> q dvd p", "hence dvd: \"poly q j dvd poly P j\""], ["proof (prove)\nusing this:\n  poly P j = poly q j * poly r j\n\ngoal (1 subgoal):\n 1. poly q j dvd poly P j", "by auto"], ["proof (state)\nthis:\n  poly q j dvd poly P j\n\ngoal (1 subgoal):\n 1. \\<nexists>q. 1 \\<le> degree q \\<and> degree q \\<le> bnd \\<and> q dvd p", "from j"], ["proof (chain)\npicking this:\n  j \\<in> set js", "have \"(poly P j, j) \\<in> set ?zero\""], ["proof (prove)\nusing this:\n  j \\<in> set js\n\ngoal (1 subgoal):\n 1. (poly P j, j) \\<in> set (map (\\<lambda>j. (poly P j, j)) js)", "by auto"], ["proof (state)\nthis:\n  (poly P j, j) \\<in> set (map (\\<lambda>j. (poly P j, j)) js)\n\ngoal (1 subgoal):\n 1. \\<nexists>q. 1 \\<le> degree q \\<and> degree q \\<le> bnd \\<and> q dvd p", "with zero"], ["proof (chain)\npicking this:\n  map_of (map (\\<lambda>j. (poly P j, j)) js) 0 = None\n  (poly P j, j) \\<in> set (map (\\<lambda>j. (poly P j, j)) js)", "have zero: \"poly P j \\<noteq> 0\""], ["proof (prove)\nusing this:\n  map_of (map (\\<lambda>j. (poly P j, j)) js) 0 = None\n  (poly P j, j) \\<in> set (map (\\<lambda>j. (poly P j, j)) js)\n\ngoal (1 subgoal):\n 1. poly P j \\<noteq> 0", "unfolding map_of_eq_None_iff"], ["proof (prove)\nusing this:\n  0 \\<notin> fst ` set (map (\\<lambda>j. (poly P j, j)) js)\n  (poly P j, j) \\<in> set (map (\\<lambda>j. (poly P j, j)) js)\n\ngoal (1 subgoal):\n 1. poly P j \\<noteq> 0", "by force"], ["proof (state)\nthis:\n  poly P j \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<nexists>q. 1 \\<le> degree q \\<and> degree q \\<le> bnd \\<and> q dvd p", "with id"], ["proof (chain)\npicking this:\n  poly P j = poly q j * poly r j\n  poly P j \\<noteq> 0", "have \"poly q j \\<noteq> 0\""], ["proof (prove)\nusing this:\n  poly P j = poly q j * poly r j\n  poly P j \\<noteq> 0\n\ngoal (1 subgoal):\n 1. poly q j \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  poly q j \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<nexists>q. 1 \\<le> degree q \\<and> degree q \\<le> bnd \\<and> q dvd p", "hence \"j = 0 \\<Longrightarrow> poly q j > 0\""], ["proof (prove)\nusing this:\n  poly q j \\<noteq> 0\n\ngoal (1 subgoal):\n 1. j = 0 \\<Longrightarrow> 0 < poly q j", "unfolding q_def"], ["proof (prove)\nusing this:\n  poly (if 0 < poly q' 0 then q' else - q') j \\<noteq> 0\n\ngoal (1 subgoal):\n 1. j = 0 \\<Longrightarrow> 0 < poly (if 0 < poly q' 0 then q' else - q') j", "by auto"], ["proof (state)\nthis:\n  j = 0 \\<Longrightarrow> 0 < poly q j\n\ngoal (1 subgoal):\n 1. \\<nexists>q. 1 \\<le> degree q \\<and> degree q \\<le> bnd \\<and> q dvd p", "from divisors_funD[OF df zero dvd] divisors_pos_funD[OF dpf zero dvd this]"], ["proof (chain)\npicking this:\n  poly q j \\<in> set (df (poly P j))\n  j = 0 \\<Longrightarrow> poly q j \\<in> set (dp (poly P j))", "have \"poly q j \\<in> set (df (poly P j))\" \"j = 0 \\<Longrightarrow> poly q j \\<in> set (dp (poly P j))\""], ["proof (prove)\nusing this:\n  poly q j \\<in> set (df (poly P j))\n  j = 0 \\<Longrightarrow> poly q j \\<in> set (dp (poly P j))\n\ngoal (1 subgoal):\n 1. poly q j \\<in> set (df (poly P j)) &&&\n    (j = 0 \\<Longrightarrow> poly q j \\<in> set (dp (poly P j)))", "."], ["proof (state)\nthis:\n  poly q j \\<in> set (df (poly P j))\n  j = 0 \\<Longrightarrow> poly q j \\<in> set (dp (poly P j))\n\ngoal (1 subgoal):\n 1. \\<nexists>q. 1 \\<le> degree q \\<and> degree q \\<le> bnd \\<and> q dvd p", "}"], ["proof (state)\nthis:\n  ?j2 \\<in> set js \\<Longrightarrow> poly q ?j2 \\<in> set (df (poly P ?j2))\n  \\<lbrakk>?j2 \\<in> set js; ?j2 = 0\\<rbrakk>\n  \\<Longrightarrow> poly q ?j2 \\<in> set (dp (poly P ?j2))\n\ngoal (1 subgoal):\n 1. \\<nexists>q. 1 \\<le> degree q \\<and> degree q \\<le> bnd \\<and> q dvd p", "note mem1 = this"], ["proof (state)\nthis:\n  ?j2 \\<in> set js \\<Longrightarrow> poly q ?j2 \\<in> set (df (poly P ?j2))\n  \\<lbrakk>?j2 \\<in> set js; ?j2 = 0\\<rbrakk>\n  \\<Longrightarrow> poly q ?j2 \\<in> set (dp (poly P ?j2))\n\ngoal (1 subgoal):\n 1. \\<nexists>q. 1 \\<le> degree q \\<and> degree q \\<le> bnd \\<and> q dvd p", "define t where \"t = map (\\<lambda> j. (j, poly q j)) js\""], ["proof (state)\nthis:\n  t = map (\\<lambda>j. (j, poly q j)) js\n\ngoal (1 subgoal):\n 1. \\<nexists>q. 1 \\<le> degree q \\<and> degree q \\<le> bnd \\<and> q dvd p", "have t: \"t \\<in> set tests\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<in> set tests", "unfolding tests_def concat_lists_listset listset length_map map_map o_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<in> {ys.\n             length ys = length js \\<and>\n             (\\<forall>i<length js.\n                 ys ! i\n                 \\<in> map (\\<lambda>x.\n                               set (case (poly P x, x) of\n                                    (v, j) \\<Rightarrow>\nmap (Pair j) (if j = 0 then dp v else df v)))\n                        js !\n                       i)}", "proof (rule, intro conjI allI impI)"], ["proof (state)\ngoal (2 subgoals):\n 1. length t = length js\n 2. \\<And>i.\n       i < length js \\<Longrightarrow>\n       t ! i\n       \\<in> map (\\<lambda>x.\n                     set (case (poly P x, x) of\n                          (v, j) \\<Rightarrow>\n                            map (Pair j) (if j = 0 then dp v else df v)))\n              js !\n             i", "show \"length t = length js\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length t = length js", "unfolding t_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (map (\\<lambda>j. (j, poly q j)) js) = length js", "by simp"], ["proof (state)\nthis:\n  length t = length js\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length js \\<Longrightarrow>\n       t ! i\n       \\<in> map (\\<lambda>x.\n                     set (case (poly P x, x) of\n                          (v, j) \\<Rightarrow>\n                            map (Pair j) (if j = 0 then dp v else df v)))\n              js !\n             i", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length js \\<Longrightarrow>\n       t ! i\n       \\<in> map (\\<lambda>x.\n                     set (case (poly P x, x) of\n                          (v, j) \\<Rightarrow>\n                            map (Pair j) (if j = 0 then dp v else df v)))\n              js !\n             i", "assume i: \"i < length js\""], ["proof (state)\nthis:\n  i < length js\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length js \\<Longrightarrow>\n       t ! i\n       \\<in> map (\\<lambda>x.\n                     set (case (poly P x, x) of\n                          (v, j) \\<Rightarrow>\n                            map (Pair j) (if j = 0 then dp v else df v)))\n              js !\n             i", "hence jsi: \"js ! i \\<in> set js\""], ["proof (prove)\nusing this:\n  i < length js\n\ngoal (1 subgoal):\n 1. js ! i \\<in> set js", "by auto"], ["proof (state)\nthis:\n  js ! i \\<in> set js\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length js \\<Longrightarrow>\n       t ! i\n       \\<in> map (\\<lambda>x.\n                     set (case (poly P x, x) of\n                          (v, j) \\<Rightarrow>\n                            map (Pair j) (if j = 0 then dp v else df v)))\n              js !\n             i", "have ti: \"t ! i = (js ! i, poly q (js ! i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t ! i = (js ! i, poly q (js ! i))", "unfolding t_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>j. (j, poly q j)) js ! i = (js ! i, poly q (js ! i))", "using i"], ["proof (prove)\nusing this:\n  i < length js\n\ngoal (1 subgoal):\n 1. map (\\<lambda>j. (j, poly q j)) js ! i = (js ! i, poly q (js ! i))", "by auto"], ["proof (state)\nthis:\n  t ! i = (js ! i, poly q (js ! i))\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length js \\<Longrightarrow>\n       t ! i\n       \\<in> map (\\<lambda>x.\n                     set (case (poly P x, x) of\n                          (v, j) \\<Rightarrow>\n                            map (Pair j) (if j = 0 then dp v else df v)))\n              js !\n             i", "let ?f = \"(\\<lambda>x. set (case (poly P x, x) of (v, j) \\<Rightarrow> map (Pair j) (if j = 0 then dp v else df v)))\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length js \\<Longrightarrow>\n       t ! i\n       \\<in> map (\\<lambda>x.\n                     set (case (poly P x, x) of\n                          (v, j) \\<Rightarrow>\n                            map (Pair j) (if j = 0 then dp v else df v)))\n              js !\n             i", "show \"t ! i \\<in> map ?f js ! i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t ! i\n    \\<in> map (\\<lambda>x.\n                  set (case (poly P x, x) of\n                       (v, j) \\<Rightarrow>\n                         map (Pair j) (if j = 0 then dp v else df v)))\n           js !\n          i", "unfolding ti nth_map[OF i] split"], ["proof (prove)\ngoal (1 subgoal):\n 1. (js ! i, poly q (js ! i))\n    \\<in> set (map (Pair (js ! i))\n                (if js ! i = 0 then dp (poly P (js ! i))\n                 else df (poly P (js ! i))))", "using mem1[OF jsi]"], ["proof (prove)\nusing this:\n  poly q (js ! i) \\<in> set (df (poly P (js ! i)))\n  js ! i = 0 \\<Longrightarrow>\n  poly q (js ! i) \\<in> set (dp (poly P (js ! i)))\n\ngoal (1 subgoal):\n 1. (js ! i, poly q (js ! i))\n    \\<in> set (map (Pair (js ! i))\n                (if js ! i = 0 then dp (poly P (js ! i))\n                 else df (poly P (js ! i))))", "by auto"], ["proof (state)\nthis:\n  t ! i\n  \\<in> map (\\<lambda>x.\n                set (case (poly P x, x) of\n                     (v, j) \\<Rightarrow>\n                       map (Pair j) (if j = 0 then dp v else df v)))\n         js !\n        i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  t \\<in> set tests\n\ngoal (1 subgoal):\n 1. \\<nexists>q. 1 \\<le> degree q \\<and> degree q \\<le> bnd \\<and> q dvd p", "have dist: \"distinct js\" and lenj: \"length js = Suc bnd\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct js &&& length js = Suc bnd", "unfolding js_def degP"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (kronecker_samples bnd) &&&\n    length (kronecker_samples bnd) = Suc bnd", "using kronecker_samples"], ["proof (prove)\nusing this:\n  distinct (kronecker_samples ?n)\n  length (kronecker_samples ?n) = Suc ?n\n\ngoal (1 subgoal):\n 1. distinct (kronecker_samples bnd) &&&\n    length (kronecker_samples bnd) = Suc bnd", "by auto"], ["proof (state)\nthis:\n  distinct js\n  length js = Suc bnd\n\ngoal (1 subgoal):\n 1. \\<nexists>q. 1 \\<le> degree q \\<and> degree q \\<le> bnd \\<and> q dvd p", "have map_fst: \"map fst t = js\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map fst t = js", "unfolding t_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map fst (map (\\<lambda>j. (j, poly q j)) js) = js", "by (rule nth_equalityI, auto)"], ["proof (state)\nthis:\n  map fst t = js\n\ngoal (1 subgoal):\n 1. \\<nexists>q. 1 \\<le> degree q \\<and> degree q \\<le> bnd \\<and> q dvd p", "with dist"], ["proof (chain)\npicking this:\n  distinct js\n  map fst t = js", "have dist: \"distinct (map fst t)\""], ["proof (prove)\nusing this:\n  distinct js\n  map fst t = js\n\ngoal (1 subgoal):\n 1. distinct (map fst t)", "by simp"], ["proof (state)\nthis:\n  distinct (map fst t)\n\ngoal (1 subgoal):\n 1. \\<nexists>q. 1 \\<le> degree q \\<and> degree q \\<le> bnd \\<and> q dvd p", "from lenj q degP"], ["proof (chain)\npicking this:\n  length js = Suc bnd\n  1 \\<le> degree q\n  degree q \\<le> bnd\n  degree P = degree p", "have degq: \"degree q < length t\""], ["proof (prove)\nusing this:\n  length js = Suc bnd\n  1 \\<le> degree q\n  degree q \\<le> bnd\n  degree P = degree p\n\ngoal (1 subgoal):\n 1. degree q < length t", "unfolding t_def"], ["proof (prove)\nusing this:\n  length js = Suc bnd\n  1 \\<le> degree q\n  degree q \\<le> bnd\n  degree P = degree p\n\ngoal (1 subgoal):\n 1. degree q < length (map (\\<lambda>j. (j, poly q j)) js)", "by auto"], ["proof (state)\nthis:\n  degree q < length t\n\ngoal (1 subgoal):\n 1. \\<nexists>q. 1 \\<le> degree q \\<and> degree q \\<le> bnd \\<and> q dvd p", "from find_map_filter_None[OF res] t"], ["proof (chain)\npicking this:\n  \\<forall>b\\<in>newton_interpolation_poly_int ` set tests. \\<not> filt b\n  t \\<in> set tests", "have nfilt: \"\\<not> filt (newton_interpolation_poly_int t)\""], ["proof (prove)\nusing this:\n  \\<forall>b\\<in>newton_interpolation_poly_int ` set tests. \\<not> filt b\n  t \\<in> set tests\n\ngoal (1 subgoal):\n 1. \\<not> filt (newton_interpolation_poly_int t)", "by auto"], ["proof (state)\nthis:\n  \\<not> filt (newton_interpolation_poly_int t)\n\ngoal (1 subgoal):\n 1. \\<nexists>q. 1 \\<le> degree q \\<and> degree q \\<le> bnd \\<and> q dvd p", "have qt: \"\\<And>x y. (x, y) \\<in> set t \\<Longrightarrow> poly q x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y. (x, y) \\<in> set t \\<Longrightarrow> poly q x = y", "unfolding t_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       (x, y)\n       \\<in> set (map (\\<lambda>j. (j, poly q j)) js) \\<Longrightarrow>\n       poly q x = y", "by auto"], ["proof (state)\nthis:\n  (?x, ?y) \\<in> set t \\<Longrightarrow> poly q ?x = ?y\n\ngoal (1 subgoal):\n 1. \\<nexists>q. 1 \\<le> degree q \\<and> degree q \\<le> bnd \\<and> q dvd p", "from interpolation_poly_int_None[OF dist _ qt degq, of Newton]"], ["proof (chain)\npicking this:\n  \\<lbrakk>interpolation_poly_int Newton t = None;\n   \\<And>x y.\n      (x, y) \\<in> set t \\<Longrightarrow> (x, y) \\<in> set t\\<rbrakk>\n  \\<Longrightarrow> False", "have\n      \"newton_interpolation_poly_int t \\<noteq> None\""], ["proof (prove)\nusing this:\n  \\<lbrakk>interpolation_poly_int Newton t = None;\n   \\<And>x y.\n      (x, y) \\<in> set t \\<Longrightarrow> (x, y) \\<in> set t\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. newton_interpolation_poly_int t \\<noteq> None", "by auto"], ["proof (state)\nthis:\n  newton_interpolation_poly_int t \\<noteq> None\n\ngoal (1 subgoal):\n 1. \\<nexists>q. 1 \\<le> degree q \\<and> degree q \\<le> bnd \\<and> q dvd p", "then"], ["proof (chain)\npicking this:\n  newton_interpolation_poly_int t \\<noteq> None", "obtain g where lt: \"newton_interpolation_poly_int t = Some g\""], ["proof (prove)\nusing this:\n  newton_interpolation_poly_int t \\<noteq> None\n\ngoal (1 subgoal):\n 1. (\\<And>g.\n        newton_interpolation_poly_int t = Some g \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  newton_interpolation_poly_int t = Some g\n\ngoal (1 subgoal):\n 1. \\<nexists>q. 1 \\<le> degree q \\<and> degree q \\<le> bnd \\<and> q dvd p", "from newton_interpolation_poly_int_Some[OF dist lt]"], ["proof (chain)\npicking this:\n  (?x, ?y) \\<in> set t \\<Longrightarrow> poly g ?x = ?y\n  degree g \\<le> length t - 1", "have gt: \"\\<And> x y. (x, y) \\<in> set t \\<Longrightarrow> poly g x = y\" and degg: \"degree g < length t\""], ["proof (prove)\nusing this:\n  (?x, ?y) \\<in> set t \\<Longrightarrow> poly g ?x = ?y\n  degree g \\<le> length t - 1\n\ngoal (1 subgoal):\n 1. (\\<And>x y. (x, y) \\<in> set t \\<Longrightarrow> poly g x = y) &&&\n    degree g < length t", "using degq"], ["proof (prove)\nusing this:\n  (?x, ?y) \\<in> set t \\<Longrightarrow> poly g ?x = ?y\n  degree g \\<le> length t - 1\n  degree q < length t\n\ngoal (1 subgoal):\n 1. (\\<And>x y. (x, y) \\<in> set t \\<Longrightarrow> poly g x = y) &&&\n    degree g < length t", "by auto"], ["proof (state)\nthis:\n  (?x, ?y) \\<in> set t \\<Longrightarrow> poly g ?x = ?y\n  degree g < length t\n\ngoal (1 subgoal):\n 1. \\<nexists>q. 1 \\<le> degree q \\<and> degree q \\<le> bnd \\<and> q dvd p", "from uniqueness_of_interpolation_point_list[OF dist qt degq gt degg]"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<And>x y.\n              (x, y) \\<in> set t \\<Longrightarrow> (x, y) \\<in> set t;\n   \\<And>x y.\n      (x, y) \\<in> set t \\<Longrightarrow> (x, y) \\<in> set t\\<rbrakk>\n  \\<Longrightarrow> q = g", "have g: \"g = q\""], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>x y.\n              (x, y) \\<in> set t \\<Longrightarrow> (x, y) \\<in> set t;\n   \\<And>x y.\n      (x, y) \\<in> set t \\<Longrightarrow> (x, y) \\<in> set t\\<rbrakk>\n  \\<Longrightarrow> q = g\n\ngoal (1 subgoal):\n 1. g = q", "by auto"], ["proof (state)\nthis:\n  g = q\n\ngoal (1 subgoal):\n 1. \\<nexists>q. 1 \\<le> degree q \\<and> degree q \\<le> bnd \\<and> q dvd p", "from nfilt[unfolded lt g]"], ["proof (chain)\npicking this:\n  \\<not> filt (Some q)", "have \"\\<not> filt (Some q)\""], ["proof (prove)\nusing this:\n  \\<not> filt (Some q)\n\ngoal (1 subgoal):\n 1. \\<not> filt (Some q)", "."], ["proof (state)\nthis:\n  \\<not> filt (Some q)\n\ngoal (1 subgoal):\n 1. \\<nexists>q. 1 \\<le> degree q \\<and> degree q \\<le> bnd \\<and> q dvd p", "from this[unfolded filt_def] q dvd"], ["proof (chain)\npicking this:\n  \\<not> (case Some q of None \\<Rightarrow> False\n          | Some g \\<Rightarrow>\n              dvd_int_poly_non_0 g P \\<and> 1 \\<le> degree g)\n  1 \\<le> degree q\n  degree q \\<le> bnd\n  q dvd P", "have False"], ["proof (prove)\nusing this:\n  \\<not> (case Some q of None \\<Rightarrow> False\n          | Some g \\<Rightarrow>\n              dvd_int_poly_non_0 g P \\<and> 1 \\<le> degree g)\n  1 \\<le> degree q\n  degree q \\<le> bnd\n  q dvd P\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<nexists>q. 1 \\<le> degree q \\<and> degree q \\<le> bnd \\<and> q dvd p", "}"], ["proof (state)\nthis:\n  \\<lbrakk>1 \\<le> degree ?qq2; degree ?qq2 \\<le> bnd; ?qq2 dvd p\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<nexists>q. 1 \\<le> degree q \\<and> degree q \\<le> bnd \\<and> q dvd p", "note main = this"], ["proof (state)\nthis:\n  \\<lbrakk>1 \\<le> degree ?qq2; degree ?qq2 \\<le> bnd; ?qq2 dvd p\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<nexists>q. 1 \\<le> degree q \\<and> degree q \\<le> bnd \\<and> q dvd p", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>1 \\<le> degree ?qq2; degree ?qq2 \\<le> bnd; ?qq2 dvd p\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<nexists>q. 1 \\<le> degree q \\<and> degree q \\<le> bnd \\<and> q dvd p", "by auto"], ["proof (state)\nthis:\n  \\<nexists>q. 1 \\<le> degree q \\<and> degree q \\<le> bnd \\<and> q dvd p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma kronecker_factorization_rat_main_complete: assumes \n  none: \"kronecker_factorization_rat_main df dp bnd p = None\"\n  and dp: \"degree p \\<ge> 2\"\n  shows \"\\<not> (\\<exists> q. 1 \\<le> degree q \\<and> degree q \\<le> bnd \\<and> q dvd p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nexists>q. 1 \\<le> degree q \\<and> degree q \\<le> bnd \\<and> q dvd p", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>q.\n       1 \\<le> degree q \\<and>\n       degree q \\<le> bnd \\<and> q dvd p \\<Longrightarrow>\n    False", "assume \"\\<exists> q. 1 \\<le> degree q \\<and> degree q \\<le> bnd \\<and> q dvd p\""], ["proof (state)\nthis:\n  \\<exists>q. 1 \\<le> degree q \\<and> degree q \\<le> bnd \\<and> q dvd p\n\ngoal (1 subgoal):\n 1. \\<exists>q.\n       1 \\<le> degree q \\<and>\n       degree q \\<le> bnd \\<and> q dvd p \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<exists>q. 1 \\<le> degree q \\<and> degree q \\<le> bnd \\<and> q dvd p", "obtain q where q: \"1 \\<le> degree q\" \"degree q \\<le> bnd\" and dvd: \"q dvd p\""], ["proof (prove)\nusing this:\n  \\<exists>q. 1 \\<le> degree q \\<and> degree q \\<le> bnd \\<and> q dvd p\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        \\<lbrakk>1 \\<le> degree q; degree q \\<le> bnd; q dvd p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  1 \\<le> degree q\n  degree q \\<le> bnd\n  q dvd p\n\ngoal (1 subgoal):\n 1. \\<exists>q.\n       1 \\<le> degree q \\<and>\n       degree q \\<le> bnd \\<and> q dvd p \\<Longrightarrow>\n    False", "from dvd"], ["proof (chain)\npicking this:\n  q dvd p", "obtain r where prod: \"p = q * r\""], ["proof (prove)\nusing this:\n  q dvd p\n\ngoal (1 subgoal):\n 1. (\\<And>r. p = q * r \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "unfolding dvd_def"], ["proof (prove)\nusing this:\n  \\<exists>k. p = q * k\n\ngoal (1 subgoal):\n 1. (\\<And>r. p = q * r \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  p = q * r\n\ngoal (1 subgoal):\n 1. \\<exists>q.\n       1 \\<le> degree q \\<and>\n       degree q \\<le> bnd \\<and> q dvd p \\<Longrightarrow>\n    False", "let ?r = \"rat_of_int\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>q.\n       1 \\<le> degree q \\<and>\n       degree q \\<le> bnd \\<and> q dvd p \\<Longrightarrow>\n    False", "let ?rp = \"map_poly ?r\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>q.\n       1 \\<le> degree q \\<and>\n       degree q \\<le> bnd \\<and> q dvd p \\<Longrightarrow>\n    False", "let ?p = \"rat_to_normalized_int_poly p\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>q.\n       1 \\<le> degree q \\<and>\n       degree q \\<le> bnd \\<and> q dvd p \\<Longrightarrow>\n    False", "obtain a P where rp: \"?p = (a,P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a P.\n        rat_to_normalized_int_poly p = (a, P) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  rat_to_normalized_int_poly p = (a, P)\n\ngoal (1 subgoal):\n 1. \\<exists>q.\n       1 \\<le> degree q \\<and>\n       degree q \\<le> bnd \\<and> q dvd p \\<Longrightarrow>\n    False", "from rat_to_normalized_int_poly[OF this]"], ["proof (chain)\npicking this:\n  p = smult a (of_int_poly P)\n  0 < a\n  p \\<noteq> 0 \\<Longrightarrow> content P = 1\n  degree P = degree p", "have deg: \"degree P = degree p\""], ["proof (prove)\nusing this:\n  p = smult a (of_int_poly P)\n  0 < a\n  p \\<noteq> 0 \\<Longrightarrow> content P = 1\n  degree P = degree p\n\ngoal (1 subgoal):\n 1. degree P = degree p", "by auto"], ["proof (state)\nthis:\n  degree P = degree p\n\ngoal (1 subgoal):\n 1. \\<exists>q.\n       1 \\<le> degree q \\<and>\n       degree q \\<le> bnd \\<and> q dvd p \\<Longrightarrow>\n    False", "from rat_to_int_factor_normalized_int_poly[OF prod rp]"], ["proof (chain)\npicking this:\n  \\<exists>g' h'. P = g' * h' \\<and> degree g' = degree q", "obtain g' where dvd: \"g' dvd P\" and dg: \"degree g' = degree q\""], ["proof (prove)\nusing this:\n  \\<exists>g' h'. P = g' * h' \\<and> degree g' = degree q\n\ngoal (1 subgoal):\n 1. (\\<And>g'.\n        \\<lbrakk>g' dvd P; degree g' = degree q\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto intro: dvdI)"], ["proof (state)\nthis:\n  g' dvd P\n  degree g' = degree q\n\ngoal (1 subgoal):\n 1. \\<exists>q.\n       1 \\<le> degree q \\<and>\n       degree q \\<le> bnd \\<and> q dvd p \\<Longrightarrow>\n    False", "have \"kronecker_factorization_main df dp bnd P = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. kronecker_factorization_main df dp bnd P = None", "using none[unfolded kronecker_factorization_rat_main_def rp]"], ["proof (prove)\nusing this:\n  map_option of_int_poly\n   (kronecker_factorization_main df dp bnd (snd (a, P))) =\n  None\n\ngoal (1 subgoal):\n 1. kronecker_factorization_main df dp bnd P = None", "by auto"], ["proof (state)\nthis:\n  kronecker_factorization_main df dp bnd P = None\n\ngoal (1 subgoal):\n 1. \\<exists>q.\n       1 \\<le> degree q \\<and>\n       degree q \\<le> bnd \\<and> q dvd p \\<Longrightarrow>\n    False", "from kronecker_factorization_main_complete[OF this dp[folded deg]] dg dvd q"], ["proof (chain)\npicking this:\n  \\<nexists>q. 1 \\<le> degree q \\<and> degree q \\<le> bnd \\<and> q dvd P\n  degree g' = degree q\n  g' dvd P\n  1 \\<le> degree q\n  degree q \\<le> bnd", "show False"], ["proof (prove)\nusing this:\n  \\<nexists>q. 1 \\<le> degree q \\<and> degree q \\<le> bnd \\<and> q dvd P\n  degree g' = degree q\n  g' dvd P\n  1 \\<le> degree q\n  degree q \\<le> bnd\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"], ["", "lemma kronecker_factorization:\n  \"kronecker_factorization p = Some q \\<Longrightarrow> \n    degree q \\<ge> 1 \\<and> degree q < degree p \\<and> q dvd p\"\n  \"kronecker_factorization p = None \\<Longrightarrow> degree p \\<ge> 1 \\<Longrightarrow> irreducible\\<^sub>d p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (kronecker_factorization p = Some q \\<Longrightarrow>\n     1 \\<le> degree q \\<and> degree q < degree p \\<and> q dvd p) &&&\n    (\\<lbrakk>kronecker_factorization p = None; 1 \\<le> degree p\\<rbrakk>\n     \\<Longrightarrow> irreducible\\<^sub>d p)", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. kronecker_factorization p = Some q \\<Longrightarrow>\n    1 \\<le> degree q \\<and> degree q < degree p \\<and> q dvd p\n 2. \\<lbrakk>kronecker_factorization p = None; 1 \\<le> degree p\\<rbrakk>\n    \\<Longrightarrow> irreducible\\<^sub>d p", "note d = kronecker_factorization_def"], ["proof (state)\nthis:\n  kronecker_factorization ?p =\n  kronecker_factorization_main divisors_int divisors_int_pos\n   (degree ?p div 2) ?p\n\ngoal (2 subgoals):\n 1. kronecker_factorization p = Some q \\<Longrightarrow>\n    1 \\<le> degree q \\<and> degree q < degree p \\<and> q dvd p\n 2. \\<lbrakk>kronecker_factorization p = None; 1 \\<le> degree p\\<rbrakk>\n    \\<Longrightarrow> irreducible\\<^sub>d p", "{"], ["proof (state)\nthis:\n  kronecker_factorization ?p =\n  kronecker_factorization_main divisors_int divisors_int_pos\n   (degree ?p div 2) ?p\n\ngoal (2 subgoals):\n 1. kronecker_factorization p = Some q \\<Longrightarrow>\n    1 \\<le> degree q \\<and> degree q < degree p \\<and> q dvd p\n 2. \\<lbrakk>kronecker_factorization p = None; 1 \\<le> degree p\\<rbrakk>\n    \\<Longrightarrow> irreducible\\<^sub>d p", "assume \"kronecker_factorization p = Some q\""], ["proof (state)\nthis:\n  kronecker_factorization p = Some q\n\ngoal (2 subgoals):\n 1. kronecker_factorization p = Some q \\<Longrightarrow>\n    1 \\<le> degree q \\<and> degree q < degree p \\<and> q dvd p\n 2. \\<lbrakk>kronecker_factorization p = None; 1 \\<le> degree p\\<rbrakk>\n    \\<Longrightarrow> irreducible\\<^sub>d p", "from kronecker_factorization_main_sound[OF this[unfolded d]]"], ["proof (chain)\npicking this:\n  (2 \\<le> degree p \\<Longrightarrow>\n   1 \\<le> degree p div 2) \\<Longrightarrow>\n  1 \\<le> degree q\n  (2 \\<le> degree p \\<Longrightarrow>\n   1 \\<le> degree p div 2) \\<Longrightarrow>\n  degree q \\<le> degree p div 2\n  (2 \\<le> degree p \\<Longrightarrow>\n   1 \\<le> degree p div 2) \\<Longrightarrow>\n  q dvd p", "show \"degree q \\<ge> 1 \\<and> degree q < degree p \\<and> q dvd p\""], ["proof (prove)\nusing this:\n  (2 \\<le> degree p \\<Longrightarrow>\n   1 \\<le> degree p div 2) \\<Longrightarrow>\n  1 \\<le> degree q\n  (2 \\<le> degree p \\<Longrightarrow>\n   1 \\<le> degree p div 2) \\<Longrightarrow>\n  degree q \\<le> degree p div 2\n  (2 \\<le> degree p \\<Longrightarrow>\n   1 \\<le> degree p div 2) \\<Longrightarrow>\n  q dvd p\n\ngoal (1 subgoal):\n 1. 1 \\<le> degree q \\<and> degree q < degree p \\<and> q dvd p", "by auto linarith"], ["proof (state)\nthis:\n  1 \\<le> degree q \\<and> degree q < degree p \\<and> q dvd p\n\ngoal (1 subgoal):\n 1. \\<lbrakk>kronecker_factorization p = None; 1 \\<le> degree p\\<rbrakk>\n    \\<Longrightarrow> irreducible\\<^sub>d p", "}"], ["proof (state)\nthis:\n  kronecker_factorization p = Some q \\<Longrightarrow>\n  1 \\<le> degree q \\<and> degree q < degree p \\<and> q dvd p\n\ngoal (1 subgoal):\n 1. \\<lbrakk>kronecker_factorization p = None; 1 \\<le> degree p\\<rbrakk>\n    \\<Longrightarrow> irreducible\\<^sub>d p", "assume kf: \"kronecker_factorization p = None\" and deg: \"degree p \\<ge> 1\""], ["proof (state)\nthis:\n  kronecker_factorization p = None\n  1 \\<le> degree p\n\ngoal (1 subgoal):\n 1. \\<lbrakk>kronecker_factorization p = None; 1 \\<le> degree p\\<rbrakk>\n    \\<Longrightarrow> irreducible\\<^sub>d p", "show \"irreducible\\<^sub>d p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. irreducible\\<^sub>d p", "proof (cases \"degree p = 1\")"], ["proof (state)\ngoal (2 subgoals):\n 1. degree p = 1 \\<Longrightarrow> irreducible\\<^sub>d p\n 2. degree p \\<noteq> 1 \\<Longrightarrow> irreducible\\<^sub>d p", "case True"], ["proof (state)\nthis:\n  degree p = 1\n\ngoal (2 subgoals):\n 1. degree p = 1 \\<Longrightarrow> irreducible\\<^sub>d p\n 2. degree p \\<noteq> 1 \\<Longrightarrow> irreducible\\<^sub>d p", "thus ?thesis"], ["proof (prove)\nusing this:\n  degree p = 1\n\ngoal (1 subgoal):\n 1. irreducible\\<^sub>d p", "by (rule linear_irreducible\\<^sub>d)"], ["proof (state)\nthis:\n  irreducible\\<^sub>d p\n\ngoal (1 subgoal):\n 1. degree p \\<noteq> 1 \\<Longrightarrow> irreducible\\<^sub>d p", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. degree p \\<noteq> 1 \\<Longrightarrow> irreducible\\<^sub>d p", "case False"], ["proof (state)\nthis:\n  degree p \\<noteq> 1\n\ngoal (1 subgoal):\n 1. degree p \\<noteq> 1 \\<Longrightarrow> irreducible\\<^sub>d p", "with deg"], ["proof (chain)\npicking this:\n  1 \\<le> degree p\n  degree p \\<noteq> 1", "have \"degree p \\<ge> 2\""], ["proof (prove)\nusing this:\n  1 \\<le> degree p\n  degree p \\<noteq> 1\n\ngoal (1 subgoal):\n 1. 2 \\<le> degree p", "by auto"], ["proof (state)\nthis:\n  2 \\<le> degree p\n\ngoal (1 subgoal):\n 1. degree p \\<noteq> 1 \\<Longrightarrow> irreducible\\<^sub>d p", "with kronecker_factorization_main_complete[OF divisors_fun_int divisors_pos_fun_int kf[unfolded d] this]"], ["proof (chain)\npicking this:\n  \\<nexists>q.\n     1 \\<le> degree q \\<and> degree q \\<le> degree p div 2 \\<and> q dvd p\n  2 \\<le> degree p", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<nexists>q.\n     1 \\<le> degree q \\<and> degree q \\<le> degree p div 2 \\<and> q dvd p\n  2 \\<le> degree p\n\ngoal (1 subgoal):\n 1. irreducible\\<^sub>d p", "by (intro irreducible\\<^sub>dI2, auto)"], ["proof (state)\nthis:\n  irreducible\\<^sub>d p\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  irreducible\\<^sub>d p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma kronecker_factorization_rat:\n  \"kronecker_factorization_rat p = Some q \\<Longrightarrow> \n    degree q \\<ge> 1 \\<and> degree q < degree p \\<and> q dvd p\"\n  \"kronecker_factorization_rat p = None \\<Longrightarrow> degree p \\<ge> 1 \\<Longrightarrow> irreducible\\<^sub>d p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (kronecker_factorization_rat p = Some q \\<Longrightarrow>\n     1 \\<le> degree q \\<and> degree q < degree p \\<and> q dvd p) &&&\n    (\\<lbrakk>kronecker_factorization_rat p = None;\n      1 \\<le> degree p\\<rbrakk>\n     \\<Longrightarrow> irreducible\\<^sub>d p)", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. kronecker_factorization_rat p = Some q \\<Longrightarrow>\n    1 \\<le> degree q \\<and> degree q < degree p \\<and> q dvd p\n 2. \\<lbrakk>kronecker_factorization_rat p = None; 1 \\<le> degree p\\<rbrakk>\n    \\<Longrightarrow> irreducible\\<^sub>d p", "note d = kronecker_factorization_rat_def"], ["proof (state)\nthis:\n  kronecker_factorization_rat ?p =\n  kronecker_factorization_rat_main divisors_int divisors_int_pos\n   (degree ?p div 2) ?p\n\ngoal (2 subgoals):\n 1. kronecker_factorization_rat p = Some q \\<Longrightarrow>\n    1 \\<le> degree q \\<and> degree q < degree p \\<and> q dvd p\n 2. \\<lbrakk>kronecker_factorization_rat p = None; 1 \\<le> degree p\\<rbrakk>\n    \\<Longrightarrow> irreducible\\<^sub>d p", "{"], ["proof (state)\nthis:\n  kronecker_factorization_rat ?p =\n  kronecker_factorization_rat_main divisors_int divisors_int_pos\n   (degree ?p div 2) ?p\n\ngoal (2 subgoals):\n 1. kronecker_factorization_rat p = Some q \\<Longrightarrow>\n    1 \\<le> degree q \\<and> degree q < degree p \\<and> q dvd p\n 2. \\<lbrakk>kronecker_factorization_rat p = None; 1 \\<le> degree p\\<rbrakk>\n    \\<Longrightarrow> irreducible\\<^sub>d p", "assume \"kronecker_factorization_rat p = Some q\""], ["proof (state)\nthis:\n  kronecker_factorization_rat p = Some q\n\ngoal (2 subgoals):\n 1. kronecker_factorization_rat p = Some q \\<Longrightarrow>\n    1 \\<le> degree q \\<and> degree q < degree p \\<and> q dvd p\n 2. \\<lbrakk>kronecker_factorization_rat p = None; 1 \\<le> degree p\\<rbrakk>\n    \\<Longrightarrow> irreducible\\<^sub>d p", "from kronecker_factorization_rat_main_sound[OF this[unfolded d]]"], ["proof (chain)\npicking this:\n  (2 \\<le> degree p \\<Longrightarrow>\n   1 \\<le> degree p div 2) \\<Longrightarrow>\n  1 \\<le> degree q\n  (2 \\<le> degree p \\<Longrightarrow>\n   1 \\<le> degree p div 2) \\<Longrightarrow>\n  degree q \\<le> degree p div 2\n  (2 \\<le> degree p \\<Longrightarrow>\n   1 \\<le> degree p div 2) \\<Longrightarrow>\n  q dvd p", "show \"degree q \\<ge> 1 \\<and> degree q < degree p \\<and> q dvd p\""], ["proof (prove)\nusing this:\n  (2 \\<le> degree p \\<Longrightarrow>\n   1 \\<le> degree p div 2) \\<Longrightarrow>\n  1 \\<le> degree q\n  (2 \\<le> degree p \\<Longrightarrow>\n   1 \\<le> degree p div 2) \\<Longrightarrow>\n  degree q \\<le> degree p div 2\n  (2 \\<le> degree p \\<Longrightarrow>\n   1 \\<le> degree p div 2) \\<Longrightarrow>\n  q dvd p\n\ngoal (1 subgoal):\n 1. 1 \\<le> degree q \\<and> degree q < degree p \\<and> q dvd p", "by auto linarith"], ["proof (state)\nthis:\n  1 \\<le> degree q \\<and> degree q < degree p \\<and> q dvd p\n\ngoal (1 subgoal):\n 1. \\<lbrakk>kronecker_factorization_rat p = None; 1 \\<le> degree p\\<rbrakk>\n    \\<Longrightarrow> irreducible\\<^sub>d p", "}"], ["proof (state)\nthis:\n  kronecker_factorization_rat p = Some q \\<Longrightarrow>\n  1 \\<le> degree q \\<and> degree q < degree p \\<and> q dvd p\n\ngoal (1 subgoal):\n 1. \\<lbrakk>kronecker_factorization_rat p = None; 1 \\<le> degree p\\<rbrakk>\n    \\<Longrightarrow> irreducible\\<^sub>d p", "assume kf: \"kronecker_factorization_rat p = None\" and deg: \"degree p \\<ge> 1\""], ["proof (state)\nthis:\n  kronecker_factorization_rat p = None\n  1 \\<le> degree p\n\ngoal (1 subgoal):\n 1. \\<lbrakk>kronecker_factorization_rat p = None; 1 \\<le> degree p\\<rbrakk>\n    \\<Longrightarrow> irreducible\\<^sub>d p", "show \"irreducible\\<^sub>d p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. irreducible\\<^sub>d p", "proof (cases \"degree p = 1\")"], ["proof (state)\ngoal (2 subgoals):\n 1. degree p = 1 \\<Longrightarrow> irreducible\\<^sub>d p\n 2. degree p \\<noteq> 1 \\<Longrightarrow> irreducible\\<^sub>d p", "case True"], ["proof (state)\nthis:\n  degree p = 1\n\ngoal (2 subgoals):\n 1. degree p = 1 \\<Longrightarrow> irreducible\\<^sub>d p\n 2. degree p \\<noteq> 1 \\<Longrightarrow> irreducible\\<^sub>d p", "thus ?thesis"], ["proof (prove)\nusing this:\n  degree p = 1\n\ngoal (1 subgoal):\n 1. irreducible\\<^sub>d p", "by (rule linear_irreducible\\<^sub>d)"], ["proof (state)\nthis:\n  irreducible\\<^sub>d p\n\ngoal (1 subgoal):\n 1. degree p \\<noteq> 1 \\<Longrightarrow> irreducible\\<^sub>d p", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. degree p \\<noteq> 1 \\<Longrightarrow> irreducible\\<^sub>d p", "case False"], ["proof (state)\nthis:\n  degree p \\<noteq> 1\n\ngoal (1 subgoal):\n 1. degree p \\<noteq> 1 \\<Longrightarrow> irreducible\\<^sub>d p", "with deg"], ["proof (chain)\npicking this:\n  1 \\<le> degree p\n  degree p \\<noteq> 1", "have \"degree p \\<ge> 2\""], ["proof (prove)\nusing this:\n  1 \\<le> degree p\n  degree p \\<noteq> 1\n\ngoal (1 subgoal):\n 1. 2 \\<le> degree p", "by auto"], ["proof (state)\nthis:\n  2 \\<le> degree p\n\ngoal (1 subgoal):\n 1. degree p \\<noteq> 1 \\<Longrightarrow> irreducible\\<^sub>d p", "with kronecker_factorization_rat_main_complete[OF divisors_fun_int divisors_pos_fun_int kf[unfolded d] this]"], ["proof (chain)\npicking this:\n  \\<nexists>q.\n     1 \\<le> degree q \\<and> degree q \\<le> degree p div 2 \\<and> q dvd p\n  2 \\<le> degree p", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<nexists>q.\n     1 \\<le> degree q \\<and> degree q \\<le> degree p div 2 \\<and> q dvd p\n  2 \\<le> degree p\n\ngoal (1 subgoal):\n 1. irreducible\\<^sub>d p", "by (intro irreducible\\<^sub>dI2, auto)"], ["proof (state)\nthis:\n  irreducible\\<^sub>d p\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  irreducible\\<^sub>d p\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"]]}