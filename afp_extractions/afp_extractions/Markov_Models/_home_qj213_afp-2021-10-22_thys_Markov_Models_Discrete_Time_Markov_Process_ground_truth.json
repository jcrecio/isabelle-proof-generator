{"file_name": "/home/qj213/afp-2021-10-22/thys/Markov_Models/Discrete_Time_Markov_Process.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Markov_Models", "problem_names": ["lemma measure_eqI_PiM_sequence:\n  fixes M :: \"nat \\<Rightarrow> 'a measure\"\n  assumes *[simp]: \"sets P = PiM UNIV M\" \"sets Q = PiM UNIV M\"\n  assumes eq: \"\\<And>A n. (\\<And>i. A i \\<in> sets (M i)) \\<Longrightarrow>\n    P (prod_emb UNIV M {..n} (Pi\\<^sub>E {..n} A)) = Q (prod_emb UNIV M {..n} (Pi\\<^sub>E {..n} A))\"\n  assumes A: \"finite_measure P\"\n  shows \"P = Q\"", "lemma distr_cong_simp:\n  \"M = K \\<Longrightarrow> sets N = sets L \\<Longrightarrow> (\\<And>x. x \\<in> space M =simp=> f x = g x) \\<Longrightarrow> distr M N f = distr K L g\"", "lemma space_K: \"x \\<in> space M \\<Longrightarrow> space (K x) = space M\"", "lemma sets_K[measurable_cong]: \"x \\<in> space M \\<Longrightarrow> sets (K x) = sets M\"", "lemma prob_space_K: \"x \\<in> space M \\<Longrightarrow> prob_space (K x)\"", "lemma IT_K':\n  assumes x: \"x \\<in> space M\" shows \"Ionescu_Tulcea (K' x) (\\<lambda>_. M)\"", "lemma\n  assumes x: \"x \\<in> space M\"\n  shows space_lim_sequence: \"space (lim_sequence x) = space (\\<Pi>\\<^sub>M i\\<in>UNIV. M)\"\n    and sets_lim_sequence[measurable_cong]: \"sets (lim_sequence x) = sets (\\<Pi>\\<^sub>M i\\<in>UNIV. M)\"\n    and emeasure_lim_sequence_emb: \"\\<And>J X. finite J \\<Longrightarrow> X \\<in> sets (\\<Pi>\\<^sub>M j\\<in>J. M) \\<Longrightarrow>\n      emeasure (lim_sequence x) (prod_emb UNIV (\\<lambda>_. M) J X) =\n      emeasure (Ionescu_Tulcea.CI (K' x) (\\<lambda>_. M) J) X\"\n    and emeasure_lim_sequence_emb_I0o: \"\\<And>n X. X \\<in> sets (\\<Pi>\\<^sub>M i \\<in> {0..<n}. M) \\<Longrightarrow>\n      emeasure (lim_sequence x) (prod_emb UNIV (\\<lambda>_. M) {0..<n} X) =\n      emeasure (Ionescu_Tulcea.C (K' x) (\\<lambda>_. M) 0 n (\\<lambda>x. undefined)) X\"", "lemma lim_sequence[measurable]: \"lim_sequence \\<in> M \\<rightarrow>\\<^sub>M prob_algebra (\\<Pi>\\<^sub>M i\\<in>UNIV. M)\"", "lemma step_C:\n  assumes x: \"x \\<in> space M\"\n  shows \"Ionescu_Tulcea.C (K' x) (\\<lambda>_. M) 0 1 (\\<lambda>_. undefined) \\<bind> Ionescu_Tulcea.C (K' x) (\\<lambda>_. M) 1 n =\n    K x \\<bind> (\\<lambda>y. Ionescu_Tulcea.C (K' x) (\\<lambda>_. M) 1 n (case_nat y (\\<lambda>_. undefined)))\"", "lemma lim_sequence_eq:\n  assumes x: \"x \\<in> space M\"\n  shows \"lim_sequence x = bind (K x) (\\<lambda>y. distr (lim_sequence y) (\\<Pi>\\<^sub>M j\\<in>UNIV. M) (case_nat y))\"\n    (is \"_ = ?B x\")", "lemma AE_lim_sequence:\n  assumes x[simp]: \"x \\<in> space M\" and P[measurable]: \"Measurable.pred (\\<Pi>\\<^sub>M i\\<in>UNIV. M) P\"\n  shows \"(AE \\<omega> in lim_sequence x. P \\<omega>) \\<longleftrightarrow> (AE y in K x. AE \\<omega> in lim_sequence y. P (case_nat y \\<omega>))\"", "lemma space_lim_stream: \"space (lim_stream x) = streams (space M)\"", "lemma sets_lim_stream[measurable_cong]: \"sets (lim_stream x) = sets (stream_space M)\"", "lemma lim_stream[measurable]: \"lim_stream \\<in> M \\<rightarrow>\\<^sub>M prob_algebra (stream_space M)\"", "lemma space_stream_space_M_ne: \"x \\<in> space M \\<Longrightarrow> space (stream_space M) \\<noteq> {}\"", "lemma prob_space_lim_stream: \"x \\<in> space M \\<Longrightarrow> prob_space (lim_stream x)\"", "lemma lim_stream_eq:\n  assumes x: \"x \\<in> space M\"\n  shows \"lim_stream x = do { y \\<leftarrow> K x; \\<omega> \\<leftarrow> lim_stream y; return (stream_space M) (y ## \\<omega>) }\"", "lemma AE_lim_stream:\n  assumes x[simp]: \"x \\<in> space M\" and P[measurable]: \"Measurable.pred (stream_space M) P\"\n  shows \"(AE \\<omega> in lim_stream x. P \\<omega>) \\<longleftrightarrow> (AE y in K x. AE \\<omega> in lim_stream y. P (y ## \\<omega>))\"", "lemma emeasure_lim_stream:\n  assumes x[measurable, simp]: \"x \\<in> space M\" and A[measurable, simp]: \"A \\<in> sets (stream_space M)\"\n  shows \"lim_stream x A = (\\<integral>\\<^sup>+y. emeasure (lim_stream y) (((##) y) -` A \\<inter> space (stream_space M)) \\<partial>K x)\"", "lemma lim_stream_eq_coinduct[case_names in_space step]:\n  fixes R :: \"'a \\<Rightarrow> 'a stream measure \\<Rightarrow> bool\"\n  assumes x: \"R x B\" \"x \\<in> space M\"\n  assumes R: \"\\<And>x B. R x B \\<Longrightarrow> \\<exists>B'\\<in>M \\<rightarrow>\\<^sub>M prob_algebra (stream_space M).\n    (AE y in K x. R y (B' y) \\<or> lim_stream y = B' y) \\<and>\n    B = do { y \\<leftarrow> K x; \\<omega> \\<leftarrow> B' y; return (stream_space M) (y ## \\<omega>) }\"\n  shows \"lim_stream x = B\"", "lemma prob_space_lim_sequence: \"x \\<in> space M \\<Longrightarrow> prob_space (lim_sequence x)\"", "lemma measurable_stream_filtration1: \"enat i \\<le> n \\<Longrightarrow> (\\<lambda>\\<omega>. \\<omega> !! i) \\<in> stream_filtration M n \\<rightarrow>\\<^sub>M M\"", "lemma measurable_stream_filtration2:\n  \"f \\<in> space N \\<rightarrow> streams (space M) \\<Longrightarrow> (\\<And>i. enat i \\<le> n \\<Longrightarrow> (\\<lambda>x. f x !! i) \\<in> N \\<rightarrow>\\<^sub>M M) \\<Longrightarrow> f \\<in> N \\<rightarrow>\\<^sub>M stream_filtration M n\"", "lemma space_stream_filtration: \"space (stream_filtration M n) = space (stream_space M)\"", "lemma sets_stream_filteration_le_stream_space: \"sets (stream_filtration M n) \\<subseteq> sets (stream_space M)\"", "lemma measurable_stopping_time_stream:\n  \"stopping_time (stream_filtration M) T \\<Longrightarrow> T \\<in> stream_space M \\<rightarrow>\\<^sub>M count_space UNIV\"", "lemma measurable_stopping_time_All_eq_0:\n  assumes T: \"stopping_time (stream_filtration M) T\"\n  shows \"{x\\<in>space M. \\<forall>\\<omega>\\<in>streams (space M). T (x ## \\<omega>) = 0} \\<in> sets M\"", "lemma stopping_time_0:\n  assumes T: \"stopping_time (stream_filtration M) T\"\n    and x: \"x \\<in> space M\" and \\<omega>: \"\\<omega> \\<in> streams (space M)\" \"T (x ## \\<omega>) > 0\"\n    and \\<omega>': \"\\<omega>' \\<in> streams (space M)\"\n  shows \"T (x ## \\<omega>') > 0\"", "lemma stopping_time_epred_SCons:\n  assumes T: \"stopping_time (stream_filtration M) T\"\n    and x: \"x \\<in> space M\" and \\<omega>: \"\\<omega> \\<in> streams (space M)\" \"T (x ## \\<omega>) > 0\"\n  shows \"stopping_time (stream_filtration M) (\\<lambda>\\<omega>. epred (T (x ## \\<omega>)))\"", "lemma lim_stream_strong_Markov:\n  assumes x: \"x \\<in> space M\" and T: \"stopping_time (stream_filtration M) T\"\n  shows \"lim_stream x =\n    lim_stream x \\<bind> (\\<lambda>\\<omega>. case T \\<omega> of\n      enat i \\<Rightarrow> distr (lim_stream (\\<omega> !! i)) (stream_space M) (\\<lambda>\\<omega>'. stake (Suc i) \\<omega> @- \\<omega>')\n    | \\<infinity>     \\<Rightarrow> return (stream_space M) \\<omega>)\"\n  (is \"_ = ?L T x\")"], "translations": [["", "lemma measure_eqI_PiM_sequence:\n  fixes M :: \"nat \\<Rightarrow> 'a measure\"\n  assumes *[simp]: \"sets P = PiM UNIV M\" \"sets Q = PiM UNIV M\"\n  assumes eq: \"\\<And>A n. (\\<And>i. A i \\<in> sets (M i)) \\<Longrightarrow>\n    P (prod_emb UNIV M {..n} (Pi\\<^sub>E {..n} A)) = Q (prod_emb UNIV M {..n} (Pi\\<^sub>E {..n} A))\"\n  assumes A: \"finite_measure P\"\n  shows \"P = Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P = Q", "proof (rule measure_eqI_PiM_infinite[OF * _ A])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>A J.\n       \\<lbrakk>finite J; J \\<subseteq> UNIV;\n        \\<And>i. i \\<in> J \\<Longrightarrow> A i \\<in> sets (M i)\\<rbrakk>\n       \\<Longrightarrow> emeasure P (prod_emb UNIV M J (Pi\\<^sub>E J A)) =\n                         emeasure Q (prod_emb UNIV M J (Pi\\<^sub>E J A))", "fix J :: \"nat set\" and F'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>A J.\n       \\<lbrakk>finite J; J \\<subseteq> UNIV;\n        \\<And>i. i \\<in> J \\<Longrightarrow> A i \\<in> sets (M i)\\<rbrakk>\n       \\<Longrightarrow> emeasure P (prod_emb UNIV M J (Pi\\<^sub>E J A)) =\n                         emeasure Q (prod_emb UNIV M J (Pi\\<^sub>E J A))", "assume J: \"finite J\" \"\\<And>i. i \\<in> J \\<Longrightarrow> F' i \\<in> sets (M i)\""], ["proof (state)\nthis:\n  finite J\n  ?i \\<in> J \\<Longrightarrow> F' ?i \\<in> sets (M ?i)\n\ngoal (1 subgoal):\n 1. \\<And>A J.\n       \\<lbrakk>finite J; J \\<subseteq> UNIV;\n        \\<And>i. i \\<in> J \\<Longrightarrow> A i \\<in> sets (M i)\\<rbrakk>\n       \\<Longrightarrow> emeasure P (prod_emb UNIV M J (Pi\\<^sub>E J A)) =\n                         emeasure Q (prod_emb UNIV M J (Pi\\<^sub>E J A))", "define n where \"n = (if J = {} then 0 else Max J)\""], ["proof (state)\nthis:\n  n = (if J = {} then 0 else Max J)\n\ngoal (1 subgoal):\n 1. \\<And>A J.\n       \\<lbrakk>finite J; J \\<subseteq> UNIV;\n        \\<And>i. i \\<in> J \\<Longrightarrow> A i \\<in> sets (M i)\\<rbrakk>\n       \\<Longrightarrow> emeasure P (prod_emb UNIV M J (Pi\\<^sub>E J A)) =\n                         emeasure Q (prod_emb UNIV M J (Pi\\<^sub>E J A))", "define F where \"F i = (if i \\<in> J then F' i else space (M i))\" for i"], ["proof (state)\nthis:\n  F ?i = (if ?i \\<in> J then F' ?i else space (M ?i))\n\ngoal (1 subgoal):\n 1. \\<And>A J.\n       \\<lbrakk>finite J; J \\<subseteq> UNIV;\n        \\<And>i. i \\<in> J \\<Longrightarrow> A i \\<in> sets (M i)\\<rbrakk>\n       \\<Longrightarrow> emeasure P (prod_emb UNIV M J (Pi\\<^sub>E J A)) =\n                         emeasure Q (prod_emb UNIV M J (Pi\\<^sub>E J A))", "then"], ["proof (chain)\npicking this:\n  F ?i = (if ?i \\<in> J then F' ?i else space (M ?i))", "have F[simp, measurable]: \"F i \\<in> sets (M i)\" for i"], ["proof (prove)\nusing this:\n  F ?i = (if ?i \\<in> J then F' ?i else space (M ?i))\n\ngoal (1 subgoal):\n 1. F i \\<in> sets (M i)", "using J"], ["proof (prove)\nusing this:\n  F ?i = (if ?i \\<in> J then F' ?i else space (M ?i))\n  finite J\n  ?i \\<in> J \\<Longrightarrow> F' ?i \\<in> sets (M ?i)\n\ngoal (1 subgoal):\n 1. F i \\<in> sets (M i)", "by auto"], ["proof (state)\nthis:\n  F ?i \\<in> sets (M ?i)\n\ngoal (1 subgoal):\n 1. \\<And>A J.\n       \\<lbrakk>finite J; J \\<subseteq> UNIV;\n        \\<And>i. i \\<in> J \\<Longrightarrow> A i \\<in> sets (M i)\\<rbrakk>\n       \\<Longrightarrow> emeasure P (prod_emb UNIV M J (Pi\\<^sub>E J A)) =\n                         emeasure Q (prod_emb UNIV M J (Pi\\<^sub>E J A))", "have emb_eq: \"prod_emb UNIV M J (Pi\\<^sub>E J F') = prod_emb UNIV M {..n} (Pi\\<^sub>E {..n} F)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod_emb UNIV M J (Pi\\<^sub>E J F') =\n    prod_emb UNIV M {..n} (Pi\\<^sub>E {..n} F)", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    prod_emb UNIV M J (Pi\\<^sub>E J F') =\n    prod_emb UNIV M {..n} (Pi\\<^sub>E {..n} F)\n 2. \\<not> ?P \\<Longrightarrow>\n    prod_emb UNIV M J (Pi\\<^sub>E J F') =\n    prod_emb UNIV M {..n} (Pi\\<^sub>E {..n} F)", "assume \"J = {}\""], ["proof (state)\nthis:\n  J = {}\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    prod_emb UNIV M J (Pi\\<^sub>E J F') =\n    prod_emb UNIV M {..n} (Pi\\<^sub>E {..n} F)\n 2. \\<not> ?P \\<Longrightarrow>\n    prod_emb UNIV M J (Pi\\<^sub>E J F') =\n    prod_emb UNIV M {..n} (Pi\\<^sub>E {..n} F)", "then"], ["proof (chain)\npicking this:\n  J = {}", "show ?thesis"], ["proof (prove)\nusing this:\n  J = {}\n\ngoal (1 subgoal):\n 1. prod_emb UNIV M J (Pi\\<^sub>E J F') =\n    prod_emb UNIV M {..n} (Pi\\<^sub>E {..n} F)", "by (auto simp add: n_def F_def[abs_def] prod_emb_def PiE_def)"], ["proof (state)\nthis:\n  prod_emb UNIV M J (Pi\\<^sub>E J F') =\n  prod_emb UNIV M {..n} (Pi\\<^sub>E {..n} F)\n\ngoal (1 subgoal):\n 1. J \\<noteq> {} \\<Longrightarrow>\n    prod_emb UNIV M J (Pi\\<^sub>E J F') =\n    prod_emb UNIV M {..n} (Pi\\<^sub>E {..n} F)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. J \\<noteq> {} \\<Longrightarrow>\n    prod_emb UNIV M J (Pi\\<^sub>E J F') =\n    prod_emb UNIV M {..n} (Pi\\<^sub>E {..n} F)", "assume \"J \\<noteq> {}\""], ["proof (state)\nthis:\n  J \\<noteq> {}\n\ngoal (1 subgoal):\n 1. J \\<noteq> {} \\<Longrightarrow>\n    prod_emb UNIV M J (Pi\\<^sub>E J F') =\n    prod_emb UNIV M {..n} (Pi\\<^sub>E {..n} F)", "then"], ["proof (chain)\npicking this:\n  J \\<noteq> {}", "show ?thesis"], ["proof (prove)\nusing this:\n  J \\<noteq> {}\n\ngoal (1 subgoal):\n 1. prod_emb UNIV M J (Pi\\<^sub>E J F') =\n    prod_emb UNIV M {..n} (Pi\\<^sub>E {..n} F)", "by (auto simp: prod_emb_def PiE_iff F_def n_def less_Suc_eq_le \\<open>finite J\\<close> split: if_split_asm)"], ["proof (state)\nthis:\n  prod_emb UNIV M J (Pi\\<^sub>E J F') =\n  prod_emb UNIV M {..n} (Pi\\<^sub>E {..n} F)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  prod_emb UNIV M J (Pi\\<^sub>E J F') =\n  prod_emb UNIV M {..n} (Pi\\<^sub>E {..n} F)\n\ngoal (1 subgoal):\n 1. \\<And>A J.\n       \\<lbrakk>finite J; J \\<subseteq> UNIV;\n        \\<And>i. i \\<in> J \\<Longrightarrow> A i \\<in> sets (M i)\\<rbrakk>\n       \\<Longrightarrow> emeasure P (prod_emb UNIV M J (Pi\\<^sub>E J A)) =\n                         emeasure Q (prod_emb UNIV M J (Pi\\<^sub>E J A))", "show \"emeasure P (prod_emb UNIV M J (Pi\\<^sub>E J F')) = emeasure Q (prod_emb UNIV M J (Pi\\<^sub>E J F'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure P (prod_emb UNIV M J (Pi\\<^sub>E J F')) =\n    emeasure Q (prod_emb UNIV M J (Pi\\<^sub>E J F'))", "unfolding emb_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure P (prod_emb UNIV M {..n} (Pi\\<^sub>E {..n} F)) =\n    emeasure Q (prod_emb UNIV M {..n} (Pi\\<^sub>E {..n} F))", "by (rule eq) fact"], ["proof (state)\nthis:\n  emeasure P (prod_emb UNIV M J (Pi\\<^sub>E J F')) =\n  emeasure Q (prod_emb UNIV M J (Pi\\<^sub>E J F'))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma distr_cong_simp:\n  \"M = K \\<Longrightarrow> sets N = sets L \\<Longrightarrow> (\\<And>x. x \\<in> space M =simp=> f x = g x) \\<Longrightarrow> distr M N f = distr K L g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>M = K; sets N = sets L;\n     \\<And>x. x \\<in> space M =simp=> f x = g x\\<rbrakk>\n    \\<Longrightarrow> distr M N f = distr K L g", "unfolding simp_implies_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>M = K; sets N = sets L;\n     \\<And>x. x \\<in> space M \\<Longrightarrow> f x = g x\\<rbrakk>\n    \\<Longrightarrow> distr M N f = distr K L g", "by (rule distr_cong)"], ["", "subsection \\<open>Constructing Discrete-Time Markov Processes\\<close>"], ["", "locale discrete_Markov_process =\n  fixes M :: \"'a measure\" and K :: \"'a \\<Rightarrow> 'a measure\"\n  assumes K[measurable]: \"K \\<in> M \\<rightarrow>\\<^sub>M prob_algebra M\"\nbegin"], ["", "lemma space_K: \"x \\<in> space M \\<Longrightarrow> space (K x) = space M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> space M \\<Longrightarrow> space (K x) = space M", "using K"], ["proof (prove)\nusing this:\n  K \\<in> M \\<rightarrow>\\<^sub>M prob_algebra M\n\ngoal (1 subgoal):\n 1. x \\<in> space M \\<Longrightarrow> space (K x) = space M", "unfolding prob_algebra_def"], ["proof (prove)\nusing this:\n  K \\<in> M \\<rightarrow>\\<^sub>M\n          restrict_space (subprob_algebra M) (Collect prob_space)\n\ngoal (1 subgoal):\n 1. x \\<in> space M \\<Longrightarrow> space (K x) = space M", "unfolding measurable_restrict_space2_iff"], ["proof (prove)\nusing this:\n  K \\<in> M \\<rightarrow>\\<^sub>M subprob_algebra M \\<and>\n  K \\<in> space M \\<rightarrow> Collect prob_space\n\ngoal (1 subgoal):\n 1. x \\<in> space M \\<Longrightarrow> space (K x) = space M", "by (auto dest: subprob_measurableD)"], ["", "lemma sets_K[measurable_cong]: \"x \\<in> space M \\<Longrightarrow> sets (K x) = sets M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> space M \\<Longrightarrow> sets (K x) = sets M", "using K"], ["proof (prove)\nusing this:\n  K \\<in> M \\<rightarrow>\\<^sub>M prob_algebra M\n\ngoal (1 subgoal):\n 1. x \\<in> space M \\<Longrightarrow> sets (K x) = sets M", "unfolding prob_algebra_def"], ["proof (prove)\nusing this:\n  K \\<in> M \\<rightarrow>\\<^sub>M\n          restrict_space (subprob_algebra M) (Collect prob_space)\n\ngoal (1 subgoal):\n 1. x \\<in> space M \\<Longrightarrow> sets (K x) = sets M", "unfolding measurable_restrict_space2_iff"], ["proof (prove)\nusing this:\n  K \\<in> M \\<rightarrow>\\<^sub>M subprob_algebra M \\<and>\n  K \\<in> space M \\<rightarrow> Collect prob_space\n\ngoal (1 subgoal):\n 1. x \\<in> space M \\<Longrightarrow> sets (K x) = sets M", "by (auto dest: subprob_measurableD)"], ["", "lemma prob_space_K: \"x \\<in> space M \\<Longrightarrow> prob_space (K x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> space M \\<Longrightarrow> prob_space (K x)", "using measurable_space[OF K]"], ["proof (prove)\nusing this:\n  ?x \\<in> space M \\<Longrightarrow> K ?x \\<in> space (prob_algebra M)\n\ngoal (1 subgoal):\n 1. x \\<in> space M \\<Longrightarrow> prob_space (K x)", "by (simp add: space_prob_algebra)"], ["", "definition K' :: \"'a \\<Rightarrow> nat \\<Rightarrow> (nat \\<Rightarrow> 'a) \\<Rightarrow> 'a measure\"\nwhere\n  \"K' x n' \\<omega>' = K (case_nat x \\<omega>' n')\""], ["", "lemma IT_K':\n  assumes x: \"x \\<in> space M\" shows \"Ionescu_Tulcea (K' x) (\\<lambda>_. M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ionescu_Tulcea (K' x) (\\<lambda>_. M)", "unfolding Ionescu_Tulcea_def K'_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>i.\n        (\\<lambda>\\<omega>'.\n            K (case i of 0 \\<Rightarrow> x\n               | Suc x \\<Rightarrow> \\<omega>' x))\n        \\<in> Pi\\<^sub>M {0..<i} (\\<lambda>_. M) \\<rightarrow>\\<^sub>M\n              subprob_algebra M) \\<and>\n    (\\<forall>i xa.\n        xa \\<in> space\n                  (Pi\\<^sub>M {0..<i} (\\<lambda>_. M)) \\<longrightarrow>\n        prob_space\n         (K (case i of 0 \\<Rightarrow> x | Suc x \\<Rightarrow> xa x)))", "proof safe"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i.\n       (\\<lambda>\\<omega>'.\n           K (case i of 0 \\<Rightarrow> x\n              | Suc x \\<Rightarrow> \\<omega>' x))\n       \\<in> Pi\\<^sub>M {0..<i} (\\<lambda>_. M) \\<rightarrow>\\<^sub>M\n             subprob_algebra M\n 2. \\<And>i xa.\n       xa \\<in> space (Pi\\<^sub>M {0..<i} (\\<lambda>_. M)) \\<Longrightarrow>\n       prob_space\n        (K (case i of 0 \\<Rightarrow> x | Suc x \\<Rightarrow> xa x))", "fix i"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i.\n       (\\<lambda>\\<omega>'.\n           K (case i of 0 \\<Rightarrow> x\n              | Suc x \\<Rightarrow> \\<omega>' x))\n       \\<in> Pi\\<^sub>M {0..<i} (\\<lambda>_. M) \\<rightarrow>\\<^sub>M\n             subprob_algebra M\n 2. \\<And>i xa.\n       xa \\<in> space (Pi\\<^sub>M {0..<i} (\\<lambda>_. M)) \\<Longrightarrow>\n       prob_space\n        (K (case i of 0 \\<Rightarrow> x | Suc x \\<Rightarrow> xa x))", "show \"(\\<lambda>\\<omega>'. K (case i of 0 \\<Rightarrow> x | Suc x \\<Rightarrow> \\<omega>' x)) \\<in> Pi\\<^sub>M {0..<i} (\\<lambda>_. M) \\<rightarrow>\\<^sub>M subprob_algebra M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>\\<omega>'.\n        K (case i of 0 \\<Rightarrow> x | Suc x \\<Rightarrow> \\<omega>' x))\n    \\<in> Pi\\<^sub>M {0..<i} (\\<lambda>_. M) \\<rightarrow>\\<^sub>M\n          subprob_algebra M", "using x"], ["proof (prove)\nusing this:\n  x \\<in> space M\n\ngoal (1 subgoal):\n 1. (\\<lambda>\\<omega>'.\n        K (case i of 0 \\<Rightarrow> x | Suc x \\<Rightarrow> \\<omega>' x))\n    \\<in> Pi\\<^sub>M {0..<i} (\\<lambda>_. M) \\<rightarrow>\\<^sub>M\n          subprob_algebra M", "by (intro measurable_prob_algebraD measurable_compose[OF _ K]) measurable"], ["proof (state)\nthis:\n  (\\<lambda>\\<omega>'.\n      K (case i of 0 \\<Rightarrow> x | Suc x \\<Rightarrow> \\<omega>' x))\n  \\<in> Pi\\<^sub>M {0..<i} (\\<lambda>_. M) \\<rightarrow>\\<^sub>M\n        subprob_algebra M\n\ngoal (1 subgoal):\n 1. \\<And>i xa.\n       xa \\<in> space (Pi\\<^sub>M {0..<i} (\\<lambda>_. M)) \\<Longrightarrow>\n       prob_space\n        (K (case i of 0 \\<Rightarrow> x | Suc x \\<Rightarrow> xa x))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i xa.\n       xa \\<in> space (Pi\\<^sub>M {0..<i} (\\<lambda>_. M)) \\<Longrightarrow>\n       prob_space\n        (K (case i of 0 \\<Rightarrow> x | Suc x \\<Rightarrow> xa x))", "fix i :: nat and \\<omega>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i xa.\n       xa \\<in> space (Pi\\<^sub>M {0..<i} (\\<lambda>_. M)) \\<Longrightarrow>\n       prob_space\n        (K (case i of 0 \\<Rightarrow> x | Suc x \\<Rightarrow> xa x))", "assume \\<omega>: \"\\<omega> \\<in> space (Pi\\<^sub>M {0..<i} (\\<lambda>_. M))\""], ["proof (state)\nthis:\n  \\<omega> \\<in> space (Pi\\<^sub>M {0..<i} (\\<lambda>_. M))\n\ngoal (1 subgoal):\n 1. \\<And>i xa.\n       xa \\<in> space (Pi\\<^sub>M {0..<i} (\\<lambda>_. M)) \\<Longrightarrow>\n       prob_space\n        (K (case i of 0 \\<Rightarrow> x | Suc x \\<Rightarrow> xa x))", "with x"], ["proof (chain)\npicking this:\n  x \\<in> space M\n  \\<omega> \\<in> space (Pi\\<^sub>M {0..<i} (\\<lambda>_. M))", "have \"(case i of 0 \\<Rightarrow> x | Suc x \\<Rightarrow> \\<omega> x) \\<in> space M\""], ["proof (prove)\nusing this:\n  x \\<in> space M\n  \\<omega> \\<in> space (Pi\\<^sub>M {0..<i} (\\<lambda>_. M))\n\ngoal (1 subgoal):\n 1. (case i of 0 \\<Rightarrow> x | Suc x \\<Rightarrow> \\<omega> x)\n    \\<in> space M", "by (auto simp: space_PiM split: nat.split)"], ["proof (state)\nthis:\n  (case i of 0 \\<Rightarrow> x | Suc x \\<Rightarrow> \\<omega> x)\n  \\<in> space M\n\ngoal (1 subgoal):\n 1. \\<And>i xa.\n       xa \\<in> space (Pi\\<^sub>M {0..<i} (\\<lambda>_. M)) \\<Longrightarrow>\n       prob_space\n        (K (case i of 0 \\<Rightarrow> x | Suc x \\<Rightarrow> xa x))", "then"], ["proof (chain)\npicking this:\n  (case i of 0 \\<Rightarrow> x | Suc x \\<Rightarrow> \\<omega> x)\n  \\<in> space M", "show \"prob_space (K (case i of 0 \\<Rightarrow> x | Suc x \\<Rightarrow> \\<omega> x))\""], ["proof (prove)\nusing this:\n  (case i of 0 \\<Rightarrow> x | Suc x \\<Rightarrow> \\<omega> x)\n  \\<in> space M\n\ngoal (1 subgoal):\n 1. prob_space\n     (K (case i of 0 \\<Rightarrow> x | Suc x \\<Rightarrow> \\<omega> x))", "using K"], ["proof (prove)\nusing this:\n  (case i of 0 \\<Rightarrow> x | Suc x \\<Rightarrow> \\<omega> x)\n  \\<in> space M\n  K \\<in> M \\<rightarrow>\\<^sub>M prob_algebra M\n\ngoal (1 subgoal):\n 1. prob_space\n     (K (case i of 0 \\<Rightarrow> x | Suc x \\<Rightarrow> \\<omega> x))", "unfolding measurable_restrict_space2_iff prob_algebra_def"], ["proof (prove)\nusing this:\n  (case i of 0 \\<Rightarrow> x | Suc x \\<Rightarrow> \\<omega> x)\n  \\<in> space M\n  K \\<in> M \\<rightarrow>\\<^sub>M subprob_algebra M \\<and>\n  K \\<in> space M \\<rightarrow> Collect prob_space\n\ngoal (1 subgoal):\n 1. prob_space\n     (K (case i of 0 \\<Rightarrow> x | Suc x \\<Rightarrow> \\<omega> x))", "by auto"], ["proof (state)\nthis:\n  prob_space\n   (K (case i of 0 \\<Rightarrow> x | Suc x \\<Rightarrow> \\<omega> x))\n\ngoal:\nNo subgoals!", "qed"], ["", "definition lim_sequence :: \"'a \\<Rightarrow> (nat \\<Rightarrow> 'a) measure\"\nwhere\n  \"lim_sequence x = projective_family.lim UNIV (Ionescu_Tulcea.CI (K' x) (\\<lambda>_. M)) (\\<lambda>_. M)\""], ["", "lemma\n  assumes x: \"x \\<in> space M\"\n  shows space_lim_sequence: \"space (lim_sequence x) = space (\\<Pi>\\<^sub>M i\\<in>UNIV. M)\"\n    and sets_lim_sequence[measurable_cong]: \"sets (lim_sequence x) = sets (\\<Pi>\\<^sub>M i\\<in>UNIV. M)\"\n    and emeasure_lim_sequence_emb: \"\\<And>J X. finite J \\<Longrightarrow> X \\<in> sets (\\<Pi>\\<^sub>M j\\<in>J. M) \\<Longrightarrow>\n      emeasure (lim_sequence x) (prod_emb UNIV (\\<lambda>_. M) J X) =\n      emeasure (Ionescu_Tulcea.CI (K' x) (\\<lambda>_. M) J) X\"\n    and emeasure_lim_sequence_emb_I0o: \"\\<And>n X. X \\<in> sets (\\<Pi>\\<^sub>M i \\<in> {0..<n}. M) \\<Longrightarrow>\n      emeasure (lim_sequence x) (prod_emb UNIV (\\<lambda>_. M) {0..<n} X) =\n      emeasure (Ionescu_Tulcea.C (K' x) (\\<lambda>_. M) 0 n (\\<lambda>x. undefined)) X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (space (lim_sequence x) = space (Pi\\<^sub>M UNIV (\\<lambda>i. M)) &&&\n     sets (lim_sequence x) = sets (Pi\\<^sub>M UNIV (\\<lambda>i. M))) &&&\n    (\\<And>J X.\n        \\<lbrakk>finite J;\n         X \\<in> sets (Pi\\<^sub>M J (\\<lambda>j. M))\\<rbrakk>\n        \\<Longrightarrow> emeasure (lim_sequence x)\n                           (prod_emb UNIV (\\<lambda>_. M) J X) =\n                          emeasure\n                           (Ionescu_Tulcea.CI (K' x) (\\<lambda>_. M) J)\n                           X) &&&\n    (\\<And>n X.\n        X \\<in> sets (Pi\\<^sub>M {0..<n} (\\<lambda>i. M)) \\<Longrightarrow>\n        emeasure (lim_sequence x)\n         (prod_emb UNIV (\\<lambda>_. M) {0..<n} X) =\n        emeasure\n         (Ionescu_Tulcea.C (K' x) (\\<lambda>_. M) 0 n\n           (\\<lambda>x. undefined))\n         X)", "proof -"], ["proof (state)\ngoal (4 subgoals):\n 1. space (lim_sequence x) = space (Pi\\<^sub>M UNIV (\\<lambda>i. M))\n 2. sets (lim_sequence x) = sets (Pi\\<^sub>M UNIV (\\<lambda>i. M))\n 3. \\<And>J X.\n       \\<lbrakk>finite J;\n        X \\<in> sets (Pi\\<^sub>M J (\\<lambda>j. M))\\<rbrakk>\n       \\<Longrightarrow> emeasure (lim_sequence x)\n                          (prod_emb UNIV (\\<lambda>_. M) J X) =\n                         emeasure\n                          (Ionescu_Tulcea.CI (K' x) (\\<lambda>_. M) J) X\n 4. \\<And>n X.\n       X \\<in> sets (Pi\\<^sub>M {0..<n} (\\<lambda>i. M)) \\<Longrightarrow>\n       emeasure (lim_sequence x) (prod_emb UNIV (\\<lambda>_. M) {0..<n} X) =\n       emeasure\n        (Ionescu_Tulcea.C (K' x) (\\<lambda>_. M) 0 n\n          (\\<lambda>x. undefined))\n        X", "interpret Ionescu_Tulcea \"K' x\" \"\\<lambda>_. M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ionescu_Tulcea (K' x) (\\<lambda>_. M)", "using x"], ["proof (prove)\nusing this:\n  x \\<in> space M\n\ngoal (1 subgoal):\n 1. Ionescu_Tulcea (K' x) (\\<lambda>_. M)", "by (rule IT_K')"], ["proof (state)\ngoal (4 subgoals):\n 1. space (lim_sequence x) = space (Pi\\<^sub>M UNIV (\\<lambda>i. M))\n 2. sets (lim_sequence x) = sets (Pi\\<^sub>M UNIV (\\<lambda>i. M))\n 3. \\<And>J X.\n       \\<lbrakk>finite J;\n        X \\<in> sets (Pi\\<^sub>M J (\\<lambda>j. M))\\<rbrakk>\n       \\<Longrightarrow> emeasure (lim_sequence x) (PF.emb UNIV J X) =\n                         emeasure (CI J) X\n 4. \\<And>n X.\n       X \\<in> sets (Pi\\<^sub>M {0..<n} (\\<lambda>i. M)) \\<Longrightarrow>\n       emeasure (lim_sequence x) (PF.emb UNIV {0..<n} X) =\n       emeasure (C 0 n (\\<lambda>x. undefined)) X", "show \"space (lim_sequence x) = space (\\<Pi>\\<^sub>M i\\<in>UNIV. M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. space (lim_sequence x) = space (Pi\\<^sub>M UNIV (\\<lambda>i. M))", "unfolding lim_sequence_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. space PF.lim = space (Pi\\<^sub>M UNIV (\\<lambda>i. M))", "by simp"], ["proof (state)\nthis:\n  space (lim_sequence x) = space (Pi\\<^sub>M UNIV (\\<lambda>i. M))\n\ngoal (3 subgoals):\n 1. sets (lim_sequence x) = sets (Pi\\<^sub>M UNIV (\\<lambda>i. M))\n 2. \\<And>J X.\n       \\<lbrakk>finite J;\n        X \\<in> sets (Pi\\<^sub>M J (\\<lambda>j. M))\\<rbrakk>\n       \\<Longrightarrow> emeasure (lim_sequence x) (PF.emb UNIV J X) =\n                         emeasure (CI J) X\n 3. \\<And>n X.\n       X \\<in> sets (Pi\\<^sub>M {0..<n} (\\<lambda>i. M)) \\<Longrightarrow>\n       emeasure (lim_sequence x) (PF.emb UNIV {0..<n} X) =\n       emeasure (C 0 n (\\<lambda>x. undefined)) X", "show \"sets (lim_sequence x) = sets (\\<Pi>\\<^sub>M i\\<in>UNIV. M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sets (lim_sequence x) = sets (Pi\\<^sub>M UNIV (\\<lambda>i. M))", "unfolding lim_sequence_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. sets PF.lim = sets (Pi\\<^sub>M UNIV (\\<lambda>i. M))", "by simp"], ["proof (state)\nthis:\n  sets (lim_sequence x) = sets (Pi\\<^sub>M UNIV (\\<lambda>i. M))\n\ngoal (2 subgoals):\n 1. \\<And>J X.\n       \\<lbrakk>finite J;\n        X \\<in> sets (Pi\\<^sub>M J (\\<lambda>j. M))\\<rbrakk>\n       \\<Longrightarrow> emeasure (lim_sequence x) (PF.emb UNIV J X) =\n                         emeasure (CI J) X\n 2. \\<And>n X.\n       X \\<in> sets (Pi\\<^sub>M {0..<n} (\\<lambda>i. M)) \\<Longrightarrow>\n       emeasure (lim_sequence x) (PF.emb UNIV {0..<n} X) =\n       emeasure (C 0 n (\\<lambda>x. undefined)) X", "{"], ["proof (state)\nthis:\n  sets (lim_sequence x) = sets (Pi\\<^sub>M UNIV (\\<lambda>i. M))\n\ngoal (2 subgoals):\n 1. \\<And>J X.\n       \\<lbrakk>finite J;\n        X \\<in> sets (Pi\\<^sub>M J (\\<lambda>j. M))\\<rbrakk>\n       \\<Longrightarrow> emeasure (lim_sequence x) (PF.emb UNIV J X) =\n                         emeasure (CI J) X\n 2. \\<And>n X.\n       X \\<in> sets (Pi\\<^sub>M {0..<n} (\\<lambda>i. M)) \\<Longrightarrow>\n       emeasure (lim_sequence x) (PF.emb UNIV {0..<n} X) =\n       emeasure (C 0 n (\\<lambda>x. undefined)) X", "fix J :: \"nat set\" and X"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>J X.\n       \\<lbrakk>finite J;\n        X \\<in> sets (Pi\\<^sub>M J (\\<lambda>j. M))\\<rbrakk>\n       \\<Longrightarrow> emeasure (lim_sequence x) (PF.emb UNIV J X) =\n                         emeasure (CI J) X\n 2. \\<And>n X.\n       X \\<in> sets (Pi\\<^sub>M {0..<n} (\\<lambda>i. M)) \\<Longrightarrow>\n       emeasure (lim_sequence x) (PF.emb UNIV {0..<n} X) =\n       emeasure (C 0 n (\\<lambda>x. undefined)) X", "assume \"finite J\" \"X \\<in> sets (\\<Pi>\\<^sub>M j\\<in>J. M)\""], ["proof (state)\nthis:\n  finite J\n  X \\<in> sets (Pi\\<^sub>M J (\\<lambda>j. M))\n\ngoal (2 subgoals):\n 1. \\<And>J X.\n       \\<lbrakk>finite J;\n        X \\<in> sets (Pi\\<^sub>M J (\\<lambda>j. M))\\<rbrakk>\n       \\<Longrightarrow> emeasure (lim_sequence x) (PF.emb UNIV J X) =\n                         emeasure (CI J) X\n 2. \\<And>n X.\n       X \\<in> sets (Pi\\<^sub>M {0..<n} (\\<lambda>i. M)) \\<Longrightarrow>\n       emeasure (lim_sequence x) (PF.emb UNIV {0..<n} X) =\n       emeasure (C 0 n (\\<lambda>x. undefined)) X", "then"], ["proof (chain)\npicking this:\n  finite J\n  X \\<in> sets (Pi\\<^sub>M J (\\<lambda>j. M))", "show \"emeasure (lim_sequence x) (PF.emb UNIV J X) = emeasure (CI J) X\""], ["proof (prove)\nusing this:\n  finite J\n  X \\<in> sets (Pi\\<^sub>M J (\\<lambda>j. M))\n\ngoal (1 subgoal):\n 1. emeasure (lim_sequence x) (PF.emb UNIV J X) = emeasure (CI J) X", "unfolding lim_sequence_def"], ["proof (prove)\nusing this:\n  finite J\n  X \\<in> sets (Pi\\<^sub>M J (\\<lambda>j. M))\n\ngoal (1 subgoal):\n 1. emeasure PF.lim (PF.emb UNIV J X) = emeasure (CI J) X", "by (rule lim)"], ["proof (state)\nthis:\n  emeasure (lim_sequence x) (PF.emb UNIV J X) = emeasure (CI J) X\n\ngoal (1 subgoal):\n 1. \\<And>n X.\n       X \\<in> sets (Pi\\<^sub>M {0..<n} (\\<lambda>i. M)) \\<Longrightarrow>\n       emeasure (lim_sequence x) (PF.emb UNIV {0..<n} X) =\n       emeasure (C 0 n (\\<lambda>x. undefined)) X", "}"], ["proof (state)\nthis:\n  \\<lbrakk>finite ?J2;\n   ?X2 \\<in> sets (Pi\\<^sub>M ?J2 (\\<lambda>j. M))\\<rbrakk>\n  \\<Longrightarrow> emeasure (lim_sequence x) (PF.emb UNIV ?J2 ?X2) =\n                    emeasure (CI ?J2) ?X2\n\ngoal (1 subgoal):\n 1. \\<And>n X.\n       X \\<in> sets (Pi\\<^sub>M {0..<n} (\\<lambda>i. M)) \\<Longrightarrow>\n       emeasure (lim_sequence x) (PF.emb UNIV {0..<n} X) =\n       emeasure (C 0 n (\\<lambda>x. undefined)) X", "note emb = this"], ["proof (state)\nthis:\n  \\<lbrakk>finite ?J2;\n   ?X2 \\<in> sets (Pi\\<^sub>M ?J2 (\\<lambda>j. M))\\<rbrakk>\n  \\<Longrightarrow> emeasure (lim_sequence x) (PF.emb UNIV ?J2 ?X2) =\n                    emeasure (CI ?J2) ?X2\n\ngoal (1 subgoal):\n 1. \\<And>n X.\n       X \\<in> sets (Pi\\<^sub>M {0..<n} (\\<lambda>i. M)) \\<Longrightarrow>\n       emeasure (lim_sequence x) (PF.emb UNIV {0..<n} X) =\n       emeasure (C 0 n (\\<lambda>x. undefined)) X", "have up_to_I0o[simp]: \"up_to {0..<n} = n\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. up_to {0..<n} = n", "unfolding up_to_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST na. \\<forall>i\\<ge>na. i \\<notin> {0..<n}) = n", "by (rule Least_equality) auto"], ["proof (state)\nthis:\n  up_to {0..<?n} = ?n\n\ngoal (1 subgoal):\n 1. \\<And>n X.\n       X \\<in> sets (Pi\\<^sub>M {0..<n} (\\<lambda>i. M)) \\<Longrightarrow>\n       emeasure (lim_sequence x) (PF.emb UNIV {0..<n} X) =\n       emeasure (C 0 n (\\<lambda>x. undefined)) X", "{"], ["proof (state)\nthis:\n  up_to {0..<?n} = ?n\n\ngoal (1 subgoal):\n 1. \\<And>n X.\n       X \\<in> sets (Pi\\<^sub>M {0..<n} (\\<lambda>i. M)) \\<Longrightarrow>\n       emeasure (lim_sequence x) (PF.emb UNIV {0..<n} X) =\n       emeasure (C 0 n (\\<lambda>x. undefined)) X", "fix n :: nat and X"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n X.\n       X \\<in> sets (Pi\\<^sub>M {0..<n} (\\<lambda>i. M)) \\<Longrightarrow>\n       emeasure (lim_sequence x) (PF.emb UNIV {0..<n} X) =\n       emeasure (C 0 n (\\<lambda>x. undefined)) X", "assume \"X \\<in> sets (\\<Pi>\\<^sub>M j\\<in>{0..<n}. M)\""], ["proof (state)\nthis:\n  X \\<in> sets (Pi\\<^sub>M {0..<n} (\\<lambda>j. M))\n\ngoal (1 subgoal):\n 1. \\<And>n X.\n       X \\<in> sets (Pi\\<^sub>M {0..<n} (\\<lambda>i. M)) \\<Longrightarrow>\n       emeasure (lim_sequence x) (PF.emb UNIV {0..<n} X) =\n       emeasure (C 0 n (\\<lambda>x. undefined)) X", "then"], ["proof (chain)\npicking this:\n  X \\<in> sets (Pi\\<^sub>M {0..<n} (\\<lambda>j. M))", "show \"emeasure (lim_sequence x) (PF.emb UNIV {0..<n} X) = emeasure (C 0 n (\\<lambda>x. undefined)) X\""], ["proof (prove)\nusing this:\n  X \\<in> sets (Pi\\<^sub>M {0..<n} (\\<lambda>j. M))\n\ngoal (1 subgoal):\n 1. emeasure (lim_sequence x) (PF.emb UNIV {0..<n} X) =\n    emeasure (C 0 n (\\<lambda>x. undefined)) X", "by (simp add: space_C emb CI_def space_PiM distr_id2 sets_C cong: distr_cong_simp)"], ["proof (state)\nthis:\n  emeasure (lim_sequence x) (PF.emb UNIV {0..<n} X) =\n  emeasure (C 0 n (\\<lambda>x. undefined)) X\n\ngoal:\nNo subgoals!", "}"], ["proof (state)\nthis:\n  ?X2 \\<in> sets (Pi\\<^sub>M {0..<?n2} (\\<lambda>j. M)) \\<Longrightarrow>\n  emeasure (lim_sequence x) (PF.emb UNIV {0..<?n2} ?X2) =\n  emeasure (C 0 ?n2 (\\<lambda>x. undefined)) ?X2\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lim_sequence[measurable]: \"lim_sequence \\<in> M \\<rightarrow>\\<^sub>M prob_algebra (\\<Pi>\\<^sub>M i\\<in>UNIV. M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lim_sequence\n    \\<in> M \\<rightarrow>\\<^sub>M\n          prob_algebra (Pi\\<^sub>M UNIV (\\<lambda>i. M))", "proof (intro measurable_prob_algebra_generated[OF sets_PiM Int_stable_prod_algebra prod_algebra_sets_into_space])"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>a. a \\<in> space M \\<Longrightarrow> prob_space (lim_sequence a)\n 2. \\<And>a.\n       a \\<in> space M \\<Longrightarrow>\n       sets (lim_sequence a) = sets (Pi\\<^sub>M UNIV (\\<lambda>i. M))\n 3. \\<And>A.\n       A \\<in> prod_algebra UNIV (\\<lambda>i. M) \\<Longrightarrow>\n       (\\<lambda>a. emeasure (lim_sequence a) A) \\<in> borel_measurable M", "fix a"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>a. a \\<in> space M \\<Longrightarrow> prob_space (lim_sequence a)\n 2. \\<And>a.\n       a \\<in> space M \\<Longrightarrow>\n       sets (lim_sequence a) = sets (Pi\\<^sub>M UNIV (\\<lambda>i. M))\n 3. \\<And>A.\n       A \\<in> prod_algebra UNIV (\\<lambda>i. M) \\<Longrightarrow>\n       (\\<lambda>a. emeasure (lim_sequence a) A) \\<in> borel_measurable M", "assume [simp]: \"a \\<in> space M\""], ["proof (state)\nthis:\n  a \\<in> space M\n\ngoal (3 subgoals):\n 1. \\<And>a. a \\<in> space M \\<Longrightarrow> prob_space (lim_sequence a)\n 2. \\<And>a.\n       a \\<in> space M \\<Longrightarrow>\n       sets (lim_sequence a) = sets (Pi\\<^sub>M UNIV (\\<lambda>i. M))\n 3. \\<And>A.\n       A \\<in> prod_algebra UNIV (\\<lambda>i. M) \\<Longrightarrow>\n       (\\<lambda>a. emeasure (lim_sequence a) A) \\<in> borel_measurable M", "interpret Ionescu_Tulcea \"K' a\" \"\\<lambda>_. M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ionescu_Tulcea (K' a) (\\<lambda>_. M)", "by (rule IT_K') simp"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>a. a \\<in> space M \\<Longrightarrow> prob_space (lim_sequence a)\n 2. \\<And>a.\n       a \\<in> space M \\<Longrightarrow>\n       sets (lim_sequence a) = sets (Pi\\<^sub>M UNIV (\\<lambda>i. M))\n 3. \\<And>A.\n       A \\<in> prod_algebra UNIV (\\<lambda>i. M) \\<Longrightarrow>\n       (\\<lambda>a. emeasure (lim_sequence a) A) \\<in> borel_measurable M", "have sp: \"space (lim_sequence a) = prod_emb UNIV (\\<lambda>_. M) {} (\\<Pi>\\<^sub>E j\\<in>{}. space M)\" \"space (CI {}) = {} \\<rightarrow>\\<^sub>E space M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. space (lim_sequence a) =\n    PF.emb UNIV {} ({} \\<rightarrow>\\<^sub>E space M) &&&\n    space (CI {}) = {} \\<rightarrow>\\<^sub>E space M", "by (auto simp: space_lim_sequence space_PiM prod_emb_def PF.space_P)"], ["proof (state)\nthis:\n  space (lim_sequence a) = PF.emb UNIV {} ({} \\<rightarrow>\\<^sub>E space M)\n  space (CI {}) = {} \\<rightarrow>\\<^sub>E space M\n\ngoal (3 subgoals):\n 1. \\<And>a. a \\<in> space M \\<Longrightarrow> prob_space (lim_sequence a)\n 2. \\<And>a.\n       a \\<in> space M \\<Longrightarrow>\n       sets (lim_sequence a) = sets (Pi\\<^sub>M UNIV (\\<lambda>i. M))\n 3. \\<And>A.\n       A \\<in> prod_algebra UNIV (\\<lambda>i. M) \\<Longrightarrow>\n       (\\<lambda>a. emeasure (lim_sequence a) A) \\<in> borel_measurable M", "show \"prob_space (lim_sequence a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prob_space (lim_sequence a)", "apply standard"], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure (lim_sequence a) (space (lim_sequence a)) = 1", "using PF.prob_space_P[THEN prob_space.emeasure_space_1, of \"{}\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>finite {}; {} \\<subseteq> UNIV\\<rbrakk>\n  \\<Longrightarrow> emeasure (CI {}) (space (CI {})) = 1\n\ngoal (1 subgoal):\n 1. emeasure (lim_sequence a) (space (lim_sequence a)) = 1", "apply (simp add: sp emeasure_lim_sequence_emb del: PiE_empty_domain)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  prob_space (lim_sequence a)\n\ngoal (2 subgoals):\n 1. \\<And>a.\n       a \\<in> space M \\<Longrightarrow>\n       sets (lim_sequence a) = sets (Pi\\<^sub>M UNIV (\\<lambda>i. M))\n 2. \\<And>A.\n       A \\<in> prod_algebra UNIV (\\<lambda>i. M) \\<Longrightarrow>\n       (\\<lambda>a. emeasure (lim_sequence a) A) \\<in> borel_measurable M", "show \"sets (lim_sequence a) = sets (Pi\\<^sub>M UNIV (\\<lambda>i. M))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sets (lim_sequence a) = sets (Pi\\<^sub>M UNIV (\\<lambda>i. M))", "by (simp add: sets_lim_sequence)"], ["proof (state)\nthis:\n  sets (lim_sequence a) = sets (Pi\\<^sub>M UNIV (\\<lambda>i. M))\n\ngoal (1 subgoal):\n 1. \\<And>A.\n       A \\<in> prod_algebra UNIV (\\<lambda>i. M) \\<Longrightarrow>\n       (\\<lambda>a. emeasure (lim_sequence a) A) \\<in> borel_measurable M", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>A.\n       A \\<in> prod_algebra UNIV (\\<lambda>i. M) \\<Longrightarrow>\n       (\\<lambda>a. emeasure (lim_sequence a) A) \\<in> borel_measurable M", "fix X :: \"(nat \\<Rightarrow> 'a) set\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>A.\n       A \\<in> prod_algebra UNIV (\\<lambda>i. M) \\<Longrightarrow>\n       (\\<lambda>a. emeasure (lim_sequence a) A) \\<in> borel_measurable M", "assume \"X \\<in> prod_algebra UNIV (\\<lambda>i. M)\""], ["proof (state)\nthis:\n  X \\<in> prod_algebra UNIV (\\<lambda>i. M)\n\ngoal (1 subgoal):\n 1. \\<And>A.\n       A \\<in> prod_algebra UNIV (\\<lambda>i. M) \\<Longrightarrow>\n       (\\<lambda>a. emeasure (lim_sequence a) A) \\<in> borel_measurable M", "then"], ["proof (chain)\npicking this:\n  X \\<in> prod_algebra UNIV (\\<lambda>i. M)", "obtain J :: \"nat set\" and F where J: \"J \\<noteq> {}\" \"finite J\" \"F \\<in> J \\<rightarrow> sets M\"\n    and X: \"X = prod_emb UNIV (\\<lambda>_. M) J (Pi\\<^sub>E J F)\""], ["proof (prove)\nusing this:\n  X \\<in> prod_algebra UNIV (\\<lambda>i. M)\n\ngoal (1 subgoal):\n 1. (\\<And>J F.\n        \\<lbrakk>J \\<noteq> {}; finite J; F \\<in> J \\<rightarrow> sets M;\n         X = prod_emb UNIV (\\<lambda>_. M) J (Pi\\<^sub>E J F)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding prod_algebra_def"], ["proof (prove)\nusing this:\n  X \\<in> (\\<lambda>(J, X).\n              prod_emb UNIV (\\<lambda>i. M) J (Pi\\<^sub>E J X)) `\n          {(J, X).\n           (J \\<noteq> {} \\<or> UNIV = {}) \\<and>\n           finite J \\<and>\n           J \\<subseteq> UNIV \\<and> X \\<in> J \\<rightarrow> sets M}\n\ngoal (1 subgoal):\n 1. (\\<And>J F.\n        \\<lbrakk>J \\<noteq> {}; finite J; F \\<in> J \\<rightarrow> sets M;\n         X = prod_emb UNIV (\\<lambda>_. M) J (Pi\\<^sub>E J F)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  J \\<noteq> {}\n  finite J\n  F \\<in> J \\<rightarrow> sets M\n  X = prod_emb UNIV (\\<lambda>_. M) J (Pi\\<^sub>E J F)\n\ngoal (1 subgoal):\n 1. \\<And>A.\n       A \\<in> prod_algebra UNIV (\\<lambda>i. M) \\<Longrightarrow>\n       (\\<lambda>a. emeasure (lim_sequence a) A) \\<in> borel_measurable M", "then"], ["proof (chain)\npicking this:\n  J \\<noteq> {}\n  finite J\n  F \\<in> J \\<rightarrow> sets M\n  X = prod_emb UNIV (\\<lambda>_. M) J (Pi\\<^sub>E J F)", "have Pi_F: \"finite J\" \"Pi\\<^sub>E J F \\<in> sets (Pi\\<^sub>M J (\\<lambda>_. M))\""], ["proof (prove)\nusing this:\n  J \\<noteq> {}\n  finite J\n  F \\<in> J \\<rightarrow> sets M\n  X = prod_emb UNIV (\\<lambda>_. M) J (Pi\\<^sub>E J F)\n\ngoal (1 subgoal):\n 1. finite J &&& Pi\\<^sub>E J F \\<in> sets (Pi\\<^sub>M J (\\<lambda>_. M))", "by (auto intro: sets_PiM_I_finite)"], ["proof (state)\nthis:\n  finite J\n  Pi\\<^sub>E J F \\<in> sets (Pi\\<^sub>M J (\\<lambda>_. M))\n\ngoal (1 subgoal):\n 1. \\<And>A.\n       A \\<in> prod_algebra UNIV (\\<lambda>i. M) \\<Longrightarrow>\n       (\\<lambda>a. emeasure (lim_sequence a) A) \\<in> borel_measurable M", "define n where \"n = (LEAST n. \\<forall>i\\<ge>n. i \\<notin> J)\""], ["proof (state)\nthis:\n  n = (LEAST n. \\<forall>i\\<ge>n. i \\<notin> J)\n\ngoal (1 subgoal):\n 1. \\<And>A.\n       A \\<in> prod_algebra UNIV (\\<lambda>i. M) \\<Longrightarrow>\n       (\\<lambda>a. emeasure (lim_sequence a) A) \\<in> borel_measurable M", "have J_le_n: \"J \\<subseteq> {0..<n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. J \\<subseteq> {0..<n}", "unfolding n_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. J \\<subseteq> {0..<LEAST n. \\<forall>i\\<ge>n. i \\<notin> J}", "using \\<open>finite J\\<close>"], ["proof (prove)\nusing this:\n  finite J\n\ngoal (1 subgoal):\n 1. J \\<subseteq> {0..<LEAST n. \\<forall>i\\<ge>n. i \\<notin> J}", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite J \\<Longrightarrow>\n    J \\<subseteq> {0..<LEAST n. \\<forall>i\\<ge>n. i \\<notin> J}", "apply (rule LeastI2[of _ \"Suc (Max J)\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. finite J \\<Longrightarrow> \\<forall>i\\<ge>Suc (Max J). i \\<notin> J\n 2. \\<And>x.\n       \\<lbrakk>finite J; \\<forall>i\\<ge>x. i \\<notin> J\\<rbrakk>\n       \\<Longrightarrow> J \\<subseteq> {0..<x}", "apply (auto simp: Suc_le_eq not_le[symmetric])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  J \\<subseteq> {0..<n}\n\ngoal (1 subgoal):\n 1. \\<And>A.\n       A \\<in> prod_algebra UNIV (\\<lambda>i. M) \\<Longrightarrow>\n       (\\<lambda>a. emeasure (lim_sequence a) A) \\<in> borel_measurable M", "have C: \"(\\<lambda>x. Ionescu_Tulcea.C (K' x) (\\<lambda>_. M) 0 n (\\<lambda>x. undefined)) \\<in> M \\<rightarrow>\\<^sub>M subprob_algebra (Pi\\<^sub>M {0..<n} (\\<lambda>_. M))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x.\n        Ionescu_Tulcea.C (K' x) (\\<lambda>_. M) 0 n (\\<lambda>x. undefined))\n    \\<in> M \\<rightarrow>\\<^sub>M\n          subprob_algebra (Pi\\<^sub>M {0..<n} (\\<lambda>_. M))", "apply (induction n)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (\\<lambda>x.\n        Ionescu_Tulcea.C (K' x) (\\<lambda>_. M) 0 0 (\\<lambda>x. undefined))\n    \\<in> M \\<rightarrow>\\<^sub>M\n          subprob_algebra (Pi\\<^sub>M {0..<0} (\\<lambda>_. M))\n 2. \\<And>n.\n       (\\<lambda>x.\n           Ionescu_Tulcea.C (K' x) (\\<lambda>_. M) 0 n\n            (\\<lambda>x. undefined))\n       \\<in> M \\<rightarrow>\\<^sub>M\n             subprob_algebra\n              (Pi\\<^sub>M {0..<n} (\\<lambda>_. M)) \\<Longrightarrow>\n       (\\<lambda>x.\n           Ionescu_Tulcea.C (K' x) (\\<lambda>_. M) 0 (Suc n)\n            (\\<lambda>x. undefined))\n       \\<in> M \\<rightarrow>\\<^sub>M\n             subprob_algebra (Pi\\<^sub>M {0..<Suc n} (\\<lambda>_. M))", "apply (subst measurable_cong)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>w.\n       w \\<in> space M \\<Longrightarrow>\n       Ionescu_Tulcea.C (K' w) (\\<lambda>_. M) 0 0 (\\<lambda>x. undefined) =\n       ?g3 w\n 2. ?g3\n    \\<in> M \\<rightarrow>\\<^sub>M\n          subprob_algebra (Pi\\<^sub>M {0..<0} (\\<lambda>_. M))\n 3. \\<And>n.\n       (\\<lambda>x.\n           Ionescu_Tulcea.C (K' x) (\\<lambda>_. M) 0 n\n            (\\<lambda>x. undefined))\n       \\<in> M \\<rightarrow>\\<^sub>M\n             subprob_algebra\n              (Pi\\<^sub>M {0..<n} (\\<lambda>_. M)) \\<Longrightarrow>\n       (\\<lambda>x.\n           Ionescu_Tulcea.C (K' x) (\\<lambda>_. M) 0 (Suc n)\n            (\\<lambda>x. undefined))\n       \\<in> M \\<rightarrow>\\<^sub>M\n             subprob_algebra (Pi\\<^sub>M {0..<Suc n} (\\<lambda>_. M))", "apply (rule Ionescu_Tulcea.C.simps[OF IT_K'])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>w. w \\<in> space M \\<Longrightarrow> w \\<in> space M\n 2. (\\<lambda>w.\n        return (Pi\\<^sub>M {0..<0} (\\<lambda>_. M)) (\\<lambda>x. undefined))\n    \\<in> M \\<rightarrow>\\<^sub>M\n          subprob_algebra (Pi\\<^sub>M {0..<0} (\\<lambda>_. M))\n 3. \\<And>n.\n       (\\<lambda>x.\n           Ionescu_Tulcea.C (K' x) (\\<lambda>_. M) 0 n\n            (\\<lambda>x. undefined))\n       \\<in> M \\<rightarrow>\\<^sub>M\n             subprob_algebra\n              (Pi\\<^sub>M {0..<n} (\\<lambda>_. M)) \\<Longrightarrow>\n       (\\<lambda>x.\n           Ionescu_Tulcea.C (K' x) (\\<lambda>_. M) 0 (Suc n)\n            (\\<lambda>x. undefined))\n       \\<in> M \\<rightarrow>\\<^sub>M\n             subprob_algebra (Pi\\<^sub>M {0..<Suc n} (\\<lambda>_. M))", "apply assumption"], ["proof (prove)\ngoal (2 subgoals):\n 1. (\\<lambda>w.\n        return (Pi\\<^sub>M {0..<0} (\\<lambda>_. M)) (\\<lambda>x. undefined))\n    \\<in> M \\<rightarrow>\\<^sub>M\n          subprob_algebra (Pi\\<^sub>M {0..<0} (\\<lambda>_. M))\n 2. \\<And>n.\n       (\\<lambda>x.\n           Ionescu_Tulcea.C (K' x) (\\<lambda>_. M) 0 n\n            (\\<lambda>x. undefined))\n       \\<in> M \\<rightarrow>\\<^sub>M\n             subprob_algebra\n              (Pi\\<^sub>M {0..<n} (\\<lambda>_. M)) \\<Longrightarrow>\n       (\\<lambda>x.\n           Ionescu_Tulcea.C (K' x) (\\<lambda>_. M) 0 (Suc n)\n            (\\<lambda>x. undefined))\n       \\<in> M \\<rightarrow>\\<^sub>M\n             subprob_algebra (Pi\\<^sub>M {0..<Suc n} (\\<lambda>_. M))", "apply (rule measurable_compose[OF _ return_measurable])"], ["proof (prove)\ngoal (2 subgoals):\n 1. (\\<lambda>x xa. undefined)\n    \\<in> M \\<rightarrow>\\<^sub>M Pi\\<^sub>M {0..<0} (\\<lambda>_. M)\n 2. \\<And>n.\n       (\\<lambda>x.\n           Ionescu_Tulcea.C (K' x) (\\<lambda>_. M) 0 n\n            (\\<lambda>x. undefined))\n       \\<in> M \\<rightarrow>\\<^sub>M\n             subprob_algebra\n              (Pi\\<^sub>M {0..<n} (\\<lambda>_. M)) \\<Longrightarrow>\n       (\\<lambda>x.\n           Ionescu_Tulcea.C (K' x) (\\<lambda>_. M) 0 (Suc n)\n            (\\<lambda>x. undefined))\n       \\<in> M \\<rightarrow>\\<^sub>M\n             subprob_algebra (Pi\\<^sub>M {0..<Suc n} (\\<lambda>_. M))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       (\\<lambda>x.\n           Ionescu_Tulcea.C (K' x) (\\<lambda>_. M) 0 n\n            (\\<lambda>x. undefined))\n       \\<in> M \\<rightarrow>\\<^sub>M\n             subprob_algebra\n              (Pi\\<^sub>M {0..<n} (\\<lambda>_. M)) \\<Longrightarrow>\n       (\\<lambda>x.\n           Ionescu_Tulcea.C (K' x) (\\<lambda>_. M) 0 (Suc n)\n            (\\<lambda>x. undefined))\n       \\<in> M \\<rightarrow>\\<^sub>M\n             subprob_algebra (Pi\\<^sub>M {0..<Suc n} (\\<lambda>_. M))", "apply (subst measurable_cong)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n w.\n       \\<lbrakk>(\\<lambda>x.\n                    Ionescu_Tulcea.C (K' x) (\\<lambda>_. M) 0 n\n                     (\\<lambda>x. undefined))\n                \\<in> M \\<rightarrow>\\<^sub>M\n                      subprob_algebra (Pi\\<^sub>M {0..<n} (\\<lambda>_. M));\n        w \\<in> space M\\<rbrakk>\n       \\<Longrightarrow> Ionescu_Tulcea.C (K' w) (\\<lambda>_. M) 0 (Suc n)\n                          (\\<lambda>x. undefined) =\n                         ?g12 n w\n 2. \\<And>n.\n       (\\<lambda>x.\n           Ionescu_Tulcea.C (K' x) (\\<lambda>_. M) 0 n\n            (\\<lambda>x. undefined))\n       \\<in> M \\<rightarrow>\\<^sub>M\n             subprob_algebra\n              (Pi\\<^sub>M {0..<n} (\\<lambda>_. M)) \\<Longrightarrow>\n       ?g12 n\n       \\<in> M \\<rightarrow>\\<^sub>M\n             subprob_algebra (Pi\\<^sub>M {0..<Suc n} (\\<lambda>_. M))", "apply (rule Ionescu_Tulcea.C.simps[OF IT_K'])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n w.\n       \\<lbrakk>(\\<lambda>x.\n                    Ionescu_Tulcea.C (K' x) (\\<lambda>_. M) 0 n\n                     (\\<lambda>x. undefined))\n                \\<in> M \\<rightarrow>\\<^sub>M\n                      subprob_algebra (Pi\\<^sub>M {0..<n} (\\<lambda>_. M));\n        w \\<in> space M\\<rbrakk>\n       \\<Longrightarrow> w \\<in> space M\n 2. \\<And>n.\n       (\\<lambda>x.\n           Ionescu_Tulcea.C (K' x) (\\<lambda>_. M) 0 n\n            (\\<lambda>x. undefined))\n       \\<in> M \\<rightarrow>\\<^sub>M\n             subprob_algebra\n              (Pi\\<^sub>M {0..<n} (\\<lambda>_. M)) \\<Longrightarrow>\n       (\\<lambda>w.\n           Ionescu_Tulcea.C (K' w) (\\<lambda>_. M) 0 n\n            (\\<lambda>x. undefined) \\<bind>\n           Ionescu_Tulcea.eP (K' w) (\\<lambda>_. M) (0 + n))\n       \\<in> M \\<rightarrow>\\<^sub>M\n             subprob_algebra (Pi\\<^sub>M {0..<Suc n} (\\<lambda>_. M))", "apply assumption"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       (\\<lambda>x.\n           Ionescu_Tulcea.C (K' x) (\\<lambda>_. M) 0 n\n            (\\<lambda>x. undefined))\n       \\<in> M \\<rightarrow>\\<^sub>M\n             subprob_algebra\n              (Pi\\<^sub>M {0..<n} (\\<lambda>_. M)) \\<Longrightarrow>\n       (\\<lambda>w.\n           Ionescu_Tulcea.C (K' w) (\\<lambda>_. M) 0 n\n            (\\<lambda>x. undefined) \\<bind>\n           Ionescu_Tulcea.eP (K' w) (\\<lambda>_. M) (0 + n))\n       \\<in> M \\<rightarrow>\\<^sub>M\n             subprob_algebra (Pi\\<^sub>M {0..<Suc n} (\\<lambda>_. M))", "apply (rule measurable_bind')"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n.\n       (\\<lambda>x.\n           Ionescu_Tulcea.C (K' x) (\\<lambda>_. M) 0 n\n            (\\<lambda>x. undefined))\n       \\<in> M \\<rightarrow>\\<^sub>M\n             subprob_algebra\n              (Pi\\<^sub>M {0..<n} (\\<lambda>_. M)) \\<Longrightarrow>\n       (\\<lambda>x.\n           Ionescu_Tulcea.C (K' x) (\\<lambda>_. M) 0 n\n            (\\<lambda>x. undefined))\n       \\<in> M \\<rightarrow>\\<^sub>M subprob_algebra (?N16 n)\n 2. \\<And>n.\n       (\\<lambda>x.\n           Ionescu_Tulcea.C (K' x) (\\<lambda>_. M) 0 n\n            (\\<lambda>x. undefined))\n       \\<in> M \\<rightarrow>\\<^sub>M\n             subprob_algebra\n              (Pi\\<^sub>M {0..<n} (\\<lambda>_. M)) \\<Longrightarrow>\n       (\\<lambda>(x, y). Ionescu_Tulcea.eP (K' x) (\\<lambda>_. M) (0 + n) y)\n       \\<in> M \\<Otimes>\\<^sub>M ?N16 n \\<rightarrow>\\<^sub>M\n             subprob_algebra (Pi\\<^sub>M {0..<Suc n} (\\<lambda>_. M))", "apply assumption"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       (\\<lambda>x.\n           Ionescu_Tulcea.C (K' x) (\\<lambda>_. M) 0 n\n            (\\<lambda>x. undefined))\n       \\<in> M \\<rightarrow>\\<^sub>M\n             subprob_algebra\n              (Pi\\<^sub>M {0..<n} (\\<lambda>_. M)) \\<Longrightarrow>\n       (\\<lambda>(x, y). Ionescu_Tulcea.eP (K' x) (\\<lambda>_. M) (0 + n) y)\n       \\<in> M \\<Otimes>\\<^sub>M\n             Pi\\<^sub>M {0..<n} (\\<lambda>_. M) \\<rightarrow>\\<^sub>M\n             subprob_algebra (Pi\\<^sub>M {0..<Suc n} (\\<lambda>_. M))", "apply (subst measurable_cong)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n w.\n       \\<lbrakk>(\\<lambda>x.\n                    Ionescu_Tulcea.C (K' x) (\\<lambda>_. M) 0 n\n                     (\\<lambda>x. undefined))\n                \\<in> M \\<rightarrow>\\<^sub>M\n                      subprob_algebra (Pi\\<^sub>M {0..<n} (\\<lambda>_. M));\n        w \\<in> space\n                 (M \\<Otimes>\\<^sub>M\n                  Pi\\<^sub>M {0..<n} (\\<lambda>_. M))\\<rbrakk>\n       \\<Longrightarrow> (case w of\n                          (x, xa) \\<Rightarrow>\n                            Ionescu_Tulcea.eP (K' x) (\\<lambda>_. M) (0 + n)\n                             xa) =\n                         ?g19 n w\n 2. \\<And>n.\n       (\\<lambda>x.\n           Ionescu_Tulcea.C (K' x) (\\<lambda>_. M) 0 n\n            (\\<lambda>x. undefined))\n       \\<in> M \\<rightarrow>\\<^sub>M\n             subprob_algebra\n              (Pi\\<^sub>M {0..<n} (\\<lambda>_. M)) \\<Longrightarrow>\n       ?g19 n\n       \\<in> M \\<Otimes>\\<^sub>M\n             Pi\\<^sub>M {0..<n} (\\<lambda>_. M) \\<rightarrow>\\<^sub>M\n             subprob_algebra (Pi\\<^sub>M {0..<Suc n} (\\<lambda>_. M))", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n w.\n       \\<lbrakk>(\\<lambda>x.\n                    Ionescu_Tulcea.C (K' x) (\\<lambda>_. M) 0 n\n                     (\\<lambda>x. undefined))\n                \\<in> M \\<rightarrow>\\<^sub>M\n                      subprob_algebra (Pi\\<^sub>M {0..<n} (\\<lambda>_. M));\n        w \\<in> space\n                 (M \\<Otimes>\\<^sub>M\n                  Pi\\<^sub>M {0..<n} (\\<lambda>_. M))\\<rbrakk>\n       \\<Longrightarrow> (case w of\n                          (x, xa) \\<Rightarrow>\n                            Ionescu_Tulcea.eP (K' x) (\\<lambda>_. M) (0 + n)\n                             xa) =\n                         ?g19 n w\n 2. \\<And>n.\n       (\\<lambda>x.\n           Ionescu_Tulcea.C (K' x) (\\<lambda>_. M) 0 n\n            (\\<lambda>x. undefined))\n       \\<in> M \\<rightarrow>\\<^sub>M\n             subprob_algebra\n              (Pi\\<^sub>M {0..<n} (\\<lambda>_. M)) \\<Longrightarrow>\n       ?g19 n\n       \\<in> M \\<Otimes>\\<^sub>M\n             Pi\\<^sub>M {0..<n} (\\<lambda>_. M) \\<rightarrow>\\<^sub>M\n             subprob_algebra (Pi\\<^sub>M {0..<Suc n} (\\<lambda>_. M))", "fix n :: nat and w"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n w.\n       \\<lbrakk>(\\<lambda>x.\n                    Ionescu_Tulcea.C (K' x) (\\<lambda>_. M) 0 n\n                     (\\<lambda>x. undefined))\n                \\<in> M \\<rightarrow>\\<^sub>M\n                      subprob_algebra (Pi\\<^sub>M {0..<n} (\\<lambda>_. M));\n        w \\<in> space\n                 (M \\<Otimes>\\<^sub>M\n                  Pi\\<^sub>M {0..<n} (\\<lambda>_. M))\\<rbrakk>\n       \\<Longrightarrow> (case w of\n                          (x, xa) \\<Rightarrow>\n                            Ionescu_Tulcea.eP (K' x) (\\<lambda>_. M) (0 + n)\n                             xa) =\n                         ?g19 n w\n 2. \\<And>n.\n       (\\<lambda>x.\n           Ionescu_Tulcea.C (K' x) (\\<lambda>_. M) 0 n\n            (\\<lambda>x. undefined))\n       \\<in> M \\<rightarrow>\\<^sub>M\n             subprob_algebra\n              (Pi\\<^sub>M {0..<n} (\\<lambda>_. M)) \\<Longrightarrow>\n       ?g19 n\n       \\<in> M \\<Otimes>\\<^sub>M\n             Pi\\<^sub>M {0..<n} (\\<lambda>_. M) \\<rightarrow>\\<^sub>M\n             subprob_algebra (Pi\\<^sub>M {0..<Suc n} (\\<lambda>_. M))", "assume \"w \\<in> space (M \\<Otimes>\\<^sub>M Pi\\<^sub>M {0..<n} (\\<lambda>_. M))\""], ["proof (state)\nthis:\n  w \\<in> space (M \\<Otimes>\\<^sub>M Pi\\<^sub>M {0..<n} (\\<lambda>_. M))\n\ngoal (2 subgoals):\n 1. \\<And>n w.\n       \\<lbrakk>(\\<lambda>x.\n                    Ionescu_Tulcea.C (K' x) (\\<lambda>_. M) 0 n\n                     (\\<lambda>x. undefined))\n                \\<in> M \\<rightarrow>\\<^sub>M\n                      subprob_algebra (Pi\\<^sub>M {0..<n} (\\<lambda>_. M));\n        w \\<in> space\n                 (M \\<Otimes>\\<^sub>M\n                  Pi\\<^sub>M {0..<n} (\\<lambda>_. M))\\<rbrakk>\n       \\<Longrightarrow> (case w of\n                          (x, xa) \\<Rightarrow>\n                            Ionescu_Tulcea.eP (K' x) (\\<lambda>_. M) (0 + n)\n                             xa) =\n                         ?g19 n w\n 2. \\<And>n.\n       (\\<lambda>x.\n           Ionescu_Tulcea.C (K' x) (\\<lambda>_. M) 0 n\n            (\\<lambda>x. undefined))\n       \\<in> M \\<rightarrow>\\<^sub>M\n             subprob_algebra\n              (Pi\\<^sub>M {0..<n} (\\<lambda>_. M)) \\<Longrightarrow>\n       ?g19 n\n       \\<in> M \\<Otimes>\\<^sub>M\n             Pi\\<^sub>M {0..<n} (\\<lambda>_. M) \\<rightarrow>\\<^sub>M\n             subprob_algebra (Pi\\<^sub>M {0..<Suc n} (\\<lambda>_. M))", "then"], ["proof (chain)\npicking this:\n  w \\<in> space (M \\<Otimes>\\<^sub>M Pi\\<^sub>M {0..<n} (\\<lambda>_. M))", "show \"(case w of (x, xa) \\<Rightarrow> Ionescu_Tulcea.eP (K' x) (\\<lambda>_. M) (0 + n) xa) =\n      (case w of (x, xa) \\<Rightarrow> distr (K' x n xa) (\\<Pi>\\<^sub>M i\\<in>{0..<Suc n}. M) (fun_upd xa n))\""], ["proof (prove)\nusing this:\n  w \\<in> space (M \\<Otimes>\\<^sub>M Pi\\<^sub>M {0..<n} (\\<lambda>_. M))\n\ngoal (1 subgoal):\n 1. (case w of\n     (x, xa) \\<Rightarrow>\n       Ionescu_Tulcea.eP (K' x) (\\<lambda>_. M) (0 + n) xa) =\n    (case w of\n     (x, xa) \\<Rightarrow>\n       distr (K' x n xa) (Pi\\<^sub>M {0..<Suc n} (\\<lambda>i. M))\n        (fun_upd xa n))", "by (auto simp: space_pair_measure Ionescu_Tulcea.eP_def[OF IT_K'] split: prod.split)"], ["proof (state)\nthis:\n  (case w of\n   (x, xa) \\<Rightarrow>\n     Ionescu_Tulcea.eP (K' x) (\\<lambda>_. M) (0 + n) xa) =\n  (case w of\n   (x, xa) \\<Rightarrow>\n     distr (K' x n xa) (Pi\\<^sub>M {0..<Suc n} (\\<lambda>i. M))\n      (fun_upd xa n))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       (\\<lambda>x.\n           Ionescu_Tulcea.C (K' x) (\\<lambda>_. M) 0 n\n            (\\<lambda>x. undefined))\n       \\<in> M \\<rightarrow>\\<^sub>M\n             subprob_algebra\n              (Pi\\<^sub>M {0..<n} (\\<lambda>_. M)) \\<Longrightarrow>\n       (\\<lambda>w.\n           case w of\n           (x, xa) \\<Rightarrow>\n             distr (K' x n xa) (Pi\\<^sub>M {0..<Suc n} (\\<lambda>i. M))\n              (fun_upd xa n))\n       \\<in> M \\<Otimes>\\<^sub>M\n             Pi\\<^sub>M {0..<n} (\\<lambda>_. M) \\<rightarrow>\\<^sub>M\n             subprob_algebra (Pi\\<^sub>M {0..<Suc n} (\\<lambda>_. M))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       (\\<lambda>x.\n           Ionescu_Tulcea.C (K' x) (\\<lambda>_. M) 0 n\n            (\\<lambda>x. undefined))\n       \\<in> M \\<rightarrow>\\<^sub>M\n             subprob_algebra\n              (Pi\\<^sub>M {0..<n} (\\<lambda>_. M)) \\<Longrightarrow>\n       (\\<lambda>w.\n           case w of\n           (x, xa) \\<Rightarrow>\n             distr (K' x n xa) (Pi\\<^sub>M {0..<Suc n} (\\<lambda>i. M))\n              (fun_upd xa n))\n       \\<in> M \\<Otimes>\\<^sub>M\n             Pi\\<^sub>M {0..<n} (\\<lambda>_. M) \\<rightarrow>\\<^sub>M\n             subprob_algebra (Pi\\<^sub>M {0..<Suc n} (\\<lambda>_. M))", "fix n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       (\\<lambda>x.\n           Ionescu_Tulcea.C (K' x) (\\<lambda>_. M) 0 n\n            (\\<lambda>x. undefined))\n       \\<in> M \\<rightarrow>\\<^sub>M\n             subprob_algebra\n              (Pi\\<^sub>M {0..<n} (\\<lambda>_. M)) \\<Longrightarrow>\n       (\\<lambda>w.\n           case w of\n           (x, xa) \\<Rightarrow>\n             distr (K' x n xa) (Pi\\<^sub>M {0..<Suc n} (\\<lambda>i. M))\n              (fun_upd xa n))\n       \\<in> M \\<Otimes>\\<^sub>M\n             Pi\\<^sub>M {0..<n} (\\<lambda>_. M) \\<rightarrow>\\<^sub>M\n             subprob_algebra (Pi\\<^sub>M {0..<Suc n} (\\<lambda>_. M))", "show \"(\\<lambda>w. case w of (x, xa) \\<Rightarrow> distr (K' x n xa) (Pi\\<^sub>M {0..<Suc n} (\\<lambda>i. M)) (fun_upd xa n))\n         \\<in> M \\<Otimes>\\<^sub>M Pi\\<^sub>M {0..<n} (\\<lambda>_. M) \\<rightarrow>\\<^sub>M subprob_algebra (Pi\\<^sub>M {0..<Suc n} (\\<lambda>_. M))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>w.\n        case w of\n        (x, xa) \\<Rightarrow>\n          distr (K' x n xa) (Pi\\<^sub>M {0..<Suc n} (\\<lambda>i. M))\n           (fun_upd xa n))\n    \\<in> M \\<Otimes>\\<^sub>M\n          Pi\\<^sub>M {0..<n} (\\<lambda>_. M) \\<rightarrow>\\<^sub>M\n          subprob_algebra (Pi\\<^sub>M {0..<Suc n} (\\<lambda>_. M))", "unfolding K'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>w.\n        case w of\n        (x, xa) \\<Rightarrow>\n          distr (K (case n of 0 \\<Rightarrow> x | Suc x \\<Rightarrow> xa x))\n           (Pi\\<^sub>M {0..<Suc n} (\\<lambda>i. M)) (fun_upd xa n))\n    \\<in> M \\<Otimes>\\<^sub>M\n          Pi\\<^sub>M {0..<n} (\\<lambda>_. M) \\<rightarrow>\\<^sub>M\n          subprob_algebra (Pi\\<^sub>M {0..<Suc n} (\\<lambda>_. M))", "apply measurable"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>w.\n        distr\n         (K (case n of 0 \\<Rightarrow> fst w | Suc x \\<Rightarrow> snd w x))\n         (Pi\\<^sub>M {0..<Suc n} (\\<lambda>i. M)) (fun_upd (snd w) n))\n    \\<in> M \\<Otimes>\\<^sub>M\n          Pi\\<^sub>M {0..<n} (\\<lambda>_. M) \\<rightarrow>\\<^sub>M\n          subprob_algebra (Pi\\<^sub>M {0..<Suc n} (\\<lambda>_. M))", "apply (rule measurable_distr2[where M=M])"], ["proof (prove)\ngoal (2 subgoals):\n 1. (\\<lambda>(x, y). (snd x)(n := y))\n    \\<in> (M \\<Otimes>\\<^sub>M\n           Pi\\<^sub>M {0..<n} (\\<lambda>_. M)) \\<Otimes>\\<^sub>M\n          M \\<rightarrow>\\<^sub>M\n          Pi\\<^sub>M {0..<Suc n} (\\<lambda>i. M)\n 2. (\\<lambda>x.\n        K (case n of 0 \\<Rightarrow> fst x | Suc xa \\<Rightarrow> snd x xa))\n    \\<in> M \\<Otimes>\\<^sub>M\n          Pi\\<^sub>M {0..<n} (\\<lambda>_. M) \\<rightarrow>\\<^sub>M\n          subprob_algebra M", "apply (rule measurable_PiM_single')"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>i.\n       i \\<in> {0..<Suc n} \\<Longrightarrow>\n       (\\<lambda>\\<omega>.\n           (case \\<omega> of (x, xa) \\<Rightarrow> (snd x)(n := xa)) i)\n       \\<in> (M \\<Otimes>\\<^sub>M\n              Pi\\<^sub>M {0..<n} (\\<lambda>_. M)) \\<Otimes>\\<^sub>M\n             M \\<rightarrow>\\<^sub>M\n             M\n 2. (\\<lambda>\\<omega>.\n        case \\<omega> of (x, xa) \\<Rightarrow> (snd x)(n := xa))\n    \\<in> space\n           ((M \\<Otimes>\\<^sub>M\n             Pi\\<^sub>M {0..<n} (\\<lambda>_. M)) \\<Otimes>\\<^sub>M\n            M) \\<rightarrow>\n          {0..<Suc n} \\<rightarrow>\\<^sub>E space M\n 3. (\\<lambda>x.\n        K (case n of 0 \\<Rightarrow> fst x | Suc xa \\<Rightarrow> snd x xa))\n    \\<in> M \\<Otimes>\\<^sub>M\n          Pi\\<^sub>M {0..<n} (\\<lambda>_. M) \\<rightarrow>\\<^sub>M\n          subprob_algebra M", "apply (simp add: split_beta')"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>i.\n       i < Suc n \\<Longrightarrow>\n       (\\<lambda>\\<omega>.\n           if i = n then snd \\<omega> else snd (fst \\<omega>) i)\n       \\<in> (M \\<Otimes>\\<^sub>M\n              Pi\\<^sub>M {0..<n} (\\<lambda>_. M)) \\<Otimes>\\<^sub>M\n             M \\<rightarrow>\\<^sub>M\n             M\n 2. (\\<lambda>\\<omega>.\n        case \\<omega> of (x, xa) \\<Rightarrow> (snd x)(n := xa))\n    \\<in> space\n           ((M \\<Otimes>\\<^sub>M\n             Pi\\<^sub>M {0..<n} (\\<lambda>_. M)) \\<Otimes>\\<^sub>M\n            M) \\<rightarrow>\n          {0..<Suc n} \\<rightarrow>\\<^sub>E space M\n 3. (\\<lambda>x.\n        K (case n of 0 \\<Rightarrow> fst x | Suc xa \\<Rightarrow> snd x xa))\n    \\<in> M \\<Otimes>\\<^sub>M\n          Pi\\<^sub>M {0..<n} (\\<lambda>_. M) \\<rightarrow>\\<^sub>M\n          subprob_algebra M", "subgoal for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. i < Suc n \\<Longrightarrow>\n    (\\<lambda>\\<omega>.\n        if i = n then snd \\<omega> else snd (fst \\<omega>) i)\n    \\<in> (M \\<Otimes>\\<^sub>M\n           Pi\\<^sub>M {0..<n} (\\<lambda>_. M)) \\<Otimes>\\<^sub>M\n          M \\<rightarrow>\\<^sub>M\n          M", "by (cases \"i = n\") auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. (\\<lambda>\\<omega>.\n        case \\<omega> of (x, xa) \\<Rightarrow> (snd x)(n := xa))\n    \\<in> space\n           ((M \\<Otimes>\\<^sub>M\n             Pi\\<^sub>M {0..<n} (\\<lambda>_. M)) \\<Otimes>\\<^sub>M\n            M) \\<rightarrow>\n          {0..<Suc n} \\<rightarrow>\\<^sub>E space M\n 2. (\\<lambda>x.\n        K (case n of 0 \\<Rightarrow> fst x | Suc xa \\<Rightarrow> snd x xa))\n    \\<in> M \\<Otimes>\\<^sub>M\n          Pi\\<^sub>M {0..<n} (\\<lambda>_. M) \\<rightarrow>\\<^sub>M\n          subprob_algebra M", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>\\<omega>.\n        case \\<omega> of (x, xa) \\<Rightarrow> (snd x)(n := xa))\n    \\<in> space\n           ((M \\<Otimes>\\<^sub>M\n             Pi\\<^sub>M {0..<n} (\\<lambda>_. M)) \\<Otimes>\\<^sub>M\n            M) \\<rightarrow>\n          {0..<Suc n} \\<rightarrow>\\<^sub>E space M", "by (auto simp: split_beta' PiE_iff extensional_def Pi_iff space_pair_measure space_PiM)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x.\n        K (case n of 0 \\<Rightarrow> fst x | Suc xa \\<Rightarrow> snd x xa))\n    \\<in> M \\<Otimes>\\<^sub>M\n          Pi\\<^sub>M {0..<n} (\\<lambda>_. M) \\<rightarrow>\\<^sub>M\n          subprob_algebra M", "apply (rule measurable_prob_algebraD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x.\n        K (case n of 0 \\<Rightarrow> fst x | Suc xa \\<Rightarrow> snd x xa))\n    \\<in> M \\<Otimes>\\<^sub>M\n          Pi\\<^sub>M {0..<n} (\\<lambda>_. M) \\<rightarrow>\\<^sub>M\n          prob_algebra M", "apply (rule measurable_compose[OF _ K])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x.\n        case n of 0 \\<Rightarrow> fst x | Suc xa \\<Rightarrow> snd x xa)\n    \\<in> M \\<Otimes>\\<^sub>M\n          Pi\\<^sub>M {0..<n} (\\<lambda>_. M) \\<rightarrow>\\<^sub>M\n          M", "apply measurable"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (\\<lambda>w.\n      case w of\n      (x, xa) \\<Rightarrow>\n        distr (K' x n xa) (Pi\\<^sub>M {0..<Suc n} (\\<lambda>i. M))\n         (fun_upd xa n))\n  \\<in> M \\<Otimes>\\<^sub>M\n        Pi\\<^sub>M {0..<n} (\\<lambda>_. M) \\<rightarrow>\\<^sub>M\n        subprob_algebra (Pi\\<^sub>M {0..<Suc n} (\\<lambda>_. M))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<lambda>x.\n      Ionescu_Tulcea.C (K' x) (\\<lambda>_. M) 0 n (\\<lambda>x. undefined))\n  \\<in> M \\<rightarrow>\\<^sub>M\n        subprob_algebra (Pi\\<^sub>M {0..<n} (\\<lambda>_. M))\n\ngoal (1 subgoal):\n 1. \\<And>A.\n       A \\<in> prod_algebra UNIV (\\<lambda>i. M) \\<Longrightarrow>\n       (\\<lambda>a. emeasure (lim_sequence a) A) \\<in> borel_measurable M", "have \"(\\<lambda>a. emeasure (lim_sequence a) X) \\<in> borel_measurable M \\<longleftrightarrow>\n    (\\<lambda>a. emeasure (Ionescu_Tulcea.CI (K' a) (\\<lambda>_. M) J) (Pi\\<^sub>E J F)) \\<in> borel_measurable M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>a. emeasure (lim_sequence a) X) \\<in> borel_measurable M) =\n    ((\\<lambda>a.\n         emeasure (Ionescu_Tulcea.CI (K' a) (\\<lambda>_. M) J)\n          (Pi\\<^sub>E J F))\n     \\<in> borel_measurable M)", "unfolding X"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>a.\n         emeasure (lim_sequence a)\n          (prod_emb UNIV (\\<lambda>_. M) J (Pi\\<^sub>E J F)))\n     \\<in> borel_measurable M) =\n    ((\\<lambda>a.\n         emeasure (Ionescu_Tulcea.CI (K' a) (\\<lambda>_. M) J)\n          (Pi\\<^sub>E J F))\n     \\<in> borel_measurable M)", "using J Pi_F"], ["proof (prove)\nusing this:\n  J \\<noteq> {}\n  finite J\n  F \\<in> J \\<rightarrow> sets M\n  finite J\n  Pi\\<^sub>E J F \\<in> sets (Pi\\<^sub>M J (\\<lambda>_. M))\n\ngoal (1 subgoal):\n 1. ((\\<lambda>a.\n         emeasure (lim_sequence a)\n          (prod_emb UNIV (\\<lambda>_. M) J (Pi\\<^sub>E J F)))\n     \\<in> borel_measurable M) =\n    ((\\<lambda>a.\n         emeasure (Ionescu_Tulcea.CI (K' a) (\\<lambda>_. M) J)\n          (Pi\\<^sub>E J F))\n     \\<in> borel_measurable M)", "by (intro measurable_cong emeasure_lim_sequence_emb) auto"], ["proof (state)\nthis:\n  ((\\<lambda>a. emeasure (lim_sequence a) X) \\<in> borel_measurable M) =\n  ((\\<lambda>a.\n       emeasure (Ionescu_Tulcea.CI (K' a) (\\<lambda>_. M) J)\n        (Pi\\<^sub>E J F))\n   \\<in> borel_measurable M)\n\ngoal (1 subgoal):\n 1. \\<And>A.\n       A \\<in> prod_algebra UNIV (\\<lambda>i. M) \\<Longrightarrow>\n       (\\<lambda>a. emeasure (lim_sequence a) A) \\<in> borel_measurable M", "also"], ["proof (state)\nthis:\n  ((\\<lambda>a. emeasure (lim_sequence a) X) \\<in> borel_measurable M) =\n  ((\\<lambda>a.\n       emeasure (Ionescu_Tulcea.CI (K' a) (\\<lambda>_. M) J)\n        (Pi\\<^sub>E J F))\n   \\<in> borel_measurable M)\n\ngoal (1 subgoal):\n 1. \\<And>A.\n       A \\<in> prod_algebra UNIV (\\<lambda>i. M) \\<Longrightarrow>\n       (\\<lambda>a. emeasure (lim_sequence a) A) \\<in> borel_measurable M", "have \"\\<dots>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>a.\n        emeasure (Ionescu_Tulcea.CI (K' a) (\\<lambda>_. M) J)\n         (Pi\\<^sub>E J F))\n    \\<in> borel_measurable M", "apply (intro measurable_compose[OF _ measurable_emeasure_subprob_algebra[OF Pi_F(2)]])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. Ionescu_Tulcea.CI (K' x) (\\<lambda>_. M) J)\n    \\<in> M \\<rightarrow>\\<^sub>M\n          subprob_algebra (Pi\\<^sub>M J (\\<lambda>_. M))", "apply (subst measurable_cong)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>w.\n       w \\<in> space M \\<Longrightarrow>\n       Ionescu_Tulcea.CI (K' w) (\\<lambda>_. M) J = ?g3 w\n 2. ?g3\n    \\<in> M \\<rightarrow>\\<^sub>M\n          subprob_algebra (Pi\\<^sub>M J (\\<lambda>_. M))", "apply (subst Ionescu_Tulcea.CI_def[OF IT_K'])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>w. w \\<in> space M \\<Longrightarrow> w \\<in> space M\n 2. \\<And>w.\n       w \\<in> space M \\<Longrightarrow>\n       distr\n        (Ionescu_Tulcea.C (K' w) (\\<lambda>_. M) 0 (Ionescu_Tulcea.up_to J)\n          (\\<lambda>x. undefined))\n        (Pi\\<^sub>M J (\\<lambda>_. M)) (\\<lambda>f. restrict f J) =\n       ?g5 w w\n 3. (\\<lambda>w. ?g5 w w)\n    \\<in> M \\<rightarrow>\\<^sub>M\n          subprob_algebra (Pi\\<^sub>M J (\\<lambda>_. M))", "apply assumption"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>w.\n       w \\<in> space M \\<Longrightarrow>\n       distr\n        (Ionescu_Tulcea.C (K' w) (\\<lambda>_. M) 0 (Ionescu_Tulcea.up_to J)\n          (\\<lambda>x. undefined))\n        (Pi\\<^sub>M J (\\<lambda>_. M)) (\\<lambda>f. restrict f J) =\n       ?g5 w w\n 2. (\\<lambda>w. ?g5 w w)\n    \\<in> M \\<rightarrow>\\<^sub>M\n          subprob_algebra (Pi\\<^sub>M J (\\<lambda>_. M))", "apply (subst Ionescu_Tulcea.up_to_def[OF IT_K'])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>w. w \\<in> space M \\<Longrightarrow> ?x8 w \\<in> space M\n 2. \\<And>w.\n       w \\<in> space M \\<Longrightarrow>\n       distr\n        (Ionescu_Tulcea.C (K' w) (\\<lambda>_. M) 0\n          (LEAST n. \\<forall>i\\<ge>n. i \\<notin> J) (\\<lambda>x. undefined))\n        (Pi\\<^sub>M J (\\<lambda>_. M)) (\\<lambda>f. restrict f J) =\n       ?g8 w w w\n 3. (\\<lambda>w. ?g5 w w)\n    \\<in> M \\<rightarrow>\\<^sub>M\n          subprob_algebra (Pi\\<^sub>M J (\\<lambda>_. M))\nflex-flex pairs:\n  \\<lambda>w. ?g8 w w w \\<equiv>\\<^sup>? \\<lambda>w. ?g5 w w", "apply assumption"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>w.\n       w \\<in> space M \\<Longrightarrow>\n       distr\n        (Ionescu_Tulcea.C (K' w) (\\<lambda>_. M) 0\n          (LEAST n. \\<forall>i\\<ge>n. i \\<notin> J) (\\<lambda>x. undefined))\n        (Pi\\<^sub>M J (\\<lambda>_. M)) (\\<lambda>f. restrict f J) =\n       ?g8 w w w\n 2. (\\<lambda>w. ?g5 w w)\n    \\<in> M \\<rightarrow>\\<^sub>M\n          subprob_algebra (Pi\\<^sub>M J (\\<lambda>_. M))\nflex-flex pairs:\n  \\<lambda>w. ?g8 w w w \\<equiv>\\<^sup>? \\<lambda>w. ?g5 w w", "unfolding n_def[symmetric]"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>w.\n       w \\<in> space M \\<Longrightarrow>\n       distr\n        (Ionescu_Tulcea.C (K' w) (\\<lambda>_. M) 0 n\n          (\\<lambda>x. undefined))\n        (Pi\\<^sub>M J (\\<lambda>_. M)) (\\<lambda>f. restrict f J) =\n       ?g8 w w w\n 2. (\\<lambda>w. ?g5 w w)\n    \\<in> M \\<rightarrow>\\<^sub>M\n          subprob_algebra (Pi\\<^sub>M J (\\<lambda>_. M))\nflex-flex pairs:\n  \\<lambda>w. ?g8 w w w \\<equiv>\\<^sup>? \\<lambda>w. ?g5 w w", "apply (rule refl)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>w.\n        distr\n         (Ionescu_Tulcea.C (K' w) (\\<lambda>_. M) 0 n\n           (\\<lambda>x. undefined))\n         (Pi\\<^sub>M J (\\<lambda>_. M)) (\\<lambda>f. restrict f J))\n    \\<in> M \\<rightarrow>\\<^sub>M\n          subprob_algebra (Pi\\<^sub>M J (\\<lambda>_. M))", "apply (rule measurable_compose[OF _ measurable_distr[OF measurable_restrict_subset[OF J_le_n]]])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x.\n        Ionescu_Tulcea.C (K' x) (\\<lambda>_. M) 0 n (\\<lambda>x. undefined))\n    \\<in> M \\<rightarrow>\\<^sub>M\n          subprob_algebra (Pi\\<^sub>M {0..<n} (\\<lambda>_. M))", "apply (rule C)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (\\<lambda>a.\n      emeasure (Ionescu_Tulcea.CI (K' a) (\\<lambda>_. M) J)\n       (Pi\\<^sub>E J F))\n  \\<in> borel_measurable M\n\ngoal (1 subgoal):\n 1. \\<And>A.\n       A \\<in> prod_algebra UNIV (\\<lambda>i. M) \\<Longrightarrow>\n       (\\<lambda>a. emeasure (lim_sequence a) A) \\<in> borel_measurable M", "finally"], ["proof (chain)\npicking this:\n  (\\<lambda>a. emeasure (lim_sequence a) X) \\<in> borel_measurable M", "show \"(\\<lambda>a. emeasure (lim_sequence a) X) \\<in> borel_measurable M\""], ["proof (prove)\nusing this:\n  (\\<lambda>a. emeasure (lim_sequence a) X) \\<in> borel_measurable M\n\ngoal (1 subgoal):\n 1. (\\<lambda>a. emeasure (lim_sequence a) X) \\<in> borel_measurable M", "."], ["proof (state)\nthis:\n  (\\<lambda>a. emeasure (lim_sequence a) X) \\<in> borel_measurable M\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma step_C:\n  assumes x: \"x \\<in> space M\"\n  shows \"Ionescu_Tulcea.C (K' x) (\\<lambda>_. M) 0 1 (\\<lambda>_. undefined) \\<bind> Ionescu_Tulcea.C (K' x) (\\<lambda>_. M) 1 n =\n    K x \\<bind> (\\<lambda>y. Ionescu_Tulcea.C (K' x) (\\<lambda>_. M) 1 n (case_nat y (\\<lambda>_. undefined)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ionescu_Tulcea.C (K' x) (\\<lambda>_. M) 0 1\n     (\\<lambda>_. undefined) \\<bind>\n    Ionescu_Tulcea.C (K' x) (\\<lambda>_. M) 1 n =\n    K x \\<bind>\n    (\\<lambda>y.\n        Ionescu_Tulcea.C (K' x) (\\<lambda>_. M) 1 n\n         (case_nat y (\\<lambda>_. undefined)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Ionescu_Tulcea.C (K' x) (\\<lambda>_. M) 0 1\n     (\\<lambda>_. undefined) \\<bind>\n    Ionescu_Tulcea.C (K' x) (\\<lambda>_. M) 1 n =\n    K x \\<bind>\n    (\\<lambda>y.\n        Ionescu_Tulcea.C (K' x) (\\<lambda>_. M) 1 n\n         (case_nat y (\\<lambda>_. undefined)))", "interpret Ionescu_Tulcea \"K' x\" \"\\<lambda>_. M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ionescu_Tulcea (K' x) (\\<lambda>_. M)", "using x"], ["proof (prove)\nusing this:\n  x \\<in> space M\n\ngoal (1 subgoal):\n 1. Ionescu_Tulcea (K' x) (\\<lambda>_. M)", "by (rule IT_K')"], ["proof (state)\ngoal (1 subgoal):\n 1. C 0 1 (\\<lambda>_. undefined) \\<bind> C 1 n =\n    K x \\<bind> (\\<lambda>y. C 1 n (case_nat y (\\<lambda>_. undefined)))", "have [simp]: \"space (K x) \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. space (K x) \\<noteq> {}", "using space_K[OF x] x"], ["proof (prove)\nusing this:\n  space (K x) = space M\n  x \\<in> space M\n\ngoal (1 subgoal):\n 1. space (K x) \\<noteq> {}", "by auto"], ["proof (state)\nthis:\n  space (K x) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. C 0 1 (\\<lambda>_. undefined) \\<bind> C 1 n =\n    K x \\<bind> (\\<lambda>y. C 1 n (case_nat y (\\<lambda>_. undefined)))", "have [simp]: \"((\\<lambda>_. undefined::'a)(0 := x)) = case_nat x (\\<lambda>_. undefined)\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>_. undefined)(0 := x) = case_nat x (\\<lambda>_. undefined)", "by (auto simp: fun_eq_iff split: nat.split)"], ["proof (state)\nthis:\n  (\\<lambda>_. undefined)(0 := ?x) = case_nat ?x (\\<lambda>_. undefined)\n\ngoal (1 subgoal):\n 1. C 0 1 (\\<lambda>_. undefined) \\<bind> C 1 n =\n    K x \\<bind> (\\<lambda>y. C 1 n (case_nat y (\\<lambda>_. undefined)))", "have \"C 0 1 (\\<lambda>_. undefined) \\<bind> C 1 n = eP 0 (\\<lambda>_. undefined) \\<bind> C 1 n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C 0 1 (\\<lambda>_. undefined) \\<bind> C 1 n =\n    eP 0 (\\<lambda>_. undefined) \\<bind> C 1 n", "using measurable_eP[of 0] measurable_C[of 1 n, measurable del]"], ["proof (prove)\nusing this:\n  eP 0\n  \\<in> Pi\\<^sub>M {0..<0} (\\<lambda>_. M) \\<rightarrow>\\<^sub>M\n        subprob_algebra (Pi\\<^sub>M {0..<Suc 0} (\\<lambda>_. M))\n  C 1 n\n  \\<in> Pi\\<^sub>M {0..<1} (\\<lambda>_. M) \\<rightarrow>\\<^sub>M\n        subprob_algebra (Pi\\<^sub>M {0..<1 + n} (\\<lambda>_. M))\n\ngoal (1 subgoal):\n 1. C 0 1 (\\<lambda>_. undefined) \\<bind> C 1 n =\n    eP 0 (\\<lambda>_. undefined) \\<bind> C 1 n", "by (simp add: bind_return[where N=\"Pi\\<^sub>M {0} (\\<lambda>_. M)\"])"], ["proof (state)\nthis:\n  C 0 1 (\\<lambda>_. undefined) \\<bind> C 1 n =\n  eP 0 (\\<lambda>_. undefined) \\<bind> C 1 n\n\ngoal (1 subgoal):\n 1. C 0 1 (\\<lambda>_. undefined) \\<bind> C 1 n =\n    K x \\<bind> (\\<lambda>y. C 1 n (case_nat y (\\<lambda>_. undefined)))", "also"], ["proof (state)\nthis:\n  C 0 1 (\\<lambda>_. undefined) \\<bind> C 1 n =\n  eP 0 (\\<lambda>_. undefined) \\<bind> C 1 n\n\ngoal (1 subgoal):\n 1. C 0 1 (\\<lambda>_. undefined) \\<bind> C 1 n =\n    K x \\<bind> (\\<lambda>y. C 1 n (case_nat y (\\<lambda>_. undefined)))", "have \"\\<dots> = K x \\<bind> (\\<lambda>y. C 1 n (case_nat y (\\<lambda>_. undefined)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eP 0 (\\<lambda>_. undefined) \\<bind> C 1 n =\n    K x \\<bind> (\\<lambda>y. C 1 n (case_nat y (\\<lambda>_. undefined)))", "using measurable_C[of 1 n, measurable del] x[THEN sets_K]"], ["proof (prove)\nusing this:\n  C 1 n\n  \\<in> Pi\\<^sub>M {0..<1} (\\<lambda>_. M) \\<rightarrow>\\<^sub>M\n        subprob_algebra (Pi\\<^sub>M {0..<1 + n} (\\<lambda>_. M))\n  sets (K x) = sets M\n\ngoal (1 subgoal):\n 1. eP 0 (\\<lambda>_. undefined) \\<bind> C 1 n =\n    K x \\<bind> (\\<lambda>y. C 1 n (case_nat y (\\<lambda>_. undefined)))", "by (simp add: eP_def K'_def bind_distr cong: measurable_cong_sets)"], ["proof (state)\nthis:\n  eP 0 (\\<lambda>_. undefined) \\<bind> C 1 n =\n  K x \\<bind> (\\<lambda>y. C 1 n (case_nat y (\\<lambda>_. undefined)))\n\ngoal (1 subgoal):\n 1. C 0 1 (\\<lambda>_. undefined) \\<bind> C 1 n =\n    K x \\<bind> (\\<lambda>y. C 1 n (case_nat y (\\<lambda>_. undefined)))", "finally"], ["proof (chain)\npicking this:\n  C 0 1 (\\<lambda>_. undefined) \\<bind> C 1 n =\n  K x \\<bind> (\\<lambda>y. C 1 n (case_nat y (\\<lambda>_. undefined)))", "show \"C 0 1 (\\<lambda>_. undefined) \\<bind> C 1 n = K x \\<bind> (\\<lambda>y. C 1 n (case_nat y (\\<lambda>_. undefined)))\""], ["proof (prove)\nusing this:\n  C 0 1 (\\<lambda>_. undefined) \\<bind> C 1 n =\n  K x \\<bind> (\\<lambda>y. C 1 n (case_nat y (\\<lambda>_. undefined)))\n\ngoal (1 subgoal):\n 1. C 0 1 (\\<lambda>_. undefined) \\<bind> C 1 n =\n    K x \\<bind> (\\<lambda>y. C 1 n (case_nat y (\\<lambda>_. undefined)))", "."], ["proof (state)\nthis:\n  C 0 1 (\\<lambda>_. undefined) \\<bind> C 1 n =\n  K x \\<bind> (\\<lambda>y. C 1 n (case_nat y (\\<lambda>_. undefined)))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lim_sequence_eq:\n  assumes x: \"x \\<in> space M\"\n  shows \"lim_sequence x = bind (K x) (\\<lambda>y. distr (lim_sequence y) (\\<Pi>\\<^sub>M j\\<in>UNIV. M) (case_nat y))\"\n    (is \"_ = ?B x\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. lim_sequence x =\n    K x \\<bind>\n    (\\<lambda>y.\n        distr (lim_sequence y) (Pi\\<^sub>M UNIV (\\<lambda>j. M))\n         (case_nat y))", "proof (rule measure_eqI_PiM_infinite)"], ["proof (state)\ngoal (4 subgoals):\n 1. sets (lim_sequence x) = sets (Pi\\<^sub>M ?I ?M)\n 2. sets\n     (K x \\<bind>\n      (\\<lambda>y.\n          distr (lim_sequence y) (Pi\\<^sub>M UNIV (\\<lambda>j. M))\n           (case_nat y))) =\n    sets (Pi\\<^sub>M ?I ?M)\n 3. \\<And>A J.\n       \\<lbrakk>finite J; J \\<subseteq> ?I;\n        \\<And>i. i \\<in> J \\<Longrightarrow> A i \\<in> sets (?M i)\\<rbrakk>\n       \\<Longrightarrow> emeasure (lim_sequence x)\n                          (prod_emb ?I ?M J (Pi\\<^sub>E J A)) =\n                         emeasure\n                          (K x \\<bind>\n                           (\\<lambda>y.\n                               distr (lim_sequence y)\n                                (Pi\\<^sub>M UNIV (\\<lambda>j. M))\n                                (case_nat y)))\n                          (prod_emb ?I ?M J (Pi\\<^sub>E J A))\n 4. finite_measure (lim_sequence x)", "show \"sets (lim_sequence x) = sets (\\<Pi>\\<^sub>M j\\<in>UNIV. M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sets (lim_sequence x) = sets (Pi\\<^sub>M UNIV (\\<lambda>j. M))", "using x"], ["proof (prove)\nusing this:\n  x \\<in> space M\n\ngoal (1 subgoal):\n 1. sets (lim_sequence x) = sets (Pi\\<^sub>M UNIV (\\<lambda>j. M))", "by (rule sets_lim_sequence)"], ["proof (state)\nthis:\n  sets (lim_sequence x) = sets (Pi\\<^sub>M UNIV (\\<lambda>j. M))\n\ngoal (3 subgoals):\n 1. sets\n     (K x \\<bind>\n      (\\<lambda>y.\n          distr (lim_sequence y) (Pi\\<^sub>M UNIV (\\<lambda>j. M))\n           (case_nat y))) =\n    sets (Pi\\<^sub>M UNIV (\\<lambda>j. M))\n 2. \\<And>A J.\n       \\<lbrakk>finite J; J \\<subseteq> UNIV;\n        \\<And>i. i \\<in> J \\<Longrightarrow> A i \\<in> sets M\\<rbrakk>\n       \\<Longrightarrow> emeasure (lim_sequence x)\n                          (prod_emb UNIV (\\<lambda>j. M) J\n                            (Pi\\<^sub>E J A)) =\n                         emeasure\n                          (K x \\<bind>\n                           (\\<lambda>y.\n                               distr (lim_sequence y)\n                                (Pi\\<^sub>M UNIV (\\<lambda>j. M))\n                                (case_nat y)))\n                          (prod_emb UNIV (\\<lambda>j. M) J (Pi\\<^sub>E J A))\n 3. finite_measure (lim_sequence x)", "have [simp]: \"space (K x) \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. space (K x) \\<noteq> {}", "using space_K[OF x] x"], ["proof (prove)\nusing this:\n  space (K x) = space M\n  x \\<in> space M\n\ngoal (1 subgoal):\n 1. space (K x) \\<noteq> {}", "by auto"], ["proof (state)\nthis:\n  space (K x) \\<noteq> {}\n\ngoal (3 subgoals):\n 1. sets\n     (K x \\<bind>\n      (\\<lambda>y.\n          distr (lim_sequence y) (Pi\\<^sub>M UNIV (\\<lambda>j. M))\n           (case_nat y))) =\n    sets (Pi\\<^sub>M UNIV (\\<lambda>j. M))\n 2. \\<And>A J.\n       \\<lbrakk>finite J; J \\<subseteq> UNIV;\n        \\<And>i. i \\<in> J \\<Longrightarrow> A i \\<in> sets M\\<rbrakk>\n       \\<Longrightarrow> emeasure (lim_sequence x)\n                          (prod_emb UNIV (\\<lambda>j. M) J\n                            (Pi\\<^sub>E J A)) =\n                         emeasure\n                          (K x \\<bind>\n                           (\\<lambda>y.\n                               distr (lim_sequence y)\n                                (Pi\\<^sub>M UNIV (\\<lambda>j. M))\n                                (case_nat y)))\n                          (prod_emb UNIV (\\<lambda>j. M) J (Pi\\<^sub>E J A))\n 3. finite_measure (lim_sequence x)", "show \"sets (?B x) = sets (Pi\\<^sub>M UNIV (\\<lambda>j. M))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sets\n     (K x \\<bind>\n      (\\<lambda>y.\n          distr (lim_sequence y) (Pi\\<^sub>M UNIV (\\<lambda>j. M))\n           (\\<lambda>a aa.\n               case aa of 0 \\<Rightarrow> y | Suc aa \\<Rightarrow> a aa))) =\n    sets (Pi\\<^sub>M UNIV (\\<lambda>j. M))", "using x"], ["proof (prove)\nusing this:\n  x \\<in> space M\n\ngoal (1 subgoal):\n 1. sets\n     (K x \\<bind>\n      (\\<lambda>y.\n          distr (lim_sequence y) (Pi\\<^sub>M UNIV (\\<lambda>j. M))\n           (\\<lambda>a aa.\n               case aa of 0 \\<Rightarrow> y | Suc aa \\<Rightarrow> a aa))) =\n    sets (Pi\\<^sub>M UNIV (\\<lambda>j. M))", "by (subst sets_bind) auto"], ["proof (state)\nthis:\n  sets\n   (K x \\<bind>\n    (\\<lambda>y.\n        distr (lim_sequence y) (Pi\\<^sub>M UNIV (\\<lambda>j. M))\n         (\\<lambda>a aa.\n             case aa of 0 \\<Rightarrow> y | Suc aa \\<Rightarrow> a aa))) =\n  sets (Pi\\<^sub>M UNIV (\\<lambda>j. M))\n\ngoal (2 subgoals):\n 1. \\<And>A J.\n       \\<lbrakk>finite J; J \\<subseteq> UNIV;\n        \\<And>i. i \\<in> J \\<Longrightarrow> A i \\<in> sets M\\<rbrakk>\n       \\<Longrightarrow> emeasure (lim_sequence x)\n                          (prod_emb UNIV (\\<lambda>j. M) J\n                            (Pi\\<^sub>E J A)) =\n                         emeasure\n                          (K x \\<bind>\n                           (\\<lambda>y.\n                               distr (lim_sequence y)\n                                (Pi\\<^sub>M UNIV (\\<lambda>j. M))\n                                (case_nat y)))\n                          (prod_emb UNIV (\\<lambda>j. M) J (Pi\\<^sub>E J A))\n 2. finite_measure (lim_sequence x)", "interpret lim_sequence: prob_space \"lim_sequence x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prob_space (lim_sequence x)", "using lim_sequence x"], ["proof (prove)\nusing this:\n  lim_sequence\n  \\<in> M \\<rightarrow>\\<^sub>M\n        prob_algebra (Pi\\<^sub>M UNIV (\\<lambda>i. M))\n  x \\<in> space M\n\ngoal (1 subgoal):\n 1. prob_space (lim_sequence x)", "by (auto simp: measurable_restrict_space2_iff prob_algebra_def)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>A J.\n       \\<lbrakk>finite J; J \\<subseteq> UNIV;\n        \\<And>i. i \\<in> J \\<Longrightarrow> A i \\<in> sets M\\<rbrakk>\n       \\<Longrightarrow> emeasure (lim_sequence x)\n                          (prod_emb UNIV (\\<lambda>j. M) J\n                            (Pi\\<^sub>E J A)) =\n                         emeasure\n                          (K x \\<bind>\n                           (\\<lambda>y.\n                               distr (lim_sequence y)\n                                (Pi\\<^sub>M UNIV (\\<lambda>j. M))\n                                (case_nat y)))\n                          (prod_emb UNIV (\\<lambda>j. M) J (Pi\\<^sub>E J A))\n 2. finite_measure (lim_sequence x)", "show \"finite_measure (lim_sequence x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_measure (lim_sequence x)", "by (rule lim_sequence.finite_measure)"], ["proof (state)\nthis:\n  finite_measure (lim_sequence x)\n\ngoal (1 subgoal):\n 1. \\<And>A J.\n       \\<lbrakk>finite J; J \\<subseteq> UNIV;\n        \\<And>i. i \\<in> J \\<Longrightarrow> A i \\<in> sets M\\<rbrakk>\n       \\<Longrightarrow> emeasure (lim_sequence x)\n                          (prod_emb UNIV (\\<lambda>j. M) J\n                            (Pi\\<^sub>E J A)) =\n                         emeasure\n                          (K x \\<bind>\n                           (\\<lambda>y.\n                               distr (lim_sequence y)\n                                (Pi\\<^sub>M UNIV (\\<lambda>j. M))\n                                (case_nat y)))\n                          (prod_emb UNIV (\\<lambda>j. M) J (Pi\\<^sub>E J A))", "interpret Ionescu_Tulcea \"K' x\" \"\\<lambda>_. M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ionescu_Tulcea (K' x) (\\<lambda>_. M)", "using x"], ["proof (prove)\nusing this:\n  x \\<in> space M\n\ngoal (1 subgoal):\n 1. Ionescu_Tulcea (K' x) (\\<lambda>_. M)", "by (rule IT_K')"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>A J.\n       \\<lbrakk>finite J; J \\<subseteq> UNIV;\n        \\<And>i. i \\<in> J \\<Longrightarrow> A i \\<in> sets M\\<rbrakk>\n       \\<Longrightarrow> emeasure (lim_sequence x)\n                          (PF.emb UNIV J (Pi\\<^sub>E J A)) =\n                         emeasure\n                          (K x \\<bind>\n                           (\\<lambda>y.\n                               distr (lim_sequence y)\n                                (Pi\\<^sub>M UNIV (\\<lambda>j. M))\n                                (case_nat y)))\n                          (PF.emb UNIV J (Pi\\<^sub>E J A))", "let ?U = \"\\<lambda>_::nat. undefined :: 'a\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>A J.\n       \\<lbrakk>finite J; J \\<subseteq> UNIV;\n        \\<And>i. i \\<in> J \\<Longrightarrow> A i \\<in> sets M\\<rbrakk>\n       \\<Longrightarrow> emeasure (lim_sequence x)\n                          (PF.emb UNIV J (Pi\\<^sub>E J A)) =\n                         emeasure\n                          (K x \\<bind>\n                           (\\<lambda>y.\n                               distr (lim_sequence y)\n                                (Pi\\<^sub>M UNIV (\\<lambda>j. M))\n                                (case_nat y)))\n                          (PF.emb UNIV J (Pi\\<^sub>E J A))", "fix J :: \"nat set\" and F'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>A J.\n       \\<lbrakk>finite J; J \\<subseteq> UNIV;\n        \\<And>i. i \\<in> J \\<Longrightarrow> A i \\<in> sets M\\<rbrakk>\n       \\<Longrightarrow> emeasure (lim_sequence x)\n                          (PF.emb UNIV J (Pi\\<^sub>E J A)) =\n                         emeasure\n                          (K x \\<bind>\n                           (\\<lambda>y.\n                               distr (lim_sequence y)\n                                (Pi\\<^sub>M UNIV (\\<lambda>j. M))\n                                (case_nat y)))\n                          (PF.emb UNIV J (Pi\\<^sub>E J A))", "assume J: \"finite J\" \"\\<And>i. i \\<in> J \\<Longrightarrow> F' i \\<in> sets M\""], ["proof (state)\nthis:\n  finite J\n  ?i1 \\<in> J \\<Longrightarrow> F' ?i1 \\<in> sets M\n\ngoal (1 subgoal):\n 1. \\<And>A J.\n       \\<lbrakk>finite J; J \\<subseteq> UNIV;\n        \\<And>i. i \\<in> J \\<Longrightarrow> A i \\<in> sets M\\<rbrakk>\n       \\<Longrightarrow> emeasure (lim_sequence x)\n                          (PF.emb UNIV J (Pi\\<^sub>E J A)) =\n                         emeasure\n                          (K x \\<bind>\n                           (\\<lambda>y.\n                               distr (lim_sequence y)\n                                (Pi\\<^sub>M UNIV (\\<lambda>j. M))\n                                (case_nat y)))\n                          (PF.emb UNIV J (Pi\\<^sub>E J A))", "define n where \"n = (if J = {} then 0 else Max J)\""], ["proof (state)\nthis:\n  n = (if J = {} then 0 else Max J)\n\ngoal (1 subgoal):\n 1. \\<And>A J.\n       \\<lbrakk>finite J; J \\<subseteq> UNIV;\n        \\<And>i. i \\<in> J \\<Longrightarrow> A i \\<in> sets M\\<rbrakk>\n       \\<Longrightarrow> emeasure (lim_sequence x)\n                          (PF.emb UNIV J (Pi\\<^sub>E J A)) =\n                         emeasure\n                          (K x \\<bind>\n                           (\\<lambda>y.\n                               distr (lim_sequence y)\n                                (Pi\\<^sub>M UNIV (\\<lambda>j. M))\n                                (case_nat y)))\n                          (PF.emb UNIV J (Pi\\<^sub>E J A))", "define F where \"F i = (if i \\<in> J then F' i else space M)\" for i"], ["proof (state)\nthis:\n  F ?i = (if ?i \\<in> J then F' ?i else space M)\n\ngoal (1 subgoal):\n 1. \\<And>A J.\n       \\<lbrakk>finite J; J \\<subseteq> UNIV;\n        \\<And>i. i \\<in> J \\<Longrightarrow> A i \\<in> sets M\\<rbrakk>\n       \\<Longrightarrow> emeasure (lim_sequence x)\n                          (PF.emb UNIV J (Pi\\<^sub>E J A)) =\n                         emeasure\n                          (K x \\<bind>\n                           (\\<lambda>y.\n                               distr (lim_sequence y)\n                                (Pi\\<^sub>M UNIV (\\<lambda>j. M))\n                                (case_nat y)))\n                          (PF.emb UNIV J (Pi\\<^sub>E J A))", "then"], ["proof (chain)\npicking this:\n  F ?i = (if ?i \\<in> J then F' ?i else space M)", "have F[simp, measurable]: \"F i \\<in> sets M\" for i"], ["proof (prove)\nusing this:\n  F ?i = (if ?i \\<in> J then F' ?i else space M)\n\ngoal (1 subgoal):\n 1. F i \\<in> sets M", "using J"], ["proof (prove)\nusing this:\n  F ?i = (if ?i \\<in> J then F' ?i else space M)\n  finite J\n  ?i1 \\<in> J \\<Longrightarrow> F' ?i1 \\<in> sets M\n\ngoal (1 subgoal):\n 1. F i \\<in> sets M", "by auto"], ["proof (state)\nthis:\n  F ?i1 \\<in> sets M\n\ngoal (1 subgoal):\n 1. \\<And>A J.\n       \\<lbrakk>finite J; J \\<subseteq> UNIV;\n        \\<And>i. i \\<in> J \\<Longrightarrow> A i \\<in> sets M\\<rbrakk>\n       \\<Longrightarrow> emeasure (lim_sequence x)\n                          (PF.emb UNIV J (Pi\\<^sub>E J A)) =\n                         emeasure\n                          (K x \\<bind>\n                           (\\<lambda>y.\n                               distr (lim_sequence y)\n                                (Pi\\<^sub>M UNIV (\\<lambda>j. M))\n                                (case_nat y)))\n                          (PF.emb UNIV J (Pi\\<^sub>E J A))", "have emb_eq: \"PF.emb UNIV J (Pi\\<^sub>E J F') = PF.emb UNIV {0..<Suc n} (Pi\\<^sub>E {0..<Suc n} F)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. PF.emb UNIV J (Pi\\<^sub>E J F') =\n    PF.emb UNIV {0..<Suc n} (Pi\\<^sub>E {0..<Suc n} F)", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    PF.emb UNIV J (Pi\\<^sub>E J F') =\n    PF.emb UNIV {0..<Suc n} (Pi\\<^sub>E {0..<Suc n} F)\n 2. \\<not> ?P \\<Longrightarrow>\n    PF.emb UNIV J (Pi\\<^sub>E J F') =\n    PF.emb UNIV {0..<Suc n} (Pi\\<^sub>E {0..<Suc n} F)", "assume \"J = {}\""], ["proof (state)\nthis:\n  J = {}\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    PF.emb UNIV J (Pi\\<^sub>E J F') =\n    PF.emb UNIV {0..<Suc n} (Pi\\<^sub>E {0..<Suc n} F)\n 2. \\<not> ?P \\<Longrightarrow>\n    PF.emb UNIV J (Pi\\<^sub>E J F') =\n    PF.emb UNIV {0..<Suc n} (Pi\\<^sub>E {0..<Suc n} F)", "then"], ["proof (chain)\npicking this:\n  J = {}", "show ?thesis"], ["proof (prove)\nusing this:\n  J = {}\n\ngoal (1 subgoal):\n 1. PF.emb UNIV J (Pi\\<^sub>E J F') =\n    PF.emb UNIV {0..<Suc n} (Pi\\<^sub>E {0..<Suc n} F)", "by (auto simp add: n_def F_def[abs_def] prod_emb_def PiE_def)"], ["proof (state)\nthis:\n  PF.emb UNIV J (Pi\\<^sub>E J F') =\n  PF.emb UNIV {0..<Suc n} (Pi\\<^sub>E {0..<Suc n} F)\n\ngoal (1 subgoal):\n 1. J \\<noteq> {} \\<Longrightarrow>\n    PF.emb UNIV J (Pi\\<^sub>E J F') =\n    PF.emb UNIV {0..<Suc n} (Pi\\<^sub>E {0..<Suc n} F)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. J \\<noteq> {} \\<Longrightarrow>\n    PF.emb UNIV J (Pi\\<^sub>E J F') =\n    PF.emb UNIV {0..<Suc n} (Pi\\<^sub>E {0..<Suc n} F)", "assume \"J \\<noteq> {}\""], ["proof (state)\nthis:\n  J \\<noteq> {}\n\ngoal (1 subgoal):\n 1. J \\<noteq> {} \\<Longrightarrow>\n    PF.emb UNIV J (Pi\\<^sub>E J F') =\n    PF.emb UNIV {0..<Suc n} (Pi\\<^sub>E {0..<Suc n} F)", "then"], ["proof (chain)\npicking this:\n  J \\<noteq> {}", "show ?thesis"], ["proof (prove)\nusing this:\n  J \\<noteq> {}\n\ngoal (1 subgoal):\n 1. PF.emb UNIV J (Pi\\<^sub>E J F') =\n    PF.emb UNIV {0..<Suc n} (Pi\\<^sub>E {0..<Suc n} F)", "by (auto simp: prod_emb_def PiE_iff F_def n_def less_Suc_eq_le \\<open>finite J\\<close> split: if_split_asm)"], ["proof (state)\nthis:\n  PF.emb UNIV J (Pi\\<^sub>E J F') =\n  PF.emb UNIV {0..<Suc n} (Pi\\<^sub>E {0..<Suc n} F)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  PF.emb UNIV J (Pi\\<^sub>E J F') =\n  PF.emb UNIV {0..<Suc n} (Pi\\<^sub>E {0..<Suc n} F)\n\ngoal (1 subgoal):\n 1. \\<And>A J.\n       \\<lbrakk>finite J; J \\<subseteq> UNIV;\n        \\<And>i. i \\<in> J \\<Longrightarrow> A i \\<in> sets M\\<rbrakk>\n       \\<Longrightarrow> emeasure (lim_sequence x)\n                          (PF.emb UNIV J (Pi\\<^sub>E J A)) =\n                         emeasure\n                          (K x \\<bind>\n                           (\\<lambda>y.\n                               distr (lim_sequence y)\n                                (Pi\\<^sub>M UNIV (\\<lambda>j. M))\n                                (case_nat y)))\n                          (PF.emb UNIV J (Pi\\<^sub>E J A))", "have \"emeasure (lim_sequence x) (PF.emb UNIV J (Pi\\<^sub>E J F')) = emeasure (C 0 (Suc n) ?U) (Pi\\<^sub>E {0..<Suc n} F)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure (lim_sequence x) (PF.emb UNIV J (Pi\\<^sub>E J F')) =\n    emeasure (C 0 (Suc n) (\\<lambda>_. undefined))\n     (Pi\\<^sub>E {0..<Suc n} F)", "using x"], ["proof (prove)\nusing this:\n  x \\<in> space M\n\ngoal (1 subgoal):\n 1. emeasure (lim_sequence x) (PF.emb UNIV J (Pi\\<^sub>E J F')) =\n    emeasure (C 0 (Suc n) (\\<lambda>_. undefined))\n     (Pi\\<^sub>E {0..<Suc n} F)", "unfolding emb_eq"], ["proof (prove)\nusing this:\n  x \\<in> space M\n\ngoal (1 subgoal):\n 1. emeasure (lim_sequence x)\n     (PF.emb UNIV {0..<Suc n} (Pi\\<^sub>E {0..<Suc n} F)) =\n    emeasure (C 0 (Suc n) (\\<lambda>_. undefined))\n     (Pi\\<^sub>E {0..<Suc n} F)", "by (rule emeasure_lim_sequence_emb_I0o) (auto intro!: sets_PiM_I_finite)"], ["proof (state)\nthis:\n  emeasure (lim_sequence x) (PF.emb UNIV J (Pi\\<^sub>E J F')) =\n  emeasure (C 0 (Suc n) (\\<lambda>_. undefined)) (Pi\\<^sub>E {0..<Suc n} F)\n\ngoal (1 subgoal):\n 1. \\<And>A J.\n       \\<lbrakk>finite J; J \\<subseteq> UNIV;\n        \\<And>i. i \\<in> J \\<Longrightarrow> A i \\<in> sets M\\<rbrakk>\n       \\<Longrightarrow> emeasure (lim_sequence x)\n                          (PF.emb UNIV J (Pi\\<^sub>E J A)) =\n                         emeasure\n                          (K x \\<bind>\n                           (\\<lambda>y.\n                               distr (lim_sequence y)\n                                (Pi\\<^sub>M UNIV (\\<lambda>j. M))\n                                (case_nat y)))\n                          (PF.emb UNIV J (Pi\\<^sub>E J A))", "also"], ["proof (state)\nthis:\n  emeasure (lim_sequence x) (PF.emb UNIV J (Pi\\<^sub>E J F')) =\n  emeasure (C 0 (Suc n) (\\<lambda>_. undefined)) (Pi\\<^sub>E {0..<Suc n} F)\n\ngoal (1 subgoal):\n 1. \\<And>A J.\n       \\<lbrakk>finite J; J \\<subseteq> UNIV;\n        \\<And>i. i \\<in> J \\<Longrightarrow> A i \\<in> sets M\\<rbrakk>\n       \\<Longrightarrow> emeasure (lim_sequence x)\n                          (PF.emb UNIV J (Pi\\<^sub>E J A)) =\n                         emeasure\n                          (K x \\<bind>\n                           (\\<lambda>y.\n                               distr (lim_sequence y)\n                                (Pi\\<^sub>M UNIV (\\<lambda>j. M))\n                                (case_nat y)))\n                          (PF.emb UNIV J (Pi\\<^sub>E J A))", "have \"C 0 (Suc n) ?U = K x \\<bind> (\\<lambda>y. C 1 n (case_nat y ?U))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C 0 (Suc n) (\\<lambda>_. undefined) =\n    K x \\<bind> (\\<lambda>y. C 1 n (case_nat y (\\<lambda>_. undefined)))", "using split_C[of ?U 0 \"Suc 0\" n] step_C[OF x]"], ["proof (prove)\nusing this:\n  (\\<lambda>_. undefined)\n  \\<in> space (Pi\\<^sub>M {0..<0} (\\<lambda>_. M)) \\<Longrightarrow>\n  C 0 (Suc 0) (\\<lambda>_. undefined) \\<bind> C (0 + Suc 0) n =\n  C 0 (Suc 0 + n) (\\<lambda>_. undefined)\n  C 0 1 (\\<lambda>_. undefined) \\<bind> C 1 ?n =\n  K x \\<bind> (\\<lambda>y. C 1 ?n (case_nat y (\\<lambda>_. undefined)))\n\ngoal (1 subgoal):\n 1. C 0 (Suc n) (\\<lambda>_. undefined) =\n    K x \\<bind> (\\<lambda>y. C 1 n (case_nat y (\\<lambda>_. undefined)))", "by simp"], ["proof (state)\nthis:\n  C 0 (Suc n) (\\<lambda>_. undefined) =\n  K x \\<bind> (\\<lambda>y. C 1 n (case_nat y (\\<lambda>_. undefined)))\n\ngoal (1 subgoal):\n 1. \\<And>A J.\n       \\<lbrakk>finite J; J \\<subseteq> UNIV;\n        \\<And>i. i \\<in> J \\<Longrightarrow> A i \\<in> sets M\\<rbrakk>\n       \\<Longrightarrow> emeasure (lim_sequence x)\n                          (PF.emb UNIV J (Pi\\<^sub>E J A)) =\n                         emeasure\n                          (K x \\<bind>\n                           (\\<lambda>y.\n                               distr (lim_sequence y)\n                                (Pi\\<^sub>M UNIV (\\<lambda>j. M))\n                                (case_nat y)))\n                          (PF.emb UNIV J (Pi\\<^sub>E J A))", "also"], ["proof (state)\nthis:\n  C 0 (Suc n) (\\<lambda>_. undefined) =\n  K x \\<bind> (\\<lambda>y. C 1 n (case_nat y (\\<lambda>_. undefined)))\n\ngoal (1 subgoal):\n 1. \\<And>A J.\n       \\<lbrakk>finite J; J \\<subseteq> UNIV;\n        \\<And>i. i \\<in> J \\<Longrightarrow> A i \\<in> sets M\\<rbrakk>\n       \\<Longrightarrow> emeasure (lim_sequence x)\n                          (PF.emb UNIV J (Pi\\<^sub>E J A)) =\n                         emeasure\n                          (K x \\<bind>\n                           (\\<lambda>y.\n                               distr (lim_sequence y)\n                                (Pi\\<^sub>M UNIV (\\<lambda>j. M))\n                                (case_nat y)))\n                          (PF.emb UNIV J (Pi\\<^sub>E J A))", "have \"emeasure (K x \\<bind> (\\<lambda>y. C 1 n (case_nat y ?U))) (Pi\\<^sub>E {0..<Suc n} F) =\n    (\\<integral>\\<^sup>+y. C 1 n (case_nat y ?U) (Pi\\<^sub>E {0..<Suc n} F) \\<partial>K x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure\n     (K x \\<bind> (\\<lambda>y. C 1 n (case_nat y (\\<lambda>_. undefined))))\n     (Pi\\<^sub>E {0..<Suc n} F) =\n    \\<integral>\\<^sup>+ y. emeasure\n                            (C 1 n (case_nat y (\\<lambda>_. undefined)))\n                            (Pi\\<^sub>E {0..<Suc n} F)\n                       \\<partial>K x", "using measurable_C[of 1 n, measurable del] x[THEN sets_K] F x"], ["proof (prove)\nusing this:\n  C 1 n\n  \\<in> Pi\\<^sub>M {0..<1} (\\<lambda>_. M) \\<rightarrow>\\<^sub>M\n        subprob_algebra (Pi\\<^sub>M {0..<1 + n} (\\<lambda>_. M))\n  sets (K x) = sets M\n  F ?i1 \\<in> sets M\n  x \\<in> space M\n\ngoal (1 subgoal):\n 1. emeasure\n     (K x \\<bind> (\\<lambda>y. C 1 n (case_nat y (\\<lambda>_. undefined))))\n     (Pi\\<^sub>E {0..<Suc n} F) =\n    \\<integral>\\<^sup>+ y. emeasure\n                            (C 1 n (case_nat y (\\<lambda>_. undefined)))\n                            (Pi\\<^sub>E {0..<Suc n} F)\n                       \\<partial>K x", "by (intro emeasure_bind[OF  _ measurable_compose[OF _ measurable_C]])\n       (auto cong: measurable_cong_sets intro!: measurable_PiM_single' split: nat.split_asm)"], ["proof (state)\nthis:\n  emeasure\n   (K x \\<bind> (\\<lambda>y. C 1 n (case_nat y (\\<lambda>_. undefined))))\n   (Pi\\<^sub>E {0..<Suc n} F) =\n  \\<integral>\\<^sup>+ y. emeasure\n                          (C 1 n (case_nat y (\\<lambda>_. undefined)))\n                          (Pi\\<^sub>E {0..<Suc n} F)\n                     \\<partial>K x\n\ngoal (1 subgoal):\n 1. \\<And>A J.\n       \\<lbrakk>finite J; J \\<subseteq> UNIV;\n        \\<And>i. i \\<in> J \\<Longrightarrow> A i \\<in> sets M\\<rbrakk>\n       \\<Longrightarrow> emeasure (lim_sequence x)\n                          (PF.emb UNIV J (Pi\\<^sub>E J A)) =\n                         emeasure\n                          (K x \\<bind>\n                           (\\<lambda>y.\n                               distr (lim_sequence y)\n                                (Pi\\<^sub>M UNIV (\\<lambda>j. M))\n                                (case_nat y)))\n                          (PF.emb UNIV J (Pi\\<^sub>E J A))", "also"], ["proof (state)\nthis:\n  emeasure\n   (K x \\<bind> (\\<lambda>y. C 1 n (case_nat y (\\<lambda>_. undefined))))\n   (Pi\\<^sub>E {0..<Suc n} F) =\n  \\<integral>\\<^sup>+ y. emeasure\n                          (C 1 n (case_nat y (\\<lambda>_. undefined)))\n                          (Pi\\<^sub>E {0..<Suc n} F)\n                     \\<partial>K x\n\ngoal (1 subgoal):\n 1. \\<And>A J.\n       \\<lbrakk>finite J; J \\<subseteq> UNIV;\n        \\<And>i. i \\<in> J \\<Longrightarrow> A i \\<in> sets M\\<rbrakk>\n       \\<Longrightarrow> emeasure (lim_sequence x)\n                          (PF.emb UNIV J (Pi\\<^sub>E J A)) =\n                         emeasure\n                          (K x \\<bind>\n                           (\\<lambda>y.\n                               distr (lim_sequence y)\n                                (Pi\\<^sub>M UNIV (\\<lambda>j. M))\n                                (case_nat y)))\n                          (PF.emb UNIV J (Pi\\<^sub>E J A))", "have \"\\<dots> = (\\<integral>\\<^sup>+y. distr (lim_sequence y) (Pi\\<^sub>M UNIV (\\<lambda>j. M)) (case_nat y) (PF.emb UNIV J (Pi\\<^sub>E J F')) \\<partial>K x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ y. emeasure\n                            (C 1 n (case_nat y (\\<lambda>_. undefined)))\n                            (Pi\\<^sub>E {0..<Suc n} F)\n                       \\<partial>K x =\n    \\<integral>\\<^sup>+ y. emeasure\n                            (distr (lim_sequence y)\n                              (Pi\\<^sub>M UNIV (\\<lambda>j. M))\n                              (case_nat y))\n                            (PF.emb UNIV J (Pi\\<^sub>E J F'))\n                       \\<partial>K x", "proof (intro nn_integral_cong)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> space (K x) \\<Longrightarrow>\n       emeasure (C 1 n (case_nat xa (\\<lambda>_. undefined)))\n        (Pi\\<^sub>E {0..<Suc n} F) =\n       emeasure\n        (distr (lim_sequence xa) (Pi\\<^sub>M UNIV (\\<lambda>j. M))\n          (case_nat xa))\n        (PF.emb UNIV J (Pi\\<^sub>E J F'))", "fix y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> space (K x) \\<Longrightarrow>\n       emeasure (C 1 n (case_nat xa (\\<lambda>_. undefined)))\n        (Pi\\<^sub>E {0..<Suc n} F) =\n       emeasure\n        (distr (lim_sequence xa) (Pi\\<^sub>M UNIV (\\<lambda>j. M))\n          (case_nat xa))\n        (PF.emb UNIV J (Pi\\<^sub>E J F'))", "assume \"y \\<in> space (K x)\""], ["proof (state)\nthis:\n  y \\<in> space (K x)\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> space (K x) \\<Longrightarrow>\n       emeasure (C 1 n (case_nat xa (\\<lambda>_. undefined)))\n        (Pi\\<^sub>E {0..<Suc n} F) =\n       emeasure\n        (distr (lim_sequence xa) (Pi\\<^sub>M UNIV (\\<lambda>j. M))\n          (case_nat xa))\n        (PF.emb UNIV J (Pi\\<^sub>E J F'))", "then"], ["proof (chain)\npicking this:\n  y \\<in> space (K x)", "have y: \"y \\<in> space M\""], ["proof (prove)\nusing this:\n  y \\<in> space (K x)\n\ngoal (1 subgoal):\n 1. y \\<in> space M", "using x"], ["proof (prove)\nusing this:\n  y \\<in> space (K x)\n  x \\<in> space M\n\ngoal (1 subgoal):\n 1. y \\<in> space M", "by (simp add: space_K)"], ["proof (state)\nthis:\n  y \\<in> space M\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> space (K x) \\<Longrightarrow>\n       emeasure (C 1 n (case_nat xa (\\<lambda>_. undefined)))\n        (Pi\\<^sub>E {0..<Suc n} F) =\n       emeasure\n        (distr (lim_sequence xa) (Pi\\<^sub>M UNIV (\\<lambda>j. M))\n          (case_nat xa))\n        (PF.emb UNIV J (Pi\\<^sub>E J F'))", "then"], ["proof (chain)\npicking this:\n  y \\<in> space M", "interpret y: Ionescu_Tulcea \"K' y\" \"\\<lambda>_. M\""], ["proof (prove)\nusing this:\n  y \\<in> space M\n\ngoal (1 subgoal):\n 1. Ionescu_Tulcea (K' y) (\\<lambda>_. M)", "by (rule IT_K')"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> space (K x) \\<Longrightarrow>\n       emeasure (C 1 n (case_nat xa (\\<lambda>_. undefined)))\n        (Pi\\<^sub>E {0..<Suc n} F) =\n       emeasure\n        (distr (lim_sequence xa) (Pi\\<^sub>M UNIV (\\<lambda>j. M))\n          (case_nat xa))\n        (y.PF.emb UNIV J (Pi\\<^sub>E J F'))", "let ?y = \"case_nat y\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> space (K x) \\<Longrightarrow>\n       emeasure (C 1 n (case_nat xa (\\<lambda>_. undefined)))\n        (Pi\\<^sub>E {0..<Suc n} F) =\n       emeasure\n        (distr (lim_sequence xa) (Pi\\<^sub>M UNIV (\\<lambda>j. M))\n          (case_nat xa))\n        (y.PF.emb UNIV J (Pi\\<^sub>E J F'))", "have [simp]: \"?y ?U \\<in> space (Pi\\<^sub>M {0} (\\<lambda>i. M))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. case_nat y (\\<lambda>_. undefined)\n    \\<in> space (Pi\\<^sub>M {0} (\\<lambda>i. M))", "using y"], ["proof (prove)\nusing this:\n  y \\<in> space M\n\ngoal (1 subgoal):\n 1. case_nat y (\\<lambda>_. undefined)\n    \\<in> space (Pi\\<^sub>M {0} (\\<lambda>i. M))", "by (auto simp: space_PiM PiE_iff extensional_def split: nat.split)"], ["proof (state)\nthis:\n  case_nat y (\\<lambda>_. undefined)\n  \\<in> space (Pi\\<^sub>M {0} (\\<lambda>i. M))\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> space (K x) \\<Longrightarrow>\n       emeasure (C 1 n (case_nat xa (\\<lambda>_. undefined)))\n        (Pi\\<^sub>E {0..<Suc n} F) =\n       emeasure\n        (distr (lim_sequence xa) (Pi\\<^sub>M UNIV (\\<lambda>j. M))\n          (case_nat xa))\n        (y.PF.emb UNIV J (Pi\\<^sub>E J F'))", "have yM[measurable]: \"?y \\<in> Pi\\<^sub>M {0..<m} (\\<lambda>_. M) \\<rightarrow>\\<^sub>M Pi\\<^sub>M {0..<Suc m} (\\<lambda>i. M)\" for m"], ["proof (prove)\ngoal (1 subgoal):\n 1. case_nat y\n    \\<in> Pi\\<^sub>M {0..<m} (\\<lambda>_. M) \\<rightarrow>\\<^sub>M\n          Pi\\<^sub>M {0..<Suc m} (\\<lambda>i. M)", "using y"], ["proof (prove)\nusing this:\n  y \\<in> space M\n\ngoal (1 subgoal):\n 1. case_nat y\n    \\<in> Pi\\<^sub>M {0..<m} (\\<lambda>_. M) \\<rightarrow>\\<^sub>M\n          Pi\\<^sub>M {0..<Suc m} (\\<lambda>i. M)", "by (intro measurable_PiM_single') (auto simp: space_PiM PiE_iff extensional_def split: nat.split)"], ["proof (state)\nthis:\n  case_nat y\n  \\<in> Pi\\<^sub>M {0..<?m1} (\\<lambda>_. M) \\<rightarrow>\\<^sub>M\n        Pi\\<^sub>M {0..<Suc ?m1} (\\<lambda>i. M)\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> space (K x) \\<Longrightarrow>\n       emeasure (C 1 n (case_nat xa (\\<lambda>_. undefined)))\n        (Pi\\<^sub>E {0..<Suc n} F) =\n       emeasure\n        (distr (lim_sequence xa) (Pi\\<^sub>M UNIV (\\<lambda>j. M))\n          (case_nat xa))\n        (y.PF.emb UNIV J (Pi\\<^sub>E J F'))", "have y': \"?y ?U \\<in> space (Pi\\<^sub>M {0..<1} (\\<lambda>i. M))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. case_nat y (\\<lambda>_. undefined)\n    \\<in> space (Pi\\<^sub>M {0..<1} (\\<lambda>i. M))", "by (simp add: space_PiM PiE_def y extensional_def split: nat.split)"], ["proof (state)\nthis:\n  case_nat y (\\<lambda>_. undefined)\n  \\<in> space (Pi\\<^sub>M {0..<1} (\\<lambda>i. M))\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> space (K x) \\<Longrightarrow>\n       emeasure (C 1 n (case_nat xa (\\<lambda>_. undefined)))\n        (Pi\\<^sub>E {0..<Suc n} F) =\n       emeasure\n        (distr (lim_sequence xa) (Pi\\<^sub>M UNIV (\\<lambda>j. M))\n          (case_nat xa))\n        (y.PF.emb UNIV J (Pi\\<^sub>E J F'))", "have eq1: \"?y -` Pi\\<^sub>E {0..<Suc n} F \\<inter> space (Pi\\<^sub>M {0..<n} (\\<lambda>_. M)) =\n        (if y \\<in> F 0 then Pi\\<^sub>E {0..<n} (F\\<circ>Suc) else {})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. case_nat y -` Pi\\<^sub>E {0..<Suc n} F \\<inter>\n    space (Pi\\<^sub>M {0..<n} (\\<lambda>_. M)) =\n    (if y \\<in> F 0 then Pi\\<^sub>E {0..<n} (F \\<circ> Suc) else {})", "unfolding set_eq_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       (x \\<in> case_nat y -` Pi\\<^sub>E {0..<Suc n} F \\<inter>\n                space (Pi\\<^sub>M {0..<n} (\\<lambda>_. M))) =\n       (x \\<in> (if y \\<in> F 0 then Pi\\<^sub>E {0..<n} (F \\<circ> Suc)\n                 else {}))", "using y sets.sets_into_space[OF F]"], ["proof (prove)\nusing this:\n  y \\<in> space M\n  F ?i2 \\<subseteq> space M\n\ngoal (1 subgoal):\n 1. \\<forall>x.\n       (x \\<in> case_nat y -` Pi\\<^sub>E {0..<Suc n} F \\<inter>\n                space (Pi\\<^sub>M {0..<n} (\\<lambda>_. M))) =\n       (x \\<in> (if y \\<in> F 0 then Pi\\<^sub>E {0..<n} (F \\<circ> Suc)\n                 else {}))", "by (auto simp: space_PiM PiE_iff extensional_def Ball_def split: nat.split nat.split_asm)"], ["proof (state)\nthis:\n  case_nat y -` Pi\\<^sub>E {0..<Suc n} F \\<inter>\n  space (Pi\\<^sub>M {0..<n} (\\<lambda>_. M)) =\n  (if y \\<in> F 0 then Pi\\<^sub>E {0..<n} (F \\<circ> Suc) else {})\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> space (K x) \\<Longrightarrow>\n       emeasure (C 1 n (case_nat xa (\\<lambda>_. undefined)))\n        (Pi\\<^sub>E {0..<Suc n} F) =\n       emeasure\n        (distr (lim_sequence xa) (Pi\\<^sub>M UNIV (\\<lambda>j. M))\n          (case_nat xa))\n        (y.PF.emb UNIV J (Pi\\<^sub>E J F'))", "have eq2: \"?y -` PF.emb UNIV {0..<Suc n} (Pi\\<^sub>E {0..<Suc n} F) \\<inter> space (Pi\\<^sub>M UNIV (\\<lambda>_. M)) =\n        (if y \\<in> F 0 then PF.emb UNIV {0..<n} (Pi\\<^sub>E {0..<n} (F\\<circ>Suc)) else {})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. case_nat y -`\n    y.PF.emb UNIV {0..<Suc n} (Pi\\<^sub>E {0..<Suc n} F) \\<inter>\n    space (Pi\\<^sub>M UNIV (\\<lambda>_. M)) =\n    (if y \\<in> F 0\n     then y.PF.emb UNIV {0..<n} (Pi\\<^sub>E {0..<n} (F \\<circ> Suc))\n     else {})", "unfolding set_eq_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       (x \\<in> case_nat y -`\n                y.PF.emb UNIV {0..<Suc n}\n                 (Pi\\<^sub>E {0..<Suc n} F) \\<inter>\n                space (Pi\\<^sub>M UNIV (\\<lambda>_. M))) =\n       (x \\<in> (if y \\<in> F 0\n                 then y.PF.emb UNIV {0..<n}\n                       (Pi\\<^sub>E {0..<n} (F \\<circ> Suc))\n                 else {}))", "using y sets.sets_into_space[OF F]"], ["proof (prove)\nusing this:\n  y \\<in> space M\n  F ?i2 \\<subseteq> space M\n\ngoal (1 subgoal):\n 1. \\<forall>x.\n       (x \\<in> case_nat y -`\n                y.PF.emb UNIV {0..<Suc n}\n                 (Pi\\<^sub>E {0..<Suc n} F) \\<inter>\n                space (Pi\\<^sub>M UNIV (\\<lambda>_. M))) =\n       (x \\<in> (if y \\<in> F 0\n                 then y.PF.emb UNIV {0..<n}\n                       (Pi\\<^sub>E {0..<n} (F \\<circ> Suc))\n                 else {}))", "by (auto simp: space_PiM PiE_iff prod_emb_def extensional_def Ball_def split: nat.split nat.split_asm)"], ["proof (state)\nthis:\n  case_nat y -`\n  y.PF.emb UNIV {0..<Suc n} (Pi\\<^sub>E {0..<Suc n} F) \\<inter>\n  space (Pi\\<^sub>M UNIV (\\<lambda>_. M)) =\n  (if y \\<in> F 0\n   then y.PF.emb UNIV {0..<n} (Pi\\<^sub>E {0..<n} (F \\<circ> Suc)) else {})\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> space (K x) \\<Longrightarrow>\n       emeasure (C 1 n (case_nat xa (\\<lambda>_. undefined)))\n        (Pi\\<^sub>E {0..<Suc n} F) =\n       emeasure\n        (distr (lim_sequence xa) (Pi\\<^sub>M UNIV (\\<lambda>j. M))\n          (case_nat xa))\n        (y.PF.emb UNIV J (Pi\\<^sub>E J F'))", "let ?I = \"indicator (F 0) y\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> space (K x) \\<Longrightarrow>\n       emeasure (C 1 n (case_nat xa (\\<lambda>_. undefined)))\n        (Pi\\<^sub>E {0..<Suc n} F) =\n       emeasure\n        (distr (lim_sequence xa) (Pi\\<^sub>M UNIV (\\<lambda>j. M))\n          (case_nat xa))\n        (y.PF.emb UNIV J (Pi\\<^sub>E J F'))", "have \"C 1 n (?y ?U) = distr (y.C 0 n ?U) (\\<Pi>\\<^sub>M i\\<in>{0..<Suc n}. M) ?y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C 1 n (case_nat y (\\<lambda>_. undefined)) =\n    distr (y.C 0 n (\\<lambda>_. undefined))\n     (Pi\\<^sub>M {0..<Suc n} (\\<lambda>i. M)) (case_nat y)", "proof (induction n)"], ["proof (state)\ngoal (2 subgoals):\n 1. C 1 0 (\\<lambda>a. case a of 0 \\<Rightarrow> y) =\n    distr (y.C 0 0 (\\<lambda>_. undefined))\n     (Pi\\<^sub>M {0..<Suc 0} (\\<lambda>i. M))\n     (\\<lambda>a aa.\n         case aa of 0 \\<Rightarrow> y | Suc aa \\<Rightarrow> a aa)\n 2. \\<And>n.\n       C 1 n (\\<lambda>a. case a of 0 \\<Rightarrow> y) =\n       distr (y.C 0 n (\\<lambda>_. undefined))\n        (Pi\\<^sub>M {0..<Suc n} (\\<lambda>i. M))\n        (\\<lambda>a aa.\n            case aa of 0 \\<Rightarrow> y\n            | Suc aa \\<Rightarrow> a aa) \\<Longrightarrow>\n       C 1 (Suc n) (\\<lambda>a. case a of 0 \\<Rightarrow> y) =\n       distr (y.C 0 (Suc n) (\\<lambda>_. undefined))\n        (Pi\\<^sub>M {0..<Suc (Suc n)} (\\<lambda>i. M))\n        (\\<lambda>a aa.\n            case aa of 0 \\<Rightarrow> y | Suc aa \\<Rightarrow> a aa)", "case (Suc m)"], ["proof (state)\nthis:\n  C 1 m (\\<lambda>a. case a of 0 \\<Rightarrow> y) =\n  distr (y.C 0 m (\\<lambda>_. undefined))\n   (Pi\\<^sub>M {0..<Suc m} (\\<lambda>i. M))\n   (\\<lambda>a aa. case aa of 0 \\<Rightarrow> y | Suc aa \\<Rightarrow> a aa)\n\ngoal (2 subgoals):\n 1. C 1 0 (\\<lambda>a. case a of 0 \\<Rightarrow> y) =\n    distr (y.C 0 0 (\\<lambda>_. undefined))\n     (Pi\\<^sub>M {0..<Suc 0} (\\<lambda>i. M))\n     (\\<lambda>a aa.\n         case aa of 0 \\<Rightarrow> y | Suc aa \\<Rightarrow> a aa)\n 2. \\<And>n.\n       C 1 n (\\<lambda>a. case a of 0 \\<Rightarrow> y) =\n       distr (y.C 0 n (\\<lambda>_. undefined))\n        (Pi\\<^sub>M {0..<Suc n} (\\<lambda>i. M))\n        (\\<lambda>a aa.\n            case aa of 0 \\<Rightarrow> y\n            | Suc aa \\<Rightarrow> a aa) \\<Longrightarrow>\n       C 1 (Suc n) (\\<lambda>a. case a of 0 \\<Rightarrow> y) =\n       distr (y.C 0 (Suc n) (\\<lambda>_. undefined))\n        (Pi\\<^sub>M {0..<Suc (Suc n)} (\\<lambda>i. M))\n        (\\<lambda>a aa.\n            case aa of 0 \\<Rightarrow> y | Suc aa \\<Rightarrow> a aa)", "have \"C 1 (Suc m) (?y ?U) = distr (y.C 0 m ?U) (Pi\\<^sub>M {0..<Suc m} (\\<lambda>i. M)) ?y \\<bind> eP (Suc m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C 1 (Suc m) (case_nat y (\\<lambda>_. undefined)) =\n    distr (y.C 0 m (\\<lambda>_. undefined))\n     (Pi\\<^sub>M {0..<Suc m} (\\<lambda>i. M)) (case_nat y) \\<bind>\n    eP (Suc m)", "using Suc"], ["proof (prove)\nusing this:\n  C 1 m (\\<lambda>a. case a of 0 \\<Rightarrow> y) =\n  distr (y.C 0 m (\\<lambda>_. undefined))\n   (Pi\\<^sub>M {0..<Suc m} (\\<lambda>i. M))\n   (\\<lambda>a aa. case aa of 0 \\<Rightarrow> y | Suc aa \\<Rightarrow> a aa)\n\ngoal (1 subgoal):\n 1. C 1 (Suc m) (case_nat y (\\<lambda>_. undefined)) =\n    distr (y.C 0 m (\\<lambda>_. undefined))\n     (Pi\\<^sub>M {0..<Suc m} (\\<lambda>i. M)) (case_nat y) \\<bind>\n    eP (Suc m)", "by simp"], ["proof (state)\nthis:\n  C 1 (Suc m) (case_nat y (\\<lambda>_. undefined)) =\n  distr (y.C 0 m (\\<lambda>_. undefined))\n   (Pi\\<^sub>M {0..<Suc m} (\\<lambda>i. M)) (case_nat y) \\<bind>\n  eP (Suc m)\n\ngoal (2 subgoals):\n 1. C 1 0 (\\<lambda>a. case a of 0 \\<Rightarrow> y) =\n    distr (y.C 0 0 (\\<lambda>_. undefined))\n     (Pi\\<^sub>M {0..<Suc 0} (\\<lambda>i. M))\n     (\\<lambda>a aa.\n         case aa of 0 \\<Rightarrow> y | Suc aa \\<Rightarrow> a aa)\n 2. \\<And>n.\n       C 1 n (\\<lambda>a. case a of 0 \\<Rightarrow> y) =\n       distr (y.C 0 n (\\<lambda>_. undefined))\n        (Pi\\<^sub>M {0..<Suc n} (\\<lambda>i. M))\n        (\\<lambda>a aa.\n            case aa of 0 \\<Rightarrow> y\n            | Suc aa \\<Rightarrow> a aa) \\<Longrightarrow>\n       C 1 (Suc n) (\\<lambda>a. case a of 0 \\<Rightarrow> y) =\n       distr (y.C 0 (Suc n) (\\<lambda>_. undefined))\n        (Pi\\<^sub>M {0..<Suc (Suc n)} (\\<lambda>i. M))\n        (\\<lambda>a aa.\n            case aa of 0 \\<Rightarrow> y | Suc aa \\<Rightarrow> a aa)", "also"], ["proof (state)\nthis:\n  C 1 (Suc m) (case_nat y (\\<lambda>_. undefined)) =\n  distr (y.C 0 m (\\<lambda>_. undefined))\n   (Pi\\<^sub>M {0..<Suc m} (\\<lambda>i. M)) (case_nat y) \\<bind>\n  eP (Suc m)\n\ngoal (2 subgoals):\n 1. C 1 0 (\\<lambda>a. case a of 0 \\<Rightarrow> y) =\n    distr (y.C 0 0 (\\<lambda>_. undefined))\n     (Pi\\<^sub>M {0..<Suc 0} (\\<lambda>i. M))\n     (\\<lambda>a aa.\n         case aa of 0 \\<Rightarrow> y | Suc aa \\<Rightarrow> a aa)\n 2. \\<And>n.\n       C 1 n (\\<lambda>a. case a of 0 \\<Rightarrow> y) =\n       distr (y.C 0 n (\\<lambda>_. undefined))\n        (Pi\\<^sub>M {0..<Suc n} (\\<lambda>i. M))\n        (\\<lambda>a aa.\n            case aa of 0 \\<Rightarrow> y\n            | Suc aa \\<Rightarrow> a aa) \\<Longrightarrow>\n       C 1 (Suc n) (\\<lambda>a. case a of 0 \\<Rightarrow> y) =\n       distr (y.C 0 (Suc n) (\\<lambda>_. undefined))\n        (Pi\\<^sub>M {0..<Suc (Suc n)} (\\<lambda>i. M))\n        (\\<lambda>a aa.\n            case aa of 0 \\<Rightarrow> y | Suc aa \\<Rightarrow> a aa)", "have \"\\<dots> = y.C 0 m ?U \\<bind> (\\<lambda>x. eP (Suc m) (?y x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distr (y.C 0 m (\\<lambda>_. undefined))\n     (Pi\\<^sub>M {0..<Suc m} (\\<lambda>i. M)) (case_nat y) \\<bind>\n    eP (Suc m) =\n    y.C 0 m (\\<lambda>_. undefined) \\<bind>\n    (\\<lambda>x. eP (Suc m) (case_nat y x))", "by (intro bind_distr[where K=\"Pi\\<^sub>M {0..<Suc (Suc m)} (\\<lambda>_. M)\"]) (simp_all add: y y.space_C y.sets_C cong: measurable_cong_sets)"], ["proof (state)\nthis:\n  distr (y.C 0 m (\\<lambda>_. undefined))\n   (Pi\\<^sub>M {0..<Suc m} (\\<lambda>i. M)) (case_nat y) \\<bind>\n  eP (Suc m) =\n  y.C 0 m (\\<lambda>_. undefined) \\<bind>\n  (\\<lambda>x. eP (Suc m) (case_nat y x))\n\ngoal (2 subgoals):\n 1. C 1 0 (\\<lambda>a. case a of 0 \\<Rightarrow> y) =\n    distr (y.C 0 0 (\\<lambda>_. undefined))\n     (Pi\\<^sub>M {0..<Suc 0} (\\<lambda>i. M))\n     (\\<lambda>a aa.\n         case aa of 0 \\<Rightarrow> y | Suc aa \\<Rightarrow> a aa)\n 2. \\<And>n.\n       C 1 n (\\<lambda>a. case a of 0 \\<Rightarrow> y) =\n       distr (y.C 0 n (\\<lambda>_. undefined))\n        (Pi\\<^sub>M {0..<Suc n} (\\<lambda>i. M))\n        (\\<lambda>a aa.\n            case aa of 0 \\<Rightarrow> y\n            | Suc aa \\<Rightarrow> a aa) \\<Longrightarrow>\n       C 1 (Suc n) (\\<lambda>a. case a of 0 \\<Rightarrow> y) =\n       distr (y.C 0 (Suc n) (\\<lambda>_. undefined))\n        (Pi\\<^sub>M {0..<Suc (Suc n)} (\\<lambda>i. M))\n        (\\<lambda>a aa.\n            case aa of 0 \\<Rightarrow> y | Suc aa \\<Rightarrow> a aa)", "also"], ["proof (state)\nthis:\n  distr (y.C 0 m (\\<lambda>_. undefined))\n   (Pi\\<^sub>M {0..<Suc m} (\\<lambda>i. M)) (case_nat y) \\<bind>\n  eP (Suc m) =\n  y.C 0 m (\\<lambda>_. undefined) \\<bind>\n  (\\<lambda>x. eP (Suc m) (case_nat y x))\n\ngoal (2 subgoals):\n 1. C 1 0 (\\<lambda>a. case a of 0 \\<Rightarrow> y) =\n    distr (y.C 0 0 (\\<lambda>_. undefined))\n     (Pi\\<^sub>M {0..<Suc 0} (\\<lambda>i. M))\n     (\\<lambda>a aa.\n         case aa of 0 \\<Rightarrow> y | Suc aa \\<Rightarrow> a aa)\n 2. \\<And>n.\n       C 1 n (\\<lambda>a. case a of 0 \\<Rightarrow> y) =\n       distr (y.C 0 n (\\<lambda>_. undefined))\n        (Pi\\<^sub>M {0..<Suc n} (\\<lambda>i. M))\n        (\\<lambda>a aa.\n            case aa of 0 \\<Rightarrow> y\n            | Suc aa \\<Rightarrow> a aa) \\<Longrightarrow>\n       C 1 (Suc n) (\\<lambda>a. case a of 0 \\<Rightarrow> y) =\n       distr (y.C 0 (Suc n) (\\<lambda>_. undefined))\n        (Pi\\<^sub>M {0..<Suc (Suc n)} (\\<lambda>i. M))\n        (\\<lambda>a aa.\n            case aa of 0 \\<Rightarrow> y | Suc aa \\<Rightarrow> a aa)", "have \"\\<dots> = y.C 0 m ?U \\<bind> (\\<lambda>x. distr (y.eP m x) (Pi\\<^sub>M {0..<Suc (Suc m)} (\\<lambda>i. M)) ?y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y.C 0 m (\\<lambda>_. undefined) \\<bind>\n    (\\<lambda>x. eP (Suc m) (case_nat y x)) =\n    y.C 0 m (\\<lambda>_. undefined) \\<bind>\n    (\\<lambda>x.\n        distr (y.eP m x) (Pi\\<^sub>M {0..<Suc (Suc m)} (\\<lambda>i. M))\n         (case_nat y))", "proof (intro bind_cong refl)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> space (y.C 0 m (\\<lambda>_. undefined)) \\<Longrightarrow>\n       eP (Suc m) (case_nat y x) =\n       distr (y.eP m x) (Pi\\<^sub>M {0..<Suc (Suc m)} (\\<lambda>i. M))\n        (case_nat y)", "fix \\<omega>'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> space (y.C 0 m (\\<lambda>_. undefined)) \\<Longrightarrow>\n       eP (Suc m) (case_nat y x) =\n       distr (y.eP m x) (Pi\\<^sub>M {0..<Suc (Suc m)} (\\<lambda>i. M))\n        (case_nat y)", "assume \\<omega>': \"\\<omega>' \\<in> space (y.C 0 m ?U)\""], ["proof (state)\nthis:\n  \\<omega>' \\<in> space (y.C 0 m (\\<lambda>_. undefined))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> space (y.C 0 m (\\<lambda>_. undefined)) \\<Longrightarrow>\n       eP (Suc m) (case_nat y x) =\n       distr (y.eP m x) (Pi\\<^sub>M {0..<Suc (Suc m)} (\\<lambda>i. M))\n        (case_nat y)", "moreover"], ["proof (state)\nthis:\n  \\<omega>' \\<in> space (y.C 0 m (\\<lambda>_. undefined))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> space (y.C 0 m (\\<lambda>_. undefined)) \\<Longrightarrow>\n       eP (Suc m) (case_nat y x) =\n       distr (y.eP m x) (Pi\\<^sub>M {0..<Suc (Suc m)} (\\<lambda>i. M))\n        (case_nat y)", "have \"K' x (Suc m) (?y \\<omega>') = K' y m \\<omega>'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. K' x (Suc m) (case_nat y \\<omega>') = K' y m \\<omega>'", "by (auto simp: K'_def)"], ["proof (state)\nthis:\n  K' x (Suc m) (case_nat y \\<omega>') = K' y m \\<omega>'\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> space (y.C 0 m (\\<lambda>_. undefined)) \\<Longrightarrow>\n       eP (Suc m) (case_nat y x) =\n       distr (y.eP m x) (Pi\\<^sub>M {0..<Suc (Suc m)} (\\<lambda>i. M))\n        (case_nat y)", "ultimately"], ["proof (chain)\npicking this:\n  \\<omega>' \\<in> space (y.C 0 m (\\<lambda>_. undefined))\n  K' x (Suc m) (case_nat y \\<omega>') = K' y m \\<omega>'", "show \"eP (Suc m) (?y \\<omega>') = distr (y.eP m \\<omega>') (Pi\\<^sub>M {0..<Suc (Suc m)} (\\<lambda>i. M)) ?y\""], ["proof (prove)\nusing this:\n  \\<omega>' \\<in> space (y.C 0 m (\\<lambda>_. undefined))\n  K' x (Suc m) (case_nat y \\<omega>') = K' y m \\<omega>'\n\ngoal (1 subgoal):\n 1. eP (Suc m) (case_nat y \\<omega>') =\n    distr (y.eP m \\<omega>') (Pi\\<^sub>M {0..<Suc (Suc m)} (\\<lambda>i. M))\n     (case_nat y)", "unfolding eP_def y.eP_def"], ["proof (prove)\nusing this:\n  \\<omega>' \\<in> space (y.C 0 m (\\<lambda>_. undefined))\n  K' x (Suc m) (case_nat y \\<omega>') = K' y m \\<omega>'\n\ngoal (1 subgoal):\n 1. distr (K' x (Suc m) (case_nat y \\<omega>'))\n     (Pi\\<^sub>M {0..<Suc (Suc m)} (\\<lambda>_. M))\n     (fun_upd (case_nat y \\<omega>') (Suc m)) =\n    distr\n     (distr (K' y m \\<omega>') (Pi\\<^sub>M {0..<Suc m} (\\<lambda>_. M))\n       (fun_upd \\<omega>' m))\n     (Pi\\<^sub>M {0..<Suc (Suc m)} (\\<lambda>i. M)) (case_nat y)", "by (subst distr_distr)\n             (auto simp: y.space_C y.sets_P split: nat.split cong: measurable_cong_sets\n                   intro!: distr_cong measurable_fun_upd[where J=\"{0..<m}\"])"], ["proof (state)\nthis:\n  eP (Suc m) (case_nat y \\<omega>') =\n  distr (y.eP m \\<omega>') (Pi\\<^sub>M {0..<Suc (Suc m)} (\\<lambda>i. M))\n   (case_nat y)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  y.C 0 m (\\<lambda>_. undefined) \\<bind>\n  (\\<lambda>x. eP (Suc m) (case_nat y x)) =\n  y.C 0 m (\\<lambda>_. undefined) \\<bind>\n  (\\<lambda>x.\n      distr (y.eP m x) (Pi\\<^sub>M {0..<Suc (Suc m)} (\\<lambda>i. M))\n       (case_nat y))\n\ngoal (2 subgoals):\n 1. C 1 0 (\\<lambda>a. case a of 0 \\<Rightarrow> y) =\n    distr (y.C 0 0 (\\<lambda>_. undefined))\n     (Pi\\<^sub>M {0..<Suc 0} (\\<lambda>i. M))\n     (\\<lambda>a aa.\n         case aa of 0 \\<Rightarrow> y | Suc aa \\<Rightarrow> a aa)\n 2. \\<And>n.\n       C 1 n (\\<lambda>a. case a of 0 \\<Rightarrow> y) =\n       distr (y.C 0 n (\\<lambda>_. undefined))\n        (Pi\\<^sub>M {0..<Suc n} (\\<lambda>i. M))\n        (\\<lambda>a aa.\n            case aa of 0 \\<Rightarrow> y\n            | Suc aa \\<Rightarrow> a aa) \\<Longrightarrow>\n       C 1 (Suc n) (\\<lambda>a. case a of 0 \\<Rightarrow> y) =\n       distr (y.C 0 (Suc n) (\\<lambda>_. undefined))\n        (Pi\\<^sub>M {0..<Suc (Suc n)} (\\<lambda>i. M))\n        (\\<lambda>a aa.\n            case aa of 0 \\<Rightarrow> y | Suc aa \\<Rightarrow> a aa)", "also"], ["proof (state)\nthis:\n  y.C 0 m (\\<lambda>_. undefined) \\<bind>\n  (\\<lambda>x. eP (Suc m) (case_nat y x)) =\n  y.C 0 m (\\<lambda>_. undefined) \\<bind>\n  (\\<lambda>x.\n      distr (y.eP m x) (Pi\\<^sub>M {0..<Suc (Suc m)} (\\<lambda>i. M))\n       (case_nat y))\n\ngoal (2 subgoals):\n 1. C 1 0 (\\<lambda>a. case a of 0 \\<Rightarrow> y) =\n    distr (y.C 0 0 (\\<lambda>_. undefined))\n     (Pi\\<^sub>M {0..<Suc 0} (\\<lambda>i. M))\n     (\\<lambda>a aa.\n         case aa of 0 \\<Rightarrow> y | Suc aa \\<Rightarrow> a aa)\n 2. \\<And>n.\n       C 1 n (\\<lambda>a. case a of 0 \\<Rightarrow> y) =\n       distr (y.C 0 n (\\<lambda>_. undefined))\n        (Pi\\<^sub>M {0..<Suc n} (\\<lambda>i. M))\n        (\\<lambda>a aa.\n            case aa of 0 \\<Rightarrow> y\n            | Suc aa \\<Rightarrow> a aa) \\<Longrightarrow>\n       C 1 (Suc n) (\\<lambda>a. case a of 0 \\<Rightarrow> y) =\n       distr (y.C 0 (Suc n) (\\<lambda>_. undefined))\n        (Pi\\<^sub>M {0..<Suc (Suc n)} (\\<lambda>i. M))\n        (\\<lambda>a aa.\n            case aa of 0 \\<Rightarrow> y | Suc aa \\<Rightarrow> a aa)", "have \"\\<dots> = distr (y.C 0 m ?U \\<bind> y.eP m) (Pi\\<^sub>M {0..<Suc (Suc m)} (\\<lambda>i. M)) ?y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y.C 0 m (\\<lambda>_. undefined) \\<bind>\n    (\\<lambda>x.\n        distr (y.eP m x) (Pi\\<^sub>M {0..<Suc (Suc m)} (\\<lambda>i. M))\n         (case_nat y)) =\n    distr (y.C 0 m (\\<lambda>_. undefined) \\<bind> y.eP m)\n     (Pi\\<^sub>M {0..<Suc (Suc m)} (\\<lambda>i. M)) (case_nat y)", "by (intro distr_bind[symmetric, OF _ _ yM]) (auto simp: y.space_C y.sets_C cong: measurable_cong_sets)"], ["proof (state)\nthis:\n  y.C 0 m (\\<lambda>_. undefined) \\<bind>\n  (\\<lambda>x.\n      distr (y.eP m x) (Pi\\<^sub>M {0..<Suc (Suc m)} (\\<lambda>i. M))\n       (case_nat y)) =\n  distr (y.C 0 m (\\<lambda>_. undefined) \\<bind> y.eP m)\n   (Pi\\<^sub>M {0..<Suc (Suc m)} (\\<lambda>i. M)) (case_nat y)\n\ngoal (2 subgoals):\n 1. C 1 0 (\\<lambda>a. case a of 0 \\<Rightarrow> y) =\n    distr (y.C 0 0 (\\<lambda>_. undefined))\n     (Pi\\<^sub>M {0..<Suc 0} (\\<lambda>i. M))\n     (\\<lambda>a aa.\n         case aa of 0 \\<Rightarrow> y | Suc aa \\<Rightarrow> a aa)\n 2. \\<And>n.\n       C 1 n (\\<lambda>a. case a of 0 \\<Rightarrow> y) =\n       distr (y.C 0 n (\\<lambda>_. undefined))\n        (Pi\\<^sub>M {0..<Suc n} (\\<lambda>i. M))\n        (\\<lambda>a aa.\n            case aa of 0 \\<Rightarrow> y\n            | Suc aa \\<Rightarrow> a aa) \\<Longrightarrow>\n       C 1 (Suc n) (\\<lambda>a. case a of 0 \\<Rightarrow> y) =\n       distr (y.C 0 (Suc n) (\\<lambda>_. undefined))\n        (Pi\\<^sub>M {0..<Suc (Suc n)} (\\<lambda>i. M))\n        (\\<lambda>a aa.\n            case aa of 0 \\<Rightarrow> y | Suc aa \\<Rightarrow> a aa)", "finally"], ["proof (chain)\npicking this:\n  C 1 (Suc m) (case_nat y (\\<lambda>_. undefined)) =\n  distr (y.C 0 m (\\<lambda>_. undefined) \\<bind> y.eP m)\n   (Pi\\<^sub>M {0..<Suc (Suc m)} (\\<lambda>i. M)) (case_nat y)", "show ?case"], ["proof (prove)\nusing this:\n  C 1 (Suc m) (case_nat y (\\<lambda>_. undefined)) =\n  distr (y.C 0 m (\\<lambda>_. undefined) \\<bind> y.eP m)\n   (Pi\\<^sub>M {0..<Suc (Suc m)} (\\<lambda>i. M)) (case_nat y)\n\ngoal (1 subgoal):\n 1. C 1 (Suc m) (\\<lambda>a. case a of 0 \\<Rightarrow> y) =\n    distr (y.C 0 (Suc m) (\\<lambda>_. undefined))\n     (Pi\\<^sub>M {0..<Suc (Suc m)} (\\<lambda>i. M))\n     (\\<lambda>a aa.\n         case aa of 0 \\<Rightarrow> y | Suc aa \\<Rightarrow> a aa)", "by simp"], ["proof (state)\nthis:\n  C 1 (Suc m) (\\<lambda>a. case a of 0 \\<Rightarrow> y) =\n  distr (y.C 0 (Suc m) (\\<lambda>_. undefined))\n   (Pi\\<^sub>M {0..<Suc (Suc m)} (\\<lambda>i. M))\n   (\\<lambda>a aa. case aa of 0 \\<Rightarrow> y | Suc aa \\<Rightarrow> a aa)\n\ngoal (1 subgoal):\n 1. C 1 0 (\\<lambda>a. case a of 0 \\<Rightarrow> y) =\n    distr (y.C 0 0 (\\<lambda>_. undefined))\n     (Pi\\<^sub>M {0..<Suc 0} (\\<lambda>i. M))\n     (\\<lambda>a aa.\n         case aa of 0 \\<Rightarrow> y | Suc aa \\<Rightarrow> a aa)", "qed (use y in \\<open>simp add: PiM_empty distr_return\\<close>)"], ["proof (state)\nthis:\n  C 1 n (case_nat y (\\<lambda>_. undefined)) =\n  distr (y.C 0 n (\\<lambda>_. undefined))\n   (Pi\\<^sub>M {0..<Suc n} (\\<lambda>i. M)) (case_nat y)\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> space (K x) \\<Longrightarrow>\n       emeasure (C 1 n (case_nat xa (\\<lambda>_. undefined)))\n        (Pi\\<^sub>E {0..<Suc n} F) =\n       emeasure\n        (distr (lim_sequence xa) (Pi\\<^sub>M UNIV (\\<lambda>j. M))\n          (case_nat xa))\n        (y.PF.emb UNIV J (Pi\\<^sub>E J F'))", "then"], ["proof (chain)\npicking this:\n  C 1 n (case_nat y (\\<lambda>_. undefined)) =\n  distr (y.C 0 n (\\<lambda>_. undefined))\n   (Pi\\<^sub>M {0..<Suc n} (\\<lambda>i. M)) (case_nat y)", "have \"C 1 n (case_nat y ?U) (Pi\\<^sub>E {0..<Suc n} F) =\n      (distr (y.C 0 n ?U) (\\<Pi>\\<^sub>M i\\<in>{0..<Suc n}. M) ?y) (Pi\\<^sub>E {0..<Suc n} F)\""], ["proof (prove)\nusing this:\n  C 1 n (case_nat y (\\<lambda>_. undefined)) =\n  distr (y.C 0 n (\\<lambda>_. undefined))\n   (Pi\\<^sub>M {0..<Suc n} (\\<lambda>i. M)) (case_nat y)\n\ngoal (1 subgoal):\n 1. emeasure (C 1 n (case_nat y (\\<lambda>_. undefined)))\n     (Pi\\<^sub>E {0..<Suc n} F) =\n    emeasure\n     (distr (y.C 0 n (\\<lambda>_. undefined))\n       (Pi\\<^sub>M {0..<Suc n} (\\<lambda>i. M)) (case_nat y))\n     (Pi\\<^sub>E {0..<Suc n} F)", "by simp"], ["proof (state)\nthis:\n  emeasure (C 1 n (case_nat y (\\<lambda>_. undefined)))\n   (Pi\\<^sub>E {0..<Suc n} F) =\n  emeasure\n   (distr (y.C 0 n (\\<lambda>_. undefined))\n     (Pi\\<^sub>M {0..<Suc n} (\\<lambda>i. M)) (case_nat y))\n   (Pi\\<^sub>E {0..<Suc n} F)\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> space (K x) \\<Longrightarrow>\n       emeasure (C 1 n (case_nat xa (\\<lambda>_. undefined)))\n        (Pi\\<^sub>E {0..<Suc n} F) =\n       emeasure\n        (distr (lim_sequence xa) (Pi\\<^sub>M UNIV (\\<lambda>j. M))\n          (case_nat xa))\n        (y.PF.emb UNIV J (Pi\\<^sub>E J F'))", "also"], ["proof (state)\nthis:\n  emeasure (C 1 n (case_nat y (\\<lambda>_. undefined)))\n   (Pi\\<^sub>E {0..<Suc n} F) =\n  emeasure\n   (distr (y.C 0 n (\\<lambda>_. undefined))\n     (Pi\\<^sub>M {0..<Suc n} (\\<lambda>i. M)) (case_nat y))\n   (Pi\\<^sub>E {0..<Suc n} F)\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> space (K x) \\<Longrightarrow>\n       emeasure (C 1 n (case_nat xa (\\<lambda>_. undefined)))\n        (Pi\\<^sub>E {0..<Suc n} F) =\n       emeasure\n        (distr (lim_sequence xa) (Pi\\<^sub>M UNIV (\\<lambda>j. M))\n          (case_nat xa))\n        (y.PF.emb UNIV J (Pi\\<^sub>E J F'))", "have \"\\<dots> = ?I * y.C 0 n ?U (Pi\\<^sub>E {0..<n} (F \\<circ> Suc))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure\n     (distr (y.C 0 n (\\<lambda>_. undefined))\n       (Pi\\<^sub>M {0..<Suc n} (\\<lambda>i. M)) (case_nat y))\n     (Pi\\<^sub>E {0..<Suc n} F) =\n    indicator (F 0) y *\n    emeasure (y.C 0 n (\\<lambda>_. undefined))\n     (Pi\\<^sub>E {0..<n} (F \\<circ> Suc))", "by (subst emeasure_distr) (auto simp: y.sets_C y.space_C eq1 cong: measurable_cong_sets)"], ["proof (state)\nthis:\n  emeasure\n   (distr (y.C 0 n (\\<lambda>_. undefined))\n     (Pi\\<^sub>M {0..<Suc n} (\\<lambda>i. M)) (case_nat y))\n   (Pi\\<^sub>E {0..<Suc n} F) =\n  indicator (F 0) y *\n  emeasure (y.C 0 n (\\<lambda>_. undefined))\n   (Pi\\<^sub>E {0..<n} (F \\<circ> Suc))\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> space (K x) \\<Longrightarrow>\n       emeasure (C 1 n (case_nat xa (\\<lambda>_. undefined)))\n        (Pi\\<^sub>E {0..<Suc n} F) =\n       emeasure\n        (distr (lim_sequence xa) (Pi\\<^sub>M UNIV (\\<lambda>j. M))\n          (case_nat xa))\n        (y.PF.emb UNIV J (Pi\\<^sub>E J F'))", "also"], ["proof (state)\nthis:\n  emeasure\n   (distr (y.C 0 n (\\<lambda>_. undefined))\n     (Pi\\<^sub>M {0..<Suc n} (\\<lambda>i. M)) (case_nat y))\n   (Pi\\<^sub>E {0..<Suc n} F) =\n  indicator (F 0) y *\n  emeasure (y.C 0 n (\\<lambda>_. undefined))\n   (Pi\\<^sub>E {0..<n} (F \\<circ> Suc))\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> space (K x) \\<Longrightarrow>\n       emeasure (C 1 n (case_nat xa (\\<lambda>_. undefined)))\n        (Pi\\<^sub>E {0..<Suc n} F) =\n       emeasure\n        (distr (lim_sequence xa) (Pi\\<^sub>M UNIV (\\<lambda>j. M))\n          (case_nat xa))\n        (y.PF.emb UNIV J (Pi\\<^sub>E J F'))", "have \"\\<dots> = ?I * lim_sequence y (PF.emb UNIV {0..<n} (Pi\\<^sub>E {0..<n} (F \\<circ> Suc)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. indicator (F 0) y *\n    emeasure (y.C 0 n (\\<lambda>_. undefined))\n     (Pi\\<^sub>E {0..<n} (F \\<circ> Suc)) =\n    indicator (F 0) y *\n    emeasure (lim_sequence y)\n     (y.PF.emb UNIV {0..<n} (Pi\\<^sub>E {0..<n} (F \\<circ> Suc)))", "using y"], ["proof (prove)\nusing this:\n  y \\<in> space M\n\ngoal (1 subgoal):\n 1. indicator (F 0) y *\n    emeasure (y.C 0 n (\\<lambda>_. undefined))\n     (Pi\\<^sub>E {0..<n} (F \\<circ> Suc)) =\n    indicator (F 0) y *\n    emeasure (lim_sequence y)\n     (y.PF.emb UNIV {0..<n} (Pi\\<^sub>E {0..<n} (F \\<circ> Suc)))", "by (simp add: emeasure_lim_sequence_emb_I0o sets_PiM_I_finite)"], ["proof (state)\nthis:\n  indicator (F 0) y *\n  emeasure (y.C 0 n (\\<lambda>_. undefined))\n   (Pi\\<^sub>E {0..<n} (F \\<circ> Suc)) =\n  indicator (F 0) y *\n  emeasure (lim_sequence y)\n   (y.PF.emb UNIV {0..<n} (Pi\\<^sub>E {0..<n} (F \\<circ> Suc)))\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> space (K x) \\<Longrightarrow>\n       emeasure (C 1 n (case_nat xa (\\<lambda>_. undefined)))\n        (Pi\\<^sub>E {0..<Suc n} F) =\n       emeasure\n        (distr (lim_sequence xa) (Pi\\<^sub>M UNIV (\\<lambda>j. M))\n          (case_nat xa))\n        (y.PF.emb UNIV J (Pi\\<^sub>E J F'))", "also"], ["proof (state)\nthis:\n  indicator (F 0) y *\n  emeasure (y.C 0 n (\\<lambda>_. undefined))\n   (Pi\\<^sub>E {0..<n} (F \\<circ> Suc)) =\n  indicator (F 0) y *\n  emeasure (lim_sequence y)\n   (y.PF.emb UNIV {0..<n} (Pi\\<^sub>E {0..<n} (F \\<circ> Suc)))\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> space (K x) \\<Longrightarrow>\n       emeasure (C 1 n (case_nat xa (\\<lambda>_. undefined)))\n        (Pi\\<^sub>E {0..<Suc n} F) =\n       emeasure\n        (distr (lim_sequence xa) (Pi\\<^sub>M UNIV (\\<lambda>j. M))\n          (case_nat xa))\n        (y.PF.emb UNIV J (Pi\\<^sub>E J F'))", "have \"\\<dots> = distr (lim_sequence y) (Pi\\<^sub>M UNIV (\\<lambda>j. M)) ?y (PF.emb UNIV {0..<Suc n} (Pi\\<^sub>E {0..<Suc n} F))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. indicator (F 0) y *\n    emeasure (lim_sequence y)\n     (y.PF.emb UNIV {0..<n} (Pi\\<^sub>E {0..<n} (F \\<circ> Suc))) =\n    emeasure\n     (distr (lim_sequence y) (Pi\\<^sub>M UNIV (\\<lambda>j. M)) (case_nat y))\n     (y.PF.emb UNIV {0..<Suc n} (Pi\\<^sub>E {0..<Suc n} F))", "using y"], ["proof (prove)\nusing this:\n  y \\<in> space M\n\ngoal (1 subgoal):\n 1. indicator (F 0) y *\n    emeasure (lim_sequence y)\n     (y.PF.emb UNIV {0..<n} (Pi\\<^sub>E {0..<n} (F \\<circ> Suc))) =\n    emeasure\n     (distr (lim_sequence y) (Pi\\<^sub>M UNIV (\\<lambda>j. M)) (case_nat y))\n     (y.PF.emb UNIV {0..<Suc n} (Pi\\<^sub>E {0..<Suc n} F))", "by (subst emeasure_distr) (simp_all add: eq2 space_lim_sequence)"], ["proof (state)\nthis:\n  indicator (F 0) y *\n  emeasure (lim_sequence y)\n   (y.PF.emb UNIV {0..<n} (Pi\\<^sub>E {0..<n} (F \\<circ> Suc))) =\n  emeasure\n   (distr (lim_sequence y) (Pi\\<^sub>M UNIV (\\<lambda>j. M)) (case_nat y))\n   (y.PF.emb UNIV {0..<Suc n} (Pi\\<^sub>E {0..<Suc n} F))\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> space (K x) \\<Longrightarrow>\n       emeasure (C 1 n (case_nat xa (\\<lambda>_. undefined)))\n        (Pi\\<^sub>E {0..<Suc n} F) =\n       emeasure\n        (distr (lim_sequence xa) (Pi\\<^sub>M UNIV (\\<lambda>j. M))\n          (case_nat xa))\n        (y.PF.emb UNIV J (Pi\\<^sub>E J F'))", "finally"], ["proof (chain)\npicking this:\n  emeasure (C 1 n (case_nat y (\\<lambda>_. undefined)))\n   (Pi\\<^sub>E {0..<Suc n} F) =\n  emeasure\n   (distr (lim_sequence y) (Pi\\<^sub>M UNIV (\\<lambda>j. M)) (case_nat y))\n   (y.PF.emb UNIV {0..<Suc n} (Pi\\<^sub>E {0..<Suc n} F))", "show \"emeasure (C 1 n (case_nat y (\\<lambda>_. undefined))) (Pi\\<^sub>E {0..<Suc n} F) =\n        emeasure (distr (lim_sequence y) (Pi\\<^sub>M UNIV (\\<lambda>j. M)) (case_nat y)) (PF.emb UNIV J (Pi\\<^sub>E J F'))\""], ["proof (prove)\nusing this:\n  emeasure (C 1 n (case_nat y (\\<lambda>_. undefined)))\n   (Pi\\<^sub>E {0..<Suc n} F) =\n  emeasure\n   (distr (lim_sequence y) (Pi\\<^sub>M UNIV (\\<lambda>j. M)) (case_nat y))\n   (y.PF.emb UNIV {0..<Suc n} (Pi\\<^sub>E {0..<Suc n} F))\n\ngoal (1 subgoal):\n 1. emeasure (C 1 n (case_nat y (\\<lambda>_. undefined)))\n     (Pi\\<^sub>E {0..<Suc n} F) =\n    emeasure\n     (distr (lim_sequence y) (Pi\\<^sub>M UNIV (\\<lambda>j. M)) (case_nat y))\n     (y.PF.emb UNIV J (Pi\\<^sub>E J F'))", "unfolding emb_eq"], ["proof (prove)\nusing this:\n  emeasure (C 1 n (case_nat y (\\<lambda>_. undefined)))\n   (Pi\\<^sub>E {0..<Suc n} F) =\n  emeasure\n   (distr (lim_sequence y) (Pi\\<^sub>M UNIV (\\<lambda>j. M)) (case_nat y))\n   (y.PF.emb UNIV {0..<Suc n} (Pi\\<^sub>E {0..<Suc n} F))\n\ngoal (1 subgoal):\n 1. emeasure (C 1 n (case_nat y (\\<lambda>_. undefined)))\n     (Pi\\<^sub>E {0..<Suc n} F) =\n    emeasure\n     (distr (lim_sequence y) (Pi\\<^sub>M UNIV (\\<lambda>j. M)) (case_nat y))\n     (y.PF.emb UNIV {0..<Suc n} (Pi\\<^sub>E {0..<Suc n} F))", "."], ["proof (state)\nthis:\n  emeasure (C 1 n (case_nat y (\\<lambda>_. undefined)))\n   (Pi\\<^sub>E {0..<Suc n} F) =\n  emeasure\n   (distr (lim_sequence y) (Pi\\<^sub>M UNIV (\\<lambda>j. M)) (case_nat y))\n   (y.PF.emb UNIV J (Pi\\<^sub>E J F'))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ y. emeasure\n                          (C 1 n (case_nat y (\\<lambda>_. undefined)))\n                          (Pi\\<^sub>E {0..<Suc n} F)\n                     \\<partial>K x =\n  \\<integral>\\<^sup>+ y. emeasure\n                          (distr (lim_sequence y)\n                            (Pi\\<^sub>M UNIV (\\<lambda>j. M)) (case_nat y))\n                          (PF.emb UNIV J (Pi\\<^sub>E J F'))\n                     \\<partial>K x\n\ngoal (1 subgoal):\n 1. \\<And>A J.\n       \\<lbrakk>finite J; J \\<subseteq> UNIV;\n        \\<And>i. i \\<in> J \\<Longrightarrow> A i \\<in> sets M\\<rbrakk>\n       \\<Longrightarrow> emeasure (lim_sequence x)\n                          (PF.emb UNIV J (Pi\\<^sub>E J A)) =\n                         emeasure\n                          (K x \\<bind>\n                           (\\<lambda>y.\n                               distr (lim_sequence y)\n                                (Pi\\<^sub>M UNIV (\\<lambda>j. M))\n                                (case_nat y)))\n                          (PF.emb UNIV J (Pi\\<^sub>E J A))", "also"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ y. emeasure\n                          (C 1 n (case_nat y (\\<lambda>_. undefined)))\n                          (Pi\\<^sub>E {0..<Suc n} F)\n                     \\<partial>K x =\n  \\<integral>\\<^sup>+ y. emeasure\n                          (distr (lim_sequence y)\n                            (Pi\\<^sub>M UNIV (\\<lambda>j. M)) (case_nat y))\n                          (PF.emb UNIV J (Pi\\<^sub>E J F'))\n                     \\<partial>K x\n\ngoal (1 subgoal):\n 1. \\<And>A J.\n       \\<lbrakk>finite J; J \\<subseteq> UNIV;\n        \\<And>i. i \\<in> J \\<Longrightarrow> A i \\<in> sets M\\<rbrakk>\n       \\<Longrightarrow> emeasure (lim_sequence x)\n                          (PF.emb UNIV J (Pi\\<^sub>E J A)) =\n                         emeasure\n                          (K x \\<bind>\n                           (\\<lambda>y.\n                               distr (lim_sequence y)\n                                (Pi\\<^sub>M UNIV (\\<lambda>j. M))\n                                (case_nat y)))\n                          (PF.emb UNIV J (Pi\\<^sub>E J A))", "have \"\\<dots> =\n    emeasure (K x \\<bind> (\\<lambda>y. distr (lim_sequence y) (Pi\\<^sub>M UNIV (\\<lambda>j. M)) (case_nat y))) (PF.emb UNIV J (Pi\\<^sub>E J F'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ y. emeasure\n                            (distr (lim_sequence y)\n                              (Pi\\<^sub>M UNIV (\\<lambda>j. M))\n                              (case_nat y))\n                            (PF.emb UNIV J (Pi\\<^sub>E J F'))\n                       \\<partial>K x =\n    emeasure\n     (K x \\<bind>\n      (\\<lambda>y.\n          distr (lim_sequence y) (Pi\\<^sub>M UNIV (\\<lambda>j. M))\n           (case_nat y)))\n     (PF.emb UNIV J (Pi\\<^sub>E J F'))", "using J"], ["proof (prove)\nusing this:\n  finite J\n  ?i1 \\<in> J \\<Longrightarrow> F' ?i1 \\<in> sets M\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ y. emeasure\n                            (distr (lim_sequence y)\n                              (Pi\\<^sub>M UNIV (\\<lambda>j. M))\n                              (case_nat y))\n                            (PF.emb UNIV J (Pi\\<^sub>E J F'))\n                       \\<partial>K x =\n    emeasure\n     (K x \\<bind>\n      (\\<lambda>y.\n          distr (lim_sequence y) (Pi\\<^sub>M UNIV (\\<lambda>j. M))\n           (case_nat y)))\n     (PF.emb UNIV J (Pi\\<^sub>E J F'))", "by (subst emeasure_bind[where N=\"PiM UNIV (\\<lambda>_. M)\"])\n       (auto simp: sets_K x intro!: measurable_distr2[OF _ measurable_prob_algebraD[OF lim_sequence]] cong: measurable_cong_sets)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ y. emeasure\n                          (distr (lim_sequence y)\n                            (Pi\\<^sub>M UNIV (\\<lambda>j. M)) (case_nat y))\n                          (PF.emb UNIV J (Pi\\<^sub>E J F'))\n                     \\<partial>K x =\n  emeasure\n   (K x \\<bind>\n    (\\<lambda>y.\n        distr (lim_sequence y) (Pi\\<^sub>M UNIV (\\<lambda>j. M))\n         (case_nat y)))\n   (PF.emb UNIV J (Pi\\<^sub>E J F'))\n\ngoal (1 subgoal):\n 1. \\<And>A J.\n       \\<lbrakk>finite J; J \\<subseteq> UNIV;\n        \\<And>i. i \\<in> J \\<Longrightarrow> A i \\<in> sets M\\<rbrakk>\n       \\<Longrightarrow> emeasure (lim_sequence x)\n                          (PF.emb UNIV J (Pi\\<^sub>E J A)) =\n                         emeasure\n                          (K x \\<bind>\n                           (\\<lambda>y.\n                               distr (lim_sequence y)\n                                (Pi\\<^sub>M UNIV (\\<lambda>j. M))\n                                (case_nat y)))\n                          (PF.emb UNIV J (Pi\\<^sub>E J A))", "finally"], ["proof (chain)\npicking this:\n  emeasure (lim_sequence x) (PF.emb UNIV J (Pi\\<^sub>E J F')) =\n  emeasure\n   (K x \\<bind>\n    (\\<lambda>y.\n        distr (lim_sequence y) (Pi\\<^sub>M UNIV (\\<lambda>j. M))\n         (case_nat y)))\n   (PF.emb UNIV J (Pi\\<^sub>E J F'))", "show \"emeasure (lim_sequence x) (PF.emb UNIV J (Pi\\<^sub>E J F')) =\n    emeasure (K x \\<bind> (\\<lambda>y. distr (lim_sequence y) (Pi\\<^sub>M UNIV (\\<lambda>j. M)) (case_nat y)))\n            (PF.emb UNIV J (Pi\\<^sub>E J F'))\""], ["proof (prove)\nusing this:\n  emeasure (lim_sequence x) (PF.emb UNIV J (Pi\\<^sub>E J F')) =\n  emeasure\n   (K x \\<bind>\n    (\\<lambda>y.\n        distr (lim_sequence y) (Pi\\<^sub>M UNIV (\\<lambda>j. M))\n         (case_nat y)))\n   (PF.emb UNIV J (Pi\\<^sub>E J F'))\n\ngoal (1 subgoal):\n 1. emeasure (lim_sequence x) (PF.emb UNIV J (Pi\\<^sub>E J F')) =\n    emeasure\n     (K x \\<bind>\n      (\\<lambda>y.\n          distr (lim_sequence y) (Pi\\<^sub>M UNIV (\\<lambda>j. M))\n           (case_nat y)))\n     (PF.emb UNIV J (Pi\\<^sub>E J F'))", "."], ["proof (state)\nthis:\n  emeasure (lim_sequence x) (PF.emb UNIV J (Pi\\<^sub>E J F')) =\n  emeasure\n   (K x \\<bind>\n    (\\<lambda>y.\n        distr (lim_sequence y) (Pi\\<^sub>M UNIV (\\<lambda>j. M))\n         (case_nat y)))\n   (PF.emb UNIV J (Pi\\<^sub>E J F'))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma AE_lim_sequence:\n  assumes x[simp]: \"x \\<in> space M\" and P[measurable]: \"Measurable.pred (\\<Pi>\\<^sub>M i\\<in>UNIV. M) P\"\n  shows \"(AE \\<omega> in lim_sequence x. P \\<omega>) \\<longleftrightarrow> (AE y in K x. AE \\<omega> in lim_sequence y. P (case_nat y \\<omega>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. almost_everywhere (lim_sequence x) P =\n    (AE y in K x. AE \\<omega> in lim_sequence y. P (case_nat y \\<omega>))", "apply (simp add: lim_sequence_eq cong del: AE_cong)"], ["proof (prove)\ngoal (1 subgoal):\n 1. almost_everywhere\n     (K x \\<bind>\n      (\\<lambda>y.\n          distr (lim_sequence y) (Pi\\<^sub>M UNIV (\\<lambda>j. M))\n           (case_nat y)))\n     P =\n    (AE y in K x. AE \\<omega> in lim_sequence y. P (case_nat y \\<omega>))", "apply (subst AE_bind)"], ["proof (prove)\ngoal (3 subgoals):\n 1. (\\<lambda>y.\n        distr (lim_sequence y) (Pi\\<^sub>M UNIV (\\<lambda>j. M))\n         (case_nat y))\n    \\<in> K x \\<rightarrow>\\<^sub>M subprob_algebra ?B1\n 2. Measurable.pred ?B1 P\n 3. (AE x in K x. almost_everywhere\n                   (distr (lim_sequence x) (Pi\\<^sub>M UNIV (\\<lambda>j. M))\n                     (case_nat x))\n                   P) =\n    (AE y in K x. AE \\<omega> in lim_sequence y. P (case_nat y \\<omega>))", "apply (rule measurable_prob_algebraD)"], ["proof (prove)\ngoal (3 subgoals):\n 1. (\\<lambda>y.\n        distr (lim_sequence y) (Pi\\<^sub>M UNIV (\\<lambda>j. M))\n         (case_nat y))\n    \\<in> K x \\<rightarrow>\\<^sub>M prob_algebra ?B1\n 2. Measurable.pred ?B1 P\n 3. (AE x in K x. almost_everywhere\n                   (distr (lim_sequence x) (Pi\\<^sub>M UNIV (\\<lambda>j. M))\n                     (case_nat x))\n                   P) =\n    (AE y in K x. AE \\<omega> in lim_sequence y. P (case_nat y \\<omega>))", "apply measurable"], ["proof (prove)\ngoal (1 subgoal):\n 1. (AE x in K x. almost_everywhere\n                   (distr (lim_sequence x) (Pi\\<^sub>M UNIV (\\<lambda>j. M))\n                     (case_nat x))\n                   P) =\n    (AE y in K x. AE \\<omega> in lim_sequence y. P (case_nat y \\<omega>))", "apply (auto intro!: AE_cong simp add: space_K AE_distr_iff)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "definition lim_stream :: \"'a \\<Rightarrow> 'a stream measure\"\nwhere\n  \"lim_stream x = distr (lim_sequence x) (stream_space M) to_stream\""], ["", "lemma space_lim_stream: \"space (lim_stream x) = streams (space M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. space (lim_stream x) = streams (space M)", "unfolding lim_stream_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. space (distr (lim_sequence x) (stream_space M) to_stream) =\n    streams (space M)", "by (simp add: space_stream_space)"], ["", "lemma sets_lim_stream[measurable_cong]: \"sets (lim_stream x) = sets (stream_space M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sets (lim_stream x) = sets (stream_space M)", "unfolding lim_stream_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. sets (distr (lim_sequence x) (stream_space M) to_stream) =\n    sets (stream_space M)", "by simp"], ["", "lemma lim_stream[measurable]: \"lim_stream \\<in> M \\<rightarrow>\\<^sub>M prob_algebra (stream_space M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lim_stream \\<in> M \\<rightarrow>\\<^sub>M prob_algebra (stream_space M)", "unfolding lim_stream_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. distr (lim_sequence x) (stream_space M) to_stream)\n    \\<in> M \\<rightarrow>\\<^sub>M prob_algebra (stream_space M)", "by (intro measurable_distr_prob_space2[OF lim_sequence]) auto"], ["", "lemma space_stream_space_M_ne: \"x \\<in> space M \\<Longrightarrow> space (stream_space M) \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> space M \\<Longrightarrow> space (stream_space M) \\<noteq> {}", "using sconst_streams[of x \"space M\"]"], ["proof (prove)\nusing this:\n  x \\<in> space M \\<Longrightarrow> sconst x \\<in> streams (space M)\n\ngoal (1 subgoal):\n 1. x \\<in> space M \\<Longrightarrow> space (stream_space M) \\<noteq> {}", "by (auto simp: space_stream_space)"], ["", "lemma prob_space_lim_stream: \"x \\<in> space M \\<Longrightarrow> prob_space (lim_stream x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> space M \\<Longrightarrow> prob_space (lim_stream x)", "using measurable_space[OF lim_stream, of x]"], ["proof (prove)\nusing this:\n  x \\<in> space M \\<Longrightarrow>\n  lim_stream x \\<in> space (prob_algebra (stream_space M))\n\ngoal (1 subgoal):\n 1. x \\<in> space M \\<Longrightarrow> prob_space (lim_stream x)", "by (simp add: space_prob_algebra)"], ["", "lemma lim_stream_eq:\n  assumes x: \"x \\<in> space M\"\n  shows \"lim_stream x = do { y \\<leftarrow> K x; \\<omega> \\<leftarrow> lim_stream y; return (stream_space M) (y ## \\<omega>) }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lim_stream x =\n    K x \\<bind>\n    (\\<lambda>y.\n        lim_stream y \\<bind>\n        (\\<lambda>\\<omega>. return (stream_space M) (y ## \\<omega>)))", "unfolding lim_stream_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. distr (lim_sequence x) (stream_space M) to_stream =\n    K x \\<bind>\n    (\\<lambda>y.\n        distr (lim_sequence y) (stream_space M) to_stream \\<bind>\n        (\\<lambda>\\<omega>. return (stream_space M) (y ## \\<omega>)))", "apply (subst lim_sequence_eq[OF x])"], ["proof (prove)\ngoal (1 subgoal):\n 1. distr\n     (K x \\<bind>\n      (\\<lambda>y.\n          distr (lim_sequence y) (Pi\\<^sub>M UNIV (\\<lambda>j. M))\n           (case_nat y)))\n     (stream_space M) to_stream =\n    K x \\<bind>\n    (\\<lambda>y.\n        distr (lim_sequence y) (stream_space M) to_stream \\<bind>\n        (\\<lambda>\\<omega>. return (stream_space M) (y ## \\<omega>)))", "apply (subst distr_bind[OF _ _ measurable_to_stream])"], ["proof (prove)\ngoal (3 subgoals):\n 1. (\\<lambda>y.\n        distr (lim_sequence y) (Pi\\<^sub>M UNIV (\\<lambda>j. M))\n         (case_nat y))\n    \\<in> K x \\<rightarrow>\\<^sub>M\n          subprob_algebra (Pi\\<^sub>M UNIV (\\<lambda>i. M))\n 2. space (K x) \\<noteq> {}\n 3. K x \\<bind>\n    (\\<lambda>x.\n        distr\n         (distr (lim_sequence x) (Pi\\<^sub>M UNIV (\\<lambda>j. M))\n           (case_nat x))\n         (stream_space M) to_stream) =\n    K x \\<bind>\n    (\\<lambda>y.\n        distr (lim_sequence y) (stream_space M) to_stream \\<bind>\n        (\\<lambda>\\<omega>. return (stream_space M) (y ## \\<omega>)))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>y.\n        distr (lim_sequence y) (Pi\\<^sub>M UNIV (\\<lambda>j. M))\n         (case_nat y))\n    \\<in> K x \\<rightarrow>\\<^sub>M\n          subprob_algebra (Pi\\<^sub>M UNIV (\\<lambda>i. M))", "by (auto simp: sets_K x cong: measurable_cong_sets\n             intro!: measurable_prob_algebraD measurable_distr_prob_space2[where M=\"Pi\\<^sub>M UNIV (\\<lambda>j. M)\"] lim_sequence) []"], ["proof (prove)\ngoal (2 subgoals):\n 1. space (K x) \\<noteq> {}\n 2. K x \\<bind>\n    (\\<lambda>x.\n        distr\n         (distr (lim_sequence x) (Pi\\<^sub>M UNIV (\\<lambda>j. M))\n           (case_nat x))\n         (stream_space M) to_stream) =\n    K x \\<bind>\n    (\\<lambda>y.\n        distr (lim_sequence y) (stream_space M) to_stream \\<bind>\n        (\\<lambda>\\<omega>. return (stream_space M) (y ## \\<omega>)))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. space (K x) \\<noteq> {}", "using x"], ["proof (prove)\nusing this:\n  x \\<in> space M\n\ngoal (1 subgoal):\n 1. space (K x) \\<noteq> {}", "by (auto simp add: space_K)"], ["proof (prove)\ngoal (1 subgoal):\n 1. K x \\<bind>\n    (\\<lambda>x.\n        distr\n         (distr (lim_sequence x) (Pi\\<^sub>M UNIV (\\<lambda>j. M))\n           (case_nat x))\n         (stream_space M) to_stream) =\n    K x \\<bind>\n    (\\<lambda>y.\n        distr (lim_sequence y) (stream_space M) to_stream \\<bind>\n        (\\<lambda>\\<omega>. return (stream_space M) (y ## \\<omega>)))", "apply (intro bind_cong refl)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> space (K x) \\<Longrightarrow>\n       distr\n        (distr (lim_sequence xa) (Pi\\<^sub>M UNIV (\\<lambda>j. M))\n          (case_nat xa))\n        (stream_space M) to_stream =\n       distr (lim_sequence xa) (stream_space M) to_stream \\<bind>\n       (\\<lambda>\\<omega>. return (stream_space M) (xa ## \\<omega>))", "apply (subst distr_distr)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>xa.\n       xa \\<in> space (K x) \\<Longrightarrow>\n       to_stream\n       \\<in> Pi\\<^sub>M UNIV (\\<lambda>j. M) \\<rightarrow>\\<^sub>M\n             stream_space M\n 2. \\<And>xa.\n       xa \\<in> space (K x) \\<Longrightarrow>\n       case_nat xa\n       \\<in> lim_sequence xa \\<rightarrow>\\<^sub>M\n             Pi\\<^sub>M UNIV (\\<lambda>j. M)\n 3. \\<And>xa.\n       xa \\<in> space (K x) \\<Longrightarrow>\n       distr (lim_sequence xa) (stream_space M)\n        (to_stream \\<circ> case_nat xa) =\n       distr (lim_sequence xa) (stream_space M) to_stream \\<bind>\n       (\\<lambda>\\<omega>. return (stream_space M) (xa ## \\<omega>))", "apply (auto simp: space_K sets_lim_sequence x cong: measurable_cong_sets intro!: distr_cong)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> space M \\<Longrightarrow>\n       distr (lim_sequence x) (stream_space M)\n        (to_stream \\<circ> case_nat x) =\n       distr (lim_sequence x) (stream_space M) to_stream \\<bind>\n       (\\<lambda>\\<omega>. return (stream_space M) (x ## \\<omega>))", "apply (subst bind_return_distr')"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       x \\<in> space M \\<Longrightarrow>\n       space (distr (lim_sequence x) (stream_space M) to_stream) \\<noteq> {}\n 2. \\<And>x.\n       x \\<in> space M \\<Longrightarrow>\n       (##) x\n       \\<in> distr (lim_sequence x) (stream_space M)\n              to_stream \\<rightarrow>\\<^sub>M\n             stream_space M\n 3. \\<And>x.\n       x \\<in> space M \\<Longrightarrow>\n       distr (lim_sequence x) (stream_space M)\n        (to_stream \\<circ> case_nat x) =\n       distr (distr (lim_sequence x) (stream_space M) to_stream)\n        (stream_space M) ((##) x)", "apply (auto simp: space_stream_space_M_ne)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> space M \\<Longrightarrow>\n       distr (lim_sequence x) (stream_space M)\n        (to_stream \\<circ> case_nat x) =\n       distr (distr (lim_sequence x) (stream_space M) to_stream)\n        (stream_space M) ((##) x)", "apply (subst distr_distr)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       x \\<in> space M \\<Longrightarrow>\n       (##) x \\<in> stream_space M \\<rightarrow>\\<^sub>M stream_space M\n 2. \\<And>x.\n       x \\<in> space M \\<Longrightarrow>\n       to_stream \\<in> lim_sequence x \\<rightarrow>\\<^sub>M stream_space M\n 3. \\<And>x.\n       x \\<in> space M \\<Longrightarrow>\n       distr (lim_sequence x) (stream_space M)\n        (to_stream \\<circ> case_nat x) =\n       distr (lim_sequence x) (stream_space M) ((##) x \\<circ> to_stream)", "apply (auto simp: space_K sets_lim_sequence x to_stream_nat_case cong: measurable_cong_sets intro!: distr_cong)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma AE_lim_stream:\n  assumes x[simp]: \"x \\<in> space M\" and P[measurable]: \"Measurable.pred (stream_space M) P\"\n  shows \"(AE \\<omega> in lim_stream x. P \\<omega>) \\<longleftrightarrow> (AE y in K x. AE \\<omega> in lim_stream y. P (y ## \\<omega>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. almost_everywhere (lim_stream x) P =\n    (AE y in K x. AE \\<omega> in lim_stream y. P (y ## \\<omega>))", "unfolding lim_stream_eq[OF x]"], ["proof (prove)\ngoal (1 subgoal):\n 1. almost_everywhere\n     (K x \\<bind>\n      (\\<lambda>y.\n          lim_stream y \\<bind>\n          (\\<lambda>\\<omega>. return (stream_space M) (y ## \\<omega>))))\n     P =\n    (AE y in K x. AE \\<omega> in lim_stream y. P (y ## \\<omega>))", "by (simp_all add: space_K space_lim_stream space_stream_space AE_return AE_bind[OF measurable_prob_algebraD P] cong: AE_cong_simp)"], ["", "lemma emeasure_lim_stream:\n  assumes x[measurable, simp]: \"x \\<in> space M\" and A[measurable, simp]: \"A \\<in> sets (stream_space M)\"\n  shows \"lim_stream x A = (\\<integral>\\<^sup>+y. emeasure (lim_stream y) (((##) y) -` A \\<inter> space (stream_space M)) \\<partial>K x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure (lim_stream x) A =\n    \\<integral>\\<^sup>+ y. emeasure (lim_stream y)\n                            ((##) y -` A \\<inter> space (stream_space M))\n                       \\<partial>K x", "apply (subst lim_stream_eq, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure\n     (K x \\<bind>\n      (\\<lambda>y.\n          lim_stream y \\<bind>\n          (\\<lambda>\\<omega>. return (stream_space M) (y ## \\<omega>))))\n     A =\n    \\<integral>\\<^sup>+ y. emeasure (lim_stream y)\n                            ((##) y -` A \\<inter> space (stream_space M))\n                       \\<partial>K x", "apply (subst emeasure_bind[OF _ _ A], simp add: prob_space.not_empty prob_space_K)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (\\<lambda>y.\n        lim_stream y \\<bind>\n        (\\<lambda>\\<omega>. return (stream_space M) (y ## \\<omega>)))\n    \\<in> K x \\<rightarrow>\\<^sub>M subprob_algebra (stream_space M)\n 2. \\<integral>\\<^sup>+ x. emeasure\n                            (lim_stream x \\<bind>\n                             (\\<lambda>\\<omega>.\n                                 return (stream_space M) (x ## \\<omega>)))\n                            A\n                       \\<partial>K x =\n    \\<integral>\\<^sup>+ y. emeasure (lim_stream y)\n                            ((##) y -` A \\<inter> space (stream_space M))\n                       \\<partial>K x", "apply (rule measurable_prob_algebraD)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (\\<lambda>y.\n        lim_stream y \\<bind>\n        (\\<lambda>\\<omega>. return (stream_space M) (y ## \\<omega>)))\n    \\<in> K x \\<rightarrow>\\<^sub>M prob_algebra (stream_space M)\n 2. \\<integral>\\<^sup>+ x. emeasure\n                            (lim_stream x \\<bind>\n                             (\\<lambda>\\<omega>.\n                                 return (stream_space M) (x ## \\<omega>)))\n                            A\n                       \\<partial>K x =\n    \\<integral>\\<^sup>+ y. emeasure (lim_stream y)\n                            ((##) y -` A \\<inter> space (stream_space M))\n                       \\<partial>K x", "apply measurable"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ x. emeasure\n                            (lim_stream x \\<bind>\n                             (\\<lambda>\\<omega>.\n                                 return (stream_space M) (x ## \\<omega>)))\n                            A\n                       \\<partial>K x =\n    \\<integral>\\<^sup>+ y. emeasure (lim_stream y)\n                            ((##) y -` A \\<inter> space (stream_space M))\n                       \\<partial>K x", "apply (intro nn_integral_cong)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> space (K x) \\<Longrightarrow>\n       emeasure\n        (lim_stream xa \\<bind>\n         (\\<lambda>\\<omega>. return (stream_space M) (xa ## \\<omega>)))\n        A =\n       emeasure (lim_stream xa)\n        ((##) xa -` A \\<inter> space (stream_space M))", "apply (subst bind_return_distr')"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>xa.\n       xa \\<in> space (K x) \\<Longrightarrow>\n       space (lim_stream xa) \\<noteq> {}\n 2. \\<And>xa.\n       xa \\<in> space (K x) \\<Longrightarrow>\n       (##) xa \\<in> lim_stream xa \\<rightarrow>\\<^sub>M stream_space M\n 3. \\<And>xa.\n       xa \\<in> space (K x) \\<Longrightarrow>\n       emeasure (distr (lim_stream xa) (stream_space M) ((##) xa)) A =\n       emeasure (lim_stream xa)\n        ((##) xa -` A \\<inter> space (stream_space M))", "apply (auto intro!: prob_space.not_empty prob_space_lim_stream simp: space_K emeasure_distr)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> space M \\<Longrightarrow>\n       emeasure (lim_stream x) ((##) x -` A \\<inter> space (lim_stream x)) =\n       emeasure (lim_stream x) ((##) x -` A \\<inter> space (stream_space M))", "apply (simp add: space_lim_stream space_stream_space)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma lim_stream_eq_coinduct[case_names in_space step]:\n  fixes R :: \"'a \\<Rightarrow> 'a stream measure \\<Rightarrow> bool\"\n  assumes x: \"R x B\" \"x \\<in> space M\"\n  assumes R: \"\\<And>x B. R x B \\<Longrightarrow> \\<exists>B'\\<in>M \\<rightarrow>\\<^sub>M prob_algebra (stream_space M).\n    (AE y in K x. R y (B' y) \\<or> lim_stream y = B' y) \\<and>\n    B = do { y \\<leftarrow> K x; \\<omega> \\<leftarrow> B' y; return (stream_space M) (y ## \\<omega>) }\"\n  shows \"lim_stream x = B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lim_stream x = B", "using x"], ["proof (prove)\nusing this:\n  R x B\n  x \\<in> space M\n\ngoal (1 subgoal):\n 1. lim_stream x = B", "proof (coinduction arbitrary: x B rule: stream_space_coinduct[where M=M, case_names step])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x Ba.\n       \\<lbrakk>R x Ba; x \\<in> space M\\<rbrakk>\n       \\<Longrightarrow> \\<exists>K\\<in>space (prob_algebra M).\n                            \\<exists>A'\\<in>M \\<rightarrow>\\<^sub>M\n      prob_algebra (stream_space M).\n                               \\<exists>B'\n  \\<in>M \\<rightarrow>\\<^sub>M prob_algebra (stream_space M).\n                                  (AE y in K. (\\<exists>x B.\n            A' y = lim_stream x \\<and>\n            B' y = B \\<and> R x B \\<and> x \\<in> space M) \\<or>\n        A' y = B' y) \\<and>\n                                  lim_stream x =\n                                  K \\<bind>\n                                  (\\<lambda>y.\nA' y \\<bind>\n(\\<lambda>\\<omega>. return (stream_space M) (y ## \\<omega>))) \\<and>\n                                  Ba =\n                                  K \\<bind>\n                                  (\\<lambda>y.\nB' y \\<bind> (\\<lambda>\\<omega>. return (stream_space M) (y ## \\<omega>)))", "case (step x B)"], ["proof (state)\nthis:\n  R x B\n  x \\<in> space M\n\ngoal (1 subgoal):\n 1. \\<And>x Ba.\n       \\<lbrakk>R x Ba; x \\<in> space M\\<rbrakk>\n       \\<Longrightarrow> \\<exists>K\\<in>space (prob_algebra M).\n                            \\<exists>A'\\<in>M \\<rightarrow>\\<^sub>M\n      prob_algebra (stream_space M).\n                               \\<exists>B'\n  \\<in>M \\<rightarrow>\\<^sub>M prob_algebra (stream_space M).\n                                  (AE y in K. (\\<exists>x B.\n            A' y = lim_stream x \\<and>\n            B' y = B \\<and> R x B \\<and> x \\<in> space M) \\<or>\n        A' y = B' y) \\<and>\n                                  lim_stream x =\n                                  K \\<bind>\n                                  (\\<lambda>y.\nA' y \\<bind>\n(\\<lambda>\\<omega>. return (stream_space M) (y ## \\<omega>))) \\<and>\n                                  Ba =\n                                  K \\<bind>\n                                  (\\<lambda>y.\nB' y \\<bind> (\\<lambda>\\<omega>. return (stream_space M) (y ## \\<omega>)))", "from R[OF \\<open>R x B\\<close>]"], ["proof (chain)\npicking this:\n  \\<exists>B'\\<in>M \\<rightarrow>\\<^sub>M prob_algebra (stream_space M).\n     (AE y in K x. R y (B' y) \\<or> lim_stream y = B' y) \\<and>\n     B =\n     K x \\<bind>\n     (\\<lambda>y.\n         B' y \\<bind>\n         (\\<lambda>\\<omega>. return (stream_space M) (y ## \\<omega>)))", "obtain B' where B': \"B' \\<in> M \\<rightarrow>\\<^sub>M prob_algebra (stream_space M)\"\n    and ae: \"AE y in K x. R y (B' y) \\<or> lim_stream y = B' y\"\n    and eq: \"B = K x \\<bind> (\\<lambda>y. B' y \\<bind> (\\<lambda>\\<omega>. return (stream_space M) (y ## \\<omega>)))\""], ["proof (prove)\nusing this:\n  \\<exists>B'\\<in>M \\<rightarrow>\\<^sub>M prob_algebra (stream_space M).\n     (AE y in K x. R y (B' y) \\<or> lim_stream y = B' y) \\<and>\n     B =\n     K x \\<bind>\n     (\\<lambda>y.\n         B' y \\<bind>\n         (\\<lambda>\\<omega>. return (stream_space M) (y ## \\<omega>)))\n\ngoal (1 subgoal):\n 1. (\\<And>B'.\n        \\<lbrakk>B' \\<in> M \\<rightarrow>\\<^sub>M\n                          prob_algebra (stream_space M);\n         AE y in K x. R y (B' y) \\<or> lim_stream y = B' y;\n         B =\n         K x \\<bind>\n         (\\<lambda>y.\n             B' y \\<bind>\n             (\\<lambda>\\<omega>.\n                 return (stream_space M) (y ## \\<omega>)))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  B' \\<in> M \\<rightarrow>\\<^sub>M prob_algebra (stream_space M)\n  AE y in K x. R y (B' y) \\<or> lim_stream y = B' y\n  B =\n  K x \\<bind>\n  (\\<lambda>y.\n      B' y \\<bind>\n      (\\<lambda>\\<omega>. return (stream_space M) (y ## \\<omega>)))\n\ngoal (1 subgoal):\n 1. \\<And>x Ba.\n       \\<lbrakk>R x Ba; x \\<in> space M\\<rbrakk>\n       \\<Longrightarrow> \\<exists>K\\<in>space (prob_algebra M).\n                            \\<exists>A'\\<in>M \\<rightarrow>\\<^sub>M\n      prob_algebra (stream_space M).\n                               \\<exists>B'\n  \\<in>M \\<rightarrow>\\<^sub>M prob_algebra (stream_space M).\n                                  (AE y in K. (\\<exists>x B.\n            A' y = lim_stream x \\<and>\n            B' y = B \\<and> R x B \\<and> x \\<in> space M) \\<or>\n        A' y = B' y) \\<and>\n                                  lim_stream x =\n                                  K \\<bind>\n                                  (\\<lambda>y.\nA' y \\<bind>\n(\\<lambda>\\<omega>. return (stream_space M) (y ## \\<omega>))) \\<and>\n                                  Ba =\n                                  K \\<bind>\n                                  (\\<lambda>y.\nB' y \\<bind> (\\<lambda>\\<omega>. return (stream_space M) (y ## \\<omega>)))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>K\\<in>space (prob_algebra M).\n       \\<exists>A'\\<in>M \\<rightarrow>\\<^sub>M\n                       prob_algebra (stream_space M).\n          \\<exists>B'\\<in>M \\<rightarrow>\\<^sub>M\n                          prob_algebra (stream_space M).\n             (AE y in K. (\\<exists>x B.\n                             A' y = lim_stream x \\<and>\n                             B' y = B \\<and>\n                             R x B \\<and> x \\<in> space M) \\<or>\n                         A' y = B' y) \\<and>\n             lim_stream x =\n             K \\<bind>\n             (\\<lambda>y.\n                 A' y \\<bind>\n                 (\\<lambda>\\<omega>.\n                     return (stream_space M) (y ## \\<omega>))) \\<and>\n             B =\n             K \\<bind>\n             (\\<lambda>y.\n                 B' y \\<bind>\n                 (\\<lambda>\\<omega>.\n                     return (stream_space M) (y ## \\<omega>)))", "apply (rule bexI[of _ \"K x\"], rule bexI[OF _ lim_stream], rule bexI[OF _ B'])"], ["proof (prove)\ngoal (2 subgoals):\n 1. (AE y in K x. (\\<exists>x B.\n                      lim_stream y = lim_stream x \\<and>\n                      B' y = B \\<and> R x B \\<and> x \\<in> space M) \\<or>\n                  lim_stream y = B' y) \\<and>\n    lim_stream x =\n    K x \\<bind>\n    (\\<lambda>y.\n        lim_stream y \\<bind>\n        (\\<lambda>\\<omega>. return (stream_space M) (y ## \\<omega>))) \\<and>\n    B =\n    K x \\<bind>\n    (\\<lambda>y.\n        B' y \\<bind>\n        (\\<lambda>\\<omega>. return (stream_space M) (y ## \\<omega>)))\n 2. K x \\<in> space (prob_algebra M)", "apply (intro conjI)"], ["proof (prove)\ngoal (4 subgoals):\n 1. AE y in K x. (\\<exists>x B.\n                     lim_stream y = lim_stream x \\<and>\n                     B' y = B \\<and> R x B \\<and> x \\<in> space M) \\<or>\n                 lim_stream y = B' y\n 2. lim_stream x =\n    K x \\<bind>\n    (\\<lambda>y.\n        lim_stream y \\<bind>\n        (\\<lambda>\\<omega>. return (stream_space M) (y ## \\<omega>)))\n 3. B =\n    K x \\<bind>\n    (\\<lambda>y.\n        B' y \\<bind>\n        (\\<lambda>\\<omega>. return (stream_space M) (y ## \\<omega>)))\n 4. K x \\<in> space (prob_algebra M)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. AE y in K x. (\\<exists>x B.\n                     lim_stream y = lim_stream x \\<and>\n                     B' y = B \\<and> R x B \\<and> x \\<in> space M) \\<or>\n                 lim_stream y = B' y", "using ae AE_space"], ["proof (prove)\nusing this:\n  AE y in K x. R y (B' y) \\<or> lim_stream y = B' y\n  AE x in ?M. x \\<in> space ?M\n\ngoal (1 subgoal):\n 1. AE y in K x. (\\<exists>x B.\n                     lim_stream y = lim_stream x \\<and>\n                     B' y = B \\<and> R x B \\<and> x \\<in> space M) \\<or>\n                 lim_stream y = B' y", "by eventually_elim (insert \\<open>x\\<in>space M\\<close>, auto simp: space_K)"], ["proof (prove)\ngoal (3 subgoals):\n 1. lim_stream x =\n    K x \\<bind>\n    (\\<lambda>y.\n        lim_stream y \\<bind>\n        (\\<lambda>\\<omega>. return (stream_space M) (y ## \\<omega>)))\n 2. B =\n    K x \\<bind>\n    (\\<lambda>y.\n        B' y \\<bind>\n        (\\<lambda>\\<omega>. return (stream_space M) (y ## \\<omega>)))\n 3. K x \\<in> space (prob_algebra M)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. lim_stream x =\n    K x \\<bind>\n    (\\<lambda>y.\n        lim_stream y \\<bind>\n        (\\<lambda>\\<omega>. return (stream_space M) (y ## \\<omega>)))", "by (rule lim_stream_eq) fact"], ["proof (prove)\ngoal (2 subgoals):\n 1. B =\n    K x \\<bind>\n    (\\<lambda>y.\n        B' y \\<bind>\n        (\\<lambda>\\<omega>. return (stream_space M) (y ## \\<omega>)))\n 2. K x \\<in> space (prob_algebra M)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. B =\n    K x \\<bind>\n    (\\<lambda>y.\n        B' y \\<bind>\n        (\\<lambda>\\<omega>. return (stream_space M) (y ## \\<omega>)))", "by (rule eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. K x \\<in> space (prob_algebra M)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. K x \\<in> space (prob_algebra M)", "using K \\<open>x \\<in> space M\\<close>"], ["proof (prove)\nusing this:\n  K \\<in> M \\<rightarrow>\\<^sub>M prob_algebra M\n  x \\<in> space M\n\ngoal (1 subgoal):\n 1. K x \\<in> space (prob_algebra M)", "by (rule measurable_space)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>K\\<in>space (prob_algebra M).\n     \\<exists>A'\\<in>M \\<rightarrow>\\<^sub>M prob_algebra (stream_space M).\n        \\<exists>B'\\<in>M \\<rightarrow>\\<^sub>M\n                        prob_algebra (stream_space M).\n           (AE y in K. (\\<exists>x B.\n                           A' y = lim_stream x \\<and>\n                           B' y = B \\<and>\n                           R x B \\<and> x \\<in> space M) \\<or>\n                       A' y = B' y) \\<and>\n           lim_stream x =\n           K \\<bind>\n           (\\<lambda>y.\n               A' y \\<bind>\n               (\\<lambda>\\<omega>.\n                   return (stream_space M) (y ## \\<omega>))) \\<and>\n           B =\n           K \\<bind>\n           (\\<lambda>y.\n               B' y \\<bind>\n               (\\<lambda>\\<omega>. return (stream_space M) (y ## \\<omega>)))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma prob_space_lim_sequence: \"x \\<in> space M \\<Longrightarrow> prob_space (lim_sequence x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> space M \\<Longrightarrow> prob_space (lim_sequence x)", "using measurable_space[OF lim_sequence, of x]"], ["proof (prove)\nusing this:\n  x \\<in> space M \\<Longrightarrow>\n  lim_sequence x\n  \\<in> space (prob_algebra (Pi\\<^sub>M UNIV (\\<lambda>i. M)))\n\ngoal (1 subgoal):\n 1. x \\<in> space M \\<Longrightarrow> prob_space (lim_sequence x)", "by (simp add: space_prob_algebra)"], ["", "end"], ["", "subsection \\<open>Strong Markov Property for Discrete-Time Markov Processes\\<close>"], ["", "text \\<open>The filtration adopted to streams, i.e. to the $n$-th projection.\\<close>"], ["", "definition stream_filtration :: \"'a measure \\<Rightarrow> enat \\<Rightarrow> 'a stream measure\"\n  where \"stream_filtration M n = (SUP i\\<in>{i::nat. i \\<le> n}. vimage_algebra (streams (space M)) (\\<lambda>\\<omega> . \\<omega> !! i) M)\""], ["", "lemma measurable_stream_filtration1: \"enat i \\<le> n \\<Longrightarrow> (\\<lambda>\\<omega>. \\<omega> !! i) \\<in> stream_filtration M n \\<rightarrow>\\<^sub>M M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enat i \\<le> n \\<Longrightarrow>\n    (\\<lambda>\\<omega>. \\<omega> !! i)\n    \\<in> stream_filtration M n \\<rightarrow>\\<^sub>M M", "by (auto intro!: measurable_SUP1 measurable_vimage_algebra1 snth_in simp: stream_filtration_def)"], ["", "lemma measurable_stream_filtration2:\n  \"f \\<in> space N \\<rightarrow> streams (space M) \\<Longrightarrow> (\\<And>i. enat i \\<le> n \\<Longrightarrow> (\\<lambda>x. f x !! i) \\<in> N \\<rightarrow>\\<^sub>M M) \\<Longrightarrow> f \\<in> N \\<rightarrow>\\<^sub>M stream_filtration M n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>f \\<in> space N \\<rightarrow> streams (space M);\n     \\<And>i.\n        enat i \\<le> n \\<Longrightarrow>\n        (\\<lambda>x. f x !! i) \\<in> N \\<rightarrow>\\<^sub>M M\\<rbrakk>\n    \\<Longrightarrow> f \\<in> N \\<rightarrow>\\<^sub>M stream_filtration M n", "by (auto simp: stream_filtration_def enat_0\n           intro!: measurable_SUP2 measurable_vimage_algebra2 elim!: allE[of _ \"0::nat\"])"], ["", "lemma space_stream_filtration: \"space (stream_filtration M n) = space (stream_space M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. space (stream_filtration M n) = space (stream_space M)", "by (auto simp add: space_stream_space space_Sup_eq_UN stream_filtration_def enat_0 elim!: allE[of _ 0])"], ["", "lemma sets_stream_filteration_le_stream_space: \"sets (stream_filtration M n) \\<subseteq> sets (stream_space M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sets (stream_filtration M n) \\<subseteq> sets (stream_space M)", "unfolding sets_stream_space_eq stream_filtration_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. sets\n     (\\<Squnion>i\\<in>{x. enat x \\<le> n}.\n         vimage_algebra (streams (space M))\n          (\\<lambda>\\<omega>. \\<omega> !! i) M)\n    \\<subseteq> sets\n                 (\\<Squnion>i.\n                     vimage_algebra (streams (space M)) (\\<lambda>s. s !! i)\n                      M)", "by (intro SUP_subset_mono le_measureD2) (auto simp: space_Sup_eq_UN enat_0 elim!: allE[of _ 0])"], ["", "interpretation stream_filtration: filtration \"space (stream_space M)\" \"stream_filtration M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filtration (space (stream_space M)) (stream_filtration M)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i. space (stream_filtration M i) = space (stream_space M)\n 2. \\<And>i j.\n       i \\<le> j \\<Longrightarrow>\n       sets (stream_filtration M i) \\<subseteq> sets (stream_filtration M j)", "show \"space (stream_filtration M i) = space (stream_space M)\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. space (stream_filtration M i) = space (stream_space M)", "by (simp add: space_stream_filtration)"], ["proof (state)\nthis:\n  space (stream_filtration M ?i) = space (stream_space M)\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       i \\<le> j \\<Longrightarrow>\n       sets (stream_filtration M i) \\<subseteq> sets (stream_filtration M j)", "show \"sets (stream_filtration M i) \\<subseteq> sets (stream_filtration M j)\" if \"i \\<le> j\" for i j"], ["proof (prove)\ngoal (1 subgoal):\n 1. sets (stream_filtration M i) \\<subseteq> sets (stream_filtration M j)", "proof (rule le_measureD2)"], ["proof (state)\ngoal (2 subgoals):\n 1. stream_filtration M i \\<le> stream_filtration M j\n 2. space (stream_filtration M i) = space (stream_filtration M j)", "show \"stream_filtration M i \\<le> stream_filtration M j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stream_filtration M i \\<le> stream_filtration M j", "using \\<open>i \\<le> j\\<close>"], ["proof (prove)\nusing this:\n  i \\<le> j\n\ngoal (1 subgoal):\n 1. stream_filtration M i \\<le> stream_filtration M j", "unfolding stream_filtration_def"], ["proof (prove)\nusing this:\n  i \\<le> j\n\ngoal (1 subgoal):\n 1. (\\<Squnion>i\\<in>{x. enat x \\<le> i}.\n        vimage_algebra (streams (space M))\n         (\\<lambda>\\<omega>. \\<omega> !! i) M)\n    \\<le> (\\<Squnion>i\\<in>{x. enat x \\<le> j}.\n              vimage_algebra (streams (space M))\n               (\\<lambda>\\<omega>. \\<omega> !! i) M)", "by (intro SUP_subset_mono) auto"], ["proof (state)\nthis:\n  stream_filtration M i \\<le> stream_filtration M j\n\ngoal (1 subgoal):\n 1. space (stream_filtration M i) = space (stream_filtration M j)", "qed (simp add: space_stream_filtration)"], ["proof (state)\nthis:\n  ?i \\<le> ?j \\<Longrightarrow>\n  sets (stream_filtration M ?i) \\<subseteq> sets (stream_filtration M ?j)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma measurable_stopping_time_stream:\n  \"stopping_time (stream_filtration M) T \\<Longrightarrow> T \\<in> stream_space M \\<rightarrow>\\<^sub>M count_space UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stopping_time (stream_filtration M) T \\<Longrightarrow>\n    T \\<in> stream_space M \\<rightarrow>\\<^sub>M count_space UNIV", "using sets_stream_filteration_le_stream_space"], ["proof (prove)\nusing this:\n  sets (stream_filtration ?M ?n) \\<subseteq> sets (stream_space ?M)\n\ngoal (1 subgoal):\n 1. stopping_time (stream_filtration M) T \\<Longrightarrow>\n    T \\<in> stream_space M \\<rightarrow>\\<^sub>M count_space UNIV", "by (subst measurable_cong_sets[OF refl sets_borel_eq_count_space[symmetric, where 'a=enat]])\n     (auto intro!: measurable_stopping_time simp: space_stream_filtration)"], ["", "lemma measurable_stopping_time_All_eq_0:\n  assumes T: \"stopping_time (stream_filtration M) T\"\n  shows \"{x\\<in>space M. \\<forall>\\<omega>\\<in>streams (space M). T (x ## \\<omega>) = 0} \\<in> sets M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {x \\<in> space M.\n     \\<forall>\\<omega>\\<in>streams (space M). T (x ## \\<omega>) = 0}\n    \\<in> sets M", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. {x \\<in> space M.\n     \\<forall>\\<omega>\\<in>streams (space M). T (x ## \\<omega>) = 0}\n    \\<in> sets M", "have \"{\\<omega>\\<in>streams (space M). T \\<omega> = 0} \\<in> vimage_algebra (streams (space M)) (\\<lambda>\\<omega>. \\<omega> !! 0) M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {\\<omega> \\<in> streams (space M). T \\<omega> = 0}\n    \\<in> sets\n           (vimage_algebra (streams (space M))\n             (\\<lambda>\\<omega>. \\<omega> !! 0) M)", "using stopping_timeD[OF T, of 0]"], ["proof (prove)\nusing this:\n  Measurable.pred (stream_filtration M 0) (\\<lambda>x. T x \\<le> 0)\n\ngoal (1 subgoal):\n 1. {\\<omega> \\<in> streams (space M). T \\<omega> = 0}\n    \\<in> sets\n           (vimage_algebra (streams (space M))\n             (\\<lambda>\\<omega>. \\<omega> !! 0) M)", "by (simp add: stream_filtration_def pred_def enat_0_iff)"], ["proof (state)\nthis:\n  {\\<omega> \\<in> streams (space M). T \\<omega> = 0}\n  \\<in> sets\n         (vimage_algebra (streams (space M))\n           (\\<lambda>\\<omega>. \\<omega> !! 0) M)\n\ngoal (1 subgoal):\n 1. {x \\<in> space M.\n     \\<forall>\\<omega>\\<in>streams (space M). T (x ## \\<omega>) = 0}\n    \\<in> sets M", "then"], ["proof (chain)\npicking this:\n  {\\<omega> \\<in> streams (space M). T \\<omega> = 0}\n  \\<in> sets\n         (vimage_algebra (streams (space M))\n           (\\<lambda>\\<omega>. \\<omega> !! 0) M)", "obtain A\n    where A: \"A \\<in> sets M\"\n      and *: \"{\\<omega> \\<in> streams (space M). T \\<omega> = 0} = (\\<lambda>\\<omega>. \\<omega> !! 0) -` A \\<inter> streams (space M)\""], ["proof (prove)\nusing this:\n  {\\<omega> \\<in> streams (space M). T \\<omega> = 0}\n  \\<in> sets\n         (vimage_algebra (streams (space M))\n           (\\<lambda>\\<omega>. \\<omega> !! 0) M)\n\ngoal (1 subgoal):\n 1. (\\<And>A.\n        \\<lbrakk>A \\<in> sets M;\n         {\\<omega> \\<in> streams (space M). T \\<omega> = 0} =\n         (\\<lambda>\\<omega>. \\<omega> !! 0) -` A \\<inter>\n         streams (space M)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: sets_vimage_algebra2 streams_shd)"], ["proof (state)\nthis:\n  A \\<in> sets M\n  {\\<omega> \\<in> streams (space M). T \\<omega> = 0} =\n  (\\<lambda>\\<omega>. \\<omega> !! 0) -` A \\<inter> streams (space M)\n\ngoal (1 subgoal):\n 1. {x \\<in> space M.\n     \\<forall>\\<omega>\\<in>streams (space M). T (x ## \\<omega>) = 0}\n    \\<in> sets M", "have \"A = {x\\<in>space M. \\<forall>\\<omega>\\<in>streams (space M). T (x ## \\<omega>) = 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A =\n    {x \\<in> space M.\n     \\<forall>\\<omega>\\<in>streams (space M). T (x ## \\<omega>) = 0}", "proof safe"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x. x \\<in> A \\<Longrightarrow> x \\<in> space M\n 2. \\<And>x \\<omega>.\n       \\<lbrakk>x \\<in> A; \\<omega> \\<in> streams (space M)\\<rbrakk>\n       \\<Longrightarrow> T (x ## \\<omega>) = 0\n 3. \\<And>x.\n       \\<lbrakk>x \\<in> space M;\n        \\<forall>\\<omega>\\<in>streams (space M).\n           T (x ## \\<omega>) = 0\\<rbrakk>\n       \\<Longrightarrow> x \\<in> A", "fix x \\<omega>"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x. x \\<in> A \\<Longrightarrow> x \\<in> space M\n 2. \\<And>x \\<omega>.\n       \\<lbrakk>x \\<in> A; \\<omega> \\<in> streams (space M)\\<rbrakk>\n       \\<Longrightarrow> T (x ## \\<omega>) = 0\n 3. \\<And>x.\n       \\<lbrakk>x \\<in> space M;\n        \\<forall>\\<omega>\\<in>streams (space M).\n           T (x ## \\<omega>) = 0\\<rbrakk>\n       \\<Longrightarrow> x \\<in> A", "assume \"x \\<in> A\" \"\\<omega> \\<in> streams (space M)\""], ["proof (state)\nthis:\n  x \\<in> A\n  \\<omega> \\<in> streams (space M)\n\ngoal (3 subgoals):\n 1. \\<And>x. x \\<in> A \\<Longrightarrow> x \\<in> space M\n 2. \\<And>x \\<omega>.\n       \\<lbrakk>x \\<in> A; \\<omega> \\<in> streams (space M)\\<rbrakk>\n       \\<Longrightarrow> T (x ## \\<omega>) = 0\n 3. \\<And>x.\n       \\<lbrakk>x \\<in> space M;\n        \\<forall>\\<omega>\\<in>streams (space M).\n           T (x ## \\<omega>) = 0\\<rbrakk>\n       \\<Longrightarrow> x \\<in> A", "then"], ["proof (chain)\npicking this:\n  x \\<in> A\n  \\<omega> \\<in> streams (space M)", "have \"x ## \\<omega> \\<in> {\\<omega> \\<in> streams (space M). T \\<omega> = 0}\""], ["proof (prove)\nusing this:\n  x \\<in> A\n  \\<omega> \\<in> streams (space M)\n\ngoal (1 subgoal):\n 1. x ## \\<omega> \\<in> {\\<omega> \\<in> streams (space M). T \\<omega> = 0}", "unfolding *"], ["proof (prove)\nusing this:\n  x \\<in> A\n  \\<omega> \\<in> streams (space M)\n\ngoal (1 subgoal):\n 1. x ## \\<omega>\n    \\<in> (\\<lambda>\\<omega>. \\<omega> !! 0) -` A \\<inter> streams (space M)", "using A[THEN sets.sets_into_space]"], ["proof (prove)\nusing this:\n  x \\<in> A\n  \\<omega> \\<in> streams (space M)\n  A \\<subseteq> space M\n\ngoal (1 subgoal):\n 1. x ## \\<omega>\n    \\<in> (\\<lambda>\\<omega>. \\<omega> !! 0) -` A \\<inter> streams (space M)", "by auto"], ["proof (state)\nthis:\n  x ## \\<omega> \\<in> {\\<omega> \\<in> streams (space M). T \\<omega> = 0}\n\ngoal (3 subgoals):\n 1. \\<And>x. x \\<in> A \\<Longrightarrow> x \\<in> space M\n 2. \\<And>x \\<omega>.\n       \\<lbrakk>x \\<in> A; \\<omega> \\<in> streams (space M)\\<rbrakk>\n       \\<Longrightarrow> T (x ## \\<omega>) = 0\n 3. \\<And>x.\n       \\<lbrakk>x \\<in> space M;\n        \\<forall>\\<omega>\\<in>streams (space M).\n           T (x ## \\<omega>) = 0\\<rbrakk>\n       \\<Longrightarrow> x \\<in> A", "then"], ["proof (chain)\npicking this:\n  x ## \\<omega> \\<in> {\\<omega> \\<in> streams (space M). T \\<omega> = 0}", "show \"T (x ## \\<omega>) = 0\""], ["proof (prove)\nusing this:\n  x ## \\<omega> \\<in> {\\<omega> \\<in> streams (space M). T \\<omega> = 0}\n\ngoal (1 subgoal):\n 1. T (x ## \\<omega>) = 0", "by auto"], ["proof (state)\nthis:\n  T (x ## \\<omega>) = 0\n\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> A \\<Longrightarrow> x \\<in> space M\n 2. \\<And>x.\n       \\<lbrakk>x \\<in> space M;\n        \\<forall>\\<omega>\\<in>streams (space M).\n           T (x ## \\<omega>) = 0\\<rbrakk>\n       \\<Longrightarrow> x \\<in> A", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> A \\<Longrightarrow> x \\<in> space M\n 2. \\<And>x.\n       \\<lbrakk>x \\<in> space M;\n        \\<forall>\\<omega>\\<in>streams (space M).\n           T (x ## \\<omega>) = 0\\<rbrakk>\n       \\<Longrightarrow> x \\<in> A", "fix x"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> A \\<Longrightarrow> x \\<in> space M\n 2. \\<And>x.\n       \\<lbrakk>x \\<in> space M;\n        \\<forall>\\<omega>\\<in>streams (space M).\n           T (x ## \\<omega>) = 0\\<rbrakk>\n       \\<Longrightarrow> x \\<in> A", "assume \"x \\<in> space M\" \"\\<forall>\\<omega>\\<in>streams (space M). T (x ## \\<omega>) = 0 \""], ["proof (state)\nthis:\n  x \\<in> space M\n  \\<forall>\\<omega>\\<in>streams (space M). T (x ## \\<omega>) = 0\n\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> A \\<Longrightarrow> x \\<in> space M\n 2. \\<And>x.\n       \\<lbrakk>x \\<in> space M;\n        \\<forall>\\<omega>\\<in>streams (space M).\n           T (x ## \\<omega>) = 0\\<rbrakk>\n       \\<Longrightarrow> x \\<in> A", "then"], ["proof (chain)\npicking this:\n  x \\<in> space M\n  \\<forall>\\<omega>\\<in>streams (space M). T (x ## \\<omega>) = 0", "have \"\\<forall>\\<omega>\\<in>streams (space M). x ## \\<omega> \\<in> {\\<omega> \\<in> streams (space M). T \\<omega> = 0}\""], ["proof (prove)\nusing this:\n  x \\<in> space M\n  \\<forall>\\<omega>\\<in>streams (space M). T (x ## \\<omega>) = 0\n\ngoal (1 subgoal):\n 1. \\<forall>\\<omega>\\<in>streams (space M).\n       x ## \\<omega>\n       \\<in> {\\<omega> \\<in> streams (space M). T \\<omega> = 0}", "by simp"], ["proof (state)\nthis:\n  \\<forall>\\<omega>\\<in>streams (space M).\n     x ## \\<omega> \\<in> {\\<omega> \\<in> streams (space M). T \\<omega> = 0}\n\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> A \\<Longrightarrow> x \\<in> space M\n 2. \\<And>x.\n       \\<lbrakk>x \\<in> space M;\n        \\<forall>\\<omega>\\<in>streams (space M).\n           T (x ## \\<omega>) = 0\\<rbrakk>\n       \\<Longrightarrow> x \\<in> A", "with \\<open>x\\<in>space M\\<close>"], ["proof (chain)\npicking this:\n  x \\<in> space M\n  \\<forall>\\<omega>\\<in>streams (space M).\n     x ## \\<omega> \\<in> {\\<omega> \\<in> streams (space M). T \\<omega> = 0}", "show \"x \\<in> A\""], ["proof (prove)\nusing this:\n  x \\<in> space M\n  \\<forall>\\<omega>\\<in>streams (space M).\n     x ## \\<omega> \\<in> {\\<omega> \\<in> streams (space M). T \\<omega> = 0}\n\ngoal (1 subgoal):\n 1. x \\<in> A", "unfolding *"], ["proof (prove)\nusing this:\n  x \\<in> space M\n  \\<forall>\\<omega>\\<in>streams (space M).\n     x ## \\<omega>\n     \\<in> (\\<lambda>\\<omega>. \\<omega> !! 0) -` A \\<inter>\n           streams (space M)\n\ngoal (1 subgoal):\n 1. x \\<in> A", "by (auto simp: streams_empty_iff)"], ["proof (state)\nthis:\n  x \\<in> A\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> A \\<Longrightarrow> x \\<in> space M", "qed (use A[THEN sets.sets_into_space] in auto)"], ["proof (state)\nthis:\n  A =\n  {x \\<in> space M.\n   \\<forall>\\<omega>\\<in>streams (space M). T (x ## \\<omega>) = 0}\n\ngoal (1 subgoal):\n 1. {x \\<in> space M.\n     \\<forall>\\<omega>\\<in>streams (space M). T (x ## \\<omega>) = 0}\n    \\<in> sets M", "with \\<open>A \\<in> sets M\\<close>"], ["proof (chain)\npicking this:\n  A \\<in> sets M\n  A =\n  {x \\<in> space M.\n   \\<forall>\\<omega>\\<in>streams (space M). T (x ## \\<omega>) = 0}", "show ?thesis"], ["proof (prove)\nusing this:\n  A \\<in> sets M\n  A =\n  {x \\<in> space M.\n   \\<forall>\\<omega>\\<in>streams (space M). T (x ## \\<omega>) = 0}\n\ngoal (1 subgoal):\n 1. {x \\<in> space M.\n     \\<forall>\\<omega>\\<in>streams (space M). T (x ## \\<omega>) = 0}\n    \\<in> sets M", "by auto"], ["proof (state)\nthis:\n  {x \\<in> space M.\n   \\<forall>\\<omega>\\<in>streams (space M). T (x ## \\<omega>) = 0}\n  \\<in> sets M\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma stopping_time_0:\n  assumes T: \"stopping_time (stream_filtration M) T\"\n    and x: \"x \\<in> space M\" and \\<omega>: \"\\<omega> \\<in> streams (space M)\" \"T (x ## \\<omega>) > 0\"\n    and \\<omega>': \"\\<omega>' \\<in> streams (space M)\"\n  shows \"T (x ## \\<omega>') > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < T (x ## \\<omega>')", "unfolding zero_less_iff_neq_zero"], ["proof (prove)\ngoal (1 subgoal):\n 1. T (x ## \\<omega>') \\<noteq> 0", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. T (x ## \\<omega>') = 0 \\<Longrightarrow> False", "assume \"T (x ## \\<omega>') = 0\""], ["proof (state)\nthis:\n  T (x ## \\<omega>') = 0\n\ngoal (1 subgoal):\n 1. T (x ## \\<omega>') = 0 \\<Longrightarrow> False", "with x \\<omega>'"], ["proof (chain)\npicking this:\n  x \\<in> space M\n  \\<omega>' \\<in> streams (space M)\n  T (x ## \\<omega>') = 0", "have x': \"x ## \\<omega>' \\<in> {\\<omega> \\<in> streams (space M). T \\<omega> = 0}\""], ["proof (prove)\nusing this:\n  x \\<in> space M\n  \\<omega>' \\<in> streams (space M)\n  T (x ## \\<omega>') = 0\n\ngoal (1 subgoal):\n 1. x ## \\<omega>' \\<in> {\\<omega> \\<in> streams (space M). T \\<omega> = 0}", "by auto"], ["proof (state)\nthis:\n  x ## \\<omega>' \\<in> {\\<omega> \\<in> streams (space M). T \\<omega> = 0}\n\ngoal (1 subgoal):\n 1. T (x ## \\<omega>') = 0 \\<Longrightarrow> False", "have \"{\\<omega>\\<in>streams (space M). T \\<omega> = 0} \\<in> vimage_algebra (streams (space M)) (\\<lambda>\\<omega>. \\<omega> !! 0) M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {\\<omega> \\<in> streams (space M). T \\<omega> = 0}\n    \\<in> sets\n           (vimage_algebra (streams (space M))\n             (\\<lambda>\\<omega>. \\<omega> !! 0) M)", "using stopping_timeD[OF T, of 0]"], ["proof (prove)\nusing this:\n  Measurable.pred (stream_filtration M 0) (\\<lambda>x. T x \\<le> 0)\n\ngoal (1 subgoal):\n 1. {\\<omega> \\<in> streams (space M). T \\<omega> = 0}\n    \\<in> sets\n           (vimage_algebra (streams (space M))\n             (\\<lambda>\\<omega>. \\<omega> !! 0) M)", "by (simp add: stream_filtration_def pred_def enat_0_iff)"], ["proof (state)\nthis:\n  {\\<omega> \\<in> streams (space M). T \\<omega> = 0}\n  \\<in> sets\n         (vimage_algebra (streams (space M))\n           (\\<lambda>\\<omega>. \\<omega> !! 0) M)\n\ngoal (1 subgoal):\n 1. T (x ## \\<omega>') = 0 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  {\\<omega> \\<in> streams (space M). T \\<omega> = 0}\n  \\<in> sets\n         (vimage_algebra (streams (space M))\n           (\\<lambda>\\<omega>. \\<omega> !! 0) M)", "obtain A\n    where A: \"A \\<in> sets M\"\n      and *: \"{\\<omega> \\<in> streams (space M). T \\<omega> = 0} = (\\<lambda>\\<omega>. \\<omega> !! 0) -` A \\<inter> streams (space M)\""], ["proof (prove)\nusing this:\n  {\\<omega> \\<in> streams (space M). T \\<omega> = 0}\n  \\<in> sets\n         (vimage_algebra (streams (space M))\n           (\\<lambda>\\<omega>. \\<omega> !! 0) M)\n\ngoal (1 subgoal):\n 1. (\\<And>A.\n        \\<lbrakk>A \\<in> sets M;\n         {\\<omega> \\<in> streams (space M). T \\<omega> = 0} =\n         (\\<lambda>\\<omega>. \\<omega> !! 0) -` A \\<inter>\n         streams (space M)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: sets_vimage_algebra2 streams_shd)"], ["proof (state)\nthis:\n  A \\<in> sets M\n  {\\<omega> \\<in> streams (space M). T \\<omega> = 0} =\n  (\\<lambda>\\<omega>. \\<omega> !! 0) -` A \\<inter> streams (space M)\n\ngoal (1 subgoal):\n 1. T (x ## \\<omega>') = 0 \\<Longrightarrow> False", "with x'"], ["proof (chain)\npicking this:\n  x ## \\<omega>' \\<in> {\\<omega> \\<in> streams (space M). T \\<omega> = 0}\n  A \\<in> sets M\n  {\\<omega> \\<in> streams (space M). T \\<omega> = 0} =\n  (\\<lambda>\\<omega>. \\<omega> !! 0) -` A \\<inter> streams (space M)", "have \"x \\<in> A\""], ["proof (prove)\nusing this:\n  x ## \\<omega>' \\<in> {\\<omega> \\<in> streams (space M). T \\<omega> = 0}\n  A \\<in> sets M\n  {\\<omega> \\<in> streams (space M). T \\<omega> = 0} =\n  (\\<lambda>\\<omega>. \\<omega> !! 0) -` A \\<inter> streams (space M)\n\ngoal (1 subgoal):\n 1. x \\<in> A", "by auto"], ["proof (state)\nthis:\n  x \\<in> A\n\ngoal (1 subgoal):\n 1. T (x ## \\<omega>') = 0 \\<Longrightarrow> False", "with \\<omega> x"], ["proof (chain)\npicking this:\n  \\<omega> \\<in> streams (space M)\n  0 < T (x ## \\<omega>)\n  x \\<in> space M\n  x \\<in> A", "have \"x ## \\<omega> \\<in> (\\<lambda>\\<omega>. \\<omega> !! 0) -` A \\<inter> streams (space M)\""], ["proof (prove)\nusing this:\n  \\<omega> \\<in> streams (space M)\n  0 < T (x ## \\<omega>)\n  x \\<in> space M\n  x \\<in> A\n\ngoal (1 subgoal):\n 1. x ## \\<omega>\n    \\<in> (\\<lambda>\\<omega>. \\<omega> !! 0) -` A \\<inter> streams (space M)", "by auto"], ["proof (state)\nthis:\n  x ## \\<omega>\n  \\<in> (\\<lambda>\\<omega>. \\<omega> !! 0) -` A \\<inter> streams (space M)\n\ngoal (1 subgoal):\n 1. T (x ## \\<omega>') = 0 \\<Longrightarrow> False", "with \\<omega>"], ["proof (chain)\npicking this:\n  \\<omega> \\<in> streams (space M)\n  0 < T (x ## \\<omega>)\n  x ## \\<omega>\n  \\<in> (\\<lambda>\\<omega>. \\<omega> !! 0) -` A \\<inter> streams (space M)", "show False"], ["proof (prove)\nusing this:\n  \\<omega> \\<in> streams (space M)\n  0 < T (x ## \\<omega>)\n  x ## \\<omega>\n  \\<in> (\\<lambda>\\<omega>. \\<omega> !! 0) -` A \\<inter> streams (space M)\n\ngoal (1 subgoal):\n 1. False", "unfolding *[symmetric]"], ["proof (prove)\nusing this:\n  \\<omega> \\<in> streams (space M)\n  0 < T (x ## \\<omega>)\n  x ## \\<omega> \\<in> {\\<omega> \\<in> streams (space M). T \\<omega> = 0}\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma stopping_time_epred_SCons:\n  assumes T: \"stopping_time (stream_filtration M) T\"\n    and x: \"x \\<in> space M\" and \\<omega>: \"\\<omega> \\<in> streams (space M)\" \"T (x ## \\<omega>) > 0\"\n  shows \"stopping_time (stream_filtration M) (\\<lambda>\\<omega>. epred (T (x ## \\<omega>)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stopping_time (stream_filtration M)\n     (\\<lambda>\\<omega>. epred (T (x ## \\<omega>)))", "proof (rule stopping_timeI, rule measurable_cong[THEN iffD2])"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>t w.\n       w \\<in> space (stream_filtration M t) \\<Longrightarrow>\n       (epred (T (x ## w)) \\<le> t) = ?g3 t w\n 2. \\<And>t. Measurable.pred (stream_filtration M t) (?g3 t)", "show \"\\<omega> \\<in> space (stream_filtration M t) \\<Longrightarrow> (epred (T (x ## \\<omega>)) \\<le> t) = (T (x ## \\<omega>) \\<le> eSuc t)\" for t \\<omega>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<omega> \\<in> space (stream_filtration M t) \\<Longrightarrow>\n    (epred (T (x ## \\<omega>)) \\<le> t) = (T (x ## \\<omega>) \\<le> eSuc t)", "by (cases \"T (x ## \\<omega>)\" rule: enat_coexhaust)\n       (auto simp add: space_stream_filtration space_stream_space dest!: stopping_time_0[OF T x \\<omega>])"], ["proof (state)\nthis:\n  ?\\<omega> \\<in> space (stream_filtration M ?t) \\<Longrightarrow>\n  (epred (T (x ## ?\\<omega>)) \\<le> ?t) = (T (x ## ?\\<omega>) \\<le> eSuc ?t)\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       Measurable.pred (stream_filtration M t)\n        (\\<lambda>w. T (x ## w) \\<le> eSuc t)", "show \"Measurable.pred (stream_filtration M t) (\\<lambda>w. T (x ## w) \\<le> eSuc t)\" for t"], ["proof (prove)\ngoal (1 subgoal):\n 1. Measurable.pred (stream_filtration M t)\n     (\\<lambda>w. T (x ## w) \\<le> eSuc t)", "proof (rule measurable_compose[of \"SCons x\"])"], ["proof (state)\ngoal (2 subgoals):\n 1. (##) x \\<in> stream_filtration M t \\<rightarrow>\\<^sub>M ?N\n 2. Measurable.pred ?N (\\<lambda>a. T a \\<le> eSuc t)", "show \"(##) x \\<in> stream_filtration M t \\<rightarrow>\\<^sub>M stream_filtration M (eSuc t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (##) x\n    \\<in> stream_filtration M t \\<rightarrow>\\<^sub>M\n          stream_filtration M (eSuc t)", "proof (intro measurable_stream_filtration2)"], ["proof (state)\ngoal (2 subgoals):\n 1. (##) x\n    \\<in> space (stream_filtration M t) \\<rightarrow> streams (space M)\n 2. \\<And>i.\n       enat i \\<le> eSuc t \\<Longrightarrow>\n       (\\<lambda>xa. (x ## xa) !! i)\n       \\<in> stream_filtration M t \\<rightarrow>\\<^sub>M M", "show \"enat i \\<le> eSuc t \\<Longrightarrow> (\\<lambda>xa. (x ## xa) !! i) \\<in> stream_filtration M t \\<rightarrow>\\<^sub>M M\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. enat i \\<le> eSuc t \\<Longrightarrow>\n    (\\<lambda>xa. (x ## xa) !! i)\n    \\<in> stream_filtration M t \\<rightarrow>\\<^sub>M M", "using \\<open>x\\<in>space M\\<close>"], ["proof (prove)\nusing this:\n  x \\<in> space M\n\ngoal (1 subgoal):\n 1. enat i \\<le> eSuc t \\<Longrightarrow>\n    (\\<lambda>xa. (x ## xa) !! i)\n    \\<in> stream_filtration M t \\<rightarrow>\\<^sub>M M", "by (cases i) (auto simp: eSuc_enat[symmetric] intro!: measurable_stream_filtration1)"], ["proof (state)\nthis:\n  enat ?i \\<le> eSuc t \\<Longrightarrow>\n  (\\<lambda>xa. (x ## xa) !! ?i)\n  \\<in> stream_filtration M t \\<rightarrow>\\<^sub>M M\n\ngoal (1 subgoal):\n 1. (##) x\n    \\<in> space (stream_filtration M t) \\<rightarrow> streams (space M)", "qed (auto simp: space_stream_filtration space_stream_space \\<open>x\\<in>space M\\<close>)"], ["proof (state)\nthis:\n  (##) x\n  \\<in> stream_filtration M t \\<rightarrow>\\<^sub>M\n        stream_filtration M (eSuc t)\n\ngoal (1 subgoal):\n 1. Measurable.pred (stream_filtration M (eSuc t))\n     (\\<lambda>a. T a \\<le> eSuc t)", "qed (rule T[THEN stopping_timeD])"], ["proof (state)\nthis:\n  Measurable.pred (stream_filtration M ?t)\n   (\\<lambda>w. T (x ## w) \\<le> eSuc ?t)\n\ngoal:\nNo subgoals!", "qed"], ["", "context discrete_Markov_process\nbegin"], ["", "lemma lim_stream_strong_Markov:\n  assumes x: \"x \\<in> space M\" and T: \"stopping_time (stream_filtration M) T\"\n  shows \"lim_stream x =\n    lim_stream x \\<bind> (\\<lambda>\\<omega>. case T \\<omega> of\n      enat i \\<Rightarrow> distr (lim_stream (\\<omega> !! i)) (stream_space M) (\\<lambda>\\<omega>'. stake (Suc i) \\<omega> @- \\<omega>')\n    | \\<infinity>     \\<Rightarrow> return (stream_space M) \\<omega>)\"\n  (is \"_ = ?L T x\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. lim_stream x =\n    lim_stream x \\<bind>\n    (\\<lambda>\\<omega>.\n        case T \\<omega> of\n        enat i \\<Rightarrow>\n          distr (lim_stream (\\<omega> !! i)) (stream_space M)\n           ((@-) (stake (Suc i) \\<omega>))\n        | \\<infinity> \\<Rightarrow> return (stream_space M) \\<omega>)", "using assms"], ["proof (prove)\nusing this:\n  x \\<in> space M\n  stopping_time (stream_filtration M) T\n\ngoal (1 subgoal):\n 1. lim_stream x =\n    lim_stream x \\<bind>\n    (\\<lambda>\\<omega>.\n        case T \\<omega> of\n        enat i \\<Rightarrow>\n          distr (lim_stream (\\<omega> !! i)) (stream_space M)\n           ((@-) (stake (Suc i) \\<omega>))\n        | \\<infinity> \\<Rightarrow> return (stream_space M) \\<omega>)", "proof (coinduction arbitrary: x T rule: lim_stream_eq_coinduct)"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<in> space M\n 2. \\<And>xa T.\n       \\<lbrakk>xa \\<in> space M;\n        stopping_time (stream_filtration M) T\\<rbrakk>\n       \\<Longrightarrow> \\<exists>B'\\<in>M \\<rightarrow>\\<^sub>M\n   prob_algebra (stream_space M).\n                            (AE y in K\nxa. (\\<exists>x T.\n        y = x \\<and>\n        B' y =\n        lim_stream x \\<bind>\n        (\\<lambda>\\<omega>.\n            case T \\<omega> of\n            enat i \\<Rightarrow>\n              distr (lim_stream (\\<omega> !! i)) (stream_space M)\n               ((@-) (stake (Suc i) \\<omega>))\n            | \\<infinity> \\<Rightarrow>\n                return (stream_space M) \\<omega>) \\<and>\n        x \\<in> space M \\<and> stopping_time (stream_filtration M) T) \\<or>\n    lim_stream y = B' y) \\<and>\n                            lim_stream xa \\<bind>\n                            (\\<lambda>\\<omega>.\n                                case T \\<omega> of\n                                enat i \\<Rightarrow>\n                                  distr (lim_stream (\\<omega> !! i))\n                                   (stream_space M)\n                                   ((@-) (stake (Suc i) \\<omega>))\n                                | \\<infinity> \\<Rightarrow>\n                                    return (stream_space M) \\<omega>) =\n                            K xa \\<bind>\n                            (\\<lambda>y.\n                                B' y \\<bind>\n                                (\\<lambda>\\<omega>.\n                                    return (stream_space M)\n                                     (y ## \\<omega>)))", "case (step x T)"], ["proof (state)\nthis:\n  x \\<in> space M\n  stopping_time (stream_filtration M) T\n\ngoal (2 subgoals):\n 1. x \\<in> space M\n 2. \\<And>xa T.\n       \\<lbrakk>xa \\<in> space M;\n        stopping_time (stream_filtration M) T\\<rbrakk>\n       \\<Longrightarrow> \\<exists>B'\\<in>M \\<rightarrow>\\<^sub>M\n   prob_algebra (stream_space M).\n                            (AE y in K\nxa. (\\<exists>x T.\n        y = x \\<and>\n        B' y =\n        lim_stream x \\<bind>\n        (\\<lambda>\\<omega>.\n            case T \\<omega> of\n            enat i \\<Rightarrow>\n              distr (lim_stream (\\<omega> !! i)) (stream_space M)\n               ((@-) (stake (Suc i) \\<omega>))\n            | \\<infinity> \\<Rightarrow>\n                return (stream_space M) \\<omega>) \\<and>\n        x \\<in> space M \\<and> stopping_time (stream_filtration M) T) \\<or>\n    lim_stream y = B' y) \\<and>\n                            lim_stream xa \\<bind>\n                            (\\<lambda>\\<omega>.\n                                case T \\<omega> of\n                                enat i \\<Rightarrow>\n                                  distr (lim_stream (\\<omega> !! i))\n                                   (stream_space M)\n                                   ((@-) (stake (Suc i) \\<omega>))\n                                | \\<infinity> \\<Rightarrow>\n                                    return (stream_space M) \\<omega>) =\n                            K xa \\<bind>\n                            (\\<lambda>y.\n                                B' y \\<bind>\n                                (\\<lambda>\\<omega>.\n                                    return (stream_space M)\n                                     (y ## \\<omega>)))", "note T = \\<open>stopping_time (stream_filtration M) T\\<close>[THEN measurable_stopping_time_stream, measurable]"], ["proof (state)\nthis:\n  T \\<in> stream_space M \\<rightarrow>\\<^sub>M count_space UNIV\n\ngoal (2 subgoals):\n 1. x \\<in> space M\n 2. \\<And>xa T.\n       \\<lbrakk>xa \\<in> space M;\n        stopping_time (stream_filtration M) T\\<rbrakk>\n       \\<Longrightarrow> \\<exists>B'\\<in>M \\<rightarrow>\\<^sub>M\n   prob_algebra (stream_space M).\n                            (AE y in K\nxa. (\\<exists>x T.\n        y = x \\<and>\n        B' y =\n        lim_stream x \\<bind>\n        (\\<lambda>\\<omega>.\n            case T \\<omega> of\n            enat i \\<Rightarrow>\n              distr (lim_stream (\\<omega> !! i)) (stream_space M)\n               ((@-) (stake (Suc i) \\<omega>))\n            | \\<infinity> \\<Rightarrow>\n                return (stream_space M) \\<omega>) \\<and>\n        x \\<in> space M \\<and> stopping_time (stream_filtration M) T) \\<or>\n    lim_stream y = B' y) \\<and>\n                            lim_stream xa \\<bind>\n                            (\\<lambda>\\<omega>.\n                                case T \\<omega> of\n                                enat i \\<Rightarrow>\n                                  distr (lim_stream (\\<omega> !! i))\n                                   (stream_space M)\n                                   ((@-) (stake (Suc i) \\<omega>))\n                                | \\<infinity> \\<Rightarrow>\n                                    return (stream_space M) \\<omega>) =\n                            K xa \\<bind>\n                            (\\<lambda>y.\n                                B' y \\<bind>\n                                (\\<lambda>\\<omega>.\n                                    return (stream_space M)\n                                     (y ## \\<omega>)))", "define L where \"L T x = ?L T x\" for T x"], ["proof (state)\nthis:\n  L ?T ?x =\n  lim_stream ?x \\<bind>\n  (\\<lambda>\\<omega>.\n      case ?T \\<omega> of\n      enat i \\<Rightarrow>\n        distr (lim_stream (\\<omega> !! i)) (stream_space M)\n         ((@-) (stake (Suc i) \\<omega>))\n      | \\<infinity> \\<Rightarrow> return (stream_space M) \\<omega>)\n\ngoal (2 subgoals):\n 1. x \\<in> space M\n 2. \\<And>xa T.\n       \\<lbrakk>xa \\<in> space M;\n        stopping_time (stream_filtration M) T\\<rbrakk>\n       \\<Longrightarrow> \\<exists>B'\\<in>M \\<rightarrow>\\<^sub>M\n   prob_algebra (stream_space M).\n                            (AE y in K\nxa. (\\<exists>x T.\n        y = x \\<and>\n        B' y =\n        lim_stream x \\<bind>\n        (\\<lambda>\\<omega>.\n            case T \\<omega> of\n            enat i \\<Rightarrow>\n              distr (lim_stream (\\<omega> !! i)) (stream_space M)\n               ((@-) (stake (Suc i) \\<omega>))\n            | \\<infinity> \\<Rightarrow>\n                return (stream_space M) \\<omega>) \\<and>\n        x \\<in> space M \\<and> stopping_time (stream_filtration M) T) \\<or>\n    lim_stream y = B' y) \\<and>\n                            lim_stream xa \\<bind>\n                            (\\<lambda>\\<omega>.\n                                case T \\<omega> of\n                                enat i \\<Rightarrow>\n                                  distr (lim_stream (\\<omega> !! i))\n                                   (stream_space M)\n                                   ((@-) (stake (Suc i) \\<omega>))\n                                | \\<infinity> \\<Rightarrow>\n                                    return (stream_space M) \\<omega>) =\n                            K xa \\<bind>\n                            (\\<lambda>y.\n                                B' y \\<bind>\n                                (\\<lambda>\\<omega>.\n                                    return (stream_space M)\n                                     (y ## \\<omega>)))", "have L[measurable (raw)]:\n    \"(\\<lambda>(x, \\<omega>). T x \\<omega>) \\<in> N \\<Otimes>\\<^sub>M stream_space M \\<rightarrow>\\<^sub>M count_space UNIV \\<Longrightarrow>\n    f \\<in> N \\<rightarrow>\\<^sub>M M \\<Longrightarrow> (\\<lambda>x. L (T x) (f x)) \\<in> N \\<rightarrow>\\<^sub>M prob_algebra (stream_space M)\" for f :: \"'a \\<Rightarrow> 'a\" and N T"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<lambda>(x, \\<omega>). T x \\<omega>)\n             \\<in> N \\<Otimes>\\<^sub>M stream_space M \\<rightarrow>\\<^sub>M\n                   count_space UNIV;\n     f \\<in> N \\<rightarrow>\\<^sub>M M\\<rbrakk>\n    \\<Longrightarrow> (\\<lambda>x. L (T x) (f x))\n                      \\<in> N \\<rightarrow>\\<^sub>M\n                            prob_algebra (stream_space M)", "unfolding L_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<lambda>(x, \\<omega>). T x \\<omega>)\n             \\<in> N \\<Otimes>\\<^sub>M stream_space M \\<rightarrow>\\<^sub>M\n                   count_space UNIV;\n     f \\<in> N \\<rightarrow>\\<^sub>M M\\<rbrakk>\n    \\<Longrightarrow> (\\<lambda>x.\n                          lim_stream (f x) \\<bind>\n                          (\\<lambda>\\<omega>.\n                              case T x \\<omega> of\n                              enat i \\<Rightarrow>\n                                distr (lim_stream (\\<omega> !! i))\n                                 (stream_space M)\n                                 ((@-) (stake (Suc i) \\<omega>))\n                              | \\<infinity> \\<Rightarrow>\n                                  return (stream_space M) \\<omega>))\n                      \\<in> N \\<rightarrow>\\<^sub>M\n                            prob_algebra (stream_space M)", "by (intro measurable_bind_prob_space2[OF measurable_compose[OF _ lim_stream]] measurable_case_enat\n        measurable_distr_prob_space2[OF measurable_compose[OF _ lim_stream]]\n        measurable_return_prob_space measurable_stopping_time_stream)\n       auto"], ["proof (state)\nthis:\n  \\<lbrakk>(\\<lambda>(x, \\<omega>). ?T x \\<omega>)\n           \\<in> ?N \\<Otimes>\\<^sub>M stream_space M \\<rightarrow>\\<^sub>M\n                 count_space UNIV;\n   ?f \\<in> ?N \\<rightarrow>\\<^sub>M M\\<rbrakk>\n  \\<Longrightarrow> (\\<lambda>x. L (?T x) (?f x))\n                    \\<in> ?N \\<rightarrow>\\<^sub>M\n                          prob_algebra (stream_space M)\n\ngoal (2 subgoals):\n 1. x \\<in> space M\n 2. \\<And>xa T.\n       \\<lbrakk>xa \\<in> space M;\n        stopping_time (stream_filtration M) T\\<rbrakk>\n       \\<Longrightarrow> \\<exists>B'\\<in>M \\<rightarrow>\\<^sub>M\n   prob_algebra (stream_space M).\n                            (AE y in K\nxa. (\\<exists>x T.\n        y = x \\<and>\n        B' y =\n        lim_stream x \\<bind>\n        (\\<lambda>\\<omega>.\n            case T \\<omega> of\n            enat i \\<Rightarrow>\n              distr (lim_stream (\\<omega> !! i)) (stream_space M)\n               ((@-) (stake (Suc i) \\<omega>))\n            | \\<infinity> \\<Rightarrow>\n                return (stream_space M) \\<omega>) \\<and>\n        x \\<in> space M \\<and> stopping_time (stream_filtration M) T) \\<or>\n    lim_stream y = B' y) \\<and>\n                            lim_stream xa \\<bind>\n                            (\\<lambda>\\<omega>.\n                                case T \\<omega> of\n                                enat i \\<Rightarrow>\n                                  distr (lim_stream (\\<omega> !! i))\n                                   (stream_space M)\n                                   ((@-) (stake (Suc i) \\<omega>))\n                                | \\<infinity> \\<Rightarrow>\n                                    return (stream_space M) \\<omega>) =\n                            K xa \\<bind>\n                            (\\<lambda>y.\n                                B' y \\<bind>\n                                (\\<lambda>\\<omega>.\n                                    return (stream_space M)\n                                     (y ## \\<omega>)))", "define S where \"S x = (if \\<forall>\\<omega>\\<in>streams (space M). T (x##\\<omega>) = 0 then lim_stream x else L (\\<lambda>\\<omega>. epred (T (x ## \\<omega>))) x)\" for x"], ["proof (state)\nthis:\n  S ?x =\n  (if \\<forall>\\<omega>\\<in>streams (space M). T (?x ## \\<omega>) = 0\n   then lim_stream ?x\n   else L (\\<lambda>\\<omega>. epred (T (?x ## \\<omega>))) ?x)\n\ngoal (2 subgoals):\n 1. x \\<in> space M\n 2. \\<And>xa T.\n       \\<lbrakk>xa \\<in> space M;\n        stopping_time (stream_filtration M) T\\<rbrakk>\n       \\<Longrightarrow> \\<exists>B'\\<in>M \\<rightarrow>\\<^sub>M\n   prob_algebra (stream_space M).\n                            (AE y in K\nxa. (\\<exists>x T.\n        y = x \\<and>\n        B' y =\n        lim_stream x \\<bind>\n        (\\<lambda>\\<omega>.\n            case T \\<omega> of\n            enat i \\<Rightarrow>\n              distr (lim_stream (\\<omega> !! i)) (stream_space M)\n               ((@-) (stake (Suc i) \\<omega>))\n            | \\<infinity> \\<Rightarrow>\n                return (stream_space M) \\<omega>) \\<and>\n        x \\<in> space M \\<and> stopping_time (stream_filtration M) T) \\<or>\n    lim_stream y = B' y) \\<and>\n                            lim_stream xa \\<bind>\n                            (\\<lambda>\\<omega>.\n                                case T \\<omega> of\n                                enat i \\<Rightarrow>\n                                  distr (lim_stream (\\<omega> !! i))\n                                   (stream_space M)\n                                   ((@-) (stake (Suc i) \\<omega>))\n                                | \\<infinity> \\<Rightarrow>\n                                    return (stream_space M) \\<omega>) =\n                            K xa \\<bind>\n                            (\\<lambda>y.\n                                B' y \\<bind>\n                                (\\<lambda>\\<omega>.\n                                    return (stream_space M)\n                                     (y ## \\<omega>)))", "then"], ["proof (chain)\npicking this:\n  S ?x =\n  (if \\<forall>\\<omega>\\<in>streams (space M). T (?x ## \\<omega>) = 0\n   then lim_stream ?x\n   else L (\\<lambda>\\<omega>. epred (T (?x ## \\<omega>))) ?x)", "have S_eq: \"\\<forall>\\<omega>\\<in>streams (space M). T (x##\\<omega>) = 0 \\<Longrightarrow> S x = lim_stream x\"\n    \"\\<not> (\\<forall>\\<omega>\\<in>streams (space M). T (x##\\<omega>) = 0) \\<Longrightarrow> S x = L (\\<lambda>\\<omega>. epred (T (x ## \\<omega>))) x\" for x"], ["proof (prove)\nusing this:\n  S ?x =\n  (if \\<forall>\\<omega>\\<in>streams (space M). T (?x ## \\<omega>) = 0\n   then lim_stream ?x\n   else L (\\<lambda>\\<omega>. epred (T (?x ## \\<omega>))) ?x)\n\ngoal (1 subgoal):\n 1. (\\<forall>\\<omega>\\<in>streams (space M).\n        T (x ## \\<omega>) = 0 \\<Longrightarrow>\n     S x = lim_stream x) &&&\n    (\\<not> (\\<forall>\\<omega>\\<in>streams (space M).\n                T (x ## \\<omega>) = 0) \\<Longrightarrow>\n     S x = L (\\<lambda>\\<omega>. epred (T (x ## \\<omega>))) x)", "by auto"], ["proof (state)\nthis:\n  \\<forall>\\<omega>\\<in>streams (space M).\n     T (?x ## \\<omega>) = 0 \\<Longrightarrow>\n  S ?x = lim_stream ?x\n  \\<not> (\\<forall>\\<omega>\\<in>streams (space M).\n             T (?x ## \\<omega>) = 0) \\<Longrightarrow>\n  S ?x = L (\\<lambda>\\<omega>. epred (T (?x ## \\<omega>))) ?x\n\ngoal (2 subgoals):\n 1. x \\<in> space M\n 2. \\<And>xa T.\n       \\<lbrakk>xa \\<in> space M;\n        stopping_time (stream_filtration M) T\\<rbrakk>\n       \\<Longrightarrow> \\<exists>B'\\<in>M \\<rightarrow>\\<^sub>M\n   prob_algebra (stream_space M).\n                            (AE y in K\nxa. (\\<exists>x T.\n        y = x \\<and>\n        B' y =\n        lim_stream x \\<bind>\n        (\\<lambda>\\<omega>.\n            case T \\<omega> of\n            enat i \\<Rightarrow>\n              distr (lim_stream (\\<omega> !! i)) (stream_space M)\n               ((@-) (stake (Suc i) \\<omega>))\n            | \\<infinity> \\<Rightarrow>\n                return (stream_space M) \\<omega>) \\<and>\n        x \\<in> space M \\<and> stopping_time (stream_filtration M) T) \\<or>\n    lim_stream y = B' y) \\<and>\n                            lim_stream xa \\<bind>\n                            (\\<lambda>\\<omega>.\n                                case T \\<omega> of\n                                enat i \\<Rightarrow>\n                                  distr (lim_stream (\\<omega> !! i))\n                                   (stream_space M)\n                                   ((@-) (stake (Suc i) \\<omega>))\n                                | \\<infinity> \\<Rightarrow>\n                                    return (stream_space M) \\<omega>) =\n                            K xa \\<bind>\n                            (\\<lambda>y.\n                                B' y \\<bind>\n                                (\\<lambda>\\<omega>.\n                                    return (stream_space M)\n                                     (y ## \\<omega>)))", "have [measurable]: \"S \\<in> M \\<rightarrow>\\<^sub>M prob_algebra (stream_space M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S \\<in> M \\<rightarrow>\\<^sub>M prob_algebra (stream_space M)", "unfolding S_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x.\n        if \\<forall>\\<omega>\\<in>streams (space M). T (x ## \\<omega>) = 0\n        then lim_stream x\n        else L (\\<lambda>\\<omega>. epred (T (x ## \\<omega>))) x)\n    \\<in> M \\<rightarrow>\\<^sub>M prob_algebra (stream_space M)", "by (subst measurable_If_restrict_space_iff, safe intro!: L)\n       (auto intro!: measurable_stopping_time_All_eq_0 step measurable_restrict_space1 lim_stream\n                     measurable_compose[OF _ measurable_epred] measurable_compose[OF _ T]\n                     measurable_Stream measurable_compose[OF measurable_fst]\n             simp: measurable_split_conv)"], ["proof (state)\nthis:\n  S \\<in> M \\<rightarrow>\\<^sub>M prob_algebra (stream_space M)\n\ngoal (2 subgoals):\n 1. x \\<in> space M\n 2. \\<And>xa T.\n       \\<lbrakk>xa \\<in> space M;\n        stopping_time (stream_filtration M) T\\<rbrakk>\n       \\<Longrightarrow> \\<exists>B'\\<in>M \\<rightarrow>\\<^sub>M\n   prob_algebra (stream_space M).\n                            (AE y in K\nxa. (\\<exists>x T.\n        y = x \\<and>\n        B' y =\n        lim_stream x \\<bind>\n        (\\<lambda>\\<omega>.\n            case T \\<omega> of\n            enat i \\<Rightarrow>\n              distr (lim_stream (\\<omega> !! i)) (stream_space M)\n               ((@-) (stake (Suc i) \\<omega>))\n            | \\<infinity> \\<Rightarrow>\n                return (stream_space M) \\<omega>) \\<and>\n        x \\<in> space M \\<and> stopping_time (stream_filtration M) T) \\<or>\n    lim_stream y = B' y) \\<and>\n                            lim_stream xa \\<bind>\n                            (\\<lambda>\\<omega>.\n                                case T \\<omega> of\n                                enat i \\<Rightarrow>\n                                  distr (lim_stream (\\<omega> !! i))\n                                   (stream_space M)\n                                   ((@-) (stake (Suc i) \\<omega>))\n                                | \\<infinity> \\<Rightarrow>\n                                    return (stream_space M) \\<omega>) =\n                            K xa \\<bind>\n                            (\\<lambda>y.\n                                B' y \\<bind>\n                                (\\<lambda>\\<omega>.\n                                    return (stream_space M)\n                                     (y ## \\<omega>)))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>B'\\<in>M \\<rightarrow>\\<^sub>M prob_algebra (stream_space M).\n       (AE y in K x. (\\<exists>x T.\n                         y = x \\<and>\n                         B' y =\n                         lim_stream x \\<bind>\n                         (\\<lambda>\\<omega>.\n                             case T \\<omega> of\n                             enat i \\<Rightarrow>\n                               distr (lim_stream (\\<omega> !! i))\n                                (stream_space M)\n                                ((@-) (stake (Suc i) \\<omega>))\n                             | \\<infinity> \\<Rightarrow>\n                                 return (stream_space M) \\<omega>) \\<and>\n                         x \\<in> space M \\<and>\n                         stopping_time (stream_filtration M) T) \\<or>\n                     lim_stream y = B' y) \\<and>\n       lim_stream x \\<bind>\n       (\\<lambda>\\<omega>.\n           case T \\<omega> of\n           enat i \\<Rightarrow>\n             distr (lim_stream (\\<omega> !! i)) (stream_space M)\n              ((@-) (stake (Suc i) \\<omega>))\n           | \\<infinity> \\<Rightarrow> return (stream_space M) \\<omega>) =\n       K x \\<bind>\n       (\\<lambda>y.\n           B' y \\<bind>\n           (\\<lambda>\\<omega>. return (stream_space M) (y ## \\<omega>)))", "unfolding L_def[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>B'\\<in>M \\<rightarrow>\\<^sub>M prob_algebra (stream_space M).\n       (AE y in K x. (\\<exists>x T.\n                         y = x \\<and>\n                         B' y = L T x \\<and>\n                         x \\<in> space M \\<and>\n                         stopping_time (stream_filtration M) T) \\<or>\n                     lim_stream y = B' y) \\<and>\n       L T x =\n       K x \\<bind>\n       (\\<lambda>y.\n           B' y \\<bind>\n           (\\<lambda>\\<omega>. return (stream_space M) (y ## \\<omega>)))", "proof (intro bexI[of _ S] conjI AE_I2)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>y.\n       y \\<in> space (K x) \\<Longrightarrow>\n       (\\<exists>x T.\n           y = x \\<and>\n           S y = L T x \\<and>\n           x \\<in> space M \\<and>\n           stopping_time (stream_filtration M) T) \\<or>\n       lim_stream y = S y\n 2. L T x =\n    K x \\<bind>\n    (\\<lambda>y.\n        S y \\<bind>\n        (\\<lambda>\\<omega>. return (stream_space M) (y ## \\<omega>)))\n 3. S \\<in> M \\<rightarrow>\\<^sub>M prob_algebra (stream_space M)", "fix y"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>y.\n       y \\<in> space (K x) \\<Longrightarrow>\n       (\\<exists>x T.\n           y = x \\<and>\n           S y = L T x \\<and>\n           x \\<in> space M \\<and>\n           stopping_time (stream_filtration M) T) \\<or>\n       lim_stream y = S y\n 2. L T x =\n    K x \\<bind>\n    (\\<lambda>y.\n        S y \\<bind>\n        (\\<lambda>\\<omega>. return (stream_space M) (y ## \\<omega>)))\n 3. S \\<in> M \\<rightarrow>\\<^sub>M prob_algebra (stream_space M)", "assume \"y \\<in> space (K x)\""], ["proof (state)\nthis:\n  y \\<in> space (K x)\n\ngoal (3 subgoals):\n 1. \\<And>y.\n       y \\<in> space (K x) \\<Longrightarrow>\n       (\\<exists>x T.\n           y = x \\<and>\n           S y = L T x \\<and>\n           x \\<in> space M \\<and>\n           stopping_time (stream_filtration M) T) \\<or>\n       lim_stream y = S y\n 2. L T x =\n    K x \\<bind>\n    (\\<lambda>y.\n        S y \\<bind>\n        (\\<lambda>\\<omega>. return (stream_space M) (y ## \\<omega>)))\n 3. S \\<in> M \\<rightarrow>\\<^sub>M prob_algebra (stream_space M)", "then"], ["proof (chain)\npicking this:\n  y \\<in> space (K x)", "show \"(\\<exists>x T. y = x \\<and> S y = L T x \\<and> x \\<in> space M \\<and> stopping_time (stream_filtration M) T) \\<or>\n      lim_stream y = S y\""], ["proof (prove)\nusing this:\n  y \\<in> space (K x)\n\ngoal (1 subgoal):\n 1. (\\<exists>x T.\n        y = x \\<and>\n        S y = L T x \\<and>\n        x \\<in> space M \\<and> stopping_time (stream_filtration M) T) \\<or>\n    lim_stream y = S y", "using \\<open>x\\<in>space M\\<close>"], ["proof (prove)\nusing this:\n  y \\<in> space (K x)\n  x \\<in> space M\n\ngoal (1 subgoal):\n 1. (\\<exists>x T.\n        y = x \\<and>\n        S y = L T x \\<and>\n        x \\<in> space M \\<and> stopping_time (stream_filtration M) T) \\<or>\n    lim_stream y = S y", "by (cases \"\\<forall>\\<omega>\\<in>streams (space M). T (y##\\<omega>) = 0\")\n         (auto simp add: S_eq space_K intro!: exI[of _ \"\\<lambda>\\<omega>. epred (T (y ## \\<omega>))\"] stopping_time_epred_SCons step)"], ["proof (state)\nthis:\n  (\\<exists>x T.\n      y = x \\<and>\n      S y = L T x \\<and>\n      x \\<in> space M \\<and> stopping_time (stream_filtration M) T) \\<or>\n  lim_stream y = S y\n\ngoal (2 subgoals):\n 1. L T x =\n    K x \\<bind>\n    (\\<lambda>y.\n        S y \\<bind>\n        (\\<lambda>\\<omega>. return (stream_space M) (y ## \\<omega>)))\n 2. S \\<in> M \\<rightarrow>\\<^sub>M prob_algebra (stream_space M)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. L T x =\n    K x \\<bind>\n    (\\<lambda>y.\n        S y \\<bind>\n        (\\<lambda>\\<omega>. return (stream_space M) (y ## \\<omega>)))\n 2. S \\<in> M \\<rightarrow>\\<^sub>M prob_algebra (stream_space M)", "note \\<open>x\\<in>space M\\<close>[simp]"], ["proof (state)\nthis:\n  x \\<in> space M\n\ngoal (2 subgoals):\n 1. L T x =\n    K x \\<bind>\n    (\\<lambda>y.\n        S y \\<bind>\n        (\\<lambda>\\<omega>. return (stream_space M) (y ## \\<omega>)))\n 2. S \\<in> M \\<rightarrow>\\<^sub>M prob_algebra (stream_space M)", "have \"L T x = K x \\<bind>\n      (\\<lambda>y. lim_stream y \\<bind> (\\<lambda>\\<omega>. case T (y##\\<omega>) of\n            enat i \\<Rightarrow> distr (lim_stream ((y##\\<omega>) !! i)) (stream_space M) (\\<lambda>\\<omega>'. stake (Suc i) (y##\\<omega>) @- \\<omega>')\n          | \\<infinity>     \\<Rightarrow> return (stream_space M) (y##\\<omega>)))\" (is \"_ = K x \\<bind> ?L'\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. L T x =\n    K x \\<bind>\n    (\\<lambda>y.\n        lim_stream y \\<bind>\n        (\\<lambda>\\<omega>.\n            case T (y ## \\<omega>) of\n            enat i \\<Rightarrow>\n              distr (lim_stream ((y ## \\<omega>) !! i)) (stream_space M)\n               ((@-) (stake (Suc i) (y ## \\<omega>)))\n            | \\<infinity> \\<Rightarrow>\n                return (stream_space M) (y ## \\<omega>)))", "unfolding L_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. lim_stream x \\<bind>\n    (\\<lambda>\\<omega>.\n        case T \\<omega> of\n        enat i \\<Rightarrow>\n          distr (lim_stream (\\<omega> !! i)) (stream_space M)\n           ((@-) (stake (Suc i) \\<omega>))\n        | \\<infinity> \\<Rightarrow> return (stream_space M) \\<omega>) =\n    K x \\<bind>\n    (\\<lambda>y.\n        lim_stream y \\<bind>\n        (\\<lambda>\\<omega>.\n            case T (y ## \\<omega>) of\n            enat i \\<Rightarrow>\n              distr (lim_stream ((y ## \\<omega>) !! i)) (stream_space M)\n               ((@-) (stake (Suc i) (y ## \\<omega>)))\n            | \\<infinity> \\<Rightarrow>\n                return (stream_space M) (y ## \\<omega>)))", "apply (subst lim_stream_eq[OF \\<open>x\\<in>space M\\<close>])"], ["proof (prove)\ngoal (1 subgoal):\n 1. K x \\<bind>\n    (\\<lambda>y.\n        lim_stream y \\<bind>\n        (\\<lambda>\\<omega>.\n            return (stream_space M) (y ## \\<omega>))) \\<bind>\n    (\\<lambda>\\<omega>.\n        case T \\<omega> of\n        enat i \\<Rightarrow>\n          distr (lim_stream (\\<omega> !! i)) (stream_space M)\n           ((@-) (stake (Suc i) \\<omega>))\n        | \\<infinity> \\<Rightarrow> return (stream_space M) \\<omega>) =\n    K x \\<bind>\n    (\\<lambda>y.\n        lim_stream y \\<bind>\n        (\\<lambda>\\<omega>.\n            case T (y ## \\<omega>) of\n            enat i \\<Rightarrow>\n              distr (lim_stream ((y ## \\<omega>) !! i)) (stream_space M)\n               ((@-) (stake (Suc i) (y ## \\<omega>)))\n            | \\<infinity> \\<Rightarrow>\n                return (stream_space M) (y ## \\<omega>)))", "apply (subst bind_assoc[where N=\"stream_space M\" and R=\"stream_space M\", OF measurable_prob_algebraD measurable_prob_algebraD];\n          measurable)"], ["proof (prove)\ngoal (1 subgoal):\n 1. K x \\<bind>\n    (\\<lambda>x.\n        lim_stream x \\<bind>\n        (\\<lambda>\\<omega>. return (stream_space M) (x ## \\<omega>)) \\<bind>\n        (\\<lambda>\\<omega>.\n            case T \\<omega> of\n            enat i \\<Rightarrow>\n              distr (lim_stream (\\<omega> !! i)) (stream_space M)\n               ((@-) (stake (Suc i) \\<omega>))\n            | \\<infinity> \\<Rightarrow> return (stream_space M) \\<omega>)) =\n    K x \\<bind>\n    (\\<lambda>y.\n        lim_stream y \\<bind>\n        (\\<lambda>\\<omega>.\n            case T (y ## \\<omega>) of\n            enat i \\<Rightarrow>\n              distr (lim_stream ((y ## \\<omega>) !! i)) (stream_space M)\n               ((@-) (stake (Suc i) (y ## \\<omega>)))\n            | \\<infinity> \\<Rightarrow>\n                return (stream_space M) (y ## \\<omega>)))", "apply (rule bind_cong[OF refl])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> space (K x) \\<Longrightarrow>\n       lim_stream x \\<bind>\n       (\\<lambda>\\<omega>. return (stream_space M) (x ## \\<omega>)) \\<bind>\n       (\\<lambda>\\<omega>.\n           case T \\<omega> of\n           enat i \\<Rightarrow>\n             distr (lim_stream (\\<omega> !! i)) (stream_space M)\n              ((@-) (stake (Suc i) \\<omega>))\n           | \\<infinity> \\<Rightarrow> return (stream_space M) \\<omega>) =\n       lim_stream x \\<bind>\n       (\\<lambda>\\<omega>.\n           case T (x ## \\<omega>) of\n           enat i \\<Rightarrow>\n             distr (lim_stream ((x ## \\<omega>) !! i)) (stream_space M)\n              ((@-) (stake (Suc i) (x ## \\<omega>)))\n           | \\<infinity> \\<Rightarrow>\n               return (stream_space M) (x ## \\<omega>))", "apply (simp add: space_K)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> space M \\<Longrightarrow>\n       lim_stream x \\<bind>\n       (\\<lambda>\\<omega>. return (stream_space M) (x ## \\<omega>)) \\<bind>\n       (\\<lambda>\\<omega>.\n           case T \\<omega> of\n           enat i \\<Rightarrow>\n             distr (lim_stream (\\<omega> !! i)) (stream_space M)\n              ((@-) (stake (Suc i) \\<omega>))\n           | \\<infinity> \\<Rightarrow> return (stream_space M) \\<omega>) =\n       lim_stream x \\<bind>\n       (\\<lambda>\\<omega>.\n           case T (x ## \\<omega>) of\n           enat i \\<Rightarrow>\n             distr (lim_stream ((x ## \\<omega>) !! i)) (stream_space M)\n              ((@-) (stake (Suc i) (x ## \\<omega>)))\n           | \\<infinity> \\<Rightarrow>\n               return (stream_space M) (x ## \\<omega>))", "apply (subst bind_assoc[where N=\"stream_space M\" and R=\"stream_space M\", OF measurable_prob_algebraD measurable_prob_algebraD];\n          measurable)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> space M \\<Longrightarrow>\n       lim_stream x \\<bind>\n       (\\<lambda>xa.\n           return (stream_space M) (x ## xa) \\<bind>\n           (\\<lambda>\\<omega>.\n               case T \\<omega> of\n               enat i \\<Rightarrow>\n                 distr (lim_stream (\\<omega> !! i)) (stream_space M)\n                  ((@-) (stake (Suc i) \\<omega>))\n               | \\<infinity> \\<Rightarrow>\n                   return (stream_space M) \\<omega>)) =\n       lim_stream x \\<bind>\n       (\\<lambda>\\<omega>.\n           case T (x ## \\<omega>) of\n           enat i \\<Rightarrow>\n             distr (lim_stream ((x ## \\<omega>) !! i)) (stream_space M)\n              ((@-) (stake (Suc i) (x ## \\<omega>)))\n           | \\<infinity> \\<Rightarrow>\n               return (stream_space M) (x ## \\<omega>))", "apply (rule bind_cong[OF refl])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>x \\<in> space M; xa \\<in> space (lim_stream x)\\<rbrakk>\n       \\<Longrightarrow> return (stream_space M) (x ## xa) \\<bind>\n                         (\\<lambda>\\<omega>.\n                             case T \\<omega> of\n                             enat i \\<Rightarrow>\n                               distr (lim_stream (\\<omega> !! i))\n                                (stream_space M)\n                                ((@-) (stake (Suc i) \\<omega>))\n                             | \\<infinity> \\<Rightarrow>\n                                 return (stream_space M) \\<omega>) =\n                         (case T (x ## xa) of\n                          enat i \\<Rightarrow>\n                            distr (lim_stream ((x ## xa) !! i))\n                             (stream_space M)\n                             ((@-) (stake (Suc i) (x ## xa)))\n                          | \\<infinity> \\<Rightarrow>\n                              return (stream_space M) (x ## xa))", "apply (simp add: space_lim_stream)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>x \\<in> space M; xa \\<in> streams (space M)\\<rbrakk>\n       \\<Longrightarrow> return (stream_space M) (x ## xa) \\<bind>\n                         (\\<lambda>\\<omega>.\n                             case T \\<omega> of\n                             enat i \\<Rightarrow>\n                               distr (lim_stream (\\<omega> !! i))\n                                (stream_space M)\n                                ((@-) (stake (Suc i) \\<omega>))\n                             | \\<infinity> \\<Rightarrow>\n                                 return (stream_space M) \\<omega>) =\n                         (case T (x ## xa) of\n                          enat i \\<Rightarrow>\n                            distr (lim_stream ((x ## xa) !! i))\n                             (stream_space M)\n                             ((@-) (stake (Suc i) (x ## xa)))\n                          | \\<infinity> \\<Rightarrow>\n                              return (stream_space M) (x ## xa))", "apply (subst bind_return[where N=\"stream_space M\", OF measurable_prob_algebraD])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x xa.\n       \\<lbrakk>x \\<in> space M; xa \\<in> streams (space M)\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>\\<omega>.\n                             case T \\<omega> of\n                             enat i \\<Rightarrow>\n                               distr (lim_stream (\\<omega> !! i))\n                                (stream_space M)\n                                ((@-) (stake (Suc i) \\<omega>))\n                             | \\<infinity> \\<Rightarrow>\n                                 return (stream_space M) \\<omega>)\n                         \\<in> stream_space M \\<rightarrow>\\<^sub>M\n                               prob_algebra (stream_space M)\n 2. \\<And>x xa.\n       \\<lbrakk>x \\<in> space M; xa \\<in> streams (space M)\\<rbrakk>\n       \\<Longrightarrow> x ## xa \\<in> space (stream_space M)\n 3. \\<And>x xa.\n       \\<lbrakk>x \\<in> space M; xa \\<in> streams (space M)\\<rbrakk>\n       \\<Longrightarrow> (case T (x ## xa) of\n                          enat i \\<Rightarrow>\n                            distr (lim_stream ((x ## xa) !! i))\n                             (stream_space M)\n                             ((@-) (stake (Suc i) (x ## xa)))\n                          | \\<infinity> \\<Rightarrow>\n                              return (stream_space M) (x ## xa)) =\n                         (case T (x ## xa) of\n                          enat i \\<Rightarrow>\n                            distr (lim_stream ((x ## xa) !! i))\n                             (stream_space M)\n                             ((@-) (stake (Suc i) (x ## xa)))\n                          | \\<infinity> \\<Rightarrow>\n                              return (stream_space M) (x ## xa))", "apply (measurable; fail) []"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       \\<lbrakk>x \\<in> space M; xa \\<in> streams (space M)\\<rbrakk>\n       \\<Longrightarrow> x ## xa \\<in> space (stream_space M)\n 2. \\<And>x xa.\n       \\<lbrakk>x \\<in> space M; xa \\<in> streams (space M)\\<rbrakk>\n       \\<Longrightarrow> (case T (x ## xa) of\n                          enat i \\<Rightarrow>\n                            distr (lim_stream ((x ## xa) !! i))\n                             (stream_space M)\n                             ((@-) (stake (Suc i) (x ## xa)))\n                          | \\<infinity> \\<Rightarrow>\n                              return (stream_space M) (x ## xa)) =\n                         (case T (x ## xa) of\n                          enat i \\<Rightarrow>\n                            distr (lim_stream ((x ## xa) !! i))\n                             (stream_space M)\n                             ((@-) (stake (Suc i) (x ## xa)))\n                          | \\<infinity> \\<Rightarrow>\n                              return (stream_space M) (x ## xa))", "apply (simp add: space_stream_space)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>x \\<in> space M; xa \\<in> streams (space M)\\<rbrakk>\n       \\<Longrightarrow> (case T (x ## xa) of\n                          enat i \\<Rightarrow>\n                            distr (lim_stream ((x ## xa) !! i))\n                             (stream_space M)\n                             ((@-) (stake (Suc i) (x ## xa)))\n                          | \\<infinity> \\<Rightarrow>\n                              return (stream_space M) (x ## xa)) =\n                         (case T (x ## xa) of\n                          enat i \\<Rightarrow>\n                            distr (lim_stream ((x ## xa) !! i))\n                             (stream_space M)\n                             ((@-) (stake (Suc i) (x ## xa)))\n                          | \\<infinity> \\<Rightarrow>\n                              return (stream_space M) (x ## xa))", "apply rule"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  L T x =\n  K x \\<bind>\n  (\\<lambda>y.\n      lim_stream y \\<bind>\n      (\\<lambda>\\<omega>.\n          case T (y ## \\<omega>) of\n          enat i \\<Rightarrow>\n            distr (lim_stream ((y ## \\<omega>) !! i)) (stream_space M)\n             ((@-) (stake (Suc i) (y ## \\<omega>)))\n          | \\<infinity> \\<Rightarrow>\n              return (stream_space M) (y ## \\<omega>)))\n\ngoal (2 subgoals):\n 1. L T x =\n    K x \\<bind>\n    (\\<lambda>y.\n        S y \\<bind>\n        (\\<lambda>\\<omega>. return (stream_space M) (y ## \\<omega>)))\n 2. S \\<in> M \\<rightarrow>\\<^sub>M prob_algebra (stream_space M)", "also"], ["proof (state)\nthis:\n  L T x =\n  K x \\<bind>\n  (\\<lambda>y.\n      lim_stream y \\<bind>\n      (\\<lambda>\\<omega>.\n          case T (y ## \\<omega>) of\n          enat i \\<Rightarrow>\n            distr (lim_stream ((y ## \\<omega>) !! i)) (stream_space M)\n             ((@-) (stake (Suc i) (y ## \\<omega>)))\n          | \\<infinity> \\<Rightarrow>\n              return (stream_space M) (y ## \\<omega>)))\n\ngoal (2 subgoals):\n 1. L T x =\n    K x \\<bind>\n    (\\<lambda>y.\n        S y \\<bind>\n        (\\<lambda>\\<omega>. return (stream_space M) (y ## \\<omega>)))\n 2. S \\<in> M \\<rightarrow>\\<^sub>M prob_algebra (stream_space M)", "have \"\\<dots> = K x \\<bind> (\\<lambda>y. S y \\<bind> (\\<lambda>\\<omega>. return (stream_space M) (y ## \\<omega>)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. K x \\<bind>\n    (\\<lambda>y.\n        lim_stream y \\<bind>\n        (\\<lambda>\\<omega>.\n            case T (y ## \\<omega>) of\n            enat i \\<Rightarrow>\n              distr (lim_stream ((y ## \\<omega>) !! i)) (stream_space M)\n               ((@-) (stake (Suc i) (y ## \\<omega>)))\n            | \\<infinity> \\<Rightarrow>\n                return (stream_space M) (y ## \\<omega>))) =\n    K x \\<bind>\n    (\\<lambda>y.\n        S y \\<bind>\n        (\\<lambda>\\<omega>. return (stream_space M) (y ## \\<omega>)))", "proof (intro bind_cong[of \"K x\"] refl)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> space (K x) \\<Longrightarrow>\n       lim_stream x \\<bind>\n       (\\<lambda>\\<omega>.\n           case T (x ## \\<omega>) of\n           enat i \\<Rightarrow>\n             distr (lim_stream ((x ## \\<omega>) !! i)) (stream_space M)\n              ((@-) (stake (Suc i) (x ## \\<omega>)))\n           | \\<infinity> \\<Rightarrow>\n               return (stream_space M) (x ## \\<omega>)) =\n       S x \\<bind>\n       (\\<lambda>\\<omega>. return (stream_space M) (x ## \\<omega>))", "fix y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> space (K x) \\<Longrightarrow>\n       lim_stream x \\<bind>\n       (\\<lambda>\\<omega>.\n           case T (x ## \\<omega>) of\n           enat i \\<Rightarrow>\n             distr (lim_stream ((x ## \\<omega>) !! i)) (stream_space M)\n              ((@-) (stake (Suc i) (x ## \\<omega>)))\n           | \\<infinity> \\<Rightarrow>\n               return (stream_space M) (x ## \\<omega>)) =\n       S x \\<bind>\n       (\\<lambda>\\<omega>. return (stream_space M) (x ## \\<omega>))", "assume \"y \\<in> space (K x)\""], ["proof (state)\nthis:\n  y \\<in> space (K x)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> space (K x) \\<Longrightarrow>\n       lim_stream x \\<bind>\n       (\\<lambda>\\<omega>.\n           case T (x ## \\<omega>) of\n           enat i \\<Rightarrow>\n             distr (lim_stream ((x ## \\<omega>) !! i)) (stream_space M)\n              ((@-) (stake (Suc i) (x ## \\<omega>)))\n           | \\<infinity> \\<Rightarrow>\n               return (stream_space M) (x ## \\<omega>)) =\n       S x \\<bind>\n       (\\<lambda>\\<omega>. return (stream_space M) (x ## \\<omega>))", "then"], ["proof (chain)\npicking this:\n  y \\<in> space (K x)", "have [simp]: \"y \\<in> space M\""], ["proof (prove)\nusing this:\n  y \\<in> space (K x)\n\ngoal (1 subgoal):\n 1. y \\<in> space M", "by (simp add: space_K)"], ["proof (state)\nthis:\n  y \\<in> space M\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> space (K x) \\<Longrightarrow>\n       lim_stream x \\<bind>\n       (\\<lambda>\\<omega>.\n           case T (x ## \\<omega>) of\n           enat i \\<Rightarrow>\n             distr (lim_stream ((x ## \\<omega>) !! i)) (stream_space M)\n              ((@-) (stake (Suc i) (x ## \\<omega>)))\n           | \\<infinity> \\<Rightarrow>\n               return (stream_space M) (x ## \\<omega>)) =\n       S x \\<bind>\n       (\\<lambda>\\<omega>. return (stream_space M) (x ## \\<omega>))", "show \"?L' y = S y \\<bind> (\\<lambda>\\<omega>. return (stream_space M) (y ## \\<omega>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lim_stream y \\<bind>\n    (\\<lambda>\\<omega>.\n        case T (y ## \\<omega>) of\n        enat i \\<Rightarrow>\n          distr (lim_stream ((y ## \\<omega>) !! i)) (stream_space M)\n           ((@-) (stake (Suc i) (y ## \\<omega>)))\n        | \\<infinity> \\<Rightarrow>\n            return (stream_space M) (y ## \\<omega>)) =\n    S y \\<bind> (\\<lambda>\\<omega>. return (stream_space M) (y ## \\<omega>))", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    lim_stream y \\<bind>\n    (\\<lambda>\\<omega>.\n        case T (y ## \\<omega>) of\n        enat i \\<Rightarrow>\n          distr (lim_stream ((y ## \\<omega>) !! i)) (stream_space M)\n           ((@-) (stake (Suc i) (y ## \\<omega>)))\n        | \\<infinity> \\<Rightarrow>\n            return (stream_space M) (y ## \\<omega>)) =\n    S y \\<bind> (\\<lambda>\\<omega>. return (stream_space M) (y ## \\<omega>))\n 2. \\<not> ?P \\<Longrightarrow>\n    lim_stream y \\<bind>\n    (\\<lambda>\\<omega>.\n        case T (y ## \\<omega>) of\n        enat i \\<Rightarrow>\n          distr (lim_stream ((y ## \\<omega>) !! i)) (stream_space M)\n           ((@-) (stake (Suc i) (y ## \\<omega>)))\n        | \\<infinity> \\<Rightarrow>\n            return (stream_space M) (y ## \\<omega>)) =\n    S y \\<bind> (\\<lambda>\\<omega>. return (stream_space M) (y ## \\<omega>))", "assume \"\\<forall>\\<omega>\\<in>streams (space M). T (y##\\<omega>) = 0\""], ["proof (state)\nthis:\n  \\<forall>\\<omega>\\<in>streams (space M). T (y ## \\<omega>) = 0\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    lim_stream y \\<bind>\n    (\\<lambda>\\<omega>.\n        case T (y ## \\<omega>) of\n        enat i \\<Rightarrow>\n          distr (lim_stream ((y ## \\<omega>) !! i)) (stream_space M)\n           ((@-) (stake (Suc i) (y ## \\<omega>)))\n        | \\<infinity> \\<Rightarrow>\n            return (stream_space M) (y ## \\<omega>)) =\n    S y \\<bind> (\\<lambda>\\<omega>. return (stream_space M) (y ## \\<omega>))\n 2. \\<not> ?P \\<Longrightarrow>\n    lim_stream y \\<bind>\n    (\\<lambda>\\<omega>.\n        case T (y ## \\<omega>) of\n        enat i \\<Rightarrow>\n          distr (lim_stream ((y ## \\<omega>) !! i)) (stream_space M)\n           ((@-) (stake (Suc i) (y ## \\<omega>)))\n        | \\<infinity> \\<Rightarrow>\n            return (stream_space M) (y ## \\<omega>)) =\n    S y \\<bind> (\\<lambda>\\<omega>. return (stream_space M) (y ## \\<omega>))", "with x"], ["proof (chain)\npicking this:\n  x \\<in> space M\n  \\<forall>\\<omega>\\<in>streams (space M). T (y ## \\<omega>) = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  x \\<in> space M\n  \\<forall>\\<omega>\\<in>streams (space M). T (y ## \\<omega>) = 0\n\ngoal (1 subgoal):\n 1. lim_stream y \\<bind>\n    (\\<lambda>\\<omega>.\n        case T (y ## \\<omega>) of\n        enat i \\<Rightarrow>\n          distr (lim_stream ((y ## \\<omega>) !! i)) (stream_space M)\n           ((@-) (stake (Suc i) (y ## \\<omega>)))\n        | \\<infinity> \\<Rightarrow>\n            return (stream_space M) (y ## \\<omega>)) =\n    S y \\<bind> (\\<lambda>\\<omega>. return (stream_space M) (y ## \\<omega>))", "by (auto simp: S_eq space_lim_stream shift.simps[abs_def] streams_empty_iff\n                bind_const'[OF _ prob_space_imp_subprob_space] prob_space_lim_stream prob_space.prob_space_distr\n              intro!: bind_return_distr'[symmetric]\n              cong: bind_cong_simp)"], ["proof (state)\nthis:\n  lim_stream y \\<bind>\n  (\\<lambda>\\<omega>.\n      case T (y ## \\<omega>) of\n      enat i \\<Rightarrow>\n        distr (lim_stream ((y ## \\<omega>) !! i)) (stream_space M)\n         ((@-) (stake (Suc i) (y ## \\<omega>)))\n      | \\<infinity> \\<Rightarrow> return (stream_space M) (y ## \\<omega>)) =\n  S y \\<bind> (\\<lambda>\\<omega>. return (stream_space M) (y ## \\<omega>))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>\\<omega>\\<in>streams (space M).\n               T (y ## \\<omega>) = 0) \\<Longrightarrow>\n    lim_stream y \\<bind>\n    (\\<lambda>\\<omega>.\n        case T (y ## \\<omega>) of\n        enat i \\<Rightarrow>\n          distr (lim_stream ((y ## \\<omega>) !! i)) (stream_space M)\n           ((@-) (stake (Suc i) (y ## \\<omega>)))\n        | \\<infinity> \\<Rightarrow>\n            return (stream_space M) (y ## \\<omega>)) =\n    S y \\<bind> (\\<lambda>\\<omega>. return (stream_space M) (y ## \\<omega>))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>\\<omega>\\<in>streams (space M).\n               T (y ## \\<omega>) = 0) \\<Longrightarrow>\n    lim_stream y \\<bind>\n    (\\<lambda>\\<omega>.\n        case T (y ## \\<omega>) of\n        enat i \\<Rightarrow>\n          distr (lim_stream ((y ## \\<omega>) !! i)) (stream_space M)\n           ((@-) (stake (Suc i) (y ## \\<omega>)))\n        | \\<infinity> \\<Rightarrow>\n            return (stream_space M) (y ## \\<omega>)) =\n    S y \\<bind> (\\<lambda>\\<omega>. return (stream_space M) (y ## \\<omega>))", "assume *: \"\\<not> (\\<forall>\\<omega>\\<in>streams (space M). T (y##\\<omega>) = 0)\""], ["proof (state)\nthis:\n  \\<not> (\\<forall>\\<omega>\\<in>streams (space M). T (y ## \\<omega>) = 0)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>\\<omega>\\<in>streams (space M).\n               T (y ## \\<omega>) = 0) \\<Longrightarrow>\n    lim_stream y \\<bind>\n    (\\<lambda>\\<omega>.\n        case T (y ## \\<omega>) of\n        enat i \\<Rightarrow>\n          distr (lim_stream ((y ## \\<omega>) !! i)) (stream_space M)\n           ((@-) (stake (Suc i) (y ## \\<omega>)))\n        | \\<infinity> \\<Rightarrow>\n            return (stream_space M) (y ## \\<omega>)) =\n    S y \\<bind> (\\<lambda>\\<omega>. return (stream_space M) (y ## \\<omega>))", "then"], ["proof (chain)\npicking this:\n  \\<not> (\\<forall>\\<omega>\\<in>streams (space M). T (y ## \\<omega>) = 0)", "have T_pos: \"\\<omega> \\<in> streams (space M) \\<Longrightarrow> T (y ## \\<omega>) \\<noteq> 0\" for \\<omega>"], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>\\<omega>\\<in>streams (space M). T (y ## \\<omega>) = 0)\n\ngoal (1 subgoal):\n 1. \\<omega> \\<in> streams (space M) \\<Longrightarrow>\n    T (y ## \\<omega>) \\<noteq> 0", "using stopping_time_0[OF \\<open>stopping_time (stream_filtration M) T\\<close>, of y _ \\<omega>]"], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>\\<omega>\\<in>streams (space M). T (y ## \\<omega>) = 0)\n  \\<lbrakk>y \\<in> space M; ?\\<omega> \\<in> streams (space M);\n   0 < T (y ## ?\\<omega>); \\<omega> \\<in> streams (space M)\\<rbrakk>\n  \\<Longrightarrow> 0 < T (y ## \\<omega>)\n\ngoal (1 subgoal):\n 1. \\<omega> \\<in> streams (space M) \\<Longrightarrow>\n    T (y ## \\<omega>) \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  ?\\<omega> \\<in> streams (space M) \\<Longrightarrow>\n  T (y ## ?\\<omega>) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>\\<omega>\\<in>streams (space M).\n               T (y ## \\<omega>) = 0) \\<Longrightarrow>\n    lim_stream y \\<bind>\n    (\\<lambda>\\<omega>.\n        case T (y ## \\<omega>) of\n        enat i \\<Rightarrow>\n          distr (lim_stream ((y ## \\<omega>) !! i)) (stream_space M)\n           ((@-) (stake (Suc i) (y ## \\<omega>)))\n        | \\<infinity> \\<Rightarrow>\n            return (stream_space M) (y ## \\<omega>)) =\n    S y \\<bind> (\\<lambda>\\<omega>. return (stream_space M) (y ## \\<omega>))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. lim_stream y \\<bind>\n    (\\<lambda>\\<omega>.\n        case T (y ## \\<omega>) of\n        enat i \\<Rightarrow>\n          distr (lim_stream ((y ## \\<omega>) !! i)) (stream_space M)\n           ((@-) (stake (Suc i) (y ## \\<omega>)))\n        | \\<infinity> \\<Rightarrow>\n            return (stream_space M) (y ## \\<omega>)) =\n    S y \\<bind> (\\<lambda>\\<omega>. return (stream_space M) (y ## \\<omega>))", "apply (simp add: S_eq(2)[OF *] L_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. lim_stream y \\<bind>\n    (\\<lambda>\\<omega>.\n        case T (y ## \\<omega>) of\n        enat i \\<Rightarrow>\n          distr (lim_stream ((y ## \\<omega>) !! i)) (stream_space M)\n           ((@-) (stake (Suc i) (y ## \\<omega>)))\n        | \\<infinity> \\<Rightarrow>\n            return (stream_space M) (y ## \\<omega>)) =\n    lim_stream y \\<bind>\n    (\\<lambda>\\<omega>.\n        case epred (T (y ## \\<omega>)) of\n        enat i \\<Rightarrow>\n          distr (lim_stream (\\<omega> !! i)) (stream_space M)\n           ((@-) (stake (Suc i) \\<omega>))\n        | \\<infinity> \\<Rightarrow>\n            return (stream_space M) \\<omega>) \\<bind>\n    (\\<lambda>\\<omega>. return (stream_space M) (y ## \\<omega>))", "apply (subst bind_assoc[where N=\"stream_space M\" and R=\"stream_space M\", OF measurable_prob_algebraD measurable_prob_algebraD];\n            measurable)"], ["proof (prove)\ngoal (1 subgoal):\n 1. lim_stream y \\<bind>\n    (\\<lambda>\\<omega>.\n        case T (y ## \\<omega>) of\n        enat i \\<Rightarrow>\n          distr (lim_stream ((y ## \\<omega>) !! i)) (stream_space M)\n           ((@-) (stake (Suc i) (y ## \\<omega>)))\n        | \\<infinity> \\<Rightarrow>\n            return (stream_space M) (y ## \\<omega>)) =\n    lim_stream y \\<bind>\n    (\\<lambda>x.\n        (case epred (T (y ## x)) of\n         enat i \\<Rightarrow>\n           distr (lim_stream (x !! i)) (stream_space M)\n            ((@-) (stake (Suc i) x))\n         | \\<infinity> \\<Rightarrow> return (stream_space M) x) \\<bind>\n        (\\<lambda>\\<omega>. return (stream_space M) (y ## \\<omega>)))", "apply (intro bind_cong refl)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> space (lim_stream y) \\<Longrightarrow>\n       (case T (y ## x) of\n        enat i \\<Rightarrow>\n          distr (lim_stream ((y ## x) !! i)) (stream_space M)\n           ((@-) (stake (Suc i) (y ## x)))\n        | \\<infinity> \\<Rightarrow> return (stream_space M) (y ## x)) =\n       (case epred (T (y ## x)) of\n        enat i \\<Rightarrow>\n          distr (lim_stream (x !! i)) (stream_space M)\n           ((@-) (stake (Suc i) x))\n        | \\<infinity> \\<Rightarrow> return (stream_space M) x) \\<bind>\n       (\\<lambda>\\<omega>. return (stream_space M) (y ## \\<omega>))", "apply (auto simp: T_pos enat_0 space_lim_stream shift.simps[abs_def] diff_Suc space_stream_space\n                      intro!: bind_return[where N=\"stream_space M\", OF measurable_prob_algebraD, symmetric]\n                        bind_distr_return[symmetric]\n                      split: nat.split enat.split)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  lim_stream y \\<bind>\n  (\\<lambda>\\<omega>.\n      case T (y ## \\<omega>) of\n      enat i \\<Rightarrow>\n        distr (lim_stream ((y ## \\<omega>) !! i)) (stream_space M)\n         ((@-) (stake (Suc i) (y ## \\<omega>)))\n      | \\<infinity> \\<Rightarrow> return (stream_space M) (y ## \\<omega>)) =\n  S y \\<bind> (\\<lambda>\\<omega>. return (stream_space M) (y ## \\<omega>))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lim_stream y \\<bind>\n  (\\<lambda>\\<omega>.\n      case T (y ## \\<omega>) of\n      enat i \\<Rightarrow>\n        distr (lim_stream ((y ## \\<omega>) !! i)) (stream_space M)\n         ((@-) (stake (Suc i) (y ## \\<omega>)))\n      | \\<infinity> \\<Rightarrow> return (stream_space M) (y ## \\<omega>)) =\n  S y \\<bind> (\\<lambda>\\<omega>. return (stream_space M) (y ## \\<omega>))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  K x \\<bind>\n  (\\<lambda>y.\n      lim_stream y \\<bind>\n      (\\<lambda>\\<omega>.\n          case T (y ## \\<omega>) of\n          enat i \\<Rightarrow>\n            distr (lim_stream ((y ## \\<omega>) !! i)) (stream_space M)\n             ((@-) (stake (Suc i) (y ## \\<omega>)))\n          | \\<infinity> \\<Rightarrow>\n              return (stream_space M) (y ## \\<omega>))) =\n  K x \\<bind>\n  (\\<lambda>y.\n      S y \\<bind>\n      (\\<lambda>\\<omega>. return (stream_space M) (y ## \\<omega>)))\n\ngoal (2 subgoals):\n 1. L T x =\n    K x \\<bind>\n    (\\<lambda>y.\n        S y \\<bind>\n        (\\<lambda>\\<omega>. return (stream_space M) (y ## \\<omega>)))\n 2. S \\<in> M \\<rightarrow>\\<^sub>M prob_algebra (stream_space M)", "finally"], ["proof (chain)\npicking this:\n  L T x =\n  K x \\<bind>\n  (\\<lambda>y.\n      S y \\<bind>\n      (\\<lambda>\\<omega>. return (stream_space M) (y ## \\<omega>)))", "show \"L T x = K x \\<bind> (\\<lambda>y. S y \\<bind> (\\<lambda>\\<omega>. return (stream_space M) (y ## \\<omega>)))\""], ["proof (prove)\nusing this:\n  L T x =\n  K x \\<bind>\n  (\\<lambda>y.\n      S y \\<bind>\n      (\\<lambda>\\<omega>. return (stream_space M) (y ## \\<omega>)))\n\ngoal (1 subgoal):\n 1. L T x =\n    K x \\<bind>\n    (\\<lambda>y.\n        S y \\<bind>\n        (\\<lambda>\\<omega>. return (stream_space M) (y ## \\<omega>)))", "."], ["proof (state)\nthis:\n  L T x =\n  K x \\<bind>\n  (\\<lambda>y.\n      S y \\<bind>\n      (\\<lambda>\\<omega>. return (stream_space M) (y ## \\<omega>)))\n\ngoal (1 subgoal):\n 1. S \\<in> M \\<rightarrow>\\<^sub>M prob_algebra (stream_space M)", "qed fact"], ["proof (state)\nthis:\n  \\<exists>B'\\<in>M \\<rightarrow>\\<^sub>M prob_algebra (stream_space M).\n     (AE y in K x. (\\<exists>x T.\n                       y = x \\<and>\n                       B' y =\n                       lim_stream x \\<bind>\n                       (\\<lambda>\\<omega>.\n                           case T \\<omega> of\n                           enat i \\<Rightarrow>\n                             distr (lim_stream (\\<omega> !! i))\n                              (stream_space M)\n                              ((@-) (stake (Suc i) \\<omega>))\n                           | \\<infinity> \\<Rightarrow>\n                               return (stream_space M) \\<omega>) \\<and>\n                       x \\<in> space M \\<and>\n                       stopping_time (stream_filtration M) T) \\<or>\n                   lim_stream y = B' y) \\<and>\n     lim_stream x \\<bind>\n     (\\<lambda>\\<omega>.\n         case T \\<omega> of\n         enat i \\<Rightarrow>\n           distr (lim_stream (\\<omega> !! i)) (stream_space M)\n            ((@-) (stake (Suc i) \\<omega>))\n         | \\<infinity> \\<Rightarrow> return (stream_space M) \\<omega>) =\n     K x \\<bind>\n     (\\<lambda>y.\n         B' y \\<bind>\n         (\\<lambda>\\<omega>. return (stream_space M) (y ## \\<omega>)))\n\ngoal (1 subgoal):\n 1. x \\<in> space M", "qed fact"], ["", "end"], ["", "end"]]}