{"file_name": "/home/qj213/afp-2021-10-22/thys/Markov_Models/Markov_Models_Auxiliary.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Markov_Models", "problem_names": ["lemma lfp_upperbound: \"(\\<And>y. x \\<le> f y) \\<Longrightarrow> x \\<le> lfp f\"", "lemma lfp_arg: \"(\\<lambda>t. lfp (F t)) = lfp (\\<lambda>x t. F t (x t))\"", "lemma lfp_pair: \"lfp (\\<lambda>f (a, b). F (\\<lambda>a b. f (a, b)) a b) (a, b) = lfp F a b\"", "lemma all_Suc_split: \"(\\<forall>i. P i) \\<longleftrightarrow> (P 0 \\<and> (\\<forall>i. P (Suc i)))\"", "lemma withI[case_names default exists]:\n  \"((\\<And>x. \\<not> P x) \\<Longrightarrow> Q d) \\<Longrightarrow> (\\<And>x. P x \\<Longrightarrow> Q (f x)) \\<Longrightarrow> Q (with P f d)\"", "lemma maximalI: \"x \\<in> S \\<Longrightarrow> (\\<And>y. y \\<in> S \\<Longrightarrow> f y \\<le> f x) \\<Longrightarrow> x \\<in> maximal f S\"", "lemma maximalI_trans: \"x \\<in> maximal f S \\<Longrightarrow> f x \\<le> f y \\<Longrightarrow> y \\<in> S \\<Longrightarrow> y \\<in> maximal f S\"", "lemma maximalD1: \"x \\<in> maximal f S \\<Longrightarrow> x \\<in> S\"", "lemma maximalD2: \"x \\<in> maximal f S \\<Longrightarrow> y \\<in> S \\<Longrightarrow> f y \\<le> f x\"", "lemma maximal_inject: \"x \\<in> maximal f S \\<Longrightarrow> y \\<in> maximal f S \\<Longrightarrow> f x = f y\"", "lemma maximal_empty[simp]: \"maximal f {} = {}\"", "lemma maximal_singleton[simp]: \"maximal f {x} = {x}\"", "lemma maximal_in_S: \"maximal f S \\<subseteq> S\"", "lemma maximal_ne:\n  assumes \"finite S\" \"S \\<noteq> {}\"\n  shows \"maximal f S \\<noteq> {}\"", "lemma mono_les:\n  fixes s S N and l1 l2 :: \"'a \\<Rightarrow> real\" and K :: \"'a \\<Rightarrow> 'a pmf\"\n  defines \"\\<Delta> x \\<equiv> l2 x - l1 x\"\n  assumes s: \"s \\<in> S\" and S: \"(\\<Union>s\\<in>S. set_pmf (K s)) \\<subseteq> S \\<union> N\"\n  assumes int_l1[simp]: \"\\<And>s. s \\<in> S \\<Longrightarrow> integrable (K s) l1\"\n  assumes int_l2[simp]: \"\\<And>s. s \\<in> S \\<Longrightarrow> integrable (K s) l2\"\n  assumes to_N: \"\\<And>s. s \\<in> S \\<Longrightarrow> \\<exists>t\\<in>N. (s, t) \\<in> (SIGMA s:UNIV. K s)\\<^sup>*\"\n  assumes l1: \"\\<And>s. s \\<in> S \\<Longrightarrow> (\\<integral>t. l1 t \\<partial>K s) + c s \\<le> l1 s\"\n  assumes l2: \"\\<And>s. s \\<in> S \\<Longrightarrow> l2 s \\<le> (\\<integral>t. l2 t \\<partial>K s) + c s\"\n  assumes eq: \"\\<And>s. s \\<in> N \\<Longrightarrow> l2 s \\<le> l1 s\"\n  assumes finitary: \"finite (\\<Delta> ` (S\\<union>N))\"\n  shows \"l2 s \\<le> l1 s\"", "lemma unique_les:\n  fixes s S N and l1 l2 :: \"'a \\<Rightarrow> real\" and K :: \"'a \\<Rightarrow> 'a pmf\"\n  defines \"\\<Delta> x \\<equiv> l2 x - l1 x\"\n  assumes s: \"s \\<in> S\" and S: \"(\\<Union>s\\<in>S. set_pmf (K s)) \\<subseteq> S \\<union> N\"\n  assumes \"\\<And>s. s \\<in> S \\<Longrightarrow> integrable (K s) l1\"\n  assumes \"\\<And>s. s \\<in> S \\<Longrightarrow> integrable (K s) l2\"\n  assumes \"\\<And>s. s \\<in> S \\<Longrightarrow> \\<exists>t\\<in>N. (s, t) \\<in> (SIGMA s:UNIV. K s)\\<^sup>*\"\n  assumes \"\\<And>s. s \\<in> S \\<Longrightarrow> l1 s = (\\<integral>t. l1 t \\<partial>K s) + c s\"\n  assumes \"\\<And>s. s \\<in> S \\<Longrightarrow> l2 s = (\\<integral>t. l2 t \\<partial>K s) + c s\"\n  assumes \"\\<And>s. s \\<in> N \\<Longrightarrow> l2 s = l1 s\"\n  assumes 1: \"finite (\\<Delta> ` (S\\<union>N))\"\n  shows \"l2 s = l1 s\"", "lemma inf_continuous_suntil_disj[order_continuous_intros]:\n  assumes Q: \"inf_continuous Q\"\n  assumes disj: \"\\<And>x \\<omega>. \\<not> (P \\<omega> \\<and> Q x \\<omega>)\"\n  shows \"inf_continuous (\\<lambda>x. P suntil Q x)\"", "lemma inf_continuous_nxt[order_continuous_intros]: \"inf_continuous P \\<Longrightarrow> inf_continuous (\\<lambda>x. nxt (P x) \\<omega>)\"", "lemma sup_continuous_nxt[order_continuous_intros]: \"sup_continuous P \\<Longrightarrow> sup_continuous (\\<lambda>x. nxt (P x) \\<omega>)\"", "lemma mcont_ennreal_of_enat: \"mcont Sup (\\<le>) Sup (\\<le>) ennreal_of_enat\"", "lemma mcont2mcont_ennreal_of_enat[cont_intro]:\n  \"mcont lub ord Sup (\\<le>) f \\<Longrightarrow> mcont lub ord Sup (\\<le>) (\\<lambda>x. ennreal_of_enat (f x))\"", "lemma scount_eq_emeasure: \"scount P \\<omega> = emeasure (count_space UNIV) {i. P (sdrop i \\<omega>)}\"", "lemma measurable_scount[measurable]:\n  assumes [measurable]: \"Measurable.pred (stream_space M) P\"\n  shows \"scount P \\<in> measurable (stream_space M) (count_space UNIV)\"", "lemma measurable_sfirst2:\n  assumes [measurable]: \"Measurable.pred (N \\<Otimes>\\<^sub>M stream_space M) (\\<lambda>(x, \\<omega>). P x \\<omega>)\"\n  shows \"(\\<lambda>(x, \\<omega>). sfirst (P x) \\<omega>) \\<in> measurable (N \\<Otimes>\\<^sub>M  stream_space M) (count_space UNIV)\"", "lemma measurable_sfirst2'[measurable (raw)]:\n  assumes [measurable (raw)]: \"f \\<in> N \\<rightarrow>\\<^sub>M stream_space M\" \"Measurable.pred (N \\<Otimes>\\<^sub>M stream_space M) (\\<lambda>x. P (fst x) (snd x))\"\n  shows \"(\\<lambda>x. sfirst (P x) (f x)) \\<in> measurable N (count_space UNIV)\"", "lemma measurable_sfirst[measurable]:\n  assumes [measurable]: \"Measurable.pred (stream_space M) P\"\n  shows \"sfirst P \\<in> measurable (stream_space M) (count_space UNIV)\"", "lemma measurable_epred[measurable]: \"epred \\<in> count_space UNIV \\<rightarrow>\\<^sub>M count_space UNIV\"", "lemma nn_integral_stretch:\n  \"f \\<in> borel \\<rightarrow>\\<^sub>M borel \\<Longrightarrow> c \\<noteq> 0 \\<Longrightarrow> (\\<integral>\\<^sup>+x. f (c * x) \\<partial>lborel) = (1 / \\<bar>c\\<bar>::real) * (\\<integral>\\<^sup>+x. f x \\<partial>lborel)\"", "lemma prod_sum_distrib:\n  fixes f g :: \"'a \\<Rightarrow> 'b \\<Rightarrow> 'c::comm_semiring_1\"\n  assumes \"finite I\" shows \"(\\<And>i. i \\<in> I \\<Longrightarrow> finite (J i)) \\<Longrightarrow> (\\<Prod>i\\<in>I. \\<Sum>j\\<in>J i. f i j) = (\\<Sum>m\\<in>Pi\\<^sub>E I J. \\<Prod>i\\<in>I. f i (m i))\"", "lemma prod_add_distrib:\n  fixes f g :: \"'a \\<Rightarrow> 'b::comm_semiring_1\"\n  assumes \"finite I\" shows \"(\\<Prod>i\\<in>I. f i + g i) = (\\<Sum>J\\<in>Pow I. (\\<Prod>i\\<in>J. f i) * (\\<Prod>i\\<in>I - J. g i))\"", "lemma (in linordered_nonzero_semiring) prod_nonneg: \"(\\<forall>a\\<in>A. 0 \\<le> f a) \\<Longrightarrow> 0 \\<le> prod f A\"", "lemma (in linordered_nonzero_semiring) prod_mono:\n  \"\\<forall>i\\<in>A. 0 \\<le> f i \\<and> f i \\<le> g i \\<Longrightarrow> prod f A \\<le> prod g A\"", "lemma (in linordered_nonzero_semiring) prod_mono2:\n  assumes \"finite J\" \"I \\<subseteq> J\" \"\\<And>i. i \\<in> I \\<Longrightarrow> 0 \\<le> g i \\<and> g i \\<le> f i\" \"(\\<And>i. i \\<in> J - I \\<Longrightarrow> 1 \\<le> f i)\"\n  shows \"prod g I \\<le> prod f J\"", "lemma (in linordered_nonzero_semiring) prod_mono3:\n  assumes \"finite J\" \"I \\<subseteq> J\" \"\\<And>i. i \\<in> J \\<Longrightarrow> 0 \\<le> g i\" \"\\<And>i. i \\<in> I \\<Longrightarrow> g i \\<le> f i\" \"(\\<And>i. i \\<in> J - I \\<Longrightarrow> g i \\<le> 1)\"\n  shows \"prod g J \\<le> prod f I\"", "lemma (in linordered_nonzero_semiring) one_le_prod: \"(\\<And>i. i \\<in> I \\<Longrightarrow> 1 \\<le> f i) \\<Longrightarrow> 1 \\<le> prod f I\"", "lemma sum_plus_one_le_prod_plus_one:\n  fixes p :: \"'a \\<Rightarrow> 'b::linordered_nonzero_semiring\"\n  assumes \"\\<And>i. i \\<in> I \\<Longrightarrow> 0 \\<le> p i\"\n  shows \"(\\<Sum>i\\<in>I. p i) + 1 \\<le> (\\<Prod>i\\<in>I. p i + 1)\"", "lemma summable_iff_convergent_prod:\n  fixes p :: \"nat \\<Rightarrow> real\" assumes p: \"\\<And>i. 0 \\<le> p i\"\n  shows \"summable p \\<longleftrightarrow> convergent (\\<lambda>n. \\<Prod>i<n. p i + 1)\"", "lemma\n  shows eexp_minus_infty[simp]: \"eexp (-\\<infinity>) = 0\"\n    and eexp_infty[simp]: \"eexp \\<infinity> = top\"", "lemma eexp_0[simp]: \"eexp 0 = 1\"", "lemma eexp_inj[simp]: \"eexp x = eexp y \\<longleftrightarrow> x = y\"", "lemma eexp_mono[simp]: \"eexp x \\<le> eexp y \\<longleftrightarrow> x \\<le> y\"", "lemma eexp_strict_mono[simp]: \"eexp x < eexp y \\<longleftrightarrow> x < y\"", "lemma exp_eq_0_iff[simp]: \"eexp x = 0 \\<longleftrightarrow> x = -\\<infinity>\"", "lemma eexp_surj: \"range eexp = UNIV\"", "lemma continuous_on_eexp': \"continuous_on UNIV eexp\"", "lemma continuous_on_eexp[continuous_intros]: \"continuous_on A f \\<Longrightarrow> continuous_on A (\\<lambda>x. eexp (f x))\"", "lemma tendsto_eexp[tendsto_intros]: \"(f \\<longlongrightarrow> x) F \\<Longrightarrow> ((\\<lambda>x. eexp (f x)) \\<longlongrightarrow> eexp x) F\"", "lemma measurable_eexp[measurable]: \"eexp \\<in> borel \\<rightarrow>\\<^sub>M borel\"", "lemma eexp_add: \"\\<not> ((x = \\<infinity> \\<and> y = -\\<infinity>) \\<or> (x = -\\<infinity> \\<and> y = \\<infinity>)) \\<Longrightarrow> eexp (x + y) = eexp x * eexp y\"", "lemma sum_Pinfty:\n  fixes f :: \"'a \\<Rightarrow> ereal\"\n  shows \"sum f I = \\<infinity> \\<longleftrightarrow> (finite I \\<and> (\\<exists>i\\<in>I. f i = \\<infinity>))\"", "lemma sum_Minfty:\n  fixes f :: \"'a \\<Rightarrow> ereal\"\n  shows \"sum f I = -\\<infinity> \\<longleftrightarrow> (finite I \\<and> \\<not> (\\<exists>i\\<in>I. f i = \\<infinity>) \\<and> (\\<exists>i\\<in>I. f i = -\\<infinity>))\"", "lemma eexp_sum: \"\\<not> (\\<exists>i\\<in>I. \\<exists>j\\<in>I. f i = -\\<infinity> \\<and> f j = \\<infinity>) \\<Longrightarrow> eexp (\\<Sum>i\\<in>I. f i) = (\\<Prod>i\\<in>I. eexp (f i))\"", "lemma eexp_suminf:\n  assumes wf_f: \"\\<not> {-\\<infinity>, \\<infinity>} \\<subseteq> range f\" and f: \"summable f\"\n  shows \"(\\<lambda>n. \\<Prod>i<n. eexp (f i)) \\<longlonglongrightarrow> eexp (\\<Sum>i. f i)\"", "lemma continuous_onI_antimono:\n  fixes f :: \"'a::linorder_topology \\<Rightarrow> 'b::{dense_order,linorder_topology}\"\n  assumes \"open (f`A)\"\n    and mono: \"\\<And>x y. x \\<in> A \\<Longrightarrow> y \\<in> A \\<Longrightarrow> x \\<le> y \\<Longrightarrow> f y \\<le> f x\"\n  shows \"continuous_on A f\"", "lemma minus_add_eq_ereal: \"\\<not> ((a = \\<infinity> \\<and> b = -\\<infinity>) \\<or> (a = -\\<infinity> \\<and> b = \\<infinity>)) \\<Longrightarrow> - (a + b::ereal) = -a - b\"", "lemma setsum_negf_ereal: \"\\<not> {-\\<infinity>, \\<infinity>} \\<subseteq> f`I \\<Longrightarrow> (\\<Sum>i\\<in>I. - f i) = - (\\<Sum>i\\<in>I. f i::ereal)\"", "lemma convergent_minus_iff_ereal: \"convergent (\\<lambda>x. - f x::ereal) \\<longleftrightarrow> convergent f\"", "lemma summable_minus_ereal: \"\\<not> {-\\<infinity>, \\<infinity>} \\<subseteq> range f \\<Longrightarrow> summable (\\<lambda>n. f n) \\<Longrightarrow> summable (\\<lambda>n. - f n::ereal)\"", "lemma (in product_prob_space) product_nn_integral_component:\n  assumes \"f \\<in> borel_measurable (M i)\"\"i \\<in> I\"\n  shows \"integral\\<^sup>N (Pi\\<^sub>M I M) (\\<lambda>x. f (x i)) = integral\\<^sup>N (M i) f\"", "lemma ennreal_inverse_le[simp]: \"inverse x \\<le> inverse y \\<longleftrightarrow> y \\<le> (x::ennreal)\"", "lemma inverse_inverse_ennreal[simp]: \"inverse (inverse x::ennreal) = x\"", "lemma range_inverse_ennreal: \"range inverse = (UNIV::ennreal set)\"", "lemma continuous_on_inverse_ennreal': \"continuous_on (UNIV :: ennreal set) inverse\"", "lemma sums_minus_ereal: \"\\<not> {- \\<infinity>, \\<infinity>} \\<subseteq> f ` UNIV \\<Longrightarrow> (\\<lambda>n. - f n::ereal) sums x \\<Longrightarrow> f sums - x\"", "lemma suminf_minus_ereal: \"\\<not> {- \\<infinity>, \\<infinity>} \\<subseteq> f ` UNIV \\<Longrightarrow> summable f \\<Longrightarrow> (\\<Sum>n. - f n :: ereal) = - suminf f\""], "translations": [["", "lemma lfp_upperbound: \"(\\<And>y. x \\<le> f y) \\<Longrightarrow> x \\<le> lfp f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>y. x \\<le> f y) \\<Longrightarrow> x \\<le> lfp f", "unfolding lfp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>y. x \\<le> f y) \\<Longrightarrow>\n    x \\<le> \\<Sqinter> {u. f u \\<le> u}", "by (intro Inf_greatest) (auto intro: order_trans)"], ["", "(* ?? *)"], ["", "lemma lfp_arg: \"(\\<lambda>t. lfp (F t)) = lfp (\\<lambda>x t. F t (x t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>t. lfp (F t)) = lfp (\\<lambda>x t. F t (x t))", "apply (auto simp: lfp_def le_fun_def fun_eq_iff intro!: Inf_eqI Inf_greatest)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x i.\n       F x i \\<le> i \\<Longrightarrow>\n       (\\<Sqinter>f\\<in>{u. \\<forall>x. F x (u x) \\<le> u x}. f x) \\<le> i", "subgoal for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. F x y \\<le> y \\<Longrightarrow>\n    (\\<Sqinter>f\\<in>{u. \\<forall>x. F x (u x) \\<le> u x}. f x) \\<le> y", "by (rule INF_lower2[of \"top(x := y)\"]) auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma lfp_pair: \"lfp (\\<lambda>f (a, b). F (\\<lambda>a b. f (a, b)) a b) (a, b) = lfp F a b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lfp (\\<lambda>f (a, b). F (\\<lambda>a b. f (a, b)) a b) (a, b) =\n    lfp F a b", "unfolding lfp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sqinter> {u. (\\<lambda>(x, y). F (\\<lambda>a b. u (a, b)) x y)\n                    \\<le> u})\n     (a, b) =\n    (\\<Sqinter> {u. F u \\<le> u}) a b", "by (auto intro!: INF_eq simp: le_fun_def)\n     (auto intro!: exI[of _ \"\\<lambda>(a, b). x a b\" for x])"], ["", "lemma all_Suc_split: \"(\\<forall>i. P i) \\<longleftrightarrow> (P 0 \\<and> (\\<forall>i. P (Suc i)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>i. P i) = (P 0 \\<and> (\\<forall>i. P (Suc i)))", "using nat_induct"], ["proof (prove)\nusing this:\n  \\<lbrakk>?P 0; \\<And>n. ?P n \\<Longrightarrow> ?P (Suc n)\\<rbrakk>\n  \\<Longrightarrow> ?P ?n\n\ngoal (1 subgoal):\n 1. (\\<forall>i. P i) = (P 0 \\<and> (\\<forall>i. P (Suc i)))", "by auto"], ["", "definition \"with P f d = (if \\<exists>x. P x then f (SOME x. P x) else d)\""], ["", "lemma withI[case_names default exists]:\n  \"((\\<And>x. \\<not> P x) \\<Longrightarrow> Q d) \\<Longrightarrow> (\\<And>x. P x \\<Longrightarrow> Q (f x)) \\<Longrightarrow> Q (with P f d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<And>x. \\<not> P x) \\<Longrightarrow> Q d;\n     \\<And>x. P x \\<Longrightarrow> Q (f x)\\<rbrakk>\n    \\<Longrightarrow> Q (with P f d)", "unfolding with_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<And>x. \\<not> P x) \\<Longrightarrow> Q d;\n     \\<And>x. P x \\<Longrightarrow> Q (f x)\\<rbrakk>\n    \\<Longrightarrow> Q (if Ex P then f (Eps P) else d)", "by (auto intro: someI2)"], ["", "context order\nbegin"], ["", "definition\n  \"maximal f S = {x\\<in>S. \\<forall>y\\<in>S. f y \\<le> f x}\""], ["", "lemma maximalI: \"x \\<in> S \\<Longrightarrow> (\\<And>y. y \\<in> S \\<Longrightarrow> f y \\<le> f x) \\<Longrightarrow> x \\<in> maximal f S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> S;\n     \\<And>y. y \\<in> S \\<Longrightarrow> f y \\<le> f x\\<rbrakk>\n    \\<Longrightarrow> x \\<in> maximal f S", "by (simp add: maximal_def)"], ["", "lemma maximalI_trans: \"x \\<in> maximal f S \\<Longrightarrow> f x \\<le> f y \\<Longrightarrow> y \\<in> S \\<Longrightarrow> y \\<in> maximal f S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> maximal f S; f x \\<le> f y; y \\<in> S\\<rbrakk>\n    \\<Longrightarrow> y \\<in> maximal f S", "unfolding maximal_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> {x \\<in> S. \\<forall>y\\<in>S. f y \\<le> f x};\n     f x \\<le> f y; y \\<in> S\\<rbrakk>\n    \\<Longrightarrow> y \\<in> {x \\<in> S. \\<forall>y\\<in>S. f y \\<le> f x}", "by (blast intro: antisym order_trans)"], ["", "lemma maximalD1: \"x \\<in> maximal f S \\<Longrightarrow> x \\<in> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> maximal f S \\<Longrightarrow> x \\<in> S", "by (simp add: maximal_def)"], ["", "lemma maximalD2: \"x \\<in> maximal f S \\<Longrightarrow> y \\<in> S \\<Longrightarrow> f y \\<le> f x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> maximal f S; y \\<in> S\\<rbrakk>\n    \\<Longrightarrow> f y \\<le> f x", "by (simp add: maximal_def)"], ["", "lemma maximal_inject: \"x \\<in> maximal f S \\<Longrightarrow> y \\<in> maximal f S \\<Longrightarrow> f x = f y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> maximal f S; y \\<in> maximal f S\\<rbrakk>\n    \\<Longrightarrow> f x = f y", "unfolding maximal_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> {x \\<in> S. \\<forall>y\\<in>S. f y \\<le> f x};\n     y \\<in> {x \\<in> S. \\<forall>y\\<in>S. f y \\<le> f x}\\<rbrakk>\n    \\<Longrightarrow> f x = f y", "by (blast intro: antisym)"], ["", "lemma maximal_empty[simp]: \"maximal f {} = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. maximal f {} = {}", "by (simp add: maximal_def)"], ["", "lemma maximal_singleton[simp]: \"maximal f {x} = {x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. maximal f {x} = {x}", "by (auto simp add: maximal_def)"], ["", "lemma maximal_in_S: \"maximal f S \\<subseteq> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. maximal f S \\<subseteq> S", "by (auto simp: maximal_def)"], ["", "end"], ["", "context linorder\nbegin"], ["", "lemma maximal_ne:\n  assumes \"finite S\" \"S \\<noteq> {}\"\n  shows \"maximal f S \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. maximal f S \\<noteq> {}", "using assms"], ["proof (prove)\nusing this:\n  finite S\n  S \\<noteq> {}\n\ngoal (1 subgoal):\n 1. maximal f S \\<noteq> {}", "proof (induct rule: finite_ne_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x. maximal f {x} \\<noteq> {}\n 2. \\<And>x F.\n       \\<lbrakk>finite F; F \\<noteq> {}; x \\<notin> F;\n        maximal f F \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> maximal f (insert x F) \\<noteq> {}", "case (insert s S)"], ["proof (state)\nthis:\n  finite S\n  S \\<noteq> {}\n  s \\<notin> S\n  maximal f S \\<noteq> {}\n\ngoal (2 subgoals):\n 1. \\<And>x. maximal f {x} \\<noteq> {}\n 2. \\<And>x F.\n       \\<lbrakk>finite F; F \\<noteq> {}; x \\<notin> F;\n        maximal f F \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> maximal f (insert x F) \\<noteq> {}", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. maximal f (insert s S) \\<noteq> {}", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> maximal f (insert s S) \\<noteq> {}\n 2. \\<not> ?P \\<Longrightarrow> maximal f (insert s S) \\<noteq> {}", "assume \"\\<forall>x\\<in>S. f x \\<le> f s\""], ["proof (state)\nthis:\n  \\<forall>x\\<in>S. f x \\<le> f s\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> maximal f (insert s S) \\<noteq> {}\n 2. \\<not> ?P \\<Longrightarrow> maximal f (insert s S) \\<noteq> {}", "with insert"], ["proof (chain)\npicking this:\n  finite S\n  S \\<noteq> {}\n  s \\<notin> S\n  maximal f S \\<noteq> {}\n  \\<forall>x\\<in>S. f x \\<le> f s", "have \"s \\<in> maximal f (insert s S)\""], ["proof (prove)\nusing this:\n  finite S\n  S \\<noteq> {}\n  s \\<notin> S\n  maximal f S \\<noteq> {}\n  \\<forall>x\\<in>S. f x \\<le> f s\n\ngoal (1 subgoal):\n 1. s \\<in> maximal f (insert s S)", "by (auto intro!: maximalI)"], ["proof (state)\nthis:\n  s \\<in> maximal f (insert s S)\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> maximal f (insert s S) \\<noteq> {}\n 2. \\<not> ?P \\<Longrightarrow> maximal f (insert s S) \\<noteq> {}", "then"], ["proof (chain)\npicking this:\n  s \\<in> maximal f (insert s S)", "show ?thesis"], ["proof (prove)\nusing this:\n  s \\<in> maximal f (insert s S)\n\ngoal (1 subgoal):\n 1. maximal f (insert s S) \\<noteq> {}", "by auto"], ["proof (state)\nthis:\n  maximal f (insert s S) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>x\\<in>S. f x \\<le> f s) \\<Longrightarrow>\n    maximal f (insert s S) \\<noteq> {}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>x\\<in>S. f x \\<le> f s) \\<Longrightarrow>\n    maximal f (insert s S) \\<noteq> {}", "assume \"\\<not> (\\<forall>x\\<in>S. f x \\<le> f s)\""], ["proof (state)\nthis:\n  \\<not> (\\<forall>x\\<in>S. f x \\<le> f s)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>x\\<in>S. f x \\<le> f s) \\<Longrightarrow>\n    maximal f (insert s S) \\<noteq> {}", "then"], ["proof (chain)\npicking this:\n  \\<not> (\\<forall>x\\<in>S. f x \\<le> f s)", "have \"maximal f (insert s S) = maximal f S\""], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>x\\<in>S. f x \\<le> f s)\n\ngoal (1 subgoal):\n 1. maximal f (insert s S) = maximal f S", "by (auto simp: maximal_def)"], ["proof (state)\nthis:\n  maximal f (insert s S) = maximal f S\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>x\\<in>S. f x \\<le> f s) \\<Longrightarrow>\n    maximal f (insert s S) \\<noteq> {}", "with insert"], ["proof (chain)\npicking this:\n  finite S\n  S \\<noteq> {}\n  s \\<notin> S\n  maximal f S \\<noteq> {}\n  maximal f (insert s S) = maximal f S", "show ?thesis"], ["proof (prove)\nusing this:\n  finite S\n  S \\<noteq> {}\n  s \\<notin> S\n  maximal f S \\<noteq> {}\n  maximal f (insert s S) = maximal f S\n\ngoal (1 subgoal):\n 1. maximal f (insert s S) \\<noteq> {}", "by auto"], ["proof (state)\nthis:\n  maximal f (insert s S) \\<noteq> {}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  maximal f (insert s S) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<And>x. maximal f {x} \\<noteq> {}", "qed simp"], ["", "end"], ["", "lemma mono_les:\n  fixes s S N and l1 l2 :: \"'a \\<Rightarrow> real\" and K :: \"'a \\<Rightarrow> 'a pmf\"\n  defines \"\\<Delta> x \\<equiv> l2 x - l1 x\"\n  assumes s: \"s \\<in> S\" and S: \"(\\<Union>s\\<in>S. set_pmf (K s)) \\<subseteq> S \\<union> N\"\n  assumes int_l1[simp]: \"\\<And>s. s \\<in> S \\<Longrightarrow> integrable (K s) l1\"\n  assumes int_l2[simp]: \"\\<And>s. s \\<in> S \\<Longrightarrow> integrable (K s) l2\"\n  assumes to_N: \"\\<And>s. s \\<in> S \\<Longrightarrow> \\<exists>t\\<in>N. (s, t) \\<in> (SIGMA s:UNIV. K s)\\<^sup>*\"\n  assumes l1: \"\\<And>s. s \\<in> S \\<Longrightarrow> (\\<integral>t. l1 t \\<partial>K s) + c s \\<le> l1 s\"\n  assumes l2: \"\\<And>s. s \\<in> S \\<Longrightarrow> l2 s \\<le> (\\<integral>t. l2 t \\<partial>K s) + c s\"\n  assumes eq: \"\\<And>s. s \\<in> N \\<Longrightarrow> l2 s \\<le> l1 s\"\n  assumes finitary: \"finite (\\<Delta> ` (S\\<union>N))\"\n  shows \"l2 s \\<le> l1 s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l2 s \\<le> l1 s", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. l2 s \\<le> l1 s", "define M where \"M = {s\\<in>S\\<union>N. \\<forall>t\\<in>S\\<union>N. \\<Delta> t \\<le> \\<Delta> s}\""], ["proof (state)\nthis:\n  M =\n  {s \\<in> S \\<union> N.\n   \\<forall>t\\<in>S \\<union> N. \\<Delta> t \\<le> \\<Delta> s}\n\ngoal (1 subgoal):\n 1. l2 s \\<le> l1 s", "have [simp]: \"\\<And>s. s\\<in>S \\<Longrightarrow> integrable (K s) \\<Delta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s.\n       s \\<in> S \\<Longrightarrow> integrable (measure_pmf (K s)) \\<Delta>", "by (simp add: \\<Delta>_def[abs_def])"], ["proof (state)\nthis:\n  ?s \\<in> S \\<Longrightarrow> integrable (measure_pmf (K ?s)) \\<Delta>\n\ngoal (1 subgoal):\n 1. l2 s \\<le> l1 s", "have M_unqiue: \"\\<And>s t. s \\<in> M \\<Longrightarrow> t \\<in> M \\<Longrightarrow> \\<Delta> s = \\<Delta> t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s t.\n       \\<lbrakk>s \\<in> M; t \\<in> M\\<rbrakk>\n       \\<Longrightarrow> \\<Delta> s = \\<Delta> t", "by (auto intro!: antisym simp: M_def)"], ["proof (state)\nthis:\n  \\<lbrakk>?s \\<in> M; ?t \\<in> M\\<rbrakk>\n  \\<Longrightarrow> \\<Delta> ?s = \\<Delta> ?t\n\ngoal (1 subgoal):\n 1. l2 s \\<le> l1 s", "have M1: \"\\<And>s. s \\<in> M \\<Longrightarrow> s \\<in> S \\<union> N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s. s \\<in> M \\<Longrightarrow> s \\<in> S \\<union> N", "by (auto simp: M_def)"], ["proof (state)\nthis:\n  ?s \\<in> M \\<Longrightarrow> ?s \\<in> S \\<union> N\n\ngoal (1 subgoal):\n 1. l2 s \\<le> l1 s", "have M2: \"\\<And>s t. s \\<in> M \\<Longrightarrow> t \\<in> S \\<union> N \\<Longrightarrow> \\<Delta> t \\<le> \\<Delta> s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s t.\n       \\<lbrakk>s \\<in> M; t \\<in> S \\<union> N\\<rbrakk>\n       \\<Longrightarrow> \\<Delta> t \\<le> \\<Delta> s", "by (auto simp: M_def)"], ["proof (state)\nthis:\n  \\<lbrakk>?s \\<in> M; ?t \\<in> S \\<union> N\\<rbrakk>\n  \\<Longrightarrow> \\<Delta> ?t \\<le> \\<Delta> ?s\n\ngoal (1 subgoal):\n 1. l2 s \\<le> l1 s", "have M3: \"\\<And>s t. s \\<in> M \\<Longrightarrow> t \\<in> S \\<union> N \\<Longrightarrow> t \\<notin> M \\<Longrightarrow> \\<Delta> t < \\<Delta> s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s t.\n       \\<lbrakk>s \\<in> M; t \\<in> S \\<union> N; t \\<notin> M\\<rbrakk>\n       \\<Longrightarrow> \\<Delta> t < \\<Delta> s", "by (auto simp: M_def less_le)"], ["proof (state)\nthis:\n  \\<lbrakk>?s \\<in> M; ?t \\<in> S \\<union> N; ?t \\<notin> M\\<rbrakk>\n  \\<Longrightarrow> \\<Delta> ?t < \\<Delta> ?s\n\ngoal (1 subgoal):\n 1. l2 s \\<le> l1 s", "have N: \"\\<forall>s\\<in>N. \\<Delta> s \\<le> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>s\\<in>N. \\<Delta> s \\<le> 0", "using eq"], ["proof (prove)\nusing this:\n  ?s \\<in> N \\<Longrightarrow> l2 ?s \\<le> l1 ?s\n\ngoal (1 subgoal):\n 1. \\<forall>s\\<in>N. \\<Delta> s \\<le> 0", "by (simp add: \\<Delta>_def)"], ["proof (state)\nthis:\n  \\<forall>s\\<in>N. \\<Delta> s \\<le> 0\n\ngoal (1 subgoal):\n 1. l2 s \\<le> l1 s", "{"], ["proof (state)\nthis:\n  \\<forall>s\\<in>N. \\<Delta> s \\<le> 0\n\ngoal (1 subgoal):\n 1. l2 s \\<le> l1 s", "fix s"], ["proof (state)\ngoal (1 subgoal):\n 1. l2 s \\<le> l1 s", "assume s: \"s \\<in> M\" \"M \\<inter> N = {}\""], ["proof (state)\nthis:\n  s \\<in> M\n  M \\<inter> N = {}\n\ngoal (1 subgoal):\n 1. l2 s \\<le> l1 s", "then"], ["proof (chain)\npicking this:\n  s \\<in> M\n  M \\<inter> N = {}", "have \"s \\<in> S - N\""], ["proof (prove)\nusing this:\n  s \\<in> M\n  M \\<inter> N = {}\n\ngoal (1 subgoal):\n 1. s \\<in> S - N", "by (auto dest: M1)"], ["proof (state)\nthis:\n  s \\<in> S - N\n\ngoal (1 subgoal):\n 1. l2 s \\<le> l1 s", "with to_N[of s]"], ["proof (chain)\npicking this:\n  s \\<in> S \\<Longrightarrow>\n  \\<exists>t\\<in>N. (s, t) \\<in> (SIGMA x:UNIV. set_pmf (K x))\\<^sup>*\n  s \\<in> S - N", "obtain t where \"(s, t) \\<in> (SIGMA s:UNIV. K s)\\<^sup>*\" and \"t \\<in> N\""], ["proof (prove)\nusing this:\n  s \\<in> S \\<Longrightarrow>\n  \\<exists>t\\<in>N. (s, t) \\<in> (SIGMA x:UNIV. set_pmf (K x))\\<^sup>*\n  s \\<in> S - N\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        \\<lbrakk>(s, t) \\<in> (SIGMA x:UNIV. set_pmf (K x))\\<^sup>*;\n         t \\<in> N\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: M_def)"], ["proof (state)\nthis:\n  (s, t) \\<in> (SIGMA x:UNIV. set_pmf (K x))\\<^sup>*\n  t \\<in> N\n\ngoal (1 subgoal):\n 1. l2 s \\<le> l1 s", "from this(1) \\<open>s \\<in> M\\<close>"], ["proof (chain)\npicking this:\n  (s, t) \\<in> (SIGMA x:UNIV. set_pmf (K x))\\<^sup>*\n  s \\<in> M", "have \"\\<Delta> s \\<le> 0\""], ["proof (prove)\nusing this:\n  (s, t) \\<in> (SIGMA x:UNIV. set_pmf (K x))\\<^sup>*\n  s \\<in> M\n\ngoal (1 subgoal):\n 1. \\<Delta> s \\<le> 0", "proof (induction rule: converse_rtrancl_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. t \\<in> M \\<Longrightarrow> \\<Delta> t \\<le> 0\n 2. \\<And>y z.\n       \\<lbrakk>(y, z) \\<in> (SIGMA x:UNIV. set_pmf (K x));\n        (z, t) \\<in> (SIGMA x:UNIV. set_pmf (K x))\\<^sup>*;\n        z \\<in> M \\<Longrightarrow> \\<Delta> z \\<le> 0; y \\<in> M\\<rbrakk>\n       \\<Longrightarrow> \\<Delta> y \\<le> 0", "case (step s s')"], ["proof (state)\nthis:\n  (s, s') \\<in> (SIGMA x:UNIV. set_pmf (K x))\n  (s', t) \\<in> (SIGMA x:UNIV. set_pmf (K x))\\<^sup>*\n  s' \\<in> M \\<Longrightarrow> \\<Delta> s' \\<le> 0\n  s \\<in> M\n\ngoal (2 subgoals):\n 1. t \\<in> M \\<Longrightarrow> \\<Delta> t \\<le> 0\n 2. \\<And>y z.\n       \\<lbrakk>(y, z) \\<in> (SIGMA x:UNIV. set_pmf (K x));\n        (z, t) \\<in> (SIGMA x:UNIV. set_pmf (K x))\\<^sup>*;\n        z \\<in> M \\<Longrightarrow> \\<Delta> z \\<le> 0; y \\<in> M\\<rbrakk>\n       \\<Longrightarrow> \\<Delta> y \\<le> 0", "then"], ["proof (chain)\npicking this:\n  (s, s') \\<in> (SIGMA x:UNIV. set_pmf (K x))\n  (s', t) \\<in> (SIGMA x:UNIV. set_pmf (K x))\\<^sup>*\n  s' \\<in> M \\<Longrightarrow> \\<Delta> s' \\<le> 0\n  s \\<in> M", "have s: \"s \\<in> M\" \"s \\<in> S\" \"s \\<notin> N\" and s': \"s' \\<in> S \\<union> N\" \"s' \\<in> K s\""], ["proof (prove)\nusing this:\n  (s, s') \\<in> (SIGMA x:UNIV. set_pmf (K x))\n  (s', t) \\<in> (SIGMA x:UNIV. set_pmf (K x))\\<^sup>*\n  s' \\<in> M \\<Longrightarrow> \\<Delta> s' \\<le> 0\n  s \\<in> M\n\ngoal (1 subgoal):\n 1. (s \\<in> M &&& s \\<in> S &&& s \\<notin> N) &&&\n    s' \\<in> S \\<union> N &&& s' \\<in> set_pmf (K s)", "using S \\<open>M \\<inter> N = {}\\<close>"], ["proof (prove)\nusing this:\n  (s, s') \\<in> (SIGMA x:UNIV. set_pmf (K x))\n  (s', t) \\<in> (SIGMA x:UNIV. set_pmf (K x))\\<^sup>*\n  s' \\<in> M \\<Longrightarrow> \\<Delta> s' \\<le> 0\n  s \\<in> M\n  (\\<Union>s\\<in>S. set_pmf (K s)) \\<subseteq> S \\<union> N\n  M \\<inter> N = {}\n\ngoal (1 subgoal):\n 1. (s \\<in> M &&& s \\<in> S &&& s \\<notin> N) &&&\n    s' \\<in> S \\<union> N &&& s' \\<in> set_pmf (K s)", "by (auto dest: M1)"], ["proof (state)\nthis:\n  s \\<in> M\n  s \\<in> S\n  s \\<notin> N\n  s' \\<in> S \\<union> N\n  s' \\<in> set_pmf (K s)\n\ngoal (2 subgoals):\n 1. t \\<in> M \\<Longrightarrow> \\<Delta> t \\<le> 0\n 2. \\<And>y z.\n       \\<lbrakk>(y, z) \\<in> (SIGMA x:UNIV. set_pmf (K x));\n        (z, t) \\<in> (SIGMA x:UNIV. set_pmf (K x))\\<^sup>*;\n        z \\<in> M \\<Longrightarrow> \\<Delta> z \\<le> 0; y \\<in> M\\<rbrakk>\n       \\<Longrightarrow> \\<Delta> y \\<le> 0", "have \"s' \\<in> M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s' \\<in> M", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. s' \\<notin> M \\<Longrightarrow> False", "assume \"s' \\<notin> M\""], ["proof (state)\nthis:\n  s' \\<notin> M\n\ngoal (1 subgoal):\n 1. s' \\<notin> M \\<Longrightarrow> False", "with \\<open>s \\<in> S\\<close> s' \\<open>s \\<in> M\\<close>"], ["proof (chain)\npicking this:\n  s \\<in> S\n  s' \\<in> S \\<union> N\n  s' \\<in> set_pmf (K s)\n  s \\<in> M\n  s' \\<notin> M", "have \"0 < pmf (K s) s'\" \"\\<Delta> s' < \\<Delta> s\""], ["proof (prove)\nusing this:\n  s \\<in> S\n  s' \\<in> S \\<union> N\n  s' \\<in> set_pmf (K s)\n  s \\<in> M\n  s' \\<notin> M\n\ngoal (1 subgoal):\n 1. 0 < pmf (K s) s' &&& \\<Delta> s' < \\<Delta> s", "by (auto intro: M2 M3 pmf_positive)"], ["proof (state)\nthis:\n  0 < pmf (K s) s'\n  \\<Delta> s' < \\<Delta> s\n\ngoal (1 subgoal):\n 1. s' \\<notin> M \\<Longrightarrow> False", "have \"\\<Delta> s \\<le> ((\\<integral>t. l2 t \\<partial>K s) + c s) - ((\\<integral>t. l1 t \\<partial>K s) + c s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Delta> s\n    \\<le> measure_pmf.expectation (K s) l2 + c s -\n          (measure_pmf.expectation (K s) l1 + c s)", "unfolding \\<Delta>_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. l2 s - l1 s\n    \\<le> measure_pmf.expectation (K s) l2 + c s -\n          (measure_pmf.expectation (K s) l1 + c s)", "using \\<open>s \\<in> S\\<close> \\<open>s \\<notin> N\\<close>"], ["proof (prove)\nusing this:\n  s \\<in> S\n  s \\<notin> N\n\ngoal (1 subgoal):\n 1. l2 s - l1 s\n    \\<le> measure_pmf.expectation (K s) l2 + c s -\n          (measure_pmf.expectation (K s) l1 + c s)", "by (intro diff_mono l1 l2) auto"], ["proof (state)\nthis:\n  \\<Delta> s\n  \\<le> measure_pmf.expectation (K s) l2 + c s -\n        (measure_pmf.expectation (K s) l1 + c s)\n\ngoal (1 subgoal):\n 1. s' \\<notin> M \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<Delta> s\n  \\<le> measure_pmf.expectation (K s) l2 + c s -\n        (measure_pmf.expectation (K s) l1 + c s)", "have \"\\<Delta> s \\<le> (\\<integral>s'. \\<Delta> s' \\<partial>K s)\""], ["proof (prove)\nusing this:\n  \\<Delta> s\n  \\<le> measure_pmf.expectation (K s) l2 + c s -\n        (measure_pmf.expectation (K s) l1 + c s)\n\ngoal (1 subgoal):\n 1. \\<Delta> s \\<le> measure_pmf.expectation (K s) \\<Delta>", "using \\<open>s \\<in> S\\<close>"], ["proof (prove)\nusing this:\n  \\<Delta> s\n  \\<le> measure_pmf.expectation (K s) l2 + c s -\n        (measure_pmf.expectation (K s) l1 + c s)\n  s \\<in> S\n\ngoal (1 subgoal):\n 1. \\<Delta> s \\<le> measure_pmf.expectation (K s) \\<Delta>", "by (simp add: \\<Delta>_def)"], ["proof (state)\nthis:\n  \\<Delta> s \\<le> measure_pmf.expectation (K s) \\<Delta>\n\ngoal (1 subgoal):\n 1. s' \\<notin> M \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  \\<Delta> s \\<le> measure_pmf.expectation (K s) \\<Delta>\n\ngoal (1 subgoal):\n 1. s' \\<notin> M \\<Longrightarrow> False", "have \"\\<dots> < (\\<integral>s'. \\<Delta> s \\<partial>K s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. measure_pmf.expectation (K s) \\<Delta>\n    < measure_pmf.expectation (K s) (\\<lambda>s'. \\<Delta> s)", "using \\<open>s' \\<in> K s\\<close> \\<open>\\<Delta> s' < \\<Delta> s\\<close> \\<open>s\\<in>S\\<close> S \\<open>s\\<in>M\\<close>"], ["proof (prove)\nusing this:\n  s' \\<in> set_pmf (K s)\n  \\<Delta> s' < \\<Delta> s\n  s \\<in> S\n  (\\<Union>s\\<in>S. set_pmf (K s)) \\<subseteq> S \\<union> N\n  s \\<in> M\n\ngoal (1 subgoal):\n 1. measure_pmf.expectation (K s) \\<Delta>\n    < measure_pmf.expectation (K s) (\\<lambda>s'. \\<Delta> s)", "by (intro measure_pmf.integral_less_AE[where A=\"{s'}\"])\n             (auto simp: emeasure_measure_pmf_finite AE_measure_pmf_iff set_pmf_iff[symmetric]\n                   intro!: M2)"], ["proof (state)\nthis:\n  measure_pmf.expectation (K s) \\<Delta>\n  < measure_pmf.expectation (K s) (\\<lambda>s'. \\<Delta> s)\n\ngoal (1 subgoal):\n 1. s' \\<notin> M \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  \\<Delta> s < measure_pmf.expectation (K s) (\\<lambda>s'. \\<Delta> s)", "show False"], ["proof (prove)\nusing this:\n  \\<Delta> s < measure_pmf.expectation (K s) (\\<lambda>s'. \\<Delta> s)\n\ngoal (1 subgoal):\n 1. False", "using measure_pmf.prob_space[of \"K s\"]"], ["proof (prove)\nusing this:\n  \\<Delta> s < measure_pmf.expectation (K s) (\\<lambda>s'. \\<Delta> s)\n  measure_pmf.prob (K s) (space (measure_pmf (K s))) = 1\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  s' \\<in> M\n\ngoal (2 subgoals):\n 1. t \\<in> M \\<Longrightarrow> \\<Delta> t \\<le> 0\n 2. \\<And>y z.\n       \\<lbrakk>(y, z) \\<in> (SIGMA x:UNIV. set_pmf (K x));\n        (z, t) \\<in> (SIGMA x:UNIV. set_pmf (K x))\\<^sup>*;\n        z \\<in> M \\<Longrightarrow> \\<Delta> z \\<le> 0; y \\<in> M\\<rbrakk>\n       \\<Longrightarrow> \\<Delta> y \\<le> 0", "with step.IH \\<open>t\\<in>N\\<close> N"], ["proof (chain)\npicking this:\n  s' \\<in> M \\<Longrightarrow> \\<Delta> s' \\<le> 0\n  t \\<in> N\n  \\<forall>s\\<in>N. \\<Delta> s \\<le> 0\n  s' \\<in> M", "have \"\\<Delta> s' \\<le> 0\" \"s' \\<in> M\""], ["proof (prove)\nusing this:\n  s' \\<in> M \\<Longrightarrow> \\<Delta> s' \\<le> 0\n  t \\<in> N\n  \\<forall>s\\<in>N. \\<Delta> s \\<le> 0\n  s' \\<in> M\n\ngoal (1 subgoal):\n 1. \\<Delta> s' \\<le> 0 &&& s' \\<in> M", "by auto"], ["proof (state)\nthis:\n  \\<Delta> s' \\<le> 0\n  s' \\<in> M\n\ngoal (2 subgoals):\n 1. t \\<in> M \\<Longrightarrow> \\<Delta> t \\<le> 0\n 2. \\<And>y z.\n       \\<lbrakk>(y, z) \\<in> (SIGMA x:UNIV. set_pmf (K x));\n        (z, t) \\<in> (SIGMA x:UNIV. set_pmf (K x))\\<^sup>*;\n        z \\<in> M \\<Longrightarrow> \\<Delta> z \\<le> 0; y \\<in> M\\<rbrakk>\n       \\<Longrightarrow> \\<Delta> y \\<le> 0", "with \\<open>s\\<in>S\\<close>"], ["proof (chain)\npicking this:\n  s \\<in> S\n  \\<Delta> s' \\<le> 0\n  s' \\<in> M", "show \"\\<Delta> s \\<le> 0\""], ["proof (prove)\nusing this:\n  s \\<in> S\n  \\<Delta> s' \\<le> 0\n  s' \\<in> M\n\ngoal (1 subgoal):\n 1. \\<Delta> s \\<le> 0", "by (force simp: M_def)"], ["proof (state)\nthis:\n  \\<Delta> s \\<le> 0\n\ngoal (1 subgoal):\n 1. t \\<in> M \\<Longrightarrow> \\<Delta> t \\<le> 0", "qed (insert N \\<open>t\\<in>N\\<close>, auto)"], ["proof (state)\nthis:\n  \\<Delta> s \\<le> 0\n\ngoal (1 subgoal):\n 1. l2 s \\<le> l1 s", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?sa2 \\<in> M; M \\<inter> N = {}\\<rbrakk>\n  \\<Longrightarrow> \\<Delta> ?sa2 \\<le> 0\n\ngoal (1 subgoal):\n 1. l2 s \\<le> l1 s", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. l2 s \\<le> l1 s", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> l2 s \\<le> l1 s\n 2. \\<not> ?P \\<Longrightarrow> l2 s \\<le> l1 s", "assume \"M \\<inter> N = {}\""], ["proof (state)\nthis:\n  M \\<inter> N = {}\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> l2 s \\<le> l1 s\n 2. \\<not> ?P \\<Longrightarrow> l2 s \\<le> l1 s", "have \"Max (\\<Delta>`(S\\<union>N)) \\<in> \\<Delta>`(S\\<union>N)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Max (\\<Delta> ` (S \\<union> N)) \\<in> \\<Delta> ` (S \\<union> N)", "using \\<open>s \\<in> S\\<close>"], ["proof (prove)\nusing this:\n  s \\<in> S\n\ngoal (1 subgoal):\n 1. Max (\\<Delta> ` (S \\<union> N)) \\<in> \\<Delta> ` (S \\<union> N)", "by (intro Max_in finitary) auto"], ["proof (state)\nthis:\n  Max (\\<Delta> ` (S \\<union> N)) \\<in> \\<Delta> ` (S \\<union> N)\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> l2 s \\<le> l1 s\n 2. \\<not> ?P \\<Longrightarrow> l2 s \\<le> l1 s", "then"], ["proof (chain)\npicking this:\n  Max (\\<Delta> ` (S \\<union> N)) \\<in> \\<Delta> ` (S \\<union> N)", "obtain t where \"t \\<in> S \\<union> N\" \"\\<Delta> t = Max (\\<Delta>`(S\\<union>N))\""], ["proof (prove)\nusing this:\n  Max (\\<Delta> ` (S \\<union> N)) \\<in> \\<Delta> ` (S \\<union> N)\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        \\<lbrakk>t \\<in> S \\<union> N;\n         \\<Delta> t = Max (\\<Delta> ` (S \\<union> N))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding image_iff"], ["proof (prove)\nusing this:\n  \\<exists>x\\<in>S \\<union> N. Max (\\<Delta> ` (S \\<union> N)) = \\<Delta> x\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        \\<lbrakk>t \\<in> S \\<union> N;\n         \\<Delta> t = Max (\\<Delta> ` (S \\<union> N))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  t \\<in> S \\<union> N\n  \\<Delta> t = Max (\\<Delta> ` (S \\<union> N))\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> l2 s \\<le> l1 s\n 2. \\<not> ?P \\<Longrightarrow> l2 s \\<le> l1 s", "then"], ["proof (chain)\npicking this:\n  t \\<in> S \\<union> N\n  \\<Delta> t = Max (\\<Delta> ` (S \\<union> N))", "have \"t \\<in> M\""], ["proof (prove)\nusing this:\n  t \\<in> S \\<union> N\n  \\<Delta> t = Max (\\<Delta> ` (S \\<union> N))\n\ngoal (1 subgoal):\n 1. t \\<in> M", "by (auto simp: M_def finitary intro!: Max_ge)"], ["proof (state)\nthis:\n  t \\<in> M\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> l2 s \\<le> l1 s\n 2. \\<not> ?P \\<Longrightarrow> l2 s \\<le> l1 s", "have \"\\<Delta> s \\<le> \\<Delta> t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Delta> s \\<le> \\<Delta> t", "using \\<open>t\\<in>M\\<close> \\<open>s\\<in>S\\<close>"], ["proof (prove)\nusing this:\n  t \\<in> M\n  s \\<in> S\n\ngoal (1 subgoal):\n 1. \\<Delta> s \\<le> \\<Delta> t", "by (auto dest: M2)"], ["proof (state)\nthis:\n  \\<Delta> s \\<le> \\<Delta> t\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> l2 s \\<le> l1 s\n 2. \\<not> ?P \\<Longrightarrow> l2 s \\<le> l1 s", "also"], ["proof (state)\nthis:\n  \\<Delta> s \\<le> \\<Delta> t\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> l2 s \\<le> l1 s\n 2. \\<not> ?P \\<Longrightarrow> l2 s \\<le> l1 s", "have \"\\<Delta> t \\<le> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Delta> t \\<le> 0", "using \\<open>t\\<in>M\\<close> \\<open>M \\<inter> N = {}\\<close>"], ["proof (prove)\nusing this:\n  t \\<in> M\n  M \\<inter> N = {}\n\ngoal (1 subgoal):\n 1. \\<Delta> t \\<le> 0", "by fact"], ["proof (state)\nthis:\n  \\<Delta> t \\<le> 0\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> l2 s \\<le> l1 s\n 2. \\<not> ?P \\<Longrightarrow> l2 s \\<le> l1 s", "finally"], ["proof (chain)\npicking this:\n  \\<Delta> s \\<le> 0", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<Delta> s \\<le> 0\n\ngoal (1 subgoal):\n 1. l2 s \\<le> l1 s", "by (simp add: \\<Delta>_def)"], ["proof (state)\nthis:\n  l2 s \\<le> l1 s\n\ngoal (1 subgoal):\n 1. M \\<inter> N \\<noteq> {} \\<Longrightarrow> l2 s \\<le> l1 s", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. M \\<inter> N \\<noteq> {} \\<Longrightarrow> l2 s \\<le> l1 s", "assume \"M \\<inter> N \\<noteq> {}\""], ["proof (state)\nthis:\n  M \\<inter> N \\<noteq> {}\n\ngoal (1 subgoal):\n 1. M \\<inter> N \\<noteq> {} \\<Longrightarrow> l2 s \\<le> l1 s", "then"], ["proof (chain)\npicking this:\n  M \\<inter> N \\<noteq> {}", "obtain t where \"t \\<in> M\" \"t \\<in> N\""], ["proof (prove)\nusing this:\n  M \\<inter> N \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        \\<lbrakk>t \\<in> M; t \\<in> N\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  t \\<in> M\n  t \\<in> N\n\ngoal (1 subgoal):\n 1. M \\<inter> N \\<noteq> {} \\<Longrightarrow> l2 s \\<le> l1 s", "with N \\<open>s\\<in>S\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>s\\<in>N. \\<Delta> s \\<le> 0\n  s \\<in> S\n  t \\<in> M\n  t \\<in> N", "have \"\\<Delta> s \\<le> 0\""], ["proof (prove)\nusing this:\n  \\<forall>s\\<in>N. \\<Delta> s \\<le> 0\n  s \\<in> S\n  t \\<in> M\n  t \\<in> N\n\ngoal (1 subgoal):\n 1. \\<Delta> s \\<le> 0", "by (intro order_trans[of \"\\<Delta> s\" \"\\<Delta> t\" 0]) (auto simp: M_def)"], ["proof (state)\nthis:\n  \\<Delta> s \\<le> 0\n\ngoal (1 subgoal):\n 1. M \\<inter> N \\<noteq> {} \\<Longrightarrow> l2 s \\<le> l1 s", "then"], ["proof (chain)\npicking this:\n  \\<Delta> s \\<le> 0", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<Delta> s \\<le> 0\n\ngoal (1 subgoal):\n 1. l2 s \\<le> l1 s", "by (simp add: \\<Delta>_def)"], ["proof (state)\nthis:\n  l2 s \\<le> l1 s\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  l2 s \\<le> l1 s\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma unique_les:\n  fixes s S N and l1 l2 :: \"'a \\<Rightarrow> real\" and K :: \"'a \\<Rightarrow> 'a pmf\"\n  defines \"\\<Delta> x \\<equiv> l2 x - l1 x\"\n  assumes s: \"s \\<in> S\" and S: \"(\\<Union>s\\<in>S. set_pmf (K s)) \\<subseteq> S \\<union> N\"\n  assumes \"\\<And>s. s \\<in> S \\<Longrightarrow> integrable (K s) l1\"\n  assumes \"\\<And>s. s \\<in> S \\<Longrightarrow> integrable (K s) l2\"\n  assumes \"\\<And>s. s \\<in> S \\<Longrightarrow> \\<exists>t\\<in>N. (s, t) \\<in> (SIGMA s:UNIV. K s)\\<^sup>*\"\n  assumes \"\\<And>s. s \\<in> S \\<Longrightarrow> l1 s = (\\<integral>t. l1 t \\<partial>K s) + c s\"\n  assumes \"\\<And>s. s \\<in> S \\<Longrightarrow> l2 s = (\\<integral>t. l2 t \\<partial>K s) + c s\"\n  assumes \"\\<And>s. s \\<in> N \\<Longrightarrow> l2 s = l1 s\"\n  assumes 1: \"finite (\\<Delta> ` (S\\<union>N))\"\n  shows \"l2 s = l1 s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l2 s = l1 s", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. l2 s = l1 s", "have \"finite ((\\<lambda>x. l2 x - l1 x) ` (S\\<union>N))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite ((\\<lambda>x. l2 x - l1 x) ` (S \\<union> N))", "using 1"], ["proof (prove)\nusing this:\n  finite (\\<Delta> ` (S \\<union> N))\n\ngoal (1 subgoal):\n 1. finite ((\\<lambda>x. l2 x - l1 x) ` (S \\<union> N))", "by (auto simp: \\<Delta>_def[abs_def])"], ["proof (state)\nthis:\n  finite ((\\<lambda>x. l2 x - l1 x) ` (S \\<union> N))\n\ngoal (1 subgoal):\n 1. l2 s = l1 s", "moreover"], ["proof (state)\nthis:\n  finite ((\\<lambda>x. l2 x - l1 x) ` (S \\<union> N))\n\ngoal (1 subgoal):\n 1. l2 s = l1 s", "then"], ["proof (chain)\npicking this:\n  finite ((\\<lambda>x. l2 x - l1 x) ` (S \\<union> N))", "have \"finite (uminus ` (\\<lambda>x. l2 x - l1 x) ` (S\\<union>N))\""], ["proof (prove)\nusing this:\n  finite ((\\<lambda>x. l2 x - l1 x) ` (S \\<union> N))\n\ngoal (1 subgoal):\n 1. finite (uminus ` (\\<lambda>x. l2 x - l1 x) ` (S \\<union> N))", "by auto"], ["proof (state)\nthis:\n  finite (uminus ` (\\<lambda>x. l2 x - l1 x) ` (S \\<union> N))\n\ngoal (1 subgoal):\n 1. l2 s = l1 s", "ultimately"], ["proof (chain)\npicking this:\n  finite ((\\<lambda>x. l2 x - l1 x) ` (S \\<union> N))\n  finite (uminus ` (\\<lambda>x. l2 x - l1 x) ` (S \\<union> N))", "show ?thesis"], ["proof (prove)\nusing this:\n  finite ((\\<lambda>x. l2 x - l1 x) ` (S \\<union> N))\n  finite (uminus ` (\\<lambda>x. l2 x - l1 x) ` (S \\<union> N))\n\ngoal (1 subgoal):\n 1. l2 s = l1 s", "using assms"], ["proof (prove)\nusing this:\n  finite ((\\<lambda>x. l2 x - l1 x) ` (S \\<union> N))\n  finite (uminus ` (\\<lambda>x. l2 x - l1 x) ` (S \\<union> N))\n  \\<Delta> ?x \\<equiv> l2 ?x - l1 ?x\n  s \\<in> S\n  (\\<Union>s\\<in>S. set_pmf (K s)) \\<subseteq> S \\<union> N\n  ?s \\<in> S \\<Longrightarrow> integrable (measure_pmf (K ?s)) l1\n  ?s \\<in> S \\<Longrightarrow> integrable (measure_pmf (K ?s)) l2\n  ?s \\<in> S \\<Longrightarrow>\n  \\<exists>t\\<in>N. (?s, t) \\<in> (SIGMA x:UNIV. set_pmf (K x))\\<^sup>*\n  ?s \\<in> S \\<Longrightarrow>\n  l1 ?s = measure_pmf.expectation (K ?s) l1 + c ?s\n  ?s \\<in> S \\<Longrightarrow>\n  l2 ?s = measure_pmf.expectation (K ?s) l2 + c ?s\n  ?s \\<in> N \\<Longrightarrow> l2 ?s = l1 ?s\n  finite (\\<Delta> ` (S \\<union> N))\n\ngoal (1 subgoal):\n 1. l2 s = l1 s", "by (intro antisym mono_les[of s S K N l2 l1 c] mono_les[of s S K N l1 l2 c])\n       (auto simp: image_comp comp_def)"], ["proof (state)\nthis:\n  l2 s = l1 s\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma inf_continuous_suntil_disj[order_continuous_intros]:\n  assumes Q: \"inf_continuous Q\"\n  assumes disj: \"\\<And>x \\<omega>. \\<not> (P \\<omega> \\<and> Q x \\<omega>)\"\n  shows \"inf_continuous (\\<lambda>x. P suntil Q x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inf_continuous (\\<lambda>x. P suntil Q x)", "unfolding inf_continuous_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>M.\n       decseq M \\<longrightarrow>\n       P suntil Q (\\<Sqinter> range M) = (\\<Sqinter>i. P suntil Q (M i))", "proof (safe intro!: ext)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>M x i.\n       \\<lbrakk>decseq M; (P suntil Q (\\<Sqinter> range M)) x;\n        i \\<in> UNIV\\<rbrakk>\n       \\<Longrightarrow> (P suntil Q (M i)) x\n 2. \\<And>M x.\n       \\<lbrakk>decseq M; (\\<Sqinter>i. P suntil Q (M i)) x\\<rbrakk>\n       \\<Longrightarrow> (P suntil Q (\\<Sqinter> range M)) x", "fix M \\<omega> i"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>M x i.\n       \\<lbrakk>decseq M; (P suntil Q (\\<Sqinter> range M)) x;\n        i \\<in> UNIV\\<rbrakk>\n       \\<Longrightarrow> (P suntil Q (M i)) x\n 2. \\<And>M x.\n       \\<lbrakk>decseq M; (\\<Sqinter>i. P suntil Q (M i)) x\\<rbrakk>\n       \\<Longrightarrow> (P suntil Q (\\<Sqinter> range M)) x", "assume \"(P suntil Q (\\<Sqinter>i. M i)) \\<omega>\" \"decseq M\""], ["proof (state)\nthis:\n  (P suntil Q (\\<Sqinter> range M)) \\<omega>\n  decseq M\n\ngoal (2 subgoals):\n 1. \\<And>M x i.\n       \\<lbrakk>decseq M; (P suntil Q (\\<Sqinter> range M)) x;\n        i \\<in> UNIV\\<rbrakk>\n       \\<Longrightarrow> (P suntil Q (M i)) x\n 2. \\<And>M x.\n       \\<lbrakk>decseq M; (\\<Sqinter>i. P suntil Q (M i)) x\\<rbrakk>\n       \\<Longrightarrow> (P suntil Q (\\<Sqinter> range M)) x", "then"], ["proof (chain)\npicking this:\n  (P suntil Q (\\<Sqinter> range M)) \\<omega>\n  decseq M", "show \"(P suntil Q (M i)) \\<omega>\""], ["proof (prove)\nusing this:\n  (P suntil Q (\\<Sqinter> range M)) \\<omega>\n  decseq M\n\ngoal (1 subgoal):\n 1. (P suntil Q (M i)) \\<omega>", "unfolding inf_continuousD[OF Q \\<open>decseq M\\<close>]"], ["proof (prove)\nusing this:\n  (P suntil (\\<Sqinter>i. Q (M i))) \\<omega>\n  decseq M\n\ngoal (1 subgoal):\n 1. (P suntil Q (M i)) \\<omega>", "by induction (auto intro: suntil.intros)"], ["proof (state)\nthis:\n  (P suntil Q (M i)) \\<omega>\n\ngoal (1 subgoal):\n 1. \\<And>M x.\n       \\<lbrakk>decseq M; (\\<Sqinter>i. P suntil Q (M i)) x\\<rbrakk>\n       \\<Longrightarrow> (P suntil Q (\\<Sqinter> range M)) x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>M x.\n       \\<lbrakk>decseq M; (\\<Sqinter>i. P suntil Q (M i)) x\\<rbrakk>\n       \\<Longrightarrow> (P suntil Q (\\<Sqinter> range M)) x", "fix M \\<omega>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>M x.\n       \\<lbrakk>decseq M; (\\<Sqinter>i. P suntil Q (M i)) x\\<rbrakk>\n       \\<Longrightarrow> (P suntil Q (\\<Sqinter> range M)) x", "assume *: \"(\\<Sqinter>i. P suntil Q (M i)) \\<omega>\" \"decseq M\""], ["proof (state)\nthis:\n  (\\<Sqinter>i. P suntil Q (M i)) \\<omega>\n  decseq M\n\ngoal (1 subgoal):\n 1. \\<And>M x.\n       \\<lbrakk>decseq M; (\\<Sqinter>i. P suntil Q (M i)) x\\<rbrakk>\n       \\<Longrightarrow> (P suntil Q (\\<Sqinter> range M)) x", "then"], ["proof (chain)\npicking this:\n  (\\<Sqinter>i. P suntil Q (M i)) \\<omega>\n  decseq M", "have \"(P suntil Q (M 0)) \\<omega>\""], ["proof (prove)\nusing this:\n  (\\<Sqinter>i. P suntil Q (M i)) \\<omega>\n  decseq M\n\ngoal (1 subgoal):\n 1. (P suntil Q (M 0)) \\<omega>", "by auto"], ["proof (state)\nthis:\n  (P suntil Q (M 0)) \\<omega>\n\ngoal (1 subgoal):\n 1. \\<And>M x.\n       \\<lbrakk>decseq M; (\\<Sqinter>i. P suntil Q (M i)) x\\<rbrakk>\n       \\<Longrightarrow> (P suntil Q (\\<Sqinter> range M)) x", "from this *"], ["proof (chain)\npicking this:\n  (P suntil Q (M 0)) \\<omega>\n  (\\<Sqinter>i. P suntil Q (M i)) \\<omega>\n  decseq M", "show \"(P suntil Q (\\<Sqinter>i. M i)) \\<omega>\""], ["proof (prove)\nusing this:\n  (P suntil Q (M 0)) \\<omega>\n  (\\<Sqinter>i. P suntil Q (M i)) \\<omega>\n  decseq M\n\ngoal (1 subgoal):\n 1. (P suntil Q (\\<Sqinter> range M)) \\<omega>", "unfolding inf_continuousD[OF Q \\<open>decseq M\\<close>]"], ["proof (prove)\nusing this:\n  (P suntil Q (M 0)) \\<omega>\n  (\\<Sqinter>i. P suntil Q (M i)) \\<omega>\n  decseq M\n\ngoal (1 subgoal):\n 1. (P suntil (\\<Sqinter>i. Q (M i))) \\<omega>", "proof induction"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>\\<omega>.\n       \\<lbrakk>Q (M 0) \\<omega>; (\\<Sqinter>i. P suntil Q (M i)) \\<omega>;\n        decseq M\\<rbrakk>\n       \\<Longrightarrow> (P suntil (\\<Sqinter>i. Q (M i))) \\<omega>\n 2. \\<And>\\<omega>.\n       \\<lbrakk>P \\<omega>; (P suntil Q (M 0)) (stl \\<omega>);\n        \\<lbrakk>(\\<Sqinter>i. P suntil Q (M i)) (stl \\<omega>);\n         decseq M\\<rbrakk>\n        \\<Longrightarrow> (P suntil (\\<Sqinter>i. Q (M i))) (stl \\<omega>);\n        (\\<Sqinter>i. P suntil Q (M i)) \\<omega>; decseq M\\<rbrakk>\n       \\<Longrightarrow> (P suntil (\\<Sqinter>i. Q (M i))) \\<omega>", "case (base \\<omega>)"], ["proof (state)\nthis:\n  Q (M 0) \\<omega>\n  (\\<Sqinter>i. P suntil Q (M i)) \\<omega>\n  decseq M\n\ngoal (2 subgoals):\n 1. \\<And>\\<omega>.\n       \\<lbrakk>Q (M 0) \\<omega>; (\\<Sqinter>i. P suntil Q (M i)) \\<omega>;\n        decseq M\\<rbrakk>\n       \\<Longrightarrow> (P suntil (\\<Sqinter>i. Q (M i))) \\<omega>\n 2. \\<And>\\<omega>.\n       \\<lbrakk>P \\<omega>; (P suntil Q (M 0)) (stl \\<omega>);\n        \\<lbrakk>(\\<Sqinter>i. P suntil Q (M i)) (stl \\<omega>);\n         decseq M\\<rbrakk>\n        \\<Longrightarrow> (P suntil (\\<Sqinter>i. Q (M i))) (stl \\<omega>);\n        (\\<Sqinter>i. P suntil Q (M i)) \\<omega>; decseq M\\<rbrakk>\n       \\<Longrightarrow> (P suntil (\\<Sqinter>i. Q (M i))) \\<omega>", "with disj[of \\<omega> \"M _\"]"], ["proof (chain)\npicking this:\n  \\<not> (P \\<omega> \\<and> Q (M ?uu3) \\<omega>)\n  Q (M 0) \\<omega>\n  (\\<Sqinter>i. P suntil Q (M i)) \\<omega>\n  decseq M", "show ?case"], ["proof (prove)\nusing this:\n  \\<not> (P \\<omega> \\<and> Q (M ?uu3) \\<omega>)\n  Q (M 0) \\<omega>\n  (\\<Sqinter>i. P suntil Q (M i)) \\<omega>\n  decseq M\n\ngoal (1 subgoal):\n 1. (P suntil (\\<Sqinter>i. Q (M i))) \\<omega>", "by (auto intro: suntil.intros elim: suntil.cases)"], ["proof (state)\nthis:\n  (P suntil (\\<Sqinter>i. Q (M i))) \\<omega>\n\ngoal (1 subgoal):\n 1. \\<And>\\<omega>.\n       \\<lbrakk>P \\<omega>; (P suntil Q (M 0)) (stl \\<omega>);\n        \\<lbrakk>(\\<Sqinter>i. P suntil Q (M i)) (stl \\<omega>);\n         decseq M\\<rbrakk>\n        \\<Longrightarrow> (P suntil (\\<Sqinter>i. Q (M i))) (stl \\<omega>);\n        (\\<Sqinter>i. P suntil Q (M i)) \\<omega>; decseq M\\<rbrakk>\n       \\<Longrightarrow> (P suntil (\\<Sqinter>i. Q (M i))) \\<omega>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<omega>.\n       \\<lbrakk>P \\<omega>; (P suntil Q (M 0)) (stl \\<omega>);\n        \\<lbrakk>(\\<Sqinter>i. P suntil Q (M i)) (stl \\<omega>);\n         decseq M\\<rbrakk>\n        \\<Longrightarrow> (P suntil (\\<Sqinter>i. Q (M i))) (stl \\<omega>);\n        (\\<Sqinter>i. P suntil Q (M i)) \\<omega>; decseq M\\<rbrakk>\n       \\<Longrightarrow> (P suntil (\\<Sqinter>i. Q (M i))) \\<omega>", "case (step \\<omega>)"], ["proof (state)\nthis:\n  P \\<omega>\n  (P suntil Q (M 0)) (stl \\<omega>)\n  \\<lbrakk>(\\<Sqinter>i. P suntil Q (M i)) (stl \\<omega>); decseq M\\<rbrakk>\n  \\<Longrightarrow> (P suntil (\\<Sqinter>i. Q (M i))) (stl \\<omega>)\n  (\\<Sqinter>i. P suntil Q (M i)) \\<omega>\n  decseq M\n\ngoal (1 subgoal):\n 1. \\<And>\\<omega>.\n       \\<lbrakk>P \\<omega>; (P suntil Q (M 0)) (stl \\<omega>);\n        \\<lbrakk>(\\<Sqinter>i. P suntil Q (M i)) (stl \\<omega>);\n         decseq M\\<rbrakk>\n        \\<Longrightarrow> (P suntil (\\<Sqinter>i. Q (M i))) (stl \\<omega>);\n        (\\<Sqinter>i. P suntil Q (M i)) \\<omega>; decseq M\\<rbrakk>\n       \\<Longrightarrow> (P suntil (\\<Sqinter>i. Q (M i))) \\<omega>", "with disj[of \\<omega> \"M _\"]"], ["proof (chain)\npicking this:\n  \\<not> (P \\<omega> \\<and> Q (M ?uu3) \\<omega>)\n  P \\<omega>\n  (P suntil Q (M 0)) (stl \\<omega>)\n  \\<lbrakk>(\\<Sqinter>i. P suntil Q (M i)) (stl \\<omega>); decseq M\\<rbrakk>\n  \\<Longrightarrow> (P suntil (\\<Sqinter>i. Q (M i))) (stl \\<omega>)\n  (\\<Sqinter>i. P suntil Q (M i)) \\<omega>\n  decseq M", "show ?case"], ["proof (prove)\nusing this:\n  \\<not> (P \\<omega> \\<and> Q (M ?uu3) \\<omega>)\n  P \\<omega>\n  (P suntil Q (M 0)) (stl \\<omega>)\n  \\<lbrakk>(\\<Sqinter>i. P suntil Q (M i)) (stl \\<omega>); decseq M\\<rbrakk>\n  \\<Longrightarrow> (P suntil (\\<Sqinter>i. Q (M i))) (stl \\<omega>)\n  (\\<Sqinter>i. P suntil Q (M i)) \\<omega>\n  decseq M\n\ngoal (1 subgoal):\n 1. (P suntil (\\<Sqinter>i. Q (M i))) \\<omega>", "by (auto intro: suntil.intros elim: suntil.cases)"], ["proof (state)\nthis:\n  (P suntil (\\<Sqinter>i. Q (M i))) \\<omega>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (P suntil Q (\\<Sqinter> range M)) \\<omega>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma inf_continuous_nxt[order_continuous_intros]: \"inf_continuous P \\<Longrightarrow> inf_continuous (\\<lambda>x. nxt (P x) \\<omega>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inf_continuous P \\<Longrightarrow>\n    inf_continuous (\\<lambda>x. nxt (P x) \\<omega>)", "by (auto simp: inf_continuous_def image_comp)"], ["", "lemma sup_continuous_nxt[order_continuous_intros]: \"sup_continuous P \\<Longrightarrow> sup_continuous (\\<lambda>x. nxt (P x) \\<omega>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sup_continuous P \\<Longrightarrow>\n    sup_continuous (\\<lambda>x. nxt (P x) \\<omega>)", "by (auto simp: sup_continuous_def image_comp)"], ["", "lemma mcont_ennreal_of_enat: \"mcont Sup (\\<le>) Sup (\\<le>) ennreal_of_enat\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mcont Sup (\\<le>) Sup (\\<le>) ennreal_of_enat", "by (auto intro!: mcontI monotoneI contI ennreal_of_enat_Sup)"], ["", "lemma mcont2mcont_ennreal_of_enat[cont_intro]:\n  \"mcont lub ord Sup (\\<le>) f \\<Longrightarrow> mcont lub ord Sup (\\<le>) (\\<lambda>x. ennreal_of_enat (f x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mcont lub ord Sup (\\<le>) f \\<Longrightarrow>\n    mcont lub ord Sup (\\<le>) (\\<lambda>x. ennreal_of_enat (f x))", "by (auto intro: ccpo.mcont2mcont[OF complete_lattice_ccpo'] mcont_ennreal_of_enat)"], ["", "declare stream.exhaust[cases type: stream]"], ["", "lemma scount_eq_emeasure: \"scount P \\<omega> = emeasure (count_space UNIV) {i. P (sdrop i \\<omega>)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ennreal_of_enat (scount P \\<omega>) =\n    emeasure (count_space UNIV) {i. P (sdrop i \\<omega>)}", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    ennreal_of_enat (scount P \\<omega>) =\n    emeasure (count_space UNIV) {i. P (sdrop i \\<omega>)}\n 2. \\<not> ?P \\<Longrightarrow>\n    ennreal_of_enat (scount P \\<omega>) =\n    emeasure (count_space UNIV) {i. P (sdrop i \\<omega>)}", "assume \"alw (ev P) \\<omega>\""], ["proof (state)\nthis:\n  alw (ev P) \\<omega>\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    ennreal_of_enat (scount P \\<omega>) =\n    emeasure (count_space UNIV) {i. P (sdrop i \\<omega>)}\n 2. \\<not> ?P \\<Longrightarrow>\n    ennreal_of_enat (scount P \\<omega>) =\n    emeasure (count_space UNIV) {i. P (sdrop i \\<omega>)}", "moreover"], ["proof (state)\nthis:\n  alw (ev P) \\<omega>\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    ennreal_of_enat (scount P \\<omega>) =\n    emeasure (count_space UNIV) {i. P (sdrop i \\<omega>)}\n 2. \\<not> ?P \\<Longrightarrow>\n    ennreal_of_enat (scount P \\<omega>) =\n    emeasure (count_space UNIV) {i. P (sdrop i \\<omega>)}", "then"], ["proof (chain)\npicking this:\n  alw (ev P) \\<omega>", "have \"infinite {i. P (sdrop i \\<omega>)}\""], ["proof (prove)\nusing this:\n  alw (ev P) \\<omega>\n\ngoal (1 subgoal):\n 1. infinite {i. P (sdrop i \\<omega>)}", "using infinite_iff_alw_ev[of P \\<omega>]"], ["proof (prove)\nusing this:\n  alw (ev P) \\<omega>\n  infinite {m. P (sdrop m \\<omega>)} = alw (ev P) \\<omega>\n\ngoal (1 subgoal):\n 1. infinite {i. P (sdrop i \\<omega>)}", "by simp"], ["proof (state)\nthis:\n  infinite {i. P (sdrop i \\<omega>)}\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    ennreal_of_enat (scount P \\<omega>) =\n    emeasure (count_space UNIV) {i. P (sdrop i \\<omega>)}\n 2. \\<not> ?P \\<Longrightarrow>\n    ennreal_of_enat (scount P \\<omega>) =\n    emeasure (count_space UNIV) {i. P (sdrop i \\<omega>)}", "ultimately"], ["proof (chain)\npicking this:\n  alw (ev P) \\<omega>\n  infinite {i. P (sdrop i \\<omega>)}", "show ?thesis"], ["proof (prove)\nusing this:\n  alw (ev P) \\<omega>\n  infinite {i. P (sdrop i \\<omega>)}\n\ngoal (1 subgoal):\n 1. ennreal_of_enat (scount P \\<omega>) =\n    emeasure (count_space UNIV) {i. P (sdrop i \\<omega>)}", "by (simp add: scount_infinite_iff[symmetric])"], ["proof (state)\nthis:\n  ennreal_of_enat (scount P \\<omega>) =\n  emeasure (count_space UNIV) {i. P (sdrop i \\<omega>)}\n\ngoal (1 subgoal):\n 1. \\<not> alw (ev P) \\<omega> \\<Longrightarrow>\n    ennreal_of_enat (scount P \\<omega>) =\n    emeasure (count_space UNIV) {i. P (sdrop i \\<omega>)}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> alw (ev P) \\<omega> \\<Longrightarrow>\n    ennreal_of_enat (scount P \\<omega>) =\n    emeasure (count_space UNIV) {i. P (sdrop i \\<omega>)}", "assume \"\\<not> alw (ev P) \\<omega>\""], ["proof (state)\nthis:\n  \\<not> alw (ev P) \\<omega>\n\ngoal (1 subgoal):\n 1. \\<not> alw (ev P) \\<omega> \\<Longrightarrow>\n    ennreal_of_enat (scount P \\<omega>) =\n    emeasure (count_space UNIV) {i. P (sdrop i \\<omega>)}", "moreover"], ["proof (state)\nthis:\n  \\<not> alw (ev P) \\<omega>\n\ngoal (1 subgoal):\n 1. \\<not> alw (ev P) \\<omega> \\<Longrightarrow>\n    ennreal_of_enat (scount P \\<omega>) =\n    emeasure (count_space UNIV) {i. P (sdrop i \\<omega>)}", "then"], ["proof (chain)\npicking this:\n  \\<not> alw (ev P) \\<omega>", "have \"finite {i. P (sdrop i \\<omega>)}\""], ["proof (prove)\nusing this:\n  \\<not> alw (ev P) \\<omega>\n\ngoal (1 subgoal):\n 1. finite {i. P (sdrop i \\<omega>)}", "using infinite_iff_alw_ev[of P \\<omega>]"], ["proof (prove)\nusing this:\n  \\<not> alw (ev P) \\<omega>\n  infinite {m. P (sdrop m \\<omega>)} = alw (ev P) \\<omega>\n\ngoal (1 subgoal):\n 1. finite {i. P (sdrop i \\<omega>)}", "by simp"], ["proof (state)\nthis:\n  finite {i. P (sdrop i \\<omega>)}\n\ngoal (1 subgoal):\n 1. \\<not> alw (ev P) \\<omega> \\<Longrightarrow>\n    ennreal_of_enat (scount P \\<omega>) =\n    emeasure (count_space UNIV) {i. P (sdrop i \\<omega>)}", "ultimately"], ["proof (chain)\npicking this:\n  \\<not> alw (ev P) \\<omega>\n  finite {i. P (sdrop i \\<omega>)}", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> alw (ev P) \\<omega>\n  finite {i. P (sdrop i \\<omega>)}\n\ngoal (1 subgoal):\n 1. ennreal_of_enat (scount P \\<omega>) =\n    emeasure (count_space UNIV) {i. P (sdrop i \\<omega>)}", "by (simp add: not_alw_iff not_ev_iff scount_eq_card)"], ["proof (state)\nthis:\n  ennreal_of_enat (scount P \\<omega>) =\n  emeasure (count_space UNIV) {i. P (sdrop i \\<omega>)}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma measurable_scount[measurable]:\n  assumes [measurable]: \"Measurable.pred (stream_space M) P\"\n  shows \"scount P \\<in> measurable (stream_space M) (count_space UNIV)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. scount P \\<in> stream_space M \\<rightarrow>\\<^sub>M count_space UNIV", "unfolding scount_eq[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>\\<omega>.\n        if alw (ev P) \\<omega> then \\<infinity>\n        else enat (card {i. P (sdrop i \\<omega>)}))\n    \\<in> stream_space M \\<rightarrow>\\<^sub>M count_space UNIV", "by measurable"], ["", "lemma measurable_sfirst2:\n  assumes [measurable]: \"Measurable.pred (N \\<Otimes>\\<^sub>M stream_space M) (\\<lambda>(x, \\<omega>). P x \\<omega>)\"\n  shows \"(\\<lambda>(x, \\<omega>). sfirst (P x) \\<omega>) \\<in> measurable (N \\<Otimes>\\<^sub>M  stream_space M) (count_space UNIV)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>(x, \\<omega>). sfirst (P x) \\<omega>)\n    \\<in> N \\<Otimes>\\<^sub>M stream_space M \\<rightarrow>\\<^sub>M\n          count_space UNIV", "apply (coinduction rule: measurable_enat_coinduct)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>g h i Pa.\n       g = (\\<lambda>(x, y). sfirst (P x) y) \\<and>\n       (\\<lambda>(x, y). sfirst (P x) y) =\n       (\\<lambda>x. if Pa x then h x else eSuc (g (i x))) \\<and>\n       Measurable.pred (N \\<Otimes>\\<^sub>M stream_space M) Pa \\<and>\n       i \\<in> N \\<Otimes>\\<^sub>M stream_space M \\<rightarrow>\\<^sub>M\n               N \\<Otimes>\\<^sub>M stream_space M \\<and>\n       h \\<in> N \\<Otimes>\\<^sub>M stream_space M \\<rightarrow>\\<^sub>M\n               count_space UNIV", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>h i Pa.\n       (\\<lambda>(x, y). sfirst (P x) y) =\n       (\\<lambda>x.\n           if Pa x then h x\n           else eSuc\n                 (case i x of (x, xa) \\<Rightarrow> sfirst (P x) xa)) \\<and>\n       Measurable.pred (N \\<Otimes>\\<^sub>M stream_space M) Pa \\<and>\n       i \\<in> N \\<Otimes>\\<^sub>M stream_space M \\<rightarrow>\\<^sub>M\n               N \\<Otimes>\\<^sub>M stream_space M \\<and>\n       h \\<in> N \\<Otimes>\\<^sub>M stream_space M \\<rightarrow>\\<^sub>M\n               count_space UNIV", "apply (rule exI[of _ \"\\<lambda>x. 0\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>i Pa.\n       (\\<lambda>(x, y). sfirst (P x) y) =\n       (\\<lambda>x.\n           if Pa x then 0\n           else eSuc\n                 (case i x of (x, xa) \\<Rightarrow> sfirst (P x) xa)) \\<and>\n       Measurable.pred (N \\<Otimes>\\<^sub>M stream_space M) Pa \\<and>\n       i \\<in> N \\<Otimes>\\<^sub>M stream_space M \\<rightarrow>\\<^sub>M\n               N \\<Otimes>\\<^sub>M stream_space M \\<and>\n       (\\<lambda>h. 0)\n       \\<in> N \\<Otimes>\\<^sub>M stream_space M \\<rightarrow>\\<^sub>M\n             count_space UNIV", "apply (rule exI[of _ \"\\<lambda>(x, \\<omega>). (x, stl \\<omega>)\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>Pa.\n       (\\<lambda>(x, y). sfirst (P x) y) =\n       (\\<lambda>x.\n           if Pa x then 0\n           else eSuc\n                 (case case x of\n                       (i, \\<omega>) \\<Rightarrow> (i, stl \\<omega>) of\n                  (x, xa) \\<Rightarrow> sfirst (P x) xa)) \\<and>\n       Measurable.pred (N \\<Otimes>\\<^sub>M stream_space M) Pa \\<and>\n       (\\<lambda>(i, \\<omega>). (i, stl \\<omega>))\n       \\<in> N \\<Otimes>\\<^sub>M stream_space M \\<rightarrow>\\<^sub>M\n             N \\<Otimes>\\<^sub>M stream_space M \\<and>\n       (\\<lambda>h. 0)\n       \\<in> N \\<Otimes>\\<^sub>M stream_space M \\<rightarrow>\\<^sub>M\n             count_space UNIV", "apply (rule exI[of _ \"\\<lambda>(x, \\<omega>). P x \\<omega>\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>(x, y). sfirst (P x) y) =\n    (\\<lambda>x.\n        if case x of (Pa, \\<omega>) \\<Rightarrow> P Pa \\<omega> then 0\n        else eSuc\n              (case case x of\n                    (i, \\<omega>) \\<Rightarrow> (i, stl \\<omega>) of\n               (x, xa) \\<Rightarrow> sfirst (P x) xa)) \\<and>\n    Measurable.pred (N \\<Otimes>\\<^sub>M stream_space M)\n     (\\<lambda>(Pa, \\<omega>). P Pa \\<omega>) \\<and>\n    (\\<lambda>(i, \\<omega>). (i, stl \\<omega>))\n    \\<in> N \\<Otimes>\\<^sub>M stream_space M \\<rightarrow>\\<^sub>M\n          N \\<Otimes>\\<^sub>M stream_space M \\<and>\n    (\\<lambda>h. 0)\n    \\<in> N \\<Otimes>\\<^sub>M stream_space M \\<rightarrow>\\<^sub>M\n          count_space UNIV", "apply (subst sfirst.simps[abs_def])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>(x, \\<omega>).\n        if P x \\<omega> then 0 else eSuc (sfirst (P x) (stl \\<omega>))) =\n    (\\<lambda>x.\n        if case x of (x, xa) \\<Rightarrow> P x xa then 0\n        else eSuc\n              (case case x of\n                    (i, \\<omega>) \\<Rightarrow> (i, stl \\<omega>) of\n               (x, xa) \\<Rightarrow> sfirst (P x) xa)) \\<and>\n    Measurable.pred (N \\<Otimes>\\<^sub>M stream_space M)\n     (\\<lambda>(x, y). P x y) \\<and>\n    (\\<lambda>(i, \\<omega>). (i, stl \\<omega>))\n    \\<in> N \\<Otimes>\\<^sub>M stream_space M \\<rightarrow>\\<^sub>M\n          N \\<Otimes>\\<^sub>M stream_space M \\<and>\n    (\\<lambda>h. 0)\n    \\<in> N \\<Otimes>\\<^sub>M stream_space M \\<rightarrow>\\<^sub>M\n          count_space UNIV", "apply (simp add: fun_eq_iff)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma measurable_sfirst2'[measurable (raw)]:\n  assumes [measurable (raw)]: \"f \\<in> N \\<rightarrow>\\<^sub>M stream_space M\" \"Measurable.pred (N \\<Otimes>\\<^sub>M stream_space M) (\\<lambda>x. P (fst x) (snd x))\"\n  shows \"(\\<lambda>x. sfirst (P x) (f x)) \\<in> measurable N (count_space UNIV)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. sfirst (P x) (f x))\n    \\<in> N \\<rightarrow>\\<^sub>M count_space UNIV", "using measurable_sfirst2[measurable]"], ["proof (prove)\nusing this:\n  Measurable.pred (?N \\<Otimes>\\<^sub>M stream_space ?M)\n   (\\<lambda>(x, \\<omega>). ?P x \\<omega>) \\<Longrightarrow>\n  (\\<lambda>(x, \\<omega>). sfirst (?P x) \\<omega>)\n  \\<in> ?N \\<Otimes>\\<^sub>M stream_space ?M \\<rightarrow>\\<^sub>M\n        count_space UNIV\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. sfirst (P x) (f x))\n    \\<in> N \\<rightarrow>\\<^sub>M count_space UNIV", "by measurable"], ["", "lemma measurable_sfirst[measurable]:\n  assumes [measurable]: \"Measurable.pred (stream_space M) P\"\n  shows \"sfirst P \\<in> measurable (stream_space M) (count_space UNIV)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sfirst P \\<in> stream_space M \\<rightarrow>\\<^sub>M count_space UNIV", "by measurable"], ["", "lemma measurable_epred[measurable]: \"epred \\<in> count_space UNIV \\<rightarrow>\\<^sub>M count_space UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. epred \\<in> count_space UNIV \\<rightarrow>\\<^sub>M count_space UNIV", "by (rule measurable_count_space)"], ["", "lemma nn_integral_stretch:\n  \"f \\<in> borel \\<rightarrow>\\<^sub>M borel \\<Longrightarrow> c \\<noteq> 0 \\<Longrightarrow> (\\<integral>\\<^sup>+x. f (c * x) \\<partial>lborel) = (1 / \\<bar>c\\<bar>::real) * (\\<integral>\\<^sup>+x. f x \\<partial>lborel)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>f \\<in> borel_measurable borel; c \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> \\<integral>\\<^sup>+ x. f (c * x) \\<partial>lborel =\n                      ennreal (1 / \\<bar>c\\<bar>) *\n                      integral\\<^sup>N lborel f", "using nn_integral_real_affine[of f c 0]"], ["proof (prove)\nusing this:\n  \\<lbrakk>f \\<in> borel_measurable borel; c \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> integral\\<^sup>N lborel f =\n                    ennreal \\<bar>c\\<bar> *\n                    \\<integral>\\<^sup>+ x. f (0 + c * x) \\<partial>lborel\n\ngoal (1 subgoal):\n 1. \\<lbrakk>f \\<in> borel_measurable borel; c \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> \\<integral>\\<^sup>+ x. f (c * x) \\<partial>lborel =\n                      ennreal (1 / \\<bar>c\\<bar>) *\n                      integral\\<^sup>N lborel f", "by (simp add: mult.assoc[symmetric] ennreal_mult[symmetric])"], ["", "lemma prod_sum_distrib:\n  fixes f g :: \"'a \\<Rightarrow> 'b \\<Rightarrow> 'c::comm_semiring_1\"\n  assumes \"finite I\" shows \"(\\<And>i. i \\<in> I \\<Longrightarrow> finite (J i)) \\<Longrightarrow> (\\<Prod>i\\<in>I. \\<Sum>j\\<in>J i. f i j) = (\\<Sum>m\\<in>Pi\\<^sub>E I J. \\<Prod>i\\<in>I. f i (m i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>i. i \\<in> I \\<Longrightarrow> finite (J i)) \\<Longrightarrow>\n    (\\<Prod>i\\<in>I. sum (f i) (J i)) =\n    (\\<Sum>m\\<in>Pi\\<^sub>E I J. \\<Prod>i\\<in>I. f i (m i))", "using \\<open>finite I\\<close>"], ["proof (prove)\nusing this:\n  finite I\n\ngoal (1 subgoal):\n 1. (\\<And>i. i \\<in> I \\<Longrightarrow> finite (J i)) \\<Longrightarrow>\n    (\\<Prod>i\\<in>I. sum (f i) (J i)) =\n    (\\<Sum>m\\<in>Pi\\<^sub>E I J. \\<Prod>i\\<in>I. f i (m i))", "proof induction"], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<And>i. i \\<in> {} \\<Longrightarrow> finite (J i)) \\<Longrightarrow>\n    (\\<Prod>i\\<in>{}. sum (f i) (J i)) =\n    (\\<Sum>m\\<in>Pi\\<^sub>E {} J. \\<Prod>i\\<in>{}. f i (m i))\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        (\\<And>i.\n            i \\<in> F \\<Longrightarrow> finite (J i)) \\<Longrightarrow>\n        (\\<Prod>i\\<in>F. sum (f i) (J i)) =\n        (\\<Sum>m\\<in>Pi\\<^sub>E F J. \\<Prod>i\\<in>F. f i (m i));\n        \\<And>i. i \\<in> insert x F \\<Longrightarrow> finite (J i)\\<rbrakk>\n       \\<Longrightarrow> (\\<Prod>i\\<in>insert x F. sum (f i) (J i)) =\n                         (\\<Sum>m\\<in>Pi\\<^sub>E (insert x F) J.\n                            \\<Prod>i\\<in>insert x F. f i (m i))", "case (insert i I)"], ["proof (state)\nthis:\n  finite I\n  i \\<notin> I\n  (\\<And>i. i \\<in> I \\<Longrightarrow> finite (J i)) \\<Longrightarrow>\n  (\\<Prod>i\\<in>I. sum (f i) (J i)) =\n  (\\<Sum>m\\<in>Pi\\<^sub>E I J. \\<Prod>i\\<in>I. f i (m i))\n  ?i \\<in> insert i I \\<Longrightarrow> finite (J ?i)\n\ngoal (2 subgoals):\n 1. (\\<And>i. i \\<in> {} \\<Longrightarrow> finite (J i)) \\<Longrightarrow>\n    (\\<Prod>i\\<in>{}. sum (f i) (J i)) =\n    (\\<Sum>m\\<in>Pi\\<^sub>E {} J. \\<Prod>i\\<in>{}. f i (m i))\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        (\\<And>i.\n            i \\<in> F \\<Longrightarrow> finite (J i)) \\<Longrightarrow>\n        (\\<Prod>i\\<in>F. sum (f i) (J i)) =\n        (\\<Sum>m\\<in>Pi\\<^sub>E F J. \\<Prod>i\\<in>F. f i (m i));\n        \\<And>i. i \\<in> insert x F \\<Longrightarrow> finite (J i)\\<rbrakk>\n       \\<Longrightarrow> (\\<Prod>i\\<in>insert x F. sum (f i) (J i)) =\n                         (\\<Sum>m\\<in>Pi\\<^sub>E (insert x F) J.\n                            \\<Prod>i\\<in>insert x F. f i (m i))", "then"], ["proof (chain)\npicking this:\n  finite I\n  i \\<notin> I\n  (\\<And>i. i \\<in> I \\<Longrightarrow> finite (J i)) \\<Longrightarrow>\n  (\\<Prod>i\\<in>I. sum (f i) (J i)) =\n  (\\<Sum>m\\<in>Pi\\<^sub>E I J. \\<Prod>i\\<in>I. f i (m i))\n  ?i \\<in> insert i I \\<Longrightarrow> finite (J ?i)", "show ?case"], ["proof (prove)\nusing this:\n  finite I\n  i \\<notin> I\n  (\\<And>i. i \\<in> I \\<Longrightarrow> finite (J i)) \\<Longrightarrow>\n  (\\<Prod>i\\<in>I. sum (f i) (J i)) =\n  (\\<Sum>m\\<in>Pi\\<^sub>E I J. \\<Prod>i\\<in>I. f i (m i))\n  ?i \\<in> insert i I \\<Longrightarrow> finite (J ?i)\n\ngoal (1 subgoal):\n 1. (\\<Prod>i\\<in>insert i I. sum (f i) (J i)) =\n    (\\<Sum>m\\<in>Pi\\<^sub>E (insert i I) J.\n       \\<Prod>i\\<in>insert i I. f i (m i))", "by (auto simp: PiE_insert_eq finite_PiE sum.reindex inj_combinator sum.swap[of _ \"Pi\\<^sub>E I J\"]\n                   sum_cartesian_product' sum_distrib_left sum_distrib_right\n             intro!: sum.cong prod.cong arg_cong[where f=\"(*) x\" for x])"], ["proof (state)\nthis:\n  (\\<Prod>i\\<in>insert i I. sum (f i) (J i)) =\n  (\\<Sum>m\\<in>Pi\\<^sub>E (insert i I) J.\n     \\<Prod>i\\<in>insert i I. f i (m i))\n\ngoal (1 subgoal):\n 1. (\\<And>i. i \\<in> {} \\<Longrightarrow> finite (J i)) \\<Longrightarrow>\n    (\\<Prod>i\\<in>{}. sum (f i) (J i)) =\n    (\\<Sum>m\\<in>Pi\\<^sub>E {} J. \\<Prod>i\\<in>{}. f i (m i))", "qed simp"], ["", "lemma prod_add_distrib:\n  fixes f g :: \"'a \\<Rightarrow> 'b::comm_semiring_1\"\n  assumes \"finite I\" shows \"(\\<Prod>i\\<in>I. f i + g i) = (\\<Sum>J\\<in>Pow I. (\\<Prod>i\\<in>J. f i) * (\\<Prod>i\\<in>I - J. g i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>i\\<in>I. f i + g i) =\n    (\\<Sum>J\\<in>Pow I. prod f J * prod g (I - J))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Prod>i\\<in>I. f i + g i) =\n    (\\<Sum>J\\<in>Pow I. prod f J * prod g (I - J))", "have \"(\\<Prod>i\\<in>I. f i + g i) = (\\<Prod>i\\<in>I. \\<Sum>b\\<in>{True, False}. if b then f i else g i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>i\\<in>I. f i + g i) =\n    (\\<Prod>i\\<in>I. \\<Sum>b\\<in>{True, False}. if b then f i else g i)", "by simp"], ["proof (state)\nthis:\n  (\\<Prod>i\\<in>I. f i + g i) =\n  (\\<Prod>i\\<in>I. \\<Sum>b\\<in>{True, False}. if b then f i else g i)\n\ngoal (1 subgoal):\n 1. (\\<Prod>i\\<in>I. f i + g i) =\n    (\\<Sum>J\\<in>Pow I. prod f J * prod g (I - J))", "also"], ["proof (state)\nthis:\n  (\\<Prod>i\\<in>I. f i + g i) =\n  (\\<Prod>i\\<in>I. \\<Sum>b\\<in>{True, False}. if b then f i else g i)\n\ngoal (1 subgoal):\n 1. (\\<Prod>i\\<in>I. f i + g i) =\n    (\\<Sum>J\\<in>Pow I. prod f J * prod g (I - J))", "have \"\\<dots> = (\\<Sum>m\\<in>I \\<rightarrow>\\<^sub>E {True, False}. \\<Prod>i\\<in>I. if m i then f i else g i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>i\\<in>I. \\<Sum>b\\<in>{True, False}. if b then f i else g i) =\n    (\\<Sum>m\\<in>I \\<rightarrow>\\<^sub>E {True, False}.\n       \\<Prod>i\\<in>I. if m i then f i else g i)", "using \\<open>finite I\\<close>"], ["proof (prove)\nusing this:\n  finite I\n\ngoal (1 subgoal):\n 1. (\\<Prod>i\\<in>I. \\<Sum>b\\<in>{True, False}. if b then f i else g i) =\n    (\\<Sum>m\\<in>I \\<rightarrow>\\<^sub>E {True, False}.\n       \\<Prod>i\\<in>I. if m i then f i else g i)", "by (rule prod_sum_distrib) simp"], ["proof (state)\nthis:\n  (\\<Prod>i\\<in>I. \\<Sum>b\\<in>{True, False}. if b then f i else g i) =\n  (\\<Sum>m\\<in>I \\<rightarrow>\\<^sub>E {True, False}.\n     \\<Prod>i\\<in>I. if m i then f i else g i)\n\ngoal (1 subgoal):\n 1. (\\<Prod>i\\<in>I. f i + g i) =\n    (\\<Sum>J\\<in>Pow I. prod f J * prod g (I - J))", "also"], ["proof (state)\nthis:\n  (\\<Prod>i\\<in>I. \\<Sum>b\\<in>{True, False}. if b then f i else g i) =\n  (\\<Sum>m\\<in>I \\<rightarrow>\\<^sub>E {True, False}.\n     \\<Prod>i\\<in>I. if m i then f i else g i)\n\ngoal (1 subgoal):\n 1. (\\<Prod>i\\<in>I. f i + g i) =\n    (\\<Sum>J\\<in>Pow I. prod f J * prod g (I - J))", "have \"\\<dots> = (\\<Sum>J\\<in>Pow I. (\\<Prod>i\\<in>J. f i) * (\\<Prod>i\\<in>I - J. g i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>m\\<in>I \\<rightarrow>\\<^sub>E {True, False}.\n       \\<Prod>i\\<in>I. if m i then f i else g i) =\n    (\\<Sum>J\\<in>Pow I. prod f J * prod g (I - J))", "by (rule sum.reindex_bij_witness[where i=\"\\<lambda>J. \\<lambda>i\\<in>I. i\\<in>J\" and j=\"\\<lambda>m. {i\\<in>I. m i}\"])\n       (auto simp: fun_eq_iff prod.If_cases \\<open>finite I\\<close> intro!: arg_cong2[where f=\"(*)\"] prod.cong)"], ["proof (state)\nthis:\n  (\\<Sum>m\\<in>I \\<rightarrow>\\<^sub>E {True, False}.\n     \\<Prod>i\\<in>I. if m i then f i else g i) =\n  (\\<Sum>J\\<in>Pow I. prod f J * prod g (I - J))\n\ngoal (1 subgoal):\n 1. (\\<Prod>i\\<in>I. f i + g i) =\n    (\\<Sum>J\\<in>Pow I. prod f J * prod g (I - J))", "finally"], ["proof (chain)\npicking this:\n  (\\<Prod>i\\<in>I. f i + g i) =\n  (\\<Sum>J\\<in>Pow I. prod f J * prod g (I - J))", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<Prod>i\\<in>I. f i + g i) =\n  (\\<Sum>J\\<in>Pow I. prod f J * prod g (I - J))\n\ngoal (1 subgoal):\n 1. (\\<Prod>i\\<in>I. f i + g i) =\n    (\\<Sum>J\\<in>Pow I. prod f J * prod g (I - J))", "."], ["proof (state)\nthis:\n  (\\<Prod>i\\<in>I. f i + g i) =\n  (\\<Sum>J\\<in>Pow I. prod f J * prod g (I - J))\n\ngoal:\nNo subgoals!", "qed"], ["", "subclass (in linordered_nonzero_semiring) ordered_semiring_0"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.ordered_semiring_0 (+) (0::'a) (\\<le>) (<) (*)", "proof"], ["proof (state)\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in linordered_nonzero_semiring) prod_nonneg: \"(\\<forall>a\\<in>A. 0 \\<le> f a) \\<Longrightarrow> 0 \\<le> prod f A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a\\<in>A. (0::'a) \\<le> f a \\<Longrightarrow>\n    (0::'a) \\<le> prod f A", "by (induct A rule: infinite_finite_induct) simp_all"], ["", "lemma (in linordered_nonzero_semiring) prod_mono:\n  \"\\<forall>i\\<in>A. 0 \\<le> f i \\<and> f i \\<le> g i \\<Longrightarrow> prod f A \\<le> prod g A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>A.\n       (0::'a) \\<le> f i \\<and> f i \\<le> g i \\<Longrightarrow>\n    prod f A \\<le> prod g A", "by (induct A rule: infinite_finite_induct) (auto intro!: prod_nonneg mult_mono)"], ["", "lemma (in linordered_nonzero_semiring) prod_mono2:\n  assumes \"finite J\" \"I \\<subseteq> J\" \"\\<And>i. i \\<in> I \\<Longrightarrow> 0 \\<le> g i \\<and> g i \\<le> f i\" \"(\\<And>i. i \\<in> J - I \\<Longrightarrow> 1 \\<le> f i)\"\n  shows \"prod g I \\<le> prod f J\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod g I \\<le> prod f J", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. prod g I \\<le> prod f J", "have \"prod g I = (\\<Prod>i\\<in>J. if i \\<in> I then g i else 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod g I = (\\<Prod>i\\<in>J. if i \\<in> I then g i else (1::'a))", "using \\<open>finite J\\<close> \\<open>I \\<subseteq> J\\<close>"], ["proof (prove)\nusing this:\n  finite J\n  I \\<subseteq> J\n\ngoal (1 subgoal):\n 1. prod g I = (\\<Prod>i\\<in>J. if i \\<in> I then g i else (1::'a))", "by (simp add: prod.If_cases Int_absorb1)"], ["proof (state)\nthis:\n  prod g I = (\\<Prod>i\\<in>J. if i \\<in> I then g i else (1::'a))\n\ngoal (1 subgoal):\n 1. prod g I \\<le> prod f J", "also"], ["proof (state)\nthis:\n  prod g I = (\\<Prod>i\\<in>J. if i \\<in> I then g i else (1::'a))\n\ngoal (1 subgoal):\n 1. prod g I \\<le> prod f J", "have \"\\<dots> \\<le> prod f J\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>i\\<in>J. if i \\<in> I then g i else (1::'a)) \\<le> prod f J", "using assms"], ["proof (prove)\nusing this:\n  finite J\n  I \\<subseteq> J\n  ?i1 \\<in> I \\<Longrightarrow> (0::'a) \\<le> g ?i1 \\<and> g ?i1 \\<le> f ?i1\n  ?i1 \\<in> J - I \\<Longrightarrow> (1::'a) \\<le> f ?i1\n\ngoal (1 subgoal):\n 1. (\\<Prod>i\\<in>J. if i \\<in> I then g i else (1::'a)) \\<le> prod f J", "by (intro prod_mono) auto"], ["proof (state)\nthis:\n  (\\<Prod>i\\<in>J. if i \\<in> I then g i else (1::'a)) \\<le> prod f J\n\ngoal (1 subgoal):\n 1. prod g I \\<le> prod f J", "finally"], ["proof (chain)\npicking this:\n  prod g I \\<le> prod f J", "show ?thesis"], ["proof (prove)\nusing this:\n  prod g I \\<le> prod f J\n\ngoal (1 subgoal):\n 1. prod g I \\<le> prod f J", "."], ["proof (state)\nthis:\n  prod g I \\<le> prod f J\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in linordered_nonzero_semiring) prod_mono3:\n  assumes \"finite J\" \"I \\<subseteq> J\" \"\\<And>i. i \\<in> J \\<Longrightarrow> 0 \\<le> g i\" \"\\<And>i. i \\<in> I \\<Longrightarrow> g i \\<le> f i\" \"(\\<And>i. i \\<in> J - I \\<Longrightarrow> g i \\<le> 1)\"\n  shows \"prod g J \\<le> prod f I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod g J \\<le> prod f I", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. prod g J \\<le> prod f I", "have \"prod g J \\<le> (\\<Prod>i\\<in>J. if i \\<in> I then f i else 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod g J \\<le> (\\<Prod>i\\<in>J. if i \\<in> I then f i else (1::'a))", "using assms"], ["proof (prove)\nusing this:\n  finite J\n  I \\<subseteq> J\n  ?i1 \\<in> J \\<Longrightarrow> (0::'a) \\<le> g ?i1\n  ?i1 \\<in> I \\<Longrightarrow> g ?i1 \\<le> f ?i1\n  ?i1 \\<in> J - I \\<Longrightarrow> g ?i1 \\<le> (1::'a)\n\ngoal (1 subgoal):\n 1. prod g J \\<le> (\\<Prod>i\\<in>J. if i \\<in> I then f i else (1::'a))", "by (intro prod_mono) auto"], ["proof (state)\nthis:\n  prod g J \\<le> (\\<Prod>i\\<in>J. if i \\<in> I then f i else (1::'a))\n\ngoal (1 subgoal):\n 1. prod g J \\<le> prod f I", "also"], ["proof (state)\nthis:\n  prod g J \\<le> (\\<Prod>i\\<in>J. if i \\<in> I then f i else (1::'a))\n\ngoal (1 subgoal):\n 1. prod g J \\<le> prod f I", "have \"\\<dots> = prod f I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>i\\<in>J. if i \\<in> I then f i else (1::'a)) = prod f I", "using \\<open>finite J\\<close> \\<open>I \\<subseteq> J\\<close>"], ["proof (prove)\nusing this:\n  finite J\n  I \\<subseteq> J\n\ngoal (1 subgoal):\n 1. (\\<Prod>i\\<in>J. if i \\<in> I then f i else (1::'a)) = prod f I", "by (simp add: prod.If_cases Int_absorb1)"], ["proof (state)\nthis:\n  (\\<Prod>i\\<in>J. if i \\<in> I then f i else (1::'a)) = prod f I\n\ngoal (1 subgoal):\n 1. prod g J \\<le> prod f I", "finally"], ["proof (chain)\npicking this:\n  prod g J \\<le> prod f I", "show ?thesis"], ["proof (prove)\nusing this:\n  prod g J \\<le> prod f I\n\ngoal (1 subgoal):\n 1. prod g J \\<le> prod f I", "."], ["proof (state)\nthis:\n  prod g J \\<le> prod f I\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in linordered_nonzero_semiring) one_le_prod: \"(\\<And>i. i \\<in> I \\<Longrightarrow> 1 \\<le> f i) \\<Longrightarrow> 1 \\<le> prod f I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>i.\n        i \\<in> I \\<Longrightarrow> (1::'a) \\<le> f i) \\<Longrightarrow>\n    (1::'a) \\<le> prod f I", "proof (induction I rule: infinite_finite_induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>A.\n       \\<lbrakk>infinite A;\n        \\<And>i. i \\<in> A \\<Longrightarrow> (1::'a) \\<le> f i\\<rbrakk>\n       \\<Longrightarrow> (1::'a) \\<le> prod f A\n 2. (\\<And>i.\n        i \\<in> {} \\<Longrightarrow> (1::'a) \\<le> f i) \\<Longrightarrow>\n    (1::'a) \\<le> prod f {}\n 3. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        (\\<And>i.\n            i \\<in> F \\<Longrightarrow> (1::'a) \\<le> f i) \\<Longrightarrow>\n        (1::'a) \\<le> prod f F;\n        \\<And>i.\n           i \\<in> insert x F \\<Longrightarrow> (1::'a) \\<le> f i\\<rbrakk>\n       \\<Longrightarrow> (1::'a) \\<le> prod f (insert x F)", "case (insert i I)"], ["proof (state)\nthis:\n  finite I\n  i \\<notin> I\n  (\\<And>i. i \\<in> I \\<Longrightarrow> (1::'a) \\<le> f i) \\<Longrightarrow>\n  (1::'a) \\<le> prod f I\n  ?i1 \\<in> insert i I \\<Longrightarrow> (1::'a) \\<le> f ?i1\n\ngoal (3 subgoals):\n 1. \\<And>A.\n       \\<lbrakk>infinite A;\n        \\<And>i. i \\<in> A \\<Longrightarrow> (1::'a) \\<le> f i\\<rbrakk>\n       \\<Longrightarrow> (1::'a) \\<le> prod f A\n 2. (\\<And>i.\n        i \\<in> {} \\<Longrightarrow> (1::'a) \\<le> f i) \\<Longrightarrow>\n    (1::'a) \\<le> prod f {}\n 3. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        (\\<And>i.\n            i \\<in> F \\<Longrightarrow> (1::'a) \\<le> f i) \\<Longrightarrow>\n        (1::'a) \\<le> prod f F;\n        \\<And>i.\n           i \\<in> insert x F \\<Longrightarrow> (1::'a) \\<le> f i\\<rbrakk>\n       \\<Longrightarrow> (1::'a) \\<le> prod f (insert x F)", "then"], ["proof (chain)\npicking this:\n  finite I\n  i \\<notin> I\n  (\\<And>i. i \\<in> I \\<Longrightarrow> (1::'a) \\<le> f i) \\<Longrightarrow>\n  (1::'a) \\<le> prod f I\n  ?i1 \\<in> insert i I \\<Longrightarrow> (1::'a) \\<le> f ?i1", "show ?case"], ["proof (prove)\nusing this:\n  finite I\n  i \\<notin> I\n  (\\<And>i. i \\<in> I \\<Longrightarrow> (1::'a) \\<le> f i) \\<Longrightarrow>\n  (1::'a) \\<le> prod f I\n  ?i1 \\<in> insert i I \\<Longrightarrow> (1::'a) \\<le> f ?i1\n\ngoal (1 subgoal):\n 1. (1::'a) \\<le> prod f (insert i I)", "using mult_mono[of 1 \"f i\" 1 \"prod f I\"]"], ["proof (prove)\nusing this:\n  finite I\n  i \\<notin> I\n  (\\<And>i. i \\<in> I \\<Longrightarrow> (1::'a) \\<le> f i) \\<Longrightarrow>\n  (1::'a) \\<le> prod f I\n  ?i1 \\<in> insert i I \\<Longrightarrow> (1::'a) \\<le> f ?i1\n  \\<lbrakk>(1::'a) \\<le> f i; (1::'a) \\<le> prod f I; (0::'a) \\<le> f i;\n   (0::'a) \\<le> (1::'a)\\<rbrakk>\n  \\<Longrightarrow> (1::'a) * (1::'a) \\<le> f i * prod f I\n\ngoal (1 subgoal):\n 1. (1::'a) \\<le> prod f (insert i I)", "by (auto intro: order_trans[OF zero_le_one])"], ["proof (state)\nthis:\n  (1::'a) \\<le> prod f (insert i I)\n\ngoal (2 subgoals):\n 1. \\<And>A.\n       \\<lbrakk>infinite A;\n        \\<And>i. i \\<in> A \\<Longrightarrow> (1::'a) \\<le> f i\\<rbrakk>\n       \\<Longrightarrow> (1::'a) \\<le> prod f A\n 2. (\\<And>i.\n        i \\<in> {} \\<Longrightarrow> (1::'a) \\<le> f i) \\<Longrightarrow>\n    (1::'a) \\<le> prod f {}", "qed auto"], ["", "lemma sum_plus_one_le_prod_plus_one:\n  fixes p :: \"'a \\<Rightarrow> 'b::linordered_nonzero_semiring\"\n  assumes \"\\<And>i. i \\<in> I \\<Longrightarrow> 0 \\<le> p i\"\n  shows \"(\\<Sum>i\\<in>I. p i) + 1 \\<le> (\\<Prod>i\\<in>I. p i + 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum p I + (1::'b) \\<le> (\\<Prod>i\\<in>I. p i + (1::'b))", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    sum p I + (1::'b) \\<le> (\\<Prod>i\\<in>I. p i + (1::'b))\n 2. \\<not> ?P \\<Longrightarrow>\n    sum p I + (1::'b) \\<le> (\\<Prod>i\\<in>I. p i + (1::'b))", "assume [simp]: \"finite I\""], ["proof (state)\nthis:\n  finite I\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    sum p I + (1::'b) \\<le> (\\<Prod>i\\<in>I. p i + (1::'b))\n 2. \\<not> ?P \\<Longrightarrow>\n    sum p I + (1::'b) \\<le> (\\<Prod>i\\<in>I. p i + (1::'b))", "with assms"], ["proof (chain)\npicking this:\n  ?i \\<in> I \\<Longrightarrow> (0::'b) \\<le> p ?i\n  finite I", "have [simp]: \"J \\<subseteq> I \\<Longrightarrow> 0 \\<le> prod p J\" for J"], ["proof (prove)\nusing this:\n  ?i \\<in> I \\<Longrightarrow> (0::'b) \\<le> p ?i\n  finite I\n\ngoal (1 subgoal):\n 1. J \\<subseteq> I \\<Longrightarrow> (0::'b) \\<le> prod p J", "by (intro prod_nonneg) auto"], ["proof (state)\nthis:\n  ?J \\<subseteq> I \\<Longrightarrow> (0::'b) \\<le> prod p ?J\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    sum p I + (1::'b) \\<le> (\\<Prod>i\\<in>I. p i + (1::'b))\n 2. \\<not> ?P \\<Longrightarrow>\n    sum p I + (1::'b) \\<le> (\\<Prod>i\\<in>I. p i + (1::'b))", "have \"1 + (\\<Sum>i\\<in>I. p i) = (\\<Sum>J\\<in>insert {} ((\\<lambda>x. {x})`I). (\\<Prod>i\\<in>J. p i) * (\\<Prod>i\\<in>I - J. 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1::'b) + sum p I =\n    (\\<Sum>J\\<in>insert {} ((\\<lambda>x. {x}) ` I).\n       prod p J * (\\<Prod>i\\<in>I - J. (1::'b)))", "by (subst sum.insert) (auto simp: sum.reindex)"], ["proof (state)\nthis:\n  (1::'b) + sum p I =\n  (\\<Sum>J\\<in>insert {} ((\\<lambda>x. {x}) ` I).\n     prod p J * (\\<Prod>i\\<in>I - J. (1::'b)))\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    sum p I + (1::'b) \\<le> (\\<Prod>i\\<in>I. p i + (1::'b))\n 2. \\<not> ?P \\<Longrightarrow>\n    sum p I + (1::'b) \\<le> (\\<Prod>i\\<in>I. p i + (1::'b))", "also"], ["proof (state)\nthis:\n  (1::'b) + sum p I =\n  (\\<Sum>J\\<in>insert {} ((\\<lambda>x. {x}) ` I).\n     prod p J * (\\<Prod>i\\<in>I - J. (1::'b)))\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    sum p I + (1::'b) \\<le> (\\<Prod>i\\<in>I. p i + (1::'b))\n 2. \\<not> ?P \\<Longrightarrow>\n    sum p I + (1::'b) \\<le> (\\<Prod>i\\<in>I. p i + (1::'b))", "have \"\\<dots> \\<le> (\\<Sum>J\\<in>Pow I. (\\<Prod>i\\<in>J. p i) * (\\<Prod>i\\<in>I - J. 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>J\\<in>insert {} ((\\<lambda>x. {x}) ` I).\n       prod p J * (\\<Prod>i\\<in>I - J. (1::'b)))\n    \\<le> (\\<Sum>J\\<in>Pow I. prod p J * (\\<Prod>i\\<in>I - J. (1::'b)))", "using assms"], ["proof (prove)\nusing this:\n  ?i \\<in> I \\<Longrightarrow> (0::'b) \\<le> p ?i\n\ngoal (1 subgoal):\n 1. (\\<Sum>J\\<in>insert {} ((\\<lambda>x. {x}) ` I).\n       prod p J * (\\<Prod>i\\<in>I - J. (1::'b)))\n    \\<le> (\\<Sum>J\\<in>Pow I. prod p J * (\\<Prod>i\\<in>I - J. (1::'b)))", "by (intro sum_mono2) auto"], ["proof (state)\nthis:\n  (\\<Sum>J\\<in>insert {} ((\\<lambda>x. {x}) ` I).\n     prod p J * (\\<Prod>i\\<in>I - J. (1::'b)))\n  \\<le> (\\<Sum>J\\<in>Pow I. prod p J * (\\<Prod>i\\<in>I - J. (1::'b)))\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    sum p I + (1::'b) \\<le> (\\<Prod>i\\<in>I. p i + (1::'b))\n 2. \\<not> ?P \\<Longrightarrow>\n    sum p I + (1::'b) \\<le> (\\<Prod>i\\<in>I. p i + (1::'b))", "finally"], ["proof (chain)\npicking this:\n  (1::'b) + sum p I\n  \\<le> (\\<Sum>J\\<in>Pow I. prod p J * (\\<Prod>i\\<in>I - J. (1::'b)))", "show ?thesis"], ["proof (prove)\nusing this:\n  (1::'b) + sum p I\n  \\<le> (\\<Sum>J\\<in>Pow I. prod p J * (\\<Prod>i\\<in>I - J. (1::'b)))\n\ngoal (1 subgoal):\n 1. sum p I + (1::'b) \\<le> (\\<Prod>i\\<in>I. p i + (1::'b))", "by (subst prod_add_distrib) (auto simp: add.commute)"], ["proof (state)\nthis:\n  sum p I + (1::'b) \\<le> (\\<Prod>i\\<in>I. p i + (1::'b))\n\ngoal (1 subgoal):\n 1. infinite I \\<Longrightarrow>\n    sum p I + (1::'b) \\<le> (\\<Prod>i\\<in>I. p i + (1::'b))", "qed simp"], ["", "lemma summable_iff_convergent_prod:\n  fixes p :: \"nat \\<Rightarrow> real\" assumes p: \"\\<And>i. 0 \\<le> p i\"\n  shows \"summable p \\<longleftrightarrow> convergent (\\<lambda>n. \\<Prod>i<n. p i + 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. summable p = convergent (\\<lambda>n. \\<Prod>i<n. p i + 1)", "unfolding summable_iff_convergent"], ["proof (prove)\ngoal (1 subgoal):\n 1. convergent (\\<lambda>n. sum p {..<n}) =\n    convergent (\\<lambda>n. \\<Prod>i<n. p i + 1)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. convergent (\\<lambda>n. sum p {..<n}) \\<Longrightarrow>\n    convergent (\\<lambda>n. \\<Prod>i<n. p i + 1)\n 2. convergent (\\<lambda>n. \\<Prod>i<n. p i + 1) \\<Longrightarrow>\n    convergent (\\<lambda>n. sum p {..<n})", "assume \"convergent (\\<lambda>n. \\<Prod>i<n. p i + 1)\""], ["proof (state)\nthis:\n  convergent (\\<lambda>n. \\<Prod>i<n. p i + 1)\n\ngoal (2 subgoals):\n 1. convergent (\\<lambda>n. sum p {..<n}) \\<Longrightarrow>\n    convergent (\\<lambda>n. \\<Prod>i<n. p i + 1)\n 2. convergent (\\<lambda>n. \\<Prod>i<n. p i + 1) \\<Longrightarrow>\n    convergent (\\<lambda>n. sum p {..<n})", "then"], ["proof (chain)\npicking this:\n  convergent (\\<lambda>n. \\<Prod>i<n. p i + 1)", "obtain x where x: \"(\\<lambda>n. \\<Prod>i<n. p i + 1) \\<longlonglongrightarrow> x\""], ["proof (prove)\nusing this:\n  convergent (\\<lambda>n. \\<Prod>i<n. p i + 1)\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        (\\<lambda>n. \\<Prod>i<n. p i + 1)\n        \\<longlonglongrightarrow> x \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: convergent_def)"], ["proof (state)\nthis:\n  (\\<lambda>n. \\<Prod>i<n. p i + 1) \\<longlonglongrightarrow> x\n\ngoal (2 subgoals):\n 1. convergent (\\<lambda>n. sum p {..<n}) \\<Longrightarrow>\n    convergent (\\<lambda>n. \\<Prod>i<n. p i + 1)\n 2. convergent (\\<lambda>n. \\<Prod>i<n. p i + 1) \\<Longrightarrow>\n    convergent (\\<lambda>n. sum p {..<n})", "then"], ["proof (chain)\npicking this:\n  (\\<lambda>n. \\<Prod>i<n. p i + 1) \\<longlonglongrightarrow> x", "have \"1 \\<le> x\""], ["proof (prove)\nusing this:\n  (\\<lambda>n. \\<Prod>i<n. p i + 1) \\<longlonglongrightarrow> x\n\ngoal (1 subgoal):\n 1. 1 \\<le> x", "by (rule tendsto_lowerbound) (auto intro!: always_eventually one_le_prod p)"], ["proof (state)\nthis:\n  1 \\<le> x\n\ngoal (2 subgoals):\n 1. convergent (\\<lambda>n. sum p {..<n}) \\<Longrightarrow>\n    convergent (\\<lambda>n. \\<Prod>i<n. p i + 1)\n 2. convergent (\\<lambda>n. \\<Prod>i<n. p i + 1) \\<Longrightarrow>\n    convergent (\\<lambda>n. sum p {..<n})", "have \"convergent (\\<lambda>n. 1 + (\\<Sum>i<n. p i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. convergent (\\<lambda>n. 1 + sum p {..<n})", "proof (intro Bseq_mono_convergent BseqI allI)"], ["proof (state)\ngoal (3 subgoals):\n 1. 0 < ?K3\n 2. \\<And>n. norm (1 + sum p {..<n}) \\<le> ?K3\n 3. \\<And>m n.\n       m \\<le> n \\<longrightarrow> 1 + sum p {..<m} \\<le> 1 + sum p {..<n}", "show \"0 < x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < x", "using \\<open>1 \\<le> x\\<close>"], ["proof (prove)\nusing this:\n  1 \\<le> x\n\ngoal (1 subgoal):\n 1. 0 < x", "by auto"], ["proof (state)\nthis:\n  0 < x\n\ngoal (2 subgoals):\n 1. \\<And>n. norm (1 + sum p {..<n}) \\<le> x\n 2. \\<And>m n.\n       m \\<le> n \\<longrightarrow> 1 + sum p {..<m} \\<le> 1 + sum p {..<n}", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n. norm (1 + sum p {..<n}) \\<le> x\n 2. \\<And>m n.\n       m \\<le> n \\<longrightarrow> 1 + sum p {..<m} \\<le> 1 + sum p {..<n}", "fix n"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n. norm (1 + sum p {..<n}) \\<le> x\n 2. \\<And>m n.\n       m \\<le> n \\<longrightarrow> 1 + sum p {..<m} \\<le> 1 + sum p {..<n}", "have \"norm ((\\<Sum>i<n. p i) + 1) \\<le> (\\<Prod>i<n. p i + 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm (sum p {..<n} + 1) \\<le> (\\<Prod>i<n. p i + 1)", "using p"], ["proof (prove)\nusing this:\n  0 \\<le> p ?i\n\ngoal (1 subgoal):\n 1. norm (sum p {..<n} + 1) \\<le> (\\<Prod>i<n. p i + 1)", "by (simp add: sum_nonneg sum_plus_one_le_prod_plus_one p)"], ["proof (state)\nthis:\n  norm (sum p {..<n} + 1) \\<le> (\\<Prod>i<n. p i + 1)\n\ngoal (2 subgoals):\n 1. \\<And>n. norm (1 + sum p {..<n}) \\<le> x\n 2. \\<And>m n.\n       m \\<le> n \\<longrightarrow> 1 + sum p {..<m} \\<le> 1 + sum p {..<n}", "also"], ["proof (state)\nthis:\n  norm (sum p {..<n} + 1) \\<le> (\\<Prod>i<n. p i + 1)\n\ngoal (2 subgoals):\n 1. \\<And>n. norm (1 + sum p {..<n}) \\<le> x\n 2. \\<And>m n.\n       m \\<le> n \\<longrightarrow> 1 + sum p {..<m} \\<le> 1 + sum p {..<n}", "have \"\\<dots> \\<le> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>i<n. p i + 1) \\<le> x", "using assms"], ["proof (prove)\nusing this:\n  0 \\<le> p ?i\n\ngoal (1 subgoal):\n 1. (\\<Prod>i<n. p i + 1) \\<le> x", "by (intro tendsto_lowerbound[OF x])\n          (auto simp: eventually_sequentially intro!: exI[of _ n] prod_mono2)"], ["proof (state)\nthis:\n  (\\<Prod>i<n. p i + 1) \\<le> x\n\ngoal (2 subgoals):\n 1. \\<And>n. norm (1 + sum p {..<n}) \\<le> x\n 2. \\<And>m n.\n       m \\<le> n \\<longrightarrow> 1 + sum p {..<m} \\<le> 1 + sum p {..<n}", "finally"], ["proof (chain)\npicking this:\n  norm (sum p {..<n} + 1) \\<le> x", "show \"norm (1 + sum p {..<n}) \\<le> x\""], ["proof (prove)\nusing this:\n  norm (sum p {..<n} + 1) \\<le> x\n\ngoal (1 subgoal):\n 1. norm (1 + sum p {..<n}) \\<le> x", "by (simp add: add.commute)"], ["proof (state)\nthis:\n  norm (1 + sum p {..<n}) \\<le> x\n\ngoal (1 subgoal):\n 1. \\<And>m n.\n       m \\<le> n \\<longrightarrow> 1 + sum p {..<m} \\<le> 1 + sum p {..<n}", "qed (insert p, auto intro!: sum_mono2)"], ["proof (state)\nthis:\n  convergent (\\<lambda>n. 1 + sum p {..<n})\n\ngoal (2 subgoals):\n 1. convergent (\\<lambda>n. sum p {..<n}) \\<Longrightarrow>\n    convergent (\\<lambda>n. \\<Prod>i<n. p i + 1)\n 2. convergent (\\<lambda>n. \\<Prod>i<n. p i + 1) \\<Longrightarrow>\n    convergent (\\<lambda>n. sum p {..<n})", "then"], ["proof (chain)\npicking this:\n  convergent (\\<lambda>n. 1 + sum p {..<n})", "show \"convergent (\\<lambda>n. \\<Sum>i<n. p i)\""], ["proof (prove)\nusing this:\n  convergent (\\<lambda>n. 1 + sum p {..<n})\n\ngoal (1 subgoal):\n 1. convergent (\\<lambda>n. sum p {..<n})", "unfolding convergent_add_const_iff"], ["proof (prove)\nusing this:\n  convergent (\\<lambda>n. sum p {..<n})\n\ngoal (1 subgoal):\n 1. convergent (\\<lambda>n. sum p {..<n})", "."], ["proof (state)\nthis:\n  convergent (\\<lambda>n. sum p {..<n})\n\ngoal (1 subgoal):\n 1. convergent (\\<lambda>n. sum p {..<n}) \\<Longrightarrow>\n    convergent (\\<lambda>n. \\<Prod>i<n. p i + 1)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. convergent (\\<lambda>n. sum p {..<n}) \\<Longrightarrow>\n    convergent (\\<lambda>n. \\<Prod>i<n. p i + 1)", "assume \"convergent (\\<lambda>n. \\<Sum>i<n. p i)\""], ["proof (state)\nthis:\n  convergent (\\<lambda>n. sum p {..<n})\n\ngoal (1 subgoal):\n 1. convergent (\\<lambda>n. sum p {..<n}) \\<Longrightarrow>\n    convergent (\\<lambda>n. \\<Prod>i<n. p i + 1)", "then"], ["proof (chain)\npicking this:\n  convergent (\\<lambda>n. sum p {..<n})", "obtain x where x: \"(\\<lambda>n. exp (\\<Sum>i<n. p i)) \\<longlonglongrightarrow> exp x\""], ["proof (prove)\nusing this:\n  convergent (\\<lambda>n. sum p {..<n})\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        (\\<lambda>n. exp (sum p {..<n}))\n        \\<longlonglongrightarrow> exp x \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (force simp: convergent_def intro!: tendsto_exp)"], ["proof (state)\nthis:\n  (\\<lambda>n. exp (sum p {..<n})) \\<longlonglongrightarrow> exp x\n\ngoal (1 subgoal):\n 1. convergent (\\<lambda>n. sum p {..<n}) \\<Longrightarrow>\n    convergent (\\<lambda>n. \\<Prod>i<n. p i + 1)", "show \"convergent (\\<lambda>n. \\<Prod>i<n. p i + 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. convergent (\\<lambda>n. \\<Prod>i<n. p i + 1)", "proof (intro Bseq_mono_convergent BseqI allI)"], ["proof (state)\ngoal (3 subgoals):\n 1. 0 < ?K3\n 2. \\<And>n. norm (\\<Prod>i<n. p i + 1) \\<le> ?K3\n 3. \\<And>m n.\n       m \\<le> n \\<longrightarrow>\n       (\\<Prod>i<m. p i + 1) \\<le> (\\<Prod>i<n. p i + 1)", "show \"0 < exp x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < exp x", "by simp"], ["proof (state)\nthis:\n  0 < exp x\n\ngoal (2 subgoals):\n 1. \\<And>n. norm (\\<Prod>i<n. p i + 1) \\<le> exp x\n 2. \\<And>m n.\n       m \\<le> n \\<longrightarrow>\n       (\\<Prod>i<m. p i + 1) \\<le> (\\<Prod>i<n. p i + 1)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n. norm (\\<Prod>i<n. p i + 1) \\<le> exp x\n 2. \\<And>m n.\n       m \\<le> n \\<longrightarrow>\n       (\\<Prod>i<m. p i + 1) \\<le> (\\<Prod>i<n. p i + 1)", "fix n"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n. norm (\\<Prod>i<n. p i + 1) \\<le> exp x\n 2. \\<And>m n.\n       m \\<le> n \\<longrightarrow>\n       (\\<Prod>i<m. p i + 1) \\<le> (\\<Prod>i<n. p i + 1)", "have \"norm (\\<Prod>i<n. p i + 1) \\<le> exp (\\<Sum>i<n. p i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm (\\<Prod>i<n. p i + 1) \\<le> exp (sum p {..<n})", "using p exp_ge_add_one_self[of \"p _\"]"], ["proof (prove)\nusing this:\n  0 \\<le> p ?i\n  1 + p ?uu3 \\<le> exp (p ?uu3)\n\ngoal (1 subgoal):\n 1. norm (\\<Prod>i<n. p i + 1) \\<le> exp (sum p {..<n})", "by (auto simp add: prod_nonneg exp_sum add.commute intro!: prod_mono)"], ["proof (state)\nthis:\n  norm (\\<Prod>i<n. p i + 1) \\<le> exp (sum p {..<n})\n\ngoal (2 subgoals):\n 1. \\<And>n. norm (\\<Prod>i<n. p i + 1) \\<le> exp x\n 2. \\<And>m n.\n       m \\<le> n \\<longrightarrow>\n       (\\<Prod>i<m. p i + 1) \\<le> (\\<Prod>i<n. p i + 1)", "also"], ["proof (state)\nthis:\n  norm (\\<Prod>i<n. p i + 1) \\<le> exp (sum p {..<n})\n\ngoal (2 subgoals):\n 1. \\<And>n. norm (\\<Prod>i<n. p i + 1) \\<le> exp x\n 2. \\<And>m n.\n       m \\<le> n \\<longrightarrow>\n       (\\<Prod>i<m. p i + 1) \\<le> (\\<Prod>i<n. p i + 1)", "have \"\\<dots> \\<le> exp x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exp (sum p {..<n}) \\<le> exp x", "using p"], ["proof (prove)\nusing this:\n  0 \\<le> p ?i\n\ngoal (1 subgoal):\n 1. exp (sum p {..<n}) \\<le> exp x", "by (intro tendsto_lowerbound[OF x]) (auto simp: eventually_sequentially intro!: sum_mono2 )"], ["proof (state)\nthis:\n  exp (sum p {..<n}) \\<le> exp x\n\ngoal (2 subgoals):\n 1. \\<And>n. norm (\\<Prod>i<n. p i + 1) \\<le> exp x\n 2. \\<And>m n.\n       m \\<le> n \\<longrightarrow>\n       (\\<Prod>i<m. p i + 1) \\<le> (\\<Prod>i<n. p i + 1)", "finally"], ["proof (chain)\npicking this:\n  norm (\\<Prod>i<n. p i + 1) \\<le> exp x", "show \"norm (\\<Prod>i<n. p i + 1) \\<le> exp x\""], ["proof (prove)\nusing this:\n  norm (\\<Prod>i<n. p i + 1) \\<le> exp x\n\ngoal (1 subgoal):\n 1. norm (\\<Prod>i<n. p i + 1) \\<le> exp x", "."], ["proof (state)\nthis:\n  norm (\\<Prod>i<n. p i + 1) \\<le> exp x\n\ngoal (1 subgoal):\n 1. \\<And>m n.\n       m \\<le> n \\<longrightarrow>\n       (\\<Prod>i<m. p i + 1) \\<le> (\\<Prod>i<n. p i + 1)", "qed (insert p, auto intro!: prod_mono2)"], ["proof (state)\nthis:\n  convergent (\\<lambda>n. \\<Prod>i<n. p i + 1)\n\ngoal:\nNo subgoals!", "qed"], ["", "primrec eexp :: \"ereal \\<Rightarrow> ennreal\"\n  where\n    \"eexp MInfty = 0\"\n  | \"eexp (ereal r) = ennreal (exp r)\"\n  | \"eexp PInfty = top\""], ["", "lemma\n  shows eexp_minus_infty[simp]: \"eexp (-\\<infinity>) = 0\"\n    and eexp_infty[simp]: \"eexp \\<infinity> = top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eexp (- \\<infinity>) = 0 &&& eexp \\<infinity> = \\<top>", "using eexp.simps"], ["proof (prove)\nusing this:\n  eexp MInfty = 0\n  eexp (ereal ?r) = ennreal (exp ?r)\n  eexp PInfty = \\<top>\n\ngoal (1 subgoal):\n 1. eexp (- \\<infinity>) = 0 &&& eexp \\<infinity> = \\<top>", "by simp_all"], ["", "lemma eexp_0[simp]: \"eexp 0 = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eexp 0 = 1", "by (simp add: zero_ereal_def)"], ["", "lemma eexp_inj[simp]: \"eexp x = eexp y \\<longleftrightarrow> x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (eexp x = eexp y) = (x = y)", "by (cases x; cases y; simp)"], ["", "lemma eexp_mono[simp]: \"eexp x \\<le> eexp y \\<longleftrightarrow> x \\<le> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (eexp x \\<le> eexp y) = (x \\<le> y)", "by (cases x; cases y; simp add: top_unique)"], ["", "lemma eexp_strict_mono[simp]: \"eexp x < eexp y \\<longleftrightarrow> x < y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (eexp x < eexp y) = (x < y)", "by (simp add: less_le)"], ["", "lemma exp_eq_0_iff[simp]: \"eexp x = 0 \\<longleftrightarrow> x = -\\<infinity>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (eexp x = 0) = (x = - \\<infinity>)", "using eexp_inj[of x \"-\\<infinity>\"]"], ["proof (prove)\nusing this:\n  (eexp x = eexp (- \\<infinity>)) = (x = - \\<infinity>)\n\ngoal (1 subgoal):\n 1. (eexp x = 0) = (x = - \\<infinity>)", "unfolding eexp_minus_infty"], ["proof (prove)\nusing this:\n  (eexp x = 0) = (x = - \\<infinity>)\n\ngoal (1 subgoal):\n 1. (eexp x = 0) = (x = - \\<infinity>)", "."], ["", "lemma eexp_surj: \"range eexp = UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. surj eexp", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. surj eexp", "have part: \"UNIV = {0} \\<union> {0 <..< top} \\<union> {top::ennreal}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. UNIV = {0} \\<union> {0<..<\\<top>} \\<union> {\\<top>}", "by (auto simp: less_top)"], ["proof (state)\nthis:\n  UNIV = {0} \\<union> {0<..<\\<top>} \\<union> {\\<top>}\n\ngoal (1 subgoal):\n 1. surj eexp", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. surj eexp", "unfolding part"], ["proof (prove)\ngoal (1 subgoal):\n 1. range eexp = {0} \\<union> {0<..<\\<top>} \\<union> {\\<top>}", "by (force simp: image_iff less_top less_top_ennreal intro!: eexp.simps[symmetric] eexp.simps dest: exp_total)"], ["proof (state)\nthis:\n  surj eexp\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma continuous_on_eexp': \"continuous_on UNIV eexp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on UNIV eexp", "by (rule continuous_onI_mono) (auto simp: eexp_surj)"], ["", "lemma continuous_on_eexp[continuous_intros]: \"continuous_on A f \\<Longrightarrow> continuous_on A (\\<lambda>x. eexp (f x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on A f \\<Longrightarrow>\n    continuous_on A (\\<lambda>x. eexp (f x))", "by (rule continuous_on_compose2[OF continuous_on_eexp']) auto"], ["", "lemma tendsto_eexp[tendsto_intros]: \"(f \\<longlongrightarrow> x) F \\<Longrightarrow> ((\\<lambda>x. eexp (f x)) \\<longlongrightarrow> eexp x) F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f \\<longlongrightarrow> x) F \\<Longrightarrow>\n    ((\\<lambda>x. eexp (f x)) \\<longlongrightarrow> eexp x) F", "by (rule continuous_on_tendsto_compose[OF continuous_on_eexp']) auto"], ["", "lemma measurable_eexp[measurable]: \"eexp \\<in> borel \\<rightarrow>\\<^sub>M borel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eexp \\<in> borel_measurable borel", "using continuous_on_eexp'"], ["proof (prove)\nusing this:\n  continuous_on UNIV eexp\n\ngoal (1 subgoal):\n 1. eexp \\<in> borel_measurable borel", "by (rule borel_measurable_continuous_onI)"], ["", "lemma eexp_add: \"\\<not> ((x = \\<infinity> \\<and> y = -\\<infinity>) \\<or> (x = -\\<infinity> \\<and> y = \\<infinity>)) \\<Longrightarrow> eexp (x + y) = eexp x * eexp y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (x = \\<infinity> \\<and> y = - \\<infinity> \\<or>\n            x = - \\<infinity> \\<and> y = \\<infinity>) \\<Longrightarrow>\n    eexp (x + y) = eexp x * eexp y", "by (cases x; cases y; simp add: exp_add ennreal_mult ennreal_top_mult ennreal_mult_top)"], ["", "lemma sum_Pinfty:\n  fixes f :: \"'a \\<Rightarrow> ereal\"\n  shows \"sum f I = \\<infinity> \\<longleftrightarrow> (finite I \\<and> (\\<exists>i\\<in>I. f i = \\<infinity>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (sum f I = \\<infinity>) =\n    (finite I \\<and> (\\<exists>i\\<in>I. f i = \\<infinity>))", "by (induction I rule: infinite_finite_induct) auto"], ["", "lemma sum_Minfty:\n  fixes f :: \"'a \\<Rightarrow> ereal\"\n  shows \"sum f I = -\\<infinity> \\<longleftrightarrow> (finite I \\<and> \\<not> (\\<exists>i\\<in>I. f i = \\<infinity>) \\<and> (\\<exists>i\\<in>I. f i = -\\<infinity>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (sum f I = - \\<infinity>) =\n    (finite I \\<and>\n     \\<not> (\\<exists>i\\<in>I. f i = \\<infinity>) \\<and>\n     (\\<exists>i\\<in>I. f i = - \\<infinity>))", "by (induction I rule: infinite_finite_induct)\n     (auto simp: sum_Pinfty)"], ["", "lemma eexp_sum: \"\\<not> (\\<exists>i\\<in>I. \\<exists>j\\<in>I. f i = -\\<infinity> \\<and> f j = \\<infinity>) \\<Longrightarrow> eexp (\\<Sum>i\\<in>I. f i) = (\\<Prod>i\\<in>I. eexp (f i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>i\\<in>I.\n               \\<exists>j\\<in>I.\n                  f i = - \\<infinity> \\<and>\n                  f j = \\<infinity>) \\<Longrightarrow>\n    eexp (sum f I) = (\\<Prod>i\\<in>I. eexp (f i))", "proof (induction I rule: infinite_finite_induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>A.\n       \\<lbrakk>infinite A;\n        \\<not> (\\<exists>i\\<in>A.\n                   \\<exists>j\\<in>A.\n                      f i = - \\<infinity> \\<and> f j = \\<infinity>)\\<rbrakk>\n       \\<Longrightarrow> eexp (sum f A) = (\\<Prod>i\\<in>A. eexp (f i))\n 2. \\<not> (\\<exists>i\\<in>{}.\n               \\<exists>j\\<in>{}.\n                  f i = - \\<infinity> \\<and>\n                  f j = \\<infinity>) \\<Longrightarrow>\n    eexp (sum f {}) = (\\<Prod>i\\<in>{}. eexp (f i))\n 3. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<not> (\\<exists>i\\<in>F.\n                   \\<exists>j\\<in>F.\n                      f i = - \\<infinity> \\<and>\n                      f j = \\<infinity>) \\<Longrightarrow>\n        eexp (sum f F) = (\\<Prod>i\\<in>F. eexp (f i));\n        \\<not> (\\<exists>i\\<in>insert x F.\n                   \\<exists>j\\<in>insert x F.\n                      f i = - \\<infinity> \\<and> f j = \\<infinity>)\\<rbrakk>\n       \\<Longrightarrow> eexp (sum f (insert x F)) =\n                         (\\<Prod>i\\<in>insert x F. eexp (f i))", "case (insert i I)"], ["proof (state)\nthis:\n  finite I\n  i \\<notin> I\n  \\<not> (\\<exists>i\\<in>I.\n             \\<exists>j\\<in>I.\n                f i = - \\<infinity> \\<and>\n                f j = \\<infinity>) \\<Longrightarrow>\n  eexp (sum f I) = (\\<Prod>i\\<in>I. eexp (f i))\n  \\<not> (\\<exists>ia\\<in>insert i I.\n             \\<exists>j\\<in>insert i I.\n                f ia = - \\<infinity> \\<and> f j = \\<infinity>)\n\ngoal (3 subgoals):\n 1. \\<And>A.\n       \\<lbrakk>infinite A;\n        \\<not> (\\<exists>i\\<in>A.\n                   \\<exists>j\\<in>A.\n                      f i = - \\<infinity> \\<and> f j = \\<infinity>)\\<rbrakk>\n       \\<Longrightarrow> eexp (sum f A) = (\\<Prod>i\\<in>A. eexp (f i))\n 2. \\<not> (\\<exists>i\\<in>{}.\n               \\<exists>j\\<in>{}.\n                  f i = - \\<infinity> \\<and>\n                  f j = \\<infinity>) \\<Longrightarrow>\n    eexp (sum f {}) = (\\<Prod>i\\<in>{}. eexp (f i))\n 3. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<not> (\\<exists>i\\<in>F.\n                   \\<exists>j\\<in>F.\n                      f i = - \\<infinity> \\<and>\n                      f j = \\<infinity>) \\<Longrightarrow>\n        eexp (sum f F) = (\\<Prod>i\\<in>F. eexp (f i));\n        \\<not> (\\<exists>i\\<in>insert x F.\n                   \\<exists>j\\<in>insert x F.\n                      f i = - \\<infinity> \\<and> f j = \\<infinity>)\\<rbrakk>\n       \\<Longrightarrow> eexp (sum f (insert x F)) =\n                         (\\<Prod>i\\<in>insert x F. eexp (f i))", "have \"eexp (sum f (insert i I)) = eexp (f i) * eexp (sum f I)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eexp (sum f (insert i I)) = eexp (f i) * eexp (sum f I)", "using insert.prems insert.hyps"], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>ia\\<in>insert i I.\n             \\<exists>j\\<in>insert i I.\n                f ia = - \\<infinity> \\<and> f j = \\<infinity>)\n  finite I\n  i \\<notin> I\n\ngoal (1 subgoal):\n 1. eexp (sum f (insert i I)) = eexp (f i) * eexp (sum f I)", "by (auto simp: sum_Pinfty sum_Minfty intro!: eexp_add)"], ["proof (state)\nthis:\n  eexp (sum f (insert i I)) = eexp (f i) * eexp (sum f I)\n\ngoal (3 subgoals):\n 1. \\<And>A.\n       \\<lbrakk>infinite A;\n        \\<not> (\\<exists>i\\<in>A.\n                   \\<exists>j\\<in>A.\n                      f i = - \\<infinity> \\<and> f j = \\<infinity>)\\<rbrakk>\n       \\<Longrightarrow> eexp (sum f A) = (\\<Prod>i\\<in>A. eexp (f i))\n 2. \\<not> (\\<exists>i\\<in>{}.\n               \\<exists>j\\<in>{}.\n                  f i = - \\<infinity> \\<and>\n                  f j = \\<infinity>) \\<Longrightarrow>\n    eexp (sum f {}) = (\\<Prod>i\\<in>{}. eexp (f i))\n 3. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<not> (\\<exists>i\\<in>F.\n                   \\<exists>j\\<in>F.\n                      f i = - \\<infinity> \\<and>\n                      f j = \\<infinity>) \\<Longrightarrow>\n        eexp (sum f F) = (\\<Prod>i\\<in>F. eexp (f i));\n        \\<not> (\\<exists>i\\<in>insert x F.\n                   \\<exists>j\\<in>insert x F.\n                      f i = - \\<infinity> \\<and> f j = \\<infinity>)\\<rbrakk>\n       \\<Longrightarrow> eexp (sum f (insert x F)) =\n                         (\\<Prod>i\\<in>insert x F. eexp (f i))", "then"], ["proof (chain)\npicking this:\n  eexp (sum f (insert i I)) = eexp (f i) * eexp (sum f I)", "show ?case"], ["proof (prove)\nusing this:\n  eexp (sum f (insert i I)) = eexp (f i) * eexp (sum f I)\n\ngoal (1 subgoal):\n 1. eexp (sum f (insert i I)) = (\\<Prod>i\\<in>insert i I. eexp (f i))", "using insert"], ["proof (prove)\nusing this:\n  eexp (sum f (insert i I)) = eexp (f i) * eexp (sum f I)\n  finite I\n  i \\<notin> I\n  \\<not> (\\<exists>i\\<in>I.\n             \\<exists>j\\<in>I.\n                f i = - \\<infinity> \\<and>\n                f j = \\<infinity>) \\<Longrightarrow>\n  eexp (sum f I) = (\\<Prod>i\\<in>I. eexp (f i))\n  \\<not> (\\<exists>ia\\<in>insert i I.\n             \\<exists>j\\<in>insert i I.\n                f ia = - \\<infinity> \\<and> f j = \\<infinity>)\n\ngoal (1 subgoal):\n 1. eexp (sum f (insert i I)) = (\\<Prod>i\\<in>insert i I. eexp (f i))", "by auto"], ["proof (state)\nthis:\n  eexp (sum f (insert i I)) = (\\<Prod>i\\<in>insert i I. eexp (f i))\n\ngoal (2 subgoals):\n 1. \\<And>A.\n       \\<lbrakk>infinite A;\n        \\<not> (\\<exists>i\\<in>A.\n                   \\<exists>j\\<in>A.\n                      f i = - \\<infinity> \\<and> f j = \\<infinity>)\\<rbrakk>\n       \\<Longrightarrow> eexp (sum f A) = (\\<Prod>i\\<in>A. eexp (f i))\n 2. \\<not> (\\<exists>i\\<in>{}.\n               \\<exists>j\\<in>{}.\n                  f i = - \\<infinity> \\<and>\n                  f j = \\<infinity>) \\<Longrightarrow>\n    eexp (sum f {}) = (\\<Prod>i\\<in>{}. eexp (f i))", "qed simp_all"], ["", "lemma eexp_suminf:\n  assumes wf_f: \"\\<not> {-\\<infinity>, \\<infinity>} \\<subseteq> range f\" and f: \"summable f\"\n  shows \"(\\<lambda>n. \\<Prod>i<n. eexp (f i)) \\<longlonglongrightarrow> eexp (\\<Sum>i. f i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n. \\<Prod>i<n. eexp (f i))\n    \\<longlonglongrightarrow> eexp (\\<Sum>i. f i)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<lambda>n. \\<Prod>i<n. eexp (f i))\n    \\<longlonglongrightarrow> eexp (\\<Sum>i. f i)", "have \"(\\<lambda>n. eexp (\\<Sum>i<n. f i)) \\<longlonglongrightarrow> eexp (\\<Sum>i. f i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n. eexp (sum f {..<n}))\n    \\<longlonglongrightarrow> eexp (\\<Sum>i. f i)", "by (intro tendsto_eexp summable_LIMSEQ f)"], ["proof (state)\nthis:\n  (\\<lambda>n. eexp (sum f {..<n}))\n  \\<longlonglongrightarrow> eexp (\\<Sum>i. f i)\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. \\<Prod>i<n. eexp (f i))\n    \\<longlonglongrightarrow> eexp (\\<Sum>i. f i)", "also"], ["proof (state)\nthis:\n  (\\<lambda>n. eexp (sum f {..<n}))\n  \\<longlonglongrightarrow> eexp (\\<Sum>i. f i)\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. \\<Prod>i<n. eexp (f i))\n    \\<longlonglongrightarrow> eexp (\\<Sum>i. f i)", "have \"(\\<lambda>n. eexp (\\<Sum>i<n. f i)) = (\\<lambda>n. \\<Prod>i<n. eexp (f i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n. eexp (sum f {..<n})) = (\\<lambda>n. \\<Prod>i<n. eexp (f i))", "using wf_f"], ["proof (prove)\nusing this:\n  \\<not> {- \\<infinity>, \\<infinity>} \\<subseteq> range f\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. eexp (sum f {..<n})) = (\\<lambda>n. \\<Prod>i<n. eexp (f i))", "by (auto simp: fun_eq_iff image_iff eq_commute intro!: eexp_sum)"], ["proof (state)\nthis:\n  (\\<lambda>n. eexp (sum f {..<n})) = (\\<lambda>n. \\<Prod>i<n. eexp (f i))\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. \\<Prod>i<n. eexp (f i))\n    \\<longlonglongrightarrow> eexp (\\<Sum>i. f i)", "finally"], ["proof (chain)\npicking this:\n  (\\<lambda>n. \\<Prod>i<n. eexp (f i))\n  \\<longlonglongrightarrow> eexp (\\<Sum>i. f i)", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<lambda>n. \\<Prod>i<n. eexp (f i))\n  \\<longlonglongrightarrow> eexp (\\<Sum>i. f i)\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. \\<Prod>i<n. eexp (f i))\n    \\<longlonglongrightarrow> eexp (\\<Sum>i. f i)", "."], ["proof (state)\nthis:\n  (\\<lambda>n. \\<Prod>i<n. eexp (f i))\n  \\<longlonglongrightarrow> eexp (\\<Sum>i. f i)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma continuous_onI_antimono:\n  fixes f :: \"'a::linorder_topology \\<Rightarrow> 'b::{dense_order,linorder_topology}\"\n  assumes \"open (f`A)\"\n    and mono: \"\\<And>x y. x \\<in> A \\<Longrightarrow> y \\<in> A \\<Longrightarrow> x \\<le> y \\<Longrightarrow> f y \\<le> f x\"\n  shows \"continuous_on A f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on A f", "proof (rule continuous_on_generate_topology[OF open_generated_order], safe)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>B a.\n       a \\<in> UNIV \\<Longrightarrow>\n       \\<exists>C. open C \\<and> C \\<inter> A = f -` {..<a} \\<inter> A\n 2. \\<And>B a.\n       a \\<in> UNIV \\<Longrightarrow>\n       \\<exists>C. open C \\<and> C \\<inter> A = f -` {a<..} \\<inter> A", "have monoD: \"\\<And>x y. x \\<in> A \\<Longrightarrow> y \\<in> A \\<Longrightarrow> f y < f x \\<Longrightarrow> x < y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> A; y \\<in> A; f y < f x\\<rbrakk>\n       \\<Longrightarrow> x < y", "by (auto simp: not_le[symmetric] mono)"], ["proof (state)\nthis:\n  \\<lbrakk>?x \\<in> A; ?y \\<in> A; f ?y < f ?x\\<rbrakk>\n  \\<Longrightarrow> ?x < ?y\n\ngoal (2 subgoals):\n 1. \\<And>B a.\n       a \\<in> UNIV \\<Longrightarrow>\n       \\<exists>C. open C \\<and> C \\<inter> A = f -` {..<a} \\<inter> A\n 2. \\<And>B a.\n       a \\<in> UNIV \\<Longrightarrow>\n       \\<exists>C. open C \\<and> C \\<inter> A = f -` {a<..} \\<inter> A", "have \"\\<exists>x. x \\<in> A \\<and> f x < b \\<and> x < a\" if a: \"a \\<in> A\" and fa: \"f a < b\" for a b"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> A \\<and> f x < b \\<and> x < a", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> A \\<and> f x < b \\<and> x < a", "obtain y where \"f a < y\" \"{f a ..< y} \\<subseteq> f`A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>f a < y; {f a..<y} \\<subseteq> f ` A\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using open_right[OF \\<open>open (f`A)\\<close>, of \"f a\" b] a fa"], ["proof (prove)\nusing this:\n  \\<lbrakk>f a \\<in> f ` A; f a < b\\<rbrakk>\n  \\<Longrightarrow> \\<exists>b>f a. {f a..<b} \\<subseteq> f ` A\n  a \\<in> A\n  f a < b\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>f a < y; {f a..<y} \\<subseteq> f ` A\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  f a < y\n  {f a..<y} \\<subseteq> f ` A\n\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> A \\<and> f x < b \\<and> x < a", "obtain z where z: \"f a < z\" \"z < min b y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>z.\n        \\<lbrakk>f a < z; z < min b y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using dense[of \"f a\" \"min b y\"] \\<open>f a < y\\<close> \\<open>f a < b\\<close>"], ["proof (prove)\nusing this:\n  f a < min b y \\<Longrightarrow> \\<exists>z>f a. z < min b y\n  f a < y\n  f a < b\n\ngoal (1 subgoal):\n 1. (\\<And>z.\n        \\<lbrakk>f a < z; z < min b y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  f a < z\n  z < min b y\n\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> A \\<and> f x < b \\<and> x < a", "then"], ["proof (chain)\npicking this:\n  f a < z\n  z < min b y", "obtain c where \"z = f c\" \"c \\<in> A\""], ["proof (prove)\nusing this:\n  f a < z\n  z < min b y\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        \\<lbrakk>z = f c; c \\<in> A\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>{f a ..< y} \\<subseteq> f`A\\<close>[THEN subsetD, of z]"], ["proof (prove)\nusing this:\n  f a < z\n  z < min b y\n  z \\<in> {f a..<y} \\<Longrightarrow> z \\<in> f ` A\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        \\<lbrakk>z = f c; c \\<in> A\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: less_imp_le)"], ["proof (state)\nthis:\n  z = f c\n  c \\<in> A\n\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> A \\<and> f x < b \\<and> x < a", "with a z"], ["proof (chain)\npicking this:\n  a \\<in> A\n  f a < z\n  z < min b y\n  z = f c\n  c \\<in> A", "show ?thesis"], ["proof (prove)\nusing this:\n  a \\<in> A\n  f a < z\n  z < min b y\n  z = f c\n  c \\<in> A\n\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> A \\<and> f x < b \\<and> x < a", "by (auto intro!: exI[of _ c] simp: monoD)"], ["proof (state)\nthis:\n  \\<exists>x. x \\<in> A \\<and> f x < b \\<and> x < a\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>?a \\<in> A; f ?a < ?b\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x. x \\<in> A \\<and> f x < ?b \\<and> x < ?a\n\ngoal (2 subgoals):\n 1. \\<And>B a.\n       a \\<in> UNIV \\<Longrightarrow>\n       \\<exists>C. open C \\<and> C \\<inter> A = f -` {..<a} \\<inter> A\n 2. \\<And>B a.\n       a \\<in> UNIV \\<Longrightarrow>\n       \\<exists>C. open C \\<and> C \\<inter> A = f -` {a<..} \\<inter> A", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>?a \\<in> A; f ?a < ?b\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x. x \\<in> A \\<and> f x < ?b \\<and> x < ?a", "show \"\\<exists>C. open C \\<and> C \\<inter> A = f -` {..<b} \\<inter> A\" for b"], ["proof (prove)\nusing this:\n  \\<lbrakk>?a \\<in> A; f ?a < ?b\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x. x \\<in> A \\<and> f x < ?b \\<and> x < ?a\n\ngoal (1 subgoal):\n 1. \\<exists>C. open C \\<and> C \\<inter> A = f -` {..<b} \\<inter> A", "by (intro exI[of _ \"(\\<Union>x\\<in>{x\\<in>A. f x < b}. {x <..})\"])\n       (auto intro: le_less_trans[OF mono] less_imp_le)"], ["proof (state)\nthis:\n  \\<exists>C. open C \\<and> C \\<inter> A = f -` {..<?b} \\<inter> A\n\ngoal (1 subgoal):\n 1. \\<And>B a.\n       a \\<in> UNIV \\<Longrightarrow>\n       \\<exists>C. open C \\<and> C \\<inter> A = f -` {a<..} \\<inter> A", "have \"\\<exists>x. x \\<in> A \\<and> b < f x \\<and> x > a\" if a: \"a \\<in> A\" and fa: \"b < f a\" for a b"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> A \\<and> b < f x \\<and> a < x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> A \\<and> b < f x \\<and> a < x", "note a fa"], ["proof (state)\nthis:\n  a \\<in> A\n  b < f a\n\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> A \\<and> b < f x \\<and> a < x", "moreover"], ["proof (state)\nthis:\n  a \\<in> A\n  b < f a\n\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> A \\<and> b < f x \\<and> a < x", "obtain y where \"y < f a\" \"{y <.. f a} \\<subseteq> f`A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y < f a; {y<..f a} \\<subseteq> f ` A\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using open_left[OF \\<open>open (f`A)\\<close>, of \"f a\" b]  a fa"], ["proof (prove)\nusing this:\n  \\<lbrakk>f a \\<in> f ` A; b < f a\\<rbrakk>\n  \\<Longrightarrow> \\<exists>b<f a. {b<..f a} \\<subseteq> f ` A\n  a \\<in> A\n  b < f a\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y < f a; {y<..f a} \\<subseteq> f ` A\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  y < f a\n  {y<..f a} \\<subseteq> f ` A\n\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> A \\<and> b < f x \\<and> a < x", "then"], ["proof (chain)\npicking this:\n  y < f a\n  {y<..f a} \\<subseteq> f ` A", "obtain z where z: \"max b y < z\" \"z < f a\""], ["proof (prove)\nusing this:\n  y < f a\n  {y<..f a} \\<subseteq> f ` A\n\ngoal (1 subgoal):\n 1. (\\<And>z.\n        \\<lbrakk>max b y < z; z < f a\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using dense[of \"max b y\" \"f a\"] \\<open>y < f a\\<close> \\<open>b < f a\\<close>"], ["proof (prove)\nusing this:\n  y < f a\n  {y<..f a} \\<subseteq> f ` A\n  max b y < f a \\<Longrightarrow> \\<exists>z>max b y. z < f a\n  y < f a\n  b < f a\n\ngoal (1 subgoal):\n 1. (\\<And>z.\n        \\<lbrakk>max b y < z; z < f a\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  max b y < z\n  z < f a\n\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> A \\<and> b < f x \\<and> a < x", "then"], ["proof (chain)\npicking this:\n  max b y < z\n  z < f a", "obtain c where \"z = f c\" \"c \\<in> A\""], ["proof (prove)\nusing this:\n  max b y < z\n  z < f a\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        \\<lbrakk>z = f c; c \\<in> A\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>{y <.. f a} \\<subseteq> f`A\\<close>[THEN subsetD, of z]"], ["proof (prove)\nusing this:\n  max b y < z\n  z < f a\n  z \\<in> {y<..f a} \\<Longrightarrow> z \\<in> f ` A\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        \\<lbrakk>z = f c; c \\<in> A\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: less_imp_le)"], ["proof (state)\nthis:\n  z = f c\n  c \\<in> A\n\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> A \\<and> b < f x \\<and> a < x", "with a z"], ["proof (chain)\npicking this:\n  a \\<in> A\n  max b y < z\n  z < f a\n  z = f c\n  c \\<in> A", "show ?thesis"], ["proof (prove)\nusing this:\n  a \\<in> A\n  max b y < z\n  z < f a\n  z = f c\n  c \\<in> A\n\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> A \\<and> b < f x \\<and> a < x", "by (auto intro!: exI[of _ c] simp: monoD)"], ["proof (state)\nthis:\n  \\<exists>x. x \\<in> A \\<and> b < f x \\<and> a < x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>?a \\<in> A; ?b < f ?a\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x. x \\<in> A \\<and> ?b < f x \\<and> ?a < x\n\ngoal (1 subgoal):\n 1. \\<And>B a.\n       a \\<in> UNIV \\<Longrightarrow>\n       \\<exists>C. open C \\<and> C \\<inter> A = f -` {a<..} \\<inter> A", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>?a \\<in> A; ?b < f ?a\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x. x \\<in> A \\<and> ?b < f x \\<and> ?a < x", "show \"\\<exists>C. open C \\<and> C \\<inter> A = f -` {b <..} \\<inter> A\" for b"], ["proof (prove)\nusing this:\n  \\<lbrakk>?a \\<in> A; ?b < f ?a\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x. x \\<in> A \\<and> ?b < f x \\<and> ?a < x\n\ngoal (1 subgoal):\n 1. \\<exists>C. open C \\<and> C \\<inter> A = f -` {b<..} \\<inter> A", "by (intro exI[of _ \"(\\<Union>x\\<in>{x\\<in>A. b < f x}. {..< x})\"])\n       (auto intro: less_le_trans[OF _ mono] less_imp_le)"], ["proof (state)\nthis:\n  \\<exists>C. open C \\<and> C \\<inter> A = f -` {?b<..} \\<inter> A\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma minus_add_eq_ereal: \"\\<not> ((a = \\<infinity> \\<and> b = -\\<infinity>) \\<or> (a = -\\<infinity> \\<and> b = \\<infinity>)) \\<Longrightarrow> - (a + b::ereal) = -a - b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (a = \\<infinity> \\<and> b = - \\<infinity> \\<or>\n            a = - \\<infinity> \\<and> b = \\<infinity>) \\<Longrightarrow>\n    - (a + b) = - a - b", "by (cases a; cases b; simp)"], ["", "lemma setsum_negf_ereal: \"\\<not> {-\\<infinity>, \\<infinity>} \\<subseteq> f`I \\<Longrightarrow> (\\<Sum>i\\<in>I. - f i) = - (\\<Sum>i\\<in>I. f i::ereal)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> {- \\<infinity>, \\<infinity>} \\<subseteq> f ` I \\<Longrightarrow>\n    (\\<Sum>i\\<in>I. - f i) = - sum f I", "by (induction I rule: infinite_finite_induct)\n     (auto simp: minus_add_eq_ereal sum_Minfty sum_Pinfty,\n      (subst minus_add_eq_ereal; auto simp: sum_Pinfty sum_Minfty image_iff minus_ereal_def)+)"], ["", "lemma convergent_minus_iff_ereal: \"convergent (\\<lambda>x. - f x::ereal) \\<longleftrightarrow> convergent f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. convergent (\\<lambda>x. - f x) = convergent f", "unfolding convergent_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>L. (\\<lambda>x. - f x) \\<longlonglongrightarrow> L) =\n    (\\<exists>L. f \\<longlonglongrightarrow> L)", "by (metis ereal_uminus_uminus ereal_Lim_uminus)"], ["", "lemma summable_minus_ereal: \"\\<not> {-\\<infinity>, \\<infinity>} \\<subseteq> range f \\<Longrightarrow> summable (\\<lambda>n. f n) \\<Longrightarrow> summable (\\<lambda>n. - f n::ereal)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> {- \\<infinity>, \\<infinity>} \\<subseteq> range f;\n     summable f\\<rbrakk>\n    \\<Longrightarrow> summable (\\<lambda>n. - f n)", "unfolding summable_iff_convergent"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> {- \\<infinity>, \\<infinity>} \\<subseteq> range f;\n     convergent (\\<lambda>n. sum f {..<n})\\<rbrakk>\n    \\<Longrightarrow> convergent (\\<lambda>n. \\<Sum>n<n. - f n)", "by (subst setsum_negf_ereal) (auto simp: convergent_minus_iff_ereal)"], ["", "lemma (in product_prob_space) product_nn_integral_component:\n  assumes \"f \\<in> borel_measurable (M i)\"\"i \\<in> I\"\n  shows \"integral\\<^sup>N (Pi\\<^sub>M I M) (\\<lambda>x. f (x i)) = integral\\<^sup>N (M i) f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ x. f (x i) \\<partial>Pi\\<^sub>M I M =\n    integral\\<^sup>N (M i) f", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ x. f (x i) \\<partial>Pi\\<^sub>M I M =\n    integral\\<^sup>N (M i) f", "from assms"], ["proof (chain)\npicking this:\n  M.random_variable i borel f\n  i \\<in> I", "show ?thesis"], ["proof (prove)\nusing this:\n  M.random_variable i borel f\n  i \\<in> I\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ x. f (x i) \\<partial>Pi\\<^sub>M I M =\n    integral\\<^sup>N (M i) f", "apply (subst PiM_component[symmetric, OF \\<open>i \\<in> I\\<close>])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>M.random_variable i borel f; i \\<in> I\\<rbrakk>\n    \\<Longrightarrow> \\<integral>\\<^sup>+ x. f (x i)\n   \\<partial>Pi\\<^sub>M I M =\n                      integral\\<^sup>N\n                       (distr (Pi\\<^sub>M I M) (M i)\n                         (\\<lambda>\\<omega>. \\<omega> i))\n                       f", "apply (subst nn_integral_distr[OF measurable_component_singleton])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>M.random_variable i borel f; i \\<in> I\\<rbrakk>\n    \\<Longrightarrow> i \\<in> I\n 2. \\<lbrakk>M.random_variable i borel f; i \\<in> I\\<rbrakk>\n    \\<Longrightarrow> f \\<in> borel_measurable\n                               (distr (Pi\\<^sub>M I M) (M i)\n                                 (\\<lambda>x. x i))\n 3. \\<lbrakk>M.random_variable i borel f; i \\<in> I\\<rbrakk>\n    \\<Longrightarrow> \\<integral>\\<^sup>+ x. f (x i)\n   \\<partial>Pi\\<^sub>M I M =\n                      \\<integral>\\<^sup>+ x. f (x i)\n   \\<partial>Pi\\<^sub>M I M", "apply simp_all"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ x. f (x i) \\<partial>Pi\\<^sub>M I M =\n  integral\\<^sup>N (M i) f\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ennreal_inverse_le[simp]: \"inverse x \\<le> inverse y \\<longleftrightarrow> y \\<le> (x::ennreal)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (inverse x \\<le> inverse y) = (y \\<le> x)", "by (cases \"0 < x\"; cases x; cases \"0 < y\"; cases y; auto simp: top_unique inverse_ennreal)"], ["", "lemma inverse_inverse_ennreal[simp]: \"inverse (inverse x::ennreal) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inverse (inverse x) = x", "by (cases \"0 < x\"; cases x; auto simp: inverse_ennreal)"], ["", "lemma range_inverse_ennreal: \"range inverse = (UNIV::ennreal set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. surj inverse", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. surj inverse", "have \"\\<exists>x. y = inverse x\" for y :: ennreal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. y = inverse x", "by (intro exI[of _ \"inverse y\"]) simp"], ["proof (state)\nthis:\n  \\<exists>x. ?y = inverse x\n\ngoal (1 subgoal):\n 1. surj inverse", "then"], ["proof (chain)\npicking this:\n  \\<exists>x. ?y = inverse x", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>x. ?y = inverse x\n\ngoal (1 subgoal):\n 1. surj inverse", "unfolding surj_def"], ["proof (prove)\nusing this:\n  \\<exists>x. ?y = inverse x\n\ngoal (1 subgoal):\n 1. \\<forall>y. \\<exists>x. y = inverse x", "by auto"], ["proof (state)\nthis:\n  surj inverse\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma continuous_on_inverse_ennreal': \"continuous_on (UNIV :: ennreal set) inverse\""], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on UNIV inverse", "by (rule continuous_onI_antimono) (auto simp: range_inverse_ennreal)"], ["", "lemma sums_minus_ereal: \"\\<not> {- \\<infinity>, \\<infinity>} \\<subseteq> f ` UNIV \\<Longrightarrow> (\\<lambda>n. - f n::ereal) sums x \\<Longrightarrow> f sums - x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> {- \\<infinity>, \\<infinity>} \\<subseteq> range f;\n     (\\<lambda>n. - f n) sums x\\<rbrakk>\n    \\<Longrightarrow> f sums - x", "unfolding sums_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> {- \\<infinity>, \\<infinity>} \\<subseteq> range f;\n     (\\<lambda>n. \\<Sum>n<n. - f n) \\<longlonglongrightarrow> x\\<rbrakk>\n    \\<Longrightarrow> (\\<lambda>n. sum f {..<n})\n                      \\<longlonglongrightarrow> - x", "apply (subst ereal_Lim_uminus)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> {- \\<infinity>, \\<infinity>} \\<subseteq> range f;\n     (\\<lambda>n. \\<Sum>n<n. - f n) \\<longlonglongrightarrow> x\\<rbrakk>\n    \\<Longrightarrow> (\\<lambda>x. - sum f {..<x})\n                      \\<longlonglongrightarrow> - (- x)", "apply (subst (asm) setsum_negf_ereal)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n.\n       \\<not> {- \\<infinity>, \\<infinity>}\n              \\<subseteq> range f \\<Longrightarrow>\n       \\<not> {- \\<infinity>, \\<infinity>} \\<subseteq> f ` {..<n}\n 2. \\<lbrakk>\\<not> {- \\<infinity>, \\<infinity>} \\<subseteq> range f;\n     (\\<lambda>n. - sum f {..<n}) \\<longlonglongrightarrow> x\\<rbrakk>\n    \\<Longrightarrow> (\\<lambda>x. - sum f {..<x})\n                      \\<longlonglongrightarrow> - (- x)", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma suminf_minus_ereal: \"\\<not> {- \\<infinity>, \\<infinity>} \\<subseteq> f ` UNIV \\<Longrightarrow> summable f \\<Longrightarrow> (\\<Sum>n. - f n :: ereal) = - suminf f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> {- \\<infinity>, \\<infinity>} \\<subseteq> range f;\n     summable f\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>n. - f n) = - suminf f", "apply (rule sums_unique[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> {- \\<infinity>, \\<infinity>} \\<subseteq> range f;\n     summable f\\<rbrakk>\n    \\<Longrightarrow> (\\<lambda>n. - f n) sums - suminf f", "apply (rule sums_minus_ereal)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> {- \\<infinity>, \\<infinity>} \\<subseteq> range f;\n     summable f\\<rbrakk>\n    \\<Longrightarrow> \\<not> {- \\<infinity>, \\<infinity>}\n                             \\<subseteq> range (\\<lambda>n. - f n)\n 2. \\<lbrakk>\\<not> {- \\<infinity>, \\<infinity>} \\<subseteq> range f;\n     summable f\\<rbrakk>\n    \\<Longrightarrow> (\\<lambda>n. - (- f n)) sums suminf f", "apply (auto simp: ereal_uminus_eq_reorder)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"]]}